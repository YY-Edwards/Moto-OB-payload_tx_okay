
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000e2bc  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010400  80010400  00010800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009c48  80010600  80010600  00010a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  8001a248  0001a808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8001ac7c  0001b23c  2**0
                  ALLOC
  8 .bss          00003c90  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012930  000046d0  000046d0  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001b23c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001638  00000000  00000000  0001b270  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002bc4  00000000  00000000  0001c8a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ed87  00000000  00000000  0001f46c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000078a5  00000000  00000000  0004e1f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000e0d6  00000000  00000000  00055a98  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003d7c  00000000  00000000  00063b70  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008168  00000000  00000000  000678ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00012482  00000000  00000000  0006fa54  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001730  00000000  00000000  00081ed8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	a8 48       	st.h	r4[0x8],r8

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	a8 48       	st.h	r4[0x8],r8

Disassembly of section .text:

80002010 <DeviceManagement_brdcst_func>:
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	19 a9       	ld.ub	r9,r12[0x2]
80002012:	30 18       	mov	r8,1
80002014:	f0 09 18 00 	cp.b	r9,r8
80002018:	c0 61       	brne	80002024 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000201a:	48 68       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
8000201c:	70 09       	ld.w	r9,r8[0x0]
8000201e:	a1 b9       	sbr	r9,0x1
80002020:	91 09       	st.w	r8[0x0],r9
80002022:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002024:	48 38       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
80002026:	70 09       	ld.w	r9,r8[0x0]
80002028:	a1 d9       	cbr	r9,0x1
8000202a:	91 09       	st.w	r8[0x0],r9
8000202c:	5e fc       	retal	r12
8000202e:	00 00       	add	r0,r0
80002030:	00 00       	add	r0,r0
80002032:	13 60       	ld.uh	r0,--r9

80002034 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002034:	5e fc       	retal	r12

80002036 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002036:	5e fc       	retal	r12

80002038 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002038:	48 38       	lddpc	r8,80002044 <vApplicationIdleHook+0xc>
8000203a:	70 09       	ld.w	r9,r8[0x0]
8000203c:	2f f9       	sub	r9,-1
8000203e:	91 09       	st.w	r8[0x0],r9
	
}
80002040:	5e fc       	retal	r12
80002042:	00 00       	add	r0,r0
80002044:	00 00       	add	r0,r0
80002046:	0a 58       	eor	r8,r5

80002048 <app_init>:
														
		
};

void app_init(void)
{	
80002048:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
8000204a:	48 cb       	lddpc	r11,80002078 <app_init+0x30>
8000204c:	48 cc       	lddpc	r12,8000207c <app_init+0x34>
8000204e:	f0 1f 00 0d 	mcall	80002080 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
80002052:	48 dc       	lddpc	r12,80002084 <app_init+0x3c>
80002054:	f0 1f 00 0d 	mcall	80002088 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002058:	30 09       	mov	r9,0
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	1a d9       	st.w	--sp,r9
8000205e:	1a d9       	st.w	--sp,r9
80002060:	30 18       	mov	r8,1
80002062:	e0 6a 01 80 	mov	r10,384
80002066:	48 ab       	lddpc	r11,8000208c <app_init+0x44>
80002068:	48 ac       	lddpc	r12,80002090 <app_init+0x48>
8000206a:	f0 1f 00 0b 	mcall	80002094 <app_init+0x4c>
8000206e:	48 b8       	lddpc	r8,80002098 <app_init+0x50>
80002070:	91 0c       	st.w	r8[0x0],r12
80002072:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002074:	d8 02       	popm	pc
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 9c       	sub	r12,9
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 48       	sub	r8,-124
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3a e4       	mov	r4,-82
80002084:	00 00       	add	r0,r0
80002086:	00 08       	add	r8,r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	54 7c       	stdsp	sp[0x11c],r12
8000208c:	80 01       	ld.sh	r1,r0[0x0]
8000208e:	06 00       	add	r0,r3
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	27 a4       	sub	r4,122
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	9f 7c       	st.w	pc[0x1c],r12
80002098:	00 00       	add	r0,r0
8000209a:	0a 44       	or	r4,r5

8000209c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000209c:	d4 01       	pushm	lr
  log("R");
8000209e:	48 3c       	lddpc	r12,800020a8 <app_payload_tx_proc+0xc>
800020a0:	f0 1f 00 03 	mcall	800020ac <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
800020a4:	d8 02       	popm	pc
800020a6:	00 00       	add	r0,r0
800020a8:	80 01       	ld.sh	r1,r0[0x0]
800020aa:	06 08       	add	r8,r3
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	a3 40       	asr	r0,0x2

800020b0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020b0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020b2:	48 3c       	lddpc	r12,800020bc <FD_brdcst_func+0xc>
800020b4:	f0 1f 00 03 	mcall	800020c0 <FD_brdcst_func+0x10>
	
}
800020b8:	d8 02       	popm	pc
800020ba:	00 00       	add	r0,r0
800020bc:	80 01       	ld.sh	r1,r0[0x0]
800020be:	06 0c       	add	r12,r3
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	a3 40       	asr	r0,0x2

800020c4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020c4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020c6:	48 3c       	lddpc	r12,800020d0 <FD_reply_func+0xc>
800020c8:	f0 1f 00 03 	mcall	800020d4 <FD_reply_func+0x10>
	
	
}
800020cc:	d8 02       	popm	pc
800020ce:	00 00       	add	r0,r0
800020d0:	80 01       	ld.sh	r1,r0[0x0]
800020d2:	06 2c       	rsub	r12,r3
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	a3 40       	asr	r0,0x2

800020d8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_request_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_request_func+0x10>
	
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 01       	ld.sh	r1,r0[0x0]
800020e6:	06 48       	or	r8,r3
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	a3 40       	asr	r0,0x2

800020ec <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <EnOB_brdcst_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <EnOB_brdcst_func+0x10>
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 01       	ld.sh	r1,r0[0x0]
800020fa:	06 64       	and	r4,r3
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	a3 40       	asr	r0,0x2

80002100 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002100:	eb cd 40 80 	pushm	r7,lr
80002104:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002106:	19 a9       	ld.ub	r9,r12[0x2]
80002108:	30 08       	mov	r8,0
8000210a:	f0 09 18 00 	cp.b	r9,r8
8000210e:	c1 91       	brne	80002140 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002110:	19 b8       	ld.ub	r8,r12[0x3]
80002112:	30 19       	mov	r9,1
80002114:	f2 08 18 00 	cp.b	r8,r9
80002118:	c0 61       	brne	80002124 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000211a:	49 0c       	lddpc	r12,80002158 <EnOB_reply_func+0x58>
8000211c:	f0 1f 00 10 	mcall	8000215c <EnOB_reply_func+0x5c>
80002120:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002124:	58 08       	cp.w	r8,0
80002126:	c0 61       	brne	80002132 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002128:	48 ec       	lddpc	r12,80002160 <EnOB_reply_func+0x60>
8000212a:	f0 1f 00 0d 	mcall	8000215c <EnOB_reply_func+0x5c>
8000212e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002132:	1a d8       	st.w	--sp,r8
80002134:	48 cc       	lddpc	r12,80002164 <EnOB_reply_func+0x64>
80002136:	f0 1f 00 0a 	mcall	8000215c <EnOB_reply_func+0x5c>
8000213a:	2f fd       	sub	sp,-4
8000213c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002140:	48 ac       	lddpc	r12,80002168 <EnOB_reply_func+0x68>
80002142:	f0 1f 00 07 	mcall	8000215c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002146:	0f a8       	ld.ub	r8,r7[0x2]
80002148:	1a d8       	st.w	--sp,r8
8000214a:	48 9c       	lddpc	r12,8000216c <EnOB_reply_func+0x6c>
8000214c:	f0 1f 00 04 	mcall	8000215c <EnOB_reply_func+0x5c>
80002150:	2f fd       	sub	sp,-4
80002152:	e3 cd 80 80 	ldm	sp++,r7,pc
80002156:	00 00       	add	r0,r0
80002158:	80 01       	ld.sh	r1,r0[0x0]
8000215a:	06 7c       	tst	r12,r3
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	a3 40       	asr	r0,0x2
80002160:	80 01       	ld.sh	r1,r0[0x0]
80002162:	06 94       	mov	r4,r3
80002164:	80 01       	ld.sh	r1,r0[0x0]
80002166:	06 a8       	st.w	r3++,r8
80002168:	80 01       	ld.sh	r1,r0[0x0]
8000216a:	06 c0       	st.b	r3++,r0
8000216c:	80 01       	ld.sh	r1,r0[0x0]
8000216e:	06 dc       	st.w	--r3,r12

80002170 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002170:	eb cd 40 80 	pushm	r7,lr
80002174:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002176:	19 a9       	ld.ub	r9,r12[0x2]
80002178:	31 18       	mov	r8,17
8000217a:	f0 09 18 00 	cp.b	r9,r8
8000217e:	c0 61       	brne	8000218a <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002180:	48 8c       	lddpc	r12,800021a0 <SingleDetection_brdcst_func+0x30>
80002182:	f0 1f 00 09 	mcall	800021a4 <SingleDetection_brdcst_func+0x34>
80002186:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x38>
8000218c:	f0 1f 00 06 	mcall	800021a4 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002190:	0f a8       	ld.ub	r8,r7[0x2]
80002192:	1a d8       	st.w	--sp,r8
80002194:	48 6c       	lddpc	r12,800021ac <SingleDetection_brdcst_func+0x3c>
80002196:	f0 1f 00 04 	mcall	800021a4 <SingleDetection_brdcst_func+0x34>
8000219a:	2f fd       	sub	sp,-4
8000219c:	e3 cd 80 80 	ldm	sp++,r7,pc
800021a0:	80 01       	ld.sh	r1,r0[0x0]
800021a2:	06 f4       	st.b	--r3,r4
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	a3 40       	asr	r0,0x2
800021a8:	80 01       	ld.sh	r1,r0[0x0]
800021aa:	07 08       	ld.w	r8,r3++
800021ac:	80 01       	ld.sh	r1,r0[0x0]
800021ae:	07 18       	ld.sh	r8,r3++

800021b0 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021b0:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021b2:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b6:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b8:	4a bc       	lddpc	r12,80002264 <ButtonConfig_brdcst_func+0xb4>
800021ba:	f0 1f 00 2c 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021be:	0f 88       	ld.ub	r8,r7[0x0]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	4a bc       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xbc>
800021c4:	f0 1f 00 29 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c8:	1a d5       	st.w	--sp,r5
800021ca:	4a ac       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc0>
800021cc:	f0 1f 00 27 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021d0:	0f a8       	ld.ub	r8,r7[0x2]
800021d2:	1a d8       	st.w	--sp,r8
800021d4:	4a 8c       	lddpc	r12,80002274 <ButtonConfig_brdcst_func+0xc4>
800021d6:	f0 1f 00 25 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021da:	2f dd       	sub	sp,-12
800021dc:	58 05       	cp.w	r5,0
800021de:	c4 10       	breq	80002260 <ButtonConfig_brdcst_func+0xb0>
800021e0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e2:	4a 64       	lddpc	r4,80002278 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e4:	4a 63       	lddpc	r3,8000227c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e6:	4a 72       	lddpc	r2,80002280 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e8:	4a 71       	lddpc	r1,80002284 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ea:	4a 80       	lddpc	r0,80002288 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ec:	0f b9       	ld.ub	r9,r7[0x3]
800021ee:	0f c8       	ld.ub	r8,r7[0x4]
800021f0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	1a d6       	st.w	--sp,r6
800021f8:	08 9c       	mov	r12,r4
800021fa:	f0 1f 00 1c 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fe:	0f d9       	ld.ub	r9,r7[0x5]
80002200:	0f e8       	ld.ub	r8,r7[0x6]
80002202:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002206:	1a d8       	st.w	--sp,r8
80002208:	1a d6       	st.w	--sp,r6
8000220a:	06 9c       	mov	r12,r3
8000220c:	f0 1f 00 17 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002210:	0f f9       	ld.ub	r9,r7[0x7]
80002212:	ef 38 00 08 	ld.ub	r8,r7[8]
80002216:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221a:	1a d8       	st.w	--sp,r8
8000221c:	1a d6       	st.w	--sp,r6
8000221e:	04 9c       	mov	r12,r2
80002220:	f0 1f 00 12 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002224:	ef 39 00 09 	ld.ub	r9,r7[9]
80002228:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000222c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002230:	1a d8       	st.w	--sp,r8
80002232:	1a d6       	st.w	--sp,r6
80002234:	02 9c       	mov	r12,r1
80002236:	f0 1f 00 0d 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223a:	2f 8d       	sub	sp,-32
8000223c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002240:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002244:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002248:	1a d8       	st.w	--sp,r8
8000224a:	1a d6       	st.w	--sp,r6
8000224c:	00 9c       	mov	r12,r0
8000224e:	f0 1f 00 07 	mcall	80002268 <ButtonConfig_brdcst_func+0xb8>
80002252:	2f f6       	sub	r6,-1
80002254:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002256:	2f ed       	sub	sp,-8
80002258:	ec 05 18 00 	cp.b	r5,r6
8000225c:	fe 9b ff c8 	brhi	800021ec <ButtonConfig_brdcst_func+0x3c>
80002260:	d8 32       	popm	r0-r7,pc
80002262:	00 00       	add	r0,r0
80002264:	80 01       	ld.sh	r1,r0[0x0]
80002266:	07 30       	ld.ub	r0,r3++
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	a3 40       	asr	r0,0x2
8000226c:	80 01       	ld.sh	r1,r0[0x0]
8000226e:	07 50       	ld.sh	r0,--r3
80002270:	80 01       	ld.sh	r1,r0[0x0]
80002272:	07 64       	ld.uh	r4,--r3
80002274:	80 01       	ld.sh	r1,r0[0x0]
80002276:	07 7c       	ld.ub	r12,--r3
80002278:	80 01       	ld.sh	r1,r0[0x0]
8000227a:	07 9c       	ld.ub	r12,r3[0x1]
8000227c:	80 01       	ld.sh	r1,r0[0x0]
8000227e:	07 c4       	ld.ub	r4,r3[0x4]
80002280:	80 01       	ld.sh	r1,r0[0x0]
80002282:	07 ec       	ld.ub	r12,r3[0x6]
80002284:	80 01       	ld.sh	r1,r0[0x0]
80002286:	08 10       	sub	r0,r4
80002288:	80 01       	ld.sh	r1,r0[0x0]
8000228a:	08 38       	cp.w	r8,r4

8000228c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000228c:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002290:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
80002292:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002294:	19 c7       	ld.ub	r7,r12[0x4]
80002296:	19 d8       	ld.ub	r8,r12[0x5]
80002298:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
8000229c:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000229e:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022a0:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022a4:	49 0c       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x58>
800022a6:	f0 1f 00 11 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	49 0c       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x60>
800022ae:	f0 1f 00 0f 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022b2:	1a d5       	st.w	--sp,r5
800022b4:	48 fc       	lddpc	r12,800022f0 <Phyuserinput_brdcst_func+0x64>
800022b6:	f0 1f 00 0d 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022ba:	5c 77       	castu.h	r7
800022bc:	1a d7       	st.w	--sp,r7
800022be:	48 ec       	lddpc	r12,800022f4 <Phyuserinput_brdcst_func+0x68>
800022c0:	f0 1f 00 0a 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022c4:	1a d4       	st.w	--sp,r4
800022c6:	48 dc       	lddpc	r12,800022f8 <Phyuserinput_brdcst_func+0x6c>
800022c8:	f0 1f 00 08 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022cc:	1a d3       	st.w	--sp,r3
800022ce:	48 cc       	lddpc	r12,800022fc <Phyuserinput_brdcst_func+0x70>
800022d0:	f0 1f 00 06 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022d4:	1a d2       	st.w	--sp,r2
800022d6:	48 bc       	lddpc	r12,80002300 <Phyuserinput_brdcst_func+0x74>
800022d8:	f0 1f 00 04 	mcall	800022e8 <Phyuserinput_brdcst_func+0x5c>
800022dc:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022de:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022e2:	00 00       	add	r0,r0
800022e4:	80 01       	ld.sh	r1,r0[0x0]
800022e6:	08 5c       	eor	r12,r4
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	a3 40       	asr	r0,0x2
800022ec:	80 01       	ld.sh	r1,r0[0x0]
800022ee:	08 80       	andn	r0,r4
800022f0:	80 01       	ld.sh	r1,r0[0x0]
800022f2:	08 98       	mov	r8,r4
800022f4:	80 01       	ld.sh	r1,r0[0x0]
800022f6:	08 ac       	st.w	r4++,r12
800022f8:	80 01       	ld.sh	r1,r0[0x0]
800022fa:	08 c0       	st.b	r4++,r0
800022fc:	80 01       	ld.sh	r1,r0[0x0]
800022fe:	08 d4       	st.w	--r4,r4
80002300:	80 01       	ld.sh	r1,r0[0x0]
80002302:	08 f4       	st.b	--r4,r4

80002304 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 c1       	brne	8000232c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002316:	48 9c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x34>
80002318:	f0 1f 00 09 	mcall	8000233c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000231c:	0f 98       	ld.ub	r8,r7[0x1]
8000231e:	1a d8       	st.w	--sp,r8
80002320:	48 8c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x3c>
80002322:	f0 1f 00 07 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002326:	2f fd       	sub	sp,-4
80002328:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000232c:	48 6c       	lddpc	r12,80002344 <ButtonConfig_reply_func+0x40>
8000232e:	f0 1f 00 04 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 01       	ld.sh	r1,r0[0x0]
8000233a:	09 14       	ld.sh	r4,r4++
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	a3 40       	asr	r0,0x2
80002340:	80 01       	ld.sh	r1,r0[0x0]
80002342:	07 50       	ld.sh	r0,--r3
80002344:	80 01       	ld.sh	r1,r0[0x0]
80002346:	09 2c       	ld.uh	r12,r4++

80002348 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002348:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000234a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000234e:	0d 88       	ld.ub	r8,r6[0x0]
80002350:	32 49       	mov	r9,36
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c2 91       	brne	800023a8 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002358:	49 7c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x6c>
8000235a:	f0 1f 00 18 	mcall	800023b8 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	49 4c       	lddpc	r12,800023bc <DataSession_brdcst_func+0x74>
8000236e:	f0 1f 00 13 	mcall	800023b8 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	49 2c       	lddpc	r12,800023c0 <DataSession_brdcst_func+0x78>
8000237a:	f0 1f 00 10 	mcall	800023b8 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c1 80       	breq	800023b2 <DataSession_brdcst_func+0x6a>
80002384:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	49 04       	lddpc	r4,800023c4 <DataSession_brdcst_func+0x7c>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 09 	mcall	800023b8 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0x40>
800023a6:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	48 8c       	lddpc	r12,800023c8 <DataSession_brdcst_func+0x80>
800023ac:	f0 1f 00 03 	mcall	800023b8 <DataSession_brdcst_func+0x70>
800023b0:	2f fd       	sub	sp,-4
800023b2:	d8 22       	popm	r4-r7,pc
800023b4:	80 01       	ld.sh	r1,r0[0x0]
800023b6:	09 48       	ld.w	r8,--r4
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	a3 40       	asr	r0,0x2
800023bc:	80 01       	ld.sh	r1,r0[0x0]
800023be:	09 5c       	ld.sh	r12,--r4
800023c0:	80 01       	ld.sh	r1,r0[0x0]
800023c2:	09 74       	ld.ub	r4,--r4
800023c4:	80 01       	ld.sh	r1,r0[0x0]
800023c6:	09 90       	ld.ub	r0,r4[0x1]
800023c8:	80 01       	ld.sh	r1,r0[0x0]
800023ca:	09 a8       	ld.ub	r8,r4[0x2]

800023cc <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
800023d0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023d2:	19 a8       	ld.ub	r8,r12[0x2]
800023d4:	58 08       	cp.w	r8,0
800023d6:	c0 61       	brne	800023e2 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023d8:	48 dc       	lddpc	r12,8000240c <DataSession_reply_func+0x40>
800023da:	f0 1f 00 0e 	mcall	80002410 <DataSession_reply_func+0x44>
800023de:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	48 cc       	lddpc	r12,80002414 <DataSession_reply_func+0x48>
800023e6:	f0 1f 00 0b 	mcall	80002410 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023ea:	48 cc       	lddpc	r12,80002418 <DataSession_reply_func+0x4c>
800023ec:	f0 1f 00 09 	mcall	80002410 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023f0:	0f b8       	ld.ub	r8,r7[0x3]
800023f2:	1a d8       	st.w	--sp,r8
800023f4:	48 ac       	lddpc	r12,8000241c <DataSession_reply_func+0x50>
800023f6:	f0 1f 00 07 	mcall	80002410 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023fa:	0f c8       	ld.ub	r8,r7[0x4]
800023fc:	1a d8       	st.w	--sp,r8
800023fe:	48 9c       	lddpc	r12,80002420 <DataSession_reply_func+0x54>
80002400:	f0 1f 00 04 	mcall	80002410 <DataSession_reply_func+0x44>
80002404:	2f dd       	sub	sp,-12
80002406:	e3 cd 80 80 	ldm	sp++,r7,pc
8000240a:	00 00       	add	r0,r0
8000240c:	80 01       	ld.sh	r1,r0[0x0]
8000240e:	09 bc       	ld.ub	r12,r4[0x3]
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	a3 40       	asr	r0,0x2
80002414:	80 01       	ld.sh	r1,r0[0x0]
80002416:	09 d0       	ld.ub	r0,r4[0x5]
80002418:	80 01       	ld.sh	r1,r0[0x0]
8000241a:	09 e4       	ld.ub	r4,r4[0x6]
8000241c:	80 01       	ld.sh	r1,r0[0x0]
8000241e:	09 f8       	ld.ub	r8,r4[0x7]
80002420:	80 01       	ld.sh	r1,r0[0x0]
80002422:	0a 08       	add	r8,r5

80002424 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002424:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002428:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000242c:	0f 89       	ld.ub	r9,r7[0x0]
8000242e:	30 08       	mov	r8,0
80002430:	f0 09 18 00 	cp.b	r9,r8
80002434:	c2 21       	brne	80002478 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002436:	49 4c       	lddpc	r12,80002484 <TransmitControl_reply_func+0x60>
80002438:	f0 1f 00 14 	mcall	80002488 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
8000243c:	0f 98       	ld.ub	r8,r7[0x1]
8000243e:	1a d8       	st.w	--sp,r8
80002440:	49 3c       	lddpc	r12,8000248c <TransmitControl_reply_func+0x68>
80002442:	f0 1f 00 12 	mcall	80002488 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002446:	0f a8       	ld.ub	r8,r7[0x2]
80002448:	1a d8       	st.w	--sp,r8
8000244a:	49 2c       	lddpc	r12,80002490 <TransmitControl_reply_func+0x6c>
8000244c:	f0 1f 00 0f 	mcall	80002488 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002450:	0f b8       	ld.ub	r8,r7[0x3]
80002452:	1a d8       	st.w	--sp,r8
80002454:	49 0c       	lddpc	r12,80002494 <TransmitControl_reply_func+0x70>
80002456:	f0 1f 00 0d 	mcall	80002488 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
8000245a:	0f 98       	ld.ub	r8,r7[0x1]
8000245c:	2f dd       	sub	sp,-12
8000245e:	30 19       	mov	r9,1
80002460:	f2 08 18 00 	cp.b	r8,r9
80002464:	c0 d0       	breq	8000247e <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
80002466:	30 29       	mov	r9,2
80002468:	f2 08 18 00 	cp.b	r8,r9
8000246c:	c0 91       	brne	8000247e <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
8000246e:	30 09       	mov	r9,0
80002470:	48 a8       	lddpc	r8,80002498 <TransmitControl_reply_func+0x74>
80002472:	b0 89       	st.b	r8[0x0],r9
80002474:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002478:	48 9c       	lddpc	r12,8000249c <TransmitControl_reply_func+0x78>
8000247a:	f0 1f 00 04 	mcall	80002488 <TransmitControl_reply_func+0x64>
8000247e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002482:	00 00       	add	r0,r0
80002484:	80 01       	ld.sh	r1,r0[0x0]
80002486:	0a 18       	sub	r8,r5
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	a3 40       	asr	r0,0x2
8000248c:	80 01       	ld.sh	r1,r0[0x0]
8000248e:	0a 34       	cp.w	r4,r5
80002490:	80 01       	ld.sh	r1,r0[0x0]
80002492:	0a 48       	or	r8,r5
80002494:	80 01       	ld.sh	r1,r0[0x0]
80002496:	0a 64       	and	r4,r5
80002498:	00 00       	add	r0,r0
8000249a:	0a 4a       	or	r10,r5
8000249c:	80 01       	ld.sh	r1,r0[0x0]
8000249e:	0a 74       	tst	r4,r5

800024a0 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024a0:	eb cd 40 f8 	pushm	r3-r7,lr
800024a4:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
800024a6:	19 a5       	ld.ub	r5,r12[0x2]
800024a8:	19 b8       	ld.ub	r8,r12[0x3]
800024aa:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800024ae:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
800024b0:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024b4:	1a d8       	st.w	--sp,r8
800024b6:	49 6c       	lddpc	r12,8000250c <AudioRoutingControl_brdcst_func+0x6c>
800024b8:	f0 1f 00 16 	mcall	80002510 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024bc:	2f fd       	sub	sp,-4
800024be:	58 05       	cp.w	r5,0
800024c0:	c0 31       	brne	800024c6 <AudioRoutingControl_brdcst_func+0x26>
800024c2:	30 07       	mov	r7,0
800024c4:	c1 98       	rjmp	800024f6 <AudioRoutingControl_brdcst_func+0x56>
800024c6:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024c8:	49 34       	lddpc	r4,80002514 <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024ca:	49 43       	lddpc	r3,80002518 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024cc:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024d0:	11 c8       	ld.ub	r8,r8[0x4]
800024d2:	1a d8       	st.w	--sp,r8
800024d4:	08 9c       	mov	r12,r4
800024d6:	f0 1f 00 0f 	mcall	80002510 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024da:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024de:	11 d8       	ld.ub	r8,r8[0x5]
800024e0:	1a d8       	st.w	--sp,r8
800024e2:	06 9c       	mov	r12,r3
800024e4:	f0 1f 00 0b 	mcall	80002510 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024e8:	2f f7       	sub	r7,-1
800024ea:	5c 57       	castu.b	r7
800024ec:	2f ed       	sub	sp,-8
800024ee:	ee 05 19 00 	cp.h	r5,r7
800024f2:	fe 9b ff ed 	brhi	800024cc <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024f6:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024fa:	0f c8       	ld.ub	r8,r7[0x4]
800024fc:	1a d8       	st.w	--sp,r8
800024fe:	48 8c       	lddpc	r12,8000251c <AudioRoutingControl_brdcst_func+0x7c>
80002500:	f0 1f 00 04 	mcall	80002510 <AudioRoutingControl_brdcst_func+0x70>
80002504:	2f fd       	sub	sp,-4
	
	
	
}
80002506:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000250a:	00 00       	add	r0,r0
8000250c:	80 01       	ld.sh	r1,r0[0x0]
8000250e:	0a 8c       	andn	r12,r5
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	a3 40       	asr	r0,0x2
80002514:	80 01       	ld.sh	r1,r0[0x0]
80002516:	0a a4       	st.w	r5++,r4
80002518:	80 01       	ld.sh	r1,r0[0x0]
8000251a:	0a bc       	st.h	r5++,r12
8000251c:	80 01       	ld.sh	r1,r0[0x0]
8000251e:	0a d4       	st.w	--r5,r4

80002520 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002520:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002524:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002528:	0f 89       	ld.ub	r9,r7[0x0]
8000252a:	0f 98       	ld.ub	r8,r7[0x1]
8000252c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002530:	1a d8       	st.w	--sp,r8
80002532:	48 6c       	lddpc	r12,80002548 <Volume_brdcst_func+0x28>
80002534:	f0 1f 00 06 	mcall	8000254c <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002538:	0f b8       	ld.ub	r8,r7[0x3]
8000253a:	1a d8       	st.w	--sp,r8
8000253c:	48 5c       	lddpc	r12,80002550 <Volume_brdcst_func+0x30>
8000253e:	f0 1f 00 04 	mcall	8000254c <Volume_brdcst_func+0x2c>
80002542:	2f ed       	sub	sp,-8
	
	
}
80002544:	e3 cd 80 80 	ldm	sp++,r7,pc
80002548:	80 01       	ld.sh	r1,r0[0x0]
8000254a:	0a f0       	st.b	--r5,r0
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	a3 40       	asr	r0,0x2
80002550:	80 01       	ld.sh	r1,r0[0x0]
80002552:	0b 0c       	ld.w	r12,r5++

80002554 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002558:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000255c:	0f 89       	ld.ub	r9,r7[0x0]
8000255e:	30 08       	mov	r8,0
80002560:	f0 09 18 00 	cp.b	r9,r8
80002564:	c1 b1       	brne	8000259a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002566:	0f b8       	ld.ub	r8,r7[0x3]
80002568:	31 09       	mov	r9,16
8000256a:	f2 08 18 00 	cp.b	r8,r9
8000256e:	c0 f1       	brne	8000258c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002570:	48 dc       	lddpc	r12,800025a4 <Volume_reply_func+0x50>
80002572:	f0 1f 00 0e 	mcall	800025a8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002576:	0f 99       	ld.ub	r9,r7[0x1]
80002578:	0f a8       	ld.ub	r8,r7[0x2]
8000257a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 bc       	lddpc	r12,800025ac <Volume_reply_func+0x58>
80002582:	f0 1f 00 0a 	mcall	800025a8 <Volume_reply_func+0x54>
80002586:	2f fd       	sub	sp,-4
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000258c:	1a d8       	st.w	--sp,r8
8000258e:	48 9c       	lddpc	r12,800025b0 <Volume_reply_func+0x5c>
80002590:	f0 1f 00 06 	mcall	800025a8 <Volume_reply_func+0x54>
80002594:	2f fd       	sub	sp,-4
80002596:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000259a:	48 7c       	lddpc	r12,800025b4 <Volume_reply_func+0x60>
8000259c:	f0 1f 00 03 	mcall	800025a8 <Volume_reply_func+0x54>
800025a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a4:	80 01       	ld.sh	r1,r0[0x0]
800025a6:	0b 28       	ld.uh	r8,r5++
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	a3 40       	asr	r0,0x2
800025ac:	80 01       	ld.sh	r1,r0[0x0]
800025ae:	0a f0       	st.b	--r5,r0
800025b0:	80 01       	ld.sh	r1,r0[0x0]
800025b2:	0b 3c       	ld.ub	r12,r5++
800025b4:	80 01       	ld.sh	r1,r0[0x0]
800025b6:	0b 54       	ld.sh	r4,--r5

800025b8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ba:	19 d9       	ld.ub	r9,r12[0x5]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 91       	brne	800025d4 <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025c4:	48 89       	lddpc	r9,800025e4 <spk_brdcst_func+0x2c>
800025c6:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025c8:	48 89       	lddpc	r9,800025e8 <spk_brdcst_func+0x30>
800025ca:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025cc:	48 8c       	lddpc	r12,800025ec <spk_brdcst_func+0x34>
800025ce:	f0 1f 00 09 	mcall	800025f0 <spk_brdcst_func+0x38>
800025d2:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025d4:	30 19       	mov	r9,1
800025d6:	48 58       	lddpc	r8,800025e8 <spk_brdcst_func+0x30>
800025d8:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
800025da:	48 7c       	lddpc	r12,800025f4 <spk_brdcst_func+0x3c>
800025dc:	f0 1f 00 05 	mcall	800025f0 <spk_brdcst_func+0x38>
800025e0:	d8 02       	popm	pc
800025e2:	00 00       	add	r0,r0
800025e4:	00 00       	add	r0,r0
800025e6:	0a 4a       	or	r10,r5
800025e8:	00 00       	add	r0,r0
800025ea:	0a 54       	eor	r4,r5
800025ec:	80 01       	ld.sh	r1,r0[0x0]
800025ee:	0b 6c       	ld.uh	r12,--r5
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	a3 40       	asr	r0,0x2
800025f4:	80 01       	ld.sh	r1,r0[0x0]
800025f6:	0b 7c       	ld.ub	r12,--r5

800025f8 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025f8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025fa:	19 a9       	ld.ub	r9,r12[0x2]
800025fc:	30 08       	mov	r8,0
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 f1       	brne	80002620 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002604:	19 e9       	ld.ub	r9,r12[0x6]
80002606:	f0 09 18 00 	cp.b	r9,r8
8000260a:	c0 40       	breq	80002612 <spk_reply_func+0x1a>
		{
			is_unmute = 1;
8000260c:	30 19       	mov	r9,1
8000260e:	48 78       	lddpc	r8,80002628 <spk_reply_func+0x30>
80002610:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002612:	19 e8       	ld.ub	r8,r12[0x6]
80002614:	1a d8       	st.w	--sp,r8
80002616:	48 6c       	lddpc	r12,8000262c <spk_reply_func+0x34>
80002618:	f0 1f 00 06 	mcall	80002630 <spk_reply_func+0x38>
8000261c:	2f fd       	sub	sp,-4
8000261e:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002620:	48 5c       	lddpc	r12,80002634 <spk_reply_func+0x3c>
80002622:	f0 1f 00 04 	mcall	80002630 <spk_reply_func+0x38>
80002626:	d8 02       	popm	pc
80002628:	00 00       	add	r0,r0
8000262a:	0a 4a       	or	r10,r5
8000262c:	80 01       	ld.sh	r1,r0[0x0]
8000262e:	0b 88       	ld.ub	r8,r5[0x0]
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	a3 40       	asr	r0,0x2
80002634:	80 01       	ld.sh	r1,r0[0x0]
80002636:	0b 98       	ld.ub	r8,r5[0x1]

80002638 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002638:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000263c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002640:	49 ac       	lddpc	r12,800026a8 <mic_reply_func+0x70>
80002642:	f0 1f 00 1b 	mcall	800026ac <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002646:	0f 89       	ld.ub	r9,r7[0x0]
80002648:	30 08       	mov	r8,0
8000264a:	f0 09 18 00 	cp.b	r9,r8
8000264e:	c2 71       	brne	8000269c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002650:	0f 98       	ld.ub	r8,r7[0x1]
80002652:	30 29       	mov	r9,2
80002654:	f2 08 18 00 	cp.b	r8,r9
80002658:	c1 b1       	brne	8000268e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000265a:	49 6c       	lddpc	r12,800026b0 <mic_reply_func+0x78>
8000265c:	f0 1f 00 14 	mcall	800026ac <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002660:	0f a8       	ld.ub	r8,r7[0x2]
80002662:	1a d8       	st.w	--sp,r8
80002664:	49 4c       	lddpc	r12,800026b4 <mic_reply_func+0x7c>
80002666:	f0 1f 00 12 	mcall	800026ac <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000266a:	0f b8       	ld.ub	r8,r7[0x3]
8000266c:	1a d8       	st.w	--sp,r8
8000266e:	49 3c       	lddpc	r12,800026b8 <mic_reply_func+0x80>
80002670:	f0 1f 00 0f 	mcall	800026ac <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002674:	0f c8       	ld.ub	r8,r7[0x4]
80002676:	1a d8       	st.w	--sp,r8
80002678:	49 1c       	lddpc	r12,800026bc <mic_reply_func+0x84>
8000267a:	f0 1f 00 0d 	mcall	800026ac <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000267e:	0f d8       	ld.ub	r8,r7[0x5]
80002680:	1a d8       	st.w	--sp,r8
80002682:	49 0c       	lddpc	r12,800026c0 <mic_reply_func+0x88>
80002684:	f0 1f 00 0a 	mcall	800026ac <mic_reply_func+0x74>
80002688:	2f cd       	sub	sp,-16
8000268a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000268e:	1a d8       	st.w	--sp,r8
80002690:	48 dc       	lddpc	r12,800026c4 <mic_reply_func+0x8c>
80002692:	f0 1f 00 07 	mcall	800026ac <mic_reply_func+0x74>
80002696:	2f fd       	sub	sp,-4
80002698:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000269c:	48 bc       	lddpc	r12,800026c8 <mic_reply_func+0x90>
8000269e:	f0 1f 00 04 	mcall	800026ac <mic_reply_func+0x74>
800026a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026a6:	00 00       	add	r0,r0
800026a8:	80 01       	ld.sh	r1,r0[0x0]
800026aa:	0b a4       	ld.ub	r4,r5[0x2]
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	a3 40       	asr	r0,0x2
800026b0:	80 01       	ld.sh	r1,r0[0x0]
800026b2:	0b b4       	ld.ub	r4,r5[0x3]
800026b4:	80 01       	ld.sh	r1,r0[0x0]
800026b6:	0b c8       	ld.ub	r8,r5[0x4]
800026b8:	80 01       	ld.sh	r1,r0[0x0]
800026ba:	0b dc       	ld.ub	r12,r5[0x5]
800026bc:	80 01       	ld.sh	r1,r0[0x0]
800026be:	0b f8       	ld.ub	r8,r5[0x7]
800026c0:	80 01       	ld.sh	r1,r0[0x0]
800026c2:	0c 10       	sub	r0,r6
800026c4:	80 01       	ld.sh	r1,r0[0x0]
800026c6:	0c 28       	rsub	r8,r6
800026c8:	80 01       	ld.sh	r1,r0[0x0]
800026ca:	0c 40       	or	r0,r6

800026cc <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026cc:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026d0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026d4:	48 bc       	lddpc	r12,80002700 <dcm_brdcst_func+0x34>
800026d6:	f0 1f 00 0c 	mcall	80002704 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026da:	0f 88       	ld.ub	r8,r7[0x0]
800026dc:	1a d8       	st.w	--sp,r8
800026de:	48 bc       	lddpc	r12,80002708 <dcm_brdcst_func+0x3c>
800026e0:	f0 1f 00 09 	mcall	80002704 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026e4:	0f a8       	ld.ub	r8,r7[0x2]
800026e6:	1a d8       	st.w	--sp,r8
800026e8:	48 9c       	lddpc	r12,8000270c <dcm_brdcst_func+0x40>
800026ea:	f0 1f 00 07 	mcall	80002704 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800026ee:	0f 98       	ld.ub	r8,r7[0x1]
800026f0:	1a d8       	st.w	--sp,r8
800026f2:	48 8c       	lddpc	r12,80002710 <dcm_brdcst_func+0x44>
800026f4:	f0 1f 00 04 	mcall	80002704 <dcm_brdcst_func+0x38>
800026f8:	2f dd       	sub	sp,-12
	
	
}
800026fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fe:	00 00       	add	r0,r0
80002700:	80 01       	ld.sh	r1,r0[0x0]
80002702:	0c 50       	eor	r0,r6
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	a3 40       	asr	r0,0x2
80002708:	80 01       	ld.sh	r1,r0[0x0]
8000270a:	0c 64       	and	r4,r6
8000270c:	80 01       	ld.sh	r1,r0[0x0]
8000270e:	0c 78       	tst	r8,r6
80002710:	80 01       	ld.sh	r1,r0[0x0]
80002712:	0c 90       	mov	r0,r6

80002714 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	eb cd 40 80 	pushm	r7,lr
80002718:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271a:	19 a9       	ld.ub	r9,r12[0x2]
8000271c:	30 08       	mov	r8,0
8000271e:	f0 09 18 00 	cp.b	r9,r8
80002722:	c1 b1       	brne	80002758 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002724:	19 b8       	ld.ub	r8,r12[0x3]
80002726:	30 19       	mov	r9,1
80002728:	f2 08 18 00 	cp.b	r8,r9
8000272c:	c0 51       	brne	80002736 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000272e:	48 ec       	lddpc	r12,80002764 <dcm_reply_func+0x50>
80002730:	f0 1f 00 0e 	mcall	80002768 <dcm_reply_func+0x54>
80002734:	c0 a8       	rjmp	80002748 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002736:	58 08       	cp.w	r8,0
80002738:	c0 51       	brne	80002742 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000273a:	48 dc       	lddpc	r12,8000276c <dcm_reply_func+0x58>
8000273c:	f0 1f 00 0b 	mcall	80002768 <dcm_reply_func+0x54>
80002740:	c0 48       	rjmp	80002748 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002742:	48 cc       	lddpc	r12,80002770 <dcm_reply_func+0x5c>
80002744:	f0 1f 00 09 	mcall	80002768 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002748:	0f d8       	ld.ub	r8,r7[0x5]
8000274a:	1a d8       	st.w	--sp,r8
8000274c:	48 ac       	lddpc	r12,80002774 <dcm_reply_func+0x60>
8000274e:	f0 1f 00 07 	mcall	80002768 <dcm_reply_func+0x54>
80002752:	2f fd       	sub	sp,-4
80002754:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002758:	48 8c       	lddpc	r12,80002778 <dcm_reply_func+0x64>
8000275a:	f0 1f 00 04 	mcall	80002768 <dcm_reply_func+0x54>
8000275e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002762:	00 00       	add	r0,r0
80002764:	80 01       	ld.sh	r1,r0[0x0]
80002766:	0c ac       	st.w	r6++,r12
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	a3 40       	asr	r0,0x2
8000276c:	80 01       	ld.sh	r1,r0[0x0]
8000276e:	0c c0       	st.b	r6++,r0
80002770:	80 01       	ld.sh	r1,r0[0x0]
80002772:	0c d4       	st.w	--r6,r4
80002774:	80 01       	ld.sh	r1,r0[0x0]
80002776:	0c e8       	st.h	--r6,r8
80002778:	80 01       	ld.sh	r1,r0[0x0]
8000277a:	0c f4       	st.b	--r6,r4

8000277c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000277c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000277e:	19 a9       	ld.ub	r9,r12[0x2]
80002780:	30 08       	mov	r8,0
80002782:	f0 09 18 00 	cp.b	r9,r8
80002786:	c0 51       	brne	80002790 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002788:	48 4c       	lddpc	r12,80002798 <ToneControl_reply_func+0x1c>
8000278a:	f0 1f 00 05 	mcall	8000279c <ToneControl_reply_func+0x20>
8000278e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002790:	48 4c       	lddpc	r12,800027a0 <ToneControl_reply_func+0x24>
80002792:	f0 1f 00 03 	mcall	8000279c <ToneControl_reply_func+0x20>
80002796:	d8 02       	popm	pc
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	0d 00       	ld.w	r0,r6++
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	a3 40       	asr	r0,0x2
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	0d 08       	ld.w	r8,r6++

800027a4 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027a4:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027a6:	f0 1f 00 1d 	mcall	80002818 <app_cfg+0x74>
800027aa:	49 d8       	lddpc	r8,8000281c <app_cfg+0x78>
800027ac:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027ae:	49 d6       	lddpc	r6,80002820 <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027b0:	49 d5       	lddpc	r5,80002824 <app_cfg+0x80>
				{
					isAudioRouting++;
				}

				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027b2:	49 e4       	lddpc	r4,80002828 <app_cfg+0x84>
800027b4:	49 e3       	lddpc	r3,8000282c <app_cfg+0x88>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027b6:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027b8:	30 21       	mov	r1,2
					xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ba:	30 12       	mov	r2,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
800027bc:	10 97       	mov	r7,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027be:	6c 08       	ld.w	r8,r6[0x0]
800027c0:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027c4:	58 38       	cp.w	r8,3
800027c6:	c2 31       	brne	8000280c <app_cfg+0x68>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027c8:	6a 08       	ld.w	r8,r5[0x0]
800027ca:	58 08       	cp.w	r8,0
800027cc:	c0 51       	brne	800027d6 <app_cfg+0x32>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027ce:	f0 1f 00 19 	mcall	80002830 <app_cfg+0x8c>
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027d2:	8b 02       	st.w	r5[0x0],r2
800027d4:	c1 68       	rjmp	80002800 <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
800027d6:	58 18       	cp.w	r8,1
800027d8:	c0 51       	brne	800027e2 <app_cfg+0x3e>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
800027da:	f0 1f 00 17 	mcall	80002834 <app_cfg+0x90>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027de:	8b 01       	st.w	r5[0x0],r1
800027e0:	c1 08       	rjmp	80002800 <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800027e2:	58 28       	cp.w	r8,2
800027e4:	c0 51       	brne	800027ee <app_cfg+0x4a>
				{
					
					xcmp_exit_device_control_mode();
800027e6:	f0 1f 00 15 	mcall	80002838 <app_cfg+0x94>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027ea:	8b 00       	st.w	r5[0x0],r0
800027ec:	c0 a8       	rjmp	80002800 <app_cfg+0x5c>
					
				}
				else if(isAudioRouting == 3)
800027ee:	58 38       	cp.w	r8,3
800027f0:	c0 61       	brne	800027fc <app_cfg+0x58>
				{
					xcmp_audio_route_AMBE();
800027f2:	f0 1f 00 13 	mcall	8000283c <app_cfg+0x98>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027f6:	30 48       	mov	r8,4
800027f8:	8b 08       	st.w	r5[0x0],r8
800027fa:	c0 38       	rjmp	80002800 <app_cfg+0x5c>
					
				}
				else
				{
					isAudioRouting++;
800027fc:	2f f8       	sub	r8,-1
800027fe:	8b 08       	st.w	r5[0x0],r8
				}

				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
80002800:	07 88       	ld.ub	r8,r3[0x0]
80002802:	1a d8       	st.w	--sp,r8
80002804:	08 9c       	mov	r12,r4
80002806:	f0 1f 00 0f 	mcall	80002840 <app_cfg+0x9c>
8000280a:	2f fd       	sub	sp,-4
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
8000280c:	e0 6b 0f a0 	mov	r11,4000
80002810:	0e 9c       	mov	r12,r7
80002812:	f0 1f 00 0d 	mcall	80002844 <app_cfg+0xa0>
	}
80002816:	cd 4b       	rjmp	800027be <app_cfg+0x1a>
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	9c b4       	ld.uh	r4,lr[0x6]
8000281c:	00 00       	add	r0,r0
8000281e:	0a 50       	eor	r0,r5
80002820:	00 00       	add	r0,r0
80002822:	13 60       	ld.uh	r0,--r9
80002824:	00 00       	add	r0,r0
80002826:	0a 4c       	or	r12,r5
80002828:	80 01       	ld.sh	r1,r0[0x0]
8000282a:	0d 14       	ld.sh	r4,r6++
8000282c:	00 00       	add	r0,r0
8000282e:	0a 4a       	or	r10,r5
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	55 00       	stdsp	sp[0x140],r0
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	55 78       	stdsp	sp[0x15c],r8
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	54 d0       	stdsp	sp[0x134],r0
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	55 2c       	stdsp	sp[0x148],r12
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	a3 40       	asr	r0,0x2
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	9e 1c       	ld.sh	r12,pc[0x2]

80002848 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002848:	eb cd 40 80 	pushm	r7,lr
8000284c:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
8000284e:	48 cc       	lddpc	r12,8000287c <app_payload_rx_proc+0x34>
80002850:	f0 1f 00 0c 	mcall	80002880 <app_payload_rx_proc+0x38>
	if (AMBE_tx_flag)//mic
80002854:	48 c8       	lddpc	r8,80002884 <app_payload_rx_proc+0x3c>
80002856:	11 89       	ld.ub	r9,r8[0x0]
80002858:	30 08       	mov	r8,0
8000285a:	f0 09 18 00 	cp.b	r9,r8
8000285e:	c0 80       	breq	8000286e <app_payload_rx_proc+0x26>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
80002860:	e0 69 02 00 	mov	r9,512
80002864:	0e 9a       	mov	r10,r7
80002866:	3f fb       	mov	r11,-1
80002868:	48 8c       	lddpc	r12,80002888 <app_payload_rx_proc+0x40>
8000286a:	f0 1f 00 09 	mcall	8000288c <app_payload_rx_proc+0x44>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000286e:	48 98       	lddpc	r8,80002890 <app_payload_rx_proc+0x48>
80002870:	70 0c       	ld.w	r12,r8[0x0]
80002872:	0e 9b       	mov	r11,r7
80002874:	f0 1f 00 08 	mcall	80002894 <app_payload_rx_proc+0x4c>

}
80002878:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287c:	80 01       	ld.sh	r1,r0[0x0]
8000287e:	0d 24       	ld.uh	r4,r6++
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	a3 40       	asr	r0,0x2
80002884:	00 00       	add	r0,r0
80002886:	0a 48       	or	r8,r5
80002888:	80 01       	ld.sh	r1,r0[0x0]
8000288a:	0d 30       	ld.ub	r0,r6++
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	34 fc       	mov	r12,79
80002890:	00 00       	add	r0,r0
80002892:	10 20       	rsub	r0,r8
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	3c 2c       	mov	r12,-62

80002898 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002898:	eb cd 40 80 	pushm	r7,lr
8000289c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000289e:	19 a9       	ld.ub	r9,r12[0x2]
800028a0:	30 08       	mov	r8,0
800028a2:	f0 09 18 00 	cp.b	r9,r8
800028a6:	c0 81       	brne	800028b6 <AudioRoutingControl_reply_func+0x1e>
	{
		log("AudioRouting OK");
800028a8:	48 9c       	lddpc	r12,800028cc <AudioRoutingControl_reply_func+0x34>
800028aa:	f0 1f 00 0a 	mcall	800028d0 <AudioRoutingControl_reply_func+0x38>
		xcmp_IdleTestTone();//
800028ae:	f0 1f 00 0a 	mcall	800028d4 <AudioRoutingControl_reply_func+0x3c>
800028b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800028b6:	48 9c       	lddpc	r12,800028d8 <AudioRoutingControl_reply_func+0x40>
800028b8:	f0 1f 00 06 	mcall	800028d0 <AudioRoutingControl_reply_func+0x38>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
800028bc:	0f a8       	ld.ub	r8,r7[0x2]
800028be:	1a d8       	st.w	--sp,r8
800028c0:	48 7c       	lddpc	r12,800028dc <AudioRoutingControl_reply_func+0x44>
800028c2:	f0 1f 00 04 	mcall	800028d0 <AudioRoutingControl_reply_func+0x38>
800028c6:	2f fd       	sub	sp,-4
800028c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028cc:	80 01       	ld.sh	r1,r0[0x0]
800028ce:	0d 3c       	ld.ub	r12,r6++
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	a3 40       	asr	r0,0x2
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	56 48       	stdsp	sp[0x190],r8
800028d8:	80 01       	ld.sh	r1,r0[0x0]
800028da:	0d 4c       	ld.w	r12,--r6
800028dc:	80 01       	ld.sh	r1,r0[0x0]
800028de:	0d 60       	ld.uh	r0,--r6

800028e0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028e0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028e2:	19 e8       	ld.ub	r8,r12[0x6]
800028e4:	30 19       	mov	r9,1
800028e6:	f2 08 18 00 	cp.b	r8,r9
800028ea:	c0 61       	brne	800028f6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028ec:	48 98       	lddpc	r8,80002910 <DeviceInitializationStatus_brdcst_func+0x30>
800028ee:	70 09       	ld.w	r9,r8[0x0]
800028f0:	a1 a9       	sbr	r9,0x0
800028f2:	91 09       	st.w	r8[0x0],r9
800028f4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028f6:	30 29       	mov	r9,2
800028f8:	f2 08 18 00 	cp.b	r8,r9
800028fc:	c0 80       	breq	8000290c <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028fe:	48 58       	lddpc	r8,80002910 <DeviceInitializationStatus_brdcst_func+0x30>
80002900:	70 09       	ld.w	r9,r8[0x0]
80002902:	e0 19 ff fc 	andl	r9,0xfffc
80002906:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002908:	f0 1f 00 03 	mcall	80002914 <DeviceInitializationStatus_brdcst_func+0x34>
8000290c:	d8 02       	popm	pc
8000290e:	00 00       	add	r0,r0
80002910:	00 00       	add	r0,r0
80002912:	13 60       	ld.uh	r0,--r9
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	55 9c       	stdsp	sp[0x164],r12

80002918 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002918:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
8000291a:	48 78       	lddpc	r8,80002934 <SD_SPI_SetSpeed+0x1c>
8000291c:	70 09       	ld.w	r9,r8[0x0]
8000291e:	72 ca       	ld.w	r10,r9[0x30]
80002920:	5c 7c       	castu.h	r12
80002922:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002926:	f9 ea 10 0a 	or	r10,r12,r10
8000292a:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
8000292c:	70 0c       	ld.w	r12,r8[0x0]
8000292e:	f0 1f 00 03 	mcall	80002938 <SD_SPI_SetSpeed+0x20>
	
 
}
80002932:	d8 02       	popm	pc
80002934:	00 00       	add	r0,r0
80002936:	13 64       	ld.uh	r4,--r9
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	63 60       	ld.w	r0,r1[0x58]

8000293c <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
8000293c:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
8000293e:	e0 6c 01 00 	mov	r12,256
80002942:	f0 1f 00 02 	mcall	80002948 <SD_SPI_SetSpeedHi+0xc>

}
80002946:	d8 02       	popm	pc
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	29 18       	sub	r8,-111

8000294c <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
8000294c:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
8000294e:	e0 6c ff 00 	mov	r12,65280
80002952:	f0 1f 00 02 	mcall	80002958 <SD_SPI_SetSpeedLow+0xc>


	
}
80002956:	d8 02       	popm	pc
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	29 18       	sub	r8,-111

8000295c <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
8000295c:	eb cd 40 c0 	pushm	r6-r7,lr
80002960:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002962:	49 58       	lddpc	r8,800029b4 <SD_LowLevel_Init+0x58>
80002964:	1a 96       	mov	r6,sp
80002966:	f0 ea 00 00 	ld.d	r10,r8[0]
8000296a:	fa eb 00 00 	st.d	sp[0],r10
8000296e:	f0 e8 00 08 	ld.d	r8,r8[8]
80002972:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
80002976:	30 4b       	mov	r11,4
80002978:	49 0c       	lddpc	r12,800029b8 <SD_LowLevel_Init+0x5c>
8000297a:	f0 1f 00 11 	mcall	800029bc <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
8000297e:	49 17       	lddpc	r7,800029c0 <SD_LowLevel_Init+0x64>
80002980:	fe 7c 24 00 	mov	r12,-56320
80002984:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002986:	1a 9b       	mov	r11,sp
80002988:	f0 1f 00 0f 	mcall	800029c4 <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
8000298c:	30 09       	mov	r9,0
8000298e:	12 9a       	mov	r10,r9
80002990:	12 9b       	mov	r11,r9
80002992:	6e 0c       	ld.w	r12,r7[0x0]
80002994:	f0 1f 00 0d 	mcall	800029c8 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
80002998:	6e 0c       	ld.w	r12,r7[0x0]
8000299a:	f0 1f 00 0d 	mcall	800029cc <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
8000299e:	e0 6a 36 00 	mov	r10,13824
800029a2:	ea 1a 01 6e 	orh	r10,0x16e
800029a6:	1a 9b       	mov	r11,sp
800029a8:	6e 0c       	ld.w	r12,r7[0x0]
800029aa:	f0 1f 00 0a 	mcall	800029d0 <SD_LowLevel_Init+0x74>
	return;
	}


	
}
800029ae:	2f cd       	sub	sp,-16
800029b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029b4:	80 01       	ld.sh	r1,r0[0x0]
800029b6:	0d 94       	ld.ub	r4,r6[0x1]
800029b8:	80 01       	ld.sh	r1,r0[0x0]
800029ba:	0d a4       	ld.ub	r4,r6[0x2]
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	a7 e0       	*unknown*
800029c0:	00 00       	add	r0,r0
800029c2:	13 64       	ld.uh	r4,--r9
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	61 c8       	ld.w	r8,r0[0x70]
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	62 00       	ld.w	r0,r1[0x0]
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	63 60       	ld.w	r0,r1[0x58]
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	62 9e       	ld.w	lr,r1[0x24]

800029d4 <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
800029d4:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
800029d8:	48 b7       	lddpc	r7,80002a04 <SD_ReadByte+0x30>
800029da:	30 0b       	mov	r11,0
800029dc:	6e 0c       	ld.w	r12,r7[0x0]
800029de:	f0 1f 00 0b 	mcall	80002a08 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
800029e2:	e0 6b 00 ff 	mov	r11,255
800029e6:	6e 0c       	ld.w	r12,r7[0x0]
800029e8:	f0 1f 00 09 	mcall	80002a0c <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
800029ec:	30 06       	mov	r6,0
800029ee:	0c 9b       	mov	r11,r6
800029f0:	6e 0c       	ld.w	r12,r7[0x0]
800029f2:	f0 1f 00 08 	mcall	80002a10 <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
800029f6:	0c 9b       	mov	r11,r6
800029f8:	6e 0c       	ld.w	r12,r7[0x0]
800029fa:	f0 1f 00 07 	mcall	80002a14 <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
800029fe:	0d 9c       	ld.ub	r12,r6[0x1]
80002a00:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a04:	00 00       	add	r0,r0
80002a06:	13 64       	ld.uh	r4,--r9
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	62 2c       	ld.w	r12,r1[0x8]
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	63 66       	ld.w	r6,r1[0x58]
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	63 82       	ld.w	r2,r1[0x60]
80002a14:	80 00       	ld.sh	r0,r0[0x0]
80002a16:	62 78       	ld.w	r8,r1[0x1c]

80002a18 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a18:	eb cd 40 c0 	pushm	r6-r7,lr
80002a1c:	18 96       	mov	r6,r12
80002a1e:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a22:	c0 28       	rjmp	80002a26 <SD_GetResponse+0xe>
  {
    Count--;
80002a24:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a26:	f0 1f 00 09 	mcall	80002a48 <SD_GetResponse+0x30>
80002a2a:	ec 0c 18 00 	cp.b	r12,r6
80002a2e:	c0 40       	breq	80002a36 <SD_GetResponse+0x1e>
80002a30:	58 07       	cp.w	r7,0
80002a32:	cf 91       	brne	80002a24 <SD_GetResponse+0xc>
80002a34:	c0 58       	rjmp	80002a3e <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002a36:	58 07       	cp.w	r7,0
80002a38:	c0 30       	breq	80002a3e <SD_GetResponse+0x26>
80002a3a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002a3e:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002a42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a46:	00 00       	add	r0,r0
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	29 d4       	sub	r4,-99

80002a4c <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002a4c:	eb cd 40 f8 	pushm	r3-r7,lr
80002a50:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002a52:	30 b5       	mov	r5,11
80002a54:	30 d4       	mov	r4,13
80002a56:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002a58:	f0 1f 00 0c 	mcall	80002a88 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002a5c:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002a60:	ea 07 18 00 	cp.b	r7,r5
80002a64:	c0 e0       	breq	80002a80 <SD_GetDataResponse+0x34>
80002a66:	e8 07 18 00 	cp.b	r7,r4
80002a6a:	c0 b0       	breq	80002a80 <SD_GetDataResponse+0x34>
80002a6c:	e6 07 18 00 	cp.b	r7,r3
80002a70:	c0 50       	breq	80002a7a <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002a72:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002a74:	e0 46 00 41 	cp.w	r6,65
80002a78:	cf 01       	brne	80002a58 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002a7a:	f0 1f 00 04 	mcall	80002a88 <SD_GetDataResponse+0x3c>
80002a7e:	cf e0       	breq	80002a7a <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002a80:	0e 9c       	mov	r12,r7
80002a82:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002a86:	00 00       	add	r0,r0
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	29 d4       	sub	r4,-99

80002a8c <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002a8c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a90:	20 1d       	sub	sp,4
80002a92:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a94:	48 c7       	lddpc	r7,80002ac4 <SD_WriteByte+0x38>
80002a96:	30 0b       	mov	r11,0
80002a98:	6e 0c       	ld.w	r12,r7[0x0]
80002a9a:	f0 1f 00 0c 	mcall	80002ac8 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002a9e:	1b 8b       	ld.ub	r11,sp[0x0]
80002aa0:	6e 0c       	ld.w	r12,r7[0x0]
80002aa2:	f0 1f 00 0b 	mcall	80002acc <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002aa6:	1a 9b       	mov	r11,sp
80002aa8:	6e 0c       	ld.w	r12,r7[0x0]
80002aaa:	f0 1f 00 0a 	mcall	80002ad0 <SD_WriteByte+0x44>
80002aae:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002ab0:	30 0b       	mov	r11,0
80002ab2:	6e 0c       	ld.w	r12,r7[0x0]
80002ab4:	f0 1f 00 08 	mcall	80002ad4 <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002ab8:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002abc:	2f fd       	sub	sp,-4
80002abe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	00 00       	add	r0,r0
80002ac6:	13 64       	ld.uh	r4,--r9
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	62 2c       	ld.w	r12,r1[0x8]
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	63 66       	ld.w	r6,r1[0x58]
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	63 82       	ld.w	r2,r1[0x60]
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	62 78       	ld.w	r8,r1[0x1c]

80002ad8 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002ad8:	eb cd 40 c0 	pushm	r6-r7,lr
80002adc:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002ade:	a7 ac       	sbr	r12,0x6
80002ae0:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002ae2:	f6 08 16 18 	lsr	r8,r11,0x18
80002ae6:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002ae8:	f6 08 16 10 	lsr	r8,r11,0x10
80002aec:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002aee:	f6 08 16 08 	lsr	r8,r11,0x8
80002af2:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002af4:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002af6:	ba da       	st.b	sp[0x5],r10
80002af8:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002afa:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002afe:	0f 3c       	ld.ub	r12,r7++
80002b00:	f0 1f 00 04 	mcall	80002b10 <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002b04:	0c 37       	cp.w	r7,r6
80002b06:	cf c1       	brne	80002afe <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002b08:	2f ed       	sub	sp,-8
80002b0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b0e:	00 00       	add	r0,r0
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	2a 8c       	sub	r12,-88

80002b14 <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b14:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b16:	31 8c       	mov	r12,24
80002b18:	f0 1f 00 6a 	mcall	80002cc0 <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b1c:	e0 6a 00 95 	mov	r10,149
80002b20:	30 0b       	mov	r11,0
80002b22:	16 9c       	mov	r12,r11
80002b24:	f0 1f 00 68 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002b28:	30 1c       	mov	r12,1
80002b2a:	f0 1f 00 68 	mcall	80002cc8 <SD_GoIdleState+0x1b4>
80002b2e:	e0 81 00 a8 	brne	80002c7e <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002b32:	e0 6a 00 87 	mov	r10,135
80002b36:	e0 6b 01 aa 	mov	r11,426
80002b3a:	30 8c       	mov	r12,8
80002b3c:	f0 1f 00 62 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
80002b40:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b44:	3f f6       	mov	r6,-1
80002b46:	c0 38       	rjmp	80002b4c <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002b48:	20 17       	sub	r7,1
80002b4a:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b4c:	f0 1f 00 60 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002b50:	ec 0c 18 00 	cp.b	r12,r6
80002b54:	c0 41       	brne	80002b5c <SD_GoIdleState+0x48>
80002b56:	58 07       	cp.w	r7,0
80002b58:	cf 81       	brne	80002b48 <SD_GoIdleState+0x34>
80002b5a:	c2 68       	rjmp	80002ba6 <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002b5c:	30 58       	mov	r8,5
80002b5e:	f0 0c 18 00 	cp.b	r12,r8
80002b62:	c2 21       	brne	80002ba6 <SD_GoIdleState+0x92>
80002b64:	c9 48       	rjmp	80002c8c <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002b66:	08 9c       	mov	r12,r4
80002b68:	f0 1f 00 5a 	mcall	80002cd0 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002b6c:	06 9c       	mov	r12,r3
80002b6e:	f0 1f 00 5a 	mcall	80002cd4 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002b72:	08 9c       	mov	r12,r4
80002b74:	f0 1f 00 53 	mcall	80002cc0 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002b78:	06 9a       	mov	r10,r3
80002b7a:	0a 9b       	mov	r11,r5
80002b7c:	02 9c       	mov	r12,r1
80002b7e:	f0 1f 00 52 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002b82:	2f f6       	sub	r6,-1
80002b84:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002b86:	e4 06 19 00 	cp.h	r6,r2
80002b8a:	c0 60       	breq	80002b96 <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002b8c:	0a 9c       	mov	r12,r5
80002b8e:	f0 1f 00 4f 	mcall	80002cc8 <SD_GoIdleState+0x1b4>
80002b92:	18 97       	mov	r7,r12
    }
    while (Status);
80002b94:	ce 91       	brne	80002b66 <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002b96:	31 8c       	mov	r12,24
80002b98:	f0 1f 00 4e 	mcall	80002cd0 <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002b9c:	e0 6c 00 ff 	mov	r12,255
80002ba0:	f0 1f 00 4d 	mcall	80002cd4 <SD_GoIdleState+0x1c0>
80002ba4:	c6 f8       	rjmp	80002c82 <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002ba6:	f0 1f 00 4a 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002baa:	f0 1f 00 49 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002bae:	f0 1f 00 48 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002bb2:	f0 1f 00 47 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002bb6:	f0 1f 00 46 	mcall	80002ccc <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002bba:	31 8c       	mov	r12,24
80002bbc:	f0 1f 00 45 	mcall	80002cd0 <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bc0:	e0 6c 00 ff 	mov	r12,255
80002bc4:	f0 1f 00 44 	mcall	80002cd4 <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002bc8:	31 8c       	mov	r12,24
80002bca:	f0 1f 00 3e 	mcall	80002cc0 <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bce:	e0 6c 00 ff 	mov	r12,255
80002bd2:	f0 1f 00 41 	mcall	80002cd4 <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bd6:	e0 6c 00 ff 	mov	r12,255
80002bda:	f0 1f 00 3f 	mcall	80002cd4 <SD_GoIdleState+0x1c0>
80002bde:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002be2:	08 91       	mov	r1,r4
80002be4:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002be6:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002be8:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002bea:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002bee:	02 9a       	mov	r10,r1
80002bf0:	04 9b       	mov	r11,r2
80002bf2:	33 7c       	mov	r12,55
80002bf4:	f0 1f 00 34 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
80002bf8:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002bfa:	f0 1f 00 35 	mcall	80002ccc <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002bfe:	f8 05 18 00 	cp.b	r5,r12
80002c02:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c06:	2f f7       	sub	r7,-1
80002c08:	5c 87       	casts.h	r7
80002c0a:	e6 07 19 00 	cp.h	r7,r3
80002c0e:	cf 61       	brne	80002bfa <SD_GoIdleState+0xe6>
80002c10:	08 90       	mov	r0,r4
80002c12:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c14:	04 9a       	mov	r10,r2
80002c16:	fc 1b 40 00 	movh	r11,0x4000
80002c1a:	32 9c       	mov	r12,41
80002c1c:	f0 1f 00 2a 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
80002c20:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c22:	f0 1f 00 2b 	mcall	80002ccc <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c26:	c3 00       	breq	80002c86 <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c28:	2f f7       	sub	r7,-1
80002c2a:	5c 87       	casts.h	r7
80002c2c:	ec 07 19 00 	cp.h	r7,r6
80002c30:	cf 91       	brne	80002c22 <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c32:	e0 c4 00 01 	sub	r4,r0,1
80002c36:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002c38:	30 08       	mov	r8,0
80002c3a:	f0 0c 18 00 	cp.b	r12,r8
80002c3e:	5f 1a       	srne	r10
80002c40:	30 09       	mov	r9,0
80002c42:	f2 04 19 00 	cp.h	r4,r9
80002c46:	5f 19       	srne	r9
80002c48:	f5 e9 00 09 	and	r9,r10,r9
80002c4c:	f0 09 18 00 	cp.b	r9,r8
80002c50:	cc f1       	brne	80002bee <SD_GoIdleState+0xda>

    if(n==0)
80002c52:	58 04       	cp.w	r4,0
80002c54:	c1 50       	breq	80002c7e <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002c56:	30 0a       	mov	r10,0
80002c58:	14 9b       	mov	r11,r10
80002c5a:	33 ac       	mov	r12,58
80002c5c:	f0 1f 00 1a 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002c60:	f0 1f 00 1b 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002c64:	f0 1f 00 1a 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002c68:	f0 1f 00 19 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002c6c:	f0 1f 00 18 	mcall	80002ccc <SD_GoIdleState+0x1b8>
80002c70:	f0 1f 00 17 	mcall	80002ccc <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002c74:	30 19       	mov	r9,1
80002c76:	49 98       	lddpc	r8,80002cd8 <SD_GoIdleState+0x1c4>
80002c78:	b0 89       	st.b	r8[0x0],r9
80002c7a:	30 07       	mov	r7,0
80002c7c:	c0 38       	rjmp	80002c82 <SD_GoIdleState+0x16e>
80002c7e:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002c82:	0e 9c       	mov	r12,r7
80002c84:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c86:	20 14       	sub	r4,1
80002c88:	5c 84       	casts.h	r4
80002c8a:	ce 4b       	rjmp	80002c52 <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002c8c:	31 8c       	mov	r12,24
80002c8e:	f0 1f 00 11 	mcall	80002cd0 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002c92:	e0 6c 00 ff 	mov	r12,255
80002c96:	f0 1f 00 10 	mcall	80002cd4 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002c9a:	31 8c       	mov	r12,24
80002c9c:	f0 1f 00 09 	mcall	80002cc0 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002ca0:	e0 6a 00 ff 	mov	r10,255
80002ca4:	30 0b       	mov	r11,0
80002ca6:	30 1c       	mov	r12,1
80002ca8:	f0 1f 00 07 	mcall	80002cc4 <SD_GoIdleState+0x1b0>
80002cac:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002cae:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cb0:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cb2:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cb6:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002cb8:	e0 62 00 f0 	mov	r2,240
80002cbc:	c6 8b       	rjmp	80002b8c <SD_GoIdleState+0x78>
80002cbe:	00 00       	add	r0,r0
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	a8 2c       	st.h	r4[0x4],r12
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	2a d8       	sub	r8,-83
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	2a 18       	sub	r8,-95
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	29 d4       	sub	r4,-99
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	a8 10       	st.h	r4[0x2],r0
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	2a 8c       	sub	r12,-88
80002cd8:	00 00       	add	r0,r0
80002cda:	0a 68       	and	r8,r5

80002cdc <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002cdc:	eb cd 40 e0 	pushm	r5-r7,lr
80002ce0:	20 4d       	sub	sp,16
80002ce2:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002ce4:	31 8c       	mov	r12,24
80002ce6:	f0 1f 00 44 	mcall	80002df4 <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002cea:	e0 6a 00 ff 	mov	r10,255
80002cee:	30 0b       	mov	r11,0
80002cf0:	30 ac       	mov	r12,10
80002cf2:	f0 1f 00 42 	mcall	80002df8 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002cf6:	30 0c       	mov	r12,0
80002cf8:	f0 1f 00 41 	mcall	80002dfc <SD_GetCIDRegister+0x120>
80002cfc:	c0 40       	breq	80002d04 <SD_GetCIDRegister+0x28>
80002cfe:	e0 66 00 ff 	mov	r6,255
80002d02:	c1 78       	rjmp	80002d30 <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002d04:	e0 6c 00 fe 	mov	r12,254
80002d08:	f0 1f 00 3d 	mcall	80002dfc <SD_GetCIDRegister+0x120>
80002d0c:	c0 91       	brne	80002d1e <SD_GetCIDRegister+0x42>
80002d0e:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002d10:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d14:	f0 1f 00 3b 	mcall	80002e00 <SD_GetCIDRegister+0x124>
80002d18:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d1a:	0a 36       	cp.w	r6,r5
80002d1c:	cf c1       	brne	80002d14 <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d1e:	e0 6c 00 ff 	mov	r12,255
80002d22:	f0 1f 00 39 	mcall	80002e04 <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d26:	e0 6c 00 ff 	mov	r12,255
80002d2a:	f0 1f 00 37 	mcall	80002e04 <SD_GetCIDRegister+0x128>
80002d2e:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002d30:	31 8c       	mov	r12,24
80002d32:	f0 1f 00 36 	mcall	80002e08 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002d36:	e0 6c 00 ff 	mov	r12,255
80002d3a:	f0 1f 00 33 	mcall	80002e04 <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002d3e:	1b 88       	ld.ub	r8,sp[0x0]
80002d40:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002d42:	fb 28 00 01 	ld.sb	r8,sp[1]
80002d46:	a9 68       	lsl	r8,0x8
80002d48:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002d4a:	8e 19       	ld.sh	r9,r7[0x2]
80002d4c:	1b a8       	ld.ub	r8,sp[0x2]
80002d4e:	f3 e8 10 08 	or	r8,r9,r8
80002d52:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002d54:	1b b8       	ld.ub	r8,sp[0x3]
80002d56:	b9 68       	lsl	r8,0x18
80002d58:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002d5a:	6e 18       	ld.w	r8,r7[0x4]
80002d5c:	1b c9       	ld.ub	r9,sp[0x4]
80002d5e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d62:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002d64:	6e 18       	ld.w	r8,r7[0x4]
80002d66:	1b d9       	ld.ub	r9,sp[0x5]
80002d68:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002d6c:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002d6e:	6e 18       	ld.w	r8,r7[0x4]
80002d70:	1b e9       	ld.ub	r9,sp[0x6]
80002d72:	f3 e8 10 08 	or	r8,r9,r8
80002d76:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002d78:	1b f8       	ld.ub	r8,sp[0x7]
80002d7a:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002d7e:	fb 38 00 08 	ld.ub	r8,sp[8]
80002d82:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002d86:	fb 38 00 09 	ld.ub	r8,sp[9]
80002d8a:	b9 68       	lsl	r8,0x18
80002d8c:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002d8e:	6e 38       	ld.w	r8,r7[0xc]
80002d90:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002d94:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d98:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002d9a:	6e 38       	ld.w	r8,r7[0xc]
80002d9c:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002da0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002da4:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002da6:	6e 38       	ld.w	r8,r7[0xc]
80002da8:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002dac:	f3 e8 10 08 	or	r8,r9,r8
80002db0:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002db2:	ef 39 00 10 	ld.ub	r9,r7[16]
80002db6:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002dba:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002dbe:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002dc2:	a9 68       	lsl	r8,0x8
80002dc4:	e2 18 0f 00 	andl	r8,0xf00,COH
80002dc8:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002dcc:	ef 09 00 12 	ld.sh	r9,r7[18]
80002dd0:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002dd4:	f3 e8 10 08 	or	r8,r9,r8
80002dd8:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002ddc:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002de0:	a1 98       	lsr	r8,0x1
80002de2:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002de6:	30 18       	mov	r8,1
80002de8:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002dec:	0c 9c       	mov	r12,r6
80002dee:	2f cd       	sub	sp,-16
80002df0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	a8 2c       	st.h	r4[0x4],r12
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2a d8       	sub	r8,-83
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	2a 18       	sub	r8,-95
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	29 d4       	sub	r4,-99
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2a 8c       	sub	r12,-88
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	a8 10       	st.h	r4[0x2],r0

80002e0c <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002e0c:	d4 31       	pushm	r0-r7,lr
80002e0e:	18 95       	mov	r5,r12
80002e10:	16 93       	mov	r3,r11
80002e12:	14 96       	mov	r6,r10
80002e14:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e16:	31 8c       	mov	r12,24
80002e18:	f0 1f 00 27 	mcall	80002eb4 <SD_WriteMultiBlocks+0xa8>
80002e1c:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e20:	4a 60       	lddpc	r0,80002eb8 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e22:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e24:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e26:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e28:	c3 a8       	rjmp	80002e9c <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002e2a:	01 88       	ld.ub	r8,r0[0x0]
80002e2c:	30 19       	mov	r9,1
80002e2e:	f2 08 18 00 	cp.b	r8,r9
80002e32:	c0 81       	brne	80002e42 <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002e34:	04 9a       	mov	r10,r2
80002e36:	e6 0b 16 09 	lsr	r11,r3,0x9
80002e3a:	31 8c       	mov	r12,24
80002e3c:	f0 1f 00 20 	mcall	80002ebc <SD_WriteMultiBlocks+0xb0>
80002e40:	c0 68       	rjmp	80002e4c <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e42:	04 9a       	mov	r10,r2
80002e44:	06 9b       	mov	r11,r3
80002e46:	31 8c       	mov	r12,24
80002e48:	f0 1f 00 1d 	mcall	80002ebc <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002e4c:	30 0c       	mov	r12,0
80002e4e:	f0 1f 00 1d 	mcall	80002ec0 <SD_WriteMultiBlocks+0xb4>
80002e52:	c0 40       	breq	80002e5a <SD_WriteMultiBlocks+0x4e>
80002e54:	e0 67 00 ff 	mov	r7,255
80002e58:	c2 b8       	rjmp	80002eae <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002e5a:	04 9c       	mov	r12,r2
80002e5c:	f0 1f 00 1a 	mcall	80002ec4 <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002e60:	e0 6c 00 fe 	mov	r12,254
80002e64:	f0 1f 00 18 	mcall	80002ec4 <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e68:	58 06       	cp.w	r6,0
80002e6a:	c0 a0       	breq	80002e7e <SD_WriteMultiBlocks+0x72>
80002e6c:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002e6e:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002e72:	f0 1f 00 15 	mcall	80002ec4 <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e76:	2f f7       	sub	r7,-1
80002e78:	0c 37       	cp.w	r7,r6
80002e7a:	cf a3       	brcs	80002e6e <SD_WriteMultiBlocks+0x62>
80002e7c:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002e7e:	f0 1f 00 13 	mcall	80002ec8 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002e82:	f0 1f 00 12 	mcall	80002ec8 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e86:	f0 1f 00 12 	mcall	80002ecc <SD_WriteMultiBlocks+0xc0>
80002e8a:	f8 01 18 00 	cp.b	r1,r12
80002e8e:	f9 b7 00 00 	moveq	r7,0
80002e92:	e4 07 17 10 	movne	r7,r2
80002e96:	20 14       	sub	r4,1
80002e98:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e9c:	58 04       	cp.w	r4,0
80002e9e:	cc 61       	brne	80002e2a <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002ea0:	31 8c       	mov	r12,24
80002ea2:	f0 1f 00 0c 	mcall	80002ed0 <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002ea6:	e0 6c 00 ff 	mov	r12,255
80002eaa:	f0 1f 00 07 	mcall	80002ec4 <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002eae:	0e 9c       	mov	r12,r7
80002eb0:	d8 32       	popm	r0-r7,pc
80002eb2:	00 00       	add	r0,r0
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	a8 2c       	st.h	r4[0x4],r12
80002eb8:	00 00       	add	r0,r0
80002eba:	0a 68       	and	r8,r5
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	2a d8       	sub	r8,-83
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	2a 18       	sub	r8,-95
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	2a 8c       	sub	r12,-88
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	29 d4       	sub	r4,-99
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	2a 4c       	sub	r12,-92
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	a8 10       	st.h	r4[0x2],r0

80002ed4 <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002ed4:	eb cd 40 e0 	pushm	r5-r7,lr
80002ed8:	18 95       	mov	r5,r12
80002eda:	16 97       	mov	r7,r11
80002edc:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002ede:	31 8c       	mov	r12,24
80002ee0:	f0 1f 00 1f 	mcall	80002f5c <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002ee4:	49 f8       	lddpc	r8,80002f60 <SD_WriteBlock+0x8c>
80002ee6:	11 89       	ld.ub	r9,r8[0x0]
80002ee8:	30 18       	mov	r8,1
80002eea:	f0 09 18 00 	cp.b	r9,r8
80002eee:	c0 21       	brne	80002ef2 <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002ef0:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002ef2:	e0 6a 00 ff 	mov	r10,255
80002ef6:	0e 9b       	mov	r11,r7
80002ef8:	31 8c       	mov	r12,24
80002efa:	f0 1f 00 1b 	mcall	80002f64 <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002efe:	30 0c       	mov	r12,0
80002f00:	f0 1f 00 1a 	mcall	80002f68 <SD_WriteBlock+0x94>
80002f04:	c1 f1       	brne	80002f42 <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f06:	e0 6c 00 ff 	mov	r12,255
80002f0a:	f0 1f 00 19 	mcall	80002f6c <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002f0e:	e0 6c 00 fe 	mov	r12,254
80002f12:	f0 1f 00 17 	mcall	80002f6c <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f16:	5c 76       	castu.h	r6
80002f18:	c0 90       	breq	80002f2a <SD_WriteBlock+0x56>
80002f1a:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f1c:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f20:	f0 1f 00 13 	mcall	80002f6c <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f24:	2f f7       	sub	r7,-1
80002f26:	0c 37       	cp.w	r7,r6
80002f28:	cf a3       	brcs	80002f1c <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002f2a:	f0 1f 00 12 	mcall	80002f70 <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002f2e:	f0 1f 00 11 	mcall	80002f70 <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002f32:	f0 1f 00 11 	mcall	80002f74 <SD_WriteBlock+0xa0>
80002f36:	30 58       	mov	r8,5
80002f38:	f0 0c 18 00 	cp.b	r12,r8
80002f3c:	c0 31       	brne	80002f42 <SD_WriteBlock+0x6e>
80002f3e:	30 07       	mov	r7,0
80002f40:	c0 38       	rjmp	80002f46 <SD_WriteBlock+0x72>
80002f42:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f46:	31 8c       	mov	r12,24
80002f48:	f0 1f 00 0c 	mcall	80002f78 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f4c:	e0 6c 00 ff 	mov	r12,255
80002f50:	f0 1f 00 07 	mcall	80002f6c <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002f54:	0e 9c       	mov	r12,r7
80002f56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f5a:	00 00       	add	r0,r0
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	a8 2c       	st.h	r4[0x4],r12
80002f60:	00 00       	add	r0,r0
80002f62:	0a 68       	and	r8,r5
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	2a d8       	sub	r8,-83
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	2a 18       	sub	r8,-95
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	2a 8c       	sub	r12,-88
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	29 d4       	sub	r4,-99
80002f74:	80 00       	ld.sh	r0,r0[0x0]
80002f76:	2a 4c       	sub	r12,-92
80002f78:	80 00       	ld.sh	r0,r0[0x0]
80002f7a:	a8 10       	st.h	r4[0x2],r0

80002f7c <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002f7c:	d4 31       	pushm	r0-r7,lr
80002f7e:	20 1d       	sub	sp,4
80002f80:	18 95       	mov	r5,r12
80002f82:	50 0b       	stdsp	sp[0x0],r11
80002f84:	14 96       	mov	r6,r10
80002f86:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002f88:	31 8c       	mov	r12,24
80002f8a:	f0 1f 00 27 	mcall	80003024 <SD_ReadMultiBlocks+0xa8>
80002f8e:	e0 67 00 ff 	mov	r7,255
80002f92:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002f94:	4a 53       	lddpc	r3,80003028 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002f96:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f98:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002f9a:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002f9c:	c3 78       	rjmp	8000300a <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80002f9e:	07 88       	ld.ub	r8,r3[0x0]
80002fa0:	30 19       	mov	r9,1
80002fa2:	f2 08 18 00 	cp.b	r8,r9
80002fa6:	c0 a1       	brne	80002fba <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80002fa8:	40 08       	lddsp	r8,sp[0x0]
80002faa:	e4 08 00 0b 	add	r11,r2,r8
80002fae:	00 9a       	mov	r10,r0
80002fb0:	a9 9b       	lsr	r11,0x9
80002fb2:	31 1c       	mov	r12,17
80002fb4:	f0 1f 00 1e 	mcall	8000302c <SD_ReadMultiBlocks+0xb0>
80002fb8:	c0 88       	rjmp	80002fc8 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002fba:	00 9a       	mov	r10,r0
80002fbc:	40 09       	lddsp	r9,sp[0x0]
80002fbe:	e4 09 00 0b 	add	r11,r2,r9
80002fc2:	31 1c       	mov	r12,17
80002fc4:	f0 1f 00 1a 	mcall	8000302c <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002fc8:	02 9c       	mov	r12,r1
80002fca:	f0 1f 00 1a 	mcall	80003030 <SD_ReadMultiBlocks+0xb4>
80002fce:	c0 40       	breq	80002fd6 <SD_ReadMultiBlocks+0x5a>
80002fd0:	e0 67 00 ff 	mov	r7,255
80002fd4:	c2 48       	rjmp	8000301c <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002fd6:	e0 6c 00 fe 	mov	r12,254
80002fda:	f0 1f 00 16 	mcall	80003030 <SD_ReadMultiBlocks+0xb4>
80002fde:	c0 30       	breq	80002fe4 <SD_ReadMultiBlocks+0x68>
80002fe0:	00 97       	mov	r7,r0
80002fe2:	c1 38       	rjmp	80003008 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002fe4:	58 06       	cp.w	r6,0
80002fe6:	c0 a0       	breq	80002ffa <SD_ReadMultiBlocks+0x7e>
80002fe8:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80002fea:	f0 1f 00 13 	mcall	80003034 <SD_ReadMultiBlocks+0xb8>
80002fee:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002ff2:	2f f7       	sub	r7,-1
80002ff4:	0c 37       	cp.w	r7,r6
80002ff6:	cf a3       	brcs	80002fea <SD_ReadMultiBlocks+0x6e>
80002ff8:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80002ffa:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80002ffe:	f0 1f 00 0e 	mcall	80003034 <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
80003002:	f0 1f 00 0d 	mcall	80003034 <SD_ReadMultiBlocks+0xb8>
80003006:	02 97       	mov	r7,r1
80003008:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
8000300a:	58 04       	cp.w	r4,0
8000300c:	cc 91       	brne	80002f9e <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000300e:	31 8c       	mov	r12,24
80003010:	f0 1f 00 0a 	mcall	80003038 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003014:	e0 6c 00 ff 	mov	r12,255
80003018:	f0 1f 00 09 	mcall	8000303c <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
8000301c:	0e 9c       	mov	r12,r7
8000301e:	2f fd       	sub	sp,-4
80003020:	d8 32       	popm	r0-r7,pc
80003022:	00 00       	add	r0,r0
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	a8 2c       	st.h	r4[0x4],r12
80003028:	00 00       	add	r0,r0
8000302a:	0a 68       	and	r8,r5
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	2a d8       	sub	r8,-83
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	2a 18       	sub	r8,-95
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	29 d4       	sub	r4,-99
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	a8 10       	st.h	r4[0x2],r0
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	2a 8c       	sub	r12,-88

80003040 <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
80003040:	eb cd 40 e0 	pushm	r5-r7,lr
80003044:	18 95       	mov	r5,r12
80003046:	16 97       	mov	r7,r11
80003048:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
8000304a:	31 8c       	mov	r12,24
8000304c:	f0 1f 00 1a 	mcall	800030b4 <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
80003050:	49 a8       	lddpc	r8,800030b8 <SD_ReadBlock+0x78>
80003052:	11 89       	ld.ub	r9,r8[0x0]
80003054:	30 18       	mov	r8,1
80003056:	f0 09 18 00 	cp.b	r9,r8
8000305a:	c0 21       	brne	8000305e <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
8000305c:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
8000305e:	e0 6a 00 ff 	mov	r10,255
80003062:	0e 9b       	mov	r11,r7
80003064:	31 1c       	mov	r12,17
80003066:	f0 1f 00 16 	mcall	800030bc <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
8000306a:	30 0c       	mov	r12,0
8000306c:	f0 1f 00 15 	mcall	800030c0 <SD_ReadBlock+0x80>
80003070:	c1 61       	brne	8000309c <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003072:	e0 6c 00 fe 	mov	r12,254
80003076:	f0 1f 00 13 	mcall	800030c0 <SD_ReadBlock+0x80>
8000307a:	c1 11       	brne	8000309c <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000307c:	5c 76       	castu.h	r6
8000307e:	c0 90       	breq	80003090 <SD_ReadBlock+0x50>
80003080:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
80003082:	f0 1f 00 11 	mcall	800030c4 <SD_ReadBlock+0x84>
80003086:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000308a:	2f f7       	sub	r7,-1
8000308c:	0c 37       	cp.w	r7,r6
8000308e:	cf a3       	brcs	80003082 <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80003090:	f0 1f 00 0d 	mcall	800030c4 <SD_ReadBlock+0x84>
      SD_ReadByte();
80003094:	f0 1f 00 0c 	mcall	800030c4 <SD_ReadBlock+0x84>
80003098:	30 07       	mov	r7,0
8000309a:	c0 38       	rjmp	800030a0 <SD_ReadBlock+0x60>
8000309c:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800030a0:	31 8c       	mov	r12,24
800030a2:	f0 1f 00 0a 	mcall	800030c8 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800030a6:	e0 6c 00 ff 	mov	r12,255
800030aa:	f0 1f 00 09 	mcall	800030cc <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
800030ae:	0e 9c       	mov	r12,r7
800030b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	a8 2c       	st.h	r4[0x4],r12
800030b8:	00 00       	add	r0,r0
800030ba:	0a 68       	and	r8,r5
800030bc:	80 00       	ld.sh	r0,r0[0x0]
800030be:	2a d8       	sub	r8,-83
800030c0:	80 00       	ld.sh	r0,r0[0x0]
800030c2:	2a 18       	sub	r8,-95
800030c4:	80 00       	ld.sh	r0,r0[0x0]
800030c6:	29 d4       	sub	r4,-99
800030c8:	80 00       	ld.sh	r0,r0[0x0]
800030ca:	a8 10       	st.h	r4[0x2],r0
800030cc:	80 00       	ld.sh	r0,r0[0x0]
800030ce:	2a 8c       	sub	r12,-88

800030d0 <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
800030d0:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
800030d4:	f0 1f 00 11 	mcall	80003118 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
800030d8:	f0 1f 00 11 	mcall	8000311c <SD_Init+0x4c>
800030dc:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
800030de:	31 84       	mov	r4,24
800030e0:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
800030e2:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
800030e6:	08 9c       	mov	r12,r4
800030e8:	f0 1f 00 0e 	mcall	80003120 <SD_Init+0x50>
800030ec:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
800030ee:	0c 9c       	mov	r12,r6
800030f0:	f0 1f 00 0d 	mcall	80003124 <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
800030f4:	2f f7       	sub	r7,-1
800030f6:	58 a7       	cp.w	r7,10
800030f8:	cf b1       	brne	800030ee <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
800030fa:	f0 1f 00 0c 	mcall	80003128 <SD_Init+0x58>
800030fe:	18 97       	mov	r7,r12

    if(TimeOut > 6)
80003100:	58 75       	cp.w	r5,7
80003102:	c0 50       	breq	8000310c <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
80003104:	58 0c       	cp.w	r12,0
80003106:	c0 30       	breq	8000310c <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
80003108:	2f f5       	sub	r5,-1
8000310a:	ce eb       	rjmp	800030e6 <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
8000310c:	f0 1f 00 08 	mcall	8000312c <SD_Init+0x5c>
  return (Status);
}
80003110:	0e 9c       	mov	r12,r7
80003112:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003116:	00 00       	add	r0,r0
80003118:	80 00       	ld.sh	r0,r0[0x0]
8000311a:	29 5c       	sub	r12,-107
8000311c:	80 00       	ld.sh	r0,r0[0x0]
8000311e:	29 4c       	sub	r12,-108
80003120:	80 00       	ld.sh	r0,r0[0x0]
80003122:	a8 10       	st.h	r4[0x2],r0
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	2a 8c       	sub	r12,-88
80003128:	80 00       	ld.sh	r0,r0[0x0]
8000312a:	2b 14       	sub	r4,-79
8000312c:	80 00       	ld.sh	r0,r0[0x0]
8000312e:	29 3c       	sub	r12,-109

80003130 <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
80003130:	eb cd 40 e0 	pushm	r5-r7,lr
80003134:	20 9d       	sub	sp,36
80003136:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
80003138:	31 8c       	mov	r12,24
8000313a:	f0 1f 00 a6 	mcall	800033d0 <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
8000313e:	e0 6a 00 ff 	mov	r10,255
80003142:	30 0b       	mov	r11,0
80003144:	30 9c       	mov	r12,9
80003146:	f0 1f 00 a4 	mcall	800033d4 <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
8000314a:	30 0c       	mov	r12,0
8000314c:	f0 1f 00 a3 	mcall	800033d8 <SD_GetCSDRegister+0x2a8>
80003150:	c0 40       	breq	80003158 <SD_GetCSDRegister+0x28>
80003152:	e0 6c 00 ff 	mov	r12,255
80003156:	c3 99       	rjmp	800033c8 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003158:	e0 6c 00 fe 	mov	r12,254
8000315c:	f0 1f 00 9f 	mcall	800033d8 <SD_GetCSDRegister+0x2a8>
80003160:	c0 a1       	brne	80003174 <SD_GetCSDRegister+0x44>
80003162:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
80003166:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
8000316a:	f0 1f 00 9d 	mcall	800033dc <SD_GetCSDRegister+0x2ac>
8000316e:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
80003170:	0a 36       	cp.w	r6,r5
80003172:	cf c1       	brne	8000316a <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80003174:	e0 6c 00 ff 	mov	r12,255
80003178:	f0 1f 00 9a 	mcall	800033e0 <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
8000317c:	e0 6c 00 ff 	mov	r12,255
80003180:	f0 1f 00 98 	mcall	800033e0 <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003184:	31 8c       	mov	r12,24
80003186:	f0 1f 00 98 	mcall	800033e4 <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
8000318a:	e0 6c 00 ff 	mov	r12,255
8000318e:	f0 1f 00 95 	mcall	800033e0 <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
80003192:	fb 38 00 14 	ld.ub	r8,sp[20]
80003196:	f0 09 16 06 	lsr	r9,r8,0x6
8000319a:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
8000319c:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
800031a0:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
800031a2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800031a6:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
800031a8:	fe f8 02 40 	ld.w	r8,pc[576]
800031ac:	70 08       	ld.w	r8,r8[0x0]
800031ae:	58 08       	cp.w	r8,0
800031b0:	c0 f1       	brne	800031ce <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
800031b2:	0f 89       	ld.ub	r9,r7[0x0]
800031b4:	30 18       	mov	r8,1
800031b6:	f0 09 18 00 	cp.b	r9,r8
800031ba:	c0 61       	brne	800031c6 <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
800031bc:	10 99       	mov	r9,r8
800031be:	fe f8 02 2e 	ld.w	r8,pc[558]
800031c2:	b0 89       	st.b	r8[0x0],r9
800031c4:	c0 58       	rjmp	800031ce <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
800031c6:	30 09       	mov	r9,0
800031c8:	fe f8 02 24 	ld.w	r8,pc[548]
800031cc:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
800031ce:	fb 38 00 15 	ld.ub	r8,sp[21]
800031d2:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
800031d4:	fb 38 00 16 	ld.ub	r8,sp[22]
800031d8:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
800031da:	fb 38 00 17 	ld.ub	r8,sp[23]
800031de:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
800031e0:	fb 38 00 18 	ld.ub	r8,sp[24]
800031e4:	a5 68       	lsl	r8,0x4
800031e6:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
800031e8:	8e 39       	ld.sh	r9,r7[0x6]
800031ea:	fb 38 00 19 	ld.ub	r8,sp[25]
800031ee:	f3 e8 12 49 	or	r9,r9,r8>>0x4
800031f2:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
800031f4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800031f8:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
800031fc:	fb 38 00 1a 	ld.ub	r8,sp[26]
80003200:	f0 09 16 07 	lsr	r9,r8,0x7
80003204:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
80003208:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
8000320c:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
80003210:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003214:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003218:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
8000321c:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
80003220:	30 09       	mov	r9,0
80003222:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
80003226:	4f 2a       	lddpc	r10,800033ec <SD_GetCSDRegister+0x2bc>
80003228:	15 8a       	ld.ub	r10,r10[0x0]
8000322a:	f2 0a 18 00 	cp.b	r10,r9
8000322e:	c1 21       	brne	80003252 <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
80003230:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003234:	ab 68       	lsl	r8,0xa
80003236:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
80003238:	6e 48       	ld.w	r8,r7[0x10]
8000323a:	fb 39 00 1b 	ld.ub	r9,sp[27]
8000323e:	f1 e9 10 28 	or	r8,r8,r9<<0x2
80003242:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
80003244:	6e 48       	ld.w	r8,r7[0x10]
80003246:	fb 39 00 1c 	ld.ub	r9,sp[28]
8000324a:	f1 e9 12 68 	or	r8,r8,r9>>0x6
8000324e:	8f 48       	st.w	r7[0x10],r8
80003250:	c1 38       	rjmp	80003276 <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
80003252:	fb 38 00 1b 	ld.ub	r8,sp[27]
80003256:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
8000325a:	b1 68       	lsl	r8,0x10
8000325c:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
8000325e:	6e 49       	ld.w	r9,r7[0x10]
80003260:	fb 38 00 1c 	ld.ub	r8,sp[28]
80003264:	a9 68       	lsl	r8,0x8
80003266:	12 08       	add	r8,r9
80003268:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
8000326a:	6e 48       	ld.w	r8,r7[0x10]
8000326c:	fb 39 00 1d 	ld.ub	r9,sp[29]
80003270:	f2 08 00 08 	add	r8,r9,r8
80003274:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
80003276:	fb 38 00 1c 	ld.ub	r8,sp[28]
8000327a:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
8000327e:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
80003282:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003286:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
8000328a:	fb 38 00 1d 	ld.ub	r8,sp[29]
8000328e:	f0 09 16 05 	lsr	r9,r8,0x5
80003292:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
80003296:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
8000329a:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
8000329e:	a1 78       	lsl	r8,0x1
800032a0:	e2 18 00 06 	andl	r8,0x6,COH
800032a4:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
800032a8:	ef 39 00 18 	ld.ub	r9,r7[24]
800032ac:	fb 38 00 1e 	ld.ub	r8,sp[30]
800032b0:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032b4:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
800032b8:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800032bc:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
800032c0:	a1 78       	lsl	r8,0x1
800032c2:	e2 18 00 7e 	andl	r8,0x7e,COH
800032c6:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
800032ca:	ef 39 00 1a 	ld.ub	r9,r7[26]
800032ce:	fb 38 00 1f 	ld.ub	r8,sp[31]
800032d2:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032d6:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
800032da:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800032de:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
800032e2:	fb 38 00 20 	ld.ub	r8,sp[32]
800032e6:	f0 09 16 07 	lsr	r9,r8,0x7
800032ea:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
800032ee:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
800032f2:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
800032f6:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
800032fa:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
800032fe:	a3 68       	lsl	r8,0x2
80003300:	e2 18 00 0c 	andl	r8,0xc,COH
80003304:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
80003308:	ef 39 00 1f 	ld.ub	r9,r7[31]
8000330c:	fb 38 00 21 	ld.ub	r8,sp[33]
80003310:	f3 e8 12 69 	or	r9,r9,r8>>0x6
80003314:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003318:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
8000331c:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
80003320:	30 09       	mov	r9,0
80003322:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
80003326:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000332a:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
8000332e:	fb 38 00 22 	ld.ub	r8,sp[34]
80003332:	f0 09 16 07 	lsr	r9,r8,0x7
80003336:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
8000333a:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
8000333e:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
80003342:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003346:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
8000334a:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
8000334e:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
80003352:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
80003356:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
8000335a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000335e:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
80003362:	fb 38 00 23 	ld.ub	r8,sp[35]
80003366:	a1 98       	lsr	r8,0x1
80003368:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
8000336c:	30 18       	mov	r8,1
8000336e:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
80003372:	49 e8       	lddpc	r8,800033e8 <SD_GetCSDRegister+0x2b8>
80003374:	70 08       	ld.w	r8,r8[0x0]
80003376:	58 28       	cp.w	r8,2
80003378:	e0 88 00 04 	brls	80003380 <SD_GetCSDRegister+0x250>
8000337c:	30 0c       	mov	r12,0
8000337e:	c2 58       	rjmp	800033c8 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
80003380:	49 b9       	lddpc	r9,800033ec <SD_GetCSDRegister+0x2bc>
80003382:	13 8a       	ld.ub	r10,r9[0x0]
80003384:	30 19       	mov	r9,1
80003386:	f2 0a 18 00 	cp.b	r10,r9
8000338a:	c0 51       	brne	80003394 <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
8000338c:	6e 49       	ld.w	r9,r7[0x10]
8000338e:	2f f9       	sub	r9,-1
80003390:	a9 79       	lsl	r9,0x9
80003392:	c0 c8       	rjmp	800033aa <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
80003394:	6e 4a       	ld.w	r10,r7[0x10]
80003396:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
80003398:	ef 39 00 18 	ld.ub	r9,r7[24]
8000339c:	2f e9       	sub	r9,-2
8000339e:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
800033a2:	ef 39 00 08 	ld.ub	r9,r7[8]
800033a6:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
800033aa:	58 08       	cp.w	r8,0
800033ac:	c0 91       	brne	800033be <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
800033ae:	b5 89       	lsr	r9,0x14
800033b0:	1a d9       	st.w	--sp,r9
800033b2:	49 0b       	lddpc	r11,800033f0 <SD_GetCSDRegister+0x2c0>
800033b4:	fa cc ff fc 	sub	r12,sp,-4
800033b8:	f0 1f 00 0f 	mcall	800033f4 <SD_GetCSDRegister+0x2c4>
800033bc:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
800033be:	48 b8       	lddpc	r8,800033e8 <SD_GetCSDRegister+0x2b8>
800033c0:	70 09       	ld.w	r9,r8[0x0]
800033c2:	2f f9       	sub	r9,-1
800033c4:	91 09       	st.w	r8[0x0],r9
800033c6:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
800033c8:	2f 7d       	sub	sp,-36
800033ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800033ce:	00 00       	add	r0,r0
800033d0:	80 00       	ld.sh	r0,r0[0x0]
800033d2:	a8 2c       	st.h	r4[0x4],r12
800033d4:	80 00       	ld.sh	r0,r0[0x0]
800033d6:	2a d8       	sub	r8,-83
800033d8:	80 00       	ld.sh	r0,r0[0x0]
800033da:	2a 18       	sub	r8,-95
800033dc:	80 00       	ld.sh	r0,r0[0x0]
800033de:	29 d4       	sub	r4,-99
800033e0:	80 00       	ld.sh	r0,r0[0x0]
800033e2:	2a 8c       	sub	r12,-88
800033e4:	80 00       	ld.sh	r0,r0[0x0]
800033e6:	a8 10       	st.h	r4[0x2],r0
800033e8:	00 00       	add	r0,r0
800033ea:	0a 64       	and	r4,r5
800033ec:	00 00       	add	r0,r0
800033ee:	0a 68       	and	r8,r5
800033f0:	80 01       	ld.sh	r1,r0[0x0]
800033f2:	0d 80       	ld.ub	r0,r6[0x0]
800033f4:	80 00       	ld.sh	r0,r0[0x0]
800033f6:	b1 3c       	mul	r12,r8

800033f8 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
800033f8:	eb cd 40 c0 	pushm	r6-r7,lr
800033fc:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
800033fe:	18 96       	mov	r6,r12
80003400:	f0 1f 00 12 	mcall	80003448 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
80003404:	e0 4c 00 ff 	cp.w	r12,255
80003408:	c0 41       	brne	80003410 <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
8000340a:	0e 9c       	mov	r12,r7
8000340c:	f0 1f 00 0f 	mcall	80003448 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
80003410:	ee cc ff d4 	sub	r12,r7,-44
80003414:	f0 1f 00 0e 	mcall	8000344c <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003418:	30 19       	mov	r9,1
8000341a:	48 e8       	lddpc	r8,80003450 <SD_GetCardInfo+0x58>
8000341c:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
8000341e:	6e 48       	ld.w	r8,r7[0x10]
80003420:	2f f8       	sub	r8,-1
80003422:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
80003426:	ef 39 00 08 	ld.ub	r9,r7[8]
8000342a:	30 1a       	mov	r10,1
8000342c:	f4 09 09 49 	lsl	r9,r10,r9
80003430:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
80003434:	f2 08 02 48 	mul	r8,r9,r8
80003438:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
8000343c:	48 68       	lddpc	r8,80003454 <SD_GetCardInfo+0x5c>
8000343e:	70 09       	ld.w	r9,r8[0x0]
80003440:	14 09       	add	r9,r10
80003442:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
80003444:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	31 30       	mov	r0,19
8000344c:	80 00       	ld.sh	r0,r0[0x0]
8000344e:	2c dc       	sub	r12,-51
80003450:	00 00       	add	r0,r0
80003452:	0a 68       	and	r8,r5
80003454:	00 00       	add	r0,r0
80003456:	0a 60       	and	r0,r5

80003458 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
80003458:	d4 01       	pushm	lr
8000345a:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
8000345c:	1a 9c       	mov	r12,sp
8000345e:	f0 1f 00 05 	mcall	80003470 <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
80003462:	41 1c       	lddsp	r12,sp[0x44]
80003464:	a1 7c       	lsl	r12,0x1
80003466:	48 48       	lddpc	r8,80003474 <SD_GetSectorCount+0x1c>
80003468:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
8000346a:	2e dd       	sub	sp,-76
8000346c:	d8 02       	popm	pc
8000346e:	00 00       	add	r0,r0
80003470:	80 00       	ld.sh	r0,r0[0x0]
80003472:	33 f8       	mov	r8,63
80003474:	00 00       	add	r0,r0
80003476:	0a 5c       	eor	r12,r5

80003478 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003478:	d4 01       	pushm	lr
	
	
	if(count == 1)
8000347a:	30 18       	mov	r8,1
8000347c:	f0 09 18 00 	cp.b	r9,r8
80003480:	c0 71       	brne	8000348e <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
80003482:	5c 7a       	castu.h	r10
80003484:	a9 7b       	lsl	r11,0x9
80003486:	f0 1f 00 07 	mcall	800034a0 <MAL_WriteDisk+0x28>
8000348a:	c0 91       	brne	8000349c <MAL_WriteDisk+0x24>
8000348c:	c0 68       	rjmp	80003498 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
8000348e:	5c 7a       	castu.h	r10
80003490:	a9 7b       	lsl	r11,0x9
80003492:	f0 1f 00 05 	mcall	800034a4 <MAL_WriteDisk+0x2c>
80003496:	c0 31       	brne	8000349c <MAL_WriteDisk+0x24>
80003498:	30 4c       	mov	r12,4
8000349a:	d8 02       	popm	pc
8000349c:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
8000349e:	d8 02       	popm	pc
800034a0:	80 00       	ld.sh	r0,r0[0x0]
800034a2:	2e d4       	sub	r4,-19
800034a4:	80 00       	ld.sh	r0,r0[0x0]
800034a6:	2e 0c       	sub	r12,-32

800034a8 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034a8:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034aa:	30 18       	mov	r8,1
800034ac:	f0 09 18 00 	cp.b	r9,r8
800034b0:	c0 71       	brne	800034be <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034b2:	5c 7a       	castu.h	r10
800034b4:	a9 7b       	lsl	r11,0x9
800034b6:	f0 1f 00 07 	mcall	800034d0 <MAL_ReadDisk+0x28>
800034ba:	c0 91       	brne	800034cc <MAL_ReadDisk+0x24>
800034bc:	c0 68       	rjmp	800034c8 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034be:	5c 7a       	castu.h	r10
800034c0:	a9 7b       	lsl	r11,0x9
800034c2:	f0 1f 00 05 	mcall	800034d4 <MAL_ReadDisk+0x2c>
800034c6:	c0 31       	brne	800034cc <MAL_ReadDisk+0x24>
800034c8:	30 8c       	mov	r12,8
800034ca:	d8 02       	popm	pc
800034cc:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
800034ce:	d8 02       	popm	pc
800034d0:	80 00       	ld.sh	r0,r0[0x0]
800034d2:	30 40       	mov	r0,4
800034d4:	80 00       	ld.sh	r0,r0[0x0]
800034d6:	2f 7c       	sub	r12,-9

800034d8 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
800034d8:	d4 01       	pushm	lr
800034da:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
800034dc:	f0 1f 00 06 	mcall	800034f4 <MAL_InitConfig+0x1c>
800034e0:	c0 30       	breq	800034e6 <MAL_InitConfig+0xe>
800034e2:	30 1c       	mov	r12,1
800034e4:	c0 58       	rjmp	800034ee <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
800034e6:	1a 9c       	mov	r12,sp
800034e8:	f0 1f 00 04 	mcall	800034f8 <MAL_InitConfig+0x20>
800034ec:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
800034ee:	2e dd       	sub	sp,-76
800034f0:	d8 02       	popm	pc
800034f2:	00 00       	add	r0,r0
800034f4:	80 00       	ld.sh	r0,r0[0x0]
800034f6:	30 d0       	mov	r0,13
800034f8:	80 00       	ld.sh	r0,r0[0x0]
800034fa:	33 f8       	mov	r8,63

800034fc <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
800034fc:	eb cd 40 f8 	pushm	r3-r7,lr
80003500:	20 2d       	sub	sp,8
80003502:	18 95       	mov	r5,r12
80003504:	16 94       	mov	r4,r11
80003506:	14 93       	mov	r3,r10
80003508:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
8000350a:	34 cc       	mov	r12,76
8000350c:	f0 1f 00 16 	mcall	80003564 <fl_write+0x68>
80003510:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
80003512:	0a 9b       	mov	r11,r5
80003514:	f0 1f 00 15 	mcall	80003568 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003518:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
8000351c:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80003520:	0c 9c       	mov	r12,r6
80003522:	f0 1f 00 11 	mcall	80003564 <fl_write+0x68>
80003526:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
8000352a:	0c 9a       	mov	r10,r6
8000352c:	06 9b       	mov	r11,r3
8000352e:	f0 1f 00 10 	mcall	8000356c <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
80003532:	e0 68 40 00 	mov	r8,16384
80003536:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003538:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
8000353a:	48 e8       	lddpc	r8,80003570 <fl_write+0x74>
8000353c:	70 0c       	ld.w	r12,r8[0x0]
8000353e:	30 09       	mov	r9,0
80003540:	12 9a       	mov	r10,r9
80003542:	1a 9b       	mov	r11,sp
80003544:	f0 1f 00 0c 	mcall	80003574 <fl_write+0x78>
80003548:	58 1c       	cp.w	r12,1
8000354a:	c0 a0       	breq	8000355e <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
8000354c:	6f 2c       	ld.w	r12,r7[0x48]
8000354e:	f0 1f 00 0b 	mcall	80003578 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
80003552:	0e 9c       	mov	r12,r7
80003554:	f0 1f 00 09 	mcall	80003578 <fl_write+0x7c>
		log("\n\r Wmm \n\r");//man...SPI_PBA
80003558:	48 9c       	lddpc	r12,8000357c <fl_write+0x80>
8000355a:	f0 1f 00 0a 	mcall	80003580 <fl_write+0x84>
	}
	
}
8000355e:	2f ed       	sub	sp,-8
80003560:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003564:	80 00       	ld.sh	r0,r0[0x0]
80003566:	93 fc       	st.w	r9[0x3c],r12
80003568:	80 00       	ld.sh	r0,r0[0x0]
8000356a:	b1 78       	lsl	r8,0x11
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	ad 06       	ld.d	r6,r6
80003570:	00 00       	add	r0,r0
80003572:	0d 40       	ld.w	r0,--r6
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	97 50       	st.w	r11[0x14],r0
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	93 d4       	st.w	r9[0x34],r4
8000357c:	80 01       	ld.sh	r1,r0[0x0]
8000357e:	0d d4       	ld.ub	r4,r6[0x5]
80003580:	80 00       	ld.sh	r0,r0[0x0]
80003582:	a3 40       	asr	r0,0x2

80003584 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
80003584:	d4 31       	pushm	r0-r7,lr
80003586:	20 1d       	sub	sp,4
80003588:	18 97       	mov	r7,r12
8000358a:	16 96       	mov	r6,r11
8000358c:	14 94       	mov	r4,r10
8000358e:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003590:	30 1a       	mov	r10,1
80003592:	4c 7b       	lddpc	r11,800036ac <fl_write_func+0x128>
80003594:	4c 7c       	lddpc	r12,800036b0 <fl_write_func+0x12c>
80003596:	f0 1f 00 48 	mcall	800036b4 <fl_write_func+0x130>
8000359a:	e0 81 00 86 	brne	800036a6 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
8000359e:	0e 91       	mov	r1,r7
800035a0:	31 2a       	mov	r10,18
800035a2:	0e 9b       	mov	r11,r7
800035a4:	4c 5c       	lddpc	r12,800036b8 <fl_write_func+0x134>
800035a6:	f0 1f 00 46 	mcall	800036bc <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800035aa:	58 5c       	cp.w	r12,5
800035ac:	c5 91       	brne	8000365e <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800035ae:	4c 0b       	lddpc	r11,800036ac <fl_write_func+0x128>
800035b0:	4c 4c       	lddpc	r12,800036c0 <fl_write_func+0x13c>
800035b2:	f0 1f 00 45 	mcall	800036c4 <fl_write_func+0x140>
800035b6:	c0 80       	breq	800035c6 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800035b8:	30 1a       	mov	r10,1
800035ba:	4b db       	lddpc	r11,800036ac <fl_write_func+0x128>
800035bc:	30 0c       	mov	r12,0
800035be:	f0 1f 00 3e 	mcall	800036b4 <fl_write_func+0x130>
800035c2:	30 6c       	mov	r12,6
			return fs_err;
800035c4:	c7 28       	rjmp	800036a8 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
800035c6:	0e 9c       	mov	r12,r7
800035c8:	f0 1f 00 40 	mcall	800036c8 <fl_write_func+0x144>
800035cc:	4c 03       	lddpc	r3,800036cc <fl_write_func+0x148>
800035ce:	18 9a       	mov	r10,r12
800035d0:	0e 9b       	mov	r11,r7
800035d2:	06 9c       	mov	r12,r3
800035d4:	f0 1f 00 3f 	mcall	800036d0 <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
800035d8:	4b 57       	lddpc	r7,800036ac <fl_write_func+0x128>
800035da:	0e 9b       	mov	r11,r7
800035dc:	06 9c       	mov	r12,r3
800035de:	f0 1f 00 3e 	mcall	800036d4 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
800035e2:	1a dc       	st.w	--sp,r12
800035e4:	4b db       	lddpc	r11,800036d8 <fl_write_func+0x154>
800035e6:	4b ec       	lddpc	r12,800036dc <fl_write_func+0x158>
800035e8:	f0 1f 00 3e 	mcall	800036e0 <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
800035ec:	0e 9b       	mov	r11,r7
800035ee:	30 0c       	mov	r12,0
800035f0:	f0 1f 00 39 	mcall	800036d4 <fl_write_func+0x150>
800035f4:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
800035f6:	2f fd       	sub	sp,-4
800035f8:	58 0c       	cp.w	r12,0
800035fa:	c2 50       	breq	80003644 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
800035fc:	4b 83       	lddpc	r3,800036dc <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
800035fe:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003600:	4b 90       	lddpc	r0,800036e4 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
80003602:	06 9c       	mov	r12,r3
80003604:	f0 1f 00 39 	mcall	800036e8 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003608:	5f 09       	sreq	r9
8000360a:	58 8c       	cp.w	r12,8
8000360c:	5f 08       	sreq	r8
8000360e:	f3 e8 10 08 	or	r8,r9,r8
80003612:	e4 08 18 00 	cp.b	r8,r2
80003616:	c1 00       	breq	80003636 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003618:	1a d7       	st.w	--sp,r7
8000361a:	1a d3       	st.w	--sp,r3
8000361c:	00 9b       	mov	r11,r0
8000361e:	06 9c       	mov	r12,r3
80003620:	f0 1f 00 30 	mcall	800036e0 <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003624:	4a 2b       	lddpc	r11,800036ac <fl_write_func+0x128>
80003626:	30 0c       	mov	r12,0
80003628:	f0 1f 00 2b 	mcall	800036d4 <fl_write_func+0x150>
8000362c:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000362e:	2f ed       	sub	sp,-8
80003630:	58 0c       	cp.w	r12,0
80003632:	ce 81       	brne	80003602 <fl_write_func+0x7e>
80003634:	c0 88       	rjmp	80003644 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003636:	30 1a       	mov	r10,1
80003638:	49 db       	lddpc	r11,800036ac <fl_write_func+0x128>
8000363a:	30 0c       	mov	r12,0
8000363c:	f0 1f 00 1e 	mcall	800036b4 <fl_write_func+0x130>
80003640:	30 4c       	mov	r12,4
					return new_dir_err;
80003642:	c3 38       	rjmp	800036a8 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003644:	31 2a       	mov	r10,18
80003646:	02 9b       	mov	r11,r1
80003648:	49 cc       	lddpc	r12,800036b8 <fl_write_func+0x134>
8000364a:	f0 1f 00 1d 	mcall	800036bc <fl_write_func+0x138>
				if(res != FR_OK)
8000364e:	c1 10       	breq	80003670 <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
80003650:	30 1a       	mov	r10,1
80003652:	49 7b       	lddpc	r11,800036ac <fl_write_func+0x128>
80003654:	30 0c       	mov	r12,0
80003656:	f0 1f 00 18 	mcall	800036b4 <fl_write_func+0x130>
8000365a:	30 3c       	mov	r12,3
					return open_fl_err;
8000365c:	c2 68       	rjmp	800036a8 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000365e:	58 0c       	cp.w	r12,0
80003660:	c0 80       	breq	80003670 <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
80003662:	30 1a       	mov	r10,1
80003664:	49 2b       	lddpc	r11,800036ac <fl_write_func+0x128>
80003666:	30 0c       	mov	r12,0
80003668:	f0 1f 00 13 	mcall	800036b4 <fl_write_func+0x130>
8000366c:	30 3c       	mov	r12,3
		return open_fl_err;
8000366e:	c1 d8       	rjmp	800036a8 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
80003670:	5b f6       	cp.w	r6,-1
80003672:	c0 61       	brne	8000367e <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
80003674:	49 1c       	lddpc	r12,800036b8 <fl_write_func+0x134>
80003676:	78 3b       	ld.w	r11,r12[0xc]
80003678:	f0 1f 00 1d 	mcall	800036ec <fl_write_func+0x168>
8000367c:	c0 58       	rjmp	80003686 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
8000367e:	0c 9b       	mov	r11,r6
80003680:	48 ec       	lddpc	r12,800036b8 <fl_write_func+0x134>
80003682:	f0 1f 00 1b 	mcall	800036ec <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
80003686:	48 d7       	lddpc	r7,800036b8 <fl_write_func+0x134>
80003688:	1a 99       	mov	r9,sp
8000368a:	0a 9a       	mov	r10,r5
8000368c:	08 9b       	mov	r11,r4
8000368e:	0e 9c       	mov	r12,r7
80003690:	f0 1f 00 18 	mcall	800036f0 <fl_write_func+0x16c>

	f_close (&fl);
80003694:	0e 9c       	mov	r12,r7
80003696:	f0 1f 00 18 	mcall	800036f4 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
8000369a:	30 1a       	mov	r10,1
8000369c:	48 4b       	lddpc	r11,800036ac <fl_write_func+0x128>
8000369e:	30 0c       	mov	r12,0
800036a0:	f0 1f 00 05 	mcall	800036b4 <fl_write_func+0x130>
800036a4:	c0 28       	rjmp	800036a8 <fl_write_func+0x124>
}
800036a6:	30 2c       	mov	r12,2
800036a8:	2f fd       	sub	sp,-4
800036aa:	d8 32       	popm	r0-r7,pc
800036ac:	80 01       	ld.sh	r1,r0[0x0]
800036ae:	0d c4       	ld.ub	r4,r6[0x4]
800036b0:	00 00       	add	r0,r0
800036b2:	0a b0       	st.h	r5++,r0
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	77 c8       	ld.w	r8,r11[0x70]
800036b8:	00 00       	add	r0,r0
800036ba:	0d c8       	ld.ub	r8,r6[0x4]
800036bc:	80 00       	ld.sh	r0,r0[0x0]
800036be:	87 94       	st.w	r3[0x24],r4
800036c0:	00 00       	add	r0,r0
800036c2:	0c e0       	st.h	--r6,r0
800036c4:	80 00       	ld.sh	r0,r0[0x0]
800036c6:	85 58       	st.w	r2[0x14],r8
800036c8:	80 00       	ld.sh	r0,r0[0x0]
800036ca:	b1 8a       	lsr	r10,0x10
800036cc:	00 00       	add	r0,r0
800036ce:	0d 44       	ld.w	r4,--r6
800036d0:	80 00       	ld.sh	r0,r0[0x0]
800036d2:	ad 06       	ld.d	r6,r6
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	b1 c0       	cbr	r0,0x10
800036d8:	80 01       	ld.sh	r1,r0[0x0]
800036da:	0d e0       	ld.ub	r0,r6[0x6]
800036dc:	00 00       	add	r0,r0
800036de:	0d 88       	ld.ub	r8,r6[0x0]
800036e0:	80 00       	ld.sh	r0,r0[0x0]
800036e2:	b1 3c       	mul	r12,r8
800036e4:	80 01       	ld.sh	r1,r0[0x0]
800036e6:	0d e8       	ld.ub	r8,r6[0x6]
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	85 dc       	st.w	r2[0x34],r12
800036ec:	80 00       	ld.sh	r0,r0[0x0]
800036ee:	8a 34       	ld.sh	r4,r5[0x6]
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	8c e8       	ld.uh	r8,r6[0xc]
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	79 14       	ld.w	r4,r12[0x44]

800036f8 <fl_read_func>:



fs_err_t fl_read_func(void * path, S32 offset, void * buffer, U32 length)
{
800036f8:	d4 31       	pushm	r0-r7,lr
800036fa:	20 1d       	sub	sp,4
800036fc:	18 97       	mov	r7,r12
800036fe:	16 96       	mov	r6,r11
80003700:	14 94       	mov	r4,r10
80003702:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003704:	30 1a       	mov	r10,1
80003706:	4c 7b       	lddpc	r11,80003820 <fl_read_func+0x128>
80003708:	4c 7c       	lddpc	r12,80003824 <fl_read_func+0x12c>
8000370a:	f0 1f 00 48 	mcall	80003828 <fl_read_func+0x130>
8000370e:	e0 81 00 86 	brne	8000381a <fl_read_func+0x122>
		{
			return amount_err;
		}
	
		FRESULT res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
80003712:	0e 91       	mov	r1,r7
80003714:	30 1a       	mov	r10,1
80003716:	0e 9b       	mov	r11,r7
80003718:	4c 5c       	lddpc	r12,8000382c <fl_read_func+0x134>
8000371a:	f0 1f 00 46 	mcall	80003830 <fl_read_func+0x138>
		if(FR_NO_PATH == res)
8000371e:	58 5c       	cp.w	r12,5
80003720:	c5 91       	brne	800037d2 <fl_read_func+0xda>
		{
			if ( f_opendir(&dirs, "/") != FR_OK)
80003722:	4c 0b       	lddpc	r11,80003820 <fl_read_func+0x128>
80003724:	4c 4c       	lddpc	r12,80003834 <fl_read_func+0x13c>
80003726:	f0 1f 00 45 	mcall	80003838 <fl_read_func+0x140>
8000372a:	c0 80       	breq	8000373a <fl_read_func+0x42>
			{
				f_mount(NULL, "/", 1);
8000372c:	30 1a       	mov	r10,1
8000372e:	4b db       	lddpc	r11,80003820 <fl_read_func+0x128>
80003730:	30 0c       	mov	r12,0
80003732:	f0 1f 00 3e 	mcall	80003828 <fl_read_func+0x130>
80003736:	30 6c       	mov	r12,6
				return fs_err;
80003738:	c7 28       	rjmp	8000381c <fl_read_func+0x124>
			}
		
			static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
			memcpy(path_bk, path, strlen(path));
8000373a:	0e 9c       	mov	r12,r7
8000373c:	f0 1f 00 40 	mcall	8000383c <fl_read_func+0x144>
80003740:	4c 03       	lddpc	r3,80003840 <fl_read_func+0x148>
80003742:	18 9a       	mov	r10,r12
80003744:	0e 9b       	mov	r11,r7
80003746:	06 9c       	mov	r12,r3
80003748:	f0 1f 00 3f 	mcall	80003844 <fl_read_func+0x14c>
				
			char * dir = strtok(path_bk,"/");
8000374c:	4b 57       	lddpc	r7,80003820 <fl_read_func+0x128>
8000374e:	0e 9b       	mov	r11,r7
80003750:	06 9c       	mov	r12,r3
80003752:	f0 1f 00 3e 	mcall	80003848 <fl_read_func+0x150>
			sprintf(filename,"//%s", dir);		
80003756:	1a dc       	st.w	--sp,r12
80003758:	4b db       	lddpc	r11,8000384c <fl_read_func+0x154>
8000375a:	4b ec       	lddpc	r12,80003850 <fl_read_func+0x158>
8000375c:	f0 1f 00 3e 	mcall	80003854 <fl_read_func+0x15c>
			dir = strtok(NULL,"/");
80003760:	0e 9b       	mov	r11,r7
80003762:	30 0c       	mov	r12,0
80003764:	f0 1f 00 39 	mcall	80003848 <fl_read_func+0x150>
80003768:	18 97       	mov	r7,r12
			while(TRUE)
			{
				if(NULL != dir)
8000376a:	2f fd       	sub	sp,-4
8000376c:	58 0c       	cp.w	r12,0
8000376e:	c2 50       	breq	800037b8 <fl_read_func+0xc0>
				{				
					res = f_mkdir(filename);
80003770:	4b 83       	lddpc	r3,80003850 <fl_read_func+0x158>
					if((res == FR_OK) || (res == FR_EXIST))
80003772:	30 02       	mov	r2,0
					{					
						sprintf(filename,"%s//%s", filename, dir);
80003774:	4b 90       	lddpc	r0,80003858 <fl_read_func+0x160>
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
				{				
					res = f_mkdir(filename);
80003776:	06 9c       	mov	r12,r3
80003778:	f0 1f 00 39 	mcall	8000385c <fl_read_func+0x164>
					if((res == FR_OK) || (res == FR_EXIST))
8000377c:	5f 09       	sreq	r9
8000377e:	58 8c       	cp.w	r12,8
80003780:	5f 08       	sreq	r8
80003782:	f3 e8 10 08 	or	r8,r9,r8
80003786:	e4 08 18 00 	cp.b	r8,r2
8000378a:	c1 00       	breq	800037aa <fl_read_func+0xb2>
					{					
						sprintf(filename,"%s//%s", filename, dir);
8000378c:	1a d7       	st.w	--sp,r7
8000378e:	1a d3       	st.w	--sp,r3
80003790:	00 9b       	mov	r11,r0
80003792:	06 9c       	mov	r12,r3
80003794:	f0 1f 00 30 	mcall	80003854 <fl_read_func+0x15c>
						dir = strtok(NULL,"/");					
80003798:	4a 2b       	lddpc	r11,80003820 <fl_read_func+0x128>
8000379a:	30 0c       	mov	r12,0
8000379c:	f0 1f 00 2b 	mcall	80003848 <fl_read_func+0x150>
800037a0:	18 97       	mov	r7,r12
			char * dir = strtok(path_bk,"/");
			sprintf(filename,"//%s", dir);		
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
800037a2:	2f ed       	sub	sp,-8
800037a4:	58 0c       	cp.w	r12,0
800037a6:	ce 81       	brne	80003776 <fl_read_func+0x7e>
800037a8:	c0 88       	rjmp	800037b8 <fl_read_func+0xc0>
						sprintf(filename,"%s//%s", filename, dir);
						dir = strtok(NULL,"/");					
					}
					else
					{
						f_mount(NULL, "/", 1);	
800037aa:	30 1a       	mov	r10,1
800037ac:	49 db       	lddpc	r11,80003820 <fl_read_func+0x128>
800037ae:	30 0c       	mov	r12,0
800037b0:	f0 1f 00 1e 	mcall	80003828 <fl_read_func+0x130>
800037b4:	30 4c       	mov	r12,4
						return new_dir_err;
800037b6:	c3 38       	rjmp	8000381c <fl_read_func+0x124>
					}
				
				}
				else
				{
					res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
800037b8:	30 1a       	mov	r10,1
800037ba:	02 9b       	mov	r11,r1
800037bc:	49 cc       	lddpc	r12,8000382c <fl_read_func+0x134>
800037be:	f0 1f 00 1d 	mcall	80003830 <fl_read_func+0x138>
					if(res != FR_OK)
800037c2:	c1 10       	breq	800037e4 <fl_read_func+0xec>
					{					
						f_mount(NULL, "/", 1);	
800037c4:	30 1a       	mov	r10,1
800037c6:	49 7b       	lddpc	r11,80003820 <fl_read_func+0x128>
800037c8:	30 0c       	mov	r12,0
800037ca:	f0 1f 00 18 	mcall	80003828 <fl_read_func+0x130>
800037ce:	30 3c       	mov	r12,3
						return open_fl_err;
800037d0:	c2 68       	rjmp	8000381c <fl_read_func+0x124>
					}
					break;
				}
			}
		}
		else if(res != FR_OK)
800037d2:	58 0c       	cp.w	r12,0
800037d4:	c0 80       	breq	800037e4 <fl_read_func+0xec>
		{
			f_mount(NULL, "/", 1);
800037d6:	30 1a       	mov	r10,1
800037d8:	49 2b       	lddpc	r11,80003820 <fl_read_func+0x128>
800037da:	30 0c       	mov	r12,0
800037dc:	f0 1f 00 13 	mcall	80003828 <fl_read_func+0x130>
800037e0:	30 3c       	mov	r12,3
			return open_fl_err;
800037e2:	c1 d8       	rjmp	8000381c <fl_read_func+0x124>
		}
	
		if(offset == FILE_END)
800037e4:	5b f6       	cp.w	r6,-1
800037e6:	c0 61       	brne	800037f2 <fl_read_func+0xfa>
		{
			f_lseek(&fl, fl.fsize);
800037e8:	49 1c       	lddpc	r12,8000382c <fl_read_func+0x134>
800037ea:	78 3b       	ld.w	r11,r12[0xc]
800037ec:	f0 1f 00 1d 	mcall	80003860 <fl_read_func+0x168>
800037f0:	c0 58       	rjmp	800037fa <fl_read_func+0x102>
		}
		else
		{
			f_lseek(&fl, offset);
800037f2:	0c 9b       	mov	r11,r6
800037f4:	48 ec       	lddpc	r12,8000382c <fl_read_func+0x134>
800037f6:	f0 1f 00 1b 	mcall	80003860 <fl_read_func+0x168>
		}
	
		UINT w;
		f_read (&fl, buffer, length, &w );
800037fa:	48 d7       	lddpc	r7,8000382c <fl_read_func+0x134>
800037fc:	1a 99       	mov	r9,sp
800037fe:	0a 9a       	mov	r10,r5
80003800:	08 9b       	mov	r11,r4
80003802:	0e 9c       	mov	r12,r7
80003804:	f0 1f 00 18 	mcall	80003864 <fl_read_func+0x16c>

		f_close (&fl);
80003808:	0e 9c       	mov	r12,r7
8000380a:	f0 1f 00 18 	mcall	80003868 <fl_read_func+0x170>
		
		f_mount(NULL, "/", 1);		
8000380e:	30 1a       	mov	r10,1
80003810:	48 4b       	lddpc	r11,80003820 <fl_read_func+0x128>
80003812:	30 0c       	mov	r12,0
80003814:	f0 1f 00 05 	mcall	80003828 <fl_read_func+0x130>
80003818:	c0 28       	rjmp	8000381c <fl_read_func+0x124>
	
	
	
	
	
}
8000381a:	30 2c       	mov	r12,2
8000381c:	2f fd       	sub	sp,-4
8000381e:	d8 32       	popm	r0-r7,pc
80003820:	80 01       	ld.sh	r1,r0[0x0]
80003822:	0d c4       	ld.ub	r4,r6[0x4]
80003824:	00 00       	add	r0,r0
80003826:	0a b0       	st.h	r5++,r0
80003828:	80 00       	ld.sh	r0,r0[0x0]
8000382a:	77 c8       	ld.w	r8,r11[0x70]
8000382c:	00 00       	add	r0,r0
8000382e:	0d c8       	ld.ub	r8,r6[0x4]
80003830:	80 00       	ld.sh	r0,r0[0x0]
80003832:	87 94       	st.w	r3[0x24],r4
80003834:	00 00       	add	r0,r0
80003836:	0c e0       	st.h	--r6,r0
80003838:	80 00       	ld.sh	r0,r0[0x0]
8000383a:	85 58       	st.w	r2[0x14],r8
8000383c:	80 00       	ld.sh	r0,r0[0x0]
8000383e:	b1 8a       	lsr	r10,0x10
80003840:	00 00       	add	r0,r0
80003842:	0a 6c       	and	r12,r5
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	ad 06       	ld.d	r6,r6
80003848:	80 00       	ld.sh	r0,r0[0x0]
8000384a:	b1 c0       	cbr	r0,0x10
8000384c:	80 01       	ld.sh	r1,r0[0x0]
8000384e:	0d e0       	ld.ub	r0,r6[0x6]
80003850:	00 00       	add	r0,r0
80003852:	0d 00       	ld.w	r0,r6++
80003854:	80 00       	ld.sh	r0,r0[0x0]
80003856:	b1 3c       	mul	r12,r8
80003858:	80 01       	ld.sh	r1,r0[0x0]
8000385a:	0d e8       	ld.ub	r8,r6[0x6]
8000385c:	80 00       	ld.sh	r0,r0[0x0]
8000385e:	85 dc       	st.w	r2[0x34],r12
80003860:	80 00       	ld.sh	r0,r0[0x0]
80003862:	8a 34       	ld.sh	r4,r5[0x6]
80003864:	80 00       	ld.sh	r0,r0[0x0]
80003866:	8e c8       	ld.uh	r8,r7[0x8]
80003868:	80 00       	ld.sh	r0,r0[0x0]
8000386a:	79 14       	ld.w	r4,r12[0x44]

8000386c <fl_oper_process>:



static void fl_oper_process(void * pvParameters)
{
8000386c:	eb cd 40 fc 	pushm	r2-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
80003870:	30 8c       	mov	r12,8
80003872:	f0 1f 00 23 	mcall	800038fc <fl_oper_process+0x90>
80003876:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003878:	4a 26       	lddpc	r6,80003900 <fl_oper_process+0x94>
8000387a:	30 05       	mov	r5,0
8000387c:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
8000387e:	e0 63 40 00 	mov	r3,16384
80003882:	e0 62 40 01 	mov	r2,16385
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003886:	6c 0c       	ld.w	r12,r6[0x0]
80003888:	0a 99       	mov	r9,r5
8000388a:	08 9a       	mov	r10,r4
8000388c:	0e 9b       	mov	r11,r7
8000388e:	f0 1f 00 1e 	mcall	80003904 <fl_oper_process+0x98>
80003892:	58 1c       	cp.w	r12,1
80003894:	cf 91       	brne	80003886 <fl_oper_process+0x1a>
		{  
			switch(fl_oper->opcode)
80003896:	8e 08       	ld.sh	r8,r7[0x0]
80003898:	e6 08 19 00 	cp.h	r8,r3
8000389c:	c0 50       	breq	800038a6 <fl_oper_process+0x3a>
8000389e:	e4 08 19 00 	cp.h	r8,r2
800038a2:	c2 61       	brne	800038ee <fl_oper_process+0x82>
800038a4:	c1 38       	rjmp	800038ca <fl_oper_process+0x5e>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
800038a6:	6e 1c       	ld.w	r12,r7[0x4]
800038a8:	58 0c       	cp.w	r12,0
800038aa:	ce e0       	breq	80003886 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
800038ac:	79 2a       	ld.w	r10,r12[0x48]
800038ae:	58 0a       	cp.w	r10,0
800038b0:	c0 90       	breq	800038c2 <fl_oper_process+0x56>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
800038b2:	79 19       	ld.w	r9,r12[0x44]
800038b4:	79 0b       	ld.w	r11,r12[0x40]
800038b6:	f0 1f 00 15 	mcall	80003908 <fl_oper_process+0x9c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
800038ba:	6e 18       	ld.w	r8,r7[0x4]
800038bc:	71 2c       	ld.w	r12,r8[0x48]
800038be:	f0 1f 00 14 	mcall	8000390c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);					
800038c2:	6e 1c       	ld.w	r12,r7[0x4]
800038c4:	f0 1f 00 12 	mcall	8000390c <fl_oper_process+0xa0>
800038c8:	cd fb       	rjmp	80003886 <fl_oper_process+0x1a>
				}
				break;
				
			case FL_READ:
			
				if(NULL != fl_oper->payload)
800038ca:	6e 1c       	ld.w	r12,r7[0x4]
800038cc:	58 0c       	cp.w	r12,0
800038ce:	cd c0       	breq	80003886 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_read_t *)(fl_oper->payload))->buffer)
800038d0:	79 2a       	ld.w	r10,r12[0x48]
800038d2:	58 0a       	cp.w	r10,0
800038d4:	c0 90       	breq	800038e6 <fl_oper_process+0x7a>
					{
						fl_read_func(((fl_read_t *)(fl_oper->payload))->path
800038d6:	79 19       	ld.w	r9,r12[0x44]
800038d8:	79 0b       	ld.w	r11,r12[0x40]
800038da:	f0 1f 00 0e 	mcall	80003910 <fl_oper_process+0xa4>
						, ((fl_read_t *)(fl_oper->payload))->offset
						, ((fl_read_t *)(fl_oper->payload))->buffer
						, ((fl_read_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_read_t *)(fl_oper->payload))->buffer);
800038de:	6e 18       	ld.w	r8,r7[0x4]
800038e0:	71 2c       	ld.w	r12,r8[0x48]
800038e2:	f0 1f 00 0b 	mcall	8000390c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);
800038e6:	6e 1c       	ld.w	r12,r7[0x4]
800038e8:	f0 1f 00 09 	mcall	8000390c <fl_oper_process+0xa0>
800038ec:	cc db       	rjmp	80003886 <fl_oper_process+0x1a>
				break;
			
			   
								
			default:
				if(NULL != fl_oper->payload)
800038ee:	6e 1c       	ld.w	r12,r7[0x4]
800038f0:	58 0c       	cp.w	r12,0
800038f2:	cc a0       	breq	80003886 <fl_oper_process+0x1a>
				{
					vPortFree(fl_oper->payload);
800038f4:	f0 1f 00 06 	mcall	8000390c <fl_oper_process+0xa0>
800038f8:	cc 7b       	rjmp	80003886 <fl_oper_process+0x1a>
800038fa:	00 00       	add	r0,r0
800038fc:	80 00       	ld.sh	r0,r0[0x0]
800038fe:	93 fc       	st.w	r9[0x3c],r12
80003900:	00 00       	add	r0,r0
80003902:	0d 40       	ld.w	r0,--r6
80003904:	80 00       	ld.sh	r0,r0[0x0]
80003906:	95 44       	st.w	r10[0x10],r4
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	35 84       	mov	r4,88
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	93 d4       	st.w	r9[0x34],r4
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	36 f8       	mov	r8,111

80003914 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
80003914:	d4 01       	pushm	lr
80003916:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
80003918:	f0 1f 00 41 	mcall	80003a1c <disk_init+0x108>
8000391c:	5c 8c       	casts.h	r12
8000391e:	c0 30       	breq	80003924 <disk_init+0x10>
80003920:	30 1c       	mov	r12,1
80003922:	c7 a8       	rjmp	80003a16 <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
80003924:	30 1a       	mov	r10,1
80003926:	4b fb       	lddpc	r11,80003a20 <disk_init+0x10c>
80003928:	4b fc       	lddpc	r12,80003a24 <disk_init+0x110>
8000392a:	f0 1f 00 40 	mcall	80003a28 <disk_init+0x114>
8000392e:	c0 30       	breq	80003934 <disk_init+0x20>
80003930:	30 2c       	mov	r12,2
80003932:	c7 28       	rjmp	80003a16 <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
80003934:	4b ea       	lddpc	r10,80003a2c <disk_init+0x118>
80003936:	4b fb       	lddpc	r11,80003a30 <disk_init+0x11c>
80003938:	4b ac       	lddpc	r12,80003a20 <disk_init+0x10c>
8000393a:	f0 1f 00 3f 	mcall	80003a34 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
8000393e:	58 dc       	cp.w	r12,13
80003940:	c1 41       	brne	80003968 <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
80003942:	e0 6a 10 00 	mov	r10,4096
80003946:	30 0b       	mov	r11,0
80003948:	16 9c       	mov	r12,r11
8000394a:	f0 1f 00 3c 	mcall	80003a38 <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
8000394e:	4b 8a       	lddpc	r10,80003a2c <disk_init+0x118>
80003950:	4b 8b       	lddpc	r11,80003a30 <disk_init+0x11c>
80003952:	4b 4c       	lddpc	r12,80003a20 <disk_init+0x10c>
80003954:	f0 1f 00 38 	mcall	80003a34 <disk_init+0x120>
80003958:	c1 10       	breq	8000397a <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
8000395a:	30 1a       	mov	r10,1
8000395c:	4b 1b       	lddpc	r11,80003a20 <disk_init+0x10c>
8000395e:	30 0c       	mov	r12,0
80003960:	f0 1f 00 32 	mcall	80003a28 <disk_init+0x114>
80003964:	30 5c       	mov	r12,5
			return no_fs;
80003966:	c5 88       	rjmp	80003a16 <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
80003968:	58 0c       	cp.w	r12,0
8000396a:	c0 80       	breq	8000397a <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
8000396c:	30 1a       	mov	r10,1
8000396e:	4a db       	lddpc	r11,80003a20 <disk_init+0x10c>
80003970:	30 0c       	mov	r12,0
80003972:	f0 1f 00 2e 	mcall	80003a28 <disk_init+0x114>
80003976:	30 6c       	mov	r12,6
		return fs_err;
80003978:	c4 f8       	rjmp	80003a16 <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
8000397a:	1a 9b       	mov	r11,sp
8000397c:	30 08       	mov	r8,0
8000397e:	30 09       	mov	r9,0
80003980:	fa e9 00 00 	st.d	sp[0],r8
80003984:	30 0a       	mov	r10,0
80003986:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
80003988:	4a 6c       	lddpc	r12,80003a20 <disk_init+0x10c>
8000398a:	f0 1f 00 2d 	mcall	80003a3c <disk_init+0x128>
8000398e:	c0 80       	breq	8000399e <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003990:	30 1a       	mov	r10,1
80003992:	4a 4b       	lddpc	r11,80003a20 <disk_init+0x10c>
80003994:	30 0c       	mov	r12,0
80003996:	f0 1f 00 25 	mcall	80003a28 <disk_init+0x114>
8000399a:	30 6c       	mov	r12,6
		return fs_err;
8000399c:	c3 d8       	rjmp	80003a16 <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
8000399e:	30 7a       	mov	r10,7
800039a0:	1a 9b       	mov	r11,sp
800039a2:	4a 8c       	lddpc	r12,80003a40 <disk_init+0x12c>
800039a4:	f0 1f 00 28 	mcall	80003a44 <disk_init+0x130>
800039a8:	c0 c0       	breq	800039c0 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
800039aa:	4a 8c       	lddpc	r12,80003a48 <disk_init+0x134>
800039ac:	f0 1f 00 28 	mcall	80003a4c <disk_init+0x138>
800039b0:	c0 80       	breq	800039c0 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
800039b2:	30 1a       	mov	r10,1
800039b4:	49 bb       	lddpc	r11,80003a20 <disk_init+0x10c>
800039b6:	30 0c       	mov	r12,0
800039b8:	f0 1f 00 1c 	mcall	80003a28 <disk_init+0x114>
800039bc:	30 6c       	mov	r12,6
			return fs_err;
800039be:	c2 c8       	rjmp	80003a16 <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
800039c0:	49 8b       	lddpc	r11,80003a20 <disk_init+0x10c>
800039c2:	4a 4c       	lddpc	r12,80003a50 <disk_init+0x13c>
800039c4:	f0 1f 00 24 	mcall	80003a54 <disk_init+0x140>
800039c8:	c2 11       	brne	80003a0a <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
800039ca:	30 aa       	mov	r10,10
800039cc:	4a 3b       	lddpc	r11,80003a58 <disk_init+0x144>
800039ce:	4a 4c       	lddpc	r12,80003a5c <disk_init+0x148>
800039d0:	f0 1f 00 24 	mcall	80003a60 <disk_init+0x14c>
800039d4:	c1 41       	brne	800039fc <disk_init+0xe8>
		{
			f_close(&fl);
800039d6:	4a 2c       	lddpc	r12,80003a5c <disk_init+0x148>
800039d8:	f0 1f 00 23 	mcall	80003a64 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
800039dc:	4a 3c       	lddpc	r12,80003a68 <disk_init+0x154>
800039de:	f0 1f 00 24 	mcall	80003a6c <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
800039e2:	4a 4c       	lddpc	r12,80003a70 <disk_init+0x15c>
800039e4:	f0 1f 00 22 	mcall	80003a6c <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
800039e8:	4a 3c       	lddpc	r12,80003a74 <disk_init+0x160>
800039ea:	f0 1f 00 21 	mcall	80003a6c <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
800039ee:	30 1a       	mov	r10,1
800039f0:	48 cb       	lddpc	r11,80003a20 <disk_init+0x10c>
800039f2:	30 0c       	mov	r12,0
800039f4:	f0 1f 00 0d 	mcall	80003a28 <disk_init+0x114>
800039f8:	30 0c       	mov	r12,0
	return fs_ok;
800039fa:	c0 e8       	rjmp	80003a16 <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
800039fc:	30 1a       	mov	r10,1
800039fe:	48 9b       	lddpc	r11,80003a20 <disk_init+0x10c>
80003a00:	30 0c       	mov	r12,0
80003a02:	f0 1f 00 0a 	mcall	80003a28 <disk_init+0x114>
80003a06:	30 6c       	mov	r12,6
			return fs_err;
80003a08:	c0 78       	rjmp	80003a16 <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
80003a0a:	30 1a       	mov	r10,1
80003a0c:	48 5b       	lddpc	r11,80003a20 <disk_init+0x10c>
80003a0e:	30 0c       	mov	r12,0
80003a10:	f0 1f 00 06 	mcall	80003a28 <disk_init+0x114>
80003a14:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
80003a16:	2f dd       	sub	sp,-12
80003a18:	d8 02       	popm	pc
80003a1a:	00 00       	add	r0,r0
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	34 d8       	mov	r8,77
80003a20:	80 01       	ld.sh	r1,r0[0x0]
80003a22:	0d c4       	ld.ub	r4,r6[0x4]
80003a24:	00 00       	add	r0,r0
80003a26:	0a b0       	st.h	r5++,r0
80003a28:	80 00       	ld.sh	r0,r0[0x0]
80003a2a:	77 c8       	ld.w	r8,r11[0x70]
80003a2c:	00 00       	add	r0,r0
80003a2e:	0d 84       	ld.ub	r4,r6[0x0]
80003a30:	00 00       	add	r0,r0
80003a32:	0a ac       	st.w	r5++,r12
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	89 48       	st.w	r4[0x10],r8
80003a38:	80 00       	ld.sh	r0,r0[0x0]
80003a3a:	6c 8c       	ld.w	r12,r6[0x20]
80003a3c:	80 00       	ld.sh	r0,r0[0x0]
80003a3e:	7e c4       	ld.w	r4,pc[0x30]
80003a40:	00 00       	add	r0,r0
80003a42:	04 f4       	st.b	--r2,r4
80003a44:	80 00       	ld.sh	r0,r0[0x0]
80003a46:	ac e0       	st.b	r6[0x6],r0
80003a48:	80 01       	ld.sh	r1,r0[0x0]
80003a4a:	0d f0       	ld.ub	r0,r6[0x7]
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	80 10       	ld.sh	r0,r0[0x2]
80003a50:	00 00       	add	r0,r0
80003a52:	0c e0       	st.h	--r6,r0
80003a54:	80 00       	ld.sh	r0,r0[0x0]
80003a56:	85 58       	st.w	r2[0x14],r8
80003a58:	80 01       	ld.sh	r1,r0[0x0]
80003a5a:	0d f8       	ld.ub	r8,r6[0x7]
80003a5c:	00 00       	add	r0,r0
80003a5e:	0d c8       	ld.ub	r8,r6[0x4]
80003a60:	80 00       	ld.sh	r0,r0[0x0]
80003a62:	87 94       	st.w	r3[0x24],r4
80003a64:	80 00       	ld.sh	r0,r0[0x0]
80003a66:	79 14       	ld.w	r4,r12[0x44]
80003a68:	80 01       	ld.sh	r1,r0[0x0]
80003a6a:	0e 00       	add	r0,r7
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	85 dc       	st.w	r2[0x34],r12
80003a70:	80 01       	ld.sh	r1,r0[0x0]
80003a72:	0e 08       	add	r8,r7
80003a74:	80 01       	ld.sh	r1,r0[0x0]
80003a76:	0e 14       	sub	r4,r7

80003a78 <fs_init>:
}



fs_err_t fs_init(void)
{
80003a78:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003a7c:	f0 1f 00 0d 	mcall	80003ab0 <fs_init+0x38>
80003a80:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003a82:	c1 31       	brne	80003aa8 <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(20, sizeof(fl_oper_t)); //20*512bytes = 10k
80003a84:	30 8b       	mov	r11,8
80003a86:	31 4c       	mov	r12,20
80003a88:	f0 1f 00 0b 	mcall	80003ab4 <fs_init+0x3c>
80003a8c:	48 b8       	lddpc	r8,80003ab8 <fs_init+0x40>
80003a8e:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003a90:	30 09       	mov	r9,0
80003a92:	1a d9       	st.w	--sp,r9
80003a94:	1a d9       	st.w	--sp,r9
80003a96:	1a d9       	st.w	--sp,r9
80003a98:	30 28       	mov	r8,2
80003a9a:	e0 6a 02 00 	mov	r10,512
80003a9e:	48 8b       	lddpc	r11,80003abc <fs_init+0x44>
80003aa0:	48 8c       	lddpc	r12,80003ac0 <fs_init+0x48>
80003aa2:	f0 1f 00 09 	mcall	80003ac4 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
80003aa6:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
80003aa8:	0e 9c       	mov	r12,r7
80003aaa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003aae:	00 00       	add	r0,r0
80003ab0:	80 00       	ld.sh	r0,r0[0x0]
80003ab2:	39 14       	mov	r4,-111
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	98 a8       	ld.uh	r8,r12[0x4]
80003ab8:	00 00       	add	r0,r0
80003aba:	0d 40       	ld.w	r0,--r6
80003abc:	80 01       	ld.sh	r1,r0[0x0]
80003abe:	0e 28       	rsub	r8,r7
80003ac0:	80 00       	ld.sh	r0,r0[0x0]
80003ac2:	38 6c       	mov	r12,-122
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	9f 7c       	st.w	pc[0x1c],r12

80003ac8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003ac8:	20 1c       	sub	r12,1
80003aca:	5c 5c       	castu.b	r12
80003acc:	31 18       	mov	r8,17
80003ace:	f0 0c 18 00 	cp.b	r12,r8
80003ad2:	e0 88 00 03 	brls	80003ad8 <CalculateBurst+0x10>
80003ad6:	5e fd       	retal	0
80003ad8:	48 28       	lddpc	r8,80003ae0 <CalculateBurst+0x18>
80003ada:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003ade:	5e fc       	retal	r12
80003ae0:	80 01       	ld.sh	r1,r0[0x0]
80003ae2:	0e 38       	cp.w	r8,r7

80003ae4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003ae4:	eb cd 40 80 	pushm	r7,lr
	payload_rx_exec = payload_rx_func;
80003ae8:	48 f8       	lddpc	r8,80003b24 <payload_init+0x40>
80003aea:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003aec:	48 f8       	lddpc	r8,80003b28 <payload_init+0x44>
80003aee:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003af0:	30 07       	mov	r7,0
80003af2:	1a d7       	st.w	--sp,r7
80003af4:	1a d7       	st.w	--sp,r7
80003af6:	1a d7       	st.w	--sp,r7
80003af8:	30 28       	mov	r8,2
80003afa:	0e 99       	mov	r9,r7
80003afc:	e0 6a 04 00 	mov	r10,1024
80003b00:	48 bb       	lddpc	r11,80003b2c <payload_init+0x48>
80003b02:	48 cc       	lddpc	r12,80003b30 <payload_init+0x4c>
80003b04:	f0 1f 00 0c 	mcall	80003b34 <payload_init+0x50>
	,  2
	,  NULL
	);
	
	/*this task is used to transmit  payload message*/
	xTaskCreate(
80003b08:	1a d7       	st.w	--sp,r7
80003b0a:	1a d7       	st.w	--sp,r7
80003b0c:	1a d7       	st.w	--sp,r7
80003b0e:	30 28       	mov	r8,2
80003b10:	0e 99       	mov	r9,r7
80003b12:	e0 6a 04 00 	mov	r10,1024
80003b16:	48 9b       	lddpc	r11,80003b38 <payload_init+0x54>
80003b18:	48 9c       	lddpc	r12,80003b3c <payload_init+0x58>
80003b1a:	f0 1f 00 07 	mcall	80003b34 <payload_init+0x50>
80003b1e:	2f ad       	sub	sp,-24
	,  2
	,  NULL
	);
	
	
}
80003b20:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b24:	00 00       	add	r0,r0
80003b26:	0f f0       	ld.ub	r0,r7[0x7]
80003b28:	00 00       	add	r0,r0
80003b2a:	0f f4       	ld.ub	r4,r7[0x7]
80003b2c:	80 01       	ld.sh	r1,r0[0x0]
80003b2e:	14 30       	cp.w	r0,r10
80003b30:	80 00       	ld.sh	r0,r0[0x0]
80003b32:	3b 8c       	mov	r12,-72
80003b34:	80 00       	ld.sh	r0,r0[0x0]
80003b36:	9f 7c       	st.w	pc[0x1c],r12
80003b38:	80 01       	ld.sh	r1,r0[0x0]
80003b3a:	14 3c       	cp.w	r12,r10
80003b3c:	80 00       	ld.sh	r0,r0[0x0]
80003b3e:	3b 40       	mov	r0,-76

80003b40 <payload_tx_process>:
Description: Transmit the payload
Calls:
Called By:task
*/
static void payload_tx_process(void * pvParameters)
{
80003b40:	eb cd 40 f8 	pushm	r3-r7,lr
80003b44:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
	
	if(NULL == phy_payload_frame_tx)
80003b46:	48 e8       	lddpc	r8,80003b7c <payload_tx_process+0x3c>
80003b48:	70 08       	ld.w	r8,r8[0x0]
80003b4a:	58 08       	cp.w	r8,0
80003b4c:	c0 71       	brne	80003b5a <payload_tx_process+0x1a>
	{
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003b4e:	30 4b       	mov	r11,4
80003b50:	30 5c       	mov	r12,5
80003b52:	f0 1f 00 0c 	mcall	80003b80 <payload_tx_process+0x40>
80003b56:	48 a8       	lddpc	r8,80003b7c <payload_tx_process+0x3c>
80003b58:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003b5a:	48 96       	lddpc	r6,80003b7c <payload_tx_process+0x3c>
80003b5c:	30 05       	mov	r5,0
80003b5e:	3f f4       	mov	r4,-1
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003b60:	48 93       	lddpc	r3,80003b84 <payload_tx_process+0x44>
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003b62:	6c 0c       	ld.w	r12,r6[0x0]
80003b64:	0a 99       	mov	r9,r5
80003b66:	08 9a       	mov	r10,r4
80003b68:	1a 9b       	mov	r11,sp
80003b6a:	f0 1f 00 08 	mcall	80003b88 <payload_tx_process+0x48>
80003b6e:	58 1c       	cp.w	r12,1
80003b70:	cf 91       	brne	80003b62 <payload_tx_process+0x22>
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003b72:	66 08       	ld.w	r8,r3[0x0]
80003b74:	40 0c       	lddsp	r12,sp[0x0]
80003b76:	5d 18       	icall	r8
80003b78:	cf 5b       	rjmp	80003b62 <payload_tx_process+0x22>
80003b7a:	00 00       	add	r0,r0
80003b7c:	00 00       	add	r0,r0
80003b7e:	10 6c       	and	r12,r8
80003b80:	80 00       	ld.sh	r0,r0[0x0]
80003b82:	98 a8       	ld.uh	r8,r12[0x4]
80003b84:	00 00       	add	r0,r0
80003b86:	0f f4       	ld.ub	r4,r7[0x7]
80003b88:	80 00       	ld.sh	r0,r0[0x0]
80003b8a:	95 44       	st.w	r10[0x10],r4

80003b8c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003b8c:	eb cd 40 f8 	pushm	r3-r7,lr
80003b90:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003b92:	48 e8       	lddpc	r8,80003bc8 <payload_rx_process+0x3c>
80003b94:	70 08       	ld.w	r8,r8[0x0]
80003b96:	58 08       	cp.w	r8,0
80003b98:	c0 71       	brne	80003ba6 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003b9a:	30 4b       	mov	r11,4
80003b9c:	30 5c       	mov	r12,5
80003b9e:	f0 1f 00 0c 	mcall	80003bcc <payload_rx_process+0x40>
80003ba2:	48 a8       	lddpc	r8,80003bc8 <payload_rx_process+0x3c>
80003ba4:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003ba6:	48 96       	lddpc	r6,80003bc8 <payload_rx_process+0x3c>
80003ba8:	30 05       	mov	r5,0
80003baa:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003bac:	48 93       	lddpc	r3,80003bd0 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003bae:	6c 0c       	ld.w	r12,r6[0x0]
80003bb0:	0a 99       	mov	r9,r5
80003bb2:	08 9a       	mov	r10,r4
80003bb4:	1a 9b       	mov	r11,sp
80003bb6:	f0 1f 00 08 	mcall	80003bd4 <payload_rx_process+0x48>
80003bba:	58 1c       	cp.w	r12,1
80003bbc:	cf 91       	brne	80003bae <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003bbe:	66 08       	ld.w	r8,r3[0x0]
80003bc0:	40 0c       	lddsp	r12,sp[0x0]
80003bc2:	5d 18       	icall	r8
80003bc4:	cf 5b       	rjmp	80003bae <payload_rx_process+0x22>
80003bc6:	00 00       	add	r0,r0
80003bc8:	00 00       	add	r0,r0
80003bca:	10 08       	add	r8,r8
80003bcc:	80 00       	ld.sh	r0,r0[0x0]
80003bce:	98 a8       	ld.uh	r8,r12[0x4]
80003bd0:	00 00       	add	r0,r0
80003bd2:	0f f0       	ld.ub	r0,r7[0x7]
80003bd4:	80 00       	ld.sh	r0,r0[0x0]
80003bd6:	95 44       	st.w	r10[0x10],r4

80003bd8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003bd8:	d4 01       	pushm	lr
80003bda:	20 2d       	sub	sp,8
80003bdc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003bde:	30 09       	mov	r9,0
80003be0:	fa ca ff f8 	sub	r10,sp,-8
80003be4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003be6:	1a 9b       	mov	r11,sp
80003be8:	f0 1f 00 02 	mcall	80003bf0 <set_idle_store_isr+0x18>
}
80003bec:	2f ed       	sub	sp,-8
80003bee:	d8 02       	popm	pc
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	97 00       	st.w	r11[0x0],r0

80003bf4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003bf4:	d4 01       	pushm	lr
80003bf6:	20 2d       	sub	sp,8
80003bf8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003bfa:	58 0c       	cp.w	r12,0
80003bfc:	c1 10       	breq	80003c1e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003bfe:	30 08       	mov	r8,0
80003c00:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003c02:	98 88       	ld.uh	r8,r12[0x0]
80003c04:	e2 18 f0 00 	andl	r8,0xf000,COH
80003c08:	e0 48 40 00 	cp.w	r8,16384
80003c0c:	c0 91       	brne	80003c1e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003c0e:	48 68       	lddpc	r8,80003c24 <phy_rx+0x30>
80003c10:	70 0c       	ld.w	r12,r8[0x0]
80003c12:	30 09       	mov	r9,0
80003c14:	fa ca ff fc 	sub	r10,sp,-4
80003c18:	1a 9b       	mov	r11,sp
80003c1a:	f0 1f 00 04 	mcall	80003c28 <phy_rx+0x34>
		}	

    }
		
 
}
80003c1e:	2f ed       	sub	sp,-8
80003c20:	d8 02       	popm	pc
80003c22:	00 00       	add	r0,r0
80003c24:	00 00       	add	r0,r0
80003c26:	10 68       	and	r8,r8
80003c28:	80 00       	ld.sh	r0,r0[0x0]
80003c2a:	97 00       	st.w	r11[0x0],r0

80003c2c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003c2c:	eb cd 40 80 	pushm	r7,lr
80003c30:	20 1d       	sub	sp,4
80003c32:	fa c7 ff fc 	sub	r7,sp,-4
80003c36:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003c38:	30 09       	mov	r9,0
80003c3a:	12 9a       	mov	r10,r9
80003c3c:	1a 9b       	mov	r11,sp
80003c3e:	f0 1f 00 03 	mcall	80003c48 <set_idle_store+0x1c>
}
80003c42:	2f fd       	sub	sp,-4
80003c44:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	97 50       	st.w	r11[0x14],r0

80003c4c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003c4c:	d4 01       	pushm	lr
80003c4e:	20 1d       	sub	sp,4
80003c50:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003c52:	98 88       	ld.uh	r8,r12[0x0]
80003c54:	e2 18 f0 00 	andl	r8,0xf000,COH
80003c58:	e0 48 40 00 	cp.w	r8,16384
80003c5c:	c0 d1       	brne	80003c76 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003c5e:	49 08       	lddpc	r8,80003c9c <phy_tx+0x50>
80003c60:	70 08       	ld.w	r8,r8[0x0]
80003c62:	58 08       	cp.w	r8,0
80003c64:	c1 a0       	breq	80003c98 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003c66:	48 e8       	lddpc	r8,80003c9c <phy_tx+0x50>
80003c68:	70 0c       	ld.w	r12,r8[0x0]
80003c6a:	30 09       	mov	r9,0
80003c6c:	12 9a       	mov	r10,r9
80003c6e:	1a 9b       	mov	r11,sp
80003c70:	f0 1f 00 0c 	mcall	80003ca0 <phy_tx+0x54>
80003c74:	c1 28       	rjmp	80003c98 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003c76:	e0 48 10 00 	cp.w	r8,4096
80003c7a:	5f 0a       	sreq	r10
80003c7c:	e0 48 20 00 	cp.w	r8,8192
80003c80:	5f 09       	sreq	r9
80003c82:	f5 e9 10 09 	or	r9,r10,r9
80003c86:	c0 71       	brne	80003c94 <phy_tx+0x48>
80003c88:	e0 48 50 00 	cp.w	r8,20480
80003c8c:	c0 40       	breq	80003c94 <phy_tx+0x48>
80003c8e:	e0 48 60 00 	cp.w	r8,24576
80003c92:	c0 31       	brne	80003c98 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003c94:	48 48       	lddpc	r8,80003ca4 <phy_tx+0x58>
80003c96:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003c98:	2f fd       	sub	sp,-4
80003c9a:	d8 02       	popm	pc
80003c9c:	00 00       	add	r0,r0
80003c9e:	10 7c       	tst	r12,r8
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	97 50       	st.w	r11[0x14],r0
80003ca4:	00 00       	add	r0,r0
80003ca6:	10 6c       	and	r12,r8

80003ca8 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003ca8:	d4 01       	pushm	lr
80003caa:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003cac:	30 08       	mov	r8,0
80003cae:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003cb0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003cb2:	1a 9a       	mov	r10,sp
80003cb4:	fa cb ff fc 	sub	r11,sp,-4
80003cb8:	f0 1f 00 05 	mcall	80003ccc <get_idle_store_isr+0x24>
80003cbc:	58 1c       	cp.w	r12,1
80003cbe:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003cc2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003cc6:	2f ed       	sub	sp,-8
80003cc8:	d8 02       	popm	pc
80003cca:	00 00       	add	r0,r0
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	94 54       	ld.sh	r4,r10[0xa]

80003cd0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003cd0:	eb cd 40 c0 	pushm	r6-r7,lr
80003cd4:	20 1d       	sub	sp,4
80003cd6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003cd8:	fe f8 05 c4 	ld.w	r8,pc[1476]
80003cdc:	70 08       	ld.w	r8,r8[0x0]
80003cde:	58 08       	cp.w	r8,0
80003ce0:	c7 40       	breq	80003dc8 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003ce2:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003ce4:	30 08       	mov	r8,0
80003ce6:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003ce8:	fe f8 05 b8 	ld.w	r8,pc[1464]
80003cec:	70 08       	ld.w	r8,r8[0x0]
80003cee:	58 18       	cp.w	r8,1
80003cf0:	c2 90       	breq	80003d42 <phy_tx_func+0x72>
80003cf2:	c0 43       	brcs	80003cfa <phy_tx_func+0x2a>
80003cf4:	58 28       	cp.w	r8,2
80003cf6:	c6 91       	brne	80003dc8 <phy_tx_func+0xf8>
80003cf8:	c6 18       	rjmp	80003dba <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003cfa:	fe f8 05 a2 	ld.w	r8,pc[1442]
80003cfe:	70 0c       	ld.w	r12,r8[0x0]
80003d00:	1a 9a       	mov	r10,sp
80003d02:	fe fb 05 a2 	ld.w	r11,pc[1442]
80003d06:	f0 1f 01 69 	mcall	800042a8 <phy_tx_func+0x5d8>
80003d0a:	58 1c       	cp.w	r12,1
80003d0c:	c1 51       	brne	80003d36 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003d0e:	fe f8 05 96 	ld.w	r8,pc[1430]
80003d12:	70 08       	ld.w	r8,r8[0x0]
80003d14:	11 9a       	ld.ub	r10,r8[0x1]
80003d16:	fe f9 05 96 	ld.w	r9,pc[1430]
80003d1a:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003d1c:	90 88       	ld.uh	r8,r8[0x0]
80003d1e:	ea 18 ab cd 	orh	r8,0xabcd
80003d22:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003d24:	30 19       	mov	r9,1
80003d26:	fe f8 05 8a 	ld.w	r8,pc[1418]
80003d2a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003d2c:	30 19       	mov	r9,1
80003d2e:	fe f8 05 72 	ld.w	r8,pc[1394]
80003d32:	91 09       	st.w	r8[0x0],r9
80003d34:	c4 a8       	rjmp	80003dc8 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003d36:	e0 68 5a 5a 	mov	r8,23130
80003d3a:	ea 18 ab cd 	orh	r8,0xabcd
80003d3e:	8f 18       	st.w	r7[0x4],r8
80003d40:	c4 48       	rjmp	80003dc8 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003d42:	fe f9 05 6e 	ld.w	r9,pc[1390]
80003d46:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003d48:	fe fa 05 5c 	ld.w	r10,pc[1372]
80003d4c:	74 0a       	ld.w	r10,r10[0x0]
80003d4e:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003d52:	b1 6a       	lsl	r10,0x10
80003d54:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003d56:	2f f8       	sub	r8,-1
80003d58:	5c 58       	castu.b	r8
80003d5a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003d5c:	fe fa 05 50 	ld.w	r10,pc[1360]
80003d60:	94 09       	ld.sh	r9,r10[0x0]
80003d62:	20 29       	sub	r9,2
80003d64:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003d66:	30 0a       	mov	r10,0
80003d68:	f4 09 19 00 	cp.h	r9,r10
80003d6c:	e0 89 00 0b 	brgt	80003d82 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003d70:	78 18       	ld.w	r8,r12[0x4]
80003d72:	e8 18 00 ba 	orl	r8,0xba
80003d76:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003d78:	30 09       	mov	r9,0
80003d7a:	fe f8 05 26 	ld.w	r8,pc[1318]
80003d7e:	91 09       	st.w	r8[0x0],r9
80003d80:	c2 48       	rjmp	80003dc8 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003d82:	fe f9 05 22 	ld.w	r9,pc[1314]
80003d86:	72 09       	ld.w	r9,r9[0x0]
80003d88:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003d8c:	78 1a       	ld.w	r10,r12[0x4]
80003d8e:	f5 e9 10 09 	or	r9,r10,r9
80003d92:	99 19       	st.w	r12[0x4],r9
80003d94:	2f f8       	sub	r8,-1
80003d96:	fe f9 05 1a 	ld.w	r9,pc[1306]
80003d9a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003d9c:	fe f9 05 10 	ld.w	r9,pc[1296]
80003da0:	92 08       	ld.sh	r8,r9[0x0]
80003da2:	20 28       	sub	r8,2
80003da4:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003da6:	30 09       	mov	r9,0
80003da8:	f2 08 19 00 	cp.h	r8,r9
80003dac:	e0 89 00 0e 	brgt	80003dc8 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003db0:	30 29       	mov	r9,2
80003db2:	fe f8 04 ee 	ld.w	r8,pc[1262]
80003db6:	91 09       	st.w	r8[0x0],r9
80003db8:	c0 88       	rjmp	80003dc8 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003dba:	fc 18 00 ba 	movh	r8,0xba
80003dbe:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003dc0:	30 09       	mov	r9,0
80003dc2:	fe f8 04 de 	ld.w	r8,pc[1246]
80003dc6:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80003dc8:	fe f8 04 ec 	ld.w	r8,pc[1260]
80003dcc:	11 89       	ld.ub	r9,r8[0x0]
80003dce:	30 18       	mov	r8,1
80003dd0:	f0 09 18 00 	cp.b	r9,r8
80003dd4:	c0 90       	breq	80003de6 <phy_tx_func+0x116>
80003dd6:	fe f8 04 e2 	ld.w	r8,pc[1250]
80003dda:	11 89       	ld.ub	r9,r8[0x0]
80003ddc:	30 18       	mov	r8,1
80003dde:	f0 09 18 00 	cp.b	r9,r8
80003de2:	e0 81 00 f5 	brne	80003fcc <phy_tx_func+0x2fc>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003de6:	fe f8 04 d6 	ld.w	r8,pc[1238]
80003dea:	70 08       	ld.w	r8,r8[0x0]
80003dec:	e0 48 05 b0 	cp.w	r8,1456
80003df0:	f9 b8 02 00 	movhs	r8,0
80003df4:	fe f9 04 c8 	ld.w	r9,pc[1224]
80003df8:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80003dfa:	fe f9 04 c6 	ld.w	r9,pc[1222]
80003dfe:	72 09       	ld.w	r9,r9[0x0]
80003e00:	58 29       	cp.w	r9,2
80003e02:	e0 80 00 92 	breq	80003f26 <phy_tx_func+0x256>
80003e06:	e0 8b 00 08 	brhi	80003e16 <phy_tx_func+0x146>
80003e0a:	58 09       	cp.w	r9,0
80003e0c:	c0 e0       	breq	80003e28 <phy_tx_func+0x158>
80003e0e:	58 19       	cp.w	r9,1
80003e10:	e0 81 00 d2 	brne	80003fb4 <phy_tx_func+0x2e4>
80003e14:	c5 78       	rjmp	80003ec2 <phy_tx_func+0x1f2>
80003e16:	58 49       	cp.w	r9,4
80003e18:	e0 80 00 b1 	breq	80003f7a <phy_tx_func+0x2aa>
80003e1c:	e0 83 00 9c 	brlo	80003f54 <phy_tx_func+0x284>
80003e20:	58 59       	cp.w	r9,5
80003e22:	e0 81 00 c9 	brne	80003fb4 <phy_tx_func+0x2e4>
80003e26:	cb a8       	rjmp	80003f9a <phy_tx_func+0x2ca>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003e28:	fe f8 04 9c 	ld.w	r8,pc[1180]
80003e2c:	70 08       	ld.w	r8,r8[0x0]
80003e2e:	58 08       	cp.w	r8,0
80003e30:	c0 b0       	breq	80003e46 <phy_tx_func+0x176>
80003e32:	fe f8 04 92 	ld.w	r8,pc[1170]
80003e36:	70 08       	ld.w	r8,r8[0x0]
80003e38:	58 a8       	cp.w	r8,10
80003e3a:	c0 60       	breq	80003e46 <phy_tx_func+0x176>
80003e3c:	fe f8 04 88 	ld.w	r8,pc[1160]
80003e40:	70 08       	ld.w	r8,r8[0x0]
80003e42:	58 18       	cp.w	r8,1
80003e44:	c0 a1       	brne	80003e58 <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003e46:	e0 68 5a 5a 	mov	r8,23130
80003e4a:	ea 18 ab cd 	orh	r8,0xabcd
80003e4e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003e50:	30 08       	mov	r8,0
80003e52:	8f 38       	st.w	r7[0xc],r8
80003e54:	e0 8f 02 20 	bral	80004294 <phy_tx_func+0x5c4>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003e58:	fe f8 04 6c 	ld.w	r8,pc[1132]
80003e5c:	70 08       	ld.w	r8,r8[0x0]
80003e5e:	58 38       	cp.w	r8,3
80003e60:	c0 91       	brne	80003e72 <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003e62:	fe f8 04 66 	ld.w	r8,pc[1126]
80003e66:	70 09       	ld.w	r9,r8[0x0]
80003e68:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003e6a:	70 18       	ld.w	r8,r8[0x4]
80003e6c:	8f 38       	st.w	r7[0xc],r8
80003e6e:	e0 8f 02 13 	bral	80004294 <phy_tx_func+0x5c4>
				else//
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//
80003e72:	fe f8 04 52 	ld.w	r8,pc[1106]
80003e76:	70 08       	ld.w	r8,r8[0x0]
80003e78:	58 28       	cp.w	r8,2
80003e7a:	c1 31       	brne	80003ea0 <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80003e7c:	e0 68 c0 14 	mov	r8,49172
80003e80:	ea 18 ab cd 	orh	r8,0xabcd
80003e84:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80003e86:	fe 78 84 7f 	mov	r8,-31617
80003e8a:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80003e8c:	fe f8 04 40 	ld.w	r8,pc[1088]
80003e90:	90 08       	ld.sh	r8,r8[0x0]
80003e92:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80003e94:	30 39       	mov	r9,3
80003e96:	fe f8 04 2a 	ld.w	r8,pc[1066]
80003e9a:	91 09       	st.w	r8[0x0],r9
80003e9c:	e0 8f 01 fc 	bral	80004294 <phy_tx_func+0x5c4>
					
					else
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003ea0:	e0 68 c0 0e 	mov	r8,49166
80003ea4:	ea 18 ab cd 	orh	r8,0xabcd
80003ea8:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80003eaa:	fe f8 04 26 	ld.w	r8,pc[1062]
80003eae:	90 09       	ld.sh	r9,r8[0x0]
80003eb0:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80003eb2:	90 18       	ld.sh	r8,r8[0x2]
80003eb4:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80003eb6:	30 19       	mov	r9,1
80003eb8:	fe f8 04 08 	ld.w	r8,pc[1032]
80003ebc:	91 09       	st.w	r8[0x0],r9
80003ebe:	e0 8f 01 eb 	bral	80004294 <phy_tx_func+0x5c4>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003ec2:	fe 78 88 f2 	mov	r8,-30478
80003ec6:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003ec8:	fe f8 03 f4 	ld.w	r8,pc[1012]
80003ecc:	70 0a       	ld.w	r10,r8[0x0]
80003ece:	fe f9 04 06 	ld.w	r9,pc[1030]
80003ed2:	f2 0a 00 0b 	add	r11,r9,r10
80003ed6:	17 9b       	ld.ub	r11,r11[0x1]
80003ed8:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80003edc:	a9 6a       	lsl	r10,0x8
80003ede:	f6 0a 00 0a 	add	r10,r11,r10
80003ee2:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80003ee4:	70 0a       	ld.w	r10,r8[0x0]
80003ee6:	2f ea       	sub	r10,-2
80003ee8:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003eea:	f2 0a 00 0b 	add	r11,r9,r10
80003eee:	17 9b       	ld.ub	r11,r11[0x1]
80003ef0:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80003ef4:	a9 6a       	lsl	r10,0x8
80003ef6:	f6 0a 00 0a 	add	r10,r11,r10
80003efa:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80003efc:	70 0a       	ld.w	r10,r8[0x0]
80003efe:	2f ea       	sub	r10,-2
80003f00:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003f02:	f2 0a 00 0b 	add	r11,r9,r10
80003f06:	17 9b       	ld.ub	r11,r11[0x1]
80003f08:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80003f0c:	a9 69       	lsl	r9,0x8
80003f0e:	f6 09 00 09 	add	r9,r11,r9
80003f12:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80003f14:	70 09       	ld.w	r9,r8[0x0]
80003f16:	2f e9       	sub	r9,-2
80003f18:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80003f1a:	30 29       	mov	r9,2
80003f1c:	fe f8 03 a4 	ld.w	r8,pc[932]
80003f20:	91 09       	st.w	r8[0x0],r9
80003f22:	e0 8f 01 b9 	bral	80004294 <phy_tx_func+0x5c4>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
80003f26:	fe f9 03 ae 	ld.w	r9,pc[942]
80003f2a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80003f2e:	a9 68       	lsl	r8,0x8
80003f30:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80003f32:	fe f8 03 8a 	ld.w	r8,pc[906]
80003f36:	70 09       	ld.w	r9,r8[0x0]
80003f38:	2f f9       	sub	r9,-1
80003f3a:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80003f3c:	e0 68 00 ba 	mov	r8,186
80003f40:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003f42:	30 08       	mov	r8,0
80003f44:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003f46:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80003f48:	30 09       	mov	r9,0
80003f4a:	fe f8 03 76 	ld.w	r8,pc[886]
80003f4e:	91 09       	st.w	r8[0x0],r9
80003f50:	e0 8f 01 a2 	bral	80004294 <phy_tx_func+0x5c4>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80003f54:	fe f8 03 78 	ld.w	r8,pc[888]
80003f58:	90 18       	ld.sh	r8,r8[0x2]
80003f5a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80003f5c:	fe f8 03 74 	ld.w	r8,pc[884]
80003f60:	90 09       	ld.sh	r9,r8[0x0]
80003f62:	ae 59       	st.h	r7[0xa],r9
					//0xF00x
					payload_tx_channel->word[2] = VBSP_data[1];
80003f64:	90 18       	ld.sh	r8,r8[0x2]
80003f66:	ae 68       	st.h	r7[0xc],r8
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80003f68:	fe 78 88 f3 	mov	r8,-30477
80003f6c:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80003f6e:	30 49       	mov	r9,4
80003f70:	fe f8 03 50 	ld.w	r8,pc[848]
80003f74:	91 09       	st.w	r8[0x0],r9
80003f76:	e0 8f 01 8f 	bral	80004294 <phy_tx_func+0x5c4>
					
				break;
			case AMBE_DE_SECOND:
					
					//0xxxxx
					payload_tx_channel->word[0] = AMBEBurst_rawdata[0];
80003f7a:	fe f8 03 5e 	ld.w	r8,pc[862]
80003f7e:	90 09       	ld.sh	r9,r8[0x0]
80003f80:	ae 49       	st.h	r7[0x8],r9
					//0xxxxx
					payload_tx_channel->word[1] = AMBEBurst_rawdata[1];
80003f82:	90 19       	ld.sh	r9,r8[0x2]
80003f84:	ae 59       	st.h	r7[0xa],r9
					//0xxxxx
					payload_tx_channel->word[2] = AMBEBurst_rawdata[2];
80003f86:	90 29       	ld.sh	r9,r8[0x4]
80003f88:	ae 69       	st.h	r7[0xc],r9
					//0xxxxx
					payload_tx_channel->word[3] = AMBEBurst_rawdata[3];
80003f8a:	90 38       	ld.sh	r8,r8[0x6]
80003f8c:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_DE_LAST;
80003f8e:	30 59       	mov	r9,5
80003f90:	fe f8 03 30 	ld.w	r8,pc[816]
80003f94:	91 09       	st.w	r8[0x0],r9
80003f96:	e0 8f 01 7f 	bral	80004294 <phy_tx_func+0x5c4>
				
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80003f9a:	e0 68 00 ba 	mov	r8,186
80003f9e:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80003fa0:	30 08       	mov	r8,0
80003fa2:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003fa4:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003fa6:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80003fa8:	30 09       	mov	r9,0
80003faa:	fe f8 03 16 	ld.w	r8,pc[790]
80003fae:	91 09       	st.w	r8[0x0],r9
80003fb0:	e0 8f 01 72 	bral	80004294 <phy_tx_func+0x5c4>
				
				
				
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003fb4:	e0 68 5a 5a 	mov	r8,23130
80003fb8:	ea 18 ab cd 	orh	r8,0xabcd
80003fbc:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003fbe:	30 08       	mov	r8,0
80003fc0:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80003fc2:	fe f9 02 fe 	ld.w	r9,pc[766]
80003fc6:	93 08       	st.w	r9[0x0],r8
80003fc8:	e0 8f 01 66 	bral	80004294 <phy_tx_func+0x5c4>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80003fcc:	fe f8 03 10 	ld.w	r8,pc[784]
80003fd0:	70 08       	ld.w	r8,r8[0x0]
80003fd2:	e0 48 76 20 	cp.w	r8,30240
80003fd6:	f9 b8 02 00 	movhs	r8,0
80003fda:	fe f9 03 02 	ld.w	r9,pc[770]
80003fde:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80003fe0:	fe f8 03 00 	ld.w	r8,pc[768]
80003fe4:	11 89       	ld.ub	r9,r8[0x0]
80003fe6:	30 18       	mov	r8,1
80003fe8:	f0 09 18 00 	cp.b	r9,r8
80003fec:	c0 61       	brne	80003ff8 <phy_tx_func+0x328>
80003fee:	fe f8 02 f6 	ld.w	r8,pc[758]
80003ff2:	70 09       	ld.w	r9,r8[0x0]
80003ff4:	2f f9       	sub	r9,-1
80003ff6:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80003ff8:	fe f8 02 f0 	ld.w	r8,pc[752]
80003ffc:	11 88       	ld.ub	r8,r8[0x0]
80003ffe:	30 19       	mov	r9,1
80004000:	f2 08 18 00 	cp.b	r8,r9
80004004:	c3 60       	breq	80004070 <phy_tx_func+0x3a0>
80004006:	c0 73       	brcs	80004014 <phy_tx_func+0x344>
80004008:	30 29       	mov	r9,2
8000400a:	f2 08 18 00 	cp.b	r8,r9
8000400e:	e0 81 01 40 	brne	8000428e <phy_tx_func+0x5be>
80004012:	c7 e8       	rjmp	8000410e <phy_tx_func+0x43e>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004014:	e0 68 5a 5a 	mov	r8,23130
80004018:	ea 18 ab cd 	orh	r8,0xabcd
8000401c:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000401e:	30 08       	mov	r8,0
80004020:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80004022:	fe f8 02 c2 	ld.w	r8,pc[706]
80004026:	70 08       	ld.w	r8,r8[0x0]
80004028:	e0 6b cc cd 	mov	r11,52429
8000402c:	ea 1b cc cc 	orh	r11,0xcccc
80004030:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80004034:	f6 09 16 04 	lsr	r9,r11,0x4
80004038:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000403c:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80004040:	c1 21       	brne	80004064 <phy_tx_func+0x394>
80004042:	58 08       	cp.w	r8,0
80004044:	c1 00       	breq	80004064 <phy_tx_func+0x394>
80004046:	fe f8 02 9a 	ld.w	r8,pc[666]
8000404a:	11 89       	ld.ub	r9,r8[0x0]
8000404c:	30 18       	mov	r8,1
8000404e:	f0 09 18 00 	cp.b	r9,r8
80004052:	c0 91       	brne	80004064 <phy_tx_func+0x394>
			{
				payload_tx_state = 1;
80004054:	10 99       	mov	r9,r8
80004056:	fe f8 02 92 	ld.w	r8,pc[658]
8000405a:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
8000405c:	30 09       	mov	r9,0
8000405e:	fe f8 02 8e 	ld.w	r8,pc[654]
80004062:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80004064:	fe f8 02 8c 	ld.w	r8,pc[652]
80004068:	70 09       	ld.w	r9,r8[0x0]
8000406a:	2f f9       	sub	r9,-1
8000406c:	91 09       	st.w	r8[0x0],r9
8000406e:	c1 39       	rjmp	80004294 <phy_tx_func+0x5c4>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80004070:	fe 78 ab cd 	mov	r8,-21555
80004074:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80004076:	fe f8 02 76 	ld.w	r8,pc[630]
8000407a:	11 89       	ld.ub	r9,r8[0x0]
8000407c:	30 08       	mov	r8,0
8000407e:	f0 09 18 00 	cp.b	r9,r8
80004082:	c1 b1       	brne	800040b8 <phy_tx_func+0x3e8>
			{
				if (Silent_flag == 1)
80004084:	fe f8 02 70 	ld.w	r8,pc[624]
80004088:	11 89       	ld.ub	r9,r8[0x0]
8000408a:	30 18       	mov	r8,1
8000408c:	f0 09 18 00 	cp.b	r9,r8
80004090:	c0 91       	brne	800040a2 <phy_tx_func+0x3d2>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80004092:	32 c9       	mov	r9,44
80004094:	fe f8 02 64 	ld.w	r8,pc[612]
80004098:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
8000409a:	e0 68 10 2c 	mov	r8,4140
8000409e:	ae 58       	st.h	r7[0xa],r8
800040a0:	c0 88       	rjmp	800040b0 <phy_tx_func+0x3e0>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
800040a2:	32 a9       	mov	r9,42
800040a4:	fe f8 02 54 	ld.w	r8,pc[596]
800040a8:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
800040aa:	e0 68 10 2a 	mov	r8,4138
800040ae:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
800040b0:	30 19       	mov	r9,1
800040b2:	fe f8 02 4a 	ld.w	r8,pc[586]
800040b6:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
800040b8:	fe f8 02 3c 	ld.w	r8,pc[572]
800040bc:	11 89       	ld.ub	r9,r8[0x0]
800040be:	30 18       	mov	r8,1
800040c0:	f0 09 18 00 	cp.b	r9,r8
800040c4:	c0 61       	brne	800040d0 <phy_tx_func+0x400>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
800040c6:	30 18       	mov	r8,1
800040c8:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
800040ca:	30 48       	mov	r8,4
800040cc:	ae 78       	st.h	r7[0xe],r8
800040ce:	c1 48       	rjmp	800040f6 <phy_tx_func+0x426>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
800040d0:	30 08       	mov	r8,0
800040d2:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800040d4:	fe f8 02 08 	ld.w	r8,pc[520]
800040d8:	70 09       	ld.w	r9,r8[0x0]
800040da:	fe fa 02 26 	ld.w	r10,pc[550]
800040de:	f4 09 00 0b 	add	r11,r10,r9
800040e2:	17 9b       	ld.ub	r11,r11[0x1]
800040e4:	f4 09 07 09 	ld.ub	r9,r10[r9]
800040e8:	a9 69       	lsl	r9,0x8
800040ea:	f6 09 00 09 	add	r9,r11,r9
800040ee:	ae 79       	st.h	r7[0xe],r9
				index+=2;
800040f0:	70 09       	ld.w	r9,r8[0x0]
800040f2:	2f e9       	sub	r9,-2
800040f4:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
800040f6:	fe f8 02 02 	ld.w	r8,pc[514]
800040fa:	90 09       	ld.sh	r9,r8[0x0]
800040fc:	20 49       	sub	r9,4
800040fe:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80004100:	30 29       	mov	r9,2
80004102:	4f a8       	lddpc	r8,800042e8 <phy_tx_func+0x618>
80004104:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80004106:	30 09       	mov	r9,0
80004108:	4f f8       	lddpc	r8,80004304 <phy_tx_func+0x634>
8000410a:	91 09       	st.w	r8[0x0],r9
8000410c:	cc 48       	rjmp	80004294 <phy_tx_func+0x5c4>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
8000410e:	4f b8       	lddpc	r8,800042f8 <phy_tx_func+0x628>
80004110:	90 09       	ld.sh	r9,r8[0x0]
80004112:	30 08       	mov	r8,0
80004114:	f0 09 19 00 	cp.h	r9,r8
80004118:	e0 89 00 12 	brgt	8000413c <phy_tx_func+0x46c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000411c:	4f 88       	lddpc	r8,800042fc <phy_tx_func+0x62c>
8000411e:	11 89       	ld.ub	r9,r8[0x0]
80004120:	30 08       	mov	r8,0
80004122:	f0 09 18 00 	cp.b	r9,r8
80004126:	5f 09       	sreq	r9
80004128:	4f 08       	lddpc	r8,800042e8 <phy_tx_func+0x618>
8000412a:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
8000412c:	e0 68 00 ba 	mov	r8,186
80004130:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80004132:	30 08       	mov	r8,0
80004134:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80004136:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004138:	ae 78       	st.h	r7[0xe],r8
8000413a:	ca d8       	rjmp	80004294 <phy_tx_func+0x5c4>
				break;
			}
		
			if(Silent_flag == 1)
8000413c:	4e e8       	lddpc	r8,800042f4 <phy_tx_func+0x624>
8000413e:	11 89       	ld.ub	r9,r8[0x0]
80004140:	30 18       	mov	r8,1
80004142:	f0 09 18 00 	cp.b	r9,r8
80004146:	c0 41       	brne	8000414e <phy_tx_func+0x47e>
			{
				payload_tx_channel->word[0] =  0x0000;
80004148:	30 08       	mov	r8,0
8000414a:	ae 48       	st.h	r7[0x8],r8
8000414c:	c1 08       	rjmp	8000416c <phy_tx_func+0x49c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000414e:	4e 48       	lddpc	r8,800042dc <phy_tx_func+0x60c>
80004150:	70 09       	ld.w	r9,r8[0x0]
80004152:	4e ca       	lddpc	r10,80004300 <phy_tx_func+0x630>
80004154:	f4 09 00 0b 	add	r11,r10,r9
80004158:	17 9b       	ld.ub	r11,r11[0x1]
8000415a:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000415e:	a9 69       	lsl	r9,0x8
80004160:	f6 09 00 09 	add	r9,r11,r9
80004164:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80004166:	70 09       	ld.w	r9,r8[0x0]
80004168:	2f e9       	sub	r9,-2
8000416a:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
8000416c:	4e 39       	lddpc	r9,800042f8 <phy_tx_func+0x628>
8000416e:	92 08       	ld.sh	r8,r9[0x0]
80004170:	20 28       	sub	r8,2
80004172:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80004174:	30 09       	mov	r9,0
80004176:	f2 08 19 00 	cp.h	r8,r9
8000417a:	e0 89 00 11 	brgt	8000419c <phy_tx_func+0x4cc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000417e:	4e 08       	lddpc	r8,800042fc <phy_tx_func+0x62c>
80004180:	11 89       	ld.ub	r9,r8[0x0]
80004182:	30 08       	mov	r8,0
80004184:	f0 09 18 00 	cp.b	r9,r8
80004188:	5f 09       	sreq	r9
8000418a:	4d 88       	lddpc	r8,800042e8 <phy_tx_func+0x618>
8000418c:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
8000418e:	e0 68 00 ba 	mov	r8,186
80004192:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80004194:	30 08       	mov	r8,0
80004196:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004198:	ae 78       	st.h	r7[0xe],r8
8000419a:	c7 d8       	rjmp	80004294 <phy_tx_func+0x5c4>
				break;
			}
		
			if(Silent_flag == 1)
8000419c:	4d 68       	lddpc	r8,800042f4 <phy_tx_func+0x624>
8000419e:	11 89       	ld.ub	r9,r8[0x0]
800041a0:	30 18       	mov	r8,1
800041a2:	f0 09 18 00 	cp.b	r9,r8
800041a6:	c0 41       	brne	800041ae <phy_tx_func+0x4de>
			{
				payload_tx_channel->word[1] =  0x0000;
800041a8:	30 08       	mov	r8,0
800041aa:	ae 58       	st.h	r7[0xa],r8
800041ac:	c1 08       	rjmp	800041cc <phy_tx_func+0x4fc>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800041ae:	4c c8       	lddpc	r8,800042dc <phy_tx_func+0x60c>
800041b0:	70 09       	ld.w	r9,r8[0x0]
800041b2:	4d 4a       	lddpc	r10,80004300 <phy_tx_func+0x630>
800041b4:	f4 09 00 0b 	add	r11,r10,r9
800041b8:	17 9b       	ld.ub	r11,r11[0x1]
800041ba:	f4 09 07 09 	ld.ub	r9,r10[r9]
800041be:	a9 69       	lsl	r9,0x8
800041c0:	f6 09 00 09 	add	r9,r11,r9
800041c4:	ae 59       	st.h	r7[0xa],r9
				index+=2;
800041c6:	70 09       	ld.w	r9,r8[0x0]
800041c8:	2f e9       	sub	r9,-2
800041ca:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800041cc:	4c b9       	lddpc	r9,800042f8 <phy_tx_func+0x628>
800041ce:	92 08       	ld.sh	r8,r9[0x0]
800041d0:	20 28       	sub	r8,2
800041d2:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800041d4:	30 09       	mov	r9,0
800041d6:	f2 08 19 00 	cp.h	r8,r9
800041da:	e0 89 00 10 	brgt	800041fa <phy_tx_func+0x52a>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800041de:	4c 88       	lddpc	r8,800042fc <phy_tx_func+0x62c>
800041e0:	11 89       	ld.ub	r9,r8[0x0]
800041e2:	30 08       	mov	r8,0
800041e4:	f0 09 18 00 	cp.b	r9,r8
800041e8:	5f 09       	sreq	r9
800041ea:	4c 08       	lddpc	r8,800042e8 <phy_tx_func+0x618>
800041ec:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
800041ee:	e0 68 00 ba 	mov	r8,186
800041f2:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
800041f4:	30 08       	mov	r8,0
800041f6:	ae 78       	st.h	r7[0xe],r8
800041f8:	c4 e8       	rjmp	80004294 <phy_tx_func+0x5c4>
				break;
			}
		
			if(Silent_flag == 1)
800041fa:	4b f8       	lddpc	r8,800042f4 <phy_tx_func+0x624>
800041fc:	11 89       	ld.ub	r9,r8[0x0]
800041fe:	30 18       	mov	r8,1
80004200:	f0 09 18 00 	cp.b	r9,r8
80004204:	c0 41       	brne	8000420c <phy_tx_func+0x53c>
			{
				payload_tx_channel->word[2] =  0x0000;
80004206:	30 08       	mov	r8,0
80004208:	ae 68       	st.h	r7[0xc],r8
8000420a:	c1 08       	rjmp	8000422a <phy_tx_func+0x55a>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000420c:	4b 48       	lddpc	r8,800042dc <phy_tx_func+0x60c>
8000420e:	70 09       	ld.w	r9,r8[0x0]
80004210:	4b ca       	lddpc	r10,80004300 <phy_tx_func+0x630>
80004212:	f4 09 00 0b 	add	r11,r10,r9
80004216:	17 9b       	ld.ub	r11,r11[0x1]
80004218:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000421c:	a9 69       	lsl	r9,0x8
8000421e:	f6 09 00 09 	add	r9,r11,r9
80004222:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80004224:	70 09       	ld.w	r9,r8[0x0]
80004226:	2f e9       	sub	r9,-2
80004228:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
8000422a:	4b 49       	lddpc	r9,800042f8 <phy_tx_func+0x628>
8000422c:	92 08       	ld.sh	r8,r9[0x0]
8000422e:	20 28       	sub	r8,2
80004230:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80004232:	30 09       	mov	r9,0
80004234:	f2 08 19 00 	cp.h	r8,r9
80004238:	e0 89 00 0e 	brgt	80004254 <phy_tx_func+0x584>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000423c:	4b 08       	lddpc	r8,800042fc <phy_tx_func+0x62c>
8000423e:	11 89       	ld.ub	r9,r8[0x0]
80004240:	30 08       	mov	r8,0
80004242:	f0 09 18 00 	cp.b	r9,r8
80004246:	5f 09       	sreq	r9
80004248:	4a 88       	lddpc	r8,800042e8 <phy_tx_func+0x618>
8000424a:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
8000424c:	e0 68 00 ba 	mov	r8,186
80004250:	ae 78       	st.h	r7[0xe],r8
80004252:	c2 18       	rjmp	80004294 <phy_tx_func+0x5c4>
				break;
			}
		
			if(Silent_flag == 1)
80004254:	4a 88       	lddpc	r8,800042f4 <phy_tx_func+0x624>
80004256:	11 89       	ld.ub	r9,r8[0x0]
80004258:	30 18       	mov	r8,1
8000425a:	f0 09 18 00 	cp.b	r9,r8
8000425e:	c0 41       	brne	80004266 <phy_tx_func+0x596>
			{
				payload_tx_channel->word[3] =  0x0000;
80004260:	30 08       	mov	r8,0
80004262:	ae 78       	st.h	r7[0xe],r8
80004264:	c1 08       	rjmp	80004284 <phy_tx_func+0x5b4>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80004266:	49 e8       	lddpc	r8,800042dc <phy_tx_func+0x60c>
80004268:	70 09       	ld.w	r9,r8[0x0]
8000426a:	4a 6a       	lddpc	r10,80004300 <phy_tx_func+0x630>
8000426c:	f4 09 00 0b 	add	r11,r10,r9
80004270:	17 9b       	ld.ub	r11,r11[0x1]
80004272:	f4 09 07 09 	ld.ub	r9,r10[r9]
80004276:	a9 69       	lsl	r9,0x8
80004278:	f6 09 00 09 	add	r9,r11,r9
8000427c:	ae 79       	st.h	r7[0xe],r9
				index+=2;
8000427e:	70 09       	ld.w	r9,r8[0x0]
80004280:	2f e9       	sub	r9,-2
80004282:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004284:	49 d8       	lddpc	r8,800042f8 <phy_tx_func+0x628>
80004286:	90 09       	ld.sh	r9,r8[0x0]
80004288:	20 29       	sub	r9,2
8000428a:	b0 09       	st.h	r8[0x0],r9
8000428c:	c0 48       	rjmp	80004294 <phy_tx_func+0x5c4>
		
			break;
		
		default:
			payload_tx_state = 0;
8000428e:	30 09       	mov	r9,0
80004290:	49 68       	lddpc	r8,800042e8 <phy_tx_func+0x618>
80004292:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004294:	2f fd       	sub	sp,-4
80004296:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000429a:	00 00       	add	r0,r0
8000429c:	00 00       	add	r0,r0
8000429e:	10 7c       	tst	r12,r8
800042a0:	00 00       	add	r0,r0
800042a2:	10 3c       	cp.w	r12,r8
800042a4:	00 00       	add	r0,r0
800042a6:	10 0c       	add	r12,r8
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	94 54       	ld.sh	r4,r10[0xa]
800042ac:	00 00       	add	r0,r0
800042ae:	10 30       	cp.w	r0,r8
800042b0:	00 00       	add	r0,r0
800042b2:	10 18       	sub	r8,r8
800042b4:	00 00       	add	r0,r0
800042b6:	0a 48       	or	r8,r5
800042b8:	00 00       	add	r0,r0
800042ba:	0a 40       	or	r0,r5
800042bc:	00 00       	add	r0,r0
800042be:	10 48       	or	r8,r8
800042c0:	00 00       	add	r0,r0
800042c2:	10 40       	or	r0,r8
800042c4:	00 00       	add	r0,r0
800042c6:	0f fc       	ld.ub	r12,r7[0x7]
800042c8:	00 00       	add	r0,r0
800042ca:	10 28       	rsub	r8,r8
800042cc:	00 00       	add	r0,r0
800042ce:	13 78       	ld.ub	r8,--r9
800042d0:	00 00       	add	r0,r0
800042d2:	14 6c       	and	r12,r10
800042d4:	80 01       	ld.sh	r1,r0[0x0]
800042d6:	0e 80       	andn	r0,r7
800042d8:	00 00       	add	r0,r0
800042da:	13 70       	ld.ub	r0,--r9
800042dc:	00 00       	add	r0,r0
800042de:	10 34       	cp.w	r4,r8
800042e0:	00 00       	add	r0,r0
800042e2:	0a 4a       	or	r10,r5
800042e4:	00 00       	add	r0,r0
800042e6:	0f f8       	ld.ub	r8,r7[0x7]
800042e8:	00 00       	add	r0,r0
800042ea:	10 74       	tst	r4,r8
800042ec:	00 00       	add	r0,r0
800042ee:	10 5c       	eor	r12,r8
800042f0:	00 00       	add	r0,r0
800042f2:	10 00       	add	r0,r8
800042f4:	00 00       	add	r0,r0
800042f6:	0a 54       	eor	r4,r5
800042f8:	00 00       	add	r0,r0
800042fa:	10 76       	tst	r6,r8
800042fc:	00 00       	add	r0,r0
800042fe:	10 17       	sub	r7,r8
80004300:	80 01       	ld.sh	r1,r0[0x0]
80004302:	14 48       	or	r8,r10
80004304:	00 00       	add	r0,r0
80004306:	10 04       	add	r4,r8

80004308 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80004308:	d4 01       	pushm	lr
8000430a:	20 1d       	sub	sp,4
	void * ptr = NULL;
8000430c:	30 0a       	mov	r10,0
8000430e:	fa cb ff fc 	sub	r11,sp,-4
80004312:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80004314:	14 99       	mov	r9,r10
80004316:	1a 9b       	mov	r11,sp
80004318:	f0 1f 00 05 	mcall	8000432c <get_idle_store+0x24>
8000431c:	58 1c       	cp.w	r12,1
8000431e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80004322:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80004326:	2f fd       	sub	sp,-4
80004328:	d8 02       	popm	pc
8000432a:	00 00       	add	r0,r0
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	95 44       	st.w	r10[0x10],r4

80004330 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80004330:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80004334:	f0 1f 00 21 	mcall	800043b8 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80004338:	4a 1b       	lddpc	r11,800043bc <phy_init+0x8c>
8000433a:	4a 2c       	lddpc	r12,800043c0 <phy_init+0x90>
8000433c:	f0 1f 00 22 	mcall	800043c4 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004340:	30 4b       	mov	r11,4
80004342:	31 ec       	mov	r12,30
80004344:	f0 1f 00 21 	mcall	800043c8 <phy_init+0x98>
80004348:	4a 18       	lddpc	r8,800043cc <phy_init+0x9c>
8000434a:	91 0c       	st.w	r8[0x0],r12
8000434c:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
8000434e:	10 96       	mov	r6,r8
80004350:	4a 05       	lddpc	r5,800043d0 <phy_init+0xa0>
80004352:	6c 0c       	ld.w	r12,r6[0x0]
80004354:	ea 07 00 0b 	add	r11,r5,r7
80004358:	f0 1f 00 1f 	mcall	800043d4 <phy_init+0xa4>
8000435c:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004360:	e0 47 1e 00 	cp.w	r7,7680
80004364:	cf 71       	brne	80004352 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004366:	30 4b       	mov	r11,4
80004368:	31 4c       	mov	r12,20
8000436a:	f0 1f 00 18 	mcall	800043c8 <phy_init+0x98>
8000436e:	49 b8       	lddpc	r8,800043d8 <phy_init+0xa8>
80004370:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004372:	30 4b       	mov	r11,4
80004374:	30 ac       	mov	r12,10
80004376:	f0 1f 00 15 	mcall	800043c8 <phy_init+0x98>
8000437a:	49 98       	lddpc	r8,800043dc <phy_init+0xac>
8000437c:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000437e:	30 4b       	mov	r11,4
80004380:	30 ac       	mov	r12,10
80004382:	f0 1f 00 12 	mcall	800043c8 <phy_init+0x98>
80004386:	49 78       	lddpc	r8,800043e0 <phy_init+0xb0>
80004388:	91 0c       	st.w	r8[0x0],r12
8000438a:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000438c:	10 96       	mov	r6,r8
8000438e:	49 65       	lddpc	r5,800043e4 <phy_init+0xb4>
80004390:	6c 0c       	ld.w	r12,r6[0x0]
80004392:	ea 07 00 0b 	add	r11,r5,r7
80004396:	f0 1f 00 10 	mcall	800043d4 <phy_init+0xa4>
8000439a:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000439e:	e0 47 14 00 	cp.w	r7,5120
800043a2:	cf 71       	brne	80004390 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800043a4:	e0 6b 01 00 	mov	r11,256
800043a8:	30 5c       	mov	r12,5
800043aa:	f0 1f 00 08 	mcall	800043c8 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800043ae:	48 f8       	lddpc	r8,800043e8 <phy_init+0xb8>
800043b0:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800043b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800043b6:	00 00       	add	r0,r0
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	54 14       	stdsp	sp[0x104],r4
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	3c d0       	mov	r0,-51
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	44 4c       	lddsp	r12,sp[0x110]
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	54 00       	stdsp	sp[0x100],r0
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	98 a8       	ld.uh	r8,r12[0x4]
800043cc:	00 00       	add	r0,r0
800043ce:	10 64       	and	r4,r8
800043d0:	00 00       	add	r0,r0
800043d2:	28 70       	sub	r0,-121
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	3c 2c       	mov	r12,-62
800043d8:	00 00       	add	r0,r0
800043da:	10 7c       	tst	r12,r8
800043dc:	00 00       	add	r0,r0
800043de:	10 68       	and	r8,r8
800043e0:	00 00       	add	r0,r0
800043e2:	10 20       	rsub	r0,r8
800043e4:	00 00       	add	r0,r0
800043e6:	14 70       	tst	r0,r10
800043e8:	00 00       	add	r0,r0
800043ea:	10 6c       	and	r12,r8

800043ec <payload_rx>:




static void payload_rx(void * payload)
{
800043ec:	d4 01       	pushm	lr
800043ee:	20 2d       	sub	sp,8
800043f0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800043f2:	30 08       	mov	r8,0
800043f4:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800043f6:	48 f8       	lddpc	r8,80004430 <payload_rx+0x44>
800043f8:	70 08       	ld.w	r8,r8[0x0]
800043fa:	58 08       	cp.w	r8,0
800043fc:	c0 71       	brne	8000440a <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800043fe:	30 4b       	mov	r11,4
80004400:	30 5c       	mov	r12,5
80004402:	f0 1f 00 0d 	mcall	80004434 <payload_rx+0x48>
80004406:	48 b8       	lddpc	r8,80004430 <payload_rx+0x44>
80004408:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000440a:	48 a8       	lddpc	r8,80004430 <payload_rx+0x44>
8000440c:	70 0c       	ld.w	r12,r8[0x0]
8000440e:	30 09       	mov	r9,0
80004410:	fa ca ff fc 	sub	r10,sp,-4
80004414:	1a 9b       	mov	r11,sp
80004416:	f0 1f 00 09 	mcall	80004438 <payload_rx+0x4c>
8000441a:	c0 91       	brne	8000442c <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
8000441c:	48 88       	lddpc	r8,8000443c <payload_rx+0x50>
8000441e:	70 0c       	ld.w	r12,r8[0x0]
80004420:	40 0b       	lddsp	r11,sp[0x0]
80004422:	f0 1f 00 08 	mcall	80004440 <payload_rx+0x54>
		logFromISR("mm");
80004426:	48 8c       	lddpc	r12,80004444 <payload_rx+0x58>
80004428:	f0 1f 00 08 	mcall	80004448 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000442c:	2f ed       	sub	sp,-8
8000442e:	d8 02       	popm	pc
80004430:	00 00       	add	r0,r0
80004432:	10 08       	add	r8,r8
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	98 a8       	ld.uh	r8,r12[0x4]
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	97 00       	st.w	r11[0x0],r0
8000443c:	00 00       	add	r0,r0
8000443e:	10 20       	rsub	r0,r8
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	3b d8       	mov	r8,-67
80004444:	80 01       	ld.sh	r1,r0[0x0]
80004446:	97 f8       	st.w	r11[0x3c],r8
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	a4 cc       	st.b	r2[0x4],r12

8000444c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000444c:	eb cd 40 e0 	pushm	r5-r7,lr
80004450:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80004452:	fe f8 0d ee 	ld.w	r8,pc[3566]
80004456:	70 08       	ld.w	r8,r8[0x0]
80004458:	58 08       	cp.w	r8,0
8000445a:	e0 80 01 05 	breq	80004664 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000445e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80004460:	fe f8 0d e4 	ld.w	r8,pc[3556]
80004464:	70 09       	ld.w	r9,r8[0x0]
80004466:	2f f9       	sub	r9,-1
80004468:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000446a:	fe f8 0d de 	ld.w	r8,pc[3550]
8000446e:	70 08       	ld.w	r8,r8[0x0]
80004470:	58 18       	cp.w	r8,1
80004472:	e0 80 00 84 	breq	8000457a <phy_rx_func+0x12e>
80004476:	c0 73       	brcs	80004484 <phy_rx_func+0x38>
80004478:	58 28       	cp.w	r8,2
8000447a:	c5 b0       	breq	80004530 <phy_rx_func+0xe4>
8000447c:	58 38       	cp.w	r8,3
8000447e:	e0 81 00 f3 	brne	80004664 <phy_rx_func+0x218>
80004482:	cd 38       	rjmp	80004628 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80004484:	e0 6a 5a 5a 	mov	r10,23130
80004488:	ea 1a ab cd 	orh	r10,0xabcd
8000448c:	14 36       	cp.w	r6,r10
8000448e:	e0 80 00 eb 	breq	80004664 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80004492:	ec 08 16 10 	lsr	r8,r6,0x10
80004496:	e0 48 ab cd 	cp.w	r8,43981
8000449a:	e0 81 00 e5 	brne	80004664 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000449e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800044a2:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800044a6:	20 28       	sub	r8,2
800044a8:	fe f9 0d a4 	ld.w	r9,pc[3492]
800044ac:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800044ae:	30 09       	mov	r9,0
800044b0:	f2 08 19 00 	cp.h	r8,r9
800044b4:	e0 8a 00 d8 	brle	80004664 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800044b8:	fe f8 0d 98 	ld.w	r8,pc[3480]
800044bc:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800044be:	fe f8 0d 96 	ld.w	r8,pc[3478]
800044c2:	70 0c       	ld.w	r12,r8[0x0]
800044c4:	f0 1f 03 65 	mcall	80005258 <phy_rx_func+0xe0c>
800044c8:	fe f8 0d 94 	ld.w	r8,pc[3476]
800044cc:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800044ce:	58 0c       	cp.w	r12,0
800044d0:	e0 80 00 ca 	breq	80004664 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800044d4:	fe f8 0d 7c 	ld.w	r8,pc[3452]
800044d8:	90 09       	ld.sh	r9,r8[0x0]
800044da:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800044de:	2f f9       	sub	r9,-1
800044e0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800044e2:	fe fa 0d 7a 	ld.w	r10,pc[3450]
800044e6:	74 0a       	ld.w	r10,r10[0x0]
800044e8:	fe fb 0d 5c 	ld.w	r11,pc[3420]
800044ec:	76 0b       	ld.w	r11,r11[0x0]
800044ee:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800044f2:	2f f9       	sub	r9,-1
800044f4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800044f6:	e2 16 0f 00 	andl	r6,0xf00,COH
800044fa:	e0 46 01 00 	cp.w	r6,256
800044fe:	c0 c0       	breq	80004516 <phy_rx_func+0xca>
80004500:	e0 8b 00 05 	brhi	8000450a <phy_rx_func+0xbe>
80004504:	58 06       	cp.w	r6,0
80004506:	c0 80       	breq	80004516 <phy_rx_func+0xca>
80004508:	c0 c8       	rjmp	80004520 <phy_rx_func+0xd4>
8000450a:	e0 46 02 00 	cp.w	r6,512
8000450e:	c0 40       	breq	80004516 <phy_rx_func+0xca>
80004510:	e0 46 03 00 	cp.w	r6,768
80004514:	c0 61       	brne	80004520 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80004516:	30 29       	mov	r9,2
80004518:	fe f8 0d 30 	ld.w	r8,pc[3376]
8000451c:	91 09       	st.w	r8[0x0],r9
8000451e:	ca 38       	rjmp	80004664 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80004520:	fe f6 0d 3c 	ld.w	r6,pc[3388]
80004524:	6c 0c       	ld.w	r12,r6[0x0]
80004526:	f0 1f 03 4f 	mcall	80005260 <phy_rx_func+0xe14>
					phy_frame_ptr = NULL;					
8000452a:	30 08       	mov	r8,0
8000452c:	8d 08       	st.w	r6[0x0],r8
8000452e:	c9 b8       	rjmp	80004664 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80004530:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80004534:	b1 86       	lsr	r6,0x10
80004536:	14 06       	add	r6,r10
80004538:	fe f8 0d 2c 	ld.w	r8,pc[3372]
8000453c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000453e:	fe f8 0d 12 	ld.w	r8,pc[3346]
80004542:	90 09       	ld.sh	r9,r8[0x0]
80004544:	fe fb 0d 18 	ld.w	r11,pc[3352]
80004548:	76 0b       	ld.w	r11,r11[0x0]
8000454a:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000454e:	2f f9       	sub	r9,-1
80004550:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80004552:	fe f9 0c fa 	ld.w	r9,pc[3322]
80004556:	92 08       	ld.sh	r8,r9[0x0]
80004558:	20 28       	sub	r8,2
8000455a:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000455c:	30 09       	mov	r9,0
8000455e:	f2 08 19 00 	cp.h	r8,r9
80004562:	e0 8a 00 07 	brle	80004570 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80004566:	30 19       	mov	r9,1
80004568:	fe f8 0c e0 	ld.w	r8,pc[3296]
8000456c:	91 09       	st.w	r8[0x0],r9
8000456e:	c7 b8       	rjmp	80004664 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004570:	30 39       	mov	r9,3
80004572:	fe f8 0c d6 	ld.w	r8,pc[3286]
80004576:	91 09       	st.w	r8[0x0],r9
80004578:	c7 68       	rjmp	80004664 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000457a:	ec 0a 14 10 	asr	r10,r6,0x10
8000457e:	fe f8 0c e6 	ld.w	r8,pc[3302]
80004582:	90 09       	ld.sh	r9,r8[0x0]
80004584:	14 09       	add	r9,r10
80004586:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004588:	fe f9 0c c8 	ld.w	r9,pc[3272]
8000458c:	92 08       	ld.sh	r8,r9[0x0]
8000458e:	fe fb 0c ce 	ld.w	r11,pc[3278]
80004592:	76 0b       	ld.w	r11,r11[0x0]
80004594:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80004598:	2f f8       	sub	r8,-1
8000459a:	5c 88       	casts.h	r8
8000459c:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000459e:	fe fa 0c ae 	ld.w	r10,pc[3246]
800045a2:	94 09       	ld.sh	r9,r10[0x0]
800045a4:	20 29       	sub	r9,2
800045a6:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800045a8:	30 0a       	mov	r10,0
800045aa:	f4 09 19 00 	cp.h	r9,r10
800045ae:	e0 89 00 1f 	brgt	800045ec <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800045b2:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800045b6:	e0 46 00 ba 	cp.w	r6,186
800045ba:	c0 d1       	brne	800045d4 <phy_rx_func+0x188>
800045bc:	fe f8 0c a8 	ld.w	r8,pc[3240]
800045c0:	90 09       	ld.sh	r9,r8[0x0]
800045c2:	f4 09 19 00 	cp.h	r9,r10
800045c6:	c0 71       	brne	800045d4 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800045c8:	fe f8 0c 94 	ld.w	r8,pc[3220]
800045cc:	70 0c       	ld.w	r12,r8[0x0]
800045ce:	f0 1f 03 27 	mcall	80005268 <phy_rx_func+0xe1c>
800045d2:	c0 88       	rjmp	800045e2 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800045d4:	fe f6 0c 88 	ld.w	r6,pc[3208]
800045d8:	6c 0c       	ld.w	r12,r6[0x0]
800045da:	f0 1f 03 22 	mcall	80005260 <phy_rx_func+0xe14>
					phy_frame_ptr = NULL;
800045de:	30 08       	mov	r8,0
800045e0:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800045e2:	30 09       	mov	r9,0
800045e4:	fe f8 0c 64 	ld.w	r8,pc[3172]
800045e8:	91 09       	st.w	r8[0x0],r9
800045ea:	c3 d8       	rjmp	80004664 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800045ec:	5c 86       	casts.h	r6
800045ee:	fe f9 0c 76 	ld.w	r9,pc[3190]
800045f2:	92 0a       	ld.sh	r10,r9[0x0]
800045f4:	0c 0a       	add	r10,r6
800045f6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800045f8:	fe f9 0c 64 	ld.w	r9,pc[3172]
800045fc:	72 09       	ld.w	r9,r9[0x0]
800045fe:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80004602:	2f f8       	sub	r8,-1
80004604:	fe f9 0c 4c 	ld.w	r9,pc[3148]
80004608:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000460a:	fe f9 0c 42 	ld.w	r9,pc[3138]
8000460e:	92 08       	ld.sh	r8,r9[0x0]
80004610:	20 28       	sub	r8,2
80004612:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004614:	30 09       	mov	r9,0
80004616:	f2 08 19 00 	cp.h	r8,r9
8000461a:	e0 89 00 25 	brgt	80004664 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000461e:	30 39       	mov	r9,3
80004620:	fe f8 0c 28 	ld.w	r8,pc[3112]
80004624:	91 09       	st.w	r8[0x0],r9
80004626:	c1 f8       	rjmp	80004664 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004628:	e6 16 00 ff 	andh	r6,0xff,COH
8000462c:	fc 19 00 ba 	movh	r9,0xba
80004630:	12 36       	cp.w	r6,r9
80004632:	c0 e1       	brne	8000464e <phy_rx_func+0x202>
80004634:	fe f8 0c 30 	ld.w	r8,pc[3120]
80004638:	90 09       	ld.sh	r9,r8[0x0]
8000463a:	30 08       	mov	r8,0
8000463c:	f0 09 19 00 	cp.h	r9,r8
80004640:	c0 71       	brne	8000464e <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80004642:	fe f8 0c 1a 	ld.w	r8,pc[3098]
80004646:	70 0c       	ld.w	r12,r8[0x0]
80004648:	f0 1f 03 08 	mcall	80005268 <phy_rx_func+0xe1c>
8000464c:	c0 88       	rjmp	8000465c <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000464e:	fe f6 0c 0e 	ld.w	r6,pc[3086]
80004652:	6c 0c       	ld.w	r12,r6[0x0]
80004654:	f0 1f 03 03 	mcall	80005260 <phy_rx_func+0xe14>
				phy_frame_ptr = NULL;
80004658:	30 08       	mov	r8,0
8000465a:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000465c:	30 09       	mov	r9,0
8000465e:	fe f8 0b ea 	ld.w	r8,pc[3050]
80004662:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80004664:	fe f8 0c 08 	ld.w	r8,pc[3080]
80004668:	11 89       	ld.ub	r9,r8[0x0]
8000466a:	30 08       	mov	r8,0
8000466c:	f0 09 18 00 	cp.b	r9,r8
80004670:	c1 31       	brne	80004696 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
80004672:	fe f6 0b fe 	ld.w	r6,pc[3070]
80004676:	6c 0c       	ld.w	r12,r6[0x0]
80004678:	f0 1f 02 f8 	mcall	80005258 <phy_rx_func+0xe0c>
8000467c:	fe f8 0b f8 	ld.w	r8,pc[3064]
80004680:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80004682:	6c 0c       	ld.w	r12,r6[0x0]
80004684:	f0 1f 02 f5 	mcall	80005258 <phy_rx_func+0xe0c>
80004688:	fe f8 0b f0 	ld.w	r8,pc[3056]
8000468c:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000468e:	30 19       	mov	r9,1
80004690:	fe f8 0b dc 	ld.w	r8,pc[3036]
80004694:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80004696:	fe f8 0b e6 	ld.w	r8,pc[3046]
8000469a:	70 08       	ld.w	r8,r8[0x0]
8000469c:	58 28       	cp.w	r8,2
8000469e:	e0 80 01 af 	breq	800049fc <phy_rx_func+0x5b0>
800046a2:	e0 8b 00 06 	brhi	800046ae <phy_rx_func+0x262>
800046a6:	58 08       	cp.w	r8,0
800046a8:	c0 b0       	breq	800046be <phy_rx_func+0x272>
800046aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800046ae:	58 38       	cp.w	r8,3
800046b0:	e0 80 05 82 	breq	800051b4 <phy_rx_func+0xd68>
800046b4:	58 48       	cp.w	r8,4
800046b6:	e0 81 05 c3 	brne	8000523c <phy_rx_func+0xdf0>
800046ba:	e0 8f 02 62 	bral	80004b7e <phy_rx_func+0x732>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800046be:	6e 28       	ld.w	r8,r7[0x8]
800046c0:	e0 6a 5a 5a 	mov	r10,23130
800046c4:	ea 1a ab cd 	orh	r10,0xabcd
800046c8:	14 38       	cp.w	r8,r10
800046ca:	c0 71       	brne	800046d8 <phy_rx_func+0x28c>
			{
				m_RxBurstType = VOICE_WATING;
800046cc:	30 09       	mov	r9,0
800046ce:	fe f8 0b b2 	ld.w	r8,pc[2994]
800046d2:	91 09       	st.w	r8[0x0],r9
800046d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800046d8:	10 99       	mov	r9,r8
800046da:	e0 19 00 00 	andl	r9,0x0
800046de:	fc 1a ab cd 	movh	r10,0xabcd
800046e2:	14 39       	cp.w	r9,r10
800046e4:	e0 81 05 ac 	brne	8000523c <phy_rx_func+0xdf0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800046e8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800046ec:	fe f9 0b 98 	ld.w	r9,pc[2968]
800046f0:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800046f2:	fe f8 0b 82 	ld.w	r8,pc[2946]
800046f6:	70 08       	ld.w	r8,r8[0x0]
800046f8:	58 08       	cp.w	r8,0
800046fa:	c0 60       	breq	80004706 <phy_rx_func+0x2ba>
800046fc:	fe f8 0b 7c 	ld.w	r8,pc[2940]
80004700:	70 08       	ld.w	r8,r8[0x0]
80004702:	58 08       	cp.w	r8,0
80004704:	c1 a1       	brne	80004738 <phy_rx_func+0x2ec>
			{
				payload_ptr = get_payload_idle_isr();
80004706:	fe f6 0b 6a 	ld.w	r6,pc[2922]
8000470a:	6c 0c       	ld.w	r12,r6[0x0]
8000470c:	f0 1f 02 d3 	mcall	80005258 <phy_rx_func+0xe0c>
80004710:	fe f5 0b 64 	ld.w	r5,pc[2916]
80004714:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
80004716:	6c 0c       	ld.w	r12,r6[0x0]
80004718:	f0 1f 02 d0 	mcall	80005258 <phy_rx_func+0xe0c>
8000471c:	fe f8 0b 5c 	ld.w	r8,pc[2908]
80004720:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
80004722:	6a 08       	ld.w	r8,r5[0x0]
80004724:	58 08       	cp.w	r8,0
80004726:	c0 30       	breq	8000472c <phy_rx_func+0x2e0>
80004728:	58 0c       	cp.w	r12,0
8000472a:	c0 71       	brne	80004738 <phy_rx_func+0x2ec>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
8000472c:	fe fc 0b 5c 	ld.w	r12,pc[2908]
80004730:	f0 1f 02 d7 	mcall	8000528c <phy_rx_func+0xe40>
80004734:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80004738:	6e 28       	ld.w	r8,r7[0x8]
8000473a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000473e:	e0 48 c0 00 	cp.w	r8,49152
80004742:	e0 81 00 c7 	brne	800048d0 <phy_rx_func+0x484>
			{
											
				Item_ID = payload_rx_channel->byte[5];
80004746:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000474a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000474e:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80004750:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80004754:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80004758:	fe f9 0b 3c 	ld.w	r9,pc[2876]
8000475c:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000475e:	11 88       	ld.ub	r8,r8[0x0]
80004760:	37 f9       	mov	r9,127
80004762:	f2 08 18 00 	cp.b	r8,r9
80004766:	c6 b0       	breq	8000483c <phy_rx_func+0x3f0>
80004768:	e0 8b 00 0c 	brhi	80004780 <phy_rx_func+0x334>
8000476c:	31 29       	mov	r9,18
8000476e:	f2 08 18 00 	cp.b	r8,r9
80004772:	c4 20       	breq	800047f6 <phy_rx_func+0x3aa>
80004774:	31 39       	mov	r9,19
80004776:	f2 08 18 00 	cp.b	r8,r9
8000477a:	e0 81 00 8b 	brne	80004890 <phy_rx_func+0x444>
8000477e:	c5 98       	rjmp	80004830 <phy_rx_func+0x3e4>
80004780:	2f 08       	sub	r8,-16
80004782:	30 19       	mov	r9,1
80004784:	f2 08 18 00 	cp.b	r8,r9
80004788:	e0 8b 00 84 	brhi	80004890 <phy_rx_func+0x444>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000478c:	ef 38 00 0e 	ld.ub	r8,r7[14]
80004790:	e2 18 00 f0 	andl	r8,0xf0,COH
80004794:	59 08       	cp.w	r8,16
80004796:	c0 71       	brne	800047a4 <phy_rx_func+0x358>
							{
								m_RxBurstType = VOICEHEADER;
80004798:	30 19       	mov	r9,1
8000479a:	fe f8 0a e6 	ld.w	r8,pc[2790]
8000479e:	91 09       	st.w	r8[0x0],r9
800047a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800047a4:	e0 48 00 20 	cp.w	r8,32
800047a8:	c2 11       	brne	800047ea <phy_rx_func+0x39e>
							{
								m_RxBurstType = VOICETERMINATOR;
800047aa:	30 a9       	mov	r9,10
800047ac:	fe f8 0a d4 	ld.w	r8,pc[2772]
800047b0:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//0
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800047b2:	fe f6 0a e6 	ld.w	r6,pc[2790]
800047b6:	6c 08       	ld.w	r8,r6[0x0]
800047b8:	f0 0a 11 ff 	rsub	r10,r8,-1
800047bc:	fe f7 0a bc 	ld.w	r7,pc[2748]
800047c0:	2f f8       	sub	r8,-1
800047c2:	6e 0c       	ld.w	r12,r7[0x0]
800047c4:	f4 ca fe 00 	sub	r10,r10,-512
800047c8:	30 0b       	mov	r11,0
800047ca:	10 0c       	add	r12,r8
800047cc:	f0 1f 02 b4 	mcall	8000529c <phy_rx_func+0xe50>
								
								RxAMBE_IsFillingNext8 = 0;
800047d0:	30 08       	mov	r8,0
800047d2:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800047d4:	6e 0c       	ld.w	r12,r7[0x0]
800047d6:	f0 1f 02 b3 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
800047da:	fe f8 0a 96 	ld.w	r8,pc[2710]
800047de:	70 0c       	ld.w	r12,r8[0x0]
800047e0:	f0 1f 02 9e 	mcall	80005258 <phy_rx_func+0xe0c>
800047e4:	8f 0c       	st.w	r7[0x0],r12
800047e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800047ea:	30 09       	mov	r9,0
800047ec:	fe f8 0a 94 	ld.w	r8,pc[2708]
800047f0:	91 09       	st.w	r8[0x0],r9
800047f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800047f6:	fe f9 0a 8e 	ld.w	r9,pc[2702]
800047fa:	72 08       	ld.w	r8,r9[0x0]
800047fc:	20 48       	sub	r8,4
800047fe:	93 08       	st.w	r9[0x0],r8
80004800:	e0 80 05 1e 	breq	8000523c <phy_rx_func+0xdf0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
80004804:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80004808:	fe f8 0a 9c 	ld.w	r8,pc[2716]
8000480c:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000480e:	8e 69       	ld.sh	r9,r7[0xc]
80004810:	fe f8 0a 98 	ld.w	r8,pc[2712]
80004814:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80004816:	8e 79       	ld.sh	r9,r7[0xe]
80004818:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000481a:	f0 1f 02 a5 	mcall	800052ac <phy_rx_func+0xe60>
8000481e:	fe f8 0a 62 	ld.w	r8,pc[2658]
80004822:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80004824:	30 49       	mov	r9,4
80004826:	fe f8 0a 56 	ld.w	r8,pc[2646]
8000482a:	91 09       	st.w	r8[0x0],r9
8000482c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80004830:	30 09       	mov	r9,0
80004832:	fe f8 0a 4e 	ld.w	r8,pc[2638]
80004836:	91 09       	st.w	r8[0x0],r9
80004838:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
8000483c:	fe f8 0a 58 	ld.w	r8,pc[2648]
80004840:	70 08       	ld.w	r8,r8[0x0]
80004842:	1a d8       	st.w	--sp,r8
80004844:	fe fc 0a 6c 	ld.w	r12,pc[2668]
80004848:	f0 1f 02 91 	mcall	8000528c <phy_rx_func+0xe40>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000484c:	fe f9 0a 38 	ld.w	r9,pc[2616]
80004850:	72 08       	ld.w	r8,r9[0x0]
80004852:	20 48       	sub	r8,4
80004854:	93 08       	st.w	r9[0x0],r8
80004856:	2f fd       	sub	sp,-4
80004858:	58 08       	cp.w	r8,0
8000485a:	e0 80 04 f1 	breq	8000523c <phy_rx_func+0xdf0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000485e:	fe f8 0a 56 	ld.w	r8,pc[2646]
80004862:	70 09       	ld.w	r9,r8[0x0]
80004864:	8e 7b       	ld.sh	r11,r7[0xe]
80004866:	fe fa 0a 52 	ld.w	r10,pc[2642]
8000486a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000486e:	2f f9       	sub	r9,-1
80004870:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80004872:	fe f8 0a 22 	ld.w	r8,pc[2594]
80004876:	70 09       	ld.w	r9,r8[0x0]
80004878:	20 29       	sub	r9,2
8000487a:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000487c:	30 29       	mov	r9,2
8000487e:	fe f8 0a 02 	ld.w	r8,pc[2562]
80004882:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80004884:	30 39       	mov	r9,3
80004886:	fe f8 09 f6 	ld.w	r8,pc[2550]
8000488a:	91 09       	st.w	r8[0x0],r9
8000488c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80004890:	30 39       	mov	r9,3
80004892:	fe f8 09 ee 	ld.w	r8,pc[2542]
80004896:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80004898:	6e 29       	ld.w	r9,r7[0x8]
8000489a:	fe f8 0a 22 	ld.w	r8,pc[2594]
8000489e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
800048a0:	6e 39       	ld.w	r9,r7[0xc]
800048a2:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
800048a4:	fe f8 09 e0 	ld.w	r8,pc[2528]
800048a8:	70 08       	ld.w	r8,r8[0x0]
800048aa:	59 48       	cp.w	r8,20
800048ac:	c0 61       	brne	800048b8 <phy_rx_func+0x46c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800048ae:	31 89       	mov	r9,24
800048b0:	fe f8 09 d4 	ld.w	r8,pc[2516]
800048b4:	91 09       	st.w	r8[0x0],r9
800048b6:	c0 78       	rjmp	800048c4 <phy_rx_func+0x478>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800048b8:	59 08       	cp.w	r8,16
800048ba:	c0 51       	brne	800048c4 <phy_rx_func+0x478>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800048bc:	31 09       	mov	r9,16
800048be:	fe f8 09 c6 	ld.w	r8,pc[2502]
800048c2:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800048c4:	30 49       	mov	r9,4
800048c6:	fe f8 09 b6 	ld.w	r8,pc[2486]
800048ca:	91 09       	st.w	r8[0x0],r9
800048cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800048d0:	e0 48 10 00 	cp.w	r8,4096
800048d4:	5f 19       	srne	r9
800048d6:	e0 48 20 00 	cp.w	r8,8192
800048da:	5f 18       	srne	r8
800048dc:	f3 e8 00 08 	and	r8,r9,r8
800048e0:	e0 81 04 ae 	brne	8000523c <phy_rx_func+0xdf0>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800048e4:	fe f9 09 dc 	ld.w	r9,pc[2524]
800048e8:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
800048ea:	fe f9 09 da 	ld.w	r9,pc[2522]
800048ee:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800048f0:	fe f9 09 a0 	ld.w	r9,pc[2464]
800048f4:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800048f6:	6e 28       	ld.w	r8,r7[0x8]
800048f8:	e2 18 0f 00 	andl	r8,0xf00,COH
800048fc:	58 18       	cp.w	r8,1
800048fe:	e0 8b 00 4d 	brhi	80004998 <phy_rx_func+0x54c>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80004902:	fe f9 09 82 	ld.w	r9,pc[2434]
80004906:	72 08       	ld.w	r8,r9[0x0]
80004908:	20 48       	sub	r8,4
8000490a:	93 08       	st.w	r9[0x0],r8
8000490c:	e0 80 04 98 	breq	8000523c <phy_rx_func+0xdf0>
				ArrayDiscLength = payload_rx_channel->word[2];
80004910:	8e 68       	ld.sh	r8,r7[0xc]
80004912:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004916:	fe f9 09 b2 	ld.w	r9,pc[2482]
8000491a:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
8000491c:	30 09       	mov	r9,0
8000491e:	f2 08 19 00 	cp.h	r8,r9
80004922:	c0 70       	breq	80004930 <phy_rx_func+0x4e4>
80004924:	30 19       	mov	r9,1
80004926:	f2 08 19 00 	cp.h	r8,r9
8000492a:	e0 81 04 89 	brne	8000523c <phy_rx_func+0xdf0>
8000492e:	c2 68       	rjmp	8000497a <phy_rx_func+0x52e>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004930:	fe f8 09 9c 	ld.w	r8,pc[2460]
80004934:	70 0a       	ld.w	r10,r8[0x0]
80004936:	fe f9 09 3e 	ld.w	r9,pc[2366]
8000493a:	72 09       	ld.w	r9,r9[0x0]
8000493c:	8e 7b       	ld.sh	r11,r7[0xe]
8000493e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004942:	70 09       	ld.w	r9,r8[0x0]
80004944:	2f f9       	sub	r9,-1
80004946:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004948:	e0 49 00 ff 	cp.w	r9,255
8000494c:	e0 88 00 11 	brls	8000496e <phy_rx_func+0x522>
						{
							RxMedia_IsFillingNext16 = 0;	
80004950:	30 09       	mov	r9,0
80004952:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80004954:	fe f7 09 20 	ld.w	r7,pc[2336]
80004958:	6e 0c       	ld.w	r12,r7[0x0]
8000495a:	f0 1f 02 52 	mcall	800052a0 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
8000495e:	fe f8 09 12 	ld.w	r8,pc[2322]
80004962:	70 0c       	ld.w	r12,r8[0x0]
80004964:	f0 1f 02 3d 	mcall	80005258 <phy_rx_func+0xe0c>
80004968:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000496a:	e0 80 04 69 	breq	8000523c <phy_rx_func+0xdf0>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000496e:	30 29       	mov	r9,2
80004970:	fe f8 09 0c 	ld.w	r8,pc[2316]
80004974:	91 09       	st.w	r8[0x0],r9
80004976:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000497a:	8e 79       	ld.sh	r9,r7[0xe]
8000497c:	30 38       	mov	r8,3
8000497e:	f0 09 19 00 	cp.h	r9,r8
80004982:	c0 51       	brne	8000498c <phy_rx_func+0x540>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80004984:	30 19       	mov	r9,1
80004986:	fe f8 09 4a 	ld.w	r8,pc[2378]
8000498a:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000498c:	30 29       	mov	r9,2
8000498e:	fe f8 08 ee 	ld.w	r8,pc[2286]
80004992:	91 09       	st.w	r8[0x0],r9
80004994:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80004998:	fe f8 08 ec 	ld.w	r8,pc[2284]
8000499c:	70 08       	ld.w	r8,r8[0x0]
8000499e:	58 18       	cp.w	r8,1
800049a0:	e0 88 04 4e 	brls	8000523c <phy_rx_func+0xdf0>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800049a4:	fe f8 09 28 	ld.w	r8,pc[2344]
800049a8:	70 0a       	ld.w	r10,r8[0x0]
800049aa:	fe f9 08 ca 	ld.w	r9,pc[2250]
800049ae:	72 09       	ld.w	r9,r9[0x0]
800049b0:	6e 3b       	ld.w	r11,r7[0xc]
800049b2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800049b6:	70 09       	ld.w	r9,r8[0x0]
800049b8:	2f f9       	sub	r9,-1
800049ba:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800049bc:	e0 49 00 ff 	cp.w	r9,255
800049c0:	e0 88 00 11 	brls	800049e2 <phy_rx_func+0x596>
				{
					RxMedia_IsFillingNext16 = 0;
800049c4:	30 09       	mov	r9,0
800049c6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800049c8:	fe f7 08 ac 	ld.w	r7,pc[2220]
800049cc:	6e 0c       	ld.w	r12,r7[0x0]
800049ce:	f0 1f 02 35 	mcall	800052a0 <phy_rx_func+0xe54>
								payload_ptr = get_payload_idle_isr();
800049d2:	fe f8 08 9e 	ld.w	r8,pc[2206]
800049d6:	70 0c       	ld.w	r12,r8[0x0]
800049d8:	f0 1f 02 20 	mcall	80005258 <phy_rx_func+0xe0c>
800049dc:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800049de:	e0 80 04 2f 	breq	8000523c <phy_rx_func+0xdf0>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800049e2:	fe f9 08 a2 	ld.w	r9,pc[2210]
800049e6:	72 08       	ld.w	r8,r9[0x0]
800049e8:	20 28       	sub	r8,2
800049ea:	93 08       	st.w	r9[0x0],r8
800049ec:	e0 80 04 28 	breq	8000523c <phy_rx_func+0xdf0>
				RxMediaState = READINGMEDIA;
800049f0:	30 29       	mov	r9,2
800049f2:	fe f8 08 8a 	ld.w	r8,pc[2186]
800049f6:	91 09       	st.w	r8[0x0],r9
800049f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800049fc:	fe f8 08 d0 	ld.w	r8,pc[2256]
80004a00:	70 0a       	ld.w	r10,r8[0x0]
80004a02:	fe f9 08 72 	ld.w	r9,pc[2162]
80004a06:	72 09       	ld.w	r9,r9[0x0]
80004a08:	8e 4b       	ld.sh	r11,r7[0x8]
80004a0a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80004a0e:	70 09       	ld.w	r9,r8[0x0]
80004a10:	2f f9       	sub	r9,-1
80004a12:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a14:	e0 49 00 ff 	cp.w	r9,255
80004a18:	e0 88 00 16 	brls	80004a44 <phy_rx_func+0x5f8>
					{
							RxMedia_IsFillingNext16 = 0;
80004a1c:	30 09       	mov	r9,0
80004a1e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a20:	fe f6 08 54 	ld.w	r6,pc[2132]
80004a24:	6c 0c       	ld.w	r12,r6[0x0]
80004a26:	f0 1f 02 1f 	mcall	800052a0 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
80004a2a:	fe f8 08 46 	ld.w	r8,pc[2118]
80004a2e:	70 0c       	ld.w	r12,r8[0x0]
80004a30:	f0 1f 02 0a 	mcall	80005258 <phy_rx_func+0xe0c>
80004a34:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80004a36:	c0 71       	brne	80004a44 <phy_rx_func+0x5f8>
							{
								RxMediaState = WAITINGABAB;
80004a38:	30 09       	mov	r9,0
80004a3a:	fe f8 08 42 	ld.w	r8,pc[2114]
80004a3e:	91 09       	st.w	r8[0x0],r9
80004a40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80004a44:	fe f9 08 40 	ld.w	r9,pc[2112]
80004a48:	72 08       	ld.w	r8,r9[0x0]
80004a4a:	20 28       	sub	r8,2
80004a4c:	93 08       	st.w	r9[0x0],r8
80004a4e:	c0 71       	brne	80004a5c <phy_rx_func+0x610>
				{
					RxMediaState = WAITINGABAB;
80004a50:	30 09       	mov	r9,0
80004a52:	fe f8 08 2a 	ld.w	r8,pc[2090]
80004a56:	91 09       	st.w	r8[0x0],r9
80004a58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80004a5c:	fe f8 08 70 	ld.w	r8,pc[2160]
80004a60:	70 0a       	ld.w	r10,r8[0x0]
80004a62:	fe f9 08 12 	ld.w	r9,pc[2066]
80004a66:	72 09       	ld.w	r9,r9[0x0]
80004a68:	8e 5b       	ld.sh	r11,r7[0xa]
80004a6a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004a6e:	70 09       	ld.w	r9,r8[0x0]
80004a70:	2f f9       	sub	r9,-1
80004a72:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a74:	e0 49 00 ff 	cp.w	r9,255
80004a78:	e0 88 00 16 	brls	80004aa4 <phy_rx_func+0x658>
						{
							RxMedia_IsFillingNext16 = 0;
80004a7c:	30 09       	mov	r9,0
80004a7e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004a80:	fe f6 07 f4 	ld.w	r6,pc[2036]
80004a84:	6c 0c       	ld.w	r12,r6[0x0]
80004a86:	f0 1f 02 07 	mcall	800052a0 <phy_rx_func+0xe54>
								payload_ptr = get_payload_idle_isr();
80004a8a:	fe f8 07 e6 	ld.w	r8,pc[2022]
80004a8e:	70 0c       	ld.w	r12,r8[0x0]
80004a90:	f0 1f 01 f2 	mcall	80005258 <phy_rx_func+0xe0c>
80004a94:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004a96:	c0 71       	brne	80004aa4 <phy_rx_func+0x658>
								{
									RxMediaState = WAITINGABAB;
80004a98:	30 09       	mov	r9,0
80004a9a:	fe f8 07 e2 	ld.w	r8,pc[2018]
80004a9e:	91 09       	st.w	r8[0x0],r9
80004aa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004aa4:	fe f9 07 e0 	ld.w	r9,pc[2016]
80004aa8:	72 08       	ld.w	r8,r9[0x0]
80004aaa:	20 28       	sub	r8,2
80004aac:	93 08       	st.w	r9[0x0],r8
80004aae:	c0 71       	brne	80004abc <phy_rx_func+0x670>
					RxMediaState = WAITINGABAB;
80004ab0:	30 09       	mov	r9,0
80004ab2:	fe f8 07 ca 	ld.w	r8,pc[1994]
80004ab6:	91 09       	st.w	r8[0x0],r9
80004ab8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80004abc:	fe f8 08 10 	ld.w	r8,pc[2064]
80004ac0:	70 0a       	ld.w	r10,r8[0x0]
80004ac2:	fe f9 07 b2 	ld.w	r9,pc[1970]
80004ac6:	72 09       	ld.w	r9,r9[0x0]
80004ac8:	8e 6b       	ld.sh	r11,r7[0xc]
80004aca:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004ace:	70 09       	ld.w	r9,r8[0x0]
80004ad0:	2f f9       	sub	r9,-1
80004ad2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004ad4:	e0 49 00 ff 	cp.w	r9,255
80004ad8:	e0 88 00 16 	brls	80004b04 <phy_rx_func+0x6b8>
						{
							RxMedia_IsFillingNext16 = 0;
80004adc:	30 09       	mov	r9,0
80004ade:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004ae0:	fe f6 07 94 	ld.w	r6,pc[1940]
80004ae4:	6c 0c       	ld.w	r12,r6[0x0]
80004ae6:	f0 1f 01 ef 	mcall	800052a0 <phy_rx_func+0xe54>
									payload_ptr = get_payload_idle_isr();
80004aea:	fe f8 07 86 	ld.w	r8,pc[1926]
80004aee:	70 0c       	ld.w	r12,r8[0x0]
80004af0:	f0 1f 01 da 	mcall	80005258 <phy_rx_func+0xe0c>
80004af4:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80004af6:	c0 71       	brne	80004b04 <phy_rx_func+0x6b8>
									{
										RxMediaState = WAITINGABAB;
80004af8:	30 09       	mov	r9,0
80004afa:	fe f8 07 82 	ld.w	r8,pc[1922]
80004afe:	91 09       	st.w	r8[0x0],r9
80004b00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004b04:	fe f9 07 80 	ld.w	r9,pc[1920]
80004b08:	72 08       	ld.w	r8,r9[0x0]
80004b0a:	20 28       	sub	r8,2
80004b0c:	93 08       	st.w	r9[0x0],r8
80004b0e:	c0 71       	brne	80004b1c <phy_rx_func+0x6d0>
					RxMediaState = WAITINGABAB;
80004b10:	30 09       	mov	r9,0
80004b12:	fe f8 07 6a 	ld.w	r8,pc[1898]
80004b16:	91 09       	st.w	r8[0x0],r9
80004b18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004b1c:	fe f8 07 b0 	ld.w	r8,pc[1968]
80004b20:	70 0a       	ld.w	r10,r8[0x0]
80004b22:	fe f9 07 52 	ld.w	r9,pc[1874]
80004b26:	72 09       	ld.w	r9,r9[0x0]
80004b28:	8e 7b       	ld.sh	r11,r7[0xe]
80004b2a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004b2e:	70 09       	ld.w	r9,r8[0x0]
80004b30:	2f f9       	sub	r9,-1
80004b32:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004b34:	e0 49 00 ff 	cp.w	r9,255
80004b38:	e0 88 00 16 	brls	80004b64 <phy_rx_func+0x718>
						{
							RxMedia_IsFillingNext16 = 0;
80004b3c:	30 09       	mov	r9,0
80004b3e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004b40:	fe f7 07 34 	ld.w	r7,pc[1844]
80004b44:	6e 0c       	ld.w	r12,r7[0x0]
80004b46:	f0 1f 01 d7 	mcall	800052a0 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
80004b4a:	fe f8 07 26 	ld.w	r8,pc[1830]
80004b4e:	70 0c       	ld.w	r12,r8[0x0]
80004b50:	f0 1f 01 c2 	mcall	80005258 <phy_rx_func+0xe0c>
80004b54:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004b56:	c0 71       	brne	80004b64 <phy_rx_func+0x718>
							{
								RxMediaState = WAITINGABAB;
80004b58:	30 09       	mov	r9,0
80004b5a:	fe f8 07 22 	ld.w	r8,pc[1826]
80004b5e:	91 09       	st.w	r8[0x0],r9
80004b60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004b64:	fe f9 07 20 	ld.w	r9,pc[1824]
80004b68:	72 08       	ld.w	r8,r9[0x0]
80004b6a:	20 28       	sub	r8,2
80004b6c:	93 08       	st.w	r9[0x0],r8
80004b6e:	e0 81 03 67 	brne	8000523c <phy_rx_func+0xdf0>
					RxMediaState = WAITINGABAB;
80004b72:	30 09       	mov	r9,0
80004b74:	fe f8 07 08 	ld.w	r8,pc[1800]
80004b78:	91 09       	st.w	r8[0x0],r9
80004b7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80004b7e:	fe f8 07 12 	ld.w	r8,pc[1810]
80004b82:	11 89       	ld.ub	r9,r8[0x0]
80004b84:	31 28       	mov	r8,18
80004b86:	f0 09 18 00 	cp.b	r9,r8
80004b8a:	e0 81 01 4c 	brne	80004e22 <phy_rx_func+0x9d6>
					{
						Item_ID = payload_rx_channel->byte[1];
80004b8e:	ef 39 00 09 	ld.ub	r9,r7[9]
80004b92:	fe f8 06 fe 	ld.w	r8,pc[1790]
80004b96:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//
80004b98:	11 89       	ld.ub	r9,r8[0x0]
80004b9a:	3f 28       	mov	r8,-14
80004b9c:	f0 09 18 00 	cp.b	r9,r8
80004ba0:	e0 81 01 3b 	brne	80004e16 <phy_rx_func+0x9ca>
						{
							AMBE_tx_flag = 1;
80004ba4:	30 19       	mov	r9,1
80004ba6:	fe f8 07 1a 	ld.w	r8,pc[1818]
80004baa:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004bac:	6e 29       	ld.w	r9,r7[0x8]
80004bae:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004bb2:	fe f8 06 d2 	ld.w	r8,pc[1746]
80004bb6:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80004bb8:	8e 59       	ld.sh	r9,r7[0xa]
80004bba:	fe f8 07 1a 	ld.w	r8,pc[1818]
80004bbe:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004bc0:	8e 69       	ld.sh	r9,r7[0xc]
80004bc2:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004bc4:	8e 79       	ld.sh	r9,r7[0xe]
80004bc6:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80004bc8:	fe f8 06 d0 	ld.w	r8,pc[1744]
80004bcc:	fe f9 06 ac 	ld.w	r9,pc[1708]
80004bd0:	72 0a       	ld.w	r10,r9[0x0]
80004bd2:	70 09       	ld.w	r9,r8[0x0]
80004bd4:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004bd8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004bdc:	70 09       	ld.w	r9,r8[0x0]
80004bde:	2f f9       	sub	r9,-1
80004be0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004be2:	e0 49 01 ff 	cp.w	r9,511
80004be6:	e0 88 00 16 	brls	80004c12 <phy_rx_func+0x7c6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004bea:	30 09       	mov	r9,0
80004bec:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004bee:	fe f6 06 8a 	ld.w	r6,pc[1674]
80004bf2:	6c 0c       	ld.w	r12,r6[0x0]
80004bf4:	f0 1f 01 ab 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80004bf8:	fe f8 06 78 	ld.w	r8,pc[1656]
80004bfc:	70 0c       	ld.w	r12,r8[0x0]
80004bfe:	f0 1f 01 97 	mcall	80005258 <phy_rx_func+0xe0c>
80004c02:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c04:	c0 71       	brne	80004c12 <phy_rx_func+0x7c6>
								{
									RxMediaState = WAITINGABAB;
80004c06:	30 09       	mov	r9,0
80004c08:	fe f8 06 74 	ld.w	r8,pc[1652]
80004c0c:	91 09       	st.w	r8[0x0],r9
80004c0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c12:	fe f9 06 72 	ld.w	r9,pc[1650]
80004c16:	72 08       	ld.w	r8,r9[0x0]
80004c18:	20 18       	sub	r8,1
80004c1a:	93 08       	st.w	r9[0x0],r8
80004c1c:	c0 71       	brne	80004c2a <phy_rx_func+0x7de>
								RxMediaState = WAITINGABAB;
80004c1e:	30 09       	mov	r9,0
80004c20:	fe f8 06 5c 	ld.w	r8,pc[1628]
80004c24:	91 09       	st.w	r8[0x0],r9
80004c26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80004c2a:	fe f8 06 6e 	ld.w	r8,pc[1646]
80004c2e:	fe f9 06 4a 	ld.w	r9,pc[1610]
80004c32:	72 0a       	ld.w	r10,r9[0x0]
80004c34:	70 09       	ld.w	r9,r8[0x0]
80004c36:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80004c3a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004c3e:	70 09       	ld.w	r9,r8[0x0]
80004c40:	2f f9       	sub	r9,-1
80004c42:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004c44:	e0 49 01 ff 	cp.w	r9,511
80004c48:	e0 88 00 16 	brls	80004c74 <phy_rx_func+0x828>
							{
								RxAMBE_IsFillingNext8 = 0;
80004c4c:	30 09       	mov	r9,0
80004c4e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004c50:	fe f6 06 28 	ld.w	r6,pc[1576]
80004c54:	6c 0c       	ld.w	r12,r6[0x0]
80004c56:	f0 1f 01 93 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80004c5a:	fe f8 06 16 	ld.w	r8,pc[1558]
80004c5e:	70 0c       	ld.w	r12,r8[0x0]
80004c60:	f0 1f 01 7e 	mcall	80005258 <phy_rx_func+0xe0c>
80004c64:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c66:	c0 71       	brne	80004c74 <phy_rx_func+0x828>
								{
									RxMediaState = WAITINGABAB;
80004c68:	30 09       	mov	r9,0
80004c6a:	fe f8 06 12 	ld.w	r8,pc[1554]
80004c6e:	91 09       	st.w	r8[0x0],r9
80004c70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c74:	fe f9 06 10 	ld.w	r9,pc[1552]
80004c78:	72 08       	ld.w	r8,r9[0x0]
80004c7a:	20 18       	sub	r8,1
80004c7c:	93 08       	st.w	r9[0x0],r8
80004c7e:	c0 71       	brne	80004c8c <phy_rx_func+0x840>
								RxMediaState = WAITINGABAB;
80004c80:	30 09       	mov	r9,0
80004c82:	fe f8 05 fa 	ld.w	r8,pc[1530]
80004c86:	91 09       	st.w	r8[0x0],r9
80004c88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80004c8c:	fe f8 06 0c 	ld.w	r8,pc[1548]
80004c90:	fe f9 05 e8 	ld.w	r9,pc[1512]
80004c94:	72 0a       	ld.w	r10,r9[0x0]
80004c96:	70 09       	ld.w	r9,r8[0x0]
80004c98:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004c9c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004ca0:	70 09       	ld.w	r9,r8[0x0]
80004ca2:	2f f9       	sub	r9,-1
80004ca4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004ca6:	e0 49 01 ff 	cp.w	r9,511
80004caa:	e0 88 00 16 	brls	80004cd6 <phy_rx_func+0x88a>
							{
								RxAMBE_IsFillingNext8 = 0;
80004cae:	30 09       	mov	r9,0
80004cb0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004cb2:	fe f6 05 c6 	ld.w	r6,pc[1478]
80004cb6:	6c 0c       	ld.w	r12,r6[0x0]
80004cb8:	f0 1f 01 7a 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80004cbc:	fe f8 05 b4 	ld.w	r8,pc[1460]
80004cc0:	70 0c       	ld.w	r12,r8[0x0]
80004cc2:	f0 1f 01 66 	mcall	80005258 <phy_rx_func+0xe0c>
80004cc6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004cc8:	c0 71       	brne	80004cd6 <phy_rx_func+0x88a>
								{
									RxMediaState = WAITINGABAB;
80004cca:	30 09       	mov	r9,0
80004ccc:	fe f8 05 b0 	ld.w	r8,pc[1456]
80004cd0:	91 09       	st.w	r8[0x0],r9
80004cd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004cd6:	fe f9 05 ae 	ld.w	r9,pc[1454]
80004cda:	72 08       	ld.w	r8,r9[0x0]
80004cdc:	20 18       	sub	r8,1
80004cde:	93 08       	st.w	r9[0x0],r8
80004ce0:	c0 71       	brne	80004cee <phy_rx_func+0x8a2>
								RxMediaState = WAITINGABAB;
80004ce2:	30 09       	mov	r9,0
80004ce4:	fe f8 05 98 	ld.w	r8,pc[1432]
80004ce8:	91 09       	st.w	r8[0x0],r9
80004cea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004cee:	fe f8 05 aa 	ld.w	r8,pc[1450]
80004cf2:	fe f9 05 86 	ld.w	r9,pc[1414]
80004cf6:	72 0a       	ld.w	r10,r9[0x0]
80004cf8:	70 09       	ld.w	r9,r8[0x0]
80004cfa:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004cfe:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d02:	70 09       	ld.w	r9,r8[0x0]
80004d04:	2f f9       	sub	r9,-1
80004d06:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d08:	e0 49 01 ff 	cp.w	r9,511
80004d0c:	e0 88 00 16 	brls	80004d38 <phy_rx_func+0x8ec>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d10:	30 09       	mov	r9,0
80004d12:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d14:	fe f6 05 64 	ld.w	r6,pc[1380]
80004d18:	6c 0c       	ld.w	r12,r6[0x0]
80004d1a:	f0 1f 01 62 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d1e:	fe f8 05 52 	ld.w	r8,pc[1362]
80004d22:	70 0c       	ld.w	r12,r8[0x0]
80004d24:	f0 1f 01 4d 	mcall	80005258 <phy_rx_func+0xe0c>
80004d28:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d2a:	c0 71       	brne	80004d38 <phy_rx_func+0x8ec>
								{
									RxMediaState = WAITINGABAB;
80004d2c:	30 09       	mov	r9,0
80004d2e:	fe f8 05 4e 	ld.w	r8,pc[1358]
80004d32:	91 09       	st.w	r8[0x0],r9
80004d34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d38:	fe f9 05 4c 	ld.w	r9,pc[1356]
80004d3c:	72 08       	ld.w	r8,r9[0x0]
80004d3e:	20 18       	sub	r8,1
80004d40:	93 08       	st.w	r9[0x0],r8
80004d42:	c0 71       	brne	80004d50 <phy_rx_func+0x904>
								RxMediaState = WAITINGABAB;
80004d44:	30 09       	mov	r9,0
80004d46:	fe f8 05 36 	ld.w	r8,pc[1334]
80004d4a:	91 09       	st.w	r8[0x0],r9
80004d4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004d50:	fe f8 05 48 	ld.w	r8,pc[1352]
80004d54:	fe f9 05 24 	ld.w	r9,pc[1316]
80004d58:	72 0a       	ld.w	r10,r9[0x0]
80004d5a:	70 09       	ld.w	r9,r8[0x0]
80004d5c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004d60:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d64:	70 09       	ld.w	r9,r8[0x0]
80004d66:	2f f9       	sub	r9,-1
80004d68:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d6a:	e0 49 01 ff 	cp.w	r9,511
80004d6e:	e0 88 00 16 	brls	80004d9a <phy_rx_func+0x94e>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d72:	30 09       	mov	r9,0
80004d74:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d76:	fe f6 05 02 	ld.w	r6,pc[1282]
80004d7a:	6c 0c       	ld.w	r12,r6[0x0]
80004d7c:	f0 1f 01 49 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d80:	fe f8 04 f0 	ld.w	r8,pc[1264]
80004d84:	70 0c       	ld.w	r12,r8[0x0]
80004d86:	f0 1f 01 35 	mcall	80005258 <phy_rx_func+0xe0c>
80004d8a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d8c:	c0 71       	brne	80004d9a <phy_rx_func+0x94e>
								{
									RxMediaState = WAITINGABAB;
80004d8e:	30 09       	mov	r9,0
80004d90:	fe f8 04 ec 	ld.w	r8,pc[1260]
80004d94:	91 09       	st.w	r8[0x0],r9
80004d96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d9a:	fe f9 04 ea 	ld.w	r9,pc[1258]
80004d9e:	72 08       	ld.w	r8,r9[0x0]
80004da0:	20 18       	sub	r8,1
80004da2:	93 08       	st.w	r9[0x0],r8
80004da4:	c0 71       	brne	80004db2 <phy_rx_func+0x966>
								RxMediaState = WAITINGABAB;
80004da6:	30 09       	mov	r9,0
80004da8:	fe f8 04 d4 	ld.w	r8,pc[1236]
80004dac:	91 09       	st.w	r8[0x0],r9
80004dae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004db2:	fe f8 04 e6 	ld.w	r8,pc[1254]
80004db6:	fe f9 04 c2 	ld.w	r9,pc[1218]
80004dba:	72 0a       	ld.w	r10,r9[0x0]
80004dbc:	70 09       	ld.w	r9,r8[0x0]
80004dbe:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004dc2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004dc6:	70 09       	ld.w	r9,r8[0x0]
80004dc8:	2f f9       	sub	r9,-1
80004dca:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004dcc:	e0 49 01 ff 	cp.w	r9,511
80004dd0:	e0 88 00 16 	brls	80004dfc <phy_rx_func+0x9b0>
							{
								RxAMBE_IsFillingNext8 = 0;
80004dd4:	30 09       	mov	r9,0
80004dd6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004dd8:	fe f7 04 a0 	ld.w	r7,pc[1184]
80004ddc:	6e 0c       	ld.w	r12,r7[0x0]
80004dde:	f0 1f 01 31 	mcall	800052a0 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80004de2:	fe f8 04 8e 	ld.w	r8,pc[1166]
80004de6:	70 0c       	ld.w	r12,r8[0x0]
80004de8:	f0 1f 01 1c 	mcall	80005258 <phy_rx_func+0xe0c>
80004dec:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004dee:	c0 71       	brne	80004dfc <phy_rx_func+0x9b0>
								{
									RxMediaState = WAITINGABAB;
80004df0:	30 09       	mov	r9,0
80004df2:	fe f8 04 8a 	ld.w	r8,pc[1162]
80004df6:	91 09       	st.w	r8[0x0],r9
80004df8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004dfc:	fe f9 04 88 	ld.w	r9,pc[1160]
80004e00:	72 08       	ld.w	r8,r9[0x0]
80004e02:	20 18       	sub	r8,1
80004e04:	93 08       	st.w	r9[0x0],r8
80004e06:	e0 81 02 1b 	brne	8000523c <phy_rx_func+0xdf0>
								RxMediaState = WAITINGABAB;
80004e0a:	30 09       	mov	r9,0
80004e0c:	fe f8 04 70 	ld.w	r8,pc[1136]
80004e10:	91 09       	st.w	r8[0x0],r9
80004e12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004e16:	30 09       	mov	r9,0
80004e18:	fe f8 04 64 	ld.w	r8,pc[1124]
80004e1c:	91 09       	st.w	r8[0x0],r9
80004e1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004e22:	fe f8 04 6e 	ld.w	r8,pc[1134]
80004e26:	11 89       	ld.ub	r9,r8[0x0]
80004e28:	3f 28       	mov	r8,-14
80004e2a:	f0 09 18 00 	cp.b	r9,r8
80004e2e:	c4 31       	brne	80004eb4 <phy_rx_func+0xa68>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004e30:	8e 49       	ld.sh	r9,r7[0x8]
80004e32:	fe f8 04 a2 	ld.w	r8,pc[1186]
80004e36:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004e38:	fe f8 04 60 	ld.w	r8,pc[1120]
80004e3c:	fe f9 04 3c 	ld.w	r9,pc[1084]
80004e40:	72 0a       	ld.w	r10,r9[0x0]
80004e42:	70 09       	ld.w	r9,r8[0x0]
80004e44:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004e48:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004e4c:	70 09       	ld.w	r9,r8[0x0]
80004e4e:	2f f9       	sub	r9,-1
80004e50:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004e52:	e0 49 01 ff 	cp.w	r9,511
80004e56:	e0 88 00 16 	brls	80004e82 <phy_rx_func+0xa36>
						{
							RxAMBE_IsFillingNext8 = 0;
80004e5a:	30 09       	mov	r9,0
80004e5c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004e5e:	fe f7 04 1a 	ld.w	r7,pc[1050]
80004e62:	6e 0c       	ld.w	r12,r7[0x0]
80004e64:	f0 1f 01 0f 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80004e68:	fe f8 04 08 	ld.w	r8,pc[1032]
80004e6c:	70 0c       	ld.w	r12,r8[0x0]
80004e6e:	f0 1f 00 fb 	mcall	80005258 <phy_rx_func+0xe0c>
80004e72:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004e74:	c0 71       	brne	80004e82 <phy_rx_func+0xa36>
							{
								RxMediaState = WAITINGABAB;
80004e76:	30 09       	mov	r9,0
80004e78:	fe f8 04 04 	ld.w	r8,pc[1028]
80004e7c:	91 09       	st.w	r8[0x0],r9
80004e7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004e82:	fe f9 04 02 	ld.w	r9,pc[1026]
80004e86:	72 08       	ld.w	r8,r9[0x0]
80004e88:	20 18       	sub	r8,1
80004e8a:	93 08       	st.w	r9[0x0],r8
80004e8c:	c0 71       	brne	80004e9a <phy_rx_func+0xa4e>
							RxMediaState = WAITINGABAB;
80004e8e:	30 09       	mov	r9,0
80004e90:	fe f8 03 ec 	ld.w	r8,pc[1004]
80004e94:	91 09       	st.w	r8[0x0],r9
80004e96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004e9a:	20 18       	sub	r8,1
80004e9c:	fe f9 03 e8 	ld.w	r9,pc[1000]
80004ea0:	93 08       	st.w	r9[0x0],r8
80004ea2:	58 08       	cp.w	r8,0
80004ea4:	e0 81 01 cc 	brne	8000523c <phy_rx_func+0xdf0>
							RxMediaState = WAITINGABAB;
80004ea8:	30 09       	mov	r9,0
80004eaa:	fe f8 03 d2 	ld.w	r8,pc[978]
80004eae:	91 09       	st.w	r8[0x0],r9
80004eb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
80004eb4:	fe f8 03 dc 	ld.w	r8,pc[988]
80004eb8:	11 89       	ld.ub	r9,r8[0x0]
80004eba:	3f 38       	mov	r8,-13
80004ebc:	f0 09 18 00 	cp.b	r9,r8
80004ec0:	e0 81 01 5a 	brne	80005174 <phy_rx_func+0xd28>
					{
						//
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
80004ec4:	8e 49       	ld.sh	r9,r7[0x8]
80004ec6:	fe f8 04 0e 	ld.w	r8,pc[1038]
80004eca:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
80004ecc:	8e 59       	ld.sh	r9,r7[0xa]
80004ece:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
80004ed0:	8e 69       	ld.sh	r9,r7[0xc]
80004ed2:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
80004ed4:	8e 79       	ld.sh	r9,r7[0xe]
80004ed6:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
80004ed8:	fe f8 03 c0 	ld.w	r8,pc[960]
80004edc:	fe f9 03 9c 	ld.w	r9,pc[924]
80004ee0:	72 0a       	ld.w	r10,r9[0x0]
80004ee2:	70 09       	ld.w	r9,r8[0x0]
80004ee4:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004ee8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004eec:	70 09       	ld.w	r9,r8[0x0]
80004eee:	2f f9       	sub	r9,-1
80004ef0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004ef2:	e0 49 01 ff 	cp.w	r9,511
80004ef6:	e0 88 00 16 	brls	80004f22 <phy_rx_func+0xad6>
						{
							RxAMBE_IsFillingNext8 = 0;
80004efa:	30 09       	mov	r9,0
80004efc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004efe:	fe f6 03 7a 	ld.w	r6,pc[890]
80004f02:	6c 0c       	ld.w	r12,r6[0x0]
80004f04:	f0 1f 00 e7 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80004f08:	fe f8 03 68 	ld.w	r8,pc[872]
80004f0c:	70 0c       	ld.w	r12,r8[0x0]
80004f0e:	f0 1f 00 d3 	mcall	80005258 <phy_rx_func+0xe0c>
80004f12:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004f14:	c0 71       	brne	80004f22 <phy_rx_func+0xad6>
							{
								RxMediaState = WAITINGABAB;
80004f16:	30 09       	mov	r9,0
80004f18:	fe f8 03 64 	ld.w	r8,pc[868]
80004f1c:	91 09       	st.w	r8[0x0],r9
80004f1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004f22:	fe f9 03 62 	ld.w	r9,pc[866]
80004f26:	72 08       	ld.w	r8,r9[0x0]
80004f28:	20 18       	sub	r8,1
80004f2a:	93 08       	st.w	r9[0x0],r8
80004f2c:	c0 71       	brne	80004f3a <phy_rx_func+0xaee>
							RxMediaState = WAITINGABAB;
80004f2e:	30 09       	mov	r9,0
80004f30:	fe f8 03 4c 	ld.w	r8,pc[844]
80004f34:	91 09       	st.w	r8[0x0],r9
80004f36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
80004f3a:	fe f8 03 5e 	ld.w	r8,pc[862]
80004f3e:	fe f9 03 3a 	ld.w	r9,pc[826]
80004f42:	72 0a       	ld.w	r10,r9[0x0]
80004f44:	70 09       	ld.w	r9,r8[0x0]
80004f46:	ef 3b 00 09 	ld.ub	r11,r7[9]
80004f4a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004f4e:	70 09       	ld.w	r9,r8[0x0]
80004f50:	2f f9       	sub	r9,-1
80004f52:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004f54:	e0 49 01 ff 	cp.w	r9,511
80004f58:	e0 88 00 16 	brls	80004f84 <phy_rx_func+0xb38>
						{
							RxAMBE_IsFillingNext8 = 0;
80004f5c:	30 09       	mov	r9,0
80004f5e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004f60:	fe f6 03 18 	ld.w	r6,pc[792]
80004f64:	6c 0c       	ld.w	r12,r6[0x0]
80004f66:	f0 1f 00 cf 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80004f6a:	fe f8 03 06 	ld.w	r8,pc[774]
80004f6e:	70 0c       	ld.w	r12,r8[0x0]
80004f70:	f0 1f 00 ba 	mcall	80005258 <phy_rx_func+0xe0c>
80004f74:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004f76:	c0 71       	brne	80004f84 <phy_rx_func+0xb38>
							{
								RxMediaState = WAITINGABAB;
80004f78:	30 09       	mov	r9,0
80004f7a:	fe f8 03 02 	ld.w	r8,pc[770]
80004f7e:	91 09       	st.w	r8[0x0],r9
80004f80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004f84:	fe f9 03 00 	ld.w	r9,pc[768]
80004f88:	72 08       	ld.w	r8,r9[0x0]
80004f8a:	20 18       	sub	r8,1
80004f8c:	93 08       	st.w	r9[0x0],r8
80004f8e:	c0 71       	brne	80004f9c <phy_rx_func+0xb50>
							RxMediaState = WAITINGABAB;
80004f90:	30 09       	mov	r9,0
80004f92:	fe f8 02 ea 	ld.w	r8,pc[746]
80004f96:	91 09       	st.w	r8[0x0],r9
80004f98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
80004f9c:	fe f8 02 fc 	ld.w	r8,pc[764]
80004fa0:	fe f9 02 d8 	ld.w	r9,pc[728]
80004fa4:	72 0a       	ld.w	r10,r9[0x0]
80004fa6:	70 09       	ld.w	r9,r8[0x0]
80004fa8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004fac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004fb0:	70 09       	ld.w	r9,r8[0x0]
80004fb2:	2f f9       	sub	r9,-1
80004fb4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004fb6:	e0 49 01 ff 	cp.w	r9,511
80004fba:	e0 88 00 16 	brls	80004fe6 <phy_rx_func+0xb9a>
						{
							RxAMBE_IsFillingNext8 = 0;
80004fbe:	30 09       	mov	r9,0
80004fc0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004fc2:	fe f6 02 b6 	ld.w	r6,pc[694]
80004fc6:	6c 0c       	ld.w	r12,r6[0x0]
80004fc8:	f0 1f 00 b6 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80004fcc:	fe f8 02 a4 	ld.w	r8,pc[676]
80004fd0:	70 0c       	ld.w	r12,r8[0x0]
80004fd2:	f0 1f 00 a2 	mcall	80005258 <phy_rx_func+0xe0c>
80004fd6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004fd8:	c0 71       	brne	80004fe6 <phy_rx_func+0xb9a>
							{
								RxMediaState = WAITINGABAB;
80004fda:	30 09       	mov	r9,0
80004fdc:	fe f8 02 a0 	ld.w	r8,pc[672]
80004fe0:	91 09       	st.w	r8[0x0],r9
80004fe2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004fe6:	fe f9 02 9e 	ld.w	r9,pc[670]
80004fea:	72 08       	ld.w	r8,r9[0x0]
80004fec:	20 18       	sub	r8,1
80004fee:	93 08       	st.w	r9[0x0],r8
80004ff0:	c0 71       	brne	80004ffe <phy_rx_func+0xbb2>
							RxMediaState = WAITINGABAB;
80004ff2:	30 09       	mov	r9,0
80004ff4:	fe f8 02 88 	ld.w	r8,pc[648]
80004ff8:	91 09       	st.w	r8[0x0],r9
80004ffa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80004ffe:	fe f8 02 9a 	ld.w	r8,pc[666]
80005002:	fe f9 02 76 	ld.w	r9,pc[630]
80005006:	72 0a       	ld.w	r10,r9[0x0]
80005008:	70 09       	ld.w	r9,r8[0x0]
8000500a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000500e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80005012:	70 09       	ld.w	r9,r8[0x0]
80005014:	2f f9       	sub	r9,-1
80005016:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005018:	e0 49 01 ff 	cp.w	r9,511
8000501c:	e0 88 00 16 	brls	80005048 <phy_rx_func+0xbfc>
						{
							RxAMBE_IsFillingNext8 = 0;
80005020:	30 09       	mov	r9,0
80005022:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005024:	fe f6 02 54 	ld.w	r6,pc[596]
80005028:	6c 0c       	ld.w	r12,r6[0x0]
8000502a:	f0 1f 00 9e 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
8000502e:	fe f8 02 42 	ld.w	r8,pc[578]
80005032:	70 0c       	ld.w	r12,r8[0x0]
80005034:	f0 1f 00 89 	mcall	80005258 <phy_rx_func+0xe0c>
80005038:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000503a:	c0 71       	brne	80005048 <phy_rx_func+0xbfc>
							{
								RxMediaState = WAITINGABAB;
8000503c:	30 09       	mov	r9,0
8000503e:	fe f8 02 3e 	ld.w	r8,pc[574]
80005042:	91 09       	st.w	r8[0x0],r9
80005044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005048:	fe f9 02 3c 	ld.w	r9,pc[572]
8000504c:	72 08       	ld.w	r8,r9[0x0]
8000504e:	20 18       	sub	r8,1
80005050:	93 08       	st.w	r9[0x0],r8
80005052:	c0 71       	brne	80005060 <phy_rx_func+0xc14>
							RxMediaState = WAITINGABAB;
80005054:	30 09       	mov	r9,0
80005056:	fe f8 02 26 	ld.w	r8,pc[550]
8000505a:	91 09       	st.w	r8[0x0],r9
8000505c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80005060:	fe f8 02 38 	ld.w	r8,pc[568]
80005064:	fe f9 02 14 	ld.w	r9,pc[532]
80005068:	72 0a       	ld.w	r10,r9[0x0]
8000506a:	70 09       	ld.w	r9,r8[0x0]
8000506c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80005070:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80005074:	70 09       	ld.w	r9,r8[0x0]
80005076:	2f f9       	sub	r9,-1
80005078:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000507a:	e0 49 01 ff 	cp.w	r9,511
8000507e:	e0 88 00 13 	brls	800050a4 <phy_rx_func+0xc58>
						{
							RxAMBE_IsFillingNext8 = 0;
80005082:	30 09       	mov	r9,0
80005084:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005086:	4f d6       	lddpc	r6,80005278 <phy_rx_func+0xe2c>
80005088:	6c 0c       	ld.w	r12,r6[0x0]
8000508a:	f0 1f 00 86 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
8000508e:	4f 98       	lddpc	r8,80005270 <phy_rx_func+0xe24>
80005090:	70 0c       	ld.w	r12,r8[0x0]
80005092:	f0 1f 00 72 	mcall	80005258 <phy_rx_func+0xe0c>
80005096:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80005098:	c0 61       	brne	800050a4 <phy_rx_func+0xc58>
							{
								RxMediaState = WAITINGABAB;
8000509a:	30 09       	mov	r9,0
8000509c:	4f 88       	lddpc	r8,8000527c <phy_rx_func+0xe30>
8000509e:	91 09       	st.w	r8[0x0],r9
800050a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800050a4:	4f 89       	lddpc	r9,80005284 <phy_rx_func+0xe38>
800050a6:	72 08       	ld.w	r8,r9[0x0]
800050a8:	20 18       	sub	r8,1
800050aa:	93 08       	st.w	r9[0x0],r8
800050ac:	c0 61       	brne	800050b8 <phy_rx_func+0xc6c>
							RxMediaState = WAITINGABAB;
800050ae:	30 09       	mov	r9,0
800050b0:	4f 38       	lddpc	r8,8000527c <phy_rx_func+0xe30>
800050b2:	91 09       	st.w	r8[0x0],r9
800050b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
800050b8:	4f 88       	lddpc	r8,80005298 <phy_rx_func+0xe4c>
800050ba:	4f 09       	lddpc	r9,80005278 <phy_rx_func+0xe2c>
800050bc:	72 0a       	ld.w	r10,r9[0x0]
800050be:	70 09       	ld.w	r9,r8[0x0]
800050c0:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800050c4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800050c8:	70 09       	ld.w	r9,r8[0x0]
800050ca:	2f f9       	sub	r9,-1
800050cc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800050ce:	e0 49 01 ff 	cp.w	r9,511
800050d2:	e0 88 00 13 	brls	800050f8 <phy_rx_func+0xcac>
						{
							RxAMBE_IsFillingNext8 = 0;
800050d6:	30 09       	mov	r9,0
800050d8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800050da:	4e 86       	lddpc	r6,80005278 <phy_rx_func+0xe2c>
800050dc:	6c 0c       	ld.w	r12,r6[0x0]
800050de:	f0 1f 00 71 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
800050e2:	4e 48       	lddpc	r8,80005270 <phy_rx_func+0xe24>
800050e4:	70 0c       	ld.w	r12,r8[0x0]
800050e6:	f0 1f 00 5d 	mcall	80005258 <phy_rx_func+0xe0c>
800050ea:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800050ec:	c0 61       	brne	800050f8 <phy_rx_func+0xcac>
							{
								RxMediaState = WAITINGABAB;
800050ee:	30 09       	mov	r9,0
800050f0:	4e 38       	lddpc	r8,8000527c <phy_rx_func+0xe30>
800050f2:	91 09       	st.w	r8[0x0],r9
800050f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800050f8:	4e 39       	lddpc	r9,80005284 <phy_rx_func+0xe38>
800050fa:	72 08       	ld.w	r8,r9[0x0]
800050fc:	20 18       	sub	r8,1
800050fe:	93 08       	st.w	r9[0x0],r8
80005100:	c0 61       	brne	8000510c <phy_rx_func+0xcc0>
							RxMediaState = WAITINGABAB;
80005102:	30 09       	mov	r9,0
80005104:	4d e8       	lddpc	r8,8000527c <phy_rx_func+0xe30>
80005106:	91 09       	st.w	r8[0x0],r9
80005108:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
8000510c:	4e 38       	lddpc	r8,80005298 <phy_rx_func+0xe4c>
8000510e:	4d b9       	lddpc	r9,80005278 <phy_rx_func+0xe2c>
80005110:	72 0a       	ld.w	r10,r9[0x0]
80005112:	70 09       	ld.w	r9,r8[0x0]
80005114:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80005118:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000511c:	70 09       	ld.w	r9,r8[0x0]
8000511e:	2f f9       	sub	r9,-1
80005120:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005122:	e0 49 01 ff 	cp.w	r9,511
80005126:	e0 88 00 13 	brls	8000514c <phy_rx_func+0xd00>
						{
							RxAMBE_IsFillingNext8 = 0;
8000512a:	30 09       	mov	r9,0
8000512c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000512e:	4d 37       	lddpc	r7,80005278 <phy_rx_func+0xe2c>
80005130:	6e 0c       	ld.w	r12,r7[0x0]
80005132:	f0 1f 00 5c 	mcall	800052a0 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80005136:	4c f8       	lddpc	r8,80005270 <phy_rx_func+0xe24>
80005138:	70 0c       	ld.w	r12,r8[0x0]
8000513a:	f0 1f 00 48 	mcall	80005258 <phy_rx_func+0xe0c>
8000513e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80005140:	c0 61       	brne	8000514c <phy_rx_func+0xd00>
							{
								RxMediaState = WAITINGABAB;
80005142:	30 09       	mov	r9,0
80005144:	4c e8       	lddpc	r8,8000527c <phy_rx_func+0xe30>
80005146:	91 09       	st.w	r8[0x0],r9
80005148:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000514c:	4c e9       	lddpc	r9,80005284 <phy_rx_func+0xe38>
8000514e:	72 08       	ld.w	r8,r9[0x0]
80005150:	20 18       	sub	r8,1
80005152:	93 08       	st.w	r9[0x0],r8
80005154:	c0 61       	brne	80005160 <phy_rx_func+0xd14>
							RxMediaState = WAITINGABAB;
80005156:	30 09       	mov	r9,0
80005158:	4c 98       	lddpc	r8,8000527c <phy_rx_func+0xe30>
8000515a:	91 09       	st.w	r8[0x0],r9
8000515c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//AMBE Vocoder Bits Stream(bit59~63),
						if ((RxBytesWaiting -= 1) <= 0){
80005160:	20 18       	sub	r8,1
80005162:	4c 99       	lddpc	r9,80005284 <phy_rx_func+0xe38>
80005164:	93 08       	st.w	r9[0x0],r8
80005166:	58 08       	cp.w	r8,0
80005168:	c6 a1       	brne	8000523c <phy_rx_func+0xdf0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000516a:	30 09       	mov	r9,0
8000516c:	4c 48       	lddpc	r8,8000527c <phy_rx_func+0xe30>
8000516e:	91 09       	st.w	r8[0x0],r9
80005170:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80005174:	4c 78       	lddpc	r8,80005290 <phy_rx_func+0xe44>
80005176:	11 89       	ld.ub	r9,r8[0x0]
80005178:	30 48       	mov	r8,4
8000517a:	f0 09 18 00 	cp.b	r9,r8
8000517e:	c0 70       	breq	8000518c <phy_rx_func+0xd40>
80005180:	4c 48       	lddpc	r8,80005290 <phy_rx_func+0xe44>
80005182:	11 89       	ld.ub	r9,r8[0x0]
80005184:	30 38       	mov	r8,3
80005186:	f0 09 18 00 	cp.b	r9,r8
8000518a:	c1 01       	brne	800051aa <phy_rx_func+0xd5e>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000518c:	6e 29       	ld.w	r9,r7[0x8]
8000518e:	4c c8       	lddpc	r8,800052bc <phy_rx_func+0xe70>
80005190:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80005192:	6e 39       	ld.w	r9,r7[0xc]
80005194:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80005196:	4b c9       	lddpc	r9,80005284 <phy_rx_func+0xe38>
80005198:	72 08       	ld.w	r8,r9[0x0]
8000519a:	20 88       	sub	r8,8
8000519c:	93 08       	st.w	r9[0x0],r8
8000519e:	c4 f1       	brne	8000523c <phy_rx_func+0xdf0>
						{
					
							RxBytesWaiting = 0;
800051a0:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800051a2:	4b 79       	lddpc	r9,8000527c <phy_rx_func+0xe30>
800051a4:	93 08       	st.w	r9[0x0],r8
800051a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800051aa:	30 09       	mov	r9,0
800051ac:	4b 48       	lddpc	r8,8000527c <phy_rx_func+0xe30>
800051ae:	91 09       	st.w	r8[0x0],r9
800051b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800051b4:	4c 08       	lddpc	r8,800052b4 <phy_rx_func+0xe68>
800051b6:	70 09       	ld.w	r9,r8[0x0]
800051b8:	8e 4b       	ld.sh	r11,r7[0x8]
800051ba:	4c 0a       	lddpc	r10,800052b8 <phy_rx_func+0xe6c>
800051bc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800051c0:	2f f9       	sub	r9,-1
800051c2:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800051c4:	4b 48       	lddpc	r8,80005294 <phy_rx_func+0xe48>
800051c6:	70 09       	ld.w	r9,r8[0x0]
800051c8:	20 29       	sub	r9,2
800051ca:	91 09       	st.w	r8[0x0],r9
800051cc:	70 08       	ld.w	r8,r8[0x0]
800051ce:	58 08       	cp.w	r8,0
800051d0:	c3 01       	brne	80005230 <phy_rx_func+0xde4>
				{
					RxData_IsFillingNext16 = 0;
800051d2:	30 09       	mov	r9,0
800051d4:	4b 88       	lddpc	r8,800052b4 <phy_rx_func+0xe68>
800051d6:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800051d8:	8e 59       	ld.sh	r9,r7[0xa]
800051da:	fe 78 82 12 	mov	r8,-32238
800051de:	f0 09 19 00 	cp.h	r9,r8
800051e2:	c2 21       	brne	80005226 <phy_rx_func+0xdda>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
800051e4:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800051e8:	4a f8       	lddpc	r8,800052a4 <phy_rx_func+0xe58>
800051ea:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800051ec:	8e 59       	ld.sh	r9,r7[0xa]
800051ee:	4a f8       	lddpc	r8,800052a8 <phy_rx_func+0xe5c>
800051f0:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800051f2:	8e 69       	ld.sh	r9,r7[0xc]
800051f4:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800051f6:	f0 1f 00 2e 	mcall	800052ac <phy_rx_func+0xe60>
800051fa:	4a 28       	lddpc	r8,80005280 <phy_rx_func+0xe34>
800051fc:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800051fe:	ef 39 00 0f 	ld.ub	r9,r7[15]
80005202:	3f 38       	mov	r8,-13
80005204:	f0 09 18 00 	cp.b	r9,r8
80005208:	c0 a1       	brne	8000521c <phy_rx_func+0xdd0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
8000520a:	10 99       	mov	r9,r8
8000520c:	4a 18       	lddpc	r8,80005290 <phy_rx_func+0xe44>
8000520e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
80005210:	30 09       	mov	r9,0
80005212:	49 d8       	lddpc	r8,80005284 <phy_rx_func+0xe38>
80005214:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//AMBE
80005216:	30 19       	mov	r9,1
80005218:	4a b8       	lddpc	r8,800052c4 <phy_rx_func+0xe78>
8000521a:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
8000521c:	30 49       	mov	r9,4
8000521e:	49 88       	lddpc	r8,8000527c <phy_rx_func+0xe30>
80005220:	91 09       	st.w	r8[0x0],r9
80005222:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80005226:	30 09       	mov	r9,0
80005228:	49 58       	lddpc	r8,8000527c <phy_rx_func+0xe30>
8000522a:	91 09       	st.w	r8[0x0],r9
8000522c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80005230:	4a ac       	lddpc	r12,800052d8 <phy_rx_func+0xe8c>
80005232:	f0 1f 00 17 	mcall	8000528c <phy_rx_func+0xe40>
					RxMediaState = WAITINGABAB;//Jump
80005236:	30 09       	mov	r9,0
80005238:	49 18       	lddpc	r8,8000527c <phy_rx_func+0xe30>
8000523a:	91 09       	st.w	r8[0x0],r9
8000523c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005240:	00 00       	add	r0,r0
80005242:	10 68       	and	r8,r8
80005244:	00 00       	add	r0,r0
80005246:	10 54       	eor	r4,r8
80005248:	00 00       	add	r0,r0
8000524a:	10 1c       	sub	r12,r8
8000524c:	00 00       	add	r0,r0
8000524e:	10 14       	sub	r4,r8
80005250:	00 00       	add	r0,r0
80005252:	10 84       	andn	r4,r8
80005254:	00 00       	add	r0,r0
80005256:	10 64       	and	r4,r8
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	3c a8       	mov	r8,-54
8000525c:	00 00       	add	r0,r0
8000525e:	10 50       	eor	r0,r8
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	93 d4       	st.w	r9[0x34],r4
80005264:	00 00       	add	r0,r0
80005266:	10 38       	cp.w	r8,r8
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	3b f4       	mov	r4,-65
8000526c:	00 00       	add	r0,r0
8000526e:	10 16       	sub	r6,r8
80005270:	00 00       	add	r0,r0
80005272:	10 20       	rsub	r0,r8
80005274:	00 00       	add	r0,r0
80005276:	10 60       	and	r0,r8
80005278:	00 00       	add	r0,r0
8000527a:	10 80       	andn	r0,r8
8000527c:	00 00       	add	r0,r0
8000527e:	10 4c       	or	r12,r8
80005280:	00 00       	add	r0,r0
80005282:	0f fc       	ld.ub	r12,r7[0x7]
80005284:	00 00       	add	r0,r0
80005286:	10 10       	sub	r0,r8
80005288:	80 01       	ld.sh	r1,r0[0x0]
8000528a:	97 fc       	st.w	r11[0x3c],r12
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	a4 cc       	st.b	r2[0x4],r12
80005290:	00 00       	add	r0,r0
80005292:	10 24       	rsub	r4,r8
80005294:	00 00       	add	r0,r0
80005296:	10 70       	tst	r0,r8
80005298:	00 00       	add	r0,r0
8000529a:	10 78       	tst	r8,r8
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	ae 4e       	st.h	r7[0x8],lr
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	43 ec       	lddsp	r12,sp[0xf8]
800052a4:	00 00       	add	r0,r0
800052a6:	0a 49       	or	r9,r5
800052a8:	00 00       	add	r0,r0
800052aa:	14 6c       	and	r12,r10
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	3a c8       	mov	r8,-84
800052b0:	80 01       	ld.sh	r1,r0[0x0]
800052b2:	98 14       	ld.sh	r4,r12[0x2]
800052b4:	00 00       	add	r0,r0
800052b6:	10 58       	eor	r8,r8
800052b8:	00 00       	add	r0,r0
800052ba:	13 78       	ld.ub	r8,--r9
800052bc:	00 00       	add	r0,r0
800052be:	10 28       	rsub	r8,r8
800052c0:	00 00       	add	r0,r0
800052c2:	0a 48       	or	r8,r5
800052c4:	00 00       	add	r0,r0
800052c6:	0a 40       	or	r0,r5
800052c8:	00 00       	add	r0,r0
800052ca:	10 88       	andn	r8,r8
800052cc:	00 00       	add	r0,r0
800052ce:	10 44       	or	r4,r8
800052d0:	00 00       	add	r0,r0
800052d2:	0a 55       	eor	r5,r5
800052d4:	00 00       	add	r0,r0
800052d6:	13 70       	ld.ub	r0,--r9
800052d8:	80 01       	ld.sh	r1,r0[0x0]
800052da:	98 28       	ld.sh	r8,r12[0x4]

800052dc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800052dc:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800052de:	49 88       	lddpc	r8,8000533c <pdca_int_handler+0x60>
800052e0:	11 89       	ld.ub	r9,r8[0x0]
800052e2:	ec 19 00 01 	eorl	r9,0x1
800052e6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800052e8:	11 89       	ld.ub	r9,r8[0x0]
800052ea:	a5 69       	lsl	r9,0x4
800052ec:	2f c9       	sub	r9,-4
800052ee:	49 5a       	lddpc	r10,80005340 <pdca_int_handler+0x64>
800052f0:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800052f2:	fe 7a 00 40 	mov	r10,-65472
800052f6:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800052f8:	30 39       	mov	r9,3
800052fa:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800052fc:	11 8a       	ld.ub	r10,r8[0x0]
800052fe:	a5 6a       	lsl	r10,0x4
80005300:	2f ca       	sub	r10,-4
80005302:	49 18       	lddpc	r8,80005344 <pdca_int_handler+0x68>
80005304:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80005306:	fe 78 00 00 	mov	r8,-65536
8000530a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000530c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000530e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80005310:	48 e8       	lddpc	r8,80005348 <pdca_int_handler+0x6c>
80005312:	70 08       	ld.w	r8,r8[0x0]
80005314:	58 08       	cp.w	r8,0
80005316:	c0 70       	breq	80005324 <pdca_int_handler+0x48>
80005318:	48 99       	lddpc	r9,8000533c <pdca_int_handler+0x60>
8000531a:	13 89       	ld.ub	r9,r9[0x0]
8000531c:	a5 69       	lsl	r9,0x4
8000531e:	48 ac       	lddpc	r12,80005344 <pdca_int_handler+0x68>
80005320:	12 0c       	add	r12,r9
80005322:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80005324:	48 a8       	lddpc	r8,8000534c <pdca_int_handler+0x70>
80005326:	70 08       	ld.w	r8,r8[0x0]
80005328:	58 08       	cp.w	r8,0
8000532a:	c0 70       	breq	80005338 <pdca_int_handler+0x5c>
8000532c:	48 49       	lddpc	r9,8000533c <pdca_int_handler+0x60>
8000532e:	13 89       	ld.ub	r9,r9[0x0]
80005330:	a5 69       	lsl	r9,0x4
80005332:	48 4c       	lddpc	r12,80005340 <pdca_int_handler+0x64>
80005334:	12 0c       	add	r12,r9
80005336:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80005338:	d4 02       	popm	lr
8000533a:	d6 03       	rete
8000533c:	00 00       	add	r0,r0
8000533e:	46 74       	lddsp	r4,sp[0x19c]
80005340:	00 00       	add	r0,r0
80005342:	46 9c       	lddsp	r12,sp[0x1a4]
80005344:	00 00       	add	r0,r0
80005346:	46 7c       	lddsp	r12,sp[0x19c]
80005348:	00 00       	add	r0,r0
8000534a:	10 8c       	andn	r12,r8
8000534c:	00 00       	add	r0,r0
8000534e:	10 90       	mov	r0,r8

80005350 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80005350:	fe 78 10 00 	mov	r8,-61440
80005354:	e0 69 0d c0 	mov	r9,3520
80005358:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
8000535c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80005360:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80005364:	fe 78 34 00 	mov	r8,-52224
80005368:	e0 69 80 00 	mov	r9,32768
8000536c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000536e:	30 09       	mov	r9,0
80005370:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80005372:	e0 69 04 21 	mov	r9,1057
80005376:	ea 19 3f 20 	orh	r9,0x3f20
8000537a:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
8000537c:	e0 69 02 9f 	mov	r9,671
80005380:	ea 19 01 00 	orh	r9,0x100
80005384:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80005386:	e0 6a 04 02 	mov	r10,1026
8000538a:	ea 1a 3f 20 	orh	r10,0x3f20
8000538e:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80005390:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80005392:	5e fc       	retal	r12

80005394 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80005394:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80005396:	30 19       	mov	r9,1
80005398:	49 78       	lddpc	r8,800053f4 <local_start_PDC+0x60>
8000539a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
8000539c:	fe 78 00 00 	mov	r8,-65536
800053a0:	30 7b       	mov	r11,7
800053a2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800053a4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800053a6:	49 59       	lddpc	r9,800053f8 <local_start_PDC+0x64>
800053a8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800053ac:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800053ae:	30 3a       	mov	r10,3
800053b0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800053b2:	30 1c       	mov	r12,1
800053b4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800053b6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800053b8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800053ba:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800053bc:	30 2c       	mov	r12,2
800053be:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800053c0:	48 f9       	lddpc	r9,800053fc <local_start_PDC+0x68>
800053c2:	e0 68 5a 5a 	mov	r8,23130
800053c6:	ea 18 ab cd 	orh	r8,0xabcd
800053ca:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800053cc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800053ce:	30 0e       	mov	lr,0
800053d0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800053d2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800053d4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800053d6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800053d8:	fe 78 00 40 	mov	r8,-65472
800053dc:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800053de:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800053e0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800053e4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800053e6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800053e8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800053ea:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800053ec:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800053ee:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800053f0:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800053f2:	d8 02       	popm	pc
800053f4:	00 00       	add	r0,r0
800053f6:	46 74       	lddsp	r4,sp[0x19c]
800053f8:	00 00       	add	r0,r0
800053fa:	46 7c       	lddsp	r12,sp[0x19c]
800053fc:	00 00       	add	r0,r0
800053fe:	46 9c       	lddsp	r12,sp[0x1a4]

80005400 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80005400:	48 38       	lddpc	r8,8000540c <register_rx_tx_func+0xc>
80005402:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80005404:	48 38       	lddpc	r8,80005410 <register_rx_tx_func+0x10>
80005406:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80005408:	5e fc       	retal	r12
8000540a:	00 00       	add	r0,r0
8000540c:	00 00       	add	r0,r0
8000540e:	10 8c       	andn	r12,r8
80005410:	00 00       	add	r0,r0
80005412:	10 90       	mov	r0,r8

80005414 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80005414:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80005416:	fe 78 10 00 	mov	r8,-61440
8000541a:	30 29       	mov	r9,2
8000541c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80005420:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80005424:	10 99       	mov	r9,r8
80005426:	f2 f8 01 60 	ld.w	r8,r9[352]
8000542a:	e2 18 00 02 	andl	r8,0x2,COH
8000542e:	cf c0       	breq	80005426 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80005430:	fe 79 10 00 	mov	r9,-61440
80005434:	f2 f8 01 60 	ld.w	r8,r9[352]
80005438:	e2 18 00 02 	andl	r8,0x2,COH
8000543c:	cf c1       	brne	80005434 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000543e:	30 3a       	mov	r10,3
80005440:	36 0b       	mov	r11,96
80005442:	48 bc       	lddpc	r12,8000546c <ssc_init+0x58>
80005444:	f0 1f 00 0b 	mcall	80005470 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80005448:	f0 1f 00 0b 	mcall	80005474 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
8000544c:	f0 1f 00 0b 	mcall	80005478 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005450:	fe 79 00 00 	mov	r9,-65536
80005454:	30 18       	mov	r8,1
80005456:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005458:	fe 7a 00 40 	mov	r10,-65472
8000545c:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000545e:	e0 6b 01 01 	mov	r11,257
80005462:	fe 7a 34 00 	mov	r10,-52224
80005466:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80005468:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
8000546a:	d8 02       	popm	pc
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	52 dc       	stdsp	sp[0xb4],r12
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	60 bc       	ld.w	r12,r0[0x2c]
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	53 50       	stdsp	sp[0xd4],r0
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	53 94       	stdsp	sp[0xe4],r4

8000547c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
8000547c:	48 28       	lddpc	r8,80005484 <xcmp_register_app_list+0x8>
8000547e:	91 0c       	st.w	r8[0x0],r12
}
80005480:	5e fc       	retal	r12
80005482:	00 00       	add	r0,r0
80005484:	00 00       	add	r0,r0
80005486:	46 bc       	lddsp	r12,sp[0x1ac]

80005488 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80005488:	eb cd 40 80 	pushm	r7,lr
8000548c:	fa cd 01 00 	sub	sp,sp,256
80005490:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80005492:	16 98       	mov	r8,r11
80005494:	2f 08       	sub	r8,-16
80005496:	af a8       	sbr	r8,0xe
80005498:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000549a:	3f f8       	mov	r8,-1
8000549c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000549e:	30 b9       	mov	r9,11
800054a0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800054a2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800054a4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800054a6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800054a8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800054aa:	f6 ca ff fe 	sub	r10,r11,-2
800054ae:	18 9b       	mov	r11,r12
800054b0:	fa cc ff f0 	sub	r12,sp,-16
800054b4:	f0 1f 00 05 	mcall	800054c8 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800054b8:	2f e7       	sub	r7,-2
800054ba:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800054bc:	1a 9c       	mov	r12,sp
800054be:	f0 1f 00 04 	mcall	800054cc <xcmp_tx+0x44>
}
800054c2:	2c 0d       	sub	sp,-256
800054c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	ad 06       	ld.d	r6,r6
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	59 a4       	cp.w	r4,26

800054d0 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
800054d0:	d4 01       	pushm	lr
800054d2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800054d6:	e0 68 04 21 	mov	r8,1057
800054da:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
800054dc:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
800054e0:	30 09       	mov	r9,0
800054e2:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
800054e4:	30 19       	mov	r9,1
800054e6:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
800054e8:	30 39       	mov	r9,3
800054ea:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
800054ec:	30 3b       	mov	r11,3
800054ee:	fa cc ff fe 	sub	r12,sp,-2
800054f2:	f0 1f 00 03 	mcall	800054fc <xcmp_exit_device_control_mode+0x2c>
}
800054f6:	2c dd       	sub	sp,-204
800054f8:	d8 02       	popm	pc
800054fa:	00 00       	add	r0,r0
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	54 88       	stdsp	sp[0x120],r8

80005500 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80005500:	d4 01       	pushm	lr
80005502:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80005506:	e0 68 04 21 	mov	r8,1057
8000550a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
8000550c:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80005510:	30 19       	mov	r9,1
80005512:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80005514:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80005516:	30 39       	mov	r9,3
80005518:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
8000551a:	30 3b       	mov	r11,3
8000551c:	fa cc ff fe 	sub	r12,sp,-2
80005520:	f0 1f 00 02 	mcall	80005528 <xcmp_enter_device_control_mode+0x28>
}
80005524:	2c dd       	sub	sp,-204
80005526:	d8 02       	popm	pc
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	54 88       	stdsp	sp[0x120],r8

8000552c <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
8000552c:	d4 01       	pushm	lr
8000552e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80005532:	e0 68 04 14 	mov	r8,1044
80005536:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80005538:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
8000553c:	30 19       	mov	r9,1
8000553e:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80005540:	30 09       	mov	r9,0
80005542:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80005544:	30 49       	mov	r9,4
80005546:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80005548:	30 fa       	mov	r10,15
8000554a:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000554c:	30 c9       	mov	r9,12
8000554e:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80005550:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80005552:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
80005554:	31 1a       	mov	r10,17
80005556:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80005558:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
8000555c:	31 3a       	mov	r10,19
8000555e:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
80005562:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80005566:	30 bb       	mov	r11,11
80005568:	fa cc ff fe 	sub	r12,sp,-2
8000556c:	f0 1f 00 02 	mcall	80005574 <xcmp_audio_route_AMBE+0x48>
}
80005570:	2c dd       	sub	sp,-204
80005572:	d8 02       	popm	pc
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	54 88       	stdsp	sp[0x120],r8

80005578 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80005578:	d4 01       	pushm	lr
8000557a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
8000557e:	e0 68 04 65 	mov	r8,1125
80005582:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80005584:	fa cc ff fe 	sub	r12,sp,-2
80005588:	30 18       	mov	r8,1
8000558a:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
8000558c:	30 1b       	mov	r11,1
8000558e:	f0 1f 00 03 	mcall	80005598 <xcmp_enter_enhanced_OB_mode+0x20>
}
80005592:	2c dd       	sub	sp,-204
80005594:	d8 02       	popm	pc
80005596:	00 00       	add	r0,r0
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	54 88       	stdsp	sp[0x120],r8

8000559c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000559c:	d4 01       	pushm	lr
8000559e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800055a2:	fe 78 b4 00 	mov	r8,-19456
800055a6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800055a8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
800055ac:	30 89       	mov	r9,8
800055ae:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800055b0:	30 19       	mov	r9,1
800055b2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800055b4:	30 09       	mov	r9,0
800055b6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800055b8:	30 5a       	mov	r10,5
800055ba:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800055bc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800055be:	30 7a       	mov	r10,7
800055c0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800055c2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800055c4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800055c6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800055ca:	30 9b       	mov	r11,9
800055cc:	fa cc ff fe 	sub	r12,sp,-2
800055d0:	f0 1f 00 02 	mcall	800055d8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800055d4:	2c dd       	sub	sp,-204
800055d6:	d8 02       	popm	pc
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	54 88       	stdsp	sp[0x120],r8

800055dc <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800055dc:	d4 01       	pushm	lr
800055de:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800055e2:	fe 78 80 00 	mov	r8,-32768
800055e6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800055e8:	30 38       	mov	r8,3
800055ea:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800055ec:	30 1b       	mov	r11,1
800055ee:	fa cc ff fe 	sub	r12,sp,-2
800055f2:	f0 1f 00 03 	mcall	800055fc <xcmp_opcode_not_supported+0x20>
}
800055f6:	2c dd       	sub	sp,-204
800055f8:	d8 02       	popm	pc
800055fa:	00 00       	add	r0,r0
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	54 88       	stdsp	sp[0x120],r8

80005600 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80005600:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80005602:	96 88       	ld.uh	r8,r11[0x0]
80005604:	e2 18 f0 00 	andl	r8,0xf000,COH
80005608:	e0 48 80 00 	cp.w	r8,32768
8000560c:	c0 f0       	breq	8000562a <xcmp_exec_func+0x2a>
8000560e:	e0 48 b0 00 	cp.w	r8,45056
80005612:	c1 20       	breq	80005636 <xcmp_exec_func+0x36>
80005614:	58 08       	cp.w	r8,0
80005616:	c1 51       	brne	80005640 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80005618:	78 08       	ld.w	r8,r12[0x0]
8000561a:	58 08       	cp.w	r8,0
8000561c:	c0 40       	breq	80005624 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000561e:	16 9c       	mov	r12,r11
80005620:	5d 18       	icall	r8
80005622:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80005624:	f0 1f 00 08 	mcall	80005644 <xcmp_exec_func+0x44>
80005628:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000562a:	78 18       	ld.w	r8,r12[0x4]
8000562c:	58 08       	cp.w	r8,0
8000562e:	c0 90       	breq	80005640 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80005630:	16 9c       	mov	r12,r11
80005632:	5d 18       	icall	r8
80005634:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80005636:	78 28       	ld.w	r8,r12[0x8]
80005638:	58 08       	cp.w	r8,0
8000563a:	c0 30       	breq	80005640 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000563c:	16 9c       	mov	r12,r11
8000563e:	5d 18       	icall	r8
80005640:	d8 02       	popm	pc
80005642:	00 00       	add	r0,r0
80005644:	80 00       	ld.sh	r0,r0[0x0]
80005646:	55 dc       	stdsp	sp[0x174],r12

80005648 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80005648:	d4 01       	pushm	lr
8000564a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000564e:	e0 68 04 09 	mov	r8,1033
80005652:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80005654:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80005658:	30 19       	mov	r9,1
8000565a:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
8000565c:	30 09       	mov	r9,0
8000565e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80005660:	30 ca       	mov	r10,12
80005662:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80005664:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80005666:	fb 69 00 08 	st.b	sp[8],r9
8000566a:	fa c8 ff f7 	sub	r8,sp,-9
8000566e:	b0 89       	st.b	r8[0x0],r9
80005670:	fa c8 ff f6 	sub	r8,sp,-10
80005674:	b0 89       	st.b	r8[0x0],r9
80005676:	fa c8 ff f5 	sub	r8,sp,-11
8000567a:	b0 89       	st.b	r8[0x0],r9
8000567c:	fa c8 ff f4 	sub	r8,sp,-12
80005680:	b0 89       	st.b	r8[0x0],r9
80005682:	fa c8 ff f3 	sub	r8,sp,-13
80005686:	b0 89       	st.b	r8[0x0],r9
80005688:	fa c8 ff f2 	sub	r8,sp,-14
8000568c:	b0 89       	st.b	r8[0x0],r9
8000568e:	fa c8 ff f1 	sub	r8,sp,-15
80005692:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80005694:	30 cb       	mov	r11,12
80005696:	fa cc ff fe 	sub	r12,sp,-2
8000569a:	f0 1f 00 03 	mcall	800056a4 <xcmp_IdleTestTone+0x5c>
}
8000569e:	2c dd       	sub	sp,-204
800056a0:	d8 02       	popm	pc
800056a2:	00 00       	add	r0,r0
800056a4:	80 00       	ld.sh	r0,r0[0x0]
800056a6:	54 88       	stdsp	sp[0x120],r8

800056a8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800056a8:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800056aa:	f0 1f 00 0d 	mcall	800056dc <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800056ae:	48 dc       	lddpc	r12,800056e0 <xcmp_init+0x38>
800056b0:	f0 1f 00 0d 	mcall	800056e4 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800056b4:	30 4b       	mov	r11,4
800056b6:	31 4c       	mov	r12,20
800056b8:	f0 1f 00 0c 	mcall	800056e8 <xcmp_init+0x40>
800056bc:	48 c8       	lddpc	r8,800056ec <xcmp_init+0x44>
800056be:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800056c0:	30 09       	mov	r9,0
800056c2:	1a d9       	st.w	--sp,r9
800056c4:	1a d9       	st.w	--sp,r9
800056c6:	1a d9       	st.w	--sp,r9
800056c8:	30 38       	mov	r8,3
800056ca:	e0 6a 01 80 	mov	r10,384
800056ce:	48 9b       	lddpc	r11,800056f0 <xcmp_init+0x48>
800056d0:	48 9c       	lddpc	r12,800056f4 <xcmp_init+0x4c>
800056d2:	f0 1f 00 0a 	mcall	800056f8 <xcmp_init+0x50>
800056d6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800056d8:	d8 02       	popm	pc
800056da:	00 00       	add	r0,r0
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	5a 88       	cp.w	r8,-24
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	57 f8       	stdsp	sp[0x1fc],r8
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	58 44       	cp.w	r4,4
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	98 a8       	ld.uh	r8,r12[0x4]
800056ec:	00 00       	add	r0,r0
800056ee:	10 a0       	st.w	r8++,r0
800056f0:	80 01       	ld.sh	r1,r0[0x0]
800056f2:	98 54       	ld.sh	r4,r12[0xa]
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	56 fc       	stdsp	sp[0x1bc],r12
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	9f 7c       	st.w	pc[0x1c],r12

800056fc <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800056fc:	d4 31       	pushm	r0-r7,lr
800056fe:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80005700:	4b 16       	lddpc	r6,800057c4 <xcmp_rx_process+0xc8>
80005702:	30 05       	mov	r5,0
80005704:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80005706:	4b 13       	lddpc	r3,800057c8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005708:	4b 12       	lddpc	r2,800057cc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000570a:	4b 21       	lddpc	r1,800057d0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000570c:	4b 20       	lddpc	r0,800057d4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
8000570e:	6c 0c       	ld.w	r12,r6[0x0]
80005710:	0a 99       	mov	r9,r5
80005712:	08 9a       	mov	r10,r4
80005714:	1a 9b       	mov	r11,sp
80005716:	f0 1f 00 31 	mcall	800057d8 <xcmp_rx_process+0xdc>
8000571a:	58 1c       	cp.w	r12,1
8000571c:	cf 91       	brne	8000570e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000571e:	40 0b       	lddsp	r11,sp[0x0]
80005720:	58 0b       	cp.w	r11,0
80005722:	cf 60       	breq	8000570e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80005724:	96 0a       	ld.sh	r10,r11[0x0]
80005726:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000572a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000572e:	59 c8       	cp.w	r8,28
80005730:	c1 e0       	breq	8000576c <xcmp_rx_process+0x70>
80005732:	e0 89 00 07 	brgt	80005740 <xcmp_rx_process+0x44>
80005736:	58 e8       	cp.w	r8,14
80005738:	c0 e0       	breq	80005754 <xcmp_rx_process+0x58>
8000573a:	58 f8       	cp.w	r8,15
8000573c:	c2 41       	brne	80005784 <xcmp_rx_process+0x88>
8000573e:	c0 f8       	rjmp	8000575c <xcmp_rx_process+0x60>
80005740:	e0 48 01 09 	cp.w	r8,265
80005744:	c1 80       	breq	80005774 <xcmp_rx_process+0x78>
80005746:	e0 48 01 0a 	cp.w	r8,266
8000574a:	c1 90       	breq	8000577c <xcmp_rx_process+0x80>
8000574c:	e0 48 00 2c 	cp.w	r8,44
80005750:	c1 a1       	brne	80005784 <xcmp_rx_process+0x88>
80005752:	c0 98       	rjmp	80005764 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80005754:	4a 2c       	lddpc	r12,800057dc <xcmp_rx_process+0xe0>
80005756:	f0 1f 00 23 	mcall	800057e0 <xcmp_rx_process+0xe4>
					break;
8000575a:	c2 f8       	rjmp	800057b8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000575c:	4a 2c       	lddpc	r12,800057e4 <xcmp_rx_process+0xe8>
8000575e:	f0 1f 00 21 	mcall	800057e0 <xcmp_rx_process+0xe4>
					break;
80005762:	c2 b8       	rjmp	800057b8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80005764:	4a 1c       	lddpc	r12,800057e8 <xcmp_rx_process+0xec>
80005766:	f0 1f 00 1f 	mcall	800057e0 <xcmp_rx_process+0xe4>
					break;
8000576a:	c2 78       	rjmp	800057b8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000576c:	04 9c       	mov	r12,r2
8000576e:	f0 1f 00 1d 	mcall	800057e0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80005772:	c2 38       	rjmp	800057b8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80005774:	02 9c       	mov	r12,r1
80005776:	f0 1f 00 1b 	mcall	800057e0 <xcmp_rx_process+0xe4>
					break;
8000577a:	c1 f8       	rjmp	800057b8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000577c:	00 9c       	mov	r12,r0
8000577e:	f0 1f 00 19 	mcall	800057e0 <xcmp_rx_process+0xe4>
					break;
80005782:	c1 b8       	rjmp	800057b8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80005784:	12 98       	mov	r8,r9
80005786:	e2 18 04 00 	andl	r8,0x400,COH
8000578a:	c0 70       	breq	80005798 <xcmp_rx_process+0x9c>
8000578c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80005790:	e0 48 00 68 	cp.w	r8,104
80005794:	e0 8a 00 08 	brle	800057a4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80005798:	e2 19 f0 00 	andl	r9,0xf000,COH
8000579c:	c0 e1       	brne	800057b8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000579e:	f0 1f 00 14 	mcall	800057ec <xcmp_rx_process+0xf0>
800057a2:	c0 b8       	rjmp	800057b8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800057a4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800057a8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800057ac:	49 19       	lddpc	r9,800057f0 <xcmp_rx_process+0xf4>
800057ae:	72 08       	ld.w	r8,r9[0x0]
800057b0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800057b4:	f0 1f 00 0b 	mcall	800057e0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800057b8:	66 0c       	ld.w	r12,r3[0x0]
800057ba:	40 0b       	lddsp	r11,sp[0x0]
800057bc:	f0 1f 00 0e 	mcall	800057f4 <xcmp_rx_process+0xf8>
800057c0:	ca 7b       	rjmp	8000570e <xcmp_rx_process+0x12>
800057c2:	00 00       	add	r0,r0
800057c4:	00 00       	add	r0,r0
800057c6:	10 a0       	st.w	r8++,r0
800057c8:	00 00       	add	r0,r0
800057ca:	10 64       	and	r4,r8
800057cc:	00 00       	add	r0,r0
800057ce:	10 b0       	st.h	r8++,r0
800057d0:	00 00       	add	r0,r0
800057d2:	10 a4       	st.w	r8++,r4
800057d4:	00 00       	add	r0,r0
800057d6:	10 bc       	st.h	r8++,r12
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	95 44       	st.w	r10[0x10],r4
800057dc:	00 00       	add	r0,r0
800057de:	10 d4       	st.w	--r8,r4
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	56 00       	stdsp	sp[0x180],r0
800057e4:	00 00       	add	r0,r0
800057e6:	10 94       	mov	r4,r8
800057e8:	00 00       	add	r0,r0
800057ea:	10 c8       	st.b	r8++,r8
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	55 dc       	stdsp	sp[0x174],r12
800057f0:	00 00       	add	r0,r0
800057f2:	46 bc       	lddsp	r12,sp[0x1ac]
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	3c 2c       	mov	r12,-62

800057f8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800057f8:	eb cd 40 90 	pushm	r4,r7,lr
800057fc:	20 1d       	sub	sp,4
800057fe:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005802:	48 c8       	lddpc	r8,80005830 <xcmp_rx+0x38>
80005804:	70 0c       	ld.w	r12,r8[0x0]
80005806:	f0 1f 00 0c 	mcall	80005834 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000580a:	c1 00       	breq	8000582a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000580c:	fa c7 ff fc 	sub	r7,sp,-4
80005810:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80005812:	e0 6a 00 ca 	mov	r10,202
80005816:	08 9b       	mov	r11,r4
80005818:	f0 1f 00 08 	mcall	80005838 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000581c:	48 88       	lddpc	r8,8000583c <xcmp_rx+0x44>
8000581e:	70 0c       	ld.w	r12,r8[0x0]
80005820:	30 09       	mov	r9,0
80005822:	12 9a       	mov	r10,r9
80005824:	1a 9b       	mov	r11,sp
80005826:	f0 1f 00 07 	mcall	80005840 <xcmp_rx+0x48>
	}	
}
8000582a:	2f fd       	sub	sp,-4
8000582c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80005830:	00 00       	add	r0,r0
80005832:	10 64       	and	r4,r8
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	43 08       	lddsp	r8,sp[0xc0]
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	ad 06       	ld.d	r6,r6
8000583c:	00 00       	add	r0,r0
8000583e:	10 a0       	st.w	r8++,r0
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	97 50       	st.w	r11[0x14],r0

80005844 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80005844:	48 28       	lddpc	r8,8000584c <xnl_register_xcmp_func+0x8>
80005846:	91 0c       	st.w	r8[0x0],r12
}
80005848:	5e fc       	retal	r12
8000584a:	00 00       	add	r0,r0
8000584c:	00 00       	add	r0,r0
8000584e:	11 04       	ld.w	r4,r8++

80005850 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005850:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80005852:	48 88       	lddpc	r8,80005870 <xnl_get_msg_ack_func+0x20>
80005854:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80005856:	98 49       	ld.sh	r9,r12[0x8]
80005858:	f0 09 19 00 	cp.h	r9,r8
8000585c:	c0 81       	brne	8000586c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000585e:	48 68       	lddpc	r8,80005874 <xnl_get_msg_ack_func+0x24>
80005860:	70 0c       	ld.w	r12,r8[0x0]
80005862:	30 09       	mov	r9,0
80005864:	12 9a       	mov	r10,r9
80005866:	12 9b       	mov	r11,r9
80005868:	f0 1f 00 04 	mcall	80005878 <xnl_get_msg_ack_func+0x28>
8000586c:	d8 02       	popm	pc
8000586e:	00 00       	add	r0,r0
80005870:	00 00       	add	r0,r0
80005872:	10 e4       	st.h	--r8,r4
80005874:	00 00       	add	r0,r0
80005876:	10 e0       	st.h	--r8,r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	97 50       	st.w	r11[0x14],r0

8000587c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000587c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000587e:	4a 86       	lddpc	r6,8000591c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005880:	4a 82       	lddpc	r2,80005920 <xnl_tx_process+0xa4>
80005882:	4a 94       	lddpc	r4,80005924 <xnl_tx_process+0xa8>
80005884:	30 07       	mov	r7,0
80005886:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005888:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000588a:	4a 85       	lddpc	r5,80005928 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000588c:	4a 83       	lddpc	r3,8000592c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000588e:	6c 08       	ld.w	r8,r6[0x0]
80005890:	58 08       	cp.w	r8,0
80005892:	c0 40       	breq	8000589a <xnl_tx_process+0x1e>
80005894:	58 18       	cp.w	r8,1
80005896:	cf d1       	brne	80005890 <xnl_tx_process+0x14>
80005898:	c2 08       	rjmp	800058d8 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000589a:	64 0c       	ld.w	r12,r2[0x0]
8000589c:	0e 99       	mov	r9,r7
8000589e:	02 9a       	mov	r10,r1
800058a0:	08 9b       	mov	r11,r4
800058a2:	f0 1f 00 24 	mcall	80005930 <xnl_tx_process+0xb4>
800058a6:	58 1c       	cp.w	r12,1
800058a8:	cf 31       	brne	8000588e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800058aa:	68 0c       	ld.w	r12,r4[0x0]
800058ac:	58 0c       	cp.w	r12,0
800058ae:	cf 00       	breq	8000588e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800058b0:	98 28       	ld.sh	r8,r12[0x4]
800058b2:	e0 08 19 00 	cp.h	r8,r0
800058b6:	c0 41       	brne	800058be <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800058b8:	f0 1f 00 1f 	mcall	80005934 <xnl_tx_process+0xb8>
						break;
800058bc:	ce 9b       	rjmp	8000588e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800058be:	f0 1f 00 1f 	mcall	80005938 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800058c2:	30 18       	mov	r8,1
800058c4:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800058c6:	66 0c       	ld.w	r12,r3[0x0]
800058c8:	0e 99       	mov	r9,r7
800058ca:	0e 9a       	mov	r10,r7
800058cc:	0e 9b       	mov	r11,r7
800058ce:	f0 1f 00 19 	mcall	80005930 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800058d2:	30 18       	mov	r8,1
800058d4:	8d 08       	st.w	r6[0x0],r8
800058d6:	cd cb       	rjmp	8000588e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800058d8:	66 0c       	ld.w	r12,r3[0x0]
800058da:	0e 99       	mov	r9,r7
800058dc:	36 4a       	mov	r10,100
800058de:	0e 9b       	mov	r11,r7
800058e0:	f0 1f 00 14 	mcall	80005930 <xnl_tx_process+0xb4>
800058e4:	58 1c       	cp.w	r12,1
800058e6:	c0 81       	brne	800058f6 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800058e8:	49 58       	lddpc	r8,8000593c <xnl_tx_process+0xc0>
800058ea:	70 0c       	ld.w	r12,r8[0x0]
800058ec:	68 0b       	ld.w	r11,r4[0x0]
800058ee:	f0 1f 00 15 	mcall	80005940 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800058f2:	8d 07       	st.w	r6[0x0],r7
800058f4:	cc db       	rjmp	8000588e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800058f6:	6a 08       	ld.w	r8,r5[0x0]
800058f8:	58 38       	cp.w	r8,3
800058fa:	e0 89 00 09 	brgt	8000590c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800058fe:	68 0c       	ld.w	r12,r4[0x0]
80005900:	f0 1f 00 0e 	mcall	80005938 <xnl_tx_process+0xbc>
						xnl_send_times++;
80005904:	6a 08       	ld.w	r8,r5[0x0]
80005906:	2f f8       	sub	r8,-1
80005908:	8b 08       	st.w	r5[0x0],r8
8000590a:	cc 2b       	rjmp	8000588e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000590c:	48 c8       	lddpc	r8,8000593c <xnl_tx_process+0xc0>
8000590e:	70 0c       	ld.w	r12,r8[0x0]
80005910:	68 0b       	ld.w	r11,r4[0x0]
80005912:	f0 1f 00 0c 	mcall	80005940 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80005916:	8d 07       	st.w	r6[0x0],r7
80005918:	cb bb       	rjmp	8000588e <xnl_tx_process+0x12>
8000591a:	00 00       	add	r0,r0
8000591c:	00 00       	add	r0,r0
8000591e:	11 00       	ld.w	r0,r8++
80005920:	00 00       	add	r0,r0
80005922:	10 f4       	st.b	--r8,r4
80005924:	00 00       	add	r0,r0
80005926:	10 f8       	st.b	--r8,r8
80005928:	00 00       	add	r0,r0
8000592a:	10 f0       	st.b	--r8,r0
8000592c:	00 00       	add	r0,r0
8000592e:	10 e0       	st.h	--r8,r0
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	95 44       	st.w	r10[0x10],r4
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	93 d4       	st.w	r9[0x34],r4
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	3c 4c       	mov	r12,-60
8000593c:	00 00       	add	r0,r0
8000593e:	10 64       	and	r4,r8
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	3c 2c       	mov	r12,-62

80005944 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80005944:	eb cd 40 fe 	pushm	r1-r7,lr
80005948:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000594a:	49 26       	lddpc	r6,80005990 <xnl_rx_process+0x4c>
8000594c:	30 05       	mov	r5,0
8000594e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005950:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80005952:	49 11       	lddpc	r1,80005994 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80005954:	49 12       	lddpc	r2,80005998 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005956:	6c 0c       	ld.w	r12,r6[0x0]
80005958:	0a 99       	mov	r9,r5
8000595a:	08 9a       	mov	r10,r4
8000595c:	1a 9b       	mov	r11,sp
8000595e:	f0 1f 00 10 	mcall	8000599c <xnl_rx_process+0x58>
80005962:	58 1c       	cp.w	r12,1
80005964:	cf 91       	brne	80005956 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80005966:	40 0c       	lddsp	r12,sp[0x0]
80005968:	58 0c       	cp.w	r12,0
8000596a:	cf 60       	breq	80005956 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000596c:	98 28       	ld.sh	r8,r12[0x4]
8000596e:	e6 08 19 00 	cp.h	r8,r3
80005972:	e0 8b 00 0a 	brhi	80005986 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80005976:	5c 78       	castu.h	r8
80005978:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000597c:	58 09       	cp.w	r9,0
8000597e:	c0 40       	breq	80005986 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80005980:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80005984:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80005986:	62 0c       	ld.w	r12,r1[0x0]
80005988:	40 0b       	lddsp	r11,sp[0x0]
8000598a:	f0 1f 00 06 	mcall	800059a0 <xnl_rx_process+0x5c>
8000598e:	ce 4b       	rjmp	80005956 <xnl_rx_process+0x12>
80005990:	00 00       	add	r0,r0
80005992:	10 68       	and	r8,r8
80005994:	00 00       	add	r0,r0
80005996:	10 64       	and	r4,r8
80005998:	00 00       	add	r0,r0
8000599a:	04 fc       	st.b	--r2,r12
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	95 44       	st.w	r10[0x10],r4
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	3c 2c       	mov	r12,-62

800059a4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800059a4:	eb cd 40 c0 	pushm	r6-r7,lr
800059a8:	20 1d       	sub	sp,4
800059aa:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800059ac:	98 39       	ld.sh	r9,r12[0x6]
800059ae:	3f f8       	mov	r8,-1
800059b0:	f0 09 19 00 	cp.h	r9,r8
800059b4:	c0 a1       	brne	800059c8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800059b6:	4a e9       	lddpc	r9,80005a6c <xnl_tx+0xc8>
800059b8:	13 88       	ld.ub	r8,r9[0x0]
800059ba:	2f f8       	sub	r8,-1
800059bc:	5c 58       	castu.b	r8
800059be:	b2 88       	st.b	r9[0x0],r8
800059c0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800059c4:	a9 a8       	sbr	r8,0x8
800059c6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800059c8:	8c 49       	ld.sh	r9,r6[0x8]
800059ca:	3f f8       	mov	r8,-1
800059cc:	f0 09 19 00 	cp.h	r9,r8
800059d0:	c0 41       	brne	800059d8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800059d2:	4a 88       	lddpc	r8,80005a70 <xnl_tx+0xcc>
800059d4:	90 18       	ld.sh	r8,r8[0x2]
800059d6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800059d8:	8c 59       	ld.sh	r9,r6[0xa]
800059da:	3f f8       	mov	r8,-1
800059dc:	f0 09 19 00 	cp.h	r9,r8
800059e0:	c0 41       	brne	800059e8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800059e2:	4a 48       	lddpc	r8,80005a70 <xnl_tx+0xcc>
800059e4:	90 28       	ld.sh	r8,r8[0x4]
800059e6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800059e8:	8c 69       	ld.sh	r9,r6[0xc]
800059ea:	3f f8       	mov	r8,-1
800059ec:	f0 09 19 00 	cp.h	r9,r8
800059f0:	c0 e1       	brne	80005a0c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800059f2:	4a 08       	lddpc	r8,80005a70 <xnl_tx+0xcc>
800059f4:	90 49       	ld.sh	r9,r8[0x8]
800059f6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800059f8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800059fa:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800059fc:	90 49       	ld.sh	r9,r8[0x8]
800059fe:	e0 19 ff 00 	andl	r9,0xff00
80005a02:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80005a06:	f3 e8 10 08 	or	r8,r9,r8
80005a0a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80005a0c:	0d 98       	ld.ub	r8,r6[0x1]
80005a0e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80005a10:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005a14:	10 0c       	add	r12,r8
80005a16:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005a18:	58 0c       	cp.w	r12,0
80005a1a:	e0 89 00 04 	brgt	80005a22 <xnl_tx+0x7e>
80005a1e:	30 09       	mov	r9,0
80005a20:	c0 d8       	rjmp	80005a3a <xnl_tx+0x96>
80005a22:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80005a26:	2f ec       	sub	r12,-2
80005a28:	30 09       	mov	r9,0
80005a2a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80005a2c:	15 1b       	ld.sh	r11,r10++
80005a2e:	f6 09 00 09 	add	r9,r11,r9
80005a32:	5c 89       	casts.h	r9
		indextohWord     += 1;
80005a34:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005a36:	18 38       	cp.w	r8,r12
80005a38:	cf a1       	brne	80005a2c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80005a3a:	5c 39       	neg	r9
80005a3c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005a3e:	48 e8       	lddpc	r8,80005a74 <xnl_tx+0xd0>
80005a40:	70 0c       	ld.w	r12,r8[0x0]
80005a42:	f0 1f 00 0e 	mcall	80005a78 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80005a46:	c1 00       	breq	80005a66 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005a48:	fa c7 ff fc 	sub	r7,sp,-4
80005a4c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80005a4e:	e0 6a 01 00 	mov	r10,256
80005a52:	0c 9b       	mov	r11,r6
80005a54:	f0 1f 00 0a 	mcall	80005a7c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80005a58:	48 a8       	lddpc	r8,80005a80 <xnl_tx+0xdc>
80005a5a:	70 0c       	ld.w	r12,r8[0x0]
80005a5c:	30 09       	mov	r9,0
80005a5e:	12 9a       	mov	r10,r9
80005a60:	1a 9b       	mov	r11,sp
80005a62:	f0 1f 00 09 	mcall	80005a84 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80005a66:	2f fd       	sub	sp,-4
80005a68:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a6c:	00 00       	add	r0,r0
80005a6e:	10 fc       	st.b	--r8,r12
80005a70:	00 00       	add	r0,r0
80005a72:	10 e4       	st.h	--r8,r4
80005a74:	00 00       	add	r0,r0
80005a76:	10 64       	and	r4,r8
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	43 08       	lddsp	r8,sp[0xc0]
80005a7c:	80 00       	ld.sh	r0,r0[0x0]
80005a7e:	ad 06       	ld.d	r6,r6
80005a80:	00 00       	add	r0,r0
80005a82:	10 f4       	st.b	--r8,r4
80005a84:	80 00       	ld.sh	r0,r0[0x0]
80005a86:	97 50       	st.w	r11[0x14],r0

80005a88 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80005a88:	eb cd 40 80 	pushm	r7,lr
80005a8c:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80005a90:	f0 1f 00 27 	mcall	80005b2c <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80005a94:	30 09       	mov	r9,0
80005a96:	4a 78       	lddpc	r8,80005b30 <xnl_init+0xa8>
80005a98:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80005a9a:	30 0b       	mov	r11,0
80005a9c:	30 1c       	mov	r12,1
80005a9e:	f0 1f 00 26 	mcall	80005b34 <xnl_init+0xac>
80005aa2:	4a 68       	lddpc	r8,80005b38 <xnl_init+0xb0>
80005aa4:	91 0c       	st.w	r8[0x0],r12
80005aa6:	70 08       	ld.w	r8,r8[0x0]
80005aa8:	58 08       	cp.w	r8,0
80005aaa:	c0 80       	breq	80005aba <xnl_init+0x32>
80005aac:	4a 38       	lddpc	r8,80005b38 <xnl_init+0xb0>
80005aae:	70 0c       	ld.w	r12,r8[0x0]
80005ab0:	30 09       	mov	r9,0
80005ab2:	12 9a       	mov	r10,r9
80005ab4:	12 9b       	mov	r11,r9
80005ab6:	f0 1f 00 22 	mcall	80005b3c <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80005aba:	30 4b       	mov	r11,4
80005abc:	31 4c       	mov	r12,20
80005abe:	f0 1f 00 1e 	mcall	80005b34 <xnl_init+0xac>
80005ac2:	4a 08       	lddpc	r8,80005b40 <xnl_init+0xb8>
80005ac4:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80005ac6:	30 07       	mov	r7,0
80005ac8:	1a d7       	st.w	--sp,r7
80005aca:	1a d7       	st.w	--sp,r7
80005acc:	1a d7       	st.w	--sp,r7
80005ace:	30 38       	mov	r8,3
80005ad0:	0e 99       	mov	r9,r7
80005ad2:	e0 6a 02 00 	mov	r10,512
80005ad6:	49 cb       	lddpc	r11,80005b44 <xnl_init+0xbc>
80005ad8:	49 cc       	lddpc	r12,80005b48 <xnl_init+0xc0>
80005ada:	f0 1f 00 1d 	mcall	80005b4c <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80005ade:	1a d7       	st.w	--sp,r7
80005ae0:	1a d7       	st.w	--sp,r7
80005ae2:	1a d7       	st.w	--sp,r7
80005ae4:	30 38       	mov	r8,3
80005ae6:	0e 99       	mov	r9,r7
80005ae8:	e0 6a 03 20 	mov	r10,800
80005aec:	49 9b       	lddpc	r11,80005b50 <xnl_init+0xc8>
80005aee:	49 ac       	lddpc	r12,80005b54 <xnl_init+0xcc>
80005af0:	f0 1f 00 17 	mcall	80005b4c <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005af4:	e0 68 40 0e 	mov	r8,16398
80005af8:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005afc:	3f f8       	mov	r8,-1
80005afe:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005b02:	30 38       	mov	r8,3
80005b04:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80005b08:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005b0c:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005b10:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005b14:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005b18:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005b1c:	fa cc ff e8 	sub	r12,sp,-24
80005b20:	f0 1f 00 0e 	mcall	80005b58 <xnl_init+0xd0>
80005b24:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80005b26:	2c 0d       	sub	sp,-256
80005b28:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b2c:	80 00       	ld.sh	r0,r0[0x0]
80005b2e:	43 30       	lddsp	r0,sp[0xcc]
80005b30:	00 00       	add	r0,r0
80005b32:	10 e4       	st.h	--r8,r4
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	98 a8       	ld.uh	r8,r12[0x4]
80005b38:	00 00       	add	r0,r0
80005b3a:	10 e0       	st.h	--r8,r0
80005b3c:	80 00       	ld.sh	r0,r0[0x0]
80005b3e:	97 50       	st.w	r11[0x14],r0
80005b40:	00 00       	add	r0,r0
80005b42:	10 f4       	st.b	--r8,r4
80005b44:	80 01       	ld.sh	r1,r0[0x0]
80005b46:	98 5c       	ld.sh	r12,r12[0xa]
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	59 44       	cp.w	r4,20
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	9f 7c       	st.w	pc[0x1c],r12
80005b50:	80 01       	ld.sh	r1,r0[0x0]
80005b52:	06 00       	add	r0,r3
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	58 7c       	cp.w	r12,7
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	59 a4       	cp.w	r4,26

80005b5c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005b5c:	eb cd 40 80 	pushm	r7,lr
80005b60:	fa cd 01 00 	sub	sp,sp,256
80005b64:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005b66:	e0 68 40 0e 	mov	r8,16398
80005b6a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005b6c:	3f f8       	mov	r8,-1
80005b6e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005b70:	30 c8       	mov	r8,12
80005b72:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80005b74:	98 38       	ld.sh	r8,r12[0x6]
80005b76:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005b78:	98 58       	ld.sh	r8,r12[0xa]
80005b7a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80005b7c:	98 48       	ld.sh	r8,r12[0x8]
80005b7e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005b80:	98 68       	ld.sh	r8,r12[0xc]
80005b82:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80005b84:	30 08       	mov	r8,0
80005b86:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005b88:	1a 9c       	mov	r12,sp
80005b8a:	f0 1f 00 0a 	mcall	80005bb0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80005b8e:	fa cd 00 cc 	sub	sp,sp,204
80005b92:	e0 6a 00 ca 	mov	r10,202
80005b96:	ee cb ff f0 	sub	r11,r7,-16
80005b9a:	1a 9c       	mov	r12,sp
80005b9c:	f0 1f 00 06 	mcall	80005bb4 <xnl_data_msg_func+0x58>
80005ba0:	48 68       	lddpc	r8,80005bb8 <xnl_data_msg_func+0x5c>
80005ba2:	70 08       	ld.w	r8,r8[0x0]
80005ba4:	5d 18       	icall	r8
80005ba6:	fa cd ff 34 	sub	sp,sp,-204
}
80005baa:	2c 0d       	sub	sp,-256
80005bac:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	59 a4       	cp.w	r4,26
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	ad 06       	ld.d	r6,r6
80005bb8:	00 00       	add	r0,r0
80005bba:	11 04       	ld.w	r4,r8++

80005bbc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005bbc:	d4 21       	pushm	r4-r7,lr
80005bbe:	fa cd 01 00 	sub	sp,sp,256
80005bc2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80005bc4:	4c 28       	lddpc	r8,80005ccc <xnl_device_auth_reply_func+0x110>
80005bc6:	11 88       	ld.ub	r8,r8[0x0]
80005bc8:	58 08       	cp.w	r8,0
80005bca:	e0 81 00 7f 	brne	80005cc8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80005bce:	4c 18       	lddpc	r8,80005cd0 <xnl_device_auth_reply_func+0x114>
80005bd0:	70 0c       	ld.w	r12,r8[0x0]
80005bd2:	30 09       	mov	r9,0
80005bd4:	12 9a       	mov	r10,r9
80005bd6:	12 9b       	mov	r11,r9
80005bd8:	f0 1f 00 3f 	mcall	80005cd4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80005bdc:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005be0:	4b b8       	lddpc	r8,80005ccc <xnl_device_auth_reply_func+0x110>
80005be2:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80005be4:	ef 39 00 12 	ld.ub	r9,r7[18]
80005be8:	ef 38 00 13 	ld.ub	r8,r7[19]
80005bec:	b1 68       	lsl	r8,0x10
80005bee:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80005bf2:	ef 38 00 15 	ld.ub	r8,r7[21]
80005bf6:	f3 e8 10 08 	or	r8,r9,r8
80005bfa:	ef 39 00 14 	ld.ub	r9,r7[20]
80005bfe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005c02:	ef 3a 00 16 	ld.ub	r10,r7[22]
80005c06:	ef 38 00 17 	ld.ub	r8,r7[23]
80005c0a:	b1 68       	lsl	r8,0x10
80005c0c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80005c10:	ef 38 00 19 	ld.ub	r8,r7[25]
80005c14:	f5 e8 10 08 	or	r8,r10,r8
80005c18:	ef 3a 00 18 	ld.ub	r10,r7[24]
80005c1c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005c20:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005c22:	e0 64 79 b9 	mov	r4,31161
80005c26:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005c2a:	e0 65 45 07 	mov	r5,17671
80005c2e:	ea 15 8a bd 	orh	r5,0x8abd
80005c32:	e0 66 f9 3d 	mov	r6,63805
80005c36:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005c3a:	e0 6e b8 cf 	mov	lr,47311
80005c3e:	ea 1e 36 83 	orh	lr,0x3683
80005c42:	e0 67 aa 1c 	mov	r7,43548
80005c46:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005c4a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005c4c:	f4 08 00 0c 	add	r12,r10,r8
80005c50:	f0 0b 15 04 	lsl	r11,r8,0x4
80005c54:	0a 0b       	add	r11,r5
80005c56:	f9 eb 20 0b 	eor	r11,r12,r11
80005c5a:	f0 0c 16 05 	lsr	r12,r8,0x5
80005c5e:	0c 0c       	add	r12,r6
80005c60:	18 5b       	eor	r11,r12
80005c62:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005c64:	f2 0c 15 04 	lsl	r12,r9,0x4
80005c68:	1c 0c       	add	r12,lr
80005c6a:	f2 0b 16 05 	lsr	r11,r9,0x5
80005c6e:	0e 0b       	add	r11,r7
80005c70:	f9 eb 20 0b 	eor	r11,r12,r11
80005c74:	f2 0a 00 0c 	add	r12,r9,r10
80005c78:	18 5b       	eor	r11,r12
80005c7a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005c7c:	e0 6b 37 20 	mov	r11,14112
80005c80:	ea 1b c6 ef 	orh	r11,0xc6ef
80005c84:	16 3a       	cp.w	r10,r11
80005c86:	ce 21       	brne	80005c4a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005c88:	e0 6a 40 1a 	mov	r10,16410
80005c8c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005c8e:	3f fa       	mov	r10,-1
80005c90:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005c92:	30 6b       	mov	r11,6
80005c94:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005c96:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005c98:	48 db       	lddpc	r11,80005ccc <xnl_device_auth_reply_func+0x110>
80005c9a:	96 1c       	ld.sh	r12,r11[0x2]
80005c9c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80005c9e:	96 2b       	ld.sh	r11,r11[0x4]
80005ca0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005ca2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80005ca4:	30 ca       	mov	r10,12
80005ca6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80005ca8:	30 0a       	mov	r10,0
80005caa:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80005cae:	30 7a       	mov	r10,7
80005cb0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80005cb4:	30 2a       	mov	r10,2
80005cb6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005cba:	fa ca ff ec 	sub	r10,sp,-20
80005cbe:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005cc0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005cc2:	1a 9c       	mov	r12,sp
80005cc4:	f0 1f 00 05 	mcall	80005cd8 <xnl_device_auth_reply_func+0x11c>
}
80005cc8:	2c 0d       	sub	sp,-256
80005cca:	d8 22       	popm	r4-r7,pc
80005ccc:	00 00       	add	r0,r0
80005cce:	10 e4       	st.h	--r8,r4
80005cd0:	00 00       	add	r0,r0
80005cd2:	10 e0       	st.h	--r8,r0
80005cd4:	80 00       	ld.sh	r0,r0[0x0]
80005cd6:	97 50       	st.w	r11[0x14],r0
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	59 a4       	cp.w	r4,26

80005cdc <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005cdc:	eb cd 40 80 	pushm	r7,lr
80005ce0:	fa cd 01 00 	sub	sp,sp,256
80005ce4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80005ce6:	49 28       	lddpc	r8,80005d2c <xnl_master_status_brdcst_func+0x50>
80005ce8:	11 88       	ld.ub	r8,r8[0x0]
80005cea:	58 08       	cp.w	r8,0
80005cec:	c1 c1       	brne	80005d24 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80005cee:	49 18       	lddpc	r8,80005d30 <xnl_master_status_brdcst_func+0x54>
80005cf0:	70 0c       	ld.w	r12,r8[0x0]
80005cf2:	30 09       	mov	r9,0
80005cf4:	12 9a       	mov	r10,r9
80005cf6:	12 9b       	mov	r11,r9
80005cf8:	f0 1f 00 0f 	mcall	80005d34 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005cfc:	8e 58       	ld.sh	r8,r7[0xa]
80005cfe:	48 c9       	lddpc	r9,80005d2c <xnl_master_status_brdcst_func+0x50>
80005d00:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005d02:	e0 68 40 0e 	mov	r8,16398
80005d06:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005d08:	3f f8       	mov	r8,-1
80005d0a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005d0c:	30 4a       	mov	r10,4
80005d0e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005d10:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005d12:	92 19       	ld.sh	r9,r9[0x2]
80005d14:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80005d16:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005d18:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80005d1a:	30 08       	mov	r8,0
80005d1c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80005d1e:	1a 9c       	mov	r12,sp
80005d20:	f0 1f 00 06 	mcall	80005d38 <xnl_master_status_brdcst_func+0x5c>
}
80005d24:	2c 0d       	sub	sp,-256
80005d26:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d2a:	00 00       	add	r0,r0
80005d2c:	00 00       	add	r0,r0
80005d2e:	10 e4       	st.h	--r8,r4
80005d30:	00 00       	add	r0,r0
80005d32:	10 e0       	st.h	--r8,r0
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	97 50       	st.w	r11[0x14],r0
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	59 a4       	cp.w	r4,26

80005d3c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005d3c:	eb cd 40 80 	pushm	r7,lr
80005d40:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005d42:	49 38       	lddpc	r8,80005d8c <xnl_device_conn_reply_func+0x50>
80005d44:	70 0c       	ld.w	r12,r8[0x0]
80005d46:	30 09       	mov	r9,0
80005d48:	12 9a       	mov	r10,r9
80005d4a:	12 9b       	mov	r11,r9
80005d4c:	f0 1f 00 11 	mcall	80005d90 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005d50:	ef 18 00 10 	ld.uh	r8,r7[16]
80005d54:	10 99       	mov	r9,r8
80005d56:	e2 19 ff 00 	andl	r9,0xff00,COH
80005d5a:	e0 49 01 00 	cp.w	r9,256
80005d5e:	c0 60       	breq	80005d6a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005d60:	0e 9c       	mov	r12,r7
80005d62:	f0 1f 00 0d 	mcall	80005d94 <xnl_device_conn_reply_func+0x58>
80005d66:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005d6a:	a9 68       	lsl	r8,0x8
80005d6c:	48 b9       	lddpc	r9,80005d98 <xnl_device_conn_reply_func+0x5c>
80005d6e:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005d70:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005d74:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80005d76:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80005d7a:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005d7c:	30 18       	mov	r8,1
80005d7e:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005d80:	48 7c       	lddpc	r12,80005d9c <xnl_device_conn_reply_func+0x60>
80005d82:	f0 1f 00 08 	mcall	80005da0 <xnl_device_conn_reply_func+0x64>
80005d86:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d8a:	00 00       	add	r0,r0
80005d8c:	00 00       	add	r0,r0
80005d8e:	10 e0       	st.h	--r8,r0
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	97 50       	st.w	r11[0x14],r0
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	5c dc       	com	r12
80005d98:	00 00       	add	r0,r0
80005d9a:	10 e4       	st.h	--r8,r4
80005d9c:	80 01       	ld.sh	r1,r0[0x0]
80005d9e:	98 64       	ld.sh	r4,r12[0xc]
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	a3 40       	asr	r0,0x2

80005da4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80005da4:	fe 78 0c 00 	mov	r8,-62464
80005da8:	e0 69 03 07 	mov	r9,775
80005dac:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005dae:	30 49       	mov	r9,4
80005db0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005db2:	71 59       	ld.w	r9,r8[0x54]
80005db4:	e2 19 00 80 	andl	r9,0x80,COH
80005db8:	cf d0       	breq	80005db2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005dba:	fe 78 0c 00 	mov	r8,-62464
80005dbe:	30 59       	mov	r9,5
80005dc0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80005dc2:	e0 69 01 0d 	mov	r9,269
80005dc6:	ea 19 10 07 	orh	r9,0x1007
80005dca:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005dcc:	71 59       	ld.w	r9,r8[0x54]
80005dce:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005dd2:	cf d0       	breq	80005dcc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005dd4:	fe 78 0c 00 	mov	r8,-62464
80005dd8:	fc 19 00 80 	movh	r9,0x80
80005ddc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005dde:	34 0a       	mov	r10,64
80005de0:	fe 69 14 00 	mov	r9,-125952
80005de4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80005de6:	30 69       	mov	r9,6
80005de8:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005dea:	30 19       	mov	r9,1
80005dec:	fe 68 10 00 	mov	r8,-126976
80005df0:	91 19       	st.w	r8[0x4],r9
}
80005df2:	5e fc       	retal	r12

80005df4 <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
80005df4:	fe 78 2c 00 	mov	r8,-54272
80005df8:	32 49       	mov	r9,36
80005dfa:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
80005dfc:	e0 69 11 00 	mov	r9,4352
80005e00:	ea 19 00 51 	orh	r9,0x51
80005e04:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
80005e06:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
80005e08:	30 39       	mov	r9,3
80005e0a:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
80005e0c:	70 8c       	ld.w	r12,r8[0x20]
80005e0e:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
80005e12:	cf d0       	breq	80005e0c <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
80005e14:	18 98       	mov	r8,r12
80005e16:	e2 18 01 00 	andl	r8,0x100,COH
80005e1a:	c0 51       	brne	80005e24 <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
80005e1c:	fe 78 2c 00 	mov	r8,-54272
80005e20:	70 c8       	ld.w	r8,r8[0x30]
80005e22:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
80005e24:	fe 78 2c 00 	mov	r8,-54272
80005e28:	70 89       	ld.w	r9,r8[0x20]
80005e2a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005e2e:	cf d0       	breq	80005e28 <read_a_byte+0x34>
	return (TWI_Status);
}
80005e30:	5e fc       	retal	r12
80005e32:	d7 03       	nop

80005e34 <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
80005e34:	eb cd 40 e0 	pushm	r5-r7,lr
80005e38:	20 2d       	sub	sp,8
80005e3a:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
80005e3c:	4c 28       	lddpc	r8,80005f44 <rtc_read_time+0x110>
80005e3e:	70 08       	ld.w	r8,r8[0x0]
80005e40:	58 08       	cp.w	r8,0
80005e42:	c0 31       	brne	80005e48 <rtc_read_time+0x14>
80005e44:	30 3c       	mov	r12,3
80005e46:	c7 b8       	rjmp	80005f3c <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005e48:	4b f6       	lddpc	r6,80005f44 <rtc_read_time+0x110>
80005e4a:	6c 0c       	ld.w	r12,r6[0x0]
80005e4c:	30 09       	mov	r9,0
80005e4e:	3f fa       	mov	r10,-1
80005e50:	12 9b       	mov	r11,r9
80005e52:	f0 1f 00 3e 	mcall	80005f48 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
80005e56:	1a 9b       	mov	r11,sp
80005e58:	30 2c       	mov	r12,2
80005e5a:	f0 1f 00 3d 	mcall	80005f4c <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005e5e:	1b 88       	ld.ub	r8,sp[0x0]
80005e60:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005e64:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005e68:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005e6c:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005e70:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
80005e72:	fa cb ff ff 	sub	r11,sp,-1
80005e76:	30 3c       	mov	r12,3
80005e78:	f0 1f 00 35 	mcall	80005f4c <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005e7c:	1b 98       	ld.ub	r8,sp[0x1]
80005e7e:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005e82:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005e86:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005e8a:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005e8e:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005e90:	fa cb ff fe 	sub	r11,sp,-2
80005e94:	30 4c       	mov	r12,4
80005e96:	f0 1f 00 2e 	mcall	80005f4c <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
80005e9a:	1b a8       	ld.ub	r8,sp[0x2]
80005e9c:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005ea0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ea4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ea8:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005eac:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
80005eae:	fa cb ff fd 	sub	r11,sp,-3
80005eb2:	30 5c       	mov	r12,5
80005eb4:	f0 1f 00 26 	mcall	80005f4c <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
80005eb8:	1b b8       	ld.ub	r8,sp[0x3]
80005eba:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005ebe:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ec2:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ec6:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005eca:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
80005ecc:	fa cb ff fc 	sub	r11,sp,-4
80005ed0:	30 6c       	mov	r12,6
80005ed2:	f0 1f 00 1f 	mcall	80005f4c <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
80005ed6:	1b c8       	ld.ub	r8,sp[0x4]
80005ed8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005edc:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
80005ede:	fa cb ff fb 	sub	r11,sp,-5
80005ee2:	30 7c       	mov	r12,7
80005ee4:	f0 1f 00 1a 	mcall	80005f4c <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
80005ee8:	1b d8       	ld.ub	r8,sp[0x5]
80005eea:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80005eee:	f2 0a 15 02 	lsl	r10,r9,0x2
80005ef2:	14 09       	add	r9,r10
80005ef4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ef8:	f0 09 00 18 	add	r8,r8,r9<<0x1
80005efc:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
80005efe:	fa cb ff fa 	sub	r11,sp,-6
80005f02:	30 8c       	mov	r12,8
80005f04:	f0 1f 00 12 	mcall	80005f4c <rtc_read_time+0x118>
80005f08:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
80005f0a:	1b e9       	ld.ub	r9,sp[0x6]
80005f0c:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80005f10:	f0 c8 f8 30 	sub	r8,r8,-2000
80005f14:	a5 89       	lsr	r9,0x4
80005f16:	f2 09 10 0a 	mul	r9,r9,10
80005f1a:	12 08       	add	r8,r9
80005f1c:	5c 78       	castu.h	r8
80005f1e:	30 0b       	mov	r11,0
80005f20:	f0 09 16 08 	lsr	r9,r8,0x8
80005f24:	ae 89       	st.b	r7[0x0],r9
80005f26:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
80005f28:	6c 0c       	ld.w	r12,r6[0x0]
80005f2a:	16 99       	mov	r9,r11
80005f2c:	16 9a       	mov	r10,r11
80005f2e:	f0 1f 00 09 	mcall	80005f50 <rtc_read_time+0x11c>
		
	if(res)
80005f32:	58 05       	cp.w	r5,0
80005f34:	f9 bc 01 00 	movne	r12,0
80005f38:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005f3c:	2f ed       	sub	sp,-8
80005f3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005f42:	00 00       	add	r0,r0
80005f44:	00 00       	add	r0,r0
80005f46:	11 14       	ld.sh	r4,r8++
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	95 44       	st.w	r10[0x10],r4
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	5d f4       	*unknown*
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	97 50       	st.w	r11[0x14],r0

80005f54 <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
80005f54:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005f58:	48 47       	lddpc	r7,80005f68 <getTime+0x14>
80005f5a:	0e 9c       	mov	r12,r7
80005f5c:	f0 1f 00 04 	mcall	80005f6c <getTime+0x18>
	return &date_time;
80005f60:	0e 9c       	mov	r12,r7
80005f62:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f66:	00 00       	add	r0,r0
80005f68:	00 00       	add	r0,r0
80005f6a:	11 0c       	ld.w	r12,r8++
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	5e 34       	retlo	r4

80005f70 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005f70:	eb cd 40 c0 	pushm	r6-r7,lr
80005f74:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80005f76:	f0 1f 00 1a 	mcall	80005fdc <rtc_init+0x6c>
80005f7a:	49 a8       	lddpc	r8,80005fe0 <rtc_init+0x70>
80005f7c:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005f7e:	70 08       	ld.w	r8,r8[0x0]
80005f80:	58 08       	cp.w	r8,0
80005f82:	c0 31       	brne	80005f88 <rtc_init+0x18>
80005f84:	30 3c       	mov	r12,3
80005f86:	c2 78       	rjmp	80005fd4 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005f88:	49 66       	lddpc	r6,80005fe0 <rtc_init+0x70>
80005f8a:	6c 0c       	ld.w	r12,r6[0x0]
80005f8c:	30 09       	mov	r9,0
80005f8e:	3f fa       	mov	r10,-1
80005f90:	12 9b       	mov	r11,r9
80005f92:	f0 1f 00 15 	mcall	80005fe4 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80005f96:	30 2b       	mov	r11,2
80005f98:	49 4c       	lddpc	r12,80005fe8 <rtc_init+0x78>
80005f9a:	f0 1f 00 15 	mcall	80005fec <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80005f9e:	e0 68 36 00 	mov	r8,13824
80005fa2:	ea 18 01 6e 	orh	r8,0x16e
80005fa6:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80005fa8:	e2 78 0d 40 	mov	r8,200000
80005fac:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80005fae:	35 18       	mov	r8,81
80005fb0:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80005fb4:	1a 9b       	mov	r11,sp
80005fb6:	fe 7c 2c 00 	mov	r12,-54272
80005fba:	f0 1f 00 0e 	mcall	80005ff0 <rtc_init+0x80>
80005fbe:	48 e7       	lddpc	r7,80005ff4 <rtc_init+0x84>
80005fc0:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80005fc2:	6c 0c       	ld.w	r12,r6[0x0]
80005fc4:	30 09       	mov	r9,0
80005fc6:	12 9a       	mov	r10,r9
80005fc8:	12 9b       	mov	r11,r9
80005fca:	f0 1f 00 0c 	mcall	80005ff8 <rtc_init+0x88>
80005fce:	6e 08       	ld.w	r8,r7[0x0]
80005fd0:	58 08       	cp.w	r8,0
80005fd2:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80005fd4:	2f dd       	sub	sp,-12
80005fd6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fda:	00 00       	add	r0,r0
80005fdc:	80 00       	ld.sh	r0,r0[0x0]
80005fde:	98 50       	ld.sh	r0,r12[0xa]
80005fe0:	00 00       	add	r0,r0
80005fe2:	11 14       	ld.sh	r4,r8++
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	95 44       	st.w	r10[0x10],r4
80005fe8:	80 01       	ld.sh	r1,r0[0x0]
80005fea:	98 78       	ld.sh	r8,r12[0xe]
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	a7 e0       	*unknown*
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	66 5c       	ld.w	r12,r3[0x14]
80005ff4:	00 00       	add	r0,r0
80005ff6:	11 08       	ld.w	r8,r8++
80005ff8:	80 00       	ld.sh	r0,r0[0x0]
80005ffa:	97 50       	st.w	r11[0x14],r0

80005ffc <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005ffc:	fe 78 10 00 	mov	r8,-61440
80006000:	fc 19 00 10 	movh	r9,0x10
80006004:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80006006:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80006008:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000600a:	30 39       	mov	r9,3
8000600c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80006010:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80006014:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80006018:	fe 78 38 00 	mov	r8,-51200
8000601c:	30 49       	mov	r9,4
8000601e:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80006022:	e0 69 91 0d 	mov	r9,37133
80006026:	ea 19 00 52 	orh	r9,0x52
8000602a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000602c:	32 09       	mov	r9,32
8000602e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80006030:	30 59       	mov	r9,5
80006032:	91 09       	st.w	r8[0x0],r9
}
80006034:	5e fc       	retal	r12
80006036:	d7 03       	nop

80006038 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80006038:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
8000603a:	30 2a       	mov	r10,2
8000603c:	e0 6b 01 c1 	mov	r11,449
80006040:	48 ec       	lddpc	r12,80006078 <tc_init+0x40>
80006042:	f0 1f 00 0f 	mcall	8000607c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80006046:	48 fb       	lddpc	r11,80006080 <tc_init+0x48>
80006048:	fe 7c 38 00 	mov	r12,-51200
8000604c:	f0 1f 00 0e 	mcall	80006084 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80006050:	e0 6a 75 30 	mov	r10,30000
80006054:	30 1b       	mov	r11,1
80006056:	fe 7c 38 00 	mov	r12,-51200
8000605a:	f0 1f 00 0c 	mcall	80006088 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
8000605e:	48 ca       	lddpc	r10,8000608c <tc_init+0x54>
80006060:	30 1b       	mov	r11,1
80006062:	fe 7c 38 00 	mov	r12,-51200
80006066:	f0 1f 00 0b 	mcall	80006090 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
8000606a:	30 1b       	mov	r11,1
8000606c:	fe 7c 38 00 	mov	r12,-51200
80006070:	f0 1f 00 09 	mcall	80006094 <tc_init+0x5c>
80006074:	d8 02       	popm	pc
80006076:	00 00       	add	r0,r0
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	60 98       	ld.w	r8,r0[0x24]
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	60 bc       	ld.w	r12,r0[0x2c]
80006080:	80 01       	ld.sh	r1,r0[0x0]
80006082:	98 8c       	ld.uh	r12,r12[0x0]
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	63 a2       	ld.w	r2,r1[0x68]
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	64 62       	ld.w	r2,r2[0x18]
8000608c:	80 01       	ld.sh	r1,r0[0x0]
8000608e:	98 88       	ld.uh	r8,r12[0x0]
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	64 96       	ld.w	r6,r2[0x24]
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	64 3e       	ld.w	lr,r2[0xc]

80006098 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80006098:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000609a:	48 68       	lddpc	r8,800060b0 <_tc_interrupt+0x18>
8000609c:	70 09       	ld.w	r9,r8[0x0]
8000609e:	2f f9       	sub	r9,-1
800060a0:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
800060a2:	30 1b       	mov	r11,1
800060a4:	fe 7c 38 00 	mov	r12,-51200
800060a8:	f0 1f 00 03 	mcall	800060b4 <_tc_interrupt+0x1c>
	
}
800060ac:	d4 02       	popm	lr
800060ae:	d6 03       	rete
800060b0:	00 00       	add	r0,r0
800060b2:	11 18       	ld.sh	r8,r8++
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	64 50       	ld.w	r0,r2[0x14]

800060b8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800060b8:	c0 08       	rjmp	800060b8 <_unhandled_interrupt>
800060ba:	d7 03       	nop

800060bc <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800060bc:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800060c0:	49 99       	lddpc	r9,80006124 <INTC_register_interrupt+0x68>
800060c2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800060c6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800060ca:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800060cc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800060d0:	58 0a       	cp.w	r10,0
800060d2:	c0 91       	brne	800060e4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800060d4:	49 59       	lddpc	r9,80006128 <INTC_register_interrupt+0x6c>
800060d6:	49 6a       	lddpc	r10,8000612c <INTC_register_interrupt+0x70>
800060d8:	12 1a       	sub	r10,r9
800060da:	fe 79 08 00 	mov	r9,-63488
800060de:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800060e2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800060e4:	58 1a       	cp.w	r10,1
800060e6:	c0 a1       	brne	800060fa <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800060e8:	49 09       	lddpc	r9,80006128 <INTC_register_interrupt+0x6c>
800060ea:	49 2a       	lddpc	r10,80006130 <INTC_register_interrupt+0x74>
800060ec:	12 1a       	sub	r10,r9
800060ee:	bf aa       	sbr	r10,0x1e
800060f0:	fe 79 08 00 	mov	r9,-63488
800060f4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800060f8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800060fa:	58 2a       	cp.w	r10,2
800060fc:	c0 a1       	brne	80006110 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800060fe:	48 b9       	lddpc	r9,80006128 <INTC_register_interrupt+0x6c>
80006100:	48 da       	lddpc	r10,80006134 <INTC_register_interrupt+0x78>
80006102:	12 1a       	sub	r10,r9
80006104:	bf ba       	sbr	r10,0x1f
80006106:	fe 79 08 00 	mov	r9,-63488
8000610a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000610e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006110:	48 69       	lddpc	r9,80006128 <INTC_register_interrupt+0x6c>
80006112:	48 aa       	lddpc	r10,80006138 <INTC_register_interrupt+0x7c>
80006114:	12 1a       	sub	r10,r9
80006116:	ea 1a c0 00 	orh	r10,0xc000
8000611a:	fe 79 08 00 	mov	r9,-63488
8000611e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006122:	5e fc       	retal	r12
80006124:	80 01       	ld.sh	r1,r0[0x0]
80006126:	98 94       	ld.uh	r4,r12[0x2]
80006128:	80 01       	ld.sh	r1,r0[0x0]
8000612a:	04 00       	add	r0,r2
8000612c:	80 01       	ld.sh	r1,r0[0x0]
8000612e:	05 04       	ld.w	r4,r2++
80006130:	80 01       	ld.sh	r1,r0[0x0]
80006132:	05 12       	ld.sh	r2,r2++
80006134:	80 01       	ld.sh	r1,r0[0x0]
80006136:	05 20       	ld.uh	r0,r2++
80006138:	80 01       	ld.sh	r1,r0[0x0]
8000613a:	05 2e       	ld.uh	lr,r2++

8000613c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000613c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000613e:	49 18       	lddpc	r8,80006180 <INTC_init_interrupts+0x44>
80006140:	e3 b8 00 01 	mtsr	0x4,r8
80006144:	49 0e       	lddpc	lr,80006184 <INTC_init_interrupts+0x48>
80006146:	30 07       	mov	r7,0
80006148:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000614a:	49 0c       	lddpc	r12,80006188 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000614c:	49 05       	lddpc	r5,8000618c <INTC_init_interrupts+0x50>
8000614e:	10 15       	sub	r5,r8
80006150:	fe 76 08 00 	mov	r6,-63488
80006154:	c1 08       	rjmp	80006174 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006156:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80006158:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000615a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000615c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006160:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006162:	10 3a       	cp.w	r10,r8
80006164:	fe 9b ff fc 	brhi	8000615c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006168:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000616c:	2f f7       	sub	r7,-1
8000616e:	2f 8e       	sub	lr,-8
80006170:	59 37       	cp.w	r7,19
80006172:	c0 50       	breq	8000617c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006174:	7c 08       	ld.w	r8,lr[0x0]
80006176:	58 08       	cp.w	r8,0
80006178:	ce f1       	brne	80006156 <INTC_init_interrupts+0x1a>
8000617a:	cf 7b       	rjmp	80006168 <INTC_init_interrupts+0x2c>
8000617c:	d8 22       	popm	r4-r7,pc
8000617e:	00 00       	add	r0,r0
80006180:	80 01       	ld.sh	r1,r0[0x0]
80006182:	04 00       	add	r0,r2
80006184:	80 01       	ld.sh	r1,r0[0x0]
80006186:	98 94       	ld.uh	r4,r12[0x2]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	60 b8       	ld.w	r8,r0[0x2c]
8000618c:	80 01       	ld.sh	r1,r0[0x0]
8000618e:	05 04       	ld.w	r4,r2++

80006190 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006190:	fe 78 08 00 	mov	r8,-63488
80006194:	e0 69 00 83 	mov	r9,131
80006198:	f2 0c 01 0c 	sub	r12,r9,r12
8000619c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800061a0:	f2 ca ff c0 	sub	r10,r9,-64
800061a4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800061a8:	58 08       	cp.w	r8,0
800061aa:	c0 21       	brne	800061ae <_get_interrupt_handler+0x1e>
800061ac:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800061ae:	f0 08 12 00 	clz	r8,r8
800061b2:	48 5a       	lddpc	r10,800061c4 <_get_interrupt_handler+0x34>
800061b4:	f4 09 00 39 	add	r9,r10,r9<<0x3
800061b8:	f0 08 11 1f 	rsub	r8,r8,31
800061bc:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800061be:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800061c2:	5e fc       	retal	r12
800061c4:	80 01       	ld.sh	r1,r0[0x0]
800061c6:	98 94       	ld.uh	r4,r12[0x2]

800061c8 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
800061c8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800061cc:	30 18       	mov	r8,1
800061ce:	f0 09 18 00 	cp.b	r9,r8
800061d2:	e0 88 00 04 	brls	800061da <spi_initMaster+0x12>
800061d6:	30 2c       	mov	r12,2
800061d8:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
800061da:	e0 68 00 80 	mov	r8,128
800061de:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
800061e0:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
800061e2:	30 19       	mov	r9,1
800061e4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
800061e8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800061ec:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
800061f0:	30 09       	mov	r9,0
800061f2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800061f6:	30 fa       	mov	r10,15
800061f8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
800061fc:	99 18       	st.w	r12[0x4],r8
800061fe:	5e f9       	retal	r9

80006200 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80006200:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80006202:	30 18       	mov	r8,1
80006204:	f0 0b 18 00 	cp.b	r11,r8
80006208:	5f be       	srhi	lr
8000620a:	f0 0a 18 00 	cp.b	r10,r8
8000620e:	5f b8       	srhi	r8
80006210:	fd e8 10 08 	or	r8,lr,r8
80006214:	c0 30       	breq	8000621a <spi_selectionMode+0x1a>
80006216:	30 2c       	mov	r12,2
80006218:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
8000621a:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
8000621c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006220:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80006224:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80006228:	99 18       	st.w	r12[0x4],r8
8000622a:	d8 0a       	popm	pc,r12=0

8000622c <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000622c:	78 18       	ld.w	r8,r12[0x4]
8000622e:	ea 18 00 0f 	orh	r8,0xf
80006232:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80006234:	78 18       	ld.w	r8,r12[0x4]
80006236:	e2 18 00 04 	andl	r8,0x4,COH
8000623a:	c0 f0       	breq	80006258 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
8000623c:	30 e8       	mov	r8,14
8000623e:	f0 0b 18 00 	cp.b	r11,r8
80006242:	e0 8b 00 19 	brhi	80006274 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80006246:	78 18       	ld.w	r8,r12[0x4]
80006248:	b1 6b       	lsl	r11,0x10
8000624a:	ea 1b ff f0 	orh	r11,0xfff0
8000624e:	e8 1b ff ff 	orl	r11,0xffff
80006252:	10 6b       	and	r11,r8
80006254:	99 1b       	st.w	r12[0x4],r11
80006256:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80006258:	30 38       	mov	r8,3
8000625a:	f0 0b 18 00 	cp.b	r11,r8
8000625e:	e0 8b 00 0b 	brhi	80006274 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80006262:	78 18       	ld.w	r8,r12[0x4]
80006264:	2f 0b       	sub	r11,-16
80006266:	30 19       	mov	r9,1
80006268:	f2 0b 09 4b 	lsl	r11,r9,r11
8000626c:	5c db       	com	r11
8000626e:	10 6b       	and	r11,r8
80006270:	99 1b       	st.w	r12[0x4],r11
80006272:	5e fd       	retal	0
80006274:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80006276:	5e fc       	retal	r12

80006278 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80006278:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000627c:	c0 58       	rjmp	80006286 <spi_unselectChip+0xe>
    if (!timeout--) {
8000627e:	58 08       	cp.w	r8,0
80006280:	c0 21       	brne	80006284 <spi_unselectChip+0xc>
80006282:	5e ff       	retal	1
80006284:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006286:	78 49       	ld.w	r9,r12[0x10]
80006288:	e2 19 02 00 	andl	r9,0x200,COH
8000628c:	cf 90       	breq	8000627e <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000628e:	78 18       	ld.w	r8,r12[0x4]
80006290:	ea 18 00 0f 	orh	r8,0xf
80006294:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80006296:	fc 18 01 00 	movh	r8,0x100
8000629a:	99 08       	st.w	r12[0x0],r8
8000629c:	5e fd       	retal	0

8000629e <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
8000629e:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
800062a2:	f7 38 00 0c 	ld.ub	r8,r11[12]
800062a6:	30 39       	mov	r9,3
800062a8:	f2 08 18 00 	cp.b	r8,r9
800062ac:	e0 8b 00 57 	brhi	8000635a <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
800062b0:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
800062b4:	30 1e       	mov	lr,1
800062b6:	fc 09 18 00 	cp.b	r9,lr
800062ba:	e0 8b 00 50 	brhi	8000635a <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
800062be:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
800062c2:	30 77       	mov	r7,7
800062c4:	ee 0e 18 00 	cp.b	lr,r7
800062c8:	e0 88 00 49 	brls	8000635a <spi_setupChipReg+0xbc>
800062cc:	31 07       	mov	r7,16
800062ce:	ee 0e 18 00 	cp.b	lr,r7
800062d2:	e0 8b 00 44 	brhi	8000635a <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
800062d6:	76 17       	ld.w	r7,r11[0x4]
800062d8:	ee 06 16 01 	lsr	r6,r7,0x1
800062dc:	0c 0a       	add	r10,r6
800062de:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
800062e2:	ec c7 00 01 	sub	r7,r6,1
800062e6:	e0 47 00 fe 	cp.w	r7,254
800062ea:	e0 8b 00 38 	brhi	8000635a <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
800062ee:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
800062f0:	58 06       	cp.w	r6,0
800062f2:	c3 45       	brlt	8000635a <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
800062f4:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
800062f6:	f0 06 16 01 	lsr	r6,r8,0x1
800062fa:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
800062fe:	ec 18 00 01 	eorl	r8,0x1
80006302:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80006306:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
8000630a:	20 8e       	sub	lr,8
8000630c:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80006310:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80006314:	f7 38 00 09 	ld.ub	r8,r11[9]
80006318:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000631c:	f7 38 00 0a 	ld.ub	r8,r11[10]
80006320:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80006324:	17 88       	ld.ub	r8,r11[0x0]
80006326:	30 19       	mov	r9,1
80006328:	f2 08 18 00 	cp.b	r8,r9
8000632c:	c0 e0       	breq	80006348 <spi_setupChipReg+0xaa>
8000632e:	c0 a3       	brcs	80006342 <spi_setupChipReg+0xa4>
80006330:	30 29       	mov	r9,2
80006332:	f2 08 18 00 	cp.b	r8,r9
80006336:	c0 c0       	breq	8000634e <spi_setupChipReg+0xb0>
80006338:	30 39       	mov	r9,3
8000633a:	f2 08 18 00 	cp.b	r8,r9
8000633e:	c0 e1       	brne	8000635a <spi_setupChipReg+0xbc>
80006340:	c0 a8       	rjmp	80006354 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80006342:	99 ca       	st.w	r12[0x30],r10
80006344:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80006348:	99 da       	st.w	r12[0x34],r10
8000634a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
8000634e:	99 ea       	st.w	r12[0x38],r10
80006350:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80006354:	99 fa       	st.w	r12[0x3c],r10
80006356:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
8000635a:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
8000635c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006360 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80006360:	30 18       	mov	r8,1
80006362:	99 08       	st.w	r12[0x0],r8
}
80006364:	5e fc       	retal	r12

80006366 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80006366:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000636a:	c0 58       	rjmp	80006374 <spi_write+0xe>
    if (!timeout--) {
8000636c:	58 08       	cp.w	r8,0
8000636e:	c0 21       	brne	80006372 <spi_write+0xc>
80006370:	5e ff       	retal	1
80006372:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006374:	78 49       	ld.w	r9,r12[0x10]
80006376:	e2 19 00 02 	andl	r9,0x2,COH
8000637a:	cf 90       	breq	8000636c <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000637c:	5c 7b       	castu.h	r11
8000637e:	99 3b       	st.w	r12[0xc],r11
80006380:	5e fd       	retal	0

80006382 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80006382:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80006386:	c0 58       	rjmp	80006390 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80006388:	58 08       	cp.w	r8,0
8000638a:	c0 21       	brne	8000638e <spi_read+0xc>
8000638c:	5e ff       	retal	1
8000638e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80006390:	78 49       	ld.w	r9,r12[0x10]
80006392:	e2 19 02 01 	andl	r9,0x201,COH
80006396:	e0 49 02 01 	cp.w	r9,513
8000639a:	cf 71       	brne	80006388 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000639c:	78 28       	ld.w	r8,r12[0x8]
8000639e:	b6 08       	st.h	r11[0x0],r8
800063a0:	5e fd       	retal	0

800063a2 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
800063a2:	76 09       	ld.w	r9,r11[0x0]
800063a4:	58 29       	cp.w	r9,2
800063a6:	e0 88 00 03 	brls	800063ac <tc_init_waveform+0xa>
800063aa:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
800063ac:	76 18       	ld.w	r8,r11[0x4]
800063ae:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800063b2:	af ba       	sbr	r10,0xf
800063b4:	10 9b       	mov	r11,r8
800063b6:	e6 1b c0 00 	andh	r11,0xc000,COH
800063ba:	16 4a       	or	r10,r11
800063bc:	10 9b       	mov	r11,r8
800063be:	e6 1b 30 00 	andh	r11,0x3000,COH
800063c2:	16 4a       	or	r10,r11
800063c4:	10 9b       	mov	r11,r8
800063c6:	e6 1b 0c 00 	andh	r11,0xc00,COH
800063ca:	16 4a       	or	r10,r11
800063cc:	10 9b       	mov	r11,r8
800063ce:	e6 1b 03 00 	andh	r11,0x300,COH
800063d2:	16 4a       	or	r10,r11
800063d4:	10 9b       	mov	r11,r8
800063d6:	e6 1b 00 c0 	andh	r11,0xc0,COH
800063da:	16 4a       	or	r10,r11
800063dc:	10 9b       	mov	r11,r8
800063de:	e6 1b 00 30 	andh	r11,0x30,COH
800063e2:	16 4a       	or	r10,r11
800063e4:	10 9b       	mov	r11,r8
800063e6:	e6 1b 00 0c 	andh	r11,0xc,COH
800063ea:	16 4a       	or	r10,r11
800063ec:	10 9b       	mov	r11,r8
800063ee:	e6 1b 00 03 	andh	r11,0x3,COH
800063f2:	16 4a       	or	r10,r11
800063f4:	10 9b       	mov	r11,r8
800063f6:	e2 1b 60 00 	andl	r11,0x6000,COH
800063fa:	16 4a       	or	r10,r11
800063fc:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80006400:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80006404:	10 9b       	mov	r11,r8
80006406:	e2 1b 0c 00 	andl	r11,0xc00,COH
8000640a:	16 4a       	or	r10,r11
8000640c:	10 9b       	mov	r11,r8
8000640e:	e2 1b 03 00 	andl	r11,0x300,COH
80006412:	16 4a       	or	r10,r11
80006414:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80006418:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
8000641c:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80006420:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80006424:	10 9b       	mov	r11,r8
80006426:	e2 1b 00 30 	andl	r11,0x30,COH
8000642a:	16 4a       	or	r10,r11
8000642c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80006430:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80006434:	a5 69       	lsl	r9,0x4
80006436:	2f f9       	sub	r9,-1
80006438:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
8000643c:	5e fd       	retal	0

8000643e <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000643e:	58 2b       	cp.w	r11,2
80006440:	e0 88 00 03 	brls	80006446 <tc_start+0x8>
80006444:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80006446:	a7 6b       	lsl	r11,0x6
80006448:	16 0c       	add	r12,r11
8000644a:	30 58       	mov	r8,5
8000644c:	99 08       	st.w	r12[0x0],r8
8000644e:	5e fd       	retal	0

80006450 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006450:	58 2b       	cp.w	r11,2
80006452:	e0 88 00 03 	brls	80006458 <tc_read_sr+0x8>
80006456:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80006458:	a7 6b       	lsl	r11,0x6
8000645a:	2e 0b       	sub	r11,-32
8000645c:	16 0c       	add	r12,r11
8000645e:	78 0c       	ld.w	r12,r12[0x0]
}
80006460:	5e fc       	retal	r12

80006462 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006462:	58 2b       	cp.w	r11,2
80006464:	e0 88 00 03 	brls	8000646a <tc_write_rc+0x8>
80006468:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
8000646a:	f6 08 15 04 	lsl	r8,r11,0x4
8000646e:	2f f8       	sub	r8,-1
80006470:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80006474:	e2 18 80 00 	andl	r8,0x8000,COH
80006478:	c0 c0       	breq	80006490 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
8000647a:	a7 6b       	lsl	r11,0x6
8000647c:	16 0c       	add	r12,r11
8000647e:	2e 4c       	sub	r12,-28
80006480:	78 08       	ld.w	r8,r12[0x0]
80006482:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80006486:	e0 18 00 00 	andl	r8,0x0
8000648a:	f3 e8 10 08 	or	r8,r9,r8
8000648e:	99 08       	st.w	r12[0x0],r8

  return value;
80006490:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80006494:	5e fc       	retal	r12

80006496 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80006496:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000649a:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000649e:	58 2b       	cp.w	r11,2
800064a0:	e0 88 00 04 	brls	800064a8 <tc_configure_interrupts+0x12>
800064a4:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
800064a8:	ee 19 00 01 	eorh	r9,0x1
800064ac:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800064b0:	74 08       	ld.w	r8,r10[0x0]
800064b2:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
800064b6:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
800064ba:	a7 6e       	lsl	lr,0x6
800064bc:	fd e7 10 7e 	or	lr,lr,r7<<0x7
800064c0:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
800064c4:	0e 4e       	or	lr,r7
800064c6:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
800064ca:	fd e7 10 5e 	or	lr,lr,r7<<0x5
800064ce:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
800064d2:	fd e7 10 4e 	or	lr,lr,r7<<0x4
800064d6:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
800064da:	fd e7 10 3e 	or	lr,lr,r7<<0x3
800064de:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
800064e2:	fd e7 10 2e 	or	lr,lr,r7<<0x2
800064e6:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800064ea:	fd e8 10 18 	or	r8,lr,r8<<0x1
800064ee:	f6 0e 15 06 	lsl	lr,r11,0x6
800064f2:	f8 0e 00 0e 	add	lr,r12,lr
800064f6:	2d ce       	sub	lr,-36
800064f8:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800064fa:	58 09       	cp.w	r9,0
800064fc:	c0 20       	breq	80006500 <tc_configure_interrupts+0x6a>
800064fe:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80006500:	74 08       	ld.w	r8,r10[0x0]
80006502:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80006506:	e0 65 00 80 	mov	r5,128
8000650a:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000650e:	74 08       	ld.w	r8,r10[0x0]
80006510:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80006514:	f9 b4 00 40 	moveq	r4,64
80006518:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000651c:	74 08       	ld.w	r8,r10[0x0]
8000651e:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80006522:	f9 b3 00 20 	moveq	r3,32
80006526:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
8000652a:	74 08       	ld.w	r8,r10[0x0]
8000652c:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80006530:	f9 b2 00 10 	moveq	r2,16
80006534:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80006538:	74 08       	ld.w	r8,r10[0x0]
8000653a:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000653e:	f9 b6 00 08 	moveq	r6,8
80006542:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80006546:	74 08       	ld.w	r8,r10[0x0]
80006548:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
8000654c:	f9 b7 00 04 	moveq	r7,4
80006550:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80006554:	74 08       	ld.w	r8,r10[0x0]
80006556:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000655a:	f9 be 00 02 	moveq	lr,2
8000655e:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80006562:	74 08       	ld.w	r8,r10[0x0]
80006564:	ec 18 00 01 	eorl	r8,0x1
80006568:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000656c:	eb e8 10 08 	or	r8,r5,r8
80006570:	08 48       	or	r8,r4
80006572:	06 48       	or	r8,r3
80006574:	04 48       	or	r8,r2
80006576:	0c 48       	or	r8,r6
80006578:	0e 48       	or	r8,r7
8000657a:	1c 48       	or	r8,lr
8000657c:	f6 0a 15 06 	lsl	r10,r11,0x6
80006580:	f8 0a 00 0a 	add	r10,r12,r10
80006584:	2d 8a       	sub	r10,-40
80006586:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80006588:	a7 6b       	lsl	r11,0x6
8000658a:	2e 0b       	sub	r11,-32
8000658c:	16 0c       	add	r12,r11
8000658e:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80006590:	58 09       	cp.w	r9,0
80006592:	c0 31       	brne	80006598 <tc_configure_interrupts+0x102>
80006594:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80006598:	d5 03       	csrf	0x10
8000659a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000659e:	d7 03       	nop

800065a0 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
800065a0:	4a 78       	lddpc	r8,8000663c <twi_master_interrupt_handler+0x9c>
800065a2:	70 08       	ld.w	r8,r8[0x0]
800065a4:	70 89       	ld.w	r9,r8[0x20]
800065a6:	4a 7a       	lddpc	r10,80006640 <twi_master_interrupt_handler+0xa0>
800065a8:	74 0a       	ld.w	r10,r10[0x0]
800065aa:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800065ae:	12 9a       	mov	r10,r9
800065b0:	e2 1a 01 00 	andl	r10,0x100,COH
800065b4:	c3 91       	brne	80006626 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800065b6:	12 9a       	mov	r10,r9
800065b8:	e2 1a 00 02 	andl	r10,0x2,COH
800065bc:	c1 70       	breq	800065ea <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800065be:	4a 29       	lddpc	r9,80006644 <twi_master_interrupt_handler+0xa4>
800065c0:	72 0a       	ld.w	r10,r9[0x0]
800065c2:	70 cb       	ld.w	r11,r8[0x30]
800065c4:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
800065c6:	72 0a       	ld.w	r10,r9[0x0]
800065c8:	2f fa       	sub	r10,-1
800065ca:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800065cc:	49 f9       	lddpc	r9,80006648 <twi_master_interrupt_handler+0xa8>
800065ce:	72 0a       	ld.w	r10,r9[0x0]
800065d0:	20 1a       	sub	r10,1
800065d2:	93 0a       	st.w	r9[0x0],r10
800065d4:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800065d6:	58 19       	cp.w	r9,1
800065d8:	f9 b9 00 02 	moveq	r9,2
800065dc:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800065e0:	49 a9       	lddpc	r9,80006648 <twi_master_interrupt_handler+0xa8>
800065e2:	72 09       	ld.w	r9,r9[0x0]
800065e4:	58 09       	cp.w	r9,0
800065e6:	c2 30       	breq	8000662c <twi_master_interrupt_handler+0x8c>
800065e8:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800065ea:	12 9a       	mov	r10,r9
800065ec:	e2 1a 00 04 	andl	r10,0x4,COH
800065f0:	c1 70       	breq	8000661e <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800065f2:	49 79       	lddpc	r9,8000664c <twi_master_interrupt_handler+0xac>
800065f4:	72 0a       	ld.w	r10,r9[0x0]
800065f6:	20 1a       	sub	r10,1
800065f8:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800065fa:	72 09       	ld.w	r9,r9[0x0]
800065fc:	58 09       	cp.w	r9,0
800065fe:	e0 89 00 0a 	brgt	80006612 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80006602:	49 09       	lddpc	r9,80006640 <twi_master_interrupt_handler+0xa0>
80006604:	30 1a       	mov	r10,1
80006606:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80006608:	3f fa       	mov	r10,-1
8000660a:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
8000660c:	72 09       	ld.w	r9,r9[0x0]
8000660e:	91 99       	st.w	r8[0x24],r9
80006610:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80006612:	49 0a       	lddpc	r10,80006650 <twi_master_interrupt_handler+0xb0>
80006614:	74 09       	ld.w	r9,r10[0x0]
80006616:	13 3b       	ld.ub	r11,r9++
80006618:	91 db       	st.w	r8[0x34],r11
8000661a:	95 09       	st.w	r10[0x0],r9
8000661c:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
8000661e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006622:	c0 51       	brne	8000662c <twi_master_interrupt_handler+0x8c>
80006624:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80006626:	30 1a       	mov	r10,1
80006628:	48 b9       	lddpc	r9,80006654 <twi_master_interrupt_handler+0xb4>
8000662a:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
8000662c:	3f f9       	mov	r9,-1
8000662e:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80006630:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80006632:	30 09       	mov	r9,0
80006634:	48 98       	lddpc	r8,80006658 <twi_master_interrupt_handler+0xb8>
80006636:	b0 89       	st.b	r8[0x0],r9
80006638:	d6 03       	rete
8000663a:	00 00       	add	r0,r0
8000663c:	00 00       	add	r0,r0
8000663e:	11 d0       	ld.ub	r0,r8[0x5]
80006640:	00 00       	add	r0,r0
80006642:	11 cc       	ld.ub	r12,r8[0x4]
80006644:	00 00       	add	r0,r0
80006646:	11 dc       	ld.ub	r12,r8[0x5]
80006648:	00 00       	add	r0,r0
8000664a:	11 d8       	ld.ub	r8,r8[0x5]
8000664c:	00 00       	add	r0,r0
8000664e:	11 c8       	ld.ub	r8,r8[0x4]
80006650:	00 00       	add	r0,r0
80006652:	11 d4       	ld.ub	r4,r8[0x5]
80006654:	00 00       	add	r0,r0
80006656:	11 c5       	ld.ub	r5,r8[0x4]
80006658:	00 00       	add	r0,r0
8000665a:	11 c4       	ld.ub	r4,r8[0x4]

8000665c <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
8000665c:	eb cd 40 e0 	pushm	r5-r7,lr
80006660:	18 97       	mov	r7,r12
80006662:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80006664:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80006668:	49 f9       	lddpc	r9,800066e4 <twi_master_init+0x88>
8000666a:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
8000666c:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
8000666e:	3f f9       	mov	r9,-1
80006670:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80006672:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80006674:	e0 69 00 80 	mov	r9,128
80006678:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000667a:	e6 18 00 01 	andh	r8,0x1,COH
8000667e:	c0 21       	brne	80006682 <twi_master_init+0x26>
      cpu_irq_enable();
80006680:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80006682:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006684:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80006688:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
8000668a:	30 3a       	mov	r10,3
8000668c:	e0 6b 01 60 	mov	r11,352
80006690:	49 6c       	lddpc	r12,800066e8 <twi_master_init+0x8c>
80006692:	f0 1f 00 17 	mcall	800066ec <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006696:	e6 16 00 01 	andh	r6,0x1,COH
8000669a:	c0 21       	brne	8000669e <twi_master_init+0x42>
      cpu_irq_enable();
8000669c:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
8000669e:	6a 19       	ld.w	r9,r5[0x4]
800066a0:	a1 79       	lsl	r9,0x1
800066a2:	6a 08       	ld.w	r8,r5[0x0]
800066a4:	f0 09 0d 08 	divu	r8,r8,r9
800066a8:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800066aa:	e0 48 00 ff 	cp.w	r8,255
800066ae:	e0 8b 00 04 	brhi	800066b6 <twi_master_init+0x5a>
800066b2:	30 09       	mov	r9,0
800066b4:	c0 f8       	rjmp	800066d2 <twi_master_init+0x76>
800066b6:	30 09       	mov	r9,0
800066b8:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
800066ba:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
800066bc:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800066be:	e0 48 00 ff 	cp.w	r8,255
800066c2:	5f bb       	srhi	r11
800066c4:	58 69       	cp.w	r9,6
800066c6:	5f 8a       	srls	r10
800066c8:	f7 ea 00 0a 	and	r10,r11,r10
800066cc:	f8 0a 18 00 	cp.b	r10,r12
800066d0:	cf 51       	brne	800066ba <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800066d2:	b1 69       	lsl	r9,0x10
800066d4:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800066d8:	f3 e8 10 08 	or	r8,r9,r8
800066dc:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800066de:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800066e2:	00 00       	add	r0,r0
800066e4:	00 00       	add	r0,r0
800066e6:	11 d0       	ld.ub	r0,r8[0x5]
800066e8:	80 00       	ld.sh	r0,r0[0x0]
800066ea:	65 a0       	ld.w	r0,r2[0x68]
800066ec:	80 00       	ld.sh	r0,r0[0x0]
800066ee:	60 bc       	ld.w	r12,r0[0x2c]

800066f0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800066f0:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800066f2:	f6 08 15 04 	lsl	r8,r11,0x4
800066f6:	14 38       	cp.w	r8,r10
800066f8:	f9 b8 08 10 	movls	r8,16
800066fc:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006700:	f0 0b 02 4b 	mul	r11,r8,r11
80006704:	f6 09 16 01 	lsr	r9,r11,0x1
80006708:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000670c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006710:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006714:	f2 cb 00 01 	sub	r11,r9,1
80006718:	e0 4b ff fe 	cp.w	r11,65534
8000671c:	e0 88 00 03 	brls	80006722 <usart_set_async_baudrate+0x32>
80006720:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006722:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006724:	e8 6e 00 00 	mov	lr,524288
80006728:	59 08       	cp.w	r8,16
8000672a:	fc 08 17 10 	movne	r8,lr
8000672e:	f9 b8 00 00 	moveq	r8,0
80006732:	e4 1b ff f7 	andh	r11,0xfff7
80006736:	e0 1b fe cf 	andl	r11,0xfecf
8000673a:	16 48       	or	r8,r11
8000673c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000673e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006742:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006746:	99 89       	st.w	r12[0x20],r9
80006748:	d8 0a       	popm	pc,r12=0

8000674a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000674a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000674c:	e2 18 00 02 	andl	r8,0x2,COH
80006750:	c0 31       	brne	80006756 <usart_write_char+0xc>
80006752:	30 2c       	mov	r12,2
80006754:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006756:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000675a:	99 7b       	st.w	r12[0x1c],r11
8000675c:	5e fd       	retal	0
8000675e:	d7 03       	nop

80006760 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006760:	eb cd 40 e0 	pushm	r5-r7,lr
80006764:	18 96       	mov	r6,r12
80006766:	16 95       	mov	r5,r11
80006768:	e0 67 27 0f 	mov	r7,9999
8000676c:	c0 68       	rjmp	80006778 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000676e:	58 07       	cp.w	r7,0
80006770:	c0 31       	brne	80006776 <usart_putchar+0x16>
80006772:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006776:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006778:	0a 9b       	mov	r11,r5
8000677a:	0c 9c       	mov	r12,r6
8000677c:	f0 1f 00 03 	mcall	80006788 <usart_putchar+0x28>
80006780:	cf 71       	brne	8000676e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006782:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006786:	00 00       	add	r0,r0
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	67 4a       	ld.w	r10,r3[0x50]

8000678c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000678c:	78 58       	ld.w	r8,r12[0x14]
8000678e:	e2 18 00 e0 	andl	r8,0xe0,COH
80006792:	c0 30       	breq	80006798 <usart_read_char+0xc>
80006794:	30 4c       	mov	r12,4
80006796:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006798:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000679a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000679e:	c0 31       	brne	800067a4 <usart_read_char+0x18>
800067a0:	30 3c       	mov	r12,3
800067a2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800067a4:	78 68       	ld.w	r8,r12[0x18]
800067a6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800067aa:	97 08       	st.w	r11[0x0],r8
800067ac:	5e fd       	retal	0
800067ae:	d7 03       	nop

800067b0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800067b0:	eb cd 40 c0 	pushm	r6-r7,lr
800067b4:	20 1d       	sub	sp,4
800067b6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800067b8:	1a 97       	mov	r7,sp
800067ba:	1a 9b       	mov	r11,sp
800067bc:	0c 9c       	mov	r12,r6
800067be:	f0 1f 00 07 	mcall	800067d8 <usart_getchar+0x28>
800067c2:	58 3c       	cp.w	r12,3
800067c4:	cf b0       	breq	800067ba <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800067c6:	58 4c       	cp.w	r12,4
800067c8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800067cc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800067d0:	2f fd       	sub	sp,-4
800067d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067d6:	00 00       	add	r0,r0
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	67 8c       	ld.w	r12,r3[0x60]

800067dc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800067dc:	eb cd 40 c0 	pushm	r6-r7,lr
800067e0:	18 96       	mov	r6,r12
800067e2:	16 97       	mov	r7,r11
  while (*string != '\0')
800067e4:	17 8b       	ld.ub	r11,r11[0x0]
800067e6:	58 0b       	cp.w	r11,0
800067e8:	c0 80       	breq	800067f8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800067ea:	2f f7       	sub	r7,-1
800067ec:	0c 9c       	mov	r12,r6
800067ee:	f0 1f 00 04 	mcall	800067fc <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800067f2:	0f 8b       	ld.ub	r11,r7[0x0]
800067f4:	58 0b       	cp.w	r11,0
800067f6:	cf a1       	brne	800067ea <usart_write_line+0xe>
800067f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	67 60       	ld.w	r0,r3[0x58]

80006800 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006800:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006804:	e6 18 00 01 	andh	r8,0x1,COH
80006808:	c0 71       	brne	80006816 <usart_reset+0x16>
8000680a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000680c:	3f f8       	mov	r8,-1
8000680e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006810:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006812:	d5 03       	csrf	0x10
80006814:	c0 48       	rjmp	8000681c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006816:	3f f8       	mov	r8,-1
80006818:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000681a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000681c:	30 08       	mov	r8,0
8000681e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006820:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006822:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006824:	ea 68 61 0c 	mov	r8,680204
80006828:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000682a:	5e fc       	retal	r12

8000682c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000682c:	eb cd 40 e0 	pushm	r5-r7,lr
80006830:	18 96       	mov	r6,r12
80006832:	16 97       	mov	r7,r11
80006834:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006836:	f0 1f 00 2f 	mcall	800068f0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000683a:	58 07       	cp.w	r7,0
8000683c:	c5 80       	breq	800068ec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000683e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006840:	30 49       	mov	r9,4
80006842:	f2 08 18 00 	cp.b	r8,r9
80006846:	e0 88 00 53 	brls	800068ec <usart_init_rs232+0xc0>
8000684a:	30 99       	mov	r9,9
8000684c:	f2 08 18 00 	cp.b	r8,r9
80006850:	e0 8b 00 4e 	brhi	800068ec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006854:	0f d9       	ld.ub	r9,r7[0x5]
80006856:	30 78       	mov	r8,7
80006858:	f0 09 18 00 	cp.b	r9,r8
8000685c:	e0 8b 00 48 	brhi	800068ec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006860:	8e 39       	ld.sh	r9,r7[0x6]
80006862:	e0 68 01 01 	mov	r8,257
80006866:	f0 09 19 00 	cp.h	r9,r8
8000686a:	e0 8b 00 41 	brhi	800068ec <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000686e:	ef 39 00 08 	ld.ub	r9,r7[8]
80006872:	30 38       	mov	r8,3
80006874:	f0 09 18 00 	cp.b	r9,r8
80006878:	e0 8b 00 3a 	brhi	800068ec <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000687c:	0a 9a       	mov	r10,r5
8000687e:	6e 0b       	ld.w	r11,r7[0x0]
80006880:	0c 9c       	mov	r12,r6
80006882:	f0 1f 00 1d 	mcall	800068f4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006886:	58 1c       	cp.w	r12,1
80006888:	c3 20       	breq	800068ec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000688a:	0f c8       	ld.ub	r8,r7[0x4]
8000688c:	30 99       	mov	r9,9
8000688e:	f2 08 18 00 	cp.b	r8,r9
80006892:	c0 51       	brne	8000689c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006894:	6c 18       	ld.w	r8,r6[0x4]
80006896:	b1 b8       	sbr	r8,0x11
80006898:	8d 18       	st.w	r6[0x4],r8
8000689a:	c0 68       	rjmp	800068a6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
8000689c:	6c 19       	ld.w	r9,r6[0x4]
8000689e:	20 58       	sub	r8,5
800068a0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800068a4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800068a6:	6c 19       	ld.w	r9,r6[0x4]
800068a8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800068ac:	0f d8       	ld.ub	r8,r7[0x5]
800068ae:	a9 78       	lsl	r8,0x9
800068b0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800068b4:	12 48       	or	r8,r9
800068b6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800068b8:	8e 38       	ld.sh	r8,r7[0x6]
800068ba:	30 29       	mov	r9,2
800068bc:	f2 08 19 00 	cp.h	r8,r9
800068c0:	e0 88 00 09 	brls	800068d2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800068c4:	6c 18       	ld.w	r8,r6[0x4]
800068c6:	ad b8       	sbr	r8,0xd
800068c8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800068ca:	8e b8       	ld.uh	r8,r7[0x6]
800068cc:	20 28       	sub	r8,2
800068ce:	8d a8       	st.w	r6[0x28],r8
800068d0:	c0 68       	rjmp	800068dc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800068d2:	6c 19       	ld.w	r9,r6[0x4]
800068d4:	5c 78       	castu.h	r8
800068d6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800068da:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800068dc:	6c 18       	ld.w	r8,r6[0x4]
800068de:	e0 18 ff f0 	andl	r8,0xfff0
800068e2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800068e4:	35 08       	mov	r8,80
800068e6:	8d 08       	st.w	r6[0x0],r8
800068e8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800068ec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800068f0:	80 00       	ld.sh	r0,r0[0x0]
800068f2:	68 00       	ld.w	r0,r4[0x0]
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	66 f0       	ld.w	r0,r3[0x3c]

800068f8 <disk_status>:


	return RES_OK;

	
}
800068f8:	5e fd       	retal	0

800068fa <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
800068fa:	5e fd       	retal	0

800068fc <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
800068fc:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
800068fe:	f0 1f 00 0e 	mcall	80006934 <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
80006902:	19 89       	ld.ub	r9,r12[0x0]
80006904:	19 98       	ld.ub	r8,r12[0x1]
80006906:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000690a:	f0 c8 07 bc 	sub	r8,r8,1980
8000690e:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
80006910:	19 aa       	ld.ub	r10,r12[0x2]
80006912:	b5 7a       	lsl	r10,0x15
80006914:	19 b9       	ld.ub	r9,r12[0x3]
80006916:	b1 69       	lsl	r9,0x10
80006918:	12 0a       	add	r10,r9
	current_time += t->day << 16;
8000691a:	19 f9       	ld.ub	r9,r12[0x7]
8000691c:	a1 99       	lsr	r9,0x1
8000691e:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
80006920:	19 d9       	ld.ub	r9,r12[0x5]
80006922:	ab 79       	lsl	r9,0xb
80006924:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
80006926:	19 e9       	ld.ub	r9,r12[0x6]
80006928:	a5 79       	lsl	r9,0x5
8000692a:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
8000692e:	10 0c       	add	r12,r8
80006930:	d8 02       	popm	pc
80006932:	00 00       	add	r0,r0
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	5f 54       	srlt	r4

80006938 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
80006938:	eb cd 40 80 	pushm	r7,lr
8000693c:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
8000693e:	30 18       	mov	r8,1
80006940:	f0 0b 18 00 	cp.b	r11,r8
80006944:	c1 a0       	breq	80006978 <disk_ioctl+0x40>
80006946:	58 0b       	cp.w	r11,0
80006948:	c0 c0       	breq	80006960 <disk_ioctl+0x28>
8000694a:	30 28       	mov	r8,2
8000694c:	f0 0b 18 00 	cp.b	r11,r8
80006950:	c0 a0       	breq	80006964 <disk_ioctl+0x2c>
80006952:	30 38       	mov	r8,3
80006954:	f0 0b 18 00 	cp.b	r11,r8
80006958:	c0 b0       	breq	8000696e <disk_ioctl+0x36>
8000695a:	30 4c       	mov	r12,4
8000695c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006960:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
80006964:	e0 68 02 00 	mov	r8,512
80006968:	b4 08       	st.h	r10[0x0],r8
8000696a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
8000696e:	e0 68 02 00 	mov	r8,512
80006972:	b4 08       	st.h	r10[0x0],r8
80006974:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
80006978:	f0 1f 00 03 	mcall	80006984 <disk_ioctl+0x4c>
8000697c:	8f 0c       	st.w	r7[0x0],r12
8000697e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006982:	00 00       	add	r0,r0
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	34 58       	mov	r8,69

80006988 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
80006988:	d4 01       	pushm	lr
8000698a:	16 9c       	mov	r12,r11
8000698c:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
8000698e:	5c 59       	castu.b	r9
80006990:	e0 6a 02 00 	mov	r10,512
80006994:	f0 1f 00 03 	mcall	800069a0 <disk_write+0x18>
80006998:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
8000699a:	5f 1c       	srne	r12
8000699c:	d8 02       	popm	pc
8000699e:	00 00       	add	r0,r0
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	34 78       	mov	r8,71

800069a4 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
800069a4:	d4 01       	pushm	lr
800069a6:	16 9c       	mov	r12,r11
800069a8:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
800069aa:	5c 59       	castu.b	r9
800069ac:	e0 6a 02 00 	mov	r10,512
800069b0:	f0 1f 00 03 	mcall	800069bc <disk_read+0x18>
800069b4:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
800069b6:	5f 1c       	srne	r12
800069b8:	d8 02       	popm	pc
800069ba:	00 00       	add	r0,r0
800069bc:	80 00       	ld.sh	r0,r0[0x0]
800069be:	34 a8       	mov	r8,74

800069c0 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800069c0:	58 0a       	cp.w	r10,0
800069c2:	5e 0c       	reteq	r12
800069c4:	30 08       	mov	r8,0
		*d++ = *s++;
800069c6:	f6 08 07 09 	ld.ub	r9,r11[r8]
800069ca:	f8 08 0b 09 	st.b	r12[r8],r9
800069ce:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800069d0:	14 38       	cp.w	r8,r10
800069d2:	cf a1       	brne	800069c6 <mem_cpy+0x6>
800069d4:	5e fc       	retal	r12

800069d6 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800069d6:	58 0a       	cp.w	r10,0
800069d8:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
800069da:	18 cb       	st.b	r12++,r11
800069dc:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800069de:	cf e1       	brne	800069da <mem_set+0x4>
800069e0:	5e fc       	retal	r12

800069e2 <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
800069e2:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
800069e4:	19 8c       	ld.ub	r12,r12[0x0]
800069e6:	58 0c       	cp.w	r12,0
800069e8:	5e 0c       	reteq	r12
800069ea:	16 3c       	cp.w	r12,r11
800069ec:	5e 0c       	reteq	r12
800069ee:	2f f8       	sub	r8,-1
800069f0:	11 8c       	ld.ub	r12,r8[0x0]
800069f2:	58 0c       	cp.w	r12,0
800069f4:	5e 0c       	reteq	r12
800069f6:	16 3c       	cp.w	r12,r11
800069f8:	cf b1       	brne	800069ee <chk_chr+0xc>
	return *str;
}
800069fa:	5e fc       	retal	r12

800069fc <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
800069fc:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
800069fe:	78 58       	ld.w	r8,r12[0x14]
80006a00:	20 28       	sub	r8,2
80006a02:	10 3b       	cp.w	r11,r8
80006a04:	c0 23       	brcs	80006a08 <clust2sect+0xc>
80006a06:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
80006a08:	19 a8       	ld.ub	r8,r12[0x2]
80006a0a:	b1 3b       	mul	r11,r8
80006a0c:	78 a8       	ld.w	r8,r12[0x28]
80006a0e:	f6 08 00 0c 	add	r12,r11,r8
}
80006a12:	5e fc       	retal	r12

80006a14 <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
80006a14:	78 9a       	ld.w	r10,r12[0x24]
80006a16:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006a18:	78 08       	ld.w	r8,r12[0x0]
80006a1a:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006a1c:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
80006a1e:	58 0c       	cp.w	r12,0
80006a20:	c1 80       	breq	80006a50 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006a22:	f6 09 16 09 	lsr	r9,r11,0x9
80006a26:	f2 08 0d 08 	divu	r8,r9,r8
80006a2a:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006a2c:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006a2e:	18 38       	cp.w	r8,r12
80006a30:	c0 82       	brcc	80006a40 <clmt_clust+0x2c>
80006a32:	c0 b8       	rjmp	80006a48 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
80006a34:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
80006a36:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006a38:	12 38       	cp.w	r8,r9
80006a3a:	e0 8b 00 07 	brhi	80006a48 <clmt_clust+0x34>
80006a3e:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006a40:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
80006a42:	58 08       	cp.w	r8,0
80006a44:	cf 81       	brne	80006a34 <clmt_clust+0x20>
80006a46:	c0 58       	rjmp	80006a50 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006a48:	74 0c       	ld.w	r12,r10[0x0]
80006a4a:	f2 0c 00 0c 	add	r12,r9,r12
80006a4e:	5e fc       	retal	r12
80006a50:	5e fd       	retal	0

80006a52 <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
80006a52:	f7 39 00 1b 	ld.ub	r9,r11[27]
80006a56:	f7 38 00 1a 	ld.ub	r8,r11[26]
80006a5a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
80006a5e:	19 8a       	ld.ub	r10,r12[0x0]
80006a60:	30 39       	mov	r9,3
80006a62:	f2 0a 18 00 	cp.b	r10,r9
80006a66:	c0 91       	brne	80006a78 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
80006a68:	f7 3a 00 15 	ld.ub	r10,r11[21]
80006a6c:	f7 39 00 14 	ld.ub	r9,r11[20]
80006a70:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80006a74:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
80006a78:	5e f8       	retal	r8

80006a7a <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
80006a7a:	f9 6b 00 1a 	st.b	r12[26],r11
80006a7e:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
80006a82:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
80006a86:	b1 8b       	lsr	r11,0x10
80006a88:	f9 6b 00 14 	st.b	r12[20],r11
80006a8c:	a9 8b       	lsr	r11,0x8
80006a8e:	f9 6b 00 15 	st.b	r12[21],r11
}
80006a92:	5e fc       	retal	r12

80006a94 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
80006a94:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
80006a96:	78 05       	ld.w	r5,r12[0x0]
80006a98:	58 05       	cp.w	r5,0
80006a9a:	c5 50       	breq	80006b44 <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
80006a9c:	0b 84       	ld.ub	r4,r5[0x0]
80006a9e:	32 08       	mov	r8,32
80006aa0:	f0 04 18 00 	cp.b	r4,r8
80006aa4:	5f b9       	srhi	r9
80006aa6:	33 a8       	mov	r8,58
80006aa8:	f0 04 18 00 	cp.b	r4,r8
80006aac:	5f 18       	srne	r8
80006aae:	f3 e8 00 08 	and	r8,r9,r8
80006ab2:	c0 41       	brne	80006aba <get_ldnumber+0x26>
80006ab4:	08 99       	mov	r9,r4
80006ab6:	0a 98       	mov	r8,r5
80006ab8:	c1 28       	rjmp	80006adc <get_ldnumber+0x48>
80006aba:	0a 98       	mov	r8,r5
80006abc:	32 06       	mov	r6,32
80006abe:	33 a7       	mov	r7,58
80006ac0:	30 0e       	mov	lr,0
80006ac2:	2f f8       	sub	r8,-1
80006ac4:	11 89       	ld.ub	r9,r8[0x0]
80006ac6:	ec 09 18 00 	cp.b	r9,r6
80006aca:	5f bb       	srhi	r11
80006acc:	ee 09 18 00 	cp.b	r9,r7
80006ad0:	5f 1a       	srne	r10
80006ad2:	f7 ea 00 0a 	and	r10,r11,r10
80006ad6:	fc 0a 18 00 	cp.b	r10,lr
80006ada:	cf 41       	brne	80006ac2 <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
80006adc:	33 aa       	mov	r10,58
80006ade:	f4 09 18 00 	cp.b	r9,r10
80006ae2:	c0 30       	breq	80006ae8 <get_ldnumber+0x54>
80006ae4:	30 04       	mov	r4,0
80006ae6:	c3 08       	rjmp	80006b46 <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
80006ae8:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
80006aea:	58 94       	cp.w	r4,9
80006aec:	5f 8a       	srls	r10
80006aee:	ea c9 ff ff 	sub	r9,r5,-1
80006af2:	12 38       	cp.w	r8,r9
80006af4:	5f 09       	sreq	r9
80006af6:	f5 e9 00 09 	and	r9,r10,r9
80006afa:	c0 60       	breq	80006b06 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006afc:	58 04       	cp.w	r4,0
80006afe:	c2 31       	brne	80006b44 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
80006b00:	2f f8       	sub	r8,-1
80006b02:	99 08       	st.w	r12[0x0],r8
80006b04:	c2 18       	rjmp	80006b46 <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
80006b06:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
80006b08:	49 17       	lddpc	r7,80006b4c <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
80006b0a:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
80006b0c:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
80006b0e:	0f 3a       	ld.ub	r10,r7++
80006b10:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
80006b12:	f2 cb 00 61 	sub	r11,r9,97
80006b16:	ec 0b 18 00 	cp.b	r11,r6
80006b1a:	e0 8b 00 03 	brhi	80006b20 <get_ldnumber+0x8c>
80006b1e:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
80006b20:	fc 0a 18 00 	cp.b	r10,lr
80006b24:	5f 1b       	srne	r11
80006b26:	f2 0a 18 00 	cp.b	r10,r9
80006b2a:	5f 09       	sreq	r9
80006b2c:	f7 e9 00 09 	and	r9,r11,r9
80006b30:	fc 09 18 00 	cp.b	r9,lr
80006b34:	ce d1       	brne	80006b0e <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006b36:	10 35       	cp.w	r5,r8
80006b38:	5f 19       	srne	r9
80006b3a:	12 4b       	or	r11,r9
80006b3c:	c0 41       	brne	80006b44 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
80006b3e:	99 08       	st.w	r12[0x0],r8
80006b40:	30 04       	mov	r4,0
80006b42:	c0 28       	rjmp	80006b46 <get_ldnumber+0xb2>
80006b44:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
80006b46:	08 9c       	mov	r12,r4
80006b48:	d8 22       	popm	r4-r7,pc
80006b4a:	00 00       	add	r0,r0
80006b4c:	80 01       	ld.sh	r1,r0[0x0]
80006b4e:	99 58       	st.w	r12[0x14],r8

80006b50 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006b50:	eb cd 40 f8 	pushm	r3-r7,lr
80006b54:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
80006b56:	19 c9       	ld.ub	r9,r12[0x4]
80006b58:	30 08       	mov	r8,0
80006b5a:	f0 09 18 00 	cp.b	r9,r8
80006b5e:	c2 60       	breq	80006baa <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006b60:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
80006b62:	f8 c4 ff d0 	sub	r4,r12,-48
80006b66:	30 19       	mov	r9,1
80006b68:	0c 9a       	mov	r10,r6
80006b6a:	08 9b       	mov	r11,r4
80006b6c:	19 9c       	ld.ub	r12,r12[0x1]
80006b6e:	f0 1f 00 11 	mcall	80006bb0 <sync_window+0x60>
80006b72:	c0 30       	breq	80006b78 <sync_window+0x28>
80006b74:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
80006b78:	30 08       	mov	r8,0
80006b7a:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
80006b7c:	6e 89       	ld.w	r9,r7[0x20]
80006b7e:	ec 09 01 09 	sub	r9,r6,r9
80006b82:	6e 68       	ld.w	r8,r7[0x18]
80006b84:	10 39       	cp.w	r9,r8
80006b86:	c1 22       	brcc	80006baa <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006b88:	0f b5       	ld.ub	r5,r7[0x3]
80006b8a:	58 15       	cp.w	r5,1
80006b8c:	e0 88 00 0f 	brls	80006baa <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
80006b90:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
80006b92:	6e 68       	ld.w	r8,r7[0x18]
80006b94:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
80006b96:	06 99       	mov	r9,r3
80006b98:	0c 9a       	mov	r10,r6
80006b9a:	08 9b       	mov	r11,r4
80006b9c:	0f 9c       	ld.ub	r12,r7[0x1]
80006b9e:	f0 1f 00 05 	mcall	80006bb0 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006ba2:	20 15       	sub	r5,1
80006ba4:	58 15       	cp.w	r5,1
80006ba6:	fe 9b ff f6 	brhi	80006b92 <sync_window+0x42>
80006baa:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006bae:	00 00       	add	r0,r0
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	69 88       	ld.w	r8,r4[0x60]

80006bb4 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006bb4:	eb cd 40 e0 	pushm	r5-r7,lr
80006bb8:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
80006bba:	f0 1f 00 31 	mcall	80006c7c <sync_fs+0xc8>
80006bbe:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80006bc0:	c5 a1       	brne	80006c74 <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
80006bc2:	0d 89       	ld.ub	r9,r6[0x0]
80006bc4:	30 38       	mov	r8,3
80006bc6:	f0 09 18 00 	cp.b	r9,r8
80006bca:	c4 e1       	brne	80006c66 <sync_fs+0xb2>
80006bcc:	0d d9       	ld.ub	r9,r6[0x5]
80006bce:	30 18       	mov	r8,1
80006bd0:	f0 09 18 00 	cp.b	r9,r8
80006bd4:	c4 91       	brne	80006c66 <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
80006bd6:	ec c5 ff d0 	sub	r5,r6,-48
80006bda:	e0 6a 02 00 	mov	r10,512
80006bde:	30 0b       	mov	r11,0
80006be0:	0a 9c       	mov	r12,r5
80006be2:	f0 1f 00 28 	mcall	80006c80 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
80006be6:	35 58       	mov	r8,85
80006be8:	ed 68 02 2e 	st.b	r6[558],r8
80006bec:	3a a8       	mov	r8,-86
80006bee:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
80006bf2:	35 28       	mov	r8,82
80006bf4:	ed 68 00 30 	st.b	r6[48],r8
80006bf8:	ed 68 00 31 	st.b	r6[49],r8
80006bfc:	36 18       	mov	r8,97
80006bfe:	ed 68 00 32 	st.b	r6[50],r8
80006c02:	34 19       	mov	r9,65
80006c04:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
80006c08:	37 2a       	mov	r10,114
80006c0a:	ed 6a 02 14 	st.b	r6[532],r10
80006c0e:	ed 6a 02 15 	st.b	r6[533],r10
80006c12:	ed 69 02 16 	st.b	r6[534],r9
80006c16:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
80006c1a:	6c 48       	ld.w	r8,r6[0x10]
80006c1c:	ed 68 02 18 	st.b	r6[536],r8
80006c20:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006c24:	ed 69 02 19 	st.b	r6[537],r9
80006c28:	f0 09 16 10 	lsr	r9,r8,0x10
80006c2c:	ed 69 02 1a 	st.b	r6[538],r9
80006c30:	b9 88       	lsr	r8,0x18
80006c32:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
80006c36:	6c 38       	ld.w	r8,r6[0xc]
80006c38:	ed 68 02 1c 	st.b	r6[540],r8
80006c3c:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006c40:	ed 69 02 1d 	st.b	r6[541],r9
80006c44:	f0 09 16 10 	lsr	r9,r8,0x10
80006c48:	ed 69 02 1e 	st.b	r6[542],r9
80006c4c:	b9 88       	lsr	r8,0x18
80006c4e:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
80006c52:	6c 7a       	ld.w	r10,r6[0x1c]
80006c54:	2f fa       	sub	r10,-1
80006c56:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
80006c58:	30 19       	mov	r9,1
80006c5a:	0a 9b       	mov	r11,r5
80006c5c:	0d 9c       	ld.ub	r12,r6[0x1]
80006c5e:	f0 1f 00 0a 	mcall	80006c84 <sync_fs+0xd0>
			fs->fsi_flag = 0;
80006c62:	30 08       	mov	r8,0
80006c64:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
80006c66:	30 0a       	mov	r10,0
80006c68:	14 9b       	mov	r11,r10
80006c6a:	0d 9c       	ld.ub	r12,r6[0x1]
80006c6c:	f0 1f 00 07 	mcall	80006c88 <sync_fs+0xd4>
80006c70:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
80006c74:	0e 9c       	mov	r12,r7
80006c76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006c7a:	00 00       	add	r0,r0
80006c7c:	80 00       	ld.sh	r0,r0[0x0]
80006c7e:	6b 50       	ld.w	r0,r5[0x54]
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	69 d6       	ld.w	r6,r4[0x74]
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	69 88       	ld.w	r8,r4[0x60]
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	69 38       	ld.w	r8,r4[0x4c]

80006c8c <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
80006c8c:	d4 31       	pushm	r0-r7,lr
80006c8e:	20 ad       	sub	sp,40
80006c90:	50 7c       	stdsp	sp[0x1c],r12
80006c92:	16 97       	mov	r7,r11
80006c94:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
80006c96:	30 18       	mov	r8,1
80006c98:	f0 0b 18 00 	cp.b	r11,r8
80006c9c:	e0 88 00 05 	brls	80006ca6 <f_mkfs+0x1a>
80006ca0:	31 3c       	mov	r12,19
80006ca2:	e0 8f 03 16 	bral	800072ce <f_mkfs+0x642>
	vol = get_ldnumber(&path);
80006ca6:	fa cc ff e4 	sub	r12,sp,-28
80006caa:	f0 1f 01 8e 	mcall	800072e0 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
80006cae:	c0 44       	brge	80006cb6 <f_mkfs+0x2a>
80006cb0:	30 bc       	mov	r12,11
80006cb2:	e0 8f 03 0e 	bral	800072ce <f_mkfs+0x642>
	fs = FatFs[vol];
80006cb6:	fe f8 06 2e 	ld.w	r8,pc[1582]
80006cba:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
80006cbe:	58 05       	cp.w	r5,0
80006cc0:	c0 41       	brne	80006cc8 <f_mkfs+0x3c>
80006cc2:	30 cc       	mov	r12,12
80006cc4:	e0 8f 03 05 	bral	800072ce <f_mkfs+0x642>
	fs->fs_type = 0;
80006cc8:	30 08       	mov	r8,0
80006cca:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
80006ccc:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
80006cd0:	08 9c       	mov	r12,r4
80006cd2:	f0 1f 01 86 	mcall	800072e8 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
80006cd6:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006cda:	c0 40       	breq	80006ce2 <f_mkfs+0x56>
80006cdc:	30 3c       	mov	r12,3
80006cde:	e0 8f 02 f8 	bral	800072ce <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
80006ce2:	e2 1c 00 04 	andl	r12,0x4,COH
80006ce6:	c0 40       	breq	80006cee <f_mkfs+0x62>
80006ce8:	30 ac       	mov	r12,10
80006cea:	e0 8f 02 f2 	bral	800072ce <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
80006cee:	fa ca ff e0 	sub	r10,sp,-32
80006cf2:	30 1b       	mov	r11,1
80006cf4:	08 9c       	mov	r12,r4
80006cf6:	f0 1f 01 7e 	mcall	800072ec <f_mkfs+0x660>
80006cfa:	e0 81 02 e7 	brne	800072c8 <f_mkfs+0x63c>
80006cfe:	40 89       	lddsp	r9,sp[0x20]
80006d00:	e0 49 00 7f 	cp.w	r9,127
80006d04:	e0 88 02 e2 	brls	800072c8 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
80006d08:	58 07       	cp.w	r7,0
80006d0a:	f9 b1 01 00 	movne	r1,0
80006d0e:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
80006d12:	02 19       	sub	r9,r1
80006d14:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
80006d16:	ec c8 00 01 	sub	r8,r6,1
80006d1a:	0c 68       	and	r8,r6
80006d1c:	c0 31       	brne	80006d22 <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
80006d1e:	58 06       	cp.w	r6,0
80006d20:	c1 a1       	brne	80006d54 <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
80006d22:	e0 6b 4d d3 	mov	r11,19923
80006d26:	ea 1b 10 62 	orh	r11,0x1062
80006d2a:	f2 0b 06 4a 	mulu.d	r10,r9,r11
80006d2e:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
80006d32:	e0 4c 04 00 	cp.w	r12,1024
80006d36:	c0 33       	brcs	80006d3c <f_mkfs+0xb0>
80006d38:	30 08       	mov	r8,0
80006d3a:	c0 98       	rjmp	80006d4c <f_mkfs+0xc0>
80006d3c:	fe fa 05 b4 	ld.w	r10,pc[1460]
80006d40:	2f ea       	sub	r10,-2
80006d42:	30 08       	mov	r8,0
80006d44:	2f f8       	sub	r8,-1
80006d46:	15 2b       	ld.uh	r11,r10++
80006d48:	16 3c       	cp.w	r12,r11
80006d4a:	cf d3       	brcs	80006d44 <f_mkfs+0xb8>
		au = cst[i];
80006d4c:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006d50:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
80006d54:	e0 46 01 ff 	cp.w	r6,511
80006d58:	e0 88 00 03 	brls	80006d5e <f_mkfs+0xd2>
80006d5c:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
80006d5e:	58 06       	cp.w	r6,0
80006d60:	f9 b6 00 01 	moveq	r6,1
80006d64:	e0 60 00 80 	mov	r0,128
80006d68:	00 36       	cp.w	r6,r0
80006d6a:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
80006d6e:	f2 00 0d 0a 	divu	r10,r9,r0
80006d72:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
80006d74:	e0 4a 0f f6 	cp.w	r10,4086
80006d78:	f9 b3 03 01 	movlo	r3,1
80006d7c:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
80006d80:	e0 4a ff f5 	cp.w	r10,65525
80006d84:	e0 88 00 04 	brls	80006d8c <f_mkfs+0x100>
80006d88:	30 33       	mov	r3,3
80006d8a:	c0 58       	rjmp	80006d94 <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
80006d8c:	30 3a       	mov	r10,3
80006d8e:	f4 03 18 00 	cp.b	r3,r10
80006d92:	c0 a1       	brne	80006da6 <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
80006d94:	a3 68       	lsl	r8,0x2
80006d96:	f0 c2 fd f9 	sub	r2,r8,-519
80006d9a:	a9 92       	lsr	r2,0x9
80006d9c:	30 0b       	mov	r11,0
80006d9e:	50 2b       	stdsp	sp[0x8],r11
80006da0:	32 0a       	mov	r10,32
80006da2:	50 0a       	stdsp	sp[0x0],r10
80006da4:	c1 68       	rjmp	80006dd0 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
80006da6:	30 1a       	mov	r10,1
80006da8:	f4 03 18 00 	cp.b	r3,r10
80006dac:	c0 81       	brne	80006dbc <f_mkfs+0x130>
80006dae:	f0 08 00 18 	add	r8,r8,r8<<0x1
80006db2:	f0 c2 ff ff 	sub	r2,r8,-1
80006db6:	a1 92       	lsr	r2,0x1
80006db8:	2f d2       	sub	r2,-3
80006dba:	c0 48       	rjmp	80006dc2 <f_mkfs+0x136>
80006dbc:	2f e8       	sub	r8,-2
80006dbe:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
80006dc2:	e4 c2 fe 01 	sub	r2,r2,-511
80006dc6:	a9 92       	lsr	r2,0x9
80006dc8:	32 08       	mov	r8,32
80006dca:	50 28       	stdsp	sp[0x8],r8
80006dcc:	30 1c       	mov	r12,1
80006dce:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
80006dd0:	40 0b       	lddsp	r11,sp[0x0]
80006dd2:	02 0b       	add	r11,r1
80006dd4:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
80006dd6:	40 26       	lddsp	r6,sp[0x8]
80006dd8:	04 06       	add	r6,r2
80006dda:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
80006ddc:	e0 01 01 08 	sub	r8,r0,r1
80006de0:	0c 08       	add	r8,r6
80006de2:	10 39       	cp.w	r9,r8
80006de4:	e0 83 02 74 	brlo	800072cc <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
80006de8:	fa ca ff dc 	sub	r10,sp,-36
80006dec:	30 3b       	mov	r11,3
80006dee:	08 9c       	mov	r12,r4
80006df0:	f0 1f 01 3f 	mcall	800072ec <f_mkfs+0x660>
80006df4:	c0 81       	brne	80006e04 <f_mkfs+0x178>
80006df6:	40 98       	lddsp	r8,sp[0x24]
80006df8:	58 08       	cp.w	r8,0
80006dfa:	c0 50       	breq	80006e04 <f_mkfs+0x178>
80006dfc:	e0 48 80 00 	cp.w	r8,32768
80006e00:	e0 88 00 04 	brls	80006e08 <f_mkfs+0x17c>
80006e04:	30 18       	mov	r8,1
80006e06:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
80006e08:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
80006e0a:	f0 c9 00 01 	sub	r9,r8,1
80006e0e:	0c 09       	add	r9,r6
80006e10:	5c 38       	neg	r8
80006e12:	f3 e8 00 08 	and	r8,r9,r8
80006e16:	f0 06 01 06 	sub	r6,r8,r6
80006e1a:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
80006e1c:	30 38       	mov	r8,3
80006e1e:	f0 03 18 00 	cp.b	r3,r8
80006e22:	c1 d1       	brne	80006e5c <f_mkfs+0x1d0>
		n_rsv += n;
80006e24:	40 0a       	lddsp	r10,sp[0x0]
80006e26:	0c 0a       	add	r10,r6
80006e28:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
80006e2a:	40 19       	lddsp	r9,sp[0x4]
80006e2c:	0c 09       	add	r9,r6
80006e2e:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006e30:	40 88       	lddsp	r8,sp[0x20]
80006e32:	f0 0a 01 0b 	sub	r11,r8,r10
80006e36:	04 1b       	sub	r11,r2
80006e38:	40 2c       	lddsp	r12,sp[0x8]
80006e3a:	18 1b       	sub	r11,r12
80006e3c:	f6 00 0d 0a 	divu	r10,r11,r0
80006e40:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006e42:	30 39       	mov	r9,3
80006e44:	f2 03 18 00 	cp.b	r3,r9
80006e48:	5f 0b       	sreq	r11
80006e4a:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006e4c:	e0 4a ff f5 	cp.w	r10,65525
80006e50:	5f 89       	srls	r9
80006e52:	f7 e9 00 09 	and	r9,r11,r9
80006e56:	e0 81 02 3b 	brne	800072cc <f_mkfs+0x640>
80006e5a:	c1 a8       	rjmp	80006e8e <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006e5c:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006e5e:	40 88       	lddsp	r8,sp[0x20]
80006e60:	40 0a       	lddsp	r10,sp[0x0]
80006e62:	f0 0a 01 0b 	sub	r11,r8,r10
80006e66:	04 1b       	sub	r11,r2
80006e68:	40 29       	lddsp	r9,sp[0x8]
80006e6a:	12 1b       	sub	r11,r9
80006e6c:	f6 00 0d 0a 	divu	r10,r11,r0
80006e70:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006e72:	30 29       	mov	r9,2
80006e74:	f2 03 18 00 	cp.b	r3,r9
80006e78:	5f 0a       	sreq	r10
80006e7a:	40 4c       	lddsp	r12,sp[0x10]
80006e7c:	e0 4c 0f f5 	cp.w	r12,4085
80006e80:	5f 89       	srls	r9
80006e82:	f5 e9 00 09 	and	r9,r10,r9
80006e86:	e0 80 02 26 	breq	800072d2 <f_mkfs+0x646>
80006e8a:	e0 8f 02 21 	bral	800072cc <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006e8e:	40 3b       	lddsp	r11,sp[0xc]
80006e90:	58 0b       	cp.w	r11,0
80006e92:	c0 30       	breq	80006e98 <f_mkfs+0x20c>
80006e94:	30 c6       	mov	r6,12
80006e96:	c1 28       	rjmp	80006eba <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
80006e98:	30 19       	mov	r9,1
80006e9a:	f2 03 18 00 	cp.b	r3,r9
80006e9e:	c0 71       	brne	80006eac <f_mkfs+0x220>
80006ea0:	e0 48 ff ff 	cp.w	r8,65535
80006ea4:	e0 8b 00 0a 	brhi	80006eb8 <f_mkfs+0x22c>
80006ea8:	30 16       	mov	r6,1
80006eaa:	c0 88       	rjmp	80006eba <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
80006eac:	e0 48 ff ff 	cp.w	r8,65535
80006eb0:	e0 8b 00 04 	brhi	80006eb8 <f_mkfs+0x22c>
80006eb4:	30 46       	mov	r6,4
80006eb6:	c0 28       	rjmp	80006eba <f_mkfs+0x22e>
80006eb8:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
80006eba:	58 07       	cp.w	r7,0
80006ebc:	c0 40       	breq	80006ec4 <f_mkfs+0x238>
80006ebe:	e0 67 00 f0 	mov	r7,240
80006ec2:	c5 68       	rjmp	80006f6e <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
80006ec4:	ea ca ff d0 	sub	r10,r5,-48
80006ec8:	50 5a       	stdsp	sp[0x14],r10
80006eca:	e0 6a 02 00 	mov	r10,512
80006ece:	30 0b       	mov	r11,0
80006ed0:	40 5c       	lddsp	r12,sp[0x14]
80006ed2:	f0 1f 01 0a 	mcall	800072f8 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
80006ed6:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
80006eda:	30 19       	mov	r9,1
80006edc:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
80006ede:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
80006ee0:	30 09       	mov	r9,0
80006ee2:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
80006ee4:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
80006ee6:	3f ea       	mov	r10,-2
80006ee8:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
80006eea:	40 8b       	lddsp	r11,sp[0x20]
80006eec:	e2 0b 00 0b 	add	r11,r1,r11
80006ef0:	e0 6a 56 5b 	mov	r10,22107
80006ef4:	ea 1a 05 15 	orh	r10,0x515
80006ef8:	f6 0a 06 46 	mulu.d	r6,r11,r10
80006efc:	0e 9c       	mov	r12,r7
80006efe:	f6 0c 01 0a 	sub	r10,r11,r12
80006f02:	a1 9a       	lsr	r10,0x1
80006f04:	f4 0c 00 07 	add	r7,r10,r12
80006f08:	ee 0a 16 0d 	lsr	r10,r7,0xd
80006f0c:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
80006f0e:	ee 0b 16 0f 	lsr	r11,r7,0xf
80006f12:	16 97       	mov	r7,r11
80006f14:	e8 17 00 3f 	orl	r7,0x3f
80006f18:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
80006f1a:	40 9a       	lddsp	r10,sp[0x24]
80006f1c:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
80006f1e:	33 fa       	mov	r10,63
80006f20:	f1 6a 00 08 	st.b	r8[8],r10
80006f24:	f1 69 00 09 	st.b	r8[9],r9
80006f28:	f1 69 00 0a 	st.b	r8[10],r9
80006f2c:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006f30:	40 89       	lddsp	r9,sp[0x20]
80006f32:	f1 69 00 0c 	st.b	r8[12],r9
80006f36:	fb 39 00 22 	ld.ub	r9,sp[34]
80006f3a:	f1 69 00 0d 	st.b	r8[13],r9
80006f3e:	fb 19 00 20 	ld.uh	r9,sp[32]
80006f42:	f1 69 00 0e 	st.b	r8[14],r9
80006f46:	fb 39 00 20 	ld.ub	r9,sp[32]
80006f4a:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006f4e:	35 58       	mov	r8,85
80006f50:	eb 68 02 2e 	st.b	r5[558],r8
80006f54:	3a a8       	mov	r8,-86
80006f56:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006f5a:	30 19       	mov	r9,1
80006f5c:	30 0a       	mov	r10,0
80006f5e:	40 5b       	lddsp	r11,sp[0x14]
80006f60:	08 9c       	mov	r12,r4
80006f62:	f0 1f 00 e7 	mcall	800072fc <f_mkfs+0x670>
80006f66:	e0 81 01 b1 	brne	800072c8 <f_mkfs+0x63c>
80006f6a:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006f6e:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
80006f72:	e0 6a 02 00 	mov	r10,512
80006f76:	30 0b       	mov	r11,0
80006f78:	0c 9c       	mov	r12,r6
80006f7a:	f0 1f 00 e0 	mcall	800072f8 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006f7e:	30 ba       	mov	r10,11
80006f80:	fe fb 03 80 	ld.w	r11,pc[896]
80006f84:	0c 9c       	mov	r12,r6
80006f86:	f0 1f 00 e0 	mcall	80007304 <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006f8a:	ea ca ff c5 	sub	r10,r5,-59
80006f8e:	50 5a       	stdsp	sp[0x14],r10
80006f90:	30 08       	mov	r8,0
80006f92:	b4 88       	st.b	r10[0x0],r8
80006f94:	30 28       	mov	r8,2
80006f96:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
80006f9a:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
80006f9e:	40 09       	lddsp	r9,sp[0x0]
80006fa0:	ed 69 00 0e 	st.b	r6[14],r9
80006fa4:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
80006fa8:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
80006fac:	30 18       	mov	r8,1
80006fae:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
80006fb2:	e0 68 02 00 	mov	r8,512
80006fb6:	40 3c       	lddsp	r12,sp[0xc]
80006fb8:	58 0c       	cp.w	r12,0
80006fba:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
80006fbe:	ed 68 00 11 	st.b	r6[17],r8
80006fc2:	58 08       	cp.w	r8,0
80006fc4:	f9 b8 01 02 	movne	r8,2
80006fc8:	f9 b8 00 00 	moveq	r8,0
80006fcc:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
80006fd0:	40 88       	lddsp	r8,sp[0x20]
80006fd2:	e0 48 ff ff 	cp.w	r8,65535
80006fd6:	e0 8b 00 09 	brhi	80006fe8 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
80006fda:	ed 68 00 13 	st.b	r6[19],r8
80006fde:	fb 38 00 22 	ld.ub	r8,sp[34]
80006fe2:	ed 68 00 14 	st.b	r6[20],r8
80006fe6:	c0 f8       	rjmp	80007004 <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
80006fe8:	ed 68 00 20 	st.b	r6[32],r8
80006fec:	fb 38 00 22 	ld.ub	r8,sp[34]
80006ff0:	ed 68 00 21 	st.b	r6[33],r8
80006ff4:	fb 18 00 20 	ld.uh	r8,sp[32]
80006ff8:	ed 68 00 22 	st.b	r6[34],r8
80006ffc:	fb 38 00 20 	ld.ub	r8,sp[32]
80007000:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
80007004:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
80007008:	33 f8       	mov	r8,63
8000700a:	ed 68 00 18 	st.b	r6[24],r8
8000700e:	30 08       	mov	r8,0
80007010:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
80007014:	3f f9       	mov	r9,-1
80007016:	ed 69 00 1a 	st.b	r6[26],r9
8000701a:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
8000701e:	ed 61 00 1c 	st.b	r6[28],r1
80007022:	30 08       	mov	r8,0
80007024:	ed 68 00 1d 	st.b	r6[29],r8
80007028:	e2 08 16 10 	lsr	r8,r1,0x10
8000702c:	ed 68 00 1e 	st.b	r6[30],r8
80007030:	e2 08 16 18 	lsr	r8,r1,0x18
80007034:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
80007038:	f0 1f 00 b4 	mcall	80007308 <f_mkfs+0x67c>
8000703c:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
8000703e:	40 3a       	lddsp	r10,sp[0xc]
80007040:	58 0a       	cp.w	r10,0
80007042:	c3 f0       	breq	800070c0 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
80007044:	ed 6c 00 43 	st.b	r6[67],r12
80007048:	fb 38 00 26 	ld.ub	r8,sp[38]
8000704c:	ed 68 00 44 	st.b	r6[68],r8
80007050:	fb 18 00 24 	ld.uh	r8,sp[36]
80007054:	ed 68 00 45 	st.b	r6[69],r8
80007058:	fb 38 00 24 	ld.ub	r8,sp[36]
8000705c:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80007060:	ed 62 00 24 	st.b	r6[36],r2
80007064:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80007068:	ed 68 00 25 	st.b	r6[37],r8
8000706c:	e4 08 16 10 	lsr	r8,r2,0x10
80007070:	ed 68 00 26 	st.b	r6[38],r8
80007074:	e4 08 16 18 	lsr	r8,r2,0x18
80007078:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
8000707c:	30 28       	mov	r8,2
8000707e:	ed 68 00 2c 	st.b	r6[44],r8
80007082:	30 08       	mov	r8,0
80007084:	ed 68 00 2d 	st.b	r6[45],r8
80007088:	ed 68 00 2e 	st.b	r6[46],r8
8000708c:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80007090:	30 19       	mov	r9,1
80007092:	ed 69 00 30 	st.b	r6[48],r9
80007096:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
8000709a:	30 69       	mov	r9,6
8000709c:	ed 69 00 32 	st.b	r6[50],r9
800070a0:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
800070a4:	38 08       	mov	r8,-128
800070a6:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
800070aa:	32 98       	mov	r8,41
800070ac:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
800070b0:	31 3a       	mov	r10,19
800070b2:	fe fb 02 5a 	ld.w	r11,pc[602]
800070b6:	ec cc ff b9 	sub	r12,r6,-71
800070ba:	f0 1f 00 93 	mcall	80007304 <f_mkfs+0x678>
800070be:	c2 28       	rjmp	80007102 <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
800070c0:	ed 6c 00 27 	st.b	r6[39],r12
800070c4:	fb 38 00 26 	ld.ub	r8,sp[38]
800070c8:	ed 68 00 28 	st.b	r6[40],r8
800070cc:	fb 18 00 24 	ld.uh	r8,sp[36]
800070d0:	ed 68 00 29 	st.b	r6[41],r8
800070d4:	fb 38 00 24 	ld.ub	r8,sp[36]
800070d8:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
800070dc:	ed 62 00 16 	st.b	r6[22],r2
800070e0:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
800070e4:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
800070e8:	38 08       	mov	r8,-128
800070ea:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
800070ee:	32 98       	mov	r8,41
800070f0:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
800070f4:	31 3a       	mov	r10,19
800070f6:	fe fb 02 1a 	ld.w	r11,pc[538]
800070fa:	ec cc ff d5 	sub	r12,r6,-43
800070fe:	f0 1f 00 82 	mcall	80007304 <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
80007102:	ec c9 fe 02 	sub	r9,r6,-510
80007106:	50 69       	stdsp	sp[0x18],r9
80007108:	35 58       	mov	r8,85
8000710a:	b2 88       	st.b	r9[0x0],r8
8000710c:	ec c8 fe 01 	sub	r8,r6,-511
80007110:	50 08       	stdsp	sp[0x0],r8
80007112:	3a a8       	mov	r8,-86
80007114:	40 0c       	lddsp	r12,sp[0x0]
80007116:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
80007118:	30 19       	mov	r9,1
8000711a:	02 9a       	mov	r10,r1
8000711c:	0c 9b       	mov	r11,r6
8000711e:	08 9c       	mov	r12,r4
80007120:	f0 1f 00 77 	mcall	800072fc <f_mkfs+0x670>
80007124:	e0 81 00 d2 	brne	800072c8 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80007128:	40 3b       	lddsp	r11,sp[0xc]
8000712a:	58 0b       	cp.w	r11,0
8000712c:	c0 80       	breq	8000713c <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
8000712e:	30 19       	mov	r9,1
80007130:	e2 ca ff fa 	sub	r10,r1,-6
80007134:	0c 9b       	mov	r11,r6
80007136:	08 9c       	mov	r12,r4
80007138:	f0 1f 00 71 	mcall	800072fc <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
8000713c:	e0 6a 02 00 	mov	r10,512
80007140:	30 0b       	mov	r11,0
80007142:	0c 9c       	mov	r12,r6
80007144:	f0 1f 00 6d 	mcall	800072f8 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80007148:	30 38       	mov	r8,3
8000714a:	f0 03 18 00 	cp.b	r3,r8
8000714e:	c1 d0       	breq	80007188 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80007150:	30 18       	mov	r8,1
80007152:	fe 7a ff 00 	mov	r10,-256
80007156:	e0 69 ff 00 	mov	r9,65280
8000715a:	ea 19 00 ff 	orh	r9,0xff
8000715e:	e6 08 18 00 	cp.b	r8,r3
80007162:	f2 08 17 00 	moveq	r8,r9
80007166:	f4 08 17 10 	movne	r8,r10
8000716a:	f1 e7 10 07 	or	r7,r8,r7
8000716e:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80007170:	eb 67 00 30 	st.b	r5[48],r7
80007174:	fb 38 00 26 	ld.ub	r8,sp[38]
80007178:	ac 98       	st.b	r6[0x1],r8
8000717a:	fb 18 00 24 	ld.uh	r8,sp[36]
8000717e:	ac a8       	st.b	r6[0x2],r8
80007180:	fb 38 00 24 	ld.ub	r8,sp[36]
80007184:	ac b8       	st.b	r6[0x3],r8
80007186:	c1 f8       	rjmp	800071c4 <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80007188:	ea 17 ff ff 	orh	r7,0xffff
8000718c:	e8 17 ff 00 	orl	r7,0xff00
80007190:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80007192:	eb 67 00 30 	st.b	r5[48],r7
80007196:	fb 38 00 26 	ld.ub	r8,sp[38]
8000719a:	ac 98       	st.b	r6[0x1],r8
8000719c:	fb 18 00 24 	ld.uh	r8,sp[36]
800071a0:	ac a8       	st.b	r6[0x2],r8
800071a2:	fb 38 00 24 	ld.ub	r8,sp[36]
800071a6:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
800071a8:	3f f8       	mov	r8,-1
800071aa:	ac c8       	st.b	r6[0x4],r8
800071ac:	ac d8       	st.b	r6[0x5],r8
800071ae:	ac e8       	st.b	r6[0x6],r8
800071b0:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
800071b2:	ed 68 00 08 	st.b	r6[8],r8
800071b6:	ed 68 00 09 	st.b	r6[9],r8
800071ba:	ed 68 00 0a 	st.b	r6[10],r8
800071be:	30 f8       	mov	r8,15
800071c0:	40 5a       	lddsp	r10,sp[0x14]
800071c2:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
800071c4:	30 19       	mov	r9,1
800071c6:	40 1a       	lddsp	r10,sp[0x4]
800071c8:	0c 9b       	mov	r11,r6
800071ca:	08 9c       	mov	r12,r4
800071cc:	f0 1f 00 4c 	mcall	800072fc <f_mkfs+0x670>
800071d0:	c7 c1       	brne	800072c8 <f_mkfs+0x63c>
800071d2:	40 13       	lddsp	r3,sp[0x4]
800071d4:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
800071d6:	e0 6a 02 00 	mov	r10,512
800071da:	30 0b       	mov	r11,0
800071dc:	0c 9c       	mov	r12,r6
800071de:	f0 1f 00 47 	mcall	800072f8 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
800071e2:	30 18       	mov	r8,1
800071e4:	50 98       	stdsp	sp[0x24],r8
800071e6:	10 32       	cp.w	r2,r8
800071e8:	e0 88 00 11 	brls	8000720a <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
800071ec:	10 97       	mov	r7,r8
800071ee:	0e 99       	mov	r9,r7
800071f0:	06 9a       	mov	r10,r3
800071f2:	0c 9b       	mov	r11,r6
800071f4:	08 9c       	mov	r12,r4
800071f6:	f0 1f 00 42 	mcall	800072fc <f_mkfs+0x670>
800071fa:	c6 71       	brne	800072c8 <f_mkfs+0x63c>
800071fc:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
800071fe:	40 98       	lddsp	r8,sp[0x24]
80007200:	2f f8       	sub	r8,-1
80007202:	50 98       	stdsp	sp[0x24],r8
80007204:	10 32       	cp.w	r2,r8
80007206:	fe 9b ff f4 	brhi	800071ee <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
8000720a:	40 29       	lddsp	r9,sp[0x8]
8000720c:	40 38       	lddsp	r8,sp[0xc]
8000720e:	58 08       	cp.w	r8,0
80007210:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80007214:	30 12       	mov	r2,1
80007216:	06 9a       	mov	r10,r3
80007218:	f4 c7 ff ff 	sub	r7,r10,-1
8000721c:	04 99       	mov	r9,r2
8000721e:	0c 9b       	mov	r11,r6
80007220:	08 9c       	mov	r12,r4
80007222:	f0 1f 00 37 	mcall	800072fc <f_mkfs+0x670>
80007226:	c5 11       	brne	800072c8 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80007228:	20 10       	sub	r0,1
8000722a:	c0 30       	breq	80007230 <f_mkfs+0x5a4>
8000722c:	0e 9a       	mov	r10,r7
8000722e:	cf 5b       	rjmp	80007218 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80007230:	40 3c       	lddsp	r12,sp[0xc]
80007232:	58 0c       	cp.w	r12,0
80007234:	c4 30       	breq	800072ba <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80007236:	35 28       	mov	r8,82
80007238:	eb 68 00 30 	st.b	r5[48],r8
8000723c:	ac 98       	st.b	r6[0x1],r8
8000723e:	36 18       	mov	r8,97
80007240:	ac a8       	st.b	r6[0x2],r8
80007242:	34 19       	mov	r9,65
80007244:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80007246:	37 2a       	mov	r10,114
80007248:	ed 6a 01 e4 	st.b	r6[484],r10
8000724c:	ed 6a 01 e5 	st.b	r6[485],r10
80007250:	ed 69 01 e6 	st.b	r6[486],r9
80007254:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80007258:	40 48       	lddsp	r8,sp[0x10]
8000725a:	20 18       	sub	r8,1
8000725c:	ed 68 01 e8 	st.b	r6[488],r8
80007260:	40 48       	lddsp	r8,sp[0x10]
80007262:	20 18       	sub	r8,1
80007264:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80007268:	ed 68 01 e9 	st.b	r6[489],r8
8000726c:	40 48       	lddsp	r8,sp[0x10]
8000726e:	20 18       	sub	r8,1
80007270:	f0 09 16 10 	lsr	r9,r8,0x10
80007274:	ed 69 01 ea 	st.b	r6[490],r9
80007278:	b9 88       	lsr	r8,0x18
8000727a:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
8000727e:	30 28       	mov	r8,2
80007280:	ed 68 01 ec 	st.b	r6[492],r8
80007284:	30 08       	mov	r8,0
80007286:	ed 68 01 ed 	st.b	r6[493],r8
8000728a:	ed 68 01 ee 	st.b	r6[494],r8
8000728e:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80007292:	35 58       	mov	r8,85
80007294:	40 6b       	lddsp	r11,sp[0x18]
80007296:	b6 88       	st.b	r11[0x0],r8
80007298:	3a a8       	mov	r8,-86
8000729a:	40 0a       	lddsp	r10,sp[0x0]
8000729c:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
8000729e:	30 19       	mov	r9,1
800072a0:	e2 09 00 0a 	add	r10,r1,r9
800072a4:	0c 9b       	mov	r11,r6
800072a6:	08 9c       	mov	r12,r4
800072a8:	f0 1f 00 15 	mcall	800072fc <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
800072ac:	30 19       	mov	r9,1
800072ae:	e2 ca ff f9 	sub	r10,r1,-7
800072b2:	0c 9b       	mov	r11,r6
800072b4:	08 9c       	mov	r12,r4
800072b6:	f0 1f 00 12 	mcall	800072fc <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
800072ba:	30 0a       	mov	r10,0
800072bc:	14 9b       	mov	r11,r10
800072be:	08 9c       	mov	r12,r4
800072c0:	f0 1f 00 0b 	mcall	800072ec <f_mkfs+0x660>
800072c4:	5f 1c       	srne	r12
800072c6:	c0 48       	rjmp	800072ce <f_mkfs+0x642>
800072c8:	30 1c       	mov	r12,1
800072ca:	c0 28       	rjmp	800072ce <f_mkfs+0x642>
800072cc:	30 ec       	mov	r12,14
}
800072ce:	2f 6d       	sub	sp,-40
800072d0:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
800072d2:	30 39       	mov	r9,3
800072d4:	f2 03 18 00 	cp.b	r3,r9
800072d8:	5f 09       	sreq	r9
800072da:	50 39       	stdsp	sp[0xc],r9
800072dc:	fe 9f fd d9 	bral	80006e8e <f_mkfs+0x202>
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	6a 94       	ld.w	r4,r5[0x24]
800072e4:	00 00       	add	r0,r0
800072e6:	11 e4       	ld.ub	r4,r8[0x6]
800072e8:	80 00       	ld.sh	r0,r0[0x0]
800072ea:	68 fa       	ld.w	r10,r4[0x3c]
800072ec:	80 00       	ld.sh	r0,r0[0x0]
800072ee:	69 38       	ld.w	r8,r4[0x4c]
800072f0:	80 01       	ld.sh	r1,r0[0x0]
800072f2:	99 42       	st.w	r12[0x10],r2
800072f4:	80 01       	ld.sh	r1,r0[0x0]
800072f6:	99 2c       	st.w	r12[0x8],r12
800072f8:	80 00       	ld.sh	r0,r0[0x0]
800072fa:	69 d6       	ld.w	r6,r4[0x74]
800072fc:	80 00       	ld.sh	r0,r0[0x0]
800072fe:	69 88       	ld.w	r8,r4[0x60]
80007300:	80 01       	ld.sh	r1,r0[0x0]
80007302:	99 5c       	st.w	r12[0x14],r12
80007304:	80 00       	ld.sh	r0,r0[0x0]
80007306:	69 c0       	ld.w	r0,r4[0x70]
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	68 fc       	ld.w	r12,r4[0x3c]
8000730c:	80 01       	ld.sh	r1,r0[0x0]
8000730e:	99 68       	st.w	r12[0x18],r8
80007310:	80 01       	ld.sh	r1,r0[0x0]
80007312:	99 7c       	st.w	r12[0x1c],r12

80007314 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80007314:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80007316:	58 0c       	cp.w	r12,0
80007318:	c1 40       	breq	80007340 <validate+0x2c>
8000731a:	78 08       	ld.w	r8,r12[0x0]
8000731c:	58 08       	cp.w	r8,0
8000731e:	c1 10       	breq	80007340 <validate+0x2c>
80007320:	11 8a       	ld.ub	r10,r8[0x0]
80007322:	30 09       	mov	r9,0
80007324:	f2 0a 18 00 	cp.b	r10,r9
80007328:	c0 c0       	breq	80007340 <validate+0x2c>
8000732a:	90 3a       	ld.sh	r10,r8[0x6]
8000732c:	98 29       	ld.sh	r9,r12[0x4]
8000732e:	f2 0a 19 00 	cp.h	r10,r9
80007332:	c0 71       	brne	80007340 <validate+0x2c>
80007334:	11 9c       	ld.ub	r12,r8[0x1]
80007336:	f0 1f 00 04 	mcall	80007344 <validate+0x30>
8000733a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000733e:	c0 20       	breq	80007342 <validate+0x2e>
80007340:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80007342:	d8 02       	popm	pc
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	68 f8       	ld.w	r8,r4[0x3c]

80007348 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80007348:	eb cd 40 e0 	pushm	r5-r7,lr
8000734c:	18 97       	mov	r7,r12
8000734e:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80007350:	78 b8       	ld.w	r8,r12[0x2c]
80007352:	16 38       	cp.w	r8,r11
80007354:	c0 31       	brne	8000735a <move_window+0x12>
80007356:	30 06       	mov	r6,0
80007358:	c1 18       	rjmp	8000737a <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
8000735a:	f0 1f 00 0a 	mcall	80007380 <move_window+0x38>
8000735e:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80007360:	c0 d1       	brne	8000737a <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80007362:	30 19       	mov	r9,1
80007364:	0a 9a       	mov	r10,r5
80007366:	ee cb ff d0 	sub	r11,r7,-48
8000736a:	0f 9c       	ld.ub	r12,r7[0x1]
8000736c:	f0 1f 00 06 	mcall	80007384 <move_window+0x3c>
80007370:	f9 b6 01 01 	movne	r6,1
80007374:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80007378:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
8000737a:	0c 9c       	mov	r12,r6
8000737c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	6b 50       	ld.w	r0,r5[0x54]
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	69 a4       	ld.w	r4,r4[0x68]

80007388 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80007388:	eb cd 40 80 	pushm	r7,lr
8000738c:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
8000738e:	30 08       	mov	r8,0
80007390:	b8 c8       	st.b	r12[0x4],r8
80007392:	3f f8       	mov	r8,-1
80007394:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80007396:	f0 1f 00 23 	mcall	80007420 <check_fs+0x98>
8000739a:	c0 40       	breq	800073a2 <check_fs+0x1a>
8000739c:	30 3c       	mov	r12,3
8000739e:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
800073a2:	ef 39 02 2f 	ld.ub	r9,r7[559]
800073a6:	ef 38 02 2e 	ld.ub	r8,r7[558]
800073aa:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800073ae:	fe 78 aa 55 	mov	r8,-21931
800073b2:	f0 09 19 00 	cp.h	r9,r8
800073b6:	c0 40       	breq	800073be <check_fs+0x36>
800073b8:	30 2c       	mov	r12,2
800073ba:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
800073be:	ef 39 00 69 	ld.ub	r9,r7[105]
800073c2:	ef 38 00 68 	ld.ub	r8,r7[104]
800073c6:	b1 68       	lsl	r8,0x10
800073c8:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800073cc:	ef 39 00 66 	ld.ub	r9,r7[102]
800073d0:	12 48       	or	r8,r9
800073d2:	ef 39 00 67 	ld.ub	r9,r7[103]
800073d6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800073da:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
800073de:	e0 69 41 46 	mov	r9,16710
800073e2:	ea 19 00 54 	orh	r9,0x54
800073e6:	12 38       	cp.w	r8,r9
800073e8:	c0 31       	brne	800073ee <check_fs+0x66>
800073ea:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
800073ee:	ef 39 00 85 	ld.ub	r9,r7[133]
800073f2:	ef 38 00 84 	ld.ub	r8,r7[132]
800073f6:	b1 68       	lsl	r8,0x10
800073f8:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800073fc:	ef 39 00 82 	ld.ub	r9,r7[130]
80007400:	12 48       	or	r8,r9
80007402:	ef 39 00 83 	ld.ub	r9,r7[131]
80007406:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000740a:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
8000740e:	e0 69 41 46 	mov	r9,16710
80007412:	ea 19 00 54 	orh	r9,0x54
80007416:	12 38       	cp.w	r8,r9
80007418:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
8000741a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000741e:	00 00       	add	r0,r0
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	73 48       	ld.w	r8,r9[0x50]

80007424 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80007424:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80007428:	20 4d       	sub	sp,16
8000742a:	18 95       	mov	r5,r12
8000742c:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
8000742e:	30 08       	mov	r8,0
80007430:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80007432:	16 9c       	mov	r12,r11
80007434:	f0 1f 00 de 	mcall	800077ac <find_volume+0x388>
80007438:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
8000743a:	c0 34       	brge	80007440 <find_volume+0x1c>
8000743c:	30 bc       	mov	r12,11
8000743e:	ca a9       	rjmp	80007792 <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80007440:	fe f8 03 70 	ld.w	r8,pc[880]
80007444:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80007448:	58 07       	cp.w	r7,0
8000744a:	c0 31       	brne	80007450 <find_volume+0x2c>
8000744c:	30 cc       	mov	r12,12
8000744e:	ca 29       	rjmp	80007792 <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80007450:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
80007452:	0f 89       	ld.ub	r9,r7[0x0]
80007454:	30 08       	mov	r8,0
80007456:	f0 09 18 00 	cp.b	r9,r8
8000745a:	c0 f0       	breq	80007478 <find_volume+0x54>
		stat = disk_status(fs->drv);
8000745c:	0f 9c       	ld.ub	r12,r7[0x1]
8000745e:	f0 1f 00 d6 	mcall	800077b4 <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
80007462:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80007466:	c0 91       	brne	80007478 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80007468:	58 04       	cp.w	r4,0
8000746a:	e0 80 01 91 	breq	8000778c <find_volume+0x368>
8000746e:	e2 1c 00 04 	andl	r12,0x4,COH
80007472:	e0 81 01 8b 	brne	80007788 <find_volume+0x364>
80007476:	c8 b9       	rjmp	8000778c <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80007478:	30 08       	mov	r8,0
8000747a:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
8000747c:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80007480:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
80007482:	f0 1f 00 ce 	mcall	800077b8 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
80007486:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
8000748a:	c0 30       	breq	80007490 <find_volume+0x6c>
8000748c:	30 3c       	mov	r12,3
8000748e:	c8 29       	rjmp	80007792 <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80007490:	58 04       	cp.w	r4,0
80007492:	c0 50       	breq	8000749c <find_volume+0x78>
80007494:	e2 1c 00 04 	andl	r12,0x4,COH
80007498:	e0 81 01 78 	brne	80007788 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
8000749c:	30 0b       	mov	r11,0
8000749e:	0e 9c       	mov	r12,r7
800074a0:	f0 1f 00 c7 	mcall	800077bc <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
800074a4:	30 18       	mov	r8,1
800074a6:	f0 0c 18 00 	cp.b	r12,r8
800074aa:	c0 30       	breq	800074b0 <find_volume+0x8c>
800074ac:	30 05       	mov	r5,0
800074ae:	c3 48       	rjmp	80007516 <find_volume+0xf2>
800074b0:	1a 96       	mov	r6,sp
800074b2:	1a 9a       	mov	r10,sp
800074b4:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
800074b8:	30 0c       	mov	r12,0
800074ba:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
800074bc:	f0 c9 ff d0 	sub	r9,r8,-48
800074c0:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
800074c4:	13 cb       	ld.ub	r11,r9[0x4]
800074c6:	f8 0b 18 00 	cp.b	r11,r12
800074ca:	c0 31       	brne	800074d0 <find_volume+0xac>
800074cc:	08 99       	mov	r9,r4
800074ce:	c0 f8       	rjmp	800074ec <find_volume+0xc8>
800074d0:	f3 35 00 0b 	ld.ub	r5,r9[11]
800074d4:	f3 3b 00 0a 	ld.ub	r11,r9[10]
800074d8:	b1 6b       	lsl	r11,0x10
800074da:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
800074de:	f3 35 00 08 	ld.ub	r5,r9[8]
800074e2:	0a 4b       	or	r11,r5
800074e4:	f3 39 00 09 	ld.ub	r9,r9[9]
800074e8:	f7 e9 10 89 	or	r9,r11,r9<<0x8
800074ec:	14 a9       	st.w	r10++,r9
800074ee:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
800074f0:	e0 48 01 fe 	cp.w	r8,510
800074f4:	ce 41       	brne	800074bc <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
800074f6:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
800074fa:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
800074fc:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
800074fe:	58 05       	cp.w	r5,0
80007500:	c0 31       	brne	80007506 <find_volume+0xe2>
80007502:	06 9c       	mov	r12,r3
80007504:	c0 68       	rjmp	80007510 <find_volume+0xec>
80007506:	0a 9b       	mov	r11,r5
80007508:	0e 9c       	mov	r12,r7
8000750a:	f0 1f 00 ad 	mcall	800077bc <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
8000750e:	c0 d0       	breq	80007528 <find_volume+0x104>
80007510:	2f c6       	sub	r6,-4
80007512:	08 36       	cp.w	r6,r4
80007514:	cf 41       	brne	800074fc <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80007516:	30 38       	mov	r8,3
80007518:	f0 0c 18 00 	cp.b	r12,r8
8000751c:	c0 31       	brne	80007522 <find_volume+0xfe>
8000751e:	30 1c       	mov	r12,1
80007520:	c3 99       	rjmp	80007792 <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
80007522:	58 0c       	cp.w	r12,0
80007524:	e0 81 01 36 	brne	80007790 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80007528:	ef 39 00 3c 	ld.ub	r9,r7[60]
8000752c:	ef 38 00 3b 	ld.ub	r8,r7[59]
80007530:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80007534:	e0 68 02 00 	mov	r8,512
80007538:	f0 09 19 00 	cp.h	r9,r8
8000753c:	e0 81 01 2a 	brne	80007790 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
80007540:	ef 39 00 47 	ld.ub	r9,r7[71]
80007544:	ef 38 00 46 	ld.ub	r8,r7[70]
80007548:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
8000754c:	c1 01       	brne	8000756c <find_volume+0x148>
8000754e:	ef 39 00 57 	ld.ub	r9,r7[87]
80007552:	ef 38 00 56 	ld.ub	r8,r7[86]
80007556:	b1 68       	lsl	r8,0x10
80007558:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000755c:	ef 38 00 54 	ld.ub	r8,r7[84]
80007560:	f3 e8 10 08 	or	r8,r9,r8
80007564:	ef 39 00 55 	ld.ub	r9,r7[85]
80007568:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
8000756c:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
8000756e:	ef 39 00 40 	ld.ub	r9,r7[64]
80007572:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
80007574:	f2 cb 00 01 	sub	r11,r9,1
80007578:	30 1a       	mov	r10,1
8000757a:	f4 0b 18 00 	cp.b	r11,r10
8000757e:	e0 8b 01 09 	brhi	80007790 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
80007582:	ef 3a 00 3d 	ld.ub	r10,r7[61]
80007586:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80007588:	58 0a       	cp.w	r10,0
8000758a:	e0 80 01 03 	breq	80007790 <find_volume+0x36c>
8000758e:	f4 cb 00 01 	sub	r11,r10,1
80007592:	14 6b       	and	r11,r10
80007594:	e0 81 00 fe 	brne	80007790 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80007598:	ef 3c 00 42 	ld.ub	r12,r7[66]
8000759c:	ef 3b 00 41 	ld.ub	r11,r7[65]
800075a0:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
800075a4:	5c 8b       	casts.h	r11
800075a6:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
800075a8:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
800075ac:	e0 81 00 f2 	brne	80007790 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
800075b0:	ef 36 00 44 	ld.ub	r6,r7[68]
800075b4:	ef 3c 00 43 	ld.ub	r12,r7[67]
800075b8:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
800075bc:	c1 01       	brne	800075dc <find_volume+0x1b8>
800075be:	ef 36 00 53 	ld.ub	r6,r7[83]
800075c2:	ef 3c 00 52 	ld.ub	r12,r7[82]
800075c6:	b1 6c       	lsl	r12,0x10
800075c8:	f9 e6 11 86 	or	r6,r12,r6<<0x18
800075cc:	ef 3c 00 50 	ld.ub	r12,r7[80]
800075d0:	ed ec 10 0c 	or	r12,r6,r12
800075d4:	ef 36 00 51 	ld.ub	r6,r7[81]
800075d8:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
800075dc:	ef 34 00 3f 	ld.ub	r4,r7[63]
800075e0:	ef 36 00 3e 	ld.ub	r6,r7[62]
800075e4:	ed e4 10 86 	or	r6,r6,r4<<0x8
800075e8:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
800075ea:	e0 80 00 d3 	breq	80007790 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
800075ee:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
800075f0:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
800075f4:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
800075f8:	06 04       	add	r4,r3
800075fa:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
800075fc:	08 3c       	cp.w	r12,r4
800075fe:	e0 83 00 c9 	brlo	80007790 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
80007602:	f8 04 01 01 	sub	r1,r12,r4
80007606:	e2 0a 0d 00 	divu	r0,r1,r10
8000760a:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
8000760c:	58 00       	cp.w	r0,0
8000760e:	e0 80 00 c1 	breq	80007790 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
80007612:	e0 40 0f f6 	cp.w	r0,4086
80007616:	f9 b6 03 01 	movlo	r6,1
8000761a:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
8000761e:	e0 40 ff f5 	cp.w	r0,65525
80007622:	e0 8b 00 bb 	brhi	80007798 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007626:	2f e9       	sub	r9,-2
80007628:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
8000762a:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
8000762c:	ea 03 00 03 	add	r3,r5,r3
80007630:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80007632:	0a 04       	add	r4,r5
80007634:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80007636:	30 3a       	mov	r10,3
80007638:	f4 06 18 00 	cp.b	r6,r10
8000763c:	c1 61       	brne	80007668 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
8000763e:	58 0b       	cp.w	r11,0
80007640:	e0 81 00 a8 	brne	80007790 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80007644:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80007648:	ef 38 00 5e 	ld.ub	r8,r7[94]
8000764c:	b1 68       	lsl	r8,0x10
8000764e:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80007652:	ef 38 00 5c 	ld.ub	r8,r7[92]
80007656:	f5 e8 10 08 	or	r8,r10,r8
8000765a:	ef 3a 00 5d 	ld.ub	r10,r7[93]
8000765e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80007662:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
80007664:	a3 69       	lsl	r9,0x2
80007666:	c1 38       	rjmp	8000768c <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80007668:	58 0b       	cp.w	r11,0
8000766a:	e0 80 00 93 	breq	80007790 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
8000766e:	06 08       	add	r8,r3
80007670:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
80007672:	30 28       	mov	r8,2
80007674:	f0 06 18 00 	cp.b	r6,r8
80007678:	c0 31       	brne	8000767e <find_volume+0x25a>
8000767a:	a1 79       	lsl	r9,0x1
8000767c:	c0 88       	rjmp	8000768c <find_volume+0x268>
8000767e:	f2 09 00 18 	add	r8,r9,r9<<0x1
80007682:	a1 98       	lsr	r8,0x1
80007684:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80007688:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
8000768c:	f2 c8 fe 01 	sub	r8,r9,-511
80007690:	a9 98       	lsr	r8,0x9
80007692:	6e 69       	ld.w	r9,r7[0x18]
80007694:	10 39       	cp.w	r9,r8
80007696:	c7 d3       	brcs	80007790 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80007698:	3f f8       	mov	r8,-1
8000769a:	8f 48       	st.w	r7[0x10],r8
8000769c:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
8000769e:	38 08       	mov	r8,-128
800076a0:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
800076a2:	30 38       	mov	r8,3
800076a4:	f0 06 18 00 	cp.b	r6,r8
800076a8:	c6 81       	brne	80007778 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
800076aa:	ef 39 00 61 	ld.ub	r9,r7[97]
800076ae:	ef 38 00 60 	ld.ub	r8,r7[96]
800076b2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800076b6:	30 18       	mov	r8,1
800076b8:	f0 09 19 00 	cp.h	r9,r8
800076bc:	c5 e1       	brne	80007778 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
800076be:	ea cb ff ff 	sub	r11,r5,-1
800076c2:	0e 9c       	mov	r12,r7
800076c4:	f0 1f 00 3f 	mcall	800077c0 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
800076c8:	c5 81       	brne	80007778 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
800076ca:	30 08       	mov	r8,0
800076cc:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
800076ce:	ef 39 02 2f 	ld.ub	r9,r7[559]
800076d2:	ef 38 02 2e 	ld.ub	r8,r7[558]
800076d6:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800076da:	fe 78 aa 55 	mov	r8,-21931
800076de:	f0 09 19 00 	cp.h	r9,r8
800076e2:	c4 b1       	brne	80007778 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
800076e4:	ef 39 00 33 	ld.ub	r9,r7[51]
800076e8:	ef 38 00 32 	ld.ub	r8,r7[50]
800076ec:	b1 68       	lsl	r8,0x10
800076ee:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800076f2:	ef 38 00 30 	ld.ub	r8,r7[48]
800076f6:	f3 e8 10 08 	or	r8,r9,r8
800076fa:	ef 39 00 31 	ld.ub	r9,r7[49]
800076fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007702:	e0 69 52 52 	mov	r9,21074
80007706:	ea 19 41 61 	orh	r9,0x4161
8000770a:	12 38       	cp.w	r8,r9
8000770c:	c3 61       	brne	80007778 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
8000770e:	ef 39 02 17 	ld.ub	r9,r7[535]
80007712:	ef 38 02 16 	ld.ub	r8,r7[534]
80007716:	b1 68       	lsl	r8,0x10
80007718:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000771c:	ef 38 02 14 	ld.ub	r8,r7[532]
80007720:	f3 e8 10 08 	or	r8,r9,r8
80007724:	ef 39 02 15 	ld.ub	r9,r7[533]
80007728:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000772c:	e0 69 72 72 	mov	r9,29298
80007730:	ea 19 61 41 	orh	r9,0x6141
80007734:	12 38       	cp.w	r8,r9
80007736:	c2 11       	brne	80007778 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
80007738:	ef 39 02 1b 	ld.ub	r9,r7[539]
8000773c:	ef 38 02 1a 	ld.ub	r8,r7[538]
80007740:	b1 68       	lsl	r8,0x10
80007742:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007746:	ef 38 02 18 	ld.ub	r8,r7[536]
8000774a:	f3 e8 10 08 	or	r8,r9,r8
8000774e:	ef 39 02 19 	ld.ub	r9,r7[537]
80007752:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007756:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
80007758:	ef 39 02 1f 	ld.ub	r9,r7[543]
8000775c:	ef 38 02 1e 	ld.ub	r8,r7[542]
80007760:	b1 68       	lsl	r8,0x10
80007762:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007766:	ef 38 02 1c 	ld.ub	r8,r7[540]
8000776a:	f3 e8 10 08 	or	r8,r9,r8
8000776e:	ef 39 02 1d 	ld.ub	r9,r7[541]
80007772:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007776:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
80007778:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
8000777a:	49 39       	lddpc	r9,800077c4 <find_volume+0x3a0>
8000777c:	92 08       	ld.sh	r8,r9[0x0]
8000777e:	2f f8       	sub	r8,-1
80007780:	b2 08       	st.h	r9[0x0],r8
80007782:	ae 38       	st.h	r7[0x6],r8
80007784:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
80007786:	c0 68       	rjmp	80007792 <find_volume+0x36e>
80007788:	30 ac       	mov	r12,10
8000778a:	c0 48       	rjmp	80007792 <find_volume+0x36e>
8000778c:	30 0c       	mov	r12,0
8000778e:	c0 28       	rjmp	80007792 <find_volume+0x36e>
80007790:	30 dc       	mov	r12,13
}
80007792:	2f cd       	sub	sp,-16
80007794:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007798:	2f e9       	sub	r9,-2
8000779a:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
8000779c:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
8000779e:	ea 03 00 03 	add	r3,r5,r3
800077a2:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
800077a4:	0a 04       	add	r4,r5
800077a6:	8f a4       	st.w	r7[0x28],r4
800077a8:	30 36       	mov	r6,3
800077aa:	c4 ab       	rjmp	8000763e <find_volume+0x21a>
800077ac:	80 00       	ld.sh	r0,r0[0x0]
800077ae:	6a 94       	ld.w	r4,r5[0x24]
800077b0:	00 00       	add	r0,r0
800077b2:	11 e4       	ld.ub	r4,r8[0x6]
800077b4:	80 00       	ld.sh	r0,r0[0x0]
800077b6:	68 f8       	ld.w	r8,r4[0x3c]
800077b8:	80 00       	ld.sh	r0,r0[0x0]
800077ba:	68 fa       	ld.w	r10,r4[0x3c]
800077bc:	80 00       	ld.sh	r0,r0[0x0]
800077be:	73 88       	ld.w	r8,r9[0x60]
800077c0:	80 00       	ld.sh	r0,r0[0x0]
800077c2:	73 48       	ld.w	r8,r9[0x50]
800077c4:	00 00       	add	r0,r0
800077c6:	11 e0       	ld.ub	r0,r8[0x6]

800077c8 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
800077c8:	eb cd 40 40 	pushm	r6,lr
800077cc:	20 3d       	sub	sp,12
800077ce:	50 1c       	stdsp	sp[0x4],r12
800077d0:	50 0b       	stdsp	sp[0x0],r11
800077d2:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
800077d4:	fa cc ff f4 	sub	r12,sp,-12
800077d8:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
800077da:	f0 1f 00 1a 	mcall	80007840 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
800077de:	c0 34       	brge	800077e4 <f_mount+0x1c>
800077e0:	30 bc       	mov	r12,11
800077e2:	c2 58       	rjmp	8000782c <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
800077e4:	49 88       	lddpc	r8,80007844 <f_mount+0x7c>
800077e6:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
800077ea:	58 08       	cp.w	r8,0
800077ec:	f9 b9 01 00 	movne	r9,0
800077f0:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
800077f4:	40 18       	lddsp	r8,sp[0x4]
800077f6:	58 08       	cp.w	r8,0
800077f8:	c1 d0       	breq	80007832 <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
800077fa:	30 09       	mov	r9,0
800077fc:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
800077fe:	40 18       	lddsp	r8,sp[0x4]
80007800:	49 1a       	lddpc	r10,80007844 <f_mount+0x7c>
80007802:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
80007806:	58 08       	cp.w	r8,0
80007808:	5f 0a       	sreq	r10
8000780a:	30 18       	mov	r8,1
8000780c:	f0 06 18 00 	cp.b	r6,r8
80007810:	5f 18       	srne	r8
80007812:	f5 e8 10 08 	or	r8,r10,r8
80007816:	f2 08 18 00 	cp.b	r8,r9
8000781a:	c0 30       	breq	80007820 <f_mount+0x58>
8000781c:	30 0c       	mov	r12,0
8000781e:	c0 78       	rjmp	8000782c <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
80007820:	30 0a       	mov	r10,0
80007822:	1a 9b       	mov	r11,sp
80007824:	fa cc ff fc 	sub	r12,sp,-4
80007828:	f0 1f 00 08 	mcall	80007848 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
8000782c:	2f dd       	sub	sp,-12
8000782e:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
80007832:	30 08       	mov	r8,0
80007834:	48 49       	lddpc	r9,80007844 <f_mount+0x7c>
80007836:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
8000783a:	10 9c       	mov	r12,r8
8000783c:	cf 8b       	rjmp	8000782c <f_mount+0x64>
8000783e:	00 00       	add	r0,r0
80007840:	80 00       	ld.sh	r0,r0[0x0]
80007842:	6a 94       	ld.w	r4,r5[0x24]
80007844:	00 00       	add	r0,r0
80007846:	11 e4       	ld.ub	r4,r8[0x6]
80007848:	80 00       	ld.sh	r0,r0[0x0]
8000784a:	74 24       	ld.w	r4,r10[0x8]

8000784c <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
8000784c:	eb cd 40 c0 	pushm	r6-r7,lr
80007850:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
80007852:	f0 1f 00 2b 	mcall	800078fc <f_sync+0xb0>
	if (res == FR_OK) {
80007856:	c5 11       	brne	800078f8 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
80007858:	0f e8       	ld.ub	r8,r7[0x6]
8000785a:	10 99       	mov	r9,r8
8000785c:	e2 19 00 20 	andl	r9,0x20,COH
80007860:	c4 c0       	breq	800078f8 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
80007862:	e2 18 00 40 	andl	r8,0x40,COH
80007866:	c0 f0       	breq	80007884 <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80007868:	6e 08       	ld.w	r8,r7[0x0]
8000786a:	30 19       	mov	r9,1
8000786c:	6e 6a       	ld.w	r10,r7[0x18]
8000786e:	ee cb ff d8 	sub	r11,r7,-40
80007872:	11 9c       	ld.ub	r12,r8[0x1]
80007874:	f0 1f 00 23 	mcall	80007900 <f_sync+0xb4>
80007878:	c0 30       	breq	8000787e <f_sync+0x32>
8000787a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
8000787e:	0f e8       	ld.ub	r8,r7[0x6]
80007880:	a7 c8       	cbr	r8,0x6
80007882:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
80007884:	6e 7b       	ld.w	r11,r7[0x1c]
80007886:	6e 0c       	ld.w	r12,r7[0x0]
80007888:	f0 1f 00 1f 	mcall	80007904 <f_sync+0xb8>
			if (res == FR_OK) {
8000788c:	c3 61       	brne	800078f8 <f_sync+0xac>
				dir = fp->dir_ptr;
8000788e:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
80007890:	ec c8 ff f5 	sub	r8,r6,-11
80007894:	11 89       	ld.ub	r9,r8[0x0]
80007896:	a5 b9       	sbr	r9,0x5
80007898:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
8000789a:	6e 38       	ld.w	r8,r7[0xc]
8000789c:	ed 68 00 1c 	st.b	r6[28],r8
800078a0:	ef 38 00 0e 	ld.ub	r8,r7[14]
800078a4:	ed 68 00 1d 	st.b	r6[29],r8
800078a8:	8e e8       	ld.uh	r8,r7[0xc]
800078aa:	ed 68 00 1e 	st.b	r6[30],r8
800078ae:	ef 38 00 0c 	ld.ub	r8,r7[12]
800078b2:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
800078b6:	6e 4b       	ld.w	r11,r7[0x10]
800078b8:	0c 9c       	mov	r12,r6
800078ba:	f0 1f 00 14 	mcall	80007908 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
800078be:	f0 1f 00 14 	mcall	8000790c <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
800078c2:	ed 6c 00 16 	st.b	r6[22],r12
800078c6:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
800078ca:	ed 68 00 17 	st.b	r6[23],r8
800078ce:	f8 08 16 10 	lsr	r8,r12,0x10
800078d2:	ed 68 00 18 	st.b	r6[24],r8
800078d6:	b9 8c       	lsr	r12,0x18
800078d8:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
800078dc:	30 08       	mov	r8,0
800078de:	ed 68 00 12 	st.b	r6[18],r8
800078e2:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
800078e6:	0f e8       	ld.ub	r8,r7[0x6]
800078e8:	a5 d8       	cbr	r8,0x5
800078ea:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
800078ec:	6e 08       	ld.w	r8,r7[0x0]
800078ee:	30 19       	mov	r9,1
800078f0:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
800078f2:	6e 0c       	ld.w	r12,r7[0x0]
800078f4:	f0 1f 00 07 	mcall	80007910 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
800078f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800078fc:	80 00       	ld.sh	r0,r0[0x0]
800078fe:	73 14       	ld.w	r4,r9[0x44]
80007900:	80 00       	ld.sh	r0,r0[0x0]
80007902:	69 88       	ld.w	r8,r4[0x60]
80007904:	80 00       	ld.sh	r0,r0[0x0]
80007906:	73 48       	ld.w	r8,r9[0x50]
80007908:	80 00       	ld.sh	r0,r0[0x0]
8000790a:	6a 7a       	ld.w	r10,r5[0x1c]
8000790c:	80 00       	ld.sh	r0,r0[0x0]
8000790e:	68 fc       	ld.w	r12,r4[0x3c]
80007910:	80 00       	ld.sh	r0,r0[0x0]
80007912:	6b b4       	ld.w	r4,r5[0x6c]

80007914 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
80007914:	eb cd 40 80 	pushm	r7,lr
80007918:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
8000791a:	f0 1f 00 07 	mcall	80007934 <f_close+0x20>
	if (res == FR_OK)
8000791e:	c0 81       	brne	8000792e <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
80007920:	0e 9c       	mov	r12,r7
80007922:	f0 1f 00 06 	mcall	80007938 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
80007926:	f9 b8 00 00 	moveq	r8,0
8000792a:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
8000792e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007932:	00 00       	add	r0,r0
80007934:	80 00       	ld.sh	r0,r0[0x0]
80007936:	78 4c       	ld.w	r12,r12[0x10]
80007938:	80 00       	ld.sh	r0,r0[0x0]
8000793a:	73 14       	ld.w	r4,r9[0x44]

8000793c <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
8000793c:	d4 21       	pushm	r4-r7,lr
8000793e:	18 97       	mov	r7,r12
80007940:	16 96       	mov	r6,r11
80007942:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007944:	58 1b       	cp.w	r11,1
80007946:	e0 88 00 90 	brls	80007a66 <put_fat+0x12a>
8000794a:	78 58       	ld.w	r8,r12[0x14]
8000794c:	10 3b       	cp.w	r11,r8
8000794e:	e0 82 00 8c 	brhs	80007a66 <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
80007952:	19 88       	ld.ub	r8,r12[0x0]
80007954:	30 29       	mov	r9,2
80007956:	f2 08 18 00 	cp.b	r8,r9
8000795a:	c4 d0       	breq	800079f4 <put_fat+0xb8>
8000795c:	30 39       	mov	r9,3
8000795e:	f2 08 18 00 	cp.b	r8,r9
80007962:	c5 e0       	breq	80007a1e <put_fat+0xe2>
80007964:	30 19       	mov	r9,1
80007966:	f2 08 18 00 	cp.b	r8,r9
8000796a:	c7 e1       	brne	80007a66 <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
8000796c:	f6 04 16 01 	lsr	r4,r11,0x1
80007970:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
80007972:	e8 0b 16 09 	lsr	r11,r4,0x9
80007976:	78 88       	ld.w	r8,r12[0x20]
80007978:	10 0b       	add	r11,r8
8000797a:	f0 1f 00 3d 	mcall	80007a6c <put_fat+0x130>
			if (res != FR_OK) break;
8000797e:	c7 51       	brne	80007a68 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
80007980:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
80007984:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
80007986:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
8000798a:	c0 d0       	breq	800079a4 <put_fat+0x68>
8000798c:	ee 08 00 09 	add	r9,r7,r8
80007990:	f3 39 00 30 	ld.ub	r9,r9[48]
80007994:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
80007998:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
8000799c:	f3 ea 10 49 	or	r9,r9,r10<<0x4
800079a0:	5c 59       	castu.b	r9
800079a2:	c0 38       	rjmp	800079a8 <put_fat+0x6c>
800079a4:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
800079a8:	ee 08 00 08 	add	r8,r7,r8
800079ac:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
800079b0:	30 18       	mov	r8,1
800079b2:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
800079b4:	e8 0b 16 09 	lsr	r11,r4,0x9
800079b8:	6e 88       	ld.w	r8,r7[0x20]
800079ba:	10 0b       	add	r11,r8
800079bc:	0e 9c       	mov	r12,r7
800079be:	f0 1f 00 2c 	mcall	80007a6c <put_fat+0x130>
			if (res != FR_OK) break;
800079c2:	c5 31       	brne	80007a68 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
800079c4:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
800079c8:	58 06       	cp.w	r6,0
800079ca:	c0 40       	breq	800079d2 <put_fat+0x96>
800079cc:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
800079d0:	c0 b8       	rjmp	800079e6 <put_fat+0xaa>
800079d2:	ee 04 00 08 	add	r8,r7,r4
800079d6:	f1 38 00 30 	ld.ub	r8,r8[48]
800079da:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
800079de:	e2 18 00 f0 	andl	r8,0xf0,COH
800079e2:	f1 e5 10 05 	or	r5,r8,r5
800079e6:	ee 04 00 04 	add	r4,r7,r4
800079ea:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
800079ee:	30 18       	mov	r8,1
800079f0:	ae c8       	st.b	r7[0x4],r8
			break;
800079f2:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
800079f4:	a9 8b       	lsr	r11,0x8
800079f6:	78 88       	ld.w	r8,r12[0x20]
800079f8:	10 0b       	add	r11,r8
800079fa:	f0 1f 00 1d 	mcall	80007a6c <put_fat+0x130>
			if (res != FR_OK) break;
800079fe:	c3 51       	brne	80007a68 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
80007a00:	a1 76       	lsl	r6,0x1
80007a02:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
80007a06:	ee 06 00 08 	add	r8,r7,r6
80007a0a:	f1 65 00 30 	st.b	r8[48],r5
80007a0e:	10 96       	mov	r6,r8
80007a10:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
80007a14:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
80007a18:	30 18       	mov	r8,1
80007a1a:	ae c8       	st.b	r7[0x4],r8
			break;
80007a1c:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
80007a1e:	a7 9b       	lsr	r11,0x7
80007a20:	78 88       	ld.w	r8,r12[0x20]
80007a22:	10 0b       	add	r11,r8
80007a24:	f0 1f 00 12 	mcall	80007a6c <put_fat+0x130>
			if (res != FR_OK) break;
80007a28:	c2 01       	brne	80007a68 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
80007a2a:	a3 66       	lsl	r6,0x2
80007a2c:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007a30:	ec c8 ff d0 	sub	r8,r6,-48
80007a34:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
80007a38:	f0 c9 ff fd 	sub	r9,r8,-3
80007a3c:	13 8a       	ld.ub	r10,r9[0x0]
80007a3e:	b9 6a       	lsl	r10,0x18
80007a40:	ee 06 00 06 	add	r6,r7,r6
80007a44:	e6 1a f0 00 	andh	r10,0xf000,COH
80007a48:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007a4c:	ed 65 00 30 	st.b	r6[48],r5
80007a50:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
80007a54:	b0 9a       	st.b	r8[0x1],r10
80007a56:	ea 0a 16 10 	lsr	r10,r5,0x10
80007a5a:	b0 aa       	st.b	r8[0x2],r10
80007a5c:	b9 85       	lsr	r5,0x18
80007a5e:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007a60:	30 18       	mov	r8,1
80007a62:	ae c8       	st.b	r7[0x4],r8
			break;
80007a64:	d8 22       	popm	r4-r7,pc
80007a66:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
80007a68:	d8 22       	popm	r4-r7,pc
80007a6a:	00 00       	add	r0,r0
80007a6c:	80 00       	ld.sh	r0,r0[0x0]
80007a6e:	73 48       	ld.w	r8,r9[0x50]

80007a70 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007a70:	d4 21       	pushm	r4-r7,lr
80007a72:	18 97       	mov	r7,r12
80007a74:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007a76:	58 1b       	cp.w	r11,1
80007a78:	e0 88 00 69 	brls	80007b4a <get_fat+0xda>
80007a7c:	78 58       	ld.w	r8,r12[0x14]
80007a7e:	10 3b       	cp.w	r11,r8
80007a80:	c6 52       	brcc	80007b4a <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
80007a82:	19 88       	ld.ub	r8,r12[0x0]
80007a84:	30 29       	mov	r9,2
80007a86:	f2 08 18 00 	cp.b	r8,r9
80007a8a:	c3 10       	breq	80007aec <get_fat+0x7c>
80007a8c:	30 39       	mov	r9,3
80007a8e:	f2 08 18 00 	cp.b	r8,r9
80007a92:	c4 00       	breq	80007b12 <get_fat+0xa2>
80007a94:	30 19       	mov	r9,1
80007a96:	f2 08 18 00 	cp.b	r8,r9
80007a9a:	c5 81       	brne	80007b4a <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007a9c:	f6 05 16 01 	lsr	r5,r11,0x1
80007aa0:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
80007aa2:	ea 0b 16 09 	lsr	r11,r5,0x9
80007aa6:	78 88       	ld.w	r8,r12[0x20]
80007aa8:	10 0b       	add	r11,r8
80007aaa:	f0 1f 00 2a 	mcall	80007b50 <get_fat+0xe0>
80007aae:	c4 f1       	brne	80007b4c <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
80007ab0:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
80007ab4:	ee 08 00 08 	add	r8,r7,r8
80007ab8:	f1 34 00 30 	ld.ub	r4,r8[48]
80007abc:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
80007abe:	ea 0b 16 09 	lsr	r11,r5,0x9
80007ac2:	6e 88       	ld.w	r8,r7[0x20]
80007ac4:	10 0b       	add	r11,r8
80007ac6:	0e 9c       	mov	r12,r7
80007ac8:	f0 1f 00 22 	mcall	80007b50 <get_fat+0xe0>
80007acc:	c4 01       	brne	80007b4c <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
80007ace:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
80007ad2:	0a 07       	add	r7,r5
80007ad4:	ef 3c 00 30 	ld.ub	r12,r7[48]
80007ad8:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
80007adc:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007ae0:	c0 30       	breq	80007ae6 <get_fat+0x76>
80007ae2:	a5 8c       	lsr	r12,0x4
80007ae4:	d8 22       	popm	r4-r7,pc
80007ae6:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
80007aea:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
80007aec:	a9 8b       	lsr	r11,0x8
80007aee:	78 88       	ld.w	r8,r12[0x20]
80007af0:	10 0b       	add	r11,r8
80007af2:	f0 1f 00 18 	mcall	80007b50 <get_fat+0xe0>
80007af6:	c2 b1       	brne	80007b4c <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
80007af8:	a1 76       	lsl	r6,0x1
80007afa:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
80007afe:	ee 06 00 08 	add	r8,r7,r6
80007b02:	10 97       	mov	r7,r8
80007b04:	f1 3c 00 31 	ld.ub	r12,r8[49]
80007b08:	f1 38 00 30 	ld.ub	r8,r8[48]
80007b0c:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
80007b10:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
80007b12:	a7 9b       	lsr	r11,0x7
80007b14:	78 88       	ld.w	r8,r12[0x20]
80007b16:	10 0b       	add	r11,r8
80007b18:	f0 1f 00 0e 	mcall	80007b50 <get_fat+0xe0>
80007b1c:	c1 81       	brne	80007b4c <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
80007b1e:	a3 66       	lsl	r6,0x2
80007b20:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007b24:	ec c8 ff d0 	sub	r8,r6,-48
80007b28:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
80007b2c:	11 a9       	ld.ub	r9,r8[0x2]
80007b2e:	11 bc       	ld.ub	r12,r8[0x3]
80007b30:	b9 6c       	lsl	r12,0x18
80007b32:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
80007b36:	11 98       	ld.ub	r8,r8[0x1]
80007b38:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
80007b3c:	0c 07       	add	r7,r6
80007b3e:	ef 38 00 30 	ld.ub	r8,r7[48]
80007b42:	10 4c       	or	r12,r8
80007b44:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007b48:	d8 22       	popm	r4-r7,pc
80007b4a:	da 2a       	popm	r4-r7,pc,r12=1
80007b4c:	dc 2a       	popm	r4-r7,pc,r12=-1
80007b4e:	00 00       	add	r0,r0
80007b50:	80 00       	ld.sh	r0,r0[0x0]
80007b52:	73 48       	ld.w	r8,r9[0x50]

80007b54 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
80007b54:	eb cd 40 f8 	pushm	r3-r7,lr
80007b58:	18 96       	mov	r6,r12
80007b5a:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
80007b5c:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
80007b5e:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007b60:	58 18       	cp.w	r8,1
80007b62:	c4 c0       	breq	80007bfa <dir_sdi+0xa6>
80007b64:	78 09       	ld.w	r9,r12[0x0]
80007b66:	72 5a       	ld.w	r10,r9[0x14]
80007b68:	14 38       	cp.w	r8,r10
80007b6a:	c4 82       	brcc	80007bfa <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
80007b6c:	58 08       	cp.w	r8,0
80007b6e:	c0 f1       	brne	80007b8c <dir_sdi+0x38>
80007b70:	13 8b       	ld.ub	r11,r9[0x0]
80007b72:	30 3a       	mov	r10,3
80007b74:	f4 0b 18 00 	cp.b	r11,r10
80007b78:	c0 41       	brne	80007b80 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
80007b7a:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
80007b7c:	58 07       	cp.w	r7,0
80007b7e:	c0 81       	brne	80007b8e <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
80007b80:	92 ca       	ld.uh	r10,r9[0x8]
80007b82:	14 35       	cp.w	r5,r10
80007b84:	c3 b2       	brcc	80007bfa <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
80007b86:	72 9c       	ld.w	r12,r9[0x24]
80007b88:	10 97       	mov	r7,r8
80007b8a:	c2 68       	rjmp	80007bd6 <dir_sdi+0x82>
80007b8c:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
80007b8e:	13 a4       	ld.ub	r4,r9[0x2]
80007b90:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
80007b92:	08 35       	cp.w	r5,r4
80007b94:	c1 d3       	brcs	80007bce <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
80007b96:	e8 03 11 00 	rsub	r3,r4,0
80007b9a:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
80007b9c:	0e 9b       	mov	r11,r7
80007b9e:	6c 0c       	ld.w	r12,r6[0x0]
80007ba0:	f0 1f 00 18 	mcall	80007c00 <dir_sdi+0xac>
80007ba4:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
80007ba6:	5b fc       	cp.w	r12,-1
80007ba8:	c0 31       	brne	80007bae <dir_sdi+0x5a>
80007baa:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
80007bae:	58 1c       	cp.w	r12,1
80007bb0:	e0 88 00 25 	brls	80007bfa <dir_sdi+0xa6>
80007bb4:	6c 08       	ld.w	r8,r6[0x0]
80007bb6:	70 58       	ld.w	r8,r8[0x14]
80007bb8:	10 3c       	cp.w	r12,r8
80007bba:	c2 02       	brcc	80007bfa <dir_sdi+0xa6>
80007bbc:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
80007bc0:	f0 04 00 09 	add	r9,r8,r4
80007bc4:	12 34       	cp.w	r4,r9
80007bc6:	e0 8b 00 04 	brhi	80007bce <dir_sdi+0x7a>
80007bca:	10 95       	mov	r5,r8
80007bcc:	ce 8b       	rjmp	80007b9c <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
80007bce:	0e 9b       	mov	r11,r7
80007bd0:	6c 0c       	ld.w	r12,r6[0x0]
80007bd2:	f0 1f 00 0d 	mcall	80007c04 <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
80007bd6:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
80007bd8:	58 0c       	cp.w	r12,0
80007bda:	c1 00       	breq	80007bfa <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
80007bdc:	ea 08 16 04 	lsr	r8,r5,0x4
80007be0:	f0 0c 00 0c 	add	r12,r8,r12
80007be4:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
80007be6:	6c 08       	ld.w	r8,r6[0x0]
80007be8:	2d 08       	sub	r8,-48
80007bea:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
80007bee:	a5 75       	lsl	r5,0x5
80007bf0:	f0 05 00 05 	add	r5,r8,r5
80007bf4:	8d 55       	st.w	r6[0x14],r5
80007bf6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
80007bfa:	30 2c       	mov	r12,2
}
80007bfc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007c00:	80 00       	ld.sh	r0,r0[0x0]
80007c02:	7a 70       	ld.w	r0,sp[0x1c]
80007c04:	80 00       	ld.sh	r0,r0[0x0]
80007c06:	69 fc       	ld.w	r12,r4[0x7c]

80007c08 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
80007c08:	eb cd 40 fc 	pushm	r2-r7,lr
80007c0c:	18 96       	mov	r6,r12
80007c0e:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
80007c10:	58 0b       	cp.w	r11,0
80007c12:	c0 81       	brne	80007c22 <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
80007c14:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
80007c16:	58 05       	cp.w	r5,0
80007c18:	c1 10       	breq	80007c3a <create_chain+0x32>
80007c1a:	78 58       	ld.w	r8,r12[0x14]
80007c1c:	10 35       	cp.w	r5,r8
80007c1e:	c0 e2       	brcc	80007c3a <create_chain+0x32>
80007c20:	c0 e8       	rjmp	80007c3c <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
80007c22:	f0 1f 00 2c 	mcall	80007cd0 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
80007c26:	58 1c       	cp.w	r12,1
80007c28:	e0 88 00 4f 	brls	80007cc6 <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
80007c2c:	5b fc       	cp.w	r12,-1
80007c2e:	c4 f0       	breq	80007ccc <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
80007c30:	6c 58       	ld.w	r8,r6[0x14]
80007c32:	10 3c       	cp.w	r12,r8
80007c34:	c4 c3       	brcs	80007ccc <create_chain+0xc4>
80007c36:	04 95       	mov	r5,r2
80007c38:	c0 28       	rjmp	80007c3c <create_chain+0x34>
80007c3a:	30 15       	mov	r5,1
80007c3c:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007c3e:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007c40:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
80007c42:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
80007c44:	6c 58       	ld.w	r8,r6[0x14]
80007c46:	10 37       	cp.w	r7,r8
80007c48:	c0 53       	brcs	80007c52 <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007c4a:	58 15       	cp.w	r5,1
80007c4c:	e0 88 00 3f 	brls	80007cca <create_chain+0xc2>
80007c50:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
80007c52:	0e 9b       	mov	r11,r7
80007c54:	0c 9c       	mov	r12,r6
80007c56:	f0 1f 00 1f 	mcall	80007cd0 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
80007c5a:	c0 d0       	breq	80007c74 <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007c5c:	5b fc       	cp.w	r12,-1
80007c5e:	5f 09       	sreq	r9
80007c60:	58 1c       	cp.w	r12,1
80007c62:	5f 08       	sreq	r8
80007c64:	f3 e8 10 08 	or	r8,r9,r8
80007c68:	e8 08 18 00 	cp.b	r8,r4
80007c6c:	c3 01       	brne	80007ccc <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
80007c6e:	0a 37       	cp.w	r7,r5
80007c70:	ce 91       	brne	80007c42 <create_chain+0x3a>
80007c72:	c2 c8       	rjmp	80007cca <create_chain+0xc2>
80007c74:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
80007c76:	e0 6a ff ff 	mov	r10,65535
80007c7a:	ea 1a 0f ff 	orh	r10,0xfff
80007c7e:	0e 9b       	mov	r11,r7
80007c80:	0c 9c       	mov	r12,r6
80007c82:	f0 1f 00 15 	mcall	80007cd4 <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
80007c86:	5f 09       	sreq	r9
80007c88:	58 02       	cp.w	r2,0
80007c8a:	5f 18       	srne	r8
80007c8c:	f3 e8 00 08 	and	r8,r9,r8
80007c90:	c0 60       	breq	80007c9c <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
80007c92:	0e 9a       	mov	r10,r7
80007c94:	04 9b       	mov	r11,r2
80007c96:	0c 9c       	mov	r12,r6
80007c98:	f0 1f 00 0f 	mcall	80007cd4 <create_chain+0xcc>
	}
	if (res == FR_OK) {
80007c9c:	58 0c       	cp.w	r12,0
80007c9e:	c1 01       	brne	80007cbe <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
80007ca0:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
80007ca2:	6c 48       	ld.w	r8,r6[0x10]
80007ca4:	5b f8       	cp.w	r8,-1
80007ca6:	c0 41       	brne	80007cae <create_chain+0xa6>
80007ca8:	0e 9c       	mov	r12,r7
80007caa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
80007cae:	20 18       	sub	r8,1
80007cb0:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
80007cb2:	0d d8       	ld.ub	r8,r6[0x5]
80007cb4:	a1 a8       	sbr	r8,0x0
80007cb6:	ac d8       	st.b	r6[0x5],r8
80007cb8:	0e 9c       	mov	r12,r7
80007cba:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
80007cbe:	58 1c       	cp.w	r12,1
80007cc0:	c0 31       	brne	80007cc6 <create_chain+0xbe>
80007cc2:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
80007cc6:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80007cca:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
80007ccc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007cd0:	80 00       	ld.sh	r0,r0[0x0]
80007cd2:	7a 70       	ld.w	r0,sp[0x1c]
80007cd4:	80 00       	ld.sh	r0,r0[0x0]
80007cd6:	79 3c       	ld.w	r12,r12[0x4c]

80007cd8 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
80007cd8:	eb cd 40 fc 	pushm	r2-r7,lr
80007cdc:	18 97       	mov	r7,r12
80007cde:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
80007ce0:	98 b5       	ld.uh	r5,r12[0x6]
80007ce2:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
80007ce4:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80007ce8:	c6 d0       	breq	80007dc2 <dir_next+0xea>
80007cea:	78 48       	ld.w	r8,r12[0x10]
80007cec:	58 08       	cp.w	r8,0
80007cee:	c6 a0       	breq	80007dc2 <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
80007cf0:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
80007cf4:	c5 e1       	brne	80007db0 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
80007cf6:	2f f8       	sub	r8,-1
80007cf8:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
80007cfa:	78 3b       	ld.w	r11,r12[0xc]
80007cfc:	58 0b       	cp.w	r11,0
80007cfe:	c0 61       	brne	80007d0a <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
80007d00:	78 08       	ld.w	r8,r12[0x0]
80007d02:	90 c8       	ld.uh	r8,r8[0x8]
80007d04:	10 35       	cp.w	r5,r8
80007d06:	c5 53       	brcs	80007db0 <dir_next+0xd8>
80007d08:	c5 d8       	rjmp	80007dc2 <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
80007d0a:	78 0c       	ld.w	r12,r12[0x0]
80007d0c:	19 a8       	ld.ub	r8,r12[0x2]
80007d0e:	20 18       	sub	r8,1
80007d10:	f1 e5 02 48 	and	r8,r8,r5>>0x4
80007d14:	c4 e1       	brne	80007db0 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
80007d16:	f0 1f 00 30 	mcall	80007dd4 <dir_next+0xfc>
80007d1a:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
80007d1c:	58 1c       	cp.w	r12,1
80007d1e:	e0 88 00 55 	brls	80007dc8 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
80007d22:	5b fc       	cp.w	r12,-1
80007d24:	c5 50       	breq	80007dce <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
80007d26:	6e 0c       	ld.w	r12,r7[0x0]
80007d28:	78 58       	ld.w	r8,r12[0x14]
80007d2a:	10 33       	cp.w	r3,r8
80007d2c:	c3 c3       	brcs	80007da4 <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
80007d2e:	58 06       	cp.w	r6,0
80007d30:	c4 90       	breq	80007dc2 <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
80007d32:	6e 3b       	ld.w	r11,r7[0xc]
80007d34:	f0 1f 00 29 	mcall	80007dd8 <dir_next+0x100>
80007d38:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
80007d3a:	c0 41       	brne	80007d42 <dir_next+0x6a>
80007d3c:	30 7c       	mov	r12,7
80007d3e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
80007d42:	58 1c       	cp.w	r12,1
80007d44:	c4 20       	breq	80007dc8 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
80007d46:	5b fc       	cp.w	r12,-1
80007d48:	c4 30       	breq	80007dce <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
80007d4a:	6e 0c       	ld.w	r12,r7[0x0]
80007d4c:	f0 1f 00 24 	mcall	80007ddc <dir_next+0x104>
80007d50:	c3 f1       	brne	80007dce <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
80007d52:	6e 0c       	ld.w	r12,r7[0x0]
80007d54:	e0 6a 02 00 	mov	r10,512
80007d58:	30 0b       	mov	r11,0
80007d5a:	2d 0c       	sub	r12,-48
80007d5c:	f0 1f 00 21 	mcall	80007de0 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007d60:	6e 06       	ld.w	r6,r7[0x0]
80007d62:	06 9b       	mov	r11,r3
80007d64:	0c 9c       	mov	r12,r6
80007d66:	f0 1f 00 20 	mcall	80007de4 <dir_next+0x10c>
80007d6a:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007d6c:	6e 08       	ld.w	r8,r7[0x0]
80007d6e:	11 aa       	ld.ub	r10,r8[0x2]
80007d70:	30 09       	mov	r9,0
80007d72:	f2 0a 18 00 	cp.b	r10,r9
80007d76:	c0 31       	brne	80007d7c <dir_next+0xa4>
80007d78:	30 06       	mov	r6,0
80007d7a:	c1 28       	rjmp	80007d9e <dir_next+0xc6>
80007d7c:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
80007d7e:	30 12       	mov	r2,1
80007d80:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
80007d82:	6e 0c       	ld.w	r12,r7[0x0]
80007d84:	f0 1f 00 16 	mcall	80007ddc <dir_next+0x104>
80007d88:	c2 31       	brne	80007dce <dir_next+0xf6>
						dp->fs->winsect++;
80007d8a:	6e 08       	ld.w	r8,r7[0x0]
80007d8c:	70 b9       	ld.w	r9,r8[0x2c]
80007d8e:	2f f9       	sub	r9,-1
80007d90:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007d92:	2f f6       	sub	r6,-1
80007d94:	6e 08       	ld.w	r8,r7[0x0]
80007d96:	11 a9       	ld.ub	r9,r8[0x2]
80007d98:	0c 39       	cp.w	r9,r6
80007d9a:	fe 9b ff f3 	brhi	80007d80 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
80007d9e:	70 b9       	ld.w	r9,r8[0x2c]
80007da0:	0c 19       	sub	r9,r6
80007da2:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
80007da4:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
80007da6:	06 9b       	mov	r11,r3
80007da8:	6e 0c       	ld.w	r12,r7[0x0]
80007daa:	f0 1f 00 0f 	mcall	80007de4 <dir_next+0x10c>
80007dae:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
80007db0:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
80007db2:	6e 08       	ld.w	r8,r7[0x0]
80007db4:	2d 08       	sub	r8,-48
80007db6:	a5 74       	lsl	r4,0x5
80007db8:	f0 04 00 04 	add	r4,r8,r4
80007dbc:	8f 54       	st.w	r7[0x14],r4
80007dbe:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
80007dc2:	30 4c       	mov	r12,4
80007dc4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007dc8:	30 2c       	mov	r12,2
80007dca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007dce:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80007dd2:	00 00       	add	r0,r0
80007dd4:	80 00       	ld.sh	r0,r0[0x0]
80007dd6:	7a 70       	ld.w	r0,sp[0x1c]
80007dd8:	80 00       	ld.sh	r0,r0[0x0]
80007dda:	7c 08       	ld.w	r8,lr[0x0]
80007ddc:	80 00       	ld.sh	r0,r0[0x0]
80007dde:	6b 50       	ld.w	r0,r5[0x54]
80007de0:	80 00       	ld.sh	r0,r0[0x0]
80007de2:	69 d6       	ld.w	r6,r4[0x74]
80007de4:	80 00       	ld.sh	r0,r0[0x0]
80007de6:	69 fc       	ld.w	r12,r4[0x7c]

80007de8 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
80007de8:	d4 21       	pushm	r4-r7,lr
80007dea:	18 97       	mov	r7,r12
80007dec:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007dee:	58 1b       	cp.w	r11,1
80007df0:	e0 88 00 26 	brls	80007e3c <remove_chain+0x54>
80007df4:	78 58       	ld.w	r8,r12[0x14]
80007df6:	10 3b       	cp.w	r11,r8
80007df8:	c2 22       	brcc	80007e3c <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007dfa:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
80007dfc:	0a 9b       	mov	r11,r5
80007dfe:	0e 9c       	mov	r12,r7
80007e00:	f0 1f 00 10 	mcall	80007e40 <remove_chain+0x58>
80007e04:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
80007e06:	c0 21       	brne	80007e0a <remove_chain+0x22>
80007e08:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
80007e0a:	58 1c       	cp.w	r12,1
80007e0c:	c1 80       	breq	80007e3c <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
80007e0e:	5b fc       	cp.w	r12,-1
80007e10:	c0 21       	brne	80007e14 <remove_chain+0x2c>
80007e12:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007e14:	08 9a       	mov	r10,r4
80007e16:	0a 9b       	mov	r11,r5
80007e18:	0e 9c       	mov	r12,r7
80007e1a:	f0 1f 00 0b 	mcall	80007e44 <remove_chain+0x5c>
			if (res != FR_OK) break;
80007e1e:	c1 01       	brne	80007e3e <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
80007e20:	6e 48       	ld.w	r8,r7[0x10]
80007e22:	5b f8       	cp.w	r8,-1
80007e24:	c0 60       	breq	80007e30 <remove_chain+0x48>
				fs->free_clust++;
80007e26:	2f f8       	sub	r8,-1
80007e28:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
80007e2a:	0f d8       	ld.ub	r8,r7[0x5]
80007e2c:	a1 a8       	sbr	r8,0x0
80007e2e:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
80007e30:	6e 58       	ld.w	r8,r7[0x14]
80007e32:	0c 38       	cp.w	r8,r6
80007e34:	e0 88 00 05 	brls	80007e3e <remove_chain+0x56>
80007e38:	0c 95       	mov	r5,r6
80007e3a:	ce 1b       	rjmp	80007dfc <remove_chain+0x14>
80007e3c:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
80007e3e:	d8 22       	popm	r4-r7,pc
80007e40:	80 00       	ld.sh	r0,r0[0x0]
80007e42:	7a 70       	ld.w	r0,sp[0x1c]
80007e44:	80 00       	ld.sh	r0,r0[0x0]
80007e46:	79 3c       	ld.w	r12,r12[0x4c]

80007e48 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007e48:	eb cd 40 fe 	pushm	r1-r7,lr
80007e4c:	18 97       	mov	r7,r12
80007e4e:	16 91       	mov	r1,r11
80007e50:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007e52:	3e 56       	mov	r6,-27
80007e54:	32 e5       	mov	r5,46
80007e56:	30 04       	mov	r4,0
80007e58:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007e5a:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007e5c:	c2 58       	rjmp	80007ea6 <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007e5e:	6e 0c       	ld.w	r12,r7[0x0]
80007e60:	f0 1f 00 17 	mcall	80007ebc <dir_read+0x74>
		if (res != FR_OK) break;
80007e64:	c2 61       	brne	80007eb0 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007e66:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007e68:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007e6a:	58 08       	cp.w	r8,0
80007e6c:	c2 60       	breq	80007eb8 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007e6e:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007e72:	ec 08 18 00 	cp.b	r8,r6
80007e76:	5f 19       	srne	r9
80007e78:	ea 08 18 00 	cp.b	r8,r5
80007e7c:	5f 18       	srne	r8
80007e7e:	f3 e8 00 08 	and	r8,r9,r8
80007e82:	e8 08 18 00 	cp.b	r8,r4
80007e86:	c0 b0       	breq	80007e9c <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007e88:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007e8c:	e4 08 18 00 	cp.b	r8,r2
80007e90:	c0 60       	breq	80007e9c <dir_read+0x54>
80007e92:	a5 d8       	cbr	r8,0x5
80007e94:	58 88       	cp.w	r8,8
80007e96:	5f 08       	sreq	r8
80007e98:	02 38       	cp.w	r8,r1
80007e9a:	c0 d0       	breq	80007eb4 <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007e9c:	06 9b       	mov	r11,r3
80007e9e:	0e 9c       	mov	r12,r7
80007ea0:	f0 1f 00 08 	mcall	80007ec0 <dir_read+0x78>
		if (res != FR_OK) break;
80007ea4:	c0 61       	brne	80007eb0 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007ea6:	6e 4b       	ld.w	r11,r7[0x10]
80007ea8:	58 0b       	cp.w	r11,0
80007eaa:	cd a1       	brne	80007e5e <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007eac:	58 0c       	cp.w	r12,0
80007eae:	c0 30       	breq	80007eb4 <dir_read+0x6c>
80007eb0:	30 08       	mov	r8,0
80007eb2:	8f 48       	st.w	r7[0x10],r8

	return res;
}
80007eb4:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007eb8:	30 4c       	mov	r12,4
80007eba:	cf bb       	rjmp	80007eb0 <dir_read+0x68>
80007ebc:	80 00       	ld.sh	r0,r0[0x0]
80007ebe:	73 48       	ld.w	r8,r9[0x50]
80007ec0:	80 00       	ld.sh	r0,r0[0x0]
80007ec2:	7c d8       	ld.w	r8,lr[0x34]

80007ec4 <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
80007ec4:	d4 21       	pushm	r4-r7,lr
80007ec6:	20 9d       	sub	sp,36
80007ec8:	50 0c       	stdsp	sp[0x0],r12
80007eca:	16 96       	mov	r6,r11
80007ecc:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
80007ece:	30 0a       	mov	r10,0
80007ed0:	1a 9b       	mov	r11,sp
80007ed2:	fa cc ff fc 	sub	r12,sp,-4
80007ed6:	f0 1f 00 30 	mcall	80007f94 <f_getlabel+0xd0>
80007eda:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
80007edc:	5f 09       	sreq	r9
80007ede:	58 06       	cp.w	r6,0
80007ee0:	5f 18       	srne	r8
80007ee2:	f3 e8 00 08 	and	r8,r9,r8
80007ee6:	c2 d0       	breq	80007f40 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
80007ee8:	30 0b       	mov	r11,0
80007eea:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
80007eec:	fa cc ff fc 	sub	r12,sp,-4
80007ef0:	f0 1f 00 2a 	mcall	80007f98 <f_getlabel+0xd4>
80007ef4:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007ef6:	c4 c1       	brne	80007f8e <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007ef8:	30 1b       	mov	r11,1
80007efa:	fa cc ff fc 	sub	r12,sp,-4
80007efe:	f0 1f 00 28 	mcall	80007f9c <f_getlabel+0xd8>
80007f02:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
80007f04:	c1 81       	brne	80007f34 <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
80007f06:	30 ba       	mov	r10,11
80007f08:	40 6b       	lddsp	r11,sp[0x18]
80007f0a:	0c 9c       	mov	r12,r6
80007f0c:	f0 1f 00 25 	mcall	80007fa0 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
80007f10:	30 08       	mov	r8,0
80007f12:	ed 68 00 0b 	st.b	r6[11],r8
80007f16:	2f 66       	sub	r6,-10
80007f18:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
80007f1a:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
80007f1c:	30 0b       	mov	r11,0
80007f1e:	c0 58       	rjmp	80007f28 <f_getlabel+0x64>
80007f20:	ac 8b       	st.b	r6[0x0],r11
80007f22:	20 16       	sub	r6,1
					if (!j) break;
80007f24:	58 08       	cp.w	r8,0
80007f26:	c0 c0       	breq	80007f3e <f_getlabel+0x7a>
				} while (label[--j] == ' ');
80007f28:	20 18       	sub	r8,1
80007f2a:	0d 89       	ld.ub	r9,r6[0x0]
80007f2c:	f4 09 18 00 	cp.b	r9,r10
80007f30:	cf 80       	breq	80007f20 <f_getlabel+0x5c>
80007f32:	c0 68       	rjmp	80007f3e <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
80007f34:	58 4c       	cp.w	r12,4
80007f36:	c0 41       	brne	80007f3e <f_getlabel+0x7a>
				label[0] = 0;
80007f38:	30 08       	mov	r8,0
80007f3a:	ac 88       	st.b	r6[0x0],r8
80007f3c:	c0 28       	rjmp	80007f40 <f_getlabel+0x7c>
80007f3e:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007f40:	58 07       	cp.w	r7,0
80007f42:	5f 09       	sreq	r9
80007f44:	58 05       	cp.w	r5,0
80007f46:	5f 18       	srne	r8
80007f48:	f3 e8 00 08 	and	r8,r9,r8
80007f4c:	c2 10       	breq	80007f8e <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007f4e:	40 1c       	lddsp	r12,sp[0x4]
80007f50:	78 7b       	ld.w	r11,r12[0x1c]
80007f52:	f0 1f 00 15 	mcall	80007fa4 <f_getlabel+0xe0>
80007f56:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007f58:	c1 b1       	brne	80007f8e <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007f5a:	40 19       	lddsp	r9,sp[0x4]
80007f5c:	13 8a       	ld.ub	r10,r9[0x0]
80007f5e:	30 38       	mov	r8,3
80007f60:	f0 0a 18 00 	cp.b	r10,r8
80007f64:	f9 b8 00 43 	moveq	r8,67
80007f68:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007f6c:	f2 08 00 08 	add	r8,r9,r8
80007f70:	f1 3a 00 33 	ld.ub	r10,r8[51]
80007f74:	f1 39 00 32 	ld.ub	r9,r8[50]
80007f78:	b1 69       	lsl	r9,0x10
80007f7a:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007f7e:	f1 3a 00 30 	ld.ub	r10,r8[48]
80007f82:	14 49       	or	r9,r10
80007f84:	f1 38 00 31 	ld.ub	r8,r8[49]
80007f88:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007f8c:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007f8e:	0e 9c       	mov	r12,r7
80007f90:	2f 7d       	sub	sp,-36
80007f92:	d8 22       	popm	r4-r7,pc
80007f94:	80 00       	ld.sh	r0,r0[0x0]
80007f96:	74 24       	ld.w	r4,r10[0x8]
80007f98:	80 00       	ld.sh	r0,r0[0x0]
80007f9a:	7b 54       	ld.w	r4,sp[0x54]
80007f9c:	80 00       	ld.sh	r0,r0[0x0]
80007f9e:	7e 48       	ld.w	r8,pc[0x10]
80007fa0:	80 00       	ld.sh	r0,r0[0x0]
80007fa2:	69 c0       	ld.w	r0,r4[0x70]
80007fa4:	80 00       	ld.sh	r0,r0[0x0]
80007fa6:	73 48       	ld.w	r8,r9[0x50]

80007fa8 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
80007fa8:	eb cd 40 fe 	pushm	r1-r7,lr
80007fac:	18 97       	mov	r7,r12
80007fae:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
80007fb0:	30 0b       	mov	r11,0
80007fb2:	f0 1f 00 15 	mcall	80008004 <dir_alloc+0x5c>
	if (res == FR_OK) {
80007fb6:	c2 21       	brne	80007ffa <dir_alloc+0x52>
80007fb8:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007fba:	3e 54       	mov	r4,-27
80007fbc:	30 06       	mov	r6,0
80007fbe:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007fc0:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
80007fc2:	6e 4b       	ld.w	r11,r7[0x10]
80007fc4:	6e 0c       	ld.w	r12,r7[0x0]
80007fc6:	f0 1f 00 11 	mcall	80008008 <dir_alloc+0x60>
			if (res != FR_OK) break;
80007fca:	c1 81       	brne	80007ffa <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007fcc:	6e 58       	ld.w	r8,r7[0x14]
80007fce:	11 88       	ld.ub	r8,r8[0x0]
80007fd0:	e8 08 18 00 	cp.b	r8,r4
80007fd4:	5f 09       	sreq	r9
80007fd6:	ec 08 18 00 	cp.b	r8,r6
80007fda:	5f 08       	sreq	r8
80007fdc:	f3 e8 10 08 	or	r8,r9,r8
80007fe0:	ec 08 18 00 	cp.b	r8,r6
80007fe4:	c0 31       	brne	80007fea <dir_alloc+0x42>
80007fe6:	02 95       	mov	r5,r1
80007fe8:	c0 48       	rjmp	80007ff0 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
80007fea:	2f f5       	sub	r5,-1
80007fec:	04 35       	cp.w	r5,r2
80007fee:	c0 90       	breq	80008000 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007ff0:	06 9b       	mov	r11,r3
80007ff2:	0e 9c       	mov	r12,r7
80007ff4:	f0 1f 00 06 	mcall	8000800c <dir_alloc+0x64>
		} while (res == FR_OK);
80007ff8:	ce 50       	breq	80007fc2 <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
80007ffa:	58 4c       	cp.w	r12,4
80007ffc:	f9 bc 00 07 	moveq	r12,7
	return res;
}
80008000:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80008004:	80 00       	ld.sh	r0,r0[0x0]
80008006:	7b 54       	ld.w	r4,sp[0x54]
80008008:	80 00       	ld.sh	r0,r0[0x0]
8000800a:	73 48       	ld.w	r8,r9[0x50]
8000800c:	80 00       	ld.sh	r0,r0[0x0]
8000800e:	7c d8       	ld.w	r8,lr[0x34]

80008010 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
80008010:	d4 31       	pushm	r0-r7,lr
80008012:	20 cd       	sub	sp,48
80008014:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
80008016:	30 1a       	mov	r10,1
80008018:	1a 9b       	mov	r11,sp
8000801a:	fa cc ff f0 	sub	r12,sp,-16
8000801e:	f0 1f 00 8b 	mcall	80008248 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
80008022:	e0 81 01 08 	brne	80008232 <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
80008026:	30 08       	mov	r8,0
80008028:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
8000802a:	40 0a       	lddsp	r10,sp[0x0]
8000802c:	15 89       	ld.ub	r9,r10[0x0]
8000802e:	f0 09 18 00 	cp.b	r9,r8
80008032:	e0 80 00 90 	breq	80008152 <f_setlabel+0x142>
80008036:	30 07       	mov	r7,0
80008038:	2f f7       	sub	r7,-1
8000803a:	f4 07 07 09 	ld.ub	r9,r10[r7]
8000803e:	f0 09 18 00 	cp.b	r9,r8
80008042:	cf b1       	brne	80008038 <f_setlabel+0x28>
80008044:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
80008046:	58 07       	cp.w	r7,0
80008048:	e0 80 00 85 	breq	80008152 <f_setlabel+0x142>
8000804c:	f4 07 00 09 	add	r9,r10,r7
80008050:	f3 3b ff ff 	ld.ub	r11,r9[-1]
80008054:	32 09       	mov	r9,32
80008056:	f2 0b 18 00 	cp.b	r11,r9
8000805a:	e0 81 00 ee 	brne	80008236 <f_setlabel+0x226>
8000805e:	20 28       	sub	r8,2
80008060:	f4 08 00 08 	add	r8,r10,r8
80008064:	12 9a       	mov	r10,r9
80008066:	20 17       	sub	r7,1
80008068:	c7 50       	breq	80008152 <f_setlabel+0x142>
8000806a:	11 89       	ld.ub	r9,r8[0x0]
8000806c:	20 18       	sub	r8,1
8000806e:	f4 09 18 00 	cp.b	r9,r10
80008072:	cf a0       	breq	80008066 <f_setlabel+0x56>
80008074:	ce 18       	rjmp	80008236 <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
80008076:	40 08       	lddsp	r8,sp[0x0]
80008078:	f0 04 07 06 	ld.ub	r6,r8[r4]
8000807c:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
8000807e:	ec c9 ff 81 	sub	r9,r6,-127
80008082:	e4 09 18 00 	cp.b	r9,r2
80008086:	e0 8b 00 24 	brhi	800080ce <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
8000808a:	58 95       	cp.w	r5,9
8000808c:	5f 8a       	srls	r10
8000808e:	0e 34       	cp.w	r4,r7
80008090:	5f 39       	srlo	r9
80008092:	f5 e9 00 09 	and	r9,r10,r9
80008096:	e2 09 18 00 	cp.b	r9,r1
8000809a:	e0 80 00 c9 	breq	8000822c <f_setlabel+0x21c>
8000809e:	f0 04 07 08 	ld.ub	r8,r8[r4]
800080a2:	f0 c9 00 40 	sub	r9,r8,64
800080a6:	33 eb       	mov	r11,62
800080a8:	f6 09 18 00 	cp.b	r9,r11
800080ac:	5f 8a       	srls	r10
800080ae:	f0 c9 00 80 	sub	r9,r8,128
800080b2:	37 eb       	mov	r11,126
800080b4:	f6 09 18 00 	cp.b	r9,r11
800080b8:	5f 89       	srls	r9
800080ba:	f5 e9 10 09 	or	r9,r10,r9
800080be:	e2 09 18 00 	cp.b	r9,r1
800080c2:	e0 80 00 b5 	breq	8000822c <f_setlabel+0x21c>
800080c6:	f1 e6 10 86 	or	r6,r8,r6<<0x8
800080ca:	5c 86       	casts.h	r6
800080cc:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
800080ce:	ec c8 00 61 	sub	r8,r6,97
800080d2:	31 9a       	mov	r10,25
800080d4:	f4 08 19 00 	cp.h	r8,r10
800080d8:	e0 8b 00 04 	brhi	800080e0 <f_setlabel+0xd0>
800080dc:	22 06       	sub	r6,32
800080de:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
800080e0:	58 06       	cp.w	r6,0
800080e2:	e0 80 00 a5 	breq	8000822c <f_setlabel+0x21c>
800080e6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800080ea:	00 9c       	mov	r12,r0
800080ec:	f0 1f 00 58 	mcall	8000824c <f_setlabel+0x23c>
800080f0:	e0 81 00 9e 	brne	8000822c <f_setlabel+0x21c>
800080f4:	ec 03 19 00 	cp.h	r3,r6
800080f8:	f9 b8 03 0a 	movlo	r8,10
800080fc:	f9 b8 02 0b 	movhs	r8,11
80008100:	10 35       	cp.w	r5,r8
80008102:	e0 82 00 95 	brhs	8000822c <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
80008106:	e6 06 19 00 	cp.h	r6,r3
8000810a:	e0 88 00 0a 	brls	8000811e <f_setlabel+0x10e>
8000810e:	fa c8 ff d0 	sub	r8,sp,-48
80008112:	0a 08       	add	r8,r5
80008114:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80008118:	f1 69 ff d4 	st.b	r8[-44],r9
8000811c:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
8000811e:	fa c8 ff d0 	sub	r8,sp,-48
80008122:	0a 08       	add	r8,r5
80008124:	f1 66 ff d4 	st.b	r8[-44],r6
80008128:	2f f5       	sub	r5,-1
		} while (i < sl);
8000812a:	0e 34       	cp.w	r4,r7
8000812c:	ca 53       	brcs	80008076 <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
8000812e:	58 a5       	cp.w	r5,10
80008130:	e0 8b 00 0c 	brhi	80008148 <f_setlabel+0x138>
80008134:	fa c9 ff fc 	sub	r9,sp,-4
80008138:	f2 05 00 08 	add	r8,r9,r5
8000813c:	32 09       	mov	r9,32
8000813e:	10 c9       	st.b	r8++,r9
80008140:	2f f5       	sub	r5,-1
80008142:	58 a5       	cp.w	r5,10
80008144:	fe 98 ff fd 	brls	8000813e <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80008148:	3e 58       	mov	r8,-27
8000814a:	1b c9       	ld.ub	r9,sp[0x4]
8000814c:	f0 09 18 00 	cp.b	r9,r8
80008150:	c6 e0       	breq	8000822c <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80008152:	30 0b       	mov	r11,0
80008154:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80008156:	fa cc ff f0 	sub	r12,sp,-16
8000815a:	f0 1f 00 3e 	mcall	80008250 <f_setlabel+0x240>
8000815e:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80008160:	c6 81       	brne	80008230 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80008162:	30 1b       	mov	r11,1
80008164:	fa cc ff f0 	sub	r12,sp,-16
80008168:	f0 1f 00 3b 	mcall	80008254 <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
8000816c:	c2 a1       	brne	800081c0 <f_setlabel+0x1b0>
			if (vn[0]) {
8000816e:	30 08       	mov	r8,0
80008170:	1b c9       	ld.ub	r9,sp[0x4]
80008172:	f0 09 18 00 	cp.b	r9,r8
80008176:	c1 b0       	breq	800081ac <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80008178:	30 ba       	mov	r10,11
8000817a:	fa cb ff fc 	sub	r11,sp,-4
8000817e:	40 9c       	lddsp	r12,sp[0x24]
80008180:	f0 1f 00 36 	mcall	80008258 <f_setlabel+0x248>
				tm = GET_FATTIME();
80008184:	f0 1f 00 36 	mcall	8000825c <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80008188:	40 98       	lddsp	r8,sp[0x24]
8000818a:	f1 6c 00 16 	st.b	r8[22],r12
8000818e:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008192:	40 98       	lddsp	r8,sp[0x24]
80008194:	f1 69 00 17 	st.b	r8[23],r9
80008198:	f8 09 16 10 	lsr	r9,r12,0x10
8000819c:	40 98       	lddsp	r8,sp[0x24]
8000819e:	f1 69 00 18 	st.b	r8[24],r9
800081a2:	b9 8c       	lsr	r12,0x18
800081a4:	40 98       	lddsp	r8,sp[0x24]
800081a6:	f1 6c 00 19 	st.b	r8[25],r12
800081aa:	c0 48       	rjmp	800081b2 <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
800081ac:	3e 59       	mov	r9,-27
800081ae:	40 98       	lddsp	r8,sp[0x24]
800081b0:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
800081b2:	30 19       	mov	r9,1
800081b4:	40 48       	lddsp	r8,sp[0x10]
800081b6:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
800081b8:	40 4c       	lddsp	r12,sp[0x10]
800081ba:	f0 1f 00 2a 	mcall	80008260 <f_setlabel+0x250>
800081be:	c3 a8       	rjmp	80008232 <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
800081c0:	58 4c       	cp.w	r12,4
800081c2:	c3 81       	brne	80008232 <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
800081c4:	30 08       	mov	r8,0
800081c6:	1b c9       	ld.ub	r9,sp[0x4]
800081c8:	f0 09 18 00 	cp.b	r9,r8
800081cc:	c3 20       	breq	80008230 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
800081ce:	30 1b       	mov	r11,1
800081d0:	fa cc ff f0 	sub	r12,sp,-16
800081d4:	f0 1f 00 24 	mcall	80008264 <f_setlabel+0x254>
					if (res == FR_OK) {
800081d8:	c2 d1       	brne	80008232 <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
800081da:	32 0a       	mov	r10,32
800081dc:	30 0b       	mov	r11,0
800081de:	40 9c       	lddsp	r12,sp[0x24]
800081e0:	f0 1f 00 22 	mcall	80008268 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
800081e4:	30 ba       	mov	r10,11
800081e6:	fa cb ff fc 	sub	r11,sp,-4
800081ea:	40 9c       	lddsp	r12,sp[0x24]
800081ec:	f0 1f 00 1b 	mcall	80008258 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
800081f0:	30 89       	mov	r9,8
800081f2:	40 98       	lddsp	r8,sp[0x24]
800081f4:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
800081f8:	f0 1f 00 19 	mcall	8000825c <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
800081fc:	40 98       	lddsp	r8,sp[0x24]
800081fe:	f1 6c 00 16 	st.b	r8[22],r12
80008202:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008206:	40 98       	lddsp	r8,sp[0x24]
80008208:	f1 69 00 17 	st.b	r8[23],r9
8000820c:	f8 09 16 10 	lsr	r9,r12,0x10
80008210:	40 98       	lddsp	r8,sp[0x24]
80008212:	f1 69 00 18 	st.b	r8[24],r9
80008216:	b9 8c       	lsr	r12,0x18
80008218:	40 98       	lddsp	r8,sp[0x24]
8000821a:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
8000821e:	30 19       	mov	r9,1
80008220:	40 48       	lddsp	r8,sp[0x10]
80008222:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80008224:	40 4c       	lddsp	r12,sp[0x10]
80008226:	f0 1f 00 0f 	mcall	80008260 <f_setlabel+0x250>
8000822a:	c0 48       	rjmp	80008232 <f_setlabel+0x222>
8000822c:	30 6c       	mov	r12,6
8000822e:	c0 28       	rjmp	80008232 <f_setlabel+0x222>
80008230:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80008232:	2f 4d       	sub	sp,-48
80008234:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80008236:	30 05       	mov	r5,0
80008238:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
8000823a:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
8000823c:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
8000823e:	48 c0       	lddpc	r0,8000826c <f_setlabel+0x25c>
80008240:	e0 63 00 ff 	mov	r3,255
80008244:	c1 9b       	rjmp	80008076 <f_setlabel+0x66>
80008246:	00 00       	add	r0,r0
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	74 24       	ld.w	r4,r10[0x8]
8000824c:	80 00       	ld.sh	r0,r0[0x0]
8000824e:	69 e2       	ld.w	r2,r4[0x78]
80008250:	80 00       	ld.sh	r0,r0[0x0]
80008252:	7b 54       	ld.w	r4,sp[0x54]
80008254:	80 00       	ld.sh	r0,r0[0x0]
80008256:	7e 48       	ld.w	r8,pc[0x10]
80008258:	80 00       	ld.sh	r0,r0[0x0]
8000825a:	69 c0       	ld.w	r0,r4[0x70]
8000825c:	80 00       	ld.sh	r0,r0[0x0]
8000825e:	68 fc       	ld.w	r12,r4[0x3c]
80008260:	80 00       	ld.sh	r0,r0[0x0]
80008262:	6b b4       	ld.w	r4,r5[0x6c]
80008264:	80 00       	ld.sh	r0,r0[0x0]
80008266:	7f a8       	ld.w	r8,pc[0x68]
80008268:	80 00       	ld.sh	r0,r0[0x0]
8000826a:	69 d6       	ld.w	r6,r4[0x74]
8000826c:	80 01       	ld.sh	r1,r0[0x0]
8000826e:	99 90       	st.w	r12[0x24],r0

80008270 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80008270:	eb cd 40 c0 	pushm	r6-r7,lr
80008274:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80008276:	30 1b       	mov	r11,1
80008278:	f0 1f 00 0d 	mcall	800082ac <dir_register+0x3c>
8000827c:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
8000827e:	c1 41       	brne	800082a6 <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80008280:	6c 4b       	ld.w	r11,r6[0x10]
80008282:	6c 0c       	ld.w	r12,r6[0x0]
80008284:	f0 1f 00 0b 	mcall	800082b0 <dir_register+0x40>
80008288:	18 97       	mov	r7,r12
		if (res == FR_OK) {
8000828a:	c0 e1       	brne	800082a6 <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
8000828c:	32 0a       	mov	r10,32
8000828e:	30 0b       	mov	r11,0
80008290:	6c 5c       	ld.w	r12,r6[0x14]
80008292:	f0 1f 00 09 	mcall	800082b4 <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80008296:	30 ba       	mov	r10,11
80008298:	6c 6b       	ld.w	r11,r6[0x18]
8000829a:	6c 5c       	ld.w	r12,r6[0x14]
8000829c:	f0 1f 00 07 	mcall	800082b8 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
800082a0:	6c 08       	ld.w	r8,r6[0x0]
800082a2:	30 19       	mov	r9,1
800082a4:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
800082a6:	0e 9c       	mov	r12,r7
800082a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800082ac:	80 00       	ld.sh	r0,r0[0x0]
800082ae:	7f a8       	ld.w	r8,pc[0x68]
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	73 48       	ld.w	r8,r9[0x50]
800082b4:	80 00       	ld.sh	r0,r0[0x0]
800082b6:	69 d6       	ld.w	r6,r4[0x74]
800082b8:	80 00       	ld.sh	r0,r0[0x0]
800082ba:	69 c0       	ld.w	r0,r4[0x70]

800082bc <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
800082bc:	d4 31       	pushm	r0-r7,lr
800082be:	20 3d       	sub	sp,12
800082c0:	18 92       	mov	r2,r12
800082c2:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
800082c4:	17 88       	ld.ub	r8,r11[0x0]
800082c6:	32 f9       	mov	r9,47
800082c8:	f2 08 18 00 	cp.b	r8,r9
800082cc:	5f 09       	sreq	r9
800082ce:	35 ca       	mov	r10,92
800082d0:	f4 08 18 00 	cp.b	r8,r10
800082d4:	5f 08       	sreq	r8
800082d6:	f3 e8 10 08 	or	r8,r9,r8
		path++;
800082da:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
800082de:	30 08       	mov	r8,0
800082e0:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
800082e2:	0f 89       	ld.ub	r9,r7[0x0]
800082e4:	31 f8       	mov	r8,31
800082e6:	f0 09 18 00 	cp.b	r9,r8
800082ea:	e0 8b 00 08 	brhi	800082fa <follow_path+0x3e>
		res = dir_sdi(dp, 0);
800082ee:	30 0b       	mov	r11,0
800082f0:	f0 1f 00 93 	mcall	8000853c <follow_path+0x280>
		dp->dir = 0;
800082f4:	30 08       	mov	r8,0
800082f6:	85 58       	st.w	r2[0x14],r8
800082f8:	c1 49       	rjmp	80008520 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
800082fa:	32 f4       	mov	r4,47
800082fc:	35 c3       	mov	r3,92
800082fe:	30 06       	mov	r6,0
80008300:	0f 88       	ld.ub	r8,r7[0x0]
80008302:	e8 08 18 00 	cp.b	r8,r4
80008306:	5f 09       	sreq	r9
80008308:	e6 08 18 00 	cp.b	r8,r3
8000830c:	5f 08       	sreq	r8
8000830e:	f3 e8 10 08 	or	r8,r9,r8
80008312:	ec 08 18 00 	cp.b	r8,r6
80008316:	c0 e0       	breq	80008332 <follow_path+0x76>
80008318:	2f f7       	sub	r7,-1
8000831a:	0f 88       	ld.ub	r8,r7[0x0]
8000831c:	e8 08 18 00 	cp.b	r8,r4
80008320:	5f 09       	sreq	r9
80008322:	e6 08 18 00 	cp.b	r8,r3
80008326:	5f 08       	sreq	r8
80008328:	f3 e8 10 08 	or	r8,r9,r8
8000832c:	ec 08 18 00 	cp.b	r8,r6
80008330:	cf 41       	brne	80008318 <follow_path+0x5c>
	sfn = dp->fn;
80008332:	64 6a       	ld.w	r10,r2[0x18]
80008334:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80008336:	30 ba       	mov	r10,11
80008338:	32 0b       	mov	r11,32
8000833a:	40 2c       	lddsp	r12,sp[0x8]
8000833c:	f0 1f 00 81 	mcall	80008540 <follow_path+0x284>
80008340:	30 89       	mov	r9,8
80008342:	50 09       	stdsp	sp[0x0],r9
80008344:	30 08       	mov	r8,0
80008346:	50 18       	stdsp	sp[0x4],r8
80008348:	10 90       	mov	r0,r8
8000834a:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
8000834c:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
8000834e:	ea 01 07 07 	ld.ub	r7,r5[r1]
80008352:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80008354:	32 09       	mov	r9,32
80008356:	f2 07 18 00 	cp.b	r7,r9
8000835a:	5f 88       	srls	r8
8000835c:	e8 07 18 00 	cp.b	r7,r4
80008360:	5f 09       	sreq	r9
80008362:	f1 e9 10 09 	or	r9,r8,r9
80008366:	ec 09 18 00 	cp.b	r9,r6
8000836a:	c7 51       	brne	80008454 <follow_path+0x198>
8000836c:	e6 07 18 00 	cp.b	r7,r3
80008370:	c7 20       	breq	80008454 <follow_path+0x198>
		if (c == '.' || i >= ni) {
80008372:	32 e8       	mov	r8,46
80008374:	f0 07 18 00 	cp.b	r7,r8
80008378:	5f 09       	sreq	r9
8000837a:	40 0a       	lddsp	r10,sp[0x0]
8000837c:	14 30       	cp.w	r0,r10
8000837e:	5f 28       	srhs	r8
80008380:	f3 e8 10 08 	or	r8,r9,r8
80008384:	ec 08 18 00 	cp.b	r8,r6
80008388:	c1 50       	breq	800083b2 <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
8000838a:	58 8a       	cp.w	r10,8
8000838c:	5f 19       	srne	r9
8000838e:	32 e8       	mov	r8,46
80008390:	f0 07 18 00 	cp.b	r7,r8
80008394:	5f 18       	srne	r8
80008396:	f3 e8 10 08 	or	r8,r9,r8
8000839a:	ec 08 18 00 	cp.b	r8,r6
8000839e:	e0 81 00 be 	brne	8000851a <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
800083a2:	40 18       	lddsp	r8,sp[0x4]
800083a4:	a3 68       	lsl	r8,0x2
800083a6:	5c 58       	castu.b	r8
800083a8:	50 18       	stdsp	sp[0x4],r8
800083aa:	30 ba       	mov	r10,11
800083ac:	50 0a       	stdsp	sp[0x0],r10
800083ae:	30 80       	mov	r0,8
800083b0:	cc fb       	rjmp	8000834e <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
800083b2:	ec 07 18 00 	cp.b	r7,r6
800083b6:	c0 54       	brge	800083c0 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
800083b8:	40 18       	lddsp	r8,sp[0x4]
800083ba:	e8 18 00 03 	orl	r8,0x3
800083be:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
800083c0:	0e 98       	mov	r8,r7
800083c2:	28 18       	sub	r8,-127
800083c4:	37 da       	mov	r10,125
800083c6:	f4 08 18 00 	cp.b	r8,r10
800083ca:	e0 8b 00 23 	brhi	80008410 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
800083ce:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
800083d2:	f0 c9 00 40 	sub	r9,r8,64
800083d6:	33 ea       	mov	r10,62
800083d8:	f4 09 18 00 	cp.b	r9,r10
800083dc:	5f b9       	srhi	r9
800083de:	f0 cb 00 80 	sub	r11,r8,128
800083e2:	37 ea       	mov	r10,126
800083e4:	f4 0b 18 00 	cp.b	r11,r10
800083e8:	5f ba       	srhi	r10
800083ea:	14 69       	and	r9,r10
800083ec:	ec 09 18 00 	cp.b	r9,r6
800083f0:	e0 81 00 95 	brne	8000851a <follow_path+0x25e>
800083f4:	40 09       	lddsp	r9,sp[0x0]
800083f6:	20 19       	sub	r9,1
800083f8:	12 30       	cp.w	r0,r9
800083fa:	e0 82 00 90 	brhs	8000851a <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
800083fe:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80008400:	40 29       	lddsp	r9,sp[0x8]
80008402:	f2 00 0b 07 	st.b	r9[r0],r7
80008406:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80008408:	f2 00 0b 08 	st.b	r9[r0],r8
8000840c:	2f f0       	sub	r0,-1
8000840e:	ca 0b       	rjmp	8000834e <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80008410:	0e 9b       	mov	r11,r7
80008412:	4c dc       	lddpc	r12,80008544 <follow_path+0x288>
80008414:	f0 1f 00 4d 	mcall	80008548 <follow_path+0x28c>
80008418:	e0 81 00 81 	brne	8000851a <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
8000841c:	0e 98       	mov	r8,r7
8000841e:	24 18       	sub	r8,65
80008420:	31 99       	mov	r9,25
80008422:	f2 08 18 00 	cp.b	r8,r9
80008426:	e0 8b 00 06 	brhi	80008432 <follow_path+0x176>
				b |= 2;
8000842a:	40 18       	lddsp	r8,sp[0x4]
8000842c:	a1 b8       	sbr	r8,0x1
8000842e:	50 18       	stdsp	sp[0x4],r8
80008430:	c0 d8       	rjmp	8000844a <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80008432:	0e 98       	mov	r8,r7
80008434:	26 18       	sub	r8,97
80008436:	31 9a       	mov	r10,25
80008438:	f4 08 18 00 	cp.b	r8,r10
8000843c:	e0 8b 00 07 	brhi	8000844a <follow_path+0x18e>
					b |= 1; c -= 0x20;
80008440:	40 19       	lddsp	r9,sp[0x4]
80008442:	a1 a9       	sbr	r9,0x0
80008444:	50 19       	stdsp	sp[0x4],r9
80008446:	22 07       	sub	r7,32
80008448:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
8000844a:	40 28       	lddsp	r8,sp[0x8]
8000844c:	f0 00 0b 07 	st.b	r8[r0],r7
80008450:	2f f0       	sub	r0,-1
80008452:	c7 eb       	rjmp	8000834e <follow_path+0x92>
80008454:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
80008456:	58 08       	cp.w	r8,0
80008458:	f9 b8 01 04 	movne	r8,4
8000845c:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80008460:	58 00       	cp.w	r0,0
80008462:	c5 c0       	breq	8000851a <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
80008464:	40 29       	lddsp	r9,sp[0x8]
80008466:	13 8a       	ld.ub	r10,r9[0x0]
80008468:	3e 59       	mov	r9,-27
8000846a:	f2 0a 18 00 	cp.b	r10,r9
8000846e:	f9 b9 00 05 	moveq	r9,5
80008472:	fb fa 00 02 	ld.weq	r10,sp[0x8]
80008476:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
8000847a:	40 09       	lddsp	r9,sp[0x0]
8000847c:	58 89       	cp.w	r9,8
8000847e:	c0 51       	brne	80008488 <follow_path+0x1cc>
80008480:	40 19       	lddsp	r9,sp[0x4]
80008482:	a3 69       	lsl	r9,0x2
80008484:	5c 59       	castu.b	r9
80008486:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80008488:	40 19       	lddsp	r9,sp[0x4]
8000848a:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
8000848e:	58 1a       	cp.w	r10,1
80008490:	c0 21       	brne	80008494 <follow_path+0x1d8>
80008492:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
80008494:	e2 19 00 0c 	andl	r9,0xc,COH
80008498:	58 49       	cp.w	r9,4
8000849a:	c0 21       	brne	8000849e <follow_path+0x1e2>
8000849c:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
8000849e:	40 2a       	lddsp	r10,sp[0x8]
800084a0:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
800084a4:	30 0b       	mov	r11,0
800084a6:	04 9c       	mov	r12,r2
800084a8:	f0 1f 00 25 	mcall	8000853c <follow_path+0x280>
	if (res != FR_OK) return res;
800084ac:	c2 11       	brne	800084ee <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
800084ae:	64 4b       	ld.w	r11,r2[0x10]
800084b0:	64 0c       	ld.w	r12,r2[0x0]
800084b2:	f0 1f 00 27 	mcall	8000854c <follow_path+0x290>
		if (res != FR_OK) break;
800084b6:	c1 c1       	brne	800084ee <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
800084b8:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
800084ba:	13 88       	ld.ub	r8,r9[0x0]
800084bc:	ec 08 18 00 	cp.b	r8,r6
800084c0:	c3 90       	breq	80008532 <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
800084c2:	f3 38 00 0b 	ld.ub	r8,r9[11]
800084c6:	e2 18 00 08 	andl	r8,0x8,COH
800084ca:	c0 d1       	brne	800084e4 <follow_path+0x228>
800084cc:	64 65       	ld.w	r5,r2[0x18]
800084ce:	c0 48       	rjmp	800084d6 <follow_path+0x21a>
800084d0:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
800084d2:	58 b8       	cp.w	r8,11
800084d4:	c2 80       	breq	80008524 <follow_path+0x268>
800084d6:	f2 08 07 0b 	ld.ub	r11,r9[r8]
800084da:	ea 08 07 0a 	ld.ub	r10,r5[r8]
800084de:	f4 0b 18 00 	cp.b	r11,r10
800084e2:	cf 70       	breq	800084d0 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
800084e4:	30 0b       	mov	r11,0
800084e6:	04 9c       	mov	r12,r2
800084e8:	f0 1f 00 1a 	mcall	80008550 <follow_path+0x294>
	} while (res == FR_OK);
800084ec:	ce 10       	breq	800084ae <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
800084ee:	64 68       	ld.w	r8,r2[0x18]
800084f0:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
800084f4:	58 4c       	cp.w	r12,4
800084f6:	c1 51       	brne	80008520 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
800084f8:	e2 18 00 04 	andl	r8,0x4,COH
800084fc:	c1 10       	breq	8000851e <follow_path+0x262>
800084fe:	30 4c       	mov	r12,4
80008500:	c1 08       	rjmp	80008520 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
80008502:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80008504:	f7 38 00 0b 	ld.ub	r8,r11[11]
80008508:	e2 18 00 10 	andl	r8,0x10,COH
8000850c:	c0 90       	breq	8000851e <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
8000850e:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
80008510:	64 0c       	ld.w	r12,r2[0x0]
80008512:	f0 1f 00 11 	mcall	80008554 <follow_path+0x298>
80008516:	85 2c       	st.w	r2[0x8],r12
		}
80008518:	cf 4a       	rjmp	80008300 <follow_path+0x44>
8000851a:	30 6c       	mov	r12,6
8000851c:	c0 28       	rjmp	80008520 <follow_path+0x264>
8000851e:	30 5c       	mov	r12,5
	}

	return res;
}
80008520:	2f dd       	sub	sp,-12
80008522:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80008524:	64 68       	ld.w	r8,r2[0x18]
80008526:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000852a:	e2 18 00 04 	andl	r8,0x4,COH
8000852e:	ce a0       	breq	80008502 <follow_path+0x246>
80008530:	cf 8b       	rjmp	80008520 <follow_path+0x264>
80008532:	64 68       	ld.w	r8,r2[0x18]
80008534:	f1 38 00 0b 	ld.ub	r8,r8[11]
80008538:	ce 0b       	rjmp	800084f8 <follow_path+0x23c>
8000853a:	00 00       	add	r0,r0
8000853c:	80 00       	ld.sh	r0,r0[0x0]
8000853e:	7b 54       	ld.w	r4,sp[0x54]
80008540:	80 00       	ld.sh	r0,r0[0x0]
80008542:	69 d6       	ld.w	r6,r4[0x74]
80008544:	80 01       	ld.sh	r1,r0[0x0]
80008546:	99 a0       	st.w	r12[0x28],r0
80008548:	80 00       	ld.sh	r0,r0[0x0]
8000854a:	69 e2       	ld.w	r2,r4[0x78]
8000854c:	80 00       	ld.sh	r0,r0[0x0]
8000854e:	73 48       	ld.w	r8,r9[0x50]
80008550:	80 00       	ld.sh	r0,r0[0x0]
80008552:	7c d8       	ld.w	r8,lr[0x34]
80008554:	80 00       	ld.sh	r0,r0[0x0]
80008556:	6a 52       	ld.w	r2,r5[0x14]

80008558 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80008558:	eb cd 40 80 	pushm	r7,lr
8000855c:	20 5d       	sub	sp,20
8000855e:	18 97       	mov	r7,r12
80008560:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
80008562:	58 0c       	cp.w	r12,0
80008564:	c0 31       	brne	8000856a <f_opendir+0x12>
80008566:	30 9c       	mov	r12,9
80008568:	c2 d8       	rjmp	800085c2 <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
8000856a:	30 0a       	mov	r10,0
8000856c:	1a 9b       	mov	r11,sp
8000856e:	fa cc ff f0 	sub	r12,sp,-16
80008572:	f0 1f 00 17 	mcall	800085cc <f_opendir+0x74>
	if (res == FR_OK) {
80008576:	c2 41       	brne	800085be <f_opendir+0x66>
		dp->fs = fs;
80008578:	40 48       	lddsp	r8,sp[0x10]
8000857a:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
8000857c:	fa c8 ff fc 	sub	r8,sp,-4
80008580:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
80008582:	40 0b       	lddsp	r11,sp[0x0]
80008584:	0e 9c       	mov	r12,r7
80008586:	f0 1f 00 13 	mcall	800085d0 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
8000858a:	c1 61       	brne	800085b6 <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
8000858c:	6e 5b       	ld.w	r11,r7[0x14]
8000858e:	58 0b       	cp.w	r11,0
80008590:	c0 c0       	breq	800085a8 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
80008592:	f7 38 00 0b 	ld.ub	r8,r11[11]
80008596:	e2 18 00 10 	andl	r8,0x10,COH
8000859a:	c0 31       	brne	800085a0 <f_opendir+0x48>
8000859c:	30 5c       	mov	r12,5
8000859e:	c0 e8       	rjmp	800085ba <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
800085a0:	40 4c       	lddsp	r12,sp[0x10]
800085a2:	f0 1f 00 0d 	mcall	800085d4 <f_opendir+0x7c>
800085a6:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
800085a8:	40 48       	lddsp	r8,sp[0x10]
800085aa:	90 38       	ld.sh	r8,r8[0x6]
800085ac:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
800085ae:	30 0b       	mov	r11,0
800085b0:	0e 9c       	mov	r12,r7
800085b2:	f0 1f 00 0a 	mcall	800085d8 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
800085b6:	58 4c       	cp.w	r12,4
800085b8:	c0 80       	breq	800085c8 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
800085ba:	58 0c       	cp.w	r12,0
800085bc:	c0 30       	breq	800085c2 <f_opendir+0x6a>
800085be:	30 08       	mov	r8,0
800085c0:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
800085c2:	2f bd       	sub	sp,-20
800085c4:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
800085c8:	30 5c       	mov	r12,5
800085ca:	cf ab       	rjmp	800085be <f_opendir+0x66>
800085cc:	80 00       	ld.sh	r0,r0[0x0]
800085ce:	74 24       	ld.w	r4,r10[0x8]
800085d0:	80 00       	ld.sh	r0,r0[0x0]
800085d2:	82 bc       	ld.uh	r12,r1[0x6]
800085d4:	80 00       	ld.sh	r0,r0[0x0]
800085d6:	6a 52       	ld.w	r2,r5[0x14]
800085d8:	80 00       	ld.sh	r0,r0[0x0]
800085da:	7b 54       	ld.w	r4,sp[0x54]

800085dc <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
800085dc:	d4 31       	pushm	r0-r7,lr
800085de:	21 0d       	sub	sp,64
800085e0:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
800085e2:	f0 1f 00 61 	mcall	80008764 <f_mkdir+0x188>
800085e6:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
800085e8:	30 1a       	mov	r10,1
800085ea:	fa cb ff f0 	sub	r11,sp,-16
800085ee:	fa cc ff e0 	sub	r12,sp,-32
800085f2:	f0 1f 00 5e 	mcall	80008768 <f_mkdir+0x18c>
800085f6:	18 97       	mov	r7,r12
	if (res == FR_OK) {
800085f8:	c0 30       	breq	800085fe <f_mkdir+0x22>
800085fa:	18 96       	mov	r6,r12
800085fc:	ca 78       	rjmp	8000874a <f_mkdir+0x16e>
		INIT_BUF(dj);
800085fe:	fa c8 ff ec 	sub	r8,sp,-20
80008602:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80008604:	40 4b       	lddsp	r11,sp[0x10]
80008606:	fa cc ff e0 	sub	r12,sp,-32
8000860a:	f0 1f 00 59 	mcall	8000876c <f_mkdir+0x190>
8000860e:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
80008610:	c0 31       	brne	80008616 <f_mkdir+0x3a>
80008612:	30 86       	mov	r6,8
80008614:	c9 b8       	rjmp	8000874a <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80008616:	58 4c       	cp.w	r12,4
80008618:	e0 81 00 99 	brne	8000874a <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
8000861c:	30 0b       	mov	r11,0
8000861e:	40 8c       	lddsp	r12,sp[0x20]
80008620:	f0 1f 00 54 	mcall	80008770 <f_mkdir+0x194>
80008624:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80008626:	c0 31       	brne	8000862c <f_mkdir+0x50>
80008628:	30 77       	mov	r7,7
8000862a:	c0 88       	rjmp	8000863a <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
8000862c:	58 1c       	cp.w	r12,1
8000862e:	c0 31       	brne	80008634 <f_mkdir+0x58>
80008630:	30 27       	mov	r7,2
80008632:	c6 c8       	rjmp	8000870a <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80008634:	5b fc       	cp.w	r12,-1
80008636:	e0 80 00 8d 	breq	80008750 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
8000863a:	58 07       	cp.w	r7,0
8000863c:	c6 71       	brne	8000870a <f_mkdir+0x12e>
				res = sync_window(dj.fs);
8000863e:	40 8c       	lddsp	r12,sp[0x20]
80008640:	f0 1f 00 4d 	mcall	80008774 <f_mkdir+0x198>
80008644:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80008646:	c6 21       	brne	8000870a <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80008648:	40 87       	lddsp	r7,sp[0x20]
8000864a:	04 9b       	mov	r11,r2
8000864c:	0e 9c       	mov	r12,r7
8000864e:	f0 1f 00 4b 	mcall	80008778 <f_mkdir+0x19c>
80008652:	18 94       	mov	r4,r12
				dir = dj.fs->win;
80008654:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80008658:	e0 6a 02 00 	mov	r10,512
8000865c:	30 0b       	mov	r11,0
8000865e:	06 9c       	mov	r12,r3
80008660:	f0 1f 00 47 	mcall	8000877c <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
80008664:	30 ba       	mov	r10,11
80008666:	32 0b       	mov	r11,32
80008668:	06 9c       	mov	r12,r3
8000866a:	f0 1f 00 45 	mcall	8000877c <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
8000866e:	32 e6       	mov	r6,46
80008670:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
80008674:	31 08       	mov	r8,16
80008676:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
8000867a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000867e:	50 38       	stdsp	sp[0xc],r8
80008680:	e7 68 00 16 	st.b	r3[22],r8
80008684:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80008688:	50 28       	stdsp	sp[0x8],r8
8000868a:	e7 68 00 17 	st.b	r3[23],r8
8000868e:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
80008692:	50 18       	stdsp	sp[0x4],r8
80008694:	e7 68 00 18 	st.b	r3[24],r8
80008698:	b9 85       	lsr	r5,0x18
8000869a:	50 05       	stdsp	sp[0x0],r5
8000869c:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
800086a0:	04 9b       	mov	r11,r2
800086a2:	06 9c       	mov	r12,r3
800086a4:	f0 1f 00 37 	mcall	80008780 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
800086a8:	2b 07       	sub	r7,-80
800086aa:	32 0a       	mov	r10,32
800086ac:	06 9b       	mov	r11,r3
800086ae:	0e 9c       	mov	r12,r7
800086b0:	f0 1f 00 35 	mcall	80008784 <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
800086b4:	e7 66 00 21 	st.b	r3[33],r6
800086b8:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
800086ba:	40 88       	lddsp	r8,sp[0x20]
800086bc:	11 8a       	ld.ub	r10,r8[0x0]
800086be:	30 39       	mov	r9,3
800086c0:	f2 0a 18 00 	cp.b	r10,r9
800086c4:	c0 51       	brne	800086ce <f_mkdir+0xf2>
800086c6:	70 98       	ld.w	r8,r8[0x24]
800086c8:	16 38       	cp.w	r8,r11
800086ca:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
800086ce:	0e 9c       	mov	r12,r7
800086d0:	f0 1f 00 2c 	mcall	80008780 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
800086d4:	40 88       	lddsp	r8,sp[0x20]
800086d6:	11 a6       	ld.ub	r6,r8[0x2]
800086d8:	58 06       	cp.w	r6,0
800086da:	c3 d0       	breq	80008754 <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
800086dc:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
800086de:	e0 61 02 00 	mov	r1,512
800086e2:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
800086e4:	40 88       	lddsp	r8,sp[0x20]
800086e6:	91 b4       	st.w	r8[0x2c],r4
800086e8:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
800086ea:	40 88       	lddsp	r8,sp[0x20]
800086ec:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
800086ee:	40 8c       	lddsp	r12,sp[0x20]
800086f0:	f0 1f 00 21 	mcall	80008774 <f_mkdir+0x198>
					if (res != FR_OK) break;
800086f4:	c0 a1       	brne	80008708 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
800086f6:	02 9a       	mov	r10,r1
800086f8:	00 9b       	mov	r11,r0
800086fa:	06 9c       	mov	r12,r3
800086fc:	f0 1f 00 20 	mcall	8000877c <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80008700:	20 16       	sub	r6,1
80008702:	5c 56       	castu.b	r6
80008704:	cf 01       	brne	800086e4 <f_mkdir+0x108>
80008706:	c2 78       	rjmp	80008754 <f_mkdir+0x178>
80008708:	18 97       	mov	r7,r12
8000870a:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
8000870c:	04 9b       	mov	r11,r2
8000870e:	40 8c       	lddsp	r12,sp[0x20]
80008710:	f0 1f 00 1e 	mcall	80008788 <f_mkdir+0x1ac>
80008714:	c1 b8       	rjmp	8000874a <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
80008716:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
80008718:	31 08       	mov	r8,16
8000871a:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
8000871e:	40 38       	lddsp	r8,sp[0xc]
80008720:	f9 68 00 16 	st.b	r12[22],r8
80008724:	40 28       	lddsp	r8,sp[0x8]
80008726:	f9 68 00 17 	st.b	r12[23],r8
8000872a:	40 18       	lddsp	r8,sp[0x4]
8000872c:	f9 68 00 18 	st.b	r12[24],r8
80008730:	40 08       	lddsp	r8,sp[0x0]
80008732:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
80008736:	04 9b       	mov	r11,r2
80008738:	f0 1f 00 12 	mcall	80008780 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
8000873c:	30 19       	mov	r9,1
8000873e:	40 88       	lddsp	r8,sp[0x20]
80008740:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
80008742:	40 8c       	lddsp	r12,sp[0x20]
80008744:	f0 1f 00 12 	mcall	8000878c <f_mkdir+0x1b0>
80008748:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
8000874a:	0c 9c       	mov	r12,r6
8000874c:	2f 0d       	sub	sp,-64
8000874e:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80008750:	30 17       	mov	r7,1
80008752:	cd cb       	rjmp	8000870a <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
80008754:	fa cc ff e0 	sub	r12,sp,-32
80008758:	f0 1f 00 0e 	mcall	80008790 <f_mkdir+0x1b4>
8000875c:	18 96       	mov	r6,r12
			if (res != FR_OK) {
8000875e:	cd c0       	breq	80008716 <f_mkdir+0x13a>
80008760:	cd 6b       	rjmp	8000870c <f_mkdir+0x130>
80008762:	00 00       	add	r0,r0
80008764:	80 00       	ld.sh	r0,r0[0x0]
80008766:	68 fc       	ld.w	r12,r4[0x3c]
80008768:	80 00       	ld.sh	r0,r0[0x0]
8000876a:	74 24       	ld.w	r4,r10[0x8]
8000876c:	80 00       	ld.sh	r0,r0[0x0]
8000876e:	82 bc       	ld.uh	r12,r1[0x6]
80008770:	80 00       	ld.sh	r0,r0[0x0]
80008772:	7c 08       	ld.w	r8,lr[0x0]
80008774:	80 00       	ld.sh	r0,r0[0x0]
80008776:	6b 50       	ld.w	r0,r5[0x54]
80008778:	80 00       	ld.sh	r0,r0[0x0]
8000877a:	69 fc       	ld.w	r12,r4[0x7c]
8000877c:	80 00       	ld.sh	r0,r0[0x0]
8000877e:	69 d6       	ld.w	r6,r4[0x74]
80008780:	80 00       	ld.sh	r0,r0[0x0]
80008782:	6a 7a       	ld.w	r10,r5[0x1c]
80008784:	80 00       	ld.sh	r0,r0[0x0]
80008786:	69 c0       	ld.w	r0,r4[0x70]
80008788:	80 00       	ld.sh	r0,r0[0x0]
8000878a:	7d e8       	ld.w	r8,lr[0x78]
8000878c:	80 00       	ld.sh	r0,r0[0x0]
8000878e:	6b b4       	ld.w	r4,r5[0x6c]
80008790:	80 00       	ld.sh	r0,r0[0x0]
80008792:	82 70       	ld.sh	r0,r1[0xe]

80008794 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
80008794:	eb cd 40 fc 	pushm	r2-r7,lr
80008798:	20 cd       	sub	sp,48
8000879a:	18 97       	mov	r7,r12
8000879c:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
8000879e:	58 0c       	cp.w	r12,0
800087a0:	c0 31       	brne	800087a6 <f_open+0x12>
800087a2:	30 96       	mov	r6,9
800087a4:	cb 68       	rjmp	80008910 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
800087a6:	30 08       	mov	r8,0
800087a8:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
800087aa:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
800087ae:	0a 93       	mov	r3,r5
800087b0:	e2 1a 00 1e 	andl	r10,0x1e,COH
800087b4:	1a 9b       	mov	r11,sp
800087b6:	fa cc ff f0 	sub	r12,sp,-16
800087ba:	f0 1f 00 5c 	mcall	80008928 <f_open+0x194>
800087be:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
800087c0:	e0 81 00 a8 	brne	80008910 <f_open+0x17c>
		INIT_BUF(dj);
800087c4:	fa c8 ff fc 	sub	r8,sp,-4
800087c8:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
800087ca:	40 0b       	lddsp	r11,sp[0x0]
800087cc:	fa cc ff f0 	sub	r12,sp,-16
800087d0:	f0 1f 00 57 	mcall	8000892c <f_open+0x198>
		dir = dj.dir;
800087d4:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
800087d6:	c0 41       	brne	800087de <f_open+0x4a>
			if (!dir)	/* Default directory itself */
800087d8:	58 04       	cp.w	r4,0
800087da:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
800087de:	06 98       	mov	r8,r3
800087e0:	e2 18 00 1c 	andl	r8,0x1c,COH
800087e4:	c5 f0       	breq	800088a2 <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
800087e6:	58 0c       	cp.w	r12,0
800087e8:	c0 d0       	breq	80008802 <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
800087ea:	58 4c       	cp.w	r12,4
800087ec:	e0 81 00 91 	brne	8000890e <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
800087f0:	fa cc ff f0 	sub	r12,sp,-16
800087f4:	f0 1f 00 4f 	mcall	80008930 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
800087f8:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
800087fa:	e0 81 00 8a 	brne	8000890e <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
800087fe:	a3 b5       	sbr	r5,0x3
80008800:	c0 c8       	rjmp	80008818 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
80008802:	e9 38 00 0b 	ld.ub	r8,r4[11]
80008806:	e2 18 00 11 	andl	r8,0x11,COH
8000880a:	c0 30       	breq	80008810 <f_open+0x7c>
8000880c:	30 7c       	mov	r12,7
8000880e:	c8 08       	rjmp	8000890e <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
80008810:	e2 13 00 04 	andl	r3,0x4,COH
80008814:	e0 81 00 82 	brne	80008918 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80008818:	0a 98       	mov	r8,r5
8000881a:	e2 18 00 08 	andl	r8,0x8,COH
8000881e:	c7 f0       	breq	8000891c <f_open+0x188>
				dw = GET_FATTIME();
80008820:	f0 1f 00 45 	mcall	80008934 <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
80008824:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
80008828:	e9 6a 00 0e 	st.b	r4[14],r10
8000882c:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008830:	e9 69 00 0f 	st.b	r4[15],r9
80008834:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80008838:	e9 68 00 10 	st.b	r4[16],r8
8000883c:	b9 8c       	lsr	r12,0x18
8000883e:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
80008842:	e9 6a 00 16 	st.b	r4[22],r10
80008846:	e9 69 00 17 	st.b	r4[23],r9
8000884a:	e9 68 00 18 	st.b	r4[24],r8
8000884e:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
80008852:	30 08       	mov	r8,0
80008854:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
80008858:	e9 68 00 1c 	st.b	r4[28],r8
8000885c:	e9 68 00 1d 	st.b	r4[29],r8
80008860:	e9 68 00 1e 	st.b	r4[30],r8
80008864:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
80008868:	08 9b       	mov	r11,r4
8000886a:	40 4c       	lddsp	r12,sp[0x10]
8000886c:	f0 1f 00 33 	mcall	80008938 <f_open+0x1a4>
80008870:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
80008872:	30 0b       	mov	r11,0
80008874:	08 9c       	mov	r12,r4
80008876:	f0 1f 00 32 	mcall	8000893c <f_open+0x1a8>
				dj.fs->wflag = 1;
8000887a:	30 19       	mov	r9,1
8000887c:	40 48       	lddsp	r8,sp[0x10]
8000887e:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
80008880:	58 03       	cp.w	r3,0
80008882:	c4 d0       	breq	8000891c <f_open+0x188>
					dw = dj.fs->winsect;
80008884:	40 4c       	lddsp	r12,sp[0x10]
80008886:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
80008888:	06 9b       	mov	r11,r3
8000888a:	f0 1f 00 2e 	mcall	80008940 <f_open+0x1ac>
					if (res == FR_OK) {
8000888e:	c4 01       	brne	8000890e <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
80008890:	20 13       	sub	r3,1
80008892:	40 48       	lddsp	r8,sp[0x10]
80008894:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
80008896:	04 9b       	mov	r11,r2
80008898:	40 4c       	lddsp	r12,sp[0x10]
8000889a:	f0 1f 00 2b 	mcall	80008944 <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
8000889e:	c1 40       	breq	800088c6 <f_open+0x132>
800088a0:	c3 78       	rjmp	8000890e <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
800088a2:	58 0c       	cp.w	r12,0
800088a4:	c3 51       	brne	8000890e <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
800088a6:	e9 38 00 0b 	ld.ub	r8,r4[11]
800088aa:	10 99       	mov	r9,r8
800088ac:	e2 19 00 10 	andl	r9,0x10,COH
800088b0:	c0 30       	breq	800088b6 <f_open+0x122>
800088b2:	30 4c       	mov	r12,4
800088b4:	c2 d8       	rjmp	8000890e <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
800088b6:	e2 13 00 02 	andl	r3,0x2,COH
800088ba:	c3 10       	breq	8000891c <f_open+0x188>
800088bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800088c0:	c2 e0       	breq	8000891c <f_open+0x188>
800088c2:	30 7c       	mov	r12,7
800088c4:	c2 58       	rjmp	8000890e <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
800088c6:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
800088c8:	40 43       	lddsp	r3,sp[0x10]
800088ca:	66 b8       	ld.w	r8,r3[0x2c]
800088cc:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
800088ce:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
800088d0:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
800088d2:	30 08       	mov	r8,0
800088d4:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
800088d6:	08 9b       	mov	r11,r4
800088d8:	06 9c       	mov	r12,r3
800088da:	f0 1f 00 18 	mcall	80008938 <f_open+0x1a4>
800088de:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
800088e0:	e9 39 00 1f 	ld.ub	r9,r4[31]
800088e4:	e9 38 00 1e 	ld.ub	r8,r4[30]
800088e8:	b1 68       	lsl	r8,0x10
800088ea:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800088ee:	e9 39 00 1c 	ld.ub	r9,r4[28]
800088f2:	12 48       	or	r8,r9
800088f4:	e9 39 00 1d 	ld.ub	r9,r4[29]
800088f8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800088fc:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
800088fe:	30 08       	mov	r8,0
80008900:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
80008902:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
80008904:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
80008906:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
80008908:	86 38       	ld.sh	r8,r3[0x6]
8000890a:	ae 28       	st.h	r7[0x4],r8
8000890c:	c0 28       	rjmp	80008910 <f_open+0x17c>
8000890e:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
80008910:	0c 9c       	mov	r12,r6
80008912:	2f 4d       	sub	sp,-48
80008914:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
80008918:	30 8c       	mov	r12,8
8000891a:	cf ab       	rjmp	8000890e <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
8000891c:	0a 98       	mov	r8,r5
8000891e:	e2 18 00 08 	andl	r8,0x8,COH
80008922:	cd 30       	breq	800088c8 <f_open+0x134>
80008924:	cd 1b       	rjmp	800088c6 <f_open+0x132>
80008926:	00 00       	add	r0,r0
80008928:	80 00       	ld.sh	r0,r0[0x0]
8000892a:	74 24       	ld.w	r4,r10[0x8]
8000892c:	80 00       	ld.sh	r0,r0[0x0]
8000892e:	82 bc       	ld.uh	r12,r1[0x6]
80008930:	80 00       	ld.sh	r0,r0[0x0]
80008932:	82 70       	ld.sh	r0,r1[0xe]
80008934:	80 00       	ld.sh	r0,r0[0x0]
80008936:	68 fc       	ld.w	r12,r4[0x3c]
80008938:	80 00       	ld.sh	r0,r0[0x0]
8000893a:	6a 52       	ld.w	r2,r5[0x14]
8000893c:	80 00       	ld.sh	r0,r0[0x0]
8000893e:	6a 7a       	ld.w	r10,r5[0x1c]
80008940:	80 00       	ld.sh	r0,r0[0x0]
80008942:	7d e8       	ld.w	r8,lr[0x78]
80008944:	80 00       	ld.sh	r0,r0[0x0]
80008946:	73 48       	ld.w	r8,r9[0x50]

80008948 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008948:	d4 31       	pushm	r0-r7,lr
8000894a:	20 2d       	sub	sp,8
8000894c:	fa c7 ff f8 	sub	r7,sp,-8
80008950:	0e dc       	st.w	--r7,r12
80008952:	16 90       	mov	r0,r11
80008954:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
80008956:	30 0a       	mov	r10,0
80008958:	0e 9b       	mov	r11,r7
8000895a:	0c 9c       	mov	r12,r6
8000895c:	f0 1f 00 33 	mcall	80008a28 <f_getfree+0xe0>
80008960:	18 93       	mov	r3,r12
	fs = *fatfs;
80008962:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
80008964:	c5 f1       	brne	80008a22 <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
80008966:	6c 48       	ld.w	r8,r6[0x10]
80008968:	6c 57       	ld.w	r7,r6[0x14]
8000896a:	ee c9 00 02 	sub	r9,r7,2
8000896e:	12 38       	cp.w	r8,r9
80008970:	e0 8b 00 04 	brhi	80008978 <f_getfree+0x30>
			*nclst = fs->free_clust;
80008974:	81 08       	st.w	r0[0x0],r8
80008976:	c5 68       	rjmp	80008a22 <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
80008978:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
8000897a:	30 18       	mov	r8,1
8000897c:	f0 04 18 00 	cp.b	r4,r8
80008980:	c1 71       	brne	800089ae <f_getfree+0x66>
80008982:	30 27       	mov	r7,2
80008984:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
80008986:	0e 9b       	mov	r11,r7
80008988:	0c 9c       	mov	r12,r6
8000898a:	f0 1f 00 29 	mcall	80008a2c <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
8000898e:	5b fc       	cp.w	r12,-1
80008990:	c0 31       	brne	80008996 <f_getfree+0x4e>
80008992:	30 1c       	mov	r12,1
80008994:	c4 28       	rjmp	80008a18 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
80008996:	58 1c       	cp.w	r12,1
80008998:	c0 31       	brne	8000899e <f_getfree+0x56>
8000899a:	30 2c       	mov	r12,2
8000899c:	c3 e8       	rjmp	80008a18 <f_getfree+0xd0>
					if (stat == 0) nfree++;
8000899e:	58 0c       	cp.w	r12,0
800089a0:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
800089a4:	2f f7       	sub	r7,-1
800089a6:	6c 58       	ld.w	r8,r6[0x14]
800089a8:	10 37       	cp.w	r7,r8
800089aa:	ce e3       	brcs	80008986 <f_getfree+0x3e>
800089ac:	c3 58       	rjmp	80008a16 <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
800089ae:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
800089b0:	30 08       	mov	r8,0
800089b2:	10 99       	mov	r9,r8
800089b4:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800089b6:	ec ca ff d0 	sub	r10,r6,-48
800089ba:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800089bc:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
800089be:	58 09       	cp.w	r9,0
800089c0:	c0 a1       	brne	800089d4 <f_getfree+0x8c>
						res = move_window(fs, sect++);
800089c2:	02 9b       	mov	r11,r1
800089c4:	0c 9c       	mov	r12,r6
800089c6:	f0 1f 00 1b 	mcall	80008a30 <f_getfree+0xe8>
						if (res != FR_OK) break;
800089ca:	c2 71       	brne	80008a18 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800089cc:	2f f1       	sub	r1,-1
800089ce:	40 08       	lddsp	r8,sp[0x0]
800089d0:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800089d4:	e4 04 18 00 	cp.b	r4,r2
800089d8:	c0 d1       	brne	800089f2 <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
800089da:	11 9b       	ld.ub	r11,r8[0x1]
800089dc:	11 8a       	ld.ub	r10,r8[0x0]
800089de:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800089e2:	30 0b       	mov	r11,0
800089e4:	f6 0a 19 00 	cp.h	r10,r11
800089e8:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
800089ec:	2f e8       	sub	r8,-2
800089ee:	20 29       	sub	r9,2
800089f0:	c1 18       	rjmp	80008a12 <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
800089f2:	11 bb       	ld.ub	r11,r8[0x3]
800089f4:	11 aa       	ld.ub	r10,r8[0x2]
800089f6:	b1 6a       	lsl	r10,0x10
800089f8:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
800089fc:	11 8b       	ld.ub	r11,r8[0x0]
800089fe:	16 4a       	or	r10,r11
80008a00:	11 9b       	ld.ub	r11,r8[0x1]
80008a02:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80008a06:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
80008a0a:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
80008a0e:	2f c8       	sub	r8,-4
80008a10:	20 49       	sub	r9,4
					}
				} while (--clst);
80008a12:	20 17       	sub	r7,1
80008a14:	cd 51       	brne	800089be <f_getfree+0x76>
80008a16:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
80008a18:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
80008a1a:	0d d8       	ld.ub	r8,r6[0x5]
80008a1c:	a1 a8       	sbr	r8,0x0
80008a1e:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
80008a20:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
80008a22:	2f ed       	sub	sp,-8
80008a24:	d8 32       	popm	r0-r7,pc
80008a26:	00 00       	add	r0,r0
80008a28:	80 00       	ld.sh	r0,r0[0x0]
80008a2a:	74 24       	ld.w	r4,r10[0x8]
80008a2c:	80 00       	ld.sh	r0,r0[0x0]
80008a2e:	7a 70       	ld.w	r0,sp[0x1c]
80008a30:	80 00       	ld.sh	r0,r0[0x0]
80008a32:	73 48       	ld.w	r8,r9[0x50]

80008a34 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
80008a34:	d4 31       	pushm	r0-r7,lr
80008a36:	18 97       	mov	r7,r12
80008a38:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
80008a3a:	f0 1f 00 a5 	mcall	80008ccc <f_lseek+0x298>
80008a3e:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008a40:	e0 81 01 44 	brne	80008cc8 <f_lseek+0x294>
	if (fp->err)						/* Check error */
80008a44:	0f f8       	ld.ub	r8,r7[0x7]
80008a46:	58 08       	cp.w	r8,0
80008a48:	c0 30       	breq	80008a4e <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008a4a:	10 96       	mov	r6,r8
80008a4c:	c3 e9       	rjmp	80008cc8 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
80008a4e:	6e 93       	ld.w	r3,r7[0x24]
80008a50:	58 03       	cp.w	r3,0
80008a52:	e0 80 00 85 	breq	80008b5c <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
80008a56:	5b f5       	cp.w	r5,-1
80008a58:	c3 71       	brne	80008ac6 <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
80008a5a:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
80008a5c:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
80008a5e:	58 01       	cp.w	r1,0
80008a60:	c2 80       	breq	80008ab0 <f_lseek+0x7c>
80008a62:	30 22       	mov	r2,2
80008a64:	02 95       	mov	r5,r1
80008a66:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
80008a68:	0a 9b       	mov	r11,r5
80008a6a:	6e 0c       	ld.w	r12,r7[0x0]
80008a6c:	f0 1f 00 99 	mcall	80008cd0 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008a70:	58 1c       	cp.w	r12,1
80008a72:	e0 8b 00 06 	brhi	80008a7e <f_lseek+0x4a>
80008a76:	30 28       	mov	r8,2
80008a78:	ae f8       	st.b	r7[0x7],r8
80008a7a:	30 26       	mov	r6,2
80008a7c:	c2 69       	rjmp	80008cc8 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008a7e:	5b fc       	cp.w	r12,-1
80008a80:	c0 51       	brne	80008a8a <f_lseek+0x56>
80008a82:	30 18       	mov	r8,1
80008a84:	ae f8       	st.b	r7[0x7],r8
80008a86:	30 16       	mov	r6,1
80008a88:	c2 09       	rjmp	80008cc8 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
80008a8a:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
80008a8c:	2f f5       	sub	r5,-1
80008a8e:	0a 3c       	cp.w	r12,r5
80008a90:	c0 31       	brne	80008a96 <f_lseek+0x62>
80008a92:	18 95       	mov	r5,r12
80008a94:	ce ab       	rjmp	80008a68 <f_lseek+0x34>
80008a96:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
80008a98:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
80008a9a:	04 30       	cp.w	r0,r2
80008a9c:	c0 33       	brcs	80008aa2 <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
80008a9e:	06 a4       	st.w	r3++,r4
80008aa0:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
80008aa2:	6e 09       	ld.w	r9,r7[0x0]
80008aa4:	72 59       	ld.w	r9,r9[0x14]
80008aa6:	10 39       	cp.w	r9,r8
80008aa8:	e0 88 00 05 	brls	80008ab2 <f_lseek+0x7e>
80008aac:	18 91       	mov	r1,r12
80008aae:	cd bb       	rjmp	80008a64 <f_lseek+0x30>
80008ab0:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
80008ab2:	6e 98       	ld.w	r8,r7[0x24]
80008ab4:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
80008ab6:	00 32       	cp.w	r2,r0
80008ab8:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
80008abc:	f9 b8 08 00 	movls	r8,0
80008ac0:	e7 f8 8a 00 	st.wls	r3[0x0],r8
80008ac4:	c0 29       	rjmp	80008cc8 <f_lseek+0x294>
80008ac6:	6e 34       	ld.w	r4,r7[0xc]
80008ac8:	08 35       	cp.w	r5,r4
80008aca:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
80008ace:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
80008ad0:	58 05       	cp.w	r5,0
80008ad2:	e0 80 00 fb 	breq	80008cc8 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
80008ad6:	ea c4 00 01 	sub	r4,r5,1
80008ada:	08 9b       	mov	r11,r4
80008adc:	0e 9c       	mov	r12,r7
80008ade:	f0 1f 00 7e 	mcall	80008cd4 <f_lseek+0x2a0>
80008ae2:	18 9b       	mov	r11,r12
80008ae4:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
80008ae6:	6e 05       	ld.w	r5,r7[0x0]
80008ae8:	0a 9c       	mov	r12,r5
80008aea:	f0 1f 00 7c 	mcall	80008cd8 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
80008aee:	c0 51       	brne	80008af8 <f_lseek+0xc4>
80008af0:	30 28       	mov	r8,2
80008af2:	ae f8       	st.b	r7[0x7],r8
80008af4:	30 26       	mov	r6,2
80008af6:	ce 98       	rjmp	80008cc8 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008af8:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
80008afa:	6e 28       	ld.w	r8,r7[0x8]
80008afc:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008b00:	e0 80 00 e4 	breq	80008cc8 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008b04:	20 19       	sub	r9,1
80008b06:	f3 e4 02 94 	and	r4,r9,r4>>0x9
80008b0a:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
80008b0e:	6e 6a       	ld.w	r10,r7[0x18]
80008b10:	08 3a       	cp.w	r10,r4
80008b12:	e0 80 00 db 	breq	80008cc8 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008b16:	0f e8       	ld.ub	r8,r7[0x6]
80008b18:	e2 18 00 40 	andl	r8,0x40,COH
80008b1c:	c0 f0       	breq	80008b3a <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008b1e:	30 19       	mov	r9,1
80008b20:	ee cb ff d8 	sub	r11,r7,-40
80008b24:	0b 9c       	ld.ub	r12,r5[0x1]
80008b26:	f0 1f 00 6e 	mcall	80008cdc <f_lseek+0x2a8>
80008b2a:	c0 50       	breq	80008b34 <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
80008b2c:	30 18       	mov	r8,1
80008b2e:	ae f8       	st.b	r7[0x7],r8
80008b30:	30 16       	mov	r6,1
80008b32:	cc b8       	rjmp	80008cc8 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
80008b34:	0f e8       	ld.ub	r8,r7[0x6]
80008b36:	a7 c8       	cbr	r8,0x6
80008b38:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
80008b3a:	6e 08       	ld.w	r8,r7[0x0]
80008b3c:	30 19       	mov	r9,1
80008b3e:	08 9a       	mov	r10,r4
80008b40:	ee cb ff d8 	sub	r11,r7,-40
80008b44:	11 9c       	ld.ub	r12,r8[0x1]
80008b46:	f0 1f 00 67 	mcall	80008ce0 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
80008b4a:	f9 b8 01 01 	movne	r8,1
80008b4e:	ef f8 1e 07 	st.bne	r7[0x7],r8
80008b52:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
80008b56:	ef f4 0a 06 	st.weq	r7[0x18],r4
80008b5a:	cb 78       	rjmp	80008cc8 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008b5c:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
80008b5e:	08 35       	cp.w	r5,r4
80008b60:	e0 88 00 06 	brls	80008b6c <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008b64:	0f e8       	ld.ub	r8,r7[0x6]
80008b66:	e2 18 00 02 	andl	r8,0x2,COH
80008b6a:	c0 20       	breq	80008b6e <f_lseek+0x13a>
80008b6c:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
80008b6e:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008b70:	30 08       	mov	r8,0
80008b72:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
80008b74:	58 04       	cp.w	r4,0
80008b76:	e0 80 00 a9 	breq	80008cc8 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
80008b7a:	6e 08       	ld.w	r8,r7[0x0]
80008b7c:	11 a5       	ld.ub	r5,r8[0x2]
80008b7e:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
80008b80:	58 09       	cp.w	r9,0
80008b82:	c1 30       	breq	80008ba8 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
80008b84:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
80008b86:	e8 cb 00 01 	sub	r11,r4,1
80008b8a:	f6 05 0d 0a 	divu	r10,r11,r5
80008b8e:	14 9b       	mov	r11,r10
80008b90:	f2 05 0d 02 	divu	r2,r9,r5
80008b94:	04 3b       	cp.w	r11,r2
80008b96:	c0 93       	brcs	80008ba8 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
80008b98:	ea 08 11 00 	rsub	r8,r5,0
80008b9c:	f1 e9 00 09 	and	r9,r8,r9
80008ba0:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
80008ba2:	12 14       	sub	r4,r9
				clst = fp->clust;
80008ba4:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
80008ba6:	c1 68       	rjmp	80008bd2 <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
80008ba8:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
80008baa:	58 0c       	cp.w	r12,0
80008bac:	c1 21       	brne	80008bd0 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
80008bae:	30 0b       	mov	r11,0
80008bb0:	10 9c       	mov	r12,r8
80008bb2:	f0 1f 00 4d 	mcall	80008ce4 <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008bb6:	58 1c       	cp.w	r12,1
80008bb8:	c0 51       	brne	80008bc2 <f_lseek+0x18e>
80008bba:	30 28       	mov	r8,2
80008bbc:	ae f8       	st.b	r7[0x7],r8
80008bbe:	30 26       	mov	r6,2
80008bc0:	c8 48       	rjmp	80008cc8 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008bc2:	5b fc       	cp.w	r12,-1
80008bc4:	c0 51       	brne	80008bce <f_lseek+0x19a>
80008bc6:	30 18       	mov	r8,1
80008bc8:	ae f8       	st.b	r7[0x7],r8
80008bca:	30 16       	mov	r6,1
80008bcc:	c7 e8       	rjmp	80008cc8 <f_lseek+0x294>
					fp->sclust = clst;
80008bce:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
80008bd0:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
80008bd2:	58 0c       	cp.w	r12,0
80008bd4:	c4 80       	breq	80008c64 <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
80008bd6:	0a 34       	cp.w	r4,r5
80008bd8:	e0 88 00 32 	brls	80008c3c <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
80008bdc:	ea 03 11 00 	rsub	r3,r5,0
80008be0:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
80008be2:	0f e8       	ld.ub	r8,r7[0x6]
80008be4:	e2 18 00 02 	andl	r8,0x2,COH
80008be8:	c0 70       	breq	80008bf6 <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
80008bea:	18 9b       	mov	r11,r12
80008bec:	6e 0c       	ld.w	r12,r7[0x0]
80008bee:	f0 1f 00 3e 	mcall	80008ce4 <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
80008bf2:	c0 61       	brne	80008bfe <f_lseek+0x1ca>
80008bf4:	c2 38       	rjmp	80008c3a <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
80008bf6:	18 9b       	mov	r11,r12
80008bf8:	6e 0c       	ld.w	r12,r7[0x0]
80008bfa:	f0 1f 00 36 	mcall	80008cd0 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008bfe:	5b fc       	cp.w	r12,-1
80008c00:	c0 51       	brne	80008c0a <f_lseek+0x1d6>
80008c02:	30 18       	mov	r8,1
80008c04:	ae f8       	st.b	r7[0x7],r8
80008c06:	30 16       	mov	r6,1
80008c08:	c6 08       	rjmp	80008cc8 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
80008c0a:	58 1c       	cp.w	r12,1
80008c0c:	e0 88 00 06 	brls	80008c18 <f_lseek+0x1e4>
80008c10:	6e 08       	ld.w	r8,r7[0x0]
80008c12:	70 58       	ld.w	r8,r8[0x14]
80008c14:	10 3c       	cp.w	r12,r8
80008c16:	c0 53       	brcs	80008c20 <f_lseek+0x1ec>
80008c18:	30 28       	mov	r8,2
80008c1a:	ae f8       	st.b	r7[0x7],r8
80008c1c:	30 26       	mov	r6,2
80008c1e:	c5 58       	rjmp	80008cc8 <f_lseek+0x294>
					fp->clust = clst;
80008c20:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
80008c22:	6e 28       	ld.w	r8,r7[0x8]
80008c24:	0a 08       	add	r8,r5
80008c26:	8f 28       	st.w	r7[0x8],r8
80008c28:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
80008c2c:	f0 05 00 09 	add	r9,r8,r5
80008c30:	0a 39       	cp.w	r9,r5
80008c32:	e0 88 00 05 	brls	80008c3c <f_lseek+0x208>
80008c36:	10 94       	mov	r4,r8
80008c38:	cd 5b       	rjmp	80008be2 <f_lseek+0x1ae>
80008c3a:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
80008c3c:	6e 28       	ld.w	r8,r7[0x8]
80008c3e:	08 08       	add	r8,r4
80008c40:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
80008c42:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
80008c46:	c0 f0       	breq	80008c64 <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008c48:	18 9b       	mov	r11,r12
80008c4a:	6e 0c       	ld.w	r12,r7[0x0]
80008c4c:	f0 1f 00 23 	mcall	80008cd8 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008c50:	c0 51       	brne	80008c5a <f_lseek+0x226>
80008c52:	30 28       	mov	r8,2
80008c54:	ae f8       	st.b	r7[0x7],r8
80008c56:	30 26       	mov	r6,2
80008c58:	c3 88       	rjmp	80008cc8 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
80008c5a:	e8 05 16 09 	lsr	r5,r4,0x9
80008c5e:	f8 05 00 05 	add	r5,r12,r5
80008c62:	c0 28       	rjmp	80008c66 <f_lseek+0x232>
80008c64:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
80008c66:	6e 28       	ld.w	r8,r7[0x8]
80008c68:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008c6c:	c2 50       	breq	80008cb6 <f_lseek+0x282>
80008c6e:	6e 6a       	ld.w	r10,r7[0x18]
80008c70:	0a 3a       	cp.w	r10,r5
80008c72:	c2 20       	breq	80008cb6 <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
80008c74:	0f e8       	ld.ub	r8,r7[0x6]
80008c76:	e2 18 00 40 	andl	r8,0x40,COH
80008c7a:	c1 00       	breq	80008c9a <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008c7c:	6e 08       	ld.w	r8,r7[0x0]
80008c7e:	30 19       	mov	r9,1
80008c80:	ee cb ff d8 	sub	r11,r7,-40
80008c84:	11 9c       	ld.ub	r12,r8[0x1]
80008c86:	f0 1f 00 16 	mcall	80008cdc <f_lseek+0x2a8>
80008c8a:	c0 50       	breq	80008c94 <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
80008c8c:	30 18       	mov	r8,1
80008c8e:	ae f8       	st.b	r7[0x7],r8
80008c90:	30 16       	mov	r6,1
80008c92:	c1 b8       	rjmp	80008cc8 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
80008c94:	0f e8       	ld.ub	r8,r7[0x6]
80008c96:	a7 c8       	cbr	r8,0x6
80008c98:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
80008c9a:	6e 08       	ld.w	r8,r7[0x0]
80008c9c:	30 19       	mov	r9,1
80008c9e:	0a 9a       	mov	r10,r5
80008ca0:	ee cb ff d8 	sub	r11,r7,-40
80008ca4:	11 9c       	ld.ub	r12,r8[0x1]
80008ca6:	f0 1f 00 0f 	mcall	80008ce0 <f_lseek+0x2ac>
80008caa:	c0 50       	breq	80008cb4 <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
80008cac:	30 18       	mov	r8,1
80008cae:	ae f8       	st.b	r7[0x7],r8
80008cb0:	30 16       	mov	r6,1
80008cb2:	c0 b8       	rjmp	80008cc8 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
80008cb4:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
80008cb6:	6e 28       	ld.w	r8,r7[0x8]
80008cb8:	6e 39       	ld.w	r9,r7[0xc]
80008cba:	12 38       	cp.w	r8,r9
80008cbc:	e0 88 00 06 	brls	80008cc8 <f_lseek+0x294>
			fp->fsize = fp->fptr;
80008cc0:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
80008cc2:	0f e8       	ld.ub	r8,r7[0x6]
80008cc4:	a5 b8       	sbr	r8,0x5
80008cc6:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
80008cc8:	0c 9c       	mov	r12,r6
80008cca:	d8 32       	popm	r0-r7,pc
80008ccc:	80 00       	ld.sh	r0,r0[0x0]
80008cce:	73 14       	ld.w	r4,r9[0x44]
80008cd0:	80 00       	ld.sh	r0,r0[0x0]
80008cd2:	7a 70       	ld.w	r0,sp[0x1c]
80008cd4:	80 00       	ld.sh	r0,r0[0x0]
80008cd6:	6a 14       	ld.w	r4,r5[0x4]
80008cd8:	80 00       	ld.sh	r0,r0[0x0]
80008cda:	69 fc       	ld.w	r12,r4[0x7c]
80008cdc:	80 00       	ld.sh	r0,r0[0x0]
80008cde:	69 88       	ld.w	r8,r4[0x60]
80008ce0:	80 00       	ld.sh	r0,r0[0x0]
80008ce2:	69 a4       	ld.w	r4,r4[0x68]
80008ce4:	80 00       	ld.sh	r0,r0[0x0]
80008ce6:	7c 08       	ld.w	r8,lr[0x0]

80008ce8 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
80008ce8:	d4 31       	pushm	r0-r7,lr
80008cea:	20 3d       	sub	sp,12
80008cec:	18 97       	mov	r7,r12
80008cee:	16 93       	mov	r3,r11
80008cf0:	14 96       	mov	r6,r10
80008cf2:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
80008cf4:	30 08       	mov	r8,0
80008cf6:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
80008cf8:	f0 1f 00 6d 	mcall	80008eac <f_write+0x1c4>
80008cfc:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008cfe:	e0 81 00 d3 	brne	80008ea4 <f_write+0x1bc>
	if (fp->err)							/* Check error */
80008d02:	0f f8       	ld.ub	r8,r7[0x7]
80008d04:	58 08       	cp.w	r8,0
80008d06:	c0 30       	breq	80008d0c <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008d08:	10 92       	mov	r2,r8
80008d0a:	cc d8       	rjmp	80008ea4 <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
80008d0c:	0f e8       	ld.ub	r8,r7[0x6]
80008d0e:	e2 18 00 02 	andl	r8,0x2,COH
80008d12:	c0 31       	brne	80008d18 <f_write+0x30>
80008d14:	30 72       	mov	r2,7
80008d16:	cc 78       	rjmp	80008ea4 <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
80008d18:	6e 28       	ld.w	r8,r7[0x8]
80008d1a:	ec 08 00 09 	add	r9,r6,r8
80008d1e:	12 38       	cp.w	r8,r9
80008d20:	e0 8b 00 ba 	brhi	80008e94 <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
80008d24:	58 06       	cp.w	r6,0
80008d26:	e0 80 00 b7 	breq	80008e94 <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008d2a:	ee c8 ff d8 	sub	r8,r7,-40
80008d2e:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008d30:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008d32:	50 2c       	stdsp	sp[0x8],r12
80008d34:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
80008d36:	6e 2b       	ld.w	r11,r7[0x8]
80008d38:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008d3c:	e0 81 00 8c 	brne	80008e54 <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008d40:	6e 08       	ld.w	r8,r7[0x0]
80008d42:	11 a6       	ld.ub	r6,r8[0x2]
80008d44:	20 16       	sub	r6,1
80008d46:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008d4a:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008d4c:	c2 91       	brne	80008d9e <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
80008d4e:	58 0b       	cp.w	r11,0
80008d50:	c0 81       	brne	80008d60 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
80008d52:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
80008d54:	58 0c       	cp.w	r12,0
80008d56:	c1 31       	brne	80008d7c <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008d58:	10 9c       	mov	r12,r8
80008d5a:	f0 1f 00 56 	mcall	80008eb0 <f_write+0x1c8>
80008d5e:	c0 c8       	rjmp	80008d76 <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008d60:	6e 99       	ld.w	r9,r7[0x24]
80008d62:	58 09       	cp.w	r9,0
80008d64:	c0 50       	breq	80008d6e <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
80008d66:	0e 9c       	mov	r12,r7
80008d68:	f0 1f 00 53 	mcall	80008eb4 <f_write+0x1cc>
80008d6c:	c0 58       	rjmp	80008d76 <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
80008d6e:	6e 5b       	ld.w	r11,r7[0x14]
80008d70:	10 9c       	mov	r12,r8
80008d72:	f0 1f 00 50 	mcall	80008eb0 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
80008d76:	58 0c       	cp.w	r12,0
80008d78:	e0 80 00 8b 	breq	80008e8e <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008d7c:	58 1c       	cp.w	r12,1
80008d7e:	c0 51       	brne	80008d88 <f_write+0xa0>
80008d80:	30 28       	mov	r8,2
80008d82:	ae f8       	st.b	r7[0x7],r8
80008d84:	30 22       	mov	r2,2
80008d86:	c8 f8       	rjmp	80008ea4 <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008d88:	5b fc       	cp.w	r12,-1
80008d8a:	c0 51       	brne	80008d94 <f_write+0xac>
80008d8c:	30 18       	mov	r8,1
80008d8e:	ae f8       	st.b	r7[0x7],r8
80008d90:	30 12       	mov	r2,1
80008d92:	c8 98       	rjmp	80008ea4 <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
80008d94:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
80008d96:	6e 48       	ld.w	r8,r7[0x10]
80008d98:	58 08       	cp.w	r8,0
80008d9a:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
80008d9e:	0f e8       	ld.ub	r8,r7[0x6]
80008da0:	e2 18 00 40 	andl	r8,0x40,COH
80008da4:	c1 00       	breq	80008dc4 <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008da6:	6e 08       	ld.w	r8,r7[0x0]
80008da8:	30 19       	mov	r9,1
80008daa:	6e 6a       	ld.w	r10,r7[0x18]
80008dac:	40 1b       	lddsp	r11,sp[0x4]
80008dae:	11 9c       	ld.ub	r12,r8[0x1]
80008db0:	f0 1f 00 42 	mcall	80008eb8 <f_write+0x1d0>
80008db4:	c0 50       	breq	80008dbe <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
80008db6:	30 18       	mov	r8,1
80008db8:	ae f8       	st.b	r7[0x7],r8
80008dba:	30 12       	mov	r2,1
80008dbc:	c7 48       	rjmp	80008ea4 <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
80008dbe:	0f e8       	ld.ub	r8,r7[0x6]
80008dc0:	a7 c8       	cbr	r8,0x6
80008dc2:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
80008dc4:	6e 01       	ld.w	r1,r7[0x0]
80008dc6:	6e 5b       	ld.w	r11,r7[0x14]
80008dc8:	02 9c       	mov	r12,r1
80008dca:	f0 1f 00 3d 	mcall	80008ebc <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008dce:	c0 51       	brne	80008dd8 <f_write+0xf0>
80008dd0:	30 28       	mov	r8,2
80008dd2:	ae f8       	st.b	r7[0x7],r8
80008dd4:	30 22       	mov	r2,2
80008dd6:	c6 78       	rjmp	80008ea4 <f_write+0x1bc>
			sect += csect;
80008dd8:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
80008ddc:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
80008de0:	c2 70       	breq	80008e2e <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008de2:	03 a9       	ld.ub	r9,r1[0x2]
80008de4:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
80008de8:	12 38       	cp.w	r8,r9
80008dea:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
80008dee:	04 99       	mov	r9,r2
80008df0:	00 9a       	mov	r10,r0
80008df2:	06 9b       	mov	r11,r3
80008df4:	03 9c       	ld.ub	r12,r1[0x1]
80008df6:	f0 1f 00 31 	mcall	80008eb8 <f_write+0x1d0>
80008dfa:	c0 50       	breq	80008e04 <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
80008dfc:	30 18       	mov	r8,1
80008dfe:	ae f8       	st.b	r7[0x7],r8
80008e00:	30 12       	mov	r2,1
80008e02:	c5 18       	rjmp	80008ea4 <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
80008e04:	6e 6b       	ld.w	r11,r7[0x18]
80008e06:	f6 00 01 00 	sub	r0,r11,r0
80008e0a:	00 32       	cp.w	r2,r0
80008e0c:	e0 88 00 0e 	brls	80008e28 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008e10:	e0 0b 15 09 	lsl	r11,r0,0x9
80008e14:	e0 6a 02 00 	mov	r10,512
80008e18:	e6 0b 00 0b 	add	r11,r3,r11
80008e1c:	40 0c       	lddsp	r12,sp[0x0]
80008e1e:	f0 1f 00 29 	mcall	80008ec0 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
80008e22:	0f e8       	ld.ub	r8,r7[0x6]
80008e24:	a7 c8       	cbr	r8,0x6
80008e26:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
80008e28:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008e2c:	c2 78       	rjmp	80008e7a <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
80008e2e:	6e 68       	ld.w	r8,r7[0x18]
80008e30:	00 38       	cp.w	r8,r0
80008e32:	c1 00       	breq	80008e52 <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
80008e34:	6e 29       	ld.w	r9,r7[0x8]
80008e36:	6e 38       	ld.w	r8,r7[0xc]
80008e38:	10 39       	cp.w	r9,r8
80008e3a:	c0 c2       	brcc	80008e52 <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
80008e3c:	30 19       	mov	r9,1
80008e3e:	00 9a       	mov	r10,r0
80008e40:	40 1b       	lddsp	r11,sp[0x4]
80008e42:	03 9c       	ld.ub	r12,r1[0x1]
80008e44:	f0 1f 00 20 	mcall	80008ec4 <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008e48:	c0 50       	breq	80008e52 <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008e4a:	30 18       	mov	r8,1
80008e4c:	ae f8       	st.b	r7[0x7],r8
80008e4e:	30 12       	mov	r2,1
80008e50:	c2 a8       	rjmp	80008ea4 <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
80008e52:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
80008e54:	6e 2c       	ld.w	r12,r7[0x8]
80008e56:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008e5a:	e0 66 02 00 	mov	r6,512
80008e5e:	18 16       	sub	r6,r12
80008e60:	0c 35       	cp.w	r5,r6
80008e62:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
80008e66:	0c 9a       	mov	r10,r6
80008e68:	06 9b       	mov	r11,r3
80008e6a:	40 08       	lddsp	r8,sp[0x0]
80008e6c:	f0 0c 00 0c 	add	r12,r8,r12
80008e70:	f0 1f 00 14 	mcall	80008ec0 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
80008e74:	0f e8       	ld.ub	r8,r7[0x6]
80008e76:	a7 a8       	sbr	r8,0x6
80008e78:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008e7a:	6e 28       	ld.w	r8,r7[0x8]
80008e7c:	0c 08       	add	r8,r6
80008e7e:	8f 28       	st.w	r7[0x8],r8
80008e80:	68 08       	ld.w	r8,r4[0x0]
80008e82:	0c 08       	add	r8,r6
80008e84:	89 08       	st.w	r4[0x0],r8
80008e86:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008e88:	c0 50       	breq	80008e92 <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008e8a:	0c 03       	add	r3,r6
80008e8c:	c5 5b       	rjmp	80008d36 <f_write+0x4e>
80008e8e:	40 22       	lddsp	r2,sp[0x8]
80008e90:	c0 28       	rjmp	80008e94 <f_write+0x1ac>
80008e92:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
80008e94:	6e 28       	ld.w	r8,r7[0x8]
80008e96:	6e 39       	ld.w	r9,r7[0xc]
80008e98:	12 38       	cp.w	r8,r9
80008e9a:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
80008e9e:	0f e8       	ld.ub	r8,r7[0x6]
80008ea0:	a5 b8       	sbr	r8,0x5
80008ea2:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
80008ea4:	04 9c       	mov	r12,r2
80008ea6:	2f dd       	sub	sp,-12
80008ea8:	d8 32       	popm	r0-r7,pc
80008eaa:	00 00       	add	r0,r0
80008eac:	80 00       	ld.sh	r0,r0[0x0]
80008eae:	73 14       	ld.w	r4,r9[0x44]
80008eb0:	80 00       	ld.sh	r0,r0[0x0]
80008eb2:	7c 08       	ld.w	r8,lr[0x0]
80008eb4:	80 00       	ld.sh	r0,r0[0x0]
80008eb6:	6a 14       	ld.w	r4,r5[0x4]
80008eb8:	80 00       	ld.sh	r0,r0[0x0]
80008eba:	69 88       	ld.w	r8,r4[0x60]
80008ebc:	80 00       	ld.sh	r0,r0[0x0]
80008ebe:	69 fc       	ld.w	r12,r4[0x7c]
80008ec0:	80 00       	ld.sh	r0,r0[0x0]
80008ec2:	69 c0       	ld.w	r0,r4[0x70]
80008ec4:	80 00       	ld.sh	r0,r0[0x0]
80008ec6:	69 a4       	ld.w	r4,r4[0x68]

80008ec8 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
80008ec8:	d4 31       	pushm	r0-r7,lr
80008eca:	20 3d       	sub	sp,12
80008ecc:	18 97       	mov	r7,r12
80008ece:	16 93       	mov	r3,r11
80008ed0:	14 96       	mov	r6,r10
80008ed2:	12 94       	mov	r4,r9
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
80008ed4:	30 08       	mov	r8,0
80008ed6:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);							/* Check validity */
80008ed8:	f0 1f 00 5e 	mcall	80009050 <f_read+0x188>
80008edc:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008ede:	e0 81 00 b5 	brne	80009048 <f_read+0x180>
	if (fp->err)								/* Check error */
80008ee2:	0f f8       	ld.ub	r8,r7[0x7]
80008ee4:	58 08       	cp.w	r8,0
80008ee6:	c0 30       	breq	80008eec <f_read+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008ee8:	10 92       	mov	r2,r8
80008eea:	ca f8       	rjmp	80009048 <f_read+0x180>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
80008eec:	0f e8       	ld.ub	r8,r7[0x6]
80008eee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008ef2:	e0 80 00 a8 	breq	80009042 <f_read+0x17a>
80008ef6:	6e 35       	ld.w	r5,r7[0xc]
80008ef8:	6e 28       	ld.w	r8,r7[0x8]
80008efa:	10 15       	sub	r5,r8
80008efc:	0a 36       	cp.w	r6,r5
80008efe:	ec 05 17 80 	movls	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008f02:	58 05       	cp.w	r5,0
80008f04:	e0 80 00 a2 	breq	80009048 <f_read+0x180>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008f08:	ee c8 ff d8 	sub	r8,r7,-40
80008f0c:	50 08       	stdsp	sp[0x0],r8
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008f0e:	50 18       	stdsp	sp[0x4],r8
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008f10:	50 2c       	stdsp	sp[0x8],r12
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
80008f12:	6e 2b       	ld.w	r11,r7[0x8]
80008f14:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008f18:	c7 b1       	brne	8000900e <f_read+0x146>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008f1a:	6e 0c       	ld.w	r12,r7[0x0]
80008f1c:	19 a6       	ld.ub	r6,r12[0x2]
80008f1e:	20 16       	sub	r6,1
80008f20:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008f24:	5c 56       	castu.b	r6
			if (!csect) {						/* On the cluster boundary? */
80008f26:	c1 d1       	brne	80008f60 <f_read+0x98>
				if (fp->fptr == 0) {			/* On the top of the file? */
80008f28:	58 0b       	cp.w	r11,0
80008f2a:	c0 31       	brne	80008f30 <f_read+0x68>
					clst = fp->sclust;			/* Follow from the origin */
80008f2c:	6e 4c       	ld.w	r12,r7[0x10]
80008f2e:	c0 b8       	rjmp	80008f44 <f_read+0x7c>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008f30:	6e 98       	ld.w	r8,r7[0x24]
80008f32:	58 08       	cp.w	r8,0
80008f34:	c0 50       	breq	80008f3e <f_read+0x76>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
80008f36:	0e 9c       	mov	r12,r7
80008f38:	f0 1f 00 47 	mcall	80009054 <f_read+0x18c>
80008f3c:	c0 48       	rjmp	80008f44 <f_read+0x7c>
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
80008f3e:	6e 5b       	ld.w	r11,r7[0x14]
80008f40:	f0 1f 00 46 	mcall	80009058 <f_read+0x190>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
80008f44:	58 1c       	cp.w	r12,1
80008f46:	e0 8b 00 06 	brhi	80008f52 <f_read+0x8a>
80008f4a:	30 28       	mov	r8,2
80008f4c:	ae f8       	st.b	r7[0x7],r8
80008f4e:	30 22       	mov	r2,2
80008f50:	c7 c8       	rjmp	80009048 <f_read+0x180>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008f52:	5b fc       	cp.w	r12,-1
80008f54:	c0 51       	brne	80008f5e <f_read+0x96>
80008f56:	30 18       	mov	r8,1
80008f58:	ae f8       	st.b	r7[0x7],r8
80008f5a:	30 12       	mov	r2,1
80008f5c:	c7 68       	rjmp	80009048 <f_read+0x180>
				fp->clust = clst;				/* Update current cluster */
80008f5e:	8f 5c       	st.w	r7[0x14],r12
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
80008f60:	6e 01       	ld.w	r1,r7[0x0]
80008f62:	6e 5b       	ld.w	r11,r7[0x14]
80008f64:	02 9c       	mov	r12,r1
80008f66:	f0 1f 00 3e 	mcall	8000905c <f_read+0x194>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008f6a:	c0 51       	brne	80008f74 <f_read+0xac>
80008f6c:	30 28       	mov	r8,2
80008f6e:	ae f8       	st.b	r7[0x7],r8
80008f70:	30 22       	mov	r2,2
80008f72:	c6 b8       	rjmp	80009048 <f_read+0x180>
			sect += csect;
80008f74:	f8 06 00 00 	add	r0,r12,r6
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
80008f78:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {							/* Read maximum contiguous sectors directly */
80008f7c:	c2 80       	breq	80008fcc <f_read+0x104>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008f7e:	03 a9       	ld.ub	r9,r1[0x2]
80008f80:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
80008f84:	12 38       	cp.w	r8,r9
80008f86:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
80008f8a:	04 99       	mov	r9,r2
80008f8c:	00 9a       	mov	r10,r0
80008f8e:	06 9b       	mov	r11,r3
80008f90:	03 9c       	ld.ub	r12,r1[0x1]
80008f92:	f0 1f 00 34 	mcall	80009060 <f_read+0x198>
80008f96:	c0 50       	breq	80008fa0 <f_read+0xd8>
					ABORT(fp->fs, FR_DISK_ERR);
80008f98:	30 18       	mov	r8,1
80008f9a:	ae f8       	st.b	r7[0x7],r8
80008f9c:	30 12       	mov	r2,1
80008f9e:	c5 58       	rjmp	80009048 <f_read+0x180>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
80008fa0:	0f e8       	ld.ub	r8,r7[0x6]
80008fa2:	e2 18 00 40 	andl	r8,0x40,COH
80008fa6:	c1 00       	breq	80008fc6 <f_read+0xfe>
80008fa8:	6e 6c       	ld.w	r12,r7[0x18]
80008faa:	f8 00 01 00 	sub	r0,r12,r0
80008fae:	00 32       	cp.w	r2,r0
80008fb0:	e0 88 00 0b 	brls	80008fc6 <f_read+0xfe>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008fb4:	e0 0c 15 09 	lsl	r12,r0,0x9
80008fb8:	e0 6a 02 00 	mov	r10,512
80008fbc:	40 0b       	lddsp	r11,sp[0x0]
80008fbe:	e6 0c 00 0c 	add	r12,r3,r12
80008fc2:	f0 1f 00 29 	mcall	80009064 <f_read+0x19c>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
80008fc6:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008fca:	c3 28       	rjmp	8000902e <f_read+0x166>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
80008fcc:	6e 6a       	ld.w	r10,r7[0x18]
80008fce:	00 3a       	cp.w	r10,r0
80008fd0:	c1 e0       	breq	8000900c <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008fd2:	0f e8       	ld.ub	r8,r7[0x6]
80008fd4:	e2 18 00 40 	andl	r8,0x40,COH
80008fd8:	c0 e0       	breq	80008ff4 <f_read+0x12c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008fda:	30 19       	mov	r9,1
80008fdc:	40 1b       	lddsp	r11,sp[0x4]
80008fde:	03 9c       	ld.ub	r12,r1[0x1]
80008fe0:	f0 1f 00 22 	mcall	80009068 <f_read+0x1a0>
80008fe4:	c0 50       	breq	80008fee <f_read+0x126>
						ABORT(fp->fs, FR_DISK_ERR);
80008fe6:	30 18       	mov	r8,1
80008fe8:	ae f8       	st.b	r7[0x7],r8
80008fea:	30 12       	mov	r2,1
80008fec:	c2 e8       	rjmp	80009048 <f_read+0x180>
					fp->flag &= ~FA__DIRTY;
80008fee:	0f e8       	ld.ub	r8,r7[0x6]
80008ff0:	a7 c8       	cbr	r8,0x6
80008ff2:	ae e8       	st.b	r7[0x6],r8
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
80008ff4:	6e 08       	ld.w	r8,r7[0x0]
80008ff6:	30 19       	mov	r9,1
80008ff8:	00 9a       	mov	r10,r0
80008ffa:	40 1b       	lddsp	r11,sp[0x4]
80008ffc:	11 9c       	ld.ub	r12,r8[0x1]
80008ffe:	f0 1f 00 19 	mcall	80009060 <f_read+0x198>
80009002:	c0 50       	breq	8000900c <f_read+0x144>
					ABORT(fp->fs, FR_DISK_ERR);
80009004:	30 18       	mov	r8,1
80009006:	ae f8       	st.b	r7[0x7],r8
80009008:	30 12       	mov	r2,1
8000900a:	c1 f8       	rjmp	80009048 <f_read+0x180>
			}
#endif
			fp->dsect = sect;
8000900c:	8f 60       	st.w	r7[0x18],r0
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
8000900e:	6e 2b       	ld.w	r11,r7[0x8]
80009010:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80009014:	e0 66 02 00 	mov	r6,512
80009018:	16 16       	sub	r6,r11
8000901a:	0c 35       	cp.w	r5,r6
8000901c:	ea 06 17 80 	movls	r6,r5
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
80009020:	0c 9a       	mov	r10,r6
80009022:	40 08       	lddsp	r8,sp[0x0]
80009024:	f0 0b 00 0b 	add	r11,r8,r11
80009028:	06 9c       	mov	r12,r3
8000902a:	f0 1f 00 0f 	mcall	80009064 <f_read+0x19c>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
8000902e:	6e 28       	ld.w	r8,r7[0x8]
80009030:	0c 08       	add	r8,r6
80009032:	8f 28       	st.w	r7[0x8],r8
80009034:	68 08       	ld.w	r8,r4[0x0]
80009036:	0c 08       	add	r8,r6
80009038:	89 08       	st.w	r4[0x0],r8
8000903a:	0c 15       	sub	r5,r6
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
8000903c:	c0 50       	breq	80009046 <f_read+0x17e>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
8000903e:	0c 03       	add	r3,r6
80009040:	c6 9b       	rjmp	80008f12 <f_read+0x4a>
80009042:	30 72       	mov	r2,7
80009044:	c0 28       	rjmp	80009048 <f_read+0x180>
80009046:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
80009048:	04 9c       	mov	r12,r2
8000904a:	2f dd       	sub	sp,-12
8000904c:	d8 32       	popm	r0-r7,pc
8000904e:	00 00       	add	r0,r0
80009050:	80 00       	ld.sh	r0,r0[0x0]
80009052:	73 14       	ld.w	r4,r9[0x44]
80009054:	80 00       	ld.sh	r0,r0[0x0]
80009056:	6a 14       	ld.w	r4,r5[0x4]
80009058:	80 00       	ld.sh	r0,r0[0x0]
8000905a:	7a 70       	ld.w	r0,sp[0x1c]
8000905c:	80 00       	ld.sh	r0,r0[0x0]
8000905e:	69 fc       	ld.w	r12,r4[0x7c]
80009060:	80 00       	ld.sh	r0,r0[0x0]
80009062:	69 a4       	ld.w	r4,r4[0x68]
80009064:	80 00       	ld.sh	r0,r0[0x0]
80009066:	69 c0       	ld.w	r0,r4[0x70]
80009068:	80 00       	ld.sh	r0,r0[0x0]
8000906a:	69 88       	ld.w	r8,r4[0x60]

8000906c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
8000906c:	f8 c8 ff f8 	sub	r8,r12,-8
80009070:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80009072:	3f f9       	mov	r9,-1
80009074:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80009076:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80009078:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000907a:	30 08       	mov	r8,0
8000907c:	99 08       	st.w	r12[0x0],r8
}
8000907e:	5e fc       	retal	r12

80009080 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80009080:	30 08       	mov	r8,0
80009082:	99 48       	st.w	r12[0x10],r8
}
80009084:	5e fc       	retal	r12

80009086 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80009086:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80009088:	70 19       	ld.w	r9,r8[0x4]
8000908a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000908c:	78 19       	ld.w	r9,r12[0x4]
8000908e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80009090:	70 19       	ld.w	r9,r8[0x4]
80009092:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80009094:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80009096:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80009098:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000909a:	78 08       	ld.w	r8,r12[0x0]
8000909c:	2f f8       	sub	r8,-1
8000909e:	99 08       	st.w	r12[0x0],r8
}
800090a0:	5e fc       	retal	r12

800090a2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800090a2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800090a4:	5b fa       	cp.w	r10,-1
800090a6:	c0 31       	brne	800090ac <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800090a8:	78 48       	ld.w	r8,r12[0x10]
800090aa:	c0 c8       	rjmp	800090c2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800090ac:	f8 c8 ff f8 	sub	r8,r12,-8
800090b0:	70 19       	ld.w	r9,r8[0x4]
800090b2:	72 09       	ld.w	r9,r9[0x0]
800090b4:	12 3a       	cp.w	r10,r9
800090b6:	c0 63       	brcs	800090c2 <vListInsert+0x20>
800090b8:	70 18       	ld.w	r8,r8[0x4]
800090ba:	70 19       	ld.w	r9,r8[0x4]
800090bc:	72 09       	ld.w	r9,r9[0x0]
800090be:	12 3a       	cp.w	r10,r9
800090c0:	cf c2       	brcc	800090b8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800090c2:	70 19       	ld.w	r9,r8[0x4]
800090c4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800090c6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800090c8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800090ca:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800090cc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800090ce:	78 08       	ld.w	r8,r12[0x0]
800090d0:	2f f8       	sub	r8,-1
800090d2:	99 08       	st.w	r12[0x0],r8
}
800090d4:	5e fc       	retal	r12

800090d6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800090d6:	78 18       	ld.w	r8,r12[0x4]
800090d8:	78 29       	ld.w	r9,r12[0x8]
800090da:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800090dc:	78 28       	ld.w	r8,r12[0x8]
800090de:	78 19       	ld.w	r9,r12[0x4]
800090e0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800090e2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800090e4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800090e6:	18 39       	cp.w	r9,r12
800090e8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800090ec:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800090f0:	30 09       	mov	r9,0
800090f2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800090f4:	70 09       	ld.w	r9,r8[0x0]
800090f6:	20 19       	sub	r9,1
800090f8:	91 09       	st.w	r8[0x0],r9
}
800090fa:	5e fc       	retal	r12

800090fc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800090fc:	e0 68 08 08 	mov	r8,2056
80009100:	ea 18 08 08 	orh	r8,0x808
80009104:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80009106:	e0 68 09 09 	mov	r8,2313
8000910a:	ea 18 09 09 	orh	r8,0x909
8000910e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80009110:	e0 68 0a 0a 	mov	r8,2570
80009114:	ea 18 0a 0a 	orh	r8,0xa0a
80009118:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000911a:	e0 68 0b 0b 	mov	r8,2827
8000911e:	ea 18 0b 0b 	orh	r8,0xb0b
80009122:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80009124:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80009126:	e0 68 be ef 	mov	r8,48879
8000912a:	ea 18 de ad 	orh	r8,0xdead
8000912e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80009130:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80009132:	fc 18 00 40 	movh	r8,0x40
80009136:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80009138:	e0 68 00 ff 	mov	r8,255
8000913c:	ea 18 ff 00 	orh	r8,0xff00
80009140:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80009142:	e0 68 01 01 	mov	r8,257
80009146:	ea 18 01 01 	orh	r8,0x101
8000914a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000914c:	e0 68 02 02 	mov	r8,514
80009150:	ea 18 02 02 	orh	r8,0x202
80009154:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80009156:	e0 68 03 03 	mov	r8,771
8000915a:	ea 18 03 03 	orh	r8,0x303
8000915e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80009160:	e0 68 04 04 	mov	r8,1028
80009164:	ea 18 04 04 	orh	r8,0x404
80009168:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000916a:	e0 68 05 05 	mov	r8,1285
8000916e:	ea 18 05 05 	orh	r8,0x505
80009172:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80009174:	e0 68 06 06 	mov	r8,1542
80009178:	ea 18 06 06 	orh	r8,0x606
8000917c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000917e:	e0 68 07 07 	mov	r8,1799
80009182:	ea 18 07 07 	orh	r8,0x707
80009186:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80009188:	30 08       	mov	r8,0
8000918a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000918c:	5e fc       	retal	r12
8000918e:	d7 03       	nop

80009190 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80009190:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80009192:	48 38       	lddpc	r8,8000919c <vPortEnterCritical+0xc>
80009194:	70 09       	ld.w	r9,r8[0x0]
80009196:	2f f9       	sub	r9,-1
80009198:	91 09       	st.w	r8[0x0],r9
}
8000919a:	5e fc       	retal	r12
8000919c:	00 00       	add	r0,r0
8000919e:	05 30       	ld.ub	r0,r2++

800091a0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800091a0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800091a2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800091a4:	30 0a       	mov	r10,0
800091a6:	14 9b       	mov	r11,r10
800091a8:	49 2c       	lddpc	r12,800091f0 <xPortStartScheduler+0x50>
800091aa:	f0 1f 00 13 	mcall	800091f4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800091ae:	e0 68 5d c0 	mov	r8,24000
800091b2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800091b6:	30 08       	mov	r8,0
800091b8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800091bc:	e0 68 12 b8 	mov	r8,4792
800091c0:	ea 18 00 00 	orh	r8,0x0
800091c4:	70 00       	ld.w	r0,r8[0x0]
800091c6:	60 0d       	ld.w	sp,r0[0x0]
800091c8:	1b 00       	ld.w	r0,sp++
800091ca:	e0 68 05 30 	mov	r8,1328
800091ce:	ea 18 00 00 	orh	r8,0x0
800091d2:	91 00       	st.w	r8[0x0],r0
800091d4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800091d8:	2f ed       	sub	sp,-8
800091da:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800091de:	fa f0 ff e0 	ld.w	r0,sp[-32]
800091e2:	e3 b0 00 00 	mtsr	0x0,r0
800091e6:	fa f0 ff dc 	ld.w	r0,sp[-36]
800091ea:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800091ee:	d8 0a       	popm	pc,r12=0
800091f0:	80 00       	ld.sh	r0,r0[0x0]
800091f2:	92 bc       	ld.uh	r12,r9[0x6]
800091f4:	80 00       	ld.sh	r0,r0[0x0]
800091f6:	60 bc       	ld.w	r12,r0[0x2c]

800091f8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800091f8:	20 6d       	sub	sp,24
800091fa:	eb cd 00 ff 	pushm	r0-r7
800091fe:	fa c7 ff c0 	sub	r7,sp,-64
80009202:	ee f0 ff f8 	ld.w	r0,r7[-8]
80009206:	ef 40 ff e0 	st.w	r7[-32],r0
8000920a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000920e:	ef 40 ff e4 	st.w	r7[-28],r0
80009212:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80009216:	e0 68 05 30 	mov	r8,1328
8000921a:	ea 18 00 00 	orh	r8,0x0
8000921e:	70 00       	ld.w	r0,r8[0x0]
80009220:	1a d0       	st.w	--sp,r0
80009222:	f0 1f 00 1a 	mcall	80009288 <LABEL_RET_SCALL_263+0x14>
80009226:	e0 68 12 b8 	mov	r8,4792
8000922a:	ea 18 00 00 	orh	r8,0x0
8000922e:	70 00       	ld.w	r0,r8[0x0]
80009230:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80009232:	f0 1f 00 17 	mcall	8000928c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80009236:	e0 68 12 b8 	mov	r8,4792
8000923a:	ea 18 00 00 	orh	r8,0x0
8000923e:	70 00       	ld.w	r0,r8[0x0]
80009240:	60 0d       	ld.w	sp,r0[0x0]
80009242:	1b 00       	ld.w	r0,sp++
80009244:	e0 68 05 30 	mov	r8,1328
80009248:	ea 18 00 00 	orh	r8,0x0
8000924c:	91 00       	st.w	r8[0x0],r0
8000924e:	fa c7 ff d8 	sub	r7,sp,-40
80009252:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80009256:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000925a:	e0 61 05 30 	mov	r1,1328
8000925e:	ea 11 00 00 	orh	r1,0x0
80009262:	62 02       	ld.w	r2,r1[0x0]
80009264:	58 02       	cp.w	r2,0
80009266:	c0 70       	breq	80009274 <LABEL_RET_SCALL_263>
80009268:	e4 c2 00 01 	sub	r2,r2,1
8000926c:	83 02       	st.w	r1[0x0],r2
8000926e:	58 02       	cp.w	r2,0
80009270:	c0 21       	brne	80009274 <LABEL_RET_SCALL_263>
80009272:	b1 c0       	cbr	r0,0x10

80009274 <LABEL_RET_SCALL_263>:
80009274:	ef 40 ff f8 	st.w	r7[-8],r0
80009278:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000927c:	ef 40 ff fc 	st.w	r7[-4],r0
80009280:	e3 cd 00 ff 	ldm	sp++,r0-r7
80009284:	2f ad       	sub	sp,-24
80009286:	d6 13       	rets
80009288:	80 00       	ld.sh	r0,r0[0x0]
8000928a:	91 90       	st.w	r8[0x24],r0
8000928c:	80 00       	ld.sh	r0,r0[0x0]
8000928e:	99 2c       	st.w	r12[0x8],r12

80009290 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80009290:	e1 b8 00 43 	mfsr	r8,0x10c
80009294:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80009298:	5e fc       	retal	r12
8000929a:	d7 03       	nop

8000929c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000929c:	48 78       	lddpc	r8,800092b8 <vPortExitCritical+0x1c>
8000929e:	70 08       	ld.w	r8,r8[0x0]
800092a0:	58 08       	cp.w	r8,0
800092a2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800092a4:	48 58       	lddpc	r8,800092b8 <vPortExitCritical+0x1c>
800092a6:	70 09       	ld.w	r9,r8[0x0]
800092a8:	20 19       	sub	r9,1
800092aa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800092ac:	70 08       	ld.w	r8,r8[0x0]
800092ae:	58 08       	cp.w	r8,0
800092b0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800092b2:	d5 03       	csrf	0x10
800092b4:	5e fc       	retal	r12
800092b6:	00 00       	add	r0,r0
800092b8:	00 00       	add	r0,r0
800092ba:	05 30       	ld.ub	r0,r2++

800092bc <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800092bc:	eb cd 00 ff 	pushm	r0-r7
800092c0:	e0 68 05 30 	mov	r8,1328
800092c4:	ea 18 00 00 	orh	r8,0x0
800092c8:	70 00       	ld.w	r0,r8[0x0]
800092ca:	1a d0       	st.w	--sp,r0
800092cc:	7a 90       	ld.w	r0,sp[0x24]
800092ce:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800092d2:	58 10       	cp.w	r0,1
800092d4:	e0 8b 00 08 	brhi	800092e4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800092d8:	e0 68 12 b8 	mov	r8,4792
800092dc:	ea 18 00 00 	orh	r8,0x0
800092e0:	70 00       	ld.w	r0,r8[0x0]
800092e2:	81 0d       	st.w	r0[0x0],sp

800092e4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800092e4:	f0 1f 00 12 	mcall	8000932c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800092e8:	f0 1f 00 12 	mcall	80009330 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800092ec:	f0 1f 00 12 	mcall	80009334 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800092f0:	f0 1f 00 12 	mcall	80009338 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800092f4:	7a 90       	ld.w	r0,sp[0x24]
800092f6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800092fa:	58 10       	cp.w	r0,1
800092fc:	e0 8b 00 0e 	brhi	80009318 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80009300:	f0 1f 00 0c 	mcall	80009330 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80009304:	f0 1f 00 0e 	mcall	8000933c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80009308:	f0 1f 00 0c 	mcall	80009338 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000930c:	e0 68 12 b8 	mov	r8,4792
80009310:	ea 18 00 00 	orh	r8,0x0
80009314:	70 00       	ld.w	r0,r8[0x0]
80009316:	60 0d       	ld.w	sp,r0[0x0]

80009318 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80009318:	1b 00       	ld.w	r0,sp++
8000931a:	e0 68 05 30 	mov	r8,1328
8000931e:	ea 18 00 00 	orh	r8,0x0
80009322:	91 00       	st.w	r8[0x0],r0
80009324:	e3 cd 00 ff 	ldm	sp++,r0-r7
80009328:	d6 03       	rete
8000932a:	00 00       	add	r0,r0
8000932c:	80 00       	ld.sh	r0,r0[0x0]
8000932e:	92 90       	ld.uh	r0,r9[0x2]
80009330:	80 00       	ld.sh	r0,r0[0x0]
80009332:	91 90       	st.w	r8[0x24],r0
80009334:	80 00       	ld.sh	r0,r0[0x0]
80009336:	9b 30       	st.w	sp[0xc],r0
80009338:	80 00       	ld.sh	r0,r0[0x0]
8000933a:	92 9c       	ld.uh	r12,r9[0x2]
8000933c:	80 00       	ld.sh	r0,r0[0x0]
8000933e:	99 2c       	st.w	r12[0x8],r12

80009340 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80009340:	d4 01       	pushm	lr
	vTaskSuspendAll();
80009342:	f0 1f 00 02 	mcall	80009348 <__malloc_lock+0x8>
}
80009346:	d8 02       	popm	pc
80009348:	80 00       	ld.sh	r0,r0[0x0]
8000934a:	99 1c       	st.w	r12[0x4],r12

8000934c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000934c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000934e:	f0 1f 00 02 	mcall	80009354 <__malloc_unlock+0x8>
}
80009352:	d8 02       	popm	pc
80009354:	80 00       	ld.sh	r0,r0[0x0]
80009356:	9c d8       	ld.uh	r8,lr[0xa]

80009358 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80009358:	d4 21       	pushm	r4-r7,lr
8000935a:	16 95       	mov	r5,r11
8000935c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000935e:	58 0c       	cp.w	r12,0
80009360:	c0 30       	breq	80009366 <_read+0xe>
80009362:	3f f7       	mov	r7,-1
80009364:	c1 48       	rjmp	8000938c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80009366:	58 0a       	cp.w	r10,0
80009368:	e0 89 00 04 	brgt	80009370 <_read+0x18>
8000936c:	30 07       	mov	r7,0
8000936e:	c0 f8       	rjmp	8000938c <_read+0x34>
80009370:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80009372:	48 84       	lddpc	r4,80009390 <_read+0x38>
80009374:	68 0c       	ld.w	r12,r4[0x0]
80009376:	f0 1f 00 08 	mcall	80009394 <_read+0x3c>
    if (c < 0)
8000937a:	c0 95       	brlt	8000938c <_read+0x34>
      break;

    *ptr++ = c;
8000937c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80009380:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80009382:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80009386:	58 08       	cp.w	r8,0
80009388:	fe 99 ff f6 	brgt	80009374 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000938c:	0e 9c       	mov	r12,r7
8000938e:	d8 22       	popm	r4-r7,pc
80009390:	00 00       	add	r0,r0
80009392:	46 c0       	lddsp	r0,sp[0x1b0]
80009394:	80 00       	ld.sh	r0,r0[0x0]
80009396:	67 b0       	ld.w	r0,r3[0x6c]

80009398 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80009398:	d4 21       	pushm	r4-r7,lr
8000939a:	16 95       	mov	r5,r11
8000939c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000939e:	20 1c       	sub	r12,1
800093a0:	58 2c       	cp.w	r12,2
800093a2:	e0 8b 00 12 	brhi	800093c6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800093a6:	58 0a       	cp.w	r10,0
800093a8:	c0 31       	brne	800093ae <_write+0x16>
800093aa:	30 07       	mov	r7,0
800093ac:	c0 e8       	rjmp	800093c8 <_write+0x30>
800093ae:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800093b0:	48 74       	lddpc	r4,800093cc <_write+0x34>
800093b2:	68 0c       	ld.w	r12,r4[0x0]
800093b4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800093b8:	f0 1f 00 06 	mcall	800093d0 <_write+0x38>
800093bc:	c0 55       	brlt	800093c6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800093be:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800093c0:	0e 36       	cp.w	r6,r7
800093c2:	cf 81       	brne	800093b2 <_write+0x1a>
800093c4:	c0 28       	rjmp	800093c8 <_write+0x30>
800093c6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800093c8:	0e 9c       	mov	r12,r7
800093ca:	d8 22       	popm	r4-r7,pc
800093cc:	00 00       	add	r0,r0
800093ce:	46 c0       	lddsp	r0,sp[0x1b0]
800093d0:	80 00       	ld.sh	r0,r0[0x0]
800093d2:	67 60       	ld.w	r0,r3[0x58]

800093d4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800093d4:	eb cd 40 80 	pushm	r7,lr
800093d8:	18 97       	mov	r7,r12
	if( pv )
800093da:	58 0c       	cp.w	r12,0
800093dc:	c0 80       	breq	800093ec <vPortFree+0x18>
	{
		vTaskSuspendAll();
800093de:	f0 1f 00 05 	mcall	800093f0 <vPortFree+0x1c>
		{
			free( pv );
800093e2:	0e 9c       	mov	r12,r7
800093e4:	f0 1f 00 04 	mcall	800093f4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800093e8:	f0 1f 00 04 	mcall	800093f8 <vPortFree+0x24>
800093ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800093f0:	80 00       	ld.sh	r0,r0[0x0]
800093f2:	99 1c       	st.w	r12[0x4],r12
800093f4:	80 00       	ld.sh	r0,r0[0x0]
800093f6:	a8 88       	st.b	r4[0x0],r8
800093f8:	80 00       	ld.sh	r0,r0[0x0]
800093fa:	9c d8       	ld.uh	r8,lr[0xa]

800093fc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800093fc:	eb cd 40 80 	pushm	r7,lr
80009400:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80009402:	f0 1f 00 06 	mcall	80009418 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80009406:	0e 9c       	mov	r12,r7
80009408:	f0 1f 00 05 	mcall	8000941c <pvPortMalloc+0x20>
8000940c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000940e:	f0 1f 00 05 	mcall	80009420 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80009412:	0e 9c       	mov	r12,r7
80009414:	e3 cd 80 80 	ldm	sp++,r7,pc
80009418:	80 00       	ld.sh	r0,r0[0x0]
8000941a:	99 1c       	st.w	r12[0x4],r12
8000941c:	80 00       	ld.sh	r0,r0[0x0]
8000941e:	a8 98       	st.b	r4[0x1],r8
80009420:	80 00       	ld.sh	r0,r0[0x0]
80009422:	9c d8       	ld.uh	r8,lr[0xa]

80009424 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80009424:	d4 01       	pushm	lr
80009426:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80009428:	78 09       	ld.w	r9,r12[0x0]
8000942a:	58 09       	cp.w	r9,0
8000942c:	c1 10       	breq	8000944e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000942e:	78 3a       	ld.w	r10,r12[0xc]
80009430:	79 09       	ld.w	r9,r12[0x40]
80009432:	f4 09 00 09 	add	r9,r10,r9
80009436:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80009438:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000943a:	14 39       	cp.w	r9,r10
8000943c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80009440:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80009444:	79 0a       	ld.w	r10,r12[0x40]
80009446:	78 3b       	ld.w	r11,r12[0xc]
80009448:	10 9c       	mov	r12,r8
8000944a:	f0 1f 00 02 	mcall	80009450 <prvCopyDataFromQueue+0x2c>
8000944e:	d8 02       	popm	pc
80009450:	80 00       	ld.sh	r0,r0[0x0]
80009452:	ad 06       	ld.d	r6,r6

80009454 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80009454:	eb cd 40 c0 	pushm	r6-r7,lr
80009458:	18 97       	mov	r7,r12
8000945a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000945c:	78 e8       	ld.w	r8,r12[0x38]
8000945e:	58 08       	cp.w	r8,0
80009460:	c0 31       	brne	80009466 <xQueueReceiveFromISR+0x12>
80009462:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80009466:	f0 1f 00 0e 	mcall	8000949c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000946a:	6e e8       	ld.w	r8,r7[0x38]
8000946c:	20 18       	sub	r8,1
8000946e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80009470:	6f 18       	ld.w	r8,r7[0x44]
80009472:	5b f8       	cp.w	r8,-1
80009474:	c0 d1       	brne	8000948e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009476:	6e 48       	ld.w	r8,r7[0x10]
80009478:	58 08       	cp.w	r8,0
8000947a:	c0 f0       	breq	80009498 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000947c:	ee cc ff f0 	sub	r12,r7,-16
80009480:	f0 1f 00 08 	mcall	800094a0 <xQueueReceiveFromISR+0x4c>
80009484:	c0 a0       	breq	80009498 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80009486:	30 1c       	mov	r12,1
80009488:	8d 0c       	st.w	r6[0x0],r12
8000948a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000948e:	2f f8       	sub	r8,-1
80009490:	ef 48 00 44 	st.w	r7[68],r8
80009494:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009498:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000949c:	80 00       	ld.sh	r0,r0[0x0]
8000949e:	94 24       	ld.sh	r4,r10[0x4]
800094a0:	80 00       	ld.sh	r0,r0[0x0]
800094a2:	9a b4       	ld.uh	r4,sp[0x6]

800094a4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800094a4:	eb cd 40 c0 	pushm	r6-r7,lr
800094a8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800094aa:	f0 1f 00 23 	mcall	80009534 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800094ae:	6f 28       	ld.w	r8,r7[0x48]
800094b0:	58 08       	cp.w	r8,0
800094b2:	e0 8a 00 18 	brle	800094e2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800094b6:	6e 98       	ld.w	r8,r7[0x24]
800094b8:	58 08       	cp.w	r8,0
800094ba:	c1 40       	breq	800094e2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800094bc:	ee c6 ff dc 	sub	r6,r7,-36
800094c0:	c0 48       	rjmp	800094c8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800094c2:	6e 98       	ld.w	r8,r7[0x24]
800094c4:	58 08       	cp.w	r8,0
800094c6:	c0 e0       	breq	800094e2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800094c8:	0c 9c       	mov	r12,r6
800094ca:	f0 1f 00 1c 	mcall	80009538 <prvUnlockQueue+0x94>
800094ce:	c0 30       	breq	800094d4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800094d0:	f0 1f 00 1b 	mcall	8000953c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800094d4:	6f 28       	ld.w	r8,r7[0x48]
800094d6:	20 18       	sub	r8,1
800094d8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800094dc:	58 08       	cp.w	r8,0
800094de:	fe 99 ff f2 	brgt	800094c2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800094e2:	3f f8       	mov	r8,-1
800094e4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800094e8:	f0 1f 00 16 	mcall	80009540 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800094ec:	f0 1f 00 12 	mcall	80009534 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800094f0:	6f 18       	ld.w	r8,r7[0x44]
800094f2:	58 08       	cp.w	r8,0
800094f4:	e0 8a 00 18 	brle	80009524 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800094f8:	6e 48       	ld.w	r8,r7[0x10]
800094fa:	58 08       	cp.w	r8,0
800094fc:	c1 40       	breq	80009524 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800094fe:	ee c6 ff f0 	sub	r6,r7,-16
80009502:	c0 48       	rjmp	8000950a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009504:	6e 48       	ld.w	r8,r7[0x10]
80009506:	58 08       	cp.w	r8,0
80009508:	c0 e0       	breq	80009524 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000950a:	0c 9c       	mov	r12,r6
8000950c:	f0 1f 00 0b 	mcall	80009538 <prvUnlockQueue+0x94>
80009510:	c0 30       	breq	80009516 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80009512:	f0 1f 00 0b 	mcall	8000953c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80009516:	6f 18       	ld.w	r8,r7[0x44]
80009518:	20 18       	sub	r8,1
8000951a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000951e:	58 08       	cp.w	r8,0
80009520:	fe 99 ff f2 	brgt	80009504 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80009524:	3f f8       	mov	r8,-1
80009526:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000952a:	f0 1f 00 06 	mcall	80009540 <prvUnlockQueue+0x9c>
}
8000952e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009532:	00 00       	add	r0,r0
80009534:	80 00       	ld.sh	r0,r0[0x0]
80009536:	91 90       	st.w	r8[0x24],r0
80009538:	80 00       	ld.sh	r0,r0[0x0]
8000953a:	9a b4       	ld.uh	r4,sp[0x6]
8000953c:	80 00       	ld.sh	r0,r0[0x0]
8000953e:	99 c0       	st.w	r12[0x30],r0
80009540:	80 00       	ld.sh	r0,r0[0x0]
80009542:	92 9c       	ld.uh	r12,r9[0x2]

80009544 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80009544:	d4 31       	pushm	r0-r7,lr
80009546:	20 5d       	sub	sp,20
80009548:	18 97       	mov	r7,r12
8000954a:	50 0b       	stdsp	sp[0x0],r11
8000954c:	50 2a       	stdsp	sp[0x8],r10
8000954e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80009550:	f8 c2 ff dc 	sub	r2,r12,-36
80009554:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80009556:	fa c4 ff f4 	sub	r4,sp,-12
8000955a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000955c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000955e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80009562:	f0 1f 00 3e 	mcall	80009658 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80009566:	6e e8       	ld.w	r8,r7[0x38]
80009568:	58 08       	cp.w	r8,0
8000956a:	c2 a0       	breq	800095be <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000956c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000956e:	40 0b       	lddsp	r11,sp[0x0]
80009570:	0e 9c       	mov	r12,r7
80009572:	f0 1f 00 3b 	mcall	8000965c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80009576:	40 18       	lddsp	r8,sp[0x4]
80009578:	58 08       	cp.w	r8,0
8000957a:	c1 51       	brne	800095a4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000957c:	6e e8       	ld.w	r8,r7[0x38]
8000957e:	20 18       	sub	r8,1
80009580:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80009582:	6e 08       	ld.w	r8,r7[0x0]
80009584:	58 08       	cp.w	r8,0
80009586:	c0 41       	brne	8000958e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80009588:	f0 1f 00 36 	mcall	80009660 <xQueueGenericReceive+0x11c>
8000958c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000958e:	6e 48       	ld.w	r8,r7[0x10]
80009590:	58 08       	cp.w	r8,0
80009592:	c1 20       	breq	800095b6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80009594:	ee cc ff f0 	sub	r12,r7,-16
80009598:	f0 1f 00 33 	mcall	80009664 <xQueueGenericReceive+0x120>
8000959c:	58 1c       	cp.w	r12,1
8000959e:	c0 c1       	brne	800095b6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800095a0:	d7 33       	scall
800095a2:	c0 a8       	rjmp	800095b6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800095a4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800095a6:	6e 98       	ld.w	r8,r7[0x24]
800095a8:	58 08       	cp.w	r8,0
800095aa:	c0 60       	breq	800095b6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800095ac:	04 9c       	mov	r12,r2
800095ae:	f0 1f 00 2e 	mcall	80009664 <xQueueGenericReceive+0x120>
800095b2:	c0 20       	breq	800095b6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800095b4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800095b6:	f0 1f 00 2d 	mcall	80009668 <xQueueGenericReceive+0x124>
800095ba:	30 1c       	mov	r12,1
				return pdPASS;
800095bc:	c4 c8       	rjmp	80009654 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800095be:	40 28       	lddsp	r8,sp[0x8]
800095c0:	58 08       	cp.w	r8,0
800095c2:	c0 51       	brne	800095cc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800095c4:	f0 1f 00 29 	mcall	80009668 <xQueueGenericReceive+0x124>
800095c8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800095ca:	c4 58       	rjmp	80009654 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800095cc:	58 05       	cp.w	r5,0
800095ce:	c0 51       	brne	800095d8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800095d0:	08 9c       	mov	r12,r4
800095d2:	f0 1f 00 27 	mcall	8000966c <xQueueGenericReceive+0x128>
800095d6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800095d8:	f0 1f 00 24 	mcall	80009668 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800095dc:	f0 1f 00 25 	mcall	80009670 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800095e0:	f0 1f 00 1e 	mcall	80009658 <xQueueGenericReceive+0x114>
800095e4:	6f 18       	ld.w	r8,r7[0x44]
800095e6:	5b f8       	cp.w	r8,-1
800095e8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800095ec:	6f 28       	ld.w	r8,r7[0x48]
800095ee:	5b f8       	cp.w	r8,-1
800095f0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800095f4:	f0 1f 00 1d 	mcall	80009668 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800095f8:	06 9b       	mov	r11,r3
800095fa:	08 9c       	mov	r12,r4
800095fc:	f0 1f 00 1e 	mcall	80009674 <xQueueGenericReceive+0x130>
80009600:	c2 41       	brne	80009648 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80009602:	f0 1f 00 16 	mcall	80009658 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80009606:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80009608:	f0 1f 00 18 	mcall	80009668 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000960c:	58 06       	cp.w	r6,0
8000960e:	c1 71       	brne	8000963c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80009610:	6e 08       	ld.w	r8,r7[0x0]
80009612:	58 08       	cp.w	r8,0
80009614:	c0 81       	brne	80009624 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80009616:	f0 1f 00 11 	mcall	80009658 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000961a:	6e 1c       	ld.w	r12,r7[0x4]
8000961c:	f0 1f 00 17 	mcall	80009678 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80009620:	f0 1f 00 12 	mcall	80009668 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80009624:	40 2b       	lddsp	r11,sp[0x8]
80009626:	04 9c       	mov	r12,r2
80009628:	f0 1f 00 15 	mcall	8000967c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000962c:	0e 9c       	mov	r12,r7
8000962e:	f0 1f 00 15 	mcall	80009680 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80009632:	f0 1f 00 15 	mcall	80009684 <xQueueGenericReceive+0x140>
80009636:	c9 61       	brne	80009562 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80009638:	d7 33       	scall
8000963a:	c9 4b       	rjmp	80009562 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000963c:	0e 9c       	mov	r12,r7
8000963e:	f0 1f 00 11 	mcall	80009680 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80009642:	f0 1f 00 11 	mcall	80009684 <xQueueGenericReceive+0x140>
80009646:	c8 eb       	rjmp	80009562 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80009648:	0e 9c       	mov	r12,r7
8000964a:	f0 1f 00 0e 	mcall	80009680 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000964e:	f0 1f 00 0e 	mcall	80009684 <xQueueGenericReceive+0x140>
80009652:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80009654:	2f bd       	sub	sp,-20
80009656:	d8 32       	popm	r0-r7,pc
80009658:	80 00       	ld.sh	r0,r0[0x0]
8000965a:	91 90       	st.w	r8[0x24],r0
8000965c:	80 00       	ld.sh	r0,r0[0x0]
8000965e:	94 24       	ld.sh	r4,r10[0x4]
80009660:	80 00       	ld.sh	r0,r0[0x0]
80009662:	99 cc       	st.w	r12[0x30],r12
80009664:	80 00       	ld.sh	r0,r0[0x0]
80009666:	9a b4       	ld.uh	r4,sp[0x6]
80009668:	80 00       	ld.sh	r0,r0[0x0]
8000966a:	92 9c       	ld.uh	r12,r9[0x2]
8000966c:	80 00       	ld.sh	r0,r0[0x0]
8000966e:	99 a8       	st.w	r12[0x28],r8
80009670:	80 00       	ld.sh	r0,r0[0x0]
80009672:	99 1c       	st.w	r12[0x4],r12
80009674:	80 00       	ld.sh	r0,r0[0x0]
80009676:	9c 44       	ld.sh	r4,lr[0x8]
80009678:	80 00       	ld.sh	r0,r0[0x0]
8000967a:	9a 30       	ld.sh	r0,sp[0x6]
8000967c:	80 00       	ld.sh	r0,r0[0x0]
8000967e:	9e 9c       	ld.uh	r12,pc[0x2]
80009680:	80 00       	ld.sh	r0,r0[0x0]
80009682:	94 a4       	ld.uh	r4,r10[0x4]
80009684:	80 00       	ld.sh	r0,r0[0x0]
80009686:	9c d8       	ld.uh	r8,lr[0xa]

80009688 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80009688:	eb cd 40 80 	pushm	r7,lr
8000968c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000968e:	79 08       	ld.w	r8,r12[0x40]
80009690:	58 08       	cp.w	r8,0
80009692:	c0 a1       	brne	800096a6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80009694:	78 08       	ld.w	r8,r12[0x0]
80009696:	58 08       	cp.w	r8,0
80009698:	c2 b1       	brne	800096ee <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000969a:	78 1c       	ld.w	r12,r12[0x4]
8000969c:	f0 1f 00 17 	mcall	800096f8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800096a0:	30 08       	mov	r8,0
800096a2:	8f 18       	st.w	r7[0x4],r8
800096a4:	c2 58       	rjmp	800096ee <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800096a6:	58 0a       	cp.w	r10,0
800096a8:	c1 01       	brne	800096c8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800096aa:	10 9a       	mov	r10,r8
800096ac:	78 2c       	ld.w	r12,r12[0x8]
800096ae:	f0 1f 00 14 	mcall	800096fc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800096b2:	6e 29       	ld.w	r9,r7[0x8]
800096b4:	6f 08       	ld.w	r8,r7[0x40]
800096b6:	f2 08 00 08 	add	r8,r9,r8
800096ba:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800096bc:	6e 19       	ld.w	r9,r7[0x4]
800096be:	12 38       	cp.w	r8,r9
800096c0:	c1 73       	brcs	800096ee <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800096c2:	6e 08       	ld.w	r8,r7[0x0]
800096c4:	8f 28       	st.w	r7[0x8],r8
800096c6:	c1 48       	rjmp	800096ee <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800096c8:	10 9a       	mov	r10,r8
800096ca:	78 3c       	ld.w	r12,r12[0xc]
800096cc:	f0 1f 00 0c 	mcall	800096fc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800096d0:	6f 08       	ld.w	r8,r7[0x40]
800096d2:	6e 39       	ld.w	r9,r7[0xc]
800096d4:	f2 08 01 08 	sub	r8,r9,r8
800096d8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800096da:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800096dc:	12 38       	cp.w	r8,r9
800096de:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800096e2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800096e6:	f3 d8 e3 19 	subcs	r9,r9,r8
800096ea:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800096ee:	6e e8       	ld.w	r8,r7[0x38]
800096f0:	2f f8       	sub	r8,-1
800096f2:	8f e8       	st.w	r7[0x38],r8
}
800096f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800096f8:	80 00       	ld.sh	r0,r0[0x0]
800096fa:	99 d8       	st.w	r12[0x34],r8
800096fc:	80 00       	ld.sh	r0,r0[0x0]
800096fe:	ad 06       	ld.d	r6,r6

80009700 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80009700:	eb cd 40 c0 	pushm	r6-r7,lr
80009704:	18 97       	mov	r7,r12
80009706:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80009708:	78 ec       	ld.w	r12,r12[0x38]
8000970a:	6e f8       	ld.w	r8,r7[0x3c]
8000970c:	10 3c       	cp.w	r12,r8
8000970e:	c0 33       	brcs	80009714 <xQueueGenericSendFromISR+0x14>
80009710:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80009714:	12 9a       	mov	r10,r9
80009716:	0e 9c       	mov	r12,r7
80009718:	f0 1f 00 0c 	mcall	80009748 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000971c:	6f 28       	ld.w	r8,r7[0x48]
8000971e:	5b f8       	cp.w	r8,-1
80009720:	c0 d1       	brne	8000973a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009722:	6e 98       	ld.w	r8,r7[0x24]
80009724:	58 08       	cp.w	r8,0
80009726:	c0 f0       	breq	80009744 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009728:	ee cc ff dc 	sub	r12,r7,-36
8000972c:	f0 1f 00 08 	mcall	8000974c <xQueueGenericSendFromISR+0x4c>
80009730:	c0 a0       	breq	80009744 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80009732:	30 1c       	mov	r12,1
80009734:	8d 0c       	st.w	r6[0x0],r12
80009736:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000973a:	2f f8       	sub	r8,-1
8000973c:	ef 48 00 48 	st.w	r7[72],r8
80009740:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009744:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009748:	80 00       	ld.sh	r0,r0[0x0]
8000974a:	96 88       	ld.uh	r8,r11[0x0]
8000974c:	80 00       	ld.sh	r0,r0[0x0]
8000974e:	9a b4       	ld.uh	r4,sp[0x6]

80009750 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80009750:	d4 31       	pushm	r0-r7,lr
80009752:	20 5d       	sub	sp,20
80009754:	18 97       	mov	r7,r12
80009756:	50 0b       	stdsp	sp[0x0],r11
80009758:	50 2a       	stdsp	sp[0x8],r10
8000975a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000975c:	f8 c0 ff f0 	sub	r0,r12,-16
80009760:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80009762:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80009766:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009768:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000976c:	f0 1f 00 2f 	mcall	80009828 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80009770:	6e e9       	ld.w	r9,r7[0x38]
80009772:	6e f8       	ld.w	r8,r7[0x3c]
80009774:	10 39       	cp.w	r9,r8
80009776:	c1 42       	brcc	8000979e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80009778:	40 1a       	lddsp	r10,sp[0x4]
8000977a:	40 0b       	lddsp	r11,sp[0x0]
8000977c:	0e 9c       	mov	r12,r7
8000977e:	f0 1f 00 2c 	mcall	8000982c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009782:	6e 98       	ld.w	r8,r7[0x24]
80009784:	58 08       	cp.w	r8,0
80009786:	c0 80       	breq	80009796 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80009788:	ee cc ff dc 	sub	r12,r7,-36
8000978c:	f0 1f 00 29 	mcall	80009830 <xQueueGenericSend+0xe0>
80009790:	58 1c       	cp.w	r12,1
80009792:	c0 21       	brne	80009796 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80009794:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80009796:	f0 1f 00 28 	mcall	80009834 <xQueueGenericSend+0xe4>
8000979a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000979c:	c4 38       	rjmp	80009822 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000979e:	40 28       	lddsp	r8,sp[0x8]
800097a0:	58 08       	cp.w	r8,0
800097a2:	c0 51       	brne	800097ac <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800097a4:	f0 1f 00 24 	mcall	80009834 <xQueueGenericSend+0xe4>
800097a8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800097aa:	c3 c8       	rjmp	80009822 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800097ac:	58 04       	cp.w	r4,0
800097ae:	c0 51       	brne	800097b8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800097b0:	06 9c       	mov	r12,r3
800097b2:	f0 1f 00 22 	mcall	80009838 <xQueueGenericSend+0xe8>
800097b6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800097b8:	f0 1f 00 1f 	mcall	80009834 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800097bc:	f0 1f 00 20 	mcall	8000983c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800097c0:	f0 1f 00 1a 	mcall	80009828 <xQueueGenericSend+0xd8>
800097c4:	6f 18       	ld.w	r8,r7[0x44]
800097c6:	5b f8       	cp.w	r8,-1
800097c8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800097cc:	6f 28       	ld.w	r8,r7[0x48]
800097ce:	5b f8       	cp.w	r8,-1
800097d0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800097d4:	f0 1f 00 18 	mcall	80009834 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800097d8:	04 9b       	mov	r11,r2
800097da:	06 9c       	mov	r12,r3
800097dc:	f0 1f 00 19 	mcall	80009840 <xQueueGenericSend+0xf0>
800097e0:	c1 b1       	brne	80009816 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800097e2:	f0 1f 00 12 	mcall	80009828 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800097e6:	6e e5       	ld.w	r5,r7[0x38]
800097e8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800097ea:	f0 1f 00 13 	mcall	80009834 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800097ee:	0c 35       	cp.w	r5,r6
800097f0:	c0 d1       	brne	8000980a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800097f2:	40 2b       	lddsp	r11,sp[0x8]
800097f4:	00 9c       	mov	r12,r0
800097f6:	f0 1f 00 14 	mcall	80009844 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800097fa:	0e 9c       	mov	r12,r7
800097fc:	f0 1f 00 13 	mcall	80009848 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80009800:	f0 1f 00 13 	mcall	8000984c <xQueueGenericSend+0xfc>
80009804:	cb 41       	brne	8000976c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80009806:	d7 33       	scall
80009808:	cb 2b       	rjmp	8000976c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000980a:	0e 9c       	mov	r12,r7
8000980c:	f0 1f 00 0f 	mcall	80009848 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80009810:	f0 1f 00 0f 	mcall	8000984c <xQueueGenericSend+0xfc>
80009814:	ca cb       	rjmp	8000976c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80009816:	0e 9c       	mov	r12,r7
80009818:	f0 1f 00 0c 	mcall	80009848 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000981c:	f0 1f 00 0c 	mcall	8000984c <xQueueGenericSend+0xfc>
80009820:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80009822:	2f bd       	sub	sp,-20
80009824:	d8 32       	popm	r0-r7,pc
80009826:	00 00       	add	r0,r0
80009828:	80 00       	ld.sh	r0,r0[0x0]
8000982a:	91 90       	st.w	r8[0x24],r0
8000982c:	80 00       	ld.sh	r0,r0[0x0]
8000982e:	96 88       	ld.uh	r8,r11[0x0]
80009830:	80 00       	ld.sh	r0,r0[0x0]
80009832:	9a b4       	ld.uh	r4,sp[0x6]
80009834:	80 00       	ld.sh	r0,r0[0x0]
80009836:	92 9c       	ld.uh	r12,r9[0x2]
80009838:	80 00       	ld.sh	r0,r0[0x0]
8000983a:	99 a8       	st.w	r12[0x28],r8
8000983c:	80 00       	ld.sh	r0,r0[0x0]
8000983e:	99 1c       	st.w	r12[0x4],r12
80009840:	80 00       	ld.sh	r0,r0[0x0]
80009842:	9c 44       	ld.sh	r4,lr[0x8]
80009844:	80 00       	ld.sh	r0,r0[0x0]
80009846:	9e 9c       	ld.uh	r12,pc[0x2]
80009848:	80 00       	ld.sh	r0,r0[0x0]
8000984a:	94 a4       	ld.uh	r4,r10[0x4]
8000984c:	80 00       	ld.sh	r0,r0[0x0]
8000984e:	9c d8       	ld.uh	r8,lr[0xa]

80009850 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80009850:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80009854:	34 cc       	mov	r12,76
80009856:	f0 1f 00 12 	mcall	8000989c <xQueueCreateMutex+0x4c>
8000985a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000985c:	c1 d0       	breq	80009896 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000985e:	30 06       	mov	r6,0
80009860:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80009862:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80009864:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80009866:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80009868:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000986a:	30 18       	mov	r8,1
8000986c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000986e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80009872:	3f f8       	mov	r8,-1
80009874:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80009878:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000987c:	2f 0c       	sub	r12,-16
8000987e:	f0 1f 00 09 	mcall	800098a0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80009882:	ee cc ff dc 	sub	r12,r7,-36
80009886:	f0 1f 00 07 	mcall	800098a0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000988a:	0c 99       	mov	r9,r6
8000988c:	0c 9a       	mov	r10,r6
8000988e:	0c 9b       	mov	r11,r6
80009890:	0e 9c       	mov	r12,r7
80009892:	f0 1f 00 05 	mcall	800098a4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80009896:	0e 9c       	mov	r12,r7
80009898:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000989c:	80 00       	ld.sh	r0,r0[0x0]
8000989e:	93 fc       	st.w	r9[0x3c],r12
800098a0:	80 00       	ld.sh	r0,r0[0x0]
800098a2:	90 6c       	ld.sh	r12,r8[0xc]
800098a4:	80 00       	ld.sh	r0,r0[0x0]
800098a6:	97 50       	st.w	r11[0x14],r0

800098a8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800098a8:	d4 21       	pushm	r4-r7,lr
800098aa:	18 97       	mov	r7,r12
800098ac:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800098ae:	58 0c       	cp.w	r12,0
800098b0:	c2 f0       	breq	8000990e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800098b2:	34 cc       	mov	r12,76
800098b4:	f0 1f 00 17 	mcall	80009910 <xQueueCreate+0x68>
800098b8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800098ba:	c2 a0       	breq	8000990e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800098bc:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800098c0:	e8 cc ff ff 	sub	r12,r4,-1
800098c4:	f0 1f 00 13 	mcall	80009910 <xQueueCreate+0x68>
800098c8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800098ca:	c1 e0       	breq	80009906 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800098cc:	f8 04 00 04 	add	r4,r12,r4
800098d0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800098d2:	30 08       	mov	r8,0
800098d4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800098d6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800098d8:	ee c8 00 01 	sub	r8,r7,1
800098dc:	ad 38       	mul	r8,r6
800098de:	10 0c       	add	r12,r8
800098e0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800098e2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800098e4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800098e8:	3f f8       	mov	r8,-1
800098ea:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800098ee:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800098f2:	ea cc ff f0 	sub	r12,r5,-16
800098f6:	f0 1f 00 08 	mcall	80009914 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800098fa:	ea cc ff dc 	sub	r12,r5,-36
800098fe:	f0 1f 00 06 	mcall	80009914 <xQueueCreate+0x6c>
80009902:	0a 9c       	mov	r12,r5
80009904:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80009906:	0a 9c       	mov	r12,r5
80009908:	f0 1f 00 04 	mcall	80009918 <xQueueCreate+0x70>
8000990c:	d8 2a       	popm	r4-r7,pc,r12=0
8000990e:	d8 2a       	popm	r4-r7,pc,r12=0
80009910:	80 00       	ld.sh	r0,r0[0x0]
80009912:	93 fc       	st.w	r9[0x3c],r12
80009914:	80 00       	ld.sh	r0,r0[0x0]
80009916:	90 6c       	ld.sh	r12,r8[0xc]
80009918:	80 00       	ld.sh	r0,r0[0x0]
8000991a:	93 d4       	st.w	r9[0x34],r4

8000991c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000991c:	48 38       	lddpc	r8,80009928 <vTaskSuspendAll+0xc>
8000991e:	70 09       	ld.w	r9,r8[0x0]
80009920:	2f f9       	sub	r9,-1
80009922:	91 09       	st.w	r8[0x0],r9
}
80009924:	5e fc       	retal	r12
80009926:	00 00       	add	r0,r0
80009928:	00 00       	add	r0,r0
8000992a:	12 e8       	st.h	--r9,r8

8000992c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000992c:	49 a8       	lddpc	r8,80009994 <vTaskSwitchContext+0x68>
8000992e:	70 08       	ld.w	r8,r8[0x0]
80009930:	58 08       	cp.w	r8,0
80009932:	c0 b1       	brne	80009948 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009934:	49 98       	lddpc	r8,80009998 <vTaskSwitchContext+0x6c>
80009936:	70 08       	ld.w	r8,r8[0x0]
80009938:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000993c:	49 89       	lddpc	r9,8000999c <vTaskSwitchContext+0x70>
8000993e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80009942:	58 08       	cp.w	r8,0
80009944:	c0 60       	breq	80009950 <vTaskSwitchContext+0x24>
80009946:	c1 18       	rjmp	80009968 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80009948:	30 19       	mov	r9,1
8000994a:	49 68       	lddpc	r8,800099a0 <vTaskSwitchContext+0x74>
8000994c:	91 09       	st.w	r8[0x0],r9
8000994e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009950:	49 28       	lddpc	r8,80009998 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009952:	49 3a       	lddpc	r10,8000999c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009954:	70 09       	ld.w	r9,r8[0x0]
80009956:	20 19       	sub	r9,1
80009958:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000995a:	70 09       	ld.w	r9,r8[0x0]
8000995c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009960:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80009964:	58 09       	cp.w	r9,0
80009966:	cf 70       	breq	80009954 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80009968:	48 c8       	lddpc	r8,80009998 <vTaskSwitchContext+0x6c>
8000996a:	70 08       	ld.w	r8,r8[0x0]
8000996c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009970:	48 b9       	lddpc	r9,8000999c <vTaskSwitchContext+0x70>
80009972:	f2 08 00 28 	add	r8,r9,r8<<0x2
80009976:	70 19       	ld.w	r9,r8[0x4]
80009978:	72 19       	ld.w	r9,r9[0x4]
8000997a:	91 19       	st.w	r8[0x4],r9
8000997c:	f0 ca ff f8 	sub	r10,r8,-8
80009980:	14 39       	cp.w	r9,r10
80009982:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80009986:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000998a:	70 18       	ld.w	r8,r8[0x4]
8000998c:	70 39       	ld.w	r9,r8[0xc]
8000998e:	48 68       	lddpc	r8,800099a4 <vTaskSwitchContext+0x78>
80009990:	91 09       	st.w	r8[0x0],r9
80009992:	5e fc       	retal	r12
80009994:	00 00       	add	r0,r0
80009996:	12 e8       	st.h	--r9,r8
80009998:	00 00       	add	r0,r0
8000999a:	13 20       	ld.uh	r0,r9++
8000999c:	00 00       	add	r0,r0
8000999e:	12 04       	add	r4,r9
800099a0:	00 00       	add	r0,r0
800099a2:	13 08       	ld.w	r8,r9++
800099a4:	00 00       	add	r0,r0
800099a6:	12 b8       	st.h	r9++,r8

800099a8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800099a8:	48 48       	lddpc	r8,800099b8 <vTaskSetTimeOutState+0x10>
800099aa:	70 08       	ld.w	r8,r8[0x0]
800099ac:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800099ae:	48 48       	lddpc	r8,800099bc <vTaskSetTimeOutState+0x14>
800099b0:	70 08       	ld.w	r8,r8[0x0]
800099b2:	99 18       	st.w	r12[0x4],r8
}
800099b4:	5e fc       	retal	r12
800099b6:	00 00       	add	r0,r0
800099b8:	00 00       	add	r0,r0
800099ba:	11 fc       	ld.ub	r12,r8[0x7]
800099bc:	00 00       	add	r0,r0
800099be:	12 e4       	st.h	--r9,r4

800099c0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800099c0:	30 19       	mov	r9,1
800099c2:	48 28       	lddpc	r8,800099c8 <vTaskMissedYield+0x8>
800099c4:	91 09       	st.w	r8[0x0],r9
}
800099c6:	5e fc       	retal	r12
800099c8:	00 00       	add	r0,r0
800099ca:	13 08       	ld.w	r8,r9++

800099cc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800099cc:	48 28       	lddpc	r8,800099d4 <xTaskGetCurrentTaskHandle+0x8>
800099ce:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800099d0:	5e fc       	retal	r12
800099d2:	00 00       	add	r0,r0
800099d4:	00 00       	add	r0,r0
800099d6:	12 b8       	st.h	r9++,r8

800099d8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800099d8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800099dc:	58 0c       	cp.w	r12,0
800099de:	c1 f0       	breq	80009a1c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800099e0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800099e2:	78 b9       	ld.w	r9,r12[0x2c]
800099e4:	79 18       	ld.w	r8,r12[0x44]
800099e6:	10 39       	cp.w	r9,r8
800099e8:	c1 a0       	breq	80009a1c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800099ea:	f8 c6 ff fc 	sub	r6,r12,-4
800099ee:	0c 9c       	mov	r12,r6
800099f0:	f0 1f 00 0c 	mcall	80009a20 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800099f4:	6f 1c       	ld.w	r12,r7[0x44]
800099f6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800099f8:	f8 08 11 08 	rsub	r8,r12,8
800099fc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800099fe:	48 a8       	lddpc	r8,80009a24 <vTaskPriorityDisinherit+0x4c>
80009a00:	70 08       	ld.w	r8,r8[0x0]
80009a02:	10 3c       	cp.w	r12,r8
80009a04:	e0 88 00 04 	brls	80009a0c <vTaskPriorityDisinherit+0x34>
80009a08:	48 78       	lddpc	r8,80009a24 <vTaskPriorityDisinherit+0x4c>
80009a0a:	91 0c       	st.w	r8[0x0],r12
80009a0c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009a10:	0c 9b       	mov	r11,r6
80009a12:	48 68       	lddpc	r8,80009a28 <vTaskPriorityDisinherit+0x50>
80009a14:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009a18:	f0 1f 00 05 	mcall	80009a2c <vTaskPriorityDisinherit+0x54>
80009a1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009a20:	80 00       	ld.sh	r0,r0[0x0]
80009a22:	90 d6       	ld.uh	r6,r8[0xa]
80009a24:	00 00       	add	r0,r0
80009a26:	13 20       	ld.uh	r0,r9++
80009a28:	00 00       	add	r0,r0
80009a2a:	12 04       	add	r4,r9
80009a2c:	80 00       	ld.sh	r0,r0[0x0]
80009a2e:	90 86       	ld.uh	r6,r8[0x0]

80009a30 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80009a30:	eb cd 40 c0 	pushm	r6-r7,lr
80009a34:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80009a36:	49 b8       	lddpc	r8,80009aa0 <vTaskPriorityInherit+0x70>
80009a38:	70 08       	ld.w	r8,r8[0x0]
80009a3a:	78 b9       	ld.w	r9,r12[0x2c]
80009a3c:	70 b8       	ld.w	r8,r8[0x2c]
80009a3e:	10 39       	cp.w	r9,r8
80009a40:	c2 d2       	brcc	80009a9a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80009a42:	49 88       	lddpc	r8,80009aa0 <vTaskPriorityInherit+0x70>
80009a44:	70 08       	ld.w	r8,r8[0x0]
80009a46:	70 b8       	ld.w	r8,r8[0x2c]
80009a48:	f0 08 11 08 	rsub	r8,r8,8
80009a4c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80009a4e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80009a52:	49 59       	lddpc	r9,80009aa4 <vTaskPriorityInherit+0x74>
80009a54:	f2 08 00 28 	add	r8,r9,r8<<0x2
80009a58:	78 59       	ld.w	r9,r12[0x14]
80009a5a:	10 39       	cp.w	r9,r8
80009a5c:	c1 b1       	brne	80009a92 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80009a5e:	f8 c6 ff fc 	sub	r6,r12,-4
80009a62:	0c 9c       	mov	r12,r6
80009a64:	f0 1f 00 11 	mcall	80009aa8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009a68:	48 e8       	lddpc	r8,80009aa0 <vTaskPriorityInherit+0x70>
80009a6a:	70 08       	ld.w	r8,r8[0x0]
80009a6c:	70 bc       	ld.w	r12,r8[0x2c]
80009a6e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80009a70:	48 f8       	lddpc	r8,80009aac <vTaskPriorityInherit+0x7c>
80009a72:	70 08       	ld.w	r8,r8[0x0]
80009a74:	10 3c       	cp.w	r12,r8
80009a76:	e0 88 00 04 	brls	80009a7e <vTaskPriorityInherit+0x4e>
80009a7a:	48 d8       	lddpc	r8,80009aac <vTaskPriorityInherit+0x7c>
80009a7c:	91 0c       	st.w	r8[0x0],r12
80009a7e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009a82:	0c 9b       	mov	r11,r6
80009a84:	48 88       	lddpc	r8,80009aa4 <vTaskPriorityInherit+0x74>
80009a86:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009a8a:	f0 1f 00 0a 	mcall	80009ab0 <vTaskPriorityInherit+0x80>
80009a8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009a92:	48 48       	lddpc	r8,80009aa0 <vTaskPriorityInherit+0x70>
80009a94:	70 08       	ld.w	r8,r8[0x0]
80009a96:	70 b8       	ld.w	r8,r8[0x2c]
80009a98:	99 b8       	st.w	r12[0x2c],r8
80009a9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009a9e:	00 00       	add	r0,r0
80009aa0:	00 00       	add	r0,r0
80009aa2:	12 b8       	st.h	r9++,r8
80009aa4:	00 00       	add	r0,r0
80009aa6:	12 04       	add	r4,r9
80009aa8:	80 00       	ld.sh	r0,r0[0x0]
80009aaa:	90 d6       	ld.uh	r6,r8[0xa]
80009aac:	00 00       	add	r0,r0
80009aae:	13 20       	ld.uh	r0,r9++
80009ab0:	80 00       	ld.sh	r0,r0[0x0]
80009ab2:	90 86       	ld.uh	r6,r8[0x0]

80009ab4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80009ab4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80009ab8:	78 38       	ld.w	r8,r12[0xc]
80009aba:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80009abc:	ee c6 ff e8 	sub	r6,r7,-24
80009ac0:	0c 9c       	mov	r12,r6
80009ac2:	f0 1f 00 15 	mcall	80009b14 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009ac6:	49 58       	lddpc	r8,80009b18 <xTaskRemoveFromEventList+0x64>
80009ac8:	70 08       	ld.w	r8,r8[0x0]
80009aca:	58 08       	cp.w	r8,0
80009acc:	c1 71       	brne	80009afa <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80009ace:	ee c6 ff fc 	sub	r6,r7,-4
80009ad2:	0c 9c       	mov	r12,r6
80009ad4:	f0 1f 00 10 	mcall	80009b14 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80009ad8:	6e bc       	ld.w	r12,r7[0x2c]
80009ada:	49 18       	lddpc	r8,80009b1c <xTaskRemoveFromEventList+0x68>
80009adc:	70 08       	ld.w	r8,r8[0x0]
80009ade:	10 3c       	cp.w	r12,r8
80009ae0:	e0 88 00 04 	brls	80009ae8 <xTaskRemoveFromEventList+0x34>
80009ae4:	48 e8       	lddpc	r8,80009b1c <xTaskRemoveFromEventList+0x68>
80009ae6:	91 0c       	st.w	r8[0x0],r12
80009ae8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009aec:	0c 9b       	mov	r11,r6
80009aee:	48 d8       	lddpc	r8,80009b20 <xTaskRemoveFromEventList+0x6c>
80009af0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009af4:	f0 1f 00 0c 	mcall	80009b24 <xTaskRemoveFromEventList+0x70>
80009af8:	c0 58       	rjmp	80009b02 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80009afa:	0c 9b       	mov	r11,r6
80009afc:	48 bc       	lddpc	r12,80009b28 <xTaskRemoveFromEventList+0x74>
80009afe:	f0 1f 00 0a 	mcall	80009b24 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009b02:	48 b8       	lddpc	r8,80009b2c <xTaskRemoveFromEventList+0x78>
80009b04:	70 08       	ld.w	r8,r8[0x0]
80009b06:	6e b9       	ld.w	r9,r7[0x2c]
80009b08:	70 b8       	ld.w	r8,r8[0x2c]
80009b0a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80009b0c:	5f 2c       	srhs	r12
80009b0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009b12:	00 00       	add	r0,r0
80009b14:	80 00       	ld.sh	r0,r0[0x0]
80009b16:	90 d6       	ld.uh	r6,r8[0xa]
80009b18:	00 00       	add	r0,r0
80009b1a:	12 e8       	st.h	--r9,r8
80009b1c:	00 00       	add	r0,r0
80009b1e:	13 20       	ld.uh	r0,r9++
80009b20:	00 00       	add	r0,r0
80009b22:	12 04       	add	r4,r9
80009b24:	80 00       	ld.sh	r0,r0[0x0]
80009b26:	90 86       	ld.uh	r6,r8[0x0]
80009b28:	00 00       	add	r0,r0
80009b2a:	12 bc       	st.h	r9++,r12
80009b2c:	00 00       	add	r0,r0
80009b2e:	12 b8       	st.h	r9++,r8

80009b30 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009b30:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009b34:	4b 98       	lddpc	r8,80009c18 <vTaskIncrementTick+0xe8>
80009b36:	70 08       	ld.w	r8,r8[0x0]
80009b38:	58 08       	cp.w	r8,0
80009b3a:	c6 91       	brne	80009c0c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80009b3c:	4b 88       	lddpc	r8,80009c1c <vTaskIncrementTick+0xec>
80009b3e:	70 09       	ld.w	r9,r8[0x0]
80009b40:	2f f9       	sub	r9,-1
80009b42:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80009b44:	70 08       	ld.w	r8,r8[0x0]
80009b46:	58 08       	cp.w	r8,0
80009b48:	c1 a1       	brne	80009b7c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80009b4a:	4b 68       	lddpc	r8,80009c20 <vTaskIncrementTick+0xf0>
80009b4c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80009b4e:	4b 69       	lddpc	r9,80009c24 <vTaskIncrementTick+0xf4>
80009b50:	72 0b       	ld.w	r11,r9[0x0]
80009b52:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80009b54:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80009b56:	4b 59       	lddpc	r9,80009c28 <vTaskIncrementTick+0xf8>
80009b58:	72 0a       	ld.w	r10,r9[0x0]
80009b5a:	2f fa       	sub	r10,-1
80009b5c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80009b5e:	70 08       	ld.w	r8,r8[0x0]
80009b60:	70 08       	ld.w	r8,r8[0x0]
80009b62:	58 08       	cp.w	r8,0
80009b64:	c0 51       	brne	80009b6e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80009b66:	3f f9       	mov	r9,-1
80009b68:	4b 18       	lddpc	r8,80009c2c <vTaskIncrementTick+0xfc>
80009b6a:	91 09       	st.w	r8[0x0],r9
80009b6c:	c0 88       	rjmp	80009b7c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80009b6e:	4a d8       	lddpc	r8,80009c20 <vTaskIncrementTick+0xf0>
80009b70:	70 08       	ld.w	r8,r8[0x0]
80009b72:	70 38       	ld.w	r8,r8[0xc]
80009b74:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80009b76:	70 19       	ld.w	r9,r8[0x4]
80009b78:	4a d8       	lddpc	r8,80009c2c <vTaskIncrementTick+0xfc>
80009b7a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80009b7c:	4a 88       	lddpc	r8,80009c1c <vTaskIncrementTick+0xec>
80009b7e:	70 09       	ld.w	r9,r8[0x0]
80009b80:	4a b8       	lddpc	r8,80009c2c <vTaskIncrementTick+0xfc>
80009b82:	70 08       	ld.w	r8,r8[0x0]
80009b84:	10 39       	cp.w	r9,r8
80009b86:	c4 73       	brcs	80009c14 <vTaskIncrementTick+0xe4>
80009b88:	4a 68       	lddpc	r8,80009c20 <vTaskIncrementTick+0xf0>
80009b8a:	70 08       	ld.w	r8,r8[0x0]
80009b8c:	70 08       	ld.w	r8,r8[0x0]
80009b8e:	58 08       	cp.w	r8,0
80009b90:	c0 c0       	breq	80009ba8 <vTaskIncrementTick+0x78>
80009b92:	4a 48       	lddpc	r8,80009c20 <vTaskIncrementTick+0xf0>
80009b94:	70 08       	ld.w	r8,r8[0x0]
80009b96:	70 38       	ld.w	r8,r8[0xc]
80009b98:	70 37       	ld.w	r7,r8[0xc]
80009b9a:	6e 18       	ld.w	r8,r7[0x4]
80009b9c:	4a 09       	lddpc	r9,80009c1c <vTaskIncrementTick+0xec>
80009b9e:	72 09       	ld.w	r9,r9[0x0]
80009ba0:	12 38       	cp.w	r8,r9
80009ba2:	e0 88 00 14 	brls	80009bca <vTaskIncrementTick+0x9a>
80009ba6:	c0 e8       	rjmp	80009bc2 <vTaskIncrementTick+0x92>
80009ba8:	3f f9       	mov	r9,-1
80009baa:	4a 18       	lddpc	r8,80009c2c <vTaskIncrementTick+0xfc>
80009bac:	91 09       	st.w	r8[0x0],r9
80009bae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009bb2:	6a 08       	ld.w	r8,r5[0x0]
80009bb4:	70 38       	ld.w	r8,r8[0xc]
80009bb6:	70 37       	ld.w	r7,r8[0xc]
80009bb8:	6e 18       	ld.w	r8,r7[0x4]
80009bba:	64 09       	ld.w	r9,r2[0x0]
80009bbc:	12 38       	cp.w	r8,r9
80009bbe:	e0 88 00 0a 	brls	80009bd2 <vTaskIncrementTick+0xa2>
80009bc2:	49 b9       	lddpc	r9,80009c2c <vTaskIncrementTick+0xfc>
80009bc4:	93 08       	st.w	r9[0x0],r8
80009bc6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009bca:	49 a4       	lddpc	r4,80009c30 <vTaskIncrementTick+0x100>
80009bcc:	49 a3       	lddpc	r3,80009c34 <vTaskIncrementTick+0x104>
80009bce:	49 55       	lddpc	r5,80009c20 <vTaskIncrementTick+0xf0>
80009bd0:	49 32       	lddpc	r2,80009c1c <vTaskIncrementTick+0xec>
80009bd2:	ee c6 ff fc 	sub	r6,r7,-4
80009bd6:	0c 9c       	mov	r12,r6
80009bd8:	f0 1f 00 18 	mcall	80009c38 <vTaskIncrementTick+0x108>
80009bdc:	6e a8       	ld.w	r8,r7[0x28]
80009bde:	58 08       	cp.w	r8,0
80009be0:	c0 50       	breq	80009bea <vTaskIncrementTick+0xba>
80009be2:	ee cc ff e8 	sub	r12,r7,-24
80009be6:	f0 1f 00 15 	mcall	80009c38 <vTaskIncrementTick+0x108>
80009bea:	6e bc       	ld.w	r12,r7[0x2c]
80009bec:	68 08       	ld.w	r8,r4[0x0]
80009bee:	10 3c       	cp.w	r12,r8
80009bf0:	e9 fc ba 00 	st.whi	r4[0x0],r12
80009bf4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009bf8:	0c 9b       	mov	r11,r6
80009bfa:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80009bfe:	f0 1f 00 10 	mcall	80009c3c <vTaskIncrementTick+0x10c>
80009c02:	6a 08       	ld.w	r8,r5[0x0]
80009c04:	70 08       	ld.w	r8,r8[0x0]
80009c06:	58 08       	cp.w	r8,0
80009c08:	cd 51       	brne	80009bb2 <vTaskIncrementTick+0x82>
80009c0a:	cc fb       	rjmp	80009ba8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80009c0c:	48 d8       	lddpc	r8,80009c40 <vTaskIncrementTick+0x110>
80009c0e:	70 09       	ld.w	r9,r8[0x0]
80009c10:	2f f9       	sub	r9,-1
80009c12:	91 09       	st.w	r8[0x0],r9
80009c14:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009c18:	00 00       	add	r0,r0
80009c1a:	12 e8       	st.h	--r9,r8
80009c1c:	00 00       	add	r0,r0
80009c1e:	12 e4       	st.h	--r9,r4
80009c20:	00 00       	add	r0,r0
80009c22:	11 f0       	ld.ub	r0,r8[0x7]
80009c24:	00 00       	add	r0,r0
80009c26:	12 00       	add	r0,r9
80009c28:	00 00       	add	r0,r0
80009c2a:	11 fc       	ld.ub	r12,r8[0x7]
80009c2c:	00 00       	add	r0,r0
80009c2e:	05 34       	ld.ub	r4,r2++
80009c30:	00 00       	add	r0,r0
80009c32:	13 20       	ld.uh	r0,r9++
80009c34:	00 00       	add	r0,r0
80009c36:	12 04       	add	r4,r9
80009c38:	80 00       	ld.sh	r0,r0[0x0]
80009c3a:	90 d6       	ld.uh	r6,r8[0xa]
80009c3c:	80 00       	ld.sh	r0,r0[0x0]
80009c3e:	90 86       	ld.uh	r6,r8[0x0]
80009c40:	00 00       	add	r0,r0
80009c42:	11 e8       	ld.ub	r8,r8[0x6]

80009c44 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80009c44:	eb cd 40 c0 	pushm	r6-r7,lr
80009c48:	18 97       	mov	r7,r12
80009c4a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80009c4c:	f0 1f 00 15 	mcall	80009ca0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80009c50:	6c 08       	ld.w	r8,r6[0x0]
80009c52:	5b f8       	cp.w	r8,-1
80009c54:	c0 31       	brne	80009c5a <xTaskCheckForTimeOut+0x16>
80009c56:	30 07       	mov	r7,0
80009c58:	c1 f8       	rjmp	80009c96 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80009c5a:	49 39       	lddpc	r9,80009ca4 <xTaskCheckForTimeOut+0x60>
80009c5c:	72 09       	ld.w	r9,r9[0x0]
80009c5e:	6e 0a       	ld.w	r10,r7[0x0]
80009c60:	12 3a       	cp.w	r10,r9
80009c62:	c0 70       	breq	80009c70 <xTaskCheckForTimeOut+0x2c>
80009c64:	49 19       	lddpc	r9,80009ca8 <xTaskCheckForTimeOut+0x64>
80009c66:	72 09       	ld.w	r9,r9[0x0]
80009c68:	6e 1a       	ld.w	r10,r7[0x4]
80009c6a:	12 3a       	cp.w	r10,r9
80009c6c:	e0 88 00 14 	brls	80009c94 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80009c70:	48 e9       	lddpc	r9,80009ca8 <xTaskCheckForTimeOut+0x64>
80009c72:	72 0a       	ld.w	r10,r9[0x0]
80009c74:	6e 19       	ld.w	r9,r7[0x4]
80009c76:	12 1a       	sub	r10,r9
80009c78:	14 38       	cp.w	r8,r10
80009c7a:	e0 88 00 0d 	brls	80009c94 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80009c7e:	48 ba       	lddpc	r10,80009ca8 <xTaskCheckForTimeOut+0x64>
80009c80:	74 0a       	ld.w	r10,r10[0x0]
80009c82:	14 19       	sub	r9,r10
80009c84:	f2 08 00 08 	add	r8,r9,r8
80009c88:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80009c8a:	0e 9c       	mov	r12,r7
80009c8c:	f0 1f 00 08 	mcall	80009cac <xTaskCheckForTimeOut+0x68>
80009c90:	30 07       	mov	r7,0
80009c92:	c0 28       	rjmp	80009c96 <xTaskCheckForTimeOut+0x52>
80009c94:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80009c96:	f0 1f 00 07 	mcall	80009cb0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80009c9a:	0e 9c       	mov	r12,r7
80009c9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009ca0:	80 00       	ld.sh	r0,r0[0x0]
80009ca2:	91 90       	st.w	r8[0x24],r0
80009ca4:	00 00       	add	r0,r0
80009ca6:	11 fc       	ld.ub	r12,r8[0x7]
80009ca8:	00 00       	add	r0,r0
80009caa:	12 e4       	st.h	--r9,r4
80009cac:	80 00       	ld.sh	r0,r0[0x0]
80009cae:	99 a8       	st.w	r12[0x28],r8
80009cb0:	80 00       	ld.sh	r0,r0[0x0]
80009cb2:	92 9c       	ld.uh	r12,r9[0x2]

80009cb4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80009cb4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009cb8:	f0 1f 00 05 	mcall	80009ccc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80009cbc:	48 58       	lddpc	r8,80009cd0 <xTaskGetTickCount+0x1c>
80009cbe:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80009cc0:	f0 1f 00 05 	mcall	80009cd4 <xTaskGetTickCount+0x20>

	return xTicks;
}
80009cc4:	0e 9c       	mov	r12,r7
80009cc6:	e3 cd 80 80 	ldm	sp++,r7,pc
80009cca:	00 00       	add	r0,r0
80009ccc:	80 00       	ld.sh	r0,r0[0x0]
80009cce:	91 90       	st.w	r8[0x24],r0
80009cd0:	00 00       	add	r0,r0
80009cd2:	12 e4       	st.h	--r9,r4
80009cd4:	80 00       	ld.sh	r0,r0[0x0]
80009cd6:	92 9c       	ld.uh	r12,r9[0x2]

80009cd8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80009cd8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80009cdc:	f0 1f 00 2c 	mcall	80009d8c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80009ce0:	4a c8       	lddpc	r8,80009d90 <xTaskResumeAll+0xb8>
80009ce2:	70 09       	ld.w	r9,r8[0x0]
80009ce4:	20 19       	sub	r9,1
80009ce6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009ce8:	70 08       	ld.w	r8,r8[0x0]
80009cea:	58 08       	cp.w	r8,0
80009cec:	c4 91       	brne	80009d7e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80009cee:	4a a8       	lddpc	r8,80009d94 <xTaskResumeAll+0xbc>
80009cf0:	70 08       	ld.w	r8,r8[0x0]
80009cf2:	58 08       	cp.w	r8,0
80009cf4:	c4 50       	breq	80009d7e <xTaskResumeAll+0xa6>
80009cf6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009cf8:	4a 85       	lddpc	r5,80009d98 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80009cfa:	4a 93       	lddpc	r3,80009d9c <xTaskResumeAll+0xc4>
80009cfc:	4a 92       	lddpc	r2,80009da0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009cfe:	4a a1       	lddpc	r1,80009da4 <xTaskResumeAll+0xcc>
80009d00:	c1 e8       	rjmp	80009d3c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80009d02:	6a 38       	ld.w	r8,r5[0xc]
80009d04:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80009d06:	ee cc ff e8 	sub	r12,r7,-24
80009d0a:	f0 1f 00 28 	mcall	80009da8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80009d0e:	ee c6 ff fc 	sub	r6,r7,-4
80009d12:	0c 9c       	mov	r12,r6
80009d14:	f0 1f 00 25 	mcall	80009da8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80009d18:	6e bc       	ld.w	r12,r7[0x2c]
80009d1a:	66 08       	ld.w	r8,r3[0x0]
80009d1c:	10 3c       	cp.w	r12,r8
80009d1e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80009d22:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009d26:	0c 9b       	mov	r11,r6
80009d28:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80009d2c:	f0 1f 00 20 	mcall	80009dac <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009d30:	62 08       	ld.w	r8,r1[0x0]
80009d32:	6e b9       	ld.w	r9,r7[0x2c]
80009d34:	70 b8       	ld.w	r8,r8[0x2c]
80009d36:	10 39       	cp.w	r9,r8
80009d38:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009d3c:	6a 08       	ld.w	r8,r5[0x0]
80009d3e:	58 08       	cp.w	r8,0
80009d40:	ce 11       	brne	80009d02 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009d42:	49 c8       	lddpc	r8,80009db0 <xTaskResumeAll+0xd8>
80009d44:	70 08       	ld.w	r8,r8[0x0]
80009d46:	58 08       	cp.w	r8,0
80009d48:	c0 f0       	breq	80009d66 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009d4a:	49 a8       	lddpc	r8,80009db0 <xTaskResumeAll+0xd8>
80009d4c:	70 08       	ld.w	r8,r8[0x0]
80009d4e:	58 08       	cp.w	r8,0
80009d50:	c1 10       	breq	80009d72 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80009d52:	49 87       	lddpc	r7,80009db0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80009d54:	f0 1f 00 18 	mcall	80009db4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80009d58:	6e 08       	ld.w	r8,r7[0x0]
80009d5a:	20 18       	sub	r8,1
80009d5c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009d5e:	6e 08       	ld.w	r8,r7[0x0]
80009d60:	58 08       	cp.w	r8,0
80009d62:	cf 91       	brne	80009d54 <xTaskResumeAll+0x7c>
80009d64:	c0 78       	rjmp	80009d72 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80009d66:	58 14       	cp.w	r4,1
80009d68:	c0 50       	breq	80009d72 <xTaskResumeAll+0x9a>
80009d6a:	49 48       	lddpc	r8,80009db8 <xTaskResumeAll+0xe0>
80009d6c:	70 08       	ld.w	r8,r8[0x0]
80009d6e:	58 18       	cp.w	r8,1
80009d70:	c0 71       	brne	80009d7e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80009d72:	30 09       	mov	r9,0
80009d74:	49 18       	lddpc	r8,80009db8 <xTaskResumeAll+0xe0>
80009d76:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80009d78:	d7 33       	scall
80009d7a:	30 17       	mov	r7,1
80009d7c:	c0 28       	rjmp	80009d80 <xTaskResumeAll+0xa8>
80009d7e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80009d80:	f0 1f 00 0f 	mcall	80009dbc <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80009d84:	0e 9c       	mov	r12,r7
80009d86:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80009d8a:	00 00       	add	r0,r0
80009d8c:	80 00       	ld.sh	r0,r0[0x0]
80009d8e:	91 90       	st.w	r8[0x24],r0
80009d90:	00 00       	add	r0,r0
80009d92:	12 e8       	st.h	--r9,r8
80009d94:	00 00       	add	r0,r0
80009d96:	13 04       	ld.w	r4,r9++
80009d98:	00 00       	add	r0,r0
80009d9a:	12 bc       	st.h	r9++,r12
80009d9c:	00 00       	add	r0,r0
80009d9e:	13 20       	ld.uh	r0,r9++
80009da0:	00 00       	add	r0,r0
80009da2:	12 04       	add	r4,r9
80009da4:	00 00       	add	r0,r0
80009da6:	12 b8       	st.h	r9++,r8
80009da8:	80 00       	ld.sh	r0,r0[0x0]
80009daa:	90 d6       	ld.uh	r6,r8[0xa]
80009dac:	80 00       	ld.sh	r0,r0[0x0]
80009dae:	90 86       	ld.uh	r6,r8[0x0]
80009db0:	00 00       	add	r0,r0
80009db2:	11 e8       	ld.ub	r8,r8[0x6]
80009db4:	80 00       	ld.sh	r0,r0[0x0]
80009db6:	9b 30       	st.w	sp[0xc],r0
80009db8:	00 00       	add	r0,r0
80009dba:	13 08       	ld.w	r8,r9++
80009dbc:	80 00       	ld.sh	r0,r0[0x0]
80009dbe:	92 9c       	ld.uh	r12,r9[0x2]

80009dc0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009dc0:	eb cd 40 80 	pushm	r7,lr
80009dc4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80009dc6:	49 08       	lddpc	r8,80009e04 <prvAddCurrentTaskToDelayedList+0x44>
80009dc8:	70 08       	ld.w	r8,r8[0x0]
80009dca:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80009dcc:	48 f8       	lddpc	r8,80009e08 <prvAddCurrentTaskToDelayedList+0x48>
80009dce:	70 08       	ld.w	r8,r8[0x0]
80009dd0:	10 3c       	cp.w	r12,r8
80009dd2:	c0 a2       	brcc	80009de6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009dd4:	48 c8       	lddpc	r8,80009e04 <prvAddCurrentTaskToDelayedList+0x44>
80009dd6:	70 0b       	ld.w	r11,r8[0x0]
80009dd8:	48 d8       	lddpc	r8,80009e0c <prvAddCurrentTaskToDelayedList+0x4c>
80009dda:	70 0c       	ld.w	r12,r8[0x0]
80009ddc:	2f cb       	sub	r11,-4
80009dde:	f0 1f 00 0d 	mcall	80009e10 <prvAddCurrentTaskToDelayedList+0x50>
80009de2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009de6:	48 88       	lddpc	r8,80009e04 <prvAddCurrentTaskToDelayedList+0x44>
80009de8:	70 0b       	ld.w	r11,r8[0x0]
80009dea:	48 b8       	lddpc	r8,80009e14 <prvAddCurrentTaskToDelayedList+0x54>
80009dec:	70 0c       	ld.w	r12,r8[0x0]
80009dee:	2f cb       	sub	r11,-4
80009df0:	f0 1f 00 08 	mcall	80009e10 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009df4:	48 98       	lddpc	r8,80009e18 <prvAddCurrentTaskToDelayedList+0x58>
80009df6:	70 08       	ld.w	r8,r8[0x0]
80009df8:	10 37       	cp.w	r7,r8
80009dfa:	c0 32       	brcc	80009e00 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80009dfc:	48 78       	lddpc	r8,80009e18 <prvAddCurrentTaskToDelayedList+0x58>
80009dfe:	91 07       	st.w	r8[0x0],r7
80009e00:	e3 cd 80 80 	ldm	sp++,r7,pc
80009e04:	00 00       	add	r0,r0
80009e06:	12 b8       	st.h	r9++,r8
80009e08:	00 00       	add	r0,r0
80009e0a:	12 e4       	st.h	--r9,r4
80009e0c:	00 00       	add	r0,r0
80009e0e:	12 00       	add	r0,r9
80009e10:	80 00       	ld.sh	r0,r0[0x0]
80009e12:	90 a2       	ld.uh	r2,r8[0x4]
80009e14:	00 00       	add	r0,r0
80009e16:	11 f0       	ld.ub	r0,r8[0x7]
80009e18:	00 00       	add	r0,r0
80009e1a:	05 34       	ld.ub	r4,r2++

80009e1c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009e1c:	eb cd 40 c0 	pushm	r6-r7,lr
80009e20:	18 96       	mov	r6,r12
80009e22:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80009e24:	f0 1f 00 18 	mcall	80009e84 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80009e28:	6c 08       	ld.w	r8,r6[0x0]
80009e2a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80009e2c:	49 79       	lddpc	r9,80009e88 <vTaskDelayUntil+0x6c>
80009e2e:	72 09       	ld.w	r9,r9[0x0]
80009e30:	12 38       	cp.w	r8,r9
80009e32:	e0 88 00 0c 	brls	80009e4a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80009e36:	0e 38       	cp.w	r8,r7
80009e38:	e0 88 00 22 	brls	80009e7c <vTaskDelayUntil+0x60>
80009e3c:	49 38       	lddpc	r8,80009e88 <vTaskDelayUntil+0x6c>
80009e3e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009e40:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80009e42:	10 37       	cp.w	r7,r8
80009e44:	e0 88 00 14 	brls	80009e6c <vTaskDelayUntil+0x50>
80009e48:	c0 a8       	rjmp	80009e5c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80009e4a:	0e 38       	cp.w	r8,r7
80009e4c:	e0 8b 00 16 	brhi	80009e78 <vTaskDelayUntil+0x5c>
80009e50:	48 e8       	lddpc	r8,80009e88 <vTaskDelayUntil+0x6c>
80009e52:	70 08       	ld.w	r8,r8[0x0]
80009e54:	10 37       	cp.w	r7,r8
80009e56:	e0 8b 00 11 	brhi	80009e78 <vTaskDelayUntil+0x5c>
80009e5a:	c1 18       	rjmp	80009e7c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009e5c:	48 c8       	lddpc	r8,80009e8c <vTaskDelayUntil+0x70>
80009e5e:	70 0c       	ld.w	r12,r8[0x0]
80009e60:	2f cc       	sub	r12,-4
80009e62:	f0 1f 00 0c 	mcall	80009e90 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80009e66:	0e 9c       	mov	r12,r7
80009e68:	f0 1f 00 0b 	mcall	80009e94 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009e6c:	f0 1f 00 0b 	mcall	80009e98 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80009e70:	c0 81       	brne	80009e80 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80009e72:	d7 33       	scall
80009e74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009e78:	8d 07       	st.w	r6[0x0],r7
80009e7a:	cf 1b       	rjmp	80009e5c <vTaskDelayUntil+0x40>
80009e7c:	8d 07       	st.w	r6[0x0],r7
80009e7e:	cf 7b       	rjmp	80009e6c <vTaskDelayUntil+0x50>
80009e80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009e84:	80 00       	ld.sh	r0,r0[0x0]
80009e86:	99 1c       	st.w	r12[0x4],r12
80009e88:	00 00       	add	r0,r0
80009e8a:	12 e4       	st.h	--r9,r4
80009e8c:	00 00       	add	r0,r0
80009e8e:	12 b8       	st.h	r9++,r8
80009e90:	80 00       	ld.sh	r0,r0[0x0]
80009e92:	90 d6       	ld.uh	r6,r8[0xa]
80009e94:	80 00       	ld.sh	r0,r0[0x0]
80009e96:	9d c0       	st.w	lr[0x30],r0
80009e98:	80 00       	ld.sh	r0,r0[0x0]
80009e9a:	9c d8       	ld.uh	r8,lr[0xa]

80009e9c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009e9c:	eb cd 40 c0 	pushm	r6-r7,lr
80009ea0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009ea2:	48 e7       	lddpc	r7,80009ed8 <vTaskPlaceOnEventList+0x3c>
80009ea4:	6e 0b       	ld.w	r11,r7[0x0]
80009ea6:	2e 8b       	sub	r11,-24
80009ea8:	f0 1f 00 0d 	mcall	80009edc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009eac:	6e 0c       	ld.w	r12,r7[0x0]
80009eae:	2f cc       	sub	r12,-4
80009eb0:	f0 1f 00 0c 	mcall	80009ee0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009eb4:	5b f6       	cp.w	r6,-1
80009eb6:	c0 81       	brne	80009ec6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009eb8:	6e 0b       	ld.w	r11,r7[0x0]
80009eba:	2f cb       	sub	r11,-4
80009ebc:	48 ac       	lddpc	r12,80009ee4 <vTaskPlaceOnEventList+0x48>
80009ebe:	f0 1f 00 0b 	mcall	80009ee8 <vTaskPlaceOnEventList+0x4c>
80009ec2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009ec6:	48 a8       	lddpc	r8,80009eec <vTaskPlaceOnEventList+0x50>
80009ec8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009eca:	ec 0c 00 0c 	add	r12,r6,r12
80009ece:	f0 1f 00 09 	mcall	80009ef0 <vTaskPlaceOnEventList+0x54>
80009ed2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009ed6:	00 00       	add	r0,r0
80009ed8:	00 00       	add	r0,r0
80009eda:	12 b8       	st.h	r9++,r8
80009edc:	80 00       	ld.sh	r0,r0[0x0]
80009ede:	90 a2       	ld.uh	r2,r8[0x4]
80009ee0:	80 00       	ld.sh	r0,r0[0x0]
80009ee2:	90 d6       	ld.uh	r6,r8[0xa]
80009ee4:	00 00       	add	r0,r0
80009ee6:	13 0c       	ld.w	r12,r9++
80009ee8:	80 00       	ld.sh	r0,r0[0x0]
80009eea:	90 86       	ld.uh	r6,r8[0x0]
80009eec:	00 00       	add	r0,r0
80009eee:	12 e4       	st.h	--r9,r4
80009ef0:	80 00       	ld.sh	r0,r0[0x0]
80009ef2:	9d c0       	st.w	lr[0x30],r0

80009ef4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009ef4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009ef8:	49 67       	lddpc	r7,80009f50 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009efa:	49 74       	lddpc	r4,80009f54 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009efc:	49 73       	lddpc	r3,80009f58 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009efe:	49 85       	lddpc	r5,80009f5c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009f00:	6e 08       	ld.w	r8,r7[0x0]
80009f02:	58 08       	cp.w	r8,0
80009f04:	c1 e0       	breq	80009f40 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80009f06:	f0 1f 00 17 	mcall	80009f60 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009f0a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009f0c:	f0 1f 00 16 	mcall	80009f64 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009f10:	58 06       	cp.w	r6,0
80009f12:	c1 70       	breq	80009f40 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009f14:	f0 1f 00 15 	mcall	80009f68 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009f18:	68 38       	ld.w	r8,r4[0xc]
80009f1a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009f1c:	ec cc ff fc 	sub	r12,r6,-4
80009f20:	f0 1f 00 13 	mcall	80009f6c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009f24:	66 08       	ld.w	r8,r3[0x0]
80009f26:	20 18       	sub	r8,1
80009f28:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80009f2a:	6e 08       	ld.w	r8,r7[0x0]
80009f2c:	20 18       	sub	r8,1
80009f2e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009f30:	f0 1f 00 10 	mcall	80009f70 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009f34:	6c cc       	ld.w	r12,r6[0x30]
80009f36:	f0 1f 00 10 	mcall	80009f74 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80009f3a:	0c 9c       	mov	r12,r6
80009f3c:	f0 1f 00 0e 	mcall	80009f74 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009f40:	6a 08       	ld.w	r8,r5[0x0]
80009f42:	58 18       	cp.w	r8,1
80009f44:	e0 88 00 03 	brls	80009f4a <prvIdleTask+0x56>
			{
				taskYIELD();
80009f48:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80009f4a:	f0 1f 00 0c 	mcall	80009f78 <prvIdleTask+0x84>
		}
		#endif
	}
80009f4e:	cd 9b       	rjmp	80009f00 <prvIdleTask+0xc>
80009f50:	00 00       	add	r0,r0
80009f52:	11 f8       	ld.ub	r8,r8[0x7]
80009f54:	00 00       	add	r0,r0
80009f56:	12 a4       	st.w	r9++,r4
80009f58:	00 00       	add	r0,r0
80009f5a:	13 04       	ld.w	r4,r9++
80009f5c:	00 00       	add	r0,r0
80009f5e:	12 04       	add	r4,r9
80009f60:	80 00       	ld.sh	r0,r0[0x0]
80009f62:	99 1c       	st.w	r12[0x4],r12
80009f64:	80 00       	ld.sh	r0,r0[0x0]
80009f66:	9c d8       	ld.uh	r8,lr[0xa]
80009f68:	80 00       	ld.sh	r0,r0[0x0]
80009f6a:	91 90       	st.w	r8[0x24],r0
80009f6c:	80 00       	ld.sh	r0,r0[0x0]
80009f6e:	90 d6       	ld.uh	r6,r8[0xa]
80009f70:	80 00       	ld.sh	r0,r0[0x0]
80009f72:	92 9c       	ld.uh	r12,r9[0x2]
80009f74:	80 00       	ld.sh	r0,r0[0x0]
80009f76:	93 d4       	st.w	r9[0x34],r4
80009f78:	80 00       	ld.sh	r0,r0[0x0]
80009f7a:	20 38       	sub	r8,3

80009f7c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80009f7c:	d4 31       	pushm	r0-r7,lr
80009f7e:	20 1d       	sub	sp,4
80009f80:	fa c4 ff d8 	sub	r4,sp,-40
80009f84:	50 0c       	stdsp	sp[0x0],r12
80009f86:	16 91       	mov	r1,r11
80009f88:	14 97       	mov	r7,r10
80009f8a:	12 90       	mov	r0,r9
80009f8c:	10 93       	mov	r3,r8
80009f8e:	68 02       	ld.w	r2,r4[0x0]
80009f90:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009f92:	34 8c       	mov	r12,72
80009f94:	f0 1f 00 5c 	mcall	8000a104 <xTaskGenericCreate+0x188>
80009f98:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80009f9a:	c0 31       	brne	80009fa0 <xTaskGenericCreate+0x24>
80009f9c:	3f fc       	mov	r12,-1
80009f9e:	ca f8       	rjmp	8000a0fc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009fa0:	58 06       	cp.w	r6,0
80009fa2:	e0 81 00 af 	brne	8000a100 <xTaskGenericCreate+0x184>
80009fa6:	0e 9c       	mov	r12,r7
80009fa8:	5c 7c       	castu.h	r12
80009faa:	a3 6c       	lsl	r12,0x2
80009fac:	f0 1f 00 56 	mcall	8000a104 <xTaskGenericCreate+0x188>
80009fb0:	18 96       	mov	r6,r12
80009fb2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80009fb4:	c0 61       	brne	80009fc0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009fb6:	0a 9c       	mov	r12,r5
80009fb8:	f0 1f 00 54 	mcall	8000a108 <xTaskGenericCreate+0x18c>
80009fbc:	3f fc       	mov	r12,-1
80009fbe:	c9 f8       	rjmp	8000a0fc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009fc0:	5c 77       	castu.h	r7
80009fc2:	ee 0a 15 02 	lsl	r10,r7,0x2
80009fc6:	e0 6b 00 a5 	mov	r11,165
80009fca:	0c 9c       	mov	r12,r6
80009fcc:	f0 1f 00 50 	mcall	8000a10c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009fd0:	ee c6 00 01 	sub	r6,r7,1
80009fd4:	6a c8       	ld.w	r8,r5[0x30]
80009fd6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80009fda:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009fde:	31 0a       	mov	r10,16
80009fe0:	02 9b       	mov	r11,r1
80009fe2:	ea cc ff cc 	sub	r12,r5,-52
80009fe6:	f0 1f 00 4b 	mcall	8000a110 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80009fea:	30 08       	mov	r8,0
80009fec:	eb 68 00 43 	st.b	r5[67],r8
80009ff0:	58 73       	cp.w	r3,7
80009ff2:	e6 07 17 80 	movls	r7,r3
80009ff6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80009ffa:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009ffc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000a000:	ea c4 ff fc 	sub	r4,r5,-4
8000a004:	08 9c       	mov	r12,r4
8000a006:	f0 1f 00 44 	mcall	8000a114 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000a00a:	ea cc ff e8 	sub	r12,r5,-24
8000a00e:	f0 1f 00 42 	mcall	8000a114 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000a012:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000a014:	ee 07 11 08 	rsub	r7,r7,8
8000a018:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000a01a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
8000a01c:	00 9a       	mov	r10,r0
8000a01e:	40 0b       	lddsp	r11,sp[0x0]
8000a020:	0c 9c       	mov	r12,r6
8000a022:	f0 1f 00 3e 	mcall	8000a118 <xTaskGenericCreate+0x19c>
8000a026:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000a028:	58 02       	cp.w	r2,0
8000a02a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000a02e:	f0 1f 00 3c 	mcall	8000a11c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000a032:	4b c8       	lddpc	r8,8000a120 <xTaskGenericCreate+0x1a4>
8000a034:	70 09       	ld.w	r9,r8[0x0]
8000a036:	2f f9       	sub	r9,-1
8000a038:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000a03a:	4b b8       	lddpc	r8,8000a124 <xTaskGenericCreate+0x1a8>
8000a03c:	70 08       	ld.w	r8,r8[0x0]
8000a03e:	58 08       	cp.w	r8,0
8000a040:	c2 61       	brne	8000a08c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000a042:	4b 98       	lddpc	r8,8000a124 <xTaskGenericCreate+0x1a8>
8000a044:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000a046:	4b 78       	lddpc	r8,8000a120 <xTaskGenericCreate+0x1a4>
8000a048:	70 08       	ld.w	r8,r8[0x0]
8000a04a:	58 18       	cp.w	r8,1
8000a04c:	c2 b1       	brne	8000a0a2 <xTaskGenericCreate+0x126>
8000a04e:	4b 77       	lddpc	r7,8000a128 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000a050:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000a054:	0e 9c       	mov	r12,r7
8000a056:	f0 1f 00 36 	mcall	8000a12c <xTaskGenericCreate+0x1b0>
8000a05a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000a05c:	0c 37       	cp.w	r7,r6
8000a05e:	cf b1       	brne	8000a054 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000a060:	4b 47       	lddpc	r7,8000a130 <xTaskGenericCreate+0x1b4>
8000a062:	0e 9c       	mov	r12,r7
8000a064:	f0 1f 00 32 	mcall	8000a12c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000a068:	4b 36       	lddpc	r6,8000a134 <xTaskGenericCreate+0x1b8>
8000a06a:	0c 9c       	mov	r12,r6
8000a06c:	f0 1f 00 30 	mcall	8000a12c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000a070:	4b 2c       	lddpc	r12,8000a138 <xTaskGenericCreate+0x1bc>
8000a072:	f0 1f 00 2f 	mcall	8000a12c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000a076:	4b 2c       	lddpc	r12,8000a13c <xTaskGenericCreate+0x1c0>
8000a078:	f0 1f 00 2d 	mcall	8000a12c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000a07c:	4b 1c       	lddpc	r12,8000a140 <xTaskGenericCreate+0x1c4>
8000a07e:	f0 1f 00 2c 	mcall	8000a12c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000a082:	4b 18       	lddpc	r8,8000a144 <xTaskGenericCreate+0x1c8>
8000a084:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000a086:	4b 18       	lddpc	r8,8000a148 <xTaskGenericCreate+0x1cc>
8000a088:	91 06       	st.w	r8[0x0],r6
8000a08a:	c0 c8       	rjmp	8000a0a2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
8000a08c:	4b 08       	lddpc	r8,8000a14c <xTaskGenericCreate+0x1d0>
8000a08e:	70 08       	ld.w	r8,r8[0x0]
8000a090:	58 08       	cp.w	r8,0
8000a092:	c0 81       	brne	8000a0a2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000a094:	4a 48       	lddpc	r8,8000a124 <xTaskGenericCreate+0x1a8>
8000a096:	70 08       	ld.w	r8,r8[0x0]
8000a098:	70 b8       	ld.w	r8,r8[0x2c]
8000a09a:	10 33       	cp.w	r3,r8
8000a09c:	c0 33       	brcs	8000a0a2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000a09e:	4a 28       	lddpc	r8,8000a124 <xTaskGenericCreate+0x1a8>
8000a0a0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000a0a2:	6a b8       	ld.w	r8,r5[0x2c]
8000a0a4:	4a b9       	lddpc	r9,8000a150 <xTaskGenericCreate+0x1d4>
8000a0a6:	72 09       	ld.w	r9,r9[0x0]
8000a0a8:	12 38       	cp.w	r8,r9
8000a0aa:	e0 88 00 04 	brls	8000a0b2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000a0ae:	4a 99       	lddpc	r9,8000a150 <xTaskGenericCreate+0x1d4>
8000a0b0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000a0b2:	4a 98       	lddpc	r8,8000a154 <xTaskGenericCreate+0x1d8>
8000a0b4:	70 09       	ld.w	r9,r8[0x0]
8000a0b6:	2f f9       	sub	r9,-1
8000a0b8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000a0ba:	6a b8       	ld.w	r8,r5[0x2c]
8000a0bc:	4a 79       	lddpc	r9,8000a158 <xTaskGenericCreate+0x1dc>
8000a0be:	72 09       	ld.w	r9,r9[0x0]
8000a0c0:	12 38       	cp.w	r8,r9
8000a0c2:	e0 88 00 04 	brls	8000a0ca <xTaskGenericCreate+0x14e>
8000a0c6:	4a 59       	lddpc	r9,8000a158 <xTaskGenericCreate+0x1dc>
8000a0c8:	93 08       	st.w	r9[0x0],r8
8000a0ca:	6a bc       	ld.w	r12,r5[0x2c]
8000a0cc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000a0d0:	08 9b       	mov	r11,r4
8000a0d2:	49 68       	lddpc	r8,8000a128 <xTaskGenericCreate+0x1ac>
8000a0d4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000a0d8:	f0 1f 00 21 	mcall	8000a15c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000a0dc:	f0 1f 00 21 	mcall	8000a160 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
8000a0e0:	49 b8       	lddpc	r8,8000a14c <xTaskGenericCreate+0x1d0>
8000a0e2:	70 08       	ld.w	r8,r8[0x0]
8000a0e4:	58 08       	cp.w	r8,0
8000a0e6:	c0 a0       	breq	8000a0fa <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000a0e8:	48 f8       	lddpc	r8,8000a124 <xTaskGenericCreate+0x1a8>
8000a0ea:	70 08       	ld.w	r8,r8[0x0]
8000a0ec:	70 b8       	ld.w	r8,r8[0x2c]
8000a0ee:	10 33       	cp.w	r3,r8
8000a0f0:	e0 88 00 05 	brls	8000a0fa <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
8000a0f4:	d7 33       	scall
8000a0f6:	30 1c       	mov	r12,1
8000a0f8:	c0 28       	rjmp	8000a0fc <xTaskGenericCreate+0x180>
8000a0fa:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000a0fc:	2f fd       	sub	sp,-4
8000a0fe:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000a100:	99 c6       	st.w	r12[0x30],r6
8000a102:	c5 fb       	rjmp	80009fc0 <xTaskGenericCreate+0x44>
8000a104:	80 00       	ld.sh	r0,r0[0x0]
8000a106:	93 fc       	st.w	r9[0x3c],r12
8000a108:	80 00       	ld.sh	r0,r0[0x0]
8000a10a:	93 d4       	st.w	r9[0x34],r4
8000a10c:	80 00       	ld.sh	r0,r0[0x0]
8000a10e:	ae 4e       	st.h	r7[0x8],lr
8000a110:	80 00       	ld.sh	r0,r0[0x0]
8000a112:	b1 a0       	sbr	r0,0x10
8000a114:	80 00       	ld.sh	r0,r0[0x0]
8000a116:	90 80       	ld.uh	r0,r8[0x0]
8000a118:	80 00       	ld.sh	r0,r0[0x0]
8000a11a:	90 fc       	ld.uh	r12,r8[0xe]
8000a11c:	80 00       	ld.sh	r0,r0[0x0]
8000a11e:	91 90       	st.w	r8[0x24],r0
8000a120:	00 00       	add	r0,r0
8000a122:	13 04       	ld.w	r4,r9++
8000a124:	00 00       	add	r0,r0
8000a126:	12 b8       	st.h	r9++,r8
8000a128:	00 00       	add	r0,r0
8000a12a:	12 04       	add	r4,r9
8000a12c:	80 00       	ld.sh	r0,r0[0x0]
8000a12e:	90 6c       	ld.sh	r12,r8[0xc]
8000a130:	00 00       	add	r0,r0
8000a132:	12 d0       	st.w	--r9,r0
8000a134:	00 00       	add	r0,r0
8000a136:	12 ec       	st.h	--r9,r12
8000a138:	00 00       	add	r0,r0
8000a13a:	12 bc       	st.h	r9++,r12
8000a13c:	00 00       	add	r0,r0
8000a13e:	12 a4       	st.w	r9++,r4
8000a140:	00 00       	add	r0,r0
8000a142:	13 0c       	ld.w	r12,r9++
8000a144:	00 00       	add	r0,r0
8000a146:	11 f0       	ld.ub	r0,r8[0x7]
8000a148:	00 00       	add	r0,r0
8000a14a:	12 00       	add	r0,r9
8000a14c:	00 00       	add	r0,r0
8000a14e:	11 f4       	ld.ub	r4,r8[0x7]
8000a150:	00 00       	add	r0,r0
8000a152:	11 ec       	ld.ub	r12,r8[0x6]
8000a154:	00 00       	add	r0,r0
8000a156:	13 00       	ld.w	r0,r9++
8000a158:	00 00       	add	r0,r0
8000a15a:	13 20       	ld.uh	r0,r9++
8000a15c:	80 00       	ld.sh	r0,r0[0x0]
8000a15e:	90 86       	ld.uh	r6,r8[0x0]
8000a160:	80 00       	ld.sh	r0,r0[0x0]
8000a162:	92 9c       	ld.uh	r12,r9[0x2]

8000a164 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000a164:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000a166:	30 09       	mov	r9,0
8000a168:	1a d9       	st.w	--sp,r9
8000a16a:	1a d9       	st.w	--sp,r9
8000a16c:	1a d9       	st.w	--sp,r9
8000a16e:	12 98       	mov	r8,r9
8000a170:	e0 6a 01 00 	mov	r10,256
8000a174:	48 9b       	lddpc	r11,8000a198 <vTaskStartScheduler+0x34>
8000a176:	48 ac       	lddpc	r12,8000a19c <vTaskStartScheduler+0x38>
8000a178:	f0 1f 00 0a 	mcall	8000a1a0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
8000a17c:	2f dd       	sub	sp,-12
8000a17e:	58 1c       	cp.w	r12,1
8000a180:	c0 a1       	brne	8000a194 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000a182:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000a184:	30 19       	mov	r9,1
8000a186:	48 88       	lddpc	r8,8000a1a4 <vTaskStartScheduler+0x40>
8000a188:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000a18a:	30 09       	mov	r9,0
8000a18c:	48 78       	lddpc	r8,8000a1a8 <vTaskStartScheduler+0x44>
8000a18e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
8000a190:	f0 1f 00 07 	mcall	8000a1ac <vTaskStartScheduler+0x48>
8000a194:	d8 02       	popm	pc
8000a196:	00 00       	add	r0,r0
8000a198:	80 01       	ld.sh	r1,r0[0x0]
8000a19a:	99 b0       	st.w	r12[0x2c],r0
8000a19c:	80 00       	ld.sh	r0,r0[0x0]
8000a19e:	9e f4       	ld.uh	r4,pc[0xe]
8000a1a0:	80 00       	ld.sh	r0,r0[0x0]
8000a1a2:	9f 7c       	st.w	pc[0x1c],r12
8000a1a4:	00 00       	add	r0,r0
8000a1a6:	11 f4       	ld.ub	r4,r8[0x7]
8000a1a8:	00 00       	add	r0,r0
8000a1aa:	12 e4       	st.h	--r9,r4
8000a1ac:	80 00       	ld.sh	r0,r0[0x0]
8000a1ae:	91 a0       	st.w	r8[0x28],r0

8000a1b0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
8000a1b0:	16 cc       	st.b	r11++,r12
	return str;
}
8000a1b2:	5e fb       	retal	r11

8000a1b4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
8000a1b4:	eb cd 40 c0 	pushm	r6-r7,lr
8000a1b8:	20 3d       	sub	sp,12
8000a1ba:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000a1bc:	30 06       	mov	r6,0
8000a1be:	30 07       	mov	r7,0
8000a1c0:	fa e7 00 00 	st.d	sp[0],r6
8000a1c4:	30 0c       	mov	r12,0
8000a1c6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000a1c8:	58 08       	cp.w	r8,0
8000a1ca:	c1 30       	breq	8000a1f0 <PrintHex+0x3c>
8000a1cc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000a1ce:	1a 9c       	mov	r12,sp
8000a1d0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000a1d4:	58 9e       	cp.w	lr,9
8000a1d6:	e0 8a 00 04 	brle	8000a1de <PrintHex+0x2a>
8000a1da:	2c 9e       	sub	lr,-55
8000a1dc:	c0 48       	rjmp	8000a1e4 <PrintHex+0x30>
8000a1de:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000a1e2:	2d 0e       	sub	lr,-48
8000a1e4:	f8 09 0b 0e 	st.b	r12[r9],lr
8000a1e8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000a1ea:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000a1ec:	cf 21       	brne	8000a1d0 <PrintHex+0x1c>
8000a1ee:	c0 48       	rjmp	8000a1f6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
8000a1f0:	33 08       	mov	r8,48
8000a1f2:	ba 88       	st.b	sp[0x0],r8
8000a1f4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000a1f6:	f6 09 01 08 	sub	r8,r11,r9
8000a1fa:	58 08       	cp.w	r8,0
8000a1fc:	e0 8a 00 13 	brle	8000a222 <PrintHex+0x6e>
	{
		char num = len - cnt;
8000a200:	12 1b       	sub	r11,r9
8000a202:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000a206:	18 9e       	mov	lr,r12
8000a208:	58 0c       	cp.w	r12,0
8000a20a:	e0 8a 00 0c 	brle	8000a222 <PrintHex+0x6e>
8000a20e:	1a 9b       	mov	r11,sp
8000a210:	12 0b       	add	r11,r9
8000a212:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000a214:	33 07       	mov	r7,48
8000a216:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000a218:	2f f8       	sub	r8,-1
8000a21a:	1c 38       	cp.w	r8,lr
8000a21c:	cf d5       	brlt	8000a216 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000a21e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000a222:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000a226:	f0 cb ff ff 	sub	r11,r8,-1
8000a22a:	58 0b       	cp.w	r11,0
8000a22c:	e0 8a 00 19 	brle	8000a25e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000a230:	fa cb ff f4 	sub	r11,sp,-12
8000a234:	f6 09 00 09 	add	r9,r11,r9
8000a238:	37 8b       	mov	r11,120
8000a23a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000a23e:	fa c9 ff f4 	sub	r9,sp,-12
8000a242:	10 09       	add	r9,r8
8000a244:	33 0b       	mov	r11,48
8000a246:	f3 6b ff f4 	st.b	r9[-12],r11
8000a24a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000a24e:	fa ce 00 01 	sub	lr,sp,1
8000a252:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000a254:	11 8b       	ld.ub	r11,r8[0x0]
8000a256:	12 cb       	st.b	r9++,r11
8000a258:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000a25a:	1c 38       	cp.w	r8,lr
8000a25c:	cf c1       	brne	8000a254 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000a25e:	14 9c       	mov	r12,r10
8000a260:	2f dd       	sub	sp,-12
8000a262:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000a266 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000a266:	d4 21       	pushm	r4-r7,lr
8000a268:	20 3d       	sub	sp,12
8000a26a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000a26c:	30 06       	mov	r6,0
8000a26e:	30 07       	mov	r7,0
8000a270:	fa e7 00 00 	st.d	sp[0],r6
8000a274:	30 0c       	mov	r12,0
8000a276:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000a278:	58 08       	cp.w	r8,0
8000a27a:	c0 35       	brlt	8000a280 <PrintDec+0x1a>
8000a27c:	14 97       	mov	r7,r10
8000a27e:	c0 58       	rjmp	8000a288 <PrintDec+0x22>
	{
		*p++ = '-';
8000a280:	14 97       	mov	r7,r10
8000a282:	32 d9       	mov	r9,45
8000a284:	0e c9       	st.b	r7++,r9
		i = -i;
8000a286:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000a288:	58 08       	cp.w	r8,0
8000a28a:	c0 51       	brne	8000a294 <PrintDec+0x2e>
8000a28c:	33 08       	mov	r8,48
8000a28e:	ba 88       	st.b	sp[0x0],r8
8000a290:	30 1e       	mov	lr,1
8000a292:	c2 f8       	rjmp	8000a2f0 <PrintDec+0x8a>
	
	int ten = i%10;
8000a294:	e0 65 66 67 	mov	r5,26215
8000a298:	ea 15 66 66 	orh	r5,0x6666
8000a29c:	f0 05 04 44 	muls.d	r4,r8,r5
8000a2a0:	ea 0c 14 02 	asr	r12,r5,0x2
8000a2a4:	f0 09 14 1f 	asr	r9,r8,0x1f
8000a2a8:	f8 09 01 09 	sub	r9,r12,r9
8000a2ac:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000a2b0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
8000a2b4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000a2b6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000a2b8:	e0 66 66 67 	mov	r6,26215
8000a2bc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
8000a2c0:	2d 09       	sub	r9,-48
8000a2c2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000a2c6:	2f fe       	sub	lr,-1
		i /= 10;
8000a2c8:	f0 06 04 44 	muls.d	r4,r8,r6
8000a2cc:	ea 09 14 02 	asr	r9,r5,0x2
8000a2d0:	bf 58       	asr	r8,0x1f
8000a2d2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000a2d6:	f0 06 04 44 	muls.d	r4,r8,r6
8000a2da:	ea 09 14 02 	asr	r9,r5,0x2
8000a2de:	f0 05 14 1f 	asr	r5,r8,0x1f
8000a2e2:	0a 19       	sub	r9,r5
8000a2e4:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000a2e8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000a2ec:	58 08       	cp.w	r8,0
8000a2ee:	ce 91       	brne	8000a2c0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
8000a2f0:	f6 0e 01 08 	sub	r8,r11,lr
8000a2f4:	58 08       	cp.w	r8,0
8000a2f6:	e0 89 00 06 	brgt	8000a302 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000a2fa:	58 0e       	cp.w	lr,0
8000a2fc:	e0 89 00 14 	brgt	8000a324 <PrintDec+0xbe>
8000a300:	c1 d8       	rjmp	8000a33a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000a302:	1c 1b       	sub	r11,lr
8000a304:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000a306:	16 9c       	mov	r12,r11
8000a308:	58 0b       	cp.w	r11,0
8000a30a:	fe 9a ff f8 	brle	8000a2fa <PrintDec+0x94>
8000a30e:	1a 99       	mov	r9,sp
8000a310:	1c 09       	add	r9,lr
8000a312:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000a314:	33 06       	mov	r6,48
8000a316:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000a318:	2f f8       	sub	r8,-1
8000a31a:	18 38       	cp.w	r8,r12
8000a31c:	cf d5       	brlt	8000a316 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000a31e:	f6 0e 00 0e 	add	lr,r11,lr
8000a322:	ce cb       	rjmp	8000a2fa <PrintDec+0x94>
8000a324:	fa c8 ff f4 	sub	r8,sp,-12
8000a328:	1c 08       	add	r8,lr
8000a32a:	20 d8       	sub	r8,13
8000a32c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
8000a330:	11 89       	ld.ub	r9,r8[0x0]
8000a332:	0e c9       	st.b	r7++,r9
8000a334:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000a336:	16 38       	cp.w	r8,r11
8000a338:	cf c1       	brne	8000a330 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000a33a:	14 9c       	mov	r12,r10
8000a33c:	2f dd       	sub	sp,-12
8000a33e:	d8 22       	popm	r4-r7,pc

8000a340 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
8000a340:	d4 31       	pushm	r0-r7,lr
8000a342:	fa cd 02 08 	sub	sp,sp,520
8000a346:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000a348:	e0 6a 01 00 	mov	r10,256
8000a34c:	30 0b       	mov	r11,0
8000a34e:	fa cc fe f8 	sub	r12,sp,-264
8000a352:	f0 1f 00 4e 	mcall	8000a488 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000a356:	fa c4 fd d4 	sub	r4,sp,-556
8000a35a:	30 0a       	mov	r10,0
8000a35c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a35e:	fa c3 ff fc 	sub	r3,sp,-4
8000a362:	e0 61 01 00 	mov	r1,256
8000a366:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000a368:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a36a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a36e:	02 9a       	mov	r10,r1
8000a370:	00 9b       	mov	r11,r0
8000a372:	06 9c       	mov	r12,r3
8000a374:	f0 1f 00 45 	mcall	8000a488 <log+0x148>
			
					if(*str == '%')
8000a378:	0f 88       	ld.ub	r8,r7[0x0]
8000a37a:	e4 08 18 00 	cp.b	r8,r2
8000a37e:	c5 71       	brne	8000a42c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
8000a380:	ee c8 ff ff 	sub	r8,r7,-1
8000a384:	11 89       	ld.ub	r9,r8[0x0]
8000a386:	4c 2a       	lddpc	r10,8000a48c <log+0x14c>
8000a388:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000a38a:	23 09       	sub	r9,48
8000a38c:	30 9a       	mov	r10,9
8000a38e:	f4 09 18 00 	cp.b	r9,r10
8000a392:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000a396:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000a39a:	f7 b9 08 30 	subls	r9,48
8000a39e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000a3a2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000a3a6:	0f 88       	ld.ub	r8,r7[0x0]
8000a3a8:	22 58       	sub	r8,37
8000a3aa:	e0 48 00 53 	cp.w	r8,83
8000a3ae:	e0 8b 00 31 	brhi	8000a410 <log+0xd0>
8000a3b2:	4b 89       	lddpc	r9,8000a490 <log+0x150>
8000a3b4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000a3b8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000a3bc:	06 9a       	mov	r10,r3
8000a3be:	40 0b       	lddsp	r11,sp[0x0]
8000a3c0:	5c 5b       	castu.b	r11
8000a3c2:	68 0c       	ld.w	r12,r4[0x0]
8000a3c4:	f0 1f 00 34 	mcall	8000a494 <log+0x154>
							break;
8000a3c8:	c2 98       	rjmp	8000a41a <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000a3ca:	4b 4c       	lddpc	r12,8000a498 <log+0x158>
8000a3cc:	f0 1f 00 34 	mcall	8000a49c <log+0x15c>
8000a3d0:	08 95       	mov	r5,r4
8000a3d2:	06 9c       	mov	r12,r3
							break;
8000a3d4:	c2 38       	rjmp	8000a41a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000a3d6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000a3da:	06 9a       	mov	r10,r3
8000a3dc:	40 0b       	lddsp	r11,sp[0x0]
8000a3de:	5c 5b       	castu.b	r11
8000a3e0:	68 0c       	ld.w	r12,r4[0x0]
8000a3e2:	f0 1f 00 30 	mcall	8000a4a0 <log+0x160>
8000a3e6:	06 9c       	mov	r12,r3
							break;
8000a3e8:	c1 98       	rjmp	8000a41a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000a3ea:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000a3ee:	06 9b       	mov	r11,r3
8000a3f0:	09 bc       	ld.ub	r12,r4[0x3]
8000a3f2:	f0 1f 00 2d 	mcall	8000a4a4 <log+0x164>
8000a3f6:	06 9c       	mov	r12,r3
							break;
8000a3f8:	c1 18       	rjmp	8000a41a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000a3fa:	e8 c5 ff fc 	sub	r5,r4,-4
8000a3fe:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000a400:	c0 d8       	rjmp	8000a41a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000a402:	06 9b       	mov	r11,r3
8000a404:	32 5c       	mov	r12,37
8000a406:	f0 1f 00 28 	mcall	8000a4a4 <log+0x164>
8000a40a:	08 95       	mov	r5,r4
8000a40c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000a40e:	c0 68       	rjmp	8000a41a <log+0xda>
							
							default:
							log("I need relax.");
8000a410:	4a 6c       	lddpc	r12,8000a4a8 <log+0x168>
8000a412:	f0 1f 00 23 	mcall	8000a49c <log+0x15c>
8000a416:	08 95       	mov	r5,r4
8000a418:	06 9c       	mov	r12,r3
						}
						str++;
8000a41a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a41c:	1a dc       	st.w	--sp,r12
8000a41e:	1a d6       	st.w	--sp,r6
8000a420:	4a 3b       	lddpc	r11,8000a4ac <log+0x16c>
8000a422:	0c 9c       	mov	r12,r6
8000a424:	f0 1f 00 23 	mcall	8000a4b0 <log+0x170>
8000a428:	2f ed       	sub	sp,-8
8000a42a:	c0 a8       	rjmp	8000a43e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a42c:	2f f7       	sub	r7,-1
8000a42e:	1a d8       	st.w	--sp,r8
8000a430:	1a d6       	st.w	--sp,r6
8000a432:	4a 1b       	lddpc	r11,8000a4b4 <log+0x174>
8000a434:	0c 9c       	mov	r12,r6
8000a436:	f0 1f 00 1f 	mcall	8000a4b0 <log+0x170>
8000a43a:	08 95       	mov	r5,r4
8000a43c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000a43e:	0f 89       	ld.ub	r9,r7[0x0]
8000a440:	30 08       	mov	r8,0
8000a442:	f0 09 18 00 	cp.b	r9,r8
8000a446:	c0 30       	breq	8000a44c <log+0x10c>
8000a448:	0a 94       	mov	r4,r5
8000a44a:	c9 2b       	rjmp	8000a36e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000a44c:	fa c7 fe f8 	sub	r7,sp,-264
8000a450:	1a d7       	st.w	--sp,r7
8000a452:	49 ab       	lddpc	r11,8000a4b8 <log+0x178>
8000a454:	0e 9c       	mov	r12,r7
8000a456:	f0 1f 00 17 	mcall	8000a4b0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000a45a:	5c 5c       	castu.b	r12
8000a45c:	f8 c6 ff ff 	sub	r6,r12,-1
8000a460:	0c 9c       	mov	r12,r6
8000a462:	f0 1f 00 17 	mcall	8000a4bc <log+0x17c>
8000a466:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000a468:	0c 9a       	mov	r10,r6
8000a46a:	0e 9b       	mov	r11,r7
8000a46c:	f0 1f 00 15 	mcall	8000a4c0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
8000a470:	30 09       	mov	r9,0
8000a472:	30 5a       	mov	r10,5
8000a474:	fa cb fe f8 	sub	r11,sp,-264
8000a478:	49 38       	lddpc	r8,8000a4c4 <log+0x184>
8000a47a:	70 0c       	ld.w	r12,r8[0x0]
8000a47c:	f0 1f 00 13 	mcall	8000a4c8 <log+0x188>
8000a480:	2f fd       	sub	sp,-4
}
8000a482:	fe 3d fd f8 	sub	sp,-520
8000a486:	d8 32       	popm	r0-r7,pc
8000a488:	80 00       	ld.sh	r0,r0[0x0]
8000a48a:	ae 4e       	st.h	r7[0x8],lr
8000a48c:	00 00       	add	r0,r0
8000a48e:	13 24       	ld.uh	r4,r9++
8000a490:	80 01       	ld.sh	r1,r0[0x0]
8000a492:	99 b8       	st.w	r12[0x2c],r8
8000a494:	80 00       	ld.sh	r0,r0[0x0]
8000a496:	a2 66       	st.h	r1[0xc],r6
8000a498:	80 01       	ld.sh	r1,r0[0x0]
8000a49a:	9c 64       	ld.sh	r4,lr[0xc]
8000a49c:	80 00       	ld.sh	r0,r0[0x0]
8000a49e:	a3 40       	asr	r0,0x2
8000a4a0:	80 00       	ld.sh	r0,r0[0x0]
8000a4a2:	a1 b4       	sbr	r4,0x1
8000a4a4:	80 00       	ld.sh	r0,r0[0x0]
8000a4a6:	a1 b0       	sbr	r0,0x1
8000a4a8:	80 01       	ld.sh	r1,r0[0x0]
8000a4aa:	9c 74       	ld.sh	r4,lr[0xe]
8000a4ac:	80 01       	ld.sh	r1,r0[0x0]
8000a4ae:	9c 84       	ld.uh	r4,lr[0x0]
8000a4b0:	80 00       	ld.sh	r0,r0[0x0]
8000a4b2:	b1 3c       	mul	r12,r8
8000a4b4:	80 01       	ld.sh	r1,r0[0x0]
8000a4b6:	9c 8c       	ld.uh	r12,lr[0x0]
8000a4b8:	80 01       	ld.sh	r1,r0[0x0]
8000a4ba:	9c 94       	ld.uh	r4,lr[0x2]
8000a4bc:	80 00       	ld.sh	r0,r0[0x0]
8000a4be:	93 fc       	st.w	r9[0x3c],r12
8000a4c0:	80 00       	ld.sh	r0,r0[0x0]
8000a4c2:	ad 06       	ld.d	r6,r6
8000a4c4:	00 00       	add	r0,r0
8000a4c6:	46 c4       	lddsp	r4,sp[0x1b0]
8000a4c8:	80 00       	ld.sh	r0,r0[0x0]
8000a4ca:	97 50       	st.w	r11[0x14],r0

8000a4cc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000a4cc:	d4 31       	pushm	r0-r7,lr
8000a4ce:	fa cd 02 0c 	sub	sp,sp,524
8000a4d2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000a4d4:	e0 6a 01 00 	mov	r10,256
8000a4d8:	30 0b       	mov	r11,0
8000a4da:	fa cc fe f4 	sub	r12,sp,-268
8000a4de:	f0 1f 00 4c 	mcall	8000a60c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
8000a4e2:	fa c4 fd d0 	sub	r4,sp,-560
8000a4e6:	30 0a       	mov	r10,0
8000a4e8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a4ea:	fa c3 ff fc 	sub	r3,sp,-4
8000a4ee:	e0 61 01 00 	mov	r1,256
8000a4f2:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000a4f4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a4f6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a4fa:	02 9a       	mov	r10,r1
8000a4fc:	00 9b       	mov	r11,r0
8000a4fe:	06 9c       	mov	r12,r3
8000a500:	f0 1f 00 43 	mcall	8000a60c <logFromISR+0x140>
			
			if(*str == '%')
8000a504:	0f 88       	ld.ub	r8,r7[0x0]
8000a506:	e4 08 18 00 	cp.b	r8,r2
8000a50a:	c5 11       	brne	8000a5ac <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000a50c:	ee c8 ff ff 	sub	r8,r7,-1
8000a510:	11 89       	ld.ub	r9,r8[0x0]
8000a512:	4c 0a       	lddpc	r10,8000a610 <logFromISR+0x144>
8000a514:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000a516:	23 09       	sub	r9,48
8000a518:	30 9a       	mov	r10,9
8000a51a:	f4 09 18 00 	cp.b	r9,r10
8000a51e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000a522:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000a526:	f7 b9 08 30 	subls	r9,48
8000a52a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000a52e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000a532:	0f 88       	ld.ub	r8,r7[0x0]
8000a534:	22 58       	sub	r8,37
8000a536:	e0 48 00 53 	cp.w	r8,83
8000a53a:	e0 8b 00 2b 	brhi	8000a590 <logFromISR+0xc4>
8000a53e:	4b 69       	lddpc	r9,8000a614 <logFromISR+0x148>
8000a540:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000a544:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000a548:	06 9a       	mov	r10,r3
8000a54a:	40 0b       	lddsp	r11,sp[0x0]
8000a54c:	5c 5b       	castu.b	r11
8000a54e:	68 0c       	ld.w	r12,r4[0x0]
8000a550:	f0 1f 00 32 	mcall	8000a618 <logFromISR+0x14c>
					break;
8000a554:	c2 38       	rjmp	8000a59a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000a556:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000a55a:	06 9a       	mov	r10,r3
8000a55c:	40 0b       	lddsp	r11,sp[0x0]
8000a55e:	5c 5b       	castu.b	r11
8000a560:	68 0c       	ld.w	r12,r4[0x0]
8000a562:	f0 1f 00 2f 	mcall	8000a61c <logFromISR+0x150>
8000a566:	06 9c       	mov	r12,r3
					break;
8000a568:	c1 98       	rjmp	8000a59a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000a56a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000a56e:	06 9b       	mov	r11,r3
8000a570:	09 bc       	ld.ub	r12,r4[0x3]
8000a572:	f0 1f 00 2c 	mcall	8000a620 <logFromISR+0x154>
8000a576:	06 9c       	mov	r12,r3
					break;
8000a578:	c1 18       	rjmp	8000a59a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000a57a:	e8 c5 ff fc 	sub	r5,r4,-4
8000a57e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000a580:	c0 d8       	rjmp	8000a59a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000a582:	06 9b       	mov	r11,r3
8000a584:	32 5c       	mov	r12,37
8000a586:	f0 1f 00 27 	mcall	8000a620 <logFromISR+0x154>
8000a58a:	08 95       	mov	r5,r4
8000a58c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000a58e:	c0 68       	rjmp	8000a59a <logFromISR+0xce>
					default:
					log("I need relax.");
8000a590:	4a 5c       	lddpc	r12,8000a624 <logFromISR+0x158>
8000a592:	f0 1f 00 26 	mcall	8000a628 <logFromISR+0x15c>
8000a596:	08 95       	mov	r5,r4
8000a598:	06 9c       	mov	r12,r3
				}
				str++;
8000a59a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a59c:	1a dc       	st.w	--sp,r12
8000a59e:	1a d6       	st.w	--sp,r6
8000a5a0:	4a 3b       	lddpc	r11,8000a62c <logFromISR+0x160>
8000a5a2:	0c 9c       	mov	r12,r6
8000a5a4:	f0 1f 00 23 	mcall	8000a630 <logFromISR+0x164>
8000a5a8:	2f ed       	sub	sp,-8
8000a5aa:	c0 a8       	rjmp	8000a5be <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a5ac:	2f f7       	sub	r7,-1
8000a5ae:	1a d8       	st.w	--sp,r8
8000a5b0:	1a d6       	st.w	--sp,r6
8000a5b2:	4a 1b       	lddpc	r11,8000a634 <logFromISR+0x168>
8000a5b4:	0c 9c       	mov	r12,r6
8000a5b6:	f0 1f 00 1f 	mcall	8000a630 <logFromISR+0x164>
8000a5ba:	08 95       	mov	r5,r4
8000a5bc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000a5be:	0f 89       	ld.ub	r9,r7[0x0]
8000a5c0:	30 08       	mov	r8,0
8000a5c2:	f0 09 18 00 	cp.b	r9,r8
8000a5c6:	c0 30       	breq	8000a5cc <logFromISR+0x100>
8000a5c8:	0a 94       	mov	r4,r5
8000a5ca:	c9 8b       	rjmp	8000a4fa <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000a5cc:	fa c7 fe f4 	sub	r7,sp,-268
8000a5d0:	1a d7       	st.w	--sp,r7
8000a5d2:	49 ab       	lddpc	r11,8000a638 <logFromISR+0x16c>
8000a5d4:	0e 9c       	mov	r12,r7
8000a5d6:	f0 1f 00 17 	mcall	8000a630 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000a5da:	5c 5c       	castu.b	r12
8000a5dc:	f8 c6 ff ff 	sub	r6,r12,-1
8000a5e0:	0c 9c       	mov	r12,r6
8000a5e2:	f0 1f 00 17 	mcall	8000a63c <logFromISR+0x170>
8000a5e6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000a5e8:	0c 9a       	mov	r10,r6
8000a5ea:	0e 9b       	mov	r11,r7
8000a5ec:	f0 1f 00 15 	mcall	8000a640 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000a5f0:	30 09       	mov	r9,0
8000a5f2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000a5f4:	fa ca fe f8 	sub	r10,sp,-264
8000a5f8:	fa cb fe f4 	sub	r11,sp,-268
8000a5fc:	49 28       	lddpc	r8,8000a644 <logFromISR+0x178>
8000a5fe:	70 0c       	ld.w	r12,r8[0x0]
8000a600:	f0 1f 00 12 	mcall	8000a648 <logFromISR+0x17c>
8000a604:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000a606:	fe 3d fd f4 	sub	sp,-524
8000a60a:	d8 32       	popm	r0-r7,pc
8000a60c:	80 00       	ld.sh	r0,r0[0x0]
8000a60e:	ae 4e       	st.h	r7[0x8],lr
8000a610:	00 00       	add	r0,r0
8000a612:	13 25       	ld.uh	r5,r9++
8000a614:	80 01       	ld.sh	r1,r0[0x0]
8000a616:	9b 08       	st.w	sp[0x0],r8
8000a618:	80 00       	ld.sh	r0,r0[0x0]
8000a61a:	a2 66       	st.h	r1[0xc],r6
8000a61c:	80 00       	ld.sh	r0,r0[0x0]
8000a61e:	a1 b4       	sbr	r4,0x1
8000a620:	80 00       	ld.sh	r0,r0[0x0]
8000a622:	a1 b0       	sbr	r0,0x1
8000a624:	80 01       	ld.sh	r1,r0[0x0]
8000a626:	9c 74       	ld.sh	r4,lr[0xe]
8000a628:	80 00       	ld.sh	r0,r0[0x0]
8000a62a:	a3 40       	asr	r0,0x2
8000a62c:	80 01       	ld.sh	r1,r0[0x0]
8000a62e:	9c 84       	ld.uh	r4,lr[0x0]
8000a630:	80 00       	ld.sh	r0,r0[0x0]
8000a632:	b1 3c       	mul	r12,r8
8000a634:	80 01       	ld.sh	r1,r0[0x0]
8000a636:	9c 8c       	ld.uh	r12,lr[0x0]
8000a638:	80 01       	ld.sh	r1,r0[0x0]
8000a63a:	9c 94       	ld.uh	r4,lr[0x2]
8000a63c:	80 00       	ld.sh	r0,r0[0x0]
8000a63e:	93 fc       	st.w	r9[0x3c],r12
8000a640:	80 00       	ld.sh	r0,r0[0x0]
8000a642:	ad 06       	ld.d	r6,r6
8000a644:	00 00       	add	r0,r0
8000a646:	46 c4       	lddsp	r4,sp[0x1b0]
8000a648:	80 00       	ld.sh	r0,r0[0x0]
8000a64a:	97 00       	st.w	r11[0x0],r0

8000a64c <log_init>:
		
	return str;
}

void log_init(void)
{
8000a64c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000a64e:	30 2b       	mov	r11,2
8000a650:	49 0c       	lddpc	r12,8000a690 <log_init+0x44>
8000a652:	f0 1f 00 11 	mcall	8000a694 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000a656:	e0 6a 36 00 	mov	r10,13824
8000a65a:	ea 1a 01 6e 	orh	r10,0x16e
8000a65e:	48 fb       	lddpc	r11,8000a698 <log_init+0x4c>
8000a660:	fe 7c 18 00 	mov	r12,-59392
8000a664:	f0 1f 00 0e 	mcall	8000a69c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000a668:	30 4b       	mov	r11,4
8000a66a:	33 2c       	mov	r12,50
8000a66c:	f0 1f 00 0d 	mcall	8000a6a0 <log_init+0x54>
8000a670:	48 d8       	lddpc	r8,8000a6a4 <log_init+0x58>
8000a672:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000a674:	30 09       	mov	r9,0
8000a676:	1a d9       	st.w	--sp,r9
8000a678:	1a d9       	st.w	--sp,r9
8000a67a:	1a d9       	st.w	--sp,r9
8000a67c:	30 28       	mov	r8,2
8000a67e:	e0 6a 01 80 	mov	r10,384
8000a682:	48 ab       	lddpc	r11,8000a6a8 <log_init+0x5c>
8000a684:	48 ac       	lddpc	r12,8000a6ac <log_init+0x60>
8000a686:	f0 1f 00 0b 	mcall	8000a6b0 <log_init+0x64>
8000a68a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000a68c:	d8 02       	popm	pc
8000a68e:	00 00       	add	r0,r0
8000a690:	80 01       	ld.sh	r1,r0[0x0]
8000a692:	9c a0       	ld.uh	r0,lr[0x4]
8000a694:	80 00       	ld.sh	r0,r0[0x0]
8000a696:	a7 e0       	*unknown*
8000a698:	80 01       	ld.sh	r1,r0[0x0]
8000a69a:	9c 58       	ld.sh	r8,lr[0xa]
8000a69c:	80 00       	ld.sh	r0,r0[0x0]
8000a69e:	68 2c       	ld.w	r12,r4[0x8]
8000a6a0:	80 00       	ld.sh	r0,r0[0x0]
8000a6a2:	98 a8       	ld.uh	r8,r12[0x4]
8000a6a4:	00 00       	add	r0,r0
8000a6a6:	46 c4       	lddsp	r4,sp[0x1b0]
8000a6a8:	80 01       	ld.sh	r1,r0[0x0]
8000a6aa:	9c 9c       	ld.uh	r12,lr[0x2]
8000a6ac:	80 00       	ld.sh	r0,r0[0x0]
8000a6ae:	a6 b4       	st.b	r3[0x3],r4
8000a6b0:	80 00       	ld.sh	r0,r0[0x0]
8000a6b2:	9f 7c       	st.w	pc[0x1c],r12

8000a6b4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000a6b4:	eb cd 40 f8 	pushm	r3-r7,lr
8000a6b8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a6ba:	48 c7       	lddpc	r7,8000a6e8 <task_log+0x34>
8000a6bc:	30 05       	mov	r5,0
8000a6be:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000a6c0:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a6c4:	0a 99       	mov	r9,r5
8000a6c6:	08 9a       	mov	r10,r4
8000a6c8:	1a 9b       	mov	r11,sp
8000a6ca:	6e 0c       	ld.w	r12,r7[0x0]
8000a6cc:	f0 1f 00 08 	mcall	8000a6ec <task_log+0x38>
8000a6d0:	58 1c       	cp.w	r12,1
8000a6d2:	cf 91       	brne	8000a6c4 <task_log+0x10>
		{
			if( NULL != str)
8000a6d4:	40 0b       	lddsp	r11,sp[0x0]
8000a6d6:	58 0b       	cp.w	r11,0
8000a6d8:	cf 60       	breq	8000a6c4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000a6da:	06 9c       	mov	r12,r3
8000a6dc:	f0 1f 00 05 	mcall	8000a6f0 <task_log+0x3c>
				vPortFree(str);
8000a6e0:	40 0c       	lddsp	r12,sp[0x0]
8000a6e2:	f0 1f 00 05 	mcall	8000a6f4 <task_log+0x40>
8000a6e6:	ce fb       	rjmp	8000a6c4 <task_log+0x10>
8000a6e8:	00 00       	add	r0,r0
8000a6ea:	46 c4       	lddsp	r4,sp[0x1b0]
8000a6ec:	80 00       	ld.sh	r0,r0[0x0]
8000a6ee:	95 44       	st.w	r10[0x10],r4
8000a6f0:	80 00       	ld.sh	r0,r0[0x0]
8000a6f2:	67 dc       	ld.w	r12,r3[0x74]
8000a6f4:	80 00       	ld.sh	r0,r0[0x0]
8000a6f6:	93 d4       	st.w	r9[0x34],r4

8000a6f8 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
8000a6f8:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000a6fa:	fe 78 10 00 	mov	r8,-61440
8000a6fe:	30 19       	mov	r9,1
8000a700:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000a704:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000a708:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000a70c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000a70e:	f0 1f 00 14 	mcall	8000a75c <main+0x64>
		
	INTC_init_interrupts();
8000a712:	f0 1f 00 14 	mcall	8000a760 <main+0x68>
	
	log_init();		
8000a716:	f0 1f 00 14 	mcall	8000a764 <main+0x6c>
	log("----start debug----");	
8000a71a:	49 4c       	lddpc	r12,8000a768 <main+0x70>
8000a71c:	f0 1f 00 14 	mcall	8000a76c <main+0x74>
		
	rtc_init();
8000a720:	f0 1f 00 14 	mcall	8000a770 <main+0x78>
	
	fs_init();//65795
8000a724:	f0 1f 00 14 	mcall	8000a774 <main+0x7c>

	tc_init();	
8000a728:	f0 1f 00 14 	mcall	8000a778 <main+0x80>
			
	xcmp_init();
8000a72c:	f0 1f 00 14 	mcall	8000a77c <main+0x84>
	
	app_init();
8000a730:	f0 1f 00 14 	mcall	8000a780 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000a734:	fe 79 10 00 	mov	r9,-61440
8000a738:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a73c:	e2 18 00 02 	andl	r8,0x2,COH
8000a740:	cf c0       	breq	8000a738 <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000a742:	fe 79 10 00 	mov	r9,-61440
8000a746:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a74a:	e2 18 00 02 	andl	r8,0x2,COH
8000a74e:	cf c1       	brne	8000a746 <main+0x4e>
	local_start_timer();
8000a750:	f0 1f 00 0d 	mcall	8000a784 <main+0x8c>
	
	Enable_global_interrupt();
8000a754:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000a756:	f0 1f 00 0d 	mcall	8000a788 <main+0x90>
	return 0;
}
8000a75a:	d8 0a       	popm	pc,r12=0
8000a75c:	80 00       	ld.sh	r0,r0[0x0]
8000a75e:	5d a4       	*unknown*
8000a760:	80 00       	ld.sh	r0,r0[0x0]
8000a762:	61 3c       	ld.w	r12,r0[0x4c]
8000a764:	80 00       	ld.sh	r0,r0[0x0]
8000a766:	a6 4c       	st.h	r3[0x8],r12
8000a768:	80 01       	ld.sh	r1,r0[0x0]
8000a76a:	9c b0       	ld.uh	r0,lr[0x6]
8000a76c:	80 00       	ld.sh	r0,r0[0x0]
8000a76e:	a3 40       	asr	r0,0x2
8000a770:	80 00       	ld.sh	r0,r0[0x0]
8000a772:	5f 70       	srpl	r0
8000a774:	80 00       	ld.sh	r0,r0[0x0]
8000a776:	3a 78       	mov	r8,-89
8000a778:	80 00       	ld.sh	r0,r0[0x0]
8000a77a:	60 38       	ld.w	r8,r0[0xc]
8000a77c:	80 00       	ld.sh	r0,r0[0x0]
8000a77e:	56 a8       	stdsp	sp[0x1a8],r8
8000a780:	80 00       	ld.sh	r0,r0[0x0]
8000a782:	20 48       	sub	r8,4
8000a784:	80 00       	ld.sh	r0,r0[0x0]
8000a786:	5f fc       	sral	r12
8000a788:	80 00       	ld.sh	r0,r0[0x0]
8000a78a:	a1 64       	lsl	r4,0x0

8000a78c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a78c:	f8 08 16 05 	lsr	r8,r12,0x5
8000a790:	a9 68       	lsl	r8,0x8
8000a792:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000a796:	58 1b       	cp.w	r11,1
8000a798:	c0 d0       	breq	8000a7b2 <gpio_enable_module_pin+0x26>
8000a79a:	c0 63       	brcs	8000a7a6 <gpio_enable_module_pin+0x1a>
8000a79c:	58 2b       	cp.w	r11,2
8000a79e:	c1 00       	breq	8000a7be <gpio_enable_module_pin+0x32>
8000a7a0:	58 3b       	cp.w	r11,3
8000a7a2:	c1 40       	breq	8000a7ca <gpio_enable_module_pin+0x3e>
8000a7a4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a7a6:	30 19       	mov	r9,1
8000a7a8:	f2 0c 09 49 	lsl	r9,r9,r12
8000a7ac:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a7ae:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a7b0:	c1 28       	rjmp	8000a7d4 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a7b2:	30 19       	mov	r9,1
8000a7b4:	f2 0c 09 49 	lsl	r9,r9,r12
8000a7b8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a7ba:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a7bc:	c0 c8       	rjmp	8000a7d4 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a7be:	30 19       	mov	r9,1
8000a7c0:	f2 0c 09 49 	lsl	r9,r9,r12
8000a7c4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a7c6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a7c8:	c0 68       	rjmp	8000a7d4 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a7ca:	30 19       	mov	r9,1
8000a7cc:	f2 0c 09 49 	lsl	r9,r9,r12
8000a7d0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a7d2:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000a7d4:	30 19       	mov	r9,1
8000a7d6:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a7da:	91 2c       	st.w	r8[0x8],r12
8000a7dc:	5e fd       	retal	0
8000a7de:	d7 03       	nop

8000a7e0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000a7e0:	d4 21       	pushm	r4-r7,lr
8000a7e2:	18 97       	mov	r7,r12
8000a7e4:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a7e6:	58 0b       	cp.w	r11,0
8000a7e8:	c0 31       	brne	8000a7ee <gpio_enable_module+0xe>
8000a7ea:	30 05       	mov	r5,0
8000a7ec:	c0 d8       	rjmp	8000a806 <gpio_enable_module+0x26>
8000a7ee:	30 06       	mov	r6,0
8000a7f0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000a7f2:	6e 1b       	ld.w	r11,r7[0x4]
8000a7f4:	6e 0c       	ld.w	r12,r7[0x0]
8000a7f6:	f0 1f 00 06 	mcall	8000a80c <gpio_enable_module+0x2c>
8000a7fa:	18 45       	or	r5,r12
		gpiomap++;
8000a7fc:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a7fe:	2f f6       	sub	r6,-1
8000a800:	0c 34       	cp.w	r4,r6
8000a802:	fe 9b ff f8 	brhi	8000a7f2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000a806:	0a 9c       	mov	r12,r5
8000a808:	d8 22       	popm	r4-r7,pc
8000a80a:	00 00       	add	r0,r0
8000a80c:	80 00       	ld.sh	r0,r0[0x0]
8000a80e:	a7 8c       	lsr	r12,0x6

8000a810 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a810:	f8 08 16 05 	lsr	r8,r12,0x5
8000a814:	a9 68       	lsl	r8,0x8
8000a816:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000a81a:	30 19       	mov	r9,1
8000a81c:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a820:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000a824:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a828:	91 1c       	st.w	r8[0x4],r12
}
8000a82a:	5e fc       	retal	r12

8000a82c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a82c:	f8 08 16 05 	lsr	r8,r12,0x5
8000a830:	a9 68       	lsl	r8,0x8
8000a832:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000a836:	30 19       	mov	r9,1
8000a838:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a83c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000a840:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a844:	91 1c       	st.w	r8[0x4],r12
}
8000a846:	5e fc       	retal	r12

8000a848 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000a848:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000a84c:	fe c0 a4 4c 	sub	r0,pc,-23476

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000a850:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000a854:	d5 53       	csrf	0x15
  cp      r0, r1
8000a856:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000a858:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000a85c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000a85e:	c0 62       	brcc	8000a86a <idata_load_loop_end>
  cp      r0, r1
8000a860:	48 92       	lddpc	r2,8000a884 <udata_clear_loop_end+0x4>

8000a862 <idata_load_loop>:
  brlo    idata_load_loop
8000a862:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000a864:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000a866:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000a868:	cf d3       	brcs	8000a862 <idata_load_loop>

8000a86a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000a86a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000a86e:	e0 61 46 d0 	mov	r1,18128
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000a872:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000a874:	c0 62       	brcc	8000a880 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000a876:	30 02       	mov	r2,0
8000a878:	30 03       	mov	r3,0

8000a87a <udata_clear_loop>:
8000a87a:	a1 22       	st.d	r0++,r2
8000a87c:	02 30       	cp.w	r0,r1
8000a87e:	cf e3       	brcs	8000a87a <udata_clear_loop>

8000a880 <udata_clear_loop_end>:
8000a880:	fe cf 01 88 	sub	pc,pc,392
8000a884:	80 01       	ld.sh	r1,r0[0x0]
8000a886:	a2 48       	st.h	r1[0x8],r8

8000a888 <free>:
8000a888:	d4 01       	pushm	lr
8000a88a:	e0 68 0a 38 	mov	r8,2616
8000a88e:	18 9b       	mov	r11,r12
8000a890:	70 0c       	ld.w	r12,r8[0x0]
8000a892:	e0 a0 1f 19 	rcall	8000e6c4 <_free_r>
8000a896:	d8 02       	popm	pc

8000a898 <malloc>:
8000a898:	d4 01       	pushm	lr
8000a89a:	e0 68 0a 38 	mov	r8,2616
8000a89e:	18 9b       	mov	r11,r12
8000a8a0:	70 0c       	ld.w	r12,r8[0x0]
8000a8a2:	c0 3c       	rcall	8000a8a8 <_malloc_r>
8000a8a4:	d8 02       	popm	pc
8000a8a6:	d7 03       	nop

8000a8a8 <_malloc_r>:
8000a8a8:	d4 31       	pushm	r0-r7,lr
8000a8aa:	f6 c8 ff f5 	sub	r8,r11,-11
8000a8ae:	18 95       	mov	r5,r12
8000a8b0:	10 97       	mov	r7,r8
8000a8b2:	e0 17 ff f8 	andl	r7,0xfff8
8000a8b6:	59 68       	cp.w	r8,22
8000a8b8:	f9 b7 08 10 	movls	r7,16
8000a8bc:	16 37       	cp.w	r7,r11
8000a8be:	5f 38       	srlo	r8
8000a8c0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a8c4:	c0 50       	breq	8000a8ce <_malloc_r+0x26>
8000a8c6:	30 c8       	mov	r8,12
8000a8c8:	99 38       	st.w	r12[0xc],r8
8000a8ca:	e0 8f 01 fa 	bral	8000acbe <_malloc_r+0x416>
8000a8ce:	fe b0 f5 39 	rcall	80009340 <__malloc_lock>
8000a8d2:	e0 47 01 f7 	cp.w	r7,503
8000a8d6:	e0 8b 00 1d 	brhi	8000a910 <_malloc_r+0x68>
8000a8da:	ee 03 16 03 	lsr	r3,r7,0x3
8000a8de:	e0 68 05 38 	mov	r8,1336
8000a8e2:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a8e6:	70 36       	ld.w	r6,r8[0xc]
8000a8e8:	10 36       	cp.w	r6,r8
8000a8ea:	c0 61       	brne	8000a8f6 <_malloc_r+0x4e>
8000a8ec:	ec c8 ff f8 	sub	r8,r6,-8
8000a8f0:	70 36       	ld.w	r6,r8[0xc]
8000a8f2:	10 36       	cp.w	r6,r8
8000a8f4:	c0 c0       	breq	8000a90c <_malloc_r+0x64>
8000a8f6:	6c 18       	ld.w	r8,r6[0x4]
8000a8f8:	e0 18 ff fc 	andl	r8,0xfffc
8000a8fc:	6c 3a       	ld.w	r10,r6[0xc]
8000a8fe:	ec 08 00 09 	add	r9,r6,r8
8000a902:	0a 9c       	mov	r12,r5
8000a904:	6c 28       	ld.w	r8,r6[0x8]
8000a906:	95 28       	st.w	r10[0x8],r8
8000a908:	91 3a       	st.w	r8[0xc],r10
8000a90a:	c4 78       	rjmp	8000a998 <_malloc_r+0xf0>
8000a90c:	2f e3       	sub	r3,-2
8000a90e:	c4 d8       	rjmp	8000a9a8 <_malloc_r+0x100>
8000a910:	ee 03 16 09 	lsr	r3,r7,0x9
8000a914:	c0 41       	brne	8000a91c <_malloc_r+0x74>
8000a916:	ee 03 16 03 	lsr	r3,r7,0x3
8000a91a:	c2 68       	rjmp	8000a966 <_malloc_r+0xbe>
8000a91c:	58 43       	cp.w	r3,4
8000a91e:	e0 8b 00 06 	brhi	8000a92a <_malloc_r+0x82>
8000a922:	ee 03 16 06 	lsr	r3,r7,0x6
8000a926:	2c 83       	sub	r3,-56
8000a928:	c1 f8       	rjmp	8000a966 <_malloc_r+0xbe>
8000a92a:	59 43       	cp.w	r3,20
8000a92c:	e0 8b 00 04 	brhi	8000a934 <_malloc_r+0x8c>
8000a930:	2a 53       	sub	r3,-91
8000a932:	c1 a8       	rjmp	8000a966 <_malloc_r+0xbe>
8000a934:	e0 43 00 54 	cp.w	r3,84
8000a938:	e0 8b 00 06 	brhi	8000a944 <_malloc_r+0x9c>
8000a93c:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a940:	29 23       	sub	r3,-110
8000a942:	c1 28       	rjmp	8000a966 <_malloc_r+0xbe>
8000a944:	e0 43 01 54 	cp.w	r3,340
8000a948:	e0 8b 00 06 	brhi	8000a954 <_malloc_r+0xac>
8000a94c:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a950:	28 93       	sub	r3,-119
8000a952:	c0 a8       	rjmp	8000a966 <_malloc_r+0xbe>
8000a954:	e0 43 05 54 	cp.w	r3,1364
8000a958:	e0 88 00 04 	brls	8000a960 <_malloc_r+0xb8>
8000a95c:	37 e3       	mov	r3,126
8000a95e:	c0 48       	rjmp	8000a966 <_malloc_r+0xbe>
8000a960:	ee 03 16 12 	lsr	r3,r7,0x12
8000a964:	28 43       	sub	r3,-124
8000a966:	e0 6a 05 38 	mov	r10,1336
8000a96a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a96e:	74 36       	ld.w	r6,r10[0xc]
8000a970:	c1 98       	rjmp	8000a9a2 <_malloc_r+0xfa>
8000a972:	6c 19       	ld.w	r9,r6[0x4]
8000a974:	e0 19 ff fc 	andl	r9,0xfffc
8000a978:	f2 07 01 0b 	sub	r11,r9,r7
8000a97c:	58 fb       	cp.w	r11,15
8000a97e:	e0 8a 00 04 	brle	8000a986 <_malloc_r+0xde>
8000a982:	20 13       	sub	r3,1
8000a984:	c1 18       	rjmp	8000a9a6 <_malloc_r+0xfe>
8000a986:	6c 38       	ld.w	r8,r6[0xc]
8000a988:	58 0b       	cp.w	r11,0
8000a98a:	c0 b5       	brlt	8000a9a0 <_malloc_r+0xf8>
8000a98c:	6c 2a       	ld.w	r10,r6[0x8]
8000a98e:	ec 09 00 09 	add	r9,r6,r9
8000a992:	0a 9c       	mov	r12,r5
8000a994:	91 2a       	st.w	r8[0x8],r10
8000a996:	95 38       	st.w	r10[0xc],r8
8000a998:	72 18       	ld.w	r8,r9[0x4]
8000a99a:	a1 a8       	sbr	r8,0x0
8000a99c:	93 18       	st.w	r9[0x4],r8
8000a99e:	cb c8       	rjmp	8000ab16 <_malloc_r+0x26e>
8000a9a0:	10 96       	mov	r6,r8
8000a9a2:	14 36       	cp.w	r6,r10
8000a9a4:	ce 71       	brne	8000a972 <_malloc_r+0xca>
8000a9a6:	2f f3       	sub	r3,-1
8000a9a8:	e0 6a 05 38 	mov	r10,1336
8000a9ac:	f4 cc ff f8 	sub	r12,r10,-8
8000a9b0:	78 26       	ld.w	r6,r12[0x8]
8000a9b2:	18 36       	cp.w	r6,r12
8000a9b4:	c6 c0       	breq	8000aa8c <_malloc_r+0x1e4>
8000a9b6:	6c 19       	ld.w	r9,r6[0x4]
8000a9b8:	e0 19 ff fc 	andl	r9,0xfffc
8000a9bc:	f2 07 01 08 	sub	r8,r9,r7
8000a9c0:	58 f8       	cp.w	r8,15
8000a9c2:	e0 89 00 8f 	brgt	8000aae0 <_malloc_r+0x238>
8000a9c6:	99 3c       	st.w	r12[0xc],r12
8000a9c8:	99 2c       	st.w	r12[0x8],r12
8000a9ca:	58 08       	cp.w	r8,0
8000a9cc:	c0 55       	brlt	8000a9d6 <_malloc_r+0x12e>
8000a9ce:	ec 09 00 09 	add	r9,r6,r9
8000a9d2:	0a 9c       	mov	r12,r5
8000a9d4:	ce 2b       	rjmp	8000a998 <_malloc_r+0xf0>
8000a9d6:	e0 49 01 ff 	cp.w	r9,511
8000a9da:	e0 8b 00 13 	brhi	8000aa00 <_malloc_r+0x158>
8000a9de:	a3 99       	lsr	r9,0x3
8000a9e0:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a9e4:	70 2b       	ld.w	r11,r8[0x8]
8000a9e6:	8d 38       	st.w	r6[0xc],r8
8000a9e8:	8d 2b       	st.w	r6[0x8],r11
8000a9ea:	97 36       	st.w	r11[0xc],r6
8000a9ec:	91 26       	st.w	r8[0x8],r6
8000a9ee:	a3 49       	asr	r9,0x2
8000a9f0:	74 18       	ld.w	r8,r10[0x4]
8000a9f2:	30 1b       	mov	r11,1
8000a9f4:	f6 09 09 49 	lsl	r9,r11,r9
8000a9f8:	f1 e9 10 09 	or	r9,r8,r9
8000a9fc:	95 19       	st.w	r10[0x4],r9
8000a9fe:	c4 78       	rjmp	8000aa8c <_malloc_r+0x1e4>
8000aa00:	f2 0a 16 09 	lsr	r10,r9,0x9
8000aa04:	58 4a       	cp.w	r10,4
8000aa06:	e0 8b 00 07 	brhi	8000aa14 <_malloc_r+0x16c>
8000aa0a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000aa0e:	2c 8a       	sub	r10,-56
8000aa10:	c2 08       	rjmp	8000aa50 <_malloc_r+0x1a8>
8000aa12:	d7 03       	nop
8000aa14:	59 4a       	cp.w	r10,20
8000aa16:	e0 8b 00 04 	brhi	8000aa1e <_malloc_r+0x176>
8000aa1a:	2a 5a       	sub	r10,-91
8000aa1c:	c1 a8       	rjmp	8000aa50 <_malloc_r+0x1a8>
8000aa1e:	e0 4a 00 54 	cp.w	r10,84
8000aa22:	e0 8b 00 06 	brhi	8000aa2e <_malloc_r+0x186>
8000aa26:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000aa2a:	29 2a       	sub	r10,-110
8000aa2c:	c1 28       	rjmp	8000aa50 <_malloc_r+0x1a8>
8000aa2e:	e0 4a 01 54 	cp.w	r10,340
8000aa32:	e0 8b 00 06 	brhi	8000aa3e <_malloc_r+0x196>
8000aa36:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000aa3a:	28 9a       	sub	r10,-119
8000aa3c:	c0 a8       	rjmp	8000aa50 <_malloc_r+0x1a8>
8000aa3e:	e0 4a 05 54 	cp.w	r10,1364
8000aa42:	e0 88 00 04 	brls	8000aa4a <_malloc_r+0x1a2>
8000aa46:	37 ea       	mov	r10,126
8000aa48:	c0 48       	rjmp	8000aa50 <_malloc_r+0x1a8>
8000aa4a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000aa4e:	28 4a       	sub	r10,-124
8000aa50:	e0 6b 05 38 	mov	r11,1336
8000aa54:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000aa58:	68 28       	ld.w	r8,r4[0x8]
8000aa5a:	08 38       	cp.w	r8,r4
8000aa5c:	c0 e1       	brne	8000aa78 <_malloc_r+0x1d0>
8000aa5e:	76 19       	ld.w	r9,r11[0x4]
8000aa60:	a3 4a       	asr	r10,0x2
8000aa62:	30 1e       	mov	lr,1
8000aa64:	fc 0a 09 4a 	lsl	r10,lr,r10
8000aa68:	f3 ea 10 0a 	or	r10,r9,r10
8000aa6c:	10 99       	mov	r9,r8
8000aa6e:	97 1a       	st.w	r11[0x4],r10
8000aa70:	c0 a8       	rjmp	8000aa84 <_malloc_r+0x1dc>
8000aa72:	70 28       	ld.w	r8,r8[0x8]
8000aa74:	08 38       	cp.w	r8,r4
8000aa76:	c0 60       	breq	8000aa82 <_malloc_r+0x1da>
8000aa78:	70 1a       	ld.w	r10,r8[0x4]
8000aa7a:	e0 1a ff fc 	andl	r10,0xfffc
8000aa7e:	14 39       	cp.w	r9,r10
8000aa80:	cf 93       	brcs	8000aa72 <_malloc_r+0x1ca>
8000aa82:	70 39       	ld.w	r9,r8[0xc]
8000aa84:	8d 39       	st.w	r6[0xc],r9
8000aa86:	8d 28       	st.w	r6[0x8],r8
8000aa88:	91 36       	st.w	r8[0xc],r6
8000aa8a:	93 26       	st.w	r9[0x8],r6
8000aa8c:	e6 08 14 02 	asr	r8,r3,0x2
8000aa90:	30 1b       	mov	r11,1
8000aa92:	e0 64 05 38 	mov	r4,1336
8000aa96:	f6 08 09 4b 	lsl	r11,r11,r8
8000aa9a:	68 18       	ld.w	r8,r4[0x4]
8000aa9c:	10 3b       	cp.w	r11,r8
8000aa9e:	e0 8b 00 6b 	brhi	8000ab74 <_malloc_r+0x2cc>
8000aaa2:	f7 e8 00 09 	and	r9,r11,r8
8000aaa6:	c0 b1       	brne	8000aabc <_malloc_r+0x214>
8000aaa8:	e0 13 ff fc 	andl	r3,0xfffc
8000aaac:	a1 7b       	lsl	r11,0x1
8000aaae:	2f c3       	sub	r3,-4
8000aab0:	c0 38       	rjmp	8000aab6 <_malloc_r+0x20e>
8000aab2:	2f c3       	sub	r3,-4
8000aab4:	a1 7b       	lsl	r11,0x1
8000aab6:	f7 e8 00 09 	and	r9,r11,r8
8000aaba:	cf c0       	breq	8000aab2 <_malloc_r+0x20a>
8000aabc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000aac0:	06 92       	mov	r2,r3
8000aac2:	1c 91       	mov	r1,lr
8000aac4:	62 36       	ld.w	r6,r1[0xc]
8000aac6:	c2 e8       	rjmp	8000ab22 <_malloc_r+0x27a>
8000aac8:	6c 1a       	ld.w	r10,r6[0x4]
8000aaca:	e0 1a ff fc 	andl	r10,0xfffc
8000aace:	f4 07 01 08 	sub	r8,r10,r7
8000aad2:	58 f8       	cp.w	r8,15
8000aad4:	e0 8a 00 15 	brle	8000aafe <_malloc_r+0x256>
8000aad8:	6c 3a       	ld.w	r10,r6[0xc]
8000aada:	6c 29       	ld.w	r9,r6[0x8]
8000aadc:	95 29       	st.w	r10[0x8],r9
8000aade:	93 3a       	st.w	r9[0xc],r10
8000aae0:	0e 99       	mov	r9,r7
8000aae2:	ec 07 00 07 	add	r7,r6,r7
8000aae6:	a1 a9       	sbr	r9,0x0
8000aae8:	99 37       	st.w	r12[0xc],r7
8000aaea:	99 27       	st.w	r12[0x8],r7
8000aaec:	8d 19       	st.w	r6[0x4],r9
8000aaee:	ee 08 09 08 	st.w	r7[r8],r8
8000aaf2:	8f 2c       	st.w	r7[0x8],r12
8000aaf4:	8f 3c       	st.w	r7[0xc],r12
8000aaf6:	a1 a8       	sbr	r8,0x0
8000aaf8:	0a 9c       	mov	r12,r5
8000aafa:	8f 18       	st.w	r7[0x4],r8
8000aafc:	c0 d8       	rjmp	8000ab16 <_malloc_r+0x26e>
8000aafe:	6c 39       	ld.w	r9,r6[0xc]
8000ab00:	58 08       	cp.w	r8,0
8000ab02:	c0 f5       	brlt	8000ab20 <_malloc_r+0x278>
8000ab04:	ec 0a 00 0a 	add	r10,r6,r10
8000ab08:	74 18       	ld.w	r8,r10[0x4]
8000ab0a:	a1 a8       	sbr	r8,0x0
8000ab0c:	0a 9c       	mov	r12,r5
8000ab0e:	95 18       	st.w	r10[0x4],r8
8000ab10:	6c 28       	ld.w	r8,r6[0x8]
8000ab12:	93 28       	st.w	r9[0x8],r8
8000ab14:	91 39       	st.w	r8[0xc],r9
8000ab16:	fe b0 f4 1b 	rcall	8000934c <__malloc_unlock>
8000ab1a:	ec cc ff f8 	sub	r12,r6,-8
8000ab1e:	d8 32       	popm	r0-r7,pc
8000ab20:	12 96       	mov	r6,r9
8000ab22:	02 36       	cp.w	r6,r1
8000ab24:	cd 21       	brne	8000aac8 <_malloc_r+0x220>
8000ab26:	2f f2       	sub	r2,-1
8000ab28:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000ab2c:	c0 30       	breq	8000ab32 <_malloc_r+0x28a>
8000ab2e:	2f 81       	sub	r1,-8
8000ab30:	cc ab       	rjmp	8000aac4 <_malloc_r+0x21c>
8000ab32:	1c 98       	mov	r8,lr
8000ab34:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000ab38:	c0 81       	brne	8000ab48 <_malloc_r+0x2a0>
8000ab3a:	68 19       	ld.w	r9,r4[0x4]
8000ab3c:	f6 08 11 ff 	rsub	r8,r11,-1
8000ab40:	f3 e8 00 08 	and	r8,r9,r8
8000ab44:	89 18       	st.w	r4[0x4],r8
8000ab46:	c0 78       	rjmp	8000ab54 <_malloc_r+0x2ac>
8000ab48:	f0 c9 00 08 	sub	r9,r8,8
8000ab4c:	20 13       	sub	r3,1
8000ab4e:	70 08       	ld.w	r8,r8[0x0]
8000ab50:	12 38       	cp.w	r8,r9
8000ab52:	cf 10       	breq	8000ab34 <_malloc_r+0x28c>
8000ab54:	a1 7b       	lsl	r11,0x1
8000ab56:	68 18       	ld.w	r8,r4[0x4]
8000ab58:	10 3b       	cp.w	r11,r8
8000ab5a:	e0 8b 00 0d 	brhi	8000ab74 <_malloc_r+0x2cc>
8000ab5e:	58 0b       	cp.w	r11,0
8000ab60:	c0 a0       	breq	8000ab74 <_malloc_r+0x2cc>
8000ab62:	04 93       	mov	r3,r2
8000ab64:	c0 38       	rjmp	8000ab6a <_malloc_r+0x2c2>
8000ab66:	2f c3       	sub	r3,-4
8000ab68:	a1 7b       	lsl	r11,0x1
8000ab6a:	f7 e8 00 09 	and	r9,r11,r8
8000ab6e:	ca 71       	brne	8000aabc <_malloc_r+0x214>
8000ab70:	cf bb       	rjmp	8000ab66 <_malloc_r+0x2be>
8000ab72:	d7 03       	nop
8000ab74:	68 23       	ld.w	r3,r4[0x8]
8000ab76:	66 12       	ld.w	r2,r3[0x4]
8000ab78:	e0 12 ff fc 	andl	r2,0xfffc
8000ab7c:	0e 32       	cp.w	r2,r7
8000ab7e:	5f 39       	srlo	r9
8000ab80:	e4 07 01 08 	sub	r8,r2,r7
8000ab84:	58 f8       	cp.w	r8,15
8000ab86:	5f aa       	srle	r10
8000ab88:	f5 e9 10 09 	or	r9,r10,r9
8000ab8c:	e0 80 00 9a 	breq	8000acc0 <_malloc_r+0x418>
8000ab90:	e0 68 13 30 	mov	r8,4912
8000ab94:	70 01       	ld.w	r1,r8[0x0]
8000ab96:	e0 68 09 44 	mov	r8,2372
8000ab9a:	2f 01       	sub	r1,-16
8000ab9c:	70 08       	ld.w	r8,r8[0x0]
8000ab9e:	0e 01       	add	r1,r7
8000aba0:	5b f8       	cp.w	r8,-1
8000aba2:	c0 40       	breq	8000abaa <_malloc_r+0x302>
8000aba4:	28 11       	sub	r1,-127
8000aba6:	e0 11 ff 80 	andl	r1,0xff80
8000abaa:	02 9b       	mov	r11,r1
8000abac:	0a 9c       	mov	r12,r5
8000abae:	e0 a0 02 b7 	rcall	8000b11c <_sbrk_r>
8000abb2:	18 96       	mov	r6,r12
8000abb4:	5b fc       	cp.w	r12,-1
8000abb6:	c7 50       	breq	8000aca0 <_malloc_r+0x3f8>
8000abb8:	e6 02 00 08 	add	r8,r3,r2
8000abbc:	10 3c       	cp.w	r12,r8
8000abbe:	c0 32       	brcc	8000abc4 <_malloc_r+0x31c>
8000abc0:	08 33       	cp.w	r3,r4
8000abc2:	c6 f1       	brne	8000aca0 <_malloc_r+0x3f8>
8000abc4:	e0 6a 13 34 	mov	r10,4916
8000abc8:	74 09       	ld.w	r9,r10[0x0]
8000abca:	e2 09 00 09 	add	r9,r1,r9
8000abce:	95 09       	st.w	r10[0x0],r9
8000abd0:	10 36       	cp.w	r6,r8
8000abd2:	c0 a1       	brne	8000abe6 <_malloc_r+0x33e>
8000abd4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000abd8:	c0 71       	brne	8000abe6 <_malloc_r+0x33e>
8000abda:	e2 02 00 02 	add	r2,r1,r2
8000abde:	68 28       	ld.w	r8,r4[0x8]
8000abe0:	a1 a2       	sbr	r2,0x0
8000abe2:	91 12       	st.w	r8[0x4],r2
8000abe4:	c4 f8       	rjmp	8000ac82 <_malloc_r+0x3da>
8000abe6:	e0 6a 09 44 	mov	r10,2372
8000abea:	74 0b       	ld.w	r11,r10[0x0]
8000abec:	5b fb       	cp.w	r11,-1
8000abee:	c0 31       	brne	8000abf4 <_malloc_r+0x34c>
8000abf0:	95 06       	st.w	r10[0x0],r6
8000abf2:	c0 78       	rjmp	8000ac00 <_malloc_r+0x358>
8000abf4:	ec 09 00 09 	add	r9,r6,r9
8000abf8:	e0 6a 13 34 	mov	r10,4916
8000abfc:	10 19       	sub	r9,r8
8000abfe:	95 09       	st.w	r10[0x0],r9
8000ac00:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000ac04:	f0 09 11 08 	rsub	r9,r8,8
8000ac08:	58 08       	cp.w	r8,0
8000ac0a:	f2 08 17 10 	movne	r8,r9
8000ac0e:	ed d8 e1 06 	addne	r6,r6,r8
8000ac12:	28 08       	sub	r8,-128
8000ac14:	ec 01 00 01 	add	r1,r6,r1
8000ac18:	0a 9c       	mov	r12,r5
8000ac1a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000ac1e:	f0 01 01 01 	sub	r1,r8,r1
8000ac22:	02 9b       	mov	r11,r1
8000ac24:	e0 a0 02 7c 	rcall	8000b11c <_sbrk_r>
8000ac28:	e0 68 13 34 	mov	r8,4916
8000ac2c:	5b fc       	cp.w	r12,-1
8000ac2e:	ec 0c 17 00 	moveq	r12,r6
8000ac32:	f9 b1 00 00 	moveq	r1,0
8000ac36:	70 09       	ld.w	r9,r8[0x0]
8000ac38:	0c 1c       	sub	r12,r6
8000ac3a:	89 26       	st.w	r4[0x8],r6
8000ac3c:	02 0c       	add	r12,r1
8000ac3e:	12 01       	add	r1,r9
8000ac40:	a1 ac       	sbr	r12,0x0
8000ac42:	91 01       	st.w	r8[0x0],r1
8000ac44:	8d 1c       	st.w	r6[0x4],r12
8000ac46:	08 33       	cp.w	r3,r4
8000ac48:	c1 d0       	breq	8000ac82 <_malloc_r+0x3da>
8000ac4a:	58 f2       	cp.w	r2,15
8000ac4c:	e0 8b 00 05 	brhi	8000ac56 <_malloc_r+0x3ae>
8000ac50:	30 18       	mov	r8,1
8000ac52:	8d 18       	st.w	r6[0x4],r8
8000ac54:	c2 68       	rjmp	8000aca0 <_malloc_r+0x3f8>
8000ac56:	30 59       	mov	r9,5
8000ac58:	20 c2       	sub	r2,12
8000ac5a:	e0 12 ff f8 	andl	r2,0xfff8
8000ac5e:	e6 02 00 08 	add	r8,r3,r2
8000ac62:	91 29       	st.w	r8[0x8],r9
8000ac64:	91 19       	st.w	r8[0x4],r9
8000ac66:	66 18       	ld.w	r8,r3[0x4]
8000ac68:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ac6c:	e5 e8 10 08 	or	r8,r2,r8
8000ac70:	87 18       	st.w	r3[0x4],r8
8000ac72:	58 f2       	cp.w	r2,15
8000ac74:	e0 88 00 07 	brls	8000ac82 <_malloc_r+0x3da>
8000ac78:	e6 cb ff f8 	sub	r11,r3,-8
8000ac7c:	0a 9c       	mov	r12,r5
8000ac7e:	e0 a0 1d 23 	rcall	8000e6c4 <_free_r>
8000ac82:	e0 69 13 2c 	mov	r9,4908
8000ac86:	72 0a       	ld.w	r10,r9[0x0]
8000ac88:	e0 68 13 34 	mov	r8,4916
8000ac8c:	70 08       	ld.w	r8,r8[0x0]
8000ac8e:	14 38       	cp.w	r8,r10
8000ac90:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000ac94:	e0 69 13 28 	mov	r9,4904
8000ac98:	72 0a       	ld.w	r10,r9[0x0]
8000ac9a:	14 38       	cp.w	r8,r10
8000ac9c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000aca0:	68 28       	ld.w	r8,r4[0x8]
8000aca2:	70 18       	ld.w	r8,r8[0x4]
8000aca4:	e0 18 ff fc 	andl	r8,0xfffc
8000aca8:	0e 38       	cp.w	r8,r7
8000acaa:	5f 39       	srlo	r9
8000acac:	0e 18       	sub	r8,r7
8000acae:	58 f8       	cp.w	r8,15
8000acb0:	5f aa       	srle	r10
8000acb2:	f5 e9 10 09 	or	r9,r10,r9
8000acb6:	c0 50       	breq	8000acc0 <_malloc_r+0x418>
8000acb8:	0a 9c       	mov	r12,r5
8000acba:	fe b0 f3 49 	rcall	8000934c <__malloc_unlock>
8000acbe:	d8 3a       	popm	r0-r7,pc,r12=0
8000acc0:	68 26       	ld.w	r6,r4[0x8]
8000acc2:	a1 a8       	sbr	r8,0x0
8000acc4:	0e 99       	mov	r9,r7
8000acc6:	a1 a9       	sbr	r9,0x0
8000acc8:	8d 19       	st.w	r6[0x4],r9
8000acca:	ec 07 00 07 	add	r7,r6,r7
8000acce:	0a 9c       	mov	r12,r5
8000acd0:	89 27       	st.w	r4[0x8],r7
8000acd2:	8f 18       	st.w	r7[0x4],r8
8000acd4:	fe b0 f3 3c 	rcall	8000934c <__malloc_unlock>
8000acd8:	ec cc ff f8 	sub	r12,r6,-8
8000acdc:	d8 32       	popm	r0-r7,pc
8000acde:	d7 03       	nop

8000ace0 <memcmp>:
8000ace0:	d4 01       	pushm	lr
8000ace2:	30 08       	mov	r8,0
8000ace4:	c0 d8       	rjmp	8000acfe <memcmp+0x1e>
8000ace6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000acea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000acee:	20 1a       	sub	r10,1
8000acf0:	2f f8       	sub	r8,-1
8000acf2:	f2 0e 18 00 	cp.b	lr,r9
8000acf6:	c0 40       	breq	8000acfe <memcmp+0x1e>
8000acf8:	fc 09 01 0c 	sub	r12,lr,r9
8000acfc:	d8 02       	popm	pc
8000acfe:	58 0a       	cp.w	r10,0
8000ad00:	cf 31       	brne	8000ace6 <memcmp+0x6>
8000ad02:	14 9c       	mov	r12,r10
8000ad04:	d8 02       	popm	pc

8000ad06 <memcpy>:
8000ad06:	58 8a       	cp.w	r10,8
8000ad08:	c2 f5       	brlt	8000ad66 <memcpy+0x60>
8000ad0a:	f9 eb 10 09 	or	r9,r12,r11
8000ad0e:	e2 19 00 03 	andl	r9,0x3,COH
8000ad12:	e0 81 00 97 	brne	8000ae40 <memcpy+0x13a>
8000ad16:	e0 4a 00 20 	cp.w	r10,32
8000ad1a:	c3 b4       	brge	8000ad90 <memcpy+0x8a>
8000ad1c:	f4 08 14 02 	asr	r8,r10,0x2
8000ad20:	f0 09 11 08 	rsub	r9,r8,8
8000ad24:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000ad28:	76 69       	ld.w	r9,r11[0x18]
8000ad2a:	99 69       	st.w	r12[0x18],r9
8000ad2c:	76 59       	ld.w	r9,r11[0x14]
8000ad2e:	99 59       	st.w	r12[0x14],r9
8000ad30:	76 49       	ld.w	r9,r11[0x10]
8000ad32:	99 49       	st.w	r12[0x10],r9
8000ad34:	76 39       	ld.w	r9,r11[0xc]
8000ad36:	99 39       	st.w	r12[0xc],r9
8000ad38:	76 29       	ld.w	r9,r11[0x8]
8000ad3a:	99 29       	st.w	r12[0x8],r9
8000ad3c:	76 19       	ld.w	r9,r11[0x4]
8000ad3e:	99 19       	st.w	r12[0x4],r9
8000ad40:	76 09       	ld.w	r9,r11[0x0]
8000ad42:	99 09       	st.w	r12[0x0],r9
8000ad44:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000ad48:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000ad4c:	e0 1a 00 03 	andl	r10,0x3
8000ad50:	f4 0a 11 04 	rsub	r10,r10,4
8000ad54:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000ad58:	17 a9       	ld.ub	r9,r11[0x2]
8000ad5a:	b0 a9       	st.b	r8[0x2],r9
8000ad5c:	17 99       	ld.ub	r9,r11[0x1]
8000ad5e:	b0 99       	st.b	r8[0x1],r9
8000ad60:	17 89       	ld.ub	r9,r11[0x0]
8000ad62:	b0 89       	st.b	r8[0x0],r9
8000ad64:	5e fc       	retal	r12
8000ad66:	f4 0a 11 09 	rsub	r10,r10,9
8000ad6a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000ad6e:	17 f9       	ld.ub	r9,r11[0x7]
8000ad70:	b8 f9       	st.b	r12[0x7],r9
8000ad72:	17 e9       	ld.ub	r9,r11[0x6]
8000ad74:	b8 e9       	st.b	r12[0x6],r9
8000ad76:	17 d9       	ld.ub	r9,r11[0x5]
8000ad78:	b8 d9       	st.b	r12[0x5],r9
8000ad7a:	17 c9       	ld.ub	r9,r11[0x4]
8000ad7c:	b8 c9       	st.b	r12[0x4],r9
8000ad7e:	17 b9       	ld.ub	r9,r11[0x3]
8000ad80:	b8 b9       	st.b	r12[0x3],r9
8000ad82:	17 a9       	ld.ub	r9,r11[0x2]
8000ad84:	b8 a9       	st.b	r12[0x2],r9
8000ad86:	17 99       	ld.ub	r9,r11[0x1]
8000ad88:	b8 99       	st.b	r12[0x1],r9
8000ad8a:	17 89       	ld.ub	r9,r11[0x0]
8000ad8c:	b8 89       	st.b	r12[0x0],r9
8000ad8e:	5e fc       	retal	r12
8000ad90:	eb cd 40 c0 	pushm	r6-r7,lr
8000ad94:	18 99       	mov	r9,r12
8000ad96:	22 0a       	sub	r10,32
8000ad98:	b7 07       	ld.d	r6,r11++
8000ad9a:	b3 26       	st.d	r9++,r6
8000ad9c:	b7 07       	ld.d	r6,r11++
8000ad9e:	b3 26       	st.d	r9++,r6
8000ada0:	b7 07       	ld.d	r6,r11++
8000ada2:	b3 26       	st.d	r9++,r6
8000ada4:	b7 07       	ld.d	r6,r11++
8000ada6:	b3 26       	st.d	r9++,r6
8000ada8:	22 0a       	sub	r10,32
8000adaa:	cf 74       	brge	8000ad98 <memcpy+0x92>
8000adac:	2f 0a       	sub	r10,-16
8000adae:	c0 65       	brlt	8000adba <memcpy+0xb4>
8000adb0:	b7 07       	ld.d	r6,r11++
8000adb2:	b3 26       	st.d	r9++,r6
8000adb4:	b7 07       	ld.d	r6,r11++
8000adb6:	b3 26       	st.d	r9++,r6
8000adb8:	21 0a       	sub	r10,16
8000adba:	5c 3a       	neg	r10
8000adbc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000adc0:	d7 03       	nop
8000adc2:	d7 03       	nop
8000adc4:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000adc8:	f3 66 00 0e 	st.b	r9[14],r6
8000adcc:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000add0:	f3 66 00 0d 	st.b	r9[13],r6
8000add4:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000add8:	f3 66 00 0c 	st.b	r9[12],r6
8000addc:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000ade0:	f3 66 00 0b 	st.b	r9[11],r6
8000ade4:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000ade8:	f3 66 00 0a 	st.b	r9[10],r6
8000adec:	f7 36 00 09 	ld.ub	r6,r11[9]
8000adf0:	f3 66 00 09 	st.b	r9[9],r6
8000adf4:	f7 36 00 08 	ld.ub	r6,r11[8]
8000adf8:	f3 66 00 08 	st.b	r9[8],r6
8000adfc:	f7 36 00 07 	ld.ub	r6,r11[7]
8000ae00:	f3 66 00 07 	st.b	r9[7],r6
8000ae04:	f7 36 00 06 	ld.ub	r6,r11[6]
8000ae08:	f3 66 00 06 	st.b	r9[6],r6
8000ae0c:	f7 36 00 05 	ld.ub	r6,r11[5]
8000ae10:	f3 66 00 05 	st.b	r9[5],r6
8000ae14:	f7 36 00 04 	ld.ub	r6,r11[4]
8000ae18:	f3 66 00 04 	st.b	r9[4],r6
8000ae1c:	f7 36 00 03 	ld.ub	r6,r11[3]
8000ae20:	f3 66 00 03 	st.b	r9[3],r6
8000ae24:	f7 36 00 02 	ld.ub	r6,r11[2]
8000ae28:	f3 66 00 02 	st.b	r9[2],r6
8000ae2c:	f7 36 00 01 	ld.ub	r6,r11[1]
8000ae30:	f3 66 00 01 	st.b	r9[1],r6
8000ae34:	f7 36 00 00 	ld.ub	r6,r11[0]
8000ae38:	f3 66 00 00 	st.b	r9[0],r6
8000ae3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000ae40:	20 1a       	sub	r10,1
8000ae42:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000ae46:	f8 0a 0b 09 	st.b	r12[r10],r9
8000ae4a:	cf b1       	brne	8000ae40 <memcpy+0x13a>
8000ae4c:	5e fc       	retal	r12

8000ae4e <memset>:
8000ae4e:	18 98       	mov	r8,r12
8000ae50:	c0 38       	rjmp	8000ae56 <memset+0x8>
8000ae52:	10 cb       	st.b	r8++,r11
8000ae54:	20 1a       	sub	r10,1
8000ae56:	58 0a       	cp.w	r10,0
8000ae58:	cf d1       	brne	8000ae52 <memset+0x4>
8000ae5a:	5e fc       	retal	r12

8000ae5c <_realloc_r>:
8000ae5c:	d4 31       	pushm	r0-r7,lr
8000ae5e:	20 1d       	sub	sp,4
8000ae60:	16 94       	mov	r4,r11
8000ae62:	18 92       	mov	r2,r12
8000ae64:	14 9b       	mov	r11,r10
8000ae66:	58 04       	cp.w	r4,0
8000ae68:	c0 51       	brne	8000ae72 <_realloc_r+0x16>
8000ae6a:	fe b0 fd 1f 	rcall	8000a8a8 <_malloc_r>
8000ae6e:	18 95       	mov	r5,r12
8000ae70:	c5 39       	rjmp	8000b116 <_realloc_r+0x2ba>
8000ae72:	50 0a       	stdsp	sp[0x0],r10
8000ae74:	fe b0 f2 66 	rcall	80009340 <__malloc_lock>
8000ae78:	40 0b       	lddsp	r11,sp[0x0]
8000ae7a:	f6 c8 ff f5 	sub	r8,r11,-11
8000ae7e:	e8 c1 00 08 	sub	r1,r4,8
8000ae82:	10 96       	mov	r6,r8
8000ae84:	62 1c       	ld.w	r12,r1[0x4]
8000ae86:	e0 16 ff f8 	andl	r6,0xfff8
8000ae8a:	59 68       	cp.w	r8,22
8000ae8c:	f9 b6 08 10 	movls	r6,16
8000ae90:	16 36       	cp.w	r6,r11
8000ae92:	5f 38       	srlo	r8
8000ae94:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000ae98:	c0 50       	breq	8000aea2 <_realloc_r+0x46>
8000ae9a:	30 c8       	mov	r8,12
8000ae9c:	30 05       	mov	r5,0
8000ae9e:	85 38       	st.w	r2[0xc],r8
8000aea0:	c3 b9       	rjmp	8000b116 <_realloc_r+0x2ba>
8000aea2:	18 90       	mov	r0,r12
8000aea4:	e0 10 ff fc 	andl	r0,0xfffc
8000aea8:	0c 30       	cp.w	r0,r6
8000aeaa:	e0 84 01 0b 	brge	8000b0c0 <_realloc_r+0x264>
8000aeae:	e0 68 05 38 	mov	r8,1336
8000aeb2:	e2 00 00 09 	add	r9,r1,r0
8000aeb6:	70 25       	ld.w	r5,r8[0x8]
8000aeb8:	0a 39       	cp.w	r9,r5
8000aeba:	c0 90       	breq	8000aecc <_realloc_r+0x70>
8000aebc:	72 1a       	ld.w	r10,r9[0x4]
8000aebe:	a1 ca       	cbr	r10,0x0
8000aec0:	f2 0a 00 0a 	add	r10,r9,r10
8000aec4:	74 1a       	ld.w	r10,r10[0x4]
8000aec6:	ed ba 00 00 	bld	r10,0x0
8000aeca:	c2 20       	breq	8000af0e <_realloc_r+0xb2>
8000aecc:	72 1a       	ld.w	r10,r9[0x4]
8000aece:	e0 1a ff fc 	andl	r10,0xfffc
8000aed2:	f4 00 00 03 	add	r3,r10,r0
8000aed6:	0a 39       	cp.w	r9,r5
8000aed8:	c1 31       	brne	8000aefe <_realloc_r+0xa2>
8000aeda:	ec c7 ff f0 	sub	r7,r6,-16
8000aede:	0e 33       	cp.w	r3,r7
8000aee0:	c1 95       	brlt	8000af12 <_realloc_r+0xb6>
8000aee2:	e2 06 00 09 	add	r9,r1,r6
8000aee6:	0c 13       	sub	r3,r6
8000aee8:	a1 a3       	sbr	r3,0x0
8000aeea:	93 13       	st.w	r9[0x4],r3
8000aeec:	91 29       	st.w	r8[0x8],r9
8000aeee:	04 9c       	mov	r12,r2
8000aef0:	62 18       	ld.w	r8,r1[0x4]
8000aef2:	08 95       	mov	r5,r4
8000aef4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000aef8:	10 46       	or	r6,r8
8000aefa:	83 16       	st.w	r1[0x4],r6
8000aefc:	c0 b9       	rjmp	8000b112 <_realloc_r+0x2b6>
8000aefe:	0c 33       	cp.w	r3,r6
8000af00:	c0 95       	brlt	8000af12 <_realloc_r+0xb6>
8000af02:	72 28       	ld.w	r8,r9[0x8]
8000af04:	02 97       	mov	r7,r1
8000af06:	72 39       	ld.w	r9,r9[0xc]
8000af08:	93 28       	st.w	r9[0x8],r8
8000af0a:	91 39       	st.w	r8[0xc],r9
8000af0c:	cd c8       	rjmp	8000b0c4 <_realloc_r+0x268>
8000af0e:	30 0a       	mov	r10,0
8000af10:	14 99       	mov	r9,r10
8000af12:	ed bc 00 00 	bld	r12,0x0
8000af16:	e0 80 00 95 	breq	8000b040 <_realloc_r+0x1e4>
8000af1a:	62 07       	ld.w	r7,r1[0x0]
8000af1c:	e2 07 01 07 	sub	r7,r1,r7
8000af20:	6e 1c       	ld.w	r12,r7[0x4]
8000af22:	e0 1c ff fc 	andl	r12,0xfffc
8000af26:	58 09       	cp.w	r9,0
8000af28:	c5 60       	breq	8000afd4 <_realloc_r+0x178>
8000af2a:	f8 00 00 03 	add	r3,r12,r0
8000af2e:	0a 39       	cp.w	r9,r5
8000af30:	c4 81       	brne	8000afc0 <_realloc_r+0x164>
8000af32:	14 03       	add	r3,r10
8000af34:	ec c9 ff f0 	sub	r9,r6,-16
8000af38:	12 33       	cp.w	r3,r9
8000af3a:	c4 d5       	brlt	8000afd4 <_realloc_r+0x178>
8000af3c:	6e 3a       	ld.w	r10,r7[0xc]
8000af3e:	6e 29       	ld.w	r9,r7[0x8]
8000af40:	95 29       	st.w	r10[0x8],r9
8000af42:	93 3a       	st.w	r9[0xc],r10
8000af44:	ee c5 ff f8 	sub	r5,r7,-8
8000af48:	e0 ca 00 04 	sub	r10,r0,4
8000af4c:	e0 4a 00 24 	cp.w	r10,36
8000af50:	e0 8b 00 25 	brhi	8000af9a <_realloc_r+0x13e>
8000af54:	0a 99       	mov	r9,r5
8000af56:	59 3a       	cp.w	r10,19
8000af58:	e0 88 00 1a 	brls	8000af8c <_realloc_r+0x130>
8000af5c:	09 09       	ld.w	r9,r4++
8000af5e:	8b 09       	st.w	r5[0x0],r9
8000af60:	09 09       	ld.w	r9,r4++
8000af62:	8f 39       	st.w	r7[0xc],r9
8000af64:	ee c9 ff f0 	sub	r9,r7,-16
8000af68:	59 ba       	cp.w	r10,27
8000af6a:	e0 88 00 11 	brls	8000af8c <_realloc_r+0x130>
8000af6e:	09 0b       	ld.w	r11,r4++
8000af70:	93 0b       	st.w	r9[0x0],r11
8000af72:	09 09       	ld.w	r9,r4++
8000af74:	8f 59       	st.w	r7[0x14],r9
8000af76:	ee c9 ff e8 	sub	r9,r7,-24
8000af7a:	e0 4a 00 24 	cp.w	r10,36
8000af7e:	c0 71       	brne	8000af8c <_realloc_r+0x130>
8000af80:	09 0a       	ld.w	r10,r4++
8000af82:	93 0a       	st.w	r9[0x0],r10
8000af84:	ee c9 ff e0 	sub	r9,r7,-32
8000af88:	09 0a       	ld.w	r10,r4++
8000af8a:	8f 7a       	st.w	r7[0x1c],r10
8000af8c:	09 0a       	ld.w	r10,r4++
8000af8e:	12 aa       	st.w	r9++,r10
8000af90:	68 0a       	ld.w	r10,r4[0x0]
8000af92:	93 0a       	st.w	r9[0x0],r10
8000af94:	68 1a       	ld.w	r10,r4[0x4]
8000af96:	93 1a       	st.w	r9[0x4],r10
8000af98:	c0 78       	rjmp	8000afa6 <_realloc_r+0x14a>
8000af9a:	50 08       	stdsp	sp[0x0],r8
8000af9c:	08 9b       	mov	r11,r4
8000af9e:	0a 9c       	mov	r12,r5
8000afa0:	e0 a0 1e 35 	rcall	8000ec0a <memmove>
8000afa4:	40 08       	lddsp	r8,sp[0x0]
8000afa6:	ee 06 00 09 	add	r9,r7,r6
8000afaa:	0c 13       	sub	r3,r6
8000afac:	a1 a3       	sbr	r3,0x0
8000afae:	93 13       	st.w	r9[0x4],r3
8000afb0:	91 29       	st.w	r8[0x8],r9
8000afb2:	04 9c       	mov	r12,r2
8000afb4:	6e 18       	ld.w	r8,r7[0x4]
8000afb6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000afba:	10 46       	or	r6,r8
8000afbc:	8f 16       	st.w	r7[0x4],r6
8000afbe:	ca a8       	rjmp	8000b112 <_realloc_r+0x2b6>
8000afc0:	14 03       	add	r3,r10
8000afc2:	0c 33       	cp.w	r3,r6
8000afc4:	c0 85       	brlt	8000afd4 <_realloc_r+0x178>
8000afc6:	72 28       	ld.w	r8,r9[0x8]
8000afc8:	72 39       	ld.w	r9,r9[0xc]
8000afca:	93 28       	st.w	r9[0x8],r8
8000afcc:	91 39       	st.w	r8[0xc],r9
8000afce:	6e 28       	ld.w	r8,r7[0x8]
8000afd0:	6e 39       	ld.w	r9,r7[0xc]
8000afd2:	c0 78       	rjmp	8000afe0 <_realloc_r+0x184>
8000afd4:	f8 00 00 03 	add	r3,r12,r0
8000afd8:	0c 33       	cp.w	r3,r6
8000afda:	c3 35       	brlt	8000b040 <_realloc_r+0x1e4>
8000afdc:	6e 39       	ld.w	r9,r7[0xc]
8000afde:	6e 28       	ld.w	r8,r7[0x8]
8000afe0:	93 28       	st.w	r9[0x8],r8
8000afe2:	91 39       	st.w	r8[0xc],r9
8000afe4:	e0 ca 00 04 	sub	r10,r0,4
8000afe8:	ee cc ff f8 	sub	r12,r7,-8
8000afec:	e0 4a 00 24 	cp.w	r10,36
8000aff0:	e0 8b 00 24 	brhi	8000b038 <_realloc_r+0x1dc>
8000aff4:	59 3a       	cp.w	r10,19
8000aff6:	e0 88 00 1a 	brls	8000b02a <_realloc_r+0x1ce>
8000affa:	09 08       	ld.w	r8,r4++
8000affc:	99 08       	st.w	r12[0x0],r8
8000affe:	09 08       	ld.w	r8,r4++
8000b000:	8f 38       	st.w	r7[0xc],r8
8000b002:	ee cc ff f0 	sub	r12,r7,-16
8000b006:	59 ba       	cp.w	r10,27
8000b008:	e0 88 00 11 	brls	8000b02a <_realloc_r+0x1ce>
8000b00c:	09 08       	ld.w	r8,r4++
8000b00e:	99 08       	st.w	r12[0x0],r8
8000b010:	09 08       	ld.w	r8,r4++
8000b012:	8f 58       	st.w	r7[0x14],r8
8000b014:	ee cc ff e8 	sub	r12,r7,-24
8000b018:	e0 4a 00 24 	cp.w	r10,36
8000b01c:	c0 71       	brne	8000b02a <_realloc_r+0x1ce>
8000b01e:	09 08       	ld.w	r8,r4++
8000b020:	99 08       	st.w	r12[0x0],r8
8000b022:	ee cc ff e0 	sub	r12,r7,-32
8000b026:	09 08       	ld.w	r8,r4++
8000b028:	8f 78       	st.w	r7[0x1c],r8
8000b02a:	09 08       	ld.w	r8,r4++
8000b02c:	18 a8       	st.w	r12++,r8
8000b02e:	68 08       	ld.w	r8,r4[0x0]
8000b030:	99 08       	st.w	r12[0x0],r8
8000b032:	68 18       	ld.w	r8,r4[0x4]
8000b034:	99 18       	st.w	r12[0x4],r8
8000b036:	c4 78       	rjmp	8000b0c4 <_realloc_r+0x268>
8000b038:	08 9b       	mov	r11,r4
8000b03a:	e0 a0 1d e8 	rcall	8000ec0a <memmove>
8000b03e:	c4 38       	rjmp	8000b0c4 <_realloc_r+0x268>
8000b040:	04 9c       	mov	r12,r2
8000b042:	fe b0 fc 33 	rcall	8000a8a8 <_malloc_r>
8000b046:	18 95       	mov	r5,r12
8000b048:	c3 a0       	breq	8000b0bc <_realloc_r+0x260>
8000b04a:	62 18       	ld.w	r8,r1[0x4]
8000b04c:	f8 c9 00 08 	sub	r9,r12,8
8000b050:	a1 c8       	cbr	r8,0x0
8000b052:	e2 08 00 08 	add	r8,r1,r8
8000b056:	10 39       	cp.w	r9,r8
8000b058:	c0 71       	brne	8000b066 <_realloc_r+0x20a>
8000b05a:	72 13       	ld.w	r3,r9[0x4]
8000b05c:	02 97       	mov	r7,r1
8000b05e:	e0 13 ff fc 	andl	r3,0xfffc
8000b062:	00 03       	add	r3,r0
8000b064:	c3 08       	rjmp	8000b0c4 <_realloc_r+0x268>
8000b066:	e0 ca 00 04 	sub	r10,r0,4
8000b06a:	e0 4a 00 24 	cp.w	r10,36
8000b06e:	e0 8b 00 20 	brhi	8000b0ae <_realloc_r+0x252>
8000b072:	08 99       	mov	r9,r4
8000b074:	18 98       	mov	r8,r12
8000b076:	59 3a       	cp.w	r10,19
8000b078:	e0 88 00 14 	brls	8000b0a0 <_realloc_r+0x244>
8000b07c:	13 0b       	ld.w	r11,r9++
8000b07e:	10 ab       	st.w	r8++,r11
8000b080:	13 0b       	ld.w	r11,r9++
8000b082:	10 ab       	st.w	r8++,r11
8000b084:	59 ba       	cp.w	r10,27
8000b086:	e0 88 00 0d 	brls	8000b0a0 <_realloc_r+0x244>
8000b08a:	13 0b       	ld.w	r11,r9++
8000b08c:	10 ab       	st.w	r8++,r11
8000b08e:	13 0b       	ld.w	r11,r9++
8000b090:	10 ab       	st.w	r8++,r11
8000b092:	e0 4a 00 24 	cp.w	r10,36
8000b096:	c0 51       	brne	8000b0a0 <_realloc_r+0x244>
8000b098:	13 0a       	ld.w	r10,r9++
8000b09a:	10 aa       	st.w	r8++,r10
8000b09c:	13 0a       	ld.w	r10,r9++
8000b09e:	10 aa       	st.w	r8++,r10
8000b0a0:	13 0a       	ld.w	r10,r9++
8000b0a2:	10 aa       	st.w	r8++,r10
8000b0a4:	72 0a       	ld.w	r10,r9[0x0]
8000b0a6:	91 0a       	st.w	r8[0x0],r10
8000b0a8:	72 19       	ld.w	r9,r9[0x4]
8000b0aa:	91 19       	st.w	r8[0x4],r9
8000b0ac:	c0 48       	rjmp	8000b0b4 <_realloc_r+0x258>
8000b0ae:	08 9b       	mov	r11,r4
8000b0b0:	e0 a0 1d ad 	rcall	8000ec0a <memmove>
8000b0b4:	08 9b       	mov	r11,r4
8000b0b6:	04 9c       	mov	r12,r2
8000b0b8:	e0 a0 1b 06 	rcall	8000e6c4 <_free_r>
8000b0bc:	04 9c       	mov	r12,r2
8000b0be:	c2 a8       	rjmp	8000b112 <_realloc_r+0x2b6>
8000b0c0:	00 93       	mov	r3,r0
8000b0c2:	02 97       	mov	r7,r1
8000b0c4:	e6 06 01 09 	sub	r9,r3,r6
8000b0c8:	6e 18       	ld.w	r8,r7[0x4]
8000b0ca:	58 f9       	cp.w	r9,15
8000b0cc:	e0 88 00 16 	brls	8000b0f8 <_realloc_r+0x29c>
8000b0d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b0d4:	ed e8 10 08 	or	r8,r6,r8
8000b0d8:	8f 18       	st.w	r7[0x4],r8
8000b0da:	12 98       	mov	r8,r9
8000b0dc:	a1 a8       	sbr	r8,0x0
8000b0de:	ee 06 00 0b 	add	r11,r7,r6
8000b0e2:	f6 09 00 09 	add	r9,r11,r9
8000b0e6:	97 18       	st.w	r11[0x4],r8
8000b0e8:	72 18       	ld.w	r8,r9[0x4]
8000b0ea:	a1 a8       	sbr	r8,0x0
8000b0ec:	2f 8b       	sub	r11,-8
8000b0ee:	93 18       	st.w	r9[0x4],r8
8000b0f0:	04 9c       	mov	r12,r2
8000b0f2:	e0 a0 1a e9 	rcall	8000e6c4 <_free_r>
8000b0f6:	c0 b8       	rjmp	8000b10c <_realloc_r+0x2b0>
8000b0f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b0fc:	e7 e8 10 08 	or	r8,r3,r8
8000b100:	8f 18       	st.w	r7[0x4],r8
8000b102:	ee 03 00 03 	add	r3,r7,r3
8000b106:	66 18       	ld.w	r8,r3[0x4]
8000b108:	a1 a8       	sbr	r8,0x0
8000b10a:	87 18       	st.w	r3[0x4],r8
8000b10c:	04 9c       	mov	r12,r2
8000b10e:	ee c5 ff f8 	sub	r5,r7,-8
8000b112:	fe b0 f1 1d 	rcall	8000934c <__malloc_unlock>
8000b116:	0a 9c       	mov	r12,r5
8000b118:	2f fd       	sub	sp,-4
8000b11a:	d8 32       	popm	r0-r7,pc

8000b11c <_sbrk_r>:
8000b11c:	d4 21       	pushm	r4-r7,lr
8000b11e:	30 08       	mov	r8,0
8000b120:	18 97       	mov	r7,r12
8000b122:	e0 66 46 c8 	mov	r6,18120
8000b126:	16 9c       	mov	r12,r11
8000b128:	8d 08       	st.w	r6[0x0],r8
8000b12a:	c1 1d       	rcall	8000b34c <_sbrk>
8000b12c:	5b fc       	cp.w	r12,-1
8000b12e:	c0 51       	brne	8000b138 <_sbrk_r+0x1c>
8000b130:	6c 08       	ld.w	r8,r6[0x0]
8000b132:	58 08       	cp.w	r8,0
8000b134:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b138:	d8 22       	popm	r4-r7,pc
8000b13a:	d7 03       	nop

8000b13c <sprintf>:
8000b13c:	d4 01       	pushm	lr
8000b13e:	21 7d       	sub	sp,92
8000b140:	e0 68 ff ff 	mov	r8,65535
8000b144:	ea 18 7f ff 	orh	r8,0x7fff
8000b148:	50 58       	stdsp	sp[0x14],r8
8000b14a:	50 28       	stdsp	sp[0x8],r8
8000b14c:	e0 68 02 08 	mov	r8,520
8000b150:	ba 68       	st.h	sp[0xc],r8
8000b152:	3f f8       	mov	r8,-1
8000b154:	ba 78       	st.h	sp[0xe],r8
8000b156:	e0 68 0a 38 	mov	r8,2616
8000b15a:	50 4c       	stdsp	sp[0x10],r12
8000b15c:	16 9a       	mov	r10,r11
8000b15e:	50 0c       	stdsp	sp[0x0],r12
8000b160:	fa c9 ff a0 	sub	r9,sp,-96
8000b164:	70 0c       	ld.w	r12,r8[0x0]
8000b166:	1a 9b       	mov	r11,sp
8000b168:	e0 a0 02 ac 	rcall	8000b6c0 <_vfprintf_r>
8000b16c:	30 09       	mov	r9,0
8000b16e:	40 08       	lddsp	r8,sp[0x0]
8000b170:	b0 89       	st.b	r8[0x0],r9
8000b172:	2e 9d       	sub	sp,-92
8000b174:	d8 02       	popm	pc
8000b176:	d7 03       	nop

8000b178 <strcpy>:
8000b178:	30 08       	mov	r8,0
8000b17a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b17e:	f8 08 0b 09 	st.b	r12[r8],r9
8000b182:	2f f8       	sub	r8,-1
8000b184:	58 09       	cp.w	r9,0
8000b186:	cf a1       	brne	8000b17a <strcpy+0x2>
8000b188:	5e fc       	retal	r12

8000b18a <strlen>:
8000b18a:	30 09       	mov	r9,0
8000b18c:	18 98       	mov	r8,r12
8000b18e:	c0 28       	rjmp	8000b192 <strlen+0x8>
8000b190:	2f f8       	sub	r8,-1
8000b192:	11 8a       	ld.ub	r10,r8[0x0]
8000b194:	f2 0a 18 00 	cp.b	r10,r9
8000b198:	cf c1       	brne	8000b190 <strlen+0x6>
8000b19a:	f0 0c 01 0c 	sub	r12,r8,r12
8000b19e:	5e fc       	retal	r12

8000b1a0 <strncpy>:
8000b1a0:	30 08       	mov	r8,0
8000b1a2:	10 3a       	cp.w	r10,r8
8000b1a4:	5e 0c       	reteq	r12
8000b1a6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b1aa:	f8 08 0b 09 	st.b	r12[r8],r9
8000b1ae:	2f f8       	sub	r8,-1
8000b1b0:	58 09       	cp.w	r9,0
8000b1b2:	cf 81       	brne	8000b1a2 <strncpy+0x2>
8000b1b4:	10 3a       	cp.w	r10,r8
8000b1b6:	5e 0c       	reteq	r12
8000b1b8:	f8 08 0b 09 	st.b	r12[r8],r9
8000b1bc:	2f f8       	sub	r8,-1
8000b1be:	cf bb       	rjmp	8000b1b4 <strncpy+0x14>

8000b1c0 <strtok>:
8000b1c0:	d4 21       	pushm	r4-r7,lr
8000b1c2:	20 1d       	sub	sp,4
8000b1c4:	e0 65 0a 38 	mov	r5,2616
8000b1c8:	18 97       	mov	r7,r12
8000b1ca:	6a 04       	ld.w	r4,r5[0x0]
8000b1cc:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000b1d0:	58 06       	cp.w	r6,0
8000b1d2:	c3 51       	brne	8000b23c <strtok+0x7c>
8000b1d4:	50 0b       	stdsp	sp[0x0],r11
8000b1d6:	35 0c       	mov	r12,80
8000b1d8:	fe b0 fb 60 	rcall	8000a898 <malloc>
8000b1dc:	6a 08       	ld.w	r8,r5[0x0]
8000b1de:	e9 4c 00 e8 	st.w	r4[232],r12
8000b1e2:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b1e6:	93 26       	st.w	r9[0x8],r6
8000b1e8:	93 06       	st.w	r9[0x0],r6
8000b1ea:	93 16       	st.w	r9[0x4],r6
8000b1ec:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b1f0:	93 46       	st.w	r9[0x10],r6
8000b1f2:	93 36       	st.w	r9[0xc],r6
8000b1f4:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b1f8:	93 66       	st.w	r9[0x18],r6
8000b1fa:	93 56       	st.w	r9[0x14],r6
8000b1fc:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b200:	93 b6       	st.w	r9[0x2c],r6
8000b202:	93 a6       	st.w	r9[0x28],r6
8000b204:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b208:	93 d6       	st.w	r9[0x34],r6
8000b20a:	93 c6       	st.w	r9[0x30],r6
8000b20c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b210:	93 f6       	st.w	r9[0x3c],r6
8000b212:	93 e6       	st.w	r9[0x38],r6
8000b214:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b218:	f3 46 00 44 	st.w	r9[68],r6
8000b21c:	f3 46 00 40 	st.w	r9[64],r6
8000b220:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b224:	f3 46 00 4c 	st.w	r9[76],r6
8000b228:	f3 46 00 48 	st.w	r9[72],r6
8000b22c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000b230:	f3 66 00 1c 	st.b	r9[28],r6
8000b234:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000b238:	40 0b       	lddsp	r11,sp[0x0]
8000b23a:	91 96       	st.w	r8[0x24],r6
8000b23c:	e0 68 0a 38 	mov	r8,2616
8000b240:	70 08       	ld.w	r8,r8[0x0]
8000b242:	0e 9c       	mov	r12,r7
8000b244:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000b248:	30 19       	mov	r9,1
8000b24a:	c0 3c       	rcall	8000b250 <__strtok_r>
8000b24c:	2f fd       	sub	sp,-4
8000b24e:	d8 22       	popm	r4-r7,pc

8000b250 <__strtok_r>:
8000b250:	d4 21       	pushm	r4-r7,lr
8000b252:	58 0c       	cp.w	r12,0
8000b254:	c0 41       	brne	8000b25c <__strtok_r+0xc>
8000b256:	74 0c       	ld.w	r12,r10[0x0]
8000b258:	58 0c       	cp.w	r12,0
8000b25a:	c2 90       	breq	8000b2ac <__strtok_r+0x5c>
8000b25c:	18 98       	mov	r8,r12
8000b25e:	16 97       	mov	r7,r11
8000b260:	11 3e       	ld.ub	lr,r8++
8000b262:	c0 a8       	rjmp	8000b276 <__strtok_r+0x26>
8000b264:	0c 3e       	cp.w	lr,r6
8000b266:	c0 81       	brne	8000b276 <__strtok_r+0x26>
8000b268:	58 09       	cp.w	r9,0
8000b26a:	c0 30       	breq	8000b270 <__strtok_r+0x20>
8000b26c:	10 9c       	mov	r12,r8
8000b26e:	cf 7b       	rjmp	8000b25c <__strtok_r+0xc>
8000b270:	95 08       	st.w	r10[0x0],r8
8000b272:	b8 89       	st.b	r12[0x0],r9
8000b274:	d8 22       	popm	r4-r7,pc
8000b276:	0f 36       	ld.ub	r6,r7++
8000b278:	58 06       	cp.w	r6,0
8000b27a:	cf 51       	brne	8000b264 <__strtok_r+0x14>
8000b27c:	58 0e       	cp.w	lr,0
8000b27e:	c0 51       	brne	8000b288 <__strtok_r+0x38>
8000b280:	95 0e       	st.w	r10[0x0],lr
8000b282:	1c 9c       	mov	r12,lr
8000b284:	d8 22       	popm	r4-r7,pc
8000b286:	12 98       	mov	r8,r9
8000b288:	10 99       	mov	r9,r8
8000b28a:	16 97       	mov	r7,r11
8000b28c:	13 3e       	ld.ub	lr,r9++
8000b28e:	0f 36       	ld.ub	r6,r7++
8000b290:	1c 36       	cp.w	r6,lr
8000b292:	c0 a1       	brne	8000b2a6 <__strtok_r+0x56>
8000b294:	58 0e       	cp.w	lr,0
8000b296:	fc 09 17 00 	moveq	r9,lr
8000b29a:	f9 bb 01 00 	movne	r11,0
8000b29e:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000b2a2:	95 09       	st.w	r10[0x0],r9
8000b2a4:	d8 22       	popm	r4-r7,pc
8000b2a6:	58 06       	cp.w	r6,0
8000b2a8:	cf 31       	brne	8000b28e <__strtok_r+0x3e>
8000b2aa:	ce eb       	rjmp	8000b286 <__strtok_r+0x36>
8000b2ac:	d8 22       	popm	r4-r7,pc
8000b2ae:	d7 03       	nop

8000b2b0 <_close>:
8000b2b0:	30 28       	mov	r8,2
8000b2b2:	d6 73       	breakpoint
8000b2b4:	3f fc       	mov	r12,-1
8000b2b6:	35 8b       	mov	r11,88
8000b2b8:	58 0c       	cp.w	r12,0
8000b2ba:	5e 4c       	retge	r12
8000b2bc:	e0 6a 46 c8 	mov	r10,18120
8000b2c0:	95 0b       	st.w	r10[0x0],r11
8000b2c2:	5e fc       	retal	r12

8000b2c4 <_lseek>:
8000b2c4:	30 58       	mov	r8,5
8000b2c6:	d6 73       	breakpoint
8000b2c8:	3f fc       	mov	r12,-1
8000b2ca:	35 8b       	mov	r11,88
8000b2cc:	58 0c       	cp.w	r12,0
8000b2ce:	5e 4c       	retge	r12
8000b2d0:	e0 6a 46 c8 	mov	r10,18120
8000b2d4:	95 0b       	st.w	r10[0x0],r11
8000b2d6:	5e fc       	retal	r12

8000b2d8 <isatty>:
8000b2d8:	30 b8       	mov	r8,11
8000b2da:	d6 73       	breakpoint
8000b2dc:	3f fc       	mov	r12,-1
8000b2de:	35 8b       	mov	r11,88
8000b2e0:	58 0c       	cp.w	r12,0
8000b2e2:	5e 4c       	retge	r12
8000b2e4:	e0 6a 46 c8 	mov	r10,18120
8000b2e8:	95 0b       	st.w	r10[0x0],r11
8000b2ea:	5e fc       	retal	r12

8000b2ec <_fstat_host>:
8000b2ec:	30 98       	mov	r8,9
8000b2ee:	d6 73       	breakpoint
8000b2f0:	3f fc       	mov	r12,-1
8000b2f2:	35 8b       	mov	r11,88
8000b2f4:	58 0c       	cp.w	r12,0
8000b2f6:	5e 4c       	retge	r12
8000b2f8:	e0 6a 46 c8 	mov	r10,18120
8000b2fc:	95 0b       	st.w	r10[0x0],r11
8000b2fe:	5e fc       	retal	r12

8000b300 <_fstat>:
8000b300:	d4 21       	pushm	r4-r7,lr
8000b302:	21 0d       	sub	sp,64
8000b304:	16 97       	mov	r7,r11
8000b306:	1a 9b       	mov	r11,sp
8000b308:	cf 2f       	rcall	8000b2ec <_fstat_host>
8000b30a:	c0 34       	brge	8000b310 <_fstat+0x10>
8000b30c:	3f fc       	mov	r12,-1
8000b30e:	c1 c8       	rjmp	8000b346 <_fstat+0x46>
8000b310:	40 08       	lddsp	r8,sp[0x0]
8000b312:	ae 08       	st.h	r7[0x0],r8
8000b314:	40 18       	lddsp	r8,sp[0x4]
8000b316:	ae 18       	st.h	r7[0x2],r8
8000b318:	40 28       	lddsp	r8,sp[0x8]
8000b31a:	8f 18       	st.w	r7[0x4],r8
8000b31c:	40 38       	lddsp	r8,sp[0xc]
8000b31e:	ae 48       	st.h	r7[0x8],r8
8000b320:	40 48       	lddsp	r8,sp[0x10]
8000b322:	ae 58       	st.h	r7[0xa],r8
8000b324:	40 58       	lddsp	r8,sp[0x14]
8000b326:	ae 68       	st.h	r7[0xc],r8
8000b328:	40 68       	lddsp	r8,sp[0x18]
8000b32a:	ae 78       	st.h	r7[0xe],r8
8000b32c:	40 88       	lddsp	r8,sp[0x20]
8000b32e:	8f 48       	st.w	r7[0x10],r8
8000b330:	40 a8       	lddsp	r8,sp[0x28]
8000b332:	8f b8       	st.w	r7[0x2c],r8
8000b334:	40 c8       	lddsp	r8,sp[0x30]
8000b336:	8f c8       	st.w	r7[0x30],r8
8000b338:	40 d8       	lddsp	r8,sp[0x34]
8000b33a:	8f 58       	st.w	r7[0x14],r8
8000b33c:	40 e8       	lddsp	r8,sp[0x38]
8000b33e:	30 0c       	mov	r12,0
8000b340:	8f 78       	st.w	r7[0x1c],r8
8000b342:	40 f8       	lddsp	r8,sp[0x3c]
8000b344:	8f 98       	st.w	r7[0x24],r8
8000b346:	2f 0d       	sub	sp,-64
8000b348:	d8 22       	popm	r4-r7,pc
8000b34a:	d7 03       	nop

8000b34c <_sbrk>:
8000b34c:	d4 01       	pushm	lr
8000b34e:	e0 68 13 5c 	mov	r8,4956
8000b352:	70 09       	ld.w	r9,r8[0x0]
8000b354:	58 09       	cp.w	r9,0
8000b356:	c0 41       	brne	8000b35e <_sbrk+0x12>
8000b358:	e0 69 46 d0 	mov	r9,18128
8000b35c:	91 09       	st.w	r8[0x0],r9
8000b35e:	e0 69 13 5c 	mov	r9,4956
8000b362:	e0 7a 70 00 	mov	r10,94208
8000b366:	72 08       	ld.w	r8,r9[0x0]
8000b368:	f0 0c 00 0c 	add	r12,r8,r12
8000b36c:	14 3c       	cp.w	r12,r10
8000b36e:	e0 8b 00 04 	brhi	8000b376 <_sbrk+0x2a>
8000b372:	93 0c       	st.w	r9[0x0],r12
8000b374:	c0 68       	rjmp	8000b380 <_sbrk+0x34>
8000b376:	e0 a0 18 2b 	rcall	8000e3cc <__errno>
8000b37a:	30 c8       	mov	r8,12
8000b37c:	99 08       	st.w	r12[0x0],r8
8000b37e:	3f f8       	mov	r8,-1
8000b380:	10 9c       	mov	r12,r8
8000b382:	d8 02       	popm	pc

8000b384 <get_arg>:
8000b384:	d4 31       	pushm	r0-r7,lr
8000b386:	20 8d       	sub	sp,32
8000b388:	fa c4 ff bc 	sub	r4,sp,-68
8000b38c:	50 4b       	stdsp	sp[0x10],r11
8000b38e:	68 2e       	ld.w	lr,r4[0x8]
8000b390:	50 58       	stdsp	sp[0x14],r8
8000b392:	12 96       	mov	r6,r9
8000b394:	7c 0b       	ld.w	r11,lr[0x0]
8000b396:	70 05       	ld.w	r5,r8[0x0]
8000b398:	50 6e       	stdsp	sp[0x18],lr
8000b39a:	58 0b       	cp.w	r11,0
8000b39c:	f4 0b 17 00 	moveq	r11,r10
8000b3a0:	68 03       	ld.w	r3,r4[0x0]
8000b3a2:	68 11       	ld.w	r1,r4[0x4]
8000b3a4:	40 49       	lddsp	r9,sp[0x10]
8000b3a6:	30 08       	mov	r8,0
8000b3a8:	c2 e9       	rjmp	8000b604 <get_arg+0x280>
8000b3aa:	2f fb       	sub	r11,-1
8000b3ac:	32 5c       	mov	r12,37
8000b3ae:	17 8a       	ld.ub	r10,r11[0x0]
8000b3b0:	f8 0a 18 00 	cp.b	r10,r12
8000b3b4:	5f 1e       	srne	lr
8000b3b6:	f0 0a 18 00 	cp.b	r10,r8
8000b3ba:	5f 1c       	srne	r12
8000b3bc:	fd ec 00 0c 	and	r12,lr,r12
8000b3c0:	f0 0c 18 00 	cp.b	r12,r8
8000b3c4:	cf 31       	brne	8000b3aa <get_arg+0x26>
8000b3c6:	58 0a       	cp.w	r10,0
8000b3c8:	e0 80 01 2b 	breq	8000b61e <get_arg+0x29a>
8000b3cc:	30 0c       	mov	r12,0
8000b3ce:	3f fa       	mov	r10,-1
8000b3d0:	18 90       	mov	r0,r12
8000b3d2:	50 3a       	stdsp	sp[0xc],r10
8000b3d4:	18 94       	mov	r4,r12
8000b3d6:	18 92       	mov	r2,r12
8000b3d8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000b3dc:	16 97       	mov	r7,r11
8000b3de:	50 7c       	stdsp	sp[0x1c],r12
8000b3e0:	4c ec       	lddpc	r12,8000b518 <get_arg+0x194>
8000b3e2:	0f 3a       	ld.ub	r10,r7++
8000b3e4:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000b3e8:	40 7c       	lddsp	r12,sp[0x1c]
8000b3ea:	1c 0c       	add	r12,lr
8000b3ec:	4c ce       	lddpc	lr,8000b51c <get_arg+0x198>
8000b3ee:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000b3f2:	20 1e       	sub	lr,1
8000b3f4:	50 0e       	stdsp	sp[0x0],lr
8000b3f6:	4c be       	lddpc	lr,8000b520 <get_arg+0x19c>
8000b3f8:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000b3fc:	50 7c       	stdsp	sp[0x1c],r12
8000b3fe:	40 0c       	lddsp	r12,sp[0x0]
8000b400:	58 7c       	cp.w	r12,7
8000b402:	e0 8b 00 fa 	brhi	8000b5f6 <get_arg+0x272>
8000b406:	4c 8e       	lddpc	lr,8000b524 <get_arg+0x1a0>
8000b408:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000b40c:	36 8b       	mov	r11,104
8000b40e:	f6 0a 18 00 	cp.b	r10,r11
8000b412:	e0 80 00 f2 	breq	8000b5f6 <get_arg+0x272>
8000b416:	37 1b       	mov	r11,113
8000b418:	f6 0a 18 00 	cp.b	r10,r11
8000b41c:	c0 70       	breq	8000b42a <get_arg+0xa6>
8000b41e:	34 cb       	mov	r11,76
8000b420:	f6 0a 18 00 	cp.b	r10,r11
8000b424:	c0 51       	brne	8000b42e <get_arg+0xaa>
8000b426:	a3 b4       	sbr	r4,0x3
8000b428:	ce 78       	rjmp	8000b5f6 <get_arg+0x272>
8000b42a:	a5 b4       	sbr	r4,0x5
8000b42c:	ce 58       	rjmp	8000b5f6 <get_arg+0x272>
8000b42e:	08 9a       	mov	r10,r4
8000b430:	0e 9b       	mov	r11,r7
8000b432:	a5 aa       	sbr	r10,0x4
8000b434:	17 3c       	ld.ub	r12,r11++
8000b436:	a5 b4       	sbr	r4,0x5
8000b438:	36 ce       	mov	lr,108
8000b43a:	fc 0c 18 00 	cp.b	r12,lr
8000b43e:	e0 80 00 dd 	breq	8000b5f8 <get_arg+0x274>
8000b442:	14 94       	mov	r4,r10
8000b444:	cd 98       	rjmp	8000b5f6 <get_arg+0x272>
8000b446:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000b44a:	36 7c       	mov	r12,103
8000b44c:	f8 0a 18 00 	cp.b	r10,r12
8000b450:	e0 8b 00 27 	brhi	8000b49e <get_arg+0x11a>
8000b454:	36 5b       	mov	r11,101
8000b456:	f6 0a 18 00 	cp.b	r10,r11
8000b45a:	c4 82       	brcc	8000b4ea <get_arg+0x166>
8000b45c:	34 fb       	mov	r11,79
8000b45e:	f6 0a 18 00 	cp.b	r10,r11
8000b462:	c4 80       	breq	8000b4f2 <get_arg+0x16e>
8000b464:	e0 8b 00 0c 	brhi	8000b47c <get_arg+0xf8>
8000b468:	34 5b       	mov	r11,69
8000b46a:	f6 0a 18 00 	cp.b	r10,r11
8000b46e:	c3 e0       	breq	8000b4ea <get_arg+0x166>
8000b470:	34 7b       	mov	r11,71
8000b472:	f6 0a 18 00 	cp.b	r10,r11
8000b476:	c3 a0       	breq	8000b4ea <get_arg+0x166>
8000b478:	34 4b       	mov	r11,68
8000b47a:	c0 88       	rjmp	8000b48a <get_arg+0x106>
8000b47c:	35 8b       	mov	r11,88
8000b47e:	f6 0a 18 00 	cp.b	r10,r11
8000b482:	c2 c0       	breq	8000b4da <get_arg+0x156>
8000b484:	e0 8b 00 07 	brhi	8000b492 <get_arg+0x10e>
8000b488:	35 5b       	mov	r11,85
8000b48a:	f6 0a 18 00 	cp.b	r10,r11
8000b48e:	c3 51       	brne	8000b4f8 <get_arg+0x174>
8000b490:	c3 18       	rjmp	8000b4f2 <get_arg+0x16e>
8000b492:	36 3b       	mov	r11,99
8000b494:	f6 0a 18 00 	cp.b	r10,r11
8000b498:	c2 f0       	breq	8000b4f6 <get_arg+0x172>
8000b49a:	36 4b       	mov	r11,100
8000b49c:	c0 e8       	rjmp	8000b4b8 <get_arg+0x134>
8000b49e:	37 0b       	mov	r11,112
8000b4a0:	f6 0a 18 00 	cp.b	r10,r11
8000b4a4:	c2 50       	breq	8000b4ee <get_arg+0x16a>
8000b4a6:	e0 8b 00 0d 	brhi	8000b4c0 <get_arg+0x13c>
8000b4aa:	36 eb       	mov	r11,110
8000b4ac:	f6 0a 18 00 	cp.b	r10,r11
8000b4b0:	c1 f0       	breq	8000b4ee <get_arg+0x16a>
8000b4b2:	e0 8b 00 14 	brhi	8000b4da <get_arg+0x156>
8000b4b6:	36 9b       	mov	r11,105
8000b4b8:	f6 0a 18 00 	cp.b	r10,r11
8000b4bc:	c1 e1       	brne	8000b4f8 <get_arg+0x174>
8000b4be:	c0 e8       	rjmp	8000b4da <get_arg+0x156>
8000b4c0:	37 5b       	mov	r11,117
8000b4c2:	f6 0a 18 00 	cp.b	r10,r11
8000b4c6:	c0 a0       	breq	8000b4da <get_arg+0x156>
8000b4c8:	37 8b       	mov	r11,120
8000b4ca:	f6 0a 18 00 	cp.b	r10,r11
8000b4ce:	c0 60       	breq	8000b4da <get_arg+0x156>
8000b4d0:	37 3b       	mov	r11,115
8000b4d2:	f6 0a 18 00 	cp.b	r10,r11
8000b4d6:	c1 11       	brne	8000b4f8 <get_arg+0x174>
8000b4d8:	c0 b8       	rjmp	8000b4ee <get_arg+0x16a>
8000b4da:	ed b4 00 04 	bld	r4,0x4
8000b4de:	c0 a0       	breq	8000b4f2 <get_arg+0x16e>
8000b4e0:	ed b4 00 05 	bld	r4,0x5
8000b4e4:	c0 91       	brne	8000b4f6 <get_arg+0x172>
8000b4e6:	30 20       	mov	r0,2
8000b4e8:	c0 88       	rjmp	8000b4f8 <get_arg+0x174>
8000b4ea:	30 40       	mov	r0,4
8000b4ec:	c0 68       	rjmp	8000b4f8 <get_arg+0x174>
8000b4ee:	30 30       	mov	r0,3
8000b4f0:	c0 48       	rjmp	8000b4f8 <get_arg+0x174>
8000b4f2:	30 10       	mov	r0,1
8000b4f4:	c0 28       	rjmp	8000b4f8 <get_arg+0x174>
8000b4f6:	30 00       	mov	r0,0
8000b4f8:	40 3b       	lddsp	r11,sp[0xc]
8000b4fa:	5b fb       	cp.w	r11,-1
8000b4fc:	c0 40       	breq	8000b504 <get_arg+0x180>
8000b4fe:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000b502:	c7 a8       	rjmp	8000b5f6 <get_arg+0x272>
8000b504:	58 60       	cp.w	r0,6
8000b506:	e0 8b 00 78 	brhi	8000b5f6 <get_arg+0x272>
8000b50a:	6c 0a       	ld.w	r10,r6[0x0]
8000b50c:	ea cc ff ff 	sub	r12,r5,-1
8000b510:	48 6e       	lddpc	lr,8000b528 <get_arg+0x1a4>
8000b512:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000b516:	d7 03       	nop
8000b518:	80 01       	ld.sh	r1,r0[0x0]
8000b51a:	9f 98       	st.w	pc[0x24],r8
8000b51c:	80 01       	ld.sh	r1,r0[0x0]
8000b51e:	9e d0       	ld.uh	r0,pc[0xa]
8000b520:	80 01       	ld.sh	r1,r0[0x0]
8000b522:	9e 64       	ld.sh	r4,pc[0xc]
8000b524:	80 01       	ld.sh	r1,r0[0x0]
8000b526:	9c c4       	ld.uh	r4,lr[0x8]
8000b528:	80 01       	ld.sh	r1,r0[0x0]
8000b52a:	9c e4       	ld.uh	r4,lr[0xc]
8000b52c:	f4 cb ff f8 	sub	r11,r10,-8
8000b530:	8d 0b       	st.w	r6[0x0],r11
8000b532:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b536:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b53a:	c0 f8       	rjmp	8000b558 <get_arg+0x1d4>
8000b53c:	f4 cb ff fc 	sub	r11,r10,-4
8000b540:	8d 0b       	st.w	r6[0x0],r11
8000b542:	74 0a       	ld.w	r10,r10[0x0]
8000b544:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b548:	c0 88       	rjmp	8000b558 <get_arg+0x1d4>
8000b54a:	f4 cb ff f8 	sub	r11,r10,-8
8000b54e:	8d 0b       	st.w	r6[0x0],r11
8000b550:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b554:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b558:	0e 9b       	mov	r11,r7
8000b55a:	18 95       	mov	r5,r12
8000b55c:	c4 e8       	rjmp	8000b5f8 <get_arg+0x274>
8000b55e:	62 0a       	ld.w	r10,r1[0x0]
8000b560:	5b fa       	cp.w	r10,-1
8000b562:	c0 b1       	brne	8000b578 <get_arg+0x1f4>
8000b564:	50 19       	stdsp	sp[0x4],r9
8000b566:	50 28       	stdsp	sp[0x8],r8
8000b568:	e0 6a 00 80 	mov	r10,128
8000b56c:	30 0b       	mov	r11,0
8000b56e:	02 9c       	mov	r12,r1
8000b570:	fe b0 fc 6f 	rcall	8000ae4e <memset>
8000b574:	40 28       	lddsp	r8,sp[0x8]
8000b576:	40 19       	lddsp	r9,sp[0x4]
8000b578:	e4 cc 00 01 	sub	r12,r2,1
8000b57c:	0e 9b       	mov	r11,r7
8000b57e:	50 3c       	stdsp	sp[0xc],r12
8000b580:	f2 0c 0c 49 	max	r9,r9,r12
8000b584:	c3 a8       	rjmp	8000b5f8 <get_arg+0x274>
8000b586:	62 0a       	ld.w	r10,r1[0x0]
8000b588:	5b fa       	cp.w	r10,-1
8000b58a:	c0 b1       	brne	8000b5a0 <get_arg+0x21c>
8000b58c:	50 19       	stdsp	sp[0x4],r9
8000b58e:	50 28       	stdsp	sp[0x8],r8
8000b590:	e0 6a 00 80 	mov	r10,128
8000b594:	30 0b       	mov	r11,0
8000b596:	02 9c       	mov	r12,r1
8000b598:	fe b0 fc 5b 	rcall	8000ae4e <memset>
8000b59c:	40 28       	lddsp	r8,sp[0x8]
8000b59e:	40 19       	lddsp	r9,sp[0x4]
8000b5a0:	20 12       	sub	r2,1
8000b5a2:	30 0a       	mov	r10,0
8000b5a4:	0e 9b       	mov	r11,r7
8000b5a6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000b5aa:	f2 02 0c 49 	max	r9,r9,r2
8000b5ae:	c2 58       	rjmp	8000b5f8 <get_arg+0x274>
8000b5b0:	16 97       	mov	r7,r11
8000b5b2:	6c 0a       	ld.w	r10,r6[0x0]
8000b5b4:	f4 cb ff fc 	sub	r11,r10,-4
8000b5b8:	8d 0b       	st.w	r6[0x0],r11
8000b5ba:	74 0a       	ld.w	r10,r10[0x0]
8000b5bc:	0e 9b       	mov	r11,r7
8000b5be:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b5c2:	2f f5       	sub	r5,-1
8000b5c4:	c1 a8       	rjmp	8000b5f8 <get_arg+0x274>
8000b5c6:	f4 c2 00 30 	sub	r2,r10,48
8000b5ca:	c0 68       	rjmp	8000b5d6 <get_arg+0x252>
8000b5cc:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000b5d0:	2f f7       	sub	r7,-1
8000b5d2:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000b5d6:	0f 8a       	ld.ub	r10,r7[0x0]
8000b5d8:	58 0a       	cp.w	r10,0
8000b5da:	c0 e0       	breq	8000b5f6 <get_arg+0x272>
8000b5dc:	23 0a       	sub	r10,48
8000b5de:	58 9a       	cp.w	r10,9
8000b5e0:	fe 98 ff f6 	brls	8000b5cc <get_arg+0x248>
8000b5e4:	c0 98       	rjmp	8000b5f6 <get_arg+0x272>
8000b5e6:	2f f7       	sub	r7,-1
8000b5e8:	0f 8a       	ld.ub	r10,r7[0x0]
8000b5ea:	58 0a       	cp.w	r10,0
8000b5ec:	c0 50       	breq	8000b5f6 <get_arg+0x272>
8000b5ee:	23 0a       	sub	r10,48
8000b5f0:	58 9a       	cp.w	r10,9
8000b5f2:	fe 98 ff fa 	brls	8000b5e6 <get_arg+0x262>
8000b5f6:	0e 9b       	mov	r11,r7
8000b5f8:	40 7c       	lddsp	r12,sp[0x1c]
8000b5fa:	30 ba       	mov	r10,11
8000b5fc:	f4 0c 18 00 	cp.b	r12,r10
8000b600:	fe 91 fe ec 	brne	8000b3d8 <get_arg+0x54>
8000b604:	40 42       	lddsp	r2,sp[0x10]
8000b606:	17 8c       	ld.ub	r12,r11[0x0]
8000b608:	0a 32       	cp.w	r2,r5
8000b60a:	5f 4a       	srge	r10
8000b60c:	f0 0c 18 00 	cp.b	r12,r8
8000b610:	5f 1c       	srne	r12
8000b612:	f9 ea 00 0a 	and	r10,r12,r10
8000b616:	f0 0a 18 00 	cp.b	r10,r8
8000b61a:	fe 91 fe c9 	brne	8000b3ac <get_arg+0x28>
8000b61e:	30 08       	mov	r8,0
8000b620:	40 4e       	lddsp	lr,sp[0x10]
8000b622:	17 8a       	ld.ub	r10,r11[0x0]
8000b624:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000b628:	f0 0a 18 00 	cp.b	r10,r8
8000b62c:	fc 09 17 10 	movne	r9,lr
8000b630:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000b634:	06 9e       	mov	lr,r3
8000b636:	c2 a8       	rjmp	8000b68a <get_arg+0x306>
8000b638:	62 0a       	ld.w	r10,r1[0x0]
8000b63a:	58 3a       	cp.w	r10,3
8000b63c:	c1 e0       	breq	8000b678 <get_arg+0x2f4>
8000b63e:	e0 89 00 07 	brgt	8000b64c <get_arg+0x2c8>
8000b642:	58 1a       	cp.w	r10,1
8000b644:	c1 a0       	breq	8000b678 <get_arg+0x2f4>
8000b646:	58 2a       	cp.w	r10,2
8000b648:	c1 81       	brne	8000b678 <get_arg+0x2f4>
8000b64a:	c0 58       	rjmp	8000b654 <get_arg+0x2d0>
8000b64c:	58 5a       	cp.w	r10,5
8000b64e:	c0 c0       	breq	8000b666 <get_arg+0x2e2>
8000b650:	c0 b5       	brlt	8000b666 <get_arg+0x2e2>
8000b652:	c1 38       	rjmp	8000b678 <get_arg+0x2f4>
8000b654:	6c 0a       	ld.w	r10,r6[0x0]
8000b656:	f4 cc ff f8 	sub	r12,r10,-8
8000b65a:	8d 0c       	st.w	r6[0x0],r12
8000b65c:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b660:	f0 e3 00 00 	st.d	r8[0],r2
8000b664:	c1 08       	rjmp	8000b684 <get_arg+0x300>
8000b666:	6c 0a       	ld.w	r10,r6[0x0]
8000b668:	f4 cc ff f8 	sub	r12,r10,-8
8000b66c:	8d 0c       	st.w	r6[0x0],r12
8000b66e:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b672:	f0 e3 00 00 	st.d	r8[0],r2
8000b676:	c0 78       	rjmp	8000b684 <get_arg+0x300>
8000b678:	6c 0a       	ld.w	r10,r6[0x0]
8000b67a:	f4 cc ff fc 	sub	r12,r10,-4
8000b67e:	8d 0c       	st.w	r6[0x0],r12
8000b680:	74 0a       	ld.w	r10,r10[0x0]
8000b682:	91 0a       	st.w	r8[0x0],r10
8000b684:	2f f5       	sub	r5,-1
8000b686:	2f 88       	sub	r8,-8
8000b688:	2f c1       	sub	r1,-4
8000b68a:	12 35       	cp.w	r5,r9
8000b68c:	fe 9a ff d6 	brle	8000b638 <get_arg+0x2b4>
8000b690:	1c 93       	mov	r3,lr
8000b692:	40 52       	lddsp	r2,sp[0x14]
8000b694:	40 6e       	lddsp	lr,sp[0x18]
8000b696:	85 05       	st.w	r2[0x0],r5
8000b698:	9d 0b       	st.w	lr[0x0],r11
8000b69a:	40 4b       	lddsp	r11,sp[0x10]
8000b69c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000b6a0:	2f 8d       	sub	sp,-32
8000b6a2:	d8 32       	popm	r0-r7,pc

8000b6a4 <__sprint_r>:
8000b6a4:	d4 21       	pushm	r4-r7,lr
8000b6a6:	14 97       	mov	r7,r10
8000b6a8:	74 28       	ld.w	r8,r10[0x8]
8000b6aa:	58 08       	cp.w	r8,0
8000b6ac:	c0 41       	brne	8000b6b4 <__sprint_r+0x10>
8000b6ae:	95 18       	st.w	r10[0x4],r8
8000b6b0:	10 9c       	mov	r12,r8
8000b6b2:	d8 22       	popm	r4-r7,pc
8000b6b4:	e0 a0 18 ce 	rcall	8000e850 <__sfvwrite_r>
8000b6b8:	30 08       	mov	r8,0
8000b6ba:	8f 18       	st.w	r7[0x4],r8
8000b6bc:	8f 28       	st.w	r7[0x8],r8
8000b6be:	d8 22       	popm	r4-r7,pc

8000b6c0 <_vfprintf_r>:
8000b6c0:	d4 31       	pushm	r0-r7,lr
8000b6c2:	fa cd 06 bc 	sub	sp,sp,1724
8000b6c6:	51 09       	stdsp	sp[0x40],r9
8000b6c8:	16 91       	mov	r1,r11
8000b6ca:	14 97       	mov	r7,r10
8000b6cc:	18 95       	mov	r5,r12
8000b6ce:	e0 a0 1a 31 	rcall	8000eb30 <_localeconv_r>
8000b6d2:	78 0c       	ld.w	r12,r12[0x0]
8000b6d4:	50 cc       	stdsp	sp[0x30],r12
8000b6d6:	58 05       	cp.w	r5,0
8000b6d8:	c0 70       	breq	8000b6e6 <_vfprintf_r+0x26>
8000b6da:	6a 68       	ld.w	r8,r5[0x18]
8000b6dc:	58 08       	cp.w	r8,0
8000b6de:	c0 41       	brne	8000b6e6 <_vfprintf_r+0x26>
8000b6e0:	0a 9c       	mov	r12,r5
8000b6e2:	e0 a0 17 57 	rcall	8000e590 <__sinit>
8000b6e6:	4d 08       	lddpc	r8,8000b824 <_vfprintf_r+0x164>
8000b6e8:	10 31       	cp.w	r1,r8
8000b6ea:	c0 31       	brne	8000b6f0 <_vfprintf_r+0x30>
8000b6ec:	6a 01       	ld.w	r1,r5[0x0]
8000b6ee:	c0 a8       	rjmp	8000b702 <_vfprintf_r+0x42>
8000b6f0:	4c e8       	lddpc	r8,8000b828 <_vfprintf_r+0x168>
8000b6f2:	10 31       	cp.w	r1,r8
8000b6f4:	c0 31       	brne	8000b6fa <_vfprintf_r+0x3a>
8000b6f6:	6a 11       	ld.w	r1,r5[0x4]
8000b6f8:	c0 58       	rjmp	8000b702 <_vfprintf_r+0x42>
8000b6fa:	4c d8       	lddpc	r8,8000b82c <_vfprintf_r+0x16c>
8000b6fc:	10 31       	cp.w	r1,r8
8000b6fe:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000b702:	82 68       	ld.sh	r8,r1[0xc]
8000b704:	ed b8 00 03 	bld	r8,0x3
8000b708:	c0 41       	brne	8000b710 <_vfprintf_r+0x50>
8000b70a:	62 48       	ld.w	r8,r1[0x10]
8000b70c:	58 08       	cp.w	r8,0
8000b70e:	c0 71       	brne	8000b71c <_vfprintf_r+0x5c>
8000b710:	02 9b       	mov	r11,r1
8000b712:	0a 9c       	mov	r12,r5
8000b714:	e0 a0 0f 6c 	rcall	8000d5ec <__swsetup_r>
8000b718:	e0 81 0f 63 	brne	8000d5de <_vfprintf_r+0x1f1e>
8000b71c:	82 68       	ld.sh	r8,r1[0xc]
8000b71e:	10 99       	mov	r9,r8
8000b720:	e2 19 00 1a 	andl	r9,0x1a,COH
8000b724:	58 a9       	cp.w	r9,10
8000b726:	c3 c1       	brne	8000b79e <_vfprintf_r+0xde>
8000b728:	82 79       	ld.sh	r9,r1[0xe]
8000b72a:	30 0a       	mov	r10,0
8000b72c:	f4 09 19 00 	cp.h	r9,r10
8000b730:	c3 75       	brlt	8000b79e <_vfprintf_r+0xde>
8000b732:	a1 d8       	cbr	r8,0x1
8000b734:	fb 58 05 d0 	st.h	sp[1488],r8
8000b738:	62 88       	ld.w	r8,r1[0x20]
8000b73a:	fb 48 05 e4 	st.w	sp[1508],r8
8000b73e:	62 a8       	ld.w	r8,r1[0x28]
8000b740:	fb 48 05 ec 	st.w	sp[1516],r8
8000b744:	fa c8 ff bc 	sub	r8,sp,-68
8000b748:	fb 48 05 d4 	st.w	sp[1492],r8
8000b74c:	fb 48 05 c4 	st.w	sp[1476],r8
8000b750:	e0 68 04 00 	mov	r8,1024
8000b754:	fb 48 05 d8 	st.w	sp[1496],r8
8000b758:	fb 48 05 cc 	st.w	sp[1484],r8
8000b75c:	30 08       	mov	r8,0
8000b75e:	fb 59 05 d2 	st.h	sp[1490],r9
8000b762:	0e 9a       	mov	r10,r7
8000b764:	41 09       	lddsp	r9,sp[0x40]
8000b766:	fa c7 fa 3c 	sub	r7,sp,-1476
8000b76a:	fb 48 05 dc 	st.w	sp[1500],r8
8000b76e:	0a 9c       	mov	r12,r5
8000b770:	0e 9b       	mov	r11,r7
8000b772:	ca 7f       	rcall	8000b6c0 <_vfprintf_r>
8000b774:	50 bc       	stdsp	sp[0x2c],r12
8000b776:	c0 95       	brlt	8000b788 <_vfprintf_r+0xc8>
8000b778:	0e 9b       	mov	r11,r7
8000b77a:	0a 9c       	mov	r12,r5
8000b77c:	e0 a0 16 2e 	rcall	8000e3d8 <_fflush_r>
8000b780:	40 be       	lddsp	lr,sp[0x2c]
8000b782:	f9 be 01 ff 	movne	lr,-1
8000b786:	50 be       	stdsp	sp[0x2c],lr
8000b788:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000b78c:	ed b8 00 06 	bld	r8,0x6
8000b790:	e0 81 0f 29 	brne	8000d5e2 <_vfprintf_r+0x1f22>
8000b794:	82 68       	ld.sh	r8,r1[0xc]
8000b796:	a7 a8       	sbr	r8,0x6
8000b798:	a2 68       	st.h	r1[0xc],r8
8000b79a:	e0 8f 0f 24 	bral	8000d5e2 <_vfprintf_r+0x1f22>
8000b79e:	30 08       	mov	r8,0
8000b7a0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b7a4:	fb 48 06 90 	st.w	sp[1680],r8
8000b7a8:	fb 48 06 8c 	st.w	sp[1676],r8
8000b7ac:	fb 48 06 b0 	st.w	sp[1712],r8
8000b7b0:	30 08       	mov	r8,0
8000b7b2:	30 09       	mov	r9,0
8000b7b4:	50 a7       	stdsp	sp[0x28],r7
8000b7b6:	50 78       	stdsp	sp[0x1c],r8
8000b7b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b7bc:	3f f8       	mov	r8,-1
8000b7be:	50 59       	stdsp	sp[0x14],r9
8000b7c0:	fb 43 06 88 	st.w	sp[1672],r3
8000b7c4:	fb 48 05 44 	st.w	sp[1348],r8
8000b7c8:	12 9c       	mov	r12,r9
8000b7ca:	50 69       	stdsp	sp[0x18],r9
8000b7cc:	50 d9       	stdsp	sp[0x34],r9
8000b7ce:	50 e9       	stdsp	sp[0x38],r9
8000b7d0:	50 b9       	stdsp	sp[0x2c],r9
8000b7d2:	12 97       	mov	r7,r9
8000b7d4:	0a 94       	mov	r4,r5
8000b7d6:	40 a2       	lddsp	r2,sp[0x28]
8000b7d8:	32 5a       	mov	r10,37
8000b7da:	30 08       	mov	r8,0
8000b7dc:	c0 28       	rjmp	8000b7e0 <_vfprintf_r+0x120>
8000b7de:	2f f2       	sub	r2,-1
8000b7e0:	05 89       	ld.ub	r9,r2[0x0]
8000b7e2:	f0 09 18 00 	cp.b	r9,r8
8000b7e6:	5f 1b       	srne	r11
8000b7e8:	f4 09 18 00 	cp.b	r9,r10
8000b7ec:	5f 19       	srne	r9
8000b7ee:	f3 eb 00 0b 	and	r11,r9,r11
8000b7f2:	f0 0b 18 00 	cp.b	r11,r8
8000b7f6:	cf 41       	brne	8000b7de <_vfprintf_r+0x11e>
8000b7f8:	40 ab       	lddsp	r11,sp[0x28]
8000b7fa:	e4 0b 01 06 	sub	r6,r2,r11
8000b7fe:	c2 50       	breq	8000b848 <_vfprintf_r+0x188>
8000b800:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b804:	0c 08       	add	r8,r6
8000b806:	87 0b       	st.w	r3[0x0],r11
8000b808:	fb 48 06 90 	st.w	sp[1680],r8
8000b80c:	87 16       	st.w	r3[0x4],r6
8000b80e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b812:	2f f8       	sub	r8,-1
8000b814:	fb 48 06 8c 	st.w	sp[1676],r8
8000b818:	58 78       	cp.w	r8,7
8000b81a:	e0 89 00 0b 	brgt	8000b830 <_vfprintf_r+0x170>
8000b81e:	2f 83       	sub	r3,-8
8000b820:	c1 18       	rjmp	8000b842 <_vfprintf_r+0x182>
8000b822:	d7 03       	nop
8000b824:	80 01       	ld.sh	r1,r0[0x0]
8000b826:	a0 a8       	st.b	r0[0x2],r8
8000b828:	80 01       	ld.sh	r1,r0[0x0]
8000b82a:	a0 c8       	st.b	r0[0x4],r8
8000b82c:	80 01       	ld.sh	r1,r0[0x0]
8000b82e:	a0 e8       	st.b	r0[0x6],r8
8000b830:	fa ca f9 78 	sub	r10,sp,-1672
8000b834:	02 9b       	mov	r11,r1
8000b836:	08 9c       	mov	r12,r4
8000b838:	c3 6f       	rcall	8000b6a4 <__sprint_r>
8000b83a:	e0 81 0e ce 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000b83e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b842:	40 ba       	lddsp	r10,sp[0x2c]
8000b844:	0c 0a       	add	r10,r6
8000b846:	50 ba       	stdsp	sp[0x2c],r10
8000b848:	05 89       	ld.ub	r9,r2[0x0]
8000b84a:	30 08       	mov	r8,0
8000b84c:	f0 09 18 00 	cp.b	r9,r8
8000b850:	e0 80 0e b2 	breq	8000d5b4 <_vfprintf_r+0x1ef4>
8000b854:	30 09       	mov	r9,0
8000b856:	fb 68 06 bb 	st.b	sp[1723],r8
8000b85a:	0e 96       	mov	r6,r7
8000b85c:	e4 c8 ff ff 	sub	r8,r2,-1
8000b860:	3f fe       	mov	lr,-1
8000b862:	50 93       	stdsp	sp[0x24],r3
8000b864:	50 41       	stdsp	sp[0x10],r1
8000b866:	0e 93       	mov	r3,r7
8000b868:	04 91       	mov	r1,r2
8000b86a:	50 89       	stdsp	sp[0x20],r9
8000b86c:	50 a8       	stdsp	sp[0x28],r8
8000b86e:	50 2e       	stdsp	sp[0x8],lr
8000b870:	50 39       	stdsp	sp[0xc],r9
8000b872:	12 95       	mov	r5,r9
8000b874:	12 90       	mov	r0,r9
8000b876:	10 97       	mov	r7,r8
8000b878:	08 92       	mov	r2,r4
8000b87a:	c0 78       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000b87c:	3f fc       	mov	r12,-1
8000b87e:	08 97       	mov	r7,r4
8000b880:	50 2c       	stdsp	sp[0x8],r12
8000b882:	c0 38       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000b884:	30 0b       	mov	r11,0
8000b886:	50 3b       	stdsp	sp[0xc],r11
8000b888:	0f 38       	ld.ub	r8,r7++
8000b88a:	c0 28       	rjmp	8000b88e <_vfprintf_r+0x1ce>
8000b88c:	12 90       	mov	r0,r9
8000b88e:	f0 c9 00 20 	sub	r9,r8,32
8000b892:	e0 49 00 58 	cp.w	r9,88
8000b896:	e0 8b 0a 36 	brhi	8000cd02 <_vfprintf_r+0x1642>
8000b89a:	4d 9a       	lddpc	r10,8000b9fc <_vfprintf_r+0x33c>
8000b89c:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b8a0:	50 a7       	stdsp	sp[0x28],r7
8000b8a2:	50 80       	stdsp	sp[0x20],r0
8000b8a4:	0c 97       	mov	r7,r6
8000b8a6:	04 94       	mov	r4,r2
8000b8a8:	06 96       	mov	r6,r3
8000b8aa:	02 92       	mov	r2,r1
8000b8ac:	4d 59       	lddpc	r9,8000ba00 <_vfprintf_r+0x340>
8000b8ae:	40 93       	lddsp	r3,sp[0x24]
8000b8b0:	10 90       	mov	r0,r8
8000b8b2:	40 41       	lddsp	r1,sp[0x10]
8000b8b4:	50 d9       	stdsp	sp[0x34],r9
8000b8b6:	e0 8f 08 95 	bral	8000c9e0 <_vfprintf_r+0x1320>
8000b8ba:	30 08       	mov	r8,0
8000b8bc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b8c0:	f0 09 18 00 	cp.b	r9,r8
8000b8c4:	ce 21       	brne	8000b888 <_vfprintf_r+0x1c8>
8000b8c6:	32 08       	mov	r8,32
8000b8c8:	c6 e8       	rjmp	8000b9a4 <_vfprintf_r+0x2e4>
8000b8ca:	a1 a5       	sbr	r5,0x0
8000b8cc:	cd eb       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000b8ce:	0f 89       	ld.ub	r9,r7[0x0]
8000b8d0:	f2 c8 00 30 	sub	r8,r9,48
8000b8d4:	58 98       	cp.w	r8,9
8000b8d6:	e0 8b 00 1d 	brhi	8000b910 <_vfprintf_r+0x250>
8000b8da:	ee c8 ff ff 	sub	r8,r7,-1
8000b8de:	30 0b       	mov	r11,0
8000b8e0:	23 09       	sub	r9,48
8000b8e2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b8e6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b8ea:	11 39       	ld.ub	r9,r8++
8000b8ec:	f2 ca 00 30 	sub	r10,r9,48
8000b8f0:	58 9a       	cp.w	r10,9
8000b8f2:	fe 98 ff f7 	brls	8000b8e0 <_vfprintf_r+0x220>
8000b8f6:	e0 49 00 24 	cp.w	r9,36
8000b8fa:	cc 51       	brne	8000b884 <_vfprintf_r+0x1c4>
8000b8fc:	e0 4b 00 20 	cp.w	r11,32
8000b900:	e0 89 0e 6a 	brgt	8000d5d4 <_vfprintf_r+0x1f14>
8000b904:	20 1b       	sub	r11,1
8000b906:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b90a:	12 3b       	cp.w	r11,r9
8000b90c:	c0 95       	brlt	8000b91e <_vfprintf_r+0x25e>
8000b90e:	c1 08       	rjmp	8000b92e <_vfprintf_r+0x26e>
8000b910:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b914:	ec ca ff ff 	sub	r10,r6,-1
8000b918:	12 36       	cp.w	r6,r9
8000b91a:	c1 f5       	brlt	8000b958 <_vfprintf_r+0x298>
8000b91c:	c2 68       	rjmp	8000b968 <_vfprintf_r+0x2a8>
8000b91e:	fa ce f9 44 	sub	lr,sp,-1724
8000b922:	10 97       	mov	r7,r8
8000b924:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b928:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b92c:	c3 58       	rjmp	8000b996 <_vfprintf_r+0x2d6>
8000b92e:	10 97       	mov	r7,r8
8000b930:	fa c8 f9 50 	sub	r8,sp,-1712
8000b934:	1a d8       	st.w	--sp,r8
8000b936:	fa c8 fa b8 	sub	r8,sp,-1352
8000b93a:	1a d8       	st.w	--sp,r8
8000b93c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b940:	02 9a       	mov	r10,r1
8000b942:	1a d8       	st.w	--sp,r8
8000b944:	04 9c       	mov	r12,r2
8000b946:	fa c8 f9 40 	sub	r8,sp,-1728
8000b94a:	fa c9 ff b4 	sub	r9,sp,-76
8000b94e:	fe b0 fd 1b 	rcall	8000b384 <get_arg>
8000b952:	2f dd       	sub	sp,-12
8000b954:	78 00       	ld.w	r0,r12[0x0]
8000b956:	c2 08       	rjmp	8000b996 <_vfprintf_r+0x2d6>
8000b958:	fa cc f9 44 	sub	r12,sp,-1724
8000b95c:	14 96       	mov	r6,r10
8000b95e:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b962:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b966:	c1 88       	rjmp	8000b996 <_vfprintf_r+0x2d6>
8000b968:	41 08       	lddsp	r8,sp[0x40]
8000b96a:	59 f9       	cp.w	r9,31
8000b96c:	e0 89 00 11 	brgt	8000b98e <_vfprintf_r+0x2ce>
8000b970:	f0 cb ff fc 	sub	r11,r8,-4
8000b974:	51 0b       	stdsp	sp[0x40],r11
8000b976:	70 00       	ld.w	r0,r8[0x0]
8000b978:	fa cb f9 44 	sub	r11,sp,-1724
8000b97c:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b980:	f1 40 fd 88 	st.w	r8[-632],r0
8000b984:	2f f9       	sub	r9,-1
8000b986:	14 96       	mov	r6,r10
8000b988:	fb 49 06 b4 	st.w	sp[1716],r9
8000b98c:	c0 58       	rjmp	8000b996 <_vfprintf_r+0x2d6>
8000b98e:	70 00       	ld.w	r0,r8[0x0]
8000b990:	14 96       	mov	r6,r10
8000b992:	2f c8       	sub	r8,-4
8000b994:	51 08       	stdsp	sp[0x40],r8
8000b996:	58 00       	cp.w	r0,0
8000b998:	fe 94 ff 78 	brge	8000b888 <_vfprintf_r+0x1c8>
8000b99c:	5c 30       	neg	r0
8000b99e:	a3 a5       	sbr	r5,0x2
8000b9a0:	c7 4b       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000b9a2:	32 b8       	mov	r8,43
8000b9a4:	fb 68 06 bb 	st.b	sp[1723],r8
8000b9a8:	c7 0b       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000b9aa:	0f 38       	ld.ub	r8,r7++
8000b9ac:	e0 48 00 2a 	cp.w	r8,42
8000b9b0:	c0 30       	breq	8000b9b6 <_vfprintf_r+0x2f6>
8000b9b2:	30 09       	mov	r9,0
8000b9b4:	c7 d8       	rjmp	8000baae <_vfprintf_r+0x3ee>
8000b9b6:	0f 88       	ld.ub	r8,r7[0x0]
8000b9b8:	f0 c9 00 30 	sub	r9,r8,48
8000b9bc:	58 99       	cp.w	r9,9
8000b9be:	e0 8b 00 23 	brhi	8000ba04 <_vfprintf_r+0x344>
8000b9c2:	ee c4 ff ff 	sub	r4,r7,-1
8000b9c6:	30 0b       	mov	r11,0
8000b9c8:	23 08       	sub	r8,48
8000b9ca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b9ce:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b9d2:	09 38       	ld.ub	r8,r4++
8000b9d4:	f0 c9 00 30 	sub	r9,r8,48
8000b9d8:	58 99       	cp.w	r9,9
8000b9da:	fe 98 ff f7 	brls	8000b9c8 <_vfprintf_r+0x308>
8000b9de:	e0 48 00 24 	cp.w	r8,36
8000b9e2:	fe 91 ff 51 	brne	8000b884 <_vfprintf_r+0x1c4>
8000b9e6:	e0 4b 00 20 	cp.w	r11,32
8000b9ea:	e0 89 0d f5 	brgt	8000d5d4 <_vfprintf_r+0x1f14>
8000b9ee:	20 1b       	sub	r11,1
8000b9f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b9f4:	10 3b       	cp.w	r11,r8
8000b9f6:	c0 e5       	brlt	8000ba12 <_vfprintf_r+0x352>
8000b9f8:	c1 58       	rjmp	8000ba22 <_vfprintf_r+0x362>
8000b9fa:	d7 03       	nop
8000b9fc:	80 01       	ld.sh	r1,r0[0x0]
8000b9fe:	9d 00       	st.w	lr[0x0],r0
8000ba00:	80 01       	ld.sh	r1,r0[0x0]
8000ba02:	9f 3c       	st.w	pc[0xc],r12
8000ba04:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000ba08:	ec c9 ff ff 	sub	r9,r6,-1
8000ba0c:	14 36       	cp.w	r6,r10
8000ba0e:	c1 f5       	brlt	8000ba4c <_vfprintf_r+0x38c>
8000ba10:	c2 88       	rjmp	8000ba60 <_vfprintf_r+0x3a0>
8000ba12:	fa ca f9 44 	sub	r10,sp,-1724
8000ba16:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000ba1a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000ba1e:	50 2b       	stdsp	sp[0x8],r11
8000ba20:	c3 c8       	rjmp	8000ba98 <_vfprintf_r+0x3d8>
8000ba22:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba26:	1a d8       	st.w	--sp,r8
8000ba28:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba2c:	1a d8       	st.w	--sp,r8
8000ba2e:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba32:	02 9a       	mov	r10,r1
8000ba34:	1a d8       	st.w	--sp,r8
8000ba36:	04 9c       	mov	r12,r2
8000ba38:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba3c:	fa c9 ff b4 	sub	r9,sp,-76
8000ba40:	fe b0 fc a2 	rcall	8000b384 <get_arg>
8000ba44:	2f dd       	sub	sp,-12
8000ba46:	78 0c       	ld.w	r12,r12[0x0]
8000ba48:	50 2c       	stdsp	sp[0x8],r12
8000ba4a:	c2 78       	rjmp	8000ba98 <_vfprintf_r+0x3d8>
8000ba4c:	12 96       	mov	r6,r9
8000ba4e:	0e 94       	mov	r4,r7
8000ba50:	fa c9 f9 44 	sub	r9,sp,-1724
8000ba54:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000ba58:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000ba5c:	50 28       	stdsp	sp[0x8],r8
8000ba5e:	c1 d8       	rjmp	8000ba98 <_vfprintf_r+0x3d8>
8000ba60:	41 08       	lddsp	r8,sp[0x40]
8000ba62:	59 fa       	cp.w	r10,31
8000ba64:	e0 89 00 14 	brgt	8000ba8c <_vfprintf_r+0x3cc>
8000ba68:	f0 cb ff fc 	sub	r11,r8,-4
8000ba6c:	70 08       	ld.w	r8,r8[0x0]
8000ba6e:	51 0b       	stdsp	sp[0x40],r11
8000ba70:	50 28       	stdsp	sp[0x8],r8
8000ba72:	fa c6 f9 44 	sub	r6,sp,-1724
8000ba76:	40 2e       	lddsp	lr,sp[0x8]
8000ba78:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000ba7c:	f1 4e fd 88 	st.w	r8[-632],lr
8000ba80:	2f fa       	sub	r10,-1
8000ba82:	0e 94       	mov	r4,r7
8000ba84:	fb 4a 06 b4 	st.w	sp[1716],r10
8000ba88:	12 96       	mov	r6,r9
8000ba8a:	c0 78       	rjmp	8000ba98 <_vfprintf_r+0x3d8>
8000ba8c:	70 0c       	ld.w	r12,r8[0x0]
8000ba8e:	0e 94       	mov	r4,r7
8000ba90:	2f c8       	sub	r8,-4
8000ba92:	50 2c       	stdsp	sp[0x8],r12
8000ba94:	12 96       	mov	r6,r9
8000ba96:	51 08       	stdsp	sp[0x40],r8
8000ba98:	40 2b       	lddsp	r11,sp[0x8]
8000ba9a:	58 0b       	cp.w	r11,0
8000ba9c:	fe 95 fe f0 	brlt	8000b87c <_vfprintf_r+0x1bc>
8000baa0:	08 97       	mov	r7,r4
8000baa2:	cf 3a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000baa4:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000baa8:	0f 38       	ld.ub	r8,r7++
8000baaa:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000baae:	f0 ca 00 30 	sub	r10,r8,48
8000bab2:	58 9a       	cp.w	r10,9
8000bab4:	fe 98 ff f8 	brls	8000baa4 <_vfprintf_r+0x3e4>
8000bab8:	3f fa       	mov	r10,-1
8000baba:	f2 0a 0c 49 	max	r9,r9,r10
8000babe:	50 29       	stdsp	sp[0x8],r9
8000bac0:	ce 7a       	rjmp	8000b88e <_vfprintf_r+0x1ce>
8000bac2:	a7 b5       	sbr	r5,0x7
8000bac4:	ce 2a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000bac6:	30 09       	mov	r9,0
8000bac8:	23 08       	sub	r8,48
8000baca:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000bace:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000bad2:	0f 38       	ld.ub	r8,r7++
8000bad4:	f0 ca 00 30 	sub	r10,r8,48
8000bad8:	58 9a       	cp.w	r10,9
8000bada:	fe 98 ff f7 	brls	8000bac8 <_vfprintf_r+0x408>
8000bade:	e0 48 00 24 	cp.w	r8,36
8000bae2:	fe 91 fe d5 	brne	8000b88c <_vfprintf_r+0x1cc>
8000bae6:	e0 49 00 20 	cp.w	r9,32
8000baea:	e0 89 0d 75 	brgt	8000d5d4 <_vfprintf_r+0x1f14>
8000baee:	f2 c3 00 01 	sub	r3,r9,1
8000baf2:	30 19       	mov	r9,1
8000baf4:	50 39       	stdsp	sp[0xc],r9
8000baf6:	cc 9a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000baf8:	a3 b5       	sbr	r5,0x3
8000bafa:	cc 7a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000bafc:	a7 a5       	sbr	r5,0x6
8000bafe:	cc 5a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000bb00:	0a 98       	mov	r8,r5
8000bb02:	a5 b5       	sbr	r5,0x5
8000bb04:	a5 a8       	sbr	r8,0x4
8000bb06:	0f 89       	ld.ub	r9,r7[0x0]
8000bb08:	36 ce       	mov	lr,108
8000bb0a:	fc 09 18 00 	cp.b	r9,lr
8000bb0e:	f7 b7 00 ff 	subeq	r7,-1
8000bb12:	f0 05 17 10 	movne	r5,r8
8000bb16:	cb 9a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000bb18:	a5 b5       	sbr	r5,0x5
8000bb1a:	cb 7a       	rjmp	8000b888 <_vfprintf_r+0x1c8>
8000bb1c:	50 a7       	stdsp	sp[0x28],r7
8000bb1e:	50 80       	stdsp	sp[0x20],r0
8000bb20:	0c 97       	mov	r7,r6
8000bb22:	10 90       	mov	r0,r8
8000bb24:	06 96       	mov	r6,r3
8000bb26:	04 94       	mov	r4,r2
8000bb28:	40 93       	lddsp	r3,sp[0x24]
8000bb2a:	02 92       	mov	r2,r1
8000bb2c:	0e 99       	mov	r9,r7
8000bb2e:	40 41       	lddsp	r1,sp[0x10]
8000bb30:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb34:	40 3c       	lddsp	r12,sp[0xc]
8000bb36:	58 0c       	cp.w	r12,0
8000bb38:	c1 d0       	breq	8000bb72 <_vfprintf_r+0x4b2>
8000bb3a:	10 36       	cp.w	r6,r8
8000bb3c:	c0 64       	brge	8000bb48 <_vfprintf_r+0x488>
8000bb3e:	fa cb f9 44 	sub	r11,sp,-1724
8000bb42:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb46:	c1 d8       	rjmp	8000bb80 <_vfprintf_r+0x4c0>
8000bb48:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb4c:	1a d8       	st.w	--sp,r8
8000bb4e:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb52:	1a d8       	st.w	--sp,r8
8000bb54:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb58:	1a d8       	st.w	--sp,r8
8000bb5a:	fa c8 f9 40 	sub	r8,sp,-1728
8000bb5e:	fa c9 ff b4 	sub	r9,sp,-76
8000bb62:	04 9a       	mov	r10,r2
8000bb64:	0c 9b       	mov	r11,r6
8000bb66:	08 9c       	mov	r12,r4
8000bb68:	fe b0 fc 0e 	rcall	8000b384 <get_arg>
8000bb6c:	2f dd       	sub	sp,-12
8000bb6e:	19 b8       	ld.ub	r8,r12[0x3]
8000bb70:	c2 28       	rjmp	8000bbb4 <_vfprintf_r+0x4f4>
8000bb72:	2f f7       	sub	r7,-1
8000bb74:	10 39       	cp.w	r9,r8
8000bb76:	c0 84       	brge	8000bb86 <_vfprintf_r+0x4c6>
8000bb78:	fa ca f9 44 	sub	r10,sp,-1724
8000bb7c:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bb80:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000bb84:	c1 88       	rjmp	8000bbb4 <_vfprintf_r+0x4f4>
8000bb86:	41 09       	lddsp	r9,sp[0x40]
8000bb88:	59 f8       	cp.w	r8,31
8000bb8a:	e0 89 00 12 	brgt	8000bbae <_vfprintf_r+0x4ee>
8000bb8e:	f2 ca ff fc 	sub	r10,r9,-4
8000bb92:	51 0a       	stdsp	sp[0x40],r10
8000bb94:	72 09       	ld.w	r9,r9[0x0]
8000bb96:	fa c6 f9 44 	sub	r6,sp,-1724
8000bb9a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000bb9e:	2f f8       	sub	r8,-1
8000bba0:	f5 49 fd 88 	st.w	r10[-632],r9
8000bba4:	fb 48 06 b4 	st.w	sp[1716],r8
8000bba8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000bbac:	c0 48       	rjmp	8000bbb4 <_vfprintf_r+0x4f4>
8000bbae:	13 b8       	ld.ub	r8,r9[0x3]
8000bbb0:	2f c9       	sub	r9,-4
8000bbb2:	51 09       	stdsp	sp[0x40],r9
8000bbb4:	fb 68 06 60 	st.b	sp[1632],r8
8000bbb8:	30 0e       	mov	lr,0
8000bbba:	30 08       	mov	r8,0
8000bbbc:	30 12       	mov	r2,1
8000bbbe:	fb 68 06 bb 	st.b	sp[1723],r8
8000bbc2:	50 2e       	stdsp	sp[0x8],lr
8000bbc4:	e0 8f 08 b1 	bral	8000cd26 <_vfprintf_r+0x1666>
8000bbc8:	50 a7       	stdsp	sp[0x28],r7
8000bbca:	50 80       	stdsp	sp[0x20],r0
8000bbcc:	0c 97       	mov	r7,r6
8000bbce:	04 94       	mov	r4,r2
8000bbd0:	06 96       	mov	r6,r3
8000bbd2:	02 92       	mov	r2,r1
8000bbd4:	40 93       	lddsp	r3,sp[0x24]
8000bbd6:	10 90       	mov	r0,r8
8000bbd8:	40 41       	lddsp	r1,sp[0x10]
8000bbda:	a5 a5       	sbr	r5,0x4
8000bbdc:	c0 a8       	rjmp	8000bbf0 <_vfprintf_r+0x530>
8000bbde:	50 a7       	stdsp	sp[0x28],r7
8000bbe0:	50 80       	stdsp	sp[0x20],r0
8000bbe2:	0c 97       	mov	r7,r6
8000bbe4:	04 94       	mov	r4,r2
8000bbe6:	06 96       	mov	r6,r3
8000bbe8:	02 92       	mov	r2,r1
8000bbea:	40 93       	lddsp	r3,sp[0x24]
8000bbec:	10 90       	mov	r0,r8
8000bbee:	40 41       	lddsp	r1,sp[0x10]
8000bbf0:	ed b5 00 05 	bld	r5,0x5
8000bbf4:	c5 11       	brne	8000bc96 <_vfprintf_r+0x5d6>
8000bbf6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bbfa:	40 3c       	lddsp	r12,sp[0xc]
8000bbfc:	58 0c       	cp.w	r12,0
8000bbfe:	c1 e0       	breq	8000bc3a <_vfprintf_r+0x57a>
8000bc00:	10 36       	cp.w	r6,r8
8000bc02:	c0 64       	brge	8000bc0e <_vfprintf_r+0x54e>
8000bc04:	fa cb f9 44 	sub	r11,sp,-1724
8000bc08:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc0c:	c2 08       	rjmp	8000bc4c <_vfprintf_r+0x58c>
8000bc0e:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc12:	1a d8       	st.w	--sp,r8
8000bc14:	fa c8 fa b8 	sub	r8,sp,-1352
8000bc18:	0c 9b       	mov	r11,r6
8000bc1a:	1a d8       	st.w	--sp,r8
8000bc1c:	fa c8 fb b4 	sub	r8,sp,-1100
8000bc20:	1a d8       	st.w	--sp,r8
8000bc22:	fa c9 ff b4 	sub	r9,sp,-76
8000bc26:	fa c8 f9 40 	sub	r8,sp,-1728
8000bc2a:	04 9a       	mov	r10,r2
8000bc2c:	08 9c       	mov	r12,r4
8000bc2e:	fe b0 fb ab 	rcall	8000b384 <get_arg>
8000bc32:	2f dd       	sub	sp,-12
8000bc34:	78 1b       	ld.w	r11,r12[0x4]
8000bc36:	78 09       	ld.w	r9,r12[0x0]
8000bc38:	c2 b8       	rjmp	8000bc8e <_vfprintf_r+0x5ce>
8000bc3a:	ee ca ff ff 	sub	r10,r7,-1
8000bc3e:	10 37       	cp.w	r7,r8
8000bc40:	c0 b4       	brge	8000bc56 <_vfprintf_r+0x596>
8000bc42:	fa c9 f9 44 	sub	r9,sp,-1724
8000bc46:	14 97       	mov	r7,r10
8000bc48:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bc4c:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000bc50:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000bc54:	c1 d8       	rjmp	8000bc8e <_vfprintf_r+0x5ce>
8000bc56:	41 09       	lddsp	r9,sp[0x40]
8000bc58:	59 f8       	cp.w	r8,31
8000bc5a:	e0 89 00 14 	brgt	8000bc82 <_vfprintf_r+0x5c2>
8000bc5e:	f2 cb ff f8 	sub	r11,r9,-8
8000bc62:	51 0b       	stdsp	sp[0x40],r11
8000bc64:	fa c6 f9 44 	sub	r6,sp,-1724
8000bc68:	72 1b       	ld.w	r11,r9[0x4]
8000bc6a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000bc6e:	72 09       	ld.w	r9,r9[0x0]
8000bc70:	f9 4b fd 8c 	st.w	r12[-628],r11
8000bc74:	f9 49 fd 88 	st.w	r12[-632],r9
8000bc78:	2f f8       	sub	r8,-1
8000bc7a:	14 97       	mov	r7,r10
8000bc7c:	fb 48 06 b4 	st.w	sp[1716],r8
8000bc80:	c0 78       	rjmp	8000bc8e <_vfprintf_r+0x5ce>
8000bc82:	f2 c8 ff f8 	sub	r8,r9,-8
8000bc86:	72 1b       	ld.w	r11,r9[0x4]
8000bc88:	14 97       	mov	r7,r10
8000bc8a:	51 08       	stdsp	sp[0x40],r8
8000bc8c:	72 09       	ld.w	r9,r9[0x0]
8000bc8e:	16 98       	mov	r8,r11
8000bc90:	fa e9 00 00 	st.d	sp[0],r8
8000bc94:	ca e8       	rjmp	8000bdf0 <_vfprintf_r+0x730>
8000bc96:	ed b5 00 04 	bld	r5,0x4
8000bc9a:	c1 71       	brne	8000bcc8 <_vfprintf_r+0x608>
8000bc9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bca0:	40 3e       	lddsp	lr,sp[0xc]
8000bca2:	58 0e       	cp.w	lr,0
8000bca4:	c0 80       	breq	8000bcb4 <_vfprintf_r+0x5f4>
8000bca6:	10 36       	cp.w	r6,r8
8000bca8:	c6 94       	brge	8000bd7a <_vfprintf_r+0x6ba>
8000bcaa:	fa cc f9 44 	sub	r12,sp,-1724
8000bcae:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bcb2:	c8 28       	rjmp	8000bdb6 <_vfprintf_r+0x6f6>
8000bcb4:	ee ca ff ff 	sub	r10,r7,-1
8000bcb8:	10 37       	cp.w	r7,r8
8000bcba:	e0 84 00 81 	brge	8000bdbc <_vfprintf_r+0x6fc>
8000bcbe:	fa cb f9 44 	sub	r11,sp,-1724
8000bcc2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bcc6:	c7 78       	rjmp	8000bdb4 <_vfprintf_r+0x6f4>
8000bcc8:	ed b5 00 06 	bld	r5,0x6
8000bccc:	c4 b1       	brne	8000bd62 <_vfprintf_r+0x6a2>
8000bcce:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bcd2:	40 3c       	lddsp	r12,sp[0xc]
8000bcd4:	58 0c       	cp.w	r12,0
8000bcd6:	c1 d0       	breq	8000bd10 <_vfprintf_r+0x650>
8000bcd8:	10 36       	cp.w	r6,r8
8000bcda:	c0 64       	brge	8000bce6 <_vfprintf_r+0x626>
8000bcdc:	fa cb f9 44 	sub	r11,sp,-1724
8000bce0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bce4:	c1 f8       	rjmp	8000bd22 <_vfprintf_r+0x662>
8000bce6:	fa c8 f9 50 	sub	r8,sp,-1712
8000bcea:	1a d8       	st.w	--sp,r8
8000bcec:	fa c8 fa b8 	sub	r8,sp,-1352
8000bcf0:	1a d8       	st.w	--sp,r8
8000bcf2:	fa c8 fb b4 	sub	r8,sp,-1100
8000bcf6:	1a d8       	st.w	--sp,r8
8000bcf8:	fa c8 f9 40 	sub	r8,sp,-1728
8000bcfc:	fa c9 ff b4 	sub	r9,sp,-76
8000bd00:	04 9a       	mov	r10,r2
8000bd02:	0c 9b       	mov	r11,r6
8000bd04:	08 9c       	mov	r12,r4
8000bd06:	fe b0 fb 3f 	rcall	8000b384 <get_arg>
8000bd0a:	2f dd       	sub	sp,-12
8000bd0c:	98 18       	ld.sh	r8,r12[0x2]
8000bd0e:	c2 68       	rjmp	8000bd5a <_vfprintf_r+0x69a>
8000bd10:	ee ca ff ff 	sub	r10,r7,-1
8000bd14:	10 37       	cp.w	r7,r8
8000bd16:	c0 94       	brge	8000bd28 <_vfprintf_r+0x668>
8000bd18:	fa c9 f9 44 	sub	r9,sp,-1724
8000bd1c:	14 97       	mov	r7,r10
8000bd1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bd22:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bd26:	c1 a8       	rjmp	8000bd5a <_vfprintf_r+0x69a>
8000bd28:	41 09       	lddsp	r9,sp[0x40]
8000bd2a:	59 f8       	cp.w	r8,31
8000bd2c:	e0 89 00 13 	brgt	8000bd52 <_vfprintf_r+0x692>
8000bd30:	f2 cb ff fc 	sub	r11,r9,-4
8000bd34:	51 0b       	stdsp	sp[0x40],r11
8000bd36:	72 09       	ld.w	r9,r9[0x0]
8000bd38:	fa c6 f9 44 	sub	r6,sp,-1724
8000bd3c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bd40:	2f f8       	sub	r8,-1
8000bd42:	f7 49 fd 88 	st.w	r11[-632],r9
8000bd46:	fb 48 06 b4 	st.w	sp[1716],r8
8000bd4a:	14 97       	mov	r7,r10
8000bd4c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bd50:	c0 58       	rjmp	8000bd5a <_vfprintf_r+0x69a>
8000bd52:	92 18       	ld.sh	r8,r9[0x2]
8000bd54:	14 97       	mov	r7,r10
8000bd56:	2f c9       	sub	r9,-4
8000bd58:	51 09       	stdsp	sp[0x40],r9
8000bd5a:	50 18       	stdsp	sp[0x4],r8
8000bd5c:	bf 58       	asr	r8,0x1f
8000bd5e:	50 08       	stdsp	sp[0x0],r8
8000bd60:	c4 88       	rjmp	8000bdf0 <_vfprintf_r+0x730>
8000bd62:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd66:	40 3c       	lddsp	r12,sp[0xc]
8000bd68:	58 0c       	cp.w	r12,0
8000bd6a:	c1 d0       	breq	8000bda4 <_vfprintf_r+0x6e4>
8000bd6c:	10 36       	cp.w	r6,r8
8000bd6e:	c0 64       	brge	8000bd7a <_vfprintf_r+0x6ba>
8000bd70:	fa cb f9 44 	sub	r11,sp,-1724
8000bd74:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bd78:	c1 f8       	rjmp	8000bdb6 <_vfprintf_r+0x6f6>
8000bd7a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bd7e:	1a d8       	st.w	--sp,r8
8000bd80:	fa c8 fa b8 	sub	r8,sp,-1352
8000bd84:	0c 9b       	mov	r11,r6
8000bd86:	1a d8       	st.w	--sp,r8
8000bd88:	fa c8 fb b4 	sub	r8,sp,-1100
8000bd8c:	04 9a       	mov	r10,r2
8000bd8e:	1a d8       	st.w	--sp,r8
8000bd90:	08 9c       	mov	r12,r4
8000bd92:	fa c8 f9 40 	sub	r8,sp,-1728
8000bd96:	fa c9 ff b4 	sub	r9,sp,-76
8000bd9a:	fe b0 fa f5 	rcall	8000b384 <get_arg>
8000bd9e:	2f dd       	sub	sp,-12
8000bda0:	78 0b       	ld.w	r11,r12[0x0]
8000bda2:	c2 48       	rjmp	8000bdea <_vfprintf_r+0x72a>
8000bda4:	ee ca ff ff 	sub	r10,r7,-1
8000bda8:	10 37       	cp.w	r7,r8
8000bdaa:	c0 94       	brge	8000bdbc <_vfprintf_r+0x6fc>
8000bdac:	fa c9 f9 44 	sub	r9,sp,-1724
8000bdb0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bdb4:	14 97       	mov	r7,r10
8000bdb6:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bdba:	c1 88       	rjmp	8000bdea <_vfprintf_r+0x72a>
8000bdbc:	41 09       	lddsp	r9,sp[0x40]
8000bdbe:	59 f8       	cp.w	r8,31
8000bdc0:	e0 89 00 11 	brgt	8000bde2 <_vfprintf_r+0x722>
8000bdc4:	f2 cb ff fc 	sub	r11,r9,-4
8000bdc8:	51 0b       	stdsp	sp[0x40],r11
8000bdca:	fa c6 f9 44 	sub	r6,sp,-1724
8000bdce:	72 0b       	ld.w	r11,r9[0x0]
8000bdd0:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bdd4:	f3 4b fd 88 	st.w	r9[-632],r11
8000bdd8:	2f f8       	sub	r8,-1
8000bdda:	14 97       	mov	r7,r10
8000bddc:	fb 48 06 b4 	st.w	sp[1716],r8
8000bde0:	c0 58       	rjmp	8000bdea <_vfprintf_r+0x72a>
8000bde2:	72 0b       	ld.w	r11,r9[0x0]
8000bde4:	14 97       	mov	r7,r10
8000bde6:	2f c9       	sub	r9,-4
8000bde8:	51 09       	stdsp	sp[0x40],r9
8000bdea:	50 1b       	stdsp	sp[0x4],r11
8000bdec:	bf 5b       	asr	r11,0x1f
8000bdee:	50 0b       	stdsp	sp[0x0],r11
8000bdf0:	fa ea 00 00 	ld.d	r10,sp[0]
8000bdf4:	58 0a       	cp.w	r10,0
8000bdf6:	5c 2b       	cpc	r11
8000bdf8:	c0 e4       	brge	8000be14 <_vfprintf_r+0x754>
8000bdfa:	30 08       	mov	r8,0
8000bdfc:	fa ea 00 00 	ld.d	r10,sp[0]
8000be00:	30 09       	mov	r9,0
8000be02:	f0 0a 01 0a 	sub	r10,r8,r10
8000be06:	f2 0b 01 4b 	sbc	r11,r9,r11
8000be0a:	32 d8       	mov	r8,45
8000be0c:	fa eb 00 00 	st.d	sp[0],r10
8000be10:	fb 68 06 bb 	st.b	sp[1723],r8
8000be14:	30 18       	mov	r8,1
8000be16:	e0 8f 06 fe 	bral	8000cc12 <_vfprintf_r+0x1552>
8000be1a:	50 a7       	stdsp	sp[0x28],r7
8000be1c:	50 80       	stdsp	sp[0x20],r0
8000be1e:	0c 97       	mov	r7,r6
8000be20:	04 94       	mov	r4,r2
8000be22:	06 96       	mov	r6,r3
8000be24:	02 92       	mov	r2,r1
8000be26:	40 93       	lddsp	r3,sp[0x24]
8000be28:	10 90       	mov	r0,r8
8000be2a:	40 41       	lddsp	r1,sp[0x10]
8000be2c:	0e 99       	mov	r9,r7
8000be2e:	ed b5 00 03 	bld	r5,0x3
8000be32:	c4 11       	brne	8000beb4 <_vfprintf_r+0x7f4>
8000be34:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be38:	40 3a       	lddsp	r10,sp[0xc]
8000be3a:	58 0a       	cp.w	r10,0
8000be3c:	c1 90       	breq	8000be6e <_vfprintf_r+0x7ae>
8000be3e:	10 36       	cp.w	r6,r8
8000be40:	c6 45       	brlt	8000bf08 <_vfprintf_r+0x848>
8000be42:	fa c8 f9 50 	sub	r8,sp,-1712
8000be46:	1a d8       	st.w	--sp,r8
8000be48:	fa c8 fa b8 	sub	r8,sp,-1352
8000be4c:	1a d8       	st.w	--sp,r8
8000be4e:	fa c8 fb b4 	sub	r8,sp,-1100
8000be52:	0c 9b       	mov	r11,r6
8000be54:	1a d8       	st.w	--sp,r8
8000be56:	04 9a       	mov	r10,r2
8000be58:	fa c8 f9 40 	sub	r8,sp,-1728
8000be5c:	fa c9 ff b4 	sub	r9,sp,-76
8000be60:	08 9c       	mov	r12,r4
8000be62:	fe b0 fa 91 	rcall	8000b384 <get_arg>
8000be66:	2f dd       	sub	sp,-12
8000be68:	78 16       	ld.w	r6,r12[0x4]
8000be6a:	50 76       	stdsp	sp[0x1c],r6
8000be6c:	c4 88       	rjmp	8000befc <_vfprintf_r+0x83c>
8000be6e:	2f f7       	sub	r7,-1
8000be70:	10 39       	cp.w	r9,r8
8000be72:	c0 c4       	brge	8000be8a <_vfprintf_r+0x7ca>
8000be74:	fa ce f9 44 	sub	lr,sp,-1724
8000be78:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000be7c:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000be80:	50 7c       	stdsp	sp[0x1c],r12
8000be82:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000be86:	50 56       	stdsp	sp[0x14],r6
8000be88:	c6 68       	rjmp	8000bf54 <_vfprintf_r+0x894>
8000be8a:	41 09       	lddsp	r9,sp[0x40]
8000be8c:	59 f8       	cp.w	r8,31
8000be8e:	e0 89 00 10 	brgt	8000beae <_vfprintf_r+0x7ee>
8000be92:	f2 ca ff f8 	sub	r10,r9,-8
8000be96:	72 1b       	ld.w	r11,r9[0x4]
8000be98:	51 0a       	stdsp	sp[0x40],r10
8000be9a:	72 09       	ld.w	r9,r9[0x0]
8000be9c:	fa ca f9 44 	sub	r10,sp,-1724
8000bea0:	50 7b       	stdsp	sp[0x1c],r11
8000bea2:	50 59       	stdsp	sp[0x14],r9
8000bea4:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000bea8:	40 5b       	lddsp	r11,sp[0x14]
8000beaa:	40 7a       	lddsp	r10,sp[0x1c]
8000beac:	c4 78       	rjmp	8000bf3a <_vfprintf_r+0x87a>
8000beae:	72 18       	ld.w	r8,r9[0x4]
8000beb0:	50 78       	stdsp	sp[0x1c],r8
8000beb2:	c4 c8       	rjmp	8000bf4a <_vfprintf_r+0x88a>
8000beb4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000beb8:	40 3e       	lddsp	lr,sp[0xc]
8000beba:	58 0e       	cp.w	lr,0
8000bebc:	c2 30       	breq	8000bf02 <_vfprintf_r+0x842>
8000bebe:	10 36       	cp.w	r6,r8
8000bec0:	c0 94       	brge	8000bed2 <_vfprintf_r+0x812>
8000bec2:	fa cc f9 44 	sub	r12,sp,-1724
8000bec6:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000beca:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000bece:	50 7b       	stdsp	sp[0x1c],r11
8000bed0:	cd 9b       	rjmp	8000be82 <_vfprintf_r+0x7c2>
8000bed2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bed6:	1a d8       	st.w	--sp,r8
8000bed8:	fa c8 fa b8 	sub	r8,sp,-1352
8000bedc:	04 9a       	mov	r10,r2
8000bede:	1a d8       	st.w	--sp,r8
8000bee0:	fa c8 fb b4 	sub	r8,sp,-1100
8000bee4:	0c 9b       	mov	r11,r6
8000bee6:	1a d8       	st.w	--sp,r8
8000bee8:	08 9c       	mov	r12,r4
8000beea:	fa c8 f9 40 	sub	r8,sp,-1728
8000beee:	fa c9 ff b4 	sub	r9,sp,-76
8000bef2:	fe b0 fa 49 	rcall	8000b384 <get_arg>
8000bef6:	2f dd       	sub	sp,-12
8000bef8:	78 1a       	ld.w	r10,r12[0x4]
8000befa:	50 7a       	stdsp	sp[0x1c],r10
8000befc:	78 0c       	ld.w	r12,r12[0x0]
8000befe:	50 5c       	stdsp	sp[0x14],r12
8000bf00:	c2 a8       	rjmp	8000bf54 <_vfprintf_r+0x894>
8000bf02:	2f f7       	sub	r7,-1
8000bf04:	10 39       	cp.w	r9,r8
8000bf06:	c0 94       	brge	8000bf18 <_vfprintf_r+0x858>
8000bf08:	fa c9 f9 44 	sub	r9,sp,-1724
8000bf0c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bf10:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000bf14:	50 78       	stdsp	sp[0x1c],r8
8000bf16:	cb 6b       	rjmp	8000be82 <_vfprintf_r+0x7c2>
8000bf18:	41 09       	lddsp	r9,sp[0x40]
8000bf1a:	59 f8       	cp.w	r8,31
8000bf1c:	e0 89 00 15 	brgt	8000bf46 <_vfprintf_r+0x886>
8000bf20:	f2 ca ff f8 	sub	r10,r9,-8
8000bf24:	72 16       	ld.w	r6,r9[0x4]
8000bf26:	72 09       	ld.w	r9,r9[0x0]
8000bf28:	51 0a       	stdsp	sp[0x40],r10
8000bf2a:	50 59       	stdsp	sp[0x14],r9
8000bf2c:	fa ce f9 44 	sub	lr,sp,-1724
8000bf30:	50 76       	stdsp	sp[0x1c],r6
8000bf32:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000bf36:	40 5b       	lddsp	r11,sp[0x14]
8000bf38:	0c 9a       	mov	r10,r6
8000bf3a:	f2 eb fd 88 	st.d	r9[-632],r10
8000bf3e:	2f f8       	sub	r8,-1
8000bf40:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf44:	c0 88       	rjmp	8000bf54 <_vfprintf_r+0x894>
8000bf46:	72 1c       	ld.w	r12,r9[0x4]
8000bf48:	50 7c       	stdsp	sp[0x1c],r12
8000bf4a:	f2 c8 ff f8 	sub	r8,r9,-8
8000bf4e:	51 08       	stdsp	sp[0x40],r8
8000bf50:	72 09       	ld.w	r9,r9[0x0]
8000bf52:	50 59       	stdsp	sp[0x14],r9
8000bf54:	40 5b       	lddsp	r11,sp[0x14]
8000bf56:	40 7a       	lddsp	r10,sp[0x1c]
8000bf58:	e0 a0 19 64 	rcall	8000f220 <__isinfd>
8000bf5c:	18 96       	mov	r6,r12
8000bf5e:	c1 50       	breq	8000bf88 <_vfprintf_r+0x8c8>
8000bf60:	30 08       	mov	r8,0
8000bf62:	30 09       	mov	r9,0
8000bf64:	40 5b       	lddsp	r11,sp[0x14]
8000bf66:	40 7a       	lddsp	r10,sp[0x1c]
8000bf68:	e0 a0 1d ba 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000bf6c:	c0 40       	breq	8000bf74 <_vfprintf_r+0x8b4>
8000bf6e:	32 d8       	mov	r8,45
8000bf70:	fb 68 06 bb 	st.b	sp[1723],r8
8000bf74:	4d 18       	lddpc	r8,8000c0b8 <_vfprintf_r+0x9f8>
8000bf76:	4d 26       	lddpc	r6,8000c0bc <_vfprintf_r+0x9fc>
8000bf78:	a7 d5       	cbr	r5,0x7
8000bf7a:	e0 40 00 47 	cp.w	r0,71
8000bf7e:	f0 06 17 a0 	movle	r6,r8
8000bf82:	30 32       	mov	r2,3
8000bf84:	e0 8f 06 d4 	bral	8000cd2c <_vfprintf_r+0x166c>
8000bf88:	40 5b       	lddsp	r11,sp[0x14]
8000bf8a:	40 7a       	lddsp	r10,sp[0x1c]
8000bf8c:	e0 a0 19 5f 	rcall	8000f24a <__isnand>
8000bf90:	c0 c0       	breq	8000bfa8 <_vfprintf_r+0x8e8>
8000bf92:	50 26       	stdsp	sp[0x8],r6
8000bf94:	4c b8       	lddpc	r8,8000c0c0 <_vfprintf_r+0xa00>
8000bf96:	4c c6       	lddpc	r6,8000c0c4 <_vfprintf_r+0xa04>
8000bf98:	a7 d5       	cbr	r5,0x7
8000bf9a:	e0 40 00 47 	cp.w	r0,71
8000bf9e:	f0 06 17 a0 	movle	r6,r8
8000bfa2:	30 32       	mov	r2,3
8000bfa4:	e0 8f 06 ca 	bral	8000cd38 <_vfprintf_r+0x1678>
8000bfa8:	40 2a       	lddsp	r10,sp[0x8]
8000bfaa:	5b fa       	cp.w	r10,-1
8000bfac:	c0 41       	brne	8000bfb4 <_vfprintf_r+0x8f4>
8000bfae:	30 69       	mov	r9,6
8000bfb0:	50 29       	stdsp	sp[0x8],r9
8000bfb2:	c1 18       	rjmp	8000bfd4 <_vfprintf_r+0x914>
8000bfb4:	e0 40 00 47 	cp.w	r0,71
8000bfb8:	5f 09       	sreq	r9
8000bfba:	e0 40 00 67 	cp.w	r0,103
8000bfbe:	5f 08       	sreq	r8
8000bfc0:	f3 e8 10 08 	or	r8,r9,r8
8000bfc4:	f8 08 18 00 	cp.b	r8,r12
8000bfc8:	c0 60       	breq	8000bfd4 <_vfprintf_r+0x914>
8000bfca:	40 28       	lddsp	r8,sp[0x8]
8000bfcc:	58 08       	cp.w	r8,0
8000bfce:	f9 b8 00 01 	moveq	r8,1
8000bfd2:	50 28       	stdsp	sp[0x8],r8
8000bfd4:	40 78       	lddsp	r8,sp[0x1c]
8000bfd6:	40 59       	lddsp	r9,sp[0x14]
8000bfd8:	fa e9 06 94 	st.d	sp[1684],r8
8000bfdc:	a9 a5       	sbr	r5,0x8
8000bfde:	fa f8 06 94 	ld.w	r8,sp[1684]
8000bfe2:	58 08       	cp.w	r8,0
8000bfe4:	c0 65       	brlt	8000bff0 <_vfprintf_r+0x930>
8000bfe6:	40 5e       	lddsp	lr,sp[0x14]
8000bfe8:	30 0c       	mov	r12,0
8000bfea:	50 6e       	stdsp	sp[0x18],lr
8000bfec:	50 9c       	stdsp	sp[0x24],r12
8000bfee:	c0 78       	rjmp	8000bffc <_vfprintf_r+0x93c>
8000bff0:	40 5b       	lddsp	r11,sp[0x14]
8000bff2:	32 da       	mov	r10,45
8000bff4:	ee 1b 80 00 	eorh	r11,0x8000
8000bff8:	50 9a       	stdsp	sp[0x24],r10
8000bffa:	50 6b       	stdsp	sp[0x18],r11
8000bffc:	e0 40 00 46 	cp.w	r0,70
8000c000:	5f 09       	sreq	r9
8000c002:	e0 40 00 66 	cp.w	r0,102
8000c006:	5f 08       	sreq	r8
8000c008:	f3 e8 10 08 	or	r8,r9,r8
8000c00c:	50 48       	stdsp	sp[0x10],r8
8000c00e:	c0 40       	breq	8000c016 <_vfprintf_r+0x956>
8000c010:	40 22       	lddsp	r2,sp[0x8]
8000c012:	30 39       	mov	r9,3
8000c014:	c1 08       	rjmp	8000c034 <_vfprintf_r+0x974>
8000c016:	e0 40 00 45 	cp.w	r0,69
8000c01a:	5f 09       	sreq	r9
8000c01c:	e0 40 00 65 	cp.w	r0,101
8000c020:	5f 08       	sreq	r8
8000c022:	40 22       	lddsp	r2,sp[0x8]
8000c024:	10 49       	or	r9,r8
8000c026:	2f f2       	sub	r2,-1
8000c028:	40 46       	lddsp	r6,sp[0x10]
8000c02a:	ec 09 18 00 	cp.b	r9,r6
8000c02e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000c032:	30 29       	mov	r9,2
8000c034:	fa c8 f9 5c 	sub	r8,sp,-1700
8000c038:	1a d8       	st.w	--sp,r8
8000c03a:	fa c8 f9 54 	sub	r8,sp,-1708
8000c03e:	1a d8       	st.w	--sp,r8
8000c040:	fa c8 f9 4c 	sub	r8,sp,-1716
8000c044:	08 9c       	mov	r12,r4
8000c046:	1a d8       	st.w	--sp,r8
8000c048:	04 98       	mov	r8,r2
8000c04a:	40 9b       	lddsp	r11,sp[0x24]
8000c04c:	40 aa       	lddsp	r10,sp[0x28]
8000c04e:	e0 a0 0b cf 	rcall	8000d7ec <_dtoa_r>
8000c052:	e0 40 00 47 	cp.w	r0,71
8000c056:	5f 19       	srne	r9
8000c058:	e0 40 00 67 	cp.w	r0,103
8000c05c:	5f 18       	srne	r8
8000c05e:	18 96       	mov	r6,r12
8000c060:	2f dd       	sub	sp,-12
8000c062:	f3 e8 00 08 	and	r8,r9,r8
8000c066:	c0 41       	brne	8000c06e <_vfprintf_r+0x9ae>
8000c068:	ed b5 00 00 	bld	r5,0x0
8000c06c:	c3 81       	brne	8000c0dc <_vfprintf_r+0xa1c>
8000c06e:	ec 02 00 0e 	add	lr,r6,r2
8000c072:	50 3e       	stdsp	sp[0xc],lr
8000c074:	40 4c       	lddsp	r12,sp[0x10]
8000c076:	58 0c       	cp.w	r12,0
8000c078:	c1 50       	breq	8000c0a2 <_vfprintf_r+0x9e2>
8000c07a:	0d 89       	ld.ub	r9,r6[0x0]
8000c07c:	33 08       	mov	r8,48
8000c07e:	f0 09 18 00 	cp.b	r9,r8
8000c082:	c0 b1       	brne	8000c098 <_vfprintf_r+0x9d8>
8000c084:	30 08       	mov	r8,0
8000c086:	30 09       	mov	r9,0
8000c088:	40 6b       	lddsp	r11,sp[0x18]
8000c08a:	40 7a       	lddsp	r10,sp[0x1c]
8000c08c:	e0 a0 1c e1 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000c090:	fb b2 00 01 	rsubeq	r2,1
8000c094:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000c098:	40 3b       	lddsp	r11,sp[0xc]
8000c09a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c09e:	10 0b       	add	r11,r8
8000c0a0:	50 3b       	stdsp	sp[0xc],r11
8000c0a2:	40 6b       	lddsp	r11,sp[0x18]
8000c0a4:	30 08       	mov	r8,0
8000c0a6:	30 09       	mov	r9,0
8000c0a8:	40 7a       	lddsp	r10,sp[0x1c]
8000c0aa:	e0 a0 1c d2 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000c0ae:	c1 10       	breq	8000c0d0 <_vfprintf_r+0xa10>
8000c0b0:	40 3a       	lddsp	r10,sp[0xc]
8000c0b2:	fb 4a 06 a4 	st.w	sp[1700],r10
8000c0b6:	c0 d8       	rjmp	8000c0d0 <_vfprintf_r+0xa10>
8000c0b8:	80 01       	ld.sh	r1,r0[0x0]
8000c0ba:	9f 50       	st.w	pc[0x14],r0
8000c0bc:	80 01       	ld.sh	r1,r0[0x0]
8000c0be:	9f 54       	st.w	pc[0x14],r4
8000c0c0:	80 01       	ld.sh	r1,r0[0x0]
8000c0c2:	9f 58       	st.w	pc[0x14],r8
8000c0c4:	80 01       	ld.sh	r1,r0[0x0]
8000c0c6:	9f 5c       	st.w	pc[0x14],r12
8000c0c8:	10 c9       	st.b	r8++,r9
8000c0ca:	fb 48 06 a4 	st.w	sp[1700],r8
8000c0ce:	c0 28       	rjmp	8000c0d2 <_vfprintf_r+0xa12>
8000c0d0:	33 09       	mov	r9,48
8000c0d2:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000c0d6:	40 3e       	lddsp	lr,sp[0xc]
8000c0d8:	1c 38       	cp.w	r8,lr
8000c0da:	cf 73       	brcs	8000c0c8 <_vfprintf_r+0xa08>
8000c0dc:	e0 40 00 47 	cp.w	r0,71
8000c0e0:	5f 09       	sreq	r9
8000c0e2:	e0 40 00 67 	cp.w	r0,103
8000c0e6:	5f 08       	sreq	r8
8000c0e8:	f3 e8 10 08 	or	r8,r9,r8
8000c0ec:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000c0f0:	0c 19       	sub	r9,r6
8000c0f2:	50 69       	stdsp	sp[0x18],r9
8000c0f4:	58 08       	cp.w	r8,0
8000c0f6:	c0 b0       	breq	8000c10c <_vfprintf_r+0xa4c>
8000c0f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c0fc:	5b d8       	cp.w	r8,-3
8000c0fe:	c0 55       	brlt	8000c108 <_vfprintf_r+0xa48>
8000c100:	40 2c       	lddsp	r12,sp[0x8]
8000c102:	18 38       	cp.w	r8,r12
8000c104:	e0 8a 00 6a 	brle	8000c1d8 <_vfprintf_r+0xb18>
8000c108:	20 20       	sub	r0,2
8000c10a:	c0 58       	rjmp	8000c114 <_vfprintf_r+0xa54>
8000c10c:	e0 40 00 65 	cp.w	r0,101
8000c110:	e0 89 00 46 	brgt	8000c19c <_vfprintf_r+0xadc>
8000c114:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000c118:	fb 60 06 9c 	st.b	sp[1692],r0
8000c11c:	20 1b       	sub	r11,1
8000c11e:	fb 4b 06 ac 	st.w	sp[1708],r11
8000c122:	c0 47       	brpl	8000c12a <_vfprintf_r+0xa6a>
8000c124:	5c 3b       	neg	r11
8000c126:	32 d8       	mov	r8,45
8000c128:	c0 28       	rjmp	8000c12c <_vfprintf_r+0xa6c>
8000c12a:	32 b8       	mov	r8,43
8000c12c:	fb 68 06 9d 	st.b	sp[1693],r8
8000c130:	58 9b       	cp.w	r11,9
8000c132:	e0 8a 00 1d 	brle	8000c16c <_vfprintf_r+0xaac>
8000c136:	fa c9 fa 35 	sub	r9,sp,-1483
8000c13a:	30 aa       	mov	r10,10
8000c13c:	12 98       	mov	r8,r9
8000c13e:	0e 9c       	mov	r12,r7
8000c140:	0c 92       	mov	r2,r6
8000c142:	f6 0a 0c 06 	divs	r6,r11,r10
8000c146:	0e 9b       	mov	r11,r7
8000c148:	2d 0b       	sub	r11,-48
8000c14a:	10 fb       	st.b	--r8,r11
8000c14c:	0c 9b       	mov	r11,r6
8000c14e:	58 96       	cp.w	r6,9
8000c150:	fe 99 ff f9 	brgt	8000c142 <_vfprintf_r+0xa82>
8000c154:	2d 0b       	sub	r11,-48
8000c156:	18 97       	mov	r7,r12
8000c158:	04 96       	mov	r6,r2
8000c15a:	10 fb       	st.b	--r8,r11
8000c15c:	fa ca f9 62 	sub	r10,sp,-1694
8000c160:	c0 38       	rjmp	8000c166 <_vfprintf_r+0xaa6>
8000c162:	11 3b       	ld.ub	r11,r8++
8000c164:	14 cb       	st.b	r10++,r11
8000c166:	12 38       	cp.w	r8,r9
8000c168:	cf d3       	brcs	8000c162 <_vfprintf_r+0xaa2>
8000c16a:	c0 98       	rjmp	8000c17c <_vfprintf_r+0xabc>
8000c16c:	2d 0b       	sub	r11,-48
8000c16e:	33 08       	mov	r8,48
8000c170:	fb 6b 06 9f 	st.b	sp[1695],r11
8000c174:	fb 68 06 9e 	st.b	sp[1694],r8
8000c178:	fa ca f9 60 	sub	r10,sp,-1696
8000c17c:	fa c8 f9 64 	sub	r8,sp,-1692
8000c180:	f4 08 01 08 	sub	r8,r10,r8
8000c184:	50 e8       	stdsp	sp[0x38],r8
8000c186:	10 92       	mov	r2,r8
8000c188:	40 6b       	lddsp	r11,sp[0x18]
8000c18a:	16 02       	add	r2,r11
8000c18c:	58 1b       	cp.w	r11,1
8000c18e:	e0 89 00 05 	brgt	8000c198 <_vfprintf_r+0xad8>
8000c192:	ed b5 00 00 	bld	r5,0x0
8000c196:	c3 51       	brne	8000c200 <_vfprintf_r+0xb40>
8000c198:	2f f2       	sub	r2,-1
8000c19a:	c3 38       	rjmp	8000c200 <_vfprintf_r+0xb40>
8000c19c:	e0 40 00 66 	cp.w	r0,102
8000c1a0:	c1 c1       	brne	8000c1d8 <_vfprintf_r+0xb18>
8000c1a2:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c1a6:	58 02       	cp.w	r2,0
8000c1a8:	e0 8a 00 0c 	brle	8000c1c0 <_vfprintf_r+0xb00>
8000c1ac:	40 2a       	lddsp	r10,sp[0x8]
8000c1ae:	58 0a       	cp.w	r10,0
8000c1b0:	c0 41       	brne	8000c1b8 <_vfprintf_r+0xaf8>
8000c1b2:	ed b5 00 00 	bld	r5,0x0
8000c1b6:	c2 51       	brne	8000c200 <_vfprintf_r+0xb40>
8000c1b8:	2f f2       	sub	r2,-1
8000c1ba:	40 29       	lddsp	r9,sp[0x8]
8000c1bc:	12 02       	add	r2,r9
8000c1be:	c0 b8       	rjmp	8000c1d4 <_vfprintf_r+0xb14>
8000c1c0:	40 28       	lddsp	r8,sp[0x8]
8000c1c2:	58 08       	cp.w	r8,0
8000c1c4:	c0 61       	brne	8000c1d0 <_vfprintf_r+0xb10>
8000c1c6:	ed b5 00 00 	bld	r5,0x0
8000c1ca:	c0 30       	breq	8000c1d0 <_vfprintf_r+0xb10>
8000c1cc:	30 12       	mov	r2,1
8000c1ce:	c1 98       	rjmp	8000c200 <_vfprintf_r+0xb40>
8000c1d0:	40 22       	lddsp	r2,sp[0x8]
8000c1d2:	2f e2       	sub	r2,-2
8000c1d4:	36 60       	mov	r0,102
8000c1d6:	c1 58       	rjmp	8000c200 <_vfprintf_r+0xb40>
8000c1d8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c1dc:	40 6e       	lddsp	lr,sp[0x18]
8000c1de:	1c 32       	cp.w	r2,lr
8000c1e0:	c0 65       	brlt	8000c1ec <_vfprintf_r+0xb2c>
8000c1e2:	ed b5 00 00 	bld	r5,0x0
8000c1e6:	f7 b2 00 ff 	subeq	r2,-1
8000c1ea:	c0 a8       	rjmp	8000c1fe <_vfprintf_r+0xb3e>
8000c1ec:	e4 08 11 02 	rsub	r8,r2,2
8000c1f0:	40 6c       	lddsp	r12,sp[0x18]
8000c1f2:	58 02       	cp.w	r2,0
8000c1f4:	f0 02 17 a0 	movle	r2,r8
8000c1f8:	f9 b2 09 01 	movgt	r2,1
8000c1fc:	18 02       	add	r2,r12
8000c1fe:	36 70       	mov	r0,103
8000c200:	40 9b       	lddsp	r11,sp[0x24]
8000c202:	58 0b       	cp.w	r11,0
8000c204:	e0 80 05 94 	breq	8000cd2c <_vfprintf_r+0x166c>
8000c208:	32 d8       	mov	r8,45
8000c20a:	fb 68 06 bb 	st.b	sp[1723],r8
8000c20e:	e0 8f 05 93 	bral	8000cd34 <_vfprintf_r+0x1674>
8000c212:	50 a7       	stdsp	sp[0x28],r7
8000c214:	04 94       	mov	r4,r2
8000c216:	0c 97       	mov	r7,r6
8000c218:	02 92       	mov	r2,r1
8000c21a:	06 96       	mov	r6,r3
8000c21c:	40 41       	lddsp	r1,sp[0x10]
8000c21e:	40 93       	lddsp	r3,sp[0x24]
8000c220:	0e 99       	mov	r9,r7
8000c222:	ed b5 00 05 	bld	r5,0x5
8000c226:	c4 81       	brne	8000c2b6 <_vfprintf_r+0xbf6>
8000c228:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c22c:	40 3e       	lddsp	lr,sp[0xc]
8000c22e:	58 0e       	cp.w	lr,0
8000c230:	c1 d0       	breq	8000c26a <_vfprintf_r+0xbaa>
8000c232:	10 36       	cp.w	r6,r8
8000c234:	c0 64       	brge	8000c240 <_vfprintf_r+0xb80>
8000c236:	fa cc f9 44 	sub	r12,sp,-1724
8000c23a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c23e:	c1 d8       	rjmp	8000c278 <_vfprintf_r+0xbb8>
8000c240:	fa c8 f9 50 	sub	r8,sp,-1712
8000c244:	1a d8       	st.w	--sp,r8
8000c246:	fa c8 fa b8 	sub	r8,sp,-1352
8000c24a:	04 9a       	mov	r10,r2
8000c24c:	1a d8       	st.w	--sp,r8
8000c24e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c252:	0c 9b       	mov	r11,r6
8000c254:	1a d8       	st.w	--sp,r8
8000c256:	08 9c       	mov	r12,r4
8000c258:	fa c8 f9 40 	sub	r8,sp,-1728
8000c25c:	fa c9 ff b4 	sub	r9,sp,-76
8000c260:	fe b0 f8 92 	rcall	8000b384 <get_arg>
8000c264:	2f dd       	sub	sp,-12
8000c266:	78 0a       	ld.w	r10,r12[0x0]
8000c268:	c2 08       	rjmp	8000c2a8 <_vfprintf_r+0xbe8>
8000c26a:	2f f7       	sub	r7,-1
8000c26c:	10 39       	cp.w	r9,r8
8000c26e:	c0 84       	brge	8000c27e <_vfprintf_r+0xbbe>
8000c270:	fa cb f9 44 	sub	r11,sp,-1724
8000c274:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c278:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c27c:	c1 68       	rjmp	8000c2a8 <_vfprintf_r+0xbe8>
8000c27e:	41 09       	lddsp	r9,sp[0x40]
8000c280:	59 f8       	cp.w	r8,31
8000c282:	e0 89 00 10 	brgt	8000c2a2 <_vfprintf_r+0xbe2>
8000c286:	f2 ca ff fc 	sub	r10,r9,-4
8000c28a:	51 0a       	stdsp	sp[0x40],r10
8000c28c:	fa c6 f9 44 	sub	r6,sp,-1724
8000c290:	72 0a       	ld.w	r10,r9[0x0]
8000c292:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c296:	f3 4a fd 88 	st.w	r9[-632],r10
8000c29a:	2f f8       	sub	r8,-1
8000c29c:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2a0:	c0 48       	rjmp	8000c2a8 <_vfprintf_r+0xbe8>
8000c2a2:	72 0a       	ld.w	r10,r9[0x0]
8000c2a4:	2f c9       	sub	r9,-4
8000c2a6:	51 09       	stdsp	sp[0x40],r9
8000c2a8:	40 be       	lddsp	lr,sp[0x2c]
8000c2aa:	1c 98       	mov	r8,lr
8000c2ac:	95 1e       	st.w	r10[0x4],lr
8000c2ae:	bf 58       	asr	r8,0x1f
8000c2b0:	95 08       	st.w	r10[0x0],r8
8000c2b2:	fe 9f fa 92 	bral	8000b7d6 <_vfprintf_r+0x116>
8000c2b6:	ed b5 00 04 	bld	r5,0x4
8000c2ba:	c4 80       	breq	8000c34a <_vfprintf_r+0xc8a>
8000c2bc:	e2 15 00 40 	andl	r5,0x40,COH
8000c2c0:	c4 50       	breq	8000c34a <_vfprintf_r+0xc8a>
8000c2c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c2c6:	40 3c       	lddsp	r12,sp[0xc]
8000c2c8:	58 0c       	cp.w	r12,0
8000c2ca:	c1 d0       	breq	8000c304 <_vfprintf_r+0xc44>
8000c2cc:	10 36       	cp.w	r6,r8
8000c2ce:	c0 64       	brge	8000c2da <_vfprintf_r+0xc1a>
8000c2d0:	fa cb f9 44 	sub	r11,sp,-1724
8000c2d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c2d8:	c1 d8       	rjmp	8000c312 <_vfprintf_r+0xc52>
8000c2da:	fa c8 f9 50 	sub	r8,sp,-1712
8000c2de:	1a d8       	st.w	--sp,r8
8000c2e0:	fa c8 fa b8 	sub	r8,sp,-1352
8000c2e4:	04 9a       	mov	r10,r2
8000c2e6:	1a d8       	st.w	--sp,r8
8000c2e8:	fa c8 fb b4 	sub	r8,sp,-1100
8000c2ec:	0c 9b       	mov	r11,r6
8000c2ee:	1a d8       	st.w	--sp,r8
8000c2f0:	08 9c       	mov	r12,r4
8000c2f2:	fa c8 f9 40 	sub	r8,sp,-1728
8000c2f6:	fa c9 ff b4 	sub	r9,sp,-76
8000c2fa:	fe b0 f8 45 	rcall	8000b384 <get_arg>
8000c2fe:	2f dd       	sub	sp,-12
8000c300:	78 0a       	ld.w	r10,r12[0x0]
8000c302:	c2 08       	rjmp	8000c342 <_vfprintf_r+0xc82>
8000c304:	2f f7       	sub	r7,-1
8000c306:	10 39       	cp.w	r9,r8
8000c308:	c0 84       	brge	8000c318 <_vfprintf_r+0xc58>
8000c30a:	fa ca f9 44 	sub	r10,sp,-1724
8000c30e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c312:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c316:	c1 68       	rjmp	8000c342 <_vfprintf_r+0xc82>
8000c318:	41 09       	lddsp	r9,sp[0x40]
8000c31a:	59 f8       	cp.w	r8,31
8000c31c:	e0 89 00 10 	brgt	8000c33c <_vfprintf_r+0xc7c>
8000c320:	f2 ca ff fc 	sub	r10,r9,-4
8000c324:	51 0a       	stdsp	sp[0x40],r10
8000c326:	fa c6 f9 44 	sub	r6,sp,-1724
8000c32a:	72 0a       	ld.w	r10,r9[0x0]
8000c32c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c330:	f3 4a fd 88 	st.w	r9[-632],r10
8000c334:	2f f8       	sub	r8,-1
8000c336:	fb 48 06 b4 	st.w	sp[1716],r8
8000c33a:	c0 48       	rjmp	8000c342 <_vfprintf_r+0xc82>
8000c33c:	72 0a       	ld.w	r10,r9[0x0]
8000c33e:	2f c9       	sub	r9,-4
8000c340:	51 09       	stdsp	sp[0x40],r9
8000c342:	40 be       	lddsp	lr,sp[0x2c]
8000c344:	b4 0e       	st.h	r10[0x0],lr
8000c346:	fe 9f fa 48 	bral	8000b7d6 <_vfprintf_r+0x116>
8000c34a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c34e:	40 3c       	lddsp	r12,sp[0xc]
8000c350:	58 0c       	cp.w	r12,0
8000c352:	c1 d0       	breq	8000c38c <_vfprintf_r+0xccc>
8000c354:	10 36       	cp.w	r6,r8
8000c356:	c0 64       	brge	8000c362 <_vfprintf_r+0xca2>
8000c358:	fa cb f9 44 	sub	r11,sp,-1724
8000c35c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c360:	c1 d8       	rjmp	8000c39a <_vfprintf_r+0xcda>
8000c362:	fa c8 f9 50 	sub	r8,sp,-1712
8000c366:	1a d8       	st.w	--sp,r8
8000c368:	fa c8 fa b8 	sub	r8,sp,-1352
8000c36c:	04 9a       	mov	r10,r2
8000c36e:	1a d8       	st.w	--sp,r8
8000c370:	fa c8 fb b4 	sub	r8,sp,-1100
8000c374:	0c 9b       	mov	r11,r6
8000c376:	1a d8       	st.w	--sp,r8
8000c378:	08 9c       	mov	r12,r4
8000c37a:	fa c8 f9 40 	sub	r8,sp,-1728
8000c37e:	fa c9 ff b4 	sub	r9,sp,-76
8000c382:	fe b0 f8 01 	rcall	8000b384 <get_arg>
8000c386:	2f dd       	sub	sp,-12
8000c388:	78 0a       	ld.w	r10,r12[0x0]
8000c38a:	c2 08       	rjmp	8000c3ca <_vfprintf_r+0xd0a>
8000c38c:	2f f7       	sub	r7,-1
8000c38e:	10 39       	cp.w	r9,r8
8000c390:	c0 84       	brge	8000c3a0 <_vfprintf_r+0xce0>
8000c392:	fa ca f9 44 	sub	r10,sp,-1724
8000c396:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c39a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c39e:	c1 68       	rjmp	8000c3ca <_vfprintf_r+0xd0a>
8000c3a0:	41 09       	lddsp	r9,sp[0x40]
8000c3a2:	59 f8       	cp.w	r8,31
8000c3a4:	e0 89 00 10 	brgt	8000c3c4 <_vfprintf_r+0xd04>
8000c3a8:	f2 ca ff fc 	sub	r10,r9,-4
8000c3ac:	51 0a       	stdsp	sp[0x40],r10
8000c3ae:	fa c6 f9 44 	sub	r6,sp,-1724
8000c3b2:	72 0a       	ld.w	r10,r9[0x0]
8000c3b4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c3b8:	f3 4a fd 88 	st.w	r9[-632],r10
8000c3bc:	2f f8       	sub	r8,-1
8000c3be:	fb 48 06 b4 	st.w	sp[1716],r8
8000c3c2:	c0 48       	rjmp	8000c3ca <_vfprintf_r+0xd0a>
8000c3c4:	72 0a       	ld.w	r10,r9[0x0]
8000c3c6:	2f c9       	sub	r9,-4
8000c3c8:	51 09       	stdsp	sp[0x40],r9
8000c3ca:	40 be       	lddsp	lr,sp[0x2c]
8000c3cc:	95 0e       	st.w	r10[0x0],lr
8000c3ce:	fe 9f fa 04 	bral	8000b7d6 <_vfprintf_r+0x116>
8000c3d2:	50 a7       	stdsp	sp[0x28],r7
8000c3d4:	50 80       	stdsp	sp[0x20],r0
8000c3d6:	0c 97       	mov	r7,r6
8000c3d8:	04 94       	mov	r4,r2
8000c3da:	06 96       	mov	r6,r3
8000c3dc:	02 92       	mov	r2,r1
8000c3de:	40 93       	lddsp	r3,sp[0x24]
8000c3e0:	10 90       	mov	r0,r8
8000c3e2:	40 41       	lddsp	r1,sp[0x10]
8000c3e4:	a5 a5       	sbr	r5,0x4
8000c3e6:	c0 a8       	rjmp	8000c3fa <_vfprintf_r+0xd3a>
8000c3e8:	50 a7       	stdsp	sp[0x28],r7
8000c3ea:	50 80       	stdsp	sp[0x20],r0
8000c3ec:	0c 97       	mov	r7,r6
8000c3ee:	04 94       	mov	r4,r2
8000c3f0:	06 96       	mov	r6,r3
8000c3f2:	02 92       	mov	r2,r1
8000c3f4:	40 93       	lddsp	r3,sp[0x24]
8000c3f6:	10 90       	mov	r0,r8
8000c3f8:	40 41       	lddsp	r1,sp[0x10]
8000c3fa:	ed b5 00 05 	bld	r5,0x5
8000c3fe:	c5 d1       	brne	8000c4b8 <_vfprintf_r+0xdf8>
8000c400:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c404:	40 3c       	lddsp	r12,sp[0xc]
8000c406:	58 0c       	cp.w	r12,0
8000c408:	c2 60       	breq	8000c454 <_vfprintf_r+0xd94>
8000c40a:	10 36       	cp.w	r6,r8
8000c40c:	c0 a4       	brge	8000c420 <_vfprintf_r+0xd60>
8000c40e:	fa cb f9 44 	sub	r11,sp,-1724
8000c412:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c416:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c41a:	fa e9 00 00 	st.d	sp[0],r8
8000c41e:	c1 88       	rjmp	8000c44e <_vfprintf_r+0xd8e>
8000c420:	fa c8 f9 50 	sub	r8,sp,-1712
8000c424:	1a d8       	st.w	--sp,r8
8000c426:	fa c8 fa b8 	sub	r8,sp,-1352
8000c42a:	04 9a       	mov	r10,r2
8000c42c:	1a d8       	st.w	--sp,r8
8000c42e:	0c 9b       	mov	r11,r6
8000c430:	fa c8 fb b4 	sub	r8,sp,-1100
8000c434:	08 9c       	mov	r12,r4
8000c436:	1a d8       	st.w	--sp,r8
8000c438:	fa c8 f9 40 	sub	r8,sp,-1728
8000c43c:	fa c9 ff b4 	sub	r9,sp,-76
8000c440:	fe b0 f7 a2 	rcall	8000b384 <get_arg>
8000c444:	2f dd       	sub	sp,-12
8000c446:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c44a:	fa eb 00 00 	st.d	sp[0],r10
8000c44e:	30 08       	mov	r8,0
8000c450:	e0 8f 03 de 	bral	8000cc0c <_vfprintf_r+0x154c>
8000c454:	ee ca ff ff 	sub	r10,r7,-1
8000c458:	10 37       	cp.w	r7,r8
8000c45a:	c0 b4       	brge	8000c470 <_vfprintf_r+0xdb0>
8000c45c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c460:	14 97       	mov	r7,r10
8000c462:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c466:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c46a:	fa eb 00 00 	st.d	sp[0],r10
8000c46e:	c1 88       	rjmp	8000c49e <_vfprintf_r+0xdde>
8000c470:	41 09       	lddsp	r9,sp[0x40]
8000c472:	59 f8       	cp.w	r8,31
8000c474:	e0 89 00 18 	brgt	8000c4a4 <_vfprintf_r+0xde4>
8000c478:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c47c:	f2 cb ff f8 	sub	r11,r9,-8
8000c480:	fa e7 00 00 	st.d	sp[0],r6
8000c484:	51 0b       	stdsp	sp[0x40],r11
8000c486:	fa c6 f9 44 	sub	r6,sp,-1724
8000c48a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c48e:	fa e6 00 00 	ld.d	r6,sp[0]
8000c492:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c496:	2f f8       	sub	r8,-1
8000c498:	14 97       	mov	r7,r10
8000c49a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c49e:	40 38       	lddsp	r8,sp[0xc]
8000c4a0:	e0 8f 03 b6 	bral	8000cc0c <_vfprintf_r+0x154c>
8000c4a4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c4a8:	40 38       	lddsp	r8,sp[0xc]
8000c4aa:	fa e7 00 00 	st.d	sp[0],r6
8000c4ae:	2f 89       	sub	r9,-8
8000c4b0:	14 97       	mov	r7,r10
8000c4b2:	51 09       	stdsp	sp[0x40],r9
8000c4b4:	e0 8f 03 ac 	bral	8000cc0c <_vfprintf_r+0x154c>
8000c4b8:	ed b5 00 04 	bld	r5,0x4
8000c4bc:	c1 61       	brne	8000c4e8 <_vfprintf_r+0xe28>
8000c4be:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4c2:	40 3e       	lddsp	lr,sp[0xc]
8000c4c4:	58 0e       	cp.w	lr,0
8000c4c6:	c0 80       	breq	8000c4d6 <_vfprintf_r+0xe16>
8000c4c8:	10 36       	cp.w	r6,r8
8000c4ca:	c6 74       	brge	8000c598 <_vfprintf_r+0xed8>
8000c4cc:	fa cc f9 44 	sub	r12,sp,-1724
8000c4d0:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c4d4:	c8 08       	rjmp	8000c5d4 <_vfprintf_r+0xf14>
8000c4d6:	ee ca ff ff 	sub	r10,r7,-1
8000c4da:	10 37       	cp.w	r7,r8
8000c4dc:	c7 f4       	brge	8000c5da <_vfprintf_r+0xf1a>
8000c4de:	fa cb f9 44 	sub	r11,sp,-1724
8000c4e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c4e6:	c7 68       	rjmp	8000c5d2 <_vfprintf_r+0xf12>
8000c4e8:	ed b5 00 06 	bld	r5,0x6
8000c4ec:	c4 a1       	brne	8000c580 <_vfprintf_r+0xec0>
8000c4ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4f2:	40 3c       	lddsp	r12,sp[0xc]
8000c4f4:	58 0c       	cp.w	r12,0
8000c4f6:	c1 d0       	breq	8000c530 <_vfprintf_r+0xe70>
8000c4f8:	10 36       	cp.w	r6,r8
8000c4fa:	c0 64       	brge	8000c506 <_vfprintf_r+0xe46>
8000c4fc:	fa cb f9 44 	sub	r11,sp,-1724
8000c500:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c504:	c1 f8       	rjmp	8000c542 <_vfprintf_r+0xe82>
8000c506:	fa c8 f9 50 	sub	r8,sp,-1712
8000c50a:	1a d8       	st.w	--sp,r8
8000c50c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c510:	1a d8       	st.w	--sp,r8
8000c512:	fa c8 fb b4 	sub	r8,sp,-1100
8000c516:	1a d8       	st.w	--sp,r8
8000c518:	fa c8 f9 40 	sub	r8,sp,-1728
8000c51c:	fa c9 ff b4 	sub	r9,sp,-76
8000c520:	04 9a       	mov	r10,r2
8000c522:	0c 9b       	mov	r11,r6
8000c524:	08 9c       	mov	r12,r4
8000c526:	fe b0 f7 2f 	rcall	8000b384 <get_arg>
8000c52a:	2f dd       	sub	sp,-12
8000c52c:	98 18       	ld.sh	r8,r12[0x2]
8000c52e:	c2 68       	rjmp	8000c57a <_vfprintf_r+0xeba>
8000c530:	ee ca ff ff 	sub	r10,r7,-1
8000c534:	10 37       	cp.w	r7,r8
8000c536:	c0 94       	brge	8000c548 <_vfprintf_r+0xe88>
8000c538:	fa c9 f9 44 	sub	r9,sp,-1724
8000c53c:	14 97       	mov	r7,r10
8000c53e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c542:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c546:	c1 a8       	rjmp	8000c57a <_vfprintf_r+0xeba>
8000c548:	41 09       	lddsp	r9,sp[0x40]
8000c54a:	59 f8       	cp.w	r8,31
8000c54c:	e0 89 00 13 	brgt	8000c572 <_vfprintf_r+0xeb2>
8000c550:	f2 cb ff fc 	sub	r11,r9,-4
8000c554:	51 0b       	stdsp	sp[0x40],r11
8000c556:	72 09       	ld.w	r9,r9[0x0]
8000c558:	fa c6 f9 44 	sub	r6,sp,-1724
8000c55c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c560:	2f f8       	sub	r8,-1
8000c562:	f7 49 fd 88 	st.w	r11[-632],r9
8000c566:	fb 48 06 b4 	st.w	sp[1716],r8
8000c56a:	14 97       	mov	r7,r10
8000c56c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c570:	c0 58       	rjmp	8000c57a <_vfprintf_r+0xeba>
8000c572:	92 18       	ld.sh	r8,r9[0x2]
8000c574:	14 97       	mov	r7,r10
8000c576:	2f c9       	sub	r9,-4
8000c578:	51 09       	stdsp	sp[0x40],r9
8000c57a:	5c 78       	castu.h	r8
8000c57c:	50 18       	stdsp	sp[0x4],r8
8000c57e:	c4 68       	rjmp	8000c60a <_vfprintf_r+0xf4a>
8000c580:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c584:	40 3c       	lddsp	r12,sp[0xc]
8000c586:	58 0c       	cp.w	r12,0
8000c588:	c1 d0       	breq	8000c5c2 <_vfprintf_r+0xf02>
8000c58a:	10 36       	cp.w	r6,r8
8000c58c:	c0 64       	brge	8000c598 <_vfprintf_r+0xed8>
8000c58e:	fa cb f9 44 	sub	r11,sp,-1724
8000c592:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c596:	c1 f8       	rjmp	8000c5d4 <_vfprintf_r+0xf14>
8000c598:	fa c8 f9 50 	sub	r8,sp,-1712
8000c59c:	1a d8       	st.w	--sp,r8
8000c59e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c5a2:	0c 9b       	mov	r11,r6
8000c5a4:	1a d8       	st.w	--sp,r8
8000c5a6:	fa c8 fb b4 	sub	r8,sp,-1100
8000c5aa:	04 9a       	mov	r10,r2
8000c5ac:	1a d8       	st.w	--sp,r8
8000c5ae:	08 9c       	mov	r12,r4
8000c5b0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c5b4:	fa c9 ff b4 	sub	r9,sp,-76
8000c5b8:	fe b0 f6 e6 	rcall	8000b384 <get_arg>
8000c5bc:	2f dd       	sub	sp,-12
8000c5be:	78 0b       	ld.w	r11,r12[0x0]
8000c5c0:	c2 48       	rjmp	8000c608 <_vfprintf_r+0xf48>
8000c5c2:	ee ca ff ff 	sub	r10,r7,-1
8000c5c6:	10 37       	cp.w	r7,r8
8000c5c8:	c0 94       	brge	8000c5da <_vfprintf_r+0xf1a>
8000c5ca:	fa c9 f9 44 	sub	r9,sp,-1724
8000c5ce:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c5d2:	14 97       	mov	r7,r10
8000c5d4:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c5d8:	c1 88       	rjmp	8000c608 <_vfprintf_r+0xf48>
8000c5da:	41 09       	lddsp	r9,sp[0x40]
8000c5dc:	59 f8       	cp.w	r8,31
8000c5de:	e0 89 00 11 	brgt	8000c600 <_vfprintf_r+0xf40>
8000c5e2:	f2 cb ff fc 	sub	r11,r9,-4
8000c5e6:	51 0b       	stdsp	sp[0x40],r11
8000c5e8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c5ec:	72 0b       	ld.w	r11,r9[0x0]
8000c5ee:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c5f2:	f3 4b fd 88 	st.w	r9[-632],r11
8000c5f6:	2f f8       	sub	r8,-1
8000c5f8:	14 97       	mov	r7,r10
8000c5fa:	fb 48 06 b4 	st.w	sp[1716],r8
8000c5fe:	c0 58       	rjmp	8000c608 <_vfprintf_r+0xf48>
8000c600:	72 0b       	ld.w	r11,r9[0x0]
8000c602:	14 97       	mov	r7,r10
8000c604:	2f c9       	sub	r9,-4
8000c606:	51 09       	stdsp	sp[0x40],r9
8000c608:	50 1b       	stdsp	sp[0x4],r11
8000c60a:	30 0e       	mov	lr,0
8000c60c:	50 0e       	stdsp	sp[0x0],lr
8000c60e:	1c 98       	mov	r8,lr
8000c610:	e0 8f 02 fe 	bral	8000cc0c <_vfprintf_r+0x154c>
8000c614:	50 a7       	stdsp	sp[0x28],r7
8000c616:	50 80       	stdsp	sp[0x20],r0
8000c618:	0c 97       	mov	r7,r6
8000c61a:	04 94       	mov	r4,r2
8000c61c:	06 96       	mov	r6,r3
8000c61e:	02 92       	mov	r2,r1
8000c620:	40 93       	lddsp	r3,sp[0x24]
8000c622:	40 41       	lddsp	r1,sp[0x10]
8000c624:	0e 99       	mov	r9,r7
8000c626:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c62a:	40 3c       	lddsp	r12,sp[0xc]
8000c62c:	58 0c       	cp.w	r12,0
8000c62e:	c1 d0       	breq	8000c668 <_vfprintf_r+0xfa8>
8000c630:	10 36       	cp.w	r6,r8
8000c632:	c0 64       	brge	8000c63e <_vfprintf_r+0xf7e>
8000c634:	fa cb f9 44 	sub	r11,sp,-1724
8000c638:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c63c:	c1 d8       	rjmp	8000c676 <_vfprintf_r+0xfb6>
8000c63e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c642:	1a d8       	st.w	--sp,r8
8000c644:	fa c8 fa b8 	sub	r8,sp,-1352
8000c648:	1a d8       	st.w	--sp,r8
8000c64a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c64e:	1a d8       	st.w	--sp,r8
8000c650:	fa c9 ff b4 	sub	r9,sp,-76
8000c654:	fa c8 f9 40 	sub	r8,sp,-1728
8000c658:	04 9a       	mov	r10,r2
8000c65a:	0c 9b       	mov	r11,r6
8000c65c:	08 9c       	mov	r12,r4
8000c65e:	fe b0 f6 93 	rcall	8000b384 <get_arg>
8000c662:	2f dd       	sub	sp,-12
8000c664:	78 09       	ld.w	r9,r12[0x0]
8000c666:	c2 18       	rjmp	8000c6a8 <_vfprintf_r+0xfe8>
8000c668:	2f f7       	sub	r7,-1
8000c66a:	10 39       	cp.w	r9,r8
8000c66c:	c0 84       	brge	8000c67c <_vfprintf_r+0xfbc>
8000c66e:	fa ca f9 44 	sub	r10,sp,-1724
8000c672:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c676:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c67a:	c1 78       	rjmp	8000c6a8 <_vfprintf_r+0xfe8>
8000c67c:	41 09       	lddsp	r9,sp[0x40]
8000c67e:	59 f8       	cp.w	r8,31
8000c680:	e0 89 00 10 	brgt	8000c6a0 <_vfprintf_r+0xfe0>
8000c684:	f2 ca ff fc 	sub	r10,r9,-4
8000c688:	51 0a       	stdsp	sp[0x40],r10
8000c68a:	fa c6 f9 44 	sub	r6,sp,-1724
8000c68e:	72 09       	ld.w	r9,r9[0x0]
8000c690:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c694:	f5 49 fd 88 	st.w	r10[-632],r9
8000c698:	2f f8       	sub	r8,-1
8000c69a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c69e:	c0 58       	rjmp	8000c6a8 <_vfprintf_r+0xfe8>
8000c6a0:	f2 c8 ff fc 	sub	r8,r9,-4
8000c6a4:	51 08       	stdsp	sp[0x40],r8
8000c6a6:	72 09       	ld.w	r9,r9[0x0]
8000c6a8:	33 08       	mov	r8,48
8000c6aa:	fb 68 06 b8 	st.b	sp[1720],r8
8000c6ae:	37 88       	mov	r8,120
8000c6b0:	30 0e       	mov	lr,0
8000c6b2:	fb 68 06 b9 	st.b	sp[1721],r8
8000c6b6:	4c ac       	lddpc	r12,8000c7dc <_vfprintf_r+0x111c>
8000c6b8:	50 19       	stdsp	sp[0x4],r9
8000c6ba:	a1 b5       	sbr	r5,0x1
8000c6bc:	50 0e       	stdsp	sp[0x0],lr
8000c6be:	50 dc       	stdsp	sp[0x34],r12
8000c6c0:	30 28       	mov	r8,2
8000c6c2:	37 80       	mov	r0,120
8000c6c4:	e0 8f 02 a4 	bral	8000cc0c <_vfprintf_r+0x154c>
8000c6c8:	50 a7       	stdsp	sp[0x28],r7
8000c6ca:	50 80       	stdsp	sp[0x20],r0
8000c6cc:	10 90       	mov	r0,r8
8000c6ce:	30 08       	mov	r8,0
8000c6d0:	fb 68 06 bb 	st.b	sp[1723],r8
8000c6d4:	0c 97       	mov	r7,r6
8000c6d6:	04 94       	mov	r4,r2
8000c6d8:	06 96       	mov	r6,r3
8000c6da:	02 92       	mov	r2,r1
8000c6dc:	40 93       	lddsp	r3,sp[0x24]
8000c6de:	40 41       	lddsp	r1,sp[0x10]
8000c6e0:	0e 99       	mov	r9,r7
8000c6e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c6e6:	40 3b       	lddsp	r11,sp[0xc]
8000c6e8:	58 0b       	cp.w	r11,0
8000c6ea:	c1 d0       	breq	8000c724 <_vfprintf_r+0x1064>
8000c6ec:	10 36       	cp.w	r6,r8
8000c6ee:	c0 64       	brge	8000c6fa <_vfprintf_r+0x103a>
8000c6f0:	fa ca f9 44 	sub	r10,sp,-1724
8000c6f4:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c6f8:	c1 d8       	rjmp	8000c732 <_vfprintf_r+0x1072>
8000c6fa:	fa c8 f9 50 	sub	r8,sp,-1712
8000c6fe:	1a d8       	st.w	--sp,r8
8000c700:	fa c8 fa b8 	sub	r8,sp,-1352
8000c704:	1a d8       	st.w	--sp,r8
8000c706:	fa c8 fb b4 	sub	r8,sp,-1100
8000c70a:	0c 9b       	mov	r11,r6
8000c70c:	1a d8       	st.w	--sp,r8
8000c70e:	04 9a       	mov	r10,r2
8000c710:	fa c8 f9 40 	sub	r8,sp,-1728
8000c714:	fa c9 ff b4 	sub	r9,sp,-76
8000c718:	08 9c       	mov	r12,r4
8000c71a:	fe b0 f6 35 	rcall	8000b384 <get_arg>
8000c71e:	2f dd       	sub	sp,-12
8000c720:	78 06       	ld.w	r6,r12[0x0]
8000c722:	c2 08       	rjmp	8000c762 <_vfprintf_r+0x10a2>
8000c724:	2f f7       	sub	r7,-1
8000c726:	10 39       	cp.w	r9,r8
8000c728:	c0 84       	brge	8000c738 <_vfprintf_r+0x1078>
8000c72a:	fa c9 f9 44 	sub	r9,sp,-1724
8000c72e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c732:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c736:	c1 68       	rjmp	8000c762 <_vfprintf_r+0x10a2>
8000c738:	41 09       	lddsp	r9,sp[0x40]
8000c73a:	59 f8       	cp.w	r8,31
8000c73c:	e0 89 00 10 	brgt	8000c75c <_vfprintf_r+0x109c>
8000c740:	f2 ca ff fc 	sub	r10,r9,-4
8000c744:	51 0a       	stdsp	sp[0x40],r10
8000c746:	72 06       	ld.w	r6,r9[0x0]
8000c748:	fa ce f9 44 	sub	lr,sp,-1724
8000c74c:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c750:	f3 46 fd 88 	st.w	r9[-632],r6
8000c754:	2f f8       	sub	r8,-1
8000c756:	fb 48 06 b4 	st.w	sp[1716],r8
8000c75a:	c0 48       	rjmp	8000c762 <_vfprintf_r+0x10a2>
8000c75c:	72 06       	ld.w	r6,r9[0x0]
8000c75e:	2f c9       	sub	r9,-4
8000c760:	51 09       	stdsp	sp[0x40],r9
8000c762:	40 2c       	lddsp	r12,sp[0x8]
8000c764:	58 0c       	cp.w	r12,0
8000c766:	c1 05       	brlt	8000c786 <_vfprintf_r+0x10c6>
8000c768:	18 9a       	mov	r10,r12
8000c76a:	30 0b       	mov	r11,0
8000c76c:	0c 9c       	mov	r12,r6
8000c76e:	e0 a0 12 43 	rcall	8000ebf4 <memchr>
8000c772:	e0 80 02 e0 	breq	8000cd32 <_vfprintf_r+0x1672>
8000c776:	f8 06 01 02 	sub	r2,r12,r6
8000c77a:	40 2b       	lddsp	r11,sp[0x8]
8000c77c:	16 32       	cp.w	r2,r11
8000c77e:	e0 89 02 da 	brgt	8000cd32 <_vfprintf_r+0x1672>
8000c782:	e0 8f 02 d5 	bral	8000cd2c <_vfprintf_r+0x166c>
8000c786:	30 0a       	mov	r10,0
8000c788:	0c 9c       	mov	r12,r6
8000c78a:	50 2a       	stdsp	sp[0x8],r10
8000c78c:	fe b0 f4 ff 	rcall	8000b18a <strlen>
8000c790:	18 92       	mov	r2,r12
8000c792:	e0 8f 02 d3 	bral	8000cd38 <_vfprintf_r+0x1678>
8000c796:	50 a7       	stdsp	sp[0x28],r7
8000c798:	50 80       	stdsp	sp[0x20],r0
8000c79a:	0c 97       	mov	r7,r6
8000c79c:	04 94       	mov	r4,r2
8000c79e:	06 96       	mov	r6,r3
8000c7a0:	02 92       	mov	r2,r1
8000c7a2:	40 93       	lddsp	r3,sp[0x24]
8000c7a4:	10 90       	mov	r0,r8
8000c7a6:	40 41       	lddsp	r1,sp[0x10]
8000c7a8:	a5 a5       	sbr	r5,0x4
8000c7aa:	c0 a8       	rjmp	8000c7be <_vfprintf_r+0x10fe>
8000c7ac:	50 a7       	stdsp	sp[0x28],r7
8000c7ae:	50 80       	stdsp	sp[0x20],r0
8000c7b0:	0c 97       	mov	r7,r6
8000c7b2:	04 94       	mov	r4,r2
8000c7b4:	06 96       	mov	r6,r3
8000c7b6:	02 92       	mov	r2,r1
8000c7b8:	40 93       	lddsp	r3,sp[0x24]
8000c7ba:	10 90       	mov	r0,r8
8000c7bc:	40 41       	lddsp	r1,sp[0x10]
8000c7be:	ed b5 00 05 	bld	r5,0x5
8000c7c2:	c5 71       	brne	8000c870 <_vfprintf_r+0x11b0>
8000c7c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c7c8:	40 39       	lddsp	r9,sp[0xc]
8000c7ca:	58 09       	cp.w	r9,0
8000c7cc:	c2 20       	breq	8000c810 <_vfprintf_r+0x1150>
8000c7ce:	10 36       	cp.w	r6,r8
8000c7d0:	c0 84       	brge	8000c7e0 <_vfprintf_r+0x1120>
8000c7d2:	fa c8 f9 44 	sub	r8,sp,-1724
8000c7d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c7da:	c2 48       	rjmp	8000c822 <_vfprintf_r+0x1162>
8000c7dc:	80 01       	ld.sh	r1,r0[0x0]
8000c7de:	9f 60       	st.w	pc[0x18],r0
8000c7e0:	fa c8 f9 50 	sub	r8,sp,-1712
8000c7e4:	1a d8       	st.w	--sp,r8
8000c7e6:	fa c8 fa b8 	sub	r8,sp,-1352
8000c7ea:	1a d8       	st.w	--sp,r8
8000c7ec:	fa c8 fb b4 	sub	r8,sp,-1100
8000c7f0:	1a d8       	st.w	--sp,r8
8000c7f2:	fa c8 f9 40 	sub	r8,sp,-1728
8000c7f6:	fa c9 ff b4 	sub	r9,sp,-76
8000c7fa:	04 9a       	mov	r10,r2
8000c7fc:	0c 9b       	mov	r11,r6
8000c7fe:	08 9c       	mov	r12,r4
8000c800:	fe b0 f5 c2 	rcall	8000b384 <get_arg>
8000c804:	2f dd       	sub	sp,-12
8000c806:	f8 e8 00 00 	ld.d	r8,r12[0]
8000c80a:	fa e9 00 00 	st.d	sp[0],r8
8000c80e:	c2 e8       	rjmp	8000c86a <_vfprintf_r+0x11aa>
8000c810:	ee ca ff ff 	sub	r10,r7,-1
8000c814:	10 37       	cp.w	r7,r8
8000c816:	c0 b4       	brge	8000c82c <_vfprintf_r+0x116c>
8000c818:	fa c8 f9 44 	sub	r8,sp,-1724
8000c81c:	14 97       	mov	r7,r10
8000c81e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c822:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c826:	fa eb 00 00 	st.d	sp[0],r10
8000c82a:	c2 08       	rjmp	8000c86a <_vfprintf_r+0x11aa>
8000c82c:	41 09       	lddsp	r9,sp[0x40]
8000c82e:	59 f8       	cp.w	r8,31
8000c830:	e0 89 00 16 	brgt	8000c85c <_vfprintf_r+0x119c>
8000c834:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c838:	f2 cb ff f8 	sub	r11,r9,-8
8000c83c:	fa e7 00 00 	st.d	sp[0],r6
8000c840:	51 0b       	stdsp	sp[0x40],r11
8000c842:	fa c6 f9 44 	sub	r6,sp,-1724
8000c846:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c84a:	fa e6 00 00 	ld.d	r6,sp[0]
8000c84e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c852:	2f f8       	sub	r8,-1
8000c854:	14 97       	mov	r7,r10
8000c856:	fb 48 06 b4 	st.w	sp[1716],r8
8000c85a:	c0 88       	rjmp	8000c86a <_vfprintf_r+0x11aa>
8000c85c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c860:	2f 89       	sub	r9,-8
8000c862:	fa e7 00 00 	st.d	sp[0],r6
8000c866:	51 09       	stdsp	sp[0x40],r9
8000c868:	14 97       	mov	r7,r10
8000c86a:	30 18       	mov	r8,1
8000c86c:	e0 8f 01 d0 	bral	8000cc0c <_vfprintf_r+0x154c>
8000c870:	ed b5 00 04 	bld	r5,0x4
8000c874:	c1 61       	brne	8000c8a0 <_vfprintf_r+0x11e0>
8000c876:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c87a:	40 3e       	lddsp	lr,sp[0xc]
8000c87c:	58 0e       	cp.w	lr,0
8000c87e:	c0 80       	breq	8000c88e <_vfprintf_r+0x11ce>
8000c880:	10 36       	cp.w	r6,r8
8000c882:	c6 74       	brge	8000c950 <_vfprintf_r+0x1290>
8000c884:	fa cc f9 44 	sub	r12,sp,-1724
8000c888:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c88c:	c8 08       	rjmp	8000c98c <_vfprintf_r+0x12cc>
8000c88e:	ee ca ff ff 	sub	r10,r7,-1
8000c892:	10 37       	cp.w	r7,r8
8000c894:	c7 f4       	brge	8000c992 <_vfprintf_r+0x12d2>
8000c896:	fa cb f9 44 	sub	r11,sp,-1724
8000c89a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c89e:	c7 68       	rjmp	8000c98a <_vfprintf_r+0x12ca>
8000c8a0:	ed b5 00 06 	bld	r5,0x6
8000c8a4:	c4 a1       	brne	8000c938 <_vfprintf_r+0x1278>
8000c8a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c8aa:	40 3c       	lddsp	r12,sp[0xc]
8000c8ac:	58 0c       	cp.w	r12,0
8000c8ae:	c1 d0       	breq	8000c8e8 <_vfprintf_r+0x1228>
8000c8b0:	10 36       	cp.w	r6,r8
8000c8b2:	c0 64       	brge	8000c8be <_vfprintf_r+0x11fe>
8000c8b4:	fa cb f9 44 	sub	r11,sp,-1724
8000c8b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c8bc:	c1 f8       	rjmp	8000c8fa <_vfprintf_r+0x123a>
8000c8be:	fa c8 f9 50 	sub	r8,sp,-1712
8000c8c2:	1a d8       	st.w	--sp,r8
8000c8c4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c8c8:	1a d8       	st.w	--sp,r8
8000c8ca:	fa c8 fb b4 	sub	r8,sp,-1100
8000c8ce:	1a d8       	st.w	--sp,r8
8000c8d0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c8d4:	fa c9 ff b4 	sub	r9,sp,-76
8000c8d8:	04 9a       	mov	r10,r2
8000c8da:	0c 9b       	mov	r11,r6
8000c8dc:	08 9c       	mov	r12,r4
8000c8de:	fe b0 f5 53 	rcall	8000b384 <get_arg>
8000c8e2:	2f dd       	sub	sp,-12
8000c8e4:	98 18       	ld.sh	r8,r12[0x2]
8000c8e6:	c2 68       	rjmp	8000c932 <_vfprintf_r+0x1272>
8000c8e8:	ee ca ff ff 	sub	r10,r7,-1
8000c8ec:	10 37       	cp.w	r7,r8
8000c8ee:	c0 94       	brge	8000c900 <_vfprintf_r+0x1240>
8000c8f0:	fa c9 f9 44 	sub	r9,sp,-1724
8000c8f4:	14 97       	mov	r7,r10
8000c8f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c8fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c8fe:	c1 a8       	rjmp	8000c932 <_vfprintf_r+0x1272>
8000c900:	41 09       	lddsp	r9,sp[0x40]
8000c902:	59 f8       	cp.w	r8,31
8000c904:	e0 89 00 13 	brgt	8000c92a <_vfprintf_r+0x126a>
8000c908:	f2 cb ff fc 	sub	r11,r9,-4
8000c90c:	51 0b       	stdsp	sp[0x40],r11
8000c90e:	72 09       	ld.w	r9,r9[0x0]
8000c910:	fa c6 f9 44 	sub	r6,sp,-1724
8000c914:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c918:	2f f8       	sub	r8,-1
8000c91a:	f7 49 fd 88 	st.w	r11[-632],r9
8000c91e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c922:	14 97       	mov	r7,r10
8000c924:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c928:	c0 58       	rjmp	8000c932 <_vfprintf_r+0x1272>
8000c92a:	92 18       	ld.sh	r8,r9[0x2]
8000c92c:	14 97       	mov	r7,r10
8000c92e:	2f c9       	sub	r9,-4
8000c930:	51 09       	stdsp	sp[0x40],r9
8000c932:	5c 78       	castu.h	r8
8000c934:	50 18       	stdsp	sp[0x4],r8
8000c936:	c4 68       	rjmp	8000c9c2 <_vfprintf_r+0x1302>
8000c938:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c93c:	40 3c       	lddsp	r12,sp[0xc]
8000c93e:	58 0c       	cp.w	r12,0
8000c940:	c1 d0       	breq	8000c97a <_vfprintf_r+0x12ba>
8000c942:	10 36       	cp.w	r6,r8
8000c944:	c0 64       	brge	8000c950 <_vfprintf_r+0x1290>
8000c946:	fa cb f9 44 	sub	r11,sp,-1724
8000c94a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c94e:	c1 f8       	rjmp	8000c98c <_vfprintf_r+0x12cc>
8000c950:	fa c8 f9 50 	sub	r8,sp,-1712
8000c954:	1a d8       	st.w	--sp,r8
8000c956:	fa c8 fa b8 	sub	r8,sp,-1352
8000c95a:	0c 9b       	mov	r11,r6
8000c95c:	1a d8       	st.w	--sp,r8
8000c95e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c962:	04 9a       	mov	r10,r2
8000c964:	1a d8       	st.w	--sp,r8
8000c966:	08 9c       	mov	r12,r4
8000c968:	fa c8 f9 40 	sub	r8,sp,-1728
8000c96c:	fa c9 ff b4 	sub	r9,sp,-76
8000c970:	fe b0 f5 0a 	rcall	8000b384 <get_arg>
8000c974:	2f dd       	sub	sp,-12
8000c976:	78 0b       	ld.w	r11,r12[0x0]
8000c978:	c2 48       	rjmp	8000c9c0 <_vfprintf_r+0x1300>
8000c97a:	ee ca ff ff 	sub	r10,r7,-1
8000c97e:	10 37       	cp.w	r7,r8
8000c980:	c0 94       	brge	8000c992 <_vfprintf_r+0x12d2>
8000c982:	fa c9 f9 44 	sub	r9,sp,-1724
8000c986:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c98a:	14 97       	mov	r7,r10
8000c98c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c990:	c1 88       	rjmp	8000c9c0 <_vfprintf_r+0x1300>
8000c992:	41 09       	lddsp	r9,sp[0x40]
8000c994:	59 f8       	cp.w	r8,31
8000c996:	e0 89 00 11 	brgt	8000c9b8 <_vfprintf_r+0x12f8>
8000c99a:	f2 cb ff fc 	sub	r11,r9,-4
8000c99e:	51 0b       	stdsp	sp[0x40],r11
8000c9a0:	fa c6 f9 44 	sub	r6,sp,-1724
8000c9a4:	72 0b       	ld.w	r11,r9[0x0]
8000c9a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c9aa:	f3 4b fd 88 	st.w	r9[-632],r11
8000c9ae:	2f f8       	sub	r8,-1
8000c9b0:	14 97       	mov	r7,r10
8000c9b2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c9b6:	c0 58       	rjmp	8000c9c0 <_vfprintf_r+0x1300>
8000c9b8:	72 0b       	ld.w	r11,r9[0x0]
8000c9ba:	14 97       	mov	r7,r10
8000c9bc:	2f c9       	sub	r9,-4
8000c9be:	51 09       	stdsp	sp[0x40],r9
8000c9c0:	50 1b       	stdsp	sp[0x4],r11
8000c9c2:	30 0e       	mov	lr,0
8000c9c4:	30 18       	mov	r8,1
8000c9c6:	50 0e       	stdsp	sp[0x0],lr
8000c9c8:	c2 29       	rjmp	8000cc0c <_vfprintf_r+0x154c>
8000c9ca:	50 a7       	stdsp	sp[0x28],r7
8000c9cc:	50 80       	stdsp	sp[0x20],r0
8000c9ce:	0c 97       	mov	r7,r6
8000c9d0:	04 94       	mov	r4,r2
8000c9d2:	06 96       	mov	r6,r3
8000c9d4:	02 92       	mov	r2,r1
8000c9d6:	4d 3c       	lddpc	r12,8000cb20 <_vfprintf_r+0x1460>
8000c9d8:	40 93       	lddsp	r3,sp[0x24]
8000c9da:	10 90       	mov	r0,r8
8000c9dc:	40 41       	lddsp	r1,sp[0x10]
8000c9de:	50 dc       	stdsp	sp[0x34],r12
8000c9e0:	ed b5 00 05 	bld	r5,0x5
8000c9e4:	c5 51       	brne	8000ca8e <_vfprintf_r+0x13ce>
8000c9e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c9ea:	40 3b       	lddsp	r11,sp[0xc]
8000c9ec:	58 0b       	cp.w	r11,0
8000c9ee:	c2 20       	breq	8000ca32 <_vfprintf_r+0x1372>
8000c9f0:	10 36       	cp.w	r6,r8
8000c9f2:	c0 a4       	brge	8000ca06 <_vfprintf_r+0x1346>
8000c9f4:	fa ca f9 44 	sub	r10,sp,-1724
8000c9f8:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c9fc:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000ca00:	fa e9 00 00 	st.d	sp[0],r8
8000ca04:	cf 38       	rjmp	8000cbea <_vfprintf_r+0x152a>
8000ca06:	fa c8 f9 50 	sub	r8,sp,-1712
8000ca0a:	1a d8       	st.w	--sp,r8
8000ca0c:	fa c8 fa b8 	sub	r8,sp,-1352
8000ca10:	04 9a       	mov	r10,r2
8000ca12:	1a d8       	st.w	--sp,r8
8000ca14:	0c 9b       	mov	r11,r6
8000ca16:	fa c8 fb b4 	sub	r8,sp,-1100
8000ca1a:	08 9c       	mov	r12,r4
8000ca1c:	1a d8       	st.w	--sp,r8
8000ca1e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ca22:	fa c9 ff b4 	sub	r9,sp,-76
8000ca26:	fe b0 f4 af 	rcall	8000b384 <get_arg>
8000ca2a:	2f dd       	sub	sp,-12
8000ca2c:	f8 ea 00 00 	ld.d	r10,r12[0]
8000ca30:	c0 c8       	rjmp	8000ca48 <_vfprintf_r+0x1388>
8000ca32:	ee ca ff ff 	sub	r10,r7,-1
8000ca36:	10 37       	cp.w	r7,r8
8000ca38:	c0 b4       	brge	8000ca4e <_vfprintf_r+0x138e>
8000ca3a:	fa c9 f9 44 	sub	r9,sp,-1724
8000ca3e:	14 97       	mov	r7,r10
8000ca40:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ca44:	ec ea fd 88 	ld.d	r10,r6[-632]
8000ca48:	fa eb 00 00 	st.d	sp[0],r10
8000ca4c:	cc f8       	rjmp	8000cbea <_vfprintf_r+0x152a>
8000ca4e:	41 09       	lddsp	r9,sp[0x40]
8000ca50:	59 f8       	cp.w	r8,31
8000ca52:	e0 89 00 16 	brgt	8000ca7e <_vfprintf_r+0x13be>
8000ca56:	f2 e6 00 00 	ld.d	r6,r9[0]
8000ca5a:	f2 cb ff f8 	sub	r11,r9,-8
8000ca5e:	fa e7 00 00 	st.d	sp[0],r6
8000ca62:	51 0b       	stdsp	sp[0x40],r11
8000ca64:	fa c6 f9 44 	sub	r6,sp,-1724
8000ca68:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ca6c:	fa e6 00 00 	ld.d	r6,sp[0]
8000ca70:	f2 e7 fd 88 	st.d	r9[-632],r6
8000ca74:	2f f8       	sub	r8,-1
8000ca76:	14 97       	mov	r7,r10
8000ca78:	fb 48 06 b4 	st.w	sp[1716],r8
8000ca7c:	cb 78       	rjmp	8000cbea <_vfprintf_r+0x152a>
8000ca7e:	f2 e6 00 00 	ld.d	r6,r9[0]
8000ca82:	2f 89       	sub	r9,-8
8000ca84:	fa e7 00 00 	st.d	sp[0],r6
8000ca88:	51 09       	stdsp	sp[0x40],r9
8000ca8a:	14 97       	mov	r7,r10
8000ca8c:	ca f8       	rjmp	8000cbea <_vfprintf_r+0x152a>
8000ca8e:	ed b5 00 04 	bld	r5,0x4
8000ca92:	c1 71       	brne	8000cac0 <_vfprintf_r+0x1400>
8000ca94:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ca98:	40 3e       	lddsp	lr,sp[0xc]
8000ca9a:	58 0e       	cp.w	lr,0
8000ca9c:	c0 80       	breq	8000caac <_vfprintf_r+0x13ec>
8000ca9e:	10 36       	cp.w	r6,r8
8000caa0:	c6 a4       	brge	8000cb74 <_vfprintf_r+0x14b4>
8000caa2:	fa cc f9 44 	sub	r12,sp,-1724
8000caa6:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000caaa:	c8 38       	rjmp	8000cbb0 <_vfprintf_r+0x14f0>
8000caac:	ee ca ff ff 	sub	r10,r7,-1
8000cab0:	10 37       	cp.w	r7,r8
8000cab2:	e0 84 00 82 	brge	8000cbb6 <_vfprintf_r+0x14f6>
8000cab6:	fa cb f9 44 	sub	r11,sp,-1724
8000caba:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cabe:	c7 88       	rjmp	8000cbae <_vfprintf_r+0x14ee>
8000cac0:	ed b5 00 06 	bld	r5,0x6
8000cac4:	c4 c1       	brne	8000cb5c <_vfprintf_r+0x149c>
8000cac6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000caca:	40 3c       	lddsp	r12,sp[0xc]
8000cacc:	58 0c       	cp.w	r12,0
8000cace:	c1 d0       	breq	8000cb08 <_vfprintf_r+0x1448>
8000cad0:	10 36       	cp.w	r6,r8
8000cad2:	c0 64       	brge	8000cade <_vfprintf_r+0x141e>
8000cad4:	fa cb f9 44 	sub	r11,sp,-1724
8000cad8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cadc:	c1 f8       	rjmp	8000cb1a <_vfprintf_r+0x145a>
8000cade:	fa c8 f9 50 	sub	r8,sp,-1712
8000cae2:	1a d8       	st.w	--sp,r8
8000cae4:	fa c8 fa b8 	sub	r8,sp,-1352
8000cae8:	1a d8       	st.w	--sp,r8
8000caea:	fa c8 fb b4 	sub	r8,sp,-1100
8000caee:	1a d8       	st.w	--sp,r8
8000caf0:	fa c8 f9 40 	sub	r8,sp,-1728
8000caf4:	fa c9 ff b4 	sub	r9,sp,-76
8000caf8:	04 9a       	mov	r10,r2
8000cafa:	0c 9b       	mov	r11,r6
8000cafc:	08 9c       	mov	r12,r4
8000cafe:	fe b0 f4 43 	rcall	8000b384 <get_arg>
8000cb02:	2f dd       	sub	sp,-12
8000cb04:	98 18       	ld.sh	r8,r12[0x2]
8000cb06:	c2 88       	rjmp	8000cb56 <_vfprintf_r+0x1496>
8000cb08:	ee ca ff ff 	sub	r10,r7,-1
8000cb0c:	10 37       	cp.w	r7,r8
8000cb0e:	c0 b4       	brge	8000cb24 <_vfprintf_r+0x1464>
8000cb10:	fa c9 f9 44 	sub	r9,sp,-1724
8000cb14:	14 97       	mov	r7,r10
8000cb16:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cb1a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000cb1e:	c1 c8       	rjmp	8000cb56 <_vfprintf_r+0x1496>
8000cb20:	80 01       	ld.sh	r1,r0[0x0]
8000cb22:	9f 60       	st.w	pc[0x18],r0
8000cb24:	41 09       	lddsp	r9,sp[0x40]
8000cb26:	59 f8       	cp.w	r8,31
8000cb28:	e0 89 00 13 	brgt	8000cb4e <_vfprintf_r+0x148e>
8000cb2c:	f2 cb ff fc 	sub	r11,r9,-4
8000cb30:	51 0b       	stdsp	sp[0x40],r11
8000cb32:	72 09       	ld.w	r9,r9[0x0]
8000cb34:	fa c6 f9 44 	sub	r6,sp,-1724
8000cb38:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000cb3c:	2f f8       	sub	r8,-1
8000cb3e:	f7 49 fd 88 	st.w	r11[-632],r9
8000cb42:	fb 48 06 b4 	st.w	sp[1716],r8
8000cb46:	14 97       	mov	r7,r10
8000cb48:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000cb4c:	c0 58       	rjmp	8000cb56 <_vfprintf_r+0x1496>
8000cb4e:	92 18       	ld.sh	r8,r9[0x2]
8000cb50:	14 97       	mov	r7,r10
8000cb52:	2f c9       	sub	r9,-4
8000cb54:	51 09       	stdsp	sp[0x40],r9
8000cb56:	5c 78       	castu.h	r8
8000cb58:	50 18       	stdsp	sp[0x4],r8
8000cb5a:	c4 68       	rjmp	8000cbe6 <_vfprintf_r+0x1526>
8000cb5c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cb60:	40 3c       	lddsp	r12,sp[0xc]
8000cb62:	58 0c       	cp.w	r12,0
8000cb64:	c1 d0       	breq	8000cb9e <_vfprintf_r+0x14de>
8000cb66:	10 36       	cp.w	r6,r8
8000cb68:	c0 64       	brge	8000cb74 <_vfprintf_r+0x14b4>
8000cb6a:	fa cb f9 44 	sub	r11,sp,-1724
8000cb6e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cb72:	c1 f8       	rjmp	8000cbb0 <_vfprintf_r+0x14f0>
8000cb74:	fa c8 f9 50 	sub	r8,sp,-1712
8000cb78:	1a d8       	st.w	--sp,r8
8000cb7a:	fa c8 fa b8 	sub	r8,sp,-1352
8000cb7e:	0c 9b       	mov	r11,r6
8000cb80:	1a d8       	st.w	--sp,r8
8000cb82:	fa c8 fb b4 	sub	r8,sp,-1100
8000cb86:	04 9a       	mov	r10,r2
8000cb88:	1a d8       	st.w	--sp,r8
8000cb8a:	08 9c       	mov	r12,r4
8000cb8c:	fa c8 f9 40 	sub	r8,sp,-1728
8000cb90:	fa c9 ff b4 	sub	r9,sp,-76
8000cb94:	fe b0 f3 f8 	rcall	8000b384 <get_arg>
8000cb98:	2f dd       	sub	sp,-12
8000cb9a:	78 0b       	ld.w	r11,r12[0x0]
8000cb9c:	c2 48       	rjmp	8000cbe4 <_vfprintf_r+0x1524>
8000cb9e:	ee ca ff ff 	sub	r10,r7,-1
8000cba2:	10 37       	cp.w	r7,r8
8000cba4:	c0 94       	brge	8000cbb6 <_vfprintf_r+0x14f6>
8000cba6:	fa c9 f9 44 	sub	r9,sp,-1724
8000cbaa:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cbae:	14 97       	mov	r7,r10
8000cbb0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000cbb4:	c1 88       	rjmp	8000cbe4 <_vfprintf_r+0x1524>
8000cbb6:	41 09       	lddsp	r9,sp[0x40]
8000cbb8:	59 f8       	cp.w	r8,31
8000cbba:	e0 89 00 11 	brgt	8000cbdc <_vfprintf_r+0x151c>
8000cbbe:	f2 cb ff fc 	sub	r11,r9,-4
8000cbc2:	51 0b       	stdsp	sp[0x40],r11
8000cbc4:	fa c6 f9 44 	sub	r6,sp,-1724
8000cbc8:	72 0b       	ld.w	r11,r9[0x0]
8000cbca:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cbce:	f3 4b fd 88 	st.w	r9[-632],r11
8000cbd2:	2f f8       	sub	r8,-1
8000cbd4:	14 97       	mov	r7,r10
8000cbd6:	fb 48 06 b4 	st.w	sp[1716],r8
8000cbda:	c0 58       	rjmp	8000cbe4 <_vfprintf_r+0x1524>
8000cbdc:	72 0b       	ld.w	r11,r9[0x0]
8000cbde:	14 97       	mov	r7,r10
8000cbe0:	2f c9       	sub	r9,-4
8000cbe2:	51 09       	stdsp	sp[0x40],r9
8000cbe4:	50 1b       	stdsp	sp[0x4],r11
8000cbe6:	30 0e       	mov	lr,0
8000cbe8:	50 0e       	stdsp	sp[0x0],lr
8000cbea:	40 08       	lddsp	r8,sp[0x0]
8000cbec:	40 1c       	lddsp	r12,sp[0x4]
8000cbee:	18 48       	or	r8,r12
8000cbf0:	5f 19       	srne	r9
8000cbf2:	0a 98       	mov	r8,r5
8000cbf4:	eb e9 00 09 	and	r9,r5,r9
8000cbf8:	a1 b8       	sbr	r8,0x1
8000cbfa:	58 09       	cp.w	r9,0
8000cbfc:	c0 70       	breq	8000cc0a <_vfprintf_r+0x154a>
8000cbfe:	10 95       	mov	r5,r8
8000cc00:	fb 60 06 b9 	st.b	sp[1721],r0
8000cc04:	33 08       	mov	r8,48
8000cc06:	fb 68 06 b8 	st.b	sp[1720],r8
8000cc0a:	30 28       	mov	r8,2
8000cc0c:	30 09       	mov	r9,0
8000cc0e:	fb 69 06 bb 	st.b	sp[1723],r9
8000cc12:	0a 99       	mov	r9,r5
8000cc14:	a7 d9       	cbr	r9,0x7
8000cc16:	40 2b       	lddsp	r11,sp[0x8]
8000cc18:	40 16       	lddsp	r6,sp[0x4]
8000cc1a:	58 0b       	cp.w	r11,0
8000cc1c:	5f 1a       	srne	r10
8000cc1e:	f2 05 17 40 	movge	r5,r9
8000cc22:	fa c2 f9 78 	sub	r2,sp,-1672
8000cc26:	40 09       	lddsp	r9,sp[0x0]
8000cc28:	0c 49       	or	r9,r6
8000cc2a:	5f 19       	srne	r9
8000cc2c:	f5 e9 10 09 	or	r9,r10,r9
8000cc30:	c5 c0       	breq	8000cce8 <_vfprintf_r+0x1628>
8000cc32:	30 19       	mov	r9,1
8000cc34:	f2 08 18 00 	cp.b	r8,r9
8000cc38:	c0 60       	breq	8000cc44 <_vfprintf_r+0x1584>
8000cc3a:	30 29       	mov	r9,2
8000cc3c:	f2 08 18 00 	cp.b	r8,r9
8000cc40:	c0 41       	brne	8000cc48 <_vfprintf_r+0x1588>
8000cc42:	c3 c8       	rjmp	8000ccba <_vfprintf_r+0x15fa>
8000cc44:	04 96       	mov	r6,r2
8000cc46:	c3 08       	rjmp	8000cca6 <_vfprintf_r+0x15e6>
8000cc48:	04 96       	mov	r6,r2
8000cc4a:	fa e8 00 00 	ld.d	r8,sp[0]
8000cc4e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000cc52:	2d 0a       	sub	r10,-48
8000cc54:	0c fa       	st.b	--r6,r10
8000cc56:	f0 0b 16 03 	lsr	r11,r8,0x3
8000cc5a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000cc5e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000cc62:	18 99       	mov	r9,r12
8000cc64:	16 98       	mov	r8,r11
8000cc66:	58 08       	cp.w	r8,0
8000cc68:	5c 29       	cpc	r9
8000cc6a:	cf 21       	brne	8000cc4e <_vfprintf_r+0x158e>
8000cc6c:	fa e9 00 00 	st.d	sp[0],r8
8000cc70:	ed b5 00 00 	bld	r5,0x0
8000cc74:	c4 51       	brne	8000ccfe <_vfprintf_r+0x163e>
8000cc76:	33 09       	mov	r9,48
8000cc78:	f2 0a 18 00 	cp.b	r10,r9
8000cc7c:	c4 10       	breq	8000ccfe <_vfprintf_r+0x163e>
8000cc7e:	0c f9       	st.b	--r6,r9
8000cc80:	c3 f8       	rjmp	8000ccfe <_vfprintf_r+0x163e>
8000cc82:	fa ea 00 00 	ld.d	r10,sp[0]
8000cc86:	30 a8       	mov	r8,10
8000cc88:	30 09       	mov	r9,0
8000cc8a:	e0 a0 1a 1b 	rcall	800100c0 <__avr32_umod64>
8000cc8e:	30 a8       	mov	r8,10
8000cc90:	2d 0a       	sub	r10,-48
8000cc92:	30 09       	mov	r9,0
8000cc94:	ac 8a       	st.b	r6[0x0],r10
8000cc96:	fa ea 00 00 	ld.d	r10,sp[0]
8000cc9a:	e0 a0 18 e1 	rcall	8000fe5c <__avr32_udiv64>
8000cc9e:	16 99       	mov	r9,r11
8000cca0:	14 98       	mov	r8,r10
8000cca2:	fa e9 00 00 	st.d	sp[0],r8
8000cca6:	20 16       	sub	r6,1
8000cca8:	fa ea 00 00 	ld.d	r10,sp[0]
8000ccac:	58 9a       	cp.w	r10,9
8000ccae:	5c 2b       	cpc	r11
8000ccb0:	fe 9b ff e9 	brhi	8000cc82 <_vfprintf_r+0x15c2>
8000ccb4:	1b f8       	ld.ub	r8,sp[0x7]
8000ccb6:	2d 08       	sub	r8,-48
8000ccb8:	c2 08       	rjmp	8000ccf8 <_vfprintf_r+0x1638>
8000ccba:	04 96       	mov	r6,r2
8000ccbc:	fa e8 00 00 	ld.d	r8,sp[0]
8000ccc0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000ccc4:	40 de       	lddsp	lr,sp[0x34]
8000ccc6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000ccca:	0c fa       	st.b	--r6,r10
8000cccc:	f2 0b 16 04 	lsr	r11,r9,0x4
8000ccd0:	f0 0a 16 04 	lsr	r10,r8,0x4
8000ccd4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000ccd8:	16 99       	mov	r9,r11
8000ccda:	14 98       	mov	r8,r10
8000ccdc:	58 08       	cp.w	r8,0
8000ccde:	5c 29       	cpc	r9
8000cce0:	cf 01       	brne	8000ccc0 <_vfprintf_r+0x1600>
8000cce2:	fa e9 00 00 	st.d	sp[0],r8
8000cce6:	c0 c8       	rjmp	8000ccfe <_vfprintf_r+0x163e>
8000cce8:	58 08       	cp.w	r8,0
8000ccea:	c0 91       	brne	8000ccfc <_vfprintf_r+0x163c>
8000ccec:	ed b5 00 00 	bld	r5,0x0
8000ccf0:	c0 61       	brne	8000ccfc <_vfprintf_r+0x163c>
8000ccf2:	fa c6 f9 79 	sub	r6,sp,-1671
8000ccf6:	33 08       	mov	r8,48
8000ccf8:	ac 88       	st.b	r6[0x0],r8
8000ccfa:	c0 28       	rjmp	8000ccfe <_vfprintf_r+0x163e>
8000ccfc:	04 96       	mov	r6,r2
8000ccfe:	0c 12       	sub	r2,r6
8000cd00:	c1 c8       	rjmp	8000cd38 <_vfprintf_r+0x1678>
8000cd02:	50 a7       	stdsp	sp[0x28],r7
8000cd04:	50 80       	stdsp	sp[0x20],r0
8000cd06:	40 93       	lddsp	r3,sp[0x24]
8000cd08:	0c 97       	mov	r7,r6
8000cd0a:	10 90       	mov	r0,r8
8000cd0c:	04 94       	mov	r4,r2
8000cd0e:	40 41       	lddsp	r1,sp[0x10]
8000cd10:	58 08       	cp.w	r8,0
8000cd12:	e0 80 04 51 	breq	8000d5b4 <_vfprintf_r+0x1ef4>
8000cd16:	fb 68 06 60 	st.b	sp[1632],r8
8000cd1a:	30 0c       	mov	r12,0
8000cd1c:	30 08       	mov	r8,0
8000cd1e:	30 12       	mov	r2,1
8000cd20:	fb 68 06 bb 	st.b	sp[1723],r8
8000cd24:	50 2c       	stdsp	sp[0x8],r12
8000cd26:	fa c6 f9 a0 	sub	r6,sp,-1632
8000cd2a:	c0 78       	rjmp	8000cd38 <_vfprintf_r+0x1678>
8000cd2c:	30 0b       	mov	r11,0
8000cd2e:	50 2b       	stdsp	sp[0x8],r11
8000cd30:	c0 48       	rjmp	8000cd38 <_vfprintf_r+0x1678>
8000cd32:	40 22       	lddsp	r2,sp[0x8]
8000cd34:	30 0a       	mov	r10,0
8000cd36:	50 2a       	stdsp	sp[0x8],r10
8000cd38:	40 29       	lddsp	r9,sp[0x8]
8000cd3a:	e4 09 0c 49 	max	r9,r2,r9
8000cd3e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000cd42:	50 39       	stdsp	sp[0xc],r9
8000cd44:	0a 9e       	mov	lr,r5
8000cd46:	30 09       	mov	r9,0
8000cd48:	e2 1e 00 02 	andl	lr,0x2,COH
8000cd4c:	f2 08 18 00 	cp.b	r8,r9
8000cd50:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000cd54:	f7 b8 01 ff 	subne	r8,-1
8000cd58:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000cd5c:	0a 9b       	mov	r11,r5
8000cd5e:	58 0e       	cp.w	lr,0
8000cd60:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000cd64:	f7 bc 01 fe 	subne	r12,-2
8000cd68:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000cd6c:	e2 1b 00 84 	andl	r11,0x84,COH
8000cd70:	50 fe       	stdsp	sp[0x3c],lr
8000cd72:	50 9b       	stdsp	sp[0x24],r11
8000cd74:	c4 51       	brne	8000cdfe <_vfprintf_r+0x173e>
8000cd76:	40 8a       	lddsp	r10,sp[0x20]
8000cd78:	40 39       	lddsp	r9,sp[0xc]
8000cd7a:	12 1a       	sub	r10,r9
8000cd7c:	50 4a       	stdsp	sp[0x10],r10
8000cd7e:	58 0a       	cp.w	r10,0
8000cd80:	e0 89 00 1f 	brgt	8000cdbe <_vfprintf_r+0x16fe>
8000cd84:	c3 d8       	rjmp	8000cdfe <_vfprintf_r+0x173e>
8000cd86:	2f 09       	sub	r9,-16
8000cd88:	2f f8       	sub	r8,-1
8000cd8a:	4c ee       	lddpc	lr,8000cec0 <_vfprintf_r+0x1800>
8000cd8c:	31 0c       	mov	r12,16
8000cd8e:	fb 49 06 90 	st.w	sp[1680],r9
8000cd92:	87 0e       	st.w	r3[0x0],lr
8000cd94:	87 1c       	st.w	r3[0x4],r12
8000cd96:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd9a:	58 78       	cp.w	r8,7
8000cd9c:	e0 89 00 04 	brgt	8000cda4 <_vfprintf_r+0x16e4>
8000cda0:	2f 83       	sub	r3,-8
8000cda2:	c0 b8       	rjmp	8000cdb8 <_vfprintf_r+0x16f8>
8000cda4:	fa ca f9 78 	sub	r10,sp,-1672
8000cda8:	02 9b       	mov	r11,r1
8000cdaa:	08 9c       	mov	r12,r4
8000cdac:	fe b0 f4 7c 	rcall	8000b6a4 <__sprint_r>
8000cdb0:	e0 81 04 13 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000cdb4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cdb8:	40 4b       	lddsp	r11,sp[0x10]
8000cdba:	21 0b       	sub	r11,16
8000cdbc:	50 4b       	stdsp	sp[0x10],r11
8000cdbe:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cdc2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cdc6:	4b fa       	lddpc	r10,8000cec0 <_vfprintf_r+0x1800>
8000cdc8:	40 4e       	lddsp	lr,sp[0x10]
8000cdca:	59 0e       	cp.w	lr,16
8000cdcc:	fe 99 ff dd 	brgt	8000cd86 <_vfprintf_r+0x16c6>
8000cdd0:	1c 09       	add	r9,lr
8000cdd2:	2f f8       	sub	r8,-1
8000cdd4:	87 0a       	st.w	r3[0x0],r10
8000cdd6:	fb 49 06 90 	st.w	sp[1680],r9
8000cdda:	87 1e       	st.w	r3[0x4],lr
8000cddc:	fb 48 06 8c 	st.w	sp[1676],r8
8000cde0:	58 78       	cp.w	r8,7
8000cde2:	e0 89 00 04 	brgt	8000cdea <_vfprintf_r+0x172a>
8000cde6:	2f 83       	sub	r3,-8
8000cde8:	c0 b8       	rjmp	8000cdfe <_vfprintf_r+0x173e>
8000cdea:	fa ca f9 78 	sub	r10,sp,-1672
8000cdee:	02 9b       	mov	r11,r1
8000cdf0:	08 9c       	mov	r12,r4
8000cdf2:	fe b0 f4 59 	rcall	8000b6a4 <__sprint_r>
8000cdf6:	e0 81 03 f0 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000cdfa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cdfe:	30 09       	mov	r9,0
8000ce00:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000ce04:	f2 08 18 00 	cp.b	r8,r9
8000ce08:	c1 f0       	breq	8000ce46 <_vfprintf_r+0x1786>
8000ce0a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce0e:	fa c9 f9 45 	sub	r9,sp,-1723
8000ce12:	2f f8       	sub	r8,-1
8000ce14:	87 09       	st.w	r3[0x0],r9
8000ce16:	fb 48 06 90 	st.w	sp[1680],r8
8000ce1a:	30 19       	mov	r9,1
8000ce1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce20:	87 19       	st.w	r3[0x4],r9
8000ce22:	2f f8       	sub	r8,-1
8000ce24:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce28:	58 78       	cp.w	r8,7
8000ce2a:	e0 89 00 04 	brgt	8000ce32 <_vfprintf_r+0x1772>
8000ce2e:	2f 83       	sub	r3,-8
8000ce30:	c0 b8       	rjmp	8000ce46 <_vfprintf_r+0x1786>
8000ce32:	fa ca f9 78 	sub	r10,sp,-1672
8000ce36:	02 9b       	mov	r11,r1
8000ce38:	08 9c       	mov	r12,r4
8000ce3a:	fe b0 f4 35 	rcall	8000b6a4 <__sprint_r>
8000ce3e:	e0 81 03 cc 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000ce42:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce46:	40 fc       	lddsp	r12,sp[0x3c]
8000ce48:	58 0c       	cp.w	r12,0
8000ce4a:	c1 f0       	breq	8000ce88 <_vfprintf_r+0x17c8>
8000ce4c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce50:	fa c9 f9 48 	sub	r9,sp,-1720
8000ce54:	2f e8       	sub	r8,-2
8000ce56:	87 09       	st.w	r3[0x0],r9
8000ce58:	fb 48 06 90 	st.w	sp[1680],r8
8000ce5c:	30 29       	mov	r9,2
8000ce5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce62:	87 19       	st.w	r3[0x4],r9
8000ce64:	2f f8       	sub	r8,-1
8000ce66:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce6a:	58 78       	cp.w	r8,7
8000ce6c:	e0 89 00 04 	brgt	8000ce74 <_vfprintf_r+0x17b4>
8000ce70:	2f 83       	sub	r3,-8
8000ce72:	c0 b8       	rjmp	8000ce88 <_vfprintf_r+0x17c8>
8000ce74:	fa ca f9 78 	sub	r10,sp,-1672
8000ce78:	02 9b       	mov	r11,r1
8000ce7a:	08 9c       	mov	r12,r4
8000ce7c:	fe b0 f4 14 	rcall	8000b6a4 <__sprint_r>
8000ce80:	e0 81 03 ab 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000ce84:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce88:	40 9b       	lddsp	r11,sp[0x24]
8000ce8a:	e0 4b 00 80 	cp.w	r11,128
8000ce8e:	c4 a1       	brne	8000cf22 <_vfprintf_r+0x1862>
8000ce90:	40 8a       	lddsp	r10,sp[0x20]
8000ce92:	40 39       	lddsp	r9,sp[0xc]
8000ce94:	12 1a       	sub	r10,r9
8000ce96:	50 4a       	stdsp	sp[0x10],r10
8000ce98:	58 0a       	cp.w	r10,0
8000ce9a:	e0 89 00 24 	brgt	8000cee2 <_vfprintf_r+0x1822>
8000ce9e:	c4 28       	rjmp	8000cf22 <_vfprintf_r+0x1862>
8000cea0:	2f 09       	sub	r9,-16
8000cea2:	2f f8       	sub	r8,-1
8000cea4:	48 8e       	lddpc	lr,8000cec4 <_vfprintf_r+0x1804>
8000cea6:	31 0c       	mov	r12,16
8000cea8:	fb 49 06 90 	st.w	sp[1680],r9
8000ceac:	87 0e       	st.w	r3[0x0],lr
8000ceae:	87 1c       	st.w	r3[0x4],r12
8000ceb0:	fb 48 06 8c 	st.w	sp[1676],r8
8000ceb4:	58 78       	cp.w	r8,7
8000ceb6:	e0 89 00 09 	brgt	8000cec8 <_vfprintf_r+0x1808>
8000ceba:	2f 83       	sub	r3,-8
8000cebc:	c1 08       	rjmp	8000cedc <_vfprintf_r+0x181c>
8000cebe:	d7 03       	nop
8000cec0:	80 01       	ld.sh	r1,r0[0x0]
8000cec2:	9f 78       	st.w	pc[0x1c],r8
8000cec4:	80 01       	ld.sh	r1,r0[0x0]
8000cec6:	9f 88       	st.w	pc[0x20],r8
8000cec8:	fa ca f9 78 	sub	r10,sp,-1672
8000cecc:	02 9b       	mov	r11,r1
8000cece:	08 9c       	mov	r12,r4
8000ced0:	fe b0 f3 ea 	rcall	8000b6a4 <__sprint_r>
8000ced4:	e0 81 03 81 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000ced8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cedc:	40 4b       	lddsp	r11,sp[0x10]
8000cede:	21 0b       	sub	r11,16
8000cee0:	50 4b       	stdsp	sp[0x10],r11
8000cee2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cee6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ceea:	4c 6a       	lddpc	r10,8000d000 <_vfprintf_r+0x1940>
8000ceec:	40 4e       	lddsp	lr,sp[0x10]
8000ceee:	59 0e       	cp.w	lr,16
8000cef0:	fe 99 ff d8 	brgt	8000cea0 <_vfprintf_r+0x17e0>
8000cef4:	1c 09       	add	r9,lr
8000cef6:	2f f8       	sub	r8,-1
8000cef8:	87 0a       	st.w	r3[0x0],r10
8000cefa:	fb 49 06 90 	st.w	sp[1680],r9
8000cefe:	87 1e       	st.w	r3[0x4],lr
8000cf00:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf04:	58 78       	cp.w	r8,7
8000cf06:	e0 89 00 04 	brgt	8000cf0e <_vfprintf_r+0x184e>
8000cf0a:	2f 83       	sub	r3,-8
8000cf0c:	c0 b8       	rjmp	8000cf22 <_vfprintf_r+0x1862>
8000cf0e:	fa ca f9 78 	sub	r10,sp,-1672
8000cf12:	02 9b       	mov	r11,r1
8000cf14:	08 9c       	mov	r12,r4
8000cf16:	fe b0 f3 c7 	rcall	8000b6a4 <__sprint_r>
8000cf1a:	e0 81 03 5e 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000cf1e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf22:	40 2c       	lddsp	r12,sp[0x8]
8000cf24:	04 1c       	sub	r12,r2
8000cf26:	50 2c       	stdsp	sp[0x8],r12
8000cf28:	58 0c       	cp.w	r12,0
8000cf2a:	e0 89 00 1f 	brgt	8000cf68 <_vfprintf_r+0x18a8>
8000cf2e:	c3 d8       	rjmp	8000cfa8 <_vfprintf_r+0x18e8>
8000cf30:	2f 09       	sub	r9,-16
8000cf32:	2f f8       	sub	r8,-1
8000cf34:	4b 3b       	lddpc	r11,8000d000 <_vfprintf_r+0x1940>
8000cf36:	31 0a       	mov	r10,16
8000cf38:	fb 49 06 90 	st.w	sp[1680],r9
8000cf3c:	87 0b       	st.w	r3[0x0],r11
8000cf3e:	87 1a       	st.w	r3[0x4],r10
8000cf40:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf44:	58 78       	cp.w	r8,7
8000cf46:	e0 89 00 04 	brgt	8000cf4e <_vfprintf_r+0x188e>
8000cf4a:	2f 83       	sub	r3,-8
8000cf4c:	c0 b8       	rjmp	8000cf62 <_vfprintf_r+0x18a2>
8000cf4e:	fa ca f9 78 	sub	r10,sp,-1672
8000cf52:	02 9b       	mov	r11,r1
8000cf54:	08 9c       	mov	r12,r4
8000cf56:	fe b0 f3 a7 	rcall	8000b6a4 <__sprint_r>
8000cf5a:	e0 81 03 3e 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000cf5e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf62:	40 29       	lddsp	r9,sp[0x8]
8000cf64:	21 09       	sub	r9,16
8000cf66:	50 29       	stdsp	sp[0x8],r9
8000cf68:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cf6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf70:	4a 4a       	lddpc	r10,8000d000 <_vfprintf_r+0x1940>
8000cf72:	40 2e       	lddsp	lr,sp[0x8]
8000cf74:	59 0e       	cp.w	lr,16
8000cf76:	fe 99 ff dd 	brgt	8000cf30 <_vfprintf_r+0x1870>
8000cf7a:	1c 09       	add	r9,lr
8000cf7c:	2f f8       	sub	r8,-1
8000cf7e:	87 0a       	st.w	r3[0x0],r10
8000cf80:	fb 49 06 90 	st.w	sp[1680],r9
8000cf84:	87 1e       	st.w	r3[0x4],lr
8000cf86:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf8a:	58 78       	cp.w	r8,7
8000cf8c:	e0 89 00 04 	brgt	8000cf94 <_vfprintf_r+0x18d4>
8000cf90:	2f 83       	sub	r3,-8
8000cf92:	c0 b8       	rjmp	8000cfa8 <_vfprintf_r+0x18e8>
8000cf94:	fa ca f9 78 	sub	r10,sp,-1672
8000cf98:	02 9b       	mov	r11,r1
8000cf9a:	08 9c       	mov	r12,r4
8000cf9c:	fe b0 f3 84 	rcall	8000b6a4 <__sprint_r>
8000cfa0:	e0 81 03 1b 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000cfa4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cfa8:	ed b5 00 08 	bld	r5,0x8
8000cfac:	c0 b0       	breq	8000cfc2 <_vfprintf_r+0x1902>
8000cfae:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cfb2:	87 12       	st.w	r3[0x4],r2
8000cfb4:	87 06       	st.w	r3[0x0],r6
8000cfb6:	f0 02 00 02 	add	r2,r8,r2
8000cfba:	fb 42 06 90 	st.w	sp[1680],r2
8000cfbe:	e0 8f 01 d5 	bral	8000d368 <_vfprintf_r+0x1ca8>
8000cfc2:	e0 40 00 65 	cp.w	r0,101
8000cfc6:	e0 8a 01 d7 	brle	8000d374 <_vfprintf_r+0x1cb4>
8000cfca:	30 08       	mov	r8,0
8000cfcc:	30 09       	mov	r9,0
8000cfce:	40 5b       	lddsp	r11,sp[0x14]
8000cfd0:	40 7a       	lddsp	r10,sp[0x1c]
8000cfd2:	e0 a0 15 3e 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000cfd6:	c7 a0       	breq	8000d0ca <_vfprintf_r+0x1a0a>
8000cfd8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cfdc:	48 a9       	lddpc	r9,8000d004 <_vfprintf_r+0x1944>
8000cfde:	2f f8       	sub	r8,-1
8000cfe0:	87 09       	st.w	r3[0x0],r9
8000cfe2:	fb 48 06 90 	st.w	sp[1680],r8
8000cfe6:	30 19       	mov	r9,1
8000cfe8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cfec:	87 19       	st.w	r3[0x4],r9
8000cfee:	2f f8       	sub	r8,-1
8000cff0:	fb 48 06 8c 	st.w	sp[1676],r8
8000cff4:	58 78       	cp.w	r8,7
8000cff6:	e0 89 00 09 	brgt	8000d008 <_vfprintf_r+0x1948>
8000cffa:	2f 83       	sub	r3,-8
8000cffc:	c1 08       	rjmp	8000d01c <_vfprintf_r+0x195c>
8000cffe:	d7 03       	nop
8000d000:	80 01       	ld.sh	r1,r0[0x0]
8000d002:	9f 88       	st.w	pc[0x20],r8
8000d004:	80 01       	ld.sh	r1,r0[0x0]
8000d006:	9f 74       	st.w	pc[0x1c],r4
8000d008:	fa ca f9 78 	sub	r10,sp,-1672
8000d00c:	02 9b       	mov	r11,r1
8000d00e:	08 9c       	mov	r12,r4
8000d010:	fe b0 f3 4a 	rcall	8000b6a4 <__sprint_r>
8000d014:	e0 81 02 e1 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d018:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d01c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d020:	40 6c       	lddsp	r12,sp[0x18]
8000d022:	18 38       	cp.w	r8,r12
8000d024:	c0 55       	brlt	8000d02e <_vfprintf_r+0x196e>
8000d026:	ed b5 00 00 	bld	r5,0x0
8000d02a:	e0 81 02 69 	brne	8000d4fc <_vfprintf_r+0x1e3c>
8000d02e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d032:	2f f8       	sub	r8,-1
8000d034:	40 cb       	lddsp	r11,sp[0x30]
8000d036:	fb 48 06 90 	st.w	sp[1680],r8
8000d03a:	30 19       	mov	r9,1
8000d03c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d040:	87 0b       	st.w	r3[0x0],r11
8000d042:	2f f8       	sub	r8,-1
8000d044:	87 19       	st.w	r3[0x4],r9
8000d046:	fb 48 06 8c 	st.w	sp[1676],r8
8000d04a:	58 78       	cp.w	r8,7
8000d04c:	e0 89 00 04 	brgt	8000d054 <_vfprintf_r+0x1994>
8000d050:	2f 83       	sub	r3,-8
8000d052:	c0 b8       	rjmp	8000d068 <_vfprintf_r+0x19a8>
8000d054:	fa ca f9 78 	sub	r10,sp,-1672
8000d058:	02 9b       	mov	r11,r1
8000d05a:	08 9c       	mov	r12,r4
8000d05c:	fe b0 f3 24 	rcall	8000b6a4 <__sprint_r>
8000d060:	e0 81 02 bb 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d064:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d068:	40 66       	lddsp	r6,sp[0x18]
8000d06a:	20 16       	sub	r6,1
8000d06c:	58 06       	cp.w	r6,0
8000d06e:	e0 89 00 1d 	brgt	8000d0a8 <_vfprintf_r+0x19e8>
8000d072:	e0 8f 02 45 	bral	8000d4fc <_vfprintf_r+0x1e3c>
8000d076:	2f 09       	sub	r9,-16
8000d078:	2f f8       	sub	r8,-1
8000d07a:	fb 49 06 90 	st.w	sp[1680],r9
8000d07e:	87 02       	st.w	r3[0x0],r2
8000d080:	87 10       	st.w	r3[0x4],r0
8000d082:	fb 48 06 8c 	st.w	sp[1676],r8
8000d086:	58 78       	cp.w	r8,7
8000d088:	e0 89 00 04 	brgt	8000d090 <_vfprintf_r+0x19d0>
8000d08c:	2f 83       	sub	r3,-8
8000d08e:	c0 b8       	rjmp	8000d0a4 <_vfprintf_r+0x19e4>
8000d090:	fa ca f9 78 	sub	r10,sp,-1672
8000d094:	02 9b       	mov	r11,r1
8000d096:	08 9c       	mov	r12,r4
8000d098:	fe b0 f3 06 	rcall	8000b6a4 <__sprint_r>
8000d09c:	e0 81 02 9d 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d0a0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0a4:	21 06       	sub	r6,16
8000d0a6:	c0 38       	rjmp	8000d0ac <_vfprintf_r+0x19ec>
8000d0a8:	4d 22       	lddpc	r2,8000d1f0 <_vfprintf_r+0x1b30>
8000d0aa:	31 00       	mov	r0,16
8000d0ac:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d0b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0b4:	4c fa       	lddpc	r10,8000d1f0 <_vfprintf_r+0x1b30>
8000d0b6:	59 06       	cp.w	r6,16
8000d0b8:	fe 99 ff df 	brgt	8000d076 <_vfprintf_r+0x19b6>
8000d0bc:	0c 09       	add	r9,r6
8000d0be:	87 0a       	st.w	r3[0x0],r10
8000d0c0:	fb 49 06 90 	st.w	sp[1680],r9
8000d0c4:	2f f8       	sub	r8,-1
8000d0c6:	87 16       	st.w	r3[0x4],r6
8000d0c8:	c5 39       	rjmp	8000d36e <_vfprintf_r+0x1cae>
8000d0ca:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000d0ce:	58 0a       	cp.w	r10,0
8000d0d0:	e0 89 00 94 	brgt	8000d1f8 <_vfprintf_r+0x1b38>
8000d0d4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d0d8:	4c 79       	lddpc	r9,8000d1f4 <_vfprintf_r+0x1b34>
8000d0da:	2f f8       	sub	r8,-1
8000d0dc:	87 09       	st.w	r3[0x0],r9
8000d0de:	fb 48 06 90 	st.w	sp[1680],r8
8000d0e2:	30 19       	mov	r9,1
8000d0e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0e8:	87 19       	st.w	r3[0x4],r9
8000d0ea:	2f f8       	sub	r8,-1
8000d0ec:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0f0:	58 78       	cp.w	r8,7
8000d0f2:	e0 89 00 04 	brgt	8000d0fa <_vfprintf_r+0x1a3a>
8000d0f6:	2f 83       	sub	r3,-8
8000d0f8:	c0 b8       	rjmp	8000d10e <_vfprintf_r+0x1a4e>
8000d0fa:	fa ca f9 78 	sub	r10,sp,-1672
8000d0fe:	02 9b       	mov	r11,r1
8000d100:	08 9c       	mov	r12,r4
8000d102:	fe b0 f2 d1 	rcall	8000b6a4 <__sprint_r>
8000d106:	e0 81 02 68 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d10a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d10e:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d112:	58 08       	cp.w	r8,0
8000d114:	c0 81       	brne	8000d124 <_vfprintf_r+0x1a64>
8000d116:	40 6a       	lddsp	r10,sp[0x18]
8000d118:	58 0a       	cp.w	r10,0
8000d11a:	c0 51       	brne	8000d124 <_vfprintf_r+0x1a64>
8000d11c:	ed b5 00 00 	bld	r5,0x0
8000d120:	e0 81 01 ee 	brne	8000d4fc <_vfprintf_r+0x1e3c>
8000d124:	40 c9       	lddsp	r9,sp[0x30]
8000d126:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d12a:	2f f8       	sub	r8,-1
8000d12c:	87 09       	st.w	r3[0x0],r9
8000d12e:	fb 48 06 90 	st.w	sp[1680],r8
8000d132:	30 19       	mov	r9,1
8000d134:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d138:	87 19       	st.w	r3[0x4],r9
8000d13a:	2f f8       	sub	r8,-1
8000d13c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d140:	58 78       	cp.w	r8,7
8000d142:	e0 89 00 04 	brgt	8000d14a <_vfprintf_r+0x1a8a>
8000d146:	2f 83       	sub	r3,-8
8000d148:	c0 b8       	rjmp	8000d15e <_vfprintf_r+0x1a9e>
8000d14a:	fa ca f9 78 	sub	r10,sp,-1672
8000d14e:	02 9b       	mov	r11,r1
8000d150:	08 9c       	mov	r12,r4
8000d152:	fe b0 f2 a9 	rcall	8000b6a4 <__sprint_r>
8000d156:	e0 81 02 40 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d15a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d15e:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000d162:	5c 32       	neg	r2
8000d164:	58 02       	cp.w	r2,0
8000d166:	e0 89 00 1d 	brgt	8000d1a0 <_vfprintf_r+0x1ae0>
8000d16a:	c3 b8       	rjmp	8000d1e0 <_vfprintf_r+0x1b20>
8000d16c:	2f 09       	sub	r9,-16
8000d16e:	2f f8       	sub	r8,-1
8000d170:	31 0e       	mov	lr,16
8000d172:	fb 49 06 90 	st.w	sp[1680],r9
8000d176:	87 00       	st.w	r3[0x0],r0
8000d178:	87 1e       	st.w	r3[0x4],lr
8000d17a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d17e:	58 78       	cp.w	r8,7
8000d180:	e0 89 00 04 	brgt	8000d188 <_vfprintf_r+0x1ac8>
8000d184:	2f 83       	sub	r3,-8
8000d186:	c0 b8       	rjmp	8000d19c <_vfprintf_r+0x1adc>
8000d188:	fa ca f9 78 	sub	r10,sp,-1672
8000d18c:	02 9b       	mov	r11,r1
8000d18e:	08 9c       	mov	r12,r4
8000d190:	fe b0 f2 8a 	rcall	8000b6a4 <__sprint_r>
8000d194:	e0 81 02 21 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d198:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d19c:	21 02       	sub	r2,16
8000d19e:	c0 28       	rjmp	8000d1a2 <_vfprintf_r+0x1ae2>
8000d1a0:	49 40       	lddpc	r0,8000d1f0 <_vfprintf_r+0x1b30>
8000d1a2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d1a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d1aa:	49 2a       	lddpc	r10,8000d1f0 <_vfprintf_r+0x1b30>
8000d1ac:	59 02       	cp.w	r2,16
8000d1ae:	fe 99 ff df 	brgt	8000d16c <_vfprintf_r+0x1aac>
8000d1b2:	04 09       	add	r9,r2
8000d1b4:	2f f8       	sub	r8,-1
8000d1b6:	87 0a       	st.w	r3[0x0],r10
8000d1b8:	fb 49 06 90 	st.w	sp[1680],r9
8000d1bc:	87 12       	st.w	r3[0x4],r2
8000d1be:	fb 48 06 8c 	st.w	sp[1676],r8
8000d1c2:	58 78       	cp.w	r8,7
8000d1c4:	e0 89 00 04 	brgt	8000d1cc <_vfprintf_r+0x1b0c>
8000d1c8:	2f 83       	sub	r3,-8
8000d1ca:	c0 b8       	rjmp	8000d1e0 <_vfprintf_r+0x1b20>
8000d1cc:	fa ca f9 78 	sub	r10,sp,-1672
8000d1d0:	02 9b       	mov	r11,r1
8000d1d2:	08 9c       	mov	r12,r4
8000d1d4:	fe b0 f2 68 	rcall	8000b6a4 <__sprint_r>
8000d1d8:	e0 81 01 ff 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d1dc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d1e0:	40 6c       	lddsp	r12,sp[0x18]
8000d1e2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d1e6:	87 06       	st.w	r3[0x0],r6
8000d1e8:	87 1c       	st.w	r3[0x4],r12
8000d1ea:	18 08       	add	r8,r12
8000d1ec:	cb c8       	rjmp	8000d364 <_vfprintf_r+0x1ca4>
8000d1ee:	d7 03       	nop
8000d1f0:	80 01       	ld.sh	r1,r0[0x0]
8000d1f2:	9f 88       	st.w	pc[0x20],r8
8000d1f4:	80 01       	ld.sh	r1,r0[0x0]
8000d1f6:	9f 74       	st.w	pc[0x1c],r4
8000d1f8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d1fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d200:	40 6b       	lddsp	r11,sp[0x18]
8000d202:	16 3a       	cp.w	r10,r11
8000d204:	c6 d5       	brlt	8000d2de <_vfprintf_r+0x1c1e>
8000d206:	16 09       	add	r9,r11
8000d208:	2f f8       	sub	r8,-1
8000d20a:	87 06       	st.w	r3[0x0],r6
8000d20c:	fb 49 06 90 	st.w	sp[1680],r9
8000d210:	87 1b       	st.w	r3[0x4],r11
8000d212:	fb 48 06 8c 	st.w	sp[1676],r8
8000d216:	58 78       	cp.w	r8,7
8000d218:	e0 89 00 04 	brgt	8000d220 <_vfprintf_r+0x1b60>
8000d21c:	2f 83       	sub	r3,-8
8000d21e:	c0 b8       	rjmp	8000d234 <_vfprintf_r+0x1b74>
8000d220:	fa ca f9 78 	sub	r10,sp,-1672
8000d224:	02 9b       	mov	r11,r1
8000d226:	08 9c       	mov	r12,r4
8000d228:	fe b0 f2 3e 	rcall	8000b6a4 <__sprint_r>
8000d22c:	e0 81 01 d5 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d230:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d234:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000d238:	40 6a       	lddsp	r10,sp[0x18]
8000d23a:	14 16       	sub	r6,r10
8000d23c:	58 06       	cp.w	r6,0
8000d23e:	e0 89 00 1c 	brgt	8000d276 <_vfprintf_r+0x1bb6>
8000d242:	c3 b8       	rjmp	8000d2b8 <_vfprintf_r+0x1bf8>
8000d244:	2f 09       	sub	r9,-16
8000d246:	2f f8       	sub	r8,-1
8000d248:	fb 49 06 90 	st.w	sp[1680],r9
8000d24c:	87 02       	st.w	r3[0x0],r2
8000d24e:	87 10       	st.w	r3[0x4],r0
8000d250:	fb 48 06 8c 	st.w	sp[1676],r8
8000d254:	58 78       	cp.w	r8,7
8000d256:	e0 89 00 04 	brgt	8000d25e <_vfprintf_r+0x1b9e>
8000d25a:	2f 83       	sub	r3,-8
8000d25c:	c0 b8       	rjmp	8000d272 <_vfprintf_r+0x1bb2>
8000d25e:	fa ca f9 78 	sub	r10,sp,-1672
8000d262:	02 9b       	mov	r11,r1
8000d264:	08 9c       	mov	r12,r4
8000d266:	fe b0 f2 1f 	rcall	8000b6a4 <__sprint_r>
8000d26a:	e0 81 01 b6 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d26e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d272:	21 06       	sub	r6,16
8000d274:	c0 38       	rjmp	8000d27a <_vfprintf_r+0x1bba>
8000d276:	4d c2       	lddpc	r2,8000d3e4 <_vfprintf_r+0x1d24>
8000d278:	31 00       	mov	r0,16
8000d27a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d27e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d282:	4d 9a       	lddpc	r10,8000d3e4 <_vfprintf_r+0x1d24>
8000d284:	59 06       	cp.w	r6,16
8000d286:	fe 99 ff df 	brgt	8000d244 <_vfprintf_r+0x1b84>
8000d28a:	0c 09       	add	r9,r6
8000d28c:	2f f8       	sub	r8,-1
8000d28e:	87 0a       	st.w	r3[0x0],r10
8000d290:	fb 49 06 90 	st.w	sp[1680],r9
8000d294:	87 16       	st.w	r3[0x4],r6
8000d296:	fb 48 06 8c 	st.w	sp[1676],r8
8000d29a:	58 78       	cp.w	r8,7
8000d29c:	e0 89 00 04 	brgt	8000d2a4 <_vfprintf_r+0x1be4>
8000d2a0:	2f 83       	sub	r3,-8
8000d2a2:	c0 b8       	rjmp	8000d2b8 <_vfprintf_r+0x1bf8>
8000d2a4:	fa ca f9 78 	sub	r10,sp,-1672
8000d2a8:	02 9b       	mov	r11,r1
8000d2aa:	08 9c       	mov	r12,r4
8000d2ac:	fe b0 f1 fc 	rcall	8000b6a4 <__sprint_r>
8000d2b0:	e0 81 01 93 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d2b4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d2b8:	ed b5 00 00 	bld	r5,0x0
8000d2bc:	e0 81 01 20 	brne	8000d4fc <_vfprintf_r+0x1e3c>
8000d2c0:	40 c9       	lddsp	r9,sp[0x30]
8000d2c2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d2c6:	2f f8       	sub	r8,-1
8000d2c8:	87 09       	st.w	r3[0x0],r9
8000d2ca:	fb 48 06 90 	st.w	sp[1680],r8
8000d2ce:	30 19       	mov	r9,1
8000d2d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d2d4:	87 19       	st.w	r3[0x4],r9
8000d2d6:	2f f8       	sub	r8,-1
8000d2d8:	fb 48 06 8c 	st.w	sp[1676],r8
8000d2dc:	c0 29       	rjmp	8000d4e0 <_vfprintf_r+0x1e20>
8000d2de:	14 09       	add	r9,r10
8000d2e0:	2f f8       	sub	r8,-1
8000d2e2:	fb 49 06 90 	st.w	sp[1680],r9
8000d2e6:	87 06       	st.w	r3[0x0],r6
8000d2e8:	87 1a       	st.w	r3[0x4],r10
8000d2ea:	fb 48 06 8c 	st.w	sp[1676],r8
8000d2ee:	58 78       	cp.w	r8,7
8000d2f0:	e0 89 00 04 	brgt	8000d2f8 <_vfprintf_r+0x1c38>
8000d2f4:	2f 83       	sub	r3,-8
8000d2f6:	c0 b8       	rjmp	8000d30c <_vfprintf_r+0x1c4c>
8000d2f8:	fa ca f9 78 	sub	r10,sp,-1672
8000d2fc:	02 9b       	mov	r11,r1
8000d2fe:	08 9c       	mov	r12,r4
8000d300:	fe b0 f1 d2 	rcall	8000b6a4 <__sprint_r>
8000d304:	e0 81 01 69 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d308:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d30c:	40 c8       	lddsp	r8,sp[0x30]
8000d30e:	87 08       	st.w	r3[0x0],r8
8000d310:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d314:	2f f8       	sub	r8,-1
8000d316:	30 19       	mov	r9,1
8000d318:	fb 48 06 90 	st.w	sp[1680],r8
8000d31c:	87 19       	st.w	r3[0x4],r9
8000d31e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d322:	2f f8       	sub	r8,-1
8000d324:	fb 48 06 8c 	st.w	sp[1676],r8
8000d328:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000d32c:	58 78       	cp.w	r8,7
8000d32e:	e0 89 00 04 	brgt	8000d336 <_vfprintf_r+0x1c76>
8000d332:	2f 83       	sub	r3,-8
8000d334:	c0 b8       	rjmp	8000d34a <_vfprintf_r+0x1c8a>
8000d336:	fa ca f9 78 	sub	r10,sp,-1672
8000d33a:	02 9b       	mov	r11,r1
8000d33c:	08 9c       	mov	r12,r4
8000d33e:	fe b0 f1 b3 	rcall	8000b6a4 <__sprint_r>
8000d342:	e0 81 01 4a 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d346:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d34a:	04 06       	add	r6,r2
8000d34c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d350:	87 06       	st.w	r3[0x0],r6
8000d352:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d356:	40 66       	lddsp	r6,sp[0x18]
8000d358:	40 6e       	lddsp	lr,sp[0x18]
8000d35a:	10 16       	sub	r6,r8
8000d35c:	f2 08 01 08 	sub	r8,r9,r8
8000d360:	87 16       	st.w	r3[0x4],r6
8000d362:	1c 08       	add	r8,lr
8000d364:	fb 48 06 90 	st.w	sp[1680],r8
8000d368:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d36c:	2f f8       	sub	r8,-1
8000d36e:	fb 48 06 8c 	st.w	sp[1676],r8
8000d372:	cb 78       	rjmp	8000d4e0 <_vfprintf_r+0x1e20>
8000d374:	40 6c       	lddsp	r12,sp[0x18]
8000d376:	58 1c       	cp.w	r12,1
8000d378:	e0 89 00 06 	brgt	8000d384 <_vfprintf_r+0x1cc4>
8000d37c:	ed b5 00 00 	bld	r5,0x0
8000d380:	e0 81 00 85 	brne	8000d48a <_vfprintf_r+0x1dca>
8000d384:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d388:	2f f8       	sub	r8,-1
8000d38a:	30 19       	mov	r9,1
8000d38c:	fb 48 06 90 	st.w	sp[1680],r8
8000d390:	87 06       	st.w	r3[0x0],r6
8000d392:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d396:	87 19       	st.w	r3[0x4],r9
8000d398:	2f f8       	sub	r8,-1
8000d39a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d39e:	58 78       	cp.w	r8,7
8000d3a0:	e0 89 00 04 	brgt	8000d3a8 <_vfprintf_r+0x1ce8>
8000d3a4:	2f 83       	sub	r3,-8
8000d3a6:	c0 b8       	rjmp	8000d3bc <_vfprintf_r+0x1cfc>
8000d3a8:	fa ca f9 78 	sub	r10,sp,-1672
8000d3ac:	02 9b       	mov	r11,r1
8000d3ae:	08 9c       	mov	r12,r4
8000d3b0:	fe b0 f1 7a 	rcall	8000b6a4 <__sprint_r>
8000d3b4:	e0 81 01 11 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d3b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d3bc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d3c0:	2f f8       	sub	r8,-1
8000d3c2:	40 cb       	lddsp	r11,sp[0x30]
8000d3c4:	fb 48 06 90 	st.w	sp[1680],r8
8000d3c8:	30 19       	mov	r9,1
8000d3ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d3ce:	87 0b       	st.w	r3[0x0],r11
8000d3d0:	2f f8       	sub	r8,-1
8000d3d2:	87 19       	st.w	r3[0x4],r9
8000d3d4:	fb 48 06 8c 	st.w	sp[1676],r8
8000d3d8:	58 78       	cp.w	r8,7
8000d3da:	e0 89 00 07 	brgt	8000d3e8 <_vfprintf_r+0x1d28>
8000d3de:	2f 83       	sub	r3,-8
8000d3e0:	c0 e8       	rjmp	8000d3fc <_vfprintf_r+0x1d3c>
8000d3e2:	d7 03       	nop
8000d3e4:	80 01       	ld.sh	r1,r0[0x0]
8000d3e6:	9f 88       	st.w	pc[0x20],r8
8000d3e8:	fa ca f9 78 	sub	r10,sp,-1672
8000d3ec:	02 9b       	mov	r11,r1
8000d3ee:	08 9c       	mov	r12,r4
8000d3f0:	fe b0 f1 5a 	rcall	8000b6a4 <__sprint_r>
8000d3f4:	e0 81 00 f1 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d3f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d3fc:	30 08       	mov	r8,0
8000d3fe:	30 09       	mov	r9,0
8000d400:	40 5b       	lddsp	r11,sp[0x14]
8000d402:	40 7a       	lddsp	r10,sp[0x1c]
8000d404:	e0 a0 13 25 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000d408:	40 68       	lddsp	r8,sp[0x18]
8000d40a:	20 18       	sub	r8,1
8000d40c:	58 0c       	cp.w	r12,0
8000d40e:	c0 d1       	brne	8000d428 <_vfprintf_r+0x1d68>
8000d410:	2f f6       	sub	r6,-1
8000d412:	87 18       	st.w	r3[0x4],r8
8000d414:	87 06       	st.w	r3[0x0],r6
8000d416:	fa f6 06 90 	ld.w	r6,sp[1680]
8000d41a:	10 06       	add	r6,r8
8000d41c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d420:	fb 46 06 90 	st.w	sp[1680],r6
8000d424:	2f f8       	sub	r8,-1
8000d426:	c2 f8       	rjmp	8000d484 <_vfprintf_r+0x1dc4>
8000d428:	10 96       	mov	r6,r8
8000d42a:	58 08       	cp.w	r8,0
8000d42c:	e0 89 00 1c 	brgt	8000d464 <_vfprintf_r+0x1da4>
8000d430:	c4 98       	rjmp	8000d4c2 <_vfprintf_r+0x1e02>
8000d432:	2f 09       	sub	r9,-16
8000d434:	2f f8       	sub	r8,-1
8000d436:	fb 49 06 90 	st.w	sp[1680],r9
8000d43a:	87 02       	st.w	r3[0x0],r2
8000d43c:	87 10       	st.w	r3[0x4],r0
8000d43e:	fb 48 06 8c 	st.w	sp[1676],r8
8000d442:	58 78       	cp.w	r8,7
8000d444:	e0 89 00 04 	brgt	8000d44c <_vfprintf_r+0x1d8c>
8000d448:	2f 83       	sub	r3,-8
8000d44a:	c0 b8       	rjmp	8000d460 <_vfprintf_r+0x1da0>
8000d44c:	fa ca f9 78 	sub	r10,sp,-1672
8000d450:	02 9b       	mov	r11,r1
8000d452:	08 9c       	mov	r12,r4
8000d454:	fe b0 f1 28 	rcall	8000b6a4 <__sprint_r>
8000d458:	e0 81 00 bf 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d45c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d460:	21 06       	sub	r6,16
8000d462:	c0 38       	rjmp	8000d468 <_vfprintf_r+0x1da8>
8000d464:	4d 22       	lddpc	r2,8000d5ac <_vfprintf_r+0x1eec>
8000d466:	31 00       	mov	r0,16
8000d468:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d46c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d470:	4c fa       	lddpc	r10,8000d5ac <_vfprintf_r+0x1eec>
8000d472:	59 06       	cp.w	r6,16
8000d474:	fe 99 ff df 	brgt	8000d432 <_vfprintf_r+0x1d72>
8000d478:	0c 09       	add	r9,r6
8000d47a:	87 0a       	st.w	r3[0x0],r10
8000d47c:	fb 49 06 90 	st.w	sp[1680],r9
8000d480:	2f f8       	sub	r8,-1
8000d482:	87 16       	st.w	r3[0x4],r6
8000d484:	fb 48 06 8c 	st.w	sp[1676],r8
8000d488:	c0 e8       	rjmp	8000d4a4 <_vfprintf_r+0x1de4>
8000d48a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d48e:	2f f8       	sub	r8,-1
8000d490:	30 19       	mov	r9,1
8000d492:	fb 48 06 90 	st.w	sp[1680],r8
8000d496:	87 06       	st.w	r3[0x0],r6
8000d498:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d49c:	87 19       	st.w	r3[0x4],r9
8000d49e:	2f f8       	sub	r8,-1
8000d4a0:	fb 48 06 8c 	st.w	sp[1676],r8
8000d4a4:	58 78       	cp.w	r8,7
8000d4a6:	e0 89 00 04 	brgt	8000d4ae <_vfprintf_r+0x1dee>
8000d4aa:	2f 83       	sub	r3,-8
8000d4ac:	c0 b8       	rjmp	8000d4c2 <_vfprintf_r+0x1e02>
8000d4ae:	fa ca f9 78 	sub	r10,sp,-1672
8000d4b2:	02 9b       	mov	r11,r1
8000d4b4:	08 9c       	mov	r12,r4
8000d4b6:	fe b0 f0 f7 	rcall	8000b6a4 <__sprint_r>
8000d4ba:	e0 81 00 8e 	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d4be:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d4c2:	40 ea       	lddsp	r10,sp[0x38]
8000d4c4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d4c8:	14 08       	add	r8,r10
8000d4ca:	fa c9 f9 64 	sub	r9,sp,-1692
8000d4ce:	fb 48 06 90 	st.w	sp[1680],r8
8000d4d2:	87 1a       	st.w	r3[0x4],r10
8000d4d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d4d8:	87 09       	st.w	r3[0x0],r9
8000d4da:	2f f8       	sub	r8,-1
8000d4dc:	fb 48 06 8c 	st.w	sp[1676],r8
8000d4e0:	58 78       	cp.w	r8,7
8000d4e2:	e0 89 00 04 	brgt	8000d4ea <_vfprintf_r+0x1e2a>
8000d4e6:	2f 83       	sub	r3,-8
8000d4e8:	c0 a8       	rjmp	8000d4fc <_vfprintf_r+0x1e3c>
8000d4ea:	fa ca f9 78 	sub	r10,sp,-1672
8000d4ee:	02 9b       	mov	r11,r1
8000d4f0:	08 9c       	mov	r12,r4
8000d4f2:	fe b0 f0 d9 	rcall	8000b6a4 <__sprint_r>
8000d4f6:	c7 01       	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d4f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d4fc:	e2 15 00 04 	andl	r5,0x4,COH
8000d500:	c3 d0       	breq	8000d57a <_vfprintf_r+0x1eba>
8000d502:	40 86       	lddsp	r6,sp[0x20]
8000d504:	40 39       	lddsp	r9,sp[0xc]
8000d506:	12 16       	sub	r6,r9
8000d508:	58 06       	cp.w	r6,0
8000d50a:	e0 89 00 1a 	brgt	8000d53e <_vfprintf_r+0x1e7e>
8000d50e:	c3 68       	rjmp	8000d57a <_vfprintf_r+0x1eba>
8000d510:	2f 09       	sub	r9,-16
8000d512:	2f f8       	sub	r8,-1
8000d514:	fb 49 06 90 	st.w	sp[1680],r9
8000d518:	87 05       	st.w	r3[0x0],r5
8000d51a:	87 12       	st.w	r3[0x4],r2
8000d51c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d520:	58 78       	cp.w	r8,7
8000d522:	e0 89 00 04 	brgt	8000d52a <_vfprintf_r+0x1e6a>
8000d526:	2f 83       	sub	r3,-8
8000d528:	c0 98       	rjmp	8000d53a <_vfprintf_r+0x1e7a>
8000d52a:	00 9a       	mov	r10,r0
8000d52c:	02 9b       	mov	r11,r1
8000d52e:	08 9c       	mov	r12,r4
8000d530:	fe b0 f0 ba 	rcall	8000b6a4 <__sprint_r>
8000d534:	c5 11       	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d536:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d53a:	21 06       	sub	r6,16
8000d53c:	c0 58       	rjmp	8000d546 <_vfprintf_r+0x1e86>
8000d53e:	49 d5       	lddpc	r5,8000d5b0 <_vfprintf_r+0x1ef0>
8000d540:	31 02       	mov	r2,16
8000d542:	fa c0 f9 78 	sub	r0,sp,-1672
8000d546:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d54a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d54e:	49 9a       	lddpc	r10,8000d5b0 <_vfprintf_r+0x1ef0>
8000d550:	59 06       	cp.w	r6,16
8000d552:	fe 99 ff df 	brgt	8000d510 <_vfprintf_r+0x1e50>
8000d556:	0c 09       	add	r9,r6
8000d558:	2f f8       	sub	r8,-1
8000d55a:	87 0a       	st.w	r3[0x0],r10
8000d55c:	87 16       	st.w	r3[0x4],r6
8000d55e:	fb 49 06 90 	st.w	sp[1680],r9
8000d562:	fb 48 06 8c 	st.w	sp[1676],r8
8000d566:	58 78       	cp.w	r8,7
8000d568:	e0 8a 00 09 	brle	8000d57a <_vfprintf_r+0x1eba>
8000d56c:	fa ca f9 78 	sub	r10,sp,-1672
8000d570:	02 9b       	mov	r11,r1
8000d572:	08 9c       	mov	r12,r4
8000d574:	fe b0 f0 98 	rcall	8000b6a4 <__sprint_r>
8000d578:	c2 f1       	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d57a:	40 bc       	lddsp	r12,sp[0x2c]
8000d57c:	40 36       	lddsp	r6,sp[0xc]
8000d57e:	40 8e       	lddsp	lr,sp[0x20]
8000d580:	ec 0e 0c 48 	max	r8,r6,lr
8000d584:	10 0c       	add	r12,r8
8000d586:	50 bc       	stdsp	sp[0x2c],r12
8000d588:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d58c:	58 08       	cp.w	r8,0
8000d58e:	c0 80       	breq	8000d59e <_vfprintf_r+0x1ede>
8000d590:	fa ca f9 78 	sub	r10,sp,-1672
8000d594:	02 9b       	mov	r11,r1
8000d596:	08 9c       	mov	r12,r4
8000d598:	fe b0 f0 86 	rcall	8000b6a4 <__sprint_r>
8000d59c:	c1 d1       	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d59e:	30 0b       	mov	r11,0
8000d5a0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d5a4:	fb 4b 06 8c 	st.w	sp[1676],r11
8000d5a8:	fe 9f f1 17 	bral	8000b7d6 <_vfprintf_r+0x116>
8000d5ac:	80 01       	ld.sh	r1,r0[0x0]
8000d5ae:	9f 88       	st.w	pc[0x20],r8
8000d5b0:	80 01       	ld.sh	r1,r0[0x0]
8000d5b2:	9f 78       	st.w	pc[0x1c],r8
8000d5b4:	08 95       	mov	r5,r4
8000d5b6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d5ba:	58 08       	cp.w	r8,0
8000d5bc:	c0 80       	breq	8000d5cc <_vfprintf_r+0x1f0c>
8000d5be:	08 9c       	mov	r12,r4
8000d5c0:	fa ca f9 78 	sub	r10,sp,-1672
8000d5c4:	02 9b       	mov	r11,r1
8000d5c6:	fe b0 f0 6f 	rcall	8000b6a4 <__sprint_r>
8000d5ca:	c0 61       	brne	8000d5d6 <_vfprintf_r+0x1f16>
8000d5cc:	30 08       	mov	r8,0
8000d5ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000d5d2:	c0 28       	rjmp	8000d5d6 <_vfprintf_r+0x1f16>
8000d5d4:	40 41       	lddsp	r1,sp[0x10]
8000d5d6:	82 68       	ld.sh	r8,r1[0xc]
8000d5d8:	ed b8 00 06 	bld	r8,0x6
8000d5dc:	c0 31       	brne	8000d5e2 <_vfprintf_r+0x1f22>
8000d5de:	3f fa       	mov	r10,-1
8000d5e0:	50 ba       	stdsp	sp[0x2c],r10
8000d5e2:	40 bc       	lddsp	r12,sp[0x2c]
8000d5e4:	fe 3d f9 44 	sub	sp,-1724
8000d5e8:	d8 32       	popm	r0-r7,pc
8000d5ea:	d7 03       	nop

8000d5ec <__swsetup_r>:
8000d5ec:	d4 21       	pushm	r4-r7,lr
8000d5ee:	e0 68 0a 38 	mov	r8,2616
8000d5f2:	18 96       	mov	r6,r12
8000d5f4:	16 97       	mov	r7,r11
8000d5f6:	70 0c       	ld.w	r12,r8[0x0]
8000d5f8:	58 0c       	cp.w	r12,0
8000d5fa:	c0 60       	breq	8000d606 <__swsetup_r+0x1a>
8000d5fc:	78 68       	ld.w	r8,r12[0x18]
8000d5fe:	58 08       	cp.w	r8,0
8000d600:	c0 31       	brne	8000d606 <__swsetup_r+0x1a>
8000d602:	e0 a0 07 c7 	rcall	8000e590 <__sinit>
8000d606:	4a f8       	lddpc	r8,8000d6c0 <__swsetup_r+0xd4>
8000d608:	10 37       	cp.w	r7,r8
8000d60a:	c0 61       	brne	8000d616 <__swsetup_r+0x2a>
8000d60c:	e0 68 0a 38 	mov	r8,2616
8000d610:	70 08       	ld.w	r8,r8[0x0]
8000d612:	70 07       	ld.w	r7,r8[0x0]
8000d614:	c1 08       	rjmp	8000d634 <__swsetup_r+0x48>
8000d616:	4a c8       	lddpc	r8,8000d6c4 <__swsetup_r+0xd8>
8000d618:	10 37       	cp.w	r7,r8
8000d61a:	c0 61       	brne	8000d626 <__swsetup_r+0x3a>
8000d61c:	e0 68 0a 38 	mov	r8,2616
8000d620:	70 08       	ld.w	r8,r8[0x0]
8000d622:	70 17       	ld.w	r7,r8[0x4]
8000d624:	c0 88       	rjmp	8000d634 <__swsetup_r+0x48>
8000d626:	4a 98       	lddpc	r8,8000d6c8 <__swsetup_r+0xdc>
8000d628:	10 37       	cp.w	r7,r8
8000d62a:	c0 51       	brne	8000d634 <__swsetup_r+0x48>
8000d62c:	e0 68 0a 38 	mov	r8,2616
8000d630:	70 08       	ld.w	r8,r8[0x0]
8000d632:	70 27       	ld.w	r7,r8[0x8]
8000d634:	8e 68       	ld.sh	r8,r7[0xc]
8000d636:	ed b8 00 03 	bld	r8,0x3
8000d63a:	c1 e0       	breq	8000d676 <__swsetup_r+0x8a>
8000d63c:	ed b8 00 04 	bld	r8,0x4
8000d640:	c3 e1       	brne	8000d6bc <__swsetup_r+0xd0>
8000d642:	ed b8 00 02 	bld	r8,0x2
8000d646:	c1 51       	brne	8000d670 <__swsetup_r+0x84>
8000d648:	6e db       	ld.w	r11,r7[0x34]
8000d64a:	58 0b       	cp.w	r11,0
8000d64c:	c0 a0       	breq	8000d660 <__swsetup_r+0x74>
8000d64e:	ee c8 ff bc 	sub	r8,r7,-68
8000d652:	10 3b       	cp.w	r11,r8
8000d654:	c0 40       	breq	8000d65c <__swsetup_r+0x70>
8000d656:	0c 9c       	mov	r12,r6
8000d658:	e0 a0 08 36 	rcall	8000e6c4 <_free_r>
8000d65c:	30 08       	mov	r8,0
8000d65e:	8f d8       	st.w	r7[0x34],r8
8000d660:	8e 68       	ld.sh	r8,r7[0xc]
8000d662:	e0 18 ff db 	andl	r8,0xffdb
8000d666:	ae 68       	st.h	r7[0xc],r8
8000d668:	30 08       	mov	r8,0
8000d66a:	8f 18       	st.w	r7[0x4],r8
8000d66c:	6e 48       	ld.w	r8,r7[0x10]
8000d66e:	8f 08       	st.w	r7[0x0],r8
8000d670:	8e 68       	ld.sh	r8,r7[0xc]
8000d672:	a3 b8       	sbr	r8,0x3
8000d674:	ae 68       	st.h	r7[0xc],r8
8000d676:	6e 48       	ld.w	r8,r7[0x10]
8000d678:	58 08       	cp.w	r8,0
8000d67a:	c0 b1       	brne	8000d690 <__swsetup_r+0xa4>
8000d67c:	8e 68       	ld.sh	r8,r7[0xc]
8000d67e:	e2 18 02 80 	andl	r8,0x280,COH
8000d682:	e0 48 02 00 	cp.w	r8,512
8000d686:	c0 50       	breq	8000d690 <__swsetup_r+0xa4>
8000d688:	0c 9c       	mov	r12,r6
8000d68a:	0e 9b       	mov	r11,r7
8000d68c:	e0 a0 0a 56 	rcall	8000eb38 <__smakebuf_r>
8000d690:	8e 69       	ld.sh	r9,r7[0xc]
8000d692:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000d696:	c0 70       	breq	8000d6a4 <__swsetup_r+0xb8>
8000d698:	30 08       	mov	r8,0
8000d69a:	8f 28       	st.w	r7[0x8],r8
8000d69c:	6e 58       	ld.w	r8,r7[0x14]
8000d69e:	5c 38       	neg	r8
8000d6a0:	8f 68       	st.w	r7[0x18],r8
8000d6a2:	c0 68       	rjmp	8000d6ae <__swsetup_r+0xc2>
8000d6a4:	ed b9 00 01 	bld	r9,0x1
8000d6a8:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000d6ac:	8f 28       	st.w	r7[0x8],r8
8000d6ae:	6e 48       	ld.w	r8,r7[0x10]
8000d6b0:	58 08       	cp.w	r8,0
8000d6b2:	c0 61       	brne	8000d6be <__swsetup_r+0xd2>
8000d6b4:	8e 68       	ld.sh	r8,r7[0xc]
8000d6b6:	ed b8 00 07 	bld	r8,0x7
8000d6ba:	c0 21       	brne	8000d6be <__swsetup_r+0xd2>
8000d6bc:	dc 2a       	popm	r4-r7,pc,r12=-1
8000d6be:	d8 2a       	popm	r4-r7,pc,r12=0
8000d6c0:	80 01       	ld.sh	r1,r0[0x0]
8000d6c2:	a0 a8       	st.b	r0[0x2],r8
8000d6c4:	80 01       	ld.sh	r1,r0[0x0]
8000d6c6:	a0 c8       	st.b	r0[0x4],r8
8000d6c8:	80 01       	ld.sh	r1,r0[0x0]
8000d6ca:	a0 e8       	st.b	r0[0x6],r8

8000d6cc <quorem>:
8000d6cc:	d4 31       	pushm	r0-r7,lr
8000d6ce:	20 2d       	sub	sp,8
8000d6d0:	18 97       	mov	r7,r12
8000d6d2:	78 48       	ld.w	r8,r12[0x10]
8000d6d4:	76 46       	ld.w	r6,r11[0x10]
8000d6d6:	0c 38       	cp.w	r8,r6
8000d6d8:	c0 34       	brge	8000d6de <quorem+0x12>
8000d6da:	30 0c       	mov	r12,0
8000d6dc:	c8 58       	rjmp	8000d7e6 <quorem+0x11a>
8000d6de:	ec c2 ff fc 	sub	r2,r6,-4
8000d6e2:	f6 c3 ff ec 	sub	r3,r11,-20
8000d6e6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000d6ea:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000d6ee:	2f f9       	sub	r9,-1
8000d6f0:	20 16       	sub	r6,1
8000d6f2:	f8 09 0d 08 	divu	r8,r12,r9
8000d6f6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000d6fa:	ee c4 ff ec 	sub	r4,r7,-20
8000d6fe:	10 95       	mov	r5,r8
8000d700:	58 08       	cp.w	r8,0
8000d702:	c4 10       	breq	8000d784 <quorem+0xb8>
8000d704:	30 09       	mov	r9,0
8000d706:	06 9a       	mov	r10,r3
8000d708:	08 98       	mov	r8,r4
8000d70a:	12 91       	mov	r1,r9
8000d70c:	50 0b       	stdsp	sp[0x0],r11
8000d70e:	70 0e       	ld.w	lr,r8[0x0]
8000d710:	b1 8e       	lsr	lr,0x10
8000d712:	50 1e       	stdsp	sp[0x4],lr
8000d714:	15 0e       	ld.w	lr,r10++
8000d716:	fc 00 16 10 	lsr	r0,lr,0x10
8000d71a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d71e:	ea 0e 03 41 	mac	r1,r5,lr
8000d722:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000d726:	b1 81       	lsr	r1,0x10
8000d728:	40 1b       	lddsp	r11,sp[0x4]
8000d72a:	ea 00 02 40 	mul	r0,r5,r0
8000d72e:	e2 00 00 00 	add	r0,r1,r0
8000d732:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000d736:	02 1b       	sub	r11,r1
8000d738:	50 1b       	stdsp	sp[0x4],r11
8000d73a:	70 0b       	ld.w	r11,r8[0x0]
8000d73c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000d740:	02 09       	add	r9,r1
8000d742:	f2 0e 01 0e 	sub	lr,r9,lr
8000d746:	b0 1e       	st.h	r8[0x2],lr
8000d748:	fc 09 14 10 	asr	r9,lr,0x10
8000d74c:	40 1e       	lddsp	lr,sp[0x4]
8000d74e:	fc 09 00 09 	add	r9,lr,r9
8000d752:	b0 09       	st.h	r8[0x0],r9
8000d754:	e0 01 16 10 	lsr	r1,r0,0x10
8000d758:	2f c8       	sub	r8,-4
8000d75a:	b1 49       	asr	r9,0x10
8000d75c:	04 3a       	cp.w	r10,r2
8000d75e:	fe 98 ff d8 	brls	8000d70e <quorem+0x42>
8000d762:	40 0b       	lddsp	r11,sp[0x0]
8000d764:	58 0c       	cp.w	r12,0
8000d766:	c0 f1       	brne	8000d784 <quorem+0xb8>
8000d768:	ec c8 ff fb 	sub	r8,r6,-5
8000d76c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d770:	c0 28       	rjmp	8000d774 <quorem+0xa8>
8000d772:	20 16       	sub	r6,1
8000d774:	20 48       	sub	r8,4
8000d776:	08 38       	cp.w	r8,r4
8000d778:	e0 88 00 05 	brls	8000d782 <quorem+0xb6>
8000d77c:	70 09       	ld.w	r9,r8[0x0]
8000d77e:	58 09       	cp.w	r9,0
8000d780:	cf 90       	breq	8000d772 <quorem+0xa6>
8000d782:	8f 46       	st.w	r7[0x10],r6
8000d784:	0e 9c       	mov	r12,r7
8000d786:	e0 a0 0a d8 	rcall	8000ed36 <__mcmp>
8000d78a:	c2 d5       	brlt	8000d7e4 <quorem+0x118>
8000d78c:	2f f5       	sub	r5,-1
8000d78e:	08 98       	mov	r8,r4
8000d790:	30 09       	mov	r9,0
8000d792:	07 0b       	ld.w	r11,r3++
8000d794:	f6 0a 16 10 	lsr	r10,r11,0x10
8000d798:	70 0c       	ld.w	r12,r8[0x0]
8000d79a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d79e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d7a2:	14 1e       	sub	lr,r10
8000d7a4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d7a8:	16 1a       	sub	r10,r11
8000d7aa:	12 0a       	add	r10,r9
8000d7ac:	b0 1a       	st.h	r8[0x2],r10
8000d7ae:	b1 4a       	asr	r10,0x10
8000d7b0:	fc 0a 00 09 	add	r9,lr,r10
8000d7b4:	b0 09       	st.h	r8[0x0],r9
8000d7b6:	2f c8       	sub	r8,-4
8000d7b8:	b1 49       	asr	r9,0x10
8000d7ba:	04 33       	cp.w	r3,r2
8000d7bc:	fe 98 ff eb 	brls	8000d792 <quorem+0xc6>
8000d7c0:	ec c8 ff fb 	sub	r8,r6,-5
8000d7c4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000d7c8:	58 09       	cp.w	r9,0
8000d7ca:	c0 d1       	brne	8000d7e4 <quorem+0x118>
8000d7cc:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d7d0:	c0 28       	rjmp	8000d7d4 <quorem+0x108>
8000d7d2:	20 16       	sub	r6,1
8000d7d4:	20 48       	sub	r8,4
8000d7d6:	08 38       	cp.w	r8,r4
8000d7d8:	e0 88 00 05 	brls	8000d7e2 <quorem+0x116>
8000d7dc:	70 09       	ld.w	r9,r8[0x0]
8000d7de:	58 09       	cp.w	r9,0
8000d7e0:	cf 90       	breq	8000d7d2 <quorem+0x106>
8000d7e2:	8f 46       	st.w	r7[0x10],r6
8000d7e4:	0a 9c       	mov	r12,r5
8000d7e6:	2f ed       	sub	sp,-8
8000d7e8:	d8 32       	popm	r0-r7,pc
8000d7ea:	d7 03       	nop

8000d7ec <_dtoa_r>:
8000d7ec:	d4 31       	pushm	r0-r7,lr
8000d7ee:	21 ad       	sub	sp,104
8000d7f0:	fa c4 ff 74 	sub	r4,sp,-140
8000d7f4:	18 97       	mov	r7,r12
8000d7f6:	16 95       	mov	r5,r11
8000d7f8:	68 2c       	ld.w	r12,r4[0x8]
8000d7fa:	50 c9       	stdsp	sp[0x30],r9
8000d7fc:	68 16       	ld.w	r6,r4[0x4]
8000d7fe:	68 09       	ld.w	r9,r4[0x0]
8000d800:	50 e8       	stdsp	sp[0x38],r8
8000d802:	14 94       	mov	r4,r10
8000d804:	51 2c       	stdsp	sp[0x48],r12
8000d806:	fa e5 00 08 	st.d	sp[8],r4
8000d80a:	51 59       	stdsp	sp[0x54],r9
8000d80c:	6e 95       	ld.w	r5,r7[0x24]
8000d80e:	58 05       	cp.w	r5,0
8000d810:	c0 91       	brne	8000d822 <_dtoa_r+0x36>
8000d812:	31 0c       	mov	r12,16
8000d814:	fe b0 e8 42 	rcall	8000a898 <malloc>
8000d818:	99 35       	st.w	r12[0xc],r5
8000d81a:	8f 9c       	st.w	r7[0x24],r12
8000d81c:	99 15       	st.w	r12[0x4],r5
8000d81e:	99 25       	st.w	r12[0x8],r5
8000d820:	99 05       	st.w	r12[0x0],r5
8000d822:	6e 99       	ld.w	r9,r7[0x24]
8000d824:	72 08       	ld.w	r8,r9[0x0]
8000d826:	58 08       	cp.w	r8,0
8000d828:	c0 f0       	breq	8000d846 <_dtoa_r+0x5a>
8000d82a:	72 1a       	ld.w	r10,r9[0x4]
8000d82c:	91 1a       	st.w	r8[0x4],r10
8000d82e:	30 1a       	mov	r10,1
8000d830:	72 19       	ld.w	r9,r9[0x4]
8000d832:	f4 09 09 49 	lsl	r9,r10,r9
8000d836:	10 9b       	mov	r11,r8
8000d838:	91 29       	st.w	r8[0x8],r9
8000d83a:	0e 9c       	mov	r12,r7
8000d83c:	e0 a0 0a 96 	rcall	8000ed68 <_Bfree>
8000d840:	6e 98       	ld.w	r8,r7[0x24]
8000d842:	30 09       	mov	r9,0
8000d844:	91 09       	st.w	r8[0x0],r9
8000d846:	40 28       	lddsp	r8,sp[0x8]
8000d848:	10 94       	mov	r4,r8
8000d84a:	58 08       	cp.w	r8,0
8000d84c:	c0 64       	brge	8000d858 <_dtoa_r+0x6c>
8000d84e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000d852:	50 28       	stdsp	sp[0x8],r8
8000d854:	30 18       	mov	r8,1
8000d856:	c0 28       	rjmp	8000d85a <_dtoa_r+0x6e>
8000d858:	30 08       	mov	r8,0
8000d85a:	8d 08       	st.w	r6[0x0],r8
8000d85c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000d860:	40 26       	lddsp	r6,sp[0x8]
8000d862:	0c 98       	mov	r8,r6
8000d864:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d868:	18 38       	cp.w	r8,r12
8000d86a:	c1 e1       	brne	8000d8a6 <_dtoa_r+0xba>
8000d86c:	e0 68 27 0f 	mov	r8,9999
8000d870:	41 5b       	lddsp	r11,sp[0x54]
8000d872:	97 08       	st.w	r11[0x0],r8
8000d874:	40 3a       	lddsp	r10,sp[0xc]
8000d876:	58 0a       	cp.w	r10,0
8000d878:	c0 61       	brne	8000d884 <_dtoa_r+0x98>
8000d87a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000d87e:	c0 31       	brne	8000d884 <_dtoa_r+0x98>
8000d880:	4a cc       	lddpc	r12,8000d930 <_dtoa_r+0x144>
8000d882:	c0 28       	rjmp	8000d886 <_dtoa_r+0x9a>
8000d884:	4a cc       	lddpc	r12,8000d934 <_dtoa_r+0x148>
8000d886:	41 29       	lddsp	r9,sp[0x48]
8000d888:	58 09       	cp.w	r9,0
8000d88a:	e0 80 05 9e 	breq	8000e3c6 <_dtoa_r+0xbda>
8000d88e:	f8 c8 ff fd 	sub	r8,r12,-3
8000d892:	f8 c9 ff f8 	sub	r9,r12,-8
8000d896:	11 8b       	ld.ub	r11,r8[0x0]
8000d898:	30 0a       	mov	r10,0
8000d89a:	41 25       	lddsp	r5,sp[0x48]
8000d89c:	f4 0b 18 00 	cp.b	r11,r10
8000d8a0:	f2 08 17 10 	movne	r8,r9
8000d8a4:	c1 58       	rjmp	8000d8ce <_dtoa_r+0xe2>
8000d8a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d8aa:	30 08       	mov	r8,0
8000d8ac:	fa eb 00 3c 	st.d	sp[60],r10
8000d8b0:	30 09       	mov	r9,0
8000d8b2:	e0 a0 10 ce 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000d8b6:	c0 f0       	breq	8000d8d4 <_dtoa_r+0xe8>
8000d8b8:	30 18       	mov	r8,1
8000d8ba:	41 5a       	lddsp	r10,sp[0x54]
8000d8bc:	95 08       	st.w	r10[0x0],r8
8000d8be:	49 fc       	lddpc	r12,8000d938 <_dtoa_r+0x14c>
8000d8c0:	41 29       	lddsp	r9,sp[0x48]
8000d8c2:	f8 08 00 08 	add	r8,r12,r8
8000d8c6:	58 09       	cp.w	r9,0
8000d8c8:	e0 80 05 7f 	breq	8000e3c6 <_dtoa_r+0xbda>
8000d8cc:	12 95       	mov	r5,r9
8000d8ce:	8b 08       	st.w	r5[0x0],r8
8000d8d0:	e0 8f 05 7b 	bral	8000e3c6 <_dtoa_r+0xbda>
8000d8d4:	fa c8 ff 9c 	sub	r8,sp,-100
8000d8d8:	fa c9 ff a0 	sub	r9,sp,-96
8000d8dc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d8e0:	0e 9c       	mov	r12,r7
8000d8e2:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d8e6:	e0 a0 0a 93 	rcall	8000ee0c <__d2b>
8000d8ea:	18 93       	mov	r3,r12
8000d8ec:	58 05       	cp.w	r5,0
8000d8ee:	c0 d0       	breq	8000d908 <_dtoa_r+0x11c>
8000d8f0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d8f4:	30 04       	mov	r4,0
8000d8f6:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d8fa:	ea c5 03 ff 	sub	r5,r5,1023
8000d8fe:	10 9b       	mov	r11,r8
8000d900:	51 74       	stdsp	sp[0x5c],r4
8000d902:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d906:	c2 a8       	rjmp	8000d95a <_dtoa_r+0x16e>
8000d908:	41 88       	lddsp	r8,sp[0x60]
8000d90a:	41 9c       	lddsp	r12,sp[0x64]
8000d90c:	10 0c       	add	r12,r8
8000d90e:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d912:	e0 45 00 20 	cp.w	r5,32
8000d916:	e0 8a 00 13 	brle	8000d93c <_dtoa_r+0x150>
8000d91a:	f8 cc fb ee 	sub	r12,r12,-1042
8000d91e:	40 3b       	lddsp	r11,sp[0xc]
8000d920:	ea 08 11 40 	rsub	r8,r5,64
8000d924:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d928:	ec 08 09 46 	lsl	r6,r6,r8
8000d92c:	0c 4c       	or	r12,r6
8000d92e:	c0 c8       	rjmp	8000d946 <_dtoa_r+0x15a>
8000d930:	80 01       	ld.sh	r1,r0[0x0]
8000d932:	a0 98       	st.b	r0[0x1],r8
8000d934:	80 01       	ld.sh	r1,r0[0x0]
8000d936:	a0 a4       	st.b	r0[0x2],r4
8000d938:	80 01       	ld.sh	r1,r0[0x0]
8000d93a:	9f 74       	st.w	pc[0x1c],r4
8000d93c:	ea 0c 11 20 	rsub	r12,r5,32
8000d940:	40 3a       	lddsp	r10,sp[0xc]
8000d942:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d946:	e0 a0 10 10 	rcall	8000f966 <__avr32_u32_to_f64>
8000d94a:	fc 18 fe 10 	movh	r8,0xfe10
8000d94e:	30 19       	mov	r9,1
8000d950:	ea c5 04 33 	sub	r5,r5,1075
8000d954:	f0 0b 00 0b 	add	r11,r8,r11
8000d958:	51 79       	stdsp	sp[0x5c],r9
8000d95a:	30 08       	mov	r8,0
8000d95c:	fc 19 3f f8 	movh	r9,0x3ff8
8000d960:	e0 a0 0e 98 	rcall	8000f690 <__avr32_f64_sub>
8000d964:	e0 68 43 61 	mov	r8,17249
8000d968:	ea 18 63 6f 	orh	r8,0x636f
8000d96c:	e0 69 87 a7 	mov	r9,34727
8000d970:	ea 19 3f d2 	orh	r9,0x3fd2
8000d974:	e0 a0 0d a2 	rcall	8000f4b8 <__avr32_f64_mul>
8000d978:	e0 68 c8 b3 	mov	r8,51379
8000d97c:	ea 18 8b 60 	orh	r8,0x8b60
8000d980:	e0 69 8a 28 	mov	r9,35368
8000d984:	ea 19 3f c6 	orh	r9,0x3fc6
8000d988:	e0 a0 0f 52 	rcall	8000f82c <__avr32_f64_add>
8000d98c:	0a 9c       	mov	r12,r5
8000d98e:	14 90       	mov	r0,r10
8000d990:	16 91       	mov	r1,r11
8000d992:	e0 a0 0f ee 	rcall	8000f96e <__avr32_s32_to_f64>
8000d996:	e0 68 79 fb 	mov	r8,31227
8000d99a:	ea 18 50 9f 	orh	r8,0x509f
8000d99e:	e0 69 44 13 	mov	r9,17427
8000d9a2:	ea 19 3f d3 	orh	r9,0x3fd3
8000d9a6:	e0 a0 0d 89 	rcall	8000f4b8 <__avr32_f64_mul>
8000d9aa:	14 98       	mov	r8,r10
8000d9ac:	16 99       	mov	r9,r11
8000d9ae:	00 9a       	mov	r10,r0
8000d9b0:	02 9b       	mov	r11,r1
8000d9b2:	e0 a0 0f 3d 	rcall	8000f82c <__avr32_f64_add>
8000d9b6:	14 90       	mov	r0,r10
8000d9b8:	16 91       	mov	r1,r11
8000d9ba:	e0 a0 0f c3 	rcall	8000f940 <__avr32_f64_to_s32>
8000d9be:	30 08       	mov	r8,0
8000d9c0:	18 96       	mov	r6,r12
8000d9c2:	30 09       	mov	r9,0
8000d9c4:	00 9a       	mov	r10,r0
8000d9c6:	02 9b       	mov	r11,r1
8000d9c8:	e0 a0 10 8a 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000d9cc:	c0 c0       	breq	8000d9e4 <_dtoa_r+0x1f8>
8000d9ce:	0c 9c       	mov	r12,r6
8000d9d0:	e0 a0 0f cf 	rcall	8000f96e <__avr32_s32_to_f64>
8000d9d4:	14 98       	mov	r8,r10
8000d9d6:	16 99       	mov	r9,r11
8000d9d8:	00 9a       	mov	r10,r0
8000d9da:	02 9b       	mov	r11,r1
8000d9dc:	e0 a0 10 39 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000d9e0:	f7 b6 00 01 	subeq	r6,1
8000d9e4:	59 66       	cp.w	r6,22
8000d9e6:	e0 88 00 05 	brls	8000d9f0 <_dtoa_r+0x204>
8000d9ea:	30 18       	mov	r8,1
8000d9ec:	51 48       	stdsp	sp[0x50],r8
8000d9ee:	c1 28       	rjmp	8000da12 <_dtoa_r+0x226>
8000d9f0:	4c 08       	lddpc	r8,8000daf0 <_dtoa_r+0x304>
8000d9f2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d9f6:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d9fa:	e0 a0 10 71 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000d9fe:	f9 b4 00 00 	moveq	r4,0
8000da02:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000da06:	f7 b6 01 01 	subne	r6,1
8000da0a:	f9 bc 01 00 	movne	r12,0
8000da0e:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000da12:	41 90       	lddsp	r0,sp[0x64]
8000da14:	20 10       	sub	r0,1
8000da16:	0a 10       	sub	r0,r5
8000da18:	c0 46       	brmi	8000da20 <_dtoa_r+0x234>
8000da1a:	50 40       	stdsp	sp[0x10],r0
8000da1c:	30 00       	mov	r0,0
8000da1e:	c0 48       	rjmp	8000da26 <_dtoa_r+0x23a>
8000da20:	30 0b       	mov	r11,0
8000da22:	5c 30       	neg	r0
8000da24:	50 4b       	stdsp	sp[0x10],r11
8000da26:	ec 02 11 00 	rsub	r2,r6,0
8000da2a:	58 06       	cp.w	r6,0
8000da2c:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000da30:	f5 d6 e4 0a 	addge	r10,r10,r6
8000da34:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000da38:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000da3c:	f9 b2 04 00 	movge	r2,0
8000da40:	e1 d6 e5 10 	sublt	r0,r0,r6
8000da44:	f9 b9 05 00 	movlt	r9,0
8000da48:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000da4c:	40 c8       	lddsp	r8,sp[0x30]
8000da4e:	58 98       	cp.w	r8,9
8000da50:	e0 8b 00 20 	brhi	8000da90 <_dtoa_r+0x2a4>
8000da54:	58 58       	cp.w	r8,5
8000da56:	f9 b4 0a 01 	movle	r4,1
8000da5a:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000da5e:	f7 b5 09 04 	subgt	r5,4
8000da62:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000da66:	f9 b4 09 00 	movgt	r4,0
8000da6a:	40 cc       	lddsp	r12,sp[0x30]
8000da6c:	58 3c       	cp.w	r12,3
8000da6e:	c2 d0       	breq	8000dac8 <_dtoa_r+0x2dc>
8000da70:	e0 89 00 05 	brgt	8000da7a <_dtoa_r+0x28e>
8000da74:	58 2c       	cp.w	r12,2
8000da76:	c1 01       	brne	8000da96 <_dtoa_r+0x2aa>
8000da78:	c1 88       	rjmp	8000daa8 <_dtoa_r+0x2bc>
8000da7a:	40 cb       	lddsp	r11,sp[0x30]
8000da7c:	58 4b       	cp.w	r11,4
8000da7e:	c0 60       	breq	8000da8a <_dtoa_r+0x29e>
8000da80:	58 5b       	cp.w	r11,5
8000da82:	c0 a1       	brne	8000da96 <_dtoa_r+0x2aa>
8000da84:	30 1a       	mov	r10,1
8000da86:	50 da       	stdsp	sp[0x34],r10
8000da88:	c2 28       	rjmp	8000dacc <_dtoa_r+0x2e0>
8000da8a:	30 19       	mov	r9,1
8000da8c:	50 d9       	stdsp	sp[0x34],r9
8000da8e:	c0 f8       	rjmp	8000daac <_dtoa_r+0x2c0>
8000da90:	30 08       	mov	r8,0
8000da92:	30 14       	mov	r4,1
8000da94:	50 c8       	stdsp	sp[0x30],r8
8000da96:	3f f5       	mov	r5,-1
8000da98:	30 1c       	mov	r12,1
8000da9a:	30 0b       	mov	r11,0
8000da9c:	50 95       	stdsp	sp[0x24],r5
8000da9e:	50 dc       	stdsp	sp[0x34],r12
8000daa0:	0a 91       	mov	r1,r5
8000daa2:	31 28       	mov	r8,18
8000daa4:	50 eb       	stdsp	sp[0x38],r11
8000daa6:	c2 08       	rjmp	8000dae6 <_dtoa_r+0x2fa>
8000daa8:	30 0a       	mov	r10,0
8000daaa:	50 da       	stdsp	sp[0x34],r10
8000daac:	40 e9       	lddsp	r9,sp[0x38]
8000daae:	58 09       	cp.w	r9,0
8000dab0:	e0 89 00 07 	brgt	8000dabe <_dtoa_r+0x2d2>
8000dab4:	30 18       	mov	r8,1
8000dab6:	50 98       	stdsp	sp[0x24],r8
8000dab8:	10 91       	mov	r1,r8
8000daba:	50 e8       	stdsp	sp[0x38],r8
8000dabc:	c1 58       	rjmp	8000dae6 <_dtoa_r+0x2fa>
8000dabe:	40 e5       	lddsp	r5,sp[0x38]
8000dac0:	50 95       	stdsp	sp[0x24],r5
8000dac2:	0a 91       	mov	r1,r5
8000dac4:	0a 98       	mov	r8,r5
8000dac6:	c1 08       	rjmp	8000dae6 <_dtoa_r+0x2fa>
8000dac8:	30 0c       	mov	r12,0
8000daca:	50 dc       	stdsp	sp[0x34],r12
8000dacc:	40 eb       	lddsp	r11,sp[0x38]
8000dace:	ec 0b 00 0b 	add	r11,r6,r11
8000dad2:	50 9b       	stdsp	sp[0x24],r11
8000dad4:	16 98       	mov	r8,r11
8000dad6:	2f f8       	sub	r8,-1
8000dad8:	58 08       	cp.w	r8,0
8000dada:	e0 89 00 05 	brgt	8000dae4 <_dtoa_r+0x2f8>
8000dade:	10 91       	mov	r1,r8
8000dae0:	30 18       	mov	r8,1
8000dae2:	c0 28       	rjmp	8000dae6 <_dtoa_r+0x2fa>
8000dae4:	10 91       	mov	r1,r8
8000dae6:	30 09       	mov	r9,0
8000dae8:	6e 9a       	ld.w	r10,r7[0x24]
8000daea:	95 19       	st.w	r10[0x4],r9
8000daec:	30 49       	mov	r9,4
8000daee:	c0 78       	rjmp	8000dafc <_dtoa_r+0x310>
8000daf0:	80 01       	ld.sh	r1,r0[0x0]
8000daf2:	a1 58       	asr	r8,0x1
8000daf4:	6a 1a       	ld.w	r10,r5[0x4]
8000daf6:	a1 79       	lsl	r9,0x1
8000daf8:	2f fa       	sub	r10,-1
8000dafa:	8b 1a       	st.w	r5[0x4],r10
8000dafc:	6e 95       	ld.w	r5,r7[0x24]
8000dafe:	f2 ca ff ec 	sub	r10,r9,-20
8000db02:	10 3a       	cp.w	r10,r8
8000db04:	fe 98 ff f8 	brls	8000daf4 <_dtoa_r+0x308>
8000db08:	6a 1b       	ld.w	r11,r5[0x4]
8000db0a:	0e 9c       	mov	r12,r7
8000db0c:	e0 a0 09 48 	rcall	8000ed9c <_Balloc>
8000db10:	58 e1       	cp.w	r1,14
8000db12:	5f 88       	srls	r8
8000db14:	8b 0c       	st.w	r5[0x0],r12
8000db16:	f1 e4 00 04 	and	r4,r8,r4
8000db1a:	6e 98       	ld.w	r8,r7[0x24]
8000db1c:	70 08       	ld.w	r8,r8[0x0]
8000db1e:	50 88       	stdsp	sp[0x20],r8
8000db20:	e0 80 01 82 	breq	8000de24 <_dtoa_r+0x638>
8000db24:	58 06       	cp.w	r6,0
8000db26:	e0 8a 00 40 	brle	8000dba6 <_dtoa_r+0x3ba>
8000db2a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000db2e:	4c b8       	lddpc	r8,8000dc58 <_dtoa_r+0x46c>
8000db30:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000db34:	fa e5 00 18 	st.d	sp[24],r4
8000db38:	ec 04 14 04 	asr	r4,r6,0x4
8000db3c:	ed b4 00 04 	bld	r4,0x4
8000db40:	c0 30       	breq	8000db46 <_dtoa_r+0x35a>
8000db42:	30 25       	mov	r5,2
8000db44:	c0 f8       	rjmp	8000db62 <_dtoa_r+0x376>
8000db46:	4c 68       	lddpc	r8,8000dc5c <_dtoa_r+0x470>
8000db48:	f0 e8 00 20 	ld.d	r8,r8[32]
8000db4c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000db50:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000db54:	e0 a0 0f f8 	rcall	8000fb44 <__avr32_f64_div>
8000db58:	30 35       	mov	r5,3
8000db5a:	14 98       	mov	r8,r10
8000db5c:	16 99       	mov	r9,r11
8000db5e:	fa e9 00 08 	st.d	sp[8],r8
8000db62:	4b fc       	lddpc	r12,8000dc5c <_dtoa_r+0x470>
8000db64:	50 a3       	stdsp	sp[0x28],r3
8000db66:	0c 93       	mov	r3,r6
8000db68:	18 96       	mov	r6,r12
8000db6a:	c0 f8       	rjmp	8000db88 <_dtoa_r+0x39c>
8000db6c:	fa ea 00 18 	ld.d	r10,sp[24]
8000db70:	ed b4 00 00 	bld	r4,0x0
8000db74:	c0 81       	brne	8000db84 <_dtoa_r+0x398>
8000db76:	ec e8 00 00 	ld.d	r8,r6[0]
8000db7a:	2f f5       	sub	r5,-1
8000db7c:	e0 a0 0c 9e 	rcall	8000f4b8 <__avr32_f64_mul>
8000db80:	fa eb 00 18 	st.d	sp[24],r10
8000db84:	a1 54       	asr	r4,0x1
8000db86:	2f 86       	sub	r6,-8
8000db88:	58 04       	cp.w	r4,0
8000db8a:	cf 11       	brne	8000db6c <_dtoa_r+0x380>
8000db8c:	fa e8 00 18 	ld.d	r8,sp[24]
8000db90:	fa ea 00 08 	ld.d	r10,sp[8]
8000db94:	06 96       	mov	r6,r3
8000db96:	e0 a0 0f d7 	rcall	8000fb44 <__avr32_f64_div>
8000db9a:	40 a3       	lddsp	r3,sp[0x28]
8000db9c:	14 98       	mov	r8,r10
8000db9e:	16 99       	mov	r9,r11
8000dba0:	fa e9 00 08 	st.d	sp[8],r8
8000dba4:	c2 d8       	rjmp	8000dbfe <_dtoa_r+0x412>
8000dba6:	ec 08 11 00 	rsub	r8,r6,0
8000dbaa:	c0 31       	brne	8000dbb0 <_dtoa_r+0x3c4>
8000dbac:	30 25       	mov	r5,2
8000dbae:	c2 88       	rjmp	8000dbfe <_dtoa_r+0x412>
8000dbb0:	4a bc       	lddpc	r12,8000dc5c <_dtoa_r+0x470>
8000dbb2:	f0 04 14 04 	asr	r4,r8,0x4
8000dbb6:	50 1c       	stdsp	sp[0x4],r12
8000dbb8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000dbbc:	4a 79       	lddpc	r9,8000dc58 <_dtoa_r+0x46c>
8000dbbe:	fa ea 00 3c 	ld.d	r10,sp[60]
8000dbc2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000dbc6:	e0 a0 0c 79 	rcall	8000f4b8 <__avr32_f64_mul>
8000dbca:	40 1c       	lddsp	r12,sp[0x4]
8000dbcc:	50 63       	stdsp	sp[0x18],r3
8000dbce:	30 25       	mov	r5,2
8000dbd0:	0c 93       	mov	r3,r6
8000dbd2:	fa eb 00 08 	st.d	sp[8],r10
8000dbd6:	18 96       	mov	r6,r12
8000dbd8:	c0 f8       	rjmp	8000dbf6 <_dtoa_r+0x40a>
8000dbda:	fa ea 00 08 	ld.d	r10,sp[8]
8000dbde:	ed b4 00 00 	bld	r4,0x0
8000dbe2:	c0 81       	brne	8000dbf2 <_dtoa_r+0x406>
8000dbe4:	ec e8 00 00 	ld.d	r8,r6[0]
8000dbe8:	2f f5       	sub	r5,-1
8000dbea:	e0 a0 0c 67 	rcall	8000f4b8 <__avr32_f64_mul>
8000dbee:	fa eb 00 08 	st.d	sp[8],r10
8000dbf2:	a1 54       	asr	r4,0x1
8000dbf4:	2f 86       	sub	r6,-8
8000dbf6:	58 04       	cp.w	r4,0
8000dbf8:	cf 11       	brne	8000dbda <_dtoa_r+0x3ee>
8000dbfa:	06 96       	mov	r6,r3
8000dbfc:	40 63       	lddsp	r3,sp[0x18]
8000dbfe:	41 4a       	lddsp	r10,sp[0x50]
8000dc00:	58 0a       	cp.w	r10,0
8000dc02:	c2 f0       	breq	8000dc60 <_dtoa_r+0x474>
8000dc04:	fa e8 00 08 	ld.d	r8,sp[8]
8000dc08:	58 01       	cp.w	r1,0
8000dc0a:	5f 94       	srgt	r4
8000dc0c:	fa e9 00 18 	st.d	sp[24],r8
8000dc10:	30 08       	mov	r8,0
8000dc12:	fc 19 3f f0 	movh	r9,0x3ff0
8000dc16:	fa ea 00 18 	ld.d	r10,sp[24]
8000dc1a:	e0 a0 0f 61 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000dc1e:	f9 bc 00 00 	moveq	r12,0
8000dc22:	f9 bc 01 01 	movne	r12,1
8000dc26:	e9 ec 00 0c 	and	r12,r4,r12
8000dc2a:	c1 b0       	breq	8000dc60 <_dtoa_r+0x474>
8000dc2c:	40 98       	lddsp	r8,sp[0x24]
8000dc2e:	58 08       	cp.w	r8,0
8000dc30:	e0 8a 00 f6 	brle	8000de1c <_dtoa_r+0x630>
8000dc34:	30 08       	mov	r8,0
8000dc36:	fc 19 40 24 	movh	r9,0x4024
8000dc3a:	ec c4 00 01 	sub	r4,r6,1
8000dc3e:	fa ea 00 18 	ld.d	r10,sp[24]
8000dc42:	2f f5       	sub	r5,-1
8000dc44:	50 64       	stdsp	sp[0x18],r4
8000dc46:	e0 a0 0c 39 	rcall	8000f4b8 <__avr32_f64_mul>
8000dc4a:	40 94       	lddsp	r4,sp[0x24]
8000dc4c:	14 98       	mov	r8,r10
8000dc4e:	16 99       	mov	r9,r11
8000dc50:	fa e9 00 08 	st.d	sp[8],r8
8000dc54:	c0 88       	rjmp	8000dc64 <_dtoa_r+0x478>
8000dc56:	d7 03       	nop
8000dc58:	80 01       	ld.sh	r1,r0[0x0]
8000dc5a:	a1 58       	asr	r8,0x1
8000dc5c:	80 01       	ld.sh	r1,r0[0x0]
8000dc5e:	a2 20       	st.h	r1[0x4],r0
8000dc60:	50 66       	stdsp	sp[0x18],r6
8000dc62:	02 94       	mov	r4,r1
8000dc64:	0a 9c       	mov	r12,r5
8000dc66:	e0 a0 0e 84 	rcall	8000f96e <__avr32_s32_to_f64>
8000dc6a:	fa e8 00 08 	ld.d	r8,sp[8]
8000dc6e:	e0 a0 0c 25 	rcall	8000f4b8 <__avr32_f64_mul>
8000dc72:	30 08       	mov	r8,0
8000dc74:	fc 19 40 1c 	movh	r9,0x401c
8000dc78:	e0 a0 0d da 	rcall	8000f82c <__avr32_f64_add>
8000dc7c:	14 98       	mov	r8,r10
8000dc7e:	16 99       	mov	r9,r11
8000dc80:	fa e9 00 28 	st.d	sp[40],r8
8000dc84:	fc 18 fc c0 	movh	r8,0xfcc0
8000dc88:	40 a5       	lddsp	r5,sp[0x28]
8000dc8a:	10 05       	add	r5,r8
8000dc8c:	50 a5       	stdsp	sp[0x28],r5
8000dc8e:	58 04       	cp.w	r4,0
8000dc90:	c2 11       	brne	8000dcd2 <_dtoa_r+0x4e6>
8000dc92:	fa ea 00 08 	ld.d	r10,sp[8]
8000dc96:	30 08       	mov	r8,0
8000dc98:	fc 19 40 14 	movh	r9,0x4014
8000dc9c:	e0 a0 0c fa 	rcall	8000f690 <__avr32_f64_sub>
8000dca0:	40 bc       	lddsp	r12,sp[0x2c]
8000dca2:	fa eb 00 08 	st.d	sp[8],r10
8000dca6:	14 98       	mov	r8,r10
8000dca8:	16 99       	mov	r9,r11
8000dcaa:	18 9a       	mov	r10,r12
8000dcac:	0a 9b       	mov	r11,r5
8000dcae:	e0 a0 0f 17 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000dcb2:	e0 81 02 54 	brne	8000e15a <_dtoa_r+0x96e>
8000dcb6:	0a 98       	mov	r8,r5
8000dcb8:	40 b9       	lddsp	r9,sp[0x2c]
8000dcba:	ee 18 80 00 	eorh	r8,0x8000
8000dcbe:	fa ea 00 08 	ld.d	r10,sp[8]
8000dcc2:	10 95       	mov	r5,r8
8000dcc4:	12 98       	mov	r8,r9
8000dcc6:	0a 99       	mov	r9,r5
8000dcc8:	e0 a0 0f 0a 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000dccc:	e0 81 02 3e 	brne	8000e148 <_dtoa_r+0x95c>
8000dcd0:	ca 68       	rjmp	8000de1c <_dtoa_r+0x630>
8000dcd2:	4c e9       	lddpc	r9,8000de08 <_dtoa_r+0x61c>
8000dcd4:	e8 c8 00 01 	sub	r8,r4,1
8000dcd8:	40 d5       	lddsp	r5,sp[0x34]
8000dcda:	58 05       	cp.w	r5,0
8000dcdc:	c4 f0       	breq	8000dd7a <_dtoa_r+0x58e>
8000dcde:	30 0c       	mov	r12,0
8000dce0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000dce4:	51 3c       	stdsp	sp[0x4c],r12
8000dce6:	30 0a       	mov	r10,0
8000dce8:	fc 1b 3f e0 	movh	r11,0x3fe0
8000dcec:	e0 a0 0f 2c 	rcall	8000fb44 <__avr32_f64_div>
8000dcf0:	fa e8 00 28 	ld.d	r8,sp[40]
8000dcf4:	40 85       	lddsp	r5,sp[0x20]
8000dcf6:	e0 a0 0c cd 	rcall	8000f690 <__avr32_f64_sub>
8000dcfa:	fa eb 00 28 	st.d	sp[40],r10
8000dcfe:	fa ea 00 08 	ld.d	r10,sp[8]
8000dd02:	e0 a0 0e 1f 	rcall	8000f940 <__avr32_f64_to_s32>
8000dd06:	51 6c       	stdsp	sp[0x58],r12
8000dd08:	e0 a0 0e 33 	rcall	8000f96e <__avr32_s32_to_f64>
8000dd0c:	14 98       	mov	r8,r10
8000dd0e:	16 99       	mov	r9,r11
8000dd10:	fa ea 00 08 	ld.d	r10,sp[8]
8000dd14:	e0 a0 0c be 	rcall	8000f690 <__avr32_f64_sub>
8000dd18:	fa eb 00 08 	st.d	sp[8],r10
8000dd1c:	41 68       	lddsp	r8,sp[0x58]
8000dd1e:	2d 08       	sub	r8,-48
8000dd20:	0a c8       	st.b	r5++,r8
8000dd22:	41 39       	lddsp	r9,sp[0x4c]
8000dd24:	2f f9       	sub	r9,-1
8000dd26:	51 39       	stdsp	sp[0x4c],r9
8000dd28:	fa e8 00 28 	ld.d	r8,sp[40]
8000dd2c:	e0 a0 0e d8 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000dd30:	e0 81 03 3a 	brne	8000e3a4 <_dtoa_r+0xbb8>
8000dd34:	fa e8 00 08 	ld.d	r8,sp[8]
8000dd38:	30 0a       	mov	r10,0
8000dd3a:	fc 1b 3f f0 	movh	r11,0x3ff0
8000dd3e:	e0 a0 0c a9 	rcall	8000f690 <__avr32_f64_sub>
8000dd42:	fa e8 00 28 	ld.d	r8,sp[40]
8000dd46:	e0 a0 0e cb 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000dd4a:	fa ea 00 28 	ld.d	r10,sp[40]
8000dd4e:	30 08       	mov	r8,0
8000dd50:	fc 19 40 24 	movh	r9,0x4024
8000dd54:	e0 81 00 da 	brne	8000df08 <_dtoa_r+0x71c>
8000dd58:	41 3c       	lddsp	r12,sp[0x4c]
8000dd5a:	08 3c       	cp.w	r12,r4
8000dd5c:	c6 04       	brge	8000de1c <_dtoa_r+0x630>
8000dd5e:	e0 a0 0b ad 	rcall	8000f4b8 <__avr32_f64_mul>
8000dd62:	30 08       	mov	r8,0
8000dd64:	fa eb 00 28 	st.d	sp[40],r10
8000dd68:	fc 19 40 24 	movh	r9,0x4024
8000dd6c:	fa ea 00 08 	ld.d	r10,sp[8]
8000dd70:	e0 a0 0b a4 	rcall	8000f4b8 <__avr32_f64_mul>
8000dd74:	fa eb 00 08 	st.d	sp[8],r10
8000dd78:	cc 3b       	rjmp	8000dcfe <_dtoa_r+0x512>
8000dd7a:	40 85       	lddsp	r5,sp[0x20]
8000dd7c:	08 05       	add	r5,r4
8000dd7e:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000dd82:	51 35       	stdsp	sp[0x4c],r5
8000dd84:	fa e8 00 28 	ld.d	r8,sp[40]
8000dd88:	40 85       	lddsp	r5,sp[0x20]
8000dd8a:	e0 a0 0b 97 	rcall	8000f4b8 <__avr32_f64_mul>
8000dd8e:	fa eb 00 28 	st.d	sp[40],r10
8000dd92:	fa ea 00 08 	ld.d	r10,sp[8]
8000dd96:	e0 a0 0d d5 	rcall	8000f940 <__avr32_f64_to_s32>
8000dd9a:	51 6c       	stdsp	sp[0x58],r12
8000dd9c:	e0 a0 0d e9 	rcall	8000f96e <__avr32_s32_to_f64>
8000dda0:	14 98       	mov	r8,r10
8000dda2:	16 99       	mov	r9,r11
8000dda4:	fa ea 00 08 	ld.d	r10,sp[8]
8000dda8:	e0 a0 0c 74 	rcall	8000f690 <__avr32_f64_sub>
8000ddac:	fa eb 00 08 	st.d	sp[8],r10
8000ddb0:	41 68       	lddsp	r8,sp[0x58]
8000ddb2:	2d 08       	sub	r8,-48
8000ddb4:	0a c8       	st.b	r5++,r8
8000ddb6:	41 3c       	lddsp	r12,sp[0x4c]
8000ddb8:	18 35       	cp.w	r5,r12
8000ddba:	c2 91       	brne	8000de0c <_dtoa_r+0x620>
8000ddbc:	30 08       	mov	r8,0
8000ddbe:	fc 19 3f e0 	movh	r9,0x3fe0
8000ddc2:	fa ea 00 28 	ld.d	r10,sp[40]
8000ddc6:	e0 a0 0d 33 	rcall	8000f82c <__avr32_f64_add>
8000ddca:	40 85       	lddsp	r5,sp[0x20]
8000ddcc:	fa e8 00 08 	ld.d	r8,sp[8]
8000ddd0:	08 05       	add	r5,r4
8000ddd2:	e0 a0 0e 85 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000ddd6:	e0 81 00 99 	brne	8000df08 <_dtoa_r+0x71c>
8000ddda:	fa e8 00 28 	ld.d	r8,sp[40]
8000ddde:	30 0a       	mov	r10,0
8000dde0:	fc 1b 3f e0 	movh	r11,0x3fe0
8000dde4:	e0 a0 0c 56 	rcall	8000f690 <__avr32_f64_sub>
8000dde8:	14 98       	mov	r8,r10
8000ddea:	16 99       	mov	r9,r11
8000ddec:	fa ea 00 08 	ld.d	r10,sp[8]
8000ddf0:	e0 a0 0e 76 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000ddf4:	c1 40       	breq	8000de1c <_dtoa_r+0x630>
8000ddf6:	33 09       	mov	r9,48
8000ddf8:	0a 98       	mov	r8,r5
8000ddfa:	11 7a       	ld.ub	r10,--r8
8000ddfc:	f2 0a 18 00 	cp.b	r10,r9
8000de00:	e0 81 02 d2 	brne	8000e3a4 <_dtoa_r+0xbb8>
8000de04:	10 95       	mov	r5,r8
8000de06:	cf 9b       	rjmp	8000ddf8 <_dtoa_r+0x60c>
8000de08:	80 01       	ld.sh	r1,r0[0x0]
8000de0a:	a1 58       	asr	r8,0x1
8000de0c:	30 08       	mov	r8,0
8000de0e:	fc 19 40 24 	movh	r9,0x4024
8000de12:	e0 a0 0b 53 	rcall	8000f4b8 <__avr32_f64_mul>
8000de16:	fa eb 00 08 	st.d	sp[8],r10
8000de1a:	cb cb       	rjmp	8000dd92 <_dtoa_r+0x5a6>
8000de1c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000de20:	fa eb 00 08 	st.d	sp[8],r10
8000de24:	58 e6       	cp.w	r6,14
8000de26:	5f ab       	srle	r11
8000de28:	41 8a       	lddsp	r10,sp[0x60]
8000de2a:	30 08       	mov	r8,0
8000de2c:	f4 09 11 ff 	rsub	r9,r10,-1
8000de30:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000de34:	f0 09 18 00 	cp.b	r9,r8
8000de38:	e0 80 00 81 	breq	8000df3a <_dtoa_r+0x74e>
8000de3c:	40 ea       	lddsp	r10,sp[0x38]
8000de3e:	58 01       	cp.w	r1,0
8000de40:	5f a9       	srle	r9
8000de42:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000de46:	4c 9a       	lddpc	r10,8000df68 <_dtoa_r+0x77c>
8000de48:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000de4c:	fa e5 00 10 	st.d	sp[16],r4
8000de50:	f0 09 18 00 	cp.b	r9,r8
8000de54:	c1 40       	breq	8000de7c <_dtoa_r+0x690>
8000de56:	58 01       	cp.w	r1,0
8000de58:	e0 81 01 78 	brne	8000e148 <_dtoa_r+0x95c>
8000de5c:	30 08       	mov	r8,0
8000de5e:	fc 19 40 14 	movh	r9,0x4014
8000de62:	08 9a       	mov	r10,r4
8000de64:	0a 9b       	mov	r11,r5
8000de66:	e0 a0 0b 29 	rcall	8000f4b8 <__avr32_f64_mul>
8000de6a:	fa e8 00 08 	ld.d	r8,sp[8]
8000de6e:	e0 a0 0e 03 	rcall	8000fa74 <__avr32_f64_cmp_ge>
8000de72:	e0 81 01 6b 	brne	8000e148 <_dtoa_r+0x95c>
8000de76:	02 92       	mov	r2,r1
8000de78:	e0 8f 01 73 	bral	8000e15e <_dtoa_r+0x972>
8000de7c:	40 85       	lddsp	r5,sp[0x20]
8000de7e:	30 14       	mov	r4,1
8000de80:	fa e8 00 10 	ld.d	r8,sp[16]
8000de84:	fa ea 00 08 	ld.d	r10,sp[8]
8000de88:	e0 a0 0e 5e 	rcall	8000fb44 <__avr32_f64_div>
8000de8c:	e0 a0 0d 5a 	rcall	8000f940 <__avr32_f64_to_s32>
8000de90:	18 92       	mov	r2,r12
8000de92:	e0 a0 0d 6e 	rcall	8000f96e <__avr32_s32_to_f64>
8000de96:	fa e8 00 10 	ld.d	r8,sp[16]
8000de9a:	e0 a0 0b 0f 	rcall	8000f4b8 <__avr32_f64_mul>
8000de9e:	14 98       	mov	r8,r10
8000dea0:	16 99       	mov	r9,r11
8000dea2:	fa ea 00 08 	ld.d	r10,sp[8]
8000dea6:	e0 a0 0b f5 	rcall	8000f690 <__avr32_f64_sub>
8000deaa:	fa eb 00 08 	st.d	sp[8],r10
8000deae:	e4 c8 ff d0 	sub	r8,r2,-48
8000deb2:	0a c8       	st.b	r5++,r8
8000deb4:	fc 19 40 24 	movh	r9,0x4024
8000deb8:	30 08       	mov	r8,0
8000deba:	02 34       	cp.w	r4,r1
8000debc:	c3 31       	brne	8000df22 <_dtoa_r+0x736>
8000debe:	fa e8 00 08 	ld.d	r8,sp[8]
8000dec2:	e0 a0 0c b5 	rcall	8000f82c <__avr32_f64_add>
8000dec6:	16 91       	mov	r1,r11
8000dec8:	14 90       	mov	r0,r10
8000deca:	14 98       	mov	r8,r10
8000decc:	02 99       	mov	r9,r1
8000dece:	fa ea 00 10 	ld.d	r10,sp[16]
8000ded2:	e0 a0 0e 05 	rcall	8000fadc <__avr32_f64_cmp_lt>
8000ded6:	c1 a1       	brne	8000df0a <_dtoa_r+0x71e>
8000ded8:	fa e8 00 10 	ld.d	r8,sp[16]
8000dedc:	00 9a       	mov	r10,r0
8000dede:	02 9b       	mov	r11,r1
8000dee0:	e0 a0 0d b7 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000dee4:	e0 80 02 5f 	breq	8000e3a2 <_dtoa_r+0xbb6>
8000dee8:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000deec:	c0 f1       	brne	8000df0a <_dtoa_r+0x71e>
8000deee:	e0 8f 02 5a 	bral	8000e3a2 <_dtoa_r+0xbb6>
8000def2:	40 8a       	lddsp	r10,sp[0x20]
8000def4:	14 38       	cp.w	r8,r10
8000def6:	c0 30       	breq	8000defc <_dtoa_r+0x710>
8000def8:	10 95       	mov	r5,r8
8000defa:	c0 98       	rjmp	8000df0c <_dtoa_r+0x720>
8000defc:	33 08       	mov	r8,48
8000defe:	40 89       	lddsp	r9,sp[0x20]
8000df00:	2f f6       	sub	r6,-1
8000df02:	b2 88       	st.b	r9[0x0],r8
8000df04:	40 88       	lddsp	r8,sp[0x20]
8000df06:	c0 88       	rjmp	8000df16 <_dtoa_r+0x72a>
8000df08:	40 66       	lddsp	r6,sp[0x18]
8000df0a:	33 99       	mov	r9,57
8000df0c:	0a 98       	mov	r8,r5
8000df0e:	11 7a       	ld.ub	r10,--r8
8000df10:	f2 0a 18 00 	cp.b	r10,r9
8000df14:	ce f0       	breq	8000def2 <_dtoa_r+0x706>
8000df16:	50 66       	stdsp	sp[0x18],r6
8000df18:	11 89       	ld.ub	r9,r8[0x0]
8000df1a:	2f f9       	sub	r9,-1
8000df1c:	b0 89       	st.b	r8[0x0],r9
8000df1e:	e0 8f 02 43 	bral	8000e3a4 <_dtoa_r+0xbb8>
8000df22:	e0 a0 0a cb 	rcall	8000f4b8 <__avr32_f64_mul>
8000df26:	2f f4       	sub	r4,-1
8000df28:	fa eb 00 08 	st.d	sp[8],r10
8000df2c:	30 08       	mov	r8,0
8000df2e:	30 09       	mov	r9,0
8000df30:	e0 a0 0d 8f 	rcall	8000fa4e <__avr32_f64_cmp_eq>
8000df34:	ca 60       	breq	8000de80 <_dtoa_r+0x694>
8000df36:	e0 8f 02 36 	bral	8000e3a2 <_dtoa_r+0xbb6>
8000df3a:	40 d8       	lddsp	r8,sp[0x34]
8000df3c:	58 08       	cp.w	r8,0
8000df3e:	c0 51       	brne	8000df48 <_dtoa_r+0x75c>
8000df40:	04 98       	mov	r8,r2
8000df42:	00 95       	mov	r5,r0
8000df44:	40 d4       	lddsp	r4,sp[0x34]
8000df46:	c3 88       	rjmp	8000dfb6 <_dtoa_r+0x7ca>
8000df48:	40 c5       	lddsp	r5,sp[0x30]
8000df4a:	58 15       	cp.w	r5,1
8000df4c:	e0 89 00 10 	brgt	8000df6c <_dtoa_r+0x780>
8000df50:	41 74       	lddsp	r4,sp[0x5c]
8000df52:	58 04       	cp.w	r4,0
8000df54:	c0 40       	breq	8000df5c <_dtoa_r+0x770>
8000df56:	f4 c9 fb cd 	sub	r9,r10,-1075
8000df5a:	c0 48       	rjmp	8000df62 <_dtoa_r+0x776>
8000df5c:	41 99       	lddsp	r9,sp[0x64]
8000df5e:	f2 09 11 36 	rsub	r9,r9,54
8000df62:	04 98       	mov	r8,r2
8000df64:	00 95       	mov	r5,r0
8000df66:	c1 d8       	rjmp	8000dfa0 <_dtoa_r+0x7b4>
8000df68:	80 01       	ld.sh	r1,r0[0x0]
8000df6a:	a1 58       	asr	r8,0x1
8000df6c:	e2 c8 00 01 	sub	r8,r1,1
8000df70:	58 01       	cp.w	r1,0
8000df72:	e0 05 17 40 	movge	r5,r0
8000df76:	e2 09 17 40 	movge	r9,r1
8000df7a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000df7e:	f9 b9 05 00 	movlt	r9,0
8000df82:	10 32       	cp.w	r2,r8
8000df84:	e5 d8 e4 18 	subge	r8,r2,r8
8000df88:	f1 d2 e5 18 	sublt	r8,r8,r2
8000df8c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000df90:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000df94:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000df98:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000df9c:	f9 b8 05 00 	movlt	r8,0
8000dfa0:	40 4b       	lddsp	r11,sp[0x10]
8000dfa2:	12 0b       	add	r11,r9
8000dfa4:	50 08       	stdsp	sp[0x0],r8
8000dfa6:	50 4b       	stdsp	sp[0x10],r11
8000dfa8:	12 00       	add	r0,r9
8000dfaa:	30 1b       	mov	r11,1
8000dfac:	0e 9c       	mov	r12,r7
8000dfae:	e0 a0 08 ab 	rcall	8000f104 <__i2b>
8000dfb2:	40 08       	lddsp	r8,sp[0x0]
8000dfb4:	18 94       	mov	r4,r12
8000dfb6:	40 4a       	lddsp	r10,sp[0x10]
8000dfb8:	58 05       	cp.w	r5,0
8000dfba:	5f 99       	srgt	r9
8000dfbc:	58 0a       	cp.w	r10,0
8000dfbe:	5f 9a       	srgt	r10
8000dfc0:	f5 e9 00 09 	and	r9,r10,r9
8000dfc4:	c0 80       	breq	8000dfd4 <_dtoa_r+0x7e8>
8000dfc6:	40 4c       	lddsp	r12,sp[0x10]
8000dfc8:	f8 05 0d 49 	min	r9,r12,r5
8000dfcc:	12 1c       	sub	r12,r9
8000dfce:	12 10       	sub	r0,r9
8000dfd0:	50 4c       	stdsp	sp[0x10],r12
8000dfd2:	12 15       	sub	r5,r9
8000dfd4:	58 02       	cp.w	r2,0
8000dfd6:	e0 8a 00 27 	brle	8000e024 <_dtoa_r+0x838>
8000dfda:	40 db       	lddsp	r11,sp[0x34]
8000dfdc:	58 0b       	cp.w	r11,0
8000dfde:	c1 d0       	breq	8000e018 <_dtoa_r+0x82c>
8000dfe0:	58 08       	cp.w	r8,0
8000dfe2:	e0 8a 00 17 	brle	8000e010 <_dtoa_r+0x824>
8000dfe6:	10 9a       	mov	r10,r8
8000dfe8:	50 08       	stdsp	sp[0x0],r8
8000dfea:	08 9b       	mov	r11,r4
8000dfec:	0e 9c       	mov	r12,r7
8000dfee:	e0 a0 08 d1 	rcall	8000f190 <__pow5mult>
8000dff2:	06 9a       	mov	r10,r3
8000dff4:	18 9b       	mov	r11,r12
8000dff6:	18 94       	mov	r4,r12
8000dff8:	0e 9c       	mov	r12,r7
8000dffa:	e0 a0 08 05 	rcall	8000f004 <__multiply>
8000dffe:	18 99       	mov	r9,r12
8000e000:	06 9b       	mov	r11,r3
8000e002:	50 19       	stdsp	sp[0x4],r9
8000e004:	0e 9c       	mov	r12,r7
8000e006:	e0 a0 06 b1 	rcall	8000ed68 <_Bfree>
8000e00a:	40 19       	lddsp	r9,sp[0x4]
8000e00c:	40 08       	lddsp	r8,sp[0x0]
8000e00e:	12 93       	mov	r3,r9
8000e010:	e4 08 01 0a 	sub	r10,r2,r8
8000e014:	c0 80       	breq	8000e024 <_dtoa_r+0x838>
8000e016:	c0 28       	rjmp	8000e01a <_dtoa_r+0x82e>
8000e018:	04 9a       	mov	r10,r2
8000e01a:	06 9b       	mov	r11,r3
8000e01c:	0e 9c       	mov	r12,r7
8000e01e:	e0 a0 08 b9 	rcall	8000f190 <__pow5mult>
8000e022:	18 93       	mov	r3,r12
8000e024:	30 1b       	mov	r11,1
8000e026:	0e 9c       	mov	r12,r7
8000e028:	e0 a0 08 6e 	rcall	8000f104 <__i2b>
8000e02c:	41 1a       	lddsp	r10,sp[0x44]
8000e02e:	18 92       	mov	r2,r12
8000e030:	58 0a       	cp.w	r10,0
8000e032:	e0 8a 00 07 	brle	8000e040 <_dtoa_r+0x854>
8000e036:	18 9b       	mov	r11,r12
8000e038:	0e 9c       	mov	r12,r7
8000e03a:	e0 a0 08 ab 	rcall	8000f190 <__pow5mult>
8000e03e:	18 92       	mov	r2,r12
8000e040:	40 c9       	lddsp	r9,sp[0x30]
8000e042:	58 19       	cp.w	r9,1
8000e044:	e0 89 00 14 	brgt	8000e06c <_dtoa_r+0x880>
8000e048:	40 38       	lddsp	r8,sp[0xc]
8000e04a:	58 08       	cp.w	r8,0
8000e04c:	c1 01       	brne	8000e06c <_dtoa_r+0x880>
8000e04e:	40 29       	lddsp	r9,sp[0x8]
8000e050:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000e054:	c0 c1       	brne	8000e06c <_dtoa_r+0x880>
8000e056:	12 98       	mov	r8,r9
8000e058:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000e05c:	c0 80       	breq	8000e06c <_dtoa_r+0x880>
8000e05e:	40 4c       	lddsp	r12,sp[0x10]
8000e060:	30 1b       	mov	r11,1
8000e062:	2f fc       	sub	r12,-1
8000e064:	2f f0       	sub	r0,-1
8000e066:	50 4c       	stdsp	sp[0x10],r12
8000e068:	50 6b       	stdsp	sp[0x18],r11
8000e06a:	c0 38       	rjmp	8000e070 <_dtoa_r+0x884>
8000e06c:	30 0a       	mov	r10,0
8000e06e:	50 6a       	stdsp	sp[0x18],r10
8000e070:	41 19       	lddsp	r9,sp[0x44]
8000e072:	58 09       	cp.w	r9,0
8000e074:	c0 31       	brne	8000e07a <_dtoa_r+0x88e>
8000e076:	30 1c       	mov	r12,1
8000e078:	c0 98       	rjmp	8000e08a <_dtoa_r+0x89e>
8000e07a:	64 48       	ld.w	r8,r2[0x10]
8000e07c:	2f c8       	sub	r8,-4
8000e07e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000e082:	e0 a0 05 e3 	rcall	8000ec48 <__hi0bits>
8000e086:	f8 0c 11 20 	rsub	r12,r12,32
8000e08a:	40 4b       	lddsp	r11,sp[0x10]
8000e08c:	f8 0b 00 08 	add	r8,r12,r11
8000e090:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000e094:	c0 c0       	breq	8000e0ac <_dtoa_r+0x8c0>
8000e096:	f0 08 11 20 	rsub	r8,r8,32
8000e09a:	58 48       	cp.w	r8,4
8000e09c:	e0 8a 00 06 	brle	8000e0a8 <_dtoa_r+0x8bc>
8000e0a0:	20 48       	sub	r8,4
8000e0a2:	10 0b       	add	r11,r8
8000e0a4:	50 4b       	stdsp	sp[0x10],r11
8000e0a6:	c0 78       	rjmp	8000e0b4 <_dtoa_r+0x8c8>
8000e0a8:	58 48       	cp.w	r8,4
8000e0aa:	c0 70       	breq	8000e0b8 <_dtoa_r+0x8cc>
8000e0ac:	40 4a       	lddsp	r10,sp[0x10]
8000e0ae:	2e 48       	sub	r8,-28
8000e0b0:	10 0a       	add	r10,r8
8000e0b2:	50 4a       	stdsp	sp[0x10],r10
8000e0b4:	10 00       	add	r0,r8
8000e0b6:	10 05       	add	r5,r8
8000e0b8:	58 00       	cp.w	r0,0
8000e0ba:	e0 8a 00 08 	brle	8000e0ca <_dtoa_r+0x8de>
8000e0be:	06 9b       	mov	r11,r3
8000e0c0:	00 9a       	mov	r10,r0
8000e0c2:	0e 9c       	mov	r12,r7
8000e0c4:	e0 a0 07 5c 	rcall	8000ef7c <__lshift>
8000e0c8:	18 93       	mov	r3,r12
8000e0ca:	40 49       	lddsp	r9,sp[0x10]
8000e0cc:	58 09       	cp.w	r9,0
8000e0ce:	e0 8a 00 08 	brle	8000e0de <_dtoa_r+0x8f2>
8000e0d2:	04 9b       	mov	r11,r2
8000e0d4:	12 9a       	mov	r10,r9
8000e0d6:	0e 9c       	mov	r12,r7
8000e0d8:	e0 a0 07 52 	rcall	8000ef7c <__lshift>
8000e0dc:	18 92       	mov	r2,r12
8000e0de:	41 48       	lddsp	r8,sp[0x50]
8000e0e0:	58 08       	cp.w	r8,0
8000e0e2:	c1 b0       	breq	8000e118 <_dtoa_r+0x92c>
8000e0e4:	04 9b       	mov	r11,r2
8000e0e6:	06 9c       	mov	r12,r3
8000e0e8:	e0 a0 06 27 	rcall	8000ed36 <__mcmp>
8000e0ec:	c1 64       	brge	8000e118 <_dtoa_r+0x92c>
8000e0ee:	06 9b       	mov	r11,r3
8000e0f0:	30 09       	mov	r9,0
8000e0f2:	30 aa       	mov	r10,10
8000e0f4:	0e 9c       	mov	r12,r7
8000e0f6:	e0 a0 08 0f 	rcall	8000f114 <__multadd>
8000e0fa:	20 16       	sub	r6,1
8000e0fc:	18 93       	mov	r3,r12
8000e0fe:	40 dc       	lddsp	r12,sp[0x34]
8000e100:	58 0c       	cp.w	r12,0
8000e102:	c0 31       	brne	8000e108 <_dtoa_r+0x91c>
8000e104:	40 91       	lddsp	r1,sp[0x24]
8000e106:	c0 98       	rjmp	8000e118 <_dtoa_r+0x92c>
8000e108:	08 9b       	mov	r11,r4
8000e10a:	40 91       	lddsp	r1,sp[0x24]
8000e10c:	30 09       	mov	r9,0
8000e10e:	30 aa       	mov	r10,10
8000e110:	0e 9c       	mov	r12,r7
8000e112:	e0 a0 08 01 	rcall	8000f114 <__multadd>
8000e116:	18 94       	mov	r4,r12
8000e118:	58 01       	cp.w	r1,0
8000e11a:	5f a9       	srle	r9
8000e11c:	40 cb       	lddsp	r11,sp[0x30]
8000e11e:	58 2b       	cp.w	r11,2
8000e120:	5f 98       	srgt	r8
8000e122:	f3 e8 00 08 	and	r8,r9,r8
8000e126:	c2 50       	breq	8000e170 <_dtoa_r+0x984>
8000e128:	58 01       	cp.w	r1,0
8000e12a:	c1 11       	brne	8000e14c <_dtoa_r+0x960>
8000e12c:	04 9b       	mov	r11,r2
8000e12e:	02 99       	mov	r9,r1
8000e130:	30 5a       	mov	r10,5
8000e132:	0e 9c       	mov	r12,r7
8000e134:	e0 a0 07 f0 	rcall	8000f114 <__multadd>
8000e138:	18 92       	mov	r2,r12
8000e13a:	18 9b       	mov	r11,r12
8000e13c:	06 9c       	mov	r12,r3
8000e13e:	e0 a0 05 fc 	rcall	8000ed36 <__mcmp>
8000e142:	e0 89 00 0f 	brgt	8000e160 <_dtoa_r+0x974>
8000e146:	c0 38       	rjmp	8000e14c <_dtoa_r+0x960>
8000e148:	30 02       	mov	r2,0
8000e14a:	04 94       	mov	r4,r2
8000e14c:	40 ea       	lddsp	r10,sp[0x38]
8000e14e:	30 09       	mov	r9,0
8000e150:	5c da       	com	r10
8000e152:	40 85       	lddsp	r5,sp[0x20]
8000e154:	50 6a       	stdsp	sp[0x18],r10
8000e156:	50 49       	stdsp	sp[0x10],r9
8000e158:	c0 f9       	rjmp	8000e376 <_dtoa_r+0xb8a>
8000e15a:	08 92       	mov	r2,r4
8000e15c:	40 66       	lddsp	r6,sp[0x18]
8000e15e:	04 94       	mov	r4,r2
8000e160:	2f f6       	sub	r6,-1
8000e162:	50 66       	stdsp	sp[0x18],r6
8000e164:	33 18       	mov	r8,49
8000e166:	40 85       	lddsp	r5,sp[0x20]
8000e168:	0a c8       	st.b	r5++,r8
8000e16a:	30 08       	mov	r8,0
8000e16c:	50 48       	stdsp	sp[0x10],r8
8000e16e:	c0 49       	rjmp	8000e376 <_dtoa_r+0xb8a>
8000e170:	40 dc       	lddsp	r12,sp[0x34]
8000e172:	58 0c       	cp.w	r12,0
8000e174:	e0 80 00 b5 	breq	8000e2de <_dtoa_r+0xaf2>
8000e178:	58 05       	cp.w	r5,0
8000e17a:	e0 8a 00 08 	brle	8000e18a <_dtoa_r+0x99e>
8000e17e:	08 9b       	mov	r11,r4
8000e180:	0a 9a       	mov	r10,r5
8000e182:	0e 9c       	mov	r12,r7
8000e184:	e0 a0 06 fc 	rcall	8000ef7c <__lshift>
8000e188:	18 94       	mov	r4,r12
8000e18a:	40 6b       	lddsp	r11,sp[0x18]
8000e18c:	58 0b       	cp.w	r11,0
8000e18e:	c0 31       	brne	8000e194 <_dtoa_r+0x9a8>
8000e190:	08 9c       	mov	r12,r4
8000e192:	c1 38       	rjmp	8000e1b8 <_dtoa_r+0x9cc>
8000e194:	68 1b       	ld.w	r11,r4[0x4]
8000e196:	0e 9c       	mov	r12,r7
8000e198:	e0 a0 06 02 	rcall	8000ed9c <_Balloc>
8000e19c:	68 4a       	ld.w	r10,r4[0x10]
8000e19e:	18 95       	mov	r5,r12
8000e1a0:	e8 cb ff f4 	sub	r11,r4,-12
8000e1a4:	2f ea       	sub	r10,-2
8000e1a6:	2f 4c       	sub	r12,-12
8000e1a8:	a3 6a       	lsl	r10,0x2
8000e1aa:	fe b0 e5 ae 	rcall	8000ad06 <memcpy>
8000e1ae:	0a 9b       	mov	r11,r5
8000e1b0:	30 1a       	mov	r10,1
8000e1b2:	0e 9c       	mov	r12,r7
8000e1b4:	e0 a0 06 e4 	rcall	8000ef7c <__lshift>
8000e1b8:	50 44       	stdsp	sp[0x10],r4
8000e1ba:	40 3a       	lddsp	r10,sp[0xc]
8000e1bc:	30 19       	mov	r9,1
8000e1be:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000e1c2:	18 94       	mov	r4,r12
8000e1c4:	50 da       	stdsp	sp[0x34],r10
8000e1c6:	40 85       	lddsp	r5,sp[0x20]
8000e1c8:	50 99       	stdsp	sp[0x24],r9
8000e1ca:	50 26       	stdsp	sp[0x8],r6
8000e1cc:	50 e1       	stdsp	sp[0x38],r1
8000e1ce:	04 9b       	mov	r11,r2
8000e1d0:	06 9c       	mov	r12,r3
8000e1d2:	fe b0 fa 7d 	rcall	8000d6cc <quorem>
8000e1d6:	40 4b       	lddsp	r11,sp[0x10]
8000e1d8:	f8 c0 ff d0 	sub	r0,r12,-48
8000e1dc:	06 9c       	mov	r12,r3
8000e1de:	e0 a0 05 ac 	rcall	8000ed36 <__mcmp>
8000e1e2:	08 9a       	mov	r10,r4
8000e1e4:	50 6c       	stdsp	sp[0x18],r12
8000e1e6:	04 9b       	mov	r11,r2
8000e1e8:	0e 9c       	mov	r12,r7
8000e1ea:	e0 a0 06 61 	rcall	8000eeac <__mdiff>
8000e1ee:	18 91       	mov	r1,r12
8000e1f0:	78 38       	ld.w	r8,r12[0xc]
8000e1f2:	58 08       	cp.w	r8,0
8000e1f4:	c0 30       	breq	8000e1fa <_dtoa_r+0xa0e>
8000e1f6:	30 16       	mov	r6,1
8000e1f8:	c0 68       	rjmp	8000e204 <_dtoa_r+0xa18>
8000e1fa:	18 9b       	mov	r11,r12
8000e1fc:	06 9c       	mov	r12,r3
8000e1fe:	e0 a0 05 9c 	rcall	8000ed36 <__mcmp>
8000e202:	18 96       	mov	r6,r12
8000e204:	0e 9c       	mov	r12,r7
8000e206:	02 9b       	mov	r11,r1
8000e208:	e0 a0 05 b0 	rcall	8000ed68 <_Bfree>
8000e20c:	40 cc       	lddsp	r12,sp[0x30]
8000e20e:	ed ec 10 08 	or	r8,r6,r12
8000e212:	c0 d1       	brne	8000e22c <_dtoa_r+0xa40>
8000e214:	40 db       	lddsp	r11,sp[0x34]
8000e216:	58 0b       	cp.w	r11,0
8000e218:	c0 a1       	brne	8000e22c <_dtoa_r+0xa40>
8000e21a:	40 26       	lddsp	r6,sp[0x8]
8000e21c:	e0 40 00 39 	cp.w	r0,57
8000e220:	c3 00       	breq	8000e280 <_dtoa_r+0xa94>
8000e222:	40 6a       	lddsp	r10,sp[0x18]
8000e224:	58 0a       	cp.w	r10,0
8000e226:	e0 89 00 24 	brgt	8000e26e <_dtoa_r+0xa82>
8000e22a:	c2 f8       	rjmp	8000e288 <_dtoa_r+0xa9c>
8000e22c:	40 69       	lddsp	r9,sp[0x18]
8000e22e:	58 09       	cp.w	r9,0
8000e230:	c0 85       	brlt	8000e240 <_dtoa_r+0xa54>
8000e232:	12 98       	mov	r8,r9
8000e234:	40 cc       	lddsp	r12,sp[0x30]
8000e236:	18 48       	or	r8,r12
8000e238:	c1 d1       	brne	8000e272 <_dtoa_r+0xa86>
8000e23a:	40 db       	lddsp	r11,sp[0x34]
8000e23c:	58 0b       	cp.w	r11,0
8000e23e:	c1 a1       	brne	8000e272 <_dtoa_r+0xa86>
8000e240:	0c 99       	mov	r9,r6
8000e242:	40 26       	lddsp	r6,sp[0x8]
8000e244:	58 09       	cp.w	r9,0
8000e246:	e0 8a 00 21 	brle	8000e288 <_dtoa_r+0xa9c>
8000e24a:	06 9b       	mov	r11,r3
8000e24c:	30 1a       	mov	r10,1
8000e24e:	0e 9c       	mov	r12,r7
8000e250:	e0 a0 06 96 	rcall	8000ef7c <__lshift>
8000e254:	04 9b       	mov	r11,r2
8000e256:	18 93       	mov	r3,r12
8000e258:	e0 a0 05 6f 	rcall	8000ed36 <__mcmp>
8000e25c:	e0 89 00 06 	brgt	8000e268 <_dtoa_r+0xa7c>
8000e260:	c1 41       	brne	8000e288 <_dtoa_r+0xa9c>
8000e262:	ed b0 00 00 	bld	r0,0x0
8000e266:	c1 11       	brne	8000e288 <_dtoa_r+0xa9c>
8000e268:	e0 40 00 39 	cp.w	r0,57
8000e26c:	c0 a0       	breq	8000e280 <_dtoa_r+0xa94>
8000e26e:	2f f0       	sub	r0,-1
8000e270:	c0 c8       	rjmp	8000e288 <_dtoa_r+0xa9c>
8000e272:	58 06       	cp.w	r6,0
8000e274:	e0 8a 00 0c 	brle	8000e28c <_dtoa_r+0xaa0>
8000e278:	40 26       	lddsp	r6,sp[0x8]
8000e27a:	e0 40 00 39 	cp.w	r0,57
8000e27e:	c0 41       	brne	8000e286 <_dtoa_r+0xa9a>
8000e280:	33 98       	mov	r8,57
8000e282:	0a c8       	st.b	r5++,r8
8000e284:	c6 78       	rjmp	8000e352 <_dtoa_r+0xb66>
8000e286:	2f f0       	sub	r0,-1
8000e288:	0a c0       	st.b	r5++,r0
8000e28a:	c7 58       	rjmp	8000e374 <_dtoa_r+0xb88>
8000e28c:	0a c0       	st.b	r5++,r0
8000e28e:	40 9a       	lddsp	r10,sp[0x24]
8000e290:	40 e9       	lddsp	r9,sp[0x38]
8000e292:	12 3a       	cp.w	r10,r9
8000e294:	c4 30       	breq	8000e31a <_dtoa_r+0xb2e>
8000e296:	06 9b       	mov	r11,r3
8000e298:	30 09       	mov	r9,0
8000e29a:	30 aa       	mov	r10,10
8000e29c:	0e 9c       	mov	r12,r7
8000e29e:	e0 a0 07 3b 	rcall	8000f114 <__multadd>
8000e2a2:	40 48       	lddsp	r8,sp[0x10]
8000e2a4:	18 93       	mov	r3,r12
8000e2a6:	08 38       	cp.w	r8,r4
8000e2a8:	c0 91       	brne	8000e2ba <_dtoa_r+0xace>
8000e2aa:	10 9b       	mov	r11,r8
8000e2ac:	30 09       	mov	r9,0
8000e2ae:	30 aa       	mov	r10,10
8000e2b0:	0e 9c       	mov	r12,r7
8000e2b2:	e0 a0 07 31 	rcall	8000f114 <__multadd>
8000e2b6:	50 4c       	stdsp	sp[0x10],r12
8000e2b8:	c0 e8       	rjmp	8000e2d4 <_dtoa_r+0xae8>
8000e2ba:	40 4b       	lddsp	r11,sp[0x10]
8000e2bc:	30 09       	mov	r9,0
8000e2be:	30 aa       	mov	r10,10
8000e2c0:	0e 9c       	mov	r12,r7
8000e2c2:	e0 a0 07 29 	rcall	8000f114 <__multadd>
8000e2c6:	08 9b       	mov	r11,r4
8000e2c8:	50 4c       	stdsp	sp[0x10],r12
8000e2ca:	30 09       	mov	r9,0
8000e2cc:	30 aa       	mov	r10,10
8000e2ce:	0e 9c       	mov	r12,r7
8000e2d0:	e0 a0 07 22 	rcall	8000f114 <__multadd>
8000e2d4:	18 94       	mov	r4,r12
8000e2d6:	40 9c       	lddsp	r12,sp[0x24]
8000e2d8:	2f fc       	sub	r12,-1
8000e2da:	50 9c       	stdsp	sp[0x24],r12
8000e2dc:	c7 9b       	rjmp	8000e1ce <_dtoa_r+0x9e2>
8000e2de:	30 18       	mov	r8,1
8000e2e0:	06 90       	mov	r0,r3
8000e2e2:	40 85       	lddsp	r5,sp[0x20]
8000e2e4:	08 93       	mov	r3,r4
8000e2e6:	0c 94       	mov	r4,r6
8000e2e8:	10 96       	mov	r6,r8
8000e2ea:	04 9b       	mov	r11,r2
8000e2ec:	00 9c       	mov	r12,r0
8000e2ee:	fe b0 f9 ef 	rcall	8000d6cc <quorem>
8000e2f2:	2d 0c       	sub	r12,-48
8000e2f4:	0a cc       	st.b	r5++,r12
8000e2f6:	02 36       	cp.w	r6,r1
8000e2f8:	c0 a4       	brge	8000e30c <_dtoa_r+0xb20>
8000e2fa:	00 9b       	mov	r11,r0
8000e2fc:	30 09       	mov	r9,0
8000e2fe:	30 aa       	mov	r10,10
8000e300:	0e 9c       	mov	r12,r7
8000e302:	2f f6       	sub	r6,-1
8000e304:	e0 a0 07 08 	rcall	8000f114 <__multadd>
8000e308:	18 90       	mov	r0,r12
8000e30a:	cf 0b       	rjmp	8000e2ea <_dtoa_r+0xafe>
8000e30c:	08 96       	mov	r6,r4
8000e30e:	30 0b       	mov	r11,0
8000e310:	06 94       	mov	r4,r3
8000e312:	50 4b       	stdsp	sp[0x10],r11
8000e314:	00 93       	mov	r3,r0
8000e316:	18 90       	mov	r0,r12
8000e318:	c0 28       	rjmp	8000e31c <_dtoa_r+0xb30>
8000e31a:	40 26       	lddsp	r6,sp[0x8]
8000e31c:	06 9b       	mov	r11,r3
8000e31e:	30 1a       	mov	r10,1
8000e320:	0e 9c       	mov	r12,r7
8000e322:	e0 a0 06 2d 	rcall	8000ef7c <__lshift>
8000e326:	04 9b       	mov	r11,r2
8000e328:	18 93       	mov	r3,r12
8000e32a:	e0 a0 05 06 	rcall	8000ed36 <__mcmp>
8000e32e:	e0 89 00 12 	brgt	8000e352 <_dtoa_r+0xb66>
8000e332:	c1 b1       	brne	8000e368 <_dtoa_r+0xb7c>
8000e334:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000e338:	c0 d1       	brne	8000e352 <_dtoa_r+0xb66>
8000e33a:	c1 78       	rjmp	8000e368 <_dtoa_r+0xb7c>
8000e33c:	40 89       	lddsp	r9,sp[0x20]
8000e33e:	12 38       	cp.w	r8,r9
8000e340:	c0 30       	breq	8000e346 <_dtoa_r+0xb5a>
8000e342:	10 95       	mov	r5,r8
8000e344:	c0 88       	rjmp	8000e354 <_dtoa_r+0xb68>
8000e346:	2f f6       	sub	r6,-1
8000e348:	50 66       	stdsp	sp[0x18],r6
8000e34a:	33 18       	mov	r8,49
8000e34c:	40 8c       	lddsp	r12,sp[0x20]
8000e34e:	b8 88       	st.b	r12[0x0],r8
8000e350:	c1 38       	rjmp	8000e376 <_dtoa_r+0xb8a>
8000e352:	33 9a       	mov	r10,57
8000e354:	0a 98       	mov	r8,r5
8000e356:	11 79       	ld.ub	r9,--r8
8000e358:	f4 09 18 00 	cp.b	r9,r10
8000e35c:	cf 00       	breq	8000e33c <_dtoa_r+0xb50>
8000e35e:	2f f9       	sub	r9,-1
8000e360:	b0 89       	st.b	r8[0x0],r9
8000e362:	c0 98       	rjmp	8000e374 <_dtoa_r+0xb88>
8000e364:	10 95       	mov	r5,r8
8000e366:	c0 28       	rjmp	8000e36a <_dtoa_r+0xb7e>
8000e368:	33 09       	mov	r9,48
8000e36a:	0a 98       	mov	r8,r5
8000e36c:	11 7a       	ld.ub	r10,--r8
8000e36e:	f2 0a 18 00 	cp.b	r10,r9
8000e372:	cf 90       	breq	8000e364 <_dtoa_r+0xb78>
8000e374:	50 66       	stdsp	sp[0x18],r6
8000e376:	04 9b       	mov	r11,r2
8000e378:	0e 9c       	mov	r12,r7
8000e37a:	e0 a0 04 f7 	rcall	8000ed68 <_Bfree>
8000e37e:	58 04       	cp.w	r4,0
8000e380:	c1 20       	breq	8000e3a4 <_dtoa_r+0xbb8>
8000e382:	40 4b       	lddsp	r11,sp[0x10]
8000e384:	08 3b       	cp.w	r11,r4
8000e386:	5f 19       	srne	r9
8000e388:	58 0b       	cp.w	r11,0
8000e38a:	5f 18       	srne	r8
8000e38c:	f3 e8 00 08 	and	r8,r9,r8
8000e390:	c0 40       	breq	8000e398 <_dtoa_r+0xbac>
8000e392:	0e 9c       	mov	r12,r7
8000e394:	e0 a0 04 ea 	rcall	8000ed68 <_Bfree>
8000e398:	08 9b       	mov	r11,r4
8000e39a:	0e 9c       	mov	r12,r7
8000e39c:	e0 a0 04 e6 	rcall	8000ed68 <_Bfree>
8000e3a0:	c0 28       	rjmp	8000e3a4 <_dtoa_r+0xbb8>
8000e3a2:	50 66       	stdsp	sp[0x18],r6
8000e3a4:	0e 9c       	mov	r12,r7
8000e3a6:	06 9b       	mov	r11,r3
8000e3a8:	e0 a0 04 e0 	rcall	8000ed68 <_Bfree>
8000e3ac:	30 08       	mov	r8,0
8000e3ae:	aa 88       	st.b	r5[0x0],r8
8000e3b0:	40 68       	lddsp	r8,sp[0x18]
8000e3b2:	41 5a       	lddsp	r10,sp[0x54]
8000e3b4:	2f f8       	sub	r8,-1
8000e3b6:	41 29       	lddsp	r9,sp[0x48]
8000e3b8:	95 08       	st.w	r10[0x0],r8
8000e3ba:	40 8c       	lddsp	r12,sp[0x20]
8000e3bc:	58 09       	cp.w	r9,0
8000e3be:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000e3c2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000e3c6:	2e 6d       	sub	sp,-104
8000e3c8:	d8 32       	popm	r0-r7,pc
8000e3ca:	d7 03       	nop

8000e3cc <__errno>:
8000e3cc:	e0 68 0a 38 	mov	r8,2616
8000e3d0:	70 0c       	ld.w	r12,r8[0x0]
8000e3d2:	2f 4c       	sub	r12,-12
8000e3d4:	5e fc       	retal	r12
8000e3d6:	d7 03       	nop

8000e3d8 <_fflush_r>:
8000e3d8:	d4 21       	pushm	r4-r7,lr
8000e3da:	16 97       	mov	r7,r11
8000e3dc:	18 96       	mov	r6,r12
8000e3de:	76 48       	ld.w	r8,r11[0x10]
8000e3e0:	58 08       	cp.w	r8,0
8000e3e2:	c7 c0       	breq	8000e4da <_fflush_r+0x102>
8000e3e4:	58 0c       	cp.w	r12,0
8000e3e6:	c0 50       	breq	8000e3f0 <_fflush_r+0x18>
8000e3e8:	78 68       	ld.w	r8,r12[0x18]
8000e3ea:	58 08       	cp.w	r8,0
8000e3ec:	c0 21       	brne	8000e3f0 <_fflush_r+0x18>
8000e3ee:	cd 1c       	rcall	8000e590 <__sinit>
8000e3f0:	4b b8       	lddpc	r8,8000e4dc <_fflush_r+0x104>
8000e3f2:	10 37       	cp.w	r7,r8
8000e3f4:	c0 31       	brne	8000e3fa <_fflush_r+0x22>
8000e3f6:	6c 07       	ld.w	r7,r6[0x0]
8000e3f8:	c0 a8       	rjmp	8000e40c <_fflush_r+0x34>
8000e3fa:	4b a8       	lddpc	r8,8000e4e0 <_fflush_r+0x108>
8000e3fc:	10 37       	cp.w	r7,r8
8000e3fe:	c0 31       	brne	8000e404 <_fflush_r+0x2c>
8000e400:	6c 17       	ld.w	r7,r6[0x4]
8000e402:	c0 58       	rjmp	8000e40c <_fflush_r+0x34>
8000e404:	4b 88       	lddpc	r8,8000e4e4 <_fflush_r+0x10c>
8000e406:	10 37       	cp.w	r7,r8
8000e408:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e40c:	8e 6a       	ld.sh	r10,r7[0xc]
8000e40e:	14 98       	mov	r8,r10
8000e410:	ed ba 00 03 	bld	r10,0x3
8000e414:	c4 20       	breq	8000e498 <_fflush_r+0xc0>
8000e416:	ab ba       	sbr	r10,0xb
8000e418:	ae 6a       	st.h	r7[0xc],r10
8000e41a:	6e 18       	ld.w	r8,r7[0x4]
8000e41c:	58 08       	cp.w	r8,0
8000e41e:	e0 89 00 06 	brgt	8000e42a <_fflush_r+0x52>
8000e422:	6f 08       	ld.w	r8,r7[0x40]
8000e424:	58 08       	cp.w	r8,0
8000e426:	e0 8a 00 5a 	brle	8000e4da <_fflush_r+0x102>
8000e42a:	6e b8       	ld.w	r8,r7[0x2c]
8000e42c:	58 08       	cp.w	r8,0
8000e42e:	c5 60       	breq	8000e4da <_fflush_r+0x102>
8000e430:	e2 1a 10 00 	andl	r10,0x1000,COH
8000e434:	c0 30       	breq	8000e43a <_fflush_r+0x62>
8000e436:	6f 55       	ld.w	r5,r7[0x54]
8000e438:	c0 f8       	rjmp	8000e456 <_fflush_r+0x7e>
8000e43a:	30 19       	mov	r9,1
8000e43c:	6e 8b       	ld.w	r11,r7[0x20]
8000e43e:	0c 9c       	mov	r12,r6
8000e440:	5d 18       	icall	r8
8000e442:	18 95       	mov	r5,r12
8000e444:	5b fc       	cp.w	r12,-1
8000e446:	c0 81       	brne	8000e456 <_fflush_r+0x7e>
8000e448:	6c 38       	ld.w	r8,r6[0xc]
8000e44a:	59 d8       	cp.w	r8,29
8000e44c:	c4 70       	breq	8000e4da <_fflush_r+0x102>
8000e44e:	8e 68       	ld.sh	r8,r7[0xc]
8000e450:	a7 a8       	sbr	r8,0x6
8000e452:	ae 68       	st.h	r7[0xc],r8
8000e454:	d8 22       	popm	r4-r7,pc
8000e456:	8e 68       	ld.sh	r8,r7[0xc]
8000e458:	ed b8 00 02 	bld	r8,0x2
8000e45c:	c0 91       	brne	8000e46e <_fflush_r+0x96>
8000e45e:	6e 18       	ld.w	r8,r7[0x4]
8000e460:	10 15       	sub	r5,r8
8000e462:	6e d8       	ld.w	r8,r7[0x34]
8000e464:	58 08       	cp.w	r8,0
8000e466:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e46a:	eb d8 e1 15 	subne	r5,r5,r8
8000e46e:	6e b8       	ld.w	r8,r7[0x2c]
8000e470:	0c 9c       	mov	r12,r6
8000e472:	30 09       	mov	r9,0
8000e474:	0a 9a       	mov	r10,r5
8000e476:	6e 8b       	ld.w	r11,r7[0x20]
8000e478:	5d 18       	icall	r8
8000e47a:	8e 68       	ld.sh	r8,r7[0xc]
8000e47c:	0a 3c       	cp.w	r12,r5
8000e47e:	c2 61       	brne	8000e4ca <_fflush_r+0xf2>
8000e480:	ab d8       	cbr	r8,0xb
8000e482:	30 0c       	mov	r12,0
8000e484:	6e 49       	ld.w	r9,r7[0x10]
8000e486:	ae 68       	st.h	r7[0xc],r8
8000e488:	8f 1c       	st.w	r7[0x4],r12
8000e48a:	8f 09       	st.w	r7[0x0],r9
8000e48c:	ed b8 00 0c 	bld	r8,0xc
8000e490:	c2 51       	brne	8000e4da <_fflush_r+0x102>
8000e492:	ef 45 00 54 	st.w	r7[84],r5
8000e496:	d8 22       	popm	r4-r7,pc
8000e498:	6e 45       	ld.w	r5,r7[0x10]
8000e49a:	58 05       	cp.w	r5,0
8000e49c:	c1 f0       	breq	8000e4da <_fflush_r+0x102>
8000e49e:	6e 04       	ld.w	r4,r7[0x0]
8000e4a0:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e4a4:	8f 05       	st.w	r7[0x0],r5
8000e4a6:	f9 b8 01 00 	movne	r8,0
8000e4aa:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e4ae:	0a 14       	sub	r4,r5
8000e4b0:	8f 28       	st.w	r7[0x8],r8
8000e4b2:	c1 18       	rjmp	8000e4d4 <_fflush_r+0xfc>
8000e4b4:	08 99       	mov	r9,r4
8000e4b6:	0a 9a       	mov	r10,r5
8000e4b8:	6e a8       	ld.w	r8,r7[0x28]
8000e4ba:	6e 8b       	ld.w	r11,r7[0x20]
8000e4bc:	0c 9c       	mov	r12,r6
8000e4be:	5d 18       	icall	r8
8000e4c0:	18 14       	sub	r4,r12
8000e4c2:	58 0c       	cp.w	r12,0
8000e4c4:	e0 89 00 07 	brgt	8000e4d2 <_fflush_r+0xfa>
8000e4c8:	8e 68       	ld.sh	r8,r7[0xc]
8000e4ca:	a7 a8       	sbr	r8,0x6
8000e4cc:	3f fc       	mov	r12,-1
8000e4ce:	ae 68       	st.h	r7[0xc],r8
8000e4d0:	d8 22       	popm	r4-r7,pc
8000e4d2:	18 05       	add	r5,r12
8000e4d4:	58 04       	cp.w	r4,0
8000e4d6:	fe 99 ff ef 	brgt	8000e4b4 <_fflush_r+0xdc>
8000e4da:	d8 2a       	popm	r4-r7,pc,r12=0
8000e4dc:	80 01       	ld.sh	r1,r0[0x0]
8000e4de:	a0 a8       	st.b	r0[0x2],r8
8000e4e0:	80 01       	ld.sh	r1,r0[0x0]
8000e4e2:	a0 c8       	st.b	r0[0x4],r8
8000e4e4:	80 01       	ld.sh	r1,r0[0x0]
8000e4e6:	a0 e8       	st.b	r0[0x6],r8

8000e4e8 <__sfp_lock_acquire>:
8000e4e8:	5e fc       	retal	r12

8000e4ea <__sfp_lock_release>:
8000e4ea:	5e fc       	retal	r12

8000e4ec <_cleanup_r>:
8000e4ec:	d4 01       	pushm	lr
8000e4ee:	fe cb f0 ba 	sub	r11,pc,-3910
8000e4f2:	e0 a0 02 f9 	rcall	8000eae4 <_fwalk>
8000e4f6:	d8 02       	popm	pc

8000e4f8 <__sfmoreglue>:
8000e4f8:	d4 21       	pushm	r4-r7,lr
8000e4fa:	16 95       	mov	r5,r11
8000e4fc:	f6 06 10 5c 	mul	r6,r11,92
8000e500:	ec cb ff f4 	sub	r11,r6,-12
8000e504:	fe b0 e1 d2 	rcall	8000a8a8 <_malloc_r>
8000e508:	18 97       	mov	r7,r12
8000e50a:	c0 90       	breq	8000e51c <__sfmoreglue+0x24>
8000e50c:	99 15       	st.w	r12[0x4],r5
8000e50e:	30 0b       	mov	r11,0
8000e510:	2f 4c       	sub	r12,-12
8000e512:	0c 9a       	mov	r10,r6
8000e514:	8f 2c       	st.w	r7[0x8],r12
8000e516:	8f 0b       	st.w	r7[0x0],r11
8000e518:	fe b0 e4 9b 	rcall	8000ae4e <memset>
8000e51c:	0e 9c       	mov	r12,r7
8000e51e:	d8 22       	popm	r4-r7,pc

8000e520 <__sfp>:
8000e520:	d4 21       	pushm	r4-r7,lr
8000e522:	49 b8       	lddpc	r8,8000e58c <__sfp+0x6c>
8000e524:	18 96       	mov	r6,r12
8000e526:	70 07       	ld.w	r7,r8[0x0]
8000e528:	6e 68       	ld.w	r8,r7[0x18]
8000e52a:	58 08       	cp.w	r8,0
8000e52c:	c0 31       	brne	8000e532 <__sfp+0x12>
8000e52e:	0e 9c       	mov	r12,r7
8000e530:	c3 0c       	rcall	8000e590 <__sinit>
8000e532:	ee c7 ff 28 	sub	r7,r7,-216
8000e536:	30 05       	mov	r5,0
8000e538:	6e 2c       	ld.w	r12,r7[0x8]
8000e53a:	6e 18       	ld.w	r8,r7[0x4]
8000e53c:	c0 68       	rjmp	8000e548 <__sfp+0x28>
8000e53e:	98 69       	ld.sh	r9,r12[0xc]
8000e540:	ea 09 19 00 	cp.h	r9,r5
8000e544:	c1 10       	breq	8000e566 <__sfp+0x46>
8000e546:	2a 4c       	sub	r12,-92
8000e548:	20 18       	sub	r8,1
8000e54a:	cf a7       	brpl	8000e53e <__sfp+0x1e>
8000e54c:	6e 08       	ld.w	r8,r7[0x0]
8000e54e:	58 08       	cp.w	r8,0
8000e550:	c0 61       	brne	8000e55c <__sfp+0x3c>
8000e552:	30 4b       	mov	r11,4
8000e554:	0c 9c       	mov	r12,r6
8000e556:	cd 1f       	rcall	8000e4f8 <__sfmoreglue>
8000e558:	8f 0c       	st.w	r7[0x0],r12
8000e55a:	c0 30       	breq	8000e560 <__sfp+0x40>
8000e55c:	6e 07       	ld.w	r7,r7[0x0]
8000e55e:	ce db       	rjmp	8000e538 <__sfp+0x18>
8000e560:	30 c8       	mov	r8,12
8000e562:	8d 38       	st.w	r6[0xc],r8
8000e564:	d8 22       	popm	r4-r7,pc
8000e566:	30 08       	mov	r8,0
8000e568:	f9 48 00 4c 	st.w	r12[76],r8
8000e56c:	99 08       	st.w	r12[0x0],r8
8000e56e:	99 28       	st.w	r12[0x8],r8
8000e570:	99 18       	st.w	r12[0x4],r8
8000e572:	99 48       	st.w	r12[0x10],r8
8000e574:	99 58       	st.w	r12[0x14],r8
8000e576:	99 68       	st.w	r12[0x18],r8
8000e578:	99 d8       	st.w	r12[0x34],r8
8000e57a:	99 e8       	st.w	r12[0x38],r8
8000e57c:	f9 48 00 48 	st.w	r12[72],r8
8000e580:	3f f8       	mov	r8,-1
8000e582:	b8 78       	st.h	r12[0xe],r8
8000e584:	30 18       	mov	r8,1
8000e586:	b8 68       	st.h	r12[0xc],r8
8000e588:	d8 22       	popm	r4-r7,pc
8000e58a:	d7 03       	nop
8000e58c:	80 01       	ld.sh	r1,r0[0x0]
8000e58e:	a1 0c       	ld.d	r12,r0

8000e590 <__sinit>:
8000e590:	d4 21       	pushm	r4-r7,lr
8000e592:	18 96       	mov	r6,r12
8000e594:	78 67       	ld.w	r7,r12[0x18]
8000e596:	58 07       	cp.w	r7,0
8000e598:	c4 91       	brne	8000e62a <__sinit+0x9a>
8000e59a:	fe c8 00 ae 	sub	r8,pc,174
8000e59e:	30 15       	mov	r5,1
8000e5a0:	99 a8       	st.w	r12[0x28],r8
8000e5a2:	f9 47 00 d8 	st.w	r12[216],r7
8000e5a6:	f9 47 00 dc 	st.w	r12[220],r7
8000e5aa:	f9 47 00 e0 	st.w	r12[224],r7
8000e5ae:	99 65       	st.w	r12[0x18],r5
8000e5b0:	cb 8f       	rcall	8000e520 <__sfp>
8000e5b2:	8d 0c       	st.w	r6[0x0],r12
8000e5b4:	0c 9c       	mov	r12,r6
8000e5b6:	cb 5f       	rcall	8000e520 <__sfp>
8000e5b8:	8d 1c       	st.w	r6[0x4],r12
8000e5ba:	0c 9c       	mov	r12,r6
8000e5bc:	cb 2f       	rcall	8000e520 <__sfp>
8000e5be:	6c 09       	ld.w	r9,r6[0x0]
8000e5c0:	30 48       	mov	r8,4
8000e5c2:	93 07       	st.w	r9[0x0],r7
8000e5c4:	b2 68       	st.h	r9[0xc],r8
8000e5c6:	93 17       	st.w	r9[0x4],r7
8000e5c8:	93 27       	st.w	r9[0x8],r7
8000e5ca:	6c 18       	ld.w	r8,r6[0x4]
8000e5cc:	b2 77       	st.h	r9[0xe],r7
8000e5ce:	93 47       	st.w	r9[0x10],r7
8000e5d0:	93 57       	st.w	r9[0x14],r7
8000e5d2:	93 67       	st.w	r9[0x18],r7
8000e5d4:	93 89       	st.w	r9[0x20],r9
8000e5d6:	91 07       	st.w	r8[0x0],r7
8000e5d8:	91 17       	st.w	r8[0x4],r7
8000e5da:	91 27       	st.w	r8[0x8],r7
8000e5dc:	fe ce f3 20 	sub	lr,pc,-3296
8000e5e0:	fe cb f3 50 	sub	r11,pc,-3248
8000e5e4:	93 9e       	st.w	r9[0x24],lr
8000e5e6:	93 ab       	st.w	r9[0x28],r11
8000e5e8:	fe ca f3 78 	sub	r10,pc,-3208
8000e5ec:	fe c4 f3 84 	sub	r4,pc,-3196
8000e5f0:	93 ba       	st.w	r9[0x2c],r10
8000e5f2:	93 c4       	st.w	r9[0x30],r4
8000e5f4:	30 99       	mov	r9,9
8000e5f6:	b0 69       	st.h	r8[0xc],r9
8000e5f8:	b0 75       	st.h	r8[0xe],r5
8000e5fa:	91 c4       	st.w	r8[0x30],r4
8000e5fc:	91 47       	st.w	r8[0x10],r7
8000e5fe:	91 57       	st.w	r8[0x14],r7
8000e600:	91 67       	st.w	r8[0x18],r7
8000e602:	91 88       	st.w	r8[0x20],r8
8000e604:	91 9e       	st.w	r8[0x24],lr
8000e606:	91 ab       	st.w	r8[0x28],r11
8000e608:	91 ba       	st.w	r8[0x2c],r10
8000e60a:	8d 2c       	st.w	r6[0x8],r12
8000e60c:	31 28       	mov	r8,18
8000e60e:	99 07       	st.w	r12[0x0],r7
8000e610:	b8 68       	st.h	r12[0xc],r8
8000e612:	99 17       	st.w	r12[0x4],r7
8000e614:	99 27       	st.w	r12[0x8],r7
8000e616:	30 28       	mov	r8,2
8000e618:	b8 78       	st.h	r12[0xe],r8
8000e61a:	99 c4       	st.w	r12[0x30],r4
8000e61c:	99 67       	st.w	r12[0x18],r7
8000e61e:	99 9e       	st.w	r12[0x24],lr
8000e620:	99 ab       	st.w	r12[0x28],r11
8000e622:	99 ba       	st.w	r12[0x2c],r10
8000e624:	99 47       	st.w	r12[0x10],r7
8000e626:	99 57       	st.w	r12[0x14],r7
8000e628:	99 8c       	st.w	r12[0x20],r12
8000e62a:	d8 22       	popm	r4-r7,pc

8000e62c <_malloc_trim_r>:
8000e62c:	d4 21       	pushm	r4-r7,lr
8000e62e:	16 95       	mov	r5,r11
8000e630:	18 97       	mov	r7,r12
8000e632:	fe b0 d6 87 	rcall	80009340 <__malloc_lock>
8000e636:	e0 64 05 38 	mov	r4,1336
8000e63a:	68 28       	ld.w	r8,r4[0x8]
8000e63c:	70 16       	ld.w	r6,r8[0x4]
8000e63e:	e0 16 ff fc 	andl	r6,0xfffc
8000e642:	ec c8 ff 91 	sub	r8,r6,-111
8000e646:	f0 05 01 05 	sub	r5,r8,r5
8000e64a:	e0 15 ff 80 	andl	r5,0xff80
8000e64e:	ea c5 00 80 	sub	r5,r5,128
8000e652:	e0 45 00 7f 	cp.w	r5,127
8000e656:	e0 8a 00 25 	brle	8000e6a0 <_malloc_trim_r+0x74>
8000e65a:	30 0b       	mov	r11,0
8000e65c:	0e 9c       	mov	r12,r7
8000e65e:	fe b0 e5 5f 	rcall	8000b11c <_sbrk_r>
8000e662:	68 28       	ld.w	r8,r4[0x8]
8000e664:	0c 08       	add	r8,r6
8000e666:	10 3c       	cp.w	r12,r8
8000e668:	c1 c1       	brne	8000e6a0 <_malloc_trim_r+0x74>
8000e66a:	ea 0b 11 00 	rsub	r11,r5,0
8000e66e:	0e 9c       	mov	r12,r7
8000e670:	fe b0 e5 56 	rcall	8000b11c <_sbrk_r>
8000e674:	5b fc       	cp.w	r12,-1
8000e676:	c1 91       	brne	8000e6a8 <_malloc_trim_r+0x7c>
8000e678:	30 0b       	mov	r11,0
8000e67a:	0e 9c       	mov	r12,r7
8000e67c:	fe b0 e5 50 	rcall	8000b11c <_sbrk_r>
8000e680:	68 28       	ld.w	r8,r4[0x8]
8000e682:	f8 08 01 09 	sub	r9,r12,r8
8000e686:	58 f9       	cp.w	r9,15
8000e688:	e0 8a 00 0c 	brle	8000e6a0 <_malloc_trim_r+0x74>
8000e68c:	a1 a9       	sbr	r9,0x0
8000e68e:	91 19       	st.w	r8[0x4],r9
8000e690:	e0 68 09 44 	mov	r8,2372
8000e694:	70 09       	ld.w	r9,r8[0x0]
8000e696:	e0 68 13 34 	mov	r8,4916
8000e69a:	f8 09 01 09 	sub	r9,r12,r9
8000e69e:	91 09       	st.w	r8[0x0],r9
8000e6a0:	0e 9c       	mov	r12,r7
8000e6a2:	fe b0 d6 55 	rcall	8000934c <__malloc_unlock>
8000e6a6:	d8 2a       	popm	r4-r7,pc,r12=0
8000e6a8:	68 28       	ld.w	r8,r4[0x8]
8000e6aa:	0a 16       	sub	r6,r5
8000e6ac:	a1 a6       	sbr	r6,0x0
8000e6ae:	91 16       	st.w	r8[0x4],r6
8000e6b0:	e0 68 13 34 	mov	r8,4916
8000e6b4:	70 09       	ld.w	r9,r8[0x0]
8000e6b6:	0a 19       	sub	r9,r5
8000e6b8:	0e 9c       	mov	r12,r7
8000e6ba:	91 09       	st.w	r8[0x0],r9
8000e6bc:	fe b0 d6 48 	rcall	8000934c <__malloc_unlock>
8000e6c0:	da 2a       	popm	r4-r7,pc,r12=1
8000e6c2:	d7 03       	nop

8000e6c4 <_free_r>:
8000e6c4:	d4 21       	pushm	r4-r7,lr
8000e6c6:	16 96       	mov	r6,r11
8000e6c8:	18 97       	mov	r7,r12
8000e6ca:	58 0b       	cp.w	r11,0
8000e6cc:	e0 80 00 c0 	breq	8000e84c <_free_r+0x188>
8000e6d0:	fe b0 d6 38 	rcall	80009340 <__malloc_lock>
8000e6d4:	20 86       	sub	r6,8
8000e6d6:	e0 6a 05 38 	mov	r10,1336
8000e6da:	6c 18       	ld.w	r8,r6[0x4]
8000e6dc:	74 2e       	ld.w	lr,r10[0x8]
8000e6de:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e6e2:	a1 c8       	cbr	r8,0x0
8000e6e4:	ec 08 00 09 	add	r9,r6,r8
8000e6e8:	72 1b       	ld.w	r11,r9[0x4]
8000e6ea:	e0 1b ff fc 	andl	r11,0xfffc
8000e6ee:	1c 39       	cp.w	r9,lr
8000e6f0:	c1 e1       	brne	8000e72c <_free_r+0x68>
8000e6f2:	f6 08 00 08 	add	r8,r11,r8
8000e6f6:	58 0c       	cp.w	r12,0
8000e6f8:	c0 81       	brne	8000e708 <_free_r+0x44>
8000e6fa:	6c 09       	ld.w	r9,r6[0x0]
8000e6fc:	12 16       	sub	r6,r9
8000e6fe:	12 08       	add	r8,r9
8000e700:	6c 3b       	ld.w	r11,r6[0xc]
8000e702:	6c 29       	ld.w	r9,r6[0x8]
8000e704:	97 29       	st.w	r11[0x8],r9
8000e706:	93 3b       	st.w	r9[0xc],r11
8000e708:	10 99       	mov	r9,r8
8000e70a:	95 26       	st.w	r10[0x8],r6
8000e70c:	a1 a9       	sbr	r9,0x0
8000e70e:	8d 19       	st.w	r6[0x4],r9
8000e710:	e0 69 09 40 	mov	r9,2368
8000e714:	72 09       	ld.w	r9,r9[0x0]
8000e716:	12 38       	cp.w	r8,r9
8000e718:	c0 63       	brcs	8000e724 <_free_r+0x60>
8000e71a:	e0 68 13 30 	mov	r8,4912
8000e71e:	0e 9c       	mov	r12,r7
8000e720:	70 0b       	ld.w	r11,r8[0x0]
8000e722:	c8 5f       	rcall	8000e62c <_malloc_trim_r>
8000e724:	0e 9c       	mov	r12,r7
8000e726:	fe b0 d6 13 	rcall	8000934c <__malloc_unlock>
8000e72a:	d8 22       	popm	r4-r7,pc
8000e72c:	93 1b       	st.w	r9[0x4],r11
8000e72e:	58 0c       	cp.w	r12,0
8000e730:	c0 30       	breq	8000e736 <_free_r+0x72>
8000e732:	30 0c       	mov	r12,0
8000e734:	c1 08       	rjmp	8000e754 <_free_r+0x90>
8000e736:	6c 0e       	ld.w	lr,r6[0x0]
8000e738:	f4 c5 ff f8 	sub	r5,r10,-8
8000e73c:	1c 16       	sub	r6,lr
8000e73e:	1c 08       	add	r8,lr
8000e740:	6c 2e       	ld.w	lr,r6[0x8]
8000e742:	0a 3e       	cp.w	lr,r5
8000e744:	f9 bc 00 01 	moveq	r12,1
8000e748:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e74c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e750:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e754:	f2 0b 00 0e 	add	lr,r9,r11
8000e758:	7c 1e       	ld.w	lr,lr[0x4]
8000e75a:	ed be 00 00 	bld	lr,0x0
8000e75e:	c1 40       	breq	8000e786 <_free_r+0xc2>
8000e760:	16 08       	add	r8,r11
8000e762:	58 0c       	cp.w	r12,0
8000e764:	c0 d1       	brne	8000e77e <_free_r+0xba>
8000e766:	e0 6e 05 38 	mov	lr,1336
8000e76a:	72 2b       	ld.w	r11,r9[0x8]
8000e76c:	2f 8e       	sub	lr,-8
8000e76e:	1c 3b       	cp.w	r11,lr
8000e770:	c0 71       	brne	8000e77e <_free_r+0xba>
8000e772:	97 36       	st.w	r11[0xc],r6
8000e774:	97 26       	st.w	r11[0x8],r6
8000e776:	8d 2b       	st.w	r6[0x8],r11
8000e778:	8d 3b       	st.w	r6[0xc],r11
8000e77a:	30 1c       	mov	r12,1
8000e77c:	c0 58       	rjmp	8000e786 <_free_r+0xc2>
8000e77e:	72 2b       	ld.w	r11,r9[0x8]
8000e780:	72 39       	ld.w	r9,r9[0xc]
8000e782:	93 2b       	st.w	r9[0x8],r11
8000e784:	97 39       	st.w	r11[0xc],r9
8000e786:	10 99       	mov	r9,r8
8000e788:	ec 08 09 08 	st.w	r6[r8],r8
8000e78c:	a1 a9       	sbr	r9,0x0
8000e78e:	8d 19       	st.w	r6[0x4],r9
8000e790:	58 0c       	cp.w	r12,0
8000e792:	c5 a1       	brne	8000e846 <_free_r+0x182>
8000e794:	e0 48 01 ff 	cp.w	r8,511
8000e798:	e0 8b 00 13 	brhi	8000e7be <_free_r+0xfa>
8000e79c:	a3 98       	lsr	r8,0x3
8000e79e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e7a2:	72 2b       	ld.w	r11,r9[0x8]
8000e7a4:	8d 39       	st.w	r6[0xc],r9
8000e7a6:	8d 2b       	st.w	r6[0x8],r11
8000e7a8:	97 36       	st.w	r11[0xc],r6
8000e7aa:	93 26       	st.w	r9[0x8],r6
8000e7ac:	a3 48       	asr	r8,0x2
8000e7ae:	74 19       	ld.w	r9,r10[0x4]
8000e7b0:	30 1b       	mov	r11,1
8000e7b2:	f6 08 09 48 	lsl	r8,r11,r8
8000e7b6:	f3 e8 10 08 	or	r8,r9,r8
8000e7ba:	95 18       	st.w	r10[0x4],r8
8000e7bc:	c4 58       	rjmp	8000e846 <_free_r+0x182>
8000e7be:	f0 0b 16 09 	lsr	r11,r8,0x9
8000e7c2:	58 4b       	cp.w	r11,4
8000e7c4:	e0 8b 00 06 	brhi	8000e7d0 <_free_r+0x10c>
8000e7c8:	f0 0b 16 06 	lsr	r11,r8,0x6
8000e7cc:	2c 8b       	sub	r11,-56
8000e7ce:	c2 08       	rjmp	8000e80e <_free_r+0x14a>
8000e7d0:	59 4b       	cp.w	r11,20
8000e7d2:	e0 8b 00 04 	brhi	8000e7da <_free_r+0x116>
8000e7d6:	2a 5b       	sub	r11,-91
8000e7d8:	c1 b8       	rjmp	8000e80e <_free_r+0x14a>
8000e7da:	e0 4b 00 54 	cp.w	r11,84
8000e7de:	e0 8b 00 06 	brhi	8000e7ea <_free_r+0x126>
8000e7e2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000e7e6:	29 2b       	sub	r11,-110
8000e7e8:	c1 38       	rjmp	8000e80e <_free_r+0x14a>
8000e7ea:	e0 4b 01 54 	cp.w	r11,340
8000e7ee:	e0 8b 00 06 	brhi	8000e7fa <_free_r+0x136>
8000e7f2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000e7f6:	28 9b       	sub	r11,-119
8000e7f8:	c0 b8       	rjmp	8000e80e <_free_r+0x14a>
8000e7fa:	e0 4b 05 54 	cp.w	r11,1364
8000e7fe:	e0 88 00 05 	brls	8000e808 <_free_r+0x144>
8000e802:	37 eb       	mov	r11,126
8000e804:	c0 58       	rjmp	8000e80e <_free_r+0x14a>
8000e806:	d7 03       	nop
8000e808:	f0 0b 16 12 	lsr	r11,r8,0x12
8000e80c:	28 4b       	sub	r11,-124
8000e80e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000e812:	78 29       	ld.w	r9,r12[0x8]
8000e814:	18 39       	cp.w	r9,r12
8000e816:	c0 e1       	brne	8000e832 <_free_r+0x16e>
8000e818:	74 18       	ld.w	r8,r10[0x4]
8000e81a:	a3 4b       	asr	r11,0x2
8000e81c:	30 1c       	mov	r12,1
8000e81e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000e822:	f1 eb 10 0b 	or	r11,r8,r11
8000e826:	12 98       	mov	r8,r9
8000e828:	95 1b       	st.w	r10[0x4],r11
8000e82a:	c0 a8       	rjmp	8000e83e <_free_r+0x17a>
8000e82c:	72 29       	ld.w	r9,r9[0x8]
8000e82e:	18 39       	cp.w	r9,r12
8000e830:	c0 60       	breq	8000e83c <_free_r+0x178>
8000e832:	72 1a       	ld.w	r10,r9[0x4]
8000e834:	e0 1a ff fc 	andl	r10,0xfffc
8000e838:	14 38       	cp.w	r8,r10
8000e83a:	cf 93       	brcs	8000e82c <_free_r+0x168>
8000e83c:	72 38       	ld.w	r8,r9[0xc]
8000e83e:	8d 38       	st.w	r6[0xc],r8
8000e840:	8d 29       	st.w	r6[0x8],r9
8000e842:	93 36       	st.w	r9[0xc],r6
8000e844:	91 26       	st.w	r8[0x8],r6
8000e846:	0e 9c       	mov	r12,r7
8000e848:	fe b0 d5 82 	rcall	8000934c <__malloc_unlock>
8000e84c:	d8 22       	popm	r4-r7,pc
8000e84e:	d7 03       	nop

8000e850 <__sfvwrite_r>:
8000e850:	d4 31       	pushm	r0-r7,lr
8000e852:	20 3d       	sub	sp,12
8000e854:	14 94       	mov	r4,r10
8000e856:	18 95       	mov	r5,r12
8000e858:	16 97       	mov	r7,r11
8000e85a:	74 28       	ld.w	r8,r10[0x8]
8000e85c:	58 08       	cp.w	r8,0
8000e85e:	e0 80 01 40 	breq	8000eade <__sfvwrite_r+0x28e>
8000e862:	96 68       	ld.sh	r8,r11[0xc]
8000e864:	ed b8 00 03 	bld	r8,0x3
8000e868:	c0 41       	brne	8000e870 <__sfvwrite_r+0x20>
8000e86a:	76 48       	ld.w	r8,r11[0x10]
8000e86c:	58 08       	cp.w	r8,0
8000e86e:	c0 c1       	brne	8000e886 <__sfvwrite_r+0x36>
8000e870:	0e 9b       	mov	r11,r7
8000e872:	0a 9c       	mov	r12,r5
8000e874:	fe b0 f6 bc 	rcall	8000d5ec <__swsetup_r>
8000e878:	c0 70       	breq	8000e886 <__sfvwrite_r+0x36>
8000e87a:	8e 68       	ld.sh	r8,r7[0xc]
8000e87c:	a7 a8       	sbr	r8,0x6
8000e87e:	ae 68       	st.h	r7[0xc],r8
8000e880:	30 98       	mov	r8,9
8000e882:	8b 38       	st.w	r5[0xc],r8
8000e884:	c2 b9       	rjmp	8000eada <__sfvwrite_r+0x28a>
8000e886:	8e 63       	ld.sh	r3,r7[0xc]
8000e888:	68 00       	ld.w	r0,r4[0x0]
8000e88a:	06 96       	mov	r6,r3
8000e88c:	e2 16 00 02 	andl	r6,0x2,COH
8000e890:	c2 10       	breq	8000e8d2 <__sfvwrite_r+0x82>
8000e892:	30 03       	mov	r3,0
8000e894:	e0 62 04 00 	mov	r2,1024
8000e898:	06 96       	mov	r6,r3
8000e89a:	c0 48       	rjmp	8000e8a2 <__sfvwrite_r+0x52>
8000e89c:	60 03       	ld.w	r3,r0[0x0]
8000e89e:	60 16       	ld.w	r6,r0[0x4]
8000e8a0:	2f 80       	sub	r0,-8
8000e8a2:	58 06       	cp.w	r6,0
8000e8a4:	cf c0       	breq	8000e89c <__sfvwrite_r+0x4c>
8000e8a6:	e0 46 04 00 	cp.w	r6,1024
8000e8aa:	ec 09 17 80 	movls	r9,r6
8000e8ae:	e4 09 17 b0 	movhi	r9,r2
8000e8b2:	06 9a       	mov	r10,r3
8000e8b4:	6e a8       	ld.w	r8,r7[0x28]
8000e8b6:	6e 8b       	ld.w	r11,r7[0x20]
8000e8b8:	0a 9c       	mov	r12,r5
8000e8ba:	5d 18       	icall	r8
8000e8bc:	18 16       	sub	r6,r12
8000e8be:	58 0c       	cp.w	r12,0
8000e8c0:	e0 8a 01 0a 	brle	8000ead4 <__sfvwrite_r+0x284>
8000e8c4:	68 28       	ld.w	r8,r4[0x8]
8000e8c6:	18 18       	sub	r8,r12
8000e8c8:	89 28       	st.w	r4[0x8],r8
8000e8ca:	e0 80 01 0a 	breq	8000eade <__sfvwrite_r+0x28e>
8000e8ce:	18 03       	add	r3,r12
8000e8d0:	ce 9b       	rjmp	8000e8a2 <__sfvwrite_r+0x52>
8000e8d2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e8d6:	c0 70       	breq	8000e8e4 <__sfvwrite_r+0x94>
8000e8d8:	50 06       	stdsp	sp[0x0],r6
8000e8da:	0c 93       	mov	r3,r6
8000e8dc:	0c 91       	mov	r1,r6
8000e8de:	50 15       	stdsp	sp[0x4],r5
8000e8e0:	08 92       	mov	r2,r4
8000e8e2:	c9 c8       	rjmp	8000ea1a <__sfvwrite_r+0x1ca>
8000e8e4:	06 96       	mov	r6,r3
8000e8e6:	08 91       	mov	r1,r4
8000e8e8:	c0 48       	rjmp	8000e8f0 <__sfvwrite_r+0xa0>
8000e8ea:	60 03       	ld.w	r3,r0[0x0]
8000e8ec:	60 16       	ld.w	r6,r0[0x4]
8000e8ee:	2f 80       	sub	r0,-8
8000e8f0:	58 06       	cp.w	r6,0
8000e8f2:	cf c0       	breq	8000e8ea <__sfvwrite_r+0x9a>
8000e8f4:	8e 68       	ld.sh	r8,r7[0xc]
8000e8f6:	6e 24       	ld.w	r4,r7[0x8]
8000e8f8:	10 99       	mov	r9,r8
8000e8fa:	e2 19 02 00 	andl	r9,0x200,COH
8000e8fe:	c5 50       	breq	8000e9a8 <__sfvwrite_r+0x158>
8000e900:	08 36       	cp.w	r6,r4
8000e902:	c4 43       	brcs	8000e98a <__sfvwrite_r+0x13a>
8000e904:	10 99       	mov	r9,r8
8000e906:	e2 19 04 80 	andl	r9,0x480,COH
8000e90a:	c4 00       	breq	8000e98a <__sfvwrite_r+0x13a>
8000e90c:	6e 4b       	ld.w	r11,r7[0x10]
8000e90e:	6e 09       	ld.w	r9,r7[0x0]
8000e910:	16 19       	sub	r9,r11
8000e912:	50 09       	stdsp	sp[0x0],r9
8000e914:	6e 59       	ld.w	r9,r7[0x14]
8000e916:	10 9c       	mov	r12,r8
8000e918:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e91c:	30 28       	mov	r8,2
8000e91e:	f4 08 0c 08 	divs	r8,r10,r8
8000e922:	fa e9 00 04 	st.d	sp[4],r8
8000e926:	10 94       	mov	r4,r8
8000e928:	40 09       	lddsp	r9,sp[0x0]
8000e92a:	e2 1c 04 00 	andl	r12,0x400,COH
8000e92e:	2f f9       	sub	r9,-1
8000e930:	0c 09       	add	r9,r6
8000e932:	12 38       	cp.w	r8,r9
8000e934:	f2 04 17 30 	movlo	r4,r9
8000e938:	58 0c       	cp.w	r12,0
8000e93a:	c1 10       	breq	8000e95c <__sfvwrite_r+0x10c>
8000e93c:	08 9b       	mov	r11,r4
8000e93e:	0a 9c       	mov	r12,r5
8000e940:	fe b0 df b4 	rcall	8000a8a8 <_malloc_r>
8000e944:	18 92       	mov	r2,r12
8000e946:	c1 40       	breq	8000e96e <__sfvwrite_r+0x11e>
8000e948:	40 0a       	lddsp	r10,sp[0x0]
8000e94a:	6e 4b       	ld.w	r11,r7[0x10]
8000e94c:	fe b0 e1 dd 	rcall	8000ad06 <memcpy>
8000e950:	8e 68       	ld.sh	r8,r7[0xc]
8000e952:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e956:	a7 b8       	sbr	r8,0x7
8000e958:	ae 68       	st.h	r7[0xc],r8
8000e95a:	c0 d8       	rjmp	8000e974 <__sfvwrite_r+0x124>
8000e95c:	08 9a       	mov	r10,r4
8000e95e:	0a 9c       	mov	r12,r5
8000e960:	fe b0 e2 7e 	rcall	8000ae5c <_realloc_r>
8000e964:	18 92       	mov	r2,r12
8000e966:	c0 71       	brne	8000e974 <__sfvwrite_r+0x124>
8000e968:	6e 4b       	ld.w	r11,r7[0x10]
8000e96a:	0a 9c       	mov	r12,r5
8000e96c:	ca ce       	rcall	8000e6c4 <_free_r>
8000e96e:	30 c8       	mov	r8,12
8000e970:	8b 38       	st.w	r5[0xc],r8
8000e972:	cb 18       	rjmp	8000ead4 <__sfvwrite_r+0x284>
8000e974:	40 0a       	lddsp	r10,sp[0x0]
8000e976:	40 09       	lddsp	r9,sp[0x0]
8000e978:	e8 0a 01 0a 	sub	r10,r4,r10
8000e97c:	e4 09 00 08 	add	r8,r2,r9
8000e980:	8f 54       	st.w	r7[0x14],r4
8000e982:	8f 2a       	st.w	r7[0x8],r10
8000e984:	8f 08       	st.w	r7[0x0],r8
8000e986:	8f 42       	st.w	r7[0x10],r2
8000e988:	0c 94       	mov	r4,r6
8000e98a:	08 36       	cp.w	r6,r4
8000e98c:	ec 04 17 30 	movlo	r4,r6
8000e990:	06 9b       	mov	r11,r3
8000e992:	08 9a       	mov	r10,r4
8000e994:	6e 0c       	ld.w	r12,r7[0x0]
8000e996:	c3 ad       	rcall	8000ec0a <memmove>
8000e998:	6e 08       	ld.w	r8,r7[0x0]
8000e99a:	08 08       	add	r8,r4
8000e99c:	8f 08       	st.w	r7[0x0],r8
8000e99e:	6e 28       	ld.w	r8,r7[0x8]
8000e9a0:	08 18       	sub	r8,r4
8000e9a2:	0c 94       	mov	r4,r6
8000e9a4:	8f 28       	st.w	r7[0x8],r8
8000e9a6:	c2 e8       	rjmp	8000ea02 <__sfvwrite_r+0x1b2>
8000e9a8:	08 36       	cp.w	r6,r4
8000e9aa:	5f ba       	srhi	r10
8000e9ac:	6e 0c       	ld.w	r12,r7[0x0]
8000e9ae:	6e 48       	ld.w	r8,r7[0x10]
8000e9b0:	10 3c       	cp.w	r12,r8
8000e9b2:	5f b8       	srhi	r8
8000e9b4:	f5 e8 00 08 	and	r8,r10,r8
8000e9b8:	f2 08 18 00 	cp.b	r8,r9
8000e9bc:	c0 d0       	breq	8000e9d6 <__sfvwrite_r+0x186>
8000e9be:	06 9b       	mov	r11,r3
8000e9c0:	08 9a       	mov	r10,r4
8000e9c2:	c2 4d       	rcall	8000ec0a <memmove>
8000e9c4:	6e 08       	ld.w	r8,r7[0x0]
8000e9c6:	08 08       	add	r8,r4
8000e9c8:	0e 9b       	mov	r11,r7
8000e9ca:	8f 08       	st.w	r7[0x0],r8
8000e9cc:	0a 9c       	mov	r12,r5
8000e9ce:	fe b0 fd 05 	rcall	8000e3d8 <_fflush_r>
8000e9d2:	c1 80       	breq	8000ea02 <__sfvwrite_r+0x1b2>
8000e9d4:	c8 08       	rjmp	8000ead4 <__sfvwrite_r+0x284>
8000e9d6:	6e 59       	ld.w	r9,r7[0x14]
8000e9d8:	12 36       	cp.w	r6,r9
8000e9da:	c0 a3       	brcs	8000e9ee <__sfvwrite_r+0x19e>
8000e9dc:	6e a8       	ld.w	r8,r7[0x28]
8000e9de:	06 9a       	mov	r10,r3
8000e9e0:	6e 8b       	ld.w	r11,r7[0x20]
8000e9e2:	0a 9c       	mov	r12,r5
8000e9e4:	5d 18       	icall	r8
8000e9e6:	18 94       	mov	r4,r12
8000e9e8:	e0 89 00 0d 	brgt	8000ea02 <__sfvwrite_r+0x1b2>
8000e9ec:	c7 48       	rjmp	8000ead4 <__sfvwrite_r+0x284>
8000e9ee:	0c 9a       	mov	r10,r6
8000e9f0:	06 9b       	mov	r11,r3
8000e9f2:	c0 cd       	rcall	8000ec0a <memmove>
8000e9f4:	6e 08       	ld.w	r8,r7[0x0]
8000e9f6:	0c 08       	add	r8,r6
8000e9f8:	0c 94       	mov	r4,r6
8000e9fa:	8f 08       	st.w	r7[0x0],r8
8000e9fc:	6e 28       	ld.w	r8,r7[0x8]
8000e9fe:	0c 18       	sub	r8,r6
8000ea00:	8f 28       	st.w	r7[0x8],r8
8000ea02:	62 28       	ld.w	r8,r1[0x8]
8000ea04:	08 18       	sub	r8,r4
8000ea06:	83 28       	st.w	r1[0x8],r8
8000ea08:	c6 b0       	breq	8000eade <__sfvwrite_r+0x28e>
8000ea0a:	08 16       	sub	r6,r4
8000ea0c:	08 03       	add	r3,r4
8000ea0e:	c7 1b       	rjmp	8000e8f0 <__sfvwrite_r+0xa0>
8000ea10:	60 03       	ld.w	r3,r0[0x0]
8000ea12:	60 11       	ld.w	r1,r0[0x4]
8000ea14:	30 08       	mov	r8,0
8000ea16:	2f 80       	sub	r0,-8
8000ea18:	50 08       	stdsp	sp[0x0],r8
8000ea1a:	58 01       	cp.w	r1,0
8000ea1c:	cf a0       	breq	8000ea10 <__sfvwrite_r+0x1c0>
8000ea1e:	40 0a       	lddsp	r10,sp[0x0]
8000ea20:	58 0a       	cp.w	r10,0
8000ea22:	c1 41       	brne	8000ea4a <__sfvwrite_r+0x1fa>
8000ea24:	e2 c6 ff ff 	sub	r6,r1,-1
8000ea28:	02 9a       	mov	r10,r1
8000ea2a:	30 ab       	mov	r11,10
8000ea2c:	06 9c       	mov	r12,r3
8000ea2e:	ce 3c       	rcall	8000ebf4 <memchr>
8000ea30:	f8 c8 ff ff 	sub	r8,r12,-1
8000ea34:	58 0c       	cp.w	r12,0
8000ea36:	f1 d3 e1 16 	subne	r6,r8,r3
8000ea3a:	f9 b9 01 01 	movne	r9,1
8000ea3e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ea42:	f9 b8 00 01 	moveq	r8,1
8000ea46:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ea4a:	02 36       	cp.w	r6,r1
8000ea4c:	ec 04 17 80 	movls	r4,r6
8000ea50:	e2 04 17 b0 	movhi	r4,r1
8000ea54:	6e 59       	ld.w	r9,r7[0x14]
8000ea56:	6e 25       	ld.w	r5,r7[0x8]
8000ea58:	f2 05 00 05 	add	r5,r9,r5
8000ea5c:	0a 34       	cp.w	r4,r5
8000ea5e:	5f 9a       	srgt	r10
8000ea60:	6e 0c       	ld.w	r12,r7[0x0]
8000ea62:	6e 48       	ld.w	r8,r7[0x10]
8000ea64:	10 3c       	cp.w	r12,r8
8000ea66:	5f b8       	srhi	r8
8000ea68:	f5 e8 00 08 	and	r8,r10,r8
8000ea6c:	30 0a       	mov	r10,0
8000ea6e:	f4 08 18 00 	cp.b	r8,r10
8000ea72:	c0 d0       	breq	8000ea8c <__sfvwrite_r+0x23c>
8000ea74:	06 9b       	mov	r11,r3
8000ea76:	0a 9a       	mov	r10,r5
8000ea78:	cc 9c       	rcall	8000ec0a <memmove>
8000ea7a:	6e 08       	ld.w	r8,r7[0x0]
8000ea7c:	0a 08       	add	r8,r5
8000ea7e:	0e 9b       	mov	r11,r7
8000ea80:	8f 08       	st.w	r7[0x0],r8
8000ea82:	40 1c       	lddsp	r12,sp[0x4]
8000ea84:	fe b0 fc aa 	rcall	8000e3d8 <_fflush_r>
8000ea88:	c1 70       	breq	8000eab6 <__sfvwrite_r+0x266>
8000ea8a:	c2 58       	rjmp	8000ead4 <__sfvwrite_r+0x284>
8000ea8c:	12 34       	cp.w	r4,r9
8000ea8e:	c0 a5       	brlt	8000eaa2 <__sfvwrite_r+0x252>
8000ea90:	6e a8       	ld.w	r8,r7[0x28]
8000ea92:	06 9a       	mov	r10,r3
8000ea94:	6e 8b       	ld.w	r11,r7[0x20]
8000ea96:	40 1c       	lddsp	r12,sp[0x4]
8000ea98:	5d 18       	icall	r8
8000ea9a:	18 95       	mov	r5,r12
8000ea9c:	e0 89 00 0d 	brgt	8000eab6 <__sfvwrite_r+0x266>
8000eaa0:	c1 a8       	rjmp	8000ead4 <__sfvwrite_r+0x284>
8000eaa2:	08 9a       	mov	r10,r4
8000eaa4:	06 9b       	mov	r11,r3
8000eaa6:	cb 2c       	rcall	8000ec0a <memmove>
8000eaa8:	6e 08       	ld.w	r8,r7[0x0]
8000eaaa:	08 08       	add	r8,r4
8000eaac:	08 95       	mov	r5,r4
8000eaae:	8f 08       	st.w	r7[0x0],r8
8000eab0:	6e 28       	ld.w	r8,r7[0x8]
8000eab2:	08 18       	sub	r8,r4
8000eab4:	8f 28       	st.w	r7[0x8],r8
8000eab6:	0a 16       	sub	r6,r5
8000eab8:	c0 71       	brne	8000eac6 <__sfvwrite_r+0x276>
8000eaba:	0e 9b       	mov	r11,r7
8000eabc:	40 1c       	lddsp	r12,sp[0x4]
8000eabe:	fe b0 fc 8d 	rcall	8000e3d8 <_fflush_r>
8000eac2:	c0 91       	brne	8000ead4 <__sfvwrite_r+0x284>
8000eac4:	50 06       	stdsp	sp[0x0],r6
8000eac6:	64 28       	ld.w	r8,r2[0x8]
8000eac8:	0a 18       	sub	r8,r5
8000eaca:	85 28       	st.w	r2[0x8],r8
8000eacc:	c0 90       	breq	8000eade <__sfvwrite_r+0x28e>
8000eace:	0a 11       	sub	r1,r5
8000ead0:	0a 03       	add	r3,r5
8000ead2:	ca 4b       	rjmp	8000ea1a <__sfvwrite_r+0x1ca>
8000ead4:	8e 68       	ld.sh	r8,r7[0xc]
8000ead6:	a7 a8       	sbr	r8,0x6
8000ead8:	ae 68       	st.h	r7[0xc],r8
8000eada:	3f fc       	mov	r12,-1
8000eadc:	c0 28       	rjmp	8000eae0 <__sfvwrite_r+0x290>
8000eade:	30 0c       	mov	r12,0
8000eae0:	2f dd       	sub	sp,-12
8000eae2:	d8 32       	popm	r0-r7,pc

8000eae4 <_fwalk>:
8000eae4:	d4 31       	pushm	r0-r7,lr
8000eae6:	30 05       	mov	r5,0
8000eae8:	16 91       	mov	r1,r11
8000eaea:	f8 c7 ff 28 	sub	r7,r12,-216
8000eaee:	0a 92       	mov	r2,r5
8000eaf0:	fe b0 fc fc 	rcall	8000e4e8 <__sfp_lock_acquire>
8000eaf4:	3f f3       	mov	r3,-1
8000eaf6:	c1 68       	rjmp	8000eb22 <_fwalk+0x3e>
8000eaf8:	6e 26       	ld.w	r6,r7[0x8]
8000eafa:	6e 14       	ld.w	r4,r7[0x4]
8000eafc:	2f 46       	sub	r6,-12
8000eafe:	c0 c8       	rjmp	8000eb16 <_fwalk+0x32>
8000eb00:	8c 08       	ld.sh	r8,r6[0x0]
8000eb02:	e4 08 19 00 	cp.h	r8,r2
8000eb06:	c0 70       	breq	8000eb14 <_fwalk+0x30>
8000eb08:	8c 18       	ld.sh	r8,r6[0x2]
8000eb0a:	e6 08 19 00 	cp.h	r8,r3
8000eb0e:	c0 30       	breq	8000eb14 <_fwalk+0x30>
8000eb10:	5d 11       	icall	r1
8000eb12:	18 45       	or	r5,r12
8000eb14:	2a 46       	sub	r6,-92
8000eb16:	20 14       	sub	r4,1
8000eb18:	ec cc 00 0c 	sub	r12,r6,12
8000eb1c:	58 04       	cp.w	r4,0
8000eb1e:	cf 14       	brge	8000eb00 <_fwalk+0x1c>
8000eb20:	6e 07       	ld.w	r7,r7[0x0]
8000eb22:	58 07       	cp.w	r7,0
8000eb24:	ce a1       	brne	8000eaf8 <_fwalk+0x14>
8000eb26:	fe b0 fc e2 	rcall	8000e4ea <__sfp_lock_release>
8000eb2a:	0a 9c       	mov	r12,r5
8000eb2c:	d8 32       	popm	r0-r7,pc
8000eb2e:	d7 03       	nop

8000eb30 <_localeconv_r>:
8000eb30:	48 1c       	lddpc	r12,8000eb34 <_localeconv_r+0x4>
8000eb32:	5e fc       	retal	r12
8000eb34:	80 01       	ld.sh	r1,r0[0x0]
8000eb36:	a1 10       	ld.d	r0,--r0

8000eb38 <__smakebuf_r>:
8000eb38:	d4 21       	pushm	r4-r7,lr
8000eb3a:	20 fd       	sub	sp,60
8000eb3c:	96 68       	ld.sh	r8,r11[0xc]
8000eb3e:	16 97       	mov	r7,r11
8000eb40:	18 96       	mov	r6,r12
8000eb42:	e2 18 00 02 	andl	r8,0x2,COH
8000eb46:	c3 d1       	brne	8000ebc0 <__smakebuf_r+0x88>
8000eb48:	96 7b       	ld.sh	r11,r11[0xe]
8000eb4a:	f0 0b 19 00 	cp.h	r11,r8
8000eb4e:	c0 55       	brlt	8000eb58 <__smakebuf_r+0x20>
8000eb50:	1a 9a       	mov	r10,sp
8000eb52:	e0 a0 04 79 	rcall	8000f444 <_fstat_r>
8000eb56:	c0 f4       	brge	8000eb74 <__smakebuf_r+0x3c>
8000eb58:	8e 65       	ld.sh	r5,r7[0xc]
8000eb5a:	0a 98       	mov	r8,r5
8000eb5c:	ab b8       	sbr	r8,0xb
8000eb5e:	e2 15 00 80 	andl	r5,0x80,COH
8000eb62:	ae 68       	st.h	r7[0xc],r8
8000eb64:	30 04       	mov	r4,0
8000eb66:	e0 68 04 00 	mov	r8,1024
8000eb6a:	f9 b5 01 40 	movne	r5,64
8000eb6e:	f0 05 17 00 	moveq	r5,r8
8000eb72:	c1 c8       	rjmp	8000ebaa <__smakebuf_r+0x72>
8000eb74:	40 18       	lddsp	r8,sp[0x4]
8000eb76:	e2 18 f0 00 	andl	r8,0xf000,COH
8000eb7a:	e0 48 20 00 	cp.w	r8,8192
8000eb7e:	5f 04       	sreq	r4
8000eb80:	e0 48 80 00 	cp.w	r8,32768
8000eb84:	c0 e1       	brne	8000eba0 <__smakebuf_r+0x68>
8000eb86:	6e b9       	ld.w	r9,r7[0x2c]
8000eb88:	fe c8 f9 18 	sub	r8,pc,-1768
8000eb8c:	10 39       	cp.w	r9,r8
8000eb8e:	c0 91       	brne	8000eba0 <__smakebuf_r+0x68>
8000eb90:	8e 68       	ld.sh	r8,r7[0xc]
8000eb92:	e0 65 04 00 	mov	r5,1024
8000eb96:	ab a8       	sbr	r8,0xa
8000eb98:	ef 45 00 50 	st.w	r7[80],r5
8000eb9c:	ae 68       	st.h	r7[0xc],r8
8000eb9e:	c0 68       	rjmp	8000ebaa <__smakebuf_r+0x72>
8000eba0:	8e 68       	ld.sh	r8,r7[0xc]
8000eba2:	e0 65 04 00 	mov	r5,1024
8000eba6:	ab b8       	sbr	r8,0xb
8000eba8:	ae 68       	st.h	r7[0xc],r8
8000ebaa:	0a 9b       	mov	r11,r5
8000ebac:	0c 9c       	mov	r12,r6
8000ebae:	fe b0 de 7d 	rcall	8000a8a8 <_malloc_r>
8000ebb2:	8e 68       	ld.sh	r8,r7[0xc]
8000ebb4:	c0 d1       	brne	8000ebce <__smakebuf_r+0x96>
8000ebb6:	ed b8 00 09 	bld	r8,0x9
8000ebba:	c1 b0       	breq	8000ebf0 <__smakebuf_r+0xb8>
8000ebbc:	a1 b8       	sbr	r8,0x1
8000ebbe:	ae 68       	st.h	r7[0xc],r8
8000ebc0:	ee c8 ff b9 	sub	r8,r7,-71
8000ebc4:	8f 48       	st.w	r7[0x10],r8
8000ebc6:	8f 08       	st.w	r7[0x0],r8
8000ebc8:	30 18       	mov	r8,1
8000ebca:	8f 58       	st.w	r7[0x14],r8
8000ebcc:	c1 28       	rjmp	8000ebf0 <__smakebuf_r+0xb8>
8000ebce:	a7 b8       	sbr	r8,0x7
8000ebd0:	8f 4c       	st.w	r7[0x10],r12
8000ebd2:	ae 68       	st.h	r7[0xc],r8
8000ebd4:	8f 55       	st.w	r7[0x14],r5
8000ebd6:	fe c8 06 ea 	sub	r8,pc,1770
8000ebda:	8f 0c       	st.w	r7[0x0],r12
8000ebdc:	8d a8       	st.w	r6[0x28],r8
8000ebde:	58 04       	cp.w	r4,0
8000ebe0:	c0 80       	breq	8000ebf0 <__smakebuf_r+0xb8>
8000ebe2:	8e 7c       	ld.sh	r12,r7[0xe]
8000ebe4:	fe b0 e3 7a 	rcall	8000b2d8 <isatty>
8000ebe8:	c0 40       	breq	8000ebf0 <__smakebuf_r+0xb8>
8000ebea:	8e 68       	ld.sh	r8,r7[0xc]
8000ebec:	a1 a8       	sbr	r8,0x0
8000ebee:	ae 68       	st.h	r7[0xc],r8
8000ebf0:	2f 1d       	sub	sp,-60
8000ebf2:	d8 22       	popm	r4-r7,pc

8000ebf4 <memchr>:
8000ebf4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ebf8:	c0 68       	rjmp	8000ec04 <memchr+0x10>
8000ebfa:	20 1a       	sub	r10,1
8000ebfc:	19 88       	ld.ub	r8,r12[0x0]
8000ebfe:	16 38       	cp.w	r8,r11
8000ec00:	5e 0c       	reteq	r12
8000ec02:	2f fc       	sub	r12,-1
8000ec04:	58 0a       	cp.w	r10,0
8000ec06:	cf a1       	brne	8000ebfa <memchr+0x6>
8000ec08:	5e fa       	retal	r10

8000ec0a <memmove>:
8000ec0a:	d4 01       	pushm	lr
8000ec0c:	18 3b       	cp.w	r11,r12
8000ec0e:	c1 92       	brcc	8000ec40 <memmove+0x36>
8000ec10:	f6 0a 00 09 	add	r9,r11,r10
8000ec14:	12 3c       	cp.w	r12,r9
8000ec16:	c1 52       	brcc	8000ec40 <memmove+0x36>
8000ec18:	f8 0a 00 0b 	add	r11,r12,r10
8000ec1c:	30 08       	mov	r8,0
8000ec1e:	c0 68       	rjmp	8000ec2a <memmove+0x20>
8000ec20:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ec24:	20 1a       	sub	r10,1
8000ec26:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ec2a:	20 18       	sub	r8,1
8000ec2c:	58 0a       	cp.w	r10,0
8000ec2e:	cf 91       	brne	8000ec20 <memmove+0x16>
8000ec30:	d8 02       	popm	pc
8000ec32:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ec36:	20 1a       	sub	r10,1
8000ec38:	f8 08 0b 09 	st.b	r12[r8],r9
8000ec3c:	2f f8       	sub	r8,-1
8000ec3e:	c0 28       	rjmp	8000ec42 <memmove+0x38>
8000ec40:	30 08       	mov	r8,0
8000ec42:	58 0a       	cp.w	r10,0
8000ec44:	cf 71       	brne	8000ec32 <memmove+0x28>
8000ec46:	d8 02       	popm	pc

8000ec48 <__hi0bits>:
8000ec48:	18 98       	mov	r8,r12
8000ec4a:	e0 1c 00 00 	andl	r12,0x0
8000ec4e:	f0 09 15 10 	lsl	r9,r8,0x10
8000ec52:	58 0c       	cp.w	r12,0
8000ec54:	f2 08 17 00 	moveq	r8,r9
8000ec58:	f9 bc 00 10 	moveq	r12,16
8000ec5c:	f9 bc 01 00 	movne	r12,0
8000ec60:	10 9a       	mov	r10,r8
8000ec62:	f0 09 15 08 	lsl	r9,r8,0x8
8000ec66:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ec6a:	f7 bc 00 f8 	subeq	r12,-8
8000ec6e:	f2 08 17 00 	moveq	r8,r9
8000ec72:	10 9a       	mov	r10,r8
8000ec74:	f0 09 15 04 	lsl	r9,r8,0x4
8000ec78:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ec7c:	f7 bc 00 fc 	subeq	r12,-4
8000ec80:	f2 08 17 00 	moveq	r8,r9
8000ec84:	10 9a       	mov	r10,r8
8000ec86:	f0 09 15 02 	lsl	r9,r8,0x2
8000ec8a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ec8e:	f7 bc 00 fe 	subeq	r12,-2
8000ec92:	f2 08 17 00 	moveq	r8,r9
8000ec96:	58 08       	cp.w	r8,0
8000ec98:	5e 5c       	retlt	r12
8000ec9a:	ed b8 00 1e 	bld	r8,0x1e
8000ec9e:	f9 bc 01 20 	movne	r12,32
8000eca2:	f7 bc 00 ff 	subeq	r12,-1
8000eca6:	5e fc       	retal	r12

8000eca8 <__lo0bits>:
8000eca8:	18 99       	mov	r9,r12
8000ecaa:	78 08       	ld.w	r8,r12[0x0]
8000ecac:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ecb0:	c1 50       	breq	8000ecda <__lo0bits+0x32>
8000ecb2:	ed b8 00 00 	bld	r8,0x0
8000ecb6:	c0 21       	brne	8000ecba <__lo0bits+0x12>
8000ecb8:	5e fd       	retal	0
8000ecba:	10 9b       	mov	r11,r8
8000ecbc:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ecc0:	e2 1b 00 02 	andl	r11,0x2,COH
8000ecc4:	a3 88       	lsr	r8,0x2
8000ecc6:	58 0b       	cp.w	r11,0
8000ecc8:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000eccc:	f9 bc 01 01 	movne	r12,1
8000ecd0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ecd4:	f9 bc 00 02 	moveq	r12,2
8000ecd8:	5e fc       	retal	r12
8000ecda:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000ecde:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ece2:	58 0a       	cp.w	r10,0
8000ece4:	f6 08 17 00 	moveq	r8,r11
8000ece8:	f9 bc 00 10 	moveq	r12,16
8000ecec:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000ecf0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000ecf4:	58 0b       	cp.w	r11,0
8000ecf6:	f7 bc 00 f8 	subeq	r12,-8
8000ecfa:	f4 08 17 00 	moveq	r8,r10
8000ecfe:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000ed02:	f0 0a 16 04 	lsr	r10,r8,0x4
8000ed06:	58 0b       	cp.w	r11,0
8000ed08:	f7 bc 00 fc 	subeq	r12,-4
8000ed0c:	f4 08 17 00 	moveq	r8,r10
8000ed10:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ed14:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ed18:	58 0b       	cp.w	r11,0
8000ed1a:	f7 bc 00 fe 	subeq	r12,-2
8000ed1e:	f4 08 17 00 	moveq	r8,r10
8000ed22:	ed b8 00 00 	bld	r8,0x0
8000ed26:	c0 60       	breq	8000ed32 <__lo0bits+0x8a>
8000ed28:	a1 98       	lsr	r8,0x1
8000ed2a:	c0 31       	brne	8000ed30 <__lo0bits+0x88>
8000ed2c:	32 0c       	mov	r12,32
8000ed2e:	5e fc       	retal	r12
8000ed30:	2f fc       	sub	r12,-1
8000ed32:	93 08       	st.w	r9[0x0],r8
8000ed34:	5e fc       	retal	r12

8000ed36 <__mcmp>:
8000ed36:	d4 01       	pushm	lr
8000ed38:	18 98       	mov	r8,r12
8000ed3a:	76 49       	ld.w	r9,r11[0x10]
8000ed3c:	78 4c       	ld.w	r12,r12[0x10]
8000ed3e:	12 1c       	sub	r12,r9
8000ed40:	c1 31       	brne	8000ed66 <__mcmp+0x30>
8000ed42:	2f b9       	sub	r9,-5
8000ed44:	a3 69       	lsl	r9,0x2
8000ed46:	12 0b       	add	r11,r9
8000ed48:	f0 09 00 09 	add	r9,r8,r9
8000ed4c:	2e c8       	sub	r8,-20
8000ed4e:	13 4e       	ld.w	lr,--r9
8000ed50:	17 4a       	ld.w	r10,--r11
8000ed52:	14 3e       	cp.w	lr,r10
8000ed54:	c0 60       	breq	8000ed60 <__mcmp+0x2a>
8000ed56:	f9 bc 03 ff 	movlo	r12,-1
8000ed5a:	f9 bc 02 01 	movhs	r12,1
8000ed5e:	d8 02       	popm	pc
8000ed60:	10 39       	cp.w	r9,r8
8000ed62:	fe 9b ff f6 	brhi	8000ed4e <__mcmp+0x18>
8000ed66:	d8 02       	popm	pc

8000ed68 <_Bfree>:
8000ed68:	d4 21       	pushm	r4-r7,lr
8000ed6a:	18 97       	mov	r7,r12
8000ed6c:	16 95       	mov	r5,r11
8000ed6e:	78 96       	ld.w	r6,r12[0x24]
8000ed70:	58 06       	cp.w	r6,0
8000ed72:	c0 91       	brne	8000ed84 <_Bfree+0x1c>
8000ed74:	31 0c       	mov	r12,16
8000ed76:	fe b0 dd 91 	rcall	8000a898 <malloc>
8000ed7a:	99 36       	st.w	r12[0xc],r6
8000ed7c:	8f 9c       	st.w	r7[0x24],r12
8000ed7e:	99 16       	st.w	r12[0x4],r6
8000ed80:	99 26       	st.w	r12[0x8],r6
8000ed82:	99 06       	st.w	r12[0x0],r6
8000ed84:	58 05       	cp.w	r5,0
8000ed86:	c0 90       	breq	8000ed98 <_Bfree+0x30>
8000ed88:	6a 19       	ld.w	r9,r5[0x4]
8000ed8a:	6e 98       	ld.w	r8,r7[0x24]
8000ed8c:	70 38       	ld.w	r8,r8[0xc]
8000ed8e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ed92:	8b 0a       	st.w	r5[0x0],r10
8000ed94:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ed98:	d8 22       	popm	r4-r7,pc
8000ed9a:	d7 03       	nop

8000ed9c <_Balloc>:
8000ed9c:	d4 21       	pushm	r4-r7,lr
8000ed9e:	18 97       	mov	r7,r12
8000eda0:	16 96       	mov	r6,r11
8000eda2:	78 95       	ld.w	r5,r12[0x24]
8000eda4:	58 05       	cp.w	r5,0
8000eda6:	c0 91       	brne	8000edb8 <_Balloc+0x1c>
8000eda8:	31 0c       	mov	r12,16
8000edaa:	fe b0 dd 77 	rcall	8000a898 <malloc>
8000edae:	99 35       	st.w	r12[0xc],r5
8000edb0:	8f 9c       	st.w	r7[0x24],r12
8000edb2:	99 15       	st.w	r12[0x4],r5
8000edb4:	99 25       	st.w	r12[0x8],r5
8000edb6:	99 05       	st.w	r12[0x0],r5
8000edb8:	6e 95       	ld.w	r5,r7[0x24]
8000edba:	6a 38       	ld.w	r8,r5[0xc]
8000edbc:	58 08       	cp.w	r8,0
8000edbe:	c0 b1       	brne	8000edd4 <_Balloc+0x38>
8000edc0:	31 0a       	mov	r10,16
8000edc2:	30 4b       	mov	r11,4
8000edc4:	0e 9c       	mov	r12,r7
8000edc6:	e0 a0 02 9d 	rcall	8000f300 <_calloc_r>
8000edca:	8b 3c       	st.w	r5[0xc],r12
8000edcc:	6e 98       	ld.w	r8,r7[0x24]
8000edce:	70 3c       	ld.w	r12,r8[0xc]
8000edd0:	58 0c       	cp.w	r12,0
8000edd2:	c1 b0       	breq	8000ee08 <_Balloc+0x6c>
8000edd4:	6e 98       	ld.w	r8,r7[0x24]
8000edd6:	70 38       	ld.w	r8,r8[0xc]
8000edd8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000eddc:	70 0c       	ld.w	r12,r8[0x0]
8000edde:	58 0c       	cp.w	r12,0
8000ede0:	c0 40       	breq	8000ede8 <_Balloc+0x4c>
8000ede2:	78 09       	ld.w	r9,r12[0x0]
8000ede4:	91 09       	st.w	r8[0x0],r9
8000ede6:	c0 e8       	rjmp	8000ee02 <_Balloc+0x66>
8000ede8:	0e 9c       	mov	r12,r7
8000edea:	30 17       	mov	r7,1
8000edec:	0e 9b       	mov	r11,r7
8000edee:	ee 06 09 47 	lsl	r7,r7,r6
8000edf2:	ee ca ff fb 	sub	r10,r7,-5
8000edf6:	a3 6a       	lsl	r10,0x2
8000edf8:	e0 a0 02 84 	rcall	8000f300 <_calloc_r>
8000edfc:	c0 60       	breq	8000ee08 <_Balloc+0x6c>
8000edfe:	99 16       	st.w	r12[0x4],r6
8000ee00:	99 27       	st.w	r12[0x8],r7
8000ee02:	30 08       	mov	r8,0
8000ee04:	99 38       	st.w	r12[0xc],r8
8000ee06:	99 48       	st.w	r12[0x10],r8
8000ee08:	d8 22       	popm	r4-r7,pc
8000ee0a:	d7 03       	nop

8000ee0c <__d2b>:
8000ee0c:	d4 31       	pushm	r0-r7,lr
8000ee0e:	20 2d       	sub	sp,8
8000ee10:	16 93       	mov	r3,r11
8000ee12:	12 96       	mov	r6,r9
8000ee14:	10 95       	mov	r5,r8
8000ee16:	14 92       	mov	r2,r10
8000ee18:	30 1b       	mov	r11,1
8000ee1a:	cc 1f       	rcall	8000ed9c <_Balloc>
8000ee1c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000ee20:	50 09       	stdsp	sp[0x0],r9
8000ee22:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000ee26:	b5 a9       	sbr	r9,0x14
8000ee28:	f0 01 16 14 	lsr	r1,r8,0x14
8000ee2c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ee30:	18 94       	mov	r4,r12
8000ee32:	58 02       	cp.w	r2,0
8000ee34:	c1 d0       	breq	8000ee6e <__d2b+0x62>
8000ee36:	fa cc ff f8 	sub	r12,sp,-8
8000ee3a:	18 d2       	st.w	--r12,r2
8000ee3c:	c3 6f       	rcall	8000eca8 <__lo0bits>
8000ee3e:	40 18       	lddsp	r8,sp[0x4]
8000ee40:	c0 d0       	breq	8000ee5a <__d2b+0x4e>
8000ee42:	40 09       	lddsp	r9,sp[0x0]
8000ee44:	f8 0a 11 20 	rsub	r10,r12,32
8000ee48:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ee4c:	f5 e8 10 08 	or	r8,r10,r8
8000ee50:	89 58       	st.w	r4[0x14],r8
8000ee52:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ee56:	50 09       	stdsp	sp[0x0],r9
8000ee58:	c0 28       	rjmp	8000ee5c <__d2b+0x50>
8000ee5a:	89 58       	st.w	r4[0x14],r8
8000ee5c:	40 08       	lddsp	r8,sp[0x0]
8000ee5e:	58 08       	cp.w	r8,0
8000ee60:	f9 b3 01 02 	movne	r3,2
8000ee64:	f9 b3 00 01 	moveq	r3,1
8000ee68:	89 68       	st.w	r4[0x18],r8
8000ee6a:	89 43       	st.w	r4[0x10],r3
8000ee6c:	c0 88       	rjmp	8000ee7c <__d2b+0x70>
8000ee6e:	1a 9c       	mov	r12,sp
8000ee70:	c1 cf       	rcall	8000eca8 <__lo0bits>
8000ee72:	30 13       	mov	r3,1
8000ee74:	40 08       	lddsp	r8,sp[0x0]
8000ee76:	2e 0c       	sub	r12,-32
8000ee78:	89 43       	st.w	r4[0x10],r3
8000ee7a:	89 58       	st.w	r4[0x14],r8
8000ee7c:	58 01       	cp.w	r1,0
8000ee7e:	c0 90       	breq	8000ee90 <__d2b+0x84>
8000ee80:	e2 c1 04 33 	sub	r1,r1,1075
8000ee84:	18 01       	add	r1,r12
8000ee86:	8d 01       	st.w	r6[0x0],r1
8000ee88:	f8 0c 11 35 	rsub	r12,r12,53
8000ee8c:	8b 0c       	st.w	r5[0x0],r12
8000ee8e:	c0 c8       	rjmp	8000eea6 <__d2b+0x9a>
8000ee90:	e6 c8 ff fc 	sub	r8,r3,-4
8000ee94:	f8 cc 04 32 	sub	r12,r12,1074
8000ee98:	a5 73       	lsl	r3,0x5
8000ee9a:	8d 0c       	st.w	r6[0x0],r12
8000ee9c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000eea0:	cd 4e       	rcall	8000ec48 <__hi0bits>
8000eea2:	18 13       	sub	r3,r12
8000eea4:	8b 03       	st.w	r5[0x0],r3
8000eea6:	08 9c       	mov	r12,r4
8000eea8:	2f ed       	sub	sp,-8
8000eeaa:	d8 32       	popm	r0-r7,pc

8000eeac <__mdiff>:
8000eeac:	d4 31       	pushm	r0-r7,lr
8000eeae:	74 48       	ld.w	r8,r10[0x10]
8000eeb0:	76 45       	ld.w	r5,r11[0x10]
8000eeb2:	16 97       	mov	r7,r11
8000eeb4:	14 96       	mov	r6,r10
8000eeb6:	10 15       	sub	r5,r8
8000eeb8:	c1 31       	brne	8000eede <__mdiff+0x32>
8000eeba:	2f b8       	sub	r8,-5
8000eebc:	ee ce ff ec 	sub	lr,r7,-20
8000eec0:	a3 68       	lsl	r8,0x2
8000eec2:	f4 08 00 0b 	add	r11,r10,r8
8000eec6:	ee 08 00 08 	add	r8,r7,r8
8000eeca:	11 4a       	ld.w	r10,--r8
8000eecc:	17 49       	ld.w	r9,--r11
8000eece:	12 3a       	cp.w	r10,r9
8000eed0:	c0 30       	breq	8000eed6 <__mdiff+0x2a>
8000eed2:	c0 e2       	brcc	8000eeee <__mdiff+0x42>
8000eed4:	c0 78       	rjmp	8000eee2 <__mdiff+0x36>
8000eed6:	1c 38       	cp.w	r8,lr
8000eed8:	fe 9b ff f9 	brhi	8000eeca <__mdiff+0x1e>
8000eedc:	c4 98       	rjmp	8000ef6e <__mdiff+0xc2>
8000eede:	58 05       	cp.w	r5,0
8000eee0:	c0 64       	brge	8000eeec <__mdiff+0x40>
8000eee2:	0e 98       	mov	r8,r7
8000eee4:	30 15       	mov	r5,1
8000eee6:	0c 97       	mov	r7,r6
8000eee8:	10 96       	mov	r6,r8
8000eeea:	c0 28       	rjmp	8000eeee <__mdiff+0x42>
8000eeec:	30 05       	mov	r5,0
8000eeee:	6e 1b       	ld.w	r11,r7[0x4]
8000eef0:	c5 6f       	rcall	8000ed9c <_Balloc>
8000eef2:	6e 49       	ld.w	r9,r7[0x10]
8000eef4:	6c 44       	ld.w	r4,r6[0x10]
8000eef6:	99 35       	st.w	r12[0xc],r5
8000eef8:	2f b4       	sub	r4,-5
8000eefa:	f2 c5 ff fb 	sub	r5,r9,-5
8000eefe:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ef02:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000ef06:	2e c6       	sub	r6,-20
8000ef08:	2e c7       	sub	r7,-20
8000ef0a:	f8 c8 ff ec 	sub	r8,r12,-20
8000ef0e:	30 0a       	mov	r10,0
8000ef10:	0f 0e       	ld.w	lr,r7++
8000ef12:	0d 0b       	ld.w	r11,r6++
8000ef14:	fc 02 16 10 	lsr	r2,lr,0x10
8000ef18:	f6 03 16 10 	lsr	r3,r11,0x10
8000ef1c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ef20:	e4 03 01 03 	sub	r3,r2,r3
8000ef24:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ef28:	fc 0b 01 0b 	sub	r11,lr,r11
8000ef2c:	f6 0a 00 0a 	add	r10,r11,r10
8000ef30:	b0 1a       	st.h	r8[0x2],r10
8000ef32:	b1 4a       	asr	r10,0x10
8000ef34:	e6 0a 00 0a 	add	r10,r3,r10
8000ef38:	b0 0a       	st.h	r8[0x0],r10
8000ef3a:	2f c8       	sub	r8,-4
8000ef3c:	b1 4a       	asr	r10,0x10
8000ef3e:	08 36       	cp.w	r6,r4
8000ef40:	ce 83       	brcs	8000ef10 <__mdiff+0x64>
8000ef42:	c0 d8       	rjmp	8000ef5c <__mdiff+0xb0>
8000ef44:	0f 0b       	ld.w	r11,r7++
8000ef46:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ef4a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ef4e:	16 0a       	add	r10,r11
8000ef50:	b0 1a       	st.h	r8[0x2],r10
8000ef52:	b1 4a       	asr	r10,0x10
8000ef54:	1c 0a       	add	r10,lr
8000ef56:	b0 0a       	st.h	r8[0x0],r10
8000ef58:	2f c8       	sub	r8,-4
8000ef5a:	b1 4a       	asr	r10,0x10
8000ef5c:	0a 37       	cp.w	r7,r5
8000ef5e:	cf 33       	brcs	8000ef44 <__mdiff+0x98>
8000ef60:	c0 28       	rjmp	8000ef64 <__mdiff+0xb8>
8000ef62:	20 19       	sub	r9,1
8000ef64:	11 4a       	ld.w	r10,--r8
8000ef66:	58 0a       	cp.w	r10,0
8000ef68:	cf d0       	breq	8000ef62 <__mdiff+0xb6>
8000ef6a:	99 49       	st.w	r12[0x10],r9
8000ef6c:	d8 32       	popm	r0-r7,pc
8000ef6e:	30 0b       	mov	r11,0
8000ef70:	c1 6f       	rcall	8000ed9c <_Balloc>
8000ef72:	30 18       	mov	r8,1
8000ef74:	99 48       	st.w	r12[0x10],r8
8000ef76:	30 08       	mov	r8,0
8000ef78:	99 58       	st.w	r12[0x14],r8
8000ef7a:	d8 32       	popm	r0-r7,pc

8000ef7c <__lshift>:
8000ef7c:	d4 31       	pushm	r0-r7,lr
8000ef7e:	16 97       	mov	r7,r11
8000ef80:	76 46       	ld.w	r6,r11[0x10]
8000ef82:	f4 02 14 05 	asr	r2,r10,0x5
8000ef86:	2f f6       	sub	r6,-1
8000ef88:	14 93       	mov	r3,r10
8000ef8a:	18 94       	mov	r4,r12
8000ef8c:	04 06       	add	r6,r2
8000ef8e:	76 1b       	ld.w	r11,r11[0x4]
8000ef90:	6e 28       	ld.w	r8,r7[0x8]
8000ef92:	c0 38       	rjmp	8000ef98 <__lshift+0x1c>
8000ef94:	2f fb       	sub	r11,-1
8000ef96:	a1 78       	lsl	r8,0x1
8000ef98:	10 36       	cp.w	r6,r8
8000ef9a:	fe 99 ff fd 	brgt	8000ef94 <__lshift+0x18>
8000ef9e:	08 9c       	mov	r12,r4
8000efa0:	cf ee       	rcall	8000ed9c <_Balloc>
8000efa2:	30 09       	mov	r9,0
8000efa4:	18 95       	mov	r5,r12
8000efa6:	f8 c8 ff ec 	sub	r8,r12,-20
8000efaa:	12 9a       	mov	r10,r9
8000efac:	c0 38       	rjmp	8000efb2 <__lshift+0x36>
8000efae:	10 aa       	st.w	r8++,r10
8000efb0:	2f f9       	sub	r9,-1
8000efb2:	04 39       	cp.w	r9,r2
8000efb4:	cf d5       	brlt	8000efae <__lshift+0x32>
8000efb6:	6e 4b       	ld.w	r11,r7[0x10]
8000efb8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000efbc:	2f bb       	sub	r11,-5
8000efbe:	ee c9 ff ec 	sub	r9,r7,-20
8000efc2:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000efc6:	58 03       	cp.w	r3,0
8000efc8:	c1 30       	breq	8000efee <__lshift+0x72>
8000efca:	e6 0c 11 20 	rsub	r12,r3,32
8000efce:	30 0a       	mov	r10,0
8000efd0:	72 02       	ld.w	r2,r9[0x0]
8000efd2:	e4 03 09 42 	lsl	r2,r2,r3
8000efd6:	04 4a       	or	r10,r2
8000efd8:	10 aa       	st.w	r8++,r10
8000efda:	13 0a       	ld.w	r10,r9++
8000efdc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000efe0:	16 39       	cp.w	r9,r11
8000efe2:	cf 73       	brcs	8000efd0 <__lshift+0x54>
8000efe4:	91 0a       	st.w	r8[0x0],r10
8000efe6:	58 0a       	cp.w	r10,0
8000efe8:	c0 70       	breq	8000eff6 <__lshift+0x7a>
8000efea:	2f f6       	sub	r6,-1
8000efec:	c0 58       	rjmp	8000eff6 <__lshift+0x7a>
8000efee:	13 0a       	ld.w	r10,r9++
8000eff0:	10 aa       	st.w	r8++,r10
8000eff2:	16 39       	cp.w	r9,r11
8000eff4:	cf d3       	brcs	8000efee <__lshift+0x72>
8000eff6:	08 9c       	mov	r12,r4
8000eff8:	20 16       	sub	r6,1
8000effa:	0e 9b       	mov	r11,r7
8000effc:	8b 46       	st.w	r5[0x10],r6
8000effe:	cb 5e       	rcall	8000ed68 <_Bfree>
8000f000:	0a 9c       	mov	r12,r5
8000f002:	d8 32       	popm	r0-r7,pc

8000f004 <__multiply>:
8000f004:	d4 31       	pushm	r0-r7,lr
8000f006:	20 2d       	sub	sp,8
8000f008:	76 49       	ld.w	r9,r11[0x10]
8000f00a:	74 48       	ld.w	r8,r10[0x10]
8000f00c:	16 96       	mov	r6,r11
8000f00e:	14 95       	mov	r5,r10
8000f010:	10 39       	cp.w	r9,r8
8000f012:	ec 08 17 50 	movlt	r8,r6
8000f016:	ea 06 17 50 	movlt	r6,r5
8000f01a:	f0 05 17 50 	movlt	r5,r8
8000f01e:	6c 28       	ld.w	r8,r6[0x8]
8000f020:	76 43       	ld.w	r3,r11[0x10]
8000f022:	74 42       	ld.w	r2,r10[0x10]
8000f024:	76 1b       	ld.w	r11,r11[0x4]
8000f026:	e4 03 00 07 	add	r7,r2,r3
8000f02a:	10 37       	cp.w	r7,r8
8000f02c:	f7 bb 09 ff 	subgt	r11,-1
8000f030:	cb 6e       	rcall	8000ed9c <_Balloc>
8000f032:	ee c4 ff fb 	sub	r4,r7,-5
8000f036:	f8 c9 ff ec 	sub	r9,r12,-20
8000f03a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f03e:	30 0a       	mov	r10,0
8000f040:	12 98       	mov	r8,r9
8000f042:	c0 28       	rjmp	8000f046 <__multiply+0x42>
8000f044:	10 aa       	st.w	r8++,r10
8000f046:	08 38       	cp.w	r8,r4
8000f048:	cf e3       	brcs	8000f044 <__multiply+0x40>
8000f04a:	2f b3       	sub	r3,-5
8000f04c:	2f b2       	sub	r2,-5
8000f04e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000f052:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000f056:	ec cb ff ec 	sub	r11,r6,-20
8000f05a:	50 12       	stdsp	sp[0x4],r2
8000f05c:	ea ca ff ec 	sub	r10,r5,-20
8000f060:	c4 48       	rjmp	8000f0e8 <__multiply+0xe4>
8000f062:	94 95       	ld.uh	r5,r10[0x2]
8000f064:	58 05       	cp.w	r5,0
8000f066:	c2 00       	breq	8000f0a6 <__multiply+0xa2>
8000f068:	12 98       	mov	r8,r9
8000f06a:	16 96       	mov	r6,r11
8000f06c:	30 0e       	mov	lr,0
8000f06e:	50 09       	stdsp	sp[0x0],r9
8000f070:	0d 02       	ld.w	r2,r6++
8000f072:	e4 00 16 10 	lsr	r0,r2,0x10
8000f076:	70 01       	ld.w	r1,r8[0x0]
8000f078:	70 09       	ld.w	r9,r8[0x0]
8000f07a:	b1 81       	lsr	r1,0x10
8000f07c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000f080:	e0 05 03 41 	mac	r1,r0,r5
8000f084:	ab 32       	mul	r2,r5
8000f086:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000f08a:	00 02       	add	r2,r0
8000f08c:	e4 0e 00 0e 	add	lr,r2,lr
8000f090:	b0 1e       	st.h	r8[0x2],lr
8000f092:	b1 8e       	lsr	lr,0x10
8000f094:	1c 01       	add	r1,lr
8000f096:	b0 01       	st.h	r8[0x0],r1
8000f098:	e2 0e 16 10 	lsr	lr,r1,0x10
8000f09c:	2f c8       	sub	r8,-4
8000f09e:	06 36       	cp.w	r6,r3
8000f0a0:	ce 83       	brcs	8000f070 <__multiply+0x6c>
8000f0a2:	40 09       	lddsp	r9,sp[0x0]
8000f0a4:	91 0e       	st.w	r8[0x0],lr
8000f0a6:	94 86       	ld.uh	r6,r10[0x0]
8000f0a8:	58 06       	cp.w	r6,0
8000f0aa:	c1 d0       	breq	8000f0e4 <__multiply+0xe0>
8000f0ac:	72 02       	ld.w	r2,r9[0x0]
8000f0ae:	12 98       	mov	r8,r9
8000f0b0:	16 9e       	mov	lr,r11
8000f0b2:	30 05       	mov	r5,0
8000f0b4:	b0 12       	st.h	r8[0x2],r2
8000f0b6:	1d 01       	ld.w	r1,lr++
8000f0b8:	90 82       	ld.uh	r2,r8[0x0]
8000f0ba:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000f0be:	ad 30       	mul	r0,r6
8000f0c0:	e0 02 00 02 	add	r2,r0,r2
8000f0c4:	e4 05 00 05 	add	r5,r2,r5
8000f0c8:	b0 05       	st.h	r8[0x0],r5
8000f0ca:	b1 85       	lsr	r5,0x10
8000f0cc:	b1 81       	lsr	r1,0x10
8000f0ce:	2f c8       	sub	r8,-4
8000f0d0:	ad 31       	mul	r1,r6
8000f0d2:	90 92       	ld.uh	r2,r8[0x2]
8000f0d4:	e2 02 00 02 	add	r2,r1,r2
8000f0d8:	0a 02       	add	r2,r5
8000f0da:	e4 05 16 10 	lsr	r5,r2,0x10
8000f0de:	06 3e       	cp.w	lr,r3
8000f0e0:	ce a3       	brcs	8000f0b4 <__multiply+0xb0>
8000f0e2:	91 02       	st.w	r8[0x0],r2
8000f0e4:	2f ca       	sub	r10,-4
8000f0e6:	2f c9       	sub	r9,-4
8000f0e8:	40 18       	lddsp	r8,sp[0x4]
8000f0ea:	10 3a       	cp.w	r10,r8
8000f0ec:	cb b3       	brcs	8000f062 <__multiply+0x5e>
8000f0ee:	c0 28       	rjmp	8000f0f2 <__multiply+0xee>
8000f0f0:	20 17       	sub	r7,1
8000f0f2:	58 07       	cp.w	r7,0
8000f0f4:	e0 8a 00 05 	brle	8000f0fe <__multiply+0xfa>
8000f0f8:	09 48       	ld.w	r8,--r4
8000f0fa:	58 08       	cp.w	r8,0
8000f0fc:	cf a0       	breq	8000f0f0 <__multiply+0xec>
8000f0fe:	99 47       	st.w	r12[0x10],r7
8000f100:	2f ed       	sub	sp,-8
8000f102:	d8 32       	popm	r0-r7,pc

8000f104 <__i2b>:
8000f104:	d4 21       	pushm	r4-r7,lr
8000f106:	16 97       	mov	r7,r11
8000f108:	30 1b       	mov	r11,1
8000f10a:	c4 9e       	rcall	8000ed9c <_Balloc>
8000f10c:	30 19       	mov	r9,1
8000f10e:	99 57       	st.w	r12[0x14],r7
8000f110:	99 49       	st.w	r12[0x10],r9
8000f112:	d8 22       	popm	r4-r7,pc

8000f114 <__multadd>:
8000f114:	d4 31       	pushm	r0-r7,lr
8000f116:	30 08       	mov	r8,0
8000f118:	12 95       	mov	r5,r9
8000f11a:	16 97       	mov	r7,r11
8000f11c:	18 96       	mov	r6,r12
8000f11e:	76 44       	ld.w	r4,r11[0x10]
8000f120:	f6 c9 ff ec 	sub	r9,r11,-20
8000f124:	72 0b       	ld.w	r11,r9[0x0]
8000f126:	f6 0c 16 10 	lsr	r12,r11,0x10
8000f12a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f12e:	f4 0c 02 4c 	mul	r12,r10,r12
8000f132:	f4 0b 03 45 	mac	r5,r10,r11
8000f136:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000f13a:	b1 85       	lsr	r5,0x10
8000f13c:	18 05       	add	r5,r12
8000f13e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000f142:	f8 0b 00 0b 	add	r11,r12,r11
8000f146:	12 ab       	st.w	r9++,r11
8000f148:	2f f8       	sub	r8,-1
8000f14a:	b1 85       	lsr	r5,0x10
8000f14c:	08 38       	cp.w	r8,r4
8000f14e:	ce b5       	brlt	8000f124 <__multadd+0x10>
8000f150:	58 05       	cp.w	r5,0
8000f152:	c1 c0       	breq	8000f18a <__multadd+0x76>
8000f154:	6e 28       	ld.w	r8,r7[0x8]
8000f156:	10 34       	cp.w	r4,r8
8000f158:	c1 35       	brlt	8000f17e <__multadd+0x6a>
8000f15a:	6e 1b       	ld.w	r11,r7[0x4]
8000f15c:	0c 9c       	mov	r12,r6
8000f15e:	2f fb       	sub	r11,-1
8000f160:	c1 ee       	rcall	8000ed9c <_Balloc>
8000f162:	6e 4a       	ld.w	r10,r7[0x10]
8000f164:	ee cb ff f4 	sub	r11,r7,-12
8000f168:	18 93       	mov	r3,r12
8000f16a:	2f ea       	sub	r10,-2
8000f16c:	2f 4c       	sub	r12,-12
8000f16e:	a3 6a       	lsl	r10,0x2
8000f170:	fe b0 dd cb 	rcall	8000ad06 <memcpy>
8000f174:	0e 9b       	mov	r11,r7
8000f176:	0c 9c       	mov	r12,r6
8000f178:	fe b0 fd f8 	rcall	8000ed68 <_Bfree>
8000f17c:	06 97       	mov	r7,r3
8000f17e:	e8 c8 ff ff 	sub	r8,r4,-1
8000f182:	2f b4       	sub	r4,-5
8000f184:	8f 48       	st.w	r7[0x10],r8
8000f186:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000f18a:	0e 9c       	mov	r12,r7
8000f18c:	d8 32       	popm	r0-r7,pc
8000f18e:	d7 03       	nop

8000f190 <__pow5mult>:
8000f190:	d4 31       	pushm	r0-r7,lr
8000f192:	14 96       	mov	r6,r10
8000f194:	18 97       	mov	r7,r12
8000f196:	16 94       	mov	r4,r11
8000f198:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000f19c:	c0 80       	breq	8000f1ac <__pow5mult+0x1c>
8000f19e:	20 18       	sub	r8,1
8000f1a0:	49 f9       	lddpc	r9,8000f21c <__pow5mult+0x8c>
8000f1a2:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000f1a6:	30 09       	mov	r9,0
8000f1a8:	cb 6f       	rcall	8000f114 <__multadd>
8000f1aa:	18 94       	mov	r4,r12
8000f1ac:	a3 46       	asr	r6,0x2
8000f1ae:	c3 40       	breq	8000f216 <__pow5mult+0x86>
8000f1b0:	6e 95       	ld.w	r5,r7[0x24]
8000f1b2:	58 05       	cp.w	r5,0
8000f1b4:	c0 91       	brne	8000f1c6 <__pow5mult+0x36>
8000f1b6:	31 0c       	mov	r12,16
8000f1b8:	fe b0 db 70 	rcall	8000a898 <malloc>
8000f1bc:	99 35       	st.w	r12[0xc],r5
8000f1be:	8f 9c       	st.w	r7[0x24],r12
8000f1c0:	99 15       	st.w	r12[0x4],r5
8000f1c2:	99 25       	st.w	r12[0x8],r5
8000f1c4:	99 05       	st.w	r12[0x0],r5
8000f1c6:	6e 93       	ld.w	r3,r7[0x24]
8000f1c8:	66 25       	ld.w	r5,r3[0x8]
8000f1ca:	58 05       	cp.w	r5,0
8000f1cc:	c0 c1       	brne	8000f1e4 <__pow5mult+0x54>
8000f1ce:	e0 6b 02 71 	mov	r11,625
8000f1d2:	0e 9c       	mov	r12,r7
8000f1d4:	c9 8f       	rcall	8000f104 <__i2b>
8000f1d6:	87 2c       	st.w	r3[0x8],r12
8000f1d8:	30 08       	mov	r8,0
8000f1da:	18 95       	mov	r5,r12
8000f1dc:	99 08       	st.w	r12[0x0],r8
8000f1de:	c0 38       	rjmp	8000f1e4 <__pow5mult+0x54>
8000f1e0:	06 9c       	mov	r12,r3
8000f1e2:	18 95       	mov	r5,r12
8000f1e4:	ed b6 00 00 	bld	r6,0x0
8000f1e8:	c0 b1       	brne	8000f1fe <__pow5mult+0x6e>
8000f1ea:	08 9b       	mov	r11,r4
8000f1ec:	0a 9a       	mov	r10,r5
8000f1ee:	0e 9c       	mov	r12,r7
8000f1f0:	c0 af       	rcall	8000f004 <__multiply>
8000f1f2:	08 9b       	mov	r11,r4
8000f1f4:	18 93       	mov	r3,r12
8000f1f6:	0e 9c       	mov	r12,r7
8000f1f8:	06 94       	mov	r4,r3
8000f1fa:	fe b0 fd b7 	rcall	8000ed68 <_Bfree>
8000f1fe:	a1 56       	asr	r6,0x1
8000f200:	c0 b0       	breq	8000f216 <__pow5mult+0x86>
8000f202:	6a 03       	ld.w	r3,r5[0x0]
8000f204:	58 03       	cp.w	r3,0
8000f206:	ce d1       	brne	8000f1e0 <__pow5mult+0x50>
8000f208:	0a 9a       	mov	r10,r5
8000f20a:	0a 9b       	mov	r11,r5
8000f20c:	0e 9c       	mov	r12,r7
8000f20e:	cf be       	rcall	8000f004 <__multiply>
8000f210:	8b 0c       	st.w	r5[0x0],r12
8000f212:	99 03       	st.w	r12[0x0],r3
8000f214:	ce 7b       	rjmp	8000f1e2 <__pow5mult+0x52>
8000f216:	08 9c       	mov	r12,r4
8000f218:	d8 32       	popm	r0-r7,pc
8000f21a:	d7 03       	nop
8000f21c:	80 01       	ld.sh	r1,r0[0x0]
8000f21e:	a1 4c       	asr	r12,0x0

8000f220 <__isinfd>:
8000f220:	14 98       	mov	r8,r10
8000f222:	fc 19 7f f0 	movh	r9,0x7ff0
8000f226:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f22a:	f0 0b 11 00 	rsub	r11,r8,0
8000f22e:	f7 e8 10 08 	or	r8,r11,r8
8000f232:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000f236:	f2 08 01 08 	sub	r8,r9,r8
8000f23a:	f0 0c 11 00 	rsub	r12,r8,0
8000f23e:	f9 e8 10 08 	or	r8,r12,r8
8000f242:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000f246:	2f fc       	sub	r12,-1
8000f248:	5e fc       	retal	r12

8000f24a <__isnand>:
8000f24a:	14 98       	mov	r8,r10
8000f24c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f250:	f0 0c 11 00 	rsub	r12,r8,0
8000f254:	10 4c       	or	r12,r8
8000f256:	fc 18 7f f0 	movh	r8,0x7ff0
8000f25a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000f25e:	f0 0c 01 0c 	sub	r12,r8,r12
8000f262:	bf 9c       	lsr	r12,0x1f
8000f264:	5e fc       	retal	r12
8000f266:	d7 03       	nop

8000f268 <__sclose>:
8000f268:	d4 01       	pushm	lr
8000f26a:	96 7b       	ld.sh	r11,r11[0xe]
8000f26c:	c7 6c       	rcall	8000f358 <_close_r>
8000f26e:	d8 02       	popm	pc

8000f270 <__sseek>:
8000f270:	d4 21       	pushm	r4-r7,lr
8000f272:	16 97       	mov	r7,r11
8000f274:	96 7b       	ld.sh	r11,r11[0xe]
8000f276:	cf 9c       	rcall	8000f468 <_lseek_r>
8000f278:	8e 68       	ld.sh	r8,r7[0xc]
8000f27a:	10 99       	mov	r9,r8
8000f27c:	ad c8       	cbr	r8,0xc
8000f27e:	ad a9       	sbr	r9,0xc
8000f280:	5b fc       	cp.w	r12,-1
8000f282:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000f286:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000f28a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000f28e:	d8 22       	popm	r4-r7,pc

8000f290 <__swrite>:
8000f290:	d4 21       	pushm	r4-r7,lr
8000f292:	96 68       	ld.sh	r8,r11[0xc]
8000f294:	16 97       	mov	r7,r11
8000f296:	14 95       	mov	r5,r10
8000f298:	12 94       	mov	r4,r9
8000f29a:	e2 18 01 00 	andl	r8,0x100,COH
8000f29e:	18 96       	mov	r6,r12
8000f2a0:	c0 50       	breq	8000f2aa <__swrite+0x1a>
8000f2a2:	30 29       	mov	r9,2
8000f2a4:	30 0a       	mov	r10,0
8000f2a6:	96 7b       	ld.sh	r11,r11[0xe]
8000f2a8:	ce 0c       	rcall	8000f468 <_lseek_r>
8000f2aa:	8e 68       	ld.sh	r8,r7[0xc]
8000f2ac:	ad c8       	cbr	r8,0xc
8000f2ae:	08 99       	mov	r9,r4
8000f2b0:	0a 9a       	mov	r10,r5
8000f2b2:	8e 7b       	ld.sh	r11,r7[0xe]
8000f2b4:	0c 9c       	mov	r12,r6
8000f2b6:	ae 68       	st.h	r7[0xc],r8
8000f2b8:	c1 0c       	rcall	8000f2d8 <_write_r>
8000f2ba:	d8 22       	popm	r4-r7,pc

8000f2bc <__sread>:
8000f2bc:	d4 21       	pushm	r4-r7,lr
8000f2be:	16 97       	mov	r7,r11
8000f2c0:	96 7b       	ld.sh	r11,r11[0xe]
8000f2c2:	ce 7c       	rcall	8000f490 <_read_r>
8000f2c4:	c0 65       	brlt	8000f2d0 <__sread+0x14>
8000f2c6:	6f 58       	ld.w	r8,r7[0x54]
8000f2c8:	18 08       	add	r8,r12
8000f2ca:	ef 48 00 54 	st.w	r7[84],r8
8000f2ce:	d8 22       	popm	r4-r7,pc
8000f2d0:	8e 68       	ld.sh	r8,r7[0xc]
8000f2d2:	ad c8       	cbr	r8,0xc
8000f2d4:	ae 68       	st.h	r7[0xc],r8
8000f2d6:	d8 22       	popm	r4-r7,pc

8000f2d8 <_write_r>:
8000f2d8:	d4 21       	pushm	r4-r7,lr
8000f2da:	16 98       	mov	r8,r11
8000f2dc:	18 97       	mov	r7,r12
8000f2de:	10 9c       	mov	r12,r8
8000f2e0:	30 08       	mov	r8,0
8000f2e2:	14 9b       	mov	r11,r10
8000f2e4:	e0 66 46 c8 	mov	r6,18120
8000f2e8:	12 9a       	mov	r10,r9
8000f2ea:	8d 08       	st.w	r6[0x0],r8
8000f2ec:	fe b0 d0 56 	rcall	80009398 <_write>
8000f2f0:	5b fc       	cp.w	r12,-1
8000f2f2:	c0 51       	brne	8000f2fc <_write_r+0x24>
8000f2f4:	6c 08       	ld.w	r8,r6[0x0]
8000f2f6:	58 08       	cp.w	r8,0
8000f2f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f2fc:	d8 22       	popm	r4-r7,pc
8000f2fe:	d7 03       	nop

8000f300 <_calloc_r>:
8000f300:	d4 21       	pushm	r4-r7,lr
8000f302:	f4 0b 02 4b 	mul	r11,r10,r11
8000f306:	fe b0 da d1 	rcall	8000a8a8 <_malloc_r>
8000f30a:	18 97       	mov	r7,r12
8000f30c:	c2 30       	breq	8000f352 <_calloc_r+0x52>
8000f30e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000f312:	e0 1a ff fc 	andl	r10,0xfffc
8000f316:	20 4a       	sub	r10,4
8000f318:	e0 4a 00 24 	cp.w	r10,36
8000f31c:	e0 8b 00 18 	brhi	8000f34c <_calloc_r+0x4c>
8000f320:	18 98       	mov	r8,r12
8000f322:	59 3a       	cp.w	r10,19
8000f324:	e0 88 00 0f 	brls	8000f342 <_calloc_r+0x42>
8000f328:	30 09       	mov	r9,0
8000f32a:	10 a9       	st.w	r8++,r9
8000f32c:	10 a9       	st.w	r8++,r9
8000f32e:	59 ba       	cp.w	r10,27
8000f330:	e0 88 00 09 	brls	8000f342 <_calloc_r+0x42>
8000f334:	10 a9       	st.w	r8++,r9
8000f336:	10 a9       	st.w	r8++,r9
8000f338:	e0 4a 00 24 	cp.w	r10,36
8000f33c:	c0 31       	brne	8000f342 <_calloc_r+0x42>
8000f33e:	10 a9       	st.w	r8++,r9
8000f340:	10 a9       	st.w	r8++,r9
8000f342:	30 09       	mov	r9,0
8000f344:	10 a9       	st.w	r8++,r9
8000f346:	91 19       	st.w	r8[0x4],r9
8000f348:	91 09       	st.w	r8[0x0],r9
8000f34a:	c0 48       	rjmp	8000f352 <_calloc_r+0x52>
8000f34c:	30 0b       	mov	r11,0
8000f34e:	fe b0 dd 80 	rcall	8000ae4e <memset>
8000f352:	0e 9c       	mov	r12,r7
8000f354:	d8 22       	popm	r4-r7,pc
8000f356:	d7 03       	nop

8000f358 <_close_r>:
8000f358:	d4 21       	pushm	r4-r7,lr
8000f35a:	30 08       	mov	r8,0
8000f35c:	18 97       	mov	r7,r12
8000f35e:	e0 66 46 c8 	mov	r6,18120
8000f362:	16 9c       	mov	r12,r11
8000f364:	8d 08       	st.w	r6[0x0],r8
8000f366:	fe b0 df a5 	rcall	8000b2b0 <_close>
8000f36a:	5b fc       	cp.w	r12,-1
8000f36c:	c0 51       	brne	8000f376 <_close_r+0x1e>
8000f36e:	6c 08       	ld.w	r8,r6[0x0]
8000f370:	58 08       	cp.w	r8,0
8000f372:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f376:	d8 22       	popm	r4-r7,pc

8000f378 <_fclose_r>:
8000f378:	d4 21       	pushm	r4-r7,lr
8000f37a:	18 96       	mov	r6,r12
8000f37c:	16 97       	mov	r7,r11
8000f37e:	58 0b       	cp.w	r11,0
8000f380:	c0 31       	brne	8000f386 <_fclose_r+0xe>
8000f382:	16 95       	mov	r5,r11
8000f384:	c5 08       	rjmp	8000f424 <_fclose_r+0xac>
8000f386:	fe b0 f8 b1 	rcall	8000e4e8 <__sfp_lock_acquire>
8000f38a:	58 06       	cp.w	r6,0
8000f38c:	c0 70       	breq	8000f39a <_fclose_r+0x22>
8000f38e:	6c 68       	ld.w	r8,r6[0x18]
8000f390:	58 08       	cp.w	r8,0
8000f392:	c0 41       	brne	8000f39a <_fclose_r+0x22>
8000f394:	0c 9c       	mov	r12,r6
8000f396:	fe b0 f8 fd 	rcall	8000e590 <__sinit>
8000f39a:	4a 48       	lddpc	r8,8000f428 <_fclose_r+0xb0>
8000f39c:	10 37       	cp.w	r7,r8
8000f39e:	c0 31       	brne	8000f3a4 <_fclose_r+0x2c>
8000f3a0:	6c 07       	ld.w	r7,r6[0x0]
8000f3a2:	c0 a8       	rjmp	8000f3b6 <_fclose_r+0x3e>
8000f3a4:	4a 28       	lddpc	r8,8000f42c <_fclose_r+0xb4>
8000f3a6:	10 37       	cp.w	r7,r8
8000f3a8:	c0 31       	brne	8000f3ae <_fclose_r+0x36>
8000f3aa:	6c 17       	ld.w	r7,r6[0x4]
8000f3ac:	c0 58       	rjmp	8000f3b6 <_fclose_r+0x3e>
8000f3ae:	4a 18       	lddpc	r8,8000f430 <_fclose_r+0xb8>
8000f3b0:	10 37       	cp.w	r7,r8
8000f3b2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000f3b6:	8e 69       	ld.sh	r9,r7[0xc]
8000f3b8:	30 08       	mov	r8,0
8000f3ba:	f0 09 19 00 	cp.h	r9,r8
8000f3be:	c0 51       	brne	8000f3c8 <_fclose_r+0x50>
8000f3c0:	fe b0 f8 95 	rcall	8000e4ea <__sfp_lock_release>
8000f3c4:	30 05       	mov	r5,0
8000f3c6:	c2 f8       	rjmp	8000f424 <_fclose_r+0xac>
8000f3c8:	0e 9b       	mov	r11,r7
8000f3ca:	0c 9c       	mov	r12,r6
8000f3cc:	fe b0 f8 06 	rcall	8000e3d8 <_fflush_r>
8000f3d0:	6e c8       	ld.w	r8,r7[0x30]
8000f3d2:	18 95       	mov	r5,r12
8000f3d4:	58 08       	cp.w	r8,0
8000f3d6:	c0 60       	breq	8000f3e2 <_fclose_r+0x6a>
8000f3d8:	6e 8b       	ld.w	r11,r7[0x20]
8000f3da:	0c 9c       	mov	r12,r6
8000f3dc:	5d 18       	icall	r8
8000f3de:	f9 b5 05 ff 	movlt	r5,-1
8000f3e2:	8e 68       	ld.sh	r8,r7[0xc]
8000f3e4:	ed b8 00 07 	bld	r8,0x7
8000f3e8:	c0 51       	brne	8000f3f2 <_fclose_r+0x7a>
8000f3ea:	6e 4b       	ld.w	r11,r7[0x10]
8000f3ec:	0c 9c       	mov	r12,r6
8000f3ee:	fe b0 f9 6b 	rcall	8000e6c4 <_free_r>
8000f3f2:	6e db       	ld.w	r11,r7[0x34]
8000f3f4:	58 0b       	cp.w	r11,0
8000f3f6:	c0 a0       	breq	8000f40a <_fclose_r+0x92>
8000f3f8:	ee c8 ff bc 	sub	r8,r7,-68
8000f3fc:	10 3b       	cp.w	r11,r8
8000f3fe:	c0 40       	breq	8000f406 <_fclose_r+0x8e>
8000f400:	0c 9c       	mov	r12,r6
8000f402:	fe b0 f9 61 	rcall	8000e6c4 <_free_r>
8000f406:	30 08       	mov	r8,0
8000f408:	8f d8       	st.w	r7[0x34],r8
8000f40a:	6f 2b       	ld.w	r11,r7[0x48]
8000f40c:	58 0b       	cp.w	r11,0
8000f40e:	c0 70       	breq	8000f41c <_fclose_r+0xa4>
8000f410:	0c 9c       	mov	r12,r6
8000f412:	fe b0 f9 59 	rcall	8000e6c4 <_free_r>
8000f416:	30 08       	mov	r8,0
8000f418:	ef 48 00 48 	st.w	r7[72],r8
8000f41c:	30 08       	mov	r8,0
8000f41e:	ae 68       	st.h	r7[0xc],r8
8000f420:	fe b0 f8 65 	rcall	8000e4ea <__sfp_lock_release>
8000f424:	0a 9c       	mov	r12,r5
8000f426:	d8 22       	popm	r4-r7,pc
8000f428:	80 01       	ld.sh	r1,r0[0x0]
8000f42a:	a0 a8       	st.b	r0[0x2],r8
8000f42c:	80 01       	ld.sh	r1,r0[0x0]
8000f42e:	a0 c8       	st.b	r0[0x4],r8
8000f430:	80 01       	ld.sh	r1,r0[0x0]
8000f432:	a0 e8       	st.b	r0[0x6],r8

8000f434 <fclose>:
8000f434:	d4 01       	pushm	lr
8000f436:	e0 68 0a 38 	mov	r8,2616
8000f43a:	18 9b       	mov	r11,r12
8000f43c:	70 0c       	ld.w	r12,r8[0x0]
8000f43e:	c9 df       	rcall	8000f378 <_fclose_r>
8000f440:	d8 02       	popm	pc
8000f442:	d7 03       	nop

8000f444 <_fstat_r>:
8000f444:	d4 21       	pushm	r4-r7,lr
8000f446:	16 98       	mov	r8,r11
8000f448:	18 97       	mov	r7,r12
8000f44a:	10 9c       	mov	r12,r8
8000f44c:	30 08       	mov	r8,0
8000f44e:	e0 66 46 c8 	mov	r6,18120
8000f452:	14 9b       	mov	r11,r10
8000f454:	8d 08       	st.w	r6[0x0],r8
8000f456:	fe b0 df 55 	rcall	8000b300 <_fstat>
8000f45a:	5b fc       	cp.w	r12,-1
8000f45c:	c0 51       	brne	8000f466 <_fstat_r+0x22>
8000f45e:	6c 08       	ld.w	r8,r6[0x0]
8000f460:	58 08       	cp.w	r8,0
8000f462:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f466:	d8 22       	popm	r4-r7,pc

8000f468 <_lseek_r>:
8000f468:	d4 21       	pushm	r4-r7,lr
8000f46a:	16 98       	mov	r8,r11
8000f46c:	18 97       	mov	r7,r12
8000f46e:	10 9c       	mov	r12,r8
8000f470:	30 08       	mov	r8,0
8000f472:	14 9b       	mov	r11,r10
8000f474:	e0 66 46 c8 	mov	r6,18120
8000f478:	12 9a       	mov	r10,r9
8000f47a:	8d 08       	st.w	r6[0x0],r8
8000f47c:	fe b0 df 24 	rcall	8000b2c4 <_lseek>
8000f480:	5b fc       	cp.w	r12,-1
8000f482:	c0 51       	brne	8000f48c <_lseek_r+0x24>
8000f484:	6c 08       	ld.w	r8,r6[0x0]
8000f486:	58 08       	cp.w	r8,0
8000f488:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f48c:	d8 22       	popm	r4-r7,pc
8000f48e:	d7 03       	nop

8000f490 <_read_r>:
8000f490:	d4 21       	pushm	r4-r7,lr
8000f492:	16 98       	mov	r8,r11
8000f494:	18 97       	mov	r7,r12
8000f496:	10 9c       	mov	r12,r8
8000f498:	30 08       	mov	r8,0
8000f49a:	14 9b       	mov	r11,r10
8000f49c:	e0 66 46 c8 	mov	r6,18120
8000f4a0:	12 9a       	mov	r10,r9
8000f4a2:	8d 08       	st.w	r6[0x0],r8
8000f4a4:	fe b0 cf 5a 	rcall	80009358 <_read>
8000f4a8:	5b fc       	cp.w	r12,-1
8000f4aa:	c0 51       	brne	8000f4b4 <_read_r+0x24>
8000f4ac:	6c 08       	ld.w	r8,r6[0x0]
8000f4ae:	58 08       	cp.w	r8,0
8000f4b0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f4b4:	d8 22       	popm	r4-r7,pc
8000f4b6:	d7 03       	nop

8000f4b8 <__avr32_f64_mul>:
8000f4b8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f4bc:	e0 80 00 dc 	breq	8000f674 <__avr32_f64_mul_op1_zero>
8000f4c0:	d4 21       	pushm	r4-r7,lr
8000f4c2:	f7 e9 20 0e 	eor	lr,r11,r9
8000f4c6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f4ca:	30 15       	mov	r5,1
8000f4cc:	c4 30       	breq	8000f552 <__avr32_f64_mul_op1_subnormal>
8000f4ce:	ab 6b       	lsl	r11,0xa
8000f4d0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f4d4:	ab 6a       	lsl	r10,0xa
8000f4d6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f4da:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f4de:	c5 c0       	breq	8000f596 <__avr32_f64_mul_op2_subnormal>
8000f4e0:	a1 78       	lsl	r8,0x1
8000f4e2:	5c f9       	rol	r9
8000f4e4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f4e8:	e0 47 07 ff 	cp.w	r7,2047
8000f4ec:	c7 70       	breq	8000f5da <__avr32_f64_mul_op_nan_or_inf>
8000f4ee:	e0 46 07 ff 	cp.w	r6,2047
8000f4f2:	c7 40       	breq	8000f5da <__avr32_f64_mul_op_nan_or_inf>
8000f4f4:	ee 06 00 0c 	add	r12,r7,r6
8000f4f8:	e0 2c 03 fe 	sub	r12,1022
8000f4fc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f500:	f4 09 07 44 	macu.d	r4,r10,r9
8000f504:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f508:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f50c:	08 07       	add	r7,r4
8000f50e:	f4 05 00 4a 	adc	r10,r10,r5
8000f512:	5c 0b       	acr	r11
8000f514:	ed bb 00 14 	bld	r11,0x14
8000f518:	c0 50       	breq	8000f522 <__avr32_f64_mul+0x6a>
8000f51a:	a1 77       	lsl	r7,0x1
8000f51c:	5c fa       	rol	r10
8000f51e:	5c fb       	rol	r11
8000f520:	20 1c       	sub	r12,1
8000f522:	58 0c       	cp.w	r12,0
8000f524:	e0 8a 00 6f 	brle	8000f602 <__avr32_f64_mul_res_subnormal>
8000f528:	e0 4c 07 ff 	cp.w	r12,2047
8000f52c:	e0 84 00 9c 	brge	8000f664 <__avr32_f64_mul_res_inf>
8000f530:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f534:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f538:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f53c:	ee 17 80 00 	eorh	r7,0x8000
8000f540:	f1 b7 04 20 	satu	r7,0x1
8000f544:	0e 0a       	add	r10,r7
8000f546:	5c 0b       	acr	r11
8000f548:	ed be 00 1f 	bld	lr,0x1f
8000f54c:	ef bb 00 1f 	bst	r11,0x1f
8000f550:	d8 22       	popm	r4-r7,pc

8000f552 <__avr32_f64_mul_op1_subnormal>:
8000f552:	e4 1b 00 0f 	andh	r11,0xf
8000f556:	f4 0c 12 00 	clz	r12,r10
8000f55a:	f6 06 12 00 	clz	r6,r11
8000f55e:	f7 bc 03 e1 	sublo	r12,-31
8000f562:	f8 06 17 30 	movlo	r6,r12
8000f566:	f7 b6 02 01 	subhs	r6,1
8000f56a:	e0 46 00 20 	cp.w	r6,32
8000f56e:	c0 d4       	brge	8000f588 <__avr32_f64_mul_op1_subnormal+0x36>
8000f570:	ec 0c 11 20 	rsub	r12,r6,32
8000f574:	f6 06 09 4b 	lsl	r11,r11,r6
8000f578:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f57c:	18 4b       	or	r11,r12
8000f57e:	f4 06 09 4a 	lsl	r10,r10,r6
8000f582:	20 b6       	sub	r6,11
8000f584:	0c 17       	sub	r7,r6
8000f586:	ca ab       	rjmp	8000f4da <__avr32_f64_mul+0x22>
8000f588:	f4 06 09 4b 	lsl	r11,r10,r6
8000f58c:	c6 40       	breq	8000f654 <__avr32_f64_mul_res_zero>
8000f58e:	30 0a       	mov	r10,0
8000f590:	20 b6       	sub	r6,11
8000f592:	0c 17       	sub	r7,r6
8000f594:	ca 3b       	rjmp	8000f4da <__avr32_f64_mul+0x22>

8000f596 <__avr32_f64_mul_op2_subnormal>:
8000f596:	e4 19 00 0f 	andh	r9,0xf
8000f59a:	f0 0c 12 00 	clz	r12,r8
8000f59e:	f2 05 12 00 	clz	r5,r9
8000f5a2:	f7 bc 03 ea 	sublo	r12,-22
8000f5a6:	f8 05 17 30 	movlo	r5,r12
8000f5aa:	f7 b5 02 0a 	subhs	r5,10
8000f5ae:	e0 45 00 20 	cp.w	r5,32
8000f5b2:	c0 d4       	brge	8000f5cc <__avr32_f64_mul_op2_subnormal+0x36>
8000f5b4:	ea 0c 11 20 	rsub	r12,r5,32
8000f5b8:	f2 05 09 49 	lsl	r9,r9,r5
8000f5bc:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f5c0:	18 49       	or	r9,r12
8000f5c2:	f0 05 09 48 	lsl	r8,r8,r5
8000f5c6:	20 25       	sub	r5,2
8000f5c8:	0a 16       	sub	r6,r5
8000f5ca:	c8 fb       	rjmp	8000f4e8 <__avr32_f64_mul+0x30>
8000f5cc:	f0 05 09 49 	lsl	r9,r8,r5
8000f5d0:	c4 20       	breq	8000f654 <__avr32_f64_mul_res_zero>
8000f5d2:	30 08       	mov	r8,0
8000f5d4:	20 25       	sub	r5,2
8000f5d6:	0a 16       	sub	r6,r5
8000f5d8:	c8 8b       	rjmp	8000f4e8 <__avr32_f64_mul+0x30>

8000f5da <__avr32_f64_mul_op_nan_or_inf>:
8000f5da:	e4 19 00 0f 	andh	r9,0xf
8000f5de:	e4 1b 00 0f 	andh	r11,0xf
8000f5e2:	14 4b       	or	r11,r10
8000f5e4:	10 49       	or	r9,r8
8000f5e6:	e0 47 07 ff 	cp.w	r7,2047
8000f5ea:	c0 91       	brne	8000f5fc <__avr32_f64_mul_op1_not_naninf>
8000f5ec:	58 0b       	cp.w	r11,0
8000f5ee:	c3 81       	brne	8000f65e <__avr32_f64_mul_res_nan>
8000f5f0:	e0 46 07 ff 	cp.w	r6,2047
8000f5f4:	c3 81       	brne	8000f664 <__avr32_f64_mul_res_inf>
8000f5f6:	58 09       	cp.w	r9,0
8000f5f8:	c3 60       	breq	8000f664 <__avr32_f64_mul_res_inf>
8000f5fa:	c3 28       	rjmp	8000f65e <__avr32_f64_mul_res_nan>

8000f5fc <__avr32_f64_mul_op1_not_naninf>:
8000f5fc:	58 09       	cp.w	r9,0
8000f5fe:	c3 30       	breq	8000f664 <__avr32_f64_mul_res_inf>
8000f600:	c2 f8       	rjmp	8000f65e <__avr32_f64_mul_res_nan>

8000f602 <__avr32_f64_mul_res_subnormal>:
8000f602:	5c 3c       	neg	r12
8000f604:	2f fc       	sub	r12,-1
8000f606:	f1 bc 04 c0 	satu	r12,0x6
8000f60a:	e0 4c 00 20 	cp.w	r12,32
8000f60e:	c1 14       	brge	8000f630 <__avr32_f64_mul_res_subnormal+0x2e>
8000f610:	f8 08 11 20 	rsub	r8,r12,32
8000f614:	0e 46       	or	r6,r7
8000f616:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f61a:	f4 08 09 49 	lsl	r9,r10,r8
8000f61e:	12 47       	or	r7,r9
8000f620:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f624:	f6 08 09 49 	lsl	r9,r11,r8
8000f628:	12 4a       	or	r10,r9
8000f62a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f62e:	c8 3b       	rjmp	8000f534 <__avr32_f64_mul+0x7c>
8000f630:	f8 08 11 20 	rsub	r8,r12,32
8000f634:	f9 b9 00 00 	moveq	r9,0
8000f638:	c0 30       	breq	8000f63e <__avr32_f64_mul_res_subnormal+0x3c>
8000f63a:	f6 08 09 49 	lsl	r9,r11,r8
8000f63e:	0e 46       	or	r6,r7
8000f640:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f644:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f648:	f3 ea 10 07 	or	r7,r9,r10
8000f64c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f650:	30 0b       	mov	r11,0
8000f652:	c7 1b       	rjmp	8000f534 <__avr32_f64_mul+0x7c>

8000f654 <__avr32_f64_mul_res_zero>:
8000f654:	1c 9b       	mov	r11,lr
8000f656:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f65a:	30 0a       	mov	r10,0
8000f65c:	d8 22       	popm	r4-r7,pc

8000f65e <__avr32_f64_mul_res_nan>:
8000f65e:	3f fb       	mov	r11,-1
8000f660:	3f fa       	mov	r10,-1
8000f662:	d8 22       	popm	r4-r7,pc

8000f664 <__avr32_f64_mul_res_inf>:
8000f664:	f0 6b 00 00 	mov	r11,-1048576
8000f668:	ed be 00 1f 	bld	lr,0x1f
8000f66c:	ef bb 00 1f 	bst	r11,0x1f
8000f670:	30 0a       	mov	r10,0
8000f672:	d8 22       	popm	r4-r7,pc

8000f674 <__avr32_f64_mul_op1_zero>:
8000f674:	f7 e9 20 0b 	eor	r11,r11,r9
8000f678:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f67c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f680:	e0 4c 07 ff 	cp.w	r12,2047
8000f684:	5e 1c       	retne	r12
8000f686:	3f fa       	mov	r10,-1
8000f688:	3f fb       	mov	r11,-1
8000f68a:	5e fc       	retal	r12

8000f68c <__avr32_f64_sub_from_add>:
8000f68c:	ee 19 80 00 	eorh	r9,0x8000

8000f690 <__avr32_f64_sub>:
8000f690:	f7 e9 20 0c 	eor	r12,r11,r9
8000f694:	e0 86 00 ca 	brmi	8000f828 <__avr32_f64_add_from_sub>
8000f698:	eb cd 40 e0 	pushm	r5-r7,lr
8000f69c:	16 9c       	mov	r12,r11
8000f69e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f6a2:	bf db       	cbr	r11,0x1f
8000f6a4:	bf d9       	cbr	r9,0x1f
8000f6a6:	10 3a       	cp.w	r10,r8
8000f6a8:	f2 0b 13 00 	cpc	r11,r9
8000f6ac:	c0 92       	brcc	8000f6be <__avr32_f64_sub+0x2e>
8000f6ae:	16 97       	mov	r7,r11
8000f6b0:	12 9b       	mov	r11,r9
8000f6b2:	0e 99       	mov	r9,r7
8000f6b4:	14 97       	mov	r7,r10
8000f6b6:	10 9a       	mov	r10,r8
8000f6b8:	0e 98       	mov	r8,r7
8000f6ba:	ee 1c 80 00 	eorh	r12,0x8000
8000f6be:	f6 07 16 14 	lsr	r7,r11,0x14
8000f6c2:	ab 7b       	lsl	r11,0xb
8000f6c4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f6c8:	ab 7a       	lsl	r10,0xb
8000f6ca:	bf bb       	sbr	r11,0x1f
8000f6cc:	f2 06 16 14 	lsr	r6,r9,0x14
8000f6d0:	c4 40       	breq	8000f758 <__avr32_f64_sub_opL_subnormal>
8000f6d2:	ab 79       	lsl	r9,0xb
8000f6d4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f6d8:	ab 78       	lsl	r8,0xb
8000f6da:	bf b9       	sbr	r9,0x1f

8000f6dc <__avr32_f64_sub_opL_subnormal_done>:
8000f6dc:	e0 47 07 ff 	cp.w	r7,2047
8000f6e0:	c4 f0       	breq	8000f77e <__avr32_f64_sub_opH_nan_or_inf>
8000f6e2:	0e 26       	rsub	r6,r7
8000f6e4:	c1 20       	breq	8000f708 <__avr32_f64_sub_shift_done>
8000f6e6:	ec 05 11 20 	rsub	r5,r6,32
8000f6ea:	e0 46 00 20 	cp.w	r6,32
8000f6ee:	c7 c2       	brcc	8000f7e6 <__avr32_f64_sub_longshift>
8000f6f0:	f0 05 09 4e 	lsl	lr,r8,r5
8000f6f4:	f2 05 09 45 	lsl	r5,r9,r5
8000f6f8:	f0 06 0a 48 	lsr	r8,r8,r6
8000f6fc:	f2 06 0a 49 	lsr	r9,r9,r6
8000f700:	0a 48       	or	r8,r5
8000f702:	58 0e       	cp.w	lr,0
8000f704:	5f 1e       	srne	lr
8000f706:	1c 48       	or	r8,lr

8000f708 <__avr32_f64_sub_shift_done>:
8000f708:	10 1a       	sub	r10,r8
8000f70a:	f6 09 01 4b 	sbc	r11,r11,r9
8000f70e:	f6 06 12 00 	clz	r6,r11
8000f712:	c0 e0       	breq	8000f72e <__avr32_f64_sub_longnormalize_done>
8000f714:	c7 83       	brcs	8000f804 <__avr32_f64_sub_longnormalize>
8000f716:	ec 0e 11 20 	rsub	lr,r6,32
8000f71a:	f6 06 09 4b 	lsl	r11,r11,r6
8000f71e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f722:	1c 4b       	or	r11,lr
8000f724:	f4 06 09 4a 	lsl	r10,r10,r6
8000f728:	0c 17       	sub	r7,r6
8000f72a:	e0 8a 00 39 	brle	8000f79c <__avr32_f64_sub_subnormal_result>

8000f72e <__avr32_f64_sub_longnormalize_done>:
8000f72e:	f4 09 15 15 	lsl	r9,r10,0x15
8000f732:	ab 9a       	lsr	r10,0xb
8000f734:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f738:	ab 9b       	lsr	r11,0xb
8000f73a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f73e:	18 4b       	or	r11,r12

8000f740 <__avr32_f64_sub_round>:
8000f740:	fc 17 80 00 	movh	r7,0x8000
8000f744:	ed ba 00 00 	bld	r10,0x0
8000f748:	f7 b7 01 ff 	subne	r7,-1
8000f74c:	0e 39       	cp.w	r9,r7
8000f74e:	5f 29       	srhs	r9
8000f750:	12 0a       	add	r10,r9
8000f752:	5c 0b       	acr	r11
8000f754:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f758 <__avr32_f64_sub_opL_subnormal>:
8000f758:	ab 79       	lsl	r9,0xb
8000f75a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f75e:	ab 78       	lsl	r8,0xb
8000f760:	f3 e8 10 0e 	or	lr,r9,r8
8000f764:	f9 b6 01 01 	movne	r6,1
8000f768:	ee 0e 11 00 	rsub	lr,r7,0
8000f76c:	f9 b7 00 01 	moveq	r7,1
8000f770:	ef bb 00 1f 	bst	r11,0x1f
8000f774:	f7 ea 10 0e 	or	lr,r11,r10
8000f778:	f9 b7 00 00 	moveq	r7,0
8000f77c:	cb 0b       	rjmp	8000f6dc <__avr32_f64_sub_opL_subnormal_done>

8000f77e <__avr32_f64_sub_opH_nan_or_inf>:
8000f77e:	bf db       	cbr	r11,0x1f
8000f780:	f7 ea 10 0e 	or	lr,r11,r10
8000f784:	c0 81       	brne	8000f794 <__avr32_f64_sub_return_nan>
8000f786:	e0 46 07 ff 	cp.w	r6,2047
8000f78a:	c0 50       	breq	8000f794 <__avr32_f64_sub_return_nan>
8000f78c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f790:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f794 <__avr32_f64_sub_return_nan>:
8000f794:	3f fa       	mov	r10,-1
8000f796:	3f fb       	mov	r11,-1
8000f798:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f79c <__avr32_f64_sub_subnormal_result>:
8000f79c:	5c 37       	neg	r7
8000f79e:	2f f7       	sub	r7,-1
8000f7a0:	f1 b7 04 c0 	satu	r7,0x6
8000f7a4:	e0 47 00 20 	cp.w	r7,32
8000f7a8:	c1 14       	brge	8000f7ca <__avr32_f64_sub_subnormal_result+0x2e>
8000f7aa:	ee 08 11 20 	rsub	r8,r7,32
8000f7ae:	f4 08 09 49 	lsl	r9,r10,r8
8000f7b2:	5f 16       	srne	r6
8000f7b4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f7b8:	0c 4a       	or	r10,r6
8000f7ba:	f6 08 09 49 	lsl	r9,r11,r8
8000f7be:	f5 e9 10 0a 	or	r10,r10,r9
8000f7c2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f7c6:	30 07       	mov	r7,0
8000f7c8:	cb 3b       	rjmp	8000f72e <__avr32_f64_sub_longnormalize_done>
8000f7ca:	ee 08 11 40 	rsub	r8,r7,64
8000f7ce:	f6 08 09 49 	lsl	r9,r11,r8
8000f7d2:	14 49       	or	r9,r10
8000f7d4:	5f 16       	srne	r6
8000f7d6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f7da:	0c 4a       	or	r10,r6
8000f7dc:	30 0b       	mov	r11,0
8000f7de:	30 07       	mov	r7,0
8000f7e0:	ca 7b       	rjmp	8000f72e <__avr32_f64_sub_longnormalize_done>
8000f7e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f7e6 <__avr32_f64_sub_longshift>:
8000f7e6:	f1 b6 04 c0 	satu	r6,0x6
8000f7ea:	f0 0e 17 00 	moveq	lr,r8
8000f7ee:	c0 40       	breq	8000f7f6 <__avr32_f64_sub_longshift+0x10>
8000f7f0:	f2 05 09 4e 	lsl	lr,r9,r5
8000f7f4:	10 4e       	or	lr,r8
8000f7f6:	f2 06 0a 48 	lsr	r8,r9,r6
8000f7fa:	30 09       	mov	r9,0
8000f7fc:	58 0e       	cp.w	lr,0
8000f7fe:	5f 1e       	srne	lr
8000f800:	1c 48       	or	r8,lr
8000f802:	c8 3b       	rjmp	8000f708 <__avr32_f64_sub_shift_done>

8000f804 <__avr32_f64_sub_longnormalize>:
8000f804:	f4 06 12 00 	clz	r6,r10
8000f808:	f9 b7 03 00 	movlo	r7,0
8000f80c:	f9 b6 03 00 	movlo	r6,0
8000f810:	f9 bc 03 00 	movlo	r12,0
8000f814:	f7 b6 02 e0 	subhs	r6,-32
8000f818:	f4 06 09 4b 	lsl	r11,r10,r6
8000f81c:	30 0a       	mov	r10,0
8000f81e:	0c 17       	sub	r7,r6
8000f820:	fe 9a ff be 	brle	8000f79c <__avr32_f64_sub_subnormal_result>
8000f824:	c8 5b       	rjmp	8000f72e <__avr32_f64_sub_longnormalize_done>
8000f826:	d7 03       	nop

8000f828 <__avr32_f64_add_from_sub>:
8000f828:	ee 19 80 00 	eorh	r9,0x8000

8000f82c <__avr32_f64_add>:
8000f82c:	f7 e9 20 0c 	eor	r12,r11,r9
8000f830:	fe 96 ff 2e 	brmi	8000f68c <__avr32_f64_sub_from_add>
8000f834:	eb cd 40 e0 	pushm	r5-r7,lr
8000f838:	16 9c       	mov	r12,r11
8000f83a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f83e:	bf db       	cbr	r11,0x1f
8000f840:	bf d9       	cbr	r9,0x1f
8000f842:	12 3b       	cp.w	r11,r9
8000f844:	c0 72       	brcc	8000f852 <__avr32_f64_add+0x26>
8000f846:	16 97       	mov	r7,r11
8000f848:	12 9b       	mov	r11,r9
8000f84a:	0e 99       	mov	r9,r7
8000f84c:	14 97       	mov	r7,r10
8000f84e:	10 9a       	mov	r10,r8
8000f850:	0e 98       	mov	r8,r7
8000f852:	30 0e       	mov	lr,0
8000f854:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f858:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000f85c:	b5 ab       	sbr	r11,0x14
8000f85e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f862:	c6 20       	breq	8000f926 <__avr32_f64_add_op2_subnormal>
8000f864:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000f868:	b5 a9       	sbr	r9,0x14
8000f86a:	e0 47 07 ff 	cp.w	r7,2047
8000f86e:	c2 80       	breq	8000f8be <__avr32_f64_add_opH_nan_or_inf>
8000f870:	0e 26       	rsub	r6,r7
8000f872:	c1 20       	breq	8000f896 <__avr32_f64_add_shift_done>
8000f874:	e0 46 00 36 	cp.w	r6,54
8000f878:	c1 52       	brcc	8000f8a2 <__avr32_f64_add_res_of_done>
8000f87a:	ec 05 11 20 	rsub	r5,r6,32
8000f87e:	e0 46 00 20 	cp.w	r6,32
8000f882:	c3 52       	brcc	8000f8ec <__avr32_f64_add_longshift>
8000f884:	f0 05 09 4e 	lsl	lr,r8,r5
8000f888:	f2 05 09 45 	lsl	r5,r9,r5
8000f88c:	f0 06 0a 48 	lsr	r8,r8,r6
8000f890:	f2 06 0a 49 	lsr	r9,r9,r6
8000f894:	0a 48       	or	r8,r5

8000f896 <__avr32_f64_add_shift_done>:
8000f896:	10 0a       	add	r10,r8
8000f898:	f6 09 00 4b 	adc	r11,r11,r9
8000f89c:	ed bb 00 15 	bld	r11,0x15
8000f8a0:	c3 40       	breq	8000f908 <__avr32_f64_add_res_of>

8000f8a2 <__avr32_f64_add_res_of_done>:
8000f8a2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f8a6:	18 4b       	or	r11,r12

8000f8a8 <__avr32_f64_add_round>:
8000f8a8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f8ac:	18 4e       	or	lr,r12
8000f8ae:	ee 1e 80 00 	eorh	lr,0x8000
8000f8b2:	f1 be 04 20 	satu	lr,0x1
8000f8b6:	1c 0a       	add	r10,lr
8000f8b8:	5c 0b       	acr	r11
8000f8ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f8be <__avr32_f64_add_opH_nan_or_inf>:
8000f8be:	b5 cb       	cbr	r11,0x14
8000f8c0:	f7 ea 10 0e 	or	lr,r11,r10
8000f8c4:	c1 01       	brne	8000f8e4 <__avr32_f64_add_return_nan>
8000f8c6:	e0 46 07 ff 	cp.w	r6,2047
8000f8ca:	c0 30       	breq	8000f8d0 <__avr32_f64_add_opL_nan_or_inf>
8000f8cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f8d0 <__avr32_f64_add_opL_nan_or_inf>:
8000f8d0:	b5 c9       	cbr	r9,0x14
8000f8d2:	f3 e8 10 0e 	or	lr,r9,r8
8000f8d6:	c0 71       	brne	8000f8e4 <__avr32_f64_add_return_nan>
8000f8d8:	30 0a       	mov	r10,0
8000f8da:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f8de:	18 4b       	or	r11,r12
8000f8e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f8e4 <__avr32_f64_add_return_nan>:
8000f8e4:	3f fa       	mov	r10,-1
8000f8e6:	3f fb       	mov	r11,-1
8000f8e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f8ec <__avr32_f64_add_longshift>:
8000f8ec:	f1 b6 04 c0 	satu	r6,0x6
8000f8f0:	f0 0e 17 00 	moveq	lr,r8
8000f8f4:	c0 60       	breq	8000f900 <__avr32_f64_add_longshift+0x14>
8000f8f6:	f2 05 09 4e 	lsl	lr,r9,r5
8000f8fa:	58 08       	cp.w	r8,0
8000f8fc:	5f 18       	srne	r8
8000f8fe:	10 4e       	or	lr,r8
8000f900:	f2 06 0a 48 	lsr	r8,r9,r6
8000f904:	30 09       	mov	r9,0
8000f906:	cc 8b       	rjmp	8000f896 <__avr32_f64_add_shift_done>

8000f908 <__avr32_f64_add_res_of>:
8000f908:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f90c:	a1 9b       	lsr	r11,0x1
8000f90e:	5d 0a       	ror	r10
8000f910:	5d 0e       	ror	lr
8000f912:	2f f7       	sub	r7,-1
8000f914:	e0 47 07 ff 	cp.w	r7,2047
8000f918:	f9 ba 00 00 	moveq	r10,0
8000f91c:	f9 bb 00 00 	moveq	r11,0
8000f920:	f9 be 00 00 	moveq	lr,0
8000f924:	cb fb       	rjmp	8000f8a2 <__avr32_f64_add_res_of_done>

8000f926 <__avr32_f64_add_op2_subnormal>:
8000f926:	30 16       	mov	r6,1
8000f928:	58 07       	cp.w	r7,0
8000f92a:	ca 01       	brne	8000f86a <__avr32_f64_add+0x3e>
8000f92c:	b5 cb       	cbr	r11,0x14
8000f92e:	10 0a       	add	r10,r8
8000f930:	f6 09 00 4b 	adc	r11,r11,r9
8000f934:	18 4b       	or	r11,r12
8000f936:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f93a:	d7 03       	nop

8000f93c <__avr32_f64_to_u32>:
8000f93c:	58 0b       	cp.w	r11,0
8000f93e:	5e 6d       	retmi	0

8000f940 <__avr32_f64_to_s32>:
8000f940:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f944:	b5 9c       	lsr	r12,0x15
8000f946:	e0 2c 03 ff 	sub	r12,1023
8000f94a:	5e 3d       	retlo	0
8000f94c:	f8 0c 11 1f 	rsub	r12,r12,31
8000f950:	16 99       	mov	r9,r11
8000f952:	ab 7b       	lsl	r11,0xb
8000f954:	bf bb       	sbr	r11,0x1f
8000f956:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f95a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f95e:	a1 79       	lsl	r9,0x1
8000f960:	5e 2b       	reths	r11
8000f962:	5c 3b       	neg	r11
8000f964:	5e fb       	retal	r11

8000f966 <__avr32_u32_to_f64>:
8000f966:	f8 cb 00 00 	sub	r11,r12,0
8000f96a:	30 0c       	mov	r12,0
8000f96c:	c0 38       	rjmp	8000f972 <__avr32_s32_to_f64+0x4>

8000f96e <__avr32_s32_to_f64>:
8000f96e:	18 9b       	mov	r11,r12
8000f970:	5c 4b       	abs	r11
8000f972:	30 0a       	mov	r10,0
8000f974:	5e 0b       	reteq	r11
8000f976:	d4 01       	pushm	lr
8000f978:	e0 69 04 1e 	mov	r9,1054
8000f97c:	f6 08 12 00 	clz	r8,r11
8000f980:	c1 70       	breq	8000f9ae <__avr32_s32_to_f64+0x40>
8000f982:	c0 c3       	brcs	8000f99a <__avr32_s32_to_f64+0x2c>
8000f984:	f0 0e 11 20 	rsub	lr,r8,32
8000f988:	f6 08 09 4b 	lsl	r11,r11,r8
8000f98c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f990:	1c 4b       	or	r11,lr
8000f992:	f4 08 09 4a 	lsl	r10,r10,r8
8000f996:	10 19       	sub	r9,r8
8000f998:	c0 b8       	rjmp	8000f9ae <__avr32_s32_to_f64+0x40>
8000f99a:	f4 08 12 00 	clz	r8,r10
8000f99e:	f9 b8 03 00 	movlo	r8,0
8000f9a2:	f7 b8 02 e0 	subhs	r8,-32
8000f9a6:	f4 08 09 4b 	lsl	r11,r10,r8
8000f9aa:	30 0a       	mov	r10,0
8000f9ac:	10 19       	sub	r9,r8
8000f9ae:	58 09       	cp.w	r9,0
8000f9b0:	e0 89 00 30 	brgt	8000fa10 <__avr32_s32_to_f64+0xa2>
8000f9b4:	5c 39       	neg	r9
8000f9b6:	2f f9       	sub	r9,-1
8000f9b8:	e0 49 00 36 	cp.w	r9,54
8000f9bc:	c0 43       	brcs	8000f9c4 <__avr32_s32_to_f64+0x56>
8000f9be:	30 0b       	mov	r11,0
8000f9c0:	30 0a       	mov	r10,0
8000f9c2:	c2 68       	rjmp	8000fa0e <__avr32_s32_to_f64+0xa0>
8000f9c4:	2f 69       	sub	r9,-10
8000f9c6:	f2 08 11 20 	rsub	r8,r9,32
8000f9ca:	e0 49 00 20 	cp.w	r9,32
8000f9ce:	c0 b2       	brcc	8000f9e4 <__avr32_s32_to_f64+0x76>
8000f9d0:	f4 08 09 4e 	lsl	lr,r10,r8
8000f9d4:	f6 08 09 48 	lsl	r8,r11,r8
8000f9d8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f9dc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f9e0:	10 4b       	or	r11,r8
8000f9e2:	c0 88       	rjmp	8000f9f2 <__avr32_s32_to_f64+0x84>
8000f9e4:	f6 08 09 4e 	lsl	lr,r11,r8
8000f9e8:	14 4e       	or	lr,r10
8000f9ea:	16 9a       	mov	r10,r11
8000f9ec:	30 0b       	mov	r11,0
8000f9ee:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f9f2:	ed ba 00 00 	bld	r10,0x0
8000f9f6:	c0 92       	brcc	8000fa08 <__avr32_s32_to_f64+0x9a>
8000f9f8:	1c 7e       	tst	lr,lr
8000f9fa:	c0 41       	brne	8000fa02 <__avr32_s32_to_f64+0x94>
8000f9fc:	ed ba 00 01 	bld	r10,0x1
8000fa00:	c0 42       	brcc	8000fa08 <__avr32_s32_to_f64+0x9a>
8000fa02:	2f fa       	sub	r10,-1
8000fa04:	f7 bb 02 ff 	subhs	r11,-1
8000fa08:	5c fc       	rol	r12
8000fa0a:	5d 0b       	ror	r11
8000fa0c:	5d 0a       	ror	r10
8000fa0e:	d8 02       	popm	pc
8000fa10:	e0 68 03 ff 	mov	r8,1023
8000fa14:	ed ba 00 0b 	bld	r10,0xb
8000fa18:	f7 b8 00 ff 	subeq	r8,-1
8000fa1c:	10 0a       	add	r10,r8
8000fa1e:	5c 0b       	acr	r11
8000fa20:	f7 b9 03 fe 	sublo	r9,-2
8000fa24:	e0 49 07 ff 	cp.w	r9,2047
8000fa28:	c0 55       	brlt	8000fa32 <__avr32_s32_to_f64+0xc4>
8000fa2a:	30 0a       	mov	r10,0
8000fa2c:	fc 1b ff e0 	movh	r11,0xffe0
8000fa30:	c0 c8       	rjmp	8000fa48 <__floatsidf_return_op1>
8000fa32:	ed bb 00 1f 	bld	r11,0x1f
8000fa36:	f7 b9 01 01 	subne	r9,1
8000fa3a:	ab 9a       	lsr	r10,0xb
8000fa3c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000fa40:	a1 7b       	lsl	r11,0x1
8000fa42:	ab 9b       	lsr	r11,0xb
8000fa44:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000fa48 <__floatsidf_return_op1>:
8000fa48:	a1 7c       	lsl	r12,0x1
8000fa4a:	5d 0b       	ror	r11
8000fa4c:	d8 02       	popm	pc

8000fa4e <__avr32_f64_cmp_eq>:
8000fa4e:	10 3a       	cp.w	r10,r8
8000fa50:	f2 0b 13 00 	cpc	r11,r9
8000fa54:	c0 80       	breq	8000fa64 <__avr32_f64_cmp_eq+0x16>
8000fa56:	a1 7b       	lsl	r11,0x1
8000fa58:	a1 79       	lsl	r9,0x1
8000fa5a:	14 4b       	or	r11,r10
8000fa5c:	12 4b       	or	r11,r9
8000fa5e:	10 4b       	or	r11,r8
8000fa60:	5e 0f       	reteq	1
8000fa62:	5e fd       	retal	0
8000fa64:	a1 7b       	lsl	r11,0x1
8000fa66:	fc 1c ff e0 	movh	r12,0xffe0
8000fa6a:	58 0a       	cp.w	r10,0
8000fa6c:	f8 0b 13 00 	cpc	r11,r12
8000fa70:	5e 8f       	retls	1
8000fa72:	5e fd       	retal	0

8000fa74 <__avr32_f64_cmp_ge>:
8000fa74:	1a de       	st.w	--sp,lr
8000fa76:	1a d7       	st.w	--sp,r7
8000fa78:	a1 7b       	lsl	r11,0x1
8000fa7a:	5f 3c       	srlo	r12
8000fa7c:	a1 79       	lsl	r9,0x1
8000fa7e:	5f 37       	srlo	r7
8000fa80:	5c fc       	rol	r12
8000fa82:	fc 1e ff e0 	movh	lr,0xffe0
8000fa86:	58 0a       	cp.w	r10,0
8000fa88:	fc 0b 13 00 	cpc	r11,lr
8000fa8c:	e0 8b 00 1d 	brhi	8000fac6 <__avr32_f64_cmp_ge+0x52>
8000fa90:	58 08       	cp.w	r8,0
8000fa92:	fc 09 13 00 	cpc	r9,lr
8000fa96:	e0 8b 00 18 	brhi	8000fac6 <__avr32_f64_cmp_ge+0x52>
8000fa9a:	58 0b       	cp.w	r11,0
8000fa9c:	f5 ba 00 00 	subfeq	r10,0
8000faa0:	c1 50       	breq	8000faca <__avr32_f64_cmp_ge+0x56>
8000faa2:	1b 07       	ld.w	r7,sp++
8000faa4:	1b 0e       	ld.w	lr,sp++
8000faa6:	58 3c       	cp.w	r12,3
8000faa8:	c0 a0       	breq	8000fabc <__avr32_f64_cmp_ge+0x48>
8000faaa:	58 1c       	cp.w	r12,1
8000faac:	c0 33       	brcs	8000fab2 <__avr32_f64_cmp_ge+0x3e>
8000faae:	5e 0f       	reteq	1
8000fab0:	5e 1d       	retne	0
8000fab2:	10 3a       	cp.w	r10,r8
8000fab4:	f2 0b 13 00 	cpc	r11,r9
8000fab8:	5e 2f       	reths	1
8000faba:	5e 3d       	retlo	0
8000fabc:	14 38       	cp.w	r8,r10
8000fabe:	f6 09 13 00 	cpc	r9,r11
8000fac2:	5e 2f       	reths	1
8000fac4:	5e 3d       	retlo	0
8000fac6:	1b 07       	ld.w	r7,sp++
8000fac8:	d8 0a       	popm	pc,r12=0
8000faca:	58 17       	cp.w	r7,1
8000facc:	5f 0c       	sreq	r12
8000face:	58 09       	cp.w	r9,0
8000fad0:	f5 b8 00 00 	subfeq	r8,0
8000fad4:	1b 07       	ld.w	r7,sp++
8000fad6:	1b 0e       	ld.w	lr,sp++
8000fad8:	5e 0f       	reteq	1
8000fada:	5e fc       	retal	r12

8000fadc <__avr32_f64_cmp_lt>:
8000fadc:	1a de       	st.w	--sp,lr
8000fade:	1a d7       	st.w	--sp,r7
8000fae0:	a1 7b       	lsl	r11,0x1
8000fae2:	5f 3c       	srlo	r12
8000fae4:	a1 79       	lsl	r9,0x1
8000fae6:	5f 37       	srlo	r7
8000fae8:	5c fc       	rol	r12
8000faea:	fc 1e ff e0 	movh	lr,0xffe0
8000faee:	58 0a       	cp.w	r10,0
8000faf0:	fc 0b 13 00 	cpc	r11,lr
8000faf4:	e0 8b 00 1d 	brhi	8000fb2e <__avr32_f64_cmp_lt+0x52>
8000faf8:	58 08       	cp.w	r8,0
8000fafa:	fc 09 13 00 	cpc	r9,lr
8000fafe:	e0 8b 00 18 	brhi	8000fb2e <__avr32_f64_cmp_lt+0x52>
8000fb02:	58 0b       	cp.w	r11,0
8000fb04:	f5 ba 00 00 	subfeq	r10,0
8000fb08:	c1 50       	breq	8000fb32 <__avr32_f64_cmp_lt+0x56>
8000fb0a:	1b 07       	ld.w	r7,sp++
8000fb0c:	1b 0e       	ld.w	lr,sp++
8000fb0e:	58 3c       	cp.w	r12,3
8000fb10:	c0 a0       	breq	8000fb24 <__avr32_f64_cmp_lt+0x48>
8000fb12:	58 1c       	cp.w	r12,1
8000fb14:	c0 33       	brcs	8000fb1a <__avr32_f64_cmp_lt+0x3e>
8000fb16:	5e 0d       	reteq	0
8000fb18:	5e 1f       	retne	1
8000fb1a:	10 3a       	cp.w	r10,r8
8000fb1c:	f2 0b 13 00 	cpc	r11,r9
8000fb20:	5e 2d       	reths	0
8000fb22:	5e 3f       	retlo	1
8000fb24:	14 38       	cp.w	r8,r10
8000fb26:	f6 09 13 00 	cpc	r9,r11
8000fb2a:	5e 2d       	reths	0
8000fb2c:	5e 3f       	retlo	1
8000fb2e:	1b 07       	ld.w	r7,sp++
8000fb30:	d8 0a       	popm	pc,r12=0
8000fb32:	58 17       	cp.w	r7,1
8000fb34:	5f 1c       	srne	r12
8000fb36:	58 09       	cp.w	r9,0
8000fb38:	f5 b8 00 00 	subfeq	r8,0
8000fb3c:	1b 07       	ld.w	r7,sp++
8000fb3e:	1b 0e       	ld.w	lr,sp++
8000fb40:	5e 0d       	reteq	0
8000fb42:	5e fc       	retal	r12

8000fb44 <__avr32_f64_div>:
8000fb44:	eb cd 40 ff 	pushm	r0-r7,lr
8000fb48:	f7 e9 20 0e 	eor	lr,r11,r9
8000fb4c:	f6 07 16 14 	lsr	r7,r11,0x14
8000fb50:	a9 7b       	lsl	r11,0x9
8000fb52:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000fb56:	a9 7a       	lsl	r10,0x9
8000fb58:	bd bb       	sbr	r11,0x1d
8000fb5a:	e4 1b 3f ff 	andh	r11,0x3fff
8000fb5e:	ab d7       	cbr	r7,0xb
8000fb60:	e0 80 00 cc 	breq	8000fcf8 <__avr32_f64_div_round_subnormal+0x54>
8000fb64:	e0 47 07 ff 	cp.w	r7,2047
8000fb68:	e0 84 00 b5 	brge	8000fcd2 <__avr32_f64_div_round_subnormal+0x2e>
8000fb6c:	f2 06 16 14 	lsr	r6,r9,0x14
8000fb70:	a9 79       	lsl	r9,0x9
8000fb72:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000fb76:	a9 78       	lsl	r8,0x9
8000fb78:	bd b9       	sbr	r9,0x1d
8000fb7a:	e4 19 3f ff 	andh	r9,0x3fff
8000fb7e:	ab d6       	cbr	r6,0xb
8000fb80:	e0 80 00 e2 	breq	8000fd44 <__avr32_f64_div_round_subnormal+0xa0>
8000fb84:	e0 46 07 ff 	cp.w	r6,2047
8000fb88:	e0 84 00 b2 	brge	8000fcec <__avr32_f64_div_round_subnormal+0x48>
8000fb8c:	0c 17       	sub	r7,r6
8000fb8e:	fe 37 fc 01 	sub	r7,-1023
8000fb92:	fc 1c 80 00 	movh	r12,0x8000
8000fb96:	f8 03 16 01 	lsr	r3,r12,0x1
8000fb9a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000fb9e:	5c d4       	com	r4
8000fba0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000fba4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fba8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fbac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fbb0:	ea 03 15 02 	lsl	r3,r5,0x2
8000fbb4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fbb8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fbbc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fbc0:	ea 03 15 02 	lsl	r3,r5,0x2
8000fbc4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fbc8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fbcc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fbd0:	ea 03 15 02 	lsl	r3,r5,0x2
8000fbd4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fbd8:	e4 09 07 40 	macu.d	r0,r2,r9
8000fbdc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fbe0:	02 04       	add	r4,r1
8000fbe2:	5c 05       	acr	r5
8000fbe4:	a3 65       	lsl	r5,0x2
8000fbe6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000fbea:	a3 64       	lsl	r4,0x2
8000fbec:	5c 34       	neg	r4
8000fbee:	f8 05 01 45 	sbc	r5,r12,r5
8000fbf2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000fbf6:	e4 05 07 40 	macu.d	r0,r2,r5
8000fbfa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fbfe:	02 04       	add	r4,r1
8000fc00:	5c 05       	acr	r5
8000fc02:	ea 03 15 02 	lsl	r3,r5,0x2
8000fc06:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000fc0a:	e8 02 15 02 	lsl	r2,r4,0x2
8000fc0e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fc12:	e4 09 07 40 	macu.d	r0,r2,r9
8000fc16:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fc1a:	02 04       	add	r4,r1
8000fc1c:	5c 05       	acr	r5
8000fc1e:	a3 65       	lsl	r5,0x2
8000fc20:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000fc24:	a3 64       	lsl	r4,0x2
8000fc26:	5c 34       	neg	r4
8000fc28:	f8 05 01 45 	sbc	r5,r12,r5
8000fc2c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000fc30:	e4 05 07 40 	macu.d	r0,r2,r5
8000fc34:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fc38:	02 04       	add	r4,r1
8000fc3a:	5c 05       	acr	r5
8000fc3c:	ea 03 15 02 	lsl	r3,r5,0x2
8000fc40:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000fc44:	e8 02 15 02 	lsl	r2,r4,0x2
8000fc48:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000fc4c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000fc50:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000fc54:	02 02       	add	r2,r1
8000fc56:	5c 03       	acr	r3
8000fc58:	ed b3 00 1c 	bld	r3,0x1c
8000fc5c:	c0 90       	breq	8000fc6e <__avr32_f64_div+0x12a>
8000fc5e:	a1 72       	lsl	r2,0x1
8000fc60:	5c f3       	rol	r3
8000fc62:	20 17       	sub	r7,1
8000fc64:	a3 9a       	lsr	r10,0x3
8000fc66:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000fc6a:	a3 9b       	lsr	r11,0x3
8000fc6c:	c0 58       	rjmp	8000fc76 <__avr32_f64_div+0x132>
8000fc6e:	a5 8a       	lsr	r10,0x4
8000fc70:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000fc74:	a5 8b       	lsr	r11,0x4
8000fc76:	58 07       	cp.w	r7,0
8000fc78:	e0 8a 00 8b 	brle	8000fd8e <__avr32_f64_div_res_subnormal>
8000fc7c:	e0 12 ff 00 	andl	r2,0xff00
8000fc80:	e8 12 00 80 	orl	r2,0x80
8000fc84:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fc88:	e4 09 07 40 	macu.d	r0,r2,r9
8000fc8c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fc90:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fc94:	00 05       	add	r5,r0
8000fc96:	f0 01 00 48 	adc	r8,r8,r1
8000fc9a:	5c 09       	acr	r9
8000fc9c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fca0:	58 04       	cp.w	r4,0
8000fca2:	5c 25       	cpc	r5

8000fca4 <__avr32_f64_div_round_subnormal>:
8000fca4:	f4 08 13 00 	cpc	r8,r10
8000fca8:	f6 09 13 00 	cpc	r9,r11
8000fcac:	5f 36       	srlo	r6
8000fcae:	f8 06 17 00 	moveq	r6,r12
8000fcb2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000fcb6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000fcba:	e6 0b 16 08 	lsr	r11,r3,0x8
8000fcbe:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000fcc2:	ed be 00 1f 	bld	lr,0x1f
8000fcc6:	ef bb 00 1f 	bst	r11,0x1f
8000fcca:	0c 0a       	add	r10,r6
8000fccc:	5c 0b       	acr	r11
8000fcce:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fcd2:	e4 1b 00 0f 	andh	r11,0xf
8000fcd6:	14 4b       	or	r11,r10
8000fcd8:	e0 81 00 a7 	brne	8000fe26 <__avr32_f64_div_res_subnormal+0x98>
8000fcdc:	f2 06 16 14 	lsr	r6,r9,0x14
8000fce0:	ab d6       	cbr	r6,0xb
8000fce2:	e0 46 07 ff 	cp.w	r6,2047
8000fce6:	e0 81 00 a4 	brne	8000fe2e <__avr32_f64_div_res_subnormal+0xa0>
8000fcea:	c9 e8       	rjmp	8000fe26 <__avr32_f64_div_res_subnormal+0x98>
8000fcec:	e4 19 00 0f 	andh	r9,0xf
8000fcf0:	10 49       	or	r9,r8
8000fcf2:	e0 81 00 9a 	brne	8000fe26 <__avr32_f64_div_res_subnormal+0x98>
8000fcf6:	c9 28       	rjmp	8000fe1a <__avr32_f64_div_res_subnormal+0x8c>
8000fcf8:	a3 7b       	lsl	r11,0x3
8000fcfa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000fcfe:	a3 7a       	lsl	r10,0x3
8000fd00:	f5 eb 10 04 	or	r4,r10,r11
8000fd04:	e0 80 00 a0 	breq	8000fe44 <__avr32_f64_div_op1_zero>
8000fd08:	f6 04 12 00 	clz	r4,r11
8000fd0c:	c1 70       	breq	8000fd3a <__avr32_f64_div_round_subnormal+0x96>
8000fd0e:	c0 c3       	brcs	8000fd26 <__avr32_f64_div_round_subnormal+0x82>
8000fd10:	e8 05 11 20 	rsub	r5,r4,32
8000fd14:	f6 04 09 4b 	lsl	r11,r11,r4
8000fd18:	f4 05 0a 45 	lsr	r5,r10,r5
8000fd1c:	0a 4b       	or	r11,r5
8000fd1e:	f4 04 09 4a 	lsl	r10,r10,r4
8000fd22:	08 17       	sub	r7,r4
8000fd24:	c0 b8       	rjmp	8000fd3a <__avr32_f64_div_round_subnormal+0x96>
8000fd26:	f4 04 12 00 	clz	r4,r10
8000fd2a:	f9 b4 03 00 	movlo	r4,0
8000fd2e:	f7 b4 02 e0 	subhs	r4,-32
8000fd32:	f4 04 09 4b 	lsl	r11,r10,r4
8000fd36:	30 0a       	mov	r10,0
8000fd38:	08 17       	sub	r7,r4
8000fd3a:	a3 8a       	lsr	r10,0x2
8000fd3c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000fd40:	a3 8b       	lsr	r11,0x2
8000fd42:	c1 1b       	rjmp	8000fb64 <__avr32_f64_div+0x20>
8000fd44:	a3 79       	lsl	r9,0x3
8000fd46:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000fd4a:	a3 78       	lsl	r8,0x3
8000fd4c:	f3 e8 10 04 	or	r4,r9,r8
8000fd50:	c6 f0       	breq	8000fe2e <__avr32_f64_div_res_subnormal+0xa0>
8000fd52:	f2 04 12 00 	clz	r4,r9
8000fd56:	c1 70       	breq	8000fd84 <__avr32_f64_div_round_subnormal+0xe0>
8000fd58:	c0 c3       	brcs	8000fd70 <__avr32_f64_div_round_subnormal+0xcc>
8000fd5a:	e8 05 11 20 	rsub	r5,r4,32
8000fd5e:	f2 04 09 49 	lsl	r9,r9,r4
8000fd62:	f0 05 0a 45 	lsr	r5,r8,r5
8000fd66:	0a 49       	or	r9,r5
8000fd68:	f0 04 09 48 	lsl	r8,r8,r4
8000fd6c:	08 16       	sub	r6,r4
8000fd6e:	c0 b8       	rjmp	8000fd84 <__avr32_f64_div_round_subnormal+0xe0>
8000fd70:	f0 04 12 00 	clz	r4,r8
8000fd74:	f9 b4 03 00 	movlo	r4,0
8000fd78:	f7 b4 02 e0 	subhs	r4,-32
8000fd7c:	f0 04 09 49 	lsl	r9,r8,r4
8000fd80:	30 08       	mov	r8,0
8000fd82:	08 16       	sub	r6,r4
8000fd84:	a3 88       	lsr	r8,0x2
8000fd86:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000fd8a:	a3 89       	lsr	r9,0x2
8000fd8c:	cf ca       	rjmp	8000fb84 <__avr32_f64_div+0x40>

8000fd8e <__avr32_f64_div_res_subnormal>:
8000fd8e:	5c 37       	neg	r7
8000fd90:	2f f7       	sub	r7,-1
8000fd92:	f1 b7 04 c0 	satu	r7,0x6
8000fd96:	e0 47 00 20 	cp.w	r7,32
8000fd9a:	c1 54       	brge	8000fdc4 <__avr32_f64_div_res_subnormal+0x36>
8000fd9c:	ee 06 11 20 	rsub	r6,r7,32
8000fda0:	e4 07 0a 42 	lsr	r2,r2,r7
8000fda4:	e6 06 09 4c 	lsl	r12,r3,r6
8000fda8:	18 42       	or	r2,r12
8000fdaa:	e6 07 0a 43 	lsr	r3,r3,r7
8000fdae:	f4 06 09 41 	lsl	r1,r10,r6
8000fdb2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000fdb6:	f6 06 09 4c 	lsl	r12,r11,r6
8000fdba:	18 4a       	or	r10,r12
8000fdbc:	f6 07 0a 4b 	lsr	r11,r11,r7
8000fdc0:	30 00       	mov	r0,0
8000fdc2:	c1 58       	rjmp	8000fdec <__avr32_f64_div_res_subnormal+0x5e>
8000fdc4:	ee 06 11 20 	rsub	r6,r7,32
8000fdc8:	f9 b0 00 00 	moveq	r0,0
8000fdcc:	f9 bc 00 00 	moveq	r12,0
8000fdd0:	c0 50       	breq	8000fdda <__avr32_f64_div_res_subnormal+0x4c>
8000fdd2:	f4 06 09 40 	lsl	r0,r10,r6
8000fdd6:	f6 06 09 4c 	lsl	r12,r11,r6
8000fdda:	e6 07 0a 42 	lsr	r2,r3,r7
8000fdde:	30 03       	mov	r3,0
8000fde0:	f4 07 0a 41 	lsr	r1,r10,r7
8000fde4:	18 41       	or	r1,r12
8000fde6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000fdea:	30 0b       	mov	r11,0
8000fdec:	e0 12 ff 00 	andl	r2,0xff00
8000fdf0:	e8 12 00 80 	orl	r2,0x80
8000fdf4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000fdf8:	e4 09 07 46 	macu.d	r6,r2,r9
8000fdfc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fe00:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fe04:	0c 05       	add	r5,r6
8000fe06:	f0 07 00 48 	adc	r8,r8,r7
8000fe0a:	5c 09       	acr	r9
8000fe0c:	30 07       	mov	r7,0
8000fe0e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fe12:	00 34       	cp.w	r4,r0
8000fe14:	e2 05 13 00 	cpc	r5,r1
8000fe18:	c4 6b       	rjmp	8000fca4 <__avr32_f64_div_round_subnormal>
8000fe1a:	1c 9b       	mov	r11,lr
8000fe1c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fe20:	30 0a       	mov	r10,0
8000fe22:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fe26:	3f fb       	mov	r11,-1
8000fe28:	30 0a       	mov	r10,0
8000fe2a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fe2e:	f5 eb 10 04 	or	r4,r10,r11
8000fe32:	c0 90       	breq	8000fe44 <__avr32_f64_div_op1_zero>
8000fe34:	1c 9b       	mov	r11,lr
8000fe36:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fe3a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000fe3e:	30 0a       	mov	r10,0
8000fe40:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000fe44 <__avr32_f64_div_op1_zero>:
8000fe44:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000fe48:	ce f0       	breq	8000fe26 <__avr32_f64_div_res_subnormal+0x98>
8000fe4a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000fe4e:	e0 44 07 ff 	cp.w	r4,2047
8000fe52:	ce 41       	brne	8000fe1a <__avr32_f64_div_res_subnormal+0x8c>
8000fe54:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000fe58:	ce 10       	breq	8000fe1a <__avr32_f64_div_res_subnormal+0x8c>
8000fe5a:	ce 6b       	rjmp	8000fe26 <__avr32_f64_div_res_subnormal+0x98>

8000fe5c <__avr32_udiv64>:
8000fe5c:	d4 31       	pushm	r0-r7,lr
8000fe5e:	1a 97       	mov	r7,sp
8000fe60:	20 3d       	sub	sp,12
8000fe62:	10 9c       	mov	r12,r8
8000fe64:	12 9e       	mov	lr,r9
8000fe66:	14 93       	mov	r3,r10
8000fe68:	58 09       	cp.w	r9,0
8000fe6a:	e0 81 00 bd 	brne	8000ffe4 <__avr32_udiv64+0x188>
8000fe6e:	16 38       	cp.w	r8,r11
8000fe70:	e0 88 00 40 	brls	8000fef0 <__avr32_udiv64+0x94>
8000fe74:	f0 08 12 00 	clz	r8,r8
8000fe78:	c0 d0       	breq	8000fe92 <__avr32_udiv64+0x36>
8000fe7a:	f6 08 09 4b 	lsl	r11,r11,r8
8000fe7e:	f0 09 11 20 	rsub	r9,r8,32
8000fe82:	f8 08 09 4c 	lsl	r12,r12,r8
8000fe86:	f4 09 0a 49 	lsr	r9,r10,r9
8000fe8a:	f4 08 09 43 	lsl	r3,r10,r8
8000fe8e:	f3 eb 10 0b 	or	r11,r9,r11
8000fe92:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fe96:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fe9a:	f6 0e 0d 00 	divu	r0,r11,lr
8000fe9e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fea2:	00 99       	mov	r9,r0
8000fea4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fea8:	e0 0a 02 48 	mul	r8,r0,r10
8000feac:	10 3b       	cp.w	r11,r8
8000feae:	c0 a2       	brcc	8000fec2 <__avr32_udiv64+0x66>
8000feb0:	20 19       	sub	r9,1
8000feb2:	18 0b       	add	r11,r12
8000feb4:	18 3b       	cp.w	r11,r12
8000feb6:	c0 63       	brcs	8000fec2 <__avr32_udiv64+0x66>
8000feb8:	10 3b       	cp.w	r11,r8
8000feba:	f7 b9 03 01 	sublo	r9,1
8000febe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fec2:	f6 08 01 01 	sub	r1,r11,r8
8000fec6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000feca:	e2 0e 0d 00 	divu	r0,r1,lr
8000fece:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fed2:	00 98       	mov	r8,r0
8000fed4:	e0 0a 02 4a 	mul	r10,r0,r10
8000fed8:	14 33       	cp.w	r3,r10
8000feda:	c0 82       	brcc	8000feea <__avr32_udiv64+0x8e>
8000fedc:	20 18       	sub	r8,1
8000fede:	18 03       	add	r3,r12
8000fee0:	18 33       	cp.w	r3,r12
8000fee2:	c0 43       	brcs	8000feea <__avr32_udiv64+0x8e>
8000fee4:	14 33       	cp.w	r3,r10
8000fee6:	f7 b8 03 01 	sublo	r8,1
8000feea:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000feee:	cd f8       	rjmp	800100ac <__avr32_udiv64+0x250>
8000fef0:	58 08       	cp.w	r8,0
8000fef2:	c0 51       	brne	8000fefc <__avr32_udiv64+0xa0>
8000fef4:	30 19       	mov	r9,1
8000fef6:	f2 08 0d 08 	divu	r8,r9,r8
8000fefa:	10 9c       	mov	r12,r8
8000fefc:	f8 06 12 00 	clz	r6,r12
8000ff00:	c0 41       	brne	8000ff08 <__avr32_udiv64+0xac>
8000ff02:	18 1b       	sub	r11,r12
8000ff04:	30 19       	mov	r9,1
8000ff06:	c4 08       	rjmp	8000ff86 <__avr32_udiv64+0x12a>
8000ff08:	ec 01 11 20 	rsub	r1,r6,32
8000ff0c:	f4 01 0a 49 	lsr	r9,r10,r1
8000ff10:	f8 06 09 4c 	lsl	r12,r12,r6
8000ff14:	f6 06 09 48 	lsl	r8,r11,r6
8000ff18:	f6 01 0a 41 	lsr	r1,r11,r1
8000ff1c:	f3 e8 10 08 	or	r8,r9,r8
8000ff20:	f8 03 16 10 	lsr	r3,r12,0x10
8000ff24:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ff28:	e2 03 0d 00 	divu	r0,r1,r3
8000ff2c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ff30:	00 9e       	mov	lr,r0
8000ff32:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ff36:	e0 05 02 49 	mul	r9,r0,r5
8000ff3a:	12 3b       	cp.w	r11,r9
8000ff3c:	c0 a2       	brcc	8000ff50 <__avr32_udiv64+0xf4>
8000ff3e:	20 1e       	sub	lr,1
8000ff40:	18 0b       	add	r11,r12
8000ff42:	18 3b       	cp.w	r11,r12
8000ff44:	c0 63       	brcs	8000ff50 <__avr32_udiv64+0xf4>
8000ff46:	12 3b       	cp.w	r11,r9
8000ff48:	f7 be 03 01 	sublo	lr,1
8000ff4c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ff50:	12 1b       	sub	r11,r9
8000ff52:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ff56:	f6 03 0d 02 	divu	r2,r11,r3
8000ff5a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000ff5e:	04 99       	mov	r9,r2
8000ff60:	e4 05 02 4b 	mul	r11,r2,r5
8000ff64:	16 38       	cp.w	r8,r11
8000ff66:	c0 a2       	brcc	8000ff7a <__avr32_udiv64+0x11e>
8000ff68:	20 19       	sub	r9,1
8000ff6a:	18 08       	add	r8,r12
8000ff6c:	18 38       	cp.w	r8,r12
8000ff6e:	c0 63       	brcs	8000ff7a <__avr32_udiv64+0x11e>
8000ff70:	16 38       	cp.w	r8,r11
8000ff72:	f7 b9 03 01 	sublo	r9,1
8000ff76:	f1 dc e3 08 	addcs	r8,r8,r12
8000ff7a:	f4 06 09 43 	lsl	r3,r10,r6
8000ff7e:	f0 0b 01 0b 	sub	r11,r8,r11
8000ff82:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ff86:	f8 06 16 10 	lsr	r6,r12,0x10
8000ff8a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ff8e:	f6 06 0d 00 	divu	r0,r11,r6
8000ff92:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ff96:	00 9a       	mov	r10,r0
8000ff98:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ff9c:	e0 0e 02 48 	mul	r8,r0,lr
8000ffa0:	10 3b       	cp.w	r11,r8
8000ffa2:	c0 a2       	brcc	8000ffb6 <__avr32_udiv64+0x15a>
8000ffa4:	20 1a       	sub	r10,1
8000ffa6:	18 0b       	add	r11,r12
8000ffa8:	18 3b       	cp.w	r11,r12
8000ffaa:	c0 63       	brcs	8000ffb6 <__avr32_udiv64+0x15a>
8000ffac:	10 3b       	cp.w	r11,r8
8000ffae:	f7 ba 03 01 	sublo	r10,1
8000ffb2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ffb6:	f6 08 01 01 	sub	r1,r11,r8
8000ffba:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ffbe:	e2 06 0d 00 	divu	r0,r1,r6
8000ffc2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ffc6:	00 98       	mov	r8,r0
8000ffc8:	e0 0e 02 4b 	mul	r11,r0,lr
8000ffcc:	16 33       	cp.w	r3,r11
8000ffce:	c0 82       	brcc	8000ffde <__avr32_udiv64+0x182>
8000ffd0:	20 18       	sub	r8,1
8000ffd2:	18 03       	add	r3,r12
8000ffd4:	18 33       	cp.w	r3,r12
8000ffd6:	c0 43       	brcs	8000ffde <__avr32_udiv64+0x182>
8000ffd8:	16 33       	cp.w	r3,r11
8000ffda:	f7 b8 03 01 	sublo	r8,1
8000ffde:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ffe2:	c6 98       	rjmp	800100b4 <__avr32_udiv64+0x258>
8000ffe4:	16 39       	cp.w	r9,r11
8000ffe6:	e0 8b 00 65 	brhi	800100b0 <__avr32_udiv64+0x254>
8000ffea:	f2 09 12 00 	clz	r9,r9
8000ffee:	c0 b1       	brne	80010004 <__avr32_udiv64+0x1a8>
8000fff0:	10 3a       	cp.w	r10,r8
8000fff2:	5f 2a       	srhs	r10
8000fff4:	1c 3b       	cp.w	r11,lr
8000fff6:	5f b8       	srhi	r8
8000fff8:	10 4a       	or	r10,r8
8000fffa:	f2 0a 18 00 	cp.b	r10,r9
8000fffe:	c5 90       	breq	800100b0 <__avr32_udiv64+0x254>
80010000:	30 18       	mov	r8,1
80010002:	c5 98       	rjmp	800100b4 <__avr32_udiv64+0x258>
80010004:	f0 09 09 46 	lsl	r6,r8,r9
80010008:	f2 03 11 20 	rsub	r3,r9,32
8001000c:	fc 09 09 4e 	lsl	lr,lr,r9
80010010:	f0 03 0a 48 	lsr	r8,r8,r3
80010014:	f6 09 09 4c 	lsl	r12,r11,r9
80010018:	f4 03 0a 42 	lsr	r2,r10,r3
8001001c:	ef 46 ff f4 	st.w	r7[-12],r6
80010020:	f6 03 0a 43 	lsr	r3,r11,r3
80010024:	18 42       	or	r2,r12
80010026:	f1 ee 10 0c 	or	r12,r8,lr
8001002a:	f8 01 16 10 	lsr	r1,r12,0x10
8001002e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80010032:	e6 01 0d 04 	divu	r4,r3,r1
80010036:	e4 03 16 10 	lsr	r3,r2,0x10
8001003a:	08 9e       	mov	lr,r4
8001003c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80010040:	e8 06 02 48 	mul	r8,r4,r6
80010044:	10 33       	cp.w	r3,r8
80010046:	c0 a2       	brcc	8001005a <__avr32_udiv64+0x1fe>
80010048:	20 1e       	sub	lr,1
8001004a:	18 03       	add	r3,r12
8001004c:	18 33       	cp.w	r3,r12
8001004e:	c0 63       	brcs	8001005a <__avr32_udiv64+0x1fe>
80010050:	10 33       	cp.w	r3,r8
80010052:	f7 be 03 01 	sublo	lr,1
80010056:	e7 dc e3 03 	addcs	r3,r3,r12
8001005a:	10 13       	sub	r3,r8
8001005c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80010060:	e6 01 0d 00 	divu	r0,r3,r1
80010064:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80010068:	00 98       	mov	r8,r0
8001006a:	e0 06 02 46 	mul	r6,r0,r6
8001006e:	0c 3b       	cp.w	r11,r6
80010070:	c0 a2       	brcc	80010084 <__avr32_udiv64+0x228>
80010072:	20 18       	sub	r8,1
80010074:	18 0b       	add	r11,r12
80010076:	18 3b       	cp.w	r11,r12
80010078:	c0 63       	brcs	80010084 <__avr32_udiv64+0x228>
8001007a:	0c 3b       	cp.w	r11,r6
8001007c:	f7 dc e3 0b 	addcs	r11,r11,r12
80010080:	f7 b8 03 01 	sublo	r8,1
80010084:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80010088:	ee f4 ff f4 	ld.w	r4,r7[-12]
8001008c:	0c 1b       	sub	r11,r6
8001008e:	f0 04 06 42 	mulu.d	r2,r8,r4
80010092:	06 95       	mov	r5,r3
80010094:	16 35       	cp.w	r5,r11
80010096:	e0 8b 00 0a 	brhi	800100aa <__avr32_udiv64+0x24e>
8001009a:	5f 0b       	sreq	r11
8001009c:	f4 09 09 49 	lsl	r9,r10,r9
800100a0:	12 32       	cp.w	r2,r9
800100a2:	5f b9       	srhi	r9
800100a4:	f7 e9 00 09 	and	r9,r11,r9
800100a8:	c0 60       	breq	800100b4 <__avr32_udiv64+0x258>
800100aa:	20 18       	sub	r8,1
800100ac:	30 09       	mov	r9,0
800100ae:	c0 38       	rjmp	800100b4 <__avr32_udiv64+0x258>
800100b0:	30 09       	mov	r9,0
800100b2:	12 98       	mov	r8,r9
800100b4:	10 9a       	mov	r10,r8
800100b6:	12 93       	mov	r3,r9
800100b8:	10 92       	mov	r2,r8
800100ba:	12 9b       	mov	r11,r9
800100bc:	2f dd       	sub	sp,-12
800100be:	d8 32       	popm	r0-r7,pc

800100c0 <__avr32_umod64>:
800100c0:	d4 31       	pushm	r0-r7,lr
800100c2:	1a 97       	mov	r7,sp
800100c4:	20 3d       	sub	sp,12
800100c6:	10 9c       	mov	r12,r8
800100c8:	12 95       	mov	r5,r9
800100ca:	14 9e       	mov	lr,r10
800100cc:	16 91       	mov	r1,r11
800100ce:	16 96       	mov	r6,r11
800100d0:	58 09       	cp.w	r9,0
800100d2:	e0 81 00 81 	brne	800101d4 <__avr32_umod64+0x114>
800100d6:	16 38       	cp.w	r8,r11
800100d8:	e0 88 00 12 	brls	800100fc <__avr32_umod64+0x3c>
800100dc:	f0 08 12 00 	clz	r8,r8
800100e0:	c4 e0       	breq	8001017c <__avr32_umod64+0xbc>
800100e2:	f6 08 09 46 	lsl	r6,r11,r8
800100e6:	f8 08 09 4c 	lsl	r12,r12,r8
800100ea:	f0 0b 11 20 	rsub	r11,r8,32
800100ee:	f4 08 09 4e 	lsl	lr,r10,r8
800100f2:	f4 0b 0a 4b 	lsr	r11,r10,r11
800100f6:	f7 e6 10 06 	or	r6,r11,r6
800100fa:	c4 18       	rjmp	8001017c <__avr32_umod64+0xbc>
800100fc:	58 08       	cp.w	r8,0
800100fe:	c0 51       	brne	80010108 <__avr32_umod64+0x48>
80010100:	30 19       	mov	r9,1
80010102:	f2 08 0d 08 	divu	r8,r9,r8
80010106:	10 9c       	mov	r12,r8
80010108:	f8 08 12 00 	clz	r8,r12
8001010c:	c0 31       	brne	80010112 <__avr32_umod64+0x52>
8001010e:	18 16       	sub	r6,r12
80010110:	c3 68       	rjmp	8001017c <__avr32_umod64+0xbc>
80010112:	f0 03 11 20 	rsub	r3,r8,32
80010116:	f4 03 0a 4b 	lsr	r11,r10,r3
8001011a:	f8 08 09 4c 	lsl	r12,r12,r8
8001011e:	ec 08 09 49 	lsl	r9,r6,r8
80010122:	ec 03 0a 43 	lsr	r3,r6,r3
80010126:	f7 e9 10 09 	or	r9,r11,r9
8001012a:	f8 05 16 10 	lsr	r5,r12,0x10
8001012e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80010132:	e6 05 0d 02 	divu	r2,r3,r5
80010136:	f2 0e 16 10 	lsr	lr,r9,0x10
8001013a:	ec 02 02 4b 	mul	r11,r6,r2
8001013e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
80010142:	16 3e       	cp.w	lr,r11
80010144:	c0 72       	brcc	80010152 <__avr32_umod64+0x92>
80010146:	18 0e       	add	lr,r12
80010148:	18 3e       	cp.w	lr,r12
8001014a:	c0 43       	brcs	80010152 <__avr32_umod64+0x92>
8001014c:	16 3e       	cp.w	lr,r11
8001014e:	fd dc e3 0e 	addcs	lr,lr,r12
80010152:	fc 0b 01 03 	sub	r3,lr,r11
80010156:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8001015a:	e6 05 0d 02 	divu	r2,r3,r5
8001015e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80010162:	a5 36       	mul	r6,r2
80010164:	0c 39       	cp.w	r9,r6
80010166:	c0 72       	brcc	80010174 <__avr32_umod64+0xb4>
80010168:	18 09       	add	r9,r12
8001016a:	18 39       	cp.w	r9,r12
8001016c:	c0 43       	brcs	80010174 <__avr32_umod64+0xb4>
8001016e:	0c 39       	cp.w	r9,r6
80010170:	f3 dc e3 09 	addcs	r9,r9,r12
80010174:	f2 06 01 06 	sub	r6,r9,r6
80010178:	f4 08 09 4e 	lsl	lr,r10,r8
8001017c:	f8 0a 16 10 	lsr	r10,r12,0x10
80010180:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80010184:	ec 0a 0d 02 	divu	r2,r6,r10
80010188:	fc 09 16 10 	lsr	r9,lr,0x10
8001018c:	ea 02 02 4b 	mul	r11,r5,r2
80010190:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80010194:	16 39       	cp.w	r9,r11
80010196:	c0 72       	brcc	800101a4 <__avr32_umod64+0xe4>
80010198:	18 09       	add	r9,r12
8001019a:	18 39       	cp.w	r9,r12
8001019c:	c0 43       	brcs	800101a4 <__avr32_umod64+0xe4>
8001019e:	16 39       	cp.w	r9,r11
800101a0:	f3 dc e3 09 	addcs	r9,r9,r12
800101a4:	f2 0b 01 0b 	sub	r11,r9,r11
800101a8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800101ac:	f6 0a 0d 0a 	divu	r10,r11,r10
800101b0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
800101b4:	ea 0a 02 4a 	mul	r10,r5,r10
800101b8:	14 3e       	cp.w	lr,r10
800101ba:	c0 72       	brcc	800101c8 <__avr32_umod64+0x108>
800101bc:	18 0e       	add	lr,r12
800101be:	18 3e       	cp.w	lr,r12
800101c0:	c0 43       	brcs	800101c8 <__avr32_umod64+0x108>
800101c2:	14 3e       	cp.w	lr,r10
800101c4:	fd dc e3 0e 	addcs	lr,lr,r12
800101c8:	fc 0a 01 0a 	sub	r10,lr,r10
800101cc:	30 0b       	mov	r11,0
800101ce:	f4 08 0a 4a 	lsr	r10,r10,r8
800101d2:	c7 b8       	rjmp	800102c8 <__avr32_umod64+0x208>
800101d4:	16 39       	cp.w	r9,r11
800101d6:	e0 8b 00 79 	brhi	800102c8 <__avr32_umod64+0x208>
800101da:	f2 09 12 00 	clz	r9,r9
800101de:	c1 21       	brne	80010202 <__avr32_umod64+0x142>
800101e0:	10 3a       	cp.w	r10,r8
800101e2:	5f 2b       	srhs	r11
800101e4:	0a 31       	cp.w	r1,r5
800101e6:	5f ba       	srhi	r10
800101e8:	f7 ea 10 0a 	or	r10,r11,r10
800101ec:	f2 0a 18 00 	cp.b	r10,r9
800101f0:	c0 60       	breq	800101fc <__avr32_umod64+0x13c>
800101f2:	fc 08 01 0c 	sub	r12,lr,r8
800101f6:	e2 05 01 46 	sbc	r6,r1,r5
800101fa:	18 9e       	mov	lr,r12
800101fc:	0c 9b       	mov	r11,r6
800101fe:	1c 9a       	mov	r10,lr
80010200:	c6 48       	rjmp	800102c8 <__avr32_umod64+0x208>
80010202:	ea 09 09 4c 	lsl	r12,r5,r9
80010206:	f2 06 11 20 	rsub	r6,r9,32
8001020a:	f6 09 09 4b 	lsl	r11,r11,r9
8001020e:	f0 09 09 42 	lsl	r2,r8,r9
80010212:	ef 46 ff f4 	st.w	r7[-12],r6
80010216:	f0 06 0a 48 	lsr	r8,r8,r6
8001021a:	18 48       	or	r8,r12
8001021c:	e2 06 0a 4c 	lsr	r12,r1,r6
80010220:	f4 09 09 43 	lsl	r3,r10,r9
80010224:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
80010228:	f4 06 0a 4a 	lsr	r10,r10,r6
8001022c:	16 4a       	or	r10,r11
8001022e:	f0 0b 16 10 	lsr	r11,r8,0x10
80010232:	f8 0b 0d 04 	divu	r4,r12,r11
80010236:	f4 0c 16 10 	lsr	r12,r10,0x10
8001023a:	08 91       	mov	r1,r4
8001023c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
80010240:	e8 0e 02 46 	mul	r6,r4,lr
80010244:	0c 3c       	cp.w	r12,r6
80010246:	c0 a2       	brcc	8001025a <__avr32_umod64+0x19a>
80010248:	20 11       	sub	r1,1
8001024a:	10 0c       	add	r12,r8
8001024c:	10 3c       	cp.w	r12,r8
8001024e:	c0 63       	brcs	8001025a <__avr32_umod64+0x19a>
80010250:	0c 3c       	cp.w	r12,r6
80010252:	f7 b1 03 01 	sublo	r1,1
80010256:	f9 d8 e3 0c 	addcs	r12,r12,r8
8001025a:	0c 1c       	sub	r12,r6
8001025c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
80010260:	f8 0b 0d 04 	divu	r4,r12,r11
80010264:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
80010268:	08 96       	mov	r6,r4
8001026a:	e8 0e 02 4e 	mul	lr,r4,lr
8001026e:	1c 3b       	cp.w	r11,lr
80010270:	c0 a2       	brcc	80010284 <__avr32_umod64+0x1c4>
80010272:	20 16       	sub	r6,1
80010274:	10 0b       	add	r11,r8
80010276:	10 3b       	cp.w	r11,r8
80010278:	c0 63       	brcs	80010284 <__avr32_umod64+0x1c4>
8001027a:	1c 3b       	cp.w	r11,lr
8001027c:	f7 b6 03 01 	sublo	r6,1
80010280:	f7 d8 e3 0b 	addcs	r11,r11,r8
80010284:	ed e1 11 01 	or	r1,r6,r1<<0x10
80010288:	1c 1b       	sub	r11,lr
8001028a:	e2 02 06 40 	mulu.d	r0,r1,r2
8001028e:	00 9e       	mov	lr,r0
80010290:	02 9c       	mov	r12,r1
80010292:	16 3c       	cp.w	r12,r11
80010294:	e0 8b 00 08 	brhi	800102a4 <__avr32_umod64+0x1e4>
80010298:	5f 06       	sreq	r6
8001029a:	06 30       	cp.w	r0,r3
8001029c:	5f ba       	srhi	r10
8001029e:	ed ea 00 0a 	and	r10,r6,r10
800102a2:	c0 60       	breq	800102ae <__avr32_umod64+0x1ee>
800102a4:	fc 02 01 04 	sub	r4,lr,r2
800102a8:	f8 08 01 4c 	sbc	r12,r12,r8
800102ac:	08 9e       	mov	lr,r4
800102ae:	e6 0e 01 0a 	sub	r10,r3,lr
800102b2:	f6 0c 01 4c 	sbc	r12,r11,r12
800102b6:	ee f1 ff f4 	ld.w	r1,r7[-12]
800102ba:	f8 09 0a 4b 	lsr	r11,r12,r9
800102be:	f4 09 0a 4a 	lsr	r10,r10,r9
800102c2:	f8 01 09 4c 	lsl	r12,r12,r1
800102c6:	18 4a       	or	r10,r12
800102c8:	2f dd       	sub	sp,-12
800102ca:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010400 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010400:	c0 08       	rjmp	80010400 <_evba>
	...

80010404 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010404:	c0 08       	rjmp	80010404 <_handle_TLB_Multiple_Hit>
	...

80010408 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010408:	c0 08       	rjmp	80010408 <_handle_Bus_Error_Data_Fetch>
	...

8001040c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8001040c:	c0 08       	rjmp	8001040c <_handle_Bus_Error_Instruction_Fetch>
	...

80010410 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010410:	c0 08       	rjmp	80010410 <_handle_NMI>
	...

80010414 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010414:	c0 08       	rjmp	80010414 <_handle_Instruction_Address>
	...

80010418 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010418:	c0 08       	rjmp	80010418 <_handle_ITLB_Protection>
	...

8001041c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8001041c:	c0 08       	rjmp	8001041c <_handle_Breakpoint>
	...

80010420 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010420:	c0 08       	rjmp	80010420 <_handle_Illegal_Opcode>
	...

80010424 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010424:	c0 08       	rjmp	80010424 <_handle_Unimplemented_Instruction>
	...

80010428 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010428:	c0 08       	rjmp	80010428 <_handle_Privilege_Violation>
	...

8001042c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8001042c:	c0 08       	rjmp	8001042c <_handle_Floating_Point>
	...

80010430 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010430:	c0 08       	rjmp	80010430 <_handle_Coprocessor_Absent>
	...

80010434 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010434:	c0 08       	rjmp	80010434 <_handle_Data_Address_Read>
	...

80010438 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010438:	c0 08       	rjmp	80010438 <_handle_Data_Address_Write>
	...

8001043c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8001043c:	c0 08       	rjmp	8001043c <_handle_DTLB_Protection_Read>
	...

80010440 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010440:	c0 08       	rjmp	80010440 <_handle_DTLB_Protection_Write>
	...

80010444 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010444:	c0 08       	rjmp	80010444 <_handle_DTLB_Modified>
	...

80010450 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010450:	c0 08       	rjmp	80010450 <_handle_ITLB_Miss>
	...

80010460 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010460:	c0 08       	rjmp	80010460 <_handle_DTLB_Miss_Read>
	...

80010470 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010470:	c0 08       	rjmp	80010470 <_handle_DTLB_Miss_Write>
	...

80010500 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010500:	fe cf 73 08 	sub	pc,pc,29448

80010504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010504:	30 0c       	mov	r12,0
80010506:	fe b0 ae 45 	rcall	80006190 <_get_interrupt_handler>
8001050a:	58 0c       	cp.w	r12,0
8001050c:	f8 0f 17 10 	movne	pc,r12
80010510:	d6 03       	rete

80010512 <_int1>:
80010512:	30 1c       	mov	r12,1
80010514:	fe b0 ae 3e 	rcall	80006190 <_get_interrupt_handler>
80010518:	58 0c       	cp.w	r12,0
8001051a:	f8 0f 17 10 	movne	pc,r12
8001051e:	d6 03       	rete

80010520 <_int2>:
80010520:	30 2c       	mov	r12,2
80010522:	fe b0 ae 37 	rcall	80006190 <_get_interrupt_handler>
80010526:	58 0c       	cp.w	r12,0
80010528:	f8 0f 17 10 	movne	pc,r12
8001052c:	d6 03       	rete

8001052e <_int3>:
8001052e:	30 3c       	mov	r12,3
80010530:	fe b0 ae 30 	rcall	80006190 <_get_interrupt_handler>
80010534:	58 0c       	cp.w	r12,0
80010536:	f8 0f 17 10 	movne	pc,r12
8001053a:	d6 03       	rete

8001053c <ipr_val>:
8001053c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8001054c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001055c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001056c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001057c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001058c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001059c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800105ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800105bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800105cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800105dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800105ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800105fc:	d7 03 d7 03                                         ....
