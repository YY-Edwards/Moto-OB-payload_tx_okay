
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009b48  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000bc00  8000bc00  0000c000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001130  8000be00  8000be00  0000c200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a3c  00000008  8000cf30  0000d408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a44  8000d96c  0000de44  2**0
                  ALLOC
  8 .bss          000036d0  00000a48  00000a48  00000000  2**2
                  ALLOC
  9 .heap         00012ee8  00004118  00004118  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000de44  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001040  00000000  00000000  0000de78  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000230b  00000000  00000000  0000eeb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00026349  00000000  00000000  000111c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000062d8  00000000  00000000  0003750c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000bc5e  00000000  00000000  0003d7e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002adc  00000000  00000000  00049444  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000069fe  00000000  00000000  0004bf20  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000c2bd  00000000  00000000  0005291e  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001138  00000000  00000000  0005ebe0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9d d4 	sub	pc,pc,-25132

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf bd d8 	sub	pc,pc,-16936

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 84       	ld.ub	r4,r6[0x0]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 64       	and	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 90       	sub	r0,-119
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 30       	sub	r0,-109
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e cc       	mov	r12,-20
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	be 00       	st.h	pc[0x0],r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 bc       	sub	r12,123
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	59 90       	cp.w	r0,25
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	be 08       	st.h	pc[0x0],r8
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	5d 54       	*unknown*

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	be 0c       	st.h	pc[0x0],r12
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	5d 54       	*unknown*

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	be 2c       	st.h	pc[0x4],r12
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	5d 54       	*unknown*

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	be 48       	st.h	pc[0x8],r8
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	5d 54       	*unknown*

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	be 64       	st.h	pc[0xc],r4
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	5d 54       	*unknown*

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	be 7c       	st.h	pc[0xe],r12
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	5d 54       	*unknown*
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	be 94       	st.b	pc[0x1],r4
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	be a8       	st.b	pc[0x2],r8
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	be c0       	st.b	pc[0x4],r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	be dc       	st.b	pc[0x5],r12

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000216a:	19 a9       	ld.ub	r9,r12[0x2]
8000216c:	31 18       	mov	r8,17
8000216e:	f0 09 18 00 	cp.b	r9,r8
80002172:	c0 41       	brne	8000217a <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002174:	48 2c       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x14>
80002176:	f0 1f 00 03 	mcall	80002180 <SingleDetection_brdcst_func+0x18>
8000217a:	d8 02       	popm	pc
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	be f4       	st.b	pc[0x7],r4
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	5d 54       	*unknown*

80002184 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002184:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002186:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000218a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000218c:	4a bc       	lddpc	r12,80002238 <ButtonConfig_brdcst_func+0xb4>
8000218e:	f0 1f 00 2c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002192:	0f 88       	ld.ub	r8,r7[0x0]
80002194:	1a d8       	st.w	--sp,r8
80002196:	4a bc       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xbc>
80002198:	f0 1f 00 29 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000219c:	1a d5       	st.w	--sp,r5
8000219e:	4a ac       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc0>
800021a0:	f0 1f 00 27 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a4:	0f a8       	ld.ub	r8,r7[0x2]
800021a6:	1a d8       	st.w	--sp,r8
800021a8:	4a 8c       	lddpc	r12,80002248 <ButtonConfig_brdcst_func+0xc4>
800021aa:	f0 1f 00 25 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ae:	2f dd       	sub	sp,-12
800021b0:	58 05       	cp.w	r5,0
800021b2:	c4 10       	breq	80002234 <ButtonConfig_brdcst_func+0xb0>
800021b4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b6:	4a 64       	lddpc	r4,8000224c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b8:	4a 63       	lddpc	r3,80002250 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ba:	4a 72       	lddpc	r2,80002254 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021bc:	4a 71       	lddpc	r1,80002258 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021be:	4a 80       	lddpc	r0,8000225c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c0:	0f b9       	ld.ub	r9,r7[0x3]
800021c2:	0f c8       	ld.ub	r8,r7[0x4]
800021c4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c8:	1a d8       	st.w	--sp,r8
800021ca:	1a d6       	st.w	--sp,r6
800021cc:	08 9c       	mov	r12,r4
800021ce:	f0 1f 00 1c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d2:	0f d9       	ld.ub	r9,r7[0x5]
800021d4:	0f e8       	ld.ub	r8,r7[0x6]
800021d6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021da:	1a d8       	st.w	--sp,r8
800021dc:	1a d6       	st.w	--sp,r6
800021de:	06 9c       	mov	r12,r3
800021e0:	f0 1f 00 17 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e4:	0f f9       	ld.ub	r9,r7[0x7]
800021e6:	ef 38 00 08 	ld.ub	r8,r7[8]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	04 9c       	mov	r12,r2
800021f4:	f0 1f 00 12 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f8:	ef 39 00 09 	ld.ub	r9,r7[9]
800021fc:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002200:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002204:	1a d8       	st.w	--sp,r8
80002206:	1a d6       	st.w	--sp,r6
80002208:	02 9c       	mov	r12,r1
8000220a:	f0 1f 00 0d 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220e:	2f 8d       	sub	sp,-32
80002210:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002214:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	00 9c       	mov	r12,r0
80002222:	f0 1f 00 07 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
80002226:	2f f6       	sub	r6,-1
80002228:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000222a:	2f ed       	sub	sp,-8
8000222c:	ec 05 18 00 	cp.b	r5,r6
80002230:	fe 9b ff c8 	brhi	800021c0 <ButtonConfig_brdcst_func+0x3c>
80002234:	d8 32       	popm	r0-r7,pc
80002236:	00 00       	add	r0,r0
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	bf 08       	ld.d	r8,pc
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	5d 54       	*unknown*
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	bf 28       	st.d	pc++,r8
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	bf 3c       	mul	r12,pc
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	bf 54       	asr	r4,0x1f
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	bf 74       	lsl	r4,0x1f
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	bf 9c       	lsr	r12,0x1f
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	bf c4       	cbr	r4,0x1e
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	bf e8       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	c0 10       	breq	80002260 <Phyuserinput_brdcst_func>

80002260 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002260:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002264:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
80002266:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002268:	19 c7       	ld.ub	r7,r12[0x4]
8000226a:	19 d8       	ld.ub	r8,r12[0x5]
8000226c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002270:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002272:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002274:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002278:	49 0c       	lddpc	r12,800022b8 <Phyuserinput_brdcst_func+0x58>
8000227a:	f0 1f 00 11 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000227e:	1a d6       	st.w	--sp,r6
80002280:	49 0c       	lddpc	r12,800022c0 <Phyuserinput_brdcst_func+0x60>
80002282:	f0 1f 00 0f 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002286:	1a d5       	st.w	--sp,r5
80002288:	48 fc       	lddpc	r12,800022c4 <Phyuserinput_brdcst_func+0x64>
8000228a:	f0 1f 00 0d 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000228e:	5c 77       	castu.h	r7
80002290:	1a d7       	st.w	--sp,r7
80002292:	48 ec       	lddpc	r12,800022c8 <Phyuserinput_brdcst_func+0x68>
80002294:	f0 1f 00 0a 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002298:	1a d4       	st.w	--sp,r4
8000229a:	48 dc       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x6c>
8000229c:	f0 1f 00 08 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022a0:	1a d3       	st.w	--sp,r3
800022a2:	48 cc       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x70>
800022a4:	f0 1f 00 06 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022a8:	1a d2       	st.w	--sp,r2
800022aa:	48 bc       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x74>
800022ac:	f0 1f 00 04 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
800022b0:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022b2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022b6:	00 00       	add	r0,r0
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c0 34       	brge	800022c0 <Phyuserinput_brdcst_func+0x60>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	5d 54       	*unknown*
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	c0 58       	rjmp	800022cc <Phyuserinput_brdcst_func+0x6c>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c0 70       	breq	800022d4 <Phyuserinput_brdcst_func+0x74>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c0 84       	brge	800022da <ButtonConfig_reply_func+0x2>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c0 98       	rjmp	800022e0 <ButtonConfig_reply_func+0x8>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c0 ac       	rcall	800022e6 <ButtonConfig_reply_func+0xe>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c0 cc       	rcall	800022ee <ButtonConfig_reply_func+0x16>

800022d8 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022dc:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022e0:	0f 89       	ld.ub	r9,r7[0x0]
800022e2:	30 08       	mov	r8,0
800022e4:	f0 09 18 00 	cp.b	r9,r8
800022e8:	c0 c1       	brne	80002300 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022ea:	48 9c       	lddpc	r12,8000230c <ButtonConfig_reply_func+0x34>
800022ec:	f0 1f 00 09 	mcall	80002310 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022f0:	0f 98       	ld.ub	r8,r7[0x1]
800022f2:	1a d8       	st.w	--sp,r8
800022f4:	48 8c       	lddpc	r12,80002314 <ButtonConfig_reply_func+0x3c>
800022f6:	f0 1f 00 07 	mcall	80002310 <ButtonConfig_reply_func+0x38>
800022fa:	2f fd       	sub	sp,-4
800022fc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002300:	48 6c       	lddpc	r12,80002318 <ButtonConfig_reply_func+0x40>
80002302:	f0 1f 00 04 	mcall	80002310 <ButtonConfig_reply_func+0x38>
80002306:	e3 cd 80 80 	ldm	sp++,r7,pc
8000230a:	00 00       	add	r0,r0
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	c0 ec       	rcall	8000232a <DataSession_brdcst_func+0xe>
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	5d 54       	*unknown*
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	bf 28       	st.d	pc++,r8
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	c1 04       	brge	8000233a <DataSession_brdcst_func+0x1e>

8000231c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000231c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000231e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002322:	0d 88       	ld.ub	r8,r6[0x0]
80002324:	32 49       	mov	r9,36
80002326:	f2 08 18 00 	cp.b	r8,r9
8000232a:	c2 91       	brne	8000237c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000232c:	49 7c       	lddpc	r12,80002388 <DataSession_brdcst_func+0x6c>
8000232e:	f0 1f 00 18 	mcall	8000238c <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002332:	0d a5       	ld.ub	r5,r6[0x2]
80002334:	0d b8       	ld.ub	r8,r6[0x3]
80002336:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000233a:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000233c:	0d 98       	ld.ub	r8,r6[0x1]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	49 4c       	lddpc	r12,80002390 <DataSession_brdcst_func+0x74>
80002342:	f0 1f 00 13 	mcall	8000238c <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002346:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000234a:	1a d8       	st.w	--sp,r8
8000234c:	49 2c       	lddpc	r12,80002394 <DataSession_brdcst_func+0x78>
8000234e:	f0 1f 00 10 	mcall	8000238c <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002352:	2f ed       	sub	sp,-8
80002354:	58 05       	cp.w	r5,0
80002356:	c1 80       	breq	80002386 <DataSession_brdcst_func+0x6a>
80002358:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000235a:	49 04       	lddpc	r4,80002398 <DataSession_brdcst_func+0x7c>
8000235c:	ec 07 00 08 	add	r8,r6,r7
80002360:	11 c8       	ld.ub	r8,r8[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	1a d7       	st.w	--sp,r7
80002366:	08 9c       	mov	r12,r4
80002368:	f0 1f 00 09 	mcall	8000238c <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000236c:	2f f7       	sub	r7,-1
8000236e:	5c 57       	castu.b	r7
80002370:	2f ed       	sub	sp,-8
80002372:	ee 05 19 00 	cp.h	r5,r7
80002376:	fe 9b ff f3 	brhi	8000235c <DataSession_brdcst_func+0x40>
8000237a:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
8000237c:	1a d8       	st.w	--sp,r8
8000237e:	48 8c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x80>
80002380:	f0 1f 00 03 	mcall	8000238c <DataSession_brdcst_func+0x70>
80002384:	2f fd       	sub	sp,-4
80002386:	d8 22       	popm	r4-r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	c1 20       	breq	800023ae <DataSession_reply_func+0xe>
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	5d 54       	*unknown*
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	c1 34       	brge	800023b8 <DataSession_reply_func+0x18>
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	c1 4c       	rcall	800023be <DataSession_reply_func+0x1e>
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c1 68       	rjmp	800023c6 <DataSession_reply_func+0x26>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	c1 80       	breq	800023ce <DataSession_reply_func+0x2e>

800023a0 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023a0:	eb cd 40 80 	pushm	r7,lr
800023a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023a6:	19 a8       	ld.ub	r8,r12[0x2]
800023a8:	58 08       	cp.w	r8,0
800023aa:	c0 61       	brne	800023b6 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023ac:	48 dc       	lddpc	r12,800023e0 <DataSession_reply_func+0x40>
800023ae:	f0 1f 00 0e 	mcall	800023e4 <DataSession_reply_func+0x44>
800023b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023b6:	1a d8       	st.w	--sp,r8
800023b8:	48 cc       	lddpc	r12,800023e8 <DataSession_reply_func+0x48>
800023ba:	f0 1f 00 0b 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023be:	48 cc       	lddpc	r12,800023ec <DataSession_reply_func+0x4c>
800023c0:	f0 1f 00 09 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023c4:	0f b8       	ld.ub	r8,r7[0x3]
800023c6:	1a d8       	st.w	--sp,r8
800023c8:	48 ac       	lddpc	r12,800023f0 <DataSession_reply_func+0x50>
800023ca:	f0 1f 00 07 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023ce:	0f c8       	ld.ub	r8,r7[0x4]
800023d0:	1a d8       	st.w	--sp,r8
800023d2:	48 9c       	lddpc	r12,800023f4 <DataSession_reply_func+0x54>
800023d4:	f0 1f 00 04 	mcall	800023e4 <DataSession_reply_func+0x44>
800023d8:	2f dd       	sub	sp,-12
800023da:	e3 cd 80 80 	ldm	sp++,r7,pc
800023de:	00 00       	add	r0,r0
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	c1 94       	brge	80002414 <CallControl_brdcst_func+0x1c>
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	5d 54       	*unknown*
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	c1 a8       	rjmp	8000241e <CallControl_brdcst_func+0x26>
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	c1 bc       	rcall	80002424 <CallControl_brdcst_func+0x2c>
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	c1 d0       	breq	8000242c <CallControl_brdcst_func+0x34>
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	c1 e0       	breq	80002432 <CallControl_brdcst_func+0x3a>

800023f8 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002400:	0f 98       	ld.ub	r8,r7[0x1]
80002402:	1a d8       	st.w	--sp,r8
80002404:	48 bc       	lddpc	r12,80002430 <CallControl_brdcst_func+0x38>
80002406:	f0 1f 00 0c 	mcall	80002434 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000240a:	2f fd       	sub	sp,-4
8000240c:	0f 99       	ld.ub	r9,r7[0x1]
8000240e:	30 38       	mov	r8,3
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c0 41       	brne	8000241c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002416:	30 09       	mov	r9,0
80002418:	48 88       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000241a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 48       	mov	r8,4
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002426:	30 19       	mov	r9,1
80002428:	48 48       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
8000242c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	c1 f0       	breq	80002470 <TransmitControl_brdcst_func+0x34>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	5d 54       	*unknown*
80002438:	00 00       	add	r0,r0
8000243a:	0a 52       	eor	r2,r5

8000243c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000243c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002440:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002444:	0f 99       	ld.ub	r9,r7[0x1]
80002446:	30 08       	mov	r8,0
80002448:	f0 09 18 00 	cp.b	r9,r8
8000244c:	c0 71       	brne	8000245a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000244e:	48 ac       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x38>
80002450:	f0 1f 00 0a 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002454:	30 09       	mov	r9,0
80002456:	48 a8       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
80002458:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000245a:	0f 99       	ld.ub	r9,r7[0x1]
8000245c:	30 18       	mov	r8,1
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 71       	brne	80002470 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002464:	48 7c       	lddpc	r12,80002480 <TransmitControl_brdcst_func+0x44>
80002466:	f0 1f 00 05 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000246a:	30 19       	mov	r9,1
8000246c:	48 48       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
8000246e:	b0 89       	st.b	r8[0x0],r9
80002470:	e3 cd 80 80 	ldm	sp++,r7,pc
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c2 08       	rjmp	800024b6 <TransmitControl_reply_func+0x32>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	5d 54       	*unknown*
8000247c:	00 00       	add	r0,r0
8000247e:	0a 51       	eor	r1,r5
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c2 20       	breq	800024c6 <TransmitControl_reply_func+0x42>

80002484 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000248c:	0f 89       	ld.ub	r9,r7[0x0]
8000248e:	30 08       	mov	r8,0
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c1 61       	brne	800024c0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002496:	48 ec       	lddpc	r12,800024cc <TransmitControl_reply_func+0x48>
80002498:	f0 1f 00 0e 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000249c:	0f 98       	ld.ub	r8,r7[0x1]
8000249e:	1a d8       	st.w	--sp,r8
800024a0:	48 dc       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x50>
800024a2:	f0 1f 00 0c 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024a6:	0f a8       	ld.ub	r8,r7[0x2]
800024a8:	1a d8       	st.w	--sp,r8
800024aa:	48 cc       	lddpc	r12,800024d8 <TransmitControl_reply_func+0x54>
800024ac:	f0 1f 00 09 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024b0:	0f b8       	ld.ub	r8,r7[0x3]
800024b2:	1a d8       	st.w	--sp,r8
800024b4:	48 ac       	lddpc	r12,800024dc <TransmitControl_reply_func+0x58>
800024b6:	f0 1f 00 07 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024ba:	2f dd       	sub	sp,-12
800024bc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024c0:	48 8c       	lddpc	r12,800024e0 <TransmitControl_reply_func+0x5c>
800024c2:	f0 1f 00 04 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ca:	00 00       	add	r0,r0
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	c2 34       	brge	80002514 <Volume_reply_func>
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	5d 54       	*unknown*
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	c2 50       	breq	80002520 <Volume_reply_func+0xc>
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	c2 64       	brge	80002526 <Volume_reply_func+0x12>
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	c2 80       	breq	8000252e <Volume_reply_func+0x1a>
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	c2 90       	breq	80002534 <Volume_reply_func+0x20>

800024e4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024e6:	19 a9       	ld.ub	r9,r12[0x2]
800024e8:	30 08       	mov	r8,0
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
800024f0:	48 5c       	lddpc	r12,80002504 <AudioRoutingControl_reply_func+0x20>
800024f2:	f0 1f 00 06 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
800024f6:	f0 1f 00 06 	mcall	8000250c <AudioRoutingControl_reply_func+0x28>
800024fa:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024fc:	48 5c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x2c>
800024fe:	f0 1f 00 03 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
80002502:	d8 02       	popm	pc
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	c2 a8       	rjmp	8000255a <Volume_reply_func+0x46>
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	5d 54       	*unknown*
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	3f cc       	mov	r12,-4
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	c2 b8       	rjmp	80002568 <Volume_reply_func+0x54>

80002514 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002514:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002518:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000251c:	0f 89       	ld.ub	r9,r7[0x0]
8000251e:	30 08       	mov	r8,0
80002520:	f0 09 18 00 	cp.b	r9,r8
80002524:	c1 b1       	brne	8000255a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002526:	0f b8       	ld.ub	r8,r7[0x3]
80002528:	31 09       	mov	r9,16
8000252a:	f2 08 18 00 	cp.b	r8,r9
8000252e:	c0 f1       	brne	8000254c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002530:	48 dc       	lddpc	r12,80002564 <Volume_reply_func+0x50>
80002532:	f0 1f 00 0e 	mcall	80002568 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002536:	0f 99       	ld.ub	r9,r7[0x1]
80002538:	0f a8       	ld.ub	r8,r7[0x2]
8000253a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 bc       	lddpc	r12,8000256c <Volume_reply_func+0x58>
80002542:	f0 1f 00 0a 	mcall	80002568 <Volume_reply_func+0x54>
80002546:	2f fd       	sub	sp,-4
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 9c       	lddpc	r12,80002570 <Volume_reply_func+0x5c>
80002550:	f0 1f 00 06 	mcall	80002568 <Volume_reply_func+0x54>
80002554:	2f fd       	sub	sp,-4
80002556:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000255a:	48 7c       	lddpc	r12,80002574 <Volume_reply_func+0x60>
8000255c:	f0 1f 00 03 	mcall	80002568 <Volume_reply_func+0x54>
80002560:	e3 cd 80 80 	ldm	sp++,r7,pc
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c2 cc       	rcall	800025be <spk_reply_func+0xe>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	5d 54       	*unknown*
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c2 e0       	breq	800025ca <spk_reply_func+0x1a>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	c2 fc       	rcall	800025d0 <spk_reply_func+0x20>
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	c3 14       	brge	800025d8 <spk_reply_func+0x28>

80002578 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000257a:	19 d9       	ld.ub	r9,r12[0x5]
8000257c:	30 08       	mov	r8,0
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 81       	brne	80002592 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002584:	10 99       	mov	r9,r8
80002586:	48 78       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002588:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000258a:	48 7c       	lddpc	r12,800025a4 <spk_brdcst_func+0x2c>
8000258c:	f0 1f 00 07 	mcall	800025a8 <spk_brdcst_func+0x30>
80002590:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002592:	30 19       	mov	r9,1
80002594:	48 38       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002596:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002598:	48 5c       	lddpc	r12,800025ac <spk_brdcst_func+0x34>
8000259a:	f0 1f 00 04 	mcall	800025a8 <spk_brdcst_func+0x30>
8000259e:	d8 02       	popm	pc
800025a0:	00 00       	add	r0,r0
800025a2:	0a 48       	or	r8,r5
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	c3 2c       	rcall	8000260a <mic_brdcst_func+0x12>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	5d 54       	*unknown*
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	c3 3c       	rcall	80002614 <mic_brdcst_func+0x1c>

800025b0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025b2:	19 a9       	ld.ub	r9,r12[0x2]
800025b4:	30 08       	mov	r8,0
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 f1       	brne	800025d8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025bc:	19 e9       	ld.ub	r9,r12[0x6]
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 40       	breq	800025ca <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025c4:	30 19       	mov	r9,1
800025c6:	48 98       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025ca:	19 e8       	ld.ub	r8,r12[0x6]
800025cc:	1a d8       	st.w	--sp,r8
800025ce:	48 8c       	lddpc	r12,800025ec <spk_reply_func+0x3c>
800025d0:	f0 1f 00 08 	mcall	800025f0 <spk_reply_func+0x40>
800025d4:	2f fd       	sub	sp,-4
800025d6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025d8:	30 09       	mov	r9,0
800025da:	48 48       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025dc:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025de:	48 6c       	lddpc	r12,800025f4 <spk_reply_func+0x44>
800025e0:	f0 1f 00 04 	mcall	800025f0 <spk_reply_func+0x40>
800025e4:	d8 02       	popm	pc
800025e6:	00 00       	add	r0,r0
800025e8:	00 00       	add	r0,r0
800025ea:	0a 48       	or	r8,r5
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	c3 48       	rjmp	80002656 <mic_reply_func+0x6>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	5d 54       	*unknown*
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	c3 58       	rjmp	80002660 <mic_reply_func+0x10>

800025f8 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002600:	0f a9       	ld.ub	r9,r7[0x2]
80002602:	30 08       	mov	r8,0
80002604:	f0 09 18 00 	cp.b	r9,r8
80002608:	c0 71       	brne	80002616 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000260a:	48 dc       	lddpc	r12,8000263c <mic_brdcst_func+0x44>
8000260c:	f0 1f 00 0d 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002610:	30 09       	mov	r9,0
80002612:	48 d8       	lddpc	r8,80002644 <mic_brdcst_func+0x4c>
80002614:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002616:	0f a9       	ld.ub	r9,r7[0x2]
80002618:	31 18       	mov	r8,17
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 d1       	brne	80002638 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002620:	48 ac       	lddpc	r12,80002648 <mic_brdcst_func+0x50>
80002622:	f0 1f 00 08 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002626:	48 89       	lddpc	r9,80002644 <mic_brdcst_func+0x4c>
80002628:	30 18       	mov	r8,1
8000262a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000262c:	13 89       	ld.ub	r9,r9[0x0]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 31       	brne	80002638 <mic_brdcst_func+0x40>
80002634:	48 68       	lddpc	r8,8000264c <mic_brdcst_func+0x54>
80002636:	11 88       	ld.ub	r8,r8[0x0]
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	c3 64       	brge	800026aa <mic_reply_func+0x5a>
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	5d 54       	*unknown*
80002644:	00 00       	add	r0,r0
80002646:	0a 5a       	eor	r10,r5
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c3 78       	rjmp	800026b8 <mic_reply_func+0x68>
8000264c:	00 00       	add	r0,r0
8000264e:	0a 52       	eor	r2,r5

80002650 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002650:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002654:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002658:	49 ac       	lddpc	r12,800026c0 <mic_reply_func+0x70>
8000265a:	f0 1f 00 1b 	mcall	800026c4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000265e:	0f 89       	ld.ub	r9,r7[0x0]
80002660:	30 08       	mov	r8,0
80002662:	f0 09 18 00 	cp.b	r9,r8
80002666:	c2 71       	brne	800026b4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002668:	0f 98       	ld.ub	r8,r7[0x1]
8000266a:	30 29       	mov	r9,2
8000266c:	f2 08 18 00 	cp.b	r8,r9
80002670:	c1 b1       	brne	800026a6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002672:	49 6c       	lddpc	r12,800026c8 <mic_reply_func+0x78>
80002674:	f0 1f 00 14 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002678:	0f a8       	ld.ub	r8,r7[0x2]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 4c       	lddpc	r12,800026cc <mic_reply_func+0x7c>
8000267e:	f0 1f 00 12 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002682:	0f b8       	ld.ub	r8,r7[0x3]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 3c       	lddpc	r12,800026d0 <mic_reply_func+0x80>
80002688:	f0 1f 00 0f 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000268c:	0f c8       	ld.ub	r8,r7[0x4]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 1c       	lddpc	r12,800026d4 <mic_reply_func+0x84>
80002692:	f0 1f 00 0d 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002696:	0f d8       	ld.ub	r8,r7[0x5]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 0c       	lddpc	r12,800026d8 <mic_reply_func+0x88>
8000269c:	f0 1f 00 0a 	mcall	800026c4 <mic_reply_func+0x74>
800026a0:	2f cd       	sub	sp,-16
800026a2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026a6:	1a d8       	st.w	--sp,r8
800026a8:	48 dc       	lddpc	r12,800026dc <mic_reply_func+0x8c>
800026aa:	f0 1f 00 07 	mcall	800026c4 <mic_reply_func+0x74>
800026ae:	2f fd       	sub	sp,-4
800026b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026b4:	48 bc       	lddpc	r12,800026e0 <mic_reply_func+0x90>
800026b6:	f0 1f 00 04 	mcall	800026c4 <mic_reply_func+0x74>
800026ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800026be:	00 00       	add	r0,r0
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	c3 8c       	rcall	80002732 <dcm_reply_func+0x6>
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	5d 54       	*unknown*
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	c3 9c       	rcall	8000273c <dcm_reply_func+0x10>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	c3 b0       	breq	80002744 <dcm_reply_func+0x18>
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	c3 c4       	brge	8000274a <dcm_reply_func+0x1e>
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	c3 e0       	breq	80002752 <dcm_reply_func+0x26>
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	c3 f8       	rjmp	80002758 <dcm_reply_func+0x2c>
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	c4 10       	breq	80002760 <dcm_reply_func+0x34>
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	c4 28       	rjmp	80002766 <dcm_reply_func+0x3a>

800026e4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026e4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026e8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026ec:	48 bc       	lddpc	r12,80002718 <dcm_brdcst_func+0x34>
800026ee:	f0 1f 00 0c 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026f2:	0f 88       	ld.ub	r8,r7[0x0]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x3c>
800026f8:	f0 1f 00 09 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026fc:	0f a8       	ld.ub	r8,r7[0x2]
800026fe:	1a d8       	st.w	--sp,r8
80002700:	48 9c       	lddpc	r12,80002724 <dcm_brdcst_func+0x40>
80002702:	f0 1f 00 07 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002706:	0f 98       	ld.ub	r8,r7[0x1]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 8c       	lddpc	r12,80002728 <dcm_brdcst_func+0x44>
8000270c:	f0 1f 00 04 	mcall	8000271c <dcm_brdcst_func+0x38>
80002710:	2f dd       	sub	sp,-12
	
	
}
80002712:	e3 cd 80 80 	ldm	sp++,r7,pc
80002716:	00 00       	add	r0,r0
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	c4 38       	rjmp	800027a0 <ToneControl_reply_func+0xc>
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	5d 54       	*unknown*
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	c4 4c       	rcall	800027aa <ToneControl_reply_func+0x16>
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	c4 60       	breq	800027b2 <ToneControl_reply_func+0x1e>
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	c4 78       	rjmp	800027b8 <ToneControl_reply_func+0x24>

8000272c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002732:	19 a9       	ld.ub	r9,r12[0x2]
80002734:	30 08       	mov	r8,0
80002736:	f0 09 18 00 	cp.b	r9,r8
8000273a:	c1 b1       	brne	80002770 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000273c:	19 b8       	ld.ub	r8,r12[0x3]
8000273e:	30 19       	mov	r9,1
80002740:	f2 08 18 00 	cp.b	r8,r9
80002744:	c0 51       	brne	8000274e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002746:	48 ec       	lddpc	r12,8000277c <dcm_reply_func+0x50>
80002748:	f0 1f 00 0e 	mcall	80002780 <dcm_reply_func+0x54>
8000274c:	c0 a8       	rjmp	80002760 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 51       	brne	8000275a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002752:	48 dc       	lddpc	r12,80002784 <dcm_reply_func+0x58>
80002754:	f0 1f 00 0b 	mcall	80002780 <dcm_reply_func+0x54>
80002758:	c0 48       	rjmp	80002760 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000275a:	48 cc       	lddpc	r12,80002788 <dcm_reply_func+0x5c>
8000275c:	f0 1f 00 09 	mcall	80002780 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002760:	0f d8       	ld.ub	r8,r7[0x5]
80002762:	1a d8       	st.w	--sp,r8
80002764:	48 ac       	lddpc	r12,8000278c <dcm_reply_func+0x60>
80002766:	f0 1f 00 07 	mcall	80002780 <dcm_reply_func+0x54>
8000276a:	2f fd       	sub	sp,-4
8000276c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002770:	48 8c       	lddpc	r12,80002790 <dcm_reply_func+0x64>
80002772:	f0 1f 00 04 	mcall	80002780 <dcm_reply_func+0x54>
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	c4 94       	brge	80002810 <app_cfg+0x54>
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	5d 54       	*unknown*
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	c4 a8       	rjmp	8000281a <app_cfg+0x5e>
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	c4 bc       	rcall	80002820 <app_cfg+0x64>
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	c4 d0       	breq	80002828 <app_cfg+0x6c>
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	c4 dc       	rcall	8000282c <app_cfg+0x70>

80002794 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002794:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002796:	19 a9       	ld.ub	r9,r12[0x2]
80002798:	30 08       	mov	r8,0
8000279a:	f0 09 18 00 	cp.b	r9,r8
8000279e:	c0 51       	brne	800027a8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027a0:	48 4c       	lddpc	r12,800027b0 <ToneControl_reply_func+0x1c>
800027a2:	f0 1f 00 05 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027a6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x24>
800027aa:	f0 1f 00 03 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	c4 e8       	rjmp	8000284e <app_cfg+0x92>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	5d 54       	*unknown*
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	c4 f0       	breq	80002858 <app_cfg+0x9c>

800027bc <app_cfg>:


extern long volatile slot[4];

static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027be:	f0 1f 00 27 	mcall	80002858 <app_cfg+0x9c>
800027c2:	4a 78       	lddpc	r8,8000285c <app_cfg+0xa0>
800027c4:	91 0c       	st.w	r8[0x0],r12
	 memcpy(debug_output, "apprun", 7);
800027c6:	30 7a       	mov	r10,7
800027c8:	4a 6b       	lddpc	r11,80002860 <app_cfg+0xa4>
800027ca:	4a 7c       	lddpc	r12,80002864 <app_cfg+0xa8>
800027cc:	f0 1f 00 27 	mcall	80002868 <app_cfg+0xac>
	 test_data = 0xBBAA1234;
800027d0:	e0 69 12 34 	mov	r9,4660
800027d4:	ea 19 bb aa 	orh	r9,0xbbaa
800027d8:	4a 58       	lddpc	r8,8000286c <app_cfg+0xb0>
800027da:	91 09       	st.w	r8[0x0],r9
	
	for(;;)
	{
		if (0x00000001 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027dc:	4a 56       	lddpc	r6,80002870 <app_cfg+0xb4>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027de:	4a 63       	lddpc	r3,80002874 <app_cfg+0xb8>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027e0:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027e2:	30 21       	mov	r1,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027e4:	30 12       	mov	r2,1
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r bunchofrandomstatusflags & 0x00000003: %d \n\r", (bunchofrandomstatusflags & 0x00000003));
		if(test_data != 0x11123334){
800027e6:	10 97       	mov	r7,r8
			
			log("\ndebug_out: %s\n", debug_output);
800027e8:	4a 45       	lddpc	r5,80002878 <app_cfg+0xbc>
800027ea:	49 f4       	lddpc	r4,80002864 <app_cfg+0xa8>
	 memcpy(debug_output, "apprun", 7);
	 test_data = 0xBBAA1234;
	
	for(;;)
	{
		if (0x00000001 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027ec:	6c 08       	ld.w	r8,r6[0x0]
800027ee:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f2:	58 18       	cp.w	r8,1
800027f4:	c1 91       	brne	80002826 <app_cfg+0x6a>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800027f6:	f0 1f 00 22 	mcall	8000287c <app_cfg+0xc0>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027fa:	66 08       	ld.w	r8,r3[0x0]
800027fc:	58 08       	cp.w	r8,0
800027fe:	c0 31       	brne	80002804 <app_cfg+0x48>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
80002800:	87 02       	st.w	r3[0x0],r2
80002802:	c1 28       	rjmp	80002826 <app_cfg+0x6a>
				}
				else if(isAudioRouting == 1)
80002804:	58 18       	cp.w	r8,1
80002806:	c0 31       	brne	8000280c <app_cfg+0x50>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002808:	87 01       	st.w	r3[0x0],r1
8000280a:	c0 e8       	rjmp	80002826 <app_cfg+0x6a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
8000280c:	58 28       	cp.w	r8,2
8000280e:	c0 31       	brne	80002814 <app_cfg+0x58>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002810:	87 00       	st.w	r3[0x0],r0
80002812:	c0 a8       	rjmp	80002826 <app_cfg+0x6a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80002814:	58 38       	cp.w	r8,3
80002816:	f9 b9 00 04 	moveq	r9,4
8000281a:	e7 f9 0a 00 	st.weq	r3[0x0],r9
					
				}
				else
				{
					isAudioRouting++;
8000281e:	f7 b8 01 ff 	subne	r8,-1
80002822:	e7 f8 1a 00 	st.wne	r3[0x0],r8
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r bunchofrandomstatusflags & 0x00000003: %d \n\r", (bunchofrandomstatusflags & 0x00000003));
		if(test_data != 0x11123334){
80002826:	6e 08       	ld.w	r8,r7[0x0]
80002828:	e0 69 33 34 	mov	r9,13108
8000282c:	ea 19 11 12 	orh	r9,0x1112
80002830:	12 38       	cp.w	r8,r9
80002832:	c0 b0       	breq	80002848 <app_cfg+0x8c>
			
			log("\ndebug_out: %s\n", debug_output);
80002834:	1a d4       	st.w	--sp,r4
80002836:	0a 9c       	mov	r12,r5
80002838:	f0 1f 00 12 	mcall	80002880 <app_cfg+0xc4>
			log(": %x\n", test_data);
8000283c:	6e 08       	ld.w	r8,r7[0x0]
8000283e:	1a d8       	st.w	--sp,r8
80002840:	49 1c       	lddpc	r12,80002884 <app_cfg+0xc8>
80002842:	f0 1f 00 10 	mcall	80002880 <app_cfg+0xc4>
80002846:	2f ed       	sub	sp,-8
		}
		if (slot[1] == 0xABCD400E)
80002848:	49 08       	lddpc	r8,80002888 <app_cfg+0xcc>
8000284a:	70 18       	ld.w	r8,r8[0x4]
		{
			//log("Send SSI: %x\t%x\t%x\t%x\r\n",slot[0], slot[1],slot[2],slot[3]);
		}
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000284c:	e0 6b 07 d0 	mov	r11,2000
80002850:	48 3c       	lddpc	r12,8000285c <app_cfg+0xa0>
80002852:	f0 1f 00 0f 	mcall	8000288c <app_cfg+0xd0>
	}
80002856:	cc bb       	rjmp	800027ec <app_cfg+0x30>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	56 c8       	stdsp	sp[0x1b0],r8
8000285c:	00 00       	add	r0,r0
8000285e:	0a 60       	and	r0,r5
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	c4 fc       	rcall	80002900 <DeviceInitializationStatus_brdcst_func+0x24>
80002864:	00 00       	add	r0,r0
80002866:	05 30       	ld.ub	r0,r2++
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	66 c4       	ld.w	r4,r3[0x30]
8000286c:	00 00       	add	r0,r0
8000286e:	05 3c       	ld.ub	r12,r2++
80002870:	00 00       	add	r0,r0
80002872:	0d 84       	ld.ub	r4,r6[0x0]
80002874:	00 00       	add	r0,r0
80002876:	0a 54       	eor	r4,r5
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	c5 04       	brge	8000291a <CalculateBurst+0x6>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	3f cc       	mov	r12,-4
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	5d 54       	*unknown*
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	c5 14       	brge	80002928 <CalculateBurst+0x14>
80002888:	00 00       	add	r0,r0
8000288a:	40 f8       	lddsp	r8,sp[0x3c]
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	58 30       	cp.w	r0,3

80002890 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002890:	eb cd 40 80 	pushm	r7,lr
80002894:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002896:	48 c9       	lddpc	r9,800028c4 <app_payload_rx_proc+0x34>
80002898:	13 88       	ld.ub	r8,r9[0x0]
8000289a:	2f f8       	sub	r8,-1
8000289c:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000289e:	30 39       	mov	r9,3
800028a0:	f2 08 18 00 	cp.b	r8,r9
800028a4:	c0 71       	brne	800028b2 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800028a6:	30 09       	mov	r9,0
800028a8:	48 78       	lddpc	r8,800028c4 <app_payload_rx_proc+0x34>
800028aa:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800028ac:	48 7c       	lddpc	r12,800028c8 <app_payload_rx_proc+0x38>
800028ae:	f0 1f 00 08 	mcall	800028cc <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800028b2:	48 88       	lddpc	r8,800028d0 <app_payload_rx_proc+0x40>
800028b4:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028b6:	48 88       	lddpc	r8,800028d4 <app_payload_rx_proc+0x44>
800028b8:	70 0c       	ld.w	r12,r8[0x0]
800028ba:	0e 9b       	mov	r11,r7
800028bc:	f0 1f 00 07 	mcall	800028d8 <app_payload_rx_proc+0x48>

}
800028c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028c4:	00 00       	add	r0,r0
800028c6:	0a 5c       	eor	r12,r5
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	c5 1c       	rcall	8000296c <payload_rx_process+0x4>
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	5d 54       	*unknown*
800028d0:	00 00       	add	r0,r0
800028d2:	0a 50       	eor	r0,r5
800028d4:	00 00       	add	r0,r0
800028d6:	0a 7c       	tst	r12,r5
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	2a 08       	sub	r8,-96

800028dc <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028dc:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028de:	19 e8       	ld.ub	r8,r12[0x6]
800028e0:	30 19       	mov	r9,1
800028e2:	f2 08 18 00 	cp.b	r8,r9
800028e6:	c0 61       	brne	800028f2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028e8:	48 98       	lddpc	r8,8000290c <DeviceInitializationStatus_brdcst_func+0x30>
800028ea:	70 09       	ld.w	r9,r8[0x0]
800028ec:	a1 a9       	sbr	r9,0x0
800028ee:	91 09       	st.w	r8[0x0],r9
800028f0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028f2:	30 29       	mov	r9,2
800028f4:	f2 08 18 00 	cp.b	r8,r9
800028f8:	c0 80       	breq	80002908 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028fa:	48 58       	lddpc	r8,8000290c <DeviceInitializationStatus_brdcst_func+0x30>
800028fc:	70 09       	ld.w	r9,r8[0x0]
800028fe:	e0 19 ff fc 	andl	r9,0xfffc
80002902:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002904:	f0 1f 00 03 	mcall	80002910 <DeviceInitializationStatus_brdcst_func+0x34>
80002908:	d8 02       	popm	pc
8000290a:	00 00       	add	r0,r0
8000290c:	00 00       	add	r0,r0
8000290e:	0d 84       	ld.ub	r4,r6[0x0]
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	3f 20       	mov	r0,-14

80002914 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002914:	20 1c       	sub	r12,1
80002916:	5c 5c       	castu.b	r12
80002918:	31 18       	mov	r8,17
8000291a:	f0 0c 18 00 	cp.b	r12,r8
8000291e:	e0 88 00 03 	brls	80002924 <CalculateBurst+0x10>
80002922:	5e fd       	retal	0
80002924:	48 28       	lddpc	r8,8000292c <CalculateBurst+0x18>
80002926:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
8000292a:	5e fc       	retal	r12
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	c5 30       	breq	800029d4 <phy_rx+0x4>

80002930 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002930:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002932:	48 98       	lddpc	r8,80002954 <payload_init+0x24>
80002934:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002936:	48 98       	lddpc	r8,80002958 <payload_init+0x28>
80002938:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000293a:	30 09       	mov	r9,0
8000293c:	1a d9       	st.w	--sp,r9
8000293e:	1a d9       	st.w	--sp,r9
80002940:	1a d9       	st.w	--sp,r9
80002942:	30 28       	mov	r8,2
80002944:	e0 6a 04 00 	mov	r10,1024
80002948:	48 5b       	lddpc	r11,8000295c <payload_init+0x2c>
8000294a:	48 6c       	lddpc	r12,80002960 <payload_init+0x30>
8000294c:	f0 1f 00 06 	mcall	80002964 <payload_init+0x34>
80002950:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002952:	d8 02       	popm	pc
80002954:	00 00       	add	r0,r0
80002956:	0a 68       	and	r8,r5
80002958:	00 00       	add	r0,r0
8000295a:	0a 6c       	and	r12,r5
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	c5 78       	rjmp	80002a0c <set_idle_store+0x4>
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	29 68       	sub	r8,-106
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	59 90       	cp.w	r0,25

80002968 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002968:	eb cd 40 f8 	pushm	r3-r7,lr
8000296c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000296e:	48 e8       	lddpc	r8,800029a4 <payload_rx_process+0x3c>
80002970:	70 08       	ld.w	r8,r8[0x0]
80002972:	58 08       	cp.w	r8,0
80002974:	c0 71       	brne	80002982 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002976:	30 4b       	mov	r11,4
80002978:	30 5c       	mov	r12,5
8000297a:	f0 1f 00 0c 	mcall	800029a8 <payload_rx_process+0x40>
8000297e:	48 a8       	lddpc	r8,800029a4 <payload_rx_process+0x3c>
80002980:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002982:	48 96       	lddpc	r6,800029a4 <payload_rx_process+0x3c>
80002984:	30 05       	mov	r5,0
80002986:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002988:	48 93       	lddpc	r3,800029ac <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000298a:	6c 0c       	ld.w	r12,r6[0x0]
8000298c:	0a 99       	mov	r9,r5
8000298e:	08 9a       	mov	r10,r4
80002990:	1a 9b       	mov	r11,sp
80002992:	f0 1f 00 08 	mcall	800029b0 <payload_rx_process+0x48>
80002996:	58 1c       	cp.w	r12,1
80002998:	cf 91       	brne	8000298a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000299a:	66 08       	ld.w	r8,r3[0x0]
8000299c:	40 0c       	lddsp	r12,sp[0x0]
8000299e:	5d 18       	icall	r8
800029a0:	cf 5b       	rjmp	8000298a <payload_rx_process+0x22>
800029a2:	00 00       	add	r0,r0
800029a4:	00 00       	add	r0,r0
800029a6:	0a dc       	st.w	--r5,r12
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	52 bc       	stdsp	sp[0xac],r12
800029ac:	00 00       	add	r0,r0
800029ae:	0a 68       	and	r8,r5
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	4f b0       	lddpc	r0,80002b9c <phy_tx_func+0xf0>

800029b4 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029b4:	d4 01       	pushm	lr
800029b6:	20 2d       	sub	sp,8
800029b8:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029ba:	30 09       	mov	r9,0
800029bc:	fa ca ff f8 	sub	r10,sp,-8
800029c0:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029c2:	1a 9b       	mov	r11,sp
800029c4:	f0 1f 00 02 	mcall	800029cc <set_idle_store_isr+0x18>
}
800029c8:	2f ed       	sub	sp,-8
800029ca:	d8 02       	popm	pc
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	51 6c       	stdsp	sp[0x58],r12

800029d0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029d0:	d4 01       	pushm	lr
800029d2:	20 2d       	sub	sp,8
800029d4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029d6:	58 0c       	cp.w	r12,0
800029d8:	c1 10       	breq	800029fa <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029da:	30 08       	mov	r8,0
800029dc:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029de:	98 88       	ld.uh	r8,r12[0x0]
800029e0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029e4:	e0 48 40 00 	cp.w	r8,16384
800029e8:	c0 91       	brne	800029fa <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029ea:	48 68       	lddpc	r8,80002a00 <phy_rx+0x30>
800029ec:	70 0c       	ld.w	r12,r8[0x0]
800029ee:	30 09       	mov	r9,0
800029f0:	fa ca ff fc 	sub	r10,sp,-4
800029f4:	1a 9b       	mov	r11,sp
800029f6:	f0 1f 00 04 	mcall	80002a04 <phy_rx+0x34>
		}	

    }
		
 
}
800029fa:	2f ed       	sub	sp,-8
800029fc:	d8 02       	popm	pc
800029fe:	00 00       	add	r0,r0
80002a00:	00 00       	add	r0,r0
80002a02:	0a b4       	st.h	r5++,r4
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	51 6c       	stdsp	sp[0x58],r12

80002a08 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a08:	eb cd 40 80 	pushm	r7,lr
80002a0c:	20 1d       	sub	sp,4
80002a0e:	fa c7 ff fc 	sub	r7,sp,-4
80002a12:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a14:	30 09       	mov	r9,0
80002a16:	12 9a       	mov	r10,r9
80002a18:	1a 9b       	mov	r11,sp
80002a1a:	f0 1f 00 03 	mcall	80002a24 <set_idle_store+0x1c>
}
80002a1e:	2f fd       	sub	sp,-4
80002a20:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	51 bc       	stdsp	sp[0x6c],r12

80002a28 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a28:	d4 01       	pushm	lr
80002a2a:	20 1d       	sub	sp,4
80002a2c:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a2e:	98 88       	ld.uh	r8,r12[0x0]
80002a30:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a34:	e0 48 40 00 	cp.w	r8,16384
80002a38:	c0 d1       	brne	80002a52 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a3a:	49 08       	lddpc	r8,80002a78 <phy_tx+0x50>
80002a3c:	70 08       	ld.w	r8,r8[0x0]
80002a3e:	58 08       	cp.w	r8,0
80002a40:	c1 a0       	breq	80002a74 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a42:	48 e8       	lddpc	r8,80002a78 <phy_tx+0x50>
80002a44:	70 0c       	ld.w	r12,r8[0x0]
80002a46:	30 09       	mov	r9,0
80002a48:	12 9a       	mov	r10,r9
80002a4a:	1a 9b       	mov	r11,sp
80002a4c:	f0 1f 00 0c 	mcall	80002a7c <phy_tx+0x54>
80002a50:	c1 28       	rjmp	80002a74 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a52:	e0 48 10 00 	cp.w	r8,4096
80002a56:	5f 0a       	sreq	r10
80002a58:	e0 48 20 00 	cp.w	r8,8192
80002a5c:	5f 09       	sreq	r9
80002a5e:	f5 e9 10 09 	or	r9,r10,r9
80002a62:	c0 71       	brne	80002a70 <phy_tx+0x48>
80002a64:	e0 48 50 00 	cp.w	r8,20480
80002a68:	c0 40       	breq	80002a70 <phy_tx+0x48>
80002a6a:	e0 48 60 00 	cp.w	r8,24576
80002a6e:	c0 31       	brne	80002a74 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a70:	48 48       	lddpc	r8,80002a80 <phy_tx+0x58>
80002a72:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a74:	2f fd       	sub	sp,-4
80002a76:	d8 02       	popm	pc
80002a78:	00 00       	add	r0,r0
80002a7a:	0a d0       	st.w	--r5,r0
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	51 bc       	stdsp	sp[0x6c],r12
80002a80:	00 00       	add	r0,r0
80002a82:	0a ac       	st.w	r5++,r12

80002a84 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a84:	d4 01       	pushm	lr
80002a86:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a88:	30 08       	mov	r8,0
80002a8a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a8c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a8e:	1a 9a       	mov	r10,sp
80002a90:	fa cb ff fc 	sub	r11,sp,-4
80002a94:	f0 1f 00 05 	mcall	80002aa8 <get_idle_store_isr+0x24>
80002a98:	58 1c       	cp.w	r12,1
80002a9a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a9e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002aa2:	2f ed       	sub	sp,-8
80002aa4:	d8 02       	popm	pc
80002aa6:	00 00       	add	r0,r0
80002aa8:	80 00       	ld.sh	r0,r0[0x0]
80002aaa:	4e c0       	lddpc	r0,80002c58 <phy_tx_func+0x1ac>

80002aac <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002aac:	eb cd 40 c0 	pushm	r6-r7,lr
80002ab0:	20 1d       	sub	sp,4
80002ab2:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002ab4:	fe f8 04 70 	ld.w	r8,pc[1136]
80002ab8:	70 08       	ld.w	r8,r8[0x0]
80002aba:	58 08       	cp.w	r8,0
80002abc:	c7 40       	breq	80002ba4 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002abe:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ac0:	30 08       	mov	r8,0
80002ac2:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002ac4:	fe f8 04 64 	ld.w	r8,pc[1124]
80002ac8:	70 08       	ld.w	r8,r8[0x0]
80002aca:	58 18       	cp.w	r8,1
80002acc:	c2 90       	breq	80002b1e <phy_tx_func+0x72>
80002ace:	c0 43       	brcs	80002ad6 <phy_tx_func+0x2a>
80002ad0:	58 28       	cp.w	r8,2
80002ad2:	c6 91       	brne	80002ba4 <phy_tx_func+0xf8>
80002ad4:	c6 18       	rjmp	80002b96 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ad6:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002ada:	70 0c       	ld.w	r12,r8[0x0]
80002adc:	1a 9a       	mov	r10,sp
80002ade:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002ae2:	f0 1f 01 14 	mcall	80002f30 <phy_tx_func+0x484>
80002ae6:	58 1c       	cp.w	r12,1
80002ae8:	c1 51       	brne	80002b12 <phy_tx_func+0x66>
			))
			{	
				//memcpy(debug_output, "xnlsend", 7);
				//test_data = phy_ptr->xnl_fragment.phy_header.phy_control;
																
				phy_tx_expexted_length = 
80002aea:	fe f8 04 42 	ld.w	r8,pc[1090]
80002aee:	70 08       	ld.w	r8,r8[0x0]
80002af0:	11 9a       	ld.ub	r10,r8[0x1]
80002af2:	fe f9 04 42 	ld.w	r9,pc[1090]
80002af6:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002af8:	90 88       	ld.uh	r8,r8[0x0]
80002afa:	ea 18 ab cd 	orh	r8,0xabcd
80002afe:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b00:	30 19       	mov	r9,1
80002b02:	fe f8 04 36 	ld.w	r8,pc[1078]
80002b06:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b08:	30 19       	mov	r9,1
80002b0a:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002b0e:	91 09       	st.w	r8[0x0],r9
80002b10:	c4 a8       	rjmp	80002ba4 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b12:	e0 68 5a 5a 	mov	r8,23130
80002b16:	ea 18 ab cd 	orh	r8,0xabcd
80002b1a:	8f 18       	st.w	r7[0x4],r8
80002b1c:	c4 48       	rjmp	80002ba4 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b1e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002b22:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b24:	fe fa 04 08 	ld.w	r10,pc[1032]
80002b28:	74 0a       	ld.w	r10,r10[0x0]
80002b2a:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b2e:	b1 6a       	lsl	r10,0x10
80002b30:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b32:	2f f8       	sub	r8,-1
80002b34:	5c 58       	castu.b	r8
80002b36:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b38:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b3c:	94 09       	ld.sh	r9,r10[0x0]
80002b3e:	20 29       	sub	r9,2
80002b40:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b42:	30 0a       	mov	r10,0
80002b44:	f4 09 19 00 	cp.h	r9,r10
80002b48:	e0 89 00 0b 	brgt	80002b5e <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b4c:	78 18       	ld.w	r8,r12[0x4]
80002b4e:	e8 18 00 ba 	orl	r8,0xba
80002b52:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b54:	30 09       	mov	r9,0
80002b56:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b5a:	91 09       	st.w	r8[0x0],r9
80002b5c:	c2 48       	rjmp	80002ba4 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b5e:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b62:	72 09       	ld.w	r9,r9[0x0]
80002b64:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b68:	78 1a       	ld.w	r10,r12[0x4]
80002b6a:	f5 e9 10 09 	or	r9,r10,r9
80002b6e:	99 19       	st.w	r12[0x4],r9
80002b70:	2f f8       	sub	r8,-1
80002b72:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b76:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b78:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b7c:	92 08       	ld.sh	r8,r9[0x0]
80002b7e:	20 28       	sub	r8,2
80002b80:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b82:	30 09       	mov	r9,0
80002b84:	f2 08 19 00 	cp.h	r8,r9
80002b88:	e0 89 00 0e 	brgt	80002ba4 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b8c:	30 29       	mov	r9,2
80002b8e:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b92:	91 09       	st.w	r8[0x0],r9
80002b94:	c0 88       	rjmp	80002ba4 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b96:	fc 18 00 ba 	movh	r8,0xba
80002b9a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;			
80002b9c:	30 09       	mov	r9,0
80002b9e:	fe f8 03 8a 	ld.w	r8,pc[906]
80002ba2:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002ba4:	fe f8 03 98 	ld.w	r8,pc[920]
80002ba8:	11 89       	ld.ub	r9,r8[0x0]
80002baa:	30 18       	mov	r8,1
80002bac:	f0 09 18 00 	cp.b	r9,r8
80002bb0:	e0 81 01 af 	brne	80002f0e <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002bb4:	fe f8 03 8c 	ld.w	r8,pc[908]
80002bb8:	70 08       	ld.w	r8,r8[0x0]
80002bba:	e0 48 05 b0 	cp.w	r8,1456
80002bbe:	f9 b8 02 00 	movhs	r8,0
80002bc2:	fe f9 03 7e 	ld.w	r9,pc[894]
80002bc6:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002bc8:	fe f8 03 7c 	ld.w	r8,pc[892]
80002bcc:	70 08       	ld.w	r8,r8[0x0]
80002bce:	58 68       	cp.w	r8,6
80002bd0:	e0 8b 01 95 	brhi	80002efa <phy_tx_func+0x44e>
80002bd4:	fe f9 03 74 	ld.w	r9,pc[884]
80002bd8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002bdc:	fe f8 03 70 	ld.w	r8,pc[880]
80002be0:	70 08       	ld.w	r8,r8[0x0]
80002be2:	58 08       	cp.w	r8,0
80002be4:	c0 b0       	breq	80002bfa <phy_tx_func+0x14e>
80002be6:	fe f8 03 66 	ld.w	r8,pc[870]
80002bea:	70 08       	ld.w	r8,r8[0x0]
80002bec:	58 a8       	cp.w	r8,10
80002bee:	c0 60       	breq	80002bfa <phy_tx_func+0x14e>
80002bf0:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bf4:	70 08       	ld.w	r8,r8[0x0]
80002bf6:	58 18       	cp.w	r8,1
80002bf8:	c0 a1       	brne	80002c0c <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bfa:	e0 68 5a 5a 	mov	r8,23130
80002bfe:	ea 18 ab cd 	orh	r8,0xabcd
80002c02:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c04:	30 08       	mov	r8,0
80002c06:	8f 38       	st.w	r7[0xc],r8
80002c08:	e0 8f 01 8a 	bral	80002f1c <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c0c:	fe f8 03 40 	ld.w	r8,pc[832]
80002c10:	70 08       	ld.w	r8,r8[0x0]
80002c12:	58 38       	cp.w	r8,3
80002c14:	c0 91       	brne	80002c26 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c16:	fe f8 03 3a 	ld.w	r8,pc[826]
80002c1a:	70 09       	ld.w	r9,r8[0x0]
80002c1c:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c1e:	70 18       	ld.w	r8,r8[0x4]
80002c20:	8f 38       	st.w	r7[0xc],r8
80002c22:	e0 8f 01 7d 	bral	80002f1c <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c26:	fe f8 03 26 	ld.w	r8,pc[806]
80002c2a:	70 08       	ld.w	r8,r8[0x0]
80002c2c:	58 28       	cp.w	r8,2
80002c2e:	c1 31       	brne	80002c54 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c30:	e0 68 c0 32 	mov	r8,49202
80002c34:	ea 18 ab cd 	orh	r8,0xabcd
80002c38:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c3a:	fe 78 84 7f 	mov	r8,-31617
80002c3e:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c40:	fe f8 03 14 	ld.w	r8,pc[788]
80002c44:	90 08       	ld.sh	r8,r8[0x0]
80002c46:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c48:	30 39       	mov	r9,3
80002c4a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c4e:	91 09       	st.w	r8[0x0],r9
80002c50:	e0 8f 01 66 	bral	80002f1c <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c54:	e0 68 c0 0e 	mov	r8,49166
80002c58:	ea 18 ab cd 	orh	r8,0xabcd
80002c5c:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c5e:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c62:	90 09       	ld.sh	r9,r8[0x0]
80002c64:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c66:	90 18       	ld.sh	r8,r8[0x2]
80002c68:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c6a:	30 19       	mov	r9,1
80002c6c:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c70:	91 09       	st.w	r8[0x0],r9
80002c72:	e0 8f 01 55 	bral	80002f1c <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c76:	fe 78 88 f2 	mov	r8,-30478
80002c7a:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c7c:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c80:	70 08       	ld.w	r8,r8[0x0]
80002c82:	58 48       	cp.w	r8,4
80002c84:	c0 60       	breq	80002c90 <phy_tx_func+0x1e4>
80002c86:	c4 53       	brcs	80002d10 <phy_tx_func+0x264>
80002c88:	58 98       	cp.w	r8,9
80002c8a:	e0 8b 00 43 	brhi	80002d10 <phy_tx_func+0x264>
80002c8e:	c2 98       	rjmp	80002ce0 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c90:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c94:	11 89       	ld.ub	r9,r8[0x0]
80002c96:	30 18       	mov	r8,1
80002c98:	f0 09 18 00 	cp.b	r9,r8
80002c9c:	c0 a1       	brne	80002cb0 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c9e:	fe f8 02 c2 	ld.w	r8,pc[706]
80002ca2:	90 09       	ld.sh	r9,r8[0x0]
80002ca4:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002ca6:	90 19       	ld.sh	r9,r8[0x2]
80002ca8:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002caa:	90 28       	ld.sh	r8,r8[0x4]
80002cac:	ae 78       	st.h	r7[0xe],r8
80002cae:	c1 48       	rjmp	80002cd6 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cb0:	fe f9 02 b4 	ld.w	r9,pc[692]
80002cb4:	92 0b       	ld.sh	r11,r9[0x0]
80002cb6:	fe f8 02 aa 	ld.w	r8,pc[682]
80002cba:	90 0a       	ld.sh	r10,r8[0x0]
80002cbc:	f7 ea 20 0a 	eor	r10,r11,r10
80002cc0:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cc2:	92 1b       	ld.sh	r11,r9[0x2]
80002cc4:	90 1a       	ld.sh	r10,r8[0x2]
80002cc6:	f7 ea 20 0a 	eor	r10,r11,r10
80002cca:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002ccc:	92 29       	ld.sh	r9,r9[0x4]
80002cce:	90 28       	ld.sh	r8,r8[0x4]
80002cd0:	f3 e8 20 08 	eor	r8,r9,r8
80002cd4:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cd6:	30 29       	mov	r9,2
80002cd8:	fe f8 02 6c 	ld.w	r8,pc[620]
80002cdc:	91 09       	st.w	r8[0x0],r9
80002cde:	c1 f9       	rjmp	80002f1c <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002ce0:	fe f9 02 84 	ld.w	r9,pc[644]
80002ce4:	92 0b       	ld.sh	r11,r9[0x0]
80002ce6:	fe f8 02 7a 	ld.w	r8,pc[634]
80002cea:	90 0a       	ld.sh	r10,r8[0x0]
80002cec:	f7 ea 20 0a 	eor	r10,r11,r10
80002cf0:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cf2:	92 1b       	ld.sh	r11,r9[0x2]
80002cf4:	90 1a       	ld.sh	r10,r8[0x2]
80002cf6:	f7 ea 20 0a 	eor	r10,r11,r10
80002cfa:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cfc:	92 29       	ld.sh	r9,r9[0x4]
80002cfe:	90 28       	ld.sh	r8,r8[0x4]
80002d00:	f3 e8 20 08 	eor	r8,r9,r8
80002d04:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002d06:	30 29       	mov	r9,2
80002d08:	fe f8 02 3c 	ld.w	r8,pc[572]
80002d0c:	91 09       	st.w	r8[0x0],r9
80002d0e:	c0 79       	rjmp	80002f1c <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002d10:	e0 68 5a 5a 	mov	r8,23130
80002d14:	ea 18 ab cd 	orh	r8,0xabcd
80002d18:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002d1a:	30 08       	mov	r8,0
80002d1c:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002d1e:	fe f9 02 26 	ld.w	r9,pc[550]
80002d22:	93 08       	st.w	r9[0x0],r8
80002d24:	cf c8       	rjmp	80002f1c <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002d26:	fe f8 02 3e 	ld.w	r8,pc[574]
80002d2a:	90 38       	ld.sh	r8,r8[0x6]
80002d2c:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d2e:	e0 68 00 ba 	mov	r8,186
80002d32:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d34:	30 08       	mov	r8,0
80002d36:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d38:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d3a:	30 09       	mov	r9,0
80002d3c:	fe f8 02 08 	ld.w	r8,pc[520]
80002d40:	91 09       	st.w	r8[0x0],r9
80002d42:	ce d8       	rjmp	80002f1c <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d44:	fe f8 02 10 	ld.w	r8,pc[528]
80002d48:	90 18       	ld.sh	r8,r8[0x2]
80002d4a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d4c:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d50:	90 08       	ld.sh	r8,r8[0x0]
80002d52:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d54:	4f e8       	lddpc	r8,80002f4c <phy_tx_func+0x4a0>
80002d56:	70 08       	ld.w	r8,r8[0x0]
80002d58:	58 48       	cp.w	r8,4
80002d5a:	c0 d1       	brne	80002d74 <phy_tx_func+0x2c8>
80002d5c:	fe f8 02 00 	ld.w	r8,pc[512]
80002d60:	11 89       	ld.ub	r9,r8[0x0]
80002d62:	30 18       	mov	r8,1
80002d64:	f0 09 18 00 	cp.b	r9,r8
80002d68:	c0 61       	brne	80002d74 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d6a:	4f c8       	lddpc	r8,80002f58 <phy_tx_func+0x4ac>
80002d6c:	90 18       	ld.sh	r8,r8[0x2]
80002d6e:	a9 a8       	sbr	r8,0x8
80002d70:	ae 68       	st.h	r7[0xc],r8
80002d72:	c0 48       	rjmp	80002d7a <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d74:	4f 98       	lddpc	r8,80002f58 <phy_tx_func+0x4ac>
80002d76:	90 18       	ld.sh	r8,r8[0x2]
80002d78:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d7a:	fe 78 9a 13 	mov	r8,-26093
80002d7e:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d80:	30 49       	mov	r9,4
80002d82:	4f 18       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002d84:	91 09       	st.w	r8[0x0],r9
80002d86:	cc b8       	rjmp	80002f1c <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d88:	4f 88       	lddpc	r8,80002f68 <phy_tx_func+0x4bc>
80002d8a:	70 0a       	ld.w	r10,r8[0x0]
80002d8c:	4f 89       	lddpc	r9,80002f6c <phy_tx_func+0x4c0>
80002d8e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d92:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d94:	70 0a       	ld.w	r10,r8[0x0]
80002d96:	2f fa       	sub	r10,-1
80002d98:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d9c:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d9e:	70 0a       	ld.w	r10,r8[0x0]
80002da0:	2f ea       	sub	r10,-2
80002da2:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002da6:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002da8:	70 0a       	ld.w	r10,r8[0x0]
80002daa:	2f da       	sub	r10,-3
80002dac:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002db0:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002db2:	70 09       	ld.w	r9,r8[0x0]
80002db4:	2f c9       	sub	r9,-4
80002db6:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002db8:	58 c9       	cp.w	r9,12
80002dba:	c0 51       	brne	80002dc4 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002dbc:	30 59       	mov	r9,5
80002dbe:	4e 28       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002dc0:	91 09       	st.w	r8[0x0],r9
80002dc2:	ca d8       	rjmp	80002f1c <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002dc4:	30 49       	mov	r9,4
80002dc6:	4e 08       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002dc8:	91 09       	st.w	r8[0x0],r9
80002dca:	ca 98       	rjmp	80002f1c <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002dcc:	4e 78       	lddpc	r8,80002f68 <phy_tx_func+0x4bc>
80002dce:	70 0a       	ld.w	r10,r8[0x0]
80002dd0:	4e 79       	lddpc	r9,80002f6c <phy_tx_func+0x4c0>
80002dd2:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002dd6:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002dd8:	30 09       	mov	r9,0
80002dda:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002ddc:	fe 78 80 03 	mov	r8,-32765
80002de0:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002de2:	fe 78 88 f3 	mov	r8,-30477
80002de6:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002de8:	4d 98       	lddpc	r8,80002f4c <phy_tx_func+0x4a0>
80002dea:	70 08       	ld.w	r8,r8[0x0]
80002dec:	58 48       	cp.w	r8,4
80002dee:	c0 60       	breq	80002dfa <phy_tx_func+0x34e>
80002df0:	c2 83       	brcs	80002e40 <phy_tx_func+0x394>
80002df2:	58 98       	cp.w	r8,9
80002df4:	e0 8b 00 26 	brhi	80002e40 <phy_tx_func+0x394>
80002df8:	c1 98       	rjmp	80002e2a <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002dfa:	4d 98       	lddpc	r8,80002f5c <phy_tx_func+0x4b0>
80002dfc:	11 89       	ld.ub	r9,r8[0x0]
80002dfe:	30 18       	mov	r8,1
80002e00:	f0 09 18 00 	cp.b	r9,r8
80002e04:	c0 81       	brne	80002e14 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002e06:	4d 88       	lddpc	r8,80002f64 <phy_tx_func+0x4b8>
80002e08:	90 0a       	ld.sh	r10,r8[0x0]
80002e0a:	4d a9       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002e0c:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002e0e:	90 08       	ld.sh	r8,r8[0x0]
80002e10:	ae 78       	st.h	r7[0xe],r8
80002e12:	c0 88       	rjmp	80002e22 <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e14:	4d 78       	lddpc	r8,80002f70 <phy_tx_func+0x4c4>
80002e16:	90 08       	ld.sh	r8,r8[0x0]
80002e18:	4d 39       	lddpc	r9,80002f64 <phy_tx_func+0x4b8>
80002e1a:	92 09       	ld.sh	r9,r9[0x0]
80002e1c:	f3 e8 20 08 	eor	r8,r9,r8
80002e20:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e22:	30 69       	mov	r9,6
80002e24:	4c 88       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002e26:	91 09       	st.w	r8[0x0],r9
80002e28:	c7 a8       	rjmp	80002f1c <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e2a:	4d 28       	lddpc	r8,80002f70 <phy_tx_func+0x4c4>
80002e2c:	90 08       	ld.sh	r8,r8[0x0]
80002e2e:	4c e9       	lddpc	r9,80002f64 <phy_tx_func+0x4b8>
80002e30:	92 09       	ld.sh	r9,r9[0x0]
80002e32:	f3 e8 20 08 	eor	r8,r9,r8
80002e36:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e38:	30 69       	mov	r9,6
80002e3a:	4c 38       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002e3c:	91 09       	st.w	r8[0x0],r9
80002e3e:	c6 f8       	rjmp	80002f1c <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e40:	e0 68 5a 5a 	mov	r8,23130
80002e44:	ea 18 ab cd 	orh	r8,0xabcd
80002e48:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e4a:	30 08       	mov	r8,0
80002e4c:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e4e:	4b e9       	lddpc	r9,80002f44 <phy_tx_func+0x498>
80002e50:	93 08       	st.w	r9[0x0],r8
80002e52:	c6 58       	rjmp	80002f1c <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e54:	4b e8       	lddpc	r8,80002f4c <phy_tx_func+0x4a0>
80002e56:	70 08       	ld.w	r8,r8[0x0]
80002e58:	58 48       	cp.w	r8,4
80002e5a:	c0 60       	breq	80002e66 <phy_tx_func+0x3ba>
80002e5c:	c4 53       	brcs	80002ee6 <phy_tx_func+0x43a>
80002e5e:	58 98       	cp.w	r8,9
80002e60:	e0 8b 00 43 	brhi	80002ee6 <phy_tx_func+0x43a>
80002e64:	c2 d8       	rjmp	80002ebe <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e66:	4b e8       	lddpc	r8,80002f5c <phy_tx_func+0x4b0>
80002e68:	11 89       	ld.ub	r9,r8[0x0]
80002e6a:	30 18       	mov	r8,1
80002e6c:	f0 09 18 00 	cp.b	r9,r8
80002e70:	c1 31       	brne	80002e96 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e72:	4b d8       	lddpc	r8,80002f64 <phy_tx_func+0x4b8>
80002e74:	90 1a       	ld.sh	r10,r8[0x2]
80002e76:	4b f9       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002e78:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e7a:	90 2a       	ld.sh	r10,r8[0x4]
80002e7c:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e7e:	90 3a       	ld.sh	r10,r8[0x6]
80002e80:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e82:	90 19       	ld.sh	r9,r8[0x2]
80002e84:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e86:	90 29       	ld.sh	r9,r8[0x4]
80002e88:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e8a:	90 38       	ld.sh	r8,r8[0x6]
80002e8c:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e8e:	e0 68 00 ba 	mov	r8,186
80002e92:	ae 78       	st.h	r7[0xe],r8
80002e94:	c1 18       	rjmp	80002eb6 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e96:	4b 48       	lddpc	r8,80002f64 <phy_tx_func+0x4b8>
80002e98:	90 1a       	ld.sh	r10,r8[0x2]
80002e9a:	4b 69       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002e9c:	92 1b       	ld.sh	r11,r9[0x2]
80002e9e:	f7 ea 20 0a 	eor	r10,r11,r10
80002ea2:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002ea4:	90 2a       	ld.sh	r10,r8[0x4]
80002ea6:	92 29       	ld.sh	r9,r9[0x4]
80002ea8:	14 59       	eor	r9,r10
80002eaa:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002eac:	90 38       	ld.sh	r8,r8[0x6]
80002eae:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002eb0:	e0 68 00 ba 	mov	r8,186
80002eb4:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002eb6:	30 09       	mov	r9,0
80002eb8:	4a 38       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002eba:	91 09       	st.w	r8[0x0],r9
80002ebc:	c3 08       	rjmp	80002f1c <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002ebe:	4a a8       	lddpc	r8,80002f64 <phy_tx_func+0x4b8>
80002ec0:	90 1a       	ld.sh	r10,r8[0x2]
80002ec2:	4a c9       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002ec4:	92 1b       	ld.sh	r11,r9[0x2]
80002ec6:	f7 ea 20 0a 	eor	r10,r11,r10
80002eca:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002ecc:	90 2a       	ld.sh	r10,r8[0x4]
80002ece:	92 29       	ld.sh	r9,r9[0x4]
80002ed0:	14 59       	eor	r9,r10
80002ed2:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002ed4:	90 38       	ld.sh	r8,r8[0x6]
80002ed6:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002ed8:	e0 68 00 ba 	mov	r8,186
80002edc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002ede:	30 09       	mov	r9,0
80002ee0:	49 98       	lddpc	r8,80002f44 <phy_tx_func+0x498>
80002ee2:	91 09       	st.w	r8[0x0],r9
80002ee4:	c1 c8       	rjmp	80002f1c <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ee6:	e0 68 5a 5a 	mov	r8,23130
80002eea:	ea 18 ab cd 	orh	r8,0xabcd
80002eee:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ef0:	30 08       	mov	r8,0
80002ef2:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ef4:	49 49       	lddpc	r9,80002f44 <phy_tx_func+0x498>
80002ef6:	93 08       	st.w	r9[0x0],r8
80002ef8:	c1 28       	rjmp	80002f1c <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002efa:	e0 68 5a 5a 	mov	r8,23130
80002efe:	ea 18 ab cd 	orh	r8,0xabcd
80002f02:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f04:	30 08       	mov	r8,0
80002f06:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002f08:	48 f9       	lddpc	r9,80002f44 <phy_tx_func+0x498>
80002f0a:	93 08       	st.w	r9[0x0],r8
80002f0c:	c0 88       	rjmp	80002f1c <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f0e:	e0 68 5a 5a 	mov	r8,23130
80002f12:	ea 18 ab cd 	orh	r8,0xabcd
80002f16:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f18:	30 08       	mov	r8,0
80002f1a:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002f1c:	2f fd       	sub	sp,-4
80002f1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f22:	00 00       	add	r0,r0
80002f24:	00 00       	add	r0,r0
80002f26:	0a d0       	st.w	--r5,r0
80002f28:	00 00       	add	r0,r0
80002f2a:	0a 70       	tst	r0,r5
80002f2c:	00 00       	add	r0,r0
80002f2e:	0a 88       	andn	r8,r5
80002f30:	80 00       	ld.sh	r0,r0[0x0]
80002f32:	4e c0       	lddpc	r0,800030e0 <phy_rx_func+0x28>
80002f34:	00 00       	add	r0,r0
80002f36:	0a cc       	st.b	r5++,r12
80002f38:	00 00       	add	r0,r0
80002f3a:	0a 8c       	andn	r12,r5
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a 58       	eor	r8,r5
80002f40:	00 00       	add	r0,r0
80002f42:	0a c0       	st.b	r5++,r0
80002f44:	00 00       	add	r0,r0
80002f46:	0a b8       	st.h	r5++,r8
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	c5 84       	brge	80002ffa <phy_init+0x5e>
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a 78       	tst	r8,r5
80002f50:	00 00       	add	r0,r0
80002f52:	0a 90       	mov	r0,r5
80002f54:	00 00       	add	r0,r0
80002f56:	0d 90       	ld.ub	r0,r6[0x1]
80002f58:	00 00       	add	r0,r0
80002f5a:	0e 8c       	andn	r12,r7
80002f5c:	00 00       	add	r0,r0
80002f5e:	0a 59       	eor	r9,r5
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	c5 26       	brmi	80003006 <phy_init+0x6a>
80002f64:	00 00       	add	r0,r0
80002f66:	0d 88       	ld.ub	r8,r6[0x0]
80002f68:	00 00       	add	r0,r0
80002f6a:	0a bc       	st.h	r5++,r12
80002f6c:	00 00       	add	r0,r0
80002f6e:	0e 90       	mov	r0,r7
80002f70:	00 00       	add	r0,r0
80002f72:	0d 94       	ld.ub	r4,r6[0x1]

80002f74 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f74:	d4 01       	pushm	lr
80002f76:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f78:	30 0a       	mov	r10,0
80002f7a:	fa cb ff fc 	sub	r11,sp,-4
80002f7e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f80:	14 99       	mov	r9,r10
80002f82:	1a 9b       	mov	r11,sp
80002f84:	f0 1f 00 05 	mcall	80002f98 <get_idle_store+0x24>
80002f88:	58 1c       	cp.w	r12,1
80002f8a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f8e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f92:	2f fd       	sub	sp,-4
80002f94:	d8 02       	popm	pc
80002f96:	00 00       	add	r0,r0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	4f b0       	lddpc	r0,80003184 <phy_rx_func+0xcc>

80002f9c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f9c:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002fa0:	f0 1f 00 21 	mcall	80003024 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002fa4:	4a 1b       	lddpc	r11,80003028 <phy_init+0x8c>
80002fa6:	4a 2c       	lddpc	r12,8000302c <phy_init+0x90>
80002fa8:	f0 1f 00 22 	mcall	80003030 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002fac:	30 4b       	mov	r11,4
80002fae:	31 ec       	mov	r12,30
80002fb0:	f0 1f 00 21 	mcall	80003034 <phy_init+0x98>
80002fb4:	4a 18       	lddpc	r8,80003038 <phy_init+0x9c>
80002fb6:	91 0c       	st.w	r8[0x0],r12
80002fb8:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002fba:	10 96       	mov	r6,r8
80002fbc:	4a 05       	lddpc	r5,8000303c <phy_init+0xa0>
80002fbe:	6c 0c       	ld.w	r12,r6[0x0]
80002fc0:	ea 07 00 0b 	add	r11,r5,r7
80002fc4:	f0 1f 00 1f 	mcall	80003040 <phy_init+0xa4>
80002fc8:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002fcc:	e0 47 1e 00 	cp.w	r7,7680
80002fd0:	cf 71       	brne	80002fbe <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fd2:	30 4b       	mov	r11,4
80002fd4:	31 4c       	mov	r12,20
80002fd6:	f0 1f 00 18 	mcall	80003034 <phy_init+0x98>
80002fda:	49 b8       	lddpc	r8,80003044 <phy_init+0xa8>
80002fdc:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fde:	30 4b       	mov	r11,4
80002fe0:	30 ac       	mov	r12,10
80002fe2:	f0 1f 00 15 	mcall	80003034 <phy_init+0x98>
80002fe6:	49 98       	lddpc	r8,80003048 <phy_init+0xac>
80002fe8:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002fea:	30 4b       	mov	r11,4
80002fec:	30 ac       	mov	r12,10
80002fee:	f0 1f 00 12 	mcall	80003034 <phy_init+0x98>
80002ff2:	49 78       	lddpc	r8,8000304c <phy_init+0xb0>
80002ff4:	91 0c       	st.w	r8[0x0],r12
80002ff6:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002ff8:	10 96       	mov	r6,r8
80002ffa:	49 65       	lddpc	r5,80003050 <phy_init+0xb4>
80002ffc:	6c 0c       	ld.w	r12,r6[0x0]
80002ffe:	ea 07 00 0b 	add	r11,r5,r7
80003002:	f0 1f 00 10 	mcall	80003040 <phy_init+0xa4>
80003006:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000300a:	e0 47 14 00 	cp.w	r7,5120
8000300e:	cf 71       	brne	80002ffc <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003010:	e0 6b 01 00 	mov	r11,256
80003014:	30 5c       	mov	r12,5
80003016:	f0 1f 00 08 	mcall	80003034 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
8000301a:	48 f8       	lddpc	r8,80003054 <phy_init+0xb8>
8000301c:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000301e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003022:	00 00       	add	r0,r0
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	3e 64       	mov	r4,-26
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	2a ac       	sub	r12,-86
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	30 b8       	mov	r8,11
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	3e 50       	mov	r0,-27
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	52 bc       	stdsp	sp[0xac],r12
80003038:	00 00       	add	r0,r0
8000303a:	0a b0       	st.h	r5++,r0
8000303c:	00 00       	add	r0,r0
8000303e:	22 aa       	sub	r10,42
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	2a 08       	sub	r8,-96
80003044:	00 00       	add	r0,r0
80003046:	0a d0       	st.w	--r5,r0
80003048:	00 00       	add	r0,r0
8000304a:	0a b4       	st.h	r5++,r4
8000304c:	00 00       	add	r0,r0
8000304e:	0a 7c       	tst	r12,r5
80003050:	00 00       	add	r0,r0
80003052:	0e aa       	st.w	r7++,r10
80003054:	00 00       	add	r0,r0
80003056:	0a ac       	st.w	r5++,r12

80003058 <payload_rx>:




static void payload_rx(void * payload)
{
80003058:	d4 01       	pushm	lr
8000305a:	20 2d       	sub	sp,8
8000305c:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000305e:	30 08       	mov	r8,0
80003060:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80003062:	48 f8       	lddpc	r8,8000309c <payload_rx+0x44>
80003064:	70 08       	ld.w	r8,r8[0x0]
80003066:	58 08       	cp.w	r8,0
80003068:	c0 71       	brne	80003076 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000306a:	30 4b       	mov	r11,4
8000306c:	30 5c       	mov	r12,5
8000306e:	f0 1f 00 0d 	mcall	800030a0 <payload_rx+0x48>
80003072:	48 b8       	lddpc	r8,8000309c <payload_rx+0x44>
80003074:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80003076:	48 a8       	lddpc	r8,8000309c <payload_rx+0x44>
80003078:	70 0c       	ld.w	r12,r8[0x0]
8000307a:	30 09       	mov	r9,0
8000307c:	fa ca ff fc 	sub	r10,sp,-4
80003080:	1a 9b       	mov	r11,sp
80003082:	f0 1f 00 09 	mcall	800030a4 <payload_rx+0x4c>
80003086:	c0 91       	brne	80003098 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003088:	48 88       	lddpc	r8,800030a8 <payload_rx+0x50>
8000308a:	70 0c       	ld.w	r12,r8[0x0]
8000308c:	40 0b       	lddsp	r11,sp[0x0]
8000308e:	f0 1f 00 08 	mcall	800030ac <payload_rx+0x54>
		logFromISR("mm");
80003092:	48 8c       	lddpc	r12,800030b0 <payload_rx+0x58>
80003094:	f0 1f 00 08 	mcall	800030b4 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003098:	2f ed       	sub	sp,-8
8000309a:	d8 02       	popm	pc
8000309c:	00 00       	add	r0,r0
8000309e:	0a dc       	st.w	--r5,r12
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	52 bc       	stdsp	sp[0xac],r12
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	51 6c       	stdsp	sp[0x58],r12
800030a8:	00 00       	add	r0,r0
800030aa:	0a 7c       	tst	r12,r5
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	29 b4       	sub	r4,-101
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	c5 a0       	breq	80003166 <phy_rx_func+0xae>
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	5e e0       	retqs	r0

800030b8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800030b8:	eb cd 40 e0 	pushm	r5-r7,lr
800030bc:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800030be:	fe f8 0b be 	ld.w	r8,pc[3006]
800030c2:	70 08       	ld.w	r8,r8[0x0]
800030c4:	58 08       	cp.w	r8,0
800030c6:	e0 80 01 00 	breq	800032c6 <phy_rx_func+0x20e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800030ca:	78 16       	ld.w	r6,r12[0x4]
		//test_data = phy_dword;
		//phy_rx_count = 0;
	//}
	//
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800030cc:	fe f8 0b b4 	ld.w	r8,pc[2996]
800030d0:	70 08       	ld.w	r8,r8[0x0]
800030d2:	58 18       	cp.w	r8,1
800030d4:	e0 80 00 84 	breq	800031dc <phy_rx_func+0x124>
800030d8:	c0 73       	brcs	800030e6 <phy_rx_func+0x2e>
800030da:	58 28       	cp.w	r8,2
800030dc:	c5 b0       	breq	80003192 <phy_rx_func+0xda>
800030de:	58 38       	cp.w	r8,3
800030e0:	e0 81 00 f3 	brne	800032c6 <phy_rx_func+0x20e>
800030e4:	cd 38       	rjmp	8000328a <phy_rx_func+0x1d2>
		*/	

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800030e6:	e0 6a 5a 5a 	mov	r10,23130
800030ea:	ea 1a ab cd 	orh	r10,0xabcd
800030ee:	14 36       	cp.w	r6,r10
800030f0:	e0 80 00 eb 	breq	800032c6 <phy_rx_func+0x20e>
				//memcpy(debug_output, "xnlrec", 10);
				//test_data = phy_dword;			
			//}
			/*Skip until Header.*/		
			//if (0xABCD0000 != (phy_dword >> 16))
			if (0xABCD0000 != (phy_dword & 0xFFFF0000))
800030f4:	0c 98       	mov	r8,r6
800030f6:	e0 18 00 00 	andl	r8,0x0
800030fa:	fc 19 ab cd 	movh	r9,0xabcd
800030fe:	12 38       	cp.w	r8,r9
80003100:	e0 81 00 e3 	brne	800032c6 <phy_rx_func+0x20e>
			{	
				break;
			}
			
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003104:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003108:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000310c:	20 28       	sub	r8,2
8000310e:	fe f9 0b 76 	ld.w	r9,pc[2934]
80003112:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003114:	30 09       	mov	r9,0
80003116:	f2 08 19 00 	cp.h	r8,r9
8000311a:	e0 8a 00 d6 	brle	800032c6 <phy_rx_func+0x20e>
			{
				break;
			}
		
			phy_rx_length = 0;
8000311e:	fe f8 0b 6a 	ld.w	r8,pc[2922]
80003122:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003124:	fe f8 0b 68 	ld.w	r8,pc[2920]
80003128:	70 0c       	ld.w	r12,r8[0x0]
8000312a:	f0 1f 02 da 	mcall	80003c90 <phy_rx_func+0xbd8>
8000312e:	fe f8 0b 66 	ld.w	r8,pc[2918]
80003132:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003134:	58 0c       	cp.w	r12,0
80003136:	e0 80 00 c8 	breq	800032c6 <phy_rx_func+0x20e>
			}
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000313a:	fe f8 0b 4e 	ld.w	r8,pc[2894]
8000313e:	90 09       	ld.sh	r9,r8[0x0]
80003140:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003144:	2f f9       	sub	r9,-1
80003146:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003148:	fe fa 0b 4c 	ld.w	r10,pc[2892]
8000314c:	74 0a       	ld.w	r10,r10[0x0]
8000314e:	30 0b       	mov	r11,0
80003150:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003154:	2f f9       	sub	r9,-1
80003156:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003158:	e2 16 0f 00 	andl	r6,0xf00,COH
8000315c:	e0 46 01 00 	cp.w	r6,256
80003160:	c0 c0       	breq	80003178 <phy_rx_func+0xc0>
80003162:	e0 8b 00 05 	brhi	8000316c <phy_rx_func+0xb4>
80003166:	58 06       	cp.w	r6,0
80003168:	c0 80       	breq	80003178 <phy_rx_func+0xc0>
8000316a:	c0 c8       	rjmp	80003182 <phy_rx_func+0xca>
8000316c:	e0 46 02 00 	cp.w	r6,512
80003170:	c0 40       	breq	80003178 <phy_rx_func+0xc0>
80003172:	e0 46 03 00 	cp.w	r6,768
80003176:	c0 61       	brne	80003182 <phy_rx_func+0xca>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003178:	30 29       	mov	r9,2
8000317a:	fe f8 0b 06 	ld.w	r8,pc[2822]
8000317e:	91 09       	st.w	r8[0x0],r9
80003180:	ca 38       	rjmp	800032c6 <phy_rx_func+0x20e>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003182:	fe f6 0b 12 	ld.w	r6,pc[2834]
80003186:	6c 0c       	ld.w	r12,r6[0x0]
80003188:	f0 1f 02 c4 	mcall	80003c98 <phy_rx_func+0xbe0>
					phy_frame_ptr = NULL;					
8000318c:	30 08       	mov	r8,0
8000318e:	8d 08       	st.w	r6[0x0],r8
80003190:	c9 b8       	rjmp	800032c6 <phy_rx_func+0x20e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003192:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003196:	b1 86       	lsr	r6,0x10
80003198:	14 06       	add	r6,r10
8000319a:	fe f8 0b 02 	ld.w	r8,pc[2818]
8000319e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031a0:	fe f8 0a e8 	ld.w	r8,pc[2792]
800031a4:	90 09       	ld.sh	r9,r8[0x0]
800031a6:	fe fb 0a ee 	ld.w	r11,pc[2798]
800031aa:	76 0b       	ld.w	r11,r11[0x0]
800031ac:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800031b0:	2f f9       	sub	r9,-1
800031b2:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800031b4:	fe f9 0a d0 	ld.w	r9,pc[2768]
800031b8:	92 08       	ld.sh	r8,r9[0x0]
800031ba:	20 28       	sub	r8,2
800031bc:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800031be:	30 09       	mov	r9,0
800031c0:	f2 08 19 00 	cp.h	r8,r9
800031c4:	e0 8a 00 07 	brle	800031d2 <phy_rx_func+0x11a>
			{					  
				phy_rx_state = READING_FRAGMENT;
800031c8:	30 19       	mov	r9,1
800031ca:	fe f8 0a b6 	ld.w	r8,pc[2742]
800031ce:	91 09       	st.w	r8[0x0],r9
800031d0:	c7 b8       	rjmp	800032c6 <phy_rx_func+0x20e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800031d2:	30 39       	mov	r9,3
800031d4:	fe f8 0a ac 	ld.w	r8,pc[2732]
800031d8:	91 09       	st.w	r8[0x0],r9
800031da:	c7 68       	rjmp	800032c6 <phy_rx_func+0x20e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800031dc:	ec 0a 14 10 	asr	r10,r6,0x10
800031e0:	fe f8 0a bc 	ld.w	r8,pc[2748]
800031e4:	90 09       	ld.sh	r9,r8[0x0]
800031e6:	14 09       	add	r9,r10
800031e8:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031ea:	fe f9 0a 9e 	ld.w	r9,pc[2718]
800031ee:	92 08       	ld.sh	r8,r9[0x0]
800031f0:	fe fb 0a a4 	ld.w	r11,pc[2724]
800031f4:	76 0b       	ld.w	r11,r11[0x0]
800031f6:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031fa:	2f f8       	sub	r8,-1
800031fc:	5c 88       	casts.h	r8
800031fe:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003200:	fe fa 0a 84 	ld.w	r10,pc[2692]
80003204:	94 09       	ld.sh	r9,r10[0x0]
80003206:	20 29       	sub	r9,2
80003208:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000320a:	30 0a       	mov	r10,0
8000320c:	f4 09 19 00 	cp.h	r9,r10
80003210:	e0 89 00 1f 	brgt	8000324e <phy_rx_func+0x196>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003214:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003218:	e0 46 00 ba 	cp.w	r6,186
8000321c:	c0 d1       	brne	80003236 <phy_rx_func+0x17e>
8000321e:	fe f8 0a 7e 	ld.w	r8,pc[2686]
80003222:	90 09       	ld.sh	r9,r8[0x0]
80003224:	f4 09 19 00 	cp.h	r9,r10
80003228:	c0 71       	brne	80003236 <phy_rx_func+0x17e>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000322a:	fe f8 0a 6a 	ld.w	r8,pc[2666]
8000322e:	70 0c       	ld.w	r12,r8[0x0]
80003230:	f0 1f 02 9c 	mcall	80003ca0 <phy_rx_func+0xbe8>
80003234:	c0 88       	rjmp	80003244 <phy_rx_func+0x18c>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003236:	fe f6 0a 5e 	ld.w	r6,pc[2654]
8000323a:	6c 0c       	ld.w	r12,r6[0x0]
8000323c:	f0 1f 02 97 	mcall	80003c98 <phy_rx_func+0xbe0>
					phy_frame_ptr = NULL;
80003240:	30 08       	mov	r8,0
80003242:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003244:	30 09       	mov	r9,0
80003246:	fe f8 0a 3a 	ld.w	r8,pc[2618]
8000324a:	91 09       	st.w	r8[0x0],r9
8000324c:	c3 d8       	rjmp	800032c6 <phy_rx_func+0x20e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000324e:	5c 86       	casts.h	r6
80003250:	fe f9 0a 4c 	ld.w	r9,pc[2636]
80003254:	92 0a       	ld.sh	r10,r9[0x0]
80003256:	0c 0a       	add	r10,r6
80003258:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000325a:	fe f9 0a 3a 	ld.w	r9,pc[2618]
8000325e:	72 09       	ld.w	r9,r9[0x0]
80003260:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003264:	2f f8       	sub	r8,-1
80003266:	fe f9 0a 22 	ld.w	r9,pc[2594]
8000326a:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000326c:	fe f9 0a 18 	ld.w	r9,pc[2584]
80003270:	92 08       	ld.sh	r8,r9[0x0]
80003272:	20 28       	sub	r8,2
80003274:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003276:	30 09       	mov	r9,0
80003278:	f2 08 19 00 	cp.h	r8,r9
8000327c:	e0 89 00 25 	brgt	800032c6 <phy_rx_func+0x20e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003280:	30 39       	mov	r9,3
80003282:	fe f8 09 fe 	ld.w	r8,pc[2558]
80003286:	91 09       	st.w	r8[0x0],r9
80003288:	c1 f8       	rjmp	800032c6 <phy_rx_func+0x20e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000328a:	e6 16 00 ff 	andh	r6,0xff,COH
8000328e:	fc 18 00 ba 	movh	r8,0xba
80003292:	10 36       	cp.w	r6,r8
80003294:	c0 e1       	brne	800032b0 <phy_rx_func+0x1f8>
80003296:	fe f8 0a 06 	ld.w	r8,pc[2566]
8000329a:	90 09       	ld.sh	r9,r8[0x0]
8000329c:	30 08       	mov	r8,0
8000329e:	f0 09 19 00 	cp.h	r9,r8
800032a2:	c0 71       	brne	800032b0 <phy_rx_func+0x1f8>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800032a4:	fe f8 09 f0 	ld.w	r8,pc[2544]
800032a8:	70 0c       	ld.w	r12,r8[0x0]
800032aa:	f0 1f 02 7e 	mcall	80003ca0 <phy_rx_func+0xbe8>
800032ae:	c0 88       	rjmp	800032be <phy_rx_func+0x206>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800032b0:	fe f6 09 e4 	ld.w	r6,pc[2532]
800032b4:	6c 0c       	ld.w	r12,r6[0x0]
800032b6:	f0 1f 02 79 	mcall	80003c98 <phy_rx_func+0xbe0>
				phy_frame_ptr = NULL;
800032ba:	30 08       	mov	r8,0
800032bc:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800032be:	30 09       	mov	r9,0
800032c0:	fe f8 09 c0 	ld.w	r8,pc[2496]
800032c4:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	static U32  phy_rx_count = 0;
	
	phy_rx_count++;
800032c6:	fe f8 09 de 	ld.w	r8,pc[2526]
800032ca:	70 09       	ld.w	r9,r8[0x0]
800032cc:	2f f9       	sub	r9,-1
800032ce:	91 09       	st.w	r8[0x0],r9
		//memcpy(debug_output, "payloadrec", 10);
		//test_data = payload_rx_channel->dword[0];
		//phy_rx_count = 0;
	}
	
	if(is_first == FALSE)
800032d0:	fe f8 09 d8 	ld.w	r8,pc[2520]
800032d4:	11 89       	ld.ub	r9,r8[0x0]
800032d6:	30 08       	mov	r8,0
800032d8:	f0 09 18 00 	cp.b	r9,r8
800032dc:	c0 d1       	brne	800032f6 <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800032de:	fe f8 09 ce 	ld.w	r8,pc[2510]
800032e2:	70 0c       	ld.w	r12,r8[0x0]
800032e4:	f0 1f 02 6b 	mcall	80003c90 <phy_rx_func+0xbd8>
800032e8:	fe f8 09 c8 	ld.w	r8,pc[2504]
800032ec:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032ee:	30 19       	mov	r9,1
800032f0:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032f4:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032f6:	fe f8 09 be 	ld.w	r8,pc[2494]
800032fa:	70 08       	ld.w	r8,r8[0x0]
800032fc:	58 38       	cp.w	r8,3
800032fe:	e0 80 04 7a 	breq	80003bf2 <phy_rx_func+0xb3a>
80003302:	58 48       	cp.w	r8,4
80003304:	e0 80 01 02 	breq	80003508 <phy_rx_func+0x450>
80003308:	58 08       	cp.w	r8,0
8000330a:	e0 81 04 b7 	brne	80003c78 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000330e:	6e 28       	ld.w	r8,r7[0x8]
80003310:	e0 6a 5a 5a 	mov	r10,23130
80003314:	ea 1a ab cd 	orh	r10,0xabcd
80003318:	14 38       	cp.w	r8,r10
8000331a:	c0 71       	brne	80003328 <phy_rx_func+0x270>
			{				
				m_RxBurstType = VOICE_WATING;
8000331c:	30 09       	mov	r9,0
8000331e:	fe f8 09 9a 	ld.w	r8,pc[2458]
80003322:	91 09       	st.w	r8[0x0],r9
80003324:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003328:	10 99       	mov	r9,r8
8000332a:	e0 19 00 00 	andl	r9,0x0
8000332e:	fc 1a ab cd 	movh	r10,0xabcd
80003332:	14 39       	cp.w	r9,r10
80003334:	e0 81 04 a2 	brne	80003c78 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003338:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000333c:	fe f9 09 80 	ld.w	r9,pc[2432]
80003340:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
80003342:	fe f8 09 6e 	ld.w	r8,pc[2414]
80003346:	70 08       	ld.w	r8,r8[0x0]
80003348:	58 08       	cp.w	r8,0
8000334a:	c1 11       	brne	8000336c <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
8000334c:	fe f8 09 60 	ld.w	r8,pc[2400]
80003350:	70 0c       	ld.w	r12,r8[0x0]
80003352:	f0 1f 02 50 	mcall	80003c90 <phy_rx_func+0xbd8>
80003356:	fe f8 09 5a 	ld.w	r8,pc[2394]
8000335a:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
8000335c:	58 0c       	cp.w	r12,0
8000335e:	c0 71       	brne	8000336c <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003360:	fe fc 09 60 	ld.w	r12,pc[2400]
80003364:	f0 1f 02 58 	mcall	80003cc4 <phy_rx_func+0xc0c>
80003368:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000336c:	6e 28       	ld.w	r8,r7[0x8]
8000336e:	e2 18 f0 00 	andl	r8,0xf000,COH
80003372:	e0 48 c0 00 	cp.w	r8,49152
80003376:	e0 81 00 c3 	brne	800034fc <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
8000337a:	30 19       	mov	r9,1
8000337c:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003380:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
80003382:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003386:	fe f8 09 46 	ld.w	r8,pc[2374]
8000338a:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000338c:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003390:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003394:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003398:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000339a:	11 88       	ld.ub	r8,r8[0x0]
8000339c:	37 f9       	mov	r9,127
8000339e:	f2 08 18 00 	cp.b	r8,r9
800033a2:	c6 d0       	breq	8000347c <phy_rx_func+0x3c4>
800033a4:	e0 8b 00 0c 	brhi	800033bc <phy_rx_func+0x304>
800033a8:	31 29       	mov	r9,18
800033aa:	f2 08 18 00 	cp.b	r8,r9
800033ae:	c4 20       	breq	80003432 <phy_rx_func+0x37a>
800033b0:	31 39       	mov	r9,19
800033b2:	f2 08 18 00 	cp.b	r8,r9
800033b6:	e0 81 00 83 	brne	800034bc <phy_rx_func+0x404>
800033ba:	c5 b8       	rjmp	80003470 <phy_rx_func+0x3b8>
800033bc:	2f 08       	sub	r8,-16
800033be:	30 19       	mov	r9,1
800033c0:	f2 08 18 00 	cp.b	r8,r9
800033c4:	e0 8b 00 7c 	brhi	800034bc <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800033c8:	ef 38 00 0e 	ld.ub	r8,r7[14]
800033cc:	e2 18 00 f0 	andl	r8,0xf0,COH
800033d0:	59 08       	cp.w	r8,16
800033d2:	c0 71       	brne	800033e0 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
800033d4:	30 19       	mov	r9,1
800033d6:	fe f8 08 e2 	ld.w	r8,pc[2274]
800033da:	91 09       	st.w	r8[0x0],r9
800033dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800033e0:	e0 48 00 20 	cp.w	r8,32
800033e4:	c2 11       	brne	80003426 <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800033e6:	30 a9       	mov	r9,10
800033e8:	fe f8 08 d0 	ld.w	r8,pc[2256]
800033ec:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033ee:	fe f6 08 e6 	ld.w	r6,pc[2278]
800033f2:	6c 08       	ld.w	r8,r6[0x0]
800033f4:	f0 0a 11 ff 	rsub	r10,r8,-1
800033f8:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033fc:	2f f8       	sub	r8,-1
800033fe:	6e 0c       	ld.w	r12,r7[0x0]
80003400:	f4 ca fe 00 	sub	r10,r10,-512
80003404:	30 0b       	mov	r11,0
80003406:	10 0c       	add	r12,r8
80003408:	f0 1f 02 34 	mcall	80003cd8 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
8000340c:	30 08       	mov	r8,0
8000340e:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003410:	6e 0c       	ld.w	r12,r7[0x0]
80003412:	f0 1f 02 33 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003416:	fe f8 08 96 	ld.w	r8,pc[2198]
8000341a:	70 0c       	ld.w	r12,r8[0x0]
8000341c:	f0 1f 02 1d 	mcall	80003c90 <phy_rx_func+0xbd8>
80003420:	8f 0c       	st.w	r7[0x0],r12
80003422:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003426:	30 09       	mov	r9,0
80003428:	fe f8 08 90 	ld.w	r8,pc[2192]
8000342c:	91 09       	st.w	r8[0x0],r9
8000342e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003432:	fe f9 08 8a 	ld.w	r9,pc[2186]
80003436:	72 08       	ld.w	r8,r9[0x0]
80003438:	20 48       	sub	r8,4
8000343a:	93 08       	st.w	r9[0x0],r8
8000343c:	e0 80 04 1e 	breq	80003c78 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003440:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003444:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003448:	fe f8 08 98 	ld.w	r8,pc[2200]
8000344c:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000344e:	8e 69       	ld.sh	r9,r7[0xc]
80003450:	fe f8 08 94 	ld.w	r8,pc[2196]
80003454:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003456:	8e 79       	ld.sh	r9,r7[0xe]
80003458:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000345a:	f0 1f 02 24 	mcall	80003ce8 <phy_rx_func+0xc30>
8000345e:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003462:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003464:	30 49       	mov	r9,4
80003466:	fe f8 08 4e 	ld.w	r8,pc[2126]
8000346a:	91 09       	st.w	r8[0x0],r9
8000346c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003470:	30 09       	mov	r9,0
80003472:	fe f8 08 46 	ld.w	r8,pc[2118]
80003476:	91 09       	st.w	r8[0x0],r9
80003478:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000347c:	fe f9 08 40 	ld.w	r9,pc[2112]
80003480:	72 08       	ld.w	r8,r9[0x0]
80003482:	20 48       	sub	r8,4
80003484:	93 08       	st.w	r9[0x0],r8
80003486:	e0 80 03 f9 	breq	80003c78 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000348a:	fe f8 08 62 	ld.w	r8,pc[2146]
8000348e:	70 09       	ld.w	r9,r8[0x0]
80003490:	8e 7b       	ld.sh	r11,r7[0xe]
80003492:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003496:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000349a:	2f f9       	sub	r9,-1
8000349c:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000349e:	fe f8 08 32 	ld.w	r8,pc[2098]
800034a2:	70 09       	ld.w	r9,r8[0x0]
800034a4:	20 29       	sub	r9,2
800034a6:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800034a8:	30 29       	mov	r9,2
800034aa:	fe f8 08 0e 	ld.w	r8,pc[2062]
800034ae:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800034b0:	30 39       	mov	r9,3
800034b2:	fe f8 08 02 	ld.w	r8,pc[2050]
800034b6:	91 09       	st.w	r8[0x0],r9
800034b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800034bc:	30 39       	mov	r9,3
800034be:	fe f8 07 fa 	ld.w	r8,pc[2042]
800034c2:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
800034c4:	6e 29       	ld.w	r9,r7[0x8]
800034c6:	fe f8 08 2e 	ld.w	r8,pc[2094]
800034ca:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
800034cc:	6e 39       	ld.w	r9,r7[0xc]
800034ce:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
800034d0:	fe f8 07 ec 	ld.w	r8,pc[2028]
800034d4:	70 08       	ld.w	r8,r8[0x0]
800034d6:	59 48       	cp.w	r8,20
800034d8:	c0 61       	brne	800034e4 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800034da:	31 89       	mov	r9,24
800034dc:	fe f8 07 e0 	ld.w	r8,pc[2016]
800034e0:	91 09       	st.w	r8[0x0],r9
800034e2:	c0 78       	rjmp	800034f0 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800034e4:	59 08       	cp.w	r8,16
800034e6:	c0 51       	brne	800034f0 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800034e8:	31 09       	mov	r9,16
800034ea:	fe f8 07 d2 	ld.w	r8,pc[2002]
800034ee:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034f0:	30 49       	mov	r9,4
800034f2:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034f6:	91 09       	st.w	r8[0x0],r9
800034f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034fc:	30 09       	mov	r9,0
800034fe:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003502:	b0 89       	st.b	r8[0x0],r9
80003504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003508:	fe f8 07 c4 	ld.w	r8,pc[1988]
8000350c:	11 89       	ld.ub	r9,r8[0x0]
8000350e:	31 28       	mov	r8,18
80003510:	f0 09 18 00 	cp.b	r9,r8
80003514:	e0 81 01 4c 	brne	800037ac <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
80003518:	ef 39 00 09 	ld.ub	r9,r7[9]
8000351c:	fe f8 07 b0 	ld.w	r8,pc[1968]
80003520:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003522:	11 89       	ld.ub	r9,r8[0x0]
80003524:	3f 28       	mov	r8,-14
80003526:	f0 09 18 00 	cp.b	r9,r8
8000352a:	e0 81 01 3b 	brne	800037a0 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
8000352e:	30 19       	mov	r9,1
80003530:	fe f8 07 c8 	ld.w	r8,pc[1992]
80003534:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003536:	6e 29       	ld.w	r9,r7[0x8]
80003538:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000353c:	fe f8 07 80 	ld.w	r8,pc[1920]
80003540:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003542:	8e 59       	ld.sh	r9,r7[0xa]
80003544:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003548:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000354a:	8e 69       	ld.sh	r9,r7[0xc]
8000354c:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000354e:	8e 79       	ld.sh	r9,r7[0xe]
80003550:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003552:	fe f8 07 82 	ld.w	r8,pc[1922]
80003556:	fe f9 07 5a 	ld.w	r9,pc[1882]
8000355a:	72 0a       	ld.w	r10,r9[0x0]
8000355c:	70 09       	ld.w	r9,r8[0x0]
8000355e:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003562:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003566:	70 09       	ld.w	r9,r8[0x0]
80003568:	2f f9       	sub	r9,-1
8000356a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000356c:	e0 49 01 ff 	cp.w	r9,511
80003570:	e0 88 00 16 	brls	8000359c <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003574:	30 09       	mov	r9,0
80003576:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003578:	fe f6 07 38 	ld.w	r6,pc[1848]
8000357c:	6c 0c       	ld.w	r12,r6[0x0]
8000357e:	f0 1f 01 d8 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003582:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003586:	70 0c       	ld.w	r12,r8[0x0]
80003588:	f0 1f 01 c2 	mcall	80003c90 <phy_rx_func+0xbd8>
8000358c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000358e:	c0 71       	brne	8000359c <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003590:	30 09       	mov	r9,0
80003592:	fe f8 07 22 	ld.w	r8,pc[1826]
80003596:	91 09       	st.w	r8[0x0],r9
80003598:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000359c:	fe f9 07 20 	ld.w	r9,pc[1824]
800035a0:	72 08       	ld.w	r8,r9[0x0]
800035a2:	20 18       	sub	r8,1
800035a4:	93 08       	st.w	r9[0x0],r8
800035a6:	c0 71       	brne	800035b4 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
800035a8:	30 09       	mov	r9,0
800035aa:	fe f8 07 0a 	ld.w	r8,pc[1802]
800035ae:	91 09       	st.w	r8[0x0],r9
800035b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800035b4:	fe f8 07 20 	ld.w	r8,pc[1824]
800035b8:	fe f9 06 f8 	ld.w	r9,pc[1784]
800035bc:	72 0a       	ld.w	r10,r9[0x0]
800035be:	70 09       	ld.w	r9,r8[0x0]
800035c0:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035c4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035c8:	70 09       	ld.w	r9,r8[0x0]
800035ca:	2f f9       	sub	r9,-1
800035cc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035ce:	e0 49 01 ff 	cp.w	r9,511
800035d2:	e0 88 00 16 	brls	800035fe <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
800035d6:	30 09       	mov	r9,0
800035d8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035da:	fe f6 06 d6 	ld.w	r6,pc[1750]
800035de:	6c 0c       	ld.w	r12,r6[0x0]
800035e0:	f0 1f 01 bf 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035e4:	fe f8 06 c8 	ld.w	r8,pc[1736]
800035e8:	70 0c       	ld.w	r12,r8[0x0]
800035ea:	f0 1f 01 aa 	mcall	80003c90 <phy_rx_func+0xbd8>
800035ee:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035f0:	c0 71       	brne	800035fe <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
800035f2:	30 09       	mov	r9,0
800035f4:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035f8:	91 09       	st.w	r8[0x0],r9
800035fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035fe:	fe f9 06 be 	ld.w	r9,pc[1726]
80003602:	72 08       	ld.w	r8,r9[0x0]
80003604:	20 18       	sub	r8,1
80003606:	93 08       	st.w	r9[0x0],r8
80003608:	c0 71       	brne	80003616 <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
8000360a:	30 09       	mov	r9,0
8000360c:	fe f8 06 a8 	ld.w	r8,pc[1704]
80003610:	91 09       	st.w	r8[0x0],r9
80003612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003616:	fe f8 06 be 	ld.w	r8,pc[1726]
8000361a:	fe f9 06 96 	ld.w	r9,pc[1686]
8000361e:	72 0a       	ld.w	r10,r9[0x0]
80003620:	70 09       	ld.w	r9,r8[0x0]
80003622:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003626:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000362a:	70 09       	ld.w	r9,r8[0x0]
8000362c:	2f f9       	sub	r9,-1
8000362e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003630:	e0 49 01 ff 	cp.w	r9,511
80003634:	e0 88 00 16 	brls	80003660 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003638:	30 09       	mov	r9,0
8000363a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000363c:	fe f6 06 74 	ld.w	r6,pc[1652]
80003640:	6c 0c       	ld.w	r12,r6[0x0]
80003642:	f0 1f 01 a7 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003646:	fe f8 06 66 	ld.w	r8,pc[1638]
8000364a:	70 0c       	ld.w	r12,r8[0x0]
8000364c:	f0 1f 01 91 	mcall	80003c90 <phy_rx_func+0xbd8>
80003650:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003652:	c0 71       	brne	80003660 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003654:	30 09       	mov	r9,0
80003656:	fe f8 06 5e 	ld.w	r8,pc[1630]
8000365a:	91 09       	st.w	r8[0x0],r9
8000365c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003660:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003664:	72 08       	ld.w	r8,r9[0x0]
80003666:	20 18       	sub	r8,1
80003668:	93 08       	st.w	r9[0x0],r8
8000366a:	c0 71       	brne	80003678 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
8000366c:	30 09       	mov	r9,0
8000366e:	fe f8 06 46 	ld.w	r8,pc[1606]
80003672:	91 09       	st.w	r8[0x0],r9
80003674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003678:	fe f8 06 5c 	ld.w	r8,pc[1628]
8000367c:	fe f9 06 34 	ld.w	r9,pc[1588]
80003680:	72 0a       	ld.w	r10,r9[0x0]
80003682:	70 09       	ld.w	r9,r8[0x0]
80003684:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003688:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000368c:	70 09       	ld.w	r9,r8[0x0]
8000368e:	2f f9       	sub	r9,-1
80003690:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003692:	e0 49 01 ff 	cp.w	r9,511
80003696:	e0 88 00 16 	brls	800036c2 <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
8000369a:	30 09       	mov	r9,0
8000369c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000369e:	fe f6 06 12 	ld.w	r6,pc[1554]
800036a2:	6c 0c       	ld.w	r12,r6[0x0]
800036a4:	f0 1f 01 8e 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036a8:	fe f8 06 04 	ld.w	r8,pc[1540]
800036ac:	70 0c       	ld.w	r12,r8[0x0]
800036ae:	f0 1f 01 79 	mcall	80003c90 <phy_rx_func+0xbd8>
800036b2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036b4:	c0 71       	brne	800036c2 <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
800036b6:	30 09       	mov	r9,0
800036b8:	fe f8 05 fc 	ld.w	r8,pc[1532]
800036bc:	91 09       	st.w	r8[0x0],r9
800036be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036c2:	fe f9 05 fa 	ld.w	r9,pc[1530]
800036c6:	72 08       	ld.w	r8,r9[0x0]
800036c8:	20 18       	sub	r8,1
800036ca:	93 08       	st.w	r9[0x0],r8
800036cc:	c0 71       	brne	800036da <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
800036ce:	30 09       	mov	r9,0
800036d0:	fe f8 05 e4 	ld.w	r8,pc[1508]
800036d4:	91 09       	st.w	r8[0x0],r9
800036d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036da:	fe f8 05 fa 	ld.w	r8,pc[1530]
800036de:	fe f9 05 d2 	ld.w	r9,pc[1490]
800036e2:	72 0a       	ld.w	r10,r9[0x0]
800036e4:	70 09       	ld.w	r9,r8[0x0]
800036e6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036ee:	70 09       	ld.w	r9,r8[0x0]
800036f0:	2f f9       	sub	r9,-1
800036f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036f4:	e0 49 01 ff 	cp.w	r9,511
800036f8:	e0 88 00 16 	brls	80003724 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036fc:	30 09       	mov	r9,0
800036fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003700:	fe f6 05 b0 	ld.w	r6,pc[1456]
80003704:	6c 0c       	ld.w	r12,r6[0x0]
80003706:	f0 1f 01 76 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000370a:	fe f8 05 a2 	ld.w	r8,pc[1442]
8000370e:	70 0c       	ld.w	r12,r8[0x0]
80003710:	f0 1f 01 60 	mcall	80003c90 <phy_rx_func+0xbd8>
80003714:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003716:	c0 71       	brne	80003724 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
80003718:	30 09       	mov	r9,0
8000371a:	fe f8 05 9a 	ld.w	r8,pc[1434]
8000371e:	91 09       	st.w	r8[0x0],r9
80003720:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003724:	fe f9 05 98 	ld.w	r9,pc[1432]
80003728:	72 08       	ld.w	r8,r9[0x0]
8000372a:	20 18       	sub	r8,1
8000372c:	93 08       	st.w	r9[0x0],r8
8000372e:	c0 71       	brne	8000373c <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003730:	30 09       	mov	r9,0
80003732:	fe f8 05 82 	ld.w	r8,pc[1410]
80003736:	91 09       	st.w	r8[0x0],r9
80003738:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000373c:	fe f8 05 98 	ld.w	r8,pc[1432]
80003740:	fe f9 05 70 	ld.w	r9,pc[1392]
80003744:	72 0a       	ld.w	r10,r9[0x0]
80003746:	70 09       	ld.w	r9,r8[0x0]
80003748:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000374c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003750:	70 09       	ld.w	r9,r8[0x0]
80003752:	2f f9       	sub	r9,-1
80003754:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003756:	e0 49 01 ff 	cp.w	r9,511
8000375a:	e0 88 00 16 	brls	80003786 <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
8000375e:	30 09       	mov	r9,0
80003760:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003762:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003766:	6e 0c       	ld.w	r12,r7[0x0]
80003768:	f0 1f 01 5d 	mcall	80003cdc <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000376c:	fe f8 05 40 	ld.w	r8,pc[1344]
80003770:	70 0c       	ld.w	r12,r8[0x0]
80003772:	f0 1f 01 48 	mcall	80003c90 <phy_rx_func+0xbd8>
80003776:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003778:	c0 71       	brne	80003786 <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
8000377a:	30 09       	mov	r9,0
8000377c:	fe f8 05 38 	ld.w	r8,pc[1336]
80003780:	91 09       	st.w	r8[0x0],r9
80003782:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003786:	fe f9 05 36 	ld.w	r9,pc[1334]
8000378a:	72 08       	ld.w	r8,r9[0x0]
8000378c:	20 18       	sub	r8,1
8000378e:	93 08       	st.w	r9[0x0],r8
80003790:	e0 81 02 74 	brne	80003c78 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003794:	30 09       	mov	r9,0
80003796:	fe f8 05 1e 	ld.w	r8,pc[1310]
8000379a:	91 09       	st.w	r8[0x0],r9
8000379c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800037a0:	30 09       	mov	r9,0
800037a2:	fe f8 05 12 	ld.w	r8,pc[1298]
800037a6:	91 09       	st.w	r8[0x0],r9
800037a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800037ac:	fe f8 05 20 	ld.w	r8,pc[1312]
800037b0:	11 89       	ld.ub	r9,r8[0x0]
800037b2:	3f 28       	mov	r8,-14
800037b4:	f0 09 18 00 	cp.b	r9,r8
800037b8:	c4 31       	brne	8000383e <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800037ba:	8e 49       	ld.sh	r9,r7[0x8]
800037bc:	fe f8 05 40 	ld.w	r8,pc[1344]
800037c0:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037c2:	fe f8 05 12 	ld.w	r8,pc[1298]
800037c6:	fe f9 04 ea 	ld.w	r9,pc[1258]
800037ca:	72 0a       	ld.w	r10,r9[0x0]
800037cc:	70 09       	ld.w	r9,r8[0x0]
800037ce:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037d2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037d6:	70 09       	ld.w	r9,r8[0x0]
800037d8:	2f f9       	sub	r9,-1
800037da:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037dc:	e0 49 01 ff 	cp.w	r9,511
800037e0:	e0 88 00 16 	brls	8000380c <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
800037e4:	30 09       	mov	r9,0
800037e6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037e8:	fe f7 04 c8 	ld.w	r7,pc[1224]
800037ec:	6e 0c       	ld.w	r12,r7[0x0]
800037ee:	f0 1f 01 3c 	mcall	80003cdc <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800037f2:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037f6:	70 0c       	ld.w	r12,r8[0x0]
800037f8:	f0 1f 01 26 	mcall	80003c90 <phy_rx_func+0xbd8>
800037fc:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037fe:	c0 71       	brne	8000380c <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
80003800:	30 09       	mov	r9,0
80003802:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003806:	91 09       	st.w	r8[0x0],r9
80003808:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000380c:	fe f9 04 b0 	ld.w	r9,pc[1200]
80003810:	72 08       	ld.w	r8,r9[0x0]
80003812:	20 18       	sub	r8,1
80003814:	93 08       	st.w	r9[0x0],r8
80003816:	c0 71       	brne	80003824 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
80003818:	30 09       	mov	r9,0
8000381a:	fe f8 04 9a 	ld.w	r8,pc[1178]
8000381e:	91 09       	st.w	r8[0x0],r9
80003820:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003824:	20 18       	sub	r8,1
80003826:	fe f9 04 96 	ld.w	r9,pc[1174]
8000382a:	93 08       	st.w	r9[0x0],r8
8000382c:	58 08       	cp.w	r8,0
8000382e:	e0 81 02 25 	brne	80003c78 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003832:	30 09       	mov	r9,0
80003834:	fe f8 04 80 	ld.w	r8,pc[1152]
80003838:	91 09       	st.w	r8[0x0],r9
8000383a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000383e:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003842:	11 89       	ld.ub	r9,r8[0x0]
80003844:	3f 38       	mov	r8,-13
80003846:	f0 09 18 00 	cp.b	r9,r8
8000384a:	e0 81 01 0c 	brne	80003a62 <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000384e:	8e 49       	ld.sh	r9,r7[0x8]
80003850:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003854:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003856:	8e 59       	ld.sh	r9,r7[0xa]
80003858:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000385a:	8e 69       	ld.sh	r9,r7[0xc]
8000385c:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000385e:	fe f8 04 76 	ld.w	r8,pc[1142]
80003862:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003866:	72 0a       	ld.w	r10,r9[0x0]
80003868:	70 09       	ld.w	r9,r8[0x0]
8000386a:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000386e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	2f f9       	sub	r9,-1
80003876:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003878:	e0 49 01 ff 	cp.w	r9,511
8000387c:	e0 88 00 16 	brls	800038a8 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003880:	30 09       	mov	r9,0
80003882:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003884:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003888:	6c 0c       	ld.w	r12,r6[0x0]
8000388a:	f0 1f 01 15 	mcall	80003cdc <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000388e:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003892:	70 0c       	ld.w	r12,r8[0x0]
80003894:	f0 1f 00 ff 	mcall	80003c90 <phy_rx_func+0xbd8>
80003898:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000389a:	c0 71       	brne	800038a8 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
8000389c:	30 09       	mov	r9,0
8000389e:	fe f8 04 16 	ld.w	r8,pc[1046]
800038a2:	91 09       	st.w	r8[0x0],r9
800038a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038a8:	fe f9 04 14 	ld.w	r9,pc[1044]
800038ac:	72 08       	ld.w	r8,r9[0x0]
800038ae:	20 18       	sub	r8,1
800038b0:	93 08       	st.w	r9[0x0],r8
800038b2:	c0 71       	brne	800038c0 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
800038b4:	30 09       	mov	r9,0
800038b6:	fe f8 03 fe 	ld.w	r8,pc[1022]
800038ba:	91 09       	st.w	r8[0x0],r9
800038bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038c0:	fe f8 04 14 	ld.w	r8,pc[1044]
800038c4:	fe f9 03 ec 	ld.w	r9,pc[1004]
800038c8:	72 0a       	ld.w	r10,r9[0x0]
800038ca:	70 09       	ld.w	r9,r8[0x0]
800038cc:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038d0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	2f f9       	sub	r9,-1
800038d8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038da:	e0 49 01 ff 	cp.w	r9,511
800038de:	e0 88 00 16 	brls	8000390a <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
800038e2:	30 09       	mov	r9,0
800038e4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038e6:	fe f6 03 ca 	ld.w	r6,pc[970]
800038ea:	6c 0c       	ld.w	r12,r6[0x0]
800038ec:	f0 1f 00 fc 	mcall	80003cdc <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038f0:	fe f8 03 bc 	ld.w	r8,pc[956]
800038f4:	70 0c       	ld.w	r12,r8[0x0]
800038f6:	f0 1f 00 e7 	mcall	80003c90 <phy_rx_func+0xbd8>
800038fa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038fc:	c0 71       	brne	8000390a <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038fe:	30 09       	mov	r9,0
80003900:	fe f8 03 b4 	ld.w	r8,pc[948]
80003904:	91 09       	st.w	r8[0x0],r9
80003906:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000390a:	fe f9 03 b2 	ld.w	r9,pc[946]
8000390e:	72 08       	ld.w	r8,r9[0x0]
80003910:	20 18       	sub	r8,1
80003912:	93 08       	st.w	r9[0x0],r8
80003914:	c0 71       	brne	80003922 <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
80003916:	30 09       	mov	r9,0
80003918:	fe f8 03 9c 	ld.w	r8,pc[924]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003922:	fe f8 03 b2 	ld.w	r8,pc[946]
80003926:	fe f9 03 8a 	ld.w	r9,pc[906]
8000392a:	72 0a       	ld.w	r10,r9[0x0]
8000392c:	70 09       	ld.w	r9,r8[0x0]
8000392e:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003932:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003936:	70 09       	ld.w	r9,r8[0x0]
80003938:	2f f9       	sub	r9,-1
8000393a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000393c:	e0 49 01 ff 	cp.w	r9,511
80003940:	e0 88 00 16 	brls	8000396c <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003944:	30 09       	mov	r9,0
80003946:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003948:	fe f6 03 68 	ld.w	r6,pc[872]
8000394c:	6c 0c       	ld.w	r12,r6[0x0]
8000394e:	f0 1f 00 e4 	mcall	80003cdc <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003952:	fe f8 03 5a 	ld.w	r8,pc[858]
80003956:	70 0c       	ld.w	r12,r8[0x0]
80003958:	f0 1f 00 ce 	mcall	80003c90 <phy_rx_func+0xbd8>
8000395c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000395e:	c0 71       	brne	8000396c <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003960:	30 09       	mov	r9,0
80003962:	fe f8 03 52 	ld.w	r8,pc[850]
80003966:	91 09       	st.w	r8[0x0],r9
80003968:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000396c:	fe f9 03 50 	ld.w	r9,pc[848]
80003970:	72 08       	ld.w	r8,r9[0x0]
80003972:	20 18       	sub	r8,1
80003974:	93 08       	st.w	r9[0x0],r8
80003976:	c0 71       	brne	80003984 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003978:	30 09       	mov	r9,0
8000397a:	fe f8 03 3a 	ld.w	r8,pc[826]
8000397e:	91 09       	st.w	r8[0x0],r9
80003980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003984:	fe f8 03 50 	ld.w	r8,pc[848]
80003988:	fe f9 03 28 	ld.w	r9,pc[808]
8000398c:	72 0a       	ld.w	r10,r9[0x0]
8000398e:	70 09       	ld.w	r9,r8[0x0]
80003990:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003994:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	2f f9       	sub	r9,-1
8000399c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000399e:	e0 49 01 ff 	cp.w	r9,511
800039a2:	e0 88 00 16 	brls	800039ce <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
800039a6:	30 09       	mov	r9,0
800039a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039aa:	fe f6 03 06 	ld.w	r6,pc[774]
800039ae:	6c 0c       	ld.w	r12,r6[0x0]
800039b0:	f0 1f 00 cb 	mcall	80003cdc <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039b4:	fe f8 02 f8 	ld.w	r8,pc[760]
800039b8:	70 0c       	ld.w	r12,r8[0x0]
800039ba:	f0 1f 00 b6 	mcall	80003c90 <phy_rx_func+0xbd8>
800039be:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039c0:	c0 71       	brne	800039ce <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
800039c2:	30 09       	mov	r9,0
800039c4:	fe f8 02 f0 	ld.w	r8,pc[752]
800039c8:	91 09       	st.w	r8[0x0],r9
800039ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039ce:	fe f9 02 ee 	ld.w	r9,pc[750]
800039d2:	72 08       	ld.w	r8,r9[0x0]
800039d4:	20 18       	sub	r8,1
800039d6:	93 08       	st.w	r9[0x0],r8
800039d8:	c0 71       	brne	800039e6 <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	fe f8 02 d8 	ld.w	r8,pc[728]
800039e0:	91 09       	st.w	r8[0x0],r9
800039e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039e6:	fe f8 02 ee 	ld.w	r8,pc[750]
800039ea:	fe f9 02 c6 	ld.w	r9,pc[710]
800039ee:	72 0a       	ld.w	r10,r9[0x0]
800039f0:	70 09       	ld.w	r9,r8[0x0]
800039f2:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039f6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039fa:	70 09       	ld.w	r9,r8[0x0]
800039fc:	2f f9       	sub	r9,-1
800039fe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a00:	e0 49 01 ff 	cp.w	r9,511
80003a04:	e0 88 00 16 	brls	80003a30 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a08:	30 09       	mov	r9,0
80003a0a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a0c:	fe f7 02 a4 	ld.w	r7,pc[676]
80003a10:	6e 0c       	ld.w	r12,r7[0x0]
80003a12:	f0 1f 00 b3 	mcall	80003cdc <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a16:	fe f8 02 96 	ld.w	r8,pc[662]
80003a1a:	70 0c       	ld.w	r12,r8[0x0]
80003a1c:	f0 1f 00 9d 	mcall	80003c90 <phy_rx_func+0xbd8>
80003a20:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a22:	c0 71       	brne	80003a30 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
80003a24:	30 09       	mov	r9,0
80003a26:	fe f8 02 8e 	ld.w	r8,pc[654]
80003a2a:	91 09       	st.w	r8[0x0],r9
80003a2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a30:	fe f9 02 8c 	ld.w	r9,pc[652]
80003a34:	72 08       	ld.w	r8,r9[0x0]
80003a36:	20 18       	sub	r8,1
80003a38:	93 08       	st.w	r9[0x0],r8
80003a3a:	c0 71       	brne	80003a48 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80003a3c:	30 09       	mov	r9,0
80003a3e:	fe f8 02 76 	ld.w	r8,pc[630]
80003a42:	91 09       	st.w	r8[0x0],r9
80003a44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a48:	20 18       	sub	r8,1
80003a4a:	fe f9 02 72 	ld.w	r9,pc[626]
80003a4e:	93 08       	st.w	r9[0x0],r8
80003a50:	58 08       	cp.w	r8,0
80003a52:	e0 81 01 13 	brne	80003c78 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a56:	30 09       	mov	r9,0
80003a58:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a5c:	91 09       	st.w	r8[0x0],r9
80003a5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a62:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a66:	11 89       	ld.ub	r9,r8[0x0]
80003a68:	30 48       	mov	r8,4
80003a6a:	f0 09 18 00 	cp.b	r9,r8
80003a6e:	c0 80       	breq	80003a7e <phy_rx_func+0x9c6>
80003a70:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a74:	11 89       	ld.ub	r9,r8[0x0]
80003a76:	30 38       	mov	r8,3
80003a78:	f0 09 18 00 	cp.b	r9,r8
80003a7c:	c1 41       	brne	80003aa4 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a7e:	6e 29       	ld.w	r9,r7[0x8]
80003a80:	fe f8 02 74 	ld.w	r8,pc[628]
80003a84:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a86:	6e 39       	ld.w	r9,r7[0xc]
80003a88:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a8a:	fe f9 02 32 	ld.w	r9,pc[562]
80003a8e:	72 08       	ld.w	r8,r9[0x0]
80003a90:	20 88       	sub	r8,8
80003a92:	93 08       	st.w	r9[0x0],r8
80003a94:	e0 81 00 f2 	brne	80003c78 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a98:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a9a:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a9e:	93 08       	st.w	r9[0x0],r8
80003aa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003aa4:	fe f8 02 28 	ld.w	r8,pc[552]
80003aa8:	11 89       	ld.ub	r9,r8[0x0]
80003aaa:	31 38       	mov	r8,19
80003aac:	f0 09 18 00 	cp.b	r9,r8
80003ab0:	e0 81 00 9c 	brne	80003be8 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003ab4:	fe f8 02 4c 	ld.w	r8,pc[588]
80003ab8:	11 88       	ld.ub	r8,r8[0x0]
80003aba:	30 c9       	mov	r9,12
80003abc:	f2 08 18 00 	cp.b	r8,r9
80003ac0:	e0 81 00 7b 	brne	80003bb6 <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003ac4:	8e 49       	ld.sh	r9,r7[0x8]
80003ac6:	fe f8 02 3e 	ld.w	r8,pc[574]
80003aca:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003ace:	30 09       	mov	r9,0
80003ad0:	fe f8 02 30 	ld.w	r8,pc[560]
80003ad4:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ad6:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ada:	3f 38       	mov	r8,-13
80003adc:	f0 09 18 00 	cp.b	r9,r8
80003ae0:	c6 61       	brne	80003bac <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ae2:	10 99       	mov	r9,r8
80003ae4:	4f a8       	lddpc	r8,80003ccc <phy_rx_func+0xc14>
80003ae6:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003ae8:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003aec:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003af0:	4f 38       	lddpc	r8,80003cbc <phy_rx_func+0xc04>
80003af2:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003af4:	30 19       	mov	r9,1
80003af6:	fe f8 02 12 	ld.w	r8,pc[530]
80003afa:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003afc:	8e 79       	ld.sh	r9,r7[0xe]
80003afe:	fe f8 01 fe 	ld.w	r8,pc[510]
80003b02:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b04:	4f 48       	lddpc	r8,80003cd4 <phy_rx_func+0xc1c>
80003b06:	4e b9       	lddpc	r9,80003cb0 <phy_rx_func+0xbf8>
80003b08:	72 0a       	ld.w	r10,r9[0x0]
80003b0a:	70 09       	ld.w	r9,r8[0x0]
80003b0c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b10:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b14:	70 09       	ld.w	r9,r8[0x0]
80003b16:	2f f9       	sub	r9,-1
80003b18:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b1a:	e0 49 01 ff 	cp.w	r9,511
80003b1e:	e0 88 00 13 	brls	80003b44 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b22:	30 09       	mov	r9,0
80003b24:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b26:	4e 36       	lddpc	r6,80003cb0 <phy_rx_func+0xbf8>
80003b28:	6c 0c       	ld.w	r12,r6[0x0]
80003b2a:	f0 1f 00 6d 	mcall	80003cdc <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b2e:	4e 08       	lddpc	r8,80003cac <phy_rx_func+0xbf4>
80003b30:	70 0c       	ld.w	r12,r8[0x0]
80003b32:	f0 1f 00 58 	mcall	80003c90 <phy_rx_func+0xbd8>
80003b36:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b38:	c0 61       	brne	80003b44 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003b3a:	30 09       	mov	r9,0
80003b3c:	4d e8       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003b3e:	91 09       	st.w	r8[0x0],r9
80003b40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b44:	4d e9       	lddpc	r9,80003cbc <phy_rx_func+0xc04>
80003b46:	72 08       	ld.w	r8,r9[0x0]
80003b48:	20 18       	sub	r8,1
80003b4a:	93 08       	st.w	r9[0x0],r8
80003b4c:	c0 61       	brne	80003b58 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003b4e:	30 09       	mov	r9,0
80003b50:	4d 98       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003b52:	91 09       	st.w	r8[0x0],r9
80003b54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b58:	4d f8       	lddpc	r8,80003cd4 <phy_rx_func+0xc1c>
80003b5a:	4d 69       	lddpc	r9,80003cb0 <phy_rx_func+0xbf8>
80003b5c:	72 0a       	ld.w	r10,r9[0x0]
80003b5e:	70 09       	ld.w	r9,r8[0x0]
80003b60:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b64:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b68:	70 09       	ld.w	r9,r8[0x0]
80003b6a:	2f f9       	sub	r9,-1
80003b6c:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b6e:	e0 49 01 ff 	cp.w	r9,511
80003b72:	e0 88 00 13 	brls	80003b98 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b76:	30 09       	mov	r9,0
80003b78:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b7a:	4c e7       	lddpc	r7,80003cb0 <phy_rx_func+0xbf8>
80003b7c:	6e 0c       	ld.w	r12,r7[0x0]
80003b7e:	f0 1f 00 58 	mcall	80003cdc <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b82:	4c b8       	lddpc	r8,80003cac <phy_rx_func+0xbf4>
80003b84:	70 0c       	ld.w	r12,r8[0x0]
80003b86:	f0 1f 00 43 	mcall	80003c90 <phy_rx_func+0xbd8>
80003b8a:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b8c:	c0 61       	brne	80003b98 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b8e:	30 09       	mov	r9,0
80003b90:	4c 98       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003b92:	91 09       	st.w	r8[0x0],r9
80003b94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b98:	4c 99       	lddpc	r9,80003cbc <phy_rx_func+0xc04>
80003b9a:	72 08       	ld.w	r8,r9[0x0]
80003b9c:	20 18       	sub	r8,1
80003b9e:	93 08       	st.w	r9[0x0],r8
80003ba0:	c6 c1       	brne	80003c78 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003ba2:	30 09       	mov	r9,0
80003ba4:	4c 48       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003ba6:	91 09       	st.w	r8[0x0],r9
80003ba8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003bac:	30 09       	mov	r9,0
80003bae:	4c 28       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003bb0:	91 09       	st.w	r8[0x0],r9
80003bb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003bb6:	8e 4a       	ld.sh	r10,r7[0x8]
80003bb8:	4d 39       	lddpc	r9,80003d04 <phy_rx_func+0xc4c>
80003bba:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003bbe:	4d 1a       	lddpc	r10,80003d00 <phy_rx_func+0xc48>
80003bc0:	15 88       	ld.ub	r8,r10[0x0]
80003bc2:	f0 cb ff ff 	sub	r11,r8,-1
80003bc6:	8e 5c       	ld.sh	r12,r7[0xa]
80003bc8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003bcc:	f0 cb ff fe 	sub	r11,r8,-2
80003bd0:	8e 6c       	ld.sh	r12,r7[0xc]
80003bd2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003bd6:	f0 cb ff fd 	sub	r11,r8,-3
80003bda:	8e 7c       	ld.sh	r12,r7[0xe]
80003bdc:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003be0:	2f c8       	sub	r8,-4
80003be2:	b4 88       	st.b	r10[0x0],r8
80003be4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003be8:	30 09       	mov	r9,0
80003bea:	4b 38       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003bec:	91 09       	st.w	r8[0x0],r9
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bf2:	4b f8       	lddpc	r8,80003cec <phy_rx_func+0xc34>
80003bf4:	70 09       	ld.w	r9,r8[0x0]
80003bf6:	8e 4b       	ld.sh	r11,r7[0x8]
80003bf8:	4b ea       	lddpc	r10,80003cf0 <phy_rx_func+0xc38>
80003bfa:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bfe:	2f f9       	sub	r9,-1
80003c00:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c02:	4b 48       	lddpc	r8,80003cd0 <phy_rx_func+0xc18>
80003c04:	70 09       	ld.w	r9,r8[0x0]
80003c06:	20 29       	sub	r9,2
80003c08:	91 09       	st.w	r8[0x0],r9
80003c0a:	70 08       	ld.w	r8,r8[0x0]
80003c0c:	58 08       	cp.w	r8,0
80003c0e:	c2 f1       	brne	80003c6c <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003c10:	30 09       	mov	r9,0
80003c12:	4b 78       	lddpc	r8,80003cec <phy_rx_func+0xc34>
80003c14:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c16:	8e 59       	ld.sh	r9,r7[0xa]
80003c18:	fe 78 82 12 	mov	r8,-32238
80003c1c:	f0 09 19 00 	cp.h	r9,r8
80003c20:	c2 11       	brne	80003c62 <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c22:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c26:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c2a:	4a e8       	lddpc	r8,80003ce0 <phy_rx_func+0xc28>
80003c2c:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c2e:	8e 59       	ld.sh	r9,r7[0xa]
80003c30:	4a d8       	lddpc	r8,80003ce4 <phy_rx_func+0xc2c>
80003c32:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c34:	8e 69       	ld.sh	r9,r7[0xc]
80003c36:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c38:	f0 1f 00 2c 	mcall	80003ce8 <phy_rx_func+0xc30>
80003c3c:	49 f8       	lddpc	r8,80003cb8 <phy_rx_func+0xc00>
80003c3e:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c40:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c44:	31 38       	mov	r8,19
80003c46:	f0 09 18 00 	cp.b	r9,r8
80003c4a:	c0 71       	brne	80003c58 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c4c:	10 99       	mov	r9,r8
80003c4e:	4a 08       	lddpc	r8,80003ccc <phy_rx_func+0xc14>
80003c50:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c52:	30 09       	mov	r9,0
80003c54:	49 a8       	lddpc	r8,80003cbc <phy_rx_func+0xc04>
80003c56:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c58:	30 49       	mov	r9,4
80003c5a:	49 78       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003c5c:	91 09       	st.w	r8[0x0],r9
80003c5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c62:	30 09       	mov	r9,0
80003c64:	49 48       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c6c:	4a 8c       	lddpc	r12,80003d0c <phy_rx_func+0xc54>
80003c6e:	f0 1f 00 16 	mcall	80003cc4 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c72:	30 09       	mov	r9,0
80003c74:	49 08       	lddpc	r8,80003cb4 <phy_rx_func+0xbfc>
80003c76:	91 09       	st.w	r8[0x0],r9
80003c78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a b4       	st.h	r5++,r4
80003c80:	00 00       	add	r0,r0
80003c82:	0a 98       	mov	r8,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a 74       	tst	r4,r5
80003c88:	00 00       	add	r0,r0
80003c8a:	0a e0       	st.h	--r5,r0
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a b0       	st.h	r5++,r0
80003c90:	80 00       	ld.sh	r0,r0[0x0]
80003c92:	2a 84       	sub	r4,-88
80003c94:	00 00       	add	r0,r0
80003c96:	0a 80       	andn	r0,r5
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	4e 40       	lddpc	r0,80003e28 <local_start_PDC+0x44>
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a a0       	st.w	r5++,r0
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	29 d0       	sub	r0,-99
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a c8       	st.b	r5++,r8
80003ca8:	00 00       	add	r0,r0
80003caa:	0a a2       	st.w	r5++,r2
80003cac:	00 00       	add	r0,r0
80003cae:	0a 7c       	tst	r12,r5
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a a4       	st.w	r5++,r4
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a d8       	st.w	--r5,r8
80003cb8:	00 00       	add	r0,r0
80003cba:	0a 78       	tst	r8,r5
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a 9c       	mov	r12,r5
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	c5 a4       	brge	80003d76 <pdca_int_handler+0x66>
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	5e e0       	retqs	r0
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 58       	eor	r8,r5
80003ccc:	00 00       	add	r0,r0
80003cce:	0a e2       	st.h	--r5,r2
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a c4       	st.b	r5++,r4
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a a8       	st.w	r5++,r8
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	68 0c       	ld.w	r12,r4[0x0]
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	30 58       	mov	r8,5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a 59       	eor	r9,r5
80003ce4:	00 00       	add	r0,r0
80003ce6:	0e 8c       	andn	r12,r7
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	29 14       	sub	r4,-111
80003cec:	00 00       	add	r0,r0
80003cee:	0a d4       	st.w	--r5,r4
80003cf0:	00 00       	add	r0,r0
80003cf2:	0d 90       	ld.ub	r0,r6[0x1]
80003cf4:	00 00       	add	r0,r0
80003cf6:	0a 90       	mov	r0,r5
80003cf8:	00 00       	add	r0,r0
80003cfa:	0a 50       	eor	r0,r5
80003cfc:	00 00       	add	r0,r0
80003cfe:	0d 88       	ld.ub	r8,r6[0x0]
80003d00:	00 00       	add	r0,r0
80003d02:	0a 84       	andn	r4,r5
80003d04:	00 00       	add	r0,r0
80003d06:	0e 90       	mov	r0,r7
80003d08:	00 00       	add	r0,r0
80003d0a:	0a 5b       	eor	r11,r5
80003d0c:	80 00       	ld.sh	r0,r0[0x0]
80003d0e:	c5 bc       	rcall	80003dc4 <local_start_SSC+0x24>

80003d10 <pdca_int_handler>:
Called By: interrupt
*/

__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d10:	d4 01       	pushm	lr
    static U32 rx_count = 0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d12:	49 e8       	lddpc	r8,80003d88 <pdca_int_handler+0x78>
80003d14:	11 89       	ld.ub	r9,r8[0x0]
80003d16:	ec 19 00 01 	eorl	r9,0x1
80003d1a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d1c:	11 89       	ld.ub	r9,r8[0x0]
80003d1e:	a5 69       	lsl	r9,0x4
80003d20:	2f c9       	sub	r9,-4
80003d22:	49 ba       	lddpc	r10,80003d8c <pdca_int_handler+0x7c>
80003d24:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d26:	fe 7a 00 40 	mov	r10,-65472
80003d2a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d2c:	30 39       	mov	r9,3
80003d2e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d30:	11 8a       	ld.ub	r10,r8[0x0]
80003d32:	a5 6a       	lsl	r10,0x4
80003d34:	2f ca       	sub	r10,-4
80003d36:	49 78       	lddpc	r8,80003d90 <pdca_int_handler+0x80>
80003d38:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d3a:	fe 78 00 00 	mov	r8,-65536
80003d3e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d40:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d42:	70 b8       	ld.w	r8,r8[0x2c]
	
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d44:	49 48       	lddpc	r8,80003d94 <pdca_int_handler+0x84>
80003d46:	70 08       	ld.w	r8,r8[0x0]
80003d48:	58 08       	cp.w	r8,0
80003d4a:	c0 70       	breq	80003d58 <pdca_int_handler+0x48>
80003d4c:	48 f9       	lddpc	r9,80003d88 <pdca_int_handler+0x78>
80003d4e:	13 89       	ld.ub	r9,r9[0x0]
80003d50:	a5 69       	lsl	r9,0x4
80003d52:	49 0c       	lddpc	r12,80003d90 <pdca_int_handler+0x80>
80003d54:	12 0c       	add	r12,r9
80003d56:	5d 18       	icall	r8
	rx_count++;
80003d58:	49 08       	lddpc	r8,80003d98 <pdca_int_handler+0x88>
80003d5a:	70 09       	ld.w	r9,r8[0x0]
80003d5c:	2f f9       	sub	r9,-1
80003d5e:	91 09       	st.w	r8[0x0],r9
	if(RxBuffer[BufferIndex].xnl_channel.dword == 0xABCD4015){
80003d60:	48 a8       	lddpc	r8,80003d88 <pdca_int_handler+0x78>
80003d62:	11 89       	ld.ub	r9,r8[0x0]
80003d64:	a3 69       	lsl	r9,0x2
80003d66:	2f f9       	sub	r9,-1
80003d68:	48 a8       	lddpc	r8,80003d90 <pdca_int_handler+0x80>
80003d6a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
		//memcpy( (unsigned char *)slot,(unsigned char *) &RxBuffer[BufferIndex], 16);
	}

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d6e:	48 c8       	lddpc	r8,80003d9c <pdca_int_handler+0x8c>
80003d70:	70 08       	ld.w	r8,r8[0x0]
80003d72:	58 08       	cp.w	r8,0
80003d74:	c0 70       	breq	80003d82 <pdca_int_handler+0x72>
80003d76:	48 59       	lddpc	r9,80003d88 <pdca_int_handler+0x78>
80003d78:	13 89       	ld.ub	r9,r9[0x0]
80003d7a:	a5 69       	lsl	r9,0x4
80003d7c:	48 4c       	lddpc	r12,80003d8c <pdca_int_handler+0x7c>
80003d7e:	12 0c       	add	r12,r9
80003d80:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d82:	d4 02       	popm	lr
80003d84:	d6 03       	rete
80003d86:	00 00       	add	r0,r0
80003d88:	00 00       	add	r0,r0
80003d8a:	40 b0       	lddsp	r0,sp[0x2c]
80003d8c:	00 00       	add	r0,r0
80003d8e:	40 d8       	lddsp	r8,sp[0x34]
80003d90:	00 00       	add	r0,r0
80003d92:	40 b8       	lddsp	r8,sp[0x2c]
80003d94:	00 00       	add	r0,r0
80003d96:	0a e8       	st.h	--r5,r8
80003d98:	00 00       	add	r0,r0
80003d9a:	0a e4       	st.h	--r5,r4
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a ec       	st.h	--r5,r12

80003da0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003da0:	fe 78 10 00 	mov	r8,-61440
80003da4:	e0 69 0d c0 	mov	r9,3520
80003da8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003dac:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003db0:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003db4:	fe 78 34 00 	mov	r8,-52224
80003db8:	e0 69 80 00 	mov	r9,32768
80003dbc:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003dbe:	30 09       	mov	r9,0
80003dc0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003dc2:	e0 69 04 21 	mov	r9,1057
80003dc6:	ea 19 3f 20 	orh	r9,0x3f20
80003dca:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003dcc:	e0 69 02 9f 	mov	r9,671
80003dd0:	ea 19 01 00 	orh	r9,0x100
80003dd4:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003dd6:	e0 6a 04 02 	mov	r10,1026
80003dda:	ea 1a 3f 20 	orh	r10,0x3f20
80003dde:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003de0:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003de2:	5e fc       	retal	r12

80003de4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003de4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003de6:	30 19       	mov	r9,1
80003de8:	49 78       	lddpc	r8,80003e44 <local_start_PDC+0x60>
80003dea:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003dec:	fe 78 00 00 	mov	r8,-65536
80003df0:	30 7b       	mov	r11,7
80003df2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003df4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003df6:	49 59       	lddpc	r9,80003e48 <local_start_PDC+0x64>
80003df8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003dfc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003dfe:	30 3a       	mov	r10,3
80003e00:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e02:	30 1c       	mov	r12,1
80003e04:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e06:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e08:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e0a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e0c:	30 2c       	mov	r12,2
80003e0e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e10:	48 f9       	lddpc	r9,80003e4c <local_start_PDC+0x68>
80003e12:	e0 68 5a 5a 	mov	r8,23130
80003e16:	ea 18 ab cd 	orh	r8,0xabcd
80003e1a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e1c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e1e:	30 0e       	mov	lr,0
80003e20:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e22:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e24:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e26:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e28:	fe 78 00 40 	mov	r8,-65472
80003e2c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e2e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e30:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e34:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e36:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e38:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e3a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e3c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e3e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e40:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e42:	d8 02       	popm	pc
80003e44:	00 00       	add	r0,r0
80003e46:	40 b0       	lddsp	r0,sp[0x2c]
80003e48:	00 00       	add	r0,r0
80003e4a:	40 b8       	lddsp	r8,sp[0x2c]
80003e4c:	00 00       	add	r0,r0
80003e4e:	40 d8       	lddsp	r8,sp[0x34]

80003e50 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e50:	48 38       	lddpc	r8,80003e5c <register_rx_tx_func+0xc>
80003e52:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e54:	48 38       	lddpc	r8,80003e60 <register_rx_tx_func+0x10>
80003e56:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e58:	5e fc       	retal	r12
80003e5a:	00 00       	add	r0,r0
80003e5c:	00 00       	add	r0,r0
80003e5e:	0a e8       	st.h	--r5,r8
80003e60:	00 00       	add	r0,r0
80003e62:	0a ec       	st.h	--r5,r12

80003e64 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e64:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e66:	fe 78 10 00 	mov	r8,-61440
80003e6a:	30 29       	mov	r9,2
80003e6c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e70:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e74:	10 99       	mov	r9,r8
80003e76:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e7a:	e2 18 00 02 	andl	r8,0x2,COH
80003e7e:	cf c0       	breq	80003e76 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e80:	fe 79 10 00 	mov	r9,-61440
80003e84:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e88:	e2 18 00 02 	andl	r8,0x2,COH
80003e8c:	cf c1       	brne	80003e84 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e8e:	30 3a       	mov	r10,3
80003e90:	36 0b       	mov	r11,96
80003e92:	48 bc       	lddpc	r12,80003ebc <ssc_init+0x58>
80003e94:	f0 1f 00 0b 	mcall	80003ec0 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e98:	f0 1f 00 0b 	mcall	80003ec4 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e9c:	f0 1f 00 0b 	mcall	80003ec8 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ea0:	fe 79 00 00 	mov	r9,-65536
80003ea4:	30 18       	mov	r8,1
80003ea6:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ea8:	fe 7a 00 40 	mov	r10,-65472
80003eac:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003eae:	e0 6b 01 01 	mov	r11,257
80003eb2:	fe 7a 34 00 	mov	r10,-52224
80003eb6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003eb8:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
	
}/*End of ssc_init.*/
80003eba:	d8 02       	popm	pc
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	3d 10       	mov	r0,-47
80003ec0:	80 00       	ld.sh	r0,r0[0x0]
80003ec2:	47 c4       	lddsp	r4,sp[0x1f0]
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	3d a0       	mov	r0,-38
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	3d e4       	mov	r4,-34

80003ecc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ecc:	48 28       	lddpc	r8,80003ed4 <xcmp_register_app_list+0x8>
80003ece:	91 0c       	st.w	r8[0x0],r12
}
80003ed0:	5e fc       	retal	r12
80003ed2:	00 00       	add	r0,r0
80003ed4:	00 00       	add	r0,r0
80003ed6:	41 08       	lddsp	r8,sp[0x40]

80003ed8 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003ed8:	eb cd 40 80 	pushm	r7,lr
80003edc:	fa cd 01 00 	sub	sp,sp,256
80003ee0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003ee2:	16 98       	mov	r8,r11
80003ee4:	2f 08       	sub	r8,-16
80003ee6:	af a8       	sbr	r8,0xe
80003ee8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003eea:	3f f8       	mov	r8,-1
80003eec:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003eee:	30 b9       	mov	r9,11
80003ef0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003ef2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ef4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ef6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ef8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003efa:	f6 ca ff fe 	sub	r10,r11,-2
80003efe:	18 9b       	mov	r11,r12
80003f00:	fa cc ff f0 	sub	r12,sp,-16
80003f04:	f0 1f 00 05 	mcall	80003f18 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f08:	2f e7       	sub	r7,-2
80003f0a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f0c:	1a 9c       	mov	r12,sp
80003f0e:	f0 1f 00 04 	mcall	80003f1c <xcmp_tx+0x44>
}
80003f12:	2c 0d       	sub	sp,-256
80003f14:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	66 c4       	ld.w	r4,r3[0x30]
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	43 38       	lddsp	r8,sp[0xcc]

80003f20 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f20:	d4 01       	pushm	lr
80003f22:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f26:	fe 78 b4 00 	mov	r8,-19456
80003f2a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003f2c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003f30:	30 89       	mov	r9,8
80003f32:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003f34:	30 19       	mov	r9,1
80003f36:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003f38:	30 09       	mov	r9,0
80003f3a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003f3c:	30 5a       	mov	r10,5
80003f3e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003f40:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003f42:	30 7a       	mov	r10,7
80003f44:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f46:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f48:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f4a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003f4e:	30 9b       	mov	r11,9
80003f50:	fa cc ff fe 	sub	r12,sp,-2
80003f54:	f0 1f 00 02 	mcall	80003f5c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003f58:	2c dd       	sub	sp,-204
80003f5a:	d8 02       	popm	pc
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	3e d8       	mov	r8,-19

80003f60 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003f60:	d4 01       	pushm	lr
80003f62:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003f66:	fe 78 80 00 	mov	r8,-32768
80003f6a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003f6c:	30 38       	mov	r8,3
80003f6e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003f70:	30 1b       	mov	r11,1
80003f72:	fa cc ff fe 	sub	r12,sp,-2
80003f76:	f0 1f 00 03 	mcall	80003f80 <xcmp_opcode_not_supported+0x20>
}
80003f7a:	2c dd       	sub	sp,-204
80003f7c:	d8 02       	popm	pc
80003f7e:	00 00       	add	r0,r0
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3e d8       	mov	r8,-19

80003f84 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f84:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f86:	96 88       	ld.uh	r8,r11[0x0]
80003f88:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f8c:	e0 48 80 00 	cp.w	r8,32768
80003f90:	c0 f0       	breq	80003fae <xcmp_exec_func+0x2a>
80003f92:	e0 48 b0 00 	cp.w	r8,45056
80003f96:	c1 20       	breq	80003fba <xcmp_exec_func+0x36>
80003f98:	58 08       	cp.w	r8,0
80003f9a:	c1 51       	brne	80003fc4 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f9c:	78 08       	ld.w	r8,r12[0x0]
80003f9e:	58 08       	cp.w	r8,0
80003fa0:	c0 40       	breq	80003fa8 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003fa2:	16 9c       	mov	r12,r11
80003fa4:	5d 18       	icall	r8
80003fa6:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
80003fa8:	f0 1f 00 08 	mcall	80003fc8 <xcmp_exec_func+0x44>
80003fac:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003fae:	78 18       	ld.w	r8,r12[0x4]
80003fb0:	58 08       	cp.w	r8,0
80003fb2:	c0 90       	breq	80003fc4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003fb4:	16 9c       	mov	r12,r11
80003fb6:	5d 18       	icall	r8
80003fb8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003fba:	78 28       	ld.w	r8,r12[0x8]
80003fbc:	58 08       	cp.w	r8,0
80003fbe:	c0 30       	breq	80003fc4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003fc0:	16 9c       	mov	r12,r11
80003fc2:	5d 18       	icall	r8
80003fc4:	d8 02       	popm	pc
80003fc6:	00 00       	add	r0,r0
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	3f 60       	mov	r0,-10

80003fcc <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003fcc:	d4 01       	pushm	lr
80003fce:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003fd2:	e0 68 04 09 	mov	r8,1033
80003fd6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003fd8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003fdc:	30 19       	mov	r9,1
80003fde:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003fe0:	30 09       	mov	r9,0
80003fe2:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003fe4:	30 ca       	mov	r10,12
80003fe6:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003fe8:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003fea:	fb 69 00 08 	st.b	sp[8],r9
80003fee:	fa c8 ff f7 	sub	r8,sp,-9
80003ff2:	b0 89       	st.b	r8[0x0],r9
80003ff4:	fa c8 ff f6 	sub	r8,sp,-10
80003ff8:	b0 89       	st.b	r8[0x0],r9
80003ffa:	fa c8 ff f5 	sub	r8,sp,-11
80003ffe:	b0 89       	st.b	r8[0x0],r9
80004000:	fa c8 ff f4 	sub	r8,sp,-12
80004004:	b0 89       	st.b	r8[0x0],r9
80004006:	fa c8 ff f3 	sub	r8,sp,-13
8000400a:	b0 89       	st.b	r8[0x0],r9
8000400c:	fa c8 ff f2 	sub	r8,sp,-14
80004010:	b0 89       	st.b	r8[0x0],r9
80004012:	fa c8 ff f1 	sub	r8,sp,-15
80004016:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004018:	30 cb       	mov	r11,12
8000401a:	fa cc ff fe 	sub	r12,sp,-2
8000401e:	f0 1f 00 03 	mcall	80004028 <xcmp_IdleTestTone+0x5c>
}
80004022:	2c dd       	sub	sp,-204
80004024:	d8 02       	popm	pc
80004026:	00 00       	add	r0,r0
80004028:	80 00       	ld.sh	r0,r0[0x0]
8000402a:	3e d8       	mov	r8,-19

8000402c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000402c:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
8000402e:	f0 1f 00 0d 	mcall	80004060 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004032:	48 dc       	lddpc	r12,80004064 <xcmp_init+0x38>
80004034:	f0 1f 00 0d 	mcall	80004068 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004038:	30 4b       	mov	r11,4
8000403a:	31 4c       	mov	r12,20
8000403c:	f0 1f 00 0c 	mcall	8000406c <xcmp_init+0x40>
80004040:	48 c8       	lddpc	r8,80004070 <xcmp_init+0x44>
80004042:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004044:	30 09       	mov	r9,0
80004046:	1a d9       	st.w	--sp,r9
80004048:	1a d9       	st.w	--sp,r9
8000404a:	1a d9       	st.w	--sp,r9
8000404c:	30 38       	mov	r8,3
8000404e:	e0 6a 01 80 	mov	r10,384
80004052:	48 9b       	lddpc	r11,80004074 <xcmp_init+0x48>
80004054:	48 9c       	lddpc	r12,80004078 <xcmp_init+0x4c>
80004056:	f0 1f 00 0a 	mcall	8000407c <xcmp_init+0x50>
8000405a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
8000405c:	d8 02       	popm	pc
8000405e:	00 00       	add	r0,r0
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	44 1c       	lddsp	r12,sp[0x104]
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	41 7c       	lddsp	r12,sp[0x5c]
80004068:	80 00       	ld.sh	r0,r0[0x0]
8000406a:	41 c8       	lddsp	r8,sp[0x70]
8000406c:	80 00       	ld.sh	r0,r0[0x0]
8000406e:	52 bc       	stdsp	sp[0xac],r12
80004070:	00 00       	add	r0,r0
80004072:	0a fc       	st.b	--r5,r12
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	c5 e8       	rjmp	80004132 <xcmp_rx_process+0xb2>
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	40 80       	lddsp	r0,sp[0x20]
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	59 90       	cp.w	r0,25

80004080 <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004080:	d4 31       	pushm	r0-r7,lr
80004082:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004084:	4b 16       	lddpc	r6,80004148 <xcmp_rx_process+0xc8>
80004086:	30 05       	mov	r5,0
80004088:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000408a:	4b 13       	lddpc	r3,8000414c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000408c:	4b 12       	lddpc	r2,80004150 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000408e:	4b 21       	lddpc	r1,80004154 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004090:	4b 20       	lddpc	r0,80004158 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004092:	6c 0c       	ld.w	r12,r6[0x0]
80004094:	0a 99       	mov	r9,r5
80004096:	08 9a       	mov	r10,r4
80004098:	1a 9b       	mov	r11,sp
8000409a:	f0 1f 00 31 	mcall	8000415c <xcmp_rx_process+0xdc>
8000409e:	58 1c       	cp.w	r12,1
800040a0:	cf 91       	brne	80004092 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800040a2:	40 0b       	lddsp	r11,sp[0x0]
800040a4:	58 0b       	cp.w	r11,0
800040a6:	cf 60       	breq	80004092 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800040a8:	96 0a       	ld.sh	r10,r11[0x0]
800040aa:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800040ae:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800040b2:	59 c8       	cp.w	r8,28
800040b4:	c1 e0       	breq	800040f0 <xcmp_rx_process+0x70>
800040b6:	e0 89 00 07 	brgt	800040c4 <xcmp_rx_process+0x44>
800040ba:	58 e8       	cp.w	r8,14
800040bc:	c0 e0       	breq	800040d8 <xcmp_rx_process+0x58>
800040be:	58 f8       	cp.w	r8,15
800040c0:	c2 41       	brne	80004108 <xcmp_rx_process+0x88>
800040c2:	c0 f8       	rjmp	800040e0 <xcmp_rx_process+0x60>
800040c4:	e0 48 01 09 	cp.w	r8,265
800040c8:	c1 80       	breq	800040f8 <xcmp_rx_process+0x78>
800040ca:	e0 48 01 0a 	cp.w	r8,266
800040ce:	c1 90       	breq	80004100 <xcmp_rx_process+0x80>
800040d0:	e0 48 00 2c 	cp.w	r8,44
800040d4:	c1 a1       	brne	80004108 <xcmp_rx_process+0x88>
800040d6:	c0 98       	rjmp	800040e8 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800040d8:	4a 2c       	lddpc	r12,80004160 <xcmp_rx_process+0xe0>
800040da:	f0 1f 00 23 	mcall	80004164 <xcmp_rx_process+0xe4>
					break;
800040de:	c2 f8       	rjmp	8000413c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800040e0:	4a 2c       	lddpc	r12,80004168 <xcmp_rx_process+0xe8>
800040e2:	f0 1f 00 21 	mcall	80004164 <xcmp_rx_process+0xe4>
					break;
800040e6:	c2 b8       	rjmp	8000413c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800040e8:	4a 1c       	lddpc	r12,8000416c <xcmp_rx_process+0xec>
800040ea:	f0 1f 00 1f 	mcall	80004164 <xcmp_rx_process+0xe4>
					break;
800040ee:	c2 78       	rjmp	8000413c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040f0:	04 9c       	mov	r12,r2
800040f2:	f0 1f 00 1d 	mcall	80004164 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800040f6:	c2 38       	rjmp	8000413c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040f8:	02 9c       	mov	r12,r1
800040fa:	f0 1f 00 1b 	mcall	80004164 <xcmp_rx_process+0xe4>
					break;
800040fe:	c1 f8       	rjmp	8000413c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004100:	00 9c       	mov	r12,r0
80004102:	f0 1f 00 19 	mcall	80004164 <xcmp_rx_process+0xe4>
					break;
80004106:	c1 b8       	rjmp	8000413c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004108:	12 98       	mov	r8,r9
8000410a:	e2 18 04 00 	andl	r8,0x400,COH
8000410e:	c0 70       	breq	8000411c <xcmp_rx_process+0x9c>
80004110:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004114:	e0 48 00 68 	cp.w	r8,104
80004118:	e0 8a 00 08 	brle	80004128 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000411c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004120:	c0 e1       	brne	8000413c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004122:	f0 1f 00 14 	mcall	80004170 <xcmp_rx_process+0xf0>
80004126:	c0 b8       	rjmp	8000413c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004128:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000412c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004130:	49 19       	lddpc	r9,80004174 <xcmp_rx_process+0xf4>
80004132:	72 08       	ld.w	r8,r9[0x0]
80004134:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004138:	f0 1f 00 0b 	mcall	80004164 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000413c:	66 0c       	ld.w	r12,r3[0x0]
8000413e:	40 0b       	lddsp	r11,sp[0x0]
80004140:	f0 1f 00 0e 	mcall	80004178 <xcmp_rx_process+0xf8>
80004144:	ca 7b       	rjmp	80004092 <xcmp_rx_process+0x12>
80004146:	00 00       	add	r0,r0
80004148:	00 00       	add	r0,r0
8000414a:	0a fc       	st.b	--r5,r12
8000414c:	00 00       	add	r0,r0
8000414e:	0a b0       	st.h	r5++,r0
80004150:	00 00       	add	r0,r0
80004152:	0b 0c       	ld.w	r12,r5++
80004154:	00 00       	add	r0,r0
80004156:	0b 00       	ld.w	r0,r5++
80004158:	00 00       	add	r0,r0
8000415a:	0b 18       	ld.sh	r8,r5++
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	4f b0       	lddpc	r0,80004348 <xnl_tx+0x10>
80004160:	00 00       	add	r0,r0
80004162:	0b 30       	ld.ub	r0,r5++
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	3f 84       	mov	r4,-8
80004168:	00 00       	add	r0,r0
8000416a:	0a f0       	st.b	--r5,r0
8000416c:	00 00       	add	r0,r0
8000416e:	0b 24       	ld.uh	r4,r5++
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	3f 60       	mov	r0,-10
80004174:	00 00       	add	r0,r0
80004176:	41 08       	lddsp	r8,sp[0x40]
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	2a 08       	sub	r8,-96

8000417c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000417c:	eb cd 40 90 	pushm	r4,r7,lr
80004180:	20 1d       	sub	sp,4
80004182:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004186:	48 c8       	lddpc	r8,800041b4 <xcmp_rx+0x38>
80004188:	70 0c       	ld.w	r12,r8[0x0]
8000418a:	f0 1f 00 0c 	mcall	800041b8 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000418e:	c1 00       	breq	800041ae <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004190:	fa c7 ff fc 	sub	r7,sp,-4
80004194:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004196:	e0 6a 00 ca 	mov	r10,202
8000419a:	08 9b       	mov	r11,r4
8000419c:	f0 1f 00 08 	mcall	800041bc <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800041a0:	48 88       	lddpc	r8,800041c0 <xcmp_rx+0x44>
800041a2:	70 0c       	ld.w	r12,r8[0x0]
800041a4:	30 09       	mov	r9,0
800041a6:	12 9a       	mov	r10,r9
800041a8:	1a 9b       	mov	r11,sp
800041aa:	f0 1f 00 07 	mcall	800041c4 <xcmp_rx+0x48>
	}	
}
800041ae:	2f fd       	sub	sp,-4
800041b0:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800041b4:	00 00       	add	r0,r0
800041b6:	0a b0       	st.h	r5++,r0
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	2f 74       	sub	r4,-9
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	66 c4       	ld.w	r4,r3[0x30]
800041c0:	00 00       	add	r0,r0
800041c2:	0a fc       	st.b	--r5,r12
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	51 bc       	stdsp	sp[0x6c],r12

800041c8 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800041c8:	48 28       	lddpc	r8,800041d0 <xnl_register_xcmp_func+0x8>
800041ca:	91 0c       	st.w	r8[0x0],r12
}
800041cc:	5e fc       	retal	r12
800041ce:	00 00       	add	r0,r0
800041d0:	00 00       	add	r0,r0
800041d2:	0b 60       	ld.uh	r0,--r5

800041d4 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800041d4:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800041d6:	48 88       	lddpc	r8,800041f4 <xnl_get_msg_ack_func+0x20>
800041d8:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800041da:	98 49       	ld.sh	r9,r12[0x8]
800041dc:	f0 09 19 00 	cp.h	r9,r8
800041e0:	c0 81       	brne	800041f0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800041e2:	48 68       	lddpc	r8,800041f8 <xnl_get_msg_ack_func+0x24>
800041e4:	70 0c       	ld.w	r12,r8[0x0]
800041e6:	30 09       	mov	r9,0
800041e8:	12 9a       	mov	r10,r9
800041ea:	12 9b       	mov	r11,r9
800041ec:	f0 1f 00 04 	mcall	800041fc <xnl_get_msg_ack_func+0x28>
800041f0:	d8 02       	popm	pc
800041f2:	00 00       	add	r0,r0
800041f4:	00 00       	add	r0,r0
800041f6:	0b 42       	ld.w	r2,--r5
800041f8:	00 00       	add	r0,r0
800041fa:	0b 3c       	ld.ub	r12,r5++
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	51 bc       	stdsp	sp[0x6c],r12

80004200 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004200:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004202:	4a 86       	lddpc	r6,800042a0 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004204:	4a 82       	lddpc	r2,800042a4 <xnl_tx_process+0xa4>
80004206:	4a 94       	lddpc	r4,800042a8 <xnl_tx_process+0xa8>
80004208:	30 07       	mov	r7,0
8000420a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000420c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000420e:	4a 85       	lddpc	r5,800042ac <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004210:	4a 83       	lddpc	r3,800042b0 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004212:	6c 08       	ld.w	r8,r6[0x0]
80004214:	58 08       	cp.w	r8,0
80004216:	c0 40       	breq	8000421e <xnl_tx_process+0x1e>
80004218:	58 18       	cp.w	r8,1
8000421a:	cf d1       	brne	80004214 <xnl_tx_process+0x14>
8000421c:	c2 08       	rjmp	8000425c <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000421e:	64 0c       	ld.w	r12,r2[0x0]
80004220:	0e 99       	mov	r9,r7
80004222:	02 9a       	mov	r10,r1
80004224:	08 9b       	mov	r11,r4
80004226:	f0 1f 00 24 	mcall	800042b4 <xnl_tx_process+0xb4>
8000422a:	58 1c       	cp.w	r12,1
8000422c:	cf 31       	brne	80004212 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000422e:	68 0c       	ld.w	r12,r4[0x0]
80004230:	58 0c       	cp.w	r12,0
80004232:	cf 00       	breq	80004212 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004234:	98 28       	ld.sh	r8,r12[0x4]
80004236:	e0 08 19 00 	cp.h	r8,r0
8000423a:	c0 41       	brne	80004242 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
8000423c:	f0 1f 00 1f 	mcall	800042b8 <xnl_tx_process+0xb8>
						break;
80004240:	ce 9b       	rjmp	80004212 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004242:	f0 1f 00 1f 	mcall	800042bc <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004246:	30 18       	mov	r8,1
80004248:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000424a:	66 0c       	ld.w	r12,r3[0x0]
8000424c:	0e 99       	mov	r9,r7
8000424e:	0e 9a       	mov	r10,r7
80004250:	0e 9b       	mov	r11,r7
80004252:	f0 1f 00 19 	mcall	800042b4 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
80004256:	30 18       	mov	r8,1
80004258:	8d 08       	st.w	r6[0x0],r8
8000425a:	cd cb       	rjmp	80004212 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
8000425c:	66 0c       	ld.w	r12,r3[0x0]
8000425e:	0e 99       	mov	r9,r7
80004260:	36 4a       	mov	r10,100
80004262:	0e 9b       	mov	r11,r7
80004264:	f0 1f 00 14 	mcall	800042b4 <xnl_tx_process+0xb4>
80004268:	58 1c       	cp.w	r12,1
8000426a:	c0 81       	brne	8000427a <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
8000426c:	49 58       	lddpc	r8,800042c0 <xnl_tx_process+0xc0>
8000426e:	70 0c       	ld.w	r12,r8[0x0]
80004270:	68 0b       	ld.w	r11,r4[0x0]
80004272:	f0 1f 00 15 	mcall	800042c4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004276:	8d 07       	st.w	r6[0x0],r7
80004278:	cc db       	rjmp	80004212 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000427a:	6a 08       	ld.w	r8,r5[0x0]
8000427c:	58 38       	cp.w	r8,3
8000427e:	e0 89 00 09 	brgt	80004290 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004282:	68 0c       	ld.w	r12,r4[0x0]
80004284:	f0 1f 00 0e 	mcall	800042bc <xnl_tx_process+0xbc>
						xnl_send_times++;
80004288:	6a 08       	ld.w	r8,r5[0x0]
8000428a:	2f f8       	sub	r8,-1
8000428c:	8b 08       	st.w	r5[0x0],r8
8000428e:	cc 2b       	rjmp	80004212 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004290:	48 c8       	lddpc	r8,800042c0 <xnl_tx_process+0xc0>
80004292:	70 0c       	ld.w	r12,r8[0x0]
80004294:	68 0b       	ld.w	r11,r4[0x0]
80004296:	f0 1f 00 0c 	mcall	800042c4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000429a:	8d 07       	st.w	r6[0x0],r7
8000429c:	cb bb       	rjmp	80004212 <xnl_tx_process+0x12>
8000429e:	00 00       	add	r0,r0
800042a0:	00 00       	add	r0,r0
800042a2:	0b 5c       	ld.sh	r12,--r5
800042a4:	00 00       	add	r0,r0
800042a6:	0b 4c       	ld.w	r12,--r5
800042a8:	00 00       	add	r0,r0
800042aa:	0b 50       	ld.sh	r0,--r5
800042ac:	00 00       	add	r0,r0
800042ae:	0b 58       	ld.sh	r8,--r5
800042b0:	00 00       	add	r0,r0
800042b2:	0b 3c       	ld.ub	r12,r5++
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	4f b0       	lddpc	r0,800044a0 <xnl_init+0x84>
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	4e 40       	lddpc	r0,80004448 <xnl_init+0x2c>
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	2a 28       	sub	r8,-94
800042c0:	00 00       	add	r0,r0
800042c2:	0a b0       	st.h	r5++,r0
800042c4:	80 00       	ld.sh	r0,r0[0x0]
800042c6:	2a 08       	sub	r8,-96

800042c8 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800042c8:	eb cd 40 fe 	pushm	r1-r7,lr
800042cc:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000	
	xLastWakeTime = xTaskGetTickCount();
800042ce:	f0 1f 00 14 	mcall	8000431c <xnl_rx_process+0x54>
800042d2:	49 48       	lddpc	r8,80004320 <xnl_rx_process+0x58>
800042d4:	91 0c       	st.w	r8[0x0],r12
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042d6:	49 46       	lddpc	r6,80004324 <xnl_rx_process+0x5c>
800042d8:	30 05       	mov	r5,0
800042da:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042dc:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042de:	49 31       	lddpc	r1,80004328 <xnl_rx_process+0x60>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042e0:	49 32       	lddpc	r2,8000432c <xnl_rx_process+0x64>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042e2:	6c 0c       	ld.w	r12,r6[0x0]
800042e4:	0a 99       	mov	r9,r5
800042e6:	08 9a       	mov	r10,r4
800042e8:	1a 9b       	mov	r11,sp
800042ea:	f0 1f 00 12 	mcall	80004330 <xnl_rx_process+0x68>
800042ee:	58 1c       	cp.w	r12,1
800042f0:	cf 91       	brne	800042e2 <xnl_rx_process+0x1a>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042f2:	40 0c       	lddsp	r12,sp[0x0]
800042f4:	58 0c       	cp.w	r12,0
800042f6:	cf 60       	breq	800042e2 <xnl_rx_process+0x1a>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042f8:	98 28       	ld.sh	r8,r12[0x4]
800042fa:	e6 08 19 00 	cp.h	r8,r3
800042fe:	e0 8b 00 0a 	brhi	80004312 <xnl_rx_process+0x4a>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004302:	5c 78       	castu.h	r8
80004304:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004308:	58 09       	cp.w	r9,0
8000430a:	c0 40       	breq	80004312 <xnl_rx_process+0x4a>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000430c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004310:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004312:	62 0c       	ld.w	r12,r1[0x0]
80004314:	40 0b       	lddsp	r11,sp[0x0]
80004316:	f0 1f 00 08 	mcall	80004334 <xnl_rx_process+0x6c>
8000431a:	ce 4b       	rjmp	800042e2 <xnl_rx_process+0x1a>
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	56 c8       	stdsp	sp[0x1b0],r8
80004320:	00 00       	add	r0,r0
80004322:	0b 54       	ld.sh	r4,--r5
80004324:	00 00       	add	r0,r0
80004326:	0a b4       	st.h	r5++,r4
80004328:	00 00       	add	r0,r0
8000432a:	0a b0       	st.h	r5++,r0
8000432c:	00 00       	add	r0,r0
8000432e:	04 f4       	st.b	--r2,r4
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	4f b0       	lddpc	r0,8000451c <xnl_data_msg_func+0x2c>
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	2a 08       	sub	r8,-96

80004338 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004338:	eb cd 40 c0 	pushm	r6-r7,lr
8000433c:	20 1d       	sub	sp,4
8000433e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004340:	98 39       	ld.sh	r9,r12[0x6]
80004342:	3f f8       	mov	r8,-1
80004344:	f0 09 19 00 	cp.h	r9,r8
80004348:	c0 a1       	brne	8000435c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000434a:	4a e9       	lddpc	r9,80004400 <xnl_tx+0xc8>
8000434c:	13 88       	ld.ub	r8,r9[0x0]
8000434e:	2f f8       	sub	r8,-1
80004350:	5c 58       	castu.b	r8
80004352:	b2 88       	st.b	r9[0x0],r8
80004354:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004358:	a9 a8       	sbr	r8,0x8
8000435a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000435c:	8c 49       	ld.sh	r9,r6[0x8]
8000435e:	3f f8       	mov	r8,-1
80004360:	f0 09 19 00 	cp.h	r9,r8
80004364:	c0 41       	brne	8000436c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004366:	4a 88       	lddpc	r8,80004404 <xnl_tx+0xcc>
80004368:	90 18       	ld.sh	r8,r8[0x2]
8000436a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000436c:	8c 59       	ld.sh	r9,r6[0xa]
8000436e:	3f f8       	mov	r8,-1
80004370:	f0 09 19 00 	cp.h	r9,r8
80004374:	c0 41       	brne	8000437c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004376:	4a 48       	lddpc	r8,80004404 <xnl_tx+0xcc>
80004378:	90 28       	ld.sh	r8,r8[0x4]
8000437a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000437c:	8c 69       	ld.sh	r9,r6[0xc]
8000437e:	3f f8       	mov	r8,-1
80004380:	f0 09 19 00 	cp.h	r9,r8
80004384:	c0 e1       	brne	800043a0 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004386:	4a 08       	lddpc	r8,80004404 <xnl_tx+0xcc>
80004388:	90 49       	ld.sh	r9,r8[0x8]
8000438a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000438c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000438e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004390:	90 49       	ld.sh	r9,r8[0x8]
80004392:	e0 19 ff 00 	andl	r9,0xff00
80004396:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000439a:	f3 e8 10 08 	or	r8,r9,r8
8000439e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800043a0:	0d 98       	ld.ub	r8,r6[0x1]
800043a2:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800043a4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800043a8:	10 0c       	add	r12,r8
800043aa:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043ac:	58 0c       	cp.w	r12,0
800043ae:	e0 89 00 04 	brgt	800043b6 <xnl_tx+0x7e>
800043b2:	30 09       	mov	r9,0
800043b4:	c0 d8       	rjmp	800043ce <xnl_tx+0x96>
800043b6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800043ba:	2f ec       	sub	r12,-2
800043bc:	30 09       	mov	r9,0
800043be:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800043c0:	15 1b       	ld.sh	r11,r10++
800043c2:	f6 09 00 09 	add	r9,r11,r9
800043c6:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043c8:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043ca:	18 38       	cp.w	r8,r12
800043cc:	cf a1       	brne	800043c0 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043ce:	5c 39       	neg	r9
800043d0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043d2:	48 e8       	lddpc	r8,80004408 <xnl_tx+0xd0>
800043d4:	70 0c       	ld.w	r12,r8[0x0]
800043d6:	f0 1f 00 0e 	mcall	8000440c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043da:	c1 00       	breq	800043fa <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043dc:	fa c7 ff fc 	sub	r7,sp,-4
800043e0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043e2:	e0 6a 01 00 	mov	r10,256
800043e6:	0c 9b       	mov	r11,r6
800043e8:	f0 1f 00 0a 	mcall	80004410 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043ec:	48 a8       	lddpc	r8,80004414 <xnl_tx+0xdc>
800043ee:	70 0c       	ld.w	r12,r8[0x0]
800043f0:	30 09       	mov	r9,0
800043f2:	12 9a       	mov	r10,r9
800043f4:	1a 9b       	mov	r11,sp
800043f6:	f0 1f 00 09 	mcall	80004418 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043fa:	2f fd       	sub	sp,-4
800043fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004400:	00 00       	add	r0,r0
80004402:	0b 40       	ld.w	r0,--r5
80004404:	00 00       	add	r0,r0
80004406:	0b 42       	ld.w	r2,--r5
80004408:	00 00       	add	r0,r0
8000440a:	0a b0       	st.h	r5++,r0
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	2f 74       	sub	r4,-9
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	66 c4       	ld.w	r4,r3[0x30]
80004414:	00 00       	add	r0,r0
80004416:	0b 4c       	ld.w	r12,--r5
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	51 bc       	stdsp	sp[0x6c],r12

8000441c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
8000441c:	eb cd 40 80 	pushm	r7,lr
80004420:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80004424:	f0 1f 00 27 	mcall	800044c0 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80004428:	30 09       	mov	r9,0
8000442a:	4a 78       	lddpc	r8,800044c4 <xnl_init+0xa8>
8000442c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000442e:	30 0b       	mov	r11,0
80004430:	30 1c       	mov	r12,1
80004432:	f0 1f 00 26 	mcall	800044c8 <xnl_init+0xac>
80004436:	4a 68       	lddpc	r8,800044cc <xnl_init+0xb0>
80004438:	91 0c       	st.w	r8[0x0],r12
8000443a:	70 08       	ld.w	r8,r8[0x0]
8000443c:	58 08       	cp.w	r8,0
8000443e:	c0 80       	breq	8000444e <xnl_init+0x32>
80004440:	4a 38       	lddpc	r8,800044cc <xnl_init+0xb0>
80004442:	70 0c       	ld.w	r12,r8[0x0]
80004444:	30 09       	mov	r9,0
80004446:	12 9a       	mov	r10,r9
80004448:	12 9b       	mov	r11,r9
8000444a:	f0 1f 00 22 	mcall	800044d0 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000444e:	30 4b       	mov	r11,4
80004450:	31 4c       	mov	r12,20
80004452:	f0 1f 00 1e 	mcall	800044c8 <xnl_init+0xac>
80004456:	4a 08       	lddpc	r8,800044d4 <xnl_init+0xb8>
80004458:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000445a:	30 07       	mov	r7,0
8000445c:	1a d7       	st.w	--sp,r7
8000445e:	1a d7       	st.w	--sp,r7
80004460:	1a d7       	st.w	--sp,r7
80004462:	30 38       	mov	r8,3
80004464:	0e 99       	mov	r9,r7
80004466:	e0 6a 02 00 	mov	r10,512
8000446a:	49 cb       	lddpc	r11,800044d8 <xnl_init+0xbc>
8000446c:	49 cc       	lddpc	r12,800044dc <xnl_init+0xc0>
8000446e:	f0 1f 00 1d 	mcall	800044e0 <xnl_init+0xc4>
	//,1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004472:	1a d7       	st.w	--sp,r7
80004474:	1a d7       	st.w	--sp,r7
80004476:	1a d7       	st.w	--sp,r7
80004478:	30 38       	mov	r8,3
8000447a:	0e 99       	mov	r9,r7
8000447c:	e0 6a 03 20 	mov	r10,800
80004480:	49 9b       	lddpc	r11,800044e4 <xnl_init+0xc8>
80004482:	49 ac       	lddpc	r12,800044e8 <xnl_init+0xcc>
80004484:	f0 1f 00 17 	mcall	800044e0 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004488:	e0 68 40 0e 	mov	r8,16398
8000448c:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004490:	3f f8       	mov	r8,-1
80004492:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004496:	30 38       	mov	r8,3
80004498:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000449c:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800044a0:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800044a4:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800044a8:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800044ac:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044b0:	fa cc ff e8 	sub	r12,sp,-24
800044b4:	f0 1f 00 0e 	mcall	800044ec <xnl_init+0xd0>
800044b8:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800044ba:	2c 0d       	sub	sp,-256
800044bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	2f 9c       	sub	r12,-7
800044c4:	00 00       	add	r0,r0
800044c6:	0b 42       	ld.w	r2,--r5
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	52 bc       	stdsp	sp[0xac],r12
800044cc:	00 00       	add	r0,r0
800044ce:	0b 3c       	ld.ub	r12,r5++
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	51 bc       	stdsp	sp[0x6c],r12
800044d4:	00 00       	add	r0,r0
800044d6:	0b 4c       	ld.w	r12,--r5
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	c5 f0       	breq	80004598 <xnl_device_auth_reply_func+0x48>
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	42 c8       	lddsp	r8,sp[0xb0]
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	59 90       	cp.w	r0,25
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	be 00       	st.h	pc[0x0],r0
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	42 00       	lddsp	r0,sp[0x80]
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	43 38       	lddsp	r8,sp[0xcc]

800044f0 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044f0:	eb cd 40 80 	pushm	r7,lr
800044f4:	fa cd 01 00 	sub	sp,sp,256
800044f8:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044fa:	e0 68 40 0e 	mov	r8,16398
800044fe:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004500:	3f f8       	mov	r8,-1
80004502:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004504:	30 c8       	mov	r8,12
80004506:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004508:	98 38       	ld.sh	r8,r12[0x6]
8000450a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
8000450c:	98 58       	ld.sh	r8,r12[0xa]
8000450e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004510:	98 48       	ld.sh	r8,r12[0x8]
80004512:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004514:	98 68       	ld.sh	r8,r12[0xc]
80004516:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004518:	30 08       	mov	r8,0
8000451a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000451c:	1a 9c       	mov	r12,sp
8000451e:	f0 1f 00 0a 	mcall	80004544 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004522:	fa cd 00 cc 	sub	sp,sp,204
80004526:	e0 6a 00 ca 	mov	r10,202
8000452a:	ee cb ff f0 	sub	r11,r7,-16
8000452e:	1a 9c       	mov	r12,sp
80004530:	f0 1f 00 06 	mcall	80004548 <xnl_data_msg_func+0x58>
80004534:	48 68       	lddpc	r8,8000454c <xnl_data_msg_func+0x5c>
80004536:	70 08       	ld.w	r8,r8[0x0]
80004538:	5d 18       	icall	r8
8000453a:	fa cd ff 34 	sub	sp,sp,-204
}
8000453e:	2c 0d       	sub	sp,-256
80004540:	e3 cd 80 80 	ldm	sp++,r7,pc
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	43 38       	lddsp	r8,sp[0xcc]
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	66 c4       	ld.w	r4,r3[0x30]
8000454c:	00 00       	add	r0,r0
8000454e:	0b 60       	ld.uh	r0,--r5

80004550 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004550:	d4 21       	pushm	r4-r7,lr
80004552:	fa cd 01 00 	sub	sp,sp,256
80004556:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004558:	4c 28       	lddpc	r8,80004660 <xnl_device_auth_reply_func+0x110>
8000455a:	11 88       	ld.ub	r8,r8[0x0]
8000455c:	58 08       	cp.w	r8,0
8000455e:	e0 81 00 7f 	brne	8000465c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004562:	4c 18       	lddpc	r8,80004664 <xnl_device_auth_reply_func+0x114>
80004564:	70 0c       	ld.w	r12,r8[0x0]
80004566:	30 09       	mov	r9,0
80004568:	12 9a       	mov	r10,r9
8000456a:	12 9b       	mov	r11,r9
8000456c:	f0 1f 00 3f 	mcall	80004668 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004570:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004574:	4b b8       	lddpc	r8,80004660 <xnl_device_auth_reply_func+0x110>
80004576:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004578:	ef 39 00 12 	ld.ub	r9,r7[18]
8000457c:	ef 38 00 13 	ld.ub	r8,r7[19]
80004580:	b1 68       	lsl	r8,0x10
80004582:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004586:	ef 38 00 15 	ld.ub	r8,r7[21]
8000458a:	f3 e8 10 08 	or	r8,r9,r8
8000458e:	ef 39 00 14 	ld.ub	r9,r7[20]
80004592:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004596:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000459a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000459e:	b1 68       	lsl	r8,0x10
800045a0:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800045a4:	ef 38 00 19 	ld.ub	r8,r7[25]
800045a8:	f5 e8 10 08 	or	r8,r10,r8
800045ac:	ef 3a 00 18 	ld.ub	r10,r7[24]
800045b0:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800045b4:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045b6:	e0 64 79 b9 	mov	r4,31161
800045ba:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045be:	e0 65 1c 1d 	mov	r5,7197
800045c2:	ea 15 c3 38 	orh	r5,0xc338
800045c6:	e0 66 63 23 	mov	r6,25379
800045ca:	ea 16 1c 8b 	orh	r6,0x1c8b
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045ce:	e0 6e fc a2 	mov	lr,64674
800045d2:	ea 1e 45 b0 	orh	lr,0x45b0
800045d6:	e0 67 75 d3 	mov	r7,30163
800045da:	ea 17 c4 ca 	orh	r7,0xc4ca
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045de:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045e0:	f4 08 00 0c 	add	r12,r10,r8
800045e4:	f0 0b 15 04 	lsl	r11,r8,0x4
800045e8:	0a 0b       	add	r11,r5
800045ea:	f9 eb 20 0b 	eor	r11,r12,r11
800045ee:	f0 0c 16 05 	lsr	r12,r8,0x5
800045f2:	0c 0c       	add	r12,r6
800045f4:	18 5b       	eor	r11,r12
800045f6:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045f8:	f2 0c 15 04 	lsl	r12,r9,0x4
800045fc:	1c 0c       	add	r12,lr
800045fe:	f2 0b 16 05 	lsr	r11,r9,0x5
80004602:	0e 0b       	add	r11,r7
80004604:	f9 eb 20 0b 	eor	r11,r12,r11
80004608:	f2 0a 00 0c 	add	r12,r9,r10
8000460c:	18 5b       	eor	r11,r12
8000460e:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004610:	e0 6b 37 20 	mov	r11,14112
80004614:	ea 1b c6 ef 	orh	r11,0xc6ef
80004618:	16 3a       	cp.w	r10,r11
8000461a:	ce 21       	brne	800045de <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000461c:	e0 6a 40 1a 	mov	r10,16410
80004620:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004622:	3f fa       	mov	r10,-1
80004624:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004626:	30 6b       	mov	r11,6
80004628:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000462a:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000462c:	48 db       	lddpc	r11,80004660 <xnl_device_auth_reply_func+0x110>
8000462e:	96 1c       	ld.sh	r12,r11[0x2]
80004630:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004632:	96 2b       	ld.sh	r11,r11[0x4]
80004634:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004636:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004638:	30 ca       	mov	r10,12
8000463a:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000463c:	30 0a       	mov	r10,0
8000463e:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004642:	30 7a       	mov	r10,7
80004644:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004648:	30 2a       	mov	r10,2
8000464a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000464e:	fa ca ff ec 	sub	r10,sp,-20
80004652:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004654:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004656:	1a 9c       	mov	r12,sp
80004658:	f0 1f 00 05 	mcall	8000466c <xnl_device_auth_reply_func+0x11c>
	//log("--2\r\n");
}
8000465c:	2c 0d       	sub	sp,-256
8000465e:	d8 22       	popm	r4-r7,pc
80004660:	00 00       	add	r0,r0
80004662:	0b 42       	ld.w	r2,--r5
80004664:	00 00       	add	r0,r0
80004666:	0b 3c       	ld.ub	r12,r5++
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	51 bc       	stdsp	sp[0x6c],r12
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	43 38       	lddsp	r8,sp[0xcc]

80004670 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004670:	eb cd 40 80 	pushm	r7,lr
80004674:	fa cd 01 00 	sub	sp,sp,256
80004678:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000467a:	49 38       	lddpc	r8,800046c4 <xnl_master_status_brdcst_func+0x54>
8000467c:	11 88       	ld.ub	r8,r8[0x0]
8000467e:	58 08       	cp.w	r8,0
80004680:	c1 f1       	brne	800046be <xnl_master_status_brdcst_func+0x4e>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004682:	49 28       	lddpc	r8,800046c8 <xnl_master_status_brdcst_func+0x58>
80004684:	70 0c       	ld.w	r12,r8[0x0]
80004686:	30 09       	mov	r9,0
80004688:	12 9a       	mov	r10,r9
8000468a:	12 9b       	mov	r11,r9
8000468c:	f0 1f 00 10 	mcall	800046cc <xnl_master_status_brdcst_func+0x5c>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004690:	8e 58       	ld.sh	r8,r7[0xa]
80004692:	48 d9       	lddpc	r9,800046c4 <xnl_master_status_brdcst_func+0x54>
80004694:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004696:	e0 68 40 0e 	mov	r8,16398
8000469a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000469c:	3f f8       	mov	r8,-1
8000469e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800046a0:	30 4a       	mov	r10,4
800046a2:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046a4:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046a6:	92 19       	ld.sh	r9,r9[0x2]
800046a8:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800046aa:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046ac:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800046ae:	30 08       	mov	r8,0
800046b0:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800046b2:	1a 9c       	mov	r12,sp
800046b4:	f0 1f 00 07 	mcall	800046d0 <xnl_master_status_brdcst_func+0x60>
	log("--1--\r\n");
800046b8:	48 7c       	lddpc	r12,800046d4 <xnl_master_status_brdcst_func+0x64>
800046ba:	f0 1f 00 08 	mcall	800046d8 <xnl_master_status_brdcst_func+0x68>
}
800046be:	2c 0d       	sub	sp,-256
800046c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800046c4:	00 00       	add	r0,r0
800046c6:	0b 42       	ld.w	r2,--r5
800046c8:	00 00       	add	r0,r0
800046ca:	0b 3c       	ld.ub	r12,r5++
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	51 bc       	stdsp	sp[0x6c],r12
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	43 38       	lddsp	r8,sp[0xcc]
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	c5 f8       	rjmp	80004794 <local_start_timer+0xc>
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	5d 54       	*unknown*

800046dc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800046dc:	eb cd 40 80 	pushm	r7,lr
800046e0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046e2:	49 28       	lddpc	r8,80004728 <xnl_device_conn_reply_func+0x4c>
800046e4:	70 0c       	ld.w	r12,r8[0x0]
800046e6:	30 09       	mov	r9,0
800046e8:	12 9a       	mov	r10,r9
800046ea:	12 9b       	mov	r11,r9
800046ec:	f0 1f 00 10 	mcall	8000472c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046f0:	ef 18 00 10 	ld.uh	r8,r7[16]
800046f4:	10 99       	mov	r9,r8
800046f6:	e2 19 ff 00 	andl	r9,0xff00,COH
800046fa:	e0 49 01 00 	cp.w	r9,256
800046fe:	c0 60       	breq	8000470a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004700:	0e 9c       	mov	r12,r7
80004702:	f0 1f 00 0c 	mcall	80004730 <xnl_device_conn_reply_func+0x54>
80004706:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000470a:	a9 68       	lsl	r8,0x8
8000470c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004710:	48 98       	lddpc	r8,80004734 <xnl_device_conn_reply_func+0x58>
80004712:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004714:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004718:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000471a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000471e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004720:	30 19       	mov	r9,1
80004722:	b0 89       	st.b	r8[0x0],r9
80004724:	e3 cd 80 80 	ldm	sp++,r7,pc
80004728:	00 00       	add	r0,r0
8000472a:	0b 3c       	ld.ub	r12,r5++
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	51 bc       	stdsp	sp[0x6c],r12
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	46 70       	lddsp	r0,sp[0x19c]
80004734:	00 00       	add	r0,r0
80004736:	0b 42       	ld.w	r2,--r5

80004738 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004738:	fe 78 0c 00 	mov	r8,-62464
8000473c:	e0 69 03 07 	mov	r9,775
80004740:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004742:	30 49       	mov	r9,4
80004744:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004746:	71 59       	ld.w	r9,r8[0x54]
80004748:	e2 19 00 80 	andl	r9,0x80,COH
8000474c:	cf d0       	breq	80004746 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000474e:	fe 78 0c 00 	mov	r8,-62464
80004752:	30 59       	mov	r9,5
80004754:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004756:	e0 69 01 0d 	mov	r9,269
8000475a:	ea 19 10 07 	orh	r9,0x1007
8000475e:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004760:	71 59       	ld.w	r9,r8[0x54]
80004762:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004766:	cf d0       	breq	80004760 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004768:	fe 78 0c 00 	mov	r8,-62464
8000476c:	fc 19 00 80 	movh	r9,0x80
80004770:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004772:	34 0a       	mov	r10,64
80004774:	fe 69 14 00 	mov	r9,-125952
80004778:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000477a:	30 69       	mov	r9,6
8000477c:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000477e:	30 19       	mov	r9,1
80004780:	fe 68 10 00 	mov	r8,-126976
80004784:	91 19       	st.w	r8[0x4],r9
}
80004786:	5e fc       	retal	r12

80004788 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004788:	fe 78 10 00 	mov	r8,-61440
8000478c:	fc 19 00 10 	movh	r9,0x10
80004790:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004792:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004794:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004796:	30 39       	mov	r9,3
80004798:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
8000479c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800047a0:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800047a4:	fe 78 38 00 	mov	r8,-51200
800047a8:	30 49       	mov	r9,4
800047aa:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800047ae:	e0 69 91 0d 	mov	r9,37133
800047b2:	ea 19 00 52 	orh	r9,0x52
800047b6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800047b8:	32 09       	mov	r9,32
800047ba:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800047bc:	30 59       	mov	r9,5
800047be:	91 09       	st.w	r8[0x0],r9
}
800047c0:	5e fc       	retal	r12

800047c2 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800047c2:	c0 08       	rjmp	800047c2 <_unhandled_interrupt>

800047c4 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800047c4:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800047c8:	49 99       	lddpc	r9,8000482c <INTC_register_interrupt+0x68>
800047ca:	f2 08 00 39 	add	r9,r9,r8<<0x3
800047ce:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800047d2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800047d4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800047d8:	58 0a       	cp.w	r10,0
800047da:	c0 91       	brne	800047ec <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800047dc:	49 59       	lddpc	r9,80004830 <INTC_register_interrupt+0x6c>
800047de:	49 6a       	lddpc	r10,80004834 <INTC_register_interrupt+0x70>
800047e0:	12 1a       	sub	r10,r9
800047e2:	fe 79 08 00 	mov	r9,-63488
800047e6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800047ea:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800047ec:	58 1a       	cp.w	r10,1
800047ee:	c0 a1       	brne	80004802 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800047f0:	49 09       	lddpc	r9,80004830 <INTC_register_interrupt+0x6c>
800047f2:	49 2a       	lddpc	r10,80004838 <INTC_register_interrupt+0x74>
800047f4:	12 1a       	sub	r10,r9
800047f6:	bf aa       	sbr	r10,0x1e
800047f8:	fe 79 08 00 	mov	r9,-63488
800047fc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004800:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004802:	58 2a       	cp.w	r10,2
80004804:	c0 a1       	brne	80004818 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004806:	48 b9       	lddpc	r9,80004830 <INTC_register_interrupt+0x6c>
80004808:	48 da       	lddpc	r10,8000483c <INTC_register_interrupt+0x78>
8000480a:	12 1a       	sub	r10,r9
8000480c:	bf ba       	sbr	r10,0x1f
8000480e:	fe 79 08 00 	mov	r9,-63488
80004812:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004816:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004818:	48 69       	lddpc	r9,80004830 <INTC_register_interrupt+0x6c>
8000481a:	48 aa       	lddpc	r10,80004840 <INTC_register_interrupt+0x7c>
8000481c:	12 1a       	sub	r10,r9
8000481e:	ea 1a c0 00 	orh	r10,0xc000
80004822:	fe 79 08 00 	mov	r9,-63488
80004826:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000482a:	5e fc       	retal	r12
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	c6 00       	breq	800048ee <usart_set_async_baudrate+0x1e>
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	bc 00       	st.h	lr[0x0],r0
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	bd 04       	ld.d	r4,lr
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	bd 12       	ld.d	r2,--lr
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	bd 20       	st.d	lr++,r0
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	bd 2e       	st.d	lr++,lr

80004844 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004844:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004846:	49 18       	lddpc	r8,80004888 <INTC_init_interrupts+0x44>
80004848:	e3 b8 00 01 	mtsr	0x4,r8
8000484c:	49 0e       	lddpc	lr,8000488c <INTC_init_interrupts+0x48>
8000484e:	30 07       	mov	r7,0
80004850:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004852:	49 0c       	lddpc	r12,80004890 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004854:	49 05       	lddpc	r5,80004894 <INTC_init_interrupts+0x50>
80004856:	10 15       	sub	r5,r8
80004858:	fe 76 08 00 	mov	r6,-63488
8000485c:	c1 08       	rjmp	8000487c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000485e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004860:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004862:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004864:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004868:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000486a:	10 3a       	cp.w	r10,r8
8000486c:	fe 9b ff fc 	brhi	80004864 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004870:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004874:	2f f7       	sub	r7,-1
80004876:	2f 8e       	sub	lr,-8
80004878:	59 37       	cp.w	r7,19
8000487a:	c0 50       	breq	80004884 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000487c:	7c 08       	ld.w	r8,lr[0x0]
8000487e:	58 08       	cp.w	r8,0
80004880:	ce f1       	brne	8000485e <INTC_init_interrupts+0x1a>
80004882:	cf 7b       	rjmp	80004870 <INTC_init_interrupts+0x2c>
80004884:	d8 22       	popm	r4-r7,pc
80004886:	00 00       	add	r0,r0
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	bc 00       	st.h	lr[0x0],r0
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	c6 00       	breq	8000494e <usart_putchar+0xe>
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	47 c2       	lddsp	r2,sp[0x1f0]
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	bd 04       	ld.d	r4,lr

80004898 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004898:	fe 78 08 00 	mov	r8,-63488
8000489c:	e0 69 00 83 	mov	r9,131
800048a0:	f2 0c 01 0c 	sub	r12,r9,r12
800048a4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800048a8:	f2 ca ff c0 	sub	r10,r9,-64
800048ac:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800048b0:	58 08       	cp.w	r8,0
800048b2:	c0 21       	brne	800048b6 <_get_interrupt_handler+0x1e>
800048b4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800048b6:	f0 08 12 00 	clz	r8,r8
800048ba:	48 5a       	lddpc	r10,800048cc <_get_interrupt_handler+0x34>
800048bc:	f4 09 00 39 	add	r9,r10,r9<<0x3
800048c0:	f0 08 11 1f 	rsub	r8,r8,31
800048c4:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800048c6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800048ca:	5e fc       	retal	r12
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	c6 00       	breq	8000498e <usart_read_char+0x22>

800048d0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800048d0:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800048d2:	f6 08 15 04 	lsl	r8,r11,0x4
800048d6:	14 38       	cp.w	r8,r10
800048d8:	f9 b8 08 10 	movls	r8,16
800048dc:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800048e0:	f0 0b 02 4b 	mul	r11,r8,r11
800048e4:	f6 09 16 01 	lsr	r9,r11,0x1
800048e8:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800048ec:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800048f0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800048f4:	f2 cb 00 01 	sub	r11,r9,1
800048f8:	e0 4b ff fe 	cp.w	r11,65534
800048fc:	e0 88 00 03 	brls	80004902 <usart_set_async_baudrate+0x32>
80004900:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004902:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004904:	e8 6e 00 00 	mov	lr,524288
80004908:	59 08       	cp.w	r8,16
8000490a:	fc 08 17 10 	movne	r8,lr
8000490e:	f9 b8 00 00 	moveq	r8,0
80004912:	e4 1b ff f7 	andh	r11,0xfff7
80004916:	e0 1b fe cf 	andl	r11,0xfecf
8000491a:	16 48       	or	r8,r11
8000491c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000491e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004922:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004926:	99 89       	st.w	r12[0x20],r9
80004928:	d8 0a       	popm	pc,r12=0

8000492a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000492a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000492c:	e2 18 00 02 	andl	r8,0x2,COH
80004930:	c0 31       	brne	80004936 <usart_write_char+0xc>
80004932:	30 2c       	mov	r12,2
80004934:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004936:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000493a:	99 7b       	st.w	r12[0x1c],r11
8000493c:	5e fd       	retal	0
8000493e:	d7 03       	nop

80004940 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004940:	eb cd 40 e0 	pushm	r5-r7,lr
80004944:	18 96       	mov	r6,r12
80004946:	16 95       	mov	r5,r11
80004948:	e0 67 27 0f 	mov	r7,9999
8000494c:	c0 68       	rjmp	80004958 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000494e:	58 07       	cp.w	r7,0
80004950:	c0 31       	brne	80004956 <usart_putchar+0x16>
80004952:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004956:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004958:	0a 9b       	mov	r11,r5
8000495a:	0c 9c       	mov	r12,r6
8000495c:	f0 1f 00 03 	mcall	80004968 <usart_putchar+0x28>
80004960:	cf 71       	brne	8000494e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004962:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004966:	00 00       	add	r0,r0
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	49 2a       	lddpc	r10,800049b0 <usart_getchar+0x20>

8000496c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000496c:	78 58       	ld.w	r8,r12[0x14]
8000496e:	e2 18 00 e0 	andl	r8,0xe0,COH
80004972:	c0 30       	breq	80004978 <usart_read_char+0xc>
80004974:	30 4c       	mov	r12,4
80004976:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004978:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000497a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000497e:	c0 31       	brne	80004984 <usart_read_char+0x18>
80004980:	30 3c       	mov	r12,3
80004982:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004984:	78 68       	ld.w	r8,r12[0x18]
80004986:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000498a:	97 08       	st.w	r11[0x0],r8
8000498c:	5e fd       	retal	0
8000498e:	d7 03       	nop

80004990 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004990:	eb cd 40 c0 	pushm	r6-r7,lr
80004994:	20 1d       	sub	sp,4
80004996:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004998:	1a 97       	mov	r7,sp
8000499a:	1a 9b       	mov	r11,sp
8000499c:	0c 9c       	mov	r12,r6
8000499e:	f0 1f 00 07 	mcall	800049b8 <usart_getchar+0x28>
800049a2:	58 3c       	cp.w	r12,3
800049a4:	cf b0       	breq	8000499a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800049a6:	58 4c       	cp.w	r12,4
800049a8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800049ac:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800049b0:	2f fd       	sub	sp,-4
800049b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049b6:	00 00       	add	r0,r0
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	49 6c       	lddpc	r12,80004a10 <usart_init_rs232+0x4>

800049bc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800049bc:	eb cd 40 c0 	pushm	r6-r7,lr
800049c0:	18 96       	mov	r6,r12
800049c2:	16 97       	mov	r7,r11
  while (*string != '\0')
800049c4:	17 8b       	ld.ub	r11,r11[0x0]
800049c6:	58 0b       	cp.w	r11,0
800049c8:	c0 80       	breq	800049d8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800049ca:	2f f7       	sub	r7,-1
800049cc:	0c 9c       	mov	r12,r6
800049ce:	f0 1f 00 04 	mcall	800049dc <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800049d2:	0f 8b       	ld.ub	r11,r7[0x0]
800049d4:	58 0b       	cp.w	r11,0
800049d6:	cf a1       	brne	800049ca <usart_write_line+0xe>
800049d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	49 40       	lddpc	r0,80004a2c <usart_init_rs232+0x20>

800049e0 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800049e0:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800049e4:	e6 18 00 01 	andh	r8,0x1,COH
800049e8:	c0 71       	brne	800049f6 <usart_reset+0x16>
800049ea:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800049ec:	3f f8       	mov	r8,-1
800049ee:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800049f0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800049f2:	d5 03       	csrf	0x10
800049f4:	c0 48       	rjmp	800049fc <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800049f6:	3f f8       	mov	r8,-1
800049f8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800049fa:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800049fc:	30 08       	mov	r8,0
800049fe:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004a00:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004a02:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004a04:	ea 68 61 0c 	mov	r8,680204
80004a08:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004a0a:	5e fc       	retal	r12

80004a0c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004a0c:	eb cd 40 e0 	pushm	r5-r7,lr
80004a10:	18 96       	mov	r6,r12
80004a12:	16 97       	mov	r7,r11
80004a14:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004a16:	f0 1f 00 2f 	mcall	80004ad0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004a1a:	58 07       	cp.w	r7,0
80004a1c:	c5 80       	breq	80004acc <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004a1e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a20:	30 49       	mov	r9,4
80004a22:	f2 08 18 00 	cp.b	r8,r9
80004a26:	e0 88 00 53 	brls	80004acc <usart_init_rs232+0xc0>
80004a2a:	30 99       	mov	r9,9
80004a2c:	f2 08 18 00 	cp.b	r8,r9
80004a30:	e0 8b 00 4e 	brhi	80004acc <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004a34:	0f d9       	ld.ub	r9,r7[0x5]
80004a36:	30 78       	mov	r8,7
80004a38:	f0 09 18 00 	cp.b	r9,r8
80004a3c:	e0 8b 00 48 	brhi	80004acc <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004a40:	8e 39       	ld.sh	r9,r7[0x6]
80004a42:	e0 68 01 01 	mov	r8,257
80004a46:	f0 09 19 00 	cp.h	r9,r8
80004a4a:	e0 8b 00 41 	brhi	80004acc <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004a4e:	ef 39 00 08 	ld.ub	r9,r7[8]
80004a52:	30 38       	mov	r8,3
80004a54:	f0 09 18 00 	cp.b	r9,r8
80004a58:	e0 8b 00 3a 	brhi	80004acc <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004a5c:	0a 9a       	mov	r10,r5
80004a5e:	6e 0b       	ld.w	r11,r7[0x0]
80004a60:	0c 9c       	mov	r12,r6
80004a62:	f0 1f 00 1d 	mcall	80004ad4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a66:	58 1c       	cp.w	r12,1
80004a68:	c3 20       	breq	80004acc <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004a6a:	0f c8       	ld.ub	r8,r7[0x4]
80004a6c:	30 99       	mov	r9,9
80004a6e:	f2 08 18 00 	cp.b	r8,r9
80004a72:	c0 51       	brne	80004a7c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004a74:	6c 18       	ld.w	r8,r6[0x4]
80004a76:	b1 b8       	sbr	r8,0x11
80004a78:	8d 18       	st.w	r6[0x4],r8
80004a7a:	c0 68       	rjmp	80004a86 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004a7c:	6c 19       	ld.w	r9,r6[0x4]
80004a7e:	20 58       	sub	r8,5
80004a80:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004a84:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a86:	6c 19       	ld.w	r9,r6[0x4]
80004a88:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004a8c:	0f d8       	ld.ub	r8,r7[0x5]
80004a8e:	a9 78       	lsl	r8,0x9
80004a90:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004a94:	12 48       	or	r8,r9
80004a96:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004a98:	8e 38       	ld.sh	r8,r7[0x6]
80004a9a:	30 29       	mov	r9,2
80004a9c:	f2 08 19 00 	cp.h	r8,r9
80004aa0:	e0 88 00 09 	brls	80004ab2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004aa4:	6c 18       	ld.w	r8,r6[0x4]
80004aa6:	ad b8       	sbr	r8,0xd
80004aa8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004aaa:	8e b8       	ld.uh	r8,r7[0x6]
80004aac:	20 28       	sub	r8,2
80004aae:	8d a8       	st.w	r6[0x28],r8
80004ab0:	c0 68       	rjmp	80004abc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004ab2:	6c 19       	ld.w	r9,r6[0x4]
80004ab4:	5c 78       	castu.h	r8
80004ab6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004aba:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004abc:	6c 18       	ld.w	r8,r6[0x4]
80004abe:	e0 18 ff f0 	andl	r8,0xfff0
80004ac2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004ac4:	35 08       	mov	r8,80
80004ac6:	8d 08       	st.w	r6[0x0],r8
80004ac8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004acc:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	49 e0       	lddpc	r0,80004b48 <vListRemove+0x6>
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	48 d0       	lddpc	r0,80004b08 <vListInsertEnd+0x16>

80004ad8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004ad8:	f8 c8 ff f8 	sub	r8,r12,-8
80004adc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004ade:	3f f9       	mov	r9,-1
80004ae0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004ae2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004ae4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004ae6:	30 08       	mov	r8,0
80004ae8:	99 08       	st.w	r12[0x0],r8
}
80004aea:	5e fc       	retal	r12

80004aec <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004aec:	30 08       	mov	r8,0
80004aee:	99 48       	st.w	r12[0x10],r8
}
80004af0:	5e fc       	retal	r12

80004af2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004af2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004af4:	70 19       	ld.w	r9,r8[0x4]
80004af6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004af8:	78 19       	ld.w	r9,r12[0x4]
80004afa:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004afc:	70 19       	ld.w	r9,r8[0x4]
80004afe:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004b00:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004b02:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004b04:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004b06:	78 08       	ld.w	r8,r12[0x0]
80004b08:	2f f8       	sub	r8,-1
80004b0a:	99 08       	st.w	r12[0x0],r8
}
80004b0c:	5e fc       	retal	r12

80004b0e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004b0e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004b10:	5b fa       	cp.w	r10,-1
80004b12:	c0 31       	brne	80004b18 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004b14:	78 48       	ld.w	r8,r12[0x10]
80004b16:	c0 c8       	rjmp	80004b2e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004b18:	f8 c8 ff f8 	sub	r8,r12,-8
80004b1c:	70 19       	ld.w	r9,r8[0x4]
80004b1e:	72 09       	ld.w	r9,r9[0x0]
80004b20:	12 3a       	cp.w	r10,r9
80004b22:	c0 63       	brcs	80004b2e <vListInsert+0x20>
80004b24:	70 18       	ld.w	r8,r8[0x4]
80004b26:	70 19       	ld.w	r9,r8[0x4]
80004b28:	72 09       	ld.w	r9,r9[0x0]
80004b2a:	12 3a       	cp.w	r10,r9
80004b2c:	cf c2       	brcc	80004b24 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004b2e:	70 19       	ld.w	r9,r8[0x4]
80004b30:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004b32:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004b34:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004b36:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004b38:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004b3a:	78 08       	ld.w	r8,r12[0x0]
80004b3c:	2f f8       	sub	r8,-1
80004b3e:	99 08       	st.w	r12[0x0],r8
}
80004b40:	5e fc       	retal	r12

80004b42 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004b42:	78 18       	ld.w	r8,r12[0x4]
80004b44:	78 29       	ld.w	r9,r12[0x8]
80004b46:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004b48:	78 28       	ld.w	r8,r12[0x8]
80004b4a:	78 19       	ld.w	r9,r12[0x4]
80004b4c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004b4e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004b50:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004b52:	18 39       	cp.w	r9,r12
80004b54:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004b58:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004b5c:	30 09       	mov	r9,0
80004b5e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004b60:	70 09       	ld.w	r9,r8[0x0]
80004b62:	20 19       	sub	r9,1
80004b64:	91 09       	st.w	r8[0x0],r9
}
80004b66:	5e fc       	retal	r12

80004b68 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004b68:	e0 68 08 08 	mov	r8,2056
80004b6c:	ea 18 08 08 	orh	r8,0x808
80004b70:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004b72:	e0 68 09 09 	mov	r8,2313
80004b76:	ea 18 09 09 	orh	r8,0x909
80004b7a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004b7c:	e0 68 0a 0a 	mov	r8,2570
80004b80:	ea 18 0a 0a 	orh	r8,0xa0a
80004b84:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004b86:	e0 68 0b 0b 	mov	r8,2827
80004b8a:	ea 18 0b 0b 	orh	r8,0xb0b
80004b8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004b90:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004b92:	e0 68 be ef 	mov	r8,48879
80004b96:	ea 18 de ad 	orh	r8,0xdead
80004b9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004b9c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004b9e:	fc 18 00 40 	movh	r8,0x40
80004ba2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004ba4:	e0 68 00 ff 	mov	r8,255
80004ba8:	ea 18 ff 00 	orh	r8,0xff00
80004bac:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004bae:	e0 68 01 01 	mov	r8,257
80004bb2:	ea 18 01 01 	orh	r8,0x101
80004bb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004bb8:	e0 68 02 02 	mov	r8,514
80004bbc:	ea 18 02 02 	orh	r8,0x202
80004bc0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004bc2:	e0 68 03 03 	mov	r8,771
80004bc6:	ea 18 03 03 	orh	r8,0x303
80004bca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004bcc:	e0 68 04 04 	mov	r8,1028
80004bd0:	ea 18 04 04 	orh	r8,0x404
80004bd4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004bd6:	e0 68 05 05 	mov	r8,1285
80004bda:	ea 18 05 05 	orh	r8,0x505
80004bde:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004be0:	e0 68 06 06 	mov	r8,1542
80004be4:	ea 18 06 06 	orh	r8,0x606
80004be8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004bea:	e0 68 07 07 	mov	r8,1799
80004bee:	ea 18 07 07 	orh	r8,0x707
80004bf2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004bf4:	30 08       	mov	r8,0
80004bf6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004bf8:	5e fc       	retal	r12
80004bfa:	d7 03       	nop

80004bfc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004bfc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004bfe:	48 38       	lddpc	r8,80004c08 <vPortEnterCritical+0xc>
80004c00:	70 09       	ld.w	r9,r8[0x0]
80004c02:	2f f9       	sub	r9,-1
80004c04:	91 09       	st.w	r8[0x0],r9
}
80004c06:	5e fc       	retal	r12
80004c08:	00 00       	add	r0,r0
80004c0a:	05 28       	ld.uh	r8,r2++

80004c0c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004c0c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004c0e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004c10:	30 0a       	mov	r10,0
80004c12:	14 9b       	mov	r11,r10
80004c14:	49 2c       	lddpc	r12,80004c5c <xPortStartScheduler+0x50>
80004c16:	f0 1f 00 13 	mcall	80004c60 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004c1a:	e0 68 5d c0 	mov	r8,24000
80004c1e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004c22:	30 08       	mov	r8,0
80004c24:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004c28:	e0 68 0c dc 	mov	r8,3292
80004c2c:	ea 18 00 00 	orh	r8,0x0
80004c30:	70 00       	ld.w	r0,r8[0x0]
80004c32:	60 0d       	ld.w	sp,r0[0x0]
80004c34:	1b 00       	ld.w	r0,sp++
80004c36:	e0 68 05 28 	mov	r8,1320
80004c3a:	ea 18 00 00 	orh	r8,0x0
80004c3e:	91 00       	st.w	r8[0x0],r0
80004c40:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004c44:	2f ed       	sub	sp,-8
80004c46:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004c4a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004c4e:	e3 b0 00 00 	mtsr	0x0,r0
80004c52:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004c56:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004c5a:	d8 0a       	popm	pc,r12=0
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	4d 28       	lddpc	r8,80004da4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	47 c4       	lddsp	r4,sp[0x1f0]

80004c64 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004c64:	20 6d       	sub	sp,24
80004c66:	eb cd 00 ff 	pushm	r0-r7
80004c6a:	fa c7 ff c0 	sub	r7,sp,-64
80004c6e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004c72:	ef 40 ff e0 	st.w	r7[-32],r0
80004c76:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004c7a:	ef 40 ff e4 	st.w	r7[-28],r0
80004c7e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004c82:	e0 68 05 28 	mov	r8,1320
80004c86:	ea 18 00 00 	orh	r8,0x0
80004c8a:	70 00       	ld.w	r0,r8[0x0]
80004c8c:	1a d0       	st.w	--sp,r0
80004c8e:	f0 1f 00 1a 	mcall	80004cf4 <LABEL_RET_SCALL_263+0x14>
80004c92:	e0 68 0c dc 	mov	r8,3292
80004c96:	ea 18 00 00 	orh	r8,0x0
80004c9a:	70 00       	ld.w	r0,r8[0x0]
80004c9c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004c9e:	f0 1f 00 17 	mcall	80004cf8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004ca2:	e0 68 0c dc 	mov	r8,3292
80004ca6:	ea 18 00 00 	orh	r8,0x0
80004caa:	70 00       	ld.w	r0,r8[0x0]
80004cac:	60 0d       	ld.w	sp,r0[0x0]
80004cae:	1b 00       	ld.w	r0,sp++
80004cb0:	e0 68 05 28 	mov	r8,1320
80004cb4:	ea 18 00 00 	orh	r8,0x0
80004cb8:	91 00       	st.w	r8[0x0],r0
80004cba:	fa c7 ff d8 	sub	r7,sp,-40
80004cbe:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004cc2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004cc6:	e0 61 05 28 	mov	r1,1320
80004cca:	ea 11 00 00 	orh	r1,0x0
80004cce:	62 02       	ld.w	r2,r1[0x0]
80004cd0:	58 02       	cp.w	r2,0
80004cd2:	c0 70       	breq	80004ce0 <LABEL_RET_SCALL_263>
80004cd4:	e4 c2 00 01 	sub	r2,r2,1
80004cd8:	83 02       	st.w	r1[0x0],r2
80004cda:	58 02       	cp.w	r2,0
80004cdc:	c0 21       	brne	80004ce0 <LABEL_RET_SCALL_263>
80004cde:	b1 c0       	cbr	r0,0x10

80004ce0 <LABEL_RET_SCALL_263>:
80004ce0:	ef 40 ff f8 	st.w	r7[-8],r0
80004ce4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004ce8:	ef 40 ff fc 	st.w	r7[-4],r0
80004cec:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004cf0:	2f ad       	sub	sp,-24
80004cf2:	d6 13       	rets
80004cf4:	80 00       	ld.sh	r0,r0[0x0]
80004cf6:	4b fc       	lddpc	r12,80004df0 <_read+0x2c>
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	53 40       	stdsp	sp[0xd0],r0

80004cfc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004cfc:	e1 b8 00 43 	mfsr	r8,0x10c
80004d00:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004d04:	5e fc       	retal	r12
80004d06:	d7 03       	nop

80004d08 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004d08:	48 78       	lddpc	r8,80004d24 <vPortExitCritical+0x1c>
80004d0a:	70 08       	ld.w	r8,r8[0x0]
80004d0c:	58 08       	cp.w	r8,0
80004d0e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004d10:	48 58       	lddpc	r8,80004d24 <vPortExitCritical+0x1c>
80004d12:	70 09       	ld.w	r9,r8[0x0]
80004d14:	20 19       	sub	r9,1
80004d16:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004d18:	70 08       	ld.w	r8,r8[0x0]
80004d1a:	58 08       	cp.w	r8,0
80004d1c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004d1e:	d5 03       	csrf	0x10
80004d20:	5e fc       	retal	r12
80004d22:	00 00       	add	r0,r0
80004d24:	00 00       	add	r0,r0
80004d26:	05 28       	ld.uh	r8,r2++

80004d28 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004d28:	eb cd 00 ff 	pushm	r0-r7
80004d2c:	e0 68 05 28 	mov	r8,1320
80004d30:	ea 18 00 00 	orh	r8,0x0
80004d34:	70 00       	ld.w	r0,r8[0x0]
80004d36:	1a d0       	st.w	--sp,r0
80004d38:	7a 90       	ld.w	r0,sp[0x24]
80004d3a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004d3e:	58 10       	cp.w	r0,1
80004d40:	e0 8b 00 08 	brhi	80004d50 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004d44:	e0 68 0c dc 	mov	r8,3292
80004d48:	ea 18 00 00 	orh	r8,0x0
80004d4c:	70 00       	ld.w	r0,r8[0x0]
80004d4e:	81 0d       	st.w	r0[0x0],sp

80004d50 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004d50:	f0 1f 00 12 	mcall	80004d98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004d54:	f0 1f 00 12 	mcall	80004d9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004d58:	f0 1f 00 12 	mcall	80004da0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004d5c:	f0 1f 00 12 	mcall	80004da4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004d60:	7a 90       	ld.w	r0,sp[0x24]
80004d62:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004d66:	58 10       	cp.w	r0,1
80004d68:	e0 8b 00 0e 	brhi	80004d84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004d6c:	f0 1f 00 0c 	mcall	80004d9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004d70:	f0 1f 00 0e 	mcall	80004da8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004d74:	f0 1f 00 0c 	mcall	80004da4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004d78:	e0 68 0c dc 	mov	r8,3292
80004d7c:	ea 18 00 00 	orh	r8,0x0
80004d80:	70 00       	ld.w	r0,r8[0x0]
80004d82:	60 0d       	ld.w	sp,r0[0x0]

80004d84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004d84:	1b 00       	ld.w	r0,sp++
80004d86:	e0 68 05 28 	mov	r8,1320
80004d8a:	ea 18 00 00 	orh	r8,0x0
80004d8e:	91 00       	st.w	r8[0x0],r0
80004d90:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004d94:	d6 03       	rete
80004d96:	00 00       	add	r0,r0
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	4c fc       	lddpc	r12,80004ed4 <xQueueReceiveFromISR+0x14>
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	4b fc       	lddpc	r12,80004e98 <prvCopyDataFromQueue+0x8>
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	55 44       	stdsp	sp[0x150],r4
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	4d 08       	lddpc	r8,80004ee4 <xQueueReceiveFromISR+0x24>
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	53 40       	stdsp	sp[0xd0],r0

80004dac <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004dac:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004dae:	f0 1f 00 02 	mcall	80004db4 <__malloc_lock+0x8>
}
80004db2:	d8 02       	popm	pc
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	53 30       	stdsp	sp[0xcc],r0

80004db8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004db8:	d4 01       	pushm	lr
	xTaskResumeAll();
80004dba:	f0 1f 00 02 	mcall	80004dc0 <__malloc_unlock+0x8>
}
80004dbe:	d8 02       	popm	pc
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	56 ec       	stdsp	sp[0x1b8],r12

80004dc4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004dc4:	d4 21       	pushm	r4-r7,lr
80004dc6:	16 95       	mov	r5,r11
80004dc8:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004dca:	58 0c       	cp.w	r12,0
80004dcc:	c0 30       	breq	80004dd2 <_read+0xe>
80004dce:	3f f7       	mov	r7,-1
80004dd0:	c1 48       	rjmp	80004df8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004dd2:	58 0a       	cp.w	r10,0
80004dd4:	e0 89 00 04 	brgt	80004ddc <_read+0x18>
80004dd8:	30 07       	mov	r7,0
80004dda:	c0 f8       	rjmp	80004df8 <_read+0x34>
80004ddc:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004dde:	48 84       	lddpc	r4,80004dfc <_read+0x38>
80004de0:	68 0c       	ld.w	r12,r4[0x0]
80004de2:	f0 1f 00 08 	mcall	80004e00 <_read+0x3c>
    if (c < 0)
80004de6:	c0 95       	brlt	80004df8 <_read+0x34>
      break;

    *ptr++ = c;
80004de8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004dec:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004dee:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004df2:	58 08       	cp.w	r8,0
80004df4:	fe 99 ff f6 	brgt	80004de0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004df8:	0e 9c       	mov	r12,r7
80004dfa:	d8 22       	popm	r4-r7,pc
80004dfc:	00 00       	add	r0,r0
80004dfe:	41 0c       	lddsp	r12,sp[0x40]
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	49 90       	lddpc	r0,80004e64 <vPortFree+0x24>

80004e04 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004e04:	d4 21       	pushm	r4-r7,lr
80004e06:	16 95       	mov	r5,r11
80004e08:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004e0a:	20 1c       	sub	r12,1
80004e0c:	58 2c       	cp.w	r12,2
80004e0e:	e0 8b 00 12 	brhi	80004e32 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004e12:	58 0a       	cp.w	r10,0
80004e14:	c0 31       	brne	80004e1a <_write+0x16>
80004e16:	30 07       	mov	r7,0
80004e18:	c0 e8       	rjmp	80004e34 <_write+0x30>
80004e1a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004e1c:	48 74       	lddpc	r4,80004e38 <_write+0x34>
80004e1e:	68 0c       	ld.w	r12,r4[0x0]
80004e20:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004e24:	f0 1f 00 06 	mcall	80004e3c <_write+0x38>
80004e28:	c0 55       	brlt	80004e32 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004e2a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004e2c:	0e 36       	cp.w	r6,r7
80004e2e:	cf 81       	brne	80004e1e <_write+0x1a>
80004e30:	c0 28       	rjmp	80004e34 <_write+0x30>
80004e32:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004e34:	0e 9c       	mov	r12,r7
80004e36:	d8 22       	popm	r4-r7,pc
80004e38:	00 00       	add	r0,r0
80004e3a:	41 0c       	lddsp	r12,sp[0x40]
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	49 40       	lddpc	r0,80004e8c <pvPortMalloc+0x24>

80004e40 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004e40:	eb cd 40 80 	pushm	r7,lr
80004e44:	18 97       	mov	r7,r12
	if( pv )
80004e46:	58 0c       	cp.w	r12,0
80004e48:	c0 80       	breq	80004e58 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004e4a:	f0 1f 00 05 	mcall	80004e5c <vPortFree+0x1c>
		{
			free( pv );
80004e4e:	0e 9c       	mov	r12,r7
80004e50:	f0 1f 00 04 	mcall	80004e60 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004e54:	f0 1f 00 04 	mcall	80004e64 <vPortFree+0x24>
80004e58:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e5c:	80 00       	ld.sh	r0,r0[0x0]
80004e5e:	53 30       	stdsp	sp[0xcc],r0
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	62 6c       	ld.w	r12,r1[0x18]
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	56 ec       	stdsp	sp[0x1b8],r12

80004e68 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004e68:	eb cd 40 80 	pushm	r7,lr
80004e6c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004e6e:	f0 1f 00 06 	mcall	80004e84 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004e72:	0e 9c       	mov	r12,r7
80004e74:	f0 1f 00 05 	mcall	80004e88 <pvPortMalloc+0x20>
80004e78:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004e7a:	f0 1f 00 05 	mcall	80004e8c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004e7e:	0e 9c       	mov	r12,r7
80004e80:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	53 30       	stdsp	sp[0xcc],r0
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	62 7c       	ld.w	r12,r1[0x1c]
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	56 ec       	stdsp	sp[0x1b8],r12

80004e90 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004e90:	d4 01       	pushm	lr
80004e92:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004e94:	78 09       	ld.w	r9,r12[0x0]
80004e96:	58 09       	cp.w	r9,0
80004e98:	c1 10       	breq	80004eba <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004e9a:	78 3a       	ld.w	r10,r12[0xc]
80004e9c:	79 09       	ld.w	r9,r12[0x40]
80004e9e:	f4 09 00 09 	add	r9,r10,r9
80004ea2:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004ea4:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004ea6:	14 39       	cp.w	r9,r10
80004ea8:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004eac:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004eb0:	79 0a       	ld.w	r10,r12[0x40]
80004eb2:	78 3b       	ld.w	r11,r12[0xc]
80004eb4:	10 9c       	mov	r12,r8
80004eb6:	f0 1f 00 02 	mcall	80004ebc <prvCopyDataFromQueue+0x2c>
80004eba:	d8 02       	popm	pc
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	66 c4       	ld.w	r4,r3[0x30]

80004ec0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004ec0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ec4:	18 97       	mov	r7,r12
80004ec6:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004ec8:	78 e8       	ld.w	r8,r12[0x38]
80004eca:	58 08       	cp.w	r8,0
80004ecc:	c0 31       	brne	80004ed2 <xQueueReceiveFromISR+0x12>
80004ece:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80004ed2:	f0 1f 00 0e 	mcall	80004f08 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80004ed6:	6e e8       	ld.w	r8,r7[0x38]
80004ed8:	20 18       	sub	r8,1
80004eda:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004edc:	6f 18       	ld.w	r8,r7[0x44]
80004ede:	5b f8       	cp.w	r8,-1
80004ee0:	c0 d1       	brne	80004efa <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004ee2:	6e 48       	ld.w	r8,r7[0x10]
80004ee4:	58 08       	cp.w	r8,0
80004ee6:	c0 f0       	breq	80004f04 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004ee8:	ee cc ff f0 	sub	r12,r7,-16
80004eec:	f0 1f 00 08 	mcall	80004f0c <xQueueReceiveFromISR+0x4c>
80004ef0:	c0 a0       	breq	80004f04 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80004ef2:	30 1c       	mov	r12,1
80004ef4:	8d 0c       	st.w	r6[0x0],r12
80004ef6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004efa:	2f f8       	sub	r8,-1
80004efc:	ef 48 00 44 	st.w	r7[68],r8
80004f00:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004f04:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	4e 90       	lddpc	r0,800050ac <xQueueGenericReceive+0xfc>
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	54 c8       	stdsp	sp[0x130],r8

80004f10 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004f10:	eb cd 40 c0 	pushm	r6-r7,lr
80004f14:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004f16:	f0 1f 00 23 	mcall	80004fa0 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004f1a:	6f 28       	ld.w	r8,r7[0x48]
80004f1c:	58 08       	cp.w	r8,0
80004f1e:	e0 8a 00 18 	brle	80004f4e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004f22:	6e 98       	ld.w	r8,r7[0x24]
80004f24:	58 08       	cp.w	r8,0
80004f26:	c1 40       	breq	80004f4e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004f28:	ee c6 ff dc 	sub	r6,r7,-36
80004f2c:	c0 48       	rjmp	80004f34 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004f2e:	6e 98       	ld.w	r8,r7[0x24]
80004f30:	58 08       	cp.w	r8,0
80004f32:	c0 e0       	breq	80004f4e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004f34:	0c 9c       	mov	r12,r6
80004f36:	f0 1f 00 1c 	mcall	80004fa4 <prvUnlockQueue+0x94>
80004f3a:	c0 30       	breq	80004f40 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004f3c:	f0 1f 00 1b 	mcall	80004fa8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004f40:	6f 28       	ld.w	r8,r7[0x48]
80004f42:	20 18       	sub	r8,1
80004f44:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004f48:	58 08       	cp.w	r8,0
80004f4a:	fe 99 ff f2 	brgt	80004f2e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004f4e:	3f f8       	mov	r8,-1
80004f50:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004f54:	f0 1f 00 16 	mcall	80004fac <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004f58:	f0 1f 00 12 	mcall	80004fa0 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004f5c:	6f 18       	ld.w	r8,r7[0x44]
80004f5e:	58 08       	cp.w	r8,0
80004f60:	e0 8a 00 18 	brle	80004f90 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004f64:	6e 48       	ld.w	r8,r7[0x10]
80004f66:	58 08       	cp.w	r8,0
80004f68:	c1 40       	breq	80004f90 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004f6a:	ee c6 ff f0 	sub	r6,r7,-16
80004f6e:	c0 48       	rjmp	80004f76 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004f70:	6e 48       	ld.w	r8,r7[0x10]
80004f72:	58 08       	cp.w	r8,0
80004f74:	c0 e0       	breq	80004f90 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004f76:	0c 9c       	mov	r12,r6
80004f78:	f0 1f 00 0b 	mcall	80004fa4 <prvUnlockQueue+0x94>
80004f7c:	c0 30       	breq	80004f82 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004f7e:	f0 1f 00 0b 	mcall	80004fa8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004f82:	6f 18       	ld.w	r8,r7[0x44]
80004f84:	20 18       	sub	r8,1
80004f86:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004f8a:	58 08       	cp.w	r8,0
80004f8c:	fe 99 ff f2 	brgt	80004f70 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004f90:	3f f8       	mov	r8,-1
80004f92:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004f96:	f0 1f 00 06 	mcall	80004fac <prvUnlockQueue+0x9c>
}
80004f9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f9e:	00 00       	add	r0,r0
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	4b fc       	lddpc	r12,8000509c <xQueueGenericReceive+0xec>
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	54 c8       	stdsp	sp[0x130],r8
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	53 d4       	stdsp	sp[0xf4],r4
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	4d 08       	lddpc	r8,800050ec <xQueueGenericReceive+0x13c>

80004fb0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004fb0:	d4 31       	pushm	r0-r7,lr
80004fb2:	20 5d       	sub	sp,20
80004fb4:	18 97       	mov	r7,r12
80004fb6:	50 0b       	stdsp	sp[0x0],r11
80004fb8:	50 2a       	stdsp	sp[0x8],r10
80004fba:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004fbc:	f8 c2 ff dc 	sub	r2,r12,-36
80004fc0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004fc2:	fa c4 ff f4 	sub	r4,sp,-12
80004fc6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004fc8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004fca:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004fce:	f0 1f 00 3e 	mcall	800050c4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004fd2:	6e e8       	ld.w	r8,r7[0x38]
80004fd4:	58 08       	cp.w	r8,0
80004fd6:	c2 a0       	breq	8000502a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004fd8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004fda:	40 0b       	lddsp	r11,sp[0x0]
80004fdc:	0e 9c       	mov	r12,r7
80004fde:	f0 1f 00 3b 	mcall	800050c8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004fe2:	40 18       	lddsp	r8,sp[0x4]
80004fe4:	58 08       	cp.w	r8,0
80004fe6:	c1 51       	brne	80005010 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004fe8:	6e e8       	ld.w	r8,r7[0x38]
80004fea:	20 18       	sub	r8,1
80004fec:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004fee:	6e 08       	ld.w	r8,r7[0x0]
80004ff0:	58 08       	cp.w	r8,0
80004ff2:	c0 41       	brne	80004ffa <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004ff4:	f0 1f 00 36 	mcall	800050cc <xQueueGenericReceive+0x11c>
80004ff8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004ffa:	6e 48       	ld.w	r8,r7[0x10]
80004ffc:	58 08       	cp.w	r8,0
80004ffe:	c1 20       	breq	80005022 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005000:	ee cc ff f0 	sub	r12,r7,-16
80005004:	f0 1f 00 33 	mcall	800050d0 <xQueueGenericReceive+0x120>
80005008:	58 1c       	cp.w	r12,1
8000500a:	c0 c1       	brne	80005022 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000500c:	d7 33       	scall
8000500e:	c0 a8       	rjmp	80005022 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005010:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005012:	6e 98       	ld.w	r8,r7[0x24]
80005014:	58 08       	cp.w	r8,0
80005016:	c0 60       	breq	80005022 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005018:	04 9c       	mov	r12,r2
8000501a:	f0 1f 00 2e 	mcall	800050d0 <xQueueGenericReceive+0x120>
8000501e:	c0 20       	breq	80005022 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005020:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005022:	f0 1f 00 2d 	mcall	800050d4 <xQueueGenericReceive+0x124>
80005026:	30 1c       	mov	r12,1
				return pdPASS;
80005028:	c4 c8       	rjmp	800050c0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000502a:	40 28       	lddsp	r8,sp[0x8]
8000502c:	58 08       	cp.w	r8,0
8000502e:	c0 51       	brne	80005038 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005030:	f0 1f 00 29 	mcall	800050d4 <xQueueGenericReceive+0x124>
80005034:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005036:	c4 58       	rjmp	800050c0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005038:	58 05       	cp.w	r5,0
8000503a:	c0 51       	brne	80005044 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000503c:	08 9c       	mov	r12,r4
8000503e:	f0 1f 00 27 	mcall	800050d8 <xQueueGenericReceive+0x128>
80005042:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005044:	f0 1f 00 24 	mcall	800050d4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005048:	f0 1f 00 25 	mcall	800050dc <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000504c:	f0 1f 00 1e 	mcall	800050c4 <xQueueGenericReceive+0x114>
80005050:	6f 18       	ld.w	r8,r7[0x44]
80005052:	5b f8       	cp.w	r8,-1
80005054:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005058:	6f 28       	ld.w	r8,r7[0x48]
8000505a:	5b f8       	cp.w	r8,-1
8000505c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005060:	f0 1f 00 1d 	mcall	800050d4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005064:	06 9b       	mov	r11,r3
80005066:	08 9c       	mov	r12,r4
80005068:	f0 1f 00 1e 	mcall	800050e0 <xQueueGenericReceive+0x130>
8000506c:	c2 41       	brne	800050b4 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000506e:	f0 1f 00 16 	mcall	800050c4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005072:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005074:	f0 1f 00 18 	mcall	800050d4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005078:	58 06       	cp.w	r6,0
8000507a:	c1 71       	brne	800050a8 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000507c:	6e 08       	ld.w	r8,r7[0x0]
8000507e:	58 08       	cp.w	r8,0
80005080:	c0 81       	brne	80005090 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005082:	f0 1f 00 11 	mcall	800050c4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005086:	6e 1c       	ld.w	r12,r7[0x4]
80005088:	f0 1f 00 17 	mcall	800050e4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000508c:	f0 1f 00 12 	mcall	800050d4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005090:	40 2b       	lddsp	r11,sp[0x8]
80005092:	04 9c       	mov	r12,r2
80005094:	f0 1f 00 15 	mcall	800050e8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005098:	0e 9c       	mov	r12,r7
8000509a:	f0 1f 00 15 	mcall	800050ec <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000509e:	f0 1f 00 15 	mcall	800050f0 <xQueueGenericReceive+0x140>
800050a2:	c9 61       	brne	80004fce <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800050a4:	d7 33       	scall
800050a6:	c9 4b       	rjmp	80004fce <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800050a8:	0e 9c       	mov	r12,r7
800050aa:	f0 1f 00 11 	mcall	800050ec <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800050ae:	f0 1f 00 11 	mcall	800050f0 <xQueueGenericReceive+0x140>
800050b2:	c8 eb       	rjmp	80004fce <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800050b4:	0e 9c       	mov	r12,r7
800050b6:	f0 1f 00 0e 	mcall	800050ec <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800050ba:	f0 1f 00 0e 	mcall	800050f0 <xQueueGenericReceive+0x140>
800050be:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800050c0:	2f bd       	sub	sp,-20
800050c2:	d8 32       	popm	r0-r7,pc
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	4b fc       	lddpc	r12,800051c0 <xQueueGenericSend+0x4>
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	4e 90       	lddpc	r0,8000526c <xQueueGenericSend+0xb0>
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	53 e0       	stdsp	sp[0xf8],r0
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	54 c8       	stdsp	sp[0x130],r8
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	4d 08       	lddpc	r8,80005214 <xQueueGenericSend+0x58>
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	53 bc       	stdsp	sp[0xec],r12
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	53 30       	stdsp	sp[0xcc],r0
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	56 58       	stdsp	sp[0x194],r8
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	54 44       	stdsp	sp[0x110],r4
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	58 b0       	cp.w	r0,11
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4f 10       	lddpc	r0,800052b0 <xQueueGenericSend+0xf4>
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	56 ec       	stdsp	sp[0x1b8],r12

800050f4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800050f4:	eb cd 40 80 	pushm	r7,lr
800050f8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800050fa:	79 08       	ld.w	r8,r12[0x40]
800050fc:	58 08       	cp.w	r8,0
800050fe:	c0 a1       	brne	80005112 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005100:	78 08       	ld.w	r8,r12[0x0]
80005102:	58 08       	cp.w	r8,0
80005104:	c2 b1       	brne	8000515a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005106:	78 1c       	ld.w	r12,r12[0x4]
80005108:	f0 1f 00 17 	mcall	80005164 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000510c:	30 08       	mov	r8,0
8000510e:	8f 18       	st.w	r7[0x4],r8
80005110:	c2 58       	rjmp	8000515a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005112:	58 0a       	cp.w	r10,0
80005114:	c1 01       	brne	80005134 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005116:	10 9a       	mov	r10,r8
80005118:	78 2c       	ld.w	r12,r12[0x8]
8000511a:	f0 1f 00 14 	mcall	80005168 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000511e:	6e 29       	ld.w	r9,r7[0x8]
80005120:	6f 08       	ld.w	r8,r7[0x40]
80005122:	f2 08 00 08 	add	r8,r9,r8
80005126:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005128:	6e 19       	ld.w	r9,r7[0x4]
8000512a:	12 38       	cp.w	r8,r9
8000512c:	c1 73       	brcs	8000515a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000512e:	6e 08       	ld.w	r8,r7[0x0]
80005130:	8f 28       	st.w	r7[0x8],r8
80005132:	c1 48       	rjmp	8000515a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005134:	10 9a       	mov	r10,r8
80005136:	78 3c       	ld.w	r12,r12[0xc]
80005138:	f0 1f 00 0c 	mcall	80005168 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000513c:	6f 08       	ld.w	r8,r7[0x40]
8000513e:	6e 39       	ld.w	r9,r7[0xc]
80005140:	f2 08 01 08 	sub	r8,r9,r8
80005144:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005146:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005148:	12 38       	cp.w	r8,r9
8000514a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000514e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005152:	f3 d8 e3 19 	subcs	r9,r9,r8
80005156:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000515a:	6e e8       	ld.w	r8,r7[0x38]
8000515c:	2f f8       	sub	r8,-1
8000515e:	8f e8       	st.w	r7[0x38],r8
}
80005160:	e3 cd 80 80 	ldm	sp++,r7,pc
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	53 ec       	stdsp	sp[0xf8],r12
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	66 c4       	ld.w	r4,r3[0x30]

8000516c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000516c:	eb cd 40 c0 	pushm	r6-r7,lr
80005170:	18 97       	mov	r7,r12
80005172:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005174:	78 ec       	ld.w	r12,r12[0x38]
80005176:	6e f8       	ld.w	r8,r7[0x3c]
80005178:	10 3c       	cp.w	r12,r8
8000517a:	c0 33       	brcs	80005180 <xQueueGenericSendFromISR+0x14>
8000517c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005180:	12 9a       	mov	r10,r9
80005182:	0e 9c       	mov	r12,r7
80005184:	f0 1f 00 0c 	mcall	800051b4 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005188:	6f 28       	ld.w	r8,r7[0x48]
8000518a:	5b f8       	cp.w	r8,-1
8000518c:	c0 d1       	brne	800051a6 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000518e:	6e 98       	ld.w	r8,r7[0x24]
80005190:	58 08       	cp.w	r8,0
80005192:	c0 f0       	breq	800051b0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005194:	ee cc ff dc 	sub	r12,r7,-36
80005198:	f0 1f 00 08 	mcall	800051b8 <xQueueGenericSendFromISR+0x4c>
8000519c:	c0 a0       	breq	800051b0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000519e:	30 1c       	mov	r12,1
800051a0:	8d 0c       	st.w	r6[0x0],r12
800051a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800051a6:	2f f8       	sub	r8,-1
800051a8:	ef 48 00 48 	st.w	r7[72],r8
800051ac:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800051b0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	50 f4       	stdsp	sp[0x3c],r4
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	54 c8       	stdsp	sp[0x130],r8

800051bc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800051bc:	d4 31       	pushm	r0-r7,lr
800051be:	20 5d       	sub	sp,20
800051c0:	18 97       	mov	r7,r12
800051c2:	50 0b       	stdsp	sp[0x0],r11
800051c4:	50 2a       	stdsp	sp[0x8],r10
800051c6:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800051c8:	f8 c0 ff f0 	sub	r0,r12,-16
800051cc:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800051ce:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800051d2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800051d4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800051d8:	f0 1f 00 2f 	mcall	80005294 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800051dc:	6e e9       	ld.w	r9,r7[0x38]
800051de:	6e f8       	ld.w	r8,r7[0x3c]
800051e0:	10 39       	cp.w	r9,r8
800051e2:	c1 42       	brcc	8000520a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800051e4:	40 1a       	lddsp	r10,sp[0x4]
800051e6:	40 0b       	lddsp	r11,sp[0x0]
800051e8:	0e 9c       	mov	r12,r7
800051ea:	f0 1f 00 2c 	mcall	80005298 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800051ee:	6e 98       	ld.w	r8,r7[0x24]
800051f0:	58 08       	cp.w	r8,0
800051f2:	c0 80       	breq	80005202 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800051f4:	ee cc ff dc 	sub	r12,r7,-36
800051f8:	f0 1f 00 29 	mcall	8000529c <xQueueGenericSend+0xe0>
800051fc:	58 1c       	cp.w	r12,1
800051fe:	c0 21       	brne	80005202 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005200:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005202:	f0 1f 00 28 	mcall	800052a0 <xQueueGenericSend+0xe4>
80005206:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005208:	c4 38       	rjmp	8000528e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000520a:	40 28       	lddsp	r8,sp[0x8]
8000520c:	58 08       	cp.w	r8,0
8000520e:	c0 51       	brne	80005218 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005210:	f0 1f 00 24 	mcall	800052a0 <xQueueGenericSend+0xe4>
80005214:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005216:	c3 c8       	rjmp	8000528e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005218:	58 04       	cp.w	r4,0
8000521a:	c0 51       	brne	80005224 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000521c:	06 9c       	mov	r12,r3
8000521e:	f0 1f 00 22 	mcall	800052a4 <xQueueGenericSend+0xe8>
80005222:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005224:	f0 1f 00 1f 	mcall	800052a0 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005228:	f0 1f 00 20 	mcall	800052a8 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000522c:	f0 1f 00 1a 	mcall	80005294 <xQueueGenericSend+0xd8>
80005230:	6f 18       	ld.w	r8,r7[0x44]
80005232:	5b f8       	cp.w	r8,-1
80005234:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005238:	6f 28       	ld.w	r8,r7[0x48]
8000523a:	5b f8       	cp.w	r8,-1
8000523c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005240:	f0 1f 00 18 	mcall	800052a0 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005244:	04 9b       	mov	r11,r2
80005246:	06 9c       	mov	r12,r3
80005248:	f0 1f 00 19 	mcall	800052ac <xQueueGenericSend+0xf0>
8000524c:	c1 b1       	brne	80005282 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000524e:	f0 1f 00 12 	mcall	80005294 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005252:	6e e5       	ld.w	r5,r7[0x38]
80005254:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005256:	f0 1f 00 13 	mcall	800052a0 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000525a:	0c 35       	cp.w	r5,r6
8000525c:	c0 d1       	brne	80005276 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000525e:	40 2b       	lddsp	r11,sp[0x8]
80005260:	00 9c       	mov	r12,r0
80005262:	f0 1f 00 14 	mcall	800052b0 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005266:	0e 9c       	mov	r12,r7
80005268:	f0 1f 00 13 	mcall	800052b4 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000526c:	f0 1f 00 13 	mcall	800052b8 <xQueueGenericSend+0xfc>
80005270:	cb 41       	brne	800051d8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005272:	d7 33       	scall
80005274:	cb 2b       	rjmp	800051d8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005276:	0e 9c       	mov	r12,r7
80005278:	f0 1f 00 0f 	mcall	800052b4 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000527c:	f0 1f 00 0f 	mcall	800052b8 <xQueueGenericSend+0xfc>
80005280:	ca cb       	rjmp	800051d8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005282:	0e 9c       	mov	r12,r7
80005284:	f0 1f 00 0c 	mcall	800052b4 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005288:	f0 1f 00 0c 	mcall	800052b8 <xQueueGenericSend+0xfc>
8000528c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000528e:	2f bd       	sub	sp,-20
80005290:	d8 32       	popm	r0-r7,pc
80005292:	00 00       	add	r0,r0
80005294:	80 00       	ld.sh	r0,r0[0x0]
80005296:	4b fc       	lddpc	r12,80005390 <vTaskSwitchContext+0x50>
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	50 f4       	stdsp	sp[0x3c],r4
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	54 c8       	stdsp	sp[0x130],r8
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	4d 08       	lddpc	r8,800053e0 <xTaskGetCurrentTaskHandle>
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	53 bc       	stdsp	sp[0xec],r12
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	53 30       	stdsp	sp[0xcc],r0
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	56 58       	stdsp	sp[0x194],r8
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	58 b0       	cp.w	r0,11
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	4f 10       	lddpc	r0,80005478 <vTaskPriorityInherit+0x34>
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	56 ec       	stdsp	sp[0x1b8],r12

800052bc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800052bc:	d4 21       	pushm	r4-r7,lr
800052be:	18 97       	mov	r7,r12
800052c0:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800052c2:	58 0c       	cp.w	r12,0
800052c4:	c2 f0       	breq	80005322 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800052c6:	34 cc       	mov	r12,76
800052c8:	f0 1f 00 17 	mcall	80005324 <xQueueCreate+0x68>
800052cc:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800052ce:	c2 a0       	breq	80005322 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800052d0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800052d4:	e8 cc ff ff 	sub	r12,r4,-1
800052d8:	f0 1f 00 13 	mcall	80005324 <xQueueCreate+0x68>
800052dc:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800052de:	c1 e0       	breq	8000531a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800052e0:	f8 04 00 04 	add	r4,r12,r4
800052e4:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800052e6:	30 08       	mov	r8,0
800052e8:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800052ea:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800052ec:	ee c8 00 01 	sub	r8,r7,1
800052f0:	ad 38       	mul	r8,r6
800052f2:	10 0c       	add	r12,r8
800052f4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800052f6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800052f8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800052fc:	3f f8       	mov	r8,-1
800052fe:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005302:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005306:	ea cc ff f0 	sub	r12,r5,-16
8000530a:	f0 1f 00 08 	mcall	80005328 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000530e:	ea cc ff dc 	sub	r12,r5,-36
80005312:	f0 1f 00 06 	mcall	80005328 <xQueueCreate+0x6c>
80005316:	0a 9c       	mov	r12,r5
80005318:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000531a:	0a 9c       	mov	r12,r5
8000531c:	f0 1f 00 04 	mcall	8000532c <xQueueCreate+0x70>
80005320:	d8 2a       	popm	r4-r7,pc,r12=0
80005322:	d8 2a       	popm	r4-r7,pc,r12=0
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	4e 68       	lddpc	r8,800054bc <vTaskPriorityInherit+0x78>
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	4a d8       	lddpc	r8,800053dc <vTaskMissedYield+0x8>
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	4e 40       	lddpc	r0,800054bc <vTaskPriorityInherit+0x78>

80005330 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005330:	48 38       	lddpc	r8,8000533c <vTaskSuspendAll+0xc>
80005332:	70 09       	ld.w	r9,r8[0x0]
80005334:	2f f9       	sub	r9,-1
80005336:	91 09       	st.w	r8[0x0],r9
}
80005338:	5e fc       	retal	r12
8000533a:	00 00       	add	r0,r0
8000533c:	00 00       	add	r0,r0
8000533e:	0d 0c       	ld.w	r12,r6++

80005340 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005340:	49 a8       	lddpc	r8,800053a8 <vTaskSwitchContext+0x68>
80005342:	70 08       	ld.w	r8,r8[0x0]
80005344:	58 08       	cp.w	r8,0
80005346:	c0 b1       	brne	8000535c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005348:	49 98       	lddpc	r8,800053ac <vTaskSwitchContext+0x6c>
8000534a:	70 08       	ld.w	r8,r8[0x0]
8000534c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005350:	49 89       	lddpc	r9,800053b0 <vTaskSwitchContext+0x70>
80005352:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005356:	58 08       	cp.w	r8,0
80005358:	c0 60       	breq	80005364 <vTaskSwitchContext+0x24>
8000535a:	c1 18       	rjmp	8000537c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000535c:	30 19       	mov	r9,1
8000535e:	49 68       	lddpc	r8,800053b4 <vTaskSwitchContext+0x74>
80005360:	91 09       	st.w	r8[0x0],r9
80005362:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005364:	49 28       	lddpc	r8,800053ac <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005366:	49 3a       	lddpc	r10,800053b0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005368:	70 09       	ld.w	r9,r8[0x0]
8000536a:	20 19       	sub	r9,1
8000536c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000536e:	70 09       	ld.w	r9,r8[0x0]
80005370:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005374:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005378:	58 09       	cp.w	r9,0
8000537a:	cf 70       	breq	80005368 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000537c:	48 c8       	lddpc	r8,800053ac <vTaskSwitchContext+0x6c>
8000537e:	70 08       	ld.w	r8,r8[0x0]
80005380:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005384:	48 b9       	lddpc	r9,800053b0 <vTaskSwitchContext+0x70>
80005386:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000538a:	70 19       	ld.w	r9,r8[0x4]
8000538c:	72 19       	ld.w	r9,r9[0x4]
8000538e:	91 19       	st.w	r8[0x4],r9
80005390:	f0 ca ff f8 	sub	r10,r8,-8
80005394:	14 39       	cp.w	r9,r10
80005396:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000539a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000539e:	70 18       	ld.w	r8,r8[0x4]
800053a0:	70 39       	ld.w	r9,r8[0xc]
800053a2:	48 68       	lddpc	r8,800053b8 <vTaskSwitchContext+0x78>
800053a4:	91 09       	st.w	r8[0x0],r9
800053a6:	5e fc       	retal	r12
800053a8:	00 00       	add	r0,r0
800053aa:	0d 0c       	ld.w	r12,r6++
800053ac:	00 00       	add	r0,r0
800053ae:	0d 44       	ld.w	r4,--r6
800053b0:	00 00       	add	r0,r0
800053b2:	0c 28       	rsub	r8,r6
800053b4:	00 00       	add	r0,r0
800053b6:	0d 2c       	ld.uh	r12,r6++
800053b8:	00 00       	add	r0,r0
800053ba:	0c dc       	st.w	--r6,r12

800053bc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800053bc:	48 48       	lddpc	r8,800053cc <vTaskSetTimeOutState+0x10>
800053be:	70 08       	ld.w	r8,r8[0x0]
800053c0:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800053c2:	48 48       	lddpc	r8,800053d0 <vTaskSetTimeOutState+0x14>
800053c4:	70 08       	ld.w	r8,r8[0x0]
800053c6:	99 18       	st.w	r12[0x4],r8
}
800053c8:	5e fc       	retal	r12
800053ca:	00 00       	add	r0,r0
800053cc:	00 00       	add	r0,r0
800053ce:	0c 20       	rsub	r0,r6
800053d0:	00 00       	add	r0,r0
800053d2:	0d 08       	ld.w	r8,r6++

800053d4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800053d4:	30 19       	mov	r9,1
800053d6:	48 28       	lddpc	r8,800053dc <vTaskMissedYield+0x8>
800053d8:	91 09       	st.w	r8[0x0],r9
}
800053da:	5e fc       	retal	r12
800053dc:	00 00       	add	r0,r0
800053de:	0d 2c       	ld.uh	r12,r6++

800053e0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800053e0:	48 28       	lddpc	r8,800053e8 <xTaskGetCurrentTaskHandle+0x8>
800053e2:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800053e4:	5e fc       	retal	r12
800053e6:	00 00       	add	r0,r0
800053e8:	00 00       	add	r0,r0
800053ea:	0c dc       	st.w	--r6,r12

800053ec <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800053ec:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800053f0:	58 0c       	cp.w	r12,0
800053f2:	c1 f0       	breq	80005430 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800053f4:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800053f6:	78 b9       	ld.w	r9,r12[0x2c]
800053f8:	79 18       	ld.w	r8,r12[0x44]
800053fa:	10 39       	cp.w	r9,r8
800053fc:	c1 a0       	breq	80005430 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800053fe:	f8 c6 ff fc 	sub	r6,r12,-4
80005402:	0c 9c       	mov	r12,r6
80005404:	f0 1f 00 0c 	mcall	80005434 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005408:	6f 1c       	ld.w	r12,r7[0x44]
8000540a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000540c:	f8 08 11 08 	rsub	r8,r12,8
80005410:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005412:	48 a8       	lddpc	r8,80005438 <vTaskPriorityDisinherit+0x4c>
80005414:	70 08       	ld.w	r8,r8[0x0]
80005416:	10 3c       	cp.w	r12,r8
80005418:	e0 88 00 04 	brls	80005420 <vTaskPriorityDisinherit+0x34>
8000541c:	48 78       	lddpc	r8,80005438 <vTaskPriorityDisinherit+0x4c>
8000541e:	91 0c       	st.w	r8[0x0],r12
80005420:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005424:	0c 9b       	mov	r11,r6
80005426:	48 68       	lddpc	r8,8000543c <vTaskPriorityDisinherit+0x50>
80005428:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000542c:	f0 1f 00 05 	mcall	80005440 <vTaskPriorityDisinherit+0x54>
80005430:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	4b 42       	lddpc	r2,80005504 <xTaskRemoveFromEventList+0x3c>
80005438:	00 00       	add	r0,r0
8000543a:	0d 44       	ld.w	r4,--r6
8000543c:	00 00       	add	r0,r0
8000543e:	0c 28       	rsub	r8,r6
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	4a f2       	lddpc	r2,800054fc <xTaskRemoveFromEventList+0x34>

80005444 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005444:	eb cd 40 c0 	pushm	r6-r7,lr
80005448:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000544a:	49 b8       	lddpc	r8,800054b4 <vTaskPriorityInherit+0x70>
8000544c:	70 08       	ld.w	r8,r8[0x0]
8000544e:	78 b9       	ld.w	r9,r12[0x2c]
80005450:	70 b8       	ld.w	r8,r8[0x2c]
80005452:	10 39       	cp.w	r9,r8
80005454:	c2 d2       	brcc	800054ae <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005456:	49 88       	lddpc	r8,800054b4 <vTaskPriorityInherit+0x70>
80005458:	70 08       	ld.w	r8,r8[0x0]
8000545a:	70 b8       	ld.w	r8,r8[0x2c]
8000545c:	f0 08 11 08 	rsub	r8,r8,8
80005460:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005462:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005466:	49 59       	lddpc	r9,800054b8 <vTaskPriorityInherit+0x74>
80005468:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000546c:	78 59       	ld.w	r9,r12[0x14]
8000546e:	10 39       	cp.w	r9,r8
80005470:	c1 b1       	brne	800054a6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005472:	f8 c6 ff fc 	sub	r6,r12,-4
80005476:	0c 9c       	mov	r12,r6
80005478:	f0 1f 00 11 	mcall	800054bc <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000547c:	48 e8       	lddpc	r8,800054b4 <vTaskPriorityInherit+0x70>
8000547e:	70 08       	ld.w	r8,r8[0x0]
80005480:	70 bc       	ld.w	r12,r8[0x2c]
80005482:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005484:	48 f8       	lddpc	r8,800054c0 <vTaskPriorityInherit+0x7c>
80005486:	70 08       	ld.w	r8,r8[0x0]
80005488:	10 3c       	cp.w	r12,r8
8000548a:	e0 88 00 04 	brls	80005492 <vTaskPriorityInherit+0x4e>
8000548e:	48 d8       	lddpc	r8,800054c0 <vTaskPriorityInherit+0x7c>
80005490:	91 0c       	st.w	r8[0x0],r12
80005492:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005496:	0c 9b       	mov	r11,r6
80005498:	48 88       	lddpc	r8,800054b8 <vTaskPriorityInherit+0x74>
8000549a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000549e:	f0 1f 00 0a 	mcall	800054c4 <vTaskPriorityInherit+0x80>
800054a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800054a6:	48 48       	lddpc	r8,800054b4 <vTaskPriorityInherit+0x70>
800054a8:	70 08       	ld.w	r8,r8[0x0]
800054aa:	70 b8       	ld.w	r8,r8[0x2c]
800054ac:	99 b8       	st.w	r12[0x2c],r8
800054ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054b2:	00 00       	add	r0,r0
800054b4:	00 00       	add	r0,r0
800054b6:	0c dc       	st.w	--r6,r12
800054b8:	00 00       	add	r0,r0
800054ba:	0c 28       	rsub	r8,r6
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	4b 42       	lddpc	r2,8000558c <vTaskIncrementTick+0x48>
800054c0:	00 00       	add	r0,r0
800054c2:	0d 44       	ld.w	r4,--r6
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	4a f2       	lddpc	r2,80005580 <vTaskIncrementTick+0x3c>

800054c8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800054c8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800054cc:	78 38       	ld.w	r8,r12[0xc]
800054ce:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800054d0:	ee c6 ff e8 	sub	r6,r7,-24
800054d4:	0c 9c       	mov	r12,r6
800054d6:	f0 1f 00 15 	mcall	80005528 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800054da:	49 58       	lddpc	r8,8000552c <xTaskRemoveFromEventList+0x64>
800054dc:	70 08       	ld.w	r8,r8[0x0]
800054de:	58 08       	cp.w	r8,0
800054e0:	c1 71       	brne	8000550e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800054e2:	ee c6 ff fc 	sub	r6,r7,-4
800054e6:	0c 9c       	mov	r12,r6
800054e8:	f0 1f 00 10 	mcall	80005528 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800054ec:	6e bc       	ld.w	r12,r7[0x2c]
800054ee:	49 18       	lddpc	r8,80005530 <xTaskRemoveFromEventList+0x68>
800054f0:	70 08       	ld.w	r8,r8[0x0]
800054f2:	10 3c       	cp.w	r12,r8
800054f4:	e0 88 00 04 	brls	800054fc <xTaskRemoveFromEventList+0x34>
800054f8:	48 e8       	lddpc	r8,80005530 <xTaskRemoveFromEventList+0x68>
800054fa:	91 0c       	st.w	r8[0x0],r12
800054fc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005500:	0c 9b       	mov	r11,r6
80005502:	48 d8       	lddpc	r8,80005534 <xTaskRemoveFromEventList+0x6c>
80005504:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005508:	f0 1f 00 0c 	mcall	80005538 <xTaskRemoveFromEventList+0x70>
8000550c:	c0 58       	rjmp	80005516 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000550e:	0c 9b       	mov	r11,r6
80005510:	48 bc       	lddpc	r12,8000553c <xTaskRemoveFromEventList+0x74>
80005512:	f0 1f 00 0a 	mcall	80005538 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005516:	48 b8       	lddpc	r8,80005540 <xTaskRemoveFromEventList+0x78>
80005518:	70 08       	ld.w	r8,r8[0x0]
8000551a:	6e b9       	ld.w	r9,r7[0x2c]
8000551c:	70 b8       	ld.w	r8,r8[0x2c]
8000551e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005520:	5f 2c       	srhs	r12
80005522:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005526:	00 00       	add	r0,r0
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	4b 42       	lddpc	r2,800055f8 <vTaskIncrementTick+0xb4>
8000552c:	00 00       	add	r0,r0
8000552e:	0d 0c       	ld.w	r12,r6++
80005530:	00 00       	add	r0,r0
80005532:	0d 44       	ld.w	r4,--r6
80005534:	00 00       	add	r0,r0
80005536:	0c 28       	rsub	r8,r6
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	4a f2       	lddpc	r2,800055f4 <vTaskIncrementTick+0xb0>
8000553c:	00 00       	add	r0,r0
8000553e:	0c e0       	st.h	--r6,r0
80005540:	00 00       	add	r0,r0
80005542:	0c dc       	st.w	--r6,r12

80005544 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005544:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005548:	4b 98       	lddpc	r8,8000562c <vTaskIncrementTick+0xe8>
8000554a:	70 08       	ld.w	r8,r8[0x0]
8000554c:	58 08       	cp.w	r8,0
8000554e:	c6 91       	brne	80005620 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005550:	4b 88       	lddpc	r8,80005630 <vTaskIncrementTick+0xec>
80005552:	70 09       	ld.w	r9,r8[0x0]
80005554:	2f f9       	sub	r9,-1
80005556:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005558:	70 08       	ld.w	r8,r8[0x0]
8000555a:	58 08       	cp.w	r8,0
8000555c:	c1 a1       	brne	80005590 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000555e:	4b 68       	lddpc	r8,80005634 <vTaskIncrementTick+0xf0>
80005560:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005562:	4b 69       	lddpc	r9,80005638 <vTaskIncrementTick+0xf4>
80005564:	72 0b       	ld.w	r11,r9[0x0]
80005566:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005568:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000556a:	4b 59       	lddpc	r9,8000563c <vTaskIncrementTick+0xf8>
8000556c:	72 0a       	ld.w	r10,r9[0x0]
8000556e:	2f fa       	sub	r10,-1
80005570:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005572:	70 08       	ld.w	r8,r8[0x0]
80005574:	70 08       	ld.w	r8,r8[0x0]
80005576:	58 08       	cp.w	r8,0
80005578:	c0 51       	brne	80005582 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000557a:	3f f9       	mov	r9,-1
8000557c:	4b 18       	lddpc	r8,80005640 <vTaskIncrementTick+0xfc>
8000557e:	91 09       	st.w	r8[0x0],r9
80005580:	c0 88       	rjmp	80005590 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005582:	4a d8       	lddpc	r8,80005634 <vTaskIncrementTick+0xf0>
80005584:	70 08       	ld.w	r8,r8[0x0]
80005586:	70 38       	ld.w	r8,r8[0xc]
80005588:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000558a:	70 19       	ld.w	r9,r8[0x4]
8000558c:	4a d8       	lddpc	r8,80005640 <vTaskIncrementTick+0xfc>
8000558e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005590:	4a 88       	lddpc	r8,80005630 <vTaskIncrementTick+0xec>
80005592:	70 09       	ld.w	r9,r8[0x0]
80005594:	4a b8       	lddpc	r8,80005640 <vTaskIncrementTick+0xfc>
80005596:	70 08       	ld.w	r8,r8[0x0]
80005598:	10 39       	cp.w	r9,r8
8000559a:	c4 73       	brcs	80005628 <vTaskIncrementTick+0xe4>
8000559c:	4a 68       	lddpc	r8,80005634 <vTaskIncrementTick+0xf0>
8000559e:	70 08       	ld.w	r8,r8[0x0]
800055a0:	70 08       	ld.w	r8,r8[0x0]
800055a2:	58 08       	cp.w	r8,0
800055a4:	c0 c0       	breq	800055bc <vTaskIncrementTick+0x78>
800055a6:	4a 48       	lddpc	r8,80005634 <vTaskIncrementTick+0xf0>
800055a8:	70 08       	ld.w	r8,r8[0x0]
800055aa:	70 38       	ld.w	r8,r8[0xc]
800055ac:	70 37       	ld.w	r7,r8[0xc]
800055ae:	6e 18       	ld.w	r8,r7[0x4]
800055b0:	4a 09       	lddpc	r9,80005630 <vTaskIncrementTick+0xec>
800055b2:	72 09       	ld.w	r9,r9[0x0]
800055b4:	12 38       	cp.w	r8,r9
800055b6:	e0 88 00 14 	brls	800055de <vTaskIncrementTick+0x9a>
800055ba:	c0 e8       	rjmp	800055d6 <vTaskIncrementTick+0x92>
800055bc:	3f f9       	mov	r9,-1
800055be:	4a 18       	lddpc	r8,80005640 <vTaskIncrementTick+0xfc>
800055c0:	91 09       	st.w	r8[0x0],r9
800055c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800055c6:	6a 08       	ld.w	r8,r5[0x0]
800055c8:	70 38       	ld.w	r8,r8[0xc]
800055ca:	70 37       	ld.w	r7,r8[0xc]
800055cc:	6e 18       	ld.w	r8,r7[0x4]
800055ce:	64 09       	ld.w	r9,r2[0x0]
800055d0:	12 38       	cp.w	r8,r9
800055d2:	e0 88 00 0a 	brls	800055e6 <vTaskIncrementTick+0xa2>
800055d6:	49 b9       	lddpc	r9,80005640 <vTaskIncrementTick+0xfc>
800055d8:	93 08       	st.w	r9[0x0],r8
800055da:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800055de:	49 a4       	lddpc	r4,80005644 <vTaskIncrementTick+0x100>
800055e0:	49 a3       	lddpc	r3,80005648 <vTaskIncrementTick+0x104>
800055e2:	49 55       	lddpc	r5,80005634 <vTaskIncrementTick+0xf0>
800055e4:	49 32       	lddpc	r2,80005630 <vTaskIncrementTick+0xec>
800055e6:	ee c6 ff fc 	sub	r6,r7,-4
800055ea:	0c 9c       	mov	r12,r6
800055ec:	f0 1f 00 18 	mcall	8000564c <vTaskIncrementTick+0x108>
800055f0:	6e a8       	ld.w	r8,r7[0x28]
800055f2:	58 08       	cp.w	r8,0
800055f4:	c0 50       	breq	800055fe <vTaskIncrementTick+0xba>
800055f6:	ee cc ff e8 	sub	r12,r7,-24
800055fa:	f0 1f 00 15 	mcall	8000564c <vTaskIncrementTick+0x108>
800055fe:	6e bc       	ld.w	r12,r7[0x2c]
80005600:	68 08       	ld.w	r8,r4[0x0]
80005602:	10 3c       	cp.w	r12,r8
80005604:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005608:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000560c:	0c 9b       	mov	r11,r6
8000560e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005612:	f0 1f 00 10 	mcall	80005650 <vTaskIncrementTick+0x10c>
80005616:	6a 08       	ld.w	r8,r5[0x0]
80005618:	70 08       	ld.w	r8,r8[0x0]
8000561a:	58 08       	cp.w	r8,0
8000561c:	cd 51       	brne	800055c6 <vTaskIncrementTick+0x82>
8000561e:	cc fb       	rjmp	800055bc <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005620:	48 d8       	lddpc	r8,80005654 <vTaskIncrementTick+0x110>
80005622:	70 09       	ld.w	r9,r8[0x0]
80005624:	2f f9       	sub	r9,-1
80005626:	91 09       	st.w	r8[0x0],r9
80005628:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000562c:	00 00       	add	r0,r0
8000562e:	0d 0c       	ld.w	r12,r6++
80005630:	00 00       	add	r0,r0
80005632:	0d 08       	ld.w	r8,r6++
80005634:	00 00       	add	r0,r0
80005636:	0c 14       	sub	r4,r6
80005638:	00 00       	add	r0,r0
8000563a:	0c 24       	rsub	r4,r6
8000563c:	00 00       	add	r0,r0
8000563e:	0c 20       	rsub	r0,r6
80005640:	00 00       	add	r0,r0
80005642:	05 2c       	ld.uh	r12,r2++
80005644:	00 00       	add	r0,r0
80005646:	0d 44       	ld.w	r4,--r6
80005648:	00 00       	add	r0,r0
8000564a:	0c 28       	rsub	r8,r6
8000564c:	80 00       	ld.sh	r0,r0[0x0]
8000564e:	4b 42       	lddpc	r2,8000571c <xTaskResumeAll+0x30>
80005650:	80 00       	ld.sh	r0,r0[0x0]
80005652:	4a f2       	lddpc	r2,8000570c <xTaskResumeAll+0x20>
80005654:	00 00       	add	r0,r0
80005656:	0c 0c       	add	r12,r6

80005658 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005658:	eb cd 40 c0 	pushm	r6-r7,lr
8000565c:	18 97       	mov	r7,r12
8000565e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005660:	f0 1f 00 15 	mcall	800056b4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005664:	6c 08       	ld.w	r8,r6[0x0]
80005666:	5b f8       	cp.w	r8,-1
80005668:	c0 31       	brne	8000566e <xTaskCheckForTimeOut+0x16>
8000566a:	30 07       	mov	r7,0
8000566c:	c1 f8       	rjmp	800056aa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000566e:	49 39       	lddpc	r9,800056b8 <xTaskCheckForTimeOut+0x60>
80005670:	72 09       	ld.w	r9,r9[0x0]
80005672:	6e 0a       	ld.w	r10,r7[0x0]
80005674:	12 3a       	cp.w	r10,r9
80005676:	c0 70       	breq	80005684 <xTaskCheckForTimeOut+0x2c>
80005678:	49 19       	lddpc	r9,800056bc <xTaskCheckForTimeOut+0x64>
8000567a:	72 09       	ld.w	r9,r9[0x0]
8000567c:	6e 1a       	ld.w	r10,r7[0x4]
8000567e:	12 3a       	cp.w	r10,r9
80005680:	e0 88 00 14 	brls	800056a8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005684:	48 e9       	lddpc	r9,800056bc <xTaskCheckForTimeOut+0x64>
80005686:	72 0a       	ld.w	r10,r9[0x0]
80005688:	6e 19       	ld.w	r9,r7[0x4]
8000568a:	12 1a       	sub	r10,r9
8000568c:	14 38       	cp.w	r8,r10
8000568e:	e0 88 00 0d 	brls	800056a8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005692:	48 ba       	lddpc	r10,800056bc <xTaskCheckForTimeOut+0x64>
80005694:	74 0a       	ld.w	r10,r10[0x0]
80005696:	14 19       	sub	r9,r10
80005698:	f2 08 00 08 	add	r8,r9,r8
8000569c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000569e:	0e 9c       	mov	r12,r7
800056a0:	f0 1f 00 08 	mcall	800056c0 <xTaskCheckForTimeOut+0x68>
800056a4:	30 07       	mov	r7,0
800056a6:	c0 28       	rjmp	800056aa <xTaskCheckForTimeOut+0x52>
800056a8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800056aa:	f0 1f 00 07 	mcall	800056c4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800056ae:	0e 9c       	mov	r12,r7
800056b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	4b fc       	lddpc	r12,800057b0 <xTaskResumeAll+0xc4>
800056b8:	00 00       	add	r0,r0
800056ba:	0c 20       	rsub	r0,r6
800056bc:	00 00       	add	r0,r0
800056be:	0d 08       	ld.w	r8,r6++
800056c0:	80 00       	ld.sh	r0,r0[0x0]
800056c2:	53 bc       	stdsp	sp[0xec],r12
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	4d 08       	lddpc	r8,80005804 <prvAddCurrentTaskToDelayedList+0x30>

800056c8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800056c8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800056cc:	f0 1f 00 05 	mcall	800056e0 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800056d0:	48 58       	lddpc	r8,800056e4 <xTaskGetTickCount+0x1c>
800056d2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800056d4:	f0 1f 00 05 	mcall	800056e8 <xTaskGetTickCount+0x20>

	return xTicks;
}
800056d8:	0e 9c       	mov	r12,r7
800056da:	e3 cd 80 80 	ldm	sp++,r7,pc
800056de:	00 00       	add	r0,r0
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	4b fc       	lddpc	r12,800057dc <prvAddCurrentTaskToDelayedList+0x8>
800056e4:	00 00       	add	r0,r0
800056e6:	0d 08       	ld.w	r8,r6++
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	4d 08       	lddpc	r8,80005828 <prvAddCurrentTaskToDelayedList+0x54>

800056ec <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800056ec:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800056f0:	f0 1f 00 2c 	mcall	800057a0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800056f4:	4a c8       	lddpc	r8,800057a4 <xTaskResumeAll+0xb8>
800056f6:	70 09       	ld.w	r9,r8[0x0]
800056f8:	20 19       	sub	r9,1
800056fa:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800056fc:	70 08       	ld.w	r8,r8[0x0]
800056fe:	58 08       	cp.w	r8,0
80005700:	c4 91       	brne	80005792 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005702:	4a a8       	lddpc	r8,800057a8 <xTaskResumeAll+0xbc>
80005704:	70 08       	ld.w	r8,r8[0x0]
80005706:	58 08       	cp.w	r8,0
80005708:	c4 50       	breq	80005792 <xTaskResumeAll+0xa6>
8000570a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000570c:	4a 85       	lddpc	r5,800057ac <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000570e:	4a 93       	lddpc	r3,800057b0 <xTaskResumeAll+0xc4>
80005710:	4a 92       	lddpc	r2,800057b4 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005712:	4a a1       	lddpc	r1,800057b8 <xTaskResumeAll+0xcc>
80005714:	c1 e8       	rjmp	80005750 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005716:	6a 38       	ld.w	r8,r5[0xc]
80005718:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000571a:	ee cc ff e8 	sub	r12,r7,-24
8000571e:	f0 1f 00 28 	mcall	800057bc <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005722:	ee c6 ff fc 	sub	r6,r7,-4
80005726:	0c 9c       	mov	r12,r6
80005728:	f0 1f 00 25 	mcall	800057bc <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000572c:	6e bc       	ld.w	r12,r7[0x2c]
8000572e:	66 08       	ld.w	r8,r3[0x0]
80005730:	10 3c       	cp.w	r12,r8
80005732:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005736:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000573a:	0c 9b       	mov	r11,r6
8000573c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005740:	f0 1f 00 20 	mcall	800057c0 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005744:	62 08       	ld.w	r8,r1[0x0]
80005746:	6e b9       	ld.w	r9,r7[0x2c]
80005748:	70 b8       	ld.w	r8,r8[0x2c]
8000574a:	10 39       	cp.w	r9,r8
8000574c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005750:	6a 08       	ld.w	r8,r5[0x0]
80005752:	58 08       	cp.w	r8,0
80005754:	ce 11       	brne	80005716 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005756:	49 c8       	lddpc	r8,800057c4 <xTaskResumeAll+0xd8>
80005758:	70 08       	ld.w	r8,r8[0x0]
8000575a:	58 08       	cp.w	r8,0
8000575c:	c0 f0       	breq	8000577a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000575e:	49 a8       	lddpc	r8,800057c4 <xTaskResumeAll+0xd8>
80005760:	70 08       	ld.w	r8,r8[0x0]
80005762:	58 08       	cp.w	r8,0
80005764:	c1 10       	breq	80005786 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005766:	49 87       	lddpc	r7,800057c4 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005768:	f0 1f 00 18 	mcall	800057c8 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000576c:	6e 08       	ld.w	r8,r7[0x0]
8000576e:	20 18       	sub	r8,1
80005770:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005772:	6e 08       	ld.w	r8,r7[0x0]
80005774:	58 08       	cp.w	r8,0
80005776:	cf 91       	brne	80005768 <xTaskResumeAll+0x7c>
80005778:	c0 78       	rjmp	80005786 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000577a:	58 14       	cp.w	r4,1
8000577c:	c0 50       	breq	80005786 <xTaskResumeAll+0x9a>
8000577e:	49 48       	lddpc	r8,800057cc <xTaskResumeAll+0xe0>
80005780:	70 08       	ld.w	r8,r8[0x0]
80005782:	58 18       	cp.w	r8,1
80005784:	c0 71       	brne	80005792 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005786:	30 09       	mov	r9,0
80005788:	49 18       	lddpc	r8,800057cc <xTaskResumeAll+0xe0>
8000578a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000578c:	d7 33       	scall
8000578e:	30 17       	mov	r7,1
80005790:	c0 28       	rjmp	80005794 <xTaskResumeAll+0xa8>
80005792:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005794:	f0 1f 00 0f 	mcall	800057d0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005798:	0e 9c       	mov	r12,r7
8000579a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000579e:	00 00       	add	r0,r0
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	4b fc       	lddpc	r12,8000589c <vTaskDelayUntil+0x6c>
800057a4:	00 00       	add	r0,r0
800057a6:	0d 0c       	ld.w	r12,r6++
800057a8:	00 00       	add	r0,r0
800057aa:	0d 28       	ld.uh	r8,r6++
800057ac:	00 00       	add	r0,r0
800057ae:	0c e0       	st.h	--r6,r0
800057b0:	00 00       	add	r0,r0
800057b2:	0d 44       	ld.w	r4,--r6
800057b4:	00 00       	add	r0,r0
800057b6:	0c 28       	rsub	r8,r6
800057b8:	00 00       	add	r0,r0
800057ba:	0c dc       	st.w	--r6,r12
800057bc:	80 00       	ld.sh	r0,r0[0x0]
800057be:	4b 42       	lddpc	r2,8000588c <vTaskDelayUntil+0x5c>
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	4a f2       	lddpc	r2,8000587c <vTaskDelayUntil+0x4c>
800057c4:	00 00       	add	r0,r0
800057c6:	0c 0c       	add	r12,r6
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	55 44       	stdsp	sp[0x150],r4
800057cc:	00 00       	add	r0,r0
800057ce:	0d 2c       	ld.uh	r12,r6++
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	4d 08       	lddpc	r8,80005910 <prvIdleTask+0x8>

800057d4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800057d4:	eb cd 40 80 	pushm	r7,lr
800057d8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800057da:	49 08       	lddpc	r8,80005818 <prvAddCurrentTaskToDelayedList+0x44>
800057dc:	70 08       	ld.w	r8,r8[0x0]
800057de:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800057e0:	48 f8       	lddpc	r8,8000581c <prvAddCurrentTaskToDelayedList+0x48>
800057e2:	70 08       	ld.w	r8,r8[0x0]
800057e4:	10 3c       	cp.w	r12,r8
800057e6:	c0 a2       	brcc	800057fa <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057e8:	48 c8       	lddpc	r8,80005818 <prvAddCurrentTaskToDelayedList+0x44>
800057ea:	70 0b       	ld.w	r11,r8[0x0]
800057ec:	48 d8       	lddpc	r8,80005820 <prvAddCurrentTaskToDelayedList+0x4c>
800057ee:	70 0c       	ld.w	r12,r8[0x0]
800057f0:	2f cb       	sub	r11,-4
800057f2:	f0 1f 00 0d 	mcall	80005824 <prvAddCurrentTaskToDelayedList+0x50>
800057f6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057fa:	48 88       	lddpc	r8,80005818 <prvAddCurrentTaskToDelayedList+0x44>
800057fc:	70 0b       	ld.w	r11,r8[0x0]
800057fe:	48 b8       	lddpc	r8,80005828 <prvAddCurrentTaskToDelayedList+0x54>
80005800:	70 0c       	ld.w	r12,r8[0x0]
80005802:	2f cb       	sub	r11,-4
80005804:	f0 1f 00 08 	mcall	80005824 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005808:	48 98       	lddpc	r8,8000582c <prvAddCurrentTaskToDelayedList+0x58>
8000580a:	70 08       	ld.w	r8,r8[0x0]
8000580c:	10 37       	cp.w	r7,r8
8000580e:	c0 32       	brcc	80005814 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005810:	48 78       	lddpc	r8,8000582c <prvAddCurrentTaskToDelayedList+0x58>
80005812:	91 07       	st.w	r8[0x0],r7
80005814:	e3 cd 80 80 	ldm	sp++,r7,pc
80005818:	00 00       	add	r0,r0
8000581a:	0c dc       	st.w	--r6,r12
8000581c:	00 00       	add	r0,r0
8000581e:	0d 08       	ld.w	r8,r6++
80005820:	00 00       	add	r0,r0
80005822:	0c 24       	rsub	r4,r6
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	4b 0e       	lddpc	lr,800058e4 <vTaskPlaceOnEventList+0x34>
80005828:	00 00       	add	r0,r0
8000582a:	0c 14       	sub	r4,r6
8000582c:	00 00       	add	r0,r0
8000582e:	05 2c       	ld.uh	r12,r2++

80005830 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005830:	eb cd 40 c0 	pushm	r6-r7,lr
80005834:	18 96       	mov	r6,r12
80005836:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005838:	f0 1f 00 18 	mcall	80005898 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000583c:	6c 08       	ld.w	r8,r6[0x0]
8000583e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005840:	49 79       	lddpc	r9,8000589c <vTaskDelayUntil+0x6c>
80005842:	72 09       	ld.w	r9,r9[0x0]
80005844:	12 38       	cp.w	r8,r9
80005846:	e0 88 00 0c 	brls	8000585e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000584a:	0e 38       	cp.w	r8,r7
8000584c:	e0 88 00 22 	brls	80005890 <vTaskDelayUntil+0x60>
80005850:	49 38       	lddpc	r8,8000589c <vTaskDelayUntil+0x6c>
80005852:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005854:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005856:	10 37       	cp.w	r7,r8
80005858:	e0 88 00 14 	brls	80005880 <vTaskDelayUntil+0x50>
8000585c:	c0 a8       	rjmp	80005870 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000585e:	0e 38       	cp.w	r8,r7
80005860:	e0 8b 00 16 	brhi	8000588c <vTaskDelayUntil+0x5c>
80005864:	48 e8       	lddpc	r8,8000589c <vTaskDelayUntil+0x6c>
80005866:	70 08       	ld.w	r8,r8[0x0]
80005868:	10 37       	cp.w	r7,r8
8000586a:	e0 8b 00 11 	brhi	8000588c <vTaskDelayUntil+0x5c>
8000586e:	c1 18       	rjmp	80005890 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005870:	48 c8       	lddpc	r8,800058a0 <vTaskDelayUntil+0x70>
80005872:	70 0c       	ld.w	r12,r8[0x0]
80005874:	2f cc       	sub	r12,-4
80005876:	f0 1f 00 0c 	mcall	800058a4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000587a:	0e 9c       	mov	r12,r7
8000587c:	f0 1f 00 0b 	mcall	800058a8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005880:	f0 1f 00 0b 	mcall	800058ac <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005884:	c0 81       	brne	80005894 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005886:	d7 33       	scall
80005888:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000588c:	8d 07       	st.w	r6[0x0],r7
8000588e:	cf 1b       	rjmp	80005870 <vTaskDelayUntil+0x40>
80005890:	8d 07       	st.w	r6[0x0],r7
80005892:	cf 7b       	rjmp	80005880 <vTaskDelayUntil+0x50>
80005894:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	53 30       	stdsp	sp[0xcc],r0
8000589c:	00 00       	add	r0,r0
8000589e:	0d 08       	ld.w	r8,r6++
800058a0:	00 00       	add	r0,r0
800058a2:	0c dc       	st.w	--r6,r12
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	4b 42       	lddpc	r2,80005974 <prvIdleTask+0x6c>
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	57 d4       	stdsp	sp[0x1f4],r4
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	56 ec       	stdsp	sp[0x1b8],r12

800058b0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800058b0:	eb cd 40 c0 	pushm	r6-r7,lr
800058b4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800058b6:	48 e7       	lddpc	r7,800058ec <vTaskPlaceOnEventList+0x3c>
800058b8:	6e 0b       	ld.w	r11,r7[0x0]
800058ba:	2e 8b       	sub	r11,-24
800058bc:	f0 1f 00 0d 	mcall	800058f0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800058c0:	6e 0c       	ld.w	r12,r7[0x0]
800058c2:	2f cc       	sub	r12,-4
800058c4:	f0 1f 00 0c 	mcall	800058f4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800058c8:	5b f6       	cp.w	r6,-1
800058ca:	c0 81       	brne	800058da <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800058cc:	6e 0b       	ld.w	r11,r7[0x0]
800058ce:	2f cb       	sub	r11,-4
800058d0:	48 ac       	lddpc	r12,800058f8 <vTaskPlaceOnEventList+0x48>
800058d2:	f0 1f 00 0b 	mcall	800058fc <vTaskPlaceOnEventList+0x4c>
800058d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800058da:	48 a8       	lddpc	r8,80005900 <vTaskPlaceOnEventList+0x50>
800058dc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800058de:	ec 0c 00 0c 	add	r12,r6,r12
800058e2:	f0 1f 00 09 	mcall	80005904 <vTaskPlaceOnEventList+0x54>
800058e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058ea:	00 00       	add	r0,r0
800058ec:	00 00       	add	r0,r0
800058ee:	0c dc       	st.w	--r6,r12
800058f0:	80 00       	ld.sh	r0,r0[0x0]
800058f2:	4b 0e       	lddpc	lr,800059b0 <xTaskGenericCreate+0x20>
800058f4:	80 00       	ld.sh	r0,r0[0x0]
800058f6:	4b 42       	lddpc	r2,800059c4 <xTaskGenericCreate+0x34>
800058f8:	00 00       	add	r0,r0
800058fa:	0d 30       	ld.ub	r0,r6++
800058fc:	80 00       	ld.sh	r0,r0[0x0]
800058fe:	4a f2       	lddpc	r2,800059b8 <xTaskGenericCreate+0x28>
80005900:	00 00       	add	r0,r0
80005902:	0d 08       	ld.w	r8,r6++
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	57 d4       	stdsp	sp[0x1f4],r4

80005908 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005908:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000590c:	49 67       	lddpc	r7,80005964 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000590e:	49 74       	lddpc	r4,80005968 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005910:	49 73       	lddpc	r3,8000596c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005912:	49 85       	lddpc	r5,80005970 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005914:	6e 08       	ld.w	r8,r7[0x0]
80005916:	58 08       	cp.w	r8,0
80005918:	c1 e0       	breq	80005954 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000591a:	f0 1f 00 17 	mcall	80005974 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000591e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005920:	f0 1f 00 16 	mcall	80005978 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005924:	58 06       	cp.w	r6,0
80005926:	c1 70       	breq	80005954 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005928:	f0 1f 00 15 	mcall	8000597c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000592c:	68 38       	ld.w	r8,r4[0xc]
8000592e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005930:	ec cc ff fc 	sub	r12,r6,-4
80005934:	f0 1f 00 13 	mcall	80005980 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005938:	66 08       	ld.w	r8,r3[0x0]
8000593a:	20 18       	sub	r8,1
8000593c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000593e:	6e 08       	ld.w	r8,r7[0x0]
80005940:	20 18       	sub	r8,1
80005942:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005944:	f0 1f 00 10 	mcall	80005984 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005948:	6c cc       	ld.w	r12,r6[0x30]
8000594a:	f0 1f 00 10 	mcall	80005988 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000594e:	0c 9c       	mov	r12,r6
80005950:	f0 1f 00 0e 	mcall	80005988 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005954:	6a 08       	ld.w	r8,r5[0x0]
80005956:	58 18       	cp.w	r8,1
80005958:	e0 88 00 03 	brls	8000595e <prvIdleTask+0x56>
			{
				taskYIELD();
8000595c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000595e:	f0 1f 00 0c 	mcall	8000598c <prvIdleTask+0x84>
		}
		#endif
	}
80005962:	cd 9b       	rjmp	80005914 <prvIdleTask+0xc>
80005964:	00 00       	add	r0,r0
80005966:	0c 1c       	sub	r12,r6
80005968:	00 00       	add	r0,r0
8000596a:	0c c8       	st.b	r6++,r8
8000596c:	00 00       	add	r0,r0
8000596e:	0d 28       	ld.uh	r8,r6++
80005970:	00 00       	add	r0,r0
80005972:	0c 28       	rsub	r8,r6
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	53 30       	stdsp	sp[0xcc],r0
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	56 ec       	stdsp	sp[0x1b8],r12
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	4b fc       	lddpc	r12,80005a78 <xTaskGenericCreate+0xe8>
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	4b 42       	lddpc	r2,80005a50 <xTaskGenericCreate+0xc0>
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	4d 08       	lddpc	r8,80005ac4 <xTaskGenericCreate+0x134>
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	4e 40       	lddpc	r0,80005b18 <xTaskGenericCreate+0x188>
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	20 30       	sub	r0,3

80005990 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005990:	d4 31       	pushm	r0-r7,lr
80005992:	20 1d       	sub	sp,4
80005994:	fa c4 ff d8 	sub	r4,sp,-40
80005998:	50 0c       	stdsp	sp[0x0],r12
8000599a:	16 91       	mov	r1,r11
8000599c:	14 97       	mov	r7,r10
8000599e:	12 90       	mov	r0,r9
800059a0:	10 93       	mov	r3,r8
800059a2:	68 02       	ld.w	r2,r4[0x0]
800059a4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800059a6:	34 8c       	mov	r12,72
800059a8:	f0 1f 00 5c 	mcall	80005b18 <xTaskGenericCreate+0x188>
800059ac:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800059ae:	c0 31       	brne	800059b4 <xTaskGenericCreate+0x24>
800059b0:	3f fc       	mov	r12,-1
800059b2:	ca f8       	rjmp	80005b10 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800059b4:	58 06       	cp.w	r6,0
800059b6:	e0 81 00 af 	brne	80005b14 <xTaskGenericCreate+0x184>
800059ba:	0e 9c       	mov	r12,r7
800059bc:	5c 7c       	castu.h	r12
800059be:	a3 6c       	lsl	r12,0x2
800059c0:	f0 1f 00 56 	mcall	80005b18 <xTaskGenericCreate+0x188>
800059c4:	18 96       	mov	r6,r12
800059c6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800059c8:	c0 61       	brne	800059d4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800059ca:	0a 9c       	mov	r12,r5
800059cc:	f0 1f 00 54 	mcall	80005b1c <xTaskGenericCreate+0x18c>
800059d0:	3f fc       	mov	r12,-1
800059d2:	c9 f8       	rjmp	80005b10 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800059d4:	5c 77       	castu.h	r7
800059d6:	ee 0a 15 02 	lsl	r10,r7,0x2
800059da:	e0 6b 00 a5 	mov	r11,165
800059de:	0c 9c       	mov	r12,r6
800059e0:	f0 1f 00 50 	mcall	80005b20 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800059e4:	ee c6 00 01 	sub	r6,r7,1
800059e8:	6a c8       	ld.w	r8,r5[0x30]
800059ea:	f0 06 00 26 	add	r6,r8,r6<<0x2
800059ee:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800059f2:	31 0a       	mov	r10,16
800059f4:	02 9b       	mov	r11,r1
800059f6:	ea cc ff cc 	sub	r12,r5,-52
800059fa:	f0 1f 00 4b 	mcall	80005b24 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800059fe:	30 08       	mov	r8,0
80005a00:	eb 68 00 43 	st.b	r5[67],r8
80005a04:	58 73       	cp.w	r3,7
80005a06:	e6 07 17 80 	movls	r7,r3
80005a0a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005a0e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005a10:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005a14:	ea c4 ff fc 	sub	r4,r5,-4
80005a18:	08 9c       	mov	r12,r4
80005a1a:	f0 1f 00 44 	mcall	80005b28 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005a1e:	ea cc ff e8 	sub	r12,r5,-24
80005a22:	f0 1f 00 42 	mcall	80005b28 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005a26:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005a28:	ee 07 11 08 	rsub	r7,r7,8
80005a2c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005a2e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005a30:	00 9a       	mov	r10,r0
80005a32:	40 0b       	lddsp	r11,sp[0x0]
80005a34:	0c 9c       	mov	r12,r6
80005a36:	f0 1f 00 3e 	mcall	80005b2c <xTaskGenericCreate+0x19c>
80005a3a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005a3c:	58 02       	cp.w	r2,0
80005a3e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005a42:	f0 1f 00 3c 	mcall	80005b30 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005a46:	4b c8       	lddpc	r8,80005b34 <xTaskGenericCreate+0x1a4>
80005a48:	70 09       	ld.w	r9,r8[0x0]
80005a4a:	2f f9       	sub	r9,-1
80005a4c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005a4e:	4b b8       	lddpc	r8,80005b38 <xTaskGenericCreate+0x1a8>
80005a50:	70 08       	ld.w	r8,r8[0x0]
80005a52:	58 08       	cp.w	r8,0
80005a54:	c2 61       	brne	80005aa0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005a56:	4b 98       	lddpc	r8,80005b38 <xTaskGenericCreate+0x1a8>
80005a58:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005a5a:	4b 78       	lddpc	r8,80005b34 <xTaskGenericCreate+0x1a4>
80005a5c:	70 08       	ld.w	r8,r8[0x0]
80005a5e:	58 18       	cp.w	r8,1
80005a60:	c2 b1       	brne	80005ab6 <xTaskGenericCreate+0x126>
80005a62:	4b 77       	lddpc	r7,80005b3c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005a64:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005a68:	0e 9c       	mov	r12,r7
80005a6a:	f0 1f 00 36 	mcall	80005b40 <xTaskGenericCreate+0x1b0>
80005a6e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005a70:	0c 37       	cp.w	r7,r6
80005a72:	cf b1       	brne	80005a68 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005a74:	4b 47       	lddpc	r7,80005b44 <xTaskGenericCreate+0x1b4>
80005a76:	0e 9c       	mov	r12,r7
80005a78:	f0 1f 00 32 	mcall	80005b40 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005a7c:	4b 36       	lddpc	r6,80005b48 <xTaskGenericCreate+0x1b8>
80005a7e:	0c 9c       	mov	r12,r6
80005a80:	f0 1f 00 30 	mcall	80005b40 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005a84:	4b 2c       	lddpc	r12,80005b4c <xTaskGenericCreate+0x1bc>
80005a86:	f0 1f 00 2f 	mcall	80005b40 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005a8a:	4b 2c       	lddpc	r12,80005b50 <xTaskGenericCreate+0x1c0>
80005a8c:	f0 1f 00 2d 	mcall	80005b40 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005a90:	4b 1c       	lddpc	r12,80005b54 <xTaskGenericCreate+0x1c4>
80005a92:	f0 1f 00 2c 	mcall	80005b40 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005a96:	4b 18       	lddpc	r8,80005b58 <xTaskGenericCreate+0x1c8>
80005a98:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005a9a:	4b 18       	lddpc	r8,80005b5c <xTaskGenericCreate+0x1cc>
80005a9c:	91 06       	st.w	r8[0x0],r6
80005a9e:	c0 c8       	rjmp	80005ab6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005aa0:	4b 08       	lddpc	r8,80005b60 <xTaskGenericCreate+0x1d0>
80005aa2:	70 08       	ld.w	r8,r8[0x0]
80005aa4:	58 08       	cp.w	r8,0
80005aa6:	c0 81       	brne	80005ab6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005aa8:	4a 48       	lddpc	r8,80005b38 <xTaskGenericCreate+0x1a8>
80005aaa:	70 08       	ld.w	r8,r8[0x0]
80005aac:	70 b8       	ld.w	r8,r8[0x2c]
80005aae:	10 33       	cp.w	r3,r8
80005ab0:	c0 33       	brcs	80005ab6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005ab2:	4a 28       	lddpc	r8,80005b38 <xTaskGenericCreate+0x1a8>
80005ab4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005ab6:	6a b8       	ld.w	r8,r5[0x2c]
80005ab8:	4a b9       	lddpc	r9,80005b64 <xTaskGenericCreate+0x1d4>
80005aba:	72 09       	ld.w	r9,r9[0x0]
80005abc:	12 38       	cp.w	r8,r9
80005abe:	e0 88 00 04 	brls	80005ac6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005ac2:	4a 99       	lddpc	r9,80005b64 <xTaskGenericCreate+0x1d4>
80005ac4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005ac6:	4a 98       	lddpc	r8,80005b68 <xTaskGenericCreate+0x1d8>
80005ac8:	70 09       	ld.w	r9,r8[0x0]
80005aca:	2f f9       	sub	r9,-1
80005acc:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005ace:	6a b8       	ld.w	r8,r5[0x2c]
80005ad0:	4a 79       	lddpc	r9,80005b6c <xTaskGenericCreate+0x1dc>
80005ad2:	72 09       	ld.w	r9,r9[0x0]
80005ad4:	12 38       	cp.w	r8,r9
80005ad6:	e0 88 00 04 	brls	80005ade <xTaskGenericCreate+0x14e>
80005ada:	4a 59       	lddpc	r9,80005b6c <xTaskGenericCreate+0x1dc>
80005adc:	93 08       	st.w	r9[0x0],r8
80005ade:	6a bc       	ld.w	r12,r5[0x2c]
80005ae0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ae4:	08 9b       	mov	r11,r4
80005ae6:	49 68       	lddpc	r8,80005b3c <xTaskGenericCreate+0x1ac>
80005ae8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005aec:	f0 1f 00 21 	mcall	80005b70 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005af0:	f0 1f 00 21 	mcall	80005b74 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005af4:	49 b8       	lddpc	r8,80005b60 <xTaskGenericCreate+0x1d0>
80005af6:	70 08       	ld.w	r8,r8[0x0]
80005af8:	58 08       	cp.w	r8,0
80005afa:	c0 a0       	breq	80005b0e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005afc:	48 f8       	lddpc	r8,80005b38 <xTaskGenericCreate+0x1a8>
80005afe:	70 08       	ld.w	r8,r8[0x0]
80005b00:	70 b8       	ld.w	r8,r8[0x2c]
80005b02:	10 33       	cp.w	r3,r8
80005b04:	e0 88 00 05 	brls	80005b0e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005b08:	d7 33       	scall
80005b0a:	30 1c       	mov	r12,1
80005b0c:	c0 28       	rjmp	80005b10 <xTaskGenericCreate+0x180>
80005b0e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005b10:	2f fd       	sub	sp,-4
80005b12:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005b14:	99 c6       	st.w	r12[0x30],r6
80005b16:	c5 fb       	rjmp	800059d4 <xTaskGenericCreate+0x44>
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	4e 68       	lddpc	r8,80005cb0 <PrintDec+0x36>
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	4e 40       	lddpc	r0,80005cac <PrintDec+0x32>
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	68 0c       	ld.w	r12,r4[0x0]
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	6b 50       	ld.w	r0,r5[0x54]
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	4a ec       	lddpc	r12,80005be0 <PrintHex+0x18>
80005b2c:	80 00       	ld.sh	r0,r0[0x0]
80005b2e:	4b 68       	lddpc	r8,80005c04 <PrintHex+0x3c>
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	4b fc       	lddpc	r12,80005c2c <PrintHex+0x64>
80005b34:	00 00       	add	r0,r0
80005b36:	0d 28       	ld.uh	r8,r6++
80005b38:	00 00       	add	r0,r0
80005b3a:	0c dc       	st.w	--r6,r12
80005b3c:	00 00       	add	r0,r0
80005b3e:	0c 28       	rsub	r8,r6
80005b40:	80 00       	ld.sh	r0,r0[0x0]
80005b42:	4a d8       	lddpc	r8,80005bf4 <PrintHex+0x2c>
80005b44:	00 00       	add	r0,r0
80005b46:	0c f4       	st.b	--r6,r4
80005b48:	00 00       	add	r0,r0
80005b4a:	0d 10       	ld.sh	r0,r6++
80005b4c:	00 00       	add	r0,r0
80005b4e:	0c e0       	st.h	--r6,r0
80005b50:	00 00       	add	r0,r0
80005b52:	0c c8       	st.b	r6++,r8
80005b54:	00 00       	add	r0,r0
80005b56:	0d 30       	ld.ub	r0,r6++
80005b58:	00 00       	add	r0,r0
80005b5a:	0c 14       	sub	r4,r6
80005b5c:	00 00       	add	r0,r0
80005b5e:	0c 24       	rsub	r4,r6
80005b60:	00 00       	add	r0,r0
80005b62:	0c 18       	sub	r8,r6
80005b64:	00 00       	add	r0,r0
80005b66:	0c 10       	sub	r0,r6
80005b68:	00 00       	add	r0,r0
80005b6a:	0d 24       	ld.uh	r4,r6++
80005b6c:	00 00       	add	r0,r0
80005b6e:	0d 44       	ld.w	r4,--r6
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	4a f2       	lddpc	r2,80005c2c <PrintHex+0x64>
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	4d 08       	lddpc	r8,80005cb4 <PrintDec+0x3a>

80005b78 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005b78:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005b7a:	30 09       	mov	r9,0
80005b7c:	1a d9       	st.w	--sp,r9
80005b7e:	1a d9       	st.w	--sp,r9
80005b80:	1a d9       	st.w	--sp,r9
80005b82:	12 98       	mov	r8,r9
80005b84:	e0 6a 01 00 	mov	r10,256
80005b88:	48 9b       	lddpc	r11,80005bac <vTaskStartScheduler+0x34>
80005b8a:	48 ac       	lddpc	r12,80005bb0 <vTaskStartScheduler+0x38>
80005b8c:	f0 1f 00 0a 	mcall	80005bb4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005b90:	2f dd       	sub	sp,-12
80005b92:	58 1c       	cp.w	r12,1
80005b94:	c0 a1       	brne	80005ba8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005b96:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005b98:	30 19       	mov	r9,1
80005b9a:	48 88       	lddpc	r8,80005bb8 <vTaskStartScheduler+0x40>
80005b9c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005b9e:	30 09       	mov	r9,0
80005ba0:	48 78       	lddpc	r8,80005bbc <vTaskStartScheduler+0x44>
80005ba2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005ba4:	f0 1f 00 07 	mcall	80005bc0 <vTaskStartScheduler+0x48>
80005ba8:	d8 02       	popm	pc
80005baa:	00 00       	add	r0,r0
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	c6 98       	rjmp	80005c80 <PrintDec+0x6>
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	59 08       	cp.w	r8,16
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	59 90       	cp.w	r0,25
80005bb8:	00 00       	add	r0,r0
80005bba:	0c 18       	sub	r8,r6
80005bbc:	00 00       	add	r0,r0
80005bbe:	0d 08       	ld.w	r8,r6++
80005bc0:	80 00       	ld.sh	r0,r0[0x0]
80005bc2:	4c 0c       	lddpc	r12,80005cc0 <PrintDec+0x46>

80005bc4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005bc4:	16 cc       	st.b	r11++,r12
	return str;
}
80005bc6:	5e fb       	retal	r11

80005bc8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005bc8:	eb cd 40 c0 	pushm	r6-r7,lr
80005bcc:	20 3d       	sub	sp,12
80005bce:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005bd0:	30 06       	mov	r6,0
80005bd2:	30 07       	mov	r7,0
80005bd4:	fa e7 00 00 	st.d	sp[0],r6
80005bd8:	30 0c       	mov	r12,0
80005bda:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005bdc:	58 08       	cp.w	r8,0
80005bde:	c1 30       	breq	80005c04 <PrintHex+0x3c>
80005be0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005be2:	1a 9c       	mov	r12,sp
80005be4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005be8:	58 9e       	cp.w	lr,9
80005bea:	e0 8a 00 04 	brle	80005bf2 <PrintHex+0x2a>
80005bee:	2c 9e       	sub	lr,-55
80005bf0:	c0 48       	rjmp	80005bf8 <PrintHex+0x30>
80005bf2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005bf6:	2d 0e       	sub	lr,-48
80005bf8:	f8 09 0b 0e 	st.b	r12[r9],lr
80005bfc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005bfe:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005c00:	cf 21       	brne	80005be4 <PrintHex+0x1c>
80005c02:	c0 48       	rjmp	80005c0a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005c04:	33 08       	mov	r8,48
80005c06:	ba 88       	st.b	sp[0x0],r8
80005c08:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005c0a:	f6 09 01 08 	sub	r8,r11,r9
80005c0e:	58 08       	cp.w	r8,0
80005c10:	e0 8a 00 13 	brle	80005c36 <PrintHex+0x6e>
	{
		char num = len - cnt;
80005c14:	12 1b       	sub	r11,r9
80005c16:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005c1a:	18 9e       	mov	lr,r12
80005c1c:	58 0c       	cp.w	r12,0
80005c1e:	e0 8a 00 0c 	brle	80005c36 <PrintHex+0x6e>
80005c22:	1a 9b       	mov	r11,sp
80005c24:	12 0b       	add	r11,r9
80005c26:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005c28:	33 07       	mov	r7,48
80005c2a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005c2c:	2f f8       	sub	r8,-1
80005c2e:	1c 38       	cp.w	r8,lr
80005c30:	cf d5       	brlt	80005c2a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005c32:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005c36:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005c3a:	f0 cb ff ff 	sub	r11,r8,-1
80005c3e:	58 0b       	cp.w	r11,0
80005c40:	e0 8a 00 19 	brle	80005c72 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005c44:	fa cb ff f4 	sub	r11,sp,-12
80005c48:	f6 09 00 09 	add	r9,r11,r9
80005c4c:	37 8b       	mov	r11,120
80005c4e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005c52:	fa c9 ff f4 	sub	r9,sp,-12
80005c56:	10 09       	add	r9,r8
80005c58:	33 0b       	mov	r11,48
80005c5a:	f3 6b ff f4 	st.b	r9[-12],r11
80005c5e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005c62:	fa ce 00 01 	sub	lr,sp,1
80005c66:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005c68:	11 8b       	ld.ub	r11,r8[0x0]
80005c6a:	12 cb       	st.b	r9++,r11
80005c6c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005c6e:	1c 38       	cp.w	r8,lr
80005c70:	cf c1       	brne	80005c68 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005c72:	14 9c       	mov	r12,r10
80005c74:	2f dd       	sub	sp,-12
80005c76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005c7a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005c7a:	d4 21       	pushm	r4-r7,lr
80005c7c:	20 3d       	sub	sp,12
80005c7e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005c80:	30 06       	mov	r6,0
80005c82:	30 07       	mov	r7,0
80005c84:	fa e7 00 00 	st.d	sp[0],r6
80005c88:	30 0c       	mov	r12,0
80005c8a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005c8c:	58 08       	cp.w	r8,0
80005c8e:	c0 35       	brlt	80005c94 <PrintDec+0x1a>
80005c90:	14 97       	mov	r7,r10
80005c92:	c0 58       	rjmp	80005c9c <PrintDec+0x22>
	{
		*p++ = '-';
80005c94:	14 97       	mov	r7,r10
80005c96:	32 d9       	mov	r9,45
80005c98:	0e c9       	st.b	r7++,r9
		i = -i;
80005c9a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005c9c:	58 08       	cp.w	r8,0
80005c9e:	c0 51       	brne	80005ca8 <PrintDec+0x2e>
80005ca0:	33 08       	mov	r8,48
80005ca2:	ba 88       	st.b	sp[0x0],r8
80005ca4:	30 1e       	mov	lr,1
80005ca6:	c2 f8       	rjmp	80005d04 <PrintDec+0x8a>
	
	int ten = i%10;
80005ca8:	e0 65 66 67 	mov	r5,26215
80005cac:	ea 15 66 66 	orh	r5,0x6666
80005cb0:	f0 05 04 44 	muls.d	r4,r8,r5
80005cb4:	ea 0c 14 02 	asr	r12,r5,0x2
80005cb8:	f0 09 14 1f 	asr	r9,r8,0x1f
80005cbc:	f8 09 01 09 	sub	r9,r12,r9
80005cc0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005cc4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005cc8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005cca:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005ccc:	e0 66 66 67 	mov	r6,26215
80005cd0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005cd4:	2d 09       	sub	r9,-48
80005cd6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005cda:	2f fe       	sub	lr,-1
		i /= 10;
80005cdc:	f0 06 04 44 	muls.d	r4,r8,r6
80005ce0:	ea 09 14 02 	asr	r9,r5,0x2
80005ce4:	bf 58       	asr	r8,0x1f
80005ce6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005cea:	f0 06 04 44 	muls.d	r4,r8,r6
80005cee:	ea 09 14 02 	asr	r9,r5,0x2
80005cf2:	f0 05 14 1f 	asr	r5,r8,0x1f
80005cf6:	0a 19       	sub	r9,r5
80005cf8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005cfc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005d00:	58 08       	cp.w	r8,0
80005d02:	ce 91       	brne	80005cd4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005d04:	f6 0e 01 08 	sub	r8,r11,lr
80005d08:	58 08       	cp.w	r8,0
80005d0a:	e0 89 00 06 	brgt	80005d16 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005d0e:	58 0e       	cp.w	lr,0
80005d10:	e0 89 00 14 	brgt	80005d38 <PrintDec+0xbe>
80005d14:	c1 d8       	rjmp	80005d4e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005d16:	1c 1b       	sub	r11,lr
80005d18:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005d1a:	16 9c       	mov	r12,r11
80005d1c:	58 0b       	cp.w	r11,0
80005d1e:	fe 9a ff f8 	brle	80005d0e <PrintDec+0x94>
80005d22:	1a 99       	mov	r9,sp
80005d24:	1c 09       	add	r9,lr
80005d26:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005d28:	33 06       	mov	r6,48
80005d2a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005d2c:	2f f8       	sub	r8,-1
80005d2e:	18 38       	cp.w	r8,r12
80005d30:	cf d5       	brlt	80005d2a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005d32:	f6 0e 00 0e 	add	lr,r11,lr
80005d36:	ce cb       	rjmp	80005d0e <PrintDec+0x94>
80005d38:	fa c8 ff f4 	sub	r8,sp,-12
80005d3c:	1c 08       	add	r8,lr
80005d3e:	20 d8       	sub	r8,13
80005d40:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005d44:	11 89       	ld.ub	r9,r8[0x0]
80005d46:	0e c9       	st.b	r7++,r9
80005d48:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005d4a:	16 38       	cp.w	r8,r11
80005d4c:	cf c1       	brne	80005d44 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005d4e:	14 9c       	mov	r12,r10
80005d50:	2f dd       	sub	sp,-12
80005d52:	d8 22       	popm	r4-r7,pc

80005d54 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005d54:	d4 31       	pushm	r0-r7,lr
80005d56:	fa cd 02 08 	sub	sp,sp,520
80005d5a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005d5c:	e0 6a 01 00 	mov	r10,256
80005d60:	30 0b       	mov	r11,0
80005d62:	fa cc fe f8 	sub	r12,sp,-264
80005d66:	f0 1f 00 4e 	mcall	80005e9c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005d6a:	fa c4 fd d4 	sub	r4,sp,-556
80005d6e:	30 0a       	mov	r10,0
80005d70:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005d72:	fa c3 ff fc 	sub	r3,sp,-4
80005d76:	e0 61 01 00 	mov	r1,256
80005d7a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005d7c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005d7e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005d82:	02 9a       	mov	r10,r1
80005d84:	00 9b       	mov	r11,r0
80005d86:	06 9c       	mov	r12,r3
80005d88:	f0 1f 00 45 	mcall	80005e9c <log+0x148>
			
					if(*str == '%')
80005d8c:	0f 88       	ld.ub	r8,r7[0x0]
80005d8e:	e4 08 18 00 	cp.b	r8,r2
80005d92:	c5 71       	brne	80005e40 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005d94:	ee c8 ff ff 	sub	r8,r7,-1
80005d98:	11 89       	ld.ub	r9,r8[0x0]
80005d9a:	4c 2a       	lddpc	r10,80005ea0 <log+0x14c>
80005d9c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005d9e:	23 09       	sub	r9,48
80005da0:	30 9a       	mov	r10,9
80005da2:	f4 09 18 00 	cp.b	r9,r10
80005da6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005daa:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005dae:	f7 b9 08 30 	subls	r9,48
80005db2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005db6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005dba:	0f 88       	ld.ub	r8,r7[0x0]
80005dbc:	22 58       	sub	r8,37
80005dbe:	e0 48 00 53 	cp.w	r8,83
80005dc2:	e0 8b 00 31 	brhi	80005e24 <log+0xd0>
80005dc6:	4b 89       	lddpc	r9,80005ea4 <log+0x150>
80005dc8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005dcc:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005dd0:	06 9a       	mov	r10,r3
80005dd2:	40 0b       	lddsp	r11,sp[0x0]
80005dd4:	5c 5b       	castu.b	r11
80005dd6:	68 0c       	ld.w	r12,r4[0x0]
80005dd8:	f0 1f 00 34 	mcall	80005ea8 <log+0x154>
							break;
80005ddc:	c2 98       	rjmp	80005e2e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005dde:	4b 4c       	lddpc	r12,80005eac <log+0x158>
80005de0:	f0 1f 00 34 	mcall	80005eb0 <log+0x15c>
80005de4:	08 95       	mov	r5,r4
80005de6:	06 9c       	mov	r12,r3
							break;
80005de8:	c2 38       	rjmp	80005e2e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005dea:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005dee:	06 9a       	mov	r10,r3
80005df0:	40 0b       	lddsp	r11,sp[0x0]
80005df2:	5c 5b       	castu.b	r11
80005df4:	68 0c       	ld.w	r12,r4[0x0]
80005df6:	f0 1f 00 30 	mcall	80005eb4 <log+0x160>
80005dfa:	06 9c       	mov	r12,r3
							break;
80005dfc:	c1 98       	rjmp	80005e2e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005dfe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005e02:	06 9b       	mov	r11,r3
80005e04:	09 bc       	ld.ub	r12,r4[0x3]
80005e06:	f0 1f 00 2d 	mcall	80005eb8 <log+0x164>
80005e0a:	06 9c       	mov	r12,r3
							break;
80005e0c:	c1 18       	rjmp	80005e2e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005e0e:	e8 c5 ff fc 	sub	r5,r4,-4
80005e12:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005e14:	c0 d8       	rjmp	80005e2e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005e16:	06 9b       	mov	r11,r3
80005e18:	32 5c       	mov	r12,37
80005e1a:	f0 1f 00 28 	mcall	80005eb8 <log+0x164>
80005e1e:	08 95       	mov	r5,r4
80005e20:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005e22:	c0 68       	rjmp	80005e2e <log+0xda>
							
							default:
							log("I need relax.");
80005e24:	4a 6c       	lddpc	r12,80005ebc <log+0x168>
80005e26:	f0 1f 00 23 	mcall	80005eb0 <log+0x15c>
80005e2a:	08 95       	mov	r5,r4
80005e2c:	06 9c       	mov	r12,r3
						}
						str++;
80005e2e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005e30:	1a dc       	st.w	--sp,r12
80005e32:	1a d6       	st.w	--sp,r6
80005e34:	4a 3b       	lddpc	r11,80005ec0 <log+0x16c>
80005e36:	0c 9c       	mov	r12,r6
80005e38:	f0 1f 00 23 	mcall	80005ec4 <log+0x170>
80005e3c:	2f ed       	sub	sp,-8
80005e3e:	c0 a8       	rjmp	80005e52 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005e40:	2f f7       	sub	r7,-1
80005e42:	1a d8       	st.w	--sp,r8
80005e44:	1a d6       	st.w	--sp,r6
80005e46:	4a 1b       	lddpc	r11,80005ec8 <log+0x174>
80005e48:	0c 9c       	mov	r12,r6
80005e4a:	f0 1f 00 1f 	mcall	80005ec4 <log+0x170>
80005e4e:	08 95       	mov	r5,r4
80005e50:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005e52:	0f 89       	ld.ub	r9,r7[0x0]
80005e54:	30 08       	mov	r8,0
80005e56:	f0 09 18 00 	cp.b	r9,r8
80005e5a:	c0 30       	breq	80005e60 <log+0x10c>
80005e5c:	0a 94       	mov	r4,r5
80005e5e:	c9 2b       	rjmp	80005d82 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005e60:	fa c7 fe f8 	sub	r7,sp,-264
80005e64:	1a d7       	st.w	--sp,r7
80005e66:	49 ab       	lddpc	r11,80005ecc <log+0x178>
80005e68:	0e 9c       	mov	r12,r7
80005e6a:	f0 1f 00 17 	mcall	80005ec4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005e6e:	5c 5c       	castu.b	r12
80005e70:	f8 c6 ff ff 	sub	r6,r12,-1
80005e74:	0c 9c       	mov	r12,r6
80005e76:	f0 1f 00 17 	mcall	80005ed0 <log+0x17c>
80005e7a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005e7c:	0c 9a       	mov	r10,r6
80005e7e:	0e 9b       	mov	r11,r7
80005e80:	f0 1f 00 15 	mcall	80005ed4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80005e84:	30 09       	mov	r9,0
80005e86:	30 5a       	mov	r10,5
80005e88:	fa cb fe f8 	sub	r11,sp,-264
80005e8c:	49 38       	lddpc	r8,80005ed8 <log+0x184>
80005e8e:	70 0c       	ld.w	r12,r8[0x0]
80005e90:	f0 1f 00 13 	mcall	80005edc <log+0x188>
80005e94:	2f fd       	sub	sp,-4
	
	
}
80005e96:	fe 3d fd f8 	sub	sp,-520
80005e9a:	d8 32       	popm	r0-r7,pc
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	68 0c       	ld.w	r12,r4[0x0]
80005ea0:	00 00       	add	r0,r0
80005ea2:	0d 48       	ld.w	r8,--r6
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	c6 a0       	breq	80005f7a <logFromISR+0x9a>
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	5c 7a       	castu.h	r10
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	c9 4c       	rcall	80005fd6 <logFromISR+0xf6>
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	5d 54       	*unknown*
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	5b c8       	cp.w	r8,-4
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	5b c4       	cp.w	r4,-4
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	c9 5c       	rcall	80005fe8 <logFromISR+0x108>
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	c9 6c       	rcall	80005fee <logFromISR+0x10e>
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	6a fc       	ld.w	r12,r5[0x3c]
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	c9 74       	brge	80005df8 <log+0xa4>
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	c9 7c       	rcall	80005ffc <logFromISR+0x11c>
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	4e 68       	lddpc	r8,80006068 <log_init+0x8>
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	66 c4       	ld.w	r4,r3[0x30]
80005ed8:	00 00       	add	r0,r0
80005eda:	41 10       	lddsp	r0,sp[0x44]
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	51 bc       	stdsp	sp[0x6c],r12

80005ee0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80005ee0:	d4 31       	pushm	r0-r7,lr
80005ee2:	fa cd 02 0c 	sub	sp,sp,524
80005ee6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80005ee8:	e0 6a 01 00 	mov	r10,256
80005eec:	30 0b       	mov	r11,0
80005eee:	fa cc fe f4 	sub	r12,sp,-268
80005ef2:	f0 1f 00 4c 	mcall	80006020 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80005ef6:	fa c4 fd d0 	sub	r4,sp,-560
80005efa:	30 0a       	mov	r10,0
80005efc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005efe:	fa c3 ff fc 	sub	r3,sp,-4
80005f02:	e0 61 01 00 	mov	r1,256
80005f06:	14 90       	mov	r0,r10
			
			if(*str == '%')
80005f08:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005f0a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005f0e:	02 9a       	mov	r10,r1
80005f10:	00 9b       	mov	r11,r0
80005f12:	06 9c       	mov	r12,r3
80005f14:	f0 1f 00 43 	mcall	80006020 <logFromISR+0x140>
			
			if(*str == '%')
80005f18:	0f 88       	ld.ub	r8,r7[0x0]
80005f1a:	e4 08 18 00 	cp.b	r8,r2
80005f1e:	c5 11       	brne	80005fc0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80005f20:	ee c8 ff ff 	sub	r8,r7,-1
80005f24:	11 89       	ld.ub	r9,r8[0x0]
80005f26:	4c 0a       	lddpc	r10,80006024 <logFromISR+0x144>
80005f28:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80005f2a:	23 09       	sub	r9,48
80005f2c:	30 9a       	mov	r10,9
80005f2e:	f4 09 18 00 	cp.b	r9,r10
80005f32:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80005f36:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005f3a:	f7 b9 08 30 	subls	r9,48
80005f3e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80005f42:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80005f46:	0f 88       	ld.ub	r8,r7[0x0]
80005f48:	22 58       	sub	r8,37
80005f4a:	e0 48 00 53 	cp.w	r8,83
80005f4e:	e0 8b 00 2b 	brhi	80005fa4 <logFromISR+0xc4>
80005f52:	4b 69       	lddpc	r9,80006028 <logFromISR+0x148>
80005f54:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80005f58:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80005f5c:	06 9a       	mov	r10,r3
80005f5e:	40 0b       	lddsp	r11,sp[0x0]
80005f60:	5c 5b       	castu.b	r11
80005f62:	68 0c       	ld.w	r12,r4[0x0]
80005f64:	f0 1f 00 32 	mcall	8000602c <logFromISR+0x14c>
					break;
80005f68:	c2 38       	rjmp	80005fae <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80005f6a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80005f6e:	06 9a       	mov	r10,r3
80005f70:	40 0b       	lddsp	r11,sp[0x0]
80005f72:	5c 5b       	castu.b	r11
80005f74:	68 0c       	ld.w	r12,r4[0x0]
80005f76:	f0 1f 00 2f 	mcall	80006030 <logFromISR+0x150>
80005f7a:	06 9c       	mov	r12,r3
					break;
80005f7c:	c1 98       	rjmp	80005fae <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80005f7e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80005f82:	06 9b       	mov	r11,r3
80005f84:	09 bc       	ld.ub	r12,r4[0x3]
80005f86:	f0 1f 00 2c 	mcall	80006034 <logFromISR+0x154>
80005f8a:	06 9c       	mov	r12,r3
					break;
80005f8c:	c1 18       	rjmp	80005fae <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80005f8e:	e8 c5 ff fc 	sub	r5,r4,-4
80005f92:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80005f94:	c0 d8       	rjmp	80005fae <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80005f96:	06 9b       	mov	r11,r3
80005f98:	32 5c       	mov	r12,37
80005f9a:	f0 1f 00 27 	mcall	80006034 <logFromISR+0x154>
80005f9e:	08 95       	mov	r5,r4
80005fa0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80005fa2:	c0 68       	rjmp	80005fae <logFromISR+0xce>
					default:
					log("I need relax.");
80005fa4:	4a 5c       	lddpc	r12,80006038 <logFromISR+0x158>
80005fa6:	f0 1f 00 26 	mcall	8000603c <logFromISR+0x15c>
80005faa:	08 95       	mov	r5,r4
80005fac:	06 9c       	mov	r12,r3
				}
				str++;
80005fae:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005fb0:	1a dc       	st.w	--sp,r12
80005fb2:	1a d6       	st.w	--sp,r6
80005fb4:	4a 3b       	lddpc	r11,80006040 <logFromISR+0x160>
80005fb6:	0c 9c       	mov	r12,r6
80005fb8:	f0 1f 00 23 	mcall	80006044 <logFromISR+0x164>
80005fbc:	2f ed       	sub	sp,-8
80005fbe:	c0 a8       	rjmp	80005fd2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005fc0:	2f f7       	sub	r7,-1
80005fc2:	1a d8       	st.w	--sp,r8
80005fc4:	1a d6       	st.w	--sp,r6
80005fc6:	4a 1b       	lddpc	r11,80006048 <logFromISR+0x168>
80005fc8:	0c 9c       	mov	r12,r6
80005fca:	f0 1f 00 1f 	mcall	80006044 <logFromISR+0x164>
80005fce:	08 95       	mov	r5,r4
80005fd0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80005fd2:	0f 89       	ld.ub	r9,r7[0x0]
80005fd4:	30 08       	mov	r8,0
80005fd6:	f0 09 18 00 	cp.b	r9,r8
80005fda:	c0 30       	breq	80005fe0 <logFromISR+0x100>
80005fdc:	0a 94       	mov	r4,r5
80005fde:	c9 8b       	rjmp	80005f0e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80005fe0:	fa c7 fe f4 	sub	r7,sp,-268
80005fe4:	1a d7       	st.w	--sp,r7
80005fe6:	49 ab       	lddpc	r11,8000604c <logFromISR+0x16c>
80005fe8:	0e 9c       	mov	r12,r7
80005fea:	f0 1f 00 17 	mcall	80006044 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80005fee:	5c 5c       	castu.b	r12
80005ff0:	f8 c6 ff ff 	sub	r6,r12,-1
80005ff4:	0c 9c       	mov	r12,r6
80005ff6:	f0 1f 00 17 	mcall	80006050 <logFromISR+0x170>
80005ffa:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80005ffc:	0c 9a       	mov	r10,r6
80005ffe:	0e 9b       	mov	r11,r7
80006000:	f0 1f 00 15 	mcall	80006054 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006004:	30 09       	mov	r9,0
80006006:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006008:	fa ca fe f8 	sub	r10,sp,-264
8000600c:	fa cb fe f4 	sub	r11,sp,-268
80006010:	49 28       	lddpc	r8,80006058 <logFromISR+0x178>
80006012:	70 0c       	ld.w	r12,r8[0x0]
80006014:	f0 1f 00 12 	mcall	8000605c <logFromISR+0x17c>
80006018:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000601a:	fe 3d fd f4 	sub	sp,-524
8000601e:	d8 32       	popm	r0-r7,pc
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	68 0c       	ld.w	r12,r4[0x0]
80006024:	00 00       	add	r0,r0
80006026:	0d 49       	ld.w	r9,--r6
80006028:	80 00       	ld.sh	r0,r0[0x0]
8000602a:	c7 f0       	breq	80006128 <main+0x1c>
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	5c 7a       	castu.h	r10
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	5b c8       	cp.w	r8,-4
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	5b c4       	cp.w	r4,-4
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	c9 5c       	rcall	80006164 <main+0x58>
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	5d 54       	*unknown*
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	c9 6c       	rcall	8000616e <main+0x62>
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	6a fc       	ld.w	r12,r5[0x3c]
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	c9 74       	brge	80005f78 <logFromISR+0x98>
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	c9 7c       	rcall	8000617c <main+0x70>
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	4e 68       	lddpc	r8,800061e8 <gpio_enable_module_pin+0x40>
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	66 c4       	ld.w	r4,r3[0x30]
80006058:	00 00       	add	r0,r0
8000605a:	41 10       	lddsp	r0,sp[0x44]
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	51 6c       	stdsp	sp[0x58],r12

80006060 <log_init>:
		
	return str;
}

void log_init(void)
{
80006060:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006062:	30 2b       	mov	r11,2
80006064:	49 0c       	lddpc	r12,800060a4 <log_init+0x44>
80006066:	f0 1f 00 11 	mcall	800060a8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000606a:	e0 6a 36 00 	mov	r10,13824
8000606e:	ea 1a 01 6e 	orh	r10,0x16e
80006072:	48 fb       	lddpc	r11,800060ac <log_init+0x4c>
80006074:	fe 7c 18 00 	mov	r12,-59392
80006078:	f0 1f 00 0e 	mcall	800060b0 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000607c:	30 4b       	mov	r11,4
8000607e:	33 2c       	mov	r12,50
80006080:	f0 1f 00 0d 	mcall	800060b4 <log_init+0x54>
80006084:	48 d8       	lddpc	r8,800060b8 <log_init+0x58>
80006086:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006088:	30 09       	mov	r9,0
8000608a:	1a d9       	st.w	--sp,r9
8000608c:	1a d9       	st.w	--sp,r9
8000608e:	1a d9       	st.w	--sp,r9
80006090:	30 28       	mov	r8,2
80006092:	e0 6a 01 80 	mov	r10,384
80006096:	48 ab       	lddpc	r11,800060bc <log_init+0x5c>
80006098:	48 ac       	lddpc	r12,800060c0 <log_init+0x60>
8000609a:	f0 1f 00 0b 	mcall	800060c4 <log_init+0x64>
8000609e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800060a0:	d8 02       	popm	pc
800060a2:	00 00       	add	r0,r0
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	c9 88       	rjmp	800061d6 <gpio_enable_module_pin+0x2e>
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	61 fc       	ld.w	r12,r0[0x7c]
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	c9 40       	breq	80005fd6 <logFromISR+0xf6>
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	4a 0c       	lddpc	r12,80006130 <main+0x24>
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	52 bc       	stdsp	sp[0xac],r12
800060b8:	00 00       	add	r0,r0
800060ba:	41 10       	lddsp	r0,sp[0x44]
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	c9 84       	brge	80005fee <logFromISR+0x10e>
800060c0:	80 00       	ld.sh	r0,r0[0x0]
800060c2:	60 c8       	ld.w	r8,r0[0x30]
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	59 90       	cp.w	r0,25

800060c8 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800060c8:	eb cd 40 f8 	pushm	r3-r7,lr
800060cc:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800060ce:	48 c7       	lddpc	r7,800060fc <task_log+0x34>
800060d0:	30 05       	mov	r5,0
800060d2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800060d4:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800060d8:	0a 99       	mov	r9,r5
800060da:	08 9a       	mov	r10,r4
800060dc:	1a 9b       	mov	r11,sp
800060de:	6e 0c       	ld.w	r12,r7[0x0]
800060e0:	f0 1f 00 08 	mcall	80006100 <task_log+0x38>
800060e4:	58 1c       	cp.w	r12,1
800060e6:	cf 91       	brne	800060d8 <task_log+0x10>
		{
			if( NULL != str)
800060e8:	40 0b       	lddsp	r11,sp[0x0]
800060ea:	58 0b       	cp.w	r11,0
800060ec:	cf 60       	breq	800060d8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800060ee:	06 9c       	mov	r12,r3
800060f0:	f0 1f 00 05 	mcall	80006104 <task_log+0x3c>
				vPortFree(str);
800060f4:	40 0c       	lddsp	r12,sp[0x0]
800060f6:	f0 1f 00 05 	mcall	80006108 <task_log+0x40>
800060fa:	ce fb       	rjmp	800060d8 <task_log+0x10>
800060fc:	00 00       	add	r0,r0
800060fe:	41 10       	lddsp	r0,sp[0x44]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	4f b0       	lddpc	r0,800062ec <_malloc_r+0x60>
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	49 bc       	lddpc	r12,80006170 <main+0x64>
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	4e 40       	lddpc	r0,80006298 <_malloc_r+0xc>

8000610c <main>:

char debug_output[10]={"start"};
U32 volatile test_data = 0x11123334;

int main(void)
{
8000610c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000610e:	fe 78 10 00 	mov	r8,-61440
80006112:	30 19       	mov	r9,1
80006114:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006118:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000611c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006120:	d3 03       	ssrf	0x10
	local_start_pll0();
80006122:	f0 1f 00 16 	mcall	80006178 <main+0x6c>
		
	INTC_init_interrupts();
80006126:	f0 1f 00 16 	mcall	8000617c <main+0x70>
	
	log_init();		
8000612a:	f0 1f 00 16 	mcall	80006180 <main+0x74>
	log("debug_output: %s\n", debug_output);
8000612e:	49 68       	lddpc	r8,80006184 <main+0x78>
80006130:	1a d8       	st.w	--sp,r8
80006132:	49 6c       	lddpc	r12,80006188 <main+0x7c>
80006134:	f0 1f 00 16 	mcall	8000618c <main+0x80>
	log(": %x\n", test_data);
80006138:	49 68       	lddpc	r8,80006190 <main+0x84>
8000613a:	70 08       	ld.w	r8,r8[0x0]
8000613c:	1a d8       	st.w	--sp,r8
8000613e:	49 6c       	lddpc	r12,80006194 <main+0x88>
80006140:	f0 1f 00 13 	mcall	8000618c <main+0x80>
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。

	//tc_init();	
			
	xcmp_init();
80006144:	f0 1f 00 15 	mcall	80006198 <main+0x8c>
	
	Enable_global_interrupt();
80006148:	d5 03       	csrf	0x10
	
	app_init();
8000614a:	f0 1f 00 15 	mcall	8000619c <main+0x90>
8000614e:	2f ed       	sub	sp,-8
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006150:	fe 79 10 00 	mov	r9,-61440
80006154:	f2 f8 01 60 	ld.w	r8,r9[352]
80006158:	e2 18 00 02 	andl	r8,0x2,COH
8000615c:	cf c0       	breq	80006154 <main+0x48>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000615e:	fe 79 10 00 	mov	r9,-61440
80006162:	f2 f8 01 60 	ld.w	r8,r9[352]
80006166:	e2 18 00 02 	andl	r8,0x2,COH
8000616a:	cf c1       	brne	80006162 <main+0x56>
	local_start_timer();
8000616c:	f0 1f 00 0d 	mcall	800061a0 <main+0x94>
	
	vTaskStartScheduler();		
80006170:	f0 1f 00 0d 	mcall	800061a4 <main+0x98>
	return 0;
}
80006174:	d8 0a       	popm	pc,r12=0
80006176:	00 00       	add	r0,r0
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	47 38       	lddsp	r8,sp[0x1cc]
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	48 44       	lddpc	r4,8000618c <main+0x80>
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	60 60       	ld.w	r0,r0[0x18]
80006184:	00 00       	add	r0,r0
80006186:	05 30       	ld.ub	r0,r2++
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	c9 98       	rjmp	800062bc <_malloc_r+0x30>
8000618c:	80 00       	ld.sh	r0,r0[0x0]
8000618e:	5d 54       	*unknown*
80006190:	00 00       	add	r0,r0
80006192:	05 3c       	ld.ub	r12,r2++
80006194:	80 00       	ld.sh	r0,r0[0x0]
80006196:	c5 14       	brge	80006238 <_stext+0xc>
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	40 2c       	lddsp	r12,sp[0x8]
8000619c:	80 00       	ld.sh	r0,r0[0x0]
8000619e:	20 40       	sub	r0,4
800061a0:	80 00       	ld.sh	r0,r0[0x0]
800061a2:	47 88       	lddsp	r8,sp[0x1e0]
800061a4:	80 00       	ld.sh	r0,r0[0x0]
800061a6:	5b 78       	cp.w	r8,-9

800061a8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800061a8:	f8 08 16 05 	lsr	r8,r12,0x5
800061ac:	a9 68       	lsl	r8,0x8
800061ae:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800061b2:	58 1b       	cp.w	r11,1
800061b4:	c0 d0       	breq	800061ce <gpio_enable_module_pin+0x26>
800061b6:	c0 63       	brcs	800061c2 <gpio_enable_module_pin+0x1a>
800061b8:	58 2b       	cp.w	r11,2
800061ba:	c1 00       	breq	800061da <gpio_enable_module_pin+0x32>
800061bc:	58 3b       	cp.w	r11,3
800061be:	c1 40       	breq	800061e6 <gpio_enable_module_pin+0x3e>
800061c0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800061c2:	30 19       	mov	r9,1
800061c4:	f2 0c 09 49 	lsl	r9,r9,r12
800061c8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800061ca:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800061cc:	c1 28       	rjmp	800061f0 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800061ce:	30 19       	mov	r9,1
800061d0:	f2 0c 09 49 	lsl	r9,r9,r12
800061d4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800061d6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800061d8:	c0 c8       	rjmp	800061f0 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800061da:	30 19       	mov	r9,1
800061dc:	f2 0c 09 49 	lsl	r9,r9,r12
800061e0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800061e2:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800061e4:	c0 68       	rjmp	800061f0 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800061e6:	30 19       	mov	r9,1
800061e8:	f2 0c 09 49 	lsl	r9,r9,r12
800061ec:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800061ee:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800061f0:	30 19       	mov	r9,1
800061f2:	f2 0c 09 4c 	lsl	r12,r9,r12
800061f6:	91 2c       	st.w	r8[0x8],r12
800061f8:	5e fd       	retal	0
800061fa:	d7 03       	nop

800061fc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800061fc:	d4 21       	pushm	r4-r7,lr
800061fe:	18 97       	mov	r7,r12
80006200:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006202:	58 0b       	cp.w	r11,0
80006204:	c0 31       	brne	8000620a <gpio_enable_module+0xe>
80006206:	30 05       	mov	r5,0
80006208:	c0 d8       	rjmp	80006222 <gpio_enable_module+0x26>
8000620a:	30 06       	mov	r6,0
8000620c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000620e:	6e 1b       	ld.w	r11,r7[0x4]
80006210:	6e 0c       	ld.w	r12,r7[0x0]
80006212:	f0 1f 00 06 	mcall	80006228 <gpio_enable_module+0x2c>
80006216:	18 45       	or	r5,r12
		gpiomap++;
80006218:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000621a:	2f f6       	sub	r6,-1
8000621c:	0c 34       	cp.w	r4,r6
8000621e:	fe 9b ff f8 	brhi	8000620e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006222:	0a 9c       	mov	r12,r5
80006224:	d8 22       	popm	r4-r7,pc
80006226:	00 00       	add	r0,r0
80006228:	80 00       	ld.sh	r0,r0[0x0]
8000622a:	61 a8       	ld.w	r8,r0[0x68]

8000622c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000622c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006230:	fe c0 a6 30 	sub	r0,pc,-22992

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006234:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006238:	d5 53       	csrf	0x15
  cp      r0, r1
8000623a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000623c:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006240:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006242:	c0 72       	brcc	80006250 <idata_load_loop_end>
  cp      r0, r1
80006244:	fe c2 93 14 	sub	r2,pc,-27884

80006248 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006248:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000624a:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000624c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000624e:	cf d3       	brcs	80006248 <idata_load_loop>

80006250 <idata_load_loop_end>:
  mov     r2, 0
80006250:	e0 60 0a 48 	mov	r0,2632
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006254:	e0 61 41 18 	mov	r1,16664
  cp      r0, r1
  brlo    udata_clear_loop
80006258:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000625a:	c0 62       	brcc	80006266 <udata_clear_loop_end>
8000625c:	30 02       	mov	r2,0
8000625e:	30 03       	mov	r3,0

80006260 <udata_clear_loop>:
80006260:	a1 22       	st.d	r0++,r2
80006262:	02 30       	cp.w	r0,r1
80006264:	cf e3       	brcs	80006260 <udata_clear_loop>

80006266 <udata_clear_loop_end>:
80006266:	fe cf 01 5a 	sub	pc,pc,346
8000626a:	d7 03       	nop

8000626c <free>:
8000626c:	d4 01       	pushm	lr
8000626e:	e0 68 0a 40 	mov	r8,2624
80006272:	18 9b       	mov	r11,r12
80006274:	70 0c       	ld.w	r12,r8[0x0]
80006276:	e0 a0 1e 6d 	rcall	80009f50 <_free_r>
8000627a:	d8 02       	popm	pc

8000627c <malloc>:
8000627c:	d4 01       	pushm	lr
8000627e:	e0 68 0a 40 	mov	r8,2624
80006282:	18 9b       	mov	r11,r12
80006284:	70 0c       	ld.w	r12,r8[0x0]
80006286:	c0 3c       	rcall	8000628c <_malloc_r>
80006288:	d8 02       	popm	pc
8000628a:	d7 03       	nop

8000628c <_malloc_r>:
8000628c:	d4 31       	pushm	r0-r7,lr
8000628e:	f6 c8 ff f5 	sub	r8,r11,-11
80006292:	18 95       	mov	r5,r12
80006294:	10 97       	mov	r7,r8
80006296:	e0 17 ff f8 	andl	r7,0xfff8
8000629a:	59 68       	cp.w	r8,22
8000629c:	f9 b7 08 10 	movls	r7,16
800062a0:	16 37       	cp.w	r7,r11
800062a2:	5f 38       	srlo	r8
800062a4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800062a8:	c0 50       	breq	800062b2 <_malloc_r+0x26>
800062aa:	30 c8       	mov	r8,12
800062ac:	99 38       	st.w	r12[0xc],r8
800062ae:	e0 8f 01 fa 	bral	800066a2 <_malloc_r+0x416>
800062b2:	fe b0 f5 7d 	rcall	80004dac <__malloc_lock>
800062b6:	e0 47 01 f7 	cp.w	r7,503
800062ba:	e0 8b 00 1d 	brhi	800062f4 <_malloc_r+0x68>
800062be:	ee 03 16 03 	lsr	r3,r7,0x3
800062c2:	e0 68 05 40 	mov	r8,1344
800062c6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800062ca:	70 36       	ld.w	r6,r8[0xc]
800062cc:	10 36       	cp.w	r6,r8
800062ce:	c0 61       	brne	800062da <_malloc_r+0x4e>
800062d0:	ec c8 ff f8 	sub	r8,r6,-8
800062d4:	70 36       	ld.w	r6,r8[0xc]
800062d6:	10 36       	cp.w	r6,r8
800062d8:	c0 c0       	breq	800062f0 <_malloc_r+0x64>
800062da:	6c 18       	ld.w	r8,r6[0x4]
800062dc:	e0 18 ff fc 	andl	r8,0xfffc
800062e0:	6c 3a       	ld.w	r10,r6[0xc]
800062e2:	ec 08 00 09 	add	r9,r6,r8
800062e6:	0a 9c       	mov	r12,r5
800062e8:	6c 28       	ld.w	r8,r6[0x8]
800062ea:	95 28       	st.w	r10[0x8],r8
800062ec:	91 3a       	st.w	r8[0xc],r10
800062ee:	c4 78       	rjmp	8000637c <_malloc_r+0xf0>
800062f0:	2f e3       	sub	r3,-2
800062f2:	c4 d8       	rjmp	8000638c <_malloc_r+0x100>
800062f4:	ee 03 16 09 	lsr	r3,r7,0x9
800062f8:	c0 41       	brne	80006300 <_malloc_r+0x74>
800062fa:	ee 03 16 03 	lsr	r3,r7,0x3
800062fe:	c2 68       	rjmp	8000634a <_malloc_r+0xbe>
80006300:	58 43       	cp.w	r3,4
80006302:	e0 8b 00 06 	brhi	8000630e <_malloc_r+0x82>
80006306:	ee 03 16 06 	lsr	r3,r7,0x6
8000630a:	2c 83       	sub	r3,-56
8000630c:	c1 f8       	rjmp	8000634a <_malloc_r+0xbe>
8000630e:	59 43       	cp.w	r3,20
80006310:	e0 8b 00 04 	brhi	80006318 <_malloc_r+0x8c>
80006314:	2a 53       	sub	r3,-91
80006316:	c1 a8       	rjmp	8000634a <_malloc_r+0xbe>
80006318:	e0 43 00 54 	cp.w	r3,84
8000631c:	e0 8b 00 06 	brhi	80006328 <_malloc_r+0x9c>
80006320:	ee 03 16 0c 	lsr	r3,r7,0xc
80006324:	29 23       	sub	r3,-110
80006326:	c1 28       	rjmp	8000634a <_malloc_r+0xbe>
80006328:	e0 43 01 54 	cp.w	r3,340
8000632c:	e0 8b 00 06 	brhi	80006338 <_malloc_r+0xac>
80006330:	ee 03 16 0f 	lsr	r3,r7,0xf
80006334:	28 93       	sub	r3,-119
80006336:	c0 a8       	rjmp	8000634a <_malloc_r+0xbe>
80006338:	e0 43 05 54 	cp.w	r3,1364
8000633c:	e0 88 00 04 	brls	80006344 <_malloc_r+0xb8>
80006340:	37 e3       	mov	r3,126
80006342:	c0 48       	rjmp	8000634a <_malloc_r+0xbe>
80006344:	ee 03 16 12 	lsr	r3,r7,0x12
80006348:	28 43       	sub	r3,-124
8000634a:	e0 6a 05 40 	mov	r10,1344
8000634e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006352:	74 36       	ld.w	r6,r10[0xc]
80006354:	c1 98       	rjmp	80006386 <_malloc_r+0xfa>
80006356:	6c 19       	ld.w	r9,r6[0x4]
80006358:	e0 19 ff fc 	andl	r9,0xfffc
8000635c:	f2 07 01 0b 	sub	r11,r9,r7
80006360:	58 fb       	cp.w	r11,15
80006362:	e0 8a 00 04 	brle	8000636a <_malloc_r+0xde>
80006366:	20 13       	sub	r3,1
80006368:	c1 18       	rjmp	8000638a <_malloc_r+0xfe>
8000636a:	6c 38       	ld.w	r8,r6[0xc]
8000636c:	58 0b       	cp.w	r11,0
8000636e:	c0 b5       	brlt	80006384 <_malloc_r+0xf8>
80006370:	6c 2a       	ld.w	r10,r6[0x8]
80006372:	ec 09 00 09 	add	r9,r6,r9
80006376:	0a 9c       	mov	r12,r5
80006378:	91 2a       	st.w	r8[0x8],r10
8000637a:	95 38       	st.w	r10[0xc],r8
8000637c:	72 18       	ld.w	r8,r9[0x4]
8000637e:	a1 a8       	sbr	r8,0x0
80006380:	93 18       	st.w	r9[0x4],r8
80006382:	cb c8       	rjmp	800064fa <_malloc_r+0x26e>
80006384:	10 96       	mov	r6,r8
80006386:	14 36       	cp.w	r6,r10
80006388:	ce 71       	brne	80006356 <_malloc_r+0xca>
8000638a:	2f f3       	sub	r3,-1
8000638c:	e0 6a 05 40 	mov	r10,1344
80006390:	f4 cc ff f8 	sub	r12,r10,-8
80006394:	78 26       	ld.w	r6,r12[0x8]
80006396:	18 36       	cp.w	r6,r12
80006398:	c6 c0       	breq	80006470 <_malloc_r+0x1e4>
8000639a:	6c 19       	ld.w	r9,r6[0x4]
8000639c:	e0 19 ff fc 	andl	r9,0xfffc
800063a0:	f2 07 01 08 	sub	r8,r9,r7
800063a4:	58 f8       	cp.w	r8,15
800063a6:	e0 89 00 8f 	brgt	800064c4 <_malloc_r+0x238>
800063aa:	99 3c       	st.w	r12[0xc],r12
800063ac:	99 2c       	st.w	r12[0x8],r12
800063ae:	58 08       	cp.w	r8,0
800063b0:	c0 55       	brlt	800063ba <_malloc_r+0x12e>
800063b2:	ec 09 00 09 	add	r9,r6,r9
800063b6:	0a 9c       	mov	r12,r5
800063b8:	ce 2b       	rjmp	8000637c <_malloc_r+0xf0>
800063ba:	e0 49 01 ff 	cp.w	r9,511
800063be:	e0 8b 00 13 	brhi	800063e4 <_malloc_r+0x158>
800063c2:	a3 99       	lsr	r9,0x3
800063c4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800063c8:	70 2b       	ld.w	r11,r8[0x8]
800063ca:	8d 38       	st.w	r6[0xc],r8
800063cc:	8d 2b       	st.w	r6[0x8],r11
800063ce:	97 36       	st.w	r11[0xc],r6
800063d0:	91 26       	st.w	r8[0x8],r6
800063d2:	a3 49       	asr	r9,0x2
800063d4:	74 18       	ld.w	r8,r10[0x4]
800063d6:	30 1b       	mov	r11,1
800063d8:	f6 09 09 49 	lsl	r9,r11,r9
800063dc:	f1 e9 10 09 	or	r9,r8,r9
800063e0:	95 19       	st.w	r10[0x4],r9
800063e2:	c4 78       	rjmp	80006470 <_malloc_r+0x1e4>
800063e4:	f2 0a 16 09 	lsr	r10,r9,0x9
800063e8:	58 4a       	cp.w	r10,4
800063ea:	e0 8b 00 07 	brhi	800063f8 <_malloc_r+0x16c>
800063ee:	f2 0a 16 06 	lsr	r10,r9,0x6
800063f2:	2c 8a       	sub	r10,-56
800063f4:	c2 08       	rjmp	80006434 <_malloc_r+0x1a8>
800063f6:	d7 03       	nop
800063f8:	59 4a       	cp.w	r10,20
800063fa:	e0 8b 00 04 	brhi	80006402 <_malloc_r+0x176>
800063fe:	2a 5a       	sub	r10,-91
80006400:	c1 a8       	rjmp	80006434 <_malloc_r+0x1a8>
80006402:	e0 4a 00 54 	cp.w	r10,84
80006406:	e0 8b 00 06 	brhi	80006412 <_malloc_r+0x186>
8000640a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000640e:	29 2a       	sub	r10,-110
80006410:	c1 28       	rjmp	80006434 <_malloc_r+0x1a8>
80006412:	e0 4a 01 54 	cp.w	r10,340
80006416:	e0 8b 00 06 	brhi	80006422 <_malloc_r+0x196>
8000641a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000641e:	28 9a       	sub	r10,-119
80006420:	c0 a8       	rjmp	80006434 <_malloc_r+0x1a8>
80006422:	e0 4a 05 54 	cp.w	r10,1364
80006426:	e0 88 00 04 	brls	8000642e <_malloc_r+0x1a2>
8000642a:	37 ea       	mov	r10,126
8000642c:	c0 48       	rjmp	80006434 <_malloc_r+0x1a8>
8000642e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006432:	28 4a       	sub	r10,-124
80006434:	e0 6b 05 40 	mov	r11,1344
80006438:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000643c:	68 28       	ld.w	r8,r4[0x8]
8000643e:	08 38       	cp.w	r8,r4
80006440:	c0 e1       	brne	8000645c <_malloc_r+0x1d0>
80006442:	76 19       	ld.w	r9,r11[0x4]
80006444:	a3 4a       	asr	r10,0x2
80006446:	30 1e       	mov	lr,1
80006448:	fc 0a 09 4a 	lsl	r10,lr,r10
8000644c:	f3 ea 10 0a 	or	r10,r9,r10
80006450:	10 99       	mov	r9,r8
80006452:	97 1a       	st.w	r11[0x4],r10
80006454:	c0 a8       	rjmp	80006468 <_malloc_r+0x1dc>
80006456:	70 28       	ld.w	r8,r8[0x8]
80006458:	08 38       	cp.w	r8,r4
8000645a:	c0 60       	breq	80006466 <_malloc_r+0x1da>
8000645c:	70 1a       	ld.w	r10,r8[0x4]
8000645e:	e0 1a ff fc 	andl	r10,0xfffc
80006462:	14 39       	cp.w	r9,r10
80006464:	cf 93       	brcs	80006456 <_malloc_r+0x1ca>
80006466:	70 39       	ld.w	r9,r8[0xc]
80006468:	8d 39       	st.w	r6[0xc],r9
8000646a:	8d 28       	st.w	r6[0x8],r8
8000646c:	91 36       	st.w	r8[0xc],r6
8000646e:	93 26       	st.w	r9[0x8],r6
80006470:	e6 08 14 02 	asr	r8,r3,0x2
80006474:	30 1b       	mov	r11,1
80006476:	e0 64 05 40 	mov	r4,1344
8000647a:	f6 08 09 4b 	lsl	r11,r11,r8
8000647e:	68 18       	ld.w	r8,r4[0x4]
80006480:	10 3b       	cp.w	r11,r8
80006482:	e0 8b 00 6b 	brhi	80006558 <_malloc_r+0x2cc>
80006486:	f7 e8 00 09 	and	r9,r11,r8
8000648a:	c0 b1       	brne	800064a0 <_malloc_r+0x214>
8000648c:	e0 13 ff fc 	andl	r3,0xfffc
80006490:	a1 7b       	lsl	r11,0x1
80006492:	2f c3       	sub	r3,-4
80006494:	c0 38       	rjmp	8000649a <_malloc_r+0x20e>
80006496:	2f c3       	sub	r3,-4
80006498:	a1 7b       	lsl	r11,0x1
8000649a:	f7 e8 00 09 	and	r9,r11,r8
8000649e:	cf c0       	breq	80006496 <_malloc_r+0x20a>
800064a0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800064a4:	06 92       	mov	r2,r3
800064a6:	1c 91       	mov	r1,lr
800064a8:	62 36       	ld.w	r6,r1[0xc]
800064aa:	c2 e8       	rjmp	80006506 <_malloc_r+0x27a>
800064ac:	6c 1a       	ld.w	r10,r6[0x4]
800064ae:	e0 1a ff fc 	andl	r10,0xfffc
800064b2:	f4 07 01 08 	sub	r8,r10,r7
800064b6:	58 f8       	cp.w	r8,15
800064b8:	e0 8a 00 15 	brle	800064e2 <_malloc_r+0x256>
800064bc:	6c 3a       	ld.w	r10,r6[0xc]
800064be:	6c 29       	ld.w	r9,r6[0x8]
800064c0:	95 29       	st.w	r10[0x8],r9
800064c2:	93 3a       	st.w	r9[0xc],r10
800064c4:	0e 99       	mov	r9,r7
800064c6:	ec 07 00 07 	add	r7,r6,r7
800064ca:	a1 a9       	sbr	r9,0x0
800064cc:	99 37       	st.w	r12[0xc],r7
800064ce:	99 27       	st.w	r12[0x8],r7
800064d0:	8d 19       	st.w	r6[0x4],r9
800064d2:	ee 08 09 08 	st.w	r7[r8],r8
800064d6:	8f 2c       	st.w	r7[0x8],r12
800064d8:	8f 3c       	st.w	r7[0xc],r12
800064da:	a1 a8       	sbr	r8,0x0
800064dc:	0a 9c       	mov	r12,r5
800064de:	8f 18       	st.w	r7[0x4],r8
800064e0:	c0 d8       	rjmp	800064fa <_malloc_r+0x26e>
800064e2:	6c 39       	ld.w	r9,r6[0xc]
800064e4:	58 08       	cp.w	r8,0
800064e6:	c0 f5       	brlt	80006504 <_malloc_r+0x278>
800064e8:	ec 0a 00 0a 	add	r10,r6,r10
800064ec:	74 18       	ld.w	r8,r10[0x4]
800064ee:	a1 a8       	sbr	r8,0x0
800064f0:	0a 9c       	mov	r12,r5
800064f2:	95 18       	st.w	r10[0x4],r8
800064f4:	6c 28       	ld.w	r8,r6[0x8]
800064f6:	93 28       	st.w	r9[0x8],r8
800064f8:	91 39       	st.w	r8[0xc],r9
800064fa:	fe b0 f4 5f 	rcall	80004db8 <__malloc_unlock>
800064fe:	ec cc ff f8 	sub	r12,r6,-8
80006502:	d8 32       	popm	r0-r7,pc
80006504:	12 96       	mov	r6,r9
80006506:	02 36       	cp.w	r6,r1
80006508:	cd 21       	brne	800064ac <_malloc_r+0x220>
8000650a:	2f f2       	sub	r2,-1
8000650c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006510:	c0 30       	breq	80006516 <_malloc_r+0x28a>
80006512:	2f 81       	sub	r1,-8
80006514:	cc ab       	rjmp	800064a8 <_malloc_r+0x21c>
80006516:	1c 98       	mov	r8,lr
80006518:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000651c:	c0 81       	brne	8000652c <_malloc_r+0x2a0>
8000651e:	68 19       	ld.w	r9,r4[0x4]
80006520:	f6 08 11 ff 	rsub	r8,r11,-1
80006524:	f3 e8 00 08 	and	r8,r9,r8
80006528:	89 18       	st.w	r4[0x4],r8
8000652a:	c0 78       	rjmp	80006538 <_malloc_r+0x2ac>
8000652c:	f0 c9 00 08 	sub	r9,r8,8
80006530:	20 13       	sub	r3,1
80006532:	70 08       	ld.w	r8,r8[0x0]
80006534:	12 38       	cp.w	r8,r9
80006536:	cf 10       	breq	80006518 <_malloc_r+0x28c>
80006538:	a1 7b       	lsl	r11,0x1
8000653a:	68 18       	ld.w	r8,r4[0x4]
8000653c:	10 3b       	cp.w	r11,r8
8000653e:	e0 8b 00 0d 	brhi	80006558 <_malloc_r+0x2cc>
80006542:	58 0b       	cp.w	r11,0
80006544:	c0 a0       	breq	80006558 <_malloc_r+0x2cc>
80006546:	04 93       	mov	r3,r2
80006548:	c0 38       	rjmp	8000654e <_malloc_r+0x2c2>
8000654a:	2f c3       	sub	r3,-4
8000654c:	a1 7b       	lsl	r11,0x1
8000654e:	f7 e8 00 09 	and	r9,r11,r8
80006552:	ca 71       	brne	800064a0 <_malloc_r+0x214>
80006554:	cf bb       	rjmp	8000654a <_malloc_r+0x2be>
80006556:	d7 03       	nop
80006558:	68 23       	ld.w	r3,r4[0x8]
8000655a:	66 12       	ld.w	r2,r3[0x4]
8000655c:	e0 12 ff fc 	andl	r2,0xfffc
80006560:	0e 32       	cp.w	r2,r7
80006562:	5f 39       	srlo	r9
80006564:	e4 07 01 08 	sub	r8,r2,r7
80006568:	58 f8       	cp.w	r8,15
8000656a:	5f aa       	srle	r10
8000656c:	f5 e9 10 09 	or	r9,r10,r9
80006570:	e0 80 00 9a 	breq	800066a4 <_malloc_r+0x418>
80006574:	e0 68 0d 54 	mov	r8,3412
80006578:	70 01       	ld.w	r1,r8[0x0]
8000657a:	e0 68 09 4c 	mov	r8,2380
8000657e:	2f 01       	sub	r1,-16
80006580:	70 08       	ld.w	r8,r8[0x0]
80006582:	0e 01       	add	r1,r7
80006584:	5b f8       	cp.w	r8,-1
80006586:	c0 40       	breq	8000658e <_malloc_r+0x302>
80006588:	28 11       	sub	r1,-127
8000658a:	e0 11 ff 80 	andl	r1,0xff80
8000658e:	02 9b       	mov	r11,r1
80006590:	0a 9c       	mov	r12,r5
80006592:	e0 a0 02 a5 	rcall	80006adc <_sbrk_r>
80006596:	18 96       	mov	r6,r12
80006598:	5b fc       	cp.w	r12,-1
8000659a:	c7 50       	breq	80006684 <_malloc_r+0x3f8>
8000659c:	e6 02 00 08 	add	r8,r3,r2
800065a0:	10 3c       	cp.w	r12,r8
800065a2:	c0 32       	brcc	800065a8 <_malloc_r+0x31c>
800065a4:	08 33       	cp.w	r3,r4
800065a6:	c6 f1       	brne	80006684 <_malloc_r+0x3f8>
800065a8:	e0 6a 0d 58 	mov	r10,3416
800065ac:	74 09       	ld.w	r9,r10[0x0]
800065ae:	e2 09 00 09 	add	r9,r1,r9
800065b2:	95 09       	st.w	r10[0x0],r9
800065b4:	10 36       	cp.w	r6,r8
800065b6:	c0 a1       	brne	800065ca <_malloc_r+0x33e>
800065b8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800065bc:	c0 71       	brne	800065ca <_malloc_r+0x33e>
800065be:	e2 02 00 02 	add	r2,r1,r2
800065c2:	68 28       	ld.w	r8,r4[0x8]
800065c4:	a1 a2       	sbr	r2,0x0
800065c6:	91 12       	st.w	r8[0x4],r2
800065c8:	c4 f8       	rjmp	80006666 <_malloc_r+0x3da>
800065ca:	e0 6a 09 4c 	mov	r10,2380
800065ce:	74 0b       	ld.w	r11,r10[0x0]
800065d0:	5b fb       	cp.w	r11,-1
800065d2:	c0 31       	brne	800065d8 <_malloc_r+0x34c>
800065d4:	95 06       	st.w	r10[0x0],r6
800065d6:	c0 78       	rjmp	800065e4 <_malloc_r+0x358>
800065d8:	ec 09 00 09 	add	r9,r6,r9
800065dc:	e0 6a 0d 58 	mov	r10,3416
800065e0:	10 19       	sub	r9,r8
800065e2:	95 09       	st.w	r10[0x0],r9
800065e4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800065e8:	f0 09 11 08 	rsub	r9,r8,8
800065ec:	58 08       	cp.w	r8,0
800065ee:	f2 08 17 10 	movne	r8,r9
800065f2:	ed d8 e1 06 	addne	r6,r6,r8
800065f6:	28 08       	sub	r8,-128
800065f8:	ec 01 00 01 	add	r1,r6,r1
800065fc:	0a 9c       	mov	r12,r5
800065fe:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006602:	f0 01 01 01 	sub	r1,r8,r1
80006606:	02 9b       	mov	r11,r1
80006608:	e0 a0 02 6a 	rcall	80006adc <_sbrk_r>
8000660c:	e0 68 0d 58 	mov	r8,3416
80006610:	5b fc       	cp.w	r12,-1
80006612:	ec 0c 17 00 	moveq	r12,r6
80006616:	f9 b1 00 00 	moveq	r1,0
8000661a:	70 09       	ld.w	r9,r8[0x0]
8000661c:	0c 1c       	sub	r12,r6
8000661e:	89 26       	st.w	r4[0x8],r6
80006620:	02 0c       	add	r12,r1
80006622:	12 01       	add	r1,r9
80006624:	a1 ac       	sbr	r12,0x0
80006626:	91 01       	st.w	r8[0x0],r1
80006628:	8d 1c       	st.w	r6[0x4],r12
8000662a:	08 33       	cp.w	r3,r4
8000662c:	c1 d0       	breq	80006666 <_malloc_r+0x3da>
8000662e:	58 f2       	cp.w	r2,15
80006630:	e0 8b 00 05 	brhi	8000663a <_malloc_r+0x3ae>
80006634:	30 18       	mov	r8,1
80006636:	8d 18       	st.w	r6[0x4],r8
80006638:	c2 68       	rjmp	80006684 <_malloc_r+0x3f8>
8000663a:	30 59       	mov	r9,5
8000663c:	20 c2       	sub	r2,12
8000663e:	e0 12 ff f8 	andl	r2,0xfff8
80006642:	e6 02 00 08 	add	r8,r3,r2
80006646:	91 29       	st.w	r8[0x8],r9
80006648:	91 19       	st.w	r8[0x4],r9
8000664a:	66 18       	ld.w	r8,r3[0x4]
8000664c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006650:	e5 e8 10 08 	or	r8,r2,r8
80006654:	87 18       	st.w	r3[0x4],r8
80006656:	58 f2       	cp.w	r2,15
80006658:	e0 88 00 07 	brls	80006666 <_malloc_r+0x3da>
8000665c:	e6 cb ff f8 	sub	r11,r3,-8
80006660:	0a 9c       	mov	r12,r5
80006662:	e0 a0 1c 77 	rcall	80009f50 <_free_r>
80006666:	e0 69 0d 50 	mov	r9,3408
8000666a:	72 0a       	ld.w	r10,r9[0x0]
8000666c:	e0 68 0d 58 	mov	r8,3416
80006670:	70 08       	ld.w	r8,r8[0x0]
80006672:	14 38       	cp.w	r8,r10
80006674:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006678:	e0 69 0d 4c 	mov	r9,3404
8000667c:	72 0a       	ld.w	r10,r9[0x0]
8000667e:	14 38       	cp.w	r8,r10
80006680:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006684:	68 28       	ld.w	r8,r4[0x8]
80006686:	70 18       	ld.w	r8,r8[0x4]
80006688:	e0 18 ff fc 	andl	r8,0xfffc
8000668c:	0e 38       	cp.w	r8,r7
8000668e:	5f 39       	srlo	r9
80006690:	0e 18       	sub	r8,r7
80006692:	58 f8       	cp.w	r8,15
80006694:	5f aa       	srle	r10
80006696:	f5 e9 10 09 	or	r9,r10,r9
8000669a:	c0 50       	breq	800066a4 <_malloc_r+0x418>
8000669c:	0a 9c       	mov	r12,r5
8000669e:	fe b0 f3 8d 	rcall	80004db8 <__malloc_unlock>
800066a2:	d8 3a       	popm	r0-r7,pc,r12=0
800066a4:	68 26       	ld.w	r6,r4[0x8]
800066a6:	a1 a8       	sbr	r8,0x0
800066a8:	0e 99       	mov	r9,r7
800066aa:	a1 a9       	sbr	r9,0x0
800066ac:	8d 19       	st.w	r6[0x4],r9
800066ae:	ec 07 00 07 	add	r7,r6,r7
800066b2:	0a 9c       	mov	r12,r5
800066b4:	89 27       	st.w	r4[0x8],r7
800066b6:	8f 18       	st.w	r7[0x4],r8
800066b8:	fe b0 f3 80 	rcall	80004db8 <__malloc_unlock>
800066bc:	ec cc ff f8 	sub	r12,r6,-8
800066c0:	d8 32       	popm	r0-r7,pc
800066c2:	d7 03       	nop

800066c4 <memcpy>:
800066c4:	58 8a       	cp.w	r10,8
800066c6:	c2 f5       	brlt	80006724 <memcpy+0x60>
800066c8:	f9 eb 10 09 	or	r9,r12,r11
800066cc:	e2 19 00 03 	andl	r9,0x3,COH
800066d0:	e0 81 00 97 	brne	800067fe <memcpy+0x13a>
800066d4:	e0 4a 00 20 	cp.w	r10,32
800066d8:	c3 b4       	brge	8000674e <memcpy+0x8a>
800066da:	f4 08 14 02 	asr	r8,r10,0x2
800066de:	f0 09 11 08 	rsub	r9,r8,8
800066e2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800066e6:	76 69       	ld.w	r9,r11[0x18]
800066e8:	99 69       	st.w	r12[0x18],r9
800066ea:	76 59       	ld.w	r9,r11[0x14]
800066ec:	99 59       	st.w	r12[0x14],r9
800066ee:	76 49       	ld.w	r9,r11[0x10]
800066f0:	99 49       	st.w	r12[0x10],r9
800066f2:	76 39       	ld.w	r9,r11[0xc]
800066f4:	99 39       	st.w	r12[0xc],r9
800066f6:	76 29       	ld.w	r9,r11[0x8]
800066f8:	99 29       	st.w	r12[0x8],r9
800066fa:	76 19       	ld.w	r9,r11[0x4]
800066fc:	99 19       	st.w	r12[0x4],r9
800066fe:	76 09       	ld.w	r9,r11[0x0]
80006700:	99 09       	st.w	r12[0x0],r9
80006702:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006706:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000670a:	e0 1a 00 03 	andl	r10,0x3
8000670e:	f4 0a 11 04 	rsub	r10,r10,4
80006712:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006716:	17 a9       	ld.ub	r9,r11[0x2]
80006718:	b0 a9       	st.b	r8[0x2],r9
8000671a:	17 99       	ld.ub	r9,r11[0x1]
8000671c:	b0 99       	st.b	r8[0x1],r9
8000671e:	17 89       	ld.ub	r9,r11[0x0]
80006720:	b0 89       	st.b	r8[0x0],r9
80006722:	5e fc       	retal	r12
80006724:	f4 0a 11 09 	rsub	r10,r10,9
80006728:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000672c:	17 f9       	ld.ub	r9,r11[0x7]
8000672e:	b8 f9       	st.b	r12[0x7],r9
80006730:	17 e9       	ld.ub	r9,r11[0x6]
80006732:	b8 e9       	st.b	r12[0x6],r9
80006734:	17 d9       	ld.ub	r9,r11[0x5]
80006736:	b8 d9       	st.b	r12[0x5],r9
80006738:	17 c9       	ld.ub	r9,r11[0x4]
8000673a:	b8 c9       	st.b	r12[0x4],r9
8000673c:	17 b9       	ld.ub	r9,r11[0x3]
8000673e:	b8 b9       	st.b	r12[0x3],r9
80006740:	17 a9       	ld.ub	r9,r11[0x2]
80006742:	b8 a9       	st.b	r12[0x2],r9
80006744:	17 99       	ld.ub	r9,r11[0x1]
80006746:	b8 99       	st.b	r12[0x1],r9
80006748:	17 89       	ld.ub	r9,r11[0x0]
8000674a:	b8 89       	st.b	r12[0x0],r9
8000674c:	5e fc       	retal	r12
8000674e:	eb cd 40 c0 	pushm	r6-r7,lr
80006752:	18 99       	mov	r9,r12
80006754:	22 0a       	sub	r10,32
80006756:	b7 07       	ld.d	r6,r11++
80006758:	b3 26       	st.d	r9++,r6
8000675a:	b7 07       	ld.d	r6,r11++
8000675c:	b3 26       	st.d	r9++,r6
8000675e:	b7 07       	ld.d	r6,r11++
80006760:	b3 26       	st.d	r9++,r6
80006762:	b7 07       	ld.d	r6,r11++
80006764:	b3 26       	st.d	r9++,r6
80006766:	22 0a       	sub	r10,32
80006768:	cf 74       	brge	80006756 <memcpy+0x92>
8000676a:	2f 0a       	sub	r10,-16
8000676c:	c0 65       	brlt	80006778 <memcpy+0xb4>
8000676e:	b7 07       	ld.d	r6,r11++
80006770:	b3 26       	st.d	r9++,r6
80006772:	b7 07       	ld.d	r6,r11++
80006774:	b3 26       	st.d	r9++,r6
80006776:	21 0a       	sub	r10,16
80006778:	5c 3a       	neg	r10
8000677a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000677e:	d7 03       	nop
80006780:	d7 03       	nop
80006782:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006786:	f3 66 00 0e 	st.b	r9[14],r6
8000678a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000678e:	f3 66 00 0d 	st.b	r9[13],r6
80006792:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006796:	f3 66 00 0c 	st.b	r9[12],r6
8000679a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000679e:	f3 66 00 0b 	st.b	r9[11],r6
800067a2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800067a6:	f3 66 00 0a 	st.b	r9[10],r6
800067aa:	f7 36 00 09 	ld.ub	r6,r11[9]
800067ae:	f3 66 00 09 	st.b	r9[9],r6
800067b2:	f7 36 00 08 	ld.ub	r6,r11[8]
800067b6:	f3 66 00 08 	st.b	r9[8],r6
800067ba:	f7 36 00 07 	ld.ub	r6,r11[7]
800067be:	f3 66 00 07 	st.b	r9[7],r6
800067c2:	f7 36 00 06 	ld.ub	r6,r11[6]
800067c6:	f3 66 00 06 	st.b	r9[6],r6
800067ca:	f7 36 00 05 	ld.ub	r6,r11[5]
800067ce:	f3 66 00 05 	st.b	r9[5],r6
800067d2:	f7 36 00 04 	ld.ub	r6,r11[4]
800067d6:	f3 66 00 04 	st.b	r9[4],r6
800067da:	f7 36 00 03 	ld.ub	r6,r11[3]
800067de:	f3 66 00 03 	st.b	r9[3],r6
800067e2:	f7 36 00 02 	ld.ub	r6,r11[2]
800067e6:	f3 66 00 02 	st.b	r9[2],r6
800067ea:	f7 36 00 01 	ld.ub	r6,r11[1]
800067ee:	f3 66 00 01 	st.b	r9[1],r6
800067f2:	f7 36 00 00 	ld.ub	r6,r11[0]
800067f6:	f3 66 00 00 	st.b	r9[0],r6
800067fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067fe:	20 1a       	sub	r10,1
80006800:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006804:	f8 0a 0b 09 	st.b	r12[r10],r9
80006808:	cf b1       	brne	800067fe <memcpy+0x13a>
8000680a:	5e fc       	retal	r12

8000680c <memset>:
8000680c:	18 98       	mov	r8,r12
8000680e:	c0 38       	rjmp	80006814 <memset+0x8>
80006810:	10 cb       	st.b	r8++,r11
80006812:	20 1a       	sub	r10,1
80006814:	58 0a       	cp.w	r10,0
80006816:	cf d1       	brne	80006810 <memset+0x4>
80006818:	5e fc       	retal	r12
8000681a:	d7 03       	nop

8000681c <_realloc_r>:
8000681c:	d4 31       	pushm	r0-r7,lr
8000681e:	20 1d       	sub	sp,4
80006820:	16 94       	mov	r4,r11
80006822:	18 92       	mov	r2,r12
80006824:	14 9b       	mov	r11,r10
80006826:	58 04       	cp.w	r4,0
80006828:	c0 51       	brne	80006832 <_realloc_r+0x16>
8000682a:	fe b0 fd 31 	rcall	8000628c <_malloc_r>
8000682e:	18 95       	mov	r5,r12
80006830:	c5 39       	rjmp	80006ad6 <_realloc_r+0x2ba>
80006832:	50 0a       	stdsp	sp[0x0],r10
80006834:	fe b0 f2 bc 	rcall	80004dac <__malloc_lock>
80006838:	40 0b       	lddsp	r11,sp[0x0]
8000683a:	f6 c8 ff f5 	sub	r8,r11,-11
8000683e:	e8 c1 00 08 	sub	r1,r4,8
80006842:	10 96       	mov	r6,r8
80006844:	62 1c       	ld.w	r12,r1[0x4]
80006846:	e0 16 ff f8 	andl	r6,0xfff8
8000684a:	59 68       	cp.w	r8,22
8000684c:	f9 b6 08 10 	movls	r6,16
80006850:	16 36       	cp.w	r6,r11
80006852:	5f 38       	srlo	r8
80006854:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006858:	c0 50       	breq	80006862 <_realloc_r+0x46>
8000685a:	30 c8       	mov	r8,12
8000685c:	30 05       	mov	r5,0
8000685e:	85 38       	st.w	r2[0xc],r8
80006860:	c3 b9       	rjmp	80006ad6 <_realloc_r+0x2ba>
80006862:	18 90       	mov	r0,r12
80006864:	e0 10 ff fc 	andl	r0,0xfffc
80006868:	0c 30       	cp.w	r0,r6
8000686a:	e0 84 01 0b 	brge	80006a80 <_realloc_r+0x264>
8000686e:	e0 68 05 40 	mov	r8,1344
80006872:	e2 00 00 09 	add	r9,r1,r0
80006876:	70 25       	ld.w	r5,r8[0x8]
80006878:	0a 39       	cp.w	r9,r5
8000687a:	c0 90       	breq	8000688c <_realloc_r+0x70>
8000687c:	72 1a       	ld.w	r10,r9[0x4]
8000687e:	a1 ca       	cbr	r10,0x0
80006880:	f2 0a 00 0a 	add	r10,r9,r10
80006884:	74 1a       	ld.w	r10,r10[0x4]
80006886:	ed ba 00 00 	bld	r10,0x0
8000688a:	c2 20       	breq	800068ce <_realloc_r+0xb2>
8000688c:	72 1a       	ld.w	r10,r9[0x4]
8000688e:	e0 1a ff fc 	andl	r10,0xfffc
80006892:	f4 00 00 03 	add	r3,r10,r0
80006896:	0a 39       	cp.w	r9,r5
80006898:	c1 31       	brne	800068be <_realloc_r+0xa2>
8000689a:	ec c7 ff f0 	sub	r7,r6,-16
8000689e:	0e 33       	cp.w	r3,r7
800068a0:	c1 95       	brlt	800068d2 <_realloc_r+0xb6>
800068a2:	e2 06 00 09 	add	r9,r1,r6
800068a6:	0c 13       	sub	r3,r6
800068a8:	a1 a3       	sbr	r3,0x0
800068aa:	93 13       	st.w	r9[0x4],r3
800068ac:	91 29       	st.w	r8[0x8],r9
800068ae:	04 9c       	mov	r12,r2
800068b0:	62 18       	ld.w	r8,r1[0x4]
800068b2:	08 95       	mov	r5,r4
800068b4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068b8:	10 46       	or	r6,r8
800068ba:	83 16       	st.w	r1[0x4],r6
800068bc:	c0 b9       	rjmp	80006ad2 <_realloc_r+0x2b6>
800068be:	0c 33       	cp.w	r3,r6
800068c0:	c0 95       	brlt	800068d2 <_realloc_r+0xb6>
800068c2:	72 28       	ld.w	r8,r9[0x8]
800068c4:	02 97       	mov	r7,r1
800068c6:	72 39       	ld.w	r9,r9[0xc]
800068c8:	93 28       	st.w	r9[0x8],r8
800068ca:	91 39       	st.w	r8[0xc],r9
800068cc:	cd c8       	rjmp	80006a84 <_realloc_r+0x268>
800068ce:	30 0a       	mov	r10,0
800068d0:	14 99       	mov	r9,r10
800068d2:	ed bc 00 00 	bld	r12,0x0
800068d6:	e0 80 00 95 	breq	80006a00 <_realloc_r+0x1e4>
800068da:	62 07       	ld.w	r7,r1[0x0]
800068dc:	e2 07 01 07 	sub	r7,r1,r7
800068e0:	6e 1c       	ld.w	r12,r7[0x4]
800068e2:	e0 1c ff fc 	andl	r12,0xfffc
800068e6:	58 09       	cp.w	r9,0
800068e8:	c5 60       	breq	80006994 <_realloc_r+0x178>
800068ea:	f8 00 00 03 	add	r3,r12,r0
800068ee:	0a 39       	cp.w	r9,r5
800068f0:	c4 81       	brne	80006980 <_realloc_r+0x164>
800068f2:	14 03       	add	r3,r10
800068f4:	ec c9 ff f0 	sub	r9,r6,-16
800068f8:	12 33       	cp.w	r3,r9
800068fa:	c4 d5       	brlt	80006994 <_realloc_r+0x178>
800068fc:	6e 3a       	ld.w	r10,r7[0xc]
800068fe:	6e 29       	ld.w	r9,r7[0x8]
80006900:	95 29       	st.w	r10[0x8],r9
80006902:	93 3a       	st.w	r9[0xc],r10
80006904:	ee c5 ff f8 	sub	r5,r7,-8
80006908:	e0 ca 00 04 	sub	r10,r0,4
8000690c:	e0 4a 00 24 	cp.w	r10,36
80006910:	e0 8b 00 25 	brhi	8000695a <_realloc_r+0x13e>
80006914:	0a 99       	mov	r9,r5
80006916:	59 3a       	cp.w	r10,19
80006918:	e0 88 00 1a 	brls	8000694c <_realloc_r+0x130>
8000691c:	09 09       	ld.w	r9,r4++
8000691e:	8b 09       	st.w	r5[0x0],r9
80006920:	09 09       	ld.w	r9,r4++
80006922:	8f 39       	st.w	r7[0xc],r9
80006924:	ee c9 ff f0 	sub	r9,r7,-16
80006928:	59 ba       	cp.w	r10,27
8000692a:	e0 88 00 11 	brls	8000694c <_realloc_r+0x130>
8000692e:	09 0b       	ld.w	r11,r4++
80006930:	93 0b       	st.w	r9[0x0],r11
80006932:	09 09       	ld.w	r9,r4++
80006934:	8f 59       	st.w	r7[0x14],r9
80006936:	ee c9 ff e8 	sub	r9,r7,-24
8000693a:	e0 4a 00 24 	cp.w	r10,36
8000693e:	c0 71       	brne	8000694c <_realloc_r+0x130>
80006940:	09 0a       	ld.w	r10,r4++
80006942:	93 0a       	st.w	r9[0x0],r10
80006944:	ee c9 ff e0 	sub	r9,r7,-32
80006948:	09 0a       	ld.w	r10,r4++
8000694a:	8f 7a       	st.w	r7[0x1c],r10
8000694c:	09 0a       	ld.w	r10,r4++
8000694e:	12 aa       	st.w	r9++,r10
80006950:	68 0a       	ld.w	r10,r4[0x0]
80006952:	93 0a       	st.w	r9[0x0],r10
80006954:	68 1a       	ld.w	r10,r4[0x4]
80006956:	93 1a       	st.w	r9[0x4],r10
80006958:	c0 78       	rjmp	80006966 <_realloc_r+0x14a>
8000695a:	50 08       	stdsp	sp[0x0],r8
8000695c:	08 9b       	mov	r11,r4
8000695e:	0a 9c       	mov	r12,r5
80006960:	e0 a0 1d 9b 	rcall	8000a496 <memmove>
80006964:	40 08       	lddsp	r8,sp[0x0]
80006966:	ee 06 00 09 	add	r9,r7,r6
8000696a:	0c 13       	sub	r3,r6
8000696c:	a1 a3       	sbr	r3,0x0
8000696e:	93 13       	st.w	r9[0x4],r3
80006970:	91 29       	st.w	r8[0x8],r9
80006972:	04 9c       	mov	r12,r2
80006974:	6e 18       	ld.w	r8,r7[0x4]
80006976:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000697a:	10 46       	or	r6,r8
8000697c:	8f 16       	st.w	r7[0x4],r6
8000697e:	ca a8       	rjmp	80006ad2 <_realloc_r+0x2b6>
80006980:	14 03       	add	r3,r10
80006982:	0c 33       	cp.w	r3,r6
80006984:	c0 85       	brlt	80006994 <_realloc_r+0x178>
80006986:	72 28       	ld.w	r8,r9[0x8]
80006988:	72 39       	ld.w	r9,r9[0xc]
8000698a:	93 28       	st.w	r9[0x8],r8
8000698c:	91 39       	st.w	r8[0xc],r9
8000698e:	6e 28       	ld.w	r8,r7[0x8]
80006990:	6e 39       	ld.w	r9,r7[0xc]
80006992:	c0 78       	rjmp	800069a0 <_realloc_r+0x184>
80006994:	f8 00 00 03 	add	r3,r12,r0
80006998:	0c 33       	cp.w	r3,r6
8000699a:	c3 35       	brlt	80006a00 <_realloc_r+0x1e4>
8000699c:	6e 39       	ld.w	r9,r7[0xc]
8000699e:	6e 28       	ld.w	r8,r7[0x8]
800069a0:	93 28       	st.w	r9[0x8],r8
800069a2:	91 39       	st.w	r8[0xc],r9
800069a4:	e0 ca 00 04 	sub	r10,r0,4
800069a8:	ee cc ff f8 	sub	r12,r7,-8
800069ac:	e0 4a 00 24 	cp.w	r10,36
800069b0:	e0 8b 00 24 	brhi	800069f8 <_realloc_r+0x1dc>
800069b4:	59 3a       	cp.w	r10,19
800069b6:	e0 88 00 1a 	brls	800069ea <_realloc_r+0x1ce>
800069ba:	09 08       	ld.w	r8,r4++
800069bc:	99 08       	st.w	r12[0x0],r8
800069be:	09 08       	ld.w	r8,r4++
800069c0:	8f 38       	st.w	r7[0xc],r8
800069c2:	ee cc ff f0 	sub	r12,r7,-16
800069c6:	59 ba       	cp.w	r10,27
800069c8:	e0 88 00 11 	brls	800069ea <_realloc_r+0x1ce>
800069cc:	09 08       	ld.w	r8,r4++
800069ce:	99 08       	st.w	r12[0x0],r8
800069d0:	09 08       	ld.w	r8,r4++
800069d2:	8f 58       	st.w	r7[0x14],r8
800069d4:	ee cc ff e8 	sub	r12,r7,-24
800069d8:	e0 4a 00 24 	cp.w	r10,36
800069dc:	c0 71       	brne	800069ea <_realloc_r+0x1ce>
800069de:	09 08       	ld.w	r8,r4++
800069e0:	99 08       	st.w	r12[0x0],r8
800069e2:	ee cc ff e0 	sub	r12,r7,-32
800069e6:	09 08       	ld.w	r8,r4++
800069e8:	8f 78       	st.w	r7[0x1c],r8
800069ea:	09 08       	ld.w	r8,r4++
800069ec:	18 a8       	st.w	r12++,r8
800069ee:	68 08       	ld.w	r8,r4[0x0]
800069f0:	99 08       	st.w	r12[0x0],r8
800069f2:	68 18       	ld.w	r8,r4[0x4]
800069f4:	99 18       	st.w	r12[0x4],r8
800069f6:	c4 78       	rjmp	80006a84 <_realloc_r+0x268>
800069f8:	08 9b       	mov	r11,r4
800069fa:	e0 a0 1d 4e 	rcall	8000a496 <memmove>
800069fe:	c4 38       	rjmp	80006a84 <_realloc_r+0x268>
80006a00:	04 9c       	mov	r12,r2
80006a02:	fe b0 fc 45 	rcall	8000628c <_malloc_r>
80006a06:	18 95       	mov	r5,r12
80006a08:	c3 a0       	breq	80006a7c <_realloc_r+0x260>
80006a0a:	62 18       	ld.w	r8,r1[0x4]
80006a0c:	f8 c9 00 08 	sub	r9,r12,8
80006a10:	a1 c8       	cbr	r8,0x0
80006a12:	e2 08 00 08 	add	r8,r1,r8
80006a16:	10 39       	cp.w	r9,r8
80006a18:	c0 71       	brne	80006a26 <_realloc_r+0x20a>
80006a1a:	72 13       	ld.w	r3,r9[0x4]
80006a1c:	02 97       	mov	r7,r1
80006a1e:	e0 13 ff fc 	andl	r3,0xfffc
80006a22:	00 03       	add	r3,r0
80006a24:	c3 08       	rjmp	80006a84 <_realloc_r+0x268>
80006a26:	e0 ca 00 04 	sub	r10,r0,4
80006a2a:	e0 4a 00 24 	cp.w	r10,36
80006a2e:	e0 8b 00 20 	brhi	80006a6e <_realloc_r+0x252>
80006a32:	08 99       	mov	r9,r4
80006a34:	18 98       	mov	r8,r12
80006a36:	59 3a       	cp.w	r10,19
80006a38:	e0 88 00 14 	brls	80006a60 <_realloc_r+0x244>
80006a3c:	13 0b       	ld.w	r11,r9++
80006a3e:	10 ab       	st.w	r8++,r11
80006a40:	13 0b       	ld.w	r11,r9++
80006a42:	10 ab       	st.w	r8++,r11
80006a44:	59 ba       	cp.w	r10,27
80006a46:	e0 88 00 0d 	brls	80006a60 <_realloc_r+0x244>
80006a4a:	13 0b       	ld.w	r11,r9++
80006a4c:	10 ab       	st.w	r8++,r11
80006a4e:	13 0b       	ld.w	r11,r9++
80006a50:	10 ab       	st.w	r8++,r11
80006a52:	e0 4a 00 24 	cp.w	r10,36
80006a56:	c0 51       	brne	80006a60 <_realloc_r+0x244>
80006a58:	13 0a       	ld.w	r10,r9++
80006a5a:	10 aa       	st.w	r8++,r10
80006a5c:	13 0a       	ld.w	r10,r9++
80006a5e:	10 aa       	st.w	r8++,r10
80006a60:	13 0a       	ld.w	r10,r9++
80006a62:	10 aa       	st.w	r8++,r10
80006a64:	72 0a       	ld.w	r10,r9[0x0]
80006a66:	91 0a       	st.w	r8[0x0],r10
80006a68:	72 19       	ld.w	r9,r9[0x4]
80006a6a:	91 19       	st.w	r8[0x4],r9
80006a6c:	c0 48       	rjmp	80006a74 <_realloc_r+0x258>
80006a6e:	08 9b       	mov	r11,r4
80006a70:	e0 a0 1d 13 	rcall	8000a496 <memmove>
80006a74:	08 9b       	mov	r11,r4
80006a76:	04 9c       	mov	r12,r2
80006a78:	e0 a0 1a 6c 	rcall	80009f50 <_free_r>
80006a7c:	04 9c       	mov	r12,r2
80006a7e:	c2 a8       	rjmp	80006ad2 <_realloc_r+0x2b6>
80006a80:	00 93       	mov	r3,r0
80006a82:	02 97       	mov	r7,r1
80006a84:	e6 06 01 09 	sub	r9,r3,r6
80006a88:	6e 18       	ld.w	r8,r7[0x4]
80006a8a:	58 f9       	cp.w	r9,15
80006a8c:	e0 88 00 16 	brls	80006ab8 <_realloc_r+0x29c>
80006a90:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006a94:	ed e8 10 08 	or	r8,r6,r8
80006a98:	8f 18       	st.w	r7[0x4],r8
80006a9a:	12 98       	mov	r8,r9
80006a9c:	a1 a8       	sbr	r8,0x0
80006a9e:	ee 06 00 0b 	add	r11,r7,r6
80006aa2:	f6 09 00 09 	add	r9,r11,r9
80006aa6:	97 18       	st.w	r11[0x4],r8
80006aa8:	72 18       	ld.w	r8,r9[0x4]
80006aaa:	a1 a8       	sbr	r8,0x0
80006aac:	2f 8b       	sub	r11,-8
80006aae:	93 18       	st.w	r9[0x4],r8
80006ab0:	04 9c       	mov	r12,r2
80006ab2:	e0 a0 1a 4f 	rcall	80009f50 <_free_r>
80006ab6:	c0 b8       	rjmp	80006acc <_realloc_r+0x2b0>
80006ab8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006abc:	e7 e8 10 08 	or	r8,r3,r8
80006ac0:	8f 18       	st.w	r7[0x4],r8
80006ac2:	ee 03 00 03 	add	r3,r7,r3
80006ac6:	66 18       	ld.w	r8,r3[0x4]
80006ac8:	a1 a8       	sbr	r8,0x0
80006aca:	87 18       	st.w	r3[0x4],r8
80006acc:	04 9c       	mov	r12,r2
80006ace:	ee c5 ff f8 	sub	r5,r7,-8
80006ad2:	fe b0 f1 73 	rcall	80004db8 <__malloc_unlock>
80006ad6:	0a 9c       	mov	r12,r5
80006ad8:	2f fd       	sub	sp,-4
80006ada:	d8 32       	popm	r0-r7,pc

80006adc <_sbrk_r>:
80006adc:	d4 21       	pushm	r4-r7,lr
80006ade:	30 08       	mov	r8,0
80006ae0:	18 97       	mov	r7,r12
80006ae2:	e0 66 41 14 	mov	r6,16660
80006ae6:	16 9c       	mov	r12,r11
80006ae8:	8d 08       	st.w	r6[0x0],r8
80006aea:	c9 1c       	rcall	80006c0c <_sbrk>
80006aec:	5b fc       	cp.w	r12,-1
80006aee:	c0 51       	brne	80006af8 <_sbrk_r+0x1c>
80006af0:	6c 08       	ld.w	r8,r6[0x0]
80006af2:	58 08       	cp.w	r8,0
80006af4:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006af8:	d8 22       	popm	r4-r7,pc
80006afa:	d7 03       	nop

80006afc <sprintf>:
80006afc:	d4 01       	pushm	lr
80006afe:	21 7d       	sub	sp,92
80006b00:	e0 68 ff ff 	mov	r8,65535
80006b04:	ea 18 7f ff 	orh	r8,0x7fff
80006b08:	50 58       	stdsp	sp[0x14],r8
80006b0a:	50 28       	stdsp	sp[0x8],r8
80006b0c:	e0 68 02 08 	mov	r8,520
80006b10:	ba 68       	st.h	sp[0xc],r8
80006b12:	3f f8       	mov	r8,-1
80006b14:	ba 78       	st.h	sp[0xe],r8
80006b16:	e0 68 0a 40 	mov	r8,2624
80006b1a:	50 4c       	stdsp	sp[0x10],r12
80006b1c:	16 9a       	mov	r10,r11
80006b1e:	50 0c       	stdsp	sp[0x0],r12
80006b20:	fa c9 ff a0 	sub	r9,sp,-96
80006b24:	70 0c       	ld.w	r12,r8[0x0]
80006b26:	1a 9b       	mov	r11,sp
80006b28:	e0 a0 02 26 	rcall	80006f74 <_vfprintf_r>
80006b2c:	30 09       	mov	r9,0
80006b2e:	40 08       	lddsp	r8,sp[0x0]
80006b30:	b0 89       	st.b	r8[0x0],r9
80006b32:	2e 9d       	sub	sp,-92
80006b34:	d8 02       	popm	pc
80006b36:	d7 03       	nop

80006b38 <strlen>:
80006b38:	30 09       	mov	r9,0
80006b3a:	18 98       	mov	r8,r12
80006b3c:	c0 28       	rjmp	80006b40 <strlen+0x8>
80006b3e:	2f f8       	sub	r8,-1
80006b40:	11 8a       	ld.ub	r10,r8[0x0]
80006b42:	f2 0a 18 00 	cp.b	r10,r9
80006b46:	cf c1       	brne	80006b3e <strlen+0x6>
80006b48:	f0 0c 01 0c 	sub	r12,r8,r12
80006b4c:	5e fc       	retal	r12
80006b4e:	d7 03       	nop

80006b50 <strncpy>:
80006b50:	30 08       	mov	r8,0
80006b52:	10 3a       	cp.w	r10,r8
80006b54:	5e 0c       	reteq	r12
80006b56:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006b5a:	f8 08 0b 09 	st.b	r12[r8],r9
80006b5e:	2f f8       	sub	r8,-1
80006b60:	58 09       	cp.w	r9,0
80006b62:	cf 81       	brne	80006b52 <strncpy+0x2>
80006b64:	10 3a       	cp.w	r10,r8
80006b66:	5e 0c       	reteq	r12
80006b68:	f8 08 0b 09 	st.b	r12[r8],r9
80006b6c:	2f f8       	sub	r8,-1
80006b6e:	cf bb       	rjmp	80006b64 <strncpy+0x14>

80006b70 <_close>:
80006b70:	30 28       	mov	r8,2
80006b72:	d6 73       	breakpoint
80006b74:	3f fc       	mov	r12,-1
80006b76:	35 8b       	mov	r11,88
80006b78:	58 0c       	cp.w	r12,0
80006b7a:	5e 4c       	retge	r12
80006b7c:	e0 6a 41 14 	mov	r10,16660
80006b80:	95 0b       	st.w	r10[0x0],r11
80006b82:	5e fc       	retal	r12

80006b84 <_lseek>:
80006b84:	30 58       	mov	r8,5
80006b86:	d6 73       	breakpoint
80006b88:	3f fc       	mov	r12,-1
80006b8a:	35 8b       	mov	r11,88
80006b8c:	58 0c       	cp.w	r12,0
80006b8e:	5e 4c       	retge	r12
80006b90:	e0 6a 41 14 	mov	r10,16660
80006b94:	95 0b       	st.w	r10[0x0],r11
80006b96:	5e fc       	retal	r12

80006b98 <isatty>:
80006b98:	30 b8       	mov	r8,11
80006b9a:	d6 73       	breakpoint
80006b9c:	3f fc       	mov	r12,-1
80006b9e:	35 8b       	mov	r11,88
80006ba0:	58 0c       	cp.w	r12,0
80006ba2:	5e 4c       	retge	r12
80006ba4:	e0 6a 41 14 	mov	r10,16660
80006ba8:	95 0b       	st.w	r10[0x0],r11
80006baa:	5e fc       	retal	r12

80006bac <_fstat_host>:
80006bac:	30 98       	mov	r8,9
80006bae:	d6 73       	breakpoint
80006bb0:	3f fc       	mov	r12,-1
80006bb2:	35 8b       	mov	r11,88
80006bb4:	58 0c       	cp.w	r12,0
80006bb6:	5e 4c       	retge	r12
80006bb8:	e0 6a 41 14 	mov	r10,16660
80006bbc:	95 0b       	st.w	r10[0x0],r11
80006bbe:	5e fc       	retal	r12

80006bc0 <_fstat>:
80006bc0:	d4 21       	pushm	r4-r7,lr
80006bc2:	21 0d       	sub	sp,64
80006bc4:	16 97       	mov	r7,r11
80006bc6:	1a 9b       	mov	r11,sp
80006bc8:	cf 2f       	rcall	80006bac <_fstat_host>
80006bca:	c0 34       	brge	80006bd0 <_fstat+0x10>
80006bcc:	3f fc       	mov	r12,-1
80006bce:	c1 c8       	rjmp	80006c06 <_fstat+0x46>
80006bd0:	40 08       	lddsp	r8,sp[0x0]
80006bd2:	ae 08       	st.h	r7[0x0],r8
80006bd4:	40 18       	lddsp	r8,sp[0x4]
80006bd6:	ae 18       	st.h	r7[0x2],r8
80006bd8:	40 28       	lddsp	r8,sp[0x8]
80006bda:	8f 18       	st.w	r7[0x4],r8
80006bdc:	40 38       	lddsp	r8,sp[0xc]
80006bde:	ae 48       	st.h	r7[0x8],r8
80006be0:	40 48       	lddsp	r8,sp[0x10]
80006be2:	ae 58       	st.h	r7[0xa],r8
80006be4:	40 58       	lddsp	r8,sp[0x14]
80006be6:	ae 68       	st.h	r7[0xc],r8
80006be8:	40 68       	lddsp	r8,sp[0x18]
80006bea:	ae 78       	st.h	r7[0xe],r8
80006bec:	40 88       	lddsp	r8,sp[0x20]
80006bee:	8f 48       	st.w	r7[0x10],r8
80006bf0:	40 a8       	lddsp	r8,sp[0x28]
80006bf2:	8f b8       	st.w	r7[0x2c],r8
80006bf4:	40 c8       	lddsp	r8,sp[0x30]
80006bf6:	8f c8       	st.w	r7[0x30],r8
80006bf8:	40 d8       	lddsp	r8,sp[0x34]
80006bfa:	8f 58       	st.w	r7[0x14],r8
80006bfc:	40 e8       	lddsp	r8,sp[0x38]
80006bfe:	30 0c       	mov	r12,0
80006c00:	8f 78       	st.w	r7[0x1c],r8
80006c02:	40 f8       	lddsp	r8,sp[0x3c]
80006c04:	8f 98       	st.w	r7[0x24],r8
80006c06:	2f 0d       	sub	sp,-64
80006c08:	d8 22       	popm	r4-r7,pc
80006c0a:	d7 03       	nop

80006c0c <_sbrk>:
80006c0c:	d4 01       	pushm	lr
80006c0e:	e0 68 0d 80 	mov	r8,3456
80006c12:	70 09       	ld.w	r9,r8[0x0]
80006c14:	58 09       	cp.w	r9,0
80006c16:	c0 41       	brne	80006c1e <_sbrk+0x12>
80006c18:	e0 69 41 18 	mov	r9,16664
80006c1c:	91 09       	st.w	r8[0x0],r9
80006c1e:	e0 69 0d 80 	mov	r9,3456
80006c22:	e0 7a 70 00 	mov	r10,94208
80006c26:	72 08       	ld.w	r8,r9[0x0]
80006c28:	f0 0c 00 0c 	add	r12,r8,r12
80006c2c:	14 3c       	cp.w	r12,r10
80006c2e:	e0 8b 00 04 	brhi	80006c36 <_sbrk+0x2a>
80006c32:	93 0c       	st.w	r9[0x0],r12
80006c34:	c0 68       	rjmp	80006c40 <_sbrk+0x34>
80006c36:	e0 a0 18 15 	rcall	80009c60 <__errno>
80006c3a:	30 c8       	mov	r8,12
80006c3c:	99 08       	st.w	r12[0x0],r8
80006c3e:	3f f8       	mov	r8,-1
80006c40:	10 9c       	mov	r12,r8
80006c42:	d8 02       	popm	pc

80006c44 <get_arg>:
80006c44:	d4 31       	pushm	r0-r7,lr
80006c46:	20 8d       	sub	sp,32
80006c48:	fa c4 ff bc 	sub	r4,sp,-68
80006c4c:	50 4b       	stdsp	sp[0x10],r11
80006c4e:	68 2e       	ld.w	lr,r4[0x8]
80006c50:	50 58       	stdsp	sp[0x14],r8
80006c52:	12 96       	mov	r6,r9
80006c54:	7c 0b       	ld.w	r11,lr[0x0]
80006c56:	70 05       	ld.w	r5,r8[0x0]
80006c58:	50 6e       	stdsp	sp[0x18],lr
80006c5a:	58 0b       	cp.w	r11,0
80006c5c:	f4 0b 17 00 	moveq	r11,r10
80006c60:	68 03       	ld.w	r3,r4[0x0]
80006c62:	68 11       	ld.w	r1,r4[0x4]
80006c64:	40 49       	lddsp	r9,sp[0x10]
80006c66:	30 08       	mov	r8,0
80006c68:	c2 89       	rjmp	80006eb8 <get_arg+0x274>
80006c6a:	2f fb       	sub	r11,-1
80006c6c:	32 5c       	mov	r12,37
80006c6e:	17 8a       	ld.ub	r10,r11[0x0]
80006c70:	f8 0a 18 00 	cp.b	r10,r12
80006c74:	5f 1e       	srne	lr
80006c76:	f0 0a 18 00 	cp.b	r10,r8
80006c7a:	5f 1c       	srne	r12
80006c7c:	fd ec 00 0c 	and	r12,lr,r12
80006c80:	f0 0c 18 00 	cp.b	r12,r8
80006c84:	cf 31       	brne	80006c6a <get_arg+0x26>
80006c86:	58 0a       	cp.w	r10,0
80006c88:	e0 80 01 25 	breq	80006ed2 <get_arg+0x28e>
80006c8c:	30 0c       	mov	r12,0
80006c8e:	3f fa       	mov	r10,-1
80006c90:	18 90       	mov	r0,r12
80006c92:	50 3a       	stdsp	sp[0xc],r10
80006c94:	18 94       	mov	r4,r12
80006c96:	18 92       	mov	r2,r12
80006c98:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006c9c:	16 97       	mov	r7,r11
80006c9e:	50 7c       	stdsp	sp[0x1c],r12
80006ca0:	fe cc a0 20 	sub	r12,pc,-24544
80006ca4:	0f 3a       	ld.ub	r10,r7++
80006ca6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006caa:	40 7c       	lddsp	r12,sp[0x1c]
80006cac:	1c 0c       	add	r12,lr
80006cae:	fe ce a0 f6 	sub	lr,pc,-24330
80006cb2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006cb6:	20 1e       	sub	lr,1
80006cb8:	50 0e       	stdsp	sp[0x0],lr
80006cba:	fe ce a1 6e 	sub	lr,pc,-24210
80006cbe:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006cc2:	50 7c       	stdsp	sp[0x1c],r12
80006cc4:	40 0c       	lddsp	r12,sp[0x0]
80006cc6:	58 7c       	cp.w	r12,7
80006cc8:	e0 8b 00 f1 	brhi	80006eaa <get_arg+0x266>
80006ccc:	fe ce a3 20 	sub	lr,pc,-23776
80006cd0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006cd4:	36 8b       	mov	r11,104
80006cd6:	f6 0a 18 00 	cp.b	r10,r11
80006cda:	e0 80 00 e8 	breq	80006eaa <get_arg+0x266>
80006cde:	37 1b       	mov	r11,113
80006ce0:	f6 0a 18 00 	cp.b	r10,r11
80006ce4:	c0 70       	breq	80006cf2 <get_arg+0xae>
80006ce6:	34 cb       	mov	r11,76
80006ce8:	f6 0a 18 00 	cp.b	r10,r11
80006cec:	c0 51       	brne	80006cf6 <get_arg+0xb2>
80006cee:	a3 b4       	sbr	r4,0x3
80006cf0:	cd d8       	rjmp	80006eaa <get_arg+0x266>
80006cf2:	a5 b4       	sbr	r4,0x5
80006cf4:	cd b8       	rjmp	80006eaa <get_arg+0x266>
80006cf6:	08 9a       	mov	r10,r4
80006cf8:	0e 9b       	mov	r11,r7
80006cfa:	a5 aa       	sbr	r10,0x4
80006cfc:	17 3c       	ld.ub	r12,r11++
80006cfe:	a5 b4       	sbr	r4,0x5
80006d00:	36 ce       	mov	lr,108
80006d02:	fc 0c 18 00 	cp.b	r12,lr
80006d06:	e0 80 00 d3 	breq	80006eac <get_arg+0x268>
80006d0a:	14 94       	mov	r4,r10
80006d0c:	cc f8       	rjmp	80006eaa <get_arg+0x266>
80006d0e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006d12:	36 7c       	mov	r12,103
80006d14:	f8 0a 18 00 	cp.b	r10,r12
80006d18:	e0 8b 00 27 	brhi	80006d66 <get_arg+0x122>
80006d1c:	36 5b       	mov	r11,101
80006d1e:	f6 0a 18 00 	cp.b	r10,r11
80006d22:	c4 82       	brcc	80006db2 <get_arg+0x16e>
80006d24:	34 fb       	mov	r11,79
80006d26:	f6 0a 18 00 	cp.b	r10,r11
80006d2a:	c4 80       	breq	80006dba <get_arg+0x176>
80006d2c:	e0 8b 00 0c 	brhi	80006d44 <get_arg+0x100>
80006d30:	34 5b       	mov	r11,69
80006d32:	f6 0a 18 00 	cp.b	r10,r11
80006d36:	c3 e0       	breq	80006db2 <get_arg+0x16e>
80006d38:	34 7b       	mov	r11,71
80006d3a:	f6 0a 18 00 	cp.b	r10,r11
80006d3e:	c3 a0       	breq	80006db2 <get_arg+0x16e>
80006d40:	34 4b       	mov	r11,68
80006d42:	c0 88       	rjmp	80006d52 <get_arg+0x10e>
80006d44:	35 8b       	mov	r11,88
80006d46:	f6 0a 18 00 	cp.b	r10,r11
80006d4a:	c2 c0       	breq	80006da2 <get_arg+0x15e>
80006d4c:	e0 8b 00 07 	brhi	80006d5a <get_arg+0x116>
80006d50:	35 5b       	mov	r11,85
80006d52:	f6 0a 18 00 	cp.b	r10,r11
80006d56:	c3 51       	brne	80006dc0 <get_arg+0x17c>
80006d58:	c3 18       	rjmp	80006dba <get_arg+0x176>
80006d5a:	36 3b       	mov	r11,99
80006d5c:	f6 0a 18 00 	cp.b	r10,r11
80006d60:	c2 f0       	breq	80006dbe <get_arg+0x17a>
80006d62:	36 4b       	mov	r11,100
80006d64:	c0 e8       	rjmp	80006d80 <get_arg+0x13c>
80006d66:	37 0b       	mov	r11,112
80006d68:	f6 0a 18 00 	cp.b	r10,r11
80006d6c:	c2 50       	breq	80006db6 <get_arg+0x172>
80006d6e:	e0 8b 00 0d 	brhi	80006d88 <get_arg+0x144>
80006d72:	36 eb       	mov	r11,110
80006d74:	f6 0a 18 00 	cp.b	r10,r11
80006d78:	c1 f0       	breq	80006db6 <get_arg+0x172>
80006d7a:	e0 8b 00 14 	brhi	80006da2 <get_arg+0x15e>
80006d7e:	36 9b       	mov	r11,105
80006d80:	f6 0a 18 00 	cp.b	r10,r11
80006d84:	c1 e1       	brne	80006dc0 <get_arg+0x17c>
80006d86:	c0 e8       	rjmp	80006da2 <get_arg+0x15e>
80006d88:	37 5b       	mov	r11,117
80006d8a:	f6 0a 18 00 	cp.b	r10,r11
80006d8e:	c0 a0       	breq	80006da2 <get_arg+0x15e>
80006d90:	37 8b       	mov	r11,120
80006d92:	f6 0a 18 00 	cp.b	r10,r11
80006d96:	c0 60       	breq	80006da2 <get_arg+0x15e>
80006d98:	37 3b       	mov	r11,115
80006d9a:	f6 0a 18 00 	cp.b	r10,r11
80006d9e:	c1 11       	brne	80006dc0 <get_arg+0x17c>
80006da0:	c0 b8       	rjmp	80006db6 <get_arg+0x172>
80006da2:	ed b4 00 04 	bld	r4,0x4
80006da6:	c0 a0       	breq	80006dba <get_arg+0x176>
80006da8:	ed b4 00 05 	bld	r4,0x5
80006dac:	c0 91       	brne	80006dbe <get_arg+0x17a>
80006dae:	30 20       	mov	r0,2
80006db0:	c0 88       	rjmp	80006dc0 <get_arg+0x17c>
80006db2:	30 40       	mov	r0,4
80006db4:	c0 68       	rjmp	80006dc0 <get_arg+0x17c>
80006db6:	30 30       	mov	r0,3
80006db8:	c0 48       	rjmp	80006dc0 <get_arg+0x17c>
80006dba:	30 10       	mov	r0,1
80006dbc:	c0 28       	rjmp	80006dc0 <get_arg+0x17c>
80006dbe:	30 00       	mov	r0,0
80006dc0:	40 3b       	lddsp	r11,sp[0xc]
80006dc2:	5b fb       	cp.w	r11,-1
80006dc4:	c0 40       	breq	80006dcc <get_arg+0x188>
80006dc6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006dca:	c7 08       	rjmp	80006eaa <get_arg+0x266>
80006dcc:	58 60       	cp.w	r0,6
80006dce:	e0 8b 00 6e 	brhi	80006eaa <get_arg+0x266>
80006dd2:	6c 0a       	ld.w	r10,r6[0x0]
80006dd4:	ea cc ff ff 	sub	r12,r5,-1
80006dd8:	fe ce a4 0c 	sub	lr,pc,-23540
80006ddc:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006de0:	f4 cb ff f8 	sub	r11,r10,-8
80006de4:	8d 0b       	st.w	r6[0x0],r11
80006de6:	f4 ea 00 00 	ld.d	r10,r10[0]
80006dea:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006dee:	c0 f8       	rjmp	80006e0c <get_arg+0x1c8>
80006df0:	f4 cb ff fc 	sub	r11,r10,-4
80006df4:	8d 0b       	st.w	r6[0x0],r11
80006df6:	74 0a       	ld.w	r10,r10[0x0]
80006df8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006dfc:	c0 88       	rjmp	80006e0c <get_arg+0x1c8>
80006dfe:	f4 cb ff f8 	sub	r11,r10,-8
80006e02:	8d 0b       	st.w	r6[0x0],r11
80006e04:	f4 ea 00 00 	ld.d	r10,r10[0]
80006e08:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006e0c:	0e 9b       	mov	r11,r7
80006e0e:	18 95       	mov	r5,r12
80006e10:	c4 e8       	rjmp	80006eac <get_arg+0x268>
80006e12:	62 0a       	ld.w	r10,r1[0x0]
80006e14:	5b fa       	cp.w	r10,-1
80006e16:	c0 b1       	brne	80006e2c <get_arg+0x1e8>
80006e18:	50 19       	stdsp	sp[0x4],r9
80006e1a:	50 28       	stdsp	sp[0x8],r8
80006e1c:	e0 6a 00 80 	mov	r10,128
80006e20:	30 0b       	mov	r11,0
80006e22:	02 9c       	mov	r12,r1
80006e24:	fe b0 fc f4 	rcall	8000680c <memset>
80006e28:	40 28       	lddsp	r8,sp[0x8]
80006e2a:	40 19       	lddsp	r9,sp[0x4]
80006e2c:	e4 cc 00 01 	sub	r12,r2,1
80006e30:	0e 9b       	mov	r11,r7
80006e32:	50 3c       	stdsp	sp[0xc],r12
80006e34:	f2 0c 0c 49 	max	r9,r9,r12
80006e38:	c3 a8       	rjmp	80006eac <get_arg+0x268>
80006e3a:	62 0a       	ld.w	r10,r1[0x0]
80006e3c:	5b fa       	cp.w	r10,-1
80006e3e:	c0 b1       	brne	80006e54 <get_arg+0x210>
80006e40:	50 19       	stdsp	sp[0x4],r9
80006e42:	50 28       	stdsp	sp[0x8],r8
80006e44:	e0 6a 00 80 	mov	r10,128
80006e48:	30 0b       	mov	r11,0
80006e4a:	02 9c       	mov	r12,r1
80006e4c:	fe b0 fc e0 	rcall	8000680c <memset>
80006e50:	40 28       	lddsp	r8,sp[0x8]
80006e52:	40 19       	lddsp	r9,sp[0x4]
80006e54:	20 12       	sub	r2,1
80006e56:	30 0a       	mov	r10,0
80006e58:	0e 9b       	mov	r11,r7
80006e5a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006e5e:	f2 02 0c 49 	max	r9,r9,r2
80006e62:	c2 58       	rjmp	80006eac <get_arg+0x268>
80006e64:	16 97       	mov	r7,r11
80006e66:	6c 0a       	ld.w	r10,r6[0x0]
80006e68:	f4 cb ff fc 	sub	r11,r10,-4
80006e6c:	8d 0b       	st.w	r6[0x0],r11
80006e6e:	74 0a       	ld.w	r10,r10[0x0]
80006e70:	0e 9b       	mov	r11,r7
80006e72:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006e76:	2f f5       	sub	r5,-1
80006e78:	c1 a8       	rjmp	80006eac <get_arg+0x268>
80006e7a:	f4 c2 00 30 	sub	r2,r10,48
80006e7e:	c0 68       	rjmp	80006e8a <get_arg+0x246>
80006e80:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006e84:	2f f7       	sub	r7,-1
80006e86:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006e8a:	0f 8a       	ld.ub	r10,r7[0x0]
80006e8c:	58 0a       	cp.w	r10,0
80006e8e:	c0 e0       	breq	80006eaa <get_arg+0x266>
80006e90:	23 0a       	sub	r10,48
80006e92:	58 9a       	cp.w	r10,9
80006e94:	fe 98 ff f6 	brls	80006e80 <get_arg+0x23c>
80006e98:	c0 98       	rjmp	80006eaa <get_arg+0x266>
80006e9a:	2f f7       	sub	r7,-1
80006e9c:	0f 8a       	ld.ub	r10,r7[0x0]
80006e9e:	58 0a       	cp.w	r10,0
80006ea0:	c0 50       	breq	80006eaa <get_arg+0x266>
80006ea2:	23 0a       	sub	r10,48
80006ea4:	58 9a       	cp.w	r10,9
80006ea6:	fe 98 ff fa 	brls	80006e9a <get_arg+0x256>
80006eaa:	0e 9b       	mov	r11,r7
80006eac:	40 7c       	lddsp	r12,sp[0x1c]
80006eae:	30 ba       	mov	r10,11
80006eb0:	f4 0c 18 00 	cp.b	r12,r10
80006eb4:	fe 91 fe f2 	brne	80006c98 <get_arg+0x54>
80006eb8:	40 42       	lddsp	r2,sp[0x10]
80006eba:	17 8c       	ld.ub	r12,r11[0x0]
80006ebc:	0a 32       	cp.w	r2,r5
80006ebe:	5f 4a       	srge	r10
80006ec0:	f0 0c 18 00 	cp.b	r12,r8
80006ec4:	5f 1c       	srne	r12
80006ec6:	f9 ea 00 0a 	and	r10,r12,r10
80006eca:	f0 0a 18 00 	cp.b	r10,r8
80006ece:	fe 91 fe cf 	brne	80006c6c <get_arg+0x28>
80006ed2:	30 08       	mov	r8,0
80006ed4:	40 4e       	lddsp	lr,sp[0x10]
80006ed6:	17 8a       	ld.ub	r10,r11[0x0]
80006ed8:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006edc:	f0 0a 18 00 	cp.b	r10,r8
80006ee0:	fc 09 17 10 	movne	r9,lr
80006ee4:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006ee8:	06 9e       	mov	lr,r3
80006eea:	c2 a8       	rjmp	80006f3e <get_arg+0x2fa>
80006eec:	62 0a       	ld.w	r10,r1[0x0]
80006eee:	58 3a       	cp.w	r10,3
80006ef0:	c1 e0       	breq	80006f2c <get_arg+0x2e8>
80006ef2:	e0 89 00 07 	brgt	80006f00 <get_arg+0x2bc>
80006ef6:	58 1a       	cp.w	r10,1
80006ef8:	c1 a0       	breq	80006f2c <get_arg+0x2e8>
80006efa:	58 2a       	cp.w	r10,2
80006efc:	c1 81       	brne	80006f2c <get_arg+0x2e8>
80006efe:	c0 58       	rjmp	80006f08 <get_arg+0x2c4>
80006f00:	58 5a       	cp.w	r10,5
80006f02:	c0 c0       	breq	80006f1a <get_arg+0x2d6>
80006f04:	c0 b5       	brlt	80006f1a <get_arg+0x2d6>
80006f06:	c1 38       	rjmp	80006f2c <get_arg+0x2e8>
80006f08:	6c 0a       	ld.w	r10,r6[0x0]
80006f0a:	f4 cc ff f8 	sub	r12,r10,-8
80006f0e:	8d 0c       	st.w	r6[0x0],r12
80006f10:	f4 e2 00 00 	ld.d	r2,r10[0]
80006f14:	f0 e3 00 00 	st.d	r8[0],r2
80006f18:	c1 08       	rjmp	80006f38 <get_arg+0x2f4>
80006f1a:	6c 0a       	ld.w	r10,r6[0x0]
80006f1c:	f4 cc ff f8 	sub	r12,r10,-8
80006f20:	8d 0c       	st.w	r6[0x0],r12
80006f22:	f4 e2 00 00 	ld.d	r2,r10[0]
80006f26:	f0 e3 00 00 	st.d	r8[0],r2
80006f2a:	c0 78       	rjmp	80006f38 <get_arg+0x2f4>
80006f2c:	6c 0a       	ld.w	r10,r6[0x0]
80006f2e:	f4 cc ff fc 	sub	r12,r10,-4
80006f32:	8d 0c       	st.w	r6[0x0],r12
80006f34:	74 0a       	ld.w	r10,r10[0x0]
80006f36:	91 0a       	st.w	r8[0x0],r10
80006f38:	2f f5       	sub	r5,-1
80006f3a:	2f 88       	sub	r8,-8
80006f3c:	2f c1       	sub	r1,-4
80006f3e:	12 35       	cp.w	r5,r9
80006f40:	fe 9a ff d6 	brle	80006eec <get_arg+0x2a8>
80006f44:	1c 93       	mov	r3,lr
80006f46:	40 52       	lddsp	r2,sp[0x14]
80006f48:	40 6e       	lddsp	lr,sp[0x18]
80006f4a:	85 05       	st.w	r2[0x0],r5
80006f4c:	9d 0b       	st.w	lr[0x0],r11
80006f4e:	40 4b       	lddsp	r11,sp[0x10]
80006f50:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006f54:	2f 8d       	sub	sp,-32
80006f56:	d8 32       	popm	r0-r7,pc

80006f58 <__sprint_r>:
80006f58:	d4 21       	pushm	r4-r7,lr
80006f5a:	14 97       	mov	r7,r10
80006f5c:	74 28       	ld.w	r8,r10[0x8]
80006f5e:	58 08       	cp.w	r8,0
80006f60:	c0 41       	brne	80006f68 <__sprint_r+0x10>
80006f62:	95 18       	st.w	r10[0x4],r8
80006f64:	10 9c       	mov	r12,r8
80006f66:	d8 22       	popm	r4-r7,pc
80006f68:	e0 a0 18 ba 	rcall	8000a0dc <__sfvwrite_r>
80006f6c:	30 08       	mov	r8,0
80006f6e:	8f 18       	st.w	r7[0x4],r8
80006f70:	8f 28       	st.w	r7[0x8],r8
80006f72:	d8 22       	popm	r4-r7,pc

80006f74 <_vfprintf_r>:
80006f74:	d4 31       	pushm	r0-r7,lr
80006f76:	fa cd 06 bc 	sub	sp,sp,1724
80006f7a:	51 09       	stdsp	sp[0x40],r9
80006f7c:	16 91       	mov	r1,r11
80006f7e:	14 97       	mov	r7,r10
80006f80:	18 95       	mov	r5,r12
80006f82:	e0 a0 1a 1d 	rcall	8000a3bc <_localeconv_r>
80006f86:	78 0c       	ld.w	r12,r12[0x0]
80006f88:	50 cc       	stdsp	sp[0x30],r12
80006f8a:	58 05       	cp.w	r5,0
80006f8c:	c0 70       	breq	80006f9a <_vfprintf_r+0x26>
80006f8e:	6a 68       	ld.w	r8,r5[0x18]
80006f90:	58 08       	cp.w	r8,0
80006f92:	c0 41       	brne	80006f9a <_vfprintf_r+0x26>
80006f94:	0a 9c       	mov	r12,r5
80006f96:	e0 a0 17 43 	rcall	80009e1c <__sinit>
80006f9a:	fe c8 a2 0a 	sub	r8,pc,-24054
80006f9e:	10 31       	cp.w	r1,r8
80006fa0:	c0 31       	brne	80006fa6 <_vfprintf_r+0x32>
80006fa2:	6a 01       	ld.w	r1,r5[0x0]
80006fa4:	c0 c8       	rjmp	80006fbc <_vfprintf_r+0x48>
80006fa6:	fe c8 a1 f6 	sub	r8,pc,-24074
80006faa:	10 31       	cp.w	r1,r8
80006fac:	c0 31       	brne	80006fb2 <_vfprintf_r+0x3e>
80006fae:	6a 11       	ld.w	r1,r5[0x4]
80006fb0:	c0 68       	rjmp	80006fbc <_vfprintf_r+0x48>
80006fb2:	fe c8 a1 e2 	sub	r8,pc,-24094
80006fb6:	10 31       	cp.w	r1,r8
80006fb8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006fbc:	82 68       	ld.sh	r8,r1[0xc]
80006fbe:	ed b8 00 03 	bld	r8,0x3
80006fc2:	c0 41       	brne	80006fca <_vfprintf_r+0x56>
80006fc4:	62 48       	ld.w	r8,r1[0x10]
80006fc6:	58 08       	cp.w	r8,0
80006fc8:	c0 71       	brne	80006fd6 <_vfprintf_r+0x62>
80006fca:	02 9b       	mov	r11,r1
80006fcc:	0a 9c       	mov	r12,r5
80006fce:	e0 a0 0f 5d 	rcall	80008e88 <__swsetup_r>
80006fd2:	e0 81 0f 54 	brne	80008e7a <_vfprintf_r+0x1f06>
80006fd6:	82 68       	ld.sh	r8,r1[0xc]
80006fd8:	10 99       	mov	r9,r8
80006fda:	e2 19 00 1a 	andl	r9,0x1a,COH
80006fde:	58 a9       	cp.w	r9,10
80006fe0:	c3 c1       	brne	80007058 <_vfprintf_r+0xe4>
80006fe2:	82 79       	ld.sh	r9,r1[0xe]
80006fe4:	30 0a       	mov	r10,0
80006fe6:	f4 09 19 00 	cp.h	r9,r10
80006fea:	c3 75       	brlt	80007058 <_vfprintf_r+0xe4>
80006fec:	a1 d8       	cbr	r8,0x1
80006fee:	fb 58 05 d0 	st.h	sp[1488],r8
80006ff2:	62 88       	ld.w	r8,r1[0x20]
80006ff4:	fb 48 05 e4 	st.w	sp[1508],r8
80006ff8:	62 a8       	ld.w	r8,r1[0x28]
80006ffa:	fb 48 05 ec 	st.w	sp[1516],r8
80006ffe:	fa c8 ff bc 	sub	r8,sp,-68
80007002:	fb 48 05 d4 	st.w	sp[1492],r8
80007006:	fb 48 05 c4 	st.w	sp[1476],r8
8000700a:	e0 68 04 00 	mov	r8,1024
8000700e:	fb 48 05 d8 	st.w	sp[1496],r8
80007012:	fb 48 05 cc 	st.w	sp[1484],r8
80007016:	30 08       	mov	r8,0
80007018:	fb 59 05 d2 	st.h	sp[1490],r9
8000701c:	0e 9a       	mov	r10,r7
8000701e:	41 09       	lddsp	r9,sp[0x40]
80007020:	fa c7 fa 3c 	sub	r7,sp,-1476
80007024:	fb 48 05 dc 	st.w	sp[1500],r8
80007028:	0a 9c       	mov	r12,r5
8000702a:	0e 9b       	mov	r11,r7
8000702c:	ca 4f       	rcall	80006f74 <_vfprintf_r>
8000702e:	50 bc       	stdsp	sp[0x2c],r12
80007030:	c0 95       	brlt	80007042 <_vfprintf_r+0xce>
80007032:	0e 9b       	mov	r11,r7
80007034:	0a 9c       	mov	r12,r5
80007036:	e0 a0 16 1b 	rcall	80009c6c <_fflush_r>
8000703a:	40 be       	lddsp	lr,sp[0x2c]
8000703c:	f9 be 01 ff 	movne	lr,-1
80007040:	50 be       	stdsp	sp[0x2c],lr
80007042:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007046:	ed b8 00 06 	bld	r8,0x6
8000704a:	e0 81 0f 1a 	brne	80008e7e <_vfprintf_r+0x1f0a>
8000704e:	82 68       	ld.sh	r8,r1[0xc]
80007050:	a7 a8       	sbr	r8,0x6
80007052:	a2 68       	st.h	r1[0xc],r8
80007054:	e0 8f 0f 15 	bral	80008e7e <_vfprintf_r+0x1f0a>
80007058:	30 08       	mov	r8,0
8000705a:	fb 48 06 b4 	st.w	sp[1716],r8
8000705e:	fb 48 06 90 	st.w	sp[1680],r8
80007062:	fb 48 06 8c 	st.w	sp[1676],r8
80007066:	fb 48 06 b0 	st.w	sp[1712],r8
8000706a:	30 08       	mov	r8,0
8000706c:	30 09       	mov	r9,0
8000706e:	50 a7       	stdsp	sp[0x28],r7
80007070:	50 78       	stdsp	sp[0x1c],r8
80007072:	fa c3 f9 e0 	sub	r3,sp,-1568
80007076:	3f f8       	mov	r8,-1
80007078:	50 59       	stdsp	sp[0x14],r9
8000707a:	fb 43 06 88 	st.w	sp[1672],r3
8000707e:	fb 48 05 44 	st.w	sp[1348],r8
80007082:	12 9c       	mov	r12,r9
80007084:	50 69       	stdsp	sp[0x18],r9
80007086:	50 d9       	stdsp	sp[0x34],r9
80007088:	50 e9       	stdsp	sp[0x38],r9
8000708a:	50 b9       	stdsp	sp[0x2c],r9
8000708c:	12 97       	mov	r7,r9
8000708e:	0a 94       	mov	r4,r5
80007090:	40 a2       	lddsp	r2,sp[0x28]
80007092:	32 5a       	mov	r10,37
80007094:	30 08       	mov	r8,0
80007096:	c0 28       	rjmp	8000709a <_vfprintf_r+0x126>
80007098:	2f f2       	sub	r2,-1
8000709a:	05 89       	ld.ub	r9,r2[0x0]
8000709c:	f0 09 18 00 	cp.b	r9,r8
800070a0:	5f 1b       	srne	r11
800070a2:	f4 09 18 00 	cp.b	r9,r10
800070a6:	5f 19       	srne	r9
800070a8:	f3 eb 00 0b 	and	r11,r9,r11
800070ac:	f0 0b 18 00 	cp.b	r11,r8
800070b0:	cf 41       	brne	80007098 <_vfprintf_r+0x124>
800070b2:	40 ab       	lddsp	r11,sp[0x28]
800070b4:	e4 0b 01 06 	sub	r6,r2,r11
800070b8:	c1 e0       	breq	800070f4 <_vfprintf_r+0x180>
800070ba:	fa f8 06 90 	ld.w	r8,sp[1680]
800070be:	0c 08       	add	r8,r6
800070c0:	87 0b       	st.w	r3[0x0],r11
800070c2:	fb 48 06 90 	st.w	sp[1680],r8
800070c6:	87 16       	st.w	r3[0x4],r6
800070c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800070cc:	2f f8       	sub	r8,-1
800070ce:	fb 48 06 8c 	st.w	sp[1676],r8
800070d2:	58 78       	cp.w	r8,7
800070d4:	e0 89 00 04 	brgt	800070dc <_vfprintf_r+0x168>
800070d8:	2f 83       	sub	r3,-8
800070da:	c0 a8       	rjmp	800070ee <_vfprintf_r+0x17a>
800070dc:	fa ca f9 78 	sub	r10,sp,-1672
800070e0:	02 9b       	mov	r11,r1
800070e2:	08 9c       	mov	r12,r4
800070e4:	c3 af       	rcall	80006f58 <__sprint_r>
800070e6:	e0 81 0e c6 	brne	80008e72 <_vfprintf_r+0x1efe>
800070ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800070ee:	40 ba       	lddsp	r10,sp[0x2c]
800070f0:	0c 0a       	add	r10,r6
800070f2:	50 ba       	stdsp	sp[0x2c],r10
800070f4:	05 89       	ld.ub	r9,r2[0x0]
800070f6:	30 08       	mov	r8,0
800070f8:	f0 09 18 00 	cp.b	r9,r8
800070fc:	e0 80 0e aa 	breq	80008e50 <_vfprintf_r+0x1edc>
80007100:	30 09       	mov	r9,0
80007102:	fb 68 06 bb 	st.b	sp[1723],r8
80007106:	0e 96       	mov	r6,r7
80007108:	e4 c8 ff ff 	sub	r8,r2,-1
8000710c:	3f fe       	mov	lr,-1
8000710e:	50 93       	stdsp	sp[0x24],r3
80007110:	50 41       	stdsp	sp[0x10],r1
80007112:	0e 93       	mov	r3,r7
80007114:	04 91       	mov	r1,r2
80007116:	50 89       	stdsp	sp[0x20],r9
80007118:	50 a8       	stdsp	sp[0x28],r8
8000711a:	50 2e       	stdsp	sp[0x8],lr
8000711c:	50 39       	stdsp	sp[0xc],r9
8000711e:	12 95       	mov	r5,r9
80007120:	12 90       	mov	r0,r9
80007122:	10 97       	mov	r7,r8
80007124:	08 92       	mov	r2,r4
80007126:	c0 78       	rjmp	80007134 <_vfprintf_r+0x1c0>
80007128:	3f fc       	mov	r12,-1
8000712a:	08 97       	mov	r7,r4
8000712c:	50 2c       	stdsp	sp[0x8],r12
8000712e:	c0 38       	rjmp	80007134 <_vfprintf_r+0x1c0>
80007130:	30 0b       	mov	r11,0
80007132:	50 3b       	stdsp	sp[0xc],r11
80007134:	0f 38       	ld.ub	r8,r7++
80007136:	c0 28       	rjmp	8000713a <_vfprintf_r+0x1c6>
80007138:	12 90       	mov	r0,r9
8000713a:	f0 c9 00 20 	sub	r9,r8,32
8000713e:	e0 49 00 58 	cp.w	r9,88
80007142:	e0 8b 0a 30 	brhi	800085a2 <_vfprintf_r+0x162e>
80007146:	fe ca a7 5e 	sub	r10,pc,-22690
8000714a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000714e:	50 a7       	stdsp	sp[0x28],r7
80007150:	50 80       	stdsp	sp[0x20],r0
80007152:	0c 97       	mov	r7,r6
80007154:	04 94       	mov	r4,r2
80007156:	06 96       	mov	r6,r3
80007158:	02 92       	mov	r2,r1
8000715a:	fe c9 a5 36 	sub	r9,pc,-23242
8000715e:	40 93       	lddsp	r3,sp[0x24]
80007160:	10 90       	mov	r0,r8
80007162:	40 41       	lddsp	r1,sp[0x10]
80007164:	50 d9       	stdsp	sp[0x34],r9
80007166:	e0 8f 08 8e 	bral	80008282 <_vfprintf_r+0x130e>
8000716a:	30 08       	mov	r8,0
8000716c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007170:	f0 09 18 00 	cp.b	r9,r8
80007174:	ce 01       	brne	80007134 <_vfprintf_r+0x1c0>
80007176:	32 08       	mov	r8,32
80007178:	c6 e8       	rjmp	80007254 <_vfprintf_r+0x2e0>
8000717a:	a1 a5       	sbr	r5,0x0
8000717c:	cd cb       	rjmp	80007134 <_vfprintf_r+0x1c0>
8000717e:	0f 89       	ld.ub	r9,r7[0x0]
80007180:	f2 c8 00 30 	sub	r8,r9,48
80007184:	58 98       	cp.w	r8,9
80007186:	e0 8b 00 1d 	brhi	800071c0 <_vfprintf_r+0x24c>
8000718a:	ee c8 ff ff 	sub	r8,r7,-1
8000718e:	30 0b       	mov	r11,0
80007190:	23 09       	sub	r9,48
80007192:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007196:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000719a:	11 39       	ld.ub	r9,r8++
8000719c:	f2 ca 00 30 	sub	r10,r9,48
800071a0:	58 9a       	cp.w	r10,9
800071a2:	fe 98 ff f7 	brls	80007190 <_vfprintf_r+0x21c>
800071a6:	e0 49 00 24 	cp.w	r9,36
800071aa:	cc 31       	brne	80007130 <_vfprintf_r+0x1bc>
800071ac:	e0 4b 00 20 	cp.w	r11,32
800071b0:	e0 89 0e 60 	brgt	80008e70 <_vfprintf_r+0x1efc>
800071b4:	20 1b       	sub	r11,1
800071b6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800071ba:	12 3b       	cp.w	r11,r9
800071bc:	c0 95       	brlt	800071ce <_vfprintf_r+0x25a>
800071be:	c1 08       	rjmp	800071de <_vfprintf_r+0x26a>
800071c0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800071c4:	ec ca ff ff 	sub	r10,r6,-1
800071c8:	12 36       	cp.w	r6,r9
800071ca:	c1 f5       	brlt	80007208 <_vfprintf_r+0x294>
800071cc:	c2 68       	rjmp	80007218 <_vfprintf_r+0x2a4>
800071ce:	fa ce f9 44 	sub	lr,sp,-1724
800071d2:	10 97       	mov	r7,r8
800071d4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800071d8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800071dc:	c3 58       	rjmp	80007246 <_vfprintf_r+0x2d2>
800071de:	10 97       	mov	r7,r8
800071e0:	fa c8 f9 50 	sub	r8,sp,-1712
800071e4:	1a d8       	st.w	--sp,r8
800071e6:	fa c8 fa b8 	sub	r8,sp,-1352
800071ea:	1a d8       	st.w	--sp,r8
800071ec:	fa c8 fb b4 	sub	r8,sp,-1100
800071f0:	02 9a       	mov	r10,r1
800071f2:	1a d8       	st.w	--sp,r8
800071f4:	04 9c       	mov	r12,r2
800071f6:	fa c8 f9 40 	sub	r8,sp,-1728
800071fa:	fa c9 ff b4 	sub	r9,sp,-76
800071fe:	fe b0 fd 23 	rcall	80006c44 <get_arg>
80007202:	2f dd       	sub	sp,-12
80007204:	78 00       	ld.w	r0,r12[0x0]
80007206:	c2 08       	rjmp	80007246 <_vfprintf_r+0x2d2>
80007208:	fa cc f9 44 	sub	r12,sp,-1724
8000720c:	14 96       	mov	r6,r10
8000720e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007212:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007216:	c1 88       	rjmp	80007246 <_vfprintf_r+0x2d2>
80007218:	41 08       	lddsp	r8,sp[0x40]
8000721a:	59 f9       	cp.w	r9,31
8000721c:	e0 89 00 11 	brgt	8000723e <_vfprintf_r+0x2ca>
80007220:	f0 cb ff fc 	sub	r11,r8,-4
80007224:	51 0b       	stdsp	sp[0x40],r11
80007226:	70 00       	ld.w	r0,r8[0x0]
80007228:	fa cb f9 44 	sub	r11,sp,-1724
8000722c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007230:	f1 40 fd 88 	st.w	r8[-632],r0
80007234:	2f f9       	sub	r9,-1
80007236:	14 96       	mov	r6,r10
80007238:	fb 49 06 b4 	st.w	sp[1716],r9
8000723c:	c0 58       	rjmp	80007246 <_vfprintf_r+0x2d2>
8000723e:	70 00       	ld.w	r0,r8[0x0]
80007240:	14 96       	mov	r6,r10
80007242:	2f c8       	sub	r8,-4
80007244:	51 08       	stdsp	sp[0x40],r8
80007246:	58 00       	cp.w	r0,0
80007248:	fe 94 ff 76 	brge	80007134 <_vfprintf_r+0x1c0>
8000724c:	5c 30       	neg	r0
8000724e:	a3 a5       	sbr	r5,0x2
80007250:	c7 2b       	rjmp	80007134 <_vfprintf_r+0x1c0>
80007252:	32 b8       	mov	r8,43
80007254:	fb 68 06 bb 	st.b	sp[1723],r8
80007258:	c6 eb       	rjmp	80007134 <_vfprintf_r+0x1c0>
8000725a:	0f 38       	ld.ub	r8,r7++
8000725c:	e0 48 00 2a 	cp.w	r8,42
80007260:	c0 30       	breq	80007266 <_vfprintf_r+0x2f2>
80007262:	30 09       	mov	r9,0
80007264:	c7 98       	rjmp	80007356 <_vfprintf_r+0x3e2>
80007266:	0f 88       	ld.ub	r8,r7[0x0]
80007268:	f0 c9 00 30 	sub	r9,r8,48
8000726c:	58 99       	cp.w	r9,9
8000726e:	e0 8b 00 1f 	brhi	800072ac <_vfprintf_r+0x338>
80007272:	ee c4 ff ff 	sub	r4,r7,-1
80007276:	30 0b       	mov	r11,0
80007278:	23 08       	sub	r8,48
8000727a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000727e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007282:	09 38       	ld.ub	r8,r4++
80007284:	f0 c9 00 30 	sub	r9,r8,48
80007288:	58 99       	cp.w	r9,9
8000728a:	fe 98 ff f7 	brls	80007278 <_vfprintf_r+0x304>
8000728e:	e0 48 00 24 	cp.w	r8,36
80007292:	fe 91 ff 4f 	brne	80007130 <_vfprintf_r+0x1bc>
80007296:	e0 4b 00 20 	cp.w	r11,32
8000729a:	e0 89 0d eb 	brgt	80008e70 <_vfprintf_r+0x1efc>
8000729e:	20 1b       	sub	r11,1
800072a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800072a4:	10 3b       	cp.w	r11,r8
800072a6:	c0 a5       	brlt	800072ba <_vfprintf_r+0x346>
800072a8:	c1 18       	rjmp	800072ca <_vfprintf_r+0x356>
800072aa:	d7 03       	nop
800072ac:	fa fa 06 b4 	ld.w	r10,sp[1716]
800072b0:	ec c9 ff ff 	sub	r9,r6,-1
800072b4:	14 36       	cp.w	r6,r10
800072b6:	c1 f5       	brlt	800072f4 <_vfprintf_r+0x380>
800072b8:	c2 88       	rjmp	80007308 <_vfprintf_r+0x394>
800072ba:	fa ca f9 44 	sub	r10,sp,-1724
800072be:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800072c2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800072c6:	50 2b       	stdsp	sp[0x8],r11
800072c8:	c3 c8       	rjmp	80007340 <_vfprintf_r+0x3cc>
800072ca:	fa c8 f9 50 	sub	r8,sp,-1712
800072ce:	1a d8       	st.w	--sp,r8
800072d0:	fa c8 fa b8 	sub	r8,sp,-1352
800072d4:	1a d8       	st.w	--sp,r8
800072d6:	fa c8 fb b4 	sub	r8,sp,-1100
800072da:	02 9a       	mov	r10,r1
800072dc:	1a d8       	st.w	--sp,r8
800072de:	04 9c       	mov	r12,r2
800072e0:	fa c8 f9 40 	sub	r8,sp,-1728
800072e4:	fa c9 ff b4 	sub	r9,sp,-76
800072e8:	fe b0 fc ae 	rcall	80006c44 <get_arg>
800072ec:	2f dd       	sub	sp,-12
800072ee:	78 0c       	ld.w	r12,r12[0x0]
800072f0:	50 2c       	stdsp	sp[0x8],r12
800072f2:	c2 78       	rjmp	80007340 <_vfprintf_r+0x3cc>
800072f4:	12 96       	mov	r6,r9
800072f6:	0e 94       	mov	r4,r7
800072f8:	fa c9 f9 44 	sub	r9,sp,-1724
800072fc:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007300:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007304:	50 28       	stdsp	sp[0x8],r8
80007306:	c1 d8       	rjmp	80007340 <_vfprintf_r+0x3cc>
80007308:	41 08       	lddsp	r8,sp[0x40]
8000730a:	59 fa       	cp.w	r10,31
8000730c:	e0 89 00 14 	brgt	80007334 <_vfprintf_r+0x3c0>
80007310:	f0 cb ff fc 	sub	r11,r8,-4
80007314:	70 08       	ld.w	r8,r8[0x0]
80007316:	51 0b       	stdsp	sp[0x40],r11
80007318:	50 28       	stdsp	sp[0x8],r8
8000731a:	fa c6 f9 44 	sub	r6,sp,-1724
8000731e:	40 2e       	lddsp	lr,sp[0x8]
80007320:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007324:	f1 4e fd 88 	st.w	r8[-632],lr
80007328:	2f fa       	sub	r10,-1
8000732a:	0e 94       	mov	r4,r7
8000732c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007330:	12 96       	mov	r6,r9
80007332:	c0 78       	rjmp	80007340 <_vfprintf_r+0x3cc>
80007334:	70 0c       	ld.w	r12,r8[0x0]
80007336:	0e 94       	mov	r4,r7
80007338:	2f c8       	sub	r8,-4
8000733a:	50 2c       	stdsp	sp[0x8],r12
8000733c:	12 96       	mov	r6,r9
8000733e:	51 08       	stdsp	sp[0x40],r8
80007340:	40 2b       	lddsp	r11,sp[0x8]
80007342:	58 0b       	cp.w	r11,0
80007344:	fe 95 fe f2 	brlt	80007128 <_vfprintf_r+0x1b4>
80007348:	08 97       	mov	r7,r4
8000734a:	cf 5a       	rjmp	80007134 <_vfprintf_r+0x1c0>
8000734c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007350:	0f 38       	ld.ub	r8,r7++
80007352:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007356:	f0 ca 00 30 	sub	r10,r8,48
8000735a:	58 9a       	cp.w	r10,9
8000735c:	fe 98 ff f8 	brls	8000734c <_vfprintf_r+0x3d8>
80007360:	3f fa       	mov	r10,-1
80007362:	f2 0a 0c 49 	max	r9,r9,r10
80007366:	50 29       	stdsp	sp[0x8],r9
80007368:	ce 9a       	rjmp	8000713a <_vfprintf_r+0x1c6>
8000736a:	a7 b5       	sbr	r5,0x7
8000736c:	ce 4a       	rjmp	80007134 <_vfprintf_r+0x1c0>
8000736e:	30 09       	mov	r9,0
80007370:	23 08       	sub	r8,48
80007372:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007376:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000737a:	0f 38       	ld.ub	r8,r7++
8000737c:	f0 ca 00 30 	sub	r10,r8,48
80007380:	58 9a       	cp.w	r10,9
80007382:	fe 98 ff f7 	brls	80007370 <_vfprintf_r+0x3fc>
80007386:	e0 48 00 24 	cp.w	r8,36
8000738a:	fe 91 fe d7 	brne	80007138 <_vfprintf_r+0x1c4>
8000738e:	e0 49 00 20 	cp.w	r9,32
80007392:	e0 89 0d 6f 	brgt	80008e70 <_vfprintf_r+0x1efc>
80007396:	f2 c3 00 01 	sub	r3,r9,1
8000739a:	30 19       	mov	r9,1
8000739c:	50 39       	stdsp	sp[0xc],r9
8000739e:	cc ba       	rjmp	80007134 <_vfprintf_r+0x1c0>
800073a0:	a3 b5       	sbr	r5,0x3
800073a2:	cc 9a       	rjmp	80007134 <_vfprintf_r+0x1c0>
800073a4:	a7 a5       	sbr	r5,0x6
800073a6:	cc 7a       	rjmp	80007134 <_vfprintf_r+0x1c0>
800073a8:	0a 98       	mov	r8,r5
800073aa:	a5 b5       	sbr	r5,0x5
800073ac:	a5 a8       	sbr	r8,0x4
800073ae:	0f 89       	ld.ub	r9,r7[0x0]
800073b0:	36 ce       	mov	lr,108
800073b2:	fc 09 18 00 	cp.b	r9,lr
800073b6:	f7 b7 00 ff 	subeq	r7,-1
800073ba:	f0 05 17 10 	movne	r5,r8
800073be:	cb ba       	rjmp	80007134 <_vfprintf_r+0x1c0>
800073c0:	a5 b5       	sbr	r5,0x5
800073c2:	cb 9a       	rjmp	80007134 <_vfprintf_r+0x1c0>
800073c4:	50 a7       	stdsp	sp[0x28],r7
800073c6:	50 80       	stdsp	sp[0x20],r0
800073c8:	0c 97       	mov	r7,r6
800073ca:	10 90       	mov	r0,r8
800073cc:	06 96       	mov	r6,r3
800073ce:	04 94       	mov	r4,r2
800073d0:	40 93       	lddsp	r3,sp[0x24]
800073d2:	02 92       	mov	r2,r1
800073d4:	0e 99       	mov	r9,r7
800073d6:	40 41       	lddsp	r1,sp[0x10]
800073d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073dc:	40 3c       	lddsp	r12,sp[0xc]
800073de:	58 0c       	cp.w	r12,0
800073e0:	c1 d0       	breq	8000741a <_vfprintf_r+0x4a6>
800073e2:	10 36       	cp.w	r6,r8
800073e4:	c0 64       	brge	800073f0 <_vfprintf_r+0x47c>
800073e6:	fa cb f9 44 	sub	r11,sp,-1724
800073ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800073ee:	c1 d8       	rjmp	80007428 <_vfprintf_r+0x4b4>
800073f0:	fa c8 f9 50 	sub	r8,sp,-1712
800073f4:	1a d8       	st.w	--sp,r8
800073f6:	fa c8 fa b8 	sub	r8,sp,-1352
800073fa:	1a d8       	st.w	--sp,r8
800073fc:	fa c8 fb b4 	sub	r8,sp,-1100
80007400:	1a d8       	st.w	--sp,r8
80007402:	fa c8 f9 40 	sub	r8,sp,-1728
80007406:	fa c9 ff b4 	sub	r9,sp,-76
8000740a:	04 9a       	mov	r10,r2
8000740c:	0c 9b       	mov	r11,r6
8000740e:	08 9c       	mov	r12,r4
80007410:	fe b0 fc 1a 	rcall	80006c44 <get_arg>
80007414:	2f dd       	sub	sp,-12
80007416:	19 b8       	ld.ub	r8,r12[0x3]
80007418:	c2 28       	rjmp	8000745c <_vfprintf_r+0x4e8>
8000741a:	2f f7       	sub	r7,-1
8000741c:	10 39       	cp.w	r9,r8
8000741e:	c0 84       	brge	8000742e <_vfprintf_r+0x4ba>
80007420:	fa ca f9 44 	sub	r10,sp,-1724
80007424:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007428:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000742c:	c1 88       	rjmp	8000745c <_vfprintf_r+0x4e8>
8000742e:	41 09       	lddsp	r9,sp[0x40]
80007430:	59 f8       	cp.w	r8,31
80007432:	e0 89 00 12 	brgt	80007456 <_vfprintf_r+0x4e2>
80007436:	f2 ca ff fc 	sub	r10,r9,-4
8000743a:	51 0a       	stdsp	sp[0x40],r10
8000743c:	72 09       	ld.w	r9,r9[0x0]
8000743e:	fa c6 f9 44 	sub	r6,sp,-1724
80007442:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007446:	2f f8       	sub	r8,-1
80007448:	f5 49 fd 88 	st.w	r10[-632],r9
8000744c:	fb 48 06 b4 	st.w	sp[1716],r8
80007450:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007454:	c0 48       	rjmp	8000745c <_vfprintf_r+0x4e8>
80007456:	13 b8       	ld.ub	r8,r9[0x3]
80007458:	2f c9       	sub	r9,-4
8000745a:	51 09       	stdsp	sp[0x40],r9
8000745c:	fb 68 06 60 	st.b	sp[1632],r8
80007460:	30 0e       	mov	lr,0
80007462:	30 08       	mov	r8,0
80007464:	30 12       	mov	r2,1
80007466:	fb 68 06 bb 	st.b	sp[1723],r8
8000746a:	50 2e       	stdsp	sp[0x8],lr
8000746c:	e0 8f 08 ad 	bral	800085c6 <_vfprintf_r+0x1652>
80007470:	50 a7       	stdsp	sp[0x28],r7
80007472:	50 80       	stdsp	sp[0x20],r0
80007474:	0c 97       	mov	r7,r6
80007476:	04 94       	mov	r4,r2
80007478:	06 96       	mov	r6,r3
8000747a:	02 92       	mov	r2,r1
8000747c:	40 93       	lddsp	r3,sp[0x24]
8000747e:	10 90       	mov	r0,r8
80007480:	40 41       	lddsp	r1,sp[0x10]
80007482:	a5 a5       	sbr	r5,0x4
80007484:	c0 a8       	rjmp	80007498 <_vfprintf_r+0x524>
80007486:	50 a7       	stdsp	sp[0x28],r7
80007488:	50 80       	stdsp	sp[0x20],r0
8000748a:	0c 97       	mov	r7,r6
8000748c:	04 94       	mov	r4,r2
8000748e:	06 96       	mov	r6,r3
80007490:	02 92       	mov	r2,r1
80007492:	40 93       	lddsp	r3,sp[0x24]
80007494:	10 90       	mov	r0,r8
80007496:	40 41       	lddsp	r1,sp[0x10]
80007498:	ed b5 00 05 	bld	r5,0x5
8000749c:	c5 11       	brne	8000753e <_vfprintf_r+0x5ca>
8000749e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800074a2:	40 3c       	lddsp	r12,sp[0xc]
800074a4:	58 0c       	cp.w	r12,0
800074a6:	c1 e0       	breq	800074e2 <_vfprintf_r+0x56e>
800074a8:	10 36       	cp.w	r6,r8
800074aa:	c0 64       	brge	800074b6 <_vfprintf_r+0x542>
800074ac:	fa cb f9 44 	sub	r11,sp,-1724
800074b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800074b4:	c2 08       	rjmp	800074f4 <_vfprintf_r+0x580>
800074b6:	fa c8 f9 50 	sub	r8,sp,-1712
800074ba:	1a d8       	st.w	--sp,r8
800074bc:	fa c8 fa b8 	sub	r8,sp,-1352
800074c0:	0c 9b       	mov	r11,r6
800074c2:	1a d8       	st.w	--sp,r8
800074c4:	fa c8 fb b4 	sub	r8,sp,-1100
800074c8:	1a d8       	st.w	--sp,r8
800074ca:	fa c9 ff b4 	sub	r9,sp,-76
800074ce:	fa c8 f9 40 	sub	r8,sp,-1728
800074d2:	04 9a       	mov	r10,r2
800074d4:	08 9c       	mov	r12,r4
800074d6:	fe b0 fb b7 	rcall	80006c44 <get_arg>
800074da:	2f dd       	sub	sp,-12
800074dc:	78 1b       	ld.w	r11,r12[0x4]
800074de:	78 09       	ld.w	r9,r12[0x0]
800074e0:	c2 b8       	rjmp	80007536 <_vfprintf_r+0x5c2>
800074e2:	ee ca ff ff 	sub	r10,r7,-1
800074e6:	10 37       	cp.w	r7,r8
800074e8:	c0 b4       	brge	800074fe <_vfprintf_r+0x58a>
800074ea:	fa c9 f9 44 	sub	r9,sp,-1724
800074ee:	14 97       	mov	r7,r10
800074f0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800074f4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800074f8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800074fc:	c1 d8       	rjmp	80007536 <_vfprintf_r+0x5c2>
800074fe:	41 09       	lddsp	r9,sp[0x40]
80007500:	59 f8       	cp.w	r8,31
80007502:	e0 89 00 14 	brgt	8000752a <_vfprintf_r+0x5b6>
80007506:	f2 cb ff f8 	sub	r11,r9,-8
8000750a:	51 0b       	stdsp	sp[0x40],r11
8000750c:	fa c6 f9 44 	sub	r6,sp,-1724
80007510:	72 1b       	ld.w	r11,r9[0x4]
80007512:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007516:	72 09       	ld.w	r9,r9[0x0]
80007518:	f9 4b fd 8c 	st.w	r12[-628],r11
8000751c:	f9 49 fd 88 	st.w	r12[-632],r9
80007520:	2f f8       	sub	r8,-1
80007522:	14 97       	mov	r7,r10
80007524:	fb 48 06 b4 	st.w	sp[1716],r8
80007528:	c0 78       	rjmp	80007536 <_vfprintf_r+0x5c2>
8000752a:	f2 c8 ff f8 	sub	r8,r9,-8
8000752e:	72 1b       	ld.w	r11,r9[0x4]
80007530:	14 97       	mov	r7,r10
80007532:	51 08       	stdsp	sp[0x40],r8
80007534:	72 09       	ld.w	r9,r9[0x0]
80007536:	16 98       	mov	r8,r11
80007538:	fa e9 00 00 	st.d	sp[0],r8
8000753c:	ca e8       	rjmp	80007698 <_vfprintf_r+0x724>
8000753e:	ed b5 00 04 	bld	r5,0x4
80007542:	c1 71       	brne	80007570 <_vfprintf_r+0x5fc>
80007544:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007548:	40 3e       	lddsp	lr,sp[0xc]
8000754a:	58 0e       	cp.w	lr,0
8000754c:	c0 80       	breq	8000755c <_vfprintf_r+0x5e8>
8000754e:	10 36       	cp.w	r6,r8
80007550:	c6 94       	brge	80007622 <_vfprintf_r+0x6ae>
80007552:	fa cc f9 44 	sub	r12,sp,-1724
80007556:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000755a:	c8 28       	rjmp	8000765e <_vfprintf_r+0x6ea>
8000755c:	ee ca ff ff 	sub	r10,r7,-1
80007560:	10 37       	cp.w	r7,r8
80007562:	e0 84 00 81 	brge	80007664 <_vfprintf_r+0x6f0>
80007566:	fa cb f9 44 	sub	r11,sp,-1724
8000756a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000756e:	c7 78       	rjmp	8000765c <_vfprintf_r+0x6e8>
80007570:	ed b5 00 06 	bld	r5,0x6
80007574:	c4 b1       	brne	8000760a <_vfprintf_r+0x696>
80007576:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000757a:	40 3c       	lddsp	r12,sp[0xc]
8000757c:	58 0c       	cp.w	r12,0
8000757e:	c1 d0       	breq	800075b8 <_vfprintf_r+0x644>
80007580:	10 36       	cp.w	r6,r8
80007582:	c0 64       	brge	8000758e <_vfprintf_r+0x61a>
80007584:	fa cb f9 44 	sub	r11,sp,-1724
80007588:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000758c:	c1 f8       	rjmp	800075ca <_vfprintf_r+0x656>
8000758e:	fa c8 f9 50 	sub	r8,sp,-1712
80007592:	1a d8       	st.w	--sp,r8
80007594:	fa c8 fa b8 	sub	r8,sp,-1352
80007598:	1a d8       	st.w	--sp,r8
8000759a:	fa c8 fb b4 	sub	r8,sp,-1100
8000759e:	1a d8       	st.w	--sp,r8
800075a0:	fa c8 f9 40 	sub	r8,sp,-1728
800075a4:	fa c9 ff b4 	sub	r9,sp,-76
800075a8:	04 9a       	mov	r10,r2
800075aa:	0c 9b       	mov	r11,r6
800075ac:	08 9c       	mov	r12,r4
800075ae:	fe b0 fb 4b 	rcall	80006c44 <get_arg>
800075b2:	2f dd       	sub	sp,-12
800075b4:	98 18       	ld.sh	r8,r12[0x2]
800075b6:	c2 68       	rjmp	80007602 <_vfprintf_r+0x68e>
800075b8:	ee ca ff ff 	sub	r10,r7,-1
800075bc:	10 37       	cp.w	r7,r8
800075be:	c0 94       	brge	800075d0 <_vfprintf_r+0x65c>
800075c0:	fa c9 f9 44 	sub	r9,sp,-1724
800075c4:	14 97       	mov	r7,r10
800075c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800075ca:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800075ce:	c1 a8       	rjmp	80007602 <_vfprintf_r+0x68e>
800075d0:	41 09       	lddsp	r9,sp[0x40]
800075d2:	59 f8       	cp.w	r8,31
800075d4:	e0 89 00 13 	brgt	800075fa <_vfprintf_r+0x686>
800075d8:	f2 cb ff fc 	sub	r11,r9,-4
800075dc:	51 0b       	stdsp	sp[0x40],r11
800075de:	72 09       	ld.w	r9,r9[0x0]
800075e0:	fa c6 f9 44 	sub	r6,sp,-1724
800075e4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800075e8:	2f f8       	sub	r8,-1
800075ea:	f7 49 fd 88 	st.w	r11[-632],r9
800075ee:	fb 48 06 b4 	st.w	sp[1716],r8
800075f2:	14 97       	mov	r7,r10
800075f4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800075f8:	c0 58       	rjmp	80007602 <_vfprintf_r+0x68e>
800075fa:	92 18       	ld.sh	r8,r9[0x2]
800075fc:	14 97       	mov	r7,r10
800075fe:	2f c9       	sub	r9,-4
80007600:	51 09       	stdsp	sp[0x40],r9
80007602:	50 18       	stdsp	sp[0x4],r8
80007604:	bf 58       	asr	r8,0x1f
80007606:	50 08       	stdsp	sp[0x0],r8
80007608:	c4 88       	rjmp	80007698 <_vfprintf_r+0x724>
8000760a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000760e:	40 3c       	lddsp	r12,sp[0xc]
80007610:	58 0c       	cp.w	r12,0
80007612:	c1 d0       	breq	8000764c <_vfprintf_r+0x6d8>
80007614:	10 36       	cp.w	r6,r8
80007616:	c0 64       	brge	80007622 <_vfprintf_r+0x6ae>
80007618:	fa cb f9 44 	sub	r11,sp,-1724
8000761c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007620:	c1 f8       	rjmp	8000765e <_vfprintf_r+0x6ea>
80007622:	fa c8 f9 50 	sub	r8,sp,-1712
80007626:	1a d8       	st.w	--sp,r8
80007628:	fa c8 fa b8 	sub	r8,sp,-1352
8000762c:	0c 9b       	mov	r11,r6
8000762e:	1a d8       	st.w	--sp,r8
80007630:	fa c8 fb b4 	sub	r8,sp,-1100
80007634:	04 9a       	mov	r10,r2
80007636:	1a d8       	st.w	--sp,r8
80007638:	08 9c       	mov	r12,r4
8000763a:	fa c8 f9 40 	sub	r8,sp,-1728
8000763e:	fa c9 ff b4 	sub	r9,sp,-76
80007642:	fe b0 fb 01 	rcall	80006c44 <get_arg>
80007646:	2f dd       	sub	sp,-12
80007648:	78 0b       	ld.w	r11,r12[0x0]
8000764a:	c2 48       	rjmp	80007692 <_vfprintf_r+0x71e>
8000764c:	ee ca ff ff 	sub	r10,r7,-1
80007650:	10 37       	cp.w	r7,r8
80007652:	c0 94       	brge	80007664 <_vfprintf_r+0x6f0>
80007654:	fa c9 f9 44 	sub	r9,sp,-1724
80007658:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000765c:	14 97       	mov	r7,r10
8000765e:	ec fb fd 88 	ld.w	r11,r6[-632]
80007662:	c1 88       	rjmp	80007692 <_vfprintf_r+0x71e>
80007664:	41 09       	lddsp	r9,sp[0x40]
80007666:	59 f8       	cp.w	r8,31
80007668:	e0 89 00 11 	brgt	8000768a <_vfprintf_r+0x716>
8000766c:	f2 cb ff fc 	sub	r11,r9,-4
80007670:	51 0b       	stdsp	sp[0x40],r11
80007672:	fa c6 f9 44 	sub	r6,sp,-1724
80007676:	72 0b       	ld.w	r11,r9[0x0]
80007678:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000767c:	f3 4b fd 88 	st.w	r9[-632],r11
80007680:	2f f8       	sub	r8,-1
80007682:	14 97       	mov	r7,r10
80007684:	fb 48 06 b4 	st.w	sp[1716],r8
80007688:	c0 58       	rjmp	80007692 <_vfprintf_r+0x71e>
8000768a:	72 0b       	ld.w	r11,r9[0x0]
8000768c:	14 97       	mov	r7,r10
8000768e:	2f c9       	sub	r9,-4
80007690:	51 09       	stdsp	sp[0x40],r9
80007692:	50 1b       	stdsp	sp[0x4],r11
80007694:	bf 5b       	asr	r11,0x1f
80007696:	50 0b       	stdsp	sp[0x0],r11
80007698:	fa ea 00 00 	ld.d	r10,sp[0]
8000769c:	58 0a       	cp.w	r10,0
8000769e:	5c 2b       	cpc	r11
800076a0:	c0 e4       	brge	800076bc <_vfprintf_r+0x748>
800076a2:	30 08       	mov	r8,0
800076a4:	fa ea 00 00 	ld.d	r10,sp[0]
800076a8:	30 09       	mov	r9,0
800076aa:	f0 0a 01 0a 	sub	r10,r8,r10
800076ae:	f2 0b 01 4b 	sbc	r11,r9,r11
800076b2:	32 d8       	mov	r8,45
800076b4:	fa eb 00 00 	st.d	sp[0],r10
800076b8:	fb 68 06 bb 	st.b	sp[1723],r8
800076bc:	30 18       	mov	r8,1
800076be:	e0 8f 06 fa 	bral	800084b2 <_vfprintf_r+0x153e>
800076c2:	50 a7       	stdsp	sp[0x28],r7
800076c4:	50 80       	stdsp	sp[0x20],r0
800076c6:	0c 97       	mov	r7,r6
800076c8:	04 94       	mov	r4,r2
800076ca:	06 96       	mov	r6,r3
800076cc:	02 92       	mov	r2,r1
800076ce:	40 93       	lddsp	r3,sp[0x24]
800076d0:	10 90       	mov	r0,r8
800076d2:	40 41       	lddsp	r1,sp[0x10]
800076d4:	0e 99       	mov	r9,r7
800076d6:	ed b5 00 03 	bld	r5,0x3
800076da:	c4 11       	brne	8000775c <_vfprintf_r+0x7e8>
800076dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076e0:	40 3a       	lddsp	r10,sp[0xc]
800076e2:	58 0a       	cp.w	r10,0
800076e4:	c1 90       	breq	80007716 <_vfprintf_r+0x7a2>
800076e6:	10 36       	cp.w	r6,r8
800076e8:	c6 45       	brlt	800077b0 <_vfprintf_r+0x83c>
800076ea:	fa c8 f9 50 	sub	r8,sp,-1712
800076ee:	1a d8       	st.w	--sp,r8
800076f0:	fa c8 fa b8 	sub	r8,sp,-1352
800076f4:	1a d8       	st.w	--sp,r8
800076f6:	fa c8 fb b4 	sub	r8,sp,-1100
800076fa:	0c 9b       	mov	r11,r6
800076fc:	1a d8       	st.w	--sp,r8
800076fe:	04 9a       	mov	r10,r2
80007700:	fa c8 f9 40 	sub	r8,sp,-1728
80007704:	fa c9 ff b4 	sub	r9,sp,-76
80007708:	08 9c       	mov	r12,r4
8000770a:	fe b0 fa 9d 	rcall	80006c44 <get_arg>
8000770e:	2f dd       	sub	sp,-12
80007710:	78 16       	ld.w	r6,r12[0x4]
80007712:	50 76       	stdsp	sp[0x1c],r6
80007714:	c4 88       	rjmp	800077a4 <_vfprintf_r+0x830>
80007716:	2f f7       	sub	r7,-1
80007718:	10 39       	cp.w	r9,r8
8000771a:	c0 c4       	brge	80007732 <_vfprintf_r+0x7be>
8000771c:	fa ce f9 44 	sub	lr,sp,-1724
80007720:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007724:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007728:	50 7c       	stdsp	sp[0x1c],r12
8000772a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000772e:	50 56       	stdsp	sp[0x14],r6
80007730:	c6 68       	rjmp	800077fc <_vfprintf_r+0x888>
80007732:	41 09       	lddsp	r9,sp[0x40]
80007734:	59 f8       	cp.w	r8,31
80007736:	e0 89 00 10 	brgt	80007756 <_vfprintf_r+0x7e2>
8000773a:	f2 ca ff f8 	sub	r10,r9,-8
8000773e:	72 1b       	ld.w	r11,r9[0x4]
80007740:	51 0a       	stdsp	sp[0x40],r10
80007742:	72 09       	ld.w	r9,r9[0x0]
80007744:	fa ca f9 44 	sub	r10,sp,-1724
80007748:	50 7b       	stdsp	sp[0x1c],r11
8000774a:	50 59       	stdsp	sp[0x14],r9
8000774c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007750:	40 5b       	lddsp	r11,sp[0x14]
80007752:	40 7a       	lddsp	r10,sp[0x1c]
80007754:	c4 78       	rjmp	800077e2 <_vfprintf_r+0x86e>
80007756:	72 18       	ld.w	r8,r9[0x4]
80007758:	50 78       	stdsp	sp[0x1c],r8
8000775a:	c4 c8       	rjmp	800077f2 <_vfprintf_r+0x87e>
8000775c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007760:	40 3e       	lddsp	lr,sp[0xc]
80007762:	58 0e       	cp.w	lr,0
80007764:	c2 30       	breq	800077aa <_vfprintf_r+0x836>
80007766:	10 36       	cp.w	r6,r8
80007768:	c0 94       	brge	8000777a <_vfprintf_r+0x806>
8000776a:	fa cc f9 44 	sub	r12,sp,-1724
8000776e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007772:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007776:	50 7b       	stdsp	sp[0x1c],r11
80007778:	cd 9b       	rjmp	8000772a <_vfprintf_r+0x7b6>
8000777a:	fa c8 f9 50 	sub	r8,sp,-1712
8000777e:	1a d8       	st.w	--sp,r8
80007780:	fa c8 fa b8 	sub	r8,sp,-1352
80007784:	04 9a       	mov	r10,r2
80007786:	1a d8       	st.w	--sp,r8
80007788:	fa c8 fb b4 	sub	r8,sp,-1100
8000778c:	0c 9b       	mov	r11,r6
8000778e:	1a d8       	st.w	--sp,r8
80007790:	08 9c       	mov	r12,r4
80007792:	fa c8 f9 40 	sub	r8,sp,-1728
80007796:	fa c9 ff b4 	sub	r9,sp,-76
8000779a:	fe b0 fa 55 	rcall	80006c44 <get_arg>
8000779e:	2f dd       	sub	sp,-12
800077a0:	78 1a       	ld.w	r10,r12[0x4]
800077a2:	50 7a       	stdsp	sp[0x1c],r10
800077a4:	78 0c       	ld.w	r12,r12[0x0]
800077a6:	50 5c       	stdsp	sp[0x14],r12
800077a8:	c2 a8       	rjmp	800077fc <_vfprintf_r+0x888>
800077aa:	2f f7       	sub	r7,-1
800077ac:	10 39       	cp.w	r9,r8
800077ae:	c0 94       	brge	800077c0 <_vfprintf_r+0x84c>
800077b0:	fa c9 f9 44 	sub	r9,sp,-1724
800077b4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800077b8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800077bc:	50 78       	stdsp	sp[0x1c],r8
800077be:	cb 6b       	rjmp	8000772a <_vfprintf_r+0x7b6>
800077c0:	41 09       	lddsp	r9,sp[0x40]
800077c2:	59 f8       	cp.w	r8,31
800077c4:	e0 89 00 15 	brgt	800077ee <_vfprintf_r+0x87a>
800077c8:	f2 ca ff f8 	sub	r10,r9,-8
800077cc:	72 16       	ld.w	r6,r9[0x4]
800077ce:	72 09       	ld.w	r9,r9[0x0]
800077d0:	51 0a       	stdsp	sp[0x40],r10
800077d2:	50 59       	stdsp	sp[0x14],r9
800077d4:	fa ce f9 44 	sub	lr,sp,-1724
800077d8:	50 76       	stdsp	sp[0x1c],r6
800077da:	fc 08 00 39 	add	r9,lr,r8<<0x3
800077de:	40 5b       	lddsp	r11,sp[0x14]
800077e0:	0c 9a       	mov	r10,r6
800077e2:	f2 eb fd 88 	st.d	r9[-632],r10
800077e6:	2f f8       	sub	r8,-1
800077e8:	fb 48 06 b4 	st.w	sp[1716],r8
800077ec:	c0 88       	rjmp	800077fc <_vfprintf_r+0x888>
800077ee:	72 1c       	ld.w	r12,r9[0x4]
800077f0:	50 7c       	stdsp	sp[0x1c],r12
800077f2:	f2 c8 ff f8 	sub	r8,r9,-8
800077f6:	51 08       	stdsp	sp[0x40],r8
800077f8:	72 09       	ld.w	r9,r9[0x0]
800077fa:	50 59       	stdsp	sp[0x14],r9
800077fc:	40 5b       	lddsp	r11,sp[0x14]
800077fe:	40 7a       	lddsp	r10,sp[0x1c]
80007800:	e0 a0 19 54 	rcall	8000aaa8 <__isinfd>
80007804:	18 96       	mov	r6,r12
80007806:	c1 70       	breq	80007834 <_vfprintf_r+0x8c0>
80007808:	30 08       	mov	r8,0
8000780a:	30 09       	mov	r9,0
8000780c:	40 5b       	lddsp	r11,sp[0x14]
8000780e:	40 7a       	lddsp	r10,sp[0x1c]
80007810:	e0 a0 1d a8 	rcall	8000b360 <__avr32_f64_cmp_lt>
80007814:	c0 40       	breq	8000781c <_vfprintf_r+0x8a8>
80007816:	32 d8       	mov	r8,45
80007818:	fb 68 06 bb 	st.b	sp[1723],r8
8000781c:	fe c8 ab e4 	sub	r8,pc,-21532
80007820:	fe c6 ab e4 	sub	r6,pc,-21532
80007824:	a7 d5       	cbr	r5,0x7
80007826:	e0 40 00 47 	cp.w	r0,71
8000782a:	f0 06 17 a0 	movle	r6,r8
8000782e:	30 32       	mov	r2,3
80007830:	e0 8f 06 ce 	bral	800085cc <_vfprintf_r+0x1658>
80007834:	40 5b       	lddsp	r11,sp[0x14]
80007836:	40 7a       	lddsp	r10,sp[0x1c]
80007838:	e0 a0 19 4d 	rcall	8000aad2 <__isnand>
8000783c:	c0 e0       	breq	80007858 <_vfprintf_r+0x8e4>
8000783e:	50 26       	stdsp	sp[0x8],r6
80007840:	fe c8 ac 00 	sub	r8,pc,-21504
80007844:	fe c6 ac 00 	sub	r6,pc,-21504
80007848:	a7 d5       	cbr	r5,0x7
8000784a:	e0 40 00 47 	cp.w	r0,71
8000784e:	f0 06 17 a0 	movle	r6,r8
80007852:	30 32       	mov	r2,3
80007854:	e0 8f 06 c2 	bral	800085d8 <_vfprintf_r+0x1664>
80007858:	40 2a       	lddsp	r10,sp[0x8]
8000785a:	5b fa       	cp.w	r10,-1
8000785c:	c0 41       	brne	80007864 <_vfprintf_r+0x8f0>
8000785e:	30 69       	mov	r9,6
80007860:	50 29       	stdsp	sp[0x8],r9
80007862:	c1 18       	rjmp	80007884 <_vfprintf_r+0x910>
80007864:	e0 40 00 47 	cp.w	r0,71
80007868:	5f 09       	sreq	r9
8000786a:	e0 40 00 67 	cp.w	r0,103
8000786e:	5f 08       	sreq	r8
80007870:	f3 e8 10 08 	or	r8,r9,r8
80007874:	f8 08 18 00 	cp.b	r8,r12
80007878:	c0 60       	breq	80007884 <_vfprintf_r+0x910>
8000787a:	40 28       	lddsp	r8,sp[0x8]
8000787c:	58 08       	cp.w	r8,0
8000787e:	f9 b8 00 01 	moveq	r8,1
80007882:	50 28       	stdsp	sp[0x8],r8
80007884:	40 78       	lddsp	r8,sp[0x1c]
80007886:	40 59       	lddsp	r9,sp[0x14]
80007888:	fa e9 06 94 	st.d	sp[1684],r8
8000788c:	a9 a5       	sbr	r5,0x8
8000788e:	fa f8 06 94 	ld.w	r8,sp[1684]
80007892:	58 08       	cp.w	r8,0
80007894:	c0 65       	brlt	800078a0 <_vfprintf_r+0x92c>
80007896:	40 5e       	lddsp	lr,sp[0x14]
80007898:	30 0c       	mov	r12,0
8000789a:	50 6e       	stdsp	sp[0x18],lr
8000789c:	50 9c       	stdsp	sp[0x24],r12
8000789e:	c0 78       	rjmp	800078ac <_vfprintf_r+0x938>
800078a0:	40 5b       	lddsp	r11,sp[0x14]
800078a2:	32 da       	mov	r10,45
800078a4:	ee 1b 80 00 	eorh	r11,0x8000
800078a8:	50 9a       	stdsp	sp[0x24],r10
800078aa:	50 6b       	stdsp	sp[0x18],r11
800078ac:	e0 40 00 46 	cp.w	r0,70
800078b0:	5f 09       	sreq	r9
800078b2:	e0 40 00 66 	cp.w	r0,102
800078b6:	5f 08       	sreq	r8
800078b8:	f3 e8 10 08 	or	r8,r9,r8
800078bc:	50 48       	stdsp	sp[0x10],r8
800078be:	c0 40       	breq	800078c6 <_vfprintf_r+0x952>
800078c0:	40 22       	lddsp	r2,sp[0x8]
800078c2:	30 39       	mov	r9,3
800078c4:	c1 08       	rjmp	800078e4 <_vfprintf_r+0x970>
800078c6:	e0 40 00 45 	cp.w	r0,69
800078ca:	5f 09       	sreq	r9
800078cc:	e0 40 00 65 	cp.w	r0,101
800078d0:	5f 08       	sreq	r8
800078d2:	40 22       	lddsp	r2,sp[0x8]
800078d4:	10 49       	or	r9,r8
800078d6:	2f f2       	sub	r2,-1
800078d8:	40 46       	lddsp	r6,sp[0x10]
800078da:	ec 09 18 00 	cp.b	r9,r6
800078de:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800078e2:	30 29       	mov	r9,2
800078e4:	fa c8 f9 5c 	sub	r8,sp,-1700
800078e8:	1a d8       	st.w	--sp,r8
800078ea:	fa c8 f9 54 	sub	r8,sp,-1708
800078ee:	1a d8       	st.w	--sp,r8
800078f0:	fa c8 f9 4c 	sub	r8,sp,-1716
800078f4:	08 9c       	mov	r12,r4
800078f6:	1a d8       	st.w	--sp,r8
800078f8:	04 98       	mov	r8,r2
800078fa:	40 9b       	lddsp	r11,sp[0x24]
800078fc:	40 aa       	lddsp	r10,sp[0x28]
800078fe:	e0 a0 0b c3 	rcall	80009084 <_dtoa_r>
80007902:	e0 40 00 47 	cp.w	r0,71
80007906:	5f 19       	srne	r9
80007908:	e0 40 00 67 	cp.w	r0,103
8000790c:	5f 18       	srne	r8
8000790e:	18 96       	mov	r6,r12
80007910:	2f dd       	sub	sp,-12
80007912:	f3 e8 00 08 	and	r8,r9,r8
80007916:	c0 41       	brne	8000791e <_vfprintf_r+0x9aa>
80007918:	ed b5 00 00 	bld	r5,0x0
8000791c:	c3 01       	brne	8000797c <_vfprintf_r+0xa08>
8000791e:	ec 02 00 0e 	add	lr,r6,r2
80007922:	50 3e       	stdsp	sp[0xc],lr
80007924:	40 4c       	lddsp	r12,sp[0x10]
80007926:	58 0c       	cp.w	r12,0
80007928:	c1 50       	breq	80007952 <_vfprintf_r+0x9de>
8000792a:	0d 89       	ld.ub	r9,r6[0x0]
8000792c:	33 08       	mov	r8,48
8000792e:	f0 09 18 00 	cp.b	r9,r8
80007932:	c0 b1       	brne	80007948 <_vfprintf_r+0x9d4>
80007934:	30 08       	mov	r8,0
80007936:	30 09       	mov	r9,0
80007938:	40 6b       	lddsp	r11,sp[0x18]
8000793a:	40 7a       	lddsp	r10,sp[0x1c]
8000793c:	e0 a0 1c cb 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
80007940:	fb b2 00 01 	rsubeq	r2,1
80007944:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007948:	40 3b       	lddsp	r11,sp[0xc]
8000794a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000794e:	10 0b       	add	r11,r8
80007950:	50 3b       	stdsp	sp[0xc],r11
80007952:	40 6b       	lddsp	r11,sp[0x18]
80007954:	30 08       	mov	r8,0
80007956:	30 09       	mov	r9,0
80007958:	40 7a       	lddsp	r10,sp[0x1c]
8000795a:	e0 a0 1c bc 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
8000795e:	c0 90       	breq	80007970 <_vfprintf_r+0x9fc>
80007960:	40 3a       	lddsp	r10,sp[0xc]
80007962:	fb 4a 06 a4 	st.w	sp[1700],r10
80007966:	c0 58       	rjmp	80007970 <_vfprintf_r+0x9fc>
80007968:	10 c9       	st.b	r8++,r9
8000796a:	fb 48 06 a4 	st.w	sp[1700],r8
8000796e:	c0 28       	rjmp	80007972 <_vfprintf_r+0x9fe>
80007970:	33 09       	mov	r9,48
80007972:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007976:	40 3e       	lddsp	lr,sp[0xc]
80007978:	1c 38       	cp.w	r8,lr
8000797a:	cf 73       	brcs	80007968 <_vfprintf_r+0x9f4>
8000797c:	e0 40 00 47 	cp.w	r0,71
80007980:	5f 09       	sreq	r9
80007982:	e0 40 00 67 	cp.w	r0,103
80007986:	5f 08       	sreq	r8
80007988:	f3 e8 10 08 	or	r8,r9,r8
8000798c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007990:	0c 19       	sub	r9,r6
80007992:	50 69       	stdsp	sp[0x18],r9
80007994:	58 08       	cp.w	r8,0
80007996:	c0 b0       	breq	800079ac <_vfprintf_r+0xa38>
80007998:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000799c:	5b d8       	cp.w	r8,-3
8000799e:	c0 55       	brlt	800079a8 <_vfprintf_r+0xa34>
800079a0:	40 2c       	lddsp	r12,sp[0x8]
800079a2:	18 38       	cp.w	r8,r12
800079a4:	e0 8a 00 6a 	brle	80007a78 <_vfprintf_r+0xb04>
800079a8:	20 20       	sub	r0,2
800079aa:	c0 58       	rjmp	800079b4 <_vfprintf_r+0xa40>
800079ac:	e0 40 00 65 	cp.w	r0,101
800079b0:	e0 89 00 46 	brgt	80007a3c <_vfprintf_r+0xac8>
800079b4:	fa fb 06 ac 	ld.w	r11,sp[1708]
800079b8:	fb 60 06 9c 	st.b	sp[1692],r0
800079bc:	20 1b       	sub	r11,1
800079be:	fb 4b 06 ac 	st.w	sp[1708],r11
800079c2:	c0 47       	brpl	800079ca <_vfprintf_r+0xa56>
800079c4:	5c 3b       	neg	r11
800079c6:	32 d8       	mov	r8,45
800079c8:	c0 28       	rjmp	800079cc <_vfprintf_r+0xa58>
800079ca:	32 b8       	mov	r8,43
800079cc:	fb 68 06 9d 	st.b	sp[1693],r8
800079d0:	58 9b       	cp.w	r11,9
800079d2:	e0 8a 00 1d 	brle	80007a0c <_vfprintf_r+0xa98>
800079d6:	fa c9 fa 35 	sub	r9,sp,-1483
800079da:	30 aa       	mov	r10,10
800079dc:	12 98       	mov	r8,r9
800079de:	0e 9c       	mov	r12,r7
800079e0:	0c 92       	mov	r2,r6
800079e2:	f6 0a 0c 06 	divs	r6,r11,r10
800079e6:	0e 9b       	mov	r11,r7
800079e8:	2d 0b       	sub	r11,-48
800079ea:	10 fb       	st.b	--r8,r11
800079ec:	0c 9b       	mov	r11,r6
800079ee:	58 96       	cp.w	r6,9
800079f0:	fe 99 ff f9 	brgt	800079e2 <_vfprintf_r+0xa6e>
800079f4:	2d 0b       	sub	r11,-48
800079f6:	18 97       	mov	r7,r12
800079f8:	04 96       	mov	r6,r2
800079fa:	10 fb       	st.b	--r8,r11
800079fc:	fa ca f9 62 	sub	r10,sp,-1694
80007a00:	c0 38       	rjmp	80007a06 <_vfprintf_r+0xa92>
80007a02:	11 3b       	ld.ub	r11,r8++
80007a04:	14 cb       	st.b	r10++,r11
80007a06:	12 38       	cp.w	r8,r9
80007a08:	cf d3       	brcs	80007a02 <_vfprintf_r+0xa8e>
80007a0a:	c0 98       	rjmp	80007a1c <_vfprintf_r+0xaa8>
80007a0c:	2d 0b       	sub	r11,-48
80007a0e:	33 08       	mov	r8,48
80007a10:	fb 6b 06 9f 	st.b	sp[1695],r11
80007a14:	fb 68 06 9e 	st.b	sp[1694],r8
80007a18:	fa ca f9 60 	sub	r10,sp,-1696
80007a1c:	fa c8 f9 64 	sub	r8,sp,-1692
80007a20:	f4 08 01 08 	sub	r8,r10,r8
80007a24:	50 e8       	stdsp	sp[0x38],r8
80007a26:	10 92       	mov	r2,r8
80007a28:	40 6b       	lddsp	r11,sp[0x18]
80007a2a:	16 02       	add	r2,r11
80007a2c:	58 1b       	cp.w	r11,1
80007a2e:	e0 89 00 05 	brgt	80007a38 <_vfprintf_r+0xac4>
80007a32:	ed b5 00 00 	bld	r5,0x0
80007a36:	c3 51       	brne	80007aa0 <_vfprintf_r+0xb2c>
80007a38:	2f f2       	sub	r2,-1
80007a3a:	c3 38       	rjmp	80007aa0 <_vfprintf_r+0xb2c>
80007a3c:	e0 40 00 66 	cp.w	r0,102
80007a40:	c1 c1       	brne	80007a78 <_vfprintf_r+0xb04>
80007a42:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007a46:	58 02       	cp.w	r2,0
80007a48:	e0 8a 00 0c 	brle	80007a60 <_vfprintf_r+0xaec>
80007a4c:	40 2a       	lddsp	r10,sp[0x8]
80007a4e:	58 0a       	cp.w	r10,0
80007a50:	c0 41       	brne	80007a58 <_vfprintf_r+0xae4>
80007a52:	ed b5 00 00 	bld	r5,0x0
80007a56:	c2 51       	brne	80007aa0 <_vfprintf_r+0xb2c>
80007a58:	2f f2       	sub	r2,-1
80007a5a:	40 29       	lddsp	r9,sp[0x8]
80007a5c:	12 02       	add	r2,r9
80007a5e:	c0 b8       	rjmp	80007a74 <_vfprintf_r+0xb00>
80007a60:	40 28       	lddsp	r8,sp[0x8]
80007a62:	58 08       	cp.w	r8,0
80007a64:	c0 61       	brne	80007a70 <_vfprintf_r+0xafc>
80007a66:	ed b5 00 00 	bld	r5,0x0
80007a6a:	c0 30       	breq	80007a70 <_vfprintf_r+0xafc>
80007a6c:	30 12       	mov	r2,1
80007a6e:	c1 98       	rjmp	80007aa0 <_vfprintf_r+0xb2c>
80007a70:	40 22       	lddsp	r2,sp[0x8]
80007a72:	2f e2       	sub	r2,-2
80007a74:	36 60       	mov	r0,102
80007a76:	c1 58       	rjmp	80007aa0 <_vfprintf_r+0xb2c>
80007a78:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007a7c:	40 6e       	lddsp	lr,sp[0x18]
80007a7e:	1c 32       	cp.w	r2,lr
80007a80:	c0 65       	brlt	80007a8c <_vfprintf_r+0xb18>
80007a82:	ed b5 00 00 	bld	r5,0x0
80007a86:	f7 b2 00 ff 	subeq	r2,-1
80007a8a:	c0 a8       	rjmp	80007a9e <_vfprintf_r+0xb2a>
80007a8c:	e4 08 11 02 	rsub	r8,r2,2
80007a90:	40 6c       	lddsp	r12,sp[0x18]
80007a92:	58 02       	cp.w	r2,0
80007a94:	f0 02 17 a0 	movle	r2,r8
80007a98:	f9 b2 09 01 	movgt	r2,1
80007a9c:	18 02       	add	r2,r12
80007a9e:	36 70       	mov	r0,103
80007aa0:	40 9b       	lddsp	r11,sp[0x24]
80007aa2:	58 0b       	cp.w	r11,0
80007aa4:	e0 80 05 94 	breq	800085cc <_vfprintf_r+0x1658>
80007aa8:	32 d8       	mov	r8,45
80007aaa:	fb 68 06 bb 	st.b	sp[1723],r8
80007aae:	e0 8f 05 93 	bral	800085d4 <_vfprintf_r+0x1660>
80007ab2:	50 a7       	stdsp	sp[0x28],r7
80007ab4:	04 94       	mov	r4,r2
80007ab6:	0c 97       	mov	r7,r6
80007ab8:	02 92       	mov	r2,r1
80007aba:	06 96       	mov	r6,r3
80007abc:	40 41       	lddsp	r1,sp[0x10]
80007abe:	40 93       	lddsp	r3,sp[0x24]
80007ac0:	0e 99       	mov	r9,r7
80007ac2:	ed b5 00 05 	bld	r5,0x5
80007ac6:	c4 81       	brne	80007b56 <_vfprintf_r+0xbe2>
80007ac8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007acc:	40 3e       	lddsp	lr,sp[0xc]
80007ace:	58 0e       	cp.w	lr,0
80007ad0:	c1 d0       	breq	80007b0a <_vfprintf_r+0xb96>
80007ad2:	10 36       	cp.w	r6,r8
80007ad4:	c0 64       	brge	80007ae0 <_vfprintf_r+0xb6c>
80007ad6:	fa cc f9 44 	sub	r12,sp,-1724
80007ada:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007ade:	c1 d8       	rjmp	80007b18 <_vfprintf_r+0xba4>
80007ae0:	fa c8 f9 50 	sub	r8,sp,-1712
80007ae4:	1a d8       	st.w	--sp,r8
80007ae6:	fa c8 fa b8 	sub	r8,sp,-1352
80007aea:	04 9a       	mov	r10,r2
80007aec:	1a d8       	st.w	--sp,r8
80007aee:	fa c8 fb b4 	sub	r8,sp,-1100
80007af2:	0c 9b       	mov	r11,r6
80007af4:	1a d8       	st.w	--sp,r8
80007af6:	08 9c       	mov	r12,r4
80007af8:	fa c8 f9 40 	sub	r8,sp,-1728
80007afc:	fa c9 ff b4 	sub	r9,sp,-76
80007b00:	fe b0 f8 a2 	rcall	80006c44 <get_arg>
80007b04:	2f dd       	sub	sp,-12
80007b06:	78 0a       	ld.w	r10,r12[0x0]
80007b08:	c2 08       	rjmp	80007b48 <_vfprintf_r+0xbd4>
80007b0a:	2f f7       	sub	r7,-1
80007b0c:	10 39       	cp.w	r9,r8
80007b0e:	c0 84       	brge	80007b1e <_vfprintf_r+0xbaa>
80007b10:	fa cb f9 44 	sub	r11,sp,-1724
80007b14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b18:	ec fa fd 88 	ld.w	r10,r6[-632]
80007b1c:	c1 68       	rjmp	80007b48 <_vfprintf_r+0xbd4>
80007b1e:	41 09       	lddsp	r9,sp[0x40]
80007b20:	59 f8       	cp.w	r8,31
80007b22:	e0 89 00 10 	brgt	80007b42 <_vfprintf_r+0xbce>
80007b26:	f2 ca ff fc 	sub	r10,r9,-4
80007b2a:	51 0a       	stdsp	sp[0x40],r10
80007b2c:	fa c6 f9 44 	sub	r6,sp,-1724
80007b30:	72 0a       	ld.w	r10,r9[0x0]
80007b32:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007b36:	f3 4a fd 88 	st.w	r9[-632],r10
80007b3a:	2f f8       	sub	r8,-1
80007b3c:	fb 48 06 b4 	st.w	sp[1716],r8
80007b40:	c0 48       	rjmp	80007b48 <_vfprintf_r+0xbd4>
80007b42:	72 0a       	ld.w	r10,r9[0x0]
80007b44:	2f c9       	sub	r9,-4
80007b46:	51 09       	stdsp	sp[0x40],r9
80007b48:	40 be       	lddsp	lr,sp[0x2c]
80007b4a:	1c 98       	mov	r8,lr
80007b4c:	95 1e       	st.w	r10[0x4],lr
80007b4e:	bf 58       	asr	r8,0x1f
80007b50:	95 08       	st.w	r10[0x0],r8
80007b52:	fe 9f fa 9f 	bral	80007090 <_vfprintf_r+0x11c>
80007b56:	ed b5 00 04 	bld	r5,0x4
80007b5a:	c4 80       	breq	80007bea <_vfprintf_r+0xc76>
80007b5c:	e2 15 00 40 	andl	r5,0x40,COH
80007b60:	c4 50       	breq	80007bea <_vfprintf_r+0xc76>
80007b62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b66:	40 3c       	lddsp	r12,sp[0xc]
80007b68:	58 0c       	cp.w	r12,0
80007b6a:	c1 d0       	breq	80007ba4 <_vfprintf_r+0xc30>
80007b6c:	10 36       	cp.w	r6,r8
80007b6e:	c0 64       	brge	80007b7a <_vfprintf_r+0xc06>
80007b70:	fa cb f9 44 	sub	r11,sp,-1724
80007b74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b78:	c1 d8       	rjmp	80007bb2 <_vfprintf_r+0xc3e>
80007b7a:	fa c8 f9 50 	sub	r8,sp,-1712
80007b7e:	1a d8       	st.w	--sp,r8
80007b80:	fa c8 fa b8 	sub	r8,sp,-1352
80007b84:	04 9a       	mov	r10,r2
80007b86:	1a d8       	st.w	--sp,r8
80007b88:	fa c8 fb b4 	sub	r8,sp,-1100
80007b8c:	0c 9b       	mov	r11,r6
80007b8e:	1a d8       	st.w	--sp,r8
80007b90:	08 9c       	mov	r12,r4
80007b92:	fa c8 f9 40 	sub	r8,sp,-1728
80007b96:	fa c9 ff b4 	sub	r9,sp,-76
80007b9a:	fe b0 f8 55 	rcall	80006c44 <get_arg>
80007b9e:	2f dd       	sub	sp,-12
80007ba0:	78 0a       	ld.w	r10,r12[0x0]
80007ba2:	c2 08       	rjmp	80007be2 <_vfprintf_r+0xc6e>
80007ba4:	2f f7       	sub	r7,-1
80007ba6:	10 39       	cp.w	r9,r8
80007ba8:	c0 84       	brge	80007bb8 <_vfprintf_r+0xc44>
80007baa:	fa ca f9 44 	sub	r10,sp,-1724
80007bae:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007bb2:	ec fa fd 88 	ld.w	r10,r6[-632]
80007bb6:	c1 68       	rjmp	80007be2 <_vfprintf_r+0xc6e>
80007bb8:	41 09       	lddsp	r9,sp[0x40]
80007bba:	59 f8       	cp.w	r8,31
80007bbc:	e0 89 00 10 	brgt	80007bdc <_vfprintf_r+0xc68>
80007bc0:	f2 ca ff fc 	sub	r10,r9,-4
80007bc4:	51 0a       	stdsp	sp[0x40],r10
80007bc6:	fa c6 f9 44 	sub	r6,sp,-1724
80007bca:	72 0a       	ld.w	r10,r9[0x0]
80007bcc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007bd0:	f3 4a fd 88 	st.w	r9[-632],r10
80007bd4:	2f f8       	sub	r8,-1
80007bd6:	fb 48 06 b4 	st.w	sp[1716],r8
80007bda:	c0 48       	rjmp	80007be2 <_vfprintf_r+0xc6e>
80007bdc:	72 0a       	ld.w	r10,r9[0x0]
80007bde:	2f c9       	sub	r9,-4
80007be0:	51 09       	stdsp	sp[0x40],r9
80007be2:	40 be       	lddsp	lr,sp[0x2c]
80007be4:	b4 0e       	st.h	r10[0x0],lr
80007be6:	fe 9f fa 55 	bral	80007090 <_vfprintf_r+0x11c>
80007bea:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bee:	40 3c       	lddsp	r12,sp[0xc]
80007bf0:	58 0c       	cp.w	r12,0
80007bf2:	c1 d0       	breq	80007c2c <_vfprintf_r+0xcb8>
80007bf4:	10 36       	cp.w	r6,r8
80007bf6:	c0 64       	brge	80007c02 <_vfprintf_r+0xc8e>
80007bf8:	fa cb f9 44 	sub	r11,sp,-1724
80007bfc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c00:	c1 d8       	rjmp	80007c3a <_vfprintf_r+0xcc6>
80007c02:	fa c8 f9 50 	sub	r8,sp,-1712
80007c06:	1a d8       	st.w	--sp,r8
80007c08:	fa c8 fa b8 	sub	r8,sp,-1352
80007c0c:	04 9a       	mov	r10,r2
80007c0e:	1a d8       	st.w	--sp,r8
80007c10:	fa c8 fb b4 	sub	r8,sp,-1100
80007c14:	0c 9b       	mov	r11,r6
80007c16:	1a d8       	st.w	--sp,r8
80007c18:	08 9c       	mov	r12,r4
80007c1a:	fa c8 f9 40 	sub	r8,sp,-1728
80007c1e:	fa c9 ff b4 	sub	r9,sp,-76
80007c22:	fe b0 f8 11 	rcall	80006c44 <get_arg>
80007c26:	2f dd       	sub	sp,-12
80007c28:	78 0a       	ld.w	r10,r12[0x0]
80007c2a:	c2 08       	rjmp	80007c6a <_vfprintf_r+0xcf6>
80007c2c:	2f f7       	sub	r7,-1
80007c2e:	10 39       	cp.w	r9,r8
80007c30:	c0 84       	brge	80007c40 <_vfprintf_r+0xccc>
80007c32:	fa ca f9 44 	sub	r10,sp,-1724
80007c36:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007c3a:	ec fa fd 88 	ld.w	r10,r6[-632]
80007c3e:	c1 68       	rjmp	80007c6a <_vfprintf_r+0xcf6>
80007c40:	41 09       	lddsp	r9,sp[0x40]
80007c42:	59 f8       	cp.w	r8,31
80007c44:	e0 89 00 10 	brgt	80007c64 <_vfprintf_r+0xcf0>
80007c48:	f2 ca ff fc 	sub	r10,r9,-4
80007c4c:	51 0a       	stdsp	sp[0x40],r10
80007c4e:	fa c6 f9 44 	sub	r6,sp,-1724
80007c52:	72 0a       	ld.w	r10,r9[0x0]
80007c54:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007c58:	f3 4a fd 88 	st.w	r9[-632],r10
80007c5c:	2f f8       	sub	r8,-1
80007c5e:	fb 48 06 b4 	st.w	sp[1716],r8
80007c62:	c0 48       	rjmp	80007c6a <_vfprintf_r+0xcf6>
80007c64:	72 0a       	ld.w	r10,r9[0x0]
80007c66:	2f c9       	sub	r9,-4
80007c68:	51 09       	stdsp	sp[0x40],r9
80007c6a:	40 be       	lddsp	lr,sp[0x2c]
80007c6c:	95 0e       	st.w	r10[0x0],lr
80007c6e:	fe 9f fa 11 	bral	80007090 <_vfprintf_r+0x11c>
80007c72:	50 a7       	stdsp	sp[0x28],r7
80007c74:	50 80       	stdsp	sp[0x20],r0
80007c76:	0c 97       	mov	r7,r6
80007c78:	04 94       	mov	r4,r2
80007c7a:	06 96       	mov	r6,r3
80007c7c:	02 92       	mov	r2,r1
80007c7e:	40 93       	lddsp	r3,sp[0x24]
80007c80:	10 90       	mov	r0,r8
80007c82:	40 41       	lddsp	r1,sp[0x10]
80007c84:	a5 a5       	sbr	r5,0x4
80007c86:	c0 a8       	rjmp	80007c9a <_vfprintf_r+0xd26>
80007c88:	50 a7       	stdsp	sp[0x28],r7
80007c8a:	50 80       	stdsp	sp[0x20],r0
80007c8c:	0c 97       	mov	r7,r6
80007c8e:	04 94       	mov	r4,r2
80007c90:	06 96       	mov	r6,r3
80007c92:	02 92       	mov	r2,r1
80007c94:	40 93       	lddsp	r3,sp[0x24]
80007c96:	10 90       	mov	r0,r8
80007c98:	40 41       	lddsp	r1,sp[0x10]
80007c9a:	ed b5 00 05 	bld	r5,0x5
80007c9e:	c5 d1       	brne	80007d58 <_vfprintf_r+0xde4>
80007ca0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ca4:	40 3c       	lddsp	r12,sp[0xc]
80007ca6:	58 0c       	cp.w	r12,0
80007ca8:	c2 60       	breq	80007cf4 <_vfprintf_r+0xd80>
80007caa:	10 36       	cp.w	r6,r8
80007cac:	c0 a4       	brge	80007cc0 <_vfprintf_r+0xd4c>
80007cae:	fa cb f9 44 	sub	r11,sp,-1724
80007cb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cb6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007cba:	fa e9 00 00 	st.d	sp[0],r8
80007cbe:	c1 88       	rjmp	80007cee <_vfprintf_r+0xd7a>
80007cc0:	fa c8 f9 50 	sub	r8,sp,-1712
80007cc4:	1a d8       	st.w	--sp,r8
80007cc6:	fa c8 fa b8 	sub	r8,sp,-1352
80007cca:	04 9a       	mov	r10,r2
80007ccc:	1a d8       	st.w	--sp,r8
80007cce:	0c 9b       	mov	r11,r6
80007cd0:	fa c8 fb b4 	sub	r8,sp,-1100
80007cd4:	08 9c       	mov	r12,r4
80007cd6:	1a d8       	st.w	--sp,r8
80007cd8:	fa c8 f9 40 	sub	r8,sp,-1728
80007cdc:	fa c9 ff b4 	sub	r9,sp,-76
80007ce0:	fe b0 f7 b2 	rcall	80006c44 <get_arg>
80007ce4:	2f dd       	sub	sp,-12
80007ce6:	f8 ea 00 00 	ld.d	r10,r12[0]
80007cea:	fa eb 00 00 	st.d	sp[0],r10
80007cee:	30 08       	mov	r8,0
80007cf0:	e0 8f 03 de 	bral	800084ac <_vfprintf_r+0x1538>
80007cf4:	ee ca ff ff 	sub	r10,r7,-1
80007cf8:	10 37       	cp.w	r7,r8
80007cfa:	c0 b4       	brge	80007d10 <_vfprintf_r+0xd9c>
80007cfc:	fa c9 f9 44 	sub	r9,sp,-1724
80007d00:	14 97       	mov	r7,r10
80007d02:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d06:	ec ea fd 88 	ld.d	r10,r6[-632]
80007d0a:	fa eb 00 00 	st.d	sp[0],r10
80007d0e:	c1 88       	rjmp	80007d3e <_vfprintf_r+0xdca>
80007d10:	41 09       	lddsp	r9,sp[0x40]
80007d12:	59 f8       	cp.w	r8,31
80007d14:	e0 89 00 18 	brgt	80007d44 <_vfprintf_r+0xdd0>
80007d18:	f2 e6 00 00 	ld.d	r6,r9[0]
80007d1c:	f2 cb ff f8 	sub	r11,r9,-8
80007d20:	fa e7 00 00 	st.d	sp[0],r6
80007d24:	51 0b       	stdsp	sp[0x40],r11
80007d26:	fa c6 f9 44 	sub	r6,sp,-1724
80007d2a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d2e:	fa e6 00 00 	ld.d	r6,sp[0]
80007d32:	f2 e7 fd 88 	st.d	r9[-632],r6
80007d36:	2f f8       	sub	r8,-1
80007d38:	14 97       	mov	r7,r10
80007d3a:	fb 48 06 b4 	st.w	sp[1716],r8
80007d3e:	40 38       	lddsp	r8,sp[0xc]
80007d40:	e0 8f 03 b6 	bral	800084ac <_vfprintf_r+0x1538>
80007d44:	f2 e6 00 00 	ld.d	r6,r9[0]
80007d48:	40 38       	lddsp	r8,sp[0xc]
80007d4a:	fa e7 00 00 	st.d	sp[0],r6
80007d4e:	2f 89       	sub	r9,-8
80007d50:	14 97       	mov	r7,r10
80007d52:	51 09       	stdsp	sp[0x40],r9
80007d54:	e0 8f 03 ac 	bral	800084ac <_vfprintf_r+0x1538>
80007d58:	ed b5 00 04 	bld	r5,0x4
80007d5c:	c1 61       	brne	80007d88 <_vfprintf_r+0xe14>
80007d5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d62:	40 3e       	lddsp	lr,sp[0xc]
80007d64:	58 0e       	cp.w	lr,0
80007d66:	c0 80       	breq	80007d76 <_vfprintf_r+0xe02>
80007d68:	10 36       	cp.w	r6,r8
80007d6a:	c6 74       	brge	80007e38 <_vfprintf_r+0xec4>
80007d6c:	fa cc f9 44 	sub	r12,sp,-1724
80007d70:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d74:	c8 08       	rjmp	80007e74 <_vfprintf_r+0xf00>
80007d76:	ee ca ff ff 	sub	r10,r7,-1
80007d7a:	10 37       	cp.w	r7,r8
80007d7c:	c7 f4       	brge	80007e7a <_vfprintf_r+0xf06>
80007d7e:	fa cb f9 44 	sub	r11,sp,-1724
80007d82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d86:	c7 68       	rjmp	80007e72 <_vfprintf_r+0xefe>
80007d88:	ed b5 00 06 	bld	r5,0x6
80007d8c:	c4 a1       	brne	80007e20 <_vfprintf_r+0xeac>
80007d8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d92:	40 3c       	lddsp	r12,sp[0xc]
80007d94:	58 0c       	cp.w	r12,0
80007d96:	c1 d0       	breq	80007dd0 <_vfprintf_r+0xe5c>
80007d98:	10 36       	cp.w	r6,r8
80007d9a:	c0 64       	brge	80007da6 <_vfprintf_r+0xe32>
80007d9c:	fa cb f9 44 	sub	r11,sp,-1724
80007da0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007da4:	c1 f8       	rjmp	80007de2 <_vfprintf_r+0xe6e>
80007da6:	fa c8 f9 50 	sub	r8,sp,-1712
80007daa:	1a d8       	st.w	--sp,r8
80007dac:	fa c8 fa b8 	sub	r8,sp,-1352
80007db0:	1a d8       	st.w	--sp,r8
80007db2:	fa c8 fb b4 	sub	r8,sp,-1100
80007db6:	1a d8       	st.w	--sp,r8
80007db8:	fa c8 f9 40 	sub	r8,sp,-1728
80007dbc:	fa c9 ff b4 	sub	r9,sp,-76
80007dc0:	04 9a       	mov	r10,r2
80007dc2:	0c 9b       	mov	r11,r6
80007dc4:	08 9c       	mov	r12,r4
80007dc6:	fe b0 f7 3f 	rcall	80006c44 <get_arg>
80007dca:	2f dd       	sub	sp,-12
80007dcc:	98 18       	ld.sh	r8,r12[0x2]
80007dce:	c2 68       	rjmp	80007e1a <_vfprintf_r+0xea6>
80007dd0:	ee ca ff ff 	sub	r10,r7,-1
80007dd4:	10 37       	cp.w	r7,r8
80007dd6:	c0 94       	brge	80007de8 <_vfprintf_r+0xe74>
80007dd8:	fa c9 f9 44 	sub	r9,sp,-1724
80007ddc:	14 97       	mov	r7,r10
80007dde:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007de2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007de6:	c1 a8       	rjmp	80007e1a <_vfprintf_r+0xea6>
80007de8:	41 09       	lddsp	r9,sp[0x40]
80007dea:	59 f8       	cp.w	r8,31
80007dec:	e0 89 00 13 	brgt	80007e12 <_vfprintf_r+0xe9e>
80007df0:	f2 cb ff fc 	sub	r11,r9,-4
80007df4:	51 0b       	stdsp	sp[0x40],r11
80007df6:	72 09       	ld.w	r9,r9[0x0]
80007df8:	fa c6 f9 44 	sub	r6,sp,-1724
80007dfc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007e00:	2f f8       	sub	r8,-1
80007e02:	f7 49 fd 88 	st.w	r11[-632],r9
80007e06:	fb 48 06 b4 	st.w	sp[1716],r8
80007e0a:	14 97       	mov	r7,r10
80007e0c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007e10:	c0 58       	rjmp	80007e1a <_vfprintf_r+0xea6>
80007e12:	92 18       	ld.sh	r8,r9[0x2]
80007e14:	14 97       	mov	r7,r10
80007e16:	2f c9       	sub	r9,-4
80007e18:	51 09       	stdsp	sp[0x40],r9
80007e1a:	5c 78       	castu.h	r8
80007e1c:	50 18       	stdsp	sp[0x4],r8
80007e1e:	c4 68       	rjmp	80007eaa <_vfprintf_r+0xf36>
80007e20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e24:	40 3c       	lddsp	r12,sp[0xc]
80007e26:	58 0c       	cp.w	r12,0
80007e28:	c1 d0       	breq	80007e62 <_vfprintf_r+0xeee>
80007e2a:	10 36       	cp.w	r6,r8
80007e2c:	c0 64       	brge	80007e38 <_vfprintf_r+0xec4>
80007e2e:	fa cb f9 44 	sub	r11,sp,-1724
80007e32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e36:	c1 f8       	rjmp	80007e74 <_vfprintf_r+0xf00>
80007e38:	fa c8 f9 50 	sub	r8,sp,-1712
80007e3c:	1a d8       	st.w	--sp,r8
80007e3e:	fa c8 fa b8 	sub	r8,sp,-1352
80007e42:	0c 9b       	mov	r11,r6
80007e44:	1a d8       	st.w	--sp,r8
80007e46:	fa c8 fb b4 	sub	r8,sp,-1100
80007e4a:	04 9a       	mov	r10,r2
80007e4c:	1a d8       	st.w	--sp,r8
80007e4e:	08 9c       	mov	r12,r4
80007e50:	fa c8 f9 40 	sub	r8,sp,-1728
80007e54:	fa c9 ff b4 	sub	r9,sp,-76
80007e58:	fe b0 f6 f6 	rcall	80006c44 <get_arg>
80007e5c:	2f dd       	sub	sp,-12
80007e5e:	78 0b       	ld.w	r11,r12[0x0]
80007e60:	c2 48       	rjmp	80007ea8 <_vfprintf_r+0xf34>
80007e62:	ee ca ff ff 	sub	r10,r7,-1
80007e66:	10 37       	cp.w	r7,r8
80007e68:	c0 94       	brge	80007e7a <_vfprintf_r+0xf06>
80007e6a:	fa c9 f9 44 	sub	r9,sp,-1724
80007e6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e72:	14 97       	mov	r7,r10
80007e74:	ec fb fd 88 	ld.w	r11,r6[-632]
80007e78:	c1 88       	rjmp	80007ea8 <_vfprintf_r+0xf34>
80007e7a:	41 09       	lddsp	r9,sp[0x40]
80007e7c:	59 f8       	cp.w	r8,31
80007e7e:	e0 89 00 11 	brgt	80007ea0 <_vfprintf_r+0xf2c>
80007e82:	f2 cb ff fc 	sub	r11,r9,-4
80007e86:	51 0b       	stdsp	sp[0x40],r11
80007e88:	fa c6 f9 44 	sub	r6,sp,-1724
80007e8c:	72 0b       	ld.w	r11,r9[0x0]
80007e8e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e92:	f3 4b fd 88 	st.w	r9[-632],r11
80007e96:	2f f8       	sub	r8,-1
80007e98:	14 97       	mov	r7,r10
80007e9a:	fb 48 06 b4 	st.w	sp[1716],r8
80007e9e:	c0 58       	rjmp	80007ea8 <_vfprintf_r+0xf34>
80007ea0:	72 0b       	ld.w	r11,r9[0x0]
80007ea2:	14 97       	mov	r7,r10
80007ea4:	2f c9       	sub	r9,-4
80007ea6:	51 09       	stdsp	sp[0x40],r9
80007ea8:	50 1b       	stdsp	sp[0x4],r11
80007eaa:	30 0e       	mov	lr,0
80007eac:	50 0e       	stdsp	sp[0x0],lr
80007eae:	1c 98       	mov	r8,lr
80007eb0:	e0 8f 02 fe 	bral	800084ac <_vfprintf_r+0x1538>
80007eb4:	50 a7       	stdsp	sp[0x28],r7
80007eb6:	50 80       	stdsp	sp[0x20],r0
80007eb8:	0c 97       	mov	r7,r6
80007eba:	04 94       	mov	r4,r2
80007ebc:	06 96       	mov	r6,r3
80007ebe:	02 92       	mov	r2,r1
80007ec0:	40 93       	lddsp	r3,sp[0x24]
80007ec2:	40 41       	lddsp	r1,sp[0x10]
80007ec4:	0e 99       	mov	r9,r7
80007ec6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007eca:	40 3c       	lddsp	r12,sp[0xc]
80007ecc:	58 0c       	cp.w	r12,0
80007ece:	c1 d0       	breq	80007f08 <_vfprintf_r+0xf94>
80007ed0:	10 36       	cp.w	r6,r8
80007ed2:	c0 64       	brge	80007ede <_vfprintf_r+0xf6a>
80007ed4:	fa cb f9 44 	sub	r11,sp,-1724
80007ed8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007edc:	c1 d8       	rjmp	80007f16 <_vfprintf_r+0xfa2>
80007ede:	fa c8 f9 50 	sub	r8,sp,-1712
80007ee2:	1a d8       	st.w	--sp,r8
80007ee4:	fa c8 fa b8 	sub	r8,sp,-1352
80007ee8:	1a d8       	st.w	--sp,r8
80007eea:	fa c8 fb b4 	sub	r8,sp,-1100
80007eee:	1a d8       	st.w	--sp,r8
80007ef0:	fa c9 ff b4 	sub	r9,sp,-76
80007ef4:	fa c8 f9 40 	sub	r8,sp,-1728
80007ef8:	04 9a       	mov	r10,r2
80007efa:	0c 9b       	mov	r11,r6
80007efc:	08 9c       	mov	r12,r4
80007efe:	fe b0 f6 a3 	rcall	80006c44 <get_arg>
80007f02:	2f dd       	sub	sp,-12
80007f04:	78 09       	ld.w	r9,r12[0x0]
80007f06:	c2 18       	rjmp	80007f48 <_vfprintf_r+0xfd4>
80007f08:	2f f7       	sub	r7,-1
80007f0a:	10 39       	cp.w	r9,r8
80007f0c:	c0 84       	brge	80007f1c <_vfprintf_r+0xfa8>
80007f0e:	fa ca f9 44 	sub	r10,sp,-1724
80007f12:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007f16:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007f1a:	c1 78       	rjmp	80007f48 <_vfprintf_r+0xfd4>
80007f1c:	41 09       	lddsp	r9,sp[0x40]
80007f1e:	59 f8       	cp.w	r8,31
80007f20:	e0 89 00 10 	brgt	80007f40 <_vfprintf_r+0xfcc>
80007f24:	f2 ca ff fc 	sub	r10,r9,-4
80007f28:	51 0a       	stdsp	sp[0x40],r10
80007f2a:	fa c6 f9 44 	sub	r6,sp,-1724
80007f2e:	72 09       	ld.w	r9,r9[0x0]
80007f30:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007f34:	f5 49 fd 88 	st.w	r10[-632],r9
80007f38:	2f f8       	sub	r8,-1
80007f3a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f3e:	c0 58       	rjmp	80007f48 <_vfprintf_r+0xfd4>
80007f40:	f2 c8 ff fc 	sub	r8,r9,-4
80007f44:	51 08       	stdsp	sp[0x40],r8
80007f46:	72 09       	ld.w	r9,r9[0x0]
80007f48:	33 08       	mov	r8,48
80007f4a:	fb 68 06 b8 	st.b	sp[1720],r8
80007f4e:	37 88       	mov	r8,120
80007f50:	30 0e       	mov	lr,0
80007f52:	fb 68 06 b9 	st.b	sp[1721],r8
80007f56:	fe cc b3 0e 	sub	r12,pc,-19698
80007f5a:	50 19       	stdsp	sp[0x4],r9
80007f5c:	a1 b5       	sbr	r5,0x1
80007f5e:	50 0e       	stdsp	sp[0x0],lr
80007f60:	50 dc       	stdsp	sp[0x34],r12
80007f62:	30 28       	mov	r8,2
80007f64:	37 80       	mov	r0,120
80007f66:	e0 8f 02 a3 	bral	800084ac <_vfprintf_r+0x1538>
80007f6a:	50 a7       	stdsp	sp[0x28],r7
80007f6c:	50 80       	stdsp	sp[0x20],r0
80007f6e:	10 90       	mov	r0,r8
80007f70:	30 08       	mov	r8,0
80007f72:	fb 68 06 bb 	st.b	sp[1723],r8
80007f76:	0c 97       	mov	r7,r6
80007f78:	04 94       	mov	r4,r2
80007f7a:	06 96       	mov	r6,r3
80007f7c:	02 92       	mov	r2,r1
80007f7e:	40 93       	lddsp	r3,sp[0x24]
80007f80:	40 41       	lddsp	r1,sp[0x10]
80007f82:	0e 99       	mov	r9,r7
80007f84:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f88:	40 3b       	lddsp	r11,sp[0xc]
80007f8a:	58 0b       	cp.w	r11,0
80007f8c:	c1 d0       	breq	80007fc6 <_vfprintf_r+0x1052>
80007f8e:	10 36       	cp.w	r6,r8
80007f90:	c0 64       	brge	80007f9c <_vfprintf_r+0x1028>
80007f92:	fa ca f9 44 	sub	r10,sp,-1724
80007f96:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007f9a:	c1 d8       	rjmp	80007fd4 <_vfprintf_r+0x1060>
80007f9c:	fa c8 f9 50 	sub	r8,sp,-1712
80007fa0:	1a d8       	st.w	--sp,r8
80007fa2:	fa c8 fa b8 	sub	r8,sp,-1352
80007fa6:	1a d8       	st.w	--sp,r8
80007fa8:	fa c8 fb b4 	sub	r8,sp,-1100
80007fac:	0c 9b       	mov	r11,r6
80007fae:	1a d8       	st.w	--sp,r8
80007fb0:	04 9a       	mov	r10,r2
80007fb2:	fa c8 f9 40 	sub	r8,sp,-1728
80007fb6:	fa c9 ff b4 	sub	r9,sp,-76
80007fba:	08 9c       	mov	r12,r4
80007fbc:	fe b0 f6 44 	rcall	80006c44 <get_arg>
80007fc0:	2f dd       	sub	sp,-12
80007fc2:	78 06       	ld.w	r6,r12[0x0]
80007fc4:	c2 08       	rjmp	80008004 <_vfprintf_r+0x1090>
80007fc6:	2f f7       	sub	r7,-1
80007fc8:	10 39       	cp.w	r9,r8
80007fca:	c0 84       	brge	80007fda <_vfprintf_r+0x1066>
80007fcc:	fa c9 f9 44 	sub	r9,sp,-1724
80007fd0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fd4:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007fd8:	c1 68       	rjmp	80008004 <_vfprintf_r+0x1090>
80007fda:	41 09       	lddsp	r9,sp[0x40]
80007fdc:	59 f8       	cp.w	r8,31
80007fde:	e0 89 00 10 	brgt	80007ffe <_vfprintf_r+0x108a>
80007fe2:	f2 ca ff fc 	sub	r10,r9,-4
80007fe6:	51 0a       	stdsp	sp[0x40],r10
80007fe8:	72 06       	ld.w	r6,r9[0x0]
80007fea:	fa ce f9 44 	sub	lr,sp,-1724
80007fee:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007ff2:	f3 46 fd 88 	st.w	r9[-632],r6
80007ff6:	2f f8       	sub	r8,-1
80007ff8:	fb 48 06 b4 	st.w	sp[1716],r8
80007ffc:	c0 48       	rjmp	80008004 <_vfprintf_r+0x1090>
80007ffe:	72 06       	ld.w	r6,r9[0x0]
80008000:	2f c9       	sub	r9,-4
80008002:	51 09       	stdsp	sp[0x40],r9
80008004:	40 2c       	lddsp	r12,sp[0x8]
80008006:	58 0c       	cp.w	r12,0
80008008:	c1 05       	brlt	80008028 <_vfprintf_r+0x10b4>
8000800a:	18 9a       	mov	r10,r12
8000800c:	30 0b       	mov	r11,0
8000800e:	0c 9c       	mov	r12,r6
80008010:	e0 a0 12 38 	rcall	8000a480 <memchr>
80008014:	e0 80 02 df 	breq	800085d2 <_vfprintf_r+0x165e>
80008018:	f8 06 01 02 	sub	r2,r12,r6
8000801c:	40 2b       	lddsp	r11,sp[0x8]
8000801e:	16 32       	cp.w	r2,r11
80008020:	e0 89 02 d9 	brgt	800085d2 <_vfprintf_r+0x165e>
80008024:	e0 8f 02 d4 	bral	800085cc <_vfprintf_r+0x1658>
80008028:	30 0a       	mov	r10,0
8000802a:	0c 9c       	mov	r12,r6
8000802c:	50 2a       	stdsp	sp[0x8],r10
8000802e:	fe b0 f5 85 	rcall	80006b38 <strlen>
80008032:	18 92       	mov	r2,r12
80008034:	e0 8f 02 d2 	bral	800085d8 <_vfprintf_r+0x1664>
80008038:	50 a7       	stdsp	sp[0x28],r7
8000803a:	50 80       	stdsp	sp[0x20],r0
8000803c:	0c 97       	mov	r7,r6
8000803e:	04 94       	mov	r4,r2
80008040:	06 96       	mov	r6,r3
80008042:	02 92       	mov	r2,r1
80008044:	40 93       	lddsp	r3,sp[0x24]
80008046:	10 90       	mov	r0,r8
80008048:	40 41       	lddsp	r1,sp[0x10]
8000804a:	a5 a5       	sbr	r5,0x4
8000804c:	c0 a8       	rjmp	80008060 <_vfprintf_r+0x10ec>
8000804e:	50 a7       	stdsp	sp[0x28],r7
80008050:	50 80       	stdsp	sp[0x20],r0
80008052:	0c 97       	mov	r7,r6
80008054:	04 94       	mov	r4,r2
80008056:	06 96       	mov	r6,r3
80008058:	02 92       	mov	r2,r1
8000805a:	40 93       	lddsp	r3,sp[0x24]
8000805c:	10 90       	mov	r0,r8
8000805e:	40 41       	lddsp	r1,sp[0x10]
80008060:	ed b5 00 05 	bld	r5,0x5
80008064:	c5 61       	brne	80008110 <_vfprintf_r+0x119c>
80008066:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000806a:	40 39       	lddsp	r9,sp[0xc]
8000806c:	58 09       	cp.w	r9,0
8000806e:	c2 10       	breq	800080b0 <_vfprintf_r+0x113c>
80008070:	10 36       	cp.w	r6,r8
80008072:	c0 74       	brge	80008080 <_vfprintf_r+0x110c>
80008074:	fa c8 f9 44 	sub	r8,sp,-1724
80008078:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000807c:	c2 38       	rjmp	800080c2 <_vfprintf_r+0x114e>
8000807e:	d7 03       	nop
80008080:	fa c8 f9 50 	sub	r8,sp,-1712
80008084:	1a d8       	st.w	--sp,r8
80008086:	fa c8 fa b8 	sub	r8,sp,-1352
8000808a:	1a d8       	st.w	--sp,r8
8000808c:	fa c8 fb b4 	sub	r8,sp,-1100
80008090:	1a d8       	st.w	--sp,r8
80008092:	fa c8 f9 40 	sub	r8,sp,-1728
80008096:	fa c9 ff b4 	sub	r9,sp,-76
8000809a:	04 9a       	mov	r10,r2
8000809c:	0c 9b       	mov	r11,r6
8000809e:	08 9c       	mov	r12,r4
800080a0:	fe b0 f5 d2 	rcall	80006c44 <get_arg>
800080a4:	2f dd       	sub	sp,-12
800080a6:	f8 e8 00 00 	ld.d	r8,r12[0]
800080aa:	fa e9 00 00 	st.d	sp[0],r8
800080ae:	c2 e8       	rjmp	8000810a <_vfprintf_r+0x1196>
800080b0:	ee ca ff ff 	sub	r10,r7,-1
800080b4:	10 37       	cp.w	r7,r8
800080b6:	c0 b4       	brge	800080cc <_vfprintf_r+0x1158>
800080b8:	fa c8 f9 44 	sub	r8,sp,-1724
800080bc:	14 97       	mov	r7,r10
800080be:	f0 06 00 36 	add	r6,r8,r6<<0x3
800080c2:	ec ea fd 88 	ld.d	r10,r6[-632]
800080c6:	fa eb 00 00 	st.d	sp[0],r10
800080ca:	c2 08       	rjmp	8000810a <_vfprintf_r+0x1196>
800080cc:	41 09       	lddsp	r9,sp[0x40]
800080ce:	59 f8       	cp.w	r8,31
800080d0:	e0 89 00 16 	brgt	800080fc <_vfprintf_r+0x1188>
800080d4:	f2 e6 00 00 	ld.d	r6,r9[0]
800080d8:	f2 cb ff f8 	sub	r11,r9,-8
800080dc:	fa e7 00 00 	st.d	sp[0],r6
800080e0:	51 0b       	stdsp	sp[0x40],r11
800080e2:	fa c6 f9 44 	sub	r6,sp,-1724
800080e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080ea:	fa e6 00 00 	ld.d	r6,sp[0]
800080ee:	f2 e7 fd 88 	st.d	r9[-632],r6
800080f2:	2f f8       	sub	r8,-1
800080f4:	14 97       	mov	r7,r10
800080f6:	fb 48 06 b4 	st.w	sp[1716],r8
800080fa:	c0 88       	rjmp	8000810a <_vfprintf_r+0x1196>
800080fc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008100:	2f 89       	sub	r9,-8
80008102:	fa e7 00 00 	st.d	sp[0],r6
80008106:	51 09       	stdsp	sp[0x40],r9
80008108:	14 97       	mov	r7,r10
8000810a:	30 18       	mov	r8,1
8000810c:	e0 8f 01 d0 	bral	800084ac <_vfprintf_r+0x1538>
80008110:	ed b5 00 04 	bld	r5,0x4
80008114:	c1 61       	brne	80008140 <_vfprintf_r+0x11cc>
80008116:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000811a:	40 3e       	lddsp	lr,sp[0xc]
8000811c:	58 0e       	cp.w	lr,0
8000811e:	c0 80       	breq	8000812e <_vfprintf_r+0x11ba>
80008120:	10 36       	cp.w	r6,r8
80008122:	c6 74       	brge	800081f0 <_vfprintf_r+0x127c>
80008124:	fa cc f9 44 	sub	r12,sp,-1724
80008128:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000812c:	c8 08       	rjmp	8000822c <_vfprintf_r+0x12b8>
8000812e:	ee ca ff ff 	sub	r10,r7,-1
80008132:	10 37       	cp.w	r7,r8
80008134:	c7 f4       	brge	80008232 <_vfprintf_r+0x12be>
80008136:	fa cb f9 44 	sub	r11,sp,-1724
8000813a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000813e:	c7 68       	rjmp	8000822a <_vfprintf_r+0x12b6>
80008140:	ed b5 00 06 	bld	r5,0x6
80008144:	c4 a1       	brne	800081d8 <_vfprintf_r+0x1264>
80008146:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000814a:	40 3c       	lddsp	r12,sp[0xc]
8000814c:	58 0c       	cp.w	r12,0
8000814e:	c1 d0       	breq	80008188 <_vfprintf_r+0x1214>
80008150:	10 36       	cp.w	r6,r8
80008152:	c0 64       	brge	8000815e <_vfprintf_r+0x11ea>
80008154:	fa cb f9 44 	sub	r11,sp,-1724
80008158:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000815c:	c1 f8       	rjmp	8000819a <_vfprintf_r+0x1226>
8000815e:	fa c8 f9 50 	sub	r8,sp,-1712
80008162:	1a d8       	st.w	--sp,r8
80008164:	fa c8 fa b8 	sub	r8,sp,-1352
80008168:	1a d8       	st.w	--sp,r8
8000816a:	fa c8 fb b4 	sub	r8,sp,-1100
8000816e:	1a d8       	st.w	--sp,r8
80008170:	fa c8 f9 40 	sub	r8,sp,-1728
80008174:	fa c9 ff b4 	sub	r9,sp,-76
80008178:	04 9a       	mov	r10,r2
8000817a:	0c 9b       	mov	r11,r6
8000817c:	08 9c       	mov	r12,r4
8000817e:	fe b0 f5 63 	rcall	80006c44 <get_arg>
80008182:	2f dd       	sub	sp,-12
80008184:	98 18       	ld.sh	r8,r12[0x2]
80008186:	c2 68       	rjmp	800081d2 <_vfprintf_r+0x125e>
80008188:	ee ca ff ff 	sub	r10,r7,-1
8000818c:	10 37       	cp.w	r7,r8
8000818e:	c0 94       	brge	800081a0 <_vfprintf_r+0x122c>
80008190:	fa c9 f9 44 	sub	r9,sp,-1724
80008194:	14 97       	mov	r7,r10
80008196:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000819a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000819e:	c1 a8       	rjmp	800081d2 <_vfprintf_r+0x125e>
800081a0:	41 09       	lddsp	r9,sp[0x40]
800081a2:	59 f8       	cp.w	r8,31
800081a4:	e0 89 00 13 	brgt	800081ca <_vfprintf_r+0x1256>
800081a8:	f2 cb ff fc 	sub	r11,r9,-4
800081ac:	51 0b       	stdsp	sp[0x40],r11
800081ae:	72 09       	ld.w	r9,r9[0x0]
800081b0:	fa c6 f9 44 	sub	r6,sp,-1724
800081b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800081b8:	2f f8       	sub	r8,-1
800081ba:	f7 49 fd 88 	st.w	r11[-632],r9
800081be:	fb 48 06 b4 	st.w	sp[1716],r8
800081c2:	14 97       	mov	r7,r10
800081c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800081c8:	c0 58       	rjmp	800081d2 <_vfprintf_r+0x125e>
800081ca:	92 18       	ld.sh	r8,r9[0x2]
800081cc:	14 97       	mov	r7,r10
800081ce:	2f c9       	sub	r9,-4
800081d0:	51 09       	stdsp	sp[0x40],r9
800081d2:	5c 78       	castu.h	r8
800081d4:	50 18       	stdsp	sp[0x4],r8
800081d6:	c4 68       	rjmp	80008262 <_vfprintf_r+0x12ee>
800081d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081dc:	40 3c       	lddsp	r12,sp[0xc]
800081de:	58 0c       	cp.w	r12,0
800081e0:	c1 d0       	breq	8000821a <_vfprintf_r+0x12a6>
800081e2:	10 36       	cp.w	r6,r8
800081e4:	c0 64       	brge	800081f0 <_vfprintf_r+0x127c>
800081e6:	fa cb f9 44 	sub	r11,sp,-1724
800081ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081ee:	c1 f8       	rjmp	8000822c <_vfprintf_r+0x12b8>
800081f0:	fa c8 f9 50 	sub	r8,sp,-1712
800081f4:	1a d8       	st.w	--sp,r8
800081f6:	fa c8 fa b8 	sub	r8,sp,-1352
800081fa:	0c 9b       	mov	r11,r6
800081fc:	1a d8       	st.w	--sp,r8
800081fe:	fa c8 fb b4 	sub	r8,sp,-1100
80008202:	04 9a       	mov	r10,r2
80008204:	1a d8       	st.w	--sp,r8
80008206:	08 9c       	mov	r12,r4
80008208:	fa c8 f9 40 	sub	r8,sp,-1728
8000820c:	fa c9 ff b4 	sub	r9,sp,-76
80008210:	fe b0 f5 1a 	rcall	80006c44 <get_arg>
80008214:	2f dd       	sub	sp,-12
80008216:	78 0b       	ld.w	r11,r12[0x0]
80008218:	c2 48       	rjmp	80008260 <_vfprintf_r+0x12ec>
8000821a:	ee ca ff ff 	sub	r10,r7,-1
8000821e:	10 37       	cp.w	r7,r8
80008220:	c0 94       	brge	80008232 <_vfprintf_r+0x12be>
80008222:	fa c9 f9 44 	sub	r9,sp,-1724
80008226:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000822a:	14 97       	mov	r7,r10
8000822c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008230:	c1 88       	rjmp	80008260 <_vfprintf_r+0x12ec>
80008232:	41 09       	lddsp	r9,sp[0x40]
80008234:	59 f8       	cp.w	r8,31
80008236:	e0 89 00 11 	brgt	80008258 <_vfprintf_r+0x12e4>
8000823a:	f2 cb ff fc 	sub	r11,r9,-4
8000823e:	51 0b       	stdsp	sp[0x40],r11
80008240:	fa c6 f9 44 	sub	r6,sp,-1724
80008244:	72 0b       	ld.w	r11,r9[0x0]
80008246:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000824a:	f3 4b fd 88 	st.w	r9[-632],r11
8000824e:	2f f8       	sub	r8,-1
80008250:	14 97       	mov	r7,r10
80008252:	fb 48 06 b4 	st.w	sp[1716],r8
80008256:	c0 58       	rjmp	80008260 <_vfprintf_r+0x12ec>
80008258:	72 0b       	ld.w	r11,r9[0x0]
8000825a:	14 97       	mov	r7,r10
8000825c:	2f c9       	sub	r9,-4
8000825e:	51 09       	stdsp	sp[0x40],r9
80008260:	50 1b       	stdsp	sp[0x4],r11
80008262:	30 0e       	mov	lr,0
80008264:	30 18       	mov	r8,1
80008266:	50 0e       	stdsp	sp[0x0],lr
80008268:	c2 29       	rjmp	800084ac <_vfprintf_r+0x1538>
8000826a:	50 a7       	stdsp	sp[0x28],r7
8000826c:	50 80       	stdsp	sp[0x20],r0
8000826e:	0c 97       	mov	r7,r6
80008270:	04 94       	mov	r4,r2
80008272:	06 96       	mov	r6,r3
80008274:	02 92       	mov	r2,r1
80008276:	fe cc b6 2e 	sub	r12,pc,-18898
8000827a:	40 93       	lddsp	r3,sp[0x24]
8000827c:	10 90       	mov	r0,r8
8000827e:	40 41       	lddsp	r1,sp[0x10]
80008280:	50 dc       	stdsp	sp[0x34],r12
80008282:	ed b5 00 05 	bld	r5,0x5
80008286:	c5 51       	brne	80008330 <_vfprintf_r+0x13bc>
80008288:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000828c:	40 3b       	lddsp	r11,sp[0xc]
8000828e:	58 0b       	cp.w	r11,0
80008290:	c2 20       	breq	800082d4 <_vfprintf_r+0x1360>
80008292:	10 36       	cp.w	r6,r8
80008294:	c0 a4       	brge	800082a8 <_vfprintf_r+0x1334>
80008296:	fa ca f9 44 	sub	r10,sp,-1724
8000829a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000829e:	ec e8 fd 88 	ld.d	r8,r6[-632]
800082a2:	fa e9 00 00 	st.d	sp[0],r8
800082a6:	cf 28       	rjmp	8000848a <_vfprintf_r+0x1516>
800082a8:	fa c8 f9 50 	sub	r8,sp,-1712
800082ac:	1a d8       	st.w	--sp,r8
800082ae:	fa c8 fa b8 	sub	r8,sp,-1352
800082b2:	04 9a       	mov	r10,r2
800082b4:	1a d8       	st.w	--sp,r8
800082b6:	0c 9b       	mov	r11,r6
800082b8:	fa c8 fb b4 	sub	r8,sp,-1100
800082bc:	08 9c       	mov	r12,r4
800082be:	1a d8       	st.w	--sp,r8
800082c0:	fa c8 f9 40 	sub	r8,sp,-1728
800082c4:	fa c9 ff b4 	sub	r9,sp,-76
800082c8:	fe b0 f4 be 	rcall	80006c44 <get_arg>
800082cc:	2f dd       	sub	sp,-12
800082ce:	f8 ea 00 00 	ld.d	r10,r12[0]
800082d2:	c0 c8       	rjmp	800082ea <_vfprintf_r+0x1376>
800082d4:	ee ca ff ff 	sub	r10,r7,-1
800082d8:	10 37       	cp.w	r7,r8
800082da:	c0 b4       	brge	800082f0 <_vfprintf_r+0x137c>
800082dc:	fa c9 f9 44 	sub	r9,sp,-1724
800082e0:	14 97       	mov	r7,r10
800082e2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082e6:	ec ea fd 88 	ld.d	r10,r6[-632]
800082ea:	fa eb 00 00 	st.d	sp[0],r10
800082ee:	cc e8       	rjmp	8000848a <_vfprintf_r+0x1516>
800082f0:	41 09       	lddsp	r9,sp[0x40]
800082f2:	59 f8       	cp.w	r8,31
800082f4:	e0 89 00 16 	brgt	80008320 <_vfprintf_r+0x13ac>
800082f8:	f2 e6 00 00 	ld.d	r6,r9[0]
800082fc:	f2 cb ff f8 	sub	r11,r9,-8
80008300:	fa e7 00 00 	st.d	sp[0],r6
80008304:	51 0b       	stdsp	sp[0x40],r11
80008306:	fa c6 f9 44 	sub	r6,sp,-1724
8000830a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000830e:	fa e6 00 00 	ld.d	r6,sp[0]
80008312:	f2 e7 fd 88 	st.d	r9[-632],r6
80008316:	2f f8       	sub	r8,-1
80008318:	14 97       	mov	r7,r10
8000831a:	fb 48 06 b4 	st.w	sp[1716],r8
8000831e:	cb 68       	rjmp	8000848a <_vfprintf_r+0x1516>
80008320:	f2 e6 00 00 	ld.d	r6,r9[0]
80008324:	2f 89       	sub	r9,-8
80008326:	fa e7 00 00 	st.d	sp[0],r6
8000832a:	51 09       	stdsp	sp[0x40],r9
8000832c:	14 97       	mov	r7,r10
8000832e:	ca e8       	rjmp	8000848a <_vfprintf_r+0x1516>
80008330:	ed b5 00 04 	bld	r5,0x4
80008334:	c1 71       	brne	80008362 <_vfprintf_r+0x13ee>
80008336:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000833a:	40 3e       	lddsp	lr,sp[0xc]
8000833c:	58 0e       	cp.w	lr,0
8000833e:	c0 80       	breq	8000834e <_vfprintf_r+0x13da>
80008340:	10 36       	cp.w	r6,r8
80008342:	c6 94       	brge	80008414 <_vfprintf_r+0x14a0>
80008344:	fa cc f9 44 	sub	r12,sp,-1724
80008348:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000834c:	c8 28       	rjmp	80008450 <_vfprintf_r+0x14dc>
8000834e:	ee ca ff ff 	sub	r10,r7,-1
80008352:	10 37       	cp.w	r7,r8
80008354:	e0 84 00 81 	brge	80008456 <_vfprintf_r+0x14e2>
80008358:	fa cb f9 44 	sub	r11,sp,-1724
8000835c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008360:	c7 78       	rjmp	8000844e <_vfprintf_r+0x14da>
80008362:	ed b5 00 06 	bld	r5,0x6
80008366:	c4 b1       	brne	800083fc <_vfprintf_r+0x1488>
80008368:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000836c:	40 3c       	lddsp	r12,sp[0xc]
8000836e:	58 0c       	cp.w	r12,0
80008370:	c1 d0       	breq	800083aa <_vfprintf_r+0x1436>
80008372:	10 36       	cp.w	r6,r8
80008374:	c0 64       	brge	80008380 <_vfprintf_r+0x140c>
80008376:	fa cb f9 44 	sub	r11,sp,-1724
8000837a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000837e:	c1 f8       	rjmp	800083bc <_vfprintf_r+0x1448>
80008380:	fa c8 f9 50 	sub	r8,sp,-1712
80008384:	1a d8       	st.w	--sp,r8
80008386:	fa c8 fa b8 	sub	r8,sp,-1352
8000838a:	1a d8       	st.w	--sp,r8
8000838c:	fa c8 fb b4 	sub	r8,sp,-1100
80008390:	1a d8       	st.w	--sp,r8
80008392:	fa c8 f9 40 	sub	r8,sp,-1728
80008396:	fa c9 ff b4 	sub	r9,sp,-76
8000839a:	04 9a       	mov	r10,r2
8000839c:	0c 9b       	mov	r11,r6
8000839e:	08 9c       	mov	r12,r4
800083a0:	fe b0 f4 52 	rcall	80006c44 <get_arg>
800083a4:	2f dd       	sub	sp,-12
800083a6:	98 18       	ld.sh	r8,r12[0x2]
800083a8:	c2 78       	rjmp	800083f6 <_vfprintf_r+0x1482>
800083aa:	ee ca ff ff 	sub	r10,r7,-1
800083ae:	10 37       	cp.w	r7,r8
800083b0:	c0 a4       	brge	800083c4 <_vfprintf_r+0x1450>
800083b2:	fa c9 f9 44 	sub	r9,sp,-1724
800083b6:	14 97       	mov	r7,r10
800083b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083bc:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800083c0:	c1 b8       	rjmp	800083f6 <_vfprintf_r+0x1482>
800083c2:	d7 03       	nop
800083c4:	41 09       	lddsp	r9,sp[0x40]
800083c6:	59 f8       	cp.w	r8,31
800083c8:	e0 89 00 13 	brgt	800083ee <_vfprintf_r+0x147a>
800083cc:	f2 cb ff fc 	sub	r11,r9,-4
800083d0:	51 0b       	stdsp	sp[0x40],r11
800083d2:	72 09       	ld.w	r9,r9[0x0]
800083d4:	fa c6 f9 44 	sub	r6,sp,-1724
800083d8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800083dc:	2f f8       	sub	r8,-1
800083de:	f7 49 fd 88 	st.w	r11[-632],r9
800083e2:	fb 48 06 b4 	st.w	sp[1716],r8
800083e6:	14 97       	mov	r7,r10
800083e8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800083ec:	c0 58       	rjmp	800083f6 <_vfprintf_r+0x1482>
800083ee:	92 18       	ld.sh	r8,r9[0x2]
800083f0:	14 97       	mov	r7,r10
800083f2:	2f c9       	sub	r9,-4
800083f4:	51 09       	stdsp	sp[0x40],r9
800083f6:	5c 78       	castu.h	r8
800083f8:	50 18       	stdsp	sp[0x4],r8
800083fa:	c4 68       	rjmp	80008486 <_vfprintf_r+0x1512>
800083fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008400:	40 3c       	lddsp	r12,sp[0xc]
80008402:	58 0c       	cp.w	r12,0
80008404:	c1 d0       	breq	8000843e <_vfprintf_r+0x14ca>
80008406:	10 36       	cp.w	r6,r8
80008408:	c0 64       	brge	80008414 <_vfprintf_r+0x14a0>
8000840a:	fa cb f9 44 	sub	r11,sp,-1724
8000840e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008412:	c1 f8       	rjmp	80008450 <_vfprintf_r+0x14dc>
80008414:	fa c8 f9 50 	sub	r8,sp,-1712
80008418:	1a d8       	st.w	--sp,r8
8000841a:	fa c8 fa b8 	sub	r8,sp,-1352
8000841e:	0c 9b       	mov	r11,r6
80008420:	1a d8       	st.w	--sp,r8
80008422:	fa c8 fb b4 	sub	r8,sp,-1100
80008426:	04 9a       	mov	r10,r2
80008428:	1a d8       	st.w	--sp,r8
8000842a:	08 9c       	mov	r12,r4
8000842c:	fa c8 f9 40 	sub	r8,sp,-1728
80008430:	fa c9 ff b4 	sub	r9,sp,-76
80008434:	fe b0 f4 08 	rcall	80006c44 <get_arg>
80008438:	2f dd       	sub	sp,-12
8000843a:	78 0b       	ld.w	r11,r12[0x0]
8000843c:	c2 48       	rjmp	80008484 <_vfprintf_r+0x1510>
8000843e:	ee ca ff ff 	sub	r10,r7,-1
80008442:	10 37       	cp.w	r7,r8
80008444:	c0 94       	brge	80008456 <_vfprintf_r+0x14e2>
80008446:	fa c9 f9 44 	sub	r9,sp,-1724
8000844a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000844e:	14 97       	mov	r7,r10
80008450:	ec fb fd 88 	ld.w	r11,r6[-632]
80008454:	c1 88       	rjmp	80008484 <_vfprintf_r+0x1510>
80008456:	41 09       	lddsp	r9,sp[0x40]
80008458:	59 f8       	cp.w	r8,31
8000845a:	e0 89 00 11 	brgt	8000847c <_vfprintf_r+0x1508>
8000845e:	f2 cb ff fc 	sub	r11,r9,-4
80008462:	51 0b       	stdsp	sp[0x40],r11
80008464:	fa c6 f9 44 	sub	r6,sp,-1724
80008468:	72 0b       	ld.w	r11,r9[0x0]
8000846a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000846e:	f3 4b fd 88 	st.w	r9[-632],r11
80008472:	2f f8       	sub	r8,-1
80008474:	14 97       	mov	r7,r10
80008476:	fb 48 06 b4 	st.w	sp[1716],r8
8000847a:	c0 58       	rjmp	80008484 <_vfprintf_r+0x1510>
8000847c:	72 0b       	ld.w	r11,r9[0x0]
8000847e:	14 97       	mov	r7,r10
80008480:	2f c9       	sub	r9,-4
80008482:	51 09       	stdsp	sp[0x40],r9
80008484:	50 1b       	stdsp	sp[0x4],r11
80008486:	30 0e       	mov	lr,0
80008488:	50 0e       	stdsp	sp[0x0],lr
8000848a:	40 08       	lddsp	r8,sp[0x0]
8000848c:	40 1c       	lddsp	r12,sp[0x4]
8000848e:	18 48       	or	r8,r12
80008490:	5f 19       	srne	r9
80008492:	0a 98       	mov	r8,r5
80008494:	eb e9 00 09 	and	r9,r5,r9
80008498:	a1 b8       	sbr	r8,0x1
8000849a:	58 09       	cp.w	r9,0
8000849c:	c0 70       	breq	800084aa <_vfprintf_r+0x1536>
8000849e:	10 95       	mov	r5,r8
800084a0:	fb 60 06 b9 	st.b	sp[1721],r0
800084a4:	33 08       	mov	r8,48
800084a6:	fb 68 06 b8 	st.b	sp[1720],r8
800084aa:	30 28       	mov	r8,2
800084ac:	30 09       	mov	r9,0
800084ae:	fb 69 06 bb 	st.b	sp[1723],r9
800084b2:	0a 99       	mov	r9,r5
800084b4:	a7 d9       	cbr	r9,0x7
800084b6:	40 2b       	lddsp	r11,sp[0x8]
800084b8:	40 16       	lddsp	r6,sp[0x4]
800084ba:	58 0b       	cp.w	r11,0
800084bc:	5f 1a       	srne	r10
800084be:	f2 05 17 40 	movge	r5,r9
800084c2:	fa c2 f9 78 	sub	r2,sp,-1672
800084c6:	40 09       	lddsp	r9,sp[0x0]
800084c8:	0c 49       	or	r9,r6
800084ca:	5f 19       	srne	r9
800084cc:	f5 e9 10 09 	or	r9,r10,r9
800084d0:	c5 c0       	breq	80008588 <_vfprintf_r+0x1614>
800084d2:	30 19       	mov	r9,1
800084d4:	f2 08 18 00 	cp.b	r8,r9
800084d8:	c0 60       	breq	800084e4 <_vfprintf_r+0x1570>
800084da:	30 29       	mov	r9,2
800084dc:	f2 08 18 00 	cp.b	r8,r9
800084e0:	c0 41       	brne	800084e8 <_vfprintf_r+0x1574>
800084e2:	c3 c8       	rjmp	8000855a <_vfprintf_r+0x15e6>
800084e4:	04 96       	mov	r6,r2
800084e6:	c3 08       	rjmp	80008546 <_vfprintf_r+0x15d2>
800084e8:	04 96       	mov	r6,r2
800084ea:	fa e8 00 00 	ld.d	r8,sp[0]
800084ee:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800084f2:	2d 0a       	sub	r10,-48
800084f4:	0c fa       	st.b	--r6,r10
800084f6:	f0 0b 16 03 	lsr	r11,r8,0x3
800084fa:	f2 0c 16 03 	lsr	r12,r9,0x3
800084fe:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008502:	18 99       	mov	r9,r12
80008504:	16 98       	mov	r8,r11
80008506:	58 08       	cp.w	r8,0
80008508:	5c 29       	cpc	r9
8000850a:	cf 21       	brne	800084ee <_vfprintf_r+0x157a>
8000850c:	fa e9 00 00 	st.d	sp[0],r8
80008510:	ed b5 00 00 	bld	r5,0x0
80008514:	c4 51       	brne	8000859e <_vfprintf_r+0x162a>
80008516:	33 09       	mov	r9,48
80008518:	f2 0a 18 00 	cp.b	r10,r9
8000851c:	c4 10       	breq	8000859e <_vfprintf_r+0x162a>
8000851e:	0c f9       	st.b	--r6,r9
80008520:	c3 f8       	rjmp	8000859e <_vfprintf_r+0x162a>
80008522:	fa ea 00 00 	ld.d	r10,sp[0]
80008526:	30 a8       	mov	r8,10
80008528:	30 09       	mov	r9,0
8000852a:	e0 a0 1a 0d 	rcall	8000b944 <__avr32_umod64>
8000852e:	30 a8       	mov	r8,10
80008530:	2d 0a       	sub	r10,-48
80008532:	30 09       	mov	r9,0
80008534:	ac 8a       	st.b	r6[0x0],r10
80008536:	fa ea 00 00 	ld.d	r10,sp[0]
8000853a:	e0 a0 18 d3 	rcall	8000b6e0 <__avr32_udiv64>
8000853e:	16 99       	mov	r9,r11
80008540:	14 98       	mov	r8,r10
80008542:	fa e9 00 00 	st.d	sp[0],r8
80008546:	20 16       	sub	r6,1
80008548:	fa ea 00 00 	ld.d	r10,sp[0]
8000854c:	58 9a       	cp.w	r10,9
8000854e:	5c 2b       	cpc	r11
80008550:	fe 9b ff e9 	brhi	80008522 <_vfprintf_r+0x15ae>
80008554:	1b f8       	ld.ub	r8,sp[0x7]
80008556:	2d 08       	sub	r8,-48
80008558:	c2 08       	rjmp	80008598 <_vfprintf_r+0x1624>
8000855a:	04 96       	mov	r6,r2
8000855c:	fa e8 00 00 	ld.d	r8,sp[0]
80008560:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008564:	40 de       	lddsp	lr,sp[0x34]
80008566:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000856a:	0c fa       	st.b	--r6,r10
8000856c:	f2 0b 16 04 	lsr	r11,r9,0x4
80008570:	f0 0a 16 04 	lsr	r10,r8,0x4
80008574:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008578:	16 99       	mov	r9,r11
8000857a:	14 98       	mov	r8,r10
8000857c:	58 08       	cp.w	r8,0
8000857e:	5c 29       	cpc	r9
80008580:	cf 01       	brne	80008560 <_vfprintf_r+0x15ec>
80008582:	fa e9 00 00 	st.d	sp[0],r8
80008586:	c0 c8       	rjmp	8000859e <_vfprintf_r+0x162a>
80008588:	58 08       	cp.w	r8,0
8000858a:	c0 91       	brne	8000859c <_vfprintf_r+0x1628>
8000858c:	ed b5 00 00 	bld	r5,0x0
80008590:	c0 61       	brne	8000859c <_vfprintf_r+0x1628>
80008592:	fa c6 f9 79 	sub	r6,sp,-1671
80008596:	33 08       	mov	r8,48
80008598:	ac 88       	st.b	r6[0x0],r8
8000859a:	c0 28       	rjmp	8000859e <_vfprintf_r+0x162a>
8000859c:	04 96       	mov	r6,r2
8000859e:	0c 12       	sub	r2,r6
800085a0:	c1 c8       	rjmp	800085d8 <_vfprintf_r+0x1664>
800085a2:	50 a7       	stdsp	sp[0x28],r7
800085a4:	50 80       	stdsp	sp[0x20],r0
800085a6:	40 93       	lddsp	r3,sp[0x24]
800085a8:	0c 97       	mov	r7,r6
800085aa:	10 90       	mov	r0,r8
800085ac:	04 94       	mov	r4,r2
800085ae:	40 41       	lddsp	r1,sp[0x10]
800085b0:	58 08       	cp.w	r8,0
800085b2:	e0 80 04 4f 	breq	80008e50 <_vfprintf_r+0x1edc>
800085b6:	fb 68 06 60 	st.b	sp[1632],r8
800085ba:	30 0c       	mov	r12,0
800085bc:	30 08       	mov	r8,0
800085be:	30 12       	mov	r2,1
800085c0:	fb 68 06 bb 	st.b	sp[1723],r8
800085c4:	50 2c       	stdsp	sp[0x8],r12
800085c6:	fa c6 f9 a0 	sub	r6,sp,-1632
800085ca:	c0 78       	rjmp	800085d8 <_vfprintf_r+0x1664>
800085cc:	30 0b       	mov	r11,0
800085ce:	50 2b       	stdsp	sp[0x8],r11
800085d0:	c0 48       	rjmp	800085d8 <_vfprintf_r+0x1664>
800085d2:	40 22       	lddsp	r2,sp[0x8]
800085d4:	30 0a       	mov	r10,0
800085d6:	50 2a       	stdsp	sp[0x8],r10
800085d8:	40 29       	lddsp	r9,sp[0x8]
800085da:	e4 09 0c 49 	max	r9,r2,r9
800085de:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800085e2:	50 39       	stdsp	sp[0xc],r9
800085e4:	0a 9e       	mov	lr,r5
800085e6:	30 09       	mov	r9,0
800085e8:	e2 1e 00 02 	andl	lr,0x2,COH
800085ec:	f2 08 18 00 	cp.b	r8,r9
800085f0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800085f4:	f7 b8 01 ff 	subne	r8,-1
800085f8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800085fc:	0a 9b       	mov	r11,r5
800085fe:	58 0e       	cp.w	lr,0
80008600:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008604:	f7 bc 01 fe 	subne	r12,-2
80008608:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000860c:	e2 1b 00 84 	andl	r11,0x84,COH
80008610:	50 fe       	stdsp	sp[0x3c],lr
80008612:	50 9b       	stdsp	sp[0x24],r11
80008614:	c4 71       	brne	800086a2 <_vfprintf_r+0x172e>
80008616:	40 8a       	lddsp	r10,sp[0x20]
80008618:	40 39       	lddsp	r9,sp[0xc]
8000861a:	12 1a       	sub	r10,r9
8000861c:	50 4a       	stdsp	sp[0x10],r10
8000861e:	58 0a       	cp.w	r10,0
80008620:	e0 89 00 20 	brgt	80008660 <_vfprintf_r+0x16ec>
80008624:	c3 f8       	rjmp	800086a2 <_vfprintf_r+0x172e>
80008626:	2f 09       	sub	r9,-16
80008628:	2f f8       	sub	r8,-1
8000862a:	fe ce b9 ca 	sub	lr,pc,-17974
8000862e:	31 0c       	mov	r12,16
80008630:	fb 49 06 90 	st.w	sp[1680],r9
80008634:	87 0e       	st.w	r3[0x0],lr
80008636:	87 1c       	st.w	r3[0x4],r12
80008638:	fb 48 06 8c 	st.w	sp[1676],r8
8000863c:	58 78       	cp.w	r8,7
8000863e:	e0 89 00 04 	brgt	80008646 <_vfprintf_r+0x16d2>
80008642:	2f 83       	sub	r3,-8
80008644:	c0 b8       	rjmp	8000865a <_vfprintf_r+0x16e6>
80008646:	fa ca f9 78 	sub	r10,sp,-1672
8000864a:	02 9b       	mov	r11,r1
8000864c:	08 9c       	mov	r12,r4
8000864e:	fe b0 f4 85 	rcall	80006f58 <__sprint_r>
80008652:	e0 81 04 10 	brne	80008e72 <_vfprintf_r+0x1efe>
80008656:	fa c3 f9 e0 	sub	r3,sp,-1568
8000865a:	40 4b       	lddsp	r11,sp[0x10]
8000865c:	21 0b       	sub	r11,16
8000865e:	50 4b       	stdsp	sp[0x10],r11
80008660:	fa f9 06 90 	ld.w	r9,sp[1680]
80008664:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008668:	fe ca ba 08 	sub	r10,pc,-17912
8000866c:	40 4e       	lddsp	lr,sp[0x10]
8000866e:	59 0e       	cp.w	lr,16
80008670:	fe 99 ff db 	brgt	80008626 <_vfprintf_r+0x16b2>
80008674:	1c 09       	add	r9,lr
80008676:	2f f8       	sub	r8,-1
80008678:	87 0a       	st.w	r3[0x0],r10
8000867a:	fb 49 06 90 	st.w	sp[1680],r9
8000867e:	87 1e       	st.w	r3[0x4],lr
80008680:	fb 48 06 8c 	st.w	sp[1676],r8
80008684:	58 78       	cp.w	r8,7
80008686:	e0 89 00 04 	brgt	8000868e <_vfprintf_r+0x171a>
8000868a:	2f 83       	sub	r3,-8
8000868c:	c0 b8       	rjmp	800086a2 <_vfprintf_r+0x172e>
8000868e:	fa ca f9 78 	sub	r10,sp,-1672
80008692:	02 9b       	mov	r11,r1
80008694:	08 9c       	mov	r12,r4
80008696:	fe b0 f4 61 	rcall	80006f58 <__sprint_r>
8000869a:	e0 81 03 ec 	brne	80008e72 <_vfprintf_r+0x1efe>
8000869e:	fa c3 f9 e0 	sub	r3,sp,-1568
800086a2:	30 09       	mov	r9,0
800086a4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800086a8:	f2 08 18 00 	cp.b	r8,r9
800086ac:	c1 f0       	breq	800086ea <_vfprintf_r+0x1776>
800086ae:	fa f8 06 90 	ld.w	r8,sp[1680]
800086b2:	fa c9 f9 45 	sub	r9,sp,-1723
800086b6:	2f f8       	sub	r8,-1
800086b8:	87 09       	st.w	r3[0x0],r9
800086ba:	fb 48 06 90 	st.w	sp[1680],r8
800086be:	30 19       	mov	r9,1
800086c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086c4:	87 19       	st.w	r3[0x4],r9
800086c6:	2f f8       	sub	r8,-1
800086c8:	fb 48 06 8c 	st.w	sp[1676],r8
800086cc:	58 78       	cp.w	r8,7
800086ce:	e0 89 00 04 	brgt	800086d6 <_vfprintf_r+0x1762>
800086d2:	2f 83       	sub	r3,-8
800086d4:	c0 b8       	rjmp	800086ea <_vfprintf_r+0x1776>
800086d6:	fa ca f9 78 	sub	r10,sp,-1672
800086da:	02 9b       	mov	r11,r1
800086dc:	08 9c       	mov	r12,r4
800086de:	fe b0 f4 3d 	rcall	80006f58 <__sprint_r>
800086e2:	e0 81 03 c8 	brne	80008e72 <_vfprintf_r+0x1efe>
800086e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800086ea:	40 fc       	lddsp	r12,sp[0x3c]
800086ec:	58 0c       	cp.w	r12,0
800086ee:	c1 f0       	breq	8000872c <_vfprintf_r+0x17b8>
800086f0:	fa f8 06 90 	ld.w	r8,sp[1680]
800086f4:	fa c9 f9 48 	sub	r9,sp,-1720
800086f8:	2f e8       	sub	r8,-2
800086fa:	87 09       	st.w	r3[0x0],r9
800086fc:	fb 48 06 90 	st.w	sp[1680],r8
80008700:	30 29       	mov	r9,2
80008702:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008706:	87 19       	st.w	r3[0x4],r9
80008708:	2f f8       	sub	r8,-1
8000870a:	fb 48 06 8c 	st.w	sp[1676],r8
8000870e:	58 78       	cp.w	r8,7
80008710:	e0 89 00 04 	brgt	80008718 <_vfprintf_r+0x17a4>
80008714:	2f 83       	sub	r3,-8
80008716:	c0 b8       	rjmp	8000872c <_vfprintf_r+0x17b8>
80008718:	fa ca f9 78 	sub	r10,sp,-1672
8000871c:	02 9b       	mov	r11,r1
8000871e:	08 9c       	mov	r12,r4
80008720:	fe b0 f4 1c 	rcall	80006f58 <__sprint_r>
80008724:	e0 81 03 a7 	brne	80008e72 <_vfprintf_r+0x1efe>
80008728:	fa c3 f9 e0 	sub	r3,sp,-1568
8000872c:	40 9b       	lddsp	r11,sp[0x24]
8000872e:	e0 4b 00 80 	cp.w	r11,128
80008732:	c4 71       	brne	800087c0 <_vfprintf_r+0x184c>
80008734:	40 8a       	lddsp	r10,sp[0x20]
80008736:	40 39       	lddsp	r9,sp[0xc]
80008738:	12 1a       	sub	r10,r9
8000873a:	50 4a       	stdsp	sp[0x10],r10
8000873c:	58 0a       	cp.w	r10,0
8000873e:	e0 89 00 20 	brgt	8000877e <_vfprintf_r+0x180a>
80008742:	c3 f8       	rjmp	800087c0 <_vfprintf_r+0x184c>
80008744:	2f 09       	sub	r9,-16
80008746:	2f f8       	sub	r8,-1
80008748:	fe ce ba d8 	sub	lr,pc,-17704
8000874c:	31 0c       	mov	r12,16
8000874e:	fb 49 06 90 	st.w	sp[1680],r9
80008752:	87 0e       	st.w	r3[0x0],lr
80008754:	87 1c       	st.w	r3[0x4],r12
80008756:	fb 48 06 8c 	st.w	sp[1676],r8
8000875a:	58 78       	cp.w	r8,7
8000875c:	e0 89 00 04 	brgt	80008764 <_vfprintf_r+0x17f0>
80008760:	2f 83       	sub	r3,-8
80008762:	c0 b8       	rjmp	80008778 <_vfprintf_r+0x1804>
80008764:	fa ca f9 78 	sub	r10,sp,-1672
80008768:	02 9b       	mov	r11,r1
8000876a:	08 9c       	mov	r12,r4
8000876c:	fe b0 f3 f6 	rcall	80006f58 <__sprint_r>
80008770:	e0 81 03 81 	brne	80008e72 <_vfprintf_r+0x1efe>
80008774:	fa c3 f9 e0 	sub	r3,sp,-1568
80008778:	40 4b       	lddsp	r11,sp[0x10]
8000877a:	21 0b       	sub	r11,16
8000877c:	50 4b       	stdsp	sp[0x10],r11
8000877e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008782:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008786:	fe ca bb 16 	sub	r10,pc,-17642
8000878a:	40 4e       	lddsp	lr,sp[0x10]
8000878c:	59 0e       	cp.w	lr,16
8000878e:	fe 99 ff db 	brgt	80008744 <_vfprintf_r+0x17d0>
80008792:	1c 09       	add	r9,lr
80008794:	2f f8       	sub	r8,-1
80008796:	87 0a       	st.w	r3[0x0],r10
80008798:	fb 49 06 90 	st.w	sp[1680],r9
8000879c:	87 1e       	st.w	r3[0x4],lr
8000879e:	fb 48 06 8c 	st.w	sp[1676],r8
800087a2:	58 78       	cp.w	r8,7
800087a4:	e0 89 00 04 	brgt	800087ac <_vfprintf_r+0x1838>
800087a8:	2f 83       	sub	r3,-8
800087aa:	c0 b8       	rjmp	800087c0 <_vfprintf_r+0x184c>
800087ac:	fa ca f9 78 	sub	r10,sp,-1672
800087b0:	02 9b       	mov	r11,r1
800087b2:	08 9c       	mov	r12,r4
800087b4:	fe b0 f3 d2 	rcall	80006f58 <__sprint_r>
800087b8:	e0 81 03 5d 	brne	80008e72 <_vfprintf_r+0x1efe>
800087bc:	fa c3 f9 e0 	sub	r3,sp,-1568
800087c0:	40 2c       	lddsp	r12,sp[0x8]
800087c2:	04 1c       	sub	r12,r2
800087c4:	50 2c       	stdsp	sp[0x8],r12
800087c6:	58 0c       	cp.w	r12,0
800087c8:	e0 89 00 20 	brgt	80008808 <_vfprintf_r+0x1894>
800087cc:	c3 f8       	rjmp	8000884a <_vfprintf_r+0x18d6>
800087ce:	2f 09       	sub	r9,-16
800087d0:	2f f8       	sub	r8,-1
800087d2:	fe cb bb 62 	sub	r11,pc,-17566
800087d6:	31 0a       	mov	r10,16
800087d8:	fb 49 06 90 	st.w	sp[1680],r9
800087dc:	87 0b       	st.w	r3[0x0],r11
800087de:	87 1a       	st.w	r3[0x4],r10
800087e0:	fb 48 06 8c 	st.w	sp[1676],r8
800087e4:	58 78       	cp.w	r8,7
800087e6:	e0 89 00 04 	brgt	800087ee <_vfprintf_r+0x187a>
800087ea:	2f 83       	sub	r3,-8
800087ec:	c0 b8       	rjmp	80008802 <_vfprintf_r+0x188e>
800087ee:	fa ca f9 78 	sub	r10,sp,-1672
800087f2:	02 9b       	mov	r11,r1
800087f4:	08 9c       	mov	r12,r4
800087f6:	fe b0 f3 b1 	rcall	80006f58 <__sprint_r>
800087fa:	e0 81 03 3c 	brne	80008e72 <_vfprintf_r+0x1efe>
800087fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008802:	40 29       	lddsp	r9,sp[0x8]
80008804:	21 09       	sub	r9,16
80008806:	50 29       	stdsp	sp[0x8],r9
80008808:	fa f9 06 90 	ld.w	r9,sp[1680]
8000880c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008810:	fe ca bb a0 	sub	r10,pc,-17504
80008814:	40 2e       	lddsp	lr,sp[0x8]
80008816:	59 0e       	cp.w	lr,16
80008818:	fe 99 ff db 	brgt	800087ce <_vfprintf_r+0x185a>
8000881c:	1c 09       	add	r9,lr
8000881e:	2f f8       	sub	r8,-1
80008820:	87 0a       	st.w	r3[0x0],r10
80008822:	fb 49 06 90 	st.w	sp[1680],r9
80008826:	87 1e       	st.w	r3[0x4],lr
80008828:	fb 48 06 8c 	st.w	sp[1676],r8
8000882c:	58 78       	cp.w	r8,7
8000882e:	e0 89 00 04 	brgt	80008836 <_vfprintf_r+0x18c2>
80008832:	2f 83       	sub	r3,-8
80008834:	c0 b8       	rjmp	8000884a <_vfprintf_r+0x18d6>
80008836:	fa ca f9 78 	sub	r10,sp,-1672
8000883a:	02 9b       	mov	r11,r1
8000883c:	08 9c       	mov	r12,r4
8000883e:	fe b0 f3 8d 	rcall	80006f58 <__sprint_r>
80008842:	e0 81 03 18 	brne	80008e72 <_vfprintf_r+0x1efe>
80008846:	fa c3 f9 e0 	sub	r3,sp,-1568
8000884a:	ed b5 00 08 	bld	r5,0x8
8000884e:	c0 b0       	breq	80008864 <_vfprintf_r+0x18f0>
80008850:	fa f8 06 90 	ld.w	r8,sp[1680]
80008854:	87 12       	st.w	r3[0x4],r2
80008856:	87 06       	st.w	r3[0x0],r6
80008858:	f0 02 00 02 	add	r2,r8,r2
8000885c:	fb 42 06 90 	st.w	sp[1680],r2
80008860:	e0 8f 01 d4 	bral	80008c08 <_vfprintf_r+0x1c94>
80008864:	e0 40 00 65 	cp.w	r0,101
80008868:	e0 8a 01 d6 	brle	80008c14 <_vfprintf_r+0x1ca0>
8000886c:	30 08       	mov	r8,0
8000886e:	30 09       	mov	r9,0
80008870:	40 5b       	lddsp	r11,sp[0x14]
80008872:	40 7a       	lddsp	r10,sp[0x1c]
80008874:	e0 a0 15 2f 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
80008878:	c7 90       	breq	8000896a <_vfprintf_r+0x19f6>
8000887a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000887e:	fe c9 bc 22 	sub	r9,pc,-17374
80008882:	2f f8       	sub	r8,-1
80008884:	87 09       	st.w	r3[0x0],r9
80008886:	fb 48 06 90 	st.w	sp[1680],r8
8000888a:	30 19       	mov	r9,1
8000888c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008890:	87 19       	st.w	r3[0x4],r9
80008892:	2f f8       	sub	r8,-1
80008894:	fb 48 06 8c 	st.w	sp[1676],r8
80008898:	58 78       	cp.w	r8,7
8000889a:	e0 89 00 05 	brgt	800088a4 <_vfprintf_r+0x1930>
8000889e:	2f 83       	sub	r3,-8
800088a0:	c0 c8       	rjmp	800088b8 <_vfprintf_r+0x1944>
800088a2:	d7 03       	nop
800088a4:	fa ca f9 78 	sub	r10,sp,-1672
800088a8:	02 9b       	mov	r11,r1
800088aa:	08 9c       	mov	r12,r4
800088ac:	fe b0 f3 56 	rcall	80006f58 <__sprint_r>
800088b0:	e0 81 02 e1 	brne	80008e72 <_vfprintf_r+0x1efe>
800088b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800088b8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088bc:	40 6c       	lddsp	r12,sp[0x18]
800088be:	18 38       	cp.w	r8,r12
800088c0:	c0 55       	brlt	800088ca <_vfprintf_r+0x1956>
800088c2:	ed b5 00 00 	bld	r5,0x0
800088c6:	e0 81 02 6b 	brne	80008d9c <_vfprintf_r+0x1e28>
800088ca:	fa f8 06 90 	ld.w	r8,sp[1680]
800088ce:	2f f8       	sub	r8,-1
800088d0:	40 cb       	lddsp	r11,sp[0x30]
800088d2:	fb 48 06 90 	st.w	sp[1680],r8
800088d6:	30 19       	mov	r9,1
800088d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088dc:	87 0b       	st.w	r3[0x0],r11
800088de:	2f f8       	sub	r8,-1
800088e0:	87 19       	st.w	r3[0x4],r9
800088e2:	fb 48 06 8c 	st.w	sp[1676],r8
800088e6:	58 78       	cp.w	r8,7
800088e8:	e0 89 00 04 	brgt	800088f0 <_vfprintf_r+0x197c>
800088ec:	2f 83       	sub	r3,-8
800088ee:	c0 b8       	rjmp	80008904 <_vfprintf_r+0x1990>
800088f0:	fa ca f9 78 	sub	r10,sp,-1672
800088f4:	02 9b       	mov	r11,r1
800088f6:	08 9c       	mov	r12,r4
800088f8:	fe b0 f3 30 	rcall	80006f58 <__sprint_r>
800088fc:	e0 81 02 bb 	brne	80008e72 <_vfprintf_r+0x1efe>
80008900:	fa c3 f9 e0 	sub	r3,sp,-1568
80008904:	40 66       	lddsp	r6,sp[0x18]
80008906:	20 16       	sub	r6,1
80008908:	58 06       	cp.w	r6,0
8000890a:	e0 89 00 1d 	brgt	80008944 <_vfprintf_r+0x19d0>
8000890e:	e0 8f 02 47 	bral	80008d9c <_vfprintf_r+0x1e28>
80008912:	2f 09       	sub	r9,-16
80008914:	2f f8       	sub	r8,-1
80008916:	fb 49 06 90 	st.w	sp[1680],r9
8000891a:	87 02       	st.w	r3[0x0],r2
8000891c:	87 10       	st.w	r3[0x4],r0
8000891e:	fb 48 06 8c 	st.w	sp[1676],r8
80008922:	58 78       	cp.w	r8,7
80008924:	e0 89 00 04 	brgt	8000892c <_vfprintf_r+0x19b8>
80008928:	2f 83       	sub	r3,-8
8000892a:	c0 b8       	rjmp	80008940 <_vfprintf_r+0x19cc>
8000892c:	fa ca f9 78 	sub	r10,sp,-1672
80008930:	02 9b       	mov	r11,r1
80008932:	08 9c       	mov	r12,r4
80008934:	fe b0 f3 12 	rcall	80006f58 <__sprint_r>
80008938:	e0 81 02 9d 	brne	80008e72 <_vfprintf_r+0x1efe>
8000893c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008940:	21 06       	sub	r6,16
80008942:	c0 48       	rjmp	8000894a <_vfprintf_r+0x19d6>
80008944:	fe c2 bc d4 	sub	r2,pc,-17196
80008948:	31 00       	mov	r0,16
8000894a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000894e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008952:	fe ca bc e2 	sub	r10,pc,-17182
80008956:	59 06       	cp.w	r6,16
80008958:	fe 99 ff dd 	brgt	80008912 <_vfprintf_r+0x199e>
8000895c:	0c 09       	add	r9,r6
8000895e:	87 0a       	st.w	r3[0x0],r10
80008960:	fb 49 06 90 	st.w	sp[1680],r9
80008964:	2f f8       	sub	r8,-1
80008966:	87 16       	st.w	r3[0x4],r6
80008968:	c5 39       	rjmp	80008c0e <_vfprintf_r+0x1c9a>
8000896a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000896e:	58 0a       	cp.w	r10,0
80008970:	e0 89 00 92 	brgt	80008a94 <_vfprintf_r+0x1b20>
80008974:	fa f8 06 90 	ld.w	r8,sp[1680]
80008978:	fe c9 bd 1c 	sub	r9,pc,-17124
8000897c:	2f f8       	sub	r8,-1
8000897e:	87 09       	st.w	r3[0x0],r9
80008980:	fb 48 06 90 	st.w	sp[1680],r8
80008984:	30 19       	mov	r9,1
80008986:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000898a:	87 19       	st.w	r3[0x4],r9
8000898c:	2f f8       	sub	r8,-1
8000898e:	fb 48 06 8c 	st.w	sp[1676],r8
80008992:	58 78       	cp.w	r8,7
80008994:	e0 89 00 04 	brgt	8000899c <_vfprintf_r+0x1a28>
80008998:	2f 83       	sub	r3,-8
8000899a:	c0 b8       	rjmp	800089b0 <_vfprintf_r+0x1a3c>
8000899c:	fa ca f9 78 	sub	r10,sp,-1672
800089a0:	02 9b       	mov	r11,r1
800089a2:	08 9c       	mov	r12,r4
800089a4:	fe b0 f2 da 	rcall	80006f58 <__sprint_r>
800089a8:	e0 81 02 65 	brne	80008e72 <_vfprintf_r+0x1efe>
800089ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800089b0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800089b4:	58 08       	cp.w	r8,0
800089b6:	c0 81       	brne	800089c6 <_vfprintf_r+0x1a52>
800089b8:	40 6a       	lddsp	r10,sp[0x18]
800089ba:	58 0a       	cp.w	r10,0
800089bc:	c0 51       	brne	800089c6 <_vfprintf_r+0x1a52>
800089be:	ed b5 00 00 	bld	r5,0x0
800089c2:	e0 81 01 ed 	brne	80008d9c <_vfprintf_r+0x1e28>
800089c6:	40 c9       	lddsp	r9,sp[0x30]
800089c8:	fa f8 06 90 	ld.w	r8,sp[1680]
800089cc:	2f f8       	sub	r8,-1
800089ce:	87 09       	st.w	r3[0x0],r9
800089d0:	fb 48 06 90 	st.w	sp[1680],r8
800089d4:	30 19       	mov	r9,1
800089d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089da:	87 19       	st.w	r3[0x4],r9
800089dc:	2f f8       	sub	r8,-1
800089de:	fb 48 06 8c 	st.w	sp[1676],r8
800089e2:	58 78       	cp.w	r8,7
800089e4:	e0 89 00 04 	brgt	800089ec <_vfprintf_r+0x1a78>
800089e8:	2f 83       	sub	r3,-8
800089ea:	c0 b8       	rjmp	80008a00 <_vfprintf_r+0x1a8c>
800089ec:	fa ca f9 78 	sub	r10,sp,-1672
800089f0:	02 9b       	mov	r11,r1
800089f2:	08 9c       	mov	r12,r4
800089f4:	fe b0 f2 b2 	rcall	80006f58 <__sprint_r>
800089f8:	e0 81 02 3d 	brne	80008e72 <_vfprintf_r+0x1efe>
800089fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a00:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a04:	5c 32       	neg	r2
80008a06:	58 02       	cp.w	r2,0
80008a08:	e0 89 00 1d 	brgt	80008a42 <_vfprintf_r+0x1ace>
80008a0c:	c3 d8       	rjmp	80008a86 <_vfprintf_r+0x1b12>
80008a0e:	2f 09       	sub	r9,-16
80008a10:	2f f8       	sub	r8,-1
80008a12:	31 0e       	mov	lr,16
80008a14:	fb 49 06 90 	st.w	sp[1680],r9
80008a18:	87 00       	st.w	r3[0x0],r0
80008a1a:	87 1e       	st.w	r3[0x4],lr
80008a1c:	fb 48 06 8c 	st.w	sp[1676],r8
80008a20:	58 78       	cp.w	r8,7
80008a22:	e0 89 00 04 	brgt	80008a2a <_vfprintf_r+0x1ab6>
80008a26:	2f 83       	sub	r3,-8
80008a28:	c0 b8       	rjmp	80008a3e <_vfprintf_r+0x1aca>
80008a2a:	fa ca f9 78 	sub	r10,sp,-1672
80008a2e:	02 9b       	mov	r11,r1
80008a30:	08 9c       	mov	r12,r4
80008a32:	fe b0 f2 93 	rcall	80006f58 <__sprint_r>
80008a36:	e0 81 02 1e 	brne	80008e72 <_vfprintf_r+0x1efe>
80008a3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a3e:	21 02       	sub	r2,16
80008a40:	c0 38       	rjmp	80008a46 <_vfprintf_r+0x1ad2>
80008a42:	fe c0 bd d2 	sub	r0,pc,-16942
80008a46:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a4e:	fe ca bd de 	sub	r10,pc,-16930
80008a52:	59 02       	cp.w	r2,16
80008a54:	fe 99 ff dd 	brgt	80008a0e <_vfprintf_r+0x1a9a>
80008a58:	04 09       	add	r9,r2
80008a5a:	2f f8       	sub	r8,-1
80008a5c:	87 0a       	st.w	r3[0x0],r10
80008a5e:	fb 49 06 90 	st.w	sp[1680],r9
80008a62:	87 12       	st.w	r3[0x4],r2
80008a64:	fb 48 06 8c 	st.w	sp[1676],r8
80008a68:	58 78       	cp.w	r8,7
80008a6a:	e0 89 00 04 	brgt	80008a72 <_vfprintf_r+0x1afe>
80008a6e:	2f 83       	sub	r3,-8
80008a70:	c0 b8       	rjmp	80008a86 <_vfprintf_r+0x1b12>
80008a72:	fa ca f9 78 	sub	r10,sp,-1672
80008a76:	02 9b       	mov	r11,r1
80008a78:	08 9c       	mov	r12,r4
80008a7a:	fe b0 f2 6f 	rcall	80006f58 <__sprint_r>
80008a7e:	e0 81 01 fa 	brne	80008e72 <_vfprintf_r+0x1efe>
80008a82:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a86:	40 6c       	lddsp	r12,sp[0x18]
80008a88:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a8c:	87 06       	st.w	r3[0x0],r6
80008a8e:	87 1c       	st.w	r3[0x4],r12
80008a90:	18 08       	add	r8,r12
80008a92:	cb 98       	rjmp	80008c04 <_vfprintf_r+0x1c90>
80008a94:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a9c:	40 6b       	lddsp	r11,sp[0x18]
80008a9e:	16 3a       	cp.w	r10,r11
80008aa0:	c6 f5       	brlt	80008b7e <_vfprintf_r+0x1c0a>
80008aa2:	16 09       	add	r9,r11
80008aa4:	2f f8       	sub	r8,-1
80008aa6:	87 06       	st.w	r3[0x0],r6
80008aa8:	fb 49 06 90 	st.w	sp[1680],r9
80008aac:	87 1b       	st.w	r3[0x4],r11
80008aae:	fb 48 06 8c 	st.w	sp[1676],r8
80008ab2:	58 78       	cp.w	r8,7
80008ab4:	e0 89 00 04 	brgt	80008abc <_vfprintf_r+0x1b48>
80008ab8:	2f 83       	sub	r3,-8
80008aba:	c0 b8       	rjmp	80008ad0 <_vfprintf_r+0x1b5c>
80008abc:	fa ca f9 78 	sub	r10,sp,-1672
80008ac0:	02 9b       	mov	r11,r1
80008ac2:	08 9c       	mov	r12,r4
80008ac4:	fe b0 f2 4a 	rcall	80006f58 <__sprint_r>
80008ac8:	e0 81 01 d5 	brne	80008e72 <_vfprintf_r+0x1efe>
80008acc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ad0:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008ad4:	40 6a       	lddsp	r10,sp[0x18]
80008ad6:	14 16       	sub	r6,r10
80008ad8:	58 06       	cp.w	r6,0
80008ada:	e0 89 00 1c 	brgt	80008b12 <_vfprintf_r+0x1b9e>
80008ade:	c3 d8       	rjmp	80008b58 <_vfprintf_r+0x1be4>
80008ae0:	2f 09       	sub	r9,-16
80008ae2:	2f f8       	sub	r8,-1
80008ae4:	fb 49 06 90 	st.w	sp[1680],r9
80008ae8:	87 02       	st.w	r3[0x0],r2
80008aea:	87 10       	st.w	r3[0x4],r0
80008aec:	fb 48 06 8c 	st.w	sp[1676],r8
80008af0:	58 78       	cp.w	r8,7
80008af2:	e0 89 00 04 	brgt	80008afa <_vfprintf_r+0x1b86>
80008af6:	2f 83       	sub	r3,-8
80008af8:	c0 b8       	rjmp	80008b0e <_vfprintf_r+0x1b9a>
80008afa:	fa ca f9 78 	sub	r10,sp,-1672
80008afe:	02 9b       	mov	r11,r1
80008b00:	08 9c       	mov	r12,r4
80008b02:	fe b0 f2 2b 	rcall	80006f58 <__sprint_r>
80008b06:	e0 81 01 b6 	brne	80008e72 <_vfprintf_r+0x1efe>
80008b0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b0e:	21 06       	sub	r6,16
80008b10:	c0 48       	rjmp	80008b18 <_vfprintf_r+0x1ba4>
80008b12:	fe c2 be a2 	sub	r2,pc,-16734
80008b16:	31 00       	mov	r0,16
80008b18:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b20:	fe ca be b0 	sub	r10,pc,-16720
80008b24:	59 06       	cp.w	r6,16
80008b26:	fe 99 ff dd 	brgt	80008ae0 <_vfprintf_r+0x1b6c>
80008b2a:	0c 09       	add	r9,r6
80008b2c:	2f f8       	sub	r8,-1
80008b2e:	87 0a       	st.w	r3[0x0],r10
80008b30:	fb 49 06 90 	st.w	sp[1680],r9
80008b34:	87 16       	st.w	r3[0x4],r6
80008b36:	fb 48 06 8c 	st.w	sp[1676],r8
80008b3a:	58 78       	cp.w	r8,7
80008b3c:	e0 89 00 04 	brgt	80008b44 <_vfprintf_r+0x1bd0>
80008b40:	2f 83       	sub	r3,-8
80008b42:	c0 b8       	rjmp	80008b58 <_vfprintf_r+0x1be4>
80008b44:	fa ca f9 78 	sub	r10,sp,-1672
80008b48:	02 9b       	mov	r11,r1
80008b4a:	08 9c       	mov	r12,r4
80008b4c:	fe b0 f2 06 	rcall	80006f58 <__sprint_r>
80008b50:	e0 81 01 91 	brne	80008e72 <_vfprintf_r+0x1efe>
80008b54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b58:	ed b5 00 00 	bld	r5,0x0
80008b5c:	e0 81 01 20 	brne	80008d9c <_vfprintf_r+0x1e28>
80008b60:	40 c9       	lddsp	r9,sp[0x30]
80008b62:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b66:	2f f8       	sub	r8,-1
80008b68:	87 09       	st.w	r3[0x0],r9
80008b6a:	fb 48 06 90 	st.w	sp[1680],r8
80008b6e:	30 19       	mov	r9,1
80008b70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b74:	87 19       	st.w	r3[0x4],r9
80008b76:	2f f8       	sub	r8,-1
80008b78:	fb 48 06 8c 	st.w	sp[1676],r8
80008b7c:	c0 29       	rjmp	80008d80 <_vfprintf_r+0x1e0c>
80008b7e:	14 09       	add	r9,r10
80008b80:	2f f8       	sub	r8,-1
80008b82:	fb 49 06 90 	st.w	sp[1680],r9
80008b86:	87 06       	st.w	r3[0x0],r6
80008b88:	87 1a       	st.w	r3[0x4],r10
80008b8a:	fb 48 06 8c 	st.w	sp[1676],r8
80008b8e:	58 78       	cp.w	r8,7
80008b90:	e0 89 00 04 	brgt	80008b98 <_vfprintf_r+0x1c24>
80008b94:	2f 83       	sub	r3,-8
80008b96:	c0 b8       	rjmp	80008bac <_vfprintf_r+0x1c38>
80008b98:	fa ca f9 78 	sub	r10,sp,-1672
80008b9c:	02 9b       	mov	r11,r1
80008b9e:	08 9c       	mov	r12,r4
80008ba0:	fe b0 f1 dc 	rcall	80006f58 <__sprint_r>
80008ba4:	e0 81 01 67 	brne	80008e72 <_vfprintf_r+0x1efe>
80008ba8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bac:	40 c8       	lddsp	r8,sp[0x30]
80008bae:	87 08       	st.w	r3[0x0],r8
80008bb0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bb4:	2f f8       	sub	r8,-1
80008bb6:	30 19       	mov	r9,1
80008bb8:	fb 48 06 90 	st.w	sp[1680],r8
80008bbc:	87 19       	st.w	r3[0x4],r9
80008bbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bc2:	2f f8       	sub	r8,-1
80008bc4:	fb 48 06 8c 	st.w	sp[1676],r8
80008bc8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bcc:	58 78       	cp.w	r8,7
80008bce:	e0 89 00 04 	brgt	80008bd6 <_vfprintf_r+0x1c62>
80008bd2:	2f 83       	sub	r3,-8
80008bd4:	c0 b8       	rjmp	80008bea <_vfprintf_r+0x1c76>
80008bd6:	fa ca f9 78 	sub	r10,sp,-1672
80008bda:	02 9b       	mov	r11,r1
80008bdc:	08 9c       	mov	r12,r4
80008bde:	fe b0 f1 bd 	rcall	80006f58 <__sprint_r>
80008be2:	e0 81 01 48 	brne	80008e72 <_vfprintf_r+0x1efe>
80008be6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bea:	04 06       	add	r6,r2
80008bec:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008bf0:	87 06       	st.w	r3[0x0],r6
80008bf2:	fa f9 06 90 	ld.w	r9,sp[1680]
80008bf6:	40 66       	lddsp	r6,sp[0x18]
80008bf8:	40 6e       	lddsp	lr,sp[0x18]
80008bfa:	10 16       	sub	r6,r8
80008bfc:	f2 08 01 08 	sub	r8,r9,r8
80008c00:	87 16       	st.w	r3[0x4],r6
80008c02:	1c 08       	add	r8,lr
80008c04:	fb 48 06 90 	st.w	sp[1680],r8
80008c08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c0c:	2f f8       	sub	r8,-1
80008c0e:	fb 48 06 8c 	st.w	sp[1676],r8
80008c12:	cb 78       	rjmp	80008d80 <_vfprintf_r+0x1e0c>
80008c14:	40 6c       	lddsp	r12,sp[0x18]
80008c16:	58 1c       	cp.w	r12,1
80008c18:	e0 89 00 06 	brgt	80008c24 <_vfprintf_r+0x1cb0>
80008c1c:	ed b5 00 00 	bld	r5,0x0
80008c20:	e0 81 00 85 	brne	80008d2a <_vfprintf_r+0x1db6>
80008c24:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c28:	2f f8       	sub	r8,-1
80008c2a:	30 19       	mov	r9,1
80008c2c:	fb 48 06 90 	st.w	sp[1680],r8
80008c30:	87 06       	st.w	r3[0x0],r6
80008c32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c36:	87 19       	st.w	r3[0x4],r9
80008c38:	2f f8       	sub	r8,-1
80008c3a:	fb 48 06 8c 	st.w	sp[1676],r8
80008c3e:	58 78       	cp.w	r8,7
80008c40:	e0 89 00 04 	brgt	80008c48 <_vfprintf_r+0x1cd4>
80008c44:	2f 83       	sub	r3,-8
80008c46:	c0 b8       	rjmp	80008c5c <_vfprintf_r+0x1ce8>
80008c48:	fa ca f9 78 	sub	r10,sp,-1672
80008c4c:	02 9b       	mov	r11,r1
80008c4e:	08 9c       	mov	r12,r4
80008c50:	fe b0 f1 84 	rcall	80006f58 <__sprint_r>
80008c54:	e0 81 01 0f 	brne	80008e72 <_vfprintf_r+0x1efe>
80008c58:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c60:	2f f8       	sub	r8,-1
80008c62:	40 cb       	lddsp	r11,sp[0x30]
80008c64:	fb 48 06 90 	st.w	sp[1680],r8
80008c68:	30 19       	mov	r9,1
80008c6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c6e:	87 0b       	st.w	r3[0x0],r11
80008c70:	2f f8       	sub	r8,-1
80008c72:	87 19       	st.w	r3[0x4],r9
80008c74:	fb 48 06 8c 	st.w	sp[1676],r8
80008c78:	58 78       	cp.w	r8,7
80008c7a:	e0 89 00 05 	brgt	80008c84 <_vfprintf_r+0x1d10>
80008c7e:	2f 83       	sub	r3,-8
80008c80:	c0 c8       	rjmp	80008c98 <_vfprintf_r+0x1d24>
80008c82:	d7 03       	nop
80008c84:	fa ca f9 78 	sub	r10,sp,-1672
80008c88:	02 9b       	mov	r11,r1
80008c8a:	08 9c       	mov	r12,r4
80008c8c:	fe b0 f1 66 	rcall	80006f58 <__sprint_r>
80008c90:	e0 81 00 f1 	brne	80008e72 <_vfprintf_r+0x1efe>
80008c94:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c98:	30 08       	mov	r8,0
80008c9a:	30 09       	mov	r9,0
80008c9c:	40 5b       	lddsp	r11,sp[0x14]
80008c9e:	40 7a       	lddsp	r10,sp[0x1c]
80008ca0:	e0 a0 13 19 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
80008ca4:	40 68       	lddsp	r8,sp[0x18]
80008ca6:	20 18       	sub	r8,1
80008ca8:	58 0c       	cp.w	r12,0
80008caa:	c0 d1       	brne	80008cc4 <_vfprintf_r+0x1d50>
80008cac:	2f f6       	sub	r6,-1
80008cae:	87 18       	st.w	r3[0x4],r8
80008cb0:	87 06       	st.w	r3[0x0],r6
80008cb2:	fa f6 06 90 	ld.w	r6,sp[1680]
80008cb6:	10 06       	add	r6,r8
80008cb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cbc:	fb 46 06 90 	st.w	sp[1680],r6
80008cc0:	2f f8       	sub	r8,-1
80008cc2:	c3 18       	rjmp	80008d24 <_vfprintf_r+0x1db0>
80008cc4:	10 96       	mov	r6,r8
80008cc6:	58 08       	cp.w	r8,0
80008cc8:	e0 89 00 1c 	brgt	80008d00 <_vfprintf_r+0x1d8c>
80008ccc:	c4 b8       	rjmp	80008d62 <_vfprintf_r+0x1dee>
80008cce:	2f 09       	sub	r9,-16
80008cd0:	2f f8       	sub	r8,-1
80008cd2:	fb 49 06 90 	st.w	sp[1680],r9
80008cd6:	87 02       	st.w	r3[0x0],r2
80008cd8:	87 10       	st.w	r3[0x4],r0
80008cda:	fb 48 06 8c 	st.w	sp[1676],r8
80008cde:	58 78       	cp.w	r8,7
80008ce0:	e0 89 00 04 	brgt	80008ce8 <_vfprintf_r+0x1d74>
80008ce4:	2f 83       	sub	r3,-8
80008ce6:	c0 b8       	rjmp	80008cfc <_vfprintf_r+0x1d88>
80008ce8:	fa ca f9 78 	sub	r10,sp,-1672
80008cec:	02 9b       	mov	r11,r1
80008cee:	08 9c       	mov	r12,r4
80008cf0:	fe b0 f1 34 	rcall	80006f58 <__sprint_r>
80008cf4:	e0 81 00 bf 	brne	80008e72 <_vfprintf_r+0x1efe>
80008cf8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cfc:	21 06       	sub	r6,16
80008cfe:	c0 48       	rjmp	80008d06 <_vfprintf_r+0x1d92>
80008d00:	fe c2 c0 90 	sub	r2,pc,-16240
80008d04:	31 00       	mov	r0,16
80008d06:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d0a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d0e:	fe ca c0 9e 	sub	r10,pc,-16226
80008d12:	59 06       	cp.w	r6,16
80008d14:	fe 99 ff dd 	brgt	80008cce <_vfprintf_r+0x1d5a>
80008d18:	0c 09       	add	r9,r6
80008d1a:	87 0a       	st.w	r3[0x0],r10
80008d1c:	fb 49 06 90 	st.w	sp[1680],r9
80008d20:	2f f8       	sub	r8,-1
80008d22:	87 16       	st.w	r3[0x4],r6
80008d24:	fb 48 06 8c 	st.w	sp[1676],r8
80008d28:	c0 e8       	rjmp	80008d44 <_vfprintf_r+0x1dd0>
80008d2a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d2e:	2f f8       	sub	r8,-1
80008d30:	30 19       	mov	r9,1
80008d32:	fb 48 06 90 	st.w	sp[1680],r8
80008d36:	87 06       	st.w	r3[0x0],r6
80008d38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d3c:	87 19       	st.w	r3[0x4],r9
80008d3e:	2f f8       	sub	r8,-1
80008d40:	fb 48 06 8c 	st.w	sp[1676],r8
80008d44:	58 78       	cp.w	r8,7
80008d46:	e0 89 00 04 	brgt	80008d4e <_vfprintf_r+0x1dda>
80008d4a:	2f 83       	sub	r3,-8
80008d4c:	c0 b8       	rjmp	80008d62 <_vfprintf_r+0x1dee>
80008d4e:	fa ca f9 78 	sub	r10,sp,-1672
80008d52:	02 9b       	mov	r11,r1
80008d54:	08 9c       	mov	r12,r4
80008d56:	fe b0 f1 01 	rcall	80006f58 <__sprint_r>
80008d5a:	e0 81 00 8c 	brne	80008e72 <_vfprintf_r+0x1efe>
80008d5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d62:	40 ea       	lddsp	r10,sp[0x38]
80008d64:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d68:	14 08       	add	r8,r10
80008d6a:	fa c9 f9 64 	sub	r9,sp,-1692
80008d6e:	fb 48 06 90 	st.w	sp[1680],r8
80008d72:	87 1a       	st.w	r3[0x4],r10
80008d74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d78:	87 09       	st.w	r3[0x0],r9
80008d7a:	2f f8       	sub	r8,-1
80008d7c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d80:	58 78       	cp.w	r8,7
80008d82:	e0 89 00 04 	brgt	80008d8a <_vfprintf_r+0x1e16>
80008d86:	2f 83       	sub	r3,-8
80008d88:	c0 a8       	rjmp	80008d9c <_vfprintf_r+0x1e28>
80008d8a:	fa ca f9 78 	sub	r10,sp,-1672
80008d8e:	02 9b       	mov	r11,r1
80008d90:	08 9c       	mov	r12,r4
80008d92:	fe b0 f0 e3 	rcall	80006f58 <__sprint_r>
80008d96:	c6 e1       	brne	80008e72 <_vfprintf_r+0x1efe>
80008d98:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d9c:	e2 15 00 04 	andl	r5,0x4,COH
80008da0:	c3 f0       	breq	80008e1e <_vfprintf_r+0x1eaa>
80008da2:	40 86       	lddsp	r6,sp[0x20]
80008da4:	40 39       	lddsp	r9,sp[0xc]
80008da6:	12 16       	sub	r6,r9
80008da8:	58 06       	cp.w	r6,0
80008daa:	e0 89 00 1a 	brgt	80008dde <_vfprintf_r+0x1e6a>
80008dae:	c3 88       	rjmp	80008e1e <_vfprintf_r+0x1eaa>
80008db0:	2f 09       	sub	r9,-16
80008db2:	2f f8       	sub	r8,-1
80008db4:	fb 49 06 90 	st.w	sp[1680],r9
80008db8:	87 05       	st.w	r3[0x0],r5
80008dba:	87 12       	st.w	r3[0x4],r2
80008dbc:	fb 48 06 8c 	st.w	sp[1676],r8
80008dc0:	58 78       	cp.w	r8,7
80008dc2:	e0 89 00 04 	brgt	80008dca <_vfprintf_r+0x1e56>
80008dc6:	2f 83       	sub	r3,-8
80008dc8:	c0 98       	rjmp	80008dda <_vfprintf_r+0x1e66>
80008dca:	00 9a       	mov	r10,r0
80008dcc:	02 9b       	mov	r11,r1
80008dce:	08 9c       	mov	r12,r4
80008dd0:	fe b0 f0 c4 	rcall	80006f58 <__sprint_r>
80008dd4:	c4 f1       	brne	80008e72 <_vfprintf_r+0x1efe>
80008dd6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dda:	21 06       	sub	r6,16
80008ddc:	c0 68       	rjmp	80008de8 <_vfprintf_r+0x1e74>
80008dde:	fe c5 c1 7e 	sub	r5,pc,-16002
80008de2:	31 02       	mov	r2,16
80008de4:	fa c0 f9 78 	sub	r0,sp,-1672
80008de8:	fa f9 06 90 	ld.w	r9,sp[1680]
80008dec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008df0:	fe ca c1 90 	sub	r10,pc,-15984
80008df4:	59 06       	cp.w	r6,16
80008df6:	fe 99 ff dd 	brgt	80008db0 <_vfprintf_r+0x1e3c>
80008dfa:	0c 09       	add	r9,r6
80008dfc:	2f f8       	sub	r8,-1
80008dfe:	87 0a       	st.w	r3[0x0],r10
80008e00:	87 16       	st.w	r3[0x4],r6
80008e02:	fb 49 06 90 	st.w	sp[1680],r9
80008e06:	fb 48 06 8c 	st.w	sp[1676],r8
80008e0a:	58 78       	cp.w	r8,7
80008e0c:	e0 8a 00 09 	brle	80008e1e <_vfprintf_r+0x1eaa>
80008e10:	fa ca f9 78 	sub	r10,sp,-1672
80008e14:	02 9b       	mov	r11,r1
80008e16:	08 9c       	mov	r12,r4
80008e18:	fe b0 f0 a0 	rcall	80006f58 <__sprint_r>
80008e1c:	c2 b1       	brne	80008e72 <_vfprintf_r+0x1efe>
80008e1e:	40 bc       	lddsp	r12,sp[0x2c]
80008e20:	40 36       	lddsp	r6,sp[0xc]
80008e22:	40 8e       	lddsp	lr,sp[0x20]
80008e24:	ec 0e 0c 48 	max	r8,r6,lr
80008e28:	10 0c       	add	r12,r8
80008e2a:	50 bc       	stdsp	sp[0x2c],r12
80008e2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e30:	58 08       	cp.w	r8,0
80008e32:	c0 80       	breq	80008e42 <_vfprintf_r+0x1ece>
80008e34:	fa ca f9 78 	sub	r10,sp,-1672
80008e38:	02 9b       	mov	r11,r1
80008e3a:	08 9c       	mov	r12,r4
80008e3c:	fe b0 f0 8e 	rcall	80006f58 <__sprint_r>
80008e40:	c1 91       	brne	80008e72 <_vfprintf_r+0x1efe>
80008e42:	30 0b       	mov	r11,0
80008e44:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e48:	fb 4b 06 8c 	st.w	sp[1676],r11
80008e4c:	fe 9f f1 22 	bral	80007090 <_vfprintf_r+0x11c>
80008e50:	08 95       	mov	r5,r4
80008e52:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e56:	58 08       	cp.w	r8,0
80008e58:	c0 80       	breq	80008e68 <_vfprintf_r+0x1ef4>
80008e5a:	08 9c       	mov	r12,r4
80008e5c:	fa ca f9 78 	sub	r10,sp,-1672
80008e60:	02 9b       	mov	r11,r1
80008e62:	fe b0 f0 7b 	rcall	80006f58 <__sprint_r>
80008e66:	c0 61       	brne	80008e72 <_vfprintf_r+0x1efe>
80008e68:	30 08       	mov	r8,0
80008e6a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e6e:	c0 28       	rjmp	80008e72 <_vfprintf_r+0x1efe>
80008e70:	40 41       	lddsp	r1,sp[0x10]
80008e72:	82 68       	ld.sh	r8,r1[0xc]
80008e74:	ed b8 00 06 	bld	r8,0x6
80008e78:	c0 31       	brne	80008e7e <_vfprintf_r+0x1f0a>
80008e7a:	3f fa       	mov	r10,-1
80008e7c:	50 ba       	stdsp	sp[0x2c],r10
80008e7e:	40 bc       	lddsp	r12,sp[0x2c]
80008e80:	fe 3d f9 44 	sub	sp,-1724
80008e84:	d8 32       	popm	r0-r7,pc
80008e86:	d7 03       	nop

80008e88 <__swsetup_r>:
80008e88:	d4 21       	pushm	r4-r7,lr
80008e8a:	e0 68 0a 40 	mov	r8,2624
80008e8e:	18 96       	mov	r6,r12
80008e90:	16 97       	mov	r7,r11
80008e92:	70 0c       	ld.w	r12,r8[0x0]
80008e94:	58 0c       	cp.w	r12,0
80008e96:	c0 60       	breq	80008ea2 <__swsetup_r+0x1a>
80008e98:	78 68       	ld.w	r8,r12[0x18]
80008e9a:	58 08       	cp.w	r8,0
80008e9c:	c0 31       	brne	80008ea2 <__swsetup_r+0x1a>
80008e9e:	e0 a0 07 bf 	rcall	80009e1c <__sinit>
80008ea2:	fe c8 c1 12 	sub	r8,pc,-16110
80008ea6:	10 37       	cp.w	r7,r8
80008ea8:	c0 61       	brne	80008eb4 <__swsetup_r+0x2c>
80008eaa:	e0 68 0a 40 	mov	r8,2624
80008eae:	70 08       	ld.w	r8,r8[0x0]
80008eb0:	70 07       	ld.w	r7,r8[0x0]
80008eb2:	c1 28       	rjmp	80008ed6 <__swsetup_r+0x4e>
80008eb4:	fe c8 c1 04 	sub	r8,pc,-16124
80008eb8:	10 37       	cp.w	r7,r8
80008eba:	c0 61       	brne	80008ec6 <__swsetup_r+0x3e>
80008ebc:	e0 68 0a 40 	mov	r8,2624
80008ec0:	70 08       	ld.w	r8,r8[0x0]
80008ec2:	70 17       	ld.w	r7,r8[0x4]
80008ec4:	c0 98       	rjmp	80008ed6 <__swsetup_r+0x4e>
80008ec6:	fe c8 c0 f6 	sub	r8,pc,-16138
80008eca:	10 37       	cp.w	r7,r8
80008ecc:	c0 51       	brne	80008ed6 <__swsetup_r+0x4e>
80008ece:	e0 68 0a 40 	mov	r8,2624
80008ed2:	70 08       	ld.w	r8,r8[0x0]
80008ed4:	70 27       	ld.w	r7,r8[0x8]
80008ed6:	8e 68       	ld.sh	r8,r7[0xc]
80008ed8:	ed b8 00 03 	bld	r8,0x3
80008edc:	c1 e0       	breq	80008f18 <__swsetup_r+0x90>
80008ede:	ed b8 00 04 	bld	r8,0x4
80008ee2:	c3 e1       	brne	80008f5e <__swsetup_r+0xd6>
80008ee4:	ed b8 00 02 	bld	r8,0x2
80008ee8:	c1 51       	brne	80008f12 <__swsetup_r+0x8a>
80008eea:	6e db       	ld.w	r11,r7[0x34]
80008eec:	58 0b       	cp.w	r11,0
80008eee:	c0 a0       	breq	80008f02 <__swsetup_r+0x7a>
80008ef0:	ee c8 ff bc 	sub	r8,r7,-68
80008ef4:	10 3b       	cp.w	r11,r8
80008ef6:	c0 40       	breq	80008efe <__swsetup_r+0x76>
80008ef8:	0c 9c       	mov	r12,r6
80008efa:	e0 a0 08 2b 	rcall	80009f50 <_free_r>
80008efe:	30 08       	mov	r8,0
80008f00:	8f d8       	st.w	r7[0x34],r8
80008f02:	8e 68       	ld.sh	r8,r7[0xc]
80008f04:	e0 18 ff db 	andl	r8,0xffdb
80008f08:	ae 68       	st.h	r7[0xc],r8
80008f0a:	30 08       	mov	r8,0
80008f0c:	8f 18       	st.w	r7[0x4],r8
80008f0e:	6e 48       	ld.w	r8,r7[0x10]
80008f10:	8f 08       	st.w	r7[0x0],r8
80008f12:	8e 68       	ld.sh	r8,r7[0xc]
80008f14:	a3 b8       	sbr	r8,0x3
80008f16:	ae 68       	st.h	r7[0xc],r8
80008f18:	6e 48       	ld.w	r8,r7[0x10]
80008f1a:	58 08       	cp.w	r8,0
80008f1c:	c0 b1       	brne	80008f32 <__swsetup_r+0xaa>
80008f1e:	8e 68       	ld.sh	r8,r7[0xc]
80008f20:	e2 18 02 80 	andl	r8,0x280,COH
80008f24:	e0 48 02 00 	cp.w	r8,512
80008f28:	c0 50       	breq	80008f32 <__swsetup_r+0xaa>
80008f2a:	0c 9c       	mov	r12,r6
80008f2c:	0e 9b       	mov	r11,r7
80008f2e:	e0 a0 0a 4b 	rcall	8000a3c4 <__smakebuf_r>
80008f32:	8e 69       	ld.sh	r9,r7[0xc]
80008f34:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008f38:	c0 70       	breq	80008f46 <__swsetup_r+0xbe>
80008f3a:	30 08       	mov	r8,0
80008f3c:	8f 28       	st.w	r7[0x8],r8
80008f3e:	6e 58       	ld.w	r8,r7[0x14]
80008f40:	5c 38       	neg	r8
80008f42:	8f 68       	st.w	r7[0x18],r8
80008f44:	c0 68       	rjmp	80008f50 <__swsetup_r+0xc8>
80008f46:	ed b9 00 01 	bld	r9,0x1
80008f4a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008f4e:	8f 28       	st.w	r7[0x8],r8
80008f50:	6e 48       	ld.w	r8,r7[0x10]
80008f52:	58 08       	cp.w	r8,0
80008f54:	c0 61       	brne	80008f60 <__swsetup_r+0xd8>
80008f56:	8e 68       	ld.sh	r8,r7[0xc]
80008f58:	ed b8 00 07 	bld	r8,0x7
80008f5c:	c0 21       	brne	80008f60 <__swsetup_r+0xd8>
80008f5e:	dc 2a       	popm	r4-r7,pc,r12=-1
80008f60:	d8 2a       	popm	r4-r7,pc,r12=0
80008f62:	d7 03       	nop

80008f64 <quorem>:
80008f64:	d4 31       	pushm	r0-r7,lr
80008f66:	20 2d       	sub	sp,8
80008f68:	18 97       	mov	r7,r12
80008f6a:	78 48       	ld.w	r8,r12[0x10]
80008f6c:	76 46       	ld.w	r6,r11[0x10]
80008f6e:	0c 38       	cp.w	r8,r6
80008f70:	c0 34       	brge	80008f76 <quorem+0x12>
80008f72:	30 0c       	mov	r12,0
80008f74:	c8 58       	rjmp	8000907e <quorem+0x11a>
80008f76:	ec c2 ff fc 	sub	r2,r6,-4
80008f7a:	f6 c3 ff ec 	sub	r3,r11,-20
80008f7e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008f82:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008f86:	2f f9       	sub	r9,-1
80008f88:	20 16       	sub	r6,1
80008f8a:	f8 09 0d 08 	divu	r8,r12,r9
80008f8e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008f92:	ee c4 ff ec 	sub	r4,r7,-20
80008f96:	10 95       	mov	r5,r8
80008f98:	58 08       	cp.w	r8,0
80008f9a:	c4 10       	breq	8000901c <quorem+0xb8>
80008f9c:	30 09       	mov	r9,0
80008f9e:	06 9a       	mov	r10,r3
80008fa0:	08 98       	mov	r8,r4
80008fa2:	12 91       	mov	r1,r9
80008fa4:	50 0b       	stdsp	sp[0x0],r11
80008fa6:	70 0e       	ld.w	lr,r8[0x0]
80008fa8:	b1 8e       	lsr	lr,0x10
80008faa:	50 1e       	stdsp	sp[0x4],lr
80008fac:	15 0e       	ld.w	lr,r10++
80008fae:	fc 00 16 10 	lsr	r0,lr,0x10
80008fb2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008fb6:	ea 0e 03 41 	mac	r1,r5,lr
80008fba:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008fbe:	b1 81       	lsr	r1,0x10
80008fc0:	40 1b       	lddsp	r11,sp[0x4]
80008fc2:	ea 00 02 40 	mul	r0,r5,r0
80008fc6:	e2 00 00 00 	add	r0,r1,r0
80008fca:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008fce:	02 1b       	sub	r11,r1
80008fd0:	50 1b       	stdsp	sp[0x4],r11
80008fd2:	70 0b       	ld.w	r11,r8[0x0]
80008fd4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008fd8:	02 09       	add	r9,r1
80008fda:	f2 0e 01 0e 	sub	lr,r9,lr
80008fde:	b0 1e       	st.h	r8[0x2],lr
80008fe0:	fc 09 14 10 	asr	r9,lr,0x10
80008fe4:	40 1e       	lddsp	lr,sp[0x4]
80008fe6:	fc 09 00 09 	add	r9,lr,r9
80008fea:	b0 09       	st.h	r8[0x0],r9
80008fec:	e0 01 16 10 	lsr	r1,r0,0x10
80008ff0:	2f c8       	sub	r8,-4
80008ff2:	b1 49       	asr	r9,0x10
80008ff4:	04 3a       	cp.w	r10,r2
80008ff6:	fe 98 ff d8 	brls	80008fa6 <quorem+0x42>
80008ffa:	40 0b       	lddsp	r11,sp[0x0]
80008ffc:	58 0c       	cp.w	r12,0
80008ffe:	c0 f1       	brne	8000901c <quorem+0xb8>
80009000:	ec c8 ff fb 	sub	r8,r6,-5
80009004:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009008:	c0 28       	rjmp	8000900c <quorem+0xa8>
8000900a:	20 16       	sub	r6,1
8000900c:	20 48       	sub	r8,4
8000900e:	08 38       	cp.w	r8,r4
80009010:	e0 88 00 05 	brls	8000901a <quorem+0xb6>
80009014:	70 09       	ld.w	r9,r8[0x0]
80009016:	58 09       	cp.w	r9,0
80009018:	cf 90       	breq	8000900a <quorem+0xa6>
8000901a:	8f 46       	st.w	r7[0x10],r6
8000901c:	0e 9c       	mov	r12,r7
8000901e:	e0 a0 0a d2 	rcall	8000a5c2 <__mcmp>
80009022:	c2 d5       	brlt	8000907c <quorem+0x118>
80009024:	2f f5       	sub	r5,-1
80009026:	08 98       	mov	r8,r4
80009028:	30 09       	mov	r9,0
8000902a:	07 0b       	ld.w	r11,r3++
8000902c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009030:	70 0c       	ld.w	r12,r8[0x0]
80009032:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009036:	f8 0e 16 10 	lsr	lr,r12,0x10
8000903a:	14 1e       	sub	lr,r10
8000903c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009040:	16 1a       	sub	r10,r11
80009042:	12 0a       	add	r10,r9
80009044:	b0 1a       	st.h	r8[0x2],r10
80009046:	b1 4a       	asr	r10,0x10
80009048:	fc 0a 00 09 	add	r9,lr,r10
8000904c:	b0 09       	st.h	r8[0x0],r9
8000904e:	2f c8       	sub	r8,-4
80009050:	b1 49       	asr	r9,0x10
80009052:	04 33       	cp.w	r3,r2
80009054:	fe 98 ff eb 	brls	8000902a <quorem+0xc6>
80009058:	ec c8 ff fb 	sub	r8,r6,-5
8000905c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009060:	58 09       	cp.w	r9,0
80009062:	c0 d1       	brne	8000907c <quorem+0x118>
80009064:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009068:	c0 28       	rjmp	8000906c <quorem+0x108>
8000906a:	20 16       	sub	r6,1
8000906c:	20 48       	sub	r8,4
8000906e:	08 38       	cp.w	r8,r4
80009070:	e0 88 00 05 	brls	8000907a <quorem+0x116>
80009074:	70 09       	ld.w	r9,r8[0x0]
80009076:	58 09       	cp.w	r9,0
80009078:	cf 90       	breq	8000906a <quorem+0x106>
8000907a:	8f 46       	st.w	r7[0x10],r6
8000907c:	0a 9c       	mov	r12,r5
8000907e:	2f ed       	sub	sp,-8
80009080:	d8 32       	popm	r0-r7,pc
80009082:	d7 03       	nop

80009084 <_dtoa_r>:
80009084:	d4 31       	pushm	r0-r7,lr
80009086:	21 ad       	sub	sp,104
80009088:	fa c4 ff 74 	sub	r4,sp,-140
8000908c:	18 97       	mov	r7,r12
8000908e:	16 95       	mov	r5,r11
80009090:	68 2c       	ld.w	r12,r4[0x8]
80009092:	50 c9       	stdsp	sp[0x30],r9
80009094:	68 16       	ld.w	r6,r4[0x4]
80009096:	68 09       	ld.w	r9,r4[0x0]
80009098:	50 e8       	stdsp	sp[0x38],r8
8000909a:	14 94       	mov	r4,r10
8000909c:	51 2c       	stdsp	sp[0x48],r12
8000909e:	fa e5 00 08 	st.d	sp[8],r4
800090a2:	51 59       	stdsp	sp[0x54],r9
800090a4:	6e 95       	ld.w	r5,r7[0x24]
800090a6:	58 05       	cp.w	r5,0
800090a8:	c0 91       	brne	800090ba <_dtoa_r+0x36>
800090aa:	31 0c       	mov	r12,16
800090ac:	fe b0 e8 e8 	rcall	8000627c <malloc>
800090b0:	99 35       	st.w	r12[0xc],r5
800090b2:	8f 9c       	st.w	r7[0x24],r12
800090b4:	99 15       	st.w	r12[0x4],r5
800090b6:	99 25       	st.w	r12[0x8],r5
800090b8:	99 05       	st.w	r12[0x0],r5
800090ba:	6e 99       	ld.w	r9,r7[0x24]
800090bc:	72 08       	ld.w	r8,r9[0x0]
800090be:	58 08       	cp.w	r8,0
800090c0:	c0 f0       	breq	800090de <_dtoa_r+0x5a>
800090c2:	72 1a       	ld.w	r10,r9[0x4]
800090c4:	91 1a       	st.w	r8[0x4],r10
800090c6:	30 1a       	mov	r10,1
800090c8:	72 19       	ld.w	r9,r9[0x4]
800090ca:	f4 09 09 49 	lsl	r9,r10,r9
800090ce:	10 9b       	mov	r11,r8
800090d0:	91 29       	st.w	r8[0x8],r9
800090d2:	0e 9c       	mov	r12,r7
800090d4:	e0 a0 0a 90 	rcall	8000a5f4 <_Bfree>
800090d8:	6e 98       	ld.w	r8,r7[0x24]
800090da:	30 09       	mov	r9,0
800090dc:	91 09       	st.w	r8[0x0],r9
800090de:	40 28       	lddsp	r8,sp[0x8]
800090e0:	10 94       	mov	r4,r8
800090e2:	58 08       	cp.w	r8,0
800090e4:	c0 64       	brge	800090f0 <_dtoa_r+0x6c>
800090e6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800090ea:	50 28       	stdsp	sp[0x8],r8
800090ec:	30 18       	mov	r8,1
800090ee:	c0 28       	rjmp	800090f2 <_dtoa_r+0x6e>
800090f0:	30 08       	mov	r8,0
800090f2:	8d 08       	st.w	r6[0x0],r8
800090f4:	fc 1c 7f f0 	movh	r12,0x7ff0
800090f8:	40 26       	lddsp	r6,sp[0x8]
800090fa:	0c 98       	mov	r8,r6
800090fc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009100:	18 38       	cp.w	r8,r12
80009102:	c2 01       	brne	80009142 <_dtoa_r+0xbe>
80009104:	e0 68 27 0f 	mov	r8,9999
80009108:	41 5b       	lddsp	r11,sp[0x54]
8000910a:	97 08       	st.w	r11[0x0],r8
8000910c:	40 3a       	lddsp	r10,sp[0xc]
8000910e:	58 0a       	cp.w	r10,0
80009110:	c0 71       	brne	8000911e <_dtoa_r+0x9a>
80009112:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009116:	c0 41       	brne	8000911e <_dtoa_r+0x9a>
80009118:	fe cc c3 98 	sub	r12,pc,-15464
8000911c:	c0 38       	rjmp	80009122 <_dtoa_r+0x9e>
8000911e:	fe cc c3 92 	sub	r12,pc,-15470
80009122:	41 29       	lddsp	r9,sp[0x48]
80009124:	58 09       	cp.w	r9,0
80009126:	e0 80 05 9a 	breq	80009c5a <_dtoa_r+0xbd6>
8000912a:	f8 c8 ff fd 	sub	r8,r12,-3
8000912e:	f8 c9 ff f8 	sub	r9,r12,-8
80009132:	11 8b       	ld.ub	r11,r8[0x0]
80009134:	30 0a       	mov	r10,0
80009136:	41 25       	lddsp	r5,sp[0x48]
80009138:	f4 0b 18 00 	cp.b	r11,r10
8000913c:	f2 08 17 10 	movne	r8,r9
80009140:	c1 68       	rjmp	8000916c <_dtoa_r+0xe8>
80009142:	fa ea 00 08 	ld.d	r10,sp[8]
80009146:	30 08       	mov	r8,0
80009148:	fa eb 00 3c 	st.d	sp[60],r10
8000914c:	30 09       	mov	r9,0
8000914e:	e0 a0 10 c2 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
80009152:	c1 00       	breq	80009172 <_dtoa_r+0xee>
80009154:	30 18       	mov	r8,1
80009156:	41 5a       	lddsp	r10,sp[0x54]
80009158:	95 08       	st.w	r10[0x0],r8
8000915a:	fe cc c4 fe 	sub	r12,pc,-15106
8000915e:	41 29       	lddsp	r9,sp[0x48]
80009160:	f8 08 00 08 	add	r8,r12,r8
80009164:	58 09       	cp.w	r9,0
80009166:	e0 80 05 7a 	breq	80009c5a <_dtoa_r+0xbd6>
8000916a:	12 95       	mov	r5,r9
8000916c:	8b 08       	st.w	r5[0x0],r8
8000916e:	e0 8f 05 76 	bral	80009c5a <_dtoa_r+0xbd6>
80009172:	fa c8 ff 9c 	sub	r8,sp,-100
80009176:	fa c9 ff a0 	sub	r9,sp,-96
8000917a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000917e:	0e 9c       	mov	r12,r7
80009180:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009184:	e0 a0 0a 8a 	rcall	8000a698 <__d2b>
80009188:	18 93       	mov	r3,r12
8000918a:	58 05       	cp.w	r5,0
8000918c:	c0 d0       	breq	800091a6 <_dtoa_r+0x122>
8000918e:	fa ea 00 3c 	ld.d	r10,sp[60]
80009192:	30 04       	mov	r4,0
80009194:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009198:	ea c5 03 ff 	sub	r5,r5,1023
8000919c:	10 9b       	mov	r11,r8
8000919e:	51 74       	stdsp	sp[0x5c],r4
800091a0:	ea 1b 3f f0 	orh	r11,0x3ff0
800091a4:	c2 58       	rjmp	800091ee <_dtoa_r+0x16a>
800091a6:	41 88       	lddsp	r8,sp[0x60]
800091a8:	41 9c       	lddsp	r12,sp[0x64]
800091aa:	10 0c       	add	r12,r8
800091ac:	f8 c5 fb ce 	sub	r5,r12,-1074
800091b0:	e0 45 00 20 	cp.w	r5,32
800091b4:	e0 8a 00 0e 	brle	800091d0 <_dtoa_r+0x14c>
800091b8:	f8 cc fb ee 	sub	r12,r12,-1042
800091bc:	40 3b       	lddsp	r11,sp[0xc]
800091be:	ea 08 11 40 	rsub	r8,r5,64
800091c2:	f6 0c 0a 4c 	lsr	r12,r11,r12
800091c6:	ec 08 09 46 	lsl	r6,r6,r8
800091ca:	0c 4c       	or	r12,r6
800091cc:	c0 78       	rjmp	800091da <_dtoa_r+0x156>
800091ce:	d7 03       	nop
800091d0:	ea 0c 11 20 	rsub	r12,r5,32
800091d4:	40 3a       	lddsp	r10,sp[0xc]
800091d6:	f4 0c 09 4c 	lsl	r12,r10,r12
800091da:	e0 a0 10 08 	rcall	8000b1ea <__avr32_u32_to_f64>
800091de:	fc 18 fe 10 	movh	r8,0xfe10
800091e2:	30 19       	mov	r9,1
800091e4:	ea c5 04 33 	sub	r5,r5,1075
800091e8:	f0 0b 00 0b 	add	r11,r8,r11
800091ec:	51 79       	stdsp	sp[0x5c],r9
800091ee:	30 08       	mov	r8,0
800091f0:	fc 19 3f f8 	movh	r9,0x3ff8
800091f4:	e0 a0 0e 90 	rcall	8000af14 <__avr32_f64_sub>
800091f8:	e0 68 43 61 	mov	r8,17249
800091fc:	ea 18 63 6f 	orh	r8,0x636f
80009200:	e0 69 87 a7 	mov	r9,34727
80009204:	ea 19 3f d2 	orh	r9,0x3fd2
80009208:	e0 a0 0d 9a 	rcall	8000ad3c <__avr32_f64_mul>
8000920c:	e0 68 c8 b3 	mov	r8,51379
80009210:	ea 18 8b 60 	orh	r8,0x8b60
80009214:	e0 69 8a 28 	mov	r9,35368
80009218:	ea 19 3f c6 	orh	r9,0x3fc6
8000921c:	e0 a0 0f 4a 	rcall	8000b0b0 <__avr32_f64_add>
80009220:	0a 9c       	mov	r12,r5
80009222:	14 90       	mov	r0,r10
80009224:	16 91       	mov	r1,r11
80009226:	e0 a0 0f e6 	rcall	8000b1f2 <__avr32_s32_to_f64>
8000922a:	e0 68 79 fb 	mov	r8,31227
8000922e:	ea 18 50 9f 	orh	r8,0x509f
80009232:	e0 69 44 13 	mov	r9,17427
80009236:	ea 19 3f d3 	orh	r9,0x3fd3
8000923a:	e0 a0 0d 81 	rcall	8000ad3c <__avr32_f64_mul>
8000923e:	14 98       	mov	r8,r10
80009240:	16 99       	mov	r9,r11
80009242:	00 9a       	mov	r10,r0
80009244:	02 9b       	mov	r11,r1
80009246:	e0 a0 0f 35 	rcall	8000b0b0 <__avr32_f64_add>
8000924a:	14 90       	mov	r0,r10
8000924c:	16 91       	mov	r1,r11
8000924e:	e0 a0 0f bb 	rcall	8000b1c4 <__avr32_f64_to_s32>
80009252:	30 08       	mov	r8,0
80009254:	18 96       	mov	r6,r12
80009256:	30 09       	mov	r9,0
80009258:	00 9a       	mov	r10,r0
8000925a:	02 9b       	mov	r11,r1
8000925c:	e0 a0 10 82 	rcall	8000b360 <__avr32_f64_cmp_lt>
80009260:	c0 c0       	breq	80009278 <_dtoa_r+0x1f4>
80009262:	0c 9c       	mov	r12,r6
80009264:	e0 a0 0f c7 	rcall	8000b1f2 <__avr32_s32_to_f64>
80009268:	14 98       	mov	r8,r10
8000926a:	16 99       	mov	r9,r11
8000926c:	00 9a       	mov	r10,r0
8000926e:	02 9b       	mov	r11,r1
80009270:	e0 a0 10 31 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
80009274:	f7 b6 00 01 	subeq	r6,1
80009278:	59 66       	cp.w	r6,22
8000927a:	e0 88 00 05 	brls	80009284 <_dtoa_r+0x200>
8000927e:	30 18       	mov	r8,1
80009280:	51 48       	stdsp	sp[0x50],r8
80009282:	c1 38       	rjmp	800092a8 <_dtoa_r+0x224>
80009284:	fe c8 c4 44 	sub	r8,pc,-15292
80009288:	fa ea 00 3c 	ld.d	r10,sp[60]
8000928c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009290:	e0 a0 10 68 	rcall	8000b360 <__avr32_f64_cmp_lt>
80009294:	f9 b4 00 00 	moveq	r4,0
80009298:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000929c:	f7 b6 01 01 	subne	r6,1
800092a0:	f9 bc 01 00 	movne	r12,0
800092a4:	fb fc 1a 14 	st.wne	sp[0x50],r12
800092a8:	41 90       	lddsp	r0,sp[0x64]
800092aa:	20 10       	sub	r0,1
800092ac:	0a 10       	sub	r0,r5
800092ae:	c0 46       	brmi	800092b6 <_dtoa_r+0x232>
800092b0:	50 40       	stdsp	sp[0x10],r0
800092b2:	30 00       	mov	r0,0
800092b4:	c0 48       	rjmp	800092bc <_dtoa_r+0x238>
800092b6:	30 0b       	mov	r11,0
800092b8:	5c 30       	neg	r0
800092ba:	50 4b       	stdsp	sp[0x10],r11
800092bc:	ec 02 11 00 	rsub	r2,r6,0
800092c0:	58 06       	cp.w	r6,0
800092c2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800092c6:	f5 d6 e4 0a 	addge	r10,r10,r6
800092ca:	fb fa 4a 04 	st.wge	sp[0x10],r10
800092ce:	fb f6 4a 11 	st.wge	sp[0x44],r6
800092d2:	f9 b2 04 00 	movge	r2,0
800092d6:	e1 d6 e5 10 	sublt	r0,r0,r6
800092da:	f9 b9 05 00 	movlt	r9,0
800092de:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800092e2:	40 c8       	lddsp	r8,sp[0x30]
800092e4:	58 98       	cp.w	r8,9
800092e6:	e0 8b 00 20 	brhi	80009326 <_dtoa_r+0x2a2>
800092ea:	58 58       	cp.w	r8,5
800092ec:	f9 b4 0a 01 	movle	r4,1
800092f0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800092f4:	f7 b5 09 04 	subgt	r5,4
800092f8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800092fc:	f9 b4 09 00 	movgt	r4,0
80009300:	40 cc       	lddsp	r12,sp[0x30]
80009302:	58 3c       	cp.w	r12,3
80009304:	c2 d0       	breq	8000935e <_dtoa_r+0x2da>
80009306:	e0 89 00 05 	brgt	80009310 <_dtoa_r+0x28c>
8000930a:	58 2c       	cp.w	r12,2
8000930c:	c1 01       	brne	8000932c <_dtoa_r+0x2a8>
8000930e:	c1 88       	rjmp	8000933e <_dtoa_r+0x2ba>
80009310:	40 cb       	lddsp	r11,sp[0x30]
80009312:	58 4b       	cp.w	r11,4
80009314:	c0 60       	breq	80009320 <_dtoa_r+0x29c>
80009316:	58 5b       	cp.w	r11,5
80009318:	c0 a1       	brne	8000932c <_dtoa_r+0x2a8>
8000931a:	30 1a       	mov	r10,1
8000931c:	50 da       	stdsp	sp[0x34],r10
8000931e:	c2 28       	rjmp	80009362 <_dtoa_r+0x2de>
80009320:	30 19       	mov	r9,1
80009322:	50 d9       	stdsp	sp[0x34],r9
80009324:	c0 f8       	rjmp	80009342 <_dtoa_r+0x2be>
80009326:	30 08       	mov	r8,0
80009328:	30 14       	mov	r4,1
8000932a:	50 c8       	stdsp	sp[0x30],r8
8000932c:	3f f5       	mov	r5,-1
8000932e:	30 1c       	mov	r12,1
80009330:	30 0b       	mov	r11,0
80009332:	50 95       	stdsp	sp[0x24],r5
80009334:	50 dc       	stdsp	sp[0x34],r12
80009336:	0a 91       	mov	r1,r5
80009338:	31 28       	mov	r8,18
8000933a:	50 eb       	stdsp	sp[0x38],r11
8000933c:	c2 08       	rjmp	8000937c <_dtoa_r+0x2f8>
8000933e:	30 0a       	mov	r10,0
80009340:	50 da       	stdsp	sp[0x34],r10
80009342:	40 e9       	lddsp	r9,sp[0x38]
80009344:	58 09       	cp.w	r9,0
80009346:	e0 89 00 07 	brgt	80009354 <_dtoa_r+0x2d0>
8000934a:	30 18       	mov	r8,1
8000934c:	50 98       	stdsp	sp[0x24],r8
8000934e:	10 91       	mov	r1,r8
80009350:	50 e8       	stdsp	sp[0x38],r8
80009352:	c1 58       	rjmp	8000937c <_dtoa_r+0x2f8>
80009354:	40 e5       	lddsp	r5,sp[0x38]
80009356:	50 95       	stdsp	sp[0x24],r5
80009358:	0a 91       	mov	r1,r5
8000935a:	0a 98       	mov	r8,r5
8000935c:	c1 08       	rjmp	8000937c <_dtoa_r+0x2f8>
8000935e:	30 0c       	mov	r12,0
80009360:	50 dc       	stdsp	sp[0x34],r12
80009362:	40 eb       	lddsp	r11,sp[0x38]
80009364:	ec 0b 00 0b 	add	r11,r6,r11
80009368:	50 9b       	stdsp	sp[0x24],r11
8000936a:	16 98       	mov	r8,r11
8000936c:	2f f8       	sub	r8,-1
8000936e:	58 08       	cp.w	r8,0
80009370:	e0 89 00 05 	brgt	8000937a <_dtoa_r+0x2f6>
80009374:	10 91       	mov	r1,r8
80009376:	30 18       	mov	r8,1
80009378:	c0 28       	rjmp	8000937c <_dtoa_r+0x2f8>
8000937a:	10 91       	mov	r1,r8
8000937c:	30 09       	mov	r9,0
8000937e:	6e 9a       	ld.w	r10,r7[0x24]
80009380:	95 19       	st.w	r10[0x4],r9
80009382:	30 49       	mov	r9,4
80009384:	c0 68       	rjmp	80009390 <_dtoa_r+0x30c>
80009386:	d7 03       	nop
80009388:	6a 1a       	ld.w	r10,r5[0x4]
8000938a:	a1 79       	lsl	r9,0x1
8000938c:	2f fa       	sub	r10,-1
8000938e:	8b 1a       	st.w	r5[0x4],r10
80009390:	6e 95       	ld.w	r5,r7[0x24]
80009392:	f2 ca ff ec 	sub	r10,r9,-20
80009396:	10 3a       	cp.w	r10,r8
80009398:	fe 98 ff f8 	brls	80009388 <_dtoa_r+0x304>
8000939c:	6a 1b       	ld.w	r11,r5[0x4]
8000939e:	0e 9c       	mov	r12,r7
800093a0:	e0 a0 09 44 	rcall	8000a628 <_Balloc>
800093a4:	58 e1       	cp.w	r1,14
800093a6:	5f 88       	srls	r8
800093a8:	8b 0c       	st.w	r5[0x0],r12
800093aa:	f1 e4 00 04 	and	r4,r8,r4
800093ae:	6e 98       	ld.w	r8,r7[0x24]
800093b0:	70 08       	ld.w	r8,r8[0x0]
800093b2:	50 88       	stdsp	sp[0x20],r8
800093b4:	e0 80 01 82 	breq	800096b8 <_dtoa_r+0x634>
800093b8:	58 06       	cp.w	r6,0
800093ba:	e0 8a 00 43 	brle	80009440 <_dtoa_r+0x3bc>
800093be:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800093c2:	fe c8 c5 82 	sub	r8,pc,-14974
800093c6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800093ca:	fa e5 00 18 	st.d	sp[24],r4
800093ce:	ec 04 14 04 	asr	r4,r6,0x4
800093d2:	ed b4 00 04 	bld	r4,0x4
800093d6:	c0 30       	breq	800093dc <_dtoa_r+0x358>
800093d8:	30 25       	mov	r5,2
800093da:	c1 08       	rjmp	800093fa <_dtoa_r+0x376>
800093dc:	fe c8 c4 d4 	sub	r8,pc,-15148
800093e0:	f0 e8 00 20 	ld.d	r8,r8[32]
800093e4:	fa ea 00 3c 	ld.d	r10,sp[60]
800093e8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800093ec:	e0 a0 0f ee 	rcall	8000b3c8 <__avr32_f64_div>
800093f0:	30 35       	mov	r5,3
800093f2:	14 98       	mov	r8,r10
800093f4:	16 99       	mov	r9,r11
800093f6:	fa e9 00 08 	st.d	sp[8],r8
800093fa:	fe cc c4 f2 	sub	r12,pc,-15118
800093fe:	50 a3       	stdsp	sp[0x28],r3
80009400:	0c 93       	mov	r3,r6
80009402:	18 96       	mov	r6,r12
80009404:	c0 f8       	rjmp	80009422 <_dtoa_r+0x39e>
80009406:	fa ea 00 18 	ld.d	r10,sp[24]
8000940a:	ed b4 00 00 	bld	r4,0x0
8000940e:	c0 81       	brne	8000941e <_dtoa_r+0x39a>
80009410:	ec e8 00 00 	ld.d	r8,r6[0]
80009414:	2f f5       	sub	r5,-1
80009416:	e0 a0 0c 93 	rcall	8000ad3c <__avr32_f64_mul>
8000941a:	fa eb 00 18 	st.d	sp[24],r10
8000941e:	a1 54       	asr	r4,0x1
80009420:	2f 86       	sub	r6,-8
80009422:	58 04       	cp.w	r4,0
80009424:	cf 11       	brne	80009406 <_dtoa_r+0x382>
80009426:	fa e8 00 18 	ld.d	r8,sp[24]
8000942a:	fa ea 00 08 	ld.d	r10,sp[8]
8000942e:	06 96       	mov	r6,r3
80009430:	e0 a0 0f cc 	rcall	8000b3c8 <__avr32_f64_div>
80009434:	40 a3       	lddsp	r3,sp[0x28]
80009436:	14 98       	mov	r8,r10
80009438:	16 99       	mov	r9,r11
8000943a:	fa e9 00 08 	st.d	sp[8],r8
8000943e:	c2 f8       	rjmp	8000949c <_dtoa_r+0x418>
80009440:	ec 08 11 00 	rsub	r8,r6,0
80009444:	c0 31       	brne	8000944a <_dtoa_r+0x3c6>
80009446:	30 25       	mov	r5,2
80009448:	c2 a8       	rjmp	8000949c <_dtoa_r+0x418>
8000944a:	fe cc c5 42 	sub	r12,pc,-15038
8000944e:	f0 04 14 04 	asr	r4,r8,0x4
80009452:	50 1c       	stdsp	sp[0x4],r12
80009454:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009458:	fe c9 c6 18 	sub	r9,pc,-14824
8000945c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009460:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009464:	e0 a0 0c 6c 	rcall	8000ad3c <__avr32_f64_mul>
80009468:	40 1c       	lddsp	r12,sp[0x4]
8000946a:	50 63       	stdsp	sp[0x18],r3
8000946c:	30 25       	mov	r5,2
8000946e:	0c 93       	mov	r3,r6
80009470:	fa eb 00 08 	st.d	sp[8],r10
80009474:	18 96       	mov	r6,r12
80009476:	c0 f8       	rjmp	80009494 <_dtoa_r+0x410>
80009478:	fa ea 00 08 	ld.d	r10,sp[8]
8000947c:	ed b4 00 00 	bld	r4,0x0
80009480:	c0 81       	brne	80009490 <_dtoa_r+0x40c>
80009482:	ec e8 00 00 	ld.d	r8,r6[0]
80009486:	2f f5       	sub	r5,-1
80009488:	e0 a0 0c 5a 	rcall	8000ad3c <__avr32_f64_mul>
8000948c:	fa eb 00 08 	st.d	sp[8],r10
80009490:	a1 54       	asr	r4,0x1
80009492:	2f 86       	sub	r6,-8
80009494:	58 04       	cp.w	r4,0
80009496:	cf 11       	brne	80009478 <_dtoa_r+0x3f4>
80009498:	06 96       	mov	r6,r3
8000949a:	40 63       	lddsp	r3,sp[0x18]
8000949c:	41 4a       	lddsp	r10,sp[0x50]
8000949e:	58 0a       	cp.w	r10,0
800094a0:	c2 a0       	breq	800094f4 <_dtoa_r+0x470>
800094a2:	fa e8 00 08 	ld.d	r8,sp[8]
800094a6:	58 01       	cp.w	r1,0
800094a8:	5f 94       	srgt	r4
800094aa:	fa e9 00 18 	st.d	sp[24],r8
800094ae:	30 08       	mov	r8,0
800094b0:	fc 19 3f f0 	movh	r9,0x3ff0
800094b4:	fa ea 00 18 	ld.d	r10,sp[24]
800094b8:	e0 a0 0f 54 	rcall	8000b360 <__avr32_f64_cmp_lt>
800094bc:	f9 bc 00 00 	moveq	r12,0
800094c0:	f9 bc 01 01 	movne	r12,1
800094c4:	e9 ec 00 0c 	and	r12,r4,r12
800094c8:	c1 60       	breq	800094f4 <_dtoa_r+0x470>
800094ca:	40 98       	lddsp	r8,sp[0x24]
800094cc:	58 08       	cp.w	r8,0
800094ce:	e0 8a 00 f1 	brle	800096b0 <_dtoa_r+0x62c>
800094d2:	30 08       	mov	r8,0
800094d4:	fc 19 40 24 	movh	r9,0x4024
800094d8:	ec c4 00 01 	sub	r4,r6,1
800094dc:	fa ea 00 18 	ld.d	r10,sp[24]
800094e0:	2f f5       	sub	r5,-1
800094e2:	50 64       	stdsp	sp[0x18],r4
800094e4:	e0 a0 0c 2c 	rcall	8000ad3c <__avr32_f64_mul>
800094e8:	40 94       	lddsp	r4,sp[0x24]
800094ea:	14 98       	mov	r8,r10
800094ec:	16 99       	mov	r9,r11
800094ee:	fa e9 00 08 	st.d	sp[8],r8
800094f2:	c0 38       	rjmp	800094f8 <_dtoa_r+0x474>
800094f4:	50 66       	stdsp	sp[0x18],r6
800094f6:	02 94       	mov	r4,r1
800094f8:	0a 9c       	mov	r12,r5
800094fa:	e0 a0 0e 7c 	rcall	8000b1f2 <__avr32_s32_to_f64>
800094fe:	fa e8 00 08 	ld.d	r8,sp[8]
80009502:	e0 a0 0c 1d 	rcall	8000ad3c <__avr32_f64_mul>
80009506:	30 08       	mov	r8,0
80009508:	fc 19 40 1c 	movh	r9,0x401c
8000950c:	e0 a0 0d d2 	rcall	8000b0b0 <__avr32_f64_add>
80009510:	14 98       	mov	r8,r10
80009512:	16 99       	mov	r9,r11
80009514:	fa e9 00 28 	st.d	sp[40],r8
80009518:	fc 18 fc c0 	movh	r8,0xfcc0
8000951c:	40 a5       	lddsp	r5,sp[0x28]
8000951e:	10 05       	add	r5,r8
80009520:	50 a5       	stdsp	sp[0x28],r5
80009522:	58 04       	cp.w	r4,0
80009524:	c2 11       	brne	80009566 <_dtoa_r+0x4e2>
80009526:	fa ea 00 08 	ld.d	r10,sp[8]
8000952a:	30 08       	mov	r8,0
8000952c:	fc 19 40 14 	movh	r9,0x4014
80009530:	e0 a0 0c f2 	rcall	8000af14 <__avr32_f64_sub>
80009534:	40 bc       	lddsp	r12,sp[0x2c]
80009536:	fa eb 00 08 	st.d	sp[8],r10
8000953a:	14 98       	mov	r8,r10
8000953c:	16 99       	mov	r9,r11
8000953e:	18 9a       	mov	r10,r12
80009540:	0a 9b       	mov	r11,r5
80009542:	e0 a0 0f 0f 	rcall	8000b360 <__avr32_f64_cmp_lt>
80009546:	e0 81 02 54 	brne	800099ee <_dtoa_r+0x96a>
8000954a:	0a 98       	mov	r8,r5
8000954c:	40 b9       	lddsp	r9,sp[0x2c]
8000954e:	ee 18 80 00 	eorh	r8,0x8000
80009552:	fa ea 00 08 	ld.d	r10,sp[8]
80009556:	10 95       	mov	r5,r8
80009558:	12 98       	mov	r8,r9
8000955a:	0a 99       	mov	r9,r5
8000955c:	e0 a0 0f 02 	rcall	8000b360 <__avr32_f64_cmp_lt>
80009560:	e0 81 02 3e 	brne	800099dc <_dtoa_r+0x958>
80009564:	ca 68       	rjmp	800096b0 <_dtoa_r+0x62c>
80009566:	fe c9 c7 26 	sub	r9,pc,-14554
8000956a:	e8 c8 00 01 	sub	r8,r4,1
8000956e:	40 d5       	lddsp	r5,sp[0x34]
80009570:	58 05       	cp.w	r5,0
80009572:	c4 f0       	breq	80009610 <_dtoa_r+0x58c>
80009574:	30 0c       	mov	r12,0
80009576:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000957a:	51 3c       	stdsp	sp[0x4c],r12
8000957c:	30 0a       	mov	r10,0
8000957e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009582:	e0 a0 0f 23 	rcall	8000b3c8 <__avr32_f64_div>
80009586:	fa e8 00 28 	ld.d	r8,sp[40]
8000958a:	40 85       	lddsp	r5,sp[0x20]
8000958c:	e0 a0 0c c4 	rcall	8000af14 <__avr32_f64_sub>
80009590:	fa eb 00 28 	st.d	sp[40],r10
80009594:	fa ea 00 08 	ld.d	r10,sp[8]
80009598:	e0 a0 0e 16 	rcall	8000b1c4 <__avr32_f64_to_s32>
8000959c:	51 6c       	stdsp	sp[0x58],r12
8000959e:	e0 a0 0e 2a 	rcall	8000b1f2 <__avr32_s32_to_f64>
800095a2:	14 98       	mov	r8,r10
800095a4:	16 99       	mov	r9,r11
800095a6:	fa ea 00 08 	ld.d	r10,sp[8]
800095aa:	e0 a0 0c b5 	rcall	8000af14 <__avr32_f64_sub>
800095ae:	fa eb 00 08 	st.d	sp[8],r10
800095b2:	41 68       	lddsp	r8,sp[0x58]
800095b4:	2d 08       	sub	r8,-48
800095b6:	0a c8       	st.b	r5++,r8
800095b8:	41 39       	lddsp	r9,sp[0x4c]
800095ba:	2f f9       	sub	r9,-1
800095bc:	51 39       	stdsp	sp[0x4c],r9
800095be:	fa e8 00 28 	ld.d	r8,sp[40]
800095c2:	e0 a0 0e cf 	rcall	8000b360 <__avr32_f64_cmp_lt>
800095c6:	e0 81 03 39 	brne	80009c38 <_dtoa_r+0xbb4>
800095ca:	fa e8 00 08 	ld.d	r8,sp[8]
800095ce:	30 0a       	mov	r10,0
800095d0:	fc 1b 3f f0 	movh	r11,0x3ff0
800095d4:	e0 a0 0c a0 	rcall	8000af14 <__avr32_f64_sub>
800095d8:	fa e8 00 28 	ld.d	r8,sp[40]
800095dc:	e0 a0 0e c2 	rcall	8000b360 <__avr32_f64_cmp_lt>
800095e0:	fa ea 00 28 	ld.d	r10,sp[40]
800095e4:	30 08       	mov	r8,0
800095e6:	fc 19 40 24 	movh	r9,0x4024
800095ea:	e0 81 00 da 	brne	8000979e <_dtoa_r+0x71a>
800095ee:	41 3c       	lddsp	r12,sp[0x4c]
800095f0:	08 3c       	cp.w	r12,r4
800095f2:	c5 f4       	brge	800096b0 <_dtoa_r+0x62c>
800095f4:	e0 a0 0b a4 	rcall	8000ad3c <__avr32_f64_mul>
800095f8:	30 08       	mov	r8,0
800095fa:	fa eb 00 28 	st.d	sp[40],r10
800095fe:	fc 19 40 24 	movh	r9,0x4024
80009602:	fa ea 00 08 	ld.d	r10,sp[8]
80009606:	e0 a0 0b 9b 	rcall	8000ad3c <__avr32_f64_mul>
8000960a:	fa eb 00 08 	st.d	sp[8],r10
8000960e:	cc 3b       	rjmp	80009594 <_dtoa_r+0x510>
80009610:	40 85       	lddsp	r5,sp[0x20]
80009612:	08 05       	add	r5,r4
80009614:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009618:	51 35       	stdsp	sp[0x4c],r5
8000961a:	fa e8 00 28 	ld.d	r8,sp[40]
8000961e:	40 85       	lddsp	r5,sp[0x20]
80009620:	e0 a0 0b 8e 	rcall	8000ad3c <__avr32_f64_mul>
80009624:	fa eb 00 28 	st.d	sp[40],r10
80009628:	fa ea 00 08 	ld.d	r10,sp[8]
8000962c:	e0 a0 0d cc 	rcall	8000b1c4 <__avr32_f64_to_s32>
80009630:	51 6c       	stdsp	sp[0x58],r12
80009632:	e0 a0 0d e0 	rcall	8000b1f2 <__avr32_s32_to_f64>
80009636:	14 98       	mov	r8,r10
80009638:	16 99       	mov	r9,r11
8000963a:	fa ea 00 08 	ld.d	r10,sp[8]
8000963e:	e0 a0 0c 6b 	rcall	8000af14 <__avr32_f64_sub>
80009642:	fa eb 00 08 	st.d	sp[8],r10
80009646:	41 68       	lddsp	r8,sp[0x58]
80009648:	2d 08       	sub	r8,-48
8000964a:	0a c8       	st.b	r5++,r8
8000964c:	41 3c       	lddsp	r12,sp[0x4c]
8000964e:	18 35       	cp.w	r5,r12
80009650:	c2 81       	brne	800096a0 <_dtoa_r+0x61c>
80009652:	30 08       	mov	r8,0
80009654:	fc 19 3f e0 	movh	r9,0x3fe0
80009658:	fa ea 00 28 	ld.d	r10,sp[40]
8000965c:	e0 a0 0d 2a 	rcall	8000b0b0 <__avr32_f64_add>
80009660:	40 85       	lddsp	r5,sp[0x20]
80009662:	fa e8 00 08 	ld.d	r8,sp[8]
80009666:	08 05       	add	r5,r4
80009668:	e0 a0 0e 7c 	rcall	8000b360 <__avr32_f64_cmp_lt>
8000966c:	e0 81 00 99 	brne	8000979e <_dtoa_r+0x71a>
80009670:	fa e8 00 28 	ld.d	r8,sp[40]
80009674:	30 0a       	mov	r10,0
80009676:	fc 1b 3f e0 	movh	r11,0x3fe0
8000967a:	e0 a0 0c 4d 	rcall	8000af14 <__avr32_f64_sub>
8000967e:	14 98       	mov	r8,r10
80009680:	16 99       	mov	r9,r11
80009682:	fa ea 00 08 	ld.d	r10,sp[8]
80009686:	e0 a0 0e 6d 	rcall	8000b360 <__avr32_f64_cmp_lt>
8000968a:	c1 30       	breq	800096b0 <_dtoa_r+0x62c>
8000968c:	33 09       	mov	r9,48
8000968e:	0a 98       	mov	r8,r5
80009690:	11 7a       	ld.ub	r10,--r8
80009692:	f2 0a 18 00 	cp.b	r10,r9
80009696:	e0 81 02 d1 	brne	80009c38 <_dtoa_r+0xbb4>
8000969a:	10 95       	mov	r5,r8
8000969c:	cf 9b       	rjmp	8000968e <_dtoa_r+0x60a>
8000969e:	d7 03       	nop
800096a0:	30 08       	mov	r8,0
800096a2:	fc 19 40 24 	movh	r9,0x4024
800096a6:	e0 a0 0b 4b 	rcall	8000ad3c <__avr32_f64_mul>
800096aa:	fa eb 00 08 	st.d	sp[8],r10
800096ae:	cb db       	rjmp	80009628 <_dtoa_r+0x5a4>
800096b0:	fa ea 00 3c 	ld.d	r10,sp[60]
800096b4:	fa eb 00 08 	st.d	sp[8],r10
800096b8:	58 e6       	cp.w	r6,14
800096ba:	5f ab       	srle	r11
800096bc:	41 8a       	lddsp	r10,sp[0x60]
800096be:	30 08       	mov	r8,0
800096c0:	f4 09 11 ff 	rsub	r9,r10,-1
800096c4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800096c8:	f0 09 18 00 	cp.b	r9,r8
800096cc:	e0 80 00 82 	breq	800097d0 <_dtoa_r+0x74c>
800096d0:	40 ea       	lddsp	r10,sp[0x38]
800096d2:	58 01       	cp.w	r1,0
800096d4:	5f a9       	srle	r9
800096d6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800096da:	fe ca c8 9a 	sub	r10,pc,-14182
800096de:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800096e2:	fa e5 00 10 	st.d	sp[16],r4
800096e6:	f0 09 18 00 	cp.b	r9,r8
800096ea:	c1 40       	breq	80009712 <_dtoa_r+0x68e>
800096ec:	58 01       	cp.w	r1,0
800096ee:	e0 81 01 77 	brne	800099dc <_dtoa_r+0x958>
800096f2:	30 08       	mov	r8,0
800096f4:	fc 19 40 14 	movh	r9,0x4014
800096f8:	08 9a       	mov	r10,r4
800096fa:	0a 9b       	mov	r11,r5
800096fc:	e0 a0 0b 20 	rcall	8000ad3c <__avr32_f64_mul>
80009700:	fa e8 00 08 	ld.d	r8,sp[8]
80009704:	e0 a0 0d fa 	rcall	8000b2f8 <__avr32_f64_cmp_ge>
80009708:	e0 81 01 6a 	brne	800099dc <_dtoa_r+0x958>
8000970c:	02 92       	mov	r2,r1
8000970e:	e0 8f 01 72 	bral	800099f2 <_dtoa_r+0x96e>
80009712:	40 85       	lddsp	r5,sp[0x20]
80009714:	30 14       	mov	r4,1
80009716:	fa e8 00 10 	ld.d	r8,sp[16]
8000971a:	fa ea 00 08 	ld.d	r10,sp[8]
8000971e:	e0 a0 0e 55 	rcall	8000b3c8 <__avr32_f64_div>
80009722:	e0 a0 0d 51 	rcall	8000b1c4 <__avr32_f64_to_s32>
80009726:	18 92       	mov	r2,r12
80009728:	e0 a0 0d 65 	rcall	8000b1f2 <__avr32_s32_to_f64>
8000972c:	fa e8 00 10 	ld.d	r8,sp[16]
80009730:	e0 a0 0b 06 	rcall	8000ad3c <__avr32_f64_mul>
80009734:	14 98       	mov	r8,r10
80009736:	16 99       	mov	r9,r11
80009738:	fa ea 00 08 	ld.d	r10,sp[8]
8000973c:	e0 a0 0b ec 	rcall	8000af14 <__avr32_f64_sub>
80009740:	fa eb 00 08 	st.d	sp[8],r10
80009744:	e4 c8 ff d0 	sub	r8,r2,-48
80009748:	0a c8       	st.b	r5++,r8
8000974a:	fc 19 40 24 	movh	r9,0x4024
8000974e:	30 08       	mov	r8,0
80009750:	02 34       	cp.w	r4,r1
80009752:	c3 31       	brne	800097b8 <_dtoa_r+0x734>
80009754:	fa e8 00 08 	ld.d	r8,sp[8]
80009758:	e0 a0 0c ac 	rcall	8000b0b0 <__avr32_f64_add>
8000975c:	16 91       	mov	r1,r11
8000975e:	14 90       	mov	r0,r10
80009760:	14 98       	mov	r8,r10
80009762:	02 99       	mov	r9,r1
80009764:	fa ea 00 10 	ld.d	r10,sp[16]
80009768:	e0 a0 0d fc 	rcall	8000b360 <__avr32_f64_cmp_lt>
8000976c:	c1 a1       	brne	800097a0 <_dtoa_r+0x71c>
8000976e:	fa e8 00 10 	ld.d	r8,sp[16]
80009772:	00 9a       	mov	r10,r0
80009774:	02 9b       	mov	r11,r1
80009776:	e0 a0 0d ae 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
8000977a:	e0 80 02 5e 	breq	80009c36 <_dtoa_r+0xbb2>
8000977e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009782:	c0 f1       	brne	800097a0 <_dtoa_r+0x71c>
80009784:	e0 8f 02 59 	bral	80009c36 <_dtoa_r+0xbb2>
80009788:	40 8a       	lddsp	r10,sp[0x20]
8000978a:	14 38       	cp.w	r8,r10
8000978c:	c0 30       	breq	80009792 <_dtoa_r+0x70e>
8000978e:	10 95       	mov	r5,r8
80009790:	c0 98       	rjmp	800097a2 <_dtoa_r+0x71e>
80009792:	33 08       	mov	r8,48
80009794:	40 89       	lddsp	r9,sp[0x20]
80009796:	2f f6       	sub	r6,-1
80009798:	b2 88       	st.b	r9[0x0],r8
8000979a:	40 88       	lddsp	r8,sp[0x20]
8000979c:	c0 88       	rjmp	800097ac <_dtoa_r+0x728>
8000979e:	40 66       	lddsp	r6,sp[0x18]
800097a0:	33 99       	mov	r9,57
800097a2:	0a 98       	mov	r8,r5
800097a4:	11 7a       	ld.ub	r10,--r8
800097a6:	f2 0a 18 00 	cp.b	r10,r9
800097aa:	ce f0       	breq	80009788 <_dtoa_r+0x704>
800097ac:	50 66       	stdsp	sp[0x18],r6
800097ae:	11 89       	ld.ub	r9,r8[0x0]
800097b0:	2f f9       	sub	r9,-1
800097b2:	b0 89       	st.b	r8[0x0],r9
800097b4:	e0 8f 02 42 	bral	80009c38 <_dtoa_r+0xbb4>
800097b8:	e0 a0 0a c2 	rcall	8000ad3c <__avr32_f64_mul>
800097bc:	2f f4       	sub	r4,-1
800097be:	fa eb 00 08 	st.d	sp[8],r10
800097c2:	30 08       	mov	r8,0
800097c4:	30 09       	mov	r9,0
800097c6:	e0 a0 0d 86 	rcall	8000b2d2 <__avr32_f64_cmp_eq>
800097ca:	ca 60       	breq	80009716 <_dtoa_r+0x692>
800097cc:	e0 8f 02 35 	bral	80009c36 <_dtoa_r+0xbb2>
800097d0:	40 d8       	lddsp	r8,sp[0x34]
800097d2:	58 08       	cp.w	r8,0
800097d4:	c0 51       	brne	800097de <_dtoa_r+0x75a>
800097d6:	04 98       	mov	r8,r2
800097d8:	00 95       	mov	r5,r0
800097da:	40 d4       	lddsp	r4,sp[0x34]
800097dc:	c3 78       	rjmp	8000984a <_dtoa_r+0x7c6>
800097de:	40 c5       	lddsp	r5,sp[0x30]
800097e0:	58 15       	cp.w	r5,1
800097e2:	e0 89 00 0f 	brgt	80009800 <_dtoa_r+0x77c>
800097e6:	41 74       	lddsp	r4,sp[0x5c]
800097e8:	58 04       	cp.w	r4,0
800097ea:	c0 40       	breq	800097f2 <_dtoa_r+0x76e>
800097ec:	f4 c9 fb cd 	sub	r9,r10,-1075
800097f0:	c0 48       	rjmp	800097f8 <_dtoa_r+0x774>
800097f2:	41 99       	lddsp	r9,sp[0x64]
800097f4:	f2 09 11 36 	rsub	r9,r9,54
800097f8:	04 98       	mov	r8,r2
800097fa:	00 95       	mov	r5,r0
800097fc:	c1 c8       	rjmp	80009834 <_dtoa_r+0x7b0>
800097fe:	d7 03       	nop
80009800:	e2 c8 00 01 	sub	r8,r1,1
80009804:	58 01       	cp.w	r1,0
80009806:	e0 05 17 40 	movge	r5,r0
8000980a:	e2 09 17 40 	movge	r9,r1
8000980e:	e1 d1 e5 15 	sublt	r5,r0,r1
80009812:	f9 b9 05 00 	movlt	r9,0
80009816:	10 32       	cp.w	r2,r8
80009818:	e5 d8 e4 18 	subge	r8,r2,r8
8000981c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009820:	e5 d8 e5 02 	addlt	r2,r2,r8
80009824:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009828:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000982c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009830:	f9 b8 05 00 	movlt	r8,0
80009834:	40 4b       	lddsp	r11,sp[0x10]
80009836:	12 0b       	add	r11,r9
80009838:	50 08       	stdsp	sp[0x0],r8
8000983a:	50 4b       	stdsp	sp[0x10],r11
8000983c:	12 00       	add	r0,r9
8000983e:	30 1b       	mov	r11,1
80009840:	0e 9c       	mov	r12,r7
80009842:	e0 a0 08 a7 	rcall	8000a990 <__i2b>
80009846:	40 08       	lddsp	r8,sp[0x0]
80009848:	18 94       	mov	r4,r12
8000984a:	40 4a       	lddsp	r10,sp[0x10]
8000984c:	58 05       	cp.w	r5,0
8000984e:	5f 99       	srgt	r9
80009850:	58 0a       	cp.w	r10,0
80009852:	5f 9a       	srgt	r10
80009854:	f5 e9 00 09 	and	r9,r10,r9
80009858:	c0 80       	breq	80009868 <_dtoa_r+0x7e4>
8000985a:	40 4c       	lddsp	r12,sp[0x10]
8000985c:	f8 05 0d 49 	min	r9,r12,r5
80009860:	12 1c       	sub	r12,r9
80009862:	12 10       	sub	r0,r9
80009864:	50 4c       	stdsp	sp[0x10],r12
80009866:	12 15       	sub	r5,r9
80009868:	58 02       	cp.w	r2,0
8000986a:	e0 8a 00 27 	brle	800098b8 <_dtoa_r+0x834>
8000986e:	40 db       	lddsp	r11,sp[0x34]
80009870:	58 0b       	cp.w	r11,0
80009872:	c1 d0       	breq	800098ac <_dtoa_r+0x828>
80009874:	58 08       	cp.w	r8,0
80009876:	e0 8a 00 17 	brle	800098a4 <_dtoa_r+0x820>
8000987a:	10 9a       	mov	r10,r8
8000987c:	50 08       	stdsp	sp[0x0],r8
8000987e:	08 9b       	mov	r11,r4
80009880:	0e 9c       	mov	r12,r7
80009882:	e0 a0 08 cd 	rcall	8000aa1c <__pow5mult>
80009886:	06 9a       	mov	r10,r3
80009888:	18 9b       	mov	r11,r12
8000988a:	18 94       	mov	r4,r12
8000988c:	0e 9c       	mov	r12,r7
8000988e:	e0 a0 08 01 	rcall	8000a890 <__multiply>
80009892:	18 99       	mov	r9,r12
80009894:	06 9b       	mov	r11,r3
80009896:	50 19       	stdsp	sp[0x4],r9
80009898:	0e 9c       	mov	r12,r7
8000989a:	e0 a0 06 ad 	rcall	8000a5f4 <_Bfree>
8000989e:	40 19       	lddsp	r9,sp[0x4]
800098a0:	40 08       	lddsp	r8,sp[0x0]
800098a2:	12 93       	mov	r3,r9
800098a4:	e4 08 01 0a 	sub	r10,r2,r8
800098a8:	c0 80       	breq	800098b8 <_dtoa_r+0x834>
800098aa:	c0 28       	rjmp	800098ae <_dtoa_r+0x82a>
800098ac:	04 9a       	mov	r10,r2
800098ae:	06 9b       	mov	r11,r3
800098b0:	0e 9c       	mov	r12,r7
800098b2:	e0 a0 08 b5 	rcall	8000aa1c <__pow5mult>
800098b6:	18 93       	mov	r3,r12
800098b8:	30 1b       	mov	r11,1
800098ba:	0e 9c       	mov	r12,r7
800098bc:	e0 a0 08 6a 	rcall	8000a990 <__i2b>
800098c0:	41 1a       	lddsp	r10,sp[0x44]
800098c2:	18 92       	mov	r2,r12
800098c4:	58 0a       	cp.w	r10,0
800098c6:	e0 8a 00 07 	brle	800098d4 <_dtoa_r+0x850>
800098ca:	18 9b       	mov	r11,r12
800098cc:	0e 9c       	mov	r12,r7
800098ce:	e0 a0 08 a7 	rcall	8000aa1c <__pow5mult>
800098d2:	18 92       	mov	r2,r12
800098d4:	40 c9       	lddsp	r9,sp[0x30]
800098d6:	58 19       	cp.w	r9,1
800098d8:	e0 89 00 14 	brgt	80009900 <_dtoa_r+0x87c>
800098dc:	40 38       	lddsp	r8,sp[0xc]
800098de:	58 08       	cp.w	r8,0
800098e0:	c1 01       	brne	80009900 <_dtoa_r+0x87c>
800098e2:	40 29       	lddsp	r9,sp[0x8]
800098e4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
800098e8:	c0 c1       	brne	80009900 <_dtoa_r+0x87c>
800098ea:	12 98       	mov	r8,r9
800098ec:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800098f0:	c0 80       	breq	80009900 <_dtoa_r+0x87c>
800098f2:	40 4c       	lddsp	r12,sp[0x10]
800098f4:	30 1b       	mov	r11,1
800098f6:	2f fc       	sub	r12,-1
800098f8:	2f f0       	sub	r0,-1
800098fa:	50 4c       	stdsp	sp[0x10],r12
800098fc:	50 6b       	stdsp	sp[0x18],r11
800098fe:	c0 38       	rjmp	80009904 <_dtoa_r+0x880>
80009900:	30 0a       	mov	r10,0
80009902:	50 6a       	stdsp	sp[0x18],r10
80009904:	41 19       	lddsp	r9,sp[0x44]
80009906:	58 09       	cp.w	r9,0
80009908:	c0 31       	brne	8000990e <_dtoa_r+0x88a>
8000990a:	30 1c       	mov	r12,1
8000990c:	c0 98       	rjmp	8000991e <_dtoa_r+0x89a>
8000990e:	64 48       	ld.w	r8,r2[0x10]
80009910:	2f c8       	sub	r8,-4
80009912:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009916:	e0 a0 05 df 	rcall	8000a4d4 <__hi0bits>
8000991a:	f8 0c 11 20 	rsub	r12,r12,32
8000991e:	40 4b       	lddsp	r11,sp[0x10]
80009920:	f8 0b 00 08 	add	r8,r12,r11
80009924:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009928:	c0 c0       	breq	80009940 <_dtoa_r+0x8bc>
8000992a:	f0 08 11 20 	rsub	r8,r8,32
8000992e:	58 48       	cp.w	r8,4
80009930:	e0 8a 00 06 	brle	8000993c <_dtoa_r+0x8b8>
80009934:	20 48       	sub	r8,4
80009936:	10 0b       	add	r11,r8
80009938:	50 4b       	stdsp	sp[0x10],r11
8000993a:	c0 78       	rjmp	80009948 <_dtoa_r+0x8c4>
8000993c:	58 48       	cp.w	r8,4
8000993e:	c0 70       	breq	8000994c <_dtoa_r+0x8c8>
80009940:	40 4a       	lddsp	r10,sp[0x10]
80009942:	2e 48       	sub	r8,-28
80009944:	10 0a       	add	r10,r8
80009946:	50 4a       	stdsp	sp[0x10],r10
80009948:	10 00       	add	r0,r8
8000994a:	10 05       	add	r5,r8
8000994c:	58 00       	cp.w	r0,0
8000994e:	e0 8a 00 08 	brle	8000995e <_dtoa_r+0x8da>
80009952:	06 9b       	mov	r11,r3
80009954:	00 9a       	mov	r10,r0
80009956:	0e 9c       	mov	r12,r7
80009958:	e0 a0 07 58 	rcall	8000a808 <__lshift>
8000995c:	18 93       	mov	r3,r12
8000995e:	40 49       	lddsp	r9,sp[0x10]
80009960:	58 09       	cp.w	r9,0
80009962:	e0 8a 00 08 	brle	80009972 <_dtoa_r+0x8ee>
80009966:	04 9b       	mov	r11,r2
80009968:	12 9a       	mov	r10,r9
8000996a:	0e 9c       	mov	r12,r7
8000996c:	e0 a0 07 4e 	rcall	8000a808 <__lshift>
80009970:	18 92       	mov	r2,r12
80009972:	41 48       	lddsp	r8,sp[0x50]
80009974:	58 08       	cp.w	r8,0
80009976:	c1 b0       	breq	800099ac <_dtoa_r+0x928>
80009978:	04 9b       	mov	r11,r2
8000997a:	06 9c       	mov	r12,r3
8000997c:	e0 a0 06 23 	rcall	8000a5c2 <__mcmp>
80009980:	c1 64       	brge	800099ac <_dtoa_r+0x928>
80009982:	06 9b       	mov	r11,r3
80009984:	30 09       	mov	r9,0
80009986:	30 aa       	mov	r10,10
80009988:	0e 9c       	mov	r12,r7
8000998a:	e0 a0 08 0b 	rcall	8000a9a0 <__multadd>
8000998e:	20 16       	sub	r6,1
80009990:	18 93       	mov	r3,r12
80009992:	40 dc       	lddsp	r12,sp[0x34]
80009994:	58 0c       	cp.w	r12,0
80009996:	c0 31       	brne	8000999c <_dtoa_r+0x918>
80009998:	40 91       	lddsp	r1,sp[0x24]
8000999a:	c0 98       	rjmp	800099ac <_dtoa_r+0x928>
8000999c:	08 9b       	mov	r11,r4
8000999e:	40 91       	lddsp	r1,sp[0x24]
800099a0:	30 09       	mov	r9,0
800099a2:	30 aa       	mov	r10,10
800099a4:	0e 9c       	mov	r12,r7
800099a6:	e0 a0 07 fd 	rcall	8000a9a0 <__multadd>
800099aa:	18 94       	mov	r4,r12
800099ac:	58 01       	cp.w	r1,0
800099ae:	5f a9       	srle	r9
800099b0:	40 cb       	lddsp	r11,sp[0x30]
800099b2:	58 2b       	cp.w	r11,2
800099b4:	5f 98       	srgt	r8
800099b6:	f3 e8 00 08 	and	r8,r9,r8
800099ba:	c2 50       	breq	80009a04 <_dtoa_r+0x980>
800099bc:	58 01       	cp.w	r1,0
800099be:	c1 11       	brne	800099e0 <_dtoa_r+0x95c>
800099c0:	04 9b       	mov	r11,r2
800099c2:	02 99       	mov	r9,r1
800099c4:	30 5a       	mov	r10,5
800099c6:	0e 9c       	mov	r12,r7
800099c8:	e0 a0 07 ec 	rcall	8000a9a0 <__multadd>
800099cc:	18 92       	mov	r2,r12
800099ce:	18 9b       	mov	r11,r12
800099d0:	06 9c       	mov	r12,r3
800099d2:	e0 a0 05 f8 	rcall	8000a5c2 <__mcmp>
800099d6:	e0 89 00 0f 	brgt	800099f4 <_dtoa_r+0x970>
800099da:	c0 38       	rjmp	800099e0 <_dtoa_r+0x95c>
800099dc:	30 02       	mov	r2,0
800099de:	04 94       	mov	r4,r2
800099e0:	40 ea       	lddsp	r10,sp[0x38]
800099e2:	30 09       	mov	r9,0
800099e4:	5c da       	com	r10
800099e6:	40 85       	lddsp	r5,sp[0x20]
800099e8:	50 6a       	stdsp	sp[0x18],r10
800099ea:	50 49       	stdsp	sp[0x10],r9
800099ec:	c0 f9       	rjmp	80009c0a <_dtoa_r+0xb86>
800099ee:	08 92       	mov	r2,r4
800099f0:	40 66       	lddsp	r6,sp[0x18]
800099f2:	04 94       	mov	r4,r2
800099f4:	2f f6       	sub	r6,-1
800099f6:	50 66       	stdsp	sp[0x18],r6
800099f8:	33 18       	mov	r8,49
800099fa:	40 85       	lddsp	r5,sp[0x20]
800099fc:	0a c8       	st.b	r5++,r8
800099fe:	30 08       	mov	r8,0
80009a00:	50 48       	stdsp	sp[0x10],r8
80009a02:	c0 49       	rjmp	80009c0a <_dtoa_r+0xb86>
80009a04:	40 dc       	lddsp	r12,sp[0x34]
80009a06:	58 0c       	cp.w	r12,0
80009a08:	e0 80 00 b5 	breq	80009b72 <_dtoa_r+0xaee>
80009a0c:	58 05       	cp.w	r5,0
80009a0e:	e0 8a 00 08 	brle	80009a1e <_dtoa_r+0x99a>
80009a12:	08 9b       	mov	r11,r4
80009a14:	0a 9a       	mov	r10,r5
80009a16:	0e 9c       	mov	r12,r7
80009a18:	e0 a0 06 f8 	rcall	8000a808 <__lshift>
80009a1c:	18 94       	mov	r4,r12
80009a1e:	40 6b       	lddsp	r11,sp[0x18]
80009a20:	58 0b       	cp.w	r11,0
80009a22:	c0 31       	brne	80009a28 <_dtoa_r+0x9a4>
80009a24:	08 9c       	mov	r12,r4
80009a26:	c1 38       	rjmp	80009a4c <_dtoa_r+0x9c8>
80009a28:	68 1b       	ld.w	r11,r4[0x4]
80009a2a:	0e 9c       	mov	r12,r7
80009a2c:	e0 a0 05 fe 	rcall	8000a628 <_Balloc>
80009a30:	68 4a       	ld.w	r10,r4[0x10]
80009a32:	18 95       	mov	r5,r12
80009a34:	e8 cb ff f4 	sub	r11,r4,-12
80009a38:	2f ea       	sub	r10,-2
80009a3a:	2f 4c       	sub	r12,-12
80009a3c:	a3 6a       	lsl	r10,0x2
80009a3e:	fe b0 e6 43 	rcall	800066c4 <memcpy>
80009a42:	0a 9b       	mov	r11,r5
80009a44:	30 1a       	mov	r10,1
80009a46:	0e 9c       	mov	r12,r7
80009a48:	e0 a0 06 e0 	rcall	8000a808 <__lshift>
80009a4c:	50 44       	stdsp	sp[0x10],r4
80009a4e:	40 3a       	lddsp	r10,sp[0xc]
80009a50:	30 19       	mov	r9,1
80009a52:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009a56:	18 94       	mov	r4,r12
80009a58:	50 da       	stdsp	sp[0x34],r10
80009a5a:	40 85       	lddsp	r5,sp[0x20]
80009a5c:	50 99       	stdsp	sp[0x24],r9
80009a5e:	50 26       	stdsp	sp[0x8],r6
80009a60:	50 e1       	stdsp	sp[0x38],r1
80009a62:	04 9b       	mov	r11,r2
80009a64:	06 9c       	mov	r12,r3
80009a66:	fe b0 fa 7f 	rcall	80008f64 <quorem>
80009a6a:	40 4b       	lddsp	r11,sp[0x10]
80009a6c:	f8 c0 ff d0 	sub	r0,r12,-48
80009a70:	06 9c       	mov	r12,r3
80009a72:	e0 a0 05 a8 	rcall	8000a5c2 <__mcmp>
80009a76:	08 9a       	mov	r10,r4
80009a78:	50 6c       	stdsp	sp[0x18],r12
80009a7a:	04 9b       	mov	r11,r2
80009a7c:	0e 9c       	mov	r12,r7
80009a7e:	e0 a0 06 5d 	rcall	8000a738 <__mdiff>
80009a82:	18 91       	mov	r1,r12
80009a84:	78 38       	ld.w	r8,r12[0xc]
80009a86:	58 08       	cp.w	r8,0
80009a88:	c0 30       	breq	80009a8e <_dtoa_r+0xa0a>
80009a8a:	30 16       	mov	r6,1
80009a8c:	c0 68       	rjmp	80009a98 <_dtoa_r+0xa14>
80009a8e:	18 9b       	mov	r11,r12
80009a90:	06 9c       	mov	r12,r3
80009a92:	e0 a0 05 98 	rcall	8000a5c2 <__mcmp>
80009a96:	18 96       	mov	r6,r12
80009a98:	0e 9c       	mov	r12,r7
80009a9a:	02 9b       	mov	r11,r1
80009a9c:	e0 a0 05 ac 	rcall	8000a5f4 <_Bfree>
80009aa0:	40 cc       	lddsp	r12,sp[0x30]
80009aa2:	ed ec 10 08 	or	r8,r6,r12
80009aa6:	c0 d1       	brne	80009ac0 <_dtoa_r+0xa3c>
80009aa8:	40 db       	lddsp	r11,sp[0x34]
80009aaa:	58 0b       	cp.w	r11,0
80009aac:	c0 a1       	brne	80009ac0 <_dtoa_r+0xa3c>
80009aae:	40 26       	lddsp	r6,sp[0x8]
80009ab0:	e0 40 00 39 	cp.w	r0,57
80009ab4:	c3 00       	breq	80009b14 <_dtoa_r+0xa90>
80009ab6:	40 6a       	lddsp	r10,sp[0x18]
80009ab8:	58 0a       	cp.w	r10,0
80009aba:	e0 89 00 24 	brgt	80009b02 <_dtoa_r+0xa7e>
80009abe:	c2 f8       	rjmp	80009b1c <_dtoa_r+0xa98>
80009ac0:	40 69       	lddsp	r9,sp[0x18]
80009ac2:	58 09       	cp.w	r9,0
80009ac4:	c0 85       	brlt	80009ad4 <_dtoa_r+0xa50>
80009ac6:	12 98       	mov	r8,r9
80009ac8:	40 cc       	lddsp	r12,sp[0x30]
80009aca:	18 48       	or	r8,r12
80009acc:	c1 d1       	brne	80009b06 <_dtoa_r+0xa82>
80009ace:	40 db       	lddsp	r11,sp[0x34]
80009ad0:	58 0b       	cp.w	r11,0
80009ad2:	c1 a1       	brne	80009b06 <_dtoa_r+0xa82>
80009ad4:	0c 99       	mov	r9,r6
80009ad6:	40 26       	lddsp	r6,sp[0x8]
80009ad8:	58 09       	cp.w	r9,0
80009ada:	e0 8a 00 21 	brle	80009b1c <_dtoa_r+0xa98>
80009ade:	06 9b       	mov	r11,r3
80009ae0:	30 1a       	mov	r10,1
80009ae2:	0e 9c       	mov	r12,r7
80009ae4:	e0 a0 06 92 	rcall	8000a808 <__lshift>
80009ae8:	04 9b       	mov	r11,r2
80009aea:	18 93       	mov	r3,r12
80009aec:	e0 a0 05 6b 	rcall	8000a5c2 <__mcmp>
80009af0:	e0 89 00 06 	brgt	80009afc <_dtoa_r+0xa78>
80009af4:	c1 41       	brne	80009b1c <_dtoa_r+0xa98>
80009af6:	ed b0 00 00 	bld	r0,0x0
80009afa:	c1 11       	brne	80009b1c <_dtoa_r+0xa98>
80009afc:	e0 40 00 39 	cp.w	r0,57
80009b00:	c0 a0       	breq	80009b14 <_dtoa_r+0xa90>
80009b02:	2f f0       	sub	r0,-1
80009b04:	c0 c8       	rjmp	80009b1c <_dtoa_r+0xa98>
80009b06:	58 06       	cp.w	r6,0
80009b08:	e0 8a 00 0c 	brle	80009b20 <_dtoa_r+0xa9c>
80009b0c:	40 26       	lddsp	r6,sp[0x8]
80009b0e:	e0 40 00 39 	cp.w	r0,57
80009b12:	c0 41       	brne	80009b1a <_dtoa_r+0xa96>
80009b14:	33 98       	mov	r8,57
80009b16:	0a c8       	st.b	r5++,r8
80009b18:	c6 78       	rjmp	80009be6 <_dtoa_r+0xb62>
80009b1a:	2f f0       	sub	r0,-1
80009b1c:	0a c0       	st.b	r5++,r0
80009b1e:	c7 58       	rjmp	80009c08 <_dtoa_r+0xb84>
80009b20:	0a c0       	st.b	r5++,r0
80009b22:	40 9a       	lddsp	r10,sp[0x24]
80009b24:	40 e9       	lddsp	r9,sp[0x38]
80009b26:	12 3a       	cp.w	r10,r9
80009b28:	c4 30       	breq	80009bae <_dtoa_r+0xb2a>
80009b2a:	06 9b       	mov	r11,r3
80009b2c:	30 09       	mov	r9,0
80009b2e:	30 aa       	mov	r10,10
80009b30:	0e 9c       	mov	r12,r7
80009b32:	e0 a0 07 37 	rcall	8000a9a0 <__multadd>
80009b36:	40 48       	lddsp	r8,sp[0x10]
80009b38:	18 93       	mov	r3,r12
80009b3a:	08 38       	cp.w	r8,r4
80009b3c:	c0 91       	brne	80009b4e <_dtoa_r+0xaca>
80009b3e:	10 9b       	mov	r11,r8
80009b40:	30 09       	mov	r9,0
80009b42:	30 aa       	mov	r10,10
80009b44:	0e 9c       	mov	r12,r7
80009b46:	e0 a0 07 2d 	rcall	8000a9a0 <__multadd>
80009b4a:	50 4c       	stdsp	sp[0x10],r12
80009b4c:	c0 e8       	rjmp	80009b68 <_dtoa_r+0xae4>
80009b4e:	40 4b       	lddsp	r11,sp[0x10]
80009b50:	30 09       	mov	r9,0
80009b52:	30 aa       	mov	r10,10
80009b54:	0e 9c       	mov	r12,r7
80009b56:	e0 a0 07 25 	rcall	8000a9a0 <__multadd>
80009b5a:	08 9b       	mov	r11,r4
80009b5c:	50 4c       	stdsp	sp[0x10],r12
80009b5e:	30 09       	mov	r9,0
80009b60:	30 aa       	mov	r10,10
80009b62:	0e 9c       	mov	r12,r7
80009b64:	e0 a0 07 1e 	rcall	8000a9a0 <__multadd>
80009b68:	18 94       	mov	r4,r12
80009b6a:	40 9c       	lddsp	r12,sp[0x24]
80009b6c:	2f fc       	sub	r12,-1
80009b6e:	50 9c       	stdsp	sp[0x24],r12
80009b70:	c7 9b       	rjmp	80009a62 <_dtoa_r+0x9de>
80009b72:	30 18       	mov	r8,1
80009b74:	06 90       	mov	r0,r3
80009b76:	40 85       	lddsp	r5,sp[0x20]
80009b78:	08 93       	mov	r3,r4
80009b7a:	0c 94       	mov	r4,r6
80009b7c:	10 96       	mov	r6,r8
80009b7e:	04 9b       	mov	r11,r2
80009b80:	00 9c       	mov	r12,r0
80009b82:	fe b0 f9 f1 	rcall	80008f64 <quorem>
80009b86:	2d 0c       	sub	r12,-48
80009b88:	0a cc       	st.b	r5++,r12
80009b8a:	02 36       	cp.w	r6,r1
80009b8c:	c0 a4       	brge	80009ba0 <_dtoa_r+0xb1c>
80009b8e:	00 9b       	mov	r11,r0
80009b90:	30 09       	mov	r9,0
80009b92:	30 aa       	mov	r10,10
80009b94:	0e 9c       	mov	r12,r7
80009b96:	2f f6       	sub	r6,-1
80009b98:	e0 a0 07 04 	rcall	8000a9a0 <__multadd>
80009b9c:	18 90       	mov	r0,r12
80009b9e:	cf 0b       	rjmp	80009b7e <_dtoa_r+0xafa>
80009ba0:	08 96       	mov	r6,r4
80009ba2:	30 0b       	mov	r11,0
80009ba4:	06 94       	mov	r4,r3
80009ba6:	50 4b       	stdsp	sp[0x10],r11
80009ba8:	00 93       	mov	r3,r0
80009baa:	18 90       	mov	r0,r12
80009bac:	c0 28       	rjmp	80009bb0 <_dtoa_r+0xb2c>
80009bae:	40 26       	lddsp	r6,sp[0x8]
80009bb0:	06 9b       	mov	r11,r3
80009bb2:	30 1a       	mov	r10,1
80009bb4:	0e 9c       	mov	r12,r7
80009bb6:	e0 a0 06 29 	rcall	8000a808 <__lshift>
80009bba:	04 9b       	mov	r11,r2
80009bbc:	18 93       	mov	r3,r12
80009bbe:	e0 a0 05 02 	rcall	8000a5c2 <__mcmp>
80009bc2:	e0 89 00 12 	brgt	80009be6 <_dtoa_r+0xb62>
80009bc6:	c1 b1       	brne	80009bfc <_dtoa_r+0xb78>
80009bc8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009bcc:	c0 d1       	brne	80009be6 <_dtoa_r+0xb62>
80009bce:	c1 78       	rjmp	80009bfc <_dtoa_r+0xb78>
80009bd0:	40 89       	lddsp	r9,sp[0x20]
80009bd2:	12 38       	cp.w	r8,r9
80009bd4:	c0 30       	breq	80009bda <_dtoa_r+0xb56>
80009bd6:	10 95       	mov	r5,r8
80009bd8:	c0 88       	rjmp	80009be8 <_dtoa_r+0xb64>
80009bda:	2f f6       	sub	r6,-1
80009bdc:	50 66       	stdsp	sp[0x18],r6
80009bde:	33 18       	mov	r8,49
80009be0:	40 8c       	lddsp	r12,sp[0x20]
80009be2:	b8 88       	st.b	r12[0x0],r8
80009be4:	c1 38       	rjmp	80009c0a <_dtoa_r+0xb86>
80009be6:	33 9a       	mov	r10,57
80009be8:	0a 98       	mov	r8,r5
80009bea:	11 79       	ld.ub	r9,--r8
80009bec:	f4 09 18 00 	cp.b	r9,r10
80009bf0:	cf 00       	breq	80009bd0 <_dtoa_r+0xb4c>
80009bf2:	2f f9       	sub	r9,-1
80009bf4:	b0 89       	st.b	r8[0x0],r9
80009bf6:	c0 98       	rjmp	80009c08 <_dtoa_r+0xb84>
80009bf8:	10 95       	mov	r5,r8
80009bfa:	c0 28       	rjmp	80009bfe <_dtoa_r+0xb7a>
80009bfc:	33 09       	mov	r9,48
80009bfe:	0a 98       	mov	r8,r5
80009c00:	11 7a       	ld.ub	r10,--r8
80009c02:	f2 0a 18 00 	cp.b	r10,r9
80009c06:	cf 90       	breq	80009bf8 <_dtoa_r+0xb74>
80009c08:	50 66       	stdsp	sp[0x18],r6
80009c0a:	04 9b       	mov	r11,r2
80009c0c:	0e 9c       	mov	r12,r7
80009c0e:	e0 a0 04 f3 	rcall	8000a5f4 <_Bfree>
80009c12:	58 04       	cp.w	r4,0
80009c14:	c1 20       	breq	80009c38 <_dtoa_r+0xbb4>
80009c16:	40 4b       	lddsp	r11,sp[0x10]
80009c18:	08 3b       	cp.w	r11,r4
80009c1a:	5f 19       	srne	r9
80009c1c:	58 0b       	cp.w	r11,0
80009c1e:	5f 18       	srne	r8
80009c20:	f3 e8 00 08 	and	r8,r9,r8
80009c24:	c0 40       	breq	80009c2c <_dtoa_r+0xba8>
80009c26:	0e 9c       	mov	r12,r7
80009c28:	e0 a0 04 e6 	rcall	8000a5f4 <_Bfree>
80009c2c:	08 9b       	mov	r11,r4
80009c2e:	0e 9c       	mov	r12,r7
80009c30:	e0 a0 04 e2 	rcall	8000a5f4 <_Bfree>
80009c34:	c0 28       	rjmp	80009c38 <_dtoa_r+0xbb4>
80009c36:	50 66       	stdsp	sp[0x18],r6
80009c38:	0e 9c       	mov	r12,r7
80009c3a:	06 9b       	mov	r11,r3
80009c3c:	e0 a0 04 dc 	rcall	8000a5f4 <_Bfree>
80009c40:	30 08       	mov	r8,0
80009c42:	aa 88       	st.b	r5[0x0],r8
80009c44:	40 68       	lddsp	r8,sp[0x18]
80009c46:	41 5a       	lddsp	r10,sp[0x54]
80009c48:	2f f8       	sub	r8,-1
80009c4a:	41 29       	lddsp	r9,sp[0x48]
80009c4c:	95 08       	st.w	r10[0x0],r8
80009c4e:	40 8c       	lddsp	r12,sp[0x20]
80009c50:	58 09       	cp.w	r9,0
80009c52:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009c56:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009c5a:	2e 6d       	sub	sp,-104
80009c5c:	d8 32       	popm	r0-r7,pc
80009c5e:	d7 03       	nop

80009c60 <__errno>:
80009c60:	e0 68 0a 40 	mov	r8,2624
80009c64:	70 0c       	ld.w	r12,r8[0x0]
80009c66:	2f 4c       	sub	r12,-12
80009c68:	5e fc       	retal	r12
80009c6a:	d7 03       	nop

80009c6c <_fflush_r>:
80009c6c:	d4 21       	pushm	r4-r7,lr
80009c6e:	16 97       	mov	r7,r11
80009c70:	18 96       	mov	r6,r12
80009c72:	76 48       	ld.w	r8,r11[0x10]
80009c74:	58 08       	cp.w	r8,0
80009c76:	c7 f0       	breq	80009d74 <_fflush_r+0x108>
80009c78:	58 0c       	cp.w	r12,0
80009c7a:	c0 50       	breq	80009c84 <_fflush_r+0x18>
80009c7c:	78 68       	ld.w	r8,r12[0x18]
80009c7e:	58 08       	cp.w	r8,0
80009c80:	c0 21       	brne	80009c84 <_fflush_r+0x18>
80009c82:	cc dc       	rcall	80009e1c <__sinit>
80009c84:	fe c8 ce f4 	sub	r8,pc,-12556
80009c88:	10 37       	cp.w	r7,r8
80009c8a:	c0 31       	brne	80009c90 <_fflush_r+0x24>
80009c8c:	6c 07       	ld.w	r7,r6[0x0]
80009c8e:	c0 c8       	rjmp	80009ca6 <_fflush_r+0x3a>
80009c90:	fe c8 ce e0 	sub	r8,pc,-12576
80009c94:	10 37       	cp.w	r7,r8
80009c96:	c0 31       	brne	80009c9c <_fflush_r+0x30>
80009c98:	6c 17       	ld.w	r7,r6[0x4]
80009c9a:	c0 68       	rjmp	80009ca6 <_fflush_r+0x3a>
80009c9c:	fe c8 ce cc 	sub	r8,pc,-12596
80009ca0:	10 37       	cp.w	r7,r8
80009ca2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009ca6:	8e 6a       	ld.sh	r10,r7[0xc]
80009ca8:	14 98       	mov	r8,r10
80009caa:	ed ba 00 03 	bld	r10,0x3
80009cae:	c4 20       	breq	80009d32 <_fflush_r+0xc6>
80009cb0:	ab ba       	sbr	r10,0xb
80009cb2:	ae 6a       	st.h	r7[0xc],r10
80009cb4:	6e 18       	ld.w	r8,r7[0x4]
80009cb6:	58 08       	cp.w	r8,0
80009cb8:	e0 89 00 06 	brgt	80009cc4 <_fflush_r+0x58>
80009cbc:	6f 08       	ld.w	r8,r7[0x40]
80009cbe:	58 08       	cp.w	r8,0
80009cc0:	e0 8a 00 5a 	brle	80009d74 <_fflush_r+0x108>
80009cc4:	6e b8       	ld.w	r8,r7[0x2c]
80009cc6:	58 08       	cp.w	r8,0
80009cc8:	c5 60       	breq	80009d74 <_fflush_r+0x108>
80009cca:	e2 1a 10 00 	andl	r10,0x1000,COH
80009cce:	c0 30       	breq	80009cd4 <_fflush_r+0x68>
80009cd0:	6f 55       	ld.w	r5,r7[0x54]
80009cd2:	c0 f8       	rjmp	80009cf0 <_fflush_r+0x84>
80009cd4:	30 19       	mov	r9,1
80009cd6:	6e 8b       	ld.w	r11,r7[0x20]
80009cd8:	0c 9c       	mov	r12,r6
80009cda:	5d 18       	icall	r8
80009cdc:	18 95       	mov	r5,r12
80009cde:	5b fc       	cp.w	r12,-1
80009ce0:	c0 81       	brne	80009cf0 <_fflush_r+0x84>
80009ce2:	6c 38       	ld.w	r8,r6[0xc]
80009ce4:	59 d8       	cp.w	r8,29
80009ce6:	c4 70       	breq	80009d74 <_fflush_r+0x108>
80009ce8:	8e 68       	ld.sh	r8,r7[0xc]
80009cea:	a7 a8       	sbr	r8,0x6
80009cec:	ae 68       	st.h	r7[0xc],r8
80009cee:	d8 22       	popm	r4-r7,pc
80009cf0:	8e 68       	ld.sh	r8,r7[0xc]
80009cf2:	ed b8 00 02 	bld	r8,0x2
80009cf6:	c0 91       	brne	80009d08 <_fflush_r+0x9c>
80009cf8:	6e 18       	ld.w	r8,r7[0x4]
80009cfa:	10 15       	sub	r5,r8
80009cfc:	6e d8       	ld.w	r8,r7[0x34]
80009cfe:	58 08       	cp.w	r8,0
80009d00:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009d04:	eb d8 e1 15 	subne	r5,r5,r8
80009d08:	6e b8       	ld.w	r8,r7[0x2c]
80009d0a:	0c 9c       	mov	r12,r6
80009d0c:	30 09       	mov	r9,0
80009d0e:	0a 9a       	mov	r10,r5
80009d10:	6e 8b       	ld.w	r11,r7[0x20]
80009d12:	5d 18       	icall	r8
80009d14:	8e 68       	ld.sh	r8,r7[0xc]
80009d16:	0a 3c       	cp.w	r12,r5
80009d18:	c2 61       	brne	80009d64 <_fflush_r+0xf8>
80009d1a:	ab d8       	cbr	r8,0xb
80009d1c:	30 0c       	mov	r12,0
80009d1e:	6e 49       	ld.w	r9,r7[0x10]
80009d20:	ae 68       	st.h	r7[0xc],r8
80009d22:	8f 1c       	st.w	r7[0x4],r12
80009d24:	8f 09       	st.w	r7[0x0],r9
80009d26:	ed b8 00 0c 	bld	r8,0xc
80009d2a:	c2 51       	brne	80009d74 <_fflush_r+0x108>
80009d2c:	ef 45 00 54 	st.w	r7[84],r5
80009d30:	d8 22       	popm	r4-r7,pc
80009d32:	6e 45       	ld.w	r5,r7[0x10]
80009d34:	58 05       	cp.w	r5,0
80009d36:	c1 f0       	breq	80009d74 <_fflush_r+0x108>
80009d38:	6e 04       	ld.w	r4,r7[0x0]
80009d3a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009d3e:	8f 05       	st.w	r7[0x0],r5
80009d40:	f9 b8 01 00 	movne	r8,0
80009d44:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009d48:	0a 14       	sub	r4,r5
80009d4a:	8f 28       	st.w	r7[0x8],r8
80009d4c:	c1 18       	rjmp	80009d6e <_fflush_r+0x102>
80009d4e:	08 99       	mov	r9,r4
80009d50:	0a 9a       	mov	r10,r5
80009d52:	6e a8       	ld.w	r8,r7[0x28]
80009d54:	6e 8b       	ld.w	r11,r7[0x20]
80009d56:	0c 9c       	mov	r12,r6
80009d58:	5d 18       	icall	r8
80009d5a:	18 14       	sub	r4,r12
80009d5c:	58 0c       	cp.w	r12,0
80009d5e:	e0 89 00 07 	brgt	80009d6c <_fflush_r+0x100>
80009d62:	8e 68       	ld.sh	r8,r7[0xc]
80009d64:	a7 a8       	sbr	r8,0x6
80009d66:	3f fc       	mov	r12,-1
80009d68:	ae 68       	st.h	r7[0xc],r8
80009d6a:	d8 22       	popm	r4-r7,pc
80009d6c:	18 05       	add	r5,r12
80009d6e:	58 04       	cp.w	r4,0
80009d70:	fe 99 ff ef 	brgt	80009d4e <_fflush_r+0xe2>
80009d74:	d8 2a       	popm	r4-r7,pc,r12=0
80009d76:	d7 03       	nop

80009d78 <__sfp_lock_acquire>:
80009d78:	5e fc       	retal	r12

80009d7a <__sfp_lock_release>:
80009d7a:	5e fc       	retal	r12

80009d7c <_cleanup_r>:
80009d7c:	d4 01       	pushm	lr
80009d7e:	fe cb f0 c6 	sub	r11,pc,-3898
80009d82:	e0 a0 02 f7 	rcall	8000a370 <_fwalk>
80009d86:	d8 02       	popm	pc

80009d88 <__sfmoreglue>:
80009d88:	d4 21       	pushm	r4-r7,lr
80009d8a:	16 95       	mov	r5,r11
80009d8c:	f6 06 10 5c 	mul	r6,r11,92
80009d90:	ec cb ff f4 	sub	r11,r6,-12
80009d94:	fe b0 e2 7c 	rcall	8000628c <_malloc_r>
80009d98:	18 97       	mov	r7,r12
80009d9a:	c0 90       	breq	80009dac <__sfmoreglue+0x24>
80009d9c:	99 15       	st.w	r12[0x4],r5
80009d9e:	30 0b       	mov	r11,0
80009da0:	2f 4c       	sub	r12,-12
80009da2:	0c 9a       	mov	r10,r6
80009da4:	8f 2c       	st.w	r7[0x8],r12
80009da6:	8f 0b       	st.w	r7[0x0],r11
80009da8:	fe b0 e5 32 	rcall	8000680c <memset>
80009dac:	0e 9c       	mov	r12,r7
80009dae:	d8 22       	popm	r4-r7,pc

80009db0 <__sfp>:
80009db0:	d4 21       	pushm	r4-r7,lr
80009db2:	fe c8 cf be 	sub	r8,pc,-12354
80009db6:	18 96       	mov	r6,r12
80009db8:	70 07       	ld.w	r7,r8[0x0]
80009dba:	6e 68       	ld.w	r8,r7[0x18]
80009dbc:	58 08       	cp.w	r8,0
80009dbe:	c0 31       	brne	80009dc4 <__sfp+0x14>
80009dc0:	0e 9c       	mov	r12,r7
80009dc2:	c2 dc       	rcall	80009e1c <__sinit>
80009dc4:	ee c7 ff 28 	sub	r7,r7,-216
80009dc8:	30 05       	mov	r5,0
80009dca:	6e 2c       	ld.w	r12,r7[0x8]
80009dcc:	6e 18       	ld.w	r8,r7[0x4]
80009dce:	c0 68       	rjmp	80009dda <__sfp+0x2a>
80009dd0:	98 69       	ld.sh	r9,r12[0xc]
80009dd2:	ea 09 19 00 	cp.h	r9,r5
80009dd6:	c1 10       	breq	80009df8 <__sfp+0x48>
80009dd8:	2a 4c       	sub	r12,-92
80009dda:	20 18       	sub	r8,1
80009ddc:	cf a7       	brpl	80009dd0 <__sfp+0x20>
80009dde:	6e 08       	ld.w	r8,r7[0x0]
80009de0:	58 08       	cp.w	r8,0
80009de2:	c0 61       	brne	80009dee <__sfp+0x3e>
80009de4:	30 4b       	mov	r11,4
80009de6:	0c 9c       	mov	r12,r6
80009de8:	cd 0f       	rcall	80009d88 <__sfmoreglue>
80009dea:	8f 0c       	st.w	r7[0x0],r12
80009dec:	c0 30       	breq	80009df2 <__sfp+0x42>
80009dee:	6e 07       	ld.w	r7,r7[0x0]
80009df0:	ce db       	rjmp	80009dca <__sfp+0x1a>
80009df2:	30 c8       	mov	r8,12
80009df4:	8d 38       	st.w	r6[0xc],r8
80009df6:	d8 22       	popm	r4-r7,pc
80009df8:	30 08       	mov	r8,0
80009dfa:	f9 48 00 4c 	st.w	r12[76],r8
80009dfe:	99 08       	st.w	r12[0x0],r8
80009e00:	99 28       	st.w	r12[0x8],r8
80009e02:	99 18       	st.w	r12[0x4],r8
80009e04:	99 48       	st.w	r12[0x10],r8
80009e06:	99 58       	st.w	r12[0x14],r8
80009e08:	99 68       	st.w	r12[0x18],r8
80009e0a:	99 d8       	st.w	r12[0x34],r8
80009e0c:	99 e8       	st.w	r12[0x38],r8
80009e0e:	f9 48 00 48 	st.w	r12[72],r8
80009e12:	3f f8       	mov	r8,-1
80009e14:	b8 78       	st.h	r12[0xe],r8
80009e16:	30 18       	mov	r8,1
80009e18:	b8 68       	st.h	r12[0xc],r8
80009e1a:	d8 22       	popm	r4-r7,pc

80009e1c <__sinit>:
80009e1c:	d4 21       	pushm	r4-r7,lr
80009e1e:	18 96       	mov	r6,r12
80009e20:	78 67       	ld.w	r7,r12[0x18]
80009e22:	58 07       	cp.w	r7,0
80009e24:	c4 91       	brne	80009eb6 <__sinit+0x9a>
80009e26:	fe c8 00 aa 	sub	r8,pc,170
80009e2a:	30 15       	mov	r5,1
80009e2c:	99 a8       	st.w	r12[0x28],r8
80009e2e:	f9 47 00 d8 	st.w	r12[216],r7
80009e32:	f9 47 00 dc 	st.w	r12[220],r7
80009e36:	f9 47 00 e0 	st.w	r12[224],r7
80009e3a:	99 65       	st.w	r12[0x18],r5
80009e3c:	cb af       	rcall	80009db0 <__sfp>
80009e3e:	8d 0c       	st.w	r6[0x0],r12
80009e40:	0c 9c       	mov	r12,r6
80009e42:	cb 7f       	rcall	80009db0 <__sfp>
80009e44:	8d 1c       	st.w	r6[0x4],r12
80009e46:	0c 9c       	mov	r12,r6
80009e48:	cb 4f       	rcall	80009db0 <__sfp>
80009e4a:	6c 09       	ld.w	r9,r6[0x0]
80009e4c:	30 48       	mov	r8,4
80009e4e:	93 07       	st.w	r9[0x0],r7
80009e50:	b2 68       	st.h	r9[0xc],r8
80009e52:	93 17       	st.w	r9[0x4],r7
80009e54:	93 27       	st.w	r9[0x8],r7
80009e56:	6c 18       	ld.w	r8,r6[0x4]
80009e58:	b2 77       	st.h	r9[0xe],r7
80009e5a:	93 47       	st.w	r9[0x10],r7
80009e5c:	93 57       	st.w	r9[0x14],r7
80009e5e:	93 67       	st.w	r9[0x18],r7
80009e60:	93 89       	st.w	r9[0x20],r9
80009e62:	91 07       	st.w	r8[0x0],r7
80009e64:	91 17       	st.w	r8[0x4],r7
80009e66:	91 27       	st.w	r8[0x8],r7
80009e68:	fe ce f3 24 	sub	lr,pc,-3292
80009e6c:	fe cb f3 54 	sub	r11,pc,-3244
80009e70:	93 9e       	st.w	r9[0x24],lr
80009e72:	93 ab       	st.w	r9[0x28],r11
80009e74:	fe ca f3 7c 	sub	r10,pc,-3204
80009e78:	fe c4 f3 88 	sub	r4,pc,-3192
80009e7c:	93 ba       	st.w	r9[0x2c],r10
80009e7e:	93 c4       	st.w	r9[0x30],r4
80009e80:	30 99       	mov	r9,9
80009e82:	b0 69       	st.h	r8[0xc],r9
80009e84:	b0 75       	st.h	r8[0xe],r5
80009e86:	91 c4       	st.w	r8[0x30],r4
80009e88:	91 47       	st.w	r8[0x10],r7
80009e8a:	91 57       	st.w	r8[0x14],r7
80009e8c:	91 67       	st.w	r8[0x18],r7
80009e8e:	91 88       	st.w	r8[0x20],r8
80009e90:	91 9e       	st.w	r8[0x24],lr
80009e92:	91 ab       	st.w	r8[0x28],r11
80009e94:	91 ba       	st.w	r8[0x2c],r10
80009e96:	8d 2c       	st.w	r6[0x8],r12
80009e98:	31 28       	mov	r8,18
80009e9a:	99 07       	st.w	r12[0x0],r7
80009e9c:	b8 68       	st.h	r12[0xc],r8
80009e9e:	99 17       	st.w	r12[0x4],r7
80009ea0:	99 27       	st.w	r12[0x8],r7
80009ea2:	30 28       	mov	r8,2
80009ea4:	b8 78       	st.h	r12[0xe],r8
80009ea6:	99 c4       	st.w	r12[0x30],r4
80009ea8:	99 67       	st.w	r12[0x18],r7
80009eaa:	99 9e       	st.w	r12[0x24],lr
80009eac:	99 ab       	st.w	r12[0x28],r11
80009eae:	99 ba       	st.w	r12[0x2c],r10
80009eb0:	99 47       	st.w	r12[0x10],r7
80009eb2:	99 57       	st.w	r12[0x14],r7
80009eb4:	99 8c       	st.w	r12[0x20],r12
80009eb6:	d8 22       	popm	r4-r7,pc

80009eb8 <_malloc_trim_r>:
80009eb8:	d4 21       	pushm	r4-r7,lr
80009eba:	16 95       	mov	r5,r11
80009ebc:	18 97       	mov	r7,r12
80009ebe:	fe b0 d7 77 	rcall	80004dac <__malloc_lock>
80009ec2:	e0 64 05 40 	mov	r4,1344
80009ec6:	68 28       	ld.w	r8,r4[0x8]
80009ec8:	70 16       	ld.w	r6,r8[0x4]
80009eca:	e0 16 ff fc 	andl	r6,0xfffc
80009ece:	ec c8 ff 91 	sub	r8,r6,-111
80009ed2:	f0 05 01 05 	sub	r5,r8,r5
80009ed6:	e0 15 ff 80 	andl	r5,0xff80
80009eda:	ea c5 00 80 	sub	r5,r5,128
80009ede:	e0 45 00 7f 	cp.w	r5,127
80009ee2:	e0 8a 00 25 	brle	80009f2c <_malloc_trim_r+0x74>
80009ee6:	30 0b       	mov	r11,0
80009ee8:	0e 9c       	mov	r12,r7
80009eea:	fe b0 e5 f9 	rcall	80006adc <_sbrk_r>
80009eee:	68 28       	ld.w	r8,r4[0x8]
80009ef0:	0c 08       	add	r8,r6
80009ef2:	10 3c       	cp.w	r12,r8
80009ef4:	c1 c1       	brne	80009f2c <_malloc_trim_r+0x74>
80009ef6:	ea 0b 11 00 	rsub	r11,r5,0
80009efa:	0e 9c       	mov	r12,r7
80009efc:	fe b0 e5 f0 	rcall	80006adc <_sbrk_r>
80009f00:	5b fc       	cp.w	r12,-1
80009f02:	c1 91       	brne	80009f34 <_malloc_trim_r+0x7c>
80009f04:	30 0b       	mov	r11,0
80009f06:	0e 9c       	mov	r12,r7
80009f08:	fe b0 e5 ea 	rcall	80006adc <_sbrk_r>
80009f0c:	68 28       	ld.w	r8,r4[0x8]
80009f0e:	f8 08 01 09 	sub	r9,r12,r8
80009f12:	58 f9       	cp.w	r9,15
80009f14:	e0 8a 00 0c 	brle	80009f2c <_malloc_trim_r+0x74>
80009f18:	a1 a9       	sbr	r9,0x0
80009f1a:	91 19       	st.w	r8[0x4],r9
80009f1c:	e0 68 09 4c 	mov	r8,2380
80009f20:	70 09       	ld.w	r9,r8[0x0]
80009f22:	e0 68 0d 58 	mov	r8,3416
80009f26:	f8 09 01 09 	sub	r9,r12,r9
80009f2a:	91 09       	st.w	r8[0x0],r9
80009f2c:	0e 9c       	mov	r12,r7
80009f2e:	fe b0 d7 45 	rcall	80004db8 <__malloc_unlock>
80009f32:	d8 2a       	popm	r4-r7,pc,r12=0
80009f34:	68 28       	ld.w	r8,r4[0x8]
80009f36:	0a 16       	sub	r6,r5
80009f38:	a1 a6       	sbr	r6,0x0
80009f3a:	91 16       	st.w	r8[0x4],r6
80009f3c:	e0 68 0d 58 	mov	r8,3416
80009f40:	70 09       	ld.w	r9,r8[0x0]
80009f42:	0a 19       	sub	r9,r5
80009f44:	0e 9c       	mov	r12,r7
80009f46:	91 09       	st.w	r8[0x0],r9
80009f48:	fe b0 d7 38 	rcall	80004db8 <__malloc_unlock>
80009f4c:	da 2a       	popm	r4-r7,pc,r12=1
80009f4e:	d7 03       	nop

80009f50 <_free_r>:
80009f50:	d4 21       	pushm	r4-r7,lr
80009f52:	16 96       	mov	r6,r11
80009f54:	18 97       	mov	r7,r12
80009f56:	58 0b       	cp.w	r11,0
80009f58:	e0 80 00 c0 	breq	8000a0d8 <_free_r+0x188>
80009f5c:	fe b0 d7 28 	rcall	80004dac <__malloc_lock>
80009f60:	20 86       	sub	r6,8
80009f62:	e0 6a 05 40 	mov	r10,1344
80009f66:	6c 18       	ld.w	r8,r6[0x4]
80009f68:	74 2e       	ld.w	lr,r10[0x8]
80009f6a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009f6e:	a1 c8       	cbr	r8,0x0
80009f70:	ec 08 00 09 	add	r9,r6,r8
80009f74:	72 1b       	ld.w	r11,r9[0x4]
80009f76:	e0 1b ff fc 	andl	r11,0xfffc
80009f7a:	1c 39       	cp.w	r9,lr
80009f7c:	c1 e1       	brne	80009fb8 <_free_r+0x68>
80009f7e:	f6 08 00 08 	add	r8,r11,r8
80009f82:	58 0c       	cp.w	r12,0
80009f84:	c0 81       	brne	80009f94 <_free_r+0x44>
80009f86:	6c 09       	ld.w	r9,r6[0x0]
80009f88:	12 16       	sub	r6,r9
80009f8a:	12 08       	add	r8,r9
80009f8c:	6c 3b       	ld.w	r11,r6[0xc]
80009f8e:	6c 29       	ld.w	r9,r6[0x8]
80009f90:	97 29       	st.w	r11[0x8],r9
80009f92:	93 3b       	st.w	r9[0xc],r11
80009f94:	10 99       	mov	r9,r8
80009f96:	95 26       	st.w	r10[0x8],r6
80009f98:	a1 a9       	sbr	r9,0x0
80009f9a:	8d 19       	st.w	r6[0x4],r9
80009f9c:	e0 69 09 48 	mov	r9,2376
80009fa0:	72 09       	ld.w	r9,r9[0x0]
80009fa2:	12 38       	cp.w	r8,r9
80009fa4:	c0 63       	brcs	80009fb0 <_free_r+0x60>
80009fa6:	e0 68 0d 54 	mov	r8,3412
80009faa:	0e 9c       	mov	r12,r7
80009fac:	70 0b       	ld.w	r11,r8[0x0]
80009fae:	c8 5f       	rcall	80009eb8 <_malloc_trim_r>
80009fb0:	0e 9c       	mov	r12,r7
80009fb2:	fe b0 d7 03 	rcall	80004db8 <__malloc_unlock>
80009fb6:	d8 22       	popm	r4-r7,pc
80009fb8:	93 1b       	st.w	r9[0x4],r11
80009fba:	58 0c       	cp.w	r12,0
80009fbc:	c0 30       	breq	80009fc2 <_free_r+0x72>
80009fbe:	30 0c       	mov	r12,0
80009fc0:	c1 08       	rjmp	80009fe0 <_free_r+0x90>
80009fc2:	6c 0e       	ld.w	lr,r6[0x0]
80009fc4:	f4 c5 ff f8 	sub	r5,r10,-8
80009fc8:	1c 16       	sub	r6,lr
80009fca:	1c 08       	add	r8,lr
80009fcc:	6c 2e       	ld.w	lr,r6[0x8]
80009fce:	0a 3e       	cp.w	lr,r5
80009fd0:	f9 bc 00 01 	moveq	r12,1
80009fd4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009fd8:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009fdc:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009fe0:	f2 0b 00 0e 	add	lr,r9,r11
80009fe4:	7c 1e       	ld.w	lr,lr[0x4]
80009fe6:	ed be 00 00 	bld	lr,0x0
80009fea:	c1 40       	breq	8000a012 <_free_r+0xc2>
80009fec:	16 08       	add	r8,r11
80009fee:	58 0c       	cp.w	r12,0
80009ff0:	c0 d1       	brne	8000a00a <_free_r+0xba>
80009ff2:	e0 6e 05 40 	mov	lr,1344
80009ff6:	72 2b       	ld.w	r11,r9[0x8]
80009ff8:	2f 8e       	sub	lr,-8
80009ffa:	1c 3b       	cp.w	r11,lr
80009ffc:	c0 71       	brne	8000a00a <_free_r+0xba>
80009ffe:	97 36       	st.w	r11[0xc],r6
8000a000:	97 26       	st.w	r11[0x8],r6
8000a002:	8d 2b       	st.w	r6[0x8],r11
8000a004:	8d 3b       	st.w	r6[0xc],r11
8000a006:	30 1c       	mov	r12,1
8000a008:	c0 58       	rjmp	8000a012 <_free_r+0xc2>
8000a00a:	72 2b       	ld.w	r11,r9[0x8]
8000a00c:	72 39       	ld.w	r9,r9[0xc]
8000a00e:	93 2b       	st.w	r9[0x8],r11
8000a010:	97 39       	st.w	r11[0xc],r9
8000a012:	10 99       	mov	r9,r8
8000a014:	ec 08 09 08 	st.w	r6[r8],r8
8000a018:	a1 a9       	sbr	r9,0x0
8000a01a:	8d 19       	st.w	r6[0x4],r9
8000a01c:	58 0c       	cp.w	r12,0
8000a01e:	c5 a1       	brne	8000a0d2 <_free_r+0x182>
8000a020:	e0 48 01 ff 	cp.w	r8,511
8000a024:	e0 8b 00 13 	brhi	8000a04a <_free_r+0xfa>
8000a028:	a3 98       	lsr	r8,0x3
8000a02a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a02e:	72 2b       	ld.w	r11,r9[0x8]
8000a030:	8d 39       	st.w	r6[0xc],r9
8000a032:	8d 2b       	st.w	r6[0x8],r11
8000a034:	97 36       	st.w	r11[0xc],r6
8000a036:	93 26       	st.w	r9[0x8],r6
8000a038:	a3 48       	asr	r8,0x2
8000a03a:	74 19       	ld.w	r9,r10[0x4]
8000a03c:	30 1b       	mov	r11,1
8000a03e:	f6 08 09 48 	lsl	r8,r11,r8
8000a042:	f3 e8 10 08 	or	r8,r9,r8
8000a046:	95 18       	st.w	r10[0x4],r8
8000a048:	c4 58       	rjmp	8000a0d2 <_free_r+0x182>
8000a04a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a04e:	58 4b       	cp.w	r11,4
8000a050:	e0 8b 00 06 	brhi	8000a05c <_free_r+0x10c>
8000a054:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a058:	2c 8b       	sub	r11,-56
8000a05a:	c2 08       	rjmp	8000a09a <_free_r+0x14a>
8000a05c:	59 4b       	cp.w	r11,20
8000a05e:	e0 8b 00 04 	brhi	8000a066 <_free_r+0x116>
8000a062:	2a 5b       	sub	r11,-91
8000a064:	c1 b8       	rjmp	8000a09a <_free_r+0x14a>
8000a066:	e0 4b 00 54 	cp.w	r11,84
8000a06a:	e0 8b 00 06 	brhi	8000a076 <_free_r+0x126>
8000a06e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a072:	29 2b       	sub	r11,-110
8000a074:	c1 38       	rjmp	8000a09a <_free_r+0x14a>
8000a076:	e0 4b 01 54 	cp.w	r11,340
8000a07a:	e0 8b 00 06 	brhi	8000a086 <_free_r+0x136>
8000a07e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a082:	28 9b       	sub	r11,-119
8000a084:	c0 b8       	rjmp	8000a09a <_free_r+0x14a>
8000a086:	e0 4b 05 54 	cp.w	r11,1364
8000a08a:	e0 88 00 05 	brls	8000a094 <_free_r+0x144>
8000a08e:	37 eb       	mov	r11,126
8000a090:	c0 58       	rjmp	8000a09a <_free_r+0x14a>
8000a092:	d7 03       	nop
8000a094:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a098:	28 4b       	sub	r11,-124
8000a09a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a09e:	78 29       	ld.w	r9,r12[0x8]
8000a0a0:	18 39       	cp.w	r9,r12
8000a0a2:	c0 e1       	brne	8000a0be <_free_r+0x16e>
8000a0a4:	74 18       	ld.w	r8,r10[0x4]
8000a0a6:	a3 4b       	asr	r11,0x2
8000a0a8:	30 1c       	mov	r12,1
8000a0aa:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a0ae:	f1 eb 10 0b 	or	r11,r8,r11
8000a0b2:	12 98       	mov	r8,r9
8000a0b4:	95 1b       	st.w	r10[0x4],r11
8000a0b6:	c0 a8       	rjmp	8000a0ca <_free_r+0x17a>
8000a0b8:	72 29       	ld.w	r9,r9[0x8]
8000a0ba:	18 39       	cp.w	r9,r12
8000a0bc:	c0 60       	breq	8000a0c8 <_free_r+0x178>
8000a0be:	72 1a       	ld.w	r10,r9[0x4]
8000a0c0:	e0 1a ff fc 	andl	r10,0xfffc
8000a0c4:	14 38       	cp.w	r8,r10
8000a0c6:	cf 93       	brcs	8000a0b8 <_free_r+0x168>
8000a0c8:	72 38       	ld.w	r8,r9[0xc]
8000a0ca:	8d 38       	st.w	r6[0xc],r8
8000a0cc:	8d 29       	st.w	r6[0x8],r9
8000a0ce:	93 36       	st.w	r9[0xc],r6
8000a0d0:	91 26       	st.w	r8[0x8],r6
8000a0d2:	0e 9c       	mov	r12,r7
8000a0d4:	fe b0 d6 72 	rcall	80004db8 <__malloc_unlock>
8000a0d8:	d8 22       	popm	r4-r7,pc
8000a0da:	d7 03       	nop

8000a0dc <__sfvwrite_r>:
8000a0dc:	d4 31       	pushm	r0-r7,lr
8000a0de:	20 3d       	sub	sp,12
8000a0e0:	14 94       	mov	r4,r10
8000a0e2:	18 95       	mov	r5,r12
8000a0e4:	16 97       	mov	r7,r11
8000a0e6:	74 28       	ld.w	r8,r10[0x8]
8000a0e8:	58 08       	cp.w	r8,0
8000a0ea:	e0 80 01 40 	breq	8000a36a <__sfvwrite_r+0x28e>
8000a0ee:	96 68       	ld.sh	r8,r11[0xc]
8000a0f0:	ed b8 00 03 	bld	r8,0x3
8000a0f4:	c0 41       	brne	8000a0fc <__sfvwrite_r+0x20>
8000a0f6:	76 48       	ld.w	r8,r11[0x10]
8000a0f8:	58 08       	cp.w	r8,0
8000a0fa:	c0 c1       	brne	8000a112 <__sfvwrite_r+0x36>
8000a0fc:	0e 9b       	mov	r11,r7
8000a0fe:	0a 9c       	mov	r12,r5
8000a100:	fe b0 f6 c4 	rcall	80008e88 <__swsetup_r>
8000a104:	c0 70       	breq	8000a112 <__sfvwrite_r+0x36>
8000a106:	8e 68       	ld.sh	r8,r7[0xc]
8000a108:	a7 a8       	sbr	r8,0x6
8000a10a:	ae 68       	st.h	r7[0xc],r8
8000a10c:	30 98       	mov	r8,9
8000a10e:	8b 38       	st.w	r5[0xc],r8
8000a110:	c2 b9       	rjmp	8000a366 <__sfvwrite_r+0x28a>
8000a112:	8e 63       	ld.sh	r3,r7[0xc]
8000a114:	68 00       	ld.w	r0,r4[0x0]
8000a116:	06 96       	mov	r6,r3
8000a118:	e2 16 00 02 	andl	r6,0x2,COH
8000a11c:	c2 10       	breq	8000a15e <__sfvwrite_r+0x82>
8000a11e:	30 03       	mov	r3,0
8000a120:	e0 62 04 00 	mov	r2,1024
8000a124:	06 96       	mov	r6,r3
8000a126:	c0 48       	rjmp	8000a12e <__sfvwrite_r+0x52>
8000a128:	60 03       	ld.w	r3,r0[0x0]
8000a12a:	60 16       	ld.w	r6,r0[0x4]
8000a12c:	2f 80       	sub	r0,-8
8000a12e:	58 06       	cp.w	r6,0
8000a130:	cf c0       	breq	8000a128 <__sfvwrite_r+0x4c>
8000a132:	e0 46 04 00 	cp.w	r6,1024
8000a136:	ec 09 17 80 	movls	r9,r6
8000a13a:	e4 09 17 b0 	movhi	r9,r2
8000a13e:	06 9a       	mov	r10,r3
8000a140:	6e a8       	ld.w	r8,r7[0x28]
8000a142:	6e 8b       	ld.w	r11,r7[0x20]
8000a144:	0a 9c       	mov	r12,r5
8000a146:	5d 18       	icall	r8
8000a148:	18 16       	sub	r6,r12
8000a14a:	58 0c       	cp.w	r12,0
8000a14c:	e0 8a 01 0a 	brle	8000a360 <__sfvwrite_r+0x284>
8000a150:	68 28       	ld.w	r8,r4[0x8]
8000a152:	18 18       	sub	r8,r12
8000a154:	89 28       	st.w	r4[0x8],r8
8000a156:	e0 80 01 0a 	breq	8000a36a <__sfvwrite_r+0x28e>
8000a15a:	18 03       	add	r3,r12
8000a15c:	ce 9b       	rjmp	8000a12e <__sfvwrite_r+0x52>
8000a15e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a162:	c0 70       	breq	8000a170 <__sfvwrite_r+0x94>
8000a164:	50 06       	stdsp	sp[0x0],r6
8000a166:	0c 93       	mov	r3,r6
8000a168:	0c 91       	mov	r1,r6
8000a16a:	50 15       	stdsp	sp[0x4],r5
8000a16c:	08 92       	mov	r2,r4
8000a16e:	c9 c8       	rjmp	8000a2a6 <__sfvwrite_r+0x1ca>
8000a170:	06 96       	mov	r6,r3
8000a172:	08 91       	mov	r1,r4
8000a174:	c0 48       	rjmp	8000a17c <__sfvwrite_r+0xa0>
8000a176:	60 03       	ld.w	r3,r0[0x0]
8000a178:	60 16       	ld.w	r6,r0[0x4]
8000a17a:	2f 80       	sub	r0,-8
8000a17c:	58 06       	cp.w	r6,0
8000a17e:	cf c0       	breq	8000a176 <__sfvwrite_r+0x9a>
8000a180:	8e 68       	ld.sh	r8,r7[0xc]
8000a182:	6e 24       	ld.w	r4,r7[0x8]
8000a184:	10 99       	mov	r9,r8
8000a186:	e2 19 02 00 	andl	r9,0x200,COH
8000a18a:	c5 50       	breq	8000a234 <__sfvwrite_r+0x158>
8000a18c:	08 36       	cp.w	r6,r4
8000a18e:	c4 43       	brcs	8000a216 <__sfvwrite_r+0x13a>
8000a190:	10 99       	mov	r9,r8
8000a192:	e2 19 04 80 	andl	r9,0x480,COH
8000a196:	c4 00       	breq	8000a216 <__sfvwrite_r+0x13a>
8000a198:	6e 4b       	ld.w	r11,r7[0x10]
8000a19a:	6e 09       	ld.w	r9,r7[0x0]
8000a19c:	16 19       	sub	r9,r11
8000a19e:	50 09       	stdsp	sp[0x0],r9
8000a1a0:	6e 59       	ld.w	r9,r7[0x14]
8000a1a2:	10 9c       	mov	r12,r8
8000a1a4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a1a8:	30 28       	mov	r8,2
8000a1aa:	f4 08 0c 08 	divs	r8,r10,r8
8000a1ae:	fa e9 00 04 	st.d	sp[4],r8
8000a1b2:	10 94       	mov	r4,r8
8000a1b4:	40 09       	lddsp	r9,sp[0x0]
8000a1b6:	e2 1c 04 00 	andl	r12,0x400,COH
8000a1ba:	2f f9       	sub	r9,-1
8000a1bc:	0c 09       	add	r9,r6
8000a1be:	12 38       	cp.w	r8,r9
8000a1c0:	f2 04 17 30 	movlo	r4,r9
8000a1c4:	58 0c       	cp.w	r12,0
8000a1c6:	c1 10       	breq	8000a1e8 <__sfvwrite_r+0x10c>
8000a1c8:	08 9b       	mov	r11,r4
8000a1ca:	0a 9c       	mov	r12,r5
8000a1cc:	fe b0 e0 60 	rcall	8000628c <_malloc_r>
8000a1d0:	18 92       	mov	r2,r12
8000a1d2:	c1 40       	breq	8000a1fa <__sfvwrite_r+0x11e>
8000a1d4:	40 0a       	lddsp	r10,sp[0x0]
8000a1d6:	6e 4b       	ld.w	r11,r7[0x10]
8000a1d8:	fe b0 e2 76 	rcall	800066c4 <memcpy>
8000a1dc:	8e 68       	ld.sh	r8,r7[0xc]
8000a1de:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a1e2:	a7 b8       	sbr	r8,0x7
8000a1e4:	ae 68       	st.h	r7[0xc],r8
8000a1e6:	c0 d8       	rjmp	8000a200 <__sfvwrite_r+0x124>
8000a1e8:	08 9a       	mov	r10,r4
8000a1ea:	0a 9c       	mov	r12,r5
8000a1ec:	fe b0 e3 18 	rcall	8000681c <_realloc_r>
8000a1f0:	18 92       	mov	r2,r12
8000a1f2:	c0 71       	brne	8000a200 <__sfvwrite_r+0x124>
8000a1f4:	6e 4b       	ld.w	r11,r7[0x10]
8000a1f6:	0a 9c       	mov	r12,r5
8000a1f8:	ca ce       	rcall	80009f50 <_free_r>
8000a1fa:	30 c8       	mov	r8,12
8000a1fc:	8b 38       	st.w	r5[0xc],r8
8000a1fe:	cb 18       	rjmp	8000a360 <__sfvwrite_r+0x284>
8000a200:	40 0a       	lddsp	r10,sp[0x0]
8000a202:	40 09       	lddsp	r9,sp[0x0]
8000a204:	e8 0a 01 0a 	sub	r10,r4,r10
8000a208:	e4 09 00 08 	add	r8,r2,r9
8000a20c:	8f 54       	st.w	r7[0x14],r4
8000a20e:	8f 2a       	st.w	r7[0x8],r10
8000a210:	8f 08       	st.w	r7[0x0],r8
8000a212:	8f 42       	st.w	r7[0x10],r2
8000a214:	0c 94       	mov	r4,r6
8000a216:	08 36       	cp.w	r6,r4
8000a218:	ec 04 17 30 	movlo	r4,r6
8000a21c:	06 9b       	mov	r11,r3
8000a21e:	08 9a       	mov	r10,r4
8000a220:	6e 0c       	ld.w	r12,r7[0x0]
8000a222:	c3 ad       	rcall	8000a496 <memmove>
8000a224:	6e 08       	ld.w	r8,r7[0x0]
8000a226:	08 08       	add	r8,r4
8000a228:	8f 08       	st.w	r7[0x0],r8
8000a22a:	6e 28       	ld.w	r8,r7[0x8]
8000a22c:	08 18       	sub	r8,r4
8000a22e:	0c 94       	mov	r4,r6
8000a230:	8f 28       	st.w	r7[0x8],r8
8000a232:	c2 e8       	rjmp	8000a28e <__sfvwrite_r+0x1b2>
8000a234:	08 36       	cp.w	r6,r4
8000a236:	5f ba       	srhi	r10
8000a238:	6e 0c       	ld.w	r12,r7[0x0]
8000a23a:	6e 48       	ld.w	r8,r7[0x10]
8000a23c:	10 3c       	cp.w	r12,r8
8000a23e:	5f b8       	srhi	r8
8000a240:	f5 e8 00 08 	and	r8,r10,r8
8000a244:	f2 08 18 00 	cp.b	r8,r9
8000a248:	c0 d0       	breq	8000a262 <__sfvwrite_r+0x186>
8000a24a:	06 9b       	mov	r11,r3
8000a24c:	08 9a       	mov	r10,r4
8000a24e:	c2 4d       	rcall	8000a496 <memmove>
8000a250:	6e 08       	ld.w	r8,r7[0x0]
8000a252:	08 08       	add	r8,r4
8000a254:	0e 9b       	mov	r11,r7
8000a256:	8f 08       	st.w	r7[0x0],r8
8000a258:	0a 9c       	mov	r12,r5
8000a25a:	fe b0 fd 09 	rcall	80009c6c <_fflush_r>
8000a25e:	c1 80       	breq	8000a28e <__sfvwrite_r+0x1b2>
8000a260:	c8 08       	rjmp	8000a360 <__sfvwrite_r+0x284>
8000a262:	6e 59       	ld.w	r9,r7[0x14]
8000a264:	12 36       	cp.w	r6,r9
8000a266:	c0 a3       	brcs	8000a27a <__sfvwrite_r+0x19e>
8000a268:	6e a8       	ld.w	r8,r7[0x28]
8000a26a:	06 9a       	mov	r10,r3
8000a26c:	6e 8b       	ld.w	r11,r7[0x20]
8000a26e:	0a 9c       	mov	r12,r5
8000a270:	5d 18       	icall	r8
8000a272:	18 94       	mov	r4,r12
8000a274:	e0 89 00 0d 	brgt	8000a28e <__sfvwrite_r+0x1b2>
8000a278:	c7 48       	rjmp	8000a360 <__sfvwrite_r+0x284>
8000a27a:	0c 9a       	mov	r10,r6
8000a27c:	06 9b       	mov	r11,r3
8000a27e:	c0 cd       	rcall	8000a496 <memmove>
8000a280:	6e 08       	ld.w	r8,r7[0x0]
8000a282:	0c 08       	add	r8,r6
8000a284:	0c 94       	mov	r4,r6
8000a286:	8f 08       	st.w	r7[0x0],r8
8000a288:	6e 28       	ld.w	r8,r7[0x8]
8000a28a:	0c 18       	sub	r8,r6
8000a28c:	8f 28       	st.w	r7[0x8],r8
8000a28e:	62 28       	ld.w	r8,r1[0x8]
8000a290:	08 18       	sub	r8,r4
8000a292:	83 28       	st.w	r1[0x8],r8
8000a294:	c6 b0       	breq	8000a36a <__sfvwrite_r+0x28e>
8000a296:	08 16       	sub	r6,r4
8000a298:	08 03       	add	r3,r4
8000a29a:	c7 1b       	rjmp	8000a17c <__sfvwrite_r+0xa0>
8000a29c:	60 03       	ld.w	r3,r0[0x0]
8000a29e:	60 11       	ld.w	r1,r0[0x4]
8000a2a0:	30 08       	mov	r8,0
8000a2a2:	2f 80       	sub	r0,-8
8000a2a4:	50 08       	stdsp	sp[0x0],r8
8000a2a6:	58 01       	cp.w	r1,0
8000a2a8:	cf a0       	breq	8000a29c <__sfvwrite_r+0x1c0>
8000a2aa:	40 0a       	lddsp	r10,sp[0x0]
8000a2ac:	58 0a       	cp.w	r10,0
8000a2ae:	c1 41       	brne	8000a2d6 <__sfvwrite_r+0x1fa>
8000a2b0:	e2 c6 ff ff 	sub	r6,r1,-1
8000a2b4:	02 9a       	mov	r10,r1
8000a2b6:	30 ab       	mov	r11,10
8000a2b8:	06 9c       	mov	r12,r3
8000a2ba:	ce 3c       	rcall	8000a480 <memchr>
8000a2bc:	f8 c8 ff ff 	sub	r8,r12,-1
8000a2c0:	58 0c       	cp.w	r12,0
8000a2c2:	f1 d3 e1 16 	subne	r6,r8,r3
8000a2c6:	f9 b9 01 01 	movne	r9,1
8000a2ca:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a2ce:	f9 b8 00 01 	moveq	r8,1
8000a2d2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a2d6:	02 36       	cp.w	r6,r1
8000a2d8:	ec 04 17 80 	movls	r4,r6
8000a2dc:	e2 04 17 b0 	movhi	r4,r1
8000a2e0:	6e 59       	ld.w	r9,r7[0x14]
8000a2e2:	6e 25       	ld.w	r5,r7[0x8]
8000a2e4:	f2 05 00 05 	add	r5,r9,r5
8000a2e8:	0a 34       	cp.w	r4,r5
8000a2ea:	5f 9a       	srgt	r10
8000a2ec:	6e 0c       	ld.w	r12,r7[0x0]
8000a2ee:	6e 48       	ld.w	r8,r7[0x10]
8000a2f0:	10 3c       	cp.w	r12,r8
8000a2f2:	5f b8       	srhi	r8
8000a2f4:	f5 e8 00 08 	and	r8,r10,r8
8000a2f8:	30 0a       	mov	r10,0
8000a2fa:	f4 08 18 00 	cp.b	r8,r10
8000a2fe:	c0 d0       	breq	8000a318 <__sfvwrite_r+0x23c>
8000a300:	06 9b       	mov	r11,r3
8000a302:	0a 9a       	mov	r10,r5
8000a304:	cc 9c       	rcall	8000a496 <memmove>
8000a306:	6e 08       	ld.w	r8,r7[0x0]
8000a308:	0a 08       	add	r8,r5
8000a30a:	0e 9b       	mov	r11,r7
8000a30c:	8f 08       	st.w	r7[0x0],r8
8000a30e:	40 1c       	lddsp	r12,sp[0x4]
8000a310:	fe b0 fc ae 	rcall	80009c6c <_fflush_r>
8000a314:	c1 70       	breq	8000a342 <__sfvwrite_r+0x266>
8000a316:	c2 58       	rjmp	8000a360 <__sfvwrite_r+0x284>
8000a318:	12 34       	cp.w	r4,r9
8000a31a:	c0 a5       	brlt	8000a32e <__sfvwrite_r+0x252>
8000a31c:	6e a8       	ld.w	r8,r7[0x28]
8000a31e:	06 9a       	mov	r10,r3
8000a320:	6e 8b       	ld.w	r11,r7[0x20]
8000a322:	40 1c       	lddsp	r12,sp[0x4]
8000a324:	5d 18       	icall	r8
8000a326:	18 95       	mov	r5,r12
8000a328:	e0 89 00 0d 	brgt	8000a342 <__sfvwrite_r+0x266>
8000a32c:	c1 a8       	rjmp	8000a360 <__sfvwrite_r+0x284>
8000a32e:	08 9a       	mov	r10,r4
8000a330:	06 9b       	mov	r11,r3
8000a332:	cb 2c       	rcall	8000a496 <memmove>
8000a334:	6e 08       	ld.w	r8,r7[0x0]
8000a336:	08 08       	add	r8,r4
8000a338:	08 95       	mov	r5,r4
8000a33a:	8f 08       	st.w	r7[0x0],r8
8000a33c:	6e 28       	ld.w	r8,r7[0x8]
8000a33e:	08 18       	sub	r8,r4
8000a340:	8f 28       	st.w	r7[0x8],r8
8000a342:	0a 16       	sub	r6,r5
8000a344:	c0 71       	brne	8000a352 <__sfvwrite_r+0x276>
8000a346:	0e 9b       	mov	r11,r7
8000a348:	40 1c       	lddsp	r12,sp[0x4]
8000a34a:	fe b0 fc 91 	rcall	80009c6c <_fflush_r>
8000a34e:	c0 91       	brne	8000a360 <__sfvwrite_r+0x284>
8000a350:	50 06       	stdsp	sp[0x0],r6
8000a352:	64 28       	ld.w	r8,r2[0x8]
8000a354:	0a 18       	sub	r8,r5
8000a356:	85 28       	st.w	r2[0x8],r8
8000a358:	c0 90       	breq	8000a36a <__sfvwrite_r+0x28e>
8000a35a:	0a 11       	sub	r1,r5
8000a35c:	0a 03       	add	r3,r5
8000a35e:	ca 4b       	rjmp	8000a2a6 <__sfvwrite_r+0x1ca>
8000a360:	8e 68       	ld.sh	r8,r7[0xc]
8000a362:	a7 a8       	sbr	r8,0x6
8000a364:	ae 68       	st.h	r7[0xc],r8
8000a366:	3f fc       	mov	r12,-1
8000a368:	c0 28       	rjmp	8000a36c <__sfvwrite_r+0x290>
8000a36a:	30 0c       	mov	r12,0
8000a36c:	2f dd       	sub	sp,-12
8000a36e:	d8 32       	popm	r0-r7,pc

8000a370 <_fwalk>:
8000a370:	d4 31       	pushm	r0-r7,lr
8000a372:	30 05       	mov	r5,0
8000a374:	16 91       	mov	r1,r11
8000a376:	f8 c7 ff 28 	sub	r7,r12,-216
8000a37a:	0a 92       	mov	r2,r5
8000a37c:	fe b0 fc fe 	rcall	80009d78 <__sfp_lock_acquire>
8000a380:	3f f3       	mov	r3,-1
8000a382:	c1 68       	rjmp	8000a3ae <_fwalk+0x3e>
8000a384:	6e 26       	ld.w	r6,r7[0x8]
8000a386:	6e 14       	ld.w	r4,r7[0x4]
8000a388:	2f 46       	sub	r6,-12
8000a38a:	c0 c8       	rjmp	8000a3a2 <_fwalk+0x32>
8000a38c:	8c 08       	ld.sh	r8,r6[0x0]
8000a38e:	e4 08 19 00 	cp.h	r8,r2
8000a392:	c0 70       	breq	8000a3a0 <_fwalk+0x30>
8000a394:	8c 18       	ld.sh	r8,r6[0x2]
8000a396:	e6 08 19 00 	cp.h	r8,r3
8000a39a:	c0 30       	breq	8000a3a0 <_fwalk+0x30>
8000a39c:	5d 11       	icall	r1
8000a39e:	18 45       	or	r5,r12
8000a3a0:	2a 46       	sub	r6,-92
8000a3a2:	20 14       	sub	r4,1
8000a3a4:	ec cc 00 0c 	sub	r12,r6,12
8000a3a8:	58 04       	cp.w	r4,0
8000a3aa:	cf 14       	brge	8000a38c <_fwalk+0x1c>
8000a3ac:	6e 07       	ld.w	r7,r7[0x0]
8000a3ae:	58 07       	cp.w	r7,0
8000a3b0:	ce a1       	brne	8000a384 <_fwalk+0x14>
8000a3b2:	fe b0 fc e4 	rcall	80009d7a <__sfp_lock_release>
8000a3b6:	0a 9c       	mov	r12,r5
8000a3b8:	d8 32       	popm	r0-r7,pc
8000a3ba:	d7 03       	nop

8000a3bc <_localeconv_r>:
8000a3bc:	fe cc d5 c4 	sub	r12,pc,-10812
8000a3c0:	5e fc       	retal	r12
8000a3c2:	d7 03       	nop

8000a3c4 <__smakebuf_r>:
8000a3c4:	d4 21       	pushm	r4-r7,lr
8000a3c6:	20 fd       	sub	sp,60
8000a3c8:	96 68       	ld.sh	r8,r11[0xc]
8000a3ca:	16 97       	mov	r7,r11
8000a3cc:	18 96       	mov	r6,r12
8000a3ce:	e2 18 00 02 	andl	r8,0x2,COH
8000a3d2:	c3 d1       	brne	8000a44c <__smakebuf_r+0x88>
8000a3d4:	96 7b       	ld.sh	r11,r11[0xe]
8000a3d6:	f0 0b 19 00 	cp.h	r11,r8
8000a3da:	c0 55       	brlt	8000a3e4 <__smakebuf_r+0x20>
8000a3dc:	1a 9a       	mov	r10,sp
8000a3de:	e0 a0 04 75 	rcall	8000acc8 <_fstat_r>
8000a3e2:	c0 f4       	brge	8000a400 <__smakebuf_r+0x3c>
8000a3e4:	8e 65       	ld.sh	r5,r7[0xc]
8000a3e6:	0a 98       	mov	r8,r5
8000a3e8:	ab b8       	sbr	r8,0xb
8000a3ea:	e2 15 00 80 	andl	r5,0x80,COH
8000a3ee:	ae 68       	st.h	r7[0xc],r8
8000a3f0:	30 04       	mov	r4,0
8000a3f2:	e0 68 04 00 	mov	r8,1024
8000a3f6:	f9 b5 01 40 	movne	r5,64
8000a3fa:	f0 05 17 00 	moveq	r5,r8
8000a3fe:	c1 c8       	rjmp	8000a436 <__smakebuf_r+0x72>
8000a400:	40 18       	lddsp	r8,sp[0x4]
8000a402:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a406:	e0 48 20 00 	cp.w	r8,8192
8000a40a:	5f 04       	sreq	r4
8000a40c:	e0 48 80 00 	cp.w	r8,32768
8000a410:	c0 e1       	brne	8000a42c <__smakebuf_r+0x68>
8000a412:	6e b9       	ld.w	r9,r7[0x2c]
8000a414:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a418:	10 39       	cp.w	r9,r8
8000a41a:	c0 91       	brne	8000a42c <__smakebuf_r+0x68>
8000a41c:	8e 68       	ld.sh	r8,r7[0xc]
8000a41e:	e0 65 04 00 	mov	r5,1024
8000a422:	ab a8       	sbr	r8,0xa
8000a424:	ef 45 00 50 	st.w	r7[80],r5
8000a428:	ae 68       	st.h	r7[0xc],r8
8000a42a:	c0 68       	rjmp	8000a436 <__smakebuf_r+0x72>
8000a42c:	8e 68       	ld.sh	r8,r7[0xc]
8000a42e:	e0 65 04 00 	mov	r5,1024
8000a432:	ab b8       	sbr	r8,0xb
8000a434:	ae 68       	st.h	r7[0xc],r8
8000a436:	0a 9b       	mov	r11,r5
8000a438:	0c 9c       	mov	r12,r6
8000a43a:	fe b0 df 29 	rcall	8000628c <_malloc_r>
8000a43e:	8e 68       	ld.sh	r8,r7[0xc]
8000a440:	c0 d1       	brne	8000a45a <__smakebuf_r+0x96>
8000a442:	ed b8 00 09 	bld	r8,0x9
8000a446:	c1 b0       	breq	8000a47c <__smakebuf_r+0xb8>
8000a448:	a1 b8       	sbr	r8,0x1
8000a44a:	ae 68       	st.h	r7[0xc],r8
8000a44c:	ee c8 ff b9 	sub	r8,r7,-71
8000a450:	8f 48       	st.w	r7[0x10],r8
8000a452:	8f 08       	st.w	r7[0x0],r8
8000a454:	30 18       	mov	r8,1
8000a456:	8f 58       	st.w	r7[0x14],r8
8000a458:	c1 28       	rjmp	8000a47c <__smakebuf_r+0xb8>
8000a45a:	a7 b8       	sbr	r8,0x7
8000a45c:	8f 4c       	st.w	r7[0x10],r12
8000a45e:	ae 68       	st.h	r7[0xc],r8
8000a460:	8f 55       	st.w	r7[0x14],r5
8000a462:	fe c8 06 e6 	sub	r8,pc,1766
8000a466:	8f 0c       	st.w	r7[0x0],r12
8000a468:	8d a8       	st.w	r6[0x28],r8
8000a46a:	58 04       	cp.w	r4,0
8000a46c:	c0 80       	breq	8000a47c <__smakebuf_r+0xb8>
8000a46e:	8e 7c       	ld.sh	r12,r7[0xe]
8000a470:	fe b0 e3 94 	rcall	80006b98 <isatty>
8000a474:	c0 40       	breq	8000a47c <__smakebuf_r+0xb8>
8000a476:	8e 68       	ld.sh	r8,r7[0xc]
8000a478:	a1 a8       	sbr	r8,0x0
8000a47a:	ae 68       	st.h	r7[0xc],r8
8000a47c:	2f 1d       	sub	sp,-60
8000a47e:	d8 22       	popm	r4-r7,pc

8000a480 <memchr>:
8000a480:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a484:	c0 68       	rjmp	8000a490 <memchr+0x10>
8000a486:	20 1a       	sub	r10,1
8000a488:	19 88       	ld.ub	r8,r12[0x0]
8000a48a:	16 38       	cp.w	r8,r11
8000a48c:	5e 0c       	reteq	r12
8000a48e:	2f fc       	sub	r12,-1
8000a490:	58 0a       	cp.w	r10,0
8000a492:	cf a1       	brne	8000a486 <memchr+0x6>
8000a494:	5e fa       	retal	r10

8000a496 <memmove>:
8000a496:	d4 01       	pushm	lr
8000a498:	18 3b       	cp.w	r11,r12
8000a49a:	c1 92       	brcc	8000a4cc <memmove+0x36>
8000a49c:	f6 0a 00 09 	add	r9,r11,r10
8000a4a0:	12 3c       	cp.w	r12,r9
8000a4a2:	c1 52       	brcc	8000a4cc <memmove+0x36>
8000a4a4:	f8 0a 00 0b 	add	r11,r12,r10
8000a4a8:	30 08       	mov	r8,0
8000a4aa:	c0 68       	rjmp	8000a4b6 <memmove+0x20>
8000a4ac:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a4b0:	20 1a       	sub	r10,1
8000a4b2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a4b6:	20 18       	sub	r8,1
8000a4b8:	58 0a       	cp.w	r10,0
8000a4ba:	cf 91       	brne	8000a4ac <memmove+0x16>
8000a4bc:	d8 02       	popm	pc
8000a4be:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a4c2:	20 1a       	sub	r10,1
8000a4c4:	f8 08 0b 09 	st.b	r12[r8],r9
8000a4c8:	2f f8       	sub	r8,-1
8000a4ca:	c0 28       	rjmp	8000a4ce <memmove+0x38>
8000a4cc:	30 08       	mov	r8,0
8000a4ce:	58 0a       	cp.w	r10,0
8000a4d0:	cf 71       	brne	8000a4be <memmove+0x28>
8000a4d2:	d8 02       	popm	pc

8000a4d4 <__hi0bits>:
8000a4d4:	18 98       	mov	r8,r12
8000a4d6:	e0 1c 00 00 	andl	r12,0x0
8000a4da:	f0 09 15 10 	lsl	r9,r8,0x10
8000a4de:	58 0c       	cp.w	r12,0
8000a4e0:	f2 08 17 00 	moveq	r8,r9
8000a4e4:	f9 bc 00 10 	moveq	r12,16
8000a4e8:	f9 bc 01 00 	movne	r12,0
8000a4ec:	10 9a       	mov	r10,r8
8000a4ee:	f0 09 15 08 	lsl	r9,r8,0x8
8000a4f2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a4f6:	f7 bc 00 f8 	subeq	r12,-8
8000a4fa:	f2 08 17 00 	moveq	r8,r9
8000a4fe:	10 9a       	mov	r10,r8
8000a500:	f0 09 15 04 	lsl	r9,r8,0x4
8000a504:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a508:	f7 bc 00 fc 	subeq	r12,-4
8000a50c:	f2 08 17 00 	moveq	r8,r9
8000a510:	10 9a       	mov	r10,r8
8000a512:	f0 09 15 02 	lsl	r9,r8,0x2
8000a516:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a51a:	f7 bc 00 fe 	subeq	r12,-2
8000a51e:	f2 08 17 00 	moveq	r8,r9
8000a522:	58 08       	cp.w	r8,0
8000a524:	5e 5c       	retlt	r12
8000a526:	ed b8 00 1e 	bld	r8,0x1e
8000a52a:	f9 bc 01 20 	movne	r12,32
8000a52e:	f7 bc 00 ff 	subeq	r12,-1
8000a532:	5e fc       	retal	r12

8000a534 <__lo0bits>:
8000a534:	18 99       	mov	r9,r12
8000a536:	78 08       	ld.w	r8,r12[0x0]
8000a538:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a53c:	c1 50       	breq	8000a566 <__lo0bits+0x32>
8000a53e:	ed b8 00 00 	bld	r8,0x0
8000a542:	c0 21       	brne	8000a546 <__lo0bits+0x12>
8000a544:	5e fd       	retal	0
8000a546:	10 9b       	mov	r11,r8
8000a548:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a54c:	e2 1b 00 02 	andl	r11,0x2,COH
8000a550:	a3 88       	lsr	r8,0x2
8000a552:	58 0b       	cp.w	r11,0
8000a554:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a558:	f9 bc 01 01 	movne	r12,1
8000a55c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a560:	f9 bc 00 02 	moveq	r12,2
8000a564:	5e fc       	retal	r12
8000a566:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a56a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a56e:	58 0a       	cp.w	r10,0
8000a570:	f6 08 17 00 	moveq	r8,r11
8000a574:	f9 bc 00 10 	moveq	r12,16
8000a578:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a57c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a580:	58 0b       	cp.w	r11,0
8000a582:	f7 bc 00 f8 	subeq	r12,-8
8000a586:	f4 08 17 00 	moveq	r8,r10
8000a58a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a58e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a592:	58 0b       	cp.w	r11,0
8000a594:	f7 bc 00 fc 	subeq	r12,-4
8000a598:	f4 08 17 00 	moveq	r8,r10
8000a59c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a5a0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a5a4:	58 0b       	cp.w	r11,0
8000a5a6:	f7 bc 00 fe 	subeq	r12,-2
8000a5aa:	f4 08 17 00 	moveq	r8,r10
8000a5ae:	ed b8 00 00 	bld	r8,0x0
8000a5b2:	c0 60       	breq	8000a5be <__lo0bits+0x8a>
8000a5b4:	a1 98       	lsr	r8,0x1
8000a5b6:	c0 31       	brne	8000a5bc <__lo0bits+0x88>
8000a5b8:	32 0c       	mov	r12,32
8000a5ba:	5e fc       	retal	r12
8000a5bc:	2f fc       	sub	r12,-1
8000a5be:	93 08       	st.w	r9[0x0],r8
8000a5c0:	5e fc       	retal	r12

8000a5c2 <__mcmp>:
8000a5c2:	d4 01       	pushm	lr
8000a5c4:	18 98       	mov	r8,r12
8000a5c6:	76 49       	ld.w	r9,r11[0x10]
8000a5c8:	78 4c       	ld.w	r12,r12[0x10]
8000a5ca:	12 1c       	sub	r12,r9
8000a5cc:	c1 31       	brne	8000a5f2 <__mcmp+0x30>
8000a5ce:	2f b9       	sub	r9,-5
8000a5d0:	a3 69       	lsl	r9,0x2
8000a5d2:	12 0b       	add	r11,r9
8000a5d4:	f0 09 00 09 	add	r9,r8,r9
8000a5d8:	2e c8       	sub	r8,-20
8000a5da:	13 4e       	ld.w	lr,--r9
8000a5dc:	17 4a       	ld.w	r10,--r11
8000a5de:	14 3e       	cp.w	lr,r10
8000a5e0:	c0 60       	breq	8000a5ec <__mcmp+0x2a>
8000a5e2:	f9 bc 03 ff 	movlo	r12,-1
8000a5e6:	f9 bc 02 01 	movhs	r12,1
8000a5ea:	d8 02       	popm	pc
8000a5ec:	10 39       	cp.w	r9,r8
8000a5ee:	fe 9b ff f6 	brhi	8000a5da <__mcmp+0x18>
8000a5f2:	d8 02       	popm	pc

8000a5f4 <_Bfree>:
8000a5f4:	d4 21       	pushm	r4-r7,lr
8000a5f6:	18 97       	mov	r7,r12
8000a5f8:	16 95       	mov	r5,r11
8000a5fa:	78 96       	ld.w	r6,r12[0x24]
8000a5fc:	58 06       	cp.w	r6,0
8000a5fe:	c0 91       	brne	8000a610 <_Bfree+0x1c>
8000a600:	31 0c       	mov	r12,16
8000a602:	fe b0 de 3d 	rcall	8000627c <malloc>
8000a606:	99 36       	st.w	r12[0xc],r6
8000a608:	8f 9c       	st.w	r7[0x24],r12
8000a60a:	99 16       	st.w	r12[0x4],r6
8000a60c:	99 26       	st.w	r12[0x8],r6
8000a60e:	99 06       	st.w	r12[0x0],r6
8000a610:	58 05       	cp.w	r5,0
8000a612:	c0 90       	breq	8000a624 <_Bfree+0x30>
8000a614:	6a 19       	ld.w	r9,r5[0x4]
8000a616:	6e 98       	ld.w	r8,r7[0x24]
8000a618:	70 38       	ld.w	r8,r8[0xc]
8000a61a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a61e:	8b 0a       	st.w	r5[0x0],r10
8000a620:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a624:	d8 22       	popm	r4-r7,pc
8000a626:	d7 03       	nop

8000a628 <_Balloc>:
8000a628:	d4 21       	pushm	r4-r7,lr
8000a62a:	18 97       	mov	r7,r12
8000a62c:	16 96       	mov	r6,r11
8000a62e:	78 95       	ld.w	r5,r12[0x24]
8000a630:	58 05       	cp.w	r5,0
8000a632:	c0 91       	brne	8000a644 <_Balloc+0x1c>
8000a634:	31 0c       	mov	r12,16
8000a636:	fe b0 de 23 	rcall	8000627c <malloc>
8000a63a:	99 35       	st.w	r12[0xc],r5
8000a63c:	8f 9c       	st.w	r7[0x24],r12
8000a63e:	99 15       	st.w	r12[0x4],r5
8000a640:	99 25       	st.w	r12[0x8],r5
8000a642:	99 05       	st.w	r12[0x0],r5
8000a644:	6e 95       	ld.w	r5,r7[0x24]
8000a646:	6a 38       	ld.w	r8,r5[0xc]
8000a648:	58 08       	cp.w	r8,0
8000a64a:	c0 b1       	brne	8000a660 <_Balloc+0x38>
8000a64c:	31 0a       	mov	r10,16
8000a64e:	30 4b       	mov	r11,4
8000a650:	0e 9c       	mov	r12,r7
8000a652:	e0 a0 02 9b 	rcall	8000ab88 <_calloc_r>
8000a656:	8b 3c       	st.w	r5[0xc],r12
8000a658:	6e 98       	ld.w	r8,r7[0x24]
8000a65a:	70 3c       	ld.w	r12,r8[0xc]
8000a65c:	58 0c       	cp.w	r12,0
8000a65e:	c1 b0       	breq	8000a694 <_Balloc+0x6c>
8000a660:	6e 98       	ld.w	r8,r7[0x24]
8000a662:	70 38       	ld.w	r8,r8[0xc]
8000a664:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a668:	70 0c       	ld.w	r12,r8[0x0]
8000a66a:	58 0c       	cp.w	r12,0
8000a66c:	c0 40       	breq	8000a674 <_Balloc+0x4c>
8000a66e:	78 09       	ld.w	r9,r12[0x0]
8000a670:	91 09       	st.w	r8[0x0],r9
8000a672:	c0 e8       	rjmp	8000a68e <_Balloc+0x66>
8000a674:	0e 9c       	mov	r12,r7
8000a676:	30 17       	mov	r7,1
8000a678:	0e 9b       	mov	r11,r7
8000a67a:	ee 06 09 47 	lsl	r7,r7,r6
8000a67e:	ee ca ff fb 	sub	r10,r7,-5
8000a682:	a3 6a       	lsl	r10,0x2
8000a684:	e0 a0 02 82 	rcall	8000ab88 <_calloc_r>
8000a688:	c0 60       	breq	8000a694 <_Balloc+0x6c>
8000a68a:	99 16       	st.w	r12[0x4],r6
8000a68c:	99 27       	st.w	r12[0x8],r7
8000a68e:	30 08       	mov	r8,0
8000a690:	99 38       	st.w	r12[0xc],r8
8000a692:	99 48       	st.w	r12[0x10],r8
8000a694:	d8 22       	popm	r4-r7,pc
8000a696:	d7 03       	nop

8000a698 <__d2b>:
8000a698:	d4 31       	pushm	r0-r7,lr
8000a69a:	20 2d       	sub	sp,8
8000a69c:	16 93       	mov	r3,r11
8000a69e:	12 96       	mov	r6,r9
8000a6a0:	10 95       	mov	r5,r8
8000a6a2:	14 92       	mov	r2,r10
8000a6a4:	30 1b       	mov	r11,1
8000a6a6:	cc 1f       	rcall	8000a628 <_Balloc>
8000a6a8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a6ac:	50 09       	stdsp	sp[0x0],r9
8000a6ae:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a6b2:	b5 a9       	sbr	r9,0x14
8000a6b4:	f0 01 16 14 	lsr	r1,r8,0x14
8000a6b8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a6bc:	18 94       	mov	r4,r12
8000a6be:	58 02       	cp.w	r2,0
8000a6c0:	c1 d0       	breq	8000a6fa <__d2b+0x62>
8000a6c2:	fa cc ff f8 	sub	r12,sp,-8
8000a6c6:	18 d2       	st.w	--r12,r2
8000a6c8:	c3 6f       	rcall	8000a534 <__lo0bits>
8000a6ca:	40 18       	lddsp	r8,sp[0x4]
8000a6cc:	c0 d0       	breq	8000a6e6 <__d2b+0x4e>
8000a6ce:	40 09       	lddsp	r9,sp[0x0]
8000a6d0:	f8 0a 11 20 	rsub	r10,r12,32
8000a6d4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a6d8:	f5 e8 10 08 	or	r8,r10,r8
8000a6dc:	89 58       	st.w	r4[0x14],r8
8000a6de:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a6e2:	50 09       	stdsp	sp[0x0],r9
8000a6e4:	c0 28       	rjmp	8000a6e8 <__d2b+0x50>
8000a6e6:	89 58       	st.w	r4[0x14],r8
8000a6e8:	40 08       	lddsp	r8,sp[0x0]
8000a6ea:	58 08       	cp.w	r8,0
8000a6ec:	f9 b3 01 02 	movne	r3,2
8000a6f0:	f9 b3 00 01 	moveq	r3,1
8000a6f4:	89 68       	st.w	r4[0x18],r8
8000a6f6:	89 43       	st.w	r4[0x10],r3
8000a6f8:	c0 88       	rjmp	8000a708 <__d2b+0x70>
8000a6fa:	1a 9c       	mov	r12,sp
8000a6fc:	c1 cf       	rcall	8000a534 <__lo0bits>
8000a6fe:	30 13       	mov	r3,1
8000a700:	40 08       	lddsp	r8,sp[0x0]
8000a702:	2e 0c       	sub	r12,-32
8000a704:	89 43       	st.w	r4[0x10],r3
8000a706:	89 58       	st.w	r4[0x14],r8
8000a708:	58 01       	cp.w	r1,0
8000a70a:	c0 90       	breq	8000a71c <__d2b+0x84>
8000a70c:	e2 c1 04 33 	sub	r1,r1,1075
8000a710:	18 01       	add	r1,r12
8000a712:	8d 01       	st.w	r6[0x0],r1
8000a714:	f8 0c 11 35 	rsub	r12,r12,53
8000a718:	8b 0c       	st.w	r5[0x0],r12
8000a71a:	c0 c8       	rjmp	8000a732 <__d2b+0x9a>
8000a71c:	e6 c8 ff fc 	sub	r8,r3,-4
8000a720:	f8 cc 04 32 	sub	r12,r12,1074
8000a724:	a5 73       	lsl	r3,0x5
8000a726:	8d 0c       	st.w	r6[0x0],r12
8000a728:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a72c:	cd 4e       	rcall	8000a4d4 <__hi0bits>
8000a72e:	18 13       	sub	r3,r12
8000a730:	8b 03       	st.w	r5[0x0],r3
8000a732:	08 9c       	mov	r12,r4
8000a734:	2f ed       	sub	sp,-8
8000a736:	d8 32       	popm	r0-r7,pc

8000a738 <__mdiff>:
8000a738:	d4 31       	pushm	r0-r7,lr
8000a73a:	74 48       	ld.w	r8,r10[0x10]
8000a73c:	76 45       	ld.w	r5,r11[0x10]
8000a73e:	16 97       	mov	r7,r11
8000a740:	14 96       	mov	r6,r10
8000a742:	10 15       	sub	r5,r8
8000a744:	c1 31       	brne	8000a76a <__mdiff+0x32>
8000a746:	2f b8       	sub	r8,-5
8000a748:	ee ce ff ec 	sub	lr,r7,-20
8000a74c:	a3 68       	lsl	r8,0x2
8000a74e:	f4 08 00 0b 	add	r11,r10,r8
8000a752:	ee 08 00 08 	add	r8,r7,r8
8000a756:	11 4a       	ld.w	r10,--r8
8000a758:	17 49       	ld.w	r9,--r11
8000a75a:	12 3a       	cp.w	r10,r9
8000a75c:	c0 30       	breq	8000a762 <__mdiff+0x2a>
8000a75e:	c0 e2       	brcc	8000a77a <__mdiff+0x42>
8000a760:	c0 78       	rjmp	8000a76e <__mdiff+0x36>
8000a762:	1c 38       	cp.w	r8,lr
8000a764:	fe 9b ff f9 	brhi	8000a756 <__mdiff+0x1e>
8000a768:	c4 98       	rjmp	8000a7fa <__mdiff+0xc2>
8000a76a:	58 05       	cp.w	r5,0
8000a76c:	c0 64       	brge	8000a778 <__mdiff+0x40>
8000a76e:	0e 98       	mov	r8,r7
8000a770:	30 15       	mov	r5,1
8000a772:	0c 97       	mov	r7,r6
8000a774:	10 96       	mov	r6,r8
8000a776:	c0 28       	rjmp	8000a77a <__mdiff+0x42>
8000a778:	30 05       	mov	r5,0
8000a77a:	6e 1b       	ld.w	r11,r7[0x4]
8000a77c:	c5 6f       	rcall	8000a628 <_Balloc>
8000a77e:	6e 49       	ld.w	r9,r7[0x10]
8000a780:	6c 44       	ld.w	r4,r6[0x10]
8000a782:	99 35       	st.w	r12[0xc],r5
8000a784:	2f b4       	sub	r4,-5
8000a786:	f2 c5 ff fb 	sub	r5,r9,-5
8000a78a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a78e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a792:	2e c6       	sub	r6,-20
8000a794:	2e c7       	sub	r7,-20
8000a796:	f8 c8 ff ec 	sub	r8,r12,-20
8000a79a:	30 0a       	mov	r10,0
8000a79c:	0f 0e       	ld.w	lr,r7++
8000a79e:	0d 0b       	ld.w	r11,r6++
8000a7a0:	fc 02 16 10 	lsr	r2,lr,0x10
8000a7a4:	f6 03 16 10 	lsr	r3,r11,0x10
8000a7a8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a7ac:	e4 03 01 03 	sub	r3,r2,r3
8000a7b0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a7b4:	fc 0b 01 0b 	sub	r11,lr,r11
8000a7b8:	f6 0a 00 0a 	add	r10,r11,r10
8000a7bc:	b0 1a       	st.h	r8[0x2],r10
8000a7be:	b1 4a       	asr	r10,0x10
8000a7c0:	e6 0a 00 0a 	add	r10,r3,r10
8000a7c4:	b0 0a       	st.h	r8[0x0],r10
8000a7c6:	2f c8       	sub	r8,-4
8000a7c8:	b1 4a       	asr	r10,0x10
8000a7ca:	08 36       	cp.w	r6,r4
8000a7cc:	ce 83       	brcs	8000a79c <__mdiff+0x64>
8000a7ce:	c0 d8       	rjmp	8000a7e8 <__mdiff+0xb0>
8000a7d0:	0f 0b       	ld.w	r11,r7++
8000a7d2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a7d6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a7da:	16 0a       	add	r10,r11
8000a7dc:	b0 1a       	st.h	r8[0x2],r10
8000a7de:	b1 4a       	asr	r10,0x10
8000a7e0:	1c 0a       	add	r10,lr
8000a7e2:	b0 0a       	st.h	r8[0x0],r10
8000a7e4:	2f c8       	sub	r8,-4
8000a7e6:	b1 4a       	asr	r10,0x10
8000a7e8:	0a 37       	cp.w	r7,r5
8000a7ea:	cf 33       	brcs	8000a7d0 <__mdiff+0x98>
8000a7ec:	c0 28       	rjmp	8000a7f0 <__mdiff+0xb8>
8000a7ee:	20 19       	sub	r9,1
8000a7f0:	11 4a       	ld.w	r10,--r8
8000a7f2:	58 0a       	cp.w	r10,0
8000a7f4:	cf d0       	breq	8000a7ee <__mdiff+0xb6>
8000a7f6:	99 49       	st.w	r12[0x10],r9
8000a7f8:	d8 32       	popm	r0-r7,pc
8000a7fa:	30 0b       	mov	r11,0
8000a7fc:	c1 6f       	rcall	8000a628 <_Balloc>
8000a7fe:	30 18       	mov	r8,1
8000a800:	99 48       	st.w	r12[0x10],r8
8000a802:	30 08       	mov	r8,0
8000a804:	99 58       	st.w	r12[0x14],r8
8000a806:	d8 32       	popm	r0-r7,pc

8000a808 <__lshift>:
8000a808:	d4 31       	pushm	r0-r7,lr
8000a80a:	16 97       	mov	r7,r11
8000a80c:	76 46       	ld.w	r6,r11[0x10]
8000a80e:	f4 02 14 05 	asr	r2,r10,0x5
8000a812:	2f f6       	sub	r6,-1
8000a814:	14 93       	mov	r3,r10
8000a816:	18 94       	mov	r4,r12
8000a818:	04 06       	add	r6,r2
8000a81a:	76 1b       	ld.w	r11,r11[0x4]
8000a81c:	6e 28       	ld.w	r8,r7[0x8]
8000a81e:	c0 38       	rjmp	8000a824 <__lshift+0x1c>
8000a820:	2f fb       	sub	r11,-1
8000a822:	a1 78       	lsl	r8,0x1
8000a824:	10 36       	cp.w	r6,r8
8000a826:	fe 99 ff fd 	brgt	8000a820 <__lshift+0x18>
8000a82a:	08 9c       	mov	r12,r4
8000a82c:	cf ee       	rcall	8000a628 <_Balloc>
8000a82e:	30 09       	mov	r9,0
8000a830:	18 95       	mov	r5,r12
8000a832:	f8 c8 ff ec 	sub	r8,r12,-20
8000a836:	12 9a       	mov	r10,r9
8000a838:	c0 38       	rjmp	8000a83e <__lshift+0x36>
8000a83a:	10 aa       	st.w	r8++,r10
8000a83c:	2f f9       	sub	r9,-1
8000a83e:	04 39       	cp.w	r9,r2
8000a840:	cf d5       	brlt	8000a83a <__lshift+0x32>
8000a842:	6e 4b       	ld.w	r11,r7[0x10]
8000a844:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a848:	2f bb       	sub	r11,-5
8000a84a:	ee c9 ff ec 	sub	r9,r7,-20
8000a84e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a852:	58 03       	cp.w	r3,0
8000a854:	c1 30       	breq	8000a87a <__lshift+0x72>
8000a856:	e6 0c 11 20 	rsub	r12,r3,32
8000a85a:	30 0a       	mov	r10,0
8000a85c:	72 02       	ld.w	r2,r9[0x0]
8000a85e:	e4 03 09 42 	lsl	r2,r2,r3
8000a862:	04 4a       	or	r10,r2
8000a864:	10 aa       	st.w	r8++,r10
8000a866:	13 0a       	ld.w	r10,r9++
8000a868:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a86c:	16 39       	cp.w	r9,r11
8000a86e:	cf 73       	brcs	8000a85c <__lshift+0x54>
8000a870:	91 0a       	st.w	r8[0x0],r10
8000a872:	58 0a       	cp.w	r10,0
8000a874:	c0 70       	breq	8000a882 <__lshift+0x7a>
8000a876:	2f f6       	sub	r6,-1
8000a878:	c0 58       	rjmp	8000a882 <__lshift+0x7a>
8000a87a:	13 0a       	ld.w	r10,r9++
8000a87c:	10 aa       	st.w	r8++,r10
8000a87e:	16 39       	cp.w	r9,r11
8000a880:	cf d3       	brcs	8000a87a <__lshift+0x72>
8000a882:	08 9c       	mov	r12,r4
8000a884:	20 16       	sub	r6,1
8000a886:	0e 9b       	mov	r11,r7
8000a888:	8b 46       	st.w	r5[0x10],r6
8000a88a:	cb 5e       	rcall	8000a5f4 <_Bfree>
8000a88c:	0a 9c       	mov	r12,r5
8000a88e:	d8 32       	popm	r0-r7,pc

8000a890 <__multiply>:
8000a890:	d4 31       	pushm	r0-r7,lr
8000a892:	20 2d       	sub	sp,8
8000a894:	76 49       	ld.w	r9,r11[0x10]
8000a896:	74 48       	ld.w	r8,r10[0x10]
8000a898:	16 96       	mov	r6,r11
8000a89a:	14 95       	mov	r5,r10
8000a89c:	10 39       	cp.w	r9,r8
8000a89e:	ec 08 17 50 	movlt	r8,r6
8000a8a2:	ea 06 17 50 	movlt	r6,r5
8000a8a6:	f0 05 17 50 	movlt	r5,r8
8000a8aa:	6c 28       	ld.w	r8,r6[0x8]
8000a8ac:	76 43       	ld.w	r3,r11[0x10]
8000a8ae:	74 42       	ld.w	r2,r10[0x10]
8000a8b0:	76 1b       	ld.w	r11,r11[0x4]
8000a8b2:	e4 03 00 07 	add	r7,r2,r3
8000a8b6:	10 37       	cp.w	r7,r8
8000a8b8:	f7 bb 09 ff 	subgt	r11,-1
8000a8bc:	cb 6e       	rcall	8000a628 <_Balloc>
8000a8be:	ee c4 ff fb 	sub	r4,r7,-5
8000a8c2:	f8 c9 ff ec 	sub	r9,r12,-20
8000a8c6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a8ca:	30 0a       	mov	r10,0
8000a8cc:	12 98       	mov	r8,r9
8000a8ce:	c0 28       	rjmp	8000a8d2 <__multiply+0x42>
8000a8d0:	10 aa       	st.w	r8++,r10
8000a8d2:	08 38       	cp.w	r8,r4
8000a8d4:	cf e3       	brcs	8000a8d0 <__multiply+0x40>
8000a8d6:	2f b3       	sub	r3,-5
8000a8d8:	2f b2       	sub	r2,-5
8000a8da:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a8de:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a8e2:	ec cb ff ec 	sub	r11,r6,-20
8000a8e6:	50 12       	stdsp	sp[0x4],r2
8000a8e8:	ea ca ff ec 	sub	r10,r5,-20
8000a8ec:	c4 48       	rjmp	8000a974 <__multiply+0xe4>
8000a8ee:	94 95       	ld.uh	r5,r10[0x2]
8000a8f0:	58 05       	cp.w	r5,0
8000a8f2:	c2 00       	breq	8000a932 <__multiply+0xa2>
8000a8f4:	12 98       	mov	r8,r9
8000a8f6:	16 96       	mov	r6,r11
8000a8f8:	30 0e       	mov	lr,0
8000a8fa:	50 09       	stdsp	sp[0x0],r9
8000a8fc:	0d 02       	ld.w	r2,r6++
8000a8fe:	e4 00 16 10 	lsr	r0,r2,0x10
8000a902:	70 01       	ld.w	r1,r8[0x0]
8000a904:	70 09       	ld.w	r9,r8[0x0]
8000a906:	b1 81       	lsr	r1,0x10
8000a908:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a90c:	e0 05 03 41 	mac	r1,r0,r5
8000a910:	ab 32       	mul	r2,r5
8000a912:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a916:	00 02       	add	r2,r0
8000a918:	e4 0e 00 0e 	add	lr,r2,lr
8000a91c:	b0 1e       	st.h	r8[0x2],lr
8000a91e:	b1 8e       	lsr	lr,0x10
8000a920:	1c 01       	add	r1,lr
8000a922:	b0 01       	st.h	r8[0x0],r1
8000a924:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a928:	2f c8       	sub	r8,-4
8000a92a:	06 36       	cp.w	r6,r3
8000a92c:	ce 83       	brcs	8000a8fc <__multiply+0x6c>
8000a92e:	40 09       	lddsp	r9,sp[0x0]
8000a930:	91 0e       	st.w	r8[0x0],lr
8000a932:	94 86       	ld.uh	r6,r10[0x0]
8000a934:	58 06       	cp.w	r6,0
8000a936:	c1 d0       	breq	8000a970 <__multiply+0xe0>
8000a938:	72 02       	ld.w	r2,r9[0x0]
8000a93a:	12 98       	mov	r8,r9
8000a93c:	16 9e       	mov	lr,r11
8000a93e:	30 05       	mov	r5,0
8000a940:	b0 12       	st.h	r8[0x2],r2
8000a942:	1d 01       	ld.w	r1,lr++
8000a944:	90 82       	ld.uh	r2,r8[0x0]
8000a946:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a94a:	ad 30       	mul	r0,r6
8000a94c:	e0 02 00 02 	add	r2,r0,r2
8000a950:	e4 05 00 05 	add	r5,r2,r5
8000a954:	b0 05       	st.h	r8[0x0],r5
8000a956:	b1 85       	lsr	r5,0x10
8000a958:	b1 81       	lsr	r1,0x10
8000a95a:	2f c8       	sub	r8,-4
8000a95c:	ad 31       	mul	r1,r6
8000a95e:	90 92       	ld.uh	r2,r8[0x2]
8000a960:	e2 02 00 02 	add	r2,r1,r2
8000a964:	0a 02       	add	r2,r5
8000a966:	e4 05 16 10 	lsr	r5,r2,0x10
8000a96a:	06 3e       	cp.w	lr,r3
8000a96c:	ce a3       	brcs	8000a940 <__multiply+0xb0>
8000a96e:	91 02       	st.w	r8[0x0],r2
8000a970:	2f ca       	sub	r10,-4
8000a972:	2f c9       	sub	r9,-4
8000a974:	40 18       	lddsp	r8,sp[0x4]
8000a976:	10 3a       	cp.w	r10,r8
8000a978:	cb b3       	brcs	8000a8ee <__multiply+0x5e>
8000a97a:	c0 28       	rjmp	8000a97e <__multiply+0xee>
8000a97c:	20 17       	sub	r7,1
8000a97e:	58 07       	cp.w	r7,0
8000a980:	e0 8a 00 05 	brle	8000a98a <__multiply+0xfa>
8000a984:	09 48       	ld.w	r8,--r4
8000a986:	58 08       	cp.w	r8,0
8000a988:	cf a0       	breq	8000a97c <__multiply+0xec>
8000a98a:	99 47       	st.w	r12[0x10],r7
8000a98c:	2f ed       	sub	sp,-8
8000a98e:	d8 32       	popm	r0-r7,pc

8000a990 <__i2b>:
8000a990:	d4 21       	pushm	r4-r7,lr
8000a992:	16 97       	mov	r7,r11
8000a994:	30 1b       	mov	r11,1
8000a996:	c4 9e       	rcall	8000a628 <_Balloc>
8000a998:	30 19       	mov	r9,1
8000a99a:	99 57       	st.w	r12[0x14],r7
8000a99c:	99 49       	st.w	r12[0x10],r9
8000a99e:	d8 22       	popm	r4-r7,pc

8000a9a0 <__multadd>:
8000a9a0:	d4 31       	pushm	r0-r7,lr
8000a9a2:	30 08       	mov	r8,0
8000a9a4:	12 95       	mov	r5,r9
8000a9a6:	16 97       	mov	r7,r11
8000a9a8:	18 96       	mov	r6,r12
8000a9aa:	76 44       	ld.w	r4,r11[0x10]
8000a9ac:	f6 c9 ff ec 	sub	r9,r11,-20
8000a9b0:	72 0b       	ld.w	r11,r9[0x0]
8000a9b2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a9b6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a9ba:	f4 0c 02 4c 	mul	r12,r10,r12
8000a9be:	f4 0b 03 45 	mac	r5,r10,r11
8000a9c2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a9c6:	b1 85       	lsr	r5,0x10
8000a9c8:	18 05       	add	r5,r12
8000a9ca:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a9ce:	f8 0b 00 0b 	add	r11,r12,r11
8000a9d2:	12 ab       	st.w	r9++,r11
8000a9d4:	2f f8       	sub	r8,-1
8000a9d6:	b1 85       	lsr	r5,0x10
8000a9d8:	08 38       	cp.w	r8,r4
8000a9da:	ce b5       	brlt	8000a9b0 <__multadd+0x10>
8000a9dc:	58 05       	cp.w	r5,0
8000a9de:	c1 c0       	breq	8000aa16 <__multadd+0x76>
8000a9e0:	6e 28       	ld.w	r8,r7[0x8]
8000a9e2:	10 34       	cp.w	r4,r8
8000a9e4:	c1 35       	brlt	8000aa0a <__multadd+0x6a>
8000a9e6:	6e 1b       	ld.w	r11,r7[0x4]
8000a9e8:	0c 9c       	mov	r12,r6
8000a9ea:	2f fb       	sub	r11,-1
8000a9ec:	c1 ee       	rcall	8000a628 <_Balloc>
8000a9ee:	6e 4a       	ld.w	r10,r7[0x10]
8000a9f0:	ee cb ff f4 	sub	r11,r7,-12
8000a9f4:	18 93       	mov	r3,r12
8000a9f6:	2f ea       	sub	r10,-2
8000a9f8:	2f 4c       	sub	r12,-12
8000a9fa:	a3 6a       	lsl	r10,0x2
8000a9fc:	fe b0 de 64 	rcall	800066c4 <memcpy>
8000aa00:	0e 9b       	mov	r11,r7
8000aa02:	0c 9c       	mov	r12,r6
8000aa04:	fe b0 fd f8 	rcall	8000a5f4 <_Bfree>
8000aa08:	06 97       	mov	r7,r3
8000aa0a:	e8 c8 ff ff 	sub	r8,r4,-1
8000aa0e:	2f b4       	sub	r4,-5
8000aa10:	8f 48       	st.w	r7[0x10],r8
8000aa12:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000aa16:	0e 9c       	mov	r12,r7
8000aa18:	d8 32       	popm	r0-r7,pc
8000aa1a:	d7 03       	nop

8000aa1c <__pow5mult>:
8000aa1c:	d4 31       	pushm	r0-r7,lr
8000aa1e:	14 96       	mov	r6,r10
8000aa20:	18 97       	mov	r7,r12
8000aa22:	16 94       	mov	r4,r11
8000aa24:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000aa28:	c0 90       	breq	8000aa3a <__pow5mult+0x1e>
8000aa2a:	20 18       	sub	r8,1
8000aa2c:	fe c9 db f8 	sub	r9,pc,-9224
8000aa30:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000aa34:	30 09       	mov	r9,0
8000aa36:	cb 5f       	rcall	8000a9a0 <__multadd>
8000aa38:	18 94       	mov	r4,r12
8000aa3a:	a3 46       	asr	r6,0x2
8000aa3c:	c3 40       	breq	8000aaa4 <__pow5mult+0x88>
8000aa3e:	6e 95       	ld.w	r5,r7[0x24]
8000aa40:	58 05       	cp.w	r5,0
8000aa42:	c0 91       	brne	8000aa54 <__pow5mult+0x38>
8000aa44:	31 0c       	mov	r12,16
8000aa46:	fe b0 dc 1b 	rcall	8000627c <malloc>
8000aa4a:	99 35       	st.w	r12[0xc],r5
8000aa4c:	8f 9c       	st.w	r7[0x24],r12
8000aa4e:	99 15       	st.w	r12[0x4],r5
8000aa50:	99 25       	st.w	r12[0x8],r5
8000aa52:	99 05       	st.w	r12[0x0],r5
8000aa54:	6e 93       	ld.w	r3,r7[0x24]
8000aa56:	66 25       	ld.w	r5,r3[0x8]
8000aa58:	58 05       	cp.w	r5,0
8000aa5a:	c0 c1       	brne	8000aa72 <__pow5mult+0x56>
8000aa5c:	e0 6b 02 71 	mov	r11,625
8000aa60:	0e 9c       	mov	r12,r7
8000aa62:	c9 7f       	rcall	8000a990 <__i2b>
8000aa64:	87 2c       	st.w	r3[0x8],r12
8000aa66:	30 08       	mov	r8,0
8000aa68:	18 95       	mov	r5,r12
8000aa6a:	99 08       	st.w	r12[0x0],r8
8000aa6c:	c0 38       	rjmp	8000aa72 <__pow5mult+0x56>
8000aa6e:	06 9c       	mov	r12,r3
8000aa70:	18 95       	mov	r5,r12
8000aa72:	ed b6 00 00 	bld	r6,0x0
8000aa76:	c0 b1       	brne	8000aa8c <__pow5mult+0x70>
8000aa78:	08 9b       	mov	r11,r4
8000aa7a:	0a 9a       	mov	r10,r5
8000aa7c:	0e 9c       	mov	r12,r7
8000aa7e:	c0 9f       	rcall	8000a890 <__multiply>
8000aa80:	08 9b       	mov	r11,r4
8000aa82:	18 93       	mov	r3,r12
8000aa84:	0e 9c       	mov	r12,r7
8000aa86:	06 94       	mov	r4,r3
8000aa88:	fe b0 fd b6 	rcall	8000a5f4 <_Bfree>
8000aa8c:	a1 56       	asr	r6,0x1
8000aa8e:	c0 b0       	breq	8000aaa4 <__pow5mult+0x88>
8000aa90:	6a 03       	ld.w	r3,r5[0x0]
8000aa92:	58 03       	cp.w	r3,0
8000aa94:	ce d1       	brne	8000aa6e <__pow5mult+0x52>
8000aa96:	0a 9a       	mov	r10,r5
8000aa98:	0a 9b       	mov	r11,r5
8000aa9a:	0e 9c       	mov	r12,r7
8000aa9c:	cf ae       	rcall	8000a890 <__multiply>
8000aa9e:	8b 0c       	st.w	r5[0x0],r12
8000aaa0:	99 03       	st.w	r12[0x0],r3
8000aaa2:	ce 7b       	rjmp	8000aa70 <__pow5mult+0x54>
8000aaa4:	08 9c       	mov	r12,r4
8000aaa6:	d8 32       	popm	r0-r7,pc

8000aaa8 <__isinfd>:
8000aaa8:	14 98       	mov	r8,r10
8000aaaa:	fc 19 7f f0 	movh	r9,0x7ff0
8000aaae:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000aab2:	f0 0b 11 00 	rsub	r11,r8,0
8000aab6:	f7 e8 10 08 	or	r8,r11,r8
8000aaba:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000aabe:	f2 08 01 08 	sub	r8,r9,r8
8000aac2:	f0 0c 11 00 	rsub	r12,r8,0
8000aac6:	f9 e8 10 08 	or	r8,r12,r8
8000aaca:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000aace:	2f fc       	sub	r12,-1
8000aad0:	5e fc       	retal	r12

8000aad2 <__isnand>:
8000aad2:	14 98       	mov	r8,r10
8000aad4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000aad8:	f0 0c 11 00 	rsub	r12,r8,0
8000aadc:	10 4c       	or	r12,r8
8000aade:	fc 18 7f f0 	movh	r8,0x7ff0
8000aae2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000aae6:	f0 0c 01 0c 	sub	r12,r8,r12
8000aaea:	bf 9c       	lsr	r12,0x1f
8000aaec:	5e fc       	retal	r12
8000aaee:	d7 03       	nop

8000aaf0 <__sclose>:
8000aaf0:	d4 01       	pushm	lr
8000aaf2:	96 7b       	ld.sh	r11,r11[0xe]
8000aaf4:	c7 6c       	rcall	8000abe0 <_close_r>
8000aaf6:	d8 02       	popm	pc

8000aaf8 <__sseek>:
8000aaf8:	d4 21       	pushm	r4-r7,lr
8000aafa:	16 97       	mov	r7,r11
8000aafc:	96 7b       	ld.sh	r11,r11[0xe]
8000aafe:	cf 7c       	rcall	8000acec <_lseek_r>
8000ab00:	8e 68       	ld.sh	r8,r7[0xc]
8000ab02:	10 99       	mov	r9,r8
8000ab04:	ad c8       	cbr	r8,0xc
8000ab06:	ad a9       	sbr	r9,0xc
8000ab08:	5b fc       	cp.w	r12,-1
8000ab0a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ab0e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ab12:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ab16:	d8 22       	popm	r4-r7,pc

8000ab18 <__swrite>:
8000ab18:	d4 21       	pushm	r4-r7,lr
8000ab1a:	96 68       	ld.sh	r8,r11[0xc]
8000ab1c:	16 97       	mov	r7,r11
8000ab1e:	14 95       	mov	r5,r10
8000ab20:	12 94       	mov	r4,r9
8000ab22:	e2 18 01 00 	andl	r8,0x100,COH
8000ab26:	18 96       	mov	r6,r12
8000ab28:	c0 50       	breq	8000ab32 <__swrite+0x1a>
8000ab2a:	30 29       	mov	r9,2
8000ab2c:	30 0a       	mov	r10,0
8000ab2e:	96 7b       	ld.sh	r11,r11[0xe]
8000ab30:	cd ec       	rcall	8000acec <_lseek_r>
8000ab32:	8e 68       	ld.sh	r8,r7[0xc]
8000ab34:	ad c8       	cbr	r8,0xc
8000ab36:	08 99       	mov	r9,r4
8000ab38:	0a 9a       	mov	r10,r5
8000ab3a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ab3c:	0c 9c       	mov	r12,r6
8000ab3e:	ae 68       	st.h	r7[0xc],r8
8000ab40:	c1 0c       	rcall	8000ab60 <_write_r>
8000ab42:	d8 22       	popm	r4-r7,pc

8000ab44 <__sread>:
8000ab44:	d4 21       	pushm	r4-r7,lr
8000ab46:	16 97       	mov	r7,r11
8000ab48:	96 7b       	ld.sh	r11,r11[0xe]
8000ab4a:	ce 5c       	rcall	8000ad14 <_read_r>
8000ab4c:	c0 65       	brlt	8000ab58 <__sread+0x14>
8000ab4e:	6f 58       	ld.w	r8,r7[0x54]
8000ab50:	18 08       	add	r8,r12
8000ab52:	ef 48 00 54 	st.w	r7[84],r8
8000ab56:	d8 22       	popm	r4-r7,pc
8000ab58:	8e 68       	ld.sh	r8,r7[0xc]
8000ab5a:	ad c8       	cbr	r8,0xc
8000ab5c:	ae 68       	st.h	r7[0xc],r8
8000ab5e:	d8 22       	popm	r4-r7,pc

8000ab60 <_write_r>:
8000ab60:	d4 21       	pushm	r4-r7,lr
8000ab62:	16 98       	mov	r8,r11
8000ab64:	18 97       	mov	r7,r12
8000ab66:	10 9c       	mov	r12,r8
8000ab68:	30 08       	mov	r8,0
8000ab6a:	14 9b       	mov	r11,r10
8000ab6c:	e0 66 41 14 	mov	r6,16660
8000ab70:	12 9a       	mov	r10,r9
8000ab72:	8d 08       	st.w	r6[0x0],r8
8000ab74:	fe b0 d1 48 	rcall	80004e04 <_write>
8000ab78:	5b fc       	cp.w	r12,-1
8000ab7a:	c0 51       	brne	8000ab84 <_write_r+0x24>
8000ab7c:	6c 08       	ld.w	r8,r6[0x0]
8000ab7e:	58 08       	cp.w	r8,0
8000ab80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ab84:	d8 22       	popm	r4-r7,pc
8000ab86:	d7 03       	nop

8000ab88 <_calloc_r>:
8000ab88:	d4 21       	pushm	r4-r7,lr
8000ab8a:	f4 0b 02 4b 	mul	r11,r10,r11
8000ab8e:	fe b0 db 7f 	rcall	8000628c <_malloc_r>
8000ab92:	18 97       	mov	r7,r12
8000ab94:	c2 30       	breq	8000abda <_calloc_r+0x52>
8000ab96:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ab9a:	e0 1a ff fc 	andl	r10,0xfffc
8000ab9e:	20 4a       	sub	r10,4
8000aba0:	e0 4a 00 24 	cp.w	r10,36
8000aba4:	e0 8b 00 18 	brhi	8000abd4 <_calloc_r+0x4c>
8000aba8:	18 98       	mov	r8,r12
8000abaa:	59 3a       	cp.w	r10,19
8000abac:	e0 88 00 0f 	brls	8000abca <_calloc_r+0x42>
8000abb0:	30 09       	mov	r9,0
8000abb2:	10 a9       	st.w	r8++,r9
8000abb4:	10 a9       	st.w	r8++,r9
8000abb6:	59 ba       	cp.w	r10,27
8000abb8:	e0 88 00 09 	brls	8000abca <_calloc_r+0x42>
8000abbc:	10 a9       	st.w	r8++,r9
8000abbe:	10 a9       	st.w	r8++,r9
8000abc0:	e0 4a 00 24 	cp.w	r10,36
8000abc4:	c0 31       	brne	8000abca <_calloc_r+0x42>
8000abc6:	10 a9       	st.w	r8++,r9
8000abc8:	10 a9       	st.w	r8++,r9
8000abca:	30 09       	mov	r9,0
8000abcc:	10 a9       	st.w	r8++,r9
8000abce:	91 19       	st.w	r8[0x4],r9
8000abd0:	91 09       	st.w	r8[0x0],r9
8000abd2:	c0 48       	rjmp	8000abda <_calloc_r+0x52>
8000abd4:	30 0b       	mov	r11,0
8000abd6:	fe b0 de 1b 	rcall	8000680c <memset>
8000abda:	0e 9c       	mov	r12,r7
8000abdc:	d8 22       	popm	r4-r7,pc
8000abde:	d7 03       	nop

8000abe0 <_close_r>:
8000abe0:	d4 21       	pushm	r4-r7,lr
8000abe2:	30 08       	mov	r8,0
8000abe4:	18 97       	mov	r7,r12
8000abe6:	e0 66 41 14 	mov	r6,16660
8000abea:	16 9c       	mov	r12,r11
8000abec:	8d 08       	st.w	r6[0x0],r8
8000abee:	fe b0 df c1 	rcall	80006b70 <_close>
8000abf2:	5b fc       	cp.w	r12,-1
8000abf4:	c0 51       	brne	8000abfe <_close_r+0x1e>
8000abf6:	6c 08       	ld.w	r8,r6[0x0]
8000abf8:	58 08       	cp.w	r8,0
8000abfa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000abfe:	d8 22       	popm	r4-r7,pc

8000ac00 <_fclose_r>:
8000ac00:	d4 21       	pushm	r4-r7,lr
8000ac02:	18 96       	mov	r6,r12
8000ac04:	16 97       	mov	r7,r11
8000ac06:	58 0b       	cp.w	r11,0
8000ac08:	c0 31       	brne	8000ac0e <_fclose_r+0xe>
8000ac0a:	16 95       	mov	r5,r11
8000ac0c:	c5 38       	rjmp	8000acb2 <_fclose_r+0xb2>
8000ac0e:	fe b0 f8 b5 	rcall	80009d78 <__sfp_lock_acquire>
8000ac12:	58 06       	cp.w	r6,0
8000ac14:	c0 70       	breq	8000ac22 <_fclose_r+0x22>
8000ac16:	6c 68       	ld.w	r8,r6[0x18]
8000ac18:	58 08       	cp.w	r8,0
8000ac1a:	c0 41       	brne	8000ac22 <_fclose_r+0x22>
8000ac1c:	0c 9c       	mov	r12,r6
8000ac1e:	fe b0 f8 ff 	rcall	80009e1c <__sinit>
8000ac22:	fe c8 de 92 	sub	r8,pc,-8558
8000ac26:	10 37       	cp.w	r7,r8
8000ac28:	c0 31       	brne	8000ac2e <_fclose_r+0x2e>
8000ac2a:	6c 07       	ld.w	r7,r6[0x0]
8000ac2c:	c0 c8       	rjmp	8000ac44 <_fclose_r+0x44>
8000ac2e:	fe c8 de 7e 	sub	r8,pc,-8578
8000ac32:	10 37       	cp.w	r7,r8
8000ac34:	c0 31       	brne	8000ac3a <_fclose_r+0x3a>
8000ac36:	6c 17       	ld.w	r7,r6[0x4]
8000ac38:	c0 68       	rjmp	8000ac44 <_fclose_r+0x44>
8000ac3a:	fe c8 de 6a 	sub	r8,pc,-8598
8000ac3e:	10 37       	cp.w	r7,r8
8000ac40:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ac44:	8e 69       	ld.sh	r9,r7[0xc]
8000ac46:	30 08       	mov	r8,0
8000ac48:	f0 09 19 00 	cp.h	r9,r8
8000ac4c:	c0 51       	brne	8000ac56 <_fclose_r+0x56>
8000ac4e:	fe b0 f8 96 	rcall	80009d7a <__sfp_lock_release>
8000ac52:	30 05       	mov	r5,0
8000ac54:	c2 f8       	rjmp	8000acb2 <_fclose_r+0xb2>
8000ac56:	0e 9b       	mov	r11,r7
8000ac58:	0c 9c       	mov	r12,r6
8000ac5a:	fe b0 f8 09 	rcall	80009c6c <_fflush_r>
8000ac5e:	6e c8       	ld.w	r8,r7[0x30]
8000ac60:	18 95       	mov	r5,r12
8000ac62:	58 08       	cp.w	r8,0
8000ac64:	c0 60       	breq	8000ac70 <_fclose_r+0x70>
8000ac66:	6e 8b       	ld.w	r11,r7[0x20]
8000ac68:	0c 9c       	mov	r12,r6
8000ac6a:	5d 18       	icall	r8
8000ac6c:	f9 b5 05 ff 	movlt	r5,-1
8000ac70:	8e 68       	ld.sh	r8,r7[0xc]
8000ac72:	ed b8 00 07 	bld	r8,0x7
8000ac76:	c0 51       	brne	8000ac80 <_fclose_r+0x80>
8000ac78:	6e 4b       	ld.w	r11,r7[0x10]
8000ac7a:	0c 9c       	mov	r12,r6
8000ac7c:	fe b0 f9 6a 	rcall	80009f50 <_free_r>
8000ac80:	6e db       	ld.w	r11,r7[0x34]
8000ac82:	58 0b       	cp.w	r11,0
8000ac84:	c0 a0       	breq	8000ac98 <_fclose_r+0x98>
8000ac86:	ee c8 ff bc 	sub	r8,r7,-68
8000ac8a:	10 3b       	cp.w	r11,r8
8000ac8c:	c0 40       	breq	8000ac94 <_fclose_r+0x94>
8000ac8e:	0c 9c       	mov	r12,r6
8000ac90:	fe b0 f9 60 	rcall	80009f50 <_free_r>
8000ac94:	30 08       	mov	r8,0
8000ac96:	8f d8       	st.w	r7[0x34],r8
8000ac98:	6f 2b       	ld.w	r11,r7[0x48]
8000ac9a:	58 0b       	cp.w	r11,0
8000ac9c:	c0 70       	breq	8000acaa <_fclose_r+0xaa>
8000ac9e:	0c 9c       	mov	r12,r6
8000aca0:	fe b0 f9 58 	rcall	80009f50 <_free_r>
8000aca4:	30 08       	mov	r8,0
8000aca6:	ef 48 00 48 	st.w	r7[72],r8
8000acaa:	30 08       	mov	r8,0
8000acac:	ae 68       	st.h	r7[0xc],r8
8000acae:	fe b0 f8 66 	rcall	80009d7a <__sfp_lock_release>
8000acb2:	0a 9c       	mov	r12,r5
8000acb4:	d8 22       	popm	r4-r7,pc
8000acb6:	d7 03       	nop

8000acb8 <fclose>:
8000acb8:	d4 01       	pushm	lr
8000acba:	e0 68 0a 40 	mov	r8,2624
8000acbe:	18 9b       	mov	r11,r12
8000acc0:	70 0c       	ld.w	r12,r8[0x0]
8000acc2:	c9 ff       	rcall	8000ac00 <_fclose_r>
8000acc4:	d8 02       	popm	pc
8000acc6:	d7 03       	nop

8000acc8 <_fstat_r>:
8000acc8:	d4 21       	pushm	r4-r7,lr
8000acca:	16 98       	mov	r8,r11
8000accc:	18 97       	mov	r7,r12
8000acce:	10 9c       	mov	r12,r8
8000acd0:	30 08       	mov	r8,0
8000acd2:	e0 66 41 14 	mov	r6,16660
8000acd6:	14 9b       	mov	r11,r10
8000acd8:	8d 08       	st.w	r6[0x0],r8
8000acda:	fe b0 df 73 	rcall	80006bc0 <_fstat>
8000acde:	5b fc       	cp.w	r12,-1
8000ace0:	c0 51       	brne	8000acea <_fstat_r+0x22>
8000ace2:	6c 08       	ld.w	r8,r6[0x0]
8000ace4:	58 08       	cp.w	r8,0
8000ace6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000acea:	d8 22       	popm	r4-r7,pc

8000acec <_lseek_r>:
8000acec:	d4 21       	pushm	r4-r7,lr
8000acee:	16 98       	mov	r8,r11
8000acf0:	18 97       	mov	r7,r12
8000acf2:	10 9c       	mov	r12,r8
8000acf4:	30 08       	mov	r8,0
8000acf6:	14 9b       	mov	r11,r10
8000acf8:	e0 66 41 14 	mov	r6,16660
8000acfc:	12 9a       	mov	r10,r9
8000acfe:	8d 08       	st.w	r6[0x0],r8
8000ad00:	fe b0 df 42 	rcall	80006b84 <_lseek>
8000ad04:	5b fc       	cp.w	r12,-1
8000ad06:	c0 51       	brne	8000ad10 <_lseek_r+0x24>
8000ad08:	6c 08       	ld.w	r8,r6[0x0]
8000ad0a:	58 08       	cp.w	r8,0
8000ad0c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad10:	d8 22       	popm	r4-r7,pc
8000ad12:	d7 03       	nop

8000ad14 <_read_r>:
8000ad14:	d4 21       	pushm	r4-r7,lr
8000ad16:	16 98       	mov	r8,r11
8000ad18:	18 97       	mov	r7,r12
8000ad1a:	10 9c       	mov	r12,r8
8000ad1c:	30 08       	mov	r8,0
8000ad1e:	14 9b       	mov	r11,r10
8000ad20:	e0 66 41 14 	mov	r6,16660
8000ad24:	12 9a       	mov	r10,r9
8000ad26:	8d 08       	st.w	r6[0x0],r8
8000ad28:	fe b0 d0 4e 	rcall	80004dc4 <_read>
8000ad2c:	5b fc       	cp.w	r12,-1
8000ad2e:	c0 51       	brne	8000ad38 <_read_r+0x24>
8000ad30:	6c 08       	ld.w	r8,r6[0x0]
8000ad32:	58 08       	cp.w	r8,0
8000ad34:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad38:	d8 22       	popm	r4-r7,pc
8000ad3a:	d7 03       	nop

8000ad3c <__avr32_f64_mul>:
8000ad3c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ad40:	e0 80 00 dc 	breq	8000aef8 <__avr32_f64_mul_op1_zero>
8000ad44:	d4 21       	pushm	r4-r7,lr
8000ad46:	f7 e9 20 0e 	eor	lr,r11,r9
8000ad4a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ad4e:	30 15       	mov	r5,1
8000ad50:	c4 30       	breq	8000add6 <__avr32_f64_mul_op1_subnormal>
8000ad52:	ab 6b       	lsl	r11,0xa
8000ad54:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ad58:	ab 6a       	lsl	r10,0xa
8000ad5a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ad5e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ad62:	c5 c0       	breq	8000ae1a <__avr32_f64_mul_op2_subnormal>
8000ad64:	a1 78       	lsl	r8,0x1
8000ad66:	5c f9       	rol	r9
8000ad68:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ad6c:	e0 47 07 ff 	cp.w	r7,2047
8000ad70:	c7 70       	breq	8000ae5e <__avr32_f64_mul_op_nan_or_inf>
8000ad72:	e0 46 07 ff 	cp.w	r6,2047
8000ad76:	c7 40       	breq	8000ae5e <__avr32_f64_mul_op_nan_or_inf>
8000ad78:	ee 06 00 0c 	add	r12,r7,r6
8000ad7c:	e0 2c 03 fe 	sub	r12,1022
8000ad80:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ad84:	f4 09 07 44 	macu.d	r4,r10,r9
8000ad88:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ad8c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ad90:	08 07       	add	r7,r4
8000ad92:	f4 05 00 4a 	adc	r10,r10,r5
8000ad96:	5c 0b       	acr	r11
8000ad98:	ed bb 00 14 	bld	r11,0x14
8000ad9c:	c0 50       	breq	8000ada6 <__avr32_f64_mul+0x6a>
8000ad9e:	a1 77       	lsl	r7,0x1
8000ada0:	5c fa       	rol	r10
8000ada2:	5c fb       	rol	r11
8000ada4:	20 1c       	sub	r12,1
8000ada6:	58 0c       	cp.w	r12,0
8000ada8:	e0 8a 00 6f 	brle	8000ae86 <__avr32_f64_mul_res_subnormal>
8000adac:	e0 4c 07 ff 	cp.w	r12,2047
8000adb0:	e0 84 00 9c 	brge	8000aee8 <__avr32_f64_mul_res_inf>
8000adb4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000adb8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000adbc:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000adc0:	ee 17 80 00 	eorh	r7,0x8000
8000adc4:	f1 b7 04 20 	satu	r7,0x1
8000adc8:	0e 0a       	add	r10,r7
8000adca:	5c 0b       	acr	r11
8000adcc:	ed be 00 1f 	bld	lr,0x1f
8000add0:	ef bb 00 1f 	bst	r11,0x1f
8000add4:	d8 22       	popm	r4-r7,pc

8000add6 <__avr32_f64_mul_op1_subnormal>:
8000add6:	e4 1b 00 0f 	andh	r11,0xf
8000adda:	f4 0c 12 00 	clz	r12,r10
8000adde:	f6 06 12 00 	clz	r6,r11
8000ade2:	f7 bc 03 e1 	sublo	r12,-31
8000ade6:	f8 06 17 30 	movlo	r6,r12
8000adea:	f7 b6 02 01 	subhs	r6,1
8000adee:	e0 46 00 20 	cp.w	r6,32
8000adf2:	c0 d4       	brge	8000ae0c <__avr32_f64_mul_op1_subnormal+0x36>
8000adf4:	ec 0c 11 20 	rsub	r12,r6,32
8000adf8:	f6 06 09 4b 	lsl	r11,r11,r6
8000adfc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ae00:	18 4b       	or	r11,r12
8000ae02:	f4 06 09 4a 	lsl	r10,r10,r6
8000ae06:	20 b6       	sub	r6,11
8000ae08:	0c 17       	sub	r7,r6
8000ae0a:	ca ab       	rjmp	8000ad5e <__avr32_f64_mul+0x22>
8000ae0c:	f4 06 09 4b 	lsl	r11,r10,r6
8000ae10:	c6 40       	breq	8000aed8 <__avr32_f64_mul_res_zero>
8000ae12:	30 0a       	mov	r10,0
8000ae14:	20 b6       	sub	r6,11
8000ae16:	0c 17       	sub	r7,r6
8000ae18:	ca 3b       	rjmp	8000ad5e <__avr32_f64_mul+0x22>

8000ae1a <__avr32_f64_mul_op2_subnormal>:
8000ae1a:	e4 19 00 0f 	andh	r9,0xf
8000ae1e:	f0 0c 12 00 	clz	r12,r8
8000ae22:	f2 05 12 00 	clz	r5,r9
8000ae26:	f7 bc 03 ea 	sublo	r12,-22
8000ae2a:	f8 05 17 30 	movlo	r5,r12
8000ae2e:	f7 b5 02 0a 	subhs	r5,10
8000ae32:	e0 45 00 20 	cp.w	r5,32
8000ae36:	c0 d4       	brge	8000ae50 <__avr32_f64_mul_op2_subnormal+0x36>
8000ae38:	ea 0c 11 20 	rsub	r12,r5,32
8000ae3c:	f2 05 09 49 	lsl	r9,r9,r5
8000ae40:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ae44:	18 49       	or	r9,r12
8000ae46:	f0 05 09 48 	lsl	r8,r8,r5
8000ae4a:	20 25       	sub	r5,2
8000ae4c:	0a 16       	sub	r6,r5
8000ae4e:	c8 fb       	rjmp	8000ad6c <__avr32_f64_mul+0x30>
8000ae50:	f0 05 09 49 	lsl	r9,r8,r5
8000ae54:	c4 20       	breq	8000aed8 <__avr32_f64_mul_res_zero>
8000ae56:	30 08       	mov	r8,0
8000ae58:	20 25       	sub	r5,2
8000ae5a:	0a 16       	sub	r6,r5
8000ae5c:	c8 8b       	rjmp	8000ad6c <__avr32_f64_mul+0x30>

8000ae5e <__avr32_f64_mul_op_nan_or_inf>:
8000ae5e:	e4 19 00 0f 	andh	r9,0xf
8000ae62:	e4 1b 00 0f 	andh	r11,0xf
8000ae66:	14 4b       	or	r11,r10
8000ae68:	10 49       	or	r9,r8
8000ae6a:	e0 47 07 ff 	cp.w	r7,2047
8000ae6e:	c0 91       	brne	8000ae80 <__avr32_f64_mul_op1_not_naninf>
8000ae70:	58 0b       	cp.w	r11,0
8000ae72:	c3 81       	brne	8000aee2 <__avr32_f64_mul_res_nan>
8000ae74:	e0 46 07 ff 	cp.w	r6,2047
8000ae78:	c3 81       	brne	8000aee8 <__avr32_f64_mul_res_inf>
8000ae7a:	58 09       	cp.w	r9,0
8000ae7c:	c3 60       	breq	8000aee8 <__avr32_f64_mul_res_inf>
8000ae7e:	c3 28       	rjmp	8000aee2 <__avr32_f64_mul_res_nan>

8000ae80 <__avr32_f64_mul_op1_not_naninf>:
8000ae80:	58 09       	cp.w	r9,0
8000ae82:	c3 30       	breq	8000aee8 <__avr32_f64_mul_res_inf>
8000ae84:	c2 f8       	rjmp	8000aee2 <__avr32_f64_mul_res_nan>

8000ae86 <__avr32_f64_mul_res_subnormal>:
8000ae86:	5c 3c       	neg	r12
8000ae88:	2f fc       	sub	r12,-1
8000ae8a:	f1 bc 04 c0 	satu	r12,0x6
8000ae8e:	e0 4c 00 20 	cp.w	r12,32
8000ae92:	c1 14       	brge	8000aeb4 <__avr32_f64_mul_res_subnormal+0x2e>
8000ae94:	f8 08 11 20 	rsub	r8,r12,32
8000ae98:	0e 46       	or	r6,r7
8000ae9a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ae9e:	f4 08 09 49 	lsl	r9,r10,r8
8000aea2:	12 47       	or	r7,r9
8000aea4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aea8:	f6 08 09 49 	lsl	r9,r11,r8
8000aeac:	12 4a       	or	r10,r9
8000aeae:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000aeb2:	c8 3b       	rjmp	8000adb8 <__avr32_f64_mul+0x7c>
8000aeb4:	f8 08 11 20 	rsub	r8,r12,32
8000aeb8:	f9 b9 00 00 	moveq	r9,0
8000aebc:	c0 30       	breq	8000aec2 <__avr32_f64_mul_res_subnormal+0x3c>
8000aebe:	f6 08 09 49 	lsl	r9,r11,r8
8000aec2:	0e 46       	or	r6,r7
8000aec4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000aec8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aecc:	f3 ea 10 07 	or	r7,r9,r10
8000aed0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000aed4:	30 0b       	mov	r11,0
8000aed6:	c7 1b       	rjmp	8000adb8 <__avr32_f64_mul+0x7c>

8000aed8 <__avr32_f64_mul_res_zero>:
8000aed8:	1c 9b       	mov	r11,lr
8000aeda:	e6 1b 80 00 	andh	r11,0x8000,COH
8000aede:	30 0a       	mov	r10,0
8000aee0:	d8 22       	popm	r4-r7,pc

8000aee2 <__avr32_f64_mul_res_nan>:
8000aee2:	3f fb       	mov	r11,-1
8000aee4:	3f fa       	mov	r10,-1
8000aee6:	d8 22       	popm	r4-r7,pc

8000aee8 <__avr32_f64_mul_res_inf>:
8000aee8:	f0 6b 00 00 	mov	r11,-1048576
8000aeec:	ed be 00 1f 	bld	lr,0x1f
8000aef0:	ef bb 00 1f 	bst	r11,0x1f
8000aef4:	30 0a       	mov	r10,0
8000aef6:	d8 22       	popm	r4-r7,pc

8000aef8 <__avr32_f64_mul_op1_zero>:
8000aef8:	f7 e9 20 0b 	eor	r11,r11,r9
8000aefc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000af00:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000af04:	e0 4c 07 ff 	cp.w	r12,2047
8000af08:	5e 1c       	retne	r12
8000af0a:	3f fa       	mov	r10,-1
8000af0c:	3f fb       	mov	r11,-1
8000af0e:	5e fc       	retal	r12

8000af10 <__avr32_f64_sub_from_add>:
8000af10:	ee 19 80 00 	eorh	r9,0x8000

8000af14 <__avr32_f64_sub>:
8000af14:	f7 e9 20 0c 	eor	r12,r11,r9
8000af18:	e0 86 00 ca 	brmi	8000b0ac <__avr32_f64_add_from_sub>
8000af1c:	eb cd 40 e0 	pushm	r5-r7,lr
8000af20:	16 9c       	mov	r12,r11
8000af22:	e6 1c 80 00 	andh	r12,0x8000,COH
8000af26:	bf db       	cbr	r11,0x1f
8000af28:	bf d9       	cbr	r9,0x1f
8000af2a:	10 3a       	cp.w	r10,r8
8000af2c:	f2 0b 13 00 	cpc	r11,r9
8000af30:	c0 92       	brcc	8000af42 <__avr32_f64_sub+0x2e>
8000af32:	16 97       	mov	r7,r11
8000af34:	12 9b       	mov	r11,r9
8000af36:	0e 99       	mov	r9,r7
8000af38:	14 97       	mov	r7,r10
8000af3a:	10 9a       	mov	r10,r8
8000af3c:	0e 98       	mov	r8,r7
8000af3e:	ee 1c 80 00 	eorh	r12,0x8000
8000af42:	f6 07 16 14 	lsr	r7,r11,0x14
8000af46:	ab 7b       	lsl	r11,0xb
8000af48:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000af4c:	ab 7a       	lsl	r10,0xb
8000af4e:	bf bb       	sbr	r11,0x1f
8000af50:	f2 06 16 14 	lsr	r6,r9,0x14
8000af54:	c4 40       	breq	8000afdc <__avr32_f64_sub_opL_subnormal>
8000af56:	ab 79       	lsl	r9,0xb
8000af58:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000af5c:	ab 78       	lsl	r8,0xb
8000af5e:	bf b9       	sbr	r9,0x1f

8000af60 <__avr32_f64_sub_opL_subnormal_done>:
8000af60:	e0 47 07 ff 	cp.w	r7,2047
8000af64:	c4 f0       	breq	8000b002 <__avr32_f64_sub_opH_nan_or_inf>
8000af66:	0e 26       	rsub	r6,r7
8000af68:	c1 20       	breq	8000af8c <__avr32_f64_sub_shift_done>
8000af6a:	ec 05 11 20 	rsub	r5,r6,32
8000af6e:	e0 46 00 20 	cp.w	r6,32
8000af72:	c7 c2       	brcc	8000b06a <__avr32_f64_sub_longshift>
8000af74:	f0 05 09 4e 	lsl	lr,r8,r5
8000af78:	f2 05 09 45 	lsl	r5,r9,r5
8000af7c:	f0 06 0a 48 	lsr	r8,r8,r6
8000af80:	f2 06 0a 49 	lsr	r9,r9,r6
8000af84:	0a 48       	or	r8,r5
8000af86:	58 0e       	cp.w	lr,0
8000af88:	5f 1e       	srne	lr
8000af8a:	1c 48       	or	r8,lr

8000af8c <__avr32_f64_sub_shift_done>:
8000af8c:	10 1a       	sub	r10,r8
8000af8e:	f6 09 01 4b 	sbc	r11,r11,r9
8000af92:	f6 06 12 00 	clz	r6,r11
8000af96:	c0 e0       	breq	8000afb2 <__avr32_f64_sub_longnormalize_done>
8000af98:	c7 83       	brcs	8000b088 <__avr32_f64_sub_longnormalize>
8000af9a:	ec 0e 11 20 	rsub	lr,r6,32
8000af9e:	f6 06 09 4b 	lsl	r11,r11,r6
8000afa2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000afa6:	1c 4b       	or	r11,lr
8000afa8:	f4 06 09 4a 	lsl	r10,r10,r6
8000afac:	0c 17       	sub	r7,r6
8000afae:	e0 8a 00 39 	brle	8000b020 <__avr32_f64_sub_subnormal_result>

8000afb2 <__avr32_f64_sub_longnormalize_done>:
8000afb2:	f4 09 15 15 	lsl	r9,r10,0x15
8000afb6:	ab 9a       	lsr	r10,0xb
8000afb8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000afbc:	ab 9b       	lsr	r11,0xb
8000afbe:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000afc2:	18 4b       	or	r11,r12

8000afc4 <__avr32_f64_sub_round>:
8000afc4:	fc 17 80 00 	movh	r7,0x8000
8000afc8:	ed ba 00 00 	bld	r10,0x0
8000afcc:	f7 b7 01 ff 	subne	r7,-1
8000afd0:	0e 39       	cp.w	r9,r7
8000afd2:	5f 29       	srhs	r9
8000afd4:	12 0a       	add	r10,r9
8000afd6:	5c 0b       	acr	r11
8000afd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000afdc <__avr32_f64_sub_opL_subnormal>:
8000afdc:	ab 79       	lsl	r9,0xb
8000afde:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000afe2:	ab 78       	lsl	r8,0xb
8000afe4:	f3 e8 10 0e 	or	lr,r9,r8
8000afe8:	f9 b6 01 01 	movne	r6,1
8000afec:	ee 0e 11 00 	rsub	lr,r7,0
8000aff0:	f9 b7 00 01 	moveq	r7,1
8000aff4:	ef bb 00 1f 	bst	r11,0x1f
8000aff8:	f7 ea 10 0e 	or	lr,r11,r10
8000affc:	f9 b7 00 00 	moveq	r7,0
8000b000:	cb 0b       	rjmp	8000af60 <__avr32_f64_sub_opL_subnormal_done>

8000b002 <__avr32_f64_sub_opH_nan_or_inf>:
8000b002:	bf db       	cbr	r11,0x1f
8000b004:	f7 ea 10 0e 	or	lr,r11,r10
8000b008:	c0 81       	brne	8000b018 <__avr32_f64_sub_return_nan>
8000b00a:	e0 46 07 ff 	cp.w	r6,2047
8000b00e:	c0 50       	breq	8000b018 <__avr32_f64_sub_return_nan>
8000b010:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b014:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b018 <__avr32_f64_sub_return_nan>:
8000b018:	3f fa       	mov	r10,-1
8000b01a:	3f fb       	mov	r11,-1
8000b01c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b020 <__avr32_f64_sub_subnormal_result>:
8000b020:	5c 37       	neg	r7
8000b022:	2f f7       	sub	r7,-1
8000b024:	f1 b7 04 c0 	satu	r7,0x6
8000b028:	e0 47 00 20 	cp.w	r7,32
8000b02c:	c1 14       	brge	8000b04e <__avr32_f64_sub_subnormal_result+0x2e>
8000b02e:	ee 08 11 20 	rsub	r8,r7,32
8000b032:	f4 08 09 49 	lsl	r9,r10,r8
8000b036:	5f 16       	srne	r6
8000b038:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b03c:	0c 4a       	or	r10,r6
8000b03e:	f6 08 09 49 	lsl	r9,r11,r8
8000b042:	f5 e9 10 0a 	or	r10,r10,r9
8000b046:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b04a:	30 07       	mov	r7,0
8000b04c:	cb 3b       	rjmp	8000afb2 <__avr32_f64_sub_longnormalize_done>
8000b04e:	ee 08 11 40 	rsub	r8,r7,64
8000b052:	f6 08 09 49 	lsl	r9,r11,r8
8000b056:	14 49       	or	r9,r10
8000b058:	5f 16       	srne	r6
8000b05a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b05e:	0c 4a       	or	r10,r6
8000b060:	30 0b       	mov	r11,0
8000b062:	30 07       	mov	r7,0
8000b064:	ca 7b       	rjmp	8000afb2 <__avr32_f64_sub_longnormalize_done>
8000b066:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b06a <__avr32_f64_sub_longshift>:
8000b06a:	f1 b6 04 c0 	satu	r6,0x6
8000b06e:	f0 0e 17 00 	moveq	lr,r8
8000b072:	c0 40       	breq	8000b07a <__avr32_f64_sub_longshift+0x10>
8000b074:	f2 05 09 4e 	lsl	lr,r9,r5
8000b078:	10 4e       	or	lr,r8
8000b07a:	f2 06 0a 48 	lsr	r8,r9,r6
8000b07e:	30 09       	mov	r9,0
8000b080:	58 0e       	cp.w	lr,0
8000b082:	5f 1e       	srne	lr
8000b084:	1c 48       	or	r8,lr
8000b086:	c8 3b       	rjmp	8000af8c <__avr32_f64_sub_shift_done>

8000b088 <__avr32_f64_sub_longnormalize>:
8000b088:	f4 06 12 00 	clz	r6,r10
8000b08c:	f9 b7 03 00 	movlo	r7,0
8000b090:	f9 b6 03 00 	movlo	r6,0
8000b094:	f9 bc 03 00 	movlo	r12,0
8000b098:	f7 b6 02 e0 	subhs	r6,-32
8000b09c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b0a0:	30 0a       	mov	r10,0
8000b0a2:	0c 17       	sub	r7,r6
8000b0a4:	fe 9a ff be 	brle	8000b020 <__avr32_f64_sub_subnormal_result>
8000b0a8:	c8 5b       	rjmp	8000afb2 <__avr32_f64_sub_longnormalize_done>
8000b0aa:	d7 03       	nop

8000b0ac <__avr32_f64_add_from_sub>:
8000b0ac:	ee 19 80 00 	eorh	r9,0x8000

8000b0b0 <__avr32_f64_add>:
8000b0b0:	f7 e9 20 0c 	eor	r12,r11,r9
8000b0b4:	fe 96 ff 2e 	brmi	8000af10 <__avr32_f64_sub_from_add>
8000b0b8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b0bc:	16 9c       	mov	r12,r11
8000b0be:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b0c2:	bf db       	cbr	r11,0x1f
8000b0c4:	bf d9       	cbr	r9,0x1f
8000b0c6:	12 3b       	cp.w	r11,r9
8000b0c8:	c0 72       	brcc	8000b0d6 <__avr32_f64_add+0x26>
8000b0ca:	16 97       	mov	r7,r11
8000b0cc:	12 9b       	mov	r11,r9
8000b0ce:	0e 99       	mov	r9,r7
8000b0d0:	14 97       	mov	r7,r10
8000b0d2:	10 9a       	mov	r10,r8
8000b0d4:	0e 98       	mov	r8,r7
8000b0d6:	30 0e       	mov	lr,0
8000b0d8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b0dc:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b0e0:	b5 ab       	sbr	r11,0x14
8000b0e2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b0e6:	c6 20       	breq	8000b1aa <__avr32_f64_add_op2_subnormal>
8000b0e8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b0ec:	b5 a9       	sbr	r9,0x14
8000b0ee:	e0 47 07 ff 	cp.w	r7,2047
8000b0f2:	c2 80       	breq	8000b142 <__avr32_f64_add_opH_nan_or_inf>
8000b0f4:	0e 26       	rsub	r6,r7
8000b0f6:	c1 20       	breq	8000b11a <__avr32_f64_add_shift_done>
8000b0f8:	e0 46 00 36 	cp.w	r6,54
8000b0fc:	c1 52       	brcc	8000b126 <__avr32_f64_add_res_of_done>
8000b0fe:	ec 05 11 20 	rsub	r5,r6,32
8000b102:	e0 46 00 20 	cp.w	r6,32
8000b106:	c3 52       	brcc	8000b170 <__avr32_f64_add_longshift>
8000b108:	f0 05 09 4e 	lsl	lr,r8,r5
8000b10c:	f2 05 09 45 	lsl	r5,r9,r5
8000b110:	f0 06 0a 48 	lsr	r8,r8,r6
8000b114:	f2 06 0a 49 	lsr	r9,r9,r6
8000b118:	0a 48       	or	r8,r5

8000b11a <__avr32_f64_add_shift_done>:
8000b11a:	10 0a       	add	r10,r8
8000b11c:	f6 09 00 4b 	adc	r11,r11,r9
8000b120:	ed bb 00 15 	bld	r11,0x15
8000b124:	c3 40       	breq	8000b18c <__avr32_f64_add_res_of>

8000b126 <__avr32_f64_add_res_of_done>:
8000b126:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b12a:	18 4b       	or	r11,r12

8000b12c <__avr32_f64_add_round>:
8000b12c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b130:	18 4e       	or	lr,r12
8000b132:	ee 1e 80 00 	eorh	lr,0x8000
8000b136:	f1 be 04 20 	satu	lr,0x1
8000b13a:	1c 0a       	add	r10,lr
8000b13c:	5c 0b       	acr	r11
8000b13e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b142 <__avr32_f64_add_opH_nan_or_inf>:
8000b142:	b5 cb       	cbr	r11,0x14
8000b144:	f7 ea 10 0e 	or	lr,r11,r10
8000b148:	c1 01       	brne	8000b168 <__avr32_f64_add_return_nan>
8000b14a:	e0 46 07 ff 	cp.w	r6,2047
8000b14e:	c0 30       	breq	8000b154 <__avr32_f64_add_opL_nan_or_inf>
8000b150:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b154 <__avr32_f64_add_opL_nan_or_inf>:
8000b154:	b5 c9       	cbr	r9,0x14
8000b156:	f3 e8 10 0e 	or	lr,r9,r8
8000b15a:	c0 71       	brne	8000b168 <__avr32_f64_add_return_nan>
8000b15c:	30 0a       	mov	r10,0
8000b15e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b162:	18 4b       	or	r11,r12
8000b164:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b168 <__avr32_f64_add_return_nan>:
8000b168:	3f fa       	mov	r10,-1
8000b16a:	3f fb       	mov	r11,-1
8000b16c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b170 <__avr32_f64_add_longshift>:
8000b170:	f1 b6 04 c0 	satu	r6,0x6
8000b174:	f0 0e 17 00 	moveq	lr,r8
8000b178:	c0 60       	breq	8000b184 <__avr32_f64_add_longshift+0x14>
8000b17a:	f2 05 09 4e 	lsl	lr,r9,r5
8000b17e:	58 08       	cp.w	r8,0
8000b180:	5f 18       	srne	r8
8000b182:	10 4e       	or	lr,r8
8000b184:	f2 06 0a 48 	lsr	r8,r9,r6
8000b188:	30 09       	mov	r9,0
8000b18a:	cc 8b       	rjmp	8000b11a <__avr32_f64_add_shift_done>

8000b18c <__avr32_f64_add_res_of>:
8000b18c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b190:	a1 9b       	lsr	r11,0x1
8000b192:	5d 0a       	ror	r10
8000b194:	5d 0e       	ror	lr
8000b196:	2f f7       	sub	r7,-1
8000b198:	e0 47 07 ff 	cp.w	r7,2047
8000b19c:	f9 ba 00 00 	moveq	r10,0
8000b1a0:	f9 bb 00 00 	moveq	r11,0
8000b1a4:	f9 be 00 00 	moveq	lr,0
8000b1a8:	cb fb       	rjmp	8000b126 <__avr32_f64_add_res_of_done>

8000b1aa <__avr32_f64_add_op2_subnormal>:
8000b1aa:	30 16       	mov	r6,1
8000b1ac:	58 07       	cp.w	r7,0
8000b1ae:	ca 01       	brne	8000b0ee <__avr32_f64_add+0x3e>
8000b1b0:	b5 cb       	cbr	r11,0x14
8000b1b2:	10 0a       	add	r10,r8
8000b1b4:	f6 09 00 4b 	adc	r11,r11,r9
8000b1b8:	18 4b       	or	r11,r12
8000b1ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b1be:	d7 03       	nop

8000b1c0 <__avr32_f64_to_u32>:
8000b1c0:	58 0b       	cp.w	r11,0
8000b1c2:	5e 6d       	retmi	0

8000b1c4 <__avr32_f64_to_s32>:
8000b1c4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b1c8:	b5 9c       	lsr	r12,0x15
8000b1ca:	e0 2c 03 ff 	sub	r12,1023
8000b1ce:	5e 3d       	retlo	0
8000b1d0:	f8 0c 11 1f 	rsub	r12,r12,31
8000b1d4:	16 99       	mov	r9,r11
8000b1d6:	ab 7b       	lsl	r11,0xb
8000b1d8:	bf bb       	sbr	r11,0x1f
8000b1da:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b1de:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b1e2:	a1 79       	lsl	r9,0x1
8000b1e4:	5e 2b       	reths	r11
8000b1e6:	5c 3b       	neg	r11
8000b1e8:	5e fb       	retal	r11

8000b1ea <__avr32_u32_to_f64>:
8000b1ea:	f8 cb 00 00 	sub	r11,r12,0
8000b1ee:	30 0c       	mov	r12,0
8000b1f0:	c0 38       	rjmp	8000b1f6 <__avr32_s32_to_f64+0x4>

8000b1f2 <__avr32_s32_to_f64>:
8000b1f2:	18 9b       	mov	r11,r12
8000b1f4:	5c 4b       	abs	r11
8000b1f6:	30 0a       	mov	r10,0
8000b1f8:	5e 0b       	reteq	r11
8000b1fa:	d4 01       	pushm	lr
8000b1fc:	e0 69 04 1e 	mov	r9,1054
8000b200:	f6 08 12 00 	clz	r8,r11
8000b204:	c1 70       	breq	8000b232 <__avr32_s32_to_f64+0x40>
8000b206:	c0 c3       	brcs	8000b21e <__avr32_s32_to_f64+0x2c>
8000b208:	f0 0e 11 20 	rsub	lr,r8,32
8000b20c:	f6 08 09 4b 	lsl	r11,r11,r8
8000b210:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b214:	1c 4b       	or	r11,lr
8000b216:	f4 08 09 4a 	lsl	r10,r10,r8
8000b21a:	10 19       	sub	r9,r8
8000b21c:	c0 b8       	rjmp	8000b232 <__avr32_s32_to_f64+0x40>
8000b21e:	f4 08 12 00 	clz	r8,r10
8000b222:	f9 b8 03 00 	movlo	r8,0
8000b226:	f7 b8 02 e0 	subhs	r8,-32
8000b22a:	f4 08 09 4b 	lsl	r11,r10,r8
8000b22e:	30 0a       	mov	r10,0
8000b230:	10 19       	sub	r9,r8
8000b232:	58 09       	cp.w	r9,0
8000b234:	e0 89 00 30 	brgt	8000b294 <__avr32_s32_to_f64+0xa2>
8000b238:	5c 39       	neg	r9
8000b23a:	2f f9       	sub	r9,-1
8000b23c:	e0 49 00 36 	cp.w	r9,54
8000b240:	c0 43       	brcs	8000b248 <__avr32_s32_to_f64+0x56>
8000b242:	30 0b       	mov	r11,0
8000b244:	30 0a       	mov	r10,0
8000b246:	c2 68       	rjmp	8000b292 <__avr32_s32_to_f64+0xa0>
8000b248:	2f 69       	sub	r9,-10
8000b24a:	f2 08 11 20 	rsub	r8,r9,32
8000b24e:	e0 49 00 20 	cp.w	r9,32
8000b252:	c0 b2       	brcc	8000b268 <__avr32_s32_to_f64+0x76>
8000b254:	f4 08 09 4e 	lsl	lr,r10,r8
8000b258:	f6 08 09 48 	lsl	r8,r11,r8
8000b25c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b260:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b264:	10 4b       	or	r11,r8
8000b266:	c0 88       	rjmp	8000b276 <__avr32_s32_to_f64+0x84>
8000b268:	f6 08 09 4e 	lsl	lr,r11,r8
8000b26c:	14 4e       	or	lr,r10
8000b26e:	16 9a       	mov	r10,r11
8000b270:	30 0b       	mov	r11,0
8000b272:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b276:	ed ba 00 00 	bld	r10,0x0
8000b27a:	c0 92       	brcc	8000b28c <__avr32_s32_to_f64+0x9a>
8000b27c:	1c 7e       	tst	lr,lr
8000b27e:	c0 41       	brne	8000b286 <__avr32_s32_to_f64+0x94>
8000b280:	ed ba 00 01 	bld	r10,0x1
8000b284:	c0 42       	brcc	8000b28c <__avr32_s32_to_f64+0x9a>
8000b286:	2f fa       	sub	r10,-1
8000b288:	f7 bb 02 ff 	subhs	r11,-1
8000b28c:	5c fc       	rol	r12
8000b28e:	5d 0b       	ror	r11
8000b290:	5d 0a       	ror	r10
8000b292:	d8 02       	popm	pc
8000b294:	e0 68 03 ff 	mov	r8,1023
8000b298:	ed ba 00 0b 	bld	r10,0xb
8000b29c:	f7 b8 00 ff 	subeq	r8,-1
8000b2a0:	10 0a       	add	r10,r8
8000b2a2:	5c 0b       	acr	r11
8000b2a4:	f7 b9 03 fe 	sublo	r9,-2
8000b2a8:	e0 49 07 ff 	cp.w	r9,2047
8000b2ac:	c0 55       	brlt	8000b2b6 <__avr32_s32_to_f64+0xc4>
8000b2ae:	30 0a       	mov	r10,0
8000b2b0:	fc 1b ff e0 	movh	r11,0xffe0
8000b2b4:	c0 c8       	rjmp	8000b2cc <__floatsidf_return_op1>
8000b2b6:	ed bb 00 1f 	bld	r11,0x1f
8000b2ba:	f7 b9 01 01 	subne	r9,1
8000b2be:	ab 9a       	lsr	r10,0xb
8000b2c0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b2c4:	a1 7b       	lsl	r11,0x1
8000b2c6:	ab 9b       	lsr	r11,0xb
8000b2c8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b2cc <__floatsidf_return_op1>:
8000b2cc:	a1 7c       	lsl	r12,0x1
8000b2ce:	5d 0b       	ror	r11
8000b2d0:	d8 02       	popm	pc

8000b2d2 <__avr32_f64_cmp_eq>:
8000b2d2:	10 3a       	cp.w	r10,r8
8000b2d4:	f2 0b 13 00 	cpc	r11,r9
8000b2d8:	c0 80       	breq	8000b2e8 <__avr32_f64_cmp_eq+0x16>
8000b2da:	a1 7b       	lsl	r11,0x1
8000b2dc:	a1 79       	lsl	r9,0x1
8000b2de:	14 4b       	or	r11,r10
8000b2e0:	12 4b       	or	r11,r9
8000b2e2:	10 4b       	or	r11,r8
8000b2e4:	5e 0f       	reteq	1
8000b2e6:	5e fd       	retal	0
8000b2e8:	a1 7b       	lsl	r11,0x1
8000b2ea:	fc 1c ff e0 	movh	r12,0xffe0
8000b2ee:	58 0a       	cp.w	r10,0
8000b2f0:	f8 0b 13 00 	cpc	r11,r12
8000b2f4:	5e 8f       	retls	1
8000b2f6:	5e fd       	retal	0

8000b2f8 <__avr32_f64_cmp_ge>:
8000b2f8:	1a de       	st.w	--sp,lr
8000b2fa:	1a d7       	st.w	--sp,r7
8000b2fc:	a1 7b       	lsl	r11,0x1
8000b2fe:	5f 3c       	srlo	r12
8000b300:	a1 79       	lsl	r9,0x1
8000b302:	5f 37       	srlo	r7
8000b304:	5c fc       	rol	r12
8000b306:	fc 1e ff e0 	movh	lr,0xffe0
8000b30a:	58 0a       	cp.w	r10,0
8000b30c:	fc 0b 13 00 	cpc	r11,lr
8000b310:	e0 8b 00 1d 	brhi	8000b34a <__avr32_f64_cmp_ge+0x52>
8000b314:	58 08       	cp.w	r8,0
8000b316:	fc 09 13 00 	cpc	r9,lr
8000b31a:	e0 8b 00 18 	brhi	8000b34a <__avr32_f64_cmp_ge+0x52>
8000b31e:	58 0b       	cp.w	r11,0
8000b320:	f5 ba 00 00 	subfeq	r10,0
8000b324:	c1 50       	breq	8000b34e <__avr32_f64_cmp_ge+0x56>
8000b326:	1b 07       	ld.w	r7,sp++
8000b328:	1b 0e       	ld.w	lr,sp++
8000b32a:	58 3c       	cp.w	r12,3
8000b32c:	c0 a0       	breq	8000b340 <__avr32_f64_cmp_ge+0x48>
8000b32e:	58 1c       	cp.w	r12,1
8000b330:	c0 33       	brcs	8000b336 <__avr32_f64_cmp_ge+0x3e>
8000b332:	5e 0f       	reteq	1
8000b334:	5e 1d       	retne	0
8000b336:	10 3a       	cp.w	r10,r8
8000b338:	f2 0b 13 00 	cpc	r11,r9
8000b33c:	5e 2f       	reths	1
8000b33e:	5e 3d       	retlo	0
8000b340:	14 38       	cp.w	r8,r10
8000b342:	f6 09 13 00 	cpc	r9,r11
8000b346:	5e 2f       	reths	1
8000b348:	5e 3d       	retlo	0
8000b34a:	1b 07       	ld.w	r7,sp++
8000b34c:	d8 0a       	popm	pc,r12=0
8000b34e:	58 17       	cp.w	r7,1
8000b350:	5f 0c       	sreq	r12
8000b352:	58 09       	cp.w	r9,0
8000b354:	f5 b8 00 00 	subfeq	r8,0
8000b358:	1b 07       	ld.w	r7,sp++
8000b35a:	1b 0e       	ld.w	lr,sp++
8000b35c:	5e 0f       	reteq	1
8000b35e:	5e fc       	retal	r12

8000b360 <__avr32_f64_cmp_lt>:
8000b360:	1a de       	st.w	--sp,lr
8000b362:	1a d7       	st.w	--sp,r7
8000b364:	a1 7b       	lsl	r11,0x1
8000b366:	5f 3c       	srlo	r12
8000b368:	a1 79       	lsl	r9,0x1
8000b36a:	5f 37       	srlo	r7
8000b36c:	5c fc       	rol	r12
8000b36e:	fc 1e ff e0 	movh	lr,0xffe0
8000b372:	58 0a       	cp.w	r10,0
8000b374:	fc 0b 13 00 	cpc	r11,lr
8000b378:	e0 8b 00 1d 	brhi	8000b3b2 <__avr32_f64_cmp_lt+0x52>
8000b37c:	58 08       	cp.w	r8,0
8000b37e:	fc 09 13 00 	cpc	r9,lr
8000b382:	e0 8b 00 18 	brhi	8000b3b2 <__avr32_f64_cmp_lt+0x52>
8000b386:	58 0b       	cp.w	r11,0
8000b388:	f5 ba 00 00 	subfeq	r10,0
8000b38c:	c1 50       	breq	8000b3b6 <__avr32_f64_cmp_lt+0x56>
8000b38e:	1b 07       	ld.w	r7,sp++
8000b390:	1b 0e       	ld.w	lr,sp++
8000b392:	58 3c       	cp.w	r12,3
8000b394:	c0 a0       	breq	8000b3a8 <__avr32_f64_cmp_lt+0x48>
8000b396:	58 1c       	cp.w	r12,1
8000b398:	c0 33       	brcs	8000b39e <__avr32_f64_cmp_lt+0x3e>
8000b39a:	5e 0d       	reteq	0
8000b39c:	5e 1f       	retne	1
8000b39e:	10 3a       	cp.w	r10,r8
8000b3a0:	f2 0b 13 00 	cpc	r11,r9
8000b3a4:	5e 2d       	reths	0
8000b3a6:	5e 3f       	retlo	1
8000b3a8:	14 38       	cp.w	r8,r10
8000b3aa:	f6 09 13 00 	cpc	r9,r11
8000b3ae:	5e 2d       	reths	0
8000b3b0:	5e 3f       	retlo	1
8000b3b2:	1b 07       	ld.w	r7,sp++
8000b3b4:	d8 0a       	popm	pc,r12=0
8000b3b6:	58 17       	cp.w	r7,1
8000b3b8:	5f 1c       	srne	r12
8000b3ba:	58 09       	cp.w	r9,0
8000b3bc:	f5 b8 00 00 	subfeq	r8,0
8000b3c0:	1b 07       	ld.w	r7,sp++
8000b3c2:	1b 0e       	ld.w	lr,sp++
8000b3c4:	5e 0d       	reteq	0
8000b3c6:	5e fc       	retal	r12

8000b3c8 <__avr32_f64_div>:
8000b3c8:	eb cd 40 ff 	pushm	r0-r7,lr
8000b3cc:	f7 e9 20 0e 	eor	lr,r11,r9
8000b3d0:	f6 07 16 14 	lsr	r7,r11,0x14
8000b3d4:	a9 7b       	lsl	r11,0x9
8000b3d6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b3da:	a9 7a       	lsl	r10,0x9
8000b3dc:	bd bb       	sbr	r11,0x1d
8000b3de:	e4 1b 3f ff 	andh	r11,0x3fff
8000b3e2:	ab d7       	cbr	r7,0xb
8000b3e4:	e0 80 00 cc 	breq	8000b57c <__avr32_f64_div_round_subnormal+0x54>
8000b3e8:	e0 47 07 ff 	cp.w	r7,2047
8000b3ec:	e0 84 00 b5 	brge	8000b556 <__avr32_f64_div_round_subnormal+0x2e>
8000b3f0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b3f4:	a9 79       	lsl	r9,0x9
8000b3f6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b3fa:	a9 78       	lsl	r8,0x9
8000b3fc:	bd b9       	sbr	r9,0x1d
8000b3fe:	e4 19 3f ff 	andh	r9,0x3fff
8000b402:	ab d6       	cbr	r6,0xb
8000b404:	e0 80 00 e2 	breq	8000b5c8 <__avr32_f64_div_round_subnormal+0xa0>
8000b408:	e0 46 07 ff 	cp.w	r6,2047
8000b40c:	e0 84 00 b2 	brge	8000b570 <__avr32_f64_div_round_subnormal+0x48>
8000b410:	0c 17       	sub	r7,r6
8000b412:	fe 37 fc 01 	sub	r7,-1023
8000b416:	fc 1c 80 00 	movh	r12,0x8000
8000b41a:	f8 03 16 01 	lsr	r3,r12,0x1
8000b41e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b422:	5c d4       	com	r4
8000b424:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b428:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b42c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b430:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b434:	ea 03 15 02 	lsl	r3,r5,0x2
8000b438:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b43c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b440:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b444:	ea 03 15 02 	lsl	r3,r5,0x2
8000b448:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b44c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b450:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b454:	ea 03 15 02 	lsl	r3,r5,0x2
8000b458:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b45c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b460:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b464:	02 04       	add	r4,r1
8000b466:	5c 05       	acr	r5
8000b468:	a3 65       	lsl	r5,0x2
8000b46a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b46e:	a3 64       	lsl	r4,0x2
8000b470:	5c 34       	neg	r4
8000b472:	f8 05 01 45 	sbc	r5,r12,r5
8000b476:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b47a:	e4 05 07 40 	macu.d	r0,r2,r5
8000b47e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b482:	02 04       	add	r4,r1
8000b484:	5c 05       	acr	r5
8000b486:	ea 03 15 02 	lsl	r3,r5,0x2
8000b48a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b48e:	e8 02 15 02 	lsl	r2,r4,0x2
8000b492:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b496:	e4 09 07 40 	macu.d	r0,r2,r9
8000b49a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b49e:	02 04       	add	r4,r1
8000b4a0:	5c 05       	acr	r5
8000b4a2:	a3 65       	lsl	r5,0x2
8000b4a4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b4a8:	a3 64       	lsl	r4,0x2
8000b4aa:	5c 34       	neg	r4
8000b4ac:	f8 05 01 45 	sbc	r5,r12,r5
8000b4b0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b4b4:	e4 05 07 40 	macu.d	r0,r2,r5
8000b4b8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b4bc:	02 04       	add	r4,r1
8000b4be:	5c 05       	acr	r5
8000b4c0:	ea 03 15 02 	lsl	r3,r5,0x2
8000b4c4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b4c8:	e8 02 15 02 	lsl	r2,r4,0x2
8000b4cc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b4d0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b4d4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b4d8:	02 02       	add	r2,r1
8000b4da:	5c 03       	acr	r3
8000b4dc:	ed b3 00 1c 	bld	r3,0x1c
8000b4e0:	c0 90       	breq	8000b4f2 <__avr32_f64_div+0x12a>
8000b4e2:	a1 72       	lsl	r2,0x1
8000b4e4:	5c f3       	rol	r3
8000b4e6:	20 17       	sub	r7,1
8000b4e8:	a3 9a       	lsr	r10,0x3
8000b4ea:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b4ee:	a3 9b       	lsr	r11,0x3
8000b4f0:	c0 58       	rjmp	8000b4fa <__avr32_f64_div+0x132>
8000b4f2:	a5 8a       	lsr	r10,0x4
8000b4f4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b4f8:	a5 8b       	lsr	r11,0x4
8000b4fa:	58 07       	cp.w	r7,0
8000b4fc:	e0 8a 00 8b 	brle	8000b612 <__avr32_f64_div_res_subnormal>
8000b500:	e0 12 ff 00 	andl	r2,0xff00
8000b504:	e8 12 00 80 	orl	r2,0x80
8000b508:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b50c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b510:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b514:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b518:	00 05       	add	r5,r0
8000b51a:	f0 01 00 48 	adc	r8,r8,r1
8000b51e:	5c 09       	acr	r9
8000b520:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b524:	58 04       	cp.w	r4,0
8000b526:	5c 25       	cpc	r5

8000b528 <__avr32_f64_div_round_subnormal>:
8000b528:	f4 08 13 00 	cpc	r8,r10
8000b52c:	f6 09 13 00 	cpc	r9,r11
8000b530:	5f 36       	srlo	r6
8000b532:	f8 06 17 00 	moveq	r6,r12
8000b536:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b53a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b53e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b542:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b546:	ed be 00 1f 	bld	lr,0x1f
8000b54a:	ef bb 00 1f 	bst	r11,0x1f
8000b54e:	0c 0a       	add	r10,r6
8000b550:	5c 0b       	acr	r11
8000b552:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b556:	e4 1b 00 0f 	andh	r11,0xf
8000b55a:	14 4b       	or	r11,r10
8000b55c:	e0 81 00 a7 	brne	8000b6aa <__avr32_f64_div_res_subnormal+0x98>
8000b560:	f2 06 16 14 	lsr	r6,r9,0x14
8000b564:	ab d6       	cbr	r6,0xb
8000b566:	e0 46 07 ff 	cp.w	r6,2047
8000b56a:	e0 81 00 a4 	brne	8000b6b2 <__avr32_f64_div_res_subnormal+0xa0>
8000b56e:	c9 e8       	rjmp	8000b6aa <__avr32_f64_div_res_subnormal+0x98>
8000b570:	e4 19 00 0f 	andh	r9,0xf
8000b574:	10 49       	or	r9,r8
8000b576:	e0 81 00 9a 	brne	8000b6aa <__avr32_f64_div_res_subnormal+0x98>
8000b57a:	c9 28       	rjmp	8000b69e <__avr32_f64_div_res_subnormal+0x8c>
8000b57c:	a3 7b       	lsl	r11,0x3
8000b57e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b582:	a3 7a       	lsl	r10,0x3
8000b584:	f5 eb 10 04 	or	r4,r10,r11
8000b588:	e0 80 00 a0 	breq	8000b6c8 <__avr32_f64_div_op1_zero>
8000b58c:	f6 04 12 00 	clz	r4,r11
8000b590:	c1 70       	breq	8000b5be <__avr32_f64_div_round_subnormal+0x96>
8000b592:	c0 c3       	brcs	8000b5aa <__avr32_f64_div_round_subnormal+0x82>
8000b594:	e8 05 11 20 	rsub	r5,r4,32
8000b598:	f6 04 09 4b 	lsl	r11,r11,r4
8000b59c:	f4 05 0a 45 	lsr	r5,r10,r5
8000b5a0:	0a 4b       	or	r11,r5
8000b5a2:	f4 04 09 4a 	lsl	r10,r10,r4
8000b5a6:	08 17       	sub	r7,r4
8000b5a8:	c0 b8       	rjmp	8000b5be <__avr32_f64_div_round_subnormal+0x96>
8000b5aa:	f4 04 12 00 	clz	r4,r10
8000b5ae:	f9 b4 03 00 	movlo	r4,0
8000b5b2:	f7 b4 02 e0 	subhs	r4,-32
8000b5b6:	f4 04 09 4b 	lsl	r11,r10,r4
8000b5ba:	30 0a       	mov	r10,0
8000b5bc:	08 17       	sub	r7,r4
8000b5be:	a3 8a       	lsr	r10,0x2
8000b5c0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b5c4:	a3 8b       	lsr	r11,0x2
8000b5c6:	c1 1b       	rjmp	8000b3e8 <__avr32_f64_div+0x20>
8000b5c8:	a3 79       	lsl	r9,0x3
8000b5ca:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b5ce:	a3 78       	lsl	r8,0x3
8000b5d0:	f3 e8 10 04 	or	r4,r9,r8
8000b5d4:	c6 f0       	breq	8000b6b2 <__avr32_f64_div_res_subnormal+0xa0>
8000b5d6:	f2 04 12 00 	clz	r4,r9
8000b5da:	c1 70       	breq	8000b608 <__avr32_f64_div_round_subnormal+0xe0>
8000b5dc:	c0 c3       	brcs	8000b5f4 <__avr32_f64_div_round_subnormal+0xcc>
8000b5de:	e8 05 11 20 	rsub	r5,r4,32
8000b5e2:	f2 04 09 49 	lsl	r9,r9,r4
8000b5e6:	f0 05 0a 45 	lsr	r5,r8,r5
8000b5ea:	0a 49       	or	r9,r5
8000b5ec:	f0 04 09 48 	lsl	r8,r8,r4
8000b5f0:	08 16       	sub	r6,r4
8000b5f2:	c0 b8       	rjmp	8000b608 <__avr32_f64_div_round_subnormal+0xe0>
8000b5f4:	f0 04 12 00 	clz	r4,r8
8000b5f8:	f9 b4 03 00 	movlo	r4,0
8000b5fc:	f7 b4 02 e0 	subhs	r4,-32
8000b600:	f0 04 09 49 	lsl	r9,r8,r4
8000b604:	30 08       	mov	r8,0
8000b606:	08 16       	sub	r6,r4
8000b608:	a3 88       	lsr	r8,0x2
8000b60a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b60e:	a3 89       	lsr	r9,0x2
8000b610:	cf ca       	rjmp	8000b408 <__avr32_f64_div+0x40>

8000b612 <__avr32_f64_div_res_subnormal>:
8000b612:	5c 37       	neg	r7
8000b614:	2f f7       	sub	r7,-1
8000b616:	f1 b7 04 c0 	satu	r7,0x6
8000b61a:	e0 47 00 20 	cp.w	r7,32
8000b61e:	c1 54       	brge	8000b648 <__avr32_f64_div_res_subnormal+0x36>
8000b620:	ee 06 11 20 	rsub	r6,r7,32
8000b624:	e4 07 0a 42 	lsr	r2,r2,r7
8000b628:	e6 06 09 4c 	lsl	r12,r3,r6
8000b62c:	18 42       	or	r2,r12
8000b62e:	e6 07 0a 43 	lsr	r3,r3,r7
8000b632:	f4 06 09 41 	lsl	r1,r10,r6
8000b636:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b63a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b63e:	18 4a       	or	r10,r12
8000b640:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b644:	30 00       	mov	r0,0
8000b646:	c1 58       	rjmp	8000b670 <__avr32_f64_div_res_subnormal+0x5e>
8000b648:	ee 06 11 20 	rsub	r6,r7,32
8000b64c:	f9 b0 00 00 	moveq	r0,0
8000b650:	f9 bc 00 00 	moveq	r12,0
8000b654:	c0 50       	breq	8000b65e <__avr32_f64_div_res_subnormal+0x4c>
8000b656:	f4 06 09 40 	lsl	r0,r10,r6
8000b65a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b65e:	e6 07 0a 42 	lsr	r2,r3,r7
8000b662:	30 03       	mov	r3,0
8000b664:	f4 07 0a 41 	lsr	r1,r10,r7
8000b668:	18 41       	or	r1,r12
8000b66a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b66e:	30 0b       	mov	r11,0
8000b670:	e0 12 ff 00 	andl	r2,0xff00
8000b674:	e8 12 00 80 	orl	r2,0x80
8000b678:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b67c:	e4 09 07 46 	macu.d	r6,r2,r9
8000b680:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b684:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b688:	0c 05       	add	r5,r6
8000b68a:	f0 07 00 48 	adc	r8,r8,r7
8000b68e:	5c 09       	acr	r9
8000b690:	30 07       	mov	r7,0
8000b692:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b696:	00 34       	cp.w	r4,r0
8000b698:	e2 05 13 00 	cpc	r5,r1
8000b69c:	c4 6b       	rjmp	8000b528 <__avr32_f64_div_round_subnormal>
8000b69e:	1c 9b       	mov	r11,lr
8000b6a0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b6a4:	30 0a       	mov	r10,0
8000b6a6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b6aa:	3f fb       	mov	r11,-1
8000b6ac:	30 0a       	mov	r10,0
8000b6ae:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b6b2:	f5 eb 10 04 	or	r4,r10,r11
8000b6b6:	c0 90       	breq	8000b6c8 <__avr32_f64_div_op1_zero>
8000b6b8:	1c 9b       	mov	r11,lr
8000b6ba:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b6be:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b6c2:	30 0a       	mov	r10,0
8000b6c4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b6c8 <__avr32_f64_div_op1_zero>:
8000b6c8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b6cc:	ce f0       	breq	8000b6aa <__avr32_f64_div_res_subnormal+0x98>
8000b6ce:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b6d2:	e0 44 07 ff 	cp.w	r4,2047
8000b6d6:	ce 41       	brne	8000b69e <__avr32_f64_div_res_subnormal+0x8c>
8000b6d8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b6dc:	ce 10       	breq	8000b69e <__avr32_f64_div_res_subnormal+0x8c>
8000b6de:	ce 6b       	rjmp	8000b6aa <__avr32_f64_div_res_subnormal+0x98>

8000b6e0 <__avr32_udiv64>:
8000b6e0:	d4 31       	pushm	r0-r7,lr
8000b6e2:	1a 97       	mov	r7,sp
8000b6e4:	20 3d       	sub	sp,12
8000b6e6:	10 9c       	mov	r12,r8
8000b6e8:	12 9e       	mov	lr,r9
8000b6ea:	14 93       	mov	r3,r10
8000b6ec:	58 09       	cp.w	r9,0
8000b6ee:	e0 81 00 bd 	brne	8000b868 <__avr32_udiv64+0x188>
8000b6f2:	16 38       	cp.w	r8,r11
8000b6f4:	e0 88 00 40 	brls	8000b774 <__avr32_udiv64+0x94>
8000b6f8:	f0 08 12 00 	clz	r8,r8
8000b6fc:	c0 d0       	breq	8000b716 <__avr32_udiv64+0x36>
8000b6fe:	f6 08 09 4b 	lsl	r11,r11,r8
8000b702:	f0 09 11 20 	rsub	r9,r8,32
8000b706:	f8 08 09 4c 	lsl	r12,r12,r8
8000b70a:	f4 09 0a 49 	lsr	r9,r10,r9
8000b70e:	f4 08 09 43 	lsl	r3,r10,r8
8000b712:	f3 eb 10 0b 	or	r11,r9,r11
8000b716:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b71a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b71e:	f6 0e 0d 00 	divu	r0,r11,lr
8000b722:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b726:	00 99       	mov	r9,r0
8000b728:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b72c:	e0 0a 02 48 	mul	r8,r0,r10
8000b730:	10 3b       	cp.w	r11,r8
8000b732:	c0 a2       	brcc	8000b746 <__avr32_udiv64+0x66>
8000b734:	20 19       	sub	r9,1
8000b736:	18 0b       	add	r11,r12
8000b738:	18 3b       	cp.w	r11,r12
8000b73a:	c0 63       	brcs	8000b746 <__avr32_udiv64+0x66>
8000b73c:	10 3b       	cp.w	r11,r8
8000b73e:	f7 b9 03 01 	sublo	r9,1
8000b742:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b746:	f6 08 01 01 	sub	r1,r11,r8
8000b74a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b74e:	e2 0e 0d 00 	divu	r0,r1,lr
8000b752:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b756:	00 98       	mov	r8,r0
8000b758:	e0 0a 02 4a 	mul	r10,r0,r10
8000b75c:	14 33       	cp.w	r3,r10
8000b75e:	c0 82       	brcc	8000b76e <__avr32_udiv64+0x8e>
8000b760:	20 18       	sub	r8,1
8000b762:	18 03       	add	r3,r12
8000b764:	18 33       	cp.w	r3,r12
8000b766:	c0 43       	brcs	8000b76e <__avr32_udiv64+0x8e>
8000b768:	14 33       	cp.w	r3,r10
8000b76a:	f7 b8 03 01 	sublo	r8,1
8000b76e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b772:	cd f8       	rjmp	8000b930 <__avr32_udiv64+0x250>
8000b774:	58 08       	cp.w	r8,0
8000b776:	c0 51       	brne	8000b780 <__avr32_udiv64+0xa0>
8000b778:	30 19       	mov	r9,1
8000b77a:	f2 08 0d 08 	divu	r8,r9,r8
8000b77e:	10 9c       	mov	r12,r8
8000b780:	f8 06 12 00 	clz	r6,r12
8000b784:	c0 41       	brne	8000b78c <__avr32_udiv64+0xac>
8000b786:	18 1b       	sub	r11,r12
8000b788:	30 19       	mov	r9,1
8000b78a:	c4 08       	rjmp	8000b80a <__avr32_udiv64+0x12a>
8000b78c:	ec 01 11 20 	rsub	r1,r6,32
8000b790:	f4 01 0a 49 	lsr	r9,r10,r1
8000b794:	f8 06 09 4c 	lsl	r12,r12,r6
8000b798:	f6 06 09 48 	lsl	r8,r11,r6
8000b79c:	f6 01 0a 41 	lsr	r1,r11,r1
8000b7a0:	f3 e8 10 08 	or	r8,r9,r8
8000b7a4:	f8 03 16 10 	lsr	r3,r12,0x10
8000b7a8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b7ac:	e2 03 0d 00 	divu	r0,r1,r3
8000b7b0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b7b4:	00 9e       	mov	lr,r0
8000b7b6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b7ba:	e0 05 02 49 	mul	r9,r0,r5
8000b7be:	12 3b       	cp.w	r11,r9
8000b7c0:	c0 a2       	brcc	8000b7d4 <__avr32_udiv64+0xf4>
8000b7c2:	20 1e       	sub	lr,1
8000b7c4:	18 0b       	add	r11,r12
8000b7c6:	18 3b       	cp.w	r11,r12
8000b7c8:	c0 63       	brcs	8000b7d4 <__avr32_udiv64+0xf4>
8000b7ca:	12 3b       	cp.w	r11,r9
8000b7cc:	f7 be 03 01 	sublo	lr,1
8000b7d0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b7d4:	12 1b       	sub	r11,r9
8000b7d6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b7da:	f6 03 0d 02 	divu	r2,r11,r3
8000b7de:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b7e2:	04 99       	mov	r9,r2
8000b7e4:	e4 05 02 4b 	mul	r11,r2,r5
8000b7e8:	16 38       	cp.w	r8,r11
8000b7ea:	c0 a2       	brcc	8000b7fe <__avr32_udiv64+0x11e>
8000b7ec:	20 19       	sub	r9,1
8000b7ee:	18 08       	add	r8,r12
8000b7f0:	18 38       	cp.w	r8,r12
8000b7f2:	c0 63       	brcs	8000b7fe <__avr32_udiv64+0x11e>
8000b7f4:	16 38       	cp.w	r8,r11
8000b7f6:	f7 b9 03 01 	sublo	r9,1
8000b7fa:	f1 dc e3 08 	addcs	r8,r8,r12
8000b7fe:	f4 06 09 43 	lsl	r3,r10,r6
8000b802:	f0 0b 01 0b 	sub	r11,r8,r11
8000b806:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b80a:	f8 06 16 10 	lsr	r6,r12,0x10
8000b80e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b812:	f6 06 0d 00 	divu	r0,r11,r6
8000b816:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b81a:	00 9a       	mov	r10,r0
8000b81c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b820:	e0 0e 02 48 	mul	r8,r0,lr
8000b824:	10 3b       	cp.w	r11,r8
8000b826:	c0 a2       	brcc	8000b83a <__avr32_udiv64+0x15a>
8000b828:	20 1a       	sub	r10,1
8000b82a:	18 0b       	add	r11,r12
8000b82c:	18 3b       	cp.w	r11,r12
8000b82e:	c0 63       	brcs	8000b83a <__avr32_udiv64+0x15a>
8000b830:	10 3b       	cp.w	r11,r8
8000b832:	f7 ba 03 01 	sublo	r10,1
8000b836:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b83a:	f6 08 01 01 	sub	r1,r11,r8
8000b83e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b842:	e2 06 0d 00 	divu	r0,r1,r6
8000b846:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b84a:	00 98       	mov	r8,r0
8000b84c:	e0 0e 02 4b 	mul	r11,r0,lr
8000b850:	16 33       	cp.w	r3,r11
8000b852:	c0 82       	brcc	8000b862 <__avr32_udiv64+0x182>
8000b854:	20 18       	sub	r8,1
8000b856:	18 03       	add	r3,r12
8000b858:	18 33       	cp.w	r3,r12
8000b85a:	c0 43       	brcs	8000b862 <__avr32_udiv64+0x182>
8000b85c:	16 33       	cp.w	r3,r11
8000b85e:	f7 b8 03 01 	sublo	r8,1
8000b862:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b866:	c6 98       	rjmp	8000b938 <__avr32_udiv64+0x258>
8000b868:	16 39       	cp.w	r9,r11
8000b86a:	e0 8b 00 65 	brhi	8000b934 <__avr32_udiv64+0x254>
8000b86e:	f2 09 12 00 	clz	r9,r9
8000b872:	c0 b1       	brne	8000b888 <__avr32_udiv64+0x1a8>
8000b874:	10 3a       	cp.w	r10,r8
8000b876:	5f 2a       	srhs	r10
8000b878:	1c 3b       	cp.w	r11,lr
8000b87a:	5f b8       	srhi	r8
8000b87c:	10 4a       	or	r10,r8
8000b87e:	f2 0a 18 00 	cp.b	r10,r9
8000b882:	c5 90       	breq	8000b934 <__avr32_udiv64+0x254>
8000b884:	30 18       	mov	r8,1
8000b886:	c5 98       	rjmp	8000b938 <__avr32_udiv64+0x258>
8000b888:	f0 09 09 46 	lsl	r6,r8,r9
8000b88c:	f2 03 11 20 	rsub	r3,r9,32
8000b890:	fc 09 09 4e 	lsl	lr,lr,r9
8000b894:	f0 03 0a 48 	lsr	r8,r8,r3
8000b898:	f6 09 09 4c 	lsl	r12,r11,r9
8000b89c:	f4 03 0a 42 	lsr	r2,r10,r3
8000b8a0:	ef 46 ff f4 	st.w	r7[-12],r6
8000b8a4:	f6 03 0a 43 	lsr	r3,r11,r3
8000b8a8:	18 42       	or	r2,r12
8000b8aa:	f1 ee 10 0c 	or	r12,r8,lr
8000b8ae:	f8 01 16 10 	lsr	r1,r12,0x10
8000b8b2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b8b6:	e6 01 0d 04 	divu	r4,r3,r1
8000b8ba:	e4 03 16 10 	lsr	r3,r2,0x10
8000b8be:	08 9e       	mov	lr,r4
8000b8c0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b8c4:	e8 06 02 48 	mul	r8,r4,r6
8000b8c8:	10 33       	cp.w	r3,r8
8000b8ca:	c0 a2       	brcc	8000b8de <__avr32_udiv64+0x1fe>
8000b8cc:	20 1e       	sub	lr,1
8000b8ce:	18 03       	add	r3,r12
8000b8d0:	18 33       	cp.w	r3,r12
8000b8d2:	c0 63       	brcs	8000b8de <__avr32_udiv64+0x1fe>
8000b8d4:	10 33       	cp.w	r3,r8
8000b8d6:	f7 be 03 01 	sublo	lr,1
8000b8da:	e7 dc e3 03 	addcs	r3,r3,r12
8000b8de:	10 13       	sub	r3,r8
8000b8e0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b8e4:	e6 01 0d 00 	divu	r0,r3,r1
8000b8e8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b8ec:	00 98       	mov	r8,r0
8000b8ee:	e0 06 02 46 	mul	r6,r0,r6
8000b8f2:	0c 3b       	cp.w	r11,r6
8000b8f4:	c0 a2       	brcc	8000b908 <__avr32_udiv64+0x228>
8000b8f6:	20 18       	sub	r8,1
8000b8f8:	18 0b       	add	r11,r12
8000b8fa:	18 3b       	cp.w	r11,r12
8000b8fc:	c0 63       	brcs	8000b908 <__avr32_udiv64+0x228>
8000b8fe:	0c 3b       	cp.w	r11,r6
8000b900:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b904:	f7 b8 03 01 	sublo	r8,1
8000b908:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b90c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b910:	0c 1b       	sub	r11,r6
8000b912:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b916:	06 95       	mov	r5,r3
8000b918:	16 35       	cp.w	r5,r11
8000b91a:	e0 8b 00 0a 	brhi	8000b92e <__avr32_udiv64+0x24e>
8000b91e:	5f 0b       	sreq	r11
8000b920:	f4 09 09 49 	lsl	r9,r10,r9
8000b924:	12 32       	cp.w	r2,r9
8000b926:	5f b9       	srhi	r9
8000b928:	f7 e9 00 09 	and	r9,r11,r9
8000b92c:	c0 60       	breq	8000b938 <__avr32_udiv64+0x258>
8000b92e:	20 18       	sub	r8,1
8000b930:	30 09       	mov	r9,0
8000b932:	c0 38       	rjmp	8000b938 <__avr32_udiv64+0x258>
8000b934:	30 09       	mov	r9,0
8000b936:	12 98       	mov	r8,r9
8000b938:	10 9a       	mov	r10,r8
8000b93a:	12 93       	mov	r3,r9
8000b93c:	10 92       	mov	r2,r8
8000b93e:	12 9b       	mov	r11,r9
8000b940:	2f dd       	sub	sp,-12
8000b942:	d8 32       	popm	r0-r7,pc

8000b944 <__avr32_umod64>:
8000b944:	d4 31       	pushm	r0-r7,lr
8000b946:	1a 97       	mov	r7,sp
8000b948:	20 3d       	sub	sp,12
8000b94a:	10 9c       	mov	r12,r8
8000b94c:	12 95       	mov	r5,r9
8000b94e:	14 9e       	mov	lr,r10
8000b950:	16 91       	mov	r1,r11
8000b952:	16 96       	mov	r6,r11
8000b954:	58 09       	cp.w	r9,0
8000b956:	e0 81 00 81 	brne	8000ba58 <__avr32_umod64+0x114>
8000b95a:	16 38       	cp.w	r8,r11
8000b95c:	e0 88 00 12 	brls	8000b980 <__avr32_umod64+0x3c>
8000b960:	f0 08 12 00 	clz	r8,r8
8000b964:	c4 e0       	breq	8000ba00 <__avr32_umod64+0xbc>
8000b966:	f6 08 09 46 	lsl	r6,r11,r8
8000b96a:	f8 08 09 4c 	lsl	r12,r12,r8
8000b96e:	f0 0b 11 20 	rsub	r11,r8,32
8000b972:	f4 08 09 4e 	lsl	lr,r10,r8
8000b976:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b97a:	f7 e6 10 06 	or	r6,r11,r6
8000b97e:	c4 18       	rjmp	8000ba00 <__avr32_umod64+0xbc>
8000b980:	58 08       	cp.w	r8,0
8000b982:	c0 51       	brne	8000b98c <__avr32_umod64+0x48>
8000b984:	30 19       	mov	r9,1
8000b986:	f2 08 0d 08 	divu	r8,r9,r8
8000b98a:	10 9c       	mov	r12,r8
8000b98c:	f8 08 12 00 	clz	r8,r12
8000b990:	c0 31       	brne	8000b996 <__avr32_umod64+0x52>
8000b992:	18 16       	sub	r6,r12
8000b994:	c3 68       	rjmp	8000ba00 <__avr32_umod64+0xbc>
8000b996:	f0 03 11 20 	rsub	r3,r8,32
8000b99a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b99e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b9a2:	ec 08 09 49 	lsl	r9,r6,r8
8000b9a6:	ec 03 0a 43 	lsr	r3,r6,r3
8000b9aa:	f7 e9 10 09 	or	r9,r11,r9
8000b9ae:	f8 05 16 10 	lsr	r5,r12,0x10
8000b9b2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b9b6:	e6 05 0d 02 	divu	r2,r3,r5
8000b9ba:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b9be:	ec 02 02 4b 	mul	r11,r6,r2
8000b9c2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b9c6:	16 3e       	cp.w	lr,r11
8000b9c8:	c0 72       	brcc	8000b9d6 <__avr32_umod64+0x92>
8000b9ca:	18 0e       	add	lr,r12
8000b9cc:	18 3e       	cp.w	lr,r12
8000b9ce:	c0 43       	brcs	8000b9d6 <__avr32_umod64+0x92>
8000b9d0:	16 3e       	cp.w	lr,r11
8000b9d2:	fd dc e3 0e 	addcs	lr,lr,r12
8000b9d6:	fc 0b 01 03 	sub	r3,lr,r11
8000b9da:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b9de:	e6 05 0d 02 	divu	r2,r3,r5
8000b9e2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b9e6:	a5 36       	mul	r6,r2
8000b9e8:	0c 39       	cp.w	r9,r6
8000b9ea:	c0 72       	brcc	8000b9f8 <__avr32_umod64+0xb4>
8000b9ec:	18 09       	add	r9,r12
8000b9ee:	18 39       	cp.w	r9,r12
8000b9f0:	c0 43       	brcs	8000b9f8 <__avr32_umod64+0xb4>
8000b9f2:	0c 39       	cp.w	r9,r6
8000b9f4:	f3 dc e3 09 	addcs	r9,r9,r12
8000b9f8:	f2 06 01 06 	sub	r6,r9,r6
8000b9fc:	f4 08 09 4e 	lsl	lr,r10,r8
8000ba00:	f8 0a 16 10 	lsr	r10,r12,0x10
8000ba04:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ba08:	ec 0a 0d 02 	divu	r2,r6,r10
8000ba0c:	fc 09 16 10 	lsr	r9,lr,0x10
8000ba10:	ea 02 02 4b 	mul	r11,r5,r2
8000ba14:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ba18:	16 39       	cp.w	r9,r11
8000ba1a:	c0 72       	brcc	8000ba28 <__avr32_umod64+0xe4>
8000ba1c:	18 09       	add	r9,r12
8000ba1e:	18 39       	cp.w	r9,r12
8000ba20:	c0 43       	brcs	8000ba28 <__avr32_umod64+0xe4>
8000ba22:	16 39       	cp.w	r9,r11
8000ba24:	f3 dc e3 09 	addcs	r9,r9,r12
8000ba28:	f2 0b 01 0b 	sub	r11,r9,r11
8000ba2c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ba30:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ba34:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000ba38:	ea 0a 02 4a 	mul	r10,r5,r10
8000ba3c:	14 3e       	cp.w	lr,r10
8000ba3e:	c0 72       	brcc	8000ba4c <__avr32_umod64+0x108>
8000ba40:	18 0e       	add	lr,r12
8000ba42:	18 3e       	cp.w	lr,r12
8000ba44:	c0 43       	brcs	8000ba4c <__avr32_umod64+0x108>
8000ba46:	14 3e       	cp.w	lr,r10
8000ba48:	fd dc e3 0e 	addcs	lr,lr,r12
8000ba4c:	fc 0a 01 0a 	sub	r10,lr,r10
8000ba50:	30 0b       	mov	r11,0
8000ba52:	f4 08 0a 4a 	lsr	r10,r10,r8
8000ba56:	c7 b8       	rjmp	8000bb4c <__avr32_umod64+0x208>
8000ba58:	16 39       	cp.w	r9,r11
8000ba5a:	e0 8b 00 79 	brhi	8000bb4c <__avr32_umod64+0x208>
8000ba5e:	f2 09 12 00 	clz	r9,r9
8000ba62:	c1 21       	brne	8000ba86 <__avr32_umod64+0x142>
8000ba64:	10 3a       	cp.w	r10,r8
8000ba66:	5f 2b       	srhs	r11
8000ba68:	0a 31       	cp.w	r1,r5
8000ba6a:	5f ba       	srhi	r10
8000ba6c:	f7 ea 10 0a 	or	r10,r11,r10
8000ba70:	f2 0a 18 00 	cp.b	r10,r9
8000ba74:	c0 60       	breq	8000ba80 <__avr32_umod64+0x13c>
8000ba76:	fc 08 01 0c 	sub	r12,lr,r8
8000ba7a:	e2 05 01 46 	sbc	r6,r1,r5
8000ba7e:	18 9e       	mov	lr,r12
8000ba80:	0c 9b       	mov	r11,r6
8000ba82:	1c 9a       	mov	r10,lr
8000ba84:	c6 48       	rjmp	8000bb4c <__avr32_umod64+0x208>
8000ba86:	ea 09 09 4c 	lsl	r12,r5,r9
8000ba8a:	f2 06 11 20 	rsub	r6,r9,32
8000ba8e:	f6 09 09 4b 	lsl	r11,r11,r9
8000ba92:	f0 09 09 42 	lsl	r2,r8,r9
8000ba96:	ef 46 ff f4 	st.w	r7[-12],r6
8000ba9a:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba9e:	18 48       	or	r8,r12
8000baa0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000baa4:	f4 09 09 43 	lsl	r3,r10,r9
8000baa8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000baac:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bab0:	16 4a       	or	r10,r11
8000bab2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bab6:	f8 0b 0d 04 	divu	r4,r12,r11
8000baba:	f4 0c 16 10 	lsr	r12,r10,0x10
8000babe:	08 91       	mov	r1,r4
8000bac0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bac4:	e8 0e 02 46 	mul	r6,r4,lr
8000bac8:	0c 3c       	cp.w	r12,r6
8000baca:	c0 a2       	brcc	8000bade <__avr32_umod64+0x19a>
8000bacc:	20 11       	sub	r1,1
8000bace:	10 0c       	add	r12,r8
8000bad0:	10 3c       	cp.w	r12,r8
8000bad2:	c0 63       	brcs	8000bade <__avr32_umod64+0x19a>
8000bad4:	0c 3c       	cp.w	r12,r6
8000bad6:	f7 b1 03 01 	sublo	r1,1
8000bada:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bade:	0c 1c       	sub	r12,r6
8000bae0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bae4:	f8 0b 0d 04 	divu	r4,r12,r11
8000bae8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000baec:	08 96       	mov	r6,r4
8000baee:	e8 0e 02 4e 	mul	lr,r4,lr
8000baf2:	1c 3b       	cp.w	r11,lr
8000baf4:	c0 a2       	brcc	8000bb08 <__avr32_umod64+0x1c4>
8000baf6:	20 16       	sub	r6,1
8000baf8:	10 0b       	add	r11,r8
8000bafa:	10 3b       	cp.w	r11,r8
8000bafc:	c0 63       	brcs	8000bb08 <__avr32_umod64+0x1c4>
8000bafe:	1c 3b       	cp.w	r11,lr
8000bb00:	f7 b6 03 01 	sublo	r6,1
8000bb04:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bb08:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bb0c:	1c 1b       	sub	r11,lr
8000bb0e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bb12:	00 9e       	mov	lr,r0
8000bb14:	02 9c       	mov	r12,r1
8000bb16:	16 3c       	cp.w	r12,r11
8000bb18:	e0 8b 00 08 	brhi	8000bb28 <__avr32_umod64+0x1e4>
8000bb1c:	5f 06       	sreq	r6
8000bb1e:	06 30       	cp.w	r0,r3
8000bb20:	5f ba       	srhi	r10
8000bb22:	ed ea 00 0a 	and	r10,r6,r10
8000bb26:	c0 60       	breq	8000bb32 <__avr32_umod64+0x1ee>
8000bb28:	fc 02 01 04 	sub	r4,lr,r2
8000bb2c:	f8 08 01 4c 	sbc	r12,r12,r8
8000bb30:	08 9e       	mov	lr,r4
8000bb32:	e6 0e 01 0a 	sub	r10,r3,lr
8000bb36:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bb3a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bb3e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bb42:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bb46:	f8 01 09 4c 	lsl	r12,r12,r1
8000bb4a:	18 4a       	or	r10,r12
8000bb4c:	2f dd       	sub	sp,-12
8000bb4e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000bc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000bc00:	c0 08       	rjmp	8000bc00 <_evba>
	...

8000bc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000bc04:	c0 08       	rjmp	8000bc04 <_handle_TLB_Multiple_Hit>
	...

8000bc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000bc08:	c0 08       	rjmp	8000bc08 <_handle_Bus_Error_Data_Fetch>
	...

8000bc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000bc0c:	c0 08       	rjmp	8000bc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000bc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000bc10:	c0 08       	rjmp	8000bc10 <_handle_NMI>
	...

8000bc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000bc14:	c0 08       	rjmp	8000bc14 <_handle_Instruction_Address>
	...

8000bc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000bc18:	c0 08       	rjmp	8000bc18 <_handle_ITLB_Protection>
	...

8000bc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000bc1c:	c0 08       	rjmp	8000bc1c <_handle_Breakpoint>
	...

8000bc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000bc20:	c0 08       	rjmp	8000bc20 <_handle_Illegal_Opcode>
	...

8000bc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000bc24:	c0 08       	rjmp	8000bc24 <_handle_Unimplemented_Instruction>
	...

8000bc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000bc28:	c0 08       	rjmp	8000bc28 <_handle_Privilege_Violation>
	...

8000bc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000bc2c:	c0 08       	rjmp	8000bc2c <_handle_Floating_Point>
	...

8000bc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000bc30:	c0 08       	rjmp	8000bc30 <_handle_Coprocessor_Absent>
	...

8000bc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000bc34:	c0 08       	rjmp	8000bc34 <_handle_Data_Address_Read>
	...

8000bc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000bc38:	c0 08       	rjmp	8000bc38 <_handle_Data_Address_Write>
	...

8000bc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000bc3c:	c0 08       	rjmp	8000bc3c <_handle_DTLB_Protection_Read>
	...

8000bc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000bc40:	c0 08       	rjmp	8000bc40 <_handle_DTLB_Protection_Write>
	...

8000bc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000bc44:	c0 08       	rjmp	8000bc44 <_handle_DTLB_Modified>
	...

8000bc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000bc50:	c0 08       	rjmp	8000bc50 <_handle_ITLB_Miss>
	...

8000bc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000bc60:	c0 08       	rjmp	8000bc60 <_handle_DTLB_Miss_Read>
	...

8000bc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000bc70:	c0 08       	rjmp	8000bc70 <_handle_DTLB_Miss_Write>
	...

8000bd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bd00:	fe cf 70 9c 	sub	pc,pc,28828

8000bd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bd04:	30 0c       	mov	r12,0
8000bd06:	fe b0 c5 c9 	rcall	80004898 <_get_interrupt_handler>
8000bd0a:	58 0c       	cp.w	r12,0
8000bd0c:	f8 0f 17 10 	movne	pc,r12
8000bd10:	d6 03       	rete

8000bd12 <_int1>:
8000bd12:	30 1c       	mov	r12,1
8000bd14:	fe b0 c5 c2 	rcall	80004898 <_get_interrupt_handler>
8000bd18:	58 0c       	cp.w	r12,0
8000bd1a:	f8 0f 17 10 	movne	pc,r12
8000bd1e:	d6 03       	rete

8000bd20 <_int2>:
8000bd20:	30 2c       	mov	r12,2
8000bd22:	fe b0 c5 bb 	rcall	80004898 <_get_interrupt_handler>
8000bd26:	58 0c       	cp.w	r12,0
8000bd28:	f8 0f 17 10 	movne	pc,r12
8000bd2c:	d6 03       	rete

8000bd2e <_int3>:
8000bd2e:	30 3c       	mov	r12,3
8000bd30:	fe b0 c5 b4 	rcall	80004898 <_get_interrupt_handler>
8000bd34:	58 0c       	cp.w	r12,0
8000bd36:	f8 0f 17 10 	movne	pc,r12
8000bd3a:	d6 03       	rete

8000bd3c <ipr_val>:
8000bd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdfc:	d7 03 d7 03                                         ....
