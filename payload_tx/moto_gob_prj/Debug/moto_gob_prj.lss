
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009a60  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000bc00  8000bc00  0000c000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000171c  8000be00  8000be00  0000c200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000d51c  8000d51c  0000d91c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a34  00000008  8000d520  0000dc08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a3c  8000df54  0000e63c  2**0
                  ALLOC
  9 .bss          000036d8  00000a40  00000a40  00000000  2**2
                  ALLOC
 10 .heap         00012ee8  00004118  00004118  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  0000e63c  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001140  00000000  00000000  0000e670  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 000024d9  00000000  00000000  0000f7b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   000282e1  00000000  00000000  00011c89  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000067f6  00000000  00000000  00039f6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000c0d7  00000000  00000000  00040760  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002d30  00000000  00000000  0004c838  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00006ccf  00000000  00000000  0004f568  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000c90c  00000000  00000000  00056237  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001228  00000000  00000000  00062b48  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9e bc 	sub	pc,pc,-24900

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf be c0 	sub	pc,pc,-16704

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d a4       	ld.ub	r4,r6[0x2]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12
8000202e:	d7 03       	nop

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 60       	and	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 8c       	sub	r12,-120
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 5c       	sub	r12,-107
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	39 14       	mov	r4,-111
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	be 00       	st.h	pc[0x0],r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 d0       	sub	r0,125
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	58 b8       	cp.w	r8,11
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	be 08       	st.h	pc[0x0],r8
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	5c 7c       	castu.h	r12

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	be 0c       	st.h	pc[0x0],r12
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	5c 7c       	castu.h	r12

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	be 2c       	st.h	pc[0x4],r12
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	5c 7c       	castu.h	r12

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	be 48       	st.h	pc[0x8],r8
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	5c 7c       	castu.h	r12

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	be 64       	st.h	pc[0xc],r4
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	5c 7c       	castu.h	r12

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	be 7c       	st.h	pc[0xe],r12
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	5c 7c       	castu.h	r12
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	be 94       	st.b	pc[0x1],r4
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	be a8       	st.b	pc[0x2],r8
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	be c0       	st.b	pc[0x4],r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	be dc       	st.b	pc[0x5],r12

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	31 18       	mov	r8,17
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c0 61       	brne	80002182 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002178:	48 8c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x30>
8000217a:	f0 1f 00 09 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
8000217e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002182:	48 8c       	lddpc	r12,800021a0 <SingleDetection_brdcst_func+0x38>
80002184:	f0 1f 00 06 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002188:	0f a8       	ld.ub	r8,r7[0x2]
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 6c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x3c>
8000218e:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	be f4       	st.b	pc[0x7],r4
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	5c 7c       	castu.h	r12
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	bf 08       	ld.d	r8,pc
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	bf 18       	ld.d	r8,--pc

800021a8 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021a8:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021aa:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ae:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b0:	4a bc       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xb4>
800021b2:	f0 1f 00 2c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021b6:	0f 88       	ld.ub	r8,r7[0x0]
800021b8:	1a d8       	st.w	--sp,r8
800021ba:	4a bc       	lddpc	r12,80002264 <ButtonConfig_brdcst_func+0xbc>
800021bc:	f0 1f 00 29 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c0:	1a d5       	st.w	--sp,r5
800021c2:	4a ac       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xc0>
800021c4:	f0 1f 00 27 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021c8:	0f a8       	ld.ub	r8,r7[0x2]
800021ca:	1a d8       	st.w	--sp,r8
800021cc:	4a 8c       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc4>
800021ce:	f0 1f 00 25 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d2:	2f dd       	sub	sp,-12
800021d4:	58 05       	cp.w	r5,0
800021d6:	c4 10       	breq	80002258 <ButtonConfig_brdcst_func+0xb0>
800021d8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021da:	4a 64       	lddpc	r4,80002270 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021dc:	4a 63       	lddpc	r3,80002274 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021de:	4a 72       	lddpc	r2,80002278 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e0:	4a 71       	lddpc	r1,8000227c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e2:	4a 80       	lddpc	r0,80002280 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e4:	0f b9       	ld.ub	r9,r7[0x3]
800021e6:	0f c8       	ld.ub	r8,r7[0x4]
800021e8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ec:	1a d8       	st.w	--sp,r8
800021ee:	1a d6       	st.w	--sp,r6
800021f0:	08 9c       	mov	r12,r4
800021f2:	f0 1f 00 1c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021f6:	0f d9       	ld.ub	r9,r7[0x5]
800021f8:	0f e8       	ld.ub	r8,r7[0x6]
800021fa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fe:	1a d8       	st.w	--sp,r8
80002200:	1a d6       	st.w	--sp,r6
80002202:	06 9c       	mov	r12,r3
80002204:	f0 1f 00 17 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002208:	0f f9       	ld.ub	r9,r7[0x7]
8000220a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000220e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002212:	1a d8       	st.w	--sp,r8
80002214:	1a d6       	st.w	--sp,r6
80002216:	04 9c       	mov	r12,r2
80002218:	f0 1f 00 12 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002220:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	02 9c       	mov	r12,r1
8000222e:	f0 1f 00 0d 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002232:	2f 8d       	sub	sp,-32
80002234:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002238:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000223c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002240:	1a d8       	st.w	--sp,r8
80002242:	1a d6       	st.w	--sp,r6
80002244:	00 9c       	mov	r12,r0
80002246:	f0 1f 00 07 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
8000224a:	2f f6       	sub	r6,-1
8000224c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000224e:	2f ed       	sub	sp,-8
80002250:	ec 05 18 00 	cp.b	r5,r6
80002254:	fe 9b ff c8 	brhi	800021e4 <ButtonConfig_brdcst_func+0x3c>
80002258:	d8 32       	popm	r0-r7,pc
8000225a:	00 00       	add	r0,r0
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	bf 30       	mul	r0,pc
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	5c 7c       	castu.h	r12
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	bf 50       	asr	r0,0x1f
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	bf 64       	lsl	r4,0x1e
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	bf 7c       	lsl	r12,0x1f
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	bf 9c       	lsr	r12,0x1f
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	bf c4       	cbr	r4,0x1e
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	bf ec       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	c0 10       	breq	80002280 <ButtonConfig_brdcst_func+0xd8>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	c0 38       	rjmp	80002288 <Phyuserinput_brdcst_func+0x4>

80002284 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002284:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002288:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000228a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000228c:	19 c7       	ld.ub	r7,r12[0x4]
8000228e:	19 d8       	ld.ub	r8,r12[0x5]
80002290:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002294:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002296:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002298:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000229c:	49 0c       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x58>
8000229e:	f0 1f 00 11 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	49 0c       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x60>
800022a6:	f0 1f 00 0f 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022aa:	1a d5       	st.w	--sp,r5
800022ac:	48 fc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x64>
800022ae:	f0 1f 00 0d 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022b2:	5c 77       	castu.h	r7
800022b4:	1a d7       	st.w	--sp,r7
800022b6:	48 ec       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x68>
800022b8:	f0 1f 00 0a 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022bc:	1a d4       	st.w	--sp,r4
800022be:	48 dc       	lddpc	r12,800022f0 <Phyuserinput_brdcst_func+0x6c>
800022c0:	f0 1f 00 08 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022c4:	1a d3       	st.w	--sp,r3
800022c6:	48 cc       	lddpc	r12,800022f4 <Phyuserinput_brdcst_func+0x70>
800022c8:	f0 1f 00 06 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022cc:	1a d2       	st.w	--sp,r2
800022ce:	48 bc       	lddpc	r12,800022f8 <Phyuserinput_brdcst_func+0x74>
800022d0:	f0 1f 00 04 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
800022d4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c0 5c       	rcall	800022e8 <Phyuserinput_brdcst_func+0x64>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	5c 7c       	castu.h	r12
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c0 80       	breq	800022f6 <Phyuserinput_brdcst_func+0x72>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c0 98       	rjmp	800022fc <ButtonConfig_reply_func>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c0 ac       	rcall	80002302 <ButtonConfig_reply_func+0x6>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	c0 c0       	breq	8000230a <ButtonConfig_reply_func+0xe>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c0 d4       	brge	80002310 <ButtonConfig_reply_func+0x14>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	c0 f4       	brge	80002318 <ButtonConfig_reply_func+0x1c>

800022fc <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002300:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002304:	0f 89       	ld.ub	r9,r7[0x0]
80002306:	30 08       	mov	r8,0
80002308:	f0 09 18 00 	cp.b	r9,r8
8000230c:	c0 c1       	brne	80002324 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000230e:	48 9c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x34>
80002310:	f0 1f 00 09 	mcall	80002334 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002314:	0f 98       	ld.ub	r8,r7[0x1]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 8c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x3c>
8000231a:	f0 1f 00 07 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000231e:	2f fd       	sub	sp,-4
80002320:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002324:	48 6c       	lddpc	r12,8000233c <ButtonConfig_reply_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	c1 14       	brge	80002354 <DataSession_brdcst_func+0x14>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	5c 7c       	castu.h	r12
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	bf 50       	asr	r0,0x1f
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	c1 2c       	rcall	80002362 <DataSession_brdcst_func+0x22>

80002340 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002342:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002346:	0d 88       	ld.ub	r8,r6[0x0]
80002348:	32 49       	mov	r9,36
8000234a:	f2 08 18 00 	cp.b	r8,r9
8000234e:	c2 91       	brne	800023a0 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002350:	49 7c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x6c>
80002352:	f0 1f 00 18 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002356:	0d a5       	ld.ub	r5,r6[0x2]
80002358:	0d b8       	ld.ub	r8,r6[0x3]
8000235a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000235e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002360:	0d 98       	ld.ub	r8,r6[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 4c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x74>
80002366:	f0 1f 00 13 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000236a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000236e:	1a d8       	st.w	--sp,r8
80002370:	49 2c       	lddpc	r12,800023b8 <DataSession_brdcst_func+0x78>
80002372:	f0 1f 00 10 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002376:	2f ed       	sub	sp,-8
80002378:	58 05       	cp.w	r5,0
8000237a:	c1 80       	breq	800023aa <DataSession_brdcst_func+0x6a>
8000237c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000237e:	49 04       	lddpc	r4,800023bc <DataSession_brdcst_func+0x7c>
80002380:	ec 07 00 08 	add	r8,r6,r7
80002384:	11 c8       	ld.ub	r8,r8[0x4]
80002386:	1a d8       	st.w	--sp,r8
80002388:	1a d7       	st.w	--sp,r7
8000238a:	08 9c       	mov	r12,r4
8000238c:	f0 1f 00 09 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002390:	2f f7       	sub	r7,-1
80002392:	5c 57       	castu.b	r7
80002394:	2f ed       	sub	sp,-8
80002396:	ee 05 19 00 	cp.h	r5,r7
8000239a:	fe 9b ff f3 	brhi	80002380 <DataSession_brdcst_func+0x40>
8000239e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023a0:	1a d8       	st.w	--sp,r8
800023a2:	48 8c       	lddpc	r12,800023c0 <DataSession_brdcst_func+0x80>
800023a4:	f0 1f 00 03 	mcall	800023b0 <DataSession_brdcst_func+0x70>
800023a8:	2f fd       	sub	sp,-4
800023aa:	d8 22       	popm	r4-r7,pc
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	c1 48       	rjmp	800023d6 <DataSession_reply_func+0x12>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	5c 7c       	castu.h	r12
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	c1 5c       	rcall	800023e0 <DataSession_reply_func+0x1c>
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	c1 74       	brge	800023e8 <DataSession_reply_func+0x24>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	c1 90       	breq	800023f0 <DataSession_reply_func+0x2c>
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	c1 a8       	rjmp	800023f6 <DataSession_reply_func+0x32>

800023c4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a8       	ld.ub	r8,r12[0x2]
800023cc:	58 08       	cp.w	r8,0
800023ce:	c0 61       	brne	800023da <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023d0:	48 dc       	lddpc	r12,80002404 <DataSession_reply_func+0x40>
800023d2:	f0 1f 00 0e 	mcall	80002408 <DataSession_reply_func+0x44>
800023d6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 cc       	lddpc	r12,8000240c <DataSession_reply_func+0x48>
800023de:	f0 1f 00 0b 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023e2:	48 cc       	lddpc	r12,80002410 <DataSession_reply_func+0x4c>
800023e4:	f0 1f 00 09 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023e8:	0f b8       	ld.ub	r8,r7[0x3]
800023ea:	1a d8       	st.w	--sp,r8
800023ec:	48 ac       	lddpc	r12,80002414 <DataSession_reply_func+0x50>
800023ee:	f0 1f 00 07 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023f2:	0f c8       	ld.ub	r8,r7[0x4]
800023f4:	1a d8       	st.w	--sp,r8
800023f6:	48 9c       	lddpc	r12,80002418 <DataSession_reply_func+0x54>
800023f8:	f0 1f 00 04 	mcall	80002408 <DataSession_reply_func+0x44>
800023fc:	2f dd       	sub	sp,-12
800023fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002402:	00 00       	add	r0,r0
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	c1 bc       	rcall	8000243c <TransmitControl_brdcst_func+0x20>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	5c 7c       	castu.h	r12
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	c1 d0       	breq	80002448 <TransmitControl_brdcst_func+0x2c>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	c1 e4       	brge	8000244e <TransmitControl_brdcst_func+0x32>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c1 f8       	rjmp	80002454 <TransmitControl_brdcst_func+0x38>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	c2 08       	rjmp	8000245a <TransmitControl_brdcst_func+0x3e>

8000241c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002424:	0f 99       	ld.ub	r9,r7[0x1]
80002426:	30 08       	mov	r8,0
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c0 71       	brne	8000243a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000242e:	48 ac       	lddpc	r12,80002454 <TransmitControl_brdcst_func+0x38>
80002430:	f0 1f 00 0a 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002434:	30 09       	mov	r9,0
80002436:	48 a8       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
80002438:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000243a:	0f 99       	ld.ub	r9,r7[0x1]
8000243c:	30 18       	mov	r8,1
8000243e:	f0 09 18 00 	cp.b	r9,r8
80002442:	c0 71       	brne	80002450 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002444:	48 7c       	lddpc	r12,80002460 <TransmitControl_brdcst_func+0x44>
80002446:	f0 1f 00 05 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000244a:	30 19       	mov	r9,1
8000244c:	48 48       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
8000244e:	b0 89       	st.b	r8[0x0],r9
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	c2 18       	rjmp	80002498 <TransmitControl_reply_func+0x34>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	5c 7c       	castu.h	r12
8000245c:	00 00       	add	r0,r0
8000245e:	0a 50       	eor	r0,r5
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c2 30       	breq	800024a8 <TransmitControl_reply_func+0x44>

80002464 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 61       	brne	800024a0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002476:	48 ec       	lddpc	r12,800024ac <TransmitControl_reply_func+0x48>
80002478:	f0 1f 00 0e 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000247c:	0f 98       	ld.ub	r8,r7[0x1]
8000247e:	1a d8       	st.w	--sp,r8
80002480:	48 dc       	lddpc	r12,800024b4 <TransmitControl_reply_func+0x50>
80002482:	f0 1f 00 0c 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002486:	0f a8       	ld.ub	r8,r7[0x2]
80002488:	1a d8       	st.w	--sp,r8
8000248a:	48 cc       	lddpc	r12,800024b8 <TransmitControl_reply_func+0x54>
8000248c:	f0 1f 00 09 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002490:	0f b8       	ld.ub	r8,r7[0x3]
80002492:	1a d8       	st.w	--sp,r8
80002494:	48 ac       	lddpc	r12,800024bc <TransmitControl_reply_func+0x58>
80002496:	f0 1f 00 07 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
8000249a:	2f dd       	sub	sp,-12
8000249c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024a0:	48 8c       	lddpc	r12,800024c0 <TransmitControl_reply_func+0x5c>
800024a2:	f0 1f 00 04 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
800024a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024aa:	00 00       	add	r0,r0
800024ac:	80 00       	ld.sh	r0,r0[0x0]
800024ae:	c2 44       	brge	800024f6 <AudioRoutingControl_brdcst_func+0x32>
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	5c 7c       	castu.h	r12
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	c2 60       	breq	80002502 <AudioRoutingControl_brdcst_func+0x3e>
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	c2 74       	brge	80002508 <AudioRoutingControl_brdcst_func+0x44>
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c2 90       	breq	80002510 <AudioRoutingControl_brdcst_func+0x4c>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	c2 a0       	breq	80002516 <AudioRoutingControl_brdcst_func+0x52>

800024c4 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c4:	d4 31       	pushm	r0-r7,lr
800024c6:	18 95       	mov	r5,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
800024c8:	19 a3       	ld.ub	r3,r12[0x2]
800024ca:	19 b8       	ld.ub	r8,r12[0x3]
800024cc:	f1 e3 10 83 	or	r3,r8,r3<<0x8
800024d0:	5c 83       	casts.h	r3
	log("\n\r num_routings: %d \n\r", num_routings);
800024d2:	f1 d3 c0 10 	bfextu	r8,r3,0x0,0x10
800024d6:	1a d8       	st.w	--sp,r8
800024d8:	49 ac       	lddpc	r12,80002540 <AudioRoutingControl_brdcst_func+0x7c>
800024da:	f0 1f 00 1b 	mcall	80002544 <AudioRoutingControl_brdcst_func+0x80>
	
	for(j = 0; j< num_routings ; j++ )
800024de:	2f fd       	sub	sp,-4
800024e0:	58 03       	cp.w	r3,0
800024e2:	c2 d0       	breq	8000253c <AudioRoutingControl_brdcst_func+0x78>
800024e4:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024e6:	49 91       	lddpc	r1,80002548 <AudioRoutingControl_brdcst_func+0x84>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024e8:	49 90       	lddpc	r0,8000254c <AudioRoutingControl_brdcst_func+0x88>
		if (xcmp->u8[2+j*2] == 0x0d)
800024ea:	30 d2       	mov	r2,13
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024ec:	ee c6 ff ff 	sub	r6,r7,-1
800024f0:	ea 06 00 16 	add	r6,r5,r6<<0x1
800024f4:	0d a8       	ld.ub	r8,r6[0x2]
800024f6:	1a d8       	st.w	--sp,r8
800024f8:	02 9c       	mov	r12,r1
800024fa:	f0 1f 00 13 	mcall	80002544 <AudioRoutingControl_brdcst_func+0x80>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024fe:	ee 04 15 01 	lsl	r4,r7,0x1
80002502:	2f d4       	sub	r4,-3
80002504:	ea 04 00 08 	add	r8,r5,r4
80002508:	11 a8       	ld.ub	r8,r8[0x2]
8000250a:	1a d8       	st.w	--sp,r8
8000250c:	00 9c       	mov	r12,r0
8000250e:	f0 1f 00 0e 	mcall	80002544 <AudioRoutingControl_brdcst_func+0x80>
		if (xcmp->u8[2+j*2] == 0x0d)
80002512:	2f ed       	sub	sp,-8
80002514:	0d a8       	ld.ub	r8,r6[0x2]
80002516:	e4 08 18 00 	cp.b	r8,r2
8000251a:	c0 b1       	brne	80002530 <AudioRoutingControl_brdcst_func+0x6c>
		{
			if (xcmp->u8[3+j*2] == 0x0c)
8000251c:	ea 04 00 04 	add	r4,r5,r4
80002520:	09 a8       	ld.ub	r8,r4[0x2]
80002522:	30 c9       	mov	r9,12
80002524:	f2 08 18 00 	cp.b	r8,r9
80002528:	c0 41       	brne	80002530 <AudioRoutingControl_brdcst_func+0x6c>
			{
				//Speaker_is_unmute = 1;
				log("Speaker IA OK");
8000252a:	48 ac       	lddpc	r12,80002550 <AudioRoutingControl_brdcst_func+0x8c>
8000252c:	f0 1f 00 06 	mcall	80002544 <AudioRoutingControl_brdcst_func+0x80>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
80002530:	2f f7       	sub	r7,-1
80002532:	5c 57       	castu.b	r7
80002534:	ee 03 19 00 	cp.h	r3,r7
80002538:	fe 9b ff da 	brhi	800024ec <AudioRoutingControl_brdcst_func+0x28>
8000253c:	d8 32       	popm	r0-r7,pc
8000253e:	00 00       	add	r0,r0
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	c2 b8       	rjmp	80002598 <Volume_reply_func+0x44>
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	5c 7c       	castu.h	r12
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	c2 d0       	breq	800025a4 <Volume_reply_func+0x50>
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	c2 e8       	rjmp	800025aa <Volume_reply_func+0x56>
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	c3 00       	breq	800025b2 <Volume_reply_func+0x5e>

80002554 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002558:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000255c:	0f 89       	ld.ub	r9,r7[0x0]
8000255e:	30 08       	mov	r8,0
80002560:	f0 09 18 00 	cp.b	r9,r8
80002564:	c1 b1       	brne	8000259a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002566:	0f b8       	ld.ub	r8,r7[0x3]
80002568:	31 09       	mov	r9,16
8000256a:	f2 08 18 00 	cp.b	r8,r9
8000256e:	c0 f1       	brne	8000258c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002570:	48 dc       	lddpc	r12,800025a4 <Volume_reply_func+0x50>
80002572:	f0 1f 00 0e 	mcall	800025a8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002576:	0f 99       	ld.ub	r9,r7[0x1]
80002578:	0f a8       	ld.ub	r8,r7[0x2]
8000257a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 bc       	lddpc	r12,800025ac <Volume_reply_func+0x58>
80002582:	f0 1f 00 0a 	mcall	800025a8 <Volume_reply_func+0x54>
80002586:	2f fd       	sub	sp,-4
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000258c:	1a d8       	st.w	--sp,r8
8000258e:	48 9c       	lddpc	r12,800025b0 <Volume_reply_func+0x5c>
80002590:	f0 1f 00 06 	mcall	800025a8 <Volume_reply_func+0x54>
80002594:	2f fd       	sub	sp,-4
80002596:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000259a:	48 7c       	lddpc	r12,800025b4 <Volume_reply_func+0x60>
8000259c:	f0 1f 00 03 	mcall	800025a8 <Volume_reply_func+0x54>
800025a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	c3 10       	breq	80002608 <spk_reply_func+0x1c>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	5c 7c       	castu.h	r12
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	c3 24       	brge	80002612 <spk_reply_func+0x26>
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	c3 40       	breq	8000261a <spk_reply_func+0x2e>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	c3 58       	rjmp	80002620 <mic_brdcst_func+0x4>

800025b8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ba:	19 d9       	ld.ub	r9,r12[0x5]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 81       	brne	800025d2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025c4:	10 99       	mov	r9,r8
800025c6:	48 68       	lddpc	r8,800025dc <spk_brdcst_func+0x24>
800025c8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025ca:	48 6c       	lddpc	r12,800025e0 <spk_brdcst_func+0x28>
800025cc:	f0 1f 00 06 	mcall	800025e4 <spk_brdcst_func+0x2c>
800025d0:	d8 02       	popm	pc
	}
	else
	{
		//Silent_flag = 1;
		//Speaker_is_unmute = 1;
		log("spk_s_open ");
800025d2:	48 6c       	lddpc	r12,800025e8 <spk_brdcst_func+0x30>
800025d4:	f0 1f 00 04 	mcall	800025e4 <spk_brdcst_func+0x2c>
800025d8:	d8 02       	popm	pc
800025da:	00 00       	add	r0,r0
800025dc:	00 00       	add	r0,r0
800025de:	0a 40       	or	r0,r5
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	c3 70       	breq	80002650 <mic_brdcst_func+0x34>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	5c 7c       	castu.h	r12
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	c3 80       	breq	8000265a <mic_brdcst_func+0x3e>

800025ec <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ee:	19 a9       	ld.ub	r9,r12[0x2]
800025f0:	30 08       	mov	r8,0
800025f2:	f0 09 18 00 	cp.b	r9,r8
800025f6:	c0 81       	brne	80002606 <spk_reply_func+0x1a>
		{
			//Speaker_is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025f8:	19 e8       	ld.ub	r8,r12[0x6]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	48 5c       	lddpc	r12,80002610 <spk_reply_func+0x24>
800025fe:	f0 1f 00 06 	mcall	80002614 <spk_reply_func+0x28>
80002602:	2f fd       	sub	sp,-4
80002604:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002606:	48 5c       	lddpc	r12,80002618 <spk_reply_func+0x2c>
80002608:	f0 1f 00 03 	mcall	80002614 <spk_reply_func+0x28>
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	c3 8c       	rcall	80002682 <mic_reply_func+0x1e>
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	5c 7c       	castu.h	r12
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	c3 9c       	rcall	8000268c <mic_reply_func+0x28>

8000261c <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
8000261c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002620:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002624:	0f a9       	ld.ub	r9,r7[0x2]
80002626:	30 08       	mov	r8,0
80002628:	f0 09 18 00 	cp.b	r9,r8
8000262c:	c0 71       	brne	8000263a <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000262e:	48 ac       	lddpc	r12,80002654 <mic_brdcst_func+0x38>
80002630:	f0 1f 00 0a 	mcall	80002658 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
80002634:	30 09       	mov	r9,0
80002636:	48 a8       	lddpc	r8,8000265c <mic_brdcst_func+0x40>
80002638:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000263a:	0f a9       	ld.ub	r9,r7[0x2]
8000263c:	31 18       	mov	r8,17
8000263e:	f0 09 18 00 	cp.b	r9,r8
80002642:	c0 71       	brne	80002650 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
80002644:	48 7c       	lddpc	r12,80002660 <mic_brdcst_func+0x44>
80002646:	f0 1f 00 05 	mcall	80002658 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
8000264a:	30 19       	mov	r9,1
8000264c:	48 48       	lddpc	r8,8000265c <mic_brdcst_func+0x40>
8000264e:	b0 89       	st.b	r8[0x0],r9
80002650:	e3 cd 80 80 	ldm	sp++,r7,pc
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	c3 a8       	rjmp	800026ca <mic_reply_func+0x66>
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	5c 7c       	castu.h	r12
8000265c:	00 00       	add	r0,r0
8000265e:	0a 5a       	eor	r10,r5
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	c3 bc       	rcall	800026d8 <mic_reply_func+0x74>

80002664 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000266c:	49 ac       	lddpc	r12,800026d4 <mic_reply_func+0x70>
8000266e:	f0 1f 00 1b 	mcall	800026d8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002672:	0f 89       	ld.ub	r9,r7[0x0]
80002674:	30 08       	mov	r8,0
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c2 71       	brne	800026c8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000267c:	0f 98       	ld.ub	r8,r7[0x1]
8000267e:	30 29       	mov	r9,2
80002680:	f2 08 18 00 	cp.b	r8,r9
80002684:	c1 b1       	brne	800026ba <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002686:	49 6c       	lddpc	r12,800026dc <mic_reply_func+0x78>
80002688:	f0 1f 00 14 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000268c:	0f a8       	ld.ub	r8,r7[0x2]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 4c       	lddpc	r12,800026e0 <mic_reply_func+0x7c>
80002692:	f0 1f 00 12 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002696:	0f b8       	ld.ub	r8,r7[0x3]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 3c       	lddpc	r12,800026e4 <mic_reply_func+0x80>
8000269c:	f0 1f 00 0f 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026a0:	0f c8       	ld.ub	r8,r7[0x4]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	49 1c       	lddpc	r12,800026e8 <mic_reply_func+0x84>
800026a6:	f0 1f 00 0d 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026aa:	0f d8       	ld.ub	r8,r7[0x5]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	49 0c       	lddpc	r12,800026ec <mic_reply_func+0x88>
800026b0:	f0 1f 00 0a 	mcall	800026d8 <mic_reply_func+0x74>
800026b4:	2f cd       	sub	sp,-16
800026b6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	48 dc       	lddpc	r12,800026f0 <mic_reply_func+0x8c>
800026be:	f0 1f 00 07 	mcall	800026d8 <mic_reply_func+0x74>
800026c2:	2f fd       	sub	sp,-4
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c8:	48 bc       	lddpc	r12,800026f4 <mic_reply_func+0x90>
800026ca:	f0 1f 00 04 	mcall	800026d8 <mic_reply_func+0x74>
800026ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d2:	00 00       	add	r0,r0
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	c3 d0       	breq	80002750 <dcm_reply_func+0x10>
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	5c 7c       	castu.h	r12
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	c3 e0       	breq	8000275a <dcm_reply_func+0x1a>
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	c3 f4       	brge	80002760 <dcm_reply_func+0x20>
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	c4 08       	rjmp	80002766 <dcm_reply_func+0x26>
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	c4 24       	brge	8000276e <dcm_reply_func+0x2e>
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	c4 3c       	rcall	80002774 <dcm_reply_func+0x34>
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	c4 54       	brge	8000277c <dcm_reply_func+0x3c>
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	c4 6c       	rcall	80002782 <dcm_reply_func+0x42>

800026f8 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002700:	48 bc       	lddpc	r12,8000272c <dcm_brdcst_func+0x34>
80002702:	f0 1f 00 0c 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002706:	0f 88       	ld.ub	r8,r7[0x0]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 bc       	lddpc	r12,80002734 <dcm_brdcst_func+0x3c>
8000270c:	f0 1f 00 09 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002710:	0f a8       	ld.ub	r8,r7[0x2]
80002712:	1a d8       	st.w	--sp,r8
80002714:	48 9c       	lddpc	r12,80002738 <dcm_brdcst_func+0x40>
80002716:	f0 1f 00 07 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000271a:	0f 98       	ld.ub	r8,r7[0x1]
8000271c:	1a d8       	st.w	--sp,r8
8000271e:	48 8c       	lddpc	r12,8000273c <dcm_brdcst_func+0x44>
80002720:	f0 1f 00 04 	mcall	80002730 <dcm_brdcst_func+0x38>
80002724:	2f dd       	sub	sp,-12
	
	
}
80002726:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272a:	00 00       	add	r0,r0
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	c4 7c       	rcall	800027bc <ToneControl_reply_func+0x14>
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	5c 7c       	castu.h	r12
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	c4 90       	breq	800027c8 <ToneControl_reply_func+0x20>
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c4 a4       	brge	800027ce <ToneControl_reply_func+0x26>
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	c4 bc       	rcall	800027d4 <app_cfg+0x4>

80002740 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
80002744:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002746:	19 a9       	ld.ub	r9,r12[0x2]
80002748:	30 08       	mov	r8,0
8000274a:	f0 09 18 00 	cp.b	r9,r8
8000274e:	c1 b1       	brne	80002784 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002750:	19 b8       	ld.ub	r8,r12[0x3]
80002752:	30 19       	mov	r9,1
80002754:	f2 08 18 00 	cp.b	r8,r9
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000275a:	48 ec       	lddpc	r12,80002790 <dcm_reply_func+0x50>
8000275c:	f0 1f 00 0e 	mcall	80002794 <dcm_reply_func+0x54>
80002760:	c0 a8       	rjmp	80002774 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002762:	58 08       	cp.w	r8,0
80002764:	c0 51       	brne	8000276e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002766:	48 dc       	lddpc	r12,80002798 <dcm_reply_func+0x58>
80002768:	f0 1f 00 0b 	mcall	80002794 <dcm_reply_func+0x54>
8000276c:	c0 48       	rjmp	80002774 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276e:	48 cc       	lddpc	r12,8000279c <dcm_reply_func+0x5c>
80002770:	f0 1f 00 09 	mcall	80002794 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002774:	0f d8       	ld.ub	r8,r7[0x5]
80002776:	1a d8       	st.w	--sp,r8
80002778:	48 ac       	lddpc	r12,800027a0 <dcm_reply_func+0x60>
8000277a:	f0 1f 00 07 	mcall	80002794 <dcm_reply_func+0x54>
8000277e:	2f fd       	sub	sp,-4
80002780:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002784:	48 8c       	lddpc	r12,800027a4 <dcm_reply_func+0x64>
80002786:	f0 1f 00 04 	mcall	80002794 <dcm_reply_func+0x54>
8000278a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278e:	00 00       	add	r0,r0
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	c4 d8       	rjmp	8000282c <app_cfg+0x5c>
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	5c 7c       	castu.h	r12
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	c4 ec       	rcall	80002836 <app_cfg+0x66>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	c5 00       	breq	8000283e <app_cfg+0x6e>
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	c5 14       	brge	80002844 <app_cfg+0x74>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	c5 20       	breq	8000284a <app_cfg+0x7a>

800027a8 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027aa:	19 a9       	ld.ub	r9,r12[0x2]
800027ac:	30 08       	mov	r8,0
800027ae:	f0 09 18 00 	cp.b	r9,r8
800027b2:	c0 51       	brne	800027bc <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b4:	48 4c       	lddpc	r12,800027c4 <ToneControl_reply_func+0x1c>
800027b6:	f0 1f 00 05 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027ba:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027bc:	48 4c       	lddpc	r12,800027cc <ToneControl_reply_func+0x24>
800027be:	f0 1f 00 03 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027c2:	d8 02       	popm	pc
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	c5 2c       	rcall	8000286a <app_cfg+0x9a>
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	5c 7c       	castu.h	r12
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	c5 34       	brge	80002874 <app_cfg+0xa4>

800027d0 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027d0:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027d2:	f0 1f 00 22 	mcall	80002858 <app_cfg+0x88>
800027d6:	4a 28       	lddpc	r8,8000285c <app_cfg+0x8c>
800027d8:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027da:	4a 27       	lddpc	r7,80002860 <app_cfg+0x90>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027dc:	4a 26       	lddpc	r6,80002864 <app_cfg+0x94>
				{
					isAudioRouting++;
				}

				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r Tone_flag: %d \n\r", Tone_flag);
800027de:	4a 35       	lddpc	r5,80002868 <app_cfg+0x98>
800027e0:	4a 34       	lddpc	r4,8000286c <app_cfg+0x9c>
				log("\n\r Tone_counters: %d \n\r", Tone_Counters);
800027e2:	4a 43       	lddpc	r3,80002870 <app_cfg+0xa0>
800027e4:	4a 42       	lddpc	r2,80002874 <app_cfg+0xa4>
				log("\n\r Silent_flag: %d \n\r", Silent_flag);
800027e6:	4a 51       	lddpc	r1,80002878 <app_cfg+0xa8>
800027e8:	4a 50       	lddpc	r0,8000287c <app_cfg+0xac>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027ea:	6e 08       	ld.w	r8,r7[0x0]
800027ec:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f0:	58 38       	cp.w	r8,3
800027f2:	c2 c1       	brne	8000284a <app_cfg+0x7a>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027f4:	6c 08       	ld.w	r8,r6[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c0 61       	brne	80002804 <app_cfg+0x34>
				{
					//xcmp_data_session();
					xcmp_audio_route_mic();
800027fa:	f0 1f 00 22 	mcall	80002880 <app_cfg+0xb0>
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fe:	30 18       	mov	r8,1
80002800:	8d 08       	st.w	r6[0x0],r8
80002802:	c1 48       	rjmp	8000282a <app_cfg+0x5a>
				}
				else if(isAudioRouting == 1)
80002804:	58 18       	cp.w	r8,1
80002806:	c0 41       	brne	8000280e <app_cfg+0x3e>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002808:	30 28       	mov	r8,2
8000280a:	8d 08       	st.w	r6[0x0],r8
8000280c:	c0 f8       	rjmp	8000282a <app_cfg+0x5a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
8000280e:	58 28       	cp.w	r8,2
80002810:	c0 41       	brne	80002818 <app_cfg+0x48>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002812:	30 38       	mov	r8,3
80002814:	8d 08       	st.w	r6[0x0],r8
80002816:	c0 a8       	rjmp	8000282a <app_cfg+0x5a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80002818:	58 38       	cp.w	r8,3
8000281a:	f9 b8 00 04 	moveq	r8,4
8000281e:	ed f8 0a 00 	st.weq	r6[0x0],r8
					
				}
				else
				{
					isAudioRouting++;
80002822:	f7 b8 01 ff 	subne	r8,-1
80002826:	ed f8 1a 00 	st.wne	r6[0x0],r8
				}

				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r Tone_flag: %d \n\r", Tone_flag);
8000282a:	09 88       	ld.ub	r8,r4[0x0]
8000282c:	1a d8       	st.w	--sp,r8
8000282e:	0a 9c       	mov	r12,r5
80002830:	f0 1f 00 15 	mcall	80002884 <app_cfg+0xb4>
				log("\n\r Tone_counters: %d \n\r", Tone_Counters);
80002834:	66 08       	ld.w	r8,r3[0x0]
80002836:	1a d8       	st.w	--sp,r8
80002838:	04 9c       	mov	r12,r2
8000283a:	f0 1f 00 13 	mcall	80002884 <app_cfg+0xb4>
				log("\n\r Silent_flag: %d \n\r", Silent_flag);
8000283e:	01 88       	ld.ub	r8,r0[0x0]
80002840:	1a d8       	st.w	--sp,r8
80002842:	02 9c       	mov	r12,r1
80002844:	f0 1f 00 10 	mcall	80002884 <app_cfg+0xb4>
80002848:	2f dd       	sub	sp,-12
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
8000284a:	e0 6b 0f a0 	mov	r11,4000
8000284e:	48 4c       	lddpc	r12,8000285c <app_cfg+0x8c>
80002850:	f0 1f 00 0e 	mcall	80002888 <app_cfg+0xb8>
	}
80002854:	cc bb       	rjmp	800027ea <app_cfg+0x1a>
80002856:	00 00       	add	r0,r0
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	55 f0       	stdsp	sp[0x17c],r0
8000285c:	00 00       	add	r0,r0
8000285e:	0a 48       	or	r8,r5
80002860:	00 00       	add	r0,r0
80002862:	0d a4       	ld.ub	r4,r6[0x2]
80002864:	00 00       	add	r0,r0
80002866:	0a 44       	or	r4,r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	c5 40       	breq	80002912 <AudioRoutingControl_reply_func+0x42>
8000286c:	00 00       	add	r0,r0
8000286e:	0a 58       	eor	r8,r5
80002870:	00 00       	add	r0,r0
80002872:	0a 54       	eor	r4,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	c5 54       	brge	80002920 <AudioRoutingControl_reply_func+0x50>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	c5 6c       	rcall	80002926 <DeviceInitializationStatus_brdcst_func+0x2>
8000287c:	00 00       	add	r0,r0
8000287e:	0a 5d       	eor	sp,r5
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	39 68       	mov	r8,-106
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	5c 7c       	castu.h	r12
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	57 58       	stdsp	sp[0x1d4],r8

8000288c <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
8000288c:	eb cd 40 80 	pushm	r7,lr
80002890:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002892:	48 b9       	lddpc	r9,800028bc <app_payload_rx_proc+0x30>
80002894:	13 88       	ld.ub	r8,r9[0x0]
80002896:	2f f8       	sub	r8,-1
80002898:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 110)
8000289a:	36 e9       	mov	r9,110
8000289c:	f2 08 18 00 	cp.b	r8,r9
800028a0:	c0 71       	brne	800028ae <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800028a2:	30 09       	mov	r9,0
800028a4:	48 68       	lddpc	r8,800028bc <app_payload_rx_proc+0x30>
800028a6:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800028a8:	48 6c       	lddpc	r12,800028c0 <app_payload_rx_proc+0x34>
800028aa:	f0 1f 00 07 	mcall	800028c4 <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028ae:	48 78       	lddpc	r8,800028c8 <app_payload_rx_proc+0x3c>
800028b0:	70 0c       	ld.w	r12,r8[0x0]
800028b2:	0e 9b       	mov	r11,r7
800028b4:	f0 1f 00 06 	mcall	800028cc <app_payload_rx_proc+0x40>

}
800028b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028bc:	00 00       	add	r0,r0
800028be:	0a 41       	or	r1,r5
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	c5 84       	brge	80002972 <payload_init+0x16>
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	5c 7c       	castu.h	r12
800028c8:	00 00       	add	r0,r0
800028ca:	0a 7c       	tst	r12,r5
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	2a 34       	sub	r4,-93

800028d0 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800028d0:	eb cd 40 80 	pushm	r7,lr
800028d4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800028d6:	19 a9       	ld.ub	r9,r12[0x2]
800028d8:	30 08       	mov	r8,0
800028da:	f0 09 18 00 	cp.b	r9,r8
800028de:	c0 e1       	brne	800028fa <AudioRoutingControl_reply_func+0x2a>
	{
		
		log("AudioRouting OK");
800028e0:	48 cc       	lddpc	r12,80002910 <AudioRoutingControl_reply_func+0x40>
800028e2:	f0 1f 00 0d 	mcall	80002914 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();//提示通道配置成功
800028e6:	f0 1f 00 0d 	mcall	80002918 <AudioRoutingControl_reply_func+0x48>
		xcmp_IdleTestTone();
800028ea:	f0 1f 00 0c 	mcall	80002918 <AudioRoutingControl_reply_func+0x48>
		xcmp_IdleTestTone();
800028ee:	f0 1f 00 0b 	mcall	80002918 <AudioRoutingControl_reply_func+0x48>
		xcmp_IdleTestTone();
800028f2:	f0 1f 00 0a 	mcall	80002918 <AudioRoutingControl_reply_func+0x48>
800028f6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800028fa:	48 9c       	lddpc	r12,8000291c <AudioRoutingControl_reply_func+0x4c>
800028fc:	f0 1f 00 06 	mcall	80002914 <AudioRoutingControl_reply_func+0x44>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002900:	0f a8       	ld.ub	r8,r7[0x2]
80002902:	1a d8       	st.w	--sp,r8
80002904:	48 7c       	lddpc	r12,80002920 <AudioRoutingControl_reply_func+0x50>
80002906:	f0 1f 00 04 	mcall	80002914 <AudioRoutingControl_reply_func+0x44>
8000290a:	2f fd       	sub	sp,-4
8000290c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	c5 90       	breq	800029c4 <payload_rx_process+0x30>
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	5c 7c       	castu.h	r12
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	3a 50       	mov	r0,-91
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	c5 a0       	breq	800029d2 <payload_rx_process+0x3e>
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	c5 b4       	brge	800029d8 <payload_rx_process+0x44>

80002924 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002924:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002926:	19 e8       	ld.ub	r8,r12[0x6]
80002928:	30 19       	mov	r9,1
8000292a:	f2 08 18 00 	cp.b	r8,r9
8000292e:	c0 61       	brne	8000293a <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002930:	48 98       	lddpc	r8,80002954 <DeviceInitializationStatus_brdcst_func+0x30>
80002932:	70 09       	ld.w	r9,r8[0x0]
80002934:	a1 a9       	sbr	r9,0x0
80002936:	91 09       	st.w	r8[0x0],r9
80002938:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000293a:	30 29       	mov	r9,2
8000293c:	f2 08 18 00 	cp.b	r8,r9
80002940:	c0 80       	breq	80002950 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002942:	48 58       	lddpc	r8,80002954 <DeviceInitializationStatus_brdcst_func+0x30>
80002944:	70 09       	ld.w	r9,r8[0x0]
80002946:	e0 19 ff fc 	andl	r9,0xfffc
8000294a:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
8000294c:	f0 1f 00 03 	mcall	80002958 <DeviceInitializationStatus_brdcst_func+0x34>
80002950:	d8 02       	popm	pc
80002952:	00 00       	add	r0,r0
80002954:	00 00       	add	r0,r0
80002956:	0d a4       	ld.ub	r4,r6[0x2]
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	39 a4       	mov	r4,-102

8000295c <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
8000295c:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000295e:	48 98       	lddpc	r8,80002980 <payload_init+0x24>
80002960:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002962:	48 98       	lddpc	r8,80002984 <payload_init+0x28>
80002964:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002966:	30 09       	mov	r9,0
80002968:	1a d9       	st.w	--sp,r9
8000296a:	1a d9       	st.w	--sp,r9
8000296c:	1a d9       	st.w	--sp,r9
8000296e:	30 28       	mov	r8,2
80002970:	e0 6a 04 00 	mov	r10,1024
80002974:	48 5b       	lddpc	r11,80002988 <payload_init+0x2c>
80002976:	48 6c       	lddpc	r12,8000298c <payload_init+0x30>
80002978:	f0 1f 00 06 	mcall	80002990 <payload_init+0x34>
8000297c:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000297e:	d8 02       	popm	pc
80002980:	00 00       	add	r0,r0
80002982:	0a 64       	and	r4,r5
80002984:	00 00       	add	r0,r0
80002986:	0a 68       	and	r8,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	cb 84       	brge	800028fa <AudioRoutingControl_reply_func+0x2a>
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	29 94       	sub	r4,-103
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	58 b8       	cp.w	r8,11

80002994 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002994:	eb cd 40 f8 	pushm	r3-r7,lr
80002998:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000299a:	48 e8       	lddpc	r8,800029d0 <payload_rx_process+0x3c>
8000299c:	70 08       	ld.w	r8,r8[0x0]
8000299e:	58 08       	cp.w	r8,0
800029a0:	c0 71       	brne	800029ae <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800029a2:	30 4b       	mov	r11,4
800029a4:	30 5c       	mov	r12,5
800029a6:	f0 1f 00 0c 	mcall	800029d4 <payload_rx_process+0x40>
800029aa:	48 a8       	lddpc	r8,800029d0 <payload_rx_process+0x3c>
800029ac:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029ae:	48 96       	lddpc	r6,800029d0 <payload_rx_process+0x3c>
800029b0:	30 05       	mov	r5,0
800029b2:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
800029b4:	48 93       	lddpc	r3,800029d8 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029b6:	6c 0c       	ld.w	r12,r6[0x0]
800029b8:	0a 99       	mov	r9,r5
800029ba:	08 9a       	mov	r10,r4
800029bc:	1a 9b       	mov	r11,sp
800029be:	f0 1f 00 08 	mcall	800029dc <payload_rx_process+0x48>
800029c2:	58 1c       	cp.w	r12,1
800029c4:	cf 91       	brne	800029b6 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
800029c6:	66 08       	ld.w	r8,r3[0x0]
800029c8:	40 0c       	lddsp	r12,sp[0x0]
800029ca:	5d 18       	icall	r8
800029cc:	cf 5b       	rjmp	800029b6 <payload_rx_process+0x22>
800029ce:	00 00       	add	r0,r0
800029d0:	00 00       	add	r0,r0
800029d2:	0a 80       	andn	r0,r5
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	51 e4       	stdsp	sp[0x78],r4
800029d8:	00 00       	add	r0,r0
800029da:	0a 64       	and	r4,r5
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	4e 80       	lddpc	r0,80002b7c <phy_tx_func+0xa4>

800029e0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029e0:	d4 01       	pushm	lr
800029e2:	20 2d       	sub	sp,8
800029e4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029e6:	30 09       	mov	r9,0
800029e8:	fa ca ff f8 	sub	r10,sp,-8
800029ec:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029ee:	1a 9b       	mov	r11,sp
800029f0:	f0 1f 00 02 	mcall	800029f8 <set_idle_store_isr+0x18>
}
800029f4:	2f ed       	sub	sp,-8
800029f6:	d8 02       	popm	pc
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	50 3c       	stdsp	sp[0xc],r12

800029fc <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029fc:	d4 01       	pushm	lr
800029fe:	20 2d       	sub	sp,8
80002a00:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a02:	58 0c       	cp.w	r12,0
80002a04:	c1 10       	breq	80002a26 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a06:	30 08       	mov	r8,0
80002a08:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a0a:	98 88       	ld.uh	r8,r12[0x0]
80002a0c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a10:	e0 48 40 00 	cp.w	r8,16384
80002a14:	c0 91       	brne	80002a26 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a16:	48 68       	lddpc	r8,80002a2c <phy_rx+0x30>
80002a18:	70 0c       	ld.w	r12,r8[0x0]
80002a1a:	30 09       	mov	r9,0
80002a1c:	fa ca ff fc 	sub	r10,sp,-4
80002a20:	1a 9b       	mov	r11,sp
80002a22:	f0 1f 00 04 	mcall	80002a30 <phy_rx+0x34>
		}	

    }
		
 
}
80002a26:	2f ed       	sub	sp,-8
80002a28:	d8 02       	popm	pc
80002a2a:	00 00       	add	r0,r0
80002a2c:	00 00       	add	r0,r0
80002a2e:	0a c0       	st.b	r5++,r0
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	50 3c       	stdsp	sp[0xc],r12

80002a34 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a34:	eb cd 40 80 	pushm	r7,lr
80002a38:	20 1d       	sub	sp,4
80002a3a:	fa c7 ff fc 	sub	r7,sp,-4
80002a3e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a40:	30 09       	mov	r9,0
80002a42:	12 9a       	mov	r10,r9
80002a44:	1a 9b       	mov	r11,sp
80002a46:	f0 1f 00 03 	mcall	80002a50 <set_idle_store+0x1c>
}
80002a4a:	2f fd       	sub	sp,-4
80002a4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	50 8c       	stdsp	sp[0x20],r12

80002a54 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a54:	d4 01       	pushm	lr
80002a56:	20 1d       	sub	sp,4
80002a58:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a5a:	98 88       	ld.uh	r8,r12[0x0]
80002a5c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a60:	e0 48 40 00 	cp.w	r8,16384
80002a64:	c0 d1       	brne	80002a7e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a66:	49 08       	lddpc	r8,80002aa4 <phy_tx+0x50>
80002a68:	70 08       	ld.w	r8,r8[0x0]
80002a6a:	58 08       	cp.w	r8,0
80002a6c:	c1 a0       	breq	80002aa0 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a6e:	48 e8       	lddpc	r8,80002aa4 <phy_tx+0x50>
80002a70:	70 0c       	ld.w	r12,r8[0x0]
80002a72:	30 09       	mov	r9,0
80002a74:	12 9a       	mov	r10,r9
80002a76:	1a 9b       	mov	r11,sp
80002a78:	f0 1f 00 0c 	mcall	80002aa8 <phy_tx+0x54>
80002a7c:	c1 28       	rjmp	80002aa0 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a7e:	e0 48 10 00 	cp.w	r8,4096
80002a82:	5f 0a       	sreq	r10
80002a84:	e0 48 20 00 	cp.w	r8,8192
80002a88:	5f 09       	sreq	r9
80002a8a:	f5 e9 10 09 	or	r9,r10,r9
80002a8e:	c0 71       	brne	80002a9c <phy_tx+0x48>
80002a90:	e0 48 50 00 	cp.w	r8,20480
80002a94:	c0 40       	breq	80002a9c <phy_tx+0x48>
80002a96:	e0 48 60 00 	cp.w	r8,24576
80002a9a:	c0 31       	brne	80002aa0 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a9c:	48 48       	lddpc	r8,80002aac <phy_tx+0x58>
80002a9e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002aa0:	2f fd       	sub	sp,-4
80002aa2:	d8 02       	popm	pc
80002aa4:	00 00       	add	r0,r0
80002aa6:	0a d0       	st.w	--r5,r0
80002aa8:	80 00       	ld.sh	r0,r0[0x0]
80002aaa:	50 8c       	stdsp	sp[0x20],r12
80002aac:	00 00       	add	r0,r0
80002aae:	0a b8       	st.h	r5++,r8

80002ab0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002ab0:	d4 01       	pushm	lr
80002ab2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ab4:	30 08       	mov	r8,0
80002ab6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ab8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002aba:	1a 9a       	mov	r10,sp
80002abc:	fa cb ff fc 	sub	r11,sp,-4
80002ac0:	f0 1f 00 05 	mcall	80002ad4 <get_idle_store_isr+0x24>
80002ac4:	58 1c       	cp.w	r12,1
80002ac6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002aca:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002ace:	2f ed       	sub	sp,-8
80002ad0:	d8 02       	popm	pc
80002ad2:	00 00       	add	r0,r0
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	4d 90       	lddpc	r0,80002c38 <phy_tx_func+0x160>

80002ad8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002ad8:	eb cd 40 c0 	pushm	r6-r7,lr
80002adc:	20 1d       	sub	sp,4
80002ade:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002ae0:	fe f8 04 a8 	ld.w	r8,pc[1192]
80002ae4:	70 08       	ld.w	r8,r8[0x0]
80002ae6:	58 08       	cp.w	r8,0
80002ae8:	c7 40       	breq	80002bd0 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002aea:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aec:	30 08       	mov	r8,0
80002aee:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002af0:	fe f8 04 9c 	ld.w	r8,pc[1180]
80002af4:	70 08       	ld.w	r8,r8[0x0]
80002af6:	58 18       	cp.w	r8,1
80002af8:	c2 90       	breq	80002b4a <phy_tx_func+0x72>
80002afa:	c0 43       	brcs	80002b02 <phy_tx_func+0x2a>
80002afc:	58 28       	cp.w	r8,2
80002afe:	c6 91       	brne	80002bd0 <phy_tx_func+0xf8>
80002b00:	c6 18       	rjmp	80002bc2 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b02:	fe f8 04 86 	ld.w	r8,pc[1158]
80002b06:	70 0c       	ld.w	r12,r8[0x0]
80002b08:	1a 9a       	mov	r10,sp
80002b0a:	fe fb 04 86 	ld.w	r11,pc[1158]
80002b0e:	f0 1f 01 22 	mcall	80002f94 <phy_tx_func+0x4bc>
80002b12:	58 1c       	cp.w	r12,1
80002b14:	c1 51       	brne	80002b3e <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b16:	fe f8 04 7a 	ld.w	r8,pc[1146]
80002b1a:	70 08       	ld.w	r8,r8[0x0]
80002b1c:	11 9a       	ld.ub	r10,r8[0x1]
80002b1e:	fe f9 04 7a 	ld.w	r9,pc[1146]
80002b22:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b24:	90 88       	ld.uh	r8,r8[0x0]
80002b26:	ea 18 ab cd 	orh	r8,0xabcd
80002b2a:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b2c:	30 19       	mov	r9,1
80002b2e:	fe f8 04 6e 	ld.w	r8,pc[1134]
80002b32:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b34:	30 19       	mov	r9,1
80002b36:	fe f8 04 56 	ld.w	r8,pc[1110]
80002b3a:	91 09       	st.w	r8[0x0],r9
80002b3c:	c4 a8       	rjmp	80002bd0 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b3e:	e0 68 5a 5a 	mov	r8,23130
80002b42:	ea 18 ab cd 	orh	r8,0xabcd
80002b46:	8f 18       	st.w	r7[0x4],r8
80002b48:	c4 48       	rjmp	80002bd0 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b4a:	fe f9 04 52 	ld.w	r9,pc[1106]
80002b4e:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b50:	fe fa 04 40 	ld.w	r10,pc[1088]
80002b54:	74 0a       	ld.w	r10,r10[0x0]
80002b56:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b5a:	b1 6a       	lsl	r10,0x10
80002b5c:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b5e:	2f f8       	sub	r8,-1
80002b60:	5c 58       	castu.b	r8
80002b62:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b64:	fe fa 04 34 	ld.w	r10,pc[1076]
80002b68:	94 09       	ld.sh	r9,r10[0x0]
80002b6a:	20 29       	sub	r9,2
80002b6c:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b6e:	30 0a       	mov	r10,0
80002b70:	f4 09 19 00 	cp.h	r9,r10
80002b74:	e0 89 00 0b 	brgt	80002b8a <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b78:	78 18       	ld.w	r8,r12[0x4]
80002b7a:	e8 18 00 ba 	orl	r8,0xba
80002b7e:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b80:	30 09       	mov	r9,0
80002b82:	fe f8 04 0a 	ld.w	r8,pc[1034]
80002b86:	91 09       	st.w	r8[0x0],r9
80002b88:	c2 48       	rjmp	80002bd0 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b8a:	fe f9 04 06 	ld.w	r9,pc[1030]
80002b8e:	72 09       	ld.w	r9,r9[0x0]
80002b90:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b94:	78 1a       	ld.w	r10,r12[0x4]
80002b96:	f5 e9 10 09 	or	r9,r10,r9
80002b9a:	99 19       	st.w	r12[0x4],r9
80002b9c:	2f f8       	sub	r8,-1
80002b9e:	fe f9 03 fe 	ld.w	r9,pc[1022]
80002ba2:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002ba4:	fe f9 03 f4 	ld.w	r9,pc[1012]
80002ba8:	92 08       	ld.sh	r8,r9[0x0]
80002baa:	20 28       	sub	r8,2
80002bac:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bae:	30 09       	mov	r9,0
80002bb0:	f2 08 19 00 	cp.h	r8,r9
80002bb4:	e0 89 00 0e 	brgt	80002bd0 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002bb8:	30 29       	mov	r9,2
80002bba:	fe f8 03 d2 	ld.w	r8,pc[978]
80002bbe:	91 09       	st.w	r8[0x0],r9
80002bc0:	c0 88       	rjmp	80002bd0 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bc2:	fc 18 00 ba 	movh	r8,0xba
80002bc6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bc8:	30 09       	mov	r9,0
80002bca:	fe f8 03 c2 	ld.w	r8,pc[962]
80002bce:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80002bd0:	fe f8 03 d0 	ld.w	r8,pc[976]
80002bd4:	11 89       	ld.ub	r9,r8[0x0]
80002bd6:	30 18       	mov	r8,1
80002bd8:	f0 09 18 00 	cp.b	r9,r8
80002bdc:	c0 90       	breq	80002bee <phy_tx_func+0x116>
80002bde:	fe f8 03 c6 	ld.w	r8,pc[966]
80002be2:	11 89       	ld.ub	r9,r8[0x0]
80002be4:	30 18       	mov	r8,1
80002be6:	f0 09 18 00 	cp.b	r9,r8
80002bea:	e0 81 01 54 	brne	80002e92 <phy_tx_func+0x3ba>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002bee:	fe f8 03 ba 	ld.w	r8,pc[954]
80002bf2:	70 08       	ld.w	r8,r8[0x0]
80002bf4:	e0 48 05 b0 	cp.w	r8,1456
80002bf8:	f9 b8 02 00 	movhs	r8,0
80002bfc:	fe f9 03 ac 	ld.w	r9,pc[940]
80002c00:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002c02:	fe f9 03 aa 	ld.w	r9,pc[938]
80002c06:	72 09       	ld.w	r9,r9[0x0]
80002c08:	58 29       	cp.w	r9,2
80002c0a:	e0 80 00 91 	breq	80002d2c <phy_tx_func+0x254>
80002c0e:	e0 8b 00 08 	brhi	80002c1e <phy_tx_func+0x146>
80002c12:	58 09       	cp.w	r9,0
80002c14:	c0 e0       	breq	80002c30 <phy_tx_func+0x158>
80002c16:	58 19       	cp.w	r9,1
80002c18:	e0 81 01 33 	brne	80002e7e <phy_tx_func+0x3a6>
80002c1c:	c5 78       	rjmp	80002cca <phy_tx_func+0x1f2>
80002c1e:	58 49       	cp.w	r9,4
80002c20:	e0 80 00 c2 	breq	80002da4 <phy_tx_func+0x2cc>
80002c24:	e0 83 00 9a 	brlo	80002d58 <phy_tx_func+0x280>
80002c28:	58 59       	cp.w	r9,5
80002c2a:	e0 81 01 2a 	brne	80002e7e <phy_tx_func+0x3a6>
80002c2e:	c1 d9       	rjmp	80002e68 <phy_tx_func+0x390>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c30:	fe f8 03 80 	ld.w	r8,pc[896]
80002c34:	70 08       	ld.w	r8,r8[0x0]
80002c36:	58 08       	cp.w	r8,0
80002c38:	c0 b0       	breq	80002c4e <phy_tx_func+0x176>
80002c3a:	fe f8 03 76 	ld.w	r8,pc[886]
80002c3e:	70 08       	ld.w	r8,r8[0x0]
80002c40:	58 a8       	cp.w	r8,10
80002c42:	c0 60       	breq	80002c4e <phy_tx_func+0x176>
80002c44:	fe f8 03 6c 	ld.w	r8,pc[876]
80002c48:	70 08       	ld.w	r8,r8[0x0]
80002c4a:	58 18       	cp.w	r8,1
80002c4c:	c0 a1       	brne	80002c60 <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c4e:	e0 68 5a 5a 	mov	r8,23130
80002c52:	ea 18 ab cd 	orh	r8,0xabcd
80002c56:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c58:	30 08       	mov	r8,0
80002c5a:	8f 38       	st.w	r7[0xc],r8
80002c5c:	e0 8f 01 92 	bral	80002f80 <phy_tx_func+0x4a8>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c60:	fe f8 03 50 	ld.w	r8,pc[848]
80002c64:	70 08       	ld.w	r8,r8[0x0]
80002c66:	58 38       	cp.w	r8,3
80002c68:	c0 91       	brne	80002c7a <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c6a:	fe f8 03 4a 	ld.w	r8,pc[842]
80002c6e:	70 09       	ld.w	r9,r8[0x0]
80002c70:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c72:	70 18       	ld.w	r8,r8[0x4]
80002c74:	8f 38       	st.w	r7[0xc],r8
80002c76:	e0 8f 01 85 	bral	80002f80 <phy_tx_func+0x4a8>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c7a:	fe f8 03 36 	ld.w	r8,pc[822]
80002c7e:	70 08       	ld.w	r8,r8[0x0]
80002c80:	58 28       	cp.w	r8,2
80002c82:	c1 31       	brne	80002ca8 <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80002c84:	e0 68 c0 14 	mov	r8,49172
80002c88:	ea 18 ab cd 	orh	r8,0xabcd
80002c8c:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c8e:	fe 78 84 7f 	mov	r8,-31617
80002c92:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c94:	fe f8 03 24 	ld.w	r8,pc[804]
80002c98:	90 08       	ld.sh	r8,r8[0x0]
80002c9a:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c9c:	30 39       	mov	r9,3
80002c9e:	fe f8 03 0e 	ld.w	r8,pc[782]
80002ca2:	91 09       	st.w	r8[0x0],r9
80002ca4:	e0 8f 01 6e 	bral	80002f80 <phy_tx_func+0x4a8>
					
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002ca8:	e0 68 c0 0e 	mov	r8,49166
80002cac:	ea 18 ab cd 	orh	r8,0xabcd
80002cb0:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002cb2:	fe f8 03 0a 	ld.w	r8,pc[778]
80002cb6:	90 09       	ld.sh	r9,r8[0x0]
80002cb8:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002cba:	90 18       	ld.sh	r8,r8[0x2]
80002cbc:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002cbe:	30 19       	mov	r9,1
80002cc0:	fe f8 02 ec 	ld.w	r8,pc[748]
80002cc4:	91 09       	st.w	r8[0x0],r9
80002cc6:	e0 8f 01 5d 	bral	80002f80 <phy_tx_func+0x4a8>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002cca:	fe 78 88 f2 	mov	r8,-30478
80002cce:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cd0:	fe f8 02 d8 	ld.w	r8,pc[728]
80002cd4:	70 0a       	ld.w	r10,r8[0x0]
80002cd6:	fe f9 02 ea 	ld.w	r9,pc[746]
80002cda:	f2 0a 00 0b 	add	r11,r9,r10
80002cde:	17 9b       	ld.ub	r11,r11[0x1]
80002ce0:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002ce4:	a9 6a       	lsl	r10,0x8
80002ce6:	f6 0a 00 0a 	add	r10,r11,r10
80002cea:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002cec:	70 0a       	ld.w	r10,r8[0x0]
80002cee:	2f ea       	sub	r10,-2
80002cf0:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cf2:	f2 0a 00 0b 	add	r11,r9,r10
80002cf6:	17 9b       	ld.ub	r11,r11[0x1]
80002cf8:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002cfc:	a9 6a       	lsl	r10,0x8
80002cfe:	f6 0a 00 0a 	add	r10,r11,r10
80002d02:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002d04:	70 0a       	ld.w	r10,r8[0x0]
80002d06:	2f ea       	sub	r10,-2
80002d08:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002d0a:	f2 0a 00 0b 	add	r11,r9,r10
80002d0e:	17 9b       	ld.ub	r11,r11[0x1]
80002d10:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002d14:	a9 69       	lsl	r9,0x8
80002d16:	f6 09 00 09 	add	r9,r11,r9
80002d1a:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002d1c:	70 09       	ld.w	r9,r8[0x0]
80002d1e:	2f e9       	sub	r9,-2
80002d20:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002d22:	30 29       	mov	r9,2
80002d24:	fe f8 02 88 	ld.w	r8,pc[648]
80002d28:	91 09       	st.w	r8[0x0],r9
80002d2a:	c2 b9       	rjmp	80002f80 <phy_tx_func+0x4a8>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
80002d2c:	fe f9 02 94 	ld.w	r9,pc[660]
80002d30:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002d34:	a9 68       	lsl	r8,0x8
80002d36:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002d38:	fe f8 02 70 	ld.w	r8,pc[624]
80002d3c:	70 09       	ld.w	r9,r8[0x0]
80002d3e:	2f f9       	sub	r9,-1
80002d40:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d42:	e0 68 00 ba 	mov	r8,186
80002d46:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d48:	30 08       	mov	r8,0
80002d4a:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d4c:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d4e:	30 09       	mov	r9,0
80002d50:	fe f8 02 5c 	ld.w	r8,pc[604]
80002d54:	91 09       	st.w	r8[0x0],r9
80002d56:	c1 59       	rjmp	80002f80 <phy_tx_func+0x4a8>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d58:	fe f8 02 60 	ld.w	r8,pc[608]
80002d5c:	90 18       	ld.sh	r8,r8[0x2]
80002d5e:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d60:	fe f8 02 5c 	ld.w	r8,pc[604]
80002d64:	90 08       	ld.sh	r8,r8[0x0]
80002d66:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d68:	fe f8 02 48 	ld.w	r8,pc[584]
80002d6c:	70 08       	ld.w	r8,r8[0x0]
80002d6e:	58 48       	cp.w	r8,4
80002d70:	c0 e1       	brne	80002d8c <phy_tx_func+0x2b4>
80002d72:	fe f8 02 52 	ld.w	r8,pc[594]
80002d76:	11 89       	ld.ub	r9,r8[0x0]
80002d78:	30 18       	mov	r8,1
80002d7a:	f0 09 18 00 	cp.b	r9,r8
80002d7e:	c0 71       	brne	80002d8c <phy_tx_func+0x2b4>
					{
						// Vocoder Bits Stream Parameter("E" flag = 1)
						//0xF08x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0080));
80002d80:	fe f8 02 3c 	ld.w	r8,pc[572]
80002d84:	90 18       	ld.sh	r8,r8[0x2]
80002d86:	a7 b8       	sbr	r8,0x7
80002d88:	ae 68       	st.h	r7[0xc],r8
80002d8a:	c0 58       	rjmp	80002d94 <phy_tx_func+0x2bc>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d8c:	fe f8 02 30 	ld.w	r8,pc[560]
80002d90:	90 18       	ld.sh	r8,r8[0x2]
80002d92:	ae 68       	st.h	r7[0xc],r8
					
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002d94:	fe 78 88 f3 	mov	r8,-30477
80002d98:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d9a:	30 49       	mov	r9,4
80002d9c:	fe f8 02 10 	ld.w	r8,pc[528]
80002da0:	91 09       	st.w	r8[0x0],r9
80002da2:	ce f8       	rjmp	80002f80 <phy_tx_func+0x4a8>
					
				break;
			case AMBE_DE_SECOND:
					
				switch (m_RxBurstType)//在发送函数中去做解密处理
80002da4:	fe f8 02 0c 	ld.w	r8,pc[524]
80002da8:	70 08       	ld.w	r8,r8[0x0]
80002daa:	58 48       	cp.w	r8,4
80002dac:	c0 60       	breq	80002db8 <phy_tx_func+0x2e0>
80002dae:	c5 33       	brcs	80002e54 <phy_tx_func+0x37c>
80002db0:	58 98       	cp.w	r8,9
80002db2:	e0 8b 00 51 	brhi	80002e54 <phy_tx_func+0x37c>
80002db6:	c3 68       	rjmp	80002e22 <phy_tx_func+0x34a>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002db8:	fe f8 02 0c 	ld.w	r8,pc[524]
80002dbc:	11 89       	ld.ub	r9,r8[0x0]
80002dbe:	30 18       	mov	r8,1
80002dc0:	f0 09 18 00 	cp.b	r9,r8
80002dc4:	c1 61       	brne	80002df0 <phy_tx_func+0x318>
							{	
								//Pick up public key
								
								AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002dc6:	fe f8 02 02 	ld.w	r8,pc[514]
80002dca:	90 0a       	ld.sh	r10,r8[0x0]
80002dcc:	fe f9 02 00 	ld.w	r9,pc[512]
80002dd0:	b2 0a       	st.h	r9[0x0],r10
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002dd2:	90 1a       	ld.sh	r10,r8[0x2]
80002dd4:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002dd6:	90 2a       	ld.sh	r10,r8[0x4]
80002dd8:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002dda:	90 3a       	ld.sh	r10,r8[0x6]
80002ddc:	b2 3a       	st.h	r9[0x6],r10
								
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[0] ;
80002dde:	90 09       	ld.sh	r9,r8[0x0]
80002de0:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[1] ;
80002de2:	90 19       	ld.sh	r9,r8[0x2]
80002de4:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[2] ;
80002de6:	90 29       	ld.sh	r9,r8[0x4]
80002de8:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = AMBEBurst_rawdata[3] ;
80002dea:	90 38       	ld.sh	r8,r8[0x6]
80002dec:	ae 78       	st.h	r7[0xe],r8
80002dee:	c1 68       	rjmp	80002e1a <phy_tx_func+0x342>
								
								
						
								//Decrypt AMBE data(XOR) 
								//Recover data
								payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002df0:	4f 79       	lddpc	r9,80002fcc <phy_tx_func+0x4f4>
80002df2:	92 0a       	ld.sh	r10,r9[0x0]
80002df4:	4f 58       	lddpc	r8,80002fc8 <phy_tx_func+0x4f0>
80002df6:	90 0b       	ld.sh	r11,r8[0x0]
80002df8:	f7 ea 20 0a 	eor	r10,r11,r10
80002dfc:	ae 4a       	st.h	r7[0x8],r10
								payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002dfe:	92 1a       	ld.sh	r10,r9[0x2]
80002e00:	90 1b       	ld.sh	r11,r8[0x2]
80002e02:	f7 ea 20 0a 	eor	r10,r11,r10
80002e06:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002e08:	92 2a       	ld.sh	r10,r9[0x4]
80002e0a:	90 2b       	ld.sh	r11,r8[0x4]
80002e0c:	f7 ea 20 0a 	eor	r10,r11,r10
80002e10:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002e12:	92 39       	ld.sh	r9,r9[0x6]
80002e14:	90 38       	ld.sh	r8,r8[0x6]
80002e16:	12 58       	eor	r8,r9
80002e18:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002e1a:	30 59       	mov	r9,5
80002e1c:	4e 48       	lddpc	r8,80002fac <phy_tx_func+0x4d4>
80002e1e:	91 09       	st.w	r8[0x0],r9
80002e20:	cb 08       	rjmp	80002f80 <phy_tx_func+0x4a8>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e22:	4e b9       	lddpc	r9,80002fcc <phy_tx_func+0x4f4>
80002e24:	92 0a       	ld.sh	r10,r9[0x0]
80002e26:	4e 98       	lddpc	r8,80002fc8 <phy_tx_func+0x4f0>
80002e28:	90 0b       	ld.sh	r11,r8[0x0]
80002e2a:	f7 ea 20 0a 	eor	r10,r11,r10
80002e2e:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002e30:	92 1a       	ld.sh	r10,r9[0x2]
80002e32:	90 1b       	ld.sh	r11,r8[0x2]
80002e34:	f7 ea 20 0a 	eor	r10,r11,r10
80002e38:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002e3a:	92 2a       	ld.sh	r10,r9[0x4]
80002e3c:	90 2b       	ld.sh	r11,r8[0x4]
80002e3e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e42:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002e44:	92 39       	ld.sh	r9,r9[0x6]
80002e46:	90 38       	ld.sh	r8,r8[0x6]
80002e48:	12 58       	eor	r8,r9
80002e4a:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002e4c:	30 59       	mov	r9,5
80002e4e:	4d 88       	lddpc	r8,80002fac <phy_tx_func+0x4d4>
80002e50:	91 09       	st.w	r8[0x0],r9
80002e52:	c9 78       	rjmp	80002f80 <phy_tx_func+0x4a8>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e54:	e0 68 5a 5a 	mov	r8,23130
80002e58:	ea 18 ab cd 	orh	r8,0xabcd
80002e5c:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e5e:	30 08       	mov	r8,0
80002e60:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002e62:	4d 39       	lddpc	r9,80002fac <phy_tx_func+0x4d4>
80002e64:	93 08       	st.w	r9[0x0],r8
80002e66:	c8 d8       	rjmp	80002f80 <phy_tx_func+0x4a8>
		
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002e68:	e0 68 00 ba 	mov	r8,186
80002e6c:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002e6e:	30 08       	mov	r8,0
80002e70:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e72:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e74:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e76:	30 09       	mov	r9,0
80002e78:	4c d8       	lddpc	r8,80002fac <phy_tx_func+0x4d4>
80002e7a:	91 09       	st.w	r8[0x0],r9
80002e7c:	c8 28       	rjmp	80002f80 <phy_tx_func+0x4a8>
				
				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e7e:	e0 68 5a 5a 	mov	r8,23130
80002e82:	ea 18 ab cd 	orh	r8,0xabcd
80002e86:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e88:	30 08       	mov	r8,0
80002e8a:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e8c:	4c 89       	lddpc	r9,80002fac <phy_tx_func+0x4d4>
80002e8e:	93 08       	st.w	r9[0x0],r8
80002e90:	c7 88       	rjmp	80002f80 <phy_tx_func+0x4a8>

	else//Send-PCM-data（注意测试回放时：数字信道码流为320bytes/20ms)
	{
		
		
		Payload_frame_DATA_1 = ((PCM_frame_Payload[0]<<16) | (PCM_frame_Payload[1]));
80002e92:	4d 08       	lddpc	r8,80002fd0 <phy_tx_func+0x4f8>
80002e94:	90 0a       	ld.sh	r10,r8[0x0]
80002e96:	90 19       	ld.sh	r9,r8[0x2]
80002e98:	5c 79       	castu.h	r9
80002e9a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002e9e:	4c ea       	lddpc	r10,80002fd4 <phy_tx_func+0x4fc>
80002ea0:	95 09       	st.w	r10[0x0],r9
		Payload_frame_DATA_2 = ((PCM_frame_Payload[2]<<16) | (PCM_frame_Payload[3]));
80002ea2:	90 2a       	ld.sh	r10,r8[0x4]
80002ea4:	90 38       	ld.sh	r8,r8[0x6]
80002ea6:	5c 78       	castu.h	r8
80002ea8:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80002eac:	4c ba       	lddpc	r10,80002fd8 <phy_tx_func+0x500>
80002eae:	95 08       	st.w	r10[0x0],r8
		
		if ((Payload_frame_DATA_1 == PAYLOADIDLE0) || (0x00000003 != (bunchofrandomstatusflags & 0x00000003)))
80002eb0:	e0 6c 5a 5a 	mov	r12,23130
80002eb4:	ea 1c ab cd 	orh	r12,0xabcd
80002eb8:	18 39       	cp.w	r9,r12
80002eba:	c0 70       	breq	80002ec8 <phy_tx_func+0x3f0>
80002ebc:	4c 8a       	lddpc	r10,80002fdc <phy_tx_func+0x504>
80002ebe:	74 0a       	ld.w	r10,r10[0x0]
80002ec0:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002ec4:	58 3a       	cp.w	r10,3
80002ec6:	c0 90       	breq	80002ed8 <phy_tx_func+0x400>
		{
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec8:	e0 68 5a 5a 	mov	r8,23130
80002ecc:	ea 18 ab cd 	orh	r8,0xabcd
80002ed0:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ed2:	30 08       	mov	r8,0
80002ed4:	8f 38       	st.w	r7[0xc],r8
80002ed6:	c5 58       	rjmp	80002f80 <phy_tx_func+0x4a8>
				
				//if((Radio_Transmit_State == 1) && (Mic_is_Enabled == 1))//加密发送
				//发送方加密				
					//头和尾数据不变
					
					if ( ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD2000) || ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD1000)
80002ed8:	12 9a       	mov	r10,r9
80002eda:	e0 1a f0 00 	andl	r10,0xf000
80002ede:	e0 6b 20 00 	mov	r11,8192
80002ee2:	ea 1b ab cd 	orh	r11,0xabcd
80002ee6:	16 3a       	cp.w	r10,r11
80002ee8:	5f 0b       	sreq	r11
80002eea:	e0 6c 10 00 	mov	r12,4096
80002eee:	ea 1c ab cd 	orh	r12,0xabcd
80002ef2:	18 3a       	cp.w	r10,r12
80002ef4:	5f 0a       	sreq	r10
80002ef6:	f7 ea 10 0a 	or	r10,r11,r10
80002efa:	c1 71       	brne	80002f28 <phy_tx_func+0x450>
80002efc:	12 9a       	mov	r10,r9
80002efe:	e0 1a 00 00 	andl	r10,0x0
80002f02:	fc 1b 00 ba 	movh	r11,0xba
80002f06:	16 3a       	cp.w	r10,r11
80002f08:	c1 00       	breq	80002f28 <phy_tx_func+0x450>
80002f0a:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80002f0e:	e0 4a 00 ba 	cp.w	r10,186
80002f12:	c0 b0       	breq	80002f28 <phy_tx_func+0x450>
80002f14:	10 9a       	mov	r10,r8
80002f16:	e0 1a 00 00 	andl	r10,0x0
80002f1a:	16 3a       	cp.w	r10,r11
80002f1c:	c0 60       	breq	80002f28 <phy_tx_func+0x450>
80002f1e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80002f22:	e0 48 00 ba 	cp.w	r8,186
80002f26:	c0 61       	brne	80002f32 <phy_tx_func+0x45a>
					|| ((Payload_frame_DATA_2 & 0xFFFF0000) == 0x00BA0000) || ((Payload_frame_DATA_2 & 0x0000FFFF) == 0x000000BA) )//header terminator
					{
				
							//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
							
							payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002f28:	8f 29       	st.w	r7[0x8],r9
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002f2a:	4a c8       	lddpc	r8,80002fd8 <phy_tx_func+0x500>
80002f2c:	70 08       	ld.w	r8,r8[0x0]
80002f2e:	8f 38       	st.w	r7[0xc],r8
80002f30:	c2 88       	rjmp	80002f80 <phy_tx_func+0x4a8>
					//中间数据
					else//PCM encryption
					{
						//(Tone_flag == 1) 
						//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
						if (Silent_flag)
80002f32:	4a c8       	lddpc	r8,80002fe0 <phy_tx_func+0x508>
80002f34:	11 8a       	ld.ub	r10,r8[0x0]
80002f36:	30 08       	mov	r8,0
80002f38:	f0 0a 18 00 	cp.b	r10,r8
80002f3c:	c0 60       	breq	80002f48 <phy_tx_func+0x470>
						{
							//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
							payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002f3e:	8f 29       	st.w	r7[0x8],r9
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002f40:	4a 68       	lddpc	r8,80002fd8 <phy_tx_func+0x500>
80002f42:	70 08       	ld.w	r8,r8[0x0]
80002f44:	8f 38       	st.w	r7[0xc],r8
80002f46:	c1 d8       	rjmp	80002f80 <phy_tx_func+0x4a8>
						else
						{
							//if(0x00000003 == (bunchofrandomstatusflags & 0x00000003))
							{
								//logFromISR("\n\r XXQ:%X \n\r", Payload_frame_DATA_1);
								if (Tone_flag)
80002f48:	4a 78       	lddpc	r8,80002fe4 <phy_tx_func+0x50c>
80002f4a:	11 8a       	ld.ub	r10,r8[0x0]
80002f4c:	30 08       	mov	r8,0
80002f4e:	f0 0a 18 00 	cp.b	r10,r8
80002f52:	c0 60       	breq	80002f5e <phy_tx_func+0x486>
								{
									payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002f54:	8f 29       	st.w	r7[0x8],r9
									payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002f56:	4a 18       	lddpc	r8,80002fd8 <phy_tx_func+0x500>
80002f58:	70 08       	ld.w	r8,r8[0x0]
80002f5a:	8f 38       	st.w	r7[0xc],r8
80002f5c:	c1 28       	rjmp	80002f80 <phy_tx_func+0x4a8>
								}
								else
								{
									payload_tx_channel->word[0] = (PCM_frame_Payload[0]);
80002f5e:	49 d8       	lddpc	r8,80002fd0 <phy_tx_func+0x4f8>
80002f60:	90 09       	ld.sh	r9,r8[0x0]
80002f62:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = (PCM_frame_Payload[1]);
80002f64:	90 19       	ld.sh	r9,r8[0x2]
80002f66:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (PCM_frame_Payload[2] ^ Public_PCMkey);
80002f68:	90 29       	ld.sh	r9,r8[0x4]
80002f6a:	ee 19 ff ff 	eorh	r9,0xffff
80002f6e:	ec 19 b2 f5 	eorl	r9,0xb2f5
80002f72:	ae 69       	st.h	r7[0xc],r9
									payload_tx_channel->word[3] = (PCM_frame_Payload[3] ^ Public_PCMkey);//加密方有bug,尝试用逻辑分析仪查看
80002f74:	90 38       	ld.sh	r8,r8[0x6]
80002f76:	ee 18 ff ff 	eorh	r8,0xffff
80002f7a:	ec 18 b2 f5 	eorl	r8,0xb2f5
80002f7e:	ae 78       	st.h	r7[0xe],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002f80:	2f fd       	sub	sp,-4
80002f82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f86:	00 00       	add	r0,r0
80002f88:	00 00       	add	r0,r0
80002f8a:	0a d0       	st.w	--r5,r0
80002f8c:	00 00       	add	r0,r0
80002f8e:	0a b4       	st.h	r5++,r4
80002f90:	00 00       	add	r0,r0
80002f92:	0a 90       	mov	r0,r5
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	4d 90       	lddpc	r0,800030f8 <payload_rx+0x1c>
80002f98:	00 00       	add	r0,r0
80002f9a:	0a cc       	st.b	r5++,r12
80002f9c:	00 00       	add	r0,r0
80002f9e:	0a 9c       	mov	r12,r5
80002fa0:	00 00       	add	r0,r0
80002fa2:	0a 5b       	eor	r11,r5
80002fa4:	00 00       	add	r0,r0
80002fa6:	0a 5c       	eor	r12,r5
80002fa8:	00 00       	add	r0,r0
80002faa:	0a c8       	st.b	r5++,r8
80002fac:	00 00       	add	r0,r0
80002fae:	0a c4       	st.b	r5++,r4
80002fb0:	00 00       	add	r0,r0
80002fb2:	0a 74       	tst	r4,r5
80002fb4:	00 00       	add	r0,r0
80002fb6:	0a 84       	andn	r4,r5
80002fb8:	00 00       	add	r0,r0
80002fba:	0d b8       	ld.ub	r8,r6[0x3]
80002fbc:	00 00       	add	r0,r0
80002fbe:	0e b4       	st.h	r7++,r4
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	c5 d4       	brge	8000307c <phy_init+0x6c>
80002fc4:	00 00       	add	r0,r0
80002fc6:	0a 59       	eor	r9,r5
80002fc8:	00 00       	add	r0,r0
80002fca:	0d b0       	ld.ub	r0,r6[0x3]
80002fcc:	00 00       	add	r0,r0
80002fce:	0d bc       	ld.ub	r12,r6[0x3]
80002fd0:	00 00       	add	r0,r0
80002fd2:	04 f4       	st.b	--r2,r4
80002fd4:	00 00       	add	r0,r0
80002fd6:	0a 6c       	and	r12,r5
80002fd8:	00 00       	add	r0,r0
80002fda:	0a 98       	mov	r8,r5
80002fdc:	00 00       	add	r0,r0
80002fde:	0d a4       	ld.ub	r4,r6[0x2]
80002fe0:	00 00       	add	r0,r0
80002fe2:	0a 5d       	eor	sp,r5
80002fe4:	00 00       	add	r0,r0
80002fe6:	0a 58       	eor	r8,r5

80002fe8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002fe8:	d4 01       	pushm	lr
80002fea:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002fec:	30 0a       	mov	r10,0
80002fee:	fa cb ff fc 	sub	r11,sp,-4
80002ff2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002ff4:	14 99       	mov	r9,r10
80002ff6:	1a 9b       	mov	r11,sp
80002ff8:	f0 1f 00 05 	mcall	8000300c <get_idle_store+0x24>
80002ffc:	58 1c       	cp.w	r12,1
80002ffe:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003002:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003006:	2f fd       	sub	sp,-4
80003008:	d8 02       	popm	pc
8000300a:	00 00       	add	r0,r0
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	4e 80       	lddpc	r0,800031ac <phy_rx_func+0x70>

80003010 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003010:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80003014:	f0 1f 00 24 	mcall	800030a4 <phy_init+0x94>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003018:	4a 4b       	lddpc	r11,800030a8 <phy_init+0x98>
8000301a:	4a 5c       	lddpc	r12,800030ac <phy_init+0x9c>
8000301c:	f0 1f 00 25 	mcall	800030b0 <phy_init+0xa0>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003020:	30 4b       	mov	r11,4
80003022:	31 ec       	mov	r12,30
80003024:	f0 1f 00 24 	mcall	800030b4 <phy_init+0xa4>
80003028:	4a 48       	lddpc	r8,800030b8 <phy_init+0xa8>
8000302a:	91 0c       	st.w	r8[0x0],r12
8000302c:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
8000302e:	10 96       	mov	r6,r8
80003030:	4a 35       	lddpc	r5,800030bc <phy_init+0xac>
80003032:	6c 0c       	ld.w	r12,r6[0x0]
80003034:	ea 07 00 0b 	add	r11,r5,r7
80003038:	f0 1f 00 22 	mcall	800030c0 <phy_init+0xb0>
8000303c:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003040:	e0 47 1e 00 	cp.w	r7,7680
80003044:	cf 71       	brne	80003032 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003046:	30 4b       	mov	r11,4
80003048:	31 4c       	mov	r12,20
8000304a:	f0 1f 00 1b 	mcall	800030b4 <phy_init+0xa4>
8000304e:	49 e8       	lddpc	r8,800030c4 <phy_init+0xb4>
80003050:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003052:	30 4b       	mov	r11,4
80003054:	30 ac       	mov	r12,10
80003056:	f0 1f 00 18 	mcall	800030b4 <phy_init+0xa4>
8000305a:	49 c8       	lddpc	r8,800030c8 <phy_init+0xb8>
8000305c:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000305e:	30 4b       	mov	r11,4
80003060:	30 ac       	mov	r12,10
80003062:	f0 1f 00 15 	mcall	800030b4 <phy_init+0xa4>
80003066:	49 a8       	lddpc	r8,800030cc <phy_init+0xbc>
80003068:	91 0c       	st.w	r8[0x0],r12
8000306a:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000306c:	10 96       	mov	r6,r8
8000306e:	49 95       	lddpc	r5,800030d0 <phy_init+0xc0>
80003070:	6c 0c       	ld.w	r12,r6[0x0]
80003072:	ea 07 00 0b 	add	r11,r5,r7
80003076:	f0 1f 00 13 	mcall	800030c0 <phy_init+0xb0>
8000307a:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000307e:	e0 47 14 00 	cp.w	r7,5120
80003082:	cf 71       	brne	80003070 <phy_init+0x60>
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003084:	30 4b       	mov	r11,4
80003086:	30 5c       	mov	r12,5
80003088:	f0 1f 00 0b 	mcall	800030b4 <phy_init+0xa4>
	}
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
8000308c:	49 28       	lddpc	r8,800030d4 <phy_init+0xc4>
8000308e:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
80003090:	e0 6b 01 00 	mov	r11,256
80003094:	30 5c       	mov	r12,5
80003096:	f0 1f 00 08 	mcall	800030b4 <phy_init+0xa4>
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
8000309a:	49 08       	lddpc	r8,800030d8 <phy_init+0xc8>
8000309c:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
	#endif /*end if*/
	
}
8000309e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030a2:	00 00       	add	r0,r0
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	38 ac       	mov	r12,-118
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	2a d8       	sub	r8,-83
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	31 3c       	mov	r12,19
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	38 98       	mov	r8,-119
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	51 e4       	stdsp	sp[0x78],r4
800030b8:	00 00       	add	r0,r0
800030ba:	0a a4       	st.w	r5++,r4
800030bc:	00 00       	add	r0,r0
800030be:	22 b8       	sub	r8,43
800030c0:	80 00       	ld.sh	r0,r0[0x0]
800030c2:	2a 34       	sub	r4,-93
800030c4:	00 00       	add	r0,r0
800030c6:	0a d0       	st.w	--r5,r0
800030c8:	00 00       	add	r0,r0
800030ca:	0a c0       	st.b	r5++,r0
800030cc:	00 00       	add	r0,r0
800030ce:	0a 7c       	tst	r12,r5
800030d0:	00 00       	add	r0,r0
800030d2:	0e b8       	st.h	r7++,r8
800030d4:	00 00       	add	r0,r0
800030d6:	0a 80       	andn	r0,r5
800030d8:	00 00       	add	r0,r0
800030da:	0a b8       	st.h	r5++,r8

800030dc <payload_rx>:




static void payload_rx(void * payload)
{
800030dc:	d4 01       	pushm	lr
800030de:	20 2d       	sub	sp,8
800030e0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800030e2:	30 08       	mov	r8,0
800030e4:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800030e6:	48 f8       	lddpc	r8,80003120 <payload_rx+0x44>
800030e8:	70 08       	ld.w	r8,r8[0x0]
800030ea:	58 08       	cp.w	r8,0
800030ec:	c0 71       	brne	800030fa <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800030ee:	30 4b       	mov	r11,4
800030f0:	30 5c       	mov	r12,5
800030f2:	f0 1f 00 0d 	mcall	80003124 <payload_rx+0x48>
800030f6:	48 b8       	lddpc	r8,80003120 <payload_rx+0x44>
800030f8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800030fa:	48 a8       	lddpc	r8,80003120 <payload_rx+0x44>
800030fc:	70 0c       	ld.w	r12,r8[0x0]
800030fe:	30 09       	mov	r9,0
80003100:	fa ca ff fc 	sub	r10,sp,-4
80003104:	1a 9b       	mov	r11,sp
80003106:	f0 1f 00 09 	mcall	80003128 <payload_rx+0x4c>
8000310a:	c0 91       	brne	8000311c <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
8000310c:	48 88       	lddpc	r8,8000312c <payload_rx+0x50>
8000310e:	70 0c       	ld.w	r12,r8[0x0]
80003110:	40 0b       	lddsp	r11,sp[0x0]
80003112:	f0 1f 00 08 	mcall	80003130 <payload_rx+0x54>
		logFromISR("mm");//触发未知BUG时，此处会被触发。
80003116:	48 8c       	lddpc	r12,80003134 <payload_rx+0x58>
80003118:	f0 1f 00 08 	mcall	80003138 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000311c:	2f ed       	sub	sp,-8
8000311e:	d8 02       	popm	pc
80003120:	00 00       	add	r0,r0
80003122:	0a 80       	andn	r0,r5
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	51 e4       	stdsp	sp[0x78],r4
80003128:	80 00       	ld.sh	r0,r0[0x0]
8000312a:	50 3c       	stdsp	sp[0xc],r12
8000312c:	00 00       	add	r0,r0
8000312e:	0a 7c       	tst	r12,r5
80003130:	80 00       	ld.sh	r0,r0[0x0]
80003132:	29 e0       	sub	r0,-98
80003134:	80 00       	ld.sh	r0,r0[0x0]
80003136:	cb 90       	breq	800030a8 <phy_init+0x98>
80003138:	80 00       	ld.sh	r0,r0[0x0]
8000313a:	5e 08       	reteq	r8

8000313c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000313c:	eb cd 40 e0 	pushm	r5-r7,lr
80003140:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003142:	fe f8 05 b6 	ld.w	r8,pc[1462]
80003146:	70 08       	ld.w	r8,r8[0x0]
80003148:	58 08       	cp.w	r8,0
8000314a:	e0 80 01 05 	breq	80003354 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000314e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003150:	fe f8 05 ac 	ld.w	r8,pc[1452]
80003154:	70 09       	ld.w	r9,r8[0x0]
80003156:	2f f9       	sub	r9,-1
80003158:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000315a:	fe f8 05 a6 	ld.w	r8,pc[1446]
8000315e:	70 08       	ld.w	r8,r8[0x0]
80003160:	58 18       	cp.w	r8,1
80003162:	e0 80 00 84 	breq	8000326a <phy_rx_func+0x12e>
80003166:	c0 73       	brcs	80003174 <phy_rx_func+0x38>
80003168:	58 28       	cp.w	r8,2
8000316a:	c5 b0       	breq	80003220 <phy_rx_func+0xe4>
8000316c:	58 38       	cp.w	r8,3
8000316e:	e0 81 00 f3 	brne	80003354 <phy_rx_func+0x218>
80003172:	cd 38       	rjmp	80003318 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003174:	e0 6a 5a 5a 	mov	r10,23130
80003178:	ea 1a ab cd 	orh	r10,0xabcd
8000317c:	14 36       	cp.w	r6,r10
8000317e:	e0 80 00 eb 	breq	80003354 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003182:	ec 08 16 10 	lsr	r8,r6,0x10
80003186:	e0 48 ab cd 	cp.w	r8,43981
8000318a:	e0 81 00 e5 	brne	80003354 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000318e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003192:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003196:	20 28       	sub	r8,2
80003198:	fe f9 05 6c 	ld.w	r9,pc[1388]
8000319c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000319e:	30 09       	mov	r9,0
800031a0:	f2 08 19 00 	cp.h	r8,r9
800031a4:	e0 8a 00 d8 	brle	80003354 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800031a8:	fe f8 05 60 	ld.w	r8,pc[1376]
800031ac:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800031ae:	fe f8 05 5e 	ld.w	r8,pc[1374]
800031b2:	70 0c       	ld.w	r12,r8[0x0]
800031b4:	f0 1f 01 57 	mcall	80003710 <phy_rx_func+0x5d4>
800031b8:	fe f8 05 5c 	ld.w	r8,pc[1372]
800031bc:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800031be:	58 0c       	cp.w	r12,0
800031c0:	e0 80 00 ca 	breq	80003354 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800031c4:	fe f8 05 44 	ld.w	r8,pc[1348]
800031c8:	90 09       	ld.sh	r9,r8[0x0]
800031ca:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800031ce:	2f f9       	sub	r9,-1
800031d0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031d2:	fe fa 05 42 	ld.w	r10,pc[1346]
800031d6:	74 0a       	ld.w	r10,r10[0x0]
800031d8:	fe fb 05 24 	ld.w	r11,pc[1316]
800031dc:	76 0b       	ld.w	r11,r11[0x0]
800031de:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800031e2:	2f f9       	sub	r9,-1
800031e4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800031e6:	e2 16 0f 00 	andl	r6,0xf00,COH
800031ea:	e0 46 01 00 	cp.w	r6,256
800031ee:	c0 c0       	breq	80003206 <phy_rx_func+0xca>
800031f0:	e0 8b 00 05 	brhi	800031fa <phy_rx_func+0xbe>
800031f4:	58 06       	cp.w	r6,0
800031f6:	c0 80       	breq	80003206 <phy_rx_func+0xca>
800031f8:	c0 c8       	rjmp	80003210 <phy_rx_func+0xd4>
800031fa:	e0 46 02 00 	cp.w	r6,512
800031fe:	c0 40       	breq	80003206 <phy_rx_func+0xca>
80003200:	e0 46 03 00 	cp.w	r6,768
80003204:	c0 61       	brne	80003210 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003206:	30 29       	mov	r9,2
80003208:	fe f8 04 f8 	ld.w	r8,pc[1272]
8000320c:	91 09       	st.w	r8[0x0],r9
8000320e:	ca 38       	rjmp	80003354 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003210:	fe f6 05 04 	ld.w	r6,pc[1284]
80003214:	6c 0c       	ld.w	r12,r6[0x0]
80003216:	f0 1f 01 41 	mcall	80003718 <phy_rx_func+0x5dc>
					phy_frame_ptr = NULL;					
8000321a:	30 08       	mov	r8,0
8000321c:	8d 08       	st.w	r6[0x0],r8
8000321e:	c9 b8       	rjmp	80003354 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003220:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003224:	b1 86       	lsr	r6,0x10
80003226:	14 06       	add	r6,r10
80003228:	fe f8 04 f4 	ld.w	r8,pc[1268]
8000322c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000322e:	fe f8 04 da 	ld.w	r8,pc[1242]
80003232:	90 09       	ld.sh	r9,r8[0x0]
80003234:	fe fb 04 e0 	ld.w	r11,pc[1248]
80003238:	76 0b       	ld.w	r11,r11[0x0]
8000323a:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000323e:	2f f9       	sub	r9,-1
80003240:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003242:	fe f9 04 c2 	ld.w	r9,pc[1218]
80003246:	92 08       	ld.sh	r8,r9[0x0]
80003248:	20 28       	sub	r8,2
8000324a:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000324c:	30 09       	mov	r9,0
8000324e:	f2 08 19 00 	cp.h	r8,r9
80003252:	e0 8a 00 07 	brle	80003260 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003256:	30 19       	mov	r9,1
80003258:	fe f8 04 a8 	ld.w	r8,pc[1192]
8000325c:	91 09       	st.w	r8[0x0],r9
8000325e:	c7 b8       	rjmp	80003354 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003260:	30 39       	mov	r9,3
80003262:	fe f8 04 9e 	ld.w	r8,pc[1182]
80003266:	91 09       	st.w	r8[0x0],r9
80003268:	c7 68       	rjmp	80003354 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000326a:	ec 0a 14 10 	asr	r10,r6,0x10
8000326e:	fe f8 04 ae 	ld.w	r8,pc[1198]
80003272:	90 09       	ld.sh	r9,r8[0x0]
80003274:	14 09       	add	r9,r10
80003276:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003278:	fe f9 04 90 	ld.w	r9,pc[1168]
8000327c:	92 08       	ld.sh	r8,r9[0x0]
8000327e:	fe fb 04 96 	ld.w	r11,pc[1174]
80003282:	76 0b       	ld.w	r11,r11[0x0]
80003284:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003288:	2f f8       	sub	r8,-1
8000328a:	5c 88       	casts.h	r8
8000328c:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000328e:	fe fa 04 76 	ld.w	r10,pc[1142]
80003292:	94 09       	ld.sh	r9,r10[0x0]
80003294:	20 29       	sub	r9,2
80003296:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003298:	30 0a       	mov	r10,0
8000329a:	f4 09 19 00 	cp.h	r9,r10
8000329e:	e0 89 00 1f 	brgt	800032dc <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800032a2:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800032a6:	e0 46 00 ba 	cp.w	r6,186
800032aa:	c0 d1       	brne	800032c4 <phy_rx_func+0x188>
800032ac:	fe f8 04 70 	ld.w	r8,pc[1136]
800032b0:	90 09       	ld.sh	r9,r8[0x0]
800032b2:	f4 09 19 00 	cp.h	r9,r10
800032b6:	c0 71       	brne	800032c4 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800032b8:	fe f8 04 5c 	ld.w	r8,pc[1116]
800032bc:	70 0c       	ld.w	r12,r8[0x0]
800032be:	f0 1f 01 19 	mcall	80003720 <phy_rx_func+0x5e4>
800032c2:	c0 88       	rjmp	800032d2 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800032c4:	fe f6 04 50 	ld.w	r6,pc[1104]
800032c8:	6c 0c       	ld.w	r12,r6[0x0]
800032ca:	f0 1f 01 14 	mcall	80003718 <phy_rx_func+0x5dc>
					phy_frame_ptr = NULL;
800032ce:	30 08       	mov	r8,0
800032d0:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800032d2:	30 09       	mov	r9,0
800032d4:	fe f8 04 2c 	ld.w	r8,pc[1068]
800032d8:	91 09       	st.w	r8[0x0],r9
800032da:	c3 d8       	rjmp	80003354 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800032dc:	5c 86       	casts.h	r6
800032de:	fe f9 04 3e 	ld.w	r9,pc[1086]
800032e2:	92 0a       	ld.sh	r10,r9[0x0]
800032e4:	0c 0a       	add	r10,r6
800032e6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800032e8:	fe f9 04 2c 	ld.w	r9,pc[1068]
800032ec:	72 09       	ld.w	r9,r9[0x0]
800032ee:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800032f2:	2f f8       	sub	r8,-1
800032f4:	fe f9 04 14 	ld.w	r9,pc[1044]
800032f8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800032fa:	fe f9 04 0a 	ld.w	r9,pc[1034]
800032fe:	92 08       	ld.sh	r8,r9[0x0]
80003300:	20 28       	sub	r8,2
80003302:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003304:	30 09       	mov	r9,0
80003306:	f2 08 19 00 	cp.h	r8,r9
8000330a:	e0 89 00 25 	brgt	80003354 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000330e:	30 39       	mov	r9,3
80003310:	fe f8 03 f0 	ld.w	r8,pc[1008]
80003314:	91 09       	st.w	r8[0x0],r9
80003316:	c1 f8       	rjmp	80003354 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003318:	e6 16 00 ff 	andh	r6,0xff,COH
8000331c:	fc 19 00 ba 	movh	r9,0xba
80003320:	12 36       	cp.w	r6,r9
80003322:	c0 e1       	brne	8000333e <phy_rx_func+0x202>
80003324:	fe f8 03 f8 	ld.w	r8,pc[1016]
80003328:	90 09       	ld.sh	r9,r8[0x0]
8000332a:	30 08       	mov	r8,0
8000332c:	f0 09 19 00 	cp.h	r9,r8
80003330:	c0 71       	brne	8000333e <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003332:	fe f8 03 e2 	ld.w	r8,pc[994]
80003336:	70 0c       	ld.w	r12,r8[0x0]
80003338:	f0 1f 00 fa 	mcall	80003720 <phy_rx_func+0x5e4>
8000333c:	c0 88       	rjmp	8000334c <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000333e:	fe f6 03 d6 	ld.w	r6,pc[982]
80003342:	6c 0c       	ld.w	r12,r6[0x0]
80003344:	f0 1f 00 f5 	mcall	80003718 <phy_rx_func+0x5dc>
				phy_frame_ptr = NULL;
80003348:	30 08       	mov	r8,0
8000334a:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000334c:	30 09       	mov	r9,0
8000334e:	fe f8 03 b2 	ld.w	r8,pc[946]
80003352:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003354:	fe f8 03 d0 	ld.w	r8,pc[976]
80003358:	11 89       	ld.ub	r9,r8[0x0]
8000335a:	30 08       	mov	r8,0
8000335c:	f0 09 18 00 	cp.b	r9,r8
80003360:	c1 31       	brne	80003386 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
80003362:	fe f6 03 c6 	ld.w	r6,pc[966]
80003366:	6c 0c       	ld.w	r12,r6[0x0]
80003368:	f0 1f 00 ea 	mcall	80003710 <phy_rx_func+0x5d4>
8000336c:	fe f8 03 c0 	ld.w	r8,pc[960]
80003370:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003372:	6c 0c       	ld.w	r12,r6[0x0]
80003374:	f0 1f 00 e7 	mcall	80003710 <phy_rx_func+0x5d4>
80003378:	fe f8 03 b8 	ld.w	r8,pc[952]
8000337c:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000337e:	30 19       	mov	r9,1
80003380:	fe f8 03 a4 	ld.w	r8,pc[932]
80003384:	b0 89       	st.b	r8[0x0],r9
	}	
	
	
	PCM_frame_Payload[0] = payload_rx_channel->word[0];
80003386:	8e 49       	ld.sh	r9,r7[0x8]
80003388:	fe f8 03 ac 	ld.w	r8,pc[940]
8000338c:	b0 09       	st.h	r8[0x0],r9
	PCM_frame_Payload[1] = payload_rx_channel->word[1];
8000338e:	8e 59       	ld.sh	r9,r7[0xa]
80003390:	b0 19       	st.h	r8[0x2],r9
	PCM_frame_Payload[2] = payload_rx_channel->word[2];
80003392:	8e 69       	ld.sh	r9,r7[0xc]
80003394:	b0 29       	st.h	r8[0x4],r9
	PCM_frame_Payload[3] = payload_rx_channel->word[3];
80003396:	8e 79       	ld.sh	r9,r7[0xe]
80003398:	b0 39       	st.h	r8[0x6],r9
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000339a:	fe f8 03 9e 	ld.w	r8,pc[926]
8000339e:	70 08       	ld.w	r8,r8[0x0]
800033a0:	58 08       	cp.w	r8,0
800033a2:	c0 50       	breq	800033ac <phy_rx_func+0x270>
800033a4:	58 28       	cp.w	r8,2
800033a6:	e0 81 01 a6 	brne	800036f2 <phy_rx_func+0x5b6>
800033aa:	c0 29       	rjmp	800035ae <phy_rx_func+0x472>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800033ac:	6e 28       	ld.w	r8,r7[0x8]
800033ae:	e0 6a 5a 5a 	mov	r10,23130
800033b2:	ea 1a ab cd 	orh	r10,0xabcd
800033b6:	14 38       	cp.w	r8,r10
800033b8:	c0 71       	brne	800033c6 <phy_rx_func+0x28a>
			{
				
				m_RxBurstType = VOICE_WATING;
800033ba:	30 09       	mov	r9,0
800033bc:	fe f8 03 80 	ld.w	r8,pc[896]
800033c0:	91 09       	st.w	r8[0x0],r9
800033c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800033c6:	10 99       	mov	r9,r8
800033c8:	e0 19 00 00 	andl	r9,0x0
800033cc:	fc 1a ab cd 	movh	r10,0xabcd
800033d0:	14 39       	cp.w	r9,r10
800033d2:	e0 81 01 90 	brne	800036f2 <phy_rx_func+0x5b6>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800033d6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800033da:	fe f9 03 66 	ld.w	r9,pc[870]
800033de:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800033e0:	fe f8 03 4c 	ld.w	r8,pc[844]
800033e4:	70 08       	ld.w	r8,r8[0x0]
800033e6:	58 08       	cp.w	r8,0
800033e8:	c0 60       	breq	800033f4 <phy_rx_func+0x2b8>
800033ea:	fe f8 03 46 	ld.w	r8,pc[838]
800033ee:	70 08       	ld.w	r8,r8[0x0]
800033f0:	58 08       	cp.w	r8,0
800033f2:	c1 a1       	brne	80003426 <phy_rx_func+0x2ea>
			{
				payload_ptr = get_payload_idle_isr();
800033f4:	fe f6 03 34 	ld.w	r6,pc[820]
800033f8:	6c 0c       	ld.w	r12,r6[0x0]
800033fa:	f0 1f 00 c6 	mcall	80003710 <phy_rx_func+0x5d4>
800033fe:	fe f5 03 2e 	ld.w	r5,pc[814]
80003402:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
80003404:	6c 0c       	ld.w	r12,r6[0x0]
80003406:	f0 1f 00 c3 	mcall	80003710 <phy_rx_func+0x5d4>
8000340a:	fe f8 03 26 	ld.w	r8,pc[806]
8000340e:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
80003410:	6a 08       	ld.w	r8,r5[0x0]
80003412:	58 08       	cp.w	r8,0
80003414:	c0 30       	breq	8000341a <phy_rx_func+0x2de>
80003416:	58 0c       	cp.w	r12,0
80003418:	c0 71       	brne	80003426 <phy_rx_func+0x2ea>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000341a:	fe fc 03 2a 	ld.w	r12,pc[810]
8000341e:	f0 1f 00 cb 	mcall	80003748 <phy_rx_func+0x60c>
80003422:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
#endif			
			{	
				
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003426:	6e 28       	ld.w	r8,r7[0x8]
80003428:	e2 18 f0 00 	andl	r8,0xf000,COH
8000342c:	e0 48 10 00 	cp.w	r8,4096
80003430:	5f 19       	srne	r9
80003432:	e0 48 20 00 	cp.w	r8,8192
80003436:	5f 18       	srne	r8
80003438:	f3 e8 00 08 	and	r8,r9,r8
8000343c:	e0 81 01 5b 	brne	800036f2 <phy_rx_func+0x5b6>
					//{
						//break;//65794的机器通道有问题
					//}
				//logFromISR("\n\r Axiba \n\r");
				
				AMBE_tx_flag = 0;
80003440:	fe f9 03 0c 	ld.w	r9,pc[780]
80003444:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
80003446:	fe f9 03 0a 	ld.w	r9,pc[778]
8000344a:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
8000344c:	fe f9 03 08 	ld.w	r9,pc[776]
80003450:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003452:	6e 28       	ld.w	r8,r7[0x8]
80003454:	e2 18 0f 00 	andl	r8,0xf00,COH
80003458:	58 18       	cp.w	r8,1
8000345a:	e0 8b 00 7e 	brhi	80003556 <phy_rx_func+0x41a>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000345e:	fe f9 02 e2 	ld.w	r9,pc[738]
80003462:	72 08       	ld.w	r8,r9[0x0]
80003464:	20 48       	sub	r8,4
80003466:	93 08       	st.w	r9[0x0],r8
80003468:	e0 80 01 45 	breq	800036f2 <phy_rx_func+0x5b6>
				ArrayDiscLength = payload_rx_channel->word[2];
8000346c:	8e 68       	ld.sh	r8,r7[0xc]
8000346e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003472:	fe f9 02 e6 	ld.w	r9,pc[742]
80003476:	93 0a       	st.w	r9[0x0],r10
				if (ArrayDiscLength ==0 )
				{ 
					//logFromISR("\n\r Axiba \n\r");
				}
				
				switch (ArrayDiscLength){
80003478:	30 09       	mov	r9,0
8000347a:	f2 08 19 00 	cp.h	r8,r9
8000347e:	c0 70       	breq	8000348c <phy_rx_func+0x350>
80003480:	30 19       	mov	r9,1
80003482:	f2 08 19 00 	cp.h	r8,r9
80003486:	e0 81 01 36 	brne	800036f2 <phy_rx_func+0x5b6>
8000348a:	c3 08       	rjmp	800034ea <phy_rx_func+0x3ae>
					
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
							
							Terminator_Flag = 0;
8000348c:	30 08       	mov	r8,0
8000348e:	fe f9 02 ce 	ld.w	r9,pc[718]
80003492:	b2 88       	st.b	r9[0x0],r8
							Silent_flag = 0;
80003494:	fe f9 02 cc 	ld.w	r9,pc[716]
80003498:	b2 88       	st.b	r9[0x0],r8
							Tone_flag = 0;
8000349a:	fe f9 02 ca 	ld.w	r9,pc[714]
8000349e:	b2 88       	st.b	r9[0x0],r8
							
							//logFromISR("\n\r Axiba \n\r");
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034a0:	fe f8 02 c8 	ld.w	r8,pc[712]
800034a4:	70 0a       	ld.w	r10,r8[0x0]
800034a6:	fe f9 02 86 	ld.w	r9,pc[646]
800034aa:	72 09       	ld.w	r9,r9[0x0]
800034ac:	8e 7b       	ld.sh	r11,r7[0xe]
800034ae:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800034b2:	70 09       	ld.w	r9,r8[0x0]
800034b4:	2f f9       	sub	r9,-1
800034b6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034b8:	e0 49 00 ff 	cp.w	r9,255
800034bc:	e0 88 00 11 	brls	800034de <phy_rx_func+0x3a2>
							{
								RxMedia_IsFillingNext16 = 0;
800034c0:	30 09       	mov	r9,0
800034c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800034c4:	fe f7 02 68 	ld.w	r7,pc[616]
800034c8:	6e 0c       	ld.w	r12,r7[0x0]
800034ca:	f0 1f 00 a9 	mcall	8000376c <phy_rx_func+0x630>
								payload_ptr = get_payload_idle_isr();
800034ce:	fe f8 02 5a 	ld.w	r8,pc[602]
800034d2:	70 0c       	ld.w	r12,r8[0x0]
800034d4:	f0 1f 00 8f 	mcall	80003710 <phy_rx_func+0x5d4>
800034d8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr)
800034da:	e0 80 01 0c 	breq	800036f2 <phy_rx_func+0x5b6>
								{
									break;
								}
							}
							
						RxMediaState = READINGMEDIA;
800034de:	30 29       	mov	r9,2
800034e0:	fe f8 02 58 	ld.w	r8,pc[600]
800034e4:	91 09       	st.w	r8[0x0],r9
800034e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
						break;
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
800034ea:	8e 78       	ld.sh	r8,r7[0xe]
800034ec:	30 39       	mov	r9,3
800034ee:	f2 08 19 00 	cp.h	r8,r9
800034f2:	c0 61       	brne	800034fe <phy_rx_func+0x3c2>
							{
								Terminator_Flag = 1;
800034f4:	30 19       	mov	r9,1
800034f6:	fe f8 02 66 	ld.w	r8,pc[614]
800034fa:	b0 89       	st.b	r8[0x0],r9
800034fc:	c2 88       	rjmp	8000354c <phy_rx_func+0x410>

							}
							else if(payload_rx_channel->word[3] == 0x0004)//Silent Descriptor
800034fe:	30 49       	mov	r9,4
80003500:	f2 08 19 00 	cp.h	r8,r9
80003504:	c0 61       	brne	80003510 <phy_rx_func+0x3d4>
							{
							
								Silent_flag = 1;
80003506:	30 19       	mov	r9,1
80003508:	fe f8 02 58 	ld.w	r8,pc[600]
8000350c:	b0 89       	st.b	r8[0x0],r9
8000350e:	c1 f8       	rjmp	8000354c <phy_rx_func+0x410>
							}
							else if (payload_rx_channel->word[3] == 0x1026)//Tone Descriptor
80003510:	e0 69 10 26 	mov	r9,4134
80003514:	f2 08 19 00 	cp.h	r8,r9
80003518:	c1 01       	brne	80003538 <phy_rx_func+0x3fc>
							{
								
								Tone_flag = 1;
8000351a:	30 19       	mov	r9,1
8000351c:	fe f8 02 48 	ld.w	r8,pc[584]
80003520:	b0 89       	st.b	r8[0x0],r9
								Tone_Counters++;
80003522:	fe f8 02 4e 	ld.w	r8,pc[590]
80003526:	70 09       	ld.w	r9,r8[0x0]
80003528:	2f f9       	sub	r9,-1
8000352a:	91 09       	st.w	r8[0x0],r9
								RxMediaState = WAITINGABAB;
8000352c:	30 09       	mov	r9,0
8000352e:	fe f8 02 0a 	ld.w	r8,pc[522]
80003532:	91 09       	st.w	r8[0x0],r9
80003534:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;	//Tone_flag = 1;//屏蔽掉此类型数据
							
							}
							else
							{
								Terminator_Flag = 0;
80003538:	30 08       	mov	r8,0
8000353a:	fe f9 02 22 	ld.w	r9,pc[546]
8000353e:	b2 88       	st.b	r9[0x0],r8
								Silent_flag = 0;
80003540:	fe f9 02 20 	ld.w	r9,pc[544]
80003544:	b2 88       	st.b	r9[0x0],r8
								Tone_flag = 0;
80003546:	fe f9 02 1e 	ld.w	r9,pc[542]
8000354a:	b2 88       	st.b	r9[0x0],r8
								
							}
					
					
							RxMediaState = READINGMEDIA;
8000354c:	30 29       	mov	r9,2
8000354e:	4f b8       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
80003550:	91 09       	st.w	r8[0x0],r9
80003552:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003556:	4f b8       	lddpc	r8,80003740 <phy_rx_func+0x604>
80003558:	70 08       	ld.w	r8,r8[0x0]
8000355a:	58 18       	cp.w	r8,1
8000355c:	e0 88 00 cb 	brls	800036f2 <phy_rx_func+0x5b6>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003560:	fe f8 02 08 	ld.w	r8,pc[520]
80003564:	70 0a       	ld.w	r10,r8[0x0]
80003566:	4f 29       	lddpc	r9,8000372c <phy_rx_func+0x5f0>
80003568:	72 09       	ld.w	r9,r9[0x0]
8000356a:	6e 3b       	ld.w	r11,r7[0xc]
8000356c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003570:	70 09       	ld.w	r9,r8[0x0]
80003572:	2f f9       	sub	r9,-1
80003574:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003576:	e0 49 00 ff 	cp.w	r9,255
8000357a:	e0 88 00 0f 	brls	80003598 <phy_rx_func+0x45c>
				{
					RxMedia_IsFillingNext16 = 0;
8000357e:	30 09       	mov	r9,0
80003580:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003582:	4e b7       	lddpc	r7,8000372c <phy_rx_func+0x5f0>
80003584:	6e 0c       	ld.w	r12,r7[0x0]
80003586:	f0 1f 00 7a 	mcall	8000376c <phy_rx_func+0x630>
								payload_ptr = get_payload_idle_isr();
8000358a:	4e 88       	lddpc	r8,80003728 <phy_rx_func+0x5ec>
8000358c:	70 0c       	ld.w	r12,r8[0x0]
8000358e:	f0 1f 00 61 	mcall	80003710 <phy_rx_func+0x5d4>
80003592:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
80003594:	e0 80 00 af 	breq	800036f2 <phy_rx_func+0x5b6>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003598:	4e a9       	lddpc	r9,80003740 <phy_rx_func+0x604>
8000359a:	72 08       	ld.w	r8,r9[0x0]
8000359c:	20 28       	sub	r8,2
8000359e:	93 08       	st.w	r9[0x0],r8
800035a0:	e0 80 00 a9 	breq	800036f2 <phy_rx_func+0x5b6>
				RxMediaState = READINGMEDIA;
800035a4:	30 29       	mov	r9,2
800035a6:	4e 58       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
800035a8:	91 09       	st.w	r8[0x0],r9
800035aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
						
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800035ae:	4e f8       	lddpc	r8,80003768 <phy_rx_func+0x62c>
800035b0:	70 0a       	ld.w	r10,r8[0x0]
800035b2:	4d f9       	lddpc	r9,8000372c <phy_rx_func+0x5f0>
800035b4:	72 09       	ld.w	r9,r9[0x0]
800035b6:	8e 4b       	ld.sh	r11,r7[0x8]
800035b8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800035bc:	70 09       	ld.w	r9,r8[0x0]
800035be:	2f f9       	sub	r9,-1
800035c0:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035c2:	e0 49 00 ff 	cp.w	r9,255
800035c6:	e0 88 00 13 	brls	800035ec <phy_rx_func+0x4b0>
					{
							RxMedia_IsFillingNext16 = 0;
800035ca:	30 09       	mov	r9,0
800035cc:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800035ce:	4d 86       	lddpc	r6,8000372c <phy_rx_func+0x5f0>
800035d0:	6c 0c       	ld.w	r12,r6[0x0]
800035d2:	f0 1f 00 67 	mcall	8000376c <phy_rx_func+0x630>
							payload_ptr = get_payload_idle_isr();
800035d6:	4d 58       	lddpc	r8,80003728 <phy_rx_func+0x5ec>
800035d8:	70 0c       	ld.w	r12,r8[0x0]
800035da:	f0 1f 00 4e 	mcall	80003710 <phy_rx_func+0x5d4>
800035de:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
800035e0:	c0 61       	brne	800035ec <phy_rx_func+0x4b0>
							{
								RxMediaState = WAITINGABAB;
800035e2:	30 09       	mov	r9,0
800035e4:	4d 58       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
800035e6:	91 09       	st.w	r8[0x0],r9
800035e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
800035ec:	4d 59       	lddpc	r9,80003740 <phy_rx_func+0x604>
800035ee:	72 08       	ld.w	r8,r9[0x0]
800035f0:	20 28       	sub	r8,2
800035f2:	93 08       	st.w	r9[0x0],r8
800035f4:	c0 61       	brne	80003600 <phy_rx_func+0x4c4>
				{
					RxMediaState = WAITINGABAB;
800035f6:	30 09       	mov	r9,0
800035f8:	4d 08       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
800035fa:	91 09       	st.w	r8[0x0],r9
800035fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003600:	4d a8       	lddpc	r8,80003768 <phy_rx_func+0x62c>
80003602:	70 0a       	ld.w	r10,r8[0x0]
80003604:	4c a9       	lddpc	r9,8000372c <phy_rx_func+0x5f0>
80003606:	72 09       	ld.w	r9,r9[0x0]
80003608:	8e 5b       	ld.sh	r11,r7[0xa]
8000360a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000360e:	70 09       	ld.w	r9,r8[0x0]
80003610:	2f f9       	sub	r9,-1
80003612:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003614:	e0 49 00 ff 	cp.w	r9,255
80003618:	e0 88 00 13 	brls	8000363e <phy_rx_func+0x502>
						{
							RxMedia_IsFillingNext16 = 0;
8000361c:	30 09       	mov	r9,0
8000361e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003620:	4c 36       	lddpc	r6,8000372c <phy_rx_func+0x5f0>
80003622:	6c 0c       	ld.w	r12,r6[0x0]
80003624:	f0 1f 00 52 	mcall	8000376c <phy_rx_func+0x630>
								payload_ptr = get_payload_idle_isr();
80003628:	4c 08       	lddpc	r8,80003728 <phy_rx_func+0x5ec>
8000362a:	70 0c       	ld.w	r12,r8[0x0]
8000362c:	f0 1f 00 39 	mcall	80003710 <phy_rx_func+0x5d4>
80003630:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003632:	c0 61       	brne	8000363e <phy_rx_func+0x502>
								{
									RxMediaState = WAITINGABAB;
80003634:	30 09       	mov	r9,0
80003636:	4c 18       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
80003638:	91 09       	st.w	r8[0x0],r9
8000363a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000363e:	4c 19       	lddpc	r9,80003740 <phy_rx_func+0x604>
80003640:	72 08       	ld.w	r8,r9[0x0]
80003642:	20 28       	sub	r8,2
80003644:	93 08       	st.w	r9[0x0],r8
80003646:	c0 61       	brne	80003652 <phy_rx_func+0x516>
					RxMediaState = WAITINGABAB;
80003648:	30 09       	mov	r9,0
8000364a:	4b c8       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
8000364c:	91 09       	st.w	r8[0x0],r9
8000364e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003652:	4c 68       	lddpc	r8,80003768 <phy_rx_func+0x62c>
80003654:	70 0a       	ld.w	r10,r8[0x0]
80003656:	4b 69       	lddpc	r9,8000372c <phy_rx_func+0x5f0>
80003658:	72 09       	ld.w	r9,r9[0x0]
8000365a:	8e 6b       	ld.sh	r11,r7[0xc]
8000365c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003660:	70 09       	ld.w	r9,r8[0x0]
80003662:	2f f9       	sub	r9,-1
80003664:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003666:	e0 49 00 ff 	cp.w	r9,255
8000366a:	e0 88 00 13 	brls	80003690 <phy_rx_func+0x554>
						{
							RxMedia_IsFillingNext16 = 0;
8000366e:	30 09       	mov	r9,0
80003670:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003672:	4a f6       	lddpc	r6,8000372c <phy_rx_func+0x5f0>
80003674:	6c 0c       	ld.w	r12,r6[0x0]
80003676:	f0 1f 00 3e 	mcall	8000376c <phy_rx_func+0x630>
									payload_ptr = get_payload_idle_isr();
8000367a:	4a c8       	lddpc	r8,80003728 <phy_rx_func+0x5ec>
8000367c:	70 0c       	ld.w	r12,r8[0x0]
8000367e:	f0 1f 00 25 	mcall	80003710 <phy_rx_func+0x5d4>
80003682:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80003684:	c0 61       	brne	80003690 <phy_rx_func+0x554>
									{
										RxMediaState = WAITINGABAB;
80003686:	30 09       	mov	r9,0
80003688:	4a c8       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
8000368a:	91 09       	st.w	r8[0x0],r9
8000368c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003690:	4a c9       	lddpc	r9,80003740 <phy_rx_func+0x604>
80003692:	72 08       	ld.w	r8,r9[0x0]
80003694:	20 28       	sub	r8,2
80003696:	93 08       	st.w	r9[0x0],r8
80003698:	c0 61       	brne	800036a4 <phy_rx_func+0x568>
					RxMediaState = WAITINGABAB;
8000369a:	30 09       	mov	r9,0
8000369c:	4a 78       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
8000369e:	91 09       	st.w	r8[0x0],r9
800036a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800036a4:	4b 18       	lddpc	r8,80003768 <phy_rx_func+0x62c>
800036a6:	70 0a       	ld.w	r10,r8[0x0]
800036a8:	4a 19       	lddpc	r9,8000372c <phy_rx_func+0x5f0>
800036aa:	72 09       	ld.w	r9,r9[0x0]
800036ac:	8e 7b       	ld.sh	r11,r7[0xe]
800036ae:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036b2:	70 09       	ld.w	r9,r8[0x0]
800036b4:	2f f9       	sub	r9,-1
800036b6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036b8:	e0 49 00 ff 	cp.w	r9,255
800036bc:	e0 88 00 13 	brls	800036e2 <phy_rx_func+0x5a6>
						{
							RxMedia_IsFillingNext16 = 0;
800036c0:	30 09       	mov	r9,0
800036c2:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800036c4:	49 a7       	lddpc	r7,8000372c <phy_rx_func+0x5f0>
800036c6:	6e 0c       	ld.w	r12,r7[0x0]
800036c8:	f0 1f 00 29 	mcall	8000376c <phy_rx_func+0x630>
							payload_ptr = get_payload_idle_isr();
800036cc:	49 78       	lddpc	r8,80003728 <phy_rx_func+0x5ec>
800036ce:	70 0c       	ld.w	r12,r8[0x0]
800036d0:	f0 1f 00 10 	mcall	80003710 <phy_rx_func+0x5d4>
800036d4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
800036d6:	c0 61       	brne	800036e2 <phy_rx_func+0x5a6>
							{
								RxMediaState = WAITINGABAB;
800036d8:	30 09       	mov	r9,0
800036da:	49 88       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
800036dc:	91 09       	st.w	r8[0x0],r9
800036de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800036e2:	49 89       	lddpc	r9,80003740 <phy_rx_func+0x604>
800036e4:	72 08       	ld.w	r8,r9[0x0]
800036e6:	20 28       	sub	r8,2
800036e8:	93 08       	st.w	r9[0x0],r8
800036ea:	c0 41       	brne	800036f2 <phy_rx_func+0x5b6>
					RxMediaState = WAITINGABAB;
800036ec:	30 09       	mov	r9,0
800036ee:	49 38       	lddpc	r8,80003738 <phy_rx_func+0x5fc>
800036f0:	91 09       	st.w	r8[0x0],r9
800036f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800036f6:	00 00       	add	r0,r0
800036f8:	00 00       	add	r0,r0
800036fa:	0a c0       	st.b	r5++,r0
800036fc:	00 00       	add	r0,r0
800036fe:	0a bc       	st.h	r5++,r12
80003700:	00 00       	add	r0,r0
80003702:	0a a0       	st.w	r5++,r0
80003704:	00 00       	add	r0,r0
80003706:	0a de       	st.w	--r5,lr
80003708:	00 00       	add	r0,r0
8000370a:	0a dc       	st.w	--r5,r12
8000370c:	00 00       	add	r0,r0
8000370e:	0a a4       	st.w	r5++,r4
80003710:	80 00       	ld.sh	r0,r0[0x0]
80003712:	2a b0       	sub	r0,-85
80003714:	00 00       	add	r0,r0
80003716:	0a 78       	tst	r8,r5
80003718:	80 00       	ld.sh	r0,r0[0x0]
8000371a:	4d 10       	lddpc	r0,8000385c <local_start_PDC+0x30>
8000371c:	00 00       	add	r0,r0
8000371e:	0a a8       	st.w	r5++,r8
80003720:	80 00       	ld.sh	r0,r0[0x0]
80003722:	29 fc       	sub	r12,-97
80003724:	00 00       	add	r0,r0
80003726:	0a b0       	st.h	r5++,r0
80003728:	00 00       	add	r0,r0
8000372a:	0a 7c       	tst	r12,r5
8000372c:	00 00       	add	r0,r0
8000372e:	0a d4       	st.w	--r5,r4
80003730:	00 00       	add	r0,r0
80003732:	0a ac       	st.w	r5++,r12
80003734:	00 00       	add	r0,r0
80003736:	04 f4       	st.b	--r2,r4
80003738:	00 00       	add	r0,r0
8000373a:	0a 8c       	andn	r12,r5
8000373c:	00 00       	add	r0,r0
8000373e:	0a 74       	tst	r4,r5
80003740:	00 00       	add	r0,r0
80003742:	0a d8       	st.w	--r5,r8
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	cb 94       	brge	800036b8 <phy_rx_func+0x57c>
80003748:	80 00       	ld.sh	r0,r0[0x0]
8000374a:	5e 08       	reteq	r8
8000374c:	00 00       	add	r0,r0
8000374e:	0a 5b       	eor	r11,r5
80003750:	00 00       	add	r0,r0
80003752:	0a 5c       	eor	r12,r5
80003754:	00 00       	add	r0,r0
80003756:	0a b1       	st.h	r5++,r1
80003758:	00 00       	add	r0,r0
8000375a:	0a 70       	tst	r0,r5
8000375c:	00 00       	add	r0,r0
8000375e:	0a 5e       	eor	lr,r5
80003760:	00 00       	add	r0,r0
80003762:	0a 5d       	eor	sp,r5
80003764:	00 00       	add	r0,r0
80003766:	0a 58       	eor	r8,r5
80003768:	00 00       	add	r0,r0
8000376a:	0a 94       	mov	r4,r5
8000376c:	80 00       	ld.sh	r0,r0[0x0]
8000376e:	30 dc       	mov	r12,13
80003770:	00 00       	add	r0,r0
80003772:	0a 54       	eor	r4,r5

80003774 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003774:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003776:	49 88       	lddpc	r8,800037d4 <pdca_int_handler+0x60>
80003778:	11 89       	ld.ub	r9,r8[0x0]
8000377a:	ec 19 00 01 	eorl	r9,0x1
8000377e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003780:	11 89       	ld.ub	r9,r8[0x0]
80003782:	a5 69       	lsl	r9,0x4
80003784:	2f c9       	sub	r9,-4
80003786:	49 5a       	lddpc	r10,800037d8 <pdca_int_handler+0x64>
80003788:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000378a:	fe 7a 00 40 	mov	r10,-65472
8000378e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003790:	30 39       	mov	r9,3
80003792:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003794:	11 8a       	ld.ub	r10,r8[0x0]
80003796:	a5 6a       	lsl	r10,0x4
80003798:	2f ca       	sub	r10,-4
8000379a:	49 18       	lddpc	r8,800037dc <pdca_int_handler+0x68>
8000379c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000379e:	fe 78 00 00 	mov	r8,-65536
800037a2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800037a4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800037a6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800037a8:	48 e8       	lddpc	r8,800037e0 <pdca_int_handler+0x6c>
800037aa:	70 08       	ld.w	r8,r8[0x0]
800037ac:	58 08       	cp.w	r8,0
800037ae:	c0 70       	breq	800037bc <pdca_int_handler+0x48>
800037b0:	48 99       	lddpc	r9,800037d4 <pdca_int_handler+0x60>
800037b2:	13 89       	ld.ub	r9,r9[0x0]
800037b4:	a5 69       	lsl	r9,0x4
800037b6:	48 ac       	lddpc	r12,800037dc <pdca_int_handler+0x68>
800037b8:	12 0c       	add	r12,r9
800037ba:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800037bc:	48 a8       	lddpc	r8,800037e4 <pdca_int_handler+0x70>
800037be:	70 08       	ld.w	r8,r8[0x0]
800037c0:	58 08       	cp.w	r8,0
800037c2:	c0 70       	breq	800037d0 <pdca_int_handler+0x5c>
800037c4:	48 49       	lddpc	r9,800037d4 <pdca_int_handler+0x60>
800037c6:	13 89       	ld.ub	r9,r9[0x0]
800037c8:	a5 69       	lsl	r9,0x4
800037ca:	48 4c       	lddpc	r12,800037d8 <pdca_int_handler+0x64>
800037cc:	12 0c       	add	r12,r9
800037ce:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800037d0:	d4 02       	popm	lr
800037d2:	d6 03       	rete
800037d4:	00 00       	add	r0,r0
800037d6:	40 bc       	lddsp	r12,sp[0x2c]
800037d8:	00 00       	add	r0,r0
800037da:	40 e4       	lddsp	r4,sp[0x38]
800037dc:	00 00       	add	r0,r0
800037de:	40 c4       	lddsp	r4,sp[0x30]
800037e0:	00 00       	add	r0,r0
800037e2:	0a e0       	st.h	--r5,r0
800037e4:	00 00       	add	r0,r0
800037e6:	0a e4       	st.h	--r5,r4

800037e8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800037e8:	fe 78 10 00 	mov	r8,-61440
800037ec:	e0 69 0d c0 	mov	r9,3520
800037f0:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800037f4:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800037f8:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800037fc:	fe 78 34 00 	mov	r8,-52224
80003800:	e0 69 80 00 	mov	r9,32768
80003804:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003806:	30 09       	mov	r9,0
80003808:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000380a:	e0 69 04 21 	mov	r9,1057
8000380e:	ea 19 3f 20 	orh	r9,0x3f20
80003812:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003814:	e0 69 02 9f 	mov	r9,671
80003818:	ea 19 01 00 	orh	r9,0x100
8000381c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000381e:	e0 6a 04 02 	mov	r10,1026
80003822:	ea 1a 3f 20 	orh	r10,0x3f20
80003826:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003828:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000382a:	5e fc       	retal	r12

8000382c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
8000382c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000382e:	30 19       	mov	r9,1
80003830:	49 78       	lddpc	r8,8000388c <local_start_PDC+0x60>
80003832:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003834:	fe 78 00 00 	mov	r8,-65536
80003838:	30 7b       	mov	r11,7
8000383a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000383c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000383e:	49 59       	lddpc	r9,80003890 <local_start_PDC+0x64>
80003840:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003844:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003846:	30 3a       	mov	r10,3
80003848:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000384a:	30 1c       	mov	r12,1
8000384c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000384e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003850:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003852:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003854:	30 2c       	mov	r12,2
80003856:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003858:	48 f9       	lddpc	r9,80003894 <local_start_PDC+0x68>
8000385a:	e0 68 5a 5a 	mov	r8,23130
8000385e:	ea 18 ab cd 	orh	r8,0xabcd
80003862:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003864:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003866:	30 0e       	mov	lr,0
80003868:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000386a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
8000386c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000386e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003870:	fe 78 00 40 	mov	r8,-65472
80003874:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003876:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003878:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
8000387c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000387e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003880:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003882:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003884:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003886:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003888:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000388a:	d8 02       	popm	pc
8000388c:	00 00       	add	r0,r0
8000388e:	40 bc       	lddsp	r12,sp[0x2c]
80003890:	00 00       	add	r0,r0
80003892:	40 c4       	lddsp	r4,sp[0x30]
80003894:	00 00       	add	r0,r0
80003896:	40 e4       	lddsp	r4,sp[0x38]

80003898 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003898:	48 38       	lddpc	r8,800038a4 <register_rx_tx_func+0xc>
8000389a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000389c:	48 38       	lddpc	r8,800038a8 <register_rx_tx_func+0x10>
8000389e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800038a0:	5e fc       	retal	r12
800038a2:	00 00       	add	r0,r0
800038a4:	00 00       	add	r0,r0
800038a6:	0a e0       	st.h	--r5,r0
800038a8:	00 00       	add	r0,r0
800038aa:	0a e4       	st.h	--r5,r4

800038ac <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800038ac:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800038ae:	fe 78 10 00 	mov	r8,-61440
800038b2:	30 29       	mov	r9,2
800038b4:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800038b8:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800038bc:	10 99       	mov	r9,r8
800038be:	f2 f8 01 60 	ld.w	r8,r9[352]
800038c2:	e2 18 00 02 	andl	r8,0x2,COH
800038c6:	cf c0       	breq	800038be <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800038c8:	fe 79 10 00 	mov	r9,-61440
800038cc:	f2 f8 01 60 	ld.w	r8,r9[352]
800038d0:	e2 18 00 02 	andl	r8,0x2,COH
800038d4:	cf c1       	brne	800038cc <ssc_init+0x20>
				
    INTC_register_interrupt (
800038d6:	30 3a       	mov	r10,3
800038d8:	36 0b       	mov	r11,96
800038da:	48 bc       	lddpc	r12,80003904 <ssc_init+0x58>
800038dc:	f0 1f 00 0b 	mcall	80003908 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800038e0:	f0 1f 00 0b 	mcall	8000390c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800038e4:	f0 1f 00 0b 	mcall	80003910 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800038e8:	fe 79 00 00 	mov	r9,-65536
800038ec:	30 18       	mov	r8,1
800038ee:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800038f0:	fe 7a 00 40 	mov	r10,-65472
800038f4:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800038f6:	e0 6b 01 01 	mov	r11,257
800038fa:	fe 7a 34 00 	mov	r10,-52224
800038fe:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003900:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003902:	d8 02       	popm	pc
80003904:	80 00       	ld.sh	r0,r0[0x0]
80003906:	37 74       	mov	r4,119
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	43 48       	lddsp	r8,sp[0xd0]
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	37 e8       	mov	r8,126
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	38 2c       	mov	r12,-126

80003914 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003914:	48 28       	lddpc	r8,8000391c <xcmp_register_app_list+0x8>
80003916:	91 0c       	st.w	r8[0x0],r12
}
80003918:	5e fc       	retal	r12
8000391a:	00 00       	add	r0,r0
8000391c:	00 00       	add	r0,r0
8000391e:	41 04       	lddsp	r4,sp[0x40]

80003920 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003920:	eb cd 40 80 	pushm	r7,lr
80003924:	fa cd 01 00 	sub	sp,sp,256
80003928:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000392a:	16 98       	mov	r8,r11
8000392c:	2f 08       	sub	r8,-16
8000392e:	af a8       	sbr	r8,0xe
80003930:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003932:	3f f8       	mov	r8,-1
80003934:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003936:	30 b9       	mov	r9,11
80003938:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000393a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000393c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000393e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003940:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003942:	f6 ca ff fe 	sub	r10,r11,-2
80003946:	18 9b       	mov	r11,r12
80003948:	fa cc ff f0 	sub	r12,sp,-16
8000394c:	f0 1f 00 05 	mcall	80003960 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003950:	2f e7       	sub	r7,-2
80003952:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003954:	1a 9c       	mov	r12,sp
80003956:	f0 1f 00 04 	mcall	80003964 <xcmp_tx+0x44>
}
8000395a:	2c 0d       	sub	sp,-256
8000395c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003960:	80 00       	ld.sh	r0,r0[0x0]
80003962:	65 dc       	ld.w	r12,r2[0x74]
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	3d ac       	mov	r12,-38

80003968 <xcmp_audio_route_mic>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_mic(void)
{
80003968:	d4 01       	pushm	lr
8000396a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000396e:	e0 68 04 14 	mov	r8,1044
80003972:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003974:	fa c8 ff fc 	sub	r8,sp,-4
			
	ptr->Function = Routing_Func_Update_Source;
80003978:	30 19       	mov	r9,1
8000397a:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings =2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
8000397c:	30 0a       	mov	r10,0
8000397e:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] = NumberofRoutings & 0xFF;
80003980:	30 2a       	mov	r10,2
80003982:	b0 aa       	st.b	r8[0x2],r10
	
	ptr->RoutingData[0].audioInput = IN_Microphone;
80003984:	b0 b9       	st.b	r8[0x3],r9
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;
80003986:	30 c9       	mov	r9,12
80003988:	b0 c9       	st.b	r8[0x4],r9
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;
8000398a:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;
8000398c:	30 d9       	mov	r9,13
8000398e:	b0 e9       	st.b	r8[0x6],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = OUT_Speaker;//OUT_Microphone_Data;//测试
	
		//
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80003990:	30 7b       	mov	r11,7
80003992:	fa cc ff fe 	sub	r12,sp,-2
80003996:	f0 1f 00 03 	mcall	800039a0 <xcmp_audio_route_mic+0x38>
}
8000399a:	2c dd       	sub	sp,-204
8000399c:	d8 02       	popm	pc
8000399e:	00 00       	add	r0,r0
800039a0:	80 00       	ld.sh	r0,r0[0x0]
800039a2:	39 20       	mov	r0,-110

800039a4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800039a4:	d4 01       	pushm	lr
800039a6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800039aa:	fe 78 b4 00 	mov	r8,-19456
800039ae:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800039b0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800039b4:	30 89       	mov	r9,8
800039b6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800039b8:	30 19       	mov	r9,1
800039ba:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800039bc:	30 09       	mov	r9,0
800039be:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800039c0:	30 5a       	mov	r10,5
800039c2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800039c4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800039c6:	30 7a       	mov	r10,7
800039c8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800039ca:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800039cc:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800039ce:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800039d2:	30 9b       	mov	r11,9
800039d4:	fa cc ff fe 	sub	r12,sp,-2
800039d8:	f0 1f 00 02 	mcall	800039e0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800039dc:	2c dd       	sub	sp,-204
800039de:	d8 02       	popm	pc
800039e0:	80 00       	ld.sh	r0,r0[0x0]
800039e2:	39 20       	mov	r0,-110

800039e4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800039e4:	d4 01       	pushm	lr
800039e6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800039ea:	fe 78 80 00 	mov	r8,-32768
800039ee:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800039f0:	30 38       	mov	r8,3
800039f2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800039f4:	30 1b       	mov	r11,1
800039f6:	fa cc ff fe 	sub	r12,sp,-2
800039fa:	f0 1f 00 03 	mcall	80003a04 <xcmp_opcode_not_supported+0x20>
}
800039fe:	2c dd       	sub	sp,-204
80003a00:	d8 02       	popm	pc
80003a02:	00 00       	add	r0,r0
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	39 20       	mov	r0,-110

80003a08 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003a08:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003a0a:	96 88       	ld.uh	r8,r11[0x0]
80003a0c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a10:	e0 48 80 00 	cp.w	r8,32768
80003a14:	c0 f0       	breq	80003a32 <xcmp_exec_func+0x2a>
80003a16:	e0 48 b0 00 	cp.w	r8,45056
80003a1a:	c1 20       	breq	80003a3e <xcmp_exec_func+0x36>
80003a1c:	58 08       	cp.w	r8,0
80003a1e:	c1 51       	brne	80003a48 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003a20:	78 08       	ld.w	r8,r12[0x0]
80003a22:	58 08       	cp.w	r8,0
80003a24:	c0 40       	breq	80003a2c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003a26:	16 9c       	mov	r12,r11
80003a28:	5d 18       	icall	r8
80003a2a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003a2c:	f0 1f 00 08 	mcall	80003a4c <xcmp_exec_func+0x44>
80003a30:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003a32:	78 18       	ld.w	r8,r12[0x4]
80003a34:	58 08       	cp.w	r8,0
80003a36:	c0 90       	breq	80003a48 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003a38:	16 9c       	mov	r12,r11
80003a3a:	5d 18       	icall	r8
80003a3c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003a3e:	78 28       	ld.w	r8,r12[0x8]
80003a40:	58 08       	cp.w	r8,0
80003a42:	c0 30       	breq	80003a48 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003a44:	16 9c       	mov	r12,r11
80003a46:	5d 18       	icall	r8
80003a48:	d8 02       	popm	pc
80003a4a:	00 00       	add	r0,r0
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	39 e4       	mov	r4,-98

80003a50 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003a50:	d4 01       	pushm	lr
80003a52:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003a56:	e0 68 04 09 	mov	r8,1033
80003a5a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003a5c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003a60:	30 19       	mov	r9,1
80003a62:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003a64:	30 09       	mov	r9,0
80003a66:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003a68:	30 ca       	mov	r10,12
80003a6a:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003a6c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003a6e:	fb 69 00 08 	st.b	sp[8],r9
80003a72:	fa c8 ff f7 	sub	r8,sp,-9
80003a76:	b0 89       	st.b	r8[0x0],r9
80003a78:	fa c8 ff f6 	sub	r8,sp,-10
80003a7c:	b0 89       	st.b	r8[0x0],r9
80003a7e:	fa c8 ff f5 	sub	r8,sp,-11
80003a82:	b0 89       	st.b	r8[0x0],r9
80003a84:	fa c8 ff f4 	sub	r8,sp,-12
80003a88:	b0 89       	st.b	r8[0x0],r9
80003a8a:	fa c8 ff f3 	sub	r8,sp,-13
80003a8e:	b0 89       	st.b	r8[0x0],r9
80003a90:	fa c8 ff f2 	sub	r8,sp,-14
80003a94:	b0 89       	st.b	r8[0x0],r9
80003a96:	fa c8 ff f1 	sub	r8,sp,-15
80003a9a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003a9c:	30 cb       	mov	r11,12
80003a9e:	fa cc ff fe 	sub	r12,sp,-2
80003aa2:	f0 1f 00 03 	mcall	80003aac <xcmp_IdleTestTone+0x5c>
}
80003aa6:	2c dd       	sub	sp,-204
80003aa8:	d8 02       	popm	pc
80003aaa:	00 00       	add	r0,r0
80003aac:	80 00       	ld.sh	r0,r0[0x0]
80003aae:	39 20       	mov	r0,-110

80003ab0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003ab0:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80003ab2:	f0 1f 00 0d 	mcall	80003ae4 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003ab6:	48 dc       	lddpc	r12,80003ae8 <xcmp_init+0x38>
80003ab8:	f0 1f 00 0d 	mcall	80003aec <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003abc:	30 4b       	mov	r11,4
80003abe:	31 4c       	mov	r12,20
80003ac0:	f0 1f 00 0c 	mcall	80003af0 <xcmp_init+0x40>
80003ac4:	48 c8       	lddpc	r8,80003af4 <xcmp_init+0x44>
80003ac6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ac8:	30 09       	mov	r9,0
80003aca:	1a d9       	st.w	--sp,r9
80003acc:	1a d9       	st.w	--sp,r9
80003ace:	1a d9       	st.w	--sp,r9
80003ad0:	30 38       	mov	r8,3
80003ad2:	e0 6a 01 80 	mov	r10,384
80003ad6:	48 9b       	lddpc	r11,80003af8 <xcmp_init+0x48>
80003ad8:	48 9c       	lddpc	r12,80003afc <xcmp_init+0x4c>
80003ada:	f0 1f 00 0a 	mcall	80003b00 <xcmp_init+0x50>
80003ade:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80003ae0:	d8 02       	popm	pc
80003ae2:	00 00       	add	r0,r0
80003ae4:	80 00       	ld.sh	r0,r0[0x0]
80003ae6:	3e 90       	mov	r0,-23
80003ae8:	80 00       	ld.sh	r0,r0[0x0]
80003aea:	3c 00       	mov	r0,-64
80003aec:	80 00       	ld.sh	r0,r0[0x0]
80003aee:	3c 4c       	mov	r12,-60
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	51 e4       	stdsp	sp[0x78],r4
80003af4:	00 00       	add	r0,r0
80003af6:	0a f4       	st.b	--r5,r4
80003af8:	80 00       	ld.sh	r0,r0[0x0]
80003afa:	cb ac       	rcall	80003c6e <xnl_get_msg_ack_func+0x16>
80003afc:	80 00       	ld.sh	r0,r0[0x0]
80003afe:	3b 04       	mov	r4,-80
80003b00:	80 00       	ld.sh	r0,r0[0x0]
80003b02:	58 b8       	cp.w	r8,11

80003b04 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003b04:	d4 31       	pushm	r0-r7,lr
80003b06:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003b08:	4b 16       	lddpc	r6,80003bcc <xcmp_rx_process+0xc8>
80003b0a:	30 05       	mov	r5,0
80003b0c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003b0e:	4b 13       	lddpc	r3,80003bd0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003b10:	4b 12       	lddpc	r2,80003bd4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003b12:	4b 21       	lddpc	r1,80003bd8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003b14:	4b 20       	lddpc	r0,80003bdc <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003b16:	6c 0c       	ld.w	r12,r6[0x0]
80003b18:	0a 99       	mov	r9,r5
80003b1a:	08 9a       	mov	r10,r4
80003b1c:	1a 9b       	mov	r11,sp
80003b1e:	f0 1f 00 31 	mcall	80003be0 <xcmp_rx_process+0xdc>
80003b22:	58 1c       	cp.w	r12,1
80003b24:	cf 91       	brne	80003b16 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003b26:	40 0b       	lddsp	r11,sp[0x0]
80003b28:	58 0b       	cp.w	r11,0
80003b2a:	cf 60       	breq	80003b16 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003b2c:	96 0a       	ld.sh	r10,r11[0x0]
80003b2e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003b32:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003b36:	59 c8       	cp.w	r8,28
80003b38:	c1 e0       	breq	80003b74 <xcmp_rx_process+0x70>
80003b3a:	e0 89 00 07 	brgt	80003b48 <xcmp_rx_process+0x44>
80003b3e:	58 e8       	cp.w	r8,14
80003b40:	c0 e0       	breq	80003b5c <xcmp_rx_process+0x58>
80003b42:	58 f8       	cp.w	r8,15
80003b44:	c2 41       	brne	80003b8c <xcmp_rx_process+0x88>
80003b46:	c0 f8       	rjmp	80003b64 <xcmp_rx_process+0x60>
80003b48:	e0 48 01 09 	cp.w	r8,265
80003b4c:	c1 80       	breq	80003b7c <xcmp_rx_process+0x78>
80003b4e:	e0 48 01 0a 	cp.w	r8,266
80003b52:	c1 90       	breq	80003b84 <xcmp_rx_process+0x80>
80003b54:	e0 48 00 2c 	cp.w	r8,44
80003b58:	c1 a1       	brne	80003b8c <xcmp_rx_process+0x88>
80003b5a:	c0 98       	rjmp	80003b6c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003b5c:	4a 2c       	lddpc	r12,80003be4 <xcmp_rx_process+0xe0>
80003b5e:	f0 1f 00 23 	mcall	80003be8 <xcmp_rx_process+0xe4>
					break;
80003b62:	c2 f8       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003b64:	4a 2c       	lddpc	r12,80003bec <xcmp_rx_process+0xe8>
80003b66:	f0 1f 00 21 	mcall	80003be8 <xcmp_rx_process+0xe4>
					break;
80003b6a:	c2 b8       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003b6c:	4a 1c       	lddpc	r12,80003bf0 <xcmp_rx_process+0xec>
80003b6e:	f0 1f 00 1f 	mcall	80003be8 <xcmp_rx_process+0xe4>
					break;
80003b72:	c2 78       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003b74:	04 9c       	mov	r12,r2
80003b76:	f0 1f 00 1d 	mcall	80003be8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003b7a:	c2 38       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003b7c:	02 9c       	mov	r12,r1
80003b7e:	f0 1f 00 1b 	mcall	80003be8 <xcmp_rx_process+0xe4>
					break;
80003b82:	c1 f8       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003b84:	00 9c       	mov	r12,r0
80003b86:	f0 1f 00 19 	mcall	80003be8 <xcmp_rx_process+0xe4>
					break;
80003b8a:	c1 b8       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003b8c:	12 98       	mov	r8,r9
80003b8e:	e2 18 04 00 	andl	r8,0x400,COH
80003b92:	c0 70       	breq	80003ba0 <xcmp_rx_process+0x9c>
80003b94:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003b98:	e0 48 00 68 	cp.w	r8,104
80003b9c:	e0 8a 00 08 	brle	80003bac <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003ba0:	e2 19 f0 00 	andl	r9,0xf000,COH
80003ba4:	c0 e1       	brne	80003bc0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003ba6:	f0 1f 00 14 	mcall	80003bf4 <xcmp_rx_process+0xf0>
80003baa:	c0 b8       	rjmp	80003bc0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003bac:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003bb0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003bb4:	49 19       	lddpc	r9,80003bf8 <xcmp_rx_process+0xf4>
80003bb6:	72 08       	ld.w	r8,r9[0x0]
80003bb8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003bbc:	f0 1f 00 0b 	mcall	80003be8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003bc0:	66 0c       	ld.w	r12,r3[0x0]
80003bc2:	40 0b       	lddsp	r11,sp[0x0]
80003bc4:	f0 1f 00 0e 	mcall	80003bfc <xcmp_rx_process+0xf8>
80003bc8:	ca 7b       	rjmp	80003b16 <xcmp_rx_process+0x12>
80003bca:	00 00       	add	r0,r0
80003bcc:	00 00       	add	r0,r0
80003bce:	0a f4       	st.b	--r5,r4
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a a4       	st.w	r5++,r4
80003bd4:	00 00       	add	r0,r0
80003bd6:	0b 04       	ld.w	r4,r5++
80003bd8:	00 00       	add	r0,r0
80003bda:	0a f8       	st.b	--r5,r8
80003bdc:	00 00       	add	r0,r0
80003bde:	0b 10       	ld.sh	r0,r5++
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	4e 80       	lddpc	r0,80003d80 <xnl_rx_process+0x34>
80003be4:	00 00       	add	r0,r0
80003be6:	0b 28       	ld.uh	r8,r5++
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	3a 08       	mov	r8,-96
80003bec:	00 00       	add	r0,r0
80003bee:	0a e8       	st.h	--r5,r8
80003bf0:	00 00       	add	r0,r0
80003bf2:	0b 1c       	ld.sh	r12,r5++
80003bf4:	80 00       	ld.sh	r0,r0[0x0]
80003bf6:	39 e4       	mov	r4,-98
80003bf8:	00 00       	add	r0,r0
80003bfa:	41 04       	lddsp	r4,sp[0x40]
80003bfc:	80 00       	ld.sh	r0,r0[0x0]
80003bfe:	2a 34       	sub	r4,-93

80003c00 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80003c00:	eb cd 40 90 	pushm	r4,r7,lr
80003c04:	20 1d       	sub	sp,4
80003c06:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003c0a:	48 c8       	lddpc	r8,80003c38 <xcmp_rx+0x38>
80003c0c:	70 0c       	ld.w	r12,r8[0x0]
80003c0e:	f0 1f 00 0c 	mcall	80003c3c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80003c12:	c1 00       	breq	80003c32 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003c14:	fa c7 ff fc 	sub	r7,sp,-4
80003c18:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80003c1a:	e0 6a 00 ca 	mov	r10,202
80003c1e:	08 9b       	mov	r11,r4
80003c20:	f0 1f 00 08 	mcall	80003c40 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80003c24:	48 88       	lddpc	r8,80003c44 <xcmp_rx+0x44>
80003c26:	70 0c       	ld.w	r12,r8[0x0]
80003c28:	30 09       	mov	r9,0
80003c2a:	12 9a       	mov	r10,r9
80003c2c:	1a 9b       	mov	r11,sp
80003c2e:	f0 1f 00 07 	mcall	80003c48 <xcmp_rx+0x48>
	}	
}
80003c32:	2f fd       	sub	sp,-4
80003c34:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80003c38:	00 00       	add	r0,r0
80003c3a:	0a a4       	st.w	r5++,r4
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	2f e8       	sub	r8,-2
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	65 dc       	ld.w	r12,r2[0x74]
80003c44:	00 00       	add	r0,r0
80003c46:	0a f4       	st.b	--r5,r4
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	50 8c       	stdsp	sp[0x20],r12

80003c4c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80003c4c:	48 28       	lddpc	r8,80003c54 <xnl_register_xcmp_func+0x8>
80003c4e:	91 0c       	st.w	r8[0x0],r12
}
80003c50:	5e fc       	retal	r12
80003c52:	00 00       	add	r0,r0
80003c54:	00 00       	add	r0,r0
80003c56:	0b 58       	ld.sh	r8,--r5

80003c58 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80003c58:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80003c5a:	48 88       	lddpc	r8,80003c78 <xnl_get_msg_ack_func+0x20>
80003c5c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80003c5e:	98 49       	ld.sh	r9,r12[0x8]
80003c60:	f0 09 19 00 	cp.h	r9,r8
80003c64:	c0 81       	brne	80003c74 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80003c66:	48 68       	lddpc	r8,80003c7c <xnl_get_msg_ack_func+0x24>
80003c68:	70 0c       	ld.w	r12,r8[0x0]
80003c6a:	30 09       	mov	r9,0
80003c6c:	12 9a       	mov	r10,r9
80003c6e:	12 9b       	mov	r11,r9
80003c70:	f0 1f 00 04 	mcall	80003c80 <xnl_get_msg_ack_func+0x28>
80003c74:	d8 02       	popm	pc
80003c76:	00 00       	add	r0,r0
80003c78:	00 00       	add	r0,r0
80003c7a:	0b 38       	ld.ub	r8,r5++
80003c7c:	00 00       	add	r0,r0
80003c7e:	0b 34       	ld.ub	r4,r5++
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	50 8c       	stdsp	sp[0x20],r12

80003c84 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80003c84:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80003c86:	4a 86       	lddpc	r6,80003d24 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80003c88:	4a 82       	lddpc	r2,80003d28 <xnl_tx_process+0xa4>
80003c8a:	4a 94       	lddpc	r4,80003d2c <xnl_tx_process+0xa8>
80003c8c:	30 07       	mov	r7,0
80003c8e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80003c90:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80003c92:	4a 85       	lddpc	r5,80003d30 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80003c94:	4a 83       	lddpc	r3,80003d34 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80003c96:	6c 08       	ld.w	r8,r6[0x0]
80003c98:	58 08       	cp.w	r8,0
80003c9a:	c0 40       	breq	80003ca2 <xnl_tx_process+0x1e>
80003c9c:	58 18       	cp.w	r8,1
80003c9e:	cf d1       	brne	80003c98 <xnl_tx_process+0x14>
80003ca0:	c2 08       	rjmp	80003ce0 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80003ca2:	64 0c       	ld.w	r12,r2[0x0]
80003ca4:	0e 99       	mov	r9,r7
80003ca6:	02 9a       	mov	r10,r1
80003ca8:	08 9b       	mov	r11,r4
80003caa:	f0 1f 00 24 	mcall	80003d38 <xnl_tx_process+0xb4>
80003cae:	58 1c       	cp.w	r12,1
80003cb0:	cf 31       	brne	80003c96 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80003cb2:	68 0c       	ld.w	r12,r4[0x0]
80003cb4:	58 0c       	cp.w	r12,0
80003cb6:	cf 00       	breq	80003c96 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80003cb8:	98 28       	ld.sh	r8,r12[0x4]
80003cba:	e0 08 19 00 	cp.h	r8,r0
80003cbe:	c0 41       	brne	80003cc6 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80003cc0:	f0 1f 00 1f 	mcall	80003d3c <xnl_tx_process+0xb8>
						break;
80003cc4:	ce 9b       	rjmp	80003c96 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80003cc6:	f0 1f 00 1f 	mcall	80003d40 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80003cca:	30 18       	mov	r8,1
80003ccc:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80003cce:	66 0c       	ld.w	r12,r3[0x0]
80003cd0:	0e 99       	mov	r9,r7
80003cd2:	0e 9a       	mov	r10,r7
80003cd4:	0e 9b       	mov	r11,r7
80003cd6:	f0 1f 00 19 	mcall	80003d38 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
80003cda:	30 18       	mov	r8,1
80003cdc:	8d 08       	st.w	r6[0x0],r8
80003cde:	cd cb       	rjmp	80003c96 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80003ce0:	66 0c       	ld.w	r12,r3[0x0]
80003ce2:	0e 99       	mov	r9,r7
80003ce4:	36 4a       	mov	r10,100
80003ce6:	0e 9b       	mov	r11,r7
80003ce8:	f0 1f 00 14 	mcall	80003d38 <xnl_tx_process+0xb4>
80003cec:	58 1c       	cp.w	r12,1
80003cee:	c0 81       	brne	80003cfe <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80003cf0:	49 58       	lddpc	r8,80003d44 <xnl_tx_process+0xc0>
80003cf2:	70 0c       	ld.w	r12,r8[0x0]
80003cf4:	68 0b       	ld.w	r11,r4[0x0]
80003cf6:	f0 1f 00 15 	mcall	80003d48 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80003cfa:	8d 07       	st.w	r6[0x0],r7
80003cfc:	cc db       	rjmp	80003c96 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80003cfe:	6a 08       	ld.w	r8,r5[0x0]
80003d00:	58 38       	cp.w	r8,3
80003d02:	e0 89 00 09 	brgt	80003d14 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80003d06:	68 0c       	ld.w	r12,r4[0x0]
80003d08:	f0 1f 00 0e 	mcall	80003d40 <xnl_tx_process+0xbc>
						xnl_send_times++;
80003d0c:	6a 08       	ld.w	r8,r5[0x0]
80003d0e:	2f f8       	sub	r8,-1
80003d10:	8b 08       	st.w	r5[0x0],r8
80003d12:	cc 2b       	rjmp	80003c96 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80003d14:	48 c8       	lddpc	r8,80003d44 <xnl_tx_process+0xc0>
80003d16:	70 0c       	ld.w	r12,r8[0x0]
80003d18:	68 0b       	ld.w	r11,r4[0x0]
80003d1a:	f0 1f 00 0c 	mcall	80003d48 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80003d1e:	8d 07       	st.w	r6[0x0],r7
80003d20:	cb bb       	rjmp	80003c96 <xnl_tx_process+0x12>
80003d22:	00 00       	add	r0,r0
80003d24:	00 00       	add	r0,r0
80003d26:	0b 54       	ld.sh	r4,--r5
80003d28:	00 00       	add	r0,r0
80003d2a:	0b 48       	ld.w	r8,--r5
80003d2c:	00 00       	add	r0,r0
80003d2e:	0b 4c       	ld.w	r12,--r5
80003d30:	00 00       	add	r0,r0
80003d32:	0b 44       	ld.w	r4,--r5
80003d34:	00 00       	add	r0,r0
80003d36:	0b 34       	ld.ub	r4,r5++
80003d38:	80 00       	ld.sh	r0,r0[0x0]
80003d3a:	4e 80       	lddpc	r0,80003ed8 <xnl_init+0x48>
80003d3c:	80 00       	ld.sh	r0,r0[0x0]
80003d3e:	4d 10       	lddpc	r0,80003e80 <xnl_tx+0xd4>
80003d40:	80 00       	ld.sh	r0,r0[0x0]
80003d42:	2a 54       	sub	r4,-91
80003d44:	00 00       	add	r0,r0
80003d46:	0a a4       	st.w	r5++,r4
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	2a 34       	sub	r4,-93

80003d4c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80003d4c:	eb cd 40 fe 	pushm	r1-r7,lr
80003d50:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80003d52:	49 26       	lddpc	r6,80003d98 <xnl_rx_process+0x4c>
80003d54:	30 05       	mov	r5,0
80003d56:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80003d58:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80003d5a:	49 11       	lddpc	r1,80003d9c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80003d5c:	49 12       	lddpc	r2,80003da0 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80003d5e:	6c 0c       	ld.w	r12,r6[0x0]
80003d60:	0a 99       	mov	r9,r5
80003d62:	08 9a       	mov	r10,r4
80003d64:	1a 9b       	mov	r11,sp
80003d66:	f0 1f 00 10 	mcall	80003da4 <xnl_rx_process+0x58>
80003d6a:	58 1c       	cp.w	r12,1
80003d6c:	cf 91       	brne	80003d5e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80003d6e:	40 0c       	lddsp	r12,sp[0x0]
80003d70:	58 0c       	cp.w	r12,0
80003d72:	cf 60       	breq	80003d5e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80003d74:	98 28       	ld.sh	r8,r12[0x4]
80003d76:	e6 08 19 00 	cp.h	r8,r3
80003d7a:	e0 8b 00 0a 	brhi	80003d8e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80003d7e:	5c 78       	castu.h	r8
80003d80:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80003d84:	58 09       	cp.w	r9,0
80003d86:	c0 40       	breq	80003d8e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80003d88:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80003d8c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80003d8e:	62 0c       	ld.w	r12,r1[0x0]
80003d90:	40 0b       	lddsp	r11,sp[0x0]
80003d92:	f0 1f 00 06 	mcall	80003da8 <xnl_rx_process+0x5c>
80003d96:	ce 4b       	rjmp	80003d5e <xnl_rx_process+0x12>
80003d98:	00 00       	add	r0,r0
80003d9a:	0a c0       	st.b	r5++,r0
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a a4       	st.w	r5++,r4
80003da0:	00 00       	add	r0,r0
80003da2:	04 fc       	st.b	--r2,r12
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	4e 80       	lddpc	r0,80003f44 <xnl_init+0xb4>
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	2a 34       	sub	r4,-93

80003dac <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80003dac:	eb cd 40 c0 	pushm	r6-r7,lr
80003db0:	20 1d       	sub	sp,4
80003db2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80003db4:	98 39       	ld.sh	r9,r12[0x6]
80003db6:	3f f8       	mov	r8,-1
80003db8:	f0 09 19 00 	cp.h	r9,r8
80003dbc:	c0 a1       	brne	80003dd0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80003dbe:	4a e9       	lddpc	r9,80003e74 <xnl_tx+0xc8>
80003dc0:	13 88       	ld.ub	r8,r9[0x0]
80003dc2:	2f f8       	sub	r8,-1
80003dc4:	5c 58       	castu.b	r8
80003dc6:	b2 88       	st.b	r9[0x0],r8
80003dc8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003dcc:	a9 a8       	sbr	r8,0x8
80003dce:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80003dd0:	8c 49       	ld.sh	r9,r6[0x8]
80003dd2:	3f f8       	mov	r8,-1
80003dd4:	f0 09 19 00 	cp.h	r9,r8
80003dd8:	c0 41       	brne	80003de0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80003dda:	4a 88       	lddpc	r8,80003e78 <xnl_tx+0xcc>
80003ddc:	90 18       	ld.sh	r8,r8[0x2]
80003dde:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80003de0:	8c 59       	ld.sh	r9,r6[0xa]
80003de2:	3f f8       	mov	r8,-1
80003de4:	f0 09 19 00 	cp.h	r9,r8
80003de8:	c0 41       	brne	80003df0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80003dea:	4a 48       	lddpc	r8,80003e78 <xnl_tx+0xcc>
80003dec:	90 28       	ld.sh	r8,r8[0x4]
80003dee:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80003df0:	8c 69       	ld.sh	r9,r6[0xc]
80003df2:	3f f8       	mov	r8,-1
80003df4:	f0 09 19 00 	cp.h	r9,r8
80003df8:	c0 e1       	brne	80003e14 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80003dfa:	4a 08       	lddpc	r8,80003e78 <xnl_tx+0xcc>
80003dfc:	90 49       	ld.sh	r9,r8[0x8]
80003dfe:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003e00:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80003e02:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003e04:	90 49       	ld.sh	r9,r8[0x8]
80003e06:	e0 19 ff 00 	andl	r9,0xff00
80003e0a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80003e0e:	f3 e8 10 08 	or	r8,r9,r8
80003e12:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80003e14:	0d 98       	ld.ub	r8,r6[0x1]
80003e16:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80003e18:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80003e1c:	10 0c       	add	r12,r8
80003e1e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003e20:	58 0c       	cp.w	r12,0
80003e22:	e0 89 00 04 	brgt	80003e2a <xnl_tx+0x7e>
80003e26:	30 09       	mov	r9,0
80003e28:	c0 d8       	rjmp	80003e42 <xnl_tx+0x96>
80003e2a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80003e2e:	2f ec       	sub	r12,-2
80003e30:	30 09       	mov	r9,0
80003e32:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80003e34:	15 1b       	ld.sh	r11,r10++
80003e36:	f6 09 00 09 	add	r9,r11,r9
80003e3a:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003e3c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003e3e:	18 38       	cp.w	r8,r12
80003e40:	cf a1       	brne	80003e34 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80003e42:	5c 39       	neg	r9
80003e44:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003e46:	48 e8       	lddpc	r8,80003e7c <xnl_tx+0xd0>
80003e48:	70 0c       	ld.w	r12,r8[0x0]
80003e4a:	f0 1f 00 0e 	mcall	80003e80 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80003e4e:	c1 00       	breq	80003e6e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003e50:	fa c7 ff fc 	sub	r7,sp,-4
80003e54:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80003e56:	e0 6a 01 00 	mov	r10,256
80003e5a:	0c 9b       	mov	r11,r6
80003e5c:	f0 1f 00 0a 	mcall	80003e84 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80003e60:	48 a8       	lddpc	r8,80003e88 <xnl_tx+0xdc>
80003e62:	70 0c       	ld.w	r12,r8[0x0]
80003e64:	30 09       	mov	r9,0
80003e66:	12 9a       	mov	r10,r9
80003e68:	1a 9b       	mov	r11,sp
80003e6a:	f0 1f 00 09 	mcall	80003e8c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80003e6e:	2f fd       	sub	sp,-4
80003e70:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003e74:	00 00       	add	r0,r0
80003e76:	0b 50       	ld.sh	r0,--r5
80003e78:	00 00       	add	r0,r0
80003e7a:	0b 38       	ld.ub	r8,r5++
80003e7c:	00 00       	add	r0,r0
80003e7e:	0a a4       	st.w	r5++,r4
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	2f e8       	sub	r8,-2
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	65 dc       	ld.w	r12,r2[0x74]
80003e88:	00 00       	add	r0,r0
80003e8a:	0b 48       	ld.w	r8,--r5
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	50 8c       	stdsp	sp[0x20],r12

80003e90 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80003e90:	eb cd 40 80 	pushm	r7,lr
80003e94:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80003e98:	f0 1f 00 27 	mcall	80003f34 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80003e9c:	30 09       	mov	r9,0
80003e9e:	4a 78       	lddpc	r8,80003f38 <xnl_init+0xa8>
80003ea0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80003ea2:	30 0b       	mov	r11,0
80003ea4:	30 1c       	mov	r12,1
80003ea6:	f0 1f 00 26 	mcall	80003f3c <xnl_init+0xac>
80003eaa:	4a 68       	lddpc	r8,80003f40 <xnl_init+0xb0>
80003eac:	91 0c       	st.w	r8[0x0],r12
80003eae:	70 08       	ld.w	r8,r8[0x0]
80003eb0:	58 08       	cp.w	r8,0
80003eb2:	c0 80       	breq	80003ec2 <xnl_init+0x32>
80003eb4:	4a 38       	lddpc	r8,80003f40 <xnl_init+0xb0>
80003eb6:	70 0c       	ld.w	r12,r8[0x0]
80003eb8:	30 09       	mov	r9,0
80003eba:	12 9a       	mov	r10,r9
80003ebc:	12 9b       	mov	r11,r9
80003ebe:	f0 1f 00 22 	mcall	80003f44 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80003ec2:	30 4b       	mov	r11,4
80003ec4:	31 4c       	mov	r12,20
80003ec6:	f0 1f 00 1e 	mcall	80003f3c <xnl_init+0xac>
80003eca:	4a 08       	lddpc	r8,80003f48 <xnl_init+0xb8>
80003ecc:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003ece:	30 07       	mov	r7,0
80003ed0:	1a d7       	st.w	--sp,r7
80003ed2:	1a d7       	st.w	--sp,r7
80003ed4:	1a d7       	st.w	--sp,r7
80003ed6:	30 38       	mov	r8,3
80003ed8:	0e 99       	mov	r9,r7
80003eda:	e0 6a 02 00 	mov	r10,512
80003ede:	49 cb       	lddpc	r11,80003f4c <xnl_init+0xbc>
80003ee0:	49 cc       	lddpc	r12,80003f50 <xnl_init+0xc0>
80003ee2:	f0 1f 00 1d 	mcall	80003f54 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80003ee6:	1a d7       	st.w	--sp,r7
80003ee8:	1a d7       	st.w	--sp,r7
80003eea:	1a d7       	st.w	--sp,r7
80003eec:	30 38       	mov	r8,3
80003eee:	0e 99       	mov	r9,r7
80003ef0:	e0 6a 03 20 	mov	r10,800
80003ef4:	49 9b       	lddpc	r11,80003f58 <xnl_init+0xc8>
80003ef6:	49 ac       	lddpc	r12,80003f5c <xnl_init+0xcc>
80003ef8:	f0 1f 00 17 	mcall	80003f54 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003efc:	e0 68 40 0e 	mov	r8,16398
80003f00:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003f04:	3f f8       	mov	r8,-1
80003f06:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80003f0a:	30 38       	mov	r8,3
80003f0c:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80003f10:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80003f14:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80003f18:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80003f1c:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80003f20:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003f24:	fa cc ff e8 	sub	r12,sp,-24
80003f28:	f0 1f 00 0e 	mcall	80003f60 <xnl_init+0xd0>
80003f2c:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80003f2e:	2c 0d       	sub	sp,-256
80003f30:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	30 10       	mov	r0,1
80003f38:	00 00       	add	r0,r0
80003f3a:	0b 38       	ld.ub	r8,r5++
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	51 e4       	stdsp	sp[0x78],r4
80003f40:	00 00       	add	r0,r0
80003f42:	0b 34       	ld.ub	r4,r5++
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	50 8c       	stdsp	sp[0x20],r12
80003f48:	00 00       	add	r0,r0
80003f4a:	0b 48       	ld.w	r8,--r5
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	cb b4       	brge	80003ec4 <xnl_init+0x34>
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	3d 4c       	mov	r12,-44
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	58 b8       	cp.w	r8,11
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	be 00       	st.h	pc[0x0],r0
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	3c 84       	mov	r4,-56
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	3d ac       	mov	r12,-38

80003f64 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80003f64:	eb cd 40 80 	pushm	r7,lr
80003f68:	fa cd 01 00 	sub	sp,sp,256
80003f6c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003f6e:	e0 68 40 0e 	mov	r8,16398
80003f72:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003f74:	3f f8       	mov	r8,-1
80003f76:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80003f78:	30 c8       	mov	r8,12
80003f7a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80003f7c:	98 38       	ld.sh	r8,r12[0x6]
80003f7e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80003f80:	98 58       	ld.sh	r8,r12[0xa]
80003f82:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80003f84:	98 48       	ld.sh	r8,r12[0x8]
80003f86:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80003f88:	98 68       	ld.sh	r8,r12[0xc]
80003f8a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80003f8c:	30 08       	mov	r8,0
80003f8e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003f90:	1a 9c       	mov	r12,sp
80003f92:	f0 1f 00 0a 	mcall	80003fb8 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80003f96:	fa cd 00 cc 	sub	sp,sp,204
80003f9a:	e0 6a 00 ca 	mov	r10,202
80003f9e:	ee cb ff f0 	sub	r11,r7,-16
80003fa2:	1a 9c       	mov	r12,sp
80003fa4:	f0 1f 00 06 	mcall	80003fbc <xnl_data_msg_func+0x58>
80003fa8:	48 68       	lddpc	r8,80003fc0 <xnl_data_msg_func+0x5c>
80003faa:	70 08       	ld.w	r8,r8[0x0]
80003fac:	5d 18       	icall	r8
80003fae:	fa cd ff 34 	sub	sp,sp,-204
}
80003fb2:	2c 0d       	sub	sp,-256
80003fb4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	3d ac       	mov	r12,-38
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	65 dc       	ld.w	r12,r2[0x74]
80003fc0:	00 00       	add	r0,r0
80003fc2:	0b 58       	ld.sh	r8,--r5

80003fc4 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80003fc4:	d4 21       	pushm	r4-r7,lr
80003fc6:	fa cd 01 00 	sub	sp,sp,256
80003fca:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80003fcc:	4c 28       	lddpc	r8,800040d4 <xnl_device_auth_reply_func+0x110>
80003fce:	11 88       	ld.ub	r8,r8[0x0]
80003fd0:	58 08       	cp.w	r8,0
80003fd2:	e0 81 00 7f 	brne	800040d0 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80003fd6:	4c 18       	lddpc	r8,800040d8 <xnl_device_auth_reply_func+0x114>
80003fd8:	70 0c       	ld.w	r12,r8[0x0]
80003fda:	30 09       	mov	r9,0
80003fdc:	12 9a       	mov	r10,r9
80003fde:	12 9b       	mov	r11,r9
80003fe0:	f0 1f 00 3f 	mcall	800040dc <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80003fe4:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80003fe8:	4b b8       	lddpc	r8,800040d4 <xnl_device_auth_reply_func+0x110>
80003fea:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80003fec:	ef 39 00 12 	ld.ub	r9,r7[18]
80003ff0:	ef 38 00 13 	ld.ub	r8,r7[19]
80003ff4:	b1 68       	lsl	r8,0x10
80003ff6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80003ffa:	ef 38 00 15 	ld.ub	r8,r7[21]
80003ffe:	f3 e8 10 08 	or	r8,r9,r8
80004002:	ef 39 00 14 	ld.ub	r9,r7[20]
80004006:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000400a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000400e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004012:	b1 68       	lsl	r8,0x10
80004014:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004018:	ef 38 00 19 	ld.ub	r8,r7[25]
8000401c:	f5 e8 10 08 	or	r8,r10,r8
80004020:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004024:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004028:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000402a:	e0 64 79 b9 	mov	r4,31161
8000402e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004032:	e0 65 45 07 	mov	r5,17671
80004036:	ea 15 8a bd 	orh	r5,0x8abd
8000403a:	e0 66 f9 3d 	mov	r6,63805
8000403e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004042:	e0 6e b8 cf 	mov	lr,47311
80004046:	ea 1e 36 83 	orh	lr,0x3683
8000404a:	e0 67 aa 1c 	mov	r7,43548
8000404e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004052:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004054:	f4 08 00 0c 	add	r12,r10,r8
80004058:	f0 0b 15 04 	lsl	r11,r8,0x4
8000405c:	0a 0b       	add	r11,r5
8000405e:	f9 eb 20 0b 	eor	r11,r12,r11
80004062:	f0 0c 16 05 	lsr	r12,r8,0x5
80004066:	0c 0c       	add	r12,r6
80004068:	18 5b       	eor	r11,r12
8000406a:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000406c:	f2 0c 15 04 	lsl	r12,r9,0x4
80004070:	1c 0c       	add	r12,lr
80004072:	f2 0b 16 05 	lsr	r11,r9,0x5
80004076:	0e 0b       	add	r11,r7
80004078:	f9 eb 20 0b 	eor	r11,r12,r11
8000407c:	f2 0a 00 0c 	add	r12,r9,r10
80004080:	18 5b       	eor	r11,r12
80004082:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004084:	e0 6b 37 20 	mov	r11,14112
80004088:	ea 1b c6 ef 	orh	r11,0xc6ef
8000408c:	16 3a       	cp.w	r10,r11
8000408e:	ce 21       	brne	80004052 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004090:	e0 6a 40 1a 	mov	r10,16410
80004094:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004096:	3f fa       	mov	r10,-1
80004098:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000409a:	30 6b       	mov	r11,6
8000409c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000409e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800040a0:	48 db       	lddpc	r11,800040d4 <xnl_device_auth_reply_func+0x110>
800040a2:	96 1c       	ld.sh	r12,r11[0x2]
800040a4:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800040a6:	96 2b       	ld.sh	r11,r11[0x4]
800040a8:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800040aa:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800040ac:	30 ca       	mov	r10,12
800040ae:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800040b0:	30 0a       	mov	r10,0
800040b2:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800040b6:	30 7a       	mov	r10,7
800040b8:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800040bc:	30 2a       	mov	r10,2
800040be:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800040c2:	fa ca ff ec 	sub	r10,sp,-20
800040c6:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800040c8:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800040ca:	1a 9c       	mov	r12,sp
800040cc:	f0 1f 00 05 	mcall	800040e0 <xnl_device_auth_reply_func+0x11c>
}
800040d0:	2c 0d       	sub	sp,-256
800040d2:	d8 22       	popm	r4-r7,pc
800040d4:	00 00       	add	r0,r0
800040d6:	0b 38       	ld.ub	r8,r5++
800040d8:	00 00       	add	r0,r0
800040da:	0b 34       	ld.ub	r4,r5++
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	50 8c       	stdsp	sp[0x20],r12
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	3d ac       	mov	r12,-38

800040e4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800040e4:	eb cd 40 80 	pushm	r7,lr
800040e8:	fa cd 01 00 	sub	sp,sp,256
800040ec:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800040ee:	49 28       	lddpc	r8,80004134 <xnl_master_status_brdcst_func+0x50>
800040f0:	11 88       	ld.ub	r8,r8[0x0]
800040f2:	58 08       	cp.w	r8,0
800040f4:	c1 c1       	brne	8000412c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800040f6:	49 18       	lddpc	r8,80004138 <xnl_master_status_brdcst_func+0x54>
800040f8:	70 0c       	ld.w	r12,r8[0x0]
800040fa:	30 09       	mov	r9,0
800040fc:	12 9a       	mov	r10,r9
800040fe:	12 9b       	mov	r11,r9
80004100:	f0 1f 00 0f 	mcall	8000413c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004104:	8e 58       	ld.sh	r8,r7[0xa]
80004106:	48 c9       	lddpc	r9,80004134 <xnl_master_status_brdcst_func+0x50>
80004108:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000410a:	e0 68 40 0e 	mov	r8,16398
8000410e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004110:	3f f8       	mov	r8,-1
80004112:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004114:	30 4a       	mov	r10,4
80004116:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004118:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000411a:	92 19       	ld.sh	r9,r9[0x2]
8000411c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000411e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004120:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004122:	30 08       	mov	r8,0
80004124:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004126:	1a 9c       	mov	r12,sp
80004128:	f0 1f 00 06 	mcall	80004140 <xnl_master_status_brdcst_func+0x5c>
}
8000412c:	2c 0d       	sub	sp,-256
8000412e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004132:	00 00       	add	r0,r0
80004134:	00 00       	add	r0,r0
80004136:	0b 38       	ld.ub	r8,r5++
80004138:	00 00       	add	r0,r0
8000413a:	0b 34       	ld.ub	r4,r5++
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	50 8c       	stdsp	sp[0x20],r12
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	3d ac       	mov	r12,-38

80004144 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004144:	eb cd 40 80 	pushm	r7,lr
80004148:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000414a:	49 38       	lddpc	r8,80004194 <xnl_device_conn_reply_func+0x50>
8000414c:	70 0c       	ld.w	r12,r8[0x0]
8000414e:	30 09       	mov	r9,0
80004150:	12 9a       	mov	r10,r9
80004152:	12 9b       	mov	r11,r9
80004154:	f0 1f 00 11 	mcall	80004198 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004158:	ef 18 00 10 	ld.uh	r8,r7[16]
8000415c:	10 99       	mov	r9,r8
8000415e:	e2 19 ff 00 	andl	r9,0xff00,COH
80004162:	e0 49 01 00 	cp.w	r9,256
80004166:	c0 60       	breq	80004172 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004168:	0e 9c       	mov	r12,r7
8000416a:	f0 1f 00 0d 	mcall	8000419c <xnl_device_conn_reply_func+0x58>
8000416e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004172:	a9 68       	lsl	r8,0x8
80004174:	48 b9       	lddpc	r9,800041a0 <xnl_device_conn_reply_func+0x5c>
80004176:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004178:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000417c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000417e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004182:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004184:	30 18       	mov	r8,1
80004186:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004188:	48 7c       	lddpc	r12,800041a4 <xnl_device_conn_reply_func+0x60>
8000418a:	f0 1f 00 08 	mcall	800041a8 <xnl_device_conn_reply_func+0x64>
8000418e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004192:	00 00       	add	r0,r0
80004194:	00 00       	add	r0,r0
80004196:	0b 34       	ld.ub	r4,r5++
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	50 8c       	stdsp	sp[0x20],r12
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	40 e4       	lddsp	r4,sp[0x38]
800041a0:	00 00       	add	r0,r0
800041a2:	0b 38       	ld.ub	r8,r5++
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	cb bc       	rcall	8000431c <tc_init+0x58>
800041a8:	80 00       	ld.sh	r0,r0[0x0]
800041aa:	5c 7c       	castu.h	r12

800041ac <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800041ac:	fe 78 0c 00 	mov	r8,-62464
800041b0:	e0 69 03 07 	mov	r9,775
800041b4:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800041b6:	30 49       	mov	r9,4
800041b8:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800041ba:	71 59       	ld.w	r9,r8[0x54]
800041bc:	e2 19 00 80 	andl	r9,0x80,COH
800041c0:	cf d0       	breq	800041ba <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800041c2:	fe 78 0c 00 	mov	r8,-62464
800041c6:	30 59       	mov	r9,5
800041c8:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800041ca:	e0 69 01 0d 	mov	r9,269
800041ce:	ea 19 10 07 	orh	r9,0x1007
800041d2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800041d4:	71 59       	ld.w	r9,r8[0x54]
800041d6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800041da:	cf d0       	breq	800041d4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800041dc:	fe 78 0c 00 	mov	r8,-62464
800041e0:	fc 19 00 80 	movh	r9,0x80
800041e4:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800041e6:	34 0a       	mov	r10,64
800041e8:	fe 69 14 00 	mov	r9,-125952
800041ec:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800041ee:	30 69       	mov	r9,6
800041f0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800041f2:	30 19       	mov	r9,1
800041f4:	fe 68 10 00 	mov	r8,-126976
800041f8:	91 19       	st.w	r8[0x4],r9
}
800041fa:	5e fc       	retal	r12

800041fc <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
800041fc:	eb cd 40 c0 	pushm	r6-r7,lr
80004200:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004202:	f0 1f 00 1a 	mcall	80004268 <rtc_init+0x6c>
80004206:	49 a8       	lddpc	r8,8000426c <rtc_init+0x70>
80004208:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
8000420a:	70 08       	ld.w	r8,r8[0x0]
8000420c:	58 08       	cp.w	r8,0
8000420e:	c0 31       	brne	80004214 <rtc_init+0x18>
80004210:	30 3c       	mov	r12,3
80004212:	c2 78       	rjmp	80004260 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004214:	49 66       	lddpc	r6,8000426c <rtc_init+0x70>
80004216:	6c 0c       	ld.w	r12,r6[0x0]
80004218:	30 09       	mov	r9,0
8000421a:	3f fa       	mov	r10,-1
8000421c:	12 9b       	mov	r11,r9
8000421e:	f0 1f 00 15 	mcall	80004270 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004222:	30 2b       	mov	r11,2
80004224:	49 4c       	lddpc	r12,80004274 <rtc_init+0x78>
80004226:	f0 1f 00 15 	mcall	80004278 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
8000422a:	e0 68 36 00 	mov	r8,13824
8000422e:	ea 18 01 6e 	orh	r8,0x16e
80004232:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004234:	e2 78 0d 40 	mov	r8,200000
80004238:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
8000423a:	35 18       	mov	r8,81
8000423c:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004240:	1a 9b       	mov	r11,sp
80004242:	fe 7c 2c 00 	mov	r12,-54272
80004246:	f0 1f 00 0e 	mcall	8000427c <rtc_init+0x80>
8000424a:	48 e7       	lddpc	r7,80004280 <rtc_init+0x84>
8000424c:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
8000424e:	6c 0c       	ld.w	r12,r6[0x0]
80004250:	30 09       	mov	r9,0
80004252:	12 9a       	mov	r10,r9
80004254:	12 9b       	mov	r11,r9
80004256:	f0 1f 00 0c 	mcall	80004284 <rtc_init+0x88>
8000425a:	6e 08       	ld.w	r8,r7[0x0]
8000425c:	58 08       	cp.w	r8,0
8000425e:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004260:	2f dd       	sub	sp,-12
80004262:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004266:	00 00       	add	r0,r0
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	51 8c       	stdsp	sp[0x60],r12
8000426c:	00 00       	add	r0,r0
8000426e:	0b 60       	ld.uh	r0,--r5
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	4e 80       	lddpc	r0,80004410 <INTC_init_interrupts+0x48>
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	cb d0       	breq	800041f0 <local_start_pll0+0x44>
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	61 14       	ld.w	r4,r0[0x44]
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	47 0c       	lddsp	r12,sp[0x1c0]
80004280:	00 00       	add	r0,r0
80004282:	0b 5c       	ld.sh	r12,--r5
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	50 8c       	stdsp	sp[0x20],r12

80004288 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004288:	fe 78 10 00 	mov	r8,-61440
8000428c:	fc 19 00 10 	movh	r9,0x10
80004290:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004292:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004294:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004296:	30 39       	mov	r9,3
80004298:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
8000429c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800042a0:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800042a4:	fe 78 38 00 	mov	r8,-51200
800042a8:	30 49       	mov	r9,4
800042aa:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800042ae:	e0 69 91 0d 	mov	r9,37133
800042b2:	ea 19 00 52 	orh	r9,0x52
800042b6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800042b8:	32 09       	mov	r9,32
800042ba:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800042bc:	30 59       	mov	r9,5
800042be:	91 09       	st.w	r8[0x0],r9
}
800042c0:	5e fc       	retal	r12
800042c2:	d7 03       	nop

800042c4 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800042c4:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800042c6:	30 2a       	mov	r10,2
800042c8:	e0 6b 01 c1 	mov	r11,449
800042cc:	48 ec       	lddpc	r12,80004304 <tc_init+0x40>
800042ce:	f0 1f 00 0f 	mcall	80004308 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800042d2:	48 fb       	lddpc	r11,8000430c <tc_init+0x48>
800042d4:	fe 7c 38 00 	mov	r12,-51200
800042d8:	f0 1f 00 0e 	mcall	80004310 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800042dc:	e0 6a 75 30 	mov	r10,30000
800042e0:	30 1b       	mov	r11,1
800042e2:	fe 7c 38 00 	mov	r12,-51200
800042e6:	f0 1f 00 0c 	mcall	80004314 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800042ea:	48 ca       	lddpc	r10,80004318 <tc_init+0x54>
800042ec:	30 1b       	mov	r11,1
800042ee:	fe 7c 38 00 	mov	r12,-51200
800042f2:	f0 1f 00 0b 	mcall	8000431c <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800042f6:	30 1b       	mov	r11,1
800042f8:	fe 7c 38 00 	mov	r12,-51200
800042fc:	f0 1f 00 09 	mcall	80004320 <tc_init+0x5c>
80004300:	d8 02       	popm	pc
80004302:	00 00       	add	r0,r0
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	43 24       	lddsp	r4,sp[0xc8]
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	43 48       	lddsp	r8,sp[0xd0]
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	cb e4       	brge	8000428a <local_start_timer+0x2>
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	44 54       	lddsp	r4,sp[0x114]
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	45 14       	lddsp	r4,sp[0x144]
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	cb e0       	breq	80004296 <local_start_timer+0xe>
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	45 48       	lddsp	r8,sp[0x150]
80004320:	80 00       	ld.sh	r0,r0[0x0]
80004322:	44 f0       	lddsp	r0,sp[0x13c]

80004324 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004324:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004326:	48 68       	lddpc	r8,8000433c <_tc_interrupt+0x18>
80004328:	70 09       	ld.w	r9,r8[0x0]
8000432a:	2f f9       	sub	r9,-1
8000432c:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
8000432e:	30 1b       	mov	r11,1
80004330:	fe 7c 38 00 	mov	r12,-51200
80004334:	f0 1f 00 03 	mcall	80004340 <_tc_interrupt+0x1c>
	
}
80004338:	d4 02       	popm	lr
8000433a:	d6 03       	rete
8000433c:	00 00       	add	r0,r0
8000433e:	0b 64       	ld.uh	r4,--r5
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	45 02       	lddsp	r2,sp[0x140]

80004344 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004344:	c0 08       	rjmp	80004344 <_unhandled_interrupt>
80004346:	d7 03       	nop

80004348 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004348:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000434c:	49 99       	lddpc	r9,800043b0 <INTC_register_interrupt+0x68>
8000434e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004352:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004356:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004358:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000435c:	58 0a       	cp.w	r10,0
8000435e:	c0 91       	brne	80004370 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004360:	49 59       	lddpc	r9,800043b4 <INTC_register_interrupt+0x6c>
80004362:	49 6a       	lddpc	r10,800043b8 <INTC_register_interrupt+0x70>
80004364:	12 1a       	sub	r10,r9
80004366:	fe 79 08 00 	mov	r9,-63488
8000436a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000436e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004370:	58 1a       	cp.w	r10,1
80004372:	c0 a1       	brne	80004386 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004374:	49 09       	lddpc	r9,800043b4 <INTC_register_interrupt+0x6c>
80004376:	49 2a       	lddpc	r10,800043bc <INTC_register_interrupt+0x74>
80004378:	12 1a       	sub	r10,r9
8000437a:	bf aa       	sbr	r10,0x1e
8000437c:	fe 79 08 00 	mov	r9,-63488
80004380:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004384:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004386:	58 2a       	cp.w	r10,2
80004388:	c0 a1       	brne	8000439c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000438a:	48 b9       	lddpc	r9,800043b4 <INTC_register_interrupt+0x6c>
8000438c:	48 da       	lddpc	r10,800043c0 <INTC_register_interrupt+0x78>
8000438e:	12 1a       	sub	r10,r9
80004390:	bf ba       	sbr	r10,0x1f
80004392:	fe 79 08 00 	mov	r9,-63488
80004396:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000439a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000439c:	48 69       	lddpc	r9,800043b4 <INTC_register_interrupt+0x6c>
8000439e:	48 aa       	lddpc	r10,800043c4 <INTC_register_interrupt+0x7c>
800043a0:	12 1a       	sub	r10,r9
800043a2:	ea 1a c0 00 	orh	r10,0xc000
800043a6:	fe 79 08 00 	mov	r9,-63488
800043aa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800043ae:	5e fc       	retal	r12
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	cb ec       	rcall	8000452e <tc_write_rc+0x1a>
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	bc 00       	st.h	lr[0x0],r0
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	bd 04       	ld.d	r4,lr
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	bd 12       	ld.d	r2,--lr
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	bd 20       	st.d	lr++,r0
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	bd 2e       	st.d	lr++,lr

800043c8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800043c8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800043ca:	49 18       	lddpc	r8,8000440c <INTC_init_interrupts+0x44>
800043cc:	e3 b8 00 01 	mtsr	0x4,r8
800043d0:	49 0e       	lddpc	lr,80004410 <INTC_init_interrupts+0x48>
800043d2:	30 07       	mov	r7,0
800043d4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800043d6:	49 0c       	lddpc	r12,80004414 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800043d8:	49 05       	lddpc	r5,80004418 <INTC_init_interrupts+0x50>
800043da:	10 15       	sub	r5,r8
800043dc:	fe 76 08 00 	mov	r6,-63488
800043e0:	c1 08       	rjmp	80004400 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800043e2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800043e4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800043e6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800043e8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800043ec:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800043ee:	10 3a       	cp.w	r10,r8
800043f0:	fe 9b ff fc 	brhi	800043e8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800043f4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800043f8:	2f f7       	sub	r7,-1
800043fa:	2f 8e       	sub	lr,-8
800043fc:	59 37       	cp.w	r7,19
800043fe:	c0 50       	breq	80004408 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004400:	7c 08       	ld.w	r8,lr[0x0]
80004402:	58 08       	cp.w	r8,0
80004404:	ce f1       	brne	800043e2 <INTC_init_interrupts+0x1a>
80004406:	cf 7b       	rjmp	800043f4 <INTC_init_interrupts+0x2c>
80004408:	d8 22       	popm	r4-r7,pc
8000440a:	00 00       	add	r0,r0
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	bc 00       	st.h	lr[0x0],r0
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	cb ec       	rcall	8000458e <tc_configure_interrupts+0x46>
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	43 44       	lddsp	r4,sp[0xd0]
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	bd 04       	ld.d	r4,lr

8000441c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000441c:	fe 78 08 00 	mov	r8,-63488
80004420:	e0 69 00 83 	mov	r9,131
80004424:	f2 0c 01 0c 	sub	r12,r9,r12
80004428:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000442c:	f2 ca ff c0 	sub	r10,r9,-64
80004430:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004434:	58 08       	cp.w	r8,0
80004436:	c0 21       	brne	8000443a <_get_interrupt_handler+0x1e>
80004438:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000443a:	f0 08 12 00 	clz	r8,r8
8000443e:	48 5a       	lddpc	r10,80004450 <_get_interrupt_handler+0x34>
80004440:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004444:	f0 08 11 1f 	rsub	r8,r8,31
80004448:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000444a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000444e:	5e fc       	retal	r12
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	cb ec       	rcall	800045ce <tc_configure_interrupts+0x86>

80004454 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004454:	76 09       	ld.w	r9,r11[0x0]
80004456:	58 29       	cp.w	r9,2
80004458:	e0 88 00 03 	brls	8000445e <tc_init_waveform+0xa>
8000445c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000445e:	76 18       	ld.w	r8,r11[0x4]
80004460:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004464:	af ba       	sbr	r10,0xf
80004466:	10 9b       	mov	r11,r8
80004468:	e6 1b c0 00 	andh	r11,0xc000,COH
8000446c:	16 4a       	or	r10,r11
8000446e:	10 9b       	mov	r11,r8
80004470:	e6 1b 30 00 	andh	r11,0x3000,COH
80004474:	16 4a       	or	r10,r11
80004476:	10 9b       	mov	r11,r8
80004478:	e6 1b 0c 00 	andh	r11,0xc00,COH
8000447c:	16 4a       	or	r10,r11
8000447e:	10 9b       	mov	r11,r8
80004480:	e6 1b 03 00 	andh	r11,0x300,COH
80004484:	16 4a       	or	r10,r11
80004486:	10 9b       	mov	r11,r8
80004488:	e6 1b 00 c0 	andh	r11,0xc0,COH
8000448c:	16 4a       	or	r10,r11
8000448e:	10 9b       	mov	r11,r8
80004490:	e6 1b 00 30 	andh	r11,0x30,COH
80004494:	16 4a       	or	r10,r11
80004496:	10 9b       	mov	r11,r8
80004498:	e6 1b 00 0c 	andh	r11,0xc,COH
8000449c:	16 4a       	or	r10,r11
8000449e:	10 9b       	mov	r11,r8
800044a0:	e6 1b 00 03 	andh	r11,0x3,COH
800044a4:	16 4a       	or	r10,r11
800044a6:	10 9b       	mov	r11,r8
800044a8:	e2 1b 60 00 	andl	r11,0x6000,COH
800044ac:	16 4a       	or	r10,r11
800044ae:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
800044b2:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
800044b6:	10 9b       	mov	r11,r8
800044b8:	e2 1b 0c 00 	andl	r11,0xc00,COH
800044bc:	16 4a       	or	r10,r11
800044be:	10 9b       	mov	r11,r8
800044c0:	e2 1b 03 00 	andl	r11,0x300,COH
800044c4:	16 4a       	or	r10,r11
800044c6:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800044ca:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800044ce:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800044d2:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800044d6:	10 9b       	mov	r11,r8
800044d8:	e2 1b 00 30 	andl	r11,0x30,COH
800044dc:	16 4a       	or	r10,r11
800044de:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800044e2:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800044e6:	a5 69       	lsl	r9,0x4
800044e8:	2f f9       	sub	r9,-1
800044ea:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800044ee:	5e fd       	retal	0

800044f0 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800044f0:	58 2b       	cp.w	r11,2
800044f2:	e0 88 00 03 	brls	800044f8 <tc_start+0x8>
800044f6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800044f8:	a7 6b       	lsl	r11,0x6
800044fa:	16 0c       	add	r12,r11
800044fc:	30 58       	mov	r8,5
800044fe:	99 08       	st.w	r12[0x0],r8
80004500:	5e fd       	retal	0

80004502 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004502:	58 2b       	cp.w	r11,2
80004504:	e0 88 00 03 	brls	8000450a <tc_read_sr+0x8>
80004508:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
8000450a:	a7 6b       	lsl	r11,0x6
8000450c:	2e 0b       	sub	r11,-32
8000450e:	16 0c       	add	r12,r11
80004510:	78 0c       	ld.w	r12,r12[0x0]
}
80004512:	5e fc       	retal	r12

80004514 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004514:	58 2b       	cp.w	r11,2
80004516:	e0 88 00 03 	brls	8000451c <tc_write_rc+0x8>
8000451a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
8000451c:	f6 08 15 04 	lsl	r8,r11,0x4
80004520:	2f f8       	sub	r8,-1
80004522:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004526:	e2 18 80 00 	andl	r8,0x8000,COH
8000452a:	c0 c0       	breq	80004542 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
8000452c:	a7 6b       	lsl	r11,0x6
8000452e:	16 0c       	add	r12,r11
80004530:	2e 4c       	sub	r12,-28
80004532:	78 08       	ld.w	r8,r12[0x0]
80004534:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004538:	e0 18 00 00 	andl	r8,0x0
8000453c:	f3 e8 10 08 	or	r8,r9,r8
80004540:	99 08       	st.w	r12[0x0],r8

  return value;
80004542:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004546:	5e fc       	retal	r12

80004548 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004548:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000454c:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004550:	58 2b       	cp.w	r11,2
80004552:	e0 88 00 04 	brls	8000455a <tc_configure_interrupts+0x12>
80004556:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
8000455a:	ee 19 00 01 	eorh	r9,0x1
8000455e:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004562:	74 08       	ld.w	r8,r10[0x0]
80004564:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004568:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
8000456c:	a7 6e       	lsl	lr,0x6
8000456e:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004572:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004576:	0e 4e       	or	lr,r7
80004578:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
8000457c:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004580:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004584:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004588:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
8000458c:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004590:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004594:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004598:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000459c:	fd e8 10 18 	or	r8,lr,r8<<0x1
800045a0:	f6 0e 15 06 	lsl	lr,r11,0x6
800045a4:	f8 0e 00 0e 	add	lr,r12,lr
800045a8:	2d ce       	sub	lr,-36
800045aa:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800045ac:	58 09       	cp.w	r9,0
800045ae:	c0 20       	breq	800045b2 <tc_configure_interrupts+0x6a>
800045b0:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800045b2:	74 08       	ld.w	r8,r10[0x0]
800045b4:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800045b8:	e0 65 00 80 	mov	r5,128
800045bc:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
800045c0:	74 08       	ld.w	r8,r10[0x0]
800045c2:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800045c6:	f9 b4 00 40 	moveq	r4,64
800045ca:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
800045ce:	74 08       	ld.w	r8,r10[0x0]
800045d0:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800045d4:	f9 b3 00 20 	moveq	r3,32
800045d8:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800045dc:	74 08       	ld.w	r8,r10[0x0]
800045de:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800045e2:	f9 b2 00 10 	moveq	r2,16
800045e6:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800045ea:	74 08       	ld.w	r8,r10[0x0]
800045ec:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800045f0:	f9 b6 00 08 	moveq	r6,8
800045f4:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800045f8:	74 08       	ld.w	r8,r10[0x0]
800045fa:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800045fe:	f9 b7 00 04 	moveq	r7,4
80004602:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004606:	74 08       	ld.w	r8,r10[0x0]
80004608:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000460c:	f9 be 00 02 	moveq	lr,2
80004610:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004614:	74 08       	ld.w	r8,r10[0x0]
80004616:	ec 18 00 01 	eorl	r8,0x1
8000461a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000461e:	eb e8 10 08 	or	r8,r5,r8
80004622:	08 48       	or	r8,r4
80004624:	06 48       	or	r8,r3
80004626:	04 48       	or	r8,r2
80004628:	0c 48       	or	r8,r6
8000462a:	0e 48       	or	r8,r7
8000462c:	1c 48       	or	r8,lr
8000462e:	f6 0a 15 06 	lsl	r10,r11,0x6
80004632:	f8 0a 00 0a 	add	r10,r12,r10
80004636:	2d 8a       	sub	r10,-40
80004638:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
8000463a:	a7 6b       	lsl	r11,0x6
8000463c:	2e 0b       	sub	r11,-32
8000463e:	16 0c       	add	r12,r11
80004640:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004642:	58 09       	cp.w	r9,0
80004644:	c0 31       	brne	8000464a <tc_configure_interrupts+0x102>
80004646:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000464a:	d5 03       	csrf	0x10
8000464c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004650 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004650:	4a 78       	lddpc	r8,800046ec <twi_master_interrupt_handler+0x9c>
80004652:	70 08       	ld.w	r8,r8[0x0]
80004654:	70 89       	ld.w	r9,r8[0x20]
80004656:	4a 7a       	lddpc	r10,800046f0 <twi_master_interrupt_handler+0xa0>
80004658:	74 0a       	ld.w	r10,r10[0x0]
8000465a:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
8000465e:	12 9a       	mov	r10,r9
80004660:	e2 1a 01 00 	andl	r10,0x100,COH
80004664:	c3 91       	brne	800046d6 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004666:	12 9a       	mov	r10,r9
80004668:	e2 1a 00 02 	andl	r10,0x2,COH
8000466c:	c1 70       	breq	8000469a <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
8000466e:	4a 29       	lddpc	r9,800046f4 <twi_master_interrupt_handler+0xa4>
80004670:	72 0a       	ld.w	r10,r9[0x0]
80004672:	70 cb       	ld.w	r11,r8[0x30]
80004674:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004676:	72 0a       	ld.w	r10,r9[0x0]
80004678:	2f fa       	sub	r10,-1
8000467a:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
8000467c:	49 f9       	lddpc	r9,800046f8 <twi_master_interrupt_handler+0xa8>
8000467e:	72 0a       	ld.w	r10,r9[0x0]
80004680:	20 1a       	sub	r10,1
80004682:	93 0a       	st.w	r9[0x0],r10
80004684:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004686:	58 19       	cp.w	r9,1
80004688:	f9 b9 00 02 	moveq	r9,2
8000468c:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004690:	49 a9       	lddpc	r9,800046f8 <twi_master_interrupt_handler+0xa8>
80004692:	72 09       	ld.w	r9,r9[0x0]
80004694:	58 09       	cp.w	r9,0
80004696:	c2 30       	breq	800046dc <twi_master_interrupt_handler+0x8c>
80004698:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
8000469a:	12 9a       	mov	r10,r9
8000469c:	e2 1a 00 04 	andl	r10,0x4,COH
800046a0:	c1 70       	breq	800046ce <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800046a2:	49 79       	lddpc	r9,800046fc <twi_master_interrupt_handler+0xac>
800046a4:	72 0a       	ld.w	r10,r9[0x0]
800046a6:	20 1a       	sub	r10,1
800046a8:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800046aa:	72 09       	ld.w	r9,r9[0x0]
800046ac:	58 09       	cp.w	r9,0
800046ae:	e0 89 00 0a 	brgt	800046c2 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800046b2:	49 09       	lddpc	r9,800046f0 <twi_master_interrupt_handler+0xa0>
800046b4:	30 1a       	mov	r10,1
800046b6:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
800046b8:	3f fa       	mov	r10,-1
800046ba:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
800046bc:	72 09       	ld.w	r9,r9[0x0]
800046be:	91 99       	st.w	r8[0x24],r9
800046c0:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
800046c2:	49 0a       	lddpc	r10,80004700 <twi_master_interrupt_handler+0xb0>
800046c4:	74 09       	ld.w	r9,r10[0x0]
800046c6:	13 3b       	ld.ub	r11,r9++
800046c8:	91 db       	st.w	r8[0x34],r11
800046ca:	95 09       	st.w	r10[0x0],r9
800046cc:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
800046ce:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800046d2:	c0 51       	brne	800046dc <twi_master_interrupt_handler+0x8c>
800046d4:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
800046d6:	30 1a       	mov	r10,1
800046d8:	48 b9       	lddpc	r9,80004704 <twi_master_interrupt_handler+0xb4>
800046da:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
800046dc:	3f f9       	mov	r9,-1
800046de:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
800046e0:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
800046e2:	30 09       	mov	r9,0
800046e4:	48 98       	lddpc	r8,80004708 <twi_master_interrupt_handler+0xb8>
800046e6:	b0 89       	st.b	r8[0x0],r9
800046e8:	d6 03       	rete
800046ea:	00 00       	add	r0,r0
800046ec:	00 00       	add	r0,r0
800046ee:	0c 1c       	sub	r12,r6
800046f0:	00 00       	add	r0,r0
800046f2:	0c 18       	sub	r8,r6
800046f4:	00 00       	add	r0,r0
800046f6:	0c 28       	rsub	r8,r6
800046f8:	00 00       	add	r0,r0
800046fa:	0c 24       	rsub	r4,r6
800046fc:	00 00       	add	r0,r0
800046fe:	0c 14       	sub	r4,r6
80004700:	00 00       	add	r0,r0
80004702:	0c 20       	rsub	r0,r6
80004704:	00 00       	add	r0,r0
80004706:	0c 11       	sub	r1,r6
80004708:	00 00       	add	r0,r0
8000470a:	0c 10       	sub	r0,r6

8000470c <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
8000470c:	eb cd 40 e0 	pushm	r5-r7,lr
80004710:	18 97       	mov	r7,r12
80004712:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004714:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004718:	49 f9       	lddpc	r9,80004794 <twi_master_init+0x88>
8000471a:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
8000471c:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
8000471e:	3f f9       	mov	r9,-1
80004720:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004722:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004724:	e0 69 00 80 	mov	r9,128
80004728:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000472a:	e6 18 00 01 	andh	r8,0x1,COH
8000472e:	c0 21       	brne	80004732 <twi_master_init+0x26>
      cpu_irq_enable();
80004730:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004732:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004734:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004738:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
8000473a:	30 3a       	mov	r10,3
8000473c:	e0 6b 01 60 	mov	r11,352
80004740:	49 6c       	lddpc	r12,80004798 <twi_master_init+0x8c>
80004742:	f0 1f 00 17 	mcall	8000479c <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004746:	e6 16 00 01 	andh	r6,0x1,COH
8000474a:	c0 21       	brne	8000474e <twi_master_init+0x42>
      cpu_irq_enable();
8000474c:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
8000474e:	6a 19       	ld.w	r9,r5[0x4]
80004750:	a1 79       	lsl	r9,0x1
80004752:	6a 08       	ld.w	r8,r5[0x0]
80004754:	f0 09 0d 08 	divu	r8,r8,r9
80004758:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000475a:	e0 48 00 ff 	cp.w	r8,255
8000475e:	e0 8b 00 04 	brhi	80004766 <twi_master_init+0x5a>
80004762:	30 09       	mov	r9,0
80004764:	c0 f8       	rjmp	80004782 <twi_master_init+0x76>
80004766:	30 09       	mov	r9,0
80004768:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
8000476a:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
8000476c:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000476e:	e0 48 00 ff 	cp.w	r8,255
80004772:	5f bb       	srhi	r11
80004774:	58 69       	cp.w	r9,6
80004776:	5f 8a       	srls	r10
80004778:	f7 ea 00 0a 	and	r10,r11,r10
8000477c:	f8 0a 18 00 	cp.b	r10,r12
80004780:	cf 51       	brne	8000476a <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004782:	b1 69       	lsl	r9,0x10
80004784:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004788:	f3 e8 10 08 	or	r8,r9,r8
8000478c:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
8000478e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004792:	00 00       	add	r0,r0
80004794:	00 00       	add	r0,r0
80004796:	0c 1c       	sub	r12,r6
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	46 50       	lddsp	r0,sp[0x194]
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	43 48       	lddsp	r8,sp[0xd0]

800047a0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800047a0:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800047a2:	f6 08 15 04 	lsl	r8,r11,0x4
800047a6:	14 38       	cp.w	r8,r10
800047a8:	f9 b8 08 10 	movls	r8,16
800047ac:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800047b0:	f0 0b 02 4b 	mul	r11,r8,r11
800047b4:	f6 09 16 01 	lsr	r9,r11,0x1
800047b8:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800047bc:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800047c0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800047c4:	f2 cb 00 01 	sub	r11,r9,1
800047c8:	e0 4b ff fe 	cp.w	r11,65534
800047cc:	e0 88 00 03 	brls	800047d2 <usart_set_async_baudrate+0x32>
800047d0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800047d2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800047d4:	e8 6e 00 00 	mov	lr,524288
800047d8:	59 08       	cp.w	r8,16
800047da:	fc 08 17 10 	movne	r8,lr
800047de:	f9 b8 00 00 	moveq	r8,0
800047e2:	e4 1b ff f7 	andh	r11,0xfff7
800047e6:	e0 1b fe cf 	andl	r11,0xfecf
800047ea:	16 48       	or	r8,r11
800047ec:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800047ee:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800047f2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800047f6:	99 89       	st.w	r12[0x20],r9
800047f8:	d8 0a       	popm	pc,r12=0

800047fa <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800047fa:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800047fc:	e2 18 00 02 	andl	r8,0x2,COH
80004800:	c0 31       	brne	80004806 <usart_write_char+0xc>
80004802:	30 2c       	mov	r12,2
80004804:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004806:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000480a:	99 7b       	st.w	r12[0x1c],r11
8000480c:	5e fd       	retal	0
8000480e:	d7 03       	nop

80004810 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004810:	eb cd 40 e0 	pushm	r5-r7,lr
80004814:	18 96       	mov	r6,r12
80004816:	16 95       	mov	r5,r11
80004818:	e0 67 27 0f 	mov	r7,9999
8000481c:	c0 68       	rjmp	80004828 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000481e:	58 07       	cp.w	r7,0
80004820:	c0 31       	brne	80004826 <usart_putchar+0x16>
80004822:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004826:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004828:	0a 9b       	mov	r11,r5
8000482a:	0c 9c       	mov	r12,r6
8000482c:	f0 1f 00 03 	mcall	80004838 <usart_putchar+0x28>
80004830:	cf 71       	brne	8000481e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004832:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004836:	00 00       	add	r0,r0
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	47 fa       	lddsp	r10,sp[0x1fc]

8000483c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000483c:	78 58       	ld.w	r8,r12[0x14]
8000483e:	e2 18 00 e0 	andl	r8,0xe0,COH
80004842:	c0 30       	breq	80004848 <usart_read_char+0xc>
80004844:	30 4c       	mov	r12,4
80004846:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004848:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000484a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000484e:	c0 31       	brne	80004854 <usart_read_char+0x18>
80004850:	30 3c       	mov	r12,3
80004852:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004854:	78 68       	ld.w	r8,r12[0x18]
80004856:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000485a:	97 08       	st.w	r11[0x0],r8
8000485c:	5e fd       	retal	0
8000485e:	d7 03       	nop

80004860 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004860:	eb cd 40 c0 	pushm	r6-r7,lr
80004864:	20 1d       	sub	sp,4
80004866:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004868:	1a 97       	mov	r7,sp
8000486a:	1a 9b       	mov	r11,sp
8000486c:	0c 9c       	mov	r12,r6
8000486e:	f0 1f 00 07 	mcall	80004888 <usart_getchar+0x28>
80004872:	58 3c       	cp.w	r12,3
80004874:	cf b0       	breq	8000486a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004876:	58 4c       	cp.w	r12,4
80004878:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000487c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004880:	2f fd       	sub	sp,-4
80004882:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004886:	00 00       	add	r0,r0
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	48 3c       	lddpc	r12,80004894 <usart_write_line+0x8>

8000488c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000488c:	eb cd 40 c0 	pushm	r6-r7,lr
80004890:	18 96       	mov	r6,r12
80004892:	16 97       	mov	r7,r11
  while (*string != '\0')
80004894:	17 8b       	ld.ub	r11,r11[0x0]
80004896:	58 0b       	cp.w	r11,0
80004898:	c0 80       	breq	800048a8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000489a:	2f f7       	sub	r7,-1
8000489c:	0c 9c       	mov	r12,r6
8000489e:	f0 1f 00 04 	mcall	800048ac <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800048a2:	0f 8b       	ld.ub	r11,r7[0x0]
800048a4:	58 0b       	cp.w	r11,0
800048a6:	cf a1       	brne	8000489a <usart_write_line+0xe>
800048a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	48 10       	lddpc	r0,800048b0 <usart_reset>

800048b0 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800048b0:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800048b4:	e6 18 00 01 	andh	r8,0x1,COH
800048b8:	c0 71       	brne	800048c6 <usart_reset+0x16>
800048ba:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800048bc:	3f f8       	mov	r8,-1
800048be:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800048c0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800048c2:	d5 03       	csrf	0x10
800048c4:	c0 48       	rjmp	800048cc <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800048c6:	3f f8       	mov	r8,-1
800048c8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800048ca:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800048cc:	30 08       	mov	r8,0
800048ce:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800048d0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800048d2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800048d4:	ea 68 61 0c 	mov	r8,680204
800048d8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800048da:	5e fc       	retal	r12

800048dc <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800048dc:	eb cd 40 e0 	pushm	r5-r7,lr
800048e0:	18 96       	mov	r6,r12
800048e2:	16 97       	mov	r7,r11
800048e4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800048e6:	f0 1f 00 2f 	mcall	800049a0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800048ea:	58 07       	cp.w	r7,0
800048ec:	c5 80       	breq	8000499c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800048ee:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800048f0:	30 49       	mov	r9,4
800048f2:	f2 08 18 00 	cp.b	r8,r9
800048f6:	e0 88 00 53 	brls	8000499c <usart_init_rs232+0xc0>
800048fa:	30 99       	mov	r9,9
800048fc:	f2 08 18 00 	cp.b	r8,r9
80004900:	e0 8b 00 4e 	brhi	8000499c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004904:	0f d9       	ld.ub	r9,r7[0x5]
80004906:	30 78       	mov	r8,7
80004908:	f0 09 18 00 	cp.b	r9,r8
8000490c:	e0 8b 00 48 	brhi	8000499c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004910:	8e 39       	ld.sh	r9,r7[0x6]
80004912:	e0 68 01 01 	mov	r8,257
80004916:	f0 09 19 00 	cp.h	r9,r8
8000491a:	e0 8b 00 41 	brhi	8000499c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000491e:	ef 39 00 08 	ld.ub	r9,r7[8]
80004922:	30 38       	mov	r8,3
80004924:	f0 09 18 00 	cp.b	r9,r8
80004928:	e0 8b 00 3a 	brhi	8000499c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000492c:	0a 9a       	mov	r10,r5
8000492e:	6e 0b       	ld.w	r11,r7[0x0]
80004930:	0c 9c       	mov	r12,r6
80004932:	f0 1f 00 1d 	mcall	800049a4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004936:	58 1c       	cp.w	r12,1
80004938:	c3 20       	breq	8000499c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000493a:	0f c8       	ld.ub	r8,r7[0x4]
8000493c:	30 99       	mov	r9,9
8000493e:	f2 08 18 00 	cp.b	r8,r9
80004942:	c0 51       	brne	8000494c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004944:	6c 18       	ld.w	r8,r6[0x4]
80004946:	b1 b8       	sbr	r8,0x11
80004948:	8d 18       	st.w	r6[0x4],r8
8000494a:	c0 68       	rjmp	80004956 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
8000494c:	6c 19       	ld.w	r9,r6[0x4]
8000494e:	20 58       	sub	r8,5
80004950:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004954:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004956:	6c 19       	ld.w	r9,r6[0x4]
80004958:	ef 3a 00 08 	ld.ub	r10,r7[8]
8000495c:	0f d8       	ld.ub	r8,r7[0x5]
8000495e:	a9 78       	lsl	r8,0x9
80004960:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004964:	12 48       	or	r8,r9
80004966:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004968:	8e 38       	ld.sh	r8,r7[0x6]
8000496a:	30 29       	mov	r9,2
8000496c:	f2 08 19 00 	cp.h	r8,r9
80004970:	e0 88 00 09 	brls	80004982 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004974:	6c 18       	ld.w	r8,r6[0x4]
80004976:	ad b8       	sbr	r8,0xd
80004978:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000497a:	8e b8       	ld.uh	r8,r7[0x6]
8000497c:	20 28       	sub	r8,2
8000497e:	8d a8       	st.w	r6[0x28],r8
80004980:	c0 68       	rjmp	8000498c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004982:	6c 19       	ld.w	r9,r6[0x4]
80004984:	5c 78       	castu.h	r8
80004986:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000498a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000498c:	6c 18       	ld.w	r8,r6[0x4]
8000498e:	e0 18 ff f0 	andl	r8,0xfff0
80004992:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004994:	35 08       	mov	r8,80
80004996:	8d 08       	st.w	r6[0x0],r8
80004998:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000499c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	48 b0       	lddpc	r0,800049cc <vListInsertEnd+0xa>
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	47 a0       	lddsp	r0,sp[0x1e8]

800049a8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800049a8:	f8 c8 ff f8 	sub	r8,r12,-8
800049ac:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800049ae:	3f f9       	mov	r9,-1
800049b0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800049b2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800049b4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800049b6:	30 08       	mov	r8,0
800049b8:	99 08       	st.w	r12[0x0],r8
}
800049ba:	5e fc       	retal	r12

800049bc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800049bc:	30 08       	mov	r8,0
800049be:	99 48       	st.w	r12[0x10],r8
}
800049c0:	5e fc       	retal	r12

800049c2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800049c2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800049c4:	70 19       	ld.w	r9,r8[0x4]
800049c6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800049c8:	78 19       	ld.w	r9,r12[0x4]
800049ca:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800049cc:	70 19       	ld.w	r9,r8[0x4]
800049ce:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800049d0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800049d2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800049d4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800049d6:	78 08       	ld.w	r8,r12[0x0]
800049d8:	2f f8       	sub	r8,-1
800049da:	99 08       	st.w	r12[0x0],r8
}
800049dc:	5e fc       	retal	r12

800049de <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800049de:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800049e0:	5b fa       	cp.w	r10,-1
800049e2:	c0 31       	brne	800049e8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800049e4:	78 48       	ld.w	r8,r12[0x10]
800049e6:	c0 c8       	rjmp	800049fe <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800049e8:	f8 c8 ff f8 	sub	r8,r12,-8
800049ec:	70 19       	ld.w	r9,r8[0x4]
800049ee:	72 09       	ld.w	r9,r9[0x0]
800049f0:	12 3a       	cp.w	r10,r9
800049f2:	c0 63       	brcs	800049fe <vListInsert+0x20>
800049f4:	70 18       	ld.w	r8,r8[0x4]
800049f6:	70 19       	ld.w	r9,r8[0x4]
800049f8:	72 09       	ld.w	r9,r9[0x0]
800049fa:	12 3a       	cp.w	r10,r9
800049fc:	cf c2       	brcc	800049f4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800049fe:	70 19       	ld.w	r9,r8[0x4]
80004a00:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004a02:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004a04:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004a06:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004a08:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004a0a:	78 08       	ld.w	r8,r12[0x0]
80004a0c:	2f f8       	sub	r8,-1
80004a0e:	99 08       	st.w	r12[0x0],r8
}
80004a10:	5e fc       	retal	r12

80004a12 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004a12:	78 18       	ld.w	r8,r12[0x4]
80004a14:	78 29       	ld.w	r9,r12[0x8]
80004a16:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004a18:	78 28       	ld.w	r8,r12[0x8]
80004a1a:	78 19       	ld.w	r9,r12[0x4]
80004a1c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004a1e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004a20:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004a22:	18 39       	cp.w	r9,r12
80004a24:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004a28:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004a2c:	30 09       	mov	r9,0
80004a2e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004a30:	70 09       	ld.w	r9,r8[0x0]
80004a32:	20 19       	sub	r9,1
80004a34:	91 09       	st.w	r8[0x0],r9
}
80004a36:	5e fc       	retal	r12

80004a38 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004a38:	e0 68 08 08 	mov	r8,2056
80004a3c:	ea 18 08 08 	orh	r8,0x808
80004a40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004a42:	e0 68 09 09 	mov	r8,2313
80004a46:	ea 18 09 09 	orh	r8,0x909
80004a4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004a4c:	e0 68 0a 0a 	mov	r8,2570
80004a50:	ea 18 0a 0a 	orh	r8,0xa0a
80004a54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004a56:	e0 68 0b 0b 	mov	r8,2827
80004a5a:	ea 18 0b 0b 	orh	r8,0xb0b
80004a5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004a60:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004a62:	e0 68 be ef 	mov	r8,48879
80004a66:	ea 18 de ad 	orh	r8,0xdead
80004a6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004a6c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004a6e:	fc 18 00 40 	movh	r8,0x40
80004a72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004a74:	e0 68 00 ff 	mov	r8,255
80004a78:	ea 18 ff 00 	orh	r8,0xff00
80004a7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004a7e:	e0 68 01 01 	mov	r8,257
80004a82:	ea 18 01 01 	orh	r8,0x101
80004a86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004a88:	e0 68 02 02 	mov	r8,514
80004a8c:	ea 18 02 02 	orh	r8,0x202
80004a90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004a92:	e0 68 03 03 	mov	r8,771
80004a96:	ea 18 03 03 	orh	r8,0x303
80004a9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004a9c:	e0 68 04 04 	mov	r8,1028
80004aa0:	ea 18 04 04 	orh	r8,0x404
80004aa4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004aa6:	e0 68 05 05 	mov	r8,1285
80004aaa:	ea 18 05 05 	orh	r8,0x505
80004aae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004ab0:	e0 68 06 06 	mov	r8,1542
80004ab4:	ea 18 06 06 	orh	r8,0x606
80004ab8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004aba:	e0 68 07 07 	mov	r8,1799
80004abe:	ea 18 07 07 	orh	r8,0x707
80004ac2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004ac4:	30 08       	mov	r8,0
80004ac6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004ac8:	5e fc       	retal	r12
80004aca:	d7 03       	nop

80004acc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004acc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004ace:	48 38       	lddpc	r8,80004ad8 <vPortEnterCritical+0xc>
80004ad0:	70 09       	ld.w	r9,r8[0x0]
80004ad2:	2f f9       	sub	r9,-1
80004ad4:	91 09       	st.w	r8[0x0],r9
}
80004ad6:	5e fc       	retal	r12
80004ad8:	00 00       	add	r0,r0
80004ada:	05 30       	ld.ub	r0,r2++

80004adc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004adc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004ade:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004ae0:	30 0a       	mov	r10,0
80004ae2:	14 9b       	mov	r11,r10
80004ae4:	49 2c       	lddpc	r12,80004b2c <xPortStartScheduler+0x50>
80004ae6:	f0 1f 00 13 	mcall	80004b30 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004aea:	e0 68 5d c0 	mov	r8,24000
80004aee:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004af2:	30 08       	mov	r8,0
80004af4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004af8:	e0 68 0c fc 	mov	r8,3324
80004afc:	ea 18 00 00 	orh	r8,0x0
80004b00:	70 00       	ld.w	r0,r8[0x0]
80004b02:	60 0d       	ld.w	sp,r0[0x0]
80004b04:	1b 00       	ld.w	r0,sp++
80004b06:	e0 68 05 30 	mov	r8,1328
80004b0a:	ea 18 00 00 	orh	r8,0x0
80004b0e:	91 00       	st.w	r8[0x0],r0
80004b10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004b14:	2f ed       	sub	sp,-8
80004b16:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004b1a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004b1e:	e3 b0 00 00 	mtsr	0x0,r0
80004b22:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004b26:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004b2a:	d8 0a       	popm	pc,r12=0
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	4b f8       	lddpc	r8,80004c28 <LABEL_INT_SKIP_SAVE_CONTEXT_237+0x8>
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	43 48       	lddsp	r8,sp[0xd0]

80004b34 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004b34:	20 6d       	sub	sp,24
80004b36:	eb cd 00 ff 	pushm	r0-r7
80004b3a:	fa c7 ff c0 	sub	r7,sp,-64
80004b3e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004b42:	ef 40 ff e0 	st.w	r7[-32],r0
80004b46:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004b4a:	ef 40 ff e4 	st.w	r7[-28],r0
80004b4e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004b52:	e0 68 05 30 	mov	r8,1328
80004b56:	ea 18 00 00 	orh	r8,0x0
80004b5a:	70 00       	ld.w	r0,r8[0x0]
80004b5c:	1a d0       	st.w	--sp,r0
80004b5e:	f0 1f 00 1a 	mcall	80004bc4 <LABEL_RET_SCALL_263+0x14>
80004b62:	e0 68 0c fc 	mov	r8,3324
80004b66:	ea 18 00 00 	orh	r8,0x0
80004b6a:	70 00       	ld.w	r0,r8[0x0]
80004b6c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004b6e:	f0 1f 00 17 	mcall	80004bc8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004b72:	e0 68 0c fc 	mov	r8,3324
80004b76:	ea 18 00 00 	orh	r8,0x0
80004b7a:	70 00       	ld.w	r0,r8[0x0]
80004b7c:	60 0d       	ld.w	sp,r0[0x0]
80004b7e:	1b 00       	ld.w	r0,sp++
80004b80:	e0 68 05 30 	mov	r8,1328
80004b84:	ea 18 00 00 	orh	r8,0x0
80004b88:	91 00       	st.w	r8[0x0],r0
80004b8a:	fa c7 ff d8 	sub	r7,sp,-40
80004b8e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004b92:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004b96:	e0 61 05 30 	mov	r1,1328
80004b9a:	ea 11 00 00 	orh	r1,0x0
80004b9e:	62 02       	ld.w	r2,r1[0x0]
80004ba0:	58 02       	cp.w	r2,0
80004ba2:	c0 70       	breq	80004bb0 <LABEL_RET_SCALL_263>
80004ba4:	e4 c2 00 01 	sub	r2,r2,1
80004ba8:	83 02       	st.w	r1[0x0],r2
80004baa:	58 02       	cp.w	r2,0
80004bac:	c0 21       	brne	80004bb0 <LABEL_RET_SCALL_263>
80004bae:	b1 c0       	cbr	r0,0x10

80004bb0 <LABEL_RET_SCALL_263>:
80004bb0:	ef 40 ff f8 	st.w	r7[-8],r0
80004bb4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004bb8:	ef 40 ff fc 	st.w	r7[-4],r0
80004bbc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004bc0:	2f ad       	sub	sp,-24
80004bc2:	d6 13       	rets
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	4a cc       	lddpc	r12,80004c74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	52 68       	stdsp	sp[0x98],r8

80004bcc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004bcc:	e1 b8 00 43 	mfsr	r8,0x10c
80004bd0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004bd4:	5e fc       	retal	r12
80004bd6:	d7 03       	nop

80004bd8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004bd8:	48 78       	lddpc	r8,80004bf4 <vPortExitCritical+0x1c>
80004bda:	70 08       	ld.w	r8,r8[0x0]
80004bdc:	58 08       	cp.w	r8,0
80004bde:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004be0:	48 58       	lddpc	r8,80004bf4 <vPortExitCritical+0x1c>
80004be2:	70 09       	ld.w	r9,r8[0x0]
80004be4:	20 19       	sub	r9,1
80004be6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004be8:	70 08       	ld.w	r8,r8[0x0]
80004bea:	58 08       	cp.w	r8,0
80004bec:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004bee:	d5 03       	csrf	0x10
80004bf0:	5e fc       	retal	r12
80004bf2:	00 00       	add	r0,r0
80004bf4:	00 00       	add	r0,r0
80004bf6:	05 30       	ld.ub	r0,r2++

80004bf8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004bf8:	eb cd 00 ff 	pushm	r0-r7
80004bfc:	e0 68 05 30 	mov	r8,1328
80004c00:	ea 18 00 00 	orh	r8,0x0
80004c04:	70 00       	ld.w	r0,r8[0x0]
80004c06:	1a d0       	st.w	--sp,r0
80004c08:	7a 90       	ld.w	r0,sp[0x24]
80004c0a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004c0e:	58 10       	cp.w	r0,1
80004c10:	e0 8b 00 08 	brhi	80004c20 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004c14:	e0 68 0c fc 	mov	r8,3324
80004c18:	ea 18 00 00 	orh	r8,0x0
80004c1c:	70 00       	ld.w	r0,r8[0x0]
80004c1e:	81 0d       	st.w	r0[0x0],sp

80004c20 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004c20:	f0 1f 00 12 	mcall	80004c68 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004c24:	f0 1f 00 12 	mcall	80004c6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004c28:	f0 1f 00 12 	mcall	80004c70 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004c2c:	f0 1f 00 12 	mcall	80004c74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004c30:	7a 90       	ld.w	r0,sp[0x24]
80004c32:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004c36:	58 10       	cp.w	r0,1
80004c38:	e0 8b 00 0e 	brhi	80004c54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004c3c:	f0 1f 00 0c 	mcall	80004c6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004c40:	f0 1f 00 0e 	mcall	80004c78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004c44:	f0 1f 00 0c 	mcall	80004c74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004c48:	e0 68 0c fc 	mov	r8,3324
80004c4c:	ea 18 00 00 	orh	r8,0x0
80004c50:	70 00       	ld.w	r0,r8[0x0]
80004c52:	60 0d       	ld.w	sp,r0[0x0]

80004c54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004c54:	1b 00       	ld.w	r0,sp++
80004c56:	e0 68 05 30 	mov	r8,1328
80004c5a:	ea 18 00 00 	orh	r8,0x0
80004c5e:	91 00       	st.w	r8[0x0],r0
80004c60:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004c64:	d6 03       	rete
80004c66:	00 00       	add	r0,r0
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	4b cc       	lddpc	r12,80004d58 <pvPortMalloc+0x20>
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	4a cc       	lddpc	r12,80004d1c <vPortFree+0xc>
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	54 6c       	stdsp	sp[0x118],r12
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	4b d8       	lddpc	r8,80004d68 <prvCopyDataFromQueue+0x8>
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	52 68       	stdsp	sp[0x98],r8

80004c7c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004c7c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004c7e:	f0 1f 00 02 	mcall	80004c84 <__malloc_lock+0x8>
}
80004c82:	d8 02       	popm	pc
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	52 58       	stdsp	sp[0x94],r8

80004c88 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004c88:	d4 01       	pushm	lr
	xTaskResumeAll();
80004c8a:	f0 1f 00 02 	mcall	80004c90 <__malloc_unlock+0x8>
}
80004c8e:	d8 02       	popm	pc
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	56 14       	stdsp	sp[0x184],r4

80004c94 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004c94:	d4 21       	pushm	r4-r7,lr
80004c96:	16 95       	mov	r5,r11
80004c98:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004c9a:	58 0c       	cp.w	r12,0
80004c9c:	c0 30       	breq	80004ca2 <_read+0xe>
80004c9e:	3f f7       	mov	r7,-1
80004ca0:	c1 48       	rjmp	80004cc8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004ca2:	58 0a       	cp.w	r10,0
80004ca4:	e0 89 00 04 	brgt	80004cac <_read+0x18>
80004ca8:	30 07       	mov	r7,0
80004caa:	c0 f8       	rjmp	80004cc8 <_read+0x34>
80004cac:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004cae:	48 84       	lddpc	r4,80004ccc <_read+0x38>
80004cb0:	68 0c       	ld.w	r12,r4[0x0]
80004cb2:	f0 1f 00 08 	mcall	80004cd0 <_read+0x3c>
    if (c < 0)
80004cb6:	c0 95       	brlt	80004cc8 <_read+0x34>
      break;

    *ptr++ = c;
80004cb8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004cbc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004cbe:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004cc2:	58 08       	cp.w	r8,0
80004cc4:	fe 99 ff f6 	brgt	80004cb0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004cc8:	0e 9c       	mov	r12,r7
80004cca:	d8 22       	popm	r4-r7,pc
80004ccc:	00 00       	add	r0,r0
80004cce:	41 08       	lddsp	r8,sp[0x40]
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	48 60       	lddpc	r0,80004ce8 <_write+0x14>

80004cd4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004cd4:	d4 21       	pushm	r4-r7,lr
80004cd6:	16 95       	mov	r5,r11
80004cd8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004cda:	20 1c       	sub	r12,1
80004cdc:	58 2c       	cp.w	r12,2
80004cde:	e0 8b 00 12 	brhi	80004d02 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004ce2:	58 0a       	cp.w	r10,0
80004ce4:	c0 31       	brne	80004cea <_write+0x16>
80004ce6:	30 07       	mov	r7,0
80004ce8:	c0 e8       	rjmp	80004d04 <_write+0x30>
80004cea:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004cec:	48 74       	lddpc	r4,80004d08 <_write+0x34>
80004cee:	68 0c       	ld.w	r12,r4[0x0]
80004cf0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004cf4:	f0 1f 00 06 	mcall	80004d0c <_write+0x38>
80004cf8:	c0 55       	brlt	80004d02 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004cfa:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004cfc:	0e 36       	cp.w	r6,r7
80004cfe:	cf 81       	brne	80004cee <_write+0x1a>
80004d00:	c0 28       	rjmp	80004d04 <_write+0x30>
80004d02:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004d04:	0e 9c       	mov	r12,r7
80004d06:	d8 22       	popm	r4-r7,pc
80004d08:	00 00       	add	r0,r0
80004d0a:	41 08       	lddsp	r8,sp[0x40]
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	48 10       	lddpc	r0,80004d10 <vPortFree>

80004d10 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004d10:	eb cd 40 80 	pushm	r7,lr
80004d14:	18 97       	mov	r7,r12
	if( pv )
80004d16:	58 0c       	cp.w	r12,0
80004d18:	c0 80       	breq	80004d28 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004d1a:	f0 1f 00 05 	mcall	80004d2c <vPortFree+0x1c>
		{
			free( pv );
80004d1e:	0e 9c       	mov	r12,r7
80004d20:	f0 1f 00 04 	mcall	80004d30 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004d24:	f0 1f 00 04 	mcall	80004d34 <vPortFree+0x24>
80004d28:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	52 58       	stdsp	sp[0x94],r8
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	61 84       	ld.w	r4,r0[0x60]
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	56 14       	stdsp	sp[0x184],r4

80004d38 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004d38:	eb cd 40 80 	pushm	r7,lr
80004d3c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004d3e:	f0 1f 00 06 	mcall	80004d54 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004d42:	0e 9c       	mov	r12,r7
80004d44:	f0 1f 00 05 	mcall	80004d58 <pvPortMalloc+0x20>
80004d48:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004d4a:	f0 1f 00 05 	mcall	80004d5c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004d4e:	0e 9c       	mov	r12,r7
80004d50:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	52 58       	stdsp	sp[0x94],r8
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	61 94       	ld.w	r4,r0[0x64]
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	56 14       	stdsp	sp[0x184],r4

80004d60 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004d60:	d4 01       	pushm	lr
80004d62:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004d64:	78 09       	ld.w	r9,r12[0x0]
80004d66:	58 09       	cp.w	r9,0
80004d68:	c1 10       	breq	80004d8a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004d6a:	78 3a       	ld.w	r10,r12[0xc]
80004d6c:	79 09       	ld.w	r9,r12[0x40]
80004d6e:	f4 09 00 09 	add	r9,r10,r9
80004d72:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004d74:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004d76:	14 39       	cp.w	r9,r10
80004d78:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004d7c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004d80:	79 0a       	ld.w	r10,r12[0x40]
80004d82:	78 3b       	ld.w	r11,r12[0xc]
80004d84:	10 9c       	mov	r12,r8
80004d86:	f0 1f 00 02 	mcall	80004d8c <prvCopyDataFromQueue+0x2c>
80004d8a:	d8 02       	popm	pc
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	65 dc       	ld.w	r12,r2[0x74]

80004d90 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004d90:	eb cd 40 c0 	pushm	r6-r7,lr
80004d94:	18 97       	mov	r7,r12
80004d96:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004d98:	78 e8       	ld.w	r8,r12[0x38]
80004d9a:	58 08       	cp.w	r8,0
80004d9c:	c0 31       	brne	80004da2 <xQueueReceiveFromISR+0x12>
80004d9e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80004da2:	f0 1f 00 0e 	mcall	80004dd8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80004da6:	6e e8       	ld.w	r8,r7[0x38]
80004da8:	20 18       	sub	r8,1
80004daa:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004dac:	6f 18       	ld.w	r8,r7[0x44]
80004dae:	5b f8       	cp.w	r8,-1
80004db0:	c0 d1       	brne	80004dca <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004db2:	6e 48       	ld.w	r8,r7[0x10]
80004db4:	58 08       	cp.w	r8,0
80004db6:	c0 f0       	breq	80004dd4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004db8:	ee cc ff f0 	sub	r12,r7,-16
80004dbc:	f0 1f 00 08 	mcall	80004ddc <xQueueReceiveFromISR+0x4c>
80004dc0:	c0 a0       	breq	80004dd4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80004dc2:	30 1c       	mov	r12,1
80004dc4:	8d 0c       	st.w	r6[0x0],r12
80004dc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004dca:	2f f8       	sub	r8,-1
80004dcc:	ef 48 00 44 	st.w	r7[68],r8
80004dd0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004dd4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004dd8:	80 00       	ld.sh	r0,r0[0x0]
80004dda:	4d 60       	lddpc	r0,80004f30 <xQueueGenericReceive+0xb0>
80004ddc:	80 00       	ld.sh	r0,r0[0x0]
80004dde:	53 f0       	stdsp	sp[0xfc],r0

80004de0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004de0:	eb cd 40 c0 	pushm	r6-r7,lr
80004de4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004de6:	f0 1f 00 23 	mcall	80004e70 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004dea:	6f 28       	ld.w	r8,r7[0x48]
80004dec:	58 08       	cp.w	r8,0
80004dee:	e0 8a 00 18 	brle	80004e1e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004df2:	6e 98       	ld.w	r8,r7[0x24]
80004df4:	58 08       	cp.w	r8,0
80004df6:	c1 40       	breq	80004e1e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004df8:	ee c6 ff dc 	sub	r6,r7,-36
80004dfc:	c0 48       	rjmp	80004e04 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004dfe:	6e 98       	ld.w	r8,r7[0x24]
80004e00:	58 08       	cp.w	r8,0
80004e02:	c0 e0       	breq	80004e1e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004e04:	0c 9c       	mov	r12,r6
80004e06:	f0 1f 00 1c 	mcall	80004e74 <prvUnlockQueue+0x94>
80004e0a:	c0 30       	breq	80004e10 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004e0c:	f0 1f 00 1b 	mcall	80004e78 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004e10:	6f 28       	ld.w	r8,r7[0x48]
80004e12:	20 18       	sub	r8,1
80004e14:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004e18:	58 08       	cp.w	r8,0
80004e1a:	fe 99 ff f2 	brgt	80004dfe <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004e1e:	3f f8       	mov	r8,-1
80004e20:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004e24:	f0 1f 00 16 	mcall	80004e7c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004e28:	f0 1f 00 12 	mcall	80004e70 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004e2c:	6f 18       	ld.w	r8,r7[0x44]
80004e2e:	58 08       	cp.w	r8,0
80004e30:	e0 8a 00 18 	brle	80004e60 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004e34:	6e 48       	ld.w	r8,r7[0x10]
80004e36:	58 08       	cp.w	r8,0
80004e38:	c1 40       	breq	80004e60 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004e3a:	ee c6 ff f0 	sub	r6,r7,-16
80004e3e:	c0 48       	rjmp	80004e46 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004e40:	6e 48       	ld.w	r8,r7[0x10]
80004e42:	58 08       	cp.w	r8,0
80004e44:	c0 e0       	breq	80004e60 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004e46:	0c 9c       	mov	r12,r6
80004e48:	f0 1f 00 0b 	mcall	80004e74 <prvUnlockQueue+0x94>
80004e4c:	c0 30       	breq	80004e52 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004e4e:	f0 1f 00 0b 	mcall	80004e78 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004e52:	6f 18       	ld.w	r8,r7[0x44]
80004e54:	20 18       	sub	r8,1
80004e56:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004e5a:	58 08       	cp.w	r8,0
80004e5c:	fe 99 ff f2 	brgt	80004e40 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004e60:	3f f8       	mov	r8,-1
80004e62:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004e66:	f0 1f 00 06 	mcall	80004e7c <prvUnlockQueue+0x9c>
}
80004e6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e6e:	00 00       	add	r0,r0
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	4a cc       	lddpc	r12,80004f20 <xQueueGenericReceive+0xa0>
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	53 f0       	stdsp	sp[0xfc],r0
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	52 fc       	stdsp	sp[0xbc],r12
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4b d8       	lddpc	r8,80004f70 <xQueueGenericReceive+0xf0>

80004e80 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004e80:	d4 31       	pushm	r0-r7,lr
80004e82:	20 5d       	sub	sp,20
80004e84:	18 97       	mov	r7,r12
80004e86:	50 0b       	stdsp	sp[0x0],r11
80004e88:	50 2a       	stdsp	sp[0x8],r10
80004e8a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004e8c:	f8 c2 ff dc 	sub	r2,r12,-36
80004e90:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004e92:	fa c4 ff f4 	sub	r4,sp,-12
80004e96:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004e98:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004e9a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004e9e:	f0 1f 00 3e 	mcall	80004f94 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004ea2:	6e e8       	ld.w	r8,r7[0x38]
80004ea4:	58 08       	cp.w	r8,0
80004ea6:	c2 a0       	breq	80004efa <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004ea8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004eaa:	40 0b       	lddsp	r11,sp[0x0]
80004eac:	0e 9c       	mov	r12,r7
80004eae:	f0 1f 00 3b 	mcall	80004f98 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004eb2:	40 18       	lddsp	r8,sp[0x4]
80004eb4:	58 08       	cp.w	r8,0
80004eb6:	c1 51       	brne	80004ee0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004eb8:	6e e8       	ld.w	r8,r7[0x38]
80004eba:	20 18       	sub	r8,1
80004ebc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004ebe:	6e 08       	ld.w	r8,r7[0x0]
80004ec0:	58 08       	cp.w	r8,0
80004ec2:	c0 41       	brne	80004eca <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004ec4:	f0 1f 00 36 	mcall	80004f9c <xQueueGenericReceive+0x11c>
80004ec8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004eca:	6e 48       	ld.w	r8,r7[0x10]
80004ecc:	58 08       	cp.w	r8,0
80004ece:	c1 20       	breq	80004ef2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004ed0:	ee cc ff f0 	sub	r12,r7,-16
80004ed4:	f0 1f 00 33 	mcall	80004fa0 <xQueueGenericReceive+0x120>
80004ed8:	58 1c       	cp.w	r12,1
80004eda:	c0 c1       	brne	80004ef2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004edc:	d7 33       	scall
80004ede:	c0 a8       	rjmp	80004ef2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004ee0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004ee2:	6e 98       	ld.w	r8,r7[0x24]
80004ee4:	58 08       	cp.w	r8,0
80004ee6:	c0 60       	breq	80004ef2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004ee8:	04 9c       	mov	r12,r2
80004eea:	f0 1f 00 2e 	mcall	80004fa0 <xQueueGenericReceive+0x120>
80004eee:	c0 20       	breq	80004ef2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004ef0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004ef2:	f0 1f 00 2d 	mcall	80004fa4 <xQueueGenericReceive+0x124>
80004ef6:	30 1c       	mov	r12,1
				return pdPASS;
80004ef8:	c4 c8       	rjmp	80004f90 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004efa:	40 28       	lddsp	r8,sp[0x8]
80004efc:	58 08       	cp.w	r8,0
80004efe:	c0 51       	brne	80004f08 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004f00:	f0 1f 00 29 	mcall	80004fa4 <xQueueGenericReceive+0x124>
80004f04:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004f06:	c4 58       	rjmp	80004f90 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80004f08:	58 05       	cp.w	r5,0
80004f0a:	c0 51       	brne	80004f14 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004f0c:	08 9c       	mov	r12,r4
80004f0e:	f0 1f 00 27 	mcall	80004fa8 <xQueueGenericReceive+0x128>
80004f12:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004f14:	f0 1f 00 24 	mcall	80004fa4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004f18:	f0 1f 00 25 	mcall	80004fac <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80004f1c:	f0 1f 00 1e 	mcall	80004f94 <xQueueGenericReceive+0x114>
80004f20:	6f 18       	ld.w	r8,r7[0x44]
80004f22:	5b f8       	cp.w	r8,-1
80004f24:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004f28:	6f 28       	ld.w	r8,r7[0x48]
80004f2a:	5b f8       	cp.w	r8,-1
80004f2c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004f30:	f0 1f 00 1d 	mcall	80004fa4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004f34:	06 9b       	mov	r11,r3
80004f36:	08 9c       	mov	r12,r4
80004f38:	f0 1f 00 1e 	mcall	80004fb0 <xQueueGenericReceive+0x130>
80004f3c:	c2 41       	brne	80004f84 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004f3e:	f0 1f 00 16 	mcall	80004f94 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80004f42:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80004f44:	f0 1f 00 18 	mcall	80004fa4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80004f48:	58 06       	cp.w	r6,0
80004f4a:	c1 71       	brne	80004f78 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004f4c:	6e 08       	ld.w	r8,r7[0x0]
80004f4e:	58 08       	cp.w	r8,0
80004f50:	c0 81       	brne	80004f60 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80004f52:	f0 1f 00 11 	mcall	80004f94 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80004f56:	6e 1c       	ld.w	r12,r7[0x4]
80004f58:	f0 1f 00 17 	mcall	80004fb4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80004f5c:	f0 1f 00 12 	mcall	80004fa4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004f60:	40 2b       	lddsp	r11,sp[0x8]
80004f62:	04 9c       	mov	r12,r2
80004f64:	f0 1f 00 15 	mcall	80004fb8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80004f68:	0e 9c       	mov	r12,r7
80004f6a:	f0 1f 00 15 	mcall	80004fbc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80004f6e:	f0 1f 00 15 	mcall	80004fc0 <xQueueGenericReceive+0x140>
80004f72:	c9 61       	brne	80004e9e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80004f74:	d7 33       	scall
80004f76:	c9 4b       	rjmp	80004e9e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004f78:	0e 9c       	mov	r12,r7
80004f7a:	f0 1f 00 11 	mcall	80004fbc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80004f7e:	f0 1f 00 11 	mcall	80004fc0 <xQueueGenericReceive+0x140>
80004f82:	c8 eb       	rjmp	80004e9e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80004f84:	0e 9c       	mov	r12,r7
80004f86:	f0 1f 00 0e 	mcall	80004fbc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80004f8a:	f0 1f 00 0e 	mcall	80004fc0 <xQueueGenericReceive+0x140>
80004f8e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80004f90:	2f bd       	sub	sp,-20
80004f92:	d8 32       	popm	r0-r7,pc
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4a cc       	lddpc	r12,80005044 <xQueueGenericSendFromISR+0x8>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4d 60       	lddpc	r0,800050f0 <xQueueGenericSend+0x64>
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	53 08       	stdsp	sp[0xc0],r8
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	53 f0       	stdsp	sp[0xfc],r0
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	4b d8       	lddpc	r8,80005098 <xQueueGenericSend+0xc>
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	52 e4       	stdsp	sp[0xb8],r4
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	52 58       	stdsp	sp[0x94],r8
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	55 80       	stdsp	sp[0x160],r0
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	53 6c       	stdsp	sp[0xd8],r12
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	57 d8       	stdsp	sp[0x1f4],r8
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	4d e0       	lddpc	r0,80005134 <xQueueGenericSend+0xa8>
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	56 14       	stdsp	sp[0x184],r4

80004fc4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80004fc4:	eb cd 40 80 	pushm	r7,lr
80004fc8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80004fca:	79 08       	ld.w	r8,r12[0x40]
80004fcc:	58 08       	cp.w	r8,0
80004fce:	c0 a1       	brne	80004fe2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004fd0:	78 08       	ld.w	r8,r12[0x0]
80004fd2:	58 08       	cp.w	r8,0
80004fd4:	c2 b1       	brne	8000502a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80004fd6:	78 1c       	ld.w	r12,r12[0x4]
80004fd8:	f0 1f 00 17 	mcall	80005034 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80004fdc:	30 08       	mov	r8,0
80004fde:	8f 18       	st.w	r7[0x4],r8
80004fe0:	c2 58       	rjmp	8000502a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80004fe2:	58 0a       	cp.w	r10,0
80004fe4:	c1 01       	brne	80005004 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004fe6:	10 9a       	mov	r10,r8
80004fe8:	78 2c       	ld.w	r12,r12[0x8]
80004fea:	f0 1f 00 14 	mcall	80005038 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80004fee:	6e 29       	ld.w	r9,r7[0x8]
80004ff0:	6f 08       	ld.w	r8,r7[0x40]
80004ff2:	f2 08 00 08 	add	r8,r9,r8
80004ff6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80004ff8:	6e 19       	ld.w	r9,r7[0x4]
80004ffa:	12 38       	cp.w	r8,r9
80004ffc:	c1 73       	brcs	8000502a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80004ffe:	6e 08       	ld.w	r8,r7[0x0]
80005000:	8f 28       	st.w	r7[0x8],r8
80005002:	c1 48       	rjmp	8000502a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005004:	10 9a       	mov	r10,r8
80005006:	78 3c       	ld.w	r12,r12[0xc]
80005008:	f0 1f 00 0c 	mcall	80005038 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000500c:	6f 08       	ld.w	r8,r7[0x40]
8000500e:	6e 39       	ld.w	r9,r7[0xc]
80005010:	f2 08 01 08 	sub	r8,r9,r8
80005014:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005016:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005018:	12 38       	cp.w	r8,r9
8000501a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000501e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005022:	f3 d8 e3 19 	subcs	r9,r9,r8
80005026:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000502a:	6e e8       	ld.w	r8,r7[0x38]
8000502c:	2f f8       	sub	r8,-1
8000502e:	8f e8       	st.w	r7[0x38],r8
}
80005030:	e3 cd 80 80 	ldm	sp++,r7,pc
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	53 14       	stdsp	sp[0xc4],r4
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	65 dc       	ld.w	r12,r2[0x74]

8000503c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000503c:	eb cd 40 c0 	pushm	r6-r7,lr
80005040:	18 97       	mov	r7,r12
80005042:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005044:	78 ec       	ld.w	r12,r12[0x38]
80005046:	6e f8       	ld.w	r8,r7[0x3c]
80005048:	10 3c       	cp.w	r12,r8
8000504a:	c0 33       	brcs	80005050 <xQueueGenericSendFromISR+0x14>
8000504c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005050:	12 9a       	mov	r10,r9
80005052:	0e 9c       	mov	r12,r7
80005054:	f0 1f 00 0c 	mcall	80005084 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005058:	6f 28       	ld.w	r8,r7[0x48]
8000505a:	5b f8       	cp.w	r8,-1
8000505c:	c0 d1       	brne	80005076 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000505e:	6e 98       	ld.w	r8,r7[0x24]
80005060:	58 08       	cp.w	r8,0
80005062:	c0 f0       	breq	80005080 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005064:	ee cc ff dc 	sub	r12,r7,-36
80005068:	f0 1f 00 08 	mcall	80005088 <xQueueGenericSendFromISR+0x4c>
8000506c:	c0 a0       	breq	80005080 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000506e:	30 1c       	mov	r12,1
80005070:	8d 0c       	st.w	r6[0x0],r12
80005072:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005076:	2f f8       	sub	r8,-1
80005078:	ef 48 00 48 	st.w	r7[72],r8
8000507c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005080:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	4f c4       	lddpc	r4,80005274 <vTaskSwitchContext+0xc>
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	53 f0       	stdsp	sp[0xfc],r0

8000508c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000508c:	d4 31       	pushm	r0-r7,lr
8000508e:	20 5d       	sub	sp,20
80005090:	18 97       	mov	r7,r12
80005092:	50 0b       	stdsp	sp[0x0],r11
80005094:	50 2a       	stdsp	sp[0x8],r10
80005096:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005098:	f8 c0 ff f0 	sub	r0,r12,-16
8000509c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000509e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800050a2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800050a4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800050a8:	f0 1f 00 2f 	mcall	80005164 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800050ac:	6e e9       	ld.w	r9,r7[0x38]
800050ae:	6e f8       	ld.w	r8,r7[0x3c]
800050b0:	10 39       	cp.w	r9,r8
800050b2:	c1 42       	brcc	800050da <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800050b4:	40 1a       	lddsp	r10,sp[0x4]
800050b6:	40 0b       	lddsp	r11,sp[0x0]
800050b8:	0e 9c       	mov	r12,r7
800050ba:	f0 1f 00 2c 	mcall	80005168 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800050be:	6e 98       	ld.w	r8,r7[0x24]
800050c0:	58 08       	cp.w	r8,0
800050c2:	c0 80       	breq	800050d2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800050c4:	ee cc ff dc 	sub	r12,r7,-36
800050c8:	f0 1f 00 29 	mcall	8000516c <xQueueGenericSend+0xe0>
800050cc:	58 1c       	cp.w	r12,1
800050ce:	c0 21       	brne	800050d2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800050d0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800050d2:	f0 1f 00 28 	mcall	80005170 <xQueueGenericSend+0xe4>
800050d6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800050d8:	c4 38       	rjmp	8000515e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800050da:	40 28       	lddsp	r8,sp[0x8]
800050dc:	58 08       	cp.w	r8,0
800050de:	c0 51       	brne	800050e8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800050e0:	f0 1f 00 24 	mcall	80005170 <xQueueGenericSend+0xe4>
800050e4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800050e6:	c3 c8       	rjmp	8000515e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800050e8:	58 04       	cp.w	r4,0
800050ea:	c0 51       	brne	800050f4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800050ec:	06 9c       	mov	r12,r3
800050ee:	f0 1f 00 22 	mcall	80005174 <xQueueGenericSend+0xe8>
800050f2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800050f4:	f0 1f 00 1f 	mcall	80005170 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800050f8:	f0 1f 00 20 	mcall	80005178 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800050fc:	f0 1f 00 1a 	mcall	80005164 <xQueueGenericSend+0xd8>
80005100:	6f 18       	ld.w	r8,r7[0x44]
80005102:	5b f8       	cp.w	r8,-1
80005104:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005108:	6f 28       	ld.w	r8,r7[0x48]
8000510a:	5b f8       	cp.w	r8,-1
8000510c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005110:	f0 1f 00 18 	mcall	80005170 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005114:	04 9b       	mov	r11,r2
80005116:	06 9c       	mov	r12,r3
80005118:	f0 1f 00 19 	mcall	8000517c <xQueueGenericSend+0xf0>
8000511c:	c1 b1       	brne	80005152 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000511e:	f0 1f 00 12 	mcall	80005164 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005122:	6e e5       	ld.w	r5,r7[0x38]
80005124:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005126:	f0 1f 00 13 	mcall	80005170 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000512a:	0c 35       	cp.w	r5,r6
8000512c:	c0 d1       	brne	80005146 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000512e:	40 2b       	lddsp	r11,sp[0x8]
80005130:	00 9c       	mov	r12,r0
80005132:	f0 1f 00 14 	mcall	80005180 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005136:	0e 9c       	mov	r12,r7
80005138:	f0 1f 00 13 	mcall	80005184 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000513c:	f0 1f 00 13 	mcall	80005188 <xQueueGenericSend+0xfc>
80005140:	cb 41       	brne	800050a8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005142:	d7 33       	scall
80005144:	cb 2b       	rjmp	800050a8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005146:	0e 9c       	mov	r12,r7
80005148:	f0 1f 00 0f 	mcall	80005184 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000514c:	f0 1f 00 0f 	mcall	80005188 <xQueueGenericSend+0xfc>
80005150:	ca cb       	rjmp	800050a8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005152:	0e 9c       	mov	r12,r7
80005154:	f0 1f 00 0c 	mcall	80005184 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005158:	f0 1f 00 0c 	mcall	80005188 <xQueueGenericSend+0xfc>
8000515c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000515e:	2f bd       	sub	sp,-20
80005160:	d8 32       	popm	r0-r7,pc
80005162:	00 00       	add	r0,r0
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	4a cc       	lddpc	r12,80005214 <xQueueCreate+0x30>
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	4f c4       	lddpc	r4,80005358 <vTaskPriorityDisinherit+0x44>
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	53 f0       	stdsp	sp[0xfc],r0
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	4b d8       	lddpc	r8,80005264 <vTaskSuspendAll+0xc>
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	52 e4       	stdsp	sp[0xb8],r4
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	52 58       	stdsp	sp[0x94],r8
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	55 80       	stdsp	sp[0x160],r0
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	57 d8       	stdsp	sp[0x1f4],r8
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	4d e0       	lddpc	r0,800052fc <vTaskMissedYield>
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	56 14       	stdsp	sp[0x184],r4

8000518c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000518c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005190:	34 cc       	mov	r12,76
80005192:	f0 1f 00 12 	mcall	800051d8 <xQueueCreateMutex+0x4c>
80005196:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005198:	c1 d0       	breq	800051d2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000519a:	30 06       	mov	r6,0
8000519c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000519e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800051a0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800051a2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800051a4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800051a6:	30 18       	mov	r8,1
800051a8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800051aa:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800051ae:	3f f8       	mov	r8,-1
800051b0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800051b4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800051b8:	2f 0c       	sub	r12,-16
800051ba:	f0 1f 00 09 	mcall	800051dc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800051be:	ee cc ff dc 	sub	r12,r7,-36
800051c2:	f0 1f 00 07 	mcall	800051dc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800051c6:	0c 99       	mov	r9,r6
800051c8:	0c 9a       	mov	r10,r6
800051ca:	0c 9b       	mov	r11,r6
800051cc:	0e 9c       	mov	r12,r7
800051ce:	f0 1f 00 05 	mcall	800051e0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800051d2:	0e 9c       	mov	r12,r7
800051d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800051d8:	80 00       	ld.sh	r0,r0[0x0]
800051da:	4d 38       	lddpc	r8,80005324 <vTaskPriorityDisinherit+0x10>
800051dc:	80 00       	ld.sh	r0,r0[0x0]
800051de:	49 a8       	lddpc	r8,80005244 <xQueueCreate+0x60>
800051e0:	80 00       	ld.sh	r0,r0[0x0]
800051e2:	50 8c       	stdsp	sp[0x20],r12

800051e4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800051e4:	d4 21       	pushm	r4-r7,lr
800051e6:	18 97       	mov	r7,r12
800051e8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800051ea:	58 0c       	cp.w	r12,0
800051ec:	c2 f0       	breq	8000524a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800051ee:	34 cc       	mov	r12,76
800051f0:	f0 1f 00 17 	mcall	8000524c <xQueueCreate+0x68>
800051f4:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800051f6:	c2 a0       	breq	8000524a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800051f8:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800051fc:	e8 cc ff ff 	sub	r12,r4,-1
80005200:	f0 1f 00 13 	mcall	8000524c <xQueueCreate+0x68>
80005204:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005206:	c1 e0       	breq	80005242 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005208:	f8 04 00 04 	add	r4,r12,r4
8000520c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000520e:	30 08       	mov	r8,0
80005210:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005212:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005214:	ee c8 00 01 	sub	r8,r7,1
80005218:	ad 38       	mul	r8,r6
8000521a:	10 0c       	add	r12,r8
8000521c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000521e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005220:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005224:	3f f8       	mov	r8,-1
80005226:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000522a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000522e:	ea cc ff f0 	sub	r12,r5,-16
80005232:	f0 1f 00 08 	mcall	80005250 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005236:	ea cc ff dc 	sub	r12,r5,-36
8000523a:	f0 1f 00 06 	mcall	80005250 <xQueueCreate+0x6c>
8000523e:	0a 9c       	mov	r12,r5
80005240:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005242:	0a 9c       	mov	r12,r5
80005244:	f0 1f 00 04 	mcall	80005254 <xQueueCreate+0x70>
80005248:	d8 2a       	popm	r4-r7,pc,r12=0
8000524a:	d8 2a       	popm	r4-r7,pc,r12=0
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	4d 38       	lddpc	r8,80005398 <vTaskPriorityInherit+0x2c>
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	49 a8       	lddpc	r8,800052b8 <vTaskSwitchContext+0x50>
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	4d 10       	lddpc	r0,80005398 <vTaskPriorityInherit+0x2c>

80005258 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005258:	48 38       	lddpc	r8,80005264 <vTaskSuspendAll+0xc>
8000525a:	70 09       	ld.w	r9,r8[0x0]
8000525c:	2f f9       	sub	r9,-1
8000525e:	91 09       	st.w	r8[0x0],r9
}
80005260:	5e fc       	retal	r12
80005262:	00 00       	add	r0,r0
80005264:	00 00       	add	r0,r0
80005266:	0d 2c       	ld.uh	r12,r6++

80005268 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005268:	49 a8       	lddpc	r8,800052d0 <vTaskSwitchContext+0x68>
8000526a:	70 08       	ld.w	r8,r8[0x0]
8000526c:	58 08       	cp.w	r8,0
8000526e:	c0 b1       	brne	80005284 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005270:	49 98       	lddpc	r8,800052d4 <vTaskSwitchContext+0x6c>
80005272:	70 08       	ld.w	r8,r8[0x0]
80005274:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005278:	49 89       	lddpc	r9,800052d8 <vTaskSwitchContext+0x70>
8000527a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000527e:	58 08       	cp.w	r8,0
80005280:	c0 60       	breq	8000528c <vTaskSwitchContext+0x24>
80005282:	c1 18       	rjmp	800052a4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005284:	30 19       	mov	r9,1
80005286:	49 68       	lddpc	r8,800052dc <vTaskSwitchContext+0x74>
80005288:	91 09       	st.w	r8[0x0],r9
8000528a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000528c:	49 28       	lddpc	r8,800052d4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000528e:	49 3a       	lddpc	r10,800052d8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005290:	70 09       	ld.w	r9,r8[0x0]
80005292:	20 19       	sub	r9,1
80005294:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005296:	70 09       	ld.w	r9,r8[0x0]
80005298:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000529c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800052a0:	58 09       	cp.w	r9,0
800052a2:	cf 70       	breq	80005290 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800052a4:	48 c8       	lddpc	r8,800052d4 <vTaskSwitchContext+0x6c>
800052a6:	70 08       	ld.w	r8,r8[0x0]
800052a8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800052ac:	48 b9       	lddpc	r9,800052d8 <vTaskSwitchContext+0x70>
800052ae:	f2 08 00 28 	add	r8,r9,r8<<0x2
800052b2:	70 19       	ld.w	r9,r8[0x4]
800052b4:	72 19       	ld.w	r9,r9[0x4]
800052b6:	91 19       	st.w	r8[0x4],r9
800052b8:	f0 ca ff f8 	sub	r10,r8,-8
800052bc:	14 39       	cp.w	r9,r10
800052be:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800052c2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800052c6:	70 18       	ld.w	r8,r8[0x4]
800052c8:	70 39       	ld.w	r9,r8[0xc]
800052ca:	48 68       	lddpc	r8,800052e0 <vTaskSwitchContext+0x78>
800052cc:	91 09       	st.w	r8[0x0],r9
800052ce:	5e fc       	retal	r12
800052d0:	00 00       	add	r0,r0
800052d2:	0d 2c       	ld.uh	r12,r6++
800052d4:	00 00       	add	r0,r0
800052d6:	0d 64       	ld.uh	r4,--r6
800052d8:	00 00       	add	r0,r0
800052da:	0c 48       	or	r8,r6
800052dc:	00 00       	add	r0,r0
800052de:	0d 4c       	ld.w	r12,--r6
800052e0:	00 00       	add	r0,r0
800052e2:	0c fc       	st.b	--r6,r12

800052e4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800052e4:	48 48       	lddpc	r8,800052f4 <vTaskSetTimeOutState+0x10>
800052e6:	70 08       	ld.w	r8,r8[0x0]
800052e8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800052ea:	48 48       	lddpc	r8,800052f8 <vTaskSetTimeOutState+0x14>
800052ec:	70 08       	ld.w	r8,r8[0x0]
800052ee:	99 18       	st.w	r12[0x4],r8
}
800052f0:	5e fc       	retal	r12
800052f2:	00 00       	add	r0,r0
800052f4:	00 00       	add	r0,r0
800052f6:	0c 40       	or	r0,r6
800052f8:	00 00       	add	r0,r0
800052fa:	0d 28       	ld.uh	r8,r6++

800052fc <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800052fc:	30 19       	mov	r9,1
800052fe:	48 28       	lddpc	r8,80005304 <vTaskMissedYield+0x8>
80005300:	91 09       	st.w	r8[0x0],r9
}
80005302:	5e fc       	retal	r12
80005304:	00 00       	add	r0,r0
80005306:	0d 4c       	ld.w	r12,--r6

80005308 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005308:	48 28       	lddpc	r8,80005310 <xTaskGetCurrentTaskHandle+0x8>
8000530a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000530c:	5e fc       	retal	r12
8000530e:	00 00       	add	r0,r0
80005310:	00 00       	add	r0,r0
80005312:	0c fc       	st.b	--r6,r12

80005314 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005314:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005318:	58 0c       	cp.w	r12,0
8000531a:	c1 f0       	breq	80005358 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000531c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000531e:	78 b9       	ld.w	r9,r12[0x2c]
80005320:	79 18       	ld.w	r8,r12[0x44]
80005322:	10 39       	cp.w	r9,r8
80005324:	c1 a0       	breq	80005358 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005326:	f8 c6 ff fc 	sub	r6,r12,-4
8000532a:	0c 9c       	mov	r12,r6
8000532c:	f0 1f 00 0c 	mcall	8000535c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005330:	6f 1c       	ld.w	r12,r7[0x44]
80005332:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005334:	f8 08 11 08 	rsub	r8,r12,8
80005338:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000533a:	48 a8       	lddpc	r8,80005360 <vTaskPriorityDisinherit+0x4c>
8000533c:	70 08       	ld.w	r8,r8[0x0]
8000533e:	10 3c       	cp.w	r12,r8
80005340:	e0 88 00 04 	brls	80005348 <vTaskPriorityDisinherit+0x34>
80005344:	48 78       	lddpc	r8,80005360 <vTaskPriorityDisinherit+0x4c>
80005346:	91 0c       	st.w	r8[0x0],r12
80005348:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000534c:	0c 9b       	mov	r11,r6
8000534e:	48 68       	lddpc	r8,80005364 <vTaskPriorityDisinherit+0x50>
80005350:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005354:	f0 1f 00 05 	mcall	80005368 <vTaskPriorityDisinherit+0x54>
80005358:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	4a 12       	lddpc	r2,800053e0 <vTaskPriorityInherit+0x74>
80005360:	00 00       	add	r0,r0
80005362:	0d 64       	ld.uh	r4,--r6
80005364:	00 00       	add	r0,r0
80005366:	0c 48       	or	r8,r6
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	49 c2       	lddpc	r2,800053d8 <vTaskPriorityInherit+0x6c>

8000536c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000536c:	eb cd 40 c0 	pushm	r6-r7,lr
80005370:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005372:	49 b8       	lddpc	r8,800053dc <vTaskPriorityInherit+0x70>
80005374:	70 08       	ld.w	r8,r8[0x0]
80005376:	78 b9       	ld.w	r9,r12[0x2c]
80005378:	70 b8       	ld.w	r8,r8[0x2c]
8000537a:	10 39       	cp.w	r9,r8
8000537c:	c2 d2       	brcc	800053d6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000537e:	49 88       	lddpc	r8,800053dc <vTaskPriorityInherit+0x70>
80005380:	70 08       	ld.w	r8,r8[0x0]
80005382:	70 b8       	ld.w	r8,r8[0x2c]
80005384:	f0 08 11 08 	rsub	r8,r8,8
80005388:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000538a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000538e:	49 59       	lddpc	r9,800053e0 <vTaskPriorityInherit+0x74>
80005390:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005394:	78 59       	ld.w	r9,r12[0x14]
80005396:	10 39       	cp.w	r9,r8
80005398:	c1 b1       	brne	800053ce <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000539a:	f8 c6 ff fc 	sub	r6,r12,-4
8000539e:	0c 9c       	mov	r12,r6
800053a0:	f0 1f 00 11 	mcall	800053e4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800053a4:	48 e8       	lddpc	r8,800053dc <vTaskPriorityInherit+0x70>
800053a6:	70 08       	ld.w	r8,r8[0x0]
800053a8:	70 bc       	ld.w	r12,r8[0x2c]
800053aa:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800053ac:	48 f8       	lddpc	r8,800053e8 <vTaskPriorityInherit+0x7c>
800053ae:	70 08       	ld.w	r8,r8[0x0]
800053b0:	10 3c       	cp.w	r12,r8
800053b2:	e0 88 00 04 	brls	800053ba <vTaskPriorityInherit+0x4e>
800053b6:	48 d8       	lddpc	r8,800053e8 <vTaskPriorityInherit+0x7c>
800053b8:	91 0c       	st.w	r8[0x0],r12
800053ba:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800053be:	0c 9b       	mov	r11,r6
800053c0:	48 88       	lddpc	r8,800053e0 <vTaskPriorityInherit+0x74>
800053c2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800053c6:	f0 1f 00 0a 	mcall	800053ec <vTaskPriorityInherit+0x80>
800053ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800053ce:	48 48       	lddpc	r8,800053dc <vTaskPriorityInherit+0x70>
800053d0:	70 08       	ld.w	r8,r8[0x0]
800053d2:	70 b8       	ld.w	r8,r8[0x2c]
800053d4:	99 b8       	st.w	r12[0x2c],r8
800053d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053da:	00 00       	add	r0,r0
800053dc:	00 00       	add	r0,r0
800053de:	0c fc       	st.b	--r6,r12
800053e0:	00 00       	add	r0,r0
800053e2:	0c 48       	or	r8,r6
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	4a 12       	lddpc	r2,80005468 <xTaskRemoveFromEventList+0x78>
800053e8:	00 00       	add	r0,r0
800053ea:	0d 64       	ld.uh	r4,--r6
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	49 c2       	lddpc	r2,8000545c <xTaskRemoveFromEventList+0x6c>

800053f0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800053f0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800053f4:	78 38       	ld.w	r8,r12[0xc]
800053f6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800053f8:	ee c6 ff e8 	sub	r6,r7,-24
800053fc:	0c 9c       	mov	r12,r6
800053fe:	f0 1f 00 15 	mcall	80005450 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005402:	49 58       	lddpc	r8,80005454 <xTaskRemoveFromEventList+0x64>
80005404:	70 08       	ld.w	r8,r8[0x0]
80005406:	58 08       	cp.w	r8,0
80005408:	c1 71       	brne	80005436 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000540a:	ee c6 ff fc 	sub	r6,r7,-4
8000540e:	0c 9c       	mov	r12,r6
80005410:	f0 1f 00 10 	mcall	80005450 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005414:	6e bc       	ld.w	r12,r7[0x2c]
80005416:	49 18       	lddpc	r8,80005458 <xTaskRemoveFromEventList+0x68>
80005418:	70 08       	ld.w	r8,r8[0x0]
8000541a:	10 3c       	cp.w	r12,r8
8000541c:	e0 88 00 04 	brls	80005424 <xTaskRemoveFromEventList+0x34>
80005420:	48 e8       	lddpc	r8,80005458 <xTaskRemoveFromEventList+0x68>
80005422:	91 0c       	st.w	r8[0x0],r12
80005424:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005428:	0c 9b       	mov	r11,r6
8000542a:	48 d8       	lddpc	r8,8000545c <xTaskRemoveFromEventList+0x6c>
8000542c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005430:	f0 1f 00 0c 	mcall	80005460 <xTaskRemoveFromEventList+0x70>
80005434:	c0 58       	rjmp	8000543e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005436:	0c 9b       	mov	r11,r6
80005438:	48 bc       	lddpc	r12,80005464 <xTaskRemoveFromEventList+0x74>
8000543a:	f0 1f 00 0a 	mcall	80005460 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000543e:	48 b8       	lddpc	r8,80005468 <xTaskRemoveFromEventList+0x78>
80005440:	70 08       	ld.w	r8,r8[0x0]
80005442:	6e b9       	ld.w	r9,r7[0x2c]
80005444:	70 b8       	ld.w	r8,r8[0x2c]
80005446:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005448:	5f 2c       	srhs	r12
8000544a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000544e:	00 00       	add	r0,r0
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	4a 12       	lddpc	r2,800054d4 <vTaskIncrementTick+0x68>
80005454:	00 00       	add	r0,r0
80005456:	0d 2c       	ld.uh	r12,r6++
80005458:	00 00       	add	r0,r0
8000545a:	0d 64       	ld.uh	r4,--r6
8000545c:	00 00       	add	r0,r0
8000545e:	0c 48       	or	r8,r6
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	49 c2       	lddpc	r2,800054d0 <vTaskIncrementTick+0x64>
80005464:	00 00       	add	r0,r0
80005466:	0d 00       	ld.w	r0,r6++
80005468:	00 00       	add	r0,r0
8000546a:	0c fc       	st.b	--r6,r12

8000546c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000546c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005470:	4b 98       	lddpc	r8,80005554 <vTaskIncrementTick+0xe8>
80005472:	70 08       	ld.w	r8,r8[0x0]
80005474:	58 08       	cp.w	r8,0
80005476:	c6 91       	brne	80005548 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005478:	4b 88       	lddpc	r8,80005558 <vTaskIncrementTick+0xec>
8000547a:	70 09       	ld.w	r9,r8[0x0]
8000547c:	2f f9       	sub	r9,-1
8000547e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005480:	70 08       	ld.w	r8,r8[0x0]
80005482:	58 08       	cp.w	r8,0
80005484:	c1 a1       	brne	800054b8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005486:	4b 68       	lddpc	r8,8000555c <vTaskIncrementTick+0xf0>
80005488:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000548a:	4b 69       	lddpc	r9,80005560 <vTaskIncrementTick+0xf4>
8000548c:	72 0b       	ld.w	r11,r9[0x0]
8000548e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005490:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005492:	4b 59       	lddpc	r9,80005564 <vTaskIncrementTick+0xf8>
80005494:	72 0a       	ld.w	r10,r9[0x0]
80005496:	2f fa       	sub	r10,-1
80005498:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000549a:	70 08       	ld.w	r8,r8[0x0]
8000549c:	70 08       	ld.w	r8,r8[0x0]
8000549e:	58 08       	cp.w	r8,0
800054a0:	c0 51       	brne	800054aa <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800054a2:	3f f9       	mov	r9,-1
800054a4:	4b 18       	lddpc	r8,80005568 <vTaskIncrementTick+0xfc>
800054a6:	91 09       	st.w	r8[0x0],r9
800054a8:	c0 88       	rjmp	800054b8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800054aa:	4a d8       	lddpc	r8,8000555c <vTaskIncrementTick+0xf0>
800054ac:	70 08       	ld.w	r8,r8[0x0]
800054ae:	70 38       	ld.w	r8,r8[0xc]
800054b0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800054b2:	70 19       	ld.w	r9,r8[0x4]
800054b4:	4a d8       	lddpc	r8,80005568 <vTaskIncrementTick+0xfc>
800054b6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800054b8:	4a 88       	lddpc	r8,80005558 <vTaskIncrementTick+0xec>
800054ba:	70 09       	ld.w	r9,r8[0x0]
800054bc:	4a b8       	lddpc	r8,80005568 <vTaskIncrementTick+0xfc>
800054be:	70 08       	ld.w	r8,r8[0x0]
800054c0:	10 39       	cp.w	r9,r8
800054c2:	c4 73       	brcs	80005550 <vTaskIncrementTick+0xe4>
800054c4:	4a 68       	lddpc	r8,8000555c <vTaskIncrementTick+0xf0>
800054c6:	70 08       	ld.w	r8,r8[0x0]
800054c8:	70 08       	ld.w	r8,r8[0x0]
800054ca:	58 08       	cp.w	r8,0
800054cc:	c0 c0       	breq	800054e4 <vTaskIncrementTick+0x78>
800054ce:	4a 48       	lddpc	r8,8000555c <vTaskIncrementTick+0xf0>
800054d0:	70 08       	ld.w	r8,r8[0x0]
800054d2:	70 38       	ld.w	r8,r8[0xc]
800054d4:	70 37       	ld.w	r7,r8[0xc]
800054d6:	6e 18       	ld.w	r8,r7[0x4]
800054d8:	4a 09       	lddpc	r9,80005558 <vTaskIncrementTick+0xec>
800054da:	72 09       	ld.w	r9,r9[0x0]
800054dc:	12 38       	cp.w	r8,r9
800054de:	e0 88 00 14 	brls	80005506 <vTaskIncrementTick+0x9a>
800054e2:	c0 e8       	rjmp	800054fe <vTaskIncrementTick+0x92>
800054e4:	3f f9       	mov	r9,-1
800054e6:	4a 18       	lddpc	r8,80005568 <vTaskIncrementTick+0xfc>
800054e8:	91 09       	st.w	r8[0x0],r9
800054ea:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800054ee:	6a 08       	ld.w	r8,r5[0x0]
800054f0:	70 38       	ld.w	r8,r8[0xc]
800054f2:	70 37       	ld.w	r7,r8[0xc]
800054f4:	6e 18       	ld.w	r8,r7[0x4]
800054f6:	64 09       	ld.w	r9,r2[0x0]
800054f8:	12 38       	cp.w	r8,r9
800054fa:	e0 88 00 0a 	brls	8000550e <vTaskIncrementTick+0xa2>
800054fe:	49 b9       	lddpc	r9,80005568 <vTaskIncrementTick+0xfc>
80005500:	93 08       	st.w	r9[0x0],r8
80005502:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005506:	49 a4       	lddpc	r4,8000556c <vTaskIncrementTick+0x100>
80005508:	49 a3       	lddpc	r3,80005570 <vTaskIncrementTick+0x104>
8000550a:	49 55       	lddpc	r5,8000555c <vTaskIncrementTick+0xf0>
8000550c:	49 32       	lddpc	r2,80005558 <vTaskIncrementTick+0xec>
8000550e:	ee c6 ff fc 	sub	r6,r7,-4
80005512:	0c 9c       	mov	r12,r6
80005514:	f0 1f 00 18 	mcall	80005574 <vTaskIncrementTick+0x108>
80005518:	6e a8       	ld.w	r8,r7[0x28]
8000551a:	58 08       	cp.w	r8,0
8000551c:	c0 50       	breq	80005526 <vTaskIncrementTick+0xba>
8000551e:	ee cc ff e8 	sub	r12,r7,-24
80005522:	f0 1f 00 15 	mcall	80005574 <vTaskIncrementTick+0x108>
80005526:	6e bc       	ld.w	r12,r7[0x2c]
80005528:	68 08       	ld.w	r8,r4[0x0]
8000552a:	10 3c       	cp.w	r12,r8
8000552c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005530:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005534:	0c 9b       	mov	r11,r6
80005536:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000553a:	f0 1f 00 10 	mcall	80005578 <vTaskIncrementTick+0x10c>
8000553e:	6a 08       	ld.w	r8,r5[0x0]
80005540:	70 08       	ld.w	r8,r8[0x0]
80005542:	58 08       	cp.w	r8,0
80005544:	cd 51       	brne	800054ee <vTaskIncrementTick+0x82>
80005546:	cc fb       	rjmp	800054e4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005548:	48 d8       	lddpc	r8,8000557c <vTaskIncrementTick+0x110>
8000554a:	70 09       	ld.w	r9,r8[0x0]
8000554c:	2f f9       	sub	r9,-1
8000554e:	91 09       	st.w	r8[0x0],r9
80005550:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005554:	00 00       	add	r0,r0
80005556:	0d 2c       	ld.uh	r12,r6++
80005558:	00 00       	add	r0,r0
8000555a:	0d 28       	ld.uh	r8,r6++
8000555c:	00 00       	add	r0,r0
8000555e:	0c 34       	cp.w	r4,r6
80005560:	00 00       	add	r0,r0
80005562:	0c 44       	or	r4,r6
80005564:	00 00       	add	r0,r0
80005566:	0c 40       	or	r0,r6
80005568:	00 00       	add	r0,r0
8000556a:	05 34       	ld.ub	r4,r2++
8000556c:	00 00       	add	r0,r0
8000556e:	0d 64       	ld.uh	r4,--r6
80005570:	00 00       	add	r0,r0
80005572:	0c 48       	or	r8,r6
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	4a 12       	lddpc	r2,800055f8 <xTaskGetTickCount+0x8>
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	49 c2       	lddpc	r2,800055e8 <xTaskCheckForTimeOut+0x68>
8000557c:	00 00       	add	r0,r0
8000557e:	0c 2c       	rsub	r12,r6

80005580 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005580:	eb cd 40 c0 	pushm	r6-r7,lr
80005584:	18 97       	mov	r7,r12
80005586:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005588:	f0 1f 00 15 	mcall	800055dc <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000558c:	6c 08       	ld.w	r8,r6[0x0]
8000558e:	5b f8       	cp.w	r8,-1
80005590:	c0 31       	brne	80005596 <xTaskCheckForTimeOut+0x16>
80005592:	30 07       	mov	r7,0
80005594:	c1 f8       	rjmp	800055d2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005596:	49 39       	lddpc	r9,800055e0 <xTaskCheckForTimeOut+0x60>
80005598:	72 09       	ld.w	r9,r9[0x0]
8000559a:	6e 0a       	ld.w	r10,r7[0x0]
8000559c:	12 3a       	cp.w	r10,r9
8000559e:	c0 70       	breq	800055ac <xTaskCheckForTimeOut+0x2c>
800055a0:	49 19       	lddpc	r9,800055e4 <xTaskCheckForTimeOut+0x64>
800055a2:	72 09       	ld.w	r9,r9[0x0]
800055a4:	6e 1a       	ld.w	r10,r7[0x4]
800055a6:	12 3a       	cp.w	r10,r9
800055a8:	e0 88 00 14 	brls	800055d0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800055ac:	48 e9       	lddpc	r9,800055e4 <xTaskCheckForTimeOut+0x64>
800055ae:	72 0a       	ld.w	r10,r9[0x0]
800055b0:	6e 19       	ld.w	r9,r7[0x4]
800055b2:	12 1a       	sub	r10,r9
800055b4:	14 38       	cp.w	r8,r10
800055b6:	e0 88 00 0d 	brls	800055d0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800055ba:	48 ba       	lddpc	r10,800055e4 <xTaskCheckForTimeOut+0x64>
800055bc:	74 0a       	ld.w	r10,r10[0x0]
800055be:	14 19       	sub	r9,r10
800055c0:	f2 08 00 08 	add	r8,r9,r8
800055c4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800055c6:	0e 9c       	mov	r12,r7
800055c8:	f0 1f 00 08 	mcall	800055e8 <xTaskCheckForTimeOut+0x68>
800055cc:	30 07       	mov	r7,0
800055ce:	c0 28       	rjmp	800055d2 <xTaskCheckForTimeOut+0x52>
800055d0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800055d2:	f0 1f 00 07 	mcall	800055ec <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800055d6:	0e 9c       	mov	r12,r7
800055d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	4a cc       	lddpc	r12,8000568c <xTaskResumeAll+0x78>
800055e0:	00 00       	add	r0,r0
800055e2:	0c 40       	or	r0,r6
800055e4:	00 00       	add	r0,r0
800055e6:	0d 28       	ld.uh	r8,r6++
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	52 e4       	stdsp	sp[0xb8],r4
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	4b d8       	lddpc	r8,800056e0 <xTaskResumeAll+0xcc>

800055f0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800055f0:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800055f4:	f0 1f 00 05 	mcall	80005608 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800055f8:	48 58       	lddpc	r8,8000560c <xTaskGetTickCount+0x1c>
800055fa:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800055fc:	f0 1f 00 05 	mcall	80005610 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005600:	0e 9c       	mov	r12,r7
80005602:	e3 cd 80 80 	ldm	sp++,r7,pc
80005606:	00 00       	add	r0,r0
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	4a cc       	lddpc	r12,800056b8 <xTaskResumeAll+0xa4>
8000560c:	00 00       	add	r0,r0
8000560e:	0d 28       	ld.uh	r8,r6++
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	4b d8       	lddpc	r8,80005704 <prvAddCurrentTaskToDelayedList+0x8>

80005614 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005614:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005618:	f0 1f 00 2c 	mcall	800056c8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000561c:	4a c8       	lddpc	r8,800056cc <xTaskResumeAll+0xb8>
8000561e:	70 09       	ld.w	r9,r8[0x0]
80005620:	20 19       	sub	r9,1
80005622:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005624:	70 08       	ld.w	r8,r8[0x0]
80005626:	58 08       	cp.w	r8,0
80005628:	c4 91       	brne	800056ba <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000562a:	4a a8       	lddpc	r8,800056d0 <xTaskResumeAll+0xbc>
8000562c:	70 08       	ld.w	r8,r8[0x0]
8000562e:	58 08       	cp.w	r8,0
80005630:	c4 50       	breq	800056ba <xTaskResumeAll+0xa6>
80005632:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005634:	4a 85       	lddpc	r5,800056d4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005636:	4a 93       	lddpc	r3,800056d8 <xTaskResumeAll+0xc4>
80005638:	4a 92       	lddpc	r2,800056dc <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000563a:	4a a1       	lddpc	r1,800056e0 <xTaskResumeAll+0xcc>
8000563c:	c1 e8       	rjmp	80005678 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000563e:	6a 38       	ld.w	r8,r5[0xc]
80005640:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005642:	ee cc ff e8 	sub	r12,r7,-24
80005646:	f0 1f 00 28 	mcall	800056e4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000564a:	ee c6 ff fc 	sub	r6,r7,-4
8000564e:	0c 9c       	mov	r12,r6
80005650:	f0 1f 00 25 	mcall	800056e4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005654:	6e bc       	ld.w	r12,r7[0x2c]
80005656:	66 08       	ld.w	r8,r3[0x0]
80005658:	10 3c       	cp.w	r12,r8
8000565a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000565e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005662:	0c 9b       	mov	r11,r6
80005664:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005668:	f0 1f 00 20 	mcall	800056e8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000566c:	62 08       	ld.w	r8,r1[0x0]
8000566e:	6e b9       	ld.w	r9,r7[0x2c]
80005670:	70 b8       	ld.w	r8,r8[0x2c]
80005672:	10 39       	cp.w	r9,r8
80005674:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005678:	6a 08       	ld.w	r8,r5[0x0]
8000567a:	58 08       	cp.w	r8,0
8000567c:	ce 11       	brne	8000563e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000567e:	49 c8       	lddpc	r8,800056ec <xTaskResumeAll+0xd8>
80005680:	70 08       	ld.w	r8,r8[0x0]
80005682:	58 08       	cp.w	r8,0
80005684:	c0 f0       	breq	800056a2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005686:	49 a8       	lddpc	r8,800056ec <xTaskResumeAll+0xd8>
80005688:	70 08       	ld.w	r8,r8[0x0]
8000568a:	58 08       	cp.w	r8,0
8000568c:	c1 10       	breq	800056ae <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000568e:	49 87       	lddpc	r7,800056ec <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005690:	f0 1f 00 18 	mcall	800056f0 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005694:	6e 08       	ld.w	r8,r7[0x0]
80005696:	20 18       	sub	r8,1
80005698:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000569a:	6e 08       	ld.w	r8,r7[0x0]
8000569c:	58 08       	cp.w	r8,0
8000569e:	cf 91       	brne	80005690 <xTaskResumeAll+0x7c>
800056a0:	c0 78       	rjmp	800056ae <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800056a2:	58 14       	cp.w	r4,1
800056a4:	c0 50       	breq	800056ae <xTaskResumeAll+0x9a>
800056a6:	49 48       	lddpc	r8,800056f4 <xTaskResumeAll+0xe0>
800056a8:	70 08       	ld.w	r8,r8[0x0]
800056aa:	58 18       	cp.w	r8,1
800056ac:	c0 71       	brne	800056ba <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800056ae:	30 09       	mov	r9,0
800056b0:	49 18       	lddpc	r8,800056f4 <xTaskResumeAll+0xe0>
800056b2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800056b4:	d7 33       	scall
800056b6:	30 17       	mov	r7,1
800056b8:	c0 28       	rjmp	800056bc <xTaskResumeAll+0xa8>
800056ba:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800056bc:	f0 1f 00 0f 	mcall	800056f8 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800056c0:	0e 9c       	mov	r12,r7
800056c2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800056c6:	00 00       	add	r0,r0
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	4a cc       	lddpc	r12,80005778 <vTaskDelayUntil+0x20>
800056cc:	00 00       	add	r0,r0
800056ce:	0d 2c       	ld.uh	r12,r6++
800056d0:	00 00       	add	r0,r0
800056d2:	0d 48       	ld.w	r8,--r6
800056d4:	00 00       	add	r0,r0
800056d6:	0d 00       	ld.w	r0,r6++
800056d8:	00 00       	add	r0,r0
800056da:	0d 64       	ld.uh	r4,--r6
800056dc:	00 00       	add	r0,r0
800056de:	0c 48       	or	r8,r6
800056e0:	00 00       	add	r0,r0
800056e2:	0c fc       	st.b	--r6,r12
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	4a 12       	lddpc	r2,80005768 <vTaskDelayUntil+0x10>
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	49 c2       	lddpc	r2,80005758 <vTaskDelayUntil>
800056ec:	00 00       	add	r0,r0
800056ee:	0c 2c       	rsub	r12,r6
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	54 6c       	stdsp	sp[0x118],r12
800056f4:	00 00       	add	r0,r0
800056f6:	0d 4c       	ld.w	r12,--r6
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	4b d8       	lddpc	r8,800057ec <vTaskPlaceOnEventList+0x14>

800056fc <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800056fc:	eb cd 40 80 	pushm	r7,lr
80005700:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005702:	49 08       	lddpc	r8,80005740 <prvAddCurrentTaskToDelayedList+0x44>
80005704:	70 08       	ld.w	r8,r8[0x0]
80005706:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005708:	48 f8       	lddpc	r8,80005744 <prvAddCurrentTaskToDelayedList+0x48>
8000570a:	70 08       	ld.w	r8,r8[0x0]
8000570c:	10 3c       	cp.w	r12,r8
8000570e:	c0 a2       	brcc	80005722 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005710:	48 c8       	lddpc	r8,80005740 <prvAddCurrentTaskToDelayedList+0x44>
80005712:	70 0b       	ld.w	r11,r8[0x0]
80005714:	48 d8       	lddpc	r8,80005748 <prvAddCurrentTaskToDelayedList+0x4c>
80005716:	70 0c       	ld.w	r12,r8[0x0]
80005718:	2f cb       	sub	r11,-4
8000571a:	f0 1f 00 0d 	mcall	8000574c <prvAddCurrentTaskToDelayedList+0x50>
8000571e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005722:	48 88       	lddpc	r8,80005740 <prvAddCurrentTaskToDelayedList+0x44>
80005724:	70 0b       	ld.w	r11,r8[0x0]
80005726:	48 b8       	lddpc	r8,80005750 <prvAddCurrentTaskToDelayedList+0x54>
80005728:	70 0c       	ld.w	r12,r8[0x0]
8000572a:	2f cb       	sub	r11,-4
8000572c:	f0 1f 00 08 	mcall	8000574c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005730:	48 98       	lddpc	r8,80005754 <prvAddCurrentTaskToDelayedList+0x58>
80005732:	70 08       	ld.w	r8,r8[0x0]
80005734:	10 37       	cp.w	r7,r8
80005736:	c0 32       	brcc	8000573c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005738:	48 78       	lddpc	r8,80005754 <prvAddCurrentTaskToDelayedList+0x58>
8000573a:	91 07       	st.w	r8[0x0],r7
8000573c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005740:	00 00       	add	r0,r0
80005742:	0c fc       	st.b	--r6,r12
80005744:	00 00       	add	r0,r0
80005746:	0d 28       	ld.uh	r8,r6++
80005748:	00 00       	add	r0,r0
8000574a:	0c 44       	or	r4,r6
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	49 de       	lddpc	lr,800057c0 <vTaskDelayUntil+0x68>
80005750:	00 00       	add	r0,r0
80005752:	0c 34       	cp.w	r4,r6
80005754:	00 00       	add	r0,r0
80005756:	05 34       	ld.ub	r4,r2++

80005758 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005758:	eb cd 40 c0 	pushm	r6-r7,lr
8000575c:	18 96       	mov	r6,r12
8000575e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005760:	f0 1f 00 18 	mcall	800057c0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005764:	6c 08       	ld.w	r8,r6[0x0]
80005766:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005768:	49 79       	lddpc	r9,800057c4 <vTaskDelayUntil+0x6c>
8000576a:	72 09       	ld.w	r9,r9[0x0]
8000576c:	12 38       	cp.w	r8,r9
8000576e:	e0 88 00 0c 	brls	80005786 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005772:	0e 38       	cp.w	r8,r7
80005774:	e0 88 00 22 	brls	800057b8 <vTaskDelayUntil+0x60>
80005778:	49 38       	lddpc	r8,800057c4 <vTaskDelayUntil+0x6c>
8000577a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000577c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000577e:	10 37       	cp.w	r7,r8
80005780:	e0 88 00 14 	brls	800057a8 <vTaskDelayUntil+0x50>
80005784:	c0 a8       	rjmp	80005798 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005786:	0e 38       	cp.w	r8,r7
80005788:	e0 8b 00 16 	brhi	800057b4 <vTaskDelayUntil+0x5c>
8000578c:	48 e8       	lddpc	r8,800057c4 <vTaskDelayUntil+0x6c>
8000578e:	70 08       	ld.w	r8,r8[0x0]
80005790:	10 37       	cp.w	r7,r8
80005792:	e0 8b 00 11 	brhi	800057b4 <vTaskDelayUntil+0x5c>
80005796:	c1 18       	rjmp	800057b8 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005798:	48 c8       	lddpc	r8,800057c8 <vTaskDelayUntil+0x70>
8000579a:	70 0c       	ld.w	r12,r8[0x0]
8000579c:	2f cc       	sub	r12,-4
8000579e:	f0 1f 00 0c 	mcall	800057cc <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800057a2:	0e 9c       	mov	r12,r7
800057a4:	f0 1f 00 0b 	mcall	800057d0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800057a8:	f0 1f 00 0b 	mcall	800057d4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800057ac:	c0 81       	brne	800057bc <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800057ae:	d7 33       	scall
800057b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800057b4:	8d 07       	st.w	r6[0x0],r7
800057b6:	cf 1b       	rjmp	80005798 <vTaskDelayUntil+0x40>
800057b8:	8d 07       	st.w	r6[0x0],r7
800057ba:	cf 7b       	rjmp	800057a8 <vTaskDelayUntil+0x50>
800057bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	52 58       	stdsp	sp[0x94],r8
800057c4:	00 00       	add	r0,r0
800057c6:	0d 28       	ld.uh	r8,r6++
800057c8:	00 00       	add	r0,r0
800057ca:	0c fc       	st.b	--r6,r12
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	4a 12       	lddpc	r2,80005850 <prvIdleTask+0x20>
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	56 fc       	stdsp	sp[0x1bc],r12
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	56 14       	stdsp	sp[0x184],r4

800057d8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800057d8:	eb cd 40 c0 	pushm	r6-r7,lr
800057dc:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800057de:	48 e7       	lddpc	r7,80005814 <vTaskPlaceOnEventList+0x3c>
800057e0:	6e 0b       	ld.w	r11,r7[0x0]
800057e2:	2e 8b       	sub	r11,-24
800057e4:	f0 1f 00 0d 	mcall	80005818 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057e8:	6e 0c       	ld.w	r12,r7[0x0]
800057ea:	2f cc       	sub	r12,-4
800057ec:	f0 1f 00 0c 	mcall	8000581c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800057f0:	5b f6       	cp.w	r6,-1
800057f2:	c0 81       	brne	80005802 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057f4:	6e 0b       	ld.w	r11,r7[0x0]
800057f6:	2f cb       	sub	r11,-4
800057f8:	48 ac       	lddpc	r12,80005820 <vTaskPlaceOnEventList+0x48>
800057fa:	f0 1f 00 0b 	mcall	80005824 <vTaskPlaceOnEventList+0x4c>
800057fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005802:	48 a8       	lddpc	r8,80005828 <vTaskPlaceOnEventList+0x50>
80005804:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005806:	ec 0c 00 0c 	add	r12,r6,r12
8000580a:	f0 1f 00 09 	mcall	8000582c <vTaskPlaceOnEventList+0x54>
8000580e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005812:	00 00       	add	r0,r0
80005814:	00 00       	add	r0,r0
80005816:	0c fc       	st.b	--r6,r12
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	49 de       	lddpc	lr,8000588c <prvIdleTask+0x5c>
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	4a 12       	lddpc	r2,800058a0 <prvIdleTask+0x70>
80005820:	00 00       	add	r0,r0
80005822:	0d 50       	ld.sh	r0,--r6
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	49 c2       	lddpc	r2,80005894 <prvIdleTask+0x64>
80005828:	00 00       	add	r0,r0
8000582a:	0d 28       	ld.uh	r8,r6++
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	56 fc       	stdsp	sp[0x1bc],r12

80005830 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005830:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005834:	49 67       	lddpc	r7,8000588c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005836:	49 74       	lddpc	r4,80005890 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005838:	49 73       	lddpc	r3,80005894 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000583a:	49 85       	lddpc	r5,80005898 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000583c:	6e 08       	ld.w	r8,r7[0x0]
8000583e:	58 08       	cp.w	r8,0
80005840:	c1 e0       	breq	8000587c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005842:	f0 1f 00 17 	mcall	8000589c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005846:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005848:	f0 1f 00 16 	mcall	800058a0 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
8000584c:	58 06       	cp.w	r6,0
8000584e:	c1 70       	breq	8000587c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005850:	f0 1f 00 15 	mcall	800058a4 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005854:	68 38       	ld.w	r8,r4[0xc]
80005856:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005858:	ec cc ff fc 	sub	r12,r6,-4
8000585c:	f0 1f 00 13 	mcall	800058a8 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005860:	66 08       	ld.w	r8,r3[0x0]
80005862:	20 18       	sub	r8,1
80005864:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005866:	6e 08       	ld.w	r8,r7[0x0]
80005868:	20 18       	sub	r8,1
8000586a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
8000586c:	f0 1f 00 10 	mcall	800058ac <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005870:	6c cc       	ld.w	r12,r6[0x30]
80005872:	f0 1f 00 10 	mcall	800058b0 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005876:	0c 9c       	mov	r12,r6
80005878:	f0 1f 00 0e 	mcall	800058b0 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000587c:	6a 08       	ld.w	r8,r5[0x0]
8000587e:	58 18       	cp.w	r8,1
80005880:	e0 88 00 03 	brls	80005886 <prvIdleTask+0x56>
			{
				taskYIELD();
80005884:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005886:	f0 1f 00 0c 	mcall	800058b4 <prvIdleTask+0x84>
		}
		#endif
	}
8000588a:	cd 9b       	rjmp	8000583c <prvIdleTask+0xc>
8000588c:	00 00       	add	r0,r0
8000588e:	0c 3c       	cp.w	r12,r6
80005890:	00 00       	add	r0,r0
80005892:	0c e8       	st.h	--r6,r8
80005894:	00 00       	add	r0,r0
80005896:	0d 48       	ld.w	r8,--r6
80005898:	00 00       	add	r0,r0
8000589a:	0c 48       	or	r8,r6
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	52 58       	stdsp	sp[0x94],r8
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	56 14       	stdsp	sp[0x184],r4
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	4a cc       	lddpc	r12,80005954 <xTaskGenericCreate+0x9c>
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	4a 12       	lddpc	r2,8000592c <xTaskGenericCreate+0x74>
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	4b d8       	lddpc	r8,800059a0 <xTaskGenericCreate+0xe8>
800058b0:	80 00       	ld.sh	r0,r0[0x0]
800058b2:	4d 10       	lddpc	r0,800059f4 <xTaskGenericCreate+0x13c>
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	20 30       	sub	r0,3

800058b8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800058b8:	d4 31       	pushm	r0-r7,lr
800058ba:	20 1d       	sub	sp,4
800058bc:	fa c4 ff d8 	sub	r4,sp,-40
800058c0:	50 0c       	stdsp	sp[0x0],r12
800058c2:	16 91       	mov	r1,r11
800058c4:	14 97       	mov	r7,r10
800058c6:	12 90       	mov	r0,r9
800058c8:	10 93       	mov	r3,r8
800058ca:	68 02       	ld.w	r2,r4[0x0]
800058cc:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800058ce:	34 8c       	mov	r12,72
800058d0:	f0 1f 00 5c 	mcall	80005a40 <xTaskGenericCreate+0x188>
800058d4:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800058d6:	c0 31       	brne	800058dc <xTaskGenericCreate+0x24>
800058d8:	3f fc       	mov	r12,-1
800058da:	ca f8       	rjmp	80005a38 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800058dc:	58 06       	cp.w	r6,0
800058de:	e0 81 00 af 	brne	80005a3c <xTaskGenericCreate+0x184>
800058e2:	0e 9c       	mov	r12,r7
800058e4:	5c 7c       	castu.h	r12
800058e6:	a3 6c       	lsl	r12,0x2
800058e8:	f0 1f 00 56 	mcall	80005a40 <xTaskGenericCreate+0x188>
800058ec:	18 96       	mov	r6,r12
800058ee:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800058f0:	c0 61       	brne	800058fc <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800058f2:	0a 9c       	mov	r12,r5
800058f4:	f0 1f 00 54 	mcall	80005a44 <xTaskGenericCreate+0x18c>
800058f8:	3f fc       	mov	r12,-1
800058fa:	c9 f8       	rjmp	80005a38 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800058fc:	5c 77       	castu.h	r7
800058fe:	ee 0a 15 02 	lsl	r10,r7,0x2
80005902:	e0 6b 00 a5 	mov	r11,165
80005906:	0c 9c       	mov	r12,r6
80005908:	f0 1f 00 50 	mcall	80005a48 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000590c:	ee c6 00 01 	sub	r6,r7,1
80005910:	6a c8       	ld.w	r8,r5[0x30]
80005912:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005916:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000591a:	31 0a       	mov	r10,16
8000591c:	02 9b       	mov	r11,r1
8000591e:	ea cc ff cc 	sub	r12,r5,-52
80005922:	f0 1f 00 4b 	mcall	80005a4c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005926:	30 08       	mov	r8,0
80005928:	eb 68 00 43 	st.b	r5[67],r8
8000592c:	58 73       	cp.w	r3,7
8000592e:	e6 07 17 80 	movls	r7,r3
80005932:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005936:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005938:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000593c:	ea c4 ff fc 	sub	r4,r5,-4
80005940:	08 9c       	mov	r12,r4
80005942:	f0 1f 00 44 	mcall	80005a50 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005946:	ea cc ff e8 	sub	r12,r5,-24
8000594a:	f0 1f 00 42 	mcall	80005a50 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000594e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005950:	ee 07 11 08 	rsub	r7,r7,8
80005954:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005956:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005958:	00 9a       	mov	r10,r0
8000595a:	40 0b       	lddsp	r11,sp[0x0]
8000595c:	0c 9c       	mov	r12,r6
8000595e:	f0 1f 00 3e 	mcall	80005a54 <xTaskGenericCreate+0x19c>
80005962:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005964:	58 02       	cp.w	r2,0
80005966:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000596a:	f0 1f 00 3c 	mcall	80005a58 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000596e:	4b c8       	lddpc	r8,80005a5c <xTaskGenericCreate+0x1a4>
80005970:	70 09       	ld.w	r9,r8[0x0]
80005972:	2f f9       	sub	r9,-1
80005974:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005976:	4b b8       	lddpc	r8,80005a60 <xTaskGenericCreate+0x1a8>
80005978:	70 08       	ld.w	r8,r8[0x0]
8000597a:	58 08       	cp.w	r8,0
8000597c:	c2 61       	brne	800059c8 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000597e:	4b 98       	lddpc	r8,80005a60 <xTaskGenericCreate+0x1a8>
80005980:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005982:	4b 78       	lddpc	r8,80005a5c <xTaskGenericCreate+0x1a4>
80005984:	70 08       	ld.w	r8,r8[0x0]
80005986:	58 18       	cp.w	r8,1
80005988:	c2 b1       	brne	800059de <xTaskGenericCreate+0x126>
8000598a:	4b 77       	lddpc	r7,80005a64 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000598c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005990:	0e 9c       	mov	r12,r7
80005992:	f0 1f 00 36 	mcall	80005a68 <xTaskGenericCreate+0x1b0>
80005996:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005998:	0c 37       	cp.w	r7,r6
8000599a:	cf b1       	brne	80005990 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000599c:	4b 47       	lddpc	r7,80005a6c <xTaskGenericCreate+0x1b4>
8000599e:	0e 9c       	mov	r12,r7
800059a0:	f0 1f 00 32 	mcall	80005a68 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800059a4:	4b 36       	lddpc	r6,80005a70 <xTaskGenericCreate+0x1b8>
800059a6:	0c 9c       	mov	r12,r6
800059a8:	f0 1f 00 30 	mcall	80005a68 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800059ac:	4b 2c       	lddpc	r12,80005a74 <xTaskGenericCreate+0x1bc>
800059ae:	f0 1f 00 2f 	mcall	80005a68 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800059b2:	4b 2c       	lddpc	r12,80005a78 <xTaskGenericCreate+0x1c0>
800059b4:	f0 1f 00 2d 	mcall	80005a68 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800059b8:	4b 1c       	lddpc	r12,80005a7c <xTaskGenericCreate+0x1c4>
800059ba:	f0 1f 00 2c 	mcall	80005a68 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800059be:	4b 18       	lddpc	r8,80005a80 <xTaskGenericCreate+0x1c8>
800059c0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800059c2:	4b 18       	lddpc	r8,80005a84 <xTaskGenericCreate+0x1cc>
800059c4:	91 06       	st.w	r8[0x0],r6
800059c6:	c0 c8       	rjmp	800059de <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800059c8:	4b 08       	lddpc	r8,80005a88 <xTaskGenericCreate+0x1d0>
800059ca:	70 08       	ld.w	r8,r8[0x0]
800059cc:	58 08       	cp.w	r8,0
800059ce:	c0 81       	brne	800059de <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800059d0:	4a 48       	lddpc	r8,80005a60 <xTaskGenericCreate+0x1a8>
800059d2:	70 08       	ld.w	r8,r8[0x0]
800059d4:	70 b8       	ld.w	r8,r8[0x2c]
800059d6:	10 33       	cp.w	r3,r8
800059d8:	c0 33       	brcs	800059de <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800059da:	4a 28       	lddpc	r8,80005a60 <xTaskGenericCreate+0x1a8>
800059dc:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800059de:	6a b8       	ld.w	r8,r5[0x2c]
800059e0:	4a b9       	lddpc	r9,80005a8c <xTaskGenericCreate+0x1d4>
800059e2:	72 09       	ld.w	r9,r9[0x0]
800059e4:	12 38       	cp.w	r8,r9
800059e6:	e0 88 00 04 	brls	800059ee <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800059ea:	4a 99       	lddpc	r9,80005a8c <xTaskGenericCreate+0x1d4>
800059ec:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800059ee:	4a 98       	lddpc	r8,80005a90 <xTaskGenericCreate+0x1d8>
800059f0:	70 09       	ld.w	r9,r8[0x0]
800059f2:	2f f9       	sub	r9,-1
800059f4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800059f6:	6a b8       	ld.w	r8,r5[0x2c]
800059f8:	4a 79       	lddpc	r9,80005a94 <xTaskGenericCreate+0x1dc>
800059fa:	72 09       	ld.w	r9,r9[0x0]
800059fc:	12 38       	cp.w	r8,r9
800059fe:	e0 88 00 04 	brls	80005a06 <xTaskGenericCreate+0x14e>
80005a02:	4a 59       	lddpc	r9,80005a94 <xTaskGenericCreate+0x1dc>
80005a04:	93 08       	st.w	r9[0x0],r8
80005a06:	6a bc       	ld.w	r12,r5[0x2c]
80005a08:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a0c:	08 9b       	mov	r11,r4
80005a0e:	49 68       	lddpc	r8,80005a64 <xTaskGenericCreate+0x1ac>
80005a10:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a14:	f0 1f 00 21 	mcall	80005a98 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005a18:	f0 1f 00 21 	mcall	80005a9c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005a1c:	49 b8       	lddpc	r8,80005a88 <xTaskGenericCreate+0x1d0>
80005a1e:	70 08       	ld.w	r8,r8[0x0]
80005a20:	58 08       	cp.w	r8,0
80005a22:	c0 a0       	breq	80005a36 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005a24:	48 f8       	lddpc	r8,80005a60 <xTaskGenericCreate+0x1a8>
80005a26:	70 08       	ld.w	r8,r8[0x0]
80005a28:	70 b8       	ld.w	r8,r8[0x2c]
80005a2a:	10 33       	cp.w	r3,r8
80005a2c:	e0 88 00 05 	brls	80005a36 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005a30:	d7 33       	scall
80005a32:	30 1c       	mov	r12,1
80005a34:	c0 28       	rjmp	80005a38 <xTaskGenericCreate+0x180>
80005a36:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005a38:	2f fd       	sub	sp,-4
80005a3a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005a3c:	99 c6       	st.w	r12[0x30],r6
80005a3e:	c5 fb       	rjmp	800058fc <xTaskGenericCreate+0x44>
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	4d 38       	lddpc	r8,80005b8c <PrintHex+0x9c>
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	4d 10       	lddpc	r0,80005b88 <PrintHex+0x98>
80005a48:	80 00       	ld.sh	r0,r0[0x0]
80005a4a:	67 24       	ld.w	r4,r3[0x48]
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	6a 68       	ld.w	r8,r5[0x18]
80005a50:	80 00       	ld.sh	r0,r0[0x0]
80005a52:	49 bc       	lddpc	r12,80005abc <vTaskStartScheduler+0x1c>
80005a54:	80 00       	ld.sh	r0,r0[0x0]
80005a56:	4a 38       	lddpc	r8,80005ae0 <vTaskStartScheduler+0x40>
80005a58:	80 00       	ld.sh	r0,r0[0x0]
80005a5a:	4a cc       	lddpc	r12,80005b08 <PrintHex+0x18>
80005a5c:	00 00       	add	r0,r0
80005a5e:	0d 48       	ld.w	r8,--r6
80005a60:	00 00       	add	r0,r0
80005a62:	0c fc       	st.b	--r6,r12
80005a64:	00 00       	add	r0,r0
80005a66:	0c 48       	or	r8,r6
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	49 a8       	lddpc	r8,80005ad0 <vTaskStartScheduler+0x30>
80005a6c:	00 00       	add	r0,r0
80005a6e:	0d 14       	ld.sh	r4,r6++
80005a70:	00 00       	add	r0,r0
80005a72:	0d 30       	ld.ub	r0,r6++
80005a74:	00 00       	add	r0,r0
80005a76:	0d 00       	ld.w	r0,r6++
80005a78:	00 00       	add	r0,r0
80005a7a:	0c e8       	st.h	--r6,r8
80005a7c:	00 00       	add	r0,r0
80005a7e:	0d 50       	ld.sh	r0,--r6
80005a80:	00 00       	add	r0,r0
80005a82:	0c 34       	cp.w	r4,r6
80005a84:	00 00       	add	r0,r0
80005a86:	0c 44       	or	r4,r6
80005a88:	00 00       	add	r0,r0
80005a8a:	0c 38       	cp.w	r8,r6
80005a8c:	00 00       	add	r0,r0
80005a8e:	0c 30       	cp.w	r0,r6
80005a90:	00 00       	add	r0,r0
80005a92:	0d 44       	ld.w	r4,--r6
80005a94:	00 00       	add	r0,r0
80005a96:	0d 64       	ld.uh	r4,--r6
80005a98:	80 00       	ld.sh	r0,r0[0x0]
80005a9a:	49 c2       	lddpc	r2,80005b08 <PrintHex+0x18>
80005a9c:	80 00       	ld.sh	r0,r0[0x0]
80005a9e:	4b d8       	lddpc	r8,80005b90 <PrintHex+0xa0>

80005aa0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005aa0:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005aa2:	30 09       	mov	r9,0
80005aa4:	1a d9       	st.w	--sp,r9
80005aa6:	1a d9       	st.w	--sp,r9
80005aa8:	1a d9       	st.w	--sp,r9
80005aaa:	12 98       	mov	r8,r9
80005aac:	e0 6a 01 00 	mov	r10,256
80005ab0:	48 9b       	lddpc	r11,80005ad4 <vTaskStartScheduler+0x34>
80005ab2:	48 ac       	lddpc	r12,80005ad8 <vTaskStartScheduler+0x38>
80005ab4:	f0 1f 00 0a 	mcall	80005adc <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005ab8:	2f dd       	sub	sp,-12
80005aba:	58 1c       	cp.w	r12,1
80005abc:	c0 a1       	brne	80005ad0 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005abe:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005ac0:	30 19       	mov	r9,1
80005ac2:	48 88       	lddpc	r8,80005ae0 <vTaskStartScheduler+0x40>
80005ac4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005ac6:	30 09       	mov	r9,0
80005ac8:	48 78       	lddpc	r8,80005ae4 <vTaskStartScheduler+0x44>
80005aca:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005acc:	f0 1f 00 07 	mcall	80005ae8 <vTaskStartScheduler+0x48>
80005ad0:	d8 02       	popm	pc
80005ad2:	00 00       	add	r0,r0
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	cc 84       	brge	80005a66 <xTaskGenericCreate+0x1ae>
80005ad8:	80 00       	ld.sh	r0,r0[0x0]
80005ada:	58 30       	cp.w	r0,3
80005adc:	80 00       	ld.sh	r0,r0[0x0]
80005ade:	58 b8       	cp.w	r8,11
80005ae0:	00 00       	add	r0,r0
80005ae2:	0c 38       	cp.w	r8,r6
80005ae4:	00 00       	add	r0,r0
80005ae6:	0d 28       	ld.uh	r8,r6++
80005ae8:	80 00       	ld.sh	r0,r0[0x0]
80005aea:	4a dc       	lddpc	r12,80005b9c <PrintHex+0xac>

80005aec <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005aec:	16 cc       	st.b	r11++,r12
	return str;
}
80005aee:	5e fb       	retal	r11

80005af0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005af0:	eb cd 40 c0 	pushm	r6-r7,lr
80005af4:	20 3d       	sub	sp,12
80005af6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005af8:	30 06       	mov	r6,0
80005afa:	30 07       	mov	r7,0
80005afc:	fa e7 00 00 	st.d	sp[0],r6
80005b00:	30 0c       	mov	r12,0
80005b02:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005b04:	58 08       	cp.w	r8,0
80005b06:	c1 30       	breq	80005b2c <PrintHex+0x3c>
80005b08:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005b0a:	1a 9c       	mov	r12,sp
80005b0c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005b10:	58 9e       	cp.w	lr,9
80005b12:	e0 8a 00 04 	brle	80005b1a <PrintHex+0x2a>
80005b16:	2c 9e       	sub	lr,-55
80005b18:	c0 48       	rjmp	80005b20 <PrintHex+0x30>
80005b1a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005b1e:	2d 0e       	sub	lr,-48
80005b20:	f8 09 0b 0e 	st.b	r12[r9],lr
80005b24:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005b26:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005b28:	cf 21       	brne	80005b0c <PrintHex+0x1c>
80005b2a:	c0 48       	rjmp	80005b32 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005b2c:	33 08       	mov	r8,48
80005b2e:	ba 88       	st.b	sp[0x0],r8
80005b30:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005b32:	f6 09 01 08 	sub	r8,r11,r9
80005b36:	58 08       	cp.w	r8,0
80005b38:	e0 8a 00 13 	brle	80005b5e <PrintHex+0x6e>
	{
		char num = len - cnt;
80005b3c:	12 1b       	sub	r11,r9
80005b3e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005b42:	18 9e       	mov	lr,r12
80005b44:	58 0c       	cp.w	r12,0
80005b46:	e0 8a 00 0c 	brle	80005b5e <PrintHex+0x6e>
80005b4a:	1a 9b       	mov	r11,sp
80005b4c:	12 0b       	add	r11,r9
80005b4e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005b50:	33 07       	mov	r7,48
80005b52:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005b54:	2f f8       	sub	r8,-1
80005b56:	1c 38       	cp.w	r8,lr
80005b58:	cf d5       	brlt	80005b52 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005b5a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005b5e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005b62:	f0 cb ff ff 	sub	r11,r8,-1
80005b66:	58 0b       	cp.w	r11,0
80005b68:	e0 8a 00 19 	brle	80005b9a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005b6c:	fa cb ff f4 	sub	r11,sp,-12
80005b70:	f6 09 00 09 	add	r9,r11,r9
80005b74:	37 8b       	mov	r11,120
80005b76:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005b7a:	fa c9 ff f4 	sub	r9,sp,-12
80005b7e:	10 09       	add	r9,r8
80005b80:	33 0b       	mov	r11,48
80005b82:	f3 6b ff f4 	st.b	r9[-12],r11
80005b86:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005b8a:	fa ce 00 01 	sub	lr,sp,1
80005b8e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005b90:	11 8b       	ld.ub	r11,r8[0x0]
80005b92:	12 cb       	st.b	r9++,r11
80005b94:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005b96:	1c 38       	cp.w	r8,lr
80005b98:	cf c1       	brne	80005b90 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005b9a:	14 9c       	mov	r12,r10
80005b9c:	2f dd       	sub	sp,-12
80005b9e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005ba2 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005ba2:	d4 21       	pushm	r4-r7,lr
80005ba4:	20 3d       	sub	sp,12
80005ba6:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005ba8:	30 06       	mov	r6,0
80005baa:	30 07       	mov	r7,0
80005bac:	fa e7 00 00 	st.d	sp[0],r6
80005bb0:	30 0c       	mov	r12,0
80005bb2:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005bb4:	58 08       	cp.w	r8,0
80005bb6:	c0 35       	brlt	80005bbc <PrintDec+0x1a>
80005bb8:	14 97       	mov	r7,r10
80005bba:	c0 58       	rjmp	80005bc4 <PrintDec+0x22>
	{
		*p++ = '-';
80005bbc:	14 97       	mov	r7,r10
80005bbe:	32 d9       	mov	r9,45
80005bc0:	0e c9       	st.b	r7++,r9
		i = -i;
80005bc2:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005bc4:	58 08       	cp.w	r8,0
80005bc6:	c0 51       	brne	80005bd0 <PrintDec+0x2e>
80005bc8:	33 08       	mov	r8,48
80005bca:	ba 88       	st.b	sp[0x0],r8
80005bcc:	30 1e       	mov	lr,1
80005bce:	c2 f8       	rjmp	80005c2c <PrintDec+0x8a>
	
	int ten = i%10;
80005bd0:	e0 65 66 67 	mov	r5,26215
80005bd4:	ea 15 66 66 	orh	r5,0x6666
80005bd8:	f0 05 04 44 	muls.d	r4,r8,r5
80005bdc:	ea 0c 14 02 	asr	r12,r5,0x2
80005be0:	f0 09 14 1f 	asr	r9,r8,0x1f
80005be4:	f8 09 01 09 	sub	r9,r12,r9
80005be8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005bec:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005bf0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005bf2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005bf4:	e0 66 66 67 	mov	r6,26215
80005bf8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005bfc:	2d 09       	sub	r9,-48
80005bfe:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005c02:	2f fe       	sub	lr,-1
		i /= 10;
80005c04:	f0 06 04 44 	muls.d	r4,r8,r6
80005c08:	ea 09 14 02 	asr	r9,r5,0x2
80005c0c:	bf 58       	asr	r8,0x1f
80005c0e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005c12:	f0 06 04 44 	muls.d	r4,r8,r6
80005c16:	ea 09 14 02 	asr	r9,r5,0x2
80005c1a:	f0 05 14 1f 	asr	r5,r8,0x1f
80005c1e:	0a 19       	sub	r9,r5
80005c20:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005c24:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005c28:	58 08       	cp.w	r8,0
80005c2a:	ce 91       	brne	80005bfc <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005c2c:	f6 0e 01 08 	sub	r8,r11,lr
80005c30:	58 08       	cp.w	r8,0
80005c32:	e0 89 00 06 	brgt	80005c3e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005c36:	58 0e       	cp.w	lr,0
80005c38:	e0 89 00 14 	brgt	80005c60 <PrintDec+0xbe>
80005c3c:	c1 d8       	rjmp	80005c76 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005c3e:	1c 1b       	sub	r11,lr
80005c40:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005c42:	16 9c       	mov	r12,r11
80005c44:	58 0b       	cp.w	r11,0
80005c46:	fe 9a ff f8 	brle	80005c36 <PrintDec+0x94>
80005c4a:	1a 99       	mov	r9,sp
80005c4c:	1c 09       	add	r9,lr
80005c4e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005c50:	33 06       	mov	r6,48
80005c52:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005c54:	2f f8       	sub	r8,-1
80005c56:	18 38       	cp.w	r8,r12
80005c58:	cf d5       	brlt	80005c52 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005c5a:	f6 0e 00 0e 	add	lr,r11,lr
80005c5e:	ce cb       	rjmp	80005c36 <PrintDec+0x94>
80005c60:	fa c8 ff f4 	sub	r8,sp,-12
80005c64:	1c 08       	add	r8,lr
80005c66:	20 d8       	sub	r8,13
80005c68:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005c6c:	11 89       	ld.ub	r9,r8[0x0]
80005c6e:	0e c9       	st.b	r7++,r9
80005c70:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005c72:	16 38       	cp.w	r8,r11
80005c74:	cf c1       	brne	80005c6c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005c76:	14 9c       	mov	r12,r10
80005c78:	2f dd       	sub	sp,-12
80005c7a:	d8 22       	popm	r4-r7,pc

80005c7c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005c7c:	d4 31       	pushm	r0-r7,lr
80005c7e:	fa cd 02 08 	sub	sp,sp,520
80005c82:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005c84:	e0 6a 01 00 	mov	r10,256
80005c88:	30 0b       	mov	r11,0
80005c8a:	fa cc fe f8 	sub	r12,sp,-264
80005c8e:	f0 1f 00 4e 	mcall	80005dc4 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005c92:	fa c4 fd d4 	sub	r4,sp,-556
80005c96:	30 0a       	mov	r10,0
80005c98:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005c9a:	fa c3 ff fc 	sub	r3,sp,-4
80005c9e:	e0 61 01 00 	mov	r1,256
80005ca2:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005ca4:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005ca6:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005caa:	02 9a       	mov	r10,r1
80005cac:	00 9b       	mov	r11,r0
80005cae:	06 9c       	mov	r12,r3
80005cb0:	f0 1f 00 45 	mcall	80005dc4 <log+0x148>
			
					if(*str == '%')
80005cb4:	0f 88       	ld.ub	r8,r7[0x0]
80005cb6:	e4 08 18 00 	cp.b	r8,r2
80005cba:	c5 71       	brne	80005d68 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005cbc:	ee c8 ff ff 	sub	r8,r7,-1
80005cc0:	11 89       	ld.ub	r9,r8[0x0]
80005cc2:	4c 2a       	lddpc	r10,80005dc8 <log+0x14c>
80005cc4:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005cc6:	23 09       	sub	r9,48
80005cc8:	30 9a       	mov	r10,9
80005cca:	f4 09 18 00 	cp.b	r9,r10
80005cce:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005cd2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005cd6:	f7 b9 08 30 	subls	r9,48
80005cda:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005cde:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005ce2:	0f 88       	ld.ub	r8,r7[0x0]
80005ce4:	22 58       	sub	r8,37
80005ce6:	e0 48 00 53 	cp.w	r8,83
80005cea:	e0 8b 00 31 	brhi	80005d4c <log+0xd0>
80005cee:	4b 89       	lddpc	r9,80005dcc <log+0x150>
80005cf0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005cf4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005cf8:	06 9a       	mov	r10,r3
80005cfa:	40 0b       	lddsp	r11,sp[0x0]
80005cfc:	5c 5b       	castu.b	r11
80005cfe:	68 0c       	ld.w	r12,r4[0x0]
80005d00:	f0 1f 00 34 	mcall	80005dd0 <log+0x154>
							break;
80005d04:	c2 98       	rjmp	80005d56 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005d06:	4b 4c       	lddpc	r12,80005dd4 <log+0x158>
80005d08:	f0 1f 00 34 	mcall	80005dd8 <log+0x15c>
80005d0c:	08 95       	mov	r5,r4
80005d0e:	06 9c       	mov	r12,r3
							break;
80005d10:	c2 38       	rjmp	80005d56 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005d12:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005d16:	06 9a       	mov	r10,r3
80005d18:	40 0b       	lddsp	r11,sp[0x0]
80005d1a:	5c 5b       	castu.b	r11
80005d1c:	68 0c       	ld.w	r12,r4[0x0]
80005d1e:	f0 1f 00 30 	mcall	80005ddc <log+0x160>
80005d22:	06 9c       	mov	r12,r3
							break;
80005d24:	c1 98       	rjmp	80005d56 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005d26:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005d2a:	06 9b       	mov	r11,r3
80005d2c:	09 bc       	ld.ub	r12,r4[0x3]
80005d2e:	f0 1f 00 2d 	mcall	80005de0 <log+0x164>
80005d32:	06 9c       	mov	r12,r3
							break;
80005d34:	c1 18       	rjmp	80005d56 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005d36:	e8 c5 ff fc 	sub	r5,r4,-4
80005d3a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005d3c:	c0 d8       	rjmp	80005d56 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005d3e:	06 9b       	mov	r11,r3
80005d40:	32 5c       	mov	r12,37
80005d42:	f0 1f 00 28 	mcall	80005de0 <log+0x164>
80005d46:	08 95       	mov	r5,r4
80005d48:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005d4a:	c0 68       	rjmp	80005d56 <log+0xda>
							
							default:
							log("I need relax.");
80005d4c:	4a 6c       	lddpc	r12,80005de4 <log+0x168>
80005d4e:	f0 1f 00 23 	mcall	80005dd8 <log+0x15c>
80005d52:	08 95       	mov	r5,r4
80005d54:	06 9c       	mov	r12,r3
						}
						str++;
80005d56:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005d58:	1a dc       	st.w	--sp,r12
80005d5a:	1a d6       	st.w	--sp,r6
80005d5c:	4a 3b       	lddpc	r11,80005de8 <log+0x16c>
80005d5e:	0c 9c       	mov	r12,r6
80005d60:	f0 1f 00 23 	mcall	80005dec <log+0x170>
80005d64:	2f ed       	sub	sp,-8
80005d66:	c0 a8       	rjmp	80005d7a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005d68:	2f f7       	sub	r7,-1
80005d6a:	1a d8       	st.w	--sp,r8
80005d6c:	1a d6       	st.w	--sp,r6
80005d6e:	4a 1b       	lddpc	r11,80005df0 <log+0x174>
80005d70:	0c 9c       	mov	r12,r6
80005d72:	f0 1f 00 1f 	mcall	80005dec <log+0x170>
80005d76:	08 95       	mov	r5,r4
80005d78:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005d7a:	0f 89       	ld.ub	r9,r7[0x0]
80005d7c:	30 08       	mov	r8,0
80005d7e:	f0 09 18 00 	cp.b	r9,r8
80005d82:	c0 30       	breq	80005d88 <log+0x10c>
80005d84:	0a 94       	mov	r4,r5
80005d86:	c9 2b       	rjmp	80005caa <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005d88:	fa c7 fe f8 	sub	r7,sp,-264
80005d8c:	1a d7       	st.w	--sp,r7
80005d8e:	49 ab       	lddpc	r11,80005df4 <log+0x178>
80005d90:	0e 9c       	mov	r12,r7
80005d92:	f0 1f 00 17 	mcall	80005dec <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005d96:	5c 5c       	castu.b	r12
80005d98:	f8 c6 ff ff 	sub	r6,r12,-1
80005d9c:	0c 9c       	mov	r12,r6
80005d9e:	f0 1f 00 17 	mcall	80005df8 <log+0x17c>
80005da2:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005da4:	0c 9a       	mov	r10,r6
80005da6:	0e 9b       	mov	r11,r7
80005da8:	f0 1f 00 15 	mcall	80005dfc <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80005dac:	30 09       	mov	r9,0
80005dae:	30 5a       	mov	r10,5
80005db0:	fa cb fe f8 	sub	r11,sp,-264
80005db4:	49 38       	lddpc	r8,80005e00 <log+0x184>
80005db6:	70 0c       	ld.w	r12,r8[0x0]
80005db8:	f0 1f 00 13 	mcall	80005e04 <log+0x188>
80005dbc:	2f fd       	sub	sp,-4
}
80005dbe:	fe 3d fd f8 	sub	sp,-520
80005dc2:	d8 32       	popm	r0-r7,pc
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	67 24       	ld.w	r4,r3[0x48]
80005dc8:	00 00       	add	r0,r0
80005dca:	0d 68       	ld.uh	r8,--r6
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	cc 8c       	rcall	80005f5e <logFromISR+0x156>
80005dd0:	80 00       	ld.sh	r0,r0[0x0]
80005dd2:	5b a2       	cp.w	r2,-6
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	cf 38       	rjmp	80005fbc <log_init+0x34>
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	5c 7c       	castu.h	r12
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	5a f0       	cp.w	r0,-17
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	5a ec       	cp.w	r12,-18
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	cf 48       	rjmp	80005fce <log_init+0x46>
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	cf 58       	rjmp	80005fd4 <log_init+0x4c>
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	6a 14       	ld.w	r4,r5[0x4]
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	cf 60       	breq	80005dde <log+0x162>
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	cf 68       	rjmp	80005fe2 <log_init+0x5a>
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	4d 38       	lddpc	r8,80005f44 <logFromISR+0x13c>
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	65 dc       	ld.w	r12,r2[0x74]
80005e00:	00 00       	add	r0,r0
80005e02:	41 0c       	lddsp	r12,sp[0x40]
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	50 8c       	stdsp	sp[0x20],r12

80005e08 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80005e08:	d4 31       	pushm	r0-r7,lr
80005e0a:	fa cd 02 0c 	sub	sp,sp,524
80005e0e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80005e10:	e0 6a 01 00 	mov	r10,256
80005e14:	30 0b       	mov	r11,0
80005e16:	fa cc fe f4 	sub	r12,sp,-268
80005e1a:	f0 1f 00 4c 	mcall	80005f48 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80005e1e:	fa c4 fd d0 	sub	r4,sp,-560
80005e22:	30 0a       	mov	r10,0
80005e24:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005e26:	fa c3 ff fc 	sub	r3,sp,-4
80005e2a:	e0 61 01 00 	mov	r1,256
80005e2e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80005e30:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005e32:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005e36:	02 9a       	mov	r10,r1
80005e38:	00 9b       	mov	r11,r0
80005e3a:	06 9c       	mov	r12,r3
80005e3c:	f0 1f 00 43 	mcall	80005f48 <logFromISR+0x140>
			
			if(*str == '%')
80005e40:	0f 88       	ld.ub	r8,r7[0x0]
80005e42:	e4 08 18 00 	cp.b	r8,r2
80005e46:	c5 11       	brne	80005ee8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80005e48:	ee c8 ff ff 	sub	r8,r7,-1
80005e4c:	11 89       	ld.ub	r9,r8[0x0]
80005e4e:	4c 0a       	lddpc	r10,80005f4c <logFromISR+0x144>
80005e50:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80005e52:	23 09       	sub	r9,48
80005e54:	30 9a       	mov	r10,9
80005e56:	f4 09 18 00 	cp.b	r9,r10
80005e5a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80005e5e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005e62:	f7 b9 08 30 	subls	r9,48
80005e66:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80005e6a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80005e6e:	0f 88       	ld.ub	r8,r7[0x0]
80005e70:	22 58       	sub	r8,37
80005e72:	e0 48 00 53 	cp.w	r8,83
80005e76:	e0 8b 00 2b 	brhi	80005ecc <logFromISR+0xc4>
80005e7a:	4b 69       	lddpc	r9,80005f50 <logFromISR+0x148>
80005e7c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80005e80:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80005e84:	06 9a       	mov	r10,r3
80005e86:	40 0b       	lddsp	r11,sp[0x0]
80005e88:	5c 5b       	castu.b	r11
80005e8a:	68 0c       	ld.w	r12,r4[0x0]
80005e8c:	f0 1f 00 32 	mcall	80005f54 <logFromISR+0x14c>
					break;
80005e90:	c2 38       	rjmp	80005ed6 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80005e92:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80005e96:	06 9a       	mov	r10,r3
80005e98:	40 0b       	lddsp	r11,sp[0x0]
80005e9a:	5c 5b       	castu.b	r11
80005e9c:	68 0c       	ld.w	r12,r4[0x0]
80005e9e:	f0 1f 00 2f 	mcall	80005f58 <logFromISR+0x150>
80005ea2:	06 9c       	mov	r12,r3
					break;
80005ea4:	c1 98       	rjmp	80005ed6 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80005ea6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80005eaa:	06 9b       	mov	r11,r3
80005eac:	09 bc       	ld.ub	r12,r4[0x3]
80005eae:	f0 1f 00 2c 	mcall	80005f5c <logFromISR+0x154>
80005eb2:	06 9c       	mov	r12,r3
					break;
80005eb4:	c1 18       	rjmp	80005ed6 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80005eb6:	e8 c5 ff fc 	sub	r5,r4,-4
80005eba:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80005ebc:	c0 d8       	rjmp	80005ed6 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80005ebe:	06 9b       	mov	r11,r3
80005ec0:	32 5c       	mov	r12,37
80005ec2:	f0 1f 00 27 	mcall	80005f5c <logFromISR+0x154>
80005ec6:	08 95       	mov	r5,r4
80005ec8:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80005eca:	c0 68       	rjmp	80005ed6 <logFromISR+0xce>
					default:
					log("I need relax.");
80005ecc:	4a 5c       	lddpc	r12,80005f60 <logFromISR+0x158>
80005ece:	f0 1f 00 26 	mcall	80005f64 <logFromISR+0x15c>
80005ed2:	08 95       	mov	r5,r4
80005ed4:	06 9c       	mov	r12,r3
				}
				str++;
80005ed6:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005ed8:	1a dc       	st.w	--sp,r12
80005eda:	1a d6       	st.w	--sp,r6
80005edc:	4a 3b       	lddpc	r11,80005f68 <logFromISR+0x160>
80005ede:	0c 9c       	mov	r12,r6
80005ee0:	f0 1f 00 23 	mcall	80005f6c <logFromISR+0x164>
80005ee4:	2f ed       	sub	sp,-8
80005ee6:	c0 a8       	rjmp	80005efa <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005ee8:	2f f7       	sub	r7,-1
80005eea:	1a d8       	st.w	--sp,r8
80005eec:	1a d6       	st.w	--sp,r6
80005eee:	4a 1b       	lddpc	r11,80005f70 <logFromISR+0x168>
80005ef0:	0c 9c       	mov	r12,r6
80005ef2:	f0 1f 00 1f 	mcall	80005f6c <logFromISR+0x164>
80005ef6:	08 95       	mov	r5,r4
80005ef8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80005efa:	0f 89       	ld.ub	r9,r7[0x0]
80005efc:	30 08       	mov	r8,0
80005efe:	f0 09 18 00 	cp.b	r9,r8
80005f02:	c0 30       	breq	80005f08 <logFromISR+0x100>
80005f04:	0a 94       	mov	r4,r5
80005f06:	c9 8b       	rjmp	80005e36 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80005f08:	fa c7 fe f4 	sub	r7,sp,-268
80005f0c:	1a d7       	st.w	--sp,r7
80005f0e:	49 ab       	lddpc	r11,80005f74 <logFromISR+0x16c>
80005f10:	0e 9c       	mov	r12,r7
80005f12:	f0 1f 00 17 	mcall	80005f6c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80005f16:	5c 5c       	castu.b	r12
80005f18:	f8 c6 ff ff 	sub	r6,r12,-1
80005f1c:	0c 9c       	mov	r12,r6
80005f1e:	f0 1f 00 17 	mcall	80005f78 <logFromISR+0x170>
80005f22:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80005f24:	0c 9a       	mov	r10,r6
80005f26:	0e 9b       	mov	r11,r7
80005f28:	f0 1f 00 15 	mcall	80005f7c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005f2c:	30 09       	mov	r9,0
80005f2e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80005f30:	fa ca fe f8 	sub	r10,sp,-264
80005f34:	fa cb fe f4 	sub	r11,sp,-268
80005f38:	49 28       	lddpc	r8,80005f80 <logFromISR+0x178>
80005f3a:	70 0c       	ld.w	r12,r8[0x0]
80005f3c:	f0 1f 00 12 	mcall	80005f84 <logFromISR+0x17c>
80005f40:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80005f42:	fe 3d fd f4 	sub	sp,-524
80005f46:	d8 32       	popm	r0-r7,pc
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	67 24       	ld.w	r4,r3[0x48]
80005f4c:	00 00       	add	r0,r0
80005f4e:	0d 69       	ld.uh	r9,--r6
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	cd dc       	rcall	8000610c <gpio_enable_module_pin+0x4c>
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	5b a2       	cp.w	r2,-6
80005f58:	80 00       	ld.sh	r0,r0[0x0]
80005f5a:	5a f0       	cp.w	r0,-17
80005f5c:	80 00       	ld.sh	r0,r0[0x0]
80005f5e:	5a ec       	cp.w	r12,-18
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	cf 48       	rjmp	8000614a <_stext+0x6>
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	5c 7c       	castu.h	r12
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	cf 58       	rjmp	80006154 <_stext+0x10>
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	6a 14       	ld.w	r4,r5[0x4]
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	cf 60       	breq	80005f5e <logFromISR+0x156>
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	cf 68       	rjmp	80006162 <idata_load_loop+0x2>
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	4d 38       	lddpc	r8,800060c4 <gpio_enable_module_pin+0x4>
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	65 dc       	ld.w	r12,r2[0x74]
80005f80:	00 00       	add	r0,r0
80005f82:	41 0c       	lddsp	r12,sp[0x40]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	50 3c       	stdsp	sp[0xc],r12

80005f88 <log_init>:
		
	return str;
}

void log_init(void)
{
80005f88:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005f8a:	30 2b       	mov	r11,2
80005f8c:	49 0c       	lddpc	r12,80005fcc <log_init+0x44>
80005f8e:	f0 1f 00 11 	mcall	80005fd0 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80005f92:	e0 6a 36 00 	mov	r10,13824
80005f96:	ea 1a 01 6e 	orh	r10,0x16e
80005f9a:	48 fb       	lddpc	r11,80005fd4 <log_init+0x4c>
80005f9c:	fe 7c 18 00 	mov	r12,-59392
80005fa0:	f0 1f 00 0e 	mcall	80005fd8 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005fa4:	30 4b       	mov	r11,4
80005fa6:	33 2c       	mov	r12,50
80005fa8:	f0 1f 00 0d 	mcall	80005fdc <log_init+0x54>
80005fac:	48 d8       	lddpc	r8,80005fe0 <log_init+0x58>
80005fae:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80005fb0:	30 09       	mov	r9,0
80005fb2:	1a d9       	st.w	--sp,r9
80005fb4:	1a d9       	st.w	--sp,r9
80005fb6:	1a d9       	st.w	--sp,r9
80005fb8:	30 28       	mov	r8,2
80005fba:	e0 6a 01 80 	mov	r10,384
80005fbe:	48 ab       	lddpc	r11,80005fe4 <log_init+0x5c>
80005fc0:	48 ac       	lddpc	r12,80005fe8 <log_init+0x60>
80005fc2:	f0 1f 00 0b 	mcall	80005fec <log_init+0x64>
80005fc6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005fc8:	d8 02       	popm	pc
80005fca:	00 00       	add	r0,r0
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	cf 74       	brge	80005fbc <log_init+0x34>
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	61 14       	ld.w	r4,r0[0x44]
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	cf 2c       	rcall	800061ba <_malloc_r+0x16>
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	48 dc       	lddpc	r12,8000600c <task_log+0x1c>
80005fdc:	80 00       	ld.sh	r0,r0[0x0]
80005fde:	51 e4       	stdsp	sp[0x78],r4
80005fe0:	00 00       	add	r0,r0
80005fe2:	41 0c       	lddsp	r12,sp[0x40]
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	cf 70       	breq	80005fd4 <log_init+0x4c>
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	5f f0       	sral	r0
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	58 b8       	cp.w	r8,11

80005ff0 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80005ff0:	eb cd 40 f8 	pushm	r3-r7,lr
80005ff4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005ff6:	48 c7       	lddpc	r7,80006024 <task_log+0x34>
80005ff8:	30 05       	mov	r5,0
80005ffa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80005ffc:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006000:	0a 99       	mov	r9,r5
80006002:	08 9a       	mov	r10,r4
80006004:	1a 9b       	mov	r11,sp
80006006:	6e 0c       	ld.w	r12,r7[0x0]
80006008:	f0 1f 00 08 	mcall	80006028 <task_log+0x38>
8000600c:	58 1c       	cp.w	r12,1
8000600e:	cf 91       	brne	80006000 <task_log+0x10>
		{
			if( NULL != str)
80006010:	40 0b       	lddsp	r11,sp[0x0]
80006012:	58 0b       	cp.w	r11,0
80006014:	cf 60       	breq	80006000 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006016:	06 9c       	mov	r12,r3
80006018:	f0 1f 00 05 	mcall	8000602c <task_log+0x3c>
				vPortFree(str);
8000601c:	40 0c       	lddsp	r12,sp[0x0]
8000601e:	f0 1f 00 05 	mcall	80006030 <task_log+0x40>
80006022:	ce fb       	rjmp	80006000 <task_log+0x10>
80006024:	00 00       	add	r0,r0
80006026:	41 0c       	lddsp	r12,sp[0x40]
80006028:	80 00       	ld.sh	r0,r0[0x0]
8000602a:	4e 80       	lddpc	r0,800061c8 <_malloc_r+0x24>
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	48 8c       	lddpc	r12,8000604c <main+0x18>
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	4d 10       	lddpc	r0,80006174 <idata_load_loop_end+0xc>

80006034 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006034:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006036:	fe 78 10 00 	mov	r8,-61440
8000603a:	30 19       	mov	r9,1
8000603c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006040:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006044:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006048:	d3 03       	ssrf	0x10
	local_start_pll0();
8000604a:	f0 1f 00 13 	mcall	80006094 <main+0x60>
		
	INTC_init_interrupts();
8000604e:	f0 1f 00 13 	mcall	80006098 <main+0x64>
	
	log_init();		
80006052:	f0 1f 00 13 	mcall	8000609c <main+0x68>
	log("----start debug----");	
80006056:	49 3c       	lddpc	r12,800060a0 <main+0x6c>
80006058:	f0 1f 00 13 	mcall	800060a4 <main+0x70>
		
	rtc_init();
8000605c:	f0 1f 00 13 	mcall	800060a8 <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006060:	f0 1f 00 13 	mcall	800060ac <main+0x78>
			
	xcmp_init();
80006064:	f0 1f 00 13 	mcall	800060b0 <main+0x7c>
	
	app_init();
80006068:	f0 1f 00 13 	mcall	800060b4 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000606c:	fe 79 10 00 	mov	r9,-61440
80006070:	f2 f8 01 60 	ld.w	r8,r9[352]
80006074:	e2 18 00 02 	andl	r8,0x2,COH
80006078:	cf c0       	breq	80006070 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000607a:	fe 79 10 00 	mov	r9,-61440
8000607e:	f2 f8 01 60 	ld.w	r8,r9[352]
80006082:	e2 18 00 02 	andl	r8,0x2,COH
80006086:	cf c1       	brne	8000607e <main+0x4a>
	local_start_timer();
80006088:	f0 1f 00 0c 	mcall	800060b8 <main+0x84>
	
	Enable_global_interrupt();
8000608c:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000608e:	f0 1f 00 0c 	mcall	800060bc <main+0x88>
	return 0;
}
80006092:	d8 0a       	popm	pc,r12=0
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	41 ac       	lddsp	r12,sp[0x68]
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	43 c8       	lddsp	r8,sp[0xf0]
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	5f 88       	srls	r8
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	cf 84       	brge	80006092 <main+0x5e>
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	5c 7c       	castu.h	r12
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	41 fc       	lddsp	r12,sp[0x7c]
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	42 c4       	lddsp	r4,sp[0xb0]
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	3a b0       	mov	r0,-85
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	20 40       	sub	r0,4
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	42 88       	lddsp	r8,sp[0xa0]
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	5a a0       	cp.w	r0,-22

800060c0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800060c0:	f8 08 16 05 	lsr	r8,r12,0x5
800060c4:	a9 68       	lsl	r8,0x8
800060c6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800060ca:	58 1b       	cp.w	r11,1
800060cc:	c0 d0       	breq	800060e6 <gpio_enable_module_pin+0x26>
800060ce:	c0 63       	brcs	800060da <gpio_enable_module_pin+0x1a>
800060d0:	58 2b       	cp.w	r11,2
800060d2:	c1 00       	breq	800060f2 <gpio_enable_module_pin+0x32>
800060d4:	58 3b       	cp.w	r11,3
800060d6:	c1 40       	breq	800060fe <gpio_enable_module_pin+0x3e>
800060d8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800060da:	30 19       	mov	r9,1
800060dc:	f2 0c 09 49 	lsl	r9,r9,r12
800060e0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800060e2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800060e4:	c1 28       	rjmp	80006108 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800060e6:	30 19       	mov	r9,1
800060e8:	f2 0c 09 49 	lsl	r9,r9,r12
800060ec:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800060ee:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800060f0:	c0 c8       	rjmp	80006108 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800060f2:	30 19       	mov	r9,1
800060f4:	f2 0c 09 49 	lsl	r9,r9,r12
800060f8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800060fa:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800060fc:	c0 68       	rjmp	80006108 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800060fe:	30 19       	mov	r9,1
80006100:	f2 0c 09 49 	lsl	r9,r9,r12
80006104:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006106:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006108:	30 19       	mov	r9,1
8000610a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000610e:	91 2c       	st.w	r8[0x8],r12
80006110:	5e fd       	retal	0
80006112:	d7 03       	nop

80006114 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006114:	d4 21       	pushm	r4-r7,lr
80006116:	18 97       	mov	r7,r12
80006118:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000611a:	58 0b       	cp.w	r11,0
8000611c:	c0 31       	brne	80006122 <gpio_enable_module+0xe>
8000611e:	30 05       	mov	r5,0
80006120:	c0 d8       	rjmp	8000613a <gpio_enable_module+0x26>
80006122:	30 06       	mov	r6,0
80006124:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006126:	6e 1b       	ld.w	r11,r7[0x4]
80006128:	6e 0c       	ld.w	r12,r7[0x0]
8000612a:	f0 1f 00 06 	mcall	80006140 <gpio_enable_module+0x2c>
8000612e:	18 45       	or	r5,r12
		gpiomap++;
80006130:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006132:	2f f6       	sub	r6,-1
80006134:	0c 34       	cp.w	r4,r6
80006136:	fe 9b ff f8 	brhi	80006126 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000613a:	0a 9c       	mov	r12,r5
8000613c:	d8 22       	popm	r4-r7,pc
8000613e:	00 00       	add	r0,r0
80006140:	80 00       	ld.sh	r0,r0[0x0]
80006142:	60 c0       	ld.w	r0,r0[0x30]

80006144 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006144:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006148:	fe c0 a5 48 	sub	r0,pc,-23224

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000614c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006150:	d5 53       	csrf	0x15
  cp      r0, r1
80006152:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006154:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006158:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000615a:	c0 72       	brcc	80006168 <idata_load_loop_end>
  cp      r0, r1
8000615c:	fe c2 8c 3c 	sub	r2,pc,-29636

80006160 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006160:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006162:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006164:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80006166:	cf d3       	brcs	80006160 <idata_load_loop>

80006168 <idata_load_loop_end>:
  mov     r2, 0
80006168:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
8000616c:	e0 61 41 18 	mov	r1,16664
  cp      r0, r1
  brlo    udata_clear_loop
80006170:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006172:	c0 62       	brcc	8000617e <udata_clear_loop_end>
80006174:	30 02       	mov	r2,0
80006176:	30 03       	mov	r3,0

80006178 <udata_clear_loop>:
80006178:	a1 22       	st.d	r0++,r2
8000617a:	02 30       	cp.w	r0,r1
8000617c:	cf e3       	brcs	80006178 <udata_clear_loop>

8000617e <udata_clear_loop_end>:
8000617e:	fe cf 01 4a 	sub	pc,pc,330
80006182:	d7 03       	nop

80006184 <free>:
80006184:	d4 01       	pushm	lr
80006186:	e0 68 0a 38 	mov	r8,2616
8000618a:	18 9b       	mov	r11,r12
8000618c:	70 0c       	ld.w	r12,r8[0x0]
8000618e:	e0 a0 1e 6d 	rcall	80009e68 <_free_r>
80006192:	d8 02       	popm	pc

80006194 <malloc>:
80006194:	d4 01       	pushm	lr
80006196:	e0 68 0a 38 	mov	r8,2616
8000619a:	18 9b       	mov	r11,r12
8000619c:	70 0c       	ld.w	r12,r8[0x0]
8000619e:	c0 3c       	rcall	800061a4 <_malloc_r>
800061a0:	d8 02       	popm	pc
800061a2:	d7 03       	nop

800061a4 <_malloc_r>:
800061a4:	d4 31       	pushm	r0-r7,lr
800061a6:	f6 c8 ff f5 	sub	r8,r11,-11
800061aa:	18 95       	mov	r5,r12
800061ac:	10 97       	mov	r7,r8
800061ae:	e0 17 ff f8 	andl	r7,0xfff8
800061b2:	59 68       	cp.w	r8,22
800061b4:	f9 b7 08 10 	movls	r7,16
800061b8:	16 37       	cp.w	r7,r11
800061ba:	5f 38       	srlo	r8
800061bc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800061c0:	c0 50       	breq	800061ca <_malloc_r+0x26>
800061c2:	30 c8       	mov	r8,12
800061c4:	99 38       	st.w	r12[0xc],r8
800061c6:	e0 8f 01 fa 	bral	800065ba <_malloc_r+0x416>
800061ca:	fe b0 f5 59 	rcall	80004c7c <__malloc_lock>
800061ce:	e0 47 01 f7 	cp.w	r7,503
800061d2:	e0 8b 00 1d 	brhi	8000620c <_malloc_r+0x68>
800061d6:	ee 03 16 03 	lsr	r3,r7,0x3
800061da:	e0 68 05 38 	mov	r8,1336
800061de:	f0 03 00 38 	add	r8,r8,r3<<0x3
800061e2:	70 36       	ld.w	r6,r8[0xc]
800061e4:	10 36       	cp.w	r6,r8
800061e6:	c0 61       	brne	800061f2 <_malloc_r+0x4e>
800061e8:	ec c8 ff f8 	sub	r8,r6,-8
800061ec:	70 36       	ld.w	r6,r8[0xc]
800061ee:	10 36       	cp.w	r6,r8
800061f0:	c0 c0       	breq	80006208 <_malloc_r+0x64>
800061f2:	6c 18       	ld.w	r8,r6[0x4]
800061f4:	e0 18 ff fc 	andl	r8,0xfffc
800061f8:	6c 3a       	ld.w	r10,r6[0xc]
800061fa:	ec 08 00 09 	add	r9,r6,r8
800061fe:	0a 9c       	mov	r12,r5
80006200:	6c 28       	ld.w	r8,r6[0x8]
80006202:	95 28       	st.w	r10[0x8],r8
80006204:	91 3a       	st.w	r8[0xc],r10
80006206:	c4 78       	rjmp	80006294 <_malloc_r+0xf0>
80006208:	2f e3       	sub	r3,-2
8000620a:	c4 d8       	rjmp	800062a4 <_malloc_r+0x100>
8000620c:	ee 03 16 09 	lsr	r3,r7,0x9
80006210:	c0 41       	brne	80006218 <_malloc_r+0x74>
80006212:	ee 03 16 03 	lsr	r3,r7,0x3
80006216:	c2 68       	rjmp	80006262 <_malloc_r+0xbe>
80006218:	58 43       	cp.w	r3,4
8000621a:	e0 8b 00 06 	brhi	80006226 <_malloc_r+0x82>
8000621e:	ee 03 16 06 	lsr	r3,r7,0x6
80006222:	2c 83       	sub	r3,-56
80006224:	c1 f8       	rjmp	80006262 <_malloc_r+0xbe>
80006226:	59 43       	cp.w	r3,20
80006228:	e0 8b 00 04 	brhi	80006230 <_malloc_r+0x8c>
8000622c:	2a 53       	sub	r3,-91
8000622e:	c1 a8       	rjmp	80006262 <_malloc_r+0xbe>
80006230:	e0 43 00 54 	cp.w	r3,84
80006234:	e0 8b 00 06 	brhi	80006240 <_malloc_r+0x9c>
80006238:	ee 03 16 0c 	lsr	r3,r7,0xc
8000623c:	29 23       	sub	r3,-110
8000623e:	c1 28       	rjmp	80006262 <_malloc_r+0xbe>
80006240:	e0 43 01 54 	cp.w	r3,340
80006244:	e0 8b 00 06 	brhi	80006250 <_malloc_r+0xac>
80006248:	ee 03 16 0f 	lsr	r3,r7,0xf
8000624c:	28 93       	sub	r3,-119
8000624e:	c0 a8       	rjmp	80006262 <_malloc_r+0xbe>
80006250:	e0 43 05 54 	cp.w	r3,1364
80006254:	e0 88 00 04 	brls	8000625c <_malloc_r+0xb8>
80006258:	37 e3       	mov	r3,126
8000625a:	c0 48       	rjmp	80006262 <_malloc_r+0xbe>
8000625c:	ee 03 16 12 	lsr	r3,r7,0x12
80006260:	28 43       	sub	r3,-124
80006262:	e0 6a 05 38 	mov	r10,1336
80006266:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000626a:	74 36       	ld.w	r6,r10[0xc]
8000626c:	c1 98       	rjmp	8000629e <_malloc_r+0xfa>
8000626e:	6c 19       	ld.w	r9,r6[0x4]
80006270:	e0 19 ff fc 	andl	r9,0xfffc
80006274:	f2 07 01 0b 	sub	r11,r9,r7
80006278:	58 fb       	cp.w	r11,15
8000627a:	e0 8a 00 04 	brle	80006282 <_malloc_r+0xde>
8000627e:	20 13       	sub	r3,1
80006280:	c1 18       	rjmp	800062a2 <_malloc_r+0xfe>
80006282:	6c 38       	ld.w	r8,r6[0xc]
80006284:	58 0b       	cp.w	r11,0
80006286:	c0 b5       	brlt	8000629c <_malloc_r+0xf8>
80006288:	6c 2a       	ld.w	r10,r6[0x8]
8000628a:	ec 09 00 09 	add	r9,r6,r9
8000628e:	0a 9c       	mov	r12,r5
80006290:	91 2a       	st.w	r8[0x8],r10
80006292:	95 38       	st.w	r10[0xc],r8
80006294:	72 18       	ld.w	r8,r9[0x4]
80006296:	a1 a8       	sbr	r8,0x0
80006298:	93 18       	st.w	r9[0x4],r8
8000629a:	cb c8       	rjmp	80006412 <_malloc_r+0x26e>
8000629c:	10 96       	mov	r6,r8
8000629e:	14 36       	cp.w	r6,r10
800062a0:	ce 71       	brne	8000626e <_malloc_r+0xca>
800062a2:	2f f3       	sub	r3,-1
800062a4:	e0 6a 05 38 	mov	r10,1336
800062a8:	f4 cc ff f8 	sub	r12,r10,-8
800062ac:	78 26       	ld.w	r6,r12[0x8]
800062ae:	18 36       	cp.w	r6,r12
800062b0:	c6 c0       	breq	80006388 <_malloc_r+0x1e4>
800062b2:	6c 19       	ld.w	r9,r6[0x4]
800062b4:	e0 19 ff fc 	andl	r9,0xfffc
800062b8:	f2 07 01 08 	sub	r8,r9,r7
800062bc:	58 f8       	cp.w	r8,15
800062be:	e0 89 00 8f 	brgt	800063dc <_malloc_r+0x238>
800062c2:	99 3c       	st.w	r12[0xc],r12
800062c4:	99 2c       	st.w	r12[0x8],r12
800062c6:	58 08       	cp.w	r8,0
800062c8:	c0 55       	brlt	800062d2 <_malloc_r+0x12e>
800062ca:	ec 09 00 09 	add	r9,r6,r9
800062ce:	0a 9c       	mov	r12,r5
800062d0:	ce 2b       	rjmp	80006294 <_malloc_r+0xf0>
800062d2:	e0 49 01 ff 	cp.w	r9,511
800062d6:	e0 8b 00 13 	brhi	800062fc <_malloc_r+0x158>
800062da:	a3 99       	lsr	r9,0x3
800062dc:	f4 09 00 38 	add	r8,r10,r9<<0x3
800062e0:	70 2b       	ld.w	r11,r8[0x8]
800062e2:	8d 38       	st.w	r6[0xc],r8
800062e4:	8d 2b       	st.w	r6[0x8],r11
800062e6:	97 36       	st.w	r11[0xc],r6
800062e8:	91 26       	st.w	r8[0x8],r6
800062ea:	a3 49       	asr	r9,0x2
800062ec:	74 18       	ld.w	r8,r10[0x4]
800062ee:	30 1b       	mov	r11,1
800062f0:	f6 09 09 49 	lsl	r9,r11,r9
800062f4:	f1 e9 10 09 	or	r9,r8,r9
800062f8:	95 19       	st.w	r10[0x4],r9
800062fa:	c4 78       	rjmp	80006388 <_malloc_r+0x1e4>
800062fc:	f2 0a 16 09 	lsr	r10,r9,0x9
80006300:	58 4a       	cp.w	r10,4
80006302:	e0 8b 00 07 	brhi	80006310 <_malloc_r+0x16c>
80006306:	f2 0a 16 06 	lsr	r10,r9,0x6
8000630a:	2c 8a       	sub	r10,-56
8000630c:	c2 08       	rjmp	8000634c <_malloc_r+0x1a8>
8000630e:	d7 03       	nop
80006310:	59 4a       	cp.w	r10,20
80006312:	e0 8b 00 04 	brhi	8000631a <_malloc_r+0x176>
80006316:	2a 5a       	sub	r10,-91
80006318:	c1 a8       	rjmp	8000634c <_malloc_r+0x1a8>
8000631a:	e0 4a 00 54 	cp.w	r10,84
8000631e:	e0 8b 00 06 	brhi	8000632a <_malloc_r+0x186>
80006322:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006326:	29 2a       	sub	r10,-110
80006328:	c1 28       	rjmp	8000634c <_malloc_r+0x1a8>
8000632a:	e0 4a 01 54 	cp.w	r10,340
8000632e:	e0 8b 00 06 	brhi	8000633a <_malloc_r+0x196>
80006332:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006336:	28 9a       	sub	r10,-119
80006338:	c0 a8       	rjmp	8000634c <_malloc_r+0x1a8>
8000633a:	e0 4a 05 54 	cp.w	r10,1364
8000633e:	e0 88 00 04 	brls	80006346 <_malloc_r+0x1a2>
80006342:	37 ea       	mov	r10,126
80006344:	c0 48       	rjmp	8000634c <_malloc_r+0x1a8>
80006346:	f2 0a 16 12 	lsr	r10,r9,0x12
8000634a:	28 4a       	sub	r10,-124
8000634c:	e0 6b 05 38 	mov	r11,1336
80006350:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006354:	68 28       	ld.w	r8,r4[0x8]
80006356:	08 38       	cp.w	r8,r4
80006358:	c0 e1       	brne	80006374 <_malloc_r+0x1d0>
8000635a:	76 19       	ld.w	r9,r11[0x4]
8000635c:	a3 4a       	asr	r10,0x2
8000635e:	30 1e       	mov	lr,1
80006360:	fc 0a 09 4a 	lsl	r10,lr,r10
80006364:	f3 ea 10 0a 	or	r10,r9,r10
80006368:	10 99       	mov	r9,r8
8000636a:	97 1a       	st.w	r11[0x4],r10
8000636c:	c0 a8       	rjmp	80006380 <_malloc_r+0x1dc>
8000636e:	70 28       	ld.w	r8,r8[0x8]
80006370:	08 38       	cp.w	r8,r4
80006372:	c0 60       	breq	8000637e <_malloc_r+0x1da>
80006374:	70 1a       	ld.w	r10,r8[0x4]
80006376:	e0 1a ff fc 	andl	r10,0xfffc
8000637a:	14 39       	cp.w	r9,r10
8000637c:	cf 93       	brcs	8000636e <_malloc_r+0x1ca>
8000637e:	70 39       	ld.w	r9,r8[0xc]
80006380:	8d 39       	st.w	r6[0xc],r9
80006382:	8d 28       	st.w	r6[0x8],r8
80006384:	91 36       	st.w	r8[0xc],r6
80006386:	93 26       	st.w	r9[0x8],r6
80006388:	e6 08 14 02 	asr	r8,r3,0x2
8000638c:	30 1b       	mov	r11,1
8000638e:	e0 64 05 38 	mov	r4,1336
80006392:	f6 08 09 4b 	lsl	r11,r11,r8
80006396:	68 18       	ld.w	r8,r4[0x4]
80006398:	10 3b       	cp.w	r11,r8
8000639a:	e0 8b 00 6b 	brhi	80006470 <_malloc_r+0x2cc>
8000639e:	f7 e8 00 09 	and	r9,r11,r8
800063a2:	c0 b1       	brne	800063b8 <_malloc_r+0x214>
800063a4:	e0 13 ff fc 	andl	r3,0xfffc
800063a8:	a1 7b       	lsl	r11,0x1
800063aa:	2f c3       	sub	r3,-4
800063ac:	c0 38       	rjmp	800063b2 <_malloc_r+0x20e>
800063ae:	2f c3       	sub	r3,-4
800063b0:	a1 7b       	lsl	r11,0x1
800063b2:	f7 e8 00 09 	and	r9,r11,r8
800063b6:	cf c0       	breq	800063ae <_malloc_r+0x20a>
800063b8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800063bc:	06 92       	mov	r2,r3
800063be:	1c 91       	mov	r1,lr
800063c0:	62 36       	ld.w	r6,r1[0xc]
800063c2:	c2 e8       	rjmp	8000641e <_malloc_r+0x27a>
800063c4:	6c 1a       	ld.w	r10,r6[0x4]
800063c6:	e0 1a ff fc 	andl	r10,0xfffc
800063ca:	f4 07 01 08 	sub	r8,r10,r7
800063ce:	58 f8       	cp.w	r8,15
800063d0:	e0 8a 00 15 	brle	800063fa <_malloc_r+0x256>
800063d4:	6c 3a       	ld.w	r10,r6[0xc]
800063d6:	6c 29       	ld.w	r9,r6[0x8]
800063d8:	95 29       	st.w	r10[0x8],r9
800063da:	93 3a       	st.w	r9[0xc],r10
800063dc:	0e 99       	mov	r9,r7
800063de:	ec 07 00 07 	add	r7,r6,r7
800063e2:	a1 a9       	sbr	r9,0x0
800063e4:	99 37       	st.w	r12[0xc],r7
800063e6:	99 27       	st.w	r12[0x8],r7
800063e8:	8d 19       	st.w	r6[0x4],r9
800063ea:	ee 08 09 08 	st.w	r7[r8],r8
800063ee:	8f 2c       	st.w	r7[0x8],r12
800063f0:	8f 3c       	st.w	r7[0xc],r12
800063f2:	a1 a8       	sbr	r8,0x0
800063f4:	0a 9c       	mov	r12,r5
800063f6:	8f 18       	st.w	r7[0x4],r8
800063f8:	c0 d8       	rjmp	80006412 <_malloc_r+0x26e>
800063fa:	6c 39       	ld.w	r9,r6[0xc]
800063fc:	58 08       	cp.w	r8,0
800063fe:	c0 f5       	brlt	8000641c <_malloc_r+0x278>
80006400:	ec 0a 00 0a 	add	r10,r6,r10
80006404:	74 18       	ld.w	r8,r10[0x4]
80006406:	a1 a8       	sbr	r8,0x0
80006408:	0a 9c       	mov	r12,r5
8000640a:	95 18       	st.w	r10[0x4],r8
8000640c:	6c 28       	ld.w	r8,r6[0x8]
8000640e:	93 28       	st.w	r9[0x8],r8
80006410:	91 39       	st.w	r8[0xc],r9
80006412:	fe b0 f4 3b 	rcall	80004c88 <__malloc_unlock>
80006416:	ec cc ff f8 	sub	r12,r6,-8
8000641a:	d8 32       	popm	r0-r7,pc
8000641c:	12 96       	mov	r6,r9
8000641e:	02 36       	cp.w	r6,r1
80006420:	cd 21       	brne	800063c4 <_malloc_r+0x220>
80006422:	2f f2       	sub	r2,-1
80006424:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006428:	c0 30       	breq	8000642e <_malloc_r+0x28a>
8000642a:	2f 81       	sub	r1,-8
8000642c:	cc ab       	rjmp	800063c0 <_malloc_r+0x21c>
8000642e:	1c 98       	mov	r8,lr
80006430:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006434:	c0 81       	brne	80006444 <_malloc_r+0x2a0>
80006436:	68 19       	ld.w	r9,r4[0x4]
80006438:	f6 08 11 ff 	rsub	r8,r11,-1
8000643c:	f3 e8 00 08 	and	r8,r9,r8
80006440:	89 18       	st.w	r4[0x4],r8
80006442:	c0 78       	rjmp	80006450 <_malloc_r+0x2ac>
80006444:	f0 c9 00 08 	sub	r9,r8,8
80006448:	20 13       	sub	r3,1
8000644a:	70 08       	ld.w	r8,r8[0x0]
8000644c:	12 38       	cp.w	r8,r9
8000644e:	cf 10       	breq	80006430 <_malloc_r+0x28c>
80006450:	a1 7b       	lsl	r11,0x1
80006452:	68 18       	ld.w	r8,r4[0x4]
80006454:	10 3b       	cp.w	r11,r8
80006456:	e0 8b 00 0d 	brhi	80006470 <_malloc_r+0x2cc>
8000645a:	58 0b       	cp.w	r11,0
8000645c:	c0 a0       	breq	80006470 <_malloc_r+0x2cc>
8000645e:	04 93       	mov	r3,r2
80006460:	c0 38       	rjmp	80006466 <_malloc_r+0x2c2>
80006462:	2f c3       	sub	r3,-4
80006464:	a1 7b       	lsl	r11,0x1
80006466:	f7 e8 00 09 	and	r9,r11,r8
8000646a:	ca 71       	brne	800063b8 <_malloc_r+0x214>
8000646c:	cf bb       	rjmp	80006462 <_malloc_r+0x2be>
8000646e:	d7 03       	nop
80006470:	68 23       	ld.w	r3,r4[0x8]
80006472:	66 12       	ld.w	r2,r3[0x4]
80006474:	e0 12 ff fc 	andl	r2,0xfffc
80006478:	0e 32       	cp.w	r2,r7
8000647a:	5f 39       	srlo	r9
8000647c:	e4 07 01 08 	sub	r8,r2,r7
80006480:	58 f8       	cp.w	r8,15
80006482:	5f aa       	srle	r10
80006484:	f5 e9 10 09 	or	r9,r10,r9
80006488:	e0 80 00 9a 	breq	800065bc <_malloc_r+0x418>
8000648c:	e0 68 0d 74 	mov	r8,3444
80006490:	70 01       	ld.w	r1,r8[0x0]
80006492:	e0 68 09 44 	mov	r8,2372
80006496:	2f 01       	sub	r1,-16
80006498:	70 08       	ld.w	r8,r8[0x0]
8000649a:	0e 01       	add	r1,r7
8000649c:	5b f8       	cp.w	r8,-1
8000649e:	c0 40       	breq	800064a6 <_malloc_r+0x302>
800064a0:	28 11       	sub	r1,-127
800064a2:	e0 11 ff 80 	andl	r1,0xff80
800064a6:	02 9b       	mov	r11,r1
800064a8:	0a 9c       	mov	r12,r5
800064aa:	e0 a0 02 a5 	rcall	800069f4 <_sbrk_r>
800064ae:	18 96       	mov	r6,r12
800064b0:	5b fc       	cp.w	r12,-1
800064b2:	c7 50       	breq	8000659c <_malloc_r+0x3f8>
800064b4:	e6 02 00 08 	add	r8,r3,r2
800064b8:	10 3c       	cp.w	r12,r8
800064ba:	c0 32       	brcc	800064c0 <_malloc_r+0x31c>
800064bc:	08 33       	cp.w	r3,r4
800064be:	c6 f1       	brne	8000659c <_malloc_r+0x3f8>
800064c0:	e0 6a 0d 78 	mov	r10,3448
800064c4:	74 09       	ld.w	r9,r10[0x0]
800064c6:	e2 09 00 09 	add	r9,r1,r9
800064ca:	95 09       	st.w	r10[0x0],r9
800064cc:	10 36       	cp.w	r6,r8
800064ce:	c0 a1       	brne	800064e2 <_malloc_r+0x33e>
800064d0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800064d4:	c0 71       	brne	800064e2 <_malloc_r+0x33e>
800064d6:	e2 02 00 02 	add	r2,r1,r2
800064da:	68 28       	ld.w	r8,r4[0x8]
800064dc:	a1 a2       	sbr	r2,0x0
800064de:	91 12       	st.w	r8[0x4],r2
800064e0:	c4 f8       	rjmp	8000657e <_malloc_r+0x3da>
800064e2:	e0 6a 09 44 	mov	r10,2372
800064e6:	74 0b       	ld.w	r11,r10[0x0]
800064e8:	5b fb       	cp.w	r11,-1
800064ea:	c0 31       	brne	800064f0 <_malloc_r+0x34c>
800064ec:	95 06       	st.w	r10[0x0],r6
800064ee:	c0 78       	rjmp	800064fc <_malloc_r+0x358>
800064f0:	ec 09 00 09 	add	r9,r6,r9
800064f4:	e0 6a 0d 78 	mov	r10,3448
800064f8:	10 19       	sub	r9,r8
800064fa:	95 09       	st.w	r10[0x0],r9
800064fc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006500:	f0 09 11 08 	rsub	r9,r8,8
80006504:	58 08       	cp.w	r8,0
80006506:	f2 08 17 10 	movne	r8,r9
8000650a:	ed d8 e1 06 	addne	r6,r6,r8
8000650e:	28 08       	sub	r8,-128
80006510:	ec 01 00 01 	add	r1,r6,r1
80006514:	0a 9c       	mov	r12,r5
80006516:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000651a:	f0 01 01 01 	sub	r1,r8,r1
8000651e:	02 9b       	mov	r11,r1
80006520:	e0 a0 02 6a 	rcall	800069f4 <_sbrk_r>
80006524:	e0 68 0d 78 	mov	r8,3448
80006528:	5b fc       	cp.w	r12,-1
8000652a:	ec 0c 17 00 	moveq	r12,r6
8000652e:	f9 b1 00 00 	moveq	r1,0
80006532:	70 09       	ld.w	r9,r8[0x0]
80006534:	0c 1c       	sub	r12,r6
80006536:	89 26       	st.w	r4[0x8],r6
80006538:	02 0c       	add	r12,r1
8000653a:	12 01       	add	r1,r9
8000653c:	a1 ac       	sbr	r12,0x0
8000653e:	91 01       	st.w	r8[0x0],r1
80006540:	8d 1c       	st.w	r6[0x4],r12
80006542:	08 33       	cp.w	r3,r4
80006544:	c1 d0       	breq	8000657e <_malloc_r+0x3da>
80006546:	58 f2       	cp.w	r2,15
80006548:	e0 8b 00 05 	brhi	80006552 <_malloc_r+0x3ae>
8000654c:	30 18       	mov	r8,1
8000654e:	8d 18       	st.w	r6[0x4],r8
80006550:	c2 68       	rjmp	8000659c <_malloc_r+0x3f8>
80006552:	30 59       	mov	r9,5
80006554:	20 c2       	sub	r2,12
80006556:	e0 12 ff f8 	andl	r2,0xfff8
8000655a:	e6 02 00 08 	add	r8,r3,r2
8000655e:	91 29       	st.w	r8[0x8],r9
80006560:	91 19       	st.w	r8[0x4],r9
80006562:	66 18       	ld.w	r8,r3[0x4]
80006564:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006568:	e5 e8 10 08 	or	r8,r2,r8
8000656c:	87 18       	st.w	r3[0x4],r8
8000656e:	58 f2       	cp.w	r2,15
80006570:	e0 88 00 07 	brls	8000657e <_malloc_r+0x3da>
80006574:	e6 cb ff f8 	sub	r11,r3,-8
80006578:	0a 9c       	mov	r12,r5
8000657a:	e0 a0 1c 77 	rcall	80009e68 <_free_r>
8000657e:	e0 69 0d 70 	mov	r9,3440
80006582:	72 0a       	ld.w	r10,r9[0x0]
80006584:	e0 68 0d 78 	mov	r8,3448
80006588:	70 08       	ld.w	r8,r8[0x0]
8000658a:	14 38       	cp.w	r8,r10
8000658c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006590:	e0 69 0d 6c 	mov	r9,3436
80006594:	72 0a       	ld.w	r10,r9[0x0]
80006596:	14 38       	cp.w	r8,r10
80006598:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000659c:	68 28       	ld.w	r8,r4[0x8]
8000659e:	70 18       	ld.w	r8,r8[0x4]
800065a0:	e0 18 ff fc 	andl	r8,0xfffc
800065a4:	0e 38       	cp.w	r8,r7
800065a6:	5f 39       	srlo	r9
800065a8:	0e 18       	sub	r8,r7
800065aa:	58 f8       	cp.w	r8,15
800065ac:	5f aa       	srle	r10
800065ae:	f5 e9 10 09 	or	r9,r10,r9
800065b2:	c0 50       	breq	800065bc <_malloc_r+0x418>
800065b4:	0a 9c       	mov	r12,r5
800065b6:	fe b0 f3 69 	rcall	80004c88 <__malloc_unlock>
800065ba:	d8 3a       	popm	r0-r7,pc,r12=0
800065bc:	68 26       	ld.w	r6,r4[0x8]
800065be:	a1 a8       	sbr	r8,0x0
800065c0:	0e 99       	mov	r9,r7
800065c2:	a1 a9       	sbr	r9,0x0
800065c4:	8d 19       	st.w	r6[0x4],r9
800065c6:	ec 07 00 07 	add	r7,r6,r7
800065ca:	0a 9c       	mov	r12,r5
800065cc:	89 27       	st.w	r4[0x8],r7
800065ce:	8f 18       	st.w	r7[0x4],r8
800065d0:	fe b0 f3 5c 	rcall	80004c88 <__malloc_unlock>
800065d4:	ec cc ff f8 	sub	r12,r6,-8
800065d8:	d8 32       	popm	r0-r7,pc
800065da:	d7 03       	nop

800065dc <memcpy>:
800065dc:	58 8a       	cp.w	r10,8
800065de:	c2 f5       	brlt	8000663c <memcpy+0x60>
800065e0:	f9 eb 10 09 	or	r9,r12,r11
800065e4:	e2 19 00 03 	andl	r9,0x3,COH
800065e8:	e0 81 00 97 	brne	80006716 <memcpy+0x13a>
800065ec:	e0 4a 00 20 	cp.w	r10,32
800065f0:	c3 b4       	brge	80006666 <memcpy+0x8a>
800065f2:	f4 08 14 02 	asr	r8,r10,0x2
800065f6:	f0 09 11 08 	rsub	r9,r8,8
800065fa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800065fe:	76 69       	ld.w	r9,r11[0x18]
80006600:	99 69       	st.w	r12[0x18],r9
80006602:	76 59       	ld.w	r9,r11[0x14]
80006604:	99 59       	st.w	r12[0x14],r9
80006606:	76 49       	ld.w	r9,r11[0x10]
80006608:	99 49       	st.w	r12[0x10],r9
8000660a:	76 39       	ld.w	r9,r11[0xc]
8000660c:	99 39       	st.w	r12[0xc],r9
8000660e:	76 29       	ld.w	r9,r11[0x8]
80006610:	99 29       	st.w	r12[0x8],r9
80006612:	76 19       	ld.w	r9,r11[0x4]
80006614:	99 19       	st.w	r12[0x4],r9
80006616:	76 09       	ld.w	r9,r11[0x0]
80006618:	99 09       	st.w	r12[0x0],r9
8000661a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000661e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006622:	e0 1a 00 03 	andl	r10,0x3
80006626:	f4 0a 11 04 	rsub	r10,r10,4
8000662a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000662e:	17 a9       	ld.ub	r9,r11[0x2]
80006630:	b0 a9       	st.b	r8[0x2],r9
80006632:	17 99       	ld.ub	r9,r11[0x1]
80006634:	b0 99       	st.b	r8[0x1],r9
80006636:	17 89       	ld.ub	r9,r11[0x0]
80006638:	b0 89       	st.b	r8[0x0],r9
8000663a:	5e fc       	retal	r12
8000663c:	f4 0a 11 09 	rsub	r10,r10,9
80006640:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006644:	17 f9       	ld.ub	r9,r11[0x7]
80006646:	b8 f9       	st.b	r12[0x7],r9
80006648:	17 e9       	ld.ub	r9,r11[0x6]
8000664a:	b8 e9       	st.b	r12[0x6],r9
8000664c:	17 d9       	ld.ub	r9,r11[0x5]
8000664e:	b8 d9       	st.b	r12[0x5],r9
80006650:	17 c9       	ld.ub	r9,r11[0x4]
80006652:	b8 c9       	st.b	r12[0x4],r9
80006654:	17 b9       	ld.ub	r9,r11[0x3]
80006656:	b8 b9       	st.b	r12[0x3],r9
80006658:	17 a9       	ld.ub	r9,r11[0x2]
8000665a:	b8 a9       	st.b	r12[0x2],r9
8000665c:	17 99       	ld.ub	r9,r11[0x1]
8000665e:	b8 99       	st.b	r12[0x1],r9
80006660:	17 89       	ld.ub	r9,r11[0x0]
80006662:	b8 89       	st.b	r12[0x0],r9
80006664:	5e fc       	retal	r12
80006666:	eb cd 40 c0 	pushm	r6-r7,lr
8000666a:	18 99       	mov	r9,r12
8000666c:	22 0a       	sub	r10,32
8000666e:	b7 07       	ld.d	r6,r11++
80006670:	b3 26       	st.d	r9++,r6
80006672:	b7 07       	ld.d	r6,r11++
80006674:	b3 26       	st.d	r9++,r6
80006676:	b7 07       	ld.d	r6,r11++
80006678:	b3 26       	st.d	r9++,r6
8000667a:	b7 07       	ld.d	r6,r11++
8000667c:	b3 26       	st.d	r9++,r6
8000667e:	22 0a       	sub	r10,32
80006680:	cf 74       	brge	8000666e <memcpy+0x92>
80006682:	2f 0a       	sub	r10,-16
80006684:	c0 65       	brlt	80006690 <memcpy+0xb4>
80006686:	b7 07       	ld.d	r6,r11++
80006688:	b3 26       	st.d	r9++,r6
8000668a:	b7 07       	ld.d	r6,r11++
8000668c:	b3 26       	st.d	r9++,r6
8000668e:	21 0a       	sub	r10,16
80006690:	5c 3a       	neg	r10
80006692:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006696:	d7 03       	nop
80006698:	d7 03       	nop
8000669a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000669e:	f3 66 00 0e 	st.b	r9[14],r6
800066a2:	f7 36 00 0d 	ld.ub	r6,r11[13]
800066a6:	f3 66 00 0d 	st.b	r9[13],r6
800066aa:	f7 36 00 0c 	ld.ub	r6,r11[12]
800066ae:	f3 66 00 0c 	st.b	r9[12],r6
800066b2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800066b6:	f3 66 00 0b 	st.b	r9[11],r6
800066ba:	f7 36 00 0a 	ld.ub	r6,r11[10]
800066be:	f3 66 00 0a 	st.b	r9[10],r6
800066c2:	f7 36 00 09 	ld.ub	r6,r11[9]
800066c6:	f3 66 00 09 	st.b	r9[9],r6
800066ca:	f7 36 00 08 	ld.ub	r6,r11[8]
800066ce:	f3 66 00 08 	st.b	r9[8],r6
800066d2:	f7 36 00 07 	ld.ub	r6,r11[7]
800066d6:	f3 66 00 07 	st.b	r9[7],r6
800066da:	f7 36 00 06 	ld.ub	r6,r11[6]
800066de:	f3 66 00 06 	st.b	r9[6],r6
800066e2:	f7 36 00 05 	ld.ub	r6,r11[5]
800066e6:	f3 66 00 05 	st.b	r9[5],r6
800066ea:	f7 36 00 04 	ld.ub	r6,r11[4]
800066ee:	f3 66 00 04 	st.b	r9[4],r6
800066f2:	f7 36 00 03 	ld.ub	r6,r11[3]
800066f6:	f3 66 00 03 	st.b	r9[3],r6
800066fa:	f7 36 00 02 	ld.ub	r6,r11[2]
800066fe:	f3 66 00 02 	st.b	r9[2],r6
80006702:	f7 36 00 01 	ld.ub	r6,r11[1]
80006706:	f3 66 00 01 	st.b	r9[1],r6
8000670a:	f7 36 00 00 	ld.ub	r6,r11[0]
8000670e:	f3 66 00 00 	st.b	r9[0],r6
80006712:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006716:	20 1a       	sub	r10,1
80006718:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000671c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006720:	cf b1       	brne	80006716 <memcpy+0x13a>
80006722:	5e fc       	retal	r12

80006724 <memset>:
80006724:	18 98       	mov	r8,r12
80006726:	c0 38       	rjmp	8000672c <memset+0x8>
80006728:	10 cb       	st.b	r8++,r11
8000672a:	20 1a       	sub	r10,1
8000672c:	58 0a       	cp.w	r10,0
8000672e:	cf d1       	brne	80006728 <memset+0x4>
80006730:	5e fc       	retal	r12
80006732:	d7 03       	nop

80006734 <_realloc_r>:
80006734:	d4 31       	pushm	r0-r7,lr
80006736:	20 1d       	sub	sp,4
80006738:	16 94       	mov	r4,r11
8000673a:	18 92       	mov	r2,r12
8000673c:	14 9b       	mov	r11,r10
8000673e:	58 04       	cp.w	r4,0
80006740:	c0 51       	brne	8000674a <_realloc_r+0x16>
80006742:	fe b0 fd 31 	rcall	800061a4 <_malloc_r>
80006746:	18 95       	mov	r5,r12
80006748:	c5 39       	rjmp	800069ee <_realloc_r+0x2ba>
8000674a:	50 0a       	stdsp	sp[0x0],r10
8000674c:	fe b0 f2 98 	rcall	80004c7c <__malloc_lock>
80006750:	40 0b       	lddsp	r11,sp[0x0]
80006752:	f6 c8 ff f5 	sub	r8,r11,-11
80006756:	e8 c1 00 08 	sub	r1,r4,8
8000675a:	10 96       	mov	r6,r8
8000675c:	62 1c       	ld.w	r12,r1[0x4]
8000675e:	e0 16 ff f8 	andl	r6,0xfff8
80006762:	59 68       	cp.w	r8,22
80006764:	f9 b6 08 10 	movls	r6,16
80006768:	16 36       	cp.w	r6,r11
8000676a:	5f 38       	srlo	r8
8000676c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006770:	c0 50       	breq	8000677a <_realloc_r+0x46>
80006772:	30 c8       	mov	r8,12
80006774:	30 05       	mov	r5,0
80006776:	85 38       	st.w	r2[0xc],r8
80006778:	c3 b9       	rjmp	800069ee <_realloc_r+0x2ba>
8000677a:	18 90       	mov	r0,r12
8000677c:	e0 10 ff fc 	andl	r0,0xfffc
80006780:	0c 30       	cp.w	r0,r6
80006782:	e0 84 01 0b 	brge	80006998 <_realloc_r+0x264>
80006786:	e0 68 05 38 	mov	r8,1336
8000678a:	e2 00 00 09 	add	r9,r1,r0
8000678e:	70 25       	ld.w	r5,r8[0x8]
80006790:	0a 39       	cp.w	r9,r5
80006792:	c0 90       	breq	800067a4 <_realloc_r+0x70>
80006794:	72 1a       	ld.w	r10,r9[0x4]
80006796:	a1 ca       	cbr	r10,0x0
80006798:	f2 0a 00 0a 	add	r10,r9,r10
8000679c:	74 1a       	ld.w	r10,r10[0x4]
8000679e:	ed ba 00 00 	bld	r10,0x0
800067a2:	c2 20       	breq	800067e6 <_realloc_r+0xb2>
800067a4:	72 1a       	ld.w	r10,r9[0x4]
800067a6:	e0 1a ff fc 	andl	r10,0xfffc
800067aa:	f4 00 00 03 	add	r3,r10,r0
800067ae:	0a 39       	cp.w	r9,r5
800067b0:	c1 31       	brne	800067d6 <_realloc_r+0xa2>
800067b2:	ec c7 ff f0 	sub	r7,r6,-16
800067b6:	0e 33       	cp.w	r3,r7
800067b8:	c1 95       	brlt	800067ea <_realloc_r+0xb6>
800067ba:	e2 06 00 09 	add	r9,r1,r6
800067be:	0c 13       	sub	r3,r6
800067c0:	a1 a3       	sbr	r3,0x0
800067c2:	93 13       	st.w	r9[0x4],r3
800067c4:	91 29       	st.w	r8[0x8],r9
800067c6:	04 9c       	mov	r12,r2
800067c8:	62 18       	ld.w	r8,r1[0x4]
800067ca:	08 95       	mov	r5,r4
800067cc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800067d0:	10 46       	or	r6,r8
800067d2:	83 16       	st.w	r1[0x4],r6
800067d4:	c0 b9       	rjmp	800069ea <_realloc_r+0x2b6>
800067d6:	0c 33       	cp.w	r3,r6
800067d8:	c0 95       	brlt	800067ea <_realloc_r+0xb6>
800067da:	72 28       	ld.w	r8,r9[0x8]
800067dc:	02 97       	mov	r7,r1
800067de:	72 39       	ld.w	r9,r9[0xc]
800067e0:	93 28       	st.w	r9[0x8],r8
800067e2:	91 39       	st.w	r8[0xc],r9
800067e4:	cd c8       	rjmp	8000699c <_realloc_r+0x268>
800067e6:	30 0a       	mov	r10,0
800067e8:	14 99       	mov	r9,r10
800067ea:	ed bc 00 00 	bld	r12,0x0
800067ee:	e0 80 00 95 	breq	80006918 <_realloc_r+0x1e4>
800067f2:	62 07       	ld.w	r7,r1[0x0]
800067f4:	e2 07 01 07 	sub	r7,r1,r7
800067f8:	6e 1c       	ld.w	r12,r7[0x4]
800067fa:	e0 1c ff fc 	andl	r12,0xfffc
800067fe:	58 09       	cp.w	r9,0
80006800:	c5 60       	breq	800068ac <_realloc_r+0x178>
80006802:	f8 00 00 03 	add	r3,r12,r0
80006806:	0a 39       	cp.w	r9,r5
80006808:	c4 81       	brne	80006898 <_realloc_r+0x164>
8000680a:	14 03       	add	r3,r10
8000680c:	ec c9 ff f0 	sub	r9,r6,-16
80006810:	12 33       	cp.w	r3,r9
80006812:	c4 d5       	brlt	800068ac <_realloc_r+0x178>
80006814:	6e 3a       	ld.w	r10,r7[0xc]
80006816:	6e 29       	ld.w	r9,r7[0x8]
80006818:	95 29       	st.w	r10[0x8],r9
8000681a:	93 3a       	st.w	r9[0xc],r10
8000681c:	ee c5 ff f8 	sub	r5,r7,-8
80006820:	e0 ca 00 04 	sub	r10,r0,4
80006824:	e0 4a 00 24 	cp.w	r10,36
80006828:	e0 8b 00 25 	brhi	80006872 <_realloc_r+0x13e>
8000682c:	0a 99       	mov	r9,r5
8000682e:	59 3a       	cp.w	r10,19
80006830:	e0 88 00 1a 	brls	80006864 <_realloc_r+0x130>
80006834:	09 09       	ld.w	r9,r4++
80006836:	8b 09       	st.w	r5[0x0],r9
80006838:	09 09       	ld.w	r9,r4++
8000683a:	8f 39       	st.w	r7[0xc],r9
8000683c:	ee c9 ff f0 	sub	r9,r7,-16
80006840:	59 ba       	cp.w	r10,27
80006842:	e0 88 00 11 	brls	80006864 <_realloc_r+0x130>
80006846:	09 0b       	ld.w	r11,r4++
80006848:	93 0b       	st.w	r9[0x0],r11
8000684a:	09 09       	ld.w	r9,r4++
8000684c:	8f 59       	st.w	r7[0x14],r9
8000684e:	ee c9 ff e8 	sub	r9,r7,-24
80006852:	e0 4a 00 24 	cp.w	r10,36
80006856:	c0 71       	brne	80006864 <_realloc_r+0x130>
80006858:	09 0a       	ld.w	r10,r4++
8000685a:	93 0a       	st.w	r9[0x0],r10
8000685c:	ee c9 ff e0 	sub	r9,r7,-32
80006860:	09 0a       	ld.w	r10,r4++
80006862:	8f 7a       	st.w	r7[0x1c],r10
80006864:	09 0a       	ld.w	r10,r4++
80006866:	12 aa       	st.w	r9++,r10
80006868:	68 0a       	ld.w	r10,r4[0x0]
8000686a:	93 0a       	st.w	r9[0x0],r10
8000686c:	68 1a       	ld.w	r10,r4[0x4]
8000686e:	93 1a       	st.w	r9[0x4],r10
80006870:	c0 78       	rjmp	8000687e <_realloc_r+0x14a>
80006872:	50 08       	stdsp	sp[0x0],r8
80006874:	08 9b       	mov	r11,r4
80006876:	0a 9c       	mov	r12,r5
80006878:	e0 a0 1d 9b 	rcall	8000a3ae <memmove>
8000687c:	40 08       	lddsp	r8,sp[0x0]
8000687e:	ee 06 00 09 	add	r9,r7,r6
80006882:	0c 13       	sub	r3,r6
80006884:	a1 a3       	sbr	r3,0x0
80006886:	93 13       	st.w	r9[0x4],r3
80006888:	91 29       	st.w	r8[0x8],r9
8000688a:	04 9c       	mov	r12,r2
8000688c:	6e 18       	ld.w	r8,r7[0x4]
8000688e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006892:	10 46       	or	r6,r8
80006894:	8f 16       	st.w	r7[0x4],r6
80006896:	ca a8       	rjmp	800069ea <_realloc_r+0x2b6>
80006898:	14 03       	add	r3,r10
8000689a:	0c 33       	cp.w	r3,r6
8000689c:	c0 85       	brlt	800068ac <_realloc_r+0x178>
8000689e:	72 28       	ld.w	r8,r9[0x8]
800068a0:	72 39       	ld.w	r9,r9[0xc]
800068a2:	93 28       	st.w	r9[0x8],r8
800068a4:	91 39       	st.w	r8[0xc],r9
800068a6:	6e 28       	ld.w	r8,r7[0x8]
800068a8:	6e 39       	ld.w	r9,r7[0xc]
800068aa:	c0 78       	rjmp	800068b8 <_realloc_r+0x184>
800068ac:	f8 00 00 03 	add	r3,r12,r0
800068b0:	0c 33       	cp.w	r3,r6
800068b2:	c3 35       	brlt	80006918 <_realloc_r+0x1e4>
800068b4:	6e 39       	ld.w	r9,r7[0xc]
800068b6:	6e 28       	ld.w	r8,r7[0x8]
800068b8:	93 28       	st.w	r9[0x8],r8
800068ba:	91 39       	st.w	r8[0xc],r9
800068bc:	e0 ca 00 04 	sub	r10,r0,4
800068c0:	ee cc ff f8 	sub	r12,r7,-8
800068c4:	e0 4a 00 24 	cp.w	r10,36
800068c8:	e0 8b 00 24 	brhi	80006910 <_realloc_r+0x1dc>
800068cc:	59 3a       	cp.w	r10,19
800068ce:	e0 88 00 1a 	brls	80006902 <_realloc_r+0x1ce>
800068d2:	09 08       	ld.w	r8,r4++
800068d4:	99 08       	st.w	r12[0x0],r8
800068d6:	09 08       	ld.w	r8,r4++
800068d8:	8f 38       	st.w	r7[0xc],r8
800068da:	ee cc ff f0 	sub	r12,r7,-16
800068de:	59 ba       	cp.w	r10,27
800068e0:	e0 88 00 11 	brls	80006902 <_realloc_r+0x1ce>
800068e4:	09 08       	ld.w	r8,r4++
800068e6:	99 08       	st.w	r12[0x0],r8
800068e8:	09 08       	ld.w	r8,r4++
800068ea:	8f 58       	st.w	r7[0x14],r8
800068ec:	ee cc ff e8 	sub	r12,r7,-24
800068f0:	e0 4a 00 24 	cp.w	r10,36
800068f4:	c0 71       	brne	80006902 <_realloc_r+0x1ce>
800068f6:	09 08       	ld.w	r8,r4++
800068f8:	99 08       	st.w	r12[0x0],r8
800068fa:	ee cc ff e0 	sub	r12,r7,-32
800068fe:	09 08       	ld.w	r8,r4++
80006900:	8f 78       	st.w	r7[0x1c],r8
80006902:	09 08       	ld.w	r8,r4++
80006904:	18 a8       	st.w	r12++,r8
80006906:	68 08       	ld.w	r8,r4[0x0]
80006908:	99 08       	st.w	r12[0x0],r8
8000690a:	68 18       	ld.w	r8,r4[0x4]
8000690c:	99 18       	st.w	r12[0x4],r8
8000690e:	c4 78       	rjmp	8000699c <_realloc_r+0x268>
80006910:	08 9b       	mov	r11,r4
80006912:	e0 a0 1d 4e 	rcall	8000a3ae <memmove>
80006916:	c4 38       	rjmp	8000699c <_realloc_r+0x268>
80006918:	04 9c       	mov	r12,r2
8000691a:	fe b0 fc 45 	rcall	800061a4 <_malloc_r>
8000691e:	18 95       	mov	r5,r12
80006920:	c3 a0       	breq	80006994 <_realloc_r+0x260>
80006922:	62 18       	ld.w	r8,r1[0x4]
80006924:	f8 c9 00 08 	sub	r9,r12,8
80006928:	a1 c8       	cbr	r8,0x0
8000692a:	e2 08 00 08 	add	r8,r1,r8
8000692e:	10 39       	cp.w	r9,r8
80006930:	c0 71       	brne	8000693e <_realloc_r+0x20a>
80006932:	72 13       	ld.w	r3,r9[0x4]
80006934:	02 97       	mov	r7,r1
80006936:	e0 13 ff fc 	andl	r3,0xfffc
8000693a:	00 03       	add	r3,r0
8000693c:	c3 08       	rjmp	8000699c <_realloc_r+0x268>
8000693e:	e0 ca 00 04 	sub	r10,r0,4
80006942:	e0 4a 00 24 	cp.w	r10,36
80006946:	e0 8b 00 20 	brhi	80006986 <_realloc_r+0x252>
8000694a:	08 99       	mov	r9,r4
8000694c:	18 98       	mov	r8,r12
8000694e:	59 3a       	cp.w	r10,19
80006950:	e0 88 00 14 	brls	80006978 <_realloc_r+0x244>
80006954:	13 0b       	ld.w	r11,r9++
80006956:	10 ab       	st.w	r8++,r11
80006958:	13 0b       	ld.w	r11,r9++
8000695a:	10 ab       	st.w	r8++,r11
8000695c:	59 ba       	cp.w	r10,27
8000695e:	e0 88 00 0d 	brls	80006978 <_realloc_r+0x244>
80006962:	13 0b       	ld.w	r11,r9++
80006964:	10 ab       	st.w	r8++,r11
80006966:	13 0b       	ld.w	r11,r9++
80006968:	10 ab       	st.w	r8++,r11
8000696a:	e0 4a 00 24 	cp.w	r10,36
8000696e:	c0 51       	brne	80006978 <_realloc_r+0x244>
80006970:	13 0a       	ld.w	r10,r9++
80006972:	10 aa       	st.w	r8++,r10
80006974:	13 0a       	ld.w	r10,r9++
80006976:	10 aa       	st.w	r8++,r10
80006978:	13 0a       	ld.w	r10,r9++
8000697a:	10 aa       	st.w	r8++,r10
8000697c:	72 0a       	ld.w	r10,r9[0x0]
8000697e:	91 0a       	st.w	r8[0x0],r10
80006980:	72 19       	ld.w	r9,r9[0x4]
80006982:	91 19       	st.w	r8[0x4],r9
80006984:	c0 48       	rjmp	8000698c <_realloc_r+0x258>
80006986:	08 9b       	mov	r11,r4
80006988:	e0 a0 1d 13 	rcall	8000a3ae <memmove>
8000698c:	08 9b       	mov	r11,r4
8000698e:	04 9c       	mov	r12,r2
80006990:	e0 a0 1a 6c 	rcall	80009e68 <_free_r>
80006994:	04 9c       	mov	r12,r2
80006996:	c2 a8       	rjmp	800069ea <_realloc_r+0x2b6>
80006998:	00 93       	mov	r3,r0
8000699a:	02 97       	mov	r7,r1
8000699c:	e6 06 01 09 	sub	r9,r3,r6
800069a0:	6e 18       	ld.w	r8,r7[0x4]
800069a2:	58 f9       	cp.w	r9,15
800069a4:	e0 88 00 16 	brls	800069d0 <_realloc_r+0x29c>
800069a8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800069ac:	ed e8 10 08 	or	r8,r6,r8
800069b0:	8f 18       	st.w	r7[0x4],r8
800069b2:	12 98       	mov	r8,r9
800069b4:	a1 a8       	sbr	r8,0x0
800069b6:	ee 06 00 0b 	add	r11,r7,r6
800069ba:	f6 09 00 09 	add	r9,r11,r9
800069be:	97 18       	st.w	r11[0x4],r8
800069c0:	72 18       	ld.w	r8,r9[0x4]
800069c2:	a1 a8       	sbr	r8,0x0
800069c4:	2f 8b       	sub	r11,-8
800069c6:	93 18       	st.w	r9[0x4],r8
800069c8:	04 9c       	mov	r12,r2
800069ca:	e0 a0 1a 4f 	rcall	80009e68 <_free_r>
800069ce:	c0 b8       	rjmp	800069e4 <_realloc_r+0x2b0>
800069d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800069d4:	e7 e8 10 08 	or	r8,r3,r8
800069d8:	8f 18       	st.w	r7[0x4],r8
800069da:	ee 03 00 03 	add	r3,r7,r3
800069de:	66 18       	ld.w	r8,r3[0x4]
800069e0:	a1 a8       	sbr	r8,0x0
800069e2:	87 18       	st.w	r3[0x4],r8
800069e4:	04 9c       	mov	r12,r2
800069e6:	ee c5 ff f8 	sub	r5,r7,-8
800069ea:	fe b0 f1 4f 	rcall	80004c88 <__malloc_unlock>
800069ee:	0a 9c       	mov	r12,r5
800069f0:	2f fd       	sub	sp,-4
800069f2:	d8 32       	popm	r0-r7,pc

800069f4 <_sbrk_r>:
800069f4:	d4 21       	pushm	r4-r7,lr
800069f6:	30 08       	mov	r8,0
800069f8:	18 97       	mov	r7,r12
800069fa:	e0 66 41 10 	mov	r6,16656
800069fe:	16 9c       	mov	r12,r11
80006a00:	8d 08       	st.w	r6[0x0],r8
80006a02:	c9 1c       	rcall	80006b24 <_sbrk>
80006a04:	5b fc       	cp.w	r12,-1
80006a06:	c0 51       	brne	80006a10 <_sbrk_r+0x1c>
80006a08:	6c 08       	ld.w	r8,r6[0x0]
80006a0a:	58 08       	cp.w	r8,0
80006a0c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006a10:	d8 22       	popm	r4-r7,pc
80006a12:	d7 03       	nop

80006a14 <sprintf>:
80006a14:	d4 01       	pushm	lr
80006a16:	21 7d       	sub	sp,92
80006a18:	e0 68 ff ff 	mov	r8,65535
80006a1c:	ea 18 7f ff 	orh	r8,0x7fff
80006a20:	50 58       	stdsp	sp[0x14],r8
80006a22:	50 28       	stdsp	sp[0x8],r8
80006a24:	e0 68 02 08 	mov	r8,520
80006a28:	ba 68       	st.h	sp[0xc],r8
80006a2a:	3f f8       	mov	r8,-1
80006a2c:	ba 78       	st.h	sp[0xe],r8
80006a2e:	e0 68 0a 38 	mov	r8,2616
80006a32:	50 4c       	stdsp	sp[0x10],r12
80006a34:	16 9a       	mov	r10,r11
80006a36:	50 0c       	stdsp	sp[0x0],r12
80006a38:	fa c9 ff a0 	sub	r9,sp,-96
80006a3c:	70 0c       	ld.w	r12,r8[0x0]
80006a3e:	1a 9b       	mov	r11,sp
80006a40:	e0 a0 02 26 	rcall	80006e8c <_vfprintf_r>
80006a44:	30 09       	mov	r9,0
80006a46:	40 08       	lddsp	r8,sp[0x0]
80006a48:	b0 89       	st.b	r8[0x0],r9
80006a4a:	2e 9d       	sub	sp,-92
80006a4c:	d8 02       	popm	pc
80006a4e:	d7 03       	nop

80006a50 <strlen>:
80006a50:	30 09       	mov	r9,0
80006a52:	18 98       	mov	r8,r12
80006a54:	c0 28       	rjmp	80006a58 <strlen+0x8>
80006a56:	2f f8       	sub	r8,-1
80006a58:	11 8a       	ld.ub	r10,r8[0x0]
80006a5a:	f2 0a 18 00 	cp.b	r10,r9
80006a5e:	cf c1       	brne	80006a56 <strlen+0x6>
80006a60:	f0 0c 01 0c 	sub	r12,r8,r12
80006a64:	5e fc       	retal	r12
80006a66:	d7 03       	nop

80006a68 <strncpy>:
80006a68:	30 08       	mov	r8,0
80006a6a:	10 3a       	cp.w	r10,r8
80006a6c:	5e 0c       	reteq	r12
80006a6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006a72:	f8 08 0b 09 	st.b	r12[r8],r9
80006a76:	2f f8       	sub	r8,-1
80006a78:	58 09       	cp.w	r9,0
80006a7a:	cf 81       	brne	80006a6a <strncpy+0x2>
80006a7c:	10 3a       	cp.w	r10,r8
80006a7e:	5e 0c       	reteq	r12
80006a80:	f8 08 0b 09 	st.b	r12[r8],r9
80006a84:	2f f8       	sub	r8,-1
80006a86:	cf bb       	rjmp	80006a7c <strncpy+0x14>

80006a88 <_close>:
80006a88:	30 28       	mov	r8,2
80006a8a:	d6 73       	breakpoint
80006a8c:	3f fc       	mov	r12,-1
80006a8e:	35 8b       	mov	r11,88
80006a90:	58 0c       	cp.w	r12,0
80006a92:	5e 4c       	retge	r12
80006a94:	e0 6a 41 10 	mov	r10,16656
80006a98:	95 0b       	st.w	r10[0x0],r11
80006a9a:	5e fc       	retal	r12

80006a9c <_lseek>:
80006a9c:	30 58       	mov	r8,5
80006a9e:	d6 73       	breakpoint
80006aa0:	3f fc       	mov	r12,-1
80006aa2:	35 8b       	mov	r11,88
80006aa4:	58 0c       	cp.w	r12,0
80006aa6:	5e 4c       	retge	r12
80006aa8:	e0 6a 41 10 	mov	r10,16656
80006aac:	95 0b       	st.w	r10[0x0],r11
80006aae:	5e fc       	retal	r12

80006ab0 <isatty>:
80006ab0:	30 b8       	mov	r8,11
80006ab2:	d6 73       	breakpoint
80006ab4:	3f fc       	mov	r12,-1
80006ab6:	35 8b       	mov	r11,88
80006ab8:	58 0c       	cp.w	r12,0
80006aba:	5e 4c       	retge	r12
80006abc:	e0 6a 41 10 	mov	r10,16656
80006ac0:	95 0b       	st.w	r10[0x0],r11
80006ac2:	5e fc       	retal	r12

80006ac4 <_fstat_host>:
80006ac4:	30 98       	mov	r8,9
80006ac6:	d6 73       	breakpoint
80006ac8:	3f fc       	mov	r12,-1
80006aca:	35 8b       	mov	r11,88
80006acc:	58 0c       	cp.w	r12,0
80006ace:	5e 4c       	retge	r12
80006ad0:	e0 6a 41 10 	mov	r10,16656
80006ad4:	95 0b       	st.w	r10[0x0],r11
80006ad6:	5e fc       	retal	r12

80006ad8 <_fstat>:
80006ad8:	d4 21       	pushm	r4-r7,lr
80006ada:	21 0d       	sub	sp,64
80006adc:	16 97       	mov	r7,r11
80006ade:	1a 9b       	mov	r11,sp
80006ae0:	cf 2f       	rcall	80006ac4 <_fstat_host>
80006ae2:	c0 34       	brge	80006ae8 <_fstat+0x10>
80006ae4:	3f fc       	mov	r12,-1
80006ae6:	c1 c8       	rjmp	80006b1e <_fstat+0x46>
80006ae8:	40 08       	lddsp	r8,sp[0x0]
80006aea:	ae 08       	st.h	r7[0x0],r8
80006aec:	40 18       	lddsp	r8,sp[0x4]
80006aee:	ae 18       	st.h	r7[0x2],r8
80006af0:	40 28       	lddsp	r8,sp[0x8]
80006af2:	8f 18       	st.w	r7[0x4],r8
80006af4:	40 38       	lddsp	r8,sp[0xc]
80006af6:	ae 48       	st.h	r7[0x8],r8
80006af8:	40 48       	lddsp	r8,sp[0x10]
80006afa:	ae 58       	st.h	r7[0xa],r8
80006afc:	40 58       	lddsp	r8,sp[0x14]
80006afe:	ae 68       	st.h	r7[0xc],r8
80006b00:	40 68       	lddsp	r8,sp[0x18]
80006b02:	ae 78       	st.h	r7[0xe],r8
80006b04:	40 88       	lddsp	r8,sp[0x20]
80006b06:	8f 48       	st.w	r7[0x10],r8
80006b08:	40 a8       	lddsp	r8,sp[0x28]
80006b0a:	8f b8       	st.w	r7[0x2c],r8
80006b0c:	40 c8       	lddsp	r8,sp[0x30]
80006b0e:	8f c8       	st.w	r7[0x30],r8
80006b10:	40 d8       	lddsp	r8,sp[0x34]
80006b12:	8f 58       	st.w	r7[0x14],r8
80006b14:	40 e8       	lddsp	r8,sp[0x38]
80006b16:	30 0c       	mov	r12,0
80006b18:	8f 78       	st.w	r7[0x1c],r8
80006b1a:	40 f8       	lddsp	r8,sp[0x3c]
80006b1c:	8f 98       	st.w	r7[0x24],r8
80006b1e:	2f 0d       	sub	sp,-64
80006b20:	d8 22       	popm	r4-r7,pc
80006b22:	d7 03       	nop

80006b24 <_sbrk>:
80006b24:	d4 01       	pushm	lr
80006b26:	e0 68 0d a0 	mov	r8,3488
80006b2a:	70 09       	ld.w	r9,r8[0x0]
80006b2c:	58 09       	cp.w	r9,0
80006b2e:	c0 41       	brne	80006b36 <_sbrk+0x12>
80006b30:	e0 69 41 18 	mov	r9,16664
80006b34:	91 09       	st.w	r8[0x0],r9
80006b36:	e0 69 0d a0 	mov	r9,3488
80006b3a:	e0 7a 70 00 	mov	r10,94208
80006b3e:	72 08       	ld.w	r8,r9[0x0]
80006b40:	f0 0c 00 0c 	add	r12,r8,r12
80006b44:	14 3c       	cp.w	r12,r10
80006b46:	e0 8b 00 04 	brhi	80006b4e <_sbrk+0x2a>
80006b4a:	93 0c       	st.w	r9[0x0],r12
80006b4c:	c0 68       	rjmp	80006b58 <_sbrk+0x34>
80006b4e:	e0 a0 18 15 	rcall	80009b78 <__errno>
80006b52:	30 c8       	mov	r8,12
80006b54:	99 08       	st.w	r12[0x0],r8
80006b56:	3f f8       	mov	r8,-1
80006b58:	10 9c       	mov	r12,r8
80006b5a:	d8 02       	popm	pc

80006b5c <get_arg>:
80006b5c:	d4 31       	pushm	r0-r7,lr
80006b5e:	20 8d       	sub	sp,32
80006b60:	fa c4 ff bc 	sub	r4,sp,-68
80006b64:	50 4b       	stdsp	sp[0x10],r11
80006b66:	68 2e       	ld.w	lr,r4[0x8]
80006b68:	50 58       	stdsp	sp[0x14],r8
80006b6a:	12 96       	mov	r6,r9
80006b6c:	7c 0b       	ld.w	r11,lr[0x0]
80006b6e:	70 05       	ld.w	r5,r8[0x0]
80006b70:	50 6e       	stdsp	sp[0x18],lr
80006b72:	58 0b       	cp.w	r11,0
80006b74:	f4 0b 17 00 	moveq	r11,r10
80006b78:	68 03       	ld.w	r3,r4[0x0]
80006b7a:	68 11       	ld.w	r1,r4[0x4]
80006b7c:	40 49       	lddsp	r9,sp[0x10]
80006b7e:	30 08       	mov	r8,0
80006b80:	c2 89       	rjmp	80006dd0 <get_arg+0x274>
80006b82:	2f fb       	sub	r11,-1
80006b84:	32 5c       	mov	r12,37
80006b86:	17 8a       	ld.ub	r10,r11[0x0]
80006b88:	f8 0a 18 00 	cp.b	r10,r12
80006b8c:	5f 1e       	srne	lr
80006b8e:	f0 0a 18 00 	cp.b	r10,r8
80006b92:	5f 1c       	srne	r12
80006b94:	fd ec 00 0c 	and	r12,lr,r12
80006b98:	f0 0c 18 00 	cp.b	r12,r8
80006b9c:	cf 31       	brne	80006b82 <get_arg+0x26>
80006b9e:	58 0a       	cp.w	r10,0
80006ba0:	e0 80 01 25 	breq	80006dea <get_arg+0x28e>
80006ba4:	30 0c       	mov	r12,0
80006ba6:	3f fa       	mov	r10,-1
80006ba8:	18 90       	mov	r0,r12
80006baa:	50 3a       	stdsp	sp[0xc],r10
80006bac:	18 94       	mov	r4,r12
80006bae:	18 92       	mov	r2,r12
80006bb0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006bb4:	16 97       	mov	r7,r11
80006bb6:	50 7c       	stdsp	sp[0x1c],r12
80006bb8:	fe cc 99 4c 	sub	r12,pc,-26292
80006bbc:	0f 3a       	ld.ub	r10,r7++
80006bbe:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006bc2:	40 7c       	lddsp	r12,sp[0x1c]
80006bc4:	1c 0c       	add	r12,lr
80006bc6:	fe ce 9a 22 	sub	lr,pc,-26078
80006bca:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006bce:	20 1e       	sub	lr,1
80006bd0:	50 0e       	stdsp	sp[0x0],lr
80006bd2:	fe ce 9a 9a 	sub	lr,pc,-25958
80006bd6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006bda:	50 7c       	stdsp	sp[0x1c],r12
80006bdc:	40 0c       	lddsp	r12,sp[0x0]
80006bde:	58 7c       	cp.w	r12,7
80006be0:	e0 8b 00 f1 	brhi	80006dc2 <get_arg+0x266>
80006be4:	fe ce 9c 4c 	sub	lr,pc,-25524
80006be8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006bec:	36 8b       	mov	r11,104
80006bee:	f6 0a 18 00 	cp.b	r10,r11
80006bf2:	e0 80 00 e8 	breq	80006dc2 <get_arg+0x266>
80006bf6:	37 1b       	mov	r11,113
80006bf8:	f6 0a 18 00 	cp.b	r10,r11
80006bfc:	c0 70       	breq	80006c0a <get_arg+0xae>
80006bfe:	34 cb       	mov	r11,76
80006c00:	f6 0a 18 00 	cp.b	r10,r11
80006c04:	c0 51       	brne	80006c0e <get_arg+0xb2>
80006c06:	a3 b4       	sbr	r4,0x3
80006c08:	cd d8       	rjmp	80006dc2 <get_arg+0x266>
80006c0a:	a5 b4       	sbr	r4,0x5
80006c0c:	cd b8       	rjmp	80006dc2 <get_arg+0x266>
80006c0e:	08 9a       	mov	r10,r4
80006c10:	0e 9b       	mov	r11,r7
80006c12:	a5 aa       	sbr	r10,0x4
80006c14:	17 3c       	ld.ub	r12,r11++
80006c16:	a5 b4       	sbr	r4,0x5
80006c18:	36 ce       	mov	lr,108
80006c1a:	fc 0c 18 00 	cp.b	r12,lr
80006c1e:	e0 80 00 d3 	breq	80006dc4 <get_arg+0x268>
80006c22:	14 94       	mov	r4,r10
80006c24:	cc f8       	rjmp	80006dc2 <get_arg+0x266>
80006c26:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006c2a:	36 7c       	mov	r12,103
80006c2c:	f8 0a 18 00 	cp.b	r10,r12
80006c30:	e0 8b 00 27 	brhi	80006c7e <get_arg+0x122>
80006c34:	36 5b       	mov	r11,101
80006c36:	f6 0a 18 00 	cp.b	r10,r11
80006c3a:	c4 82       	brcc	80006cca <get_arg+0x16e>
80006c3c:	34 fb       	mov	r11,79
80006c3e:	f6 0a 18 00 	cp.b	r10,r11
80006c42:	c4 80       	breq	80006cd2 <get_arg+0x176>
80006c44:	e0 8b 00 0c 	brhi	80006c5c <get_arg+0x100>
80006c48:	34 5b       	mov	r11,69
80006c4a:	f6 0a 18 00 	cp.b	r10,r11
80006c4e:	c3 e0       	breq	80006cca <get_arg+0x16e>
80006c50:	34 7b       	mov	r11,71
80006c52:	f6 0a 18 00 	cp.b	r10,r11
80006c56:	c3 a0       	breq	80006cca <get_arg+0x16e>
80006c58:	34 4b       	mov	r11,68
80006c5a:	c0 88       	rjmp	80006c6a <get_arg+0x10e>
80006c5c:	35 8b       	mov	r11,88
80006c5e:	f6 0a 18 00 	cp.b	r10,r11
80006c62:	c2 c0       	breq	80006cba <get_arg+0x15e>
80006c64:	e0 8b 00 07 	brhi	80006c72 <get_arg+0x116>
80006c68:	35 5b       	mov	r11,85
80006c6a:	f6 0a 18 00 	cp.b	r10,r11
80006c6e:	c3 51       	brne	80006cd8 <get_arg+0x17c>
80006c70:	c3 18       	rjmp	80006cd2 <get_arg+0x176>
80006c72:	36 3b       	mov	r11,99
80006c74:	f6 0a 18 00 	cp.b	r10,r11
80006c78:	c2 f0       	breq	80006cd6 <get_arg+0x17a>
80006c7a:	36 4b       	mov	r11,100
80006c7c:	c0 e8       	rjmp	80006c98 <get_arg+0x13c>
80006c7e:	37 0b       	mov	r11,112
80006c80:	f6 0a 18 00 	cp.b	r10,r11
80006c84:	c2 50       	breq	80006cce <get_arg+0x172>
80006c86:	e0 8b 00 0d 	brhi	80006ca0 <get_arg+0x144>
80006c8a:	36 eb       	mov	r11,110
80006c8c:	f6 0a 18 00 	cp.b	r10,r11
80006c90:	c1 f0       	breq	80006cce <get_arg+0x172>
80006c92:	e0 8b 00 14 	brhi	80006cba <get_arg+0x15e>
80006c96:	36 9b       	mov	r11,105
80006c98:	f6 0a 18 00 	cp.b	r10,r11
80006c9c:	c1 e1       	brne	80006cd8 <get_arg+0x17c>
80006c9e:	c0 e8       	rjmp	80006cba <get_arg+0x15e>
80006ca0:	37 5b       	mov	r11,117
80006ca2:	f6 0a 18 00 	cp.b	r10,r11
80006ca6:	c0 a0       	breq	80006cba <get_arg+0x15e>
80006ca8:	37 8b       	mov	r11,120
80006caa:	f6 0a 18 00 	cp.b	r10,r11
80006cae:	c0 60       	breq	80006cba <get_arg+0x15e>
80006cb0:	37 3b       	mov	r11,115
80006cb2:	f6 0a 18 00 	cp.b	r10,r11
80006cb6:	c1 11       	brne	80006cd8 <get_arg+0x17c>
80006cb8:	c0 b8       	rjmp	80006cce <get_arg+0x172>
80006cba:	ed b4 00 04 	bld	r4,0x4
80006cbe:	c0 a0       	breq	80006cd2 <get_arg+0x176>
80006cc0:	ed b4 00 05 	bld	r4,0x5
80006cc4:	c0 91       	brne	80006cd6 <get_arg+0x17a>
80006cc6:	30 20       	mov	r0,2
80006cc8:	c0 88       	rjmp	80006cd8 <get_arg+0x17c>
80006cca:	30 40       	mov	r0,4
80006ccc:	c0 68       	rjmp	80006cd8 <get_arg+0x17c>
80006cce:	30 30       	mov	r0,3
80006cd0:	c0 48       	rjmp	80006cd8 <get_arg+0x17c>
80006cd2:	30 10       	mov	r0,1
80006cd4:	c0 28       	rjmp	80006cd8 <get_arg+0x17c>
80006cd6:	30 00       	mov	r0,0
80006cd8:	40 3b       	lddsp	r11,sp[0xc]
80006cda:	5b fb       	cp.w	r11,-1
80006cdc:	c0 40       	breq	80006ce4 <get_arg+0x188>
80006cde:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006ce2:	c7 08       	rjmp	80006dc2 <get_arg+0x266>
80006ce4:	58 60       	cp.w	r0,6
80006ce6:	e0 8b 00 6e 	brhi	80006dc2 <get_arg+0x266>
80006cea:	6c 0a       	ld.w	r10,r6[0x0]
80006cec:	ea cc ff ff 	sub	r12,r5,-1
80006cf0:	fe ce 9d 38 	sub	lr,pc,-25288
80006cf4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006cf8:	f4 cb ff f8 	sub	r11,r10,-8
80006cfc:	8d 0b       	st.w	r6[0x0],r11
80006cfe:	f4 ea 00 00 	ld.d	r10,r10[0]
80006d02:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006d06:	c0 f8       	rjmp	80006d24 <get_arg+0x1c8>
80006d08:	f4 cb ff fc 	sub	r11,r10,-4
80006d0c:	8d 0b       	st.w	r6[0x0],r11
80006d0e:	74 0a       	ld.w	r10,r10[0x0]
80006d10:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006d14:	c0 88       	rjmp	80006d24 <get_arg+0x1c8>
80006d16:	f4 cb ff f8 	sub	r11,r10,-8
80006d1a:	8d 0b       	st.w	r6[0x0],r11
80006d1c:	f4 ea 00 00 	ld.d	r10,r10[0]
80006d20:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006d24:	0e 9b       	mov	r11,r7
80006d26:	18 95       	mov	r5,r12
80006d28:	c4 e8       	rjmp	80006dc4 <get_arg+0x268>
80006d2a:	62 0a       	ld.w	r10,r1[0x0]
80006d2c:	5b fa       	cp.w	r10,-1
80006d2e:	c0 b1       	brne	80006d44 <get_arg+0x1e8>
80006d30:	50 19       	stdsp	sp[0x4],r9
80006d32:	50 28       	stdsp	sp[0x8],r8
80006d34:	e0 6a 00 80 	mov	r10,128
80006d38:	30 0b       	mov	r11,0
80006d3a:	02 9c       	mov	r12,r1
80006d3c:	fe b0 fc f4 	rcall	80006724 <memset>
80006d40:	40 28       	lddsp	r8,sp[0x8]
80006d42:	40 19       	lddsp	r9,sp[0x4]
80006d44:	e4 cc 00 01 	sub	r12,r2,1
80006d48:	0e 9b       	mov	r11,r7
80006d4a:	50 3c       	stdsp	sp[0xc],r12
80006d4c:	f2 0c 0c 49 	max	r9,r9,r12
80006d50:	c3 a8       	rjmp	80006dc4 <get_arg+0x268>
80006d52:	62 0a       	ld.w	r10,r1[0x0]
80006d54:	5b fa       	cp.w	r10,-1
80006d56:	c0 b1       	brne	80006d6c <get_arg+0x210>
80006d58:	50 19       	stdsp	sp[0x4],r9
80006d5a:	50 28       	stdsp	sp[0x8],r8
80006d5c:	e0 6a 00 80 	mov	r10,128
80006d60:	30 0b       	mov	r11,0
80006d62:	02 9c       	mov	r12,r1
80006d64:	fe b0 fc e0 	rcall	80006724 <memset>
80006d68:	40 28       	lddsp	r8,sp[0x8]
80006d6a:	40 19       	lddsp	r9,sp[0x4]
80006d6c:	20 12       	sub	r2,1
80006d6e:	30 0a       	mov	r10,0
80006d70:	0e 9b       	mov	r11,r7
80006d72:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006d76:	f2 02 0c 49 	max	r9,r9,r2
80006d7a:	c2 58       	rjmp	80006dc4 <get_arg+0x268>
80006d7c:	16 97       	mov	r7,r11
80006d7e:	6c 0a       	ld.w	r10,r6[0x0]
80006d80:	f4 cb ff fc 	sub	r11,r10,-4
80006d84:	8d 0b       	st.w	r6[0x0],r11
80006d86:	74 0a       	ld.w	r10,r10[0x0]
80006d88:	0e 9b       	mov	r11,r7
80006d8a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006d8e:	2f f5       	sub	r5,-1
80006d90:	c1 a8       	rjmp	80006dc4 <get_arg+0x268>
80006d92:	f4 c2 00 30 	sub	r2,r10,48
80006d96:	c0 68       	rjmp	80006da2 <get_arg+0x246>
80006d98:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006d9c:	2f f7       	sub	r7,-1
80006d9e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006da2:	0f 8a       	ld.ub	r10,r7[0x0]
80006da4:	58 0a       	cp.w	r10,0
80006da6:	c0 e0       	breq	80006dc2 <get_arg+0x266>
80006da8:	23 0a       	sub	r10,48
80006daa:	58 9a       	cp.w	r10,9
80006dac:	fe 98 ff f6 	brls	80006d98 <get_arg+0x23c>
80006db0:	c0 98       	rjmp	80006dc2 <get_arg+0x266>
80006db2:	2f f7       	sub	r7,-1
80006db4:	0f 8a       	ld.ub	r10,r7[0x0]
80006db6:	58 0a       	cp.w	r10,0
80006db8:	c0 50       	breq	80006dc2 <get_arg+0x266>
80006dba:	23 0a       	sub	r10,48
80006dbc:	58 9a       	cp.w	r10,9
80006dbe:	fe 98 ff fa 	brls	80006db2 <get_arg+0x256>
80006dc2:	0e 9b       	mov	r11,r7
80006dc4:	40 7c       	lddsp	r12,sp[0x1c]
80006dc6:	30 ba       	mov	r10,11
80006dc8:	f4 0c 18 00 	cp.b	r12,r10
80006dcc:	fe 91 fe f2 	brne	80006bb0 <get_arg+0x54>
80006dd0:	40 42       	lddsp	r2,sp[0x10]
80006dd2:	17 8c       	ld.ub	r12,r11[0x0]
80006dd4:	0a 32       	cp.w	r2,r5
80006dd6:	5f 4a       	srge	r10
80006dd8:	f0 0c 18 00 	cp.b	r12,r8
80006ddc:	5f 1c       	srne	r12
80006dde:	f9 ea 00 0a 	and	r10,r12,r10
80006de2:	f0 0a 18 00 	cp.b	r10,r8
80006de6:	fe 91 fe cf 	brne	80006b84 <get_arg+0x28>
80006dea:	30 08       	mov	r8,0
80006dec:	40 4e       	lddsp	lr,sp[0x10]
80006dee:	17 8a       	ld.ub	r10,r11[0x0]
80006df0:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006df4:	f0 0a 18 00 	cp.b	r10,r8
80006df8:	fc 09 17 10 	movne	r9,lr
80006dfc:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006e00:	06 9e       	mov	lr,r3
80006e02:	c2 a8       	rjmp	80006e56 <get_arg+0x2fa>
80006e04:	62 0a       	ld.w	r10,r1[0x0]
80006e06:	58 3a       	cp.w	r10,3
80006e08:	c1 e0       	breq	80006e44 <get_arg+0x2e8>
80006e0a:	e0 89 00 07 	brgt	80006e18 <get_arg+0x2bc>
80006e0e:	58 1a       	cp.w	r10,1
80006e10:	c1 a0       	breq	80006e44 <get_arg+0x2e8>
80006e12:	58 2a       	cp.w	r10,2
80006e14:	c1 81       	brne	80006e44 <get_arg+0x2e8>
80006e16:	c0 58       	rjmp	80006e20 <get_arg+0x2c4>
80006e18:	58 5a       	cp.w	r10,5
80006e1a:	c0 c0       	breq	80006e32 <get_arg+0x2d6>
80006e1c:	c0 b5       	brlt	80006e32 <get_arg+0x2d6>
80006e1e:	c1 38       	rjmp	80006e44 <get_arg+0x2e8>
80006e20:	6c 0a       	ld.w	r10,r6[0x0]
80006e22:	f4 cc ff f8 	sub	r12,r10,-8
80006e26:	8d 0c       	st.w	r6[0x0],r12
80006e28:	f4 e2 00 00 	ld.d	r2,r10[0]
80006e2c:	f0 e3 00 00 	st.d	r8[0],r2
80006e30:	c1 08       	rjmp	80006e50 <get_arg+0x2f4>
80006e32:	6c 0a       	ld.w	r10,r6[0x0]
80006e34:	f4 cc ff f8 	sub	r12,r10,-8
80006e38:	8d 0c       	st.w	r6[0x0],r12
80006e3a:	f4 e2 00 00 	ld.d	r2,r10[0]
80006e3e:	f0 e3 00 00 	st.d	r8[0],r2
80006e42:	c0 78       	rjmp	80006e50 <get_arg+0x2f4>
80006e44:	6c 0a       	ld.w	r10,r6[0x0]
80006e46:	f4 cc ff fc 	sub	r12,r10,-4
80006e4a:	8d 0c       	st.w	r6[0x0],r12
80006e4c:	74 0a       	ld.w	r10,r10[0x0]
80006e4e:	91 0a       	st.w	r8[0x0],r10
80006e50:	2f f5       	sub	r5,-1
80006e52:	2f 88       	sub	r8,-8
80006e54:	2f c1       	sub	r1,-4
80006e56:	12 35       	cp.w	r5,r9
80006e58:	fe 9a ff d6 	brle	80006e04 <get_arg+0x2a8>
80006e5c:	1c 93       	mov	r3,lr
80006e5e:	40 52       	lddsp	r2,sp[0x14]
80006e60:	40 6e       	lddsp	lr,sp[0x18]
80006e62:	85 05       	st.w	r2[0x0],r5
80006e64:	9d 0b       	st.w	lr[0x0],r11
80006e66:	40 4b       	lddsp	r11,sp[0x10]
80006e68:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006e6c:	2f 8d       	sub	sp,-32
80006e6e:	d8 32       	popm	r0-r7,pc

80006e70 <__sprint_r>:
80006e70:	d4 21       	pushm	r4-r7,lr
80006e72:	14 97       	mov	r7,r10
80006e74:	74 28       	ld.w	r8,r10[0x8]
80006e76:	58 08       	cp.w	r8,0
80006e78:	c0 41       	brne	80006e80 <__sprint_r+0x10>
80006e7a:	95 18       	st.w	r10[0x4],r8
80006e7c:	10 9c       	mov	r12,r8
80006e7e:	d8 22       	popm	r4-r7,pc
80006e80:	e0 a0 18 ba 	rcall	80009ff4 <__sfvwrite_r>
80006e84:	30 08       	mov	r8,0
80006e86:	8f 18       	st.w	r7[0x4],r8
80006e88:	8f 28       	st.w	r7[0x8],r8
80006e8a:	d8 22       	popm	r4-r7,pc

80006e8c <_vfprintf_r>:
80006e8c:	d4 31       	pushm	r0-r7,lr
80006e8e:	fa cd 06 bc 	sub	sp,sp,1724
80006e92:	51 09       	stdsp	sp[0x40],r9
80006e94:	16 91       	mov	r1,r11
80006e96:	14 97       	mov	r7,r10
80006e98:	18 95       	mov	r5,r12
80006e9a:	e0 a0 1a 1d 	rcall	8000a2d4 <_localeconv_r>
80006e9e:	78 0c       	ld.w	r12,r12[0x0]
80006ea0:	50 cc       	stdsp	sp[0x30],r12
80006ea2:	58 05       	cp.w	r5,0
80006ea4:	c0 70       	breq	80006eb2 <_vfprintf_r+0x26>
80006ea6:	6a 68       	ld.w	r8,r5[0x18]
80006ea8:	58 08       	cp.w	r8,0
80006eaa:	c0 41       	brne	80006eb2 <_vfprintf_r+0x26>
80006eac:	0a 9c       	mov	r12,r5
80006eae:	e0 a0 17 43 	rcall	80009d34 <__sinit>
80006eb2:	fe c8 9b 36 	sub	r8,pc,-25802
80006eb6:	10 31       	cp.w	r1,r8
80006eb8:	c0 31       	brne	80006ebe <_vfprintf_r+0x32>
80006eba:	6a 01       	ld.w	r1,r5[0x0]
80006ebc:	c0 c8       	rjmp	80006ed4 <_vfprintf_r+0x48>
80006ebe:	fe c8 9b 22 	sub	r8,pc,-25822
80006ec2:	10 31       	cp.w	r1,r8
80006ec4:	c0 31       	brne	80006eca <_vfprintf_r+0x3e>
80006ec6:	6a 11       	ld.w	r1,r5[0x4]
80006ec8:	c0 68       	rjmp	80006ed4 <_vfprintf_r+0x48>
80006eca:	fe c8 9b 0e 	sub	r8,pc,-25842
80006ece:	10 31       	cp.w	r1,r8
80006ed0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006ed4:	82 68       	ld.sh	r8,r1[0xc]
80006ed6:	ed b8 00 03 	bld	r8,0x3
80006eda:	c0 41       	brne	80006ee2 <_vfprintf_r+0x56>
80006edc:	62 48       	ld.w	r8,r1[0x10]
80006ede:	58 08       	cp.w	r8,0
80006ee0:	c0 71       	brne	80006eee <_vfprintf_r+0x62>
80006ee2:	02 9b       	mov	r11,r1
80006ee4:	0a 9c       	mov	r12,r5
80006ee6:	e0 a0 0f 5d 	rcall	80008da0 <__swsetup_r>
80006eea:	e0 81 0f 54 	brne	80008d92 <_vfprintf_r+0x1f06>
80006eee:	82 68       	ld.sh	r8,r1[0xc]
80006ef0:	10 99       	mov	r9,r8
80006ef2:	e2 19 00 1a 	andl	r9,0x1a,COH
80006ef6:	58 a9       	cp.w	r9,10
80006ef8:	c3 c1       	brne	80006f70 <_vfprintf_r+0xe4>
80006efa:	82 79       	ld.sh	r9,r1[0xe]
80006efc:	30 0a       	mov	r10,0
80006efe:	f4 09 19 00 	cp.h	r9,r10
80006f02:	c3 75       	brlt	80006f70 <_vfprintf_r+0xe4>
80006f04:	a1 d8       	cbr	r8,0x1
80006f06:	fb 58 05 d0 	st.h	sp[1488],r8
80006f0a:	62 88       	ld.w	r8,r1[0x20]
80006f0c:	fb 48 05 e4 	st.w	sp[1508],r8
80006f10:	62 a8       	ld.w	r8,r1[0x28]
80006f12:	fb 48 05 ec 	st.w	sp[1516],r8
80006f16:	fa c8 ff bc 	sub	r8,sp,-68
80006f1a:	fb 48 05 d4 	st.w	sp[1492],r8
80006f1e:	fb 48 05 c4 	st.w	sp[1476],r8
80006f22:	e0 68 04 00 	mov	r8,1024
80006f26:	fb 48 05 d8 	st.w	sp[1496],r8
80006f2a:	fb 48 05 cc 	st.w	sp[1484],r8
80006f2e:	30 08       	mov	r8,0
80006f30:	fb 59 05 d2 	st.h	sp[1490],r9
80006f34:	0e 9a       	mov	r10,r7
80006f36:	41 09       	lddsp	r9,sp[0x40]
80006f38:	fa c7 fa 3c 	sub	r7,sp,-1476
80006f3c:	fb 48 05 dc 	st.w	sp[1500],r8
80006f40:	0a 9c       	mov	r12,r5
80006f42:	0e 9b       	mov	r11,r7
80006f44:	ca 4f       	rcall	80006e8c <_vfprintf_r>
80006f46:	50 bc       	stdsp	sp[0x2c],r12
80006f48:	c0 95       	brlt	80006f5a <_vfprintf_r+0xce>
80006f4a:	0e 9b       	mov	r11,r7
80006f4c:	0a 9c       	mov	r12,r5
80006f4e:	e0 a0 16 1b 	rcall	80009b84 <_fflush_r>
80006f52:	40 be       	lddsp	lr,sp[0x2c]
80006f54:	f9 be 01 ff 	movne	lr,-1
80006f58:	50 be       	stdsp	sp[0x2c],lr
80006f5a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80006f5e:	ed b8 00 06 	bld	r8,0x6
80006f62:	e0 81 0f 1a 	brne	80008d96 <_vfprintf_r+0x1f0a>
80006f66:	82 68       	ld.sh	r8,r1[0xc]
80006f68:	a7 a8       	sbr	r8,0x6
80006f6a:	a2 68       	st.h	r1[0xc],r8
80006f6c:	e0 8f 0f 15 	bral	80008d96 <_vfprintf_r+0x1f0a>
80006f70:	30 08       	mov	r8,0
80006f72:	fb 48 06 b4 	st.w	sp[1716],r8
80006f76:	fb 48 06 90 	st.w	sp[1680],r8
80006f7a:	fb 48 06 8c 	st.w	sp[1676],r8
80006f7e:	fb 48 06 b0 	st.w	sp[1712],r8
80006f82:	30 08       	mov	r8,0
80006f84:	30 09       	mov	r9,0
80006f86:	50 a7       	stdsp	sp[0x28],r7
80006f88:	50 78       	stdsp	sp[0x1c],r8
80006f8a:	fa c3 f9 e0 	sub	r3,sp,-1568
80006f8e:	3f f8       	mov	r8,-1
80006f90:	50 59       	stdsp	sp[0x14],r9
80006f92:	fb 43 06 88 	st.w	sp[1672],r3
80006f96:	fb 48 05 44 	st.w	sp[1348],r8
80006f9a:	12 9c       	mov	r12,r9
80006f9c:	50 69       	stdsp	sp[0x18],r9
80006f9e:	50 d9       	stdsp	sp[0x34],r9
80006fa0:	50 e9       	stdsp	sp[0x38],r9
80006fa2:	50 b9       	stdsp	sp[0x2c],r9
80006fa4:	12 97       	mov	r7,r9
80006fa6:	0a 94       	mov	r4,r5
80006fa8:	40 a2       	lddsp	r2,sp[0x28]
80006faa:	32 5a       	mov	r10,37
80006fac:	30 08       	mov	r8,0
80006fae:	c0 28       	rjmp	80006fb2 <_vfprintf_r+0x126>
80006fb0:	2f f2       	sub	r2,-1
80006fb2:	05 89       	ld.ub	r9,r2[0x0]
80006fb4:	f0 09 18 00 	cp.b	r9,r8
80006fb8:	5f 1b       	srne	r11
80006fba:	f4 09 18 00 	cp.b	r9,r10
80006fbe:	5f 19       	srne	r9
80006fc0:	f3 eb 00 0b 	and	r11,r9,r11
80006fc4:	f0 0b 18 00 	cp.b	r11,r8
80006fc8:	cf 41       	brne	80006fb0 <_vfprintf_r+0x124>
80006fca:	40 ab       	lddsp	r11,sp[0x28]
80006fcc:	e4 0b 01 06 	sub	r6,r2,r11
80006fd0:	c1 e0       	breq	8000700c <_vfprintf_r+0x180>
80006fd2:	fa f8 06 90 	ld.w	r8,sp[1680]
80006fd6:	0c 08       	add	r8,r6
80006fd8:	87 0b       	st.w	r3[0x0],r11
80006fda:	fb 48 06 90 	st.w	sp[1680],r8
80006fde:	87 16       	st.w	r3[0x4],r6
80006fe0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006fe4:	2f f8       	sub	r8,-1
80006fe6:	fb 48 06 8c 	st.w	sp[1676],r8
80006fea:	58 78       	cp.w	r8,7
80006fec:	e0 89 00 04 	brgt	80006ff4 <_vfprintf_r+0x168>
80006ff0:	2f 83       	sub	r3,-8
80006ff2:	c0 a8       	rjmp	80007006 <_vfprintf_r+0x17a>
80006ff4:	fa ca f9 78 	sub	r10,sp,-1672
80006ff8:	02 9b       	mov	r11,r1
80006ffa:	08 9c       	mov	r12,r4
80006ffc:	c3 af       	rcall	80006e70 <__sprint_r>
80006ffe:	e0 81 0e c6 	brne	80008d8a <_vfprintf_r+0x1efe>
80007002:	fa c3 f9 e0 	sub	r3,sp,-1568
80007006:	40 ba       	lddsp	r10,sp[0x2c]
80007008:	0c 0a       	add	r10,r6
8000700a:	50 ba       	stdsp	sp[0x2c],r10
8000700c:	05 89       	ld.ub	r9,r2[0x0]
8000700e:	30 08       	mov	r8,0
80007010:	f0 09 18 00 	cp.b	r9,r8
80007014:	e0 80 0e aa 	breq	80008d68 <_vfprintf_r+0x1edc>
80007018:	30 09       	mov	r9,0
8000701a:	fb 68 06 bb 	st.b	sp[1723],r8
8000701e:	0e 96       	mov	r6,r7
80007020:	e4 c8 ff ff 	sub	r8,r2,-1
80007024:	3f fe       	mov	lr,-1
80007026:	50 93       	stdsp	sp[0x24],r3
80007028:	50 41       	stdsp	sp[0x10],r1
8000702a:	0e 93       	mov	r3,r7
8000702c:	04 91       	mov	r1,r2
8000702e:	50 89       	stdsp	sp[0x20],r9
80007030:	50 a8       	stdsp	sp[0x28],r8
80007032:	50 2e       	stdsp	sp[0x8],lr
80007034:	50 39       	stdsp	sp[0xc],r9
80007036:	12 95       	mov	r5,r9
80007038:	12 90       	mov	r0,r9
8000703a:	10 97       	mov	r7,r8
8000703c:	08 92       	mov	r2,r4
8000703e:	c0 78       	rjmp	8000704c <_vfprintf_r+0x1c0>
80007040:	3f fc       	mov	r12,-1
80007042:	08 97       	mov	r7,r4
80007044:	50 2c       	stdsp	sp[0x8],r12
80007046:	c0 38       	rjmp	8000704c <_vfprintf_r+0x1c0>
80007048:	30 0b       	mov	r11,0
8000704a:	50 3b       	stdsp	sp[0xc],r11
8000704c:	0f 38       	ld.ub	r8,r7++
8000704e:	c0 28       	rjmp	80007052 <_vfprintf_r+0x1c6>
80007050:	12 90       	mov	r0,r9
80007052:	f0 c9 00 20 	sub	r9,r8,32
80007056:	e0 49 00 58 	cp.w	r9,88
8000705a:	e0 8b 0a 30 	brhi	800084ba <_vfprintf_r+0x162e>
8000705e:	fe ca a0 8a 	sub	r10,pc,-24438
80007062:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007066:	50 a7       	stdsp	sp[0x28],r7
80007068:	50 80       	stdsp	sp[0x20],r0
8000706a:	0c 97       	mov	r7,r6
8000706c:	04 94       	mov	r4,r2
8000706e:	06 96       	mov	r6,r3
80007070:	02 92       	mov	r2,r1
80007072:	fe c9 9e 62 	sub	r9,pc,-24990
80007076:	40 93       	lddsp	r3,sp[0x24]
80007078:	10 90       	mov	r0,r8
8000707a:	40 41       	lddsp	r1,sp[0x10]
8000707c:	50 d9       	stdsp	sp[0x34],r9
8000707e:	e0 8f 08 8e 	bral	8000819a <_vfprintf_r+0x130e>
80007082:	30 08       	mov	r8,0
80007084:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007088:	f0 09 18 00 	cp.b	r9,r8
8000708c:	ce 01       	brne	8000704c <_vfprintf_r+0x1c0>
8000708e:	32 08       	mov	r8,32
80007090:	c6 e8       	rjmp	8000716c <_vfprintf_r+0x2e0>
80007092:	a1 a5       	sbr	r5,0x0
80007094:	cd cb       	rjmp	8000704c <_vfprintf_r+0x1c0>
80007096:	0f 89       	ld.ub	r9,r7[0x0]
80007098:	f2 c8 00 30 	sub	r8,r9,48
8000709c:	58 98       	cp.w	r8,9
8000709e:	e0 8b 00 1d 	brhi	800070d8 <_vfprintf_r+0x24c>
800070a2:	ee c8 ff ff 	sub	r8,r7,-1
800070a6:	30 0b       	mov	r11,0
800070a8:	23 09       	sub	r9,48
800070aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800070ae:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800070b2:	11 39       	ld.ub	r9,r8++
800070b4:	f2 ca 00 30 	sub	r10,r9,48
800070b8:	58 9a       	cp.w	r10,9
800070ba:	fe 98 ff f7 	brls	800070a8 <_vfprintf_r+0x21c>
800070be:	e0 49 00 24 	cp.w	r9,36
800070c2:	cc 31       	brne	80007048 <_vfprintf_r+0x1bc>
800070c4:	e0 4b 00 20 	cp.w	r11,32
800070c8:	e0 89 0e 60 	brgt	80008d88 <_vfprintf_r+0x1efc>
800070cc:	20 1b       	sub	r11,1
800070ce:	fa f9 06 b4 	ld.w	r9,sp[1716]
800070d2:	12 3b       	cp.w	r11,r9
800070d4:	c0 95       	brlt	800070e6 <_vfprintf_r+0x25a>
800070d6:	c1 08       	rjmp	800070f6 <_vfprintf_r+0x26a>
800070d8:	fa f9 06 b4 	ld.w	r9,sp[1716]
800070dc:	ec ca ff ff 	sub	r10,r6,-1
800070e0:	12 36       	cp.w	r6,r9
800070e2:	c1 f5       	brlt	80007120 <_vfprintf_r+0x294>
800070e4:	c2 68       	rjmp	80007130 <_vfprintf_r+0x2a4>
800070e6:	fa ce f9 44 	sub	lr,sp,-1724
800070ea:	10 97       	mov	r7,r8
800070ec:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800070f0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800070f4:	c3 58       	rjmp	8000715e <_vfprintf_r+0x2d2>
800070f6:	10 97       	mov	r7,r8
800070f8:	fa c8 f9 50 	sub	r8,sp,-1712
800070fc:	1a d8       	st.w	--sp,r8
800070fe:	fa c8 fa b8 	sub	r8,sp,-1352
80007102:	1a d8       	st.w	--sp,r8
80007104:	fa c8 fb b4 	sub	r8,sp,-1100
80007108:	02 9a       	mov	r10,r1
8000710a:	1a d8       	st.w	--sp,r8
8000710c:	04 9c       	mov	r12,r2
8000710e:	fa c8 f9 40 	sub	r8,sp,-1728
80007112:	fa c9 ff b4 	sub	r9,sp,-76
80007116:	fe b0 fd 23 	rcall	80006b5c <get_arg>
8000711a:	2f dd       	sub	sp,-12
8000711c:	78 00       	ld.w	r0,r12[0x0]
8000711e:	c2 08       	rjmp	8000715e <_vfprintf_r+0x2d2>
80007120:	fa cc f9 44 	sub	r12,sp,-1724
80007124:	14 96       	mov	r6,r10
80007126:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000712a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000712e:	c1 88       	rjmp	8000715e <_vfprintf_r+0x2d2>
80007130:	41 08       	lddsp	r8,sp[0x40]
80007132:	59 f9       	cp.w	r9,31
80007134:	e0 89 00 11 	brgt	80007156 <_vfprintf_r+0x2ca>
80007138:	f0 cb ff fc 	sub	r11,r8,-4
8000713c:	51 0b       	stdsp	sp[0x40],r11
8000713e:	70 00       	ld.w	r0,r8[0x0]
80007140:	fa cb f9 44 	sub	r11,sp,-1724
80007144:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007148:	f1 40 fd 88 	st.w	r8[-632],r0
8000714c:	2f f9       	sub	r9,-1
8000714e:	14 96       	mov	r6,r10
80007150:	fb 49 06 b4 	st.w	sp[1716],r9
80007154:	c0 58       	rjmp	8000715e <_vfprintf_r+0x2d2>
80007156:	70 00       	ld.w	r0,r8[0x0]
80007158:	14 96       	mov	r6,r10
8000715a:	2f c8       	sub	r8,-4
8000715c:	51 08       	stdsp	sp[0x40],r8
8000715e:	58 00       	cp.w	r0,0
80007160:	fe 94 ff 76 	brge	8000704c <_vfprintf_r+0x1c0>
80007164:	5c 30       	neg	r0
80007166:	a3 a5       	sbr	r5,0x2
80007168:	c7 2b       	rjmp	8000704c <_vfprintf_r+0x1c0>
8000716a:	32 b8       	mov	r8,43
8000716c:	fb 68 06 bb 	st.b	sp[1723],r8
80007170:	c6 eb       	rjmp	8000704c <_vfprintf_r+0x1c0>
80007172:	0f 38       	ld.ub	r8,r7++
80007174:	e0 48 00 2a 	cp.w	r8,42
80007178:	c0 30       	breq	8000717e <_vfprintf_r+0x2f2>
8000717a:	30 09       	mov	r9,0
8000717c:	c7 98       	rjmp	8000726e <_vfprintf_r+0x3e2>
8000717e:	0f 88       	ld.ub	r8,r7[0x0]
80007180:	f0 c9 00 30 	sub	r9,r8,48
80007184:	58 99       	cp.w	r9,9
80007186:	e0 8b 00 1f 	brhi	800071c4 <_vfprintf_r+0x338>
8000718a:	ee c4 ff ff 	sub	r4,r7,-1
8000718e:	30 0b       	mov	r11,0
80007190:	23 08       	sub	r8,48
80007192:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007196:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000719a:	09 38       	ld.ub	r8,r4++
8000719c:	f0 c9 00 30 	sub	r9,r8,48
800071a0:	58 99       	cp.w	r9,9
800071a2:	fe 98 ff f7 	brls	80007190 <_vfprintf_r+0x304>
800071a6:	e0 48 00 24 	cp.w	r8,36
800071aa:	fe 91 ff 4f 	brne	80007048 <_vfprintf_r+0x1bc>
800071ae:	e0 4b 00 20 	cp.w	r11,32
800071b2:	e0 89 0d eb 	brgt	80008d88 <_vfprintf_r+0x1efc>
800071b6:	20 1b       	sub	r11,1
800071b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800071bc:	10 3b       	cp.w	r11,r8
800071be:	c0 a5       	brlt	800071d2 <_vfprintf_r+0x346>
800071c0:	c1 18       	rjmp	800071e2 <_vfprintf_r+0x356>
800071c2:	d7 03       	nop
800071c4:	fa fa 06 b4 	ld.w	r10,sp[1716]
800071c8:	ec c9 ff ff 	sub	r9,r6,-1
800071cc:	14 36       	cp.w	r6,r10
800071ce:	c1 f5       	brlt	8000720c <_vfprintf_r+0x380>
800071d0:	c2 88       	rjmp	80007220 <_vfprintf_r+0x394>
800071d2:	fa ca f9 44 	sub	r10,sp,-1724
800071d6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800071da:	f6 fb fd 88 	ld.w	r11,r11[-632]
800071de:	50 2b       	stdsp	sp[0x8],r11
800071e0:	c3 c8       	rjmp	80007258 <_vfprintf_r+0x3cc>
800071e2:	fa c8 f9 50 	sub	r8,sp,-1712
800071e6:	1a d8       	st.w	--sp,r8
800071e8:	fa c8 fa b8 	sub	r8,sp,-1352
800071ec:	1a d8       	st.w	--sp,r8
800071ee:	fa c8 fb b4 	sub	r8,sp,-1100
800071f2:	02 9a       	mov	r10,r1
800071f4:	1a d8       	st.w	--sp,r8
800071f6:	04 9c       	mov	r12,r2
800071f8:	fa c8 f9 40 	sub	r8,sp,-1728
800071fc:	fa c9 ff b4 	sub	r9,sp,-76
80007200:	fe b0 fc ae 	rcall	80006b5c <get_arg>
80007204:	2f dd       	sub	sp,-12
80007206:	78 0c       	ld.w	r12,r12[0x0]
80007208:	50 2c       	stdsp	sp[0x8],r12
8000720a:	c2 78       	rjmp	80007258 <_vfprintf_r+0x3cc>
8000720c:	12 96       	mov	r6,r9
8000720e:	0e 94       	mov	r4,r7
80007210:	fa c9 f9 44 	sub	r9,sp,-1724
80007214:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007218:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000721c:	50 28       	stdsp	sp[0x8],r8
8000721e:	c1 d8       	rjmp	80007258 <_vfprintf_r+0x3cc>
80007220:	41 08       	lddsp	r8,sp[0x40]
80007222:	59 fa       	cp.w	r10,31
80007224:	e0 89 00 14 	brgt	8000724c <_vfprintf_r+0x3c0>
80007228:	f0 cb ff fc 	sub	r11,r8,-4
8000722c:	70 08       	ld.w	r8,r8[0x0]
8000722e:	51 0b       	stdsp	sp[0x40],r11
80007230:	50 28       	stdsp	sp[0x8],r8
80007232:	fa c6 f9 44 	sub	r6,sp,-1724
80007236:	40 2e       	lddsp	lr,sp[0x8]
80007238:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000723c:	f1 4e fd 88 	st.w	r8[-632],lr
80007240:	2f fa       	sub	r10,-1
80007242:	0e 94       	mov	r4,r7
80007244:	fb 4a 06 b4 	st.w	sp[1716],r10
80007248:	12 96       	mov	r6,r9
8000724a:	c0 78       	rjmp	80007258 <_vfprintf_r+0x3cc>
8000724c:	70 0c       	ld.w	r12,r8[0x0]
8000724e:	0e 94       	mov	r4,r7
80007250:	2f c8       	sub	r8,-4
80007252:	50 2c       	stdsp	sp[0x8],r12
80007254:	12 96       	mov	r6,r9
80007256:	51 08       	stdsp	sp[0x40],r8
80007258:	40 2b       	lddsp	r11,sp[0x8]
8000725a:	58 0b       	cp.w	r11,0
8000725c:	fe 95 fe f2 	brlt	80007040 <_vfprintf_r+0x1b4>
80007260:	08 97       	mov	r7,r4
80007262:	cf 5a       	rjmp	8000704c <_vfprintf_r+0x1c0>
80007264:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007268:	0f 38       	ld.ub	r8,r7++
8000726a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000726e:	f0 ca 00 30 	sub	r10,r8,48
80007272:	58 9a       	cp.w	r10,9
80007274:	fe 98 ff f8 	brls	80007264 <_vfprintf_r+0x3d8>
80007278:	3f fa       	mov	r10,-1
8000727a:	f2 0a 0c 49 	max	r9,r9,r10
8000727e:	50 29       	stdsp	sp[0x8],r9
80007280:	ce 9a       	rjmp	80007052 <_vfprintf_r+0x1c6>
80007282:	a7 b5       	sbr	r5,0x7
80007284:	ce 4a       	rjmp	8000704c <_vfprintf_r+0x1c0>
80007286:	30 09       	mov	r9,0
80007288:	23 08       	sub	r8,48
8000728a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000728e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007292:	0f 38       	ld.ub	r8,r7++
80007294:	f0 ca 00 30 	sub	r10,r8,48
80007298:	58 9a       	cp.w	r10,9
8000729a:	fe 98 ff f7 	brls	80007288 <_vfprintf_r+0x3fc>
8000729e:	e0 48 00 24 	cp.w	r8,36
800072a2:	fe 91 fe d7 	brne	80007050 <_vfprintf_r+0x1c4>
800072a6:	e0 49 00 20 	cp.w	r9,32
800072aa:	e0 89 0d 6f 	brgt	80008d88 <_vfprintf_r+0x1efc>
800072ae:	f2 c3 00 01 	sub	r3,r9,1
800072b2:	30 19       	mov	r9,1
800072b4:	50 39       	stdsp	sp[0xc],r9
800072b6:	cc ba       	rjmp	8000704c <_vfprintf_r+0x1c0>
800072b8:	a3 b5       	sbr	r5,0x3
800072ba:	cc 9a       	rjmp	8000704c <_vfprintf_r+0x1c0>
800072bc:	a7 a5       	sbr	r5,0x6
800072be:	cc 7a       	rjmp	8000704c <_vfprintf_r+0x1c0>
800072c0:	0a 98       	mov	r8,r5
800072c2:	a5 b5       	sbr	r5,0x5
800072c4:	a5 a8       	sbr	r8,0x4
800072c6:	0f 89       	ld.ub	r9,r7[0x0]
800072c8:	36 ce       	mov	lr,108
800072ca:	fc 09 18 00 	cp.b	r9,lr
800072ce:	f7 b7 00 ff 	subeq	r7,-1
800072d2:	f0 05 17 10 	movne	r5,r8
800072d6:	cb ba       	rjmp	8000704c <_vfprintf_r+0x1c0>
800072d8:	a5 b5       	sbr	r5,0x5
800072da:	cb 9a       	rjmp	8000704c <_vfprintf_r+0x1c0>
800072dc:	50 a7       	stdsp	sp[0x28],r7
800072de:	50 80       	stdsp	sp[0x20],r0
800072e0:	0c 97       	mov	r7,r6
800072e2:	10 90       	mov	r0,r8
800072e4:	06 96       	mov	r6,r3
800072e6:	04 94       	mov	r4,r2
800072e8:	40 93       	lddsp	r3,sp[0x24]
800072ea:	02 92       	mov	r2,r1
800072ec:	0e 99       	mov	r9,r7
800072ee:	40 41       	lddsp	r1,sp[0x10]
800072f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800072f4:	40 3c       	lddsp	r12,sp[0xc]
800072f6:	58 0c       	cp.w	r12,0
800072f8:	c1 d0       	breq	80007332 <_vfprintf_r+0x4a6>
800072fa:	10 36       	cp.w	r6,r8
800072fc:	c0 64       	brge	80007308 <_vfprintf_r+0x47c>
800072fe:	fa cb f9 44 	sub	r11,sp,-1724
80007302:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007306:	c1 d8       	rjmp	80007340 <_vfprintf_r+0x4b4>
80007308:	fa c8 f9 50 	sub	r8,sp,-1712
8000730c:	1a d8       	st.w	--sp,r8
8000730e:	fa c8 fa b8 	sub	r8,sp,-1352
80007312:	1a d8       	st.w	--sp,r8
80007314:	fa c8 fb b4 	sub	r8,sp,-1100
80007318:	1a d8       	st.w	--sp,r8
8000731a:	fa c8 f9 40 	sub	r8,sp,-1728
8000731e:	fa c9 ff b4 	sub	r9,sp,-76
80007322:	04 9a       	mov	r10,r2
80007324:	0c 9b       	mov	r11,r6
80007326:	08 9c       	mov	r12,r4
80007328:	fe b0 fc 1a 	rcall	80006b5c <get_arg>
8000732c:	2f dd       	sub	sp,-12
8000732e:	19 b8       	ld.ub	r8,r12[0x3]
80007330:	c2 28       	rjmp	80007374 <_vfprintf_r+0x4e8>
80007332:	2f f7       	sub	r7,-1
80007334:	10 39       	cp.w	r9,r8
80007336:	c0 84       	brge	80007346 <_vfprintf_r+0x4ba>
80007338:	fa ca f9 44 	sub	r10,sp,-1724
8000733c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007340:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007344:	c1 88       	rjmp	80007374 <_vfprintf_r+0x4e8>
80007346:	41 09       	lddsp	r9,sp[0x40]
80007348:	59 f8       	cp.w	r8,31
8000734a:	e0 89 00 12 	brgt	8000736e <_vfprintf_r+0x4e2>
8000734e:	f2 ca ff fc 	sub	r10,r9,-4
80007352:	51 0a       	stdsp	sp[0x40],r10
80007354:	72 09       	ld.w	r9,r9[0x0]
80007356:	fa c6 f9 44 	sub	r6,sp,-1724
8000735a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000735e:	2f f8       	sub	r8,-1
80007360:	f5 49 fd 88 	st.w	r10[-632],r9
80007364:	fb 48 06 b4 	st.w	sp[1716],r8
80007368:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000736c:	c0 48       	rjmp	80007374 <_vfprintf_r+0x4e8>
8000736e:	13 b8       	ld.ub	r8,r9[0x3]
80007370:	2f c9       	sub	r9,-4
80007372:	51 09       	stdsp	sp[0x40],r9
80007374:	fb 68 06 60 	st.b	sp[1632],r8
80007378:	30 0e       	mov	lr,0
8000737a:	30 08       	mov	r8,0
8000737c:	30 12       	mov	r2,1
8000737e:	fb 68 06 bb 	st.b	sp[1723],r8
80007382:	50 2e       	stdsp	sp[0x8],lr
80007384:	e0 8f 08 ad 	bral	800084de <_vfprintf_r+0x1652>
80007388:	50 a7       	stdsp	sp[0x28],r7
8000738a:	50 80       	stdsp	sp[0x20],r0
8000738c:	0c 97       	mov	r7,r6
8000738e:	04 94       	mov	r4,r2
80007390:	06 96       	mov	r6,r3
80007392:	02 92       	mov	r2,r1
80007394:	40 93       	lddsp	r3,sp[0x24]
80007396:	10 90       	mov	r0,r8
80007398:	40 41       	lddsp	r1,sp[0x10]
8000739a:	a5 a5       	sbr	r5,0x4
8000739c:	c0 a8       	rjmp	800073b0 <_vfprintf_r+0x524>
8000739e:	50 a7       	stdsp	sp[0x28],r7
800073a0:	50 80       	stdsp	sp[0x20],r0
800073a2:	0c 97       	mov	r7,r6
800073a4:	04 94       	mov	r4,r2
800073a6:	06 96       	mov	r6,r3
800073a8:	02 92       	mov	r2,r1
800073aa:	40 93       	lddsp	r3,sp[0x24]
800073ac:	10 90       	mov	r0,r8
800073ae:	40 41       	lddsp	r1,sp[0x10]
800073b0:	ed b5 00 05 	bld	r5,0x5
800073b4:	c5 11       	brne	80007456 <_vfprintf_r+0x5ca>
800073b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073ba:	40 3c       	lddsp	r12,sp[0xc]
800073bc:	58 0c       	cp.w	r12,0
800073be:	c1 e0       	breq	800073fa <_vfprintf_r+0x56e>
800073c0:	10 36       	cp.w	r6,r8
800073c2:	c0 64       	brge	800073ce <_vfprintf_r+0x542>
800073c4:	fa cb f9 44 	sub	r11,sp,-1724
800073c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800073cc:	c2 08       	rjmp	8000740c <_vfprintf_r+0x580>
800073ce:	fa c8 f9 50 	sub	r8,sp,-1712
800073d2:	1a d8       	st.w	--sp,r8
800073d4:	fa c8 fa b8 	sub	r8,sp,-1352
800073d8:	0c 9b       	mov	r11,r6
800073da:	1a d8       	st.w	--sp,r8
800073dc:	fa c8 fb b4 	sub	r8,sp,-1100
800073e0:	1a d8       	st.w	--sp,r8
800073e2:	fa c9 ff b4 	sub	r9,sp,-76
800073e6:	fa c8 f9 40 	sub	r8,sp,-1728
800073ea:	04 9a       	mov	r10,r2
800073ec:	08 9c       	mov	r12,r4
800073ee:	fe b0 fb b7 	rcall	80006b5c <get_arg>
800073f2:	2f dd       	sub	sp,-12
800073f4:	78 1b       	ld.w	r11,r12[0x4]
800073f6:	78 09       	ld.w	r9,r12[0x0]
800073f8:	c2 b8       	rjmp	8000744e <_vfprintf_r+0x5c2>
800073fa:	ee ca ff ff 	sub	r10,r7,-1
800073fe:	10 37       	cp.w	r7,r8
80007400:	c0 b4       	brge	80007416 <_vfprintf_r+0x58a>
80007402:	fa c9 f9 44 	sub	r9,sp,-1724
80007406:	14 97       	mov	r7,r10
80007408:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000740c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007410:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007414:	c1 d8       	rjmp	8000744e <_vfprintf_r+0x5c2>
80007416:	41 09       	lddsp	r9,sp[0x40]
80007418:	59 f8       	cp.w	r8,31
8000741a:	e0 89 00 14 	brgt	80007442 <_vfprintf_r+0x5b6>
8000741e:	f2 cb ff f8 	sub	r11,r9,-8
80007422:	51 0b       	stdsp	sp[0x40],r11
80007424:	fa c6 f9 44 	sub	r6,sp,-1724
80007428:	72 1b       	ld.w	r11,r9[0x4]
8000742a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000742e:	72 09       	ld.w	r9,r9[0x0]
80007430:	f9 4b fd 8c 	st.w	r12[-628],r11
80007434:	f9 49 fd 88 	st.w	r12[-632],r9
80007438:	2f f8       	sub	r8,-1
8000743a:	14 97       	mov	r7,r10
8000743c:	fb 48 06 b4 	st.w	sp[1716],r8
80007440:	c0 78       	rjmp	8000744e <_vfprintf_r+0x5c2>
80007442:	f2 c8 ff f8 	sub	r8,r9,-8
80007446:	72 1b       	ld.w	r11,r9[0x4]
80007448:	14 97       	mov	r7,r10
8000744a:	51 08       	stdsp	sp[0x40],r8
8000744c:	72 09       	ld.w	r9,r9[0x0]
8000744e:	16 98       	mov	r8,r11
80007450:	fa e9 00 00 	st.d	sp[0],r8
80007454:	ca e8       	rjmp	800075b0 <_vfprintf_r+0x724>
80007456:	ed b5 00 04 	bld	r5,0x4
8000745a:	c1 71       	brne	80007488 <_vfprintf_r+0x5fc>
8000745c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007460:	40 3e       	lddsp	lr,sp[0xc]
80007462:	58 0e       	cp.w	lr,0
80007464:	c0 80       	breq	80007474 <_vfprintf_r+0x5e8>
80007466:	10 36       	cp.w	r6,r8
80007468:	c6 94       	brge	8000753a <_vfprintf_r+0x6ae>
8000746a:	fa cc f9 44 	sub	r12,sp,-1724
8000746e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007472:	c8 28       	rjmp	80007576 <_vfprintf_r+0x6ea>
80007474:	ee ca ff ff 	sub	r10,r7,-1
80007478:	10 37       	cp.w	r7,r8
8000747a:	e0 84 00 81 	brge	8000757c <_vfprintf_r+0x6f0>
8000747e:	fa cb f9 44 	sub	r11,sp,-1724
80007482:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007486:	c7 78       	rjmp	80007574 <_vfprintf_r+0x6e8>
80007488:	ed b5 00 06 	bld	r5,0x6
8000748c:	c4 b1       	brne	80007522 <_vfprintf_r+0x696>
8000748e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007492:	40 3c       	lddsp	r12,sp[0xc]
80007494:	58 0c       	cp.w	r12,0
80007496:	c1 d0       	breq	800074d0 <_vfprintf_r+0x644>
80007498:	10 36       	cp.w	r6,r8
8000749a:	c0 64       	brge	800074a6 <_vfprintf_r+0x61a>
8000749c:	fa cb f9 44 	sub	r11,sp,-1724
800074a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800074a4:	c1 f8       	rjmp	800074e2 <_vfprintf_r+0x656>
800074a6:	fa c8 f9 50 	sub	r8,sp,-1712
800074aa:	1a d8       	st.w	--sp,r8
800074ac:	fa c8 fa b8 	sub	r8,sp,-1352
800074b0:	1a d8       	st.w	--sp,r8
800074b2:	fa c8 fb b4 	sub	r8,sp,-1100
800074b6:	1a d8       	st.w	--sp,r8
800074b8:	fa c8 f9 40 	sub	r8,sp,-1728
800074bc:	fa c9 ff b4 	sub	r9,sp,-76
800074c0:	04 9a       	mov	r10,r2
800074c2:	0c 9b       	mov	r11,r6
800074c4:	08 9c       	mov	r12,r4
800074c6:	fe b0 fb 4b 	rcall	80006b5c <get_arg>
800074ca:	2f dd       	sub	sp,-12
800074cc:	98 18       	ld.sh	r8,r12[0x2]
800074ce:	c2 68       	rjmp	8000751a <_vfprintf_r+0x68e>
800074d0:	ee ca ff ff 	sub	r10,r7,-1
800074d4:	10 37       	cp.w	r7,r8
800074d6:	c0 94       	brge	800074e8 <_vfprintf_r+0x65c>
800074d8:	fa c9 f9 44 	sub	r9,sp,-1724
800074dc:	14 97       	mov	r7,r10
800074de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800074e2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800074e6:	c1 a8       	rjmp	8000751a <_vfprintf_r+0x68e>
800074e8:	41 09       	lddsp	r9,sp[0x40]
800074ea:	59 f8       	cp.w	r8,31
800074ec:	e0 89 00 13 	brgt	80007512 <_vfprintf_r+0x686>
800074f0:	f2 cb ff fc 	sub	r11,r9,-4
800074f4:	51 0b       	stdsp	sp[0x40],r11
800074f6:	72 09       	ld.w	r9,r9[0x0]
800074f8:	fa c6 f9 44 	sub	r6,sp,-1724
800074fc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007500:	2f f8       	sub	r8,-1
80007502:	f7 49 fd 88 	st.w	r11[-632],r9
80007506:	fb 48 06 b4 	st.w	sp[1716],r8
8000750a:	14 97       	mov	r7,r10
8000750c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007510:	c0 58       	rjmp	8000751a <_vfprintf_r+0x68e>
80007512:	92 18       	ld.sh	r8,r9[0x2]
80007514:	14 97       	mov	r7,r10
80007516:	2f c9       	sub	r9,-4
80007518:	51 09       	stdsp	sp[0x40],r9
8000751a:	50 18       	stdsp	sp[0x4],r8
8000751c:	bf 58       	asr	r8,0x1f
8000751e:	50 08       	stdsp	sp[0x0],r8
80007520:	c4 88       	rjmp	800075b0 <_vfprintf_r+0x724>
80007522:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007526:	40 3c       	lddsp	r12,sp[0xc]
80007528:	58 0c       	cp.w	r12,0
8000752a:	c1 d0       	breq	80007564 <_vfprintf_r+0x6d8>
8000752c:	10 36       	cp.w	r6,r8
8000752e:	c0 64       	brge	8000753a <_vfprintf_r+0x6ae>
80007530:	fa cb f9 44 	sub	r11,sp,-1724
80007534:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007538:	c1 f8       	rjmp	80007576 <_vfprintf_r+0x6ea>
8000753a:	fa c8 f9 50 	sub	r8,sp,-1712
8000753e:	1a d8       	st.w	--sp,r8
80007540:	fa c8 fa b8 	sub	r8,sp,-1352
80007544:	0c 9b       	mov	r11,r6
80007546:	1a d8       	st.w	--sp,r8
80007548:	fa c8 fb b4 	sub	r8,sp,-1100
8000754c:	04 9a       	mov	r10,r2
8000754e:	1a d8       	st.w	--sp,r8
80007550:	08 9c       	mov	r12,r4
80007552:	fa c8 f9 40 	sub	r8,sp,-1728
80007556:	fa c9 ff b4 	sub	r9,sp,-76
8000755a:	fe b0 fb 01 	rcall	80006b5c <get_arg>
8000755e:	2f dd       	sub	sp,-12
80007560:	78 0b       	ld.w	r11,r12[0x0]
80007562:	c2 48       	rjmp	800075aa <_vfprintf_r+0x71e>
80007564:	ee ca ff ff 	sub	r10,r7,-1
80007568:	10 37       	cp.w	r7,r8
8000756a:	c0 94       	brge	8000757c <_vfprintf_r+0x6f0>
8000756c:	fa c9 f9 44 	sub	r9,sp,-1724
80007570:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007574:	14 97       	mov	r7,r10
80007576:	ec fb fd 88 	ld.w	r11,r6[-632]
8000757a:	c1 88       	rjmp	800075aa <_vfprintf_r+0x71e>
8000757c:	41 09       	lddsp	r9,sp[0x40]
8000757e:	59 f8       	cp.w	r8,31
80007580:	e0 89 00 11 	brgt	800075a2 <_vfprintf_r+0x716>
80007584:	f2 cb ff fc 	sub	r11,r9,-4
80007588:	51 0b       	stdsp	sp[0x40],r11
8000758a:	fa c6 f9 44 	sub	r6,sp,-1724
8000758e:	72 0b       	ld.w	r11,r9[0x0]
80007590:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007594:	f3 4b fd 88 	st.w	r9[-632],r11
80007598:	2f f8       	sub	r8,-1
8000759a:	14 97       	mov	r7,r10
8000759c:	fb 48 06 b4 	st.w	sp[1716],r8
800075a0:	c0 58       	rjmp	800075aa <_vfprintf_r+0x71e>
800075a2:	72 0b       	ld.w	r11,r9[0x0]
800075a4:	14 97       	mov	r7,r10
800075a6:	2f c9       	sub	r9,-4
800075a8:	51 09       	stdsp	sp[0x40],r9
800075aa:	50 1b       	stdsp	sp[0x4],r11
800075ac:	bf 5b       	asr	r11,0x1f
800075ae:	50 0b       	stdsp	sp[0x0],r11
800075b0:	fa ea 00 00 	ld.d	r10,sp[0]
800075b4:	58 0a       	cp.w	r10,0
800075b6:	5c 2b       	cpc	r11
800075b8:	c0 e4       	brge	800075d4 <_vfprintf_r+0x748>
800075ba:	30 08       	mov	r8,0
800075bc:	fa ea 00 00 	ld.d	r10,sp[0]
800075c0:	30 09       	mov	r9,0
800075c2:	f0 0a 01 0a 	sub	r10,r8,r10
800075c6:	f2 0b 01 4b 	sbc	r11,r9,r11
800075ca:	32 d8       	mov	r8,45
800075cc:	fa eb 00 00 	st.d	sp[0],r10
800075d0:	fb 68 06 bb 	st.b	sp[1723],r8
800075d4:	30 18       	mov	r8,1
800075d6:	e0 8f 06 fa 	bral	800083ca <_vfprintf_r+0x153e>
800075da:	50 a7       	stdsp	sp[0x28],r7
800075dc:	50 80       	stdsp	sp[0x20],r0
800075de:	0c 97       	mov	r7,r6
800075e0:	04 94       	mov	r4,r2
800075e2:	06 96       	mov	r6,r3
800075e4:	02 92       	mov	r2,r1
800075e6:	40 93       	lddsp	r3,sp[0x24]
800075e8:	10 90       	mov	r0,r8
800075ea:	40 41       	lddsp	r1,sp[0x10]
800075ec:	0e 99       	mov	r9,r7
800075ee:	ed b5 00 03 	bld	r5,0x3
800075f2:	c4 11       	brne	80007674 <_vfprintf_r+0x7e8>
800075f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800075f8:	40 3a       	lddsp	r10,sp[0xc]
800075fa:	58 0a       	cp.w	r10,0
800075fc:	c1 90       	breq	8000762e <_vfprintf_r+0x7a2>
800075fe:	10 36       	cp.w	r6,r8
80007600:	c6 45       	brlt	800076c8 <_vfprintf_r+0x83c>
80007602:	fa c8 f9 50 	sub	r8,sp,-1712
80007606:	1a d8       	st.w	--sp,r8
80007608:	fa c8 fa b8 	sub	r8,sp,-1352
8000760c:	1a d8       	st.w	--sp,r8
8000760e:	fa c8 fb b4 	sub	r8,sp,-1100
80007612:	0c 9b       	mov	r11,r6
80007614:	1a d8       	st.w	--sp,r8
80007616:	04 9a       	mov	r10,r2
80007618:	fa c8 f9 40 	sub	r8,sp,-1728
8000761c:	fa c9 ff b4 	sub	r9,sp,-76
80007620:	08 9c       	mov	r12,r4
80007622:	fe b0 fa 9d 	rcall	80006b5c <get_arg>
80007626:	2f dd       	sub	sp,-12
80007628:	78 16       	ld.w	r6,r12[0x4]
8000762a:	50 76       	stdsp	sp[0x1c],r6
8000762c:	c4 88       	rjmp	800076bc <_vfprintf_r+0x830>
8000762e:	2f f7       	sub	r7,-1
80007630:	10 39       	cp.w	r9,r8
80007632:	c0 c4       	brge	8000764a <_vfprintf_r+0x7be>
80007634:	fa ce f9 44 	sub	lr,sp,-1724
80007638:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000763c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007640:	50 7c       	stdsp	sp[0x1c],r12
80007642:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007646:	50 56       	stdsp	sp[0x14],r6
80007648:	c6 68       	rjmp	80007714 <_vfprintf_r+0x888>
8000764a:	41 09       	lddsp	r9,sp[0x40]
8000764c:	59 f8       	cp.w	r8,31
8000764e:	e0 89 00 10 	brgt	8000766e <_vfprintf_r+0x7e2>
80007652:	f2 ca ff f8 	sub	r10,r9,-8
80007656:	72 1b       	ld.w	r11,r9[0x4]
80007658:	51 0a       	stdsp	sp[0x40],r10
8000765a:	72 09       	ld.w	r9,r9[0x0]
8000765c:	fa ca f9 44 	sub	r10,sp,-1724
80007660:	50 7b       	stdsp	sp[0x1c],r11
80007662:	50 59       	stdsp	sp[0x14],r9
80007664:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007668:	40 5b       	lddsp	r11,sp[0x14]
8000766a:	40 7a       	lddsp	r10,sp[0x1c]
8000766c:	c4 78       	rjmp	800076fa <_vfprintf_r+0x86e>
8000766e:	72 18       	ld.w	r8,r9[0x4]
80007670:	50 78       	stdsp	sp[0x1c],r8
80007672:	c4 c8       	rjmp	8000770a <_vfprintf_r+0x87e>
80007674:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007678:	40 3e       	lddsp	lr,sp[0xc]
8000767a:	58 0e       	cp.w	lr,0
8000767c:	c2 30       	breq	800076c2 <_vfprintf_r+0x836>
8000767e:	10 36       	cp.w	r6,r8
80007680:	c0 94       	brge	80007692 <_vfprintf_r+0x806>
80007682:	fa cc f9 44 	sub	r12,sp,-1724
80007686:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000768a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000768e:	50 7b       	stdsp	sp[0x1c],r11
80007690:	cd 9b       	rjmp	80007642 <_vfprintf_r+0x7b6>
80007692:	fa c8 f9 50 	sub	r8,sp,-1712
80007696:	1a d8       	st.w	--sp,r8
80007698:	fa c8 fa b8 	sub	r8,sp,-1352
8000769c:	04 9a       	mov	r10,r2
8000769e:	1a d8       	st.w	--sp,r8
800076a0:	fa c8 fb b4 	sub	r8,sp,-1100
800076a4:	0c 9b       	mov	r11,r6
800076a6:	1a d8       	st.w	--sp,r8
800076a8:	08 9c       	mov	r12,r4
800076aa:	fa c8 f9 40 	sub	r8,sp,-1728
800076ae:	fa c9 ff b4 	sub	r9,sp,-76
800076b2:	fe b0 fa 55 	rcall	80006b5c <get_arg>
800076b6:	2f dd       	sub	sp,-12
800076b8:	78 1a       	ld.w	r10,r12[0x4]
800076ba:	50 7a       	stdsp	sp[0x1c],r10
800076bc:	78 0c       	ld.w	r12,r12[0x0]
800076be:	50 5c       	stdsp	sp[0x14],r12
800076c0:	c2 a8       	rjmp	80007714 <_vfprintf_r+0x888>
800076c2:	2f f7       	sub	r7,-1
800076c4:	10 39       	cp.w	r9,r8
800076c6:	c0 94       	brge	800076d8 <_vfprintf_r+0x84c>
800076c8:	fa c9 f9 44 	sub	r9,sp,-1724
800076cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800076d0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800076d4:	50 78       	stdsp	sp[0x1c],r8
800076d6:	cb 6b       	rjmp	80007642 <_vfprintf_r+0x7b6>
800076d8:	41 09       	lddsp	r9,sp[0x40]
800076da:	59 f8       	cp.w	r8,31
800076dc:	e0 89 00 15 	brgt	80007706 <_vfprintf_r+0x87a>
800076e0:	f2 ca ff f8 	sub	r10,r9,-8
800076e4:	72 16       	ld.w	r6,r9[0x4]
800076e6:	72 09       	ld.w	r9,r9[0x0]
800076e8:	51 0a       	stdsp	sp[0x40],r10
800076ea:	50 59       	stdsp	sp[0x14],r9
800076ec:	fa ce f9 44 	sub	lr,sp,-1724
800076f0:	50 76       	stdsp	sp[0x1c],r6
800076f2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800076f6:	40 5b       	lddsp	r11,sp[0x14]
800076f8:	0c 9a       	mov	r10,r6
800076fa:	f2 eb fd 88 	st.d	r9[-632],r10
800076fe:	2f f8       	sub	r8,-1
80007700:	fb 48 06 b4 	st.w	sp[1716],r8
80007704:	c0 88       	rjmp	80007714 <_vfprintf_r+0x888>
80007706:	72 1c       	ld.w	r12,r9[0x4]
80007708:	50 7c       	stdsp	sp[0x1c],r12
8000770a:	f2 c8 ff f8 	sub	r8,r9,-8
8000770e:	51 08       	stdsp	sp[0x40],r8
80007710:	72 09       	ld.w	r9,r9[0x0]
80007712:	50 59       	stdsp	sp[0x14],r9
80007714:	40 5b       	lddsp	r11,sp[0x14]
80007716:	40 7a       	lddsp	r10,sp[0x1c]
80007718:	e0 a0 19 54 	rcall	8000a9c0 <__isinfd>
8000771c:	18 96       	mov	r6,r12
8000771e:	c1 70       	breq	8000774c <_vfprintf_r+0x8c0>
80007720:	30 08       	mov	r8,0
80007722:	30 09       	mov	r9,0
80007724:	40 5b       	lddsp	r11,sp[0x14]
80007726:	40 7a       	lddsp	r10,sp[0x1c]
80007728:	e0 a0 1d a8 	rcall	8000b278 <__avr32_f64_cmp_lt>
8000772c:	c0 40       	breq	80007734 <_vfprintf_r+0x8a8>
8000772e:	32 d8       	mov	r8,45
80007730:	fb 68 06 bb 	st.b	sp[1723],r8
80007734:	fe c8 a5 10 	sub	r8,pc,-23280
80007738:	fe c6 a5 10 	sub	r6,pc,-23280
8000773c:	a7 d5       	cbr	r5,0x7
8000773e:	e0 40 00 47 	cp.w	r0,71
80007742:	f0 06 17 a0 	movle	r6,r8
80007746:	30 32       	mov	r2,3
80007748:	e0 8f 06 ce 	bral	800084e4 <_vfprintf_r+0x1658>
8000774c:	40 5b       	lddsp	r11,sp[0x14]
8000774e:	40 7a       	lddsp	r10,sp[0x1c]
80007750:	e0 a0 19 4d 	rcall	8000a9ea <__isnand>
80007754:	c0 e0       	breq	80007770 <_vfprintf_r+0x8e4>
80007756:	50 26       	stdsp	sp[0x8],r6
80007758:	fe c8 a5 2c 	sub	r8,pc,-23252
8000775c:	fe c6 a5 2c 	sub	r6,pc,-23252
80007760:	a7 d5       	cbr	r5,0x7
80007762:	e0 40 00 47 	cp.w	r0,71
80007766:	f0 06 17 a0 	movle	r6,r8
8000776a:	30 32       	mov	r2,3
8000776c:	e0 8f 06 c2 	bral	800084f0 <_vfprintf_r+0x1664>
80007770:	40 2a       	lddsp	r10,sp[0x8]
80007772:	5b fa       	cp.w	r10,-1
80007774:	c0 41       	brne	8000777c <_vfprintf_r+0x8f0>
80007776:	30 69       	mov	r9,6
80007778:	50 29       	stdsp	sp[0x8],r9
8000777a:	c1 18       	rjmp	8000779c <_vfprintf_r+0x910>
8000777c:	e0 40 00 47 	cp.w	r0,71
80007780:	5f 09       	sreq	r9
80007782:	e0 40 00 67 	cp.w	r0,103
80007786:	5f 08       	sreq	r8
80007788:	f3 e8 10 08 	or	r8,r9,r8
8000778c:	f8 08 18 00 	cp.b	r8,r12
80007790:	c0 60       	breq	8000779c <_vfprintf_r+0x910>
80007792:	40 28       	lddsp	r8,sp[0x8]
80007794:	58 08       	cp.w	r8,0
80007796:	f9 b8 00 01 	moveq	r8,1
8000779a:	50 28       	stdsp	sp[0x8],r8
8000779c:	40 78       	lddsp	r8,sp[0x1c]
8000779e:	40 59       	lddsp	r9,sp[0x14]
800077a0:	fa e9 06 94 	st.d	sp[1684],r8
800077a4:	a9 a5       	sbr	r5,0x8
800077a6:	fa f8 06 94 	ld.w	r8,sp[1684]
800077aa:	58 08       	cp.w	r8,0
800077ac:	c0 65       	brlt	800077b8 <_vfprintf_r+0x92c>
800077ae:	40 5e       	lddsp	lr,sp[0x14]
800077b0:	30 0c       	mov	r12,0
800077b2:	50 6e       	stdsp	sp[0x18],lr
800077b4:	50 9c       	stdsp	sp[0x24],r12
800077b6:	c0 78       	rjmp	800077c4 <_vfprintf_r+0x938>
800077b8:	40 5b       	lddsp	r11,sp[0x14]
800077ba:	32 da       	mov	r10,45
800077bc:	ee 1b 80 00 	eorh	r11,0x8000
800077c0:	50 9a       	stdsp	sp[0x24],r10
800077c2:	50 6b       	stdsp	sp[0x18],r11
800077c4:	e0 40 00 46 	cp.w	r0,70
800077c8:	5f 09       	sreq	r9
800077ca:	e0 40 00 66 	cp.w	r0,102
800077ce:	5f 08       	sreq	r8
800077d0:	f3 e8 10 08 	or	r8,r9,r8
800077d4:	50 48       	stdsp	sp[0x10],r8
800077d6:	c0 40       	breq	800077de <_vfprintf_r+0x952>
800077d8:	40 22       	lddsp	r2,sp[0x8]
800077da:	30 39       	mov	r9,3
800077dc:	c1 08       	rjmp	800077fc <_vfprintf_r+0x970>
800077de:	e0 40 00 45 	cp.w	r0,69
800077e2:	5f 09       	sreq	r9
800077e4:	e0 40 00 65 	cp.w	r0,101
800077e8:	5f 08       	sreq	r8
800077ea:	40 22       	lddsp	r2,sp[0x8]
800077ec:	10 49       	or	r9,r8
800077ee:	2f f2       	sub	r2,-1
800077f0:	40 46       	lddsp	r6,sp[0x10]
800077f2:	ec 09 18 00 	cp.b	r9,r6
800077f6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800077fa:	30 29       	mov	r9,2
800077fc:	fa c8 f9 5c 	sub	r8,sp,-1700
80007800:	1a d8       	st.w	--sp,r8
80007802:	fa c8 f9 54 	sub	r8,sp,-1708
80007806:	1a d8       	st.w	--sp,r8
80007808:	fa c8 f9 4c 	sub	r8,sp,-1716
8000780c:	08 9c       	mov	r12,r4
8000780e:	1a d8       	st.w	--sp,r8
80007810:	04 98       	mov	r8,r2
80007812:	40 9b       	lddsp	r11,sp[0x24]
80007814:	40 aa       	lddsp	r10,sp[0x28]
80007816:	e0 a0 0b c3 	rcall	80008f9c <_dtoa_r>
8000781a:	e0 40 00 47 	cp.w	r0,71
8000781e:	5f 19       	srne	r9
80007820:	e0 40 00 67 	cp.w	r0,103
80007824:	5f 18       	srne	r8
80007826:	18 96       	mov	r6,r12
80007828:	2f dd       	sub	sp,-12
8000782a:	f3 e8 00 08 	and	r8,r9,r8
8000782e:	c0 41       	brne	80007836 <_vfprintf_r+0x9aa>
80007830:	ed b5 00 00 	bld	r5,0x0
80007834:	c3 01       	brne	80007894 <_vfprintf_r+0xa08>
80007836:	ec 02 00 0e 	add	lr,r6,r2
8000783a:	50 3e       	stdsp	sp[0xc],lr
8000783c:	40 4c       	lddsp	r12,sp[0x10]
8000783e:	58 0c       	cp.w	r12,0
80007840:	c1 50       	breq	8000786a <_vfprintf_r+0x9de>
80007842:	0d 89       	ld.ub	r9,r6[0x0]
80007844:	33 08       	mov	r8,48
80007846:	f0 09 18 00 	cp.b	r9,r8
8000784a:	c0 b1       	brne	80007860 <_vfprintf_r+0x9d4>
8000784c:	30 08       	mov	r8,0
8000784e:	30 09       	mov	r9,0
80007850:	40 6b       	lddsp	r11,sp[0x18]
80007852:	40 7a       	lddsp	r10,sp[0x1c]
80007854:	e0 a0 1c cb 	rcall	8000b1ea <__avr32_f64_cmp_eq>
80007858:	fb b2 00 01 	rsubeq	r2,1
8000785c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007860:	40 3b       	lddsp	r11,sp[0xc]
80007862:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007866:	10 0b       	add	r11,r8
80007868:	50 3b       	stdsp	sp[0xc],r11
8000786a:	40 6b       	lddsp	r11,sp[0x18]
8000786c:	30 08       	mov	r8,0
8000786e:	30 09       	mov	r9,0
80007870:	40 7a       	lddsp	r10,sp[0x1c]
80007872:	e0 a0 1c bc 	rcall	8000b1ea <__avr32_f64_cmp_eq>
80007876:	c0 90       	breq	80007888 <_vfprintf_r+0x9fc>
80007878:	40 3a       	lddsp	r10,sp[0xc]
8000787a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000787e:	c0 58       	rjmp	80007888 <_vfprintf_r+0x9fc>
80007880:	10 c9       	st.b	r8++,r9
80007882:	fb 48 06 a4 	st.w	sp[1700],r8
80007886:	c0 28       	rjmp	8000788a <_vfprintf_r+0x9fe>
80007888:	33 09       	mov	r9,48
8000788a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000788e:	40 3e       	lddsp	lr,sp[0xc]
80007890:	1c 38       	cp.w	r8,lr
80007892:	cf 73       	brcs	80007880 <_vfprintf_r+0x9f4>
80007894:	e0 40 00 47 	cp.w	r0,71
80007898:	5f 09       	sreq	r9
8000789a:	e0 40 00 67 	cp.w	r0,103
8000789e:	5f 08       	sreq	r8
800078a0:	f3 e8 10 08 	or	r8,r9,r8
800078a4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800078a8:	0c 19       	sub	r9,r6
800078aa:	50 69       	stdsp	sp[0x18],r9
800078ac:	58 08       	cp.w	r8,0
800078ae:	c0 b0       	breq	800078c4 <_vfprintf_r+0xa38>
800078b0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800078b4:	5b d8       	cp.w	r8,-3
800078b6:	c0 55       	brlt	800078c0 <_vfprintf_r+0xa34>
800078b8:	40 2c       	lddsp	r12,sp[0x8]
800078ba:	18 38       	cp.w	r8,r12
800078bc:	e0 8a 00 6a 	brle	80007990 <_vfprintf_r+0xb04>
800078c0:	20 20       	sub	r0,2
800078c2:	c0 58       	rjmp	800078cc <_vfprintf_r+0xa40>
800078c4:	e0 40 00 65 	cp.w	r0,101
800078c8:	e0 89 00 46 	brgt	80007954 <_vfprintf_r+0xac8>
800078cc:	fa fb 06 ac 	ld.w	r11,sp[1708]
800078d0:	fb 60 06 9c 	st.b	sp[1692],r0
800078d4:	20 1b       	sub	r11,1
800078d6:	fb 4b 06 ac 	st.w	sp[1708],r11
800078da:	c0 47       	brpl	800078e2 <_vfprintf_r+0xa56>
800078dc:	5c 3b       	neg	r11
800078de:	32 d8       	mov	r8,45
800078e0:	c0 28       	rjmp	800078e4 <_vfprintf_r+0xa58>
800078e2:	32 b8       	mov	r8,43
800078e4:	fb 68 06 9d 	st.b	sp[1693],r8
800078e8:	58 9b       	cp.w	r11,9
800078ea:	e0 8a 00 1d 	brle	80007924 <_vfprintf_r+0xa98>
800078ee:	fa c9 fa 35 	sub	r9,sp,-1483
800078f2:	30 aa       	mov	r10,10
800078f4:	12 98       	mov	r8,r9
800078f6:	0e 9c       	mov	r12,r7
800078f8:	0c 92       	mov	r2,r6
800078fa:	f6 0a 0c 06 	divs	r6,r11,r10
800078fe:	0e 9b       	mov	r11,r7
80007900:	2d 0b       	sub	r11,-48
80007902:	10 fb       	st.b	--r8,r11
80007904:	0c 9b       	mov	r11,r6
80007906:	58 96       	cp.w	r6,9
80007908:	fe 99 ff f9 	brgt	800078fa <_vfprintf_r+0xa6e>
8000790c:	2d 0b       	sub	r11,-48
8000790e:	18 97       	mov	r7,r12
80007910:	04 96       	mov	r6,r2
80007912:	10 fb       	st.b	--r8,r11
80007914:	fa ca f9 62 	sub	r10,sp,-1694
80007918:	c0 38       	rjmp	8000791e <_vfprintf_r+0xa92>
8000791a:	11 3b       	ld.ub	r11,r8++
8000791c:	14 cb       	st.b	r10++,r11
8000791e:	12 38       	cp.w	r8,r9
80007920:	cf d3       	brcs	8000791a <_vfprintf_r+0xa8e>
80007922:	c0 98       	rjmp	80007934 <_vfprintf_r+0xaa8>
80007924:	2d 0b       	sub	r11,-48
80007926:	33 08       	mov	r8,48
80007928:	fb 6b 06 9f 	st.b	sp[1695],r11
8000792c:	fb 68 06 9e 	st.b	sp[1694],r8
80007930:	fa ca f9 60 	sub	r10,sp,-1696
80007934:	fa c8 f9 64 	sub	r8,sp,-1692
80007938:	f4 08 01 08 	sub	r8,r10,r8
8000793c:	50 e8       	stdsp	sp[0x38],r8
8000793e:	10 92       	mov	r2,r8
80007940:	40 6b       	lddsp	r11,sp[0x18]
80007942:	16 02       	add	r2,r11
80007944:	58 1b       	cp.w	r11,1
80007946:	e0 89 00 05 	brgt	80007950 <_vfprintf_r+0xac4>
8000794a:	ed b5 00 00 	bld	r5,0x0
8000794e:	c3 51       	brne	800079b8 <_vfprintf_r+0xb2c>
80007950:	2f f2       	sub	r2,-1
80007952:	c3 38       	rjmp	800079b8 <_vfprintf_r+0xb2c>
80007954:	e0 40 00 66 	cp.w	r0,102
80007958:	c1 c1       	brne	80007990 <_vfprintf_r+0xb04>
8000795a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000795e:	58 02       	cp.w	r2,0
80007960:	e0 8a 00 0c 	brle	80007978 <_vfprintf_r+0xaec>
80007964:	40 2a       	lddsp	r10,sp[0x8]
80007966:	58 0a       	cp.w	r10,0
80007968:	c0 41       	brne	80007970 <_vfprintf_r+0xae4>
8000796a:	ed b5 00 00 	bld	r5,0x0
8000796e:	c2 51       	brne	800079b8 <_vfprintf_r+0xb2c>
80007970:	2f f2       	sub	r2,-1
80007972:	40 29       	lddsp	r9,sp[0x8]
80007974:	12 02       	add	r2,r9
80007976:	c0 b8       	rjmp	8000798c <_vfprintf_r+0xb00>
80007978:	40 28       	lddsp	r8,sp[0x8]
8000797a:	58 08       	cp.w	r8,0
8000797c:	c0 61       	brne	80007988 <_vfprintf_r+0xafc>
8000797e:	ed b5 00 00 	bld	r5,0x0
80007982:	c0 30       	breq	80007988 <_vfprintf_r+0xafc>
80007984:	30 12       	mov	r2,1
80007986:	c1 98       	rjmp	800079b8 <_vfprintf_r+0xb2c>
80007988:	40 22       	lddsp	r2,sp[0x8]
8000798a:	2f e2       	sub	r2,-2
8000798c:	36 60       	mov	r0,102
8000798e:	c1 58       	rjmp	800079b8 <_vfprintf_r+0xb2c>
80007990:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007994:	40 6e       	lddsp	lr,sp[0x18]
80007996:	1c 32       	cp.w	r2,lr
80007998:	c0 65       	brlt	800079a4 <_vfprintf_r+0xb18>
8000799a:	ed b5 00 00 	bld	r5,0x0
8000799e:	f7 b2 00 ff 	subeq	r2,-1
800079a2:	c0 a8       	rjmp	800079b6 <_vfprintf_r+0xb2a>
800079a4:	e4 08 11 02 	rsub	r8,r2,2
800079a8:	40 6c       	lddsp	r12,sp[0x18]
800079aa:	58 02       	cp.w	r2,0
800079ac:	f0 02 17 a0 	movle	r2,r8
800079b0:	f9 b2 09 01 	movgt	r2,1
800079b4:	18 02       	add	r2,r12
800079b6:	36 70       	mov	r0,103
800079b8:	40 9b       	lddsp	r11,sp[0x24]
800079ba:	58 0b       	cp.w	r11,0
800079bc:	e0 80 05 94 	breq	800084e4 <_vfprintf_r+0x1658>
800079c0:	32 d8       	mov	r8,45
800079c2:	fb 68 06 bb 	st.b	sp[1723],r8
800079c6:	e0 8f 05 93 	bral	800084ec <_vfprintf_r+0x1660>
800079ca:	50 a7       	stdsp	sp[0x28],r7
800079cc:	04 94       	mov	r4,r2
800079ce:	0c 97       	mov	r7,r6
800079d0:	02 92       	mov	r2,r1
800079d2:	06 96       	mov	r6,r3
800079d4:	40 41       	lddsp	r1,sp[0x10]
800079d6:	40 93       	lddsp	r3,sp[0x24]
800079d8:	0e 99       	mov	r9,r7
800079da:	ed b5 00 05 	bld	r5,0x5
800079de:	c4 81       	brne	80007a6e <_vfprintf_r+0xbe2>
800079e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079e4:	40 3e       	lddsp	lr,sp[0xc]
800079e6:	58 0e       	cp.w	lr,0
800079e8:	c1 d0       	breq	80007a22 <_vfprintf_r+0xb96>
800079ea:	10 36       	cp.w	r6,r8
800079ec:	c0 64       	brge	800079f8 <_vfprintf_r+0xb6c>
800079ee:	fa cc f9 44 	sub	r12,sp,-1724
800079f2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800079f6:	c1 d8       	rjmp	80007a30 <_vfprintf_r+0xba4>
800079f8:	fa c8 f9 50 	sub	r8,sp,-1712
800079fc:	1a d8       	st.w	--sp,r8
800079fe:	fa c8 fa b8 	sub	r8,sp,-1352
80007a02:	04 9a       	mov	r10,r2
80007a04:	1a d8       	st.w	--sp,r8
80007a06:	fa c8 fb b4 	sub	r8,sp,-1100
80007a0a:	0c 9b       	mov	r11,r6
80007a0c:	1a d8       	st.w	--sp,r8
80007a0e:	08 9c       	mov	r12,r4
80007a10:	fa c8 f9 40 	sub	r8,sp,-1728
80007a14:	fa c9 ff b4 	sub	r9,sp,-76
80007a18:	fe b0 f8 a2 	rcall	80006b5c <get_arg>
80007a1c:	2f dd       	sub	sp,-12
80007a1e:	78 0a       	ld.w	r10,r12[0x0]
80007a20:	c2 08       	rjmp	80007a60 <_vfprintf_r+0xbd4>
80007a22:	2f f7       	sub	r7,-1
80007a24:	10 39       	cp.w	r9,r8
80007a26:	c0 84       	brge	80007a36 <_vfprintf_r+0xbaa>
80007a28:	fa cb f9 44 	sub	r11,sp,-1724
80007a2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a30:	ec fa fd 88 	ld.w	r10,r6[-632]
80007a34:	c1 68       	rjmp	80007a60 <_vfprintf_r+0xbd4>
80007a36:	41 09       	lddsp	r9,sp[0x40]
80007a38:	59 f8       	cp.w	r8,31
80007a3a:	e0 89 00 10 	brgt	80007a5a <_vfprintf_r+0xbce>
80007a3e:	f2 ca ff fc 	sub	r10,r9,-4
80007a42:	51 0a       	stdsp	sp[0x40],r10
80007a44:	fa c6 f9 44 	sub	r6,sp,-1724
80007a48:	72 0a       	ld.w	r10,r9[0x0]
80007a4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007a4e:	f3 4a fd 88 	st.w	r9[-632],r10
80007a52:	2f f8       	sub	r8,-1
80007a54:	fb 48 06 b4 	st.w	sp[1716],r8
80007a58:	c0 48       	rjmp	80007a60 <_vfprintf_r+0xbd4>
80007a5a:	72 0a       	ld.w	r10,r9[0x0]
80007a5c:	2f c9       	sub	r9,-4
80007a5e:	51 09       	stdsp	sp[0x40],r9
80007a60:	40 be       	lddsp	lr,sp[0x2c]
80007a62:	1c 98       	mov	r8,lr
80007a64:	95 1e       	st.w	r10[0x4],lr
80007a66:	bf 58       	asr	r8,0x1f
80007a68:	95 08       	st.w	r10[0x0],r8
80007a6a:	fe 9f fa 9f 	bral	80006fa8 <_vfprintf_r+0x11c>
80007a6e:	ed b5 00 04 	bld	r5,0x4
80007a72:	c4 80       	breq	80007b02 <_vfprintf_r+0xc76>
80007a74:	e2 15 00 40 	andl	r5,0x40,COH
80007a78:	c4 50       	breq	80007b02 <_vfprintf_r+0xc76>
80007a7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a7e:	40 3c       	lddsp	r12,sp[0xc]
80007a80:	58 0c       	cp.w	r12,0
80007a82:	c1 d0       	breq	80007abc <_vfprintf_r+0xc30>
80007a84:	10 36       	cp.w	r6,r8
80007a86:	c0 64       	brge	80007a92 <_vfprintf_r+0xc06>
80007a88:	fa cb f9 44 	sub	r11,sp,-1724
80007a8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a90:	c1 d8       	rjmp	80007aca <_vfprintf_r+0xc3e>
80007a92:	fa c8 f9 50 	sub	r8,sp,-1712
80007a96:	1a d8       	st.w	--sp,r8
80007a98:	fa c8 fa b8 	sub	r8,sp,-1352
80007a9c:	04 9a       	mov	r10,r2
80007a9e:	1a d8       	st.w	--sp,r8
80007aa0:	fa c8 fb b4 	sub	r8,sp,-1100
80007aa4:	0c 9b       	mov	r11,r6
80007aa6:	1a d8       	st.w	--sp,r8
80007aa8:	08 9c       	mov	r12,r4
80007aaa:	fa c8 f9 40 	sub	r8,sp,-1728
80007aae:	fa c9 ff b4 	sub	r9,sp,-76
80007ab2:	fe b0 f8 55 	rcall	80006b5c <get_arg>
80007ab6:	2f dd       	sub	sp,-12
80007ab8:	78 0a       	ld.w	r10,r12[0x0]
80007aba:	c2 08       	rjmp	80007afa <_vfprintf_r+0xc6e>
80007abc:	2f f7       	sub	r7,-1
80007abe:	10 39       	cp.w	r9,r8
80007ac0:	c0 84       	brge	80007ad0 <_vfprintf_r+0xc44>
80007ac2:	fa ca f9 44 	sub	r10,sp,-1724
80007ac6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007aca:	ec fa fd 88 	ld.w	r10,r6[-632]
80007ace:	c1 68       	rjmp	80007afa <_vfprintf_r+0xc6e>
80007ad0:	41 09       	lddsp	r9,sp[0x40]
80007ad2:	59 f8       	cp.w	r8,31
80007ad4:	e0 89 00 10 	brgt	80007af4 <_vfprintf_r+0xc68>
80007ad8:	f2 ca ff fc 	sub	r10,r9,-4
80007adc:	51 0a       	stdsp	sp[0x40],r10
80007ade:	fa c6 f9 44 	sub	r6,sp,-1724
80007ae2:	72 0a       	ld.w	r10,r9[0x0]
80007ae4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ae8:	f3 4a fd 88 	st.w	r9[-632],r10
80007aec:	2f f8       	sub	r8,-1
80007aee:	fb 48 06 b4 	st.w	sp[1716],r8
80007af2:	c0 48       	rjmp	80007afa <_vfprintf_r+0xc6e>
80007af4:	72 0a       	ld.w	r10,r9[0x0]
80007af6:	2f c9       	sub	r9,-4
80007af8:	51 09       	stdsp	sp[0x40],r9
80007afa:	40 be       	lddsp	lr,sp[0x2c]
80007afc:	b4 0e       	st.h	r10[0x0],lr
80007afe:	fe 9f fa 55 	bral	80006fa8 <_vfprintf_r+0x11c>
80007b02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b06:	40 3c       	lddsp	r12,sp[0xc]
80007b08:	58 0c       	cp.w	r12,0
80007b0a:	c1 d0       	breq	80007b44 <_vfprintf_r+0xcb8>
80007b0c:	10 36       	cp.w	r6,r8
80007b0e:	c0 64       	brge	80007b1a <_vfprintf_r+0xc8e>
80007b10:	fa cb f9 44 	sub	r11,sp,-1724
80007b14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b18:	c1 d8       	rjmp	80007b52 <_vfprintf_r+0xcc6>
80007b1a:	fa c8 f9 50 	sub	r8,sp,-1712
80007b1e:	1a d8       	st.w	--sp,r8
80007b20:	fa c8 fa b8 	sub	r8,sp,-1352
80007b24:	04 9a       	mov	r10,r2
80007b26:	1a d8       	st.w	--sp,r8
80007b28:	fa c8 fb b4 	sub	r8,sp,-1100
80007b2c:	0c 9b       	mov	r11,r6
80007b2e:	1a d8       	st.w	--sp,r8
80007b30:	08 9c       	mov	r12,r4
80007b32:	fa c8 f9 40 	sub	r8,sp,-1728
80007b36:	fa c9 ff b4 	sub	r9,sp,-76
80007b3a:	fe b0 f8 11 	rcall	80006b5c <get_arg>
80007b3e:	2f dd       	sub	sp,-12
80007b40:	78 0a       	ld.w	r10,r12[0x0]
80007b42:	c2 08       	rjmp	80007b82 <_vfprintf_r+0xcf6>
80007b44:	2f f7       	sub	r7,-1
80007b46:	10 39       	cp.w	r9,r8
80007b48:	c0 84       	brge	80007b58 <_vfprintf_r+0xccc>
80007b4a:	fa ca f9 44 	sub	r10,sp,-1724
80007b4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007b52:	ec fa fd 88 	ld.w	r10,r6[-632]
80007b56:	c1 68       	rjmp	80007b82 <_vfprintf_r+0xcf6>
80007b58:	41 09       	lddsp	r9,sp[0x40]
80007b5a:	59 f8       	cp.w	r8,31
80007b5c:	e0 89 00 10 	brgt	80007b7c <_vfprintf_r+0xcf0>
80007b60:	f2 ca ff fc 	sub	r10,r9,-4
80007b64:	51 0a       	stdsp	sp[0x40],r10
80007b66:	fa c6 f9 44 	sub	r6,sp,-1724
80007b6a:	72 0a       	ld.w	r10,r9[0x0]
80007b6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007b70:	f3 4a fd 88 	st.w	r9[-632],r10
80007b74:	2f f8       	sub	r8,-1
80007b76:	fb 48 06 b4 	st.w	sp[1716],r8
80007b7a:	c0 48       	rjmp	80007b82 <_vfprintf_r+0xcf6>
80007b7c:	72 0a       	ld.w	r10,r9[0x0]
80007b7e:	2f c9       	sub	r9,-4
80007b80:	51 09       	stdsp	sp[0x40],r9
80007b82:	40 be       	lddsp	lr,sp[0x2c]
80007b84:	95 0e       	st.w	r10[0x0],lr
80007b86:	fe 9f fa 11 	bral	80006fa8 <_vfprintf_r+0x11c>
80007b8a:	50 a7       	stdsp	sp[0x28],r7
80007b8c:	50 80       	stdsp	sp[0x20],r0
80007b8e:	0c 97       	mov	r7,r6
80007b90:	04 94       	mov	r4,r2
80007b92:	06 96       	mov	r6,r3
80007b94:	02 92       	mov	r2,r1
80007b96:	40 93       	lddsp	r3,sp[0x24]
80007b98:	10 90       	mov	r0,r8
80007b9a:	40 41       	lddsp	r1,sp[0x10]
80007b9c:	a5 a5       	sbr	r5,0x4
80007b9e:	c0 a8       	rjmp	80007bb2 <_vfprintf_r+0xd26>
80007ba0:	50 a7       	stdsp	sp[0x28],r7
80007ba2:	50 80       	stdsp	sp[0x20],r0
80007ba4:	0c 97       	mov	r7,r6
80007ba6:	04 94       	mov	r4,r2
80007ba8:	06 96       	mov	r6,r3
80007baa:	02 92       	mov	r2,r1
80007bac:	40 93       	lddsp	r3,sp[0x24]
80007bae:	10 90       	mov	r0,r8
80007bb0:	40 41       	lddsp	r1,sp[0x10]
80007bb2:	ed b5 00 05 	bld	r5,0x5
80007bb6:	c5 d1       	brne	80007c70 <_vfprintf_r+0xde4>
80007bb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bbc:	40 3c       	lddsp	r12,sp[0xc]
80007bbe:	58 0c       	cp.w	r12,0
80007bc0:	c2 60       	breq	80007c0c <_vfprintf_r+0xd80>
80007bc2:	10 36       	cp.w	r6,r8
80007bc4:	c0 a4       	brge	80007bd8 <_vfprintf_r+0xd4c>
80007bc6:	fa cb f9 44 	sub	r11,sp,-1724
80007bca:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007bce:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007bd2:	fa e9 00 00 	st.d	sp[0],r8
80007bd6:	c1 88       	rjmp	80007c06 <_vfprintf_r+0xd7a>
80007bd8:	fa c8 f9 50 	sub	r8,sp,-1712
80007bdc:	1a d8       	st.w	--sp,r8
80007bde:	fa c8 fa b8 	sub	r8,sp,-1352
80007be2:	04 9a       	mov	r10,r2
80007be4:	1a d8       	st.w	--sp,r8
80007be6:	0c 9b       	mov	r11,r6
80007be8:	fa c8 fb b4 	sub	r8,sp,-1100
80007bec:	08 9c       	mov	r12,r4
80007bee:	1a d8       	st.w	--sp,r8
80007bf0:	fa c8 f9 40 	sub	r8,sp,-1728
80007bf4:	fa c9 ff b4 	sub	r9,sp,-76
80007bf8:	fe b0 f7 b2 	rcall	80006b5c <get_arg>
80007bfc:	2f dd       	sub	sp,-12
80007bfe:	f8 ea 00 00 	ld.d	r10,r12[0]
80007c02:	fa eb 00 00 	st.d	sp[0],r10
80007c06:	30 08       	mov	r8,0
80007c08:	e0 8f 03 de 	bral	800083c4 <_vfprintf_r+0x1538>
80007c0c:	ee ca ff ff 	sub	r10,r7,-1
80007c10:	10 37       	cp.w	r7,r8
80007c12:	c0 b4       	brge	80007c28 <_vfprintf_r+0xd9c>
80007c14:	fa c9 f9 44 	sub	r9,sp,-1724
80007c18:	14 97       	mov	r7,r10
80007c1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c1e:	ec ea fd 88 	ld.d	r10,r6[-632]
80007c22:	fa eb 00 00 	st.d	sp[0],r10
80007c26:	c1 88       	rjmp	80007c56 <_vfprintf_r+0xdca>
80007c28:	41 09       	lddsp	r9,sp[0x40]
80007c2a:	59 f8       	cp.w	r8,31
80007c2c:	e0 89 00 18 	brgt	80007c5c <_vfprintf_r+0xdd0>
80007c30:	f2 e6 00 00 	ld.d	r6,r9[0]
80007c34:	f2 cb ff f8 	sub	r11,r9,-8
80007c38:	fa e7 00 00 	st.d	sp[0],r6
80007c3c:	51 0b       	stdsp	sp[0x40],r11
80007c3e:	fa c6 f9 44 	sub	r6,sp,-1724
80007c42:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007c46:	fa e6 00 00 	ld.d	r6,sp[0]
80007c4a:	f2 e7 fd 88 	st.d	r9[-632],r6
80007c4e:	2f f8       	sub	r8,-1
80007c50:	14 97       	mov	r7,r10
80007c52:	fb 48 06 b4 	st.w	sp[1716],r8
80007c56:	40 38       	lddsp	r8,sp[0xc]
80007c58:	e0 8f 03 b6 	bral	800083c4 <_vfprintf_r+0x1538>
80007c5c:	f2 e6 00 00 	ld.d	r6,r9[0]
80007c60:	40 38       	lddsp	r8,sp[0xc]
80007c62:	fa e7 00 00 	st.d	sp[0],r6
80007c66:	2f 89       	sub	r9,-8
80007c68:	14 97       	mov	r7,r10
80007c6a:	51 09       	stdsp	sp[0x40],r9
80007c6c:	e0 8f 03 ac 	bral	800083c4 <_vfprintf_r+0x1538>
80007c70:	ed b5 00 04 	bld	r5,0x4
80007c74:	c1 61       	brne	80007ca0 <_vfprintf_r+0xe14>
80007c76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c7a:	40 3e       	lddsp	lr,sp[0xc]
80007c7c:	58 0e       	cp.w	lr,0
80007c7e:	c0 80       	breq	80007c8e <_vfprintf_r+0xe02>
80007c80:	10 36       	cp.w	r6,r8
80007c82:	c6 74       	brge	80007d50 <_vfprintf_r+0xec4>
80007c84:	fa cc f9 44 	sub	r12,sp,-1724
80007c88:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c8c:	c8 08       	rjmp	80007d8c <_vfprintf_r+0xf00>
80007c8e:	ee ca ff ff 	sub	r10,r7,-1
80007c92:	10 37       	cp.w	r7,r8
80007c94:	c7 f4       	brge	80007d92 <_vfprintf_r+0xf06>
80007c96:	fa cb f9 44 	sub	r11,sp,-1724
80007c9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c9e:	c7 68       	rjmp	80007d8a <_vfprintf_r+0xefe>
80007ca0:	ed b5 00 06 	bld	r5,0x6
80007ca4:	c4 a1       	brne	80007d38 <_vfprintf_r+0xeac>
80007ca6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007caa:	40 3c       	lddsp	r12,sp[0xc]
80007cac:	58 0c       	cp.w	r12,0
80007cae:	c1 d0       	breq	80007ce8 <_vfprintf_r+0xe5c>
80007cb0:	10 36       	cp.w	r6,r8
80007cb2:	c0 64       	brge	80007cbe <_vfprintf_r+0xe32>
80007cb4:	fa cb f9 44 	sub	r11,sp,-1724
80007cb8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cbc:	c1 f8       	rjmp	80007cfa <_vfprintf_r+0xe6e>
80007cbe:	fa c8 f9 50 	sub	r8,sp,-1712
80007cc2:	1a d8       	st.w	--sp,r8
80007cc4:	fa c8 fa b8 	sub	r8,sp,-1352
80007cc8:	1a d8       	st.w	--sp,r8
80007cca:	fa c8 fb b4 	sub	r8,sp,-1100
80007cce:	1a d8       	st.w	--sp,r8
80007cd0:	fa c8 f9 40 	sub	r8,sp,-1728
80007cd4:	fa c9 ff b4 	sub	r9,sp,-76
80007cd8:	04 9a       	mov	r10,r2
80007cda:	0c 9b       	mov	r11,r6
80007cdc:	08 9c       	mov	r12,r4
80007cde:	fe b0 f7 3f 	rcall	80006b5c <get_arg>
80007ce2:	2f dd       	sub	sp,-12
80007ce4:	98 18       	ld.sh	r8,r12[0x2]
80007ce6:	c2 68       	rjmp	80007d32 <_vfprintf_r+0xea6>
80007ce8:	ee ca ff ff 	sub	r10,r7,-1
80007cec:	10 37       	cp.w	r7,r8
80007cee:	c0 94       	brge	80007d00 <_vfprintf_r+0xe74>
80007cf0:	fa c9 f9 44 	sub	r9,sp,-1724
80007cf4:	14 97       	mov	r7,r10
80007cf6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007cfa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007cfe:	c1 a8       	rjmp	80007d32 <_vfprintf_r+0xea6>
80007d00:	41 09       	lddsp	r9,sp[0x40]
80007d02:	59 f8       	cp.w	r8,31
80007d04:	e0 89 00 13 	brgt	80007d2a <_vfprintf_r+0xe9e>
80007d08:	f2 cb ff fc 	sub	r11,r9,-4
80007d0c:	51 0b       	stdsp	sp[0x40],r11
80007d0e:	72 09       	ld.w	r9,r9[0x0]
80007d10:	fa c6 f9 44 	sub	r6,sp,-1724
80007d14:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007d18:	2f f8       	sub	r8,-1
80007d1a:	f7 49 fd 88 	st.w	r11[-632],r9
80007d1e:	fb 48 06 b4 	st.w	sp[1716],r8
80007d22:	14 97       	mov	r7,r10
80007d24:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007d28:	c0 58       	rjmp	80007d32 <_vfprintf_r+0xea6>
80007d2a:	92 18       	ld.sh	r8,r9[0x2]
80007d2c:	14 97       	mov	r7,r10
80007d2e:	2f c9       	sub	r9,-4
80007d30:	51 09       	stdsp	sp[0x40],r9
80007d32:	5c 78       	castu.h	r8
80007d34:	50 18       	stdsp	sp[0x4],r8
80007d36:	c4 68       	rjmp	80007dc2 <_vfprintf_r+0xf36>
80007d38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d3c:	40 3c       	lddsp	r12,sp[0xc]
80007d3e:	58 0c       	cp.w	r12,0
80007d40:	c1 d0       	breq	80007d7a <_vfprintf_r+0xeee>
80007d42:	10 36       	cp.w	r6,r8
80007d44:	c0 64       	brge	80007d50 <_vfprintf_r+0xec4>
80007d46:	fa cb f9 44 	sub	r11,sp,-1724
80007d4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d4e:	c1 f8       	rjmp	80007d8c <_vfprintf_r+0xf00>
80007d50:	fa c8 f9 50 	sub	r8,sp,-1712
80007d54:	1a d8       	st.w	--sp,r8
80007d56:	fa c8 fa b8 	sub	r8,sp,-1352
80007d5a:	0c 9b       	mov	r11,r6
80007d5c:	1a d8       	st.w	--sp,r8
80007d5e:	fa c8 fb b4 	sub	r8,sp,-1100
80007d62:	04 9a       	mov	r10,r2
80007d64:	1a d8       	st.w	--sp,r8
80007d66:	08 9c       	mov	r12,r4
80007d68:	fa c8 f9 40 	sub	r8,sp,-1728
80007d6c:	fa c9 ff b4 	sub	r9,sp,-76
80007d70:	fe b0 f6 f6 	rcall	80006b5c <get_arg>
80007d74:	2f dd       	sub	sp,-12
80007d76:	78 0b       	ld.w	r11,r12[0x0]
80007d78:	c2 48       	rjmp	80007dc0 <_vfprintf_r+0xf34>
80007d7a:	ee ca ff ff 	sub	r10,r7,-1
80007d7e:	10 37       	cp.w	r7,r8
80007d80:	c0 94       	brge	80007d92 <_vfprintf_r+0xf06>
80007d82:	fa c9 f9 44 	sub	r9,sp,-1724
80007d86:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d8a:	14 97       	mov	r7,r10
80007d8c:	ec fb fd 88 	ld.w	r11,r6[-632]
80007d90:	c1 88       	rjmp	80007dc0 <_vfprintf_r+0xf34>
80007d92:	41 09       	lddsp	r9,sp[0x40]
80007d94:	59 f8       	cp.w	r8,31
80007d96:	e0 89 00 11 	brgt	80007db8 <_vfprintf_r+0xf2c>
80007d9a:	f2 cb ff fc 	sub	r11,r9,-4
80007d9e:	51 0b       	stdsp	sp[0x40],r11
80007da0:	fa c6 f9 44 	sub	r6,sp,-1724
80007da4:	72 0b       	ld.w	r11,r9[0x0]
80007da6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007daa:	f3 4b fd 88 	st.w	r9[-632],r11
80007dae:	2f f8       	sub	r8,-1
80007db0:	14 97       	mov	r7,r10
80007db2:	fb 48 06 b4 	st.w	sp[1716],r8
80007db6:	c0 58       	rjmp	80007dc0 <_vfprintf_r+0xf34>
80007db8:	72 0b       	ld.w	r11,r9[0x0]
80007dba:	14 97       	mov	r7,r10
80007dbc:	2f c9       	sub	r9,-4
80007dbe:	51 09       	stdsp	sp[0x40],r9
80007dc0:	50 1b       	stdsp	sp[0x4],r11
80007dc2:	30 0e       	mov	lr,0
80007dc4:	50 0e       	stdsp	sp[0x0],lr
80007dc6:	1c 98       	mov	r8,lr
80007dc8:	e0 8f 02 fe 	bral	800083c4 <_vfprintf_r+0x1538>
80007dcc:	50 a7       	stdsp	sp[0x28],r7
80007dce:	50 80       	stdsp	sp[0x20],r0
80007dd0:	0c 97       	mov	r7,r6
80007dd2:	04 94       	mov	r4,r2
80007dd4:	06 96       	mov	r6,r3
80007dd6:	02 92       	mov	r2,r1
80007dd8:	40 93       	lddsp	r3,sp[0x24]
80007dda:	40 41       	lddsp	r1,sp[0x10]
80007ddc:	0e 99       	mov	r9,r7
80007dde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007de2:	40 3c       	lddsp	r12,sp[0xc]
80007de4:	58 0c       	cp.w	r12,0
80007de6:	c1 d0       	breq	80007e20 <_vfprintf_r+0xf94>
80007de8:	10 36       	cp.w	r6,r8
80007dea:	c0 64       	brge	80007df6 <_vfprintf_r+0xf6a>
80007dec:	fa cb f9 44 	sub	r11,sp,-1724
80007df0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007df4:	c1 d8       	rjmp	80007e2e <_vfprintf_r+0xfa2>
80007df6:	fa c8 f9 50 	sub	r8,sp,-1712
80007dfa:	1a d8       	st.w	--sp,r8
80007dfc:	fa c8 fa b8 	sub	r8,sp,-1352
80007e00:	1a d8       	st.w	--sp,r8
80007e02:	fa c8 fb b4 	sub	r8,sp,-1100
80007e06:	1a d8       	st.w	--sp,r8
80007e08:	fa c9 ff b4 	sub	r9,sp,-76
80007e0c:	fa c8 f9 40 	sub	r8,sp,-1728
80007e10:	04 9a       	mov	r10,r2
80007e12:	0c 9b       	mov	r11,r6
80007e14:	08 9c       	mov	r12,r4
80007e16:	fe b0 f6 a3 	rcall	80006b5c <get_arg>
80007e1a:	2f dd       	sub	sp,-12
80007e1c:	78 09       	ld.w	r9,r12[0x0]
80007e1e:	c2 18       	rjmp	80007e60 <_vfprintf_r+0xfd4>
80007e20:	2f f7       	sub	r7,-1
80007e22:	10 39       	cp.w	r9,r8
80007e24:	c0 84       	brge	80007e34 <_vfprintf_r+0xfa8>
80007e26:	fa ca f9 44 	sub	r10,sp,-1724
80007e2a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e2e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007e32:	c1 78       	rjmp	80007e60 <_vfprintf_r+0xfd4>
80007e34:	41 09       	lddsp	r9,sp[0x40]
80007e36:	59 f8       	cp.w	r8,31
80007e38:	e0 89 00 10 	brgt	80007e58 <_vfprintf_r+0xfcc>
80007e3c:	f2 ca ff fc 	sub	r10,r9,-4
80007e40:	51 0a       	stdsp	sp[0x40],r10
80007e42:	fa c6 f9 44 	sub	r6,sp,-1724
80007e46:	72 09       	ld.w	r9,r9[0x0]
80007e48:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007e4c:	f5 49 fd 88 	st.w	r10[-632],r9
80007e50:	2f f8       	sub	r8,-1
80007e52:	fb 48 06 b4 	st.w	sp[1716],r8
80007e56:	c0 58       	rjmp	80007e60 <_vfprintf_r+0xfd4>
80007e58:	f2 c8 ff fc 	sub	r8,r9,-4
80007e5c:	51 08       	stdsp	sp[0x40],r8
80007e5e:	72 09       	ld.w	r9,r9[0x0]
80007e60:	33 08       	mov	r8,48
80007e62:	fb 68 06 b8 	st.b	sp[1720],r8
80007e66:	37 88       	mov	r8,120
80007e68:	30 0e       	mov	lr,0
80007e6a:	fb 68 06 b9 	st.b	sp[1721],r8
80007e6e:	fe cc ac 3a 	sub	r12,pc,-21446
80007e72:	50 19       	stdsp	sp[0x4],r9
80007e74:	a1 b5       	sbr	r5,0x1
80007e76:	50 0e       	stdsp	sp[0x0],lr
80007e78:	50 dc       	stdsp	sp[0x34],r12
80007e7a:	30 28       	mov	r8,2
80007e7c:	37 80       	mov	r0,120
80007e7e:	e0 8f 02 a3 	bral	800083c4 <_vfprintf_r+0x1538>
80007e82:	50 a7       	stdsp	sp[0x28],r7
80007e84:	50 80       	stdsp	sp[0x20],r0
80007e86:	10 90       	mov	r0,r8
80007e88:	30 08       	mov	r8,0
80007e8a:	fb 68 06 bb 	st.b	sp[1723],r8
80007e8e:	0c 97       	mov	r7,r6
80007e90:	04 94       	mov	r4,r2
80007e92:	06 96       	mov	r6,r3
80007e94:	02 92       	mov	r2,r1
80007e96:	40 93       	lddsp	r3,sp[0x24]
80007e98:	40 41       	lddsp	r1,sp[0x10]
80007e9a:	0e 99       	mov	r9,r7
80007e9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ea0:	40 3b       	lddsp	r11,sp[0xc]
80007ea2:	58 0b       	cp.w	r11,0
80007ea4:	c1 d0       	breq	80007ede <_vfprintf_r+0x1052>
80007ea6:	10 36       	cp.w	r6,r8
80007ea8:	c0 64       	brge	80007eb4 <_vfprintf_r+0x1028>
80007eaa:	fa ca f9 44 	sub	r10,sp,-1724
80007eae:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007eb2:	c1 d8       	rjmp	80007eec <_vfprintf_r+0x1060>
80007eb4:	fa c8 f9 50 	sub	r8,sp,-1712
80007eb8:	1a d8       	st.w	--sp,r8
80007eba:	fa c8 fa b8 	sub	r8,sp,-1352
80007ebe:	1a d8       	st.w	--sp,r8
80007ec0:	fa c8 fb b4 	sub	r8,sp,-1100
80007ec4:	0c 9b       	mov	r11,r6
80007ec6:	1a d8       	st.w	--sp,r8
80007ec8:	04 9a       	mov	r10,r2
80007eca:	fa c8 f9 40 	sub	r8,sp,-1728
80007ece:	fa c9 ff b4 	sub	r9,sp,-76
80007ed2:	08 9c       	mov	r12,r4
80007ed4:	fe b0 f6 44 	rcall	80006b5c <get_arg>
80007ed8:	2f dd       	sub	sp,-12
80007eda:	78 06       	ld.w	r6,r12[0x0]
80007edc:	c2 08       	rjmp	80007f1c <_vfprintf_r+0x1090>
80007ede:	2f f7       	sub	r7,-1
80007ee0:	10 39       	cp.w	r9,r8
80007ee2:	c0 84       	brge	80007ef2 <_vfprintf_r+0x1066>
80007ee4:	fa c9 f9 44 	sub	r9,sp,-1724
80007ee8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007eec:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007ef0:	c1 68       	rjmp	80007f1c <_vfprintf_r+0x1090>
80007ef2:	41 09       	lddsp	r9,sp[0x40]
80007ef4:	59 f8       	cp.w	r8,31
80007ef6:	e0 89 00 10 	brgt	80007f16 <_vfprintf_r+0x108a>
80007efa:	f2 ca ff fc 	sub	r10,r9,-4
80007efe:	51 0a       	stdsp	sp[0x40],r10
80007f00:	72 06       	ld.w	r6,r9[0x0]
80007f02:	fa ce f9 44 	sub	lr,sp,-1724
80007f06:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007f0a:	f3 46 fd 88 	st.w	r9[-632],r6
80007f0e:	2f f8       	sub	r8,-1
80007f10:	fb 48 06 b4 	st.w	sp[1716],r8
80007f14:	c0 48       	rjmp	80007f1c <_vfprintf_r+0x1090>
80007f16:	72 06       	ld.w	r6,r9[0x0]
80007f18:	2f c9       	sub	r9,-4
80007f1a:	51 09       	stdsp	sp[0x40],r9
80007f1c:	40 2c       	lddsp	r12,sp[0x8]
80007f1e:	58 0c       	cp.w	r12,0
80007f20:	c1 05       	brlt	80007f40 <_vfprintf_r+0x10b4>
80007f22:	18 9a       	mov	r10,r12
80007f24:	30 0b       	mov	r11,0
80007f26:	0c 9c       	mov	r12,r6
80007f28:	e0 a0 12 38 	rcall	8000a398 <memchr>
80007f2c:	e0 80 02 df 	breq	800084ea <_vfprintf_r+0x165e>
80007f30:	f8 06 01 02 	sub	r2,r12,r6
80007f34:	40 2b       	lddsp	r11,sp[0x8]
80007f36:	16 32       	cp.w	r2,r11
80007f38:	e0 89 02 d9 	brgt	800084ea <_vfprintf_r+0x165e>
80007f3c:	e0 8f 02 d4 	bral	800084e4 <_vfprintf_r+0x1658>
80007f40:	30 0a       	mov	r10,0
80007f42:	0c 9c       	mov	r12,r6
80007f44:	50 2a       	stdsp	sp[0x8],r10
80007f46:	fe b0 f5 85 	rcall	80006a50 <strlen>
80007f4a:	18 92       	mov	r2,r12
80007f4c:	e0 8f 02 d2 	bral	800084f0 <_vfprintf_r+0x1664>
80007f50:	50 a7       	stdsp	sp[0x28],r7
80007f52:	50 80       	stdsp	sp[0x20],r0
80007f54:	0c 97       	mov	r7,r6
80007f56:	04 94       	mov	r4,r2
80007f58:	06 96       	mov	r6,r3
80007f5a:	02 92       	mov	r2,r1
80007f5c:	40 93       	lddsp	r3,sp[0x24]
80007f5e:	10 90       	mov	r0,r8
80007f60:	40 41       	lddsp	r1,sp[0x10]
80007f62:	a5 a5       	sbr	r5,0x4
80007f64:	c0 a8       	rjmp	80007f78 <_vfprintf_r+0x10ec>
80007f66:	50 a7       	stdsp	sp[0x28],r7
80007f68:	50 80       	stdsp	sp[0x20],r0
80007f6a:	0c 97       	mov	r7,r6
80007f6c:	04 94       	mov	r4,r2
80007f6e:	06 96       	mov	r6,r3
80007f70:	02 92       	mov	r2,r1
80007f72:	40 93       	lddsp	r3,sp[0x24]
80007f74:	10 90       	mov	r0,r8
80007f76:	40 41       	lddsp	r1,sp[0x10]
80007f78:	ed b5 00 05 	bld	r5,0x5
80007f7c:	c5 61       	brne	80008028 <_vfprintf_r+0x119c>
80007f7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f82:	40 39       	lddsp	r9,sp[0xc]
80007f84:	58 09       	cp.w	r9,0
80007f86:	c2 10       	breq	80007fc8 <_vfprintf_r+0x113c>
80007f88:	10 36       	cp.w	r6,r8
80007f8a:	c0 74       	brge	80007f98 <_vfprintf_r+0x110c>
80007f8c:	fa c8 f9 44 	sub	r8,sp,-1724
80007f90:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007f94:	c2 38       	rjmp	80007fda <_vfprintf_r+0x114e>
80007f96:	d7 03       	nop
80007f98:	fa c8 f9 50 	sub	r8,sp,-1712
80007f9c:	1a d8       	st.w	--sp,r8
80007f9e:	fa c8 fa b8 	sub	r8,sp,-1352
80007fa2:	1a d8       	st.w	--sp,r8
80007fa4:	fa c8 fb b4 	sub	r8,sp,-1100
80007fa8:	1a d8       	st.w	--sp,r8
80007faa:	fa c8 f9 40 	sub	r8,sp,-1728
80007fae:	fa c9 ff b4 	sub	r9,sp,-76
80007fb2:	04 9a       	mov	r10,r2
80007fb4:	0c 9b       	mov	r11,r6
80007fb6:	08 9c       	mov	r12,r4
80007fb8:	fe b0 f5 d2 	rcall	80006b5c <get_arg>
80007fbc:	2f dd       	sub	sp,-12
80007fbe:	f8 e8 00 00 	ld.d	r8,r12[0]
80007fc2:	fa e9 00 00 	st.d	sp[0],r8
80007fc6:	c2 e8       	rjmp	80008022 <_vfprintf_r+0x1196>
80007fc8:	ee ca ff ff 	sub	r10,r7,-1
80007fcc:	10 37       	cp.w	r7,r8
80007fce:	c0 b4       	brge	80007fe4 <_vfprintf_r+0x1158>
80007fd0:	fa c8 f9 44 	sub	r8,sp,-1724
80007fd4:	14 97       	mov	r7,r10
80007fd6:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007fda:	ec ea fd 88 	ld.d	r10,r6[-632]
80007fde:	fa eb 00 00 	st.d	sp[0],r10
80007fe2:	c2 08       	rjmp	80008022 <_vfprintf_r+0x1196>
80007fe4:	41 09       	lddsp	r9,sp[0x40]
80007fe6:	59 f8       	cp.w	r8,31
80007fe8:	e0 89 00 16 	brgt	80008014 <_vfprintf_r+0x1188>
80007fec:	f2 e6 00 00 	ld.d	r6,r9[0]
80007ff0:	f2 cb ff f8 	sub	r11,r9,-8
80007ff4:	fa e7 00 00 	st.d	sp[0],r6
80007ff8:	51 0b       	stdsp	sp[0x40],r11
80007ffa:	fa c6 f9 44 	sub	r6,sp,-1724
80007ffe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008002:	fa e6 00 00 	ld.d	r6,sp[0]
80008006:	f2 e7 fd 88 	st.d	r9[-632],r6
8000800a:	2f f8       	sub	r8,-1
8000800c:	14 97       	mov	r7,r10
8000800e:	fb 48 06 b4 	st.w	sp[1716],r8
80008012:	c0 88       	rjmp	80008022 <_vfprintf_r+0x1196>
80008014:	f2 e6 00 00 	ld.d	r6,r9[0]
80008018:	2f 89       	sub	r9,-8
8000801a:	fa e7 00 00 	st.d	sp[0],r6
8000801e:	51 09       	stdsp	sp[0x40],r9
80008020:	14 97       	mov	r7,r10
80008022:	30 18       	mov	r8,1
80008024:	e0 8f 01 d0 	bral	800083c4 <_vfprintf_r+0x1538>
80008028:	ed b5 00 04 	bld	r5,0x4
8000802c:	c1 61       	brne	80008058 <_vfprintf_r+0x11cc>
8000802e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008032:	40 3e       	lddsp	lr,sp[0xc]
80008034:	58 0e       	cp.w	lr,0
80008036:	c0 80       	breq	80008046 <_vfprintf_r+0x11ba>
80008038:	10 36       	cp.w	r6,r8
8000803a:	c6 74       	brge	80008108 <_vfprintf_r+0x127c>
8000803c:	fa cc f9 44 	sub	r12,sp,-1724
80008040:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008044:	c8 08       	rjmp	80008144 <_vfprintf_r+0x12b8>
80008046:	ee ca ff ff 	sub	r10,r7,-1
8000804a:	10 37       	cp.w	r7,r8
8000804c:	c7 f4       	brge	8000814a <_vfprintf_r+0x12be>
8000804e:	fa cb f9 44 	sub	r11,sp,-1724
80008052:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008056:	c7 68       	rjmp	80008142 <_vfprintf_r+0x12b6>
80008058:	ed b5 00 06 	bld	r5,0x6
8000805c:	c4 a1       	brne	800080f0 <_vfprintf_r+0x1264>
8000805e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008062:	40 3c       	lddsp	r12,sp[0xc]
80008064:	58 0c       	cp.w	r12,0
80008066:	c1 d0       	breq	800080a0 <_vfprintf_r+0x1214>
80008068:	10 36       	cp.w	r6,r8
8000806a:	c0 64       	brge	80008076 <_vfprintf_r+0x11ea>
8000806c:	fa cb f9 44 	sub	r11,sp,-1724
80008070:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008074:	c1 f8       	rjmp	800080b2 <_vfprintf_r+0x1226>
80008076:	fa c8 f9 50 	sub	r8,sp,-1712
8000807a:	1a d8       	st.w	--sp,r8
8000807c:	fa c8 fa b8 	sub	r8,sp,-1352
80008080:	1a d8       	st.w	--sp,r8
80008082:	fa c8 fb b4 	sub	r8,sp,-1100
80008086:	1a d8       	st.w	--sp,r8
80008088:	fa c8 f9 40 	sub	r8,sp,-1728
8000808c:	fa c9 ff b4 	sub	r9,sp,-76
80008090:	04 9a       	mov	r10,r2
80008092:	0c 9b       	mov	r11,r6
80008094:	08 9c       	mov	r12,r4
80008096:	fe b0 f5 63 	rcall	80006b5c <get_arg>
8000809a:	2f dd       	sub	sp,-12
8000809c:	98 18       	ld.sh	r8,r12[0x2]
8000809e:	c2 68       	rjmp	800080ea <_vfprintf_r+0x125e>
800080a0:	ee ca ff ff 	sub	r10,r7,-1
800080a4:	10 37       	cp.w	r7,r8
800080a6:	c0 94       	brge	800080b8 <_vfprintf_r+0x122c>
800080a8:	fa c9 f9 44 	sub	r9,sp,-1724
800080ac:	14 97       	mov	r7,r10
800080ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800080b6:	c1 a8       	rjmp	800080ea <_vfprintf_r+0x125e>
800080b8:	41 09       	lddsp	r9,sp[0x40]
800080ba:	59 f8       	cp.w	r8,31
800080bc:	e0 89 00 13 	brgt	800080e2 <_vfprintf_r+0x1256>
800080c0:	f2 cb ff fc 	sub	r11,r9,-4
800080c4:	51 0b       	stdsp	sp[0x40],r11
800080c6:	72 09       	ld.w	r9,r9[0x0]
800080c8:	fa c6 f9 44 	sub	r6,sp,-1724
800080cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800080d0:	2f f8       	sub	r8,-1
800080d2:	f7 49 fd 88 	st.w	r11[-632],r9
800080d6:	fb 48 06 b4 	st.w	sp[1716],r8
800080da:	14 97       	mov	r7,r10
800080dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800080e0:	c0 58       	rjmp	800080ea <_vfprintf_r+0x125e>
800080e2:	92 18       	ld.sh	r8,r9[0x2]
800080e4:	14 97       	mov	r7,r10
800080e6:	2f c9       	sub	r9,-4
800080e8:	51 09       	stdsp	sp[0x40],r9
800080ea:	5c 78       	castu.h	r8
800080ec:	50 18       	stdsp	sp[0x4],r8
800080ee:	c4 68       	rjmp	8000817a <_vfprintf_r+0x12ee>
800080f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080f4:	40 3c       	lddsp	r12,sp[0xc]
800080f6:	58 0c       	cp.w	r12,0
800080f8:	c1 d0       	breq	80008132 <_vfprintf_r+0x12a6>
800080fa:	10 36       	cp.w	r6,r8
800080fc:	c0 64       	brge	80008108 <_vfprintf_r+0x127c>
800080fe:	fa cb f9 44 	sub	r11,sp,-1724
80008102:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008106:	c1 f8       	rjmp	80008144 <_vfprintf_r+0x12b8>
80008108:	fa c8 f9 50 	sub	r8,sp,-1712
8000810c:	1a d8       	st.w	--sp,r8
8000810e:	fa c8 fa b8 	sub	r8,sp,-1352
80008112:	0c 9b       	mov	r11,r6
80008114:	1a d8       	st.w	--sp,r8
80008116:	fa c8 fb b4 	sub	r8,sp,-1100
8000811a:	04 9a       	mov	r10,r2
8000811c:	1a d8       	st.w	--sp,r8
8000811e:	08 9c       	mov	r12,r4
80008120:	fa c8 f9 40 	sub	r8,sp,-1728
80008124:	fa c9 ff b4 	sub	r9,sp,-76
80008128:	fe b0 f5 1a 	rcall	80006b5c <get_arg>
8000812c:	2f dd       	sub	sp,-12
8000812e:	78 0b       	ld.w	r11,r12[0x0]
80008130:	c2 48       	rjmp	80008178 <_vfprintf_r+0x12ec>
80008132:	ee ca ff ff 	sub	r10,r7,-1
80008136:	10 37       	cp.w	r7,r8
80008138:	c0 94       	brge	8000814a <_vfprintf_r+0x12be>
8000813a:	fa c9 f9 44 	sub	r9,sp,-1724
8000813e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008142:	14 97       	mov	r7,r10
80008144:	ec fb fd 88 	ld.w	r11,r6[-632]
80008148:	c1 88       	rjmp	80008178 <_vfprintf_r+0x12ec>
8000814a:	41 09       	lddsp	r9,sp[0x40]
8000814c:	59 f8       	cp.w	r8,31
8000814e:	e0 89 00 11 	brgt	80008170 <_vfprintf_r+0x12e4>
80008152:	f2 cb ff fc 	sub	r11,r9,-4
80008156:	51 0b       	stdsp	sp[0x40],r11
80008158:	fa c6 f9 44 	sub	r6,sp,-1724
8000815c:	72 0b       	ld.w	r11,r9[0x0]
8000815e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008162:	f3 4b fd 88 	st.w	r9[-632],r11
80008166:	2f f8       	sub	r8,-1
80008168:	14 97       	mov	r7,r10
8000816a:	fb 48 06 b4 	st.w	sp[1716],r8
8000816e:	c0 58       	rjmp	80008178 <_vfprintf_r+0x12ec>
80008170:	72 0b       	ld.w	r11,r9[0x0]
80008172:	14 97       	mov	r7,r10
80008174:	2f c9       	sub	r9,-4
80008176:	51 09       	stdsp	sp[0x40],r9
80008178:	50 1b       	stdsp	sp[0x4],r11
8000817a:	30 0e       	mov	lr,0
8000817c:	30 18       	mov	r8,1
8000817e:	50 0e       	stdsp	sp[0x0],lr
80008180:	c2 29       	rjmp	800083c4 <_vfprintf_r+0x1538>
80008182:	50 a7       	stdsp	sp[0x28],r7
80008184:	50 80       	stdsp	sp[0x20],r0
80008186:	0c 97       	mov	r7,r6
80008188:	04 94       	mov	r4,r2
8000818a:	06 96       	mov	r6,r3
8000818c:	02 92       	mov	r2,r1
8000818e:	fe cc af 5a 	sub	r12,pc,-20646
80008192:	40 93       	lddsp	r3,sp[0x24]
80008194:	10 90       	mov	r0,r8
80008196:	40 41       	lddsp	r1,sp[0x10]
80008198:	50 dc       	stdsp	sp[0x34],r12
8000819a:	ed b5 00 05 	bld	r5,0x5
8000819e:	c5 51       	brne	80008248 <_vfprintf_r+0x13bc>
800081a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081a4:	40 3b       	lddsp	r11,sp[0xc]
800081a6:	58 0b       	cp.w	r11,0
800081a8:	c2 20       	breq	800081ec <_vfprintf_r+0x1360>
800081aa:	10 36       	cp.w	r6,r8
800081ac:	c0 a4       	brge	800081c0 <_vfprintf_r+0x1334>
800081ae:	fa ca f9 44 	sub	r10,sp,-1724
800081b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800081b6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800081ba:	fa e9 00 00 	st.d	sp[0],r8
800081be:	cf 28       	rjmp	800083a2 <_vfprintf_r+0x1516>
800081c0:	fa c8 f9 50 	sub	r8,sp,-1712
800081c4:	1a d8       	st.w	--sp,r8
800081c6:	fa c8 fa b8 	sub	r8,sp,-1352
800081ca:	04 9a       	mov	r10,r2
800081cc:	1a d8       	st.w	--sp,r8
800081ce:	0c 9b       	mov	r11,r6
800081d0:	fa c8 fb b4 	sub	r8,sp,-1100
800081d4:	08 9c       	mov	r12,r4
800081d6:	1a d8       	st.w	--sp,r8
800081d8:	fa c8 f9 40 	sub	r8,sp,-1728
800081dc:	fa c9 ff b4 	sub	r9,sp,-76
800081e0:	fe b0 f4 be 	rcall	80006b5c <get_arg>
800081e4:	2f dd       	sub	sp,-12
800081e6:	f8 ea 00 00 	ld.d	r10,r12[0]
800081ea:	c0 c8       	rjmp	80008202 <_vfprintf_r+0x1376>
800081ec:	ee ca ff ff 	sub	r10,r7,-1
800081f0:	10 37       	cp.w	r7,r8
800081f2:	c0 b4       	brge	80008208 <_vfprintf_r+0x137c>
800081f4:	fa c9 f9 44 	sub	r9,sp,-1724
800081f8:	14 97       	mov	r7,r10
800081fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081fe:	ec ea fd 88 	ld.d	r10,r6[-632]
80008202:	fa eb 00 00 	st.d	sp[0],r10
80008206:	cc e8       	rjmp	800083a2 <_vfprintf_r+0x1516>
80008208:	41 09       	lddsp	r9,sp[0x40]
8000820a:	59 f8       	cp.w	r8,31
8000820c:	e0 89 00 16 	brgt	80008238 <_vfprintf_r+0x13ac>
80008210:	f2 e6 00 00 	ld.d	r6,r9[0]
80008214:	f2 cb ff f8 	sub	r11,r9,-8
80008218:	fa e7 00 00 	st.d	sp[0],r6
8000821c:	51 0b       	stdsp	sp[0x40],r11
8000821e:	fa c6 f9 44 	sub	r6,sp,-1724
80008222:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008226:	fa e6 00 00 	ld.d	r6,sp[0]
8000822a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000822e:	2f f8       	sub	r8,-1
80008230:	14 97       	mov	r7,r10
80008232:	fb 48 06 b4 	st.w	sp[1716],r8
80008236:	cb 68       	rjmp	800083a2 <_vfprintf_r+0x1516>
80008238:	f2 e6 00 00 	ld.d	r6,r9[0]
8000823c:	2f 89       	sub	r9,-8
8000823e:	fa e7 00 00 	st.d	sp[0],r6
80008242:	51 09       	stdsp	sp[0x40],r9
80008244:	14 97       	mov	r7,r10
80008246:	ca e8       	rjmp	800083a2 <_vfprintf_r+0x1516>
80008248:	ed b5 00 04 	bld	r5,0x4
8000824c:	c1 71       	brne	8000827a <_vfprintf_r+0x13ee>
8000824e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008252:	40 3e       	lddsp	lr,sp[0xc]
80008254:	58 0e       	cp.w	lr,0
80008256:	c0 80       	breq	80008266 <_vfprintf_r+0x13da>
80008258:	10 36       	cp.w	r6,r8
8000825a:	c6 94       	brge	8000832c <_vfprintf_r+0x14a0>
8000825c:	fa cc f9 44 	sub	r12,sp,-1724
80008260:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008264:	c8 28       	rjmp	80008368 <_vfprintf_r+0x14dc>
80008266:	ee ca ff ff 	sub	r10,r7,-1
8000826a:	10 37       	cp.w	r7,r8
8000826c:	e0 84 00 81 	brge	8000836e <_vfprintf_r+0x14e2>
80008270:	fa cb f9 44 	sub	r11,sp,-1724
80008274:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008278:	c7 78       	rjmp	80008366 <_vfprintf_r+0x14da>
8000827a:	ed b5 00 06 	bld	r5,0x6
8000827e:	c4 b1       	brne	80008314 <_vfprintf_r+0x1488>
80008280:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008284:	40 3c       	lddsp	r12,sp[0xc]
80008286:	58 0c       	cp.w	r12,0
80008288:	c1 d0       	breq	800082c2 <_vfprintf_r+0x1436>
8000828a:	10 36       	cp.w	r6,r8
8000828c:	c0 64       	brge	80008298 <_vfprintf_r+0x140c>
8000828e:	fa cb f9 44 	sub	r11,sp,-1724
80008292:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008296:	c1 f8       	rjmp	800082d4 <_vfprintf_r+0x1448>
80008298:	fa c8 f9 50 	sub	r8,sp,-1712
8000829c:	1a d8       	st.w	--sp,r8
8000829e:	fa c8 fa b8 	sub	r8,sp,-1352
800082a2:	1a d8       	st.w	--sp,r8
800082a4:	fa c8 fb b4 	sub	r8,sp,-1100
800082a8:	1a d8       	st.w	--sp,r8
800082aa:	fa c8 f9 40 	sub	r8,sp,-1728
800082ae:	fa c9 ff b4 	sub	r9,sp,-76
800082b2:	04 9a       	mov	r10,r2
800082b4:	0c 9b       	mov	r11,r6
800082b6:	08 9c       	mov	r12,r4
800082b8:	fe b0 f4 52 	rcall	80006b5c <get_arg>
800082bc:	2f dd       	sub	sp,-12
800082be:	98 18       	ld.sh	r8,r12[0x2]
800082c0:	c2 78       	rjmp	8000830e <_vfprintf_r+0x1482>
800082c2:	ee ca ff ff 	sub	r10,r7,-1
800082c6:	10 37       	cp.w	r7,r8
800082c8:	c0 a4       	brge	800082dc <_vfprintf_r+0x1450>
800082ca:	fa c9 f9 44 	sub	r9,sp,-1724
800082ce:	14 97       	mov	r7,r10
800082d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082d4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800082d8:	c1 b8       	rjmp	8000830e <_vfprintf_r+0x1482>
800082da:	d7 03       	nop
800082dc:	41 09       	lddsp	r9,sp[0x40]
800082de:	59 f8       	cp.w	r8,31
800082e0:	e0 89 00 13 	brgt	80008306 <_vfprintf_r+0x147a>
800082e4:	f2 cb ff fc 	sub	r11,r9,-4
800082e8:	51 0b       	stdsp	sp[0x40],r11
800082ea:	72 09       	ld.w	r9,r9[0x0]
800082ec:	fa c6 f9 44 	sub	r6,sp,-1724
800082f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800082f4:	2f f8       	sub	r8,-1
800082f6:	f7 49 fd 88 	st.w	r11[-632],r9
800082fa:	fb 48 06 b4 	st.w	sp[1716],r8
800082fe:	14 97       	mov	r7,r10
80008300:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008304:	c0 58       	rjmp	8000830e <_vfprintf_r+0x1482>
80008306:	92 18       	ld.sh	r8,r9[0x2]
80008308:	14 97       	mov	r7,r10
8000830a:	2f c9       	sub	r9,-4
8000830c:	51 09       	stdsp	sp[0x40],r9
8000830e:	5c 78       	castu.h	r8
80008310:	50 18       	stdsp	sp[0x4],r8
80008312:	c4 68       	rjmp	8000839e <_vfprintf_r+0x1512>
80008314:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008318:	40 3c       	lddsp	r12,sp[0xc]
8000831a:	58 0c       	cp.w	r12,0
8000831c:	c1 d0       	breq	80008356 <_vfprintf_r+0x14ca>
8000831e:	10 36       	cp.w	r6,r8
80008320:	c0 64       	brge	8000832c <_vfprintf_r+0x14a0>
80008322:	fa cb f9 44 	sub	r11,sp,-1724
80008326:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000832a:	c1 f8       	rjmp	80008368 <_vfprintf_r+0x14dc>
8000832c:	fa c8 f9 50 	sub	r8,sp,-1712
80008330:	1a d8       	st.w	--sp,r8
80008332:	fa c8 fa b8 	sub	r8,sp,-1352
80008336:	0c 9b       	mov	r11,r6
80008338:	1a d8       	st.w	--sp,r8
8000833a:	fa c8 fb b4 	sub	r8,sp,-1100
8000833e:	04 9a       	mov	r10,r2
80008340:	1a d8       	st.w	--sp,r8
80008342:	08 9c       	mov	r12,r4
80008344:	fa c8 f9 40 	sub	r8,sp,-1728
80008348:	fa c9 ff b4 	sub	r9,sp,-76
8000834c:	fe b0 f4 08 	rcall	80006b5c <get_arg>
80008350:	2f dd       	sub	sp,-12
80008352:	78 0b       	ld.w	r11,r12[0x0]
80008354:	c2 48       	rjmp	8000839c <_vfprintf_r+0x1510>
80008356:	ee ca ff ff 	sub	r10,r7,-1
8000835a:	10 37       	cp.w	r7,r8
8000835c:	c0 94       	brge	8000836e <_vfprintf_r+0x14e2>
8000835e:	fa c9 f9 44 	sub	r9,sp,-1724
80008362:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008366:	14 97       	mov	r7,r10
80008368:	ec fb fd 88 	ld.w	r11,r6[-632]
8000836c:	c1 88       	rjmp	8000839c <_vfprintf_r+0x1510>
8000836e:	41 09       	lddsp	r9,sp[0x40]
80008370:	59 f8       	cp.w	r8,31
80008372:	e0 89 00 11 	brgt	80008394 <_vfprintf_r+0x1508>
80008376:	f2 cb ff fc 	sub	r11,r9,-4
8000837a:	51 0b       	stdsp	sp[0x40],r11
8000837c:	fa c6 f9 44 	sub	r6,sp,-1724
80008380:	72 0b       	ld.w	r11,r9[0x0]
80008382:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008386:	f3 4b fd 88 	st.w	r9[-632],r11
8000838a:	2f f8       	sub	r8,-1
8000838c:	14 97       	mov	r7,r10
8000838e:	fb 48 06 b4 	st.w	sp[1716],r8
80008392:	c0 58       	rjmp	8000839c <_vfprintf_r+0x1510>
80008394:	72 0b       	ld.w	r11,r9[0x0]
80008396:	14 97       	mov	r7,r10
80008398:	2f c9       	sub	r9,-4
8000839a:	51 09       	stdsp	sp[0x40],r9
8000839c:	50 1b       	stdsp	sp[0x4],r11
8000839e:	30 0e       	mov	lr,0
800083a0:	50 0e       	stdsp	sp[0x0],lr
800083a2:	40 08       	lddsp	r8,sp[0x0]
800083a4:	40 1c       	lddsp	r12,sp[0x4]
800083a6:	18 48       	or	r8,r12
800083a8:	5f 19       	srne	r9
800083aa:	0a 98       	mov	r8,r5
800083ac:	eb e9 00 09 	and	r9,r5,r9
800083b0:	a1 b8       	sbr	r8,0x1
800083b2:	58 09       	cp.w	r9,0
800083b4:	c0 70       	breq	800083c2 <_vfprintf_r+0x1536>
800083b6:	10 95       	mov	r5,r8
800083b8:	fb 60 06 b9 	st.b	sp[1721],r0
800083bc:	33 08       	mov	r8,48
800083be:	fb 68 06 b8 	st.b	sp[1720],r8
800083c2:	30 28       	mov	r8,2
800083c4:	30 09       	mov	r9,0
800083c6:	fb 69 06 bb 	st.b	sp[1723],r9
800083ca:	0a 99       	mov	r9,r5
800083cc:	a7 d9       	cbr	r9,0x7
800083ce:	40 2b       	lddsp	r11,sp[0x8]
800083d0:	40 16       	lddsp	r6,sp[0x4]
800083d2:	58 0b       	cp.w	r11,0
800083d4:	5f 1a       	srne	r10
800083d6:	f2 05 17 40 	movge	r5,r9
800083da:	fa c2 f9 78 	sub	r2,sp,-1672
800083de:	40 09       	lddsp	r9,sp[0x0]
800083e0:	0c 49       	or	r9,r6
800083e2:	5f 19       	srne	r9
800083e4:	f5 e9 10 09 	or	r9,r10,r9
800083e8:	c5 c0       	breq	800084a0 <_vfprintf_r+0x1614>
800083ea:	30 19       	mov	r9,1
800083ec:	f2 08 18 00 	cp.b	r8,r9
800083f0:	c0 60       	breq	800083fc <_vfprintf_r+0x1570>
800083f2:	30 29       	mov	r9,2
800083f4:	f2 08 18 00 	cp.b	r8,r9
800083f8:	c0 41       	brne	80008400 <_vfprintf_r+0x1574>
800083fa:	c3 c8       	rjmp	80008472 <_vfprintf_r+0x15e6>
800083fc:	04 96       	mov	r6,r2
800083fe:	c3 08       	rjmp	8000845e <_vfprintf_r+0x15d2>
80008400:	04 96       	mov	r6,r2
80008402:	fa e8 00 00 	ld.d	r8,sp[0]
80008406:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000840a:	2d 0a       	sub	r10,-48
8000840c:	0c fa       	st.b	--r6,r10
8000840e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008412:	f2 0c 16 03 	lsr	r12,r9,0x3
80008416:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000841a:	18 99       	mov	r9,r12
8000841c:	16 98       	mov	r8,r11
8000841e:	58 08       	cp.w	r8,0
80008420:	5c 29       	cpc	r9
80008422:	cf 21       	brne	80008406 <_vfprintf_r+0x157a>
80008424:	fa e9 00 00 	st.d	sp[0],r8
80008428:	ed b5 00 00 	bld	r5,0x0
8000842c:	c4 51       	brne	800084b6 <_vfprintf_r+0x162a>
8000842e:	33 09       	mov	r9,48
80008430:	f2 0a 18 00 	cp.b	r10,r9
80008434:	c4 10       	breq	800084b6 <_vfprintf_r+0x162a>
80008436:	0c f9       	st.b	--r6,r9
80008438:	c3 f8       	rjmp	800084b6 <_vfprintf_r+0x162a>
8000843a:	fa ea 00 00 	ld.d	r10,sp[0]
8000843e:	30 a8       	mov	r8,10
80008440:	30 09       	mov	r9,0
80008442:	e0 a0 1a 0d 	rcall	8000b85c <__avr32_umod64>
80008446:	30 a8       	mov	r8,10
80008448:	2d 0a       	sub	r10,-48
8000844a:	30 09       	mov	r9,0
8000844c:	ac 8a       	st.b	r6[0x0],r10
8000844e:	fa ea 00 00 	ld.d	r10,sp[0]
80008452:	e0 a0 18 d3 	rcall	8000b5f8 <__avr32_udiv64>
80008456:	16 99       	mov	r9,r11
80008458:	14 98       	mov	r8,r10
8000845a:	fa e9 00 00 	st.d	sp[0],r8
8000845e:	20 16       	sub	r6,1
80008460:	fa ea 00 00 	ld.d	r10,sp[0]
80008464:	58 9a       	cp.w	r10,9
80008466:	5c 2b       	cpc	r11
80008468:	fe 9b ff e9 	brhi	8000843a <_vfprintf_r+0x15ae>
8000846c:	1b f8       	ld.ub	r8,sp[0x7]
8000846e:	2d 08       	sub	r8,-48
80008470:	c2 08       	rjmp	800084b0 <_vfprintf_r+0x1624>
80008472:	04 96       	mov	r6,r2
80008474:	fa e8 00 00 	ld.d	r8,sp[0]
80008478:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000847c:	40 de       	lddsp	lr,sp[0x34]
8000847e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008482:	0c fa       	st.b	--r6,r10
80008484:	f2 0b 16 04 	lsr	r11,r9,0x4
80008488:	f0 0a 16 04 	lsr	r10,r8,0x4
8000848c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008490:	16 99       	mov	r9,r11
80008492:	14 98       	mov	r8,r10
80008494:	58 08       	cp.w	r8,0
80008496:	5c 29       	cpc	r9
80008498:	cf 01       	brne	80008478 <_vfprintf_r+0x15ec>
8000849a:	fa e9 00 00 	st.d	sp[0],r8
8000849e:	c0 c8       	rjmp	800084b6 <_vfprintf_r+0x162a>
800084a0:	58 08       	cp.w	r8,0
800084a2:	c0 91       	brne	800084b4 <_vfprintf_r+0x1628>
800084a4:	ed b5 00 00 	bld	r5,0x0
800084a8:	c0 61       	brne	800084b4 <_vfprintf_r+0x1628>
800084aa:	fa c6 f9 79 	sub	r6,sp,-1671
800084ae:	33 08       	mov	r8,48
800084b0:	ac 88       	st.b	r6[0x0],r8
800084b2:	c0 28       	rjmp	800084b6 <_vfprintf_r+0x162a>
800084b4:	04 96       	mov	r6,r2
800084b6:	0c 12       	sub	r2,r6
800084b8:	c1 c8       	rjmp	800084f0 <_vfprintf_r+0x1664>
800084ba:	50 a7       	stdsp	sp[0x28],r7
800084bc:	50 80       	stdsp	sp[0x20],r0
800084be:	40 93       	lddsp	r3,sp[0x24]
800084c0:	0c 97       	mov	r7,r6
800084c2:	10 90       	mov	r0,r8
800084c4:	04 94       	mov	r4,r2
800084c6:	40 41       	lddsp	r1,sp[0x10]
800084c8:	58 08       	cp.w	r8,0
800084ca:	e0 80 04 4f 	breq	80008d68 <_vfprintf_r+0x1edc>
800084ce:	fb 68 06 60 	st.b	sp[1632],r8
800084d2:	30 0c       	mov	r12,0
800084d4:	30 08       	mov	r8,0
800084d6:	30 12       	mov	r2,1
800084d8:	fb 68 06 bb 	st.b	sp[1723],r8
800084dc:	50 2c       	stdsp	sp[0x8],r12
800084de:	fa c6 f9 a0 	sub	r6,sp,-1632
800084e2:	c0 78       	rjmp	800084f0 <_vfprintf_r+0x1664>
800084e4:	30 0b       	mov	r11,0
800084e6:	50 2b       	stdsp	sp[0x8],r11
800084e8:	c0 48       	rjmp	800084f0 <_vfprintf_r+0x1664>
800084ea:	40 22       	lddsp	r2,sp[0x8]
800084ec:	30 0a       	mov	r10,0
800084ee:	50 2a       	stdsp	sp[0x8],r10
800084f0:	40 29       	lddsp	r9,sp[0x8]
800084f2:	e4 09 0c 49 	max	r9,r2,r9
800084f6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800084fa:	50 39       	stdsp	sp[0xc],r9
800084fc:	0a 9e       	mov	lr,r5
800084fe:	30 09       	mov	r9,0
80008500:	e2 1e 00 02 	andl	lr,0x2,COH
80008504:	f2 08 18 00 	cp.b	r8,r9
80008508:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000850c:	f7 b8 01 ff 	subne	r8,-1
80008510:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008514:	0a 9b       	mov	r11,r5
80008516:	58 0e       	cp.w	lr,0
80008518:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000851c:	f7 bc 01 fe 	subne	r12,-2
80008520:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008524:	e2 1b 00 84 	andl	r11,0x84,COH
80008528:	50 fe       	stdsp	sp[0x3c],lr
8000852a:	50 9b       	stdsp	sp[0x24],r11
8000852c:	c4 71       	brne	800085ba <_vfprintf_r+0x172e>
8000852e:	40 8a       	lddsp	r10,sp[0x20]
80008530:	40 39       	lddsp	r9,sp[0xc]
80008532:	12 1a       	sub	r10,r9
80008534:	50 4a       	stdsp	sp[0x10],r10
80008536:	58 0a       	cp.w	r10,0
80008538:	e0 89 00 20 	brgt	80008578 <_vfprintf_r+0x16ec>
8000853c:	c3 f8       	rjmp	800085ba <_vfprintf_r+0x172e>
8000853e:	2f 09       	sub	r9,-16
80008540:	2f f8       	sub	r8,-1
80008542:	fe ce b2 f6 	sub	lr,pc,-19722
80008546:	31 0c       	mov	r12,16
80008548:	fb 49 06 90 	st.w	sp[1680],r9
8000854c:	87 0e       	st.w	r3[0x0],lr
8000854e:	87 1c       	st.w	r3[0x4],r12
80008550:	fb 48 06 8c 	st.w	sp[1676],r8
80008554:	58 78       	cp.w	r8,7
80008556:	e0 89 00 04 	brgt	8000855e <_vfprintf_r+0x16d2>
8000855a:	2f 83       	sub	r3,-8
8000855c:	c0 b8       	rjmp	80008572 <_vfprintf_r+0x16e6>
8000855e:	fa ca f9 78 	sub	r10,sp,-1672
80008562:	02 9b       	mov	r11,r1
80008564:	08 9c       	mov	r12,r4
80008566:	fe b0 f4 85 	rcall	80006e70 <__sprint_r>
8000856a:	e0 81 04 10 	brne	80008d8a <_vfprintf_r+0x1efe>
8000856e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008572:	40 4b       	lddsp	r11,sp[0x10]
80008574:	21 0b       	sub	r11,16
80008576:	50 4b       	stdsp	sp[0x10],r11
80008578:	fa f9 06 90 	ld.w	r9,sp[1680]
8000857c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008580:	fe ca b3 34 	sub	r10,pc,-19660
80008584:	40 4e       	lddsp	lr,sp[0x10]
80008586:	59 0e       	cp.w	lr,16
80008588:	fe 99 ff db 	brgt	8000853e <_vfprintf_r+0x16b2>
8000858c:	1c 09       	add	r9,lr
8000858e:	2f f8       	sub	r8,-1
80008590:	87 0a       	st.w	r3[0x0],r10
80008592:	fb 49 06 90 	st.w	sp[1680],r9
80008596:	87 1e       	st.w	r3[0x4],lr
80008598:	fb 48 06 8c 	st.w	sp[1676],r8
8000859c:	58 78       	cp.w	r8,7
8000859e:	e0 89 00 04 	brgt	800085a6 <_vfprintf_r+0x171a>
800085a2:	2f 83       	sub	r3,-8
800085a4:	c0 b8       	rjmp	800085ba <_vfprintf_r+0x172e>
800085a6:	fa ca f9 78 	sub	r10,sp,-1672
800085aa:	02 9b       	mov	r11,r1
800085ac:	08 9c       	mov	r12,r4
800085ae:	fe b0 f4 61 	rcall	80006e70 <__sprint_r>
800085b2:	e0 81 03 ec 	brne	80008d8a <_vfprintf_r+0x1efe>
800085b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800085ba:	30 09       	mov	r9,0
800085bc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800085c0:	f2 08 18 00 	cp.b	r8,r9
800085c4:	c1 f0       	breq	80008602 <_vfprintf_r+0x1776>
800085c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800085ca:	fa c9 f9 45 	sub	r9,sp,-1723
800085ce:	2f f8       	sub	r8,-1
800085d0:	87 09       	st.w	r3[0x0],r9
800085d2:	fb 48 06 90 	st.w	sp[1680],r8
800085d6:	30 19       	mov	r9,1
800085d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085dc:	87 19       	st.w	r3[0x4],r9
800085de:	2f f8       	sub	r8,-1
800085e0:	fb 48 06 8c 	st.w	sp[1676],r8
800085e4:	58 78       	cp.w	r8,7
800085e6:	e0 89 00 04 	brgt	800085ee <_vfprintf_r+0x1762>
800085ea:	2f 83       	sub	r3,-8
800085ec:	c0 b8       	rjmp	80008602 <_vfprintf_r+0x1776>
800085ee:	fa ca f9 78 	sub	r10,sp,-1672
800085f2:	02 9b       	mov	r11,r1
800085f4:	08 9c       	mov	r12,r4
800085f6:	fe b0 f4 3d 	rcall	80006e70 <__sprint_r>
800085fa:	e0 81 03 c8 	brne	80008d8a <_vfprintf_r+0x1efe>
800085fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008602:	40 fc       	lddsp	r12,sp[0x3c]
80008604:	58 0c       	cp.w	r12,0
80008606:	c1 f0       	breq	80008644 <_vfprintf_r+0x17b8>
80008608:	fa f8 06 90 	ld.w	r8,sp[1680]
8000860c:	fa c9 f9 48 	sub	r9,sp,-1720
80008610:	2f e8       	sub	r8,-2
80008612:	87 09       	st.w	r3[0x0],r9
80008614:	fb 48 06 90 	st.w	sp[1680],r8
80008618:	30 29       	mov	r9,2
8000861a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000861e:	87 19       	st.w	r3[0x4],r9
80008620:	2f f8       	sub	r8,-1
80008622:	fb 48 06 8c 	st.w	sp[1676],r8
80008626:	58 78       	cp.w	r8,7
80008628:	e0 89 00 04 	brgt	80008630 <_vfprintf_r+0x17a4>
8000862c:	2f 83       	sub	r3,-8
8000862e:	c0 b8       	rjmp	80008644 <_vfprintf_r+0x17b8>
80008630:	fa ca f9 78 	sub	r10,sp,-1672
80008634:	02 9b       	mov	r11,r1
80008636:	08 9c       	mov	r12,r4
80008638:	fe b0 f4 1c 	rcall	80006e70 <__sprint_r>
8000863c:	e0 81 03 a7 	brne	80008d8a <_vfprintf_r+0x1efe>
80008640:	fa c3 f9 e0 	sub	r3,sp,-1568
80008644:	40 9b       	lddsp	r11,sp[0x24]
80008646:	e0 4b 00 80 	cp.w	r11,128
8000864a:	c4 71       	brne	800086d8 <_vfprintf_r+0x184c>
8000864c:	40 8a       	lddsp	r10,sp[0x20]
8000864e:	40 39       	lddsp	r9,sp[0xc]
80008650:	12 1a       	sub	r10,r9
80008652:	50 4a       	stdsp	sp[0x10],r10
80008654:	58 0a       	cp.w	r10,0
80008656:	e0 89 00 20 	brgt	80008696 <_vfprintf_r+0x180a>
8000865a:	c3 f8       	rjmp	800086d8 <_vfprintf_r+0x184c>
8000865c:	2f 09       	sub	r9,-16
8000865e:	2f f8       	sub	r8,-1
80008660:	fe ce b4 04 	sub	lr,pc,-19452
80008664:	31 0c       	mov	r12,16
80008666:	fb 49 06 90 	st.w	sp[1680],r9
8000866a:	87 0e       	st.w	r3[0x0],lr
8000866c:	87 1c       	st.w	r3[0x4],r12
8000866e:	fb 48 06 8c 	st.w	sp[1676],r8
80008672:	58 78       	cp.w	r8,7
80008674:	e0 89 00 04 	brgt	8000867c <_vfprintf_r+0x17f0>
80008678:	2f 83       	sub	r3,-8
8000867a:	c0 b8       	rjmp	80008690 <_vfprintf_r+0x1804>
8000867c:	fa ca f9 78 	sub	r10,sp,-1672
80008680:	02 9b       	mov	r11,r1
80008682:	08 9c       	mov	r12,r4
80008684:	fe b0 f3 f6 	rcall	80006e70 <__sprint_r>
80008688:	e0 81 03 81 	brne	80008d8a <_vfprintf_r+0x1efe>
8000868c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008690:	40 4b       	lddsp	r11,sp[0x10]
80008692:	21 0b       	sub	r11,16
80008694:	50 4b       	stdsp	sp[0x10],r11
80008696:	fa f9 06 90 	ld.w	r9,sp[1680]
8000869a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000869e:	fe ca b4 42 	sub	r10,pc,-19390
800086a2:	40 4e       	lddsp	lr,sp[0x10]
800086a4:	59 0e       	cp.w	lr,16
800086a6:	fe 99 ff db 	brgt	8000865c <_vfprintf_r+0x17d0>
800086aa:	1c 09       	add	r9,lr
800086ac:	2f f8       	sub	r8,-1
800086ae:	87 0a       	st.w	r3[0x0],r10
800086b0:	fb 49 06 90 	st.w	sp[1680],r9
800086b4:	87 1e       	st.w	r3[0x4],lr
800086b6:	fb 48 06 8c 	st.w	sp[1676],r8
800086ba:	58 78       	cp.w	r8,7
800086bc:	e0 89 00 04 	brgt	800086c4 <_vfprintf_r+0x1838>
800086c0:	2f 83       	sub	r3,-8
800086c2:	c0 b8       	rjmp	800086d8 <_vfprintf_r+0x184c>
800086c4:	fa ca f9 78 	sub	r10,sp,-1672
800086c8:	02 9b       	mov	r11,r1
800086ca:	08 9c       	mov	r12,r4
800086cc:	fe b0 f3 d2 	rcall	80006e70 <__sprint_r>
800086d0:	e0 81 03 5d 	brne	80008d8a <_vfprintf_r+0x1efe>
800086d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800086d8:	40 2c       	lddsp	r12,sp[0x8]
800086da:	04 1c       	sub	r12,r2
800086dc:	50 2c       	stdsp	sp[0x8],r12
800086de:	58 0c       	cp.w	r12,0
800086e0:	e0 89 00 20 	brgt	80008720 <_vfprintf_r+0x1894>
800086e4:	c3 f8       	rjmp	80008762 <_vfprintf_r+0x18d6>
800086e6:	2f 09       	sub	r9,-16
800086e8:	2f f8       	sub	r8,-1
800086ea:	fe cb b4 8e 	sub	r11,pc,-19314
800086ee:	31 0a       	mov	r10,16
800086f0:	fb 49 06 90 	st.w	sp[1680],r9
800086f4:	87 0b       	st.w	r3[0x0],r11
800086f6:	87 1a       	st.w	r3[0x4],r10
800086f8:	fb 48 06 8c 	st.w	sp[1676],r8
800086fc:	58 78       	cp.w	r8,7
800086fe:	e0 89 00 04 	brgt	80008706 <_vfprintf_r+0x187a>
80008702:	2f 83       	sub	r3,-8
80008704:	c0 b8       	rjmp	8000871a <_vfprintf_r+0x188e>
80008706:	fa ca f9 78 	sub	r10,sp,-1672
8000870a:	02 9b       	mov	r11,r1
8000870c:	08 9c       	mov	r12,r4
8000870e:	fe b0 f3 b1 	rcall	80006e70 <__sprint_r>
80008712:	e0 81 03 3c 	brne	80008d8a <_vfprintf_r+0x1efe>
80008716:	fa c3 f9 e0 	sub	r3,sp,-1568
8000871a:	40 29       	lddsp	r9,sp[0x8]
8000871c:	21 09       	sub	r9,16
8000871e:	50 29       	stdsp	sp[0x8],r9
80008720:	fa f9 06 90 	ld.w	r9,sp[1680]
80008724:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008728:	fe ca b4 cc 	sub	r10,pc,-19252
8000872c:	40 2e       	lddsp	lr,sp[0x8]
8000872e:	59 0e       	cp.w	lr,16
80008730:	fe 99 ff db 	brgt	800086e6 <_vfprintf_r+0x185a>
80008734:	1c 09       	add	r9,lr
80008736:	2f f8       	sub	r8,-1
80008738:	87 0a       	st.w	r3[0x0],r10
8000873a:	fb 49 06 90 	st.w	sp[1680],r9
8000873e:	87 1e       	st.w	r3[0x4],lr
80008740:	fb 48 06 8c 	st.w	sp[1676],r8
80008744:	58 78       	cp.w	r8,7
80008746:	e0 89 00 04 	brgt	8000874e <_vfprintf_r+0x18c2>
8000874a:	2f 83       	sub	r3,-8
8000874c:	c0 b8       	rjmp	80008762 <_vfprintf_r+0x18d6>
8000874e:	fa ca f9 78 	sub	r10,sp,-1672
80008752:	02 9b       	mov	r11,r1
80008754:	08 9c       	mov	r12,r4
80008756:	fe b0 f3 8d 	rcall	80006e70 <__sprint_r>
8000875a:	e0 81 03 18 	brne	80008d8a <_vfprintf_r+0x1efe>
8000875e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008762:	ed b5 00 08 	bld	r5,0x8
80008766:	c0 b0       	breq	8000877c <_vfprintf_r+0x18f0>
80008768:	fa f8 06 90 	ld.w	r8,sp[1680]
8000876c:	87 12       	st.w	r3[0x4],r2
8000876e:	87 06       	st.w	r3[0x0],r6
80008770:	f0 02 00 02 	add	r2,r8,r2
80008774:	fb 42 06 90 	st.w	sp[1680],r2
80008778:	e0 8f 01 d4 	bral	80008b20 <_vfprintf_r+0x1c94>
8000877c:	e0 40 00 65 	cp.w	r0,101
80008780:	e0 8a 01 d6 	brle	80008b2c <_vfprintf_r+0x1ca0>
80008784:	30 08       	mov	r8,0
80008786:	30 09       	mov	r9,0
80008788:	40 5b       	lddsp	r11,sp[0x14]
8000878a:	40 7a       	lddsp	r10,sp[0x1c]
8000878c:	e0 a0 15 2f 	rcall	8000b1ea <__avr32_f64_cmp_eq>
80008790:	c7 90       	breq	80008882 <_vfprintf_r+0x19f6>
80008792:	fa f8 06 90 	ld.w	r8,sp[1680]
80008796:	fe c9 b5 4e 	sub	r9,pc,-19122
8000879a:	2f f8       	sub	r8,-1
8000879c:	87 09       	st.w	r3[0x0],r9
8000879e:	fb 48 06 90 	st.w	sp[1680],r8
800087a2:	30 19       	mov	r9,1
800087a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087a8:	87 19       	st.w	r3[0x4],r9
800087aa:	2f f8       	sub	r8,-1
800087ac:	fb 48 06 8c 	st.w	sp[1676],r8
800087b0:	58 78       	cp.w	r8,7
800087b2:	e0 89 00 05 	brgt	800087bc <_vfprintf_r+0x1930>
800087b6:	2f 83       	sub	r3,-8
800087b8:	c0 c8       	rjmp	800087d0 <_vfprintf_r+0x1944>
800087ba:	d7 03       	nop
800087bc:	fa ca f9 78 	sub	r10,sp,-1672
800087c0:	02 9b       	mov	r11,r1
800087c2:	08 9c       	mov	r12,r4
800087c4:	fe b0 f3 56 	rcall	80006e70 <__sprint_r>
800087c8:	e0 81 02 e1 	brne	80008d8a <_vfprintf_r+0x1efe>
800087cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800087d0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800087d4:	40 6c       	lddsp	r12,sp[0x18]
800087d6:	18 38       	cp.w	r8,r12
800087d8:	c0 55       	brlt	800087e2 <_vfprintf_r+0x1956>
800087da:	ed b5 00 00 	bld	r5,0x0
800087de:	e0 81 02 6b 	brne	80008cb4 <_vfprintf_r+0x1e28>
800087e2:	fa f8 06 90 	ld.w	r8,sp[1680]
800087e6:	2f f8       	sub	r8,-1
800087e8:	40 cb       	lddsp	r11,sp[0x30]
800087ea:	fb 48 06 90 	st.w	sp[1680],r8
800087ee:	30 19       	mov	r9,1
800087f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087f4:	87 0b       	st.w	r3[0x0],r11
800087f6:	2f f8       	sub	r8,-1
800087f8:	87 19       	st.w	r3[0x4],r9
800087fa:	fb 48 06 8c 	st.w	sp[1676],r8
800087fe:	58 78       	cp.w	r8,7
80008800:	e0 89 00 04 	brgt	80008808 <_vfprintf_r+0x197c>
80008804:	2f 83       	sub	r3,-8
80008806:	c0 b8       	rjmp	8000881c <_vfprintf_r+0x1990>
80008808:	fa ca f9 78 	sub	r10,sp,-1672
8000880c:	02 9b       	mov	r11,r1
8000880e:	08 9c       	mov	r12,r4
80008810:	fe b0 f3 30 	rcall	80006e70 <__sprint_r>
80008814:	e0 81 02 bb 	brne	80008d8a <_vfprintf_r+0x1efe>
80008818:	fa c3 f9 e0 	sub	r3,sp,-1568
8000881c:	40 66       	lddsp	r6,sp[0x18]
8000881e:	20 16       	sub	r6,1
80008820:	58 06       	cp.w	r6,0
80008822:	e0 89 00 1d 	brgt	8000885c <_vfprintf_r+0x19d0>
80008826:	e0 8f 02 47 	bral	80008cb4 <_vfprintf_r+0x1e28>
8000882a:	2f 09       	sub	r9,-16
8000882c:	2f f8       	sub	r8,-1
8000882e:	fb 49 06 90 	st.w	sp[1680],r9
80008832:	87 02       	st.w	r3[0x0],r2
80008834:	87 10       	st.w	r3[0x4],r0
80008836:	fb 48 06 8c 	st.w	sp[1676],r8
8000883a:	58 78       	cp.w	r8,7
8000883c:	e0 89 00 04 	brgt	80008844 <_vfprintf_r+0x19b8>
80008840:	2f 83       	sub	r3,-8
80008842:	c0 b8       	rjmp	80008858 <_vfprintf_r+0x19cc>
80008844:	fa ca f9 78 	sub	r10,sp,-1672
80008848:	02 9b       	mov	r11,r1
8000884a:	08 9c       	mov	r12,r4
8000884c:	fe b0 f3 12 	rcall	80006e70 <__sprint_r>
80008850:	e0 81 02 9d 	brne	80008d8a <_vfprintf_r+0x1efe>
80008854:	fa c3 f9 e0 	sub	r3,sp,-1568
80008858:	21 06       	sub	r6,16
8000885a:	c0 48       	rjmp	80008862 <_vfprintf_r+0x19d6>
8000885c:	fe c2 b6 00 	sub	r2,pc,-18944
80008860:	31 00       	mov	r0,16
80008862:	fa f9 06 90 	ld.w	r9,sp[1680]
80008866:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000886a:	fe ca b6 0e 	sub	r10,pc,-18930
8000886e:	59 06       	cp.w	r6,16
80008870:	fe 99 ff dd 	brgt	8000882a <_vfprintf_r+0x199e>
80008874:	0c 09       	add	r9,r6
80008876:	87 0a       	st.w	r3[0x0],r10
80008878:	fb 49 06 90 	st.w	sp[1680],r9
8000887c:	2f f8       	sub	r8,-1
8000887e:	87 16       	st.w	r3[0x4],r6
80008880:	c5 39       	rjmp	80008b26 <_vfprintf_r+0x1c9a>
80008882:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008886:	58 0a       	cp.w	r10,0
80008888:	e0 89 00 92 	brgt	800089ac <_vfprintf_r+0x1b20>
8000888c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008890:	fe c9 b6 48 	sub	r9,pc,-18872
80008894:	2f f8       	sub	r8,-1
80008896:	87 09       	st.w	r3[0x0],r9
80008898:	fb 48 06 90 	st.w	sp[1680],r8
8000889c:	30 19       	mov	r9,1
8000889e:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088a2:	87 19       	st.w	r3[0x4],r9
800088a4:	2f f8       	sub	r8,-1
800088a6:	fb 48 06 8c 	st.w	sp[1676],r8
800088aa:	58 78       	cp.w	r8,7
800088ac:	e0 89 00 04 	brgt	800088b4 <_vfprintf_r+0x1a28>
800088b0:	2f 83       	sub	r3,-8
800088b2:	c0 b8       	rjmp	800088c8 <_vfprintf_r+0x1a3c>
800088b4:	fa ca f9 78 	sub	r10,sp,-1672
800088b8:	02 9b       	mov	r11,r1
800088ba:	08 9c       	mov	r12,r4
800088bc:	fe b0 f2 da 	rcall	80006e70 <__sprint_r>
800088c0:	e0 81 02 65 	brne	80008d8a <_vfprintf_r+0x1efe>
800088c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800088c8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088cc:	58 08       	cp.w	r8,0
800088ce:	c0 81       	brne	800088de <_vfprintf_r+0x1a52>
800088d0:	40 6a       	lddsp	r10,sp[0x18]
800088d2:	58 0a       	cp.w	r10,0
800088d4:	c0 51       	brne	800088de <_vfprintf_r+0x1a52>
800088d6:	ed b5 00 00 	bld	r5,0x0
800088da:	e0 81 01 ed 	brne	80008cb4 <_vfprintf_r+0x1e28>
800088de:	40 c9       	lddsp	r9,sp[0x30]
800088e0:	fa f8 06 90 	ld.w	r8,sp[1680]
800088e4:	2f f8       	sub	r8,-1
800088e6:	87 09       	st.w	r3[0x0],r9
800088e8:	fb 48 06 90 	st.w	sp[1680],r8
800088ec:	30 19       	mov	r9,1
800088ee:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088f2:	87 19       	st.w	r3[0x4],r9
800088f4:	2f f8       	sub	r8,-1
800088f6:	fb 48 06 8c 	st.w	sp[1676],r8
800088fa:	58 78       	cp.w	r8,7
800088fc:	e0 89 00 04 	brgt	80008904 <_vfprintf_r+0x1a78>
80008900:	2f 83       	sub	r3,-8
80008902:	c0 b8       	rjmp	80008918 <_vfprintf_r+0x1a8c>
80008904:	fa ca f9 78 	sub	r10,sp,-1672
80008908:	02 9b       	mov	r11,r1
8000890a:	08 9c       	mov	r12,r4
8000890c:	fe b0 f2 b2 	rcall	80006e70 <__sprint_r>
80008910:	e0 81 02 3d 	brne	80008d8a <_vfprintf_r+0x1efe>
80008914:	fa c3 f9 e0 	sub	r3,sp,-1568
80008918:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000891c:	5c 32       	neg	r2
8000891e:	58 02       	cp.w	r2,0
80008920:	e0 89 00 1d 	brgt	8000895a <_vfprintf_r+0x1ace>
80008924:	c3 d8       	rjmp	8000899e <_vfprintf_r+0x1b12>
80008926:	2f 09       	sub	r9,-16
80008928:	2f f8       	sub	r8,-1
8000892a:	31 0e       	mov	lr,16
8000892c:	fb 49 06 90 	st.w	sp[1680],r9
80008930:	87 00       	st.w	r3[0x0],r0
80008932:	87 1e       	st.w	r3[0x4],lr
80008934:	fb 48 06 8c 	st.w	sp[1676],r8
80008938:	58 78       	cp.w	r8,7
8000893a:	e0 89 00 04 	brgt	80008942 <_vfprintf_r+0x1ab6>
8000893e:	2f 83       	sub	r3,-8
80008940:	c0 b8       	rjmp	80008956 <_vfprintf_r+0x1aca>
80008942:	fa ca f9 78 	sub	r10,sp,-1672
80008946:	02 9b       	mov	r11,r1
80008948:	08 9c       	mov	r12,r4
8000894a:	fe b0 f2 93 	rcall	80006e70 <__sprint_r>
8000894e:	e0 81 02 1e 	brne	80008d8a <_vfprintf_r+0x1efe>
80008952:	fa c3 f9 e0 	sub	r3,sp,-1568
80008956:	21 02       	sub	r2,16
80008958:	c0 38       	rjmp	8000895e <_vfprintf_r+0x1ad2>
8000895a:	fe c0 b6 fe 	sub	r0,pc,-18690
8000895e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008962:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008966:	fe ca b7 0a 	sub	r10,pc,-18678
8000896a:	59 02       	cp.w	r2,16
8000896c:	fe 99 ff dd 	brgt	80008926 <_vfprintf_r+0x1a9a>
80008970:	04 09       	add	r9,r2
80008972:	2f f8       	sub	r8,-1
80008974:	87 0a       	st.w	r3[0x0],r10
80008976:	fb 49 06 90 	st.w	sp[1680],r9
8000897a:	87 12       	st.w	r3[0x4],r2
8000897c:	fb 48 06 8c 	st.w	sp[1676],r8
80008980:	58 78       	cp.w	r8,7
80008982:	e0 89 00 04 	brgt	8000898a <_vfprintf_r+0x1afe>
80008986:	2f 83       	sub	r3,-8
80008988:	c0 b8       	rjmp	8000899e <_vfprintf_r+0x1b12>
8000898a:	fa ca f9 78 	sub	r10,sp,-1672
8000898e:	02 9b       	mov	r11,r1
80008990:	08 9c       	mov	r12,r4
80008992:	fe b0 f2 6f 	rcall	80006e70 <__sprint_r>
80008996:	e0 81 01 fa 	brne	80008d8a <_vfprintf_r+0x1efe>
8000899a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000899e:	40 6c       	lddsp	r12,sp[0x18]
800089a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800089a4:	87 06       	st.w	r3[0x0],r6
800089a6:	87 1c       	st.w	r3[0x4],r12
800089a8:	18 08       	add	r8,r12
800089aa:	cb 98       	rjmp	80008b1c <_vfprintf_r+0x1c90>
800089ac:	fa f9 06 90 	ld.w	r9,sp[1680]
800089b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089b4:	40 6b       	lddsp	r11,sp[0x18]
800089b6:	16 3a       	cp.w	r10,r11
800089b8:	c6 f5       	brlt	80008a96 <_vfprintf_r+0x1c0a>
800089ba:	16 09       	add	r9,r11
800089bc:	2f f8       	sub	r8,-1
800089be:	87 06       	st.w	r3[0x0],r6
800089c0:	fb 49 06 90 	st.w	sp[1680],r9
800089c4:	87 1b       	st.w	r3[0x4],r11
800089c6:	fb 48 06 8c 	st.w	sp[1676],r8
800089ca:	58 78       	cp.w	r8,7
800089cc:	e0 89 00 04 	brgt	800089d4 <_vfprintf_r+0x1b48>
800089d0:	2f 83       	sub	r3,-8
800089d2:	c0 b8       	rjmp	800089e8 <_vfprintf_r+0x1b5c>
800089d4:	fa ca f9 78 	sub	r10,sp,-1672
800089d8:	02 9b       	mov	r11,r1
800089da:	08 9c       	mov	r12,r4
800089dc:	fe b0 f2 4a 	rcall	80006e70 <__sprint_r>
800089e0:	e0 81 01 d5 	brne	80008d8a <_vfprintf_r+0x1efe>
800089e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800089e8:	fa f6 06 ac 	ld.w	r6,sp[1708]
800089ec:	40 6a       	lddsp	r10,sp[0x18]
800089ee:	14 16       	sub	r6,r10
800089f0:	58 06       	cp.w	r6,0
800089f2:	e0 89 00 1c 	brgt	80008a2a <_vfprintf_r+0x1b9e>
800089f6:	c3 d8       	rjmp	80008a70 <_vfprintf_r+0x1be4>
800089f8:	2f 09       	sub	r9,-16
800089fa:	2f f8       	sub	r8,-1
800089fc:	fb 49 06 90 	st.w	sp[1680],r9
80008a00:	87 02       	st.w	r3[0x0],r2
80008a02:	87 10       	st.w	r3[0x4],r0
80008a04:	fb 48 06 8c 	st.w	sp[1676],r8
80008a08:	58 78       	cp.w	r8,7
80008a0a:	e0 89 00 04 	brgt	80008a12 <_vfprintf_r+0x1b86>
80008a0e:	2f 83       	sub	r3,-8
80008a10:	c0 b8       	rjmp	80008a26 <_vfprintf_r+0x1b9a>
80008a12:	fa ca f9 78 	sub	r10,sp,-1672
80008a16:	02 9b       	mov	r11,r1
80008a18:	08 9c       	mov	r12,r4
80008a1a:	fe b0 f2 2b 	rcall	80006e70 <__sprint_r>
80008a1e:	e0 81 01 b6 	brne	80008d8a <_vfprintf_r+0x1efe>
80008a22:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a26:	21 06       	sub	r6,16
80008a28:	c0 48       	rjmp	80008a30 <_vfprintf_r+0x1ba4>
80008a2a:	fe c2 b7 ce 	sub	r2,pc,-18482
80008a2e:	31 00       	mov	r0,16
80008a30:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a38:	fe ca b7 dc 	sub	r10,pc,-18468
80008a3c:	59 06       	cp.w	r6,16
80008a3e:	fe 99 ff dd 	brgt	800089f8 <_vfprintf_r+0x1b6c>
80008a42:	0c 09       	add	r9,r6
80008a44:	2f f8       	sub	r8,-1
80008a46:	87 0a       	st.w	r3[0x0],r10
80008a48:	fb 49 06 90 	st.w	sp[1680],r9
80008a4c:	87 16       	st.w	r3[0x4],r6
80008a4e:	fb 48 06 8c 	st.w	sp[1676],r8
80008a52:	58 78       	cp.w	r8,7
80008a54:	e0 89 00 04 	brgt	80008a5c <_vfprintf_r+0x1bd0>
80008a58:	2f 83       	sub	r3,-8
80008a5a:	c0 b8       	rjmp	80008a70 <_vfprintf_r+0x1be4>
80008a5c:	fa ca f9 78 	sub	r10,sp,-1672
80008a60:	02 9b       	mov	r11,r1
80008a62:	08 9c       	mov	r12,r4
80008a64:	fe b0 f2 06 	rcall	80006e70 <__sprint_r>
80008a68:	e0 81 01 91 	brne	80008d8a <_vfprintf_r+0x1efe>
80008a6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a70:	ed b5 00 00 	bld	r5,0x0
80008a74:	e0 81 01 20 	brne	80008cb4 <_vfprintf_r+0x1e28>
80008a78:	40 c9       	lddsp	r9,sp[0x30]
80008a7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a7e:	2f f8       	sub	r8,-1
80008a80:	87 09       	st.w	r3[0x0],r9
80008a82:	fb 48 06 90 	st.w	sp[1680],r8
80008a86:	30 19       	mov	r9,1
80008a88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a8c:	87 19       	st.w	r3[0x4],r9
80008a8e:	2f f8       	sub	r8,-1
80008a90:	fb 48 06 8c 	st.w	sp[1676],r8
80008a94:	c0 29       	rjmp	80008c98 <_vfprintf_r+0x1e0c>
80008a96:	14 09       	add	r9,r10
80008a98:	2f f8       	sub	r8,-1
80008a9a:	fb 49 06 90 	st.w	sp[1680],r9
80008a9e:	87 06       	st.w	r3[0x0],r6
80008aa0:	87 1a       	st.w	r3[0x4],r10
80008aa2:	fb 48 06 8c 	st.w	sp[1676],r8
80008aa6:	58 78       	cp.w	r8,7
80008aa8:	e0 89 00 04 	brgt	80008ab0 <_vfprintf_r+0x1c24>
80008aac:	2f 83       	sub	r3,-8
80008aae:	c0 b8       	rjmp	80008ac4 <_vfprintf_r+0x1c38>
80008ab0:	fa ca f9 78 	sub	r10,sp,-1672
80008ab4:	02 9b       	mov	r11,r1
80008ab6:	08 9c       	mov	r12,r4
80008ab8:	fe b0 f1 dc 	rcall	80006e70 <__sprint_r>
80008abc:	e0 81 01 67 	brne	80008d8a <_vfprintf_r+0x1efe>
80008ac0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ac4:	40 c8       	lddsp	r8,sp[0x30]
80008ac6:	87 08       	st.w	r3[0x0],r8
80008ac8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008acc:	2f f8       	sub	r8,-1
80008ace:	30 19       	mov	r9,1
80008ad0:	fb 48 06 90 	st.w	sp[1680],r8
80008ad4:	87 19       	st.w	r3[0x4],r9
80008ad6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ada:	2f f8       	sub	r8,-1
80008adc:	fb 48 06 8c 	st.w	sp[1676],r8
80008ae0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008ae4:	58 78       	cp.w	r8,7
80008ae6:	e0 89 00 04 	brgt	80008aee <_vfprintf_r+0x1c62>
80008aea:	2f 83       	sub	r3,-8
80008aec:	c0 b8       	rjmp	80008b02 <_vfprintf_r+0x1c76>
80008aee:	fa ca f9 78 	sub	r10,sp,-1672
80008af2:	02 9b       	mov	r11,r1
80008af4:	08 9c       	mov	r12,r4
80008af6:	fe b0 f1 bd 	rcall	80006e70 <__sprint_r>
80008afa:	e0 81 01 48 	brne	80008d8a <_vfprintf_r+0x1efe>
80008afe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b02:	04 06       	add	r6,r2
80008b04:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b08:	87 06       	st.w	r3[0x0],r6
80008b0a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b0e:	40 66       	lddsp	r6,sp[0x18]
80008b10:	40 6e       	lddsp	lr,sp[0x18]
80008b12:	10 16       	sub	r6,r8
80008b14:	f2 08 01 08 	sub	r8,r9,r8
80008b18:	87 16       	st.w	r3[0x4],r6
80008b1a:	1c 08       	add	r8,lr
80008b1c:	fb 48 06 90 	st.w	sp[1680],r8
80008b20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b24:	2f f8       	sub	r8,-1
80008b26:	fb 48 06 8c 	st.w	sp[1676],r8
80008b2a:	cb 78       	rjmp	80008c98 <_vfprintf_r+0x1e0c>
80008b2c:	40 6c       	lddsp	r12,sp[0x18]
80008b2e:	58 1c       	cp.w	r12,1
80008b30:	e0 89 00 06 	brgt	80008b3c <_vfprintf_r+0x1cb0>
80008b34:	ed b5 00 00 	bld	r5,0x0
80008b38:	e0 81 00 85 	brne	80008c42 <_vfprintf_r+0x1db6>
80008b3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b40:	2f f8       	sub	r8,-1
80008b42:	30 19       	mov	r9,1
80008b44:	fb 48 06 90 	st.w	sp[1680],r8
80008b48:	87 06       	st.w	r3[0x0],r6
80008b4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b4e:	87 19       	st.w	r3[0x4],r9
80008b50:	2f f8       	sub	r8,-1
80008b52:	fb 48 06 8c 	st.w	sp[1676],r8
80008b56:	58 78       	cp.w	r8,7
80008b58:	e0 89 00 04 	brgt	80008b60 <_vfprintf_r+0x1cd4>
80008b5c:	2f 83       	sub	r3,-8
80008b5e:	c0 b8       	rjmp	80008b74 <_vfprintf_r+0x1ce8>
80008b60:	fa ca f9 78 	sub	r10,sp,-1672
80008b64:	02 9b       	mov	r11,r1
80008b66:	08 9c       	mov	r12,r4
80008b68:	fe b0 f1 84 	rcall	80006e70 <__sprint_r>
80008b6c:	e0 81 01 0f 	brne	80008d8a <_vfprintf_r+0x1efe>
80008b70:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b74:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b78:	2f f8       	sub	r8,-1
80008b7a:	40 cb       	lddsp	r11,sp[0x30]
80008b7c:	fb 48 06 90 	st.w	sp[1680],r8
80008b80:	30 19       	mov	r9,1
80008b82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b86:	87 0b       	st.w	r3[0x0],r11
80008b88:	2f f8       	sub	r8,-1
80008b8a:	87 19       	st.w	r3[0x4],r9
80008b8c:	fb 48 06 8c 	st.w	sp[1676],r8
80008b90:	58 78       	cp.w	r8,7
80008b92:	e0 89 00 05 	brgt	80008b9c <_vfprintf_r+0x1d10>
80008b96:	2f 83       	sub	r3,-8
80008b98:	c0 c8       	rjmp	80008bb0 <_vfprintf_r+0x1d24>
80008b9a:	d7 03       	nop
80008b9c:	fa ca f9 78 	sub	r10,sp,-1672
80008ba0:	02 9b       	mov	r11,r1
80008ba2:	08 9c       	mov	r12,r4
80008ba4:	fe b0 f1 66 	rcall	80006e70 <__sprint_r>
80008ba8:	e0 81 00 f1 	brne	80008d8a <_vfprintf_r+0x1efe>
80008bac:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bb0:	30 08       	mov	r8,0
80008bb2:	30 09       	mov	r9,0
80008bb4:	40 5b       	lddsp	r11,sp[0x14]
80008bb6:	40 7a       	lddsp	r10,sp[0x1c]
80008bb8:	e0 a0 13 19 	rcall	8000b1ea <__avr32_f64_cmp_eq>
80008bbc:	40 68       	lddsp	r8,sp[0x18]
80008bbe:	20 18       	sub	r8,1
80008bc0:	58 0c       	cp.w	r12,0
80008bc2:	c0 d1       	brne	80008bdc <_vfprintf_r+0x1d50>
80008bc4:	2f f6       	sub	r6,-1
80008bc6:	87 18       	st.w	r3[0x4],r8
80008bc8:	87 06       	st.w	r3[0x0],r6
80008bca:	fa f6 06 90 	ld.w	r6,sp[1680]
80008bce:	10 06       	add	r6,r8
80008bd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bd4:	fb 46 06 90 	st.w	sp[1680],r6
80008bd8:	2f f8       	sub	r8,-1
80008bda:	c3 18       	rjmp	80008c3c <_vfprintf_r+0x1db0>
80008bdc:	10 96       	mov	r6,r8
80008bde:	58 08       	cp.w	r8,0
80008be0:	e0 89 00 1c 	brgt	80008c18 <_vfprintf_r+0x1d8c>
80008be4:	c4 b8       	rjmp	80008c7a <_vfprintf_r+0x1dee>
80008be6:	2f 09       	sub	r9,-16
80008be8:	2f f8       	sub	r8,-1
80008bea:	fb 49 06 90 	st.w	sp[1680],r9
80008bee:	87 02       	st.w	r3[0x0],r2
80008bf0:	87 10       	st.w	r3[0x4],r0
80008bf2:	fb 48 06 8c 	st.w	sp[1676],r8
80008bf6:	58 78       	cp.w	r8,7
80008bf8:	e0 89 00 04 	brgt	80008c00 <_vfprintf_r+0x1d74>
80008bfc:	2f 83       	sub	r3,-8
80008bfe:	c0 b8       	rjmp	80008c14 <_vfprintf_r+0x1d88>
80008c00:	fa ca f9 78 	sub	r10,sp,-1672
80008c04:	02 9b       	mov	r11,r1
80008c06:	08 9c       	mov	r12,r4
80008c08:	fe b0 f1 34 	rcall	80006e70 <__sprint_r>
80008c0c:	e0 81 00 bf 	brne	80008d8a <_vfprintf_r+0x1efe>
80008c10:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c14:	21 06       	sub	r6,16
80008c16:	c0 48       	rjmp	80008c1e <_vfprintf_r+0x1d92>
80008c18:	fe c2 b9 bc 	sub	r2,pc,-17988
80008c1c:	31 00       	mov	r0,16
80008c1e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c26:	fe ca b9 ca 	sub	r10,pc,-17974
80008c2a:	59 06       	cp.w	r6,16
80008c2c:	fe 99 ff dd 	brgt	80008be6 <_vfprintf_r+0x1d5a>
80008c30:	0c 09       	add	r9,r6
80008c32:	87 0a       	st.w	r3[0x0],r10
80008c34:	fb 49 06 90 	st.w	sp[1680],r9
80008c38:	2f f8       	sub	r8,-1
80008c3a:	87 16       	st.w	r3[0x4],r6
80008c3c:	fb 48 06 8c 	st.w	sp[1676],r8
80008c40:	c0 e8       	rjmp	80008c5c <_vfprintf_r+0x1dd0>
80008c42:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c46:	2f f8       	sub	r8,-1
80008c48:	30 19       	mov	r9,1
80008c4a:	fb 48 06 90 	st.w	sp[1680],r8
80008c4e:	87 06       	st.w	r3[0x0],r6
80008c50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c54:	87 19       	st.w	r3[0x4],r9
80008c56:	2f f8       	sub	r8,-1
80008c58:	fb 48 06 8c 	st.w	sp[1676],r8
80008c5c:	58 78       	cp.w	r8,7
80008c5e:	e0 89 00 04 	brgt	80008c66 <_vfprintf_r+0x1dda>
80008c62:	2f 83       	sub	r3,-8
80008c64:	c0 b8       	rjmp	80008c7a <_vfprintf_r+0x1dee>
80008c66:	fa ca f9 78 	sub	r10,sp,-1672
80008c6a:	02 9b       	mov	r11,r1
80008c6c:	08 9c       	mov	r12,r4
80008c6e:	fe b0 f1 01 	rcall	80006e70 <__sprint_r>
80008c72:	e0 81 00 8c 	brne	80008d8a <_vfprintf_r+0x1efe>
80008c76:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c7a:	40 ea       	lddsp	r10,sp[0x38]
80008c7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c80:	14 08       	add	r8,r10
80008c82:	fa c9 f9 64 	sub	r9,sp,-1692
80008c86:	fb 48 06 90 	st.w	sp[1680],r8
80008c8a:	87 1a       	st.w	r3[0x4],r10
80008c8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c90:	87 09       	st.w	r3[0x0],r9
80008c92:	2f f8       	sub	r8,-1
80008c94:	fb 48 06 8c 	st.w	sp[1676],r8
80008c98:	58 78       	cp.w	r8,7
80008c9a:	e0 89 00 04 	brgt	80008ca2 <_vfprintf_r+0x1e16>
80008c9e:	2f 83       	sub	r3,-8
80008ca0:	c0 a8       	rjmp	80008cb4 <_vfprintf_r+0x1e28>
80008ca2:	fa ca f9 78 	sub	r10,sp,-1672
80008ca6:	02 9b       	mov	r11,r1
80008ca8:	08 9c       	mov	r12,r4
80008caa:	fe b0 f0 e3 	rcall	80006e70 <__sprint_r>
80008cae:	c6 e1       	brne	80008d8a <_vfprintf_r+0x1efe>
80008cb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cb4:	e2 15 00 04 	andl	r5,0x4,COH
80008cb8:	c3 f0       	breq	80008d36 <_vfprintf_r+0x1eaa>
80008cba:	40 86       	lddsp	r6,sp[0x20]
80008cbc:	40 39       	lddsp	r9,sp[0xc]
80008cbe:	12 16       	sub	r6,r9
80008cc0:	58 06       	cp.w	r6,0
80008cc2:	e0 89 00 1a 	brgt	80008cf6 <_vfprintf_r+0x1e6a>
80008cc6:	c3 88       	rjmp	80008d36 <_vfprintf_r+0x1eaa>
80008cc8:	2f 09       	sub	r9,-16
80008cca:	2f f8       	sub	r8,-1
80008ccc:	fb 49 06 90 	st.w	sp[1680],r9
80008cd0:	87 05       	st.w	r3[0x0],r5
80008cd2:	87 12       	st.w	r3[0x4],r2
80008cd4:	fb 48 06 8c 	st.w	sp[1676],r8
80008cd8:	58 78       	cp.w	r8,7
80008cda:	e0 89 00 04 	brgt	80008ce2 <_vfprintf_r+0x1e56>
80008cde:	2f 83       	sub	r3,-8
80008ce0:	c0 98       	rjmp	80008cf2 <_vfprintf_r+0x1e66>
80008ce2:	00 9a       	mov	r10,r0
80008ce4:	02 9b       	mov	r11,r1
80008ce6:	08 9c       	mov	r12,r4
80008ce8:	fe b0 f0 c4 	rcall	80006e70 <__sprint_r>
80008cec:	c4 f1       	brne	80008d8a <_vfprintf_r+0x1efe>
80008cee:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cf2:	21 06       	sub	r6,16
80008cf4:	c0 68       	rjmp	80008d00 <_vfprintf_r+0x1e74>
80008cf6:	fe c5 ba aa 	sub	r5,pc,-17750
80008cfa:	31 02       	mov	r2,16
80008cfc:	fa c0 f9 78 	sub	r0,sp,-1672
80008d00:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d08:	fe ca ba bc 	sub	r10,pc,-17732
80008d0c:	59 06       	cp.w	r6,16
80008d0e:	fe 99 ff dd 	brgt	80008cc8 <_vfprintf_r+0x1e3c>
80008d12:	0c 09       	add	r9,r6
80008d14:	2f f8       	sub	r8,-1
80008d16:	87 0a       	st.w	r3[0x0],r10
80008d18:	87 16       	st.w	r3[0x4],r6
80008d1a:	fb 49 06 90 	st.w	sp[1680],r9
80008d1e:	fb 48 06 8c 	st.w	sp[1676],r8
80008d22:	58 78       	cp.w	r8,7
80008d24:	e0 8a 00 09 	brle	80008d36 <_vfprintf_r+0x1eaa>
80008d28:	fa ca f9 78 	sub	r10,sp,-1672
80008d2c:	02 9b       	mov	r11,r1
80008d2e:	08 9c       	mov	r12,r4
80008d30:	fe b0 f0 a0 	rcall	80006e70 <__sprint_r>
80008d34:	c2 b1       	brne	80008d8a <_vfprintf_r+0x1efe>
80008d36:	40 bc       	lddsp	r12,sp[0x2c]
80008d38:	40 36       	lddsp	r6,sp[0xc]
80008d3a:	40 8e       	lddsp	lr,sp[0x20]
80008d3c:	ec 0e 0c 48 	max	r8,r6,lr
80008d40:	10 0c       	add	r12,r8
80008d42:	50 bc       	stdsp	sp[0x2c],r12
80008d44:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d48:	58 08       	cp.w	r8,0
80008d4a:	c0 80       	breq	80008d5a <_vfprintf_r+0x1ece>
80008d4c:	fa ca f9 78 	sub	r10,sp,-1672
80008d50:	02 9b       	mov	r11,r1
80008d52:	08 9c       	mov	r12,r4
80008d54:	fe b0 f0 8e 	rcall	80006e70 <__sprint_r>
80008d58:	c1 91       	brne	80008d8a <_vfprintf_r+0x1efe>
80008d5a:	30 0b       	mov	r11,0
80008d5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d60:	fb 4b 06 8c 	st.w	sp[1676],r11
80008d64:	fe 9f f1 22 	bral	80006fa8 <_vfprintf_r+0x11c>
80008d68:	08 95       	mov	r5,r4
80008d6a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d6e:	58 08       	cp.w	r8,0
80008d70:	c0 80       	breq	80008d80 <_vfprintf_r+0x1ef4>
80008d72:	08 9c       	mov	r12,r4
80008d74:	fa ca f9 78 	sub	r10,sp,-1672
80008d78:	02 9b       	mov	r11,r1
80008d7a:	fe b0 f0 7b 	rcall	80006e70 <__sprint_r>
80008d7e:	c0 61       	brne	80008d8a <_vfprintf_r+0x1efe>
80008d80:	30 08       	mov	r8,0
80008d82:	fb 48 06 8c 	st.w	sp[1676],r8
80008d86:	c0 28       	rjmp	80008d8a <_vfprintf_r+0x1efe>
80008d88:	40 41       	lddsp	r1,sp[0x10]
80008d8a:	82 68       	ld.sh	r8,r1[0xc]
80008d8c:	ed b8 00 06 	bld	r8,0x6
80008d90:	c0 31       	brne	80008d96 <_vfprintf_r+0x1f0a>
80008d92:	3f fa       	mov	r10,-1
80008d94:	50 ba       	stdsp	sp[0x2c],r10
80008d96:	40 bc       	lddsp	r12,sp[0x2c]
80008d98:	fe 3d f9 44 	sub	sp,-1724
80008d9c:	d8 32       	popm	r0-r7,pc
80008d9e:	d7 03       	nop

80008da0 <__swsetup_r>:
80008da0:	d4 21       	pushm	r4-r7,lr
80008da2:	e0 68 0a 38 	mov	r8,2616
80008da6:	18 96       	mov	r6,r12
80008da8:	16 97       	mov	r7,r11
80008daa:	70 0c       	ld.w	r12,r8[0x0]
80008dac:	58 0c       	cp.w	r12,0
80008dae:	c0 60       	breq	80008dba <__swsetup_r+0x1a>
80008db0:	78 68       	ld.w	r8,r12[0x18]
80008db2:	58 08       	cp.w	r8,0
80008db4:	c0 31       	brne	80008dba <__swsetup_r+0x1a>
80008db6:	e0 a0 07 bf 	rcall	80009d34 <__sinit>
80008dba:	fe c8 ba 3e 	sub	r8,pc,-17858
80008dbe:	10 37       	cp.w	r7,r8
80008dc0:	c0 61       	brne	80008dcc <__swsetup_r+0x2c>
80008dc2:	e0 68 0a 38 	mov	r8,2616
80008dc6:	70 08       	ld.w	r8,r8[0x0]
80008dc8:	70 07       	ld.w	r7,r8[0x0]
80008dca:	c1 28       	rjmp	80008dee <__swsetup_r+0x4e>
80008dcc:	fe c8 ba 30 	sub	r8,pc,-17872
80008dd0:	10 37       	cp.w	r7,r8
80008dd2:	c0 61       	brne	80008dde <__swsetup_r+0x3e>
80008dd4:	e0 68 0a 38 	mov	r8,2616
80008dd8:	70 08       	ld.w	r8,r8[0x0]
80008dda:	70 17       	ld.w	r7,r8[0x4]
80008ddc:	c0 98       	rjmp	80008dee <__swsetup_r+0x4e>
80008dde:	fe c8 ba 22 	sub	r8,pc,-17886
80008de2:	10 37       	cp.w	r7,r8
80008de4:	c0 51       	brne	80008dee <__swsetup_r+0x4e>
80008de6:	e0 68 0a 38 	mov	r8,2616
80008dea:	70 08       	ld.w	r8,r8[0x0]
80008dec:	70 27       	ld.w	r7,r8[0x8]
80008dee:	8e 68       	ld.sh	r8,r7[0xc]
80008df0:	ed b8 00 03 	bld	r8,0x3
80008df4:	c1 e0       	breq	80008e30 <__swsetup_r+0x90>
80008df6:	ed b8 00 04 	bld	r8,0x4
80008dfa:	c3 e1       	brne	80008e76 <__swsetup_r+0xd6>
80008dfc:	ed b8 00 02 	bld	r8,0x2
80008e00:	c1 51       	brne	80008e2a <__swsetup_r+0x8a>
80008e02:	6e db       	ld.w	r11,r7[0x34]
80008e04:	58 0b       	cp.w	r11,0
80008e06:	c0 a0       	breq	80008e1a <__swsetup_r+0x7a>
80008e08:	ee c8 ff bc 	sub	r8,r7,-68
80008e0c:	10 3b       	cp.w	r11,r8
80008e0e:	c0 40       	breq	80008e16 <__swsetup_r+0x76>
80008e10:	0c 9c       	mov	r12,r6
80008e12:	e0 a0 08 2b 	rcall	80009e68 <_free_r>
80008e16:	30 08       	mov	r8,0
80008e18:	8f d8       	st.w	r7[0x34],r8
80008e1a:	8e 68       	ld.sh	r8,r7[0xc]
80008e1c:	e0 18 ff db 	andl	r8,0xffdb
80008e20:	ae 68       	st.h	r7[0xc],r8
80008e22:	30 08       	mov	r8,0
80008e24:	8f 18       	st.w	r7[0x4],r8
80008e26:	6e 48       	ld.w	r8,r7[0x10]
80008e28:	8f 08       	st.w	r7[0x0],r8
80008e2a:	8e 68       	ld.sh	r8,r7[0xc]
80008e2c:	a3 b8       	sbr	r8,0x3
80008e2e:	ae 68       	st.h	r7[0xc],r8
80008e30:	6e 48       	ld.w	r8,r7[0x10]
80008e32:	58 08       	cp.w	r8,0
80008e34:	c0 b1       	brne	80008e4a <__swsetup_r+0xaa>
80008e36:	8e 68       	ld.sh	r8,r7[0xc]
80008e38:	e2 18 02 80 	andl	r8,0x280,COH
80008e3c:	e0 48 02 00 	cp.w	r8,512
80008e40:	c0 50       	breq	80008e4a <__swsetup_r+0xaa>
80008e42:	0c 9c       	mov	r12,r6
80008e44:	0e 9b       	mov	r11,r7
80008e46:	e0 a0 0a 4b 	rcall	8000a2dc <__smakebuf_r>
80008e4a:	8e 69       	ld.sh	r9,r7[0xc]
80008e4c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008e50:	c0 70       	breq	80008e5e <__swsetup_r+0xbe>
80008e52:	30 08       	mov	r8,0
80008e54:	8f 28       	st.w	r7[0x8],r8
80008e56:	6e 58       	ld.w	r8,r7[0x14]
80008e58:	5c 38       	neg	r8
80008e5a:	8f 68       	st.w	r7[0x18],r8
80008e5c:	c0 68       	rjmp	80008e68 <__swsetup_r+0xc8>
80008e5e:	ed b9 00 01 	bld	r9,0x1
80008e62:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008e66:	8f 28       	st.w	r7[0x8],r8
80008e68:	6e 48       	ld.w	r8,r7[0x10]
80008e6a:	58 08       	cp.w	r8,0
80008e6c:	c0 61       	brne	80008e78 <__swsetup_r+0xd8>
80008e6e:	8e 68       	ld.sh	r8,r7[0xc]
80008e70:	ed b8 00 07 	bld	r8,0x7
80008e74:	c0 21       	brne	80008e78 <__swsetup_r+0xd8>
80008e76:	dc 2a       	popm	r4-r7,pc,r12=-1
80008e78:	d8 2a       	popm	r4-r7,pc,r12=0
80008e7a:	d7 03       	nop

80008e7c <quorem>:
80008e7c:	d4 31       	pushm	r0-r7,lr
80008e7e:	20 2d       	sub	sp,8
80008e80:	18 97       	mov	r7,r12
80008e82:	78 48       	ld.w	r8,r12[0x10]
80008e84:	76 46       	ld.w	r6,r11[0x10]
80008e86:	0c 38       	cp.w	r8,r6
80008e88:	c0 34       	brge	80008e8e <quorem+0x12>
80008e8a:	30 0c       	mov	r12,0
80008e8c:	c8 58       	rjmp	80008f96 <quorem+0x11a>
80008e8e:	ec c2 ff fc 	sub	r2,r6,-4
80008e92:	f6 c3 ff ec 	sub	r3,r11,-20
80008e96:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008e9a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008e9e:	2f f9       	sub	r9,-1
80008ea0:	20 16       	sub	r6,1
80008ea2:	f8 09 0d 08 	divu	r8,r12,r9
80008ea6:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008eaa:	ee c4 ff ec 	sub	r4,r7,-20
80008eae:	10 95       	mov	r5,r8
80008eb0:	58 08       	cp.w	r8,0
80008eb2:	c4 10       	breq	80008f34 <quorem+0xb8>
80008eb4:	30 09       	mov	r9,0
80008eb6:	06 9a       	mov	r10,r3
80008eb8:	08 98       	mov	r8,r4
80008eba:	12 91       	mov	r1,r9
80008ebc:	50 0b       	stdsp	sp[0x0],r11
80008ebe:	70 0e       	ld.w	lr,r8[0x0]
80008ec0:	b1 8e       	lsr	lr,0x10
80008ec2:	50 1e       	stdsp	sp[0x4],lr
80008ec4:	15 0e       	ld.w	lr,r10++
80008ec6:	fc 00 16 10 	lsr	r0,lr,0x10
80008eca:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008ece:	ea 0e 03 41 	mac	r1,r5,lr
80008ed2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008ed6:	b1 81       	lsr	r1,0x10
80008ed8:	40 1b       	lddsp	r11,sp[0x4]
80008eda:	ea 00 02 40 	mul	r0,r5,r0
80008ede:	e2 00 00 00 	add	r0,r1,r0
80008ee2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008ee6:	02 1b       	sub	r11,r1
80008ee8:	50 1b       	stdsp	sp[0x4],r11
80008eea:	70 0b       	ld.w	r11,r8[0x0]
80008eec:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008ef0:	02 09       	add	r9,r1
80008ef2:	f2 0e 01 0e 	sub	lr,r9,lr
80008ef6:	b0 1e       	st.h	r8[0x2],lr
80008ef8:	fc 09 14 10 	asr	r9,lr,0x10
80008efc:	40 1e       	lddsp	lr,sp[0x4]
80008efe:	fc 09 00 09 	add	r9,lr,r9
80008f02:	b0 09       	st.h	r8[0x0],r9
80008f04:	e0 01 16 10 	lsr	r1,r0,0x10
80008f08:	2f c8       	sub	r8,-4
80008f0a:	b1 49       	asr	r9,0x10
80008f0c:	04 3a       	cp.w	r10,r2
80008f0e:	fe 98 ff d8 	brls	80008ebe <quorem+0x42>
80008f12:	40 0b       	lddsp	r11,sp[0x0]
80008f14:	58 0c       	cp.w	r12,0
80008f16:	c0 f1       	brne	80008f34 <quorem+0xb8>
80008f18:	ec c8 ff fb 	sub	r8,r6,-5
80008f1c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008f20:	c0 28       	rjmp	80008f24 <quorem+0xa8>
80008f22:	20 16       	sub	r6,1
80008f24:	20 48       	sub	r8,4
80008f26:	08 38       	cp.w	r8,r4
80008f28:	e0 88 00 05 	brls	80008f32 <quorem+0xb6>
80008f2c:	70 09       	ld.w	r9,r8[0x0]
80008f2e:	58 09       	cp.w	r9,0
80008f30:	cf 90       	breq	80008f22 <quorem+0xa6>
80008f32:	8f 46       	st.w	r7[0x10],r6
80008f34:	0e 9c       	mov	r12,r7
80008f36:	e0 a0 0a d2 	rcall	8000a4da <__mcmp>
80008f3a:	c2 d5       	brlt	80008f94 <quorem+0x118>
80008f3c:	2f f5       	sub	r5,-1
80008f3e:	08 98       	mov	r8,r4
80008f40:	30 09       	mov	r9,0
80008f42:	07 0b       	ld.w	r11,r3++
80008f44:	f6 0a 16 10 	lsr	r10,r11,0x10
80008f48:	70 0c       	ld.w	r12,r8[0x0]
80008f4a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80008f4e:	f8 0e 16 10 	lsr	lr,r12,0x10
80008f52:	14 1e       	sub	lr,r10
80008f54:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008f58:	16 1a       	sub	r10,r11
80008f5a:	12 0a       	add	r10,r9
80008f5c:	b0 1a       	st.h	r8[0x2],r10
80008f5e:	b1 4a       	asr	r10,0x10
80008f60:	fc 0a 00 09 	add	r9,lr,r10
80008f64:	b0 09       	st.h	r8[0x0],r9
80008f66:	2f c8       	sub	r8,-4
80008f68:	b1 49       	asr	r9,0x10
80008f6a:	04 33       	cp.w	r3,r2
80008f6c:	fe 98 ff eb 	brls	80008f42 <quorem+0xc6>
80008f70:	ec c8 ff fb 	sub	r8,r6,-5
80008f74:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008f78:	58 09       	cp.w	r9,0
80008f7a:	c0 d1       	brne	80008f94 <quorem+0x118>
80008f7c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008f80:	c0 28       	rjmp	80008f84 <quorem+0x108>
80008f82:	20 16       	sub	r6,1
80008f84:	20 48       	sub	r8,4
80008f86:	08 38       	cp.w	r8,r4
80008f88:	e0 88 00 05 	brls	80008f92 <quorem+0x116>
80008f8c:	70 09       	ld.w	r9,r8[0x0]
80008f8e:	58 09       	cp.w	r9,0
80008f90:	cf 90       	breq	80008f82 <quorem+0x106>
80008f92:	8f 46       	st.w	r7[0x10],r6
80008f94:	0a 9c       	mov	r12,r5
80008f96:	2f ed       	sub	sp,-8
80008f98:	d8 32       	popm	r0-r7,pc
80008f9a:	d7 03       	nop

80008f9c <_dtoa_r>:
80008f9c:	d4 31       	pushm	r0-r7,lr
80008f9e:	21 ad       	sub	sp,104
80008fa0:	fa c4 ff 74 	sub	r4,sp,-140
80008fa4:	18 97       	mov	r7,r12
80008fa6:	16 95       	mov	r5,r11
80008fa8:	68 2c       	ld.w	r12,r4[0x8]
80008faa:	50 c9       	stdsp	sp[0x30],r9
80008fac:	68 16       	ld.w	r6,r4[0x4]
80008fae:	68 09       	ld.w	r9,r4[0x0]
80008fb0:	50 e8       	stdsp	sp[0x38],r8
80008fb2:	14 94       	mov	r4,r10
80008fb4:	51 2c       	stdsp	sp[0x48],r12
80008fb6:	fa e5 00 08 	st.d	sp[8],r4
80008fba:	51 59       	stdsp	sp[0x54],r9
80008fbc:	6e 95       	ld.w	r5,r7[0x24]
80008fbe:	58 05       	cp.w	r5,0
80008fc0:	c0 91       	brne	80008fd2 <_dtoa_r+0x36>
80008fc2:	31 0c       	mov	r12,16
80008fc4:	fe b0 e8 e8 	rcall	80006194 <malloc>
80008fc8:	99 35       	st.w	r12[0xc],r5
80008fca:	8f 9c       	st.w	r7[0x24],r12
80008fcc:	99 15       	st.w	r12[0x4],r5
80008fce:	99 25       	st.w	r12[0x8],r5
80008fd0:	99 05       	st.w	r12[0x0],r5
80008fd2:	6e 99       	ld.w	r9,r7[0x24]
80008fd4:	72 08       	ld.w	r8,r9[0x0]
80008fd6:	58 08       	cp.w	r8,0
80008fd8:	c0 f0       	breq	80008ff6 <_dtoa_r+0x5a>
80008fda:	72 1a       	ld.w	r10,r9[0x4]
80008fdc:	91 1a       	st.w	r8[0x4],r10
80008fde:	30 1a       	mov	r10,1
80008fe0:	72 19       	ld.w	r9,r9[0x4]
80008fe2:	f4 09 09 49 	lsl	r9,r10,r9
80008fe6:	10 9b       	mov	r11,r8
80008fe8:	91 29       	st.w	r8[0x8],r9
80008fea:	0e 9c       	mov	r12,r7
80008fec:	e0 a0 0a 90 	rcall	8000a50c <_Bfree>
80008ff0:	6e 98       	ld.w	r8,r7[0x24]
80008ff2:	30 09       	mov	r9,0
80008ff4:	91 09       	st.w	r8[0x0],r9
80008ff6:	40 28       	lddsp	r8,sp[0x8]
80008ff8:	10 94       	mov	r4,r8
80008ffa:	58 08       	cp.w	r8,0
80008ffc:	c0 64       	brge	80009008 <_dtoa_r+0x6c>
80008ffe:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009002:	50 28       	stdsp	sp[0x8],r8
80009004:	30 18       	mov	r8,1
80009006:	c0 28       	rjmp	8000900a <_dtoa_r+0x6e>
80009008:	30 08       	mov	r8,0
8000900a:	8d 08       	st.w	r6[0x0],r8
8000900c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009010:	40 26       	lddsp	r6,sp[0x8]
80009012:	0c 98       	mov	r8,r6
80009014:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009018:	18 38       	cp.w	r8,r12
8000901a:	c2 01       	brne	8000905a <_dtoa_r+0xbe>
8000901c:	e0 68 27 0f 	mov	r8,9999
80009020:	41 5b       	lddsp	r11,sp[0x54]
80009022:	97 08       	st.w	r11[0x0],r8
80009024:	40 3a       	lddsp	r10,sp[0xc]
80009026:	58 0a       	cp.w	r10,0
80009028:	c0 71       	brne	80009036 <_dtoa_r+0x9a>
8000902a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000902e:	c0 41       	brne	80009036 <_dtoa_r+0x9a>
80009030:	fe cc bc c4 	sub	r12,pc,-17212
80009034:	c0 38       	rjmp	8000903a <_dtoa_r+0x9e>
80009036:	fe cc bc be 	sub	r12,pc,-17218
8000903a:	41 29       	lddsp	r9,sp[0x48]
8000903c:	58 09       	cp.w	r9,0
8000903e:	e0 80 05 9a 	breq	80009b72 <_dtoa_r+0xbd6>
80009042:	f8 c8 ff fd 	sub	r8,r12,-3
80009046:	f8 c9 ff f8 	sub	r9,r12,-8
8000904a:	11 8b       	ld.ub	r11,r8[0x0]
8000904c:	30 0a       	mov	r10,0
8000904e:	41 25       	lddsp	r5,sp[0x48]
80009050:	f4 0b 18 00 	cp.b	r11,r10
80009054:	f2 08 17 10 	movne	r8,r9
80009058:	c1 68       	rjmp	80009084 <_dtoa_r+0xe8>
8000905a:	fa ea 00 08 	ld.d	r10,sp[8]
8000905e:	30 08       	mov	r8,0
80009060:	fa eb 00 3c 	st.d	sp[60],r10
80009064:	30 09       	mov	r9,0
80009066:	e0 a0 10 c2 	rcall	8000b1ea <__avr32_f64_cmp_eq>
8000906a:	c1 00       	breq	8000908a <_dtoa_r+0xee>
8000906c:	30 18       	mov	r8,1
8000906e:	41 5a       	lddsp	r10,sp[0x54]
80009070:	95 08       	st.w	r10[0x0],r8
80009072:	fe cc be 2a 	sub	r12,pc,-16854
80009076:	41 29       	lddsp	r9,sp[0x48]
80009078:	f8 08 00 08 	add	r8,r12,r8
8000907c:	58 09       	cp.w	r9,0
8000907e:	e0 80 05 7a 	breq	80009b72 <_dtoa_r+0xbd6>
80009082:	12 95       	mov	r5,r9
80009084:	8b 08       	st.w	r5[0x0],r8
80009086:	e0 8f 05 76 	bral	80009b72 <_dtoa_r+0xbd6>
8000908a:	fa c8 ff 9c 	sub	r8,sp,-100
8000908e:	fa c9 ff a0 	sub	r9,sp,-96
80009092:	fa ea 00 3c 	ld.d	r10,sp[60]
80009096:	0e 9c       	mov	r12,r7
80009098:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000909c:	e0 a0 0a 8a 	rcall	8000a5b0 <__d2b>
800090a0:	18 93       	mov	r3,r12
800090a2:	58 05       	cp.w	r5,0
800090a4:	c0 d0       	breq	800090be <_dtoa_r+0x122>
800090a6:	fa ea 00 3c 	ld.d	r10,sp[60]
800090aa:	30 04       	mov	r4,0
800090ac:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800090b0:	ea c5 03 ff 	sub	r5,r5,1023
800090b4:	10 9b       	mov	r11,r8
800090b6:	51 74       	stdsp	sp[0x5c],r4
800090b8:	ea 1b 3f f0 	orh	r11,0x3ff0
800090bc:	c2 58       	rjmp	80009106 <_dtoa_r+0x16a>
800090be:	41 88       	lddsp	r8,sp[0x60]
800090c0:	41 9c       	lddsp	r12,sp[0x64]
800090c2:	10 0c       	add	r12,r8
800090c4:	f8 c5 fb ce 	sub	r5,r12,-1074
800090c8:	e0 45 00 20 	cp.w	r5,32
800090cc:	e0 8a 00 0e 	brle	800090e8 <_dtoa_r+0x14c>
800090d0:	f8 cc fb ee 	sub	r12,r12,-1042
800090d4:	40 3b       	lddsp	r11,sp[0xc]
800090d6:	ea 08 11 40 	rsub	r8,r5,64
800090da:	f6 0c 0a 4c 	lsr	r12,r11,r12
800090de:	ec 08 09 46 	lsl	r6,r6,r8
800090e2:	0c 4c       	or	r12,r6
800090e4:	c0 78       	rjmp	800090f2 <_dtoa_r+0x156>
800090e6:	d7 03       	nop
800090e8:	ea 0c 11 20 	rsub	r12,r5,32
800090ec:	40 3a       	lddsp	r10,sp[0xc]
800090ee:	f4 0c 09 4c 	lsl	r12,r10,r12
800090f2:	e0 a0 10 08 	rcall	8000b102 <__avr32_u32_to_f64>
800090f6:	fc 18 fe 10 	movh	r8,0xfe10
800090fa:	30 19       	mov	r9,1
800090fc:	ea c5 04 33 	sub	r5,r5,1075
80009100:	f0 0b 00 0b 	add	r11,r8,r11
80009104:	51 79       	stdsp	sp[0x5c],r9
80009106:	30 08       	mov	r8,0
80009108:	fc 19 3f f8 	movh	r9,0x3ff8
8000910c:	e0 a0 0e 90 	rcall	8000ae2c <__avr32_f64_sub>
80009110:	e0 68 43 61 	mov	r8,17249
80009114:	ea 18 63 6f 	orh	r8,0x636f
80009118:	e0 69 87 a7 	mov	r9,34727
8000911c:	ea 19 3f d2 	orh	r9,0x3fd2
80009120:	e0 a0 0d 9a 	rcall	8000ac54 <__avr32_f64_mul>
80009124:	e0 68 c8 b3 	mov	r8,51379
80009128:	ea 18 8b 60 	orh	r8,0x8b60
8000912c:	e0 69 8a 28 	mov	r9,35368
80009130:	ea 19 3f c6 	orh	r9,0x3fc6
80009134:	e0 a0 0f 4a 	rcall	8000afc8 <__avr32_f64_add>
80009138:	0a 9c       	mov	r12,r5
8000913a:	14 90       	mov	r0,r10
8000913c:	16 91       	mov	r1,r11
8000913e:	e0 a0 0f e6 	rcall	8000b10a <__avr32_s32_to_f64>
80009142:	e0 68 79 fb 	mov	r8,31227
80009146:	ea 18 50 9f 	orh	r8,0x509f
8000914a:	e0 69 44 13 	mov	r9,17427
8000914e:	ea 19 3f d3 	orh	r9,0x3fd3
80009152:	e0 a0 0d 81 	rcall	8000ac54 <__avr32_f64_mul>
80009156:	14 98       	mov	r8,r10
80009158:	16 99       	mov	r9,r11
8000915a:	00 9a       	mov	r10,r0
8000915c:	02 9b       	mov	r11,r1
8000915e:	e0 a0 0f 35 	rcall	8000afc8 <__avr32_f64_add>
80009162:	14 90       	mov	r0,r10
80009164:	16 91       	mov	r1,r11
80009166:	e0 a0 0f bb 	rcall	8000b0dc <__avr32_f64_to_s32>
8000916a:	30 08       	mov	r8,0
8000916c:	18 96       	mov	r6,r12
8000916e:	30 09       	mov	r9,0
80009170:	00 9a       	mov	r10,r0
80009172:	02 9b       	mov	r11,r1
80009174:	e0 a0 10 82 	rcall	8000b278 <__avr32_f64_cmp_lt>
80009178:	c0 c0       	breq	80009190 <_dtoa_r+0x1f4>
8000917a:	0c 9c       	mov	r12,r6
8000917c:	e0 a0 0f c7 	rcall	8000b10a <__avr32_s32_to_f64>
80009180:	14 98       	mov	r8,r10
80009182:	16 99       	mov	r9,r11
80009184:	00 9a       	mov	r10,r0
80009186:	02 9b       	mov	r11,r1
80009188:	e0 a0 10 31 	rcall	8000b1ea <__avr32_f64_cmp_eq>
8000918c:	f7 b6 00 01 	subeq	r6,1
80009190:	59 66       	cp.w	r6,22
80009192:	e0 88 00 05 	brls	8000919c <_dtoa_r+0x200>
80009196:	30 18       	mov	r8,1
80009198:	51 48       	stdsp	sp[0x50],r8
8000919a:	c1 38       	rjmp	800091c0 <_dtoa_r+0x224>
8000919c:	fe c8 bd 70 	sub	r8,pc,-17040
800091a0:	fa ea 00 3c 	ld.d	r10,sp[60]
800091a4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800091a8:	e0 a0 10 68 	rcall	8000b278 <__avr32_f64_cmp_lt>
800091ac:	f9 b4 00 00 	moveq	r4,0
800091b0:	fb f4 0a 14 	st.weq	sp[0x50],r4
800091b4:	f7 b6 01 01 	subne	r6,1
800091b8:	f9 bc 01 00 	movne	r12,0
800091bc:	fb fc 1a 14 	st.wne	sp[0x50],r12
800091c0:	41 90       	lddsp	r0,sp[0x64]
800091c2:	20 10       	sub	r0,1
800091c4:	0a 10       	sub	r0,r5
800091c6:	c0 46       	brmi	800091ce <_dtoa_r+0x232>
800091c8:	50 40       	stdsp	sp[0x10],r0
800091ca:	30 00       	mov	r0,0
800091cc:	c0 48       	rjmp	800091d4 <_dtoa_r+0x238>
800091ce:	30 0b       	mov	r11,0
800091d0:	5c 30       	neg	r0
800091d2:	50 4b       	stdsp	sp[0x10],r11
800091d4:	ec 02 11 00 	rsub	r2,r6,0
800091d8:	58 06       	cp.w	r6,0
800091da:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800091de:	f5 d6 e4 0a 	addge	r10,r10,r6
800091e2:	fb fa 4a 04 	st.wge	sp[0x10],r10
800091e6:	fb f6 4a 11 	st.wge	sp[0x44],r6
800091ea:	f9 b2 04 00 	movge	r2,0
800091ee:	e1 d6 e5 10 	sublt	r0,r0,r6
800091f2:	f9 b9 05 00 	movlt	r9,0
800091f6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800091fa:	40 c8       	lddsp	r8,sp[0x30]
800091fc:	58 98       	cp.w	r8,9
800091fe:	e0 8b 00 20 	brhi	8000923e <_dtoa_r+0x2a2>
80009202:	58 58       	cp.w	r8,5
80009204:	f9 b4 0a 01 	movle	r4,1
80009208:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000920c:	f7 b5 09 04 	subgt	r5,4
80009210:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009214:	f9 b4 09 00 	movgt	r4,0
80009218:	40 cc       	lddsp	r12,sp[0x30]
8000921a:	58 3c       	cp.w	r12,3
8000921c:	c2 d0       	breq	80009276 <_dtoa_r+0x2da>
8000921e:	e0 89 00 05 	brgt	80009228 <_dtoa_r+0x28c>
80009222:	58 2c       	cp.w	r12,2
80009224:	c1 01       	brne	80009244 <_dtoa_r+0x2a8>
80009226:	c1 88       	rjmp	80009256 <_dtoa_r+0x2ba>
80009228:	40 cb       	lddsp	r11,sp[0x30]
8000922a:	58 4b       	cp.w	r11,4
8000922c:	c0 60       	breq	80009238 <_dtoa_r+0x29c>
8000922e:	58 5b       	cp.w	r11,5
80009230:	c0 a1       	brne	80009244 <_dtoa_r+0x2a8>
80009232:	30 1a       	mov	r10,1
80009234:	50 da       	stdsp	sp[0x34],r10
80009236:	c2 28       	rjmp	8000927a <_dtoa_r+0x2de>
80009238:	30 19       	mov	r9,1
8000923a:	50 d9       	stdsp	sp[0x34],r9
8000923c:	c0 f8       	rjmp	8000925a <_dtoa_r+0x2be>
8000923e:	30 08       	mov	r8,0
80009240:	30 14       	mov	r4,1
80009242:	50 c8       	stdsp	sp[0x30],r8
80009244:	3f f5       	mov	r5,-1
80009246:	30 1c       	mov	r12,1
80009248:	30 0b       	mov	r11,0
8000924a:	50 95       	stdsp	sp[0x24],r5
8000924c:	50 dc       	stdsp	sp[0x34],r12
8000924e:	0a 91       	mov	r1,r5
80009250:	31 28       	mov	r8,18
80009252:	50 eb       	stdsp	sp[0x38],r11
80009254:	c2 08       	rjmp	80009294 <_dtoa_r+0x2f8>
80009256:	30 0a       	mov	r10,0
80009258:	50 da       	stdsp	sp[0x34],r10
8000925a:	40 e9       	lddsp	r9,sp[0x38]
8000925c:	58 09       	cp.w	r9,0
8000925e:	e0 89 00 07 	brgt	8000926c <_dtoa_r+0x2d0>
80009262:	30 18       	mov	r8,1
80009264:	50 98       	stdsp	sp[0x24],r8
80009266:	10 91       	mov	r1,r8
80009268:	50 e8       	stdsp	sp[0x38],r8
8000926a:	c1 58       	rjmp	80009294 <_dtoa_r+0x2f8>
8000926c:	40 e5       	lddsp	r5,sp[0x38]
8000926e:	50 95       	stdsp	sp[0x24],r5
80009270:	0a 91       	mov	r1,r5
80009272:	0a 98       	mov	r8,r5
80009274:	c1 08       	rjmp	80009294 <_dtoa_r+0x2f8>
80009276:	30 0c       	mov	r12,0
80009278:	50 dc       	stdsp	sp[0x34],r12
8000927a:	40 eb       	lddsp	r11,sp[0x38]
8000927c:	ec 0b 00 0b 	add	r11,r6,r11
80009280:	50 9b       	stdsp	sp[0x24],r11
80009282:	16 98       	mov	r8,r11
80009284:	2f f8       	sub	r8,-1
80009286:	58 08       	cp.w	r8,0
80009288:	e0 89 00 05 	brgt	80009292 <_dtoa_r+0x2f6>
8000928c:	10 91       	mov	r1,r8
8000928e:	30 18       	mov	r8,1
80009290:	c0 28       	rjmp	80009294 <_dtoa_r+0x2f8>
80009292:	10 91       	mov	r1,r8
80009294:	30 09       	mov	r9,0
80009296:	6e 9a       	ld.w	r10,r7[0x24]
80009298:	95 19       	st.w	r10[0x4],r9
8000929a:	30 49       	mov	r9,4
8000929c:	c0 68       	rjmp	800092a8 <_dtoa_r+0x30c>
8000929e:	d7 03       	nop
800092a0:	6a 1a       	ld.w	r10,r5[0x4]
800092a2:	a1 79       	lsl	r9,0x1
800092a4:	2f fa       	sub	r10,-1
800092a6:	8b 1a       	st.w	r5[0x4],r10
800092a8:	6e 95       	ld.w	r5,r7[0x24]
800092aa:	f2 ca ff ec 	sub	r10,r9,-20
800092ae:	10 3a       	cp.w	r10,r8
800092b0:	fe 98 ff f8 	brls	800092a0 <_dtoa_r+0x304>
800092b4:	6a 1b       	ld.w	r11,r5[0x4]
800092b6:	0e 9c       	mov	r12,r7
800092b8:	e0 a0 09 44 	rcall	8000a540 <_Balloc>
800092bc:	58 e1       	cp.w	r1,14
800092be:	5f 88       	srls	r8
800092c0:	8b 0c       	st.w	r5[0x0],r12
800092c2:	f1 e4 00 04 	and	r4,r8,r4
800092c6:	6e 98       	ld.w	r8,r7[0x24]
800092c8:	70 08       	ld.w	r8,r8[0x0]
800092ca:	50 88       	stdsp	sp[0x20],r8
800092cc:	e0 80 01 82 	breq	800095d0 <_dtoa_r+0x634>
800092d0:	58 06       	cp.w	r6,0
800092d2:	e0 8a 00 43 	brle	80009358 <_dtoa_r+0x3bc>
800092d6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800092da:	fe c8 be ae 	sub	r8,pc,-16722
800092de:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800092e2:	fa e5 00 18 	st.d	sp[24],r4
800092e6:	ec 04 14 04 	asr	r4,r6,0x4
800092ea:	ed b4 00 04 	bld	r4,0x4
800092ee:	c0 30       	breq	800092f4 <_dtoa_r+0x358>
800092f0:	30 25       	mov	r5,2
800092f2:	c1 08       	rjmp	80009312 <_dtoa_r+0x376>
800092f4:	fe c8 be 00 	sub	r8,pc,-16896
800092f8:	f0 e8 00 20 	ld.d	r8,r8[32]
800092fc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009300:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009304:	e0 a0 0f ee 	rcall	8000b2e0 <__avr32_f64_div>
80009308:	30 35       	mov	r5,3
8000930a:	14 98       	mov	r8,r10
8000930c:	16 99       	mov	r9,r11
8000930e:	fa e9 00 08 	st.d	sp[8],r8
80009312:	fe cc be 1e 	sub	r12,pc,-16866
80009316:	50 a3       	stdsp	sp[0x28],r3
80009318:	0c 93       	mov	r3,r6
8000931a:	18 96       	mov	r6,r12
8000931c:	c0 f8       	rjmp	8000933a <_dtoa_r+0x39e>
8000931e:	fa ea 00 18 	ld.d	r10,sp[24]
80009322:	ed b4 00 00 	bld	r4,0x0
80009326:	c0 81       	brne	80009336 <_dtoa_r+0x39a>
80009328:	ec e8 00 00 	ld.d	r8,r6[0]
8000932c:	2f f5       	sub	r5,-1
8000932e:	e0 a0 0c 93 	rcall	8000ac54 <__avr32_f64_mul>
80009332:	fa eb 00 18 	st.d	sp[24],r10
80009336:	a1 54       	asr	r4,0x1
80009338:	2f 86       	sub	r6,-8
8000933a:	58 04       	cp.w	r4,0
8000933c:	cf 11       	brne	8000931e <_dtoa_r+0x382>
8000933e:	fa e8 00 18 	ld.d	r8,sp[24]
80009342:	fa ea 00 08 	ld.d	r10,sp[8]
80009346:	06 96       	mov	r6,r3
80009348:	e0 a0 0f cc 	rcall	8000b2e0 <__avr32_f64_div>
8000934c:	40 a3       	lddsp	r3,sp[0x28]
8000934e:	14 98       	mov	r8,r10
80009350:	16 99       	mov	r9,r11
80009352:	fa e9 00 08 	st.d	sp[8],r8
80009356:	c2 f8       	rjmp	800093b4 <_dtoa_r+0x418>
80009358:	ec 08 11 00 	rsub	r8,r6,0
8000935c:	c0 31       	brne	80009362 <_dtoa_r+0x3c6>
8000935e:	30 25       	mov	r5,2
80009360:	c2 a8       	rjmp	800093b4 <_dtoa_r+0x418>
80009362:	fe cc be 6e 	sub	r12,pc,-16786
80009366:	f0 04 14 04 	asr	r4,r8,0x4
8000936a:	50 1c       	stdsp	sp[0x4],r12
8000936c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009370:	fe c9 bf 44 	sub	r9,pc,-16572
80009374:	fa ea 00 3c 	ld.d	r10,sp[60]
80009378:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000937c:	e0 a0 0c 6c 	rcall	8000ac54 <__avr32_f64_mul>
80009380:	40 1c       	lddsp	r12,sp[0x4]
80009382:	50 63       	stdsp	sp[0x18],r3
80009384:	30 25       	mov	r5,2
80009386:	0c 93       	mov	r3,r6
80009388:	fa eb 00 08 	st.d	sp[8],r10
8000938c:	18 96       	mov	r6,r12
8000938e:	c0 f8       	rjmp	800093ac <_dtoa_r+0x410>
80009390:	fa ea 00 08 	ld.d	r10,sp[8]
80009394:	ed b4 00 00 	bld	r4,0x0
80009398:	c0 81       	brne	800093a8 <_dtoa_r+0x40c>
8000939a:	ec e8 00 00 	ld.d	r8,r6[0]
8000939e:	2f f5       	sub	r5,-1
800093a0:	e0 a0 0c 5a 	rcall	8000ac54 <__avr32_f64_mul>
800093a4:	fa eb 00 08 	st.d	sp[8],r10
800093a8:	a1 54       	asr	r4,0x1
800093aa:	2f 86       	sub	r6,-8
800093ac:	58 04       	cp.w	r4,0
800093ae:	cf 11       	brne	80009390 <_dtoa_r+0x3f4>
800093b0:	06 96       	mov	r6,r3
800093b2:	40 63       	lddsp	r3,sp[0x18]
800093b4:	41 4a       	lddsp	r10,sp[0x50]
800093b6:	58 0a       	cp.w	r10,0
800093b8:	c2 a0       	breq	8000940c <_dtoa_r+0x470>
800093ba:	fa e8 00 08 	ld.d	r8,sp[8]
800093be:	58 01       	cp.w	r1,0
800093c0:	5f 94       	srgt	r4
800093c2:	fa e9 00 18 	st.d	sp[24],r8
800093c6:	30 08       	mov	r8,0
800093c8:	fc 19 3f f0 	movh	r9,0x3ff0
800093cc:	fa ea 00 18 	ld.d	r10,sp[24]
800093d0:	e0 a0 0f 54 	rcall	8000b278 <__avr32_f64_cmp_lt>
800093d4:	f9 bc 00 00 	moveq	r12,0
800093d8:	f9 bc 01 01 	movne	r12,1
800093dc:	e9 ec 00 0c 	and	r12,r4,r12
800093e0:	c1 60       	breq	8000940c <_dtoa_r+0x470>
800093e2:	40 98       	lddsp	r8,sp[0x24]
800093e4:	58 08       	cp.w	r8,0
800093e6:	e0 8a 00 f1 	brle	800095c8 <_dtoa_r+0x62c>
800093ea:	30 08       	mov	r8,0
800093ec:	fc 19 40 24 	movh	r9,0x4024
800093f0:	ec c4 00 01 	sub	r4,r6,1
800093f4:	fa ea 00 18 	ld.d	r10,sp[24]
800093f8:	2f f5       	sub	r5,-1
800093fa:	50 64       	stdsp	sp[0x18],r4
800093fc:	e0 a0 0c 2c 	rcall	8000ac54 <__avr32_f64_mul>
80009400:	40 94       	lddsp	r4,sp[0x24]
80009402:	14 98       	mov	r8,r10
80009404:	16 99       	mov	r9,r11
80009406:	fa e9 00 08 	st.d	sp[8],r8
8000940a:	c0 38       	rjmp	80009410 <_dtoa_r+0x474>
8000940c:	50 66       	stdsp	sp[0x18],r6
8000940e:	02 94       	mov	r4,r1
80009410:	0a 9c       	mov	r12,r5
80009412:	e0 a0 0e 7c 	rcall	8000b10a <__avr32_s32_to_f64>
80009416:	fa e8 00 08 	ld.d	r8,sp[8]
8000941a:	e0 a0 0c 1d 	rcall	8000ac54 <__avr32_f64_mul>
8000941e:	30 08       	mov	r8,0
80009420:	fc 19 40 1c 	movh	r9,0x401c
80009424:	e0 a0 0d d2 	rcall	8000afc8 <__avr32_f64_add>
80009428:	14 98       	mov	r8,r10
8000942a:	16 99       	mov	r9,r11
8000942c:	fa e9 00 28 	st.d	sp[40],r8
80009430:	fc 18 fc c0 	movh	r8,0xfcc0
80009434:	40 a5       	lddsp	r5,sp[0x28]
80009436:	10 05       	add	r5,r8
80009438:	50 a5       	stdsp	sp[0x28],r5
8000943a:	58 04       	cp.w	r4,0
8000943c:	c2 11       	brne	8000947e <_dtoa_r+0x4e2>
8000943e:	fa ea 00 08 	ld.d	r10,sp[8]
80009442:	30 08       	mov	r8,0
80009444:	fc 19 40 14 	movh	r9,0x4014
80009448:	e0 a0 0c f2 	rcall	8000ae2c <__avr32_f64_sub>
8000944c:	40 bc       	lddsp	r12,sp[0x2c]
8000944e:	fa eb 00 08 	st.d	sp[8],r10
80009452:	14 98       	mov	r8,r10
80009454:	16 99       	mov	r9,r11
80009456:	18 9a       	mov	r10,r12
80009458:	0a 9b       	mov	r11,r5
8000945a:	e0 a0 0f 0f 	rcall	8000b278 <__avr32_f64_cmp_lt>
8000945e:	e0 81 02 54 	brne	80009906 <_dtoa_r+0x96a>
80009462:	0a 98       	mov	r8,r5
80009464:	40 b9       	lddsp	r9,sp[0x2c]
80009466:	ee 18 80 00 	eorh	r8,0x8000
8000946a:	fa ea 00 08 	ld.d	r10,sp[8]
8000946e:	10 95       	mov	r5,r8
80009470:	12 98       	mov	r8,r9
80009472:	0a 99       	mov	r9,r5
80009474:	e0 a0 0f 02 	rcall	8000b278 <__avr32_f64_cmp_lt>
80009478:	e0 81 02 3e 	brne	800098f4 <_dtoa_r+0x958>
8000947c:	ca 68       	rjmp	800095c8 <_dtoa_r+0x62c>
8000947e:	fe c9 c0 52 	sub	r9,pc,-16302
80009482:	e8 c8 00 01 	sub	r8,r4,1
80009486:	40 d5       	lddsp	r5,sp[0x34]
80009488:	58 05       	cp.w	r5,0
8000948a:	c4 f0       	breq	80009528 <_dtoa_r+0x58c>
8000948c:	30 0c       	mov	r12,0
8000948e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009492:	51 3c       	stdsp	sp[0x4c],r12
80009494:	30 0a       	mov	r10,0
80009496:	fc 1b 3f e0 	movh	r11,0x3fe0
8000949a:	e0 a0 0f 23 	rcall	8000b2e0 <__avr32_f64_div>
8000949e:	fa e8 00 28 	ld.d	r8,sp[40]
800094a2:	40 85       	lddsp	r5,sp[0x20]
800094a4:	e0 a0 0c c4 	rcall	8000ae2c <__avr32_f64_sub>
800094a8:	fa eb 00 28 	st.d	sp[40],r10
800094ac:	fa ea 00 08 	ld.d	r10,sp[8]
800094b0:	e0 a0 0e 16 	rcall	8000b0dc <__avr32_f64_to_s32>
800094b4:	51 6c       	stdsp	sp[0x58],r12
800094b6:	e0 a0 0e 2a 	rcall	8000b10a <__avr32_s32_to_f64>
800094ba:	14 98       	mov	r8,r10
800094bc:	16 99       	mov	r9,r11
800094be:	fa ea 00 08 	ld.d	r10,sp[8]
800094c2:	e0 a0 0c b5 	rcall	8000ae2c <__avr32_f64_sub>
800094c6:	fa eb 00 08 	st.d	sp[8],r10
800094ca:	41 68       	lddsp	r8,sp[0x58]
800094cc:	2d 08       	sub	r8,-48
800094ce:	0a c8       	st.b	r5++,r8
800094d0:	41 39       	lddsp	r9,sp[0x4c]
800094d2:	2f f9       	sub	r9,-1
800094d4:	51 39       	stdsp	sp[0x4c],r9
800094d6:	fa e8 00 28 	ld.d	r8,sp[40]
800094da:	e0 a0 0e cf 	rcall	8000b278 <__avr32_f64_cmp_lt>
800094de:	e0 81 03 39 	brne	80009b50 <_dtoa_r+0xbb4>
800094e2:	fa e8 00 08 	ld.d	r8,sp[8]
800094e6:	30 0a       	mov	r10,0
800094e8:	fc 1b 3f f0 	movh	r11,0x3ff0
800094ec:	e0 a0 0c a0 	rcall	8000ae2c <__avr32_f64_sub>
800094f0:	fa e8 00 28 	ld.d	r8,sp[40]
800094f4:	e0 a0 0e c2 	rcall	8000b278 <__avr32_f64_cmp_lt>
800094f8:	fa ea 00 28 	ld.d	r10,sp[40]
800094fc:	30 08       	mov	r8,0
800094fe:	fc 19 40 24 	movh	r9,0x4024
80009502:	e0 81 00 da 	brne	800096b6 <_dtoa_r+0x71a>
80009506:	41 3c       	lddsp	r12,sp[0x4c]
80009508:	08 3c       	cp.w	r12,r4
8000950a:	c5 f4       	brge	800095c8 <_dtoa_r+0x62c>
8000950c:	e0 a0 0b a4 	rcall	8000ac54 <__avr32_f64_mul>
80009510:	30 08       	mov	r8,0
80009512:	fa eb 00 28 	st.d	sp[40],r10
80009516:	fc 19 40 24 	movh	r9,0x4024
8000951a:	fa ea 00 08 	ld.d	r10,sp[8]
8000951e:	e0 a0 0b 9b 	rcall	8000ac54 <__avr32_f64_mul>
80009522:	fa eb 00 08 	st.d	sp[8],r10
80009526:	cc 3b       	rjmp	800094ac <_dtoa_r+0x510>
80009528:	40 85       	lddsp	r5,sp[0x20]
8000952a:	08 05       	add	r5,r4
8000952c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009530:	51 35       	stdsp	sp[0x4c],r5
80009532:	fa e8 00 28 	ld.d	r8,sp[40]
80009536:	40 85       	lddsp	r5,sp[0x20]
80009538:	e0 a0 0b 8e 	rcall	8000ac54 <__avr32_f64_mul>
8000953c:	fa eb 00 28 	st.d	sp[40],r10
80009540:	fa ea 00 08 	ld.d	r10,sp[8]
80009544:	e0 a0 0d cc 	rcall	8000b0dc <__avr32_f64_to_s32>
80009548:	51 6c       	stdsp	sp[0x58],r12
8000954a:	e0 a0 0d e0 	rcall	8000b10a <__avr32_s32_to_f64>
8000954e:	14 98       	mov	r8,r10
80009550:	16 99       	mov	r9,r11
80009552:	fa ea 00 08 	ld.d	r10,sp[8]
80009556:	e0 a0 0c 6b 	rcall	8000ae2c <__avr32_f64_sub>
8000955a:	fa eb 00 08 	st.d	sp[8],r10
8000955e:	41 68       	lddsp	r8,sp[0x58]
80009560:	2d 08       	sub	r8,-48
80009562:	0a c8       	st.b	r5++,r8
80009564:	41 3c       	lddsp	r12,sp[0x4c]
80009566:	18 35       	cp.w	r5,r12
80009568:	c2 81       	brne	800095b8 <_dtoa_r+0x61c>
8000956a:	30 08       	mov	r8,0
8000956c:	fc 19 3f e0 	movh	r9,0x3fe0
80009570:	fa ea 00 28 	ld.d	r10,sp[40]
80009574:	e0 a0 0d 2a 	rcall	8000afc8 <__avr32_f64_add>
80009578:	40 85       	lddsp	r5,sp[0x20]
8000957a:	fa e8 00 08 	ld.d	r8,sp[8]
8000957e:	08 05       	add	r5,r4
80009580:	e0 a0 0e 7c 	rcall	8000b278 <__avr32_f64_cmp_lt>
80009584:	e0 81 00 99 	brne	800096b6 <_dtoa_r+0x71a>
80009588:	fa e8 00 28 	ld.d	r8,sp[40]
8000958c:	30 0a       	mov	r10,0
8000958e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009592:	e0 a0 0c 4d 	rcall	8000ae2c <__avr32_f64_sub>
80009596:	14 98       	mov	r8,r10
80009598:	16 99       	mov	r9,r11
8000959a:	fa ea 00 08 	ld.d	r10,sp[8]
8000959e:	e0 a0 0e 6d 	rcall	8000b278 <__avr32_f64_cmp_lt>
800095a2:	c1 30       	breq	800095c8 <_dtoa_r+0x62c>
800095a4:	33 09       	mov	r9,48
800095a6:	0a 98       	mov	r8,r5
800095a8:	11 7a       	ld.ub	r10,--r8
800095aa:	f2 0a 18 00 	cp.b	r10,r9
800095ae:	e0 81 02 d1 	brne	80009b50 <_dtoa_r+0xbb4>
800095b2:	10 95       	mov	r5,r8
800095b4:	cf 9b       	rjmp	800095a6 <_dtoa_r+0x60a>
800095b6:	d7 03       	nop
800095b8:	30 08       	mov	r8,0
800095ba:	fc 19 40 24 	movh	r9,0x4024
800095be:	e0 a0 0b 4b 	rcall	8000ac54 <__avr32_f64_mul>
800095c2:	fa eb 00 08 	st.d	sp[8],r10
800095c6:	cb db       	rjmp	80009540 <_dtoa_r+0x5a4>
800095c8:	fa ea 00 3c 	ld.d	r10,sp[60]
800095cc:	fa eb 00 08 	st.d	sp[8],r10
800095d0:	58 e6       	cp.w	r6,14
800095d2:	5f ab       	srle	r11
800095d4:	41 8a       	lddsp	r10,sp[0x60]
800095d6:	30 08       	mov	r8,0
800095d8:	f4 09 11 ff 	rsub	r9,r10,-1
800095dc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800095e0:	f0 09 18 00 	cp.b	r9,r8
800095e4:	e0 80 00 82 	breq	800096e8 <_dtoa_r+0x74c>
800095e8:	40 ea       	lddsp	r10,sp[0x38]
800095ea:	58 01       	cp.w	r1,0
800095ec:	5f a9       	srle	r9
800095ee:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800095f2:	fe ca c1 c6 	sub	r10,pc,-15930
800095f6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800095fa:	fa e5 00 10 	st.d	sp[16],r4
800095fe:	f0 09 18 00 	cp.b	r9,r8
80009602:	c1 40       	breq	8000962a <_dtoa_r+0x68e>
80009604:	58 01       	cp.w	r1,0
80009606:	e0 81 01 77 	brne	800098f4 <_dtoa_r+0x958>
8000960a:	30 08       	mov	r8,0
8000960c:	fc 19 40 14 	movh	r9,0x4014
80009610:	08 9a       	mov	r10,r4
80009612:	0a 9b       	mov	r11,r5
80009614:	e0 a0 0b 20 	rcall	8000ac54 <__avr32_f64_mul>
80009618:	fa e8 00 08 	ld.d	r8,sp[8]
8000961c:	e0 a0 0d fa 	rcall	8000b210 <__avr32_f64_cmp_ge>
80009620:	e0 81 01 6a 	brne	800098f4 <_dtoa_r+0x958>
80009624:	02 92       	mov	r2,r1
80009626:	e0 8f 01 72 	bral	8000990a <_dtoa_r+0x96e>
8000962a:	40 85       	lddsp	r5,sp[0x20]
8000962c:	30 14       	mov	r4,1
8000962e:	fa e8 00 10 	ld.d	r8,sp[16]
80009632:	fa ea 00 08 	ld.d	r10,sp[8]
80009636:	e0 a0 0e 55 	rcall	8000b2e0 <__avr32_f64_div>
8000963a:	e0 a0 0d 51 	rcall	8000b0dc <__avr32_f64_to_s32>
8000963e:	18 92       	mov	r2,r12
80009640:	e0 a0 0d 65 	rcall	8000b10a <__avr32_s32_to_f64>
80009644:	fa e8 00 10 	ld.d	r8,sp[16]
80009648:	e0 a0 0b 06 	rcall	8000ac54 <__avr32_f64_mul>
8000964c:	14 98       	mov	r8,r10
8000964e:	16 99       	mov	r9,r11
80009650:	fa ea 00 08 	ld.d	r10,sp[8]
80009654:	e0 a0 0b ec 	rcall	8000ae2c <__avr32_f64_sub>
80009658:	fa eb 00 08 	st.d	sp[8],r10
8000965c:	e4 c8 ff d0 	sub	r8,r2,-48
80009660:	0a c8       	st.b	r5++,r8
80009662:	fc 19 40 24 	movh	r9,0x4024
80009666:	30 08       	mov	r8,0
80009668:	02 34       	cp.w	r4,r1
8000966a:	c3 31       	brne	800096d0 <_dtoa_r+0x734>
8000966c:	fa e8 00 08 	ld.d	r8,sp[8]
80009670:	e0 a0 0c ac 	rcall	8000afc8 <__avr32_f64_add>
80009674:	16 91       	mov	r1,r11
80009676:	14 90       	mov	r0,r10
80009678:	14 98       	mov	r8,r10
8000967a:	02 99       	mov	r9,r1
8000967c:	fa ea 00 10 	ld.d	r10,sp[16]
80009680:	e0 a0 0d fc 	rcall	8000b278 <__avr32_f64_cmp_lt>
80009684:	c1 a1       	brne	800096b8 <_dtoa_r+0x71c>
80009686:	fa e8 00 10 	ld.d	r8,sp[16]
8000968a:	00 9a       	mov	r10,r0
8000968c:	02 9b       	mov	r11,r1
8000968e:	e0 a0 0d ae 	rcall	8000b1ea <__avr32_f64_cmp_eq>
80009692:	e0 80 02 5e 	breq	80009b4e <_dtoa_r+0xbb2>
80009696:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000969a:	c0 f1       	brne	800096b8 <_dtoa_r+0x71c>
8000969c:	e0 8f 02 59 	bral	80009b4e <_dtoa_r+0xbb2>
800096a0:	40 8a       	lddsp	r10,sp[0x20]
800096a2:	14 38       	cp.w	r8,r10
800096a4:	c0 30       	breq	800096aa <_dtoa_r+0x70e>
800096a6:	10 95       	mov	r5,r8
800096a8:	c0 98       	rjmp	800096ba <_dtoa_r+0x71e>
800096aa:	33 08       	mov	r8,48
800096ac:	40 89       	lddsp	r9,sp[0x20]
800096ae:	2f f6       	sub	r6,-1
800096b0:	b2 88       	st.b	r9[0x0],r8
800096b2:	40 88       	lddsp	r8,sp[0x20]
800096b4:	c0 88       	rjmp	800096c4 <_dtoa_r+0x728>
800096b6:	40 66       	lddsp	r6,sp[0x18]
800096b8:	33 99       	mov	r9,57
800096ba:	0a 98       	mov	r8,r5
800096bc:	11 7a       	ld.ub	r10,--r8
800096be:	f2 0a 18 00 	cp.b	r10,r9
800096c2:	ce f0       	breq	800096a0 <_dtoa_r+0x704>
800096c4:	50 66       	stdsp	sp[0x18],r6
800096c6:	11 89       	ld.ub	r9,r8[0x0]
800096c8:	2f f9       	sub	r9,-1
800096ca:	b0 89       	st.b	r8[0x0],r9
800096cc:	e0 8f 02 42 	bral	80009b50 <_dtoa_r+0xbb4>
800096d0:	e0 a0 0a c2 	rcall	8000ac54 <__avr32_f64_mul>
800096d4:	2f f4       	sub	r4,-1
800096d6:	fa eb 00 08 	st.d	sp[8],r10
800096da:	30 08       	mov	r8,0
800096dc:	30 09       	mov	r9,0
800096de:	e0 a0 0d 86 	rcall	8000b1ea <__avr32_f64_cmp_eq>
800096e2:	ca 60       	breq	8000962e <_dtoa_r+0x692>
800096e4:	e0 8f 02 35 	bral	80009b4e <_dtoa_r+0xbb2>
800096e8:	40 d8       	lddsp	r8,sp[0x34]
800096ea:	58 08       	cp.w	r8,0
800096ec:	c0 51       	brne	800096f6 <_dtoa_r+0x75a>
800096ee:	04 98       	mov	r8,r2
800096f0:	00 95       	mov	r5,r0
800096f2:	40 d4       	lddsp	r4,sp[0x34]
800096f4:	c3 78       	rjmp	80009762 <_dtoa_r+0x7c6>
800096f6:	40 c5       	lddsp	r5,sp[0x30]
800096f8:	58 15       	cp.w	r5,1
800096fa:	e0 89 00 0f 	brgt	80009718 <_dtoa_r+0x77c>
800096fe:	41 74       	lddsp	r4,sp[0x5c]
80009700:	58 04       	cp.w	r4,0
80009702:	c0 40       	breq	8000970a <_dtoa_r+0x76e>
80009704:	f4 c9 fb cd 	sub	r9,r10,-1075
80009708:	c0 48       	rjmp	80009710 <_dtoa_r+0x774>
8000970a:	41 99       	lddsp	r9,sp[0x64]
8000970c:	f2 09 11 36 	rsub	r9,r9,54
80009710:	04 98       	mov	r8,r2
80009712:	00 95       	mov	r5,r0
80009714:	c1 c8       	rjmp	8000974c <_dtoa_r+0x7b0>
80009716:	d7 03       	nop
80009718:	e2 c8 00 01 	sub	r8,r1,1
8000971c:	58 01       	cp.w	r1,0
8000971e:	e0 05 17 40 	movge	r5,r0
80009722:	e2 09 17 40 	movge	r9,r1
80009726:	e1 d1 e5 15 	sublt	r5,r0,r1
8000972a:	f9 b9 05 00 	movlt	r9,0
8000972e:	10 32       	cp.w	r2,r8
80009730:	e5 d8 e4 18 	subge	r8,r2,r8
80009734:	f1 d2 e5 18 	sublt	r8,r8,r2
80009738:	e5 d8 e5 02 	addlt	r2,r2,r8
8000973c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009740:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009744:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009748:	f9 b8 05 00 	movlt	r8,0
8000974c:	40 4b       	lddsp	r11,sp[0x10]
8000974e:	12 0b       	add	r11,r9
80009750:	50 08       	stdsp	sp[0x0],r8
80009752:	50 4b       	stdsp	sp[0x10],r11
80009754:	12 00       	add	r0,r9
80009756:	30 1b       	mov	r11,1
80009758:	0e 9c       	mov	r12,r7
8000975a:	e0 a0 08 a7 	rcall	8000a8a8 <__i2b>
8000975e:	40 08       	lddsp	r8,sp[0x0]
80009760:	18 94       	mov	r4,r12
80009762:	40 4a       	lddsp	r10,sp[0x10]
80009764:	58 05       	cp.w	r5,0
80009766:	5f 99       	srgt	r9
80009768:	58 0a       	cp.w	r10,0
8000976a:	5f 9a       	srgt	r10
8000976c:	f5 e9 00 09 	and	r9,r10,r9
80009770:	c0 80       	breq	80009780 <_dtoa_r+0x7e4>
80009772:	40 4c       	lddsp	r12,sp[0x10]
80009774:	f8 05 0d 49 	min	r9,r12,r5
80009778:	12 1c       	sub	r12,r9
8000977a:	12 10       	sub	r0,r9
8000977c:	50 4c       	stdsp	sp[0x10],r12
8000977e:	12 15       	sub	r5,r9
80009780:	58 02       	cp.w	r2,0
80009782:	e0 8a 00 27 	brle	800097d0 <_dtoa_r+0x834>
80009786:	40 db       	lddsp	r11,sp[0x34]
80009788:	58 0b       	cp.w	r11,0
8000978a:	c1 d0       	breq	800097c4 <_dtoa_r+0x828>
8000978c:	58 08       	cp.w	r8,0
8000978e:	e0 8a 00 17 	brle	800097bc <_dtoa_r+0x820>
80009792:	10 9a       	mov	r10,r8
80009794:	50 08       	stdsp	sp[0x0],r8
80009796:	08 9b       	mov	r11,r4
80009798:	0e 9c       	mov	r12,r7
8000979a:	e0 a0 08 cd 	rcall	8000a934 <__pow5mult>
8000979e:	06 9a       	mov	r10,r3
800097a0:	18 9b       	mov	r11,r12
800097a2:	18 94       	mov	r4,r12
800097a4:	0e 9c       	mov	r12,r7
800097a6:	e0 a0 08 01 	rcall	8000a7a8 <__multiply>
800097aa:	18 99       	mov	r9,r12
800097ac:	06 9b       	mov	r11,r3
800097ae:	50 19       	stdsp	sp[0x4],r9
800097b0:	0e 9c       	mov	r12,r7
800097b2:	e0 a0 06 ad 	rcall	8000a50c <_Bfree>
800097b6:	40 19       	lddsp	r9,sp[0x4]
800097b8:	40 08       	lddsp	r8,sp[0x0]
800097ba:	12 93       	mov	r3,r9
800097bc:	e4 08 01 0a 	sub	r10,r2,r8
800097c0:	c0 80       	breq	800097d0 <_dtoa_r+0x834>
800097c2:	c0 28       	rjmp	800097c6 <_dtoa_r+0x82a>
800097c4:	04 9a       	mov	r10,r2
800097c6:	06 9b       	mov	r11,r3
800097c8:	0e 9c       	mov	r12,r7
800097ca:	e0 a0 08 b5 	rcall	8000a934 <__pow5mult>
800097ce:	18 93       	mov	r3,r12
800097d0:	30 1b       	mov	r11,1
800097d2:	0e 9c       	mov	r12,r7
800097d4:	e0 a0 08 6a 	rcall	8000a8a8 <__i2b>
800097d8:	41 1a       	lddsp	r10,sp[0x44]
800097da:	18 92       	mov	r2,r12
800097dc:	58 0a       	cp.w	r10,0
800097de:	e0 8a 00 07 	brle	800097ec <_dtoa_r+0x850>
800097e2:	18 9b       	mov	r11,r12
800097e4:	0e 9c       	mov	r12,r7
800097e6:	e0 a0 08 a7 	rcall	8000a934 <__pow5mult>
800097ea:	18 92       	mov	r2,r12
800097ec:	40 c9       	lddsp	r9,sp[0x30]
800097ee:	58 19       	cp.w	r9,1
800097f0:	e0 89 00 14 	brgt	80009818 <_dtoa_r+0x87c>
800097f4:	40 38       	lddsp	r8,sp[0xc]
800097f6:	58 08       	cp.w	r8,0
800097f8:	c1 01       	brne	80009818 <_dtoa_r+0x87c>
800097fa:	40 29       	lddsp	r9,sp[0x8]
800097fc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009800:	c0 c1       	brne	80009818 <_dtoa_r+0x87c>
80009802:	12 98       	mov	r8,r9
80009804:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009808:	c0 80       	breq	80009818 <_dtoa_r+0x87c>
8000980a:	40 4c       	lddsp	r12,sp[0x10]
8000980c:	30 1b       	mov	r11,1
8000980e:	2f fc       	sub	r12,-1
80009810:	2f f0       	sub	r0,-1
80009812:	50 4c       	stdsp	sp[0x10],r12
80009814:	50 6b       	stdsp	sp[0x18],r11
80009816:	c0 38       	rjmp	8000981c <_dtoa_r+0x880>
80009818:	30 0a       	mov	r10,0
8000981a:	50 6a       	stdsp	sp[0x18],r10
8000981c:	41 19       	lddsp	r9,sp[0x44]
8000981e:	58 09       	cp.w	r9,0
80009820:	c0 31       	brne	80009826 <_dtoa_r+0x88a>
80009822:	30 1c       	mov	r12,1
80009824:	c0 98       	rjmp	80009836 <_dtoa_r+0x89a>
80009826:	64 48       	ld.w	r8,r2[0x10]
80009828:	2f c8       	sub	r8,-4
8000982a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000982e:	e0 a0 05 df 	rcall	8000a3ec <__hi0bits>
80009832:	f8 0c 11 20 	rsub	r12,r12,32
80009836:	40 4b       	lddsp	r11,sp[0x10]
80009838:	f8 0b 00 08 	add	r8,r12,r11
8000983c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009840:	c0 c0       	breq	80009858 <_dtoa_r+0x8bc>
80009842:	f0 08 11 20 	rsub	r8,r8,32
80009846:	58 48       	cp.w	r8,4
80009848:	e0 8a 00 06 	brle	80009854 <_dtoa_r+0x8b8>
8000984c:	20 48       	sub	r8,4
8000984e:	10 0b       	add	r11,r8
80009850:	50 4b       	stdsp	sp[0x10],r11
80009852:	c0 78       	rjmp	80009860 <_dtoa_r+0x8c4>
80009854:	58 48       	cp.w	r8,4
80009856:	c0 70       	breq	80009864 <_dtoa_r+0x8c8>
80009858:	40 4a       	lddsp	r10,sp[0x10]
8000985a:	2e 48       	sub	r8,-28
8000985c:	10 0a       	add	r10,r8
8000985e:	50 4a       	stdsp	sp[0x10],r10
80009860:	10 00       	add	r0,r8
80009862:	10 05       	add	r5,r8
80009864:	58 00       	cp.w	r0,0
80009866:	e0 8a 00 08 	brle	80009876 <_dtoa_r+0x8da>
8000986a:	06 9b       	mov	r11,r3
8000986c:	00 9a       	mov	r10,r0
8000986e:	0e 9c       	mov	r12,r7
80009870:	e0 a0 07 58 	rcall	8000a720 <__lshift>
80009874:	18 93       	mov	r3,r12
80009876:	40 49       	lddsp	r9,sp[0x10]
80009878:	58 09       	cp.w	r9,0
8000987a:	e0 8a 00 08 	brle	8000988a <_dtoa_r+0x8ee>
8000987e:	04 9b       	mov	r11,r2
80009880:	12 9a       	mov	r10,r9
80009882:	0e 9c       	mov	r12,r7
80009884:	e0 a0 07 4e 	rcall	8000a720 <__lshift>
80009888:	18 92       	mov	r2,r12
8000988a:	41 48       	lddsp	r8,sp[0x50]
8000988c:	58 08       	cp.w	r8,0
8000988e:	c1 b0       	breq	800098c4 <_dtoa_r+0x928>
80009890:	04 9b       	mov	r11,r2
80009892:	06 9c       	mov	r12,r3
80009894:	e0 a0 06 23 	rcall	8000a4da <__mcmp>
80009898:	c1 64       	brge	800098c4 <_dtoa_r+0x928>
8000989a:	06 9b       	mov	r11,r3
8000989c:	30 09       	mov	r9,0
8000989e:	30 aa       	mov	r10,10
800098a0:	0e 9c       	mov	r12,r7
800098a2:	e0 a0 08 0b 	rcall	8000a8b8 <__multadd>
800098a6:	20 16       	sub	r6,1
800098a8:	18 93       	mov	r3,r12
800098aa:	40 dc       	lddsp	r12,sp[0x34]
800098ac:	58 0c       	cp.w	r12,0
800098ae:	c0 31       	brne	800098b4 <_dtoa_r+0x918>
800098b0:	40 91       	lddsp	r1,sp[0x24]
800098b2:	c0 98       	rjmp	800098c4 <_dtoa_r+0x928>
800098b4:	08 9b       	mov	r11,r4
800098b6:	40 91       	lddsp	r1,sp[0x24]
800098b8:	30 09       	mov	r9,0
800098ba:	30 aa       	mov	r10,10
800098bc:	0e 9c       	mov	r12,r7
800098be:	e0 a0 07 fd 	rcall	8000a8b8 <__multadd>
800098c2:	18 94       	mov	r4,r12
800098c4:	58 01       	cp.w	r1,0
800098c6:	5f a9       	srle	r9
800098c8:	40 cb       	lddsp	r11,sp[0x30]
800098ca:	58 2b       	cp.w	r11,2
800098cc:	5f 98       	srgt	r8
800098ce:	f3 e8 00 08 	and	r8,r9,r8
800098d2:	c2 50       	breq	8000991c <_dtoa_r+0x980>
800098d4:	58 01       	cp.w	r1,0
800098d6:	c1 11       	brne	800098f8 <_dtoa_r+0x95c>
800098d8:	04 9b       	mov	r11,r2
800098da:	02 99       	mov	r9,r1
800098dc:	30 5a       	mov	r10,5
800098de:	0e 9c       	mov	r12,r7
800098e0:	e0 a0 07 ec 	rcall	8000a8b8 <__multadd>
800098e4:	18 92       	mov	r2,r12
800098e6:	18 9b       	mov	r11,r12
800098e8:	06 9c       	mov	r12,r3
800098ea:	e0 a0 05 f8 	rcall	8000a4da <__mcmp>
800098ee:	e0 89 00 0f 	brgt	8000990c <_dtoa_r+0x970>
800098f2:	c0 38       	rjmp	800098f8 <_dtoa_r+0x95c>
800098f4:	30 02       	mov	r2,0
800098f6:	04 94       	mov	r4,r2
800098f8:	40 ea       	lddsp	r10,sp[0x38]
800098fa:	30 09       	mov	r9,0
800098fc:	5c da       	com	r10
800098fe:	40 85       	lddsp	r5,sp[0x20]
80009900:	50 6a       	stdsp	sp[0x18],r10
80009902:	50 49       	stdsp	sp[0x10],r9
80009904:	c0 f9       	rjmp	80009b22 <_dtoa_r+0xb86>
80009906:	08 92       	mov	r2,r4
80009908:	40 66       	lddsp	r6,sp[0x18]
8000990a:	04 94       	mov	r4,r2
8000990c:	2f f6       	sub	r6,-1
8000990e:	50 66       	stdsp	sp[0x18],r6
80009910:	33 18       	mov	r8,49
80009912:	40 85       	lddsp	r5,sp[0x20]
80009914:	0a c8       	st.b	r5++,r8
80009916:	30 08       	mov	r8,0
80009918:	50 48       	stdsp	sp[0x10],r8
8000991a:	c0 49       	rjmp	80009b22 <_dtoa_r+0xb86>
8000991c:	40 dc       	lddsp	r12,sp[0x34]
8000991e:	58 0c       	cp.w	r12,0
80009920:	e0 80 00 b5 	breq	80009a8a <_dtoa_r+0xaee>
80009924:	58 05       	cp.w	r5,0
80009926:	e0 8a 00 08 	brle	80009936 <_dtoa_r+0x99a>
8000992a:	08 9b       	mov	r11,r4
8000992c:	0a 9a       	mov	r10,r5
8000992e:	0e 9c       	mov	r12,r7
80009930:	e0 a0 06 f8 	rcall	8000a720 <__lshift>
80009934:	18 94       	mov	r4,r12
80009936:	40 6b       	lddsp	r11,sp[0x18]
80009938:	58 0b       	cp.w	r11,0
8000993a:	c0 31       	brne	80009940 <_dtoa_r+0x9a4>
8000993c:	08 9c       	mov	r12,r4
8000993e:	c1 38       	rjmp	80009964 <_dtoa_r+0x9c8>
80009940:	68 1b       	ld.w	r11,r4[0x4]
80009942:	0e 9c       	mov	r12,r7
80009944:	e0 a0 05 fe 	rcall	8000a540 <_Balloc>
80009948:	68 4a       	ld.w	r10,r4[0x10]
8000994a:	18 95       	mov	r5,r12
8000994c:	e8 cb ff f4 	sub	r11,r4,-12
80009950:	2f ea       	sub	r10,-2
80009952:	2f 4c       	sub	r12,-12
80009954:	a3 6a       	lsl	r10,0x2
80009956:	fe b0 e6 43 	rcall	800065dc <memcpy>
8000995a:	0a 9b       	mov	r11,r5
8000995c:	30 1a       	mov	r10,1
8000995e:	0e 9c       	mov	r12,r7
80009960:	e0 a0 06 e0 	rcall	8000a720 <__lshift>
80009964:	50 44       	stdsp	sp[0x10],r4
80009966:	40 3a       	lddsp	r10,sp[0xc]
80009968:	30 19       	mov	r9,1
8000996a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000996e:	18 94       	mov	r4,r12
80009970:	50 da       	stdsp	sp[0x34],r10
80009972:	40 85       	lddsp	r5,sp[0x20]
80009974:	50 99       	stdsp	sp[0x24],r9
80009976:	50 26       	stdsp	sp[0x8],r6
80009978:	50 e1       	stdsp	sp[0x38],r1
8000997a:	04 9b       	mov	r11,r2
8000997c:	06 9c       	mov	r12,r3
8000997e:	fe b0 fa 7f 	rcall	80008e7c <quorem>
80009982:	40 4b       	lddsp	r11,sp[0x10]
80009984:	f8 c0 ff d0 	sub	r0,r12,-48
80009988:	06 9c       	mov	r12,r3
8000998a:	e0 a0 05 a8 	rcall	8000a4da <__mcmp>
8000998e:	08 9a       	mov	r10,r4
80009990:	50 6c       	stdsp	sp[0x18],r12
80009992:	04 9b       	mov	r11,r2
80009994:	0e 9c       	mov	r12,r7
80009996:	e0 a0 06 5d 	rcall	8000a650 <__mdiff>
8000999a:	18 91       	mov	r1,r12
8000999c:	78 38       	ld.w	r8,r12[0xc]
8000999e:	58 08       	cp.w	r8,0
800099a0:	c0 30       	breq	800099a6 <_dtoa_r+0xa0a>
800099a2:	30 16       	mov	r6,1
800099a4:	c0 68       	rjmp	800099b0 <_dtoa_r+0xa14>
800099a6:	18 9b       	mov	r11,r12
800099a8:	06 9c       	mov	r12,r3
800099aa:	e0 a0 05 98 	rcall	8000a4da <__mcmp>
800099ae:	18 96       	mov	r6,r12
800099b0:	0e 9c       	mov	r12,r7
800099b2:	02 9b       	mov	r11,r1
800099b4:	e0 a0 05 ac 	rcall	8000a50c <_Bfree>
800099b8:	40 cc       	lddsp	r12,sp[0x30]
800099ba:	ed ec 10 08 	or	r8,r6,r12
800099be:	c0 d1       	brne	800099d8 <_dtoa_r+0xa3c>
800099c0:	40 db       	lddsp	r11,sp[0x34]
800099c2:	58 0b       	cp.w	r11,0
800099c4:	c0 a1       	brne	800099d8 <_dtoa_r+0xa3c>
800099c6:	40 26       	lddsp	r6,sp[0x8]
800099c8:	e0 40 00 39 	cp.w	r0,57
800099cc:	c3 00       	breq	80009a2c <_dtoa_r+0xa90>
800099ce:	40 6a       	lddsp	r10,sp[0x18]
800099d0:	58 0a       	cp.w	r10,0
800099d2:	e0 89 00 24 	brgt	80009a1a <_dtoa_r+0xa7e>
800099d6:	c2 f8       	rjmp	80009a34 <_dtoa_r+0xa98>
800099d8:	40 69       	lddsp	r9,sp[0x18]
800099da:	58 09       	cp.w	r9,0
800099dc:	c0 85       	brlt	800099ec <_dtoa_r+0xa50>
800099de:	12 98       	mov	r8,r9
800099e0:	40 cc       	lddsp	r12,sp[0x30]
800099e2:	18 48       	or	r8,r12
800099e4:	c1 d1       	brne	80009a1e <_dtoa_r+0xa82>
800099e6:	40 db       	lddsp	r11,sp[0x34]
800099e8:	58 0b       	cp.w	r11,0
800099ea:	c1 a1       	brne	80009a1e <_dtoa_r+0xa82>
800099ec:	0c 99       	mov	r9,r6
800099ee:	40 26       	lddsp	r6,sp[0x8]
800099f0:	58 09       	cp.w	r9,0
800099f2:	e0 8a 00 21 	brle	80009a34 <_dtoa_r+0xa98>
800099f6:	06 9b       	mov	r11,r3
800099f8:	30 1a       	mov	r10,1
800099fa:	0e 9c       	mov	r12,r7
800099fc:	e0 a0 06 92 	rcall	8000a720 <__lshift>
80009a00:	04 9b       	mov	r11,r2
80009a02:	18 93       	mov	r3,r12
80009a04:	e0 a0 05 6b 	rcall	8000a4da <__mcmp>
80009a08:	e0 89 00 06 	brgt	80009a14 <_dtoa_r+0xa78>
80009a0c:	c1 41       	brne	80009a34 <_dtoa_r+0xa98>
80009a0e:	ed b0 00 00 	bld	r0,0x0
80009a12:	c1 11       	brne	80009a34 <_dtoa_r+0xa98>
80009a14:	e0 40 00 39 	cp.w	r0,57
80009a18:	c0 a0       	breq	80009a2c <_dtoa_r+0xa90>
80009a1a:	2f f0       	sub	r0,-1
80009a1c:	c0 c8       	rjmp	80009a34 <_dtoa_r+0xa98>
80009a1e:	58 06       	cp.w	r6,0
80009a20:	e0 8a 00 0c 	brle	80009a38 <_dtoa_r+0xa9c>
80009a24:	40 26       	lddsp	r6,sp[0x8]
80009a26:	e0 40 00 39 	cp.w	r0,57
80009a2a:	c0 41       	brne	80009a32 <_dtoa_r+0xa96>
80009a2c:	33 98       	mov	r8,57
80009a2e:	0a c8       	st.b	r5++,r8
80009a30:	c6 78       	rjmp	80009afe <_dtoa_r+0xb62>
80009a32:	2f f0       	sub	r0,-1
80009a34:	0a c0       	st.b	r5++,r0
80009a36:	c7 58       	rjmp	80009b20 <_dtoa_r+0xb84>
80009a38:	0a c0       	st.b	r5++,r0
80009a3a:	40 9a       	lddsp	r10,sp[0x24]
80009a3c:	40 e9       	lddsp	r9,sp[0x38]
80009a3e:	12 3a       	cp.w	r10,r9
80009a40:	c4 30       	breq	80009ac6 <_dtoa_r+0xb2a>
80009a42:	06 9b       	mov	r11,r3
80009a44:	30 09       	mov	r9,0
80009a46:	30 aa       	mov	r10,10
80009a48:	0e 9c       	mov	r12,r7
80009a4a:	e0 a0 07 37 	rcall	8000a8b8 <__multadd>
80009a4e:	40 48       	lddsp	r8,sp[0x10]
80009a50:	18 93       	mov	r3,r12
80009a52:	08 38       	cp.w	r8,r4
80009a54:	c0 91       	brne	80009a66 <_dtoa_r+0xaca>
80009a56:	10 9b       	mov	r11,r8
80009a58:	30 09       	mov	r9,0
80009a5a:	30 aa       	mov	r10,10
80009a5c:	0e 9c       	mov	r12,r7
80009a5e:	e0 a0 07 2d 	rcall	8000a8b8 <__multadd>
80009a62:	50 4c       	stdsp	sp[0x10],r12
80009a64:	c0 e8       	rjmp	80009a80 <_dtoa_r+0xae4>
80009a66:	40 4b       	lddsp	r11,sp[0x10]
80009a68:	30 09       	mov	r9,0
80009a6a:	30 aa       	mov	r10,10
80009a6c:	0e 9c       	mov	r12,r7
80009a6e:	e0 a0 07 25 	rcall	8000a8b8 <__multadd>
80009a72:	08 9b       	mov	r11,r4
80009a74:	50 4c       	stdsp	sp[0x10],r12
80009a76:	30 09       	mov	r9,0
80009a78:	30 aa       	mov	r10,10
80009a7a:	0e 9c       	mov	r12,r7
80009a7c:	e0 a0 07 1e 	rcall	8000a8b8 <__multadd>
80009a80:	18 94       	mov	r4,r12
80009a82:	40 9c       	lddsp	r12,sp[0x24]
80009a84:	2f fc       	sub	r12,-1
80009a86:	50 9c       	stdsp	sp[0x24],r12
80009a88:	c7 9b       	rjmp	8000997a <_dtoa_r+0x9de>
80009a8a:	30 18       	mov	r8,1
80009a8c:	06 90       	mov	r0,r3
80009a8e:	40 85       	lddsp	r5,sp[0x20]
80009a90:	08 93       	mov	r3,r4
80009a92:	0c 94       	mov	r4,r6
80009a94:	10 96       	mov	r6,r8
80009a96:	04 9b       	mov	r11,r2
80009a98:	00 9c       	mov	r12,r0
80009a9a:	fe b0 f9 f1 	rcall	80008e7c <quorem>
80009a9e:	2d 0c       	sub	r12,-48
80009aa0:	0a cc       	st.b	r5++,r12
80009aa2:	02 36       	cp.w	r6,r1
80009aa4:	c0 a4       	brge	80009ab8 <_dtoa_r+0xb1c>
80009aa6:	00 9b       	mov	r11,r0
80009aa8:	30 09       	mov	r9,0
80009aaa:	30 aa       	mov	r10,10
80009aac:	0e 9c       	mov	r12,r7
80009aae:	2f f6       	sub	r6,-1
80009ab0:	e0 a0 07 04 	rcall	8000a8b8 <__multadd>
80009ab4:	18 90       	mov	r0,r12
80009ab6:	cf 0b       	rjmp	80009a96 <_dtoa_r+0xafa>
80009ab8:	08 96       	mov	r6,r4
80009aba:	30 0b       	mov	r11,0
80009abc:	06 94       	mov	r4,r3
80009abe:	50 4b       	stdsp	sp[0x10],r11
80009ac0:	00 93       	mov	r3,r0
80009ac2:	18 90       	mov	r0,r12
80009ac4:	c0 28       	rjmp	80009ac8 <_dtoa_r+0xb2c>
80009ac6:	40 26       	lddsp	r6,sp[0x8]
80009ac8:	06 9b       	mov	r11,r3
80009aca:	30 1a       	mov	r10,1
80009acc:	0e 9c       	mov	r12,r7
80009ace:	e0 a0 06 29 	rcall	8000a720 <__lshift>
80009ad2:	04 9b       	mov	r11,r2
80009ad4:	18 93       	mov	r3,r12
80009ad6:	e0 a0 05 02 	rcall	8000a4da <__mcmp>
80009ada:	e0 89 00 12 	brgt	80009afe <_dtoa_r+0xb62>
80009ade:	c1 b1       	brne	80009b14 <_dtoa_r+0xb78>
80009ae0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009ae4:	c0 d1       	brne	80009afe <_dtoa_r+0xb62>
80009ae6:	c1 78       	rjmp	80009b14 <_dtoa_r+0xb78>
80009ae8:	40 89       	lddsp	r9,sp[0x20]
80009aea:	12 38       	cp.w	r8,r9
80009aec:	c0 30       	breq	80009af2 <_dtoa_r+0xb56>
80009aee:	10 95       	mov	r5,r8
80009af0:	c0 88       	rjmp	80009b00 <_dtoa_r+0xb64>
80009af2:	2f f6       	sub	r6,-1
80009af4:	50 66       	stdsp	sp[0x18],r6
80009af6:	33 18       	mov	r8,49
80009af8:	40 8c       	lddsp	r12,sp[0x20]
80009afa:	b8 88       	st.b	r12[0x0],r8
80009afc:	c1 38       	rjmp	80009b22 <_dtoa_r+0xb86>
80009afe:	33 9a       	mov	r10,57
80009b00:	0a 98       	mov	r8,r5
80009b02:	11 79       	ld.ub	r9,--r8
80009b04:	f4 09 18 00 	cp.b	r9,r10
80009b08:	cf 00       	breq	80009ae8 <_dtoa_r+0xb4c>
80009b0a:	2f f9       	sub	r9,-1
80009b0c:	b0 89       	st.b	r8[0x0],r9
80009b0e:	c0 98       	rjmp	80009b20 <_dtoa_r+0xb84>
80009b10:	10 95       	mov	r5,r8
80009b12:	c0 28       	rjmp	80009b16 <_dtoa_r+0xb7a>
80009b14:	33 09       	mov	r9,48
80009b16:	0a 98       	mov	r8,r5
80009b18:	11 7a       	ld.ub	r10,--r8
80009b1a:	f2 0a 18 00 	cp.b	r10,r9
80009b1e:	cf 90       	breq	80009b10 <_dtoa_r+0xb74>
80009b20:	50 66       	stdsp	sp[0x18],r6
80009b22:	04 9b       	mov	r11,r2
80009b24:	0e 9c       	mov	r12,r7
80009b26:	e0 a0 04 f3 	rcall	8000a50c <_Bfree>
80009b2a:	58 04       	cp.w	r4,0
80009b2c:	c1 20       	breq	80009b50 <_dtoa_r+0xbb4>
80009b2e:	40 4b       	lddsp	r11,sp[0x10]
80009b30:	08 3b       	cp.w	r11,r4
80009b32:	5f 19       	srne	r9
80009b34:	58 0b       	cp.w	r11,0
80009b36:	5f 18       	srne	r8
80009b38:	f3 e8 00 08 	and	r8,r9,r8
80009b3c:	c0 40       	breq	80009b44 <_dtoa_r+0xba8>
80009b3e:	0e 9c       	mov	r12,r7
80009b40:	e0 a0 04 e6 	rcall	8000a50c <_Bfree>
80009b44:	08 9b       	mov	r11,r4
80009b46:	0e 9c       	mov	r12,r7
80009b48:	e0 a0 04 e2 	rcall	8000a50c <_Bfree>
80009b4c:	c0 28       	rjmp	80009b50 <_dtoa_r+0xbb4>
80009b4e:	50 66       	stdsp	sp[0x18],r6
80009b50:	0e 9c       	mov	r12,r7
80009b52:	06 9b       	mov	r11,r3
80009b54:	e0 a0 04 dc 	rcall	8000a50c <_Bfree>
80009b58:	30 08       	mov	r8,0
80009b5a:	aa 88       	st.b	r5[0x0],r8
80009b5c:	40 68       	lddsp	r8,sp[0x18]
80009b5e:	41 5a       	lddsp	r10,sp[0x54]
80009b60:	2f f8       	sub	r8,-1
80009b62:	41 29       	lddsp	r9,sp[0x48]
80009b64:	95 08       	st.w	r10[0x0],r8
80009b66:	40 8c       	lddsp	r12,sp[0x20]
80009b68:	58 09       	cp.w	r9,0
80009b6a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009b6e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009b72:	2e 6d       	sub	sp,-104
80009b74:	d8 32       	popm	r0-r7,pc
80009b76:	d7 03       	nop

80009b78 <__errno>:
80009b78:	e0 68 0a 38 	mov	r8,2616
80009b7c:	70 0c       	ld.w	r12,r8[0x0]
80009b7e:	2f 4c       	sub	r12,-12
80009b80:	5e fc       	retal	r12
80009b82:	d7 03       	nop

80009b84 <_fflush_r>:
80009b84:	d4 21       	pushm	r4-r7,lr
80009b86:	16 97       	mov	r7,r11
80009b88:	18 96       	mov	r6,r12
80009b8a:	76 48       	ld.w	r8,r11[0x10]
80009b8c:	58 08       	cp.w	r8,0
80009b8e:	c7 f0       	breq	80009c8c <_fflush_r+0x108>
80009b90:	58 0c       	cp.w	r12,0
80009b92:	c0 50       	breq	80009b9c <_fflush_r+0x18>
80009b94:	78 68       	ld.w	r8,r12[0x18]
80009b96:	58 08       	cp.w	r8,0
80009b98:	c0 21       	brne	80009b9c <_fflush_r+0x18>
80009b9a:	cc dc       	rcall	80009d34 <__sinit>
80009b9c:	fe c8 c8 20 	sub	r8,pc,-14304
80009ba0:	10 37       	cp.w	r7,r8
80009ba2:	c0 31       	brne	80009ba8 <_fflush_r+0x24>
80009ba4:	6c 07       	ld.w	r7,r6[0x0]
80009ba6:	c0 c8       	rjmp	80009bbe <_fflush_r+0x3a>
80009ba8:	fe c8 c8 0c 	sub	r8,pc,-14324
80009bac:	10 37       	cp.w	r7,r8
80009bae:	c0 31       	brne	80009bb4 <_fflush_r+0x30>
80009bb0:	6c 17       	ld.w	r7,r6[0x4]
80009bb2:	c0 68       	rjmp	80009bbe <_fflush_r+0x3a>
80009bb4:	fe c8 c7 f8 	sub	r8,pc,-14344
80009bb8:	10 37       	cp.w	r7,r8
80009bba:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009bbe:	8e 6a       	ld.sh	r10,r7[0xc]
80009bc0:	14 98       	mov	r8,r10
80009bc2:	ed ba 00 03 	bld	r10,0x3
80009bc6:	c4 20       	breq	80009c4a <_fflush_r+0xc6>
80009bc8:	ab ba       	sbr	r10,0xb
80009bca:	ae 6a       	st.h	r7[0xc],r10
80009bcc:	6e 18       	ld.w	r8,r7[0x4]
80009bce:	58 08       	cp.w	r8,0
80009bd0:	e0 89 00 06 	brgt	80009bdc <_fflush_r+0x58>
80009bd4:	6f 08       	ld.w	r8,r7[0x40]
80009bd6:	58 08       	cp.w	r8,0
80009bd8:	e0 8a 00 5a 	brle	80009c8c <_fflush_r+0x108>
80009bdc:	6e b8       	ld.w	r8,r7[0x2c]
80009bde:	58 08       	cp.w	r8,0
80009be0:	c5 60       	breq	80009c8c <_fflush_r+0x108>
80009be2:	e2 1a 10 00 	andl	r10,0x1000,COH
80009be6:	c0 30       	breq	80009bec <_fflush_r+0x68>
80009be8:	6f 55       	ld.w	r5,r7[0x54]
80009bea:	c0 f8       	rjmp	80009c08 <_fflush_r+0x84>
80009bec:	30 19       	mov	r9,1
80009bee:	6e 8b       	ld.w	r11,r7[0x20]
80009bf0:	0c 9c       	mov	r12,r6
80009bf2:	5d 18       	icall	r8
80009bf4:	18 95       	mov	r5,r12
80009bf6:	5b fc       	cp.w	r12,-1
80009bf8:	c0 81       	brne	80009c08 <_fflush_r+0x84>
80009bfa:	6c 38       	ld.w	r8,r6[0xc]
80009bfc:	59 d8       	cp.w	r8,29
80009bfe:	c4 70       	breq	80009c8c <_fflush_r+0x108>
80009c00:	8e 68       	ld.sh	r8,r7[0xc]
80009c02:	a7 a8       	sbr	r8,0x6
80009c04:	ae 68       	st.h	r7[0xc],r8
80009c06:	d8 22       	popm	r4-r7,pc
80009c08:	8e 68       	ld.sh	r8,r7[0xc]
80009c0a:	ed b8 00 02 	bld	r8,0x2
80009c0e:	c0 91       	brne	80009c20 <_fflush_r+0x9c>
80009c10:	6e 18       	ld.w	r8,r7[0x4]
80009c12:	10 15       	sub	r5,r8
80009c14:	6e d8       	ld.w	r8,r7[0x34]
80009c16:	58 08       	cp.w	r8,0
80009c18:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009c1c:	eb d8 e1 15 	subne	r5,r5,r8
80009c20:	6e b8       	ld.w	r8,r7[0x2c]
80009c22:	0c 9c       	mov	r12,r6
80009c24:	30 09       	mov	r9,0
80009c26:	0a 9a       	mov	r10,r5
80009c28:	6e 8b       	ld.w	r11,r7[0x20]
80009c2a:	5d 18       	icall	r8
80009c2c:	8e 68       	ld.sh	r8,r7[0xc]
80009c2e:	0a 3c       	cp.w	r12,r5
80009c30:	c2 61       	brne	80009c7c <_fflush_r+0xf8>
80009c32:	ab d8       	cbr	r8,0xb
80009c34:	30 0c       	mov	r12,0
80009c36:	6e 49       	ld.w	r9,r7[0x10]
80009c38:	ae 68       	st.h	r7[0xc],r8
80009c3a:	8f 1c       	st.w	r7[0x4],r12
80009c3c:	8f 09       	st.w	r7[0x0],r9
80009c3e:	ed b8 00 0c 	bld	r8,0xc
80009c42:	c2 51       	brne	80009c8c <_fflush_r+0x108>
80009c44:	ef 45 00 54 	st.w	r7[84],r5
80009c48:	d8 22       	popm	r4-r7,pc
80009c4a:	6e 45       	ld.w	r5,r7[0x10]
80009c4c:	58 05       	cp.w	r5,0
80009c4e:	c1 f0       	breq	80009c8c <_fflush_r+0x108>
80009c50:	6e 04       	ld.w	r4,r7[0x0]
80009c52:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009c56:	8f 05       	st.w	r7[0x0],r5
80009c58:	f9 b8 01 00 	movne	r8,0
80009c5c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009c60:	0a 14       	sub	r4,r5
80009c62:	8f 28       	st.w	r7[0x8],r8
80009c64:	c1 18       	rjmp	80009c86 <_fflush_r+0x102>
80009c66:	08 99       	mov	r9,r4
80009c68:	0a 9a       	mov	r10,r5
80009c6a:	6e a8       	ld.w	r8,r7[0x28]
80009c6c:	6e 8b       	ld.w	r11,r7[0x20]
80009c6e:	0c 9c       	mov	r12,r6
80009c70:	5d 18       	icall	r8
80009c72:	18 14       	sub	r4,r12
80009c74:	58 0c       	cp.w	r12,0
80009c76:	e0 89 00 07 	brgt	80009c84 <_fflush_r+0x100>
80009c7a:	8e 68       	ld.sh	r8,r7[0xc]
80009c7c:	a7 a8       	sbr	r8,0x6
80009c7e:	3f fc       	mov	r12,-1
80009c80:	ae 68       	st.h	r7[0xc],r8
80009c82:	d8 22       	popm	r4-r7,pc
80009c84:	18 05       	add	r5,r12
80009c86:	58 04       	cp.w	r4,0
80009c88:	fe 99 ff ef 	brgt	80009c66 <_fflush_r+0xe2>
80009c8c:	d8 2a       	popm	r4-r7,pc,r12=0
80009c8e:	d7 03       	nop

80009c90 <__sfp_lock_acquire>:
80009c90:	5e fc       	retal	r12

80009c92 <__sfp_lock_release>:
80009c92:	5e fc       	retal	r12

80009c94 <_cleanup_r>:
80009c94:	d4 01       	pushm	lr
80009c96:	fe cb f0 c6 	sub	r11,pc,-3898
80009c9a:	e0 a0 02 f7 	rcall	8000a288 <_fwalk>
80009c9e:	d8 02       	popm	pc

80009ca0 <__sfmoreglue>:
80009ca0:	d4 21       	pushm	r4-r7,lr
80009ca2:	16 95       	mov	r5,r11
80009ca4:	f6 06 10 5c 	mul	r6,r11,92
80009ca8:	ec cb ff f4 	sub	r11,r6,-12
80009cac:	fe b0 e2 7c 	rcall	800061a4 <_malloc_r>
80009cb0:	18 97       	mov	r7,r12
80009cb2:	c0 90       	breq	80009cc4 <__sfmoreglue+0x24>
80009cb4:	99 15       	st.w	r12[0x4],r5
80009cb6:	30 0b       	mov	r11,0
80009cb8:	2f 4c       	sub	r12,-12
80009cba:	0c 9a       	mov	r10,r6
80009cbc:	8f 2c       	st.w	r7[0x8],r12
80009cbe:	8f 0b       	st.w	r7[0x0],r11
80009cc0:	fe b0 e5 32 	rcall	80006724 <memset>
80009cc4:	0e 9c       	mov	r12,r7
80009cc6:	d8 22       	popm	r4-r7,pc

80009cc8 <__sfp>:
80009cc8:	d4 21       	pushm	r4-r7,lr
80009cca:	fe c8 c8 ea 	sub	r8,pc,-14102
80009cce:	18 96       	mov	r6,r12
80009cd0:	70 07       	ld.w	r7,r8[0x0]
80009cd2:	6e 68       	ld.w	r8,r7[0x18]
80009cd4:	58 08       	cp.w	r8,0
80009cd6:	c0 31       	brne	80009cdc <__sfp+0x14>
80009cd8:	0e 9c       	mov	r12,r7
80009cda:	c2 dc       	rcall	80009d34 <__sinit>
80009cdc:	ee c7 ff 28 	sub	r7,r7,-216
80009ce0:	30 05       	mov	r5,0
80009ce2:	6e 2c       	ld.w	r12,r7[0x8]
80009ce4:	6e 18       	ld.w	r8,r7[0x4]
80009ce6:	c0 68       	rjmp	80009cf2 <__sfp+0x2a>
80009ce8:	98 69       	ld.sh	r9,r12[0xc]
80009cea:	ea 09 19 00 	cp.h	r9,r5
80009cee:	c1 10       	breq	80009d10 <__sfp+0x48>
80009cf0:	2a 4c       	sub	r12,-92
80009cf2:	20 18       	sub	r8,1
80009cf4:	cf a7       	brpl	80009ce8 <__sfp+0x20>
80009cf6:	6e 08       	ld.w	r8,r7[0x0]
80009cf8:	58 08       	cp.w	r8,0
80009cfa:	c0 61       	brne	80009d06 <__sfp+0x3e>
80009cfc:	30 4b       	mov	r11,4
80009cfe:	0c 9c       	mov	r12,r6
80009d00:	cd 0f       	rcall	80009ca0 <__sfmoreglue>
80009d02:	8f 0c       	st.w	r7[0x0],r12
80009d04:	c0 30       	breq	80009d0a <__sfp+0x42>
80009d06:	6e 07       	ld.w	r7,r7[0x0]
80009d08:	ce db       	rjmp	80009ce2 <__sfp+0x1a>
80009d0a:	30 c8       	mov	r8,12
80009d0c:	8d 38       	st.w	r6[0xc],r8
80009d0e:	d8 22       	popm	r4-r7,pc
80009d10:	30 08       	mov	r8,0
80009d12:	f9 48 00 4c 	st.w	r12[76],r8
80009d16:	99 08       	st.w	r12[0x0],r8
80009d18:	99 28       	st.w	r12[0x8],r8
80009d1a:	99 18       	st.w	r12[0x4],r8
80009d1c:	99 48       	st.w	r12[0x10],r8
80009d1e:	99 58       	st.w	r12[0x14],r8
80009d20:	99 68       	st.w	r12[0x18],r8
80009d22:	99 d8       	st.w	r12[0x34],r8
80009d24:	99 e8       	st.w	r12[0x38],r8
80009d26:	f9 48 00 48 	st.w	r12[72],r8
80009d2a:	3f f8       	mov	r8,-1
80009d2c:	b8 78       	st.h	r12[0xe],r8
80009d2e:	30 18       	mov	r8,1
80009d30:	b8 68       	st.h	r12[0xc],r8
80009d32:	d8 22       	popm	r4-r7,pc

80009d34 <__sinit>:
80009d34:	d4 21       	pushm	r4-r7,lr
80009d36:	18 96       	mov	r6,r12
80009d38:	78 67       	ld.w	r7,r12[0x18]
80009d3a:	58 07       	cp.w	r7,0
80009d3c:	c4 91       	brne	80009dce <__sinit+0x9a>
80009d3e:	fe c8 00 aa 	sub	r8,pc,170
80009d42:	30 15       	mov	r5,1
80009d44:	99 a8       	st.w	r12[0x28],r8
80009d46:	f9 47 00 d8 	st.w	r12[216],r7
80009d4a:	f9 47 00 dc 	st.w	r12[220],r7
80009d4e:	f9 47 00 e0 	st.w	r12[224],r7
80009d52:	99 65       	st.w	r12[0x18],r5
80009d54:	cb af       	rcall	80009cc8 <__sfp>
80009d56:	8d 0c       	st.w	r6[0x0],r12
80009d58:	0c 9c       	mov	r12,r6
80009d5a:	cb 7f       	rcall	80009cc8 <__sfp>
80009d5c:	8d 1c       	st.w	r6[0x4],r12
80009d5e:	0c 9c       	mov	r12,r6
80009d60:	cb 4f       	rcall	80009cc8 <__sfp>
80009d62:	6c 09       	ld.w	r9,r6[0x0]
80009d64:	30 48       	mov	r8,4
80009d66:	93 07       	st.w	r9[0x0],r7
80009d68:	b2 68       	st.h	r9[0xc],r8
80009d6a:	93 17       	st.w	r9[0x4],r7
80009d6c:	93 27       	st.w	r9[0x8],r7
80009d6e:	6c 18       	ld.w	r8,r6[0x4]
80009d70:	b2 77       	st.h	r9[0xe],r7
80009d72:	93 47       	st.w	r9[0x10],r7
80009d74:	93 57       	st.w	r9[0x14],r7
80009d76:	93 67       	st.w	r9[0x18],r7
80009d78:	93 89       	st.w	r9[0x20],r9
80009d7a:	91 07       	st.w	r8[0x0],r7
80009d7c:	91 17       	st.w	r8[0x4],r7
80009d7e:	91 27       	st.w	r8[0x8],r7
80009d80:	fe ce f3 24 	sub	lr,pc,-3292
80009d84:	fe cb f3 54 	sub	r11,pc,-3244
80009d88:	93 9e       	st.w	r9[0x24],lr
80009d8a:	93 ab       	st.w	r9[0x28],r11
80009d8c:	fe ca f3 7c 	sub	r10,pc,-3204
80009d90:	fe c4 f3 88 	sub	r4,pc,-3192
80009d94:	93 ba       	st.w	r9[0x2c],r10
80009d96:	93 c4       	st.w	r9[0x30],r4
80009d98:	30 99       	mov	r9,9
80009d9a:	b0 69       	st.h	r8[0xc],r9
80009d9c:	b0 75       	st.h	r8[0xe],r5
80009d9e:	91 c4       	st.w	r8[0x30],r4
80009da0:	91 47       	st.w	r8[0x10],r7
80009da2:	91 57       	st.w	r8[0x14],r7
80009da4:	91 67       	st.w	r8[0x18],r7
80009da6:	91 88       	st.w	r8[0x20],r8
80009da8:	91 9e       	st.w	r8[0x24],lr
80009daa:	91 ab       	st.w	r8[0x28],r11
80009dac:	91 ba       	st.w	r8[0x2c],r10
80009dae:	8d 2c       	st.w	r6[0x8],r12
80009db0:	31 28       	mov	r8,18
80009db2:	99 07       	st.w	r12[0x0],r7
80009db4:	b8 68       	st.h	r12[0xc],r8
80009db6:	99 17       	st.w	r12[0x4],r7
80009db8:	99 27       	st.w	r12[0x8],r7
80009dba:	30 28       	mov	r8,2
80009dbc:	b8 78       	st.h	r12[0xe],r8
80009dbe:	99 c4       	st.w	r12[0x30],r4
80009dc0:	99 67       	st.w	r12[0x18],r7
80009dc2:	99 9e       	st.w	r12[0x24],lr
80009dc4:	99 ab       	st.w	r12[0x28],r11
80009dc6:	99 ba       	st.w	r12[0x2c],r10
80009dc8:	99 47       	st.w	r12[0x10],r7
80009dca:	99 57       	st.w	r12[0x14],r7
80009dcc:	99 8c       	st.w	r12[0x20],r12
80009dce:	d8 22       	popm	r4-r7,pc

80009dd0 <_malloc_trim_r>:
80009dd0:	d4 21       	pushm	r4-r7,lr
80009dd2:	16 95       	mov	r5,r11
80009dd4:	18 97       	mov	r7,r12
80009dd6:	fe b0 d7 53 	rcall	80004c7c <__malloc_lock>
80009dda:	e0 64 05 38 	mov	r4,1336
80009dde:	68 28       	ld.w	r8,r4[0x8]
80009de0:	70 16       	ld.w	r6,r8[0x4]
80009de2:	e0 16 ff fc 	andl	r6,0xfffc
80009de6:	ec c8 ff 91 	sub	r8,r6,-111
80009dea:	f0 05 01 05 	sub	r5,r8,r5
80009dee:	e0 15 ff 80 	andl	r5,0xff80
80009df2:	ea c5 00 80 	sub	r5,r5,128
80009df6:	e0 45 00 7f 	cp.w	r5,127
80009dfa:	e0 8a 00 25 	brle	80009e44 <_malloc_trim_r+0x74>
80009dfe:	30 0b       	mov	r11,0
80009e00:	0e 9c       	mov	r12,r7
80009e02:	fe b0 e5 f9 	rcall	800069f4 <_sbrk_r>
80009e06:	68 28       	ld.w	r8,r4[0x8]
80009e08:	0c 08       	add	r8,r6
80009e0a:	10 3c       	cp.w	r12,r8
80009e0c:	c1 c1       	brne	80009e44 <_malloc_trim_r+0x74>
80009e0e:	ea 0b 11 00 	rsub	r11,r5,0
80009e12:	0e 9c       	mov	r12,r7
80009e14:	fe b0 e5 f0 	rcall	800069f4 <_sbrk_r>
80009e18:	5b fc       	cp.w	r12,-1
80009e1a:	c1 91       	brne	80009e4c <_malloc_trim_r+0x7c>
80009e1c:	30 0b       	mov	r11,0
80009e1e:	0e 9c       	mov	r12,r7
80009e20:	fe b0 e5 ea 	rcall	800069f4 <_sbrk_r>
80009e24:	68 28       	ld.w	r8,r4[0x8]
80009e26:	f8 08 01 09 	sub	r9,r12,r8
80009e2a:	58 f9       	cp.w	r9,15
80009e2c:	e0 8a 00 0c 	brle	80009e44 <_malloc_trim_r+0x74>
80009e30:	a1 a9       	sbr	r9,0x0
80009e32:	91 19       	st.w	r8[0x4],r9
80009e34:	e0 68 09 44 	mov	r8,2372
80009e38:	70 09       	ld.w	r9,r8[0x0]
80009e3a:	e0 68 0d 78 	mov	r8,3448
80009e3e:	f8 09 01 09 	sub	r9,r12,r9
80009e42:	91 09       	st.w	r8[0x0],r9
80009e44:	0e 9c       	mov	r12,r7
80009e46:	fe b0 d7 21 	rcall	80004c88 <__malloc_unlock>
80009e4a:	d8 2a       	popm	r4-r7,pc,r12=0
80009e4c:	68 28       	ld.w	r8,r4[0x8]
80009e4e:	0a 16       	sub	r6,r5
80009e50:	a1 a6       	sbr	r6,0x0
80009e52:	91 16       	st.w	r8[0x4],r6
80009e54:	e0 68 0d 78 	mov	r8,3448
80009e58:	70 09       	ld.w	r9,r8[0x0]
80009e5a:	0a 19       	sub	r9,r5
80009e5c:	0e 9c       	mov	r12,r7
80009e5e:	91 09       	st.w	r8[0x0],r9
80009e60:	fe b0 d7 14 	rcall	80004c88 <__malloc_unlock>
80009e64:	da 2a       	popm	r4-r7,pc,r12=1
80009e66:	d7 03       	nop

80009e68 <_free_r>:
80009e68:	d4 21       	pushm	r4-r7,lr
80009e6a:	16 96       	mov	r6,r11
80009e6c:	18 97       	mov	r7,r12
80009e6e:	58 0b       	cp.w	r11,0
80009e70:	e0 80 00 c0 	breq	80009ff0 <_free_r+0x188>
80009e74:	fe b0 d7 04 	rcall	80004c7c <__malloc_lock>
80009e78:	20 86       	sub	r6,8
80009e7a:	e0 6a 05 38 	mov	r10,1336
80009e7e:	6c 18       	ld.w	r8,r6[0x4]
80009e80:	74 2e       	ld.w	lr,r10[0x8]
80009e82:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009e86:	a1 c8       	cbr	r8,0x0
80009e88:	ec 08 00 09 	add	r9,r6,r8
80009e8c:	72 1b       	ld.w	r11,r9[0x4]
80009e8e:	e0 1b ff fc 	andl	r11,0xfffc
80009e92:	1c 39       	cp.w	r9,lr
80009e94:	c1 e1       	brne	80009ed0 <_free_r+0x68>
80009e96:	f6 08 00 08 	add	r8,r11,r8
80009e9a:	58 0c       	cp.w	r12,0
80009e9c:	c0 81       	brne	80009eac <_free_r+0x44>
80009e9e:	6c 09       	ld.w	r9,r6[0x0]
80009ea0:	12 16       	sub	r6,r9
80009ea2:	12 08       	add	r8,r9
80009ea4:	6c 3b       	ld.w	r11,r6[0xc]
80009ea6:	6c 29       	ld.w	r9,r6[0x8]
80009ea8:	97 29       	st.w	r11[0x8],r9
80009eaa:	93 3b       	st.w	r9[0xc],r11
80009eac:	10 99       	mov	r9,r8
80009eae:	95 26       	st.w	r10[0x8],r6
80009eb0:	a1 a9       	sbr	r9,0x0
80009eb2:	8d 19       	st.w	r6[0x4],r9
80009eb4:	e0 69 09 40 	mov	r9,2368
80009eb8:	72 09       	ld.w	r9,r9[0x0]
80009eba:	12 38       	cp.w	r8,r9
80009ebc:	c0 63       	brcs	80009ec8 <_free_r+0x60>
80009ebe:	e0 68 0d 74 	mov	r8,3444
80009ec2:	0e 9c       	mov	r12,r7
80009ec4:	70 0b       	ld.w	r11,r8[0x0]
80009ec6:	c8 5f       	rcall	80009dd0 <_malloc_trim_r>
80009ec8:	0e 9c       	mov	r12,r7
80009eca:	fe b0 d6 df 	rcall	80004c88 <__malloc_unlock>
80009ece:	d8 22       	popm	r4-r7,pc
80009ed0:	93 1b       	st.w	r9[0x4],r11
80009ed2:	58 0c       	cp.w	r12,0
80009ed4:	c0 30       	breq	80009eda <_free_r+0x72>
80009ed6:	30 0c       	mov	r12,0
80009ed8:	c1 08       	rjmp	80009ef8 <_free_r+0x90>
80009eda:	6c 0e       	ld.w	lr,r6[0x0]
80009edc:	f4 c5 ff f8 	sub	r5,r10,-8
80009ee0:	1c 16       	sub	r6,lr
80009ee2:	1c 08       	add	r8,lr
80009ee4:	6c 2e       	ld.w	lr,r6[0x8]
80009ee6:	0a 3e       	cp.w	lr,r5
80009ee8:	f9 bc 00 01 	moveq	r12,1
80009eec:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009ef0:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009ef4:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009ef8:	f2 0b 00 0e 	add	lr,r9,r11
80009efc:	7c 1e       	ld.w	lr,lr[0x4]
80009efe:	ed be 00 00 	bld	lr,0x0
80009f02:	c1 40       	breq	80009f2a <_free_r+0xc2>
80009f04:	16 08       	add	r8,r11
80009f06:	58 0c       	cp.w	r12,0
80009f08:	c0 d1       	brne	80009f22 <_free_r+0xba>
80009f0a:	e0 6e 05 38 	mov	lr,1336
80009f0e:	72 2b       	ld.w	r11,r9[0x8]
80009f10:	2f 8e       	sub	lr,-8
80009f12:	1c 3b       	cp.w	r11,lr
80009f14:	c0 71       	brne	80009f22 <_free_r+0xba>
80009f16:	97 36       	st.w	r11[0xc],r6
80009f18:	97 26       	st.w	r11[0x8],r6
80009f1a:	8d 2b       	st.w	r6[0x8],r11
80009f1c:	8d 3b       	st.w	r6[0xc],r11
80009f1e:	30 1c       	mov	r12,1
80009f20:	c0 58       	rjmp	80009f2a <_free_r+0xc2>
80009f22:	72 2b       	ld.w	r11,r9[0x8]
80009f24:	72 39       	ld.w	r9,r9[0xc]
80009f26:	93 2b       	st.w	r9[0x8],r11
80009f28:	97 39       	st.w	r11[0xc],r9
80009f2a:	10 99       	mov	r9,r8
80009f2c:	ec 08 09 08 	st.w	r6[r8],r8
80009f30:	a1 a9       	sbr	r9,0x0
80009f32:	8d 19       	st.w	r6[0x4],r9
80009f34:	58 0c       	cp.w	r12,0
80009f36:	c5 a1       	brne	80009fea <_free_r+0x182>
80009f38:	e0 48 01 ff 	cp.w	r8,511
80009f3c:	e0 8b 00 13 	brhi	80009f62 <_free_r+0xfa>
80009f40:	a3 98       	lsr	r8,0x3
80009f42:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009f46:	72 2b       	ld.w	r11,r9[0x8]
80009f48:	8d 39       	st.w	r6[0xc],r9
80009f4a:	8d 2b       	st.w	r6[0x8],r11
80009f4c:	97 36       	st.w	r11[0xc],r6
80009f4e:	93 26       	st.w	r9[0x8],r6
80009f50:	a3 48       	asr	r8,0x2
80009f52:	74 19       	ld.w	r9,r10[0x4]
80009f54:	30 1b       	mov	r11,1
80009f56:	f6 08 09 48 	lsl	r8,r11,r8
80009f5a:	f3 e8 10 08 	or	r8,r9,r8
80009f5e:	95 18       	st.w	r10[0x4],r8
80009f60:	c4 58       	rjmp	80009fea <_free_r+0x182>
80009f62:	f0 0b 16 09 	lsr	r11,r8,0x9
80009f66:	58 4b       	cp.w	r11,4
80009f68:	e0 8b 00 06 	brhi	80009f74 <_free_r+0x10c>
80009f6c:	f0 0b 16 06 	lsr	r11,r8,0x6
80009f70:	2c 8b       	sub	r11,-56
80009f72:	c2 08       	rjmp	80009fb2 <_free_r+0x14a>
80009f74:	59 4b       	cp.w	r11,20
80009f76:	e0 8b 00 04 	brhi	80009f7e <_free_r+0x116>
80009f7a:	2a 5b       	sub	r11,-91
80009f7c:	c1 b8       	rjmp	80009fb2 <_free_r+0x14a>
80009f7e:	e0 4b 00 54 	cp.w	r11,84
80009f82:	e0 8b 00 06 	brhi	80009f8e <_free_r+0x126>
80009f86:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009f8a:	29 2b       	sub	r11,-110
80009f8c:	c1 38       	rjmp	80009fb2 <_free_r+0x14a>
80009f8e:	e0 4b 01 54 	cp.w	r11,340
80009f92:	e0 8b 00 06 	brhi	80009f9e <_free_r+0x136>
80009f96:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009f9a:	28 9b       	sub	r11,-119
80009f9c:	c0 b8       	rjmp	80009fb2 <_free_r+0x14a>
80009f9e:	e0 4b 05 54 	cp.w	r11,1364
80009fa2:	e0 88 00 05 	brls	80009fac <_free_r+0x144>
80009fa6:	37 eb       	mov	r11,126
80009fa8:	c0 58       	rjmp	80009fb2 <_free_r+0x14a>
80009faa:	d7 03       	nop
80009fac:	f0 0b 16 12 	lsr	r11,r8,0x12
80009fb0:	28 4b       	sub	r11,-124
80009fb2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009fb6:	78 29       	ld.w	r9,r12[0x8]
80009fb8:	18 39       	cp.w	r9,r12
80009fba:	c0 e1       	brne	80009fd6 <_free_r+0x16e>
80009fbc:	74 18       	ld.w	r8,r10[0x4]
80009fbe:	a3 4b       	asr	r11,0x2
80009fc0:	30 1c       	mov	r12,1
80009fc2:	f8 0b 09 4b 	lsl	r11,r12,r11
80009fc6:	f1 eb 10 0b 	or	r11,r8,r11
80009fca:	12 98       	mov	r8,r9
80009fcc:	95 1b       	st.w	r10[0x4],r11
80009fce:	c0 a8       	rjmp	80009fe2 <_free_r+0x17a>
80009fd0:	72 29       	ld.w	r9,r9[0x8]
80009fd2:	18 39       	cp.w	r9,r12
80009fd4:	c0 60       	breq	80009fe0 <_free_r+0x178>
80009fd6:	72 1a       	ld.w	r10,r9[0x4]
80009fd8:	e0 1a ff fc 	andl	r10,0xfffc
80009fdc:	14 38       	cp.w	r8,r10
80009fde:	cf 93       	brcs	80009fd0 <_free_r+0x168>
80009fe0:	72 38       	ld.w	r8,r9[0xc]
80009fe2:	8d 38       	st.w	r6[0xc],r8
80009fe4:	8d 29       	st.w	r6[0x8],r9
80009fe6:	93 36       	st.w	r9[0xc],r6
80009fe8:	91 26       	st.w	r8[0x8],r6
80009fea:	0e 9c       	mov	r12,r7
80009fec:	fe b0 d6 4e 	rcall	80004c88 <__malloc_unlock>
80009ff0:	d8 22       	popm	r4-r7,pc
80009ff2:	d7 03       	nop

80009ff4 <__sfvwrite_r>:
80009ff4:	d4 31       	pushm	r0-r7,lr
80009ff6:	20 3d       	sub	sp,12
80009ff8:	14 94       	mov	r4,r10
80009ffa:	18 95       	mov	r5,r12
80009ffc:	16 97       	mov	r7,r11
80009ffe:	74 28       	ld.w	r8,r10[0x8]
8000a000:	58 08       	cp.w	r8,0
8000a002:	e0 80 01 40 	breq	8000a282 <__sfvwrite_r+0x28e>
8000a006:	96 68       	ld.sh	r8,r11[0xc]
8000a008:	ed b8 00 03 	bld	r8,0x3
8000a00c:	c0 41       	brne	8000a014 <__sfvwrite_r+0x20>
8000a00e:	76 48       	ld.w	r8,r11[0x10]
8000a010:	58 08       	cp.w	r8,0
8000a012:	c0 c1       	brne	8000a02a <__sfvwrite_r+0x36>
8000a014:	0e 9b       	mov	r11,r7
8000a016:	0a 9c       	mov	r12,r5
8000a018:	fe b0 f6 c4 	rcall	80008da0 <__swsetup_r>
8000a01c:	c0 70       	breq	8000a02a <__sfvwrite_r+0x36>
8000a01e:	8e 68       	ld.sh	r8,r7[0xc]
8000a020:	a7 a8       	sbr	r8,0x6
8000a022:	ae 68       	st.h	r7[0xc],r8
8000a024:	30 98       	mov	r8,9
8000a026:	8b 38       	st.w	r5[0xc],r8
8000a028:	c2 b9       	rjmp	8000a27e <__sfvwrite_r+0x28a>
8000a02a:	8e 63       	ld.sh	r3,r7[0xc]
8000a02c:	68 00       	ld.w	r0,r4[0x0]
8000a02e:	06 96       	mov	r6,r3
8000a030:	e2 16 00 02 	andl	r6,0x2,COH
8000a034:	c2 10       	breq	8000a076 <__sfvwrite_r+0x82>
8000a036:	30 03       	mov	r3,0
8000a038:	e0 62 04 00 	mov	r2,1024
8000a03c:	06 96       	mov	r6,r3
8000a03e:	c0 48       	rjmp	8000a046 <__sfvwrite_r+0x52>
8000a040:	60 03       	ld.w	r3,r0[0x0]
8000a042:	60 16       	ld.w	r6,r0[0x4]
8000a044:	2f 80       	sub	r0,-8
8000a046:	58 06       	cp.w	r6,0
8000a048:	cf c0       	breq	8000a040 <__sfvwrite_r+0x4c>
8000a04a:	e0 46 04 00 	cp.w	r6,1024
8000a04e:	ec 09 17 80 	movls	r9,r6
8000a052:	e4 09 17 b0 	movhi	r9,r2
8000a056:	06 9a       	mov	r10,r3
8000a058:	6e a8       	ld.w	r8,r7[0x28]
8000a05a:	6e 8b       	ld.w	r11,r7[0x20]
8000a05c:	0a 9c       	mov	r12,r5
8000a05e:	5d 18       	icall	r8
8000a060:	18 16       	sub	r6,r12
8000a062:	58 0c       	cp.w	r12,0
8000a064:	e0 8a 01 0a 	brle	8000a278 <__sfvwrite_r+0x284>
8000a068:	68 28       	ld.w	r8,r4[0x8]
8000a06a:	18 18       	sub	r8,r12
8000a06c:	89 28       	st.w	r4[0x8],r8
8000a06e:	e0 80 01 0a 	breq	8000a282 <__sfvwrite_r+0x28e>
8000a072:	18 03       	add	r3,r12
8000a074:	ce 9b       	rjmp	8000a046 <__sfvwrite_r+0x52>
8000a076:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a07a:	c0 70       	breq	8000a088 <__sfvwrite_r+0x94>
8000a07c:	50 06       	stdsp	sp[0x0],r6
8000a07e:	0c 93       	mov	r3,r6
8000a080:	0c 91       	mov	r1,r6
8000a082:	50 15       	stdsp	sp[0x4],r5
8000a084:	08 92       	mov	r2,r4
8000a086:	c9 c8       	rjmp	8000a1be <__sfvwrite_r+0x1ca>
8000a088:	06 96       	mov	r6,r3
8000a08a:	08 91       	mov	r1,r4
8000a08c:	c0 48       	rjmp	8000a094 <__sfvwrite_r+0xa0>
8000a08e:	60 03       	ld.w	r3,r0[0x0]
8000a090:	60 16       	ld.w	r6,r0[0x4]
8000a092:	2f 80       	sub	r0,-8
8000a094:	58 06       	cp.w	r6,0
8000a096:	cf c0       	breq	8000a08e <__sfvwrite_r+0x9a>
8000a098:	8e 68       	ld.sh	r8,r7[0xc]
8000a09a:	6e 24       	ld.w	r4,r7[0x8]
8000a09c:	10 99       	mov	r9,r8
8000a09e:	e2 19 02 00 	andl	r9,0x200,COH
8000a0a2:	c5 50       	breq	8000a14c <__sfvwrite_r+0x158>
8000a0a4:	08 36       	cp.w	r6,r4
8000a0a6:	c4 43       	brcs	8000a12e <__sfvwrite_r+0x13a>
8000a0a8:	10 99       	mov	r9,r8
8000a0aa:	e2 19 04 80 	andl	r9,0x480,COH
8000a0ae:	c4 00       	breq	8000a12e <__sfvwrite_r+0x13a>
8000a0b0:	6e 4b       	ld.w	r11,r7[0x10]
8000a0b2:	6e 09       	ld.w	r9,r7[0x0]
8000a0b4:	16 19       	sub	r9,r11
8000a0b6:	50 09       	stdsp	sp[0x0],r9
8000a0b8:	6e 59       	ld.w	r9,r7[0x14]
8000a0ba:	10 9c       	mov	r12,r8
8000a0bc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a0c0:	30 28       	mov	r8,2
8000a0c2:	f4 08 0c 08 	divs	r8,r10,r8
8000a0c6:	fa e9 00 04 	st.d	sp[4],r8
8000a0ca:	10 94       	mov	r4,r8
8000a0cc:	40 09       	lddsp	r9,sp[0x0]
8000a0ce:	e2 1c 04 00 	andl	r12,0x400,COH
8000a0d2:	2f f9       	sub	r9,-1
8000a0d4:	0c 09       	add	r9,r6
8000a0d6:	12 38       	cp.w	r8,r9
8000a0d8:	f2 04 17 30 	movlo	r4,r9
8000a0dc:	58 0c       	cp.w	r12,0
8000a0de:	c1 10       	breq	8000a100 <__sfvwrite_r+0x10c>
8000a0e0:	08 9b       	mov	r11,r4
8000a0e2:	0a 9c       	mov	r12,r5
8000a0e4:	fe b0 e0 60 	rcall	800061a4 <_malloc_r>
8000a0e8:	18 92       	mov	r2,r12
8000a0ea:	c1 40       	breq	8000a112 <__sfvwrite_r+0x11e>
8000a0ec:	40 0a       	lddsp	r10,sp[0x0]
8000a0ee:	6e 4b       	ld.w	r11,r7[0x10]
8000a0f0:	fe b0 e2 76 	rcall	800065dc <memcpy>
8000a0f4:	8e 68       	ld.sh	r8,r7[0xc]
8000a0f6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a0fa:	a7 b8       	sbr	r8,0x7
8000a0fc:	ae 68       	st.h	r7[0xc],r8
8000a0fe:	c0 d8       	rjmp	8000a118 <__sfvwrite_r+0x124>
8000a100:	08 9a       	mov	r10,r4
8000a102:	0a 9c       	mov	r12,r5
8000a104:	fe b0 e3 18 	rcall	80006734 <_realloc_r>
8000a108:	18 92       	mov	r2,r12
8000a10a:	c0 71       	brne	8000a118 <__sfvwrite_r+0x124>
8000a10c:	6e 4b       	ld.w	r11,r7[0x10]
8000a10e:	0a 9c       	mov	r12,r5
8000a110:	ca ce       	rcall	80009e68 <_free_r>
8000a112:	30 c8       	mov	r8,12
8000a114:	8b 38       	st.w	r5[0xc],r8
8000a116:	cb 18       	rjmp	8000a278 <__sfvwrite_r+0x284>
8000a118:	40 0a       	lddsp	r10,sp[0x0]
8000a11a:	40 09       	lddsp	r9,sp[0x0]
8000a11c:	e8 0a 01 0a 	sub	r10,r4,r10
8000a120:	e4 09 00 08 	add	r8,r2,r9
8000a124:	8f 54       	st.w	r7[0x14],r4
8000a126:	8f 2a       	st.w	r7[0x8],r10
8000a128:	8f 08       	st.w	r7[0x0],r8
8000a12a:	8f 42       	st.w	r7[0x10],r2
8000a12c:	0c 94       	mov	r4,r6
8000a12e:	08 36       	cp.w	r6,r4
8000a130:	ec 04 17 30 	movlo	r4,r6
8000a134:	06 9b       	mov	r11,r3
8000a136:	08 9a       	mov	r10,r4
8000a138:	6e 0c       	ld.w	r12,r7[0x0]
8000a13a:	c3 ad       	rcall	8000a3ae <memmove>
8000a13c:	6e 08       	ld.w	r8,r7[0x0]
8000a13e:	08 08       	add	r8,r4
8000a140:	8f 08       	st.w	r7[0x0],r8
8000a142:	6e 28       	ld.w	r8,r7[0x8]
8000a144:	08 18       	sub	r8,r4
8000a146:	0c 94       	mov	r4,r6
8000a148:	8f 28       	st.w	r7[0x8],r8
8000a14a:	c2 e8       	rjmp	8000a1a6 <__sfvwrite_r+0x1b2>
8000a14c:	08 36       	cp.w	r6,r4
8000a14e:	5f ba       	srhi	r10
8000a150:	6e 0c       	ld.w	r12,r7[0x0]
8000a152:	6e 48       	ld.w	r8,r7[0x10]
8000a154:	10 3c       	cp.w	r12,r8
8000a156:	5f b8       	srhi	r8
8000a158:	f5 e8 00 08 	and	r8,r10,r8
8000a15c:	f2 08 18 00 	cp.b	r8,r9
8000a160:	c0 d0       	breq	8000a17a <__sfvwrite_r+0x186>
8000a162:	06 9b       	mov	r11,r3
8000a164:	08 9a       	mov	r10,r4
8000a166:	c2 4d       	rcall	8000a3ae <memmove>
8000a168:	6e 08       	ld.w	r8,r7[0x0]
8000a16a:	08 08       	add	r8,r4
8000a16c:	0e 9b       	mov	r11,r7
8000a16e:	8f 08       	st.w	r7[0x0],r8
8000a170:	0a 9c       	mov	r12,r5
8000a172:	fe b0 fd 09 	rcall	80009b84 <_fflush_r>
8000a176:	c1 80       	breq	8000a1a6 <__sfvwrite_r+0x1b2>
8000a178:	c8 08       	rjmp	8000a278 <__sfvwrite_r+0x284>
8000a17a:	6e 59       	ld.w	r9,r7[0x14]
8000a17c:	12 36       	cp.w	r6,r9
8000a17e:	c0 a3       	brcs	8000a192 <__sfvwrite_r+0x19e>
8000a180:	6e a8       	ld.w	r8,r7[0x28]
8000a182:	06 9a       	mov	r10,r3
8000a184:	6e 8b       	ld.w	r11,r7[0x20]
8000a186:	0a 9c       	mov	r12,r5
8000a188:	5d 18       	icall	r8
8000a18a:	18 94       	mov	r4,r12
8000a18c:	e0 89 00 0d 	brgt	8000a1a6 <__sfvwrite_r+0x1b2>
8000a190:	c7 48       	rjmp	8000a278 <__sfvwrite_r+0x284>
8000a192:	0c 9a       	mov	r10,r6
8000a194:	06 9b       	mov	r11,r3
8000a196:	c0 cd       	rcall	8000a3ae <memmove>
8000a198:	6e 08       	ld.w	r8,r7[0x0]
8000a19a:	0c 08       	add	r8,r6
8000a19c:	0c 94       	mov	r4,r6
8000a19e:	8f 08       	st.w	r7[0x0],r8
8000a1a0:	6e 28       	ld.w	r8,r7[0x8]
8000a1a2:	0c 18       	sub	r8,r6
8000a1a4:	8f 28       	st.w	r7[0x8],r8
8000a1a6:	62 28       	ld.w	r8,r1[0x8]
8000a1a8:	08 18       	sub	r8,r4
8000a1aa:	83 28       	st.w	r1[0x8],r8
8000a1ac:	c6 b0       	breq	8000a282 <__sfvwrite_r+0x28e>
8000a1ae:	08 16       	sub	r6,r4
8000a1b0:	08 03       	add	r3,r4
8000a1b2:	c7 1b       	rjmp	8000a094 <__sfvwrite_r+0xa0>
8000a1b4:	60 03       	ld.w	r3,r0[0x0]
8000a1b6:	60 11       	ld.w	r1,r0[0x4]
8000a1b8:	30 08       	mov	r8,0
8000a1ba:	2f 80       	sub	r0,-8
8000a1bc:	50 08       	stdsp	sp[0x0],r8
8000a1be:	58 01       	cp.w	r1,0
8000a1c0:	cf a0       	breq	8000a1b4 <__sfvwrite_r+0x1c0>
8000a1c2:	40 0a       	lddsp	r10,sp[0x0]
8000a1c4:	58 0a       	cp.w	r10,0
8000a1c6:	c1 41       	brne	8000a1ee <__sfvwrite_r+0x1fa>
8000a1c8:	e2 c6 ff ff 	sub	r6,r1,-1
8000a1cc:	02 9a       	mov	r10,r1
8000a1ce:	30 ab       	mov	r11,10
8000a1d0:	06 9c       	mov	r12,r3
8000a1d2:	ce 3c       	rcall	8000a398 <memchr>
8000a1d4:	f8 c8 ff ff 	sub	r8,r12,-1
8000a1d8:	58 0c       	cp.w	r12,0
8000a1da:	f1 d3 e1 16 	subne	r6,r8,r3
8000a1de:	f9 b9 01 01 	movne	r9,1
8000a1e2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a1e6:	f9 b8 00 01 	moveq	r8,1
8000a1ea:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a1ee:	02 36       	cp.w	r6,r1
8000a1f0:	ec 04 17 80 	movls	r4,r6
8000a1f4:	e2 04 17 b0 	movhi	r4,r1
8000a1f8:	6e 59       	ld.w	r9,r7[0x14]
8000a1fa:	6e 25       	ld.w	r5,r7[0x8]
8000a1fc:	f2 05 00 05 	add	r5,r9,r5
8000a200:	0a 34       	cp.w	r4,r5
8000a202:	5f 9a       	srgt	r10
8000a204:	6e 0c       	ld.w	r12,r7[0x0]
8000a206:	6e 48       	ld.w	r8,r7[0x10]
8000a208:	10 3c       	cp.w	r12,r8
8000a20a:	5f b8       	srhi	r8
8000a20c:	f5 e8 00 08 	and	r8,r10,r8
8000a210:	30 0a       	mov	r10,0
8000a212:	f4 08 18 00 	cp.b	r8,r10
8000a216:	c0 d0       	breq	8000a230 <__sfvwrite_r+0x23c>
8000a218:	06 9b       	mov	r11,r3
8000a21a:	0a 9a       	mov	r10,r5
8000a21c:	cc 9c       	rcall	8000a3ae <memmove>
8000a21e:	6e 08       	ld.w	r8,r7[0x0]
8000a220:	0a 08       	add	r8,r5
8000a222:	0e 9b       	mov	r11,r7
8000a224:	8f 08       	st.w	r7[0x0],r8
8000a226:	40 1c       	lddsp	r12,sp[0x4]
8000a228:	fe b0 fc ae 	rcall	80009b84 <_fflush_r>
8000a22c:	c1 70       	breq	8000a25a <__sfvwrite_r+0x266>
8000a22e:	c2 58       	rjmp	8000a278 <__sfvwrite_r+0x284>
8000a230:	12 34       	cp.w	r4,r9
8000a232:	c0 a5       	brlt	8000a246 <__sfvwrite_r+0x252>
8000a234:	6e a8       	ld.w	r8,r7[0x28]
8000a236:	06 9a       	mov	r10,r3
8000a238:	6e 8b       	ld.w	r11,r7[0x20]
8000a23a:	40 1c       	lddsp	r12,sp[0x4]
8000a23c:	5d 18       	icall	r8
8000a23e:	18 95       	mov	r5,r12
8000a240:	e0 89 00 0d 	brgt	8000a25a <__sfvwrite_r+0x266>
8000a244:	c1 a8       	rjmp	8000a278 <__sfvwrite_r+0x284>
8000a246:	08 9a       	mov	r10,r4
8000a248:	06 9b       	mov	r11,r3
8000a24a:	cb 2c       	rcall	8000a3ae <memmove>
8000a24c:	6e 08       	ld.w	r8,r7[0x0]
8000a24e:	08 08       	add	r8,r4
8000a250:	08 95       	mov	r5,r4
8000a252:	8f 08       	st.w	r7[0x0],r8
8000a254:	6e 28       	ld.w	r8,r7[0x8]
8000a256:	08 18       	sub	r8,r4
8000a258:	8f 28       	st.w	r7[0x8],r8
8000a25a:	0a 16       	sub	r6,r5
8000a25c:	c0 71       	brne	8000a26a <__sfvwrite_r+0x276>
8000a25e:	0e 9b       	mov	r11,r7
8000a260:	40 1c       	lddsp	r12,sp[0x4]
8000a262:	fe b0 fc 91 	rcall	80009b84 <_fflush_r>
8000a266:	c0 91       	brne	8000a278 <__sfvwrite_r+0x284>
8000a268:	50 06       	stdsp	sp[0x0],r6
8000a26a:	64 28       	ld.w	r8,r2[0x8]
8000a26c:	0a 18       	sub	r8,r5
8000a26e:	85 28       	st.w	r2[0x8],r8
8000a270:	c0 90       	breq	8000a282 <__sfvwrite_r+0x28e>
8000a272:	0a 11       	sub	r1,r5
8000a274:	0a 03       	add	r3,r5
8000a276:	ca 4b       	rjmp	8000a1be <__sfvwrite_r+0x1ca>
8000a278:	8e 68       	ld.sh	r8,r7[0xc]
8000a27a:	a7 a8       	sbr	r8,0x6
8000a27c:	ae 68       	st.h	r7[0xc],r8
8000a27e:	3f fc       	mov	r12,-1
8000a280:	c0 28       	rjmp	8000a284 <__sfvwrite_r+0x290>
8000a282:	30 0c       	mov	r12,0
8000a284:	2f dd       	sub	sp,-12
8000a286:	d8 32       	popm	r0-r7,pc

8000a288 <_fwalk>:
8000a288:	d4 31       	pushm	r0-r7,lr
8000a28a:	30 05       	mov	r5,0
8000a28c:	16 91       	mov	r1,r11
8000a28e:	f8 c7 ff 28 	sub	r7,r12,-216
8000a292:	0a 92       	mov	r2,r5
8000a294:	fe b0 fc fe 	rcall	80009c90 <__sfp_lock_acquire>
8000a298:	3f f3       	mov	r3,-1
8000a29a:	c1 68       	rjmp	8000a2c6 <_fwalk+0x3e>
8000a29c:	6e 26       	ld.w	r6,r7[0x8]
8000a29e:	6e 14       	ld.w	r4,r7[0x4]
8000a2a0:	2f 46       	sub	r6,-12
8000a2a2:	c0 c8       	rjmp	8000a2ba <_fwalk+0x32>
8000a2a4:	8c 08       	ld.sh	r8,r6[0x0]
8000a2a6:	e4 08 19 00 	cp.h	r8,r2
8000a2aa:	c0 70       	breq	8000a2b8 <_fwalk+0x30>
8000a2ac:	8c 18       	ld.sh	r8,r6[0x2]
8000a2ae:	e6 08 19 00 	cp.h	r8,r3
8000a2b2:	c0 30       	breq	8000a2b8 <_fwalk+0x30>
8000a2b4:	5d 11       	icall	r1
8000a2b6:	18 45       	or	r5,r12
8000a2b8:	2a 46       	sub	r6,-92
8000a2ba:	20 14       	sub	r4,1
8000a2bc:	ec cc 00 0c 	sub	r12,r6,12
8000a2c0:	58 04       	cp.w	r4,0
8000a2c2:	cf 14       	brge	8000a2a4 <_fwalk+0x1c>
8000a2c4:	6e 07       	ld.w	r7,r7[0x0]
8000a2c6:	58 07       	cp.w	r7,0
8000a2c8:	ce a1       	brne	8000a29c <_fwalk+0x14>
8000a2ca:	fe b0 fc e4 	rcall	80009c92 <__sfp_lock_release>
8000a2ce:	0a 9c       	mov	r12,r5
8000a2d0:	d8 32       	popm	r0-r7,pc
8000a2d2:	d7 03       	nop

8000a2d4 <_localeconv_r>:
8000a2d4:	fe cc ce f0 	sub	r12,pc,-12560
8000a2d8:	5e fc       	retal	r12
8000a2da:	d7 03       	nop

8000a2dc <__smakebuf_r>:
8000a2dc:	d4 21       	pushm	r4-r7,lr
8000a2de:	20 fd       	sub	sp,60
8000a2e0:	96 68       	ld.sh	r8,r11[0xc]
8000a2e2:	16 97       	mov	r7,r11
8000a2e4:	18 96       	mov	r6,r12
8000a2e6:	e2 18 00 02 	andl	r8,0x2,COH
8000a2ea:	c3 d1       	brne	8000a364 <__smakebuf_r+0x88>
8000a2ec:	96 7b       	ld.sh	r11,r11[0xe]
8000a2ee:	f0 0b 19 00 	cp.h	r11,r8
8000a2f2:	c0 55       	brlt	8000a2fc <__smakebuf_r+0x20>
8000a2f4:	1a 9a       	mov	r10,sp
8000a2f6:	e0 a0 04 75 	rcall	8000abe0 <_fstat_r>
8000a2fa:	c0 f4       	brge	8000a318 <__smakebuf_r+0x3c>
8000a2fc:	8e 65       	ld.sh	r5,r7[0xc]
8000a2fe:	0a 98       	mov	r8,r5
8000a300:	ab b8       	sbr	r8,0xb
8000a302:	e2 15 00 80 	andl	r5,0x80,COH
8000a306:	ae 68       	st.h	r7[0xc],r8
8000a308:	30 04       	mov	r4,0
8000a30a:	e0 68 04 00 	mov	r8,1024
8000a30e:	f9 b5 01 40 	movne	r5,64
8000a312:	f0 05 17 00 	moveq	r5,r8
8000a316:	c1 c8       	rjmp	8000a34e <__smakebuf_r+0x72>
8000a318:	40 18       	lddsp	r8,sp[0x4]
8000a31a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a31e:	e0 48 20 00 	cp.w	r8,8192
8000a322:	5f 04       	sreq	r4
8000a324:	e0 48 80 00 	cp.w	r8,32768
8000a328:	c0 e1       	brne	8000a344 <__smakebuf_r+0x68>
8000a32a:	6e b9       	ld.w	r9,r7[0x2c]
8000a32c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a330:	10 39       	cp.w	r9,r8
8000a332:	c0 91       	brne	8000a344 <__smakebuf_r+0x68>
8000a334:	8e 68       	ld.sh	r8,r7[0xc]
8000a336:	e0 65 04 00 	mov	r5,1024
8000a33a:	ab a8       	sbr	r8,0xa
8000a33c:	ef 45 00 50 	st.w	r7[80],r5
8000a340:	ae 68       	st.h	r7[0xc],r8
8000a342:	c0 68       	rjmp	8000a34e <__smakebuf_r+0x72>
8000a344:	8e 68       	ld.sh	r8,r7[0xc]
8000a346:	e0 65 04 00 	mov	r5,1024
8000a34a:	ab b8       	sbr	r8,0xb
8000a34c:	ae 68       	st.h	r7[0xc],r8
8000a34e:	0a 9b       	mov	r11,r5
8000a350:	0c 9c       	mov	r12,r6
8000a352:	fe b0 df 29 	rcall	800061a4 <_malloc_r>
8000a356:	8e 68       	ld.sh	r8,r7[0xc]
8000a358:	c0 d1       	brne	8000a372 <__smakebuf_r+0x96>
8000a35a:	ed b8 00 09 	bld	r8,0x9
8000a35e:	c1 b0       	breq	8000a394 <__smakebuf_r+0xb8>
8000a360:	a1 b8       	sbr	r8,0x1
8000a362:	ae 68       	st.h	r7[0xc],r8
8000a364:	ee c8 ff b9 	sub	r8,r7,-71
8000a368:	8f 48       	st.w	r7[0x10],r8
8000a36a:	8f 08       	st.w	r7[0x0],r8
8000a36c:	30 18       	mov	r8,1
8000a36e:	8f 58       	st.w	r7[0x14],r8
8000a370:	c1 28       	rjmp	8000a394 <__smakebuf_r+0xb8>
8000a372:	a7 b8       	sbr	r8,0x7
8000a374:	8f 4c       	st.w	r7[0x10],r12
8000a376:	ae 68       	st.h	r7[0xc],r8
8000a378:	8f 55       	st.w	r7[0x14],r5
8000a37a:	fe c8 06 e6 	sub	r8,pc,1766
8000a37e:	8f 0c       	st.w	r7[0x0],r12
8000a380:	8d a8       	st.w	r6[0x28],r8
8000a382:	58 04       	cp.w	r4,0
8000a384:	c0 80       	breq	8000a394 <__smakebuf_r+0xb8>
8000a386:	8e 7c       	ld.sh	r12,r7[0xe]
8000a388:	fe b0 e3 94 	rcall	80006ab0 <isatty>
8000a38c:	c0 40       	breq	8000a394 <__smakebuf_r+0xb8>
8000a38e:	8e 68       	ld.sh	r8,r7[0xc]
8000a390:	a1 a8       	sbr	r8,0x0
8000a392:	ae 68       	st.h	r7[0xc],r8
8000a394:	2f 1d       	sub	sp,-60
8000a396:	d8 22       	popm	r4-r7,pc

8000a398 <memchr>:
8000a398:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a39c:	c0 68       	rjmp	8000a3a8 <memchr+0x10>
8000a39e:	20 1a       	sub	r10,1
8000a3a0:	19 88       	ld.ub	r8,r12[0x0]
8000a3a2:	16 38       	cp.w	r8,r11
8000a3a4:	5e 0c       	reteq	r12
8000a3a6:	2f fc       	sub	r12,-1
8000a3a8:	58 0a       	cp.w	r10,0
8000a3aa:	cf a1       	brne	8000a39e <memchr+0x6>
8000a3ac:	5e fa       	retal	r10

8000a3ae <memmove>:
8000a3ae:	d4 01       	pushm	lr
8000a3b0:	18 3b       	cp.w	r11,r12
8000a3b2:	c1 92       	brcc	8000a3e4 <memmove+0x36>
8000a3b4:	f6 0a 00 09 	add	r9,r11,r10
8000a3b8:	12 3c       	cp.w	r12,r9
8000a3ba:	c1 52       	brcc	8000a3e4 <memmove+0x36>
8000a3bc:	f8 0a 00 0b 	add	r11,r12,r10
8000a3c0:	30 08       	mov	r8,0
8000a3c2:	c0 68       	rjmp	8000a3ce <memmove+0x20>
8000a3c4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a3c8:	20 1a       	sub	r10,1
8000a3ca:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a3ce:	20 18       	sub	r8,1
8000a3d0:	58 0a       	cp.w	r10,0
8000a3d2:	cf 91       	brne	8000a3c4 <memmove+0x16>
8000a3d4:	d8 02       	popm	pc
8000a3d6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a3da:	20 1a       	sub	r10,1
8000a3dc:	f8 08 0b 09 	st.b	r12[r8],r9
8000a3e0:	2f f8       	sub	r8,-1
8000a3e2:	c0 28       	rjmp	8000a3e6 <memmove+0x38>
8000a3e4:	30 08       	mov	r8,0
8000a3e6:	58 0a       	cp.w	r10,0
8000a3e8:	cf 71       	brne	8000a3d6 <memmove+0x28>
8000a3ea:	d8 02       	popm	pc

8000a3ec <__hi0bits>:
8000a3ec:	18 98       	mov	r8,r12
8000a3ee:	e0 1c 00 00 	andl	r12,0x0
8000a3f2:	f0 09 15 10 	lsl	r9,r8,0x10
8000a3f6:	58 0c       	cp.w	r12,0
8000a3f8:	f2 08 17 00 	moveq	r8,r9
8000a3fc:	f9 bc 00 10 	moveq	r12,16
8000a400:	f9 bc 01 00 	movne	r12,0
8000a404:	10 9a       	mov	r10,r8
8000a406:	f0 09 15 08 	lsl	r9,r8,0x8
8000a40a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a40e:	f7 bc 00 f8 	subeq	r12,-8
8000a412:	f2 08 17 00 	moveq	r8,r9
8000a416:	10 9a       	mov	r10,r8
8000a418:	f0 09 15 04 	lsl	r9,r8,0x4
8000a41c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a420:	f7 bc 00 fc 	subeq	r12,-4
8000a424:	f2 08 17 00 	moveq	r8,r9
8000a428:	10 9a       	mov	r10,r8
8000a42a:	f0 09 15 02 	lsl	r9,r8,0x2
8000a42e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a432:	f7 bc 00 fe 	subeq	r12,-2
8000a436:	f2 08 17 00 	moveq	r8,r9
8000a43a:	58 08       	cp.w	r8,0
8000a43c:	5e 5c       	retlt	r12
8000a43e:	ed b8 00 1e 	bld	r8,0x1e
8000a442:	f9 bc 01 20 	movne	r12,32
8000a446:	f7 bc 00 ff 	subeq	r12,-1
8000a44a:	5e fc       	retal	r12

8000a44c <__lo0bits>:
8000a44c:	18 99       	mov	r9,r12
8000a44e:	78 08       	ld.w	r8,r12[0x0]
8000a450:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a454:	c1 50       	breq	8000a47e <__lo0bits+0x32>
8000a456:	ed b8 00 00 	bld	r8,0x0
8000a45a:	c0 21       	brne	8000a45e <__lo0bits+0x12>
8000a45c:	5e fd       	retal	0
8000a45e:	10 9b       	mov	r11,r8
8000a460:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a464:	e2 1b 00 02 	andl	r11,0x2,COH
8000a468:	a3 88       	lsr	r8,0x2
8000a46a:	58 0b       	cp.w	r11,0
8000a46c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a470:	f9 bc 01 01 	movne	r12,1
8000a474:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a478:	f9 bc 00 02 	moveq	r12,2
8000a47c:	5e fc       	retal	r12
8000a47e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a482:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a486:	58 0a       	cp.w	r10,0
8000a488:	f6 08 17 00 	moveq	r8,r11
8000a48c:	f9 bc 00 10 	moveq	r12,16
8000a490:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a494:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a498:	58 0b       	cp.w	r11,0
8000a49a:	f7 bc 00 f8 	subeq	r12,-8
8000a49e:	f4 08 17 00 	moveq	r8,r10
8000a4a2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a4a6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a4aa:	58 0b       	cp.w	r11,0
8000a4ac:	f7 bc 00 fc 	subeq	r12,-4
8000a4b0:	f4 08 17 00 	moveq	r8,r10
8000a4b4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a4b8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a4bc:	58 0b       	cp.w	r11,0
8000a4be:	f7 bc 00 fe 	subeq	r12,-2
8000a4c2:	f4 08 17 00 	moveq	r8,r10
8000a4c6:	ed b8 00 00 	bld	r8,0x0
8000a4ca:	c0 60       	breq	8000a4d6 <__lo0bits+0x8a>
8000a4cc:	a1 98       	lsr	r8,0x1
8000a4ce:	c0 31       	brne	8000a4d4 <__lo0bits+0x88>
8000a4d0:	32 0c       	mov	r12,32
8000a4d2:	5e fc       	retal	r12
8000a4d4:	2f fc       	sub	r12,-1
8000a4d6:	93 08       	st.w	r9[0x0],r8
8000a4d8:	5e fc       	retal	r12

8000a4da <__mcmp>:
8000a4da:	d4 01       	pushm	lr
8000a4dc:	18 98       	mov	r8,r12
8000a4de:	76 49       	ld.w	r9,r11[0x10]
8000a4e0:	78 4c       	ld.w	r12,r12[0x10]
8000a4e2:	12 1c       	sub	r12,r9
8000a4e4:	c1 31       	brne	8000a50a <__mcmp+0x30>
8000a4e6:	2f b9       	sub	r9,-5
8000a4e8:	a3 69       	lsl	r9,0x2
8000a4ea:	12 0b       	add	r11,r9
8000a4ec:	f0 09 00 09 	add	r9,r8,r9
8000a4f0:	2e c8       	sub	r8,-20
8000a4f2:	13 4e       	ld.w	lr,--r9
8000a4f4:	17 4a       	ld.w	r10,--r11
8000a4f6:	14 3e       	cp.w	lr,r10
8000a4f8:	c0 60       	breq	8000a504 <__mcmp+0x2a>
8000a4fa:	f9 bc 03 ff 	movlo	r12,-1
8000a4fe:	f9 bc 02 01 	movhs	r12,1
8000a502:	d8 02       	popm	pc
8000a504:	10 39       	cp.w	r9,r8
8000a506:	fe 9b ff f6 	brhi	8000a4f2 <__mcmp+0x18>
8000a50a:	d8 02       	popm	pc

8000a50c <_Bfree>:
8000a50c:	d4 21       	pushm	r4-r7,lr
8000a50e:	18 97       	mov	r7,r12
8000a510:	16 95       	mov	r5,r11
8000a512:	78 96       	ld.w	r6,r12[0x24]
8000a514:	58 06       	cp.w	r6,0
8000a516:	c0 91       	brne	8000a528 <_Bfree+0x1c>
8000a518:	31 0c       	mov	r12,16
8000a51a:	fe b0 de 3d 	rcall	80006194 <malloc>
8000a51e:	99 36       	st.w	r12[0xc],r6
8000a520:	8f 9c       	st.w	r7[0x24],r12
8000a522:	99 16       	st.w	r12[0x4],r6
8000a524:	99 26       	st.w	r12[0x8],r6
8000a526:	99 06       	st.w	r12[0x0],r6
8000a528:	58 05       	cp.w	r5,0
8000a52a:	c0 90       	breq	8000a53c <_Bfree+0x30>
8000a52c:	6a 19       	ld.w	r9,r5[0x4]
8000a52e:	6e 98       	ld.w	r8,r7[0x24]
8000a530:	70 38       	ld.w	r8,r8[0xc]
8000a532:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a536:	8b 0a       	st.w	r5[0x0],r10
8000a538:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a53c:	d8 22       	popm	r4-r7,pc
8000a53e:	d7 03       	nop

8000a540 <_Balloc>:
8000a540:	d4 21       	pushm	r4-r7,lr
8000a542:	18 97       	mov	r7,r12
8000a544:	16 96       	mov	r6,r11
8000a546:	78 95       	ld.w	r5,r12[0x24]
8000a548:	58 05       	cp.w	r5,0
8000a54a:	c0 91       	brne	8000a55c <_Balloc+0x1c>
8000a54c:	31 0c       	mov	r12,16
8000a54e:	fe b0 de 23 	rcall	80006194 <malloc>
8000a552:	99 35       	st.w	r12[0xc],r5
8000a554:	8f 9c       	st.w	r7[0x24],r12
8000a556:	99 15       	st.w	r12[0x4],r5
8000a558:	99 25       	st.w	r12[0x8],r5
8000a55a:	99 05       	st.w	r12[0x0],r5
8000a55c:	6e 95       	ld.w	r5,r7[0x24]
8000a55e:	6a 38       	ld.w	r8,r5[0xc]
8000a560:	58 08       	cp.w	r8,0
8000a562:	c0 b1       	brne	8000a578 <_Balloc+0x38>
8000a564:	31 0a       	mov	r10,16
8000a566:	30 4b       	mov	r11,4
8000a568:	0e 9c       	mov	r12,r7
8000a56a:	e0 a0 02 9b 	rcall	8000aaa0 <_calloc_r>
8000a56e:	8b 3c       	st.w	r5[0xc],r12
8000a570:	6e 98       	ld.w	r8,r7[0x24]
8000a572:	70 3c       	ld.w	r12,r8[0xc]
8000a574:	58 0c       	cp.w	r12,0
8000a576:	c1 b0       	breq	8000a5ac <_Balloc+0x6c>
8000a578:	6e 98       	ld.w	r8,r7[0x24]
8000a57a:	70 38       	ld.w	r8,r8[0xc]
8000a57c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a580:	70 0c       	ld.w	r12,r8[0x0]
8000a582:	58 0c       	cp.w	r12,0
8000a584:	c0 40       	breq	8000a58c <_Balloc+0x4c>
8000a586:	78 09       	ld.w	r9,r12[0x0]
8000a588:	91 09       	st.w	r8[0x0],r9
8000a58a:	c0 e8       	rjmp	8000a5a6 <_Balloc+0x66>
8000a58c:	0e 9c       	mov	r12,r7
8000a58e:	30 17       	mov	r7,1
8000a590:	0e 9b       	mov	r11,r7
8000a592:	ee 06 09 47 	lsl	r7,r7,r6
8000a596:	ee ca ff fb 	sub	r10,r7,-5
8000a59a:	a3 6a       	lsl	r10,0x2
8000a59c:	e0 a0 02 82 	rcall	8000aaa0 <_calloc_r>
8000a5a0:	c0 60       	breq	8000a5ac <_Balloc+0x6c>
8000a5a2:	99 16       	st.w	r12[0x4],r6
8000a5a4:	99 27       	st.w	r12[0x8],r7
8000a5a6:	30 08       	mov	r8,0
8000a5a8:	99 38       	st.w	r12[0xc],r8
8000a5aa:	99 48       	st.w	r12[0x10],r8
8000a5ac:	d8 22       	popm	r4-r7,pc
8000a5ae:	d7 03       	nop

8000a5b0 <__d2b>:
8000a5b0:	d4 31       	pushm	r0-r7,lr
8000a5b2:	20 2d       	sub	sp,8
8000a5b4:	16 93       	mov	r3,r11
8000a5b6:	12 96       	mov	r6,r9
8000a5b8:	10 95       	mov	r5,r8
8000a5ba:	14 92       	mov	r2,r10
8000a5bc:	30 1b       	mov	r11,1
8000a5be:	cc 1f       	rcall	8000a540 <_Balloc>
8000a5c0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a5c4:	50 09       	stdsp	sp[0x0],r9
8000a5c6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a5ca:	b5 a9       	sbr	r9,0x14
8000a5cc:	f0 01 16 14 	lsr	r1,r8,0x14
8000a5d0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a5d4:	18 94       	mov	r4,r12
8000a5d6:	58 02       	cp.w	r2,0
8000a5d8:	c1 d0       	breq	8000a612 <__d2b+0x62>
8000a5da:	fa cc ff f8 	sub	r12,sp,-8
8000a5de:	18 d2       	st.w	--r12,r2
8000a5e0:	c3 6f       	rcall	8000a44c <__lo0bits>
8000a5e2:	40 18       	lddsp	r8,sp[0x4]
8000a5e4:	c0 d0       	breq	8000a5fe <__d2b+0x4e>
8000a5e6:	40 09       	lddsp	r9,sp[0x0]
8000a5e8:	f8 0a 11 20 	rsub	r10,r12,32
8000a5ec:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a5f0:	f5 e8 10 08 	or	r8,r10,r8
8000a5f4:	89 58       	st.w	r4[0x14],r8
8000a5f6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a5fa:	50 09       	stdsp	sp[0x0],r9
8000a5fc:	c0 28       	rjmp	8000a600 <__d2b+0x50>
8000a5fe:	89 58       	st.w	r4[0x14],r8
8000a600:	40 08       	lddsp	r8,sp[0x0]
8000a602:	58 08       	cp.w	r8,0
8000a604:	f9 b3 01 02 	movne	r3,2
8000a608:	f9 b3 00 01 	moveq	r3,1
8000a60c:	89 68       	st.w	r4[0x18],r8
8000a60e:	89 43       	st.w	r4[0x10],r3
8000a610:	c0 88       	rjmp	8000a620 <__d2b+0x70>
8000a612:	1a 9c       	mov	r12,sp
8000a614:	c1 cf       	rcall	8000a44c <__lo0bits>
8000a616:	30 13       	mov	r3,1
8000a618:	40 08       	lddsp	r8,sp[0x0]
8000a61a:	2e 0c       	sub	r12,-32
8000a61c:	89 43       	st.w	r4[0x10],r3
8000a61e:	89 58       	st.w	r4[0x14],r8
8000a620:	58 01       	cp.w	r1,0
8000a622:	c0 90       	breq	8000a634 <__d2b+0x84>
8000a624:	e2 c1 04 33 	sub	r1,r1,1075
8000a628:	18 01       	add	r1,r12
8000a62a:	8d 01       	st.w	r6[0x0],r1
8000a62c:	f8 0c 11 35 	rsub	r12,r12,53
8000a630:	8b 0c       	st.w	r5[0x0],r12
8000a632:	c0 c8       	rjmp	8000a64a <__d2b+0x9a>
8000a634:	e6 c8 ff fc 	sub	r8,r3,-4
8000a638:	f8 cc 04 32 	sub	r12,r12,1074
8000a63c:	a5 73       	lsl	r3,0x5
8000a63e:	8d 0c       	st.w	r6[0x0],r12
8000a640:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a644:	cd 4e       	rcall	8000a3ec <__hi0bits>
8000a646:	18 13       	sub	r3,r12
8000a648:	8b 03       	st.w	r5[0x0],r3
8000a64a:	08 9c       	mov	r12,r4
8000a64c:	2f ed       	sub	sp,-8
8000a64e:	d8 32       	popm	r0-r7,pc

8000a650 <__mdiff>:
8000a650:	d4 31       	pushm	r0-r7,lr
8000a652:	74 48       	ld.w	r8,r10[0x10]
8000a654:	76 45       	ld.w	r5,r11[0x10]
8000a656:	16 97       	mov	r7,r11
8000a658:	14 96       	mov	r6,r10
8000a65a:	10 15       	sub	r5,r8
8000a65c:	c1 31       	brne	8000a682 <__mdiff+0x32>
8000a65e:	2f b8       	sub	r8,-5
8000a660:	ee ce ff ec 	sub	lr,r7,-20
8000a664:	a3 68       	lsl	r8,0x2
8000a666:	f4 08 00 0b 	add	r11,r10,r8
8000a66a:	ee 08 00 08 	add	r8,r7,r8
8000a66e:	11 4a       	ld.w	r10,--r8
8000a670:	17 49       	ld.w	r9,--r11
8000a672:	12 3a       	cp.w	r10,r9
8000a674:	c0 30       	breq	8000a67a <__mdiff+0x2a>
8000a676:	c0 e2       	brcc	8000a692 <__mdiff+0x42>
8000a678:	c0 78       	rjmp	8000a686 <__mdiff+0x36>
8000a67a:	1c 38       	cp.w	r8,lr
8000a67c:	fe 9b ff f9 	brhi	8000a66e <__mdiff+0x1e>
8000a680:	c4 98       	rjmp	8000a712 <__mdiff+0xc2>
8000a682:	58 05       	cp.w	r5,0
8000a684:	c0 64       	brge	8000a690 <__mdiff+0x40>
8000a686:	0e 98       	mov	r8,r7
8000a688:	30 15       	mov	r5,1
8000a68a:	0c 97       	mov	r7,r6
8000a68c:	10 96       	mov	r6,r8
8000a68e:	c0 28       	rjmp	8000a692 <__mdiff+0x42>
8000a690:	30 05       	mov	r5,0
8000a692:	6e 1b       	ld.w	r11,r7[0x4]
8000a694:	c5 6f       	rcall	8000a540 <_Balloc>
8000a696:	6e 49       	ld.w	r9,r7[0x10]
8000a698:	6c 44       	ld.w	r4,r6[0x10]
8000a69a:	99 35       	st.w	r12[0xc],r5
8000a69c:	2f b4       	sub	r4,-5
8000a69e:	f2 c5 ff fb 	sub	r5,r9,-5
8000a6a2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a6a6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a6aa:	2e c6       	sub	r6,-20
8000a6ac:	2e c7       	sub	r7,-20
8000a6ae:	f8 c8 ff ec 	sub	r8,r12,-20
8000a6b2:	30 0a       	mov	r10,0
8000a6b4:	0f 0e       	ld.w	lr,r7++
8000a6b6:	0d 0b       	ld.w	r11,r6++
8000a6b8:	fc 02 16 10 	lsr	r2,lr,0x10
8000a6bc:	f6 03 16 10 	lsr	r3,r11,0x10
8000a6c0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a6c4:	e4 03 01 03 	sub	r3,r2,r3
8000a6c8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a6cc:	fc 0b 01 0b 	sub	r11,lr,r11
8000a6d0:	f6 0a 00 0a 	add	r10,r11,r10
8000a6d4:	b0 1a       	st.h	r8[0x2],r10
8000a6d6:	b1 4a       	asr	r10,0x10
8000a6d8:	e6 0a 00 0a 	add	r10,r3,r10
8000a6dc:	b0 0a       	st.h	r8[0x0],r10
8000a6de:	2f c8       	sub	r8,-4
8000a6e0:	b1 4a       	asr	r10,0x10
8000a6e2:	08 36       	cp.w	r6,r4
8000a6e4:	ce 83       	brcs	8000a6b4 <__mdiff+0x64>
8000a6e6:	c0 d8       	rjmp	8000a700 <__mdiff+0xb0>
8000a6e8:	0f 0b       	ld.w	r11,r7++
8000a6ea:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a6ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a6f2:	16 0a       	add	r10,r11
8000a6f4:	b0 1a       	st.h	r8[0x2],r10
8000a6f6:	b1 4a       	asr	r10,0x10
8000a6f8:	1c 0a       	add	r10,lr
8000a6fa:	b0 0a       	st.h	r8[0x0],r10
8000a6fc:	2f c8       	sub	r8,-4
8000a6fe:	b1 4a       	asr	r10,0x10
8000a700:	0a 37       	cp.w	r7,r5
8000a702:	cf 33       	brcs	8000a6e8 <__mdiff+0x98>
8000a704:	c0 28       	rjmp	8000a708 <__mdiff+0xb8>
8000a706:	20 19       	sub	r9,1
8000a708:	11 4a       	ld.w	r10,--r8
8000a70a:	58 0a       	cp.w	r10,0
8000a70c:	cf d0       	breq	8000a706 <__mdiff+0xb6>
8000a70e:	99 49       	st.w	r12[0x10],r9
8000a710:	d8 32       	popm	r0-r7,pc
8000a712:	30 0b       	mov	r11,0
8000a714:	c1 6f       	rcall	8000a540 <_Balloc>
8000a716:	30 18       	mov	r8,1
8000a718:	99 48       	st.w	r12[0x10],r8
8000a71a:	30 08       	mov	r8,0
8000a71c:	99 58       	st.w	r12[0x14],r8
8000a71e:	d8 32       	popm	r0-r7,pc

8000a720 <__lshift>:
8000a720:	d4 31       	pushm	r0-r7,lr
8000a722:	16 97       	mov	r7,r11
8000a724:	76 46       	ld.w	r6,r11[0x10]
8000a726:	f4 02 14 05 	asr	r2,r10,0x5
8000a72a:	2f f6       	sub	r6,-1
8000a72c:	14 93       	mov	r3,r10
8000a72e:	18 94       	mov	r4,r12
8000a730:	04 06       	add	r6,r2
8000a732:	76 1b       	ld.w	r11,r11[0x4]
8000a734:	6e 28       	ld.w	r8,r7[0x8]
8000a736:	c0 38       	rjmp	8000a73c <__lshift+0x1c>
8000a738:	2f fb       	sub	r11,-1
8000a73a:	a1 78       	lsl	r8,0x1
8000a73c:	10 36       	cp.w	r6,r8
8000a73e:	fe 99 ff fd 	brgt	8000a738 <__lshift+0x18>
8000a742:	08 9c       	mov	r12,r4
8000a744:	cf ee       	rcall	8000a540 <_Balloc>
8000a746:	30 09       	mov	r9,0
8000a748:	18 95       	mov	r5,r12
8000a74a:	f8 c8 ff ec 	sub	r8,r12,-20
8000a74e:	12 9a       	mov	r10,r9
8000a750:	c0 38       	rjmp	8000a756 <__lshift+0x36>
8000a752:	10 aa       	st.w	r8++,r10
8000a754:	2f f9       	sub	r9,-1
8000a756:	04 39       	cp.w	r9,r2
8000a758:	cf d5       	brlt	8000a752 <__lshift+0x32>
8000a75a:	6e 4b       	ld.w	r11,r7[0x10]
8000a75c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a760:	2f bb       	sub	r11,-5
8000a762:	ee c9 ff ec 	sub	r9,r7,-20
8000a766:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a76a:	58 03       	cp.w	r3,0
8000a76c:	c1 30       	breq	8000a792 <__lshift+0x72>
8000a76e:	e6 0c 11 20 	rsub	r12,r3,32
8000a772:	30 0a       	mov	r10,0
8000a774:	72 02       	ld.w	r2,r9[0x0]
8000a776:	e4 03 09 42 	lsl	r2,r2,r3
8000a77a:	04 4a       	or	r10,r2
8000a77c:	10 aa       	st.w	r8++,r10
8000a77e:	13 0a       	ld.w	r10,r9++
8000a780:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a784:	16 39       	cp.w	r9,r11
8000a786:	cf 73       	brcs	8000a774 <__lshift+0x54>
8000a788:	91 0a       	st.w	r8[0x0],r10
8000a78a:	58 0a       	cp.w	r10,0
8000a78c:	c0 70       	breq	8000a79a <__lshift+0x7a>
8000a78e:	2f f6       	sub	r6,-1
8000a790:	c0 58       	rjmp	8000a79a <__lshift+0x7a>
8000a792:	13 0a       	ld.w	r10,r9++
8000a794:	10 aa       	st.w	r8++,r10
8000a796:	16 39       	cp.w	r9,r11
8000a798:	cf d3       	brcs	8000a792 <__lshift+0x72>
8000a79a:	08 9c       	mov	r12,r4
8000a79c:	20 16       	sub	r6,1
8000a79e:	0e 9b       	mov	r11,r7
8000a7a0:	8b 46       	st.w	r5[0x10],r6
8000a7a2:	cb 5e       	rcall	8000a50c <_Bfree>
8000a7a4:	0a 9c       	mov	r12,r5
8000a7a6:	d8 32       	popm	r0-r7,pc

8000a7a8 <__multiply>:
8000a7a8:	d4 31       	pushm	r0-r7,lr
8000a7aa:	20 2d       	sub	sp,8
8000a7ac:	76 49       	ld.w	r9,r11[0x10]
8000a7ae:	74 48       	ld.w	r8,r10[0x10]
8000a7b0:	16 96       	mov	r6,r11
8000a7b2:	14 95       	mov	r5,r10
8000a7b4:	10 39       	cp.w	r9,r8
8000a7b6:	ec 08 17 50 	movlt	r8,r6
8000a7ba:	ea 06 17 50 	movlt	r6,r5
8000a7be:	f0 05 17 50 	movlt	r5,r8
8000a7c2:	6c 28       	ld.w	r8,r6[0x8]
8000a7c4:	76 43       	ld.w	r3,r11[0x10]
8000a7c6:	74 42       	ld.w	r2,r10[0x10]
8000a7c8:	76 1b       	ld.w	r11,r11[0x4]
8000a7ca:	e4 03 00 07 	add	r7,r2,r3
8000a7ce:	10 37       	cp.w	r7,r8
8000a7d0:	f7 bb 09 ff 	subgt	r11,-1
8000a7d4:	cb 6e       	rcall	8000a540 <_Balloc>
8000a7d6:	ee c4 ff fb 	sub	r4,r7,-5
8000a7da:	f8 c9 ff ec 	sub	r9,r12,-20
8000a7de:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a7e2:	30 0a       	mov	r10,0
8000a7e4:	12 98       	mov	r8,r9
8000a7e6:	c0 28       	rjmp	8000a7ea <__multiply+0x42>
8000a7e8:	10 aa       	st.w	r8++,r10
8000a7ea:	08 38       	cp.w	r8,r4
8000a7ec:	cf e3       	brcs	8000a7e8 <__multiply+0x40>
8000a7ee:	2f b3       	sub	r3,-5
8000a7f0:	2f b2       	sub	r2,-5
8000a7f2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a7f6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a7fa:	ec cb ff ec 	sub	r11,r6,-20
8000a7fe:	50 12       	stdsp	sp[0x4],r2
8000a800:	ea ca ff ec 	sub	r10,r5,-20
8000a804:	c4 48       	rjmp	8000a88c <__multiply+0xe4>
8000a806:	94 95       	ld.uh	r5,r10[0x2]
8000a808:	58 05       	cp.w	r5,0
8000a80a:	c2 00       	breq	8000a84a <__multiply+0xa2>
8000a80c:	12 98       	mov	r8,r9
8000a80e:	16 96       	mov	r6,r11
8000a810:	30 0e       	mov	lr,0
8000a812:	50 09       	stdsp	sp[0x0],r9
8000a814:	0d 02       	ld.w	r2,r6++
8000a816:	e4 00 16 10 	lsr	r0,r2,0x10
8000a81a:	70 01       	ld.w	r1,r8[0x0]
8000a81c:	70 09       	ld.w	r9,r8[0x0]
8000a81e:	b1 81       	lsr	r1,0x10
8000a820:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a824:	e0 05 03 41 	mac	r1,r0,r5
8000a828:	ab 32       	mul	r2,r5
8000a82a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a82e:	00 02       	add	r2,r0
8000a830:	e4 0e 00 0e 	add	lr,r2,lr
8000a834:	b0 1e       	st.h	r8[0x2],lr
8000a836:	b1 8e       	lsr	lr,0x10
8000a838:	1c 01       	add	r1,lr
8000a83a:	b0 01       	st.h	r8[0x0],r1
8000a83c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a840:	2f c8       	sub	r8,-4
8000a842:	06 36       	cp.w	r6,r3
8000a844:	ce 83       	brcs	8000a814 <__multiply+0x6c>
8000a846:	40 09       	lddsp	r9,sp[0x0]
8000a848:	91 0e       	st.w	r8[0x0],lr
8000a84a:	94 86       	ld.uh	r6,r10[0x0]
8000a84c:	58 06       	cp.w	r6,0
8000a84e:	c1 d0       	breq	8000a888 <__multiply+0xe0>
8000a850:	72 02       	ld.w	r2,r9[0x0]
8000a852:	12 98       	mov	r8,r9
8000a854:	16 9e       	mov	lr,r11
8000a856:	30 05       	mov	r5,0
8000a858:	b0 12       	st.h	r8[0x2],r2
8000a85a:	1d 01       	ld.w	r1,lr++
8000a85c:	90 82       	ld.uh	r2,r8[0x0]
8000a85e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a862:	ad 30       	mul	r0,r6
8000a864:	e0 02 00 02 	add	r2,r0,r2
8000a868:	e4 05 00 05 	add	r5,r2,r5
8000a86c:	b0 05       	st.h	r8[0x0],r5
8000a86e:	b1 85       	lsr	r5,0x10
8000a870:	b1 81       	lsr	r1,0x10
8000a872:	2f c8       	sub	r8,-4
8000a874:	ad 31       	mul	r1,r6
8000a876:	90 92       	ld.uh	r2,r8[0x2]
8000a878:	e2 02 00 02 	add	r2,r1,r2
8000a87c:	0a 02       	add	r2,r5
8000a87e:	e4 05 16 10 	lsr	r5,r2,0x10
8000a882:	06 3e       	cp.w	lr,r3
8000a884:	ce a3       	brcs	8000a858 <__multiply+0xb0>
8000a886:	91 02       	st.w	r8[0x0],r2
8000a888:	2f ca       	sub	r10,-4
8000a88a:	2f c9       	sub	r9,-4
8000a88c:	40 18       	lddsp	r8,sp[0x4]
8000a88e:	10 3a       	cp.w	r10,r8
8000a890:	cb b3       	brcs	8000a806 <__multiply+0x5e>
8000a892:	c0 28       	rjmp	8000a896 <__multiply+0xee>
8000a894:	20 17       	sub	r7,1
8000a896:	58 07       	cp.w	r7,0
8000a898:	e0 8a 00 05 	brle	8000a8a2 <__multiply+0xfa>
8000a89c:	09 48       	ld.w	r8,--r4
8000a89e:	58 08       	cp.w	r8,0
8000a8a0:	cf a0       	breq	8000a894 <__multiply+0xec>
8000a8a2:	99 47       	st.w	r12[0x10],r7
8000a8a4:	2f ed       	sub	sp,-8
8000a8a6:	d8 32       	popm	r0-r7,pc

8000a8a8 <__i2b>:
8000a8a8:	d4 21       	pushm	r4-r7,lr
8000a8aa:	16 97       	mov	r7,r11
8000a8ac:	30 1b       	mov	r11,1
8000a8ae:	c4 9e       	rcall	8000a540 <_Balloc>
8000a8b0:	30 19       	mov	r9,1
8000a8b2:	99 57       	st.w	r12[0x14],r7
8000a8b4:	99 49       	st.w	r12[0x10],r9
8000a8b6:	d8 22       	popm	r4-r7,pc

8000a8b8 <__multadd>:
8000a8b8:	d4 31       	pushm	r0-r7,lr
8000a8ba:	30 08       	mov	r8,0
8000a8bc:	12 95       	mov	r5,r9
8000a8be:	16 97       	mov	r7,r11
8000a8c0:	18 96       	mov	r6,r12
8000a8c2:	76 44       	ld.w	r4,r11[0x10]
8000a8c4:	f6 c9 ff ec 	sub	r9,r11,-20
8000a8c8:	72 0b       	ld.w	r11,r9[0x0]
8000a8ca:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a8ce:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a8d2:	f4 0c 02 4c 	mul	r12,r10,r12
8000a8d6:	f4 0b 03 45 	mac	r5,r10,r11
8000a8da:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a8de:	b1 85       	lsr	r5,0x10
8000a8e0:	18 05       	add	r5,r12
8000a8e2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a8e6:	f8 0b 00 0b 	add	r11,r12,r11
8000a8ea:	12 ab       	st.w	r9++,r11
8000a8ec:	2f f8       	sub	r8,-1
8000a8ee:	b1 85       	lsr	r5,0x10
8000a8f0:	08 38       	cp.w	r8,r4
8000a8f2:	ce b5       	brlt	8000a8c8 <__multadd+0x10>
8000a8f4:	58 05       	cp.w	r5,0
8000a8f6:	c1 c0       	breq	8000a92e <__multadd+0x76>
8000a8f8:	6e 28       	ld.w	r8,r7[0x8]
8000a8fa:	10 34       	cp.w	r4,r8
8000a8fc:	c1 35       	brlt	8000a922 <__multadd+0x6a>
8000a8fe:	6e 1b       	ld.w	r11,r7[0x4]
8000a900:	0c 9c       	mov	r12,r6
8000a902:	2f fb       	sub	r11,-1
8000a904:	c1 ee       	rcall	8000a540 <_Balloc>
8000a906:	6e 4a       	ld.w	r10,r7[0x10]
8000a908:	ee cb ff f4 	sub	r11,r7,-12
8000a90c:	18 93       	mov	r3,r12
8000a90e:	2f ea       	sub	r10,-2
8000a910:	2f 4c       	sub	r12,-12
8000a912:	a3 6a       	lsl	r10,0x2
8000a914:	fe b0 de 64 	rcall	800065dc <memcpy>
8000a918:	0e 9b       	mov	r11,r7
8000a91a:	0c 9c       	mov	r12,r6
8000a91c:	fe b0 fd f8 	rcall	8000a50c <_Bfree>
8000a920:	06 97       	mov	r7,r3
8000a922:	e8 c8 ff ff 	sub	r8,r4,-1
8000a926:	2f b4       	sub	r4,-5
8000a928:	8f 48       	st.w	r7[0x10],r8
8000a92a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000a92e:	0e 9c       	mov	r12,r7
8000a930:	d8 32       	popm	r0-r7,pc
8000a932:	d7 03       	nop

8000a934 <__pow5mult>:
8000a934:	d4 31       	pushm	r0-r7,lr
8000a936:	14 96       	mov	r6,r10
8000a938:	18 97       	mov	r7,r12
8000a93a:	16 94       	mov	r4,r11
8000a93c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000a940:	c0 90       	breq	8000a952 <__pow5mult+0x1e>
8000a942:	20 18       	sub	r8,1
8000a944:	fe c9 d5 24 	sub	r9,pc,-10972
8000a948:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000a94c:	30 09       	mov	r9,0
8000a94e:	cb 5f       	rcall	8000a8b8 <__multadd>
8000a950:	18 94       	mov	r4,r12
8000a952:	a3 46       	asr	r6,0x2
8000a954:	c3 40       	breq	8000a9bc <__pow5mult+0x88>
8000a956:	6e 95       	ld.w	r5,r7[0x24]
8000a958:	58 05       	cp.w	r5,0
8000a95a:	c0 91       	brne	8000a96c <__pow5mult+0x38>
8000a95c:	31 0c       	mov	r12,16
8000a95e:	fe b0 dc 1b 	rcall	80006194 <malloc>
8000a962:	99 35       	st.w	r12[0xc],r5
8000a964:	8f 9c       	st.w	r7[0x24],r12
8000a966:	99 15       	st.w	r12[0x4],r5
8000a968:	99 25       	st.w	r12[0x8],r5
8000a96a:	99 05       	st.w	r12[0x0],r5
8000a96c:	6e 93       	ld.w	r3,r7[0x24]
8000a96e:	66 25       	ld.w	r5,r3[0x8]
8000a970:	58 05       	cp.w	r5,0
8000a972:	c0 c1       	brne	8000a98a <__pow5mult+0x56>
8000a974:	e0 6b 02 71 	mov	r11,625
8000a978:	0e 9c       	mov	r12,r7
8000a97a:	c9 7f       	rcall	8000a8a8 <__i2b>
8000a97c:	87 2c       	st.w	r3[0x8],r12
8000a97e:	30 08       	mov	r8,0
8000a980:	18 95       	mov	r5,r12
8000a982:	99 08       	st.w	r12[0x0],r8
8000a984:	c0 38       	rjmp	8000a98a <__pow5mult+0x56>
8000a986:	06 9c       	mov	r12,r3
8000a988:	18 95       	mov	r5,r12
8000a98a:	ed b6 00 00 	bld	r6,0x0
8000a98e:	c0 b1       	brne	8000a9a4 <__pow5mult+0x70>
8000a990:	08 9b       	mov	r11,r4
8000a992:	0a 9a       	mov	r10,r5
8000a994:	0e 9c       	mov	r12,r7
8000a996:	c0 9f       	rcall	8000a7a8 <__multiply>
8000a998:	08 9b       	mov	r11,r4
8000a99a:	18 93       	mov	r3,r12
8000a99c:	0e 9c       	mov	r12,r7
8000a99e:	06 94       	mov	r4,r3
8000a9a0:	fe b0 fd b6 	rcall	8000a50c <_Bfree>
8000a9a4:	a1 56       	asr	r6,0x1
8000a9a6:	c0 b0       	breq	8000a9bc <__pow5mult+0x88>
8000a9a8:	6a 03       	ld.w	r3,r5[0x0]
8000a9aa:	58 03       	cp.w	r3,0
8000a9ac:	ce d1       	brne	8000a986 <__pow5mult+0x52>
8000a9ae:	0a 9a       	mov	r10,r5
8000a9b0:	0a 9b       	mov	r11,r5
8000a9b2:	0e 9c       	mov	r12,r7
8000a9b4:	cf ae       	rcall	8000a7a8 <__multiply>
8000a9b6:	8b 0c       	st.w	r5[0x0],r12
8000a9b8:	99 03       	st.w	r12[0x0],r3
8000a9ba:	ce 7b       	rjmp	8000a988 <__pow5mult+0x54>
8000a9bc:	08 9c       	mov	r12,r4
8000a9be:	d8 32       	popm	r0-r7,pc

8000a9c0 <__isinfd>:
8000a9c0:	14 98       	mov	r8,r10
8000a9c2:	fc 19 7f f0 	movh	r9,0x7ff0
8000a9c6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a9ca:	f0 0b 11 00 	rsub	r11,r8,0
8000a9ce:	f7 e8 10 08 	or	r8,r11,r8
8000a9d2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000a9d6:	f2 08 01 08 	sub	r8,r9,r8
8000a9da:	f0 0c 11 00 	rsub	r12,r8,0
8000a9de:	f9 e8 10 08 	or	r8,r12,r8
8000a9e2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000a9e6:	2f fc       	sub	r12,-1
8000a9e8:	5e fc       	retal	r12

8000a9ea <__isnand>:
8000a9ea:	14 98       	mov	r8,r10
8000a9ec:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a9f0:	f0 0c 11 00 	rsub	r12,r8,0
8000a9f4:	10 4c       	or	r12,r8
8000a9f6:	fc 18 7f f0 	movh	r8,0x7ff0
8000a9fa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000a9fe:	f0 0c 01 0c 	sub	r12,r8,r12
8000aa02:	bf 9c       	lsr	r12,0x1f
8000aa04:	5e fc       	retal	r12
8000aa06:	d7 03       	nop

8000aa08 <__sclose>:
8000aa08:	d4 01       	pushm	lr
8000aa0a:	96 7b       	ld.sh	r11,r11[0xe]
8000aa0c:	c7 6c       	rcall	8000aaf8 <_close_r>
8000aa0e:	d8 02       	popm	pc

8000aa10 <__sseek>:
8000aa10:	d4 21       	pushm	r4-r7,lr
8000aa12:	16 97       	mov	r7,r11
8000aa14:	96 7b       	ld.sh	r11,r11[0xe]
8000aa16:	cf 7c       	rcall	8000ac04 <_lseek_r>
8000aa18:	8e 68       	ld.sh	r8,r7[0xc]
8000aa1a:	10 99       	mov	r9,r8
8000aa1c:	ad c8       	cbr	r8,0xc
8000aa1e:	ad a9       	sbr	r9,0xc
8000aa20:	5b fc       	cp.w	r12,-1
8000aa22:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000aa26:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000aa2a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000aa2e:	d8 22       	popm	r4-r7,pc

8000aa30 <__swrite>:
8000aa30:	d4 21       	pushm	r4-r7,lr
8000aa32:	96 68       	ld.sh	r8,r11[0xc]
8000aa34:	16 97       	mov	r7,r11
8000aa36:	14 95       	mov	r5,r10
8000aa38:	12 94       	mov	r4,r9
8000aa3a:	e2 18 01 00 	andl	r8,0x100,COH
8000aa3e:	18 96       	mov	r6,r12
8000aa40:	c0 50       	breq	8000aa4a <__swrite+0x1a>
8000aa42:	30 29       	mov	r9,2
8000aa44:	30 0a       	mov	r10,0
8000aa46:	96 7b       	ld.sh	r11,r11[0xe]
8000aa48:	cd ec       	rcall	8000ac04 <_lseek_r>
8000aa4a:	8e 68       	ld.sh	r8,r7[0xc]
8000aa4c:	ad c8       	cbr	r8,0xc
8000aa4e:	08 99       	mov	r9,r4
8000aa50:	0a 9a       	mov	r10,r5
8000aa52:	8e 7b       	ld.sh	r11,r7[0xe]
8000aa54:	0c 9c       	mov	r12,r6
8000aa56:	ae 68       	st.h	r7[0xc],r8
8000aa58:	c1 0c       	rcall	8000aa78 <_write_r>
8000aa5a:	d8 22       	popm	r4-r7,pc

8000aa5c <__sread>:
8000aa5c:	d4 21       	pushm	r4-r7,lr
8000aa5e:	16 97       	mov	r7,r11
8000aa60:	96 7b       	ld.sh	r11,r11[0xe]
8000aa62:	ce 5c       	rcall	8000ac2c <_read_r>
8000aa64:	c0 65       	brlt	8000aa70 <__sread+0x14>
8000aa66:	6f 58       	ld.w	r8,r7[0x54]
8000aa68:	18 08       	add	r8,r12
8000aa6a:	ef 48 00 54 	st.w	r7[84],r8
8000aa6e:	d8 22       	popm	r4-r7,pc
8000aa70:	8e 68       	ld.sh	r8,r7[0xc]
8000aa72:	ad c8       	cbr	r8,0xc
8000aa74:	ae 68       	st.h	r7[0xc],r8
8000aa76:	d8 22       	popm	r4-r7,pc

8000aa78 <_write_r>:
8000aa78:	d4 21       	pushm	r4-r7,lr
8000aa7a:	16 98       	mov	r8,r11
8000aa7c:	18 97       	mov	r7,r12
8000aa7e:	10 9c       	mov	r12,r8
8000aa80:	30 08       	mov	r8,0
8000aa82:	14 9b       	mov	r11,r10
8000aa84:	e0 66 41 10 	mov	r6,16656
8000aa88:	12 9a       	mov	r10,r9
8000aa8a:	8d 08       	st.w	r6[0x0],r8
8000aa8c:	fe b0 d1 24 	rcall	80004cd4 <_write>
8000aa90:	5b fc       	cp.w	r12,-1
8000aa92:	c0 51       	brne	8000aa9c <_write_r+0x24>
8000aa94:	6c 08       	ld.w	r8,r6[0x0]
8000aa96:	58 08       	cp.w	r8,0
8000aa98:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aa9c:	d8 22       	popm	r4-r7,pc
8000aa9e:	d7 03       	nop

8000aaa0 <_calloc_r>:
8000aaa0:	d4 21       	pushm	r4-r7,lr
8000aaa2:	f4 0b 02 4b 	mul	r11,r10,r11
8000aaa6:	fe b0 db 7f 	rcall	800061a4 <_malloc_r>
8000aaaa:	18 97       	mov	r7,r12
8000aaac:	c2 30       	breq	8000aaf2 <_calloc_r+0x52>
8000aaae:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000aab2:	e0 1a ff fc 	andl	r10,0xfffc
8000aab6:	20 4a       	sub	r10,4
8000aab8:	e0 4a 00 24 	cp.w	r10,36
8000aabc:	e0 8b 00 18 	brhi	8000aaec <_calloc_r+0x4c>
8000aac0:	18 98       	mov	r8,r12
8000aac2:	59 3a       	cp.w	r10,19
8000aac4:	e0 88 00 0f 	brls	8000aae2 <_calloc_r+0x42>
8000aac8:	30 09       	mov	r9,0
8000aaca:	10 a9       	st.w	r8++,r9
8000aacc:	10 a9       	st.w	r8++,r9
8000aace:	59 ba       	cp.w	r10,27
8000aad0:	e0 88 00 09 	brls	8000aae2 <_calloc_r+0x42>
8000aad4:	10 a9       	st.w	r8++,r9
8000aad6:	10 a9       	st.w	r8++,r9
8000aad8:	e0 4a 00 24 	cp.w	r10,36
8000aadc:	c0 31       	brne	8000aae2 <_calloc_r+0x42>
8000aade:	10 a9       	st.w	r8++,r9
8000aae0:	10 a9       	st.w	r8++,r9
8000aae2:	30 09       	mov	r9,0
8000aae4:	10 a9       	st.w	r8++,r9
8000aae6:	91 19       	st.w	r8[0x4],r9
8000aae8:	91 09       	st.w	r8[0x0],r9
8000aaea:	c0 48       	rjmp	8000aaf2 <_calloc_r+0x52>
8000aaec:	30 0b       	mov	r11,0
8000aaee:	fe b0 de 1b 	rcall	80006724 <memset>
8000aaf2:	0e 9c       	mov	r12,r7
8000aaf4:	d8 22       	popm	r4-r7,pc
8000aaf6:	d7 03       	nop

8000aaf8 <_close_r>:
8000aaf8:	d4 21       	pushm	r4-r7,lr
8000aafa:	30 08       	mov	r8,0
8000aafc:	18 97       	mov	r7,r12
8000aafe:	e0 66 41 10 	mov	r6,16656
8000ab02:	16 9c       	mov	r12,r11
8000ab04:	8d 08       	st.w	r6[0x0],r8
8000ab06:	fe b0 df c1 	rcall	80006a88 <_close>
8000ab0a:	5b fc       	cp.w	r12,-1
8000ab0c:	c0 51       	brne	8000ab16 <_close_r+0x1e>
8000ab0e:	6c 08       	ld.w	r8,r6[0x0]
8000ab10:	58 08       	cp.w	r8,0
8000ab12:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ab16:	d8 22       	popm	r4-r7,pc

8000ab18 <_fclose_r>:
8000ab18:	d4 21       	pushm	r4-r7,lr
8000ab1a:	18 96       	mov	r6,r12
8000ab1c:	16 97       	mov	r7,r11
8000ab1e:	58 0b       	cp.w	r11,0
8000ab20:	c0 31       	brne	8000ab26 <_fclose_r+0xe>
8000ab22:	16 95       	mov	r5,r11
8000ab24:	c5 38       	rjmp	8000abca <_fclose_r+0xb2>
8000ab26:	fe b0 f8 b5 	rcall	80009c90 <__sfp_lock_acquire>
8000ab2a:	58 06       	cp.w	r6,0
8000ab2c:	c0 70       	breq	8000ab3a <_fclose_r+0x22>
8000ab2e:	6c 68       	ld.w	r8,r6[0x18]
8000ab30:	58 08       	cp.w	r8,0
8000ab32:	c0 41       	brne	8000ab3a <_fclose_r+0x22>
8000ab34:	0c 9c       	mov	r12,r6
8000ab36:	fe b0 f8 ff 	rcall	80009d34 <__sinit>
8000ab3a:	fe c8 d7 be 	sub	r8,pc,-10306
8000ab3e:	10 37       	cp.w	r7,r8
8000ab40:	c0 31       	brne	8000ab46 <_fclose_r+0x2e>
8000ab42:	6c 07       	ld.w	r7,r6[0x0]
8000ab44:	c0 c8       	rjmp	8000ab5c <_fclose_r+0x44>
8000ab46:	fe c8 d7 aa 	sub	r8,pc,-10326
8000ab4a:	10 37       	cp.w	r7,r8
8000ab4c:	c0 31       	brne	8000ab52 <_fclose_r+0x3a>
8000ab4e:	6c 17       	ld.w	r7,r6[0x4]
8000ab50:	c0 68       	rjmp	8000ab5c <_fclose_r+0x44>
8000ab52:	fe c8 d7 96 	sub	r8,pc,-10346
8000ab56:	10 37       	cp.w	r7,r8
8000ab58:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ab5c:	8e 69       	ld.sh	r9,r7[0xc]
8000ab5e:	30 08       	mov	r8,0
8000ab60:	f0 09 19 00 	cp.h	r9,r8
8000ab64:	c0 51       	brne	8000ab6e <_fclose_r+0x56>
8000ab66:	fe b0 f8 96 	rcall	80009c92 <__sfp_lock_release>
8000ab6a:	30 05       	mov	r5,0
8000ab6c:	c2 f8       	rjmp	8000abca <_fclose_r+0xb2>
8000ab6e:	0e 9b       	mov	r11,r7
8000ab70:	0c 9c       	mov	r12,r6
8000ab72:	fe b0 f8 09 	rcall	80009b84 <_fflush_r>
8000ab76:	6e c8       	ld.w	r8,r7[0x30]
8000ab78:	18 95       	mov	r5,r12
8000ab7a:	58 08       	cp.w	r8,0
8000ab7c:	c0 60       	breq	8000ab88 <_fclose_r+0x70>
8000ab7e:	6e 8b       	ld.w	r11,r7[0x20]
8000ab80:	0c 9c       	mov	r12,r6
8000ab82:	5d 18       	icall	r8
8000ab84:	f9 b5 05 ff 	movlt	r5,-1
8000ab88:	8e 68       	ld.sh	r8,r7[0xc]
8000ab8a:	ed b8 00 07 	bld	r8,0x7
8000ab8e:	c0 51       	brne	8000ab98 <_fclose_r+0x80>
8000ab90:	6e 4b       	ld.w	r11,r7[0x10]
8000ab92:	0c 9c       	mov	r12,r6
8000ab94:	fe b0 f9 6a 	rcall	80009e68 <_free_r>
8000ab98:	6e db       	ld.w	r11,r7[0x34]
8000ab9a:	58 0b       	cp.w	r11,0
8000ab9c:	c0 a0       	breq	8000abb0 <_fclose_r+0x98>
8000ab9e:	ee c8 ff bc 	sub	r8,r7,-68
8000aba2:	10 3b       	cp.w	r11,r8
8000aba4:	c0 40       	breq	8000abac <_fclose_r+0x94>
8000aba6:	0c 9c       	mov	r12,r6
8000aba8:	fe b0 f9 60 	rcall	80009e68 <_free_r>
8000abac:	30 08       	mov	r8,0
8000abae:	8f d8       	st.w	r7[0x34],r8
8000abb0:	6f 2b       	ld.w	r11,r7[0x48]
8000abb2:	58 0b       	cp.w	r11,0
8000abb4:	c0 70       	breq	8000abc2 <_fclose_r+0xaa>
8000abb6:	0c 9c       	mov	r12,r6
8000abb8:	fe b0 f9 58 	rcall	80009e68 <_free_r>
8000abbc:	30 08       	mov	r8,0
8000abbe:	ef 48 00 48 	st.w	r7[72],r8
8000abc2:	30 08       	mov	r8,0
8000abc4:	ae 68       	st.h	r7[0xc],r8
8000abc6:	fe b0 f8 66 	rcall	80009c92 <__sfp_lock_release>
8000abca:	0a 9c       	mov	r12,r5
8000abcc:	d8 22       	popm	r4-r7,pc
8000abce:	d7 03       	nop

8000abd0 <fclose>:
8000abd0:	d4 01       	pushm	lr
8000abd2:	e0 68 0a 38 	mov	r8,2616
8000abd6:	18 9b       	mov	r11,r12
8000abd8:	70 0c       	ld.w	r12,r8[0x0]
8000abda:	c9 ff       	rcall	8000ab18 <_fclose_r>
8000abdc:	d8 02       	popm	pc
8000abde:	d7 03       	nop

8000abe0 <_fstat_r>:
8000abe0:	d4 21       	pushm	r4-r7,lr
8000abe2:	16 98       	mov	r8,r11
8000abe4:	18 97       	mov	r7,r12
8000abe6:	10 9c       	mov	r12,r8
8000abe8:	30 08       	mov	r8,0
8000abea:	e0 66 41 10 	mov	r6,16656
8000abee:	14 9b       	mov	r11,r10
8000abf0:	8d 08       	st.w	r6[0x0],r8
8000abf2:	fe b0 df 73 	rcall	80006ad8 <_fstat>
8000abf6:	5b fc       	cp.w	r12,-1
8000abf8:	c0 51       	brne	8000ac02 <_fstat_r+0x22>
8000abfa:	6c 08       	ld.w	r8,r6[0x0]
8000abfc:	58 08       	cp.w	r8,0
8000abfe:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ac02:	d8 22       	popm	r4-r7,pc

8000ac04 <_lseek_r>:
8000ac04:	d4 21       	pushm	r4-r7,lr
8000ac06:	16 98       	mov	r8,r11
8000ac08:	18 97       	mov	r7,r12
8000ac0a:	10 9c       	mov	r12,r8
8000ac0c:	30 08       	mov	r8,0
8000ac0e:	14 9b       	mov	r11,r10
8000ac10:	e0 66 41 10 	mov	r6,16656
8000ac14:	12 9a       	mov	r10,r9
8000ac16:	8d 08       	st.w	r6[0x0],r8
8000ac18:	fe b0 df 42 	rcall	80006a9c <_lseek>
8000ac1c:	5b fc       	cp.w	r12,-1
8000ac1e:	c0 51       	brne	8000ac28 <_lseek_r+0x24>
8000ac20:	6c 08       	ld.w	r8,r6[0x0]
8000ac22:	58 08       	cp.w	r8,0
8000ac24:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ac28:	d8 22       	popm	r4-r7,pc
8000ac2a:	d7 03       	nop

8000ac2c <_read_r>:
8000ac2c:	d4 21       	pushm	r4-r7,lr
8000ac2e:	16 98       	mov	r8,r11
8000ac30:	18 97       	mov	r7,r12
8000ac32:	10 9c       	mov	r12,r8
8000ac34:	30 08       	mov	r8,0
8000ac36:	14 9b       	mov	r11,r10
8000ac38:	e0 66 41 10 	mov	r6,16656
8000ac3c:	12 9a       	mov	r10,r9
8000ac3e:	8d 08       	st.w	r6[0x0],r8
8000ac40:	fe b0 d0 2a 	rcall	80004c94 <_read>
8000ac44:	5b fc       	cp.w	r12,-1
8000ac46:	c0 51       	brne	8000ac50 <_read_r+0x24>
8000ac48:	6c 08       	ld.w	r8,r6[0x0]
8000ac4a:	58 08       	cp.w	r8,0
8000ac4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ac50:	d8 22       	popm	r4-r7,pc
8000ac52:	d7 03       	nop

8000ac54 <__avr32_f64_mul>:
8000ac54:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ac58:	e0 80 00 dc 	breq	8000ae10 <__avr32_f64_mul_op1_zero>
8000ac5c:	d4 21       	pushm	r4-r7,lr
8000ac5e:	f7 e9 20 0e 	eor	lr,r11,r9
8000ac62:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ac66:	30 15       	mov	r5,1
8000ac68:	c4 30       	breq	8000acee <__avr32_f64_mul_op1_subnormal>
8000ac6a:	ab 6b       	lsl	r11,0xa
8000ac6c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ac70:	ab 6a       	lsl	r10,0xa
8000ac72:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ac76:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ac7a:	c5 c0       	breq	8000ad32 <__avr32_f64_mul_op2_subnormal>
8000ac7c:	a1 78       	lsl	r8,0x1
8000ac7e:	5c f9       	rol	r9
8000ac80:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ac84:	e0 47 07 ff 	cp.w	r7,2047
8000ac88:	c7 70       	breq	8000ad76 <__avr32_f64_mul_op_nan_or_inf>
8000ac8a:	e0 46 07 ff 	cp.w	r6,2047
8000ac8e:	c7 40       	breq	8000ad76 <__avr32_f64_mul_op_nan_or_inf>
8000ac90:	ee 06 00 0c 	add	r12,r7,r6
8000ac94:	e0 2c 03 fe 	sub	r12,1022
8000ac98:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ac9c:	f4 09 07 44 	macu.d	r4,r10,r9
8000aca0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000aca4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000aca8:	08 07       	add	r7,r4
8000acaa:	f4 05 00 4a 	adc	r10,r10,r5
8000acae:	5c 0b       	acr	r11
8000acb0:	ed bb 00 14 	bld	r11,0x14
8000acb4:	c0 50       	breq	8000acbe <__avr32_f64_mul+0x6a>
8000acb6:	a1 77       	lsl	r7,0x1
8000acb8:	5c fa       	rol	r10
8000acba:	5c fb       	rol	r11
8000acbc:	20 1c       	sub	r12,1
8000acbe:	58 0c       	cp.w	r12,0
8000acc0:	e0 8a 00 6f 	brle	8000ad9e <__avr32_f64_mul_res_subnormal>
8000acc4:	e0 4c 07 ff 	cp.w	r12,2047
8000acc8:	e0 84 00 9c 	brge	8000ae00 <__avr32_f64_mul_res_inf>
8000accc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000acd0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000acd4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000acd8:	ee 17 80 00 	eorh	r7,0x8000
8000acdc:	f1 b7 04 20 	satu	r7,0x1
8000ace0:	0e 0a       	add	r10,r7
8000ace2:	5c 0b       	acr	r11
8000ace4:	ed be 00 1f 	bld	lr,0x1f
8000ace8:	ef bb 00 1f 	bst	r11,0x1f
8000acec:	d8 22       	popm	r4-r7,pc

8000acee <__avr32_f64_mul_op1_subnormal>:
8000acee:	e4 1b 00 0f 	andh	r11,0xf
8000acf2:	f4 0c 12 00 	clz	r12,r10
8000acf6:	f6 06 12 00 	clz	r6,r11
8000acfa:	f7 bc 03 e1 	sublo	r12,-31
8000acfe:	f8 06 17 30 	movlo	r6,r12
8000ad02:	f7 b6 02 01 	subhs	r6,1
8000ad06:	e0 46 00 20 	cp.w	r6,32
8000ad0a:	c0 d4       	brge	8000ad24 <__avr32_f64_mul_op1_subnormal+0x36>
8000ad0c:	ec 0c 11 20 	rsub	r12,r6,32
8000ad10:	f6 06 09 4b 	lsl	r11,r11,r6
8000ad14:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ad18:	18 4b       	or	r11,r12
8000ad1a:	f4 06 09 4a 	lsl	r10,r10,r6
8000ad1e:	20 b6       	sub	r6,11
8000ad20:	0c 17       	sub	r7,r6
8000ad22:	ca ab       	rjmp	8000ac76 <__avr32_f64_mul+0x22>
8000ad24:	f4 06 09 4b 	lsl	r11,r10,r6
8000ad28:	c6 40       	breq	8000adf0 <__avr32_f64_mul_res_zero>
8000ad2a:	30 0a       	mov	r10,0
8000ad2c:	20 b6       	sub	r6,11
8000ad2e:	0c 17       	sub	r7,r6
8000ad30:	ca 3b       	rjmp	8000ac76 <__avr32_f64_mul+0x22>

8000ad32 <__avr32_f64_mul_op2_subnormal>:
8000ad32:	e4 19 00 0f 	andh	r9,0xf
8000ad36:	f0 0c 12 00 	clz	r12,r8
8000ad3a:	f2 05 12 00 	clz	r5,r9
8000ad3e:	f7 bc 03 ea 	sublo	r12,-22
8000ad42:	f8 05 17 30 	movlo	r5,r12
8000ad46:	f7 b5 02 0a 	subhs	r5,10
8000ad4a:	e0 45 00 20 	cp.w	r5,32
8000ad4e:	c0 d4       	brge	8000ad68 <__avr32_f64_mul_op2_subnormal+0x36>
8000ad50:	ea 0c 11 20 	rsub	r12,r5,32
8000ad54:	f2 05 09 49 	lsl	r9,r9,r5
8000ad58:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ad5c:	18 49       	or	r9,r12
8000ad5e:	f0 05 09 48 	lsl	r8,r8,r5
8000ad62:	20 25       	sub	r5,2
8000ad64:	0a 16       	sub	r6,r5
8000ad66:	c8 fb       	rjmp	8000ac84 <__avr32_f64_mul+0x30>
8000ad68:	f0 05 09 49 	lsl	r9,r8,r5
8000ad6c:	c4 20       	breq	8000adf0 <__avr32_f64_mul_res_zero>
8000ad6e:	30 08       	mov	r8,0
8000ad70:	20 25       	sub	r5,2
8000ad72:	0a 16       	sub	r6,r5
8000ad74:	c8 8b       	rjmp	8000ac84 <__avr32_f64_mul+0x30>

8000ad76 <__avr32_f64_mul_op_nan_or_inf>:
8000ad76:	e4 19 00 0f 	andh	r9,0xf
8000ad7a:	e4 1b 00 0f 	andh	r11,0xf
8000ad7e:	14 4b       	or	r11,r10
8000ad80:	10 49       	or	r9,r8
8000ad82:	e0 47 07 ff 	cp.w	r7,2047
8000ad86:	c0 91       	brne	8000ad98 <__avr32_f64_mul_op1_not_naninf>
8000ad88:	58 0b       	cp.w	r11,0
8000ad8a:	c3 81       	brne	8000adfa <__avr32_f64_mul_res_nan>
8000ad8c:	e0 46 07 ff 	cp.w	r6,2047
8000ad90:	c3 81       	brne	8000ae00 <__avr32_f64_mul_res_inf>
8000ad92:	58 09       	cp.w	r9,0
8000ad94:	c3 60       	breq	8000ae00 <__avr32_f64_mul_res_inf>
8000ad96:	c3 28       	rjmp	8000adfa <__avr32_f64_mul_res_nan>

8000ad98 <__avr32_f64_mul_op1_not_naninf>:
8000ad98:	58 09       	cp.w	r9,0
8000ad9a:	c3 30       	breq	8000ae00 <__avr32_f64_mul_res_inf>
8000ad9c:	c2 f8       	rjmp	8000adfa <__avr32_f64_mul_res_nan>

8000ad9e <__avr32_f64_mul_res_subnormal>:
8000ad9e:	5c 3c       	neg	r12
8000ada0:	2f fc       	sub	r12,-1
8000ada2:	f1 bc 04 c0 	satu	r12,0x6
8000ada6:	e0 4c 00 20 	cp.w	r12,32
8000adaa:	c1 14       	brge	8000adcc <__avr32_f64_mul_res_subnormal+0x2e>
8000adac:	f8 08 11 20 	rsub	r8,r12,32
8000adb0:	0e 46       	or	r6,r7
8000adb2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000adb6:	f4 08 09 49 	lsl	r9,r10,r8
8000adba:	12 47       	or	r7,r9
8000adbc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000adc0:	f6 08 09 49 	lsl	r9,r11,r8
8000adc4:	12 4a       	or	r10,r9
8000adc6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000adca:	c8 3b       	rjmp	8000acd0 <__avr32_f64_mul+0x7c>
8000adcc:	f8 08 11 20 	rsub	r8,r12,32
8000add0:	f9 b9 00 00 	moveq	r9,0
8000add4:	c0 30       	breq	8000adda <__avr32_f64_mul_res_subnormal+0x3c>
8000add6:	f6 08 09 49 	lsl	r9,r11,r8
8000adda:	0e 46       	or	r6,r7
8000addc:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ade0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ade4:	f3 ea 10 07 	or	r7,r9,r10
8000ade8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000adec:	30 0b       	mov	r11,0
8000adee:	c7 1b       	rjmp	8000acd0 <__avr32_f64_mul+0x7c>

8000adf0 <__avr32_f64_mul_res_zero>:
8000adf0:	1c 9b       	mov	r11,lr
8000adf2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000adf6:	30 0a       	mov	r10,0
8000adf8:	d8 22       	popm	r4-r7,pc

8000adfa <__avr32_f64_mul_res_nan>:
8000adfa:	3f fb       	mov	r11,-1
8000adfc:	3f fa       	mov	r10,-1
8000adfe:	d8 22       	popm	r4-r7,pc

8000ae00 <__avr32_f64_mul_res_inf>:
8000ae00:	f0 6b 00 00 	mov	r11,-1048576
8000ae04:	ed be 00 1f 	bld	lr,0x1f
8000ae08:	ef bb 00 1f 	bst	r11,0x1f
8000ae0c:	30 0a       	mov	r10,0
8000ae0e:	d8 22       	popm	r4-r7,pc

8000ae10 <__avr32_f64_mul_op1_zero>:
8000ae10:	f7 e9 20 0b 	eor	r11,r11,r9
8000ae14:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ae18:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ae1c:	e0 4c 07 ff 	cp.w	r12,2047
8000ae20:	5e 1c       	retne	r12
8000ae22:	3f fa       	mov	r10,-1
8000ae24:	3f fb       	mov	r11,-1
8000ae26:	5e fc       	retal	r12

8000ae28 <__avr32_f64_sub_from_add>:
8000ae28:	ee 19 80 00 	eorh	r9,0x8000

8000ae2c <__avr32_f64_sub>:
8000ae2c:	f7 e9 20 0c 	eor	r12,r11,r9
8000ae30:	e0 86 00 ca 	brmi	8000afc4 <__avr32_f64_add_from_sub>
8000ae34:	eb cd 40 e0 	pushm	r5-r7,lr
8000ae38:	16 9c       	mov	r12,r11
8000ae3a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ae3e:	bf db       	cbr	r11,0x1f
8000ae40:	bf d9       	cbr	r9,0x1f
8000ae42:	10 3a       	cp.w	r10,r8
8000ae44:	f2 0b 13 00 	cpc	r11,r9
8000ae48:	c0 92       	brcc	8000ae5a <__avr32_f64_sub+0x2e>
8000ae4a:	16 97       	mov	r7,r11
8000ae4c:	12 9b       	mov	r11,r9
8000ae4e:	0e 99       	mov	r9,r7
8000ae50:	14 97       	mov	r7,r10
8000ae52:	10 9a       	mov	r10,r8
8000ae54:	0e 98       	mov	r8,r7
8000ae56:	ee 1c 80 00 	eorh	r12,0x8000
8000ae5a:	f6 07 16 14 	lsr	r7,r11,0x14
8000ae5e:	ab 7b       	lsl	r11,0xb
8000ae60:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ae64:	ab 7a       	lsl	r10,0xb
8000ae66:	bf bb       	sbr	r11,0x1f
8000ae68:	f2 06 16 14 	lsr	r6,r9,0x14
8000ae6c:	c4 40       	breq	8000aef4 <__avr32_f64_sub_opL_subnormal>
8000ae6e:	ab 79       	lsl	r9,0xb
8000ae70:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ae74:	ab 78       	lsl	r8,0xb
8000ae76:	bf b9       	sbr	r9,0x1f

8000ae78 <__avr32_f64_sub_opL_subnormal_done>:
8000ae78:	e0 47 07 ff 	cp.w	r7,2047
8000ae7c:	c4 f0       	breq	8000af1a <__avr32_f64_sub_opH_nan_or_inf>
8000ae7e:	0e 26       	rsub	r6,r7
8000ae80:	c1 20       	breq	8000aea4 <__avr32_f64_sub_shift_done>
8000ae82:	ec 05 11 20 	rsub	r5,r6,32
8000ae86:	e0 46 00 20 	cp.w	r6,32
8000ae8a:	c7 c2       	brcc	8000af82 <__avr32_f64_sub_longshift>
8000ae8c:	f0 05 09 4e 	lsl	lr,r8,r5
8000ae90:	f2 05 09 45 	lsl	r5,r9,r5
8000ae94:	f0 06 0a 48 	lsr	r8,r8,r6
8000ae98:	f2 06 0a 49 	lsr	r9,r9,r6
8000ae9c:	0a 48       	or	r8,r5
8000ae9e:	58 0e       	cp.w	lr,0
8000aea0:	5f 1e       	srne	lr
8000aea2:	1c 48       	or	r8,lr

8000aea4 <__avr32_f64_sub_shift_done>:
8000aea4:	10 1a       	sub	r10,r8
8000aea6:	f6 09 01 4b 	sbc	r11,r11,r9
8000aeaa:	f6 06 12 00 	clz	r6,r11
8000aeae:	c0 e0       	breq	8000aeca <__avr32_f64_sub_longnormalize_done>
8000aeb0:	c7 83       	brcs	8000afa0 <__avr32_f64_sub_longnormalize>
8000aeb2:	ec 0e 11 20 	rsub	lr,r6,32
8000aeb6:	f6 06 09 4b 	lsl	r11,r11,r6
8000aeba:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000aebe:	1c 4b       	or	r11,lr
8000aec0:	f4 06 09 4a 	lsl	r10,r10,r6
8000aec4:	0c 17       	sub	r7,r6
8000aec6:	e0 8a 00 39 	brle	8000af38 <__avr32_f64_sub_subnormal_result>

8000aeca <__avr32_f64_sub_longnormalize_done>:
8000aeca:	f4 09 15 15 	lsl	r9,r10,0x15
8000aece:	ab 9a       	lsr	r10,0xb
8000aed0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000aed4:	ab 9b       	lsr	r11,0xb
8000aed6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000aeda:	18 4b       	or	r11,r12

8000aedc <__avr32_f64_sub_round>:
8000aedc:	fc 17 80 00 	movh	r7,0x8000
8000aee0:	ed ba 00 00 	bld	r10,0x0
8000aee4:	f7 b7 01 ff 	subne	r7,-1
8000aee8:	0e 39       	cp.w	r9,r7
8000aeea:	5f 29       	srhs	r9
8000aeec:	12 0a       	add	r10,r9
8000aeee:	5c 0b       	acr	r11
8000aef0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000aef4 <__avr32_f64_sub_opL_subnormal>:
8000aef4:	ab 79       	lsl	r9,0xb
8000aef6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000aefa:	ab 78       	lsl	r8,0xb
8000aefc:	f3 e8 10 0e 	or	lr,r9,r8
8000af00:	f9 b6 01 01 	movne	r6,1
8000af04:	ee 0e 11 00 	rsub	lr,r7,0
8000af08:	f9 b7 00 01 	moveq	r7,1
8000af0c:	ef bb 00 1f 	bst	r11,0x1f
8000af10:	f7 ea 10 0e 	or	lr,r11,r10
8000af14:	f9 b7 00 00 	moveq	r7,0
8000af18:	cb 0b       	rjmp	8000ae78 <__avr32_f64_sub_opL_subnormal_done>

8000af1a <__avr32_f64_sub_opH_nan_or_inf>:
8000af1a:	bf db       	cbr	r11,0x1f
8000af1c:	f7 ea 10 0e 	or	lr,r11,r10
8000af20:	c0 81       	brne	8000af30 <__avr32_f64_sub_return_nan>
8000af22:	e0 46 07 ff 	cp.w	r6,2047
8000af26:	c0 50       	breq	8000af30 <__avr32_f64_sub_return_nan>
8000af28:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000af2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af30 <__avr32_f64_sub_return_nan>:
8000af30:	3f fa       	mov	r10,-1
8000af32:	3f fb       	mov	r11,-1
8000af34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af38 <__avr32_f64_sub_subnormal_result>:
8000af38:	5c 37       	neg	r7
8000af3a:	2f f7       	sub	r7,-1
8000af3c:	f1 b7 04 c0 	satu	r7,0x6
8000af40:	e0 47 00 20 	cp.w	r7,32
8000af44:	c1 14       	brge	8000af66 <__avr32_f64_sub_subnormal_result+0x2e>
8000af46:	ee 08 11 20 	rsub	r8,r7,32
8000af4a:	f4 08 09 49 	lsl	r9,r10,r8
8000af4e:	5f 16       	srne	r6
8000af50:	f4 07 0a 4a 	lsr	r10,r10,r7
8000af54:	0c 4a       	or	r10,r6
8000af56:	f6 08 09 49 	lsl	r9,r11,r8
8000af5a:	f5 e9 10 0a 	or	r10,r10,r9
8000af5e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000af62:	30 07       	mov	r7,0
8000af64:	cb 3b       	rjmp	8000aeca <__avr32_f64_sub_longnormalize_done>
8000af66:	ee 08 11 40 	rsub	r8,r7,64
8000af6a:	f6 08 09 49 	lsl	r9,r11,r8
8000af6e:	14 49       	or	r9,r10
8000af70:	5f 16       	srne	r6
8000af72:	f6 07 0a 4a 	lsr	r10,r11,r7
8000af76:	0c 4a       	or	r10,r6
8000af78:	30 0b       	mov	r11,0
8000af7a:	30 07       	mov	r7,0
8000af7c:	ca 7b       	rjmp	8000aeca <__avr32_f64_sub_longnormalize_done>
8000af7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af82 <__avr32_f64_sub_longshift>:
8000af82:	f1 b6 04 c0 	satu	r6,0x6
8000af86:	f0 0e 17 00 	moveq	lr,r8
8000af8a:	c0 40       	breq	8000af92 <__avr32_f64_sub_longshift+0x10>
8000af8c:	f2 05 09 4e 	lsl	lr,r9,r5
8000af90:	10 4e       	or	lr,r8
8000af92:	f2 06 0a 48 	lsr	r8,r9,r6
8000af96:	30 09       	mov	r9,0
8000af98:	58 0e       	cp.w	lr,0
8000af9a:	5f 1e       	srne	lr
8000af9c:	1c 48       	or	r8,lr
8000af9e:	c8 3b       	rjmp	8000aea4 <__avr32_f64_sub_shift_done>

8000afa0 <__avr32_f64_sub_longnormalize>:
8000afa0:	f4 06 12 00 	clz	r6,r10
8000afa4:	f9 b7 03 00 	movlo	r7,0
8000afa8:	f9 b6 03 00 	movlo	r6,0
8000afac:	f9 bc 03 00 	movlo	r12,0
8000afb0:	f7 b6 02 e0 	subhs	r6,-32
8000afb4:	f4 06 09 4b 	lsl	r11,r10,r6
8000afb8:	30 0a       	mov	r10,0
8000afba:	0c 17       	sub	r7,r6
8000afbc:	fe 9a ff be 	brle	8000af38 <__avr32_f64_sub_subnormal_result>
8000afc0:	c8 5b       	rjmp	8000aeca <__avr32_f64_sub_longnormalize_done>
8000afc2:	d7 03       	nop

8000afc4 <__avr32_f64_add_from_sub>:
8000afc4:	ee 19 80 00 	eorh	r9,0x8000

8000afc8 <__avr32_f64_add>:
8000afc8:	f7 e9 20 0c 	eor	r12,r11,r9
8000afcc:	fe 96 ff 2e 	brmi	8000ae28 <__avr32_f64_sub_from_add>
8000afd0:	eb cd 40 e0 	pushm	r5-r7,lr
8000afd4:	16 9c       	mov	r12,r11
8000afd6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000afda:	bf db       	cbr	r11,0x1f
8000afdc:	bf d9       	cbr	r9,0x1f
8000afde:	12 3b       	cp.w	r11,r9
8000afe0:	c0 72       	brcc	8000afee <__avr32_f64_add+0x26>
8000afe2:	16 97       	mov	r7,r11
8000afe4:	12 9b       	mov	r11,r9
8000afe6:	0e 99       	mov	r9,r7
8000afe8:	14 97       	mov	r7,r10
8000afea:	10 9a       	mov	r10,r8
8000afec:	0e 98       	mov	r8,r7
8000afee:	30 0e       	mov	lr,0
8000aff0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000aff4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000aff8:	b5 ab       	sbr	r11,0x14
8000affa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000affe:	c6 20       	breq	8000b0c2 <__avr32_f64_add_op2_subnormal>
8000b000:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b004:	b5 a9       	sbr	r9,0x14
8000b006:	e0 47 07 ff 	cp.w	r7,2047
8000b00a:	c2 80       	breq	8000b05a <__avr32_f64_add_opH_nan_or_inf>
8000b00c:	0e 26       	rsub	r6,r7
8000b00e:	c1 20       	breq	8000b032 <__avr32_f64_add_shift_done>
8000b010:	e0 46 00 36 	cp.w	r6,54
8000b014:	c1 52       	brcc	8000b03e <__avr32_f64_add_res_of_done>
8000b016:	ec 05 11 20 	rsub	r5,r6,32
8000b01a:	e0 46 00 20 	cp.w	r6,32
8000b01e:	c3 52       	brcc	8000b088 <__avr32_f64_add_longshift>
8000b020:	f0 05 09 4e 	lsl	lr,r8,r5
8000b024:	f2 05 09 45 	lsl	r5,r9,r5
8000b028:	f0 06 0a 48 	lsr	r8,r8,r6
8000b02c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b030:	0a 48       	or	r8,r5

8000b032 <__avr32_f64_add_shift_done>:
8000b032:	10 0a       	add	r10,r8
8000b034:	f6 09 00 4b 	adc	r11,r11,r9
8000b038:	ed bb 00 15 	bld	r11,0x15
8000b03c:	c3 40       	breq	8000b0a4 <__avr32_f64_add_res_of>

8000b03e <__avr32_f64_add_res_of_done>:
8000b03e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b042:	18 4b       	or	r11,r12

8000b044 <__avr32_f64_add_round>:
8000b044:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b048:	18 4e       	or	lr,r12
8000b04a:	ee 1e 80 00 	eorh	lr,0x8000
8000b04e:	f1 be 04 20 	satu	lr,0x1
8000b052:	1c 0a       	add	r10,lr
8000b054:	5c 0b       	acr	r11
8000b056:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b05a <__avr32_f64_add_opH_nan_or_inf>:
8000b05a:	b5 cb       	cbr	r11,0x14
8000b05c:	f7 ea 10 0e 	or	lr,r11,r10
8000b060:	c1 01       	brne	8000b080 <__avr32_f64_add_return_nan>
8000b062:	e0 46 07 ff 	cp.w	r6,2047
8000b066:	c0 30       	breq	8000b06c <__avr32_f64_add_opL_nan_or_inf>
8000b068:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b06c <__avr32_f64_add_opL_nan_or_inf>:
8000b06c:	b5 c9       	cbr	r9,0x14
8000b06e:	f3 e8 10 0e 	or	lr,r9,r8
8000b072:	c0 71       	brne	8000b080 <__avr32_f64_add_return_nan>
8000b074:	30 0a       	mov	r10,0
8000b076:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b07a:	18 4b       	or	r11,r12
8000b07c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b080 <__avr32_f64_add_return_nan>:
8000b080:	3f fa       	mov	r10,-1
8000b082:	3f fb       	mov	r11,-1
8000b084:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b088 <__avr32_f64_add_longshift>:
8000b088:	f1 b6 04 c0 	satu	r6,0x6
8000b08c:	f0 0e 17 00 	moveq	lr,r8
8000b090:	c0 60       	breq	8000b09c <__avr32_f64_add_longshift+0x14>
8000b092:	f2 05 09 4e 	lsl	lr,r9,r5
8000b096:	58 08       	cp.w	r8,0
8000b098:	5f 18       	srne	r8
8000b09a:	10 4e       	or	lr,r8
8000b09c:	f2 06 0a 48 	lsr	r8,r9,r6
8000b0a0:	30 09       	mov	r9,0
8000b0a2:	cc 8b       	rjmp	8000b032 <__avr32_f64_add_shift_done>

8000b0a4 <__avr32_f64_add_res_of>:
8000b0a4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b0a8:	a1 9b       	lsr	r11,0x1
8000b0aa:	5d 0a       	ror	r10
8000b0ac:	5d 0e       	ror	lr
8000b0ae:	2f f7       	sub	r7,-1
8000b0b0:	e0 47 07 ff 	cp.w	r7,2047
8000b0b4:	f9 ba 00 00 	moveq	r10,0
8000b0b8:	f9 bb 00 00 	moveq	r11,0
8000b0bc:	f9 be 00 00 	moveq	lr,0
8000b0c0:	cb fb       	rjmp	8000b03e <__avr32_f64_add_res_of_done>

8000b0c2 <__avr32_f64_add_op2_subnormal>:
8000b0c2:	30 16       	mov	r6,1
8000b0c4:	58 07       	cp.w	r7,0
8000b0c6:	ca 01       	brne	8000b006 <__avr32_f64_add+0x3e>
8000b0c8:	b5 cb       	cbr	r11,0x14
8000b0ca:	10 0a       	add	r10,r8
8000b0cc:	f6 09 00 4b 	adc	r11,r11,r9
8000b0d0:	18 4b       	or	r11,r12
8000b0d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b0d6:	d7 03       	nop

8000b0d8 <__avr32_f64_to_u32>:
8000b0d8:	58 0b       	cp.w	r11,0
8000b0da:	5e 6d       	retmi	0

8000b0dc <__avr32_f64_to_s32>:
8000b0dc:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b0e0:	b5 9c       	lsr	r12,0x15
8000b0e2:	e0 2c 03 ff 	sub	r12,1023
8000b0e6:	5e 3d       	retlo	0
8000b0e8:	f8 0c 11 1f 	rsub	r12,r12,31
8000b0ec:	16 99       	mov	r9,r11
8000b0ee:	ab 7b       	lsl	r11,0xb
8000b0f0:	bf bb       	sbr	r11,0x1f
8000b0f2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b0f6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b0fa:	a1 79       	lsl	r9,0x1
8000b0fc:	5e 2b       	reths	r11
8000b0fe:	5c 3b       	neg	r11
8000b100:	5e fb       	retal	r11

8000b102 <__avr32_u32_to_f64>:
8000b102:	f8 cb 00 00 	sub	r11,r12,0
8000b106:	30 0c       	mov	r12,0
8000b108:	c0 38       	rjmp	8000b10e <__avr32_s32_to_f64+0x4>

8000b10a <__avr32_s32_to_f64>:
8000b10a:	18 9b       	mov	r11,r12
8000b10c:	5c 4b       	abs	r11
8000b10e:	30 0a       	mov	r10,0
8000b110:	5e 0b       	reteq	r11
8000b112:	d4 01       	pushm	lr
8000b114:	e0 69 04 1e 	mov	r9,1054
8000b118:	f6 08 12 00 	clz	r8,r11
8000b11c:	c1 70       	breq	8000b14a <__avr32_s32_to_f64+0x40>
8000b11e:	c0 c3       	brcs	8000b136 <__avr32_s32_to_f64+0x2c>
8000b120:	f0 0e 11 20 	rsub	lr,r8,32
8000b124:	f6 08 09 4b 	lsl	r11,r11,r8
8000b128:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b12c:	1c 4b       	or	r11,lr
8000b12e:	f4 08 09 4a 	lsl	r10,r10,r8
8000b132:	10 19       	sub	r9,r8
8000b134:	c0 b8       	rjmp	8000b14a <__avr32_s32_to_f64+0x40>
8000b136:	f4 08 12 00 	clz	r8,r10
8000b13a:	f9 b8 03 00 	movlo	r8,0
8000b13e:	f7 b8 02 e0 	subhs	r8,-32
8000b142:	f4 08 09 4b 	lsl	r11,r10,r8
8000b146:	30 0a       	mov	r10,0
8000b148:	10 19       	sub	r9,r8
8000b14a:	58 09       	cp.w	r9,0
8000b14c:	e0 89 00 30 	brgt	8000b1ac <__avr32_s32_to_f64+0xa2>
8000b150:	5c 39       	neg	r9
8000b152:	2f f9       	sub	r9,-1
8000b154:	e0 49 00 36 	cp.w	r9,54
8000b158:	c0 43       	brcs	8000b160 <__avr32_s32_to_f64+0x56>
8000b15a:	30 0b       	mov	r11,0
8000b15c:	30 0a       	mov	r10,0
8000b15e:	c2 68       	rjmp	8000b1aa <__avr32_s32_to_f64+0xa0>
8000b160:	2f 69       	sub	r9,-10
8000b162:	f2 08 11 20 	rsub	r8,r9,32
8000b166:	e0 49 00 20 	cp.w	r9,32
8000b16a:	c0 b2       	brcc	8000b180 <__avr32_s32_to_f64+0x76>
8000b16c:	f4 08 09 4e 	lsl	lr,r10,r8
8000b170:	f6 08 09 48 	lsl	r8,r11,r8
8000b174:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b178:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b17c:	10 4b       	or	r11,r8
8000b17e:	c0 88       	rjmp	8000b18e <__avr32_s32_to_f64+0x84>
8000b180:	f6 08 09 4e 	lsl	lr,r11,r8
8000b184:	14 4e       	or	lr,r10
8000b186:	16 9a       	mov	r10,r11
8000b188:	30 0b       	mov	r11,0
8000b18a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b18e:	ed ba 00 00 	bld	r10,0x0
8000b192:	c0 92       	brcc	8000b1a4 <__avr32_s32_to_f64+0x9a>
8000b194:	1c 7e       	tst	lr,lr
8000b196:	c0 41       	brne	8000b19e <__avr32_s32_to_f64+0x94>
8000b198:	ed ba 00 01 	bld	r10,0x1
8000b19c:	c0 42       	brcc	8000b1a4 <__avr32_s32_to_f64+0x9a>
8000b19e:	2f fa       	sub	r10,-1
8000b1a0:	f7 bb 02 ff 	subhs	r11,-1
8000b1a4:	5c fc       	rol	r12
8000b1a6:	5d 0b       	ror	r11
8000b1a8:	5d 0a       	ror	r10
8000b1aa:	d8 02       	popm	pc
8000b1ac:	e0 68 03 ff 	mov	r8,1023
8000b1b0:	ed ba 00 0b 	bld	r10,0xb
8000b1b4:	f7 b8 00 ff 	subeq	r8,-1
8000b1b8:	10 0a       	add	r10,r8
8000b1ba:	5c 0b       	acr	r11
8000b1bc:	f7 b9 03 fe 	sublo	r9,-2
8000b1c0:	e0 49 07 ff 	cp.w	r9,2047
8000b1c4:	c0 55       	brlt	8000b1ce <__avr32_s32_to_f64+0xc4>
8000b1c6:	30 0a       	mov	r10,0
8000b1c8:	fc 1b ff e0 	movh	r11,0xffe0
8000b1cc:	c0 c8       	rjmp	8000b1e4 <__floatsidf_return_op1>
8000b1ce:	ed bb 00 1f 	bld	r11,0x1f
8000b1d2:	f7 b9 01 01 	subne	r9,1
8000b1d6:	ab 9a       	lsr	r10,0xb
8000b1d8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b1dc:	a1 7b       	lsl	r11,0x1
8000b1de:	ab 9b       	lsr	r11,0xb
8000b1e0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b1e4 <__floatsidf_return_op1>:
8000b1e4:	a1 7c       	lsl	r12,0x1
8000b1e6:	5d 0b       	ror	r11
8000b1e8:	d8 02       	popm	pc

8000b1ea <__avr32_f64_cmp_eq>:
8000b1ea:	10 3a       	cp.w	r10,r8
8000b1ec:	f2 0b 13 00 	cpc	r11,r9
8000b1f0:	c0 80       	breq	8000b200 <__avr32_f64_cmp_eq+0x16>
8000b1f2:	a1 7b       	lsl	r11,0x1
8000b1f4:	a1 79       	lsl	r9,0x1
8000b1f6:	14 4b       	or	r11,r10
8000b1f8:	12 4b       	or	r11,r9
8000b1fa:	10 4b       	or	r11,r8
8000b1fc:	5e 0f       	reteq	1
8000b1fe:	5e fd       	retal	0
8000b200:	a1 7b       	lsl	r11,0x1
8000b202:	fc 1c ff e0 	movh	r12,0xffe0
8000b206:	58 0a       	cp.w	r10,0
8000b208:	f8 0b 13 00 	cpc	r11,r12
8000b20c:	5e 8f       	retls	1
8000b20e:	5e fd       	retal	0

8000b210 <__avr32_f64_cmp_ge>:
8000b210:	1a de       	st.w	--sp,lr
8000b212:	1a d7       	st.w	--sp,r7
8000b214:	a1 7b       	lsl	r11,0x1
8000b216:	5f 3c       	srlo	r12
8000b218:	a1 79       	lsl	r9,0x1
8000b21a:	5f 37       	srlo	r7
8000b21c:	5c fc       	rol	r12
8000b21e:	fc 1e ff e0 	movh	lr,0xffe0
8000b222:	58 0a       	cp.w	r10,0
8000b224:	fc 0b 13 00 	cpc	r11,lr
8000b228:	e0 8b 00 1d 	brhi	8000b262 <__avr32_f64_cmp_ge+0x52>
8000b22c:	58 08       	cp.w	r8,0
8000b22e:	fc 09 13 00 	cpc	r9,lr
8000b232:	e0 8b 00 18 	brhi	8000b262 <__avr32_f64_cmp_ge+0x52>
8000b236:	58 0b       	cp.w	r11,0
8000b238:	f5 ba 00 00 	subfeq	r10,0
8000b23c:	c1 50       	breq	8000b266 <__avr32_f64_cmp_ge+0x56>
8000b23e:	1b 07       	ld.w	r7,sp++
8000b240:	1b 0e       	ld.w	lr,sp++
8000b242:	58 3c       	cp.w	r12,3
8000b244:	c0 a0       	breq	8000b258 <__avr32_f64_cmp_ge+0x48>
8000b246:	58 1c       	cp.w	r12,1
8000b248:	c0 33       	brcs	8000b24e <__avr32_f64_cmp_ge+0x3e>
8000b24a:	5e 0f       	reteq	1
8000b24c:	5e 1d       	retne	0
8000b24e:	10 3a       	cp.w	r10,r8
8000b250:	f2 0b 13 00 	cpc	r11,r9
8000b254:	5e 2f       	reths	1
8000b256:	5e 3d       	retlo	0
8000b258:	14 38       	cp.w	r8,r10
8000b25a:	f6 09 13 00 	cpc	r9,r11
8000b25e:	5e 2f       	reths	1
8000b260:	5e 3d       	retlo	0
8000b262:	1b 07       	ld.w	r7,sp++
8000b264:	d8 0a       	popm	pc,r12=0
8000b266:	58 17       	cp.w	r7,1
8000b268:	5f 0c       	sreq	r12
8000b26a:	58 09       	cp.w	r9,0
8000b26c:	f5 b8 00 00 	subfeq	r8,0
8000b270:	1b 07       	ld.w	r7,sp++
8000b272:	1b 0e       	ld.w	lr,sp++
8000b274:	5e 0f       	reteq	1
8000b276:	5e fc       	retal	r12

8000b278 <__avr32_f64_cmp_lt>:
8000b278:	1a de       	st.w	--sp,lr
8000b27a:	1a d7       	st.w	--sp,r7
8000b27c:	a1 7b       	lsl	r11,0x1
8000b27e:	5f 3c       	srlo	r12
8000b280:	a1 79       	lsl	r9,0x1
8000b282:	5f 37       	srlo	r7
8000b284:	5c fc       	rol	r12
8000b286:	fc 1e ff e0 	movh	lr,0xffe0
8000b28a:	58 0a       	cp.w	r10,0
8000b28c:	fc 0b 13 00 	cpc	r11,lr
8000b290:	e0 8b 00 1d 	brhi	8000b2ca <__avr32_f64_cmp_lt+0x52>
8000b294:	58 08       	cp.w	r8,0
8000b296:	fc 09 13 00 	cpc	r9,lr
8000b29a:	e0 8b 00 18 	brhi	8000b2ca <__avr32_f64_cmp_lt+0x52>
8000b29e:	58 0b       	cp.w	r11,0
8000b2a0:	f5 ba 00 00 	subfeq	r10,0
8000b2a4:	c1 50       	breq	8000b2ce <__avr32_f64_cmp_lt+0x56>
8000b2a6:	1b 07       	ld.w	r7,sp++
8000b2a8:	1b 0e       	ld.w	lr,sp++
8000b2aa:	58 3c       	cp.w	r12,3
8000b2ac:	c0 a0       	breq	8000b2c0 <__avr32_f64_cmp_lt+0x48>
8000b2ae:	58 1c       	cp.w	r12,1
8000b2b0:	c0 33       	brcs	8000b2b6 <__avr32_f64_cmp_lt+0x3e>
8000b2b2:	5e 0d       	reteq	0
8000b2b4:	5e 1f       	retne	1
8000b2b6:	10 3a       	cp.w	r10,r8
8000b2b8:	f2 0b 13 00 	cpc	r11,r9
8000b2bc:	5e 2d       	reths	0
8000b2be:	5e 3f       	retlo	1
8000b2c0:	14 38       	cp.w	r8,r10
8000b2c2:	f6 09 13 00 	cpc	r9,r11
8000b2c6:	5e 2d       	reths	0
8000b2c8:	5e 3f       	retlo	1
8000b2ca:	1b 07       	ld.w	r7,sp++
8000b2cc:	d8 0a       	popm	pc,r12=0
8000b2ce:	58 17       	cp.w	r7,1
8000b2d0:	5f 1c       	srne	r12
8000b2d2:	58 09       	cp.w	r9,0
8000b2d4:	f5 b8 00 00 	subfeq	r8,0
8000b2d8:	1b 07       	ld.w	r7,sp++
8000b2da:	1b 0e       	ld.w	lr,sp++
8000b2dc:	5e 0d       	reteq	0
8000b2de:	5e fc       	retal	r12

8000b2e0 <__avr32_f64_div>:
8000b2e0:	eb cd 40 ff 	pushm	r0-r7,lr
8000b2e4:	f7 e9 20 0e 	eor	lr,r11,r9
8000b2e8:	f6 07 16 14 	lsr	r7,r11,0x14
8000b2ec:	a9 7b       	lsl	r11,0x9
8000b2ee:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b2f2:	a9 7a       	lsl	r10,0x9
8000b2f4:	bd bb       	sbr	r11,0x1d
8000b2f6:	e4 1b 3f ff 	andh	r11,0x3fff
8000b2fa:	ab d7       	cbr	r7,0xb
8000b2fc:	e0 80 00 cc 	breq	8000b494 <__avr32_f64_div_round_subnormal+0x54>
8000b300:	e0 47 07 ff 	cp.w	r7,2047
8000b304:	e0 84 00 b5 	brge	8000b46e <__avr32_f64_div_round_subnormal+0x2e>
8000b308:	f2 06 16 14 	lsr	r6,r9,0x14
8000b30c:	a9 79       	lsl	r9,0x9
8000b30e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b312:	a9 78       	lsl	r8,0x9
8000b314:	bd b9       	sbr	r9,0x1d
8000b316:	e4 19 3f ff 	andh	r9,0x3fff
8000b31a:	ab d6       	cbr	r6,0xb
8000b31c:	e0 80 00 e2 	breq	8000b4e0 <__avr32_f64_div_round_subnormal+0xa0>
8000b320:	e0 46 07 ff 	cp.w	r6,2047
8000b324:	e0 84 00 b2 	brge	8000b488 <__avr32_f64_div_round_subnormal+0x48>
8000b328:	0c 17       	sub	r7,r6
8000b32a:	fe 37 fc 01 	sub	r7,-1023
8000b32e:	fc 1c 80 00 	movh	r12,0x8000
8000b332:	f8 03 16 01 	lsr	r3,r12,0x1
8000b336:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b33a:	5c d4       	com	r4
8000b33c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b340:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b344:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b348:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b34c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b350:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b354:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b358:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b35c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b360:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b364:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b368:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b36c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b370:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b374:	e4 09 07 40 	macu.d	r0,r2,r9
8000b378:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b37c:	02 04       	add	r4,r1
8000b37e:	5c 05       	acr	r5
8000b380:	a3 65       	lsl	r5,0x2
8000b382:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b386:	a3 64       	lsl	r4,0x2
8000b388:	5c 34       	neg	r4
8000b38a:	f8 05 01 45 	sbc	r5,r12,r5
8000b38e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b392:	e4 05 07 40 	macu.d	r0,r2,r5
8000b396:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b39a:	02 04       	add	r4,r1
8000b39c:	5c 05       	acr	r5
8000b39e:	ea 03 15 02 	lsl	r3,r5,0x2
8000b3a2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b3a6:	e8 02 15 02 	lsl	r2,r4,0x2
8000b3aa:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b3ae:	e4 09 07 40 	macu.d	r0,r2,r9
8000b3b2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b3b6:	02 04       	add	r4,r1
8000b3b8:	5c 05       	acr	r5
8000b3ba:	a3 65       	lsl	r5,0x2
8000b3bc:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b3c0:	a3 64       	lsl	r4,0x2
8000b3c2:	5c 34       	neg	r4
8000b3c4:	f8 05 01 45 	sbc	r5,r12,r5
8000b3c8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b3cc:	e4 05 07 40 	macu.d	r0,r2,r5
8000b3d0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b3d4:	02 04       	add	r4,r1
8000b3d6:	5c 05       	acr	r5
8000b3d8:	ea 03 15 02 	lsl	r3,r5,0x2
8000b3dc:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b3e0:	e8 02 15 02 	lsl	r2,r4,0x2
8000b3e4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b3e8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b3ec:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b3f0:	02 02       	add	r2,r1
8000b3f2:	5c 03       	acr	r3
8000b3f4:	ed b3 00 1c 	bld	r3,0x1c
8000b3f8:	c0 90       	breq	8000b40a <__avr32_f64_div+0x12a>
8000b3fa:	a1 72       	lsl	r2,0x1
8000b3fc:	5c f3       	rol	r3
8000b3fe:	20 17       	sub	r7,1
8000b400:	a3 9a       	lsr	r10,0x3
8000b402:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b406:	a3 9b       	lsr	r11,0x3
8000b408:	c0 58       	rjmp	8000b412 <__avr32_f64_div+0x132>
8000b40a:	a5 8a       	lsr	r10,0x4
8000b40c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b410:	a5 8b       	lsr	r11,0x4
8000b412:	58 07       	cp.w	r7,0
8000b414:	e0 8a 00 8b 	brle	8000b52a <__avr32_f64_div_res_subnormal>
8000b418:	e0 12 ff 00 	andl	r2,0xff00
8000b41c:	e8 12 00 80 	orl	r2,0x80
8000b420:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b424:	e4 09 07 40 	macu.d	r0,r2,r9
8000b428:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b42c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b430:	00 05       	add	r5,r0
8000b432:	f0 01 00 48 	adc	r8,r8,r1
8000b436:	5c 09       	acr	r9
8000b438:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b43c:	58 04       	cp.w	r4,0
8000b43e:	5c 25       	cpc	r5

8000b440 <__avr32_f64_div_round_subnormal>:
8000b440:	f4 08 13 00 	cpc	r8,r10
8000b444:	f6 09 13 00 	cpc	r9,r11
8000b448:	5f 36       	srlo	r6
8000b44a:	f8 06 17 00 	moveq	r6,r12
8000b44e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b452:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b456:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b45a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b45e:	ed be 00 1f 	bld	lr,0x1f
8000b462:	ef bb 00 1f 	bst	r11,0x1f
8000b466:	0c 0a       	add	r10,r6
8000b468:	5c 0b       	acr	r11
8000b46a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b46e:	e4 1b 00 0f 	andh	r11,0xf
8000b472:	14 4b       	or	r11,r10
8000b474:	e0 81 00 a7 	brne	8000b5c2 <__avr32_f64_div_res_subnormal+0x98>
8000b478:	f2 06 16 14 	lsr	r6,r9,0x14
8000b47c:	ab d6       	cbr	r6,0xb
8000b47e:	e0 46 07 ff 	cp.w	r6,2047
8000b482:	e0 81 00 a4 	brne	8000b5ca <__avr32_f64_div_res_subnormal+0xa0>
8000b486:	c9 e8       	rjmp	8000b5c2 <__avr32_f64_div_res_subnormal+0x98>
8000b488:	e4 19 00 0f 	andh	r9,0xf
8000b48c:	10 49       	or	r9,r8
8000b48e:	e0 81 00 9a 	brne	8000b5c2 <__avr32_f64_div_res_subnormal+0x98>
8000b492:	c9 28       	rjmp	8000b5b6 <__avr32_f64_div_res_subnormal+0x8c>
8000b494:	a3 7b       	lsl	r11,0x3
8000b496:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b49a:	a3 7a       	lsl	r10,0x3
8000b49c:	f5 eb 10 04 	or	r4,r10,r11
8000b4a0:	e0 80 00 a0 	breq	8000b5e0 <__avr32_f64_div_op1_zero>
8000b4a4:	f6 04 12 00 	clz	r4,r11
8000b4a8:	c1 70       	breq	8000b4d6 <__avr32_f64_div_round_subnormal+0x96>
8000b4aa:	c0 c3       	brcs	8000b4c2 <__avr32_f64_div_round_subnormal+0x82>
8000b4ac:	e8 05 11 20 	rsub	r5,r4,32
8000b4b0:	f6 04 09 4b 	lsl	r11,r11,r4
8000b4b4:	f4 05 0a 45 	lsr	r5,r10,r5
8000b4b8:	0a 4b       	or	r11,r5
8000b4ba:	f4 04 09 4a 	lsl	r10,r10,r4
8000b4be:	08 17       	sub	r7,r4
8000b4c0:	c0 b8       	rjmp	8000b4d6 <__avr32_f64_div_round_subnormal+0x96>
8000b4c2:	f4 04 12 00 	clz	r4,r10
8000b4c6:	f9 b4 03 00 	movlo	r4,0
8000b4ca:	f7 b4 02 e0 	subhs	r4,-32
8000b4ce:	f4 04 09 4b 	lsl	r11,r10,r4
8000b4d2:	30 0a       	mov	r10,0
8000b4d4:	08 17       	sub	r7,r4
8000b4d6:	a3 8a       	lsr	r10,0x2
8000b4d8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b4dc:	a3 8b       	lsr	r11,0x2
8000b4de:	c1 1b       	rjmp	8000b300 <__avr32_f64_div+0x20>
8000b4e0:	a3 79       	lsl	r9,0x3
8000b4e2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b4e6:	a3 78       	lsl	r8,0x3
8000b4e8:	f3 e8 10 04 	or	r4,r9,r8
8000b4ec:	c6 f0       	breq	8000b5ca <__avr32_f64_div_res_subnormal+0xa0>
8000b4ee:	f2 04 12 00 	clz	r4,r9
8000b4f2:	c1 70       	breq	8000b520 <__avr32_f64_div_round_subnormal+0xe0>
8000b4f4:	c0 c3       	brcs	8000b50c <__avr32_f64_div_round_subnormal+0xcc>
8000b4f6:	e8 05 11 20 	rsub	r5,r4,32
8000b4fa:	f2 04 09 49 	lsl	r9,r9,r4
8000b4fe:	f0 05 0a 45 	lsr	r5,r8,r5
8000b502:	0a 49       	or	r9,r5
8000b504:	f0 04 09 48 	lsl	r8,r8,r4
8000b508:	08 16       	sub	r6,r4
8000b50a:	c0 b8       	rjmp	8000b520 <__avr32_f64_div_round_subnormal+0xe0>
8000b50c:	f0 04 12 00 	clz	r4,r8
8000b510:	f9 b4 03 00 	movlo	r4,0
8000b514:	f7 b4 02 e0 	subhs	r4,-32
8000b518:	f0 04 09 49 	lsl	r9,r8,r4
8000b51c:	30 08       	mov	r8,0
8000b51e:	08 16       	sub	r6,r4
8000b520:	a3 88       	lsr	r8,0x2
8000b522:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b526:	a3 89       	lsr	r9,0x2
8000b528:	cf ca       	rjmp	8000b320 <__avr32_f64_div+0x40>

8000b52a <__avr32_f64_div_res_subnormal>:
8000b52a:	5c 37       	neg	r7
8000b52c:	2f f7       	sub	r7,-1
8000b52e:	f1 b7 04 c0 	satu	r7,0x6
8000b532:	e0 47 00 20 	cp.w	r7,32
8000b536:	c1 54       	brge	8000b560 <__avr32_f64_div_res_subnormal+0x36>
8000b538:	ee 06 11 20 	rsub	r6,r7,32
8000b53c:	e4 07 0a 42 	lsr	r2,r2,r7
8000b540:	e6 06 09 4c 	lsl	r12,r3,r6
8000b544:	18 42       	or	r2,r12
8000b546:	e6 07 0a 43 	lsr	r3,r3,r7
8000b54a:	f4 06 09 41 	lsl	r1,r10,r6
8000b54e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b552:	f6 06 09 4c 	lsl	r12,r11,r6
8000b556:	18 4a       	or	r10,r12
8000b558:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b55c:	30 00       	mov	r0,0
8000b55e:	c1 58       	rjmp	8000b588 <__avr32_f64_div_res_subnormal+0x5e>
8000b560:	ee 06 11 20 	rsub	r6,r7,32
8000b564:	f9 b0 00 00 	moveq	r0,0
8000b568:	f9 bc 00 00 	moveq	r12,0
8000b56c:	c0 50       	breq	8000b576 <__avr32_f64_div_res_subnormal+0x4c>
8000b56e:	f4 06 09 40 	lsl	r0,r10,r6
8000b572:	f6 06 09 4c 	lsl	r12,r11,r6
8000b576:	e6 07 0a 42 	lsr	r2,r3,r7
8000b57a:	30 03       	mov	r3,0
8000b57c:	f4 07 0a 41 	lsr	r1,r10,r7
8000b580:	18 41       	or	r1,r12
8000b582:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b586:	30 0b       	mov	r11,0
8000b588:	e0 12 ff 00 	andl	r2,0xff00
8000b58c:	e8 12 00 80 	orl	r2,0x80
8000b590:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b594:	e4 09 07 46 	macu.d	r6,r2,r9
8000b598:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b59c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b5a0:	0c 05       	add	r5,r6
8000b5a2:	f0 07 00 48 	adc	r8,r8,r7
8000b5a6:	5c 09       	acr	r9
8000b5a8:	30 07       	mov	r7,0
8000b5aa:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b5ae:	00 34       	cp.w	r4,r0
8000b5b0:	e2 05 13 00 	cpc	r5,r1
8000b5b4:	c4 6b       	rjmp	8000b440 <__avr32_f64_div_round_subnormal>
8000b5b6:	1c 9b       	mov	r11,lr
8000b5b8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b5bc:	30 0a       	mov	r10,0
8000b5be:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b5c2:	3f fb       	mov	r11,-1
8000b5c4:	30 0a       	mov	r10,0
8000b5c6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b5ca:	f5 eb 10 04 	or	r4,r10,r11
8000b5ce:	c0 90       	breq	8000b5e0 <__avr32_f64_div_op1_zero>
8000b5d0:	1c 9b       	mov	r11,lr
8000b5d2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b5d6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b5da:	30 0a       	mov	r10,0
8000b5dc:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b5e0 <__avr32_f64_div_op1_zero>:
8000b5e0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b5e4:	ce f0       	breq	8000b5c2 <__avr32_f64_div_res_subnormal+0x98>
8000b5e6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b5ea:	e0 44 07 ff 	cp.w	r4,2047
8000b5ee:	ce 41       	brne	8000b5b6 <__avr32_f64_div_res_subnormal+0x8c>
8000b5f0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b5f4:	ce 10       	breq	8000b5b6 <__avr32_f64_div_res_subnormal+0x8c>
8000b5f6:	ce 6b       	rjmp	8000b5c2 <__avr32_f64_div_res_subnormal+0x98>

8000b5f8 <__avr32_udiv64>:
8000b5f8:	d4 31       	pushm	r0-r7,lr
8000b5fa:	1a 97       	mov	r7,sp
8000b5fc:	20 3d       	sub	sp,12
8000b5fe:	10 9c       	mov	r12,r8
8000b600:	12 9e       	mov	lr,r9
8000b602:	14 93       	mov	r3,r10
8000b604:	58 09       	cp.w	r9,0
8000b606:	e0 81 00 bd 	brne	8000b780 <__avr32_udiv64+0x188>
8000b60a:	16 38       	cp.w	r8,r11
8000b60c:	e0 88 00 40 	brls	8000b68c <__avr32_udiv64+0x94>
8000b610:	f0 08 12 00 	clz	r8,r8
8000b614:	c0 d0       	breq	8000b62e <__avr32_udiv64+0x36>
8000b616:	f6 08 09 4b 	lsl	r11,r11,r8
8000b61a:	f0 09 11 20 	rsub	r9,r8,32
8000b61e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b622:	f4 09 0a 49 	lsr	r9,r10,r9
8000b626:	f4 08 09 43 	lsl	r3,r10,r8
8000b62a:	f3 eb 10 0b 	or	r11,r9,r11
8000b62e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b632:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b636:	f6 0e 0d 00 	divu	r0,r11,lr
8000b63a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b63e:	00 99       	mov	r9,r0
8000b640:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b644:	e0 0a 02 48 	mul	r8,r0,r10
8000b648:	10 3b       	cp.w	r11,r8
8000b64a:	c0 a2       	brcc	8000b65e <__avr32_udiv64+0x66>
8000b64c:	20 19       	sub	r9,1
8000b64e:	18 0b       	add	r11,r12
8000b650:	18 3b       	cp.w	r11,r12
8000b652:	c0 63       	brcs	8000b65e <__avr32_udiv64+0x66>
8000b654:	10 3b       	cp.w	r11,r8
8000b656:	f7 b9 03 01 	sublo	r9,1
8000b65a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b65e:	f6 08 01 01 	sub	r1,r11,r8
8000b662:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b666:	e2 0e 0d 00 	divu	r0,r1,lr
8000b66a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b66e:	00 98       	mov	r8,r0
8000b670:	e0 0a 02 4a 	mul	r10,r0,r10
8000b674:	14 33       	cp.w	r3,r10
8000b676:	c0 82       	brcc	8000b686 <__avr32_udiv64+0x8e>
8000b678:	20 18       	sub	r8,1
8000b67a:	18 03       	add	r3,r12
8000b67c:	18 33       	cp.w	r3,r12
8000b67e:	c0 43       	brcs	8000b686 <__avr32_udiv64+0x8e>
8000b680:	14 33       	cp.w	r3,r10
8000b682:	f7 b8 03 01 	sublo	r8,1
8000b686:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b68a:	cd f8       	rjmp	8000b848 <__avr32_udiv64+0x250>
8000b68c:	58 08       	cp.w	r8,0
8000b68e:	c0 51       	brne	8000b698 <__avr32_udiv64+0xa0>
8000b690:	30 19       	mov	r9,1
8000b692:	f2 08 0d 08 	divu	r8,r9,r8
8000b696:	10 9c       	mov	r12,r8
8000b698:	f8 06 12 00 	clz	r6,r12
8000b69c:	c0 41       	brne	8000b6a4 <__avr32_udiv64+0xac>
8000b69e:	18 1b       	sub	r11,r12
8000b6a0:	30 19       	mov	r9,1
8000b6a2:	c4 08       	rjmp	8000b722 <__avr32_udiv64+0x12a>
8000b6a4:	ec 01 11 20 	rsub	r1,r6,32
8000b6a8:	f4 01 0a 49 	lsr	r9,r10,r1
8000b6ac:	f8 06 09 4c 	lsl	r12,r12,r6
8000b6b0:	f6 06 09 48 	lsl	r8,r11,r6
8000b6b4:	f6 01 0a 41 	lsr	r1,r11,r1
8000b6b8:	f3 e8 10 08 	or	r8,r9,r8
8000b6bc:	f8 03 16 10 	lsr	r3,r12,0x10
8000b6c0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b6c4:	e2 03 0d 00 	divu	r0,r1,r3
8000b6c8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b6cc:	00 9e       	mov	lr,r0
8000b6ce:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b6d2:	e0 05 02 49 	mul	r9,r0,r5
8000b6d6:	12 3b       	cp.w	r11,r9
8000b6d8:	c0 a2       	brcc	8000b6ec <__avr32_udiv64+0xf4>
8000b6da:	20 1e       	sub	lr,1
8000b6dc:	18 0b       	add	r11,r12
8000b6de:	18 3b       	cp.w	r11,r12
8000b6e0:	c0 63       	brcs	8000b6ec <__avr32_udiv64+0xf4>
8000b6e2:	12 3b       	cp.w	r11,r9
8000b6e4:	f7 be 03 01 	sublo	lr,1
8000b6e8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b6ec:	12 1b       	sub	r11,r9
8000b6ee:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b6f2:	f6 03 0d 02 	divu	r2,r11,r3
8000b6f6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b6fa:	04 99       	mov	r9,r2
8000b6fc:	e4 05 02 4b 	mul	r11,r2,r5
8000b700:	16 38       	cp.w	r8,r11
8000b702:	c0 a2       	brcc	8000b716 <__avr32_udiv64+0x11e>
8000b704:	20 19       	sub	r9,1
8000b706:	18 08       	add	r8,r12
8000b708:	18 38       	cp.w	r8,r12
8000b70a:	c0 63       	brcs	8000b716 <__avr32_udiv64+0x11e>
8000b70c:	16 38       	cp.w	r8,r11
8000b70e:	f7 b9 03 01 	sublo	r9,1
8000b712:	f1 dc e3 08 	addcs	r8,r8,r12
8000b716:	f4 06 09 43 	lsl	r3,r10,r6
8000b71a:	f0 0b 01 0b 	sub	r11,r8,r11
8000b71e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b722:	f8 06 16 10 	lsr	r6,r12,0x10
8000b726:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b72a:	f6 06 0d 00 	divu	r0,r11,r6
8000b72e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b732:	00 9a       	mov	r10,r0
8000b734:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b738:	e0 0e 02 48 	mul	r8,r0,lr
8000b73c:	10 3b       	cp.w	r11,r8
8000b73e:	c0 a2       	brcc	8000b752 <__avr32_udiv64+0x15a>
8000b740:	20 1a       	sub	r10,1
8000b742:	18 0b       	add	r11,r12
8000b744:	18 3b       	cp.w	r11,r12
8000b746:	c0 63       	brcs	8000b752 <__avr32_udiv64+0x15a>
8000b748:	10 3b       	cp.w	r11,r8
8000b74a:	f7 ba 03 01 	sublo	r10,1
8000b74e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b752:	f6 08 01 01 	sub	r1,r11,r8
8000b756:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b75a:	e2 06 0d 00 	divu	r0,r1,r6
8000b75e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b762:	00 98       	mov	r8,r0
8000b764:	e0 0e 02 4b 	mul	r11,r0,lr
8000b768:	16 33       	cp.w	r3,r11
8000b76a:	c0 82       	brcc	8000b77a <__avr32_udiv64+0x182>
8000b76c:	20 18       	sub	r8,1
8000b76e:	18 03       	add	r3,r12
8000b770:	18 33       	cp.w	r3,r12
8000b772:	c0 43       	brcs	8000b77a <__avr32_udiv64+0x182>
8000b774:	16 33       	cp.w	r3,r11
8000b776:	f7 b8 03 01 	sublo	r8,1
8000b77a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b77e:	c6 98       	rjmp	8000b850 <__avr32_udiv64+0x258>
8000b780:	16 39       	cp.w	r9,r11
8000b782:	e0 8b 00 65 	brhi	8000b84c <__avr32_udiv64+0x254>
8000b786:	f2 09 12 00 	clz	r9,r9
8000b78a:	c0 b1       	brne	8000b7a0 <__avr32_udiv64+0x1a8>
8000b78c:	10 3a       	cp.w	r10,r8
8000b78e:	5f 2a       	srhs	r10
8000b790:	1c 3b       	cp.w	r11,lr
8000b792:	5f b8       	srhi	r8
8000b794:	10 4a       	or	r10,r8
8000b796:	f2 0a 18 00 	cp.b	r10,r9
8000b79a:	c5 90       	breq	8000b84c <__avr32_udiv64+0x254>
8000b79c:	30 18       	mov	r8,1
8000b79e:	c5 98       	rjmp	8000b850 <__avr32_udiv64+0x258>
8000b7a0:	f0 09 09 46 	lsl	r6,r8,r9
8000b7a4:	f2 03 11 20 	rsub	r3,r9,32
8000b7a8:	fc 09 09 4e 	lsl	lr,lr,r9
8000b7ac:	f0 03 0a 48 	lsr	r8,r8,r3
8000b7b0:	f6 09 09 4c 	lsl	r12,r11,r9
8000b7b4:	f4 03 0a 42 	lsr	r2,r10,r3
8000b7b8:	ef 46 ff f4 	st.w	r7[-12],r6
8000b7bc:	f6 03 0a 43 	lsr	r3,r11,r3
8000b7c0:	18 42       	or	r2,r12
8000b7c2:	f1 ee 10 0c 	or	r12,r8,lr
8000b7c6:	f8 01 16 10 	lsr	r1,r12,0x10
8000b7ca:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b7ce:	e6 01 0d 04 	divu	r4,r3,r1
8000b7d2:	e4 03 16 10 	lsr	r3,r2,0x10
8000b7d6:	08 9e       	mov	lr,r4
8000b7d8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b7dc:	e8 06 02 48 	mul	r8,r4,r6
8000b7e0:	10 33       	cp.w	r3,r8
8000b7e2:	c0 a2       	brcc	8000b7f6 <__avr32_udiv64+0x1fe>
8000b7e4:	20 1e       	sub	lr,1
8000b7e6:	18 03       	add	r3,r12
8000b7e8:	18 33       	cp.w	r3,r12
8000b7ea:	c0 63       	brcs	8000b7f6 <__avr32_udiv64+0x1fe>
8000b7ec:	10 33       	cp.w	r3,r8
8000b7ee:	f7 be 03 01 	sublo	lr,1
8000b7f2:	e7 dc e3 03 	addcs	r3,r3,r12
8000b7f6:	10 13       	sub	r3,r8
8000b7f8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b7fc:	e6 01 0d 00 	divu	r0,r3,r1
8000b800:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b804:	00 98       	mov	r8,r0
8000b806:	e0 06 02 46 	mul	r6,r0,r6
8000b80a:	0c 3b       	cp.w	r11,r6
8000b80c:	c0 a2       	brcc	8000b820 <__avr32_udiv64+0x228>
8000b80e:	20 18       	sub	r8,1
8000b810:	18 0b       	add	r11,r12
8000b812:	18 3b       	cp.w	r11,r12
8000b814:	c0 63       	brcs	8000b820 <__avr32_udiv64+0x228>
8000b816:	0c 3b       	cp.w	r11,r6
8000b818:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b81c:	f7 b8 03 01 	sublo	r8,1
8000b820:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b824:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b828:	0c 1b       	sub	r11,r6
8000b82a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b82e:	06 95       	mov	r5,r3
8000b830:	16 35       	cp.w	r5,r11
8000b832:	e0 8b 00 0a 	brhi	8000b846 <__avr32_udiv64+0x24e>
8000b836:	5f 0b       	sreq	r11
8000b838:	f4 09 09 49 	lsl	r9,r10,r9
8000b83c:	12 32       	cp.w	r2,r9
8000b83e:	5f b9       	srhi	r9
8000b840:	f7 e9 00 09 	and	r9,r11,r9
8000b844:	c0 60       	breq	8000b850 <__avr32_udiv64+0x258>
8000b846:	20 18       	sub	r8,1
8000b848:	30 09       	mov	r9,0
8000b84a:	c0 38       	rjmp	8000b850 <__avr32_udiv64+0x258>
8000b84c:	30 09       	mov	r9,0
8000b84e:	12 98       	mov	r8,r9
8000b850:	10 9a       	mov	r10,r8
8000b852:	12 93       	mov	r3,r9
8000b854:	10 92       	mov	r2,r8
8000b856:	12 9b       	mov	r11,r9
8000b858:	2f dd       	sub	sp,-12
8000b85a:	d8 32       	popm	r0-r7,pc

8000b85c <__avr32_umod64>:
8000b85c:	d4 31       	pushm	r0-r7,lr
8000b85e:	1a 97       	mov	r7,sp
8000b860:	20 3d       	sub	sp,12
8000b862:	10 9c       	mov	r12,r8
8000b864:	12 95       	mov	r5,r9
8000b866:	14 9e       	mov	lr,r10
8000b868:	16 91       	mov	r1,r11
8000b86a:	16 96       	mov	r6,r11
8000b86c:	58 09       	cp.w	r9,0
8000b86e:	e0 81 00 81 	brne	8000b970 <__avr32_umod64+0x114>
8000b872:	16 38       	cp.w	r8,r11
8000b874:	e0 88 00 12 	brls	8000b898 <__avr32_umod64+0x3c>
8000b878:	f0 08 12 00 	clz	r8,r8
8000b87c:	c4 e0       	breq	8000b918 <__avr32_umod64+0xbc>
8000b87e:	f6 08 09 46 	lsl	r6,r11,r8
8000b882:	f8 08 09 4c 	lsl	r12,r12,r8
8000b886:	f0 0b 11 20 	rsub	r11,r8,32
8000b88a:	f4 08 09 4e 	lsl	lr,r10,r8
8000b88e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b892:	f7 e6 10 06 	or	r6,r11,r6
8000b896:	c4 18       	rjmp	8000b918 <__avr32_umod64+0xbc>
8000b898:	58 08       	cp.w	r8,0
8000b89a:	c0 51       	brne	8000b8a4 <__avr32_umod64+0x48>
8000b89c:	30 19       	mov	r9,1
8000b89e:	f2 08 0d 08 	divu	r8,r9,r8
8000b8a2:	10 9c       	mov	r12,r8
8000b8a4:	f8 08 12 00 	clz	r8,r12
8000b8a8:	c0 31       	brne	8000b8ae <__avr32_umod64+0x52>
8000b8aa:	18 16       	sub	r6,r12
8000b8ac:	c3 68       	rjmp	8000b918 <__avr32_umod64+0xbc>
8000b8ae:	f0 03 11 20 	rsub	r3,r8,32
8000b8b2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b8b6:	f8 08 09 4c 	lsl	r12,r12,r8
8000b8ba:	ec 08 09 49 	lsl	r9,r6,r8
8000b8be:	ec 03 0a 43 	lsr	r3,r6,r3
8000b8c2:	f7 e9 10 09 	or	r9,r11,r9
8000b8c6:	f8 05 16 10 	lsr	r5,r12,0x10
8000b8ca:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b8ce:	e6 05 0d 02 	divu	r2,r3,r5
8000b8d2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b8d6:	ec 02 02 4b 	mul	r11,r6,r2
8000b8da:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b8de:	16 3e       	cp.w	lr,r11
8000b8e0:	c0 72       	brcc	8000b8ee <__avr32_umod64+0x92>
8000b8e2:	18 0e       	add	lr,r12
8000b8e4:	18 3e       	cp.w	lr,r12
8000b8e6:	c0 43       	brcs	8000b8ee <__avr32_umod64+0x92>
8000b8e8:	16 3e       	cp.w	lr,r11
8000b8ea:	fd dc e3 0e 	addcs	lr,lr,r12
8000b8ee:	fc 0b 01 03 	sub	r3,lr,r11
8000b8f2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b8f6:	e6 05 0d 02 	divu	r2,r3,r5
8000b8fa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b8fe:	a5 36       	mul	r6,r2
8000b900:	0c 39       	cp.w	r9,r6
8000b902:	c0 72       	brcc	8000b910 <__avr32_umod64+0xb4>
8000b904:	18 09       	add	r9,r12
8000b906:	18 39       	cp.w	r9,r12
8000b908:	c0 43       	brcs	8000b910 <__avr32_umod64+0xb4>
8000b90a:	0c 39       	cp.w	r9,r6
8000b90c:	f3 dc e3 09 	addcs	r9,r9,r12
8000b910:	f2 06 01 06 	sub	r6,r9,r6
8000b914:	f4 08 09 4e 	lsl	lr,r10,r8
8000b918:	f8 0a 16 10 	lsr	r10,r12,0x10
8000b91c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b920:	ec 0a 0d 02 	divu	r2,r6,r10
8000b924:	fc 09 16 10 	lsr	r9,lr,0x10
8000b928:	ea 02 02 4b 	mul	r11,r5,r2
8000b92c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b930:	16 39       	cp.w	r9,r11
8000b932:	c0 72       	brcc	8000b940 <__avr32_umod64+0xe4>
8000b934:	18 09       	add	r9,r12
8000b936:	18 39       	cp.w	r9,r12
8000b938:	c0 43       	brcs	8000b940 <__avr32_umod64+0xe4>
8000b93a:	16 39       	cp.w	r9,r11
8000b93c:	f3 dc e3 09 	addcs	r9,r9,r12
8000b940:	f2 0b 01 0b 	sub	r11,r9,r11
8000b944:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b948:	f6 0a 0d 0a 	divu	r10,r11,r10
8000b94c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000b950:	ea 0a 02 4a 	mul	r10,r5,r10
8000b954:	14 3e       	cp.w	lr,r10
8000b956:	c0 72       	brcc	8000b964 <__avr32_umod64+0x108>
8000b958:	18 0e       	add	lr,r12
8000b95a:	18 3e       	cp.w	lr,r12
8000b95c:	c0 43       	brcs	8000b964 <__avr32_umod64+0x108>
8000b95e:	14 3e       	cp.w	lr,r10
8000b960:	fd dc e3 0e 	addcs	lr,lr,r12
8000b964:	fc 0a 01 0a 	sub	r10,lr,r10
8000b968:	30 0b       	mov	r11,0
8000b96a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000b96e:	c7 b8       	rjmp	8000ba64 <__avr32_umod64+0x208>
8000b970:	16 39       	cp.w	r9,r11
8000b972:	e0 8b 00 79 	brhi	8000ba64 <__avr32_umod64+0x208>
8000b976:	f2 09 12 00 	clz	r9,r9
8000b97a:	c1 21       	brne	8000b99e <__avr32_umod64+0x142>
8000b97c:	10 3a       	cp.w	r10,r8
8000b97e:	5f 2b       	srhs	r11
8000b980:	0a 31       	cp.w	r1,r5
8000b982:	5f ba       	srhi	r10
8000b984:	f7 ea 10 0a 	or	r10,r11,r10
8000b988:	f2 0a 18 00 	cp.b	r10,r9
8000b98c:	c0 60       	breq	8000b998 <__avr32_umod64+0x13c>
8000b98e:	fc 08 01 0c 	sub	r12,lr,r8
8000b992:	e2 05 01 46 	sbc	r6,r1,r5
8000b996:	18 9e       	mov	lr,r12
8000b998:	0c 9b       	mov	r11,r6
8000b99a:	1c 9a       	mov	r10,lr
8000b99c:	c6 48       	rjmp	8000ba64 <__avr32_umod64+0x208>
8000b99e:	ea 09 09 4c 	lsl	r12,r5,r9
8000b9a2:	f2 06 11 20 	rsub	r6,r9,32
8000b9a6:	f6 09 09 4b 	lsl	r11,r11,r9
8000b9aa:	f0 09 09 42 	lsl	r2,r8,r9
8000b9ae:	ef 46 ff f4 	st.w	r7[-12],r6
8000b9b2:	f0 06 0a 48 	lsr	r8,r8,r6
8000b9b6:	18 48       	or	r8,r12
8000b9b8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000b9bc:	f4 09 09 43 	lsl	r3,r10,r9
8000b9c0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000b9c4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000b9c8:	16 4a       	or	r10,r11
8000b9ca:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b9ce:	f8 0b 0d 04 	divu	r4,r12,r11
8000b9d2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000b9d6:	08 91       	mov	r1,r4
8000b9d8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000b9dc:	e8 0e 02 46 	mul	r6,r4,lr
8000b9e0:	0c 3c       	cp.w	r12,r6
8000b9e2:	c0 a2       	brcc	8000b9f6 <__avr32_umod64+0x19a>
8000b9e4:	20 11       	sub	r1,1
8000b9e6:	10 0c       	add	r12,r8
8000b9e8:	10 3c       	cp.w	r12,r8
8000b9ea:	c0 63       	brcs	8000b9f6 <__avr32_umod64+0x19a>
8000b9ec:	0c 3c       	cp.w	r12,r6
8000b9ee:	f7 b1 03 01 	sublo	r1,1
8000b9f2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000b9f6:	0c 1c       	sub	r12,r6
8000b9f8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000b9fc:	f8 0b 0d 04 	divu	r4,r12,r11
8000ba00:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ba04:	08 96       	mov	r6,r4
8000ba06:	e8 0e 02 4e 	mul	lr,r4,lr
8000ba0a:	1c 3b       	cp.w	r11,lr
8000ba0c:	c0 a2       	brcc	8000ba20 <__avr32_umod64+0x1c4>
8000ba0e:	20 16       	sub	r6,1
8000ba10:	10 0b       	add	r11,r8
8000ba12:	10 3b       	cp.w	r11,r8
8000ba14:	c0 63       	brcs	8000ba20 <__avr32_umod64+0x1c4>
8000ba16:	1c 3b       	cp.w	r11,lr
8000ba18:	f7 b6 03 01 	sublo	r6,1
8000ba1c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ba20:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ba24:	1c 1b       	sub	r11,lr
8000ba26:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ba2a:	00 9e       	mov	lr,r0
8000ba2c:	02 9c       	mov	r12,r1
8000ba2e:	16 3c       	cp.w	r12,r11
8000ba30:	e0 8b 00 08 	brhi	8000ba40 <__avr32_umod64+0x1e4>
8000ba34:	5f 06       	sreq	r6
8000ba36:	06 30       	cp.w	r0,r3
8000ba38:	5f ba       	srhi	r10
8000ba3a:	ed ea 00 0a 	and	r10,r6,r10
8000ba3e:	c0 60       	breq	8000ba4a <__avr32_umod64+0x1ee>
8000ba40:	fc 02 01 04 	sub	r4,lr,r2
8000ba44:	f8 08 01 4c 	sbc	r12,r12,r8
8000ba48:	08 9e       	mov	lr,r4
8000ba4a:	e6 0e 01 0a 	sub	r10,r3,lr
8000ba4e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ba52:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ba56:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ba5a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ba5e:	f8 01 09 4c 	lsl	r12,r12,r1
8000ba62:	18 4a       	or	r10,r12
8000ba64:	2f dd       	sub	sp,-12
8000ba66:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000bc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000bc00:	c0 08       	rjmp	8000bc00 <_evba>
	...

8000bc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000bc04:	c0 08       	rjmp	8000bc04 <_handle_TLB_Multiple_Hit>
	...

8000bc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000bc08:	c0 08       	rjmp	8000bc08 <_handle_Bus_Error_Data_Fetch>
	...

8000bc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000bc0c:	c0 08       	rjmp	8000bc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000bc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000bc10:	c0 08       	rjmp	8000bc10 <_handle_NMI>
	...

8000bc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000bc14:	c0 08       	rjmp	8000bc14 <_handle_Instruction_Address>
	...

8000bc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000bc18:	c0 08       	rjmp	8000bc18 <_handle_ITLB_Protection>
	...

8000bc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000bc1c:	c0 08       	rjmp	8000bc1c <_handle_Breakpoint>
	...

8000bc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000bc20:	c0 08       	rjmp	8000bc20 <_handle_Illegal_Opcode>
	...

8000bc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000bc24:	c0 08       	rjmp	8000bc24 <_handle_Unimplemented_Instruction>
	...

8000bc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000bc28:	c0 08       	rjmp	8000bc28 <_handle_Privilege_Violation>
	...

8000bc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000bc2c:	c0 08       	rjmp	8000bc2c <_handle_Floating_Point>
	...

8000bc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000bc30:	c0 08       	rjmp	8000bc30 <_handle_Coprocessor_Absent>
	...

8000bc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000bc34:	c0 08       	rjmp	8000bc34 <_handle_Data_Address_Read>
	...

8000bc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000bc38:	c0 08       	rjmp	8000bc38 <_handle_Data_Address_Write>
	...

8000bc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000bc3c:	c0 08       	rjmp	8000bc3c <_handle_DTLB_Protection_Read>
	...

8000bc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000bc40:	c0 08       	rjmp	8000bc40 <_handle_DTLB_Protection_Write>
	...

8000bc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000bc44:	c0 08       	rjmp	8000bc44 <_handle_DTLB_Modified>
	...

8000bc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000bc50:	c0 08       	rjmp	8000bc50 <_handle_ITLB_Miss>
	...

8000bc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000bc60:	c0 08       	rjmp	8000bc60 <_handle_DTLB_Miss_Read>
	...

8000bc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000bc70:	c0 08       	rjmp	8000bc70 <_handle_DTLB_Miss_Write>
	...

8000bd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bd00:	fe cf 71 cc 	sub	pc,pc,29132

8000bd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bd04:	30 0c       	mov	r12,0
8000bd06:	fe b0 c3 8b 	rcall	8000441c <_get_interrupt_handler>
8000bd0a:	58 0c       	cp.w	r12,0
8000bd0c:	f8 0f 17 10 	movne	pc,r12
8000bd10:	d6 03       	rete

8000bd12 <_int1>:
8000bd12:	30 1c       	mov	r12,1
8000bd14:	fe b0 c3 84 	rcall	8000441c <_get_interrupt_handler>
8000bd18:	58 0c       	cp.w	r12,0
8000bd1a:	f8 0f 17 10 	movne	pc,r12
8000bd1e:	d6 03       	rete

8000bd20 <_int2>:
8000bd20:	30 2c       	mov	r12,2
8000bd22:	fe b0 c3 7d 	rcall	8000441c <_get_interrupt_handler>
8000bd26:	58 0c       	cp.w	r12,0
8000bd28:	f8 0f 17 10 	movne	pc,r12
8000bd2c:	d6 03       	rete

8000bd2e <_int3>:
8000bd2e:	30 3c       	mov	r12,3
8000bd30:	fe b0 c3 76 	rcall	8000441c <_get_interrupt_handler>
8000bd34:	58 0c       	cp.w	r12,0
8000bd36:	f8 0f 17 10 	movne	pc,r12
8000bd3a:	d6 03       	rete

8000bd3c <ipr_val>:
8000bd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bdfc:	d7 03 d7 03                                         ....
