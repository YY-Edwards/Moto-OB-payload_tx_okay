
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000abb0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000017b0  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a38  00000008  8000e5b0  0000ec08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00005960  00000a40  00000a40  00000000  2**2
                  ALLOC
  8 .heap         00010c60  000063a0  000063a0  00000000  2**0
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000f640  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001270  00000000  00000000  0000f670  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002817  00000000  00000000  000108e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002a189  00000000  00000000  000130f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006e1b  00000000  00000000  0003d280  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c8f1  00000000  00000000  0004409b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000302c  00000000  00000000  0005098c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000075a9  00000000  00000000  000539b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d45f  00000000  00000000  0005af61  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 19 .debug_ranges 00001340  00000000  00000000  000683c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 8d 90 	sub	pc,pc,-29296

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf ad 94 	sub	pc,pc,-21100

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 84       	ld.ub	r4,r6[0x0]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 5c       	eor	r12,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 64       	sub	r4,-122
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	2f 28       	sub	r8,-14
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	44 a8       	lddsp	r8,sp[0x128]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ce 00       	breq	80002046 <app_init+0x6>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 bc       	sub	r12,123
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	69 b0       	ld.w	r0,r4[0x6c]
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	ce 08       	rjmp	80002262 <Phyuserinput_brdcst_func+0x2>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	6d 74       	ld.w	r4,r6[0x5c]

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	ce 0c       	rcall	80002276 <Phyuserinput_brdcst_func+0x16>
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	6d 74       	ld.w	r4,r6[0x5c]

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	ce 2c       	rcall	8000228e <Phyuserinput_brdcst_func+0x2e>
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	6d 74       	ld.w	r4,r6[0x5c]

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	ce 48       	rjmp	800022a6 <Phyuserinput_brdcst_func+0x46>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	6d 74       	ld.w	r4,r6[0x5c]

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	ce 64       	brge	800020be <FD_reply_func+0x2>
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	6d 74       	ld.w	r4,r6[0x5c]

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ce 7c       	rcall	80002320 <DataSession_brdcst_func+0x4>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	6d 74       	ld.w	r4,r6[0x5c]
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ce 94       	brge	8000212c <EnOB_reply_func+0x34>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	ce a8       	rjmp	80002332 <DataSession_brdcst_func+0x16>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	ce c0       	breq	8000213a <EnOB_reply_func+0x42>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	ce dc       	rcall	80002340 <DataSession_brdcst_func+0x24>

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000216a:	19 a9       	ld.ub	r9,r12[0x2]
8000216c:	31 18       	mov	r8,17
8000216e:	f0 09 18 00 	cp.b	r9,r8
80002172:	c0 41       	brne	8000217a <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002174:	48 2c       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x14>
80002176:	f0 1f 00 03 	mcall	80002180 <SingleDetection_brdcst_func+0x18>
8000217a:	d8 02       	popm	pc
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	ce f4       	brge	8000215c <EnOB_reply_func+0x64>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	6d 74       	ld.w	r4,r6[0x5c]

80002184 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002184:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002186:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000218a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000218c:	4a bc       	lddpc	r12,80002238 <ButtonConfig_brdcst_func+0xb4>
8000218e:	f0 1f 00 2c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002192:	0f 88       	ld.ub	r8,r7[0x0]
80002194:	1a d8       	st.w	--sp,r8
80002196:	4a bc       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xbc>
80002198:	f0 1f 00 29 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000219c:	1a d5       	st.w	--sp,r5
8000219e:	4a ac       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc0>
800021a0:	f0 1f 00 27 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a4:	0f a8       	ld.ub	r8,r7[0x2]
800021a6:	1a d8       	st.w	--sp,r8
800021a8:	4a 8c       	lddpc	r12,80002248 <ButtonConfig_brdcst_func+0xc4>
800021aa:	f0 1f 00 25 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ae:	2f dd       	sub	sp,-12
800021b0:	58 05       	cp.w	r5,0
800021b2:	c4 10       	breq	80002234 <ButtonConfig_brdcst_func+0xb0>
800021b4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b6:	4a 64       	lddpc	r4,8000224c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b8:	4a 63       	lddpc	r3,80002250 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ba:	4a 72       	lddpc	r2,80002254 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021bc:	4a 71       	lddpc	r1,80002258 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021be:	4a 80       	lddpc	r0,8000225c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c0:	0f b9       	ld.ub	r9,r7[0x3]
800021c2:	0f c8       	ld.ub	r8,r7[0x4]
800021c4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c8:	1a d8       	st.w	--sp,r8
800021ca:	1a d6       	st.w	--sp,r6
800021cc:	08 9c       	mov	r12,r4
800021ce:	f0 1f 00 1c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d2:	0f d9       	ld.ub	r9,r7[0x5]
800021d4:	0f e8       	ld.ub	r8,r7[0x6]
800021d6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021da:	1a d8       	st.w	--sp,r8
800021dc:	1a d6       	st.w	--sp,r6
800021de:	06 9c       	mov	r12,r3
800021e0:	f0 1f 00 17 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e4:	0f f9       	ld.ub	r9,r7[0x7]
800021e6:	ef 38 00 08 	ld.ub	r8,r7[8]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	04 9c       	mov	r12,r2
800021f4:	f0 1f 00 12 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f8:	ef 39 00 09 	ld.ub	r9,r7[9]
800021fc:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002200:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002204:	1a d8       	st.w	--sp,r8
80002206:	1a d6       	st.w	--sp,r6
80002208:	02 9c       	mov	r12,r1
8000220a:	f0 1f 00 0d 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220e:	2f 8d       	sub	sp,-32
80002210:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002214:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	00 9c       	mov	r12,r0
80002222:	f0 1f 00 07 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
80002226:	2f f6       	sub	r6,-1
80002228:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000222a:	2f ed       	sub	sp,-8
8000222c:	ec 05 18 00 	cp.b	r5,r6
80002230:	fe 9b ff c8 	brhi	800021c0 <ButtonConfig_brdcst_func+0x3c>
80002234:	d8 32       	popm	r0-r7,pc
80002236:	00 00       	add	r0,r0
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	cf 08       	rjmp	8000241a <CallControl_brdcst_func+0x22>
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	6d 74       	ld.w	r4,r6[0x5c]
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	cf 28       	rjmp	80002426 <CallControl_brdcst_func+0x2e>
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	cf 3c       	rcall	8000242c <CallControl_brdcst_func+0x34>
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	cf 54       	brge	80002234 <ButtonConfig_brdcst_func+0xb0>
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	cf 74       	brge	8000223c <ButtonConfig_brdcst_func+0xb8>
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	cf 9c       	rcall	80002444 <TransmitControl_brdcst_func+0x8>
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	cf c4       	brge	8000224e <ButtonConfig_brdcst_func+0xca>
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	cf e8       	rjmp	80002456 <TransmitControl_brdcst_func+0x1a>
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	d0 10       	acall	0x1

80002260 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002260:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002264:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
80002266:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002268:	19 c7       	ld.ub	r7,r12[0x4]
8000226a:	19 d8       	ld.ub	r8,r12[0x5]
8000226c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002270:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002272:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002274:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002278:	49 0c       	lddpc	r12,800022b8 <Phyuserinput_brdcst_func+0x58>
8000227a:	f0 1f 00 11 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000227e:	1a d6       	st.w	--sp,r6
80002280:	49 0c       	lddpc	r12,800022c0 <Phyuserinput_brdcst_func+0x60>
80002282:	f0 1f 00 0f 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002286:	1a d5       	st.w	--sp,r5
80002288:	48 fc       	lddpc	r12,800022c4 <Phyuserinput_brdcst_func+0x64>
8000228a:	f0 1f 00 0d 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000228e:	5c 77       	castu.h	r7
80002290:	1a d7       	st.w	--sp,r7
80002292:	48 ec       	lddpc	r12,800022c8 <Phyuserinput_brdcst_func+0x68>
80002294:	f0 1f 00 0a 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002298:	1a d4       	st.w	--sp,r4
8000229a:	48 dc       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x6c>
8000229c:	f0 1f 00 08 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022a0:	1a d3       	st.w	--sp,r3
800022a2:	48 cc       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x70>
800022a4:	f0 1f 00 06 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022a8:	1a d2       	st.w	--sp,r2
800022aa:	48 bc       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x74>
800022ac:	f0 1f 00 04 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
800022b0:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022b2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022b6:	00 00       	add	r0,r0
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d0 34       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	6d 74       	ld.w	r4,r6[0x5c]
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	d0 58       	*unknown*
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d0 70       	acall	0x7
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d0 84       	*unknown*
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	d0 98       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	d0 ac       	*unknown*
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	d0 cc       	*unknown*

800022d8 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022dc:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022e0:	0f 89       	ld.ub	r9,r7[0x0]
800022e2:	30 08       	mov	r8,0
800022e4:	f0 09 18 00 	cp.b	r9,r8
800022e8:	c0 c1       	brne	80002300 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022ea:	48 9c       	lddpc	r12,8000230c <ButtonConfig_reply_func+0x34>
800022ec:	f0 1f 00 09 	mcall	80002310 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022f0:	0f 98       	ld.ub	r8,r7[0x1]
800022f2:	1a d8       	st.w	--sp,r8
800022f4:	48 8c       	lddpc	r12,80002314 <ButtonConfig_reply_func+0x3c>
800022f6:	f0 1f 00 07 	mcall	80002310 <ButtonConfig_reply_func+0x38>
800022fa:	2f fd       	sub	sp,-4
800022fc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002300:	48 6c       	lddpc	r12,80002318 <ButtonConfig_reply_func+0x40>
80002302:	f0 1f 00 04 	mcall	80002310 <ButtonConfig_reply_func+0x38>
80002306:	e3 cd 80 80 	ldm	sp++,r7,pc
8000230a:	00 00       	add	r0,r0
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	d0 ec       	*unknown*
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	6d 74       	ld.w	r4,r6[0x5c]
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	cf 28       	rjmp	800024fa <AudioRoutingControl_reply_func+0x16>
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	d1 04       	*unknown*

8000231c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000231c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000231e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002322:	0d 88       	ld.ub	r8,r6[0x0]
80002324:	32 49       	mov	r9,36
80002326:	f2 08 18 00 	cp.b	r8,r9
8000232a:	c2 91       	brne	8000237c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000232c:	49 7c       	lddpc	r12,80002388 <DataSession_brdcst_func+0x6c>
8000232e:	f0 1f 00 18 	mcall	8000238c <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002332:	0d a5       	ld.ub	r5,r6[0x2]
80002334:	0d b8       	ld.ub	r8,r6[0x3]
80002336:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000233a:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000233c:	0d 98       	ld.ub	r8,r6[0x1]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	49 4c       	lddpc	r12,80002390 <DataSession_brdcst_func+0x74>
80002342:	f0 1f 00 13 	mcall	8000238c <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002346:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000234a:	1a d8       	st.w	--sp,r8
8000234c:	49 2c       	lddpc	r12,80002394 <DataSession_brdcst_func+0x78>
8000234e:	f0 1f 00 10 	mcall	8000238c <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002352:	2f ed       	sub	sp,-8
80002354:	58 05       	cp.w	r5,0
80002356:	c1 80       	breq	80002386 <DataSession_brdcst_func+0x6a>
80002358:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000235a:	49 04       	lddpc	r4,80002398 <DataSession_brdcst_func+0x7c>
8000235c:	ec 07 00 08 	add	r8,r6,r7
80002360:	11 c8       	ld.ub	r8,r8[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	1a d7       	st.w	--sp,r7
80002366:	08 9c       	mov	r12,r4
80002368:	f0 1f 00 09 	mcall	8000238c <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000236c:	2f f7       	sub	r7,-1
8000236e:	5c 57       	castu.b	r7
80002370:	2f ed       	sub	sp,-8
80002372:	ee 05 19 00 	cp.h	r5,r7
80002376:	fe 9b ff f3 	brhi	8000235c <DataSession_brdcst_func+0x40>
8000237a:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
8000237c:	1a d8       	st.w	--sp,r8
8000237e:	48 8c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x80>
80002380:	f0 1f 00 03 	mcall	8000238c <DataSession_brdcst_func+0x70>
80002384:	2f fd       	sub	sp,-4
80002386:	d8 22       	popm	r4-r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d1 20       	acall	0x12
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	6d 74       	ld.w	r4,r6[0x5c]
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	d1 34       	*unknown*
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	d1 4c       	*unknown*
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	d1 68       	*unknown*
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	d1 80       	acall	0x18

800023a0 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023a0:	eb cd 40 80 	pushm	r7,lr
800023a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023a6:	19 a8       	ld.ub	r8,r12[0x2]
800023a8:	58 08       	cp.w	r8,0
800023aa:	c0 61       	brne	800023b6 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023ac:	48 dc       	lddpc	r12,800023e0 <DataSession_reply_func+0x40>
800023ae:	f0 1f 00 0e 	mcall	800023e4 <DataSession_reply_func+0x44>
800023b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023b6:	1a d8       	st.w	--sp,r8
800023b8:	48 cc       	lddpc	r12,800023e8 <DataSession_reply_func+0x48>
800023ba:	f0 1f 00 0b 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023be:	48 cc       	lddpc	r12,800023ec <DataSession_reply_func+0x4c>
800023c0:	f0 1f 00 09 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023c4:	0f b8       	ld.ub	r8,r7[0x3]
800023c6:	1a d8       	st.w	--sp,r8
800023c8:	48 ac       	lddpc	r12,800023f0 <DataSession_reply_func+0x50>
800023ca:	f0 1f 00 07 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023ce:	0f c8       	ld.ub	r8,r7[0x4]
800023d0:	1a d8       	st.w	--sp,r8
800023d2:	48 9c       	lddpc	r12,800023f4 <DataSession_reply_func+0x54>
800023d4:	f0 1f 00 04 	mcall	800023e4 <DataSession_reply_func+0x44>
800023d8:	2f dd       	sub	sp,-12
800023da:	e3 cd 80 80 	ldm	sp++,r7,pc
800023de:	00 00       	add	r0,r0
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	d1 94       	*unknown*
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	6d 74       	ld.w	r4,r6[0x5c]
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d1 a8       	*unknown*
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	d1 bc       	*unknown*
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	d1 d0       	acall	0x1d
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d1 e0       	acall	0x1e

800023f8 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002400:	0f 98       	ld.ub	r8,r7[0x1]
80002402:	1a d8       	st.w	--sp,r8
80002404:	48 bc       	lddpc	r12,80002430 <CallControl_brdcst_func+0x38>
80002406:	f0 1f 00 0c 	mcall	80002434 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000240a:	2f fd       	sub	sp,-4
8000240c:	0f 99       	ld.ub	r9,r7[0x1]
8000240e:	30 38       	mov	r8,3
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c0 41       	brne	8000241c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002416:	30 09       	mov	r9,0
80002418:	48 88       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000241a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 48       	mov	r8,4
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002426:	30 19       	mov	r9,1
80002428:	48 48       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
8000242c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	d1 f0       	acall	0x1f
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	6d 74       	ld.w	r4,r6[0x5c]
80002438:	00 00       	add	r0,r0
8000243a:	0a 49       	or	r9,r5

8000243c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000243c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002440:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002444:	0f 99       	ld.ub	r9,r7[0x1]
80002446:	30 08       	mov	r8,0
80002448:	f0 09 18 00 	cp.b	r9,r8
8000244c:	c0 71       	brne	8000245a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000244e:	48 ac       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x38>
80002450:	f0 1f 00 0a 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002454:	30 09       	mov	r9,0
80002456:	48 a8       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
80002458:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000245a:	0f 99       	ld.ub	r9,r7[0x1]
8000245c:	30 18       	mov	r8,1
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 71       	brne	80002470 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002464:	48 7c       	lddpc	r12,80002480 <TransmitControl_brdcst_func+0x44>
80002466:	f0 1f 00 05 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000246a:	30 19       	mov	r9,1
8000246c:	48 48       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
8000246e:	b0 89       	st.b	r8[0x0],r9
80002470:	e3 cd 80 80 	ldm	sp++,r7,pc
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	d2 08       	*unknown*
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	6d 74       	ld.w	r4,r6[0x5c]
8000247c:	00 00       	add	r0,r0
8000247e:	0a 48       	or	r8,r5
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d2 20       	acall	0x22

80002484 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000248c:	0f 89       	ld.ub	r9,r7[0x0]
8000248e:	30 08       	mov	r8,0
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c1 61       	brne	800024c0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002496:	48 ec       	lddpc	r12,800024cc <TransmitControl_reply_func+0x48>
80002498:	f0 1f 00 0e 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000249c:	0f 98       	ld.ub	r8,r7[0x1]
8000249e:	1a d8       	st.w	--sp,r8
800024a0:	48 dc       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x50>
800024a2:	f0 1f 00 0c 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024a6:	0f a8       	ld.ub	r8,r7[0x2]
800024a8:	1a d8       	st.w	--sp,r8
800024aa:	48 cc       	lddpc	r12,800024d8 <TransmitControl_reply_func+0x54>
800024ac:	f0 1f 00 09 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024b0:	0f b8       	ld.ub	r8,r7[0x3]
800024b2:	1a d8       	st.w	--sp,r8
800024b4:	48 ac       	lddpc	r12,800024dc <TransmitControl_reply_func+0x58>
800024b6:	f0 1f 00 07 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024ba:	2f dd       	sub	sp,-12
800024bc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024c0:	48 8c       	lddpc	r12,800024e0 <TransmitControl_reply_func+0x5c>
800024c2:	f0 1f 00 04 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ca:	00 00       	add	r0,r0
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	d2 34       	*unknown*
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	6d 74       	ld.w	r4,r6[0x5c]
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	d2 50       	acall	0x25
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	d2 64       	*unknown*
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d2 80       	acall	0x28
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	d2 90       	acall	0x29

800024e4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024e6:	19 a9       	ld.ub	r9,r12[0x2]
800024e8:	30 08       	mov	r8,0
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
800024f0:	48 5c       	lddpc	r12,80002504 <AudioRoutingControl_reply_func+0x20>
800024f2:	f0 1f 00 06 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
800024f6:	f0 1f 00 06 	mcall	8000250c <AudioRoutingControl_reply_func+0x28>
800024fa:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024fc:	48 5c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x2c>
800024fe:	f0 1f 00 03 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
80002502:	d8 02       	popm	pc
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	d2 a8       	*unknown*
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	6d 74       	ld.w	r4,r6[0x5c]
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	46 58       	lddsp	r8,sp[0x194]
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	d2 b8       	*unknown*

80002514 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002514:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002518:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000251c:	0f 89       	ld.ub	r9,r7[0x0]
8000251e:	30 08       	mov	r8,0
80002520:	f0 09 18 00 	cp.b	r9,r8
80002524:	c1 b1       	brne	8000255a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002526:	0f b8       	ld.ub	r8,r7[0x3]
80002528:	31 09       	mov	r9,16
8000252a:	f2 08 18 00 	cp.b	r8,r9
8000252e:	c0 f1       	brne	8000254c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002530:	48 dc       	lddpc	r12,80002564 <Volume_reply_func+0x50>
80002532:	f0 1f 00 0e 	mcall	80002568 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002536:	0f 99       	ld.ub	r9,r7[0x1]
80002538:	0f a8       	ld.ub	r8,r7[0x2]
8000253a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 bc       	lddpc	r12,8000256c <Volume_reply_func+0x58>
80002542:	f0 1f 00 0a 	mcall	80002568 <Volume_reply_func+0x54>
80002546:	2f fd       	sub	sp,-4
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 9c       	lddpc	r12,80002570 <Volume_reply_func+0x5c>
80002550:	f0 1f 00 06 	mcall	80002568 <Volume_reply_func+0x54>
80002554:	2f fd       	sub	sp,-4
80002556:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000255a:	48 7c       	lddpc	r12,80002574 <Volume_reply_func+0x60>
8000255c:	f0 1f 00 03 	mcall	80002568 <Volume_reply_func+0x54>
80002560:	e3 cd 80 80 	ldm	sp++,r7,pc
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d2 cc       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	6d 74       	ld.w	r4,r6[0x5c]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d2 e0       	acall	0x2e
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	d2 fc       	*unknown*
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d3 14       	*unknown*

80002578 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000257a:	19 d9       	ld.ub	r9,r12[0x5]
8000257c:	30 08       	mov	r8,0
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 81       	brne	80002592 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002584:	10 99       	mov	r9,r8
80002586:	48 78       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002588:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000258a:	48 7c       	lddpc	r12,800025a4 <spk_brdcst_func+0x2c>
8000258c:	f0 1f 00 07 	mcall	800025a8 <spk_brdcst_func+0x30>
80002590:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002592:	30 19       	mov	r9,1
80002594:	48 38       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002596:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002598:	48 5c       	lddpc	r12,800025ac <spk_brdcst_func+0x34>
8000259a:	f0 1f 00 04 	mcall	800025a8 <spk_brdcst_func+0x30>
8000259e:	d8 02       	popm	pc
800025a0:	00 00       	add	r0,r0
800025a2:	0a 40       	or	r0,r5
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	d3 2c       	*unknown*
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	6d 74       	ld.w	r4,r6[0x5c]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	d3 3c       	*unknown*

800025b0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025b2:	19 a9       	ld.ub	r9,r12[0x2]
800025b4:	30 08       	mov	r8,0
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 f1       	brne	800025d8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025bc:	19 e9       	ld.ub	r9,r12[0x6]
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 40       	breq	800025ca <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025c4:	30 19       	mov	r9,1
800025c6:	48 98       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025ca:	19 e8       	ld.ub	r8,r12[0x6]
800025cc:	1a d8       	st.w	--sp,r8
800025ce:	48 8c       	lddpc	r12,800025ec <spk_reply_func+0x3c>
800025d0:	f0 1f 00 08 	mcall	800025f0 <spk_reply_func+0x40>
800025d4:	2f fd       	sub	sp,-4
800025d6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025d8:	30 09       	mov	r9,0
800025da:	48 48       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025dc:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025de:	48 6c       	lddpc	r12,800025f4 <spk_reply_func+0x44>
800025e0:	f0 1f 00 04 	mcall	800025f0 <spk_reply_func+0x40>
800025e4:	d8 02       	popm	pc
800025e6:	00 00       	add	r0,r0
800025e8:	00 00       	add	r0,r0
800025ea:	0a 40       	or	r0,r5
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	d3 48       	*unknown*
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	6d 74       	ld.w	r4,r6[0x5c]
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d3 58       	*unknown*

800025f8 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002600:	0f a9       	ld.ub	r9,r7[0x2]
80002602:	30 08       	mov	r8,0
80002604:	f0 09 18 00 	cp.b	r9,r8
80002608:	c0 71       	brne	80002616 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000260a:	48 dc       	lddpc	r12,8000263c <mic_brdcst_func+0x44>
8000260c:	f0 1f 00 0d 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002610:	30 09       	mov	r9,0
80002612:	48 d8       	lddpc	r8,80002644 <mic_brdcst_func+0x4c>
80002614:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002616:	0f a9       	ld.ub	r9,r7[0x2]
80002618:	31 18       	mov	r8,17
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 d1       	brne	80002638 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002620:	48 ac       	lddpc	r12,80002648 <mic_brdcst_func+0x50>
80002622:	f0 1f 00 08 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002626:	48 89       	lddpc	r9,80002644 <mic_brdcst_func+0x4c>
80002628:	30 18       	mov	r8,1
8000262a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000262c:	13 89       	ld.ub	r9,r9[0x0]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 31       	brne	80002638 <mic_brdcst_func+0x40>
80002634:	48 68       	lddpc	r8,8000264c <mic_brdcst_func+0x54>
80002636:	11 88       	ld.ub	r8,r8[0x0]
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	d3 64       	*unknown*
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	6d 74       	ld.w	r4,r6[0x5c]
80002644:	00 00       	add	r0,r0
80002646:	0a 50       	eor	r0,r5
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d3 78       	*unknown*
8000264c:	00 00       	add	r0,r0
8000264e:	0a 49       	or	r9,r5

80002650 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002650:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002654:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002658:	49 ac       	lddpc	r12,800026c0 <mic_reply_func+0x70>
8000265a:	f0 1f 00 1b 	mcall	800026c4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000265e:	0f 89       	ld.ub	r9,r7[0x0]
80002660:	30 08       	mov	r8,0
80002662:	f0 09 18 00 	cp.b	r9,r8
80002666:	c2 71       	brne	800026b4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002668:	0f 98       	ld.ub	r8,r7[0x1]
8000266a:	30 29       	mov	r9,2
8000266c:	f2 08 18 00 	cp.b	r8,r9
80002670:	c1 b1       	brne	800026a6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002672:	49 6c       	lddpc	r12,800026c8 <mic_reply_func+0x78>
80002674:	f0 1f 00 14 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002678:	0f a8       	ld.ub	r8,r7[0x2]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 4c       	lddpc	r12,800026cc <mic_reply_func+0x7c>
8000267e:	f0 1f 00 12 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002682:	0f b8       	ld.ub	r8,r7[0x3]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 3c       	lddpc	r12,800026d0 <mic_reply_func+0x80>
80002688:	f0 1f 00 0f 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000268c:	0f c8       	ld.ub	r8,r7[0x4]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 1c       	lddpc	r12,800026d4 <mic_reply_func+0x84>
80002692:	f0 1f 00 0d 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002696:	0f d8       	ld.ub	r8,r7[0x5]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 0c       	lddpc	r12,800026d8 <mic_reply_func+0x88>
8000269c:	f0 1f 00 0a 	mcall	800026c4 <mic_reply_func+0x74>
800026a0:	2f cd       	sub	sp,-16
800026a2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026a6:	1a d8       	st.w	--sp,r8
800026a8:	48 dc       	lddpc	r12,800026dc <mic_reply_func+0x8c>
800026aa:	f0 1f 00 07 	mcall	800026c4 <mic_reply_func+0x74>
800026ae:	2f fd       	sub	sp,-4
800026b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026b4:	48 bc       	lddpc	r12,800026e0 <mic_reply_func+0x90>
800026b6:	f0 1f 00 04 	mcall	800026c4 <mic_reply_func+0x74>
800026ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800026be:	00 00       	add	r0,r0
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	d3 8c       	*unknown*
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	6d 74       	ld.w	r4,r6[0x5c]
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d3 9c       	*unknown*
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d3 b0       	acall	0x3b
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	d3 c4       	*unknown*
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d3 e0       	acall	0x3e
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d3 f8       	*unknown*
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d4 10       	acall	0x41
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d4 28       	*unknown*

800026e4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026e4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026e8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026ec:	48 bc       	lddpc	r12,80002718 <dcm_brdcst_func+0x34>
800026ee:	f0 1f 00 0c 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026f2:	0f 88       	ld.ub	r8,r7[0x0]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x3c>
800026f8:	f0 1f 00 09 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026fc:	0f a8       	ld.ub	r8,r7[0x2]
800026fe:	1a d8       	st.w	--sp,r8
80002700:	48 9c       	lddpc	r12,80002724 <dcm_brdcst_func+0x40>
80002702:	f0 1f 00 07 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002706:	0f 98       	ld.ub	r8,r7[0x1]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 8c       	lddpc	r12,80002728 <dcm_brdcst_func+0x44>
8000270c:	f0 1f 00 04 	mcall	8000271c <dcm_brdcst_func+0x38>
80002710:	2f dd       	sub	sp,-12
	
	
}
80002712:	e3 cd 80 80 	ldm	sp++,r7,pc
80002716:	00 00       	add	r0,r0
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d4 38       	*unknown*
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	6d 74       	ld.w	r4,r6[0x5c]
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d4 4c       	*unknown*
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	d4 60       	acall	0x46
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d4 78       	*unknown*

8000272c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002732:	19 a9       	ld.ub	r9,r12[0x2]
80002734:	30 08       	mov	r8,0
80002736:	f0 09 18 00 	cp.b	r9,r8
8000273a:	c1 b1       	brne	80002770 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000273c:	19 b8       	ld.ub	r8,r12[0x3]
8000273e:	30 19       	mov	r9,1
80002740:	f2 08 18 00 	cp.b	r8,r9
80002744:	c0 51       	brne	8000274e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002746:	48 ec       	lddpc	r12,8000277c <dcm_reply_func+0x50>
80002748:	f0 1f 00 0e 	mcall	80002780 <dcm_reply_func+0x54>
8000274c:	c0 a8       	rjmp	80002760 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 51       	brne	8000275a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002752:	48 dc       	lddpc	r12,80002784 <dcm_reply_func+0x58>
80002754:	f0 1f 00 0b 	mcall	80002780 <dcm_reply_func+0x54>
80002758:	c0 48       	rjmp	80002760 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000275a:	48 cc       	lddpc	r12,80002788 <dcm_reply_func+0x5c>
8000275c:	f0 1f 00 09 	mcall	80002780 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002760:	0f d8       	ld.ub	r8,r7[0x5]
80002762:	1a d8       	st.w	--sp,r8
80002764:	48 ac       	lddpc	r12,8000278c <dcm_reply_func+0x60>
80002766:	f0 1f 00 07 	mcall	80002780 <dcm_reply_func+0x54>
8000276a:	2f fd       	sub	sp,-4
8000276c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002770:	48 8c       	lddpc	r12,80002790 <dcm_reply_func+0x64>
80002772:	f0 1f 00 04 	mcall	80002780 <dcm_reply_func+0x54>
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	d4 94       	*unknown*
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	6d 74       	ld.w	r4,r6[0x5c]
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d4 a8       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	d4 bc       	*unknown*
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d4 d0       	acall	0x4d
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	d4 dc       	*unknown*

80002794 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002794:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002796:	19 a9       	ld.ub	r9,r12[0x2]
80002798:	30 08       	mov	r8,0
8000279a:	f0 09 18 00 	cp.b	r9,r8
8000279e:	c0 51       	brne	800027a8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027a0:	48 4c       	lddpc	r12,800027b0 <ToneControl_reply_func+0x1c>
800027a2:	f0 1f 00 05 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027a6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x24>
800027aa:	f0 1f 00 03 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	d4 e8       	*unknown*
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	6d 74       	ld.w	r4,r6[0x5c]
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d4 f0       	acall	0x4f

800027bc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027be:	f0 1f 00 1e 	mcall	80002834 <app_cfg+0x78>
800027c2:	49 e8       	lddpc	r8,80002838 <app_cfg+0x7c>
800027c4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027c6:	49 e6       	lddpc	r6,8000283c <app_cfg+0x80>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027c8:	49 e3       	lddpc	r3,80002840 <app_cfg+0x84>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027ca:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027cc:	30 31       	mov	r1,3
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ce:	30 12       	mov	r2,1
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
800027d0:	49 d5       	lddpc	r5,80002844 <app_cfg+0x88>
800027d2:	49 e7       	lddpc	r7,80002848 <app_cfg+0x8c>
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027d4:	10 94       	mov	r4,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027d6:	6c 08       	ld.w	r8,r6[0x0]
800027d8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027dc:	58 38       	cp.w	r8,3
800027de:	c1 e1       	brne	8000281a <app_cfg+0x5e>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800027e0:	f0 1f 00 1b 	mcall	8000284c <app_cfg+0x90>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027e4:	66 08       	ld.w	r8,r3[0x0]
800027e6:	58 08       	cp.w	r8,0
800027e8:	c0 71       	brne	800027f6 <app_cfg+0x3a>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800027ea:	f0 1f 00 1a 	mcall	80002850 <app_cfg+0x94>
					xcmp_enter_enhanced_OB_mode();
800027ee:	f0 1f 00 1a 	mcall	80002854 <app_cfg+0x98>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027f2:	87 02       	st.w	r3[0x0],r2
800027f4:	c1 38       	rjmp	8000281a <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800027f6:	58 18       	cp.w	r8,1
800027f8:	c0 61       	brne	80002804 <app_cfg+0x48>
				{
					//xcmp_exit_device_control_mode();
					xcmp_audio_route_AMBE();
800027fa:	f0 1f 00 18 	mcall	80002858 <app_cfg+0x9c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027fe:	30 28       	mov	r8,2
80002800:	87 08       	st.w	r3[0x0],r8
80002802:	c0 c8       	rjmp	8000281a <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002804:	58 28       	cp.w	r8,2
80002806:	c0 31       	brne	8000280c <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002808:	87 01       	st.w	r3[0x0],r1
8000280a:	c0 88       	rjmp	8000281a <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000280c:	58 38       	cp.w	r8,3
8000280e:	e7 f0 0a 00 	st.weq	r3[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
80002812:	f7 b8 01 ff 	subne	r8,-1
80002816:	e7 f8 1a 00 	st.wne	r3[0x0],r8
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
8000281a:	6e 08       	ld.w	r8,r7[0x0]
8000281c:	1a d8       	st.w	--sp,r8
8000281e:	0a 9c       	mov	r12,r5
80002820:	f0 1f 00 0f 	mcall	8000285c <app_cfg+0xa0>
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002824:	e0 6b 0f a0 	mov	r11,4000
80002828:	08 9c       	mov	r12,r4
8000282a:	f0 1f 00 0e 	mcall	80002860 <app_cfg+0xa4>
	}
8000282e:	2f fd       	sub	sp,-4
80002830:	cd 3b       	rjmp	800027d6 <app_cfg+0x1a>
80002832:	00 00       	add	r0,r0
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	66 e8       	ld.w	r8,r3[0x38]
80002838:	00 00       	add	r0,r0
8000283a:	0a 54       	eor	r4,r5
8000283c:	00 00       	add	r0,r0
8000283e:	0d 84       	ld.ub	r4,r6[0x0]
80002840:	00 00       	add	r0,r0
80002842:	0a 44       	or	r4,r5
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d4 fc       	*unknown*
80002848:	00 00       	add	r0,r0
8000284a:	0a 5c       	eor	r12,r5
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	46 58       	lddsp	r8,sp[0x194]
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	44 fc       	lddsp	r12,sp[0x13c]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	45 88       	lddsp	r8,sp[0x160]
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	45 28       	lddsp	r8,sp[0x148]
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	6d 74       	ld.w	r4,r6[0x5c]
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	68 50       	ld.w	r0,r4[0x14]

80002864 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002864:	eb cd 40 80 	pushm	r7,lr
80002868:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000286a:	48 c9       	lddpc	r9,80002898 <app_payload_rx_proc+0x34>
8000286c:	13 88       	ld.ub	r8,r9[0x0]
8000286e:	2f f8       	sub	r8,-1
80002870:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002872:	30 39       	mov	r9,3
80002874:	f2 08 18 00 	cp.b	r8,r9
80002878:	c0 71       	brne	80002886 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000287a:	30 09       	mov	r9,0
8000287c:	48 78       	lddpc	r8,80002898 <app_payload_rx_proc+0x34>
8000287e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002880:	48 7c       	lddpc	r12,8000289c <app_payload_rx_proc+0x38>
80002882:	f0 1f 00 08 	mcall	800028a0 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002886:	48 88       	lddpc	r8,800028a4 <app_payload_rx_proc+0x40>
80002888:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000288a:	48 88       	lddpc	r8,800028a8 <app_payload_rx_proc+0x44>
8000288c:	70 0c       	ld.w	r12,r8[0x0]
8000288e:	0e 9b       	mov	r11,r7
80002890:	f0 1f 00 07 	mcall	800028ac <app_payload_rx_proc+0x48>

}
80002894:	e3 cd 80 80 	ldm	sp++,r7,pc
80002898:	00 00       	add	r0,r0
8000289a:	0a 58       	eor	r8,r5
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d5 18       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	6d 74       	ld.w	r4,r6[0x5c]
800028a4:	00 00       	add	r0,r0
800028a6:	0a 51       	eor	r1,r5
800028a8:	00 00       	add	r0,r0
800028aa:	0a 78       	tst	r8,r5
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	30 00       	mov	r0,0

800028b0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028b0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028b2:	19 e8       	ld.ub	r8,r12[0x6]
800028b4:	30 19       	mov	r9,1
800028b6:	f2 08 18 00 	cp.b	r8,r9
800028ba:	c0 61       	brne	800028c6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028bc:	48 98       	lddpc	r8,800028e0 <DeviceInitializationStatus_brdcst_func+0x30>
800028be:	70 09       	ld.w	r9,r8[0x0]
800028c0:	a1 a9       	sbr	r9,0x0
800028c2:	91 09       	st.w	r8[0x0],r9
800028c4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028c6:	30 29       	mov	r9,2
800028c8:	f2 08 18 00 	cp.b	r8,r9
800028cc:	c0 80       	breq	800028dc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ce:	48 58       	lddpc	r8,800028e0 <DeviceInitializationStatus_brdcst_func+0x30>
800028d0:	70 09       	ld.w	r9,r8[0x0]
800028d2:	e0 19 ff fc 	andl	r9,0xfffc
800028d6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028d8:	f0 1f 00 03 	mcall	800028e4 <DeviceInitializationStatus_brdcst_func+0x34>
800028dc:	d8 02       	popm	pc
800028de:	00 00       	add	r0,r0
800028e0:	00 00       	add	r0,r0
800028e2:	0d 84       	ld.ub	r4,r6[0x0]
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	45 ac       	lddsp	r12,sp[0x168]

800028e8 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028e8:	eb cd 40 fc 	pushm	r2-r7,lr
800028ec:	20 1d       	sub	sp,4
800028ee:	18 97       	mov	r7,r12
800028f0:	14 95       	mov	r5,r10
800028f2:	12 96       	mov	r6,r9
	U16 status = 1;
800028f4:	30 18       	mov	r8,1
800028f6:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028f8:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028fc:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002900:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80002904:	30 0b       	mov	r11,0
80002906:	4e 38       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
80002908:	70 0c       	ld.w	r12,r8[0x0]
8000290a:	f0 1f 00 63 	mcall	80002a94 <send_flash_command+0x1ac>

    switch (command)
8000290e:	30 58       	mov	r8,5
80002910:	f0 07 19 00 	cp.h	r7,r8
80002914:	c3 40       	breq	8000297c <send_flash_command+0x94>
80002916:	e0 8b 00 18 	brhi	80002946 <send_flash_command+0x5e>
8000291a:	30 28       	mov	r8,2
8000291c:	f0 07 19 00 	cp.h	r7,r8
80002920:	c5 e0       	breq	800029dc <send_flash_command+0xf4>
80002922:	e0 8b 00 08 	brhi	80002932 <send_flash_command+0x4a>
80002926:	30 18       	mov	r8,1
80002928:	f0 07 19 00 	cp.h	r7,r8
8000292c:	e0 81 00 a9 	brne	80002a7e <send_flash_command+0x196>
80002930:	c9 e8       	rjmp	80002a6c <send_flash_command+0x184>
80002932:	30 38       	mov	r8,3
80002934:	f0 07 19 00 	cp.h	r7,r8
80002938:	c7 20       	breq	80002a1c <send_flash_command+0x134>
8000293a:	30 48       	mov	r8,4
8000293c:	f0 07 19 00 	cp.h	r7,r8
80002940:	e0 81 00 9f 	brne	80002a7e <send_flash_command+0x196>
80002944:	c2 c8       	rjmp	8000299c <send_flash_command+0xb4>
80002946:	35 28       	mov	r8,82
80002948:	f0 07 19 00 	cp.h	r7,r8
8000294c:	c2 f0       	breq	800029aa <send_flash_command+0xc2>
8000294e:	e0 8b 00 0c 	brhi	80002966 <send_flash_command+0x7e>
80002952:	30 68       	mov	r8,6
80002954:	f0 07 19 00 	cp.h	r7,r8
80002958:	c2 20       	breq	8000299c <send_flash_command+0xb4>
8000295a:	32 08       	mov	r8,32
8000295c:	f0 07 19 00 	cp.h	r7,r8
80002960:	e0 81 00 8f 	brne	80002a7e <send_flash_command+0x196>
80002964:	c2 38       	rjmp	800029aa <send_flash_command+0xc2>
80002966:	36 08       	mov	r8,96
80002968:	f0 07 19 00 	cp.h	r7,r8
8000296c:	c3 20       	breq	800029d0 <send_flash_command+0xe8>
8000296e:	e0 68 00 d8 	mov	r8,216
80002972:	f0 07 19 00 	cp.h	r7,r8
80002976:	e0 81 00 84 	brne	80002a7e <send_flash_command+0x196>
8000297a:	c1 88       	rjmp	800029aa <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
8000297c:	4c 57       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
8000297e:	30 5b       	mov	r11,5
80002980:	6e 0c       	ld.w	r12,r7[0x0]
80002982:	f0 1f 00 46 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_dummy();
80002986:	e0 6b 00 ff 	mov	r11,255
8000298a:	6e 0c       	ld.w	r12,r7[0x0]
8000298c:	f0 1f 00 43 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_read_byte(&status);
80002990:	fa cb ff fe 	sub	r11,sp,-2
80002994:	6e 0c       	ld.w	r12,r7[0x0]
80002996:	f0 1f 00 42 	mcall	80002a9c <send_flash_command+0x1b4>
			break;
8000299a:	c7 28       	rjmp	80002a7e <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
8000299c:	0e 9b       	mov	r11,r7
8000299e:	5c 7b       	castu.h	r11
800029a0:	4b c8       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
800029a2:	70 0c       	ld.w	r12,r8[0x0]
800029a4:	f0 1f 00 3d 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029a8:	c6 b8       	rjmp	80002a7e <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800029aa:	4b a6       	lddpc	r6,80002a90 <send_flash_command+0x1a8>
800029ac:	0e 9b       	mov	r11,r7
800029ae:	5c 7b       	castu.h	r11
800029b0:	6c 0c       	ld.w	r12,r6[0x0]
800029b2:	f0 1f 00 3a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029b6:	08 9b       	mov	r11,r4
800029b8:	6c 0c       	ld.w	r12,r6[0x0]
800029ba:	f0 1f 00 38 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029be:	06 9b       	mov	r11,r3
800029c0:	6c 0c       	ld.w	r12,r6[0x0]
800029c2:	f0 1f 00 36 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029c6:	04 9b       	mov	r11,r2
800029c8:	6c 0c       	ld.w	r12,r6[0x0]
800029ca:	f0 1f 00 34 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029ce:	c5 88       	rjmp	80002a7e <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029d0:	36 0b       	mov	r11,96
800029d2:	4b 08       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
800029d4:	70 0c       	ld.w	r12,r8[0x0]
800029d6:	f0 1f 00 31 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029da:	c5 28       	rjmp	80002a7e <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029dc:	4a d7       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
800029de:	30 2b       	mov	r11,2
800029e0:	6e 0c       	ld.w	r12,r7[0x0]
800029e2:	f0 1f 00 2e 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029e6:	08 9b       	mov	r11,r4
800029e8:	6e 0c       	ld.w	r12,r7[0x0]
800029ea:	f0 1f 00 2c 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ee:	06 9b       	mov	r11,r3
800029f0:	6e 0c       	ld.w	r12,r7[0x0]
800029f2:	f0 1f 00 2a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029f6:	04 9b       	mov	r11,r2
800029f8:	6e 0c       	ld.w	r12,r7[0x0]
800029fa:	f0 1f 00 28 	mcall	80002a98 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029fe:	58 06       	cp.w	r6,0
80002a00:	c3 f0       	breq	80002a7e <send_flash_command+0x196>
80002a02:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002a04:	4a 34       	lddpc	r4,80002a90 <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002a06:	0f 3b       	ld.ub	r11,r7++
80002a08:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002a0a:	68 0c       	ld.w	r12,r4[0x0]
80002a0c:	f0 1f 00 23 	mcall	80002a98 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a10:	0e 98       	mov	r8,r7
80002a12:	0a 18       	sub	r8,r5
80002a14:	ec 08 19 00 	cp.h	r8,r6
80002a18:	cf 73       	brcs	80002a06 <send_flash_command+0x11e>
80002a1a:	c3 28       	rjmp	80002a7e <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a1c:	49 d7       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
80002a1e:	30 3b       	mov	r11,3
80002a20:	6e 0c       	ld.w	r12,r7[0x0]
80002a22:	f0 1f 00 1e 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a26:	08 9b       	mov	r11,r4
80002a28:	6e 0c       	ld.w	r12,r7[0x0]
80002a2a:	f0 1f 00 1c 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a2e:	06 9b       	mov	r11,r3
80002a30:	6e 0c       	ld.w	r12,r7[0x0]
80002a32:	f0 1f 00 1a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a36:	04 9b       	mov	r11,r2
80002a38:	6e 0c       	ld.w	r12,r7[0x0]
80002a3a:	f0 1f 00 18 	mcall	80002a98 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a3e:	58 06       	cp.w	r6,0
80002a40:	c1 f0       	breq	80002a7e <send_flash_command+0x196>
80002a42:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a44:	49 34       	lddpc	r4,80002a90 <send_flash_command+0x1a8>
80002a46:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a4a:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a4c:	06 9b       	mov	r11,r3
80002a4e:	68 0c       	ld.w	r12,r4[0x0]
80002a50:	f0 1f 00 12 	mcall	80002a98 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a54:	1a 9b       	mov	r11,sp
80002a56:	68 0c       	ld.w	r12,r4[0x0]
80002a58:	f0 1f 00 11 	mcall	80002a9c <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a5c:	9a 08       	ld.sh	r8,sp[0x0]
80002a5e:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a60:	0e 98       	mov	r8,r7
80002a62:	0a 18       	sub	r8,r5
80002a64:	ec 08 19 00 	cp.h	r8,r6
80002a68:	cf 23       	brcs	80002a4c <send_flash_command+0x164>
80002a6a:	c0 a8       	rjmp	80002a7e <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a6c:	48 97       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
80002a6e:	30 1b       	mov	r11,1
80002a70:	6e 0c       	ld.w	r12,r7[0x0]
80002a72:	f0 1f 00 0a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a76:	30 0b       	mov	r11,0
80002a78:	6e 0c       	ld.w	r12,r7[0x0]
80002a7a:	f0 1f 00 08 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a7e:	30 0b       	mov	r11,0
80002a80:	48 48       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
80002a82:	70 0c       	ld.w	r12,r8[0x0]
80002a84:	f0 1f 00 07 	mcall	80002aa0 <send_flash_command+0x1b8>

	return status;
}
80002a88:	9a 1c       	ld.sh	r12,sp[0x2]
80002a8a:	2f fd       	sub	sp,-4
80002a8c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a90:	00 00       	add	r0,r0
80002a92:	1d 88       	ld.ub	r8,lr[0x0]
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	55 80       	stdsp	sp[0x160],r0
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	56 ba       	stdsp	sp[0x1ac],r10
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	56 d6       	stdsp	sp[0x1b4],r6
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	55 cc       	stdsp	sp[0x170],r12

80002aa4 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002aa4:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002aa6:	58 0a       	cp.w	r10,0
80002aa8:	5f 09       	sreq	r9
80002aaa:	e0 68 ff fe 	mov	r8,65534
80002aae:	ea 18 00 7f 	orh	r8,0x7f
80002ab2:	10 3c       	cp.w	r12,r8
80002ab4:	5f b8       	srhi	r8
80002ab6:	f3 e8 10 08 	or	r8,r9,r8
80002aba:	c0 e1       	brne	80002ad6 <data_flash_read_block+0x32>
80002abc:	e0 68 10 00 	mov	r8,4096
80002ac0:	f0 0b 19 00 	cp.h	r11,r8
80002ac4:	e0 8b 00 09 	brhi	80002ad6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ac8:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002acc:	18 9b       	mov	r11,r12
80002ace:	30 3c       	mov	r12,3
80002ad0:	f0 1f 00 02 	mcall	80002ad8 <data_flash_read_block+0x34>
80002ad4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ad6:	da 0a       	popm	pc,r12=1
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	28 e8       	sub	r8,-114

80002adc <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002adc:	eb cd 40 e0 	pushm	r5-r7,lr
80002ae0:	18 96       	mov	r6,r12
80002ae2:	16 97       	mov	r7,r11
80002ae4:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ae6:	58 0c       	cp.w	r12,0
80002ae8:	5f 09       	sreq	r9
80002aea:	e0 68 ff fe 	mov	r8,65534
80002aee:	ea 18 00 7f 	orh	r8,0x7f
80002af2:	10 3b       	cp.w	r11,r8
80002af4:	5f b8       	srhi	r8
80002af6:	f3 e8 10 08 	or	r8,r9,r8
80002afa:	c3 91       	brne	80002b6c <data_flash_write_page+0x90>
80002afc:	e0 68 01 00 	mov	r8,256
80002b00:	f0 0a 19 00 	cp.h	r10,r8
80002b04:	e0 8b 00 34 	brhi	80002b6c <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b08:	30 09       	mov	r9,0
80002b0a:	12 9a       	mov	r10,r9
80002b0c:	12 9b       	mov	r11,r9
80002b0e:	30 5c       	mov	r12,5
80002b10:	f0 1f 00 19 	mcall	80002b74 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002b14:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b18:	c0 30       	breq	80002b1e <data_flash_write_page+0x42>
80002b1a:	30 27       	mov	r7,2
80002b1c:	c2 98       	rjmp	80002b6e <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b1e:	30 09       	mov	r9,0
80002b20:	12 9a       	mov	r10,r9
80002b22:	12 9b       	mov	r11,r9
80002b24:	30 6c       	mov	r12,6
80002b26:	f0 1f 00 14 	mcall	80002b74 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002b2a:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002b2e:	0c 9a       	mov	r10,r6
80002b30:	0e 9b       	mov	r11,r7
80002b32:	30 2c       	mov	r12,2
80002b34:	f0 1f 00 10 	mcall	80002b74 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b38:	30 05       	mov	r5,0
80002b3a:	30 56       	mov	r6,5
80002b3c:	0a 99       	mov	r9,r5
80002b3e:	0a 9a       	mov	r10,r5
80002b40:	0a 9b       	mov	r11,r5
80002b42:	0c 9c       	mov	r12,r6
80002b44:	f0 1f 00 0c 	mcall	80002b74 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b48:	5c 7c       	castu.h	r12
80002b4a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b4e:	cf 71       	brne	80002b3c <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b50:	18 97       	mov	r7,r12
80002b52:	e2 17 00 20 	andl	r7,0x20,COH
80002b56:	f9 b7 01 06 	movne	r7,6
80002b5a:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b5e:	30 09       	mov	r9,0
80002b60:	12 9a       	mov	r10,r9
80002b62:	12 9b       	mov	r11,r9
80002b64:	30 4c       	mov	r12,4
80002b66:	f0 1f 00 04 	mcall	80002b74 <data_flash_write_page+0x98>

	return return_code;
80002b6a:	c0 28       	rjmp	80002b6e <data_flash_write_page+0x92>
80002b6c:	30 17       	mov	r7,1
}
80002b6e:	0e 9c       	mov	r12,r7
80002b70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	28 e8       	sub	r8,-114

80002b78 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b78:	d4 31       	pushm	r0-r7,lr
80002b7a:	18 94       	mov	r4,r12
80002b7c:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b80:	16 97       	mov	r7,r11
80002b82:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b84:	30 03       	mov	r3,0
80002b86:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b88:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b8c:	c4 98       	rjmp	80002c1e <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b8e:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b92:	c1 b1       	brne	80002bc8 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b94:	e0 06 19 00 	cp.h	r6,r0
80002b98:	e0 8b 00 0a 	brhi	80002bac <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b9c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002ba0:	0e 9b       	mov	r11,r7
80002ba2:	08 9c       	mov	r12,r4
80002ba4:	f0 1f 00 24 	mcall	80002c34 <data_flash_write_block+0xbc>
80002ba8:	30 06       	mov	r6,0
80002baa:	c3 a8       	rjmp	80002c1e <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002bac:	e0 6a 01 00 	mov	r10,256
80002bb0:	0e 9b       	mov	r11,r7
80002bb2:	08 9c       	mov	r12,r4
80002bb4:	f0 1f 00 20 	mcall	80002c34 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002bb8:	ec c6 01 00 	sub	r6,r6,256
80002bbc:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002bbe:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002bc2:	ee c7 ff 00 	sub	r7,r7,-256
80002bc6:	c2 c8       	rjmp	80002c1e <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002bc8:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002bcc:	0e 09       	add	r9,r7
80002bce:	0e 98       	mov	r8,r7
80002bd0:	e4 18 00 7f 	andh	r8,0x7f
80002bd4:	e0 18 ff 00 	andl	r8,0xff00
80002bd8:	f0 c8 ff 00 	sub	r8,r8,-256
80002bdc:	10 39       	cp.w	r9,r8
80002bde:	e0 88 00 19 	brls	80002c10 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002be2:	0e 91       	mov	r1,r7
80002be4:	5c 51       	castu.b	r1
80002be6:	e0 6a 01 00 	mov	r10,256
80002bea:	02 1a       	sub	r10,r1
80002bec:	5c 7a       	castu.h	r10
80002bee:	0e 9b       	mov	r11,r7
80002bf0:	08 9c       	mov	r12,r4
80002bf2:	f0 1f 00 11 	mcall	80002c34 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bf6:	ec c6 01 00 	sub	r6,r6,256
80002bfa:	02 06       	add	r6,r1
80002bfc:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bfe:	e0 68 01 00 	mov	r8,256
80002c02:	f0 05 01 05 	sub	r5,r8,r5
80002c06:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002c08:	e0 17 ff 00 	andl	r7,0xff00
80002c0c:	10 07       	add	r7,r8
80002c0e:	c0 88       	rjmp	80002c1e <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002c10:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002c14:	0e 9b       	mov	r11,r7
80002c16:	08 9c       	mov	r12,r4
80002c18:	f0 1f 00 07 	mcall	80002c34 <data_flash_write_block+0xbc>
80002c1c:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002c1e:	e6 06 19 00 	cp.h	r6,r3
80002c22:	5f 19       	srne	r9
80002c24:	58 7c       	cp.w	r12,7
80002c26:	5f 08       	sreq	r8
80002c28:	f3 e8 00 08 	and	r8,r9,r8
80002c2c:	e4 08 18 00 	cp.b	r8,r2
80002c30:	ca f1       	brne	80002b8e <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c32:	d8 32       	popm	r0-r7,pc
80002c34:	80 00       	ld.sh	r0,r0[0x0]
80002c36:	2a dc       	sub	r12,-83

80002c38 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c38:	eb cd 40 c0 	pushm	r6-r7,lr
80002c3c:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c3e:	e0 68 ff fe 	mov	r8,65534
80002c42:	ea 18 00 7f 	orh	r8,0x7f
80002c46:	10 3c       	cp.w	r12,r8
80002c48:	e0 88 00 04 	brls	80002c50 <data_flash_erase_block+0x18>
80002c4c:	30 17       	mov	r7,1
80002c4e:	c3 e8       	rjmp	80002cca <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c50:	58 1b       	cp.w	r11,1
80002c52:	c0 31       	brne	80002c58 <data_flash_erase_block+0x20>
80002c54:	32 06       	mov	r6,32
80002c56:	c0 a8       	rjmp	80002c6a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c58:	58 2b       	cp.w	r11,2
80002c5a:	c0 31       	brne	80002c60 <data_flash_erase_block+0x28>
80002c5c:	35 26       	mov	r6,82
80002c5e:	c0 68       	rjmp	80002c6a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c60:	e0 66 00 d8 	mov	r6,216
80002c64:	58 3b       	cp.w	r11,3
80002c66:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c6a:	30 09       	mov	r9,0
80002c6c:	12 9a       	mov	r10,r9
80002c6e:	12 9b       	mov	r11,r9
80002c70:	30 5c       	mov	r12,5
80002c72:	f0 1f 00 18 	mcall	80002cd0 <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c76:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c7a:	c0 30       	breq	80002c80 <data_flash_erase_block+0x48>
80002c7c:	30 27       	mov	r7,2
80002c7e:	c2 68       	rjmp	80002cca <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c80:	30 09       	mov	r9,0
80002c82:	12 9a       	mov	r10,r9
80002c84:	12 9b       	mov	r11,r9
80002c86:	30 6c       	mov	r12,6
80002c88:	f0 1f 00 12 	mcall	80002cd0 <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c8c:	30 09       	mov	r9,0
80002c8e:	12 9a       	mov	r10,r9
80002c90:	0e 9b       	mov	r11,r7
80002c92:	0c 9c       	mov	r12,r6
80002c94:	f0 1f 00 0f 	mcall	80002cd0 <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c98:	30 06       	mov	r6,0
80002c9a:	30 57       	mov	r7,5
80002c9c:	0c 99       	mov	r9,r6
80002c9e:	0c 9a       	mov	r10,r6
80002ca0:	0c 9b       	mov	r11,r6
80002ca2:	0e 9c       	mov	r12,r7
80002ca4:	f0 1f 00 0b 	mcall	80002cd0 <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002ca8:	5c 7c       	castu.h	r12
80002caa:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002cae:	cf 71       	brne	80002c9c <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002cb0:	18 97       	mov	r7,r12
80002cb2:	e2 17 00 20 	andl	r7,0x20,COH
80002cb6:	f9 b7 01 04 	movne	r7,4
80002cba:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002cbe:	30 09       	mov	r9,0
80002cc0:	12 9a       	mov	r10,r9
80002cc2:	12 9b       	mov	r11,r9
80002cc4:	30 4c       	mov	r12,4
80002cc6:	f0 1f 00 03 	mcall	80002cd0 <data_flash_erase_block+0x98>

	return return_code;
}
80002cca:	0e 9c       	mov	r12,r7
80002ccc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	28 e8       	sub	r8,-114

80002cd4 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002cd4:	d4 31       	pushm	r0-r7,lr
80002cd6:	20 3d       	sub	sp,12
80002cd8:	50 0c       	stdsp	sp[0x0],r12
80002cda:	16 91       	mov	r1,r11
80002cdc:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cde:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002ce2:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002ce4:	e0 69 10 00 	mov	r9,4096
80002ce8:	f2 0a 01 07 	sub	r7,r9,r10
80002cec:	ea 07 19 00 	cp.h	r7,r5
80002cf0:	ea 07 17 b0 	movhi	r7,r5
80002cf4:	5c 87       	casts.h	r7
80002cf6:	16 92       	mov	r2,r11
80002cf8:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cfc:	4a e4       	lddpc	r4,80002db4 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cfe:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d00:	e8 c8 ff ff 	sub	r8,r4,-1
80002d04:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002d06:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002d08:	08 9a       	mov	r10,r4
80002d0a:	e0 6b 10 00 	mov	r11,4096
80002d0e:	04 9c       	mov	r12,r2
80002d10:	f0 1f 00 2a 	mcall	80002db8 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002d14:	58 07       	cp.w	r7,0
80002d16:	c3 00       	breq	80002d76 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002d18:	40 13       	lddsp	r3,sp[0x4]
80002d1a:	5c 73       	castu.h	r3
80002d1c:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002d20:	ec 08 18 00 	cp.b	r8,r6
80002d24:	c1 11       	brne	80002d46 <data_flash_write+0x72>
80002d26:	e6 c9 ff ff 	sub	r9,r3,-1
80002d2a:	08 09       	add	r9,r4
80002d2c:	30 08       	mov	r8,0
80002d2e:	c0 58       	rjmp	80002d38 <data_flash_write+0x64>
80002d30:	13 3a       	ld.ub	r10,r9++
80002d32:	ec 0a 18 00 	cp.b	r10,r6
80002d36:	c0 81       	brne	80002d46 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d38:	2f f8       	sub	r8,-1
80002d3a:	5c 88       	casts.h	r8
80002d3c:	f0 07 19 00 	cp.h	r7,r8
80002d40:	fe 9b ff f8 	brhi	80002d30 <data_flash_write+0x5c>
80002d44:	c1 98       	rjmp	80002d76 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d46:	30 1b       	mov	r11,1
80002d48:	04 9c       	mov	r12,r2
80002d4a:	f0 1f 00 1d 	mcall	80002dbc <data_flash_write+0xe8>
80002d4e:	40 08       	lddsp	r8,sp[0x0]
80002d50:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d52:	40 2a       	lddsp	r10,sp[0x8]
80002d54:	40 19       	lddsp	r9,sp[0x4]
80002d56:	12 0a       	add	r10,r9
80002d58:	0e 99       	mov	r9,r7
80002d5a:	20 19       	sub	r9,1
80002d5c:	5c 79       	castu.h	r9
80002d5e:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d60:	11 39       	ld.ub	r9,r8++
80002d62:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d64:	14 33       	cp.w	r3,r10
80002d66:	cf d1       	brne	80002d60 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d68:	e0 6a 10 00 	mov	r10,4096
80002d6c:	04 9b       	mov	r11,r2
80002d6e:	08 9c       	mov	r12,r4
80002d70:	f0 1f 00 14 	mcall	80002dc0 <data_flash_write+0xec>
80002d74:	c0 78       	rjmp	80002d82 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d76:	0e 9a       	mov	r10,r7
80002d78:	5c 7a       	castu.h	r10
80002d7a:	02 9b       	mov	r11,r1
80002d7c:	40 0c       	lddsp	r12,sp[0x0]
80002d7e:	f0 1f 00 11 	mcall	80002dc0 <data_flash_write+0xec>
80002d82:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d86:	0e 98       	mov	r8,r7
80002d88:	ee 05 19 00 	cp.h	r5,r7
80002d8c:	c1 20       	breq	80002db0 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d8e:	5c 78       	castu.h	r8
80002d90:	40 0a       	lddsp	r10,sp[0x0]
80002d92:	10 0a       	add	r10,r8
80002d94:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d96:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d98:	0e 15       	sub	r5,r7
80002d9a:	5c 85       	casts.h	r5
80002d9c:	e0 05 19 00 	cp.h	r5,r0
80002da0:	ea 07 17 80 	movls	r7,r5
80002da4:	e0 07 17 b0 	movhi	r7,r0
80002da8:	5c 87       	casts.h	r7
80002daa:	30 09       	mov	r9,0
80002dac:	50 19       	stdsp	sp[0x4],r9
80002dae:	ca db       	rjmp	80002d08 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002db0:	2f dd       	sub	sp,-12
80002db2:	d8 32       	popm	r0-r7,pc
80002db4:	00 00       	add	r0,r0
80002db6:	0d 88       	ld.ub	r8,r6[0x0]
80002db8:	80 00       	ld.sh	r0,r0[0x0]
80002dba:	2a a4       	sub	r4,-86
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	2c 38       	sub	r8,-61
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	2b 78       	sub	r8,-73

80002dc4 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002dc4:	eb cd 40 c0 	pushm	r6-r7,lr
80002dc8:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002dca:	4b f8       	lddpc	r8,80002ec4 <data_flash_init+0x100>
80002dcc:	fa c6 ff fc 	sub	r6,sp,-4
80002dd0:	f0 ea 00 00 	ld.d	r10,r8[0]
80002dd4:	ec eb 00 00 	st.d	r6[0],r10
80002dd8:	f0 e8 00 08 	ld.d	r8,r8[8]
80002ddc:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002de0:	30 4b       	mov	r11,4
80002de2:	4b ac       	lddpc	r12,80002ec8 <data_flash_init+0x104>
80002de4:	f0 1f 00 3a 	mcall	80002ecc <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002de8:	31 9c       	mov	r12,25
80002dea:	f0 1f 00 3a 	mcall	80002ed0 <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dee:	31 9c       	mov	r12,25
80002df0:	f0 1f 00 39 	mcall	80002ed4 <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002df4:	4b 97       	lddpc	r7,80002ed8 <data_flash_init+0x114>
80002df6:	fe 7c 24 00 	mov	r12,-56320
80002dfa:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002dfc:	0c 9b       	mov	r11,r6
80002dfe:	f0 1f 00 38 	mcall	80002edc <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002e02:	30 09       	mov	r9,0
80002e04:	12 9a       	mov	r10,r9
80002e06:	12 9b       	mov	r11,r9
80002e08:	6e 0c       	ld.w	r12,r7[0x0]
80002e0a:	f0 1f 00 36 	mcall	80002ee0 <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002e0e:	6e 0c       	ld.w	r12,r7[0x0]
80002e10:	f0 1f 00 35 	mcall	80002ee4 <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
80002e14:	e0 6a 36 00 	mov	r10,13824
80002e18:	ea 1a 01 6e 	orh	r10,0x16e
80002e1c:	0c 9b       	mov	r11,r6
80002e1e:	6e 0c       	ld.w	r12,r7[0x0]
80002e20:	f0 1f 00 32 	mcall	80002ee8 <data_flash_init+0x124>
80002e24:	c0 50       	breq	80002e2e <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002e26:	30 29       	mov	r9,2
80002e28:	4b 18       	lddpc	r8,80002eec <data_flash_init+0x128>
80002e2a:	b0 89       	st.b	r8[0x0],r9
		return;
80002e2c:	c4 88       	rjmp	80002ebc <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002e2e:	1a 96       	mov	r6,sp
80002e30:	30 4a       	mov	r10,4
80002e32:	4b 0b       	lddpc	r11,80002ef0 <data_flash_init+0x12c>
80002e34:	1a 9c       	mov	r12,sp
80002e36:	f0 1f 00 30 	mcall	80002ef4 <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e3a:	4a 87       	lddpc	r7,80002ed8 <data_flash_init+0x114>
80002e3c:	30 0b       	mov	r11,0
80002e3e:	6e 0c       	ld.w	r12,r7[0x0]
80002e40:	f0 1f 00 2e 	mcall	80002ef8 <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e44:	e0 6b 00 9f 	mov	r11,159
80002e48:	6e 0c       	ld.w	r12,r7[0x0]
80002e4a:	f0 1f 00 2d 	mcall	80002efc <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e4e:	e0 6b 00 ff 	mov	r11,255
80002e52:	6e 0c       	ld.w	r12,r7[0x0]
80002e54:	f0 1f 00 2a 	mcall	80002efc <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e58:	1a 9b       	mov	r11,sp
80002e5a:	6e 0c       	ld.w	r12,r7[0x0]
80002e5c:	f0 1f 00 29 	mcall	80002f00 <data_flash_init+0x13c>
	spi_write_dummy();
80002e60:	e0 6b 00 ff 	mov	r11,255
80002e64:	6e 0c       	ld.w	r12,r7[0x0]
80002e66:	f0 1f 00 26 	mcall	80002efc <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e6a:	fa cb ff fe 	sub	r11,sp,-2
80002e6e:	6e 0c       	ld.w	r12,r7[0x0]
80002e70:	f0 1f 00 24 	mcall	80002f00 <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e74:	30 0b       	mov	r11,0
80002e76:	6e 0c       	ld.w	r12,r7[0x0]
80002e78:	f0 1f 00 23 	mcall	80002f04 <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e7c:	31 f8       	mov	r8,31
80002e7e:	9a 09       	ld.sh	r9,sp[0x0]
80002e80:	f0 09 19 00 	cp.h	r9,r8
80002e84:	c0 61       	brne	80002e90 <data_flash_init+0xcc>
80002e86:	34 88       	mov	r8,72
80002e88:	9a 19       	ld.sh	r9,sp[0x2]
80002e8a:	f0 09 19 00 	cp.h	r9,r8
80002e8e:	c0 50       	breq	80002e98 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e90:	30 39       	mov	r9,3
80002e92:	49 78       	lddpc	r8,80002eec <data_flash_init+0x128>
80002e94:	b0 89       	st.b	r8[0x0],r9
		return;
80002e96:	c1 38       	rjmp	80002ebc <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e98:	30 09       	mov	r9,0
80002e9a:	12 9a       	mov	r10,r9
80002e9c:	12 9b       	mov	r11,r9
80002e9e:	30 6c       	mov	r12,6
80002ea0:	f0 1f 00 1a 	mcall	80002f08 <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002ea4:	30 09       	mov	r9,0
80002ea6:	12 9a       	mov	r10,r9
80002ea8:	12 9b       	mov	r11,r9
80002eaa:	30 1c       	mov	r12,1
80002eac:	f0 1f 00 17 	mcall	80002f08 <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002eb0:	30 09       	mov	r9,0
80002eb2:	12 9a       	mov	r10,r9
80002eb4:	12 9b       	mov	r11,r9
80002eb6:	30 5c       	mov	r12,5
80002eb8:	f0 1f 00 14 	mcall	80002f08 <data_flash_init+0x144>
	
	return;
}
80002ebc:	2f bd       	sub	sp,-20
80002ebe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ec2:	00 00       	add	r0,r0
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	d5 24       	*unknown*
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	d5 38       	*unknown*
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	72 0c       	ld.w	r12,r9[0x0]
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	72 3c       	ld.w	r12,r9[0xc]
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	72 54       	ld.w	r4,r9[0x14]
80002ed8:	00 00       	add	r0,r0
80002eda:	1d 88       	ld.ub	r8,lr[0x0]
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	55 1c       	stdsp	sp[0x144],r12
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	55 54       	stdsp	sp[0x154],r4
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	56 b4       	stdsp	sp[0x1ac],r4
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	55 f2       	stdsp	sp[0x17c],r2
80002eec:	00 00       	add	r0,r0
80002eee:	0a 60       	and	r0,r5
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	d5 34       	*unknown*
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	77 2e       	ld.w	lr,r11[0x48]
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	55 80       	stdsp	sp[0x160],r0
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	56 ba       	stdsp	sp[0x1ac],r10
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	56 d6       	stdsp	sp[0x1b4],r6
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	55 cc       	stdsp	sp[0x170],r12
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	28 e8       	sub	r8,-114

80002f0c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002f0c:	20 1c       	sub	r12,1
80002f0e:	5c 5c       	castu.b	r12
80002f10:	31 18       	mov	r8,17
80002f12:	f0 0c 18 00 	cp.b	r12,r8
80002f16:	e0 88 00 03 	brls	80002f1c <CalculateBurst+0x10>
80002f1a:	5e fd       	retal	0
80002f1c:	48 28       	lddpc	r8,80002f24 <CalculateBurst+0x18>
80002f1e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002f22:	5e fc       	retal	r12
80002f24:	80 00       	ld.sh	r0,r0[0x0]
80002f26:	d5 60       	acall	0x56

80002f28 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002f28:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002f2a:	48 98       	lddpc	r8,80002f4c <payload_init+0x24>
80002f2c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002f2e:	48 98       	lddpc	r8,80002f50 <payload_init+0x28>
80002f30:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002f32:	30 09       	mov	r9,0
80002f34:	1a d9       	st.w	--sp,r9
80002f36:	1a d9       	st.w	--sp,r9
80002f38:	1a d9       	st.w	--sp,r9
80002f3a:	30 28       	mov	r8,2
80002f3c:	e0 6a 04 00 	mov	r10,1024
80002f40:	48 5b       	lddpc	r11,80002f54 <payload_init+0x2c>
80002f42:	48 6c       	lddpc	r12,80002f58 <payload_init+0x30>
80002f44:	f0 1f 00 06 	mcall	80002f5c <payload_init+0x34>
80002f48:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f4a:	d8 02       	popm	pc
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a 64       	and	r4,r5
80002f50:	00 00       	add	r0,r0
80002f52:	0a 68       	and	r8,r5
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	db 58       	*unknown*
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	2f 60       	sub	r0,-10
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	69 b0       	ld.w	r0,r4[0x6c]

80002f60 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f60:	eb cd 40 f8 	pushm	r3-r7,lr
80002f64:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f66:	48 e8       	lddpc	r8,80002f9c <payload_rx_process+0x3c>
80002f68:	70 08       	ld.w	r8,r8[0x0]
80002f6a:	58 08       	cp.w	r8,0
80002f6c:	c0 71       	brne	80002f7a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f6e:	30 4b       	mov	r11,4
80002f70:	30 5c       	mov	r12,5
80002f72:	f0 1f 00 0c 	mcall	80002fa0 <payload_rx_process+0x40>
80002f76:	48 a8       	lddpc	r8,80002f9c <payload_rx_process+0x3c>
80002f78:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f7a:	48 96       	lddpc	r6,80002f9c <payload_rx_process+0x3c>
80002f7c:	30 05       	mov	r5,0
80002f7e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f80:	48 93       	lddpc	r3,80002fa4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f82:	6c 0c       	ld.w	r12,r6[0x0]
80002f84:	0a 99       	mov	r9,r5
80002f86:	08 9a       	mov	r10,r4
80002f88:	1a 9b       	mov	r11,sp
80002f8a:	f0 1f 00 08 	mcall	80002fa8 <payload_rx_process+0x48>
80002f8e:	58 1c       	cp.w	r12,1
80002f90:	cf 91       	brne	80002f82 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f92:	66 08       	ld.w	r8,r3[0x0]
80002f94:	40 0c       	lddsp	r12,sp[0x0]
80002f96:	5d 18       	icall	r8
80002f98:	cf 5b       	rjmp	80002f82 <payload_rx_process+0x22>
80002f9a:	00 00       	add	r0,r0
80002f9c:	00 00       	add	r0,r0
80002f9e:	0a 94       	mov	r4,r5
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	62 dc       	ld.w	r12,r1[0x34]
80002fa4:	00 00       	add	r0,r0
80002fa6:	0a 64       	and	r4,r5
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	5f d0       	srvc	r0

80002fac <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002fac:	d4 01       	pushm	lr
80002fae:	20 2d       	sub	sp,8
80002fb0:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fb2:	30 09       	mov	r9,0
80002fb4:	fa ca ff f8 	sub	r10,sp,-8
80002fb8:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002fba:	1a 9b       	mov	r11,sp
80002fbc:	f0 1f 00 02 	mcall	80002fc4 <set_idle_store_isr+0x18>
}
80002fc0:	2f ed       	sub	sp,-8
80002fc2:	d8 02       	popm	pc
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	61 8c       	ld.w	r12,r0[0x60]

80002fc8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002fc8:	d4 01       	pushm	lr
80002fca:	20 2d       	sub	sp,8
80002fcc:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002fce:	58 0c       	cp.w	r12,0
80002fd0:	c1 10       	breq	80002ff2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fd2:	30 08       	mov	r8,0
80002fd4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002fd6:	98 88       	ld.uh	r8,r12[0x0]
80002fd8:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fdc:	e0 48 40 00 	cp.w	r8,16384
80002fe0:	c0 91       	brne	80002ff2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002fe2:	48 68       	lddpc	r8,80002ff8 <phy_rx+0x30>
80002fe4:	70 0c       	ld.w	r12,r8[0x0]
80002fe6:	30 09       	mov	r9,0
80002fe8:	fa ca ff fc 	sub	r10,sp,-4
80002fec:	1a 9b       	mov	r11,sp
80002fee:	f0 1f 00 04 	mcall	80002ffc <phy_rx+0x34>
		}	

    }
		
 
}
80002ff2:	2f ed       	sub	sp,-8
80002ff4:	d8 02       	popm	pc
80002ff6:	00 00       	add	r0,r0
80002ff8:	00 00       	add	r0,r0
80002ffa:	0a c4       	st.b	r5++,r4
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	61 8c       	ld.w	r12,r0[0x60]

80003000 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003000:	eb cd 40 80 	pushm	r7,lr
80003004:	20 1d       	sub	sp,4
80003006:	fa c7 ff fc 	sub	r7,sp,-4
8000300a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
8000300c:	30 09       	mov	r9,0
8000300e:	12 9a       	mov	r10,r9
80003010:	1a 9b       	mov	r11,sp
80003012:	f0 1f 00 03 	mcall	8000301c <set_idle_store+0x1c>
}
80003016:	2f fd       	sub	sp,-4
80003018:	e3 cd 80 80 	ldm	sp++,r7,pc
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	61 dc       	ld.w	r12,r0[0x74]

80003020 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003020:	d4 01       	pushm	lr
80003022:	20 1d       	sub	sp,4
80003024:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003026:	98 88       	ld.uh	r8,r12[0x0]
80003028:	e2 18 f0 00 	andl	r8,0xf000,COH
8000302c:	e0 48 40 00 	cp.w	r8,16384
80003030:	c0 d1       	brne	8000304a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003032:	49 08       	lddpc	r8,80003070 <phy_tx+0x50>
80003034:	70 08       	ld.w	r8,r8[0x0]
80003036:	58 08       	cp.w	r8,0
80003038:	c1 a0       	breq	8000306c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000303a:	48 e8       	lddpc	r8,80003070 <phy_tx+0x50>
8000303c:	70 0c       	ld.w	r12,r8[0x0]
8000303e:	30 09       	mov	r9,0
80003040:	12 9a       	mov	r10,r9
80003042:	1a 9b       	mov	r11,sp
80003044:	f0 1f 00 0c 	mcall	80003074 <phy_tx+0x54>
80003048:	c1 28       	rjmp	8000306c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000304a:	e0 48 10 00 	cp.w	r8,4096
8000304e:	5f 0a       	sreq	r10
80003050:	e0 48 20 00 	cp.w	r8,8192
80003054:	5f 09       	sreq	r9
80003056:	f5 e9 10 09 	or	r9,r10,r9
8000305a:	c0 71       	brne	80003068 <phy_tx+0x48>
8000305c:	e0 48 50 00 	cp.w	r8,20480
80003060:	c0 40       	breq	80003068 <phy_tx+0x48>
80003062:	e0 48 60 00 	cp.w	r8,24576
80003066:	c0 31       	brne	8000306c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003068:	48 48       	lddpc	r8,80003078 <phy_tx+0x58>
8000306a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
8000306c:	2f fd       	sub	sp,-4
8000306e:	d8 02       	popm	pc
80003070:	00 00       	add	r0,r0
80003072:	0a d0       	st.w	--r5,r0
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	61 dc       	ld.w	r12,r0[0x74]
80003078:	00 00       	add	r0,r0
8000307a:	0a c0       	st.b	r5++,r0

8000307c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
8000307c:	d4 01       	pushm	lr
8000307e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003080:	30 08       	mov	r8,0
80003082:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003084:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003086:	1a 9a       	mov	r10,sp
80003088:	fa cb ff fc 	sub	r11,sp,-4
8000308c:	f0 1f 00 05 	mcall	800030a0 <get_idle_store_isr+0x24>
80003090:	58 1c       	cp.w	r12,1
80003092:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003096:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
8000309a:	2f ed       	sub	sp,-8
8000309c:	d8 02       	popm	pc
8000309e:	00 00       	add	r0,r0
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	5e e0       	retqs	r0

800030a4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800030a4:	eb cd 40 c0 	pushm	r6-r7,lr
800030a8:	20 1d       	sub	sp,4
800030aa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800030ac:	fe f8 04 70 	ld.w	r8,pc[1136]
800030b0:	70 08       	ld.w	r8,r8[0x0]
800030b2:	58 08       	cp.w	r8,0
800030b4:	c7 40       	breq	8000319c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800030b6:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800030b8:	30 08       	mov	r8,0
800030ba:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800030bc:	fe f8 04 64 	ld.w	r8,pc[1124]
800030c0:	70 08       	ld.w	r8,r8[0x0]
800030c2:	58 18       	cp.w	r8,1
800030c4:	c2 90       	breq	80003116 <phy_tx_func+0x72>
800030c6:	c0 43       	brcs	800030ce <phy_tx_func+0x2a>
800030c8:	58 28       	cp.w	r8,2
800030ca:	c6 91       	brne	8000319c <phy_tx_func+0xf8>
800030cc:	c6 18       	rjmp	8000318e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800030ce:	fe f8 04 4e 	ld.w	r8,pc[1102]
800030d2:	70 0c       	ld.w	r12,r8[0x0]
800030d4:	1a 9a       	mov	r10,sp
800030d6:	fe fb 04 4e 	ld.w	r11,pc[1102]
800030da:	f0 1f 01 14 	mcall	80003528 <phy_tx_func+0x484>
800030de:	58 1c       	cp.w	r12,1
800030e0:	c1 51       	brne	8000310a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030e2:	fe f8 04 42 	ld.w	r8,pc[1090]
800030e6:	70 08       	ld.w	r8,r8[0x0]
800030e8:	11 9a       	ld.ub	r10,r8[0x1]
800030ea:	fe f9 04 42 	ld.w	r9,pc[1090]
800030ee:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030f0:	90 88       	ld.uh	r8,r8[0x0]
800030f2:	ea 18 ab cd 	orh	r8,0xabcd
800030f6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030f8:	30 19       	mov	r9,1
800030fa:	fe f8 04 36 	ld.w	r8,pc[1078]
800030fe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003100:	30 19       	mov	r9,1
80003102:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003106:	91 09       	st.w	r8[0x0],r9
80003108:	c4 a8       	rjmp	8000319c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
8000310a:	e0 68 5a 5a 	mov	r8,23130
8000310e:	ea 18 ab cd 	orh	r8,0xabcd
80003112:	8f 18       	st.w	r7[0x4],r8
80003114:	c4 48       	rjmp	8000319c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003116:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000311a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
8000311c:	fe fa 04 08 	ld.w	r10,pc[1032]
80003120:	74 0a       	ld.w	r10,r10[0x0]
80003122:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003126:	b1 6a       	lsl	r10,0x10
80003128:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000312a:	2f f8       	sub	r8,-1
8000312c:	5c 58       	castu.b	r8
8000312e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003130:	fe fa 03 fc 	ld.w	r10,pc[1020]
80003134:	94 09       	ld.sh	r9,r10[0x0]
80003136:	20 29       	sub	r9,2
80003138:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000313a:	30 0a       	mov	r10,0
8000313c:	f4 09 19 00 	cp.h	r9,r10
80003140:	e0 89 00 0b 	brgt	80003156 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003144:	78 18       	ld.w	r8,r12[0x4]
80003146:	e8 18 00 ba 	orl	r8,0xba
8000314a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
8000314c:	30 09       	mov	r9,0
8000314e:	fe f8 03 d2 	ld.w	r8,pc[978]
80003152:	91 09       	st.w	r8[0x0],r9
80003154:	c2 48       	rjmp	8000319c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003156:	fe f9 03 ce 	ld.w	r9,pc[974]
8000315a:	72 09       	ld.w	r9,r9[0x0]
8000315c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003160:	78 1a       	ld.w	r10,r12[0x4]
80003162:	f5 e9 10 09 	or	r9,r10,r9
80003166:	99 19       	st.w	r12[0x4],r9
80003168:	2f f8       	sub	r8,-1
8000316a:	fe f9 03 c6 	ld.w	r9,pc[966]
8000316e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003170:	fe f9 03 bc 	ld.w	r9,pc[956]
80003174:	92 08       	ld.sh	r8,r9[0x0]
80003176:	20 28       	sub	r8,2
80003178:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000317a:	30 09       	mov	r9,0
8000317c:	f2 08 19 00 	cp.h	r8,r9
80003180:	e0 89 00 0e 	brgt	8000319c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003184:	30 29       	mov	r9,2
80003186:	fe f8 03 9a 	ld.w	r8,pc[922]
8000318a:	91 09       	st.w	r8[0x0],r9
8000318c:	c0 88       	rjmp	8000319c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000318e:	fc 18 00 ba 	movh	r8,0xba
80003192:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003194:	30 09       	mov	r9,0
80003196:	fe f8 03 8a 	ld.w	r8,pc[906]
8000319a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
8000319c:	fe f8 03 98 	ld.w	r8,pc[920]
800031a0:	11 89       	ld.ub	r9,r8[0x0]
800031a2:	30 18       	mov	r8,1
800031a4:	f0 09 18 00 	cp.b	r9,r8
800031a8:	e0 81 01 af 	brne	80003506 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
800031ac:	fe f8 03 8c 	ld.w	r8,pc[908]
800031b0:	70 08       	ld.w	r8,r8[0x0]
800031b2:	e0 48 05 b0 	cp.w	r8,1456
800031b6:	f9 b8 02 00 	movhs	r8,0
800031ba:	fe f9 03 7e 	ld.w	r9,pc[894]
800031be:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
800031c0:	fe f8 03 7c 	ld.w	r8,pc[892]
800031c4:	70 08       	ld.w	r8,r8[0x0]
800031c6:	58 68       	cp.w	r8,6
800031c8:	e0 8b 01 95 	brhi	800034f2 <phy_tx_func+0x44e>
800031cc:	fe f9 03 74 	ld.w	r9,pc[884]
800031d0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
800031d4:	fe f8 03 70 	ld.w	r8,pc[880]
800031d8:	70 08       	ld.w	r8,r8[0x0]
800031da:	58 08       	cp.w	r8,0
800031dc:	c0 b0       	breq	800031f2 <phy_tx_func+0x14e>
800031de:	fe f8 03 66 	ld.w	r8,pc[870]
800031e2:	70 08       	ld.w	r8,r8[0x0]
800031e4:	58 a8       	cp.w	r8,10
800031e6:	c0 60       	breq	800031f2 <phy_tx_func+0x14e>
800031e8:	fe f8 03 5c 	ld.w	r8,pc[860]
800031ec:	70 08       	ld.w	r8,r8[0x0]
800031ee:	58 18       	cp.w	r8,1
800031f0:	c0 a1       	brne	80003204 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800031f2:	e0 68 5a 5a 	mov	r8,23130
800031f6:	ea 18 ab cd 	orh	r8,0xabcd
800031fa:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800031fc:	30 08       	mov	r8,0
800031fe:	8f 38       	st.w	r7[0xc],r8
80003200:	e0 8f 01 8a 	bral	80003514 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003204:	fe f8 03 40 	ld.w	r8,pc[832]
80003208:	70 08       	ld.w	r8,r8[0x0]
8000320a:	58 38       	cp.w	r8,3
8000320c:	c0 91       	brne	8000321e <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
8000320e:	fe f8 03 3a 	ld.w	r8,pc[826]
80003212:	70 09       	ld.w	r9,r8[0x0]
80003214:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003216:	70 18       	ld.w	r8,r8[0x4]
80003218:	8f 38       	st.w	r7[0xc],r8
8000321a:	e0 8f 01 7d 	bral	80003514 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
8000321e:	fe f8 03 26 	ld.w	r8,pc[806]
80003222:	70 08       	ld.w	r8,r8[0x0]
80003224:	58 28       	cp.w	r8,2
80003226:	c1 31       	brne	8000324c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80003228:	e0 68 c0 32 	mov	r8,49202
8000322c:	ea 18 ab cd 	orh	r8,0xabcd
80003230:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80003232:	fe 78 84 7f 	mov	r8,-31617
80003236:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80003238:	fe f8 03 14 	ld.w	r8,pc[788]
8000323c:	90 08       	ld.sh	r8,r8[0x0]
8000323e:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80003240:	30 39       	mov	r9,3
80003242:	fe f8 02 fa 	ld.w	r8,pc[762]
80003246:	91 09       	st.w	r8[0x0],r9
80003248:	e0 8f 01 66 	bral	80003514 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
8000324c:	e0 68 c0 0e 	mov	r8,49166
80003250:	ea 18 ab cd 	orh	r8,0xabcd
80003254:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80003256:	fe f8 02 fa 	ld.w	r8,pc[762]
8000325a:	90 09       	ld.sh	r9,r8[0x0]
8000325c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
8000325e:	90 18       	ld.sh	r8,r8[0x2]
80003260:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80003262:	30 19       	mov	r9,1
80003264:	fe f8 02 d8 	ld.w	r8,pc[728]
80003268:	91 09       	st.w	r8[0x0],r9
8000326a:	e0 8f 01 55 	bral	80003514 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
8000326e:	fe 78 88 f2 	mov	r8,-30478
80003272:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80003274:	fe f8 02 d0 	ld.w	r8,pc[720]
80003278:	70 08       	ld.w	r8,r8[0x0]
8000327a:	58 48       	cp.w	r8,4
8000327c:	c0 60       	breq	80003288 <phy_tx_func+0x1e4>
8000327e:	c4 53       	brcs	80003308 <phy_tx_func+0x264>
80003280:	58 98       	cp.w	r8,9
80003282:	e0 8b 00 43 	brhi	80003308 <phy_tx_func+0x264>
80003286:	c2 98       	rjmp	800032d8 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003288:	fe f8 02 cc 	ld.w	r8,pc[716]
8000328c:	11 89       	ld.ub	r9,r8[0x0]
8000328e:	30 18       	mov	r8,1
80003290:	f0 09 18 00 	cp.b	r9,r8
80003294:	c0 a1       	brne	800032a8 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003296:	fe f8 02 c2 	ld.w	r8,pc[706]
8000329a:	90 09       	ld.sh	r9,r8[0x0]
8000329c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
8000329e:	90 19       	ld.sh	r9,r8[0x2]
800032a0:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
800032a2:	90 28       	ld.sh	r8,r8[0x4]
800032a4:	ae 78       	st.h	r7[0xe],r8
800032a6:	c1 48       	rjmp	800032ce <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032a8:	fe f9 02 b4 	ld.w	r9,pc[692]
800032ac:	92 0b       	ld.sh	r11,r9[0x0]
800032ae:	fe f8 02 aa 	ld.w	r8,pc[682]
800032b2:	90 0a       	ld.sh	r10,r8[0x0]
800032b4:	f7 ea 20 0a 	eor	r10,r11,r10
800032b8:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032ba:	92 1b       	ld.sh	r11,r9[0x2]
800032bc:	90 1a       	ld.sh	r10,r8[0x2]
800032be:	f7 ea 20 0a 	eor	r10,r11,r10
800032c2:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032c4:	92 29       	ld.sh	r9,r9[0x4]
800032c6:	90 28       	ld.sh	r8,r8[0x4]
800032c8:	f3 e8 20 08 	eor	r8,r9,r8
800032cc:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032ce:	30 29       	mov	r9,2
800032d0:	fe f8 02 6c 	ld.w	r8,pc[620]
800032d4:	91 09       	st.w	r8[0x0],r9
800032d6:	c1 f9       	rjmp	80003514 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032d8:	fe f9 02 84 	ld.w	r9,pc[644]
800032dc:	92 0b       	ld.sh	r11,r9[0x0]
800032de:	fe f8 02 7a 	ld.w	r8,pc[634]
800032e2:	90 0a       	ld.sh	r10,r8[0x0]
800032e4:	f7 ea 20 0a 	eor	r10,r11,r10
800032e8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032ea:	92 1b       	ld.sh	r11,r9[0x2]
800032ec:	90 1a       	ld.sh	r10,r8[0x2]
800032ee:	f7 ea 20 0a 	eor	r10,r11,r10
800032f2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032f4:	92 29       	ld.sh	r9,r9[0x4]
800032f6:	90 28       	ld.sh	r8,r8[0x4]
800032f8:	f3 e8 20 08 	eor	r8,r9,r8
800032fc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032fe:	30 29       	mov	r9,2
80003300:	fe f8 02 3c 	ld.w	r8,pc[572]
80003304:	91 09       	st.w	r8[0x0],r9
80003306:	c0 79       	rjmp	80003514 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003308:	e0 68 5a 5a 	mov	r8,23130
8000330c:	ea 18 ab cd 	orh	r8,0xabcd
80003310:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003312:	30 08       	mov	r8,0
80003314:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80003316:	fe f9 02 26 	ld.w	r9,pc[550]
8000331a:	93 08       	st.w	r9[0x0],r8
8000331c:	cf c8       	rjmp	80003514 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
8000331e:	fe f8 02 3e 	ld.w	r8,pc[574]
80003322:	90 38       	ld.sh	r8,r8[0x6]
80003324:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80003326:	e0 68 00 ba 	mov	r8,186
8000332a:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
8000332c:	30 08       	mov	r8,0
8000332e:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003330:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80003332:	30 09       	mov	r9,0
80003334:	fe f8 02 08 	ld.w	r8,pc[520]
80003338:	91 09       	st.w	r8[0x0],r9
8000333a:	ce d8       	rjmp	80003514 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
8000333c:	fe f8 02 10 	ld.w	r8,pc[528]
80003340:	90 18       	ld.sh	r8,r8[0x2]
80003342:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80003344:	fe f8 02 0c 	ld.w	r8,pc[524]
80003348:	90 08       	ld.sh	r8,r8[0x0]
8000334a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
8000334c:	4f e8       	lddpc	r8,80003544 <phy_tx_func+0x4a0>
8000334e:	70 08       	ld.w	r8,r8[0x0]
80003350:	58 48       	cp.w	r8,4
80003352:	c0 d1       	brne	8000336c <phy_tx_func+0x2c8>
80003354:	fe f8 02 00 	ld.w	r8,pc[512]
80003358:	11 89       	ld.ub	r9,r8[0x0]
8000335a:	30 18       	mov	r8,1
8000335c:	f0 09 18 00 	cp.b	r9,r8
80003360:	c0 61       	brne	8000336c <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80003362:	4f c8       	lddpc	r8,80003550 <phy_tx_func+0x4ac>
80003364:	90 18       	ld.sh	r8,r8[0x2]
80003366:	a9 a8       	sbr	r8,0x8
80003368:	ae 68       	st.h	r7[0xc],r8
8000336a:	c0 48       	rjmp	80003372 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
8000336c:	4f 98       	lddpc	r8,80003550 <phy_tx_func+0x4ac>
8000336e:	90 18       	ld.sh	r8,r8[0x2]
80003370:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80003372:	fe 78 9a 13 	mov	r8,-26093
80003376:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80003378:	30 49       	mov	r9,4
8000337a:	4f 18       	lddpc	r8,8000353c <phy_tx_func+0x498>
8000337c:	91 09       	st.w	r8[0x0],r9
8000337e:	cc b8       	rjmp	80003514 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80003380:	4f 88       	lddpc	r8,80003560 <phy_tx_func+0x4bc>
80003382:	70 0a       	ld.w	r10,r8[0x0]
80003384:	4f 89       	lddpc	r9,80003564 <phy_tx_func+0x4c0>
80003386:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000338a:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
8000338c:	70 0a       	ld.w	r10,r8[0x0]
8000338e:	2f fa       	sub	r10,-1
80003390:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003394:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80003396:	70 0a       	ld.w	r10,r8[0x0]
80003398:	2f ea       	sub	r10,-2
8000339a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000339e:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
800033a0:	70 0a       	ld.w	r10,r8[0x0]
800033a2:	2f da       	sub	r10,-3
800033a4:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033a8:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
800033aa:	70 09       	ld.w	r9,r8[0x0]
800033ac:	2f c9       	sub	r9,-4
800033ae:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
800033b0:	58 c9       	cp.w	r9,12
800033b2:	c0 51       	brne	800033bc <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
800033b4:	30 59       	mov	r9,5
800033b6:	4e 28       	lddpc	r8,8000353c <phy_tx_func+0x498>
800033b8:	91 09       	st.w	r8[0x0],r9
800033ba:	ca d8       	rjmp	80003514 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
800033bc:	30 49       	mov	r9,4
800033be:	4e 08       	lddpc	r8,8000353c <phy_tx_func+0x498>
800033c0:	91 09       	st.w	r8[0x0],r9
800033c2:	ca 98       	rjmp	80003514 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800033c4:	4e 78       	lddpc	r8,80003560 <phy_tx_func+0x4bc>
800033c6:	70 0a       	ld.w	r10,r8[0x0]
800033c8:	4e 79       	lddpc	r9,80003564 <phy_tx_func+0x4c0>
800033ca:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033ce:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
800033d0:	30 09       	mov	r9,0
800033d2:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
800033d4:	fe 78 80 03 	mov	r8,-32765
800033d8:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800033da:	fe 78 88 f3 	mov	r8,-30477
800033de:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
800033e0:	4d 98       	lddpc	r8,80003544 <phy_tx_func+0x4a0>
800033e2:	70 08       	ld.w	r8,r8[0x0]
800033e4:	58 48       	cp.w	r8,4
800033e6:	c0 60       	breq	800033f2 <phy_tx_func+0x34e>
800033e8:	c2 83       	brcs	80003438 <phy_tx_func+0x394>
800033ea:	58 98       	cp.w	r8,9
800033ec:	e0 8b 00 26 	brhi	80003438 <phy_tx_func+0x394>
800033f0:	c1 98       	rjmp	80003422 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800033f2:	4d 98       	lddpc	r8,80003554 <phy_tx_func+0x4b0>
800033f4:	11 89       	ld.ub	r9,r8[0x0]
800033f6:	30 18       	mov	r8,1
800033f8:	f0 09 18 00 	cp.b	r9,r8
800033fc:	c0 81       	brne	8000340c <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800033fe:	4d 88       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
80003400:	90 0a       	ld.sh	r10,r8[0x0]
80003402:	4d a9       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
80003404:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80003406:	90 08       	ld.sh	r8,r8[0x0]
80003408:	ae 78       	st.h	r7[0xe],r8
8000340a:	c0 88       	rjmp	8000341a <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000340c:	4d 78       	lddpc	r8,80003568 <phy_tx_func+0x4c4>
8000340e:	90 08       	ld.sh	r8,r8[0x0]
80003410:	4d 39       	lddpc	r9,8000355c <phy_tx_func+0x4b8>
80003412:	92 09       	ld.sh	r9,r9[0x0]
80003414:	f3 e8 20 08 	eor	r8,r9,r8
80003418:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
8000341a:	30 69       	mov	r9,6
8000341c:	4c 88       	lddpc	r8,8000353c <phy_tx_func+0x498>
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	c7 a8       	rjmp	80003514 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003422:	4d 28       	lddpc	r8,80003568 <phy_tx_func+0x4c4>
80003424:	90 08       	ld.sh	r8,r8[0x0]
80003426:	4c e9       	lddpc	r9,8000355c <phy_tx_func+0x4b8>
80003428:	92 09       	ld.sh	r9,r9[0x0]
8000342a:	f3 e8 20 08 	eor	r8,r9,r8
8000342e:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80003430:	30 69       	mov	r9,6
80003432:	4c 38       	lddpc	r8,8000353c <phy_tx_func+0x498>
80003434:	91 09       	st.w	r8[0x0],r9
80003436:	c6 f8       	rjmp	80003514 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003438:	e0 68 5a 5a 	mov	r8,23130
8000343c:	ea 18 ab cd 	orh	r8,0xabcd
80003440:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003442:	30 08       	mov	r8,0
80003444:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80003446:	4b e9       	lddpc	r9,8000353c <phy_tx_func+0x498>
80003448:	93 08       	st.w	r9[0x0],r8
8000344a:	c6 58       	rjmp	80003514 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
8000344c:	4b e8       	lddpc	r8,80003544 <phy_tx_func+0x4a0>
8000344e:	70 08       	ld.w	r8,r8[0x0]
80003450:	58 48       	cp.w	r8,4
80003452:	c0 60       	breq	8000345e <phy_tx_func+0x3ba>
80003454:	c4 53       	brcs	800034de <phy_tx_func+0x43a>
80003456:	58 98       	cp.w	r8,9
80003458:	e0 8b 00 43 	brhi	800034de <phy_tx_func+0x43a>
8000345c:	c2 d8       	rjmp	800034b6 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
8000345e:	4b e8       	lddpc	r8,80003554 <phy_tx_func+0x4b0>
80003460:	11 89       	ld.ub	r9,r8[0x0]
80003462:	30 18       	mov	r8,1
80003464:	f0 09 18 00 	cp.b	r9,r8
80003468:	c1 31       	brne	8000348e <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
8000346a:	4b d8       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
8000346c:	90 1a       	ld.sh	r10,r8[0x2]
8000346e:	4b f9       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
80003470:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80003472:	90 2a       	ld.sh	r10,r8[0x4]
80003474:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80003476:	90 3a       	ld.sh	r10,r8[0x6]
80003478:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
8000347a:	90 19       	ld.sh	r9,r8[0x2]
8000347c:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
8000347e:	90 29       	ld.sh	r9,r8[0x4]
80003480:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80003482:	90 38       	ld.sh	r8,r8[0x6]
80003484:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80003486:	e0 68 00 ba 	mov	r8,186
8000348a:	ae 78       	st.h	r7[0xe],r8
8000348c:	c1 18       	rjmp	800034ae <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000348e:	4b 48       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
80003490:	90 1a       	ld.sh	r10,r8[0x2]
80003492:	4b 69       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
80003494:	92 1b       	ld.sh	r11,r9[0x2]
80003496:	f7 ea 20 0a 	eor	r10,r11,r10
8000349a:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
8000349c:	90 2a       	ld.sh	r10,r8[0x4]
8000349e:	92 29       	ld.sh	r9,r9[0x4]
800034a0:	14 59       	eor	r9,r10
800034a2:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034a4:	90 38       	ld.sh	r8,r8[0x6]
800034a6:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
800034a8:	e0 68 00 ba 	mov	r8,186
800034ac:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034ae:	30 09       	mov	r9,0
800034b0:	4a 38       	lddpc	r8,8000353c <phy_tx_func+0x498>
800034b2:	91 09       	st.w	r8[0x0],r9
800034b4:	c3 08       	rjmp	80003514 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
800034b6:	4a a8       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
800034b8:	90 1a       	ld.sh	r10,r8[0x2]
800034ba:	4a c9       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
800034bc:	92 1b       	ld.sh	r11,r9[0x2]
800034be:	f7 ea 20 0a 	eor	r10,r11,r10
800034c2:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
800034c4:	90 2a       	ld.sh	r10,r8[0x4]
800034c6:	92 29       	ld.sh	r9,r9[0x4]
800034c8:	14 59       	eor	r9,r10
800034ca:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034cc:	90 38       	ld.sh	r8,r8[0x6]
800034ce:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
800034d0:	e0 68 00 ba 	mov	r8,186
800034d4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034d6:	30 09       	mov	r9,0
800034d8:	49 98       	lddpc	r8,8000353c <phy_tx_func+0x498>
800034da:	91 09       	st.w	r8[0x0],r9
800034dc:	c1 c8       	rjmp	80003514 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034de:	e0 68 5a 5a 	mov	r8,23130
800034e2:	ea 18 ab cd 	orh	r8,0xabcd
800034e6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034e8:	30 08       	mov	r8,0
800034ea:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
800034ec:	49 49       	lddpc	r9,8000353c <phy_tx_func+0x498>
800034ee:	93 08       	st.w	r9[0x0],r8
800034f0:	c1 28       	rjmp	80003514 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034f2:	e0 68 5a 5a 	mov	r8,23130
800034f6:	ea 18 ab cd 	orh	r8,0xabcd
800034fa:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034fc:	30 08       	mov	r8,0
800034fe:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80003500:	48 f9       	lddpc	r9,8000353c <phy_tx_func+0x498>
80003502:	93 08       	st.w	r9[0x0],r8
80003504:	c0 88       	rjmp	80003514 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003506:	e0 68 5a 5a 	mov	r8,23130
8000350a:	ea 18 ab cd 	orh	r8,0xabcd
8000350e:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003510:	30 08       	mov	r8,0
80003512:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003514:	2f fd       	sub	sp,-4
80003516:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000351a:	00 00       	add	r0,r0
8000351c:	00 00       	add	r0,r0
8000351e:	0a d0       	st.w	--r5,r0
80003520:	00 00       	add	r0,r0
80003522:	0a a8       	st.w	r5++,r8
80003524:	00 00       	add	r0,r0
80003526:	0a 84       	andn	r4,r5
80003528:	80 00       	ld.sh	r0,r0[0x0]
8000352a:	5e e0       	retqs	r0
8000352c:	00 00       	add	r0,r0
8000352e:	0a c8       	st.b	r5++,r8
80003530:	00 00       	add	r0,r0
80003532:	0a 8d       	andn	sp,r5
80003534:	00 00       	add	r0,r0
80003536:	0a 4a       	or	r10,r5
80003538:	00 00       	add	r0,r0
8000353a:	0a 80       	andn	r0,r5
8000353c:	00 00       	add	r0,r0
8000353e:	0a b8       	st.h	r5++,r8
80003540:	80 00       	ld.sh	r0,r0[0x0]
80003542:	db 64       	*unknown*
80003544:	00 00       	add	r0,r0
80003546:	0a 74       	tst	r4,r5
80003548:	00 00       	add	r0,r0
8000354a:	0a d8       	st.w	--r5,r8
8000354c:	00 00       	add	r0,r0
8000354e:	1d 94       	ld.ub	r4,lr[0x1]
80003550:	00 00       	add	r0,r0
80003552:	1e 90       	mov	r0,pc
80003554:	00 00       	add	r0,r0
80003556:	0a 4b       	or	r11,r5
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	d5 58       	*unknown*
8000355c:	00 00       	add	r0,r0
8000355e:	1d 8c       	ld.ub	r12,lr[0x0]
80003560:	00 00       	add	r0,r0
80003562:	0a a4       	st.w	r5++,r4
80003564:	00 00       	add	r0,r0
80003566:	1e 94       	mov	r4,pc
80003568:	00 00       	add	r0,r0
8000356a:	1d 98       	ld.ub	r8,lr[0x1]

8000356c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000356c:	d4 01       	pushm	lr
8000356e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003570:	30 0a       	mov	r10,0
80003572:	fa cb ff fc 	sub	r11,sp,-4
80003576:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003578:	14 99       	mov	r9,r10
8000357a:	1a 9b       	mov	r11,sp
8000357c:	f0 1f 00 05 	mcall	80003590 <get_idle_store+0x24>
80003580:	58 1c       	cp.w	r12,1
80003582:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003586:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000358a:	2f fd       	sub	sp,-4
8000358c:	d8 02       	popm	pc
8000358e:	00 00       	add	r0,r0
80003590:	80 00       	ld.sh	r0,r0[0x0]
80003592:	5f d0       	srvc	r0

80003594 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003594:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80003598:	f0 1f 00 21 	mcall	8000361c <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000359c:	4a 1b       	lddpc	r11,80003620 <phy_init+0x8c>
8000359e:	4a 2c       	lddpc	r12,80003624 <phy_init+0x90>
800035a0:	f0 1f 00 22 	mcall	80003628 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800035a4:	30 4b       	mov	r11,4
800035a6:	31 ec       	mov	r12,30
800035a8:	f0 1f 00 21 	mcall	8000362c <phy_init+0x98>
800035ac:	4a 18       	lddpc	r8,80003630 <phy_init+0x9c>
800035ae:	91 0c       	st.w	r8[0x0],r12
800035b0:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800035b2:	10 96       	mov	r6,r8
800035b4:	4a 05       	lddpc	r5,80003634 <phy_init+0xa0>
800035b6:	6c 0c       	ld.w	r12,r6[0x0]
800035b8:	ea 07 00 0b 	add	r11,r5,r7
800035bc:	f0 1f 00 1f 	mcall	80003638 <phy_init+0xa4>
800035c0:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800035c4:	e0 47 1e 00 	cp.w	r7,7680
800035c8:	cf 71       	brne	800035b6 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035ca:	30 4b       	mov	r11,4
800035cc:	31 4c       	mov	r12,20
800035ce:	f0 1f 00 18 	mcall	8000362c <phy_init+0x98>
800035d2:	49 b8       	lddpc	r8,8000363c <phy_init+0xa8>
800035d4:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035d6:	30 4b       	mov	r11,4
800035d8:	30 ac       	mov	r12,10
800035da:	f0 1f 00 15 	mcall	8000362c <phy_init+0x98>
800035de:	49 98       	lddpc	r8,80003640 <phy_init+0xac>
800035e0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800035e2:	30 4b       	mov	r11,4
800035e4:	30 ac       	mov	r12,10
800035e6:	f0 1f 00 12 	mcall	8000362c <phy_init+0x98>
800035ea:	49 78       	lddpc	r8,80003644 <phy_init+0xb0>
800035ec:	91 0c       	st.w	r8[0x0],r12
800035ee:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800035f0:	10 96       	mov	r6,r8
800035f2:	49 65       	lddpc	r5,80003648 <phy_init+0xb4>
800035f4:	6c 0c       	ld.w	r12,r6[0x0]
800035f6:	ea 07 00 0b 	add	r11,r5,r7
800035fa:	f0 1f 00 10 	mcall	80003638 <phy_init+0xa4>
800035fe:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80003602:	e0 47 14 00 	cp.w	r7,5120
80003606:	cf 71       	brne	800035f4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003608:	e0 6b 01 00 	mov	r11,256
8000360c:	30 5c       	mov	r12,5
8000360e:	f0 1f 00 08 	mcall	8000362c <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80003612:	48 f8       	lddpc	r8,8000364c <phy_init+0xb8>
80003614:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80003616:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000361a:	00 00       	add	r0,r0
8000361c:	80 00       	ld.sh	r0,r0[0x0]
8000361e:	44 40       	lddsp	r0,sp[0x110]
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	30 a4       	mov	r4,10
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	36 b0       	mov	r0,107
80003628:	80 00       	ld.sh	r0,r0[0x0]
8000362a:	44 2c       	lddsp	r12,sp[0x108]
8000362c:	80 00       	ld.sh	r0,r0[0x0]
8000362e:	62 dc       	ld.w	r12,r1[0x34]
80003630:	00 00       	add	r0,r0
80003632:	0a 9c       	mov	r12,r5
80003634:	00 00       	add	r0,r0
80003636:	32 ae       	mov	lr,42
80003638:	80 00       	ld.sh	r0,r0[0x0]
8000363a:	30 00       	mov	r0,0
8000363c:	00 00       	add	r0,r0
8000363e:	0a d0       	st.w	--r5,r0
80003640:	00 00       	add	r0,r0
80003642:	0a c4       	st.b	r5++,r4
80003644:	00 00       	add	r0,r0
80003646:	0a 78       	tst	r8,r5
80003648:	00 00       	add	r0,r0
8000364a:	1e ae       	st.w	pc++,lr
8000364c:	00 00       	add	r0,r0
8000364e:	0a c0       	st.b	r5++,r0

80003650 <payload_rx>:




static void payload_rx(void * payload)
{
80003650:	d4 01       	pushm	lr
80003652:	20 2d       	sub	sp,8
80003654:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003656:	30 08       	mov	r8,0
80003658:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000365a:	48 f8       	lddpc	r8,80003694 <payload_rx+0x44>
8000365c:	70 08       	ld.w	r8,r8[0x0]
8000365e:	58 08       	cp.w	r8,0
80003660:	c0 71       	brne	8000366e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003662:	30 4b       	mov	r11,4
80003664:	30 5c       	mov	r12,5
80003666:	f0 1f 00 0d 	mcall	80003698 <payload_rx+0x48>
8000366a:	48 b8       	lddpc	r8,80003694 <payload_rx+0x44>
8000366c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000366e:	48 a8       	lddpc	r8,80003694 <payload_rx+0x44>
80003670:	70 0c       	ld.w	r12,r8[0x0]
80003672:	30 09       	mov	r9,0
80003674:	fa ca ff fc 	sub	r10,sp,-4
80003678:	1a 9b       	mov	r11,sp
8000367a:	f0 1f 00 09 	mcall	8000369c <payload_rx+0x4c>
8000367e:	c0 91       	brne	80003690 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003680:	48 88       	lddpc	r8,800036a0 <payload_rx+0x50>
80003682:	70 0c       	ld.w	r12,r8[0x0]
80003684:	40 0b       	lddsp	r11,sp[0x0]
80003686:	f0 1f 00 08 	mcall	800036a4 <payload_rx+0x54>
		logFromISR("mm");
8000368a:	48 8c       	lddpc	r12,800036a8 <payload_rx+0x58>
8000368c:	f0 1f 00 08 	mcall	800036ac <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003690:	2f ed       	sub	sp,-8
80003692:	d8 02       	popm	pc
80003694:	00 00       	add	r0,r0
80003696:	0a 94       	mov	r4,r5
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	62 dc       	ld.w	r12,r1[0x34]
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	61 8c       	ld.w	r12,r0[0x60]
800036a0:	00 00       	add	r0,r0
800036a2:	0a 78       	tst	r8,r5
800036a4:	80 00       	ld.sh	r0,r0[0x0]
800036a6:	2f ac       	sub	r12,-6
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	db 80       	acall	0xb8
800036ac:	80 00       	ld.sh	r0,r0[0x0]
800036ae:	6f 00       	ld.w	r0,r7[0x40]

800036b0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800036b0:	eb cd 40 e0 	pushm	r5-r7,lr
800036b4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800036b6:	fe f8 0b be 	ld.w	r8,pc[3006]
800036ba:	70 08       	ld.w	r8,r8[0x0]
800036bc:	58 08       	cp.w	r8,0
800036be:	e0 80 01 05 	breq	800038c8 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800036c2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800036c4:	fe f8 0b b4 	ld.w	r8,pc[2996]
800036c8:	70 09       	ld.w	r9,r8[0x0]
800036ca:	2f f9       	sub	r9,-1
800036cc:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800036ce:	fe f8 0b ae 	ld.w	r8,pc[2990]
800036d2:	70 08       	ld.w	r8,r8[0x0]
800036d4:	58 18       	cp.w	r8,1
800036d6:	e0 80 00 84 	breq	800037de <phy_rx_func+0x12e>
800036da:	c0 73       	brcs	800036e8 <phy_rx_func+0x38>
800036dc:	58 28       	cp.w	r8,2
800036de:	c5 b0       	breq	80003794 <phy_rx_func+0xe4>
800036e0:	58 38       	cp.w	r8,3
800036e2:	e0 81 00 f3 	brne	800038c8 <phy_rx_func+0x218>
800036e6:	cd 38       	rjmp	8000388c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800036e8:	e0 6a 5a 5a 	mov	r10,23130
800036ec:	ea 1a ab cd 	orh	r10,0xabcd
800036f0:	14 36       	cp.w	r6,r10
800036f2:	e0 80 00 eb 	breq	800038c8 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800036f6:	ec 08 16 10 	lsr	r8,r6,0x10
800036fa:	e0 48 ab cd 	cp.w	r8,43981
800036fe:	e0 81 00 e5 	brne	800038c8 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003702:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003706:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000370a:	20 28       	sub	r8,2
8000370c:	fe f9 0b 74 	ld.w	r9,pc[2932]
80003710:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003712:	30 09       	mov	r9,0
80003714:	f2 08 19 00 	cp.h	r8,r9
80003718:	e0 8a 00 d8 	brle	800038c8 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
8000371c:	fe f8 0b 68 	ld.w	r8,pc[2920]
80003720:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003722:	fe f8 0b 66 	ld.w	r8,pc[2918]
80003726:	70 0c       	ld.w	r12,r8[0x0]
80003728:	f0 1f 02 d9 	mcall	8000428c <phy_rx_func+0xbdc>
8000372c:	fe f8 0b 64 	ld.w	r8,pc[2916]
80003730:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003732:	58 0c       	cp.w	r12,0
80003734:	e0 80 00 ca 	breq	800038c8 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003738:	fe f8 0b 4c 	ld.w	r8,pc[2892]
8000373c:	90 09       	ld.sh	r9,r8[0x0]
8000373e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003742:	2f f9       	sub	r9,-1
80003744:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003746:	fe fa 0b 4a 	ld.w	r10,pc[2890]
8000374a:	74 0a       	ld.w	r10,r10[0x0]
8000374c:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003750:	76 0b       	ld.w	r11,r11[0x0]
80003752:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003756:	2f f9       	sub	r9,-1
80003758:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000375a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000375e:	e0 46 01 00 	cp.w	r6,256
80003762:	c0 c0       	breq	8000377a <phy_rx_func+0xca>
80003764:	e0 8b 00 05 	brhi	8000376e <phy_rx_func+0xbe>
80003768:	58 06       	cp.w	r6,0
8000376a:	c0 80       	breq	8000377a <phy_rx_func+0xca>
8000376c:	c0 c8       	rjmp	80003784 <phy_rx_func+0xd4>
8000376e:	e0 46 02 00 	cp.w	r6,512
80003772:	c0 40       	breq	8000377a <phy_rx_func+0xca>
80003774:	e0 46 03 00 	cp.w	r6,768
80003778:	c0 61       	brne	80003784 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000377a:	30 29       	mov	r9,2
8000377c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003780:	91 09       	st.w	r8[0x0],r9
80003782:	ca 38       	rjmp	800038c8 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003784:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003788:	6c 0c       	ld.w	r12,r6[0x0]
8000378a:	f0 1f 02 c3 	mcall	80004294 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000378e:	30 08       	mov	r8,0
80003790:	8d 08       	st.w	r6[0x0],r8
80003792:	c9 b8       	rjmp	800038c8 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003794:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003798:	b1 86       	lsr	r6,0x10
8000379a:	14 06       	add	r6,r10
8000379c:	fe f8 0a fc 	ld.w	r8,pc[2812]
800037a0:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800037a2:	fe f8 0a e2 	ld.w	r8,pc[2786]
800037a6:	90 09       	ld.sh	r9,r8[0x0]
800037a8:	fe fb 0a e8 	ld.w	r11,pc[2792]
800037ac:	76 0b       	ld.w	r11,r11[0x0]
800037ae:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800037b2:	2f f9       	sub	r9,-1
800037b4:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800037b6:	fe f9 0a ca 	ld.w	r9,pc[2762]
800037ba:	92 08       	ld.sh	r8,r9[0x0]
800037bc:	20 28       	sub	r8,2
800037be:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800037c0:	30 09       	mov	r9,0
800037c2:	f2 08 19 00 	cp.h	r8,r9
800037c6:	e0 8a 00 07 	brle	800037d4 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800037ca:	30 19       	mov	r9,1
800037cc:	fe f8 0a b0 	ld.w	r8,pc[2736]
800037d0:	91 09       	st.w	r8[0x0],r9
800037d2:	c7 b8       	rjmp	800038c8 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800037d4:	30 39       	mov	r9,3
800037d6:	fe f8 0a a6 	ld.w	r8,pc[2726]
800037da:	91 09       	st.w	r8[0x0],r9
800037dc:	c7 68       	rjmp	800038c8 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800037de:	ec 0a 14 10 	asr	r10,r6,0x10
800037e2:	fe f8 0a b6 	ld.w	r8,pc[2742]
800037e6:	90 09       	ld.sh	r9,r8[0x0]
800037e8:	14 09       	add	r9,r10
800037ea:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037ec:	fe f9 0a 98 	ld.w	r9,pc[2712]
800037f0:	92 08       	ld.sh	r8,r9[0x0]
800037f2:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800037f6:	76 0b       	ld.w	r11,r11[0x0]
800037f8:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800037fc:	2f f8       	sub	r8,-1
800037fe:	5c 88       	casts.h	r8
80003800:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003802:	fe fa 0a 7e 	ld.w	r10,pc[2686]
80003806:	94 09       	ld.sh	r9,r10[0x0]
80003808:	20 29       	sub	r9,2
8000380a:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000380c:	30 0a       	mov	r10,0
8000380e:	f4 09 19 00 	cp.h	r9,r10
80003812:	e0 89 00 1f 	brgt	80003850 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003816:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000381a:	e0 46 00 ba 	cp.w	r6,186
8000381e:	c0 d1       	brne	80003838 <phy_rx_func+0x188>
80003820:	fe f8 0a 78 	ld.w	r8,pc[2680]
80003824:	90 09       	ld.sh	r9,r8[0x0]
80003826:	f4 09 19 00 	cp.h	r9,r10
8000382a:	c0 71       	brne	80003838 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000382c:	fe f8 0a 64 	ld.w	r8,pc[2660]
80003830:	70 0c       	ld.w	r12,r8[0x0]
80003832:	f0 1f 02 9b 	mcall	8000429c <phy_rx_func+0xbec>
80003836:	c0 88       	rjmp	80003846 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003838:	fe f6 0a 58 	ld.w	r6,pc[2648]
8000383c:	6c 0c       	ld.w	r12,r6[0x0]
8000383e:	f0 1f 02 96 	mcall	80004294 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
80003842:	30 08       	mov	r8,0
80003844:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003846:	30 09       	mov	r9,0
80003848:	fe f8 0a 34 	ld.w	r8,pc[2612]
8000384c:	91 09       	st.w	r8[0x0],r9
8000384e:	c3 d8       	rjmp	800038c8 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003850:	5c 86       	casts.h	r6
80003852:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003856:	92 0a       	ld.sh	r10,r9[0x0]
80003858:	0c 0a       	add	r10,r6
8000385a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000385c:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003860:	72 09       	ld.w	r9,r9[0x0]
80003862:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003866:	2f f8       	sub	r8,-1
80003868:	fe f9 0a 1c 	ld.w	r9,pc[2588]
8000386c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000386e:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003872:	92 08       	ld.sh	r8,r9[0x0]
80003874:	20 28       	sub	r8,2
80003876:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003878:	30 09       	mov	r9,0
8000387a:	f2 08 19 00 	cp.h	r8,r9
8000387e:	e0 89 00 25 	brgt	800038c8 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003882:	30 39       	mov	r9,3
80003884:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003888:	91 09       	st.w	r8[0x0],r9
8000388a:	c1 f8       	rjmp	800038c8 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000388c:	e6 16 00 ff 	andh	r6,0xff,COH
80003890:	fc 19 00 ba 	movh	r9,0xba
80003894:	12 36       	cp.w	r6,r9
80003896:	c0 e1       	brne	800038b2 <phy_rx_func+0x202>
80003898:	fe f8 0a 00 	ld.w	r8,pc[2560]
8000389c:	90 09       	ld.sh	r9,r8[0x0]
8000389e:	30 08       	mov	r8,0
800038a0:	f0 09 19 00 	cp.h	r9,r8
800038a4:	c0 71       	brne	800038b2 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800038a6:	fe f8 09 ea 	ld.w	r8,pc[2538]
800038aa:	70 0c       	ld.w	r12,r8[0x0]
800038ac:	f0 1f 02 7c 	mcall	8000429c <phy_rx_func+0xbec>
800038b0:	c0 88       	rjmp	800038c0 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800038b2:	fe f6 09 de 	ld.w	r6,pc[2526]
800038b6:	6c 0c       	ld.w	r12,r6[0x0]
800038b8:	f0 1f 02 77 	mcall	80004294 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
800038bc:	30 08       	mov	r8,0
800038be:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800038c0:	30 09       	mov	r9,0
800038c2:	fe f8 09 ba 	ld.w	r8,pc[2490]
800038c6:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800038c8:	fe f8 09 d8 	ld.w	r8,pc[2520]
800038cc:	11 89       	ld.ub	r9,r8[0x0]
800038ce:	30 08       	mov	r8,0
800038d0:	f0 09 18 00 	cp.b	r9,r8
800038d4:	c0 d1       	brne	800038ee <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800038d6:	fe f8 09 ce 	ld.w	r8,pc[2510]
800038da:	70 0c       	ld.w	r12,r8[0x0]
800038dc:	f0 1f 02 6c 	mcall	8000428c <phy_rx_func+0xbdc>
800038e0:	fe f8 09 c8 	ld.w	r8,pc[2504]
800038e4:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800038e6:	30 19       	mov	r9,1
800038e8:	fe f8 09 b8 	ld.w	r8,pc[2488]
800038ec:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800038ee:	fe f8 09 be 	ld.w	r8,pc[2494]
800038f2:	70 08       	ld.w	r8,r8[0x0]
800038f4:	58 38       	cp.w	r8,3
800038f6:	e0 80 04 7a 	breq	800041ea <phy_rx_func+0xb3a>
800038fa:	58 48       	cp.w	r8,4
800038fc:	e0 80 01 02 	breq	80003b00 <phy_rx_func+0x450>
80003900:	58 08       	cp.w	r8,0
80003902:	e0 81 04 b7 	brne	80004270 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003906:	6e 28       	ld.w	r8,r7[0x8]
80003908:	e0 6a 5a 5a 	mov	r10,23130
8000390c:	ea 1a ab cd 	orh	r10,0xabcd
80003910:	14 38       	cp.w	r8,r10
80003912:	c0 71       	brne	80003920 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80003914:	30 09       	mov	r9,0
80003916:	fe f8 09 9a 	ld.w	r8,pc[2458]
8000391a:	91 09       	st.w	r8[0x0],r9
8000391c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003920:	10 99       	mov	r9,r8
80003922:	e0 19 00 00 	andl	r9,0x0
80003926:	fc 1a ab cd 	movh	r10,0xabcd
8000392a:	14 39       	cp.w	r9,r10
8000392c:	e0 81 04 a2 	brne	80004270 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003930:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003934:	fe f9 09 80 	ld.w	r9,pc[2432]
80003938:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
8000393a:	fe f8 09 6e 	ld.w	r8,pc[2414]
8000393e:	70 08       	ld.w	r8,r8[0x0]
80003940:	58 08       	cp.w	r8,0
80003942:	c1 11       	brne	80003964 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003944:	fe f8 09 60 	ld.w	r8,pc[2400]
80003948:	70 0c       	ld.w	r12,r8[0x0]
8000394a:	f0 1f 02 51 	mcall	8000428c <phy_rx_func+0xbdc>
8000394e:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003952:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003954:	58 0c       	cp.w	r12,0
80003956:	c0 71       	brne	80003964 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003958:	fe fc 09 60 	ld.w	r12,pc[2400]
8000395c:	f0 1f 02 58 	mcall	800042bc <phy_rx_func+0xc0c>
80003960:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003964:	6e 28       	ld.w	r8,r7[0x8]
80003966:	e2 18 f0 00 	andl	r8,0xf000,COH
8000396a:	e0 48 c0 00 	cp.w	r8,49152
8000396e:	e0 81 00 c3 	brne	80003af4 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003972:	30 19       	mov	r9,1
80003974:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003978:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000397a:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000397e:	fe f8 09 46 	ld.w	r8,pc[2374]
80003982:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003984:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003988:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
8000398c:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003990:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003992:	11 88       	ld.ub	r8,r8[0x0]
80003994:	37 f9       	mov	r9,127
80003996:	f2 08 18 00 	cp.b	r8,r9
8000399a:	c6 d0       	breq	80003a74 <phy_rx_func+0x3c4>
8000399c:	e0 8b 00 0c 	brhi	800039b4 <phy_rx_func+0x304>
800039a0:	31 29       	mov	r9,18
800039a2:	f2 08 18 00 	cp.b	r8,r9
800039a6:	c4 20       	breq	80003a2a <phy_rx_func+0x37a>
800039a8:	31 39       	mov	r9,19
800039aa:	f2 08 18 00 	cp.b	r8,r9
800039ae:	e0 81 00 83 	brne	80003ab4 <phy_rx_func+0x404>
800039b2:	c5 b8       	rjmp	80003a68 <phy_rx_func+0x3b8>
800039b4:	2f 08       	sub	r8,-16
800039b6:	30 19       	mov	r9,1
800039b8:	f2 08 18 00 	cp.b	r8,r9
800039bc:	e0 8b 00 7c 	brhi	80003ab4 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800039c0:	ef 38 00 0e 	ld.ub	r8,r7[14]
800039c4:	e2 18 00 f0 	andl	r8,0xf0,COH
800039c8:	59 08       	cp.w	r8,16
800039ca:	c0 71       	brne	800039d8 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
800039cc:	30 19       	mov	r9,1
800039ce:	fe f8 08 e2 	ld.w	r8,pc[2274]
800039d2:	91 09       	st.w	r8[0x0],r9
800039d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800039d8:	e0 48 00 20 	cp.w	r8,32
800039dc:	c2 11       	brne	80003a1e <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800039de:	30 a9       	mov	r9,10
800039e0:	fe f8 08 d0 	ld.w	r8,pc[2256]
800039e4:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800039e6:	fe f6 08 e6 	ld.w	r6,pc[2278]
800039ea:	6c 08       	ld.w	r8,r6[0x0]
800039ec:	f0 0a 11 ff 	rsub	r10,r8,-1
800039f0:	fe f7 08 b8 	ld.w	r7,pc[2232]
800039f4:	2f f8       	sub	r8,-1
800039f6:	6e 0c       	ld.w	r12,r7[0x0]
800039f8:	f4 ca fe 00 	sub	r10,r10,-512
800039fc:	30 0b       	mov	r11,0
800039fe:	10 0c       	add	r12,r8
80003a00:	f0 1f 02 34 	mcall	800042d0 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
80003a04:	30 08       	mov	r8,0
80003a06:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003a08:	6e 0c       	ld.w	r12,r7[0x0]
80003a0a:	f0 1f 02 33 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a0e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003a12:	70 0c       	ld.w	r12,r8[0x0]
80003a14:	f0 1f 02 1e 	mcall	8000428c <phy_rx_func+0xbdc>
80003a18:	8f 0c       	st.w	r7[0x0],r12
80003a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 08 90 	ld.w	r8,pc[2192]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a2a:	fe f9 08 8a 	ld.w	r9,pc[2186]
80003a2e:	72 08       	ld.w	r8,r9[0x0]
80003a30:	20 48       	sub	r8,4
80003a32:	93 08       	st.w	r9[0x0],r8
80003a34:	e0 80 04 1e 	breq	80004270 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a38:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003a3c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a40:	fe f8 08 98 	ld.w	r8,pc[2200]
80003a44:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003a46:	8e 69       	ld.sh	r9,r7[0xc]
80003a48:	fe f8 08 94 	ld.w	r8,pc[2196]
80003a4c:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003a4e:	8e 79       	ld.sh	r9,r7[0xe]
80003a50:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003a52:	f0 1f 02 24 	mcall	800042e0 <phy_rx_func+0xc30>
80003a56:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003a5a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a5c:	30 49       	mov	r9,4
80003a5e:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003a62:	91 09       	st.w	r8[0x0],r9
80003a64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003a68:	30 09       	mov	r9,0
80003a6a:	fe f8 08 46 	ld.w	r8,pc[2118]
80003a6e:	91 09       	st.w	r8[0x0],r9
80003a70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a74:	fe f9 08 40 	ld.w	r9,pc[2112]
80003a78:	72 08       	ld.w	r8,r9[0x0]
80003a7a:	20 48       	sub	r8,4
80003a7c:	93 08       	st.w	r9[0x0],r8
80003a7e:	e0 80 03 f9 	breq	80004270 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003a82:	fe f8 08 62 	ld.w	r8,pc[2146]
80003a86:	70 09       	ld.w	r9,r8[0x0]
80003a88:	8e 7b       	ld.sh	r11,r7[0xe]
80003a8a:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003a8e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003a92:	2f f9       	sub	r9,-1
80003a94:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003a96:	fe f8 08 32 	ld.w	r8,pc[2098]
80003a9a:	70 09       	ld.w	r9,r8[0x0]
80003a9c:	20 29       	sub	r9,2
80003a9e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003aa0:	30 29       	mov	r9,2
80003aa2:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003aa6:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003aa8:	30 39       	mov	r9,3
80003aaa:	fe f8 08 02 	ld.w	r8,pc[2050]
80003aae:	91 09       	st.w	r8[0x0],r9
80003ab0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003ab4:	30 39       	mov	r9,3
80003ab6:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003aba:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003abc:	6e 29       	ld.w	r9,r7[0x8]
80003abe:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003ac2:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003ac4:	6e 39       	ld.w	r9,r7[0xc]
80003ac6:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003ac8:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003acc:	70 08       	ld.w	r8,r8[0x0]
80003ace:	59 48       	cp.w	r8,20
80003ad0:	c0 61       	brne	80003adc <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003ad2:	31 89       	mov	r9,24
80003ad4:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003ad8:	91 09       	st.w	r8[0x0],r9
80003ada:	c0 78       	rjmp	80003ae8 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003adc:	59 08       	cp.w	r8,16
80003ade:	c0 51       	brne	80003ae8 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003ae0:	31 09       	mov	r9,16
80003ae2:	fe f8 07 d2 	ld.w	r8,pc[2002]
80003ae6:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003ae8:	30 49       	mov	r9,4
80003aea:	fe f8 07 c2 	ld.w	r8,pc[1986]
80003aee:	91 09       	st.w	r8[0x0],r9
80003af0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
80003af4:	30 09       	mov	r9,0
80003af6:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003afa:	b0 89       	st.b	r8[0x0],r9
80003afc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003b00:	fe f8 07 c4 	ld.w	r8,pc[1988]
80003b04:	11 89       	ld.ub	r9,r8[0x0]
80003b06:	31 28       	mov	r8,18
80003b08:	f0 09 18 00 	cp.b	r9,r8
80003b0c:	e0 81 01 4c 	brne	80003da4 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
80003b10:	ef 39 00 09 	ld.ub	r9,r7[9]
80003b14:	fe f8 07 b0 	ld.w	r8,pc[1968]
80003b18:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003b1a:	11 89       	ld.ub	r9,r8[0x0]
80003b1c:	3f 28       	mov	r8,-14
80003b1e:	f0 09 18 00 	cp.b	r9,r8
80003b22:	e0 81 01 3b 	brne	80003d98 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
80003b26:	30 19       	mov	r9,1
80003b28:	fe f8 07 c8 	ld.w	r8,pc[1992]
80003b2c:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003b2e:	6e 29       	ld.w	r9,r7[0x8]
80003b30:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003b34:	fe f8 07 80 	ld.w	r8,pc[1920]
80003b38:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003b3a:	8e 59       	ld.sh	r9,r7[0xa]
80003b3c:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003b40:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003b42:	8e 69       	ld.sh	r9,r7[0xc]
80003b44:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003b46:	8e 79       	ld.sh	r9,r7[0xe]
80003b48:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003b4a:	fe f8 07 82 	ld.w	r8,pc[1922]
80003b4e:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003b52:	72 0a       	ld.w	r10,r9[0x0]
80003b54:	70 09       	ld.w	r9,r8[0x0]
80003b56:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b5a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b5e:	70 09       	ld.w	r9,r8[0x0]
80003b60:	2f f9       	sub	r9,-1
80003b62:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b64:	e0 49 01 ff 	cp.w	r9,511
80003b68:	e0 88 00 16 	brls	80003b94 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b6c:	30 09       	mov	r9,0
80003b6e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b70:	fe f6 07 38 	ld.w	r6,pc[1848]
80003b74:	6c 0c       	ld.w	r12,r6[0x0]
80003b76:	f0 1f 01 d8 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b7a:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003b7e:	70 0c       	ld.w	r12,r8[0x0]
80003b80:	f0 1f 01 c3 	mcall	8000428c <phy_rx_func+0xbdc>
80003b84:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b86:	c0 71       	brne	80003b94 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003b88:	30 09       	mov	r9,0
80003b8a:	fe f8 07 22 	ld.w	r8,pc[1826]
80003b8e:	91 09       	st.w	r8[0x0],r9
80003b90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b94:	fe f9 07 20 	ld.w	r9,pc[1824]
80003b98:	72 08       	ld.w	r8,r9[0x0]
80003b9a:	20 18       	sub	r8,1
80003b9c:	93 08       	st.w	r9[0x0],r8
80003b9e:	c0 71       	brne	80003bac <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003ba0:	30 09       	mov	r9,0
80003ba2:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003ba6:	91 09       	st.w	r8[0x0],r9
80003ba8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003bac:	fe f8 07 20 	ld.w	r8,pc[1824]
80003bb0:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003bb4:	72 0a       	ld.w	r10,r9[0x0]
80003bb6:	70 09       	ld.w	r9,r8[0x0]
80003bb8:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003bbc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003bc0:	70 09       	ld.w	r9,r8[0x0]
80003bc2:	2f f9       	sub	r9,-1
80003bc4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bc6:	e0 49 01 ff 	cp.w	r9,511
80003bca:	e0 88 00 16 	brls	80003bf6 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bce:	30 09       	mov	r9,0
80003bd0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bd2:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003bd6:	6c 0c       	ld.w	r12,r6[0x0]
80003bd8:	f0 1f 01 bf 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bdc:	fe f8 06 c8 	ld.w	r8,pc[1736]
80003be0:	70 0c       	ld.w	r12,r8[0x0]
80003be2:	f0 1f 01 ab 	mcall	8000428c <phy_rx_func+0xbdc>
80003be6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003be8:	c0 71       	brne	80003bf6 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
80003bea:	30 09       	mov	r9,0
80003bec:	fe f8 06 c0 	ld.w	r8,pc[1728]
80003bf0:	91 09       	st.w	r8[0x0],r9
80003bf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bf6:	fe f9 06 be 	ld.w	r9,pc[1726]
80003bfa:	72 08       	ld.w	r8,r9[0x0]
80003bfc:	20 18       	sub	r8,1
80003bfe:	93 08       	st.w	r9[0x0],r8
80003c00:	c0 71       	brne	80003c0e <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
80003c02:	30 09       	mov	r9,0
80003c04:	fe f8 06 a8 	ld.w	r8,pc[1704]
80003c08:	91 09       	st.w	r8[0x0],r9
80003c0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003c0e:	fe f8 06 be 	ld.w	r8,pc[1726]
80003c12:	fe f9 06 96 	ld.w	r9,pc[1686]
80003c16:	72 0a       	ld.w	r10,r9[0x0]
80003c18:	70 09       	ld.w	r9,r8[0x0]
80003c1a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c1e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c22:	70 09       	ld.w	r9,r8[0x0]
80003c24:	2f f9       	sub	r9,-1
80003c26:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c28:	e0 49 01 ff 	cp.w	r9,511
80003c2c:	e0 88 00 16 	brls	80003c58 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c30:	30 09       	mov	r9,0
80003c32:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c34:	fe f6 06 74 	ld.w	r6,pc[1652]
80003c38:	6c 0c       	ld.w	r12,r6[0x0]
80003c3a:	f0 1f 01 a7 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c3e:	fe f8 06 66 	ld.w	r8,pc[1638]
80003c42:	70 0c       	ld.w	r12,r8[0x0]
80003c44:	f0 1f 01 92 	mcall	8000428c <phy_rx_func+0xbdc>
80003c48:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c4a:	c0 71       	brne	80003c58 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003c4c:	30 09       	mov	r9,0
80003c4e:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003c52:	91 09       	st.w	r8[0x0],r9
80003c54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c58:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003c5c:	72 08       	ld.w	r8,r9[0x0]
80003c5e:	20 18       	sub	r8,1
80003c60:	93 08       	st.w	r9[0x0],r8
80003c62:	c0 71       	brne	80003c70 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003c64:	30 09       	mov	r9,0
80003c66:	fe f8 06 46 	ld.w	r8,pc[1606]
80003c6a:	91 09       	st.w	r8[0x0],r9
80003c6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003c70:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003c74:	fe f9 06 34 	ld.w	r9,pc[1588]
80003c78:	72 0a       	ld.w	r10,r9[0x0]
80003c7a:	70 09       	ld.w	r9,r8[0x0]
80003c7c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003c80:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c84:	70 09       	ld.w	r9,r8[0x0]
80003c86:	2f f9       	sub	r9,-1
80003c88:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c8a:	e0 49 01 ff 	cp.w	r9,511
80003c8e:	e0 88 00 16 	brls	80003cba <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c92:	30 09       	mov	r9,0
80003c94:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c96:	fe f6 06 12 	ld.w	r6,pc[1554]
80003c9a:	6c 0c       	ld.w	r12,r6[0x0]
80003c9c:	f0 1f 01 8e 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ca0:	fe f8 06 04 	ld.w	r8,pc[1540]
80003ca4:	70 0c       	ld.w	r12,r8[0x0]
80003ca6:	f0 1f 01 7a 	mcall	8000428c <phy_rx_func+0xbdc>
80003caa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cac:	c0 71       	brne	80003cba <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
80003cae:	30 09       	mov	r9,0
80003cb0:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003cb4:	91 09       	st.w	r8[0x0],r9
80003cb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003cba:	fe f9 05 fa 	ld.w	r9,pc[1530]
80003cbe:	72 08       	ld.w	r8,r9[0x0]
80003cc0:	20 18       	sub	r8,1
80003cc2:	93 08       	st.w	r9[0x0],r8
80003cc4:	c0 71       	brne	80003cd2 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003cc6:	30 09       	mov	r9,0
80003cc8:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003ccc:	91 09       	st.w	r8[0x0],r9
80003cce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003cd2:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003cd6:	fe f9 05 d2 	ld.w	r9,pc[1490]
80003cda:	72 0a       	ld.w	r10,r9[0x0]
80003cdc:	70 09       	ld.w	r9,r8[0x0]
80003cde:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ce2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ce6:	70 09       	ld.w	r9,r8[0x0]
80003ce8:	2f f9       	sub	r9,-1
80003cea:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cec:	e0 49 01 ff 	cp.w	r9,511
80003cf0:	e0 88 00 16 	brls	80003d1c <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003cf4:	30 09       	mov	r9,0
80003cf6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003cf8:	fe f6 05 b0 	ld.w	r6,pc[1456]
80003cfc:	6c 0c       	ld.w	r12,r6[0x0]
80003cfe:	f0 1f 01 76 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d02:	fe f8 05 a2 	ld.w	r8,pc[1442]
80003d06:	70 0c       	ld.w	r12,r8[0x0]
80003d08:	f0 1f 01 61 	mcall	8000428c <phy_rx_func+0xbdc>
80003d0c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d0e:	c0 71       	brne	80003d1c <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
80003d10:	30 09       	mov	r9,0
80003d12:	fe f8 05 9a 	ld.w	r8,pc[1434]
80003d16:	91 09       	st.w	r8[0x0],r9
80003d18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d1c:	fe f9 05 98 	ld.w	r9,pc[1432]
80003d20:	72 08       	ld.w	r8,r9[0x0]
80003d22:	20 18       	sub	r8,1
80003d24:	93 08       	st.w	r9[0x0],r8
80003d26:	c0 71       	brne	80003d34 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003d28:	30 09       	mov	r9,0
80003d2a:	fe f8 05 82 	ld.w	r8,pc[1410]
80003d2e:	91 09       	st.w	r8[0x0],r9
80003d30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003d34:	fe f8 05 98 	ld.w	r8,pc[1432]
80003d38:	fe f9 05 70 	ld.w	r9,pc[1392]
80003d3c:	72 0a       	ld.w	r10,r9[0x0]
80003d3e:	70 09       	ld.w	r9,r8[0x0]
80003d40:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d44:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d48:	70 09       	ld.w	r9,r8[0x0]
80003d4a:	2f f9       	sub	r9,-1
80003d4c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d4e:	e0 49 01 ff 	cp.w	r9,511
80003d52:	e0 88 00 16 	brls	80003d7e <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d56:	30 09       	mov	r9,0
80003d58:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d5a:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003d5e:	6e 0c       	ld.w	r12,r7[0x0]
80003d60:	f0 1f 01 5d 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d64:	fe f8 05 40 	ld.w	r8,pc[1344]
80003d68:	70 0c       	ld.w	r12,r8[0x0]
80003d6a:	f0 1f 01 49 	mcall	8000428c <phy_rx_func+0xbdc>
80003d6e:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d70:	c0 71       	brne	80003d7e <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003d72:	30 09       	mov	r9,0
80003d74:	fe f8 05 38 	ld.w	r8,pc[1336]
80003d78:	91 09       	st.w	r8[0x0],r9
80003d7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d7e:	fe f9 05 36 	ld.w	r9,pc[1334]
80003d82:	72 08       	ld.w	r8,r9[0x0]
80003d84:	20 18       	sub	r8,1
80003d86:	93 08       	st.w	r9[0x0],r8
80003d88:	e0 81 02 74 	brne	80004270 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003d8c:	30 09       	mov	r9,0
80003d8e:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003d92:	91 09       	st.w	r8[0x0],r9
80003d94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003d98:	30 09       	mov	r9,0
80003d9a:	fe f8 05 12 	ld.w	r8,pc[1298]
80003d9e:	91 09       	st.w	r8[0x0],r9
80003da0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003da4:	fe f8 05 20 	ld.w	r8,pc[1312]
80003da8:	11 89       	ld.ub	r9,r8[0x0]
80003daa:	3f 28       	mov	r8,-14
80003dac:	f0 09 18 00 	cp.b	r9,r8
80003db0:	c4 31       	brne	80003e36 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003db2:	8e 49       	ld.sh	r9,r7[0x8]
80003db4:	fe f8 05 40 	ld.w	r8,pc[1344]
80003db8:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003dba:	fe f8 05 12 	ld.w	r8,pc[1298]
80003dbe:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003dc2:	72 0a       	ld.w	r10,r9[0x0]
80003dc4:	70 09       	ld.w	r9,r8[0x0]
80003dc6:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003dca:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dce:	70 09       	ld.w	r9,r8[0x0]
80003dd0:	2f f9       	sub	r9,-1
80003dd2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dd4:	e0 49 01 ff 	cp.w	r9,511
80003dd8:	e0 88 00 16 	brls	80003e04 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ddc:	30 09       	mov	r9,0
80003dde:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003de0:	fe f7 04 c8 	ld.w	r7,pc[1224]
80003de4:	6e 0c       	ld.w	r12,r7[0x0]
80003de6:	f0 1f 01 3c 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dea:	fe f8 04 ba 	ld.w	r8,pc[1210]
80003dee:	70 0c       	ld.w	r12,r8[0x0]
80003df0:	f0 1f 01 27 	mcall	8000428c <phy_rx_func+0xbdc>
80003df4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003df6:	c0 71       	brne	80003e04 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
80003df8:	30 09       	mov	r9,0
80003dfa:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003dfe:	91 09       	st.w	r8[0x0],r9
80003e00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e04:	fe f9 04 b0 	ld.w	r9,pc[1200]
80003e08:	72 08       	ld.w	r8,r9[0x0]
80003e0a:	20 18       	sub	r8,1
80003e0c:	93 08       	st.w	r9[0x0],r8
80003e0e:	c0 71       	brne	80003e1c <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
80003e10:	30 09       	mov	r9,0
80003e12:	fe f8 04 9a 	ld.w	r8,pc[1178]
80003e16:	91 09       	st.w	r8[0x0],r9
80003e18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003e1c:	20 18       	sub	r8,1
80003e1e:	fe f9 04 96 	ld.w	r9,pc[1174]
80003e22:	93 08       	st.w	r9[0x0],r8
80003e24:	58 08       	cp.w	r8,0
80003e26:	e0 81 02 25 	brne	80004270 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003e2a:	30 09       	mov	r9,0
80003e2c:	fe f8 04 80 	ld.w	r8,pc[1152]
80003e30:	91 09       	st.w	r8[0x0],r9
80003e32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003e36:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003e3a:	11 89       	ld.ub	r9,r8[0x0]
80003e3c:	3f 38       	mov	r8,-13
80003e3e:	f0 09 18 00 	cp.b	r9,r8
80003e42:	e0 81 01 0c 	brne	8000405a <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003e46:	8e 49       	ld.sh	r9,r7[0x8]
80003e48:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003e4c:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003e4e:	8e 59       	ld.sh	r9,r7[0xa]
80003e50:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003e52:	8e 69       	ld.sh	r9,r7[0xc]
80003e54:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003e56:	fe f8 04 76 	ld.w	r8,pc[1142]
80003e5a:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003e5e:	72 0a       	ld.w	r10,r9[0x0]
80003e60:	70 09       	ld.w	r9,r8[0x0]
80003e62:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003e66:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e6a:	70 09       	ld.w	r9,r8[0x0]
80003e6c:	2f f9       	sub	r9,-1
80003e6e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e70:	e0 49 01 ff 	cp.w	r9,511
80003e74:	e0 88 00 16 	brls	80003ea0 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e78:	30 09       	mov	r9,0
80003e7a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e7c:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003e80:	6c 0c       	ld.w	r12,r6[0x0]
80003e82:	f0 1f 01 15 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e86:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003e8a:	70 0c       	ld.w	r12,r8[0x0]
80003e8c:	f0 1f 01 00 	mcall	8000428c <phy_rx_func+0xbdc>
80003e90:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e92:	c0 71       	brne	80003ea0 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003e94:	30 09       	mov	r9,0
80003e96:	fe f8 04 16 	ld.w	r8,pc[1046]
80003e9a:	91 09       	st.w	r8[0x0],r9
80003e9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ea0:	fe f9 04 14 	ld.w	r9,pc[1044]
80003ea4:	72 08       	ld.w	r8,r9[0x0]
80003ea6:	20 18       	sub	r8,1
80003ea8:	93 08       	st.w	r9[0x0],r8
80003eaa:	c0 71       	brne	80003eb8 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003eac:	30 09       	mov	r9,0
80003eae:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003eb2:	91 09       	st.w	r8[0x0],r9
80003eb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003eb8:	fe f8 04 14 	ld.w	r8,pc[1044]
80003ebc:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003ec0:	72 0a       	ld.w	r10,r9[0x0]
80003ec2:	70 09       	ld.w	r9,r8[0x0]
80003ec4:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003ec8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ecc:	70 09       	ld.w	r9,r8[0x0]
80003ece:	2f f9       	sub	r9,-1
80003ed0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ed2:	e0 49 01 ff 	cp.w	r9,511
80003ed6:	e0 88 00 16 	brls	80003f02 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
80003eda:	30 09       	mov	r9,0
80003edc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ede:	fe f6 03 ca 	ld.w	r6,pc[970]
80003ee2:	6c 0c       	ld.w	r12,r6[0x0]
80003ee4:	f0 1f 00 fc 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ee8:	fe f8 03 bc 	ld.w	r8,pc[956]
80003eec:	70 0c       	ld.w	r12,r8[0x0]
80003eee:	f0 1f 00 e8 	mcall	8000428c <phy_rx_func+0xbdc>
80003ef2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ef4:	c0 71       	brne	80003f02 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
80003ef6:	30 09       	mov	r9,0
80003ef8:	fe f8 03 b4 	ld.w	r8,pc[948]
80003efc:	91 09       	st.w	r8[0x0],r9
80003efe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f02:	fe f9 03 b2 	ld.w	r9,pc[946]
80003f06:	72 08       	ld.w	r8,r9[0x0]
80003f08:	20 18       	sub	r8,1
80003f0a:	93 08       	st.w	r9[0x0],r8
80003f0c:	c0 71       	brne	80003f1a <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
80003f0e:	30 09       	mov	r9,0
80003f10:	fe f8 03 9c 	ld.w	r8,pc[924]
80003f14:	91 09       	st.w	r8[0x0],r9
80003f16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003f1a:	fe f8 03 b2 	ld.w	r8,pc[946]
80003f1e:	fe f9 03 8a 	ld.w	r9,pc[906]
80003f22:	72 0a       	ld.w	r10,r9[0x0]
80003f24:	70 09       	ld.w	r9,r8[0x0]
80003f26:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003f2a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f2e:	70 09       	ld.w	r9,r8[0x0]
80003f30:	2f f9       	sub	r9,-1
80003f32:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f34:	e0 49 01 ff 	cp.w	r9,511
80003f38:	e0 88 00 16 	brls	80003f64 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f3c:	30 09       	mov	r9,0
80003f3e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f40:	fe f6 03 68 	ld.w	r6,pc[872]
80003f44:	6c 0c       	ld.w	r12,r6[0x0]
80003f46:	f0 1f 00 e4 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f4a:	fe f8 03 5a 	ld.w	r8,pc[858]
80003f4e:	70 0c       	ld.w	r12,r8[0x0]
80003f50:	f0 1f 00 cf 	mcall	8000428c <phy_rx_func+0xbdc>
80003f54:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f56:	c0 71       	brne	80003f64 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003f58:	30 09       	mov	r9,0
80003f5a:	fe f8 03 52 	ld.w	r8,pc[850]
80003f5e:	91 09       	st.w	r8[0x0],r9
80003f60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f64:	fe f9 03 50 	ld.w	r9,pc[848]
80003f68:	72 08       	ld.w	r8,r9[0x0]
80003f6a:	20 18       	sub	r8,1
80003f6c:	93 08       	st.w	r9[0x0],r8
80003f6e:	c0 71       	brne	80003f7c <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003f70:	30 09       	mov	r9,0
80003f72:	fe f8 03 3a 	ld.w	r8,pc[826]
80003f76:	91 09       	st.w	r8[0x0],r9
80003f78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003f7c:	fe f8 03 50 	ld.w	r8,pc[848]
80003f80:	fe f9 03 28 	ld.w	r9,pc[808]
80003f84:	72 0a       	ld.w	r10,r9[0x0]
80003f86:	70 09       	ld.w	r9,r8[0x0]
80003f88:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f8c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f90:	70 09       	ld.w	r9,r8[0x0]
80003f92:	2f f9       	sub	r9,-1
80003f94:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f96:	e0 49 01 ff 	cp.w	r9,511
80003f9a:	e0 88 00 16 	brls	80003fc6 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f9e:	30 09       	mov	r9,0
80003fa0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fa2:	fe f6 03 06 	ld.w	r6,pc[774]
80003fa6:	6c 0c       	ld.w	r12,r6[0x0]
80003fa8:	f0 1f 00 cb 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fac:	fe f8 02 f8 	ld.w	r8,pc[760]
80003fb0:	70 0c       	ld.w	r12,r8[0x0]
80003fb2:	f0 1f 00 b7 	mcall	8000428c <phy_rx_func+0xbdc>
80003fb6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fb8:	c0 71       	brne	80003fc6 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003fba:	30 09       	mov	r9,0
80003fbc:	fe f8 02 f0 	ld.w	r8,pc[752]
80003fc0:	91 09       	st.w	r8[0x0],r9
80003fc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fc6:	fe f9 02 ee 	ld.w	r9,pc[750]
80003fca:	72 08       	ld.w	r8,r9[0x0]
80003fcc:	20 18       	sub	r8,1
80003fce:	93 08       	st.w	r9[0x0],r8
80003fd0:	c0 71       	brne	80003fde <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003fd2:	30 09       	mov	r9,0
80003fd4:	fe f8 02 d8 	ld.w	r8,pc[728]
80003fd8:	91 09       	st.w	r8[0x0],r9
80003fda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003fde:	fe f8 02 ee 	ld.w	r8,pc[750]
80003fe2:	fe f9 02 c6 	ld.w	r9,pc[710]
80003fe6:	72 0a       	ld.w	r10,r9[0x0]
80003fe8:	70 09       	ld.w	r9,r8[0x0]
80003fea:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003fee:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ff2:	70 09       	ld.w	r9,r8[0x0]
80003ff4:	2f f9       	sub	r9,-1
80003ff6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ff8:	e0 49 01 ff 	cp.w	r9,511
80003ffc:	e0 88 00 16 	brls	80004028 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
80004000:	30 09       	mov	r9,0
80004002:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004004:	fe f7 02 a4 	ld.w	r7,pc[676]
80004008:	6e 0c       	ld.w	r12,r7[0x0]
8000400a:	f0 1f 00 b3 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000400e:	fe f8 02 96 	ld.w	r8,pc[662]
80004012:	70 0c       	ld.w	r12,r8[0x0]
80004014:	f0 1f 00 9e 	mcall	8000428c <phy_rx_func+0xbdc>
80004018:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000401a:	c0 71       	brne	80004028 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
8000401c:	30 09       	mov	r9,0
8000401e:	fe f8 02 8e 	ld.w	r8,pc[654]
80004022:	91 09       	st.w	r8[0x0],r9
80004024:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004028:	fe f9 02 8c 	ld.w	r9,pc[652]
8000402c:	72 08       	ld.w	r8,r9[0x0]
8000402e:	20 18       	sub	r8,1
80004030:	93 08       	st.w	r9[0x0],r8
80004032:	c0 71       	brne	80004040 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80004034:	30 09       	mov	r9,0
80004036:	fe f8 02 76 	ld.w	r8,pc[630]
8000403a:	91 09       	st.w	r8[0x0],r9
8000403c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004040:	20 18       	sub	r8,1
80004042:	fe f9 02 72 	ld.w	r9,pc[626]
80004046:	93 08       	st.w	r9[0x0],r8
80004048:	58 08       	cp.w	r8,0
8000404a:	e0 81 01 13 	brne	80004270 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000404e:	30 09       	mov	r9,0
80004050:	fe f8 02 5c 	ld.w	r8,pc[604]
80004054:	91 09       	st.w	r8[0x0],r9
80004056:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000405a:	fe f8 02 6a 	ld.w	r8,pc[618]
8000405e:	11 89       	ld.ub	r9,r8[0x0]
80004060:	30 48       	mov	r8,4
80004062:	f0 09 18 00 	cp.b	r9,r8
80004066:	c0 80       	breq	80004076 <phy_rx_func+0x9c6>
80004068:	fe f8 02 5c 	ld.w	r8,pc[604]
8000406c:	11 89       	ld.ub	r9,r8[0x0]
8000406e:	30 38       	mov	r8,3
80004070:	f0 09 18 00 	cp.b	r9,r8
80004074:	c1 41       	brne	8000409c <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004076:	6e 29       	ld.w	r9,r7[0x8]
80004078:	fe f8 02 74 	ld.w	r8,pc[628]
8000407c:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000407e:	6e 39       	ld.w	r9,r7[0xc]
80004080:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004082:	fe f9 02 32 	ld.w	r9,pc[562]
80004086:	72 08       	ld.w	r8,r9[0x0]
80004088:	20 88       	sub	r8,8
8000408a:	93 08       	st.w	r9[0x0],r8
8000408c:	e0 81 00 f2 	brne	80004270 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80004090:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004092:	fe f9 02 1a 	ld.w	r9,pc[538]
80004096:	93 08       	st.w	r9[0x0],r8
80004098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000409c:	fe f8 02 28 	ld.w	r8,pc[552]
800040a0:	11 89       	ld.ub	r9,r8[0x0]
800040a2:	31 38       	mov	r8,19
800040a4:	f0 09 18 00 	cp.b	r9,r8
800040a8:	e0 81 00 9c 	brne	800041e0 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
800040ac:	fe f8 02 4c 	ld.w	r8,pc[588]
800040b0:	11 88       	ld.ub	r8,r8[0x0]
800040b2:	30 c9       	mov	r9,12
800040b4:	f2 08 18 00 	cp.b	r8,r9
800040b8:	e0 81 00 7b 	brne	800041ae <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800040bc:	8e 49       	ld.sh	r9,r7[0x8]
800040be:	fe f8 02 3e 	ld.w	r8,pc[574]
800040c2:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800040c6:	30 09       	mov	r9,0
800040c8:	fe f8 02 30 	ld.w	r8,pc[560]
800040cc:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040ce:	ef 39 00 0d 	ld.ub	r9,r7[13]
800040d2:	3f 38       	mov	r8,-13
800040d4:	f0 09 18 00 	cp.b	r9,r8
800040d8:	c6 61       	brne	800041a4 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800040da:	10 99       	mov	r9,r8
800040dc:	4f a8       	lddpc	r8,800042c4 <phy_rx_func+0xc14>
800040de:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800040e0:	ef 39 00 0c 	ld.ub	r9,r7[12]
800040e4:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800040e8:	4f 38       	lddpc	r8,800042b4 <phy_rx_func+0xc04>
800040ea:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800040ec:	30 19       	mov	r9,1
800040ee:	fe f8 02 12 	ld.w	r8,pc[530]
800040f2:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800040f4:	8e 79       	ld.sh	r9,r7[0xe]
800040f6:	fe f8 01 fe 	ld.w	r8,pc[510]
800040fa:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800040fc:	4f 48       	lddpc	r8,800042cc <phy_rx_func+0xc1c>
800040fe:	4e b9       	lddpc	r9,800042a8 <phy_rx_func+0xbf8>
80004100:	72 0a       	ld.w	r10,r9[0x0]
80004102:	70 09       	ld.w	r9,r8[0x0]
80004104:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004108:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000410c:	70 09       	ld.w	r9,r8[0x0]
8000410e:	2f f9       	sub	r9,-1
80004110:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004112:	e0 49 01 ff 	cp.w	r9,511
80004116:	e0 88 00 13 	brls	8000413c <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
8000411a:	30 09       	mov	r9,0
8000411c:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000411e:	4e 36       	lddpc	r6,800042a8 <phy_rx_func+0xbf8>
80004120:	6c 0c       	ld.w	r12,r6[0x0]
80004122:	f0 1f 00 6d 	mcall	800042d4 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80004126:	4e 08       	lddpc	r8,800042a4 <phy_rx_func+0xbf4>
80004128:	70 0c       	ld.w	r12,r8[0x0]
8000412a:	f0 1f 00 59 	mcall	8000428c <phy_rx_func+0xbdc>
8000412e:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004130:	c0 61       	brne	8000413c <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80004132:	30 09       	mov	r9,0
80004134:	4d e8       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
80004136:	91 09       	st.w	r8[0x0],r9
80004138:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000413c:	4d e9       	lddpc	r9,800042b4 <phy_rx_func+0xc04>
8000413e:	72 08       	ld.w	r8,r9[0x0]
80004140:	20 18       	sub	r8,1
80004142:	93 08       	st.w	r9[0x0],r8
80004144:	c0 61       	brne	80004150 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80004146:	30 09       	mov	r9,0
80004148:	4d 98       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000414a:	91 09       	st.w	r8[0x0],r9
8000414c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80004150:	4d f8       	lddpc	r8,800042cc <phy_rx_func+0xc1c>
80004152:	4d 69       	lddpc	r9,800042a8 <phy_rx_func+0xbf8>
80004154:	72 0a       	ld.w	r10,r9[0x0]
80004156:	70 09       	ld.w	r9,r8[0x0]
80004158:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000415c:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004160:	70 09       	ld.w	r9,r8[0x0]
80004162:	2f f9       	sub	r9,-1
80004164:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004166:	e0 49 01 ff 	cp.w	r9,511
8000416a:	e0 88 00 13 	brls	80004190 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
8000416e:	30 09       	mov	r9,0
80004170:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004172:	4c e7       	lddpc	r7,800042a8 <phy_rx_func+0xbf8>
80004174:	6e 0c       	ld.w	r12,r7[0x0]
80004176:	f0 1f 00 58 	mcall	800042d4 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
8000417a:	4c b8       	lddpc	r8,800042a4 <phy_rx_func+0xbf4>
8000417c:	70 0c       	ld.w	r12,r8[0x0]
8000417e:	f0 1f 00 44 	mcall	8000428c <phy_rx_func+0xbdc>
80004182:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004184:	c0 61       	brne	80004190 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80004186:	30 09       	mov	r9,0
80004188:	4c 98       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000418a:	91 09       	st.w	r8[0x0],r9
8000418c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004190:	4c 99       	lddpc	r9,800042b4 <phy_rx_func+0xc04>
80004192:	72 08       	ld.w	r8,r9[0x0]
80004194:	20 18       	sub	r8,1
80004196:	93 08       	st.w	r9[0x0],r8
80004198:	c6 c1       	brne	80004270 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
8000419a:	30 09       	mov	r9,0
8000419c:	4c 48       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000419e:	91 09       	st.w	r8[0x0],r9
800041a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800041a4:	30 09       	mov	r9,0
800041a6:	4c 28       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
800041a8:	91 09       	st.w	r8[0x0],r9
800041aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800041ae:	8e 4a       	ld.sh	r10,r7[0x8]
800041b0:	4d 39       	lddpc	r9,800042fc <phy_rx_func+0xc4c>
800041b2:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800041b6:	4d 1a       	lddpc	r10,800042f8 <phy_rx_func+0xc48>
800041b8:	15 88       	ld.ub	r8,r10[0x0]
800041ba:	f0 cb ff ff 	sub	r11,r8,-1
800041be:	8e 5c       	ld.sh	r12,r7[0xa]
800041c0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800041c4:	f0 cb ff fe 	sub	r11,r8,-2
800041c8:	8e 6c       	ld.sh	r12,r7[0xc]
800041ca:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800041ce:	f0 cb ff fd 	sub	r11,r8,-3
800041d2:	8e 7c       	ld.sh	r12,r7[0xe]
800041d4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800041d8:	2f c8       	sub	r8,-4
800041da:	b4 88       	st.b	r10[0x0],r8
800041dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800041e0:	30 09       	mov	r9,0
800041e2:	4b 38       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
800041e4:	91 09       	st.w	r8[0x0],r9
800041e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800041ea:	4b f8       	lddpc	r8,800042e4 <phy_rx_func+0xc34>
800041ec:	70 09       	ld.w	r9,r8[0x0]
800041ee:	8e 4b       	ld.sh	r11,r7[0x8]
800041f0:	4b ea       	lddpc	r10,800042e8 <phy_rx_func+0xc38>
800041f2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800041f6:	2f f9       	sub	r9,-1
800041f8:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800041fa:	4b 48       	lddpc	r8,800042c8 <phy_rx_func+0xc18>
800041fc:	70 09       	ld.w	r9,r8[0x0]
800041fe:	20 29       	sub	r9,2
80004200:	91 09       	st.w	r8[0x0],r9
80004202:	70 08       	ld.w	r8,r8[0x0]
80004204:	58 08       	cp.w	r8,0
80004206:	c2 f1       	brne	80004264 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80004208:	30 09       	mov	r9,0
8000420a:	4b 78       	lddpc	r8,800042e4 <phy_rx_func+0xc34>
8000420c:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000420e:	8e 59       	ld.sh	r9,r7[0xa]
80004210:	fe 78 82 12 	mov	r8,-32238
80004214:	f0 09 19 00 	cp.h	r9,r8
80004218:	c2 11       	brne	8000425a <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000421a:	ef 3c 00 0d 	ld.ub	r12,r7[13]
8000421e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004222:	4a e8       	lddpc	r8,800042d8 <phy_rx_func+0xc28>
80004224:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004226:	8e 59       	ld.sh	r9,r7[0xa]
80004228:	4a d8       	lddpc	r8,800042dc <phy_rx_func+0xc2c>
8000422a:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
8000422c:	8e 69       	ld.sh	r9,r7[0xc]
8000422e:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004230:	f0 1f 00 2c 	mcall	800042e0 <phy_rx_func+0xc30>
80004234:	49 f8       	lddpc	r8,800042b0 <phy_rx_func+0xc00>
80004236:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004238:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000423c:	31 38       	mov	r8,19
8000423e:	f0 09 18 00 	cp.b	r9,r8
80004242:	c0 71       	brne	80004250 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004244:	10 99       	mov	r9,r8
80004246:	4a 08       	lddpc	r8,800042c4 <phy_rx_func+0xc14>
80004248:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
8000424a:	30 09       	mov	r9,0
8000424c:	49 a8       	lddpc	r8,800042b4 <phy_rx_func+0xc04>
8000424e:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004250:	30 49       	mov	r9,4
80004252:	49 78       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
80004254:	91 09       	st.w	r8[0x0],r9
80004256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000425a:	30 09       	mov	r9,0
8000425c:	49 48       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000425e:	91 09       	st.w	r8[0x0],r9
80004260:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004264:	4a 8c       	lddpc	r12,80004304 <phy_rx_func+0xc54>
80004266:	f0 1f 00 16 	mcall	800042bc <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
8000426a:	30 09       	mov	r9,0
8000426c:	49 08       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000426e:	91 09       	st.w	r8[0x0],r9
80004270:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004274:	00 00       	add	r0,r0
80004276:	0a c4       	st.b	r5++,r4
80004278:	00 00       	add	r0,r0
8000427a:	0a bc       	st.h	r5++,r12
8000427c:	00 00       	add	r0,r0
8000427e:	0a 90       	mov	r0,r5
80004280:	00 00       	add	r0,r0
80004282:	0a 6c       	and	r12,r5
80004284:	00 00       	add	r0,r0
80004286:	0a d6       	st.w	--r5,r6
80004288:	00 00       	add	r0,r0
8000428a:	0a 9c       	mov	r12,r5
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	30 7c       	mov	r12,7
80004290:	00 00       	add	r0,r0
80004292:	0a 7c       	tst	r12,r5
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	5e 60       	retmi	r0
80004298:	00 00       	add	r0,r0
8000429a:	0a 98       	mov	r8,r5
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	2f c8       	sub	r8,-4
800042a0:	00 00       	add	r0,r0
800042a2:	0a ac       	st.w	r5++,r12
800042a4:	00 00       	add	r0,r0
800042a6:	0a 78       	tst	r8,r5
800042a8:	00 00       	add	r0,r0
800042aa:	0a b4       	st.h	r5++,r4
800042ac:	00 00       	add	r0,r0
800042ae:	0a 88       	andn	r8,r5
800042b0:	00 00       	add	r0,r0
800042b2:	0a 74       	tst	r4,r5
800042b4:	00 00       	add	r0,r0
800042b6:	0a a0       	st.w	r5++,r0
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	db 84       	*unknown*
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	6f 00       	ld.w	r0,r7[0x40]
800042c0:	00 00       	add	r0,r0
800042c2:	0a 4a       	or	r10,r5
800042c4:	00 00       	add	r0,r0
800042c6:	0a d4       	st.w	--r5,r4
800042c8:	00 00       	add	r0,r0
800042ca:	0a 70       	tst	r0,r5
800042cc:	00 00       	add	r0,r0
800042ce:	0a b0       	st.h	r5++,r0
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	78 76       	ld.w	r6,r12[0x1c]
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	36 50       	mov	r0,101
800042d8:	00 00       	add	r0,r0
800042da:	0a 4b       	or	r11,r5
800042dc:	00 00       	add	r0,r0
800042de:	1e 90       	mov	r0,pc
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	2f 0c       	sub	r12,-16
800042e4:	00 00       	add	r0,r0
800042e6:	0a cc       	st.b	r5++,r12
800042e8:	00 00       	add	r0,r0
800042ea:	1d 94       	ld.ub	r4,lr[0x1]
800042ec:	00 00       	add	r0,r0
800042ee:	0a d8       	st.w	--r5,r8
800042f0:	00 00       	add	r0,r0
800042f2:	0a 51       	eor	r1,r5
800042f4:	00 00       	add	r0,r0
800042f6:	1d 8c       	ld.ub	r12,lr[0x0]
800042f8:	00 00       	add	r0,r0
800042fa:	0a 8c       	andn	r12,r5
800042fc:	00 00       	add	r0,r0
800042fe:	1e 94       	mov	r4,pc
80004300:	00 00       	add	r0,r0
80004302:	0a 41       	or	r1,r5
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	db 9c       	*unknown*

80004308 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004308:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000430a:	49 88       	lddpc	r8,80004368 <pdca_int_handler+0x60>
8000430c:	11 89       	ld.ub	r9,r8[0x0]
8000430e:	ec 19 00 01 	eorl	r9,0x1
80004312:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004314:	11 89       	ld.ub	r9,r8[0x0]
80004316:	a5 69       	lsl	r9,0x4
80004318:	2f c9       	sub	r9,-4
8000431a:	49 5a       	lddpc	r10,8000436c <pdca_int_handler+0x64>
8000431c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000431e:	fe 7a 00 40 	mov	r10,-65472
80004322:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004324:	30 39       	mov	r9,3
80004326:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004328:	11 8a       	ld.ub	r10,r8[0x0]
8000432a:	a5 6a       	lsl	r10,0x4
8000432c:	2f ca       	sub	r10,-4
8000432e:	49 18       	lddpc	r8,80004370 <pdca_int_handler+0x68>
80004330:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004332:	fe 78 00 00 	mov	r8,-65536
80004336:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004338:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000433a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000433c:	48 e8       	lddpc	r8,80004374 <pdca_int_handler+0x6c>
8000433e:	70 08       	ld.w	r8,r8[0x0]
80004340:	58 08       	cp.w	r8,0
80004342:	c0 70       	breq	80004350 <pdca_int_handler+0x48>
80004344:	48 99       	lddpc	r9,80004368 <pdca_int_handler+0x60>
80004346:	13 89       	ld.ub	r9,r9[0x0]
80004348:	a5 69       	lsl	r9,0x4
8000434a:	48 ac       	lddpc	r12,80004370 <pdca_int_handler+0x68>
8000434c:	12 0c       	add	r12,r9
8000434e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004350:	48 a8       	lddpc	r8,80004378 <pdca_int_handler+0x70>
80004352:	70 08       	ld.w	r8,r8[0x0]
80004354:	58 08       	cp.w	r8,0
80004356:	c0 70       	breq	80004364 <pdca_int_handler+0x5c>
80004358:	48 49       	lddpc	r9,80004368 <pdca_int_handler+0x60>
8000435a:	13 89       	ld.ub	r9,r9[0x0]
8000435c:	a5 69       	lsl	r9,0x4
8000435e:	48 4c       	lddpc	r12,8000436c <pdca_int_handler+0x64>
80004360:	12 0c       	add	r12,r9
80004362:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004364:	d4 02       	popm	lr
80004366:	d6 03       	rete
80004368:	00 00       	add	r0,r0
8000436a:	50 b4       	stdsp	sp[0x2c],r4
8000436c:	00 00       	add	r0,r0
8000436e:	50 dc       	stdsp	sp[0x34],r12
80004370:	00 00       	add	r0,r0
80004372:	50 bc       	stdsp	sp[0x2c],r12
80004374:	00 00       	add	r0,r0
80004376:	0a e0       	st.h	--r5,r0
80004378:	00 00       	add	r0,r0
8000437a:	0a e4       	st.h	--r5,r4

8000437c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
8000437c:	fe 78 10 00 	mov	r8,-61440
80004380:	e0 69 0d c0 	mov	r9,3520
80004384:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004388:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000438c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004390:	fe 78 34 00 	mov	r8,-52224
80004394:	e0 69 80 00 	mov	r9,32768
80004398:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000439a:	30 09       	mov	r9,0
8000439c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000439e:	e0 69 04 21 	mov	r9,1057
800043a2:	ea 19 3f 20 	orh	r9,0x3f20
800043a6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
800043a8:	e0 69 02 9f 	mov	r9,671
800043ac:	ea 19 01 00 	orh	r9,0x100
800043b0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
800043b2:	e0 6a 04 02 	mov	r10,1026
800043b6:	ea 1a 3f 20 	orh	r10,0x3f20
800043ba:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800043bc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800043be:	5e fc       	retal	r12

800043c0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800043c0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800043c2:	30 19       	mov	r9,1
800043c4:	49 78       	lddpc	r8,80004420 <local_start_PDC+0x60>
800043c6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800043c8:	fe 78 00 00 	mov	r8,-65536
800043cc:	30 7b       	mov	r11,7
800043ce:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800043d0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800043d2:	49 59       	lddpc	r9,80004424 <local_start_PDC+0x64>
800043d4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800043d8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800043da:	30 3a       	mov	r10,3
800043dc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800043de:	30 1c       	mov	r12,1
800043e0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800043e2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800043e4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800043e6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800043e8:	30 2c       	mov	r12,2
800043ea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800043ec:	48 f9       	lddpc	r9,80004428 <local_start_PDC+0x68>
800043ee:	e0 68 5a 5a 	mov	r8,23130
800043f2:	ea 18 ab cd 	orh	r8,0xabcd
800043f6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800043f8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800043fa:	30 0e       	mov	lr,0
800043fc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800043fe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004400:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004402:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004404:	fe 78 00 40 	mov	r8,-65472
80004408:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000440a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000440c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004410:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004412:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004414:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004416:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004418:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000441a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000441c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000441e:	d8 02       	popm	pc
80004420:	00 00       	add	r0,r0
80004422:	50 b4       	stdsp	sp[0x2c],r4
80004424:	00 00       	add	r0,r0
80004426:	50 bc       	stdsp	sp[0x2c],r12
80004428:	00 00       	add	r0,r0
8000442a:	50 dc       	stdsp	sp[0x34],r12

8000442c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000442c:	48 38       	lddpc	r8,80004438 <register_rx_tx_func+0xc>
8000442e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004430:	48 38       	lddpc	r8,8000443c <register_rx_tx_func+0x10>
80004432:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004434:	5e fc       	retal	r12
80004436:	00 00       	add	r0,r0
80004438:	00 00       	add	r0,r0
8000443a:	0a e0       	st.h	--r5,r0
8000443c:	00 00       	add	r0,r0
8000443e:	0a e4       	st.h	--r5,r4

80004440 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004440:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004442:	fe 78 10 00 	mov	r8,-61440
80004446:	30 29       	mov	r9,2
80004448:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000444c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004450:	10 99       	mov	r9,r8
80004452:	f2 f8 01 60 	ld.w	r8,r9[352]
80004456:	e2 18 00 02 	andl	r8,0x2,COH
8000445a:	cf c0       	breq	80004452 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000445c:	fe 79 10 00 	mov	r9,-61440
80004460:	f2 f8 01 60 	ld.w	r8,r9[352]
80004464:	e2 18 00 02 	andl	r8,0x2,COH
80004468:	cf c1       	brne	80004460 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000446a:	30 3a       	mov	r10,3
8000446c:	36 0b       	mov	r11,96
8000446e:	48 bc       	lddpc	r12,80004498 <ssc_init+0x58>
80004470:	f0 1f 00 0b 	mcall	8000449c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004474:	f0 1f 00 0b 	mcall	800044a0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004478:	f0 1f 00 0b 	mcall	800044a4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000447c:	fe 79 00 00 	mov	r9,-65536
80004480:	30 18       	mov	r8,1
80004482:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004484:	fe 7a 00 40 	mov	r10,-65472
80004488:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000448a:	e0 6b 01 01 	mov	r11,257
8000448e:	fe 7a 34 00 	mov	r10,-52224
80004492:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004494:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004496:	d8 02       	popm	pc
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	43 08       	lddsp	r8,sp[0xc0]
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	54 10       	stdsp	sp[0x104],r0
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	43 7c       	lddsp	r12,sp[0xdc]
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	43 c0       	lddsp	r0,sp[0xf0]

800044a8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800044a8:	48 28       	lddpc	r8,800044b0 <xcmp_register_app_list+0x8>
800044aa:	91 0c       	st.w	r8[0x0],r12
}
800044ac:	5e fc       	retal	r12
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	50 fc       	stdsp	sp[0x3c],r12

800044b4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800044b4:	eb cd 40 80 	pushm	r7,lr
800044b8:	fa cd 01 00 	sub	sp,sp,256
800044bc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800044be:	16 98       	mov	r8,r11
800044c0:	2f 08       	sub	r8,-16
800044c2:	af a8       	sbr	r8,0xe
800044c4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800044c6:	3f f8       	mov	r8,-1
800044c8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800044ca:	30 b9       	mov	r9,11
800044cc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800044ce:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800044d0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800044d2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800044d4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800044d6:	f6 ca ff fe 	sub	r10,r11,-2
800044da:	18 9b       	mov	r11,r12
800044dc:	fa cc ff f0 	sub	r12,sp,-16
800044e0:	f0 1f 00 05 	mcall	800044f4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800044e4:	2f e7       	sub	r7,-2
800044e6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800044e8:	1a 9c       	mov	r12,sp
800044ea:	f0 1f 00 04 	mcall	800044f8 <xcmp_tx+0x44>
}
800044ee:	2c 0d       	sub	sp,-256
800044f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	77 2e       	ld.w	lr,r11[0x48]
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	49 b4       	lddpc	r4,80004564 <xcmp_audio_route_AMBE+0x3c>

800044fc <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
800044fc:	d4 01       	pushm	lr
800044fe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004502:	e0 68 04 21 	mov	r8,1057
80004506:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004508:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
8000450c:	30 19       	mov	r9,1
8000450e:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004510:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80004512:	30 39       	mov	r9,3
80004514:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004516:	30 3b       	mov	r11,3
80004518:	fa cc ff fe 	sub	r12,sp,-2
8000451c:	f0 1f 00 02 	mcall	80004524 <xcmp_enter_device_control_mode+0x28>
}
80004520:	2c dd       	sub	sp,-204
80004522:	d8 02       	popm	pc
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	44 b4       	lddsp	r4,sp[0x12c]

80004528 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80004528:	d4 01       	pushm	lr
8000452a:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000452e:	e0 68 04 14 	mov	r8,1044
80004532:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004534:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004538:	30 19       	mov	r9,1
8000453a:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
8000453c:	30 09       	mov	r9,0
8000453e:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004540:	30 69       	mov	r9,6
80004542:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004544:	30 fa       	mov	r10,15
80004546:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004548:	30 c9       	mov	r9,12
8000454a:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
8000454c:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
8000454e:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80004550:	31 0a       	mov	r10,16
80004552:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004554:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80004558:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
8000455c:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80004560:	31 1a       	mov	r10,17
80004562:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004566:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
8000456a:	31 3a       	mov	r10,19
8000456c:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004570:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004574:	30 fb       	mov	r11,15
80004576:	fa cc ff fe 	sub	r12,sp,-2
8000457a:	f0 1f 00 03 	mcall	80004584 <xcmp_audio_route_AMBE+0x5c>

	
}
8000457e:	2c dd       	sub	sp,-204
80004580:	d8 02       	popm	pc
80004582:	00 00       	add	r0,r0
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	44 b4       	lddsp	r4,sp[0x12c]

80004588 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004588:	d4 01       	pushm	lr
8000458a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
8000458e:	e0 68 04 65 	mov	r8,1125
80004592:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004594:	fa cc ff fe 	sub	r12,sp,-2
80004598:	30 18       	mov	r8,1
8000459a:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
8000459c:	30 1b       	mov	r11,1
8000459e:	f0 1f 00 03 	mcall	800045a8 <xcmp_enter_enhanced_OB_mode+0x20>
}
800045a2:	2c dd       	sub	sp,-204
800045a4:	d8 02       	popm	pc
800045a6:	00 00       	add	r0,r0
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	44 b4       	lddsp	r4,sp[0x12c]

800045ac <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800045ac:	d4 01       	pushm	lr
800045ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800045b2:	fe 78 b4 00 	mov	r8,-19456
800045b6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800045b8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800045bc:	30 89       	mov	r9,8
800045be:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800045c0:	30 19       	mov	r9,1
800045c2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800045c4:	30 09       	mov	r9,0
800045c6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800045c8:	30 5a       	mov	r10,5
800045ca:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800045cc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800045ce:	30 7a       	mov	r10,7
800045d0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800045d2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800045d4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800045d6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800045da:	30 9b       	mov	r11,9
800045dc:	fa cc ff fe 	sub	r12,sp,-2
800045e0:	f0 1f 00 02 	mcall	800045e8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800045e4:	2c dd       	sub	sp,-204
800045e6:	d8 02       	popm	pc
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	44 b4       	lddsp	r4,sp[0x12c]

800045ec <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800045ec:	d4 01       	pushm	lr
800045ee:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800045f2:	fe 78 80 00 	mov	r8,-32768
800045f6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800045f8:	30 38       	mov	r8,3
800045fa:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800045fc:	30 1b       	mov	r11,1
800045fe:	fa cc ff fe 	sub	r12,sp,-2
80004602:	f0 1f 00 03 	mcall	8000460c <xcmp_opcode_not_supported+0x20>
}
80004606:	2c dd       	sub	sp,-204
80004608:	d8 02       	popm	pc
8000460a:	00 00       	add	r0,r0
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	44 b4       	lddsp	r4,sp[0x12c]

80004610 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004610:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004612:	96 88       	ld.uh	r8,r11[0x0]
80004614:	e2 18 f0 00 	andl	r8,0xf000,COH
80004618:	e0 48 80 00 	cp.w	r8,32768
8000461c:	c0 f0       	breq	8000463a <xcmp_exec_func+0x2a>
8000461e:	e0 48 b0 00 	cp.w	r8,45056
80004622:	c1 20       	breq	80004646 <xcmp_exec_func+0x36>
80004624:	58 08       	cp.w	r8,0
80004626:	c1 51       	brne	80004650 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004628:	78 08       	ld.w	r8,r12[0x0]
8000462a:	58 08       	cp.w	r8,0
8000462c:	c0 40       	breq	80004634 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000462e:	16 9c       	mov	r12,r11
80004630:	5d 18       	icall	r8
80004632:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004634:	f0 1f 00 08 	mcall	80004654 <xcmp_exec_func+0x44>
80004638:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000463a:	78 18       	ld.w	r8,r12[0x4]
8000463c:	58 08       	cp.w	r8,0
8000463e:	c0 90       	breq	80004650 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004640:	16 9c       	mov	r12,r11
80004642:	5d 18       	icall	r8
80004644:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004646:	78 28       	ld.w	r8,r12[0x8]
80004648:	58 08       	cp.w	r8,0
8000464a:	c0 30       	breq	80004650 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000464c:	16 9c       	mov	r12,r11
8000464e:	5d 18       	icall	r8
80004650:	d8 02       	popm	pc
80004652:	00 00       	add	r0,r0
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	45 ec       	lddsp	r12,sp[0x178]

80004658 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004658:	d4 01       	pushm	lr
8000465a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000465e:	e0 68 04 09 	mov	r8,1033
80004662:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004664:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004668:	30 19       	mov	r9,1
8000466a:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
8000466c:	30 09       	mov	r9,0
8000466e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004670:	30 ca       	mov	r10,12
80004672:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004674:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004676:	fb 69 00 08 	st.b	sp[8],r9
8000467a:	fa c8 ff f7 	sub	r8,sp,-9
8000467e:	b0 89       	st.b	r8[0x0],r9
80004680:	fa c8 ff f6 	sub	r8,sp,-10
80004684:	b0 89       	st.b	r8[0x0],r9
80004686:	fa c8 ff f5 	sub	r8,sp,-11
8000468a:	b0 89       	st.b	r8[0x0],r9
8000468c:	fa c8 ff f4 	sub	r8,sp,-12
80004690:	b0 89       	st.b	r8[0x0],r9
80004692:	fa c8 ff f3 	sub	r8,sp,-13
80004696:	b0 89       	st.b	r8[0x0],r9
80004698:	fa c8 ff f2 	sub	r8,sp,-14
8000469c:	b0 89       	st.b	r8[0x0],r9
8000469e:	fa c8 ff f1 	sub	r8,sp,-15
800046a2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800046a4:	30 cb       	mov	r11,12
800046a6:	fa cc ff fe 	sub	r12,sp,-2
800046aa:	f0 1f 00 03 	mcall	800046b4 <xcmp_IdleTestTone+0x5c>
}
800046ae:	2c dd       	sub	sp,-204
800046b0:	d8 02       	popm	pc
800046b2:	00 00       	add	r0,r0
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	44 b4       	lddsp	r4,sp[0x12c]

800046b8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800046b8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800046ba:	48 dc       	lddpc	r12,800046ec <xcmp_init+0x34>
800046bc:	f0 1f 00 0d 	mcall	800046f0 <xcmp_init+0x38>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800046c0:	30 4b       	mov	r11,4
800046c2:	31 4c       	mov	r12,20
800046c4:	f0 1f 00 0c 	mcall	800046f4 <xcmp_init+0x3c>
800046c8:	48 c8       	lddpc	r8,800046f8 <xcmp_init+0x40>
800046ca:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800046cc:	30 09       	mov	r9,0
800046ce:	1a d9       	st.w	--sp,r9
800046d0:	1a d9       	st.w	--sp,r9
800046d2:	1a d9       	st.w	--sp,r9
800046d4:	30 38       	mov	r8,3
800046d6:	e0 6a 01 80 	mov	r10,384
800046da:	48 9b       	lddpc	r11,800046fc <xcmp_init+0x44>
800046dc:	48 9c       	lddpc	r12,80004700 <xcmp_init+0x48>
800046de:	f0 1f 00 0a 	mcall	80004704 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800046e2:	f0 1f 00 0a 	mcall	80004708 <xcmp_init+0x50>
800046e6:	2f dd       	sub	sp,-12
	
}
800046e8:	d8 02       	popm	pc
800046ea:	00 00       	add	r0,r0
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	48 08       	lddpc	r8,800046ec <xcmp_init+0x34>
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	48 54       	lddpc	r4,80004704 <xcmp_init+0x4c>
800046f4:	80 00       	ld.sh	r0,r0[0x0]
800046f6:	62 dc       	ld.w	r12,r1[0x34]
800046f8:	00 00       	add	r0,r0
800046fa:	0a f4       	st.b	--r5,r4
800046fc:	80 00       	ld.sh	r0,r0[0x0]
800046fe:	db c8       	*unknown*
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	47 0c       	lddsp	r12,sp[0x1c0]
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	69 b0       	ld.w	r0,r4[0x6c]
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	4a 98       	lddpc	r8,800047ac <xcmp_rx_process+0xa0>

8000470c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000470c:	d4 31       	pushm	r0-r7,lr
8000470e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004710:	4b 16       	lddpc	r6,800047d4 <xcmp_rx_process+0xc8>
80004712:	30 05       	mov	r5,0
80004714:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004716:	4b 13       	lddpc	r3,800047d8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004718:	4b 12       	lddpc	r2,800047dc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000471a:	4b 21       	lddpc	r1,800047e0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000471c:	4b 20       	lddpc	r0,800047e4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000471e:	6c 0c       	ld.w	r12,r6[0x0]
80004720:	0a 99       	mov	r9,r5
80004722:	08 9a       	mov	r10,r4
80004724:	1a 9b       	mov	r11,sp
80004726:	f0 1f 00 31 	mcall	800047e8 <xcmp_rx_process+0xdc>
8000472a:	58 1c       	cp.w	r12,1
8000472c:	cf 91       	brne	8000471e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000472e:	40 0b       	lddsp	r11,sp[0x0]
80004730:	58 0b       	cp.w	r11,0
80004732:	cf 60       	breq	8000471e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004734:	96 0a       	ld.sh	r10,r11[0x0]
80004736:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000473a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000473e:	59 c8       	cp.w	r8,28
80004740:	c1 e0       	breq	8000477c <xcmp_rx_process+0x70>
80004742:	e0 89 00 07 	brgt	80004750 <xcmp_rx_process+0x44>
80004746:	58 e8       	cp.w	r8,14
80004748:	c0 e0       	breq	80004764 <xcmp_rx_process+0x58>
8000474a:	58 f8       	cp.w	r8,15
8000474c:	c2 41       	brne	80004794 <xcmp_rx_process+0x88>
8000474e:	c0 f8       	rjmp	8000476c <xcmp_rx_process+0x60>
80004750:	e0 48 01 09 	cp.w	r8,265
80004754:	c1 80       	breq	80004784 <xcmp_rx_process+0x78>
80004756:	e0 48 01 0a 	cp.w	r8,266
8000475a:	c1 90       	breq	8000478c <xcmp_rx_process+0x80>
8000475c:	e0 48 00 2c 	cp.w	r8,44
80004760:	c1 a1       	brne	80004794 <xcmp_rx_process+0x88>
80004762:	c0 98       	rjmp	80004774 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004764:	4a 2c       	lddpc	r12,800047ec <xcmp_rx_process+0xe0>
80004766:	f0 1f 00 23 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
8000476a:	c2 f8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000476c:	4a 2c       	lddpc	r12,800047f4 <xcmp_rx_process+0xe8>
8000476e:	f0 1f 00 21 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
80004772:	c2 b8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004774:	4a 1c       	lddpc	r12,800047f8 <xcmp_rx_process+0xec>
80004776:	f0 1f 00 1f 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
8000477a:	c2 78       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000477c:	04 9c       	mov	r12,r2
8000477e:	f0 1f 00 1d 	mcall	800047f0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004782:	c2 38       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004784:	02 9c       	mov	r12,r1
80004786:	f0 1f 00 1b 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
8000478a:	c1 f8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000478c:	00 9c       	mov	r12,r0
8000478e:	f0 1f 00 19 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
80004792:	c1 b8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004794:	12 98       	mov	r8,r9
80004796:	e2 18 04 00 	andl	r8,0x400,COH
8000479a:	c0 70       	breq	800047a8 <xcmp_rx_process+0x9c>
8000479c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800047a0:	e0 48 00 68 	cp.w	r8,104
800047a4:	e0 8a 00 08 	brle	800047b4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800047a8:	e2 19 f0 00 	andl	r9,0xf000,COH
800047ac:	c0 e1       	brne	800047c8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800047ae:	f0 1f 00 14 	mcall	800047fc <xcmp_rx_process+0xf0>
800047b2:	c0 b8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800047b4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800047b8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800047bc:	49 19       	lddpc	r9,80004800 <xcmp_rx_process+0xf4>
800047be:	72 08       	ld.w	r8,r9[0x0]
800047c0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800047c4:	f0 1f 00 0b 	mcall	800047f0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800047c8:	66 0c       	ld.w	r12,r3[0x0]
800047ca:	40 0b       	lddsp	r11,sp[0x0]
800047cc:	f0 1f 00 0e 	mcall	80004804 <xcmp_rx_process+0xf8>
800047d0:	ca 7b       	rjmp	8000471e <xcmp_rx_process+0x12>
800047d2:	00 00       	add	r0,r0
800047d4:	00 00       	add	r0,r0
800047d6:	0a f4       	st.b	--r5,r4
800047d8:	00 00       	add	r0,r0
800047da:	0a 9c       	mov	r12,r5
800047dc:	00 00       	add	r0,r0
800047de:	0b 04       	ld.w	r4,r5++
800047e0:	00 00       	add	r0,r0
800047e2:	0a f8       	st.b	--r5,r8
800047e4:	00 00       	add	r0,r0
800047e6:	0b 10       	ld.sh	r0,r5++
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	5f d0       	srvc	r0
800047ec:	00 00       	add	r0,r0
800047ee:	0b 28       	ld.uh	r8,r5++
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	46 10       	lddsp	r0,sp[0x184]
800047f4:	00 00       	add	r0,r0
800047f6:	0a e8       	st.h	--r5,r8
800047f8:	00 00       	add	r0,r0
800047fa:	0b 1c       	ld.sh	r12,r5++
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	45 ec       	lddsp	r12,sp[0x178]
80004800:	00 00       	add	r0,r0
80004802:	50 fc       	stdsp	sp[0x3c],r12
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	30 00       	mov	r0,0

80004808 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004808:	eb cd 40 90 	pushm	r4,r7,lr
8000480c:	20 1d       	sub	sp,4
8000480e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004812:	48 c8       	lddpc	r8,80004840 <xcmp_rx+0x38>
80004814:	70 0c       	ld.w	r12,r8[0x0]
80004816:	f0 1f 00 0c 	mcall	80004844 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000481a:	c1 00       	breq	8000483a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000481c:	fa c7 ff fc 	sub	r7,sp,-4
80004820:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004822:	e0 6a 00 ca 	mov	r10,202
80004826:	08 9b       	mov	r11,r4
80004828:	f0 1f 00 08 	mcall	80004848 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000482c:	48 88       	lddpc	r8,8000484c <xcmp_rx+0x44>
8000482e:	70 0c       	ld.w	r12,r8[0x0]
80004830:	30 09       	mov	r9,0
80004832:	12 9a       	mov	r10,r9
80004834:	1a 9b       	mov	r11,sp
80004836:	f0 1f 00 07 	mcall	80004850 <xcmp_rx+0x48>
	}	
}
8000483a:	2f fd       	sub	sp,-4
8000483c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004840:	00 00       	add	r0,r0
80004842:	0a 9c       	mov	r12,r5
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	35 6c       	mov	r12,86
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	77 2e       	ld.w	lr,r11[0x48]
8000484c:	00 00       	add	r0,r0
8000484e:	0a f4       	st.b	--r5,r4
80004850:	80 00       	ld.sh	r0,r0[0x0]
80004852:	61 dc       	ld.w	r12,r0[0x74]

80004854 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004854:	48 28       	lddpc	r8,8000485c <xnl_register_xcmp_func+0x8>
80004856:	91 0c       	st.w	r8[0x0],r12
}
80004858:	5e fc       	retal	r12
8000485a:	00 00       	add	r0,r0
8000485c:	00 00       	add	r0,r0
8000485e:	0b 54       	ld.sh	r4,--r5

80004860 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004860:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004862:	48 88       	lddpc	r8,80004880 <xnl_get_msg_ack_func+0x20>
80004864:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004866:	98 49       	ld.sh	r9,r12[0x8]
80004868:	f0 09 19 00 	cp.h	r9,r8
8000486c:	c0 81       	brne	8000487c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000486e:	48 68       	lddpc	r8,80004884 <xnl_get_msg_ack_func+0x24>
80004870:	70 0c       	ld.w	r12,r8[0x0]
80004872:	30 09       	mov	r9,0
80004874:	12 9a       	mov	r10,r9
80004876:	12 9b       	mov	r11,r9
80004878:	f0 1f 00 04 	mcall	80004888 <xnl_get_msg_ack_func+0x28>
8000487c:	d8 02       	popm	pc
8000487e:	00 00       	add	r0,r0
80004880:	00 00       	add	r0,r0
80004882:	0b 3a       	ld.ub	r10,r5++
80004884:	00 00       	add	r0,r0
80004886:	0b 34       	ld.ub	r4,r5++
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	61 dc       	ld.w	r12,r0[0x74]

8000488c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000488c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000488e:	4a 86       	lddpc	r6,8000492c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004890:	4a 82       	lddpc	r2,80004930 <xnl_tx_process+0xa4>
80004892:	4a 94       	lddpc	r4,80004934 <xnl_tx_process+0xa8>
80004894:	30 07       	mov	r7,0
80004896:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004898:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000489a:	4a 85       	lddpc	r5,80004938 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000489c:	4a 83       	lddpc	r3,8000493c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000489e:	6c 08       	ld.w	r8,r6[0x0]
800048a0:	58 08       	cp.w	r8,0
800048a2:	c0 40       	breq	800048aa <xnl_tx_process+0x1e>
800048a4:	58 18       	cp.w	r8,1
800048a6:	cf d1       	brne	800048a0 <xnl_tx_process+0x14>
800048a8:	c2 08       	rjmp	800048e8 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800048aa:	64 0c       	ld.w	r12,r2[0x0]
800048ac:	0e 99       	mov	r9,r7
800048ae:	02 9a       	mov	r10,r1
800048b0:	08 9b       	mov	r11,r4
800048b2:	f0 1f 00 24 	mcall	80004940 <xnl_tx_process+0xb4>
800048b6:	58 1c       	cp.w	r12,1
800048b8:	cf 31       	brne	8000489e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800048ba:	68 0c       	ld.w	r12,r4[0x0]
800048bc:	58 0c       	cp.w	r12,0
800048be:	cf 00       	breq	8000489e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800048c0:	98 28       	ld.sh	r8,r12[0x4]
800048c2:	e0 08 19 00 	cp.h	r8,r0
800048c6:	c0 41       	brne	800048ce <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800048c8:	f0 1f 00 1f 	mcall	80004944 <xnl_tx_process+0xb8>
						break;
800048cc:	ce 9b       	rjmp	8000489e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800048ce:	f0 1f 00 1f 	mcall	80004948 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800048d2:	30 18       	mov	r8,1
800048d4:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800048d6:	66 0c       	ld.w	r12,r3[0x0]
800048d8:	0e 99       	mov	r9,r7
800048da:	0e 9a       	mov	r10,r7
800048dc:	0e 9b       	mov	r11,r7
800048de:	f0 1f 00 19 	mcall	80004940 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800048e2:	30 18       	mov	r8,1
800048e4:	8d 08       	st.w	r6[0x0],r8
800048e6:	cd cb       	rjmp	8000489e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800048e8:	66 0c       	ld.w	r12,r3[0x0]
800048ea:	0e 99       	mov	r9,r7
800048ec:	36 4a       	mov	r10,100
800048ee:	0e 9b       	mov	r11,r7
800048f0:	f0 1f 00 14 	mcall	80004940 <xnl_tx_process+0xb4>
800048f4:	58 1c       	cp.w	r12,1
800048f6:	c0 81       	brne	80004906 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800048f8:	49 58       	lddpc	r8,8000494c <xnl_tx_process+0xc0>
800048fa:	70 0c       	ld.w	r12,r8[0x0]
800048fc:	68 0b       	ld.w	r11,r4[0x0]
800048fe:	f0 1f 00 15 	mcall	80004950 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004902:	8d 07       	st.w	r6[0x0],r7
80004904:	cc db       	rjmp	8000489e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004906:	6a 08       	ld.w	r8,r5[0x0]
80004908:	58 38       	cp.w	r8,3
8000490a:	e0 89 00 09 	brgt	8000491c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000490e:	68 0c       	ld.w	r12,r4[0x0]
80004910:	f0 1f 00 0e 	mcall	80004948 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004914:	6a 08       	ld.w	r8,r5[0x0]
80004916:	2f f8       	sub	r8,-1
80004918:	8b 08       	st.w	r5[0x0],r8
8000491a:	cc 2b       	rjmp	8000489e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000491c:	48 c8       	lddpc	r8,8000494c <xnl_tx_process+0xc0>
8000491e:	70 0c       	ld.w	r12,r8[0x0]
80004920:	68 0b       	ld.w	r11,r4[0x0]
80004922:	f0 1f 00 0c 	mcall	80004950 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004926:	8d 07       	st.w	r6[0x0],r7
80004928:	cb bb       	rjmp	8000489e <xnl_tx_process+0x12>
8000492a:	00 00       	add	r0,r0
8000492c:	00 00       	add	r0,r0
8000492e:	0b 50       	ld.sh	r0,--r5
80004930:	00 00       	add	r0,r0
80004932:	0b 44       	ld.w	r4,--r5
80004934:	00 00       	add	r0,r0
80004936:	0b 48       	ld.w	r8,--r5
80004938:	00 00       	add	r0,r0
8000493a:	0b 4c       	ld.w	r12,--r5
8000493c:	00 00       	add	r0,r0
8000493e:	0b 34       	ld.ub	r4,r5++
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	5f d0       	srvc	r0
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	5e 60       	retmi	r0
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	30 20       	mov	r0,2
8000494c:	00 00       	add	r0,r0
8000494e:	0a 9c       	mov	r12,r5
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	30 00       	mov	r0,0

80004954 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004954:	eb cd 40 fe 	pushm	r1-r7,lr
80004958:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000495a:	49 26       	lddpc	r6,800049a0 <xnl_rx_process+0x4c>
8000495c:	30 05       	mov	r5,0
8000495e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004960:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004962:	49 11       	lddpc	r1,800049a4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004964:	49 12       	lddpc	r2,800049a8 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004966:	6c 0c       	ld.w	r12,r6[0x0]
80004968:	0a 99       	mov	r9,r5
8000496a:	08 9a       	mov	r10,r4
8000496c:	1a 9b       	mov	r11,sp
8000496e:	f0 1f 00 10 	mcall	800049ac <xnl_rx_process+0x58>
80004972:	58 1c       	cp.w	r12,1
80004974:	cf 91       	brne	80004966 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004976:	40 0c       	lddsp	r12,sp[0x0]
80004978:	58 0c       	cp.w	r12,0
8000497a:	cf 60       	breq	80004966 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000497c:	98 28       	ld.sh	r8,r12[0x4]
8000497e:	e6 08 19 00 	cp.h	r8,r3
80004982:	e0 8b 00 0a 	brhi	80004996 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004986:	5c 78       	castu.h	r8
80004988:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000498c:	58 09       	cp.w	r9,0
8000498e:	c0 40       	breq	80004996 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004990:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004994:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004996:	62 0c       	ld.w	r12,r1[0x0]
80004998:	40 0b       	lddsp	r11,sp[0x0]
8000499a:	f0 1f 00 06 	mcall	800049b0 <xnl_rx_process+0x5c>
8000499e:	ce 4b       	rjmp	80004966 <xnl_rx_process+0x12>
800049a0:	00 00       	add	r0,r0
800049a2:	0a c4       	st.b	r5++,r4
800049a4:	00 00       	add	r0,r0
800049a6:	0a 9c       	mov	r12,r5
800049a8:	00 00       	add	r0,r0
800049aa:	04 f4       	st.b	--r2,r4
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	5f d0       	srvc	r0
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	30 00       	mov	r0,0

800049b4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800049b4:	eb cd 40 c0 	pushm	r6-r7,lr
800049b8:	20 1d       	sub	sp,4
800049ba:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800049bc:	98 39       	ld.sh	r9,r12[0x6]
800049be:	3f f8       	mov	r8,-1
800049c0:	f0 09 19 00 	cp.h	r9,r8
800049c4:	c0 a1       	brne	800049d8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800049c6:	4a e9       	lddpc	r9,80004a7c <xnl_tx+0xc8>
800049c8:	13 88       	ld.ub	r8,r9[0x0]
800049ca:	2f f8       	sub	r8,-1
800049cc:	5c 58       	castu.b	r8
800049ce:	b2 88       	st.b	r9[0x0],r8
800049d0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800049d4:	a9 a8       	sbr	r8,0x8
800049d6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800049d8:	8c 49       	ld.sh	r9,r6[0x8]
800049da:	3f f8       	mov	r8,-1
800049dc:	f0 09 19 00 	cp.h	r9,r8
800049e0:	c0 41       	brne	800049e8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800049e2:	4a 88       	lddpc	r8,80004a80 <xnl_tx+0xcc>
800049e4:	90 18       	ld.sh	r8,r8[0x2]
800049e6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800049e8:	8c 59       	ld.sh	r9,r6[0xa]
800049ea:	3f f8       	mov	r8,-1
800049ec:	f0 09 19 00 	cp.h	r9,r8
800049f0:	c0 41       	brne	800049f8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800049f2:	4a 48       	lddpc	r8,80004a80 <xnl_tx+0xcc>
800049f4:	90 28       	ld.sh	r8,r8[0x4]
800049f6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800049f8:	8c 69       	ld.sh	r9,r6[0xc]
800049fa:	3f f8       	mov	r8,-1
800049fc:	f0 09 19 00 	cp.h	r9,r8
80004a00:	c0 e1       	brne	80004a1c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004a02:	4a 08       	lddpc	r8,80004a80 <xnl_tx+0xcc>
80004a04:	90 49       	ld.sh	r9,r8[0x8]
80004a06:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004a08:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004a0a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004a0c:	90 49       	ld.sh	r9,r8[0x8]
80004a0e:	e0 19 ff 00 	andl	r9,0xff00
80004a12:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004a16:	f3 e8 10 08 	or	r8,r9,r8
80004a1a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004a1c:	0d 98       	ld.ub	r8,r6[0x1]
80004a1e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004a20:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004a24:	10 0c       	add	r12,r8
80004a26:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a28:	58 0c       	cp.w	r12,0
80004a2a:	e0 89 00 04 	brgt	80004a32 <xnl_tx+0x7e>
80004a2e:	30 09       	mov	r9,0
80004a30:	c0 d8       	rjmp	80004a4a <xnl_tx+0x96>
80004a32:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004a36:	2f ec       	sub	r12,-2
80004a38:	30 09       	mov	r9,0
80004a3a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004a3c:	15 1b       	ld.sh	r11,r10++
80004a3e:	f6 09 00 09 	add	r9,r11,r9
80004a42:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004a44:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a46:	18 38       	cp.w	r8,r12
80004a48:	cf a1       	brne	80004a3c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004a4a:	5c 39       	neg	r9
80004a4c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a4e:	48 e8       	lddpc	r8,80004a84 <xnl_tx+0xd0>
80004a50:	70 0c       	ld.w	r12,r8[0x0]
80004a52:	f0 1f 00 0e 	mcall	80004a88 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004a56:	c1 00       	breq	80004a76 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a58:	fa c7 ff fc 	sub	r7,sp,-4
80004a5c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004a5e:	e0 6a 01 00 	mov	r10,256
80004a62:	0c 9b       	mov	r11,r6
80004a64:	f0 1f 00 0a 	mcall	80004a8c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004a68:	48 a8       	lddpc	r8,80004a90 <xnl_tx+0xdc>
80004a6a:	70 0c       	ld.w	r12,r8[0x0]
80004a6c:	30 09       	mov	r9,0
80004a6e:	12 9a       	mov	r10,r9
80004a70:	1a 9b       	mov	r11,sp
80004a72:	f0 1f 00 09 	mcall	80004a94 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004a76:	2f fd       	sub	sp,-4
80004a78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a7c:	00 00       	add	r0,r0
80004a7e:	0b 38       	ld.ub	r8,r5++
80004a80:	00 00       	add	r0,r0
80004a82:	0b 3a       	ld.ub	r10,r5++
80004a84:	00 00       	add	r0,r0
80004a86:	0a 9c       	mov	r12,r5
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	35 6c       	mov	r12,86
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	77 2e       	ld.w	lr,r11[0x48]
80004a90:	00 00       	add	r0,r0
80004a92:	0b 44       	ld.w	r4,--r5
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	61 dc       	ld.w	r12,r0[0x74]

80004a98 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004a98:	eb cd 40 80 	pushm	r7,lr
80004a9c:	fa cd 01 00 	sub	sp,sp,256
	
	xnl_information.is_connected = FALSE;
80004aa0:	30 09       	mov	r9,0
80004aa2:	4a 78       	lddpc	r8,80004b3c <xnl_init+0xa4>
80004aa4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004aa6:	30 0b       	mov	r11,0
80004aa8:	30 1c       	mov	r12,1
80004aaa:	f0 1f 00 26 	mcall	80004b40 <xnl_init+0xa8>
80004aae:	4a 68       	lddpc	r8,80004b44 <xnl_init+0xac>
80004ab0:	91 0c       	st.w	r8[0x0],r12
80004ab2:	70 08       	ld.w	r8,r8[0x0]
80004ab4:	58 08       	cp.w	r8,0
80004ab6:	c0 80       	breq	80004ac6 <xnl_init+0x2e>
80004ab8:	4a 38       	lddpc	r8,80004b44 <xnl_init+0xac>
80004aba:	70 0c       	ld.w	r12,r8[0x0]
80004abc:	30 09       	mov	r9,0
80004abe:	12 9a       	mov	r10,r9
80004ac0:	12 9b       	mov	r11,r9
80004ac2:	f0 1f 00 22 	mcall	80004b48 <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004ac6:	30 4b       	mov	r11,4
80004ac8:	31 4c       	mov	r12,20
80004aca:	f0 1f 00 1e 	mcall	80004b40 <xnl_init+0xa8>
80004ace:	4a 08       	lddpc	r8,80004b4c <xnl_init+0xb4>
80004ad0:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004ad2:	30 07       	mov	r7,0
80004ad4:	1a d7       	st.w	--sp,r7
80004ad6:	1a d7       	st.w	--sp,r7
80004ad8:	1a d7       	st.w	--sp,r7
80004ada:	30 38       	mov	r8,3
80004adc:	0e 99       	mov	r9,r7
80004ade:	e0 6a 02 00 	mov	r10,512
80004ae2:	49 cb       	lddpc	r11,80004b50 <xnl_init+0xb8>
80004ae4:	49 cc       	lddpc	r12,80004b54 <xnl_init+0xbc>
80004ae6:	f0 1f 00 1d 	mcall	80004b58 <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004aea:	1a d7       	st.w	--sp,r7
80004aec:	1a d7       	st.w	--sp,r7
80004aee:	1a d7       	st.w	--sp,r7
80004af0:	30 38       	mov	r8,3
80004af2:	0e 99       	mov	r9,r7
80004af4:	e0 6a 03 20 	mov	r10,800
80004af8:	49 9b       	lddpc	r11,80004b5c <xnl_init+0xc4>
80004afa:	49 ac       	lddpc	r12,80004b60 <xnl_init+0xc8>
80004afc:	f0 1f 00 17 	mcall	80004b58 <xnl_init+0xc0>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b00:	e0 68 40 0e 	mov	r8,16398
80004b04:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b08:	3f f8       	mov	r8,-1
80004b0a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004b0e:	30 38       	mov	r8,3
80004b10:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004b14:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004b18:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004b1c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004b20:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004b24:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b28:	fa cc ff e8 	sub	r12,sp,-24
80004b2c:	f0 1f 00 0e 	mcall	80004b64 <xnl_init+0xcc>
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
	
	/*initialize the physical layer*/
	phy_init();
80004b30:	f0 1f 00 0e 	mcall	80004b68 <xnl_init+0xd0>
80004b34:	2f ad       	sub	sp,-24
}
80004b36:	2c 0d       	sub	sp,-256
80004b38:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b3c:	00 00       	add	r0,r0
80004b3e:	0b 3a       	ld.ub	r10,r5++
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	62 dc       	ld.w	r12,r1[0x34]
80004b44:	00 00       	add	r0,r0
80004b46:	0b 34       	ld.ub	r4,r5++
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	61 dc       	ld.w	r12,r0[0x74]
80004b4c:	00 00       	add	r0,r0
80004b4e:	0b 44       	ld.w	r4,--r5
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	db d0       	acall	0xbd
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	49 54       	lddpc	r4,80004ba8 <xnl_data_msg_func+0x3c>
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	69 b0       	ld.w	r0,r4[0x6c]
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	ce 00       	breq	80004b1e <xnl_init+0x86>
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	48 8c       	lddpc	r12,80004b80 <xnl_data_msg_func+0x14>
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	49 b4       	lddpc	r4,80004bd0 <xnl_device_auth_reply_func+0x4>
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	35 94       	mov	r4,89

80004b6c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004b6c:	eb cd 40 80 	pushm	r7,lr
80004b70:	fa cd 01 00 	sub	sp,sp,256
80004b74:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b76:	e0 68 40 0e 	mov	r8,16398
80004b7a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b7c:	3f f8       	mov	r8,-1
80004b7e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004b80:	30 c8       	mov	r8,12
80004b82:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004b84:	98 38       	ld.sh	r8,r12[0x6]
80004b86:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004b88:	98 58       	ld.sh	r8,r12[0xa]
80004b8a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004b8c:	98 48       	ld.sh	r8,r12[0x8]
80004b8e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004b90:	98 68       	ld.sh	r8,r12[0xc]
80004b92:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004b94:	30 08       	mov	r8,0
80004b96:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b98:	1a 9c       	mov	r12,sp
80004b9a:	f0 1f 00 0a 	mcall	80004bc0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004b9e:	fa cd 00 cc 	sub	sp,sp,204
80004ba2:	e0 6a 00 ca 	mov	r10,202
80004ba6:	ee cb ff f0 	sub	r11,r7,-16
80004baa:	1a 9c       	mov	r12,sp
80004bac:	f0 1f 00 06 	mcall	80004bc4 <xnl_data_msg_func+0x58>
80004bb0:	48 68       	lddpc	r8,80004bc8 <xnl_data_msg_func+0x5c>
80004bb2:	70 08       	ld.w	r8,r8[0x0]
80004bb4:	5d 18       	icall	r8
80004bb6:	fa cd ff 34 	sub	sp,sp,-204
}
80004bba:	2c 0d       	sub	sp,-256
80004bbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	49 b4       	lddpc	r4,80004c2c <xnl_device_auth_reply_func+0x60>
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	77 2e       	ld.w	lr,r11[0x48]
80004bc8:	00 00       	add	r0,r0
80004bca:	0b 54       	ld.sh	r4,--r5

80004bcc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004bcc:	d4 21       	pushm	r4-r7,lr
80004bce:	fa cd 01 00 	sub	sp,sp,256
80004bd2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004bd4:	4c 28       	lddpc	r8,80004cdc <xnl_device_auth_reply_func+0x110>
80004bd6:	11 88       	ld.ub	r8,r8[0x0]
80004bd8:	58 08       	cp.w	r8,0
80004bda:	e0 81 00 7f 	brne	80004cd8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004bde:	4c 18       	lddpc	r8,80004ce0 <xnl_device_auth_reply_func+0x114>
80004be0:	70 0c       	ld.w	r12,r8[0x0]
80004be2:	30 09       	mov	r9,0
80004be4:	12 9a       	mov	r10,r9
80004be6:	12 9b       	mov	r11,r9
80004be8:	f0 1f 00 3f 	mcall	80004ce4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004bec:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004bf0:	4b b8       	lddpc	r8,80004cdc <xnl_device_auth_reply_func+0x110>
80004bf2:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004bf4:	ef 39 00 12 	ld.ub	r9,r7[18]
80004bf8:	ef 38 00 13 	ld.ub	r8,r7[19]
80004bfc:	b1 68       	lsl	r8,0x10
80004bfe:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004c02:	ef 38 00 15 	ld.ub	r8,r7[21]
80004c06:	f3 e8 10 08 	or	r8,r9,r8
80004c0a:	ef 39 00 14 	ld.ub	r9,r7[20]
80004c0e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004c12:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004c16:	ef 38 00 17 	ld.ub	r8,r7[23]
80004c1a:	b1 68       	lsl	r8,0x10
80004c1c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004c20:	ef 38 00 19 	ld.ub	r8,r7[25]
80004c24:	f5 e8 10 08 	or	r8,r10,r8
80004c28:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004c2c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004c30:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c32:	e0 64 79 b9 	mov	r4,31161
80004c36:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c3a:	e0 65 45 07 	mov	r5,17671
80004c3e:	ea 15 8a bd 	orh	r5,0x8abd
80004c42:	e0 66 f9 3d 	mov	r6,63805
80004c46:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c4a:	e0 6e b8 cf 	mov	lr,47311
80004c4e:	ea 1e 36 83 	orh	lr,0x3683
80004c52:	e0 67 aa 1c 	mov	r7,43548
80004c56:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c5a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c5c:	f4 08 00 0c 	add	r12,r10,r8
80004c60:	f0 0b 15 04 	lsl	r11,r8,0x4
80004c64:	0a 0b       	add	r11,r5
80004c66:	f9 eb 20 0b 	eor	r11,r12,r11
80004c6a:	f0 0c 16 05 	lsr	r12,r8,0x5
80004c6e:	0c 0c       	add	r12,r6
80004c70:	18 5b       	eor	r11,r12
80004c72:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c74:	f2 0c 15 04 	lsl	r12,r9,0x4
80004c78:	1c 0c       	add	r12,lr
80004c7a:	f2 0b 16 05 	lsr	r11,r9,0x5
80004c7e:	0e 0b       	add	r11,r7
80004c80:	f9 eb 20 0b 	eor	r11,r12,r11
80004c84:	f2 0a 00 0c 	add	r12,r9,r10
80004c88:	18 5b       	eor	r11,r12
80004c8a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004c8c:	e0 6b 37 20 	mov	r11,14112
80004c90:	ea 1b c6 ef 	orh	r11,0xc6ef
80004c94:	16 3a       	cp.w	r10,r11
80004c96:	ce 21       	brne	80004c5a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004c98:	e0 6a 40 1a 	mov	r10,16410
80004c9c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004c9e:	3f fa       	mov	r10,-1
80004ca0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004ca2:	30 6b       	mov	r11,6
80004ca4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004ca6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ca8:	48 db       	lddpc	r11,80004cdc <xnl_device_auth_reply_func+0x110>
80004caa:	96 1c       	ld.sh	r12,r11[0x2]
80004cac:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004cae:	96 2b       	ld.sh	r11,r11[0x4]
80004cb0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004cb2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004cb4:	30 ca       	mov	r10,12
80004cb6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004cb8:	30 0a       	mov	r10,0
80004cba:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004cbe:	30 7a       	mov	r10,7
80004cc0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004cc4:	30 2a       	mov	r10,2
80004cc6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cca:	fa ca ff ec 	sub	r10,sp,-20
80004cce:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cd0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004cd2:	1a 9c       	mov	r12,sp
80004cd4:	f0 1f 00 05 	mcall	80004ce8 <xnl_device_auth_reply_func+0x11c>
}
80004cd8:	2c 0d       	sub	sp,-256
80004cda:	d8 22       	popm	r4-r7,pc
80004cdc:	00 00       	add	r0,r0
80004cde:	0b 3a       	ld.ub	r10,r5++
80004ce0:	00 00       	add	r0,r0
80004ce2:	0b 34       	ld.ub	r4,r5++
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	61 dc       	ld.w	r12,r0[0x74]
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	49 b4       	lddpc	r4,80004d54 <xnl_device_conn_reply_func+0x8>

80004cec <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004cec:	eb cd 40 80 	pushm	r7,lr
80004cf0:	fa cd 01 00 	sub	sp,sp,256
80004cf4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004cf6:	49 28       	lddpc	r8,80004d3c <xnl_master_status_brdcst_func+0x50>
80004cf8:	11 88       	ld.ub	r8,r8[0x0]
80004cfa:	58 08       	cp.w	r8,0
80004cfc:	c1 c1       	brne	80004d34 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004cfe:	49 18       	lddpc	r8,80004d40 <xnl_master_status_brdcst_func+0x54>
80004d00:	70 0c       	ld.w	r12,r8[0x0]
80004d02:	30 09       	mov	r9,0
80004d04:	12 9a       	mov	r10,r9
80004d06:	12 9b       	mov	r11,r9
80004d08:	f0 1f 00 0f 	mcall	80004d44 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004d0c:	8e 58       	ld.sh	r8,r7[0xa]
80004d0e:	48 c9       	lddpc	r9,80004d3c <xnl_master_status_brdcst_func+0x50>
80004d10:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004d12:	e0 68 40 0e 	mov	r8,16398
80004d16:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004d18:	3f f8       	mov	r8,-1
80004d1a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004d1c:	30 4a       	mov	r10,4
80004d1e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004d20:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004d22:	92 19       	ld.sh	r9,r9[0x2]
80004d24:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004d26:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d28:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004d2a:	30 08       	mov	r8,0
80004d2c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004d2e:	1a 9c       	mov	r12,sp
80004d30:	f0 1f 00 06 	mcall	80004d48 <xnl_master_status_brdcst_func+0x5c>
}
80004d34:	2c 0d       	sub	sp,-256
80004d36:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d3a:	00 00       	add	r0,r0
80004d3c:	00 00       	add	r0,r0
80004d3e:	0b 3a       	ld.ub	r10,r5++
80004d40:	00 00       	add	r0,r0
80004d42:	0b 34       	ld.ub	r4,r5++
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	61 dc       	ld.w	r12,r0[0x74]
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	49 b4       	lddpc	r4,80004db4 <local_start_pll0+0xc>

80004d4c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004d4c:	eb cd 40 80 	pushm	r7,lr
80004d50:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004d52:	49 28       	lddpc	r8,80004d98 <xnl_device_conn_reply_func+0x4c>
80004d54:	70 0c       	ld.w	r12,r8[0x0]
80004d56:	30 09       	mov	r9,0
80004d58:	12 9a       	mov	r10,r9
80004d5a:	12 9b       	mov	r11,r9
80004d5c:	f0 1f 00 10 	mcall	80004d9c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004d60:	ef 18 00 10 	ld.uh	r8,r7[16]
80004d64:	10 99       	mov	r9,r8
80004d66:	e2 19 ff 00 	andl	r9,0xff00,COH
80004d6a:	e0 49 01 00 	cp.w	r9,256
80004d6e:	c0 60       	breq	80004d7a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004d70:	0e 9c       	mov	r12,r7
80004d72:	f0 1f 00 0c 	mcall	80004da0 <xnl_device_conn_reply_func+0x54>
80004d76:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004d7a:	a9 68       	lsl	r8,0x8
80004d7c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d80:	48 98       	lddpc	r8,80004da4 <xnl_device_conn_reply_func+0x58>
80004d82:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004d84:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004d88:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004d8a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004d8e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004d90:	30 19       	mov	r9,1
80004d92:	b0 89       	st.b	r8[0x0],r9
80004d94:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d98:	00 00       	add	r0,r0
80004d9a:	0b 34       	ld.ub	r4,r5++
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	61 dc       	ld.w	r12,r0[0x74]
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	4c ec       	lddpc	r12,80004ed8 <playback_voice_data+0x24>
80004da4:	00 00       	add	r0,r0
80004da6:	0b 3a       	ld.ub	r10,r5++

80004da8 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004da8:	fe 78 0c 00 	mov	r8,-62464
80004dac:	e0 69 03 07 	mov	r9,775
80004db0:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004db2:	30 49       	mov	r9,4
80004db4:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004db6:	71 59       	ld.w	r9,r8[0x54]
80004db8:	e2 19 00 80 	andl	r9,0x80,COH
80004dbc:	cf d0       	breq	80004db6 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004dbe:	fe 78 0c 00 	mov	r8,-62464
80004dc2:	30 59       	mov	r9,5
80004dc4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004dc6:	e0 69 01 0d 	mov	r9,269
80004dca:	ea 19 10 07 	orh	r9,0x1007
80004dce:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004dd0:	71 59       	ld.w	r9,r8[0x54]
80004dd2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004dd6:	cf d0       	breq	80004dd0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004dd8:	fe 78 0c 00 	mov	r8,-62464
80004ddc:	fc 19 00 80 	movh	r9,0x80
80004de0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004de2:	34 0a       	mov	r10,64
80004de4:	fe 69 14 00 	mov	r9,-125952
80004de8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004dea:	30 69       	mov	r9,6
80004dec:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004dee:	30 19       	mov	r9,1
80004df0:	fe 68 10 00 	mov	r8,-126976
80004df4:	91 19       	st.w	r8[0x4],r9
}
80004df6:	5e fc       	retal	r12

80004df8 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004df8:	fe 78 10 00 	mov	r8,-61440
80004dfc:	fc 19 00 10 	movh	r9,0x10
80004e00:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004e02:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004e04:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004e06:	30 39       	mov	r9,3
80004e08:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004e0c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004e10:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004e14:	fe 78 38 00 	mov	r8,-51200
80004e18:	30 49       	mov	r9,4
80004e1a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004e1e:	e0 69 91 0d 	mov	r9,37133
80004e22:	ea 19 00 52 	orh	r9,0x52
80004e26:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004e28:	32 09       	mov	r9,32
80004e2a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004e2c:	30 59       	mov	r9,5
80004e2e:	91 09       	st.w	r8[0x0],r9
}
80004e30:	5e fc       	retal	r12
80004e32:	d7 03       	nop

80004e34 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004e34:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004e36:	30 2a       	mov	r10,2
80004e38:	e0 6b 01 c1 	mov	r11,449
80004e3c:	48 ec       	lddpc	r12,80004e74 <tc_init+0x40>
80004e3e:	f0 1f 00 0f 	mcall	80004e78 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004e42:	48 fb       	lddpc	r11,80004e7c <tc_init+0x48>
80004e44:	fe 7c 38 00 	mov	r12,-51200
80004e48:	f0 1f 00 0e 	mcall	80004e80 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004e4c:	e0 6a 75 30 	mov	r10,30000
80004e50:	30 1b       	mov	r11,1
80004e52:	fe 7c 38 00 	mov	r12,-51200
80004e56:	f0 1f 00 0c 	mcall	80004e84 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004e5a:	48 ca       	lddpc	r10,80004e88 <tc_init+0x54>
80004e5c:	30 1b       	mov	r11,1
80004e5e:	fe 7c 38 00 	mov	r12,-51200
80004e62:	f0 1f 00 0b 	mcall	80004e8c <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004e66:	30 1b       	mov	r11,1
80004e68:	fe 7c 38 00 	mov	r12,-51200
80004e6c:	f0 1f 00 09 	mcall	80004e90 <tc_init+0x5c>
80004e70:	d8 02       	popm	pc
80004e72:	00 00       	add	r0,r0
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	4e 94       	lddpc	r4,80005018 <voc_save_info+0x68>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	54 10       	stdsp	sp[0x104],r0
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	db dc       	*unknown*
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	56 f6       	stdsp	sp[0x1bc],r6
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	57 b6       	stdsp	sp[0x1ec],r6
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	db d8       	*unknown*
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	57 ea       	stdsp	sp[0x1f8],r10
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	57 92       	stdsp	sp[0x1e4],r2

80004e94 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004e94:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004e96:	48 68       	lddpc	r8,80004eac <_tc_interrupt+0x18>
80004e98:	70 09       	ld.w	r9,r8[0x0]
80004e9a:	2f f9       	sub	r9,-1
80004e9c:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004e9e:	30 1b       	mov	r11,1
80004ea0:	fe 7c 38 00 	mov	r12,-51200
80004ea4:	f0 1f 00 03 	mcall	80004eb0 <_tc_interrupt+0x1c>
	
}
80004ea8:	d4 02       	popm	lr
80004eaa:	d6 03       	rete
80004eac:	00 00       	add	r0,r0
80004eae:	0b 58       	ld.sh	r8,--r5
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	57 a4       	stdsp	sp[0x1e8],r4

80004eb4 <playback_voice_data>:
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
U8 PLAYBACK_BUF[512];
Bool playback_voice_data(U32 voice_index)
{
80004eb4:	d4 31       	pushm	r0-r7,lr
80004eb6:	21 2d       	sub	sp,72
80004eb8:	18 97       	mov	r7,r12
	if(!list_init_success_flag)return FALSE;
80004eba:	4b 98       	lddpc	r8,80004f9c <playback_voice_data+0xe8>
80004ebc:	11 89       	ld.ub	r9,r8[0x0]
80004ebe:	30 08       	mov	r8,0
80004ec0:	f0 09 18 00 	cp.b	r9,r8
80004ec4:	c6 40       	breq	80004f8c <playback_voice_data+0xd8>
	
	/* check input parameter */
	if (voice_index > current_voice_index)
80004ec6:	4b 78       	lddpc	r8,80004fa0 <playback_voice_data+0xec>
80004ec8:	90 88       	ld.uh	r8,r8[0x0]
80004eca:	18 38       	cp.w	r8,r12
80004ecc:	c6 23       	brcs	80004f90 <playback_voice_data+0xdc>
		return -1;
	}
	df_status_t return_code = DF_OK;
	unsigned int address =0x00000000;
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
80004ece:	1a 9a       	mov	r10,sp
80004ed0:	30 08       	mov	r8,0
80004ed2:	30 09       	mov	r9,0
80004ed4:	fa e9 00 00 	st.d	sp[0],r8
80004ed8:	fa e9 00 08 	st.d	sp[8],r8
80004edc:	fa e9 00 10 	st.d	sp[16],r8
80004ee0:	fa e9 00 18 	st.d	sp[24],r8
80004ee4:	fa e9 00 20 	st.d	sp[32],r8
80004ee8:	fa e9 00 28 	st.d	sp[40],r8
80004eec:	fa e9 00 30 	st.d	sp[48],r8
80004ef0:	fa e9 00 38 	st.d	sp[56],r8
80004ef4:	fa e9 00 40 	st.d	sp[64],r8
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80004ef8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80004efc:	a3 7c       	lsl	r12,0x3
80004efe:	34 8b       	mov	r11,72
80004f00:	23 8c       	sub	r12,56
80004f02:	f0 1f 00 29 	mcall	80004fa4 <playback_voice_data+0xf0>
	if (return_code == DF_OK)
80004f06:	c4 51       	brne	80004f90 <playback_voice_data+0xdc>
	{
		U16 bytes_remained;
		VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
		if(ptr->numb == voice_index)
80004f08:	9a 88       	ld.uh	r8,sp[0x0]
80004f0a:	0e 38       	cp.w	r8,r7
80004f0c:	c4 21       	brne	80004f90 <playback_voice_data+0xdc>
		{
			bytes_remained = ptr->offset;
80004f0e:	41 18       	lddsp	r8,sp[0x44]
80004f10:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			address = ptr->address;
80004f14:	fb 16 00 42 	ld.uh	r6,sp[66]
80004f18:	b1 88       	lsr	r8,0x10
80004f1a:	f1 e6 11 06 	or	r6,r8,r6<<0x10
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004f1e:	58 07       	cp.w	r7,0
80004f20:	c3 b0       	breq	80004f96 <playback_voice_data+0xe2>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80004f22:	e0 65 01 ff 	mov	r5,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
80004f26:	4a 13       	lddpc	r3,80004fa8 <playback_voice_data+0xf4>
80004f28:	e0 62 02 00 	mov	r2,512
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004f2c:	30 04       	mov	r4,0
80004f2e:	08 91       	mov	r1,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80004f30:	ea 07 19 00 	cp.h	r7,r5
80004f34:	e0 8b 00 11 	brhi	80004f56 <playback_voice_data+0xa2>
				{
					return_code = data_flash_read_block(address, bytes_remained, PLAYBACK_BUF);
80004f38:	49 c5       	lddpc	r5,80004fa8 <playback_voice_data+0xf4>
80004f3a:	0a 9a       	mov	r10,r5
80004f3c:	0e 9b       	mov	r11,r7
80004f3e:	5c 7b       	castu.h	r11
80004f40:	0c 9c       	mov	r12,r6
80004f42:	f0 1f 00 19 	mcall	80004fa4 <playback_voice_data+0xf0>
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
					bytes_remained-=DF_DATA_SPACE_SIZE;
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004f46:	e0 6a 02 00 	mov	r10,512
80004f4a:	30 0b       	mov	r11,0
80004f4c:	0a 9c       	mov	r12,r5
80004f4e:	f0 1f 00 18 	mcall	80004fac <playback_voice_data+0xf8>
80004f52:	30 1c       	mov	r12,1
80004f54:	c2 28       	rjmp	80004f98 <playback_voice_data+0xe4>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
80004f56:	06 9a       	mov	r10,r3
80004f58:	04 9b       	mov	r11,r2
80004f5a:	0c 9c       	mov	r12,r6
80004f5c:	f0 1f 00 12 	mcall	80004fa4 <playback_voice_data+0xf0>
80004f60:	18 90       	mov	r0,r12
					bytes_remained-=DF_DATA_SPACE_SIZE;
80004f62:	ee c7 02 00 	sub	r7,r7,512
80004f66:	5c 87       	casts.h	r7
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004f68:	04 9a       	mov	r10,r2
80004f6a:	30 0b       	mov	r11,0
80004f6c:	06 9c       	mov	r12,r3
80004f6e:	f0 1f 00 10 	mcall	80004fac <playback_voice_data+0xf8>
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004f72:	e8 07 19 00 	cp.h	r7,r4
80004f76:	5f 19       	srne	r9
80004f78:	58 00       	cp.w	r0,0
80004f7a:	5f 08       	sreq	r8
80004f7c:	f3 e8 00 08 	and	r8,r9,r8
80004f80:	e2 08 18 00 	cp.b	r8,r1
80004f84:	c0 90       	breq	80004f96 <playback_voice_data+0xe2>
				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
					bytes_remained-=DF_DATA_SPACE_SIZE;
					address+=DF_DATA_SPACE_SIZE;
80004f86:	ec c6 fe 00 	sub	r6,r6,-512
80004f8a:	cd 3b       	rjmp	80004f30 <playback_voice_data+0x7c>
80004f8c:	30 0c       	mov	r12,0
80004f8e:	c0 58       	rjmp	80004f98 <playback_voice_data+0xe4>
80004f90:	e0 6c 00 ff 	mov	r12,255
80004f94:	c0 28       	rjmp	80004f98 <playback_voice_data+0xe4>
80004f96:	30 1c       	mov	r12,1
		}
	}
	
	return -1;
	
}
80004f98:	2e ed       	sub	sp,-72
80004f9a:	d8 32       	popm	r0-r7,pc
80004f9c:	00 00       	add	r0,r0
80004f9e:	0b 5e       	ld.sh	lr,--r5
80004fa0:	00 00       	add	r0,r0
80004fa2:	0b 5c       	ld.sh	r12,--r5
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	2a a4       	sub	r4,-86
80004fa8:	00 00       	add	r0,r0
80004faa:	61 00       	ld.w	r0,r0[0x40]
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	78 76       	ld.w	r6,r12[0x1c]

80004fb0 <voc_save_info>:
	return TRUE;

}

Bool voc_save_info(VoiceList_Info_t * voice)
{
80004fb0:	d4 01       	pushm	lr
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	//if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
	{
		//current_voice_index++;
		voice->numb		= current_voice_index;
80004fb2:	49 d9       	lddpc	r9,80005024 <voc_save_info+0x74>
80004fb4:	13 88       	ld.ub	r8,r9[0x0]
80004fb6:	b8 88       	st.b	r12[0x0],r8
80004fb8:	13 98       	ld.ub	r8,r9[0x1]
80004fba:	b8 98       	st.b	r12[0x1],r8
		voice->address	= (current_save_voice_offset - current_bytes_remained);
80004fbc:	49 b8       	lddpc	r8,80005028 <voc_save_info+0x78>
80004fbe:	70 0a       	ld.w	r10,r8[0x0]
80004fc0:	49 b8       	lddpc	r8,8000502c <voc_save_info+0x7c>
80004fc2:	70 08       	ld.w	r8,r8[0x0]
80004fc4:	14 18       	sub	r8,r10
80004fc6:	f0 0b 16 18 	lsr	r11,r8,0x18
80004fca:	f9 6b 00 42 	st.b	r12[66],r11
80004fce:	f0 0b 16 10 	lsr	r11,r8,0x10
80004fd2:	f9 6b 00 43 	st.b	r12[67],r11
80004fd6:	f0 0b 16 08 	lsr	r11,r8,0x8
80004fda:	f9 6b 00 44 	st.b	r12[68],r11
80004fde:	f9 68 00 45 	st.b	r12[69],r8
		voice->offset		= current_bytes_remained;
80004fe2:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
80004fe6:	f0 0a 16 08 	lsr	r10,r8,0x8
80004fea:	f9 6a 00 46 	st.b	r12[70],r10
80004fee:	f9 68 00 47 	st.b	r12[71],r8
		
		address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80004ff2:	92 8b       	ld.uh	r11,r9[0x0]
80004ff4:	20 1b       	sub	r11,1
80004ff6:	f6 0b 00 3b 	add	r11,r11,r11<<0x3
80004ffa:	a3 7b       	lsl	r11,0x3
80004ffc:	2f 0b       	sub	r11,-16
		if(address > VOICE_LIST_BOUNDARY)//The number of messages is out of bounds
80004ffe:	e8 4b 00 00 	cp.w	r11,524288
80005002:	e0 8b 00 10 	brhi	80005022 <voc_save_info+0x72>
		{
			return FALSE;
			log("\r\n----info list is Out of bounds!!!\r\n----");
		}
		//set a voice info by current_voice_index
		return_code = data_flash_write((U8 *)voice, address, VOICE_INFO_LENGTH);
80005006:	34 8a       	mov	r10,72
80005008:	f0 1f 00 0a 	mcall	80005030 <voc_save_info+0x80>
		//set voice numbers
		return_code = data_flash_write(&current_voice_index, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
8000500c:	30 2a       	mov	r10,2
8000500e:	30 ab       	mov	r11,10
80005010:	48 5c       	lddpc	r12,80005024 <voc_save_info+0x74>
80005012:	f0 1f 00 08 	mcall	80005030 <voc_save_info+0x80>
		if(return_code != DF_WRITE_COMPLETED)
80005016:	58 7c       	cp.w	r12,7
80005018:	c0 51       	brne	80005022 <voc_save_info+0x72>
		{
			return FALSE;
		}
		
		current_bytes_remained = 0;//reset 0
8000501a:	30 09       	mov	r9,0
8000501c:	48 38       	lddpc	r8,80005028 <voc_save_info+0x78>
8000501e:	91 09       	st.w	r8[0x0],r9
80005020:	da 0a       	popm	pc,r12=1
	}
	
	return TRUE;
80005022:	d8 0a       	popm	pc,r12=0
80005024:	00 00       	add	r0,r0
80005026:	0b 5c       	ld.sh	r12,--r5
80005028:	00 00       	add	r0,r0
8000502a:	0b 60       	ld.uh	r0,--r5
8000502c:	00 00       	add	r0,r0
8000502e:	05 30       	ld.ub	r0,r2++
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	2c d4       	sub	r4,-51

80005034 <voc_save_data>:
*
*******************************************************************************/
static U32 current_bytes_remained = 0;

Bool voc_save_data(void *data_ptr, U16 data_len, U8 voice_end_flag)
{
80005034:	eb cd 40 c0 	pushm	r6-r7,lr
80005038:	14 96       	mov	r6,r10
	if(!list_init_success_flag)return FALSE;
8000503a:	49 f8       	lddpc	r8,800050b4 <voc_save_data+0x80>
8000503c:	11 89       	ld.ub	r9,r8[0x0]
8000503e:	30 08       	mov	r8,0
80005040:	f0 09 18 00 	cp.b	r9,r8
80005044:	c3 50       	breq	800050ae <voc_save_data+0x7a>
	
	U32 address = 0;
	//static U32 bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	current_bytes_remained+=data_len;//accumulate
80005046:	ef db c0 10 	bfextu	r7,r11,0x0,0x10
8000504a:	49 c8       	lddpc	r8,800050b8 <voc_save_data+0x84>
8000504c:	70 09       	ld.w	r9,r8[0x0]
8000504e:	ee 09 00 09 	add	r9,r7,r9
80005052:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x1000)
80005054:	58 0c       	cp.w	r12,0
80005056:	5f 0a       	sreq	r10
80005058:	e0 68 10 00 	mov	r8,4096
8000505c:	f0 0b 19 00 	cp.h	r11,r8
80005060:	5f b8       	srhi	r8
80005062:	f5 e8 10 08 	or	r8,r10,r8
80005066:	c2 41       	brne	800050ae <voc_save_data+0x7a>
	{
		return FALSE;
	}
	if(current_bytes_remained > 0xFFFF)//data size > 65535bytes == 64k,overout
80005068:	e0 49 ff ff 	cp.w	r9,65535
8000506c:	e0 8b 00 21 	brhi	800050ae <voc_save_data+0x7a>
	{
		//current_bytes_remained = 0;
		return FALSE;
	}
	//save data
	if(current_save_voice_offset > DF_MAX_ADDR)//The voice data is out of bounds
80005070:	49 38       	lddpc	r8,800050bc <voc_save_data+0x88>
80005072:	70 08       	ld.w	r8,r8[0x0]
80005074:	e0 69 ff ff 	mov	r9,65535
80005078:	ea 19 00 7f 	orh	r9,0x7f
8000507c:	12 38       	cp.w	r8,r9
8000507e:	e0 8b 00 18 	brhi	800050ae <voc_save_data+0x7a>
	{
		return FALSE;
		log("\r\n----voice data is Out of bounds!!!\r\n----");
	}
	return_code = data_flash_write((U8 *)data_ptr, current_save_voice_offset, data_len);
80005082:	0e 9a       	mov	r10,r7
80005084:	10 9b       	mov	r11,r8
80005086:	f0 1f 00 0f 	mcall	800050c0 <voc_save_data+0x8c>
	if(return_code != DF_WRITE_COMPLETED)
8000508a:	58 7c       	cp.w	r12,7
8000508c:	c1 11       	brne	800050ae <voc_save_data+0x7a>
	{
		return FALSE;
	}
	current_save_voice_offset+=data_len;
8000508e:	48 c8       	lddpc	r8,800050bc <voc_save_data+0x88>
80005090:	70 09       	ld.w	r9,r8[0x0]
80005092:	12 07       	add	r7,r9
80005094:	91 07       	st.w	r8[0x0],r7
	
	
	//VoiceList_Info_t *ptr = malloc(sizeof(VoiceList_Info_t));
	//if(ptr ==NULL)return FALSE;
	
	if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
80005096:	30 18       	mov	r8,1
80005098:	f0 06 18 00 	cp.b	r6,r8
8000509c:	c0 30       	breq	800050a2 <voc_save_data+0x6e>
8000509e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
	{
		current_voice_index++;
800050a2:	48 98       	lddpc	r8,800050c4 <voc_save_data+0x90>
800050a4:	90 09       	ld.sh	r9,r8[0x0]
800050a6:	2f f9       	sub	r9,-1
800050a8:	b0 09       	st.h	r8[0x0],r9
800050aa:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800050ae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800050b2:	00 00       	add	r0,r0
800050b4:	00 00       	add	r0,r0
800050b6:	0b 5e       	ld.sh	lr,--r5
800050b8:	00 00       	add	r0,r0
800050ba:	0b 60       	ld.uh	r0,--r5
800050bc:	00 00       	add	r0,r0
800050be:	05 30       	ld.ub	r0,r2++
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	2c d4       	sub	r4,-51
800050c4:	00 00       	add	r0,r0
800050c6:	0b 5c       	ld.sh	r12,--r5

800050c8 <voc_read_info>:

}


Bool voc_read_info( unsigned int voice_index,  VoiceList_Info_t * voice)
{
800050c8:	eb cd 40 c0 	pushm	r6-r7,lr
800050cc:	21 2d       	sub	sp,72
800050ce:	18 97       	mov	r7,r12
800050d0:	16 96       	mov	r6,r11
	if(!list_init_success_flag)return FALSE;
800050d2:	49 d8       	lddpc	r8,80005144 <voc_read_info+0x7c>
800050d4:	11 89       	ld.ub	r9,r8[0x0]
800050d6:	30 08       	mov	r8,0
800050d8:	f0 09 18 00 	cp.b	r9,r8
800050dc:	c2 f0       	breq	8000513a <voc_read_info+0x72>
		
	/* check input parameter */
	if (voice_index > current_voice_index)
800050de:	49 b8       	lddpc	r8,80005148 <voc_read_info+0x80>
800050e0:	90 88       	ld.uh	r8,r8[0x0]
800050e2:	18 38       	cp.w	r8,r12
800050e4:	c0 42       	brcc	800050ec <voc_read_info+0x24>
800050e6:	e0 6c 00 ff 	mov	r12,255
800050ea:	c2 98       	rjmp	8000513c <voc_read_info+0x74>
		return -1;
	}
	
	df_status_t return_code = DF_OK;
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
800050ec:	1a 9a       	mov	r10,sp
800050ee:	30 08       	mov	r8,0
800050f0:	30 09       	mov	r9,0
800050f2:	fa e9 00 00 	st.d	sp[0],r8
800050f6:	fa e9 00 08 	st.d	sp[8],r8
800050fa:	fa e9 00 10 	st.d	sp[16],r8
800050fe:	fa e9 00 18 	st.d	sp[24],r8
80005102:	fa e9 00 20 	st.d	sp[32],r8
80005106:	fa e9 00 28 	st.d	sp[40],r8
8000510a:	fa e9 00 30 	st.d	sp[48],r8
8000510e:	fa e9 00 38 	st.d	sp[56],r8
80005112:	fa e9 00 40 	st.d	sp[64],r8
	unsigned int address =0x00000000;
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80005116:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000511a:	a3 7c       	lsl	r12,0x3
8000511c:	34 8b       	mov	r11,72
8000511e:	23 8c       	sub	r12,56
80005120:	f0 1f 00 0b 	mcall	8000514c <voc_read_info+0x84>
	if (return_code == DF_OK)
80005124:	c0 b1       	brne	8000513a <voc_read_info+0x72>
	{
		if(((VoiceList_Info_t *)str)->numb == voice_index)
80005126:	9a 88       	ld.uh	r8,sp[0x0]
80005128:	0e 38       	cp.w	r8,r7
8000512a:	c0 81       	brne	8000513a <voc_read_info+0x72>
		{
			memcpy(voice, str, sizeof(VoiceList_Info_t));
8000512c:	34 8a       	mov	r10,72
8000512e:	1a 9b       	mov	r11,sp
80005130:	0c 9c       	mov	r12,r6
80005132:	f0 1f 00 08 	mcall	80005150 <voc_read_info+0x88>
80005136:	30 1c       	mov	r12,1
			return TRUE;
80005138:	c0 28       	rjmp	8000513c <voc_read_info+0x74>
8000513a:	30 0c       	mov	r12,0
			return FALSE;
	}
	else
		return FALSE;
	
}
8000513c:	2e ed       	sub	sp,-72
8000513e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005142:	00 00       	add	r0,r0
80005144:	00 00       	add	r0,r0
80005146:	0b 5e       	ld.sh	lr,--r5
80005148:	00 00       	add	r0,r0
8000514a:	0b 5c       	ld.sh	r12,--r5
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	2a a4       	sub	r4,-86
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	77 2e       	ld.w	lr,r11[0x48]

80005154 <voc_read_write_test>:

VoiceList_Info_t voice_ptr;
VoiceList_Info_t voice_temp;

void voc_read_write_test(void)
{
80005154:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 status = 0xff;
	
	/**save**/
	voc_save_data(AMBE_AudioData, 600, TRUE);
80005158:	4b 26       	lddpc	r6,80005220 <voc_read_write_test+0xcc>
8000515a:	30 1a       	mov	r10,1
8000515c:	e0 6b 02 58 	mov	r11,600
80005160:	0c 9c       	mov	r12,r6
80005162:	f0 1f 00 31 	mcall	80005224 <voc_read_write_test+0xd0>
	//save voice information
	voc_save_info(&voice_ptr);
80005166:	4b 17       	lddpc	r7,80005228 <voc_read_write_test+0xd4>
80005168:	0e 9c       	mov	r12,r7
8000516a:	f0 1f 00 31 	mcall	8000522c <voc_read_write_test+0xd8>
	
	voc_save_data(&AMBE_AudioData[600], 300, FALSE);
8000516e:	30 0a       	mov	r10,0
80005170:	e0 6b 01 2c 	mov	r11,300
80005174:	ec cc fd a8 	sub	r12,r6,-600
80005178:	f0 1f 00 2b 	mcall	80005224 <voc_read_write_test+0xd0>
	voc_save_data(&AMBE_AudioData[950], 500, TRUE);
8000517c:	30 1a       	mov	r10,1
8000517e:	e0 6b 01 f4 	mov	r11,500
80005182:	ec cc fc 4a 	sub	r12,r6,-950
80005186:	f0 1f 00 28 	mcall	80005224 <voc_read_write_test+0xd0>
	memset(&voice_ptr, 0x00, sizeof(voice_ptr));
8000518a:	34 8a       	mov	r10,72
8000518c:	30 0b       	mov	r11,0
8000518e:	0e 9c       	mov	r12,r7
80005190:	f0 1f 00 28 	mcall	80005230 <voc_read_write_test+0xdc>
	voice_ptr.Header.Header = 0xABCD5A5A;
80005194:	3a b8       	mov	r8,-85
80005196:	ae a8       	st.b	r7[0x2],r8
80005198:	3c d8       	mov	r8,-51
8000519a:	ae b8       	st.b	r7[0x3],r8
8000519c:	35 a8       	mov	r8,90
8000519e:	ae c8       	st.b	r7[0x4],r8
800051a0:	ae d8       	st.b	r7[0x5],r8
	//save voice information
	voc_save_info(&voice_ptr);
800051a2:	0e 9c       	mov	r12,r7
800051a4:	f0 1f 00 22 	mcall	8000522c <voc_read_write_test+0xd8>
	
	
	voc_save_data(AMBE_AudioData, 1024, TRUE);
800051a8:	30 1a       	mov	r10,1
800051aa:	e0 6b 04 00 	mov	r11,1024
800051ae:	0c 9c       	mov	r12,r6
800051b0:	f0 1f 00 1d 	mcall	80005224 <voc_read_write_test+0xd0>
	//save voice information
	voc_save_info(&voice_ptr);
800051b4:	0e 9c       	mov	r12,r7
800051b6:	f0 1f 00 1e 	mcall	8000522c <voc_read_write_test+0xd8>
	
	
	/**read**/
	status = voc_read_info(1, &voice_temp);
800051ba:	49 fb       	lddpc	r11,80005234 <voc_read_write_test+0xe0>
800051bc:	30 1c       	mov	r12,1
800051be:	f0 1f 00 1f 	mcall	80005238 <voc_read_write_test+0xe4>
	if(status ==TRUE){
800051c2:	30 18       	mov	r8,1
800051c4:	f0 0c 18 00 	cp.b	r12,r8
800051c8:	c0 91       	brne	800051da <voc_read_write_test+0x86>
		
		playback_voice_data(1);
800051ca:	30 1c       	mov	r12,1
800051cc:	f0 1f 00 1c 	mcall	8000523c <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
800051d0:	34 8a       	mov	r10,72
800051d2:	30 0b       	mov	r11,0
800051d4:	49 8c       	lddpc	r12,80005234 <voc_read_write_test+0xe0>
800051d6:	f0 1f 00 17 	mcall	80005230 <voc_read_write_test+0xdc>
		
	}
	
	status = voc_read_info(3, &voice_temp);
800051da:	49 7b       	lddpc	r11,80005234 <voc_read_write_test+0xe0>
800051dc:	30 3c       	mov	r12,3
800051de:	f0 1f 00 17 	mcall	80005238 <voc_read_write_test+0xe4>
	if(status ==TRUE){
800051e2:	30 18       	mov	r8,1
800051e4:	f0 0c 18 00 	cp.b	r12,r8
800051e8:	c0 91       	brne	800051fa <voc_read_write_test+0xa6>
		
		playback_voice_data(3);
800051ea:	30 3c       	mov	r12,3
800051ec:	f0 1f 00 14 	mcall	8000523c <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
800051f0:	34 8a       	mov	r10,72
800051f2:	30 0b       	mov	r11,0
800051f4:	49 0c       	lddpc	r12,80005234 <voc_read_write_test+0xe0>
800051f6:	f0 1f 00 0f 	mcall	80005230 <voc_read_write_test+0xdc>
		
	}
	
	status = voc_read_info(20, &voice_temp);
800051fa:	48 fb       	lddpc	r11,80005234 <voc_read_write_test+0xe0>
800051fc:	31 4c       	mov	r12,20
800051fe:	f0 1f 00 0f 	mcall	80005238 <voc_read_write_test+0xe4>
	if(status ==TRUE){
80005202:	30 18       	mov	r8,1
80005204:	f0 0c 18 00 	cp.b	r12,r8
80005208:	c0 91       	brne	8000521a <voc_read_write_test+0xc6>
			
		playback_voice_data(20);
8000520a:	31 4c       	mov	r12,20
8000520c:	f0 1f 00 0c 	mcall	8000523c <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
80005210:	34 8a       	mov	r10,72
80005212:	30 0b       	mov	r11,0
80005214:	48 8c       	lddpc	r12,80005234 <voc_read_write_test+0xe0>
80005216:	f0 1f 00 07 	mcall	80005230 <voc_read_write_test+0xdc>
8000521a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000521e:	00 00       	add	r0,r0
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	d5 a8       	*unknown*
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	50 34       	stdsp	sp[0xc],r4
80005228:	00 00       	add	r0,r0
8000522a:	63 00       	ld.w	r0,r1[0x40]
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	4f b0       	lddpc	r0,80005418 <INTC_register_interrupt+0x8>
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	78 76       	ld.w	r6,r12[0x1c]
80005234:	00 00       	add	r0,r0
80005236:	63 48       	ld.w	r8,r1[0x50]
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	50 c8       	stdsp	sp[0x30],r8
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	4e b4       	lddpc	r4,800053e8 <voc_init+0x1a8>

80005240 <voc_init>:
	
}


void voc_init(void)
{
80005240:	d4 31       	pushm	r0-r7,lr
80005242:	21 4d       	sub	sp,80
	data_flash_init();
80005244:	f0 1f 00 62 	mcall	800053cc <voc_init+0x18c>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
80005248:	30 08       	mov	r8,0
8000524a:	30 09       	mov	r9,0
8000524c:	fa e9 00 00 	st.d	sp[0],r8
80005250:	fa e9 00 08 	st.d	sp[8],r8
80005254:	fa e9 00 10 	st.d	sp[16],r8
80005258:	fa e9 00 18 	st.d	sp[24],r8
8000525c:	fa e9 00 20 	st.d	sp[32],r8
80005260:	fa e9 00 28 	st.d	sp[40],r8
80005264:	fa e9 00 30 	st.d	sp[48],r8
80005268:	fa e9 00 38 	st.d	sp[56],r8
8000526c:	fa e9 00 40 	st.d	sp[64],r8
80005270:	fa e9 00 48 	st.d	sp[72],r8
80005274:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005276:	1a 97       	mov	r7,sp
80005278:	30 73       	mov	r3,7
8000527a:	0a 94       	mov	r4,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
8000527c:	4d 52       	lddpc	r2,800053d0 <voc_init+0x190>
			log("\r\n----create voice info锛 okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
8000527e:	4d 66       	lddpc	r6,800053d4 <voc_init+0x194>
80005280:	30 21       	mov	r1,2
80005282:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005284:	1a 9a       	mov	r10,sp
80005286:	06 9b       	mov	r11,r3
80005288:	08 9c       	mov	r12,r4
8000528a:	f0 1f 00 54 	mcall	800053d8 <voc_init+0x198>
	if(return_code == DF_OK)
8000528e:	e0 81 00 9b 	brne	800053c4 <voc_init+0x184>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80005292:	06 9a       	mov	r10,r3
80005294:	1a 9b       	mov	r11,sp
80005296:	04 9c       	mov	r12,r2
80005298:	f0 1f 00 51 	mcall	800053dc <voc_init+0x19c>
8000529c:	c3 60       	breq	80005308 <voc_init+0xc8>
8000529e:	c8 78       	rjmp	800053ac <voc_init+0x16c>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
800052a0:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800052a4:	0e 9b       	mov	r11,r7
800052a6:	0a 9c       	mov	r12,r5
800052a8:	f0 1f 00 4e 	mcall	800053e0 <voc_init+0x1a0>
				if(return_code != DF_ERASE_COMPLETED)
800052ac:	58 5c       	cp.w	r12,5
800052ae:	e0 81 00 8b 	brne	800053c4 <voc_init+0x184>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
800052b2:	0c 35       	cp.w	r5,r6
800052b4:	cf 61       	brne	800052a0 <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
800052b6:	30 7a       	mov	r10,7
800052b8:	30 0b       	mov	r11,0
800052ba:	4c 6c       	lddpc	r12,800053d0 <voc_init+0x190>
800052bc:	f0 1f 00 4a 	mcall	800053e4 <voc_init+0x1a4>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
800052c0:	1a 9c       	mov	r12,sp
800052c2:	30 08       	mov	r8,0
800052c4:	30 09       	mov	r9,0
800052c6:	fa e9 00 00 	st.d	sp[0],r8
800052ca:	fa e9 00 08 	st.d	sp[8],r8
800052ce:	fa e9 00 10 	st.d	sp[16],r8
800052d2:	fa e9 00 18 	st.d	sp[24],r8
800052d6:	fa e9 00 20 	st.d	sp[32],r8
800052da:	fa e9 00 28 	st.d	sp[40],r8
800052de:	fa e9 00 30 	st.d	sp[48],r8
800052e2:	fa e9 00 38 	st.d	sp[56],r8
800052e6:	fa e9 00 40 	st.d	sp[64],r8
800052ea:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
800052ee:	30 2a       	mov	r10,2
800052f0:	30 ab       	mov	r11,10
800052f2:	f0 1f 00 3d 	mcall	800053e4 <voc_init+0x1a4>
			if(return_code != DF_WRITE_COMPLETED)
800052f6:	58 7c       	cp.w	r12,7
800052f8:	c6 61       	brne	800053c4 <voc_init+0x184>
			{
				return FALSE;
			}
			current_voice_index = 0;
800052fa:	30 09       	mov	r9,0
800052fc:	4b 68       	lddpc	r8,800053d4 <voc_init+0x194>
800052fe:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info锛 okay!----\r\n");
80005300:	4b ac       	lddpc	r12,800053e8 <voc_init+0x1a8>
80005302:	f0 1f 00 3b 	mcall	800053ec <voc_init+0x1ac>
80005306:	c5 c8       	rjmp	800053be <voc_init+0x17e>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80005308:	0c 9a       	mov	r10,r6
8000530a:	02 9b       	mov	r11,r1
8000530c:	00 9c       	mov	r12,r0
8000530e:	f0 1f 00 33 	mcall	800053d8 <voc_init+0x198>
			if(return_code == DF_OK)
80005312:	c5 91       	brne	800053c4 <voc_init+0x184>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80005314:	8c 08       	ld.sh	r8,r6[0x0]
80005316:	58 08       	cp.w	r8,0
80005318:	c5 00       	breq	800053b8 <voc_init+0x178>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
8000531a:	5c 78       	castu.h	r8
8000531c:	20 18       	sub	r8,1
8000531e:	f0 08 00 38 	add	r8,r8,r8<<0x3
80005322:	f0 05 15 03 	lsl	r5,r8,0x3
80005326:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80005328:	1a 9a       	mov	r10,sp
8000532a:	34 8b       	mov	r11,72
8000532c:	0a 9c       	mov	r12,r5
8000532e:	f0 1f 00 2b 	mcall	800053d8 <voc_init+0x198>
					return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)TEMP_BUF);
80005332:	4b 0a       	lddpc	r10,800053f0 <voc_init+0x1b0>
80005334:	e0 6b 02 00 	mov	r11,512
80005338:	08 9c       	mov	r12,r4
8000533a:	f0 1f 00 28 	mcall	800053d8 <voc_init+0x198>
					if(return_code == DF_OK)
8000533e:	c3 d1       	brne	800053b8 <voc_init+0x178>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80005340:	0f 89       	ld.ub	r9,r7[0x0]
80005342:	0f 98       	ld.ub	r8,r7[0x1]
80005344:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005348:	8c 09       	ld.sh	r9,r6[0x0]
8000534a:	f0 09 19 00 	cp.h	r9,r8
8000534e:	c2 c1       	brne	800053a6 <voc_init+0x166>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80005350:	ef 39 00 46 	ld.ub	r9,r7[70]
80005354:	ef 38 00 47 	ld.ub	r8,r7[71]
80005358:	f1 e9 10 89 	or	r9,r8,r9<<0x8
8000535c:	ef 3a 00 42 	ld.ub	r10,r7[66]
80005360:	ef 38 00 43 	ld.ub	r8,r7[67]
80005364:	b1 68       	lsl	r8,0x10
80005366:	f1 ea 11 88 	or	r8,r8,r10<<0x18
8000536a:	ef 3a 00 44 	ld.ub	r10,r7[68]
8000536e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005372:	ef 3a 00 45 	ld.ub	r10,r7[69]
80005376:	f5 e8 10 08 	or	r8,r10,r8
8000537a:	f2 08 00 08 	add	r8,r9,r8
8000537e:	49 e9       	lddpc	r9,800053f4 <voc_init+0x1b4>
80005380:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80005382:	e0 69 c0 00 	mov	r9,49152
80005386:	ea 19 00 7b 	orh	r9,0x7b
8000538a:	12 38       	cp.w	r8,r9
8000538c:	e0 88 00 16 	brls	800053b8 <voc_init+0x178>
								
								log("\r\n----voice storage is full!!!----\r\n");
80005390:	49 ac       	lddpc	r12,800053f8 <voc_init+0x1b8>
80005392:	f0 1f 00 17 	mcall	800053ec <voc_init+0x1ac>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005396:	30 4b       	mov	r11,4
80005398:	08 9c       	mov	r12,r4
8000539a:	f0 1f 00 12 	mcall	800053e0 <voc_init+0x1a0>
								if(return_code == DF_ERASE_COMPLETED)goto start;
8000539e:	58 5c       	cp.w	r12,5
800053a0:	fe 90 ff 72 	breq	80005284 <voc_init+0x44>
800053a4:	c1 08       	rjmp	800053c4 <voc_init+0x184>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
800053a6:	49 6c       	lddpc	r12,800053fc <voc_init+0x1bc>
800053a8:	f0 1f 00 11 	mcall	800053ec <voc_init+0x1ac>
	
	
}


void voc_init(void)
800053ac:	e6 78 00 00 	mov	r8,458752
800053b0:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800053b4:	30 37       	mov	r7,3
800053b6:	c7 7b       	rjmp	800052a4 <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info锛 okay!----\r\n");
800053b8:	49 2c       	lddpc	r12,80005400 <voc_init+0x1c0>
800053ba:	f0 1f 00 0d 	mcall	800053ec <voc_init+0x1ac>
			}
			else
			return FALSE;
		}
		
		list_init_success_flag = 1;
800053be:	30 19       	mov	r9,1
800053c0:	49 18       	lddpc	r8,80005404 <voc_init+0x1c4>
800053c2:	b0 89       	st.b	r8[0x0],r9
	// then read address 0x00001002 every 5s and report to radio with failure
	//test_data_flash(FALSE);
	//create_data_flash_test_task();
	voice_list_info_init();
	
	voc_read_write_test();
800053c4:	f0 1f 00 11 	mcall	80005408 <voc_init+0x1c8>

800053c8:	2e cd       	sub	sp,-80
800053ca:	d8 32       	popm	r0-r7,pc
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	2d c4       	sub	r4,-36
800053d0:	00 00       	add	r0,r0
800053d2:	05 28       	ld.uh	r8,r2++
800053d4:	00 00       	add	r0,r0
800053d6:	0b 5c       	ld.sh	r12,--r5
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	2a a4       	sub	r4,-86
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	77 08       	ld.w	r8,r11[0x40]
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	2c 38       	sub	r8,-61
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	2c d4       	sub	r4,-51
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	db e4       	*unknown*
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	6d 74       	ld.w	r4,r6[0x5c]
800053f0:	00 00       	add	r0,r0
800053f2:	51 00       	stdsp	sp[0x40],r0
800053f4:	00 00       	add	r0,r0
800053f6:	05 30       	ld.ub	r0,r2++
800053f8:	80 00       	ld.sh	r0,r0[0x0]
800053fa:	dc 0c       	*unknown*
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	dc 34       	*unknown*
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	dc 58       	*unknown*
80005404:	00 00       	add	r0,r0
80005406:	0b 5e       	ld.sh	lr,--r5
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	51 54       	stdsp	sp[0x54],r4

8000540c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000540c:	c0 08       	rjmp	8000540c <_unhandled_interrupt>
8000540e:	d7 03       	nop

80005410 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005410:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005414:	49 99       	lddpc	r9,80005478 <INTC_register_interrupt+0x68>
80005416:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000541a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000541e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005420:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005424:	58 0a       	cp.w	r10,0
80005426:	c0 91       	brne	80005438 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005428:	49 59       	lddpc	r9,8000547c <INTC_register_interrupt+0x6c>
8000542a:	49 6a       	lddpc	r10,80005480 <INTC_register_interrupt+0x70>
8000542c:	12 1a       	sub	r10,r9
8000542e:	fe 79 08 00 	mov	r9,-63488
80005432:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005436:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005438:	58 1a       	cp.w	r10,1
8000543a:	c0 a1       	brne	8000544e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000543c:	49 09       	lddpc	r9,8000547c <INTC_register_interrupt+0x6c>
8000543e:	49 2a       	lddpc	r10,80005484 <INTC_register_interrupt+0x74>
80005440:	12 1a       	sub	r10,r9
80005442:	bf aa       	sbr	r10,0x1e
80005444:	fe 79 08 00 	mov	r9,-63488
80005448:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000544c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000544e:	58 2a       	cp.w	r10,2
80005450:	c0 a1       	brne	80005464 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005452:	48 b9       	lddpc	r9,8000547c <INTC_register_interrupt+0x6c>
80005454:	48 da       	lddpc	r10,80005488 <INTC_register_interrupt+0x78>
80005456:	12 1a       	sub	r10,r9
80005458:	bf ba       	sbr	r10,0x1f
8000545a:	fe 79 08 00 	mov	r9,-63488
8000545e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005462:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005464:	48 69       	lddpc	r9,8000547c <INTC_register_interrupt+0x6c>
80005466:	48 aa       	lddpc	r10,8000548c <INTC_register_interrupt+0x7c>
80005468:	12 1a       	sub	r10,r9
8000546a:	ea 1a c0 00 	orh	r10,0xc000
8000546e:	fe 79 08 00 	mov	r9,-63488
80005472:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005476:	5e fc       	retal	r12
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	dc 80       	acall	0xc8
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	cc 00       	breq	800053fe <voc_init+0x1be>
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	cd 04       	brge	80005422 <INTC_register_interrupt+0x12>
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	cd 12       	brcc	80005428 <INTC_register_interrupt+0x18>
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	cd 20       	breq	8000542e <INTC_register_interrupt+0x1e>
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	cd 2e       	rcall	80005232 <voc_read_write_test+0xde>

80005490 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005490:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005492:	49 18       	lddpc	r8,800054d4 <INTC_init_interrupts+0x44>
80005494:	e3 b8 00 01 	mtsr	0x4,r8
80005498:	49 0e       	lddpc	lr,800054d8 <INTC_init_interrupts+0x48>
8000549a:	30 07       	mov	r7,0
8000549c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000549e:	49 0c       	lddpc	r12,800054dc <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054a0:	49 05       	lddpc	r5,800054e0 <INTC_init_interrupts+0x50>
800054a2:	10 15       	sub	r5,r8
800054a4:	fe 76 08 00 	mov	r6,-63488
800054a8:	c1 08       	rjmp	800054c8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054aa:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054ac:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054ae:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054b0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054b4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054b6:	10 3a       	cp.w	r10,r8
800054b8:	fe 9b ff fc 	brhi	800054b0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054bc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054c0:	2f f7       	sub	r7,-1
800054c2:	2f 8e       	sub	lr,-8
800054c4:	59 37       	cp.w	r7,19
800054c6:	c0 50       	breq	800054d0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054c8:	7c 08       	ld.w	r8,lr[0x0]
800054ca:	58 08       	cp.w	r8,0
800054cc:	ce f1       	brne	800054aa <INTC_init_interrupts+0x1a>
800054ce:	cf 7b       	rjmp	800054bc <INTC_init_interrupts+0x2c>
800054d0:	d8 22       	popm	r4-r7,pc
800054d2:	00 00       	add	r0,r0
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	cc 00       	breq	80005456 <INTC_register_interrupt+0x46>
800054d8:	80 00       	ld.sh	r0,r0[0x0]
800054da:	dc 80       	acall	0xc8
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	54 0c       	stdsp	sp[0x100],r12
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	cd 04       	brge	80005482 <INTC_register_interrupt+0x72>

800054e4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800054e4:	fe 78 08 00 	mov	r8,-63488
800054e8:	e0 69 00 83 	mov	r9,131
800054ec:	f2 0c 01 0c 	sub	r12,r9,r12
800054f0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800054f4:	f2 ca ff c0 	sub	r10,r9,-64
800054f8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800054fc:	58 08       	cp.w	r8,0
800054fe:	c0 21       	brne	80005502 <_get_interrupt_handler+0x1e>
80005500:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005502:	f0 08 12 00 	clz	r8,r8
80005506:	48 5a       	lddpc	r10,80005518 <_get_interrupt_handler+0x34>
80005508:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000550c:	f0 08 11 1f 	rsub	r8,r8,31
80005510:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005512:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005516:	5e fc       	retal	r12
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	dc 80       	acall	0xc8

8000551c <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
8000551c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005520:	30 18       	mov	r8,1
80005522:	f0 09 18 00 	cp.b	r9,r8
80005526:	e0 88 00 04 	brls	8000552e <spi_initMaster+0x12>
8000552a:	30 2c       	mov	r12,2
8000552c:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000552e:	e0 68 00 80 	mov	r8,128
80005532:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005534:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005536:	30 19       	mov	r9,1
80005538:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000553c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005540:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005544:	30 09       	mov	r9,0
80005546:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000554a:	30 fa       	mov	r10,15
8000554c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005550:	99 18       	st.w	r12[0x4],r8
80005552:	5e f9       	retal	r9

80005554 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005554:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005556:	30 18       	mov	r8,1
80005558:	f0 0b 18 00 	cp.b	r11,r8
8000555c:	5f be       	srhi	lr
8000555e:	f0 0a 18 00 	cp.b	r10,r8
80005562:	5f b8       	srhi	r8
80005564:	fd e8 10 08 	or	r8,lr,r8
80005568:	c0 30       	breq	8000556e <spi_selectionMode+0x1a>
8000556a:	30 2c       	mov	r12,2
8000556c:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
8000556e:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005570:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005574:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005578:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
8000557c:	99 18       	st.w	r12[0x4],r8
8000557e:	d8 0a       	popm	pc,r12=0

80005580 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005580:	78 18       	ld.w	r8,r12[0x4]
80005582:	ea 18 00 0f 	orh	r8,0xf
80005586:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005588:	78 18       	ld.w	r8,r12[0x4]
8000558a:	e2 18 00 04 	andl	r8,0x4,COH
8000558e:	c0 f0       	breq	800055ac <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005590:	30 e8       	mov	r8,14
80005592:	f0 0b 18 00 	cp.b	r11,r8
80005596:	e0 8b 00 19 	brhi	800055c8 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
8000559a:	78 18       	ld.w	r8,r12[0x4]
8000559c:	b1 6b       	lsl	r11,0x10
8000559e:	ea 1b ff f0 	orh	r11,0xfff0
800055a2:	e8 1b ff ff 	orl	r11,0xffff
800055a6:	10 6b       	and	r11,r8
800055a8:	99 1b       	st.w	r12[0x4],r11
800055aa:	5e fd       	retal	0
  } else {
    if (chip > 3) {
800055ac:	30 38       	mov	r8,3
800055ae:	f0 0b 18 00 	cp.b	r11,r8
800055b2:	e0 8b 00 0b 	brhi	800055c8 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800055b6:	78 18       	ld.w	r8,r12[0x4]
800055b8:	2f 0b       	sub	r11,-16
800055ba:	30 19       	mov	r9,1
800055bc:	f2 0b 09 4b 	lsl	r11,r9,r11
800055c0:	5c db       	com	r11
800055c2:	10 6b       	and	r11,r8
800055c4:	99 1b       	st.w	r12[0x4],r11
800055c6:	5e fd       	retal	0
800055c8:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
800055ca:	5e fc       	retal	r12

800055cc <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
800055cc:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800055d0:	c0 58       	rjmp	800055da <spi_unselectChip+0xe>
    if (!timeout--) {
800055d2:	58 08       	cp.w	r8,0
800055d4:	c0 21       	brne	800055d8 <spi_unselectChip+0xc>
800055d6:	5e ff       	retal	1
800055d8:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800055da:	78 49       	ld.w	r9,r12[0x10]
800055dc:	e2 19 02 00 	andl	r9,0x200,COH
800055e0:	cf 90       	breq	800055d2 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
800055e2:	78 18       	ld.w	r8,r12[0x4]
800055e4:	ea 18 00 0f 	orh	r8,0xf
800055e8:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800055ea:	fc 18 01 00 	movh	r8,0x100
800055ee:	99 08       	st.w	r12[0x0],r8
800055f0:	5e fd       	retal	0

800055f2 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
800055f2:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
800055f6:	f7 38 00 0c 	ld.ub	r8,r11[12]
800055fa:	30 39       	mov	r9,3
800055fc:	f2 08 18 00 	cp.b	r8,r9
80005600:	e0 8b 00 57 	brhi	800056ae <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005604:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005608:	30 1e       	mov	lr,1
8000560a:	fc 09 18 00 	cp.b	r9,lr
8000560e:	e0 8b 00 50 	brhi	800056ae <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005612:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005616:	30 77       	mov	r7,7
80005618:	ee 0e 18 00 	cp.b	lr,r7
8000561c:	e0 88 00 49 	brls	800056ae <spi_setupChipReg+0xbc>
80005620:	31 07       	mov	r7,16
80005622:	ee 0e 18 00 	cp.b	lr,r7
80005626:	e0 8b 00 44 	brhi	800056ae <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
8000562a:	76 17       	ld.w	r7,r11[0x4]
8000562c:	ee 06 16 01 	lsr	r6,r7,0x1
80005630:	0c 0a       	add	r10,r6
80005632:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005636:	ec c7 00 01 	sub	r7,r6,1
8000563a:	e0 47 00 fe 	cp.w	r7,254
8000563e:	e0 8b 00 38 	brhi	800056ae <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005642:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005644:	58 06       	cp.w	r6,0
80005646:	c3 45       	brlt	800056ae <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005648:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
8000564a:	f0 06 16 01 	lsr	r6,r8,0x1
8000564e:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005652:	ec 18 00 01 	eorl	r8,0x1
80005656:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
8000565a:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
8000565e:	20 8e       	sub	lr,8
80005660:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005664:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005668:	f7 38 00 09 	ld.ub	r8,r11[9]
8000566c:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005670:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005674:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005678:	17 88       	ld.ub	r8,r11[0x0]
8000567a:	30 19       	mov	r9,1
8000567c:	f2 08 18 00 	cp.b	r8,r9
80005680:	c0 e0       	breq	8000569c <spi_setupChipReg+0xaa>
80005682:	c0 a3       	brcs	80005696 <spi_setupChipReg+0xa4>
80005684:	30 29       	mov	r9,2
80005686:	f2 08 18 00 	cp.b	r8,r9
8000568a:	c0 c0       	breq	800056a2 <spi_setupChipReg+0xb0>
8000568c:	30 39       	mov	r9,3
8000568e:	f2 08 18 00 	cp.b	r8,r9
80005692:	c0 e1       	brne	800056ae <spi_setupChipReg+0xbc>
80005694:	c0 a8       	rjmp	800056a8 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005696:	99 ca       	st.w	r12[0x30],r10
80005698:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
8000569c:	99 da       	st.w	r12[0x34],r10
8000569e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
800056a2:	99 ea       	st.w	r12[0x38],r10
800056a4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
800056a8:	99 fa       	st.w	r12[0x3c],r10
800056aa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
800056ae:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
800056b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800056b4 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800056b4:	30 18       	mov	r8,1
800056b6:	99 08       	st.w	r12[0x0],r8
}
800056b8:	5e fc       	retal	r12

800056ba <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
800056ba:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056be:	c0 58       	rjmp	800056c8 <spi_write+0xe>
    if (!timeout--) {
800056c0:	58 08       	cp.w	r8,0
800056c2:	c0 21       	brne	800056c6 <spi_write+0xc>
800056c4:	5e ff       	retal	1
800056c6:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056c8:	78 49       	ld.w	r9,r12[0x10]
800056ca:	e2 19 00 02 	andl	r9,0x2,COH
800056ce:	cf 90       	breq	800056c0 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800056d0:	5c 7b       	castu.h	r11
800056d2:	99 3b       	st.w	r12[0xc],r11
800056d4:	5e fd       	retal	0

800056d6 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
800056d6:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
800056da:	c0 58       	rjmp	800056e4 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
800056dc:	58 08       	cp.w	r8,0
800056de:	c0 21       	brne	800056e2 <spi_read+0xc>
800056e0:	5e ff       	retal	1
800056e2:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
800056e4:	78 49       	ld.w	r9,r12[0x10]
800056e6:	e2 19 02 01 	andl	r9,0x201,COH
800056ea:	e0 49 02 01 	cp.w	r9,513
800056ee:	cf 71       	brne	800056dc <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800056f0:	78 28       	ld.w	r8,r12[0x8]
800056f2:	b6 08       	st.h	r11[0x0],r8
800056f4:	5e fd       	retal	0

800056f6 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
800056f6:	76 09       	ld.w	r9,r11[0x0]
800056f8:	58 29       	cp.w	r9,2
800056fa:	e0 88 00 03 	brls	80005700 <tc_init_waveform+0xa>
800056fe:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005700:	76 18       	ld.w	r8,r11[0x4]
80005702:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005706:	af ba       	sbr	r10,0xf
80005708:	10 9b       	mov	r11,r8
8000570a:	e6 1b c0 00 	andh	r11,0xc000,COH
8000570e:	16 4a       	or	r10,r11
80005710:	10 9b       	mov	r11,r8
80005712:	e6 1b 30 00 	andh	r11,0x3000,COH
80005716:	16 4a       	or	r10,r11
80005718:	10 9b       	mov	r11,r8
8000571a:	e6 1b 0c 00 	andh	r11,0xc00,COH
8000571e:	16 4a       	or	r10,r11
80005720:	10 9b       	mov	r11,r8
80005722:	e6 1b 03 00 	andh	r11,0x300,COH
80005726:	16 4a       	or	r10,r11
80005728:	10 9b       	mov	r11,r8
8000572a:	e6 1b 00 c0 	andh	r11,0xc0,COH
8000572e:	16 4a       	or	r10,r11
80005730:	10 9b       	mov	r11,r8
80005732:	e6 1b 00 30 	andh	r11,0x30,COH
80005736:	16 4a       	or	r10,r11
80005738:	10 9b       	mov	r11,r8
8000573a:	e6 1b 00 0c 	andh	r11,0xc,COH
8000573e:	16 4a       	or	r10,r11
80005740:	10 9b       	mov	r11,r8
80005742:	e6 1b 00 03 	andh	r11,0x3,COH
80005746:	16 4a       	or	r10,r11
80005748:	10 9b       	mov	r11,r8
8000574a:	e2 1b 60 00 	andl	r11,0x6000,COH
8000574e:	16 4a       	or	r10,r11
80005750:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005754:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005758:	10 9b       	mov	r11,r8
8000575a:	e2 1b 0c 00 	andl	r11,0xc00,COH
8000575e:	16 4a       	or	r10,r11
80005760:	10 9b       	mov	r11,r8
80005762:	e2 1b 03 00 	andl	r11,0x300,COH
80005766:	16 4a       	or	r10,r11
80005768:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
8000576c:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005770:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005774:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005778:	10 9b       	mov	r11,r8
8000577a:	e2 1b 00 30 	andl	r11,0x30,COH
8000577e:	16 4a       	or	r10,r11
80005780:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005784:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005788:	a5 69       	lsl	r9,0x4
8000578a:	2f f9       	sub	r9,-1
8000578c:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005790:	5e fd       	retal	0

80005792 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005792:	58 2b       	cp.w	r11,2
80005794:	e0 88 00 03 	brls	8000579a <tc_start+0x8>
80005798:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000579a:	a7 6b       	lsl	r11,0x6
8000579c:	16 0c       	add	r12,r11
8000579e:	30 58       	mov	r8,5
800057a0:	99 08       	st.w	r12[0x0],r8
800057a2:	5e fd       	retal	0

800057a4 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800057a4:	58 2b       	cp.w	r11,2
800057a6:	e0 88 00 03 	brls	800057ac <tc_read_sr+0x8>
800057aa:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800057ac:	a7 6b       	lsl	r11,0x6
800057ae:	2e 0b       	sub	r11,-32
800057b0:	16 0c       	add	r12,r11
800057b2:	78 0c       	ld.w	r12,r12[0x0]
}
800057b4:	5e fc       	retal	r12

800057b6 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800057b6:	58 2b       	cp.w	r11,2
800057b8:	e0 88 00 03 	brls	800057be <tc_write_rc+0x8>
800057bc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800057be:	f6 08 15 04 	lsl	r8,r11,0x4
800057c2:	2f f8       	sub	r8,-1
800057c4:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800057c8:	e2 18 80 00 	andl	r8,0x8000,COH
800057cc:	c0 c0       	breq	800057e4 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800057ce:	a7 6b       	lsl	r11,0x6
800057d0:	16 0c       	add	r12,r11
800057d2:	2e 4c       	sub	r12,-28
800057d4:	78 08       	ld.w	r8,r12[0x0]
800057d6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800057da:	e0 18 00 00 	andl	r8,0x0
800057de:	f3 e8 10 08 	or	r8,r9,r8
800057e2:	99 08       	st.w	r12[0x0],r8

  return value;
800057e4:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
800057e8:	5e fc       	retal	r12

800057ea <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
800057ea:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800057ee:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800057f2:	58 2b       	cp.w	r11,2
800057f4:	e0 88 00 04 	brls	800057fc <tc_configure_interrupts+0x12>
800057f8:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
800057fc:	ee 19 00 01 	eorh	r9,0x1
80005800:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005804:	74 08       	ld.w	r8,r10[0x0]
80005806:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
8000580a:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
8000580e:	a7 6e       	lsl	lr,0x6
80005810:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005814:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005818:	0e 4e       	or	lr,r7
8000581a:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
8000581e:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005822:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005826:	fd e7 10 4e 	or	lr,lr,r7<<0x4
8000582a:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
8000582e:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005832:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005836:	fd e7 10 2e 	or	lr,lr,r7<<0x2
8000583a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000583e:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005842:	f6 0e 15 06 	lsl	lr,r11,0x6
80005846:	f8 0e 00 0e 	add	lr,r12,lr
8000584a:	2d ce       	sub	lr,-36
8000584c:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000584e:	58 09       	cp.w	r9,0
80005850:	c0 20       	breq	80005854 <tc_configure_interrupts+0x6a>
80005852:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005854:	74 08       	ld.w	r8,r10[0x0]
80005856:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
8000585a:	e0 65 00 80 	mov	r5,128
8000585e:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80005862:	74 08       	ld.w	r8,r10[0x0]
80005864:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005868:	f9 b4 00 40 	moveq	r4,64
8000586c:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80005870:	74 08       	ld.w	r8,r10[0x0]
80005872:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80005876:	f9 b3 00 20 	moveq	r3,32
8000587a:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
8000587e:	74 08       	ld.w	r8,r10[0x0]
80005880:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005884:	f9 b2 00 10 	moveq	r2,16
80005888:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
8000588c:	74 08       	ld.w	r8,r10[0x0]
8000588e:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005892:	f9 b6 00 08 	moveq	r6,8
80005896:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
8000589a:	74 08       	ld.w	r8,r10[0x0]
8000589c:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800058a0:	f9 b7 00 04 	moveq	r7,4
800058a4:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800058a8:	74 08       	ld.w	r8,r10[0x0]
800058aa:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800058ae:	f9 be 00 02 	moveq	lr,2
800058b2:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800058b6:	74 08       	ld.w	r8,r10[0x0]
800058b8:	ec 18 00 01 	eorl	r8,0x1
800058bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800058c0:	eb e8 10 08 	or	r8,r5,r8
800058c4:	08 48       	or	r8,r4
800058c6:	06 48       	or	r8,r3
800058c8:	04 48       	or	r8,r2
800058ca:	0c 48       	or	r8,r6
800058cc:	0e 48       	or	r8,r7
800058ce:	1c 48       	or	r8,lr
800058d0:	f6 0a 15 06 	lsl	r10,r11,0x6
800058d4:	f8 0a 00 0a 	add	r10,r12,r10
800058d8:	2d 8a       	sub	r10,-40
800058da:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800058dc:	a7 6b       	lsl	r11,0x6
800058de:	2e 0b       	sub	r11,-32
800058e0:	16 0c       	add	r12,r11
800058e2:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
800058e4:	58 09       	cp.w	r9,0
800058e6:	c0 31       	brne	800058ec <tc_configure_interrupts+0x102>
800058e8:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800058ec:	d5 03       	csrf	0x10
800058ee:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

800058f2 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800058f2:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800058f4:	f6 08 15 04 	lsl	r8,r11,0x4
800058f8:	14 38       	cp.w	r8,r10
800058fa:	f9 b8 08 10 	movls	r8,16
800058fe:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005902:	f0 0b 02 4b 	mul	r11,r8,r11
80005906:	f6 09 16 01 	lsr	r9,r11,0x1
8000590a:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000590e:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005912:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005916:	f2 cb 00 01 	sub	r11,r9,1
8000591a:	e0 4b ff fe 	cp.w	r11,65534
8000591e:	e0 88 00 03 	brls	80005924 <usart_set_async_baudrate+0x32>
80005922:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005924:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005926:	e8 6e 00 00 	mov	lr,524288
8000592a:	59 08       	cp.w	r8,16
8000592c:	fc 08 17 10 	movne	r8,lr
80005930:	f9 b8 00 00 	moveq	r8,0
80005934:	e4 1b ff f7 	andh	r11,0xfff7
80005938:	e0 1b fe cf 	andl	r11,0xfecf
8000593c:	16 48       	or	r8,r11
8000593e:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005940:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005944:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005948:	99 89       	st.w	r12[0x20],r9
8000594a:	d8 0a       	popm	pc,r12=0

8000594c <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000594c:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000594e:	e2 18 00 02 	andl	r8,0x2,COH
80005952:	c0 31       	brne	80005958 <usart_write_char+0xc>
80005954:	30 2c       	mov	r12,2
80005956:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005958:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000595c:	99 7b       	st.w	r12[0x1c],r11
8000595e:	5e fd       	retal	0

80005960 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005960:	eb cd 40 e0 	pushm	r5-r7,lr
80005964:	18 96       	mov	r6,r12
80005966:	16 95       	mov	r5,r11
80005968:	e0 67 27 0f 	mov	r7,9999
8000596c:	c0 68       	rjmp	80005978 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000596e:	58 07       	cp.w	r7,0
80005970:	c0 31       	brne	80005976 <usart_putchar+0x16>
80005972:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005976:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005978:	0a 9b       	mov	r11,r5
8000597a:	0c 9c       	mov	r12,r6
8000597c:	f0 1f 00 03 	mcall	80005988 <usart_putchar+0x28>
80005980:	cf 71       	brne	8000596e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005986:	00 00       	add	r0,r0
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	59 4c       	cp.w	r12,20

8000598c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000598c:	78 58       	ld.w	r8,r12[0x14]
8000598e:	e2 18 00 e0 	andl	r8,0xe0,COH
80005992:	c0 30       	breq	80005998 <usart_read_char+0xc>
80005994:	30 4c       	mov	r12,4
80005996:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005998:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000599a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000599e:	c0 31       	brne	800059a4 <usart_read_char+0x18>
800059a0:	30 3c       	mov	r12,3
800059a2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800059a4:	78 68       	ld.w	r8,r12[0x18]
800059a6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800059aa:	97 08       	st.w	r11[0x0],r8
800059ac:	5e fd       	retal	0
800059ae:	d7 03       	nop

800059b0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800059b0:	eb cd 40 c0 	pushm	r6-r7,lr
800059b4:	20 1d       	sub	sp,4
800059b6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800059b8:	1a 97       	mov	r7,sp
800059ba:	1a 9b       	mov	r11,sp
800059bc:	0c 9c       	mov	r12,r6
800059be:	f0 1f 00 07 	mcall	800059d8 <usart_getchar+0x28>
800059c2:	58 3c       	cp.w	r12,3
800059c4:	cf b0       	breq	800059ba <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800059c6:	58 4c       	cp.w	r12,4
800059c8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800059cc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800059d0:	2f fd       	sub	sp,-4
800059d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059d6:	00 00       	add	r0,r0
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	59 8c       	cp.w	r12,24

800059dc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800059dc:	eb cd 40 c0 	pushm	r6-r7,lr
800059e0:	18 96       	mov	r6,r12
800059e2:	16 97       	mov	r7,r11
  while (*string != '\0')
800059e4:	17 8b       	ld.ub	r11,r11[0x0]
800059e6:	58 0b       	cp.w	r11,0
800059e8:	c0 80       	breq	800059f8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800059ea:	2f f7       	sub	r7,-1
800059ec:	0c 9c       	mov	r12,r6
800059ee:	f0 1f 00 04 	mcall	800059fc <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800059f2:	0f 8b       	ld.ub	r11,r7[0x0]
800059f4:	58 0b       	cp.w	r11,0
800059f6:	cf a1       	brne	800059ea <usart_write_line+0xe>
800059f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	59 60       	cp.w	r0,22

80005a00 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005a00:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005a04:	e6 18 00 01 	andh	r8,0x1,COH
80005a08:	c0 71       	brne	80005a16 <usart_reset+0x16>
80005a0a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005a0c:	3f f8       	mov	r8,-1
80005a0e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a10:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005a12:	d5 03       	csrf	0x10
80005a14:	c0 48       	rjmp	80005a1c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005a16:	3f f8       	mov	r8,-1
80005a18:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a1a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005a1c:	30 08       	mov	r8,0
80005a1e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005a20:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005a22:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005a24:	ea 68 61 0c 	mov	r8,680204
80005a28:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005a2a:	5e fc       	retal	r12

80005a2c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005a2c:	eb cd 40 e0 	pushm	r5-r7,lr
80005a30:	18 96       	mov	r6,r12
80005a32:	16 97       	mov	r7,r11
80005a34:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005a36:	f0 1f 00 2f 	mcall	80005af0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005a3a:	58 07       	cp.w	r7,0
80005a3c:	c5 80       	breq	80005aec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005a3e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a40:	30 49       	mov	r9,4
80005a42:	f2 08 18 00 	cp.b	r8,r9
80005a46:	e0 88 00 53 	brls	80005aec <usart_init_rs232+0xc0>
80005a4a:	30 99       	mov	r9,9
80005a4c:	f2 08 18 00 	cp.b	r8,r9
80005a50:	e0 8b 00 4e 	brhi	80005aec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005a54:	0f d9       	ld.ub	r9,r7[0x5]
80005a56:	30 78       	mov	r8,7
80005a58:	f0 09 18 00 	cp.b	r9,r8
80005a5c:	e0 8b 00 48 	brhi	80005aec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005a60:	8e 39       	ld.sh	r9,r7[0x6]
80005a62:	e0 68 01 01 	mov	r8,257
80005a66:	f0 09 19 00 	cp.h	r9,r8
80005a6a:	e0 8b 00 41 	brhi	80005aec <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005a6e:	ef 39 00 08 	ld.ub	r9,r7[8]
80005a72:	30 38       	mov	r8,3
80005a74:	f0 09 18 00 	cp.b	r9,r8
80005a78:	e0 8b 00 3a 	brhi	80005aec <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005a7c:	0a 9a       	mov	r10,r5
80005a7e:	6e 0b       	ld.w	r11,r7[0x0]
80005a80:	0c 9c       	mov	r12,r6
80005a82:	f0 1f 00 1d 	mcall	80005af4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a86:	58 1c       	cp.w	r12,1
80005a88:	c3 20       	breq	80005aec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005a8a:	0f c8       	ld.ub	r8,r7[0x4]
80005a8c:	30 99       	mov	r9,9
80005a8e:	f2 08 18 00 	cp.b	r8,r9
80005a92:	c0 51       	brne	80005a9c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005a94:	6c 18       	ld.w	r8,r6[0x4]
80005a96:	b1 b8       	sbr	r8,0x11
80005a98:	8d 18       	st.w	r6[0x4],r8
80005a9a:	c0 68       	rjmp	80005aa6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005a9c:	6c 19       	ld.w	r9,r6[0x4]
80005a9e:	20 58       	sub	r8,5
80005aa0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005aa4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005aa6:	6c 19       	ld.w	r9,r6[0x4]
80005aa8:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005aac:	0f d8       	ld.ub	r8,r7[0x5]
80005aae:	a9 78       	lsl	r8,0x9
80005ab0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ab4:	12 48       	or	r8,r9
80005ab6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005ab8:	8e 38       	ld.sh	r8,r7[0x6]
80005aba:	30 29       	mov	r9,2
80005abc:	f2 08 19 00 	cp.h	r8,r9
80005ac0:	e0 88 00 09 	brls	80005ad2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005ac4:	6c 18       	ld.w	r8,r6[0x4]
80005ac6:	ad b8       	sbr	r8,0xd
80005ac8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005aca:	8e b8       	ld.uh	r8,r7[0x6]
80005acc:	20 28       	sub	r8,2
80005ace:	8d a8       	st.w	r6[0x28],r8
80005ad0:	c0 68       	rjmp	80005adc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005ad2:	6c 19       	ld.w	r9,r6[0x4]
80005ad4:	5c 78       	castu.h	r8
80005ad6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005ada:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005adc:	6c 18       	ld.w	r8,r6[0x4]
80005ade:	e0 18 ff f0 	andl	r8,0xfff0
80005ae2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005ae4:	35 08       	mov	r8,80
80005ae6:	8d 08       	st.w	r6[0x0],r8
80005ae8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005aec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	5a 00       	cp.w	r0,-32
80005af4:	80 00       	ld.sh	r0,r0[0x0]
80005af6:	58 f2       	cp.w	r2,15

80005af8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005af8:	f8 c8 ff f8 	sub	r8,r12,-8
80005afc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005afe:	3f f9       	mov	r9,-1
80005b00:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005b02:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005b04:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005b06:	30 08       	mov	r8,0
80005b08:	99 08       	st.w	r12[0x0],r8
}
80005b0a:	5e fc       	retal	r12

80005b0c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005b0c:	30 08       	mov	r8,0
80005b0e:	99 48       	st.w	r12[0x10],r8
}
80005b10:	5e fc       	retal	r12

80005b12 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005b12:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005b14:	70 19       	ld.w	r9,r8[0x4]
80005b16:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005b18:	78 19       	ld.w	r9,r12[0x4]
80005b1a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b1c:	70 19       	ld.w	r9,r8[0x4]
80005b1e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b20:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005b22:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b24:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b26:	78 08       	ld.w	r8,r12[0x0]
80005b28:	2f f8       	sub	r8,-1
80005b2a:	99 08       	st.w	r12[0x0],r8
}
80005b2c:	5e fc       	retal	r12

80005b2e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005b2e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005b30:	5b fa       	cp.w	r10,-1
80005b32:	c0 31       	brne	80005b38 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005b34:	78 48       	ld.w	r8,r12[0x10]
80005b36:	c0 c8       	rjmp	80005b4e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005b38:	f8 c8 ff f8 	sub	r8,r12,-8
80005b3c:	70 19       	ld.w	r9,r8[0x4]
80005b3e:	72 09       	ld.w	r9,r9[0x0]
80005b40:	12 3a       	cp.w	r10,r9
80005b42:	c0 63       	brcs	80005b4e <vListInsert+0x20>
80005b44:	70 18       	ld.w	r8,r8[0x4]
80005b46:	70 19       	ld.w	r9,r8[0x4]
80005b48:	72 09       	ld.w	r9,r9[0x0]
80005b4a:	12 3a       	cp.w	r10,r9
80005b4c:	cf c2       	brcc	80005b44 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005b4e:	70 19       	ld.w	r9,r8[0x4]
80005b50:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b52:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005b54:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b56:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b58:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b5a:	78 08       	ld.w	r8,r12[0x0]
80005b5c:	2f f8       	sub	r8,-1
80005b5e:	99 08       	st.w	r12[0x0],r8
}
80005b60:	5e fc       	retal	r12

80005b62 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005b62:	78 18       	ld.w	r8,r12[0x4]
80005b64:	78 29       	ld.w	r9,r12[0x8]
80005b66:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005b68:	78 28       	ld.w	r8,r12[0x8]
80005b6a:	78 19       	ld.w	r9,r12[0x4]
80005b6c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005b6e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005b70:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005b72:	18 39       	cp.w	r9,r12
80005b74:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005b78:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005b7c:	30 09       	mov	r9,0
80005b7e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005b80:	70 09       	ld.w	r9,r8[0x0]
80005b82:	20 19       	sub	r9,1
80005b84:	91 09       	st.w	r8[0x0],r9
}
80005b86:	5e fc       	retal	r12

80005b88 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005b88:	e0 68 08 08 	mov	r8,2056
80005b8c:	ea 18 08 08 	orh	r8,0x808
80005b90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b92:	e0 68 09 09 	mov	r8,2313
80005b96:	ea 18 09 09 	orh	r8,0x909
80005b9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005b9c:	e0 68 0a 0a 	mov	r8,2570
80005ba0:	ea 18 0a 0a 	orh	r8,0xa0a
80005ba4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005ba6:	e0 68 0b 0b 	mov	r8,2827
80005baa:	ea 18 0b 0b 	orh	r8,0xb0b
80005bae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005bb0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005bb2:	e0 68 be ef 	mov	r8,48879
80005bb6:	ea 18 de ad 	orh	r8,0xdead
80005bba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005bbc:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005bbe:	fc 18 00 40 	movh	r8,0x40
80005bc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005bc4:	e0 68 00 ff 	mov	r8,255
80005bc8:	ea 18 ff 00 	orh	r8,0xff00
80005bcc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005bce:	e0 68 01 01 	mov	r8,257
80005bd2:	ea 18 01 01 	orh	r8,0x101
80005bd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005bd8:	e0 68 02 02 	mov	r8,514
80005bdc:	ea 18 02 02 	orh	r8,0x202
80005be0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005be2:	e0 68 03 03 	mov	r8,771
80005be6:	ea 18 03 03 	orh	r8,0x303
80005bea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005bec:	e0 68 04 04 	mov	r8,1028
80005bf0:	ea 18 04 04 	orh	r8,0x404
80005bf4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005bf6:	e0 68 05 05 	mov	r8,1285
80005bfa:	ea 18 05 05 	orh	r8,0x505
80005bfe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005c00:	e0 68 06 06 	mov	r8,1542
80005c04:	ea 18 06 06 	orh	r8,0x606
80005c08:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005c0a:	e0 68 07 07 	mov	r8,1799
80005c0e:	ea 18 07 07 	orh	r8,0x707
80005c12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005c14:	30 08       	mov	r8,0
80005c16:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005c18:	5e fc       	retal	r12
80005c1a:	d7 03       	nop

80005c1c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005c1c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005c1e:	48 38       	lddpc	r8,80005c28 <vPortEnterCritical+0xc>
80005c20:	70 09       	ld.w	r9,r8[0x0]
80005c22:	2f f9       	sub	r9,-1
80005c24:	91 09       	st.w	r8[0x0],r9
}
80005c26:	5e fc       	retal	r12
80005c28:	00 00       	add	r0,r0
80005c2a:	05 34       	ld.ub	r4,r2++

80005c2c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005c2c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005c2e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005c30:	30 0a       	mov	r10,0
80005c32:	14 9b       	mov	r11,r10
80005c34:	49 2c       	lddpc	r12,80005c7c <xPortStartScheduler+0x50>
80005c36:	f0 1f 00 13 	mcall	80005c80 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005c3a:	e0 68 5d c0 	mov	r8,24000
80005c3e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005c42:	30 08       	mov	r8,0
80005c44:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005c48:	e0 68 0c dc 	mov	r8,3292
80005c4c:	ea 18 00 00 	orh	r8,0x0
80005c50:	70 00       	ld.w	r0,r8[0x0]
80005c52:	60 0d       	ld.w	sp,r0[0x0]
80005c54:	1b 00       	ld.w	r0,sp++
80005c56:	e0 68 05 34 	mov	r8,1332
80005c5a:	ea 18 00 00 	orh	r8,0x0
80005c5e:	91 00       	st.w	r8[0x0],r0
80005c60:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c64:	2f ed       	sub	sp,-8
80005c66:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005c6a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005c6e:	e3 b0 00 00 	mtsr	0x0,r0
80005c72:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005c76:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005c7a:	d8 0a       	popm	pc,r12=0
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	5d 48       	*unknown*
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	54 10       	stdsp	sp[0x104],r0

80005c84 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005c84:	20 6d       	sub	sp,24
80005c86:	eb cd 00 ff 	pushm	r0-r7
80005c8a:	fa c7 ff c0 	sub	r7,sp,-64
80005c8e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c92:	ef 40 ff e0 	st.w	r7[-32],r0
80005c96:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005c9a:	ef 40 ff e4 	st.w	r7[-28],r0
80005c9e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005ca2:	e0 68 05 34 	mov	r8,1332
80005ca6:	ea 18 00 00 	orh	r8,0x0
80005caa:	70 00       	ld.w	r0,r8[0x0]
80005cac:	1a d0       	st.w	--sp,r0
80005cae:	f0 1f 00 1a 	mcall	80005d14 <LABEL_RET_SCALL_263+0x14>
80005cb2:	e0 68 0c dc 	mov	r8,3292
80005cb6:	ea 18 00 00 	orh	r8,0x0
80005cba:	70 00       	ld.w	r0,r8[0x0]
80005cbc:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005cbe:	f0 1f 00 17 	mcall	80005d18 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005cc2:	e0 68 0c dc 	mov	r8,3292
80005cc6:	ea 18 00 00 	orh	r8,0x0
80005cca:	70 00       	ld.w	r0,r8[0x0]
80005ccc:	60 0d       	ld.w	sp,r0[0x0]
80005cce:	1b 00       	ld.w	r0,sp++
80005cd0:	e0 68 05 34 	mov	r8,1332
80005cd4:	ea 18 00 00 	orh	r8,0x0
80005cd8:	91 00       	st.w	r8[0x0],r0
80005cda:	fa c7 ff d8 	sub	r7,sp,-40
80005cde:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005ce2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005ce6:	e0 61 05 34 	mov	r1,1332
80005cea:	ea 11 00 00 	orh	r1,0x0
80005cee:	62 02       	ld.w	r2,r1[0x0]
80005cf0:	58 02       	cp.w	r2,0
80005cf2:	c0 70       	breq	80005d00 <LABEL_RET_SCALL_263>
80005cf4:	e4 c2 00 01 	sub	r2,r2,1
80005cf8:	83 02       	st.w	r1[0x0],r2
80005cfa:	58 02       	cp.w	r2,0
80005cfc:	c0 21       	brne	80005d00 <LABEL_RET_SCALL_263>
80005cfe:	b1 c0       	cbr	r0,0x10

80005d00 <LABEL_RET_SCALL_263>:
80005d00:	ef 40 ff f8 	st.w	r7[-8],r0
80005d04:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005d08:	ef 40 ff fc 	st.w	r7[-4],r0
80005d0c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d10:	2f ad       	sub	sp,-24
80005d12:	d6 13       	rets
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	5c 1c       	scr	r12
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	63 60       	ld.w	r0,r1[0x58]

80005d1c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005d1c:	e1 b8 00 43 	mfsr	r8,0x10c
80005d20:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005d24:	5e fc       	retal	r12
80005d26:	d7 03       	nop

80005d28 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d28:	48 78       	lddpc	r8,80005d44 <vPortExitCritical+0x1c>
80005d2a:	70 08       	ld.w	r8,r8[0x0]
80005d2c:	58 08       	cp.w	r8,0
80005d2e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005d30:	48 58       	lddpc	r8,80005d44 <vPortExitCritical+0x1c>
80005d32:	70 09       	ld.w	r9,r8[0x0]
80005d34:	20 19       	sub	r9,1
80005d36:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005d38:	70 08       	ld.w	r8,r8[0x0]
80005d3a:	58 08       	cp.w	r8,0
80005d3c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005d3e:	d5 03       	csrf	0x10
80005d40:	5e fc       	retal	r12
80005d42:	00 00       	add	r0,r0
80005d44:	00 00       	add	r0,r0
80005d46:	05 34       	ld.ub	r4,r2++

80005d48 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005d48:	eb cd 00 ff 	pushm	r0-r7
80005d4c:	e0 68 05 34 	mov	r8,1332
80005d50:	ea 18 00 00 	orh	r8,0x0
80005d54:	70 00       	ld.w	r0,r8[0x0]
80005d56:	1a d0       	st.w	--sp,r0
80005d58:	7a 90       	ld.w	r0,sp[0x24]
80005d5a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d5e:	58 10       	cp.w	r0,1
80005d60:	e0 8b 00 08 	brhi	80005d70 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005d64:	e0 68 0c dc 	mov	r8,3292
80005d68:	ea 18 00 00 	orh	r8,0x0
80005d6c:	70 00       	ld.w	r0,r8[0x0]
80005d6e:	81 0d       	st.w	r0[0x0],sp

80005d70 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005d70:	f0 1f 00 12 	mcall	80005db8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005d74:	f0 1f 00 12 	mcall	80005dbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005d78:	f0 1f 00 12 	mcall	80005dc0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005d7c:	f0 1f 00 12 	mcall	80005dc4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005d80:	7a 90       	ld.w	r0,sp[0x24]
80005d82:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d86:	58 10       	cp.w	r0,1
80005d88:	e0 8b 00 0e 	brhi	80005da4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d8c:	f0 1f 00 0c 	mcall	80005dbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d90:	f0 1f 00 0e 	mcall	80005dc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005d94:	f0 1f 00 0c 	mcall	80005dc4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005d98:	e0 68 0c dc 	mov	r8,3292
80005d9c:	ea 18 00 00 	orh	r8,0x0
80005da0:	70 00       	ld.w	r0,r8[0x0]
80005da2:	60 0d       	ld.w	sp,r0[0x0]

80005da4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005da4:	1b 00       	ld.w	r0,sp++
80005da6:	e0 68 05 34 	mov	r8,1332
80005daa:	ea 18 00 00 	orh	r8,0x0
80005dae:	91 00       	st.w	r8[0x0],r0
80005db0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005db4:	d6 03       	rete
80005db6:	00 00       	add	r0,r0
80005db8:	80 00       	ld.sh	r0,r0[0x0]
80005dba:	5d 1c       	icall	r12
80005dbc:	80 00       	ld.sh	r0,r0[0x0]
80005dbe:	5c 1c       	scr	r12
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	65 64       	ld.w	r4,r2[0x58]
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	5d 28       	mustr	r8
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	63 60       	ld.w	r0,r1[0x58]

80005dcc <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005dcc:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005dce:	f0 1f 00 02 	mcall	80005dd4 <__malloc_lock+0x8>
}
80005dd2:	d8 02       	popm	pc
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	63 50       	ld.w	r0,r1[0x54]

80005dd8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005dd8:	d4 01       	pushm	lr
	xTaskResumeAll();
80005dda:	f0 1f 00 02 	mcall	80005de0 <__malloc_unlock+0x8>
}
80005dde:	d8 02       	popm	pc
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	67 0c       	ld.w	r12,r3[0x40]

80005de4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005de4:	d4 21       	pushm	r4-r7,lr
80005de6:	16 95       	mov	r5,r11
80005de8:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005dea:	58 0c       	cp.w	r12,0
80005dec:	c0 30       	breq	80005df2 <_read+0xe>
80005dee:	3f f7       	mov	r7,-1
80005df0:	c1 48       	rjmp	80005e18 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005df2:	58 0a       	cp.w	r10,0
80005df4:	e0 89 00 04 	brgt	80005dfc <_read+0x18>
80005df8:	30 07       	mov	r7,0
80005dfa:	c0 f8       	rjmp	80005e18 <_read+0x34>
80005dfc:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005dfe:	48 84       	lddpc	r4,80005e1c <_read+0x38>
80005e00:	68 0c       	ld.w	r12,r4[0x0]
80005e02:	f0 1f 00 08 	mcall	80005e20 <_read+0x3c>
    if (c < 0)
80005e06:	c0 95       	brlt	80005e18 <_read+0x34>
      break;

    *ptr++ = c;
80005e08:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005e0c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005e0e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005e12:	58 08       	cp.w	r8,0
80005e14:	fe 99 ff f6 	brgt	80005e00 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005e18:	0e 9c       	mov	r12,r7
80005e1a:	d8 22       	popm	r4-r7,pc
80005e1c:	00 00       	add	r0,r0
80005e1e:	63 90       	ld.w	r0,r1[0x64]
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	59 b0       	cp.w	r0,27

80005e24 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005e24:	d4 21       	pushm	r4-r7,lr
80005e26:	16 95       	mov	r5,r11
80005e28:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e2a:	20 1c       	sub	r12,1
80005e2c:	58 2c       	cp.w	r12,2
80005e2e:	e0 8b 00 12 	brhi	80005e52 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e32:	58 0a       	cp.w	r10,0
80005e34:	c0 31       	brne	80005e3a <_write+0x16>
80005e36:	30 07       	mov	r7,0
80005e38:	c0 e8       	rjmp	80005e54 <_write+0x30>
80005e3a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005e3c:	48 74       	lddpc	r4,80005e58 <_write+0x34>
80005e3e:	68 0c       	ld.w	r12,r4[0x0]
80005e40:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005e44:	f0 1f 00 06 	mcall	80005e5c <_write+0x38>
80005e48:	c0 55       	brlt	80005e52 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005e4a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e4c:	0e 36       	cp.w	r6,r7
80005e4e:	cf 81       	brne	80005e3e <_write+0x1a>
80005e50:	c0 28       	rjmp	80005e54 <_write+0x30>
80005e52:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005e54:	0e 9c       	mov	r12,r7
80005e56:	d8 22       	popm	r4-r7,pc
80005e58:	00 00       	add	r0,r0
80005e5a:	63 90       	ld.w	r0,r1[0x64]
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	59 60       	cp.w	r0,22

80005e60 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005e60:	eb cd 40 80 	pushm	r7,lr
80005e64:	18 97       	mov	r7,r12
	if( pv )
80005e66:	58 0c       	cp.w	r12,0
80005e68:	c0 80       	breq	80005e78 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005e6a:	f0 1f 00 05 	mcall	80005e7c <vPortFree+0x1c>
		{
			free( pv );
80005e6e:	0e 9c       	mov	r12,r7
80005e70:	f0 1f 00 04 	mcall	80005e80 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005e74:	f0 1f 00 04 	mcall	80005e84 <vPortFree+0x24>
80005e78:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	63 50       	ld.w	r0,r1[0x54]
80005e80:	80 00       	ld.sh	r0,r0[0x0]
80005e82:	72 b0       	ld.w	r0,r9[0x2c]
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	67 0c       	ld.w	r12,r3[0x40]

80005e88 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005e88:	eb cd 40 80 	pushm	r7,lr
80005e8c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e8e:	f0 1f 00 06 	mcall	80005ea4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e92:	0e 9c       	mov	r12,r7
80005e94:	f0 1f 00 05 	mcall	80005ea8 <pvPortMalloc+0x20>
80005e98:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005e9a:	f0 1f 00 05 	mcall	80005eac <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005e9e:	0e 9c       	mov	r12,r7
80005ea0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	63 50       	ld.w	r0,r1[0x54]
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	72 c0       	ld.w	r0,r9[0x30]
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	67 0c       	ld.w	r12,r3[0x40]

80005eb0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005eb0:	d4 01       	pushm	lr
80005eb2:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005eb4:	78 09       	ld.w	r9,r12[0x0]
80005eb6:	58 09       	cp.w	r9,0
80005eb8:	c1 10       	breq	80005eda <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005eba:	78 3a       	ld.w	r10,r12[0xc]
80005ebc:	79 09       	ld.w	r9,r12[0x40]
80005ebe:	f4 09 00 09 	add	r9,r10,r9
80005ec2:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005ec4:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005ec6:	14 39       	cp.w	r9,r10
80005ec8:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005ecc:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005ed0:	79 0a       	ld.w	r10,r12[0x40]
80005ed2:	78 3b       	ld.w	r11,r12[0xc]
80005ed4:	10 9c       	mov	r12,r8
80005ed6:	f0 1f 00 02 	mcall	80005edc <prvCopyDataFromQueue+0x2c>
80005eda:	d8 02       	popm	pc
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	77 2e       	ld.w	lr,r11[0x48]

80005ee0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005ee0:	eb cd 40 c0 	pushm	r6-r7,lr
80005ee4:	18 97       	mov	r7,r12
80005ee6:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005ee8:	78 e8       	ld.w	r8,r12[0x38]
80005eea:	58 08       	cp.w	r8,0
80005eec:	c0 31       	brne	80005ef2 <xQueueReceiveFromISR+0x12>
80005eee:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005ef2:	f0 1f 00 0e 	mcall	80005f28 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005ef6:	6e e8       	ld.w	r8,r7[0x38]
80005ef8:	20 18       	sub	r8,1
80005efa:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005efc:	6f 18       	ld.w	r8,r7[0x44]
80005efe:	5b f8       	cp.w	r8,-1
80005f00:	c0 d1       	brne	80005f1a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f02:	6e 48       	ld.w	r8,r7[0x10]
80005f04:	58 08       	cp.w	r8,0
80005f06:	c0 f0       	breq	80005f24 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f08:	ee cc ff f0 	sub	r12,r7,-16
80005f0c:	f0 1f 00 08 	mcall	80005f2c <xQueueReceiveFromISR+0x4c>
80005f10:	c0 a0       	breq	80005f24 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005f12:	30 1c       	mov	r12,1
80005f14:	8d 0c       	st.w	r6[0x0],r12
80005f16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005f1a:	2f f8       	sub	r8,-1
80005f1c:	ef 48 00 44 	st.w	r7[68],r8
80005f20:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f24:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f28:	80 00       	ld.sh	r0,r0[0x0]
80005f2a:	5e b0       	rethi	r0
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	64 e8       	ld.w	r8,r2[0x38]

80005f30 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005f30:	eb cd 40 c0 	pushm	r6-r7,lr
80005f34:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005f36:	f0 1f 00 23 	mcall	80005fc0 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f3a:	6f 28       	ld.w	r8,r7[0x48]
80005f3c:	58 08       	cp.w	r8,0
80005f3e:	e0 8a 00 18 	brle	80005f6e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f42:	6e 98       	ld.w	r8,r7[0x24]
80005f44:	58 08       	cp.w	r8,0
80005f46:	c1 40       	breq	80005f6e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f48:	ee c6 ff dc 	sub	r6,r7,-36
80005f4c:	c0 48       	rjmp	80005f54 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f4e:	6e 98       	ld.w	r8,r7[0x24]
80005f50:	58 08       	cp.w	r8,0
80005f52:	c0 e0       	breq	80005f6e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f54:	0c 9c       	mov	r12,r6
80005f56:	f0 1f 00 1c 	mcall	80005fc4 <prvUnlockQueue+0x94>
80005f5a:	c0 30       	breq	80005f60 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005f5c:	f0 1f 00 1b 	mcall	80005fc8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005f60:	6f 28       	ld.w	r8,r7[0x48]
80005f62:	20 18       	sub	r8,1
80005f64:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f68:	58 08       	cp.w	r8,0
80005f6a:	fe 99 ff f2 	brgt	80005f4e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005f6e:	3f f8       	mov	r8,-1
80005f70:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005f74:	f0 1f 00 16 	mcall	80005fcc <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005f78:	f0 1f 00 12 	mcall	80005fc0 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f7c:	6f 18       	ld.w	r8,r7[0x44]
80005f7e:	58 08       	cp.w	r8,0
80005f80:	e0 8a 00 18 	brle	80005fb0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f84:	6e 48       	ld.w	r8,r7[0x10]
80005f86:	58 08       	cp.w	r8,0
80005f88:	c1 40       	breq	80005fb0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f8a:	ee c6 ff f0 	sub	r6,r7,-16
80005f8e:	c0 48       	rjmp	80005f96 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f90:	6e 48       	ld.w	r8,r7[0x10]
80005f92:	58 08       	cp.w	r8,0
80005f94:	c0 e0       	breq	80005fb0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f96:	0c 9c       	mov	r12,r6
80005f98:	f0 1f 00 0b 	mcall	80005fc4 <prvUnlockQueue+0x94>
80005f9c:	c0 30       	breq	80005fa2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005f9e:	f0 1f 00 0b 	mcall	80005fc8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005fa2:	6f 18       	ld.w	r8,r7[0x44]
80005fa4:	20 18       	sub	r8,1
80005fa6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005faa:	58 08       	cp.w	r8,0
80005fac:	fe 99 ff f2 	brgt	80005f90 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005fb0:	3f f8       	mov	r8,-1
80005fb2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005fb6:	f0 1f 00 06 	mcall	80005fcc <prvUnlockQueue+0x9c>
}
80005fba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fbe:	00 00       	add	r0,r0
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	5c 1c       	scr	r12
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	64 e8       	ld.w	r8,r2[0x38]
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	63 f4       	ld.w	r4,r1[0x7c]
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	5d 28       	mustr	r8

80005fd0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005fd0:	d4 31       	pushm	r0-r7,lr
80005fd2:	20 5d       	sub	sp,20
80005fd4:	18 97       	mov	r7,r12
80005fd6:	50 0b       	stdsp	sp[0x0],r11
80005fd8:	50 2a       	stdsp	sp[0x8],r10
80005fda:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005fdc:	f8 c2 ff dc 	sub	r2,r12,-36
80005fe0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fe2:	fa c4 ff f4 	sub	r4,sp,-12
80005fe6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005fe8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005fea:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005fee:	f0 1f 00 3e 	mcall	800060e4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005ff2:	6e e8       	ld.w	r8,r7[0x38]
80005ff4:	58 08       	cp.w	r8,0
80005ff6:	c2 a0       	breq	8000604a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005ff8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005ffa:	40 0b       	lddsp	r11,sp[0x0]
80005ffc:	0e 9c       	mov	r12,r7
80005ffe:	f0 1f 00 3b 	mcall	800060e8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006002:	40 18       	lddsp	r8,sp[0x4]
80006004:	58 08       	cp.w	r8,0
80006006:	c1 51       	brne	80006030 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006008:	6e e8       	ld.w	r8,r7[0x38]
8000600a:	20 18       	sub	r8,1
8000600c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000600e:	6e 08       	ld.w	r8,r7[0x0]
80006010:	58 08       	cp.w	r8,0
80006012:	c0 41       	brne	8000601a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006014:	f0 1f 00 36 	mcall	800060ec <xQueueGenericReceive+0x11c>
80006018:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000601a:	6e 48       	ld.w	r8,r7[0x10]
8000601c:	58 08       	cp.w	r8,0
8000601e:	c1 20       	breq	80006042 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006020:	ee cc ff f0 	sub	r12,r7,-16
80006024:	f0 1f 00 33 	mcall	800060f0 <xQueueGenericReceive+0x120>
80006028:	58 1c       	cp.w	r12,1
8000602a:	c0 c1       	brne	80006042 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000602c:	d7 33       	scall
8000602e:	c0 a8       	rjmp	80006042 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006030:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006032:	6e 98       	ld.w	r8,r7[0x24]
80006034:	58 08       	cp.w	r8,0
80006036:	c0 60       	breq	80006042 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006038:	04 9c       	mov	r12,r2
8000603a:	f0 1f 00 2e 	mcall	800060f0 <xQueueGenericReceive+0x120>
8000603e:	c0 20       	breq	80006042 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006040:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006042:	f0 1f 00 2d 	mcall	800060f4 <xQueueGenericReceive+0x124>
80006046:	30 1c       	mov	r12,1
				return pdPASS;
80006048:	c4 c8       	rjmp	800060e0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000604a:	40 28       	lddsp	r8,sp[0x8]
8000604c:	58 08       	cp.w	r8,0
8000604e:	c0 51       	brne	80006058 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006050:	f0 1f 00 29 	mcall	800060f4 <xQueueGenericReceive+0x124>
80006054:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006056:	c4 58       	rjmp	800060e0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006058:	58 05       	cp.w	r5,0
8000605a:	c0 51       	brne	80006064 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000605c:	08 9c       	mov	r12,r4
8000605e:	f0 1f 00 27 	mcall	800060f8 <xQueueGenericReceive+0x128>
80006062:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006064:	f0 1f 00 24 	mcall	800060f4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006068:	f0 1f 00 25 	mcall	800060fc <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000606c:	f0 1f 00 1e 	mcall	800060e4 <xQueueGenericReceive+0x114>
80006070:	6f 18       	ld.w	r8,r7[0x44]
80006072:	5b f8       	cp.w	r8,-1
80006074:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006078:	6f 28       	ld.w	r8,r7[0x48]
8000607a:	5b f8       	cp.w	r8,-1
8000607c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006080:	f0 1f 00 1d 	mcall	800060f4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006084:	06 9b       	mov	r11,r3
80006086:	08 9c       	mov	r12,r4
80006088:	f0 1f 00 1e 	mcall	80006100 <xQueueGenericReceive+0x130>
8000608c:	c2 41       	brne	800060d4 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000608e:	f0 1f 00 16 	mcall	800060e4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006092:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006094:	f0 1f 00 18 	mcall	800060f4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006098:	58 06       	cp.w	r6,0
8000609a:	c1 71       	brne	800060c8 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000609c:	6e 08       	ld.w	r8,r7[0x0]
8000609e:	58 08       	cp.w	r8,0
800060a0:	c0 81       	brne	800060b0 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800060a2:	f0 1f 00 11 	mcall	800060e4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800060a6:	6e 1c       	ld.w	r12,r7[0x4]
800060a8:	f0 1f 00 17 	mcall	80006104 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800060ac:	f0 1f 00 12 	mcall	800060f4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060b0:	40 2b       	lddsp	r11,sp[0x8]
800060b2:	04 9c       	mov	r12,r2
800060b4:	f0 1f 00 15 	mcall	80006108 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800060b8:	0e 9c       	mov	r12,r7
800060ba:	f0 1f 00 15 	mcall	8000610c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800060be:	f0 1f 00 15 	mcall	80006110 <xQueueGenericReceive+0x140>
800060c2:	c9 61       	brne	80005fee <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800060c4:	d7 33       	scall
800060c6:	c9 4b       	rjmp	80005fee <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800060c8:	0e 9c       	mov	r12,r7
800060ca:	f0 1f 00 11 	mcall	8000610c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800060ce:	f0 1f 00 11 	mcall	80006110 <xQueueGenericReceive+0x140>
800060d2:	c8 eb       	rjmp	80005fee <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800060d4:	0e 9c       	mov	r12,r7
800060d6:	f0 1f 00 0e 	mcall	8000610c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800060da:	f0 1f 00 0e 	mcall	80006110 <xQueueGenericReceive+0x140>
800060de:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800060e0:	2f bd       	sub	sp,-20
800060e2:	d8 32       	popm	r0-r7,pc
800060e4:	80 00       	ld.sh	r0,r0[0x0]
800060e6:	5c 1c       	scr	r12
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	5e b0       	rethi	r0
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	64 00       	ld.w	r0,r2[0x0]
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	64 e8       	ld.w	r8,r2[0x38]
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	5d 28       	mustr	r8
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	63 dc       	ld.w	r12,r1[0x74]
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	63 50       	ld.w	r0,r1[0x54]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	66 78       	ld.w	r8,r3[0x1c]
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	64 64       	ld.w	r4,r2[0x18]
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	68 d0       	ld.w	r0,r4[0x34]
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	5f 30       	srlo	r0
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	67 0c       	ld.w	r12,r3[0x40]

80006114 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006114:	eb cd 40 80 	pushm	r7,lr
80006118:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000611a:	79 08       	ld.w	r8,r12[0x40]
8000611c:	58 08       	cp.w	r8,0
8000611e:	c0 a1       	brne	80006132 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006120:	78 08       	ld.w	r8,r12[0x0]
80006122:	58 08       	cp.w	r8,0
80006124:	c2 b1       	brne	8000617a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006126:	78 1c       	ld.w	r12,r12[0x4]
80006128:	f0 1f 00 17 	mcall	80006184 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000612c:	30 08       	mov	r8,0
8000612e:	8f 18       	st.w	r7[0x4],r8
80006130:	c2 58       	rjmp	8000617a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006132:	58 0a       	cp.w	r10,0
80006134:	c1 01       	brne	80006154 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006136:	10 9a       	mov	r10,r8
80006138:	78 2c       	ld.w	r12,r12[0x8]
8000613a:	f0 1f 00 14 	mcall	80006188 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000613e:	6e 29       	ld.w	r9,r7[0x8]
80006140:	6f 08       	ld.w	r8,r7[0x40]
80006142:	f2 08 00 08 	add	r8,r9,r8
80006146:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006148:	6e 19       	ld.w	r9,r7[0x4]
8000614a:	12 38       	cp.w	r8,r9
8000614c:	c1 73       	brcs	8000617a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000614e:	6e 08       	ld.w	r8,r7[0x0]
80006150:	8f 28       	st.w	r7[0x8],r8
80006152:	c1 48       	rjmp	8000617a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006154:	10 9a       	mov	r10,r8
80006156:	78 3c       	ld.w	r12,r12[0xc]
80006158:	f0 1f 00 0c 	mcall	80006188 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000615c:	6f 08       	ld.w	r8,r7[0x40]
8000615e:	6e 39       	ld.w	r9,r7[0xc]
80006160:	f2 08 01 08 	sub	r8,r9,r8
80006164:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006166:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006168:	12 38       	cp.w	r8,r9
8000616a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000616e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006172:	f3 d8 e3 19 	subcs	r9,r9,r8
80006176:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000617a:	6e e8       	ld.w	r8,r7[0x38]
8000617c:	2f f8       	sub	r8,-1
8000617e:	8f e8       	st.w	r7[0x38],r8
}
80006180:	e3 cd 80 80 	ldm	sp++,r7,pc
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	64 0c       	ld.w	r12,r2[0x0]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	77 2e       	ld.w	lr,r11[0x48]

8000618c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000618c:	eb cd 40 c0 	pushm	r6-r7,lr
80006190:	18 97       	mov	r7,r12
80006192:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006194:	78 ec       	ld.w	r12,r12[0x38]
80006196:	6e f8       	ld.w	r8,r7[0x3c]
80006198:	10 3c       	cp.w	r12,r8
8000619a:	c0 33       	brcs	800061a0 <xQueueGenericSendFromISR+0x14>
8000619c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800061a0:	12 9a       	mov	r10,r9
800061a2:	0e 9c       	mov	r12,r7
800061a4:	f0 1f 00 0c 	mcall	800061d4 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800061a8:	6f 28       	ld.w	r8,r7[0x48]
800061aa:	5b f8       	cp.w	r8,-1
800061ac:	c0 d1       	brne	800061c6 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061ae:	6e 98       	ld.w	r8,r7[0x24]
800061b0:	58 08       	cp.w	r8,0
800061b2:	c0 f0       	breq	800061d0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061b4:	ee cc ff dc 	sub	r12,r7,-36
800061b8:	f0 1f 00 08 	mcall	800061d8 <xQueueGenericSendFromISR+0x4c>
800061bc:	c0 a0       	breq	800061d0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800061be:	30 1c       	mov	r12,1
800061c0:	8d 0c       	st.w	r6[0x0],r12
800061c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800061c6:	2f f8       	sub	r8,-1
800061c8:	ef 48 00 48 	st.w	r7[72],r8
800061cc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	61 14       	ld.w	r4,r0[0x44]
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	64 e8       	ld.w	r8,r2[0x38]

800061dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800061dc:	d4 31       	pushm	r0-r7,lr
800061de:	20 5d       	sub	sp,20
800061e0:	18 97       	mov	r7,r12
800061e2:	50 0b       	stdsp	sp[0x0],r11
800061e4:	50 2a       	stdsp	sp[0x8],r10
800061e6:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061e8:	f8 c0 ff f0 	sub	r0,r12,-16
800061ec:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061ee:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061f2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061f4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800061f8:	f0 1f 00 2f 	mcall	800062b4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800061fc:	6e e9       	ld.w	r9,r7[0x38]
800061fe:	6e f8       	ld.w	r8,r7[0x3c]
80006200:	10 39       	cp.w	r9,r8
80006202:	c1 42       	brcc	8000622a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006204:	40 1a       	lddsp	r10,sp[0x4]
80006206:	40 0b       	lddsp	r11,sp[0x0]
80006208:	0e 9c       	mov	r12,r7
8000620a:	f0 1f 00 2c 	mcall	800062b8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000620e:	6e 98       	ld.w	r8,r7[0x24]
80006210:	58 08       	cp.w	r8,0
80006212:	c0 80       	breq	80006222 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006214:	ee cc ff dc 	sub	r12,r7,-36
80006218:	f0 1f 00 29 	mcall	800062bc <xQueueGenericSend+0xe0>
8000621c:	58 1c       	cp.w	r12,1
8000621e:	c0 21       	brne	80006222 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006220:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006222:	f0 1f 00 28 	mcall	800062c0 <xQueueGenericSend+0xe4>
80006226:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006228:	c4 38       	rjmp	800062ae <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000622a:	40 28       	lddsp	r8,sp[0x8]
8000622c:	58 08       	cp.w	r8,0
8000622e:	c0 51       	brne	80006238 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006230:	f0 1f 00 24 	mcall	800062c0 <xQueueGenericSend+0xe4>
80006234:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006236:	c3 c8       	rjmp	800062ae <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006238:	58 04       	cp.w	r4,0
8000623a:	c0 51       	brne	80006244 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000623c:	06 9c       	mov	r12,r3
8000623e:	f0 1f 00 22 	mcall	800062c4 <xQueueGenericSend+0xe8>
80006242:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006244:	f0 1f 00 1f 	mcall	800062c0 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006248:	f0 1f 00 20 	mcall	800062c8 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000624c:	f0 1f 00 1a 	mcall	800062b4 <xQueueGenericSend+0xd8>
80006250:	6f 18       	ld.w	r8,r7[0x44]
80006252:	5b f8       	cp.w	r8,-1
80006254:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006258:	6f 28       	ld.w	r8,r7[0x48]
8000625a:	5b f8       	cp.w	r8,-1
8000625c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006260:	f0 1f 00 18 	mcall	800062c0 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006264:	04 9b       	mov	r11,r2
80006266:	06 9c       	mov	r12,r3
80006268:	f0 1f 00 19 	mcall	800062cc <xQueueGenericSend+0xf0>
8000626c:	c1 b1       	brne	800062a2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000626e:	f0 1f 00 12 	mcall	800062b4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006272:	6e e5       	ld.w	r5,r7[0x38]
80006274:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006276:	f0 1f 00 13 	mcall	800062c0 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000627a:	0c 35       	cp.w	r5,r6
8000627c:	c0 d1       	brne	80006296 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000627e:	40 2b       	lddsp	r11,sp[0x8]
80006280:	00 9c       	mov	r12,r0
80006282:	f0 1f 00 14 	mcall	800062d0 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006286:	0e 9c       	mov	r12,r7
80006288:	f0 1f 00 13 	mcall	800062d4 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000628c:	f0 1f 00 13 	mcall	800062d8 <xQueueGenericSend+0xfc>
80006290:	cb 41       	brne	800061f8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006292:	d7 33       	scall
80006294:	cb 2b       	rjmp	800061f8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006296:	0e 9c       	mov	r12,r7
80006298:	f0 1f 00 0f 	mcall	800062d4 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000629c:	f0 1f 00 0f 	mcall	800062d8 <xQueueGenericSend+0xfc>
800062a0:	ca cb       	rjmp	800061f8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800062a2:	0e 9c       	mov	r12,r7
800062a4:	f0 1f 00 0c 	mcall	800062d4 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800062a8:	f0 1f 00 0c 	mcall	800062d8 <xQueueGenericSend+0xfc>
800062ac:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800062ae:	2f bd       	sub	sp,-20
800062b0:	d8 32       	popm	r0-r7,pc
800062b2:	00 00       	add	r0,r0
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	5c 1c       	scr	r12
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	61 14       	ld.w	r4,r0[0x44]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	64 e8       	ld.w	r8,r2[0x38]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	5d 28       	mustr	r8
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	63 dc       	ld.w	r12,r1[0x74]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	63 50       	ld.w	r0,r1[0x54]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	66 78       	ld.w	r8,r3[0x1c]
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	68 d0       	ld.w	r0,r4[0x34]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	5f 30       	srlo	r0
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	67 0c       	ld.w	r12,r3[0x40]

800062dc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800062dc:	d4 21       	pushm	r4-r7,lr
800062de:	18 97       	mov	r7,r12
800062e0:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800062e2:	58 0c       	cp.w	r12,0
800062e4:	c2 f0       	breq	80006342 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800062e6:	34 cc       	mov	r12,76
800062e8:	f0 1f 00 17 	mcall	80006344 <xQueueCreate+0x68>
800062ec:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800062ee:	c2 a0       	breq	80006342 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800062f0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800062f4:	e8 cc ff ff 	sub	r12,r4,-1
800062f8:	f0 1f 00 13 	mcall	80006344 <xQueueCreate+0x68>
800062fc:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800062fe:	c1 e0       	breq	8000633a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006300:	f8 04 00 04 	add	r4,r12,r4
80006304:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006306:	30 08       	mov	r8,0
80006308:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000630a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000630c:	ee c8 00 01 	sub	r8,r7,1
80006310:	ad 38       	mul	r8,r6
80006312:	10 0c       	add	r12,r8
80006314:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006316:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006318:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000631c:	3f f8       	mov	r8,-1
8000631e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006322:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006326:	ea cc ff f0 	sub	r12,r5,-16
8000632a:	f0 1f 00 08 	mcall	80006348 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000632e:	ea cc ff dc 	sub	r12,r5,-36
80006332:	f0 1f 00 06 	mcall	80006348 <xQueueCreate+0x6c>
80006336:	0a 9c       	mov	r12,r5
80006338:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000633a:	0a 9c       	mov	r12,r5
8000633c:	f0 1f 00 04 	mcall	8000634c <xQueueCreate+0x70>
80006340:	d8 2a       	popm	r4-r7,pc,r12=0
80006342:	d8 2a       	popm	r4-r7,pc,r12=0
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	5e 88       	retls	r8
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5a f8       	cp.w	r8,-17
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	5e 60       	retmi	r0

80006350 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006350:	48 38       	lddpc	r8,8000635c <vTaskSuspendAll+0xc>
80006352:	70 09       	ld.w	r9,r8[0x0]
80006354:	2f f9       	sub	r9,-1
80006356:	91 09       	st.w	r8[0x0],r9
}
80006358:	5e fc       	retal	r12
8000635a:	00 00       	add	r0,r0
8000635c:	00 00       	add	r0,r0
8000635e:	0d 0c       	ld.w	r12,r6++

80006360 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006360:	49 a8       	lddpc	r8,800063c8 <vTaskSwitchContext+0x68>
80006362:	70 08       	ld.w	r8,r8[0x0]
80006364:	58 08       	cp.w	r8,0
80006366:	c0 b1       	brne	8000637c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006368:	49 98       	lddpc	r8,800063cc <vTaskSwitchContext+0x6c>
8000636a:	70 08       	ld.w	r8,r8[0x0]
8000636c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006370:	49 89       	lddpc	r9,800063d0 <vTaskSwitchContext+0x70>
80006372:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006376:	58 08       	cp.w	r8,0
80006378:	c0 60       	breq	80006384 <vTaskSwitchContext+0x24>
8000637a:	c1 18       	rjmp	8000639c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000637c:	30 19       	mov	r9,1
8000637e:	49 68       	lddpc	r8,800063d4 <vTaskSwitchContext+0x74>
80006380:	91 09       	st.w	r8[0x0],r9
80006382:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006384:	49 28       	lddpc	r8,800063cc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006386:	49 3a       	lddpc	r10,800063d0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006388:	70 09       	ld.w	r9,r8[0x0]
8000638a:	20 19       	sub	r9,1
8000638c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000638e:	70 09       	ld.w	r9,r8[0x0]
80006390:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006394:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006398:	58 09       	cp.w	r9,0
8000639a:	cf 70       	breq	80006388 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000639c:	48 c8       	lddpc	r8,800063cc <vTaskSwitchContext+0x6c>
8000639e:	70 08       	ld.w	r8,r8[0x0]
800063a0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063a4:	48 b9       	lddpc	r9,800063d0 <vTaskSwitchContext+0x70>
800063a6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063aa:	70 19       	ld.w	r9,r8[0x4]
800063ac:	72 19       	ld.w	r9,r9[0x4]
800063ae:	91 19       	st.w	r8[0x4],r9
800063b0:	f0 ca ff f8 	sub	r10,r8,-8
800063b4:	14 39       	cp.w	r9,r10
800063b6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800063ba:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800063be:	70 18       	ld.w	r8,r8[0x4]
800063c0:	70 39       	ld.w	r9,r8[0xc]
800063c2:	48 68       	lddpc	r8,800063d8 <vTaskSwitchContext+0x78>
800063c4:	91 09       	st.w	r8[0x0],r9
800063c6:	5e fc       	retal	r12
800063c8:	00 00       	add	r0,r0
800063ca:	0d 0c       	ld.w	r12,r6++
800063cc:	00 00       	add	r0,r0
800063ce:	0d 44       	ld.w	r4,--r6
800063d0:	00 00       	add	r0,r0
800063d2:	0c 28       	rsub	r8,r6
800063d4:	00 00       	add	r0,r0
800063d6:	0d 2c       	ld.uh	r12,r6++
800063d8:	00 00       	add	r0,r0
800063da:	0c dc       	st.w	--r6,r12

800063dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800063dc:	48 48       	lddpc	r8,800063ec <vTaskSetTimeOutState+0x10>
800063de:	70 08       	ld.w	r8,r8[0x0]
800063e0:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800063e2:	48 48       	lddpc	r8,800063f0 <vTaskSetTimeOutState+0x14>
800063e4:	70 08       	ld.w	r8,r8[0x0]
800063e6:	99 18       	st.w	r12[0x4],r8
}
800063e8:	5e fc       	retal	r12
800063ea:	00 00       	add	r0,r0
800063ec:	00 00       	add	r0,r0
800063ee:	0c 20       	rsub	r0,r6
800063f0:	00 00       	add	r0,r0
800063f2:	0d 08       	ld.w	r8,r6++

800063f4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800063f4:	30 19       	mov	r9,1
800063f6:	48 28       	lddpc	r8,800063fc <vTaskMissedYield+0x8>
800063f8:	91 09       	st.w	r8[0x0],r9
}
800063fa:	5e fc       	retal	r12
800063fc:	00 00       	add	r0,r0
800063fe:	0d 2c       	ld.uh	r12,r6++

80006400 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006400:	48 28       	lddpc	r8,80006408 <xTaskGetCurrentTaskHandle+0x8>
80006402:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006404:	5e fc       	retal	r12
80006406:	00 00       	add	r0,r0
80006408:	00 00       	add	r0,r0
8000640a:	0c dc       	st.w	--r6,r12

8000640c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000640c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006410:	58 0c       	cp.w	r12,0
80006412:	c1 f0       	breq	80006450 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006414:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006416:	78 b9       	ld.w	r9,r12[0x2c]
80006418:	79 18       	ld.w	r8,r12[0x44]
8000641a:	10 39       	cp.w	r9,r8
8000641c:	c1 a0       	breq	80006450 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000641e:	f8 c6 ff fc 	sub	r6,r12,-4
80006422:	0c 9c       	mov	r12,r6
80006424:	f0 1f 00 0c 	mcall	80006454 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006428:	6f 1c       	ld.w	r12,r7[0x44]
8000642a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000642c:	f8 08 11 08 	rsub	r8,r12,8
80006430:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006432:	48 a8       	lddpc	r8,80006458 <vTaskPriorityDisinherit+0x4c>
80006434:	70 08       	ld.w	r8,r8[0x0]
80006436:	10 3c       	cp.w	r12,r8
80006438:	e0 88 00 04 	brls	80006440 <vTaskPriorityDisinherit+0x34>
8000643c:	48 78       	lddpc	r8,80006458 <vTaskPriorityDisinherit+0x4c>
8000643e:	91 0c       	st.w	r8[0x0],r12
80006440:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006444:	0c 9b       	mov	r11,r6
80006446:	48 68       	lddpc	r8,8000645c <vTaskPriorityDisinherit+0x50>
80006448:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000644c:	f0 1f 00 05 	mcall	80006460 <vTaskPriorityDisinherit+0x54>
80006450:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	5b 62       	cp.w	r2,-10
80006458:	00 00       	add	r0,r0
8000645a:	0d 44       	ld.w	r4,--r6
8000645c:	00 00       	add	r0,r0
8000645e:	0c 28       	rsub	r8,r6
80006460:	80 00       	ld.sh	r0,r0[0x0]
80006462:	5b 12       	cp.w	r2,-15

80006464 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006464:	eb cd 40 c0 	pushm	r6-r7,lr
80006468:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000646a:	49 b8       	lddpc	r8,800064d4 <vTaskPriorityInherit+0x70>
8000646c:	70 08       	ld.w	r8,r8[0x0]
8000646e:	78 b9       	ld.w	r9,r12[0x2c]
80006470:	70 b8       	ld.w	r8,r8[0x2c]
80006472:	10 39       	cp.w	r9,r8
80006474:	c2 d2       	brcc	800064ce <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006476:	49 88       	lddpc	r8,800064d4 <vTaskPriorityInherit+0x70>
80006478:	70 08       	ld.w	r8,r8[0x0]
8000647a:	70 b8       	ld.w	r8,r8[0x2c]
8000647c:	f0 08 11 08 	rsub	r8,r8,8
80006480:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006482:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006486:	49 59       	lddpc	r9,800064d8 <vTaskPriorityInherit+0x74>
80006488:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000648c:	78 59       	ld.w	r9,r12[0x14]
8000648e:	10 39       	cp.w	r9,r8
80006490:	c1 b1       	brne	800064c6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006492:	f8 c6 ff fc 	sub	r6,r12,-4
80006496:	0c 9c       	mov	r12,r6
80006498:	f0 1f 00 11 	mcall	800064dc <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000649c:	48 e8       	lddpc	r8,800064d4 <vTaskPriorityInherit+0x70>
8000649e:	70 08       	ld.w	r8,r8[0x0]
800064a0:	70 bc       	ld.w	r12,r8[0x2c]
800064a2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800064a4:	48 f8       	lddpc	r8,800064e0 <vTaskPriorityInherit+0x7c>
800064a6:	70 08       	ld.w	r8,r8[0x0]
800064a8:	10 3c       	cp.w	r12,r8
800064aa:	e0 88 00 04 	brls	800064b2 <vTaskPriorityInherit+0x4e>
800064ae:	48 d8       	lddpc	r8,800064e0 <vTaskPriorityInherit+0x7c>
800064b0:	91 0c       	st.w	r8[0x0],r12
800064b2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064b6:	0c 9b       	mov	r11,r6
800064b8:	48 88       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x74>
800064ba:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064be:	f0 1f 00 0a 	mcall	800064e4 <vTaskPriorityInherit+0x80>
800064c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064c6:	48 48       	lddpc	r8,800064d4 <vTaskPriorityInherit+0x70>
800064c8:	70 08       	ld.w	r8,r8[0x0]
800064ca:	70 b8       	ld.w	r8,r8[0x2c]
800064cc:	99 b8       	st.w	r12[0x2c],r8
800064ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064d2:	00 00       	add	r0,r0
800064d4:	00 00       	add	r0,r0
800064d6:	0c dc       	st.w	--r6,r12
800064d8:	00 00       	add	r0,r0
800064da:	0c 28       	rsub	r8,r6
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	5b 62       	cp.w	r2,-10
800064e0:	00 00       	add	r0,r0
800064e2:	0d 44       	ld.w	r4,--r6
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	5b 12       	cp.w	r2,-15

800064e8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800064e8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800064ec:	78 38       	ld.w	r8,r12[0xc]
800064ee:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800064f0:	ee c6 ff e8 	sub	r6,r7,-24
800064f4:	0c 9c       	mov	r12,r6
800064f6:	f0 1f 00 15 	mcall	80006548 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800064fa:	49 58       	lddpc	r8,8000654c <xTaskRemoveFromEventList+0x64>
800064fc:	70 08       	ld.w	r8,r8[0x0]
800064fe:	58 08       	cp.w	r8,0
80006500:	c1 71       	brne	8000652e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006502:	ee c6 ff fc 	sub	r6,r7,-4
80006506:	0c 9c       	mov	r12,r6
80006508:	f0 1f 00 10 	mcall	80006548 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000650c:	6e bc       	ld.w	r12,r7[0x2c]
8000650e:	49 18       	lddpc	r8,80006550 <xTaskRemoveFromEventList+0x68>
80006510:	70 08       	ld.w	r8,r8[0x0]
80006512:	10 3c       	cp.w	r12,r8
80006514:	e0 88 00 04 	brls	8000651c <xTaskRemoveFromEventList+0x34>
80006518:	48 e8       	lddpc	r8,80006550 <xTaskRemoveFromEventList+0x68>
8000651a:	91 0c       	st.w	r8[0x0],r12
8000651c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006520:	0c 9b       	mov	r11,r6
80006522:	48 d8       	lddpc	r8,80006554 <xTaskRemoveFromEventList+0x6c>
80006524:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006528:	f0 1f 00 0c 	mcall	80006558 <xTaskRemoveFromEventList+0x70>
8000652c:	c0 58       	rjmp	80006536 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000652e:	0c 9b       	mov	r11,r6
80006530:	48 bc       	lddpc	r12,8000655c <xTaskRemoveFromEventList+0x74>
80006532:	f0 1f 00 0a 	mcall	80006558 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006536:	48 b8       	lddpc	r8,80006560 <xTaskRemoveFromEventList+0x78>
80006538:	70 08       	ld.w	r8,r8[0x0]
8000653a:	6e b9       	ld.w	r9,r7[0x2c]
8000653c:	70 b8       	ld.w	r8,r8[0x2c]
8000653e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006540:	5f 2c       	srhs	r12
80006542:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006546:	00 00       	add	r0,r0
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	5b 62       	cp.w	r2,-10
8000654c:	00 00       	add	r0,r0
8000654e:	0d 0c       	ld.w	r12,r6++
80006550:	00 00       	add	r0,r0
80006552:	0d 44       	ld.w	r4,--r6
80006554:	00 00       	add	r0,r0
80006556:	0c 28       	rsub	r8,r6
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	5b 12       	cp.w	r2,-15
8000655c:	00 00       	add	r0,r0
8000655e:	0c e0       	st.h	--r6,r0
80006560:	00 00       	add	r0,r0
80006562:	0c dc       	st.w	--r6,r12

80006564 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006564:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006568:	4b 98       	lddpc	r8,8000664c <vTaskIncrementTick+0xe8>
8000656a:	70 08       	ld.w	r8,r8[0x0]
8000656c:	58 08       	cp.w	r8,0
8000656e:	c6 91       	brne	80006640 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006570:	4b 88       	lddpc	r8,80006650 <vTaskIncrementTick+0xec>
80006572:	70 09       	ld.w	r9,r8[0x0]
80006574:	2f f9       	sub	r9,-1
80006576:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006578:	70 08       	ld.w	r8,r8[0x0]
8000657a:	58 08       	cp.w	r8,0
8000657c:	c1 a1       	brne	800065b0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000657e:	4b 68       	lddpc	r8,80006654 <vTaskIncrementTick+0xf0>
80006580:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006582:	4b 69       	lddpc	r9,80006658 <vTaskIncrementTick+0xf4>
80006584:	72 0b       	ld.w	r11,r9[0x0]
80006586:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006588:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000658a:	4b 59       	lddpc	r9,8000665c <vTaskIncrementTick+0xf8>
8000658c:	72 0a       	ld.w	r10,r9[0x0]
8000658e:	2f fa       	sub	r10,-1
80006590:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006592:	70 08       	ld.w	r8,r8[0x0]
80006594:	70 08       	ld.w	r8,r8[0x0]
80006596:	58 08       	cp.w	r8,0
80006598:	c0 51       	brne	800065a2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000659a:	3f f9       	mov	r9,-1
8000659c:	4b 18       	lddpc	r8,80006660 <vTaskIncrementTick+0xfc>
8000659e:	91 09       	st.w	r8[0x0],r9
800065a0:	c0 88       	rjmp	800065b0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800065a2:	4a d8       	lddpc	r8,80006654 <vTaskIncrementTick+0xf0>
800065a4:	70 08       	ld.w	r8,r8[0x0]
800065a6:	70 38       	ld.w	r8,r8[0xc]
800065a8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800065aa:	70 19       	ld.w	r9,r8[0x4]
800065ac:	4a d8       	lddpc	r8,80006660 <vTaskIncrementTick+0xfc>
800065ae:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800065b0:	4a 88       	lddpc	r8,80006650 <vTaskIncrementTick+0xec>
800065b2:	70 09       	ld.w	r9,r8[0x0]
800065b4:	4a b8       	lddpc	r8,80006660 <vTaskIncrementTick+0xfc>
800065b6:	70 08       	ld.w	r8,r8[0x0]
800065b8:	10 39       	cp.w	r9,r8
800065ba:	c4 73       	brcs	80006648 <vTaskIncrementTick+0xe4>
800065bc:	4a 68       	lddpc	r8,80006654 <vTaskIncrementTick+0xf0>
800065be:	70 08       	ld.w	r8,r8[0x0]
800065c0:	70 08       	ld.w	r8,r8[0x0]
800065c2:	58 08       	cp.w	r8,0
800065c4:	c0 c0       	breq	800065dc <vTaskIncrementTick+0x78>
800065c6:	4a 48       	lddpc	r8,80006654 <vTaskIncrementTick+0xf0>
800065c8:	70 08       	ld.w	r8,r8[0x0]
800065ca:	70 38       	ld.w	r8,r8[0xc]
800065cc:	70 37       	ld.w	r7,r8[0xc]
800065ce:	6e 18       	ld.w	r8,r7[0x4]
800065d0:	4a 09       	lddpc	r9,80006650 <vTaskIncrementTick+0xec>
800065d2:	72 09       	ld.w	r9,r9[0x0]
800065d4:	12 38       	cp.w	r8,r9
800065d6:	e0 88 00 14 	brls	800065fe <vTaskIncrementTick+0x9a>
800065da:	c0 e8       	rjmp	800065f6 <vTaskIncrementTick+0x92>
800065dc:	3f f9       	mov	r9,-1
800065de:	4a 18       	lddpc	r8,80006660 <vTaskIncrementTick+0xfc>
800065e0:	91 09       	st.w	r8[0x0],r9
800065e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065e6:	6a 08       	ld.w	r8,r5[0x0]
800065e8:	70 38       	ld.w	r8,r8[0xc]
800065ea:	70 37       	ld.w	r7,r8[0xc]
800065ec:	6e 18       	ld.w	r8,r7[0x4]
800065ee:	64 09       	ld.w	r9,r2[0x0]
800065f0:	12 38       	cp.w	r8,r9
800065f2:	e0 88 00 0a 	brls	80006606 <vTaskIncrementTick+0xa2>
800065f6:	49 b9       	lddpc	r9,80006660 <vTaskIncrementTick+0xfc>
800065f8:	93 08       	st.w	r9[0x0],r8
800065fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065fe:	49 a4       	lddpc	r4,80006664 <vTaskIncrementTick+0x100>
80006600:	49 a3       	lddpc	r3,80006668 <vTaskIncrementTick+0x104>
80006602:	49 55       	lddpc	r5,80006654 <vTaskIncrementTick+0xf0>
80006604:	49 32       	lddpc	r2,80006650 <vTaskIncrementTick+0xec>
80006606:	ee c6 ff fc 	sub	r6,r7,-4
8000660a:	0c 9c       	mov	r12,r6
8000660c:	f0 1f 00 18 	mcall	8000666c <vTaskIncrementTick+0x108>
80006610:	6e a8       	ld.w	r8,r7[0x28]
80006612:	58 08       	cp.w	r8,0
80006614:	c0 50       	breq	8000661e <vTaskIncrementTick+0xba>
80006616:	ee cc ff e8 	sub	r12,r7,-24
8000661a:	f0 1f 00 15 	mcall	8000666c <vTaskIncrementTick+0x108>
8000661e:	6e bc       	ld.w	r12,r7[0x2c]
80006620:	68 08       	ld.w	r8,r4[0x0]
80006622:	10 3c       	cp.w	r12,r8
80006624:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006628:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000662c:	0c 9b       	mov	r11,r6
8000662e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006632:	f0 1f 00 10 	mcall	80006670 <vTaskIncrementTick+0x10c>
80006636:	6a 08       	ld.w	r8,r5[0x0]
80006638:	70 08       	ld.w	r8,r8[0x0]
8000663a:	58 08       	cp.w	r8,0
8000663c:	cd 51       	brne	800065e6 <vTaskIncrementTick+0x82>
8000663e:	cc fb       	rjmp	800065dc <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006640:	48 d8       	lddpc	r8,80006674 <vTaskIncrementTick+0x110>
80006642:	70 09       	ld.w	r9,r8[0x0]
80006644:	2f f9       	sub	r9,-1
80006646:	91 09       	st.w	r8[0x0],r9
80006648:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000664c:	00 00       	add	r0,r0
8000664e:	0d 0c       	ld.w	r12,r6++
80006650:	00 00       	add	r0,r0
80006652:	0d 08       	ld.w	r8,r6++
80006654:	00 00       	add	r0,r0
80006656:	0c 14       	sub	r4,r6
80006658:	00 00       	add	r0,r0
8000665a:	0c 24       	rsub	r4,r6
8000665c:	00 00       	add	r0,r0
8000665e:	0c 20       	rsub	r0,r6
80006660:	00 00       	add	r0,r0
80006662:	05 38       	ld.ub	r8,r2++
80006664:	00 00       	add	r0,r0
80006666:	0d 44       	ld.w	r4,--r6
80006668:	00 00       	add	r0,r0
8000666a:	0c 28       	rsub	r8,r6
8000666c:	80 00       	ld.sh	r0,r0[0x0]
8000666e:	5b 62       	cp.w	r2,-10
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	5b 12       	cp.w	r2,-15
80006674:	00 00       	add	r0,r0
80006676:	0c 0c       	add	r12,r6

80006678 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006678:	eb cd 40 c0 	pushm	r6-r7,lr
8000667c:	18 97       	mov	r7,r12
8000667e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006680:	f0 1f 00 15 	mcall	800066d4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006684:	6c 08       	ld.w	r8,r6[0x0]
80006686:	5b f8       	cp.w	r8,-1
80006688:	c0 31       	brne	8000668e <xTaskCheckForTimeOut+0x16>
8000668a:	30 07       	mov	r7,0
8000668c:	c1 f8       	rjmp	800066ca <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000668e:	49 39       	lddpc	r9,800066d8 <xTaskCheckForTimeOut+0x60>
80006690:	72 09       	ld.w	r9,r9[0x0]
80006692:	6e 0a       	ld.w	r10,r7[0x0]
80006694:	12 3a       	cp.w	r10,r9
80006696:	c0 70       	breq	800066a4 <xTaskCheckForTimeOut+0x2c>
80006698:	49 19       	lddpc	r9,800066dc <xTaskCheckForTimeOut+0x64>
8000669a:	72 09       	ld.w	r9,r9[0x0]
8000669c:	6e 1a       	ld.w	r10,r7[0x4]
8000669e:	12 3a       	cp.w	r10,r9
800066a0:	e0 88 00 14 	brls	800066c8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800066a4:	48 e9       	lddpc	r9,800066dc <xTaskCheckForTimeOut+0x64>
800066a6:	72 0a       	ld.w	r10,r9[0x0]
800066a8:	6e 19       	ld.w	r9,r7[0x4]
800066aa:	12 1a       	sub	r10,r9
800066ac:	14 38       	cp.w	r8,r10
800066ae:	e0 88 00 0d 	brls	800066c8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800066b2:	48 ba       	lddpc	r10,800066dc <xTaskCheckForTimeOut+0x64>
800066b4:	74 0a       	ld.w	r10,r10[0x0]
800066b6:	14 19       	sub	r9,r10
800066b8:	f2 08 00 08 	add	r8,r9,r8
800066bc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800066be:	0e 9c       	mov	r12,r7
800066c0:	f0 1f 00 08 	mcall	800066e0 <xTaskCheckForTimeOut+0x68>
800066c4:	30 07       	mov	r7,0
800066c6:	c0 28       	rjmp	800066ca <xTaskCheckForTimeOut+0x52>
800066c8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800066ca:	f0 1f 00 07 	mcall	800066e4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800066ce:	0e 9c       	mov	r12,r7
800066d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066d4:	80 00       	ld.sh	r0,r0[0x0]
800066d6:	5c 1c       	scr	r12
800066d8:	00 00       	add	r0,r0
800066da:	0c 20       	rsub	r0,r6
800066dc:	00 00       	add	r0,r0
800066de:	0d 08       	ld.w	r8,r6++
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	63 dc       	ld.w	r12,r1[0x74]
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	5d 28       	mustr	r8

800066e8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800066e8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800066ec:	f0 1f 00 05 	mcall	80006700 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800066f0:	48 58       	lddpc	r8,80006704 <xTaskGetTickCount+0x1c>
800066f2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800066f4:	f0 1f 00 05 	mcall	80006708 <xTaskGetTickCount+0x20>

	return xTicks;
}
800066f8:	0e 9c       	mov	r12,r7
800066fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800066fe:	00 00       	add	r0,r0
80006700:	80 00       	ld.sh	r0,r0[0x0]
80006702:	5c 1c       	scr	r12
80006704:	00 00       	add	r0,r0
80006706:	0d 08       	ld.w	r8,r6++
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	5d 28       	mustr	r8

8000670c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000670c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006710:	f0 1f 00 2c 	mcall	800067c0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006714:	4a c8       	lddpc	r8,800067c4 <xTaskResumeAll+0xb8>
80006716:	70 09       	ld.w	r9,r8[0x0]
80006718:	20 19       	sub	r9,1
8000671a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000671c:	70 08       	ld.w	r8,r8[0x0]
8000671e:	58 08       	cp.w	r8,0
80006720:	c4 91       	brne	800067b2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006722:	4a a8       	lddpc	r8,800067c8 <xTaskResumeAll+0xbc>
80006724:	70 08       	ld.w	r8,r8[0x0]
80006726:	58 08       	cp.w	r8,0
80006728:	c4 50       	breq	800067b2 <xTaskResumeAll+0xa6>
8000672a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000672c:	4a 85       	lddpc	r5,800067cc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000672e:	4a 93       	lddpc	r3,800067d0 <xTaskResumeAll+0xc4>
80006730:	4a 92       	lddpc	r2,800067d4 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006732:	4a a1       	lddpc	r1,800067d8 <xTaskResumeAll+0xcc>
80006734:	c1 e8       	rjmp	80006770 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006736:	6a 38       	ld.w	r8,r5[0xc]
80006738:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000673a:	ee cc ff e8 	sub	r12,r7,-24
8000673e:	f0 1f 00 28 	mcall	800067dc <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006742:	ee c6 ff fc 	sub	r6,r7,-4
80006746:	0c 9c       	mov	r12,r6
80006748:	f0 1f 00 25 	mcall	800067dc <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000674c:	6e bc       	ld.w	r12,r7[0x2c]
8000674e:	66 08       	ld.w	r8,r3[0x0]
80006750:	10 3c       	cp.w	r12,r8
80006752:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006756:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000675a:	0c 9b       	mov	r11,r6
8000675c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006760:	f0 1f 00 20 	mcall	800067e0 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006764:	62 08       	ld.w	r8,r1[0x0]
80006766:	6e b9       	ld.w	r9,r7[0x2c]
80006768:	70 b8       	ld.w	r8,r8[0x2c]
8000676a:	10 39       	cp.w	r9,r8
8000676c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006770:	6a 08       	ld.w	r8,r5[0x0]
80006772:	58 08       	cp.w	r8,0
80006774:	ce 11       	brne	80006736 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006776:	49 c8       	lddpc	r8,800067e4 <xTaskResumeAll+0xd8>
80006778:	70 08       	ld.w	r8,r8[0x0]
8000677a:	58 08       	cp.w	r8,0
8000677c:	c0 f0       	breq	8000679a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000677e:	49 a8       	lddpc	r8,800067e4 <xTaskResumeAll+0xd8>
80006780:	70 08       	ld.w	r8,r8[0x0]
80006782:	58 08       	cp.w	r8,0
80006784:	c1 10       	breq	800067a6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006786:	49 87       	lddpc	r7,800067e4 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006788:	f0 1f 00 18 	mcall	800067e8 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000678c:	6e 08       	ld.w	r8,r7[0x0]
8000678e:	20 18       	sub	r8,1
80006790:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006792:	6e 08       	ld.w	r8,r7[0x0]
80006794:	58 08       	cp.w	r8,0
80006796:	cf 91       	brne	80006788 <xTaskResumeAll+0x7c>
80006798:	c0 78       	rjmp	800067a6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000679a:	58 14       	cp.w	r4,1
8000679c:	c0 50       	breq	800067a6 <xTaskResumeAll+0x9a>
8000679e:	49 48       	lddpc	r8,800067ec <xTaskResumeAll+0xe0>
800067a0:	70 08       	ld.w	r8,r8[0x0]
800067a2:	58 18       	cp.w	r8,1
800067a4:	c0 71       	brne	800067b2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800067a6:	30 09       	mov	r9,0
800067a8:	49 18       	lddpc	r8,800067ec <xTaskResumeAll+0xe0>
800067aa:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800067ac:	d7 33       	scall
800067ae:	30 17       	mov	r7,1
800067b0:	c0 28       	rjmp	800067b4 <xTaskResumeAll+0xa8>
800067b2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800067b4:	f0 1f 00 0f 	mcall	800067f0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800067b8:	0e 9c       	mov	r12,r7
800067ba:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800067be:	00 00       	add	r0,r0
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	5c 1c       	scr	r12
800067c4:	00 00       	add	r0,r0
800067c6:	0d 0c       	ld.w	r12,r6++
800067c8:	00 00       	add	r0,r0
800067ca:	0d 28       	ld.uh	r8,r6++
800067cc:	00 00       	add	r0,r0
800067ce:	0c e0       	st.h	--r6,r0
800067d0:	00 00       	add	r0,r0
800067d2:	0d 44       	ld.w	r4,--r6
800067d4:	00 00       	add	r0,r0
800067d6:	0c 28       	rsub	r8,r6
800067d8:	00 00       	add	r0,r0
800067da:	0c dc       	st.w	--r6,r12
800067dc:	80 00       	ld.sh	r0,r0[0x0]
800067de:	5b 62       	cp.w	r2,-10
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	5b 12       	cp.w	r2,-15
800067e4:	00 00       	add	r0,r0
800067e6:	0c 0c       	add	r12,r6
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	65 64       	ld.w	r4,r2[0x58]
800067ec:	00 00       	add	r0,r0
800067ee:	0d 2c       	ld.uh	r12,r6++
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	5d 28       	mustr	r8

800067f4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800067f4:	eb cd 40 80 	pushm	r7,lr
800067f8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800067fa:	49 08       	lddpc	r8,80006838 <prvAddCurrentTaskToDelayedList+0x44>
800067fc:	70 08       	ld.w	r8,r8[0x0]
800067fe:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006800:	48 f8       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x48>
80006802:	70 08       	ld.w	r8,r8[0x0]
80006804:	10 3c       	cp.w	r12,r8
80006806:	c0 a2       	brcc	8000681a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006808:	48 c8       	lddpc	r8,80006838 <prvAddCurrentTaskToDelayedList+0x44>
8000680a:	70 0b       	ld.w	r11,r8[0x0]
8000680c:	48 d8       	lddpc	r8,80006840 <prvAddCurrentTaskToDelayedList+0x4c>
8000680e:	70 0c       	ld.w	r12,r8[0x0]
80006810:	2f cb       	sub	r11,-4
80006812:	f0 1f 00 0d 	mcall	80006844 <prvAddCurrentTaskToDelayedList+0x50>
80006816:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000681a:	48 88       	lddpc	r8,80006838 <prvAddCurrentTaskToDelayedList+0x44>
8000681c:	70 0b       	ld.w	r11,r8[0x0]
8000681e:	48 b8       	lddpc	r8,80006848 <prvAddCurrentTaskToDelayedList+0x54>
80006820:	70 0c       	ld.w	r12,r8[0x0]
80006822:	2f cb       	sub	r11,-4
80006824:	f0 1f 00 08 	mcall	80006844 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006828:	48 98       	lddpc	r8,8000684c <prvAddCurrentTaskToDelayedList+0x58>
8000682a:	70 08       	ld.w	r8,r8[0x0]
8000682c:	10 37       	cp.w	r7,r8
8000682e:	c0 32       	brcc	80006834 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006830:	48 78       	lddpc	r8,8000684c <prvAddCurrentTaskToDelayedList+0x58>
80006832:	91 07       	st.w	r8[0x0],r7
80006834:	e3 cd 80 80 	ldm	sp++,r7,pc
80006838:	00 00       	add	r0,r0
8000683a:	0c dc       	st.w	--r6,r12
8000683c:	00 00       	add	r0,r0
8000683e:	0d 08       	ld.w	r8,r6++
80006840:	00 00       	add	r0,r0
80006842:	0c 24       	rsub	r4,r6
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	5b 2e       	cp.w	lr,-14
80006848:	00 00       	add	r0,r0
8000684a:	0c 14       	sub	r4,r6
8000684c:	00 00       	add	r0,r0
8000684e:	05 38       	ld.ub	r8,r2++

80006850 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006850:	eb cd 40 c0 	pushm	r6-r7,lr
80006854:	18 96       	mov	r6,r12
80006856:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006858:	f0 1f 00 18 	mcall	800068b8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000685c:	6c 08       	ld.w	r8,r6[0x0]
8000685e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006860:	49 79       	lddpc	r9,800068bc <vTaskDelayUntil+0x6c>
80006862:	72 09       	ld.w	r9,r9[0x0]
80006864:	12 38       	cp.w	r8,r9
80006866:	e0 88 00 0c 	brls	8000687e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000686a:	0e 38       	cp.w	r8,r7
8000686c:	e0 88 00 22 	brls	800068b0 <vTaskDelayUntil+0x60>
80006870:	49 38       	lddpc	r8,800068bc <vTaskDelayUntil+0x6c>
80006872:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006874:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006876:	10 37       	cp.w	r7,r8
80006878:	e0 88 00 14 	brls	800068a0 <vTaskDelayUntil+0x50>
8000687c:	c0 a8       	rjmp	80006890 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000687e:	0e 38       	cp.w	r8,r7
80006880:	e0 8b 00 16 	brhi	800068ac <vTaskDelayUntil+0x5c>
80006884:	48 e8       	lddpc	r8,800068bc <vTaskDelayUntil+0x6c>
80006886:	70 08       	ld.w	r8,r8[0x0]
80006888:	10 37       	cp.w	r7,r8
8000688a:	e0 8b 00 11 	brhi	800068ac <vTaskDelayUntil+0x5c>
8000688e:	c1 18       	rjmp	800068b0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006890:	48 c8       	lddpc	r8,800068c0 <vTaskDelayUntil+0x70>
80006892:	70 0c       	ld.w	r12,r8[0x0]
80006894:	2f cc       	sub	r12,-4
80006896:	f0 1f 00 0c 	mcall	800068c4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000689a:	0e 9c       	mov	r12,r7
8000689c:	f0 1f 00 0b 	mcall	800068c8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800068a0:	f0 1f 00 0b 	mcall	800068cc <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068a4:	c0 81       	brne	800068b4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800068a6:	d7 33       	scall
800068a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068ac:	8d 07       	st.w	r6[0x0],r7
800068ae:	cf 1b       	rjmp	80006890 <vTaskDelayUntil+0x40>
800068b0:	8d 07       	st.w	r6[0x0],r7
800068b2:	cf 7b       	rjmp	800068a0 <vTaskDelayUntil+0x50>
800068b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	63 50       	ld.w	r0,r1[0x54]
800068bc:	00 00       	add	r0,r0
800068be:	0d 08       	ld.w	r8,r6++
800068c0:	00 00       	add	r0,r0
800068c2:	0c dc       	st.w	--r6,r12
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	5b 62       	cp.w	r2,-10
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	67 f4       	ld.w	r4,r3[0x7c]
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	67 0c       	ld.w	r12,r3[0x40]

800068d0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800068d0:	eb cd 40 c0 	pushm	r6-r7,lr
800068d4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800068d6:	48 e7       	lddpc	r7,8000690c <vTaskPlaceOnEventList+0x3c>
800068d8:	6e 0b       	ld.w	r11,r7[0x0]
800068da:	2e 8b       	sub	r11,-24
800068dc:	f0 1f 00 0d 	mcall	80006910 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068e0:	6e 0c       	ld.w	r12,r7[0x0]
800068e2:	2f cc       	sub	r12,-4
800068e4:	f0 1f 00 0c 	mcall	80006914 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800068e8:	5b f6       	cp.w	r6,-1
800068ea:	c0 81       	brne	800068fa <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068ec:	6e 0b       	ld.w	r11,r7[0x0]
800068ee:	2f cb       	sub	r11,-4
800068f0:	48 ac       	lddpc	r12,80006918 <vTaskPlaceOnEventList+0x48>
800068f2:	f0 1f 00 0b 	mcall	8000691c <vTaskPlaceOnEventList+0x4c>
800068f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800068fa:	48 a8       	lddpc	r8,80006920 <vTaskPlaceOnEventList+0x50>
800068fc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800068fe:	ec 0c 00 0c 	add	r12,r6,r12
80006902:	f0 1f 00 09 	mcall	80006924 <vTaskPlaceOnEventList+0x54>
80006906:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000690a:	00 00       	add	r0,r0
8000690c:	00 00       	add	r0,r0
8000690e:	0c dc       	st.w	--r6,r12
80006910:	80 00       	ld.sh	r0,r0[0x0]
80006912:	5b 2e       	cp.w	lr,-14
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	5b 62       	cp.w	r2,-10
80006918:	00 00       	add	r0,r0
8000691a:	0d 30       	ld.ub	r0,r6++
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	5b 12       	cp.w	r2,-15
80006920:	00 00       	add	r0,r0
80006922:	0d 08       	ld.w	r8,r6++
80006924:	80 00       	ld.sh	r0,r0[0x0]
80006926:	67 f4       	ld.w	r4,r3[0x7c]

80006928 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006928:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000692c:	49 67       	lddpc	r7,80006984 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000692e:	49 74       	lddpc	r4,80006988 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006930:	49 73       	lddpc	r3,8000698c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006932:	49 85       	lddpc	r5,80006990 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006934:	6e 08       	ld.w	r8,r7[0x0]
80006936:	58 08       	cp.w	r8,0
80006938:	c1 e0       	breq	80006974 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000693a:	f0 1f 00 17 	mcall	80006994 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000693e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006940:	f0 1f 00 16 	mcall	80006998 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006944:	58 06       	cp.w	r6,0
80006946:	c1 70       	breq	80006974 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006948:	f0 1f 00 15 	mcall	8000699c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000694c:	68 38       	ld.w	r8,r4[0xc]
8000694e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006950:	ec cc ff fc 	sub	r12,r6,-4
80006954:	f0 1f 00 13 	mcall	800069a0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006958:	66 08       	ld.w	r8,r3[0x0]
8000695a:	20 18       	sub	r8,1
8000695c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000695e:	6e 08       	ld.w	r8,r7[0x0]
80006960:	20 18       	sub	r8,1
80006962:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006964:	f0 1f 00 10 	mcall	800069a4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006968:	6c cc       	ld.w	r12,r6[0x30]
8000696a:	f0 1f 00 10 	mcall	800069a8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000696e:	0c 9c       	mov	r12,r6
80006970:	f0 1f 00 0e 	mcall	800069a8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006974:	6a 08       	ld.w	r8,r5[0x0]
80006976:	58 18       	cp.w	r8,1
80006978:	e0 88 00 03 	brls	8000697e <prvIdleTask+0x56>
			{
				taskYIELD();
8000697c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000697e:	f0 1f 00 0c 	mcall	800069ac <prvIdleTask+0x84>
		}
		#endif
	}
80006982:	cd 9b       	rjmp	80006934 <prvIdleTask+0xc>
80006984:	00 00       	add	r0,r0
80006986:	0c 1c       	sub	r12,r6
80006988:	00 00       	add	r0,r0
8000698a:	0c c8       	st.b	r6++,r8
8000698c:	00 00       	add	r0,r0
8000698e:	0d 28       	ld.uh	r8,r6++
80006990:	00 00       	add	r0,r0
80006992:	0c 28       	rsub	r8,r6
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	63 50       	ld.w	r0,r1[0x54]
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	67 0c       	ld.w	r12,r3[0x40]
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	5c 1c       	scr	r12
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	5b 62       	cp.w	r2,-10
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	5d 28       	mustr	r8
800069a8:	80 00       	ld.sh	r0,r0[0x0]
800069aa:	5e 60       	retmi	r0
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	20 30       	sub	r0,3

800069b0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800069b0:	d4 31       	pushm	r0-r7,lr
800069b2:	20 1d       	sub	sp,4
800069b4:	fa c4 ff d8 	sub	r4,sp,-40
800069b8:	50 0c       	stdsp	sp[0x0],r12
800069ba:	16 91       	mov	r1,r11
800069bc:	14 97       	mov	r7,r10
800069be:	12 90       	mov	r0,r9
800069c0:	10 93       	mov	r3,r8
800069c2:	68 02       	ld.w	r2,r4[0x0]
800069c4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800069c6:	34 8c       	mov	r12,72
800069c8:	f0 1f 00 5c 	mcall	80006b38 <xTaskGenericCreate+0x188>
800069cc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800069ce:	c0 31       	brne	800069d4 <xTaskGenericCreate+0x24>
800069d0:	3f fc       	mov	r12,-1
800069d2:	ca f8       	rjmp	80006b30 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800069d4:	58 06       	cp.w	r6,0
800069d6:	e0 81 00 af 	brne	80006b34 <xTaskGenericCreate+0x184>
800069da:	0e 9c       	mov	r12,r7
800069dc:	5c 7c       	castu.h	r12
800069de:	a3 6c       	lsl	r12,0x2
800069e0:	f0 1f 00 56 	mcall	80006b38 <xTaskGenericCreate+0x188>
800069e4:	18 96       	mov	r6,r12
800069e6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800069e8:	c0 61       	brne	800069f4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800069ea:	0a 9c       	mov	r12,r5
800069ec:	f0 1f 00 54 	mcall	80006b3c <xTaskGenericCreate+0x18c>
800069f0:	3f fc       	mov	r12,-1
800069f2:	c9 f8       	rjmp	80006b30 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800069f4:	5c 77       	castu.h	r7
800069f6:	ee 0a 15 02 	lsl	r10,r7,0x2
800069fa:	e0 6b 00 a5 	mov	r11,165
800069fe:	0c 9c       	mov	r12,r6
80006a00:	f0 1f 00 50 	mcall	80006b40 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006a04:	ee c6 00 01 	sub	r6,r7,1
80006a08:	6a c8       	ld.w	r8,r5[0x30]
80006a0a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006a0e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006a12:	31 0a       	mov	r10,16
80006a14:	02 9b       	mov	r11,r1
80006a16:	ea cc ff cc 	sub	r12,r5,-52
80006a1a:	f0 1f 00 4b 	mcall	80006b44 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006a1e:	30 08       	mov	r8,0
80006a20:	eb 68 00 43 	st.b	r5[67],r8
80006a24:	58 73       	cp.w	r3,7
80006a26:	e6 07 17 80 	movls	r7,r3
80006a2a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006a2e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006a30:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006a34:	ea c4 ff fc 	sub	r4,r5,-4
80006a38:	08 9c       	mov	r12,r4
80006a3a:	f0 1f 00 44 	mcall	80006b48 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006a3e:	ea cc ff e8 	sub	r12,r5,-24
80006a42:	f0 1f 00 42 	mcall	80006b48 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006a46:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006a48:	ee 07 11 08 	rsub	r7,r7,8
80006a4c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006a4e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006a50:	00 9a       	mov	r10,r0
80006a52:	40 0b       	lddsp	r11,sp[0x0]
80006a54:	0c 9c       	mov	r12,r6
80006a56:	f0 1f 00 3e 	mcall	80006b4c <xTaskGenericCreate+0x19c>
80006a5a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006a5c:	58 02       	cp.w	r2,0
80006a5e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006a62:	f0 1f 00 3c 	mcall	80006b50 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006a66:	4b c8       	lddpc	r8,80006b54 <xTaskGenericCreate+0x1a4>
80006a68:	70 09       	ld.w	r9,r8[0x0]
80006a6a:	2f f9       	sub	r9,-1
80006a6c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006a6e:	4b b8       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a8>
80006a70:	70 08       	ld.w	r8,r8[0x0]
80006a72:	58 08       	cp.w	r8,0
80006a74:	c2 61       	brne	80006ac0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006a76:	4b 98       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a8>
80006a78:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006a7a:	4b 78       	lddpc	r8,80006b54 <xTaskGenericCreate+0x1a4>
80006a7c:	70 08       	ld.w	r8,r8[0x0]
80006a7e:	58 18       	cp.w	r8,1
80006a80:	c2 b1       	brne	80006ad6 <xTaskGenericCreate+0x126>
80006a82:	4b 77       	lddpc	r7,80006b5c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006a84:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006a88:	0e 9c       	mov	r12,r7
80006a8a:	f0 1f 00 36 	mcall	80006b60 <xTaskGenericCreate+0x1b0>
80006a8e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006a90:	0c 37       	cp.w	r7,r6
80006a92:	cf b1       	brne	80006a88 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006a94:	4b 47       	lddpc	r7,80006b64 <xTaskGenericCreate+0x1b4>
80006a96:	0e 9c       	mov	r12,r7
80006a98:	f0 1f 00 32 	mcall	80006b60 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006a9c:	4b 36       	lddpc	r6,80006b68 <xTaskGenericCreate+0x1b8>
80006a9e:	0c 9c       	mov	r12,r6
80006aa0:	f0 1f 00 30 	mcall	80006b60 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006aa4:	4b 2c       	lddpc	r12,80006b6c <xTaskGenericCreate+0x1bc>
80006aa6:	f0 1f 00 2f 	mcall	80006b60 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006aaa:	4b 2c       	lddpc	r12,80006b70 <xTaskGenericCreate+0x1c0>
80006aac:	f0 1f 00 2d 	mcall	80006b60 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006ab0:	4b 1c       	lddpc	r12,80006b74 <xTaskGenericCreate+0x1c4>
80006ab2:	f0 1f 00 2c 	mcall	80006b60 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006ab6:	4b 18       	lddpc	r8,80006b78 <xTaskGenericCreate+0x1c8>
80006ab8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006aba:	4b 18       	lddpc	r8,80006b7c <xTaskGenericCreate+0x1cc>
80006abc:	91 06       	st.w	r8[0x0],r6
80006abe:	c0 c8       	rjmp	80006ad6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006ac0:	4b 08       	lddpc	r8,80006b80 <xTaskGenericCreate+0x1d0>
80006ac2:	70 08       	ld.w	r8,r8[0x0]
80006ac4:	58 08       	cp.w	r8,0
80006ac6:	c0 81       	brne	80006ad6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006ac8:	4a 48       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a8>
80006aca:	70 08       	ld.w	r8,r8[0x0]
80006acc:	70 b8       	ld.w	r8,r8[0x2c]
80006ace:	10 33       	cp.w	r3,r8
80006ad0:	c0 33       	brcs	80006ad6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006ad2:	4a 28       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a8>
80006ad4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006ad6:	6a b8       	ld.w	r8,r5[0x2c]
80006ad8:	4a b9       	lddpc	r9,80006b84 <xTaskGenericCreate+0x1d4>
80006ada:	72 09       	ld.w	r9,r9[0x0]
80006adc:	12 38       	cp.w	r8,r9
80006ade:	e0 88 00 04 	brls	80006ae6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006ae2:	4a 99       	lddpc	r9,80006b84 <xTaskGenericCreate+0x1d4>
80006ae4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006ae6:	4a 98       	lddpc	r8,80006b88 <xTaskGenericCreate+0x1d8>
80006ae8:	70 09       	ld.w	r9,r8[0x0]
80006aea:	2f f9       	sub	r9,-1
80006aec:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006aee:	6a b8       	ld.w	r8,r5[0x2c]
80006af0:	4a 79       	lddpc	r9,80006b8c <xTaskGenericCreate+0x1dc>
80006af2:	72 09       	ld.w	r9,r9[0x0]
80006af4:	12 38       	cp.w	r8,r9
80006af6:	e0 88 00 04 	brls	80006afe <xTaskGenericCreate+0x14e>
80006afa:	4a 59       	lddpc	r9,80006b8c <xTaskGenericCreate+0x1dc>
80006afc:	93 08       	st.w	r9[0x0],r8
80006afe:	6a bc       	ld.w	r12,r5[0x2c]
80006b00:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006b04:	08 9b       	mov	r11,r4
80006b06:	49 68       	lddpc	r8,80006b5c <xTaskGenericCreate+0x1ac>
80006b08:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006b0c:	f0 1f 00 21 	mcall	80006b90 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006b10:	f0 1f 00 21 	mcall	80006b94 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006b14:	49 b8       	lddpc	r8,80006b80 <xTaskGenericCreate+0x1d0>
80006b16:	70 08       	ld.w	r8,r8[0x0]
80006b18:	58 08       	cp.w	r8,0
80006b1a:	c0 a0       	breq	80006b2e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006b1c:	48 f8       	lddpc	r8,80006b58 <xTaskGenericCreate+0x1a8>
80006b1e:	70 08       	ld.w	r8,r8[0x0]
80006b20:	70 b8       	ld.w	r8,r8[0x2c]
80006b22:	10 33       	cp.w	r3,r8
80006b24:	e0 88 00 05 	brls	80006b2e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006b28:	d7 33       	scall
80006b2a:	30 1c       	mov	r12,1
80006b2c:	c0 28       	rjmp	80006b30 <xTaskGenericCreate+0x180>
80006b2e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006b30:	2f fd       	sub	sp,-4
80006b32:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006b34:	99 c6       	st.w	r12[0x30],r6
80006b36:	c5 fb       	rjmp	800069f4 <xTaskGenericCreate+0x44>
80006b38:	80 00       	ld.sh	r0,r0[0x0]
80006b3a:	5e 88       	retls	r8
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	5e 60       	retmi	r0
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	78 76       	ld.w	r6,r12[0x1c]
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	7b b8       	ld.w	r8,sp[0x6c]
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	5b 0c       	cp.w	r12,-16
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	5b 88       	cp.w	r8,-8
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	5c 1c       	scr	r12
80006b54:	00 00       	add	r0,r0
80006b56:	0d 28       	ld.uh	r8,r6++
80006b58:	00 00       	add	r0,r0
80006b5a:	0c dc       	st.w	--r6,r12
80006b5c:	00 00       	add	r0,r0
80006b5e:	0c 28       	rsub	r8,r6
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	5a f8       	cp.w	r8,-17
80006b64:	00 00       	add	r0,r0
80006b66:	0c f4       	st.b	--r6,r4
80006b68:	00 00       	add	r0,r0
80006b6a:	0d 10       	ld.sh	r0,r6++
80006b6c:	00 00       	add	r0,r0
80006b6e:	0c e0       	st.h	--r6,r0
80006b70:	00 00       	add	r0,r0
80006b72:	0c c8       	st.b	r6++,r8
80006b74:	00 00       	add	r0,r0
80006b76:	0d 30       	ld.ub	r0,r6++
80006b78:	00 00       	add	r0,r0
80006b7a:	0c 14       	sub	r4,r6
80006b7c:	00 00       	add	r0,r0
80006b7e:	0c 24       	rsub	r4,r6
80006b80:	00 00       	add	r0,r0
80006b82:	0c 18       	sub	r8,r6
80006b84:	00 00       	add	r0,r0
80006b86:	0c 10       	sub	r0,r6
80006b88:	00 00       	add	r0,r0
80006b8a:	0d 24       	ld.uh	r4,r6++
80006b8c:	00 00       	add	r0,r0
80006b8e:	0d 44       	ld.w	r4,--r6
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	5b 12       	cp.w	r2,-15
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	5d 28       	mustr	r8

80006b98 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006b98:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006b9a:	30 09       	mov	r9,0
80006b9c:	1a d9       	st.w	--sp,r9
80006b9e:	1a d9       	st.w	--sp,r9
80006ba0:	1a d9       	st.w	--sp,r9
80006ba2:	12 98       	mov	r8,r9
80006ba4:	e0 6a 01 00 	mov	r10,256
80006ba8:	48 9b       	lddpc	r11,80006bcc <vTaskStartScheduler+0x34>
80006baa:	48 ac       	lddpc	r12,80006bd0 <vTaskStartScheduler+0x38>
80006bac:	f0 1f 00 0a 	mcall	80006bd4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006bb0:	2f dd       	sub	sp,-12
80006bb2:	58 1c       	cp.w	r12,1
80006bb4:	c0 a1       	brne	80006bc8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006bb6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006bb8:	30 19       	mov	r9,1
80006bba:	48 88       	lddpc	r8,80006bd8 <vTaskStartScheduler+0x40>
80006bbc:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006bbe:	30 09       	mov	r9,0
80006bc0:	48 78       	lddpc	r8,80006bdc <vTaskStartScheduler+0x44>
80006bc2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006bc4:	f0 1f 00 07 	mcall	80006be0 <vTaskStartScheduler+0x48>
80006bc8:	d8 02       	popm	pc
80006bca:	00 00       	add	r0,r0
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	dd 18       	*unknown*
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	69 28       	ld.w	r8,r4[0x48]
80006bd4:	80 00       	ld.sh	r0,r0[0x0]
80006bd6:	69 b0       	ld.w	r0,r4[0x6c]
80006bd8:	00 00       	add	r0,r0
80006bda:	0c 18       	sub	r8,r6
80006bdc:	00 00       	add	r0,r0
80006bde:	0d 08       	ld.w	r8,r6++
80006be0:	80 00       	ld.sh	r0,r0[0x0]
80006be2:	5c 2c       	cpc	r12

80006be4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006be4:	16 cc       	st.b	r11++,r12
	return str;
}
80006be6:	5e fb       	retal	r11

80006be8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006be8:	eb cd 40 c0 	pushm	r6-r7,lr
80006bec:	20 3d       	sub	sp,12
80006bee:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006bf0:	30 06       	mov	r6,0
80006bf2:	30 07       	mov	r7,0
80006bf4:	fa e7 00 00 	st.d	sp[0],r6
80006bf8:	30 0c       	mov	r12,0
80006bfa:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006bfc:	58 08       	cp.w	r8,0
80006bfe:	c1 30       	breq	80006c24 <PrintHex+0x3c>
80006c00:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006c02:	1a 9c       	mov	r12,sp
80006c04:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c08:	58 9e       	cp.w	lr,9
80006c0a:	e0 8a 00 04 	brle	80006c12 <PrintHex+0x2a>
80006c0e:	2c 9e       	sub	lr,-55
80006c10:	c0 48       	rjmp	80006c18 <PrintHex+0x30>
80006c12:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c16:	2d 0e       	sub	lr,-48
80006c18:	f8 09 0b 0e 	st.b	r12[r9],lr
80006c1c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006c1e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006c20:	cf 21       	brne	80006c04 <PrintHex+0x1c>
80006c22:	c0 48       	rjmp	80006c2a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006c24:	33 08       	mov	r8,48
80006c26:	ba 88       	st.b	sp[0x0],r8
80006c28:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006c2a:	f6 09 01 08 	sub	r8,r11,r9
80006c2e:	58 08       	cp.w	r8,0
80006c30:	e0 8a 00 13 	brle	80006c56 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006c34:	12 1b       	sub	r11,r9
80006c36:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006c3a:	18 9e       	mov	lr,r12
80006c3c:	58 0c       	cp.w	r12,0
80006c3e:	e0 8a 00 0c 	brle	80006c56 <PrintHex+0x6e>
80006c42:	1a 9b       	mov	r11,sp
80006c44:	12 0b       	add	r11,r9
80006c46:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006c48:	33 07       	mov	r7,48
80006c4a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006c4c:	2f f8       	sub	r8,-1
80006c4e:	1c 38       	cp.w	r8,lr
80006c50:	cf d5       	brlt	80006c4a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c52:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c56:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006c5a:	f0 cb ff ff 	sub	r11,r8,-1
80006c5e:	58 0b       	cp.w	r11,0
80006c60:	e0 8a 00 19 	brle	80006c92 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c64:	fa cb ff f4 	sub	r11,sp,-12
80006c68:	f6 09 00 09 	add	r9,r11,r9
80006c6c:	37 8b       	mov	r11,120
80006c6e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006c72:	fa c9 ff f4 	sub	r9,sp,-12
80006c76:	10 09       	add	r9,r8
80006c78:	33 0b       	mov	r11,48
80006c7a:	f3 6b ff f4 	st.b	r9[-12],r11
80006c7e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c82:	fa ce 00 01 	sub	lr,sp,1
80006c86:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c88:	11 8b       	ld.ub	r11,r8[0x0]
80006c8a:	12 cb       	st.b	r9++,r11
80006c8c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006c8e:	1c 38       	cp.w	r8,lr
80006c90:	cf c1       	brne	80006c88 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006c92:	14 9c       	mov	r12,r10
80006c94:	2f dd       	sub	sp,-12
80006c96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006c9a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006c9a:	d4 21       	pushm	r4-r7,lr
80006c9c:	20 3d       	sub	sp,12
80006c9e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006ca0:	30 06       	mov	r6,0
80006ca2:	30 07       	mov	r7,0
80006ca4:	fa e7 00 00 	st.d	sp[0],r6
80006ca8:	30 0c       	mov	r12,0
80006caa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006cac:	58 08       	cp.w	r8,0
80006cae:	c0 35       	brlt	80006cb4 <PrintDec+0x1a>
80006cb0:	14 97       	mov	r7,r10
80006cb2:	c0 58       	rjmp	80006cbc <PrintDec+0x22>
	{
		*p++ = '-';
80006cb4:	14 97       	mov	r7,r10
80006cb6:	32 d9       	mov	r9,45
80006cb8:	0e c9       	st.b	r7++,r9
		i = -i;
80006cba:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006cbc:	58 08       	cp.w	r8,0
80006cbe:	c0 51       	brne	80006cc8 <PrintDec+0x2e>
80006cc0:	33 08       	mov	r8,48
80006cc2:	ba 88       	st.b	sp[0x0],r8
80006cc4:	30 1e       	mov	lr,1
80006cc6:	c2 f8       	rjmp	80006d24 <PrintDec+0x8a>
	
	int ten = i%10;
80006cc8:	e0 65 66 67 	mov	r5,26215
80006ccc:	ea 15 66 66 	orh	r5,0x6666
80006cd0:	f0 05 04 44 	muls.d	r4,r8,r5
80006cd4:	ea 0c 14 02 	asr	r12,r5,0x2
80006cd8:	f0 09 14 1f 	asr	r9,r8,0x1f
80006cdc:	f8 09 01 09 	sub	r9,r12,r9
80006ce0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ce4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006ce8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006cea:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006cec:	e0 66 66 67 	mov	r6,26215
80006cf0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006cf4:	2d 09       	sub	r9,-48
80006cf6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006cfa:	2f fe       	sub	lr,-1
		i /= 10;
80006cfc:	f0 06 04 44 	muls.d	r4,r8,r6
80006d00:	ea 09 14 02 	asr	r9,r5,0x2
80006d04:	bf 58       	asr	r8,0x1f
80006d06:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006d0a:	f0 06 04 44 	muls.d	r4,r8,r6
80006d0e:	ea 09 14 02 	asr	r9,r5,0x2
80006d12:	f0 05 14 1f 	asr	r5,r8,0x1f
80006d16:	0a 19       	sub	r9,r5
80006d18:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d1c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006d20:	58 08       	cp.w	r8,0
80006d22:	ce 91       	brne	80006cf4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006d24:	f6 0e 01 08 	sub	r8,r11,lr
80006d28:	58 08       	cp.w	r8,0
80006d2a:	e0 89 00 06 	brgt	80006d36 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d2e:	58 0e       	cp.w	lr,0
80006d30:	e0 89 00 14 	brgt	80006d58 <PrintDec+0xbe>
80006d34:	c1 d8       	rjmp	80006d6e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006d36:	1c 1b       	sub	r11,lr
80006d38:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006d3a:	16 9c       	mov	r12,r11
80006d3c:	58 0b       	cp.w	r11,0
80006d3e:	fe 9a ff f8 	brle	80006d2e <PrintDec+0x94>
80006d42:	1a 99       	mov	r9,sp
80006d44:	1c 09       	add	r9,lr
80006d46:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d48:	33 06       	mov	r6,48
80006d4a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d4c:	2f f8       	sub	r8,-1
80006d4e:	18 38       	cp.w	r8,r12
80006d50:	cf d5       	brlt	80006d4a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006d52:	f6 0e 00 0e 	add	lr,r11,lr
80006d56:	ce cb       	rjmp	80006d2e <PrintDec+0x94>
80006d58:	fa c8 ff f4 	sub	r8,sp,-12
80006d5c:	1c 08       	add	r8,lr
80006d5e:	20 d8       	sub	r8,13
80006d60:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d64:	11 89       	ld.ub	r9,r8[0x0]
80006d66:	0e c9       	st.b	r7++,r9
80006d68:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d6a:	16 38       	cp.w	r8,r11
80006d6c:	cf c1       	brne	80006d64 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006d6e:	14 9c       	mov	r12,r10
80006d70:	2f dd       	sub	sp,-12
80006d72:	d8 22       	popm	r4-r7,pc

80006d74 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006d74:	d4 31       	pushm	r0-r7,lr
80006d76:	fa cd 02 08 	sub	sp,sp,520
80006d7a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006d7c:	e0 6a 01 00 	mov	r10,256
80006d80:	30 0b       	mov	r11,0
80006d82:	fa cc fe f8 	sub	r12,sp,-264
80006d86:	f0 1f 00 4e 	mcall	80006ebc <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006d8a:	fa c4 fd d4 	sub	r4,sp,-556
80006d8e:	30 0a       	mov	r10,0
80006d90:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d92:	fa c3 ff fc 	sub	r3,sp,-4
80006d96:	e0 61 01 00 	mov	r1,256
80006d9a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006d9c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006d9e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006da2:	02 9a       	mov	r10,r1
80006da4:	00 9b       	mov	r11,r0
80006da6:	06 9c       	mov	r12,r3
80006da8:	f0 1f 00 45 	mcall	80006ebc <log+0x148>
			
					if(*str == '%')
80006dac:	0f 88       	ld.ub	r8,r7[0x0]
80006dae:	e4 08 18 00 	cp.b	r8,r2
80006db2:	c5 71       	brne	80006e60 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006db4:	ee c8 ff ff 	sub	r8,r7,-1
80006db8:	11 89       	ld.ub	r9,r8[0x0]
80006dba:	4c 2a       	lddpc	r10,80006ec0 <log+0x14c>
80006dbc:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006dbe:	23 09       	sub	r9,48
80006dc0:	30 9a       	mov	r10,9
80006dc2:	f4 09 18 00 	cp.b	r9,r10
80006dc6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006dca:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006dce:	f7 b9 08 30 	subls	r9,48
80006dd2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006dd6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006dda:	0f 88       	ld.ub	r8,r7[0x0]
80006ddc:	22 58       	sub	r8,37
80006dde:	e0 48 00 53 	cp.w	r8,83
80006de2:	e0 8b 00 31 	brhi	80006e44 <log+0xd0>
80006de6:	4b 89       	lddpc	r9,80006ec4 <log+0x150>
80006de8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006dec:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006df0:	06 9a       	mov	r10,r3
80006df2:	40 0b       	lddsp	r11,sp[0x0]
80006df4:	5c 5b       	castu.b	r11
80006df6:	68 0c       	ld.w	r12,r4[0x0]
80006df8:	f0 1f 00 34 	mcall	80006ec8 <log+0x154>
							break;
80006dfc:	c2 98       	rjmp	80006e4e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006dfe:	4b 4c       	lddpc	r12,80006ecc <log+0x158>
80006e00:	f0 1f 00 34 	mcall	80006ed0 <log+0x15c>
80006e04:	08 95       	mov	r5,r4
80006e06:	06 9c       	mov	r12,r3
							break;
80006e08:	c2 38       	rjmp	80006e4e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006e0a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006e0e:	06 9a       	mov	r10,r3
80006e10:	40 0b       	lddsp	r11,sp[0x0]
80006e12:	5c 5b       	castu.b	r11
80006e14:	68 0c       	ld.w	r12,r4[0x0]
80006e16:	f0 1f 00 30 	mcall	80006ed4 <log+0x160>
80006e1a:	06 9c       	mov	r12,r3
							break;
80006e1c:	c1 98       	rjmp	80006e4e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006e1e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006e22:	06 9b       	mov	r11,r3
80006e24:	09 bc       	ld.ub	r12,r4[0x3]
80006e26:	f0 1f 00 2d 	mcall	80006ed8 <log+0x164>
80006e2a:	06 9c       	mov	r12,r3
							break;
80006e2c:	c1 18       	rjmp	80006e4e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006e2e:	e8 c5 ff fc 	sub	r5,r4,-4
80006e32:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006e34:	c0 d8       	rjmp	80006e4e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006e36:	06 9b       	mov	r11,r3
80006e38:	32 5c       	mov	r12,37
80006e3a:	f0 1f 00 28 	mcall	80006ed8 <log+0x164>
80006e3e:	08 95       	mov	r5,r4
80006e40:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006e42:	c0 68       	rjmp	80006e4e <log+0xda>
							
							default:
							log("I need relax.");
80006e44:	4a 6c       	lddpc	r12,80006edc <log+0x168>
80006e46:	f0 1f 00 23 	mcall	80006ed0 <log+0x15c>
80006e4a:	08 95       	mov	r5,r4
80006e4c:	06 9c       	mov	r12,r3
						}
						str++;
80006e4e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e50:	1a dc       	st.w	--sp,r12
80006e52:	1a d6       	st.w	--sp,r6
80006e54:	4a 3b       	lddpc	r11,80006ee0 <log+0x16c>
80006e56:	0c 9c       	mov	r12,r6
80006e58:	f0 1f 00 23 	mcall	80006ee4 <log+0x170>
80006e5c:	2f ed       	sub	sp,-8
80006e5e:	c0 a8       	rjmp	80006e72 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e60:	2f f7       	sub	r7,-1
80006e62:	1a d8       	st.w	--sp,r8
80006e64:	1a d6       	st.w	--sp,r6
80006e66:	4a 1b       	lddpc	r11,80006ee8 <log+0x174>
80006e68:	0c 9c       	mov	r12,r6
80006e6a:	f0 1f 00 1f 	mcall	80006ee4 <log+0x170>
80006e6e:	08 95       	mov	r5,r4
80006e70:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006e72:	0f 89       	ld.ub	r9,r7[0x0]
80006e74:	30 08       	mov	r8,0
80006e76:	f0 09 18 00 	cp.b	r9,r8
80006e7a:	c0 30       	breq	80006e80 <log+0x10c>
80006e7c:	0a 94       	mov	r4,r5
80006e7e:	c9 2b       	rjmp	80006da2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006e80:	fa c7 fe f8 	sub	r7,sp,-264
80006e84:	1a d7       	st.w	--sp,r7
80006e86:	49 ab       	lddpc	r11,80006eec <log+0x178>
80006e88:	0e 9c       	mov	r12,r7
80006e8a:	f0 1f 00 17 	mcall	80006ee4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006e8e:	5c 5c       	castu.b	r12
80006e90:	f8 c6 ff ff 	sub	r6,r12,-1
80006e94:	0c 9c       	mov	r12,r6
80006e96:	f0 1f 00 17 	mcall	80006ef0 <log+0x17c>
80006e9a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006e9c:	0c 9a       	mov	r10,r6
80006e9e:	0e 9b       	mov	r11,r7
80006ea0:	f0 1f 00 15 	mcall	80006ef4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006ea4:	30 09       	mov	r9,0
80006ea6:	30 5a       	mov	r10,5
80006ea8:	fa cb fe f8 	sub	r11,sp,-264
80006eac:	49 38       	lddpc	r8,80006ef8 <log+0x184>
80006eae:	70 0c       	ld.w	r12,r8[0x0]
80006eb0:	f0 1f 00 13 	mcall	80006efc <log+0x188>
80006eb4:	2f fd       	sub	sp,-4
	
	
}
80006eb6:	fe 3d fd f8 	sub	sp,-520
80006eba:	d8 32       	popm	r0-r7,pc
80006ebc:	80 00       	ld.sh	r0,r0[0x0]
80006ebe:	78 76       	ld.w	r6,r12[0x1c]
80006ec0:	00 00       	add	r0,r0
80006ec2:	0d 48       	ld.w	r8,--r6
80006ec4:	80 00       	ld.sh	r0,r0[0x0]
80006ec6:	dd 20       	acall	0xd2
80006ec8:	80 00       	ld.sh	r0,r0[0x0]
80006eca:	6c 9a       	ld.w	r10,r6[0x24]
80006ecc:	80 00       	ld.sh	r0,r0[0x0]
80006ece:	df cc       	*unknown*
80006ed0:	80 00       	ld.sh	r0,r0[0x0]
80006ed2:	6d 74       	ld.w	r4,r6[0x5c]
80006ed4:	80 00       	ld.sh	r0,r0[0x0]
80006ed6:	6b e8       	ld.w	r8,r5[0x78]
80006ed8:	80 00       	ld.sh	r0,r0[0x0]
80006eda:	6b e4       	ld.w	r4,r5[0x78]
80006edc:	80 00       	ld.sh	r0,r0[0x0]
80006ede:	df dc       	*unknown*
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	df ec       	*unknown*
80006ee4:	80 00       	ld.sh	r0,r0[0x0]
80006ee6:	7b 64       	ld.w	r4,sp[0x58]
80006ee8:	80 00       	ld.sh	r0,r0[0x0]
80006eea:	df f4       	*unknown*
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	df fc       	*unknown*
80006ef0:	80 00       	ld.sh	r0,r0[0x0]
80006ef2:	5e 88       	retls	r8
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	77 2e       	ld.w	lr,r11[0x48]
80006ef8:	00 00       	add	r0,r0
80006efa:	63 94       	ld.w	r4,r1[0x64]
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	61 dc       	ld.w	r12,r0[0x74]

80006f00 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006f00:	d4 31       	pushm	r0-r7,lr
80006f02:	fa cd 02 0c 	sub	sp,sp,524
80006f06:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006f08:	e0 6a 01 00 	mov	r10,256
80006f0c:	30 0b       	mov	r11,0
80006f0e:	fa cc fe f4 	sub	r12,sp,-268
80006f12:	f0 1f 00 4c 	mcall	80007040 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006f16:	fa c4 fd d0 	sub	r4,sp,-560
80006f1a:	30 0a       	mov	r10,0
80006f1c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f1e:	fa c3 ff fc 	sub	r3,sp,-4
80006f22:	e0 61 01 00 	mov	r1,256
80006f26:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006f28:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f2a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f2e:	02 9a       	mov	r10,r1
80006f30:	00 9b       	mov	r11,r0
80006f32:	06 9c       	mov	r12,r3
80006f34:	f0 1f 00 43 	mcall	80007040 <logFromISR+0x140>
			
			if(*str == '%')
80006f38:	0f 88       	ld.ub	r8,r7[0x0]
80006f3a:	e4 08 18 00 	cp.b	r8,r2
80006f3e:	c5 11       	brne	80006fe0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006f40:	ee c8 ff ff 	sub	r8,r7,-1
80006f44:	11 89       	ld.ub	r9,r8[0x0]
80006f46:	4c 0a       	lddpc	r10,80007044 <logFromISR+0x144>
80006f48:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006f4a:	23 09       	sub	r9,48
80006f4c:	30 9a       	mov	r10,9
80006f4e:	f4 09 18 00 	cp.b	r9,r10
80006f52:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006f56:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006f5a:	f7 b9 08 30 	subls	r9,48
80006f5e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006f62:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006f66:	0f 88       	ld.ub	r8,r7[0x0]
80006f68:	22 58       	sub	r8,37
80006f6a:	e0 48 00 53 	cp.w	r8,83
80006f6e:	e0 8b 00 2b 	brhi	80006fc4 <logFromISR+0xc4>
80006f72:	4b 69       	lddpc	r9,80007048 <logFromISR+0x148>
80006f74:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006f78:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006f7c:	06 9a       	mov	r10,r3
80006f7e:	40 0b       	lddsp	r11,sp[0x0]
80006f80:	5c 5b       	castu.b	r11
80006f82:	68 0c       	ld.w	r12,r4[0x0]
80006f84:	f0 1f 00 32 	mcall	8000704c <logFromISR+0x14c>
					break;
80006f88:	c2 38       	rjmp	80006fce <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006f8a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006f8e:	06 9a       	mov	r10,r3
80006f90:	40 0b       	lddsp	r11,sp[0x0]
80006f92:	5c 5b       	castu.b	r11
80006f94:	68 0c       	ld.w	r12,r4[0x0]
80006f96:	f0 1f 00 2f 	mcall	80007050 <logFromISR+0x150>
80006f9a:	06 9c       	mov	r12,r3
					break;
80006f9c:	c1 98       	rjmp	80006fce <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006f9e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006fa2:	06 9b       	mov	r11,r3
80006fa4:	09 bc       	ld.ub	r12,r4[0x3]
80006fa6:	f0 1f 00 2c 	mcall	80007054 <logFromISR+0x154>
80006faa:	06 9c       	mov	r12,r3
					break;
80006fac:	c1 18       	rjmp	80006fce <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006fae:	e8 c5 ff fc 	sub	r5,r4,-4
80006fb2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006fb4:	c0 d8       	rjmp	80006fce <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006fb6:	06 9b       	mov	r11,r3
80006fb8:	32 5c       	mov	r12,37
80006fba:	f0 1f 00 27 	mcall	80007054 <logFromISR+0x154>
80006fbe:	08 95       	mov	r5,r4
80006fc0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006fc2:	c0 68       	rjmp	80006fce <logFromISR+0xce>
					default:
					log("I need relax.");
80006fc4:	4a 5c       	lddpc	r12,80007058 <logFromISR+0x158>
80006fc6:	f0 1f 00 26 	mcall	8000705c <logFromISR+0x15c>
80006fca:	08 95       	mov	r5,r4
80006fcc:	06 9c       	mov	r12,r3
				}
				str++;
80006fce:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006fd0:	1a dc       	st.w	--sp,r12
80006fd2:	1a d6       	st.w	--sp,r6
80006fd4:	4a 3b       	lddpc	r11,80007060 <logFromISR+0x160>
80006fd6:	0c 9c       	mov	r12,r6
80006fd8:	f0 1f 00 23 	mcall	80007064 <logFromISR+0x164>
80006fdc:	2f ed       	sub	sp,-8
80006fde:	c0 a8       	rjmp	80006ff2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fe0:	2f f7       	sub	r7,-1
80006fe2:	1a d8       	st.w	--sp,r8
80006fe4:	1a d6       	st.w	--sp,r6
80006fe6:	4a 1b       	lddpc	r11,80007068 <logFromISR+0x168>
80006fe8:	0c 9c       	mov	r12,r6
80006fea:	f0 1f 00 1f 	mcall	80007064 <logFromISR+0x164>
80006fee:	08 95       	mov	r5,r4
80006ff0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006ff2:	0f 89       	ld.ub	r9,r7[0x0]
80006ff4:	30 08       	mov	r8,0
80006ff6:	f0 09 18 00 	cp.b	r9,r8
80006ffa:	c0 30       	breq	80007000 <logFromISR+0x100>
80006ffc:	0a 94       	mov	r4,r5
80006ffe:	c9 8b       	rjmp	80006f2e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007000:	fa c7 fe f4 	sub	r7,sp,-268
80007004:	1a d7       	st.w	--sp,r7
80007006:	49 ab       	lddpc	r11,8000706c <logFromISR+0x16c>
80007008:	0e 9c       	mov	r12,r7
8000700a:	f0 1f 00 17 	mcall	80007064 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000700e:	5c 5c       	castu.b	r12
80007010:	f8 c6 ff ff 	sub	r6,r12,-1
80007014:	0c 9c       	mov	r12,r6
80007016:	f0 1f 00 17 	mcall	80007070 <logFromISR+0x170>
8000701a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000701c:	0c 9a       	mov	r10,r6
8000701e:	0e 9b       	mov	r11,r7
80007020:	f0 1f 00 15 	mcall	80007074 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007024:	30 09       	mov	r9,0
80007026:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007028:	fa ca fe f8 	sub	r10,sp,-264
8000702c:	fa cb fe f4 	sub	r11,sp,-268
80007030:	49 28       	lddpc	r8,80007078 <logFromISR+0x178>
80007032:	70 0c       	ld.w	r12,r8[0x0]
80007034:	f0 1f 00 12 	mcall	8000707c <logFromISR+0x17c>
80007038:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000703a:	fe 3d fd f4 	sub	sp,-524
8000703e:	d8 32       	popm	r0-r7,pc
80007040:	80 00       	ld.sh	r0,r0[0x0]
80007042:	78 76       	ld.w	r6,r12[0x1c]
80007044:	00 00       	add	r0,r0
80007046:	0d 49       	ld.w	r9,--r6
80007048:	80 00       	ld.sh	r0,r0[0x0]
8000704a:	de 70       	acall	0xe7
8000704c:	80 00       	ld.sh	r0,r0[0x0]
8000704e:	6c 9a       	ld.w	r10,r6[0x24]
80007050:	80 00       	ld.sh	r0,r0[0x0]
80007052:	6b e8       	ld.w	r8,r5[0x78]
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	6b e4       	ld.w	r4,r5[0x78]
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	df dc       	*unknown*
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	6d 74       	ld.w	r4,r6[0x5c]
80007060:	80 00       	ld.sh	r0,r0[0x0]
80007062:	df ec       	*unknown*
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	7b 64       	ld.w	r4,sp[0x58]
80007068:	80 00       	ld.sh	r0,r0[0x0]
8000706a:	df f4       	*unknown*
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	df fc       	*unknown*
80007070:	80 00       	ld.sh	r0,r0[0x0]
80007072:	5e 88       	retls	r8
80007074:	80 00       	ld.sh	r0,r0[0x0]
80007076:	77 2e       	ld.w	lr,r11[0x48]
80007078:	00 00       	add	r0,r0
8000707a:	63 94       	ld.w	r4,r1[0x64]
8000707c:	80 00       	ld.sh	r0,r0[0x0]
8000707e:	61 8c       	ld.w	r12,r0[0x60]

80007080 <log_init>:
		
	return str;
}

void log_init(void)
{
80007080:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007082:	30 2b       	mov	r11,2
80007084:	49 0c       	lddpc	r12,800070c4 <log_init+0x44>
80007086:	f0 1f 00 11 	mcall	800070c8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000708a:	e0 6a 36 00 	mov	r10,13824
8000708e:	ea 1a 01 6e 	orh	r10,0x16e
80007092:	48 fb       	lddpc	r11,800070cc <log_init+0x4c>
80007094:	fe 7c 18 00 	mov	r12,-59392
80007098:	f0 1f 00 0e 	mcall	800070d0 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000709c:	30 4b       	mov	r11,4
8000709e:	33 2c       	mov	r12,50
800070a0:	f0 1f 00 0d 	mcall	800070d4 <log_init+0x54>
800070a4:	48 d8       	lddpc	r8,800070d8 <log_init+0x58>
800070a6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800070a8:	30 09       	mov	r9,0
800070aa:	1a d9       	st.w	--sp,r9
800070ac:	1a d9       	st.w	--sp,r9
800070ae:	1a d9       	st.w	--sp,r9
800070b0:	30 28       	mov	r8,2
800070b2:	e0 6a 01 80 	mov	r10,384
800070b6:	48 ab       	lddpc	r11,800070dc <log_init+0x5c>
800070b8:	48 ac       	lddpc	r12,800070e0 <log_init+0x60>
800070ba:	f0 1f 00 0b 	mcall	800070e4 <log_init+0x64>
800070be:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800070c0:	d8 02       	popm	pc
800070c2:	00 00       	add	r0,r0
800070c4:	80 00       	ld.sh	r0,r0[0x0]
800070c6:	e0 08       	*unknown*
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	72 0c       	ld.w	r12,r9[0x0]
800070cc:	80 00       	ld.sh	r0,r0[0x0]
800070ce:	df c0       	acall	0xfc
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	5a 2c       	cp.w	r12,-30
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	62 dc       	ld.w	r12,r1[0x34]
800070d8:	00 00       	add	r0,r0
800070da:	63 94       	ld.w	r4,r1[0x64]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	e0 04       	*unknown*
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	70 e8       	ld.w	r8,r8[0x38]
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	69 b0       	ld.w	r0,r4[0x6c]

800070e8 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800070e8:	eb cd 40 f8 	pushm	r3-r7,lr
800070ec:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070ee:	48 c7       	lddpc	r7,8000711c <task_log+0x34>
800070f0:	30 05       	mov	r5,0
800070f2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800070f4:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070f8:	0a 99       	mov	r9,r5
800070fa:	08 9a       	mov	r10,r4
800070fc:	1a 9b       	mov	r11,sp
800070fe:	6e 0c       	ld.w	r12,r7[0x0]
80007100:	f0 1f 00 08 	mcall	80007120 <task_log+0x38>
80007104:	58 1c       	cp.w	r12,1
80007106:	cf 91       	brne	800070f8 <task_log+0x10>
		{
			if( NULL != str)
80007108:	40 0b       	lddsp	r11,sp[0x0]
8000710a:	58 0b       	cp.w	r11,0
8000710c:	cf 60       	breq	800070f8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000710e:	06 9c       	mov	r12,r3
80007110:	f0 1f 00 05 	mcall	80007124 <task_log+0x3c>
				vPortFree(str);
80007114:	40 0c       	lddsp	r12,sp[0x0]
80007116:	f0 1f 00 05 	mcall	80007128 <task_log+0x40>
8000711a:	ce fb       	rjmp	800070f8 <task_log+0x10>
8000711c:	00 00       	add	r0,r0
8000711e:	63 94       	ld.w	r4,r1[0x64]
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	5f d0       	srvc	r0
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	59 dc       	cp.w	r12,29
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	5e 60       	retmi	r0

8000712c <main>:
#include "fs/fs.h"
#include "rtc/rtc.h"
#include "voice/voice.h"

int main(void)
{
8000712c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000712e:	fe 78 10 00 	mov	r8,-61440
80007132:	30 19       	mov	r9,1
80007134:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007138:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000713c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80007140:	d3 03       	ssrf	0x10
	local_start_pll0();
80007142:	f0 1f 00 13 	mcall	8000718c <main+0x60>
		
	INTC_init_interrupts();
80007146:	f0 1f 00 13 	mcall	80007190 <main+0x64>
	
	log_init();		
8000714a:	f0 1f 00 13 	mcall	80007194 <main+0x68>
	log("----start debug----");	
8000714e:	49 3c       	lddpc	r12,80007198 <main+0x6c>
80007150:	f0 1f 00 13 	mcall	8000719c <main+0x70>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。
	
	voc_init();
80007154:	f0 1f 00 13 	mcall	800071a0 <main+0x74>

	tc_init();	
80007158:	f0 1f 00 13 	mcall	800071a4 <main+0x78>
	
	app_init();
8000715c:	f0 1f 00 13 	mcall	800071a8 <main+0x7c>
	
	xcmp_init();
80007160:	f0 1f 00 13 	mcall	800071ac <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80007164:	fe 79 10 00 	mov	r9,-61440
80007168:	f2 f8 01 60 	ld.w	r8,r9[352]
8000716c:	e2 18 00 02 	andl	r8,0x2,COH
80007170:	cf c0       	breq	80007168 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80007172:	fe 79 10 00 	mov	r9,-61440
80007176:	f2 f8 01 60 	ld.w	r8,r9[352]
8000717a:	e2 18 00 02 	andl	r8,0x2,COH
8000717e:	cf c1       	brne	80007176 <main+0x4a>
	local_start_timer();
80007180:	f0 1f 00 0c 	mcall	800071b0 <main+0x84>
	
	Enable_global_interrupt();
80007184:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80007186:	f0 1f 00 0c 	mcall	800071b4 <main+0x88>
	return 0;
}
8000718a:	d8 0a       	popm	pc,r12=0
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	4d a8       	lddpc	r8,800072f4 <_malloc_r+0x24>
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	54 90       	stdsp	sp[0x124],r0
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	70 80       	ld.w	r0,r8[0x20]
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	e0 18 80 00 	andl	r8,0x8000
8000719e:	6d 74       	ld.w	r4,r6[0x5c]
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	52 40       	stdsp	sp[0x90],r0
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	4e 34       	lddpc	r4,80007330 <_malloc_r+0x60>
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	20 40       	sub	r0,4
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	46 b8       	lddsp	r8,sp[0x1ac]
800071b0:	80 00       	ld.sh	r0,r0[0x0]
800071b2:	4d f8       	lddpc	r8,8000732c <_malloc_r+0x5c>
800071b4:	80 00       	ld.sh	r0,r0[0x0]
800071b6:	6b 98       	ld.w	r8,r5[0x64]

800071b8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800071b8:	f8 08 16 05 	lsr	r8,r12,0x5
800071bc:	a9 68       	lsl	r8,0x8
800071be:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800071c2:	58 1b       	cp.w	r11,1
800071c4:	c0 d0       	breq	800071de <gpio_enable_module_pin+0x26>
800071c6:	c0 63       	brcs	800071d2 <gpio_enable_module_pin+0x1a>
800071c8:	58 2b       	cp.w	r11,2
800071ca:	c1 00       	breq	800071ea <gpio_enable_module_pin+0x32>
800071cc:	58 3b       	cp.w	r11,3
800071ce:	c1 40       	breq	800071f6 <gpio_enable_module_pin+0x3e>
800071d0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800071d2:	30 19       	mov	r9,1
800071d4:	f2 0c 09 49 	lsl	r9,r9,r12
800071d8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800071da:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800071dc:	c1 28       	rjmp	80007200 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800071de:	30 19       	mov	r9,1
800071e0:	f2 0c 09 49 	lsl	r9,r9,r12
800071e4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800071e6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800071e8:	c0 c8       	rjmp	80007200 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800071ea:	30 19       	mov	r9,1
800071ec:	f2 0c 09 49 	lsl	r9,r9,r12
800071f0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800071f2:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800071f4:	c0 68       	rjmp	80007200 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800071f6:	30 19       	mov	r9,1
800071f8:	f2 0c 09 49 	lsl	r9,r9,r12
800071fc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800071fe:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80007200:	30 19       	mov	r9,1
80007202:	f2 0c 09 4c 	lsl	r12,r9,r12
80007206:	91 2c       	st.w	r8[0x8],r12
80007208:	5e fd       	retal	0
8000720a:	d7 03       	nop

8000720c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000720c:	d4 21       	pushm	r4-r7,lr
8000720e:	18 97       	mov	r7,r12
80007210:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80007212:	58 0b       	cp.w	r11,0
80007214:	c0 31       	brne	8000721a <gpio_enable_module+0xe>
80007216:	30 05       	mov	r5,0
80007218:	c0 d8       	rjmp	80007232 <gpio_enable_module+0x26>
8000721a:	30 06       	mov	r6,0
8000721c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000721e:	6e 1b       	ld.w	r11,r7[0x4]
80007220:	6e 0c       	ld.w	r12,r7[0x0]
80007222:	f0 1f 00 06 	mcall	80007238 <gpio_enable_module+0x2c>
80007226:	18 45       	or	r5,r12
		gpiomap++;
80007228:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000722a:	2f f6       	sub	r6,-1
8000722c:	0c 34       	cp.w	r4,r6
8000722e:	fe 9b ff f8 	brhi	8000721e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80007232:	0a 9c       	mov	r12,r5
80007234:	d8 22       	popm	r4-r7,pc
80007236:	00 00       	add	r0,r0
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	71 b8       	ld.w	r8,r8[0x6c]

8000723c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000723c:	f8 08 16 05 	lsr	r8,r12,0x5
80007240:	a9 68       	lsl	r8,0x8
80007242:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80007246:	30 19       	mov	r9,1
80007248:	f2 0c 09 4c 	lsl	r12,r9,r12
8000724c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80007250:	91 1c       	st.w	r8[0x4],r12
}
80007252:	5e fc       	retal	r12

80007254 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80007254:	f8 08 16 05 	lsr	r8,r12,0x5
80007258:	a9 68       	lsl	r8,0x8
8000725a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000725e:	30 19       	mov	r9,1
80007260:	f2 0c 09 4c 	lsl	r12,r9,r12
80007264:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80007268:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000726c:	91 1c       	st.w	r8[0x4],r12
}
8000726e:	5e fc       	retal	r12

80007270 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80007270:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80007274:	fe c0 a6 74 	sub	r0,pc,-22924

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80007278:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000727c:	d5 53       	csrf	0x15
  cp      r0, r1
8000727e:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80007280:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80007284:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80007286:	c0 72       	brcc	80007294 <idata_load_loop_end>
  cp      r0, r1
80007288:	fe c2 8c d8 	sub	r2,pc,-29480

8000728c <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000728c:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000728e:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80007290:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80007292:	cf d3       	brcs	8000728c <idata_load_loop>

80007294 <idata_load_loop_end>:
  mov     r2, 0
80007294:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80007298:	e0 61 63 a0 	mov	r1,25504
  cp      r0, r1
  brlo    udata_clear_loop
8000729c:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000729e:	c0 62       	brcc	800072aa <udata_clear_loop_end>
800072a0:	30 02       	mov	r2,0
800072a2:	30 03       	mov	r3,0

800072a4 <udata_clear_loop>:
800072a4:	a1 22       	st.d	r0++,r2
800072a6:	02 30       	cp.w	r0,r1
800072a8:	cf e3       	brcs	800072a4 <udata_clear_loop>

800072aa <udata_clear_loop_end>:
800072aa:	fe cf 01 7e 	sub	pc,pc,382
800072ae:	d7 03       	nop

800072b0 <free>:
800072b0:	d4 01       	pushm	lr
800072b2:	e0 68 0a 3c 	mov	r8,2620
800072b6:	18 9b       	mov	r11,r12
800072b8:	70 0c       	ld.w	r12,r8[0x0]
800072ba:	e0 a0 1e 7f 	rcall	8000afb8 <_free_r>
800072be:	d8 02       	popm	pc

800072c0 <malloc>:
800072c0:	d4 01       	pushm	lr
800072c2:	e0 68 0a 3c 	mov	r8,2620
800072c6:	18 9b       	mov	r11,r12
800072c8:	70 0c       	ld.w	r12,r8[0x0]
800072ca:	c0 3c       	rcall	800072d0 <_malloc_r>
800072cc:	d8 02       	popm	pc
800072ce:	d7 03       	nop

800072d0 <_malloc_r>:
800072d0:	d4 31       	pushm	r0-r7,lr
800072d2:	f6 c8 ff f5 	sub	r8,r11,-11
800072d6:	18 95       	mov	r5,r12
800072d8:	10 97       	mov	r7,r8
800072da:	e0 17 ff f8 	andl	r7,0xfff8
800072de:	59 68       	cp.w	r8,22
800072e0:	f9 b7 08 10 	movls	r7,16
800072e4:	16 37       	cp.w	r7,r11
800072e6:	5f 38       	srlo	r8
800072e8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800072ec:	c0 50       	breq	800072f6 <_malloc_r+0x26>
800072ee:	30 c8       	mov	r8,12
800072f0:	99 38       	st.w	r12[0xc],r8
800072f2:	e0 8f 01 fa 	bral	800076e6 <_malloc_r+0x416>
800072f6:	fe b0 f5 6b 	rcall	80005dcc <__malloc_lock>
800072fa:	e0 47 01 f7 	cp.w	r7,503
800072fe:	e0 8b 00 1d 	brhi	80007338 <_malloc_r+0x68>
80007302:	ee 03 16 03 	lsr	r3,r7,0x3
80007306:	e0 68 05 3c 	mov	r8,1340
8000730a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000730e:	70 36       	ld.w	r6,r8[0xc]
80007310:	10 36       	cp.w	r6,r8
80007312:	c0 61       	brne	8000731e <_malloc_r+0x4e>
80007314:	ec c8 ff f8 	sub	r8,r6,-8
80007318:	70 36       	ld.w	r6,r8[0xc]
8000731a:	10 36       	cp.w	r6,r8
8000731c:	c0 c0       	breq	80007334 <_malloc_r+0x64>
8000731e:	6c 18       	ld.w	r8,r6[0x4]
80007320:	e0 18 ff fc 	andl	r8,0xfffc
80007324:	6c 3a       	ld.w	r10,r6[0xc]
80007326:	ec 08 00 09 	add	r9,r6,r8
8000732a:	0a 9c       	mov	r12,r5
8000732c:	6c 28       	ld.w	r8,r6[0x8]
8000732e:	95 28       	st.w	r10[0x8],r8
80007330:	91 3a       	st.w	r8[0xc],r10
80007332:	c4 78       	rjmp	800073c0 <_malloc_r+0xf0>
80007334:	2f e3       	sub	r3,-2
80007336:	c4 d8       	rjmp	800073d0 <_malloc_r+0x100>
80007338:	ee 03 16 09 	lsr	r3,r7,0x9
8000733c:	c0 41       	brne	80007344 <_malloc_r+0x74>
8000733e:	ee 03 16 03 	lsr	r3,r7,0x3
80007342:	c2 68       	rjmp	8000738e <_malloc_r+0xbe>
80007344:	58 43       	cp.w	r3,4
80007346:	e0 8b 00 06 	brhi	80007352 <_malloc_r+0x82>
8000734a:	ee 03 16 06 	lsr	r3,r7,0x6
8000734e:	2c 83       	sub	r3,-56
80007350:	c1 f8       	rjmp	8000738e <_malloc_r+0xbe>
80007352:	59 43       	cp.w	r3,20
80007354:	e0 8b 00 04 	brhi	8000735c <_malloc_r+0x8c>
80007358:	2a 53       	sub	r3,-91
8000735a:	c1 a8       	rjmp	8000738e <_malloc_r+0xbe>
8000735c:	e0 43 00 54 	cp.w	r3,84
80007360:	e0 8b 00 06 	brhi	8000736c <_malloc_r+0x9c>
80007364:	ee 03 16 0c 	lsr	r3,r7,0xc
80007368:	29 23       	sub	r3,-110
8000736a:	c1 28       	rjmp	8000738e <_malloc_r+0xbe>
8000736c:	e0 43 01 54 	cp.w	r3,340
80007370:	e0 8b 00 06 	brhi	8000737c <_malloc_r+0xac>
80007374:	ee 03 16 0f 	lsr	r3,r7,0xf
80007378:	28 93       	sub	r3,-119
8000737a:	c0 a8       	rjmp	8000738e <_malloc_r+0xbe>
8000737c:	e0 43 05 54 	cp.w	r3,1364
80007380:	e0 88 00 04 	brls	80007388 <_malloc_r+0xb8>
80007384:	37 e3       	mov	r3,126
80007386:	c0 48       	rjmp	8000738e <_malloc_r+0xbe>
80007388:	ee 03 16 12 	lsr	r3,r7,0x12
8000738c:	28 43       	sub	r3,-124
8000738e:	e0 6a 05 3c 	mov	r10,1340
80007392:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007396:	74 36       	ld.w	r6,r10[0xc]
80007398:	c1 98       	rjmp	800073ca <_malloc_r+0xfa>
8000739a:	6c 19       	ld.w	r9,r6[0x4]
8000739c:	e0 19 ff fc 	andl	r9,0xfffc
800073a0:	f2 07 01 0b 	sub	r11,r9,r7
800073a4:	58 fb       	cp.w	r11,15
800073a6:	e0 8a 00 04 	brle	800073ae <_malloc_r+0xde>
800073aa:	20 13       	sub	r3,1
800073ac:	c1 18       	rjmp	800073ce <_malloc_r+0xfe>
800073ae:	6c 38       	ld.w	r8,r6[0xc]
800073b0:	58 0b       	cp.w	r11,0
800073b2:	c0 b5       	brlt	800073c8 <_malloc_r+0xf8>
800073b4:	6c 2a       	ld.w	r10,r6[0x8]
800073b6:	ec 09 00 09 	add	r9,r6,r9
800073ba:	0a 9c       	mov	r12,r5
800073bc:	91 2a       	st.w	r8[0x8],r10
800073be:	95 38       	st.w	r10[0xc],r8
800073c0:	72 18       	ld.w	r8,r9[0x4]
800073c2:	a1 a8       	sbr	r8,0x0
800073c4:	93 18       	st.w	r9[0x4],r8
800073c6:	cb c8       	rjmp	8000753e <_malloc_r+0x26e>
800073c8:	10 96       	mov	r6,r8
800073ca:	14 36       	cp.w	r6,r10
800073cc:	ce 71       	brne	8000739a <_malloc_r+0xca>
800073ce:	2f f3       	sub	r3,-1
800073d0:	e0 6a 05 3c 	mov	r10,1340
800073d4:	f4 cc ff f8 	sub	r12,r10,-8
800073d8:	78 26       	ld.w	r6,r12[0x8]
800073da:	18 36       	cp.w	r6,r12
800073dc:	c6 c0       	breq	800074b4 <_malloc_r+0x1e4>
800073de:	6c 19       	ld.w	r9,r6[0x4]
800073e0:	e0 19 ff fc 	andl	r9,0xfffc
800073e4:	f2 07 01 08 	sub	r8,r9,r7
800073e8:	58 f8       	cp.w	r8,15
800073ea:	e0 89 00 8f 	brgt	80007508 <_malloc_r+0x238>
800073ee:	99 3c       	st.w	r12[0xc],r12
800073f0:	99 2c       	st.w	r12[0x8],r12
800073f2:	58 08       	cp.w	r8,0
800073f4:	c0 55       	brlt	800073fe <_malloc_r+0x12e>
800073f6:	ec 09 00 09 	add	r9,r6,r9
800073fa:	0a 9c       	mov	r12,r5
800073fc:	ce 2b       	rjmp	800073c0 <_malloc_r+0xf0>
800073fe:	e0 49 01 ff 	cp.w	r9,511
80007402:	e0 8b 00 13 	brhi	80007428 <_malloc_r+0x158>
80007406:	a3 99       	lsr	r9,0x3
80007408:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000740c:	70 2b       	ld.w	r11,r8[0x8]
8000740e:	8d 38       	st.w	r6[0xc],r8
80007410:	8d 2b       	st.w	r6[0x8],r11
80007412:	97 36       	st.w	r11[0xc],r6
80007414:	91 26       	st.w	r8[0x8],r6
80007416:	a3 49       	asr	r9,0x2
80007418:	74 18       	ld.w	r8,r10[0x4]
8000741a:	30 1b       	mov	r11,1
8000741c:	f6 09 09 49 	lsl	r9,r11,r9
80007420:	f1 e9 10 09 	or	r9,r8,r9
80007424:	95 19       	st.w	r10[0x4],r9
80007426:	c4 78       	rjmp	800074b4 <_malloc_r+0x1e4>
80007428:	f2 0a 16 09 	lsr	r10,r9,0x9
8000742c:	58 4a       	cp.w	r10,4
8000742e:	e0 8b 00 07 	brhi	8000743c <_malloc_r+0x16c>
80007432:	f2 0a 16 06 	lsr	r10,r9,0x6
80007436:	2c 8a       	sub	r10,-56
80007438:	c2 08       	rjmp	80007478 <_malloc_r+0x1a8>
8000743a:	d7 03       	nop
8000743c:	59 4a       	cp.w	r10,20
8000743e:	e0 8b 00 04 	brhi	80007446 <_malloc_r+0x176>
80007442:	2a 5a       	sub	r10,-91
80007444:	c1 a8       	rjmp	80007478 <_malloc_r+0x1a8>
80007446:	e0 4a 00 54 	cp.w	r10,84
8000744a:	e0 8b 00 06 	brhi	80007456 <_malloc_r+0x186>
8000744e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007452:	29 2a       	sub	r10,-110
80007454:	c1 28       	rjmp	80007478 <_malloc_r+0x1a8>
80007456:	e0 4a 01 54 	cp.w	r10,340
8000745a:	e0 8b 00 06 	brhi	80007466 <_malloc_r+0x196>
8000745e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007462:	28 9a       	sub	r10,-119
80007464:	c0 a8       	rjmp	80007478 <_malloc_r+0x1a8>
80007466:	e0 4a 05 54 	cp.w	r10,1364
8000746a:	e0 88 00 04 	brls	80007472 <_malloc_r+0x1a2>
8000746e:	37 ea       	mov	r10,126
80007470:	c0 48       	rjmp	80007478 <_malloc_r+0x1a8>
80007472:	f2 0a 16 12 	lsr	r10,r9,0x12
80007476:	28 4a       	sub	r10,-124
80007478:	e0 6b 05 3c 	mov	r11,1340
8000747c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007480:	68 28       	ld.w	r8,r4[0x8]
80007482:	08 38       	cp.w	r8,r4
80007484:	c0 e1       	brne	800074a0 <_malloc_r+0x1d0>
80007486:	76 19       	ld.w	r9,r11[0x4]
80007488:	a3 4a       	asr	r10,0x2
8000748a:	30 1e       	mov	lr,1
8000748c:	fc 0a 09 4a 	lsl	r10,lr,r10
80007490:	f3 ea 10 0a 	or	r10,r9,r10
80007494:	10 99       	mov	r9,r8
80007496:	97 1a       	st.w	r11[0x4],r10
80007498:	c0 a8       	rjmp	800074ac <_malloc_r+0x1dc>
8000749a:	70 28       	ld.w	r8,r8[0x8]
8000749c:	08 38       	cp.w	r8,r4
8000749e:	c0 60       	breq	800074aa <_malloc_r+0x1da>
800074a0:	70 1a       	ld.w	r10,r8[0x4]
800074a2:	e0 1a ff fc 	andl	r10,0xfffc
800074a6:	14 39       	cp.w	r9,r10
800074a8:	cf 93       	brcs	8000749a <_malloc_r+0x1ca>
800074aa:	70 39       	ld.w	r9,r8[0xc]
800074ac:	8d 39       	st.w	r6[0xc],r9
800074ae:	8d 28       	st.w	r6[0x8],r8
800074b0:	91 36       	st.w	r8[0xc],r6
800074b2:	93 26       	st.w	r9[0x8],r6
800074b4:	e6 08 14 02 	asr	r8,r3,0x2
800074b8:	30 1b       	mov	r11,1
800074ba:	e0 64 05 3c 	mov	r4,1340
800074be:	f6 08 09 4b 	lsl	r11,r11,r8
800074c2:	68 18       	ld.w	r8,r4[0x4]
800074c4:	10 3b       	cp.w	r11,r8
800074c6:	e0 8b 00 6b 	brhi	8000759c <_malloc_r+0x2cc>
800074ca:	f7 e8 00 09 	and	r9,r11,r8
800074ce:	c0 b1       	brne	800074e4 <_malloc_r+0x214>
800074d0:	e0 13 ff fc 	andl	r3,0xfffc
800074d4:	a1 7b       	lsl	r11,0x1
800074d6:	2f c3       	sub	r3,-4
800074d8:	c0 38       	rjmp	800074de <_malloc_r+0x20e>
800074da:	2f c3       	sub	r3,-4
800074dc:	a1 7b       	lsl	r11,0x1
800074de:	f7 e8 00 09 	and	r9,r11,r8
800074e2:	cf c0       	breq	800074da <_malloc_r+0x20a>
800074e4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800074e8:	06 92       	mov	r2,r3
800074ea:	1c 91       	mov	r1,lr
800074ec:	62 36       	ld.w	r6,r1[0xc]
800074ee:	c2 e8       	rjmp	8000754a <_malloc_r+0x27a>
800074f0:	6c 1a       	ld.w	r10,r6[0x4]
800074f2:	e0 1a ff fc 	andl	r10,0xfffc
800074f6:	f4 07 01 08 	sub	r8,r10,r7
800074fa:	58 f8       	cp.w	r8,15
800074fc:	e0 8a 00 15 	brle	80007526 <_malloc_r+0x256>
80007500:	6c 3a       	ld.w	r10,r6[0xc]
80007502:	6c 29       	ld.w	r9,r6[0x8]
80007504:	95 29       	st.w	r10[0x8],r9
80007506:	93 3a       	st.w	r9[0xc],r10
80007508:	0e 99       	mov	r9,r7
8000750a:	ec 07 00 07 	add	r7,r6,r7
8000750e:	a1 a9       	sbr	r9,0x0
80007510:	99 37       	st.w	r12[0xc],r7
80007512:	99 27       	st.w	r12[0x8],r7
80007514:	8d 19       	st.w	r6[0x4],r9
80007516:	ee 08 09 08 	st.w	r7[r8],r8
8000751a:	8f 2c       	st.w	r7[0x8],r12
8000751c:	8f 3c       	st.w	r7[0xc],r12
8000751e:	a1 a8       	sbr	r8,0x0
80007520:	0a 9c       	mov	r12,r5
80007522:	8f 18       	st.w	r7[0x4],r8
80007524:	c0 d8       	rjmp	8000753e <_malloc_r+0x26e>
80007526:	6c 39       	ld.w	r9,r6[0xc]
80007528:	58 08       	cp.w	r8,0
8000752a:	c0 f5       	brlt	80007548 <_malloc_r+0x278>
8000752c:	ec 0a 00 0a 	add	r10,r6,r10
80007530:	74 18       	ld.w	r8,r10[0x4]
80007532:	a1 a8       	sbr	r8,0x0
80007534:	0a 9c       	mov	r12,r5
80007536:	95 18       	st.w	r10[0x4],r8
80007538:	6c 28       	ld.w	r8,r6[0x8]
8000753a:	93 28       	st.w	r9[0x8],r8
8000753c:	91 39       	st.w	r8[0xc],r9
8000753e:	fe b0 f4 4d 	rcall	80005dd8 <__malloc_unlock>
80007542:	ec cc ff f8 	sub	r12,r6,-8
80007546:	d8 32       	popm	r0-r7,pc
80007548:	12 96       	mov	r6,r9
8000754a:	02 36       	cp.w	r6,r1
8000754c:	cd 21       	brne	800074f0 <_malloc_r+0x220>
8000754e:	2f f2       	sub	r2,-1
80007550:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007554:	c0 30       	breq	8000755a <_malloc_r+0x28a>
80007556:	2f 81       	sub	r1,-8
80007558:	cc ab       	rjmp	800074ec <_malloc_r+0x21c>
8000755a:	1c 98       	mov	r8,lr
8000755c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007560:	c0 81       	brne	80007570 <_malloc_r+0x2a0>
80007562:	68 19       	ld.w	r9,r4[0x4]
80007564:	f6 08 11 ff 	rsub	r8,r11,-1
80007568:	f3 e8 00 08 	and	r8,r9,r8
8000756c:	89 18       	st.w	r4[0x4],r8
8000756e:	c0 78       	rjmp	8000757c <_malloc_r+0x2ac>
80007570:	f0 c9 00 08 	sub	r9,r8,8
80007574:	20 13       	sub	r3,1
80007576:	70 08       	ld.w	r8,r8[0x0]
80007578:	12 38       	cp.w	r8,r9
8000757a:	cf 10       	breq	8000755c <_malloc_r+0x28c>
8000757c:	a1 7b       	lsl	r11,0x1
8000757e:	68 18       	ld.w	r8,r4[0x4]
80007580:	10 3b       	cp.w	r11,r8
80007582:	e0 8b 00 0d 	brhi	8000759c <_malloc_r+0x2cc>
80007586:	58 0b       	cp.w	r11,0
80007588:	c0 a0       	breq	8000759c <_malloc_r+0x2cc>
8000758a:	04 93       	mov	r3,r2
8000758c:	c0 38       	rjmp	80007592 <_malloc_r+0x2c2>
8000758e:	2f c3       	sub	r3,-4
80007590:	a1 7b       	lsl	r11,0x1
80007592:	f7 e8 00 09 	and	r9,r11,r8
80007596:	ca 71       	brne	800074e4 <_malloc_r+0x214>
80007598:	cf bb       	rjmp	8000758e <_malloc_r+0x2be>
8000759a:	d7 03       	nop
8000759c:	68 23       	ld.w	r3,r4[0x8]
8000759e:	66 12       	ld.w	r2,r3[0x4]
800075a0:	e0 12 ff fc 	andl	r2,0xfffc
800075a4:	0e 32       	cp.w	r2,r7
800075a6:	5f 39       	srlo	r9
800075a8:	e4 07 01 08 	sub	r8,r2,r7
800075ac:	58 f8       	cp.w	r8,15
800075ae:	5f aa       	srle	r10
800075b0:	f5 e9 10 09 	or	r9,r10,r9
800075b4:	e0 80 00 9a 	breq	800076e8 <_malloc_r+0x418>
800075b8:	e0 68 0d 54 	mov	r8,3412
800075bc:	70 01       	ld.w	r1,r8[0x0]
800075be:	e0 68 09 48 	mov	r8,2376
800075c2:	2f 01       	sub	r1,-16
800075c4:	70 08       	ld.w	r8,r8[0x0]
800075c6:	0e 01       	add	r1,r7
800075c8:	5b f8       	cp.w	r8,-1
800075ca:	c0 40       	breq	800075d2 <_malloc_r+0x302>
800075cc:	28 11       	sub	r1,-127
800075ce:	e0 11 ff 80 	andl	r1,0xff80
800075d2:	02 9b       	mov	r11,r1
800075d4:	0a 9c       	mov	r12,r5
800075d6:	e0 a0 02 b7 	rcall	80007b44 <_sbrk_r>
800075da:	18 96       	mov	r6,r12
800075dc:	5b fc       	cp.w	r12,-1
800075de:	c7 50       	breq	800076c8 <_malloc_r+0x3f8>
800075e0:	e6 02 00 08 	add	r8,r3,r2
800075e4:	10 3c       	cp.w	r12,r8
800075e6:	c0 32       	brcc	800075ec <_malloc_r+0x31c>
800075e8:	08 33       	cp.w	r3,r4
800075ea:	c6 f1       	brne	800076c8 <_malloc_r+0x3f8>
800075ec:	e0 6a 0d 58 	mov	r10,3416
800075f0:	74 09       	ld.w	r9,r10[0x0]
800075f2:	e2 09 00 09 	add	r9,r1,r9
800075f6:	95 09       	st.w	r10[0x0],r9
800075f8:	10 36       	cp.w	r6,r8
800075fa:	c0 a1       	brne	8000760e <_malloc_r+0x33e>
800075fc:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007600:	c0 71       	brne	8000760e <_malloc_r+0x33e>
80007602:	e2 02 00 02 	add	r2,r1,r2
80007606:	68 28       	ld.w	r8,r4[0x8]
80007608:	a1 a2       	sbr	r2,0x0
8000760a:	91 12       	st.w	r8[0x4],r2
8000760c:	c4 f8       	rjmp	800076aa <_malloc_r+0x3da>
8000760e:	e0 6a 09 48 	mov	r10,2376
80007612:	74 0b       	ld.w	r11,r10[0x0]
80007614:	5b fb       	cp.w	r11,-1
80007616:	c0 31       	brne	8000761c <_malloc_r+0x34c>
80007618:	95 06       	st.w	r10[0x0],r6
8000761a:	c0 78       	rjmp	80007628 <_malloc_r+0x358>
8000761c:	ec 09 00 09 	add	r9,r6,r9
80007620:	e0 6a 0d 58 	mov	r10,3416
80007624:	10 19       	sub	r9,r8
80007626:	95 09       	st.w	r10[0x0],r9
80007628:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000762c:	f0 09 11 08 	rsub	r9,r8,8
80007630:	58 08       	cp.w	r8,0
80007632:	f2 08 17 10 	movne	r8,r9
80007636:	ed d8 e1 06 	addne	r6,r6,r8
8000763a:	28 08       	sub	r8,-128
8000763c:	ec 01 00 01 	add	r1,r6,r1
80007640:	0a 9c       	mov	r12,r5
80007642:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007646:	f0 01 01 01 	sub	r1,r8,r1
8000764a:	02 9b       	mov	r11,r1
8000764c:	e0 a0 02 7c 	rcall	80007b44 <_sbrk_r>
80007650:	e0 68 0d 58 	mov	r8,3416
80007654:	5b fc       	cp.w	r12,-1
80007656:	ec 0c 17 00 	moveq	r12,r6
8000765a:	f9 b1 00 00 	moveq	r1,0
8000765e:	70 09       	ld.w	r9,r8[0x0]
80007660:	0c 1c       	sub	r12,r6
80007662:	89 26       	st.w	r4[0x8],r6
80007664:	02 0c       	add	r12,r1
80007666:	12 01       	add	r1,r9
80007668:	a1 ac       	sbr	r12,0x0
8000766a:	91 01       	st.w	r8[0x0],r1
8000766c:	8d 1c       	st.w	r6[0x4],r12
8000766e:	08 33       	cp.w	r3,r4
80007670:	c1 d0       	breq	800076aa <_malloc_r+0x3da>
80007672:	58 f2       	cp.w	r2,15
80007674:	e0 8b 00 05 	brhi	8000767e <_malloc_r+0x3ae>
80007678:	30 18       	mov	r8,1
8000767a:	8d 18       	st.w	r6[0x4],r8
8000767c:	c2 68       	rjmp	800076c8 <_malloc_r+0x3f8>
8000767e:	30 59       	mov	r9,5
80007680:	20 c2       	sub	r2,12
80007682:	e0 12 ff f8 	andl	r2,0xfff8
80007686:	e6 02 00 08 	add	r8,r3,r2
8000768a:	91 29       	st.w	r8[0x8],r9
8000768c:	91 19       	st.w	r8[0x4],r9
8000768e:	66 18       	ld.w	r8,r3[0x4]
80007690:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007694:	e5 e8 10 08 	or	r8,r2,r8
80007698:	87 18       	st.w	r3[0x4],r8
8000769a:	58 f2       	cp.w	r2,15
8000769c:	e0 88 00 07 	brls	800076aa <_malloc_r+0x3da>
800076a0:	e6 cb ff f8 	sub	r11,r3,-8
800076a4:	0a 9c       	mov	r12,r5
800076a6:	e0 a0 1c 89 	rcall	8000afb8 <_free_r>
800076aa:	e0 69 0d 50 	mov	r9,3408
800076ae:	72 0a       	ld.w	r10,r9[0x0]
800076b0:	e0 68 0d 58 	mov	r8,3416
800076b4:	70 08       	ld.w	r8,r8[0x0]
800076b6:	14 38       	cp.w	r8,r10
800076b8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800076bc:	e0 69 0d 4c 	mov	r9,3404
800076c0:	72 0a       	ld.w	r10,r9[0x0]
800076c2:	14 38       	cp.w	r8,r10
800076c4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800076c8:	68 28       	ld.w	r8,r4[0x8]
800076ca:	70 18       	ld.w	r8,r8[0x4]
800076cc:	e0 18 ff fc 	andl	r8,0xfffc
800076d0:	0e 38       	cp.w	r8,r7
800076d2:	5f 39       	srlo	r9
800076d4:	0e 18       	sub	r8,r7
800076d6:	58 f8       	cp.w	r8,15
800076d8:	5f aa       	srle	r10
800076da:	f5 e9 10 09 	or	r9,r10,r9
800076de:	c0 50       	breq	800076e8 <_malloc_r+0x418>
800076e0:	0a 9c       	mov	r12,r5
800076e2:	fe b0 f3 7b 	rcall	80005dd8 <__malloc_unlock>
800076e6:	d8 3a       	popm	r0-r7,pc,r12=0
800076e8:	68 26       	ld.w	r6,r4[0x8]
800076ea:	a1 a8       	sbr	r8,0x0
800076ec:	0e 99       	mov	r9,r7
800076ee:	a1 a9       	sbr	r9,0x0
800076f0:	8d 19       	st.w	r6[0x4],r9
800076f2:	ec 07 00 07 	add	r7,r6,r7
800076f6:	0a 9c       	mov	r12,r5
800076f8:	89 27       	st.w	r4[0x8],r7
800076fa:	8f 18       	st.w	r7[0x4],r8
800076fc:	fe b0 f3 6e 	rcall	80005dd8 <__malloc_unlock>
80007700:	ec cc ff f8 	sub	r12,r6,-8
80007704:	d8 32       	popm	r0-r7,pc
80007706:	d7 03       	nop

80007708 <memcmp>:
80007708:	d4 01       	pushm	lr
8000770a:	30 08       	mov	r8,0
8000770c:	c0 d8       	rjmp	80007726 <memcmp+0x1e>
8000770e:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80007712:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007716:	20 1a       	sub	r10,1
80007718:	2f f8       	sub	r8,-1
8000771a:	f2 0e 18 00 	cp.b	lr,r9
8000771e:	c0 40       	breq	80007726 <memcmp+0x1e>
80007720:	fc 09 01 0c 	sub	r12,lr,r9
80007724:	d8 02       	popm	pc
80007726:	58 0a       	cp.w	r10,0
80007728:	cf 31       	brne	8000770e <memcmp+0x6>
8000772a:	14 9c       	mov	r12,r10
8000772c:	d8 02       	popm	pc

8000772e <memcpy>:
8000772e:	58 8a       	cp.w	r10,8
80007730:	c2 f5       	brlt	8000778e <memcpy+0x60>
80007732:	f9 eb 10 09 	or	r9,r12,r11
80007736:	e2 19 00 03 	andl	r9,0x3,COH
8000773a:	e0 81 00 97 	brne	80007868 <memcpy+0x13a>
8000773e:	e0 4a 00 20 	cp.w	r10,32
80007742:	c3 b4       	brge	800077b8 <memcpy+0x8a>
80007744:	f4 08 14 02 	asr	r8,r10,0x2
80007748:	f0 09 11 08 	rsub	r9,r8,8
8000774c:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007750:	76 69       	ld.w	r9,r11[0x18]
80007752:	99 69       	st.w	r12[0x18],r9
80007754:	76 59       	ld.w	r9,r11[0x14]
80007756:	99 59       	st.w	r12[0x14],r9
80007758:	76 49       	ld.w	r9,r11[0x10]
8000775a:	99 49       	st.w	r12[0x10],r9
8000775c:	76 39       	ld.w	r9,r11[0xc]
8000775e:	99 39       	st.w	r12[0xc],r9
80007760:	76 29       	ld.w	r9,r11[0x8]
80007762:	99 29       	st.w	r12[0x8],r9
80007764:	76 19       	ld.w	r9,r11[0x4]
80007766:	99 19       	st.w	r12[0x4],r9
80007768:	76 09       	ld.w	r9,r11[0x0]
8000776a:	99 09       	st.w	r12[0x0],r9
8000776c:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007770:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007774:	e0 1a 00 03 	andl	r10,0x3
80007778:	f4 0a 11 04 	rsub	r10,r10,4
8000777c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007780:	17 a9       	ld.ub	r9,r11[0x2]
80007782:	b0 a9       	st.b	r8[0x2],r9
80007784:	17 99       	ld.ub	r9,r11[0x1]
80007786:	b0 99       	st.b	r8[0x1],r9
80007788:	17 89       	ld.ub	r9,r11[0x0]
8000778a:	b0 89       	st.b	r8[0x0],r9
8000778c:	5e fc       	retal	r12
8000778e:	f4 0a 11 09 	rsub	r10,r10,9
80007792:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007796:	17 f9       	ld.ub	r9,r11[0x7]
80007798:	b8 f9       	st.b	r12[0x7],r9
8000779a:	17 e9       	ld.ub	r9,r11[0x6]
8000779c:	b8 e9       	st.b	r12[0x6],r9
8000779e:	17 d9       	ld.ub	r9,r11[0x5]
800077a0:	b8 d9       	st.b	r12[0x5],r9
800077a2:	17 c9       	ld.ub	r9,r11[0x4]
800077a4:	b8 c9       	st.b	r12[0x4],r9
800077a6:	17 b9       	ld.ub	r9,r11[0x3]
800077a8:	b8 b9       	st.b	r12[0x3],r9
800077aa:	17 a9       	ld.ub	r9,r11[0x2]
800077ac:	b8 a9       	st.b	r12[0x2],r9
800077ae:	17 99       	ld.ub	r9,r11[0x1]
800077b0:	b8 99       	st.b	r12[0x1],r9
800077b2:	17 89       	ld.ub	r9,r11[0x0]
800077b4:	b8 89       	st.b	r12[0x0],r9
800077b6:	5e fc       	retal	r12
800077b8:	eb cd 40 c0 	pushm	r6-r7,lr
800077bc:	18 99       	mov	r9,r12
800077be:	22 0a       	sub	r10,32
800077c0:	b7 07       	ld.d	r6,r11++
800077c2:	b3 26       	st.d	r9++,r6
800077c4:	b7 07       	ld.d	r6,r11++
800077c6:	b3 26       	st.d	r9++,r6
800077c8:	b7 07       	ld.d	r6,r11++
800077ca:	b3 26       	st.d	r9++,r6
800077cc:	b7 07       	ld.d	r6,r11++
800077ce:	b3 26       	st.d	r9++,r6
800077d0:	22 0a       	sub	r10,32
800077d2:	cf 74       	brge	800077c0 <memcpy+0x92>
800077d4:	2f 0a       	sub	r10,-16
800077d6:	c0 65       	brlt	800077e2 <memcpy+0xb4>
800077d8:	b7 07       	ld.d	r6,r11++
800077da:	b3 26       	st.d	r9++,r6
800077dc:	b7 07       	ld.d	r6,r11++
800077de:	b3 26       	st.d	r9++,r6
800077e0:	21 0a       	sub	r10,16
800077e2:	5c 3a       	neg	r10
800077e4:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800077e8:	d7 03       	nop
800077ea:	d7 03       	nop
800077ec:	f7 36 00 0e 	ld.ub	r6,r11[14]
800077f0:	f3 66 00 0e 	st.b	r9[14],r6
800077f4:	f7 36 00 0d 	ld.ub	r6,r11[13]
800077f8:	f3 66 00 0d 	st.b	r9[13],r6
800077fc:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007800:	f3 66 00 0c 	st.b	r9[12],r6
80007804:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007808:	f3 66 00 0b 	st.b	r9[11],r6
8000780c:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007810:	f3 66 00 0a 	st.b	r9[10],r6
80007814:	f7 36 00 09 	ld.ub	r6,r11[9]
80007818:	f3 66 00 09 	st.b	r9[9],r6
8000781c:	f7 36 00 08 	ld.ub	r6,r11[8]
80007820:	f3 66 00 08 	st.b	r9[8],r6
80007824:	f7 36 00 07 	ld.ub	r6,r11[7]
80007828:	f3 66 00 07 	st.b	r9[7],r6
8000782c:	f7 36 00 06 	ld.ub	r6,r11[6]
80007830:	f3 66 00 06 	st.b	r9[6],r6
80007834:	f7 36 00 05 	ld.ub	r6,r11[5]
80007838:	f3 66 00 05 	st.b	r9[5],r6
8000783c:	f7 36 00 04 	ld.ub	r6,r11[4]
80007840:	f3 66 00 04 	st.b	r9[4],r6
80007844:	f7 36 00 03 	ld.ub	r6,r11[3]
80007848:	f3 66 00 03 	st.b	r9[3],r6
8000784c:	f7 36 00 02 	ld.ub	r6,r11[2]
80007850:	f3 66 00 02 	st.b	r9[2],r6
80007854:	f7 36 00 01 	ld.ub	r6,r11[1]
80007858:	f3 66 00 01 	st.b	r9[1],r6
8000785c:	f7 36 00 00 	ld.ub	r6,r11[0]
80007860:	f3 66 00 00 	st.b	r9[0],r6
80007864:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007868:	20 1a       	sub	r10,1
8000786a:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000786e:	f8 0a 0b 09 	st.b	r12[r10],r9
80007872:	cf b1       	brne	80007868 <memcpy+0x13a>
80007874:	5e fc       	retal	r12

80007876 <memset>:
80007876:	18 98       	mov	r8,r12
80007878:	c0 38       	rjmp	8000787e <memset+0x8>
8000787a:	10 cb       	st.b	r8++,r11
8000787c:	20 1a       	sub	r10,1
8000787e:	58 0a       	cp.w	r10,0
80007880:	cf d1       	brne	8000787a <memset+0x4>
80007882:	5e fc       	retal	r12

80007884 <_realloc_r>:
80007884:	d4 31       	pushm	r0-r7,lr
80007886:	20 1d       	sub	sp,4
80007888:	16 94       	mov	r4,r11
8000788a:	18 92       	mov	r2,r12
8000788c:	14 9b       	mov	r11,r10
8000788e:	58 04       	cp.w	r4,0
80007890:	c0 51       	brne	8000789a <_realloc_r+0x16>
80007892:	fe b0 fd 1f 	rcall	800072d0 <_malloc_r>
80007896:	18 95       	mov	r5,r12
80007898:	c5 39       	rjmp	80007b3e <_realloc_r+0x2ba>
8000789a:	50 0a       	stdsp	sp[0x0],r10
8000789c:	fe b0 f2 98 	rcall	80005dcc <__malloc_lock>
800078a0:	40 0b       	lddsp	r11,sp[0x0]
800078a2:	f6 c8 ff f5 	sub	r8,r11,-11
800078a6:	e8 c1 00 08 	sub	r1,r4,8
800078aa:	10 96       	mov	r6,r8
800078ac:	62 1c       	ld.w	r12,r1[0x4]
800078ae:	e0 16 ff f8 	andl	r6,0xfff8
800078b2:	59 68       	cp.w	r8,22
800078b4:	f9 b6 08 10 	movls	r6,16
800078b8:	16 36       	cp.w	r6,r11
800078ba:	5f 38       	srlo	r8
800078bc:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800078c0:	c0 50       	breq	800078ca <_realloc_r+0x46>
800078c2:	30 c8       	mov	r8,12
800078c4:	30 05       	mov	r5,0
800078c6:	85 38       	st.w	r2[0xc],r8
800078c8:	c3 b9       	rjmp	80007b3e <_realloc_r+0x2ba>
800078ca:	18 90       	mov	r0,r12
800078cc:	e0 10 ff fc 	andl	r0,0xfffc
800078d0:	0c 30       	cp.w	r0,r6
800078d2:	e0 84 01 0b 	brge	80007ae8 <_realloc_r+0x264>
800078d6:	e0 68 05 3c 	mov	r8,1340
800078da:	e2 00 00 09 	add	r9,r1,r0
800078de:	70 25       	ld.w	r5,r8[0x8]
800078e0:	0a 39       	cp.w	r9,r5
800078e2:	c0 90       	breq	800078f4 <_realloc_r+0x70>
800078e4:	72 1a       	ld.w	r10,r9[0x4]
800078e6:	a1 ca       	cbr	r10,0x0
800078e8:	f2 0a 00 0a 	add	r10,r9,r10
800078ec:	74 1a       	ld.w	r10,r10[0x4]
800078ee:	ed ba 00 00 	bld	r10,0x0
800078f2:	c2 20       	breq	80007936 <_realloc_r+0xb2>
800078f4:	72 1a       	ld.w	r10,r9[0x4]
800078f6:	e0 1a ff fc 	andl	r10,0xfffc
800078fa:	f4 00 00 03 	add	r3,r10,r0
800078fe:	0a 39       	cp.w	r9,r5
80007900:	c1 31       	brne	80007926 <_realloc_r+0xa2>
80007902:	ec c7 ff f0 	sub	r7,r6,-16
80007906:	0e 33       	cp.w	r3,r7
80007908:	c1 95       	brlt	8000793a <_realloc_r+0xb6>
8000790a:	e2 06 00 09 	add	r9,r1,r6
8000790e:	0c 13       	sub	r3,r6
80007910:	a1 a3       	sbr	r3,0x0
80007912:	93 13       	st.w	r9[0x4],r3
80007914:	91 29       	st.w	r8[0x8],r9
80007916:	04 9c       	mov	r12,r2
80007918:	62 18       	ld.w	r8,r1[0x4]
8000791a:	08 95       	mov	r5,r4
8000791c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007920:	10 46       	or	r6,r8
80007922:	83 16       	st.w	r1[0x4],r6
80007924:	c0 b9       	rjmp	80007b3a <_realloc_r+0x2b6>
80007926:	0c 33       	cp.w	r3,r6
80007928:	c0 95       	brlt	8000793a <_realloc_r+0xb6>
8000792a:	72 28       	ld.w	r8,r9[0x8]
8000792c:	02 97       	mov	r7,r1
8000792e:	72 39       	ld.w	r9,r9[0xc]
80007930:	93 28       	st.w	r9[0x8],r8
80007932:	91 39       	st.w	r8[0xc],r9
80007934:	cd c8       	rjmp	80007aec <_realloc_r+0x268>
80007936:	30 0a       	mov	r10,0
80007938:	14 99       	mov	r9,r10
8000793a:	ed bc 00 00 	bld	r12,0x0
8000793e:	e0 80 00 95 	breq	80007a68 <_realloc_r+0x1e4>
80007942:	62 07       	ld.w	r7,r1[0x0]
80007944:	e2 07 01 07 	sub	r7,r1,r7
80007948:	6e 1c       	ld.w	r12,r7[0x4]
8000794a:	e0 1c ff fc 	andl	r12,0xfffc
8000794e:	58 09       	cp.w	r9,0
80007950:	c5 60       	breq	800079fc <_realloc_r+0x178>
80007952:	f8 00 00 03 	add	r3,r12,r0
80007956:	0a 39       	cp.w	r9,r5
80007958:	c4 81       	brne	800079e8 <_realloc_r+0x164>
8000795a:	14 03       	add	r3,r10
8000795c:	ec c9 ff f0 	sub	r9,r6,-16
80007960:	12 33       	cp.w	r3,r9
80007962:	c4 d5       	brlt	800079fc <_realloc_r+0x178>
80007964:	6e 3a       	ld.w	r10,r7[0xc]
80007966:	6e 29       	ld.w	r9,r7[0x8]
80007968:	95 29       	st.w	r10[0x8],r9
8000796a:	93 3a       	st.w	r9[0xc],r10
8000796c:	ee c5 ff f8 	sub	r5,r7,-8
80007970:	e0 ca 00 04 	sub	r10,r0,4
80007974:	e0 4a 00 24 	cp.w	r10,36
80007978:	e0 8b 00 25 	brhi	800079c2 <_realloc_r+0x13e>
8000797c:	0a 99       	mov	r9,r5
8000797e:	59 3a       	cp.w	r10,19
80007980:	e0 88 00 1a 	brls	800079b4 <_realloc_r+0x130>
80007984:	09 09       	ld.w	r9,r4++
80007986:	8b 09       	st.w	r5[0x0],r9
80007988:	09 09       	ld.w	r9,r4++
8000798a:	8f 39       	st.w	r7[0xc],r9
8000798c:	ee c9 ff f0 	sub	r9,r7,-16
80007990:	59 ba       	cp.w	r10,27
80007992:	e0 88 00 11 	brls	800079b4 <_realloc_r+0x130>
80007996:	09 0b       	ld.w	r11,r4++
80007998:	93 0b       	st.w	r9[0x0],r11
8000799a:	09 09       	ld.w	r9,r4++
8000799c:	8f 59       	st.w	r7[0x14],r9
8000799e:	ee c9 ff e8 	sub	r9,r7,-24
800079a2:	e0 4a 00 24 	cp.w	r10,36
800079a6:	c0 71       	brne	800079b4 <_realloc_r+0x130>
800079a8:	09 0a       	ld.w	r10,r4++
800079aa:	93 0a       	st.w	r9[0x0],r10
800079ac:	ee c9 ff e0 	sub	r9,r7,-32
800079b0:	09 0a       	ld.w	r10,r4++
800079b2:	8f 7a       	st.w	r7[0x1c],r10
800079b4:	09 0a       	ld.w	r10,r4++
800079b6:	12 aa       	st.w	r9++,r10
800079b8:	68 0a       	ld.w	r10,r4[0x0]
800079ba:	93 0a       	st.w	r9[0x0],r10
800079bc:	68 1a       	ld.w	r10,r4[0x4]
800079be:	93 1a       	st.w	r9[0x4],r10
800079c0:	c0 78       	rjmp	800079ce <_realloc_r+0x14a>
800079c2:	50 08       	stdsp	sp[0x0],r8
800079c4:	08 9b       	mov	r11,r4
800079c6:	0a 9c       	mov	r12,r5
800079c8:	e0 a0 1d 9b 	rcall	8000b4fe <memmove>
800079cc:	40 08       	lddsp	r8,sp[0x0]
800079ce:	ee 06 00 09 	add	r9,r7,r6
800079d2:	0c 13       	sub	r3,r6
800079d4:	a1 a3       	sbr	r3,0x0
800079d6:	93 13       	st.w	r9[0x4],r3
800079d8:	91 29       	st.w	r8[0x8],r9
800079da:	04 9c       	mov	r12,r2
800079dc:	6e 18       	ld.w	r8,r7[0x4]
800079de:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079e2:	10 46       	or	r6,r8
800079e4:	8f 16       	st.w	r7[0x4],r6
800079e6:	ca a8       	rjmp	80007b3a <_realloc_r+0x2b6>
800079e8:	14 03       	add	r3,r10
800079ea:	0c 33       	cp.w	r3,r6
800079ec:	c0 85       	brlt	800079fc <_realloc_r+0x178>
800079ee:	72 28       	ld.w	r8,r9[0x8]
800079f0:	72 39       	ld.w	r9,r9[0xc]
800079f2:	93 28       	st.w	r9[0x8],r8
800079f4:	91 39       	st.w	r8[0xc],r9
800079f6:	6e 28       	ld.w	r8,r7[0x8]
800079f8:	6e 39       	ld.w	r9,r7[0xc]
800079fa:	c0 78       	rjmp	80007a08 <_realloc_r+0x184>
800079fc:	f8 00 00 03 	add	r3,r12,r0
80007a00:	0c 33       	cp.w	r3,r6
80007a02:	c3 35       	brlt	80007a68 <_realloc_r+0x1e4>
80007a04:	6e 39       	ld.w	r9,r7[0xc]
80007a06:	6e 28       	ld.w	r8,r7[0x8]
80007a08:	93 28       	st.w	r9[0x8],r8
80007a0a:	91 39       	st.w	r8[0xc],r9
80007a0c:	e0 ca 00 04 	sub	r10,r0,4
80007a10:	ee cc ff f8 	sub	r12,r7,-8
80007a14:	e0 4a 00 24 	cp.w	r10,36
80007a18:	e0 8b 00 24 	brhi	80007a60 <_realloc_r+0x1dc>
80007a1c:	59 3a       	cp.w	r10,19
80007a1e:	e0 88 00 1a 	brls	80007a52 <_realloc_r+0x1ce>
80007a22:	09 08       	ld.w	r8,r4++
80007a24:	99 08       	st.w	r12[0x0],r8
80007a26:	09 08       	ld.w	r8,r4++
80007a28:	8f 38       	st.w	r7[0xc],r8
80007a2a:	ee cc ff f0 	sub	r12,r7,-16
80007a2e:	59 ba       	cp.w	r10,27
80007a30:	e0 88 00 11 	brls	80007a52 <_realloc_r+0x1ce>
80007a34:	09 08       	ld.w	r8,r4++
80007a36:	99 08       	st.w	r12[0x0],r8
80007a38:	09 08       	ld.w	r8,r4++
80007a3a:	8f 58       	st.w	r7[0x14],r8
80007a3c:	ee cc ff e8 	sub	r12,r7,-24
80007a40:	e0 4a 00 24 	cp.w	r10,36
80007a44:	c0 71       	brne	80007a52 <_realloc_r+0x1ce>
80007a46:	09 08       	ld.w	r8,r4++
80007a48:	99 08       	st.w	r12[0x0],r8
80007a4a:	ee cc ff e0 	sub	r12,r7,-32
80007a4e:	09 08       	ld.w	r8,r4++
80007a50:	8f 78       	st.w	r7[0x1c],r8
80007a52:	09 08       	ld.w	r8,r4++
80007a54:	18 a8       	st.w	r12++,r8
80007a56:	68 08       	ld.w	r8,r4[0x0]
80007a58:	99 08       	st.w	r12[0x0],r8
80007a5a:	68 18       	ld.w	r8,r4[0x4]
80007a5c:	99 18       	st.w	r12[0x4],r8
80007a5e:	c4 78       	rjmp	80007aec <_realloc_r+0x268>
80007a60:	08 9b       	mov	r11,r4
80007a62:	e0 a0 1d 4e 	rcall	8000b4fe <memmove>
80007a66:	c4 38       	rjmp	80007aec <_realloc_r+0x268>
80007a68:	04 9c       	mov	r12,r2
80007a6a:	fe b0 fc 33 	rcall	800072d0 <_malloc_r>
80007a6e:	18 95       	mov	r5,r12
80007a70:	c3 a0       	breq	80007ae4 <_realloc_r+0x260>
80007a72:	62 18       	ld.w	r8,r1[0x4]
80007a74:	f8 c9 00 08 	sub	r9,r12,8
80007a78:	a1 c8       	cbr	r8,0x0
80007a7a:	e2 08 00 08 	add	r8,r1,r8
80007a7e:	10 39       	cp.w	r9,r8
80007a80:	c0 71       	brne	80007a8e <_realloc_r+0x20a>
80007a82:	72 13       	ld.w	r3,r9[0x4]
80007a84:	02 97       	mov	r7,r1
80007a86:	e0 13 ff fc 	andl	r3,0xfffc
80007a8a:	00 03       	add	r3,r0
80007a8c:	c3 08       	rjmp	80007aec <_realloc_r+0x268>
80007a8e:	e0 ca 00 04 	sub	r10,r0,4
80007a92:	e0 4a 00 24 	cp.w	r10,36
80007a96:	e0 8b 00 20 	brhi	80007ad6 <_realloc_r+0x252>
80007a9a:	08 99       	mov	r9,r4
80007a9c:	18 98       	mov	r8,r12
80007a9e:	59 3a       	cp.w	r10,19
80007aa0:	e0 88 00 14 	brls	80007ac8 <_realloc_r+0x244>
80007aa4:	13 0b       	ld.w	r11,r9++
80007aa6:	10 ab       	st.w	r8++,r11
80007aa8:	13 0b       	ld.w	r11,r9++
80007aaa:	10 ab       	st.w	r8++,r11
80007aac:	59 ba       	cp.w	r10,27
80007aae:	e0 88 00 0d 	brls	80007ac8 <_realloc_r+0x244>
80007ab2:	13 0b       	ld.w	r11,r9++
80007ab4:	10 ab       	st.w	r8++,r11
80007ab6:	13 0b       	ld.w	r11,r9++
80007ab8:	10 ab       	st.w	r8++,r11
80007aba:	e0 4a 00 24 	cp.w	r10,36
80007abe:	c0 51       	brne	80007ac8 <_realloc_r+0x244>
80007ac0:	13 0a       	ld.w	r10,r9++
80007ac2:	10 aa       	st.w	r8++,r10
80007ac4:	13 0a       	ld.w	r10,r9++
80007ac6:	10 aa       	st.w	r8++,r10
80007ac8:	13 0a       	ld.w	r10,r9++
80007aca:	10 aa       	st.w	r8++,r10
80007acc:	72 0a       	ld.w	r10,r9[0x0]
80007ace:	91 0a       	st.w	r8[0x0],r10
80007ad0:	72 19       	ld.w	r9,r9[0x4]
80007ad2:	91 19       	st.w	r8[0x4],r9
80007ad4:	c0 48       	rjmp	80007adc <_realloc_r+0x258>
80007ad6:	08 9b       	mov	r11,r4
80007ad8:	e0 a0 1d 13 	rcall	8000b4fe <memmove>
80007adc:	08 9b       	mov	r11,r4
80007ade:	04 9c       	mov	r12,r2
80007ae0:	e0 a0 1a 6c 	rcall	8000afb8 <_free_r>
80007ae4:	04 9c       	mov	r12,r2
80007ae6:	c2 a8       	rjmp	80007b3a <_realloc_r+0x2b6>
80007ae8:	00 93       	mov	r3,r0
80007aea:	02 97       	mov	r7,r1
80007aec:	e6 06 01 09 	sub	r9,r3,r6
80007af0:	6e 18       	ld.w	r8,r7[0x4]
80007af2:	58 f9       	cp.w	r9,15
80007af4:	e0 88 00 16 	brls	80007b20 <_realloc_r+0x29c>
80007af8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007afc:	ed e8 10 08 	or	r8,r6,r8
80007b00:	8f 18       	st.w	r7[0x4],r8
80007b02:	12 98       	mov	r8,r9
80007b04:	a1 a8       	sbr	r8,0x0
80007b06:	ee 06 00 0b 	add	r11,r7,r6
80007b0a:	f6 09 00 09 	add	r9,r11,r9
80007b0e:	97 18       	st.w	r11[0x4],r8
80007b10:	72 18       	ld.w	r8,r9[0x4]
80007b12:	a1 a8       	sbr	r8,0x0
80007b14:	2f 8b       	sub	r11,-8
80007b16:	93 18       	st.w	r9[0x4],r8
80007b18:	04 9c       	mov	r12,r2
80007b1a:	e0 a0 1a 4f 	rcall	8000afb8 <_free_r>
80007b1e:	c0 b8       	rjmp	80007b34 <_realloc_r+0x2b0>
80007b20:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b24:	e7 e8 10 08 	or	r8,r3,r8
80007b28:	8f 18       	st.w	r7[0x4],r8
80007b2a:	ee 03 00 03 	add	r3,r7,r3
80007b2e:	66 18       	ld.w	r8,r3[0x4]
80007b30:	a1 a8       	sbr	r8,0x0
80007b32:	87 18       	st.w	r3[0x4],r8
80007b34:	04 9c       	mov	r12,r2
80007b36:	ee c5 ff f8 	sub	r5,r7,-8
80007b3a:	fe b0 f1 4f 	rcall	80005dd8 <__malloc_unlock>
80007b3e:	0a 9c       	mov	r12,r5
80007b40:	2f fd       	sub	sp,-4
80007b42:	d8 32       	popm	r0-r7,pc

80007b44 <_sbrk_r>:
80007b44:	d4 21       	pushm	r4-r7,lr
80007b46:	30 08       	mov	r8,0
80007b48:	18 97       	mov	r7,r12
80007b4a:	e0 66 63 98 	mov	r6,25496
80007b4e:	16 9c       	mov	r12,r11
80007b50:	8d 08       	st.w	r6[0x0],r8
80007b52:	c9 1c       	rcall	80007c74 <_sbrk>
80007b54:	5b fc       	cp.w	r12,-1
80007b56:	c0 51       	brne	80007b60 <_sbrk_r+0x1c>
80007b58:	6c 08       	ld.w	r8,r6[0x0]
80007b5a:	58 08       	cp.w	r8,0
80007b5c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007b60:	d8 22       	popm	r4-r7,pc
80007b62:	d7 03       	nop

80007b64 <sprintf>:
80007b64:	d4 01       	pushm	lr
80007b66:	21 7d       	sub	sp,92
80007b68:	e0 68 ff ff 	mov	r8,65535
80007b6c:	ea 18 7f ff 	orh	r8,0x7fff
80007b70:	50 58       	stdsp	sp[0x14],r8
80007b72:	50 28       	stdsp	sp[0x8],r8
80007b74:	e0 68 02 08 	mov	r8,520
80007b78:	ba 68       	st.h	sp[0xc],r8
80007b7a:	3f f8       	mov	r8,-1
80007b7c:	ba 78       	st.h	sp[0xe],r8
80007b7e:	e0 68 0a 3c 	mov	r8,2620
80007b82:	50 4c       	stdsp	sp[0x10],r12
80007b84:	16 9a       	mov	r10,r11
80007b86:	50 0c       	stdsp	sp[0x0],r12
80007b88:	fa c9 ff a0 	sub	r9,sp,-96
80007b8c:	70 0c       	ld.w	r12,r8[0x0]
80007b8e:	1a 9b       	mov	r11,sp
80007b90:	e0 a0 02 26 	rcall	80007fdc <_vfprintf_r>
80007b94:	30 09       	mov	r9,0
80007b96:	40 08       	lddsp	r8,sp[0x0]
80007b98:	b0 89       	st.b	r8[0x0],r9
80007b9a:	2e 9d       	sub	sp,-92
80007b9c:	d8 02       	popm	pc
80007b9e:	d7 03       	nop

80007ba0 <strlen>:
80007ba0:	30 09       	mov	r9,0
80007ba2:	18 98       	mov	r8,r12
80007ba4:	c0 28       	rjmp	80007ba8 <strlen+0x8>
80007ba6:	2f f8       	sub	r8,-1
80007ba8:	11 8a       	ld.ub	r10,r8[0x0]
80007baa:	f2 0a 18 00 	cp.b	r10,r9
80007bae:	cf c1       	brne	80007ba6 <strlen+0x6>
80007bb0:	f0 0c 01 0c 	sub	r12,r8,r12
80007bb4:	5e fc       	retal	r12
80007bb6:	d7 03       	nop

80007bb8 <strncpy>:
80007bb8:	30 08       	mov	r8,0
80007bba:	10 3a       	cp.w	r10,r8
80007bbc:	5e 0c       	reteq	r12
80007bbe:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007bc2:	f8 08 0b 09 	st.b	r12[r8],r9
80007bc6:	2f f8       	sub	r8,-1
80007bc8:	58 09       	cp.w	r9,0
80007bca:	cf 81       	brne	80007bba <strncpy+0x2>
80007bcc:	10 3a       	cp.w	r10,r8
80007bce:	5e 0c       	reteq	r12
80007bd0:	f8 08 0b 09 	st.b	r12[r8],r9
80007bd4:	2f f8       	sub	r8,-1
80007bd6:	cf bb       	rjmp	80007bcc <strncpy+0x14>

80007bd8 <_close>:
80007bd8:	30 28       	mov	r8,2
80007bda:	d6 73       	breakpoint
80007bdc:	3f fc       	mov	r12,-1
80007bde:	35 8b       	mov	r11,88
80007be0:	58 0c       	cp.w	r12,0
80007be2:	5e 4c       	retge	r12
80007be4:	e0 6a 63 98 	mov	r10,25496
80007be8:	95 0b       	st.w	r10[0x0],r11
80007bea:	5e fc       	retal	r12

80007bec <_lseek>:
80007bec:	30 58       	mov	r8,5
80007bee:	d6 73       	breakpoint
80007bf0:	3f fc       	mov	r12,-1
80007bf2:	35 8b       	mov	r11,88
80007bf4:	58 0c       	cp.w	r12,0
80007bf6:	5e 4c       	retge	r12
80007bf8:	e0 6a 63 98 	mov	r10,25496
80007bfc:	95 0b       	st.w	r10[0x0],r11
80007bfe:	5e fc       	retal	r12

80007c00 <isatty>:
80007c00:	30 b8       	mov	r8,11
80007c02:	d6 73       	breakpoint
80007c04:	3f fc       	mov	r12,-1
80007c06:	35 8b       	mov	r11,88
80007c08:	58 0c       	cp.w	r12,0
80007c0a:	5e 4c       	retge	r12
80007c0c:	e0 6a 63 98 	mov	r10,25496
80007c10:	95 0b       	st.w	r10[0x0],r11
80007c12:	5e fc       	retal	r12

80007c14 <_fstat_host>:
80007c14:	30 98       	mov	r8,9
80007c16:	d6 73       	breakpoint
80007c18:	3f fc       	mov	r12,-1
80007c1a:	35 8b       	mov	r11,88
80007c1c:	58 0c       	cp.w	r12,0
80007c1e:	5e 4c       	retge	r12
80007c20:	e0 6a 63 98 	mov	r10,25496
80007c24:	95 0b       	st.w	r10[0x0],r11
80007c26:	5e fc       	retal	r12

80007c28 <_fstat>:
80007c28:	d4 21       	pushm	r4-r7,lr
80007c2a:	21 0d       	sub	sp,64
80007c2c:	16 97       	mov	r7,r11
80007c2e:	1a 9b       	mov	r11,sp
80007c30:	cf 2f       	rcall	80007c14 <_fstat_host>
80007c32:	c0 34       	brge	80007c38 <_fstat+0x10>
80007c34:	3f fc       	mov	r12,-1
80007c36:	c1 c8       	rjmp	80007c6e <_fstat+0x46>
80007c38:	40 08       	lddsp	r8,sp[0x0]
80007c3a:	ae 08       	st.h	r7[0x0],r8
80007c3c:	40 18       	lddsp	r8,sp[0x4]
80007c3e:	ae 18       	st.h	r7[0x2],r8
80007c40:	40 28       	lddsp	r8,sp[0x8]
80007c42:	8f 18       	st.w	r7[0x4],r8
80007c44:	40 38       	lddsp	r8,sp[0xc]
80007c46:	ae 48       	st.h	r7[0x8],r8
80007c48:	40 48       	lddsp	r8,sp[0x10]
80007c4a:	ae 58       	st.h	r7[0xa],r8
80007c4c:	40 58       	lddsp	r8,sp[0x14]
80007c4e:	ae 68       	st.h	r7[0xc],r8
80007c50:	40 68       	lddsp	r8,sp[0x18]
80007c52:	ae 78       	st.h	r7[0xe],r8
80007c54:	40 88       	lddsp	r8,sp[0x20]
80007c56:	8f 48       	st.w	r7[0x10],r8
80007c58:	40 a8       	lddsp	r8,sp[0x28]
80007c5a:	8f b8       	st.w	r7[0x2c],r8
80007c5c:	40 c8       	lddsp	r8,sp[0x30]
80007c5e:	8f c8       	st.w	r7[0x30],r8
80007c60:	40 d8       	lddsp	r8,sp[0x34]
80007c62:	8f 58       	st.w	r7[0x14],r8
80007c64:	40 e8       	lddsp	r8,sp[0x38]
80007c66:	30 0c       	mov	r12,0
80007c68:	8f 78       	st.w	r7[0x1c],r8
80007c6a:	40 f8       	lddsp	r8,sp[0x3c]
80007c6c:	8f 98       	st.w	r7[0x24],r8
80007c6e:	2f 0d       	sub	sp,-64
80007c70:	d8 22       	popm	r4-r7,pc
80007c72:	d7 03       	nop

80007c74 <_sbrk>:
80007c74:	d4 01       	pushm	lr
80007c76:	e0 68 0d 80 	mov	r8,3456
80007c7a:	70 09       	ld.w	r9,r8[0x0]
80007c7c:	58 09       	cp.w	r9,0
80007c7e:	c0 41       	brne	80007c86 <_sbrk+0x12>
80007c80:	e0 69 63 a0 	mov	r9,25504
80007c84:	91 09       	st.w	r8[0x0],r9
80007c86:	e0 69 0d 80 	mov	r9,3456
80007c8a:	e0 7a 70 00 	mov	r10,94208
80007c8e:	72 08       	ld.w	r8,r9[0x0]
80007c90:	f0 0c 00 0c 	add	r12,r8,r12
80007c94:	14 3c       	cp.w	r12,r10
80007c96:	e0 8b 00 04 	brhi	80007c9e <_sbrk+0x2a>
80007c9a:	93 0c       	st.w	r9[0x0],r12
80007c9c:	c0 68       	rjmp	80007ca8 <_sbrk+0x34>
80007c9e:	e0 a0 18 15 	rcall	8000acc8 <__errno>
80007ca2:	30 c8       	mov	r8,12
80007ca4:	99 08       	st.w	r12[0x0],r8
80007ca6:	3f f8       	mov	r8,-1
80007ca8:	10 9c       	mov	r12,r8
80007caa:	d8 02       	popm	pc

80007cac <get_arg>:
80007cac:	d4 31       	pushm	r0-r7,lr
80007cae:	20 8d       	sub	sp,32
80007cb0:	fa c4 ff bc 	sub	r4,sp,-68
80007cb4:	50 4b       	stdsp	sp[0x10],r11
80007cb6:	68 2e       	ld.w	lr,r4[0x8]
80007cb8:	50 58       	stdsp	sp[0x14],r8
80007cba:	12 96       	mov	r6,r9
80007cbc:	7c 0b       	ld.w	r11,lr[0x0]
80007cbe:	70 05       	ld.w	r5,r8[0x0]
80007cc0:	50 6e       	stdsp	sp[0x18],lr
80007cc2:	58 0b       	cp.w	r11,0
80007cc4:	f4 0b 17 00 	moveq	r11,r10
80007cc8:	68 03       	ld.w	r3,r4[0x0]
80007cca:	68 11       	ld.w	r1,r4[0x4]
80007ccc:	40 49       	lddsp	r9,sp[0x10]
80007cce:	30 08       	mov	r8,0
80007cd0:	c2 89       	rjmp	80007f20 <get_arg+0x274>
80007cd2:	2f fb       	sub	r11,-1
80007cd4:	32 5c       	mov	r12,37
80007cd6:	17 8a       	ld.ub	r10,r11[0x0]
80007cd8:	f8 0a 18 00 	cp.b	r10,r12
80007cdc:	5f 1e       	srne	lr
80007cde:	f0 0a 18 00 	cp.b	r10,r8
80007ce2:	5f 1c       	srne	r12
80007ce4:	fd ec 00 0c 	and	r12,lr,r12
80007ce8:	f0 0c 18 00 	cp.b	r12,r8
80007cec:	cf 31       	brne	80007cd2 <get_arg+0x26>
80007cee:	58 0a       	cp.w	r10,0
80007cf0:	e0 80 01 25 	breq	80007f3a <get_arg+0x28e>
80007cf4:	30 0c       	mov	r12,0
80007cf6:	3f fa       	mov	r10,-1
80007cf8:	18 90       	mov	r0,r12
80007cfa:	50 3a       	stdsp	sp[0xc],r10
80007cfc:	18 94       	mov	r4,r12
80007cfe:	18 92       	mov	r2,r12
80007d00:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007d04:	16 97       	mov	r7,r11
80007d06:	50 7c       	stdsp	sp[0x1c],r12
80007d08:	fe cc 9a 08 	sub	r12,pc,-26104
80007d0c:	0f 3a       	ld.ub	r10,r7++
80007d0e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007d12:	40 7c       	lddsp	r12,sp[0x1c]
80007d14:	1c 0c       	add	r12,lr
80007d16:	fe ce 9a de 	sub	lr,pc,-25890
80007d1a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007d1e:	20 1e       	sub	lr,1
80007d20:	50 0e       	stdsp	sp[0x0],lr
80007d22:	fe ce 9b 56 	sub	lr,pc,-25770
80007d26:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007d2a:	50 7c       	stdsp	sp[0x1c],r12
80007d2c:	40 0c       	lddsp	r12,sp[0x0]
80007d2e:	58 7c       	cp.w	r12,7
80007d30:	e0 8b 00 f1 	brhi	80007f12 <get_arg+0x266>
80007d34:	fe ce 9d 08 	sub	lr,pc,-25336
80007d38:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007d3c:	36 8b       	mov	r11,104
80007d3e:	f6 0a 18 00 	cp.b	r10,r11
80007d42:	e0 80 00 e8 	breq	80007f12 <get_arg+0x266>
80007d46:	37 1b       	mov	r11,113
80007d48:	f6 0a 18 00 	cp.b	r10,r11
80007d4c:	c0 70       	breq	80007d5a <get_arg+0xae>
80007d4e:	34 cb       	mov	r11,76
80007d50:	f6 0a 18 00 	cp.b	r10,r11
80007d54:	c0 51       	brne	80007d5e <get_arg+0xb2>
80007d56:	a3 b4       	sbr	r4,0x3
80007d58:	cd d8       	rjmp	80007f12 <get_arg+0x266>
80007d5a:	a5 b4       	sbr	r4,0x5
80007d5c:	cd b8       	rjmp	80007f12 <get_arg+0x266>
80007d5e:	08 9a       	mov	r10,r4
80007d60:	0e 9b       	mov	r11,r7
80007d62:	a5 aa       	sbr	r10,0x4
80007d64:	17 3c       	ld.ub	r12,r11++
80007d66:	a5 b4       	sbr	r4,0x5
80007d68:	36 ce       	mov	lr,108
80007d6a:	fc 0c 18 00 	cp.b	r12,lr
80007d6e:	e0 80 00 d3 	breq	80007f14 <get_arg+0x268>
80007d72:	14 94       	mov	r4,r10
80007d74:	cc f8       	rjmp	80007f12 <get_arg+0x266>
80007d76:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007d7a:	36 7c       	mov	r12,103
80007d7c:	f8 0a 18 00 	cp.b	r10,r12
80007d80:	e0 8b 00 27 	brhi	80007dce <get_arg+0x122>
80007d84:	36 5b       	mov	r11,101
80007d86:	f6 0a 18 00 	cp.b	r10,r11
80007d8a:	c4 82       	brcc	80007e1a <get_arg+0x16e>
80007d8c:	34 fb       	mov	r11,79
80007d8e:	f6 0a 18 00 	cp.b	r10,r11
80007d92:	c4 80       	breq	80007e22 <get_arg+0x176>
80007d94:	e0 8b 00 0c 	brhi	80007dac <get_arg+0x100>
80007d98:	34 5b       	mov	r11,69
80007d9a:	f6 0a 18 00 	cp.b	r10,r11
80007d9e:	c3 e0       	breq	80007e1a <get_arg+0x16e>
80007da0:	34 7b       	mov	r11,71
80007da2:	f6 0a 18 00 	cp.b	r10,r11
80007da6:	c3 a0       	breq	80007e1a <get_arg+0x16e>
80007da8:	34 4b       	mov	r11,68
80007daa:	c0 88       	rjmp	80007dba <get_arg+0x10e>
80007dac:	35 8b       	mov	r11,88
80007dae:	f6 0a 18 00 	cp.b	r10,r11
80007db2:	c2 c0       	breq	80007e0a <get_arg+0x15e>
80007db4:	e0 8b 00 07 	brhi	80007dc2 <get_arg+0x116>
80007db8:	35 5b       	mov	r11,85
80007dba:	f6 0a 18 00 	cp.b	r10,r11
80007dbe:	c3 51       	brne	80007e28 <get_arg+0x17c>
80007dc0:	c3 18       	rjmp	80007e22 <get_arg+0x176>
80007dc2:	36 3b       	mov	r11,99
80007dc4:	f6 0a 18 00 	cp.b	r10,r11
80007dc8:	c2 f0       	breq	80007e26 <get_arg+0x17a>
80007dca:	36 4b       	mov	r11,100
80007dcc:	c0 e8       	rjmp	80007de8 <get_arg+0x13c>
80007dce:	37 0b       	mov	r11,112
80007dd0:	f6 0a 18 00 	cp.b	r10,r11
80007dd4:	c2 50       	breq	80007e1e <get_arg+0x172>
80007dd6:	e0 8b 00 0d 	brhi	80007df0 <get_arg+0x144>
80007dda:	36 eb       	mov	r11,110
80007ddc:	f6 0a 18 00 	cp.b	r10,r11
80007de0:	c1 f0       	breq	80007e1e <get_arg+0x172>
80007de2:	e0 8b 00 14 	brhi	80007e0a <get_arg+0x15e>
80007de6:	36 9b       	mov	r11,105
80007de8:	f6 0a 18 00 	cp.b	r10,r11
80007dec:	c1 e1       	brne	80007e28 <get_arg+0x17c>
80007dee:	c0 e8       	rjmp	80007e0a <get_arg+0x15e>
80007df0:	37 5b       	mov	r11,117
80007df2:	f6 0a 18 00 	cp.b	r10,r11
80007df6:	c0 a0       	breq	80007e0a <get_arg+0x15e>
80007df8:	37 8b       	mov	r11,120
80007dfa:	f6 0a 18 00 	cp.b	r10,r11
80007dfe:	c0 60       	breq	80007e0a <get_arg+0x15e>
80007e00:	37 3b       	mov	r11,115
80007e02:	f6 0a 18 00 	cp.b	r10,r11
80007e06:	c1 11       	brne	80007e28 <get_arg+0x17c>
80007e08:	c0 b8       	rjmp	80007e1e <get_arg+0x172>
80007e0a:	ed b4 00 04 	bld	r4,0x4
80007e0e:	c0 a0       	breq	80007e22 <get_arg+0x176>
80007e10:	ed b4 00 05 	bld	r4,0x5
80007e14:	c0 91       	brne	80007e26 <get_arg+0x17a>
80007e16:	30 20       	mov	r0,2
80007e18:	c0 88       	rjmp	80007e28 <get_arg+0x17c>
80007e1a:	30 40       	mov	r0,4
80007e1c:	c0 68       	rjmp	80007e28 <get_arg+0x17c>
80007e1e:	30 30       	mov	r0,3
80007e20:	c0 48       	rjmp	80007e28 <get_arg+0x17c>
80007e22:	30 10       	mov	r0,1
80007e24:	c0 28       	rjmp	80007e28 <get_arg+0x17c>
80007e26:	30 00       	mov	r0,0
80007e28:	40 3b       	lddsp	r11,sp[0xc]
80007e2a:	5b fb       	cp.w	r11,-1
80007e2c:	c0 40       	breq	80007e34 <get_arg+0x188>
80007e2e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007e32:	c7 08       	rjmp	80007f12 <get_arg+0x266>
80007e34:	58 60       	cp.w	r0,6
80007e36:	e0 8b 00 6e 	brhi	80007f12 <get_arg+0x266>
80007e3a:	6c 0a       	ld.w	r10,r6[0x0]
80007e3c:	ea cc ff ff 	sub	r12,r5,-1
80007e40:	fe ce 9d f4 	sub	lr,pc,-25100
80007e44:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007e48:	f4 cb ff f8 	sub	r11,r10,-8
80007e4c:	8d 0b       	st.w	r6[0x0],r11
80007e4e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007e52:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007e56:	c0 f8       	rjmp	80007e74 <get_arg+0x1c8>
80007e58:	f4 cb ff fc 	sub	r11,r10,-4
80007e5c:	8d 0b       	st.w	r6[0x0],r11
80007e5e:	74 0a       	ld.w	r10,r10[0x0]
80007e60:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007e64:	c0 88       	rjmp	80007e74 <get_arg+0x1c8>
80007e66:	f4 cb ff f8 	sub	r11,r10,-8
80007e6a:	8d 0b       	st.w	r6[0x0],r11
80007e6c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007e70:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007e74:	0e 9b       	mov	r11,r7
80007e76:	18 95       	mov	r5,r12
80007e78:	c4 e8       	rjmp	80007f14 <get_arg+0x268>
80007e7a:	62 0a       	ld.w	r10,r1[0x0]
80007e7c:	5b fa       	cp.w	r10,-1
80007e7e:	c0 b1       	brne	80007e94 <get_arg+0x1e8>
80007e80:	50 19       	stdsp	sp[0x4],r9
80007e82:	50 28       	stdsp	sp[0x8],r8
80007e84:	e0 6a 00 80 	mov	r10,128
80007e88:	30 0b       	mov	r11,0
80007e8a:	02 9c       	mov	r12,r1
80007e8c:	fe b0 fc f5 	rcall	80007876 <memset>
80007e90:	40 28       	lddsp	r8,sp[0x8]
80007e92:	40 19       	lddsp	r9,sp[0x4]
80007e94:	e4 cc 00 01 	sub	r12,r2,1
80007e98:	0e 9b       	mov	r11,r7
80007e9a:	50 3c       	stdsp	sp[0xc],r12
80007e9c:	f2 0c 0c 49 	max	r9,r9,r12
80007ea0:	c3 a8       	rjmp	80007f14 <get_arg+0x268>
80007ea2:	62 0a       	ld.w	r10,r1[0x0]
80007ea4:	5b fa       	cp.w	r10,-1
80007ea6:	c0 b1       	brne	80007ebc <get_arg+0x210>
80007ea8:	50 19       	stdsp	sp[0x4],r9
80007eaa:	50 28       	stdsp	sp[0x8],r8
80007eac:	e0 6a 00 80 	mov	r10,128
80007eb0:	30 0b       	mov	r11,0
80007eb2:	02 9c       	mov	r12,r1
80007eb4:	fe b0 fc e1 	rcall	80007876 <memset>
80007eb8:	40 28       	lddsp	r8,sp[0x8]
80007eba:	40 19       	lddsp	r9,sp[0x4]
80007ebc:	20 12       	sub	r2,1
80007ebe:	30 0a       	mov	r10,0
80007ec0:	0e 9b       	mov	r11,r7
80007ec2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007ec6:	f2 02 0c 49 	max	r9,r9,r2
80007eca:	c2 58       	rjmp	80007f14 <get_arg+0x268>
80007ecc:	16 97       	mov	r7,r11
80007ece:	6c 0a       	ld.w	r10,r6[0x0]
80007ed0:	f4 cb ff fc 	sub	r11,r10,-4
80007ed4:	8d 0b       	st.w	r6[0x0],r11
80007ed6:	74 0a       	ld.w	r10,r10[0x0]
80007ed8:	0e 9b       	mov	r11,r7
80007eda:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007ede:	2f f5       	sub	r5,-1
80007ee0:	c1 a8       	rjmp	80007f14 <get_arg+0x268>
80007ee2:	f4 c2 00 30 	sub	r2,r10,48
80007ee6:	c0 68       	rjmp	80007ef2 <get_arg+0x246>
80007ee8:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007eec:	2f f7       	sub	r7,-1
80007eee:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007ef2:	0f 8a       	ld.ub	r10,r7[0x0]
80007ef4:	58 0a       	cp.w	r10,0
80007ef6:	c0 e0       	breq	80007f12 <get_arg+0x266>
80007ef8:	23 0a       	sub	r10,48
80007efa:	58 9a       	cp.w	r10,9
80007efc:	fe 98 ff f6 	brls	80007ee8 <get_arg+0x23c>
80007f00:	c0 98       	rjmp	80007f12 <get_arg+0x266>
80007f02:	2f f7       	sub	r7,-1
80007f04:	0f 8a       	ld.ub	r10,r7[0x0]
80007f06:	58 0a       	cp.w	r10,0
80007f08:	c0 50       	breq	80007f12 <get_arg+0x266>
80007f0a:	23 0a       	sub	r10,48
80007f0c:	58 9a       	cp.w	r10,9
80007f0e:	fe 98 ff fa 	brls	80007f02 <get_arg+0x256>
80007f12:	0e 9b       	mov	r11,r7
80007f14:	40 7c       	lddsp	r12,sp[0x1c]
80007f16:	30 ba       	mov	r10,11
80007f18:	f4 0c 18 00 	cp.b	r12,r10
80007f1c:	fe 91 fe f2 	brne	80007d00 <get_arg+0x54>
80007f20:	40 42       	lddsp	r2,sp[0x10]
80007f22:	17 8c       	ld.ub	r12,r11[0x0]
80007f24:	0a 32       	cp.w	r2,r5
80007f26:	5f 4a       	srge	r10
80007f28:	f0 0c 18 00 	cp.b	r12,r8
80007f2c:	5f 1c       	srne	r12
80007f2e:	f9 ea 00 0a 	and	r10,r12,r10
80007f32:	f0 0a 18 00 	cp.b	r10,r8
80007f36:	fe 91 fe cf 	brne	80007cd4 <get_arg+0x28>
80007f3a:	30 08       	mov	r8,0
80007f3c:	40 4e       	lddsp	lr,sp[0x10]
80007f3e:	17 8a       	ld.ub	r10,r11[0x0]
80007f40:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007f44:	f0 0a 18 00 	cp.b	r10,r8
80007f48:	fc 09 17 10 	movne	r9,lr
80007f4c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007f50:	06 9e       	mov	lr,r3
80007f52:	c2 a8       	rjmp	80007fa6 <get_arg+0x2fa>
80007f54:	62 0a       	ld.w	r10,r1[0x0]
80007f56:	58 3a       	cp.w	r10,3
80007f58:	c1 e0       	breq	80007f94 <get_arg+0x2e8>
80007f5a:	e0 89 00 07 	brgt	80007f68 <get_arg+0x2bc>
80007f5e:	58 1a       	cp.w	r10,1
80007f60:	c1 a0       	breq	80007f94 <get_arg+0x2e8>
80007f62:	58 2a       	cp.w	r10,2
80007f64:	c1 81       	brne	80007f94 <get_arg+0x2e8>
80007f66:	c0 58       	rjmp	80007f70 <get_arg+0x2c4>
80007f68:	58 5a       	cp.w	r10,5
80007f6a:	c0 c0       	breq	80007f82 <get_arg+0x2d6>
80007f6c:	c0 b5       	brlt	80007f82 <get_arg+0x2d6>
80007f6e:	c1 38       	rjmp	80007f94 <get_arg+0x2e8>
80007f70:	6c 0a       	ld.w	r10,r6[0x0]
80007f72:	f4 cc ff f8 	sub	r12,r10,-8
80007f76:	8d 0c       	st.w	r6[0x0],r12
80007f78:	f4 e2 00 00 	ld.d	r2,r10[0]
80007f7c:	f0 e3 00 00 	st.d	r8[0],r2
80007f80:	c1 08       	rjmp	80007fa0 <get_arg+0x2f4>
80007f82:	6c 0a       	ld.w	r10,r6[0x0]
80007f84:	f4 cc ff f8 	sub	r12,r10,-8
80007f88:	8d 0c       	st.w	r6[0x0],r12
80007f8a:	f4 e2 00 00 	ld.d	r2,r10[0]
80007f8e:	f0 e3 00 00 	st.d	r8[0],r2
80007f92:	c0 78       	rjmp	80007fa0 <get_arg+0x2f4>
80007f94:	6c 0a       	ld.w	r10,r6[0x0]
80007f96:	f4 cc ff fc 	sub	r12,r10,-4
80007f9a:	8d 0c       	st.w	r6[0x0],r12
80007f9c:	74 0a       	ld.w	r10,r10[0x0]
80007f9e:	91 0a       	st.w	r8[0x0],r10
80007fa0:	2f f5       	sub	r5,-1
80007fa2:	2f 88       	sub	r8,-8
80007fa4:	2f c1       	sub	r1,-4
80007fa6:	12 35       	cp.w	r5,r9
80007fa8:	fe 9a ff d6 	brle	80007f54 <get_arg+0x2a8>
80007fac:	1c 93       	mov	r3,lr
80007fae:	40 52       	lddsp	r2,sp[0x14]
80007fb0:	40 6e       	lddsp	lr,sp[0x18]
80007fb2:	85 05       	st.w	r2[0x0],r5
80007fb4:	9d 0b       	st.w	lr[0x0],r11
80007fb6:	40 4b       	lddsp	r11,sp[0x10]
80007fb8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007fbc:	2f 8d       	sub	sp,-32
80007fbe:	d8 32       	popm	r0-r7,pc

80007fc0 <__sprint_r>:
80007fc0:	d4 21       	pushm	r4-r7,lr
80007fc2:	14 97       	mov	r7,r10
80007fc4:	74 28       	ld.w	r8,r10[0x8]
80007fc6:	58 08       	cp.w	r8,0
80007fc8:	c0 41       	brne	80007fd0 <__sprint_r+0x10>
80007fca:	95 18       	st.w	r10[0x4],r8
80007fcc:	10 9c       	mov	r12,r8
80007fce:	d8 22       	popm	r4-r7,pc
80007fd0:	e0 a0 18 ba 	rcall	8000b144 <__sfvwrite_r>
80007fd4:	30 08       	mov	r8,0
80007fd6:	8f 18       	st.w	r7[0x4],r8
80007fd8:	8f 28       	st.w	r7[0x8],r8
80007fda:	d8 22       	popm	r4-r7,pc

80007fdc <_vfprintf_r>:
80007fdc:	d4 31       	pushm	r0-r7,lr
80007fde:	fa cd 06 bc 	sub	sp,sp,1724
80007fe2:	51 09       	stdsp	sp[0x40],r9
80007fe4:	16 91       	mov	r1,r11
80007fe6:	14 97       	mov	r7,r10
80007fe8:	18 95       	mov	r5,r12
80007fea:	e0 a0 1a 1d 	rcall	8000b424 <_localeconv_r>
80007fee:	78 0c       	ld.w	r12,r12[0x0]
80007ff0:	50 cc       	stdsp	sp[0x30],r12
80007ff2:	58 05       	cp.w	r5,0
80007ff4:	c0 70       	breq	80008002 <_vfprintf_r+0x26>
80007ff6:	6a 68       	ld.w	r8,r5[0x18]
80007ff8:	58 08       	cp.w	r8,0
80007ffa:	c0 41       	brne	80008002 <_vfprintf_r+0x26>
80007ffc:	0a 9c       	mov	r12,r5
80007ffe:	e0 a0 17 43 	rcall	8000ae84 <__sinit>
80008002:	fe c8 9b f2 	sub	r8,pc,-25614
80008006:	10 31       	cp.w	r1,r8
80008008:	c0 31       	brne	8000800e <_vfprintf_r+0x32>
8000800a:	6a 01       	ld.w	r1,r5[0x0]
8000800c:	c0 c8       	rjmp	80008024 <_vfprintf_r+0x48>
8000800e:	fe c8 9b de 	sub	r8,pc,-25634
80008012:	10 31       	cp.w	r1,r8
80008014:	c0 31       	brne	8000801a <_vfprintf_r+0x3e>
80008016:	6a 11       	ld.w	r1,r5[0x4]
80008018:	c0 68       	rjmp	80008024 <_vfprintf_r+0x48>
8000801a:	fe c8 9b ca 	sub	r8,pc,-25654
8000801e:	10 31       	cp.w	r1,r8
80008020:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008024:	82 68       	ld.sh	r8,r1[0xc]
80008026:	ed b8 00 03 	bld	r8,0x3
8000802a:	c0 41       	brne	80008032 <_vfprintf_r+0x56>
8000802c:	62 48       	ld.w	r8,r1[0x10]
8000802e:	58 08       	cp.w	r8,0
80008030:	c0 71       	brne	8000803e <_vfprintf_r+0x62>
80008032:	02 9b       	mov	r11,r1
80008034:	0a 9c       	mov	r12,r5
80008036:	e0 a0 0f 5d 	rcall	80009ef0 <__swsetup_r>
8000803a:	e0 81 0f 54 	brne	80009ee2 <_vfprintf_r+0x1f06>
8000803e:	82 68       	ld.sh	r8,r1[0xc]
80008040:	10 99       	mov	r9,r8
80008042:	e2 19 00 1a 	andl	r9,0x1a,COH
80008046:	58 a9       	cp.w	r9,10
80008048:	c3 c1       	brne	800080c0 <_vfprintf_r+0xe4>
8000804a:	82 79       	ld.sh	r9,r1[0xe]
8000804c:	30 0a       	mov	r10,0
8000804e:	f4 09 19 00 	cp.h	r9,r10
80008052:	c3 75       	brlt	800080c0 <_vfprintf_r+0xe4>
80008054:	a1 d8       	cbr	r8,0x1
80008056:	fb 58 05 d0 	st.h	sp[1488],r8
8000805a:	62 88       	ld.w	r8,r1[0x20]
8000805c:	fb 48 05 e4 	st.w	sp[1508],r8
80008060:	62 a8       	ld.w	r8,r1[0x28]
80008062:	fb 48 05 ec 	st.w	sp[1516],r8
80008066:	fa c8 ff bc 	sub	r8,sp,-68
8000806a:	fb 48 05 d4 	st.w	sp[1492],r8
8000806e:	fb 48 05 c4 	st.w	sp[1476],r8
80008072:	e0 68 04 00 	mov	r8,1024
80008076:	fb 48 05 d8 	st.w	sp[1496],r8
8000807a:	fb 48 05 cc 	st.w	sp[1484],r8
8000807e:	30 08       	mov	r8,0
80008080:	fb 59 05 d2 	st.h	sp[1490],r9
80008084:	0e 9a       	mov	r10,r7
80008086:	41 09       	lddsp	r9,sp[0x40]
80008088:	fa c7 fa 3c 	sub	r7,sp,-1476
8000808c:	fb 48 05 dc 	st.w	sp[1500],r8
80008090:	0a 9c       	mov	r12,r5
80008092:	0e 9b       	mov	r11,r7
80008094:	ca 4f       	rcall	80007fdc <_vfprintf_r>
80008096:	50 bc       	stdsp	sp[0x2c],r12
80008098:	c0 95       	brlt	800080aa <_vfprintf_r+0xce>
8000809a:	0e 9b       	mov	r11,r7
8000809c:	0a 9c       	mov	r12,r5
8000809e:	e0 a0 16 1b 	rcall	8000acd4 <_fflush_r>
800080a2:	40 be       	lddsp	lr,sp[0x2c]
800080a4:	f9 be 01 ff 	movne	lr,-1
800080a8:	50 be       	stdsp	sp[0x2c],lr
800080aa:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800080ae:	ed b8 00 06 	bld	r8,0x6
800080b2:	e0 81 0f 1a 	brne	80009ee6 <_vfprintf_r+0x1f0a>
800080b6:	82 68       	ld.sh	r8,r1[0xc]
800080b8:	a7 a8       	sbr	r8,0x6
800080ba:	a2 68       	st.h	r1[0xc],r8
800080bc:	e0 8f 0f 15 	bral	80009ee6 <_vfprintf_r+0x1f0a>
800080c0:	30 08       	mov	r8,0
800080c2:	fb 48 06 b4 	st.w	sp[1716],r8
800080c6:	fb 48 06 90 	st.w	sp[1680],r8
800080ca:	fb 48 06 8c 	st.w	sp[1676],r8
800080ce:	fb 48 06 b0 	st.w	sp[1712],r8
800080d2:	30 08       	mov	r8,0
800080d4:	30 09       	mov	r9,0
800080d6:	50 a7       	stdsp	sp[0x28],r7
800080d8:	50 78       	stdsp	sp[0x1c],r8
800080da:	fa c3 f9 e0 	sub	r3,sp,-1568
800080de:	3f f8       	mov	r8,-1
800080e0:	50 59       	stdsp	sp[0x14],r9
800080e2:	fb 43 06 88 	st.w	sp[1672],r3
800080e6:	fb 48 05 44 	st.w	sp[1348],r8
800080ea:	12 9c       	mov	r12,r9
800080ec:	50 69       	stdsp	sp[0x18],r9
800080ee:	50 d9       	stdsp	sp[0x34],r9
800080f0:	50 e9       	stdsp	sp[0x38],r9
800080f2:	50 b9       	stdsp	sp[0x2c],r9
800080f4:	12 97       	mov	r7,r9
800080f6:	0a 94       	mov	r4,r5
800080f8:	40 a2       	lddsp	r2,sp[0x28]
800080fa:	32 5a       	mov	r10,37
800080fc:	30 08       	mov	r8,0
800080fe:	c0 28       	rjmp	80008102 <_vfprintf_r+0x126>
80008100:	2f f2       	sub	r2,-1
80008102:	05 89       	ld.ub	r9,r2[0x0]
80008104:	f0 09 18 00 	cp.b	r9,r8
80008108:	5f 1b       	srne	r11
8000810a:	f4 09 18 00 	cp.b	r9,r10
8000810e:	5f 19       	srne	r9
80008110:	f3 eb 00 0b 	and	r11,r9,r11
80008114:	f0 0b 18 00 	cp.b	r11,r8
80008118:	cf 41       	brne	80008100 <_vfprintf_r+0x124>
8000811a:	40 ab       	lddsp	r11,sp[0x28]
8000811c:	e4 0b 01 06 	sub	r6,r2,r11
80008120:	c1 e0       	breq	8000815c <_vfprintf_r+0x180>
80008122:	fa f8 06 90 	ld.w	r8,sp[1680]
80008126:	0c 08       	add	r8,r6
80008128:	87 0b       	st.w	r3[0x0],r11
8000812a:	fb 48 06 90 	st.w	sp[1680],r8
8000812e:	87 16       	st.w	r3[0x4],r6
80008130:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008134:	2f f8       	sub	r8,-1
80008136:	fb 48 06 8c 	st.w	sp[1676],r8
8000813a:	58 78       	cp.w	r8,7
8000813c:	e0 89 00 04 	brgt	80008144 <_vfprintf_r+0x168>
80008140:	2f 83       	sub	r3,-8
80008142:	c0 a8       	rjmp	80008156 <_vfprintf_r+0x17a>
80008144:	fa ca f9 78 	sub	r10,sp,-1672
80008148:	02 9b       	mov	r11,r1
8000814a:	08 9c       	mov	r12,r4
8000814c:	c3 af       	rcall	80007fc0 <__sprint_r>
8000814e:	e0 81 0e c6 	brne	80009eda <_vfprintf_r+0x1efe>
80008152:	fa c3 f9 e0 	sub	r3,sp,-1568
80008156:	40 ba       	lddsp	r10,sp[0x2c]
80008158:	0c 0a       	add	r10,r6
8000815a:	50 ba       	stdsp	sp[0x2c],r10
8000815c:	05 89       	ld.ub	r9,r2[0x0]
8000815e:	30 08       	mov	r8,0
80008160:	f0 09 18 00 	cp.b	r9,r8
80008164:	e0 80 0e aa 	breq	80009eb8 <_vfprintf_r+0x1edc>
80008168:	30 09       	mov	r9,0
8000816a:	fb 68 06 bb 	st.b	sp[1723],r8
8000816e:	0e 96       	mov	r6,r7
80008170:	e4 c8 ff ff 	sub	r8,r2,-1
80008174:	3f fe       	mov	lr,-1
80008176:	50 93       	stdsp	sp[0x24],r3
80008178:	50 41       	stdsp	sp[0x10],r1
8000817a:	0e 93       	mov	r3,r7
8000817c:	04 91       	mov	r1,r2
8000817e:	50 89       	stdsp	sp[0x20],r9
80008180:	50 a8       	stdsp	sp[0x28],r8
80008182:	50 2e       	stdsp	sp[0x8],lr
80008184:	50 39       	stdsp	sp[0xc],r9
80008186:	12 95       	mov	r5,r9
80008188:	12 90       	mov	r0,r9
8000818a:	10 97       	mov	r7,r8
8000818c:	08 92       	mov	r2,r4
8000818e:	c0 78       	rjmp	8000819c <_vfprintf_r+0x1c0>
80008190:	3f fc       	mov	r12,-1
80008192:	08 97       	mov	r7,r4
80008194:	50 2c       	stdsp	sp[0x8],r12
80008196:	c0 38       	rjmp	8000819c <_vfprintf_r+0x1c0>
80008198:	30 0b       	mov	r11,0
8000819a:	50 3b       	stdsp	sp[0xc],r11
8000819c:	0f 38       	ld.ub	r8,r7++
8000819e:	c0 28       	rjmp	800081a2 <_vfprintf_r+0x1c6>
800081a0:	12 90       	mov	r0,r9
800081a2:	f0 c9 00 20 	sub	r9,r8,32
800081a6:	e0 49 00 58 	cp.w	r9,88
800081aa:	e0 8b 0a 30 	brhi	8000960a <_vfprintf_r+0x162e>
800081ae:	fe ca a1 46 	sub	r10,pc,-24250
800081b2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800081b6:	50 a7       	stdsp	sp[0x28],r7
800081b8:	50 80       	stdsp	sp[0x20],r0
800081ba:	0c 97       	mov	r7,r6
800081bc:	04 94       	mov	r4,r2
800081be:	06 96       	mov	r6,r3
800081c0:	02 92       	mov	r2,r1
800081c2:	fe c9 9f 1e 	sub	r9,pc,-24802
800081c6:	40 93       	lddsp	r3,sp[0x24]
800081c8:	10 90       	mov	r0,r8
800081ca:	40 41       	lddsp	r1,sp[0x10]
800081cc:	50 d9       	stdsp	sp[0x34],r9
800081ce:	e0 8f 08 8e 	bral	800092ea <_vfprintf_r+0x130e>
800081d2:	30 08       	mov	r8,0
800081d4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800081d8:	f0 09 18 00 	cp.b	r9,r8
800081dc:	ce 01       	brne	8000819c <_vfprintf_r+0x1c0>
800081de:	32 08       	mov	r8,32
800081e0:	c6 e8       	rjmp	800082bc <_vfprintf_r+0x2e0>
800081e2:	a1 a5       	sbr	r5,0x0
800081e4:	cd cb       	rjmp	8000819c <_vfprintf_r+0x1c0>
800081e6:	0f 89       	ld.ub	r9,r7[0x0]
800081e8:	f2 c8 00 30 	sub	r8,r9,48
800081ec:	58 98       	cp.w	r8,9
800081ee:	e0 8b 00 1d 	brhi	80008228 <_vfprintf_r+0x24c>
800081f2:	ee c8 ff ff 	sub	r8,r7,-1
800081f6:	30 0b       	mov	r11,0
800081f8:	23 09       	sub	r9,48
800081fa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800081fe:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008202:	11 39       	ld.ub	r9,r8++
80008204:	f2 ca 00 30 	sub	r10,r9,48
80008208:	58 9a       	cp.w	r10,9
8000820a:	fe 98 ff f7 	brls	800081f8 <_vfprintf_r+0x21c>
8000820e:	e0 49 00 24 	cp.w	r9,36
80008212:	cc 31       	brne	80008198 <_vfprintf_r+0x1bc>
80008214:	e0 4b 00 20 	cp.w	r11,32
80008218:	e0 89 0e 60 	brgt	80009ed8 <_vfprintf_r+0x1efc>
8000821c:	20 1b       	sub	r11,1
8000821e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008222:	12 3b       	cp.w	r11,r9
80008224:	c0 95       	brlt	80008236 <_vfprintf_r+0x25a>
80008226:	c1 08       	rjmp	80008246 <_vfprintf_r+0x26a>
80008228:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000822c:	ec ca ff ff 	sub	r10,r6,-1
80008230:	12 36       	cp.w	r6,r9
80008232:	c1 f5       	brlt	80008270 <_vfprintf_r+0x294>
80008234:	c2 68       	rjmp	80008280 <_vfprintf_r+0x2a4>
80008236:	fa ce f9 44 	sub	lr,sp,-1724
8000823a:	10 97       	mov	r7,r8
8000823c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008240:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008244:	c3 58       	rjmp	800082ae <_vfprintf_r+0x2d2>
80008246:	10 97       	mov	r7,r8
80008248:	fa c8 f9 50 	sub	r8,sp,-1712
8000824c:	1a d8       	st.w	--sp,r8
8000824e:	fa c8 fa b8 	sub	r8,sp,-1352
80008252:	1a d8       	st.w	--sp,r8
80008254:	fa c8 fb b4 	sub	r8,sp,-1100
80008258:	02 9a       	mov	r10,r1
8000825a:	1a d8       	st.w	--sp,r8
8000825c:	04 9c       	mov	r12,r2
8000825e:	fa c8 f9 40 	sub	r8,sp,-1728
80008262:	fa c9 ff b4 	sub	r9,sp,-76
80008266:	fe b0 fd 23 	rcall	80007cac <get_arg>
8000826a:	2f dd       	sub	sp,-12
8000826c:	78 00       	ld.w	r0,r12[0x0]
8000826e:	c2 08       	rjmp	800082ae <_vfprintf_r+0x2d2>
80008270:	fa cc f9 44 	sub	r12,sp,-1724
80008274:	14 96       	mov	r6,r10
80008276:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000827a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000827e:	c1 88       	rjmp	800082ae <_vfprintf_r+0x2d2>
80008280:	41 08       	lddsp	r8,sp[0x40]
80008282:	59 f9       	cp.w	r9,31
80008284:	e0 89 00 11 	brgt	800082a6 <_vfprintf_r+0x2ca>
80008288:	f0 cb ff fc 	sub	r11,r8,-4
8000828c:	51 0b       	stdsp	sp[0x40],r11
8000828e:	70 00       	ld.w	r0,r8[0x0]
80008290:	fa cb f9 44 	sub	r11,sp,-1724
80008294:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008298:	f1 40 fd 88 	st.w	r8[-632],r0
8000829c:	2f f9       	sub	r9,-1
8000829e:	14 96       	mov	r6,r10
800082a0:	fb 49 06 b4 	st.w	sp[1716],r9
800082a4:	c0 58       	rjmp	800082ae <_vfprintf_r+0x2d2>
800082a6:	70 00       	ld.w	r0,r8[0x0]
800082a8:	14 96       	mov	r6,r10
800082aa:	2f c8       	sub	r8,-4
800082ac:	51 08       	stdsp	sp[0x40],r8
800082ae:	58 00       	cp.w	r0,0
800082b0:	fe 94 ff 76 	brge	8000819c <_vfprintf_r+0x1c0>
800082b4:	5c 30       	neg	r0
800082b6:	a3 a5       	sbr	r5,0x2
800082b8:	c7 2b       	rjmp	8000819c <_vfprintf_r+0x1c0>
800082ba:	32 b8       	mov	r8,43
800082bc:	fb 68 06 bb 	st.b	sp[1723],r8
800082c0:	c6 eb       	rjmp	8000819c <_vfprintf_r+0x1c0>
800082c2:	0f 38       	ld.ub	r8,r7++
800082c4:	e0 48 00 2a 	cp.w	r8,42
800082c8:	c0 30       	breq	800082ce <_vfprintf_r+0x2f2>
800082ca:	30 09       	mov	r9,0
800082cc:	c7 98       	rjmp	800083be <_vfprintf_r+0x3e2>
800082ce:	0f 88       	ld.ub	r8,r7[0x0]
800082d0:	f0 c9 00 30 	sub	r9,r8,48
800082d4:	58 99       	cp.w	r9,9
800082d6:	e0 8b 00 1f 	brhi	80008314 <_vfprintf_r+0x338>
800082da:	ee c4 ff ff 	sub	r4,r7,-1
800082de:	30 0b       	mov	r11,0
800082e0:	23 08       	sub	r8,48
800082e2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800082e6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800082ea:	09 38       	ld.ub	r8,r4++
800082ec:	f0 c9 00 30 	sub	r9,r8,48
800082f0:	58 99       	cp.w	r9,9
800082f2:	fe 98 ff f7 	brls	800082e0 <_vfprintf_r+0x304>
800082f6:	e0 48 00 24 	cp.w	r8,36
800082fa:	fe 91 ff 4f 	brne	80008198 <_vfprintf_r+0x1bc>
800082fe:	e0 4b 00 20 	cp.w	r11,32
80008302:	e0 89 0d eb 	brgt	80009ed8 <_vfprintf_r+0x1efc>
80008306:	20 1b       	sub	r11,1
80008308:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000830c:	10 3b       	cp.w	r11,r8
8000830e:	c0 a5       	brlt	80008322 <_vfprintf_r+0x346>
80008310:	c1 18       	rjmp	80008332 <_vfprintf_r+0x356>
80008312:	d7 03       	nop
80008314:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008318:	ec c9 ff ff 	sub	r9,r6,-1
8000831c:	14 36       	cp.w	r6,r10
8000831e:	c1 f5       	brlt	8000835c <_vfprintf_r+0x380>
80008320:	c2 88       	rjmp	80008370 <_vfprintf_r+0x394>
80008322:	fa ca f9 44 	sub	r10,sp,-1724
80008326:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000832a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000832e:	50 2b       	stdsp	sp[0x8],r11
80008330:	c3 c8       	rjmp	800083a8 <_vfprintf_r+0x3cc>
80008332:	fa c8 f9 50 	sub	r8,sp,-1712
80008336:	1a d8       	st.w	--sp,r8
80008338:	fa c8 fa b8 	sub	r8,sp,-1352
8000833c:	1a d8       	st.w	--sp,r8
8000833e:	fa c8 fb b4 	sub	r8,sp,-1100
80008342:	02 9a       	mov	r10,r1
80008344:	1a d8       	st.w	--sp,r8
80008346:	04 9c       	mov	r12,r2
80008348:	fa c8 f9 40 	sub	r8,sp,-1728
8000834c:	fa c9 ff b4 	sub	r9,sp,-76
80008350:	fe b0 fc ae 	rcall	80007cac <get_arg>
80008354:	2f dd       	sub	sp,-12
80008356:	78 0c       	ld.w	r12,r12[0x0]
80008358:	50 2c       	stdsp	sp[0x8],r12
8000835a:	c2 78       	rjmp	800083a8 <_vfprintf_r+0x3cc>
8000835c:	12 96       	mov	r6,r9
8000835e:	0e 94       	mov	r4,r7
80008360:	fa c9 f9 44 	sub	r9,sp,-1724
80008364:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008368:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000836c:	50 28       	stdsp	sp[0x8],r8
8000836e:	c1 d8       	rjmp	800083a8 <_vfprintf_r+0x3cc>
80008370:	41 08       	lddsp	r8,sp[0x40]
80008372:	59 fa       	cp.w	r10,31
80008374:	e0 89 00 14 	brgt	8000839c <_vfprintf_r+0x3c0>
80008378:	f0 cb ff fc 	sub	r11,r8,-4
8000837c:	70 08       	ld.w	r8,r8[0x0]
8000837e:	51 0b       	stdsp	sp[0x40],r11
80008380:	50 28       	stdsp	sp[0x8],r8
80008382:	fa c6 f9 44 	sub	r6,sp,-1724
80008386:	40 2e       	lddsp	lr,sp[0x8]
80008388:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000838c:	f1 4e fd 88 	st.w	r8[-632],lr
80008390:	2f fa       	sub	r10,-1
80008392:	0e 94       	mov	r4,r7
80008394:	fb 4a 06 b4 	st.w	sp[1716],r10
80008398:	12 96       	mov	r6,r9
8000839a:	c0 78       	rjmp	800083a8 <_vfprintf_r+0x3cc>
8000839c:	70 0c       	ld.w	r12,r8[0x0]
8000839e:	0e 94       	mov	r4,r7
800083a0:	2f c8       	sub	r8,-4
800083a2:	50 2c       	stdsp	sp[0x8],r12
800083a4:	12 96       	mov	r6,r9
800083a6:	51 08       	stdsp	sp[0x40],r8
800083a8:	40 2b       	lddsp	r11,sp[0x8]
800083aa:	58 0b       	cp.w	r11,0
800083ac:	fe 95 fe f2 	brlt	80008190 <_vfprintf_r+0x1b4>
800083b0:	08 97       	mov	r7,r4
800083b2:	cf 5a       	rjmp	8000819c <_vfprintf_r+0x1c0>
800083b4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800083b8:	0f 38       	ld.ub	r8,r7++
800083ba:	f4 09 00 19 	add	r9,r10,r9<<0x1
800083be:	f0 ca 00 30 	sub	r10,r8,48
800083c2:	58 9a       	cp.w	r10,9
800083c4:	fe 98 ff f8 	brls	800083b4 <_vfprintf_r+0x3d8>
800083c8:	3f fa       	mov	r10,-1
800083ca:	f2 0a 0c 49 	max	r9,r9,r10
800083ce:	50 29       	stdsp	sp[0x8],r9
800083d0:	ce 9a       	rjmp	800081a2 <_vfprintf_r+0x1c6>
800083d2:	a7 b5       	sbr	r5,0x7
800083d4:	ce 4a       	rjmp	8000819c <_vfprintf_r+0x1c0>
800083d6:	30 09       	mov	r9,0
800083d8:	23 08       	sub	r8,48
800083da:	f2 09 00 29 	add	r9,r9,r9<<0x2
800083de:	f0 09 00 19 	add	r9,r8,r9<<0x1
800083e2:	0f 38       	ld.ub	r8,r7++
800083e4:	f0 ca 00 30 	sub	r10,r8,48
800083e8:	58 9a       	cp.w	r10,9
800083ea:	fe 98 ff f7 	brls	800083d8 <_vfprintf_r+0x3fc>
800083ee:	e0 48 00 24 	cp.w	r8,36
800083f2:	fe 91 fe d7 	brne	800081a0 <_vfprintf_r+0x1c4>
800083f6:	e0 49 00 20 	cp.w	r9,32
800083fa:	e0 89 0d 6f 	brgt	80009ed8 <_vfprintf_r+0x1efc>
800083fe:	f2 c3 00 01 	sub	r3,r9,1
80008402:	30 19       	mov	r9,1
80008404:	50 39       	stdsp	sp[0xc],r9
80008406:	cc ba       	rjmp	8000819c <_vfprintf_r+0x1c0>
80008408:	a3 b5       	sbr	r5,0x3
8000840a:	cc 9a       	rjmp	8000819c <_vfprintf_r+0x1c0>
8000840c:	a7 a5       	sbr	r5,0x6
8000840e:	cc 7a       	rjmp	8000819c <_vfprintf_r+0x1c0>
80008410:	0a 98       	mov	r8,r5
80008412:	a5 b5       	sbr	r5,0x5
80008414:	a5 a8       	sbr	r8,0x4
80008416:	0f 89       	ld.ub	r9,r7[0x0]
80008418:	36 ce       	mov	lr,108
8000841a:	fc 09 18 00 	cp.b	r9,lr
8000841e:	f7 b7 00 ff 	subeq	r7,-1
80008422:	f0 05 17 10 	movne	r5,r8
80008426:	cb ba       	rjmp	8000819c <_vfprintf_r+0x1c0>
80008428:	a5 b5       	sbr	r5,0x5
8000842a:	cb 9a       	rjmp	8000819c <_vfprintf_r+0x1c0>
8000842c:	50 a7       	stdsp	sp[0x28],r7
8000842e:	50 80       	stdsp	sp[0x20],r0
80008430:	0c 97       	mov	r7,r6
80008432:	10 90       	mov	r0,r8
80008434:	06 96       	mov	r6,r3
80008436:	04 94       	mov	r4,r2
80008438:	40 93       	lddsp	r3,sp[0x24]
8000843a:	02 92       	mov	r2,r1
8000843c:	0e 99       	mov	r9,r7
8000843e:	40 41       	lddsp	r1,sp[0x10]
80008440:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008444:	40 3c       	lddsp	r12,sp[0xc]
80008446:	58 0c       	cp.w	r12,0
80008448:	c1 d0       	breq	80008482 <_vfprintf_r+0x4a6>
8000844a:	10 36       	cp.w	r6,r8
8000844c:	c0 64       	brge	80008458 <_vfprintf_r+0x47c>
8000844e:	fa cb f9 44 	sub	r11,sp,-1724
80008452:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008456:	c1 d8       	rjmp	80008490 <_vfprintf_r+0x4b4>
80008458:	fa c8 f9 50 	sub	r8,sp,-1712
8000845c:	1a d8       	st.w	--sp,r8
8000845e:	fa c8 fa b8 	sub	r8,sp,-1352
80008462:	1a d8       	st.w	--sp,r8
80008464:	fa c8 fb b4 	sub	r8,sp,-1100
80008468:	1a d8       	st.w	--sp,r8
8000846a:	fa c8 f9 40 	sub	r8,sp,-1728
8000846e:	fa c9 ff b4 	sub	r9,sp,-76
80008472:	04 9a       	mov	r10,r2
80008474:	0c 9b       	mov	r11,r6
80008476:	08 9c       	mov	r12,r4
80008478:	fe b0 fc 1a 	rcall	80007cac <get_arg>
8000847c:	2f dd       	sub	sp,-12
8000847e:	19 b8       	ld.ub	r8,r12[0x3]
80008480:	c2 28       	rjmp	800084c4 <_vfprintf_r+0x4e8>
80008482:	2f f7       	sub	r7,-1
80008484:	10 39       	cp.w	r9,r8
80008486:	c0 84       	brge	80008496 <_vfprintf_r+0x4ba>
80008488:	fa ca f9 44 	sub	r10,sp,-1724
8000848c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008490:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008494:	c1 88       	rjmp	800084c4 <_vfprintf_r+0x4e8>
80008496:	41 09       	lddsp	r9,sp[0x40]
80008498:	59 f8       	cp.w	r8,31
8000849a:	e0 89 00 12 	brgt	800084be <_vfprintf_r+0x4e2>
8000849e:	f2 ca ff fc 	sub	r10,r9,-4
800084a2:	51 0a       	stdsp	sp[0x40],r10
800084a4:	72 09       	ld.w	r9,r9[0x0]
800084a6:	fa c6 f9 44 	sub	r6,sp,-1724
800084aa:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800084ae:	2f f8       	sub	r8,-1
800084b0:	f5 49 fd 88 	st.w	r10[-632],r9
800084b4:	fb 48 06 b4 	st.w	sp[1716],r8
800084b8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800084bc:	c0 48       	rjmp	800084c4 <_vfprintf_r+0x4e8>
800084be:	13 b8       	ld.ub	r8,r9[0x3]
800084c0:	2f c9       	sub	r9,-4
800084c2:	51 09       	stdsp	sp[0x40],r9
800084c4:	fb 68 06 60 	st.b	sp[1632],r8
800084c8:	30 0e       	mov	lr,0
800084ca:	30 08       	mov	r8,0
800084cc:	30 12       	mov	r2,1
800084ce:	fb 68 06 bb 	st.b	sp[1723],r8
800084d2:	50 2e       	stdsp	sp[0x8],lr
800084d4:	e0 8f 08 ad 	bral	8000962e <_vfprintf_r+0x1652>
800084d8:	50 a7       	stdsp	sp[0x28],r7
800084da:	50 80       	stdsp	sp[0x20],r0
800084dc:	0c 97       	mov	r7,r6
800084de:	04 94       	mov	r4,r2
800084e0:	06 96       	mov	r6,r3
800084e2:	02 92       	mov	r2,r1
800084e4:	40 93       	lddsp	r3,sp[0x24]
800084e6:	10 90       	mov	r0,r8
800084e8:	40 41       	lddsp	r1,sp[0x10]
800084ea:	a5 a5       	sbr	r5,0x4
800084ec:	c0 a8       	rjmp	80008500 <_vfprintf_r+0x524>
800084ee:	50 a7       	stdsp	sp[0x28],r7
800084f0:	50 80       	stdsp	sp[0x20],r0
800084f2:	0c 97       	mov	r7,r6
800084f4:	04 94       	mov	r4,r2
800084f6:	06 96       	mov	r6,r3
800084f8:	02 92       	mov	r2,r1
800084fa:	40 93       	lddsp	r3,sp[0x24]
800084fc:	10 90       	mov	r0,r8
800084fe:	40 41       	lddsp	r1,sp[0x10]
80008500:	ed b5 00 05 	bld	r5,0x5
80008504:	c5 11       	brne	800085a6 <_vfprintf_r+0x5ca>
80008506:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000850a:	40 3c       	lddsp	r12,sp[0xc]
8000850c:	58 0c       	cp.w	r12,0
8000850e:	c1 e0       	breq	8000854a <_vfprintf_r+0x56e>
80008510:	10 36       	cp.w	r6,r8
80008512:	c0 64       	brge	8000851e <_vfprintf_r+0x542>
80008514:	fa cb f9 44 	sub	r11,sp,-1724
80008518:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000851c:	c2 08       	rjmp	8000855c <_vfprintf_r+0x580>
8000851e:	fa c8 f9 50 	sub	r8,sp,-1712
80008522:	1a d8       	st.w	--sp,r8
80008524:	fa c8 fa b8 	sub	r8,sp,-1352
80008528:	0c 9b       	mov	r11,r6
8000852a:	1a d8       	st.w	--sp,r8
8000852c:	fa c8 fb b4 	sub	r8,sp,-1100
80008530:	1a d8       	st.w	--sp,r8
80008532:	fa c9 ff b4 	sub	r9,sp,-76
80008536:	fa c8 f9 40 	sub	r8,sp,-1728
8000853a:	04 9a       	mov	r10,r2
8000853c:	08 9c       	mov	r12,r4
8000853e:	fe b0 fb b7 	rcall	80007cac <get_arg>
80008542:	2f dd       	sub	sp,-12
80008544:	78 1b       	ld.w	r11,r12[0x4]
80008546:	78 09       	ld.w	r9,r12[0x0]
80008548:	c2 b8       	rjmp	8000859e <_vfprintf_r+0x5c2>
8000854a:	ee ca ff ff 	sub	r10,r7,-1
8000854e:	10 37       	cp.w	r7,r8
80008550:	c0 b4       	brge	80008566 <_vfprintf_r+0x58a>
80008552:	fa c9 f9 44 	sub	r9,sp,-1724
80008556:	14 97       	mov	r7,r10
80008558:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000855c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008560:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008564:	c1 d8       	rjmp	8000859e <_vfprintf_r+0x5c2>
80008566:	41 09       	lddsp	r9,sp[0x40]
80008568:	59 f8       	cp.w	r8,31
8000856a:	e0 89 00 14 	brgt	80008592 <_vfprintf_r+0x5b6>
8000856e:	f2 cb ff f8 	sub	r11,r9,-8
80008572:	51 0b       	stdsp	sp[0x40],r11
80008574:	fa c6 f9 44 	sub	r6,sp,-1724
80008578:	72 1b       	ld.w	r11,r9[0x4]
8000857a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000857e:	72 09       	ld.w	r9,r9[0x0]
80008580:	f9 4b fd 8c 	st.w	r12[-628],r11
80008584:	f9 49 fd 88 	st.w	r12[-632],r9
80008588:	2f f8       	sub	r8,-1
8000858a:	14 97       	mov	r7,r10
8000858c:	fb 48 06 b4 	st.w	sp[1716],r8
80008590:	c0 78       	rjmp	8000859e <_vfprintf_r+0x5c2>
80008592:	f2 c8 ff f8 	sub	r8,r9,-8
80008596:	72 1b       	ld.w	r11,r9[0x4]
80008598:	14 97       	mov	r7,r10
8000859a:	51 08       	stdsp	sp[0x40],r8
8000859c:	72 09       	ld.w	r9,r9[0x0]
8000859e:	16 98       	mov	r8,r11
800085a0:	fa e9 00 00 	st.d	sp[0],r8
800085a4:	ca e8       	rjmp	80008700 <_vfprintf_r+0x724>
800085a6:	ed b5 00 04 	bld	r5,0x4
800085aa:	c1 71       	brne	800085d8 <_vfprintf_r+0x5fc>
800085ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085b0:	40 3e       	lddsp	lr,sp[0xc]
800085b2:	58 0e       	cp.w	lr,0
800085b4:	c0 80       	breq	800085c4 <_vfprintf_r+0x5e8>
800085b6:	10 36       	cp.w	r6,r8
800085b8:	c6 94       	brge	8000868a <_vfprintf_r+0x6ae>
800085ba:	fa cc f9 44 	sub	r12,sp,-1724
800085be:	f8 06 00 36 	add	r6,r12,r6<<0x3
800085c2:	c8 28       	rjmp	800086c6 <_vfprintf_r+0x6ea>
800085c4:	ee ca ff ff 	sub	r10,r7,-1
800085c8:	10 37       	cp.w	r7,r8
800085ca:	e0 84 00 81 	brge	800086cc <_vfprintf_r+0x6f0>
800085ce:	fa cb f9 44 	sub	r11,sp,-1724
800085d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085d6:	c7 78       	rjmp	800086c4 <_vfprintf_r+0x6e8>
800085d8:	ed b5 00 06 	bld	r5,0x6
800085dc:	c4 b1       	brne	80008672 <_vfprintf_r+0x696>
800085de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085e2:	40 3c       	lddsp	r12,sp[0xc]
800085e4:	58 0c       	cp.w	r12,0
800085e6:	c1 d0       	breq	80008620 <_vfprintf_r+0x644>
800085e8:	10 36       	cp.w	r6,r8
800085ea:	c0 64       	brge	800085f6 <_vfprintf_r+0x61a>
800085ec:	fa cb f9 44 	sub	r11,sp,-1724
800085f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085f4:	c1 f8       	rjmp	80008632 <_vfprintf_r+0x656>
800085f6:	fa c8 f9 50 	sub	r8,sp,-1712
800085fa:	1a d8       	st.w	--sp,r8
800085fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008600:	1a d8       	st.w	--sp,r8
80008602:	fa c8 fb b4 	sub	r8,sp,-1100
80008606:	1a d8       	st.w	--sp,r8
80008608:	fa c8 f9 40 	sub	r8,sp,-1728
8000860c:	fa c9 ff b4 	sub	r9,sp,-76
80008610:	04 9a       	mov	r10,r2
80008612:	0c 9b       	mov	r11,r6
80008614:	08 9c       	mov	r12,r4
80008616:	fe b0 fb 4b 	rcall	80007cac <get_arg>
8000861a:	2f dd       	sub	sp,-12
8000861c:	98 18       	ld.sh	r8,r12[0x2]
8000861e:	c2 68       	rjmp	8000866a <_vfprintf_r+0x68e>
80008620:	ee ca ff ff 	sub	r10,r7,-1
80008624:	10 37       	cp.w	r7,r8
80008626:	c0 94       	brge	80008638 <_vfprintf_r+0x65c>
80008628:	fa c9 f9 44 	sub	r9,sp,-1724
8000862c:	14 97       	mov	r7,r10
8000862e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008632:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008636:	c1 a8       	rjmp	8000866a <_vfprintf_r+0x68e>
80008638:	41 09       	lddsp	r9,sp[0x40]
8000863a:	59 f8       	cp.w	r8,31
8000863c:	e0 89 00 13 	brgt	80008662 <_vfprintf_r+0x686>
80008640:	f2 cb ff fc 	sub	r11,r9,-4
80008644:	51 0b       	stdsp	sp[0x40],r11
80008646:	72 09       	ld.w	r9,r9[0x0]
80008648:	fa c6 f9 44 	sub	r6,sp,-1724
8000864c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008650:	2f f8       	sub	r8,-1
80008652:	f7 49 fd 88 	st.w	r11[-632],r9
80008656:	fb 48 06 b4 	st.w	sp[1716],r8
8000865a:	14 97       	mov	r7,r10
8000865c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008660:	c0 58       	rjmp	8000866a <_vfprintf_r+0x68e>
80008662:	92 18       	ld.sh	r8,r9[0x2]
80008664:	14 97       	mov	r7,r10
80008666:	2f c9       	sub	r9,-4
80008668:	51 09       	stdsp	sp[0x40],r9
8000866a:	50 18       	stdsp	sp[0x4],r8
8000866c:	bf 58       	asr	r8,0x1f
8000866e:	50 08       	stdsp	sp[0x0],r8
80008670:	c4 88       	rjmp	80008700 <_vfprintf_r+0x724>
80008672:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008676:	40 3c       	lddsp	r12,sp[0xc]
80008678:	58 0c       	cp.w	r12,0
8000867a:	c1 d0       	breq	800086b4 <_vfprintf_r+0x6d8>
8000867c:	10 36       	cp.w	r6,r8
8000867e:	c0 64       	brge	8000868a <_vfprintf_r+0x6ae>
80008680:	fa cb f9 44 	sub	r11,sp,-1724
80008684:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008688:	c1 f8       	rjmp	800086c6 <_vfprintf_r+0x6ea>
8000868a:	fa c8 f9 50 	sub	r8,sp,-1712
8000868e:	1a d8       	st.w	--sp,r8
80008690:	fa c8 fa b8 	sub	r8,sp,-1352
80008694:	0c 9b       	mov	r11,r6
80008696:	1a d8       	st.w	--sp,r8
80008698:	fa c8 fb b4 	sub	r8,sp,-1100
8000869c:	04 9a       	mov	r10,r2
8000869e:	1a d8       	st.w	--sp,r8
800086a0:	08 9c       	mov	r12,r4
800086a2:	fa c8 f9 40 	sub	r8,sp,-1728
800086a6:	fa c9 ff b4 	sub	r9,sp,-76
800086aa:	fe b0 fb 01 	rcall	80007cac <get_arg>
800086ae:	2f dd       	sub	sp,-12
800086b0:	78 0b       	ld.w	r11,r12[0x0]
800086b2:	c2 48       	rjmp	800086fa <_vfprintf_r+0x71e>
800086b4:	ee ca ff ff 	sub	r10,r7,-1
800086b8:	10 37       	cp.w	r7,r8
800086ba:	c0 94       	brge	800086cc <_vfprintf_r+0x6f0>
800086bc:	fa c9 f9 44 	sub	r9,sp,-1724
800086c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086c4:	14 97       	mov	r7,r10
800086c6:	ec fb fd 88 	ld.w	r11,r6[-632]
800086ca:	c1 88       	rjmp	800086fa <_vfprintf_r+0x71e>
800086cc:	41 09       	lddsp	r9,sp[0x40]
800086ce:	59 f8       	cp.w	r8,31
800086d0:	e0 89 00 11 	brgt	800086f2 <_vfprintf_r+0x716>
800086d4:	f2 cb ff fc 	sub	r11,r9,-4
800086d8:	51 0b       	stdsp	sp[0x40],r11
800086da:	fa c6 f9 44 	sub	r6,sp,-1724
800086de:	72 0b       	ld.w	r11,r9[0x0]
800086e0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086e4:	f3 4b fd 88 	st.w	r9[-632],r11
800086e8:	2f f8       	sub	r8,-1
800086ea:	14 97       	mov	r7,r10
800086ec:	fb 48 06 b4 	st.w	sp[1716],r8
800086f0:	c0 58       	rjmp	800086fa <_vfprintf_r+0x71e>
800086f2:	72 0b       	ld.w	r11,r9[0x0]
800086f4:	14 97       	mov	r7,r10
800086f6:	2f c9       	sub	r9,-4
800086f8:	51 09       	stdsp	sp[0x40],r9
800086fa:	50 1b       	stdsp	sp[0x4],r11
800086fc:	bf 5b       	asr	r11,0x1f
800086fe:	50 0b       	stdsp	sp[0x0],r11
80008700:	fa ea 00 00 	ld.d	r10,sp[0]
80008704:	58 0a       	cp.w	r10,0
80008706:	5c 2b       	cpc	r11
80008708:	c0 e4       	brge	80008724 <_vfprintf_r+0x748>
8000870a:	30 08       	mov	r8,0
8000870c:	fa ea 00 00 	ld.d	r10,sp[0]
80008710:	30 09       	mov	r9,0
80008712:	f0 0a 01 0a 	sub	r10,r8,r10
80008716:	f2 0b 01 4b 	sbc	r11,r9,r11
8000871a:	32 d8       	mov	r8,45
8000871c:	fa eb 00 00 	st.d	sp[0],r10
80008720:	fb 68 06 bb 	st.b	sp[1723],r8
80008724:	30 18       	mov	r8,1
80008726:	e0 8f 06 fa 	bral	8000951a <_vfprintf_r+0x153e>
8000872a:	50 a7       	stdsp	sp[0x28],r7
8000872c:	50 80       	stdsp	sp[0x20],r0
8000872e:	0c 97       	mov	r7,r6
80008730:	04 94       	mov	r4,r2
80008732:	06 96       	mov	r6,r3
80008734:	02 92       	mov	r2,r1
80008736:	40 93       	lddsp	r3,sp[0x24]
80008738:	10 90       	mov	r0,r8
8000873a:	40 41       	lddsp	r1,sp[0x10]
8000873c:	0e 99       	mov	r9,r7
8000873e:	ed b5 00 03 	bld	r5,0x3
80008742:	c4 11       	brne	800087c4 <_vfprintf_r+0x7e8>
80008744:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008748:	40 3a       	lddsp	r10,sp[0xc]
8000874a:	58 0a       	cp.w	r10,0
8000874c:	c1 90       	breq	8000877e <_vfprintf_r+0x7a2>
8000874e:	10 36       	cp.w	r6,r8
80008750:	c6 45       	brlt	80008818 <_vfprintf_r+0x83c>
80008752:	fa c8 f9 50 	sub	r8,sp,-1712
80008756:	1a d8       	st.w	--sp,r8
80008758:	fa c8 fa b8 	sub	r8,sp,-1352
8000875c:	1a d8       	st.w	--sp,r8
8000875e:	fa c8 fb b4 	sub	r8,sp,-1100
80008762:	0c 9b       	mov	r11,r6
80008764:	1a d8       	st.w	--sp,r8
80008766:	04 9a       	mov	r10,r2
80008768:	fa c8 f9 40 	sub	r8,sp,-1728
8000876c:	fa c9 ff b4 	sub	r9,sp,-76
80008770:	08 9c       	mov	r12,r4
80008772:	fe b0 fa 9d 	rcall	80007cac <get_arg>
80008776:	2f dd       	sub	sp,-12
80008778:	78 16       	ld.w	r6,r12[0x4]
8000877a:	50 76       	stdsp	sp[0x1c],r6
8000877c:	c4 88       	rjmp	8000880c <_vfprintf_r+0x830>
8000877e:	2f f7       	sub	r7,-1
80008780:	10 39       	cp.w	r9,r8
80008782:	c0 c4       	brge	8000879a <_vfprintf_r+0x7be>
80008784:	fa ce f9 44 	sub	lr,sp,-1724
80008788:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000878c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008790:	50 7c       	stdsp	sp[0x1c],r12
80008792:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008796:	50 56       	stdsp	sp[0x14],r6
80008798:	c6 68       	rjmp	80008864 <_vfprintf_r+0x888>
8000879a:	41 09       	lddsp	r9,sp[0x40]
8000879c:	59 f8       	cp.w	r8,31
8000879e:	e0 89 00 10 	brgt	800087be <_vfprintf_r+0x7e2>
800087a2:	f2 ca ff f8 	sub	r10,r9,-8
800087a6:	72 1b       	ld.w	r11,r9[0x4]
800087a8:	51 0a       	stdsp	sp[0x40],r10
800087aa:	72 09       	ld.w	r9,r9[0x0]
800087ac:	fa ca f9 44 	sub	r10,sp,-1724
800087b0:	50 7b       	stdsp	sp[0x1c],r11
800087b2:	50 59       	stdsp	sp[0x14],r9
800087b4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800087b8:	40 5b       	lddsp	r11,sp[0x14]
800087ba:	40 7a       	lddsp	r10,sp[0x1c]
800087bc:	c4 78       	rjmp	8000884a <_vfprintf_r+0x86e>
800087be:	72 18       	ld.w	r8,r9[0x4]
800087c0:	50 78       	stdsp	sp[0x1c],r8
800087c2:	c4 c8       	rjmp	8000885a <_vfprintf_r+0x87e>
800087c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087c8:	40 3e       	lddsp	lr,sp[0xc]
800087ca:	58 0e       	cp.w	lr,0
800087cc:	c2 30       	breq	80008812 <_vfprintf_r+0x836>
800087ce:	10 36       	cp.w	r6,r8
800087d0:	c0 94       	brge	800087e2 <_vfprintf_r+0x806>
800087d2:	fa cc f9 44 	sub	r12,sp,-1724
800087d6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800087da:	ec fb fd 8c 	ld.w	r11,r6[-628]
800087de:	50 7b       	stdsp	sp[0x1c],r11
800087e0:	cd 9b       	rjmp	80008792 <_vfprintf_r+0x7b6>
800087e2:	fa c8 f9 50 	sub	r8,sp,-1712
800087e6:	1a d8       	st.w	--sp,r8
800087e8:	fa c8 fa b8 	sub	r8,sp,-1352
800087ec:	04 9a       	mov	r10,r2
800087ee:	1a d8       	st.w	--sp,r8
800087f0:	fa c8 fb b4 	sub	r8,sp,-1100
800087f4:	0c 9b       	mov	r11,r6
800087f6:	1a d8       	st.w	--sp,r8
800087f8:	08 9c       	mov	r12,r4
800087fa:	fa c8 f9 40 	sub	r8,sp,-1728
800087fe:	fa c9 ff b4 	sub	r9,sp,-76
80008802:	fe b0 fa 55 	rcall	80007cac <get_arg>
80008806:	2f dd       	sub	sp,-12
80008808:	78 1a       	ld.w	r10,r12[0x4]
8000880a:	50 7a       	stdsp	sp[0x1c],r10
8000880c:	78 0c       	ld.w	r12,r12[0x0]
8000880e:	50 5c       	stdsp	sp[0x14],r12
80008810:	c2 a8       	rjmp	80008864 <_vfprintf_r+0x888>
80008812:	2f f7       	sub	r7,-1
80008814:	10 39       	cp.w	r9,r8
80008816:	c0 94       	brge	80008828 <_vfprintf_r+0x84c>
80008818:	fa c9 f9 44 	sub	r9,sp,-1724
8000881c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008820:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008824:	50 78       	stdsp	sp[0x1c],r8
80008826:	cb 6b       	rjmp	80008792 <_vfprintf_r+0x7b6>
80008828:	41 09       	lddsp	r9,sp[0x40]
8000882a:	59 f8       	cp.w	r8,31
8000882c:	e0 89 00 15 	brgt	80008856 <_vfprintf_r+0x87a>
80008830:	f2 ca ff f8 	sub	r10,r9,-8
80008834:	72 16       	ld.w	r6,r9[0x4]
80008836:	72 09       	ld.w	r9,r9[0x0]
80008838:	51 0a       	stdsp	sp[0x40],r10
8000883a:	50 59       	stdsp	sp[0x14],r9
8000883c:	fa ce f9 44 	sub	lr,sp,-1724
80008840:	50 76       	stdsp	sp[0x1c],r6
80008842:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008846:	40 5b       	lddsp	r11,sp[0x14]
80008848:	0c 9a       	mov	r10,r6
8000884a:	f2 eb fd 88 	st.d	r9[-632],r10
8000884e:	2f f8       	sub	r8,-1
80008850:	fb 48 06 b4 	st.w	sp[1716],r8
80008854:	c0 88       	rjmp	80008864 <_vfprintf_r+0x888>
80008856:	72 1c       	ld.w	r12,r9[0x4]
80008858:	50 7c       	stdsp	sp[0x1c],r12
8000885a:	f2 c8 ff f8 	sub	r8,r9,-8
8000885e:	51 08       	stdsp	sp[0x40],r8
80008860:	72 09       	ld.w	r9,r9[0x0]
80008862:	50 59       	stdsp	sp[0x14],r9
80008864:	40 5b       	lddsp	r11,sp[0x14]
80008866:	40 7a       	lddsp	r10,sp[0x1c]
80008868:	e0 a0 19 54 	rcall	8000bb10 <__isinfd>
8000886c:	18 96       	mov	r6,r12
8000886e:	c1 70       	breq	8000889c <_vfprintf_r+0x8c0>
80008870:	30 08       	mov	r8,0
80008872:	30 09       	mov	r9,0
80008874:	40 5b       	lddsp	r11,sp[0x14]
80008876:	40 7a       	lddsp	r10,sp[0x1c]
80008878:	e0 a0 1d a8 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000887c:	c0 40       	breq	80008884 <_vfprintf_r+0x8a8>
8000887e:	32 d8       	mov	r8,45
80008880:	fb 68 06 bb 	st.b	sp[1723],r8
80008884:	fe c8 a5 cc 	sub	r8,pc,-23092
80008888:	fe c6 a5 cc 	sub	r6,pc,-23092
8000888c:	a7 d5       	cbr	r5,0x7
8000888e:	e0 40 00 47 	cp.w	r0,71
80008892:	f0 06 17 a0 	movle	r6,r8
80008896:	30 32       	mov	r2,3
80008898:	e0 8f 06 ce 	bral	80009634 <_vfprintf_r+0x1658>
8000889c:	40 5b       	lddsp	r11,sp[0x14]
8000889e:	40 7a       	lddsp	r10,sp[0x1c]
800088a0:	e0 a0 19 4d 	rcall	8000bb3a <__isnand>
800088a4:	c0 e0       	breq	800088c0 <_vfprintf_r+0x8e4>
800088a6:	50 26       	stdsp	sp[0x8],r6
800088a8:	fe c8 a5 e8 	sub	r8,pc,-23064
800088ac:	fe c6 a5 e8 	sub	r6,pc,-23064
800088b0:	a7 d5       	cbr	r5,0x7
800088b2:	e0 40 00 47 	cp.w	r0,71
800088b6:	f0 06 17 a0 	movle	r6,r8
800088ba:	30 32       	mov	r2,3
800088bc:	e0 8f 06 c2 	bral	80009640 <_vfprintf_r+0x1664>
800088c0:	40 2a       	lddsp	r10,sp[0x8]
800088c2:	5b fa       	cp.w	r10,-1
800088c4:	c0 41       	brne	800088cc <_vfprintf_r+0x8f0>
800088c6:	30 69       	mov	r9,6
800088c8:	50 29       	stdsp	sp[0x8],r9
800088ca:	c1 18       	rjmp	800088ec <_vfprintf_r+0x910>
800088cc:	e0 40 00 47 	cp.w	r0,71
800088d0:	5f 09       	sreq	r9
800088d2:	e0 40 00 67 	cp.w	r0,103
800088d6:	5f 08       	sreq	r8
800088d8:	f3 e8 10 08 	or	r8,r9,r8
800088dc:	f8 08 18 00 	cp.b	r8,r12
800088e0:	c0 60       	breq	800088ec <_vfprintf_r+0x910>
800088e2:	40 28       	lddsp	r8,sp[0x8]
800088e4:	58 08       	cp.w	r8,0
800088e6:	f9 b8 00 01 	moveq	r8,1
800088ea:	50 28       	stdsp	sp[0x8],r8
800088ec:	40 78       	lddsp	r8,sp[0x1c]
800088ee:	40 59       	lddsp	r9,sp[0x14]
800088f0:	fa e9 06 94 	st.d	sp[1684],r8
800088f4:	a9 a5       	sbr	r5,0x8
800088f6:	fa f8 06 94 	ld.w	r8,sp[1684]
800088fa:	58 08       	cp.w	r8,0
800088fc:	c0 65       	brlt	80008908 <_vfprintf_r+0x92c>
800088fe:	40 5e       	lddsp	lr,sp[0x14]
80008900:	30 0c       	mov	r12,0
80008902:	50 6e       	stdsp	sp[0x18],lr
80008904:	50 9c       	stdsp	sp[0x24],r12
80008906:	c0 78       	rjmp	80008914 <_vfprintf_r+0x938>
80008908:	40 5b       	lddsp	r11,sp[0x14]
8000890a:	32 da       	mov	r10,45
8000890c:	ee 1b 80 00 	eorh	r11,0x8000
80008910:	50 9a       	stdsp	sp[0x24],r10
80008912:	50 6b       	stdsp	sp[0x18],r11
80008914:	e0 40 00 46 	cp.w	r0,70
80008918:	5f 09       	sreq	r9
8000891a:	e0 40 00 66 	cp.w	r0,102
8000891e:	5f 08       	sreq	r8
80008920:	f3 e8 10 08 	or	r8,r9,r8
80008924:	50 48       	stdsp	sp[0x10],r8
80008926:	c0 40       	breq	8000892e <_vfprintf_r+0x952>
80008928:	40 22       	lddsp	r2,sp[0x8]
8000892a:	30 39       	mov	r9,3
8000892c:	c1 08       	rjmp	8000894c <_vfprintf_r+0x970>
8000892e:	e0 40 00 45 	cp.w	r0,69
80008932:	5f 09       	sreq	r9
80008934:	e0 40 00 65 	cp.w	r0,101
80008938:	5f 08       	sreq	r8
8000893a:	40 22       	lddsp	r2,sp[0x8]
8000893c:	10 49       	or	r9,r8
8000893e:	2f f2       	sub	r2,-1
80008940:	40 46       	lddsp	r6,sp[0x10]
80008942:	ec 09 18 00 	cp.b	r9,r6
80008946:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000894a:	30 29       	mov	r9,2
8000894c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008950:	1a d8       	st.w	--sp,r8
80008952:	fa c8 f9 54 	sub	r8,sp,-1708
80008956:	1a d8       	st.w	--sp,r8
80008958:	fa c8 f9 4c 	sub	r8,sp,-1716
8000895c:	08 9c       	mov	r12,r4
8000895e:	1a d8       	st.w	--sp,r8
80008960:	04 98       	mov	r8,r2
80008962:	40 9b       	lddsp	r11,sp[0x24]
80008964:	40 aa       	lddsp	r10,sp[0x28]
80008966:	e0 a0 0b c3 	rcall	8000a0ec <_dtoa_r>
8000896a:	e0 40 00 47 	cp.w	r0,71
8000896e:	5f 19       	srne	r9
80008970:	e0 40 00 67 	cp.w	r0,103
80008974:	5f 18       	srne	r8
80008976:	18 96       	mov	r6,r12
80008978:	2f dd       	sub	sp,-12
8000897a:	f3 e8 00 08 	and	r8,r9,r8
8000897e:	c0 41       	brne	80008986 <_vfprintf_r+0x9aa>
80008980:	ed b5 00 00 	bld	r5,0x0
80008984:	c3 01       	brne	800089e4 <_vfprintf_r+0xa08>
80008986:	ec 02 00 0e 	add	lr,r6,r2
8000898a:	50 3e       	stdsp	sp[0xc],lr
8000898c:	40 4c       	lddsp	r12,sp[0x10]
8000898e:	58 0c       	cp.w	r12,0
80008990:	c1 50       	breq	800089ba <_vfprintf_r+0x9de>
80008992:	0d 89       	ld.ub	r9,r6[0x0]
80008994:	33 08       	mov	r8,48
80008996:	f0 09 18 00 	cp.b	r9,r8
8000899a:	c0 b1       	brne	800089b0 <_vfprintf_r+0x9d4>
8000899c:	30 08       	mov	r8,0
8000899e:	30 09       	mov	r9,0
800089a0:	40 6b       	lddsp	r11,sp[0x18]
800089a2:	40 7a       	lddsp	r10,sp[0x1c]
800089a4:	e0 a0 1c cb 	rcall	8000c33a <__avr32_f64_cmp_eq>
800089a8:	fb b2 00 01 	rsubeq	r2,1
800089ac:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800089b0:	40 3b       	lddsp	r11,sp[0xc]
800089b2:	fa f8 06 ac 	ld.w	r8,sp[1708]
800089b6:	10 0b       	add	r11,r8
800089b8:	50 3b       	stdsp	sp[0xc],r11
800089ba:	40 6b       	lddsp	r11,sp[0x18]
800089bc:	30 08       	mov	r8,0
800089be:	30 09       	mov	r9,0
800089c0:	40 7a       	lddsp	r10,sp[0x1c]
800089c2:	e0 a0 1c bc 	rcall	8000c33a <__avr32_f64_cmp_eq>
800089c6:	c0 90       	breq	800089d8 <_vfprintf_r+0x9fc>
800089c8:	40 3a       	lddsp	r10,sp[0xc]
800089ca:	fb 4a 06 a4 	st.w	sp[1700],r10
800089ce:	c0 58       	rjmp	800089d8 <_vfprintf_r+0x9fc>
800089d0:	10 c9       	st.b	r8++,r9
800089d2:	fb 48 06 a4 	st.w	sp[1700],r8
800089d6:	c0 28       	rjmp	800089da <_vfprintf_r+0x9fe>
800089d8:	33 09       	mov	r9,48
800089da:	fa f8 06 a4 	ld.w	r8,sp[1700]
800089de:	40 3e       	lddsp	lr,sp[0xc]
800089e0:	1c 38       	cp.w	r8,lr
800089e2:	cf 73       	brcs	800089d0 <_vfprintf_r+0x9f4>
800089e4:	e0 40 00 47 	cp.w	r0,71
800089e8:	5f 09       	sreq	r9
800089ea:	e0 40 00 67 	cp.w	r0,103
800089ee:	5f 08       	sreq	r8
800089f0:	f3 e8 10 08 	or	r8,r9,r8
800089f4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800089f8:	0c 19       	sub	r9,r6
800089fa:	50 69       	stdsp	sp[0x18],r9
800089fc:	58 08       	cp.w	r8,0
800089fe:	c0 b0       	breq	80008a14 <_vfprintf_r+0xa38>
80008a00:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a04:	5b d8       	cp.w	r8,-3
80008a06:	c0 55       	brlt	80008a10 <_vfprintf_r+0xa34>
80008a08:	40 2c       	lddsp	r12,sp[0x8]
80008a0a:	18 38       	cp.w	r8,r12
80008a0c:	e0 8a 00 6a 	brle	80008ae0 <_vfprintf_r+0xb04>
80008a10:	20 20       	sub	r0,2
80008a12:	c0 58       	rjmp	80008a1c <_vfprintf_r+0xa40>
80008a14:	e0 40 00 65 	cp.w	r0,101
80008a18:	e0 89 00 46 	brgt	80008aa4 <_vfprintf_r+0xac8>
80008a1c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008a20:	fb 60 06 9c 	st.b	sp[1692],r0
80008a24:	20 1b       	sub	r11,1
80008a26:	fb 4b 06 ac 	st.w	sp[1708],r11
80008a2a:	c0 47       	brpl	80008a32 <_vfprintf_r+0xa56>
80008a2c:	5c 3b       	neg	r11
80008a2e:	32 d8       	mov	r8,45
80008a30:	c0 28       	rjmp	80008a34 <_vfprintf_r+0xa58>
80008a32:	32 b8       	mov	r8,43
80008a34:	fb 68 06 9d 	st.b	sp[1693],r8
80008a38:	58 9b       	cp.w	r11,9
80008a3a:	e0 8a 00 1d 	brle	80008a74 <_vfprintf_r+0xa98>
80008a3e:	fa c9 fa 35 	sub	r9,sp,-1483
80008a42:	30 aa       	mov	r10,10
80008a44:	12 98       	mov	r8,r9
80008a46:	0e 9c       	mov	r12,r7
80008a48:	0c 92       	mov	r2,r6
80008a4a:	f6 0a 0c 06 	divs	r6,r11,r10
80008a4e:	0e 9b       	mov	r11,r7
80008a50:	2d 0b       	sub	r11,-48
80008a52:	10 fb       	st.b	--r8,r11
80008a54:	0c 9b       	mov	r11,r6
80008a56:	58 96       	cp.w	r6,9
80008a58:	fe 99 ff f9 	brgt	80008a4a <_vfprintf_r+0xa6e>
80008a5c:	2d 0b       	sub	r11,-48
80008a5e:	18 97       	mov	r7,r12
80008a60:	04 96       	mov	r6,r2
80008a62:	10 fb       	st.b	--r8,r11
80008a64:	fa ca f9 62 	sub	r10,sp,-1694
80008a68:	c0 38       	rjmp	80008a6e <_vfprintf_r+0xa92>
80008a6a:	11 3b       	ld.ub	r11,r8++
80008a6c:	14 cb       	st.b	r10++,r11
80008a6e:	12 38       	cp.w	r8,r9
80008a70:	cf d3       	brcs	80008a6a <_vfprintf_r+0xa8e>
80008a72:	c0 98       	rjmp	80008a84 <_vfprintf_r+0xaa8>
80008a74:	2d 0b       	sub	r11,-48
80008a76:	33 08       	mov	r8,48
80008a78:	fb 6b 06 9f 	st.b	sp[1695],r11
80008a7c:	fb 68 06 9e 	st.b	sp[1694],r8
80008a80:	fa ca f9 60 	sub	r10,sp,-1696
80008a84:	fa c8 f9 64 	sub	r8,sp,-1692
80008a88:	f4 08 01 08 	sub	r8,r10,r8
80008a8c:	50 e8       	stdsp	sp[0x38],r8
80008a8e:	10 92       	mov	r2,r8
80008a90:	40 6b       	lddsp	r11,sp[0x18]
80008a92:	16 02       	add	r2,r11
80008a94:	58 1b       	cp.w	r11,1
80008a96:	e0 89 00 05 	brgt	80008aa0 <_vfprintf_r+0xac4>
80008a9a:	ed b5 00 00 	bld	r5,0x0
80008a9e:	c3 51       	brne	80008b08 <_vfprintf_r+0xb2c>
80008aa0:	2f f2       	sub	r2,-1
80008aa2:	c3 38       	rjmp	80008b08 <_vfprintf_r+0xb2c>
80008aa4:	e0 40 00 66 	cp.w	r0,102
80008aa8:	c1 c1       	brne	80008ae0 <_vfprintf_r+0xb04>
80008aaa:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008aae:	58 02       	cp.w	r2,0
80008ab0:	e0 8a 00 0c 	brle	80008ac8 <_vfprintf_r+0xaec>
80008ab4:	40 2a       	lddsp	r10,sp[0x8]
80008ab6:	58 0a       	cp.w	r10,0
80008ab8:	c0 41       	brne	80008ac0 <_vfprintf_r+0xae4>
80008aba:	ed b5 00 00 	bld	r5,0x0
80008abe:	c2 51       	brne	80008b08 <_vfprintf_r+0xb2c>
80008ac0:	2f f2       	sub	r2,-1
80008ac2:	40 29       	lddsp	r9,sp[0x8]
80008ac4:	12 02       	add	r2,r9
80008ac6:	c0 b8       	rjmp	80008adc <_vfprintf_r+0xb00>
80008ac8:	40 28       	lddsp	r8,sp[0x8]
80008aca:	58 08       	cp.w	r8,0
80008acc:	c0 61       	brne	80008ad8 <_vfprintf_r+0xafc>
80008ace:	ed b5 00 00 	bld	r5,0x0
80008ad2:	c0 30       	breq	80008ad8 <_vfprintf_r+0xafc>
80008ad4:	30 12       	mov	r2,1
80008ad6:	c1 98       	rjmp	80008b08 <_vfprintf_r+0xb2c>
80008ad8:	40 22       	lddsp	r2,sp[0x8]
80008ada:	2f e2       	sub	r2,-2
80008adc:	36 60       	mov	r0,102
80008ade:	c1 58       	rjmp	80008b08 <_vfprintf_r+0xb2c>
80008ae0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008ae4:	40 6e       	lddsp	lr,sp[0x18]
80008ae6:	1c 32       	cp.w	r2,lr
80008ae8:	c0 65       	brlt	80008af4 <_vfprintf_r+0xb18>
80008aea:	ed b5 00 00 	bld	r5,0x0
80008aee:	f7 b2 00 ff 	subeq	r2,-1
80008af2:	c0 a8       	rjmp	80008b06 <_vfprintf_r+0xb2a>
80008af4:	e4 08 11 02 	rsub	r8,r2,2
80008af8:	40 6c       	lddsp	r12,sp[0x18]
80008afa:	58 02       	cp.w	r2,0
80008afc:	f0 02 17 a0 	movle	r2,r8
80008b00:	f9 b2 09 01 	movgt	r2,1
80008b04:	18 02       	add	r2,r12
80008b06:	36 70       	mov	r0,103
80008b08:	40 9b       	lddsp	r11,sp[0x24]
80008b0a:	58 0b       	cp.w	r11,0
80008b0c:	e0 80 05 94 	breq	80009634 <_vfprintf_r+0x1658>
80008b10:	32 d8       	mov	r8,45
80008b12:	fb 68 06 bb 	st.b	sp[1723],r8
80008b16:	e0 8f 05 93 	bral	8000963c <_vfprintf_r+0x1660>
80008b1a:	50 a7       	stdsp	sp[0x28],r7
80008b1c:	04 94       	mov	r4,r2
80008b1e:	0c 97       	mov	r7,r6
80008b20:	02 92       	mov	r2,r1
80008b22:	06 96       	mov	r6,r3
80008b24:	40 41       	lddsp	r1,sp[0x10]
80008b26:	40 93       	lddsp	r3,sp[0x24]
80008b28:	0e 99       	mov	r9,r7
80008b2a:	ed b5 00 05 	bld	r5,0x5
80008b2e:	c4 81       	brne	80008bbe <_vfprintf_r+0xbe2>
80008b30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b34:	40 3e       	lddsp	lr,sp[0xc]
80008b36:	58 0e       	cp.w	lr,0
80008b38:	c1 d0       	breq	80008b72 <_vfprintf_r+0xb96>
80008b3a:	10 36       	cp.w	r6,r8
80008b3c:	c0 64       	brge	80008b48 <_vfprintf_r+0xb6c>
80008b3e:	fa cc f9 44 	sub	r12,sp,-1724
80008b42:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008b46:	c1 d8       	rjmp	80008b80 <_vfprintf_r+0xba4>
80008b48:	fa c8 f9 50 	sub	r8,sp,-1712
80008b4c:	1a d8       	st.w	--sp,r8
80008b4e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b52:	04 9a       	mov	r10,r2
80008b54:	1a d8       	st.w	--sp,r8
80008b56:	fa c8 fb b4 	sub	r8,sp,-1100
80008b5a:	0c 9b       	mov	r11,r6
80008b5c:	1a d8       	st.w	--sp,r8
80008b5e:	08 9c       	mov	r12,r4
80008b60:	fa c8 f9 40 	sub	r8,sp,-1728
80008b64:	fa c9 ff b4 	sub	r9,sp,-76
80008b68:	fe b0 f8 a2 	rcall	80007cac <get_arg>
80008b6c:	2f dd       	sub	sp,-12
80008b6e:	78 0a       	ld.w	r10,r12[0x0]
80008b70:	c2 08       	rjmp	80008bb0 <_vfprintf_r+0xbd4>
80008b72:	2f f7       	sub	r7,-1
80008b74:	10 39       	cp.w	r9,r8
80008b76:	c0 84       	brge	80008b86 <_vfprintf_r+0xbaa>
80008b78:	fa cb f9 44 	sub	r11,sp,-1724
80008b7c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b80:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b84:	c1 68       	rjmp	80008bb0 <_vfprintf_r+0xbd4>
80008b86:	41 09       	lddsp	r9,sp[0x40]
80008b88:	59 f8       	cp.w	r8,31
80008b8a:	e0 89 00 10 	brgt	80008baa <_vfprintf_r+0xbce>
80008b8e:	f2 ca ff fc 	sub	r10,r9,-4
80008b92:	51 0a       	stdsp	sp[0x40],r10
80008b94:	fa c6 f9 44 	sub	r6,sp,-1724
80008b98:	72 0a       	ld.w	r10,r9[0x0]
80008b9a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b9e:	f3 4a fd 88 	st.w	r9[-632],r10
80008ba2:	2f f8       	sub	r8,-1
80008ba4:	fb 48 06 b4 	st.w	sp[1716],r8
80008ba8:	c0 48       	rjmp	80008bb0 <_vfprintf_r+0xbd4>
80008baa:	72 0a       	ld.w	r10,r9[0x0]
80008bac:	2f c9       	sub	r9,-4
80008bae:	51 09       	stdsp	sp[0x40],r9
80008bb0:	40 be       	lddsp	lr,sp[0x2c]
80008bb2:	1c 98       	mov	r8,lr
80008bb4:	95 1e       	st.w	r10[0x4],lr
80008bb6:	bf 58       	asr	r8,0x1f
80008bb8:	95 08       	st.w	r10[0x0],r8
80008bba:	fe 9f fa 9f 	bral	800080f8 <_vfprintf_r+0x11c>
80008bbe:	ed b5 00 04 	bld	r5,0x4
80008bc2:	c4 80       	breq	80008c52 <_vfprintf_r+0xc76>
80008bc4:	e2 15 00 40 	andl	r5,0x40,COH
80008bc8:	c4 50       	breq	80008c52 <_vfprintf_r+0xc76>
80008bca:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bce:	40 3c       	lddsp	r12,sp[0xc]
80008bd0:	58 0c       	cp.w	r12,0
80008bd2:	c1 d0       	breq	80008c0c <_vfprintf_r+0xc30>
80008bd4:	10 36       	cp.w	r6,r8
80008bd6:	c0 64       	brge	80008be2 <_vfprintf_r+0xc06>
80008bd8:	fa cb f9 44 	sub	r11,sp,-1724
80008bdc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008be0:	c1 d8       	rjmp	80008c1a <_vfprintf_r+0xc3e>
80008be2:	fa c8 f9 50 	sub	r8,sp,-1712
80008be6:	1a d8       	st.w	--sp,r8
80008be8:	fa c8 fa b8 	sub	r8,sp,-1352
80008bec:	04 9a       	mov	r10,r2
80008bee:	1a d8       	st.w	--sp,r8
80008bf0:	fa c8 fb b4 	sub	r8,sp,-1100
80008bf4:	0c 9b       	mov	r11,r6
80008bf6:	1a d8       	st.w	--sp,r8
80008bf8:	08 9c       	mov	r12,r4
80008bfa:	fa c8 f9 40 	sub	r8,sp,-1728
80008bfe:	fa c9 ff b4 	sub	r9,sp,-76
80008c02:	fe b0 f8 55 	rcall	80007cac <get_arg>
80008c06:	2f dd       	sub	sp,-12
80008c08:	78 0a       	ld.w	r10,r12[0x0]
80008c0a:	c2 08       	rjmp	80008c4a <_vfprintf_r+0xc6e>
80008c0c:	2f f7       	sub	r7,-1
80008c0e:	10 39       	cp.w	r9,r8
80008c10:	c0 84       	brge	80008c20 <_vfprintf_r+0xc44>
80008c12:	fa ca f9 44 	sub	r10,sp,-1724
80008c16:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c1a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c1e:	c1 68       	rjmp	80008c4a <_vfprintf_r+0xc6e>
80008c20:	41 09       	lddsp	r9,sp[0x40]
80008c22:	59 f8       	cp.w	r8,31
80008c24:	e0 89 00 10 	brgt	80008c44 <_vfprintf_r+0xc68>
80008c28:	f2 ca ff fc 	sub	r10,r9,-4
80008c2c:	51 0a       	stdsp	sp[0x40],r10
80008c2e:	fa c6 f9 44 	sub	r6,sp,-1724
80008c32:	72 0a       	ld.w	r10,r9[0x0]
80008c34:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c38:	f3 4a fd 88 	st.w	r9[-632],r10
80008c3c:	2f f8       	sub	r8,-1
80008c3e:	fb 48 06 b4 	st.w	sp[1716],r8
80008c42:	c0 48       	rjmp	80008c4a <_vfprintf_r+0xc6e>
80008c44:	72 0a       	ld.w	r10,r9[0x0]
80008c46:	2f c9       	sub	r9,-4
80008c48:	51 09       	stdsp	sp[0x40],r9
80008c4a:	40 be       	lddsp	lr,sp[0x2c]
80008c4c:	b4 0e       	st.h	r10[0x0],lr
80008c4e:	fe 9f fa 55 	bral	800080f8 <_vfprintf_r+0x11c>
80008c52:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c56:	40 3c       	lddsp	r12,sp[0xc]
80008c58:	58 0c       	cp.w	r12,0
80008c5a:	c1 d0       	breq	80008c94 <_vfprintf_r+0xcb8>
80008c5c:	10 36       	cp.w	r6,r8
80008c5e:	c0 64       	brge	80008c6a <_vfprintf_r+0xc8e>
80008c60:	fa cb f9 44 	sub	r11,sp,-1724
80008c64:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c68:	c1 d8       	rjmp	80008ca2 <_vfprintf_r+0xcc6>
80008c6a:	fa c8 f9 50 	sub	r8,sp,-1712
80008c6e:	1a d8       	st.w	--sp,r8
80008c70:	fa c8 fa b8 	sub	r8,sp,-1352
80008c74:	04 9a       	mov	r10,r2
80008c76:	1a d8       	st.w	--sp,r8
80008c78:	fa c8 fb b4 	sub	r8,sp,-1100
80008c7c:	0c 9b       	mov	r11,r6
80008c7e:	1a d8       	st.w	--sp,r8
80008c80:	08 9c       	mov	r12,r4
80008c82:	fa c8 f9 40 	sub	r8,sp,-1728
80008c86:	fa c9 ff b4 	sub	r9,sp,-76
80008c8a:	fe b0 f8 11 	rcall	80007cac <get_arg>
80008c8e:	2f dd       	sub	sp,-12
80008c90:	78 0a       	ld.w	r10,r12[0x0]
80008c92:	c2 08       	rjmp	80008cd2 <_vfprintf_r+0xcf6>
80008c94:	2f f7       	sub	r7,-1
80008c96:	10 39       	cp.w	r9,r8
80008c98:	c0 84       	brge	80008ca8 <_vfprintf_r+0xccc>
80008c9a:	fa ca f9 44 	sub	r10,sp,-1724
80008c9e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ca2:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ca6:	c1 68       	rjmp	80008cd2 <_vfprintf_r+0xcf6>
80008ca8:	41 09       	lddsp	r9,sp[0x40]
80008caa:	59 f8       	cp.w	r8,31
80008cac:	e0 89 00 10 	brgt	80008ccc <_vfprintf_r+0xcf0>
80008cb0:	f2 ca ff fc 	sub	r10,r9,-4
80008cb4:	51 0a       	stdsp	sp[0x40],r10
80008cb6:	fa c6 f9 44 	sub	r6,sp,-1724
80008cba:	72 0a       	ld.w	r10,r9[0x0]
80008cbc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cc0:	f3 4a fd 88 	st.w	r9[-632],r10
80008cc4:	2f f8       	sub	r8,-1
80008cc6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cca:	c0 48       	rjmp	80008cd2 <_vfprintf_r+0xcf6>
80008ccc:	72 0a       	ld.w	r10,r9[0x0]
80008cce:	2f c9       	sub	r9,-4
80008cd0:	51 09       	stdsp	sp[0x40],r9
80008cd2:	40 be       	lddsp	lr,sp[0x2c]
80008cd4:	95 0e       	st.w	r10[0x0],lr
80008cd6:	fe 9f fa 11 	bral	800080f8 <_vfprintf_r+0x11c>
80008cda:	50 a7       	stdsp	sp[0x28],r7
80008cdc:	50 80       	stdsp	sp[0x20],r0
80008cde:	0c 97       	mov	r7,r6
80008ce0:	04 94       	mov	r4,r2
80008ce2:	06 96       	mov	r6,r3
80008ce4:	02 92       	mov	r2,r1
80008ce6:	40 93       	lddsp	r3,sp[0x24]
80008ce8:	10 90       	mov	r0,r8
80008cea:	40 41       	lddsp	r1,sp[0x10]
80008cec:	a5 a5       	sbr	r5,0x4
80008cee:	c0 a8       	rjmp	80008d02 <_vfprintf_r+0xd26>
80008cf0:	50 a7       	stdsp	sp[0x28],r7
80008cf2:	50 80       	stdsp	sp[0x20],r0
80008cf4:	0c 97       	mov	r7,r6
80008cf6:	04 94       	mov	r4,r2
80008cf8:	06 96       	mov	r6,r3
80008cfa:	02 92       	mov	r2,r1
80008cfc:	40 93       	lddsp	r3,sp[0x24]
80008cfe:	10 90       	mov	r0,r8
80008d00:	40 41       	lddsp	r1,sp[0x10]
80008d02:	ed b5 00 05 	bld	r5,0x5
80008d06:	c5 d1       	brne	80008dc0 <_vfprintf_r+0xde4>
80008d08:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d0c:	40 3c       	lddsp	r12,sp[0xc]
80008d0e:	58 0c       	cp.w	r12,0
80008d10:	c2 60       	breq	80008d5c <_vfprintf_r+0xd80>
80008d12:	10 36       	cp.w	r6,r8
80008d14:	c0 a4       	brge	80008d28 <_vfprintf_r+0xd4c>
80008d16:	fa cb f9 44 	sub	r11,sp,-1724
80008d1a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d1e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008d22:	fa e9 00 00 	st.d	sp[0],r8
80008d26:	c1 88       	rjmp	80008d56 <_vfprintf_r+0xd7a>
80008d28:	fa c8 f9 50 	sub	r8,sp,-1712
80008d2c:	1a d8       	st.w	--sp,r8
80008d2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d32:	04 9a       	mov	r10,r2
80008d34:	1a d8       	st.w	--sp,r8
80008d36:	0c 9b       	mov	r11,r6
80008d38:	fa c8 fb b4 	sub	r8,sp,-1100
80008d3c:	08 9c       	mov	r12,r4
80008d3e:	1a d8       	st.w	--sp,r8
80008d40:	fa c8 f9 40 	sub	r8,sp,-1728
80008d44:	fa c9 ff b4 	sub	r9,sp,-76
80008d48:	fe b0 f7 b2 	rcall	80007cac <get_arg>
80008d4c:	2f dd       	sub	sp,-12
80008d4e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008d52:	fa eb 00 00 	st.d	sp[0],r10
80008d56:	30 08       	mov	r8,0
80008d58:	e0 8f 03 de 	bral	80009514 <_vfprintf_r+0x1538>
80008d5c:	ee ca ff ff 	sub	r10,r7,-1
80008d60:	10 37       	cp.w	r7,r8
80008d62:	c0 b4       	brge	80008d78 <_vfprintf_r+0xd9c>
80008d64:	fa c9 f9 44 	sub	r9,sp,-1724
80008d68:	14 97       	mov	r7,r10
80008d6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d6e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008d72:	fa eb 00 00 	st.d	sp[0],r10
80008d76:	c1 88       	rjmp	80008da6 <_vfprintf_r+0xdca>
80008d78:	41 09       	lddsp	r9,sp[0x40]
80008d7a:	59 f8       	cp.w	r8,31
80008d7c:	e0 89 00 18 	brgt	80008dac <_vfprintf_r+0xdd0>
80008d80:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d84:	f2 cb ff f8 	sub	r11,r9,-8
80008d88:	fa e7 00 00 	st.d	sp[0],r6
80008d8c:	51 0b       	stdsp	sp[0x40],r11
80008d8e:	fa c6 f9 44 	sub	r6,sp,-1724
80008d92:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d96:	fa e6 00 00 	ld.d	r6,sp[0]
80008d9a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008d9e:	2f f8       	sub	r8,-1
80008da0:	14 97       	mov	r7,r10
80008da2:	fb 48 06 b4 	st.w	sp[1716],r8
80008da6:	40 38       	lddsp	r8,sp[0xc]
80008da8:	e0 8f 03 b6 	bral	80009514 <_vfprintf_r+0x1538>
80008dac:	f2 e6 00 00 	ld.d	r6,r9[0]
80008db0:	40 38       	lddsp	r8,sp[0xc]
80008db2:	fa e7 00 00 	st.d	sp[0],r6
80008db6:	2f 89       	sub	r9,-8
80008db8:	14 97       	mov	r7,r10
80008dba:	51 09       	stdsp	sp[0x40],r9
80008dbc:	e0 8f 03 ac 	bral	80009514 <_vfprintf_r+0x1538>
80008dc0:	ed b5 00 04 	bld	r5,0x4
80008dc4:	c1 61       	brne	80008df0 <_vfprintf_r+0xe14>
80008dc6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dca:	40 3e       	lddsp	lr,sp[0xc]
80008dcc:	58 0e       	cp.w	lr,0
80008dce:	c0 80       	breq	80008dde <_vfprintf_r+0xe02>
80008dd0:	10 36       	cp.w	r6,r8
80008dd2:	c6 74       	brge	80008ea0 <_vfprintf_r+0xec4>
80008dd4:	fa cc f9 44 	sub	r12,sp,-1724
80008dd8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ddc:	c8 08       	rjmp	80008edc <_vfprintf_r+0xf00>
80008dde:	ee ca ff ff 	sub	r10,r7,-1
80008de2:	10 37       	cp.w	r7,r8
80008de4:	c7 f4       	brge	80008ee2 <_vfprintf_r+0xf06>
80008de6:	fa cb f9 44 	sub	r11,sp,-1724
80008dea:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dee:	c7 68       	rjmp	80008eda <_vfprintf_r+0xefe>
80008df0:	ed b5 00 06 	bld	r5,0x6
80008df4:	c4 a1       	brne	80008e88 <_vfprintf_r+0xeac>
80008df6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dfa:	40 3c       	lddsp	r12,sp[0xc]
80008dfc:	58 0c       	cp.w	r12,0
80008dfe:	c1 d0       	breq	80008e38 <_vfprintf_r+0xe5c>
80008e00:	10 36       	cp.w	r6,r8
80008e02:	c0 64       	brge	80008e0e <_vfprintf_r+0xe32>
80008e04:	fa cb f9 44 	sub	r11,sp,-1724
80008e08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e0c:	c1 f8       	rjmp	80008e4a <_vfprintf_r+0xe6e>
80008e0e:	fa c8 f9 50 	sub	r8,sp,-1712
80008e12:	1a d8       	st.w	--sp,r8
80008e14:	fa c8 fa b8 	sub	r8,sp,-1352
80008e18:	1a d8       	st.w	--sp,r8
80008e1a:	fa c8 fb b4 	sub	r8,sp,-1100
80008e1e:	1a d8       	st.w	--sp,r8
80008e20:	fa c8 f9 40 	sub	r8,sp,-1728
80008e24:	fa c9 ff b4 	sub	r9,sp,-76
80008e28:	04 9a       	mov	r10,r2
80008e2a:	0c 9b       	mov	r11,r6
80008e2c:	08 9c       	mov	r12,r4
80008e2e:	fe b0 f7 3f 	rcall	80007cac <get_arg>
80008e32:	2f dd       	sub	sp,-12
80008e34:	98 18       	ld.sh	r8,r12[0x2]
80008e36:	c2 68       	rjmp	80008e82 <_vfprintf_r+0xea6>
80008e38:	ee ca ff ff 	sub	r10,r7,-1
80008e3c:	10 37       	cp.w	r7,r8
80008e3e:	c0 94       	brge	80008e50 <_vfprintf_r+0xe74>
80008e40:	fa c9 f9 44 	sub	r9,sp,-1724
80008e44:	14 97       	mov	r7,r10
80008e46:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e4a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008e4e:	c1 a8       	rjmp	80008e82 <_vfprintf_r+0xea6>
80008e50:	41 09       	lddsp	r9,sp[0x40]
80008e52:	59 f8       	cp.w	r8,31
80008e54:	e0 89 00 13 	brgt	80008e7a <_vfprintf_r+0xe9e>
80008e58:	f2 cb ff fc 	sub	r11,r9,-4
80008e5c:	51 0b       	stdsp	sp[0x40],r11
80008e5e:	72 09       	ld.w	r9,r9[0x0]
80008e60:	fa c6 f9 44 	sub	r6,sp,-1724
80008e64:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008e68:	2f f8       	sub	r8,-1
80008e6a:	f7 49 fd 88 	st.w	r11[-632],r9
80008e6e:	fb 48 06 b4 	st.w	sp[1716],r8
80008e72:	14 97       	mov	r7,r10
80008e74:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e78:	c0 58       	rjmp	80008e82 <_vfprintf_r+0xea6>
80008e7a:	92 18       	ld.sh	r8,r9[0x2]
80008e7c:	14 97       	mov	r7,r10
80008e7e:	2f c9       	sub	r9,-4
80008e80:	51 09       	stdsp	sp[0x40],r9
80008e82:	5c 78       	castu.h	r8
80008e84:	50 18       	stdsp	sp[0x4],r8
80008e86:	c4 68       	rjmp	80008f12 <_vfprintf_r+0xf36>
80008e88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e8c:	40 3c       	lddsp	r12,sp[0xc]
80008e8e:	58 0c       	cp.w	r12,0
80008e90:	c1 d0       	breq	80008eca <_vfprintf_r+0xeee>
80008e92:	10 36       	cp.w	r6,r8
80008e94:	c0 64       	brge	80008ea0 <_vfprintf_r+0xec4>
80008e96:	fa cb f9 44 	sub	r11,sp,-1724
80008e9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e9e:	c1 f8       	rjmp	80008edc <_vfprintf_r+0xf00>
80008ea0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ea4:	1a d8       	st.w	--sp,r8
80008ea6:	fa c8 fa b8 	sub	r8,sp,-1352
80008eaa:	0c 9b       	mov	r11,r6
80008eac:	1a d8       	st.w	--sp,r8
80008eae:	fa c8 fb b4 	sub	r8,sp,-1100
80008eb2:	04 9a       	mov	r10,r2
80008eb4:	1a d8       	st.w	--sp,r8
80008eb6:	08 9c       	mov	r12,r4
80008eb8:	fa c8 f9 40 	sub	r8,sp,-1728
80008ebc:	fa c9 ff b4 	sub	r9,sp,-76
80008ec0:	fe b0 f6 f6 	rcall	80007cac <get_arg>
80008ec4:	2f dd       	sub	sp,-12
80008ec6:	78 0b       	ld.w	r11,r12[0x0]
80008ec8:	c2 48       	rjmp	80008f10 <_vfprintf_r+0xf34>
80008eca:	ee ca ff ff 	sub	r10,r7,-1
80008ece:	10 37       	cp.w	r7,r8
80008ed0:	c0 94       	brge	80008ee2 <_vfprintf_r+0xf06>
80008ed2:	fa c9 f9 44 	sub	r9,sp,-1724
80008ed6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eda:	14 97       	mov	r7,r10
80008edc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ee0:	c1 88       	rjmp	80008f10 <_vfprintf_r+0xf34>
80008ee2:	41 09       	lddsp	r9,sp[0x40]
80008ee4:	59 f8       	cp.w	r8,31
80008ee6:	e0 89 00 11 	brgt	80008f08 <_vfprintf_r+0xf2c>
80008eea:	f2 cb ff fc 	sub	r11,r9,-4
80008eee:	51 0b       	stdsp	sp[0x40],r11
80008ef0:	fa c6 f9 44 	sub	r6,sp,-1724
80008ef4:	72 0b       	ld.w	r11,r9[0x0]
80008ef6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008efa:	f3 4b fd 88 	st.w	r9[-632],r11
80008efe:	2f f8       	sub	r8,-1
80008f00:	14 97       	mov	r7,r10
80008f02:	fb 48 06 b4 	st.w	sp[1716],r8
80008f06:	c0 58       	rjmp	80008f10 <_vfprintf_r+0xf34>
80008f08:	72 0b       	ld.w	r11,r9[0x0]
80008f0a:	14 97       	mov	r7,r10
80008f0c:	2f c9       	sub	r9,-4
80008f0e:	51 09       	stdsp	sp[0x40],r9
80008f10:	50 1b       	stdsp	sp[0x4],r11
80008f12:	30 0e       	mov	lr,0
80008f14:	50 0e       	stdsp	sp[0x0],lr
80008f16:	1c 98       	mov	r8,lr
80008f18:	e0 8f 02 fe 	bral	80009514 <_vfprintf_r+0x1538>
80008f1c:	50 a7       	stdsp	sp[0x28],r7
80008f1e:	50 80       	stdsp	sp[0x20],r0
80008f20:	0c 97       	mov	r7,r6
80008f22:	04 94       	mov	r4,r2
80008f24:	06 96       	mov	r6,r3
80008f26:	02 92       	mov	r2,r1
80008f28:	40 93       	lddsp	r3,sp[0x24]
80008f2a:	40 41       	lddsp	r1,sp[0x10]
80008f2c:	0e 99       	mov	r9,r7
80008f2e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f32:	40 3c       	lddsp	r12,sp[0xc]
80008f34:	58 0c       	cp.w	r12,0
80008f36:	c1 d0       	breq	80008f70 <_vfprintf_r+0xf94>
80008f38:	10 36       	cp.w	r6,r8
80008f3a:	c0 64       	brge	80008f46 <_vfprintf_r+0xf6a>
80008f3c:	fa cb f9 44 	sub	r11,sp,-1724
80008f40:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f44:	c1 d8       	rjmp	80008f7e <_vfprintf_r+0xfa2>
80008f46:	fa c8 f9 50 	sub	r8,sp,-1712
80008f4a:	1a d8       	st.w	--sp,r8
80008f4c:	fa c8 fa b8 	sub	r8,sp,-1352
80008f50:	1a d8       	st.w	--sp,r8
80008f52:	fa c8 fb b4 	sub	r8,sp,-1100
80008f56:	1a d8       	st.w	--sp,r8
80008f58:	fa c9 ff b4 	sub	r9,sp,-76
80008f5c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f60:	04 9a       	mov	r10,r2
80008f62:	0c 9b       	mov	r11,r6
80008f64:	08 9c       	mov	r12,r4
80008f66:	fe b0 f6 a3 	rcall	80007cac <get_arg>
80008f6a:	2f dd       	sub	sp,-12
80008f6c:	78 09       	ld.w	r9,r12[0x0]
80008f6e:	c2 18       	rjmp	80008fb0 <_vfprintf_r+0xfd4>
80008f70:	2f f7       	sub	r7,-1
80008f72:	10 39       	cp.w	r9,r8
80008f74:	c0 84       	brge	80008f84 <_vfprintf_r+0xfa8>
80008f76:	fa ca f9 44 	sub	r10,sp,-1724
80008f7a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f7e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008f82:	c1 78       	rjmp	80008fb0 <_vfprintf_r+0xfd4>
80008f84:	41 09       	lddsp	r9,sp[0x40]
80008f86:	59 f8       	cp.w	r8,31
80008f88:	e0 89 00 10 	brgt	80008fa8 <_vfprintf_r+0xfcc>
80008f8c:	f2 ca ff fc 	sub	r10,r9,-4
80008f90:	51 0a       	stdsp	sp[0x40],r10
80008f92:	fa c6 f9 44 	sub	r6,sp,-1724
80008f96:	72 09       	ld.w	r9,r9[0x0]
80008f98:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008f9c:	f5 49 fd 88 	st.w	r10[-632],r9
80008fa0:	2f f8       	sub	r8,-1
80008fa2:	fb 48 06 b4 	st.w	sp[1716],r8
80008fa6:	c0 58       	rjmp	80008fb0 <_vfprintf_r+0xfd4>
80008fa8:	f2 c8 ff fc 	sub	r8,r9,-4
80008fac:	51 08       	stdsp	sp[0x40],r8
80008fae:	72 09       	ld.w	r9,r9[0x0]
80008fb0:	33 08       	mov	r8,48
80008fb2:	fb 68 06 b8 	st.b	sp[1720],r8
80008fb6:	37 88       	mov	r8,120
80008fb8:	30 0e       	mov	lr,0
80008fba:	fb 68 06 b9 	st.b	sp[1721],r8
80008fbe:	fe cc ac f6 	sub	r12,pc,-21258
80008fc2:	50 19       	stdsp	sp[0x4],r9
80008fc4:	a1 b5       	sbr	r5,0x1
80008fc6:	50 0e       	stdsp	sp[0x0],lr
80008fc8:	50 dc       	stdsp	sp[0x34],r12
80008fca:	30 28       	mov	r8,2
80008fcc:	37 80       	mov	r0,120
80008fce:	e0 8f 02 a3 	bral	80009514 <_vfprintf_r+0x1538>
80008fd2:	50 a7       	stdsp	sp[0x28],r7
80008fd4:	50 80       	stdsp	sp[0x20],r0
80008fd6:	10 90       	mov	r0,r8
80008fd8:	30 08       	mov	r8,0
80008fda:	fb 68 06 bb 	st.b	sp[1723],r8
80008fde:	0c 97       	mov	r7,r6
80008fe0:	04 94       	mov	r4,r2
80008fe2:	06 96       	mov	r6,r3
80008fe4:	02 92       	mov	r2,r1
80008fe6:	40 93       	lddsp	r3,sp[0x24]
80008fe8:	40 41       	lddsp	r1,sp[0x10]
80008fea:	0e 99       	mov	r9,r7
80008fec:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ff0:	40 3b       	lddsp	r11,sp[0xc]
80008ff2:	58 0b       	cp.w	r11,0
80008ff4:	c1 d0       	breq	8000902e <_vfprintf_r+0x1052>
80008ff6:	10 36       	cp.w	r6,r8
80008ff8:	c0 64       	brge	80009004 <_vfprintf_r+0x1028>
80008ffa:	fa ca f9 44 	sub	r10,sp,-1724
80008ffe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009002:	c1 d8       	rjmp	8000903c <_vfprintf_r+0x1060>
80009004:	fa c8 f9 50 	sub	r8,sp,-1712
80009008:	1a d8       	st.w	--sp,r8
8000900a:	fa c8 fa b8 	sub	r8,sp,-1352
8000900e:	1a d8       	st.w	--sp,r8
80009010:	fa c8 fb b4 	sub	r8,sp,-1100
80009014:	0c 9b       	mov	r11,r6
80009016:	1a d8       	st.w	--sp,r8
80009018:	04 9a       	mov	r10,r2
8000901a:	fa c8 f9 40 	sub	r8,sp,-1728
8000901e:	fa c9 ff b4 	sub	r9,sp,-76
80009022:	08 9c       	mov	r12,r4
80009024:	fe b0 f6 44 	rcall	80007cac <get_arg>
80009028:	2f dd       	sub	sp,-12
8000902a:	78 06       	ld.w	r6,r12[0x0]
8000902c:	c2 08       	rjmp	8000906c <_vfprintf_r+0x1090>
8000902e:	2f f7       	sub	r7,-1
80009030:	10 39       	cp.w	r9,r8
80009032:	c0 84       	brge	80009042 <_vfprintf_r+0x1066>
80009034:	fa c9 f9 44 	sub	r9,sp,-1724
80009038:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000903c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009040:	c1 68       	rjmp	8000906c <_vfprintf_r+0x1090>
80009042:	41 09       	lddsp	r9,sp[0x40]
80009044:	59 f8       	cp.w	r8,31
80009046:	e0 89 00 10 	brgt	80009066 <_vfprintf_r+0x108a>
8000904a:	f2 ca ff fc 	sub	r10,r9,-4
8000904e:	51 0a       	stdsp	sp[0x40],r10
80009050:	72 06       	ld.w	r6,r9[0x0]
80009052:	fa ce f9 44 	sub	lr,sp,-1724
80009056:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000905a:	f3 46 fd 88 	st.w	r9[-632],r6
8000905e:	2f f8       	sub	r8,-1
80009060:	fb 48 06 b4 	st.w	sp[1716],r8
80009064:	c0 48       	rjmp	8000906c <_vfprintf_r+0x1090>
80009066:	72 06       	ld.w	r6,r9[0x0]
80009068:	2f c9       	sub	r9,-4
8000906a:	51 09       	stdsp	sp[0x40],r9
8000906c:	40 2c       	lddsp	r12,sp[0x8]
8000906e:	58 0c       	cp.w	r12,0
80009070:	c1 05       	brlt	80009090 <_vfprintf_r+0x10b4>
80009072:	18 9a       	mov	r10,r12
80009074:	30 0b       	mov	r11,0
80009076:	0c 9c       	mov	r12,r6
80009078:	e0 a0 12 38 	rcall	8000b4e8 <memchr>
8000907c:	e0 80 02 df 	breq	8000963a <_vfprintf_r+0x165e>
80009080:	f8 06 01 02 	sub	r2,r12,r6
80009084:	40 2b       	lddsp	r11,sp[0x8]
80009086:	16 32       	cp.w	r2,r11
80009088:	e0 89 02 d9 	brgt	8000963a <_vfprintf_r+0x165e>
8000908c:	e0 8f 02 d4 	bral	80009634 <_vfprintf_r+0x1658>
80009090:	30 0a       	mov	r10,0
80009092:	0c 9c       	mov	r12,r6
80009094:	50 2a       	stdsp	sp[0x8],r10
80009096:	fe b0 f5 85 	rcall	80007ba0 <strlen>
8000909a:	18 92       	mov	r2,r12
8000909c:	e0 8f 02 d2 	bral	80009640 <_vfprintf_r+0x1664>
800090a0:	50 a7       	stdsp	sp[0x28],r7
800090a2:	50 80       	stdsp	sp[0x20],r0
800090a4:	0c 97       	mov	r7,r6
800090a6:	04 94       	mov	r4,r2
800090a8:	06 96       	mov	r6,r3
800090aa:	02 92       	mov	r2,r1
800090ac:	40 93       	lddsp	r3,sp[0x24]
800090ae:	10 90       	mov	r0,r8
800090b0:	40 41       	lddsp	r1,sp[0x10]
800090b2:	a5 a5       	sbr	r5,0x4
800090b4:	c0 a8       	rjmp	800090c8 <_vfprintf_r+0x10ec>
800090b6:	50 a7       	stdsp	sp[0x28],r7
800090b8:	50 80       	stdsp	sp[0x20],r0
800090ba:	0c 97       	mov	r7,r6
800090bc:	04 94       	mov	r4,r2
800090be:	06 96       	mov	r6,r3
800090c0:	02 92       	mov	r2,r1
800090c2:	40 93       	lddsp	r3,sp[0x24]
800090c4:	10 90       	mov	r0,r8
800090c6:	40 41       	lddsp	r1,sp[0x10]
800090c8:	ed b5 00 05 	bld	r5,0x5
800090cc:	c5 61       	brne	80009178 <_vfprintf_r+0x119c>
800090ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090d2:	40 39       	lddsp	r9,sp[0xc]
800090d4:	58 09       	cp.w	r9,0
800090d6:	c2 10       	breq	80009118 <_vfprintf_r+0x113c>
800090d8:	10 36       	cp.w	r6,r8
800090da:	c0 74       	brge	800090e8 <_vfprintf_r+0x110c>
800090dc:	fa c8 f9 44 	sub	r8,sp,-1724
800090e0:	f0 06 00 36 	add	r6,r8,r6<<0x3
800090e4:	c2 38       	rjmp	8000912a <_vfprintf_r+0x114e>
800090e6:	d7 03       	nop
800090e8:	fa c8 f9 50 	sub	r8,sp,-1712
800090ec:	1a d8       	st.w	--sp,r8
800090ee:	fa c8 fa b8 	sub	r8,sp,-1352
800090f2:	1a d8       	st.w	--sp,r8
800090f4:	fa c8 fb b4 	sub	r8,sp,-1100
800090f8:	1a d8       	st.w	--sp,r8
800090fa:	fa c8 f9 40 	sub	r8,sp,-1728
800090fe:	fa c9 ff b4 	sub	r9,sp,-76
80009102:	04 9a       	mov	r10,r2
80009104:	0c 9b       	mov	r11,r6
80009106:	08 9c       	mov	r12,r4
80009108:	fe b0 f5 d2 	rcall	80007cac <get_arg>
8000910c:	2f dd       	sub	sp,-12
8000910e:	f8 e8 00 00 	ld.d	r8,r12[0]
80009112:	fa e9 00 00 	st.d	sp[0],r8
80009116:	c2 e8       	rjmp	80009172 <_vfprintf_r+0x1196>
80009118:	ee ca ff ff 	sub	r10,r7,-1
8000911c:	10 37       	cp.w	r7,r8
8000911e:	c0 b4       	brge	80009134 <_vfprintf_r+0x1158>
80009120:	fa c8 f9 44 	sub	r8,sp,-1724
80009124:	14 97       	mov	r7,r10
80009126:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000912a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000912e:	fa eb 00 00 	st.d	sp[0],r10
80009132:	c2 08       	rjmp	80009172 <_vfprintf_r+0x1196>
80009134:	41 09       	lddsp	r9,sp[0x40]
80009136:	59 f8       	cp.w	r8,31
80009138:	e0 89 00 16 	brgt	80009164 <_vfprintf_r+0x1188>
8000913c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009140:	f2 cb ff f8 	sub	r11,r9,-8
80009144:	fa e7 00 00 	st.d	sp[0],r6
80009148:	51 0b       	stdsp	sp[0x40],r11
8000914a:	fa c6 f9 44 	sub	r6,sp,-1724
8000914e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009152:	fa e6 00 00 	ld.d	r6,sp[0]
80009156:	f2 e7 fd 88 	st.d	r9[-632],r6
8000915a:	2f f8       	sub	r8,-1
8000915c:	14 97       	mov	r7,r10
8000915e:	fb 48 06 b4 	st.w	sp[1716],r8
80009162:	c0 88       	rjmp	80009172 <_vfprintf_r+0x1196>
80009164:	f2 e6 00 00 	ld.d	r6,r9[0]
80009168:	2f 89       	sub	r9,-8
8000916a:	fa e7 00 00 	st.d	sp[0],r6
8000916e:	51 09       	stdsp	sp[0x40],r9
80009170:	14 97       	mov	r7,r10
80009172:	30 18       	mov	r8,1
80009174:	e0 8f 01 d0 	bral	80009514 <_vfprintf_r+0x1538>
80009178:	ed b5 00 04 	bld	r5,0x4
8000917c:	c1 61       	brne	800091a8 <_vfprintf_r+0x11cc>
8000917e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009182:	40 3e       	lddsp	lr,sp[0xc]
80009184:	58 0e       	cp.w	lr,0
80009186:	c0 80       	breq	80009196 <_vfprintf_r+0x11ba>
80009188:	10 36       	cp.w	r6,r8
8000918a:	c6 74       	brge	80009258 <_vfprintf_r+0x127c>
8000918c:	fa cc f9 44 	sub	r12,sp,-1724
80009190:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009194:	c8 08       	rjmp	80009294 <_vfprintf_r+0x12b8>
80009196:	ee ca ff ff 	sub	r10,r7,-1
8000919a:	10 37       	cp.w	r7,r8
8000919c:	c7 f4       	brge	8000929a <_vfprintf_r+0x12be>
8000919e:	fa cb f9 44 	sub	r11,sp,-1724
800091a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091a6:	c7 68       	rjmp	80009292 <_vfprintf_r+0x12b6>
800091a8:	ed b5 00 06 	bld	r5,0x6
800091ac:	c4 a1       	brne	80009240 <_vfprintf_r+0x1264>
800091ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091b2:	40 3c       	lddsp	r12,sp[0xc]
800091b4:	58 0c       	cp.w	r12,0
800091b6:	c1 d0       	breq	800091f0 <_vfprintf_r+0x1214>
800091b8:	10 36       	cp.w	r6,r8
800091ba:	c0 64       	brge	800091c6 <_vfprintf_r+0x11ea>
800091bc:	fa cb f9 44 	sub	r11,sp,-1724
800091c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091c4:	c1 f8       	rjmp	80009202 <_vfprintf_r+0x1226>
800091c6:	fa c8 f9 50 	sub	r8,sp,-1712
800091ca:	1a d8       	st.w	--sp,r8
800091cc:	fa c8 fa b8 	sub	r8,sp,-1352
800091d0:	1a d8       	st.w	--sp,r8
800091d2:	fa c8 fb b4 	sub	r8,sp,-1100
800091d6:	1a d8       	st.w	--sp,r8
800091d8:	fa c8 f9 40 	sub	r8,sp,-1728
800091dc:	fa c9 ff b4 	sub	r9,sp,-76
800091e0:	04 9a       	mov	r10,r2
800091e2:	0c 9b       	mov	r11,r6
800091e4:	08 9c       	mov	r12,r4
800091e6:	fe b0 f5 63 	rcall	80007cac <get_arg>
800091ea:	2f dd       	sub	sp,-12
800091ec:	98 18       	ld.sh	r8,r12[0x2]
800091ee:	c2 68       	rjmp	8000923a <_vfprintf_r+0x125e>
800091f0:	ee ca ff ff 	sub	r10,r7,-1
800091f4:	10 37       	cp.w	r7,r8
800091f6:	c0 94       	brge	80009208 <_vfprintf_r+0x122c>
800091f8:	fa c9 f9 44 	sub	r9,sp,-1724
800091fc:	14 97       	mov	r7,r10
800091fe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009202:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009206:	c1 a8       	rjmp	8000923a <_vfprintf_r+0x125e>
80009208:	41 09       	lddsp	r9,sp[0x40]
8000920a:	59 f8       	cp.w	r8,31
8000920c:	e0 89 00 13 	brgt	80009232 <_vfprintf_r+0x1256>
80009210:	f2 cb ff fc 	sub	r11,r9,-4
80009214:	51 0b       	stdsp	sp[0x40],r11
80009216:	72 09       	ld.w	r9,r9[0x0]
80009218:	fa c6 f9 44 	sub	r6,sp,-1724
8000921c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009220:	2f f8       	sub	r8,-1
80009222:	f7 49 fd 88 	st.w	r11[-632],r9
80009226:	fb 48 06 b4 	st.w	sp[1716],r8
8000922a:	14 97       	mov	r7,r10
8000922c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009230:	c0 58       	rjmp	8000923a <_vfprintf_r+0x125e>
80009232:	92 18       	ld.sh	r8,r9[0x2]
80009234:	14 97       	mov	r7,r10
80009236:	2f c9       	sub	r9,-4
80009238:	51 09       	stdsp	sp[0x40],r9
8000923a:	5c 78       	castu.h	r8
8000923c:	50 18       	stdsp	sp[0x4],r8
8000923e:	c4 68       	rjmp	800092ca <_vfprintf_r+0x12ee>
80009240:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009244:	40 3c       	lddsp	r12,sp[0xc]
80009246:	58 0c       	cp.w	r12,0
80009248:	c1 d0       	breq	80009282 <_vfprintf_r+0x12a6>
8000924a:	10 36       	cp.w	r6,r8
8000924c:	c0 64       	brge	80009258 <_vfprintf_r+0x127c>
8000924e:	fa cb f9 44 	sub	r11,sp,-1724
80009252:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009256:	c1 f8       	rjmp	80009294 <_vfprintf_r+0x12b8>
80009258:	fa c8 f9 50 	sub	r8,sp,-1712
8000925c:	1a d8       	st.w	--sp,r8
8000925e:	fa c8 fa b8 	sub	r8,sp,-1352
80009262:	0c 9b       	mov	r11,r6
80009264:	1a d8       	st.w	--sp,r8
80009266:	fa c8 fb b4 	sub	r8,sp,-1100
8000926a:	04 9a       	mov	r10,r2
8000926c:	1a d8       	st.w	--sp,r8
8000926e:	08 9c       	mov	r12,r4
80009270:	fa c8 f9 40 	sub	r8,sp,-1728
80009274:	fa c9 ff b4 	sub	r9,sp,-76
80009278:	fe b0 f5 1a 	rcall	80007cac <get_arg>
8000927c:	2f dd       	sub	sp,-12
8000927e:	78 0b       	ld.w	r11,r12[0x0]
80009280:	c2 48       	rjmp	800092c8 <_vfprintf_r+0x12ec>
80009282:	ee ca ff ff 	sub	r10,r7,-1
80009286:	10 37       	cp.w	r7,r8
80009288:	c0 94       	brge	8000929a <_vfprintf_r+0x12be>
8000928a:	fa c9 f9 44 	sub	r9,sp,-1724
8000928e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009292:	14 97       	mov	r7,r10
80009294:	ec fb fd 88 	ld.w	r11,r6[-632]
80009298:	c1 88       	rjmp	800092c8 <_vfprintf_r+0x12ec>
8000929a:	41 09       	lddsp	r9,sp[0x40]
8000929c:	59 f8       	cp.w	r8,31
8000929e:	e0 89 00 11 	brgt	800092c0 <_vfprintf_r+0x12e4>
800092a2:	f2 cb ff fc 	sub	r11,r9,-4
800092a6:	51 0b       	stdsp	sp[0x40],r11
800092a8:	fa c6 f9 44 	sub	r6,sp,-1724
800092ac:	72 0b       	ld.w	r11,r9[0x0]
800092ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092b2:	f3 4b fd 88 	st.w	r9[-632],r11
800092b6:	2f f8       	sub	r8,-1
800092b8:	14 97       	mov	r7,r10
800092ba:	fb 48 06 b4 	st.w	sp[1716],r8
800092be:	c0 58       	rjmp	800092c8 <_vfprintf_r+0x12ec>
800092c0:	72 0b       	ld.w	r11,r9[0x0]
800092c2:	14 97       	mov	r7,r10
800092c4:	2f c9       	sub	r9,-4
800092c6:	51 09       	stdsp	sp[0x40],r9
800092c8:	50 1b       	stdsp	sp[0x4],r11
800092ca:	30 0e       	mov	lr,0
800092cc:	30 18       	mov	r8,1
800092ce:	50 0e       	stdsp	sp[0x0],lr
800092d0:	c2 29       	rjmp	80009514 <_vfprintf_r+0x1538>
800092d2:	50 a7       	stdsp	sp[0x28],r7
800092d4:	50 80       	stdsp	sp[0x20],r0
800092d6:	0c 97       	mov	r7,r6
800092d8:	04 94       	mov	r4,r2
800092da:	06 96       	mov	r6,r3
800092dc:	02 92       	mov	r2,r1
800092de:	fe cc b0 16 	sub	r12,pc,-20458
800092e2:	40 93       	lddsp	r3,sp[0x24]
800092e4:	10 90       	mov	r0,r8
800092e6:	40 41       	lddsp	r1,sp[0x10]
800092e8:	50 dc       	stdsp	sp[0x34],r12
800092ea:	ed b5 00 05 	bld	r5,0x5
800092ee:	c5 51       	brne	80009398 <_vfprintf_r+0x13bc>
800092f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092f4:	40 3b       	lddsp	r11,sp[0xc]
800092f6:	58 0b       	cp.w	r11,0
800092f8:	c2 20       	breq	8000933c <_vfprintf_r+0x1360>
800092fa:	10 36       	cp.w	r6,r8
800092fc:	c0 a4       	brge	80009310 <_vfprintf_r+0x1334>
800092fe:	fa ca f9 44 	sub	r10,sp,-1724
80009302:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009306:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000930a:	fa e9 00 00 	st.d	sp[0],r8
8000930e:	cf 28       	rjmp	800094f2 <_vfprintf_r+0x1516>
80009310:	fa c8 f9 50 	sub	r8,sp,-1712
80009314:	1a d8       	st.w	--sp,r8
80009316:	fa c8 fa b8 	sub	r8,sp,-1352
8000931a:	04 9a       	mov	r10,r2
8000931c:	1a d8       	st.w	--sp,r8
8000931e:	0c 9b       	mov	r11,r6
80009320:	fa c8 fb b4 	sub	r8,sp,-1100
80009324:	08 9c       	mov	r12,r4
80009326:	1a d8       	st.w	--sp,r8
80009328:	fa c8 f9 40 	sub	r8,sp,-1728
8000932c:	fa c9 ff b4 	sub	r9,sp,-76
80009330:	fe b0 f4 be 	rcall	80007cac <get_arg>
80009334:	2f dd       	sub	sp,-12
80009336:	f8 ea 00 00 	ld.d	r10,r12[0]
8000933a:	c0 c8       	rjmp	80009352 <_vfprintf_r+0x1376>
8000933c:	ee ca ff ff 	sub	r10,r7,-1
80009340:	10 37       	cp.w	r7,r8
80009342:	c0 b4       	brge	80009358 <_vfprintf_r+0x137c>
80009344:	fa c9 f9 44 	sub	r9,sp,-1724
80009348:	14 97       	mov	r7,r10
8000934a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000934e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009352:	fa eb 00 00 	st.d	sp[0],r10
80009356:	cc e8       	rjmp	800094f2 <_vfprintf_r+0x1516>
80009358:	41 09       	lddsp	r9,sp[0x40]
8000935a:	59 f8       	cp.w	r8,31
8000935c:	e0 89 00 16 	brgt	80009388 <_vfprintf_r+0x13ac>
80009360:	f2 e6 00 00 	ld.d	r6,r9[0]
80009364:	f2 cb ff f8 	sub	r11,r9,-8
80009368:	fa e7 00 00 	st.d	sp[0],r6
8000936c:	51 0b       	stdsp	sp[0x40],r11
8000936e:	fa c6 f9 44 	sub	r6,sp,-1724
80009372:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009376:	fa e6 00 00 	ld.d	r6,sp[0]
8000937a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000937e:	2f f8       	sub	r8,-1
80009380:	14 97       	mov	r7,r10
80009382:	fb 48 06 b4 	st.w	sp[1716],r8
80009386:	cb 68       	rjmp	800094f2 <_vfprintf_r+0x1516>
80009388:	f2 e6 00 00 	ld.d	r6,r9[0]
8000938c:	2f 89       	sub	r9,-8
8000938e:	fa e7 00 00 	st.d	sp[0],r6
80009392:	51 09       	stdsp	sp[0x40],r9
80009394:	14 97       	mov	r7,r10
80009396:	ca e8       	rjmp	800094f2 <_vfprintf_r+0x1516>
80009398:	ed b5 00 04 	bld	r5,0x4
8000939c:	c1 71       	brne	800093ca <_vfprintf_r+0x13ee>
8000939e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093a2:	40 3e       	lddsp	lr,sp[0xc]
800093a4:	58 0e       	cp.w	lr,0
800093a6:	c0 80       	breq	800093b6 <_vfprintf_r+0x13da>
800093a8:	10 36       	cp.w	r6,r8
800093aa:	c6 94       	brge	8000947c <_vfprintf_r+0x14a0>
800093ac:	fa cc f9 44 	sub	r12,sp,-1724
800093b0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800093b4:	c8 28       	rjmp	800094b8 <_vfprintf_r+0x14dc>
800093b6:	ee ca ff ff 	sub	r10,r7,-1
800093ba:	10 37       	cp.w	r7,r8
800093bc:	e0 84 00 81 	brge	800094be <_vfprintf_r+0x14e2>
800093c0:	fa cb f9 44 	sub	r11,sp,-1724
800093c4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093c8:	c7 78       	rjmp	800094b6 <_vfprintf_r+0x14da>
800093ca:	ed b5 00 06 	bld	r5,0x6
800093ce:	c4 b1       	brne	80009464 <_vfprintf_r+0x1488>
800093d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093d4:	40 3c       	lddsp	r12,sp[0xc]
800093d6:	58 0c       	cp.w	r12,0
800093d8:	c1 d0       	breq	80009412 <_vfprintf_r+0x1436>
800093da:	10 36       	cp.w	r6,r8
800093dc:	c0 64       	brge	800093e8 <_vfprintf_r+0x140c>
800093de:	fa cb f9 44 	sub	r11,sp,-1724
800093e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093e6:	c1 f8       	rjmp	80009424 <_vfprintf_r+0x1448>
800093e8:	fa c8 f9 50 	sub	r8,sp,-1712
800093ec:	1a d8       	st.w	--sp,r8
800093ee:	fa c8 fa b8 	sub	r8,sp,-1352
800093f2:	1a d8       	st.w	--sp,r8
800093f4:	fa c8 fb b4 	sub	r8,sp,-1100
800093f8:	1a d8       	st.w	--sp,r8
800093fa:	fa c8 f9 40 	sub	r8,sp,-1728
800093fe:	fa c9 ff b4 	sub	r9,sp,-76
80009402:	04 9a       	mov	r10,r2
80009404:	0c 9b       	mov	r11,r6
80009406:	08 9c       	mov	r12,r4
80009408:	fe b0 f4 52 	rcall	80007cac <get_arg>
8000940c:	2f dd       	sub	sp,-12
8000940e:	98 18       	ld.sh	r8,r12[0x2]
80009410:	c2 78       	rjmp	8000945e <_vfprintf_r+0x1482>
80009412:	ee ca ff ff 	sub	r10,r7,-1
80009416:	10 37       	cp.w	r7,r8
80009418:	c0 a4       	brge	8000942c <_vfprintf_r+0x1450>
8000941a:	fa c9 f9 44 	sub	r9,sp,-1724
8000941e:	14 97       	mov	r7,r10
80009420:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009424:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009428:	c1 b8       	rjmp	8000945e <_vfprintf_r+0x1482>
8000942a:	d7 03       	nop
8000942c:	41 09       	lddsp	r9,sp[0x40]
8000942e:	59 f8       	cp.w	r8,31
80009430:	e0 89 00 13 	brgt	80009456 <_vfprintf_r+0x147a>
80009434:	f2 cb ff fc 	sub	r11,r9,-4
80009438:	51 0b       	stdsp	sp[0x40],r11
8000943a:	72 09       	ld.w	r9,r9[0x0]
8000943c:	fa c6 f9 44 	sub	r6,sp,-1724
80009440:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009444:	2f f8       	sub	r8,-1
80009446:	f7 49 fd 88 	st.w	r11[-632],r9
8000944a:	fb 48 06 b4 	st.w	sp[1716],r8
8000944e:	14 97       	mov	r7,r10
80009450:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009454:	c0 58       	rjmp	8000945e <_vfprintf_r+0x1482>
80009456:	92 18       	ld.sh	r8,r9[0x2]
80009458:	14 97       	mov	r7,r10
8000945a:	2f c9       	sub	r9,-4
8000945c:	51 09       	stdsp	sp[0x40],r9
8000945e:	5c 78       	castu.h	r8
80009460:	50 18       	stdsp	sp[0x4],r8
80009462:	c4 68       	rjmp	800094ee <_vfprintf_r+0x1512>
80009464:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009468:	40 3c       	lddsp	r12,sp[0xc]
8000946a:	58 0c       	cp.w	r12,0
8000946c:	c1 d0       	breq	800094a6 <_vfprintf_r+0x14ca>
8000946e:	10 36       	cp.w	r6,r8
80009470:	c0 64       	brge	8000947c <_vfprintf_r+0x14a0>
80009472:	fa cb f9 44 	sub	r11,sp,-1724
80009476:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000947a:	c1 f8       	rjmp	800094b8 <_vfprintf_r+0x14dc>
8000947c:	fa c8 f9 50 	sub	r8,sp,-1712
80009480:	1a d8       	st.w	--sp,r8
80009482:	fa c8 fa b8 	sub	r8,sp,-1352
80009486:	0c 9b       	mov	r11,r6
80009488:	1a d8       	st.w	--sp,r8
8000948a:	fa c8 fb b4 	sub	r8,sp,-1100
8000948e:	04 9a       	mov	r10,r2
80009490:	1a d8       	st.w	--sp,r8
80009492:	08 9c       	mov	r12,r4
80009494:	fa c8 f9 40 	sub	r8,sp,-1728
80009498:	fa c9 ff b4 	sub	r9,sp,-76
8000949c:	fe b0 f4 08 	rcall	80007cac <get_arg>
800094a0:	2f dd       	sub	sp,-12
800094a2:	78 0b       	ld.w	r11,r12[0x0]
800094a4:	c2 48       	rjmp	800094ec <_vfprintf_r+0x1510>
800094a6:	ee ca ff ff 	sub	r10,r7,-1
800094aa:	10 37       	cp.w	r7,r8
800094ac:	c0 94       	brge	800094be <_vfprintf_r+0x14e2>
800094ae:	fa c9 f9 44 	sub	r9,sp,-1724
800094b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094b6:	14 97       	mov	r7,r10
800094b8:	ec fb fd 88 	ld.w	r11,r6[-632]
800094bc:	c1 88       	rjmp	800094ec <_vfprintf_r+0x1510>
800094be:	41 09       	lddsp	r9,sp[0x40]
800094c0:	59 f8       	cp.w	r8,31
800094c2:	e0 89 00 11 	brgt	800094e4 <_vfprintf_r+0x1508>
800094c6:	f2 cb ff fc 	sub	r11,r9,-4
800094ca:	51 0b       	stdsp	sp[0x40],r11
800094cc:	fa c6 f9 44 	sub	r6,sp,-1724
800094d0:	72 0b       	ld.w	r11,r9[0x0]
800094d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094d6:	f3 4b fd 88 	st.w	r9[-632],r11
800094da:	2f f8       	sub	r8,-1
800094dc:	14 97       	mov	r7,r10
800094de:	fb 48 06 b4 	st.w	sp[1716],r8
800094e2:	c0 58       	rjmp	800094ec <_vfprintf_r+0x1510>
800094e4:	72 0b       	ld.w	r11,r9[0x0]
800094e6:	14 97       	mov	r7,r10
800094e8:	2f c9       	sub	r9,-4
800094ea:	51 09       	stdsp	sp[0x40],r9
800094ec:	50 1b       	stdsp	sp[0x4],r11
800094ee:	30 0e       	mov	lr,0
800094f0:	50 0e       	stdsp	sp[0x0],lr
800094f2:	40 08       	lddsp	r8,sp[0x0]
800094f4:	40 1c       	lddsp	r12,sp[0x4]
800094f6:	18 48       	or	r8,r12
800094f8:	5f 19       	srne	r9
800094fa:	0a 98       	mov	r8,r5
800094fc:	eb e9 00 09 	and	r9,r5,r9
80009500:	a1 b8       	sbr	r8,0x1
80009502:	58 09       	cp.w	r9,0
80009504:	c0 70       	breq	80009512 <_vfprintf_r+0x1536>
80009506:	10 95       	mov	r5,r8
80009508:	fb 60 06 b9 	st.b	sp[1721],r0
8000950c:	33 08       	mov	r8,48
8000950e:	fb 68 06 b8 	st.b	sp[1720],r8
80009512:	30 28       	mov	r8,2
80009514:	30 09       	mov	r9,0
80009516:	fb 69 06 bb 	st.b	sp[1723],r9
8000951a:	0a 99       	mov	r9,r5
8000951c:	a7 d9       	cbr	r9,0x7
8000951e:	40 2b       	lddsp	r11,sp[0x8]
80009520:	40 16       	lddsp	r6,sp[0x4]
80009522:	58 0b       	cp.w	r11,0
80009524:	5f 1a       	srne	r10
80009526:	f2 05 17 40 	movge	r5,r9
8000952a:	fa c2 f9 78 	sub	r2,sp,-1672
8000952e:	40 09       	lddsp	r9,sp[0x0]
80009530:	0c 49       	or	r9,r6
80009532:	5f 19       	srne	r9
80009534:	f5 e9 10 09 	or	r9,r10,r9
80009538:	c5 c0       	breq	800095f0 <_vfprintf_r+0x1614>
8000953a:	30 19       	mov	r9,1
8000953c:	f2 08 18 00 	cp.b	r8,r9
80009540:	c0 60       	breq	8000954c <_vfprintf_r+0x1570>
80009542:	30 29       	mov	r9,2
80009544:	f2 08 18 00 	cp.b	r8,r9
80009548:	c0 41       	brne	80009550 <_vfprintf_r+0x1574>
8000954a:	c3 c8       	rjmp	800095c2 <_vfprintf_r+0x15e6>
8000954c:	04 96       	mov	r6,r2
8000954e:	c3 08       	rjmp	800095ae <_vfprintf_r+0x15d2>
80009550:	04 96       	mov	r6,r2
80009552:	fa e8 00 00 	ld.d	r8,sp[0]
80009556:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000955a:	2d 0a       	sub	r10,-48
8000955c:	0c fa       	st.b	--r6,r10
8000955e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009562:	f2 0c 16 03 	lsr	r12,r9,0x3
80009566:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000956a:	18 99       	mov	r9,r12
8000956c:	16 98       	mov	r8,r11
8000956e:	58 08       	cp.w	r8,0
80009570:	5c 29       	cpc	r9
80009572:	cf 21       	brne	80009556 <_vfprintf_r+0x157a>
80009574:	fa e9 00 00 	st.d	sp[0],r8
80009578:	ed b5 00 00 	bld	r5,0x0
8000957c:	c4 51       	brne	80009606 <_vfprintf_r+0x162a>
8000957e:	33 09       	mov	r9,48
80009580:	f2 0a 18 00 	cp.b	r10,r9
80009584:	c4 10       	breq	80009606 <_vfprintf_r+0x162a>
80009586:	0c f9       	st.b	--r6,r9
80009588:	c3 f8       	rjmp	80009606 <_vfprintf_r+0x162a>
8000958a:	fa ea 00 00 	ld.d	r10,sp[0]
8000958e:	30 a8       	mov	r8,10
80009590:	30 09       	mov	r9,0
80009592:	e0 a0 1a 0d 	rcall	8000c9ac <__avr32_umod64>
80009596:	30 a8       	mov	r8,10
80009598:	2d 0a       	sub	r10,-48
8000959a:	30 09       	mov	r9,0
8000959c:	ac 8a       	st.b	r6[0x0],r10
8000959e:	fa ea 00 00 	ld.d	r10,sp[0]
800095a2:	e0 a0 18 d3 	rcall	8000c748 <__avr32_udiv64>
800095a6:	16 99       	mov	r9,r11
800095a8:	14 98       	mov	r8,r10
800095aa:	fa e9 00 00 	st.d	sp[0],r8
800095ae:	20 16       	sub	r6,1
800095b0:	fa ea 00 00 	ld.d	r10,sp[0]
800095b4:	58 9a       	cp.w	r10,9
800095b6:	5c 2b       	cpc	r11
800095b8:	fe 9b ff e9 	brhi	8000958a <_vfprintf_r+0x15ae>
800095bc:	1b f8       	ld.ub	r8,sp[0x7]
800095be:	2d 08       	sub	r8,-48
800095c0:	c2 08       	rjmp	80009600 <_vfprintf_r+0x1624>
800095c2:	04 96       	mov	r6,r2
800095c4:	fa e8 00 00 	ld.d	r8,sp[0]
800095c8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800095cc:	40 de       	lddsp	lr,sp[0x34]
800095ce:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800095d2:	0c fa       	st.b	--r6,r10
800095d4:	f2 0b 16 04 	lsr	r11,r9,0x4
800095d8:	f0 0a 16 04 	lsr	r10,r8,0x4
800095dc:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800095e0:	16 99       	mov	r9,r11
800095e2:	14 98       	mov	r8,r10
800095e4:	58 08       	cp.w	r8,0
800095e6:	5c 29       	cpc	r9
800095e8:	cf 01       	brne	800095c8 <_vfprintf_r+0x15ec>
800095ea:	fa e9 00 00 	st.d	sp[0],r8
800095ee:	c0 c8       	rjmp	80009606 <_vfprintf_r+0x162a>
800095f0:	58 08       	cp.w	r8,0
800095f2:	c0 91       	brne	80009604 <_vfprintf_r+0x1628>
800095f4:	ed b5 00 00 	bld	r5,0x0
800095f8:	c0 61       	brne	80009604 <_vfprintf_r+0x1628>
800095fa:	fa c6 f9 79 	sub	r6,sp,-1671
800095fe:	33 08       	mov	r8,48
80009600:	ac 88       	st.b	r6[0x0],r8
80009602:	c0 28       	rjmp	80009606 <_vfprintf_r+0x162a>
80009604:	04 96       	mov	r6,r2
80009606:	0c 12       	sub	r2,r6
80009608:	c1 c8       	rjmp	80009640 <_vfprintf_r+0x1664>
8000960a:	50 a7       	stdsp	sp[0x28],r7
8000960c:	50 80       	stdsp	sp[0x20],r0
8000960e:	40 93       	lddsp	r3,sp[0x24]
80009610:	0c 97       	mov	r7,r6
80009612:	10 90       	mov	r0,r8
80009614:	04 94       	mov	r4,r2
80009616:	40 41       	lddsp	r1,sp[0x10]
80009618:	58 08       	cp.w	r8,0
8000961a:	e0 80 04 4f 	breq	80009eb8 <_vfprintf_r+0x1edc>
8000961e:	fb 68 06 60 	st.b	sp[1632],r8
80009622:	30 0c       	mov	r12,0
80009624:	30 08       	mov	r8,0
80009626:	30 12       	mov	r2,1
80009628:	fb 68 06 bb 	st.b	sp[1723],r8
8000962c:	50 2c       	stdsp	sp[0x8],r12
8000962e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009632:	c0 78       	rjmp	80009640 <_vfprintf_r+0x1664>
80009634:	30 0b       	mov	r11,0
80009636:	50 2b       	stdsp	sp[0x8],r11
80009638:	c0 48       	rjmp	80009640 <_vfprintf_r+0x1664>
8000963a:	40 22       	lddsp	r2,sp[0x8]
8000963c:	30 0a       	mov	r10,0
8000963e:	50 2a       	stdsp	sp[0x8],r10
80009640:	40 29       	lddsp	r9,sp[0x8]
80009642:	e4 09 0c 49 	max	r9,r2,r9
80009646:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000964a:	50 39       	stdsp	sp[0xc],r9
8000964c:	0a 9e       	mov	lr,r5
8000964e:	30 09       	mov	r9,0
80009650:	e2 1e 00 02 	andl	lr,0x2,COH
80009654:	f2 08 18 00 	cp.b	r8,r9
80009658:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000965c:	f7 b8 01 ff 	subne	r8,-1
80009660:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009664:	0a 9b       	mov	r11,r5
80009666:	58 0e       	cp.w	lr,0
80009668:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000966c:	f7 bc 01 fe 	subne	r12,-2
80009670:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009674:	e2 1b 00 84 	andl	r11,0x84,COH
80009678:	50 fe       	stdsp	sp[0x3c],lr
8000967a:	50 9b       	stdsp	sp[0x24],r11
8000967c:	c4 71       	brne	8000970a <_vfprintf_r+0x172e>
8000967e:	40 8a       	lddsp	r10,sp[0x20]
80009680:	40 39       	lddsp	r9,sp[0xc]
80009682:	12 1a       	sub	r10,r9
80009684:	50 4a       	stdsp	sp[0x10],r10
80009686:	58 0a       	cp.w	r10,0
80009688:	e0 89 00 20 	brgt	800096c8 <_vfprintf_r+0x16ec>
8000968c:	c3 f8       	rjmp	8000970a <_vfprintf_r+0x172e>
8000968e:	2f 09       	sub	r9,-16
80009690:	2f f8       	sub	r8,-1
80009692:	fe ce b3 b2 	sub	lr,pc,-19534
80009696:	31 0c       	mov	r12,16
80009698:	fb 49 06 90 	st.w	sp[1680],r9
8000969c:	87 0e       	st.w	r3[0x0],lr
8000969e:	87 1c       	st.w	r3[0x4],r12
800096a0:	fb 48 06 8c 	st.w	sp[1676],r8
800096a4:	58 78       	cp.w	r8,7
800096a6:	e0 89 00 04 	brgt	800096ae <_vfprintf_r+0x16d2>
800096aa:	2f 83       	sub	r3,-8
800096ac:	c0 b8       	rjmp	800096c2 <_vfprintf_r+0x16e6>
800096ae:	fa ca f9 78 	sub	r10,sp,-1672
800096b2:	02 9b       	mov	r11,r1
800096b4:	08 9c       	mov	r12,r4
800096b6:	fe b0 f4 85 	rcall	80007fc0 <__sprint_r>
800096ba:	e0 81 04 10 	brne	80009eda <_vfprintf_r+0x1efe>
800096be:	fa c3 f9 e0 	sub	r3,sp,-1568
800096c2:	40 4b       	lddsp	r11,sp[0x10]
800096c4:	21 0b       	sub	r11,16
800096c6:	50 4b       	stdsp	sp[0x10],r11
800096c8:	fa f9 06 90 	ld.w	r9,sp[1680]
800096cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096d0:	fe ca b3 f0 	sub	r10,pc,-19472
800096d4:	40 4e       	lddsp	lr,sp[0x10]
800096d6:	59 0e       	cp.w	lr,16
800096d8:	fe 99 ff db 	brgt	8000968e <_vfprintf_r+0x16b2>
800096dc:	1c 09       	add	r9,lr
800096de:	2f f8       	sub	r8,-1
800096e0:	87 0a       	st.w	r3[0x0],r10
800096e2:	fb 49 06 90 	st.w	sp[1680],r9
800096e6:	87 1e       	st.w	r3[0x4],lr
800096e8:	fb 48 06 8c 	st.w	sp[1676],r8
800096ec:	58 78       	cp.w	r8,7
800096ee:	e0 89 00 04 	brgt	800096f6 <_vfprintf_r+0x171a>
800096f2:	2f 83       	sub	r3,-8
800096f4:	c0 b8       	rjmp	8000970a <_vfprintf_r+0x172e>
800096f6:	fa ca f9 78 	sub	r10,sp,-1672
800096fa:	02 9b       	mov	r11,r1
800096fc:	08 9c       	mov	r12,r4
800096fe:	fe b0 f4 61 	rcall	80007fc0 <__sprint_r>
80009702:	e0 81 03 ec 	brne	80009eda <_vfprintf_r+0x1efe>
80009706:	fa c3 f9 e0 	sub	r3,sp,-1568
8000970a:	30 09       	mov	r9,0
8000970c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009710:	f2 08 18 00 	cp.b	r8,r9
80009714:	c1 f0       	breq	80009752 <_vfprintf_r+0x1776>
80009716:	fa f8 06 90 	ld.w	r8,sp[1680]
8000971a:	fa c9 f9 45 	sub	r9,sp,-1723
8000971e:	2f f8       	sub	r8,-1
80009720:	87 09       	st.w	r3[0x0],r9
80009722:	fb 48 06 90 	st.w	sp[1680],r8
80009726:	30 19       	mov	r9,1
80009728:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000972c:	87 19       	st.w	r3[0x4],r9
8000972e:	2f f8       	sub	r8,-1
80009730:	fb 48 06 8c 	st.w	sp[1676],r8
80009734:	58 78       	cp.w	r8,7
80009736:	e0 89 00 04 	brgt	8000973e <_vfprintf_r+0x1762>
8000973a:	2f 83       	sub	r3,-8
8000973c:	c0 b8       	rjmp	80009752 <_vfprintf_r+0x1776>
8000973e:	fa ca f9 78 	sub	r10,sp,-1672
80009742:	02 9b       	mov	r11,r1
80009744:	08 9c       	mov	r12,r4
80009746:	fe b0 f4 3d 	rcall	80007fc0 <__sprint_r>
8000974a:	e0 81 03 c8 	brne	80009eda <_vfprintf_r+0x1efe>
8000974e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009752:	40 fc       	lddsp	r12,sp[0x3c]
80009754:	58 0c       	cp.w	r12,0
80009756:	c1 f0       	breq	80009794 <_vfprintf_r+0x17b8>
80009758:	fa f8 06 90 	ld.w	r8,sp[1680]
8000975c:	fa c9 f9 48 	sub	r9,sp,-1720
80009760:	2f e8       	sub	r8,-2
80009762:	87 09       	st.w	r3[0x0],r9
80009764:	fb 48 06 90 	st.w	sp[1680],r8
80009768:	30 29       	mov	r9,2
8000976a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000976e:	87 19       	st.w	r3[0x4],r9
80009770:	2f f8       	sub	r8,-1
80009772:	fb 48 06 8c 	st.w	sp[1676],r8
80009776:	58 78       	cp.w	r8,7
80009778:	e0 89 00 04 	brgt	80009780 <_vfprintf_r+0x17a4>
8000977c:	2f 83       	sub	r3,-8
8000977e:	c0 b8       	rjmp	80009794 <_vfprintf_r+0x17b8>
80009780:	fa ca f9 78 	sub	r10,sp,-1672
80009784:	02 9b       	mov	r11,r1
80009786:	08 9c       	mov	r12,r4
80009788:	fe b0 f4 1c 	rcall	80007fc0 <__sprint_r>
8000978c:	e0 81 03 a7 	brne	80009eda <_vfprintf_r+0x1efe>
80009790:	fa c3 f9 e0 	sub	r3,sp,-1568
80009794:	40 9b       	lddsp	r11,sp[0x24]
80009796:	e0 4b 00 80 	cp.w	r11,128
8000979a:	c4 71       	brne	80009828 <_vfprintf_r+0x184c>
8000979c:	40 8a       	lddsp	r10,sp[0x20]
8000979e:	40 39       	lddsp	r9,sp[0xc]
800097a0:	12 1a       	sub	r10,r9
800097a2:	50 4a       	stdsp	sp[0x10],r10
800097a4:	58 0a       	cp.w	r10,0
800097a6:	e0 89 00 20 	brgt	800097e6 <_vfprintf_r+0x180a>
800097aa:	c3 f8       	rjmp	80009828 <_vfprintf_r+0x184c>
800097ac:	2f 09       	sub	r9,-16
800097ae:	2f f8       	sub	r8,-1
800097b0:	fe ce b4 c0 	sub	lr,pc,-19264
800097b4:	31 0c       	mov	r12,16
800097b6:	fb 49 06 90 	st.w	sp[1680],r9
800097ba:	87 0e       	st.w	r3[0x0],lr
800097bc:	87 1c       	st.w	r3[0x4],r12
800097be:	fb 48 06 8c 	st.w	sp[1676],r8
800097c2:	58 78       	cp.w	r8,7
800097c4:	e0 89 00 04 	brgt	800097cc <_vfprintf_r+0x17f0>
800097c8:	2f 83       	sub	r3,-8
800097ca:	c0 b8       	rjmp	800097e0 <_vfprintf_r+0x1804>
800097cc:	fa ca f9 78 	sub	r10,sp,-1672
800097d0:	02 9b       	mov	r11,r1
800097d2:	08 9c       	mov	r12,r4
800097d4:	fe b0 f3 f6 	rcall	80007fc0 <__sprint_r>
800097d8:	e0 81 03 81 	brne	80009eda <_vfprintf_r+0x1efe>
800097dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e0:	40 4b       	lddsp	r11,sp[0x10]
800097e2:	21 0b       	sub	r11,16
800097e4:	50 4b       	stdsp	sp[0x10],r11
800097e6:	fa f9 06 90 	ld.w	r9,sp[1680]
800097ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097ee:	fe ca b4 fe 	sub	r10,pc,-19202
800097f2:	40 4e       	lddsp	lr,sp[0x10]
800097f4:	59 0e       	cp.w	lr,16
800097f6:	fe 99 ff db 	brgt	800097ac <_vfprintf_r+0x17d0>
800097fa:	1c 09       	add	r9,lr
800097fc:	2f f8       	sub	r8,-1
800097fe:	87 0a       	st.w	r3[0x0],r10
80009800:	fb 49 06 90 	st.w	sp[1680],r9
80009804:	87 1e       	st.w	r3[0x4],lr
80009806:	fb 48 06 8c 	st.w	sp[1676],r8
8000980a:	58 78       	cp.w	r8,7
8000980c:	e0 89 00 04 	brgt	80009814 <_vfprintf_r+0x1838>
80009810:	2f 83       	sub	r3,-8
80009812:	c0 b8       	rjmp	80009828 <_vfprintf_r+0x184c>
80009814:	fa ca f9 78 	sub	r10,sp,-1672
80009818:	02 9b       	mov	r11,r1
8000981a:	08 9c       	mov	r12,r4
8000981c:	fe b0 f3 d2 	rcall	80007fc0 <__sprint_r>
80009820:	e0 81 03 5d 	brne	80009eda <_vfprintf_r+0x1efe>
80009824:	fa c3 f9 e0 	sub	r3,sp,-1568
80009828:	40 2c       	lddsp	r12,sp[0x8]
8000982a:	04 1c       	sub	r12,r2
8000982c:	50 2c       	stdsp	sp[0x8],r12
8000982e:	58 0c       	cp.w	r12,0
80009830:	e0 89 00 20 	brgt	80009870 <_vfprintf_r+0x1894>
80009834:	c3 f8       	rjmp	800098b2 <_vfprintf_r+0x18d6>
80009836:	2f 09       	sub	r9,-16
80009838:	2f f8       	sub	r8,-1
8000983a:	fe cb b5 4a 	sub	r11,pc,-19126
8000983e:	31 0a       	mov	r10,16
80009840:	fb 49 06 90 	st.w	sp[1680],r9
80009844:	87 0b       	st.w	r3[0x0],r11
80009846:	87 1a       	st.w	r3[0x4],r10
80009848:	fb 48 06 8c 	st.w	sp[1676],r8
8000984c:	58 78       	cp.w	r8,7
8000984e:	e0 89 00 04 	brgt	80009856 <_vfprintf_r+0x187a>
80009852:	2f 83       	sub	r3,-8
80009854:	c0 b8       	rjmp	8000986a <_vfprintf_r+0x188e>
80009856:	fa ca f9 78 	sub	r10,sp,-1672
8000985a:	02 9b       	mov	r11,r1
8000985c:	08 9c       	mov	r12,r4
8000985e:	fe b0 f3 b1 	rcall	80007fc0 <__sprint_r>
80009862:	e0 81 03 3c 	brne	80009eda <_vfprintf_r+0x1efe>
80009866:	fa c3 f9 e0 	sub	r3,sp,-1568
8000986a:	40 29       	lddsp	r9,sp[0x8]
8000986c:	21 09       	sub	r9,16
8000986e:	50 29       	stdsp	sp[0x8],r9
80009870:	fa f9 06 90 	ld.w	r9,sp[1680]
80009874:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009878:	fe ca b5 88 	sub	r10,pc,-19064
8000987c:	40 2e       	lddsp	lr,sp[0x8]
8000987e:	59 0e       	cp.w	lr,16
80009880:	fe 99 ff db 	brgt	80009836 <_vfprintf_r+0x185a>
80009884:	1c 09       	add	r9,lr
80009886:	2f f8       	sub	r8,-1
80009888:	87 0a       	st.w	r3[0x0],r10
8000988a:	fb 49 06 90 	st.w	sp[1680],r9
8000988e:	87 1e       	st.w	r3[0x4],lr
80009890:	fb 48 06 8c 	st.w	sp[1676],r8
80009894:	58 78       	cp.w	r8,7
80009896:	e0 89 00 04 	brgt	8000989e <_vfprintf_r+0x18c2>
8000989a:	2f 83       	sub	r3,-8
8000989c:	c0 b8       	rjmp	800098b2 <_vfprintf_r+0x18d6>
8000989e:	fa ca f9 78 	sub	r10,sp,-1672
800098a2:	02 9b       	mov	r11,r1
800098a4:	08 9c       	mov	r12,r4
800098a6:	fe b0 f3 8d 	rcall	80007fc0 <__sprint_r>
800098aa:	e0 81 03 18 	brne	80009eda <_vfprintf_r+0x1efe>
800098ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800098b2:	ed b5 00 08 	bld	r5,0x8
800098b6:	c0 b0       	breq	800098cc <_vfprintf_r+0x18f0>
800098b8:	fa f8 06 90 	ld.w	r8,sp[1680]
800098bc:	87 12       	st.w	r3[0x4],r2
800098be:	87 06       	st.w	r3[0x0],r6
800098c0:	f0 02 00 02 	add	r2,r8,r2
800098c4:	fb 42 06 90 	st.w	sp[1680],r2
800098c8:	e0 8f 01 d4 	bral	80009c70 <_vfprintf_r+0x1c94>
800098cc:	e0 40 00 65 	cp.w	r0,101
800098d0:	e0 8a 01 d6 	brle	80009c7c <_vfprintf_r+0x1ca0>
800098d4:	30 08       	mov	r8,0
800098d6:	30 09       	mov	r9,0
800098d8:	40 5b       	lddsp	r11,sp[0x14]
800098da:	40 7a       	lddsp	r10,sp[0x1c]
800098dc:	e0 a0 15 2f 	rcall	8000c33a <__avr32_f64_cmp_eq>
800098e0:	c7 90       	breq	800099d2 <_vfprintf_r+0x19f6>
800098e2:	fa f8 06 90 	ld.w	r8,sp[1680]
800098e6:	fe c9 b6 0a 	sub	r9,pc,-18934
800098ea:	2f f8       	sub	r8,-1
800098ec:	87 09       	st.w	r3[0x0],r9
800098ee:	fb 48 06 90 	st.w	sp[1680],r8
800098f2:	30 19       	mov	r9,1
800098f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098f8:	87 19       	st.w	r3[0x4],r9
800098fa:	2f f8       	sub	r8,-1
800098fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009900:	58 78       	cp.w	r8,7
80009902:	e0 89 00 05 	brgt	8000990c <_vfprintf_r+0x1930>
80009906:	2f 83       	sub	r3,-8
80009908:	c0 c8       	rjmp	80009920 <_vfprintf_r+0x1944>
8000990a:	d7 03       	nop
8000990c:	fa ca f9 78 	sub	r10,sp,-1672
80009910:	02 9b       	mov	r11,r1
80009912:	08 9c       	mov	r12,r4
80009914:	fe b0 f3 56 	rcall	80007fc0 <__sprint_r>
80009918:	e0 81 02 e1 	brne	80009eda <_vfprintf_r+0x1efe>
8000991c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009920:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009924:	40 6c       	lddsp	r12,sp[0x18]
80009926:	18 38       	cp.w	r8,r12
80009928:	c0 55       	brlt	80009932 <_vfprintf_r+0x1956>
8000992a:	ed b5 00 00 	bld	r5,0x0
8000992e:	e0 81 02 6b 	brne	80009e04 <_vfprintf_r+0x1e28>
80009932:	fa f8 06 90 	ld.w	r8,sp[1680]
80009936:	2f f8       	sub	r8,-1
80009938:	40 cb       	lddsp	r11,sp[0x30]
8000993a:	fb 48 06 90 	st.w	sp[1680],r8
8000993e:	30 19       	mov	r9,1
80009940:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009944:	87 0b       	st.w	r3[0x0],r11
80009946:	2f f8       	sub	r8,-1
80009948:	87 19       	st.w	r3[0x4],r9
8000994a:	fb 48 06 8c 	st.w	sp[1676],r8
8000994e:	58 78       	cp.w	r8,7
80009950:	e0 89 00 04 	brgt	80009958 <_vfprintf_r+0x197c>
80009954:	2f 83       	sub	r3,-8
80009956:	c0 b8       	rjmp	8000996c <_vfprintf_r+0x1990>
80009958:	fa ca f9 78 	sub	r10,sp,-1672
8000995c:	02 9b       	mov	r11,r1
8000995e:	08 9c       	mov	r12,r4
80009960:	fe b0 f3 30 	rcall	80007fc0 <__sprint_r>
80009964:	e0 81 02 bb 	brne	80009eda <_vfprintf_r+0x1efe>
80009968:	fa c3 f9 e0 	sub	r3,sp,-1568
8000996c:	40 66       	lddsp	r6,sp[0x18]
8000996e:	20 16       	sub	r6,1
80009970:	58 06       	cp.w	r6,0
80009972:	e0 89 00 1d 	brgt	800099ac <_vfprintf_r+0x19d0>
80009976:	e0 8f 02 47 	bral	80009e04 <_vfprintf_r+0x1e28>
8000997a:	2f 09       	sub	r9,-16
8000997c:	2f f8       	sub	r8,-1
8000997e:	fb 49 06 90 	st.w	sp[1680],r9
80009982:	87 02       	st.w	r3[0x0],r2
80009984:	87 10       	st.w	r3[0x4],r0
80009986:	fb 48 06 8c 	st.w	sp[1676],r8
8000998a:	58 78       	cp.w	r8,7
8000998c:	e0 89 00 04 	brgt	80009994 <_vfprintf_r+0x19b8>
80009990:	2f 83       	sub	r3,-8
80009992:	c0 b8       	rjmp	800099a8 <_vfprintf_r+0x19cc>
80009994:	fa ca f9 78 	sub	r10,sp,-1672
80009998:	02 9b       	mov	r11,r1
8000999a:	08 9c       	mov	r12,r4
8000999c:	fe b0 f3 12 	rcall	80007fc0 <__sprint_r>
800099a0:	e0 81 02 9d 	brne	80009eda <_vfprintf_r+0x1efe>
800099a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800099a8:	21 06       	sub	r6,16
800099aa:	c0 48       	rjmp	800099b2 <_vfprintf_r+0x19d6>
800099ac:	fe c2 b6 bc 	sub	r2,pc,-18756
800099b0:	31 00       	mov	r0,16
800099b2:	fa f9 06 90 	ld.w	r9,sp[1680]
800099b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ba:	fe ca b6 ca 	sub	r10,pc,-18742
800099be:	59 06       	cp.w	r6,16
800099c0:	fe 99 ff dd 	brgt	8000997a <_vfprintf_r+0x199e>
800099c4:	0c 09       	add	r9,r6
800099c6:	87 0a       	st.w	r3[0x0],r10
800099c8:	fb 49 06 90 	st.w	sp[1680],r9
800099cc:	2f f8       	sub	r8,-1
800099ce:	87 16       	st.w	r3[0x4],r6
800099d0:	c5 39       	rjmp	80009c76 <_vfprintf_r+0x1c9a>
800099d2:	fa fa 06 ac 	ld.w	r10,sp[1708]
800099d6:	58 0a       	cp.w	r10,0
800099d8:	e0 89 00 92 	brgt	80009afc <_vfprintf_r+0x1b20>
800099dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e0:	fe c9 b7 04 	sub	r9,pc,-18684
800099e4:	2f f8       	sub	r8,-1
800099e6:	87 09       	st.w	r3[0x0],r9
800099e8:	fb 48 06 90 	st.w	sp[1680],r8
800099ec:	30 19       	mov	r9,1
800099ee:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099f2:	87 19       	st.w	r3[0x4],r9
800099f4:	2f f8       	sub	r8,-1
800099f6:	fb 48 06 8c 	st.w	sp[1676],r8
800099fa:	58 78       	cp.w	r8,7
800099fc:	e0 89 00 04 	brgt	80009a04 <_vfprintf_r+0x1a28>
80009a00:	2f 83       	sub	r3,-8
80009a02:	c0 b8       	rjmp	80009a18 <_vfprintf_r+0x1a3c>
80009a04:	fa ca f9 78 	sub	r10,sp,-1672
80009a08:	02 9b       	mov	r11,r1
80009a0a:	08 9c       	mov	r12,r4
80009a0c:	fe b0 f2 da 	rcall	80007fc0 <__sprint_r>
80009a10:	e0 81 02 65 	brne	80009eda <_vfprintf_r+0x1efe>
80009a14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a18:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a1c:	58 08       	cp.w	r8,0
80009a1e:	c0 81       	brne	80009a2e <_vfprintf_r+0x1a52>
80009a20:	40 6a       	lddsp	r10,sp[0x18]
80009a22:	58 0a       	cp.w	r10,0
80009a24:	c0 51       	brne	80009a2e <_vfprintf_r+0x1a52>
80009a26:	ed b5 00 00 	bld	r5,0x0
80009a2a:	e0 81 01 ed 	brne	80009e04 <_vfprintf_r+0x1e28>
80009a2e:	40 c9       	lddsp	r9,sp[0x30]
80009a30:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a34:	2f f8       	sub	r8,-1
80009a36:	87 09       	st.w	r3[0x0],r9
80009a38:	fb 48 06 90 	st.w	sp[1680],r8
80009a3c:	30 19       	mov	r9,1
80009a3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a42:	87 19       	st.w	r3[0x4],r9
80009a44:	2f f8       	sub	r8,-1
80009a46:	fb 48 06 8c 	st.w	sp[1676],r8
80009a4a:	58 78       	cp.w	r8,7
80009a4c:	e0 89 00 04 	brgt	80009a54 <_vfprintf_r+0x1a78>
80009a50:	2f 83       	sub	r3,-8
80009a52:	c0 b8       	rjmp	80009a68 <_vfprintf_r+0x1a8c>
80009a54:	fa ca f9 78 	sub	r10,sp,-1672
80009a58:	02 9b       	mov	r11,r1
80009a5a:	08 9c       	mov	r12,r4
80009a5c:	fe b0 f2 b2 	rcall	80007fc0 <__sprint_r>
80009a60:	e0 81 02 3d 	brne	80009eda <_vfprintf_r+0x1efe>
80009a64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a68:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009a6c:	5c 32       	neg	r2
80009a6e:	58 02       	cp.w	r2,0
80009a70:	e0 89 00 1d 	brgt	80009aaa <_vfprintf_r+0x1ace>
80009a74:	c3 d8       	rjmp	80009aee <_vfprintf_r+0x1b12>
80009a76:	2f 09       	sub	r9,-16
80009a78:	2f f8       	sub	r8,-1
80009a7a:	31 0e       	mov	lr,16
80009a7c:	fb 49 06 90 	st.w	sp[1680],r9
80009a80:	87 00       	st.w	r3[0x0],r0
80009a82:	87 1e       	st.w	r3[0x4],lr
80009a84:	fb 48 06 8c 	st.w	sp[1676],r8
80009a88:	58 78       	cp.w	r8,7
80009a8a:	e0 89 00 04 	brgt	80009a92 <_vfprintf_r+0x1ab6>
80009a8e:	2f 83       	sub	r3,-8
80009a90:	c0 b8       	rjmp	80009aa6 <_vfprintf_r+0x1aca>
80009a92:	fa ca f9 78 	sub	r10,sp,-1672
80009a96:	02 9b       	mov	r11,r1
80009a98:	08 9c       	mov	r12,r4
80009a9a:	fe b0 f2 93 	rcall	80007fc0 <__sprint_r>
80009a9e:	e0 81 02 1e 	brne	80009eda <_vfprintf_r+0x1efe>
80009aa2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aa6:	21 02       	sub	r2,16
80009aa8:	c0 38       	rjmp	80009aae <_vfprintf_r+0x1ad2>
80009aaa:	fe c0 b7 ba 	sub	r0,pc,-18502
80009aae:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ab2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ab6:	fe ca b7 c6 	sub	r10,pc,-18490
80009aba:	59 02       	cp.w	r2,16
80009abc:	fe 99 ff dd 	brgt	80009a76 <_vfprintf_r+0x1a9a>
80009ac0:	04 09       	add	r9,r2
80009ac2:	2f f8       	sub	r8,-1
80009ac4:	87 0a       	st.w	r3[0x0],r10
80009ac6:	fb 49 06 90 	st.w	sp[1680],r9
80009aca:	87 12       	st.w	r3[0x4],r2
80009acc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ad0:	58 78       	cp.w	r8,7
80009ad2:	e0 89 00 04 	brgt	80009ada <_vfprintf_r+0x1afe>
80009ad6:	2f 83       	sub	r3,-8
80009ad8:	c0 b8       	rjmp	80009aee <_vfprintf_r+0x1b12>
80009ada:	fa ca f9 78 	sub	r10,sp,-1672
80009ade:	02 9b       	mov	r11,r1
80009ae0:	08 9c       	mov	r12,r4
80009ae2:	fe b0 f2 6f 	rcall	80007fc0 <__sprint_r>
80009ae6:	e0 81 01 fa 	brne	80009eda <_vfprintf_r+0x1efe>
80009aea:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aee:	40 6c       	lddsp	r12,sp[0x18]
80009af0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009af4:	87 06       	st.w	r3[0x0],r6
80009af6:	87 1c       	st.w	r3[0x4],r12
80009af8:	18 08       	add	r8,r12
80009afa:	cb 98       	rjmp	80009c6c <_vfprintf_r+0x1c90>
80009afc:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b04:	40 6b       	lddsp	r11,sp[0x18]
80009b06:	16 3a       	cp.w	r10,r11
80009b08:	c6 f5       	brlt	80009be6 <_vfprintf_r+0x1c0a>
80009b0a:	16 09       	add	r9,r11
80009b0c:	2f f8       	sub	r8,-1
80009b0e:	87 06       	st.w	r3[0x0],r6
80009b10:	fb 49 06 90 	st.w	sp[1680],r9
80009b14:	87 1b       	st.w	r3[0x4],r11
80009b16:	fb 48 06 8c 	st.w	sp[1676],r8
80009b1a:	58 78       	cp.w	r8,7
80009b1c:	e0 89 00 04 	brgt	80009b24 <_vfprintf_r+0x1b48>
80009b20:	2f 83       	sub	r3,-8
80009b22:	c0 b8       	rjmp	80009b38 <_vfprintf_r+0x1b5c>
80009b24:	fa ca f9 78 	sub	r10,sp,-1672
80009b28:	02 9b       	mov	r11,r1
80009b2a:	08 9c       	mov	r12,r4
80009b2c:	fe b0 f2 4a 	rcall	80007fc0 <__sprint_r>
80009b30:	e0 81 01 d5 	brne	80009eda <_vfprintf_r+0x1efe>
80009b34:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b38:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009b3c:	40 6a       	lddsp	r10,sp[0x18]
80009b3e:	14 16       	sub	r6,r10
80009b40:	58 06       	cp.w	r6,0
80009b42:	e0 89 00 1c 	brgt	80009b7a <_vfprintf_r+0x1b9e>
80009b46:	c3 d8       	rjmp	80009bc0 <_vfprintf_r+0x1be4>
80009b48:	2f 09       	sub	r9,-16
80009b4a:	2f f8       	sub	r8,-1
80009b4c:	fb 49 06 90 	st.w	sp[1680],r9
80009b50:	87 02       	st.w	r3[0x0],r2
80009b52:	87 10       	st.w	r3[0x4],r0
80009b54:	fb 48 06 8c 	st.w	sp[1676],r8
80009b58:	58 78       	cp.w	r8,7
80009b5a:	e0 89 00 04 	brgt	80009b62 <_vfprintf_r+0x1b86>
80009b5e:	2f 83       	sub	r3,-8
80009b60:	c0 b8       	rjmp	80009b76 <_vfprintf_r+0x1b9a>
80009b62:	fa ca f9 78 	sub	r10,sp,-1672
80009b66:	02 9b       	mov	r11,r1
80009b68:	08 9c       	mov	r12,r4
80009b6a:	fe b0 f2 2b 	rcall	80007fc0 <__sprint_r>
80009b6e:	e0 81 01 b6 	brne	80009eda <_vfprintf_r+0x1efe>
80009b72:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b76:	21 06       	sub	r6,16
80009b78:	c0 48       	rjmp	80009b80 <_vfprintf_r+0x1ba4>
80009b7a:	fe c2 b8 8a 	sub	r2,pc,-18294
80009b7e:	31 00       	mov	r0,16
80009b80:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b84:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b88:	fe ca b8 98 	sub	r10,pc,-18280
80009b8c:	59 06       	cp.w	r6,16
80009b8e:	fe 99 ff dd 	brgt	80009b48 <_vfprintf_r+0x1b6c>
80009b92:	0c 09       	add	r9,r6
80009b94:	2f f8       	sub	r8,-1
80009b96:	87 0a       	st.w	r3[0x0],r10
80009b98:	fb 49 06 90 	st.w	sp[1680],r9
80009b9c:	87 16       	st.w	r3[0x4],r6
80009b9e:	fb 48 06 8c 	st.w	sp[1676],r8
80009ba2:	58 78       	cp.w	r8,7
80009ba4:	e0 89 00 04 	brgt	80009bac <_vfprintf_r+0x1bd0>
80009ba8:	2f 83       	sub	r3,-8
80009baa:	c0 b8       	rjmp	80009bc0 <_vfprintf_r+0x1be4>
80009bac:	fa ca f9 78 	sub	r10,sp,-1672
80009bb0:	02 9b       	mov	r11,r1
80009bb2:	08 9c       	mov	r12,r4
80009bb4:	fe b0 f2 06 	rcall	80007fc0 <__sprint_r>
80009bb8:	e0 81 01 91 	brne	80009eda <_vfprintf_r+0x1efe>
80009bbc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bc0:	ed b5 00 00 	bld	r5,0x0
80009bc4:	e0 81 01 20 	brne	80009e04 <_vfprintf_r+0x1e28>
80009bc8:	40 c9       	lddsp	r9,sp[0x30]
80009bca:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bce:	2f f8       	sub	r8,-1
80009bd0:	87 09       	st.w	r3[0x0],r9
80009bd2:	fb 48 06 90 	st.w	sp[1680],r8
80009bd6:	30 19       	mov	r9,1
80009bd8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bdc:	87 19       	st.w	r3[0x4],r9
80009bde:	2f f8       	sub	r8,-1
80009be0:	fb 48 06 8c 	st.w	sp[1676],r8
80009be4:	c0 29       	rjmp	80009de8 <_vfprintf_r+0x1e0c>
80009be6:	14 09       	add	r9,r10
80009be8:	2f f8       	sub	r8,-1
80009bea:	fb 49 06 90 	st.w	sp[1680],r9
80009bee:	87 06       	st.w	r3[0x0],r6
80009bf0:	87 1a       	st.w	r3[0x4],r10
80009bf2:	fb 48 06 8c 	st.w	sp[1676],r8
80009bf6:	58 78       	cp.w	r8,7
80009bf8:	e0 89 00 04 	brgt	80009c00 <_vfprintf_r+0x1c24>
80009bfc:	2f 83       	sub	r3,-8
80009bfe:	c0 b8       	rjmp	80009c14 <_vfprintf_r+0x1c38>
80009c00:	fa ca f9 78 	sub	r10,sp,-1672
80009c04:	02 9b       	mov	r11,r1
80009c06:	08 9c       	mov	r12,r4
80009c08:	fe b0 f1 dc 	rcall	80007fc0 <__sprint_r>
80009c0c:	e0 81 01 67 	brne	80009eda <_vfprintf_r+0x1efe>
80009c10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c14:	40 c8       	lddsp	r8,sp[0x30]
80009c16:	87 08       	st.w	r3[0x0],r8
80009c18:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c1c:	2f f8       	sub	r8,-1
80009c1e:	30 19       	mov	r9,1
80009c20:	fb 48 06 90 	st.w	sp[1680],r8
80009c24:	87 19       	st.w	r3[0x4],r9
80009c26:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c2a:	2f f8       	sub	r8,-1
80009c2c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c30:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009c34:	58 78       	cp.w	r8,7
80009c36:	e0 89 00 04 	brgt	80009c3e <_vfprintf_r+0x1c62>
80009c3a:	2f 83       	sub	r3,-8
80009c3c:	c0 b8       	rjmp	80009c52 <_vfprintf_r+0x1c76>
80009c3e:	fa ca f9 78 	sub	r10,sp,-1672
80009c42:	02 9b       	mov	r11,r1
80009c44:	08 9c       	mov	r12,r4
80009c46:	fe b0 f1 bd 	rcall	80007fc0 <__sprint_r>
80009c4a:	e0 81 01 48 	brne	80009eda <_vfprintf_r+0x1efe>
80009c4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c52:	04 06       	add	r6,r2
80009c54:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009c58:	87 06       	st.w	r3[0x0],r6
80009c5a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c5e:	40 66       	lddsp	r6,sp[0x18]
80009c60:	40 6e       	lddsp	lr,sp[0x18]
80009c62:	10 16       	sub	r6,r8
80009c64:	f2 08 01 08 	sub	r8,r9,r8
80009c68:	87 16       	st.w	r3[0x4],r6
80009c6a:	1c 08       	add	r8,lr
80009c6c:	fb 48 06 90 	st.w	sp[1680],r8
80009c70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c74:	2f f8       	sub	r8,-1
80009c76:	fb 48 06 8c 	st.w	sp[1676],r8
80009c7a:	cb 78       	rjmp	80009de8 <_vfprintf_r+0x1e0c>
80009c7c:	40 6c       	lddsp	r12,sp[0x18]
80009c7e:	58 1c       	cp.w	r12,1
80009c80:	e0 89 00 06 	brgt	80009c8c <_vfprintf_r+0x1cb0>
80009c84:	ed b5 00 00 	bld	r5,0x0
80009c88:	e0 81 00 85 	brne	80009d92 <_vfprintf_r+0x1db6>
80009c8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c90:	2f f8       	sub	r8,-1
80009c92:	30 19       	mov	r9,1
80009c94:	fb 48 06 90 	st.w	sp[1680],r8
80009c98:	87 06       	st.w	r3[0x0],r6
80009c9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c9e:	87 19       	st.w	r3[0x4],r9
80009ca0:	2f f8       	sub	r8,-1
80009ca2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ca6:	58 78       	cp.w	r8,7
80009ca8:	e0 89 00 04 	brgt	80009cb0 <_vfprintf_r+0x1cd4>
80009cac:	2f 83       	sub	r3,-8
80009cae:	c0 b8       	rjmp	80009cc4 <_vfprintf_r+0x1ce8>
80009cb0:	fa ca f9 78 	sub	r10,sp,-1672
80009cb4:	02 9b       	mov	r11,r1
80009cb6:	08 9c       	mov	r12,r4
80009cb8:	fe b0 f1 84 	rcall	80007fc0 <__sprint_r>
80009cbc:	e0 81 01 0f 	brne	80009eda <_vfprintf_r+0x1efe>
80009cc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cc4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cc8:	2f f8       	sub	r8,-1
80009cca:	40 cb       	lddsp	r11,sp[0x30]
80009ccc:	fb 48 06 90 	st.w	sp[1680],r8
80009cd0:	30 19       	mov	r9,1
80009cd2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd6:	87 0b       	st.w	r3[0x0],r11
80009cd8:	2f f8       	sub	r8,-1
80009cda:	87 19       	st.w	r3[0x4],r9
80009cdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce0:	58 78       	cp.w	r8,7
80009ce2:	e0 89 00 05 	brgt	80009cec <_vfprintf_r+0x1d10>
80009ce6:	2f 83       	sub	r3,-8
80009ce8:	c0 c8       	rjmp	80009d00 <_vfprintf_r+0x1d24>
80009cea:	d7 03       	nop
80009cec:	fa ca f9 78 	sub	r10,sp,-1672
80009cf0:	02 9b       	mov	r11,r1
80009cf2:	08 9c       	mov	r12,r4
80009cf4:	fe b0 f1 66 	rcall	80007fc0 <__sprint_r>
80009cf8:	e0 81 00 f1 	brne	80009eda <_vfprintf_r+0x1efe>
80009cfc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d00:	30 08       	mov	r8,0
80009d02:	30 09       	mov	r9,0
80009d04:	40 5b       	lddsp	r11,sp[0x14]
80009d06:	40 7a       	lddsp	r10,sp[0x1c]
80009d08:	e0 a0 13 19 	rcall	8000c33a <__avr32_f64_cmp_eq>
80009d0c:	40 68       	lddsp	r8,sp[0x18]
80009d0e:	20 18       	sub	r8,1
80009d10:	58 0c       	cp.w	r12,0
80009d12:	c0 d1       	brne	80009d2c <_vfprintf_r+0x1d50>
80009d14:	2f f6       	sub	r6,-1
80009d16:	87 18       	st.w	r3[0x4],r8
80009d18:	87 06       	st.w	r3[0x0],r6
80009d1a:	fa f6 06 90 	ld.w	r6,sp[1680]
80009d1e:	10 06       	add	r6,r8
80009d20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d24:	fb 46 06 90 	st.w	sp[1680],r6
80009d28:	2f f8       	sub	r8,-1
80009d2a:	c3 18       	rjmp	80009d8c <_vfprintf_r+0x1db0>
80009d2c:	10 96       	mov	r6,r8
80009d2e:	58 08       	cp.w	r8,0
80009d30:	e0 89 00 1c 	brgt	80009d68 <_vfprintf_r+0x1d8c>
80009d34:	c4 b8       	rjmp	80009dca <_vfprintf_r+0x1dee>
80009d36:	2f 09       	sub	r9,-16
80009d38:	2f f8       	sub	r8,-1
80009d3a:	fb 49 06 90 	st.w	sp[1680],r9
80009d3e:	87 02       	st.w	r3[0x0],r2
80009d40:	87 10       	st.w	r3[0x4],r0
80009d42:	fb 48 06 8c 	st.w	sp[1676],r8
80009d46:	58 78       	cp.w	r8,7
80009d48:	e0 89 00 04 	brgt	80009d50 <_vfprintf_r+0x1d74>
80009d4c:	2f 83       	sub	r3,-8
80009d4e:	c0 b8       	rjmp	80009d64 <_vfprintf_r+0x1d88>
80009d50:	fa ca f9 78 	sub	r10,sp,-1672
80009d54:	02 9b       	mov	r11,r1
80009d56:	08 9c       	mov	r12,r4
80009d58:	fe b0 f1 34 	rcall	80007fc0 <__sprint_r>
80009d5c:	e0 81 00 bf 	brne	80009eda <_vfprintf_r+0x1efe>
80009d60:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d64:	21 06       	sub	r6,16
80009d66:	c0 48       	rjmp	80009d6e <_vfprintf_r+0x1d92>
80009d68:	fe c2 ba 78 	sub	r2,pc,-17800
80009d6c:	31 00       	mov	r0,16
80009d6e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d72:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d76:	fe ca ba 86 	sub	r10,pc,-17786
80009d7a:	59 06       	cp.w	r6,16
80009d7c:	fe 99 ff dd 	brgt	80009d36 <_vfprintf_r+0x1d5a>
80009d80:	0c 09       	add	r9,r6
80009d82:	87 0a       	st.w	r3[0x0],r10
80009d84:	fb 49 06 90 	st.w	sp[1680],r9
80009d88:	2f f8       	sub	r8,-1
80009d8a:	87 16       	st.w	r3[0x4],r6
80009d8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009d90:	c0 e8       	rjmp	80009dac <_vfprintf_r+0x1dd0>
80009d92:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d96:	2f f8       	sub	r8,-1
80009d98:	30 19       	mov	r9,1
80009d9a:	fb 48 06 90 	st.w	sp[1680],r8
80009d9e:	87 06       	st.w	r3[0x0],r6
80009da0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009da4:	87 19       	st.w	r3[0x4],r9
80009da6:	2f f8       	sub	r8,-1
80009da8:	fb 48 06 8c 	st.w	sp[1676],r8
80009dac:	58 78       	cp.w	r8,7
80009dae:	e0 89 00 04 	brgt	80009db6 <_vfprintf_r+0x1dda>
80009db2:	2f 83       	sub	r3,-8
80009db4:	c0 b8       	rjmp	80009dca <_vfprintf_r+0x1dee>
80009db6:	fa ca f9 78 	sub	r10,sp,-1672
80009dba:	02 9b       	mov	r11,r1
80009dbc:	08 9c       	mov	r12,r4
80009dbe:	fe b0 f1 01 	rcall	80007fc0 <__sprint_r>
80009dc2:	e0 81 00 8c 	brne	80009eda <_vfprintf_r+0x1efe>
80009dc6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dca:	40 ea       	lddsp	r10,sp[0x38]
80009dcc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dd0:	14 08       	add	r8,r10
80009dd2:	fa c9 f9 64 	sub	r9,sp,-1692
80009dd6:	fb 48 06 90 	st.w	sp[1680],r8
80009dda:	87 1a       	st.w	r3[0x4],r10
80009ddc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009de0:	87 09       	st.w	r3[0x0],r9
80009de2:	2f f8       	sub	r8,-1
80009de4:	fb 48 06 8c 	st.w	sp[1676],r8
80009de8:	58 78       	cp.w	r8,7
80009dea:	e0 89 00 04 	brgt	80009df2 <_vfprintf_r+0x1e16>
80009dee:	2f 83       	sub	r3,-8
80009df0:	c0 a8       	rjmp	80009e04 <_vfprintf_r+0x1e28>
80009df2:	fa ca f9 78 	sub	r10,sp,-1672
80009df6:	02 9b       	mov	r11,r1
80009df8:	08 9c       	mov	r12,r4
80009dfa:	fe b0 f0 e3 	rcall	80007fc0 <__sprint_r>
80009dfe:	c6 e1       	brne	80009eda <_vfprintf_r+0x1efe>
80009e00:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e04:	e2 15 00 04 	andl	r5,0x4,COH
80009e08:	c3 f0       	breq	80009e86 <_vfprintf_r+0x1eaa>
80009e0a:	40 86       	lddsp	r6,sp[0x20]
80009e0c:	40 39       	lddsp	r9,sp[0xc]
80009e0e:	12 16       	sub	r6,r9
80009e10:	58 06       	cp.w	r6,0
80009e12:	e0 89 00 1a 	brgt	80009e46 <_vfprintf_r+0x1e6a>
80009e16:	c3 88       	rjmp	80009e86 <_vfprintf_r+0x1eaa>
80009e18:	2f 09       	sub	r9,-16
80009e1a:	2f f8       	sub	r8,-1
80009e1c:	fb 49 06 90 	st.w	sp[1680],r9
80009e20:	87 05       	st.w	r3[0x0],r5
80009e22:	87 12       	st.w	r3[0x4],r2
80009e24:	fb 48 06 8c 	st.w	sp[1676],r8
80009e28:	58 78       	cp.w	r8,7
80009e2a:	e0 89 00 04 	brgt	80009e32 <_vfprintf_r+0x1e56>
80009e2e:	2f 83       	sub	r3,-8
80009e30:	c0 98       	rjmp	80009e42 <_vfprintf_r+0x1e66>
80009e32:	00 9a       	mov	r10,r0
80009e34:	02 9b       	mov	r11,r1
80009e36:	08 9c       	mov	r12,r4
80009e38:	fe b0 f0 c4 	rcall	80007fc0 <__sprint_r>
80009e3c:	c4 f1       	brne	80009eda <_vfprintf_r+0x1efe>
80009e3e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e42:	21 06       	sub	r6,16
80009e44:	c0 68       	rjmp	80009e50 <_vfprintf_r+0x1e74>
80009e46:	fe c5 bb 66 	sub	r5,pc,-17562
80009e4a:	31 02       	mov	r2,16
80009e4c:	fa c0 f9 78 	sub	r0,sp,-1672
80009e50:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e54:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e58:	fe ca bb 78 	sub	r10,pc,-17544
80009e5c:	59 06       	cp.w	r6,16
80009e5e:	fe 99 ff dd 	brgt	80009e18 <_vfprintf_r+0x1e3c>
80009e62:	0c 09       	add	r9,r6
80009e64:	2f f8       	sub	r8,-1
80009e66:	87 0a       	st.w	r3[0x0],r10
80009e68:	87 16       	st.w	r3[0x4],r6
80009e6a:	fb 49 06 90 	st.w	sp[1680],r9
80009e6e:	fb 48 06 8c 	st.w	sp[1676],r8
80009e72:	58 78       	cp.w	r8,7
80009e74:	e0 8a 00 09 	brle	80009e86 <_vfprintf_r+0x1eaa>
80009e78:	fa ca f9 78 	sub	r10,sp,-1672
80009e7c:	02 9b       	mov	r11,r1
80009e7e:	08 9c       	mov	r12,r4
80009e80:	fe b0 f0 a0 	rcall	80007fc0 <__sprint_r>
80009e84:	c2 b1       	brne	80009eda <_vfprintf_r+0x1efe>
80009e86:	40 bc       	lddsp	r12,sp[0x2c]
80009e88:	40 36       	lddsp	r6,sp[0xc]
80009e8a:	40 8e       	lddsp	lr,sp[0x20]
80009e8c:	ec 0e 0c 48 	max	r8,r6,lr
80009e90:	10 0c       	add	r12,r8
80009e92:	50 bc       	stdsp	sp[0x2c],r12
80009e94:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e98:	58 08       	cp.w	r8,0
80009e9a:	c0 80       	breq	80009eaa <_vfprintf_r+0x1ece>
80009e9c:	fa ca f9 78 	sub	r10,sp,-1672
80009ea0:	02 9b       	mov	r11,r1
80009ea2:	08 9c       	mov	r12,r4
80009ea4:	fe b0 f0 8e 	rcall	80007fc0 <__sprint_r>
80009ea8:	c1 91       	brne	80009eda <_vfprintf_r+0x1efe>
80009eaa:	30 0b       	mov	r11,0
80009eac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eb0:	fb 4b 06 8c 	st.w	sp[1676],r11
80009eb4:	fe 9f f1 22 	bral	800080f8 <_vfprintf_r+0x11c>
80009eb8:	08 95       	mov	r5,r4
80009eba:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ebe:	58 08       	cp.w	r8,0
80009ec0:	c0 80       	breq	80009ed0 <_vfprintf_r+0x1ef4>
80009ec2:	08 9c       	mov	r12,r4
80009ec4:	fa ca f9 78 	sub	r10,sp,-1672
80009ec8:	02 9b       	mov	r11,r1
80009eca:	fe b0 f0 7b 	rcall	80007fc0 <__sprint_r>
80009ece:	c0 61       	brne	80009eda <_vfprintf_r+0x1efe>
80009ed0:	30 08       	mov	r8,0
80009ed2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ed6:	c0 28       	rjmp	80009eda <_vfprintf_r+0x1efe>
80009ed8:	40 41       	lddsp	r1,sp[0x10]
80009eda:	82 68       	ld.sh	r8,r1[0xc]
80009edc:	ed b8 00 06 	bld	r8,0x6
80009ee0:	c0 31       	brne	80009ee6 <_vfprintf_r+0x1f0a>
80009ee2:	3f fa       	mov	r10,-1
80009ee4:	50 ba       	stdsp	sp[0x2c],r10
80009ee6:	40 bc       	lddsp	r12,sp[0x2c]
80009ee8:	fe 3d f9 44 	sub	sp,-1724
80009eec:	d8 32       	popm	r0-r7,pc
80009eee:	d7 03       	nop

80009ef0 <__swsetup_r>:
80009ef0:	d4 21       	pushm	r4-r7,lr
80009ef2:	e0 68 0a 3c 	mov	r8,2620
80009ef6:	18 96       	mov	r6,r12
80009ef8:	16 97       	mov	r7,r11
80009efa:	70 0c       	ld.w	r12,r8[0x0]
80009efc:	58 0c       	cp.w	r12,0
80009efe:	c0 60       	breq	80009f0a <__swsetup_r+0x1a>
80009f00:	78 68       	ld.w	r8,r12[0x18]
80009f02:	58 08       	cp.w	r8,0
80009f04:	c0 31       	brne	80009f0a <__swsetup_r+0x1a>
80009f06:	e0 a0 07 bf 	rcall	8000ae84 <__sinit>
80009f0a:	fe c8 ba fa 	sub	r8,pc,-17670
80009f0e:	10 37       	cp.w	r7,r8
80009f10:	c0 61       	brne	80009f1c <__swsetup_r+0x2c>
80009f12:	e0 68 0a 3c 	mov	r8,2620
80009f16:	70 08       	ld.w	r8,r8[0x0]
80009f18:	70 07       	ld.w	r7,r8[0x0]
80009f1a:	c1 28       	rjmp	80009f3e <__swsetup_r+0x4e>
80009f1c:	fe c8 ba ec 	sub	r8,pc,-17684
80009f20:	10 37       	cp.w	r7,r8
80009f22:	c0 61       	brne	80009f2e <__swsetup_r+0x3e>
80009f24:	e0 68 0a 3c 	mov	r8,2620
80009f28:	70 08       	ld.w	r8,r8[0x0]
80009f2a:	70 17       	ld.w	r7,r8[0x4]
80009f2c:	c0 98       	rjmp	80009f3e <__swsetup_r+0x4e>
80009f2e:	fe c8 ba de 	sub	r8,pc,-17698
80009f32:	10 37       	cp.w	r7,r8
80009f34:	c0 51       	brne	80009f3e <__swsetup_r+0x4e>
80009f36:	e0 68 0a 3c 	mov	r8,2620
80009f3a:	70 08       	ld.w	r8,r8[0x0]
80009f3c:	70 27       	ld.w	r7,r8[0x8]
80009f3e:	8e 68       	ld.sh	r8,r7[0xc]
80009f40:	ed b8 00 03 	bld	r8,0x3
80009f44:	c1 e0       	breq	80009f80 <__swsetup_r+0x90>
80009f46:	ed b8 00 04 	bld	r8,0x4
80009f4a:	c3 e1       	brne	80009fc6 <__swsetup_r+0xd6>
80009f4c:	ed b8 00 02 	bld	r8,0x2
80009f50:	c1 51       	brne	80009f7a <__swsetup_r+0x8a>
80009f52:	6e db       	ld.w	r11,r7[0x34]
80009f54:	58 0b       	cp.w	r11,0
80009f56:	c0 a0       	breq	80009f6a <__swsetup_r+0x7a>
80009f58:	ee c8 ff bc 	sub	r8,r7,-68
80009f5c:	10 3b       	cp.w	r11,r8
80009f5e:	c0 40       	breq	80009f66 <__swsetup_r+0x76>
80009f60:	0c 9c       	mov	r12,r6
80009f62:	e0 a0 08 2b 	rcall	8000afb8 <_free_r>
80009f66:	30 08       	mov	r8,0
80009f68:	8f d8       	st.w	r7[0x34],r8
80009f6a:	8e 68       	ld.sh	r8,r7[0xc]
80009f6c:	e0 18 ff db 	andl	r8,0xffdb
80009f70:	ae 68       	st.h	r7[0xc],r8
80009f72:	30 08       	mov	r8,0
80009f74:	8f 18       	st.w	r7[0x4],r8
80009f76:	6e 48       	ld.w	r8,r7[0x10]
80009f78:	8f 08       	st.w	r7[0x0],r8
80009f7a:	8e 68       	ld.sh	r8,r7[0xc]
80009f7c:	a3 b8       	sbr	r8,0x3
80009f7e:	ae 68       	st.h	r7[0xc],r8
80009f80:	6e 48       	ld.w	r8,r7[0x10]
80009f82:	58 08       	cp.w	r8,0
80009f84:	c0 b1       	brne	80009f9a <__swsetup_r+0xaa>
80009f86:	8e 68       	ld.sh	r8,r7[0xc]
80009f88:	e2 18 02 80 	andl	r8,0x280,COH
80009f8c:	e0 48 02 00 	cp.w	r8,512
80009f90:	c0 50       	breq	80009f9a <__swsetup_r+0xaa>
80009f92:	0c 9c       	mov	r12,r6
80009f94:	0e 9b       	mov	r11,r7
80009f96:	e0 a0 0a 4b 	rcall	8000b42c <__smakebuf_r>
80009f9a:	8e 69       	ld.sh	r9,r7[0xc]
80009f9c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009fa0:	c0 70       	breq	80009fae <__swsetup_r+0xbe>
80009fa2:	30 08       	mov	r8,0
80009fa4:	8f 28       	st.w	r7[0x8],r8
80009fa6:	6e 58       	ld.w	r8,r7[0x14]
80009fa8:	5c 38       	neg	r8
80009faa:	8f 68       	st.w	r7[0x18],r8
80009fac:	c0 68       	rjmp	80009fb8 <__swsetup_r+0xc8>
80009fae:	ed b9 00 01 	bld	r9,0x1
80009fb2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009fb6:	8f 28       	st.w	r7[0x8],r8
80009fb8:	6e 48       	ld.w	r8,r7[0x10]
80009fba:	58 08       	cp.w	r8,0
80009fbc:	c0 61       	brne	80009fc8 <__swsetup_r+0xd8>
80009fbe:	8e 68       	ld.sh	r8,r7[0xc]
80009fc0:	ed b8 00 07 	bld	r8,0x7
80009fc4:	c0 21       	brne	80009fc8 <__swsetup_r+0xd8>
80009fc6:	dc 2a       	popm	r4-r7,pc,r12=-1
80009fc8:	d8 2a       	popm	r4-r7,pc,r12=0
80009fca:	d7 03       	nop

80009fcc <quorem>:
80009fcc:	d4 31       	pushm	r0-r7,lr
80009fce:	20 2d       	sub	sp,8
80009fd0:	18 97       	mov	r7,r12
80009fd2:	78 48       	ld.w	r8,r12[0x10]
80009fd4:	76 46       	ld.w	r6,r11[0x10]
80009fd6:	0c 38       	cp.w	r8,r6
80009fd8:	c0 34       	brge	80009fde <quorem+0x12>
80009fda:	30 0c       	mov	r12,0
80009fdc:	c8 58       	rjmp	8000a0e6 <quorem+0x11a>
80009fde:	ec c2 ff fc 	sub	r2,r6,-4
80009fe2:	f6 c3 ff ec 	sub	r3,r11,-20
80009fe6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009fea:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009fee:	2f f9       	sub	r9,-1
80009ff0:	20 16       	sub	r6,1
80009ff2:	f8 09 0d 08 	divu	r8,r12,r9
80009ff6:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009ffa:	ee c4 ff ec 	sub	r4,r7,-20
80009ffe:	10 95       	mov	r5,r8
8000a000:	58 08       	cp.w	r8,0
8000a002:	c4 10       	breq	8000a084 <quorem+0xb8>
8000a004:	30 09       	mov	r9,0
8000a006:	06 9a       	mov	r10,r3
8000a008:	08 98       	mov	r8,r4
8000a00a:	12 91       	mov	r1,r9
8000a00c:	50 0b       	stdsp	sp[0x0],r11
8000a00e:	70 0e       	ld.w	lr,r8[0x0]
8000a010:	b1 8e       	lsr	lr,0x10
8000a012:	50 1e       	stdsp	sp[0x4],lr
8000a014:	15 0e       	ld.w	lr,r10++
8000a016:	fc 00 16 10 	lsr	r0,lr,0x10
8000a01a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a01e:	ea 0e 03 41 	mac	r1,r5,lr
8000a022:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a026:	b1 81       	lsr	r1,0x10
8000a028:	40 1b       	lddsp	r11,sp[0x4]
8000a02a:	ea 00 02 40 	mul	r0,r5,r0
8000a02e:	e2 00 00 00 	add	r0,r1,r0
8000a032:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a036:	02 1b       	sub	r11,r1
8000a038:	50 1b       	stdsp	sp[0x4],r11
8000a03a:	70 0b       	ld.w	r11,r8[0x0]
8000a03c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a040:	02 09       	add	r9,r1
8000a042:	f2 0e 01 0e 	sub	lr,r9,lr
8000a046:	b0 1e       	st.h	r8[0x2],lr
8000a048:	fc 09 14 10 	asr	r9,lr,0x10
8000a04c:	40 1e       	lddsp	lr,sp[0x4]
8000a04e:	fc 09 00 09 	add	r9,lr,r9
8000a052:	b0 09       	st.h	r8[0x0],r9
8000a054:	e0 01 16 10 	lsr	r1,r0,0x10
8000a058:	2f c8       	sub	r8,-4
8000a05a:	b1 49       	asr	r9,0x10
8000a05c:	04 3a       	cp.w	r10,r2
8000a05e:	fe 98 ff d8 	brls	8000a00e <quorem+0x42>
8000a062:	40 0b       	lddsp	r11,sp[0x0]
8000a064:	58 0c       	cp.w	r12,0
8000a066:	c0 f1       	brne	8000a084 <quorem+0xb8>
8000a068:	ec c8 ff fb 	sub	r8,r6,-5
8000a06c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a070:	c0 28       	rjmp	8000a074 <quorem+0xa8>
8000a072:	20 16       	sub	r6,1
8000a074:	20 48       	sub	r8,4
8000a076:	08 38       	cp.w	r8,r4
8000a078:	e0 88 00 05 	brls	8000a082 <quorem+0xb6>
8000a07c:	70 09       	ld.w	r9,r8[0x0]
8000a07e:	58 09       	cp.w	r9,0
8000a080:	cf 90       	breq	8000a072 <quorem+0xa6>
8000a082:	8f 46       	st.w	r7[0x10],r6
8000a084:	0e 9c       	mov	r12,r7
8000a086:	e0 a0 0a d2 	rcall	8000b62a <__mcmp>
8000a08a:	c2 d5       	brlt	8000a0e4 <quorem+0x118>
8000a08c:	2f f5       	sub	r5,-1
8000a08e:	08 98       	mov	r8,r4
8000a090:	30 09       	mov	r9,0
8000a092:	07 0b       	ld.w	r11,r3++
8000a094:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a098:	70 0c       	ld.w	r12,r8[0x0]
8000a09a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a09e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a0a2:	14 1e       	sub	lr,r10
8000a0a4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a0a8:	16 1a       	sub	r10,r11
8000a0aa:	12 0a       	add	r10,r9
8000a0ac:	b0 1a       	st.h	r8[0x2],r10
8000a0ae:	b1 4a       	asr	r10,0x10
8000a0b0:	fc 0a 00 09 	add	r9,lr,r10
8000a0b4:	b0 09       	st.h	r8[0x0],r9
8000a0b6:	2f c8       	sub	r8,-4
8000a0b8:	b1 49       	asr	r9,0x10
8000a0ba:	04 33       	cp.w	r3,r2
8000a0bc:	fe 98 ff eb 	brls	8000a092 <quorem+0xc6>
8000a0c0:	ec c8 ff fb 	sub	r8,r6,-5
8000a0c4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a0c8:	58 09       	cp.w	r9,0
8000a0ca:	c0 d1       	brne	8000a0e4 <quorem+0x118>
8000a0cc:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a0d0:	c0 28       	rjmp	8000a0d4 <quorem+0x108>
8000a0d2:	20 16       	sub	r6,1
8000a0d4:	20 48       	sub	r8,4
8000a0d6:	08 38       	cp.w	r8,r4
8000a0d8:	e0 88 00 05 	brls	8000a0e2 <quorem+0x116>
8000a0dc:	70 09       	ld.w	r9,r8[0x0]
8000a0de:	58 09       	cp.w	r9,0
8000a0e0:	cf 90       	breq	8000a0d2 <quorem+0x106>
8000a0e2:	8f 46       	st.w	r7[0x10],r6
8000a0e4:	0a 9c       	mov	r12,r5
8000a0e6:	2f ed       	sub	sp,-8
8000a0e8:	d8 32       	popm	r0-r7,pc
8000a0ea:	d7 03       	nop

8000a0ec <_dtoa_r>:
8000a0ec:	d4 31       	pushm	r0-r7,lr
8000a0ee:	21 ad       	sub	sp,104
8000a0f0:	fa c4 ff 74 	sub	r4,sp,-140
8000a0f4:	18 97       	mov	r7,r12
8000a0f6:	16 95       	mov	r5,r11
8000a0f8:	68 2c       	ld.w	r12,r4[0x8]
8000a0fa:	50 c9       	stdsp	sp[0x30],r9
8000a0fc:	68 16       	ld.w	r6,r4[0x4]
8000a0fe:	68 09       	ld.w	r9,r4[0x0]
8000a100:	50 e8       	stdsp	sp[0x38],r8
8000a102:	14 94       	mov	r4,r10
8000a104:	51 2c       	stdsp	sp[0x48],r12
8000a106:	fa e5 00 08 	st.d	sp[8],r4
8000a10a:	51 59       	stdsp	sp[0x54],r9
8000a10c:	6e 95       	ld.w	r5,r7[0x24]
8000a10e:	58 05       	cp.w	r5,0
8000a110:	c0 91       	brne	8000a122 <_dtoa_r+0x36>
8000a112:	31 0c       	mov	r12,16
8000a114:	fe b0 e8 d6 	rcall	800072c0 <malloc>
8000a118:	99 35       	st.w	r12[0xc],r5
8000a11a:	8f 9c       	st.w	r7[0x24],r12
8000a11c:	99 15       	st.w	r12[0x4],r5
8000a11e:	99 25       	st.w	r12[0x8],r5
8000a120:	99 05       	st.w	r12[0x0],r5
8000a122:	6e 99       	ld.w	r9,r7[0x24]
8000a124:	72 08       	ld.w	r8,r9[0x0]
8000a126:	58 08       	cp.w	r8,0
8000a128:	c0 f0       	breq	8000a146 <_dtoa_r+0x5a>
8000a12a:	72 1a       	ld.w	r10,r9[0x4]
8000a12c:	91 1a       	st.w	r8[0x4],r10
8000a12e:	30 1a       	mov	r10,1
8000a130:	72 19       	ld.w	r9,r9[0x4]
8000a132:	f4 09 09 49 	lsl	r9,r10,r9
8000a136:	10 9b       	mov	r11,r8
8000a138:	91 29       	st.w	r8[0x8],r9
8000a13a:	0e 9c       	mov	r12,r7
8000a13c:	e0 a0 0a 90 	rcall	8000b65c <_Bfree>
8000a140:	6e 98       	ld.w	r8,r7[0x24]
8000a142:	30 09       	mov	r9,0
8000a144:	91 09       	st.w	r8[0x0],r9
8000a146:	40 28       	lddsp	r8,sp[0x8]
8000a148:	10 94       	mov	r4,r8
8000a14a:	58 08       	cp.w	r8,0
8000a14c:	c0 64       	brge	8000a158 <_dtoa_r+0x6c>
8000a14e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a152:	50 28       	stdsp	sp[0x8],r8
8000a154:	30 18       	mov	r8,1
8000a156:	c0 28       	rjmp	8000a15a <_dtoa_r+0x6e>
8000a158:	30 08       	mov	r8,0
8000a15a:	8d 08       	st.w	r6[0x0],r8
8000a15c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a160:	40 26       	lddsp	r6,sp[0x8]
8000a162:	0c 98       	mov	r8,r6
8000a164:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a168:	18 38       	cp.w	r8,r12
8000a16a:	c2 01       	brne	8000a1aa <_dtoa_r+0xbe>
8000a16c:	e0 68 27 0f 	mov	r8,9999
8000a170:	41 5b       	lddsp	r11,sp[0x54]
8000a172:	97 08       	st.w	r11[0x0],r8
8000a174:	40 3a       	lddsp	r10,sp[0xc]
8000a176:	58 0a       	cp.w	r10,0
8000a178:	c0 71       	brne	8000a186 <_dtoa_r+0x9a>
8000a17a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a17e:	c0 41       	brne	8000a186 <_dtoa_r+0x9a>
8000a180:	fe cc bd 80 	sub	r12,pc,-17024
8000a184:	c0 38       	rjmp	8000a18a <_dtoa_r+0x9e>
8000a186:	fe cc bd 7a 	sub	r12,pc,-17030
8000a18a:	41 29       	lddsp	r9,sp[0x48]
8000a18c:	58 09       	cp.w	r9,0
8000a18e:	e0 80 05 9a 	breq	8000acc2 <_dtoa_r+0xbd6>
8000a192:	f8 c8 ff fd 	sub	r8,r12,-3
8000a196:	f8 c9 ff f8 	sub	r9,r12,-8
8000a19a:	11 8b       	ld.ub	r11,r8[0x0]
8000a19c:	30 0a       	mov	r10,0
8000a19e:	41 25       	lddsp	r5,sp[0x48]
8000a1a0:	f4 0b 18 00 	cp.b	r11,r10
8000a1a4:	f2 08 17 10 	movne	r8,r9
8000a1a8:	c1 68       	rjmp	8000a1d4 <_dtoa_r+0xe8>
8000a1aa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1ae:	30 08       	mov	r8,0
8000a1b0:	fa eb 00 3c 	st.d	sp[60],r10
8000a1b4:	30 09       	mov	r9,0
8000a1b6:	e0 a0 10 c2 	rcall	8000c33a <__avr32_f64_cmp_eq>
8000a1ba:	c1 00       	breq	8000a1da <_dtoa_r+0xee>
8000a1bc:	30 18       	mov	r8,1
8000a1be:	41 5a       	lddsp	r10,sp[0x54]
8000a1c0:	95 08       	st.w	r10[0x0],r8
8000a1c2:	fe cc be e6 	sub	r12,pc,-16666
8000a1c6:	41 29       	lddsp	r9,sp[0x48]
8000a1c8:	f8 08 00 08 	add	r8,r12,r8
8000a1cc:	58 09       	cp.w	r9,0
8000a1ce:	e0 80 05 7a 	breq	8000acc2 <_dtoa_r+0xbd6>
8000a1d2:	12 95       	mov	r5,r9
8000a1d4:	8b 08       	st.w	r5[0x0],r8
8000a1d6:	e0 8f 05 76 	bral	8000acc2 <_dtoa_r+0xbd6>
8000a1da:	fa c8 ff 9c 	sub	r8,sp,-100
8000a1de:	fa c9 ff a0 	sub	r9,sp,-96
8000a1e2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1e6:	0e 9c       	mov	r12,r7
8000a1e8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a1ec:	e0 a0 0a 8a 	rcall	8000b700 <__d2b>
8000a1f0:	18 93       	mov	r3,r12
8000a1f2:	58 05       	cp.w	r5,0
8000a1f4:	c0 d0       	breq	8000a20e <_dtoa_r+0x122>
8000a1f6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1fa:	30 04       	mov	r4,0
8000a1fc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a200:	ea c5 03 ff 	sub	r5,r5,1023
8000a204:	10 9b       	mov	r11,r8
8000a206:	51 74       	stdsp	sp[0x5c],r4
8000a208:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a20c:	c2 58       	rjmp	8000a256 <_dtoa_r+0x16a>
8000a20e:	41 88       	lddsp	r8,sp[0x60]
8000a210:	41 9c       	lddsp	r12,sp[0x64]
8000a212:	10 0c       	add	r12,r8
8000a214:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a218:	e0 45 00 20 	cp.w	r5,32
8000a21c:	e0 8a 00 0e 	brle	8000a238 <_dtoa_r+0x14c>
8000a220:	f8 cc fb ee 	sub	r12,r12,-1042
8000a224:	40 3b       	lddsp	r11,sp[0xc]
8000a226:	ea 08 11 40 	rsub	r8,r5,64
8000a22a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a22e:	ec 08 09 46 	lsl	r6,r6,r8
8000a232:	0c 4c       	or	r12,r6
8000a234:	c0 78       	rjmp	8000a242 <_dtoa_r+0x156>
8000a236:	d7 03       	nop
8000a238:	ea 0c 11 20 	rsub	r12,r5,32
8000a23c:	40 3a       	lddsp	r10,sp[0xc]
8000a23e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a242:	e0 a0 10 08 	rcall	8000c252 <__avr32_u32_to_f64>
8000a246:	fc 18 fe 10 	movh	r8,0xfe10
8000a24a:	30 19       	mov	r9,1
8000a24c:	ea c5 04 33 	sub	r5,r5,1075
8000a250:	f0 0b 00 0b 	add	r11,r8,r11
8000a254:	51 79       	stdsp	sp[0x5c],r9
8000a256:	30 08       	mov	r8,0
8000a258:	fc 19 3f f8 	movh	r9,0x3ff8
8000a25c:	e0 a0 0e 90 	rcall	8000bf7c <__avr32_f64_sub>
8000a260:	e0 68 43 61 	mov	r8,17249
8000a264:	ea 18 63 6f 	orh	r8,0x636f
8000a268:	e0 69 87 a7 	mov	r9,34727
8000a26c:	ea 19 3f d2 	orh	r9,0x3fd2
8000a270:	e0 a0 0d 9a 	rcall	8000bda4 <__avr32_f64_mul>
8000a274:	e0 68 c8 b3 	mov	r8,51379
8000a278:	ea 18 8b 60 	orh	r8,0x8b60
8000a27c:	e0 69 8a 28 	mov	r9,35368
8000a280:	ea 19 3f c6 	orh	r9,0x3fc6
8000a284:	e0 a0 0f 4a 	rcall	8000c118 <__avr32_f64_add>
8000a288:	0a 9c       	mov	r12,r5
8000a28a:	14 90       	mov	r0,r10
8000a28c:	16 91       	mov	r1,r11
8000a28e:	e0 a0 0f e6 	rcall	8000c25a <__avr32_s32_to_f64>
8000a292:	e0 68 79 fb 	mov	r8,31227
8000a296:	ea 18 50 9f 	orh	r8,0x509f
8000a29a:	e0 69 44 13 	mov	r9,17427
8000a29e:	ea 19 3f d3 	orh	r9,0x3fd3
8000a2a2:	e0 a0 0d 81 	rcall	8000bda4 <__avr32_f64_mul>
8000a2a6:	14 98       	mov	r8,r10
8000a2a8:	16 99       	mov	r9,r11
8000a2aa:	00 9a       	mov	r10,r0
8000a2ac:	02 9b       	mov	r11,r1
8000a2ae:	e0 a0 0f 35 	rcall	8000c118 <__avr32_f64_add>
8000a2b2:	14 90       	mov	r0,r10
8000a2b4:	16 91       	mov	r1,r11
8000a2b6:	e0 a0 0f bb 	rcall	8000c22c <__avr32_f64_to_s32>
8000a2ba:	30 08       	mov	r8,0
8000a2bc:	18 96       	mov	r6,r12
8000a2be:	30 09       	mov	r9,0
8000a2c0:	00 9a       	mov	r10,r0
8000a2c2:	02 9b       	mov	r11,r1
8000a2c4:	e0 a0 10 82 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a2c8:	c0 c0       	breq	8000a2e0 <_dtoa_r+0x1f4>
8000a2ca:	0c 9c       	mov	r12,r6
8000a2cc:	e0 a0 0f c7 	rcall	8000c25a <__avr32_s32_to_f64>
8000a2d0:	14 98       	mov	r8,r10
8000a2d2:	16 99       	mov	r9,r11
8000a2d4:	00 9a       	mov	r10,r0
8000a2d6:	02 9b       	mov	r11,r1
8000a2d8:	e0 a0 10 31 	rcall	8000c33a <__avr32_f64_cmp_eq>
8000a2dc:	f7 b6 00 01 	subeq	r6,1
8000a2e0:	59 66       	cp.w	r6,22
8000a2e2:	e0 88 00 05 	brls	8000a2ec <_dtoa_r+0x200>
8000a2e6:	30 18       	mov	r8,1
8000a2e8:	51 48       	stdsp	sp[0x50],r8
8000a2ea:	c1 38       	rjmp	8000a310 <_dtoa_r+0x224>
8000a2ec:	fe c8 be 2c 	sub	r8,pc,-16852
8000a2f0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2f4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a2f8:	e0 a0 10 68 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a2fc:	f9 b4 00 00 	moveq	r4,0
8000a300:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a304:	f7 b6 01 01 	subne	r6,1
8000a308:	f9 bc 01 00 	movne	r12,0
8000a30c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a310:	41 90       	lddsp	r0,sp[0x64]
8000a312:	20 10       	sub	r0,1
8000a314:	0a 10       	sub	r0,r5
8000a316:	c0 46       	brmi	8000a31e <_dtoa_r+0x232>
8000a318:	50 40       	stdsp	sp[0x10],r0
8000a31a:	30 00       	mov	r0,0
8000a31c:	c0 48       	rjmp	8000a324 <_dtoa_r+0x238>
8000a31e:	30 0b       	mov	r11,0
8000a320:	5c 30       	neg	r0
8000a322:	50 4b       	stdsp	sp[0x10],r11
8000a324:	ec 02 11 00 	rsub	r2,r6,0
8000a328:	58 06       	cp.w	r6,0
8000a32a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a32e:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a332:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a336:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a33a:	f9 b2 04 00 	movge	r2,0
8000a33e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a342:	f9 b9 05 00 	movlt	r9,0
8000a346:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a34a:	40 c8       	lddsp	r8,sp[0x30]
8000a34c:	58 98       	cp.w	r8,9
8000a34e:	e0 8b 00 20 	brhi	8000a38e <_dtoa_r+0x2a2>
8000a352:	58 58       	cp.w	r8,5
8000a354:	f9 b4 0a 01 	movle	r4,1
8000a358:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a35c:	f7 b5 09 04 	subgt	r5,4
8000a360:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a364:	f9 b4 09 00 	movgt	r4,0
8000a368:	40 cc       	lddsp	r12,sp[0x30]
8000a36a:	58 3c       	cp.w	r12,3
8000a36c:	c2 d0       	breq	8000a3c6 <_dtoa_r+0x2da>
8000a36e:	e0 89 00 05 	brgt	8000a378 <_dtoa_r+0x28c>
8000a372:	58 2c       	cp.w	r12,2
8000a374:	c1 01       	brne	8000a394 <_dtoa_r+0x2a8>
8000a376:	c1 88       	rjmp	8000a3a6 <_dtoa_r+0x2ba>
8000a378:	40 cb       	lddsp	r11,sp[0x30]
8000a37a:	58 4b       	cp.w	r11,4
8000a37c:	c0 60       	breq	8000a388 <_dtoa_r+0x29c>
8000a37e:	58 5b       	cp.w	r11,5
8000a380:	c0 a1       	brne	8000a394 <_dtoa_r+0x2a8>
8000a382:	30 1a       	mov	r10,1
8000a384:	50 da       	stdsp	sp[0x34],r10
8000a386:	c2 28       	rjmp	8000a3ca <_dtoa_r+0x2de>
8000a388:	30 19       	mov	r9,1
8000a38a:	50 d9       	stdsp	sp[0x34],r9
8000a38c:	c0 f8       	rjmp	8000a3aa <_dtoa_r+0x2be>
8000a38e:	30 08       	mov	r8,0
8000a390:	30 14       	mov	r4,1
8000a392:	50 c8       	stdsp	sp[0x30],r8
8000a394:	3f f5       	mov	r5,-1
8000a396:	30 1c       	mov	r12,1
8000a398:	30 0b       	mov	r11,0
8000a39a:	50 95       	stdsp	sp[0x24],r5
8000a39c:	50 dc       	stdsp	sp[0x34],r12
8000a39e:	0a 91       	mov	r1,r5
8000a3a0:	31 28       	mov	r8,18
8000a3a2:	50 eb       	stdsp	sp[0x38],r11
8000a3a4:	c2 08       	rjmp	8000a3e4 <_dtoa_r+0x2f8>
8000a3a6:	30 0a       	mov	r10,0
8000a3a8:	50 da       	stdsp	sp[0x34],r10
8000a3aa:	40 e9       	lddsp	r9,sp[0x38]
8000a3ac:	58 09       	cp.w	r9,0
8000a3ae:	e0 89 00 07 	brgt	8000a3bc <_dtoa_r+0x2d0>
8000a3b2:	30 18       	mov	r8,1
8000a3b4:	50 98       	stdsp	sp[0x24],r8
8000a3b6:	10 91       	mov	r1,r8
8000a3b8:	50 e8       	stdsp	sp[0x38],r8
8000a3ba:	c1 58       	rjmp	8000a3e4 <_dtoa_r+0x2f8>
8000a3bc:	40 e5       	lddsp	r5,sp[0x38]
8000a3be:	50 95       	stdsp	sp[0x24],r5
8000a3c0:	0a 91       	mov	r1,r5
8000a3c2:	0a 98       	mov	r8,r5
8000a3c4:	c1 08       	rjmp	8000a3e4 <_dtoa_r+0x2f8>
8000a3c6:	30 0c       	mov	r12,0
8000a3c8:	50 dc       	stdsp	sp[0x34],r12
8000a3ca:	40 eb       	lddsp	r11,sp[0x38]
8000a3cc:	ec 0b 00 0b 	add	r11,r6,r11
8000a3d0:	50 9b       	stdsp	sp[0x24],r11
8000a3d2:	16 98       	mov	r8,r11
8000a3d4:	2f f8       	sub	r8,-1
8000a3d6:	58 08       	cp.w	r8,0
8000a3d8:	e0 89 00 05 	brgt	8000a3e2 <_dtoa_r+0x2f6>
8000a3dc:	10 91       	mov	r1,r8
8000a3de:	30 18       	mov	r8,1
8000a3e0:	c0 28       	rjmp	8000a3e4 <_dtoa_r+0x2f8>
8000a3e2:	10 91       	mov	r1,r8
8000a3e4:	30 09       	mov	r9,0
8000a3e6:	6e 9a       	ld.w	r10,r7[0x24]
8000a3e8:	95 19       	st.w	r10[0x4],r9
8000a3ea:	30 49       	mov	r9,4
8000a3ec:	c0 68       	rjmp	8000a3f8 <_dtoa_r+0x30c>
8000a3ee:	d7 03       	nop
8000a3f0:	6a 1a       	ld.w	r10,r5[0x4]
8000a3f2:	a1 79       	lsl	r9,0x1
8000a3f4:	2f fa       	sub	r10,-1
8000a3f6:	8b 1a       	st.w	r5[0x4],r10
8000a3f8:	6e 95       	ld.w	r5,r7[0x24]
8000a3fa:	f2 ca ff ec 	sub	r10,r9,-20
8000a3fe:	10 3a       	cp.w	r10,r8
8000a400:	fe 98 ff f8 	brls	8000a3f0 <_dtoa_r+0x304>
8000a404:	6a 1b       	ld.w	r11,r5[0x4]
8000a406:	0e 9c       	mov	r12,r7
8000a408:	e0 a0 09 44 	rcall	8000b690 <_Balloc>
8000a40c:	58 e1       	cp.w	r1,14
8000a40e:	5f 88       	srls	r8
8000a410:	8b 0c       	st.w	r5[0x0],r12
8000a412:	f1 e4 00 04 	and	r4,r8,r4
8000a416:	6e 98       	ld.w	r8,r7[0x24]
8000a418:	70 08       	ld.w	r8,r8[0x0]
8000a41a:	50 88       	stdsp	sp[0x20],r8
8000a41c:	e0 80 01 82 	breq	8000a720 <_dtoa_r+0x634>
8000a420:	58 06       	cp.w	r6,0
8000a422:	e0 8a 00 43 	brle	8000a4a8 <_dtoa_r+0x3bc>
8000a426:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a42a:	fe c8 bf 6a 	sub	r8,pc,-16534
8000a42e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a432:	fa e5 00 18 	st.d	sp[24],r4
8000a436:	ec 04 14 04 	asr	r4,r6,0x4
8000a43a:	ed b4 00 04 	bld	r4,0x4
8000a43e:	c0 30       	breq	8000a444 <_dtoa_r+0x358>
8000a440:	30 25       	mov	r5,2
8000a442:	c1 08       	rjmp	8000a462 <_dtoa_r+0x376>
8000a444:	fe c8 be bc 	sub	r8,pc,-16708
8000a448:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a44c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a450:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a454:	e0 a0 0f ee 	rcall	8000c430 <__avr32_f64_div>
8000a458:	30 35       	mov	r5,3
8000a45a:	14 98       	mov	r8,r10
8000a45c:	16 99       	mov	r9,r11
8000a45e:	fa e9 00 08 	st.d	sp[8],r8
8000a462:	fe cc be da 	sub	r12,pc,-16678
8000a466:	50 a3       	stdsp	sp[0x28],r3
8000a468:	0c 93       	mov	r3,r6
8000a46a:	18 96       	mov	r6,r12
8000a46c:	c0 f8       	rjmp	8000a48a <_dtoa_r+0x39e>
8000a46e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a472:	ed b4 00 00 	bld	r4,0x0
8000a476:	c0 81       	brne	8000a486 <_dtoa_r+0x39a>
8000a478:	ec e8 00 00 	ld.d	r8,r6[0]
8000a47c:	2f f5       	sub	r5,-1
8000a47e:	e0 a0 0c 93 	rcall	8000bda4 <__avr32_f64_mul>
8000a482:	fa eb 00 18 	st.d	sp[24],r10
8000a486:	a1 54       	asr	r4,0x1
8000a488:	2f 86       	sub	r6,-8
8000a48a:	58 04       	cp.w	r4,0
8000a48c:	cf 11       	brne	8000a46e <_dtoa_r+0x382>
8000a48e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a492:	fa ea 00 08 	ld.d	r10,sp[8]
8000a496:	06 96       	mov	r6,r3
8000a498:	e0 a0 0f cc 	rcall	8000c430 <__avr32_f64_div>
8000a49c:	40 a3       	lddsp	r3,sp[0x28]
8000a49e:	14 98       	mov	r8,r10
8000a4a0:	16 99       	mov	r9,r11
8000a4a2:	fa e9 00 08 	st.d	sp[8],r8
8000a4a6:	c2 f8       	rjmp	8000a504 <_dtoa_r+0x418>
8000a4a8:	ec 08 11 00 	rsub	r8,r6,0
8000a4ac:	c0 31       	brne	8000a4b2 <_dtoa_r+0x3c6>
8000a4ae:	30 25       	mov	r5,2
8000a4b0:	c2 a8       	rjmp	8000a504 <_dtoa_r+0x418>
8000a4b2:	fe cc bf 2a 	sub	r12,pc,-16598
8000a4b6:	f0 04 14 04 	asr	r4,r8,0x4
8000a4ba:	50 1c       	stdsp	sp[0x4],r12
8000a4bc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a4c0:	fe c9 c0 00 	sub	r9,pc,-16384
8000a4c4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4c8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a4cc:	e0 a0 0c 6c 	rcall	8000bda4 <__avr32_f64_mul>
8000a4d0:	40 1c       	lddsp	r12,sp[0x4]
8000a4d2:	50 63       	stdsp	sp[0x18],r3
8000a4d4:	30 25       	mov	r5,2
8000a4d6:	0c 93       	mov	r3,r6
8000a4d8:	fa eb 00 08 	st.d	sp[8],r10
8000a4dc:	18 96       	mov	r6,r12
8000a4de:	c0 f8       	rjmp	8000a4fc <_dtoa_r+0x410>
8000a4e0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4e4:	ed b4 00 00 	bld	r4,0x0
8000a4e8:	c0 81       	brne	8000a4f8 <_dtoa_r+0x40c>
8000a4ea:	ec e8 00 00 	ld.d	r8,r6[0]
8000a4ee:	2f f5       	sub	r5,-1
8000a4f0:	e0 a0 0c 5a 	rcall	8000bda4 <__avr32_f64_mul>
8000a4f4:	fa eb 00 08 	st.d	sp[8],r10
8000a4f8:	a1 54       	asr	r4,0x1
8000a4fa:	2f 86       	sub	r6,-8
8000a4fc:	58 04       	cp.w	r4,0
8000a4fe:	cf 11       	brne	8000a4e0 <_dtoa_r+0x3f4>
8000a500:	06 96       	mov	r6,r3
8000a502:	40 63       	lddsp	r3,sp[0x18]
8000a504:	41 4a       	lddsp	r10,sp[0x50]
8000a506:	58 0a       	cp.w	r10,0
8000a508:	c2 a0       	breq	8000a55c <_dtoa_r+0x470>
8000a50a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a50e:	58 01       	cp.w	r1,0
8000a510:	5f 94       	srgt	r4
8000a512:	fa e9 00 18 	st.d	sp[24],r8
8000a516:	30 08       	mov	r8,0
8000a518:	fc 19 3f f0 	movh	r9,0x3ff0
8000a51c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a520:	e0 a0 0f 54 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a524:	f9 bc 00 00 	moveq	r12,0
8000a528:	f9 bc 01 01 	movne	r12,1
8000a52c:	e9 ec 00 0c 	and	r12,r4,r12
8000a530:	c1 60       	breq	8000a55c <_dtoa_r+0x470>
8000a532:	40 98       	lddsp	r8,sp[0x24]
8000a534:	58 08       	cp.w	r8,0
8000a536:	e0 8a 00 f1 	brle	8000a718 <_dtoa_r+0x62c>
8000a53a:	30 08       	mov	r8,0
8000a53c:	fc 19 40 24 	movh	r9,0x4024
8000a540:	ec c4 00 01 	sub	r4,r6,1
8000a544:	fa ea 00 18 	ld.d	r10,sp[24]
8000a548:	2f f5       	sub	r5,-1
8000a54a:	50 64       	stdsp	sp[0x18],r4
8000a54c:	e0 a0 0c 2c 	rcall	8000bda4 <__avr32_f64_mul>
8000a550:	40 94       	lddsp	r4,sp[0x24]
8000a552:	14 98       	mov	r8,r10
8000a554:	16 99       	mov	r9,r11
8000a556:	fa e9 00 08 	st.d	sp[8],r8
8000a55a:	c0 38       	rjmp	8000a560 <_dtoa_r+0x474>
8000a55c:	50 66       	stdsp	sp[0x18],r6
8000a55e:	02 94       	mov	r4,r1
8000a560:	0a 9c       	mov	r12,r5
8000a562:	e0 a0 0e 7c 	rcall	8000c25a <__avr32_s32_to_f64>
8000a566:	fa e8 00 08 	ld.d	r8,sp[8]
8000a56a:	e0 a0 0c 1d 	rcall	8000bda4 <__avr32_f64_mul>
8000a56e:	30 08       	mov	r8,0
8000a570:	fc 19 40 1c 	movh	r9,0x401c
8000a574:	e0 a0 0d d2 	rcall	8000c118 <__avr32_f64_add>
8000a578:	14 98       	mov	r8,r10
8000a57a:	16 99       	mov	r9,r11
8000a57c:	fa e9 00 28 	st.d	sp[40],r8
8000a580:	fc 18 fc c0 	movh	r8,0xfcc0
8000a584:	40 a5       	lddsp	r5,sp[0x28]
8000a586:	10 05       	add	r5,r8
8000a588:	50 a5       	stdsp	sp[0x28],r5
8000a58a:	58 04       	cp.w	r4,0
8000a58c:	c2 11       	brne	8000a5ce <_dtoa_r+0x4e2>
8000a58e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a592:	30 08       	mov	r8,0
8000a594:	fc 19 40 14 	movh	r9,0x4014
8000a598:	e0 a0 0c f2 	rcall	8000bf7c <__avr32_f64_sub>
8000a59c:	40 bc       	lddsp	r12,sp[0x2c]
8000a59e:	fa eb 00 08 	st.d	sp[8],r10
8000a5a2:	14 98       	mov	r8,r10
8000a5a4:	16 99       	mov	r9,r11
8000a5a6:	18 9a       	mov	r10,r12
8000a5a8:	0a 9b       	mov	r11,r5
8000a5aa:	e0 a0 0f 0f 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a5ae:	e0 81 02 54 	brne	8000aa56 <_dtoa_r+0x96a>
8000a5b2:	0a 98       	mov	r8,r5
8000a5b4:	40 b9       	lddsp	r9,sp[0x2c]
8000a5b6:	ee 18 80 00 	eorh	r8,0x8000
8000a5ba:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5be:	10 95       	mov	r5,r8
8000a5c0:	12 98       	mov	r8,r9
8000a5c2:	0a 99       	mov	r9,r5
8000a5c4:	e0 a0 0f 02 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a5c8:	e0 81 02 3e 	brne	8000aa44 <_dtoa_r+0x958>
8000a5cc:	ca 68       	rjmp	8000a718 <_dtoa_r+0x62c>
8000a5ce:	fe c9 c1 0e 	sub	r9,pc,-16114
8000a5d2:	e8 c8 00 01 	sub	r8,r4,1
8000a5d6:	40 d5       	lddsp	r5,sp[0x34]
8000a5d8:	58 05       	cp.w	r5,0
8000a5da:	c4 f0       	breq	8000a678 <_dtoa_r+0x58c>
8000a5dc:	30 0c       	mov	r12,0
8000a5de:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a5e2:	51 3c       	stdsp	sp[0x4c],r12
8000a5e4:	30 0a       	mov	r10,0
8000a5e6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a5ea:	e0 a0 0f 23 	rcall	8000c430 <__avr32_f64_div>
8000a5ee:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5f2:	40 85       	lddsp	r5,sp[0x20]
8000a5f4:	e0 a0 0c c4 	rcall	8000bf7c <__avr32_f64_sub>
8000a5f8:	fa eb 00 28 	st.d	sp[40],r10
8000a5fc:	fa ea 00 08 	ld.d	r10,sp[8]
8000a600:	e0 a0 0e 16 	rcall	8000c22c <__avr32_f64_to_s32>
8000a604:	51 6c       	stdsp	sp[0x58],r12
8000a606:	e0 a0 0e 2a 	rcall	8000c25a <__avr32_s32_to_f64>
8000a60a:	14 98       	mov	r8,r10
8000a60c:	16 99       	mov	r9,r11
8000a60e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a612:	e0 a0 0c b5 	rcall	8000bf7c <__avr32_f64_sub>
8000a616:	fa eb 00 08 	st.d	sp[8],r10
8000a61a:	41 68       	lddsp	r8,sp[0x58]
8000a61c:	2d 08       	sub	r8,-48
8000a61e:	0a c8       	st.b	r5++,r8
8000a620:	41 39       	lddsp	r9,sp[0x4c]
8000a622:	2f f9       	sub	r9,-1
8000a624:	51 39       	stdsp	sp[0x4c],r9
8000a626:	fa e8 00 28 	ld.d	r8,sp[40]
8000a62a:	e0 a0 0e cf 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a62e:	e0 81 03 39 	brne	8000aca0 <_dtoa_r+0xbb4>
8000a632:	fa e8 00 08 	ld.d	r8,sp[8]
8000a636:	30 0a       	mov	r10,0
8000a638:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a63c:	e0 a0 0c a0 	rcall	8000bf7c <__avr32_f64_sub>
8000a640:	fa e8 00 28 	ld.d	r8,sp[40]
8000a644:	e0 a0 0e c2 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a648:	fa ea 00 28 	ld.d	r10,sp[40]
8000a64c:	30 08       	mov	r8,0
8000a64e:	fc 19 40 24 	movh	r9,0x4024
8000a652:	e0 81 00 da 	brne	8000a806 <_dtoa_r+0x71a>
8000a656:	41 3c       	lddsp	r12,sp[0x4c]
8000a658:	08 3c       	cp.w	r12,r4
8000a65a:	c5 f4       	brge	8000a718 <_dtoa_r+0x62c>
8000a65c:	e0 a0 0b a4 	rcall	8000bda4 <__avr32_f64_mul>
8000a660:	30 08       	mov	r8,0
8000a662:	fa eb 00 28 	st.d	sp[40],r10
8000a666:	fc 19 40 24 	movh	r9,0x4024
8000a66a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a66e:	e0 a0 0b 9b 	rcall	8000bda4 <__avr32_f64_mul>
8000a672:	fa eb 00 08 	st.d	sp[8],r10
8000a676:	cc 3b       	rjmp	8000a5fc <_dtoa_r+0x510>
8000a678:	40 85       	lddsp	r5,sp[0x20]
8000a67a:	08 05       	add	r5,r4
8000a67c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a680:	51 35       	stdsp	sp[0x4c],r5
8000a682:	fa e8 00 28 	ld.d	r8,sp[40]
8000a686:	40 85       	lddsp	r5,sp[0x20]
8000a688:	e0 a0 0b 8e 	rcall	8000bda4 <__avr32_f64_mul>
8000a68c:	fa eb 00 28 	st.d	sp[40],r10
8000a690:	fa ea 00 08 	ld.d	r10,sp[8]
8000a694:	e0 a0 0d cc 	rcall	8000c22c <__avr32_f64_to_s32>
8000a698:	51 6c       	stdsp	sp[0x58],r12
8000a69a:	e0 a0 0d e0 	rcall	8000c25a <__avr32_s32_to_f64>
8000a69e:	14 98       	mov	r8,r10
8000a6a0:	16 99       	mov	r9,r11
8000a6a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6a6:	e0 a0 0c 6b 	rcall	8000bf7c <__avr32_f64_sub>
8000a6aa:	fa eb 00 08 	st.d	sp[8],r10
8000a6ae:	41 68       	lddsp	r8,sp[0x58]
8000a6b0:	2d 08       	sub	r8,-48
8000a6b2:	0a c8       	st.b	r5++,r8
8000a6b4:	41 3c       	lddsp	r12,sp[0x4c]
8000a6b6:	18 35       	cp.w	r5,r12
8000a6b8:	c2 81       	brne	8000a708 <_dtoa_r+0x61c>
8000a6ba:	30 08       	mov	r8,0
8000a6bc:	fc 19 3f e0 	movh	r9,0x3fe0
8000a6c0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a6c4:	e0 a0 0d 2a 	rcall	8000c118 <__avr32_f64_add>
8000a6c8:	40 85       	lddsp	r5,sp[0x20]
8000a6ca:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6ce:	08 05       	add	r5,r4
8000a6d0:	e0 a0 0e 7c 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a6d4:	e0 81 00 99 	brne	8000a806 <_dtoa_r+0x71a>
8000a6d8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6dc:	30 0a       	mov	r10,0
8000a6de:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a6e2:	e0 a0 0c 4d 	rcall	8000bf7c <__avr32_f64_sub>
8000a6e6:	14 98       	mov	r8,r10
8000a6e8:	16 99       	mov	r9,r11
8000a6ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6ee:	e0 a0 0e 6d 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a6f2:	c1 30       	breq	8000a718 <_dtoa_r+0x62c>
8000a6f4:	33 09       	mov	r9,48
8000a6f6:	0a 98       	mov	r8,r5
8000a6f8:	11 7a       	ld.ub	r10,--r8
8000a6fa:	f2 0a 18 00 	cp.b	r10,r9
8000a6fe:	e0 81 02 d1 	brne	8000aca0 <_dtoa_r+0xbb4>
8000a702:	10 95       	mov	r5,r8
8000a704:	cf 9b       	rjmp	8000a6f6 <_dtoa_r+0x60a>
8000a706:	d7 03       	nop
8000a708:	30 08       	mov	r8,0
8000a70a:	fc 19 40 24 	movh	r9,0x4024
8000a70e:	e0 a0 0b 4b 	rcall	8000bda4 <__avr32_f64_mul>
8000a712:	fa eb 00 08 	st.d	sp[8],r10
8000a716:	cb db       	rjmp	8000a690 <_dtoa_r+0x5a4>
8000a718:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a71c:	fa eb 00 08 	st.d	sp[8],r10
8000a720:	58 e6       	cp.w	r6,14
8000a722:	5f ab       	srle	r11
8000a724:	41 8a       	lddsp	r10,sp[0x60]
8000a726:	30 08       	mov	r8,0
8000a728:	f4 09 11 ff 	rsub	r9,r10,-1
8000a72c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a730:	f0 09 18 00 	cp.b	r9,r8
8000a734:	e0 80 00 82 	breq	8000a838 <_dtoa_r+0x74c>
8000a738:	40 ea       	lddsp	r10,sp[0x38]
8000a73a:	58 01       	cp.w	r1,0
8000a73c:	5f a9       	srle	r9
8000a73e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a742:	fe ca c2 82 	sub	r10,pc,-15742
8000a746:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a74a:	fa e5 00 10 	st.d	sp[16],r4
8000a74e:	f0 09 18 00 	cp.b	r9,r8
8000a752:	c1 40       	breq	8000a77a <_dtoa_r+0x68e>
8000a754:	58 01       	cp.w	r1,0
8000a756:	e0 81 01 77 	brne	8000aa44 <_dtoa_r+0x958>
8000a75a:	30 08       	mov	r8,0
8000a75c:	fc 19 40 14 	movh	r9,0x4014
8000a760:	08 9a       	mov	r10,r4
8000a762:	0a 9b       	mov	r11,r5
8000a764:	e0 a0 0b 20 	rcall	8000bda4 <__avr32_f64_mul>
8000a768:	fa e8 00 08 	ld.d	r8,sp[8]
8000a76c:	e0 a0 0d fa 	rcall	8000c360 <__avr32_f64_cmp_ge>
8000a770:	e0 81 01 6a 	brne	8000aa44 <_dtoa_r+0x958>
8000a774:	02 92       	mov	r2,r1
8000a776:	e0 8f 01 72 	bral	8000aa5a <_dtoa_r+0x96e>
8000a77a:	40 85       	lddsp	r5,sp[0x20]
8000a77c:	30 14       	mov	r4,1
8000a77e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a782:	fa ea 00 08 	ld.d	r10,sp[8]
8000a786:	e0 a0 0e 55 	rcall	8000c430 <__avr32_f64_div>
8000a78a:	e0 a0 0d 51 	rcall	8000c22c <__avr32_f64_to_s32>
8000a78e:	18 92       	mov	r2,r12
8000a790:	e0 a0 0d 65 	rcall	8000c25a <__avr32_s32_to_f64>
8000a794:	fa e8 00 10 	ld.d	r8,sp[16]
8000a798:	e0 a0 0b 06 	rcall	8000bda4 <__avr32_f64_mul>
8000a79c:	14 98       	mov	r8,r10
8000a79e:	16 99       	mov	r9,r11
8000a7a0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7a4:	e0 a0 0b ec 	rcall	8000bf7c <__avr32_f64_sub>
8000a7a8:	fa eb 00 08 	st.d	sp[8],r10
8000a7ac:	e4 c8 ff d0 	sub	r8,r2,-48
8000a7b0:	0a c8       	st.b	r5++,r8
8000a7b2:	fc 19 40 24 	movh	r9,0x4024
8000a7b6:	30 08       	mov	r8,0
8000a7b8:	02 34       	cp.w	r4,r1
8000a7ba:	c3 31       	brne	8000a820 <_dtoa_r+0x734>
8000a7bc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7c0:	e0 a0 0c ac 	rcall	8000c118 <__avr32_f64_add>
8000a7c4:	16 91       	mov	r1,r11
8000a7c6:	14 90       	mov	r0,r10
8000a7c8:	14 98       	mov	r8,r10
8000a7ca:	02 99       	mov	r9,r1
8000a7cc:	fa ea 00 10 	ld.d	r10,sp[16]
8000a7d0:	e0 a0 0d fc 	rcall	8000c3c8 <__avr32_f64_cmp_lt>
8000a7d4:	c1 a1       	brne	8000a808 <_dtoa_r+0x71c>
8000a7d6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a7da:	00 9a       	mov	r10,r0
8000a7dc:	02 9b       	mov	r11,r1
8000a7de:	e0 a0 0d ae 	rcall	8000c33a <__avr32_f64_cmp_eq>
8000a7e2:	e0 80 02 5e 	breq	8000ac9e <_dtoa_r+0xbb2>
8000a7e6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a7ea:	c0 f1       	brne	8000a808 <_dtoa_r+0x71c>
8000a7ec:	e0 8f 02 59 	bral	8000ac9e <_dtoa_r+0xbb2>
8000a7f0:	40 8a       	lddsp	r10,sp[0x20]
8000a7f2:	14 38       	cp.w	r8,r10
8000a7f4:	c0 30       	breq	8000a7fa <_dtoa_r+0x70e>
8000a7f6:	10 95       	mov	r5,r8
8000a7f8:	c0 98       	rjmp	8000a80a <_dtoa_r+0x71e>
8000a7fa:	33 08       	mov	r8,48
8000a7fc:	40 89       	lddsp	r9,sp[0x20]
8000a7fe:	2f f6       	sub	r6,-1
8000a800:	b2 88       	st.b	r9[0x0],r8
8000a802:	40 88       	lddsp	r8,sp[0x20]
8000a804:	c0 88       	rjmp	8000a814 <_dtoa_r+0x728>
8000a806:	40 66       	lddsp	r6,sp[0x18]
8000a808:	33 99       	mov	r9,57
8000a80a:	0a 98       	mov	r8,r5
8000a80c:	11 7a       	ld.ub	r10,--r8
8000a80e:	f2 0a 18 00 	cp.b	r10,r9
8000a812:	ce f0       	breq	8000a7f0 <_dtoa_r+0x704>
8000a814:	50 66       	stdsp	sp[0x18],r6
8000a816:	11 89       	ld.ub	r9,r8[0x0]
8000a818:	2f f9       	sub	r9,-1
8000a81a:	b0 89       	st.b	r8[0x0],r9
8000a81c:	e0 8f 02 42 	bral	8000aca0 <_dtoa_r+0xbb4>
8000a820:	e0 a0 0a c2 	rcall	8000bda4 <__avr32_f64_mul>
8000a824:	2f f4       	sub	r4,-1
8000a826:	fa eb 00 08 	st.d	sp[8],r10
8000a82a:	30 08       	mov	r8,0
8000a82c:	30 09       	mov	r9,0
8000a82e:	e0 a0 0d 86 	rcall	8000c33a <__avr32_f64_cmp_eq>
8000a832:	ca 60       	breq	8000a77e <_dtoa_r+0x692>
8000a834:	e0 8f 02 35 	bral	8000ac9e <_dtoa_r+0xbb2>
8000a838:	40 d8       	lddsp	r8,sp[0x34]
8000a83a:	58 08       	cp.w	r8,0
8000a83c:	c0 51       	brne	8000a846 <_dtoa_r+0x75a>
8000a83e:	04 98       	mov	r8,r2
8000a840:	00 95       	mov	r5,r0
8000a842:	40 d4       	lddsp	r4,sp[0x34]
8000a844:	c3 78       	rjmp	8000a8b2 <_dtoa_r+0x7c6>
8000a846:	40 c5       	lddsp	r5,sp[0x30]
8000a848:	58 15       	cp.w	r5,1
8000a84a:	e0 89 00 0f 	brgt	8000a868 <_dtoa_r+0x77c>
8000a84e:	41 74       	lddsp	r4,sp[0x5c]
8000a850:	58 04       	cp.w	r4,0
8000a852:	c0 40       	breq	8000a85a <_dtoa_r+0x76e>
8000a854:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a858:	c0 48       	rjmp	8000a860 <_dtoa_r+0x774>
8000a85a:	41 99       	lddsp	r9,sp[0x64]
8000a85c:	f2 09 11 36 	rsub	r9,r9,54
8000a860:	04 98       	mov	r8,r2
8000a862:	00 95       	mov	r5,r0
8000a864:	c1 c8       	rjmp	8000a89c <_dtoa_r+0x7b0>
8000a866:	d7 03       	nop
8000a868:	e2 c8 00 01 	sub	r8,r1,1
8000a86c:	58 01       	cp.w	r1,0
8000a86e:	e0 05 17 40 	movge	r5,r0
8000a872:	e2 09 17 40 	movge	r9,r1
8000a876:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a87a:	f9 b9 05 00 	movlt	r9,0
8000a87e:	10 32       	cp.w	r2,r8
8000a880:	e5 d8 e4 18 	subge	r8,r2,r8
8000a884:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a888:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a88c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a890:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a894:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a898:	f9 b8 05 00 	movlt	r8,0
8000a89c:	40 4b       	lddsp	r11,sp[0x10]
8000a89e:	12 0b       	add	r11,r9
8000a8a0:	50 08       	stdsp	sp[0x0],r8
8000a8a2:	50 4b       	stdsp	sp[0x10],r11
8000a8a4:	12 00       	add	r0,r9
8000a8a6:	30 1b       	mov	r11,1
8000a8a8:	0e 9c       	mov	r12,r7
8000a8aa:	e0 a0 08 a7 	rcall	8000b9f8 <__i2b>
8000a8ae:	40 08       	lddsp	r8,sp[0x0]
8000a8b0:	18 94       	mov	r4,r12
8000a8b2:	40 4a       	lddsp	r10,sp[0x10]
8000a8b4:	58 05       	cp.w	r5,0
8000a8b6:	5f 99       	srgt	r9
8000a8b8:	58 0a       	cp.w	r10,0
8000a8ba:	5f 9a       	srgt	r10
8000a8bc:	f5 e9 00 09 	and	r9,r10,r9
8000a8c0:	c0 80       	breq	8000a8d0 <_dtoa_r+0x7e4>
8000a8c2:	40 4c       	lddsp	r12,sp[0x10]
8000a8c4:	f8 05 0d 49 	min	r9,r12,r5
8000a8c8:	12 1c       	sub	r12,r9
8000a8ca:	12 10       	sub	r0,r9
8000a8cc:	50 4c       	stdsp	sp[0x10],r12
8000a8ce:	12 15       	sub	r5,r9
8000a8d0:	58 02       	cp.w	r2,0
8000a8d2:	e0 8a 00 27 	brle	8000a920 <_dtoa_r+0x834>
8000a8d6:	40 db       	lddsp	r11,sp[0x34]
8000a8d8:	58 0b       	cp.w	r11,0
8000a8da:	c1 d0       	breq	8000a914 <_dtoa_r+0x828>
8000a8dc:	58 08       	cp.w	r8,0
8000a8de:	e0 8a 00 17 	brle	8000a90c <_dtoa_r+0x820>
8000a8e2:	10 9a       	mov	r10,r8
8000a8e4:	50 08       	stdsp	sp[0x0],r8
8000a8e6:	08 9b       	mov	r11,r4
8000a8e8:	0e 9c       	mov	r12,r7
8000a8ea:	e0 a0 08 cd 	rcall	8000ba84 <__pow5mult>
8000a8ee:	06 9a       	mov	r10,r3
8000a8f0:	18 9b       	mov	r11,r12
8000a8f2:	18 94       	mov	r4,r12
8000a8f4:	0e 9c       	mov	r12,r7
8000a8f6:	e0 a0 08 01 	rcall	8000b8f8 <__multiply>
8000a8fa:	18 99       	mov	r9,r12
8000a8fc:	06 9b       	mov	r11,r3
8000a8fe:	50 19       	stdsp	sp[0x4],r9
8000a900:	0e 9c       	mov	r12,r7
8000a902:	e0 a0 06 ad 	rcall	8000b65c <_Bfree>
8000a906:	40 19       	lddsp	r9,sp[0x4]
8000a908:	40 08       	lddsp	r8,sp[0x0]
8000a90a:	12 93       	mov	r3,r9
8000a90c:	e4 08 01 0a 	sub	r10,r2,r8
8000a910:	c0 80       	breq	8000a920 <_dtoa_r+0x834>
8000a912:	c0 28       	rjmp	8000a916 <_dtoa_r+0x82a>
8000a914:	04 9a       	mov	r10,r2
8000a916:	06 9b       	mov	r11,r3
8000a918:	0e 9c       	mov	r12,r7
8000a91a:	e0 a0 08 b5 	rcall	8000ba84 <__pow5mult>
8000a91e:	18 93       	mov	r3,r12
8000a920:	30 1b       	mov	r11,1
8000a922:	0e 9c       	mov	r12,r7
8000a924:	e0 a0 08 6a 	rcall	8000b9f8 <__i2b>
8000a928:	41 1a       	lddsp	r10,sp[0x44]
8000a92a:	18 92       	mov	r2,r12
8000a92c:	58 0a       	cp.w	r10,0
8000a92e:	e0 8a 00 07 	brle	8000a93c <_dtoa_r+0x850>
8000a932:	18 9b       	mov	r11,r12
8000a934:	0e 9c       	mov	r12,r7
8000a936:	e0 a0 08 a7 	rcall	8000ba84 <__pow5mult>
8000a93a:	18 92       	mov	r2,r12
8000a93c:	40 c9       	lddsp	r9,sp[0x30]
8000a93e:	58 19       	cp.w	r9,1
8000a940:	e0 89 00 14 	brgt	8000a968 <_dtoa_r+0x87c>
8000a944:	40 38       	lddsp	r8,sp[0xc]
8000a946:	58 08       	cp.w	r8,0
8000a948:	c1 01       	brne	8000a968 <_dtoa_r+0x87c>
8000a94a:	40 29       	lddsp	r9,sp[0x8]
8000a94c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a950:	c0 c1       	brne	8000a968 <_dtoa_r+0x87c>
8000a952:	12 98       	mov	r8,r9
8000a954:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a958:	c0 80       	breq	8000a968 <_dtoa_r+0x87c>
8000a95a:	40 4c       	lddsp	r12,sp[0x10]
8000a95c:	30 1b       	mov	r11,1
8000a95e:	2f fc       	sub	r12,-1
8000a960:	2f f0       	sub	r0,-1
8000a962:	50 4c       	stdsp	sp[0x10],r12
8000a964:	50 6b       	stdsp	sp[0x18],r11
8000a966:	c0 38       	rjmp	8000a96c <_dtoa_r+0x880>
8000a968:	30 0a       	mov	r10,0
8000a96a:	50 6a       	stdsp	sp[0x18],r10
8000a96c:	41 19       	lddsp	r9,sp[0x44]
8000a96e:	58 09       	cp.w	r9,0
8000a970:	c0 31       	brne	8000a976 <_dtoa_r+0x88a>
8000a972:	30 1c       	mov	r12,1
8000a974:	c0 98       	rjmp	8000a986 <_dtoa_r+0x89a>
8000a976:	64 48       	ld.w	r8,r2[0x10]
8000a978:	2f c8       	sub	r8,-4
8000a97a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a97e:	e0 a0 05 df 	rcall	8000b53c <__hi0bits>
8000a982:	f8 0c 11 20 	rsub	r12,r12,32
8000a986:	40 4b       	lddsp	r11,sp[0x10]
8000a988:	f8 0b 00 08 	add	r8,r12,r11
8000a98c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a990:	c0 c0       	breq	8000a9a8 <_dtoa_r+0x8bc>
8000a992:	f0 08 11 20 	rsub	r8,r8,32
8000a996:	58 48       	cp.w	r8,4
8000a998:	e0 8a 00 06 	brle	8000a9a4 <_dtoa_r+0x8b8>
8000a99c:	20 48       	sub	r8,4
8000a99e:	10 0b       	add	r11,r8
8000a9a0:	50 4b       	stdsp	sp[0x10],r11
8000a9a2:	c0 78       	rjmp	8000a9b0 <_dtoa_r+0x8c4>
8000a9a4:	58 48       	cp.w	r8,4
8000a9a6:	c0 70       	breq	8000a9b4 <_dtoa_r+0x8c8>
8000a9a8:	40 4a       	lddsp	r10,sp[0x10]
8000a9aa:	2e 48       	sub	r8,-28
8000a9ac:	10 0a       	add	r10,r8
8000a9ae:	50 4a       	stdsp	sp[0x10],r10
8000a9b0:	10 00       	add	r0,r8
8000a9b2:	10 05       	add	r5,r8
8000a9b4:	58 00       	cp.w	r0,0
8000a9b6:	e0 8a 00 08 	brle	8000a9c6 <_dtoa_r+0x8da>
8000a9ba:	06 9b       	mov	r11,r3
8000a9bc:	00 9a       	mov	r10,r0
8000a9be:	0e 9c       	mov	r12,r7
8000a9c0:	e0 a0 07 58 	rcall	8000b870 <__lshift>
8000a9c4:	18 93       	mov	r3,r12
8000a9c6:	40 49       	lddsp	r9,sp[0x10]
8000a9c8:	58 09       	cp.w	r9,0
8000a9ca:	e0 8a 00 08 	brle	8000a9da <_dtoa_r+0x8ee>
8000a9ce:	04 9b       	mov	r11,r2
8000a9d0:	12 9a       	mov	r10,r9
8000a9d2:	0e 9c       	mov	r12,r7
8000a9d4:	e0 a0 07 4e 	rcall	8000b870 <__lshift>
8000a9d8:	18 92       	mov	r2,r12
8000a9da:	41 48       	lddsp	r8,sp[0x50]
8000a9dc:	58 08       	cp.w	r8,0
8000a9de:	c1 b0       	breq	8000aa14 <_dtoa_r+0x928>
8000a9e0:	04 9b       	mov	r11,r2
8000a9e2:	06 9c       	mov	r12,r3
8000a9e4:	e0 a0 06 23 	rcall	8000b62a <__mcmp>
8000a9e8:	c1 64       	brge	8000aa14 <_dtoa_r+0x928>
8000a9ea:	06 9b       	mov	r11,r3
8000a9ec:	30 09       	mov	r9,0
8000a9ee:	30 aa       	mov	r10,10
8000a9f0:	0e 9c       	mov	r12,r7
8000a9f2:	e0 a0 08 0b 	rcall	8000ba08 <__multadd>
8000a9f6:	20 16       	sub	r6,1
8000a9f8:	18 93       	mov	r3,r12
8000a9fa:	40 dc       	lddsp	r12,sp[0x34]
8000a9fc:	58 0c       	cp.w	r12,0
8000a9fe:	c0 31       	brne	8000aa04 <_dtoa_r+0x918>
8000aa00:	40 91       	lddsp	r1,sp[0x24]
8000aa02:	c0 98       	rjmp	8000aa14 <_dtoa_r+0x928>
8000aa04:	08 9b       	mov	r11,r4
8000aa06:	40 91       	lddsp	r1,sp[0x24]
8000aa08:	30 09       	mov	r9,0
8000aa0a:	30 aa       	mov	r10,10
8000aa0c:	0e 9c       	mov	r12,r7
8000aa0e:	e0 a0 07 fd 	rcall	8000ba08 <__multadd>
8000aa12:	18 94       	mov	r4,r12
8000aa14:	58 01       	cp.w	r1,0
8000aa16:	5f a9       	srle	r9
8000aa18:	40 cb       	lddsp	r11,sp[0x30]
8000aa1a:	58 2b       	cp.w	r11,2
8000aa1c:	5f 98       	srgt	r8
8000aa1e:	f3 e8 00 08 	and	r8,r9,r8
8000aa22:	c2 50       	breq	8000aa6c <_dtoa_r+0x980>
8000aa24:	58 01       	cp.w	r1,0
8000aa26:	c1 11       	brne	8000aa48 <_dtoa_r+0x95c>
8000aa28:	04 9b       	mov	r11,r2
8000aa2a:	02 99       	mov	r9,r1
8000aa2c:	30 5a       	mov	r10,5
8000aa2e:	0e 9c       	mov	r12,r7
8000aa30:	e0 a0 07 ec 	rcall	8000ba08 <__multadd>
8000aa34:	18 92       	mov	r2,r12
8000aa36:	18 9b       	mov	r11,r12
8000aa38:	06 9c       	mov	r12,r3
8000aa3a:	e0 a0 05 f8 	rcall	8000b62a <__mcmp>
8000aa3e:	e0 89 00 0f 	brgt	8000aa5c <_dtoa_r+0x970>
8000aa42:	c0 38       	rjmp	8000aa48 <_dtoa_r+0x95c>
8000aa44:	30 02       	mov	r2,0
8000aa46:	04 94       	mov	r4,r2
8000aa48:	40 ea       	lddsp	r10,sp[0x38]
8000aa4a:	30 09       	mov	r9,0
8000aa4c:	5c da       	com	r10
8000aa4e:	40 85       	lddsp	r5,sp[0x20]
8000aa50:	50 6a       	stdsp	sp[0x18],r10
8000aa52:	50 49       	stdsp	sp[0x10],r9
8000aa54:	c0 f9       	rjmp	8000ac72 <_dtoa_r+0xb86>
8000aa56:	08 92       	mov	r2,r4
8000aa58:	40 66       	lddsp	r6,sp[0x18]
8000aa5a:	04 94       	mov	r4,r2
8000aa5c:	2f f6       	sub	r6,-1
8000aa5e:	50 66       	stdsp	sp[0x18],r6
8000aa60:	33 18       	mov	r8,49
8000aa62:	40 85       	lddsp	r5,sp[0x20]
8000aa64:	0a c8       	st.b	r5++,r8
8000aa66:	30 08       	mov	r8,0
8000aa68:	50 48       	stdsp	sp[0x10],r8
8000aa6a:	c0 49       	rjmp	8000ac72 <_dtoa_r+0xb86>
8000aa6c:	40 dc       	lddsp	r12,sp[0x34]
8000aa6e:	58 0c       	cp.w	r12,0
8000aa70:	e0 80 00 b5 	breq	8000abda <_dtoa_r+0xaee>
8000aa74:	58 05       	cp.w	r5,0
8000aa76:	e0 8a 00 08 	brle	8000aa86 <_dtoa_r+0x99a>
8000aa7a:	08 9b       	mov	r11,r4
8000aa7c:	0a 9a       	mov	r10,r5
8000aa7e:	0e 9c       	mov	r12,r7
8000aa80:	e0 a0 06 f8 	rcall	8000b870 <__lshift>
8000aa84:	18 94       	mov	r4,r12
8000aa86:	40 6b       	lddsp	r11,sp[0x18]
8000aa88:	58 0b       	cp.w	r11,0
8000aa8a:	c0 31       	brne	8000aa90 <_dtoa_r+0x9a4>
8000aa8c:	08 9c       	mov	r12,r4
8000aa8e:	c1 38       	rjmp	8000aab4 <_dtoa_r+0x9c8>
8000aa90:	68 1b       	ld.w	r11,r4[0x4]
8000aa92:	0e 9c       	mov	r12,r7
8000aa94:	e0 a0 05 fe 	rcall	8000b690 <_Balloc>
8000aa98:	68 4a       	ld.w	r10,r4[0x10]
8000aa9a:	18 95       	mov	r5,r12
8000aa9c:	e8 cb ff f4 	sub	r11,r4,-12
8000aaa0:	2f ea       	sub	r10,-2
8000aaa2:	2f 4c       	sub	r12,-12
8000aaa4:	a3 6a       	lsl	r10,0x2
8000aaa6:	fe b0 e6 44 	rcall	8000772e <memcpy>
8000aaaa:	0a 9b       	mov	r11,r5
8000aaac:	30 1a       	mov	r10,1
8000aaae:	0e 9c       	mov	r12,r7
8000aab0:	e0 a0 06 e0 	rcall	8000b870 <__lshift>
8000aab4:	50 44       	stdsp	sp[0x10],r4
8000aab6:	40 3a       	lddsp	r10,sp[0xc]
8000aab8:	30 19       	mov	r9,1
8000aaba:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000aabe:	18 94       	mov	r4,r12
8000aac0:	50 da       	stdsp	sp[0x34],r10
8000aac2:	40 85       	lddsp	r5,sp[0x20]
8000aac4:	50 99       	stdsp	sp[0x24],r9
8000aac6:	50 26       	stdsp	sp[0x8],r6
8000aac8:	50 e1       	stdsp	sp[0x38],r1
8000aaca:	04 9b       	mov	r11,r2
8000aacc:	06 9c       	mov	r12,r3
8000aace:	fe b0 fa 7f 	rcall	80009fcc <quorem>
8000aad2:	40 4b       	lddsp	r11,sp[0x10]
8000aad4:	f8 c0 ff d0 	sub	r0,r12,-48
8000aad8:	06 9c       	mov	r12,r3
8000aada:	e0 a0 05 a8 	rcall	8000b62a <__mcmp>
8000aade:	08 9a       	mov	r10,r4
8000aae0:	50 6c       	stdsp	sp[0x18],r12
8000aae2:	04 9b       	mov	r11,r2
8000aae4:	0e 9c       	mov	r12,r7
8000aae6:	e0 a0 06 5d 	rcall	8000b7a0 <__mdiff>
8000aaea:	18 91       	mov	r1,r12
8000aaec:	78 38       	ld.w	r8,r12[0xc]
8000aaee:	58 08       	cp.w	r8,0
8000aaf0:	c0 30       	breq	8000aaf6 <_dtoa_r+0xa0a>
8000aaf2:	30 16       	mov	r6,1
8000aaf4:	c0 68       	rjmp	8000ab00 <_dtoa_r+0xa14>
8000aaf6:	18 9b       	mov	r11,r12
8000aaf8:	06 9c       	mov	r12,r3
8000aafa:	e0 a0 05 98 	rcall	8000b62a <__mcmp>
8000aafe:	18 96       	mov	r6,r12
8000ab00:	0e 9c       	mov	r12,r7
8000ab02:	02 9b       	mov	r11,r1
8000ab04:	e0 a0 05 ac 	rcall	8000b65c <_Bfree>
8000ab08:	40 cc       	lddsp	r12,sp[0x30]
8000ab0a:	ed ec 10 08 	or	r8,r6,r12
8000ab0e:	c0 d1       	brne	8000ab28 <_dtoa_r+0xa3c>
8000ab10:	40 db       	lddsp	r11,sp[0x34]
8000ab12:	58 0b       	cp.w	r11,0
8000ab14:	c0 a1       	brne	8000ab28 <_dtoa_r+0xa3c>
8000ab16:	40 26       	lddsp	r6,sp[0x8]
8000ab18:	e0 40 00 39 	cp.w	r0,57
8000ab1c:	c3 00       	breq	8000ab7c <_dtoa_r+0xa90>
8000ab1e:	40 6a       	lddsp	r10,sp[0x18]
8000ab20:	58 0a       	cp.w	r10,0
8000ab22:	e0 89 00 24 	brgt	8000ab6a <_dtoa_r+0xa7e>
8000ab26:	c2 f8       	rjmp	8000ab84 <_dtoa_r+0xa98>
8000ab28:	40 69       	lddsp	r9,sp[0x18]
8000ab2a:	58 09       	cp.w	r9,0
8000ab2c:	c0 85       	brlt	8000ab3c <_dtoa_r+0xa50>
8000ab2e:	12 98       	mov	r8,r9
8000ab30:	40 cc       	lddsp	r12,sp[0x30]
8000ab32:	18 48       	or	r8,r12
8000ab34:	c1 d1       	brne	8000ab6e <_dtoa_r+0xa82>
8000ab36:	40 db       	lddsp	r11,sp[0x34]
8000ab38:	58 0b       	cp.w	r11,0
8000ab3a:	c1 a1       	brne	8000ab6e <_dtoa_r+0xa82>
8000ab3c:	0c 99       	mov	r9,r6
8000ab3e:	40 26       	lddsp	r6,sp[0x8]
8000ab40:	58 09       	cp.w	r9,0
8000ab42:	e0 8a 00 21 	brle	8000ab84 <_dtoa_r+0xa98>
8000ab46:	06 9b       	mov	r11,r3
8000ab48:	30 1a       	mov	r10,1
8000ab4a:	0e 9c       	mov	r12,r7
8000ab4c:	e0 a0 06 92 	rcall	8000b870 <__lshift>
8000ab50:	04 9b       	mov	r11,r2
8000ab52:	18 93       	mov	r3,r12
8000ab54:	e0 a0 05 6b 	rcall	8000b62a <__mcmp>
8000ab58:	e0 89 00 06 	brgt	8000ab64 <_dtoa_r+0xa78>
8000ab5c:	c1 41       	brne	8000ab84 <_dtoa_r+0xa98>
8000ab5e:	ed b0 00 00 	bld	r0,0x0
8000ab62:	c1 11       	brne	8000ab84 <_dtoa_r+0xa98>
8000ab64:	e0 40 00 39 	cp.w	r0,57
8000ab68:	c0 a0       	breq	8000ab7c <_dtoa_r+0xa90>
8000ab6a:	2f f0       	sub	r0,-1
8000ab6c:	c0 c8       	rjmp	8000ab84 <_dtoa_r+0xa98>
8000ab6e:	58 06       	cp.w	r6,0
8000ab70:	e0 8a 00 0c 	brle	8000ab88 <_dtoa_r+0xa9c>
8000ab74:	40 26       	lddsp	r6,sp[0x8]
8000ab76:	e0 40 00 39 	cp.w	r0,57
8000ab7a:	c0 41       	brne	8000ab82 <_dtoa_r+0xa96>
8000ab7c:	33 98       	mov	r8,57
8000ab7e:	0a c8       	st.b	r5++,r8
8000ab80:	c6 78       	rjmp	8000ac4e <_dtoa_r+0xb62>
8000ab82:	2f f0       	sub	r0,-1
8000ab84:	0a c0       	st.b	r5++,r0
8000ab86:	c7 58       	rjmp	8000ac70 <_dtoa_r+0xb84>
8000ab88:	0a c0       	st.b	r5++,r0
8000ab8a:	40 9a       	lddsp	r10,sp[0x24]
8000ab8c:	40 e9       	lddsp	r9,sp[0x38]
8000ab8e:	12 3a       	cp.w	r10,r9
8000ab90:	c4 30       	breq	8000ac16 <_dtoa_r+0xb2a>
8000ab92:	06 9b       	mov	r11,r3
8000ab94:	30 09       	mov	r9,0
8000ab96:	30 aa       	mov	r10,10
8000ab98:	0e 9c       	mov	r12,r7
8000ab9a:	e0 a0 07 37 	rcall	8000ba08 <__multadd>
8000ab9e:	40 48       	lddsp	r8,sp[0x10]
8000aba0:	18 93       	mov	r3,r12
8000aba2:	08 38       	cp.w	r8,r4
8000aba4:	c0 91       	brne	8000abb6 <_dtoa_r+0xaca>
8000aba6:	10 9b       	mov	r11,r8
8000aba8:	30 09       	mov	r9,0
8000abaa:	30 aa       	mov	r10,10
8000abac:	0e 9c       	mov	r12,r7
8000abae:	e0 a0 07 2d 	rcall	8000ba08 <__multadd>
8000abb2:	50 4c       	stdsp	sp[0x10],r12
8000abb4:	c0 e8       	rjmp	8000abd0 <_dtoa_r+0xae4>
8000abb6:	40 4b       	lddsp	r11,sp[0x10]
8000abb8:	30 09       	mov	r9,0
8000abba:	30 aa       	mov	r10,10
8000abbc:	0e 9c       	mov	r12,r7
8000abbe:	e0 a0 07 25 	rcall	8000ba08 <__multadd>
8000abc2:	08 9b       	mov	r11,r4
8000abc4:	50 4c       	stdsp	sp[0x10],r12
8000abc6:	30 09       	mov	r9,0
8000abc8:	30 aa       	mov	r10,10
8000abca:	0e 9c       	mov	r12,r7
8000abcc:	e0 a0 07 1e 	rcall	8000ba08 <__multadd>
8000abd0:	18 94       	mov	r4,r12
8000abd2:	40 9c       	lddsp	r12,sp[0x24]
8000abd4:	2f fc       	sub	r12,-1
8000abd6:	50 9c       	stdsp	sp[0x24],r12
8000abd8:	c7 9b       	rjmp	8000aaca <_dtoa_r+0x9de>
8000abda:	30 18       	mov	r8,1
8000abdc:	06 90       	mov	r0,r3
8000abde:	40 85       	lddsp	r5,sp[0x20]
8000abe0:	08 93       	mov	r3,r4
8000abe2:	0c 94       	mov	r4,r6
8000abe4:	10 96       	mov	r6,r8
8000abe6:	04 9b       	mov	r11,r2
8000abe8:	00 9c       	mov	r12,r0
8000abea:	fe b0 f9 f1 	rcall	80009fcc <quorem>
8000abee:	2d 0c       	sub	r12,-48
8000abf0:	0a cc       	st.b	r5++,r12
8000abf2:	02 36       	cp.w	r6,r1
8000abf4:	c0 a4       	brge	8000ac08 <_dtoa_r+0xb1c>
8000abf6:	00 9b       	mov	r11,r0
8000abf8:	30 09       	mov	r9,0
8000abfa:	30 aa       	mov	r10,10
8000abfc:	0e 9c       	mov	r12,r7
8000abfe:	2f f6       	sub	r6,-1
8000ac00:	e0 a0 07 04 	rcall	8000ba08 <__multadd>
8000ac04:	18 90       	mov	r0,r12
8000ac06:	cf 0b       	rjmp	8000abe6 <_dtoa_r+0xafa>
8000ac08:	08 96       	mov	r6,r4
8000ac0a:	30 0b       	mov	r11,0
8000ac0c:	06 94       	mov	r4,r3
8000ac0e:	50 4b       	stdsp	sp[0x10],r11
8000ac10:	00 93       	mov	r3,r0
8000ac12:	18 90       	mov	r0,r12
8000ac14:	c0 28       	rjmp	8000ac18 <_dtoa_r+0xb2c>
8000ac16:	40 26       	lddsp	r6,sp[0x8]
8000ac18:	06 9b       	mov	r11,r3
8000ac1a:	30 1a       	mov	r10,1
8000ac1c:	0e 9c       	mov	r12,r7
8000ac1e:	e0 a0 06 29 	rcall	8000b870 <__lshift>
8000ac22:	04 9b       	mov	r11,r2
8000ac24:	18 93       	mov	r3,r12
8000ac26:	e0 a0 05 02 	rcall	8000b62a <__mcmp>
8000ac2a:	e0 89 00 12 	brgt	8000ac4e <_dtoa_r+0xb62>
8000ac2e:	c1 b1       	brne	8000ac64 <_dtoa_r+0xb78>
8000ac30:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ac34:	c0 d1       	brne	8000ac4e <_dtoa_r+0xb62>
8000ac36:	c1 78       	rjmp	8000ac64 <_dtoa_r+0xb78>
8000ac38:	40 89       	lddsp	r9,sp[0x20]
8000ac3a:	12 38       	cp.w	r8,r9
8000ac3c:	c0 30       	breq	8000ac42 <_dtoa_r+0xb56>
8000ac3e:	10 95       	mov	r5,r8
8000ac40:	c0 88       	rjmp	8000ac50 <_dtoa_r+0xb64>
8000ac42:	2f f6       	sub	r6,-1
8000ac44:	50 66       	stdsp	sp[0x18],r6
8000ac46:	33 18       	mov	r8,49
8000ac48:	40 8c       	lddsp	r12,sp[0x20]
8000ac4a:	b8 88       	st.b	r12[0x0],r8
8000ac4c:	c1 38       	rjmp	8000ac72 <_dtoa_r+0xb86>
8000ac4e:	33 9a       	mov	r10,57
8000ac50:	0a 98       	mov	r8,r5
8000ac52:	11 79       	ld.ub	r9,--r8
8000ac54:	f4 09 18 00 	cp.b	r9,r10
8000ac58:	cf 00       	breq	8000ac38 <_dtoa_r+0xb4c>
8000ac5a:	2f f9       	sub	r9,-1
8000ac5c:	b0 89       	st.b	r8[0x0],r9
8000ac5e:	c0 98       	rjmp	8000ac70 <_dtoa_r+0xb84>
8000ac60:	10 95       	mov	r5,r8
8000ac62:	c0 28       	rjmp	8000ac66 <_dtoa_r+0xb7a>
8000ac64:	33 09       	mov	r9,48
8000ac66:	0a 98       	mov	r8,r5
8000ac68:	11 7a       	ld.ub	r10,--r8
8000ac6a:	f2 0a 18 00 	cp.b	r10,r9
8000ac6e:	cf 90       	breq	8000ac60 <_dtoa_r+0xb74>
8000ac70:	50 66       	stdsp	sp[0x18],r6
8000ac72:	04 9b       	mov	r11,r2
8000ac74:	0e 9c       	mov	r12,r7
8000ac76:	e0 a0 04 f3 	rcall	8000b65c <_Bfree>
8000ac7a:	58 04       	cp.w	r4,0
8000ac7c:	c1 20       	breq	8000aca0 <_dtoa_r+0xbb4>
8000ac7e:	40 4b       	lddsp	r11,sp[0x10]
8000ac80:	08 3b       	cp.w	r11,r4
8000ac82:	5f 19       	srne	r9
8000ac84:	58 0b       	cp.w	r11,0
8000ac86:	5f 18       	srne	r8
8000ac88:	f3 e8 00 08 	and	r8,r9,r8
8000ac8c:	c0 40       	breq	8000ac94 <_dtoa_r+0xba8>
8000ac8e:	0e 9c       	mov	r12,r7
8000ac90:	e0 a0 04 e6 	rcall	8000b65c <_Bfree>
8000ac94:	08 9b       	mov	r11,r4
8000ac96:	0e 9c       	mov	r12,r7
8000ac98:	e0 a0 04 e2 	rcall	8000b65c <_Bfree>
8000ac9c:	c0 28       	rjmp	8000aca0 <_dtoa_r+0xbb4>
8000ac9e:	50 66       	stdsp	sp[0x18],r6
8000aca0:	0e 9c       	mov	r12,r7
8000aca2:	06 9b       	mov	r11,r3
8000aca4:	e0 a0 04 dc 	rcall	8000b65c <_Bfree>
8000aca8:	30 08       	mov	r8,0
8000acaa:	aa 88       	st.b	r5[0x0],r8
8000acac:	40 68       	lddsp	r8,sp[0x18]
8000acae:	41 5a       	lddsp	r10,sp[0x54]
8000acb0:	2f f8       	sub	r8,-1
8000acb2:	41 29       	lddsp	r9,sp[0x48]
8000acb4:	95 08       	st.w	r10[0x0],r8
8000acb6:	40 8c       	lddsp	r12,sp[0x20]
8000acb8:	58 09       	cp.w	r9,0
8000acba:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000acbe:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000acc2:	2e 6d       	sub	sp,-104
8000acc4:	d8 32       	popm	r0-r7,pc
8000acc6:	d7 03       	nop

8000acc8 <__errno>:
8000acc8:	e0 68 0a 3c 	mov	r8,2620
8000accc:	70 0c       	ld.w	r12,r8[0x0]
8000acce:	2f 4c       	sub	r12,-12
8000acd0:	5e fc       	retal	r12
8000acd2:	d7 03       	nop

8000acd4 <_fflush_r>:
8000acd4:	d4 21       	pushm	r4-r7,lr
8000acd6:	16 97       	mov	r7,r11
8000acd8:	18 96       	mov	r6,r12
8000acda:	76 48       	ld.w	r8,r11[0x10]
8000acdc:	58 08       	cp.w	r8,0
8000acde:	c7 f0       	breq	8000addc <_fflush_r+0x108>
8000ace0:	58 0c       	cp.w	r12,0
8000ace2:	c0 50       	breq	8000acec <_fflush_r+0x18>
8000ace4:	78 68       	ld.w	r8,r12[0x18]
8000ace6:	58 08       	cp.w	r8,0
8000ace8:	c0 21       	brne	8000acec <_fflush_r+0x18>
8000acea:	cc dc       	rcall	8000ae84 <__sinit>
8000acec:	fe c8 c8 dc 	sub	r8,pc,-14116
8000acf0:	10 37       	cp.w	r7,r8
8000acf2:	c0 31       	brne	8000acf8 <_fflush_r+0x24>
8000acf4:	6c 07       	ld.w	r7,r6[0x0]
8000acf6:	c0 c8       	rjmp	8000ad0e <_fflush_r+0x3a>
8000acf8:	fe c8 c8 c8 	sub	r8,pc,-14136
8000acfc:	10 37       	cp.w	r7,r8
8000acfe:	c0 31       	brne	8000ad04 <_fflush_r+0x30>
8000ad00:	6c 17       	ld.w	r7,r6[0x4]
8000ad02:	c0 68       	rjmp	8000ad0e <_fflush_r+0x3a>
8000ad04:	fe c8 c8 b4 	sub	r8,pc,-14156
8000ad08:	10 37       	cp.w	r7,r8
8000ad0a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ad0e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ad10:	14 98       	mov	r8,r10
8000ad12:	ed ba 00 03 	bld	r10,0x3
8000ad16:	c4 20       	breq	8000ad9a <_fflush_r+0xc6>
8000ad18:	ab ba       	sbr	r10,0xb
8000ad1a:	ae 6a       	st.h	r7[0xc],r10
8000ad1c:	6e 18       	ld.w	r8,r7[0x4]
8000ad1e:	58 08       	cp.w	r8,0
8000ad20:	e0 89 00 06 	brgt	8000ad2c <_fflush_r+0x58>
8000ad24:	6f 08       	ld.w	r8,r7[0x40]
8000ad26:	58 08       	cp.w	r8,0
8000ad28:	e0 8a 00 5a 	brle	8000addc <_fflush_r+0x108>
8000ad2c:	6e b8       	ld.w	r8,r7[0x2c]
8000ad2e:	58 08       	cp.w	r8,0
8000ad30:	c5 60       	breq	8000addc <_fflush_r+0x108>
8000ad32:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ad36:	c0 30       	breq	8000ad3c <_fflush_r+0x68>
8000ad38:	6f 55       	ld.w	r5,r7[0x54]
8000ad3a:	c0 f8       	rjmp	8000ad58 <_fflush_r+0x84>
8000ad3c:	30 19       	mov	r9,1
8000ad3e:	6e 8b       	ld.w	r11,r7[0x20]
8000ad40:	0c 9c       	mov	r12,r6
8000ad42:	5d 18       	icall	r8
8000ad44:	18 95       	mov	r5,r12
8000ad46:	5b fc       	cp.w	r12,-1
8000ad48:	c0 81       	brne	8000ad58 <_fflush_r+0x84>
8000ad4a:	6c 38       	ld.w	r8,r6[0xc]
8000ad4c:	59 d8       	cp.w	r8,29
8000ad4e:	c4 70       	breq	8000addc <_fflush_r+0x108>
8000ad50:	8e 68       	ld.sh	r8,r7[0xc]
8000ad52:	a7 a8       	sbr	r8,0x6
8000ad54:	ae 68       	st.h	r7[0xc],r8
8000ad56:	d8 22       	popm	r4-r7,pc
8000ad58:	8e 68       	ld.sh	r8,r7[0xc]
8000ad5a:	ed b8 00 02 	bld	r8,0x2
8000ad5e:	c0 91       	brne	8000ad70 <_fflush_r+0x9c>
8000ad60:	6e 18       	ld.w	r8,r7[0x4]
8000ad62:	10 15       	sub	r5,r8
8000ad64:	6e d8       	ld.w	r8,r7[0x34]
8000ad66:	58 08       	cp.w	r8,0
8000ad68:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ad6c:	eb d8 e1 15 	subne	r5,r5,r8
8000ad70:	6e b8       	ld.w	r8,r7[0x2c]
8000ad72:	0c 9c       	mov	r12,r6
8000ad74:	30 09       	mov	r9,0
8000ad76:	0a 9a       	mov	r10,r5
8000ad78:	6e 8b       	ld.w	r11,r7[0x20]
8000ad7a:	5d 18       	icall	r8
8000ad7c:	8e 68       	ld.sh	r8,r7[0xc]
8000ad7e:	0a 3c       	cp.w	r12,r5
8000ad80:	c2 61       	brne	8000adcc <_fflush_r+0xf8>
8000ad82:	ab d8       	cbr	r8,0xb
8000ad84:	30 0c       	mov	r12,0
8000ad86:	6e 49       	ld.w	r9,r7[0x10]
8000ad88:	ae 68       	st.h	r7[0xc],r8
8000ad8a:	8f 1c       	st.w	r7[0x4],r12
8000ad8c:	8f 09       	st.w	r7[0x0],r9
8000ad8e:	ed b8 00 0c 	bld	r8,0xc
8000ad92:	c2 51       	brne	8000addc <_fflush_r+0x108>
8000ad94:	ef 45 00 54 	st.w	r7[84],r5
8000ad98:	d8 22       	popm	r4-r7,pc
8000ad9a:	6e 45       	ld.w	r5,r7[0x10]
8000ad9c:	58 05       	cp.w	r5,0
8000ad9e:	c1 f0       	breq	8000addc <_fflush_r+0x108>
8000ada0:	6e 04       	ld.w	r4,r7[0x0]
8000ada2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ada6:	8f 05       	st.w	r7[0x0],r5
8000ada8:	f9 b8 01 00 	movne	r8,0
8000adac:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000adb0:	0a 14       	sub	r4,r5
8000adb2:	8f 28       	st.w	r7[0x8],r8
8000adb4:	c1 18       	rjmp	8000add6 <_fflush_r+0x102>
8000adb6:	08 99       	mov	r9,r4
8000adb8:	0a 9a       	mov	r10,r5
8000adba:	6e a8       	ld.w	r8,r7[0x28]
8000adbc:	6e 8b       	ld.w	r11,r7[0x20]
8000adbe:	0c 9c       	mov	r12,r6
8000adc0:	5d 18       	icall	r8
8000adc2:	18 14       	sub	r4,r12
8000adc4:	58 0c       	cp.w	r12,0
8000adc6:	e0 89 00 07 	brgt	8000add4 <_fflush_r+0x100>
8000adca:	8e 68       	ld.sh	r8,r7[0xc]
8000adcc:	a7 a8       	sbr	r8,0x6
8000adce:	3f fc       	mov	r12,-1
8000add0:	ae 68       	st.h	r7[0xc],r8
8000add2:	d8 22       	popm	r4-r7,pc
8000add4:	18 05       	add	r5,r12
8000add6:	58 04       	cp.w	r4,0
8000add8:	fe 99 ff ef 	brgt	8000adb6 <_fflush_r+0xe2>
8000addc:	d8 2a       	popm	r4-r7,pc,r12=0
8000adde:	d7 03       	nop

8000ade0 <__sfp_lock_acquire>:
8000ade0:	5e fc       	retal	r12

8000ade2 <__sfp_lock_release>:
8000ade2:	5e fc       	retal	r12

8000ade4 <_cleanup_r>:
8000ade4:	d4 01       	pushm	lr
8000ade6:	fe cb f0 c6 	sub	r11,pc,-3898
8000adea:	e0 a0 02 f7 	rcall	8000b3d8 <_fwalk>
8000adee:	d8 02       	popm	pc

8000adf0 <__sfmoreglue>:
8000adf0:	d4 21       	pushm	r4-r7,lr
8000adf2:	16 95       	mov	r5,r11
8000adf4:	f6 06 10 5c 	mul	r6,r11,92
8000adf8:	ec cb ff f4 	sub	r11,r6,-12
8000adfc:	fe b0 e2 6a 	rcall	800072d0 <_malloc_r>
8000ae00:	18 97       	mov	r7,r12
8000ae02:	c0 90       	breq	8000ae14 <__sfmoreglue+0x24>
8000ae04:	99 15       	st.w	r12[0x4],r5
8000ae06:	30 0b       	mov	r11,0
8000ae08:	2f 4c       	sub	r12,-12
8000ae0a:	0c 9a       	mov	r10,r6
8000ae0c:	8f 2c       	st.w	r7[0x8],r12
8000ae0e:	8f 0b       	st.w	r7[0x0],r11
8000ae10:	fe b0 e5 33 	rcall	80007876 <memset>
8000ae14:	0e 9c       	mov	r12,r7
8000ae16:	d8 22       	popm	r4-r7,pc

8000ae18 <__sfp>:
8000ae18:	d4 21       	pushm	r4-r7,lr
8000ae1a:	fe c8 c9 a6 	sub	r8,pc,-13914
8000ae1e:	18 96       	mov	r6,r12
8000ae20:	70 07       	ld.w	r7,r8[0x0]
8000ae22:	6e 68       	ld.w	r8,r7[0x18]
8000ae24:	58 08       	cp.w	r8,0
8000ae26:	c0 31       	brne	8000ae2c <__sfp+0x14>
8000ae28:	0e 9c       	mov	r12,r7
8000ae2a:	c2 dc       	rcall	8000ae84 <__sinit>
8000ae2c:	ee c7 ff 28 	sub	r7,r7,-216
8000ae30:	30 05       	mov	r5,0
8000ae32:	6e 2c       	ld.w	r12,r7[0x8]
8000ae34:	6e 18       	ld.w	r8,r7[0x4]
8000ae36:	c0 68       	rjmp	8000ae42 <__sfp+0x2a>
8000ae38:	98 69       	ld.sh	r9,r12[0xc]
8000ae3a:	ea 09 19 00 	cp.h	r9,r5
8000ae3e:	c1 10       	breq	8000ae60 <__sfp+0x48>
8000ae40:	2a 4c       	sub	r12,-92
8000ae42:	20 18       	sub	r8,1
8000ae44:	cf a7       	brpl	8000ae38 <__sfp+0x20>
8000ae46:	6e 08       	ld.w	r8,r7[0x0]
8000ae48:	58 08       	cp.w	r8,0
8000ae4a:	c0 61       	brne	8000ae56 <__sfp+0x3e>
8000ae4c:	30 4b       	mov	r11,4
8000ae4e:	0c 9c       	mov	r12,r6
8000ae50:	cd 0f       	rcall	8000adf0 <__sfmoreglue>
8000ae52:	8f 0c       	st.w	r7[0x0],r12
8000ae54:	c0 30       	breq	8000ae5a <__sfp+0x42>
8000ae56:	6e 07       	ld.w	r7,r7[0x0]
8000ae58:	ce db       	rjmp	8000ae32 <__sfp+0x1a>
8000ae5a:	30 c8       	mov	r8,12
8000ae5c:	8d 38       	st.w	r6[0xc],r8
8000ae5e:	d8 22       	popm	r4-r7,pc
8000ae60:	30 08       	mov	r8,0
8000ae62:	f9 48 00 4c 	st.w	r12[76],r8
8000ae66:	99 08       	st.w	r12[0x0],r8
8000ae68:	99 28       	st.w	r12[0x8],r8
8000ae6a:	99 18       	st.w	r12[0x4],r8
8000ae6c:	99 48       	st.w	r12[0x10],r8
8000ae6e:	99 58       	st.w	r12[0x14],r8
8000ae70:	99 68       	st.w	r12[0x18],r8
8000ae72:	99 d8       	st.w	r12[0x34],r8
8000ae74:	99 e8       	st.w	r12[0x38],r8
8000ae76:	f9 48 00 48 	st.w	r12[72],r8
8000ae7a:	3f f8       	mov	r8,-1
8000ae7c:	b8 78       	st.h	r12[0xe],r8
8000ae7e:	30 18       	mov	r8,1
8000ae80:	b8 68       	st.h	r12[0xc],r8
8000ae82:	d8 22       	popm	r4-r7,pc

8000ae84 <__sinit>:
8000ae84:	d4 21       	pushm	r4-r7,lr
8000ae86:	18 96       	mov	r6,r12
8000ae88:	78 67       	ld.w	r7,r12[0x18]
8000ae8a:	58 07       	cp.w	r7,0
8000ae8c:	c4 91       	brne	8000af1e <__sinit+0x9a>
8000ae8e:	fe c8 00 aa 	sub	r8,pc,170
8000ae92:	30 15       	mov	r5,1
8000ae94:	99 a8       	st.w	r12[0x28],r8
8000ae96:	f9 47 00 d8 	st.w	r12[216],r7
8000ae9a:	f9 47 00 dc 	st.w	r12[220],r7
8000ae9e:	f9 47 00 e0 	st.w	r12[224],r7
8000aea2:	99 65       	st.w	r12[0x18],r5
8000aea4:	cb af       	rcall	8000ae18 <__sfp>
8000aea6:	8d 0c       	st.w	r6[0x0],r12
8000aea8:	0c 9c       	mov	r12,r6
8000aeaa:	cb 7f       	rcall	8000ae18 <__sfp>
8000aeac:	8d 1c       	st.w	r6[0x4],r12
8000aeae:	0c 9c       	mov	r12,r6
8000aeb0:	cb 4f       	rcall	8000ae18 <__sfp>
8000aeb2:	6c 09       	ld.w	r9,r6[0x0]
8000aeb4:	30 48       	mov	r8,4
8000aeb6:	93 07       	st.w	r9[0x0],r7
8000aeb8:	b2 68       	st.h	r9[0xc],r8
8000aeba:	93 17       	st.w	r9[0x4],r7
8000aebc:	93 27       	st.w	r9[0x8],r7
8000aebe:	6c 18       	ld.w	r8,r6[0x4]
8000aec0:	b2 77       	st.h	r9[0xe],r7
8000aec2:	93 47       	st.w	r9[0x10],r7
8000aec4:	93 57       	st.w	r9[0x14],r7
8000aec6:	93 67       	st.w	r9[0x18],r7
8000aec8:	93 89       	st.w	r9[0x20],r9
8000aeca:	91 07       	st.w	r8[0x0],r7
8000aecc:	91 17       	st.w	r8[0x4],r7
8000aece:	91 27       	st.w	r8[0x8],r7
8000aed0:	fe ce f3 24 	sub	lr,pc,-3292
8000aed4:	fe cb f3 54 	sub	r11,pc,-3244
8000aed8:	93 9e       	st.w	r9[0x24],lr
8000aeda:	93 ab       	st.w	r9[0x28],r11
8000aedc:	fe ca f3 7c 	sub	r10,pc,-3204
8000aee0:	fe c4 f3 88 	sub	r4,pc,-3192
8000aee4:	93 ba       	st.w	r9[0x2c],r10
8000aee6:	93 c4       	st.w	r9[0x30],r4
8000aee8:	30 99       	mov	r9,9
8000aeea:	b0 69       	st.h	r8[0xc],r9
8000aeec:	b0 75       	st.h	r8[0xe],r5
8000aeee:	91 c4       	st.w	r8[0x30],r4
8000aef0:	91 47       	st.w	r8[0x10],r7
8000aef2:	91 57       	st.w	r8[0x14],r7
8000aef4:	91 67       	st.w	r8[0x18],r7
8000aef6:	91 88       	st.w	r8[0x20],r8
8000aef8:	91 9e       	st.w	r8[0x24],lr
8000aefa:	91 ab       	st.w	r8[0x28],r11
8000aefc:	91 ba       	st.w	r8[0x2c],r10
8000aefe:	8d 2c       	st.w	r6[0x8],r12
8000af00:	31 28       	mov	r8,18
8000af02:	99 07       	st.w	r12[0x0],r7
8000af04:	b8 68       	st.h	r12[0xc],r8
8000af06:	99 17       	st.w	r12[0x4],r7
8000af08:	99 27       	st.w	r12[0x8],r7
8000af0a:	30 28       	mov	r8,2
8000af0c:	b8 78       	st.h	r12[0xe],r8
8000af0e:	99 c4       	st.w	r12[0x30],r4
8000af10:	99 67       	st.w	r12[0x18],r7
8000af12:	99 9e       	st.w	r12[0x24],lr
8000af14:	99 ab       	st.w	r12[0x28],r11
8000af16:	99 ba       	st.w	r12[0x2c],r10
8000af18:	99 47       	st.w	r12[0x10],r7
8000af1a:	99 57       	st.w	r12[0x14],r7
8000af1c:	99 8c       	st.w	r12[0x20],r12
8000af1e:	d8 22       	popm	r4-r7,pc

8000af20 <_malloc_trim_r>:
8000af20:	d4 21       	pushm	r4-r7,lr
8000af22:	16 95       	mov	r5,r11
8000af24:	18 97       	mov	r7,r12
8000af26:	fe b0 d7 53 	rcall	80005dcc <__malloc_lock>
8000af2a:	e0 64 05 3c 	mov	r4,1340
8000af2e:	68 28       	ld.w	r8,r4[0x8]
8000af30:	70 16       	ld.w	r6,r8[0x4]
8000af32:	e0 16 ff fc 	andl	r6,0xfffc
8000af36:	ec c8 ff 91 	sub	r8,r6,-111
8000af3a:	f0 05 01 05 	sub	r5,r8,r5
8000af3e:	e0 15 ff 80 	andl	r5,0xff80
8000af42:	ea c5 00 80 	sub	r5,r5,128
8000af46:	e0 45 00 7f 	cp.w	r5,127
8000af4a:	e0 8a 00 25 	brle	8000af94 <_malloc_trim_r+0x74>
8000af4e:	30 0b       	mov	r11,0
8000af50:	0e 9c       	mov	r12,r7
8000af52:	fe b0 e5 f9 	rcall	80007b44 <_sbrk_r>
8000af56:	68 28       	ld.w	r8,r4[0x8]
8000af58:	0c 08       	add	r8,r6
8000af5a:	10 3c       	cp.w	r12,r8
8000af5c:	c1 c1       	brne	8000af94 <_malloc_trim_r+0x74>
8000af5e:	ea 0b 11 00 	rsub	r11,r5,0
8000af62:	0e 9c       	mov	r12,r7
8000af64:	fe b0 e5 f0 	rcall	80007b44 <_sbrk_r>
8000af68:	5b fc       	cp.w	r12,-1
8000af6a:	c1 91       	brne	8000af9c <_malloc_trim_r+0x7c>
8000af6c:	30 0b       	mov	r11,0
8000af6e:	0e 9c       	mov	r12,r7
8000af70:	fe b0 e5 ea 	rcall	80007b44 <_sbrk_r>
8000af74:	68 28       	ld.w	r8,r4[0x8]
8000af76:	f8 08 01 09 	sub	r9,r12,r8
8000af7a:	58 f9       	cp.w	r9,15
8000af7c:	e0 8a 00 0c 	brle	8000af94 <_malloc_trim_r+0x74>
8000af80:	a1 a9       	sbr	r9,0x0
8000af82:	91 19       	st.w	r8[0x4],r9
8000af84:	e0 68 09 48 	mov	r8,2376
8000af88:	70 09       	ld.w	r9,r8[0x0]
8000af8a:	e0 68 0d 58 	mov	r8,3416
8000af8e:	f8 09 01 09 	sub	r9,r12,r9
8000af92:	91 09       	st.w	r8[0x0],r9
8000af94:	0e 9c       	mov	r12,r7
8000af96:	fe b0 d7 21 	rcall	80005dd8 <__malloc_unlock>
8000af9a:	d8 2a       	popm	r4-r7,pc,r12=0
8000af9c:	68 28       	ld.w	r8,r4[0x8]
8000af9e:	0a 16       	sub	r6,r5
8000afa0:	a1 a6       	sbr	r6,0x0
8000afa2:	91 16       	st.w	r8[0x4],r6
8000afa4:	e0 68 0d 58 	mov	r8,3416
8000afa8:	70 09       	ld.w	r9,r8[0x0]
8000afaa:	0a 19       	sub	r9,r5
8000afac:	0e 9c       	mov	r12,r7
8000afae:	91 09       	st.w	r8[0x0],r9
8000afb0:	fe b0 d7 14 	rcall	80005dd8 <__malloc_unlock>
8000afb4:	da 2a       	popm	r4-r7,pc,r12=1
8000afb6:	d7 03       	nop

8000afb8 <_free_r>:
8000afb8:	d4 21       	pushm	r4-r7,lr
8000afba:	16 96       	mov	r6,r11
8000afbc:	18 97       	mov	r7,r12
8000afbe:	58 0b       	cp.w	r11,0
8000afc0:	e0 80 00 c0 	breq	8000b140 <_free_r+0x188>
8000afc4:	fe b0 d7 04 	rcall	80005dcc <__malloc_lock>
8000afc8:	20 86       	sub	r6,8
8000afca:	e0 6a 05 3c 	mov	r10,1340
8000afce:	6c 18       	ld.w	r8,r6[0x4]
8000afd0:	74 2e       	ld.w	lr,r10[0x8]
8000afd2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000afd6:	a1 c8       	cbr	r8,0x0
8000afd8:	ec 08 00 09 	add	r9,r6,r8
8000afdc:	72 1b       	ld.w	r11,r9[0x4]
8000afde:	e0 1b ff fc 	andl	r11,0xfffc
8000afe2:	1c 39       	cp.w	r9,lr
8000afe4:	c1 e1       	brne	8000b020 <_free_r+0x68>
8000afe6:	f6 08 00 08 	add	r8,r11,r8
8000afea:	58 0c       	cp.w	r12,0
8000afec:	c0 81       	brne	8000affc <_free_r+0x44>
8000afee:	6c 09       	ld.w	r9,r6[0x0]
8000aff0:	12 16       	sub	r6,r9
8000aff2:	12 08       	add	r8,r9
8000aff4:	6c 3b       	ld.w	r11,r6[0xc]
8000aff6:	6c 29       	ld.w	r9,r6[0x8]
8000aff8:	97 29       	st.w	r11[0x8],r9
8000affa:	93 3b       	st.w	r9[0xc],r11
8000affc:	10 99       	mov	r9,r8
8000affe:	95 26       	st.w	r10[0x8],r6
8000b000:	a1 a9       	sbr	r9,0x0
8000b002:	8d 19       	st.w	r6[0x4],r9
8000b004:	e0 69 09 44 	mov	r9,2372
8000b008:	72 09       	ld.w	r9,r9[0x0]
8000b00a:	12 38       	cp.w	r8,r9
8000b00c:	c0 63       	brcs	8000b018 <_free_r+0x60>
8000b00e:	e0 68 0d 54 	mov	r8,3412
8000b012:	0e 9c       	mov	r12,r7
8000b014:	70 0b       	ld.w	r11,r8[0x0]
8000b016:	c8 5f       	rcall	8000af20 <_malloc_trim_r>
8000b018:	0e 9c       	mov	r12,r7
8000b01a:	fe b0 d6 df 	rcall	80005dd8 <__malloc_unlock>
8000b01e:	d8 22       	popm	r4-r7,pc
8000b020:	93 1b       	st.w	r9[0x4],r11
8000b022:	58 0c       	cp.w	r12,0
8000b024:	c0 30       	breq	8000b02a <_free_r+0x72>
8000b026:	30 0c       	mov	r12,0
8000b028:	c1 08       	rjmp	8000b048 <_free_r+0x90>
8000b02a:	6c 0e       	ld.w	lr,r6[0x0]
8000b02c:	f4 c5 ff f8 	sub	r5,r10,-8
8000b030:	1c 16       	sub	r6,lr
8000b032:	1c 08       	add	r8,lr
8000b034:	6c 2e       	ld.w	lr,r6[0x8]
8000b036:	0a 3e       	cp.w	lr,r5
8000b038:	f9 bc 00 01 	moveq	r12,1
8000b03c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b040:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b044:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b048:	f2 0b 00 0e 	add	lr,r9,r11
8000b04c:	7c 1e       	ld.w	lr,lr[0x4]
8000b04e:	ed be 00 00 	bld	lr,0x0
8000b052:	c1 40       	breq	8000b07a <_free_r+0xc2>
8000b054:	16 08       	add	r8,r11
8000b056:	58 0c       	cp.w	r12,0
8000b058:	c0 d1       	brne	8000b072 <_free_r+0xba>
8000b05a:	e0 6e 05 3c 	mov	lr,1340
8000b05e:	72 2b       	ld.w	r11,r9[0x8]
8000b060:	2f 8e       	sub	lr,-8
8000b062:	1c 3b       	cp.w	r11,lr
8000b064:	c0 71       	brne	8000b072 <_free_r+0xba>
8000b066:	97 36       	st.w	r11[0xc],r6
8000b068:	97 26       	st.w	r11[0x8],r6
8000b06a:	8d 2b       	st.w	r6[0x8],r11
8000b06c:	8d 3b       	st.w	r6[0xc],r11
8000b06e:	30 1c       	mov	r12,1
8000b070:	c0 58       	rjmp	8000b07a <_free_r+0xc2>
8000b072:	72 2b       	ld.w	r11,r9[0x8]
8000b074:	72 39       	ld.w	r9,r9[0xc]
8000b076:	93 2b       	st.w	r9[0x8],r11
8000b078:	97 39       	st.w	r11[0xc],r9
8000b07a:	10 99       	mov	r9,r8
8000b07c:	ec 08 09 08 	st.w	r6[r8],r8
8000b080:	a1 a9       	sbr	r9,0x0
8000b082:	8d 19       	st.w	r6[0x4],r9
8000b084:	58 0c       	cp.w	r12,0
8000b086:	c5 a1       	brne	8000b13a <_free_r+0x182>
8000b088:	e0 48 01 ff 	cp.w	r8,511
8000b08c:	e0 8b 00 13 	brhi	8000b0b2 <_free_r+0xfa>
8000b090:	a3 98       	lsr	r8,0x3
8000b092:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b096:	72 2b       	ld.w	r11,r9[0x8]
8000b098:	8d 39       	st.w	r6[0xc],r9
8000b09a:	8d 2b       	st.w	r6[0x8],r11
8000b09c:	97 36       	st.w	r11[0xc],r6
8000b09e:	93 26       	st.w	r9[0x8],r6
8000b0a0:	a3 48       	asr	r8,0x2
8000b0a2:	74 19       	ld.w	r9,r10[0x4]
8000b0a4:	30 1b       	mov	r11,1
8000b0a6:	f6 08 09 48 	lsl	r8,r11,r8
8000b0aa:	f3 e8 10 08 	or	r8,r9,r8
8000b0ae:	95 18       	st.w	r10[0x4],r8
8000b0b0:	c4 58       	rjmp	8000b13a <_free_r+0x182>
8000b0b2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b0b6:	58 4b       	cp.w	r11,4
8000b0b8:	e0 8b 00 06 	brhi	8000b0c4 <_free_r+0x10c>
8000b0bc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b0c0:	2c 8b       	sub	r11,-56
8000b0c2:	c2 08       	rjmp	8000b102 <_free_r+0x14a>
8000b0c4:	59 4b       	cp.w	r11,20
8000b0c6:	e0 8b 00 04 	brhi	8000b0ce <_free_r+0x116>
8000b0ca:	2a 5b       	sub	r11,-91
8000b0cc:	c1 b8       	rjmp	8000b102 <_free_r+0x14a>
8000b0ce:	e0 4b 00 54 	cp.w	r11,84
8000b0d2:	e0 8b 00 06 	brhi	8000b0de <_free_r+0x126>
8000b0d6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b0da:	29 2b       	sub	r11,-110
8000b0dc:	c1 38       	rjmp	8000b102 <_free_r+0x14a>
8000b0de:	e0 4b 01 54 	cp.w	r11,340
8000b0e2:	e0 8b 00 06 	brhi	8000b0ee <_free_r+0x136>
8000b0e6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b0ea:	28 9b       	sub	r11,-119
8000b0ec:	c0 b8       	rjmp	8000b102 <_free_r+0x14a>
8000b0ee:	e0 4b 05 54 	cp.w	r11,1364
8000b0f2:	e0 88 00 05 	brls	8000b0fc <_free_r+0x144>
8000b0f6:	37 eb       	mov	r11,126
8000b0f8:	c0 58       	rjmp	8000b102 <_free_r+0x14a>
8000b0fa:	d7 03       	nop
8000b0fc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b100:	28 4b       	sub	r11,-124
8000b102:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b106:	78 29       	ld.w	r9,r12[0x8]
8000b108:	18 39       	cp.w	r9,r12
8000b10a:	c0 e1       	brne	8000b126 <_free_r+0x16e>
8000b10c:	74 18       	ld.w	r8,r10[0x4]
8000b10e:	a3 4b       	asr	r11,0x2
8000b110:	30 1c       	mov	r12,1
8000b112:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b116:	f1 eb 10 0b 	or	r11,r8,r11
8000b11a:	12 98       	mov	r8,r9
8000b11c:	95 1b       	st.w	r10[0x4],r11
8000b11e:	c0 a8       	rjmp	8000b132 <_free_r+0x17a>
8000b120:	72 29       	ld.w	r9,r9[0x8]
8000b122:	18 39       	cp.w	r9,r12
8000b124:	c0 60       	breq	8000b130 <_free_r+0x178>
8000b126:	72 1a       	ld.w	r10,r9[0x4]
8000b128:	e0 1a ff fc 	andl	r10,0xfffc
8000b12c:	14 38       	cp.w	r8,r10
8000b12e:	cf 93       	brcs	8000b120 <_free_r+0x168>
8000b130:	72 38       	ld.w	r8,r9[0xc]
8000b132:	8d 38       	st.w	r6[0xc],r8
8000b134:	8d 29       	st.w	r6[0x8],r9
8000b136:	93 36       	st.w	r9[0xc],r6
8000b138:	91 26       	st.w	r8[0x8],r6
8000b13a:	0e 9c       	mov	r12,r7
8000b13c:	fe b0 d6 4e 	rcall	80005dd8 <__malloc_unlock>
8000b140:	d8 22       	popm	r4-r7,pc
8000b142:	d7 03       	nop

8000b144 <__sfvwrite_r>:
8000b144:	d4 31       	pushm	r0-r7,lr
8000b146:	20 3d       	sub	sp,12
8000b148:	14 94       	mov	r4,r10
8000b14a:	18 95       	mov	r5,r12
8000b14c:	16 97       	mov	r7,r11
8000b14e:	74 28       	ld.w	r8,r10[0x8]
8000b150:	58 08       	cp.w	r8,0
8000b152:	e0 80 01 40 	breq	8000b3d2 <__sfvwrite_r+0x28e>
8000b156:	96 68       	ld.sh	r8,r11[0xc]
8000b158:	ed b8 00 03 	bld	r8,0x3
8000b15c:	c0 41       	brne	8000b164 <__sfvwrite_r+0x20>
8000b15e:	76 48       	ld.w	r8,r11[0x10]
8000b160:	58 08       	cp.w	r8,0
8000b162:	c0 c1       	brne	8000b17a <__sfvwrite_r+0x36>
8000b164:	0e 9b       	mov	r11,r7
8000b166:	0a 9c       	mov	r12,r5
8000b168:	fe b0 f6 c4 	rcall	80009ef0 <__swsetup_r>
8000b16c:	c0 70       	breq	8000b17a <__sfvwrite_r+0x36>
8000b16e:	8e 68       	ld.sh	r8,r7[0xc]
8000b170:	a7 a8       	sbr	r8,0x6
8000b172:	ae 68       	st.h	r7[0xc],r8
8000b174:	30 98       	mov	r8,9
8000b176:	8b 38       	st.w	r5[0xc],r8
8000b178:	c2 b9       	rjmp	8000b3ce <__sfvwrite_r+0x28a>
8000b17a:	8e 63       	ld.sh	r3,r7[0xc]
8000b17c:	68 00       	ld.w	r0,r4[0x0]
8000b17e:	06 96       	mov	r6,r3
8000b180:	e2 16 00 02 	andl	r6,0x2,COH
8000b184:	c2 10       	breq	8000b1c6 <__sfvwrite_r+0x82>
8000b186:	30 03       	mov	r3,0
8000b188:	e0 62 04 00 	mov	r2,1024
8000b18c:	06 96       	mov	r6,r3
8000b18e:	c0 48       	rjmp	8000b196 <__sfvwrite_r+0x52>
8000b190:	60 03       	ld.w	r3,r0[0x0]
8000b192:	60 16       	ld.w	r6,r0[0x4]
8000b194:	2f 80       	sub	r0,-8
8000b196:	58 06       	cp.w	r6,0
8000b198:	cf c0       	breq	8000b190 <__sfvwrite_r+0x4c>
8000b19a:	e0 46 04 00 	cp.w	r6,1024
8000b19e:	ec 09 17 80 	movls	r9,r6
8000b1a2:	e4 09 17 b0 	movhi	r9,r2
8000b1a6:	06 9a       	mov	r10,r3
8000b1a8:	6e a8       	ld.w	r8,r7[0x28]
8000b1aa:	6e 8b       	ld.w	r11,r7[0x20]
8000b1ac:	0a 9c       	mov	r12,r5
8000b1ae:	5d 18       	icall	r8
8000b1b0:	18 16       	sub	r6,r12
8000b1b2:	58 0c       	cp.w	r12,0
8000b1b4:	e0 8a 01 0a 	brle	8000b3c8 <__sfvwrite_r+0x284>
8000b1b8:	68 28       	ld.w	r8,r4[0x8]
8000b1ba:	18 18       	sub	r8,r12
8000b1bc:	89 28       	st.w	r4[0x8],r8
8000b1be:	e0 80 01 0a 	breq	8000b3d2 <__sfvwrite_r+0x28e>
8000b1c2:	18 03       	add	r3,r12
8000b1c4:	ce 9b       	rjmp	8000b196 <__sfvwrite_r+0x52>
8000b1c6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b1ca:	c0 70       	breq	8000b1d8 <__sfvwrite_r+0x94>
8000b1cc:	50 06       	stdsp	sp[0x0],r6
8000b1ce:	0c 93       	mov	r3,r6
8000b1d0:	0c 91       	mov	r1,r6
8000b1d2:	50 15       	stdsp	sp[0x4],r5
8000b1d4:	08 92       	mov	r2,r4
8000b1d6:	c9 c8       	rjmp	8000b30e <__sfvwrite_r+0x1ca>
8000b1d8:	06 96       	mov	r6,r3
8000b1da:	08 91       	mov	r1,r4
8000b1dc:	c0 48       	rjmp	8000b1e4 <__sfvwrite_r+0xa0>
8000b1de:	60 03       	ld.w	r3,r0[0x0]
8000b1e0:	60 16       	ld.w	r6,r0[0x4]
8000b1e2:	2f 80       	sub	r0,-8
8000b1e4:	58 06       	cp.w	r6,0
8000b1e6:	cf c0       	breq	8000b1de <__sfvwrite_r+0x9a>
8000b1e8:	8e 68       	ld.sh	r8,r7[0xc]
8000b1ea:	6e 24       	ld.w	r4,r7[0x8]
8000b1ec:	10 99       	mov	r9,r8
8000b1ee:	e2 19 02 00 	andl	r9,0x200,COH
8000b1f2:	c5 50       	breq	8000b29c <__sfvwrite_r+0x158>
8000b1f4:	08 36       	cp.w	r6,r4
8000b1f6:	c4 43       	brcs	8000b27e <__sfvwrite_r+0x13a>
8000b1f8:	10 99       	mov	r9,r8
8000b1fa:	e2 19 04 80 	andl	r9,0x480,COH
8000b1fe:	c4 00       	breq	8000b27e <__sfvwrite_r+0x13a>
8000b200:	6e 4b       	ld.w	r11,r7[0x10]
8000b202:	6e 09       	ld.w	r9,r7[0x0]
8000b204:	16 19       	sub	r9,r11
8000b206:	50 09       	stdsp	sp[0x0],r9
8000b208:	6e 59       	ld.w	r9,r7[0x14]
8000b20a:	10 9c       	mov	r12,r8
8000b20c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b210:	30 28       	mov	r8,2
8000b212:	f4 08 0c 08 	divs	r8,r10,r8
8000b216:	fa e9 00 04 	st.d	sp[4],r8
8000b21a:	10 94       	mov	r4,r8
8000b21c:	40 09       	lddsp	r9,sp[0x0]
8000b21e:	e2 1c 04 00 	andl	r12,0x400,COH
8000b222:	2f f9       	sub	r9,-1
8000b224:	0c 09       	add	r9,r6
8000b226:	12 38       	cp.w	r8,r9
8000b228:	f2 04 17 30 	movlo	r4,r9
8000b22c:	58 0c       	cp.w	r12,0
8000b22e:	c1 10       	breq	8000b250 <__sfvwrite_r+0x10c>
8000b230:	08 9b       	mov	r11,r4
8000b232:	0a 9c       	mov	r12,r5
8000b234:	fe b0 e0 4e 	rcall	800072d0 <_malloc_r>
8000b238:	18 92       	mov	r2,r12
8000b23a:	c1 40       	breq	8000b262 <__sfvwrite_r+0x11e>
8000b23c:	40 0a       	lddsp	r10,sp[0x0]
8000b23e:	6e 4b       	ld.w	r11,r7[0x10]
8000b240:	fe b0 e2 77 	rcall	8000772e <memcpy>
8000b244:	8e 68       	ld.sh	r8,r7[0xc]
8000b246:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b24a:	a7 b8       	sbr	r8,0x7
8000b24c:	ae 68       	st.h	r7[0xc],r8
8000b24e:	c0 d8       	rjmp	8000b268 <__sfvwrite_r+0x124>
8000b250:	08 9a       	mov	r10,r4
8000b252:	0a 9c       	mov	r12,r5
8000b254:	fe b0 e3 18 	rcall	80007884 <_realloc_r>
8000b258:	18 92       	mov	r2,r12
8000b25a:	c0 71       	brne	8000b268 <__sfvwrite_r+0x124>
8000b25c:	6e 4b       	ld.w	r11,r7[0x10]
8000b25e:	0a 9c       	mov	r12,r5
8000b260:	ca ce       	rcall	8000afb8 <_free_r>
8000b262:	30 c8       	mov	r8,12
8000b264:	8b 38       	st.w	r5[0xc],r8
8000b266:	cb 18       	rjmp	8000b3c8 <__sfvwrite_r+0x284>
8000b268:	40 0a       	lddsp	r10,sp[0x0]
8000b26a:	40 09       	lddsp	r9,sp[0x0]
8000b26c:	e8 0a 01 0a 	sub	r10,r4,r10
8000b270:	e4 09 00 08 	add	r8,r2,r9
8000b274:	8f 54       	st.w	r7[0x14],r4
8000b276:	8f 2a       	st.w	r7[0x8],r10
8000b278:	8f 08       	st.w	r7[0x0],r8
8000b27a:	8f 42       	st.w	r7[0x10],r2
8000b27c:	0c 94       	mov	r4,r6
8000b27e:	08 36       	cp.w	r6,r4
8000b280:	ec 04 17 30 	movlo	r4,r6
8000b284:	06 9b       	mov	r11,r3
8000b286:	08 9a       	mov	r10,r4
8000b288:	6e 0c       	ld.w	r12,r7[0x0]
8000b28a:	c3 ad       	rcall	8000b4fe <memmove>
8000b28c:	6e 08       	ld.w	r8,r7[0x0]
8000b28e:	08 08       	add	r8,r4
8000b290:	8f 08       	st.w	r7[0x0],r8
8000b292:	6e 28       	ld.w	r8,r7[0x8]
8000b294:	08 18       	sub	r8,r4
8000b296:	0c 94       	mov	r4,r6
8000b298:	8f 28       	st.w	r7[0x8],r8
8000b29a:	c2 e8       	rjmp	8000b2f6 <__sfvwrite_r+0x1b2>
8000b29c:	08 36       	cp.w	r6,r4
8000b29e:	5f ba       	srhi	r10
8000b2a0:	6e 0c       	ld.w	r12,r7[0x0]
8000b2a2:	6e 48       	ld.w	r8,r7[0x10]
8000b2a4:	10 3c       	cp.w	r12,r8
8000b2a6:	5f b8       	srhi	r8
8000b2a8:	f5 e8 00 08 	and	r8,r10,r8
8000b2ac:	f2 08 18 00 	cp.b	r8,r9
8000b2b0:	c0 d0       	breq	8000b2ca <__sfvwrite_r+0x186>
8000b2b2:	06 9b       	mov	r11,r3
8000b2b4:	08 9a       	mov	r10,r4
8000b2b6:	c2 4d       	rcall	8000b4fe <memmove>
8000b2b8:	6e 08       	ld.w	r8,r7[0x0]
8000b2ba:	08 08       	add	r8,r4
8000b2bc:	0e 9b       	mov	r11,r7
8000b2be:	8f 08       	st.w	r7[0x0],r8
8000b2c0:	0a 9c       	mov	r12,r5
8000b2c2:	fe b0 fd 09 	rcall	8000acd4 <_fflush_r>
8000b2c6:	c1 80       	breq	8000b2f6 <__sfvwrite_r+0x1b2>
8000b2c8:	c8 08       	rjmp	8000b3c8 <__sfvwrite_r+0x284>
8000b2ca:	6e 59       	ld.w	r9,r7[0x14]
8000b2cc:	12 36       	cp.w	r6,r9
8000b2ce:	c0 a3       	brcs	8000b2e2 <__sfvwrite_r+0x19e>
8000b2d0:	6e a8       	ld.w	r8,r7[0x28]
8000b2d2:	06 9a       	mov	r10,r3
8000b2d4:	6e 8b       	ld.w	r11,r7[0x20]
8000b2d6:	0a 9c       	mov	r12,r5
8000b2d8:	5d 18       	icall	r8
8000b2da:	18 94       	mov	r4,r12
8000b2dc:	e0 89 00 0d 	brgt	8000b2f6 <__sfvwrite_r+0x1b2>
8000b2e0:	c7 48       	rjmp	8000b3c8 <__sfvwrite_r+0x284>
8000b2e2:	0c 9a       	mov	r10,r6
8000b2e4:	06 9b       	mov	r11,r3
8000b2e6:	c0 cd       	rcall	8000b4fe <memmove>
8000b2e8:	6e 08       	ld.w	r8,r7[0x0]
8000b2ea:	0c 08       	add	r8,r6
8000b2ec:	0c 94       	mov	r4,r6
8000b2ee:	8f 08       	st.w	r7[0x0],r8
8000b2f0:	6e 28       	ld.w	r8,r7[0x8]
8000b2f2:	0c 18       	sub	r8,r6
8000b2f4:	8f 28       	st.w	r7[0x8],r8
8000b2f6:	62 28       	ld.w	r8,r1[0x8]
8000b2f8:	08 18       	sub	r8,r4
8000b2fa:	83 28       	st.w	r1[0x8],r8
8000b2fc:	c6 b0       	breq	8000b3d2 <__sfvwrite_r+0x28e>
8000b2fe:	08 16       	sub	r6,r4
8000b300:	08 03       	add	r3,r4
8000b302:	c7 1b       	rjmp	8000b1e4 <__sfvwrite_r+0xa0>
8000b304:	60 03       	ld.w	r3,r0[0x0]
8000b306:	60 11       	ld.w	r1,r0[0x4]
8000b308:	30 08       	mov	r8,0
8000b30a:	2f 80       	sub	r0,-8
8000b30c:	50 08       	stdsp	sp[0x0],r8
8000b30e:	58 01       	cp.w	r1,0
8000b310:	cf a0       	breq	8000b304 <__sfvwrite_r+0x1c0>
8000b312:	40 0a       	lddsp	r10,sp[0x0]
8000b314:	58 0a       	cp.w	r10,0
8000b316:	c1 41       	brne	8000b33e <__sfvwrite_r+0x1fa>
8000b318:	e2 c6 ff ff 	sub	r6,r1,-1
8000b31c:	02 9a       	mov	r10,r1
8000b31e:	30 ab       	mov	r11,10
8000b320:	06 9c       	mov	r12,r3
8000b322:	ce 3c       	rcall	8000b4e8 <memchr>
8000b324:	f8 c8 ff ff 	sub	r8,r12,-1
8000b328:	58 0c       	cp.w	r12,0
8000b32a:	f1 d3 e1 16 	subne	r6,r8,r3
8000b32e:	f9 b9 01 01 	movne	r9,1
8000b332:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b336:	f9 b8 00 01 	moveq	r8,1
8000b33a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b33e:	02 36       	cp.w	r6,r1
8000b340:	ec 04 17 80 	movls	r4,r6
8000b344:	e2 04 17 b0 	movhi	r4,r1
8000b348:	6e 59       	ld.w	r9,r7[0x14]
8000b34a:	6e 25       	ld.w	r5,r7[0x8]
8000b34c:	f2 05 00 05 	add	r5,r9,r5
8000b350:	0a 34       	cp.w	r4,r5
8000b352:	5f 9a       	srgt	r10
8000b354:	6e 0c       	ld.w	r12,r7[0x0]
8000b356:	6e 48       	ld.w	r8,r7[0x10]
8000b358:	10 3c       	cp.w	r12,r8
8000b35a:	5f b8       	srhi	r8
8000b35c:	f5 e8 00 08 	and	r8,r10,r8
8000b360:	30 0a       	mov	r10,0
8000b362:	f4 08 18 00 	cp.b	r8,r10
8000b366:	c0 d0       	breq	8000b380 <__sfvwrite_r+0x23c>
8000b368:	06 9b       	mov	r11,r3
8000b36a:	0a 9a       	mov	r10,r5
8000b36c:	cc 9c       	rcall	8000b4fe <memmove>
8000b36e:	6e 08       	ld.w	r8,r7[0x0]
8000b370:	0a 08       	add	r8,r5
8000b372:	0e 9b       	mov	r11,r7
8000b374:	8f 08       	st.w	r7[0x0],r8
8000b376:	40 1c       	lddsp	r12,sp[0x4]
8000b378:	fe b0 fc ae 	rcall	8000acd4 <_fflush_r>
8000b37c:	c1 70       	breq	8000b3aa <__sfvwrite_r+0x266>
8000b37e:	c2 58       	rjmp	8000b3c8 <__sfvwrite_r+0x284>
8000b380:	12 34       	cp.w	r4,r9
8000b382:	c0 a5       	brlt	8000b396 <__sfvwrite_r+0x252>
8000b384:	6e a8       	ld.w	r8,r7[0x28]
8000b386:	06 9a       	mov	r10,r3
8000b388:	6e 8b       	ld.w	r11,r7[0x20]
8000b38a:	40 1c       	lddsp	r12,sp[0x4]
8000b38c:	5d 18       	icall	r8
8000b38e:	18 95       	mov	r5,r12
8000b390:	e0 89 00 0d 	brgt	8000b3aa <__sfvwrite_r+0x266>
8000b394:	c1 a8       	rjmp	8000b3c8 <__sfvwrite_r+0x284>
8000b396:	08 9a       	mov	r10,r4
8000b398:	06 9b       	mov	r11,r3
8000b39a:	cb 2c       	rcall	8000b4fe <memmove>
8000b39c:	6e 08       	ld.w	r8,r7[0x0]
8000b39e:	08 08       	add	r8,r4
8000b3a0:	08 95       	mov	r5,r4
8000b3a2:	8f 08       	st.w	r7[0x0],r8
8000b3a4:	6e 28       	ld.w	r8,r7[0x8]
8000b3a6:	08 18       	sub	r8,r4
8000b3a8:	8f 28       	st.w	r7[0x8],r8
8000b3aa:	0a 16       	sub	r6,r5
8000b3ac:	c0 71       	brne	8000b3ba <__sfvwrite_r+0x276>
8000b3ae:	0e 9b       	mov	r11,r7
8000b3b0:	40 1c       	lddsp	r12,sp[0x4]
8000b3b2:	fe b0 fc 91 	rcall	8000acd4 <_fflush_r>
8000b3b6:	c0 91       	brne	8000b3c8 <__sfvwrite_r+0x284>
8000b3b8:	50 06       	stdsp	sp[0x0],r6
8000b3ba:	64 28       	ld.w	r8,r2[0x8]
8000b3bc:	0a 18       	sub	r8,r5
8000b3be:	85 28       	st.w	r2[0x8],r8
8000b3c0:	c0 90       	breq	8000b3d2 <__sfvwrite_r+0x28e>
8000b3c2:	0a 11       	sub	r1,r5
8000b3c4:	0a 03       	add	r3,r5
8000b3c6:	ca 4b       	rjmp	8000b30e <__sfvwrite_r+0x1ca>
8000b3c8:	8e 68       	ld.sh	r8,r7[0xc]
8000b3ca:	a7 a8       	sbr	r8,0x6
8000b3cc:	ae 68       	st.h	r7[0xc],r8
8000b3ce:	3f fc       	mov	r12,-1
8000b3d0:	c0 28       	rjmp	8000b3d4 <__sfvwrite_r+0x290>
8000b3d2:	30 0c       	mov	r12,0
8000b3d4:	2f dd       	sub	sp,-12
8000b3d6:	d8 32       	popm	r0-r7,pc

8000b3d8 <_fwalk>:
8000b3d8:	d4 31       	pushm	r0-r7,lr
8000b3da:	30 05       	mov	r5,0
8000b3dc:	16 91       	mov	r1,r11
8000b3de:	f8 c7 ff 28 	sub	r7,r12,-216
8000b3e2:	0a 92       	mov	r2,r5
8000b3e4:	fe b0 fc fe 	rcall	8000ade0 <__sfp_lock_acquire>
8000b3e8:	3f f3       	mov	r3,-1
8000b3ea:	c1 68       	rjmp	8000b416 <_fwalk+0x3e>
8000b3ec:	6e 26       	ld.w	r6,r7[0x8]
8000b3ee:	6e 14       	ld.w	r4,r7[0x4]
8000b3f0:	2f 46       	sub	r6,-12
8000b3f2:	c0 c8       	rjmp	8000b40a <_fwalk+0x32>
8000b3f4:	8c 08       	ld.sh	r8,r6[0x0]
8000b3f6:	e4 08 19 00 	cp.h	r8,r2
8000b3fa:	c0 70       	breq	8000b408 <_fwalk+0x30>
8000b3fc:	8c 18       	ld.sh	r8,r6[0x2]
8000b3fe:	e6 08 19 00 	cp.h	r8,r3
8000b402:	c0 30       	breq	8000b408 <_fwalk+0x30>
8000b404:	5d 11       	icall	r1
8000b406:	18 45       	or	r5,r12
8000b408:	2a 46       	sub	r6,-92
8000b40a:	20 14       	sub	r4,1
8000b40c:	ec cc 00 0c 	sub	r12,r6,12
8000b410:	58 04       	cp.w	r4,0
8000b412:	cf 14       	brge	8000b3f4 <_fwalk+0x1c>
8000b414:	6e 07       	ld.w	r7,r7[0x0]
8000b416:	58 07       	cp.w	r7,0
8000b418:	ce a1       	brne	8000b3ec <_fwalk+0x14>
8000b41a:	fe b0 fc e4 	rcall	8000ade2 <__sfp_lock_release>
8000b41e:	0a 9c       	mov	r12,r5
8000b420:	d8 32       	popm	r0-r7,pc
8000b422:	d7 03       	nop

8000b424 <_localeconv_r>:
8000b424:	fe cc cf ac 	sub	r12,pc,-12372
8000b428:	5e fc       	retal	r12
8000b42a:	d7 03       	nop

8000b42c <__smakebuf_r>:
8000b42c:	d4 21       	pushm	r4-r7,lr
8000b42e:	20 fd       	sub	sp,60
8000b430:	96 68       	ld.sh	r8,r11[0xc]
8000b432:	16 97       	mov	r7,r11
8000b434:	18 96       	mov	r6,r12
8000b436:	e2 18 00 02 	andl	r8,0x2,COH
8000b43a:	c3 d1       	brne	8000b4b4 <__smakebuf_r+0x88>
8000b43c:	96 7b       	ld.sh	r11,r11[0xe]
8000b43e:	f0 0b 19 00 	cp.h	r11,r8
8000b442:	c0 55       	brlt	8000b44c <__smakebuf_r+0x20>
8000b444:	1a 9a       	mov	r10,sp
8000b446:	e0 a0 04 75 	rcall	8000bd30 <_fstat_r>
8000b44a:	c0 f4       	brge	8000b468 <__smakebuf_r+0x3c>
8000b44c:	8e 65       	ld.sh	r5,r7[0xc]
8000b44e:	0a 98       	mov	r8,r5
8000b450:	ab b8       	sbr	r8,0xb
8000b452:	e2 15 00 80 	andl	r5,0x80,COH
8000b456:	ae 68       	st.h	r7[0xc],r8
8000b458:	30 04       	mov	r4,0
8000b45a:	e0 68 04 00 	mov	r8,1024
8000b45e:	f9 b5 01 40 	movne	r5,64
8000b462:	f0 05 17 00 	moveq	r5,r8
8000b466:	c1 c8       	rjmp	8000b49e <__smakebuf_r+0x72>
8000b468:	40 18       	lddsp	r8,sp[0x4]
8000b46a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b46e:	e0 48 20 00 	cp.w	r8,8192
8000b472:	5f 04       	sreq	r4
8000b474:	e0 48 80 00 	cp.w	r8,32768
8000b478:	c0 e1       	brne	8000b494 <__smakebuf_r+0x68>
8000b47a:	6e b9       	ld.w	r9,r7[0x2c]
8000b47c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b480:	10 39       	cp.w	r9,r8
8000b482:	c0 91       	brne	8000b494 <__smakebuf_r+0x68>
8000b484:	8e 68       	ld.sh	r8,r7[0xc]
8000b486:	e0 65 04 00 	mov	r5,1024
8000b48a:	ab a8       	sbr	r8,0xa
8000b48c:	ef 45 00 50 	st.w	r7[80],r5
8000b490:	ae 68       	st.h	r7[0xc],r8
8000b492:	c0 68       	rjmp	8000b49e <__smakebuf_r+0x72>
8000b494:	8e 68       	ld.sh	r8,r7[0xc]
8000b496:	e0 65 04 00 	mov	r5,1024
8000b49a:	ab b8       	sbr	r8,0xb
8000b49c:	ae 68       	st.h	r7[0xc],r8
8000b49e:	0a 9b       	mov	r11,r5
8000b4a0:	0c 9c       	mov	r12,r6
8000b4a2:	fe b0 df 17 	rcall	800072d0 <_malloc_r>
8000b4a6:	8e 68       	ld.sh	r8,r7[0xc]
8000b4a8:	c0 d1       	brne	8000b4c2 <__smakebuf_r+0x96>
8000b4aa:	ed b8 00 09 	bld	r8,0x9
8000b4ae:	c1 b0       	breq	8000b4e4 <__smakebuf_r+0xb8>
8000b4b0:	a1 b8       	sbr	r8,0x1
8000b4b2:	ae 68       	st.h	r7[0xc],r8
8000b4b4:	ee c8 ff b9 	sub	r8,r7,-71
8000b4b8:	8f 48       	st.w	r7[0x10],r8
8000b4ba:	8f 08       	st.w	r7[0x0],r8
8000b4bc:	30 18       	mov	r8,1
8000b4be:	8f 58       	st.w	r7[0x14],r8
8000b4c0:	c1 28       	rjmp	8000b4e4 <__smakebuf_r+0xb8>
8000b4c2:	a7 b8       	sbr	r8,0x7
8000b4c4:	8f 4c       	st.w	r7[0x10],r12
8000b4c6:	ae 68       	st.h	r7[0xc],r8
8000b4c8:	8f 55       	st.w	r7[0x14],r5
8000b4ca:	fe c8 06 e6 	sub	r8,pc,1766
8000b4ce:	8f 0c       	st.w	r7[0x0],r12
8000b4d0:	8d a8       	st.w	r6[0x28],r8
8000b4d2:	58 04       	cp.w	r4,0
8000b4d4:	c0 80       	breq	8000b4e4 <__smakebuf_r+0xb8>
8000b4d6:	8e 7c       	ld.sh	r12,r7[0xe]
8000b4d8:	fe b0 e3 94 	rcall	80007c00 <isatty>
8000b4dc:	c0 40       	breq	8000b4e4 <__smakebuf_r+0xb8>
8000b4de:	8e 68       	ld.sh	r8,r7[0xc]
8000b4e0:	a1 a8       	sbr	r8,0x0
8000b4e2:	ae 68       	st.h	r7[0xc],r8
8000b4e4:	2f 1d       	sub	sp,-60
8000b4e6:	d8 22       	popm	r4-r7,pc

8000b4e8 <memchr>:
8000b4e8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b4ec:	c0 68       	rjmp	8000b4f8 <memchr+0x10>
8000b4ee:	20 1a       	sub	r10,1
8000b4f0:	19 88       	ld.ub	r8,r12[0x0]
8000b4f2:	16 38       	cp.w	r8,r11
8000b4f4:	5e 0c       	reteq	r12
8000b4f6:	2f fc       	sub	r12,-1
8000b4f8:	58 0a       	cp.w	r10,0
8000b4fa:	cf a1       	brne	8000b4ee <memchr+0x6>
8000b4fc:	5e fa       	retal	r10

8000b4fe <memmove>:
8000b4fe:	d4 01       	pushm	lr
8000b500:	18 3b       	cp.w	r11,r12
8000b502:	c1 92       	brcc	8000b534 <memmove+0x36>
8000b504:	f6 0a 00 09 	add	r9,r11,r10
8000b508:	12 3c       	cp.w	r12,r9
8000b50a:	c1 52       	brcc	8000b534 <memmove+0x36>
8000b50c:	f8 0a 00 0b 	add	r11,r12,r10
8000b510:	30 08       	mov	r8,0
8000b512:	c0 68       	rjmp	8000b51e <memmove+0x20>
8000b514:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b518:	20 1a       	sub	r10,1
8000b51a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b51e:	20 18       	sub	r8,1
8000b520:	58 0a       	cp.w	r10,0
8000b522:	cf 91       	brne	8000b514 <memmove+0x16>
8000b524:	d8 02       	popm	pc
8000b526:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b52a:	20 1a       	sub	r10,1
8000b52c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b530:	2f f8       	sub	r8,-1
8000b532:	c0 28       	rjmp	8000b536 <memmove+0x38>
8000b534:	30 08       	mov	r8,0
8000b536:	58 0a       	cp.w	r10,0
8000b538:	cf 71       	brne	8000b526 <memmove+0x28>
8000b53a:	d8 02       	popm	pc

8000b53c <__hi0bits>:
8000b53c:	18 98       	mov	r8,r12
8000b53e:	e0 1c 00 00 	andl	r12,0x0
8000b542:	f0 09 15 10 	lsl	r9,r8,0x10
8000b546:	58 0c       	cp.w	r12,0
8000b548:	f2 08 17 00 	moveq	r8,r9
8000b54c:	f9 bc 00 10 	moveq	r12,16
8000b550:	f9 bc 01 00 	movne	r12,0
8000b554:	10 9a       	mov	r10,r8
8000b556:	f0 09 15 08 	lsl	r9,r8,0x8
8000b55a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b55e:	f7 bc 00 f8 	subeq	r12,-8
8000b562:	f2 08 17 00 	moveq	r8,r9
8000b566:	10 9a       	mov	r10,r8
8000b568:	f0 09 15 04 	lsl	r9,r8,0x4
8000b56c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b570:	f7 bc 00 fc 	subeq	r12,-4
8000b574:	f2 08 17 00 	moveq	r8,r9
8000b578:	10 9a       	mov	r10,r8
8000b57a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b57e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b582:	f7 bc 00 fe 	subeq	r12,-2
8000b586:	f2 08 17 00 	moveq	r8,r9
8000b58a:	58 08       	cp.w	r8,0
8000b58c:	5e 5c       	retlt	r12
8000b58e:	ed b8 00 1e 	bld	r8,0x1e
8000b592:	f9 bc 01 20 	movne	r12,32
8000b596:	f7 bc 00 ff 	subeq	r12,-1
8000b59a:	5e fc       	retal	r12

8000b59c <__lo0bits>:
8000b59c:	18 99       	mov	r9,r12
8000b59e:	78 08       	ld.w	r8,r12[0x0]
8000b5a0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b5a4:	c1 50       	breq	8000b5ce <__lo0bits+0x32>
8000b5a6:	ed b8 00 00 	bld	r8,0x0
8000b5aa:	c0 21       	brne	8000b5ae <__lo0bits+0x12>
8000b5ac:	5e fd       	retal	0
8000b5ae:	10 9b       	mov	r11,r8
8000b5b0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b5b4:	e2 1b 00 02 	andl	r11,0x2,COH
8000b5b8:	a3 88       	lsr	r8,0x2
8000b5ba:	58 0b       	cp.w	r11,0
8000b5bc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b5c0:	f9 bc 01 01 	movne	r12,1
8000b5c4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b5c8:	f9 bc 00 02 	moveq	r12,2
8000b5cc:	5e fc       	retal	r12
8000b5ce:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b5d2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b5d6:	58 0a       	cp.w	r10,0
8000b5d8:	f6 08 17 00 	moveq	r8,r11
8000b5dc:	f9 bc 00 10 	moveq	r12,16
8000b5e0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b5e4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b5e8:	58 0b       	cp.w	r11,0
8000b5ea:	f7 bc 00 f8 	subeq	r12,-8
8000b5ee:	f4 08 17 00 	moveq	r8,r10
8000b5f2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b5f6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b5fa:	58 0b       	cp.w	r11,0
8000b5fc:	f7 bc 00 fc 	subeq	r12,-4
8000b600:	f4 08 17 00 	moveq	r8,r10
8000b604:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b608:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b60c:	58 0b       	cp.w	r11,0
8000b60e:	f7 bc 00 fe 	subeq	r12,-2
8000b612:	f4 08 17 00 	moveq	r8,r10
8000b616:	ed b8 00 00 	bld	r8,0x0
8000b61a:	c0 60       	breq	8000b626 <__lo0bits+0x8a>
8000b61c:	a1 98       	lsr	r8,0x1
8000b61e:	c0 31       	brne	8000b624 <__lo0bits+0x88>
8000b620:	32 0c       	mov	r12,32
8000b622:	5e fc       	retal	r12
8000b624:	2f fc       	sub	r12,-1
8000b626:	93 08       	st.w	r9[0x0],r8
8000b628:	5e fc       	retal	r12

8000b62a <__mcmp>:
8000b62a:	d4 01       	pushm	lr
8000b62c:	18 98       	mov	r8,r12
8000b62e:	76 49       	ld.w	r9,r11[0x10]
8000b630:	78 4c       	ld.w	r12,r12[0x10]
8000b632:	12 1c       	sub	r12,r9
8000b634:	c1 31       	brne	8000b65a <__mcmp+0x30>
8000b636:	2f b9       	sub	r9,-5
8000b638:	a3 69       	lsl	r9,0x2
8000b63a:	12 0b       	add	r11,r9
8000b63c:	f0 09 00 09 	add	r9,r8,r9
8000b640:	2e c8       	sub	r8,-20
8000b642:	13 4e       	ld.w	lr,--r9
8000b644:	17 4a       	ld.w	r10,--r11
8000b646:	14 3e       	cp.w	lr,r10
8000b648:	c0 60       	breq	8000b654 <__mcmp+0x2a>
8000b64a:	f9 bc 03 ff 	movlo	r12,-1
8000b64e:	f9 bc 02 01 	movhs	r12,1
8000b652:	d8 02       	popm	pc
8000b654:	10 39       	cp.w	r9,r8
8000b656:	fe 9b ff f6 	brhi	8000b642 <__mcmp+0x18>
8000b65a:	d8 02       	popm	pc

8000b65c <_Bfree>:
8000b65c:	d4 21       	pushm	r4-r7,lr
8000b65e:	18 97       	mov	r7,r12
8000b660:	16 95       	mov	r5,r11
8000b662:	78 96       	ld.w	r6,r12[0x24]
8000b664:	58 06       	cp.w	r6,0
8000b666:	c0 91       	brne	8000b678 <_Bfree+0x1c>
8000b668:	31 0c       	mov	r12,16
8000b66a:	fe b0 de 2b 	rcall	800072c0 <malloc>
8000b66e:	99 36       	st.w	r12[0xc],r6
8000b670:	8f 9c       	st.w	r7[0x24],r12
8000b672:	99 16       	st.w	r12[0x4],r6
8000b674:	99 26       	st.w	r12[0x8],r6
8000b676:	99 06       	st.w	r12[0x0],r6
8000b678:	58 05       	cp.w	r5,0
8000b67a:	c0 90       	breq	8000b68c <_Bfree+0x30>
8000b67c:	6a 19       	ld.w	r9,r5[0x4]
8000b67e:	6e 98       	ld.w	r8,r7[0x24]
8000b680:	70 38       	ld.w	r8,r8[0xc]
8000b682:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b686:	8b 0a       	st.w	r5[0x0],r10
8000b688:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b68c:	d8 22       	popm	r4-r7,pc
8000b68e:	d7 03       	nop

8000b690 <_Balloc>:
8000b690:	d4 21       	pushm	r4-r7,lr
8000b692:	18 97       	mov	r7,r12
8000b694:	16 96       	mov	r6,r11
8000b696:	78 95       	ld.w	r5,r12[0x24]
8000b698:	58 05       	cp.w	r5,0
8000b69a:	c0 91       	brne	8000b6ac <_Balloc+0x1c>
8000b69c:	31 0c       	mov	r12,16
8000b69e:	fe b0 de 11 	rcall	800072c0 <malloc>
8000b6a2:	99 35       	st.w	r12[0xc],r5
8000b6a4:	8f 9c       	st.w	r7[0x24],r12
8000b6a6:	99 15       	st.w	r12[0x4],r5
8000b6a8:	99 25       	st.w	r12[0x8],r5
8000b6aa:	99 05       	st.w	r12[0x0],r5
8000b6ac:	6e 95       	ld.w	r5,r7[0x24]
8000b6ae:	6a 38       	ld.w	r8,r5[0xc]
8000b6b0:	58 08       	cp.w	r8,0
8000b6b2:	c0 b1       	brne	8000b6c8 <_Balloc+0x38>
8000b6b4:	31 0a       	mov	r10,16
8000b6b6:	30 4b       	mov	r11,4
8000b6b8:	0e 9c       	mov	r12,r7
8000b6ba:	e0 a0 02 9b 	rcall	8000bbf0 <_calloc_r>
8000b6be:	8b 3c       	st.w	r5[0xc],r12
8000b6c0:	6e 98       	ld.w	r8,r7[0x24]
8000b6c2:	70 3c       	ld.w	r12,r8[0xc]
8000b6c4:	58 0c       	cp.w	r12,0
8000b6c6:	c1 b0       	breq	8000b6fc <_Balloc+0x6c>
8000b6c8:	6e 98       	ld.w	r8,r7[0x24]
8000b6ca:	70 38       	ld.w	r8,r8[0xc]
8000b6cc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b6d0:	70 0c       	ld.w	r12,r8[0x0]
8000b6d2:	58 0c       	cp.w	r12,0
8000b6d4:	c0 40       	breq	8000b6dc <_Balloc+0x4c>
8000b6d6:	78 09       	ld.w	r9,r12[0x0]
8000b6d8:	91 09       	st.w	r8[0x0],r9
8000b6da:	c0 e8       	rjmp	8000b6f6 <_Balloc+0x66>
8000b6dc:	0e 9c       	mov	r12,r7
8000b6de:	30 17       	mov	r7,1
8000b6e0:	0e 9b       	mov	r11,r7
8000b6e2:	ee 06 09 47 	lsl	r7,r7,r6
8000b6e6:	ee ca ff fb 	sub	r10,r7,-5
8000b6ea:	a3 6a       	lsl	r10,0x2
8000b6ec:	e0 a0 02 82 	rcall	8000bbf0 <_calloc_r>
8000b6f0:	c0 60       	breq	8000b6fc <_Balloc+0x6c>
8000b6f2:	99 16       	st.w	r12[0x4],r6
8000b6f4:	99 27       	st.w	r12[0x8],r7
8000b6f6:	30 08       	mov	r8,0
8000b6f8:	99 38       	st.w	r12[0xc],r8
8000b6fa:	99 48       	st.w	r12[0x10],r8
8000b6fc:	d8 22       	popm	r4-r7,pc
8000b6fe:	d7 03       	nop

8000b700 <__d2b>:
8000b700:	d4 31       	pushm	r0-r7,lr
8000b702:	20 2d       	sub	sp,8
8000b704:	16 93       	mov	r3,r11
8000b706:	12 96       	mov	r6,r9
8000b708:	10 95       	mov	r5,r8
8000b70a:	14 92       	mov	r2,r10
8000b70c:	30 1b       	mov	r11,1
8000b70e:	cc 1f       	rcall	8000b690 <_Balloc>
8000b710:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b714:	50 09       	stdsp	sp[0x0],r9
8000b716:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b71a:	b5 a9       	sbr	r9,0x14
8000b71c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b720:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b724:	18 94       	mov	r4,r12
8000b726:	58 02       	cp.w	r2,0
8000b728:	c1 d0       	breq	8000b762 <__d2b+0x62>
8000b72a:	fa cc ff f8 	sub	r12,sp,-8
8000b72e:	18 d2       	st.w	--r12,r2
8000b730:	c3 6f       	rcall	8000b59c <__lo0bits>
8000b732:	40 18       	lddsp	r8,sp[0x4]
8000b734:	c0 d0       	breq	8000b74e <__d2b+0x4e>
8000b736:	40 09       	lddsp	r9,sp[0x0]
8000b738:	f8 0a 11 20 	rsub	r10,r12,32
8000b73c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b740:	f5 e8 10 08 	or	r8,r10,r8
8000b744:	89 58       	st.w	r4[0x14],r8
8000b746:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b74a:	50 09       	stdsp	sp[0x0],r9
8000b74c:	c0 28       	rjmp	8000b750 <__d2b+0x50>
8000b74e:	89 58       	st.w	r4[0x14],r8
8000b750:	40 08       	lddsp	r8,sp[0x0]
8000b752:	58 08       	cp.w	r8,0
8000b754:	f9 b3 01 02 	movne	r3,2
8000b758:	f9 b3 00 01 	moveq	r3,1
8000b75c:	89 68       	st.w	r4[0x18],r8
8000b75e:	89 43       	st.w	r4[0x10],r3
8000b760:	c0 88       	rjmp	8000b770 <__d2b+0x70>
8000b762:	1a 9c       	mov	r12,sp
8000b764:	c1 cf       	rcall	8000b59c <__lo0bits>
8000b766:	30 13       	mov	r3,1
8000b768:	40 08       	lddsp	r8,sp[0x0]
8000b76a:	2e 0c       	sub	r12,-32
8000b76c:	89 43       	st.w	r4[0x10],r3
8000b76e:	89 58       	st.w	r4[0x14],r8
8000b770:	58 01       	cp.w	r1,0
8000b772:	c0 90       	breq	8000b784 <__d2b+0x84>
8000b774:	e2 c1 04 33 	sub	r1,r1,1075
8000b778:	18 01       	add	r1,r12
8000b77a:	8d 01       	st.w	r6[0x0],r1
8000b77c:	f8 0c 11 35 	rsub	r12,r12,53
8000b780:	8b 0c       	st.w	r5[0x0],r12
8000b782:	c0 c8       	rjmp	8000b79a <__d2b+0x9a>
8000b784:	e6 c8 ff fc 	sub	r8,r3,-4
8000b788:	f8 cc 04 32 	sub	r12,r12,1074
8000b78c:	a5 73       	lsl	r3,0x5
8000b78e:	8d 0c       	st.w	r6[0x0],r12
8000b790:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b794:	cd 4e       	rcall	8000b53c <__hi0bits>
8000b796:	18 13       	sub	r3,r12
8000b798:	8b 03       	st.w	r5[0x0],r3
8000b79a:	08 9c       	mov	r12,r4
8000b79c:	2f ed       	sub	sp,-8
8000b79e:	d8 32       	popm	r0-r7,pc

8000b7a0 <__mdiff>:
8000b7a0:	d4 31       	pushm	r0-r7,lr
8000b7a2:	74 48       	ld.w	r8,r10[0x10]
8000b7a4:	76 45       	ld.w	r5,r11[0x10]
8000b7a6:	16 97       	mov	r7,r11
8000b7a8:	14 96       	mov	r6,r10
8000b7aa:	10 15       	sub	r5,r8
8000b7ac:	c1 31       	brne	8000b7d2 <__mdiff+0x32>
8000b7ae:	2f b8       	sub	r8,-5
8000b7b0:	ee ce ff ec 	sub	lr,r7,-20
8000b7b4:	a3 68       	lsl	r8,0x2
8000b7b6:	f4 08 00 0b 	add	r11,r10,r8
8000b7ba:	ee 08 00 08 	add	r8,r7,r8
8000b7be:	11 4a       	ld.w	r10,--r8
8000b7c0:	17 49       	ld.w	r9,--r11
8000b7c2:	12 3a       	cp.w	r10,r9
8000b7c4:	c0 30       	breq	8000b7ca <__mdiff+0x2a>
8000b7c6:	c0 e2       	brcc	8000b7e2 <__mdiff+0x42>
8000b7c8:	c0 78       	rjmp	8000b7d6 <__mdiff+0x36>
8000b7ca:	1c 38       	cp.w	r8,lr
8000b7cc:	fe 9b ff f9 	brhi	8000b7be <__mdiff+0x1e>
8000b7d0:	c4 98       	rjmp	8000b862 <__mdiff+0xc2>
8000b7d2:	58 05       	cp.w	r5,0
8000b7d4:	c0 64       	brge	8000b7e0 <__mdiff+0x40>
8000b7d6:	0e 98       	mov	r8,r7
8000b7d8:	30 15       	mov	r5,1
8000b7da:	0c 97       	mov	r7,r6
8000b7dc:	10 96       	mov	r6,r8
8000b7de:	c0 28       	rjmp	8000b7e2 <__mdiff+0x42>
8000b7e0:	30 05       	mov	r5,0
8000b7e2:	6e 1b       	ld.w	r11,r7[0x4]
8000b7e4:	c5 6f       	rcall	8000b690 <_Balloc>
8000b7e6:	6e 49       	ld.w	r9,r7[0x10]
8000b7e8:	6c 44       	ld.w	r4,r6[0x10]
8000b7ea:	99 35       	st.w	r12[0xc],r5
8000b7ec:	2f b4       	sub	r4,-5
8000b7ee:	f2 c5 ff fb 	sub	r5,r9,-5
8000b7f2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b7f6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b7fa:	2e c6       	sub	r6,-20
8000b7fc:	2e c7       	sub	r7,-20
8000b7fe:	f8 c8 ff ec 	sub	r8,r12,-20
8000b802:	30 0a       	mov	r10,0
8000b804:	0f 0e       	ld.w	lr,r7++
8000b806:	0d 0b       	ld.w	r11,r6++
8000b808:	fc 02 16 10 	lsr	r2,lr,0x10
8000b80c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b810:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b814:	e4 03 01 03 	sub	r3,r2,r3
8000b818:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b81c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b820:	f6 0a 00 0a 	add	r10,r11,r10
8000b824:	b0 1a       	st.h	r8[0x2],r10
8000b826:	b1 4a       	asr	r10,0x10
8000b828:	e6 0a 00 0a 	add	r10,r3,r10
8000b82c:	b0 0a       	st.h	r8[0x0],r10
8000b82e:	2f c8       	sub	r8,-4
8000b830:	b1 4a       	asr	r10,0x10
8000b832:	08 36       	cp.w	r6,r4
8000b834:	ce 83       	brcs	8000b804 <__mdiff+0x64>
8000b836:	c0 d8       	rjmp	8000b850 <__mdiff+0xb0>
8000b838:	0f 0b       	ld.w	r11,r7++
8000b83a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b83e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b842:	16 0a       	add	r10,r11
8000b844:	b0 1a       	st.h	r8[0x2],r10
8000b846:	b1 4a       	asr	r10,0x10
8000b848:	1c 0a       	add	r10,lr
8000b84a:	b0 0a       	st.h	r8[0x0],r10
8000b84c:	2f c8       	sub	r8,-4
8000b84e:	b1 4a       	asr	r10,0x10
8000b850:	0a 37       	cp.w	r7,r5
8000b852:	cf 33       	brcs	8000b838 <__mdiff+0x98>
8000b854:	c0 28       	rjmp	8000b858 <__mdiff+0xb8>
8000b856:	20 19       	sub	r9,1
8000b858:	11 4a       	ld.w	r10,--r8
8000b85a:	58 0a       	cp.w	r10,0
8000b85c:	cf d0       	breq	8000b856 <__mdiff+0xb6>
8000b85e:	99 49       	st.w	r12[0x10],r9
8000b860:	d8 32       	popm	r0-r7,pc
8000b862:	30 0b       	mov	r11,0
8000b864:	c1 6f       	rcall	8000b690 <_Balloc>
8000b866:	30 18       	mov	r8,1
8000b868:	99 48       	st.w	r12[0x10],r8
8000b86a:	30 08       	mov	r8,0
8000b86c:	99 58       	st.w	r12[0x14],r8
8000b86e:	d8 32       	popm	r0-r7,pc

8000b870 <__lshift>:
8000b870:	d4 31       	pushm	r0-r7,lr
8000b872:	16 97       	mov	r7,r11
8000b874:	76 46       	ld.w	r6,r11[0x10]
8000b876:	f4 02 14 05 	asr	r2,r10,0x5
8000b87a:	2f f6       	sub	r6,-1
8000b87c:	14 93       	mov	r3,r10
8000b87e:	18 94       	mov	r4,r12
8000b880:	04 06       	add	r6,r2
8000b882:	76 1b       	ld.w	r11,r11[0x4]
8000b884:	6e 28       	ld.w	r8,r7[0x8]
8000b886:	c0 38       	rjmp	8000b88c <__lshift+0x1c>
8000b888:	2f fb       	sub	r11,-1
8000b88a:	a1 78       	lsl	r8,0x1
8000b88c:	10 36       	cp.w	r6,r8
8000b88e:	fe 99 ff fd 	brgt	8000b888 <__lshift+0x18>
8000b892:	08 9c       	mov	r12,r4
8000b894:	cf ee       	rcall	8000b690 <_Balloc>
8000b896:	30 09       	mov	r9,0
8000b898:	18 95       	mov	r5,r12
8000b89a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b89e:	12 9a       	mov	r10,r9
8000b8a0:	c0 38       	rjmp	8000b8a6 <__lshift+0x36>
8000b8a2:	10 aa       	st.w	r8++,r10
8000b8a4:	2f f9       	sub	r9,-1
8000b8a6:	04 39       	cp.w	r9,r2
8000b8a8:	cf d5       	brlt	8000b8a2 <__lshift+0x32>
8000b8aa:	6e 4b       	ld.w	r11,r7[0x10]
8000b8ac:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b8b0:	2f bb       	sub	r11,-5
8000b8b2:	ee c9 ff ec 	sub	r9,r7,-20
8000b8b6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b8ba:	58 03       	cp.w	r3,0
8000b8bc:	c1 30       	breq	8000b8e2 <__lshift+0x72>
8000b8be:	e6 0c 11 20 	rsub	r12,r3,32
8000b8c2:	30 0a       	mov	r10,0
8000b8c4:	72 02       	ld.w	r2,r9[0x0]
8000b8c6:	e4 03 09 42 	lsl	r2,r2,r3
8000b8ca:	04 4a       	or	r10,r2
8000b8cc:	10 aa       	st.w	r8++,r10
8000b8ce:	13 0a       	ld.w	r10,r9++
8000b8d0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b8d4:	16 39       	cp.w	r9,r11
8000b8d6:	cf 73       	brcs	8000b8c4 <__lshift+0x54>
8000b8d8:	91 0a       	st.w	r8[0x0],r10
8000b8da:	58 0a       	cp.w	r10,0
8000b8dc:	c0 70       	breq	8000b8ea <__lshift+0x7a>
8000b8de:	2f f6       	sub	r6,-1
8000b8e0:	c0 58       	rjmp	8000b8ea <__lshift+0x7a>
8000b8e2:	13 0a       	ld.w	r10,r9++
8000b8e4:	10 aa       	st.w	r8++,r10
8000b8e6:	16 39       	cp.w	r9,r11
8000b8e8:	cf d3       	brcs	8000b8e2 <__lshift+0x72>
8000b8ea:	08 9c       	mov	r12,r4
8000b8ec:	20 16       	sub	r6,1
8000b8ee:	0e 9b       	mov	r11,r7
8000b8f0:	8b 46       	st.w	r5[0x10],r6
8000b8f2:	cb 5e       	rcall	8000b65c <_Bfree>
8000b8f4:	0a 9c       	mov	r12,r5
8000b8f6:	d8 32       	popm	r0-r7,pc

8000b8f8 <__multiply>:
8000b8f8:	d4 31       	pushm	r0-r7,lr
8000b8fa:	20 2d       	sub	sp,8
8000b8fc:	76 49       	ld.w	r9,r11[0x10]
8000b8fe:	74 48       	ld.w	r8,r10[0x10]
8000b900:	16 96       	mov	r6,r11
8000b902:	14 95       	mov	r5,r10
8000b904:	10 39       	cp.w	r9,r8
8000b906:	ec 08 17 50 	movlt	r8,r6
8000b90a:	ea 06 17 50 	movlt	r6,r5
8000b90e:	f0 05 17 50 	movlt	r5,r8
8000b912:	6c 28       	ld.w	r8,r6[0x8]
8000b914:	76 43       	ld.w	r3,r11[0x10]
8000b916:	74 42       	ld.w	r2,r10[0x10]
8000b918:	76 1b       	ld.w	r11,r11[0x4]
8000b91a:	e4 03 00 07 	add	r7,r2,r3
8000b91e:	10 37       	cp.w	r7,r8
8000b920:	f7 bb 09 ff 	subgt	r11,-1
8000b924:	cb 6e       	rcall	8000b690 <_Balloc>
8000b926:	ee c4 ff fb 	sub	r4,r7,-5
8000b92a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b92e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b932:	30 0a       	mov	r10,0
8000b934:	12 98       	mov	r8,r9
8000b936:	c0 28       	rjmp	8000b93a <__multiply+0x42>
8000b938:	10 aa       	st.w	r8++,r10
8000b93a:	08 38       	cp.w	r8,r4
8000b93c:	cf e3       	brcs	8000b938 <__multiply+0x40>
8000b93e:	2f b3       	sub	r3,-5
8000b940:	2f b2       	sub	r2,-5
8000b942:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b946:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b94a:	ec cb ff ec 	sub	r11,r6,-20
8000b94e:	50 12       	stdsp	sp[0x4],r2
8000b950:	ea ca ff ec 	sub	r10,r5,-20
8000b954:	c4 48       	rjmp	8000b9dc <__multiply+0xe4>
8000b956:	94 95       	ld.uh	r5,r10[0x2]
8000b958:	58 05       	cp.w	r5,0
8000b95a:	c2 00       	breq	8000b99a <__multiply+0xa2>
8000b95c:	12 98       	mov	r8,r9
8000b95e:	16 96       	mov	r6,r11
8000b960:	30 0e       	mov	lr,0
8000b962:	50 09       	stdsp	sp[0x0],r9
8000b964:	0d 02       	ld.w	r2,r6++
8000b966:	e4 00 16 10 	lsr	r0,r2,0x10
8000b96a:	70 01       	ld.w	r1,r8[0x0]
8000b96c:	70 09       	ld.w	r9,r8[0x0]
8000b96e:	b1 81       	lsr	r1,0x10
8000b970:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b974:	e0 05 03 41 	mac	r1,r0,r5
8000b978:	ab 32       	mul	r2,r5
8000b97a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b97e:	00 02       	add	r2,r0
8000b980:	e4 0e 00 0e 	add	lr,r2,lr
8000b984:	b0 1e       	st.h	r8[0x2],lr
8000b986:	b1 8e       	lsr	lr,0x10
8000b988:	1c 01       	add	r1,lr
8000b98a:	b0 01       	st.h	r8[0x0],r1
8000b98c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b990:	2f c8       	sub	r8,-4
8000b992:	06 36       	cp.w	r6,r3
8000b994:	ce 83       	brcs	8000b964 <__multiply+0x6c>
8000b996:	40 09       	lddsp	r9,sp[0x0]
8000b998:	91 0e       	st.w	r8[0x0],lr
8000b99a:	94 86       	ld.uh	r6,r10[0x0]
8000b99c:	58 06       	cp.w	r6,0
8000b99e:	c1 d0       	breq	8000b9d8 <__multiply+0xe0>
8000b9a0:	72 02       	ld.w	r2,r9[0x0]
8000b9a2:	12 98       	mov	r8,r9
8000b9a4:	16 9e       	mov	lr,r11
8000b9a6:	30 05       	mov	r5,0
8000b9a8:	b0 12       	st.h	r8[0x2],r2
8000b9aa:	1d 01       	ld.w	r1,lr++
8000b9ac:	90 82       	ld.uh	r2,r8[0x0]
8000b9ae:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b9b2:	ad 30       	mul	r0,r6
8000b9b4:	e0 02 00 02 	add	r2,r0,r2
8000b9b8:	e4 05 00 05 	add	r5,r2,r5
8000b9bc:	b0 05       	st.h	r8[0x0],r5
8000b9be:	b1 85       	lsr	r5,0x10
8000b9c0:	b1 81       	lsr	r1,0x10
8000b9c2:	2f c8       	sub	r8,-4
8000b9c4:	ad 31       	mul	r1,r6
8000b9c6:	90 92       	ld.uh	r2,r8[0x2]
8000b9c8:	e2 02 00 02 	add	r2,r1,r2
8000b9cc:	0a 02       	add	r2,r5
8000b9ce:	e4 05 16 10 	lsr	r5,r2,0x10
8000b9d2:	06 3e       	cp.w	lr,r3
8000b9d4:	ce a3       	brcs	8000b9a8 <__multiply+0xb0>
8000b9d6:	91 02       	st.w	r8[0x0],r2
8000b9d8:	2f ca       	sub	r10,-4
8000b9da:	2f c9       	sub	r9,-4
8000b9dc:	40 18       	lddsp	r8,sp[0x4]
8000b9de:	10 3a       	cp.w	r10,r8
8000b9e0:	cb b3       	brcs	8000b956 <__multiply+0x5e>
8000b9e2:	c0 28       	rjmp	8000b9e6 <__multiply+0xee>
8000b9e4:	20 17       	sub	r7,1
8000b9e6:	58 07       	cp.w	r7,0
8000b9e8:	e0 8a 00 05 	brle	8000b9f2 <__multiply+0xfa>
8000b9ec:	09 48       	ld.w	r8,--r4
8000b9ee:	58 08       	cp.w	r8,0
8000b9f0:	cf a0       	breq	8000b9e4 <__multiply+0xec>
8000b9f2:	99 47       	st.w	r12[0x10],r7
8000b9f4:	2f ed       	sub	sp,-8
8000b9f6:	d8 32       	popm	r0-r7,pc

8000b9f8 <__i2b>:
8000b9f8:	d4 21       	pushm	r4-r7,lr
8000b9fa:	16 97       	mov	r7,r11
8000b9fc:	30 1b       	mov	r11,1
8000b9fe:	c4 9e       	rcall	8000b690 <_Balloc>
8000ba00:	30 19       	mov	r9,1
8000ba02:	99 57       	st.w	r12[0x14],r7
8000ba04:	99 49       	st.w	r12[0x10],r9
8000ba06:	d8 22       	popm	r4-r7,pc

8000ba08 <__multadd>:
8000ba08:	d4 31       	pushm	r0-r7,lr
8000ba0a:	30 08       	mov	r8,0
8000ba0c:	12 95       	mov	r5,r9
8000ba0e:	16 97       	mov	r7,r11
8000ba10:	18 96       	mov	r6,r12
8000ba12:	76 44       	ld.w	r4,r11[0x10]
8000ba14:	f6 c9 ff ec 	sub	r9,r11,-20
8000ba18:	72 0b       	ld.w	r11,r9[0x0]
8000ba1a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ba1e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ba22:	f4 0c 02 4c 	mul	r12,r10,r12
8000ba26:	f4 0b 03 45 	mac	r5,r10,r11
8000ba2a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ba2e:	b1 85       	lsr	r5,0x10
8000ba30:	18 05       	add	r5,r12
8000ba32:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ba36:	f8 0b 00 0b 	add	r11,r12,r11
8000ba3a:	12 ab       	st.w	r9++,r11
8000ba3c:	2f f8       	sub	r8,-1
8000ba3e:	b1 85       	lsr	r5,0x10
8000ba40:	08 38       	cp.w	r8,r4
8000ba42:	ce b5       	brlt	8000ba18 <__multadd+0x10>
8000ba44:	58 05       	cp.w	r5,0
8000ba46:	c1 c0       	breq	8000ba7e <__multadd+0x76>
8000ba48:	6e 28       	ld.w	r8,r7[0x8]
8000ba4a:	10 34       	cp.w	r4,r8
8000ba4c:	c1 35       	brlt	8000ba72 <__multadd+0x6a>
8000ba4e:	6e 1b       	ld.w	r11,r7[0x4]
8000ba50:	0c 9c       	mov	r12,r6
8000ba52:	2f fb       	sub	r11,-1
8000ba54:	c1 ee       	rcall	8000b690 <_Balloc>
8000ba56:	6e 4a       	ld.w	r10,r7[0x10]
8000ba58:	ee cb ff f4 	sub	r11,r7,-12
8000ba5c:	18 93       	mov	r3,r12
8000ba5e:	2f ea       	sub	r10,-2
8000ba60:	2f 4c       	sub	r12,-12
8000ba62:	a3 6a       	lsl	r10,0x2
8000ba64:	fe b0 de 65 	rcall	8000772e <memcpy>
8000ba68:	0e 9b       	mov	r11,r7
8000ba6a:	0c 9c       	mov	r12,r6
8000ba6c:	fe b0 fd f8 	rcall	8000b65c <_Bfree>
8000ba70:	06 97       	mov	r7,r3
8000ba72:	e8 c8 ff ff 	sub	r8,r4,-1
8000ba76:	2f b4       	sub	r4,-5
8000ba78:	8f 48       	st.w	r7[0x10],r8
8000ba7a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ba7e:	0e 9c       	mov	r12,r7
8000ba80:	d8 32       	popm	r0-r7,pc
8000ba82:	d7 03       	nop

8000ba84 <__pow5mult>:
8000ba84:	d4 31       	pushm	r0-r7,lr
8000ba86:	14 96       	mov	r6,r10
8000ba88:	18 97       	mov	r7,r12
8000ba8a:	16 94       	mov	r4,r11
8000ba8c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ba90:	c0 90       	breq	8000baa2 <__pow5mult+0x1e>
8000ba92:	20 18       	sub	r8,1
8000ba94:	fe c9 d5 e0 	sub	r9,pc,-10784
8000ba98:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ba9c:	30 09       	mov	r9,0
8000ba9e:	cb 5f       	rcall	8000ba08 <__multadd>
8000baa0:	18 94       	mov	r4,r12
8000baa2:	a3 46       	asr	r6,0x2
8000baa4:	c3 40       	breq	8000bb0c <__pow5mult+0x88>
8000baa6:	6e 95       	ld.w	r5,r7[0x24]
8000baa8:	58 05       	cp.w	r5,0
8000baaa:	c0 91       	brne	8000babc <__pow5mult+0x38>
8000baac:	31 0c       	mov	r12,16
8000baae:	fe b0 dc 09 	rcall	800072c0 <malloc>
8000bab2:	99 35       	st.w	r12[0xc],r5
8000bab4:	8f 9c       	st.w	r7[0x24],r12
8000bab6:	99 15       	st.w	r12[0x4],r5
8000bab8:	99 25       	st.w	r12[0x8],r5
8000baba:	99 05       	st.w	r12[0x0],r5
8000babc:	6e 93       	ld.w	r3,r7[0x24]
8000babe:	66 25       	ld.w	r5,r3[0x8]
8000bac0:	58 05       	cp.w	r5,0
8000bac2:	c0 c1       	brne	8000bada <__pow5mult+0x56>
8000bac4:	e0 6b 02 71 	mov	r11,625
8000bac8:	0e 9c       	mov	r12,r7
8000baca:	c9 7f       	rcall	8000b9f8 <__i2b>
8000bacc:	87 2c       	st.w	r3[0x8],r12
8000bace:	30 08       	mov	r8,0
8000bad0:	18 95       	mov	r5,r12
8000bad2:	99 08       	st.w	r12[0x0],r8
8000bad4:	c0 38       	rjmp	8000bada <__pow5mult+0x56>
8000bad6:	06 9c       	mov	r12,r3
8000bad8:	18 95       	mov	r5,r12
8000bada:	ed b6 00 00 	bld	r6,0x0
8000bade:	c0 b1       	brne	8000baf4 <__pow5mult+0x70>
8000bae0:	08 9b       	mov	r11,r4
8000bae2:	0a 9a       	mov	r10,r5
8000bae4:	0e 9c       	mov	r12,r7
8000bae6:	c0 9f       	rcall	8000b8f8 <__multiply>
8000bae8:	08 9b       	mov	r11,r4
8000baea:	18 93       	mov	r3,r12
8000baec:	0e 9c       	mov	r12,r7
8000baee:	06 94       	mov	r4,r3
8000baf0:	fe b0 fd b6 	rcall	8000b65c <_Bfree>
8000baf4:	a1 56       	asr	r6,0x1
8000baf6:	c0 b0       	breq	8000bb0c <__pow5mult+0x88>
8000baf8:	6a 03       	ld.w	r3,r5[0x0]
8000bafa:	58 03       	cp.w	r3,0
8000bafc:	ce d1       	brne	8000bad6 <__pow5mult+0x52>
8000bafe:	0a 9a       	mov	r10,r5
8000bb00:	0a 9b       	mov	r11,r5
8000bb02:	0e 9c       	mov	r12,r7
8000bb04:	cf ae       	rcall	8000b8f8 <__multiply>
8000bb06:	8b 0c       	st.w	r5[0x0],r12
8000bb08:	99 03       	st.w	r12[0x0],r3
8000bb0a:	ce 7b       	rjmp	8000bad8 <__pow5mult+0x54>
8000bb0c:	08 9c       	mov	r12,r4
8000bb0e:	d8 32       	popm	r0-r7,pc

8000bb10 <__isinfd>:
8000bb10:	14 98       	mov	r8,r10
8000bb12:	fc 19 7f f0 	movh	r9,0x7ff0
8000bb16:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bb1a:	f0 0b 11 00 	rsub	r11,r8,0
8000bb1e:	f7 e8 10 08 	or	r8,r11,r8
8000bb22:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bb26:	f2 08 01 08 	sub	r8,r9,r8
8000bb2a:	f0 0c 11 00 	rsub	r12,r8,0
8000bb2e:	f9 e8 10 08 	or	r8,r12,r8
8000bb32:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bb36:	2f fc       	sub	r12,-1
8000bb38:	5e fc       	retal	r12

8000bb3a <__isnand>:
8000bb3a:	14 98       	mov	r8,r10
8000bb3c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bb40:	f0 0c 11 00 	rsub	r12,r8,0
8000bb44:	10 4c       	or	r12,r8
8000bb46:	fc 18 7f f0 	movh	r8,0x7ff0
8000bb4a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bb4e:	f0 0c 01 0c 	sub	r12,r8,r12
8000bb52:	bf 9c       	lsr	r12,0x1f
8000bb54:	5e fc       	retal	r12
8000bb56:	d7 03       	nop

8000bb58 <__sclose>:
8000bb58:	d4 01       	pushm	lr
8000bb5a:	96 7b       	ld.sh	r11,r11[0xe]
8000bb5c:	c7 6c       	rcall	8000bc48 <_close_r>
8000bb5e:	d8 02       	popm	pc

8000bb60 <__sseek>:
8000bb60:	d4 21       	pushm	r4-r7,lr
8000bb62:	16 97       	mov	r7,r11
8000bb64:	96 7b       	ld.sh	r11,r11[0xe]
8000bb66:	cf 7c       	rcall	8000bd54 <_lseek_r>
8000bb68:	8e 68       	ld.sh	r8,r7[0xc]
8000bb6a:	10 99       	mov	r9,r8
8000bb6c:	ad c8       	cbr	r8,0xc
8000bb6e:	ad a9       	sbr	r9,0xc
8000bb70:	5b fc       	cp.w	r12,-1
8000bb72:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bb76:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bb7a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bb7e:	d8 22       	popm	r4-r7,pc

8000bb80 <__swrite>:
8000bb80:	d4 21       	pushm	r4-r7,lr
8000bb82:	96 68       	ld.sh	r8,r11[0xc]
8000bb84:	16 97       	mov	r7,r11
8000bb86:	14 95       	mov	r5,r10
8000bb88:	12 94       	mov	r4,r9
8000bb8a:	e2 18 01 00 	andl	r8,0x100,COH
8000bb8e:	18 96       	mov	r6,r12
8000bb90:	c0 50       	breq	8000bb9a <__swrite+0x1a>
8000bb92:	30 29       	mov	r9,2
8000bb94:	30 0a       	mov	r10,0
8000bb96:	96 7b       	ld.sh	r11,r11[0xe]
8000bb98:	cd ec       	rcall	8000bd54 <_lseek_r>
8000bb9a:	8e 68       	ld.sh	r8,r7[0xc]
8000bb9c:	ad c8       	cbr	r8,0xc
8000bb9e:	08 99       	mov	r9,r4
8000bba0:	0a 9a       	mov	r10,r5
8000bba2:	8e 7b       	ld.sh	r11,r7[0xe]
8000bba4:	0c 9c       	mov	r12,r6
8000bba6:	ae 68       	st.h	r7[0xc],r8
8000bba8:	c1 0c       	rcall	8000bbc8 <_write_r>
8000bbaa:	d8 22       	popm	r4-r7,pc

8000bbac <__sread>:
8000bbac:	d4 21       	pushm	r4-r7,lr
8000bbae:	16 97       	mov	r7,r11
8000bbb0:	96 7b       	ld.sh	r11,r11[0xe]
8000bbb2:	ce 5c       	rcall	8000bd7c <_read_r>
8000bbb4:	c0 65       	brlt	8000bbc0 <__sread+0x14>
8000bbb6:	6f 58       	ld.w	r8,r7[0x54]
8000bbb8:	18 08       	add	r8,r12
8000bbba:	ef 48 00 54 	st.w	r7[84],r8
8000bbbe:	d8 22       	popm	r4-r7,pc
8000bbc0:	8e 68       	ld.sh	r8,r7[0xc]
8000bbc2:	ad c8       	cbr	r8,0xc
8000bbc4:	ae 68       	st.h	r7[0xc],r8
8000bbc6:	d8 22       	popm	r4-r7,pc

8000bbc8 <_write_r>:
8000bbc8:	d4 21       	pushm	r4-r7,lr
8000bbca:	16 98       	mov	r8,r11
8000bbcc:	18 97       	mov	r7,r12
8000bbce:	10 9c       	mov	r12,r8
8000bbd0:	30 08       	mov	r8,0
8000bbd2:	14 9b       	mov	r11,r10
8000bbd4:	e0 66 63 98 	mov	r6,25496
8000bbd8:	12 9a       	mov	r10,r9
8000bbda:	8d 08       	st.w	r6[0x0],r8
8000bbdc:	fe b0 d1 24 	rcall	80005e24 <_write>
8000bbe0:	5b fc       	cp.w	r12,-1
8000bbe2:	c0 51       	brne	8000bbec <_write_r+0x24>
8000bbe4:	6c 08       	ld.w	r8,r6[0x0]
8000bbe6:	58 08       	cp.w	r8,0
8000bbe8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbec:	d8 22       	popm	r4-r7,pc
8000bbee:	d7 03       	nop

8000bbf0 <_calloc_r>:
8000bbf0:	d4 21       	pushm	r4-r7,lr
8000bbf2:	f4 0b 02 4b 	mul	r11,r10,r11
8000bbf6:	fe b0 db 6d 	rcall	800072d0 <_malloc_r>
8000bbfa:	18 97       	mov	r7,r12
8000bbfc:	c2 30       	breq	8000bc42 <_calloc_r+0x52>
8000bbfe:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bc02:	e0 1a ff fc 	andl	r10,0xfffc
8000bc06:	20 4a       	sub	r10,4
8000bc08:	e0 4a 00 24 	cp.w	r10,36
8000bc0c:	e0 8b 00 18 	brhi	8000bc3c <_calloc_r+0x4c>
8000bc10:	18 98       	mov	r8,r12
8000bc12:	59 3a       	cp.w	r10,19
8000bc14:	e0 88 00 0f 	brls	8000bc32 <_calloc_r+0x42>
8000bc18:	30 09       	mov	r9,0
8000bc1a:	10 a9       	st.w	r8++,r9
8000bc1c:	10 a9       	st.w	r8++,r9
8000bc1e:	59 ba       	cp.w	r10,27
8000bc20:	e0 88 00 09 	brls	8000bc32 <_calloc_r+0x42>
8000bc24:	10 a9       	st.w	r8++,r9
8000bc26:	10 a9       	st.w	r8++,r9
8000bc28:	e0 4a 00 24 	cp.w	r10,36
8000bc2c:	c0 31       	brne	8000bc32 <_calloc_r+0x42>
8000bc2e:	10 a9       	st.w	r8++,r9
8000bc30:	10 a9       	st.w	r8++,r9
8000bc32:	30 09       	mov	r9,0
8000bc34:	10 a9       	st.w	r8++,r9
8000bc36:	91 19       	st.w	r8[0x4],r9
8000bc38:	91 09       	st.w	r8[0x0],r9
8000bc3a:	c0 48       	rjmp	8000bc42 <_calloc_r+0x52>
8000bc3c:	30 0b       	mov	r11,0
8000bc3e:	fe b0 de 1c 	rcall	80007876 <memset>
8000bc42:	0e 9c       	mov	r12,r7
8000bc44:	d8 22       	popm	r4-r7,pc
8000bc46:	d7 03       	nop

8000bc48 <_close_r>:
8000bc48:	d4 21       	pushm	r4-r7,lr
8000bc4a:	30 08       	mov	r8,0
8000bc4c:	18 97       	mov	r7,r12
8000bc4e:	e0 66 63 98 	mov	r6,25496
8000bc52:	16 9c       	mov	r12,r11
8000bc54:	8d 08       	st.w	r6[0x0],r8
8000bc56:	fe b0 df c1 	rcall	80007bd8 <_close>
8000bc5a:	5b fc       	cp.w	r12,-1
8000bc5c:	c0 51       	brne	8000bc66 <_close_r+0x1e>
8000bc5e:	6c 08       	ld.w	r8,r6[0x0]
8000bc60:	58 08       	cp.w	r8,0
8000bc62:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc66:	d8 22       	popm	r4-r7,pc

8000bc68 <_fclose_r>:
8000bc68:	d4 21       	pushm	r4-r7,lr
8000bc6a:	18 96       	mov	r6,r12
8000bc6c:	16 97       	mov	r7,r11
8000bc6e:	58 0b       	cp.w	r11,0
8000bc70:	c0 31       	brne	8000bc76 <_fclose_r+0xe>
8000bc72:	16 95       	mov	r5,r11
8000bc74:	c5 38       	rjmp	8000bd1a <_fclose_r+0xb2>
8000bc76:	fe b0 f8 b5 	rcall	8000ade0 <__sfp_lock_acquire>
8000bc7a:	58 06       	cp.w	r6,0
8000bc7c:	c0 70       	breq	8000bc8a <_fclose_r+0x22>
8000bc7e:	6c 68       	ld.w	r8,r6[0x18]
8000bc80:	58 08       	cp.w	r8,0
8000bc82:	c0 41       	brne	8000bc8a <_fclose_r+0x22>
8000bc84:	0c 9c       	mov	r12,r6
8000bc86:	fe b0 f8 ff 	rcall	8000ae84 <__sinit>
8000bc8a:	fe c8 d8 7a 	sub	r8,pc,-10118
8000bc8e:	10 37       	cp.w	r7,r8
8000bc90:	c0 31       	brne	8000bc96 <_fclose_r+0x2e>
8000bc92:	6c 07       	ld.w	r7,r6[0x0]
8000bc94:	c0 c8       	rjmp	8000bcac <_fclose_r+0x44>
8000bc96:	fe c8 d8 66 	sub	r8,pc,-10138
8000bc9a:	10 37       	cp.w	r7,r8
8000bc9c:	c0 31       	brne	8000bca2 <_fclose_r+0x3a>
8000bc9e:	6c 17       	ld.w	r7,r6[0x4]
8000bca0:	c0 68       	rjmp	8000bcac <_fclose_r+0x44>
8000bca2:	fe c8 d8 52 	sub	r8,pc,-10158
8000bca6:	10 37       	cp.w	r7,r8
8000bca8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bcac:	8e 69       	ld.sh	r9,r7[0xc]
8000bcae:	30 08       	mov	r8,0
8000bcb0:	f0 09 19 00 	cp.h	r9,r8
8000bcb4:	c0 51       	brne	8000bcbe <_fclose_r+0x56>
8000bcb6:	fe b0 f8 96 	rcall	8000ade2 <__sfp_lock_release>
8000bcba:	30 05       	mov	r5,0
8000bcbc:	c2 f8       	rjmp	8000bd1a <_fclose_r+0xb2>
8000bcbe:	0e 9b       	mov	r11,r7
8000bcc0:	0c 9c       	mov	r12,r6
8000bcc2:	fe b0 f8 09 	rcall	8000acd4 <_fflush_r>
8000bcc6:	6e c8       	ld.w	r8,r7[0x30]
8000bcc8:	18 95       	mov	r5,r12
8000bcca:	58 08       	cp.w	r8,0
8000bccc:	c0 60       	breq	8000bcd8 <_fclose_r+0x70>
8000bcce:	6e 8b       	ld.w	r11,r7[0x20]
8000bcd0:	0c 9c       	mov	r12,r6
8000bcd2:	5d 18       	icall	r8
8000bcd4:	f9 b5 05 ff 	movlt	r5,-1
8000bcd8:	8e 68       	ld.sh	r8,r7[0xc]
8000bcda:	ed b8 00 07 	bld	r8,0x7
8000bcde:	c0 51       	brne	8000bce8 <_fclose_r+0x80>
8000bce0:	6e 4b       	ld.w	r11,r7[0x10]
8000bce2:	0c 9c       	mov	r12,r6
8000bce4:	fe b0 f9 6a 	rcall	8000afb8 <_free_r>
8000bce8:	6e db       	ld.w	r11,r7[0x34]
8000bcea:	58 0b       	cp.w	r11,0
8000bcec:	c0 a0       	breq	8000bd00 <_fclose_r+0x98>
8000bcee:	ee c8 ff bc 	sub	r8,r7,-68
8000bcf2:	10 3b       	cp.w	r11,r8
8000bcf4:	c0 40       	breq	8000bcfc <_fclose_r+0x94>
8000bcf6:	0c 9c       	mov	r12,r6
8000bcf8:	fe b0 f9 60 	rcall	8000afb8 <_free_r>
8000bcfc:	30 08       	mov	r8,0
8000bcfe:	8f d8       	st.w	r7[0x34],r8
8000bd00:	6f 2b       	ld.w	r11,r7[0x48]
8000bd02:	58 0b       	cp.w	r11,0
8000bd04:	c0 70       	breq	8000bd12 <_fclose_r+0xaa>
8000bd06:	0c 9c       	mov	r12,r6
8000bd08:	fe b0 f9 58 	rcall	8000afb8 <_free_r>
8000bd0c:	30 08       	mov	r8,0
8000bd0e:	ef 48 00 48 	st.w	r7[72],r8
8000bd12:	30 08       	mov	r8,0
8000bd14:	ae 68       	st.h	r7[0xc],r8
8000bd16:	fe b0 f8 66 	rcall	8000ade2 <__sfp_lock_release>
8000bd1a:	0a 9c       	mov	r12,r5
8000bd1c:	d8 22       	popm	r4-r7,pc
8000bd1e:	d7 03       	nop

8000bd20 <fclose>:
8000bd20:	d4 01       	pushm	lr
8000bd22:	e0 68 0a 3c 	mov	r8,2620
8000bd26:	18 9b       	mov	r11,r12
8000bd28:	70 0c       	ld.w	r12,r8[0x0]
8000bd2a:	c9 ff       	rcall	8000bc68 <_fclose_r>
8000bd2c:	d8 02       	popm	pc
8000bd2e:	d7 03       	nop

8000bd30 <_fstat_r>:
8000bd30:	d4 21       	pushm	r4-r7,lr
8000bd32:	16 98       	mov	r8,r11
8000bd34:	18 97       	mov	r7,r12
8000bd36:	10 9c       	mov	r12,r8
8000bd38:	30 08       	mov	r8,0
8000bd3a:	e0 66 63 98 	mov	r6,25496
8000bd3e:	14 9b       	mov	r11,r10
8000bd40:	8d 08       	st.w	r6[0x0],r8
8000bd42:	fe b0 df 73 	rcall	80007c28 <_fstat>
8000bd46:	5b fc       	cp.w	r12,-1
8000bd48:	c0 51       	brne	8000bd52 <_fstat_r+0x22>
8000bd4a:	6c 08       	ld.w	r8,r6[0x0]
8000bd4c:	58 08       	cp.w	r8,0
8000bd4e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd52:	d8 22       	popm	r4-r7,pc

8000bd54 <_lseek_r>:
8000bd54:	d4 21       	pushm	r4-r7,lr
8000bd56:	16 98       	mov	r8,r11
8000bd58:	18 97       	mov	r7,r12
8000bd5a:	10 9c       	mov	r12,r8
8000bd5c:	30 08       	mov	r8,0
8000bd5e:	14 9b       	mov	r11,r10
8000bd60:	e0 66 63 98 	mov	r6,25496
8000bd64:	12 9a       	mov	r10,r9
8000bd66:	8d 08       	st.w	r6[0x0],r8
8000bd68:	fe b0 df 42 	rcall	80007bec <_lseek>
8000bd6c:	5b fc       	cp.w	r12,-1
8000bd6e:	c0 51       	brne	8000bd78 <_lseek_r+0x24>
8000bd70:	6c 08       	ld.w	r8,r6[0x0]
8000bd72:	58 08       	cp.w	r8,0
8000bd74:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd78:	d8 22       	popm	r4-r7,pc
8000bd7a:	d7 03       	nop

8000bd7c <_read_r>:
8000bd7c:	d4 21       	pushm	r4-r7,lr
8000bd7e:	16 98       	mov	r8,r11
8000bd80:	18 97       	mov	r7,r12
8000bd82:	10 9c       	mov	r12,r8
8000bd84:	30 08       	mov	r8,0
8000bd86:	14 9b       	mov	r11,r10
8000bd88:	e0 66 63 98 	mov	r6,25496
8000bd8c:	12 9a       	mov	r10,r9
8000bd8e:	8d 08       	st.w	r6[0x0],r8
8000bd90:	fe b0 d0 2a 	rcall	80005de4 <_read>
8000bd94:	5b fc       	cp.w	r12,-1
8000bd96:	c0 51       	brne	8000bda0 <_read_r+0x24>
8000bd98:	6c 08       	ld.w	r8,r6[0x0]
8000bd9a:	58 08       	cp.w	r8,0
8000bd9c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bda0:	d8 22       	popm	r4-r7,pc
8000bda2:	d7 03       	nop

8000bda4 <__avr32_f64_mul>:
8000bda4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bda8:	e0 80 00 dc 	breq	8000bf60 <__avr32_f64_mul_op1_zero>
8000bdac:	d4 21       	pushm	r4-r7,lr
8000bdae:	f7 e9 20 0e 	eor	lr,r11,r9
8000bdb2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bdb6:	30 15       	mov	r5,1
8000bdb8:	c4 30       	breq	8000be3e <__avr32_f64_mul_op1_subnormal>
8000bdba:	ab 6b       	lsl	r11,0xa
8000bdbc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bdc0:	ab 6a       	lsl	r10,0xa
8000bdc2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bdc6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bdca:	c5 c0       	breq	8000be82 <__avr32_f64_mul_op2_subnormal>
8000bdcc:	a1 78       	lsl	r8,0x1
8000bdce:	5c f9       	rol	r9
8000bdd0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bdd4:	e0 47 07 ff 	cp.w	r7,2047
8000bdd8:	c7 70       	breq	8000bec6 <__avr32_f64_mul_op_nan_or_inf>
8000bdda:	e0 46 07 ff 	cp.w	r6,2047
8000bdde:	c7 40       	breq	8000bec6 <__avr32_f64_mul_op_nan_or_inf>
8000bde0:	ee 06 00 0c 	add	r12,r7,r6
8000bde4:	e0 2c 03 fe 	sub	r12,1022
8000bde8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bdec:	f4 09 07 44 	macu.d	r4,r10,r9
8000bdf0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bdf4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bdf8:	08 07       	add	r7,r4
8000bdfa:	f4 05 00 4a 	adc	r10,r10,r5
8000bdfe:	5c 0b       	acr	r11
8000be00:	ed bb 00 14 	bld	r11,0x14
8000be04:	c0 50       	breq	8000be0e <__avr32_f64_mul+0x6a>
8000be06:	a1 77       	lsl	r7,0x1
8000be08:	5c fa       	rol	r10
8000be0a:	5c fb       	rol	r11
8000be0c:	20 1c       	sub	r12,1
8000be0e:	58 0c       	cp.w	r12,0
8000be10:	e0 8a 00 6f 	brle	8000beee <__avr32_f64_mul_res_subnormal>
8000be14:	e0 4c 07 ff 	cp.w	r12,2047
8000be18:	e0 84 00 9c 	brge	8000bf50 <__avr32_f64_mul_res_inf>
8000be1c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000be20:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000be24:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000be28:	ee 17 80 00 	eorh	r7,0x8000
8000be2c:	f1 b7 04 20 	satu	r7,0x1
8000be30:	0e 0a       	add	r10,r7
8000be32:	5c 0b       	acr	r11
8000be34:	ed be 00 1f 	bld	lr,0x1f
8000be38:	ef bb 00 1f 	bst	r11,0x1f
8000be3c:	d8 22       	popm	r4-r7,pc

8000be3e <__avr32_f64_mul_op1_subnormal>:
8000be3e:	e4 1b 00 0f 	andh	r11,0xf
8000be42:	f4 0c 12 00 	clz	r12,r10
8000be46:	f6 06 12 00 	clz	r6,r11
8000be4a:	f7 bc 03 e1 	sublo	r12,-31
8000be4e:	f8 06 17 30 	movlo	r6,r12
8000be52:	f7 b6 02 01 	subhs	r6,1
8000be56:	e0 46 00 20 	cp.w	r6,32
8000be5a:	c0 d4       	brge	8000be74 <__avr32_f64_mul_op1_subnormal+0x36>
8000be5c:	ec 0c 11 20 	rsub	r12,r6,32
8000be60:	f6 06 09 4b 	lsl	r11,r11,r6
8000be64:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000be68:	18 4b       	or	r11,r12
8000be6a:	f4 06 09 4a 	lsl	r10,r10,r6
8000be6e:	20 b6       	sub	r6,11
8000be70:	0c 17       	sub	r7,r6
8000be72:	ca ab       	rjmp	8000bdc6 <__avr32_f64_mul+0x22>
8000be74:	f4 06 09 4b 	lsl	r11,r10,r6
8000be78:	c6 40       	breq	8000bf40 <__avr32_f64_mul_res_zero>
8000be7a:	30 0a       	mov	r10,0
8000be7c:	20 b6       	sub	r6,11
8000be7e:	0c 17       	sub	r7,r6
8000be80:	ca 3b       	rjmp	8000bdc6 <__avr32_f64_mul+0x22>

8000be82 <__avr32_f64_mul_op2_subnormal>:
8000be82:	e4 19 00 0f 	andh	r9,0xf
8000be86:	f0 0c 12 00 	clz	r12,r8
8000be8a:	f2 05 12 00 	clz	r5,r9
8000be8e:	f7 bc 03 ea 	sublo	r12,-22
8000be92:	f8 05 17 30 	movlo	r5,r12
8000be96:	f7 b5 02 0a 	subhs	r5,10
8000be9a:	e0 45 00 20 	cp.w	r5,32
8000be9e:	c0 d4       	brge	8000beb8 <__avr32_f64_mul_op2_subnormal+0x36>
8000bea0:	ea 0c 11 20 	rsub	r12,r5,32
8000bea4:	f2 05 09 49 	lsl	r9,r9,r5
8000bea8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000beac:	18 49       	or	r9,r12
8000beae:	f0 05 09 48 	lsl	r8,r8,r5
8000beb2:	20 25       	sub	r5,2
8000beb4:	0a 16       	sub	r6,r5
8000beb6:	c8 fb       	rjmp	8000bdd4 <__avr32_f64_mul+0x30>
8000beb8:	f0 05 09 49 	lsl	r9,r8,r5
8000bebc:	c4 20       	breq	8000bf40 <__avr32_f64_mul_res_zero>
8000bebe:	30 08       	mov	r8,0
8000bec0:	20 25       	sub	r5,2
8000bec2:	0a 16       	sub	r6,r5
8000bec4:	c8 8b       	rjmp	8000bdd4 <__avr32_f64_mul+0x30>

8000bec6 <__avr32_f64_mul_op_nan_or_inf>:
8000bec6:	e4 19 00 0f 	andh	r9,0xf
8000beca:	e4 1b 00 0f 	andh	r11,0xf
8000bece:	14 4b       	or	r11,r10
8000bed0:	10 49       	or	r9,r8
8000bed2:	e0 47 07 ff 	cp.w	r7,2047
8000bed6:	c0 91       	brne	8000bee8 <__avr32_f64_mul_op1_not_naninf>
8000bed8:	58 0b       	cp.w	r11,0
8000beda:	c3 81       	brne	8000bf4a <__avr32_f64_mul_res_nan>
8000bedc:	e0 46 07 ff 	cp.w	r6,2047
8000bee0:	c3 81       	brne	8000bf50 <__avr32_f64_mul_res_inf>
8000bee2:	58 09       	cp.w	r9,0
8000bee4:	c3 60       	breq	8000bf50 <__avr32_f64_mul_res_inf>
8000bee6:	c3 28       	rjmp	8000bf4a <__avr32_f64_mul_res_nan>

8000bee8 <__avr32_f64_mul_op1_not_naninf>:
8000bee8:	58 09       	cp.w	r9,0
8000beea:	c3 30       	breq	8000bf50 <__avr32_f64_mul_res_inf>
8000beec:	c2 f8       	rjmp	8000bf4a <__avr32_f64_mul_res_nan>

8000beee <__avr32_f64_mul_res_subnormal>:
8000beee:	5c 3c       	neg	r12
8000bef0:	2f fc       	sub	r12,-1
8000bef2:	f1 bc 04 c0 	satu	r12,0x6
8000bef6:	e0 4c 00 20 	cp.w	r12,32
8000befa:	c1 14       	brge	8000bf1c <__avr32_f64_mul_res_subnormal+0x2e>
8000befc:	f8 08 11 20 	rsub	r8,r12,32
8000bf00:	0e 46       	or	r6,r7
8000bf02:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bf06:	f4 08 09 49 	lsl	r9,r10,r8
8000bf0a:	12 47       	or	r7,r9
8000bf0c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bf10:	f6 08 09 49 	lsl	r9,r11,r8
8000bf14:	12 4a       	or	r10,r9
8000bf16:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bf1a:	c8 3b       	rjmp	8000be20 <__avr32_f64_mul+0x7c>
8000bf1c:	f8 08 11 20 	rsub	r8,r12,32
8000bf20:	f9 b9 00 00 	moveq	r9,0
8000bf24:	c0 30       	breq	8000bf2a <__avr32_f64_mul_res_subnormal+0x3c>
8000bf26:	f6 08 09 49 	lsl	r9,r11,r8
8000bf2a:	0e 46       	or	r6,r7
8000bf2c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bf30:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bf34:	f3 ea 10 07 	or	r7,r9,r10
8000bf38:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bf3c:	30 0b       	mov	r11,0
8000bf3e:	c7 1b       	rjmp	8000be20 <__avr32_f64_mul+0x7c>

8000bf40 <__avr32_f64_mul_res_zero>:
8000bf40:	1c 9b       	mov	r11,lr
8000bf42:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf46:	30 0a       	mov	r10,0
8000bf48:	d8 22       	popm	r4-r7,pc

8000bf4a <__avr32_f64_mul_res_nan>:
8000bf4a:	3f fb       	mov	r11,-1
8000bf4c:	3f fa       	mov	r10,-1
8000bf4e:	d8 22       	popm	r4-r7,pc

8000bf50 <__avr32_f64_mul_res_inf>:
8000bf50:	f0 6b 00 00 	mov	r11,-1048576
8000bf54:	ed be 00 1f 	bld	lr,0x1f
8000bf58:	ef bb 00 1f 	bst	r11,0x1f
8000bf5c:	30 0a       	mov	r10,0
8000bf5e:	d8 22       	popm	r4-r7,pc

8000bf60 <__avr32_f64_mul_op1_zero>:
8000bf60:	f7 e9 20 0b 	eor	r11,r11,r9
8000bf64:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf68:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bf6c:	e0 4c 07 ff 	cp.w	r12,2047
8000bf70:	5e 1c       	retne	r12
8000bf72:	3f fa       	mov	r10,-1
8000bf74:	3f fb       	mov	r11,-1
8000bf76:	5e fc       	retal	r12

8000bf78 <__avr32_f64_sub_from_add>:
8000bf78:	ee 19 80 00 	eorh	r9,0x8000

8000bf7c <__avr32_f64_sub>:
8000bf7c:	f7 e9 20 0c 	eor	r12,r11,r9
8000bf80:	e0 86 00 ca 	brmi	8000c114 <__avr32_f64_add_from_sub>
8000bf84:	eb cd 40 e0 	pushm	r5-r7,lr
8000bf88:	16 9c       	mov	r12,r11
8000bf8a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bf8e:	bf db       	cbr	r11,0x1f
8000bf90:	bf d9       	cbr	r9,0x1f
8000bf92:	10 3a       	cp.w	r10,r8
8000bf94:	f2 0b 13 00 	cpc	r11,r9
8000bf98:	c0 92       	brcc	8000bfaa <__avr32_f64_sub+0x2e>
8000bf9a:	16 97       	mov	r7,r11
8000bf9c:	12 9b       	mov	r11,r9
8000bf9e:	0e 99       	mov	r9,r7
8000bfa0:	14 97       	mov	r7,r10
8000bfa2:	10 9a       	mov	r10,r8
8000bfa4:	0e 98       	mov	r8,r7
8000bfa6:	ee 1c 80 00 	eorh	r12,0x8000
8000bfaa:	f6 07 16 14 	lsr	r7,r11,0x14
8000bfae:	ab 7b       	lsl	r11,0xb
8000bfb0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bfb4:	ab 7a       	lsl	r10,0xb
8000bfb6:	bf bb       	sbr	r11,0x1f
8000bfb8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bfbc:	c4 40       	breq	8000c044 <__avr32_f64_sub_opL_subnormal>
8000bfbe:	ab 79       	lsl	r9,0xb
8000bfc0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bfc4:	ab 78       	lsl	r8,0xb
8000bfc6:	bf b9       	sbr	r9,0x1f

8000bfc8 <__avr32_f64_sub_opL_subnormal_done>:
8000bfc8:	e0 47 07 ff 	cp.w	r7,2047
8000bfcc:	c4 f0       	breq	8000c06a <__avr32_f64_sub_opH_nan_or_inf>
8000bfce:	0e 26       	rsub	r6,r7
8000bfd0:	c1 20       	breq	8000bff4 <__avr32_f64_sub_shift_done>
8000bfd2:	ec 05 11 20 	rsub	r5,r6,32
8000bfd6:	e0 46 00 20 	cp.w	r6,32
8000bfda:	c7 c2       	brcc	8000c0d2 <__avr32_f64_sub_longshift>
8000bfdc:	f0 05 09 4e 	lsl	lr,r8,r5
8000bfe0:	f2 05 09 45 	lsl	r5,r9,r5
8000bfe4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bfe8:	f2 06 0a 49 	lsr	r9,r9,r6
8000bfec:	0a 48       	or	r8,r5
8000bfee:	58 0e       	cp.w	lr,0
8000bff0:	5f 1e       	srne	lr
8000bff2:	1c 48       	or	r8,lr

8000bff4 <__avr32_f64_sub_shift_done>:
8000bff4:	10 1a       	sub	r10,r8
8000bff6:	f6 09 01 4b 	sbc	r11,r11,r9
8000bffa:	f6 06 12 00 	clz	r6,r11
8000bffe:	c0 e0       	breq	8000c01a <__avr32_f64_sub_longnormalize_done>
8000c000:	c7 83       	brcs	8000c0f0 <__avr32_f64_sub_longnormalize>
8000c002:	ec 0e 11 20 	rsub	lr,r6,32
8000c006:	f6 06 09 4b 	lsl	r11,r11,r6
8000c00a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c00e:	1c 4b       	or	r11,lr
8000c010:	f4 06 09 4a 	lsl	r10,r10,r6
8000c014:	0c 17       	sub	r7,r6
8000c016:	e0 8a 00 39 	brle	8000c088 <__avr32_f64_sub_subnormal_result>

8000c01a <__avr32_f64_sub_longnormalize_done>:
8000c01a:	f4 09 15 15 	lsl	r9,r10,0x15
8000c01e:	ab 9a       	lsr	r10,0xb
8000c020:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c024:	ab 9b       	lsr	r11,0xb
8000c026:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c02a:	18 4b       	or	r11,r12

8000c02c <__avr32_f64_sub_round>:
8000c02c:	fc 17 80 00 	movh	r7,0x8000
8000c030:	ed ba 00 00 	bld	r10,0x0
8000c034:	f7 b7 01 ff 	subne	r7,-1
8000c038:	0e 39       	cp.w	r9,r7
8000c03a:	5f 29       	srhs	r9
8000c03c:	12 0a       	add	r10,r9
8000c03e:	5c 0b       	acr	r11
8000c040:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c044 <__avr32_f64_sub_opL_subnormal>:
8000c044:	ab 79       	lsl	r9,0xb
8000c046:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c04a:	ab 78       	lsl	r8,0xb
8000c04c:	f3 e8 10 0e 	or	lr,r9,r8
8000c050:	f9 b6 01 01 	movne	r6,1
8000c054:	ee 0e 11 00 	rsub	lr,r7,0
8000c058:	f9 b7 00 01 	moveq	r7,1
8000c05c:	ef bb 00 1f 	bst	r11,0x1f
8000c060:	f7 ea 10 0e 	or	lr,r11,r10
8000c064:	f9 b7 00 00 	moveq	r7,0
8000c068:	cb 0b       	rjmp	8000bfc8 <__avr32_f64_sub_opL_subnormal_done>

8000c06a <__avr32_f64_sub_opH_nan_or_inf>:
8000c06a:	bf db       	cbr	r11,0x1f
8000c06c:	f7 ea 10 0e 	or	lr,r11,r10
8000c070:	c0 81       	brne	8000c080 <__avr32_f64_sub_return_nan>
8000c072:	e0 46 07 ff 	cp.w	r6,2047
8000c076:	c0 50       	breq	8000c080 <__avr32_f64_sub_return_nan>
8000c078:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c07c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c080 <__avr32_f64_sub_return_nan>:
8000c080:	3f fa       	mov	r10,-1
8000c082:	3f fb       	mov	r11,-1
8000c084:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c088 <__avr32_f64_sub_subnormal_result>:
8000c088:	5c 37       	neg	r7
8000c08a:	2f f7       	sub	r7,-1
8000c08c:	f1 b7 04 c0 	satu	r7,0x6
8000c090:	e0 47 00 20 	cp.w	r7,32
8000c094:	c1 14       	brge	8000c0b6 <__avr32_f64_sub_subnormal_result+0x2e>
8000c096:	ee 08 11 20 	rsub	r8,r7,32
8000c09a:	f4 08 09 49 	lsl	r9,r10,r8
8000c09e:	5f 16       	srne	r6
8000c0a0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c0a4:	0c 4a       	or	r10,r6
8000c0a6:	f6 08 09 49 	lsl	r9,r11,r8
8000c0aa:	f5 e9 10 0a 	or	r10,r10,r9
8000c0ae:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c0b2:	30 07       	mov	r7,0
8000c0b4:	cb 3b       	rjmp	8000c01a <__avr32_f64_sub_longnormalize_done>
8000c0b6:	ee 08 11 40 	rsub	r8,r7,64
8000c0ba:	f6 08 09 49 	lsl	r9,r11,r8
8000c0be:	14 49       	or	r9,r10
8000c0c0:	5f 16       	srne	r6
8000c0c2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c0c6:	0c 4a       	or	r10,r6
8000c0c8:	30 0b       	mov	r11,0
8000c0ca:	30 07       	mov	r7,0
8000c0cc:	ca 7b       	rjmp	8000c01a <__avr32_f64_sub_longnormalize_done>
8000c0ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0d2 <__avr32_f64_sub_longshift>:
8000c0d2:	f1 b6 04 c0 	satu	r6,0x6
8000c0d6:	f0 0e 17 00 	moveq	lr,r8
8000c0da:	c0 40       	breq	8000c0e2 <__avr32_f64_sub_longshift+0x10>
8000c0dc:	f2 05 09 4e 	lsl	lr,r9,r5
8000c0e0:	10 4e       	or	lr,r8
8000c0e2:	f2 06 0a 48 	lsr	r8,r9,r6
8000c0e6:	30 09       	mov	r9,0
8000c0e8:	58 0e       	cp.w	lr,0
8000c0ea:	5f 1e       	srne	lr
8000c0ec:	1c 48       	or	r8,lr
8000c0ee:	c8 3b       	rjmp	8000bff4 <__avr32_f64_sub_shift_done>

8000c0f0 <__avr32_f64_sub_longnormalize>:
8000c0f0:	f4 06 12 00 	clz	r6,r10
8000c0f4:	f9 b7 03 00 	movlo	r7,0
8000c0f8:	f9 b6 03 00 	movlo	r6,0
8000c0fc:	f9 bc 03 00 	movlo	r12,0
8000c100:	f7 b6 02 e0 	subhs	r6,-32
8000c104:	f4 06 09 4b 	lsl	r11,r10,r6
8000c108:	30 0a       	mov	r10,0
8000c10a:	0c 17       	sub	r7,r6
8000c10c:	fe 9a ff be 	brle	8000c088 <__avr32_f64_sub_subnormal_result>
8000c110:	c8 5b       	rjmp	8000c01a <__avr32_f64_sub_longnormalize_done>
8000c112:	d7 03       	nop

8000c114 <__avr32_f64_add_from_sub>:
8000c114:	ee 19 80 00 	eorh	r9,0x8000

8000c118 <__avr32_f64_add>:
8000c118:	f7 e9 20 0c 	eor	r12,r11,r9
8000c11c:	fe 96 ff 2e 	brmi	8000bf78 <__avr32_f64_sub_from_add>
8000c120:	eb cd 40 e0 	pushm	r5-r7,lr
8000c124:	16 9c       	mov	r12,r11
8000c126:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c12a:	bf db       	cbr	r11,0x1f
8000c12c:	bf d9       	cbr	r9,0x1f
8000c12e:	12 3b       	cp.w	r11,r9
8000c130:	c0 72       	brcc	8000c13e <__avr32_f64_add+0x26>
8000c132:	16 97       	mov	r7,r11
8000c134:	12 9b       	mov	r11,r9
8000c136:	0e 99       	mov	r9,r7
8000c138:	14 97       	mov	r7,r10
8000c13a:	10 9a       	mov	r10,r8
8000c13c:	0e 98       	mov	r8,r7
8000c13e:	30 0e       	mov	lr,0
8000c140:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c144:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c148:	b5 ab       	sbr	r11,0x14
8000c14a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c14e:	c6 20       	breq	8000c212 <__avr32_f64_add_op2_subnormal>
8000c150:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c154:	b5 a9       	sbr	r9,0x14
8000c156:	e0 47 07 ff 	cp.w	r7,2047
8000c15a:	c2 80       	breq	8000c1aa <__avr32_f64_add_opH_nan_or_inf>
8000c15c:	0e 26       	rsub	r6,r7
8000c15e:	c1 20       	breq	8000c182 <__avr32_f64_add_shift_done>
8000c160:	e0 46 00 36 	cp.w	r6,54
8000c164:	c1 52       	brcc	8000c18e <__avr32_f64_add_res_of_done>
8000c166:	ec 05 11 20 	rsub	r5,r6,32
8000c16a:	e0 46 00 20 	cp.w	r6,32
8000c16e:	c3 52       	brcc	8000c1d8 <__avr32_f64_add_longshift>
8000c170:	f0 05 09 4e 	lsl	lr,r8,r5
8000c174:	f2 05 09 45 	lsl	r5,r9,r5
8000c178:	f0 06 0a 48 	lsr	r8,r8,r6
8000c17c:	f2 06 0a 49 	lsr	r9,r9,r6
8000c180:	0a 48       	or	r8,r5

8000c182 <__avr32_f64_add_shift_done>:
8000c182:	10 0a       	add	r10,r8
8000c184:	f6 09 00 4b 	adc	r11,r11,r9
8000c188:	ed bb 00 15 	bld	r11,0x15
8000c18c:	c3 40       	breq	8000c1f4 <__avr32_f64_add_res_of>

8000c18e <__avr32_f64_add_res_of_done>:
8000c18e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c192:	18 4b       	or	r11,r12

8000c194 <__avr32_f64_add_round>:
8000c194:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c198:	18 4e       	or	lr,r12
8000c19a:	ee 1e 80 00 	eorh	lr,0x8000
8000c19e:	f1 be 04 20 	satu	lr,0x1
8000c1a2:	1c 0a       	add	r10,lr
8000c1a4:	5c 0b       	acr	r11
8000c1a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1aa <__avr32_f64_add_opH_nan_or_inf>:
8000c1aa:	b5 cb       	cbr	r11,0x14
8000c1ac:	f7 ea 10 0e 	or	lr,r11,r10
8000c1b0:	c1 01       	brne	8000c1d0 <__avr32_f64_add_return_nan>
8000c1b2:	e0 46 07 ff 	cp.w	r6,2047
8000c1b6:	c0 30       	breq	8000c1bc <__avr32_f64_add_opL_nan_or_inf>
8000c1b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1bc <__avr32_f64_add_opL_nan_or_inf>:
8000c1bc:	b5 c9       	cbr	r9,0x14
8000c1be:	f3 e8 10 0e 	or	lr,r9,r8
8000c1c2:	c0 71       	brne	8000c1d0 <__avr32_f64_add_return_nan>
8000c1c4:	30 0a       	mov	r10,0
8000c1c6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c1ca:	18 4b       	or	r11,r12
8000c1cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1d0 <__avr32_f64_add_return_nan>:
8000c1d0:	3f fa       	mov	r10,-1
8000c1d2:	3f fb       	mov	r11,-1
8000c1d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1d8 <__avr32_f64_add_longshift>:
8000c1d8:	f1 b6 04 c0 	satu	r6,0x6
8000c1dc:	f0 0e 17 00 	moveq	lr,r8
8000c1e0:	c0 60       	breq	8000c1ec <__avr32_f64_add_longshift+0x14>
8000c1e2:	f2 05 09 4e 	lsl	lr,r9,r5
8000c1e6:	58 08       	cp.w	r8,0
8000c1e8:	5f 18       	srne	r8
8000c1ea:	10 4e       	or	lr,r8
8000c1ec:	f2 06 0a 48 	lsr	r8,r9,r6
8000c1f0:	30 09       	mov	r9,0
8000c1f2:	cc 8b       	rjmp	8000c182 <__avr32_f64_add_shift_done>

8000c1f4 <__avr32_f64_add_res_of>:
8000c1f4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c1f8:	a1 9b       	lsr	r11,0x1
8000c1fa:	5d 0a       	ror	r10
8000c1fc:	5d 0e       	ror	lr
8000c1fe:	2f f7       	sub	r7,-1
8000c200:	e0 47 07 ff 	cp.w	r7,2047
8000c204:	f9 ba 00 00 	moveq	r10,0
8000c208:	f9 bb 00 00 	moveq	r11,0
8000c20c:	f9 be 00 00 	moveq	lr,0
8000c210:	cb fb       	rjmp	8000c18e <__avr32_f64_add_res_of_done>

8000c212 <__avr32_f64_add_op2_subnormal>:
8000c212:	30 16       	mov	r6,1
8000c214:	58 07       	cp.w	r7,0
8000c216:	ca 01       	brne	8000c156 <__avr32_f64_add+0x3e>
8000c218:	b5 cb       	cbr	r11,0x14
8000c21a:	10 0a       	add	r10,r8
8000c21c:	f6 09 00 4b 	adc	r11,r11,r9
8000c220:	18 4b       	or	r11,r12
8000c222:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c226:	d7 03       	nop

8000c228 <__avr32_f64_to_u32>:
8000c228:	58 0b       	cp.w	r11,0
8000c22a:	5e 6d       	retmi	0

8000c22c <__avr32_f64_to_s32>:
8000c22c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c230:	b5 9c       	lsr	r12,0x15
8000c232:	e0 2c 03 ff 	sub	r12,1023
8000c236:	5e 3d       	retlo	0
8000c238:	f8 0c 11 1f 	rsub	r12,r12,31
8000c23c:	16 99       	mov	r9,r11
8000c23e:	ab 7b       	lsl	r11,0xb
8000c240:	bf bb       	sbr	r11,0x1f
8000c242:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c246:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c24a:	a1 79       	lsl	r9,0x1
8000c24c:	5e 2b       	reths	r11
8000c24e:	5c 3b       	neg	r11
8000c250:	5e fb       	retal	r11

8000c252 <__avr32_u32_to_f64>:
8000c252:	f8 cb 00 00 	sub	r11,r12,0
8000c256:	30 0c       	mov	r12,0
8000c258:	c0 38       	rjmp	8000c25e <__avr32_s32_to_f64+0x4>

8000c25a <__avr32_s32_to_f64>:
8000c25a:	18 9b       	mov	r11,r12
8000c25c:	5c 4b       	abs	r11
8000c25e:	30 0a       	mov	r10,0
8000c260:	5e 0b       	reteq	r11
8000c262:	d4 01       	pushm	lr
8000c264:	e0 69 04 1e 	mov	r9,1054
8000c268:	f6 08 12 00 	clz	r8,r11
8000c26c:	c1 70       	breq	8000c29a <__avr32_s32_to_f64+0x40>
8000c26e:	c0 c3       	brcs	8000c286 <__avr32_s32_to_f64+0x2c>
8000c270:	f0 0e 11 20 	rsub	lr,r8,32
8000c274:	f6 08 09 4b 	lsl	r11,r11,r8
8000c278:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c27c:	1c 4b       	or	r11,lr
8000c27e:	f4 08 09 4a 	lsl	r10,r10,r8
8000c282:	10 19       	sub	r9,r8
8000c284:	c0 b8       	rjmp	8000c29a <__avr32_s32_to_f64+0x40>
8000c286:	f4 08 12 00 	clz	r8,r10
8000c28a:	f9 b8 03 00 	movlo	r8,0
8000c28e:	f7 b8 02 e0 	subhs	r8,-32
8000c292:	f4 08 09 4b 	lsl	r11,r10,r8
8000c296:	30 0a       	mov	r10,0
8000c298:	10 19       	sub	r9,r8
8000c29a:	58 09       	cp.w	r9,0
8000c29c:	e0 89 00 30 	brgt	8000c2fc <__avr32_s32_to_f64+0xa2>
8000c2a0:	5c 39       	neg	r9
8000c2a2:	2f f9       	sub	r9,-1
8000c2a4:	e0 49 00 36 	cp.w	r9,54
8000c2a8:	c0 43       	brcs	8000c2b0 <__avr32_s32_to_f64+0x56>
8000c2aa:	30 0b       	mov	r11,0
8000c2ac:	30 0a       	mov	r10,0
8000c2ae:	c2 68       	rjmp	8000c2fa <__avr32_s32_to_f64+0xa0>
8000c2b0:	2f 69       	sub	r9,-10
8000c2b2:	f2 08 11 20 	rsub	r8,r9,32
8000c2b6:	e0 49 00 20 	cp.w	r9,32
8000c2ba:	c0 b2       	brcc	8000c2d0 <__avr32_s32_to_f64+0x76>
8000c2bc:	f4 08 09 4e 	lsl	lr,r10,r8
8000c2c0:	f6 08 09 48 	lsl	r8,r11,r8
8000c2c4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c2c8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c2cc:	10 4b       	or	r11,r8
8000c2ce:	c0 88       	rjmp	8000c2de <__avr32_s32_to_f64+0x84>
8000c2d0:	f6 08 09 4e 	lsl	lr,r11,r8
8000c2d4:	14 4e       	or	lr,r10
8000c2d6:	16 9a       	mov	r10,r11
8000c2d8:	30 0b       	mov	r11,0
8000c2da:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c2de:	ed ba 00 00 	bld	r10,0x0
8000c2e2:	c0 92       	brcc	8000c2f4 <__avr32_s32_to_f64+0x9a>
8000c2e4:	1c 7e       	tst	lr,lr
8000c2e6:	c0 41       	brne	8000c2ee <__avr32_s32_to_f64+0x94>
8000c2e8:	ed ba 00 01 	bld	r10,0x1
8000c2ec:	c0 42       	brcc	8000c2f4 <__avr32_s32_to_f64+0x9a>
8000c2ee:	2f fa       	sub	r10,-1
8000c2f0:	f7 bb 02 ff 	subhs	r11,-1
8000c2f4:	5c fc       	rol	r12
8000c2f6:	5d 0b       	ror	r11
8000c2f8:	5d 0a       	ror	r10
8000c2fa:	d8 02       	popm	pc
8000c2fc:	e0 68 03 ff 	mov	r8,1023
8000c300:	ed ba 00 0b 	bld	r10,0xb
8000c304:	f7 b8 00 ff 	subeq	r8,-1
8000c308:	10 0a       	add	r10,r8
8000c30a:	5c 0b       	acr	r11
8000c30c:	f7 b9 03 fe 	sublo	r9,-2
8000c310:	e0 49 07 ff 	cp.w	r9,2047
8000c314:	c0 55       	brlt	8000c31e <__avr32_s32_to_f64+0xc4>
8000c316:	30 0a       	mov	r10,0
8000c318:	fc 1b ff e0 	movh	r11,0xffe0
8000c31c:	c0 c8       	rjmp	8000c334 <__floatsidf_return_op1>
8000c31e:	ed bb 00 1f 	bld	r11,0x1f
8000c322:	f7 b9 01 01 	subne	r9,1
8000c326:	ab 9a       	lsr	r10,0xb
8000c328:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c32c:	a1 7b       	lsl	r11,0x1
8000c32e:	ab 9b       	lsr	r11,0xb
8000c330:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c334 <__floatsidf_return_op1>:
8000c334:	a1 7c       	lsl	r12,0x1
8000c336:	5d 0b       	ror	r11
8000c338:	d8 02       	popm	pc

8000c33a <__avr32_f64_cmp_eq>:
8000c33a:	10 3a       	cp.w	r10,r8
8000c33c:	f2 0b 13 00 	cpc	r11,r9
8000c340:	c0 80       	breq	8000c350 <__avr32_f64_cmp_eq+0x16>
8000c342:	a1 7b       	lsl	r11,0x1
8000c344:	a1 79       	lsl	r9,0x1
8000c346:	14 4b       	or	r11,r10
8000c348:	12 4b       	or	r11,r9
8000c34a:	10 4b       	or	r11,r8
8000c34c:	5e 0f       	reteq	1
8000c34e:	5e fd       	retal	0
8000c350:	a1 7b       	lsl	r11,0x1
8000c352:	fc 1c ff e0 	movh	r12,0xffe0
8000c356:	58 0a       	cp.w	r10,0
8000c358:	f8 0b 13 00 	cpc	r11,r12
8000c35c:	5e 8f       	retls	1
8000c35e:	5e fd       	retal	0

8000c360 <__avr32_f64_cmp_ge>:
8000c360:	1a de       	st.w	--sp,lr
8000c362:	1a d7       	st.w	--sp,r7
8000c364:	a1 7b       	lsl	r11,0x1
8000c366:	5f 3c       	srlo	r12
8000c368:	a1 79       	lsl	r9,0x1
8000c36a:	5f 37       	srlo	r7
8000c36c:	5c fc       	rol	r12
8000c36e:	fc 1e ff e0 	movh	lr,0xffe0
8000c372:	58 0a       	cp.w	r10,0
8000c374:	fc 0b 13 00 	cpc	r11,lr
8000c378:	e0 8b 00 1d 	brhi	8000c3b2 <__avr32_f64_cmp_ge+0x52>
8000c37c:	58 08       	cp.w	r8,0
8000c37e:	fc 09 13 00 	cpc	r9,lr
8000c382:	e0 8b 00 18 	brhi	8000c3b2 <__avr32_f64_cmp_ge+0x52>
8000c386:	58 0b       	cp.w	r11,0
8000c388:	f5 ba 00 00 	subfeq	r10,0
8000c38c:	c1 50       	breq	8000c3b6 <__avr32_f64_cmp_ge+0x56>
8000c38e:	1b 07       	ld.w	r7,sp++
8000c390:	1b 0e       	ld.w	lr,sp++
8000c392:	58 3c       	cp.w	r12,3
8000c394:	c0 a0       	breq	8000c3a8 <__avr32_f64_cmp_ge+0x48>
8000c396:	58 1c       	cp.w	r12,1
8000c398:	c0 33       	brcs	8000c39e <__avr32_f64_cmp_ge+0x3e>
8000c39a:	5e 0f       	reteq	1
8000c39c:	5e 1d       	retne	0
8000c39e:	10 3a       	cp.w	r10,r8
8000c3a0:	f2 0b 13 00 	cpc	r11,r9
8000c3a4:	5e 2f       	reths	1
8000c3a6:	5e 3d       	retlo	0
8000c3a8:	14 38       	cp.w	r8,r10
8000c3aa:	f6 09 13 00 	cpc	r9,r11
8000c3ae:	5e 2f       	reths	1
8000c3b0:	5e 3d       	retlo	0
8000c3b2:	1b 07       	ld.w	r7,sp++
8000c3b4:	d8 0a       	popm	pc,r12=0
8000c3b6:	58 17       	cp.w	r7,1
8000c3b8:	5f 0c       	sreq	r12
8000c3ba:	58 09       	cp.w	r9,0
8000c3bc:	f5 b8 00 00 	subfeq	r8,0
8000c3c0:	1b 07       	ld.w	r7,sp++
8000c3c2:	1b 0e       	ld.w	lr,sp++
8000c3c4:	5e 0f       	reteq	1
8000c3c6:	5e fc       	retal	r12

8000c3c8 <__avr32_f64_cmp_lt>:
8000c3c8:	1a de       	st.w	--sp,lr
8000c3ca:	1a d7       	st.w	--sp,r7
8000c3cc:	a1 7b       	lsl	r11,0x1
8000c3ce:	5f 3c       	srlo	r12
8000c3d0:	a1 79       	lsl	r9,0x1
8000c3d2:	5f 37       	srlo	r7
8000c3d4:	5c fc       	rol	r12
8000c3d6:	fc 1e ff e0 	movh	lr,0xffe0
8000c3da:	58 0a       	cp.w	r10,0
8000c3dc:	fc 0b 13 00 	cpc	r11,lr
8000c3e0:	e0 8b 00 1d 	brhi	8000c41a <__avr32_f64_cmp_lt+0x52>
8000c3e4:	58 08       	cp.w	r8,0
8000c3e6:	fc 09 13 00 	cpc	r9,lr
8000c3ea:	e0 8b 00 18 	brhi	8000c41a <__avr32_f64_cmp_lt+0x52>
8000c3ee:	58 0b       	cp.w	r11,0
8000c3f0:	f5 ba 00 00 	subfeq	r10,0
8000c3f4:	c1 50       	breq	8000c41e <__avr32_f64_cmp_lt+0x56>
8000c3f6:	1b 07       	ld.w	r7,sp++
8000c3f8:	1b 0e       	ld.w	lr,sp++
8000c3fa:	58 3c       	cp.w	r12,3
8000c3fc:	c0 a0       	breq	8000c410 <__avr32_f64_cmp_lt+0x48>
8000c3fe:	58 1c       	cp.w	r12,1
8000c400:	c0 33       	brcs	8000c406 <__avr32_f64_cmp_lt+0x3e>
8000c402:	5e 0d       	reteq	0
8000c404:	5e 1f       	retne	1
8000c406:	10 3a       	cp.w	r10,r8
8000c408:	f2 0b 13 00 	cpc	r11,r9
8000c40c:	5e 2d       	reths	0
8000c40e:	5e 3f       	retlo	1
8000c410:	14 38       	cp.w	r8,r10
8000c412:	f6 09 13 00 	cpc	r9,r11
8000c416:	5e 2d       	reths	0
8000c418:	5e 3f       	retlo	1
8000c41a:	1b 07       	ld.w	r7,sp++
8000c41c:	d8 0a       	popm	pc,r12=0
8000c41e:	58 17       	cp.w	r7,1
8000c420:	5f 1c       	srne	r12
8000c422:	58 09       	cp.w	r9,0
8000c424:	f5 b8 00 00 	subfeq	r8,0
8000c428:	1b 07       	ld.w	r7,sp++
8000c42a:	1b 0e       	ld.w	lr,sp++
8000c42c:	5e 0d       	reteq	0
8000c42e:	5e fc       	retal	r12

8000c430 <__avr32_f64_div>:
8000c430:	eb cd 40 ff 	pushm	r0-r7,lr
8000c434:	f7 e9 20 0e 	eor	lr,r11,r9
8000c438:	f6 07 16 14 	lsr	r7,r11,0x14
8000c43c:	a9 7b       	lsl	r11,0x9
8000c43e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c442:	a9 7a       	lsl	r10,0x9
8000c444:	bd bb       	sbr	r11,0x1d
8000c446:	e4 1b 3f ff 	andh	r11,0x3fff
8000c44a:	ab d7       	cbr	r7,0xb
8000c44c:	e0 80 00 cc 	breq	8000c5e4 <__avr32_f64_div_round_subnormal+0x54>
8000c450:	e0 47 07 ff 	cp.w	r7,2047
8000c454:	e0 84 00 b5 	brge	8000c5be <__avr32_f64_div_round_subnormal+0x2e>
8000c458:	f2 06 16 14 	lsr	r6,r9,0x14
8000c45c:	a9 79       	lsl	r9,0x9
8000c45e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c462:	a9 78       	lsl	r8,0x9
8000c464:	bd b9       	sbr	r9,0x1d
8000c466:	e4 19 3f ff 	andh	r9,0x3fff
8000c46a:	ab d6       	cbr	r6,0xb
8000c46c:	e0 80 00 e2 	breq	8000c630 <__avr32_f64_div_round_subnormal+0xa0>
8000c470:	e0 46 07 ff 	cp.w	r6,2047
8000c474:	e0 84 00 b2 	brge	8000c5d8 <__avr32_f64_div_round_subnormal+0x48>
8000c478:	0c 17       	sub	r7,r6
8000c47a:	fe 37 fc 01 	sub	r7,-1023
8000c47e:	fc 1c 80 00 	movh	r12,0x8000
8000c482:	f8 03 16 01 	lsr	r3,r12,0x1
8000c486:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c48a:	5c d4       	com	r4
8000c48c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c490:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c494:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c498:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c49c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4a0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4a4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c4a8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4ac:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4b0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4b4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c4b8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4bc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4c0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4c4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c4c8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4cc:	02 04       	add	r4,r1
8000c4ce:	5c 05       	acr	r5
8000c4d0:	a3 65       	lsl	r5,0x2
8000c4d2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c4d6:	a3 64       	lsl	r4,0x2
8000c4d8:	5c 34       	neg	r4
8000c4da:	f8 05 01 45 	sbc	r5,r12,r5
8000c4de:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c4e2:	e4 05 07 40 	macu.d	r0,r2,r5
8000c4e6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4ea:	02 04       	add	r4,r1
8000c4ec:	5c 05       	acr	r5
8000c4ee:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4f2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c4f6:	e8 02 15 02 	lsl	r2,r4,0x2
8000c4fa:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4fe:	e4 09 07 40 	macu.d	r0,r2,r9
8000c502:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c506:	02 04       	add	r4,r1
8000c508:	5c 05       	acr	r5
8000c50a:	a3 65       	lsl	r5,0x2
8000c50c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c510:	a3 64       	lsl	r4,0x2
8000c512:	5c 34       	neg	r4
8000c514:	f8 05 01 45 	sbc	r5,r12,r5
8000c518:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c51c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c520:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c524:	02 04       	add	r4,r1
8000c526:	5c 05       	acr	r5
8000c528:	ea 03 15 02 	lsl	r3,r5,0x2
8000c52c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c530:	e8 02 15 02 	lsl	r2,r4,0x2
8000c534:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c538:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c53c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c540:	02 02       	add	r2,r1
8000c542:	5c 03       	acr	r3
8000c544:	ed b3 00 1c 	bld	r3,0x1c
8000c548:	c0 90       	breq	8000c55a <__avr32_f64_div+0x12a>
8000c54a:	a1 72       	lsl	r2,0x1
8000c54c:	5c f3       	rol	r3
8000c54e:	20 17       	sub	r7,1
8000c550:	a3 9a       	lsr	r10,0x3
8000c552:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c556:	a3 9b       	lsr	r11,0x3
8000c558:	c0 58       	rjmp	8000c562 <__avr32_f64_div+0x132>
8000c55a:	a5 8a       	lsr	r10,0x4
8000c55c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c560:	a5 8b       	lsr	r11,0x4
8000c562:	58 07       	cp.w	r7,0
8000c564:	e0 8a 00 8b 	brle	8000c67a <__avr32_f64_div_res_subnormal>
8000c568:	e0 12 ff 00 	andl	r2,0xff00
8000c56c:	e8 12 00 80 	orl	r2,0x80
8000c570:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c574:	e4 09 07 40 	macu.d	r0,r2,r9
8000c578:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c57c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c580:	00 05       	add	r5,r0
8000c582:	f0 01 00 48 	adc	r8,r8,r1
8000c586:	5c 09       	acr	r9
8000c588:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c58c:	58 04       	cp.w	r4,0
8000c58e:	5c 25       	cpc	r5

8000c590 <__avr32_f64_div_round_subnormal>:
8000c590:	f4 08 13 00 	cpc	r8,r10
8000c594:	f6 09 13 00 	cpc	r9,r11
8000c598:	5f 36       	srlo	r6
8000c59a:	f8 06 17 00 	moveq	r6,r12
8000c59e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c5a2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c5a6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c5aa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c5ae:	ed be 00 1f 	bld	lr,0x1f
8000c5b2:	ef bb 00 1f 	bst	r11,0x1f
8000c5b6:	0c 0a       	add	r10,r6
8000c5b8:	5c 0b       	acr	r11
8000c5ba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c5be:	e4 1b 00 0f 	andh	r11,0xf
8000c5c2:	14 4b       	or	r11,r10
8000c5c4:	e0 81 00 a7 	brne	8000c712 <__avr32_f64_div_res_subnormal+0x98>
8000c5c8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c5cc:	ab d6       	cbr	r6,0xb
8000c5ce:	e0 46 07 ff 	cp.w	r6,2047
8000c5d2:	e0 81 00 a4 	brne	8000c71a <__avr32_f64_div_res_subnormal+0xa0>
8000c5d6:	c9 e8       	rjmp	8000c712 <__avr32_f64_div_res_subnormal+0x98>
8000c5d8:	e4 19 00 0f 	andh	r9,0xf
8000c5dc:	10 49       	or	r9,r8
8000c5de:	e0 81 00 9a 	brne	8000c712 <__avr32_f64_div_res_subnormal+0x98>
8000c5e2:	c9 28       	rjmp	8000c706 <__avr32_f64_div_res_subnormal+0x8c>
8000c5e4:	a3 7b       	lsl	r11,0x3
8000c5e6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c5ea:	a3 7a       	lsl	r10,0x3
8000c5ec:	f5 eb 10 04 	or	r4,r10,r11
8000c5f0:	e0 80 00 a0 	breq	8000c730 <__avr32_f64_div_op1_zero>
8000c5f4:	f6 04 12 00 	clz	r4,r11
8000c5f8:	c1 70       	breq	8000c626 <__avr32_f64_div_round_subnormal+0x96>
8000c5fa:	c0 c3       	brcs	8000c612 <__avr32_f64_div_round_subnormal+0x82>
8000c5fc:	e8 05 11 20 	rsub	r5,r4,32
8000c600:	f6 04 09 4b 	lsl	r11,r11,r4
8000c604:	f4 05 0a 45 	lsr	r5,r10,r5
8000c608:	0a 4b       	or	r11,r5
8000c60a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c60e:	08 17       	sub	r7,r4
8000c610:	c0 b8       	rjmp	8000c626 <__avr32_f64_div_round_subnormal+0x96>
8000c612:	f4 04 12 00 	clz	r4,r10
8000c616:	f9 b4 03 00 	movlo	r4,0
8000c61a:	f7 b4 02 e0 	subhs	r4,-32
8000c61e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c622:	30 0a       	mov	r10,0
8000c624:	08 17       	sub	r7,r4
8000c626:	a3 8a       	lsr	r10,0x2
8000c628:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c62c:	a3 8b       	lsr	r11,0x2
8000c62e:	c1 1b       	rjmp	8000c450 <__avr32_f64_div+0x20>
8000c630:	a3 79       	lsl	r9,0x3
8000c632:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c636:	a3 78       	lsl	r8,0x3
8000c638:	f3 e8 10 04 	or	r4,r9,r8
8000c63c:	c6 f0       	breq	8000c71a <__avr32_f64_div_res_subnormal+0xa0>
8000c63e:	f2 04 12 00 	clz	r4,r9
8000c642:	c1 70       	breq	8000c670 <__avr32_f64_div_round_subnormal+0xe0>
8000c644:	c0 c3       	brcs	8000c65c <__avr32_f64_div_round_subnormal+0xcc>
8000c646:	e8 05 11 20 	rsub	r5,r4,32
8000c64a:	f2 04 09 49 	lsl	r9,r9,r4
8000c64e:	f0 05 0a 45 	lsr	r5,r8,r5
8000c652:	0a 49       	or	r9,r5
8000c654:	f0 04 09 48 	lsl	r8,r8,r4
8000c658:	08 16       	sub	r6,r4
8000c65a:	c0 b8       	rjmp	8000c670 <__avr32_f64_div_round_subnormal+0xe0>
8000c65c:	f0 04 12 00 	clz	r4,r8
8000c660:	f9 b4 03 00 	movlo	r4,0
8000c664:	f7 b4 02 e0 	subhs	r4,-32
8000c668:	f0 04 09 49 	lsl	r9,r8,r4
8000c66c:	30 08       	mov	r8,0
8000c66e:	08 16       	sub	r6,r4
8000c670:	a3 88       	lsr	r8,0x2
8000c672:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c676:	a3 89       	lsr	r9,0x2
8000c678:	cf ca       	rjmp	8000c470 <__avr32_f64_div+0x40>

8000c67a <__avr32_f64_div_res_subnormal>:
8000c67a:	5c 37       	neg	r7
8000c67c:	2f f7       	sub	r7,-1
8000c67e:	f1 b7 04 c0 	satu	r7,0x6
8000c682:	e0 47 00 20 	cp.w	r7,32
8000c686:	c1 54       	brge	8000c6b0 <__avr32_f64_div_res_subnormal+0x36>
8000c688:	ee 06 11 20 	rsub	r6,r7,32
8000c68c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c690:	e6 06 09 4c 	lsl	r12,r3,r6
8000c694:	18 42       	or	r2,r12
8000c696:	e6 07 0a 43 	lsr	r3,r3,r7
8000c69a:	f4 06 09 41 	lsl	r1,r10,r6
8000c69e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c6a2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c6a6:	18 4a       	or	r10,r12
8000c6a8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c6ac:	30 00       	mov	r0,0
8000c6ae:	c1 58       	rjmp	8000c6d8 <__avr32_f64_div_res_subnormal+0x5e>
8000c6b0:	ee 06 11 20 	rsub	r6,r7,32
8000c6b4:	f9 b0 00 00 	moveq	r0,0
8000c6b8:	f9 bc 00 00 	moveq	r12,0
8000c6bc:	c0 50       	breq	8000c6c6 <__avr32_f64_div_res_subnormal+0x4c>
8000c6be:	f4 06 09 40 	lsl	r0,r10,r6
8000c6c2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c6c6:	e6 07 0a 42 	lsr	r2,r3,r7
8000c6ca:	30 03       	mov	r3,0
8000c6cc:	f4 07 0a 41 	lsr	r1,r10,r7
8000c6d0:	18 41       	or	r1,r12
8000c6d2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c6d6:	30 0b       	mov	r11,0
8000c6d8:	e0 12 ff 00 	andl	r2,0xff00
8000c6dc:	e8 12 00 80 	orl	r2,0x80
8000c6e0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c6e4:	e4 09 07 46 	macu.d	r6,r2,r9
8000c6e8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6ec:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6f0:	0c 05       	add	r5,r6
8000c6f2:	f0 07 00 48 	adc	r8,r8,r7
8000c6f6:	5c 09       	acr	r9
8000c6f8:	30 07       	mov	r7,0
8000c6fa:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6fe:	00 34       	cp.w	r4,r0
8000c700:	e2 05 13 00 	cpc	r5,r1
8000c704:	c4 6b       	rjmp	8000c590 <__avr32_f64_div_round_subnormal>
8000c706:	1c 9b       	mov	r11,lr
8000c708:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c70c:	30 0a       	mov	r10,0
8000c70e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c712:	3f fb       	mov	r11,-1
8000c714:	30 0a       	mov	r10,0
8000c716:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c71a:	f5 eb 10 04 	or	r4,r10,r11
8000c71e:	c0 90       	breq	8000c730 <__avr32_f64_div_op1_zero>
8000c720:	1c 9b       	mov	r11,lr
8000c722:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c726:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c72a:	30 0a       	mov	r10,0
8000c72c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c730 <__avr32_f64_div_op1_zero>:
8000c730:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c734:	ce f0       	breq	8000c712 <__avr32_f64_div_res_subnormal+0x98>
8000c736:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c73a:	e0 44 07 ff 	cp.w	r4,2047
8000c73e:	ce 41       	brne	8000c706 <__avr32_f64_div_res_subnormal+0x8c>
8000c740:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c744:	ce 10       	breq	8000c706 <__avr32_f64_div_res_subnormal+0x8c>
8000c746:	ce 6b       	rjmp	8000c712 <__avr32_f64_div_res_subnormal+0x98>

8000c748 <__avr32_udiv64>:
8000c748:	d4 31       	pushm	r0-r7,lr
8000c74a:	1a 97       	mov	r7,sp
8000c74c:	20 3d       	sub	sp,12
8000c74e:	10 9c       	mov	r12,r8
8000c750:	12 9e       	mov	lr,r9
8000c752:	14 93       	mov	r3,r10
8000c754:	58 09       	cp.w	r9,0
8000c756:	e0 81 00 bd 	brne	8000c8d0 <__avr32_udiv64+0x188>
8000c75a:	16 38       	cp.w	r8,r11
8000c75c:	e0 88 00 40 	brls	8000c7dc <__avr32_udiv64+0x94>
8000c760:	f0 08 12 00 	clz	r8,r8
8000c764:	c0 d0       	breq	8000c77e <__avr32_udiv64+0x36>
8000c766:	f6 08 09 4b 	lsl	r11,r11,r8
8000c76a:	f0 09 11 20 	rsub	r9,r8,32
8000c76e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c772:	f4 09 0a 49 	lsr	r9,r10,r9
8000c776:	f4 08 09 43 	lsl	r3,r10,r8
8000c77a:	f3 eb 10 0b 	or	r11,r9,r11
8000c77e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c782:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c786:	f6 0e 0d 00 	divu	r0,r11,lr
8000c78a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c78e:	00 99       	mov	r9,r0
8000c790:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c794:	e0 0a 02 48 	mul	r8,r0,r10
8000c798:	10 3b       	cp.w	r11,r8
8000c79a:	c0 a2       	brcc	8000c7ae <__avr32_udiv64+0x66>
8000c79c:	20 19       	sub	r9,1
8000c79e:	18 0b       	add	r11,r12
8000c7a0:	18 3b       	cp.w	r11,r12
8000c7a2:	c0 63       	brcs	8000c7ae <__avr32_udiv64+0x66>
8000c7a4:	10 3b       	cp.w	r11,r8
8000c7a6:	f7 b9 03 01 	sublo	r9,1
8000c7aa:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7ae:	f6 08 01 01 	sub	r1,r11,r8
8000c7b2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c7b6:	e2 0e 0d 00 	divu	r0,r1,lr
8000c7ba:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c7be:	00 98       	mov	r8,r0
8000c7c0:	e0 0a 02 4a 	mul	r10,r0,r10
8000c7c4:	14 33       	cp.w	r3,r10
8000c7c6:	c0 82       	brcc	8000c7d6 <__avr32_udiv64+0x8e>
8000c7c8:	20 18       	sub	r8,1
8000c7ca:	18 03       	add	r3,r12
8000c7cc:	18 33       	cp.w	r3,r12
8000c7ce:	c0 43       	brcs	8000c7d6 <__avr32_udiv64+0x8e>
8000c7d0:	14 33       	cp.w	r3,r10
8000c7d2:	f7 b8 03 01 	sublo	r8,1
8000c7d6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c7da:	cd f8       	rjmp	8000c998 <__avr32_udiv64+0x250>
8000c7dc:	58 08       	cp.w	r8,0
8000c7de:	c0 51       	brne	8000c7e8 <__avr32_udiv64+0xa0>
8000c7e0:	30 19       	mov	r9,1
8000c7e2:	f2 08 0d 08 	divu	r8,r9,r8
8000c7e6:	10 9c       	mov	r12,r8
8000c7e8:	f8 06 12 00 	clz	r6,r12
8000c7ec:	c0 41       	brne	8000c7f4 <__avr32_udiv64+0xac>
8000c7ee:	18 1b       	sub	r11,r12
8000c7f0:	30 19       	mov	r9,1
8000c7f2:	c4 08       	rjmp	8000c872 <__avr32_udiv64+0x12a>
8000c7f4:	ec 01 11 20 	rsub	r1,r6,32
8000c7f8:	f4 01 0a 49 	lsr	r9,r10,r1
8000c7fc:	f8 06 09 4c 	lsl	r12,r12,r6
8000c800:	f6 06 09 48 	lsl	r8,r11,r6
8000c804:	f6 01 0a 41 	lsr	r1,r11,r1
8000c808:	f3 e8 10 08 	or	r8,r9,r8
8000c80c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c810:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c814:	e2 03 0d 00 	divu	r0,r1,r3
8000c818:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c81c:	00 9e       	mov	lr,r0
8000c81e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c822:	e0 05 02 49 	mul	r9,r0,r5
8000c826:	12 3b       	cp.w	r11,r9
8000c828:	c0 a2       	brcc	8000c83c <__avr32_udiv64+0xf4>
8000c82a:	20 1e       	sub	lr,1
8000c82c:	18 0b       	add	r11,r12
8000c82e:	18 3b       	cp.w	r11,r12
8000c830:	c0 63       	brcs	8000c83c <__avr32_udiv64+0xf4>
8000c832:	12 3b       	cp.w	r11,r9
8000c834:	f7 be 03 01 	sublo	lr,1
8000c838:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c83c:	12 1b       	sub	r11,r9
8000c83e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c842:	f6 03 0d 02 	divu	r2,r11,r3
8000c846:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c84a:	04 99       	mov	r9,r2
8000c84c:	e4 05 02 4b 	mul	r11,r2,r5
8000c850:	16 38       	cp.w	r8,r11
8000c852:	c0 a2       	brcc	8000c866 <__avr32_udiv64+0x11e>
8000c854:	20 19       	sub	r9,1
8000c856:	18 08       	add	r8,r12
8000c858:	18 38       	cp.w	r8,r12
8000c85a:	c0 63       	brcs	8000c866 <__avr32_udiv64+0x11e>
8000c85c:	16 38       	cp.w	r8,r11
8000c85e:	f7 b9 03 01 	sublo	r9,1
8000c862:	f1 dc e3 08 	addcs	r8,r8,r12
8000c866:	f4 06 09 43 	lsl	r3,r10,r6
8000c86a:	f0 0b 01 0b 	sub	r11,r8,r11
8000c86e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c872:	f8 06 16 10 	lsr	r6,r12,0x10
8000c876:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c87a:	f6 06 0d 00 	divu	r0,r11,r6
8000c87e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c882:	00 9a       	mov	r10,r0
8000c884:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c888:	e0 0e 02 48 	mul	r8,r0,lr
8000c88c:	10 3b       	cp.w	r11,r8
8000c88e:	c0 a2       	brcc	8000c8a2 <__avr32_udiv64+0x15a>
8000c890:	20 1a       	sub	r10,1
8000c892:	18 0b       	add	r11,r12
8000c894:	18 3b       	cp.w	r11,r12
8000c896:	c0 63       	brcs	8000c8a2 <__avr32_udiv64+0x15a>
8000c898:	10 3b       	cp.w	r11,r8
8000c89a:	f7 ba 03 01 	sublo	r10,1
8000c89e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8a2:	f6 08 01 01 	sub	r1,r11,r8
8000c8a6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c8aa:	e2 06 0d 00 	divu	r0,r1,r6
8000c8ae:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c8b2:	00 98       	mov	r8,r0
8000c8b4:	e0 0e 02 4b 	mul	r11,r0,lr
8000c8b8:	16 33       	cp.w	r3,r11
8000c8ba:	c0 82       	brcc	8000c8ca <__avr32_udiv64+0x182>
8000c8bc:	20 18       	sub	r8,1
8000c8be:	18 03       	add	r3,r12
8000c8c0:	18 33       	cp.w	r3,r12
8000c8c2:	c0 43       	brcs	8000c8ca <__avr32_udiv64+0x182>
8000c8c4:	16 33       	cp.w	r3,r11
8000c8c6:	f7 b8 03 01 	sublo	r8,1
8000c8ca:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c8ce:	c6 98       	rjmp	8000c9a0 <__avr32_udiv64+0x258>
8000c8d0:	16 39       	cp.w	r9,r11
8000c8d2:	e0 8b 00 65 	brhi	8000c99c <__avr32_udiv64+0x254>
8000c8d6:	f2 09 12 00 	clz	r9,r9
8000c8da:	c0 b1       	brne	8000c8f0 <__avr32_udiv64+0x1a8>
8000c8dc:	10 3a       	cp.w	r10,r8
8000c8de:	5f 2a       	srhs	r10
8000c8e0:	1c 3b       	cp.w	r11,lr
8000c8e2:	5f b8       	srhi	r8
8000c8e4:	10 4a       	or	r10,r8
8000c8e6:	f2 0a 18 00 	cp.b	r10,r9
8000c8ea:	c5 90       	breq	8000c99c <__avr32_udiv64+0x254>
8000c8ec:	30 18       	mov	r8,1
8000c8ee:	c5 98       	rjmp	8000c9a0 <__avr32_udiv64+0x258>
8000c8f0:	f0 09 09 46 	lsl	r6,r8,r9
8000c8f4:	f2 03 11 20 	rsub	r3,r9,32
8000c8f8:	fc 09 09 4e 	lsl	lr,lr,r9
8000c8fc:	f0 03 0a 48 	lsr	r8,r8,r3
8000c900:	f6 09 09 4c 	lsl	r12,r11,r9
8000c904:	f4 03 0a 42 	lsr	r2,r10,r3
8000c908:	ef 46 ff f4 	st.w	r7[-12],r6
8000c90c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c910:	18 42       	or	r2,r12
8000c912:	f1 ee 10 0c 	or	r12,r8,lr
8000c916:	f8 01 16 10 	lsr	r1,r12,0x10
8000c91a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c91e:	e6 01 0d 04 	divu	r4,r3,r1
8000c922:	e4 03 16 10 	lsr	r3,r2,0x10
8000c926:	08 9e       	mov	lr,r4
8000c928:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c92c:	e8 06 02 48 	mul	r8,r4,r6
8000c930:	10 33       	cp.w	r3,r8
8000c932:	c0 a2       	brcc	8000c946 <__avr32_udiv64+0x1fe>
8000c934:	20 1e       	sub	lr,1
8000c936:	18 03       	add	r3,r12
8000c938:	18 33       	cp.w	r3,r12
8000c93a:	c0 63       	brcs	8000c946 <__avr32_udiv64+0x1fe>
8000c93c:	10 33       	cp.w	r3,r8
8000c93e:	f7 be 03 01 	sublo	lr,1
8000c942:	e7 dc e3 03 	addcs	r3,r3,r12
8000c946:	10 13       	sub	r3,r8
8000c948:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c94c:	e6 01 0d 00 	divu	r0,r3,r1
8000c950:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c954:	00 98       	mov	r8,r0
8000c956:	e0 06 02 46 	mul	r6,r0,r6
8000c95a:	0c 3b       	cp.w	r11,r6
8000c95c:	c0 a2       	brcc	8000c970 <__avr32_udiv64+0x228>
8000c95e:	20 18       	sub	r8,1
8000c960:	18 0b       	add	r11,r12
8000c962:	18 3b       	cp.w	r11,r12
8000c964:	c0 63       	brcs	8000c970 <__avr32_udiv64+0x228>
8000c966:	0c 3b       	cp.w	r11,r6
8000c968:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c96c:	f7 b8 03 01 	sublo	r8,1
8000c970:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c974:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c978:	0c 1b       	sub	r11,r6
8000c97a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c97e:	06 95       	mov	r5,r3
8000c980:	16 35       	cp.w	r5,r11
8000c982:	e0 8b 00 0a 	brhi	8000c996 <__avr32_udiv64+0x24e>
8000c986:	5f 0b       	sreq	r11
8000c988:	f4 09 09 49 	lsl	r9,r10,r9
8000c98c:	12 32       	cp.w	r2,r9
8000c98e:	5f b9       	srhi	r9
8000c990:	f7 e9 00 09 	and	r9,r11,r9
8000c994:	c0 60       	breq	8000c9a0 <__avr32_udiv64+0x258>
8000c996:	20 18       	sub	r8,1
8000c998:	30 09       	mov	r9,0
8000c99a:	c0 38       	rjmp	8000c9a0 <__avr32_udiv64+0x258>
8000c99c:	30 09       	mov	r9,0
8000c99e:	12 98       	mov	r8,r9
8000c9a0:	10 9a       	mov	r10,r8
8000c9a2:	12 93       	mov	r3,r9
8000c9a4:	10 92       	mov	r2,r8
8000c9a6:	12 9b       	mov	r11,r9
8000c9a8:	2f dd       	sub	sp,-12
8000c9aa:	d8 32       	popm	r0-r7,pc

8000c9ac <__avr32_umod64>:
8000c9ac:	d4 31       	pushm	r0-r7,lr
8000c9ae:	1a 97       	mov	r7,sp
8000c9b0:	20 3d       	sub	sp,12
8000c9b2:	10 9c       	mov	r12,r8
8000c9b4:	12 95       	mov	r5,r9
8000c9b6:	14 9e       	mov	lr,r10
8000c9b8:	16 91       	mov	r1,r11
8000c9ba:	16 96       	mov	r6,r11
8000c9bc:	58 09       	cp.w	r9,0
8000c9be:	e0 81 00 81 	brne	8000cac0 <__avr32_umod64+0x114>
8000c9c2:	16 38       	cp.w	r8,r11
8000c9c4:	e0 88 00 12 	brls	8000c9e8 <__avr32_umod64+0x3c>
8000c9c8:	f0 08 12 00 	clz	r8,r8
8000c9cc:	c4 e0       	breq	8000ca68 <__avr32_umod64+0xbc>
8000c9ce:	f6 08 09 46 	lsl	r6,r11,r8
8000c9d2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c9d6:	f0 0b 11 20 	rsub	r11,r8,32
8000c9da:	f4 08 09 4e 	lsl	lr,r10,r8
8000c9de:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c9e2:	f7 e6 10 06 	or	r6,r11,r6
8000c9e6:	c4 18       	rjmp	8000ca68 <__avr32_umod64+0xbc>
8000c9e8:	58 08       	cp.w	r8,0
8000c9ea:	c0 51       	brne	8000c9f4 <__avr32_umod64+0x48>
8000c9ec:	30 19       	mov	r9,1
8000c9ee:	f2 08 0d 08 	divu	r8,r9,r8
8000c9f2:	10 9c       	mov	r12,r8
8000c9f4:	f8 08 12 00 	clz	r8,r12
8000c9f8:	c0 31       	brne	8000c9fe <__avr32_umod64+0x52>
8000c9fa:	18 16       	sub	r6,r12
8000c9fc:	c3 68       	rjmp	8000ca68 <__avr32_umod64+0xbc>
8000c9fe:	f0 03 11 20 	rsub	r3,r8,32
8000ca02:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ca06:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca0a:	ec 08 09 49 	lsl	r9,r6,r8
8000ca0e:	ec 03 0a 43 	lsr	r3,r6,r3
8000ca12:	f7 e9 10 09 	or	r9,r11,r9
8000ca16:	f8 05 16 10 	lsr	r5,r12,0x10
8000ca1a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca1e:	e6 05 0d 02 	divu	r2,r3,r5
8000ca22:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ca26:	ec 02 02 4b 	mul	r11,r6,r2
8000ca2a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ca2e:	16 3e       	cp.w	lr,r11
8000ca30:	c0 72       	brcc	8000ca3e <__avr32_umod64+0x92>
8000ca32:	18 0e       	add	lr,r12
8000ca34:	18 3e       	cp.w	lr,r12
8000ca36:	c0 43       	brcs	8000ca3e <__avr32_umod64+0x92>
8000ca38:	16 3e       	cp.w	lr,r11
8000ca3a:	fd dc e3 0e 	addcs	lr,lr,r12
8000ca3e:	fc 0b 01 03 	sub	r3,lr,r11
8000ca42:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000ca46:	e6 05 0d 02 	divu	r2,r3,r5
8000ca4a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ca4e:	a5 36       	mul	r6,r2
8000ca50:	0c 39       	cp.w	r9,r6
8000ca52:	c0 72       	brcc	8000ca60 <__avr32_umod64+0xb4>
8000ca54:	18 09       	add	r9,r12
8000ca56:	18 39       	cp.w	r9,r12
8000ca58:	c0 43       	brcs	8000ca60 <__avr32_umod64+0xb4>
8000ca5a:	0c 39       	cp.w	r9,r6
8000ca5c:	f3 dc e3 09 	addcs	r9,r9,r12
8000ca60:	f2 06 01 06 	sub	r6,r9,r6
8000ca64:	f4 08 09 4e 	lsl	lr,r10,r8
8000ca68:	f8 0a 16 10 	lsr	r10,r12,0x10
8000ca6c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ca70:	ec 0a 0d 02 	divu	r2,r6,r10
8000ca74:	fc 09 16 10 	lsr	r9,lr,0x10
8000ca78:	ea 02 02 4b 	mul	r11,r5,r2
8000ca7c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ca80:	16 39       	cp.w	r9,r11
8000ca82:	c0 72       	brcc	8000ca90 <__avr32_umod64+0xe4>
8000ca84:	18 09       	add	r9,r12
8000ca86:	18 39       	cp.w	r9,r12
8000ca88:	c0 43       	brcs	8000ca90 <__avr32_umod64+0xe4>
8000ca8a:	16 39       	cp.w	r9,r11
8000ca8c:	f3 dc e3 09 	addcs	r9,r9,r12
8000ca90:	f2 0b 01 0b 	sub	r11,r9,r11
8000ca94:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ca98:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ca9c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000caa0:	ea 0a 02 4a 	mul	r10,r5,r10
8000caa4:	14 3e       	cp.w	lr,r10
8000caa6:	c0 72       	brcc	8000cab4 <__avr32_umod64+0x108>
8000caa8:	18 0e       	add	lr,r12
8000caaa:	18 3e       	cp.w	lr,r12
8000caac:	c0 43       	brcs	8000cab4 <__avr32_umod64+0x108>
8000caae:	14 3e       	cp.w	lr,r10
8000cab0:	fd dc e3 0e 	addcs	lr,lr,r12
8000cab4:	fc 0a 01 0a 	sub	r10,lr,r10
8000cab8:	30 0b       	mov	r11,0
8000caba:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cabe:	c7 b8       	rjmp	8000cbb4 <__avr32_umod64+0x208>
8000cac0:	16 39       	cp.w	r9,r11
8000cac2:	e0 8b 00 79 	brhi	8000cbb4 <__avr32_umod64+0x208>
8000cac6:	f2 09 12 00 	clz	r9,r9
8000caca:	c1 21       	brne	8000caee <__avr32_umod64+0x142>
8000cacc:	10 3a       	cp.w	r10,r8
8000cace:	5f 2b       	srhs	r11
8000cad0:	0a 31       	cp.w	r1,r5
8000cad2:	5f ba       	srhi	r10
8000cad4:	f7 ea 10 0a 	or	r10,r11,r10
8000cad8:	f2 0a 18 00 	cp.b	r10,r9
8000cadc:	c0 60       	breq	8000cae8 <__avr32_umod64+0x13c>
8000cade:	fc 08 01 0c 	sub	r12,lr,r8
8000cae2:	e2 05 01 46 	sbc	r6,r1,r5
8000cae6:	18 9e       	mov	lr,r12
8000cae8:	0c 9b       	mov	r11,r6
8000caea:	1c 9a       	mov	r10,lr
8000caec:	c6 48       	rjmp	8000cbb4 <__avr32_umod64+0x208>
8000caee:	ea 09 09 4c 	lsl	r12,r5,r9
8000caf2:	f2 06 11 20 	rsub	r6,r9,32
8000caf6:	f6 09 09 4b 	lsl	r11,r11,r9
8000cafa:	f0 09 09 42 	lsl	r2,r8,r9
8000cafe:	ef 46 ff f4 	st.w	r7[-12],r6
8000cb02:	f0 06 0a 48 	lsr	r8,r8,r6
8000cb06:	18 48       	or	r8,r12
8000cb08:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cb0c:	f4 09 09 43 	lsl	r3,r10,r9
8000cb10:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cb14:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cb18:	16 4a       	or	r10,r11
8000cb1a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cb1e:	f8 0b 0d 04 	divu	r4,r12,r11
8000cb22:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cb26:	08 91       	mov	r1,r4
8000cb28:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cb2c:	e8 0e 02 46 	mul	r6,r4,lr
8000cb30:	0c 3c       	cp.w	r12,r6
8000cb32:	c0 a2       	brcc	8000cb46 <__avr32_umod64+0x19a>
8000cb34:	20 11       	sub	r1,1
8000cb36:	10 0c       	add	r12,r8
8000cb38:	10 3c       	cp.w	r12,r8
8000cb3a:	c0 63       	brcs	8000cb46 <__avr32_umod64+0x19a>
8000cb3c:	0c 3c       	cp.w	r12,r6
8000cb3e:	f7 b1 03 01 	sublo	r1,1
8000cb42:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cb46:	0c 1c       	sub	r12,r6
8000cb48:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cb4c:	f8 0b 0d 04 	divu	r4,r12,r11
8000cb50:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cb54:	08 96       	mov	r6,r4
8000cb56:	e8 0e 02 4e 	mul	lr,r4,lr
8000cb5a:	1c 3b       	cp.w	r11,lr
8000cb5c:	c0 a2       	brcc	8000cb70 <__avr32_umod64+0x1c4>
8000cb5e:	20 16       	sub	r6,1
8000cb60:	10 0b       	add	r11,r8
8000cb62:	10 3b       	cp.w	r11,r8
8000cb64:	c0 63       	brcs	8000cb70 <__avr32_umod64+0x1c4>
8000cb66:	1c 3b       	cp.w	r11,lr
8000cb68:	f7 b6 03 01 	sublo	r6,1
8000cb6c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cb70:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cb74:	1c 1b       	sub	r11,lr
8000cb76:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cb7a:	00 9e       	mov	lr,r0
8000cb7c:	02 9c       	mov	r12,r1
8000cb7e:	16 3c       	cp.w	r12,r11
8000cb80:	e0 8b 00 08 	brhi	8000cb90 <__avr32_umod64+0x1e4>
8000cb84:	5f 06       	sreq	r6
8000cb86:	06 30       	cp.w	r0,r3
8000cb88:	5f ba       	srhi	r10
8000cb8a:	ed ea 00 0a 	and	r10,r6,r10
8000cb8e:	c0 60       	breq	8000cb9a <__avr32_umod64+0x1ee>
8000cb90:	fc 02 01 04 	sub	r4,lr,r2
8000cb94:	f8 08 01 4c 	sbc	r12,r12,r8
8000cb98:	08 9e       	mov	lr,r4
8000cb9a:	e6 0e 01 0a 	sub	r10,r3,lr
8000cb9e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cba2:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cba6:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cbaa:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cbae:	f8 01 09 4c 	lsl	r12,r12,r1
8000cbb2:	18 4a       	or	r10,r12
8000cbb4:	2f dd       	sub	sp,-12
8000cbb6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 7c 	sub	pc,pc,28796

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 ef 	rcall	800054e4 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 e8 	rcall	800054e4 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 e1 	rcall	800054e4 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 da 	rcall	800054e4 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
