
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000d8f4  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000fa00  8000fa00  0000fe00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009650  8000fc00  8000fc00  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019250  00019808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  80019c84  0001a23c  2**0
                  ALLOC
  8 .bss          00003be8  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         000129d8  00004628  00004628  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001a23c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001620  00000000  00000000  0001a270  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002ade  00000000  00000000  0001b890  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002e958  00000000  00000000  0001e36e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00007853  00000000  00000000  0004ccc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000df81  00000000  00000000  00054519  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003cd4  00000000  00000000  0006249c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007fbd  00000000  00000000  00066170  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0001207e  00000000  00000000  0006e12d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001718  00000000  00000000  000801b0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	9e 7c       	ld.sh	r12,pc[0xe]

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 81 8c 	sub	pc,pc,-32372

Disassembly of section .text:

8000200c <DeviceManagement_brdcst_func>:
8000200c:	19 a9       	ld.ub	r9,r12[0x2]
8000200e:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	f0 09 18 00 	cp.b	r9,r8
80002014:	c0 61       	brne	80002020 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002016:	48 68       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002018:	70 09       	ld.w	r9,r8[0x0]
8000201a:	a1 b9       	sbr	r9,0x1
8000201c:	91 09       	st.w	r8[0x0],r9
8000201e:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002020:	48 38       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002022:	70 09       	ld.w	r9,r8[0x0]
80002024:	a1 d9       	cbr	r9,0x1
80002026:	91 09       	st.w	r8[0x0],r9
80002028:	5e fc       	retal	r12
8000202a:	00 00       	add	r0,r0
8000202c:	00 00       	add	r0,r0
8000202e:	12 c4       	st.b	r9++,r4

80002030 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002030:	5e fc       	retal	r12

80002032 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002032:	5e fc       	retal	r12

80002034 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002034:	48 38       	lddpc	r8,80002040 <vApplicationIdleHook+0xc>
80002036:	70 09       	ld.w	r9,r8[0x0]
80002038:	2f f9       	sub	r9,-1
8000203a:	91 09       	st.w	r8[0x0],r9
	
}
8000203c:	5e fc       	retal	r12
8000203e:	00 00       	add	r0,r0
80002040:	00 00       	add	r0,r0
80002042:	0a 58       	eor	r8,r5

80002044 <app_init>:
														
		
};

void app_init(void)
{	
80002044:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002046:	48 cb       	lddpc	r11,80002074 <app_init+0x30>
80002048:	48 cc       	lddpc	r12,80002078 <app_init+0x34>
8000204a:	f0 1f 00 0d 	mcall	8000207c <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204e:	48 dc       	lddpc	r12,80002080 <app_init+0x3c>
80002050:	f0 1f 00 0d 	mcall	80002084 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002054:	30 09       	mov	r9,0
80002056:	1a d9       	st.w	--sp,r9
80002058:	1a d9       	st.w	--sp,r9
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	30 18       	mov	r8,1
8000205e:	e0 6a 01 80 	mov	r10,384
80002062:	48 ab       	lddpc	r11,80002088 <app_init+0x44>
80002064:	48 ac       	lddpc	r12,8000208c <app_init+0x48>
80002066:	f0 1f 00 0b 	mcall	80002090 <app_init+0x4c>
8000206a:	48 b8       	lddpc	r8,80002094 <app_init+0x50>
8000206c:	91 0c       	st.w	r8[0x0],r12
8000206e:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002070:	d8 02       	popm	pc
80002072:	00 00       	add	r0,r0
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 50       	sub	r0,-123
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 7c       	sub	r12,-121
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	39 28       	mov	r8,-110
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	4d 44       	lddpc	r4,800021d4 <ButtonConfig_brdcst_func+0x3c>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	fc 00       	*unknown*
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	27 c0       	sub	r0,124
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	95 b0       	st.w	r10[0x2c],r0
80002094:	00 00       	add	r0,r0
80002096:	0a 50       	eor	r0,r5

80002098 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_brdcst_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_brdcst_func+0x10>
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	fc 08       	*unknown*
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	99 74       	st.w	r12[0x1c],r4

800020ac <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_reply_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_reply_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	fc 28 80 00 	sub	r8,-229376
800020be:	99 74       	st.w	r12[0x1c],r4

800020c0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <FD_request_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <FD_request_func+0x10>
	
	
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	fc 44 80 00 	cp.w	r4,-229376
800020d2:	99 74       	st.w	r12[0x1c],r4

800020d4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020d6:	48 3c       	lddpc	r12,800020e0 <EnOB_brdcst_func+0xc>
800020d8:	f0 1f 00 03 	mcall	800020e4 <EnOB_brdcst_func+0x10>
}
800020dc:	d8 02       	popm	pc
800020de:	00 00       	add	r0,r0
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	fc 60 80 00 	mov	r0,-229376
800020e6:	99 74       	st.w	r12[0x1c],r4

800020e8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020e8:	eb cd 40 80 	pushm	r7,lr
800020ec:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020ee:	19 a9       	ld.ub	r9,r12[0x2]
800020f0:	30 08       	mov	r8,0
800020f2:	f0 09 18 00 	cp.b	r9,r8
800020f6:	c1 91       	brne	80002128 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020f8:	19 b8       	ld.ub	r8,r12[0x3]
800020fa:	30 19       	mov	r9,1
800020fc:	f2 08 18 00 	cp.b	r8,r9
80002100:	c0 61       	brne	8000210c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002102:	49 0c       	lddpc	r12,80002140 <EnOB_reply_func+0x58>
80002104:	f0 1f 00 10 	mcall	80002144 <EnOB_reply_func+0x5c>
80002108:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000210c:	58 08       	cp.w	r8,0
8000210e:	c0 61       	brne	8000211a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002110:	48 ec       	lddpc	r12,80002148 <EnOB_reply_func+0x60>
80002112:	f0 1f 00 0d 	mcall	80002144 <EnOB_reply_func+0x5c>
80002116:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211a:	1a d8       	st.w	--sp,r8
8000211c:	48 cc       	lddpc	r12,8000214c <EnOB_reply_func+0x64>
8000211e:	f0 1f 00 0a 	mcall	80002144 <EnOB_reply_func+0x5c>
80002122:	2f fd       	sub	sp,-4
80002124:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002128:	48 ac       	lddpc	r12,80002150 <EnOB_reply_func+0x68>
8000212a:	f0 1f 00 07 	mcall	80002144 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000212e:	0f a8       	ld.ub	r8,r7[0x2]
80002130:	1a d8       	st.w	--sp,r8
80002132:	48 9c       	lddpc	r12,80002154 <EnOB_reply_func+0x6c>
80002134:	f0 1f 00 04 	mcall	80002144 <EnOB_reply_func+0x5c>
80002138:	2f fd       	sub	sp,-4
8000213a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	fc 78 80 00 	mov	r8,-163840
80002146:	99 74       	st.w	r12[0x1c],r4
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	fc 90 80 00 	breq	7ffb214a <_estack+0x7ff9a14a>
8000214e:	fc a4       	*unknown*
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	fc bc       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	fc d8 eb cd 	satsub.w	r8,lr,-5171

80002158 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	eb cd 40 80 	pushm	r7,lr
8000215c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000215e:	19 a9       	ld.ub	r9,r12[0x2]
80002160:	31 18       	mov	r8,17
80002162:	f0 09 18 00 	cp.b	r9,r8
80002166:	c0 61       	brne	80002172 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002168:	48 8c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x30>
8000216a:	f0 1f 00 09 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
8000216e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002172:	48 8c       	lddpc	r12,80002190 <SingleDetection_brdcst_func+0x38>
80002174:	f0 1f 00 06 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002178:	0f a8       	ld.ub	r8,r7[0x2]
8000217a:	1a d8       	st.w	--sp,r8
8000217c:	48 6c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x3c>
8000217e:	f0 1f 00 04 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
80002182:	2f fd       	sub	sp,-4
80002184:	e3 cd 80 80 	ldm	sp++,r7,pc
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	fc f0 80 00 	ld.w	r0,lr[-32768]
8000218e:	99 74       	st.w	r12[0x1c],r4
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	fd 04 80 00 	ld.sh	r4,lr[-32768]
80002196:	fd 14 d4 31 	ld.uh	r4,lr[-11215]

80002198 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000219e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a0:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xb4>
800021a2:	f0 1f 00 2c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021a6:	0f 88       	ld.ub	r8,r7[0x0]
800021a8:	1a d8       	st.w	--sp,r8
800021aa:	4a bc       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xbc>
800021ac:	f0 1f 00 29 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b0:	1a d5       	st.w	--sp,r5
800021b2:	4a ac       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xc0>
800021b4:	f0 1f 00 27 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b8:	0f a8       	ld.ub	r8,r7[0x2]
800021ba:	1a d8       	st.w	--sp,r8
800021bc:	4a 8c       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc4>
800021be:	f0 1f 00 25 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c2:	2f dd       	sub	sp,-12
800021c4:	58 05       	cp.w	r5,0
800021c6:	c4 10       	breq	80002248 <ButtonConfig_brdcst_func+0xb0>
800021c8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ca:	4a 64       	lddpc	r4,80002260 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021cc:	4a 63       	lddpc	r3,80002264 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ce:	4a 72       	lddpc	r2,80002268 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d0:	4a 71       	lddpc	r1,8000226c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d2:	4a 80       	lddpc	r0,80002270 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d4:	0f b9       	ld.ub	r9,r7[0x3]
800021d6:	0f c8       	ld.ub	r8,r7[0x4]
800021d8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021dc:	1a d8       	st.w	--sp,r8
800021de:	1a d6       	st.w	--sp,r6
800021e0:	08 9c       	mov	r12,r4
800021e2:	f0 1f 00 1c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e6:	0f d9       	ld.ub	r9,r7[0x5]
800021e8:	0f e8       	ld.ub	r8,r7[0x6]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	06 9c       	mov	r12,r3
800021f4:	f0 1f 00 17 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f8:	0f f9       	ld.ub	r9,r7[0x7]
800021fa:	ef 38 00 08 	ld.ub	r8,r7[8]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	04 9c       	mov	r12,r2
80002208:	f0 1f 00 12 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000220c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002210:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	02 9c       	mov	r12,r1
8000221e:	f0 1f 00 0d 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002222:	2f 8d       	sub	sp,-32
80002224:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002228:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000222c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002230:	1a d8       	st.w	--sp,r8
80002232:	1a d6       	st.w	--sp,r6
80002234:	00 9c       	mov	r12,r0
80002236:	f0 1f 00 07 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
8000223a:	2f f6       	sub	r6,-1
8000223c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000223e:	2f ed       	sub	sp,-8
80002240:	ec 05 18 00 	cp.b	r5,r6
80002244:	fe 9b ff c8 	brhi	800021d4 <ButtonConfig_brdcst_func+0x3c>
80002248:	d8 32       	popm	r0-r7,pc
8000224a:	00 00       	add	r0,r0
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	fd 2c 80 00 	ld.sb	r12,lr[-32768]
80002252:	99 74       	st.w	r12[0x1c],r4
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	fd 4c 80 00 	st.w	lr[-32768],r12
8000225a:	fd 60 80 00 	st.b	lr[-32768],r0
8000225e:	fd 78 80 00 	stcond	lr[-32768],r8
80002262:	fd 98       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	fd c0       	*unknown*
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	fd e8 80 00 	sthh.w	r0[r0],lr:b,r8:b
8000226e:	fe 0c       	*unknown*
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	fe 34 eb cd 	sub	r4,-5171

80002274 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002274:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002278:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000227c:	19 c7       	ld.ub	r7,r12[0x4]
8000227e:	19 d8       	ld.ub	r8,r12[0x5]
80002280:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002284:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002286:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002288:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000228c:	49 0c       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x58>
8000228e:	f0 1f 00 11 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002292:	1a d6       	st.w	--sp,r6
80002294:	49 0c       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x60>
80002296:	f0 1f 00 0f 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229a:	1a d5       	st.w	--sp,r5
8000229c:	48 fc       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x64>
8000229e:	f0 1f 00 0d 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a2:	5c 77       	castu.h	r7
800022a4:	1a d7       	st.w	--sp,r7
800022a6:	48 ec       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x68>
800022a8:	f0 1f 00 0a 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022ac:	1a d4       	st.w	--sp,r4
800022ae:	48 dc       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x6c>
800022b0:	f0 1f 00 08 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b4:	1a d3       	st.w	--sp,r3
800022b6:	48 cc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x70>
800022b8:	f0 1f 00 06 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022bc:	1a d2       	st.w	--sp,r2
800022be:	48 bc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x74>
800022c0:	f0 1f 00 04 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
800022c4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ca:	00 00       	add	r0,r0
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	fe 58 80 00 	cp.w	r8,-32768
800022d2:	99 74       	st.w	r12[0x1c],r4
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	fe 7c 80 00 	mov	r12,-32768
800022da:	fe 94 80 00 	brge	7fff22da <_estack+0x7ffda2da>
800022de:	fe a8       	*unknown*
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	fe bc       	*unknown*
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	fe d0 80 00 	satsub.w	r0,pc,-32768
800022ea:	fe f0 eb cd 	ld.w	r0,pc[-5171]

800022ec <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f0:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f4:	0f 89       	ld.ub	r9,r7[0x0]
800022f6:	30 08       	mov	r8,0
800022f8:	f0 09 18 00 	cp.b	r9,r8
800022fc:	c0 c1       	brne	80002314 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022fe:	48 9c       	lddpc	r12,80002320 <ButtonConfig_reply_func+0x34>
80002300:	f0 1f 00 09 	mcall	80002324 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002304:	0f 98       	ld.ub	r8,r7[0x1]
80002306:	1a d8       	st.w	--sp,r8
80002308:	48 8c       	lddpc	r12,80002328 <ButtonConfig_reply_func+0x3c>
8000230a:	f0 1f 00 07 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000230e:	2f fd       	sub	sp,-4
80002310:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002314:	48 6c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x40>
80002316:	f0 1f 00 04 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000231a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000231e:	00 00       	add	r0,r0
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	ff 10 80 00 	ld.uh	r0,pc[-32768]
80002326:	99 74       	st.w	r12[0x1c],r4
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	fd 4c 80 00 	st.w	lr[-32768],r12
8000232e:	ff 28 d4 21 	ld.sb	r8,pc[-11231]

80002330 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002330:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002332:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002336:	0d 88       	ld.ub	r8,r6[0x0]
80002338:	32 49       	mov	r9,36
8000233a:	f2 08 18 00 	cp.b	r8,r9
8000233e:	c2 91       	brne	80002390 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002340:	49 7c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x6c>
80002342:	f0 1f 00 18 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002346:	0d a5       	ld.ub	r5,r6[0x2]
80002348:	0d b8       	ld.ub	r8,r6[0x3]
8000234a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000234e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002350:	0d 98       	ld.ub	r8,r6[0x1]
80002352:	1a d8       	st.w	--sp,r8
80002354:	49 4c       	lddpc	r12,800023a4 <DataSession_brdcst_func+0x74>
80002356:	f0 1f 00 13 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000235e:	1a d8       	st.w	--sp,r8
80002360:	49 2c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x78>
80002362:	f0 1f 00 10 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002366:	2f ed       	sub	sp,-8
80002368:	58 05       	cp.w	r5,0
8000236a:	c1 80       	breq	8000239a <DataSession_brdcst_func+0x6a>
8000236c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000236e:	49 04       	lddpc	r4,800023ac <DataSession_brdcst_func+0x7c>
80002370:	ec 07 00 08 	add	r8,r6,r7
80002374:	11 c8       	ld.ub	r8,r8[0x4]
80002376:	1a d8       	st.w	--sp,r8
80002378:	1a d7       	st.w	--sp,r7
8000237a:	08 9c       	mov	r12,r4
8000237c:	f0 1f 00 09 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002380:	2f f7       	sub	r7,-1
80002382:	5c 57       	castu.b	r7
80002384:	2f ed       	sub	sp,-8
80002386:	ee 05 19 00 	cp.h	r5,r7
8000238a:	fe 9b ff f3 	brhi	80002370 <DataSession_brdcst_func+0x40>
8000238e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002390:	1a d8       	st.w	--sp,r8
80002392:	48 8c       	lddpc	r12,800023b0 <DataSession_brdcst_func+0x80>
80002394:	f0 1f 00 03 	mcall	800023a0 <DataSession_brdcst_func+0x70>
80002398:	2f fd       	sub	sp,-4
8000239a:	d8 22       	popm	r4-r7,pc
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	ff 44 80 00 	st.w	pc[-32768],r4
800023a2:	99 74       	st.w	r12[0x1c],r4
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	ff 58 80 00 	st.h	pc[-32768],r8
800023aa:	ff 70 80 00 	stcond	pc[-32768],r0
800023ae:	ff 8c       	*unknown*
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	ff a4       	*unknown*

800023b4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b4:	eb cd 40 80 	pushm	r7,lr
800023b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ba:	19 a8       	ld.ub	r8,r12[0x2]
800023bc:	58 08       	cp.w	r8,0
800023be:	c0 61       	brne	800023ca <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c0:	48 dc       	lddpc	r12,800023f4 <DataSession_reply_func+0x40>
800023c2:	f0 1f 00 0e 	mcall	800023f8 <DataSession_reply_func+0x44>
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	48 cc       	lddpc	r12,800023fc <DataSession_reply_func+0x48>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d2:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x4c>
800023d4:	f0 1f 00 09 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023d8:	0f b8       	ld.ub	r8,r7[0x3]
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 ac       	lddpc	r12,80002404 <DataSession_reply_func+0x50>
800023de:	f0 1f 00 07 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e2:	0f c8       	ld.ub	r8,r7[0x4]
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	48 9c       	lddpc	r12,80002408 <DataSession_reply_func+0x54>
800023e8:	f0 1f 00 04 	mcall	800023f8 <DataSession_reply_func+0x44>
800023ec:	2f dd       	sub	sp,-12
800023ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	ff b8       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	99 74       	st.w	r12[0x1c],r4
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	ff cc       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	ff e0 80 00 	sthh.w	r0[r0],pc:b,r0:b
80002406:	ff f4 80 01 	ld.wls	r4,pc[0x4]
8000240a:	00 04       	add	r4,r0

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c2 21       	brne	80002460 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	49 4c       	lddpc	r12,8000246c <TransmitControl_reply_func+0x60>
80002420:	f0 1f 00 14 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	49 3c       	lddpc	r12,80002474 <TransmitControl_reply_func+0x68>
8000242a:	f0 1f 00 12 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	49 2c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x6c>
80002434:	f0 1f 00 0f 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	49 0c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x70>
8000243e:	f0 1f 00 0d 	mcall	80002470 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002442:	0f 98       	ld.ub	r8,r7[0x1]
80002444:	2f dd       	sub	sp,-12
80002446:	30 19       	mov	r9,1
80002448:	f2 08 18 00 	cp.b	r8,r9
8000244c:	c0 d0       	breq	80002466 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000244e:	30 29       	mov	r9,2
80002450:	f2 08 18 00 	cp.b	r8,r9
80002454:	c0 91       	brne	80002466 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002456:	30 09       	mov	r9,0
80002458:	48 a8       	lddpc	r8,80002480 <TransmitControl_reply_func+0x74>
8000245a:	b0 89       	st.b	r8[0x0],r9
8000245c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002460:	48 9c       	lddpc	r12,80002484 <TransmitControl_reply_func+0x78>
80002462:	f0 1f 00 04 	mcall	80002470 <TransmitControl_reply_func+0x64>
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 01       	ld.sh	r1,r0[0x0]
8000246e:	00 14       	sub	r4,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	99 74       	st.w	r12[0x1c],r4
80002474:	80 01       	ld.sh	r1,r0[0x0]
80002476:	00 30       	cp.w	r0,r0
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	00 44       	or	r4,r0
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	00 60       	and	r0,r0
80002480:	00 00       	add	r0,r0
80002482:	0a 4d       	or	sp,r5
80002484:	80 01       	ld.sh	r1,r0[0x0]
80002486:	00 70       	tst	r0,r0

80002488 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002488:	eb cd 40 f8 	pushm	r3-r7,lr
8000248c:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000248e:	19 a5       	ld.ub	r5,r12[0x2]
80002490:	19 b8       	ld.ub	r8,r12[0x3]
80002492:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002496:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
80002498:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	49 6c       	lddpc	r12,800024f4 <AudioRoutingControl_brdcst_func+0x6c>
800024a0:	f0 1f 00 16 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a4:	2f fd       	sub	sp,-4
800024a6:	58 05       	cp.w	r5,0
800024a8:	c0 31       	brne	800024ae <AudioRoutingControl_brdcst_func+0x26>
800024aa:	30 07       	mov	r7,0
800024ac:	c1 98       	rjmp	800024de <AudioRoutingControl_brdcst_func+0x56>
800024ae:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b0:	49 34       	lddpc	r4,800024fc <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b2:	49 43       	lddpc	r3,80002500 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024b8:	11 c8       	ld.ub	r8,r8[0x4]
800024ba:	1a d8       	st.w	--sp,r8
800024bc:	08 9c       	mov	r12,r4
800024be:	f0 1f 00 0f 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c2:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024c6:	11 d8       	ld.ub	r8,r8[0x5]
800024c8:	1a d8       	st.w	--sp,r8
800024ca:	06 9c       	mov	r12,r3
800024cc:	f0 1f 00 0b 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d0:	2f f7       	sub	r7,-1
800024d2:	5c 57       	castu.b	r7
800024d4:	2f ed       	sub	sp,-8
800024d6:	ee 05 19 00 	cp.h	r5,r7
800024da:	fe 9b ff ed 	brhi	800024b4 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024de:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e2:	0f c8       	ld.ub	r8,r7[0x4]
800024e4:	1a d8       	st.w	--sp,r8
800024e6:	48 8c       	lddpc	r12,80002504 <AudioRoutingControl_brdcst_func+0x7c>
800024e8:	f0 1f 00 04 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
800024ec:	2f fd       	sub	sp,-4
	
	
	
}
800024ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f2:	00 00       	add	r0,r0
800024f4:	80 01       	ld.sh	r1,r0[0x0]
800024f6:	00 88       	andn	r8,r0
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	99 74       	st.w	r12[0x1c],r4
800024fc:	80 01       	ld.sh	r1,r0[0x0]
800024fe:	00 a0       	st.w	r0++,r0
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	00 b8       	st.h	r0++,r8
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	00 d0       	st.w	--r0,r0

80002508 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002508:	eb cd 40 80 	pushm	r7,lr
8000250c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000250e:	19 a9       	ld.ub	r9,r12[0x2]
80002510:	30 08       	mov	r8,0
80002512:	f0 09 18 00 	cp.b	r9,r8
80002516:	c0 61       	brne	80002522 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
80002518:	48 8c       	lddpc	r12,80002538 <AudioRoutingControl_reply_func+0x30>
8000251a:	f0 1f 00 09 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
8000251e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002522:	48 8c       	lddpc	r12,80002540 <AudioRoutingControl_reply_func+0x38>
80002524:	f0 1f 00 06 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002528:	0f a8       	ld.ub	r8,r7[0x2]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 6c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x3c>
8000252e:	f0 1f 00 04 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
80002538:	80 01       	ld.sh	r1,r0[0x0]
8000253a:	00 ec       	st.h	--r0,r12
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	99 74       	st.w	r12[0x1c],r4
80002540:	80 01       	ld.sh	r1,r0[0x0]
80002542:	00 fc       	st.b	--r0,r12
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	01 10       	ld.sh	r0,r0++

80002548 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002550:	0f 89       	ld.ub	r9,r7[0x0]
80002552:	0f 98       	ld.ub	r8,r7[0x1]
80002554:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002558:	1a d8       	st.w	--sp,r8
8000255a:	48 6c       	lddpc	r12,80002570 <Volume_brdcst_func+0x28>
8000255c:	f0 1f 00 06 	mcall	80002574 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002560:	0f b8       	ld.ub	r8,r7[0x3]
80002562:	1a d8       	st.w	--sp,r8
80002564:	48 5c       	lddpc	r12,80002578 <Volume_brdcst_func+0x30>
80002566:	f0 1f 00 04 	mcall	80002574 <Volume_brdcst_func+0x2c>
8000256a:	2f ed       	sub	sp,-8
	
	
}
8000256c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002570:	80 01       	ld.sh	r1,r0[0x0]
80002572:	01 30       	ld.ub	r0,r0++
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	99 74       	st.w	r12[0x1c],r4
80002578:	80 01       	ld.sh	r1,r0[0x0]
8000257a:	01 4c       	ld.w	r12,--r0

8000257c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002580:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002584:	0f 89       	ld.ub	r9,r7[0x0]
80002586:	30 08       	mov	r8,0
80002588:	f0 09 18 00 	cp.b	r9,r8
8000258c:	c1 b1       	brne	800025c2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000258e:	0f b8       	ld.ub	r8,r7[0x3]
80002590:	31 09       	mov	r9,16
80002592:	f2 08 18 00 	cp.b	r8,r9
80002596:	c0 f1       	brne	800025b4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002598:	48 dc       	lddpc	r12,800025cc <Volume_reply_func+0x50>
8000259a:	f0 1f 00 0e 	mcall	800025d0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000259e:	0f 99       	ld.ub	r9,r7[0x1]
800025a0:	0f a8       	ld.ub	r8,r7[0x2]
800025a2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025a6:	1a d8       	st.w	--sp,r8
800025a8:	48 bc       	lddpc	r12,800025d4 <Volume_reply_func+0x58>
800025aa:	f0 1f 00 0a 	mcall	800025d0 <Volume_reply_func+0x54>
800025ae:	2f fd       	sub	sp,-4
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b4:	1a d8       	st.w	--sp,r8
800025b6:	48 9c       	lddpc	r12,800025d8 <Volume_reply_func+0x5c>
800025b8:	f0 1f 00 06 	mcall	800025d0 <Volume_reply_func+0x54>
800025bc:	2f fd       	sub	sp,-4
800025be:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c2:	48 7c       	lddpc	r12,800025dc <Volume_reply_func+0x60>
800025c4:	f0 1f 00 03 	mcall	800025d0 <Volume_reply_func+0x54>
800025c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025cc:	80 01       	ld.sh	r1,r0[0x0]
800025ce:	01 68       	ld.uh	r8,--r0
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	99 74       	st.w	r12[0x1c],r4
800025d4:	80 01       	ld.sh	r1,r0[0x0]
800025d6:	01 30       	ld.ub	r0,r0++
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	01 7c       	ld.ub	r12,--r0
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	01 94       	ld.ub	r4,r0[0x1]

800025e0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e2:	19 d9       	ld.ub	r9,r12[0x5]
800025e4:	30 08       	mov	r8,0
800025e6:	f0 09 18 00 	cp.b	r9,r8
800025ea:	c0 91       	brne	800025fc <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025ec:	48 99       	lddpc	r9,80002610 <spk_brdcst_func+0x30>
800025ee:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f0:	48 99       	lddpc	r9,80002614 <spk_brdcst_func+0x34>
800025f2:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f4:	48 9c       	lddpc	r12,80002618 <spk_brdcst_func+0x38>
800025f6:	f0 1f 00 0a 	mcall	8000261c <spk_brdcst_func+0x3c>
800025fa:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025fc:	30 18       	mov	r8,1
800025fe:	48 69       	lddpc	r9,80002614 <spk_brdcst_func+0x34>
80002600:	b2 88       	st.b	r9[0x0],r8
		is_unmute = 1;
80002602:	48 49       	lddpc	r9,80002610 <spk_brdcst_func+0x30>
80002604:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");
80002606:	48 7c       	lddpc	r12,80002620 <spk_brdcst_func+0x40>
80002608:	f0 1f 00 05 	mcall	8000261c <spk_brdcst_func+0x3c>
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	00 00       	add	r0,r0
80002612:	0a 4d       	or	sp,r5
80002614:	00 00       	add	r0,r0
80002616:	0a 54       	eor	r4,r5
80002618:	80 01       	ld.sh	r1,r0[0x0]
8000261a:	01 ac       	ld.ub	r12,r0[0x2]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	99 74       	st.w	r12[0x1c],r4
80002620:	80 01       	ld.sh	r1,r0[0x0]
80002622:	01 bc       	ld.ub	r12,r0[0x3]

80002624 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002624:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002626:	19 a9       	ld.ub	r9,r12[0x2]
80002628:	30 08       	mov	r8,0
8000262a:	f0 09 18 00 	cp.b	r9,r8
8000262e:	c0 81       	brne	8000263e <spk_reply_func+0x1a>
		{
			//is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002630:	19 e8       	ld.ub	r8,r12[0x6]
80002632:	1a d8       	st.w	--sp,r8
80002634:	48 5c       	lddpc	r12,80002648 <spk_reply_func+0x24>
80002636:	f0 1f 00 06 	mcall	8000264c <spk_reply_func+0x28>
8000263a:	2f fd       	sub	sp,-4
8000263c:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000263e:	48 5c       	lddpc	r12,80002650 <spk_reply_func+0x2c>
80002640:	f0 1f 00 03 	mcall	8000264c <spk_reply_func+0x28>
80002644:	d8 02       	popm	pc
80002646:	00 00       	add	r0,r0
80002648:	80 01       	ld.sh	r1,r0[0x0]
8000264a:	01 c8       	ld.ub	r8,r0[0x4]
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	99 74       	st.w	r12[0x1c],r4
80002650:	80 01       	ld.sh	r1,r0[0x0]
80002652:	01 d8       	ld.ub	r8,r0[0x5]

80002654 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002654:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002658:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000265c:	49 ac       	lddpc	r12,800026c4 <mic_reply_func+0x70>
8000265e:	f0 1f 00 1b 	mcall	800026c8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002662:	0f 89       	ld.ub	r9,r7[0x0]
80002664:	30 08       	mov	r8,0
80002666:	f0 09 18 00 	cp.b	r9,r8
8000266a:	c2 71       	brne	800026b8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000266c:	0f 98       	ld.ub	r8,r7[0x1]
8000266e:	30 29       	mov	r9,2
80002670:	f2 08 18 00 	cp.b	r8,r9
80002674:	c1 b1       	brne	800026aa <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002676:	49 6c       	lddpc	r12,800026cc <mic_reply_func+0x78>
80002678:	f0 1f 00 14 	mcall	800026c8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	49 4c       	lddpc	r12,800026d0 <mic_reply_func+0x7c>
80002682:	f0 1f 00 12 	mcall	800026c8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002686:	0f b8       	ld.ub	r8,r7[0x3]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	49 3c       	lddpc	r12,800026d4 <mic_reply_func+0x80>
8000268c:	f0 1f 00 0f 	mcall	800026c8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002690:	0f c8       	ld.ub	r8,r7[0x4]
80002692:	1a d8       	st.w	--sp,r8
80002694:	49 1c       	lddpc	r12,800026d8 <mic_reply_func+0x84>
80002696:	f0 1f 00 0d 	mcall	800026c8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000269a:	0f d8       	ld.ub	r8,r7[0x5]
8000269c:	1a d8       	st.w	--sp,r8
8000269e:	49 0c       	lddpc	r12,800026dc <mic_reply_func+0x88>
800026a0:	f0 1f 00 0a 	mcall	800026c8 <mic_reply_func+0x74>
800026a4:	2f cd       	sub	sp,-16
800026a6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026aa:	1a d8       	st.w	--sp,r8
800026ac:	48 dc       	lddpc	r12,800026e0 <mic_reply_func+0x8c>
800026ae:	f0 1f 00 07 	mcall	800026c8 <mic_reply_func+0x74>
800026b2:	2f fd       	sub	sp,-4
800026b4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026b8:	48 bc       	lddpc	r12,800026e4 <mic_reply_func+0x90>
800026ba:	f0 1f 00 04 	mcall	800026c8 <mic_reply_func+0x74>
800026be:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c2:	00 00       	add	r0,r0
800026c4:	80 01       	ld.sh	r1,r0[0x0]
800026c6:	01 e4       	ld.ub	r4,r0[0x6]
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	99 74       	st.w	r12[0x1c],r4
800026cc:	80 01       	ld.sh	r1,r0[0x0]
800026ce:	01 f4       	ld.ub	r4,r0[0x7]
800026d0:	80 01       	ld.sh	r1,r0[0x0]
800026d2:	02 08       	add	r8,r1
800026d4:	80 01       	ld.sh	r1,r0[0x0]
800026d6:	02 1c       	sub	r12,r1
800026d8:	80 01       	ld.sh	r1,r0[0x0]
800026da:	02 38       	cp.w	r8,r1
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	02 50       	eor	r0,r1
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	02 68       	and	r8,r1
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	02 80       	andn	r0,r1

800026e8 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026e8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026ec:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026f0:	48 bc       	lddpc	r12,8000271c <dcm_brdcst_func+0x34>
800026f2:	f0 1f 00 0c 	mcall	80002720 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026f6:	0f 88       	ld.ub	r8,r7[0x0]
800026f8:	1a d8       	st.w	--sp,r8
800026fa:	48 bc       	lddpc	r12,80002724 <dcm_brdcst_func+0x3c>
800026fc:	f0 1f 00 09 	mcall	80002720 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002700:	0f a8       	ld.ub	r8,r7[0x2]
80002702:	1a d8       	st.w	--sp,r8
80002704:	48 9c       	lddpc	r12,80002728 <dcm_brdcst_func+0x40>
80002706:	f0 1f 00 07 	mcall	80002720 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000270a:	0f 98       	ld.ub	r8,r7[0x1]
8000270c:	1a d8       	st.w	--sp,r8
8000270e:	48 8c       	lddpc	r12,8000272c <dcm_brdcst_func+0x44>
80002710:	f0 1f 00 04 	mcall	80002720 <dcm_brdcst_func+0x38>
80002714:	2f dd       	sub	sp,-12
	
	
}
80002716:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271a:	00 00       	add	r0,r0
8000271c:	80 01       	ld.sh	r1,r0[0x0]
8000271e:	02 90       	mov	r0,r1
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	99 74       	st.w	r12[0x1c],r4
80002724:	80 01       	ld.sh	r1,r0[0x0]
80002726:	02 a4       	st.w	r1++,r4
80002728:	80 01       	ld.sh	r1,r0[0x0]
8000272a:	02 b8       	st.h	r1++,r8
8000272c:	80 01       	ld.sh	r1,r0[0x0]
8000272e:	02 d0       	st.w	--r1,r0

80002730 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002730:	eb cd 40 80 	pushm	r7,lr
80002734:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002736:	19 a9       	ld.ub	r9,r12[0x2]
80002738:	30 08       	mov	r8,0
8000273a:	f0 09 18 00 	cp.b	r9,r8
8000273e:	c1 b1       	brne	80002774 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002740:	19 b8       	ld.ub	r8,r12[0x3]
80002742:	30 19       	mov	r9,1
80002744:	f2 08 18 00 	cp.b	r8,r9
80002748:	c0 51       	brne	80002752 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000274a:	48 ec       	lddpc	r12,80002780 <dcm_reply_func+0x50>
8000274c:	f0 1f 00 0e 	mcall	80002784 <dcm_reply_func+0x54>
80002750:	c0 a8       	rjmp	80002764 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002752:	58 08       	cp.w	r8,0
80002754:	c0 51       	brne	8000275e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002756:	48 dc       	lddpc	r12,80002788 <dcm_reply_func+0x58>
80002758:	f0 1f 00 0b 	mcall	80002784 <dcm_reply_func+0x54>
8000275c:	c0 48       	rjmp	80002764 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000275e:	48 cc       	lddpc	r12,8000278c <dcm_reply_func+0x5c>
80002760:	f0 1f 00 09 	mcall	80002784 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002764:	0f d8       	ld.ub	r8,r7[0x5]
80002766:	1a d8       	st.w	--sp,r8
80002768:	48 ac       	lddpc	r12,80002790 <dcm_reply_func+0x60>
8000276a:	f0 1f 00 07 	mcall	80002784 <dcm_reply_func+0x54>
8000276e:	2f fd       	sub	sp,-4
80002770:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002774:	48 8c       	lddpc	r12,80002794 <dcm_reply_func+0x64>
80002776:	f0 1f 00 04 	mcall	80002784 <dcm_reply_func+0x54>
8000277a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277e:	00 00       	add	r0,r0
80002780:	80 01       	ld.sh	r1,r0[0x0]
80002782:	02 ec       	st.h	--r1,r12
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	99 74       	st.w	r12[0x1c],r4
80002788:	80 01       	ld.sh	r1,r0[0x0]
8000278a:	03 00       	ld.w	r0,r1++
8000278c:	80 01       	ld.sh	r1,r0[0x0]
8000278e:	03 14       	ld.sh	r4,r1++
80002790:	80 01       	ld.sh	r1,r0[0x0]
80002792:	03 28       	ld.uh	r8,r1++
80002794:	80 01       	ld.sh	r1,r0[0x0]
80002796:	03 34       	ld.ub	r4,r1++

80002798 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002798:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000279a:	19 a9       	ld.ub	r9,r12[0x2]
8000279c:	30 08       	mov	r8,0
8000279e:	f0 09 18 00 	cp.b	r9,r8
800027a2:	c0 51       	brne	800027ac <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027a4:	48 4c       	lddpc	r12,800027b4 <ToneControl_reply_func+0x1c>
800027a6:	f0 1f 00 05 	mcall	800027b8 <ToneControl_reply_func+0x20>
800027aa:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027ac:	48 4c       	lddpc	r12,800027bc <ToneControl_reply_func+0x24>
800027ae:	f0 1f 00 03 	mcall	800027b8 <ToneControl_reply_func+0x20>
800027b2:	d8 02       	popm	pc
800027b4:	80 01       	ld.sh	r1,r0[0x0]
800027b6:	03 40       	ld.w	r0,--r1
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	99 74       	st.w	r12[0x1c],r4
800027bc:	80 01       	ld.sh	r1,r0[0x0]
800027be:	03 48       	ld.w	r8,--r1

800027c0 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027c0:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027c2:	f0 1f 00 1b 	mcall	8000282c <app_cfg+0x6c>
800027c6:	49 b8       	lddpc	r8,80002830 <app_cfg+0x70>
800027c8:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027ca:	49 b6       	lddpc	r6,80002834 <app_cfg+0x74>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027cc:	49 b5       	lddpc	r5,80002838 <app_cfg+0x78>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027ce:	49 c4       	lddpc	r4,8000283c <app_cfg+0x7c>
800027d0:	49 c3       	lddpc	r3,80002840 <app_cfg+0x80>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027d2:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027d4:	30 21       	mov	r1,2
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027d6:	30 12       	mov	r2,1
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
800027d8:	10 97       	mov	r7,r8
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027da:	6c 08       	ld.w	r8,r6[0x0]
800027dc:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027e0:	58 38       	cp.w	r8,3
800027e2:	c1 f1       	brne	80002820 <app_cfg+0x60>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027e4:	6a 08       	ld.w	r8,r5[0x0]
800027e6:	58 08       	cp.w	r8,0
800027e8:	c0 51       	brne	800027f2 <app_cfg+0x32>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					xcmp_audio_route_speaker();
800027ea:	f0 1f 00 17 	mcall	80002844 <app_cfg+0x84>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ee:	8b 02       	st.w	r5[0x0],r2
800027f0:	c1 28       	rjmp	80002814 <app_cfg+0x54>
				}
				else if(isAudioRouting == 1)
800027f2:	58 18       	cp.w	r8,1
800027f4:	c0 31       	brne	800027fa <app_cfg+0x3a>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027f6:	8b 01       	st.w	r5[0x0],r1
800027f8:	c0 e8       	rjmp	80002814 <app_cfg+0x54>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800027fa:	58 28       	cp.w	r8,2
800027fc:	c0 31       	brne	80002802 <app_cfg+0x42>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027fe:	8b 00       	st.w	r5[0x0],r0
80002800:	c0 a8       	rjmp	80002814 <app_cfg+0x54>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80002802:	58 38       	cp.w	r8,3
80002804:	f9 b8 00 04 	moveq	r8,4
80002808:	eb f8 0a 00 	st.weq	r5[0x0],r8
					
				}
				else
				{
					isAudioRouting++;
8000280c:	f7 b8 01 ff 	subne	r8,-1
80002810:	eb f8 1a 00 	st.wne	r5[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
80002814:	07 88       	ld.ub	r8,r3[0x0]
80002816:	1a d8       	st.w	--sp,r8
80002818:	08 9c       	mov	r12,r4
8000281a:	f0 1f 00 0c 	mcall	80002848 <app_cfg+0x88>
8000281e:	2f fd       	sub	sp,-4
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
80002820:	e0 6b 0f a0 	mov	r11,4000
80002824:	0e 9c       	mov	r12,r7
80002826:	f0 1f 00 0a 	mcall	8000284c <app_cfg+0x8c>
	}
8000282a:	cd 8b       	rjmp	800027da <app_cfg+0x1a>
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	92 e8       	ld.uh	r8,r9[0xc]
80002830:	00 00       	add	r0,r0
80002832:	0a 48       	or	r8,r5
80002834:	00 00       	add	r0,r0
80002836:	12 c4       	st.b	r9++,r4
80002838:	00 00       	add	r0,r0
8000283a:	0a 40       	or	r0,r5
8000283c:	80 01       	ld.sh	r1,r0[0x0]
8000283e:	03 54       	ld.sh	r4,--r1
80002840:	00 00       	add	r0,r0
80002842:	0a 4d       	or	sp,r5
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	4d 98       	lddpc	r8,800029a8 <SD_LowLevel_Init+0x60>
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	99 74       	st.w	r12[0x1c],r4
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	94 50       	ld.sh	r0,r10[0xa]

80002850 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002850:	eb cd 40 80 	pushm	r7,lr
80002854:	18 97       	mov	r7,r12
  log("R");
80002856:	48 6c       	lddpc	r12,8000286c <app_payload_tx_proc+0x1c>
80002858:	f0 1f 00 06 	mcall	80002870 <app_payload_tx_proc+0x20>
  //fl_write("voice.dat", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  
  //vTaskDelay(100);
  
  //payload_fragment_t * ptr = (payload_fragment_t *)payload;
  set_payload_idle(payload);
8000285c:	48 68       	lddpc	r8,80002874 <app_payload_tx_proc+0x24>
8000285e:	70 0c       	ld.w	r12,r8[0x0]
80002860:	0e 9b       	mov	r11,r7
80002862:	f0 1f 00 06 	mcall	80002878 <app_payload_tx_proc+0x28>

//

}
80002866:	e3 cd 80 80 	ldm	sp++,r7,pc
8000286a:	00 00       	add	r0,r0
8000286c:	80 01       	ld.sh	r1,r0[0x0]
8000286e:	03 64       	ld.uh	r4,--r1
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	99 74       	st.w	r12[0x1c],r4
80002874:	00 00       	add	r0,r0
80002876:	0f 98       	ld.ub	r8,r7[0x1]
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	3a 00       	mov	r0,-96

8000287c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000287c:	eb cd 40 80 	pushm	r7,lr
80002880:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
80002882:	48 cc       	lddpc	r12,800028b0 <app_payload_rx_proc+0x34>
80002884:	f0 1f 00 0c 	mcall	800028b4 <app_payload_rx_proc+0x38>
	if (AMBE_flag)
80002888:	48 c8       	lddpc	r8,800028b8 <app_payload_rx_proc+0x3c>
8000288a:	11 89       	ld.ub	r9,r8[0x0]
8000288c:	30 08       	mov	r8,0
8000288e:	f0 09 18 00 	cp.b	r9,r8
80002892:	c0 81       	brne	800028a2 <app_payload_rx_proc+0x26>
	{
		//fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
80002894:	e0 69 02 00 	mov	r9,512
80002898:	0e 9a       	mov	r10,r7
8000289a:	3f fb       	mov	r11,-1
8000289c:	48 8c       	lddpc	r12,800028bc <app_payload_rx_proc+0x40>
8000289e:	f0 1f 00 09 	mcall	800028c0 <app_payload_rx_proc+0x44>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028a2:	48 98       	lddpc	r8,800028c4 <app_payload_rx_proc+0x48>
800028a4:	70 0c       	ld.w	r12,r8[0x0]
800028a6:	0e 9b       	mov	r11,r7
800028a8:	f0 1f 00 08 	mcall	800028c8 <app_payload_rx_proc+0x4c>

}
800028ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b0:	80 01       	ld.sh	r1,r0[0x0]
800028b2:	03 68       	ld.uh	r8,--r1
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	99 74       	st.w	r12[0x1c],r4
800028b8:	00 00       	add	r0,r0
800028ba:	0a 44       	or	r4,r5
800028bc:	80 01       	ld.sh	r1,r0[0x0]
800028be:	03 74       	ld.ub	r4,--r1
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	34 e8       	mov	r8,78
800028c4:	00 00       	add	r0,r0
800028c6:	0f 98       	ld.ub	r8,r7[0x1]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3a 00       	mov	r0,-96

800028cc <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028cc:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028ce:	19 e8       	ld.ub	r8,r12[0x6]
800028d0:	30 19       	mov	r9,1
800028d2:	f2 08 18 00 	cp.b	r8,r9
800028d6:	c0 61       	brne	800028e2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028d8:	48 98       	lddpc	r8,800028fc <DeviceInitializationStatus_brdcst_func+0x30>
800028da:	70 09       	ld.w	r9,r8[0x0]
800028dc:	a1 a9       	sbr	r9,0x0
800028de:	91 09       	st.w	r8[0x0],r9
800028e0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028e2:	30 29       	mov	r9,2
800028e4:	f2 08 18 00 	cp.b	r8,r9
800028e8:	c0 80       	breq	800028f8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ea:	48 58       	lddpc	r8,800028fc <DeviceInitializationStatus_brdcst_func+0x30>
800028ec:	70 09       	ld.w	r9,r8[0x0]
800028ee:	e0 19 ff fc 	andl	r9,0xfffc
800028f2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028f4:	f0 1f 00 03 	mcall	80002900 <DeviceInitializationStatus_brdcst_func+0x34>
800028f8:	d8 02       	popm	pc
800028fa:	00 00       	add	r0,r0
800028fc:	00 00       	add	r0,r0
800028fe:	12 c4       	st.b	r9++,r4
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	4d d4       	lddpc	r4,80002a74 <SD_GetDataResponse+0x3c>

80002904 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002904:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
80002906:	48 78       	lddpc	r8,80002920 <SD_SPI_SetSpeed+0x1c>
80002908:	70 09       	ld.w	r9,r8[0x0]
8000290a:	72 ca       	ld.w	r10,r9[0x30]
8000290c:	5c 7c       	castu.h	r12
8000290e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002912:	f9 ea 10 0a 	or	r10,r12,r10
80002916:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
80002918:	70 0c       	ld.w	r12,r8[0x0]
8000291a:	f0 1f 00 03 	mcall	80002924 <SD_SPI_SetSpeed+0x20>
	
 
}
8000291e:	d8 02       	popm	pc
80002920:	00 00       	add	r0,r0
80002922:	12 c8       	st.b	r9++,r8
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	5b 38       	cp.w	r8,-13

80002928 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
80002928:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
8000292a:	e0 6c 01 00 	mov	r12,256
8000292e:	f0 1f 00 02 	mcall	80002934 <SD_SPI_SetSpeedHi+0xc>

}
80002932:	d8 02       	popm	pc
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	29 04       	sub	r4,-112

80002938 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
80002938:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
8000293a:	e0 6c ff 00 	mov	r12,65280
8000293e:	f0 1f 00 02 	mcall	80002944 <SD_SPI_SetSpeedLow+0xc>


	
}
80002942:	d8 02       	popm	pc
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	29 04       	sub	r4,-112

80002948 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
80002948:	eb cd 40 c0 	pushm	r6-r7,lr
8000294c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000294e:	49 58       	lddpc	r8,800029a0 <SD_LowLevel_Init+0x58>
80002950:	1a 96       	mov	r6,sp
80002952:	f0 ea 00 00 	ld.d	r10,r8[0]
80002956:	fa eb 00 00 	st.d	sp[0],r10
8000295a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000295e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
80002962:	30 4b       	mov	r11,4
80002964:	49 0c       	lddpc	r12,800029a4 <SD_LowLevel_Init+0x5c>
80002966:	f0 1f 00 11 	mcall	800029a8 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
8000296a:	49 17       	lddpc	r7,800029ac <SD_LowLevel_Init+0x64>
8000296c:	fe 7c 24 00 	mov	r12,-56320
80002970:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002972:	1a 9b       	mov	r11,sp
80002974:	f0 1f 00 0f 	mcall	800029b0 <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002978:	30 09       	mov	r9,0
8000297a:	12 9a       	mov	r10,r9
8000297c:	12 9b       	mov	r11,r9
8000297e:	6e 0c       	ld.w	r12,r7[0x0]
80002980:	f0 1f 00 0d 	mcall	800029b4 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
80002984:	6e 0c       	ld.w	r12,r7[0x0]
80002986:	f0 1f 00 0d 	mcall	800029b8 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
8000298a:	e0 6a 36 00 	mov	r10,13824
8000298e:	ea 1a 01 6e 	orh	r10,0x16e
80002992:	1a 9b       	mov	r11,sp
80002994:	6e 0c       	ld.w	r12,r7[0x0]
80002996:	f0 1f 00 0a 	mcall	800029bc <SD_LowLevel_Init+0x74>
	return;
	}


	
}
8000299a:	2f cd       	sub	sp,-16
8000299c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029a0:	80 01       	ld.sh	r1,r0[0x0]
800029a2:	03 94       	ld.ub	r4,r1[0x1]
800029a4:	80 01       	ld.sh	r1,r0[0x0]
800029a6:	03 a4       	ld.ub	r4,r1[0x2]
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	9e 14       	ld.sh	r4,pc[0x2]
800029ac:	00 00       	add	r0,r0
800029ae:	12 c8       	st.b	r9++,r8
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	59 a0       	cp.w	r0,26
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	59 d8       	cp.w	r8,29
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	5b 38       	cp.w	r8,-13
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	5a 76       	cp.w	r6,-25

800029c0 <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
800029c0:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
800029c4:	48 b7       	lddpc	r7,800029f0 <SD_ReadByte+0x30>
800029c6:	30 0b       	mov	r11,0
800029c8:	6e 0c       	ld.w	r12,r7[0x0]
800029ca:	f0 1f 00 0b 	mcall	800029f4 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
800029ce:	e0 6b 00 ff 	mov	r11,255
800029d2:	6e 0c       	ld.w	r12,r7[0x0]
800029d4:	f0 1f 00 09 	mcall	800029f8 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
800029d8:	30 06       	mov	r6,0
800029da:	0c 9b       	mov	r11,r6
800029dc:	6e 0c       	ld.w	r12,r7[0x0]
800029de:	f0 1f 00 08 	mcall	800029fc <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
800029e2:	0c 9b       	mov	r11,r6
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 07 	mcall	80002a00 <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
800029ea:	0d 9c       	ld.ub	r12,r6[0x1]
800029ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029f0:	00 00       	add	r0,r0
800029f2:	12 c8       	st.b	r9++,r8
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	5a 04       	cp.w	r4,-32
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	5b 3e       	cp.w	lr,-13
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	5b 5a       	cp.w	r10,-11
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	5a 50       	cp.w	r0,-27

80002a04 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a04:	eb cd 40 c0 	pushm	r6-r7,lr
80002a08:	18 96       	mov	r6,r12
80002a0a:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a0e:	c0 28       	rjmp	80002a12 <SD_GetResponse+0xe>
  {
    Count--;
80002a10:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a12:	f0 1f 00 09 	mcall	80002a34 <SD_GetResponse+0x30>
80002a16:	ec 0c 18 00 	cp.b	r12,r6
80002a1a:	c0 40       	breq	80002a22 <SD_GetResponse+0x1e>
80002a1c:	58 07       	cp.w	r7,0
80002a1e:	cf 91       	brne	80002a10 <SD_GetResponse+0xc>
80002a20:	c0 58       	rjmp	80002a2a <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002a22:	58 07       	cp.w	r7,0
80002a24:	c0 30       	breq	80002a2a <SD_GetResponse+0x26>
80002a26:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002a2a:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002a2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a32:	00 00       	add	r0,r0
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	29 c0       	sub	r0,-100

80002a38 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002a38:	eb cd 40 f8 	pushm	r3-r7,lr
80002a3c:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002a3e:	30 b5       	mov	r5,11
80002a40:	30 d4       	mov	r4,13
80002a42:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002a44:	f0 1f 00 0c 	mcall	80002a74 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002a48:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002a4c:	ea 07 18 00 	cp.b	r7,r5
80002a50:	c0 e0       	breq	80002a6c <SD_GetDataResponse+0x34>
80002a52:	e8 07 18 00 	cp.b	r7,r4
80002a56:	c0 b0       	breq	80002a6c <SD_GetDataResponse+0x34>
80002a58:	e6 07 18 00 	cp.b	r7,r3
80002a5c:	c0 50       	breq	80002a66 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002a5e:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002a60:	e0 46 00 41 	cp.w	r6,65
80002a64:	cf 01       	brne	80002a44 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002a66:	f0 1f 00 04 	mcall	80002a74 <SD_GetDataResponse+0x3c>
80002a6a:	cf e0       	breq	80002a66 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002a6c:	0e 9c       	mov	r12,r7
80002a6e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002a72:	00 00       	add	r0,r0
80002a74:	80 00       	ld.sh	r0,r0[0x0]
80002a76:	29 c0       	sub	r0,-100

80002a78 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002a78:	eb cd 40 c0 	pushm	r6-r7,lr
80002a7c:	20 1d       	sub	sp,4
80002a7e:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a80:	48 c7       	lddpc	r7,80002ab0 <SD_WriteByte+0x38>
80002a82:	30 0b       	mov	r11,0
80002a84:	6e 0c       	ld.w	r12,r7[0x0]
80002a86:	f0 1f 00 0c 	mcall	80002ab4 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002a8a:	1b 8b       	ld.ub	r11,sp[0x0]
80002a8c:	6e 0c       	ld.w	r12,r7[0x0]
80002a8e:	f0 1f 00 0b 	mcall	80002ab8 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002a92:	1a 9b       	mov	r11,sp
80002a94:	6e 0c       	ld.w	r12,r7[0x0]
80002a96:	f0 1f 00 0a 	mcall	80002abc <SD_WriteByte+0x44>
80002a9a:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002a9c:	30 0b       	mov	r11,0
80002a9e:	6e 0c       	ld.w	r12,r7[0x0]
80002aa0:	f0 1f 00 08 	mcall	80002ac0 <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002aa4:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002aa8:	2f fd       	sub	sp,-4
80002aaa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002aae:	00 00       	add	r0,r0
80002ab0:	00 00       	add	r0,r0
80002ab2:	12 c8       	st.b	r9++,r8
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	5a 04       	cp.w	r4,-32
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	5b 3e       	cp.w	lr,-13
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	5b 5a       	cp.w	r10,-11
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	5a 50       	cp.w	r0,-27

80002ac4 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002ac4:	eb cd 40 c0 	pushm	r6-r7,lr
80002ac8:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002aca:	a7 ac       	sbr	r12,0x6
80002acc:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002ace:	f6 08 16 18 	lsr	r8,r11,0x18
80002ad2:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002ad4:	f6 08 16 10 	lsr	r8,r11,0x10
80002ad8:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002ada:	f6 08 16 08 	lsr	r8,r11,0x8
80002ade:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002ae0:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002ae2:	ba da       	st.b	sp[0x5],r10
80002ae4:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002ae6:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002aea:	0f 3c       	ld.ub	r12,r7++
80002aec:	f0 1f 00 04 	mcall	80002afc <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002af0:	0c 37       	cp.w	r7,r6
80002af2:	cf c1       	brne	80002aea <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002af4:	2f ed       	sub	sp,-8
80002af6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002afa:	00 00       	add	r0,r0
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	2a 78       	sub	r8,-89

80002b00 <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b00:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b02:	31 8c       	mov	r12,24
80002b04:	f0 1f 00 6a 	mcall	80002cac <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b08:	e0 6a 00 95 	mov	r10,149
80002b0c:	30 0b       	mov	r11,0
80002b0e:	16 9c       	mov	r12,r11
80002b10:	f0 1f 00 68 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002b14:	30 1c       	mov	r12,1
80002b16:	f0 1f 00 68 	mcall	80002cb4 <SD_GoIdleState+0x1b4>
80002b1a:	e0 81 00 a8 	brne	80002c6a <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002b1e:	e0 6a 00 87 	mov	r10,135
80002b22:	e0 6b 01 aa 	mov	r11,426
80002b26:	30 8c       	mov	r12,8
80002b28:	f0 1f 00 62 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
80002b2c:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b30:	3f f6       	mov	r6,-1
80002b32:	c0 38       	rjmp	80002b38 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002b34:	20 17       	sub	r7,1
80002b36:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b38:	f0 1f 00 60 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002b3c:	ec 0c 18 00 	cp.b	r12,r6
80002b40:	c0 41       	brne	80002b48 <SD_GoIdleState+0x48>
80002b42:	58 07       	cp.w	r7,0
80002b44:	cf 81       	brne	80002b34 <SD_GoIdleState+0x34>
80002b46:	c2 68       	rjmp	80002b92 <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002b48:	30 58       	mov	r8,5
80002b4a:	f0 0c 18 00 	cp.b	r12,r8
80002b4e:	c2 21       	brne	80002b92 <SD_GoIdleState+0x92>
80002b50:	c9 48       	rjmp	80002c78 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002b52:	08 9c       	mov	r12,r4
80002b54:	f0 1f 00 5a 	mcall	80002cbc <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002b58:	06 9c       	mov	r12,r3
80002b5a:	f0 1f 00 5a 	mcall	80002cc0 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002b5e:	08 9c       	mov	r12,r4
80002b60:	f0 1f 00 53 	mcall	80002cac <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002b64:	06 9a       	mov	r10,r3
80002b66:	0a 9b       	mov	r11,r5
80002b68:	02 9c       	mov	r12,r1
80002b6a:	f0 1f 00 52 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002b6e:	2f f6       	sub	r6,-1
80002b70:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002b72:	e4 06 19 00 	cp.h	r6,r2
80002b76:	c0 60       	breq	80002b82 <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002b78:	0a 9c       	mov	r12,r5
80002b7a:	f0 1f 00 4f 	mcall	80002cb4 <SD_GoIdleState+0x1b4>
80002b7e:	18 97       	mov	r7,r12
    }
    while (Status);
80002b80:	ce 91       	brne	80002b52 <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002b82:	31 8c       	mov	r12,24
80002b84:	f0 1f 00 4e 	mcall	80002cbc <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002b88:	e0 6c 00 ff 	mov	r12,255
80002b8c:	f0 1f 00 4d 	mcall	80002cc0 <SD_GoIdleState+0x1c0>
80002b90:	c6 f8       	rjmp	80002c6e <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002b92:	f0 1f 00 4a 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002b96:	f0 1f 00 49 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002b9a:	f0 1f 00 48 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002b9e:	f0 1f 00 47 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002ba2:	f0 1f 00 46 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002ba6:	31 8c       	mov	r12,24
80002ba8:	f0 1f 00 45 	mcall	80002cbc <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bac:	e0 6c 00 ff 	mov	r12,255
80002bb0:	f0 1f 00 44 	mcall	80002cc0 <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002bb4:	31 8c       	mov	r12,24
80002bb6:	f0 1f 00 3e 	mcall	80002cac <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bba:	e0 6c 00 ff 	mov	r12,255
80002bbe:	f0 1f 00 41 	mcall	80002cc0 <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bc2:	e0 6c 00 ff 	mov	r12,255
80002bc6:	f0 1f 00 3f 	mcall	80002cc0 <SD_GoIdleState+0x1c0>
80002bca:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002bce:	08 91       	mov	r1,r4
80002bd0:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002bd2:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002bd4:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002bd6:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002bda:	02 9a       	mov	r10,r1
80002bdc:	04 9b       	mov	r11,r2
80002bde:	33 7c       	mov	r12,55
80002be0:	f0 1f 00 34 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
80002be4:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002be6:	f0 1f 00 35 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002bea:	f8 05 18 00 	cp.b	r5,r12
80002bee:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002bf2:	2f f7       	sub	r7,-1
80002bf4:	5c 87       	casts.h	r7
80002bf6:	e6 07 19 00 	cp.h	r7,r3
80002bfa:	cf 61       	brne	80002be6 <SD_GoIdleState+0xe6>
80002bfc:	08 90       	mov	r0,r4
80002bfe:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c00:	04 9a       	mov	r10,r2
80002c02:	fc 1b 40 00 	movh	r11,0x4000
80002c06:	32 9c       	mov	r12,41
80002c08:	f0 1f 00 2a 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
80002c0c:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c0e:	f0 1f 00 2b 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c12:	c3 00       	breq	80002c72 <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c14:	2f f7       	sub	r7,-1
80002c16:	5c 87       	casts.h	r7
80002c18:	ec 07 19 00 	cp.h	r7,r6
80002c1c:	cf 91       	brne	80002c0e <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c1e:	e0 c4 00 01 	sub	r4,r0,1
80002c22:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002c24:	30 08       	mov	r8,0
80002c26:	f0 0c 18 00 	cp.b	r12,r8
80002c2a:	5f 1a       	srne	r10
80002c2c:	30 09       	mov	r9,0
80002c2e:	f2 04 19 00 	cp.h	r4,r9
80002c32:	5f 19       	srne	r9
80002c34:	f5 e9 00 09 	and	r9,r10,r9
80002c38:	f0 09 18 00 	cp.b	r9,r8
80002c3c:	cc f1       	brne	80002bda <SD_GoIdleState+0xda>

    if(n==0)
80002c3e:	58 04       	cp.w	r4,0
80002c40:	c1 50       	breq	80002c6a <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002c42:	30 0a       	mov	r10,0
80002c44:	14 9b       	mov	r11,r10
80002c46:	33 ac       	mov	r12,58
80002c48:	f0 1f 00 1a 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002c4c:	f0 1f 00 1b 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002c50:	f0 1f 00 1a 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002c54:	f0 1f 00 19 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002c58:	f0 1f 00 18 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
80002c5c:	f0 1f 00 17 	mcall	80002cb8 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002c60:	30 19       	mov	r9,1
80002c62:	49 98       	lddpc	r8,80002cc4 <SD_GoIdleState+0x1c4>
80002c64:	b0 89       	st.b	r8[0x0],r9
80002c66:	30 07       	mov	r7,0
80002c68:	c0 38       	rjmp	80002c6e <SD_GoIdleState+0x16e>
80002c6a:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002c6e:	0e 9c       	mov	r12,r7
80002c70:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c72:	20 14       	sub	r4,1
80002c74:	5c 84       	casts.h	r4
80002c76:	ce 4b       	rjmp	80002c3e <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002c78:	31 8c       	mov	r12,24
80002c7a:	f0 1f 00 11 	mcall	80002cbc <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002c7e:	e0 6c 00 ff 	mov	r12,255
80002c82:	f0 1f 00 10 	mcall	80002cc0 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002c86:	31 8c       	mov	r12,24
80002c88:	f0 1f 00 09 	mcall	80002cac <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002c8c:	e0 6a 00 ff 	mov	r10,255
80002c90:	30 0b       	mov	r11,0
80002c92:	30 1c       	mov	r12,1
80002c94:	f0 1f 00 07 	mcall	80002cb0 <SD_GoIdleState+0x1b0>
80002c98:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002c9a:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002c9c:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002c9e:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002ca2:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002ca4:	e0 62 00 f0 	mov	r2,240
80002ca8:	c6 8b       	rjmp	80002b78 <SD_GoIdleState+0x78>
80002caa:	00 00       	add	r0,r0
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	9e 60       	ld.sh	r0,pc[0xc]
80002cb0:	80 00       	ld.sh	r0,r0[0x0]
80002cb2:	2a c4       	sub	r4,-84
80002cb4:	80 00       	ld.sh	r0,r0[0x0]
80002cb6:	2a 04       	sub	r4,-96
80002cb8:	80 00       	ld.sh	r0,r0[0x0]
80002cba:	29 c0       	sub	r0,-100
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	9e 44       	ld.sh	r4,pc[0x8]
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	2a 78       	sub	r8,-89
80002cc4:	00 00       	add	r0,r0
80002cc6:	0a 68       	and	r8,r5

80002cc8 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002cc8:	eb cd 40 e0 	pushm	r5-r7,lr
80002ccc:	20 4d       	sub	sp,16
80002cce:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002cd0:	31 8c       	mov	r12,24
80002cd2:	f0 1f 00 44 	mcall	80002de0 <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002cd6:	e0 6a 00 ff 	mov	r10,255
80002cda:	30 0b       	mov	r11,0
80002cdc:	30 ac       	mov	r12,10
80002cde:	f0 1f 00 42 	mcall	80002de4 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002ce2:	30 0c       	mov	r12,0
80002ce4:	f0 1f 00 41 	mcall	80002de8 <SD_GetCIDRegister+0x120>
80002ce8:	c0 40       	breq	80002cf0 <SD_GetCIDRegister+0x28>
80002cea:	e0 66 00 ff 	mov	r6,255
80002cee:	c1 78       	rjmp	80002d1c <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002cf0:	e0 6c 00 fe 	mov	r12,254
80002cf4:	f0 1f 00 3d 	mcall	80002de8 <SD_GetCIDRegister+0x120>
80002cf8:	c0 91       	brne	80002d0a <SD_GetCIDRegister+0x42>
80002cfa:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002cfc:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d00:	f0 1f 00 3b 	mcall	80002dec <SD_GetCIDRegister+0x124>
80002d04:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d06:	0a 36       	cp.w	r6,r5
80002d08:	cf c1       	brne	80002d00 <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d0a:	e0 6c 00 ff 	mov	r12,255
80002d0e:	f0 1f 00 39 	mcall	80002df0 <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d12:	e0 6c 00 ff 	mov	r12,255
80002d16:	f0 1f 00 37 	mcall	80002df0 <SD_GetCIDRegister+0x128>
80002d1a:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002d1c:	31 8c       	mov	r12,24
80002d1e:	f0 1f 00 36 	mcall	80002df4 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002d22:	e0 6c 00 ff 	mov	r12,255
80002d26:	f0 1f 00 33 	mcall	80002df0 <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002d2a:	1b 88       	ld.ub	r8,sp[0x0]
80002d2c:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002d2e:	fb 28 00 01 	ld.sb	r8,sp[1]
80002d32:	a9 68       	lsl	r8,0x8
80002d34:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002d36:	8e 19       	ld.sh	r9,r7[0x2]
80002d38:	1b a8       	ld.ub	r8,sp[0x2]
80002d3a:	f3 e8 10 08 	or	r8,r9,r8
80002d3e:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002d40:	1b b8       	ld.ub	r8,sp[0x3]
80002d42:	b9 68       	lsl	r8,0x18
80002d44:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002d46:	6e 18       	ld.w	r8,r7[0x4]
80002d48:	1b c9       	ld.ub	r9,sp[0x4]
80002d4a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d4e:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002d50:	6e 18       	ld.w	r8,r7[0x4]
80002d52:	1b d9       	ld.ub	r9,sp[0x5]
80002d54:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002d58:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002d5a:	6e 18       	ld.w	r8,r7[0x4]
80002d5c:	1b e9       	ld.ub	r9,sp[0x6]
80002d5e:	f3 e8 10 08 	or	r8,r9,r8
80002d62:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002d64:	1b f8       	ld.ub	r8,sp[0x7]
80002d66:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002d6a:	fb 38 00 08 	ld.ub	r8,sp[8]
80002d6e:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002d72:	fb 38 00 09 	ld.ub	r8,sp[9]
80002d76:	b9 68       	lsl	r8,0x18
80002d78:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002d7a:	6e 38       	ld.w	r8,r7[0xc]
80002d7c:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002d80:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d84:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002d86:	6e 38       	ld.w	r8,r7[0xc]
80002d88:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002d8c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002d90:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002d92:	6e 38       	ld.w	r8,r7[0xc]
80002d94:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002d98:	f3 e8 10 08 	or	r8,r9,r8
80002d9c:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002d9e:	ef 39 00 10 	ld.ub	r9,r7[16]
80002da2:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002da6:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002daa:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002dae:	a9 68       	lsl	r8,0x8
80002db0:	e2 18 0f 00 	andl	r8,0xf00,COH
80002db4:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002db8:	ef 09 00 12 	ld.sh	r9,r7[18]
80002dbc:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002dc0:	f3 e8 10 08 	or	r8,r9,r8
80002dc4:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002dc8:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002dcc:	a1 98       	lsr	r8,0x1
80002dce:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002dd2:	30 18       	mov	r8,1
80002dd4:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002dd8:	0c 9c       	mov	r12,r6
80002dda:	2f cd       	sub	sp,-16
80002ddc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002de0:	80 00       	ld.sh	r0,r0[0x0]
80002de2:	9e 60       	ld.sh	r0,pc[0xc]
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	2a c4       	sub	r4,-84
80002de8:	80 00       	ld.sh	r0,r0[0x0]
80002dea:	2a 04       	sub	r4,-96
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	29 c0       	sub	r0,-100
80002df0:	80 00       	ld.sh	r0,r0[0x0]
80002df2:	2a 78       	sub	r8,-89
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	9e 44       	ld.sh	r4,pc[0x8]

80002df8 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002df8:	d4 31       	pushm	r0-r7,lr
80002dfa:	18 95       	mov	r5,r12
80002dfc:	16 93       	mov	r3,r11
80002dfe:	14 96       	mov	r6,r10
80002e00:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e02:	31 8c       	mov	r12,24
80002e04:	f0 1f 00 27 	mcall	80002ea0 <SD_WriteMultiBlocks+0xa8>
80002e08:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e0c:	4a 60       	lddpc	r0,80002ea4 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e0e:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e10:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e12:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e14:	c3 a8       	rjmp	80002e88 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002e16:	01 88       	ld.ub	r8,r0[0x0]
80002e18:	30 19       	mov	r9,1
80002e1a:	f2 08 18 00 	cp.b	r8,r9
80002e1e:	c0 81       	brne	80002e2e <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002e20:	04 9a       	mov	r10,r2
80002e22:	e6 0b 16 09 	lsr	r11,r3,0x9
80002e26:	31 8c       	mov	r12,24
80002e28:	f0 1f 00 20 	mcall	80002ea8 <SD_WriteMultiBlocks+0xb0>
80002e2c:	c0 68       	rjmp	80002e38 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e2e:	04 9a       	mov	r10,r2
80002e30:	06 9b       	mov	r11,r3
80002e32:	31 8c       	mov	r12,24
80002e34:	f0 1f 00 1d 	mcall	80002ea8 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002e38:	30 0c       	mov	r12,0
80002e3a:	f0 1f 00 1d 	mcall	80002eac <SD_WriteMultiBlocks+0xb4>
80002e3e:	c0 40       	breq	80002e46 <SD_WriteMultiBlocks+0x4e>
80002e40:	e0 67 00 ff 	mov	r7,255
80002e44:	c2 b8       	rjmp	80002e9a <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002e46:	04 9c       	mov	r12,r2
80002e48:	f0 1f 00 1a 	mcall	80002eb0 <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002e4c:	e0 6c 00 fe 	mov	r12,254
80002e50:	f0 1f 00 18 	mcall	80002eb0 <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e54:	58 06       	cp.w	r6,0
80002e56:	c0 a0       	breq	80002e6a <SD_WriteMultiBlocks+0x72>
80002e58:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002e5a:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002e5e:	f0 1f 00 15 	mcall	80002eb0 <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e62:	2f f7       	sub	r7,-1
80002e64:	0c 37       	cp.w	r7,r6
80002e66:	cf a3       	brcs	80002e5a <SD_WriteMultiBlocks+0x62>
80002e68:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002e6a:	f0 1f 00 13 	mcall	80002eb4 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002e6e:	f0 1f 00 12 	mcall	80002eb4 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e72:	f0 1f 00 12 	mcall	80002eb8 <SD_WriteMultiBlocks+0xc0>
80002e76:	f8 01 18 00 	cp.b	r1,r12
80002e7a:	f9 b7 00 00 	moveq	r7,0
80002e7e:	e4 07 17 10 	movne	r7,r2
80002e82:	20 14       	sub	r4,1
80002e84:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e88:	58 04       	cp.w	r4,0
80002e8a:	cc 61       	brne	80002e16 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002e8c:	31 8c       	mov	r12,24
80002e8e:	f0 1f 00 0c 	mcall	80002ebc <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002e92:	e0 6c 00 ff 	mov	r12,255
80002e96:	f0 1f 00 07 	mcall	80002eb0 <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002e9a:	0e 9c       	mov	r12,r7
80002e9c:	d8 32       	popm	r0-r7,pc
80002e9e:	00 00       	add	r0,r0
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	9e 60       	ld.sh	r0,pc[0xc]
80002ea4:	00 00       	add	r0,r0
80002ea6:	0a 68       	and	r8,r5
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	2a c4       	sub	r4,-84
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	2a 04       	sub	r4,-96
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	2a 78       	sub	r8,-89
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	29 c0       	sub	r0,-100
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	2a 38       	sub	r8,-93
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	9e 44       	ld.sh	r4,pc[0x8]

80002ec0 <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002ec0:	eb cd 40 e0 	pushm	r5-r7,lr
80002ec4:	18 95       	mov	r5,r12
80002ec6:	16 97       	mov	r7,r11
80002ec8:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002eca:	31 8c       	mov	r12,24
80002ecc:	f0 1f 00 1f 	mcall	80002f48 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002ed0:	49 f8       	lddpc	r8,80002f4c <SD_WriteBlock+0x8c>
80002ed2:	11 89       	ld.ub	r9,r8[0x0]
80002ed4:	30 18       	mov	r8,1
80002ed6:	f0 09 18 00 	cp.b	r9,r8
80002eda:	c0 21       	brne	80002ede <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002edc:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002ede:	e0 6a 00 ff 	mov	r10,255
80002ee2:	0e 9b       	mov	r11,r7
80002ee4:	31 8c       	mov	r12,24
80002ee6:	f0 1f 00 1b 	mcall	80002f50 <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002eea:	30 0c       	mov	r12,0
80002eec:	f0 1f 00 1a 	mcall	80002f54 <SD_WriteBlock+0x94>
80002ef0:	c1 f1       	brne	80002f2e <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002ef2:	e0 6c 00 ff 	mov	r12,255
80002ef6:	f0 1f 00 19 	mcall	80002f58 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002efa:	e0 6c 00 fe 	mov	r12,254
80002efe:	f0 1f 00 17 	mcall	80002f58 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f02:	5c 76       	castu.h	r6
80002f04:	c0 90       	breq	80002f16 <SD_WriteBlock+0x56>
80002f06:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f08:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f0c:	f0 1f 00 13 	mcall	80002f58 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f10:	2f f7       	sub	r7,-1
80002f12:	0c 37       	cp.w	r7,r6
80002f14:	cf a3       	brcs	80002f08 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002f16:	f0 1f 00 12 	mcall	80002f5c <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002f1a:	f0 1f 00 11 	mcall	80002f5c <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002f1e:	f0 1f 00 11 	mcall	80002f60 <SD_WriteBlock+0xa0>
80002f22:	30 58       	mov	r8,5
80002f24:	f0 0c 18 00 	cp.b	r12,r8
80002f28:	c0 31       	brne	80002f2e <SD_WriteBlock+0x6e>
80002f2a:	30 07       	mov	r7,0
80002f2c:	c0 38       	rjmp	80002f32 <SD_WriteBlock+0x72>
80002f2e:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f32:	31 8c       	mov	r12,24
80002f34:	f0 1f 00 0c 	mcall	80002f64 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f38:	e0 6c 00 ff 	mov	r12,255
80002f3c:	f0 1f 00 07 	mcall	80002f58 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002f40:	0e 9c       	mov	r12,r7
80002f42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f46:	00 00       	add	r0,r0
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	9e 60       	ld.sh	r0,pc[0xc]
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a 68       	and	r8,r5
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	2a c4       	sub	r4,-84
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	2a 04       	sub	r4,-96
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	2a 78       	sub	r8,-89
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	29 c0       	sub	r0,-100
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	2a 38       	sub	r8,-93
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	9e 44       	ld.sh	r4,pc[0x8]

80002f68 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002f68:	d4 31       	pushm	r0-r7,lr
80002f6a:	20 1d       	sub	sp,4
80002f6c:	18 95       	mov	r5,r12
80002f6e:	50 0b       	stdsp	sp[0x0],r11
80002f70:	14 96       	mov	r6,r10
80002f72:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002f74:	31 8c       	mov	r12,24
80002f76:	f0 1f 00 27 	mcall	80003010 <SD_ReadMultiBlocks+0xa8>
80002f7a:	e0 67 00 ff 	mov	r7,255
80002f7e:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002f80:	4a 53       	lddpc	r3,80003014 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002f82:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f84:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002f86:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002f88:	c3 78       	rjmp	80002ff6 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80002f8a:	07 88       	ld.ub	r8,r3[0x0]
80002f8c:	30 19       	mov	r9,1
80002f8e:	f2 08 18 00 	cp.b	r8,r9
80002f92:	c0 a1       	brne	80002fa6 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80002f94:	40 08       	lddsp	r8,sp[0x0]
80002f96:	e4 08 00 0b 	add	r11,r2,r8
80002f9a:	00 9a       	mov	r10,r0
80002f9c:	a9 9b       	lsr	r11,0x9
80002f9e:	31 1c       	mov	r12,17
80002fa0:	f0 1f 00 1e 	mcall	80003018 <SD_ReadMultiBlocks+0xb0>
80002fa4:	c0 88       	rjmp	80002fb4 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002fa6:	00 9a       	mov	r10,r0
80002fa8:	40 09       	lddsp	r9,sp[0x0]
80002faa:	e4 09 00 0b 	add	r11,r2,r9
80002fae:	31 1c       	mov	r12,17
80002fb0:	f0 1f 00 1a 	mcall	80003018 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002fb4:	02 9c       	mov	r12,r1
80002fb6:	f0 1f 00 1a 	mcall	8000301c <SD_ReadMultiBlocks+0xb4>
80002fba:	c0 40       	breq	80002fc2 <SD_ReadMultiBlocks+0x5a>
80002fbc:	e0 67 00 ff 	mov	r7,255
80002fc0:	c2 48       	rjmp	80003008 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002fc2:	e0 6c 00 fe 	mov	r12,254
80002fc6:	f0 1f 00 16 	mcall	8000301c <SD_ReadMultiBlocks+0xb4>
80002fca:	c0 30       	breq	80002fd0 <SD_ReadMultiBlocks+0x68>
80002fcc:	00 97       	mov	r7,r0
80002fce:	c1 38       	rjmp	80002ff4 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002fd0:	58 06       	cp.w	r6,0
80002fd2:	c0 a0       	breq	80002fe6 <SD_ReadMultiBlocks+0x7e>
80002fd4:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80002fd6:	f0 1f 00 13 	mcall	80003020 <SD_ReadMultiBlocks+0xb8>
80002fda:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002fde:	2f f7       	sub	r7,-1
80002fe0:	0c 37       	cp.w	r7,r6
80002fe2:	cf a3       	brcs	80002fd6 <SD_ReadMultiBlocks+0x6e>
80002fe4:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80002fe6:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80002fea:	f0 1f 00 0e 	mcall	80003020 <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
80002fee:	f0 1f 00 0d 	mcall	80003020 <SD_ReadMultiBlocks+0xb8>
80002ff2:	02 97       	mov	r7,r1
80002ff4:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ff6:	58 04       	cp.w	r4,0
80002ff8:	cc 91       	brne	80002f8a <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002ffa:	31 8c       	mov	r12,24
80002ffc:	f0 1f 00 0a 	mcall	80003024 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003000:	e0 6c 00 ff 	mov	r12,255
80003004:	f0 1f 00 09 	mcall	80003028 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
80003008:	0e 9c       	mov	r12,r7
8000300a:	2f fd       	sub	sp,-4
8000300c:	d8 32       	popm	r0-r7,pc
8000300e:	00 00       	add	r0,r0
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	9e 60       	ld.sh	r0,pc[0xc]
80003014:	00 00       	add	r0,r0
80003016:	0a 68       	and	r8,r5
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	2a c4       	sub	r4,-84
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	2a 04       	sub	r4,-96
80003020:	80 00       	ld.sh	r0,r0[0x0]
80003022:	29 c0       	sub	r0,-100
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	9e 44       	ld.sh	r4,pc[0x8]
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	2a 78       	sub	r8,-89

8000302c <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
8000302c:	eb cd 40 e0 	pushm	r5-r7,lr
80003030:	18 95       	mov	r5,r12
80003032:	16 97       	mov	r7,r11
80003034:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80003036:	31 8c       	mov	r12,24
80003038:	f0 1f 00 1a 	mcall	800030a0 <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
8000303c:	49 a8       	lddpc	r8,800030a4 <SD_ReadBlock+0x78>
8000303e:	11 89       	ld.ub	r9,r8[0x0]
80003040:	30 18       	mov	r8,1
80003042:	f0 09 18 00 	cp.b	r9,r8
80003046:	c0 21       	brne	8000304a <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
80003048:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
8000304a:	e0 6a 00 ff 	mov	r10,255
8000304e:	0e 9b       	mov	r11,r7
80003050:	31 1c       	mov	r12,17
80003052:	f0 1f 00 16 	mcall	800030a8 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003056:	30 0c       	mov	r12,0
80003058:	f0 1f 00 15 	mcall	800030ac <SD_ReadBlock+0x80>
8000305c:	c1 61       	brne	80003088 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
8000305e:	e0 6c 00 fe 	mov	r12,254
80003062:	f0 1f 00 13 	mcall	800030ac <SD_ReadBlock+0x80>
80003066:	c1 11       	brne	80003088 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003068:	5c 76       	castu.h	r6
8000306a:	c0 90       	breq	8000307c <SD_ReadBlock+0x50>
8000306c:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
8000306e:	f0 1f 00 11 	mcall	800030b0 <SD_ReadBlock+0x84>
80003072:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003076:	2f f7       	sub	r7,-1
80003078:	0c 37       	cp.w	r7,r6
8000307a:	cf a3       	brcs	8000306e <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
8000307c:	f0 1f 00 0d 	mcall	800030b0 <SD_ReadBlock+0x84>
      SD_ReadByte();
80003080:	f0 1f 00 0c 	mcall	800030b0 <SD_ReadBlock+0x84>
80003084:	30 07       	mov	r7,0
80003086:	c0 38       	rjmp	8000308c <SD_ReadBlock+0x60>
80003088:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000308c:	31 8c       	mov	r12,24
8000308e:	f0 1f 00 0a 	mcall	800030b4 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003092:	e0 6c 00 ff 	mov	r12,255
80003096:	f0 1f 00 09 	mcall	800030b8 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
8000309a:	0e 9c       	mov	r12,r7
8000309c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	9e 60       	ld.sh	r0,pc[0xc]
800030a4:	00 00       	add	r0,r0
800030a6:	0a 68       	and	r8,r5
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	2a c4       	sub	r4,-84
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	2a 04       	sub	r4,-96
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	29 c0       	sub	r0,-100
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	9e 44       	ld.sh	r4,pc[0x8]
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	2a 78       	sub	r8,-89

800030bc <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
800030bc:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
800030c0:	f0 1f 00 11 	mcall	80003104 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
800030c4:	f0 1f 00 11 	mcall	80003108 <SD_Init+0x4c>
800030c8:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
800030ca:	31 84       	mov	r4,24
800030cc:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
800030ce:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
800030d2:	08 9c       	mov	r12,r4
800030d4:	f0 1f 00 0e 	mcall	8000310c <SD_Init+0x50>
800030d8:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
800030da:	0c 9c       	mov	r12,r6
800030dc:	f0 1f 00 0d 	mcall	80003110 <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
800030e0:	2f f7       	sub	r7,-1
800030e2:	58 a7       	cp.w	r7,10
800030e4:	cf b1       	brne	800030da <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
800030e6:	f0 1f 00 0c 	mcall	80003114 <SD_Init+0x58>
800030ea:	18 97       	mov	r7,r12

    if(TimeOut > 6)
800030ec:	58 75       	cp.w	r5,7
800030ee:	c0 50       	breq	800030f8 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
800030f0:	58 0c       	cp.w	r12,0
800030f2:	c0 30       	breq	800030f8 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
800030f4:	2f f5       	sub	r5,-1
800030f6:	ce eb       	rjmp	800030d2 <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
800030f8:	f0 1f 00 08 	mcall	80003118 <SD_Init+0x5c>
  return (Status);
}
800030fc:	0e 9c       	mov	r12,r7
800030fe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003102:	00 00       	add	r0,r0
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	29 48       	sub	r8,-108
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	29 38       	sub	r8,-109
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	9e 44       	ld.sh	r4,pc[0x8]
80003110:	80 00       	ld.sh	r0,r0[0x0]
80003112:	2a 78       	sub	r8,-89
80003114:	80 00       	ld.sh	r0,r0[0x0]
80003116:	2b 00       	sub	r0,-80
80003118:	80 00       	ld.sh	r0,r0[0x0]
8000311a:	29 28       	sub	r8,-110

8000311c <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
8000311c:	eb cd 40 e0 	pushm	r5-r7,lr
80003120:	20 9d       	sub	sp,36
80003122:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
80003124:	31 8c       	mov	r12,24
80003126:	f0 1f 00 a6 	mcall	800033bc <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
8000312a:	e0 6a 00 ff 	mov	r10,255
8000312e:	30 0b       	mov	r11,0
80003130:	30 9c       	mov	r12,9
80003132:	f0 1f 00 a4 	mcall	800033c0 <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003136:	30 0c       	mov	r12,0
80003138:	f0 1f 00 a3 	mcall	800033c4 <SD_GetCSDRegister+0x2a8>
8000313c:	c0 40       	breq	80003144 <SD_GetCSDRegister+0x28>
8000313e:	e0 6c 00 ff 	mov	r12,255
80003142:	c3 99       	rjmp	800033b4 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003144:	e0 6c 00 fe 	mov	r12,254
80003148:	f0 1f 00 9f 	mcall	800033c4 <SD_GetCSDRegister+0x2a8>
8000314c:	c0 a1       	brne	80003160 <SD_GetCSDRegister+0x44>
8000314e:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
80003152:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
80003156:	f0 1f 00 9d 	mcall	800033c8 <SD_GetCSDRegister+0x2ac>
8000315a:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
8000315c:	0a 36       	cp.w	r6,r5
8000315e:	cf c1       	brne	80003156 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80003160:	e0 6c 00 ff 	mov	r12,255
80003164:	f0 1f 00 9a 	mcall	800033cc <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
80003168:	e0 6c 00 ff 	mov	r12,255
8000316c:	f0 1f 00 98 	mcall	800033cc <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003170:	31 8c       	mov	r12,24
80003172:	f0 1f 00 98 	mcall	800033d0 <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003176:	e0 6c 00 ff 	mov	r12,255
8000317a:	f0 1f 00 95 	mcall	800033cc <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
8000317e:	fb 38 00 14 	ld.ub	r8,sp[20]
80003182:	f0 09 16 06 	lsr	r9,r8,0x6
80003186:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
80003188:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
8000318c:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
8000318e:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003192:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
80003194:	fe f8 02 40 	ld.w	r8,pc[576]
80003198:	70 08       	ld.w	r8,r8[0x0]
8000319a:	58 08       	cp.w	r8,0
8000319c:	c0 f1       	brne	800031ba <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
8000319e:	0f 89       	ld.ub	r9,r7[0x0]
800031a0:	30 18       	mov	r8,1
800031a2:	f0 09 18 00 	cp.b	r9,r8
800031a6:	c0 61       	brne	800031b2 <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
800031a8:	10 99       	mov	r9,r8
800031aa:	fe f8 02 2e 	ld.w	r8,pc[558]
800031ae:	b0 89       	st.b	r8[0x0],r9
800031b0:	c0 58       	rjmp	800031ba <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
800031b2:	30 09       	mov	r9,0
800031b4:	fe f8 02 24 	ld.w	r8,pc[548]
800031b8:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
800031ba:	fb 38 00 15 	ld.ub	r8,sp[21]
800031be:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
800031c0:	fb 38 00 16 	ld.ub	r8,sp[22]
800031c4:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
800031c6:	fb 38 00 17 	ld.ub	r8,sp[23]
800031ca:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
800031cc:	fb 38 00 18 	ld.ub	r8,sp[24]
800031d0:	a5 68       	lsl	r8,0x4
800031d2:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
800031d4:	8e 39       	ld.sh	r9,r7[0x6]
800031d6:	fb 38 00 19 	ld.ub	r8,sp[25]
800031da:	f3 e8 12 49 	or	r9,r9,r8>>0x4
800031de:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
800031e0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800031e4:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
800031e8:	fb 38 00 1a 	ld.ub	r8,sp[26]
800031ec:	f0 09 16 07 	lsr	r9,r8,0x7
800031f0:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
800031f4:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800031f8:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
800031fc:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003200:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003204:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003208:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
8000320c:	30 09       	mov	r9,0
8000320e:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
80003212:	4f 2a       	lddpc	r10,800033d8 <SD_GetCSDRegister+0x2bc>
80003214:	15 8a       	ld.ub	r10,r10[0x0]
80003216:	f2 0a 18 00 	cp.b	r10,r9
8000321a:	c1 21       	brne	8000323e <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
8000321c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003220:	ab 68       	lsl	r8,0xa
80003222:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
80003224:	6e 48       	ld.w	r8,r7[0x10]
80003226:	fb 39 00 1b 	ld.ub	r9,sp[27]
8000322a:	f1 e9 10 28 	or	r8,r8,r9<<0x2
8000322e:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
80003230:	6e 48       	ld.w	r8,r7[0x10]
80003232:	fb 39 00 1c 	ld.ub	r9,sp[28]
80003236:	f1 e9 12 68 	or	r8,r8,r9>>0x6
8000323a:	8f 48       	st.w	r7[0x10],r8
8000323c:	c1 38       	rjmp	80003262 <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
8000323e:	fb 38 00 1b 	ld.ub	r8,sp[27]
80003242:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003246:	b1 68       	lsl	r8,0x10
80003248:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
8000324a:	6e 49       	ld.w	r9,r7[0x10]
8000324c:	fb 38 00 1c 	ld.ub	r8,sp[28]
80003250:	a9 68       	lsl	r8,0x8
80003252:	12 08       	add	r8,r9
80003254:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
80003256:	6e 48       	ld.w	r8,r7[0x10]
80003258:	fb 39 00 1d 	ld.ub	r9,sp[29]
8000325c:	f2 08 00 08 	add	r8,r9,r8
80003260:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
80003262:	fb 38 00 1c 	ld.ub	r8,sp[28]
80003266:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
8000326a:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
8000326e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003272:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
80003276:	fb 38 00 1d 	ld.ub	r8,sp[29]
8000327a:	f0 09 16 05 	lsr	r9,r8,0x5
8000327e:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
80003282:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003286:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
8000328a:	a1 78       	lsl	r8,0x1
8000328c:	e2 18 00 06 	andl	r8,0x6,COH
80003290:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
80003294:	ef 39 00 18 	ld.ub	r9,r7[24]
80003298:	fb 38 00 1e 	ld.ub	r8,sp[30]
8000329c:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032a0:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
800032a4:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800032a8:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
800032ac:	a1 78       	lsl	r8,0x1
800032ae:	e2 18 00 7e 	andl	r8,0x7e,COH
800032b2:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
800032b6:	ef 39 00 1a 	ld.ub	r9,r7[26]
800032ba:	fb 38 00 1f 	ld.ub	r8,sp[31]
800032be:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032c2:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
800032c6:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800032ca:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
800032ce:	fb 38 00 20 	ld.ub	r8,sp[32]
800032d2:	f0 09 16 07 	lsr	r9,r8,0x7
800032d6:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
800032da:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
800032de:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
800032e2:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
800032e6:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
800032ea:	a3 68       	lsl	r8,0x2
800032ec:	e2 18 00 0c 	andl	r8,0xc,COH
800032f0:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
800032f4:	ef 39 00 1f 	ld.ub	r9,r7[31]
800032f8:	fb 38 00 21 	ld.ub	r8,sp[33]
800032fc:	f3 e8 12 69 	or	r9,r9,r8>>0x6
80003300:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003304:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003308:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
8000330c:	30 09       	mov	r9,0
8000330e:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
80003312:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003316:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
8000331a:	fb 38 00 22 	ld.ub	r8,sp[34]
8000331e:	f0 09 16 07 	lsr	r9,r8,0x7
80003322:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
80003326:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
8000332a:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
8000332e:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003332:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
80003336:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
8000333a:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
8000333e:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
80003342:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
80003346:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000334a:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
8000334e:	fb 38 00 23 	ld.ub	r8,sp[35]
80003352:	a1 98       	lsr	r8,0x1
80003354:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
80003358:	30 18       	mov	r8,1
8000335a:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
8000335e:	49 e8       	lddpc	r8,800033d4 <SD_GetCSDRegister+0x2b8>
80003360:	70 08       	ld.w	r8,r8[0x0]
80003362:	58 28       	cp.w	r8,2
80003364:	e0 88 00 04 	brls	8000336c <SD_GetCSDRegister+0x250>
80003368:	30 0c       	mov	r12,0
8000336a:	c2 58       	rjmp	800033b4 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
8000336c:	49 b9       	lddpc	r9,800033d8 <SD_GetCSDRegister+0x2bc>
8000336e:	13 8a       	ld.ub	r10,r9[0x0]
80003370:	30 19       	mov	r9,1
80003372:	f2 0a 18 00 	cp.b	r10,r9
80003376:	c0 51       	brne	80003380 <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
80003378:	6e 49       	ld.w	r9,r7[0x10]
8000337a:	2f f9       	sub	r9,-1
8000337c:	a9 79       	lsl	r9,0x9
8000337e:	c0 c8       	rjmp	80003396 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
80003380:	6e 4a       	ld.w	r10,r7[0x10]
80003382:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
80003384:	ef 39 00 18 	ld.ub	r9,r7[24]
80003388:	2f e9       	sub	r9,-2
8000338a:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
8000338e:	ef 39 00 08 	ld.ub	r9,r7[8]
80003392:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
80003396:	58 08       	cp.w	r8,0
80003398:	c0 91       	brne	800033aa <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
8000339a:	b5 89       	lsr	r9,0x14
8000339c:	1a d9       	st.w	--sp,r9
8000339e:	49 0b       	lddpc	r11,800033dc <SD_GetCSDRegister+0x2c0>
800033a0:	fa cc ff fc 	sub	r12,sp,-4
800033a4:	f0 1f 00 0f 	mcall	800033e0 <SD_GetCSDRegister+0x2c4>
800033a8:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
800033aa:	48 b8       	lddpc	r8,800033d4 <SD_GetCSDRegister+0x2b8>
800033ac:	70 09       	ld.w	r9,r8[0x0]
800033ae:	2f f9       	sub	r9,-1
800033b0:	91 09       	st.w	r8[0x0],r9
800033b2:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
800033b4:	2f 7d       	sub	sp,-36
800033b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800033ba:	00 00       	add	r0,r0
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	9e 60       	ld.sh	r0,pc[0xc]
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	2a c4       	sub	r4,-84
800033c4:	80 00       	ld.sh	r0,r0[0x0]
800033c6:	2a 04       	sub	r4,-96
800033c8:	80 00       	ld.sh	r0,r0[0x0]
800033ca:	29 c0       	sub	r0,-100
800033cc:	80 00       	ld.sh	r0,r0[0x0]
800033ce:	2a 78       	sub	r8,-89
800033d0:	80 00       	ld.sh	r0,r0[0x0]
800033d2:	9e 44       	ld.sh	r4,pc[0x8]
800033d4:	00 00       	add	r0,r0
800033d6:	0a 64       	and	r4,r5
800033d8:	00 00       	add	r0,r0
800033da:	0a 68       	and	r8,r5
800033dc:	80 01       	ld.sh	r1,r0[0x0]
800033de:	03 80       	ld.ub	r0,r1[0x0]
800033e0:	80 00       	ld.sh	r0,r0[0x0]
800033e2:	a7 70       	lsl	r0,0x7

800033e4 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
800033e4:	eb cd 40 c0 	pushm	r6-r7,lr
800033e8:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
800033ea:	18 96       	mov	r6,r12
800033ec:	f0 1f 00 12 	mcall	80003434 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
800033f0:	e0 4c 00 ff 	cp.w	r12,255
800033f4:	c0 41       	brne	800033fc <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
800033f6:	0e 9c       	mov	r12,r7
800033f8:	f0 1f 00 0f 	mcall	80003434 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
800033fc:	ee cc ff d4 	sub	r12,r7,-44
80003400:	f0 1f 00 0e 	mcall	80003438 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003404:	30 19       	mov	r9,1
80003406:	48 e8       	lddpc	r8,8000343c <SD_GetCardInfo+0x58>
80003408:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
8000340a:	6e 48       	ld.w	r8,r7[0x10]
8000340c:	2f f8       	sub	r8,-1
8000340e:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
80003412:	ef 39 00 08 	ld.ub	r9,r7[8]
80003416:	30 1a       	mov	r10,1
80003418:	f4 09 09 49 	lsl	r9,r10,r9
8000341c:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
80003420:	f2 08 02 48 	mul	r8,r9,r8
80003424:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
80003428:	48 68       	lddpc	r8,80003440 <SD_GetCardInfo+0x5c>
8000342a:	70 09       	ld.w	r9,r8[0x0]
8000342c:	14 09       	add	r9,r10
8000342e:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
80003430:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	31 1c       	mov	r12,17
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	2c c8       	sub	r8,-52
8000343c:	00 00       	add	r0,r0
8000343e:	0a 68       	and	r8,r5
80003440:	00 00       	add	r0,r0
80003442:	0a 60       	and	r0,r5

80003444 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
80003444:	d4 01       	pushm	lr
80003446:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
80003448:	1a 9c       	mov	r12,sp
8000344a:	f0 1f 00 05 	mcall	8000345c <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
8000344e:	41 1c       	lddsp	r12,sp[0x44]
80003450:	a1 7c       	lsl	r12,0x1
80003452:	48 48       	lddpc	r8,80003460 <SD_GetSectorCount+0x1c>
80003454:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
80003456:	2e dd       	sub	sp,-76
80003458:	d8 02       	popm	pc
8000345a:	00 00       	add	r0,r0
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	33 e4       	mov	r4,62
80003460:	00 00       	add	r0,r0
80003462:	0a 5c       	eor	r12,r5

80003464 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003464:	d4 01       	pushm	lr
	
	
	if(count == 1)
80003466:	30 18       	mov	r8,1
80003468:	f0 09 18 00 	cp.b	r9,r8
8000346c:	c0 71       	brne	8000347a <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
8000346e:	5c 7a       	castu.h	r10
80003470:	a9 7b       	lsl	r11,0x9
80003472:	f0 1f 00 07 	mcall	8000348c <MAL_WriteDisk+0x28>
80003476:	c0 91       	brne	80003488 <MAL_WriteDisk+0x24>
80003478:	c0 68       	rjmp	80003484 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
8000347a:	5c 7a       	castu.h	r10
8000347c:	a9 7b       	lsl	r11,0x9
8000347e:	f0 1f 00 05 	mcall	80003490 <MAL_WriteDisk+0x2c>
80003482:	c0 31       	brne	80003488 <MAL_WriteDisk+0x24>
80003484:	30 4c       	mov	r12,4
80003486:	d8 02       	popm	pc
80003488:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
8000348a:	d8 02       	popm	pc
8000348c:	80 00       	ld.sh	r0,r0[0x0]
8000348e:	2e c0       	sub	r0,-20
80003490:	80 00       	ld.sh	r0,r0[0x0]
80003492:	2d f8       	sub	r8,-33

80003494 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003494:	d4 01       	pushm	lr
	
	
	if(count == 1)
80003496:	30 18       	mov	r8,1
80003498:	f0 09 18 00 	cp.b	r9,r8
8000349c:	c0 71       	brne	800034aa <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
8000349e:	5c 7a       	castu.h	r10
800034a0:	a9 7b       	lsl	r11,0x9
800034a2:	f0 1f 00 07 	mcall	800034bc <MAL_ReadDisk+0x28>
800034a6:	c0 91       	brne	800034b8 <MAL_ReadDisk+0x24>
800034a8:	c0 68       	rjmp	800034b4 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034aa:	5c 7a       	castu.h	r10
800034ac:	a9 7b       	lsl	r11,0x9
800034ae:	f0 1f 00 05 	mcall	800034c0 <MAL_ReadDisk+0x2c>
800034b2:	c0 31       	brne	800034b8 <MAL_ReadDisk+0x24>
800034b4:	30 8c       	mov	r12,8
800034b6:	d8 02       	popm	pc
800034b8:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
800034ba:	d8 02       	popm	pc
800034bc:	80 00       	ld.sh	r0,r0[0x0]
800034be:	30 2c       	mov	r12,2
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	2f 68       	sub	r8,-10

800034c4 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
800034c4:	d4 01       	pushm	lr
800034c6:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
800034c8:	f0 1f 00 06 	mcall	800034e0 <MAL_InitConfig+0x1c>
800034cc:	c0 30       	breq	800034d2 <MAL_InitConfig+0xe>
800034ce:	30 1c       	mov	r12,1
800034d0:	c0 58       	rjmp	800034da <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
800034d2:	1a 9c       	mov	r12,sp
800034d4:	f0 1f 00 04 	mcall	800034e4 <MAL_InitConfig+0x20>
800034d8:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
800034da:	2e dd       	sub	sp,-76
800034dc:	d8 02       	popm	pc
800034de:	00 00       	add	r0,r0
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	30 bc       	mov	r12,11
800034e4:	80 00       	ld.sh	r0,r0[0x0]
800034e6:	33 e4       	mov	r4,62

800034e8 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
800034e8:	eb cd 40 f8 	pushm	r3-r7,lr
800034ec:	20 2d       	sub	sp,8
800034ee:	18 95       	mov	r5,r12
800034f0:	16 94       	mov	r4,r11
800034f2:	14 93       	mov	r3,r10
800034f4:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
800034f6:	34 cc       	mov	r12,76
800034f8:	f0 1f 00 16 	mcall	80003550 <fl_write+0x68>
800034fc:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
800034fe:	0a 9b       	mov	r11,r5
80003500:	f0 1f 00 15 	mcall	80003554 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003504:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80003508:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
8000350c:	0c 9c       	mov	r12,r6
8000350e:	f0 1f 00 11 	mcall	80003550 <fl_write+0x68>
80003512:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
80003516:	0c 9a       	mov	r10,r6
80003518:	06 9b       	mov	r11,r3
8000351a:	f0 1f 00 10 	mcall	80003558 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
8000351e:	e0 68 40 00 	mov	r8,16384
80003522:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003524:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
80003526:	48 e8       	lddpc	r8,8000355c <fl_write+0x74>
80003528:	70 0c       	ld.w	r12,r8[0x0]
8000352a:	30 09       	mov	r9,0
8000352c:	12 9a       	mov	r10,r9
8000352e:	1a 9b       	mov	r11,sp
80003530:	f0 1f 00 0c 	mcall	80003560 <fl_write+0x78>
80003534:	58 1c       	cp.w	r12,1
80003536:	c0 a0       	breq	8000354a <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
80003538:	6f 2c       	ld.w	r12,r7[0x48]
8000353a:	f0 1f 00 0b 	mcall	80003564 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
8000353e:	0e 9c       	mov	r12,r7
80003540:	f0 1f 00 09 	mcall	80003564 <fl_write+0x7c>
		log("\n\r fsmm \n\r");//man...SPI_PBA
80003544:	48 9c       	lddpc	r12,80003568 <fl_write+0x80>
80003546:	f0 1f 00 0a 	mcall	8000356c <fl_write+0x84>
	}
	
}
8000354a:	2f ed       	sub	sp,-8
8000354c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003550:	80 00       	ld.sh	r0,r0[0x0]
80003552:	8a 30       	ld.sh	r0,r5[0x6]
80003554:	80 00       	ld.sh	r0,r0[0x0]
80003556:	a7 ac       	sbr	r12,0x6
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	a3 3a       	mul	r10,r1
8000355c:	00 00       	add	r0,r0
8000355e:	0d 40       	ld.w	r0,--r6
80003560:	80 00       	ld.sh	r0,r0[0x0]
80003562:	8d 84       	st.w	r6[0x20],r4
80003564:	80 00       	ld.sh	r0,r0[0x0]
80003566:	8a 08       	ld.sh	r8,r5[0x0]
80003568:	80 01       	ld.sh	r1,r0[0x0]
8000356a:	03 c8       	ld.ub	r8,r1[0x4]
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	99 74       	st.w	r12[0x1c],r4

80003570 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
80003570:	d4 31       	pushm	r0-r7,lr
80003572:	20 1d       	sub	sp,4
80003574:	18 97       	mov	r7,r12
80003576:	16 96       	mov	r6,r11
80003578:	14 94       	mov	r4,r10
8000357a:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
8000357c:	30 1a       	mov	r10,1
8000357e:	4c 7b       	lddpc	r11,80003698 <fl_write_func+0x128>
80003580:	4c 7c       	lddpc	r12,8000369c <fl_write_func+0x12c>
80003582:	f0 1f 00 48 	mcall	800036a0 <fl_write_func+0x130>
80003586:	e0 81 00 86 	brne	80003692 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
8000358a:	0e 91       	mov	r1,r7
8000358c:	31 2a       	mov	r10,18
8000358e:	0e 9b       	mov	r11,r7
80003590:	4c 5c       	lddpc	r12,800036a4 <fl_write_func+0x134>
80003592:	f0 1f 00 46 	mcall	800036a8 <fl_write_func+0x138>
	if(FR_NO_PATH == res)
80003596:	58 5c       	cp.w	r12,5
80003598:	c5 91       	brne	8000364a <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
8000359a:	4c 0b       	lddpc	r11,80003698 <fl_write_func+0x128>
8000359c:	4c 4c       	lddpc	r12,800036ac <fl_write_func+0x13c>
8000359e:	f0 1f 00 45 	mcall	800036b0 <fl_write_func+0x140>
800035a2:	c0 80       	breq	800035b2 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800035a4:	30 1a       	mov	r10,1
800035a6:	4b db       	lddpc	r11,80003698 <fl_write_func+0x128>
800035a8:	30 0c       	mov	r12,0
800035aa:	f0 1f 00 3e 	mcall	800036a0 <fl_write_func+0x130>
800035ae:	30 6c       	mov	r12,6
			return fs_err;
800035b0:	c7 28       	rjmp	80003694 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
800035b2:	0e 9c       	mov	r12,r7
800035b4:	f0 1f 00 40 	mcall	800036b4 <fl_write_func+0x144>
800035b8:	4c 03       	lddpc	r3,800036b8 <fl_write_func+0x148>
800035ba:	18 9a       	mov	r10,r12
800035bc:	0e 9b       	mov	r11,r7
800035be:	06 9c       	mov	r12,r3
800035c0:	f0 1f 00 3f 	mcall	800036bc <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
800035c4:	4b 57       	lddpc	r7,80003698 <fl_write_func+0x128>
800035c6:	0e 9b       	mov	r11,r7
800035c8:	06 9c       	mov	r12,r3
800035ca:	f0 1f 00 3e 	mcall	800036c0 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
800035ce:	1a dc       	st.w	--sp,r12
800035d0:	4b db       	lddpc	r11,800036c4 <fl_write_func+0x154>
800035d2:	4b ec       	lddpc	r12,800036c8 <fl_write_func+0x158>
800035d4:	f0 1f 00 3e 	mcall	800036cc <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
800035d8:	0e 9b       	mov	r11,r7
800035da:	30 0c       	mov	r12,0
800035dc:	f0 1f 00 39 	mcall	800036c0 <fl_write_func+0x150>
800035e0:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
800035e2:	2f fd       	sub	sp,-4
800035e4:	58 0c       	cp.w	r12,0
800035e6:	c2 50       	breq	80003630 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
800035e8:	4b 83       	lddpc	r3,800036c8 <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
800035ea:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
800035ec:	4b 90       	lddpc	r0,800036d0 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
800035ee:	06 9c       	mov	r12,r3
800035f0:	f0 1f 00 39 	mcall	800036d4 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
800035f4:	5f 09       	sreq	r9
800035f6:	58 8c       	cp.w	r12,8
800035f8:	5f 08       	sreq	r8
800035fa:	f3 e8 10 08 	or	r8,r9,r8
800035fe:	e4 08 18 00 	cp.b	r8,r2
80003602:	c1 00       	breq	80003622 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003604:	1a d7       	st.w	--sp,r7
80003606:	1a d3       	st.w	--sp,r3
80003608:	00 9b       	mov	r11,r0
8000360a:	06 9c       	mov	r12,r3
8000360c:	f0 1f 00 30 	mcall	800036cc <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003610:	4a 2b       	lddpc	r11,80003698 <fl_write_func+0x128>
80003612:	30 0c       	mov	r12,0
80003614:	f0 1f 00 2b 	mcall	800036c0 <fl_write_func+0x150>
80003618:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000361a:	2f ed       	sub	sp,-8
8000361c:	58 0c       	cp.w	r12,0
8000361e:	ce 81       	brne	800035ee <fl_write_func+0x7e>
80003620:	c0 88       	rjmp	80003630 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003622:	30 1a       	mov	r10,1
80003624:	49 db       	lddpc	r11,80003698 <fl_write_func+0x128>
80003626:	30 0c       	mov	r12,0
80003628:	f0 1f 00 1e 	mcall	800036a0 <fl_write_func+0x130>
8000362c:	30 4c       	mov	r12,4
					return new_dir_err;
8000362e:	c3 38       	rjmp	80003694 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003630:	31 2a       	mov	r10,18
80003632:	02 9b       	mov	r11,r1
80003634:	49 cc       	lddpc	r12,800036a4 <fl_write_func+0x134>
80003636:	f0 1f 00 1d 	mcall	800036a8 <fl_write_func+0x138>
				if(res != FR_OK)
8000363a:	c1 10       	breq	8000365c <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
8000363c:	30 1a       	mov	r10,1
8000363e:	49 7b       	lddpc	r11,80003698 <fl_write_func+0x128>
80003640:	30 0c       	mov	r12,0
80003642:	f0 1f 00 18 	mcall	800036a0 <fl_write_func+0x130>
80003646:	30 3c       	mov	r12,3
					return open_fl_err;
80003648:	c2 68       	rjmp	80003694 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000364a:	58 0c       	cp.w	r12,0
8000364c:	c0 80       	breq	8000365c <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
8000364e:	30 1a       	mov	r10,1
80003650:	49 2b       	lddpc	r11,80003698 <fl_write_func+0x128>
80003652:	30 0c       	mov	r12,0
80003654:	f0 1f 00 13 	mcall	800036a0 <fl_write_func+0x130>
80003658:	30 3c       	mov	r12,3
		return open_fl_err;
8000365a:	c1 d8       	rjmp	80003694 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
8000365c:	5b f6       	cp.w	r6,-1
8000365e:	c0 61       	brne	8000366a <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
80003660:	49 1c       	lddpc	r12,800036a4 <fl_write_func+0x134>
80003662:	78 3b       	ld.w	r11,r12[0xc]
80003664:	f0 1f 00 1d 	mcall	800036d8 <fl_write_func+0x168>
80003668:	c0 58       	rjmp	80003672 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
8000366a:	0c 9b       	mov	r11,r6
8000366c:	48 ec       	lddpc	r12,800036a4 <fl_write_func+0x134>
8000366e:	f0 1f 00 1b 	mcall	800036d8 <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
80003672:	48 d7       	lddpc	r7,800036a4 <fl_write_func+0x134>
80003674:	1a 99       	mov	r9,sp
80003676:	0a 9a       	mov	r10,r5
80003678:	08 9b       	mov	r11,r4
8000367a:	0e 9c       	mov	r12,r7
8000367c:	f0 1f 00 18 	mcall	800036dc <fl_write_func+0x16c>

	f_close (&fl);
80003680:	0e 9c       	mov	r12,r7
80003682:	f0 1f 00 18 	mcall	800036e0 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
80003686:	30 1a       	mov	r10,1
80003688:	48 4b       	lddpc	r11,80003698 <fl_write_func+0x128>
8000368a:	30 0c       	mov	r12,0
8000368c:	f0 1f 00 05 	mcall	800036a0 <fl_write_func+0x130>
80003690:	c0 28       	rjmp	80003694 <fl_write_func+0x124>
}
80003692:	30 2c       	mov	r12,2
80003694:	2f fd       	sub	sp,-4
80003696:	d8 32       	popm	r0-r7,pc
80003698:	80 01       	ld.sh	r1,r0[0x0]
8000369a:	03 c4       	ld.ub	r4,r1[0x4]
8000369c:	00 00       	add	r0,r0
8000369e:	0a 70       	tst	r0,r5
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	6f a0       	ld.w	r0,r7[0x68]
800036a4:	00 00       	add	r0,r0
800036a6:	0d 48       	ld.w	r8,--r6
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	7f 6c       	ld.w	r12,pc[0x58]
800036ac:	00 00       	add	r0,r0
800036ae:	0c e0       	st.h	--r6,r0
800036b0:	80 00       	ld.sh	r0,r0[0x0]
800036b2:	7d 30       	ld.w	r0,lr[0x4c]
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	a7 be       	sbr	lr,0x7
800036b8:	00 00       	add	r0,r0
800036ba:	0d 00       	ld.w	r0,r6++
800036bc:	80 00       	ld.sh	r0,r0[0x0]
800036be:	a3 3a       	mul	r10,r1
800036c0:	80 00       	ld.sh	r0,r0[0x0]
800036c2:	a7 f4       	*unknown*
800036c4:	80 01       	ld.sh	r1,r0[0x0]
800036c6:	03 d4       	ld.ub	r4,r1[0x5]
800036c8:	00 00       	add	r0,r0
800036ca:	0c a0       	st.w	r6++,r0
800036cc:	80 00       	ld.sh	r0,r0[0x0]
800036ce:	a7 70       	lsl	r0,0x7
800036d0:	80 01       	ld.sh	r1,r0[0x0]
800036d2:	03 dc       	ld.ub	r12,r1[0x5]
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	7d b4       	ld.w	r4,lr[0x6c]
800036d8:	80 00       	ld.sh	r0,r0[0x0]
800036da:	82 0c       	ld.sh	r12,r1[0x0]
800036dc:	80 00       	ld.sh	r0,r0[0x0]
800036de:	84 c0       	ld.uh	r0,r2[0x8]
800036e0:	80 00       	ld.sh	r0,r0[0x0]
800036e2:	70 ec       	ld.w	r12,r8[0x38]

800036e4 <fl_oper_process>:


static void fl_oper_process(void * pvParameters)
{
800036e4:	eb cd 40 f8 	pushm	r3-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
800036e8:	30 8c       	mov	r12,8
800036ea:	f0 1f 00 17 	mcall	80003744 <fl_oper_process+0x60>
800036ee:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
800036f0:	49 66       	lddpc	r6,80003748 <fl_oper_process+0x64>
800036f2:	30 05       	mov	r5,0
800036f4:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
800036f6:	e0 63 40 00 	mov	r3,16384
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
800036fa:	6c 0c       	ld.w	r12,r6[0x0]
800036fc:	0a 99       	mov	r9,r5
800036fe:	08 9a       	mov	r10,r4
80003700:	0e 9b       	mov	r11,r7
80003702:	f0 1f 00 13 	mcall	8000374c <fl_oper_process+0x68>
80003706:	58 1c       	cp.w	r12,1
80003708:	cf 91       	brne	800036fa <fl_oper_process+0x16>
		{  
			switch(fl_oper->opcode)
8000370a:	8e 08       	ld.sh	r8,r7[0x0]
8000370c:	e6 08 19 00 	cp.h	r8,r3
80003710:	c1 31       	brne	80003736 <fl_oper_process+0x52>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
80003712:	6e 1c       	ld.w	r12,r7[0x4]
80003714:	58 0c       	cp.w	r12,0
80003716:	cf 20       	breq	800036fa <fl_oper_process+0x16>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
80003718:	79 2a       	ld.w	r10,r12[0x48]
8000371a:	58 0a       	cp.w	r10,0
8000371c:	c0 90       	breq	8000372e <fl_oper_process+0x4a>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
8000371e:	79 19       	ld.w	r9,r12[0x44]
80003720:	79 0b       	ld.w	r11,r12[0x40]
80003722:	f0 1f 00 0c 	mcall	80003750 <fl_oper_process+0x6c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
80003726:	6e 18       	ld.w	r8,r7[0x4]
80003728:	71 2c       	ld.w	r12,r8[0x48]
8000372a:	f0 1f 00 0b 	mcall	80003754 <fl_oper_process+0x70>
					}
					vPortFree(fl_oper->payload);					
8000372e:	6e 1c       	ld.w	r12,r7[0x4]
80003730:	f0 1f 00 09 	mcall	80003754 <fl_oper_process+0x70>
80003734:	ce 3b       	rjmp	800036fa <fl_oper_process+0x16>
				}
				break;
								
			default:
				if(NULL != fl_oper->payload)
80003736:	6e 1c       	ld.w	r12,r7[0x4]
80003738:	58 0c       	cp.w	r12,0
8000373a:	ce 00       	breq	800036fa <fl_oper_process+0x16>
				{
					vPortFree(fl_oper->payload);
8000373c:	f0 1f 00 06 	mcall	80003754 <fl_oper_process+0x70>
80003740:	cd db       	rjmp	800036fa <fl_oper_process+0x16>
80003742:	00 00       	add	r0,r0
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	8a 30       	ld.sh	r0,r5[0x6]
80003748:	00 00       	add	r0,r0
8000374a:	0d 40       	ld.w	r0,--r6
8000374c:	80 00       	ld.sh	r0,r0[0x0]
8000374e:	8b 78       	st.w	r5[0x1c],r8
80003750:	80 00       	ld.sh	r0,r0[0x0]
80003752:	35 70       	mov	r0,87
80003754:	80 00       	ld.sh	r0,r0[0x0]
80003756:	8a 08       	ld.sh	r8,r5[0x0]

80003758 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
80003758:	d4 01       	pushm	lr
8000375a:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
8000375c:	f0 1f 00 41 	mcall	80003860 <disk_init+0x108>
80003760:	5c 8c       	casts.h	r12
80003762:	c0 30       	breq	80003768 <disk_init+0x10>
80003764:	30 1c       	mov	r12,1
80003766:	c7 a8       	rjmp	8000385a <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
80003768:	30 1a       	mov	r10,1
8000376a:	4b fb       	lddpc	r11,80003864 <disk_init+0x10c>
8000376c:	4b fc       	lddpc	r12,80003868 <disk_init+0x110>
8000376e:	f0 1f 00 40 	mcall	8000386c <disk_init+0x114>
80003772:	c0 30       	breq	80003778 <disk_init+0x20>
80003774:	30 2c       	mov	r12,2
80003776:	c7 28       	rjmp	8000385a <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
80003778:	4b ea       	lddpc	r10,80003870 <disk_init+0x118>
8000377a:	4b fb       	lddpc	r11,80003874 <disk_init+0x11c>
8000377c:	4b ac       	lddpc	r12,80003864 <disk_init+0x10c>
8000377e:	f0 1f 00 3f 	mcall	80003878 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
80003782:	58 dc       	cp.w	r12,13
80003784:	c1 41       	brne	800037ac <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
80003786:	e0 6a 10 00 	mov	r10,4096
8000378a:	30 0b       	mov	r11,0
8000378c:	16 9c       	mov	r12,r11
8000378e:	f0 1f 00 3c 	mcall	8000387c <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
80003792:	4b 8a       	lddpc	r10,80003870 <disk_init+0x118>
80003794:	4b 8b       	lddpc	r11,80003874 <disk_init+0x11c>
80003796:	4b 4c       	lddpc	r12,80003864 <disk_init+0x10c>
80003798:	f0 1f 00 38 	mcall	80003878 <disk_init+0x120>
8000379c:	c1 10       	breq	800037be <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
8000379e:	30 1a       	mov	r10,1
800037a0:	4b 1b       	lddpc	r11,80003864 <disk_init+0x10c>
800037a2:	30 0c       	mov	r12,0
800037a4:	f0 1f 00 32 	mcall	8000386c <disk_init+0x114>
800037a8:	30 5c       	mov	r12,5
			return no_fs;
800037aa:	c5 88       	rjmp	8000385a <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
800037ac:	58 0c       	cp.w	r12,0
800037ae:	c0 80       	breq	800037be <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
800037b0:	30 1a       	mov	r10,1
800037b2:	4a db       	lddpc	r11,80003864 <disk_init+0x10c>
800037b4:	30 0c       	mov	r12,0
800037b6:	f0 1f 00 2e 	mcall	8000386c <disk_init+0x114>
800037ba:	30 6c       	mov	r12,6
		return fs_err;
800037bc:	c4 f8       	rjmp	8000385a <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
800037be:	1a 9b       	mov	r11,sp
800037c0:	30 08       	mov	r8,0
800037c2:	30 09       	mov	r9,0
800037c4:	fa e9 00 00 	st.d	sp[0],r8
800037c8:	30 0a       	mov	r10,0
800037ca:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
800037cc:	4a 6c       	lddpc	r12,80003864 <disk_init+0x10c>
800037ce:	f0 1f 00 2d 	mcall	80003880 <disk_init+0x128>
800037d2:	c0 80       	breq	800037e2 <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
800037d4:	30 1a       	mov	r10,1
800037d6:	4a 4b       	lddpc	r11,80003864 <disk_init+0x10c>
800037d8:	30 0c       	mov	r12,0
800037da:	f0 1f 00 25 	mcall	8000386c <disk_init+0x114>
800037de:	30 6c       	mov	r12,6
		return fs_err;
800037e0:	c3 d8       	rjmp	8000385a <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
800037e2:	30 7a       	mov	r10,7
800037e4:	1a 9b       	mov	r11,sp
800037e6:	4a 8c       	lddpc	r12,80003884 <disk_init+0x12c>
800037e8:	f0 1f 00 28 	mcall	80003888 <disk_init+0x130>
800037ec:	c0 c0       	breq	80003804 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
800037ee:	4a 8c       	lddpc	r12,8000388c <disk_init+0x134>
800037f0:	f0 1f 00 28 	mcall	80003890 <disk_init+0x138>
800037f4:	c0 80       	breq	80003804 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
800037f6:	30 1a       	mov	r10,1
800037f8:	49 bb       	lddpc	r11,80003864 <disk_init+0x10c>
800037fa:	30 0c       	mov	r12,0
800037fc:	f0 1f 00 1c 	mcall	8000386c <disk_init+0x114>
80003800:	30 6c       	mov	r12,6
			return fs_err;
80003802:	c2 c8       	rjmp	8000385a <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003804:	49 8b       	lddpc	r11,80003864 <disk_init+0x10c>
80003806:	4a 4c       	lddpc	r12,80003894 <disk_init+0x13c>
80003808:	f0 1f 00 24 	mcall	80003898 <disk_init+0x140>
8000380c:	c2 11       	brne	8000384e <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
8000380e:	30 aa       	mov	r10,10
80003810:	4a 3b       	lddpc	r11,8000389c <disk_init+0x144>
80003812:	4a 4c       	lddpc	r12,800038a0 <disk_init+0x148>
80003814:	f0 1f 00 24 	mcall	800038a4 <disk_init+0x14c>
80003818:	c1 41       	brne	80003840 <disk_init+0xe8>
		{
			f_close(&fl);
8000381a:	4a 2c       	lddpc	r12,800038a0 <disk_init+0x148>
8000381c:	f0 1f 00 23 	mcall	800038a8 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003820:	4a 3c       	lddpc	r12,800038ac <disk_init+0x154>
80003822:	f0 1f 00 24 	mcall	800038b0 <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003826:	4a 4c       	lddpc	r12,800038b4 <disk_init+0x15c>
80003828:	f0 1f 00 22 	mcall	800038b0 <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
8000382c:	4a 3c       	lddpc	r12,800038b8 <disk_init+0x160>
8000382e:	f0 1f 00 21 	mcall	800038b0 <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003832:	30 1a       	mov	r10,1
80003834:	48 cb       	lddpc	r11,80003864 <disk_init+0x10c>
80003836:	30 0c       	mov	r12,0
80003838:	f0 1f 00 0d 	mcall	8000386c <disk_init+0x114>
8000383c:	30 0c       	mov	r12,0
	return fs_ok;
8000383e:	c0 e8       	rjmp	8000385a <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003840:	30 1a       	mov	r10,1
80003842:	48 9b       	lddpc	r11,80003864 <disk_init+0x10c>
80003844:	30 0c       	mov	r12,0
80003846:	f0 1f 00 0a 	mcall	8000386c <disk_init+0x114>
8000384a:	30 6c       	mov	r12,6
			return fs_err;
8000384c:	c0 78       	rjmp	8000385a <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
8000384e:	30 1a       	mov	r10,1
80003850:	48 5b       	lddpc	r11,80003864 <disk_init+0x10c>
80003852:	30 0c       	mov	r12,0
80003854:	f0 1f 00 06 	mcall	8000386c <disk_init+0x114>
80003858:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
8000385a:	2f dd       	sub	sp,-12
8000385c:	d8 02       	popm	pc
8000385e:	00 00       	add	r0,r0
80003860:	80 00       	ld.sh	r0,r0[0x0]
80003862:	34 c4       	mov	r4,76
80003864:	80 01       	ld.sh	r1,r0[0x0]
80003866:	03 c4       	ld.ub	r4,r1[0x4]
80003868:	00 00       	add	r0,r0
8000386a:	0a 70       	tst	r0,r5
8000386c:	80 00       	ld.sh	r0,r0[0x0]
8000386e:	6f a0       	ld.w	r0,r7[0x68]
80003870:	00 00       	add	r0,r0
80003872:	0d 44       	ld.w	r4,--r6
80003874:	00 00       	add	r0,r0
80003876:	0a 6c       	and	r12,r5
80003878:	80 00       	ld.sh	r0,r0[0x0]
8000387a:	81 20       	st.w	r0[0x8],r0
8000387c:	80 00       	ld.sh	r0,r0[0x0]
8000387e:	64 64       	ld.w	r4,r2[0x18]
80003880:	80 00       	ld.sh	r0,r0[0x0]
80003882:	76 9c       	ld.w	r12,r11[0x24]
80003884:	00 00       	add	r0,r0
80003886:	04 f4       	st.b	--r2,r4
80003888:	80 00       	ld.sh	r0,r0[0x0]
8000388a:	a3 14       	ld.d	r4,--r1
8000388c:	80 01       	ld.sh	r1,r0[0x0]
8000388e:	03 e4       	ld.ub	r4,r1[0x6]
80003890:	80 00       	ld.sh	r0,r0[0x0]
80003892:	77 e8       	ld.w	r8,r11[0x78]
80003894:	00 00       	add	r0,r0
80003896:	0c e0       	st.h	--r6,r0
80003898:	80 00       	ld.sh	r0,r0[0x0]
8000389a:	7d 30       	ld.w	r0,lr[0x4c]
8000389c:	80 01       	ld.sh	r1,r0[0x0]
8000389e:	03 ec       	ld.ub	r12,r1[0x6]
800038a0:	00 00       	add	r0,r0
800038a2:	0d 48       	ld.w	r8,--r6
800038a4:	80 00       	ld.sh	r0,r0[0x0]
800038a6:	7f 6c       	ld.w	r12,pc[0x58]
800038a8:	80 00       	ld.sh	r0,r0[0x0]
800038aa:	70 ec       	ld.w	r12,r8[0x38]
800038ac:	80 01       	ld.sh	r1,r0[0x0]
800038ae:	03 f4       	ld.ub	r4,r1[0x7]
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	7d b4       	ld.w	r4,lr[0x6c]
800038b4:	80 01       	ld.sh	r1,r0[0x0]
800038b6:	03 fc       	ld.ub	r12,r1[0x7]
800038b8:	80 01       	ld.sh	r1,r0[0x0]
800038ba:	04 08       	add	r8,r2

800038bc <fs_init>:
	}
	
}

fs_err_t fs_init(void)
{
800038bc:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
800038c0:	f0 1f 00 0d 	mcall	800038f4 <fs_init+0x38>
800038c4:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
800038c6:	c1 31       	brne	800038ec <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(50, sizeof(fl_oper_t)); //50*512bytes = 25k
800038c8:	30 8b       	mov	r11,8
800038ca:	33 2c       	mov	r12,50
800038cc:	f0 1f 00 0b 	mcall	800038f8 <fs_init+0x3c>
800038d0:	48 b8       	lddpc	r8,800038fc <fs_init+0x40>
800038d2:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
800038d4:	30 09       	mov	r9,0
800038d6:	1a d9       	st.w	--sp,r9
800038d8:	1a d9       	st.w	--sp,r9
800038da:	1a d9       	st.w	--sp,r9
800038dc:	30 28       	mov	r8,2
800038de:	e0 6a 02 00 	mov	r10,512
800038e2:	48 8b       	lddpc	r11,80003900 <fs_init+0x44>
800038e4:	48 8c       	lddpc	r12,80003904 <fs_init+0x48>
800038e6:	f0 1f 00 09 	mcall	80003908 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
800038ea:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
800038ec:	0e 9c       	mov	r12,r7
800038ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800038f2:	00 00       	add	r0,r0
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	37 58       	mov	r8,117
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	8e dc       	ld.uh	r12,r7[0xa]
800038fc:	00 00       	add	r0,r0
800038fe:	0d 40       	ld.w	r0,--r6
80003900:	80 01       	ld.sh	r1,r0[0x0]
80003902:	04 1c       	sub	r12,r2
80003904:	80 00       	ld.sh	r0,r0[0x0]
80003906:	36 e4       	mov	r4,110
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	95 b0       	st.w	r10[0x2c],r0

8000390c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000390c:	20 1c       	sub	r12,1
8000390e:	5c 5c       	castu.b	r12
80003910:	31 18       	mov	r8,17
80003912:	f0 0c 18 00 	cp.b	r12,r8
80003916:	e0 88 00 03 	brls	8000391c <CalculateBurst+0x10>
8000391a:	5e fd       	retal	0
8000391c:	48 28       	lddpc	r8,80003924 <CalculateBurst+0x18>
8000391e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003922:	5e fc       	retal	r12
80003924:	80 01       	ld.sh	r1,r0[0x0]
80003926:	04 34       	cp.w	r4,r2

80003928 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003928:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000392a:	48 98       	lddpc	r8,8000394c <payload_init+0x24>
8000392c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000392e:	48 98       	lddpc	r8,80003950 <payload_init+0x28>
80003930:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003932:	30 09       	mov	r9,0
80003934:	1a d9       	st.w	--sp,r9
80003936:	1a d9       	st.w	--sp,r9
80003938:	1a d9       	st.w	--sp,r9
8000393a:	30 28       	mov	r8,2
8000393c:	e0 6a 04 00 	mov	r10,1024
80003940:	48 5b       	lddpc	r11,80003954 <payload_init+0x2c>
80003942:	48 6c       	lddpc	r12,80003958 <payload_init+0x30>
80003944:	f0 1f 00 06 	mcall	8000395c <payload_init+0x34>
80003948:	2f dd       	sub	sp,-12
	
	
	
	
	
}
8000394a:	d8 02       	popm	pc
8000394c:	00 00       	add	r0,r0
8000394e:	0f 70       	ld.ub	r0,--r7
80003950:	00 00       	add	r0,r0
80003952:	0f 74       	ld.ub	r4,--r7
80003954:	80 01       	ld.sh	r1,r0[0x0]
80003956:	04 7c       	tst	r12,r2
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	39 60       	mov	r0,-106
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	95 b0       	st.w	r10[0x2c],r0

80003960 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003960:	eb cd 40 f8 	pushm	r3-r7,lr
80003964:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003966:	48 e8       	lddpc	r8,8000399c <payload_rx_process+0x3c>
80003968:	70 08       	ld.w	r8,r8[0x0]
8000396a:	58 08       	cp.w	r8,0
8000396c:	c0 71       	brne	8000397a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000396e:	30 4b       	mov	r11,4
80003970:	30 5c       	mov	r12,5
80003972:	f0 1f 00 0c 	mcall	800039a0 <payload_rx_process+0x40>
80003976:	48 a8       	lddpc	r8,8000399c <payload_rx_process+0x3c>
80003978:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000397a:	48 96       	lddpc	r6,8000399c <payload_rx_process+0x3c>
8000397c:	30 05       	mov	r5,0
8000397e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003980:	48 93       	lddpc	r3,800039a4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003982:	6c 0c       	ld.w	r12,r6[0x0]
80003984:	0a 99       	mov	r9,r5
80003986:	08 9a       	mov	r10,r4
80003988:	1a 9b       	mov	r11,sp
8000398a:	f0 1f 00 08 	mcall	800039a8 <payload_rx_process+0x48>
8000398e:	58 1c       	cp.w	r12,1
80003990:	cf 91       	brne	80003982 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003992:	66 08       	ld.w	r8,r3[0x0]
80003994:	40 0c       	lddsp	r12,sp[0x0]
80003996:	5d 18       	icall	r8
80003998:	cf 5b       	rjmp	80003982 <payload_rx_process+0x22>
8000399a:	00 00       	add	r0,r0
8000399c:	00 00       	add	r0,r0
8000399e:	0f 88       	ld.ub	r8,r7[0x0]
800039a0:	80 00       	ld.sh	r0,r0[0x0]
800039a2:	8e dc       	ld.uh	r12,r7[0xa]
800039a4:	00 00       	add	r0,r0
800039a6:	0f 70       	ld.ub	r0,--r7
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	8b 78       	st.w	r5[0x1c],r8

800039ac <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800039ac:	d4 01       	pushm	lr
800039ae:	20 2d       	sub	sp,8
800039b0:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800039b2:	30 09       	mov	r9,0
800039b4:	fa ca ff f8 	sub	r10,sp,-8
800039b8:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800039ba:	1a 9b       	mov	r11,sp
800039bc:	f0 1f 00 02 	mcall	800039c4 <set_idle_store_isr+0x18>
}
800039c0:	2f ed       	sub	sp,-8
800039c2:	d8 02       	popm	pc
800039c4:	80 00       	ld.sh	r0,r0[0x0]
800039c6:	8d 34       	st.w	r6[0xc],r4

800039c8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800039c8:	d4 01       	pushm	lr
800039ca:	20 2d       	sub	sp,8
800039cc:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800039ce:	58 0c       	cp.w	r12,0
800039d0:	c1 10       	breq	800039f2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800039d2:	30 08       	mov	r8,0
800039d4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800039d6:	98 88       	ld.uh	r8,r12[0x0]
800039d8:	e2 18 f0 00 	andl	r8,0xf000,COH
800039dc:	e0 48 40 00 	cp.w	r8,16384
800039e0:	c0 91       	brne	800039f2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800039e2:	48 68       	lddpc	r8,800039f8 <phy_rx+0x30>
800039e4:	70 0c       	ld.w	r12,r8[0x0]
800039e6:	30 09       	mov	r9,0
800039e8:	fa ca ff fc 	sub	r10,sp,-4
800039ec:	1a 9b       	mov	r11,sp
800039ee:	f0 1f 00 04 	mcall	800039fc <phy_rx+0x34>
		}	

    }
		
 
}
800039f2:	2f ed       	sub	sp,-8
800039f4:	d8 02       	popm	pc
800039f6:	00 00       	add	r0,r0
800039f8:	00 00       	add	r0,r0
800039fa:	0f c4       	ld.ub	r4,r7[0x4]
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	8d 34       	st.w	r6[0xc],r4

80003a00 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003a00:	eb cd 40 80 	pushm	r7,lr
80003a04:	20 1d       	sub	sp,4
80003a06:	fa c7 ff fc 	sub	r7,sp,-4
80003a0a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003a0c:	30 09       	mov	r9,0
80003a0e:	12 9a       	mov	r10,r9
80003a10:	1a 9b       	mov	r11,sp
80003a12:	f0 1f 00 03 	mcall	80003a1c <set_idle_store+0x1c>
}
80003a16:	2f fd       	sub	sp,-4
80003a18:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	8d 84       	st.w	r6[0x20],r4

80003a20 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003a20:	d4 01       	pushm	lr
80003a22:	20 1d       	sub	sp,4
80003a24:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003a26:	98 88       	ld.uh	r8,r12[0x0]
80003a28:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a2c:	e0 48 40 00 	cp.w	r8,16384
80003a30:	c0 d1       	brne	80003a4a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003a32:	49 08       	lddpc	r8,80003a70 <phy_tx+0x50>
80003a34:	70 08       	ld.w	r8,r8[0x0]
80003a36:	58 08       	cp.w	r8,0
80003a38:	c1 a0       	breq	80003a6c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003a3a:	48 e8       	lddpc	r8,80003a70 <phy_tx+0x50>
80003a3c:	70 0c       	ld.w	r12,r8[0x0]
80003a3e:	30 09       	mov	r9,0
80003a40:	12 9a       	mov	r10,r9
80003a42:	1a 9b       	mov	r11,sp
80003a44:	f0 1f 00 0c 	mcall	80003a74 <phy_tx+0x54>
80003a48:	c1 28       	rjmp	80003a6c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003a4a:	e0 48 10 00 	cp.w	r8,4096
80003a4e:	5f 0a       	sreq	r10
80003a50:	e0 48 20 00 	cp.w	r8,8192
80003a54:	5f 09       	sreq	r9
80003a56:	f5 e9 10 09 	or	r9,r10,r9
80003a5a:	c0 71       	brne	80003a68 <phy_tx+0x48>
80003a5c:	e0 48 50 00 	cp.w	r8,20480
80003a60:	c0 40       	breq	80003a68 <phy_tx+0x48>
80003a62:	e0 48 60 00 	cp.w	r8,24576
80003a66:	c0 31       	brne	80003a6c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003a68:	48 48       	lddpc	r8,80003a78 <phy_tx+0x58>
80003a6a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003a6c:	2f fd       	sub	sp,-4
80003a6e:	d8 02       	popm	pc
80003a70:	00 00       	add	r0,r0
80003a72:	0f d8       	ld.ub	r8,r7[0x5]
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	8d 84       	st.w	r6[0x20],r4
80003a78:	00 00       	add	r0,r0
80003a7a:	0f bc       	ld.ub	r12,r7[0x3]

80003a7c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003a7c:	d4 01       	pushm	lr
80003a7e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003a80:	30 08       	mov	r8,0
80003a82:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a84:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003a86:	1a 9a       	mov	r10,sp
80003a88:	fa cb ff fc 	sub	r11,sp,-4
80003a8c:	f0 1f 00 05 	mcall	80003aa0 <get_idle_store_isr+0x24>
80003a90:	58 1c       	cp.w	r12,1
80003a92:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003a96:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003a9a:	2f ed       	sub	sp,-8
80003a9c:	d8 02       	popm	pc
80003a9e:	00 00       	add	r0,r0
80003aa0:	80 00       	ld.sh	r0,r0[0x0]
80003aa2:	8a 88       	ld.uh	r8,r5[0x0]

80003aa4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003aa4:	eb cd 40 c0 	pushm	r6-r7,lr
80003aa8:	20 1d       	sub	sp,4
80003aaa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003aac:	fe f8 05 54 	ld.w	r8,pc[1364]
80003ab0:	70 08       	ld.w	r8,r8[0x0]
80003ab2:	58 08       	cp.w	r8,0
80003ab4:	c7 40       	breq	80003b9c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003ab6:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003ab8:	30 08       	mov	r8,0
80003aba:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003abc:	fe f8 05 48 	ld.w	r8,pc[1352]
80003ac0:	70 08       	ld.w	r8,r8[0x0]
80003ac2:	58 18       	cp.w	r8,1
80003ac4:	c2 90       	breq	80003b16 <phy_tx_func+0x72>
80003ac6:	c0 43       	brcs	80003ace <phy_tx_func+0x2a>
80003ac8:	58 28       	cp.w	r8,2
80003aca:	c6 91       	brne	80003b9c <phy_tx_func+0xf8>
80003acc:	c6 18       	rjmp	80003b8e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003ace:	fe f8 05 32 	ld.w	r8,pc[1330]
80003ad2:	70 0c       	ld.w	r12,r8[0x0]
80003ad4:	1a 9a       	mov	r10,sp
80003ad6:	fe fb 05 32 	ld.w	r11,pc[1330]
80003ada:	f0 1f 01 4d 	mcall	8000400c <phy_tx_func+0x568>
80003ade:	58 1c       	cp.w	r12,1
80003ae0:	c1 51       	brne	80003b0a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003ae2:	fe f8 05 26 	ld.w	r8,pc[1318]
80003ae6:	70 08       	ld.w	r8,r8[0x0]
80003ae8:	11 9a       	ld.ub	r10,r8[0x1]
80003aea:	fe f9 05 26 	ld.w	r9,pc[1318]
80003aee:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003af0:	90 88       	ld.uh	r8,r8[0x0]
80003af2:	ea 18 ab cd 	orh	r8,0xabcd
80003af6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003af8:	30 19       	mov	r9,1
80003afa:	fe f8 05 1a 	ld.w	r8,pc[1306]
80003afe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003b00:	30 19       	mov	r9,1
80003b02:	fe f8 05 02 	ld.w	r8,pc[1282]
80003b06:	91 09       	st.w	r8[0x0],r9
80003b08:	c4 a8       	rjmp	80003b9c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003b0a:	e0 68 5a 5a 	mov	r8,23130
80003b0e:	ea 18 ab cd 	orh	r8,0xabcd
80003b12:	8f 18       	st.w	r7[0x4],r8
80003b14:	c4 48       	rjmp	80003b9c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b16:	fe f9 04 fe 	ld.w	r9,pc[1278]
80003b1a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003b1c:	fe fa 04 ec 	ld.w	r10,pc[1260]
80003b20:	74 0a       	ld.w	r10,r10[0x0]
80003b22:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003b26:	b1 6a       	lsl	r10,0x10
80003b28:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b2a:	2f f8       	sub	r8,-1
80003b2c:	5c 58       	castu.b	r8
80003b2e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003b30:	fe fa 04 e0 	ld.w	r10,pc[1248]
80003b34:	94 09       	ld.sh	r9,r10[0x0]
80003b36:	20 29       	sub	r9,2
80003b38:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003b3a:	30 0a       	mov	r10,0
80003b3c:	f4 09 19 00 	cp.h	r9,r10
80003b40:	e0 89 00 0b 	brgt	80003b56 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003b44:	78 18       	ld.w	r8,r12[0x4]
80003b46:	e8 18 00 ba 	orl	r8,0xba
80003b4a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003b4c:	30 09       	mov	r9,0
80003b4e:	fe f8 04 b6 	ld.w	r8,pc[1206]
80003b52:	91 09       	st.w	r8[0x0],r9
80003b54:	c2 48       	rjmp	80003b9c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003b56:	fe f9 04 b2 	ld.w	r9,pc[1202]
80003b5a:	72 09       	ld.w	r9,r9[0x0]
80003b5c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003b60:	78 1a       	ld.w	r10,r12[0x4]
80003b62:	f5 e9 10 09 	or	r9,r10,r9
80003b66:	99 19       	st.w	r12[0x4],r9
80003b68:	2f f8       	sub	r8,-1
80003b6a:	fe f9 04 aa 	ld.w	r9,pc[1194]
80003b6e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003b70:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003b74:	92 08       	ld.sh	r8,r9[0x0]
80003b76:	20 28       	sub	r8,2
80003b78:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003b7a:	30 09       	mov	r9,0
80003b7c:	f2 08 19 00 	cp.h	r8,r9
80003b80:	e0 89 00 0e 	brgt	80003b9c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003b84:	30 29       	mov	r9,2
80003b86:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003b8a:	91 09       	st.w	r8[0x0],r9
80003b8c:	c0 88       	rjmp	80003b9c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003b8e:	fc 18 00 ba 	movh	r8,0xba
80003b92:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003b94:	30 09       	mov	r9,0
80003b96:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003b9a:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003b9c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003ba0:	11 89       	ld.ub	r9,r8[0x0]
80003ba2:	30 08       	mov	r8,0
80003ba4:	f0 09 18 00 	cp.b	r9,r8
80003ba8:	e0 80 00 c6 	breq	80003d34 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80003bac:	fe f8 04 70 	ld.w	r8,pc[1136]
80003bb0:	11 88       	ld.ub	r8,r8[0x0]
80003bb2:	30 19       	mov	r9,1
80003bb4:	f2 08 18 00 	cp.b	r8,r9
80003bb8:	c3 e0       	breq	80003c34 <phy_tx_func+0x190>
80003bba:	c0 73       	brcs	80003bc8 <phy_tx_func+0x124>
80003bbc:	30 29       	mov	r9,2
80003bbe:	f2 08 18 00 	cp.b	r8,r9
80003bc2:	e0 81 02 1b 	brne	80003ff8 <phy_tx_func+0x554>
80003bc6:	c9 28       	rjmp	80003cea <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003bc8:	fe f8 04 58 	ld.w	r8,pc[1112]
80003bcc:	70 08       	ld.w	r8,r8[0x0]
80003bce:	58 08       	cp.w	r8,0
80003bd0:	c0 b0       	breq	80003be6 <phy_tx_func+0x142>
80003bd2:	fe f8 04 4e 	ld.w	r8,pc[1102]
80003bd6:	70 08       	ld.w	r8,r8[0x0]
80003bd8:	58 98       	cp.w	r8,9
80003bda:	c0 60       	breq	80003be6 <phy_tx_func+0x142>
80003bdc:	fe f8 04 44 	ld.w	r8,pc[1092]
80003be0:	70 08       	ld.w	r8,r8[0x0]
80003be2:	58 18       	cp.w	r8,1
80003be4:	c0 a1       	brne	80003bf8 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003be6:	e0 68 5a 5a 	mov	r8,23130
80003bea:	ea 18 ab cd 	orh	r8,0xabcd
80003bee:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003bf0:	30 08       	mov	r8,0
80003bf2:	8f 38       	st.w	r7[0xc],r8
80003bf4:	e0 8f 02 02 	bral	80003ff8 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003bf8:	fe f8 04 28 	ld.w	r8,pc[1064]
80003bfc:	70 08       	ld.w	r8,r8[0x0]
80003bfe:	58 28       	cp.w	r8,2
80003c00:	c0 91       	brne	80003c12 <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003c02:	fe f8 04 22 	ld.w	r8,pc[1058]
80003c06:	70 09       	ld.w	r9,r8[0x0]
80003c08:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003c0a:	70 18       	ld.w	r8,r8[0x4]
80003c0c:	8f 38       	st.w	r7[0xc],r8
80003c0e:	e0 8f 01 f5 	bral	80003ff8 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
80003c12:	30 19       	mov	r9,1
80003c14:	fe f8 04 08 	ld.w	r8,pc[1032]
80003c18:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003c1a:	e0 68 c0 0e 	mov	r8,49166
80003c1e:	ea 18 ab cd 	orh	r8,0xabcd
80003c22:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003c24:	fe f8 04 04 	ld.w	r8,pc[1028]
80003c28:	90 09       	ld.sh	r9,r8[0x0]
80003c2a:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003c2c:	90 18       	ld.sh	r8,r8[0x2]
80003c2e:	ae 78       	st.h	r7[0xe],r8
80003c30:	e0 8f 01 e4 	bral	80003ff8 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003c34:	fe 78 88 f2 	mov	r8,-30478
80003c38:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//
80003c3a:	fe f8 03 e6 	ld.w	r8,pc[998]
80003c3e:	70 08       	ld.w	r8,r8[0x0]
80003c40:	58 38       	cp.w	r8,3
80003c42:	c0 60       	breq	80003c4e <phy_tx_func+0x1aa>
80003c44:	c4 73       	brcs	80003cd2 <phy_tx_func+0x22e>
80003c46:	58 88       	cp.w	r8,8
80003c48:	e0 8b 00 45 	brhi	80003cd2 <phy_tx_func+0x22e>
80003c4c:	c2 a8       	rjmp	80003ca0 <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003c4e:	fe f8 03 de 	ld.w	r8,pc[990]
80003c52:	11 89       	ld.ub	r9,r8[0x0]
80003c54:	30 18       	mov	r8,1
80003c56:	f0 09 18 00 	cp.b	r9,r8
80003c5a:	c0 a1       	brne	80003c6e <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003c5c:	fe f8 03 d4 	ld.w	r8,pc[980]
80003c60:	90 09       	ld.sh	r9,r8[0x0]
80003c62:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003c64:	90 19       	ld.sh	r9,r8[0x2]
80003c66:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003c68:	90 28       	ld.sh	r8,r8[0x4]
80003c6a:	ae 78       	st.h	r7[0xe],r8
80003c6c:	c1 48       	rjmp	80003c94 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003c6e:	fe f9 03 c6 	ld.w	r9,pc[966]
80003c72:	92 0b       	ld.sh	r11,r9[0x0]
80003c74:	fe f8 03 bc 	ld.w	r8,pc[956]
80003c78:	90 0a       	ld.sh	r10,r8[0x0]
80003c7a:	f7 ea 20 0a 	eor	r10,r11,r10
80003c7e:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003c80:	92 1b       	ld.sh	r11,r9[0x2]
80003c82:	90 1a       	ld.sh	r10,r8[0x2]
80003c84:	f7 ea 20 0a 	eor	r10,r11,r10
80003c88:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003c8a:	92 29       	ld.sh	r9,r9[0x4]
80003c8c:	90 28       	ld.sh	r8,r8[0x4]
80003c8e:	f3 e8 20 08 	eor	r8,r9,r8
80003c92:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80003c94:	30 29       	mov	r9,2
80003c96:	fe f8 03 86 	ld.w	r8,pc[902]
80003c9a:	b0 89       	st.b	r8[0x0],r9
80003c9c:	e0 8f 01 ae 	bral	80003ff8 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003ca0:	fe f9 03 94 	ld.w	r9,pc[916]
80003ca4:	92 0b       	ld.sh	r11,r9[0x0]
80003ca6:	fe f8 03 8a 	ld.w	r8,pc[906]
80003caa:	90 0a       	ld.sh	r10,r8[0x0]
80003cac:	f7 ea 20 0a 	eor	r10,r11,r10
80003cb0:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003cb2:	92 1b       	ld.sh	r11,r9[0x2]
80003cb4:	90 1a       	ld.sh	r10,r8[0x2]
80003cb6:	f7 ea 20 0a 	eor	r10,r11,r10
80003cba:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003cbc:	92 29       	ld.sh	r9,r9[0x4]
80003cbe:	90 28       	ld.sh	r8,r8[0x4]
80003cc0:	f3 e8 20 08 	eor	r8,r9,r8
80003cc4:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80003cc6:	30 29       	mov	r9,2
80003cc8:	fe f8 03 54 	ld.w	r8,pc[852]
80003ccc:	b0 89       	st.b	r8[0x0],r9
80003cce:	e0 8f 01 95 	bral	80003ff8 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003cd2:	e0 68 5a 5a 	mov	r8,23130
80003cd6:	ea 18 ab cd 	orh	r8,0xabcd
80003cda:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003cdc:	30 08       	mov	r8,0
80003cde:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
80003ce0:	fe f9 03 3c 	ld.w	r9,pc[828]
80003ce4:	b2 88       	st.b	r9[0x0],r8
80003ce6:	e0 8f 01 89 	bral	80003ff8 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80003cea:	fe f8 03 36 	ld.w	r8,pc[822]
80003cee:	70 08       	ld.w	r8,r8[0x0]
80003cf0:	58 38       	cp.w	r8,3
80003cf2:	c0 d1       	brne	80003d0c <phy_tx_func+0x268>
80003cf4:	fe f8 03 38 	ld.w	r8,pc[824]
80003cf8:	11 89       	ld.ub	r9,r8[0x0]
80003cfa:	30 18       	mov	r8,1
80003cfc:	f0 09 18 00 	cp.b	r9,r8
80003d00:	c0 61       	brne	80003d0c <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80003d02:	fe f8 03 2e 	ld.w	r8,pc[814]
80003d06:	90 38       	ld.sh	r8,r8[0x6]
80003d08:	ae 48       	st.h	r7[0x8],r8
80003d0a:	c0 a8       	rjmp	80003d1e <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80003d0c:	fe f8 03 28 	ld.w	r8,pc[808]
80003d10:	90 39       	ld.sh	r9,r8[0x6]
80003d12:	fe f8 03 1e 	ld.w	r8,pc[798]
80003d16:	90 38       	ld.sh	r8,r8[0x6]
80003d18:	f3 e8 20 08 	eor	r8,r9,r8
80003d1c:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
80003d1e:	e0 68 00 ba 	mov	r8,186
80003d22:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003d24:	30 08       	mov	r8,0
80003d26:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003d28:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80003d2a:	fe f9 02 f2 	ld.w	r9,pc[754]
80003d2e:	b2 88       	st.b	r9[0x0],r8
80003d30:	e0 8f 01 64 	bral	80003ff8 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80003d34:	fe f8 03 04 	ld.w	r8,pc[772]
80003d38:	70 08       	ld.w	r8,r8[0x0]
80003d3a:	e0 48 76 20 	cp.w	r8,30240
80003d3e:	f9 b8 02 00 	movhs	r8,0
80003d42:	fe f9 02 f6 	ld.w	r9,pc[758]
80003d46:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80003d48:	fe f8 02 f4 	ld.w	r8,pc[756]
80003d4c:	11 89       	ld.ub	r9,r8[0x0]
80003d4e:	30 18       	mov	r8,1
80003d50:	f0 09 18 00 	cp.b	r9,r8
80003d54:	c0 61       	brne	80003d60 <phy_tx_func+0x2bc>
80003d56:	fe f8 02 ea 	ld.w	r8,pc[746]
80003d5a:	70 09       	ld.w	r9,r8[0x0]
80003d5c:	2f f9       	sub	r9,-1
80003d5e:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80003d60:	fe f8 02 bc 	ld.w	r8,pc[700]
80003d64:	11 88       	ld.ub	r8,r8[0x0]
80003d66:	30 19       	mov	r9,1
80003d68:	f2 08 18 00 	cp.b	r8,r9
80003d6c:	c3 60       	breq	80003dd8 <phy_tx_func+0x334>
80003d6e:	c0 73       	brcs	80003d7c <phy_tx_func+0x2d8>
80003d70:	30 29       	mov	r9,2
80003d72:	f2 08 18 00 	cp.b	r8,r9
80003d76:	e0 81 01 3e 	brne	80003ff2 <phy_tx_func+0x54e>
80003d7a:	c7 c8       	rjmp	80003e72 <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003d7c:	e0 68 5a 5a 	mov	r8,23130
80003d80:	ea 18 ab cd 	orh	r8,0xabcd
80003d84:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003d86:	30 08       	mov	r8,0
80003d88:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80003d8a:	fe f8 02 b6 	ld.w	r8,pc[694]
80003d8e:	70 08       	ld.w	r8,r8[0x0]
80003d90:	e0 6b cc cd 	mov	r11,52429
80003d94:	ea 1b cc cc 	orh	r11,0xcccc
80003d98:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80003d9c:	f6 09 16 04 	lsr	r9,r11,0x4
80003da0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003da4:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80003da8:	c1 21       	brne	80003dcc <phy_tx_func+0x328>
80003daa:	58 08       	cp.w	r8,0
80003dac:	c1 00       	breq	80003dcc <phy_tx_func+0x328>
80003dae:	fe f8 02 8e 	ld.w	r8,pc[654]
80003db2:	11 89       	ld.ub	r9,r8[0x0]
80003db4:	30 18       	mov	r8,1
80003db6:	f0 09 18 00 	cp.b	r9,r8
80003dba:	c0 91       	brne	80003dcc <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
80003dbc:	10 99       	mov	r9,r8
80003dbe:	fe f8 02 5e 	ld.w	r8,pc[606]
80003dc2:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80003dc4:	30 09       	mov	r9,0
80003dc6:	fe f8 02 7e 	ld.w	r8,pc[638]
80003dca:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80003dcc:	fe f8 02 7c 	ld.w	r8,pc[636]
80003dd0:	70 09       	ld.w	r9,r8[0x0]
80003dd2:	2f f9       	sub	r9,-1
80003dd4:	91 09       	st.w	r8[0x0],r9
80003dd6:	c1 19       	rjmp	80003ff8 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80003dd8:	fe 78 ab cd 	mov	r8,-21555
80003ddc:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80003dde:	fe f8 02 66 	ld.w	r8,pc[614]
80003de2:	11 89       	ld.ub	r9,r8[0x0]
80003de4:	30 08       	mov	r8,0
80003de6:	f0 09 18 00 	cp.b	r9,r8
80003dea:	c1 b1       	brne	80003e20 <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
80003dec:	fe f8 02 60 	ld.w	r8,pc[608]
80003df0:	11 89       	ld.ub	r9,r8[0x0]
80003df2:	30 18       	mov	r8,1
80003df4:	f0 09 18 00 	cp.b	r9,r8
80003df8:	c0 91       	brne	80003e0a <phy_tx_func+0x366>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80003dfa:	32 c9       	mov	r9,44
80003dfc:	fe f8 02 54 	ld.w	r8,pc[596]
80003e00:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80003e02:	e0 68 10 2c 	mov	r8,4140
80003e06:	ae 58       	st.h	r7[0xa],r8
80003e08:	c0 88       	rjmp	80003e18 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80003e0a:	32 a9       	mov	r9,42
80003e0c:	fe f8 02 44 	ld.w	r8,pc[580]
80003e10:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80003e12:	e0 68 10 2a 	mov	r8,4138
80003e16:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80003e18:	30 19       	mov	r9,1
80003e1a:	fe f8 02 3a 	ld.w	r8,pc[570]
80003e1e:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80003e20:	fe f8 02 2c 	ld.w	r8,pc[556]
80003e24:	11 89       	ld.ub	r9,r8[0x0]
80003e26:	30 18       	mov	r8,1
80003e28:	f0 09 18 00 	cp.b	r9,r8
80003e2c:	c0 61       	brne	80003e38 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80003e2e:	30 18       	mov	r8,1
80003e30:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80003e32:	30 48       	mov	r8,4
80003e34:	ae 78       	st.h	r7[0xe],r8
80003e36:	c1 38       	rjmp	80003e5c <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80003e38:	30 08       	mov	r8,0
80003e3a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003e3c:	4f f8       	lddpc	r8,80004038 <phy_tx_func+0x594>
80003e3e:	70 09       	ld.w	r9,r8[0x0]
80003e40:	fe fa 02 18 	ld.w	r10,pc[536]
80003e44:	f4 09 00 0b 	add	r11,r10,r9
80003e48:	17 9b       	ld.ub	r11,r11[0x1]
80003e4a:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003e4e:	a9 69       	lsl	r9,0x8
80003e50:	f6 09 00 09 	add	r9,r11,r9
80003e54:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003e56:	70 09       	ld.w	r9,r8[0x0]
80003e58:	2f e9       	sub	r9,-2
80003e5a:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80003e5c:	4f d8       	lddpc	r8,80004050 <phy_tx_func+0x5ac>
80003e5e:	90 09       	ld.sh	r9,r8[0x0]
80003e60:	20 49       	sub	r9,4
80003e62:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80003e64:	30 29       	mov	r9,2
80003e66:	4e e8       	lddpc	r8,8000401c <phy_tx_func+0x578>
80003e68:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80003e6a:	30 09       	mov	r9,0
80003e6c:	4f c8       	lddpc	r8,8000405c <phy_tx_func+0x5b8>
80003e6e:	91 09       	st.w	r8[0x0],r9
80003e70:	cc 48       	rjmp	80003ff8 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80003e72:	4f 88       	lddpc	r8,80004050 <phy_tx_func+0x5ac>
80003e74:	90 09       	ld.sh	r9,r8[0x0]
80003e76:	30 08       	mov	r8,0
80003e78:	f0 09 19 00 	cp.h	r9,r8
80003e7c:	e0 89 00 12 	brgt	80003ea0 <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003e80:	4f 58       	lddpc	r8,80004054 <phy_tx_func+0x5b0>
80003e82:	11 89       	ld.ub	r9,r8[0x0]
80003e84:	30 08       	mov	r8,0
80003e86:	f0 09 18 00 	cp.b	r9,r8
80003e8a:	5f 09       	sreq	r9
80003e8c:	4e 48       	lddpc	r8,8000401c <phy_tx_func+0x578>
80003e8e:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80003e90:	e0 68 00 ba 	mov	r8,186
80003e94:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80003e96:	30 08       	mov	r8,0
80003e98:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003e9a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003e9c:	ae 78       	st.h	r7[0xe],r8
80003e9e:	ca d8       	rjmp	80003ff8 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003ea0:	4e b8       	lddpc	r8,8000404c <phy_tx_func+0x5a8>
80003ea2:	11 89       	ld.ub	r9,r8[0x0]
80003ea4:	30 18       	mov	r8,1
80003ea6:	f0 09 18 00 	cp.b	r9,r8
80003eaa:	c0 41       	brne	80003eb2 <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
80003eac:	30 08       	mov	r8,0
80003eae:	ae 48       	st.h	r7[0x8],r8
80003eb0:	c1 08       	rjmp	80003ed0 <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003eb2:	4e 28       	lddpc	r8,80004038 <phy_tx_func+0x594>
80003eb4:	70 09       	ld.w	r9,r8[0x0]
80003eb6:	4e 9a       	lddpc	r10,80004058 <phy_tx_func+0x5b4>
80003eb8:	f4 09 00 0b 	add	r11,r10,r9
80003ebc:	17 9b       	ld.ub	r11,r11[0x1]
80003ebe:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003ec2:	a9 69       	lsl	r9,0x8
80003ec4:	f6 09 00 09 	add	r9,r11,r9
80003ec8:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80003eca:	70 09       	ld.w	r9,r8[0x0]
80003ecc:	2f e9       	sub	r9,-2
80003ece:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
80003ed0:	4e 09       	lddpc	r9,80004050 <phy_tx_func+0x5ac>
80003ed2:	92 08       	ld.sh	r8,r9[0x0]
80003ed4:	20 28       	sub	r8,2
80003ed6:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003ed8:	30 09       	mov	r9,0
80003eda:	f2 08 19 00 	cp.h	r8,r9
80003ede:	e0 89 00 11 	brgt	80003f00 <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ee2:	4d d8       	lddpc	r8,80004054 <phy_tx_func+0x5b0>
80003ee4:	11 89       	ld.ub	r9,r8[0x0]
80003ee6:	30 08       	mov	r8,0
80003ee8:	f0 09 18 00 	cp.b	r9,r8
80003eec:	5f 09       	sreq	r9
80003eee:	4c c8       	lddpc	r8,8000401c <phy_tx_func+0x578>
80003ef0:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80003ef2:	e0 68 00 ba 	mov	r8,186
80003ef6:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003ef8:	30 08       	mov	r8,0
80003efa:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003efc:	ae 78       	st.h	r7[0xe],r8
80003efe:	c7 d8       	rjmp	80003ff8 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003f00:	4d 38       	lddpc	r8,8000404c <phy_tx_func+0x5a8>
80003f02:	11 89       	ld.ub	r9,r8[0x0]
80003f04:	30 18       	mov	r8,1
80003f06:	f0 09 18 00 	cp.b	r9,r8
80003f0a:	c0 41       	brne	80003f12 <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
80003f0c:	30 08       	mov	r8,0
80003f0e:	ae 58       	st.h	r7[0xa],r8
80003f10:	c1 08       	rjmp	80003f30 <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f12:	4c a8       	lddpc	r8,80004038 <phy_tx_func+0x594>
80003f14:	70 09       	ld.w	r9,r8[0x0]
80003f16:	4d 1a       	lddpc	r10,80004058 <phy_tx_func+0x5b4>
80003f18:	f4 09 00 0b 	add	r11,r10,r9
80003f1c:	17 9b       	ld.ub	r11,r11[0x1]
80003f1e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f22:	a9 69       	lsl	r9,0x8
80003f24:	f6 09 00 09 	add	r9,r11,r9
80003f28:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80003f2a:	70 09       	ld.w	r9,r8[0x0]
80003f2c:	2f e9       	sub	r9,-2
80003f2e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003f30:	4c 89       	lddpc	r9,80004050 <phy_tx_func+0x5ac>
80003f32:	92 08       	ld.sh	r8,r9[0x0]
80003f34:	20 28       	sub	r8,2
80003f36:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f38:	30 09       	mov	r9,0
80003f3a:	f2 08 19 00 	cp.h	r8,r9
80003f3e:	e0 89 00 10 	brgt	80003f5e <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f42:	4c 58       	lddpc	r8,80004054 <phy_tx_func+0x5b0>
80003f44:	11 89       	ld.ub	r9,r8[0x0]
80003f46:	30 08       	mov	r8,0
80003f48:	f0 09 18 00 	cp.b	r9,r8
80003f4c:	5f 09       	sreq	r9
80003f4e:	4b 48       	lddpc	r8,8000401c <phy_tx_func+0x578>
80003f50:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
80003f52:	e0 68 00 ba 	mov	r8,186
80003f56:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003f58:	30 08       	mov	r8,0
80003f5a:	ae 78       	st.h	r7[0xe],r8
80003f5c:	c4 e8       	rjmp	80003ff8 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003f5e:	4b c8       	lddpc	r8,8000404c <phy_tx_func+0x5a8>
80003f60:	11 89       	ld.ub	r9,r8[0x0]
80003f62:	30 18       	mov	r8,1
80003f64:	f0 09 18 00 	cp.b	r9,r8
80003f68:	c0 41       	brne	80003f70 <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80003f6a:	30 08       	mov	r8,0
80003f6c:	ae 68       	st.h	r7[0xc],r8
80003f6e:	c1 08       	rjmp	80003f8e <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f70:	4b 28       	lddpc	r8,80004038 <phy_tx_func+0x594>
80003f72:	70 09       	ld.w	r9,r8[0x0]
80003f74:	4b 9a       	lddpc	r10,80004058 <phy_tx_func+0x5b4>
80003f76:	f4 09 00 0b 	add	r11,r10,r9
80003f7a:	17 9b       	ld.ub	r11,r11[0x1]
80003f7c:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f80:	a9 69       	lsl	r9,0x8
80003f82:	f6 09 00 09 	add	r9,r11,r9
80003f86:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80003f88:	70 09       	ld.w	r9,r8[0x0]
80003f8a:	2f e9       	sub	r9,-2
80003f8c:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003f8e:	4b 19       	lddpc	r9,80004050 <phy_tx_func+0x5ac>
80003f90:	92 08       	ld.sh	r8,r9[0x0]
80003f92:	20 28       	sub	r8,2
80003f94:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f96:	30 09       	mov	r9,0
80003f98:	f2 08 19 00 	cp.h	r8,r9
80003f9c:	e0 89 00 0e 	brgt	80003fb8 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003fa0:	4a d8       	lddpc	r8,80004054 <phy_tx_func+0x5b0>
80003fa2:	11 89       	ld.ub	r9,r8[0x0]
80003fa4:	30 08       	mov	r8,0
80003fa6:	f0 09 18 00 	cp.b	r9,r8
80003faa:	5f 09       	sreq	r9
80003fac:	49 c8       	lddpc	r8,8000401c <phy_tx_func+0x578>
80003fae:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80003fb0:	e0 68 00 ba 	mov	r8,186
80003fb4:	ae 78       	st.h	r7[0xe],r8
80003fb6:	c2 18       	rjmp	80003ff8 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003fb8:	4a 58       	lddpc	r8,8000404c <phy_tx_func+0x5a8>
80003fba:	11 89       	ld.ub	r9,r8[0x0]
80003fbc:	30 18       	mov	r8,1
80003fbe:	f0 09 18 00 	cp.b	r9,r8
80003fc2:	c0 41       	brne	80003fca <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
80003fc4:	30 08       	mov	r8,0
80003fc6:	ae 78       	st.h	r7[0xe],r8
80003fc8:	c1 08       	rjmp	80003fe8 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003fca:	49 c8       	lddpc	r8,80004038 <phy_tx_func+0x594>
80003fcc:	70 09       	ld.w	r9,r8[0x0]
80003fce:	4a 3a       	lddpc	r10,80004058 <phy_tx_func+0x5b4>
80003fd0:	f4 09 00 0b 	add	r11,r10,r9
80003fd4:	17 9b       	ld.ub	r11,r11[0x1]
80003fd6:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003fda:	a9 69       	lsl	r9,0x8
80003fdc:	f6 09 00 09 	add	r9,r11,r9
80003fe0:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003fe2:	70 09       	ld.w	r9,r8[0x0]
80003fe4:	2f e9       	sub	r9,-2
80003fe6:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003fe8:	49 a8       	lddpc	r8,80004050 <phy_tx_func+0x5ac>
80003fea:	90 09       	ld.sh	r9,r8[0x0]
80003fec:	20 29       	sub	r9,2
80003fee:	b0 09       	st.h	r8[0x0],r9
80003ff0:	c0 48       	rjmp	80003ff8 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
80003ff2:	30 09       	mov	r9,0
80003ff4:	48 a8       	lddpc	r8,8000401c <phy_tx_func+0x578>
80003ff6:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003ff8:	2f fd       	sub	sp,-4
80003ffa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003ffe:	00 00       	add	r0,r0
80004000:	00 00       	add	r0,r0
80004002:	0f d8       	ld.ub	r8,r7[0x5]
80004004:	00 00       	add	r0,r0
80004006:	0f 9c       	ld.ub	r12,r7[0x1]
80004008:	00 00       	add	r0,r0
8000400a:	0f 78       	ld.ub	r8,--r7
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	8a 88       	ld.uh	r8,r5[0x0]
80004010:	00 00       	add	r0,r0
80004012:	0f c2       	ld.ub	r2,r7[0x4]
80004014:	00 00       	add	r0,r0
80004016:	0f b1       	ld.ub	r1,r7[0x3]
80004018:	00 00       	add	r0,r0
8000401a:	0a 44       	or	r4,r5
8000401c:	00 00       	add	r0,r0
8000401e:	0f b8       	ld.ub	r8,r7[0x3]
80004020:	00 00       	add	r0,r0
80004022:	0f 80       	ld.ub	r0,r7[0x0]
80004024:	00 00       	add	r0,r0
80004026:	0f a0       	ld.ub	r0,r7[0x2]
80004028:	00 00       	add	r0,r0
8000402a:	13 c4       	ld.ub	r4,r9[0x4]
8000402c:	00 00       	add	r0,r0
8000402e:	0a 4c       	or	r12,r5
80004030:	80 01       	ld.sh	r1,r0[0x0]
80004032:	04 2c       	rsub	r12,r2
80004034:	00 00       	add	r0,r0
80004036:	12 cc       	st.b	r9++,r12
80004038:	00 00       	add	r0,r0
8000403a:	0f 90       	ld.ub	r0,r7[0x1]
8000403c:	00 00       	add	r0,r0
8000403e:	0a 4d       	or	sp,r5
80004040:	00 00       	add	r0,r0
80004042:	0f dc       	ld.ub	r12,r7[0x5]
80004044:	00 00       	add	r0,r0
80004046:	0f b0       	ld.ub	r0,r7[0x3]
80004048:	00 00       	add	r0,r0
8000404a:	0f cc       	ld.ub	r12,r7[0x4]
8000404c:	00 00       	add	r0,r0
8000404e:	0a 54       	eor	r4,r5
80004050:	00 00       	add	r0,r0
80004052:	0f e8       	ld.ub	r8,r7[0x6]
80004054:	00 00       	add	r0,r0
80004056:	0f 84       	ld.ub	r4,r7[0x0]
80004058:	80 01       	ld.sh	r1,r0[0x0]
8000405a:	04 88       	andn	r8,r2
8000405c:	00 00       	add	r0,r0
8000405e:	0f ec       	ld.ub	r12,r7[0x6]

80004060 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80004060:	d4 01       	pushm	lr
80004062:	20 1d       	sub	sp,4
	void * ptr = NULL;
80004064:	30 0a       	mov	r10,0
80004066:	fa cb ff fc 	sub	r11,sp,-4
8000406a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
8000406c:	14 99       	mov	r9,r10
8000406e:	1a 9b       	mov	r11,sp
80004070:	f0 1f 00 05 	mcall	80004084 <get_idle_store+0x24>
80004074:	58 1c       	cp.w	r12,1
80004076:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000407a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000407e:	2f fd       	sub	sp,-4
80004080:	d8 02       	popm	pc
80004082:	00 00       	add	r0,r0
80004084:	80 00       	ld.sh	r0,r0[0x0]
80004086:	8b 78       	st.w	r5[0x1c],r8

80004088 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80004088:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
8000408c:	f0 1f 00 21 	mcall	80004110 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80004090:	4a 1b       	lddpc	r11,80004114 <phy_init+0x8c>
80004092:	4a 2c       	lddpc	r12,80004118 <phy_init+0x90>
80004094:	f0 1f 00 22 	mcall	8000411c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004098:	30 4b       	mov	r11,4
8000409a:	31 ec       	mov	r12,30
8000409c:	f0 1f 00 21 	mcall	80004120 <phy_init+0x98>
800040a0:	4a 18       	lddpc	r8,80004124 <phy_init+0x9c>
800040a2:	91 0c       	st.w	r8[0x0],r12
800040a4:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040a6:	10 96       	mov	r6,r8
800040a8:	4a 05       	lddpc	r5,80004128 <phy_init+0xa0>
800040aa:	6c 0c       	ld.w	r12,r6[0x0]
800040ac:	ea 07 00 0b 	add	r11,r5,r7
800040b0:	f0 1f 00 1f 	mcall	8000412c <phy_init+0xa4>
800040b4:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800040b8:	e0 47 1e 00 	cp.w	r7,7680
800040bc:	cf 71       	brne	800040aa <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800040be:	30 4b       	mov	r11,4
800040c0:	31 4c       	mov	r12,20
800040c2:	f0 1f 00 18 	mcall	80004120 <phy_init+0x98>
800040c6:	49 b8       	lddpc	r8,80004130 <phy_init+0xa8>
800040c8:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800040ca:	30 4b       	mov	r11,4
800040cc:	30 ac       	mov	r12,10
800040ce:	f0 1f 00 15 	mcall	80004120 <phy_init+0x98>
800040d2:	49 98       	lddpc	r8,80004134 <phy_init+0xac>
800040d4:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800040d6:	30 4b       	mov	r11,4
800040d8:	30 ac       	mov	r12,10
800040da:	f0 1f 00 12 	mcall	80004120 <phy_init+0x98>
800040de:	49 78       	lddpc	r8,80004138 <phy_init+0xb0>
800040e0:	91 0c       	st.w	r8[0x0],r12
800040e2:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800040e4:	10 96       	mov	r6,r8
800040e6:	49 65       	lddpc	r5,8000413c <phy_init+0xb4>
800040e8:	6c 0c       	ld.w	r12,r6[0x0]
800040ea:	ea 07 00 0b 	add	r11,r5,r7
800040ee:	f0 1f 00 10 	mcall	8000412c <phy_init+0xa4>
800040f2:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800040f6:	e0 47 14 00 	cp.w	r7,5120
800040fa:	cf 71       	brne	800040e8 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800040fc:	e0 6b 01 00 	mov	r11,256
80004100:	30 5c       	mov	r12,5
80004102:	f0 1f 00 08 	mcall	80004120 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80004106:	48 f8       	lddpc	r8,80004140 <phy_init+0xb8>
80004108:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000410a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000410e:	00 00       	add	r0,r0
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	4c dc       	lddpc	r12,80004244 <phy_rx_func+0xa0>
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	3a a4       	mov	r4,-86
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	41 a4       	lddsp	r4,sp[0x68]
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	4c c8       	lddpc	r8,8000424c <phy_rx_func+0xa8>
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	8e dc       	ld.uh	r12,r7[0xa]
80004124:	00 00       	add	r0,r0
80004126:	0f a8       	ld.ub	r8,r7[0x2]
80004128:	00 00       	add	r0,r0
8000412a:	27 c8       	sub	r8,124
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	3a 00       	mov	r0,-96
80004130:	00 00       	add	r0,r0
80004132:	0f d8       	ld.ub	r8,r7[0x5]
80004134:	00 00       	add	r0,r0
80004136:	0f c4       	ld.ub	r4,r7[0x4]
80004138:	00 00       	add	r0,r0
8000413a:	0f 98       	ld.ub	r8,r7[0x1]
8000413c:	00 00       	add	r0,r0
8000413e:	13 c8       	ld.ub	r8,r9[0x4]
80004140:	00 00       	add	r0,r0
80004142:	0f bc       	ld.ub	r12,r7[0x3]

80004144 <payload_rx>:




static void payload_rx(void * payload)
{
80004144:	d4 01       	pushm	lr
80004146:	20 2d       	sub	sp,8
80004148:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000414a:	30 08       	mov	r8,0
8000414c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000414e:	48 f8       	lddpc	r8,80004188 <payload_rx+0x44>
80004150:	70 08       	ld.w	r8,r8[0x0]
80004152:	58 08       	cp.w	r8,0
80004154:	c0 71       	brne	80004162 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80004156:	30 4b       	mov	r11,4
80004158:	30 5c       	mov	r12,5
8000415a:	f0 1f 00 0d 	mcall	8000418c <payload_rx+0x48>
8000415e:	48 b8       	lddpc	r8,80004188 <payload_rx+0x44>
80004160:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80004162:	48 a8       	lddpc	r8,80004188 <payload_rx+0x44>
80004164:	70 0c       	ld.w	r12,r8[0x0]
80004166:	30 09       	mov	r9,0
80004168:	fa ca ff fc 	sub	r10,sp,-4
8000416c:	1a 9b       	mov	r11,sp
8000416e:	f0 1f 00 09 	mcall	80004190 <payload_rx+0x4c>
80004172:	c0 91       	brne	80004184 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80004174:	48 88       	lddpc	r8,80004194 <payload_rx+0x50>
80004176:	70 0c       	ld.w	r12,r8[0x0]
80004178:	40 0b       	lddsp	r11,sp[0x0]
8000417a:	f0 1f 00 08 	mcall	80004198 <payload_rx+0x54>
		logFromISR("mm");
8000417e:	48 8c       	lddpc	r12,8000419c <payload_rx+0x58>
80004180:	f0 1f 00 08 	mcall	800041a0 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80004184:	2f ed       	sub	sp,-8
80004186:	d8 02       	popm	pc
80004188:	00 00       	add	r0,r0
8000418a:	0f 88       	ld.ub	r8,r7[0x0]
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	8e dc       	ld.uh	r12,r7[0xa]
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	8d 34       	st.w	r6[0xc],r4
80004194:	00 00       	add	r0,r0
80004196:	0f 98       	ld.ub	r8,r7[0x1]
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	39 ac       	mov	r12,-102
8000419c:	80 01       	ld.sh	r1,r0[0x0]
8000419e:	88 38       	ld.sh	r8,r4[0x6]
800041a0:	80 00       	ld.sh	r0,r0[0x0]
800041a2:	9b 00       	st.w	sp[0x0],r0

800041a4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800041a4:	eb cd 40 e0 	pushm	r5-r7,lr
800041a8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800041aa:	fe f8 09 7e 	ld.w	r8,pc[2430]
800041ae:	70 08       	ld.w	r8,r8[0x0]
800041b0:	58 08       	cp.w	r8,0
800041b2:	e0 80 01 05 	breq	800043bc <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800041b6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800041b8:	fe f8 09 74 	ld.w	r8,pc[2420]
800041bc:	70 09       	ld.w	r9,r8[0x0]
800041be:	2f f9       	sub	r9,-1
800041c0:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800041c2:	fe f8 09 6e 	ld.w	r8,pc[2414]
800041c6:	70 08       	ld.w	r8,r8[0x0]
800041c8:	58 18       	cp.w	r8,1
800041ca:	e0 80 00 84 	breq	800042d2 <phy_rx_func+0x12e>
800041ce:	c0 73       	brcs	800041dc <phy_rx_func+0x38>
800041d0:	58 28       	cp.w	r8,2
800041d2:	c5 b0       	breq	80004288 <phy_rx_func+0xe4>
800041d4:	58 38       	cp.w	r8,3
800041d6:	e0 81 00 f3 	brne	800043bc <phy_rx_func+0x218>
800041da:	cd 38       	rjmp	80004380 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800041dc:	e0 6a 5a 5a 	mov	r10,23130
800041e0:	ea 1a ab cd 	orh	r10,0xabcd
800041e4:	14 36       	cp.w	r6,r10
800041e6:	e0 80 00 eb 	breq	800043bc <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800041ea:	ec 08 16 10 	lsr	r8,r6,0x10
800041ee:	e0 48 ab cd 	cp.w	r8,43981
800041f2:	e0 81 00 e5 	brne	800043bc <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800041f6:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800041fa:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800041fe:	20 28       	sub	r8,2
80004200:	fe f9 09 34 	ld.w	r9,pc[2356]
80004204:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004206:	30 09       	mov	r9,0
80004208:	f2 08 19 00 	cp.h	r8,r9
8000420c:	e0 8a 00 d8 	brle	800043bc <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80004210:	fe f8 09 28 	ld.w	r8,pc[2344]
80004214:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80004216:	fe f8 09 26 	ld.w	r8,pc[2342]
8000421a:	70 0c       	ld.w	r12,r8[0x0]
8000421c:	f0 1f 02 49 	mcall	80004b40 <phy_rx_func+0x99c>
80004220:	fe f8 09 24 	ld.w	r8,pc[2340]
80004224:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80004226:	58 0c       	cp.w	r12,0
80004228:	e0 80 00 ca 	breq	800043bc <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000422c:	fe f8 09 0c 	ld.w	r8,pc[2316]
80004230:	90 09       	ld.sh	r9,r8[0x0]
80004232:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80004236:	2f f9       	sub	r9,-1
80004238:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000423a:	fe fa 09 0a 	ld.w	r10,pc[2314]
8000423e:	74 0a       	ld.w	r10,r10[0x0]
80004240:	fe fb 08 ec 	ld.w	r11,pc[2284]
80004244:	76 0b       	ld.w	r11,r11[0x0]
80004246:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000424a:	2f f9       	sub	r9,-1
8000424c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000424e:	e2 16 0f 00 	andl	r6,0xf00,COH
80004252:	e0 46 01 00 	cp.w	r6,256
80004256:	c0 c0       	breq	8000426e <phy_rx_func+0xca>
80004258:	e0 8b 00 05 	brhi	80004262 <phy_rx_func+0xbe>
8000425c:	58 06       	cp.w	r6,0
8000425e:	c0 80       	breq	8000426e <phy_rx_func+0xca>
80004260:	c0 c8       	rjmp	80004278 <phy_rx_func+0xd4>
80004262:	e0 46 02 00 	cp.w	r6,512
80004266:	c0 40       	breq	8000426e <phy_rx_func+0xca>
80004268:	e0 46 03 00 	cp.w	r6,768
8000426c:	c0 61       	brne	80004278 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000426e:	30 29       	mov	r9,2
80004270:	fe f8 08 c0 	ld.w	r8,pc[2240]
80004274:	91 09       	st.w	r8[0x0],r9
80004276:	ca 38       	rjmp	800043bc <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80004278:	fe f6 08 cc 	ld.w	r6,pc[2252]
8000427c:	6c 0c       	ld.w	r12,r6[0x0]
8000427e:	f0 1f 02 33 	mcall	80004b48 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;					
80004282:	30 08       	mov	r8,0
80004284:	8d 08       	st.w	r6[0x0],r8
80004286:	c9 b8       	rjmp	800043bc <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80004288:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000428c:	b1 86       	lsr	r6,0x10
8000428e:	14 06       	add	r6,r10
80004290:	fe f8 08 bc 	ld.w	r8,pc[2236]
80004294:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004296:	fe f8 08 a2 	ld.w	r8,pc[2210]
8000429a:	90 09       	ld.sh	r9,r8[0x0]
8000429c:	fe fb 08 a8 	ld.w	r11,pc[2216]
800042a0:	76 0b       	ld.w	r11,r11[0x0]
800042a2:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800042a6:	2f f9       	sub	r9,-1
800042a8:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800042aa:	fe f9 08 8a 	ld.w	r9,pc[2186]
800042ae:	92 08       	ld.sh	r8,r9[0x0]
800042b0:	20 28       	sub	r8,2
800042b2:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800042b4:	30 09       	mov	r9,0
800042b6:	f2 08 19 00 	cp.h	r8,r9
800042ba:	e0 8a 00 07 	brle	800042c8 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800042be:	30 19       	mov	r9,1
800042c0:	fe f8 08 70 	ld.w	r8,pc[2160]
800042c4:	91 09       	st.w	r8[0x0],r9
800042c6:	c7 b8       	rjmp	800043bc <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800042c8:	30 39       	mov	r9,3
800042ca:	fe f8 08 66 	ld.w	r8,pc[2150]
800042ce:	91 09       	st.w	r8[0x0],r9
800042d0:	c7 68       	rjmp	800043bc <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800042d2:	ec 0a 14 10 	asr	r10,r6,0x10
800042d6:	fe f8 08 76 	ld.w	r8,pc[2166]
800042da:	90 09       	ld.sh	r9,r8[0x0]
800042dc:	14 09       	add	r9,r10
800042de:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800042e0:	fe f9 08 58 	ld.w	r9,pc[2136]
800042e4:	92 08       	ld.sh	r8,r9[0x0]
800042e6:	fe fb 08 5e 	ld.w	r11,pc[2142]
800042ea:	76 0b       	ld.w	r11,r11[0x0]
800042ec:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800042f0:	2f f8       	sub	r8,-1
800042f2:	5c 88       	casts.h	r8
800042f4:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800042f6:	fe fa 08 3e 	ld.w	r10,pc[2110]
800042fa:	94 09       	ld.sh	r9,r10[0x0]
800042fc:	20 29       	sub	r9,2
800042fe:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80004300:	30 0a       	mov	r10,0
80004302:	f4 09 19 00 	cp.h	r9,r10
80004306:	e0 89 00 1f 	brgt	80004344 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000430a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000430e:	e0 46 00 ba 	cp.w	r6,186
80004312:	c0 d1       	brne	8000432c <phy_rx_func+0x188>
80004314:	fe f8 08 38 	ld.w	r8,pc[2104]
80004318:	90 09       	ld.sh	r9,r8[0x0]
8000431a:	f4 09 19 00 	cp.h	r9,r10
8000431e:	c0 71       	brne	8000432c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004320:	fe f8 08 24 	ld.w	r8,pc[2084]
80004324:	70 0c       	ld.w	r12,r8[0x0]
80004326:	f0 1f 02 0b 	mcall	80004b50 <phy_rx_func+0x9ac>
8000432a:	c0 88       	rjmp	8000433a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000432c:	fe f6 08 18 	ld.w	r6,pc[2072]
80004330:	6c 0c       	ld.w	r12,r6[0x0]
80004332:	f0 1f 02 06 	mcall	80004b48 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;
80004336:	30 08       	mov	r8,0
80004338:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000433a:	30 09       	mov	r9,0
8000433c:	fe f8 07 f4 	ld.w	r8,pc[2036]
80004340:	91 09       	st.w	r8[0x0],r9
80004342:	c3 d8       	rjmp	800043bc <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004344:	5c 86       	casts.h	r6
80004346:	fe f9 08 06 	ld.w	r9,pc[2054]
8000434a:	92 0a       	ld.sh	r10,r9[0x0]
8000434c:	0c 0a       	add	r10,r6
8000434e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004350:	fe f9 07 f4 	ld.w	r9,pc[2036]
80004354:	72 09       	ld.w	r9,r9[0x0]
80004356:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000435a:	2f f8       	sub	r8,-1
8000435c:	fe f9 07 dc 	ld.w	r9,pc[2012]
80004360:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80004362:	fe f9 07 d2 	ld.w	r9,pc[2002]
80004366:	92 08       	ld.sh	r8,r9[0x0]
80004368:	20 28       	sub	r8,2
8000436a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000436c:	30 09       	mov	r9,0
8000436e:	f2 08 19 00 	cp.h	r8,r9
80004372:	e0 89 00 25 	brgt	800043bc <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80004376:	30 39       	mov	r9,3
80004378:	fe f8 07 b8 	ld.w	r8,pc[1976]
8000437c:	91 09       	st.w	r8[0x0],r9
8000437e:	c1 f8       	rjmp	800043bc <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004380:	e6 16 00 ff 	andh	r6,0xff,COH
80004384:	fc 19 00 ba 	movh	r9,0xba
80004388:	12 36       	cp.w	r6,r9
8000438a:	c0 e1       	brne	800043a6 <phy_rx_func+0x202>
8000438c:	fe f8 07 c0 	ld.w	r8,pc[1984]
80004390:	90 09       	ld.sh	r9,r8[0x0]
80004392:	30 08       	mov	r8,0
80004394:	f0 09 19 00 	cp.h	r9,r8
80004398:	c0 71       	brne	800043a6 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000439a:	fe f8 07 aa 	ld.w	r8,pc[1962]
8000439e:	70 0c       	ld.w	r12,r8[0x0]
800043a0:	f0 1f 01 ec 	mcall	80004b50 <phy_rx_func+0x9ac>
800043a4:	c0 88       	rjmp	800043b4 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800043a6:	fe f6 07 9e 	ld.w	r6,pc[1950]
800043aa:	6c 0c       	ld.w	r12,r6[0x0]
800043ac:	f0 1f 01 e7 	mcall	80004b48 <phy_rx_func+0x9a4>
				phy_frame_ptr = NULL;
800043b0:	30 08       	mov	r8,0
800043b2:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800043b4:	30 09       	mov	r9,0
800043b6:	fe f8 07 7a 	ld.w	r8,pc[1914]
800043ba:	91 09       	st.w	r8[0x0],r9
	
	static U8 _flag = 1;//0xABCDC014_flag0
						//0xABCDC010_flag1
	
	
	if(is_first == FALSE)
800043bc:	fe f8 07 98 	ld.w	r8,pc[1944]
800043c0:	11 89       	ld.ub	r9,r8[0x0]
800043c2:	30 08       	mov	r8,0
800043c4:	f0 09 18 00 	cp.b	r9,r8
800043c8:	c0 d1       	brne	800043e2 <phy_rx_func+0x23e>
	{
		payload_ptr = get_payload_idle_isr();
800043ca:	fe f8 07 8e 	ld.w	r8,pc[1934]
800043ce:	70 0c       	ld.w	r12,r8[0x0]
800043d0:	f0 1f 01 dc 	mcall	80004b40 <phy_rx_func+0x99c>
800043d4:	fe f8 07 88 	ld.w	r8,pc[1928]
800043d8:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800043da:	30 19       	mov	r9,1
800043dc:	fe f8 07 78 	ld.w	r8,pc[1912]
800043e0:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800043e2:	fe f8 07 7e 	ld.w	r8,pc[1918]
800043e6:	70 08       	ld.w	r8,r8[0x0]
800043e8:	58 28       	cp.w	r8,2
800043ea:	e0 80 01 58 	breq	8000469a <phy_rx_func+0x4f6>
800043ee:	58 38       	cp.w	r8,3
800043f0:	e0 80 02 16 	breq	8000481c <phy_rx_func+0x678>
800043f4:	58 08       	cp.w	r8,0
800043f6:	e0 81 03 96 	brne	80004b22 <phy_rx_func+0x97e>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800043fa:	6e 28       	ld.w	r8,r7[0x8]
800043fc:	e0 6a 5a 5a 	mov	r10,23130
80004400:	ea 1a ab cd 	orh	r10,0xabcd
80004404:	14 38       	cp.w	r8,r10
80004406:	c0 71       	brne	80004414 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80004408:	30 09       	mov	r9,0
8000440a:	fe f8 07 5a 	ld.w	r8,pc[1882]
8000440e:	91 09       	st.w	r8[0x0],r9
80004410:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004414:	10 99       	mov	r9,r8
80004416:	e0 19 00 00 	andl	r9,0x0
8000441a:	fc 1a ab cd 	movh	r10,0xabcd
8000441e:	14 39       	cp.w	r9,r10
80004420:	e0 81 03 81 	brne	80004b22 <phy_rx_func+0x97e>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004424:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004428:	fe f9 07 40 	ld.w	r9,pc[1856]
8000442c:	93 08       	st.w	r9[0x0],r8
		
			if(NULL== payload_ptr)
8000442e:	fe f8 07 2e 	ld.w	r8,pc[1838]
80004432:	70 08       	ld.w	r8,r8[0x0]
80004434:	58 08       	cp.w	r8,0
80004436:	c0 c1       	brne	8000444e <phy_rx_func+0x2aa>
			{
				payload_ptr = get_payload_idle_isr();
80004438:	fe f8 07 20 	ld.w	r8,pc[1824]
8000443c:	70 0c       	ld.w	r12,r8[0x0]
8000443e:	f0 1f 01 c1 	mcall	80004b40 <phy_rx_func+0x99c>
80004442:	fe f8 07 1a 	ld.w	r8,pc[1818]
80004446:	91 0c       	st.w	r8[0x0],r12
				if(NULL== payload_ptr)
80004448:	58 0c       	cp.w	r12,0
8000444a:	e0 80 03 6c 	breq	80004b22 <phy_rx_func+0x97e>
				}
			}
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000444e:	6e 28       	ld.w	r8,r7[0x8]
80004450:	e2 18 f0 00 	andl	r8,0xf000,COH
80004454:	e0 48 c0 00 	cp.w	r8,49152
80004458:	e0 81 00 8e 	brne	80004574 <phy_rx_func+0x3d0>
			{
				AMBE_flag = 1;
8000445c:	30 19       	mov	r9,1
8000445e:	fe f8 07 0e 	ld.w	r8,pc[1806]
80004462:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
80004464:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004468:	fe f8 07 08 	ld.w	r8,pc[1800]
8000446c:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loopback Radio, as a reference.
8000446e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80004472:	fe f9 07 02 	ld.w	r9,pc[1794]
80004476:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
80004478:	11 89       	ld.ub	r9,r8[0x0]
8000447a:	3f 08       	mov	r8,-16
8000447c:	f0 09 18 00 	cp.b	r9,r8
80004480:	c2 b1       	brne	800044d6 <phy_rx_func+0x332>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80004482:	ef 38 00 0e 	ld.ub	r8,r7[14]
80004486:	e2 18 00 f0 	andl	r8,0xf0,COH
8000448a:	59 08       	cp.w	r8,16
8000448c:	c0 71       	brne	8000449a <phy_rx_func+0x2f6>
					{
						m_RxBurstType = VOICEHEADER;		
8000448e:	30 19       	mov	r9,1
80004490:	fe f8 06 d4 	ld.w	r8,pc[1748]
80004494:	91 09       	st.w	r8[0x0],r9
80004496:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000449a:	e0 48 00 20 	cp.w	r8,32
8000449e:	c1 61       	brne	800044ca <phy_rx_func+0x326>
					{
						m_RxBurstType = VOICETERMINATOR;
800044a0:	30 99       	mov	r9,9
800044a2:	fe f8 06 c2 	ld.w	r8,pc[1730]
800044a6:	91 09       	st.w	r8[0x0],r9
						//In order to complete the save data AMBE stream to SDcard.
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						RxMedia_IsFillingNext16 = 0;
800044a8:	30 09       	mov	r9,0
800044aa:	fe f8 06 ce 	ld.w	r8,pc[1742]
800044ae:	91 09       	st.w	r8[0x0],r9
						payload_rx(payload_ptr);//0
800044b0:	fe f7 06 ac 	ld.w	r7,pc[1708]
800044b4:	6e 0c       	ld.w	r12,r7[0x0]
800044b6:	f0 1f 01 b2 	mcall	80004b7c <phy_rx_func+0x9d8>
						payload_ptr = get_payload_idle_isr();
800044ba:	fe f8 06 9e 	ld.w	r8,pc[1694]
800044be:	70 0c       	ld.w	r12,r8[0x0]
800044c0:	f0 1f 01 a0 	mcall	80004b40 <phy_rx_func+0x99c>
800044c4:	8f 0c       	st.w	r7[0x0],r12
800044c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
800044ca:	30 09       	mov	r9,0
800044cc:	fe f8 06 98 	ld.w	r8,pc[1688]
800044d0:	91 09       	st.w	r8[0x0],r9
800044d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
800044d6:	fe f8 06 9a 	ld.w	r8,pc[1690]
800044da:	11 89       	ld.ub	r9,r8[0x0]
800044dc:	31 28       	mov	r8,18
800044de:	f0 09 18 00 	cp.b	r9,r8
800044e2:	c0 d1       	brne	800044fc <phy_rx_func+0x358>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
800044e4:	8e 69       	ld.sh	r9,r7[0xc]
800044e6:	fe f8 06 9a 	ld.w	r8,pc[1690]
800044ea:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
800044ec:	8e 79       	ld.sh	r9,r7[0xe]
800044ee:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
800044f0:	f0 1f 01 a5 	mcall	80004b84 <phy_rx_func+0x9e0>
800044f4:	fe f8 06 70 	ld.w	r8,pc[1648]
800044f8:	91 0c       	st.w	r8[0x0],r12
800044fa:	c3 78       	rjmp	80004568 <phy_rx_func+0x3c4>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
800044fc:	fe f8 06 74 	ld.w	r8,pc[1652]
80004500:	11 89       	ld.ub	r9,r8[0x0]
80004502:	30 48       	mov	r8,4
80004504:	f0 09 18 00 	cp.b	r9,r8
80004508:	c0 80       	breq	80004518 <phy_rx_func+0x374>
8000450a:	fe f8 06 66 	ld.w	r8,pc[1638]
8000450e:	11 89       	ld.ub	r9,r8[0x0]
80004510:	30 38       	mov	r8,3
80004512:	f0 09 18 00 	cp.b	r9,r8
80004516:	c1 c1       	brne	8000454e <phy_rx_func+0x3aa>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
80004518:	30 29       	mov	r9,2
8000451a:	fe f8 06 4a 	ld.w	r8,pc[1610]
8000451e:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
80004520:	6e 29       	ld.w	r9,r7[0x8]
80004522:	fe f8 06 66 	ld.w	r8,pc[1638]
80004526:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
80004528:	6e 39       	ld.w	r9,r7[0xc]
8000452a:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
8000452c:	fe f8 06 3c 	ld.w	r8,pc[1596]
80004530:	70 08       	ld.w	r8,r8[0x0]
80004532:	59 48       	cp.w	r8,20
80004534:	c0 61       	brne	80004540 <phy_rx_func+0x39c>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
80004536:	31 89       	mov	r9,24
80004538:	fe f8 06 30 	ld.w	r8,pc[1584]
8000453c:	91 09       	st.w	r8[0x0],r9
8000453e:	c1 58       	rjmp	80004568 <phy_rx_func+0x3c4>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
80004540:	59 08       	cp.w	r8,16
80004542:	c1 31       	brne	80004568 <phy_rx_func+0x3c4>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
80004544:	31 09       	mov	r9,16
80004546:	fe f8 06 22 	ld.w	r8,pc[1570]
8000454a:	91 09       	st.w	r8[0x0],r9
8000454c:	c0 e8       	rjmp	80004568 <phy_rx_func+0x3c4>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
8000454e:	8e e8       	ld.uh	r8,r7[0xc]
80004550:	1a d8       	st.w	--sp,r8
80004552:	fe fc 06 3a 	ld.w	r12,pc[1594]
80004556:	f0 1f 01 8f 	mcall	80004b90 <phy_rx_func+0x9ec>
					logFromISR("\n\r Axiba \n\r");
8000455a:	fe fc 06 3a 	ld.w	r12,pc[1594]
8000455e:	f0 1f 01 8d 	mcall	80004b90 <phy_rx_func+0x9ec>
80004562:	2f fd       	sub	sp,-4
80004564:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
80004568:	30 39       	mov	r9,3
8000456a:	fe f8 05 f6 	ld.w	r8,pc[1526]
8000456e:	91 09       	st.w	r8[0x0],r9
80004570:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80004574:	e0 48 10 00 	cp.w	r8,4096
80004578:	5f 19       	srne	r9
8000457a:	e0 48 20 00 	cp.w	r8,8192
8000457e:	5f 18       	srne	r8
80004580:	f3 e8 00 08 	and	r8,r9,r8
80004584:	e0 81 02 cf 	brne	80004b22 <phy_rx_func+0x97e>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
80004588:	fe f9 05 e4 	ld.w	r9,pc[1508]
8000458c:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
8000458e:	fe f9 05 e2 	ld.w	r9,pc[1506]
80004592:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004594:	6e 28       	ld.w	r8,r7[0x8]
80004596:	e2 18 0f 00 	andl	r8,0xf00,COH
8000459a:	58 18       	cp.w	r8,1
8000459c:	e0 8b 00 4d 	brhi	80004636 <phy_rx_func+0x492>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Frag type must process Array Discriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800045a0:	fe f9 05 c8 	ld.w	r9,pc[1480]
800045a4:	72 08       	ld.w	r8,r9[0x0]
800045a6:	20 48       	sub	r8,4
800045a8:	93 08       	st.w	r9[0x0],r8
800045aa:	e0 80 02 bc 	breq	80004b22 <phy_rx_func+0x97e>
				ArrayDiscLength = payload_rx_channel->word[2];
800045ae:	8e 68       	ld.sh	r8,r7[0xc]
800045b0:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800045b4:	fe f9 05 e4 	ld.w	r9,pc[1508]
800045b8:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
800045ba:	30 09       	mov	r9,0
800045bc:	f2 08 19 00 	cp.h	r8,r9
800045c0:	c0 70       	breq	800045ce <phy_rx_func+0x42a>
800045c2:	30 19       	mov	r9,1
800045c4:	f2 08 19 00 	cp.h	r8,r9
800045c8:	e0 81 02 ad 	brne	80004b22 <phy_rx_func+0x97e>
800045cc:	c2 68       	rjmp	80004618 <phy_rx_func+0x474>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800045ce:	fe f8 05 aa 	ld.w	r8,pc[1450]
800045d2:	70 0a       	ld.w	r10,r8[0x0]
800045d4:	fe f9 05 88 	ld.w	r9,pc[1416]
800045d8:	72 09       	ld.w	r9,r9[0x0]
800045da:	8e 7b       	ld.sh	r11,r7[0xe]
800045dc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800045e0:	70 09       	ld.w	r9,r8[0x0]
800045e2:	2f f9       	sub	r9,-1
800045e4:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800045e6:	e0 49 00 ff 	cp.w	r9,255
800045ea:	e0 88 00 11 	brls	8000460c <phy_rx_func+0x468>
						{
							RxMedia_IsFillingNext16 = 0;	
800045ee:	30 09       	mov	r9,0
800045f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
800045f2:	fe f7 05 6a 	ld.w	r7,pc[1386]
800045f6:	6e 0c       	ld.w	r12,r7[0x0]
800045f8:	f0 1f 01 61 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
800045fc:	fe f8 05 5c 	ld.w	r8,pc[1372]
80004600:	70 0c       	ld.w	r12,r8[0x0]
80004602:	f0 1f 01 50 	mcall	80004b40 <phy_rx_func+0x99c>
80004606:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004608:	e0 80 02 8d 	breq	80004b22 <phy_rx_func+0x97e>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000460c:	30 29       	mov	r9,2
8000460e:	fe f8 05 52 	ld.w	r8,pc[1362]
80004612:	91 09       	st.w	r8[0x0],r9
80004614:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004618:	8e 79       	ld.sh	r9,r7[0xe]
8000461a:	30 38       	mov	r8,3
8000461c:	f0 09 19 00 	cp.h	r9,r8
80004620:	c0 51       	brne	8000462a <phy_rx_func+0x486>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80004622:	30 19       	mov	r9,1
80004624:	fe f8 05 78 	ld.w	r8,pc[1400]
80004628:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000462a:	30 29       	mov	r9,2
8000462c:	fe f8 05 34 	ld.w	r8,pc[1332]
80004630:	91 09       	st.w	r8[0x0],r9
80004632:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80004636:	fe f8 05 32 	ld.w	r8,pc[1330]
8000463a:	70 08       	ld.w	r8,r8[0x0]
8000463c:	58 18       	cp.w	r8,1
8000463e:	e0 88 02 72 	brls	80004b22 <phy_rx_func+0x97e>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80004642:	fe f8 05 36 	ld.w	r8,pc[1334]
80004646:	70 0a       	ld.w	r10,r8[0x0]
80004648:	fe f9 05 14 	ld.w	r9,pc[1300]
8000464c:	72 09       	ld.w	r9,r9[0x0]
8000464e:	6e 3b       	ld.w	r11,r7[0xc]
80004650:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004654:	70 09       	ld.w	r9,r8[0x0]
80004656:	2f f9       	sub	r9,-1
80004658:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000465a:	e0 49 00 ff 	cp.w	r9,255
8000465e:	e0 88 00 11 	brls	80004680 <phy_rx_func+0x4dc>
				{
					RxMedia_IsFillingNext16 = 0;
80004662:	30 09       	mov	r9,0
80004664:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004666:	fe f7 04 f6 	ld.w	r7,pc[1270]
8000466a:	6e 0c       	ld.w	r12,r7[0x0]
8000466c:	f0 1f 01 44 	mcall	80004b7c <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80004670:	fe f8 04 e8 	ld.w	r8,pc[1256]
80004674:	70 0c       	ld.w	r12,r8[0x0]
80004676:	f0 1f 01 33 	mcall	80004b40 <phy_rx_func+0x99c>
8000467a:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
8000467c:	e0 80 02 53 	breq	80004b22 <phy_rx_func+0x97e>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80004680:	fe f9 04 e8 	ld.w	r9,pc[1256]
80004684:	72 08       	ld.w	r8,r9[0x0]
80004686:	20 28       	sub	r8,2
80004688:	93 08       	st.w	r9[0x0],r8
8000468a:	e0 80 02 4c 	breq	80004b22 <phy_rx_func+0x97e>
				RxMediaState = READINGMEDIA;
8000468e:	30 29       	mov	r9,2
80004690:	fe f8 04 d0 	ld.w	r8,pc[1232]
80004694:	91 09       	st.w	r8[0x0],r9
80004696:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000469a:	fe f8 04 de 	ld.w	r8,pc[1246]
8000469e:	70 0a       	ld.w	r10,r8[0x0]
800046a0:	fe f9 04 bc 	ld.w	r9,pc[1212]
800046a4:	72 09       	ld.w	r9,r9[0x0]
800046a6:	8e 4b       	ld.sh	r11,r7[0x8]
800046a8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800046ac:	70 09       	ld.w	r9,r8[0x0]
800046ae:	2f f9       	sub	r9,-1
800046b0:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800046b2:	e0 49 00 ff 	cp.w	r9,255
800046b6:	e0 88 00 16 	brls	800046e2 <phy_rx_func+0x53e>
					{
							RxMedia_IsFillingNext16 = 0;
800046ba:	30 09       	mov	r9,0
800046bc:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800046be:	fe f6 04 9e 	ld.w	r6,pc[1182]
800046c2:	6c 0c       	ld.w	r12,r6[0x0]
800046c4:	f0 1f 01 2e 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
800046c8:	fe f8 04 90 	ld.w	r8,pc[1168]
800046cc:	70 0c       	ld.w	r12,r8[0x0]
800046ce:	f0 1f 01 1d 	mcall	80004b40 <phy_rx_func+0x99c>
800046d2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
800046d4:	c0 71       	brne	800046e2 <phy_rx_func+0x53e>
							{
								RxMediaState = WAITINGABAB;
800046d6:	30 09       	mov	r9,0
800046d8:	fe f8 04 88 	ld.w	r8,pc[1160]
800046dc:	91 09       	st.w	r8[0x0],r9
800046de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
800046e2:	fe f9 04 86 	ld.w	r9,pc[1158]
800046e6:	72 08       	ld.w	r8,r9[0x0]
800046e8:	20 28       	sub	r8,2
800046ea:	93 08       	st.w	r9[0x0],r8
800046ec:	c0 71       	brne	800046fa <phy_rx_func+0x556>
				{
					RxMediaState = WAITINGABAB;
800046ee:	30 09       	mov	r9,0
800046f0:	fe f8 04 70 	ld.w	r8,pc[1136]
800046f4:	91 09       	st.w	r8[0x0],r9
800046f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800046fa:	fe f8 04 7e 	ld.w	r8,pc[1150]
800046fe:	70 0a       	ld.w	r10,r8[0x0]
80004700:	fe f9 04 5c 	ld.w	r9,pc[1116]
80004704:	72 09       	ld.w	r9,r9[0x0]
80004706:	8e 5b       	ld.sh	r11,r7[0xa]
80004708:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000470c:	70 09       	ld.w	r9,r8[0x0]
8000470e:	2f f9       	sub	r9,-1
80004710:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004712:	e0 49 00 ff 	cp.w	r9,255
80004716:	e0 88 00 16 	brls	80004742 <phy_rx_func+0x59e>
						{
							RxMedia_IsFillingNext16 = 0;
8000471a:	30 09       	mov	r9,0
8000471c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000471e:	fe f6 04 3e 	ld.w	r6,pc[1086]
80004722:	6c 0c       	ld.w	r12,r6[0x0]
80004724:	f0 1f 01 16 	mcall	80004b7c <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80004728:	fe f8 04 30 	ld.w	r8,pc[1072]
8000472c:	70 0c       	ld.w	r12,r8[0x0]
8000472e:	f0 1f 01 05 	mcall	80004b40 <phy_rx_func+0x99c>
80004732:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004734:	c0 71       	brne	80004742 <phy_rx_func+0x59e>
								{
									RxMediaState = WAITINGABAB;
80004736:	30 09       	mov	r9,0
80004738:	fe f8 04 28 	ld.w	r8,pc[1064]
8000473c:	91 09       	st.w	r8[0x0],r9
8000473e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004742:	fe f9 04 26 	ld.w	r9,pc[1062]
80004746:	72 08       	ld.w	r8,r9[0x0]
80004748:	20 28       	sub	r8,2
8000474a:	93 08       	st.w	r9[0x0],r8
8000474c:	c0 71       	brne	8000475a <phy_rx_func+0x5b6>
					RxMediaState = WAITINGABAB;
8000474e:	30 09       	mov	r9,0
80004750:	fe f8 04 10 	ld.w	r8,pc[1040]
80004754:	91 09       	st.w	r8[0x0],r9
80004756:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000475a:	fe f8 04 1e 	ld.w	r8,pc[1054]
8000475e:	70 0a       	ld.w	r10,r8[0x0]
80004760:	fe f9 03 fc 	ld.w	r9,pc[1020]
80004764:	72 09       	ld.w	r9,r9[0x0]
80004766:	8e 6b       	ld.sh	r11,r7[0xc]
80004768:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000476c:	70 09       	ld.w	r9,r8[0x0]
8000476e:	2f f9       	sub	r9,-1
80004770:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004772:	e0 49 00 ff 	cp.w	r9,255
80004776:	e0 88 00 16 	brls	800047a2 <phy_rx_func+0x5fe>
						{
							RxMedia_IsFillingNext16 = 0;
8000477a:	30 09       	mov	r9,0
8000477c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000477e:	fe f6 03 de 	ld.w	r6,pc[990]
80004782:	6c 0c       	ld.w	r12,r6[0x0]
80004784:	f0 1f 00 fe 	mcall	80004b7c <phy_rx_func+0x9d8>
									payload_ptr = get_payload_idle_isr();
80004788:	fe f8 03 d0 	ld.w	r8,pc[976]
8000478c:	70 0c       	ld.w	r12,r8[0x0]
8000478e:	f0 1f 00 ed 	mcall	80004b40 <phy_rx_func+0x99c>
80004792:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80004794:	c0 71       	brne	800047a2 <phy_rx_func+0x5fe>
									{
										RxMediaState = WAITINGABAB;
80004796:	30 09       	mov	r9,0
80004798:	fe f8 03 c8 	ld.w	r8,pc[968]
8000479c:	91 09       	st.w	r8[0x0],r9
8000479e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800047a2:	fe f9 03 c6 	ld.w	r9,pc[966]
800047a6:	72 08       	ld.w	r8,r9[0x0]
800047a8:	20 28       	sub	r8,2
800047aa:	93 08       	st.w	r9[0x0],r8
800047ac:	c0 71       	brne	800047ba <phy_rx_func+0x616>
					RxMediaState = WAITINGABAB;
800047ae:	30 09       	mov	r9,0
800047b0:	fe f8 03 b0 	ld.w	r8,pc[944]
800047b4:	91 09       	st.w	r8[0x0],r9
800047b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800047ba:	fe f8 03 be 	ld.w	r8,pc[958]
800047be:	70 0a       	ld.w	r10,r8[0x0]
800047c0:	fe f9 03 9c 	ld.w	r9,pc[924]
800047c4:	72 09       	ld.w	r9,r9[0x0]
800047c6:	8e 7b       	ld.sh	r11,r7[0xe]
800047c8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800047cc:	70 09       	ld.w	r9,r8[0x0]
800047ce:	2f f9       	sub	r9,-1
800047d0:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800047d2:	e0 49 00 ff 	cp.w	r9,255
800047d6:	e0 88 00 16 	brls	80004802 <phy_rx_func+0x65e>
						{
							RxMedia_IsFillingNext16 = 0;
800047da:	30 09       	mov	r9,0
800047dc:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800047de:	fe f7 03 7e 	ld.w	r7,pc[894]
800047e2:	6e 0c       	ld.w	r12,r7[0x0]
800047e4:	f0 1f 00 e6 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
800047e8:	fe f8 03 70 	ld.w	r8,pc[880]
800047ec:	70 0c       	ld.w	r12,r8[0x0]
800047ee:	f0 1f 00 d5 	mcall	80004b40 <phy_rx_func+0x99c>
800047f2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
800047f4:	c0 71       	brne	80004802 <phy_rx_func+0x65e>
							{
								RxMediaState = WAITINGABAB;
800047f6:	30 09       	mov	r9,0
800047f8:	fe f8 03 68 	ld.w	r8,pc[872]
800047fc:	91 09       	st.w	r8[0x0],r9
800047fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004802:	fe f9 03 66 	ld.w	r9,pc[870]
80004806:	72 08       	ld.w	r8,r9[0x0]
80004808:	20 28       	sub	r8,2
8000480a:	93 08       	st.w	r9[0x0],r8
8000480c:	e0 81 01 8b 	brne	80004b22 <phy_rx_func+0x97e>
					RxMediaState = WAITINGABAB;
80004810:	30 09       	mov	r9,0
80004812:	fe f8 03 4e 	ld.w	r8,pc[846]
80004816:	91 09       	st.w	r8[0x0],r9
80004818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000481c:	fe f8 03 54 	ld.w	r8,pc[852]
80004820:	11 89       	ld.ub	r9,r8[0x0]
80004822:	31 28       	mov	r8,18
80004824:	f0 09 18 00 	cp.b	r9,r8
80004828:	e0 81 00 b0 	brne	80004988 <phy_rx_func+0x7e4>
					{
						Item_ID = payload_rx_channel->byte[1];
8000482c:	ef 39 00 09 	ld.ub	r9,r7[9]
80004830:	fe f8 03 40 	ld.w	r8,pc[832]
80004834:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80004836:	11 89       	ld.ub	r9,r8[0x0]
80004838:	3f 28       	mov	r8,-14
8000483a:	f0 09 18 00 	cp.b	r9,r8
8000483e:	e0 81 00 a0 	brne	8000497e <phy_rx_func+0x7da>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004842:	6e 29       	ld.w	r9,r7[0x8]
80004844:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004848:	fe f8 03 20 	ld.w	r8,pc[800]
8000484c:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000484e:	8e 59       	ld.sh	r9,r7[0xa]
80004850:	fe f8 03 50 	ld.w	r8,pc[848]
80004854:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004856:	8e 69       	ld.sh	r9,r7[0xc]
80004858:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000485a:	8e 79       	ld.sh	r9,r7[0xe]
8000485c:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000485e:	fe f8 03 1a 	ld.w	r8,pc[794]
80004862:	70 0a       	ld.w	r10,r8[0x0]
80004864:	fe f9 02 f8 	ld.w	r9,pc[760]
80004868:	72 09       	ld.w	r9,r9[0x0]
8000486a:	8e 5b       	ld.sh	r11,r7[0xa]
8000486c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80004870:	70 09       	ld.w	r9,r8[0x0]
80004872:	2f f9       	sub	r9,-1
80004874:	91 09       	st.w	r8[0x0],r9
							
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004876:	e0 49 00 ff 	cp.w	r9,255
8000487a:	e0 88 00 16 	brls	800048a6 <phy_rx_func+0x702>
							{
								RxMedia_IsFillingNext16 = 0;
8000487e:	30 09       	mov	r9,0
80004880:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004882:	fe f6 02 da 	ld.w	r6,pc[730]
80004886:	6c 0c       	ld.w	r12,r6[0x0]
80004888:	f0 1f 00 bd 	mcall	80004b7c <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
8000488c:	fe f8 02 cc 	ld.w	r8,pc[716]
80004890:	70 0c       	ld.w	r12,r8[0x0]
80004892:	f0 1f 00 ac 	mcall	80004b40 <phy_rx_func+0x99c>
80004896:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004898:	c0 71       	brne	800048a6 <phy_rx_func+0x702>
								{
									RxMediaState = WAITINGABAB;
8000489a:	30 09       	mov	r9,0
8000489c:	fe f8 02 c4 	ld.w	r8,pc[708]
800048a0:	91 09       	st.w	r8[0x0],r9
800048a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
800048a6:	fe f9 02 c2 	ld.w	r9,pc[706]
800048aa:	72 08       	ld.w	r8,r9[0x0]
800048ac:	20 28       	sub	r8,2
800048ae:	93 08       	st.w	r9[0x0],r8
800048b0:	c0 71       	brne	800048be <phy_rx_func+0x71a>
								RxMediaState = WAITINGABAB;
800048b2:	30 09       	mov	r9,0
800048b4:	fe f8 02 ac 	ld.w	r8,pc[684]
800048b8:	91 09       	st.w	r8[0x0],r9
800048ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800048be:	fe f8 02 ba 	ld.w	r8,pc[698]
800048c2:	70 0a       	ld.w	r10,r8[0x0]
800048c4:	fe f9 02 98 	ld.w	r9,pc[664]
800048c8:	72 09       	ld.w	r9,r9[0x0]
800048ca:	8e 6b       	ld.sh	r11,r7[0xc]
800048cc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800048d0:	70 09       	ld.w	r9,r8[0x0]
800048d2:	2f f9       	sub	r9,-1
800048d4:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800048d6:	e0 49 00 ff 	cp.w	r9,255
800048da:	e0 88 00 16 	brls	80004906 <phy_rx_func+0x762>
							{
								RxMedia_IsFillingNext16 = 0;
800048de:	30 09       	mov	r9,0
800048e0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800048e2:	fe f6 02 7a 	ld.w	r6,pc[634]
800048e6:	6c 0c       	ld.w	r12,r6[0x0]
800048e8:	f0 1f 00 a5 	mcall	80004b7c <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800048ec:	fe f8 02 6c 	ld.w	r8,pc[620]
800048f0:	70 0c       	ld.w	r12,r8[0x0]
800048f2:	f0 1f 00 94 	mcall	80004b40 <phy_rx_func+0x99c>
800048f6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800048f8:	c0 71       	brne	80004906 <phy_rx_func+0x762>
								{
									RxMediaState = WAITINGABAB;
800048fa:	30 09       	mov	r9,0
800048fc:	fe f8 02 64 	ld.w	r8,pc[612]
80004900:	91 09       	st.w	r8[0x0],r9
80004902:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80004906:	fe f9 02 62 	ld.w	r9,pc[610]
8000490a:	72 08       	ld.w	r8,r9[0x0]
8000490c:	20 28       	sub	r8,2
8000490e:	93 08       	st.w	r9[0x0],r8
80004910:	c0 71       	brne	8000491e <phy_rx_func+0x77a>
								RxMediaState = WAITINGABAB;
80004912:	30 09       	mov	r9,0
80004914:	fe f8 02 4c 	ld.w	r8,pc[588]
80004918:	91 09       	st.w	r8[0x0],r9
8000491a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000491e:	fe f8 02 5a 	ld.w	r8,pc[602]
80004922:	70 0a       	ld.w	r10,r8[0x0]
80004924:	fe f9 02 38 	ld.w	r9,pc[568]
80004928:	72 09       	ld.w	r9,r9[0x0]
8000492a:	8e 7b       	ld.sh	r11,r7[0xe]
8000492c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80004930:	70 09       	ld.w	r9,r8[0x0]
80004932:	2f f9       	sub	r9,-1
80004934:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004936:	e0 49 00 ff 	cp.w	r9,255
8000493a:	e0 88 00 16 	brls	80004966 <phy_rx_func+0x7c2>
							{
								RxMedia_IsFillingNext16 = 0;
8000493e:	30 09       	mov	r9,0
80004940:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004942:	fe f7 02 1a 	ld.w	r7,pc[538]
80004946:	6e 0c       	ld.w	r12,r7[0x0]
80004948:	f0 1f 00 8d 	mcall	80004b7c <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
8000494c:	fe f8 02 0c 	ld.w	r8,pc[524]
80004950:	70 0c       	ld.w	r12,r8[0x0]
80004952:	f0 1f 00 7c 	mcall	80004b40 <phy_rx_func+0x99c>
80004956:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr)
80004958:	c0 71       	brne	80004966 <phy_rx_func+0x7c2>
								{
									RxMediaState = WAITINGABAB;
8000495a:	30 09       	mov	r9,0
8000495c:	fe f8 02 04 	ld.w	r8,pc[516]
80004960:	91 09       	st.w	r8[0x0],r9
80004962:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80004966:	fe f9 02 02 	ld.w	r9,pc[514]
8000496a:	72 08       	ld.w	r8,r9[0x0]
8000496c:	20 28       	sub	r8,2
8000496e:	93 08       	st.w	r9[0x0],r8
80004970:	e0 81 00 d9 	brne	80004b22 <phy_rx_func+0x97e>
								RxMediaState = WAITINGABAB;
80004974:	30 09       	mov	r9,0
80004976:	4f b8       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004978:	91 09       	st.w	r8[0x0],r9
8000497a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000497e:	30 09       	mov	r9,0
80004980:	4f 88       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004982:	91 09       	st.w	r8[0x0],r9
80004984:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004988:	4f a8       	lddpc	r8,80004b70 <phy_rx_func+0x9cc>
8000498a:	11 89       	ld.ub	r9,r8[0x0]
8000498c:	3f 28       	mov	r8,-14
8000498e:	f0 09 18 00 	cp.b	r9,r8
80004992:	e0 81 00 aa 	brne	80004ae6 <phy_rx_func+0x942>
					{
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004996:	8e 49       	ld.sh	r9,r7[0x8]
80004998:	fe f8 02 08 	ld.w	r8,pc[520]
8000499c:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000499e:	4f 78       	lddpc	r8,80004b78 <phy_rx_func+0x9d4>
800049a0:	70 0a       	ld.w	r10,r8[0x0]
800049a2:	4e f9       	lddpc	r9,80004b5c <phy_rx_func+0x9b8>
800049a4:	72 09       	ld.w	r9,r9[0x0]
800049a6:	8e 4b       	ld.sh	r11,r7[0x8]
800049a8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800049ac:	70 09       	ld.w	r9,r8[0x0]
800049ae:	2f f9       	sub	r9,-1
800049b0:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800049b2:	e0 49 00 ff 	cp.w	r9,255
800049b6:	e0 88 00 13 	brls	800049dc <phy_rx_func+0x838>
						{
							RxMedia_IsFillingNext16 = 0;
800049ba:	30 09       	mov	r9,0
800049bc:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800049be:	4e 86       	lddpc	r6,80004b5c <phy_rx_func+0x9b8>
800049c0:	6c 0c       	ld.w	r12,r6[0x0]
800049c2:	f0 1f 00 6f 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
800049c6:	4e 58       	lddpc	r8,80004b58 <phy_rx_func+0x9b4>
800049c8:	70 0c       	ld.w	r12,r8[0x0]
800049ca:	f0 1f 00 5e 	mcall	80004b40 <phy_rx_func+0x99c>
800049ce:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
800049d0:	c0 61       	brne	800049dc <phy_rx_func+0x838>
								RxMediaState = WAITINGABAB;
800049d2:	30 09       	mov	r9,0
800049d4:	4e 38       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
800049d6:	91 09       	st.w	r8[0x0],r9
800049d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				
						if ((RxBytesWaiting -= 2) <= 0)
800049dc:	4e 39       	lddpc	r9,80004b68 <phy_rx_func+0x9c4>
800049de:	72 08       	ld.w	r8,r9[0x0]
800049e0:	20 28       	sub	r8,2
800049e2:	93 08       	st.w	r9[0x0],r8
800049e4:	c0 61       	brne	800049f0 <phy_rx_func+0x84c>
						{
							RxMediaState = WAITINGABAB;
800049e6:	30 09       	mov	r9,0
800049e8:	4d e8       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
800049ea:	91 09       	st.w	r8[0x0],r9
800049ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						}
						
						/******************************
						*******************/
						//(49bits)This shouldn't happen, but must check.
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800049f0:	4e 28       	lddpc	r8,80004b78 <phy_rx_func+0x9d4>
800049f2:	70 0a       	ld.w	r10,r8[0x0]
800049f4:	4d a9       	lddpc	r9,80004b5c <phy_rx_func+0x9b8>
800049f6:	72 09       	ld.w	r9,r9[0x0]
800049f8:	8e 5b       	ld.sh	r11,r7[0xa]
800049fa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800049fe:	70 09       	ld.w	r9,r8[0x0]
80004a00:	2f f9       	sub	r9,-1
80004a02:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a04:	e0 49 00 ff 	cp.w	r9,255
80004a08:	e0 88 00 13 	brls	80004a2e <phy_rx_func+0x88a>
						{
							RxMedia_IsFillingNext16 = 0;
80004a0c:	30 09       	mov	r9,0
80004a0e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a10:	4d 36       	lddpc	r6,80004b5c <phy_rx_func+0x9b8>
80004a12:	6c 0c       	ld.w	r12,r6[0x0]
80004a14:	f0 1f 00 5a 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004a18:	4d 08       	lddpc	r8,80004b58 <phy_rx_func+0x9b4>
80004a1a:	70 0c       	ld.w	r12,r8[0x0]
80004a1c:	f0 1f 00 49 	mcall	80004b40 <phy_rx_func+0x99c>
80004a20:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80004a22:	c0 61       	brne	80004a2e <phy_rx_func+0x88a>
								RxMediaState = WAITINGABAB;
80004a24:	30 09       	mov	r9,0
80004a26:	4c f8       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004a28:	91 09       	st.w	r8[0x0],r9
80004a2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80004a2e:	4c f9       	lddpc	r9,80004b68 <phy_rx_func+0x9c4>
80004a30:	72 08       	ld.w	r8,r9[0x0]
80004a32:	20 28       	sub	r8,2
80004a34:	93 08       	st.w	r9[0x0],r8
80004a36:	c0 61       	brne	80004a42 <phy_rx_func+0x89e>
							RxMediaState = WAITINGABAB;
80004a38:	30 09       	mov	r9,0
80004a3a:	4c a8       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004a3c:	91 09       	st.w	r8[0x0],r9
80004a3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}

						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80004a42:	4c e8       	lddpc	r8,80004b78 <phy_rx_func+0x9d4>
80004a44:	70 0a       	ld.w	r10,r8[0x0]
80004a46:	4c 69       	lddpc	r9,80004b5c <phy_rx_func+0x9b8>
80004a48:	72 09       	ld.w	r9,r9[0x0]
80004a4a:	8e 6b       	ld.sh	r11,r7[0xc]
80004a4c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;							
80004a50:	70 09       	ld.w	r9,r8[0x0]
80004a52:	2f f9       	sub	r9,-1
80004a54:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a56:	e0 49 00 ff 	cp.w	r9,255
80004a5a:	e0 88 00 13 	brls	80004a80 <phy_rx_func+0x8dc>
						{
							RxMedia_IsFillingNext16 = 0;
80004a5e:	30 09       	mov	r9,0
80004a60:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a62:	4b f6       	lddpc	r6,80004b5c <phy_rx_func+0x9b8>
80004a64:	6c 0c       	ld.w	r12,r6[0x0]
80004a66:	f0 1f 00 46 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004a6a:	4b c8       	lddpc	r8,80004b58 <phy_rx_func+0x9b4>
80004a6c:	70 0c       	ld.w	r12,r8[0x0]
80004a6e:	f0 1f 00 35 	mcall	80004b40 <phy_rx_func+0x99c>
80004a72:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80004a74:	c0 61       	brne	80004a80 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80004a76:	30 09       	mov	r9,0
80004a78:	4b a8       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004a7a:	91 09       	st.w	r8[0x0],r9
80004a7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80004a80:	4b a9       	lddpc	r9,80004b68 <phy_rx_func+0x9c4>
80004a82:	72 08       	ld.w	r8,r9[0x0]
80004a84:	20 28       	sub	r8,2
80004a86:	93 08       	st.w	r9[0x0],r8
80004a88:	c0 61       	brne	80004a94 <phy_rx_func+0x8f0>
							RxMediaState = WAITINGABAB;
80004a8a:	30 09       	mov	r9,0
80004a8c:	4b 58       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004a8e:	91 09       	st.w	r8[0x0],r9
80004a90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
							
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004a94:	4b 98       	lddpc	r8,80004b78 <phy_rx_func+0x9d4>
80004a96:	70 0a       	ld.w	r10,r8[0x0]
80004a98:	4b 19       	lddpc	r9,80004b5c <phy_rx_func+0x9b8>
80004a9a:	72 09       	ld.w	r9,r9[0x0]
80004a9c:	8e 7b       	ld.sh	r11,r7[0xe]
80004a9e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004aa2:	70 09       	ld.w	r9,r8[0x0]
80004aa4:	2f f9       	sub	r9,-1
80004aa6:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004aa8:	e0 49 00 ff 	cp.w	r9,255
80004aac:	e0 88 00 13 	brls	80004ad2 <phy_rx_func+0x92e>
						{
							RxMedia_IsFillingNext16 = 0;
80004ab0:	30 09       	mov	r9,0
80004ab2:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004ab4:	4a a7       	lddpc	r7,80004b5c <phy_rx_func+0x9b8>
80004ab6:	6e 0c       	ld.w	r12,r7[0x0]
80004ab8:	f0 1f 00 31 	mcall	80004b7c <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004abc:	4a 78       	lddpc	r8,80004b58 <phy_rx_func+0x9b4>
80004abe:	70 0c       	ld.w	r12,r8[0x0]
80004ac0:	f0 1f 00 20 	mcall	80004b40 <phy_rx_func+0x99c>
80004ac4:	8f 0c       	st.w	r7[0x0],r12
							
							if(NULL == payload_ptr){
80004ac6:	c0 61       	brne	80004ad2 <phy_rx_func+0x92e>
								RxMediaState = WAITINGABAB;
80004ac8:	30 09       	mov	r9,0
80004aca:	4a 68       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004acc:	91 09       	st.w	r8[0x0],r9
80004ace:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80004ad2:	4a 69       	lddpc	r9,80004b68 <phy_rx_func+0x9c4>
80004ad4:	72 08       	ld.w	r8,r9[0x0]
80004ad6:	20 28       	sub	r8,2
80004ad8:	93 08       	st.w	r9[0x0],r8
80004ada:	c2 41       	brne	80004b22 <phy_rx_func+0x97e>
							RxMediaState = WAITINGABAB;
80004adc:	30 09       	mov	r9,0
80004ade:	4a 18       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004ae0:	91 09       	st.w	r8[0x0],r9
80004ae2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004ae6:	4a 38       	lddpc	r8,80004b70 <phy_rx_func+0x9cc>
80004ae8:	11 89       	ld.ub	r9,r8[0x0]
80004aea:	30 48       	mov	r8,4
80004aec:	f0 09 18 00 	cp.b	r9,r8
80004af0:	c0 70       	breq	80004afe <phy_rx_func+0x95a>
80004af2:	4a 08       	lddpc	r8,80004b70 <phy_rx_func+0x9cc>
80004af4:	11 89       	ld.ub	r9,r8[0x0]
80004af6:	30 38       	mov	r8,3
80004af8:	f0 09 18 00 	cp.b	r9,r8
80004afc:	c1 01       	brne	80004b1c <phy_rx_func+0x978>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004afe:	6e 29       	ld.w	r9,r7[0x8]
80004b00:	4a 28       	lddpc	r8,80004b88 <phy_rx_func+0x9e4>
80004b02:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004b04:	6e 39       	ld.w	r9,r7[0xc]
80004b06:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004b08:	49 89       	lddpc	r9,80004b68 <phy_rx_func+0x9c4>
80004b0a:	72 08       	ld.w	r8,r9[0x0]
80004b0c:	20 88       	sub	r8,8
80004b0e:	93 08       	st.w	r9[0x0],r8
80004b10:	c0 91       	brne	80004b22 <phy_rx_func+0x97e>
						{
					
							RxBytesWaiting = 0;
80004b12:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004b14:	49 39       	lddpc	r9,80004b60 <phy_rx_func+0x9bc>
80004b16:	93 08       	st.w	r9[0x0],r8
80004b18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004b1c:	30 09       	mov	r9,0
80004b1e:	49 18       	lddpc	r8,80004b60 <phy_rx_func+0x9bc>
80004b20:	91 09       	st.w	r8[0x0],r9
80004b22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b26:	00 00       	add	r0,r0
80004b28:	00 00       	add	r0,r0
80004b2a:	0f c4       	ld.ub	r4,r7[0x4]
80004b2c:	00 00       	add	r0,r0
80004b2e:	0f e0       	ld.ub	r0,r7[0x6]
80004b30:	00 00       	add	r0,r0
80004b32:	0f ac       	ld.ub	r12,r7[0x2]
80004b34:	00 00       	add	r0,r0
80004b36:	0f 94       	ld.ub	r4,r7[0x1]
80004b38:	00 00       	add	r0,r0
80004b3a:	0f 8e       	ld.ub	lr,r7[0x0]
80004b3c:	00 00       	add	r0,r0
80004b3e:	0f a8       	ld.ub	r8,r7[0x2]
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	3a 7c       	mov	r12,-89
80004b44:	00 00       	add	r0,r0
80004b46:	0f e4       	ld.ub	r4,r7[0x6]
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	8a 08       	ld.sh	r8,r5[0x0]
80004b4c:	00 00       	add	r0,r0
80004b4e:	0f c0       	ld.ub	r0,r7[0x4]
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	39 c8       	mov	r8,-100
80004b54:	00 00       	add	r0,r0
80004b56:	0f 8d       	ld.ub	sp,r7[0x0]
80004b58:	00 00       	add	r0,r0
80004b5a:	0f 98       	ld.ub	r8,r7[0x1]
80004b5c:	00 00       	add	r0,r0
80004b5e:	0f b4       	ld.ub	r4,r7[0x3]
80004b60:	00 00       	add	r0,r0
80004b62:	0f d4       	ld.ub	r4,r7[0x5]
80004b64:	00 00       	add	r0,r0
80004b66:	0f 80       	ld.ub	r0,r7[0x0]
80004b68:	00 00       	add	r0,r0
80004b6a:	0f 7c       	ld.ub	r12,--r7
80004b6c:	00 00       	add	r0,r0
80004b6e:	0a 44       	or	r4,r5
80004b70:	00 00       	add	r0,r0
80004b72:	0f 8c       	ld.ub	r12,r7[0x0]
80004b74:	00 00       	add	r0,r0
80004b76:	0a 4c       	or	r12,r5
80004b78:	00 00       	add	r0,r0
80004b7a:	0f c8       	ld.ub	r8,r7[0x4]
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	41 44       	lddsp	r4,sp[0x50]
80004b80:	00 00       	add	r0,r0
80004b82:	13 c4       	ld.ub	r4,r9[0x4]
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	39 0c       	mov	r12,-112
80004b88:	00 00       	add	r0,r0
80004b8a:	0f a0       	ld.ub	r0,r7[0x2]
80004b8c:	80 01       	ld.sh	r1,r0[0x0]
80004b8e:	88 3c       	ld.sh	r12,r4[0x6]
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	9b 00       	st.w	sp[0x0],r0
80004b94:	80 01       	ld.sh	r1,r0[0x0]
80004b96:	88 50       	ld.sh	r0,r4[0xa]
80004b98:	00 00       	add	r0,r0
80004b9a:	0f d0       	ld.ub	r0,r7[0x5]
80004b9c:	00 00       	add	r0,r0
80004b9e:	0a 55       	eor	r5,r5
80004ba0:	00 00       	add	r0,r0
80004ba2:	12 cc       	st.b	r9++,r12

80004ba4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004ba4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004ba6:	49 88       	lddpc	r8,80004c04 <pdca_int_handler+0x60>
80004ba8:	11 89       	ld.ub	r9,r8[0x0]
80004baa:	ec 19 00 01 	eorl	r9,0x1
80004bae:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004bb0:	11 89       	ld.ub	r9,r8[0x0]
80004bb2:	a5 69       	lsl	r9,0x4
80004bb4:	2f c9       	sub	r9,-4
80004bb6:	49 5a       	lddpc	r10,80004c08 <pdca_int_handler+0x64>
80004bb8:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004bba:	fe 7a 00 40 	mov	r10,-65472
80004bbe:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004bc0:	30 39       	mov	r9,3
80004bc2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004bc4:	11 8a       	ld.ub	r10,r8[0x0]
80004bc6:	a5 6a       	lsl	r10,0x4
80004bc8:	2f ca       	sub	r10,-4
80004bca:	49 18       	lddpc	r8,80004c0c <pdca_int_handler+0x68>
80004bcc:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004bce:	fe 78 00 00 	mov	r8,-65536
80004bd2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004bd4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004bd6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004bd8:	48 e8       	lddpc	r8,80004c10 <pdca_int_handler+0x6c>
80004bda:	70 08       	ld.w	r8,r8[0x0]
80004bdc:	58 08       	cp.w	r8,0
80004bde:	c0 70       	breq	80004bec <pdca_int_handler+0x48>
80004be0:	48 99       	lddpc	r9,80004c04 <pdca_int_handler+0x60>
80004be2:	13 89       	ld.ub	r9,r9[0x0]
80004be4:	a5 69       	lsl	r9,0x4
80004be6:	48 ac       	lddpc	r12,80004c0c <pdca_int_handler+0x68>
80004be8:	12 0c       	add	r12,r9
80004bea:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004bec:	48 a8       	lddpc	r8,80004c14 <pdca_int_handler+0x70>
80004bee:	70 08       	ld.w	r8,r8[0x0]
80004bf0:	58 08       	cp.w	r8,0
80004bf2:	c0 70       	breq	80004c00 <pdca_int_handler+0x5c>
80004bf4:	48 49       	lddpc	r9,80004c04 <pdca_int_handler+0x60>
80004bf6:	13 89       	ld.ub	r9,r9[0x0]
80004bf8:	a5 69       	lsl	r9,0x4
80004bfa:	48 4c       	lddpc	r12,80004c08 <pdca_int_handler+0x64>
80004bfc:	12 0c       	add	r12,r9
80004bfe:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004c00:	d4 02       	popm	lr
80004c02:	d6 03       	rete
80004c04:	00 00       	add	r0,r0
80004c06:	45 cc       	lddsp	r12,sp[0x170]
80004c08:	00 00       	add	r0,r0
80004c0a:	45 f4       	lddsp	r4,sp[0x17c]
80004c0c:	00 00       	add	r0,r0
80004c0e:	45 d4       	lddsp	r4,sp[0x174]
80004c10:	00 00       	add	r0,r0
80004c12:	0f f0       	ld.ub	r0,r7[0x7]
80004c14:	00 00       	add	r0,r0
80004c16:	0f f4       	ld.ub	r4,r7[0x7]

80004c18 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004c18:	fe 78 10 00 	mov	r8,-61440
80004c1c:	e0 69 0d c0 	mov	r9,3520
80004c20:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004c24:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004c28:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004c2c:	fe 78 34 00 	mov	r8,-52224
80004c30:	e0 69 80 00 	mov	r9,32768
80004c34:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004c36:	30 09       	mov	r9,0
80004c38:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004c3a:	e0 69 04 21 	mov	r9,1057
80004c3e:	ea 19 3f 20 	orh	r9,0x3f20
80004c42:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004c44:	e0 69 02 9f 	mov	r9,671
80004c48:	ea 19 01 00 	orh	r9,0x100
80004c4c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004c4e:	e0 6a 04 02 	mov	r10,1026
80004c52:	ea 1a 3f 20 	orh	r10,0x3f20
80004c56:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004c58:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004c5a:	5e fc       	retal	r12

80004c5c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004c5c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004c5e:	30 19       	mov	r9,1
80004c60:	49 78       	lddpc	r8,80004cbc <local_start_PDC+0x60>
80004c62:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004c64:	fe 78 00 00 	mov	r8,-65536
80004c68:	30 7b       	mov	r11,7
80004c6a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004c6c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004c6e:	49 59       	lddpc	r9,80004cc0 <local_start_PDC+0x64>
80004c70:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004c74:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004c76:	30 3a       	mov	r10,3
80004c78:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004c7a:	30 1c       	mov	r12,1
80004c7c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004c7e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004c80:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004c82:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004c84:	30 2c       	mov	r12,2
80004c86:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004c88:	48 f9       	lddpc	r9,80004cc4 <local_start_PDC+0x68>
80004c8a:	e0 68 5a 5a 	mov	r8,23130
80004c8e:	ea 18 ab cd 	orh	r8,0xabcd
80004c92:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004c94:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004c96:	30 0e       	mov	lr,0
80004c98:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004c9a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004c9c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004c9e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004ca0:	fe 78 00 40 	mov	r8,-65472
80004ca4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004ca6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004ca8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004cac:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004cae:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004cb0:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004cb2:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004cb4:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004cb6:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004cb8:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004cba:	d8 02       	popm	pc
80004cbc:	00 00       	add	r0,r0
80004cbe:	45 cc       	lddsp	r12,sp[0x170]
80004cc0:	00 00       	add	r0,r0
80004cc2:	45 d4       	lddsp	r4,sp[0x174]
80004cc4:	00 00       	add	r0,r0
80004cc6:	45 f4       	lddsp	r4,sp[0x17c]

80004cc8 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004cc8:	48 38       	lddpc	r8,80004cd4 <register_rx_tx_func+0xc>
80004cca:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004ccc:	48 38       	lddpc	r8,80004cd8 <register_rx_tx_func+0x10>
80004cce:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004cd0:	5e fc       	retal	r12
80004cd2:	00 00       	add	r0,r0
80004cd4:	00 00       	add	r0,r0
80004cd6:	0f f0       	ld.ub	r0,r7[0x7]
80004cd8:	00 00       	add	r0,r0
80004cda:	0f f4       	ld.ub	r4,r7[0x7]

80004cdc <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004cdc:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004cde:	fe 78 10 00 	mov	r8,-61440
80004ce2:	30 29       	mov	r9,2
80004ce4:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004ce8:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004cec:	10 99       	mov	r9,r8
80004cee:	f2 f8 01 60 	ld.w	r8,r9[352]
80004cf2:	e2 18 00 02 	andl	r8,0x2,COH
80004cf6:	cf c0       	breq	80004cee <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004cf8:	fe 79 10 00 	mov	r9,-61440
80004cfc:	f2 f8 01 60 	ld.w	r8,r9[352]
80004d00:	e2 18 00 02 	andl	r8,0x2,COH
80004d04:	cf c1       	brne	80004cfc <ssc_init+0x20>
				
    INTC_register_interrupt (
80004d06:	30 3a       	mov	r10,3
80004d08:	36 0b       	mov	r11,96
80004d0a:	48 bc       	lddpc	r12,80004d34 <ssc_init+0x58>
80004d0c:	f0 1f 00 0b 	mcall	80004d38 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004d10:	f0 1f 00 0b 	mcall	80004d3c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004d14:	f0 1f 00 0b 	mcall	80004d40 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004d18:	fe 79 00 00 	mov	r9,-65536
80004d1c:	30 18       	mov	r8,1
80004d1e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004d20:	fe 7a 00 40 	mov	r10,-65472
80004d24:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004d26:	e0 6b 01 01 	mov	r11,257
80004d2a:	fe 7a 34 00 	mov	r10,-52224
80004d2e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004d30:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004d32:	d8 02       	popm	pc
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	4b a4       	lddpc	r4,80004e1c <xcmp_opcode_not_supported+0x8>
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	58 94       	cp.w	r4,9
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	4c 18       	lddpc	r8,80004e40 <xcmp_exec_func+0x8>
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	4c 5c       	lddpc	r12,80004e54 <xcmp_exec_func+0x1c>

80004d44 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004d44:	48 28       	lddpc	r8,80004d4c <xcmp_register_app_list+0x8>
80004d46:	91 0c       	st.w	r8[0x0],r12
}
80004d48:	5e fc       	retal	r12
80004d4a:	00 00       	add	r0,r0
80004d4c:	00 00       	add	r0,r0
80004d4e:	46 14       	lddsp	r4,sp[0x184]

80004d50 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004d50:	eb cd 40 80 	pushm	r7,lr
80004d54:	fa cd 01 00 	sub	sp,sp,256
80004d58:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004d5a:	16 98       	mov	r8,r11
80004d5c:	2f 08       	sub	r8,-16
80004d5e:	af a8       	sbr	r8,0xe
80004d60:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004d62:	3f f8       	mov	r8,-1
80004d64:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004d66:	30 b9       	mov	r9,11
80004d68:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004d6a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004d6c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004d6e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d70:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004d72:	f6 ca ff fe 	sub	r10,r11,-2
80004d76:	18 9b       	mov	r11,r12
80004d78:	fa cc ff f0 	sub	r12,sp,-16
80004d7c:	f0 1f 00 05 	mcall	80004d90 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004d80:	2f e7       	sub	r7,-2
80004d82:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004d84:	1a 9c       	mov	r12,sp
80004d86:	f0 1f 00 04 	mcall	80004d94 <xcmp_tx+0x44>
}
80004d8a:	2c 0d       	sub	sp,-256
80004d8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	a3 3a       	mul	r10,r1
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	51 7c       	stdsp	sp[0x5c],r12

80004d98 <xcmp_audio_route_speaker>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_speaker(void)
{
80004d98:	d4 01       	pushm	lr
80004d9a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004d9e:	e0 68 04 14 	mov	r8,1044
80004da2:	ba 18       	st.h	sp[0x2],r8
		
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004da4:	fa c8 ff fc 	sub	r8,sp,-4
		
	ptr->Function = Routing_Func_Update_Source;
80004da8:	30 19       	mov	r9,1
80004daa:	b0 89       	st.b	r8[0x0],r9
		
		
	unsigned short NumberofRoutings =  2;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004dac:	30 0a       	mov	r10,0
80004dae:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004db0:	30 2a       	mov	r10,2
80004db2:	b0 aa       	st.b	r8[0x2],r10
		
	
	
	
	ptr->RoutingData[0].audioInput = IN_Pre_Speaker_Audio_Data;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
80004db4:	30 da       	mov	r10,13
80004db6:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;//OUT_Option_Board;//OUT_Microphone_Data;//
80004db8:	30 ca       	mov	r10,12
80004dba:	b0 ca       	st.b	r8[0x4],r10
	
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput =OUT_Option_Board;// OUT_Speaker;
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004dbc:	b0 da       	st.b	r8[0x5],r10
	ptr->RoutingData[1].audioOutput = OUT_Speaker;//OUT_Microphone_Data;//
80004dbe:	b0 e9       	st.b	r8[0x6],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004dc0:	30 7b       	mov	r11,7
80004dc2:	fa cc ff fe 	sub	r12,sp,-2
80004dc6:	f0 1f 00 03 	mcall	80004dd0 <xcmp_audio_route_speaker+0x38>
}
80004dca:	2c dd       	sub	sp,-204
80004dcc:	d8 02       	popm	pc
80004dce:	00 00       	add	r0,r0
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	4d 50       	lddpc	r0,80004f24 <xcmp_rx_process+0x50>

80004dd4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004dd4:	d4 01       	pushm	lr
80004dd6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004dda:	fe 78 b4 00 	mov	r8,-19456
80004dde:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004de0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80004de4:	30 89       	mov	r9,8
80004de6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004de8:	30 19       	mov	r9,1
80004dea:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004dec:	30 09       	mov	r9,0
80004dee:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004df0:	30 5a       	mov	r10,5
80004df2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004df4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004df6:	30 7a       	mov	r10,7
80004df8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004dfa:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004dfc:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004dfe:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004e02:	30 9b       	mov	r11,9
80004e04:	fa cc ff fe 	sub	r12,sp,-2
80004e08:	f0 1f 00 02 	mcall	80004e10 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004e0c:	2c dd       	sub	sp,-204
80004e0e:	d8 02       	popm	pc
80004e10:	80 00       	ld.sh	r0,r0[0x0]
80004e12:	4d 50       	lddpc	r0,80004f64 <xcmp_rx_process+0x90>

80004e14 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004e14:	d4 01       	pushm	lr
80004e16:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004e1a:	fe 78 80 00 	mov	r8,-32768
80004e1e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004e20:	30 38       	mov	r8,3
80004e22:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004e24:	30 1b       	mov	r11,1
80004e26:	fa cc ff fe 	sub	r12,sp,-2
80004e2a:	f0 1f 00 03 	mcall	80004e34 <xcmp_opcode_not_supported+0x20>
}
80004e2e:	2c dd       	sub	sp,-204
80004e30:	d8 02       	popm	pc
80004e32:	00 00       	add	r0,r0
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	4d 50       	lddpc	r0,80004f88 <xcmp_rx_process+0xb4>

80004e38 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004e38:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004e3a:	96 88       	ld.uh	r8,r11[0x0]
80004e3c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004e40:	e0 48 80 00 	cp.w	r8,32768
80004e44:	c0 f0       	breq	80004e62 <xcmp_exec_func+0x2a>
80004e46:	e0 48 b0 00 	cp.w	r8,45056
80004e4a:	c1 20       	breq	80004e6e <xcmp_exec_func+0x36>
80004e4c:	58 08       	cp.w	r8,0
80004e4e:	c1 51       	brne	80004e78 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004e50:	78 08       	ld.w	r8,r12[0x0]
80004e52:	58 08       	cp.w	r8,0
80004e54:	c0 40       	breq	80004e5c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004e56:	16 9c       	mov	r12,r11
80004e58:	5d 18       	icall	r8
80004e5a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004e5c:	f0 1f 00 08 	mcall	80004e7c <xcmp_exec_func+0x44>
80004e60:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004e62:	78 18       	ld.w	r8,r12[0x4]
80004e64:	58 08       	cp.w	r8,0
80004e66:	c0 90       	breq	80004e78 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004e68:	16 9c       	mov	r12,r11
80004e6a:	5d 18       	icall	r8
80004e6c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004e6e:	78 28       	ld.w	r8,r12[0x8]
80004e70:	58 08       	cp.w	r8,0
80004e72:	c0 30       	breq	80004e78 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004e74:	16 9c       	mov	r12,r11
80004e76:	5d 18       	icall	r8
80004e78:	d8 02       	popm	pc
80004e7a:	00 00       	add	r0,r0
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4e 14       	lddpc	r4,80005000 <xcmp_rx+0x30>

80004e80 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004e80:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004e82:	f0 1f 00 0d 	mcall	80004eb4 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004e86:	48 dc       	lddpc	r12,80004eb8 <xcmp_init+0x38>
80004e88:	f0 1f 00 0d 	mcall	80004ebc <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004e8c:	30 4b       	mov	r11,4
80004e8e:	31 4c       	mov	r12,20
80004e90:	f0 1f 00 0c 	mcall	80004ec0 <xcmp_init+0x40>
80004e94:	48 c8       	lddpc	r8,80004ec4 <xcmp_init+0x44>
80004e96:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004e98:	30 09       	mov	r9,0
80004e9a:	1a d9       	st.w	--sp,r9
80004e9c:	1a d9       	st.w	--sp,r9
80004e9e:	1a d9       	st.w	--sp,r9
80004ea0:	30 38       	mov	r8,3
80004ea2:	e0 6a 01 80 	mov	r10,384
80004ea6:	48 9b       	lddpc	r11,80004ec8 <xcmp_init+0x48>
80004ea8:	48 9c       	lddpc	r12,80004ecc <xcmp_init+0x4c>
80004eaa:	f0 1f 00 0a 	mcall	80004ed0 <xcmp_init+0x50>
80004eae:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004eb0:	d8 02       	popm	pc
80004eb2:	00 00       	add	r0,r0
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	52 60       	stdsp	sp[0x98],r0
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	4f d0       	lddpc	r0,800050ac <xnl_tx_process+0x58>
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	50 1c       	stdsp	sp[0x4],r12
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	8e dc       	ld.uh	r12,r7[0xa]
80004ec4:	00 00       	add	r0,r0
80004ec6:	10 04       	add	r4,r8
80004ec8:	80 01       	ld.sh	r1,r0[0x0]
80004eca:	88 5c       	ld.sh	r12,r4[0xa]
80004ecc:	80 00       	ld.sh	r0,r0[0x0]
80004ece:	4e d4       	lddpc	r4,80005080 <xnl_tx_process+0x2c>
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	95 b0       	st.w	r10[0x2c],r0

80004ed4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004ed4:	d4 31       	pushm	r0-r7,lr
80004ed6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80004ed8:	4b 16       	lddpc	r6,80004f9c <xcmp_rx_process+0xc8>
80004eda:	30 05       	mov	r5,0
80004edc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004ede:	4b 13       	lddpc	r3,80004fa0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004ee0:	4b 12       	lddpc	r2,80004fa4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004ee2:	4b 21       	lddpc	r1,80004fa8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004ee4:	4b 20       	lddpc	r0,80004fac <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80004ee6:	6c 0c       	ld.w	r12,r6[0x0]
80004ee8:	0a 99       	mov	r9,r5
80004eea:	08 9a       	mov	r10,r4
80004eec:	1a 9b       	mov	r11,sp
80004eee:	f0 1f 00 31 	mcall	80004fb0 <xcmp_rx_process+0xdc>
80004ef2:	58 1c       	cp.w	r12,1
80004ef4:	cf 91       	brne	80004ee6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004ef6:	40 0b       	lddsp	r11,sp[0x0]
80004ef8:	58 0b       	cp.w	r11,0
80004efa:	cf 60       	breq	80004ee6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004efc:	96 0a       	ld.sh	r10,r11[0x0]
80004efe:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004f02:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004f06:	59 c8       	cp.w	r8,28
80004f08:	c1 e0       	breq	80004f44 <xcmp_rx_process+0x70>
80004f0a:	e0 89 00 07 	brgt	80004f18 <xcmp_rx_process+0x44>
80004f0e:	58 e8       	cp.w	r8,14
80004f10:	c0 e0       	breq	80004f2c <xcmp_rx_process+0x58>
80004f12:	58 f8       	cp.w	r8,15
80004f14:	c2 41       	brne	80004f5c <xcmp_rx_process+0x88>
80004f16:	c0 f8       	rjmp	80004f34 <xcmp_rx_process+0x60>
80004f18:	e0 48 01 09 	cp.w	r8,265
80004f1c:	c1 80       	breq	80004f4c <xcmp_rx_process+0x78>
80004f1e:	e0 48 01 0a 	cp.w	r8,266
80004f22:	c1 90       	breq	80004f54 <xcmp_rx_process+0x80>
80004f24:	e0 48 00 2c 	cp.w	r8,44
80004f28:	c1 a1       	brne	80004f5c <xcmp_rx_process+0x88>
80004f2a:	c0 98       	rjmp	80004f3c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004f2c:	4a 2c       	lddpc	r12,80004fb4 <xcmp_rx_process+0xe0>
80004f2e:	f0 1f 00 23 	mcall	80004fb8 <xcmp_rx_process+0xe4>
					break;
80004f32:	c2 f8       	rjmp	80004f90 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004f34:	4a 2c       	lddpc	r12,80004fbc <xcmp_rx_process+0xe8>
80004f36:	f0 1f 00 21 	mcall	80004fb8 <xcmp_rx_process+0xe4>
					break;
80004f3a:	c2 b8       	rjmp	80004f90 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004f3c:	4a 1c       	lddpc	r12,80004fc0 <xcmp_rx_process+0xec>
80004f3e:	f0 1f 00 1f 	mcall	80004fb8 <xcmp_rx_process+0xe4>
					break;
80004f42:	c2 78       	rjmp	80004f90 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004f44:	04 9c       	mov	r12,r2
80004f46:	f0 1f 00 1d 	mcall	80004fb8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004f4a:	c2 38       	rjmp	80004f90 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004f4c:	02 9c       	mov	r12,r1
80004f4e:	f0 1f 00 1b 	mcall	80004fb8 <xcmp_rx_process+0xe4>
					break;
80004f52:	c1 f8       	rjmp	80004f90 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004f54:	00 9c       	mov	r12,r0
80004f56:	f0 1f 00 19 	mcall	80004fb8 <xcmp_rx_process+0xe4>
					break;
80004f5a:	c1 b8       	rjmp	80004f90 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004f5c:	12 98       	mov	r8,r9
80004f5e:	e2 18 04 00 	andl	r8,0x400,COH
80004f62:	c0 70       	breq	80004f70 <xcmp_rx_process+0x9c>
80004f64:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004f68:	e0 48 00 68 	cp.w	r8,104
80004f6c:	e0 8a 00 08 	brle	80004f7c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004f70:	e2 19 f0 00 	andl	r9,0xf000,COH
80004f74:	c0 e1       	brne	80004f90 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004f76:	f0 1f 00 14 	mcall	80004fc4 <xcmp_rx_process+0xf0>
80004f7a:	c0 b8       	rjmp	80004f90 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004f7c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004f80:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004f84:	49 19       	lddpc	r9,80004fc8 <xcmp_rx_process+0xf4>
80004f86:	72 08       	ld.w	r8,r9[0x0]
80004f88:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004f8c:	f0 1f 00 0b 	mcall	80004fb8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004f90:	66 0c       	ld.w	r12,r3[0x0]
80004f92:	40 0b       	lddsp	r11,sp[0x0]
80004f94:	f0 1f 00 0e 	mcall	80004fcc <xcmp_rx_process+0xf8>
80004f98:	ca 7b       	rjmp	80004ee6 <xcmp_rx_process+0x12>
80004f9a:	00 00       	add	r0,r0
80004f9c:	00 00       	add	r0,r0
80004f9e:	10 04       	add	r4,r8
80004fa0:	00 00       	add	r0,r0
80004fa2:	0f a8       	ld.ub	r8,r7[0x2]
80004fa4:	00 00       	add	r0,r0
80004fa6:	10 14       	sub	r4,r8
80004fa8:	00 00       	add	r0,r0
80004faa:	10 08       	add	r8,r8
80004fac:	00 00       	add	r0,r0
80004fae:	10 20       	rsub	r0,r8
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	8b 78       	st.w	r5[0x1c],r8
80004fb4:	00 00       	add	r0,r0
80004fb6:	10 38       	cp.w	r8,r8
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	4e 38       	lddpc	r8,80005144 <xnl_rx_process+0x28>
80004fbc:	00 00       	add	r0,r0
80004fbe:	0f f8       	ld.ub	r8,r7[0x7]
80004fc0:	00 00       	add	r0,r0
80004fc2:	10 2c       	rsub	r12,r8
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	4e 14       	lddpc	r4,80005148 <xnl_rx_process+0x2c>
80004fc8:	00 00       	add	r0,r0
80004fca:	46 14       	lddsp	r4,sp[0x184]
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	3a 00       	mov	r0,-96

80004fd0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004fd0:	eb cd 40 90 	pushm	r4,r7,lr
80004fd4:	20 1d       	sub	sp,4
80004fd6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004fda:	48 c8       	lddpc	r8,80005008 <xcmp_rx+0x38>
80004fdc:	70 0c       	ld.w	r12,r8[0x0]
80004fde:	f0 1f 00 0c 	mcall	8000500c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004fe2:	c1 00       	breq	80005002 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004fe4:	fa c7 ff fc 	sub	r7,sp,-4
80004fe8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004fea:	e0 6a 00 ca 	mov	r10,202
80004fee:	08 9b       	mov	r11,r4
80004ff0:	f0 1f 00 08 	mcall	80005010 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004ff4:	48 88       	lddpc	r8,80005014 <xcmp_rx+0x44>
80004ff6:	70 0c       	ld.w	r12,r8[0x0]
80004ff8:	30 09       	mov	r9,0
80004ffa:	12 9a       	mov	r10,r9
80004ffc:	1a 9b       	mov	r11,sp
80004ffe:	f0 1f 00 07 	mcall	80005018 <xcmp_rx+0x48>
	}	
}
80005002:	2f fd       	sub	sp,-4
80005004:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80005008:	00 00       	add	r0,r0
8000500a:	0f a8       	ld.ub	r8,r7[0x2]
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	40 60       	lddsp	r0,sp[0x18]
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	a3 3a       	mul	r10,r1
80005014:	00 00       	add	r0,r0
80005016:	10 04       	add	r4,r8
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	8d 84       	st.w	r6[0x20],r4

8000501c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000501c:	48 28       	lddpc	r8,80005024 <xnl_register_xcmp_func+0x8>
8000501e:	91 0c       	st.w	r8[0x0],r12
}
80005020:	5e fc       	retal	r12
80005022:	00 00       	add	r0,r0
80005024:	00 00       	add	r0,r0
80005026:	10 68       	and	r8,r8

80005028 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005028:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000502a:	48 88       	lddpc	r8,80005048 <xnl_get_msg_ack_func+0x20>
8000502c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000502e:	98 49       	ld.sh	r9,r12[0x8]
80005030:	f0 09 19 00 	cp.h	r9,r8
80005034:	c0 81       	brne	80005044 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80005036:	48 68       	lddpc	r8,8000504c <xnl_get_msg_ack_func+0x24>
80005038:	70 0c       	ld.w	r12,r8[0x0]
8000503a:	30 09       	mov	r9,0
8000503c:	12 9a       	mov	r10,r9
8000503e:	12 9b       	mov	r11,r9
80005040:	f0 1f 00 04 	mcall	80005050 <xnl_get_msg_ack_func+0x28>
80005044:	d8 02       	popm	pc
80005046:	00 00       	add	r0,r0
80005048:	00 00       	add	r0,r0
8000504a:	10 48       	or	r8,r8
8000504c:	00 00       	add	r0,r0
8000504e:	10 44       	or	r4,r8
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	8d 84       	st.w	r6[0x20],r4

80005054 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80005054:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005056:	4a 86       	lddpc	r6,800050f4 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005058:	4a 82       	lddpc	r2,800050f8 <xnl_tx_process+0xa4>
8000505a:	4a 94       	lddpc	r4,800050fc <xnl_tx_process+0xa8>
8000505c:	30 07       	mov	r7,0
8000505e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005060:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80005062:	4a 85       	lddpc	r5,80005100 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80005064:	4a 83       	lddpc	r3,80005104 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005066:	6c 08       	ld.w	r8,r6[0x0]
80005068:	58 08       	cp.w	r8,0
8000506a:	c0 40       	breq	80005072 <xnl_tx_process+0x1e>
8000506c:	58 18       	cp.w	r8,1
8000506e:	cf d1       	brne	80005068 <xnl_tx_process+0x14>
80005070:	c2 08       	rjmp	800050b0 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005072:	64 0c       	ld.w	r12,r2[0x0]
80005074:	0e 99       	mov	r9,r7
80005076:	02 9a       	mov	r10,r1
80005078:	08 9b       	mov	r11,r4
8000507a:	f0 1f 00 24 	mcall	80005108 <xnl_tx_process+0xb4>
8000507e:	58 1c       	cp.w	r12,1
80005080:	cf 31       	brne	80005066 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80005082:	68 0c       	ld.w	r12,r4[0x0]
80005084:	58 0c       	cp.w	r12,0
80005086:	cf 00       	breq	80005066 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005088:	98 28       	ld.sh	r8,r12[0x4]
8000508a:	e0 08 19 00 	cp.h	r8,r0
8000508e:	c0 41       	brne	80005096 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80005090:	f0 1f 00 1f 	mcall	8000510c <xnl_tx_process+0xb8>
						break;
80005094:	ce 9b       	rjmp	80005066 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80005096:	f0 1f 00 1f 	mcall	80005110 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000509a:	30 18       	mov	r8,1
8000509c:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000509e:	66 0c       	ld.w	r12,r3[0x0]
800050a0:	0e 99       	mov	r9,r7
800050a2:	0e 9a       	mov	r10,r7
800050a4:	0e 9b       	mov	r11,r7
800050a6:	f0 1f 00 19 	mcall	80005108 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800050aa:	30 18       	mov	r8,1
800050ac:	8d 08       	st.w	r6[0x0],r8
800050ae:	cd cb       	rjmp	80005066 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800050b0:	66 0c       	ld.w	r12,r3[0x0]
800050b2:	0e 99       	mov	r9,r7
800050b4:	36 4a       	mov	r10,100
800050b6:	0e 9b       	mov	r11,r7
800050b8:	f0 1f 00 14 	mcall	80005108 <xnl_tx_process+0xb4>
800050bc:	58 1c       	cp.w	r12,1
800050be:	c0 81       	brne	800050ce <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800050c0:	49 58       	lddpc	r8,80005114 <xnl_tx_process+0xc0>
800050c2:	70 0c       	ld.w	r12,r8[0x0]
800050c4:	68 0b       	ld.w	r11,r4[0x0]
800050c6:	f0 1f 00 15 	mcall	80005118 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800050ca:	8d 07       	st.w	r6[0x0],r7
800050cc:	cc db       	rjmp	80005066 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800050ce:	6a 08       	ld.w	r8,r5[0x0]
800050d0:	58 38       	cp.w	r8,3
800050d2:	e0 89 00 09 	brgt	800050e4 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800050d6:	68 0c       	ld.w	r12,r4[0x0]
800050d8:	f0 1f 00 0e 	mcall	80005110 <xnl_tx_process+0xbc>
						xnl_send_times++;
800050dc:	6a 08       	ld.w	r8,r5[0x0]
800050de:	2f f8       	sub	r8,-1
800050e0:	8b 08       	st.w	r5[0x0],r8
800050e2:	cc 2b       	rjmp	80005066 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800050e4:	48 c8       	lddpc	r8,80005114 <xnl_tx_process+0xc0>
800050e6:	70 0c       	ld.w	r12,r8[0x0]
800050e8:	68 0b       	ld.w	r11,r4[0x0]
800050ea:	f0 1f 00 0c 	mcall	80005118 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800050ee:	8d 07       	st.w	r6[0x0],r7
800050f0:	cb bb       	rjmp	80005066 <xnl_tx_process+0x12>
800050f2:	00 00       	add	r0,r0
800050f4:	00 00       	add	r0,r0
800050f6:	10 5c       	eor	r12,r8
800050f8:	00 00       	add	r0,r0
800050fa:	10 58       	eor	r8,r8
800050fc:	00 00       	add	r0,r0
800050fe:	10 54       	eor	r4,r8
80005100:	00 00       	add	r0,r0
80005102:	10 60       	and	r0,r8
80005104:	00 00       	add	r0,r0
80005106:	10 44       	or	r4,r8
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	8b 78       	st.w	r5[0x1c],r8
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	8a 08       	ld.sh	r8,r5[0x0]
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	3a 20       	mov	r0,-94
80005114:	00 00       	add	r0,r0
80005116:	0f a8       	ld.ub	r8,r7[0x2]
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	3a 00       	mov	r0,-96

8000511c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000511c:	eb cd 40 fe 	pushm	r1-r7,lr
80005120:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005122:	49 26       	lddpc	r6,80005168 <xnl_rx_process+0x4c>
80005124:	30 05       	mov	r5,0
80005126:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005128:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000512a:	49 11       	lddpc	r1,8000516c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000512c:	49 12       	lddpc	r2,80005170 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000512e:	6c 0c       	ld.w	r12,r6[0x0]
80005130:	0a 99       	mov	r9,r5
80005132:	08 9a       	mov	r10,r4
80005134:	1a 9b       	mov	r11,sp
80005136:	f0 1f 00 10 	mcall	80005174 <xnl_rx_process+0x58>
8000513a:	58 1c       	cp.w	r12,1
8000513c:	cf 91       	brne	8000512e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000513e:	40 0c       	lddsp	r12,sp[0x0]
80005140:	58 0c       	cp.w	r12,0
80005142:	cf 60       	breq	8000512e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005144:	98 28       	ld.sh	r8,r12[0x4]
80005146:	e6 08 19 00 	cp.h	r8,r3
8000514a:	e0 8b 00 0a 	brhi	8000515e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000514e:	5c 78       	castu.h	r8
80005150:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80005154:	58 09       	cp.w	r9,0
80005156:	c0 40       	breq	8000515e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80005158:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000515c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000515e:	62 0c       	ld.w	r12,r1[0x0]
80005160:	40 0b       	lddsp	r11,sp[0x0]
80005162:	f0 1f 00 06 	mcall	80005178 <xnl_rx_process+0x5c>
80005166:	ce 4b       	rjmp	8000512e <xnl_rx_process+0x12>
80005168:	00 00       	add	r0,r0
8000516a:	0f c4       	ld.ub	r4,r7[0x4]
8000516c:	00 00       	add	r0,r0
8000516e:	0f a8       	ld.ub	r8,r7[0x2]
80005170:	00 00       	add	r0,r0
80005172:	04 fc       	st.b	--r2,r12
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	8b 78       	st.w	r5[0x1c],r8
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	3a 00       	mov	r0,-96

8000517c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000517c:	eb cd 40 c0 	pushm	r6-r7,lr
80005180:	20 1d       	sub	sp,4
80005182:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80005184:	98 39       	ld.sh	r9,r12[0x6]
80005186:	3f f8       	mov	r8,-1
80005188:	f0 09 19 00 	cp.h	r9,r8
8000518c:	c0 a1       	brne	800051a0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000518e:	4a e9       	lddpc	r9,80005244 <xnl_tx+0xc8>
80005190:	13 88       	ld.ub	r8,r9[0x0]
80005192:	2f f8       	sub	r8,-1
80005194:	5c 58       	castu.b	r8
80005196:	b2 88       	st.b	r9[0x0],r8
80005198:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000519c:	a9 a8       	sbr	r8,0x8
8000519e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800051a0:	8c 49       	ld.sh	r9,r6[0x8]
800051a2:	3f f8       	mov	r8,-1
800051a4:	f0 09 19 00 	cp.h	r9,r8
800051a8:	c0 41       	brne	800051b0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800051aa:	4a 88       	lddpc	r8,80005248 <xnl_tx+0xcc>
800051ac:	90 18       	ld.sh	r8,r8[0x2]
800051ae:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800051b0:	8c 59       	ld.sh	r9,r6[0xa]
800051b2:	3f f8       	mov	r8,-1
800051b4:	f0 09 19 00 	cp.h	r9,r8
800051b8:	c0 41       	brne	800051c0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800051ba:	4a 48       	lddpc	r8,80005248 <xnl_tx+0xcc>
800051bc:	90 28       	ld.sh	r8,r8[0x4]
800051be:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800051c0:	8c 69       	ld.sh	r9,r6[0xc]
800051c2:	3f f8       	mov	r8,-1
800051c4:	f0 09 19 00 	cp.h	r9,r8
800051c8:	c0 e1       	brne	800051e4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800051ca:	4a 08       	lddpc	r8,80005248 <xnl_tx+0xcc>
800051cc:	90 49       	ld.sh	r9,r8[0x8]
800051ce:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800051d0:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800051d2:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800051d4:	90 49       	ld.sh	r9,r8[0x8]
800051d6:	e0 19 ff 00 	andl	r9,0xff00
800051da:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800051de:	f3 e8 10 08 	or	r8,r9,r8
800051e2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800051e4:	0d 98       	ld.ub	r8,r6[0x1]
800051e6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800051e8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800051ec:	10 0c       	add	r12,r8
800051ee:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800051f0:	58 0c       	cp.w	r12,0
800051f2:	e0 89 00 04 	brgt	800051fa <xnl_tx+0x7e>
800051f6:	30 09       	mov	r9,0
800051f8:	c0 d8       	rjmp	80005212 <xnl_tx+0x96>
800051fa:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800051fe:	2f ec       	sub	r12,-2
80005200:	30 09       	mov	r9,0
80005202:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80005204:	15 1b       	ld.sh	r11,r10++
80005206:	f6 09 00 09 	add	r9,r11,r9
8000520a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000520c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000520e:	18 38       	cp.w	r8,r12
80005210:	cf a1       	brne	80005204 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80005212:	5c 39       	neg	r9
80005214:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005216:	48 e8       	lddpc	r8,8000524c <xnl_tx+0xd0>
80005218:	70 0c       	ld.w	r12,r8[0x0]
8000521a:	f0 1f 00 0e 	mcall	80005250 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000521e:	c1 00       	breq	8000523e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005220:	fa c7 ff fc 	sub	r7,sp,-4
80005224:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80005226:	e0 6a 01 00 	mov	r10,256
8000522a:	0c 9b       	mov	r11,r6
8000522c:	f0 1f 00 0a 	mcall	80005254 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80005230:	48 a8       	lddpc	r8,80005258 <xnl_tx+0xdc>
80005232:	70 0c       	ld.w	r12,r8[0x0]
80005234:	30 09       	mov	r9,0
80005236:	12 9a       	mov	r10,r9
80005238:	1a 9b       	mov	r11,sp
8000523a:	f0 1f 00 09 	mcall	8000525c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000523e:	2f fd       	sub	sp,-4
80005240:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005244:	00 00       	add	r0,r0
80005246:	10 64       	and	r4,r8
80005248:	00 00       	add	r0,r0
8000524a:	10 48       	or	r8,r8
8000524c:	00 00       	add	r0,r0
8000524e:	0f a8       	ld.ub	r8,r7[0x2]
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	40 60       	lddsp	r0,sp[0x18]
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	a3 3a       	mul	r10,r1
80005258:	00 00       	add	r0,r0
8000525a:	10 58       	eor	r8,r8
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	8d 84       	st.w	r6[0x20],r4

80005260 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80005260:	eb cd 40 80 	pushm	r7,lr
80005264:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80005268:	f0 1f 00 27 	mcall	80005304 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000526c:	30 09       	mov	r9,0
8000526e:	4a 78       	lddpc	r8,80005308 <xnl_init+0xa8>
80005270:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80005272:	30 0b       	mov	r11,0
80005274:	30 1c       	mov	r12,1
80005276:	f0 1f 00 26 	mcall	8000530c <xnl_init+0xac>
8000527a:	4a 68       	lddpc	r8,80005310 <xnl_init+0xb0>
8000527c:	91 0c       	st.w	r8[0x0],r12
8000527e:	70 08       	ld.w	r8,r8[0x0]
80005280:	58 08       	cp.w	r8,0
80005282:	c0 80       	breq	80005292 <xnl_init+0x32>
80005284:	4a 38       	lddpc	r8,80005310 <xnl_init+0xb0>
80005286:	70 0c       	ld.w	r12,r8[0x0]
80005288:	30 09       	mov	r9,0
8000528a:	12 9a       	mov	r10,r9
8000528c:	12 9b       	mov	r11,r9
8000528e:	f0 1f 00 22 	mcall	80005314 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80005292:	30 4b       	mov	r11,4
80005294:	31 4c       	mov	r12,20
80005296:	f0 1f 00 1e 	mcall	8000530c <xnl_init+0xac>
8000529a:	4a 08       	lddpc	r8,80005318 <xnl_init+0xb8>
8000529c:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000529e:	30 07       	mov	r7,0
800052a0:	1a d7       	st.w	--sp,r7
800052a2:	1a d7       	st.w	--sp,r7
800052a4:	1a d7       	st.w	--sp,r7
800052a6:	30 38       	mov	r8,3
800052a8:	0e 99       	mov	r9,r7
800052aa:	e0 6a 02 00 	mov	r10,512
800052ae:	49 cb       	lddpc	r11,8000531c <xnl_init+0xbc>
800052b0:	49 cc       	lddpc	r12,80005320 <xnl_init+0xc0>
800052b2:	f0 1f 00 1d 	mcall	80005324 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800052b6:	1a d7       	st.w	--sp,r7
800052b8:	1a d7       	st.w	--sp,r7
800052ba:	1a d7       	st.w	--sp,r7
800052bc:	30 38       	mov	r8,3
800052be:	0e 99       	mov	r9,r7
800052c0:	e0 6a 03 20 	mov	r10,800
800052c4:	49 9b       	lddpc	r11,80005328 <xnl_init+0xc8>
800052c6:	49 ac       	lddpc	r12,8000532c <xnl_init+0xcc>
800052c8:	f0 1f 00 17 	mcall	80005324 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800052cc:	e0 68 40 0e 	mov	r8,16398
800052d0:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800052d4:	3f f8       	mov	r8,-1
800052d6:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800052da:	30 38       	mov	r8,3
800052dc:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800052e0:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800052e4:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800052e8:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800052ec:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800052f0:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800052f4:	fa cc ff e8 	sub	r12,sp,-24
800052f8:	f0 1f 00 0e 	mcall	80005330 <xnl_init+0xd0>
800052fc:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800052fe:	2c 0d       	sub	sp,-256
80005300:	e3 cd 80 80 	ldm	sp++,r7,pc
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	40 88       	lddsp	r8,sp[0x20]
80005308:	00 00       	add	r0,r0
8000530a:	10 48       	or	r8,r8
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	8e dc       	ld.uh	r12,r7[0xa]
80005310:	00 00       	add	r0,r0
80005312:	10 44       	or	r4,r8
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	8d 84       	st.w	r6[0x20],r4
80005318:	00 00       	add	r0,r0
8000531a:	10 58       	eor	r8,r8
8000531c:	80 01       	ld.sh	r1,r0[0x0]
8000531e:	88 64       	ld.sh	r4,r4[0xc]
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	51 1c       	stdsp	sp[0x44],r12
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	95 b0       	st.w	r10[0x2c],r0
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	fc 00       	*unknown*
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	50 54       	stdsp	sp[0x14],r4
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	51 7c       	stdsp	sp[0x5c],r12

80005334 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005334:	eb cd 40 80 	pushm	r7,lr
80005338:	fa cd 01 00 	sub	sp,sp,256
8000533c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000533e:	e0 68 40 0e 	mov	r8,16398
80005342:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005344:	3f f8       	mov	r8,-1
80005346:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005348:	30 c8       	mov	r8,12
8000534a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000534c:	98 38       	ld.sh	r8,r12[0x6]
8000534e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005350:	98 58       	ld.sh	r8,r12[0xa]
80005352:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80005354:	98 48       	ld.sh	r8,r12[0x8]
80005356:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005358:	98 68       	ld.sh	r8,r12[0xc]
8000535a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000535c:	30 08       	mov	r8,0
8000535e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005360:	1a 9c       	mov	r12,sp
80005362:	f0 1f 00 0a 	mcall	80005388 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80005366:	fa cd 00 cc 	sub	sp,sp,204
8000536a:	e0 6a 00 ca 	mov	r10,202
8000536e:	ee cb ff f0 	sub	r11,r7,-16
80005372:	1a 9c       	mov	r12,sp
80005374:	f0 1f 00 06 	mcall	8000538c <xnl_data_msg_func+0x58>
80005378:	48 68       	lddpc	r8,80005390 <xnl_data_msg_func+0x5c>
8000537a:	70 08       	ld.w	r8,r8[0x0]
8000537c:	5d 18       	icall	r8
8000537e:	fa cd ff 34 	sub	sp,sp,-204
}
80005382:	2c 0d       	sub	sp,-256
80005384:	e3 cd 80 80 	ldm	sp++,r7,pc
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	51 7c       	stdsp	sp[0x5c],r12
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	a3 3a       	mul	r10,r1
80005390:	00 00       	add	r0,r0
80005392:	10 68       	and	r8,r8

80005394 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005394:	d4 21       	pushm	r4-r7,lr
80005396:	fa cd 01 00 	sub	sp,sp,256
8000539a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000539c:	4c 28       	lddpc	r8,800054a4 <xnl_device_auth_reply_func+0x110>
8000539e:	11 88       	ld.ub	r8,r8[0x0]
800053a0:	58 08       	cp.w	r8,0
800053a2:	e0 81 00 7f 	brne	800054a0 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800053a6:	4c 18       	lddpc	r8,800054a8 <xnl_device_auth_reply_func+0x114>
800053a8:	70 0c       	ld.w	r12,r8[0x0]
800053aa:	30 09       	mov	r9,0
800053ac:	12 9a       	mov	r10,r9
800053ae:	12 9b       	mov	r11,r9
800053b0:	f0 1f 00 3f 	mcall	800054ac <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800053b4:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800053b8:	4b b8       	lddpc	r8,800054a4 <xnl_device_auth_reply_func+0x110>
800053ba:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800053bc:	ef 39 00 12 	ld.ub	r9,r7[18]
800053c0:	ef 38 00 13 	ld.ub	r8,r7[19]
800053c4:	b1 68       	lsl	r8,0x10
800053c6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800053ca:	ef 38 00 15 	ld.ub	r8,r7[21]
800053ce:	f3 e8 10 08 	or	r8,r9,r8
800053d2:	ef 39 00 14 	ld.ub	r9,r7[20]
800053d6:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800053da:	ef 3a 00 16 	ld.ub	r10,r7[22]
800053de:	ef 38 00 17 	ld.ub	r8,r7[23]
800053e2:	b1 68       	lsl	r8,0x10
800053e4:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800053e8:	ef 38 00 19 	ld.ub	r8,r7[25]
800053ec:	f5 e8 10 08 	or	r8,r10,r8
800053f0:	ef 3a 00 18 	ld.ub	r10,r7[24]
800053f4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800053f8:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800053fa:	e0 64 79 b9 	mov	r4,31161
800053fe:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005402:	e0 65 1c 1d 	mov	r5,7197
80005406:	ea 15 c3 38 	orh	r5,0xc338
8000540a:	e0 66 63 23 	mov	r6,25379
8000540e:	ea 16 1c 8b 	orh	r6,0x1c8b
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005412:	e0 6e fc a2 	mov	lr,64674
80005416:	ea 1e 45 b0 	orh	lr,0x45b0
8000541a:	e0 67 75 d3 	mov	r7,30163
8000541e:	ea 17 c4 ca 	orh	r7,0xc4ca
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005422:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005424:	f4 08 00 0c 	add	r12,r10,r8
80005428:	f0 0b 15 04 	lsl	r11,r8,0x4
8000542c:	0a 0b       	add	r11,r5
8000542e:	f9 eb 20 0b 	eor	r11,r12,r11
80005432:	f0 0c 16 05 	lsr	r12,r8,0x5
80005436:	0c 0c       	add	r12,r6
80005438:	18 5b       	eor	r11,r12
8000543a:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000543c:	f2 0c 15 04 	lsl	r12,r9,0x4
80005440:	1c 0c       	add	r12,lr
80005442:	f2 0b 16 05 	lsr	r11,r9,0x5
80005446:	0e 0b       	add	r11,r7
80005448:	f9 eb 20 0b 	eor	r11,r12,r11
8000544c:	f2 0a 00 0c 	add	r12,r9,r10
80005450:	18 5b       	eor	r11,r12
80005452:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005454:	e0 6b 37 20 	mov	r11,14112
80005458:	ea 1b c6 ef 	orh	r11,0xc6ef
8000545c:	16 3a       	cp.w	r10,r11
8000545e:	ce 21       	brne	80005422 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005460:	e0 6a 40 1a 	mov	r10,16410
80005464:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005466:	3f fa       	mov	r10,-1
80005468:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000546a:	30 6b       	mov	r11,6
8000546c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000546e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005470:	48 db       	lddpc	r11,800054a4 <xnl_device_auth_reply_func+0x110>
80005472:	96 1c       	ld.sh	r12,r11[0x2]
80005474:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80005476:	96 2b       	ld.sh	r11,r11[0x4]
80005478:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000547a:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000547c:	30 ca       	mov	r10,12
8000547e:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80005480:	30 0a       	mov	r10,0
80005482:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80005486:	30 7a       	mov	r10,7
80005488:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000548c:	30 2a       	mov	r10,2
8000548e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005492:	fa ca ff ec 	sub	r10,sp,-20
80005496:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005498:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000549a:	1a 9c       	mov	r12,sp
8000549c:	f0 1f 00 05 	mcall	800054b0 <xnl_device_auth_reply_func+0x11c>
}
800054a0:	2c 0d       	sub	sp,-256
800054a2:	d8 22       	popm	r4-r7,pc
800054a4:	00 00       	add	r0,r0
800054a6:	10 48       	or	r8,r8
800054a8:	00 00       	add	r0,r0
800054aa:	10 44       	or	r4,r8
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	8d 84       	st.w	r6[0x20],r4
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	51 7c       	stdsp	sp[0x5c],r12

800054b4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800054b4:	eb cd 40 80 	pushm	r7,lr
800054b8:	fa cd 01 00 	sub	sp,sp,256
800054bc:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800054be:	49 28       	lddpc	r8,80005504 <xnl_master_status_brdcst_func+0x50>
800054c0:	11 88       	ld.ub	r8,r8[0x0]
800054c2:	58 08       	cp.w	r8,0
800054c4:	c1 c1       	brne	800054fc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800054c6:	49 18       	lddpc	r8,80005508 <xnl_master_status_brdcst_func+0x54>
800054c8:	70 0c       	ld.w	r12,r8[0x0]
800054ca:	30 09       	mov	r9,0
800054cc:	12 9a       	mov	r10,r9
800054ce:	12 9b       	mov	r11,r9
800054d0:	f0 1f 00 0f 	mcall	8000550c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800054d4:	8e 58       	ld.sh	r8,r7[0xa]
800054d6:	48 c9       	lddpc	r9,80005504 <xnl_master_status_brdcst_func+0x50>
800054d8:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800054da:	e0 68 40 0e 	mov	r8,16398
800054de:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800054e0:	3f f8       	mov	r8,-1
800054e2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800054e4:	30 4a       	mov	r10,4
800054e6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800054e8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800054ea:	92 19       	ld.sh	r9,r9[0x2]
800054ec:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800054ee:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800054f0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800054f2:	30 08       	mov	r8,0
800054f4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800054f6:	1a 9c       	mov	r12,sp
800054f8:	f0 1f 00 06 	mcall	80005510 <xnl_master_status_brdcst_func+0x5c>
}
800054fc:	2c 0d       	sub	sp,-256
800054fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80005502:	00 00       	add	r0,r0
80005504:	00 00       	add	r0,r0
80005506:	10 48       	or	r8,r8
80005508:	00 00       	add	r0,r0
8000550a:	10 44       	or	r4,r8
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	8d 84       	st.w	r6[0x20],r4
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	51 7c       	stdsp	sp[0x5c],r12

80005514 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005514:	eb cd 40 80 	pushm	r7,lr
80005518:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000551a:	49 38       	lddpc	r8,80005564 <xnl_device_conn_reply_func+0x50>
8000551c:	70 0c       	ld.w	r12,r8[0x0]
8000551e:	30 09       	mov	r9,0
80005520:	12 9a       	mov	r10,r9
80005522:	12 9b       	mov	r11,r9
80005524:	f0 1f 00 11 	mcall	80005568 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005528:	ef 18 00 10 	ld.uh	r8,r7[16]
8000552c:	10 99       	mov	r9,r8
8000552e:	e2 19 ff 00 	andl	r9,0xff00,COH
80005532:	e0 49 01 00 	cp.w	r9,256
80005536:	c0 60       	breq	80005542 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005538:	0e 9c       	mov	r12,r7
8000553a:	f0 1f 00 0d 	mcall	8000556c <xnl_device_conn_reply_func+0x58>
8000553e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005542:	a9 68       	lsl	r8,0x8
80005544:	48 b9       	lddpc	r9,80005570 <xnl_device_conn_reply_func+0x5c>
80005546:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005548:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000554c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000554e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80005552:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005554:	30 18       	mov	r8,1
80005556:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005558:	48 7c       	lddpc	r12,80005574 <xnl_device_conn_reply_func+0x60>
8000555a:	f0 1f 00 08 	mcall	80005578 <xnl_device_conn_reply_func+0x64>
8000555e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005562:	00 00       	add	r0,r0
80005564:	00 00       	add	r0,r0
80005566:	10 44       	or	r4,r8
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	8d 84       	st.w	r6[0x20],r4
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	54 b4       	stdsp	sp[0x12c],r4
80005570:	00 00       	add	r0,r0
80005572:	10 48       	or	r8,r8
80005574:	80 01       	ld.sh	r1,r0[0x0]
80005576:	88 6c       	ld.sh	r12,r4[0xc]
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	99 74       	st.w	r12[0x1c],r4

8000557c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000557c:	fe 78 0c 00 	mov	r8,-62464
80005580:	e0 69 03 07 	mov	r9,775
80005584:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005586:	30 49       	mov	r9,4
80005588:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000558a:	71 59       	ld.w	r9,r8[0x54]
8000558c:	e2 19 00 80 	andl	r9,0x80,COH
80005590:	cf d0       	breq	8000558a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005592:	fe 78 0c 00 	mov	r8,-62464
80005596:	30 59       	mov	r9,5
80005598:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000559a:	e0 69 01 0d 	mov	r9,269
8000559e:	ea 19 10 07 	orh	r9,0x1007
800055a2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800055a4:	71 59       	ld.w	r9,r8[0x54]
800055a6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800055aa:	cf d0       	breq	800055a4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800055ac:	fe 78 0c 00 	mov	r8,-62464
800055b0:	fc 19 00 80 	movh	r9,0x80
800055b4:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800055b6:	34 0a       	mov	r10,64
800055b8:	fe 69 14 00 	mov	r9,-125952
800055bc:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800055be:	30 69       	mov	r9,6
800055c0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800055c2:	30 19       	mov	r9,1
800055c4:	fe 68 10 00 	mov	r8,-126976
800055c8:	91 19       	st.w	r8[0x4],r9
}
800055ca:	5e fc       	retal	r12

800055cc <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
800055cc:	fe 78 2c 00 	mov	r8,-54272
800055d0:	32 49       	mov	r9,36
800055d2:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
800055d4:	e0 69 11 00 	mov	r9,4352
800055d8:	ea 19 00 51 	orh	r9,0x51
800055dc:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
800055de:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
800055e0:	30 39       	mov	r9,3
800055e2:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
800055e4:	70 8c       	ld.w	r12,r8[0x20]
800055e6:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
800055ea:	cf d0       	breq	800055e4 <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
800055ec:	18 98       	mov	r8,r12
800055ee:	e2 18 01 00 	andl	r8,0x100,COH
800055f2:	c0 51       	brne	800055fc <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
800055f4:	fe 78 2c 00 	mov	r8,-54272
800055f8:	70 c8       	ld.w	r8,r8[0x30]
800055fa:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
800055fc:	fe 78 2c 00 	mov	r8,-54272
80005600:	70 89       	ld.w	r9,r8[0x20]
80005602:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005606:	cf d0       	breq	80005600 <read_a_byte+0x34>
	return (TWI_Status);
}
80005608:	5e fc       	retal	r12
8000560a:	d7 03       	nop

8000560c <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
8000560c:	eb cd 40 e0 	pushm	r5-r7,lr
80005610:	20 2d       	sub	sp,8
80005612:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
80005614:	4c 28       	lddpc	r8,8000571c <rtc_read_time+0x110>
80005616:	70 08       	ld.w	r8,r8[0x0]
80005618:	58 08       	cp.w	r8,0
8000561a:	c0 31       	brne	80005620 <rtc_read_time+0x14>
8000561c:	30 3c       	mov	r12,3
8000561e:	c7 b8       	rjmp	80005714 <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005620:	4b f6       	lddpc	r6,8000571c <rtc_read_time+0x110>
80005622:	6c 0c       	ld.w	r12,r6[0x0]
80005624:	30 09       	mov	r9,0
80005626:	3f fa       	mov	r10,-1
80005628:	12 9b       	mov	r11,r9
8000562a:	f0 1f 00 3e 	mcall	80005720 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
8000562e:	1a 9b       	mov	r11,sp
80005630:	30 2c       	mov	r12,2
80005632:	f0 1f 00 3d 	mcall	80005724 <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005636:	1b 88       	ld.ub	r8,sp[0x0]
80005638:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
8000563c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005640:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005644:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005648:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
8000564a:	fa cb ff ff 	sub	r11,sp,-1
8000564e:	30 3c       	mov	r12,3
80005650:	f0 1f 00 35 	mcall	80005724 <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005654:	1b 98       	ld.ub	r8,sp[0x1]
80005656:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
8000565a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000565e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005662:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005666:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005668:	fa cb ff fe 	sub	r11,sp,-2
8000566c:	30 4c       	mov	r12,4
8000566e:	f0 1f 00 2e 	mcall	80005724 <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
80005672:	1b a8       	ld.ub	r8,sp[0x2]
80005674:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005678:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000567c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005680:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005684:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
80005686:	fa cb ff fd 	sub	r11,sp,-3
8000568a:	30 5c       	mov	r12,5
8000568c:	f0 1f 00 26 	mcall	80005724 <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
80005690:	1b b8       	ld.ub	r8,sp[0x3]
80005692:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005696:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000569a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000569e:	f0 09 00 19 	add	r9,r8,r9<<0x1
800056a2:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
800056a4:	fa cb ff fc 	sub	r11,sp,-4
800056a8:	30 6c       	mov	r12,6
800056aa:	f0 1f 00 1f 	mcall	80005724 <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
800056ae:	1b c8       	ld.ub	r8,sp[0x4]
800056b0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800056b4:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
800056b6:	fa cb ff fb 	sub	r11,sp,-5
800056ba:	30 7c       	mov	r12,7
800056bc:	f0 1f 00 1a 	mcall	80005724 <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
800056c0:	1b d8       	ld.ub	r8,sp[0x5]
800056c2:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
800056c6:	f2 0a 15 02 	lsl	r10,r9,0x2
800056ca:	14 09       	add	r9,r10
800056cc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800056d0:	f0 09 00 18 	add	r8,r8,r9<<0x1
800056d4:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
800056d6:	fa cb ff fa 	sub	r11,sp,-6
800056da:	30 8c       	mov	r12,8
800056dc:	f0 1f 00 12 	mcall	80005724 <rtc_read_time+0x118>
800056e0:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
800056e2:	1b e9       	ld.ub	r9,sp[0x6]
800056e4:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
800056e8:	f0 c8 f8 30 	sub	r8,r8,-2000
800056ec:	a5 89       	lsr	r9,0x4
800056ee:	f2 09 10 0a 	mul	r9,r9,10
800056f2:	12 08       	add	r8,r9
800056f4:	5c 78       	castu.h	r8
800056f6:	30 0b       	mov	r11,0
800056f8:	f0 09 16 08 	lsr	r9,r8,0x8
800056fc:	ae 89       	st.b	r7[0x0],r9
800056fe:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
80005700:	6c 0c       	ld.w	r12,r6[0x0]
80005702:	16 99       	mov	r9,r11
80005704:	16 9a       	mov	r10,r11
80005706:	f0 1f 00 09 	mcall	80005728 <rtc_read_time+0x11c>
		
	if(res)
8000570a:	58 05       	cp.w	r5,0
8000570c:	f9 bc 01 00 	movne	r12,0
80005710:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005714:	2f ed       	sub	sp,-8
80005716:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000571a:	00 00       	add	r0,r0
8000571c:	00 00       	add	r0,r0
8000571e:	10 78       	tst	r8,r8
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	8b 78       	st.w	r5[0x1c],r8
80005724:	80 00       	ld.sh	r0,r0[0x0]
80005726:	55 cc       	stdsp	sp[0x170],r12
80005728:	80 00       	ld.sh	r0,r0[0x0]
8000572a:	8d 84       	st.w	r6[0x20],r4

8000572c <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
8000572c:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005730:	48 47       	lddpc	r7,80005740 <getTime+0x14>
80005732:	0e 9c       	mov	r12,r7
80005734:	f0 1f 00 04 	mcall	80005744 <getTime+0x18>
	return &date_time;
80005738:	0e 9c       	mov	r12,r7
8000573a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000573e:	00 00       	add	r0,r0
80005740:	00 00       	add	r0,r0
80005742:	10 70       	tst	r0,r8
80005744:	80 00       	ld.sh	r0,r0[0x0]
80005746:	56 0c       	stdsp	sp[0x180],r12

80005748 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005748:	eb cd 40 c0 	pushm	r6-r7,lr
8000574c:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
8000574e:	f0 1f 00 1a 	mcall	800057b4 <rtc_init+0x6c>
80005752:	49 a8       	lddpc	r8,800057b8 <rtc_init+0x70>
80005754:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005756:	70 08       	ld.w	r8,r8[0x0]
80005758:	58 08       	cp.w	r8,0
8000575a:	c0 31       	brne	80005760 <rtc_init+0x18>
8000575c:	30 3c       	mov	r12,3
8000575e:	c2 78       	rjmp	800057ac <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005760:	49 66       	lddpc	r6,800057b8 <rtc_init+0x70>
80005762:	6c 0c       	ld.w	r12,r6[0x0]
80005764:	30 09       	mov	r9,0
80005766:	3f fa       	mov	r10,-1
80005768:	12 9b       	mov	r11,r9
8000576a:	f0 1f 00 15 	mcall	800057bc <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
8000576e:	30 2b       	mov	r11,2
80005770:	49 4c       	lddpc	r12,800057c0 <rtc_init+0x78>
80005772:	f0 1f 00 15 	mcall	800057c4 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80005776:	e0 68 36 00 	mov	r8,13824
8000577a:	ea 18 01 6e 	orh	r8,0x16e
8000577e:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80005780:	e2 78 0d 40 	mov	r8,200000
80005784:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80005786:	35 18       	mov	r8,81
80005788:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
8000578c:	1a 9b       	mov	r11,sp
8000578e:	fe 7c 2c 00 	mov	r12,-54272
80005792:	f0 1f 00 0e 	mcall	800057c8 <rtc_init+0x80>
80005796:	48 e7       	lddpc	r7,800057cc <rtc_init+0x84>
80005798:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
8000579a:	6c 0c       	ld.w	r12,r6[0x0]
8000579c:	30 09       	mov	r9,0
8000579e:	12 9a       	mov	r10,r9
800057a0:	12 9b       	mov	r11,r9
800057a2:	f0 1f 00 0c 	mcall	800057d0 <rtc_init+0x88>
800057a6:	6e 08       	ld.w	r8,r7[0x0]
800057a8:	58 08       	cp.w	r8,0
800057aa:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
800057ac:	2f dd       	sub	sp,-12
800057ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057b2:	00 00       	add	r0,r0
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	8e 84       	ld.uh	r4,r7[0x0]
800057b8:	00 00       	add	r0,r0
800057ba:	10 78       	tst	r8,r8
800057bc:	80 00       	ld.sh	r0,r0[0x0]
800057be:	8b 78       	st.w	r5[0x1c],r8
800057c0:	80 01       	ld.sh	r1,r0[0x0]
800057c2:	88 80       	ld.uh	r0,r4[0x0]
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	9e 14       	ld.sh	r4,pc[0x2]
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	5e 34       	retlo	r4
800057cc:	00 00       	add	r0,r0
800057ce:	10 6c       	and	r12,r8
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	8d 84       	st.w	r6[0x20],r4

800057d4 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800057d4:	fe 78 10 00 	mov	r8,-61440
800057d8:	fc 19 00 10 	movh	r9,0x10
800057dc:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800057de:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800057e0:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800057e2:	30 39       	mov	r9,3
800057e4:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800057e8:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800057ec:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800057f0:	fe 78 38 00 	mov	r8,-51200
800057f4:	30 49       	mov	r9,4
800057f6:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800057fa:	e0 69 91 0d 	mov	r9,37133
800057fe:	ea 19 00 52 	orh	r9,0x52
80005802:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005804:	32 09       	mov	r9,32
80005806:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005808:	30 59       	mov	r9,5
8000580a:	91 09       	st.w	r8[0x0],r9
}
8000580c:	5e fc       	retal	r12
8000580e:	d7 03       	nop

80005810 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80005810:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80005812:	30 2a       	mov	r10,2
80005814:	e0 6b 01 c1 	mov	r11,449
80005818:	48 ec       	lddpc	r12,80005850 <tc_init+0x40>
8000581a:	f0 1f 00 0f 	mcall	80005854 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000581e:	48 fb       	lddpc	r11,80005858 <tc_init+0x48>
80005820:	fe 7c 38 00 	mov	r12,-51200
80005824:	f0 1f 00 0e 	mcall	8000585c <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005828:	e0 6a 75 30 	mov	r10,30000
8000582c:	30 1b       	mov	r11,1
8000582e:	fe 7c 38 00 	mov	r12,-51200
80005832:	f0 1f 00 0c 	mcall	80005860 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005836:	48 ca       	lddpc	r10,80005864 <tc_init+0x54>
80005838:	30 1b       	mov	r11,1
8000583a:	fe 7c 38 00 	mov	r12,-51200
8000583e:	f0 1f 00 0b 	mcall	80005868 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80005842:	30 1b       	mov	r11,1
80005844:	fe 7c 38 00 	mov	r12,-51200
80005848:	f0 1f 00 09 	mcall	8000586c <tc_init+0x5c>
8000584c:	d8 02       	popm	pc
8000584e:	00 00       	add	r0,r0
80005850:	80 00       	ld.sh	r0,r0[0x0]
80005852:	58 70       	cp.w	r0,7
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	58 94       	cp.w	r4,9
80005858:	80 01       	ld.sh	r1,r0[0x0]
8000585a:	88 94       	ld.uh	r4,r4[0x2]
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	5b 7a       	cp.w	r10,-9
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	5c 3a       	neg	r10
80005864:	80 01       	ld.sh	r1,r0[0x0]
80005866:	88 90       	ld.uh	r0,r4[0x2]
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	5c 6e       	casts.b	lr
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	5c 16       	scr	r6

80005870 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80005870:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80005872:	48 68       	lddpc	r8,80005888 <_tc_interrupt+0x18>
80005874:	70 09       	ld.w	r9,r8[0x0]
80005876:	2f f9       	sub	r9,-1
80005878:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
8000587a:	30 1b       	mov	r11,1
8000587c:	fe 7c 38 00 	mov	r12,-51200
80005880:	f0 1f 00 03 	mcall	8000588c <_tc_interrupt+0x1c>
	
}
80005884:	d4 02       	popm	lr
80005886:	d6 03       	rete
80005888:	00 00       	add	r0,r0
8000588a:	10 7c       	tst	r12,r8
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	5c 28       	cpc	r8

80005890 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005890:	c0 08       	rjmp	80005890 <_unhandled_interrupt>
80005892:	d7 03       	nop

80005894 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005894:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005898:	49 99       	lddpc	r9,800058fc <INTC_register_interrupt+0x68>
8000589a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000589e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800058a2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800058a4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800058a8:	58 0a       	cp.w	r10,0
800058aa:	c0 91       	brne	800058bc <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800058ac:	49 59       	lddpc	r9,80005900 <INTC_register_interrupt+0x6c>
800058ae:	49 6a       	lddpc	r10,80005904 <INTC_register_interrupt+0x70>
800058b0:	12 1a       	sub	r10,r9
800058b2:	fe 79 08 00 	mov	r9,-63488
800058b6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058ba:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800058bc:	58 1a       	cp.w	r10,1
800058be:	c0 a1       	brne	800058d2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800058c0:	49 09       	lddpc	r9,80005900 <INTC_register_interrupt+0x6c>
800058c2:	49 2a       	lddpc	r10,80005908 <INTC_register_interrupt+0x74>
800058c4:	12 1a       	sub	r10,r9
800058c6:	bf aa       	sbr	r10,0x1e
800058c8:	fe 79 08 00 	mov	r9,-63488
800058cc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058d0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800058d2:	58 2a       	cp.w	r10,2
800058d4:	c0 a1       	brne	800058e8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800058d6:	48 b9       	lddpc	r9,80005900 <INTC_register_interrupt+0x6c>
800058d8:	48 da       	lddpc	r10,8000590c <INTC_register_interrupt+0x78>
800058da:	12 1a       	sub	r10,r9
800058dc:	bf ba       	sbr	r10,0x1f
800058de:	fe 79 08 00 	mov	r9,-63488
800058e2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058e6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800058e8:	48 69       	lddpc	r9,80005900 <INTC_register_interrupt+0x6c>
800058ea:	48 aa       	lddpc	r10,80005910 <INTC_register_interrupt+0x7c>
800058ec:	12 1a       	sub	r10,r9
800058ee:	ea 1a c0 00 	orh	r10,0xc000
800058f2:	fe 79 08 00 	mov	r9,-63488
800058f6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058fa:	5e fc       	retal	r12
800058fc:	80 01       	ld.sh	r1,r0[0x0]
800058fe:	88 9c       	ld.uh	r12,r4[0x2]
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	fa 00       	*unknown*
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	fb 04 80 00 	ld.sh	r4,sp[-32768]
8000590a:	fb 12 80 00 	ld.uh	r2,sp[-32768]
8000590e:	fb 20 80 00 	ld.sb	r0,sp[-32768]
80005912:	fb 2e d4 21 	ld.sb	lr,sp[-11231]

80005914 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005914:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005916:	49 18       	lddpc	r8,80005958 <INTC_init_interrupts+0x44>
80005918:	e3 b8 00 01 	mtsr	0x4,r8
8000591c:	49 0e       	lddpc	lr,8000595c <INTC_init_interrupts+0x48>
8000591e:	30 07       	mov	r7,0
80005920:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005922:	49 0c       	lddpc	r12,80005960 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005924:	49 05       	lddpc	r5,80005964 <INTC_init_interrupts+0x50>
80005926:	10 15       	sub	r5,r8
80005928:	fe 76 08 00 	mov	r6,-63488
8000592c:	c1 08       	rjmp	8000594c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000592e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005930:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005932:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005934:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005938:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000593a:	10 3a       	cp.w	r10,r8
8000593c:	fe 9b ff fc 	brhi	80005934 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005940:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005944:	2f f7       	sub	r7,-1
80005946:	2f 8e       	sub	lr,-8
80005948:	59 37       	cp.w	r7,19
8000594a:	c0 50       	breq	80005954 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000594c:	7c 08       	ld.w	r8,lr[0x0]
8000594e:	58 08       	cp.w	r8,0
80005950:	ce f1       	brne	8000592e <INTC_init_interrupts+0x1a>
80005952:	cf 7b       	rjmp	80005940 <INTC_init_interrupts+0x2c>
80005954:	d8 22       	popm	r4-r7,pc
80005956:	00 00       	add	r0,r0
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	fa 00       	*unknown*
8000595c:	80 01       	ld.sh	r1,r0[0x0]
8000595e:	88 9c       	ld.uh	r12,r4[0x2]
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	58 90       	cp.w	r0,9
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	fb 04 fe 78 	ld.sh	r4,sp[-392]

80005968 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005968:	fe 78 08 00 	mov	r8,-63488
8000596c:	e0 69 00 83 	mov	r9,131
80005970:	f2 0c 01 0c 	sub	r12,r9,r12
80005974:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005978:	f2 ca ff c0 	sub	r10,r9,-64
8000597c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005980:	58 08       	cp.w	r8,0
80005982:	c0 21       	brne	80005986 <_get_interrupt_handler+0x1e>
80005984:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005986:	f0 08 12 00 	clz	r8,r8
8000598a:	48 5a       	lddpc	r10,8000599c <_get_interrupt_handler+0x34>
8000598c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005990:	f0 08 11 1f 	rsub	r8,r8,31
80005994:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005996:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000599a:	5e fc       	retal	r12
8000599c:	80 01       	ld.sh	r1,r0[0x0]
8000599e:	88 9c       	ld.uh	r12,r4[0x2]

800059a0 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
800059a0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800059a4:	30 18       	mov	r8,1
800059a6:	f0 09 18 00 	cp.b	r9,r8
800059aa:	e0 88 00 04 	brls	800059b2 <spi_initMaster+0x12>
800059ae:	30 2c       	mov	r12,2
800059b0:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
800059b2:	e0 68 00 80 	mov	r8,128
800059b6:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
800059b8:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
800059ba:	30 19       	mov	r9,1
800059bc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
800059c0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800059c4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
800059c8:	30 09       	mov	r9,0
800059ca:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800059ce:	30 fa       	mov	r10,15
800059d0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
800059d4:	99 18       	st.w	r12[0x4],r8
800059d6:	5e f9       	retal	r9

800059d8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
800059d8:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
800059da:	30 18       	mov	r8,1
800059dc:	f0 0b 18 00 	cp.b	r11,r8
800059e0:	5f be       	srhi	lr
800059e2:	f0 0a 18 00 	cp.b	r10,r8
800059e6:	5f b8       	srhi	r8
800059e8:	fd e8 10 08 	or	r8,lr,r8
800059ec:	c0 30       	breq	800059f2 <spi_selectionMode+0x1a>
800059ee:	30 2c       	mov	r12,2
800059f0:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
800059f2:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
800059f4:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800059f8:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
800059fc:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005a00:	99 18       	st.w	r12[0x4],r8
80005a02:	d8 0a       	popm	pc,r12=0

80005a04 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a04:	78 18       	ld.w	r8,r12[0x4]
80005a06:	ea 18 00 0f 	orh	r8,0xf
80005a0a:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a0c:	78 18       	ld.w	r8,r12[0x4]
80005a0e:	e2 18 00 04 	andl	r8,0x4,COH
80005a12:	c0 f0       	breq	80005a30 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005a14:	30 e8       	mov	r8,14
80005a16:	f0 0b 18 00 	cp.b	r11,r8
80005a1a:	e0 8b 00 19 	brhi	80005a4c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005a1e:	78 18       	ld.w	r8,r12[0x4]
80005a20:	b1 6b       	lsl	r11,0x10
80005a22:	ea 1b ff f0 	orh	r11,0xfff0
80005a26:	e8 1b ff ff 	orl	r11,0xffff
80005a2a:	10 6b       	and	r11,r8
80005a2c:	99 1b       	st.w	r12[0x4],r11
80005a2e:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005a30:	30 38       	mov	r8,3
80005a32:	f0 0b 18 00 	cp.b	r11,r8
80005a36:	e0 8b 00 0b 	brhi	80005a4c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a3a:	78 18       	ld.w	r8,r12[0x4]
80005a3c:	2f 0b       	sub	r11,-16
80005a3e:	30 19       	mov	r9,1
80005a40:	f2 0b 09 4b 	lsl	r11,r9,r11
80005a44:	5c db       	com	r11
80005a46:	10 6b       	and	r11,r8
80005a48:	99 1b       	st.w	r12[0x4],r11
80005a4a:	5e fd       	retal	0
80005a4c:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005a4e:	5e fc       	retal	r12

80005a50 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005a50:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a54:	c0 58       	rjmp	80005a5e <spi_unselectChip+0xe>
    if (!timeout--) {
80005a56:	58 08       	cp.w	r8,0
80005a58:	c0 21       	brne	80005a5c <spi_unselectChip+0xc>
80005a5a:	5e ff       	retal	1
80005a5c:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a5e:	78 49       	ld.w	r9,r12[0x10]
80005a60:	e2 19 02 00 	andl	r9,0x200,COH
80005a64:	cf 90       	breq	80005a56 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a66:	78 18       	ld.w	r8,r12[0x4]
80005a68:	ea 18 00 0f 	orh	r8,0xf
80005a6c:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005a6e:	fc 18 01 00 	movh	r8,0x100
80005a72:	99 08       	st.w	r12[0x0],r8
80005a74:	5e fd       	retal	0

80005a76 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005a76:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005a7a:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005a7e:	30 39       	mov	r9,3
80005a80:	f2 08 18 00 	cp.b	r8,r9
80005a84:	e0 8b 00 57 	brhi	80005b32 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005a88:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005a8c:	30 1e       	mov	lr,1
80005a8e:	fc 09 18 00 	cp.b	r9,lr
80005a92:	e0 8b 00 50 	brhi	80005b32 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005a96:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005a9a:	30 77       	mov	r7,7
80005a9c:	ee 0e 18 00 	cp.b	lr,r7
80005aa0:	e0 88 00 49 	brls	80005b32 <spi_setupChipReg+0xbc>
80005aa4:	31 07       	mov	r7,16
80005aa6:	ee 0e 18 00 	cp.b	lr,r7
80005aaa:	e0 8b 00 44 	brhi	80005b32 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005aae:	76 17       	ld.w	r7,r11[0x4]
80005ab0:	ee 06 16 01 	lsr	r6,r7,0x1
80005ab4:	0c 0a       	add	r10,r6
80005ab6:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005aba:	ec c7 00 01 	sub	r7,r6,1
80005abe:	e0 47 00 fe 	cp.w	r7,254
80005ac2:	e0 8b 00 38 	brhi	80005b32 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005ac6:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005ac8:	58 06       	cp.w	r6,0
80005aca:	c3 45       	brlt	80005b32 <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005acc:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005ace:	f0 06 16 01 	lsr	r6,r8,0x1
80005ad2:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005ad6:	ec 18 00 01 	eorl	r8,0x1
80005ada:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005ade:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005ae2:	20 8e       	sub	lr,8
80005ae4:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005ae8:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005aec:	f7 38 00 09 	ld.ub	r8,r11[9]
80005af0:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005af4:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005af8:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005afc:	17 88       	ld.ub	r8,r11[0x0]
80005afe:	30 19       	mov	r9,1
80005b00:	f2 08 18 00 	cp.b	r8,r9
80005b04:	c0 e0       	breq	80005b20 <spi_setupChipReg+0xaa>
80005b06:	c0 a3       	brcs	80005b1a <spi_setupChipReg+0xa4>
80005b08:	30 29       	mov	r9,2
80005b0a:	f2 08 18 00 	cp.b	r8,r9
80005b0e:	c0 c0       	breq	80005b26 <spi_setupChipReg+0xb0>
80005b10:	30 39       	mov	r9,3
80005b12:	f2 08 18 00 	cp.b	r8,r9
80005b16:	c0 e1       	brne	80005b32 <spi_setupChipReg+0xbc>
80005b18:	c0 a8       	rjmp	80005b2c <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005b1a:	99 ca       	st.w	r12[0x30],r10
80005b1c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005b20:	99 da       	st.w	r12[0x34],r10
80005b22:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005b26:	99 ea       	st.w	r12[0x38],r10
80005b28:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005b2c:	99 fa       	st.w	r12[0x3c],r10
80005b2e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005b32:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005b34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005b38 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005b38:	30 18       	mov	r8,1
80005b3a:	99 08       	st.w	r12[0x0],r8
}
80005b3c:	5e fc       	retal	r12

80005b3e <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005b3e:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005b42:	c0 58       	rjmp	80005b4c <spi_write+0xe>
    if (!timeout--) {
80005b44:	58 08       	cp.w	r8,0
80005b46:	c0 21       	brne	80005b4a <spi_write+0xc>
80005b48:	5e ff       	retal	1
80005b4a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005b4c:	78 49       	ld.w	r9,r12[0x10]
80005b4e:	e2 19 00 02 	andl	r9,0x2,COH
80005b52:	cf 90       	breq	80005b44 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005b54:	5c 7b       	castu.h	r11
80005b56:	99 3b       	st.w	r12[0xc],r11
80005b58:	5e fd       	retal	0

80005b5a <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005b5a:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005b5e:	c0 58       	rjmp	80005b68 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005b60:	58 08       	cp.w	r8,0
80005b62:	c0 21       	brne	80005b66 <spi_read+0xc>
80005b64:	5e ff       	retal	1
80005b66:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005b68:	78 49       	ld.w	r9,r12[0x10]
80005b6a:	e2 19 02 01 	andl	r9,0x201,COH
80005b6e:	e0 49 02 01 	cp.w	r9,513
80005b72:	cf 71       	brne	80005b60 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005b74:	78 28       	ld.w	r8,r12[0x8]
80005b76:	b6 08       	st.h	r11[0x0],r8
80005b78:	5e fd       	retal	0

80005b7a <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005b7a:	76 09       	ld.w	r9,r11[0x0]
80005b7c:	58 29       	cp.w	r9,2
80005b7e:	e0 88 00 03 	brls	80005b84 <tc_init_waveform+0xa>
80005b82:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005b84:	76 18       	ld.w	r8,r11[0x4]
80005b86:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005b8a:	af ba       	sbr	r10,0xf
80005b8c:	10 9b       	mov	r11,r8
80005b8e:	e6 1b c0 00 	andh	r11,0xc000,COH
80005b92:	16 4a       	or	r10,r11
80005b94:	10 9b       	mov	r11,r8
80005b96:	e6 1b 30 00 	andh	r11,0x3000,COH
80005b9a:	16 4a       	or	r10,r11
80005b9c:	10 9b       	mov	r11,r8
80005b9e:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005ba2:	16 4a       	or	r10,r11
80005ba4:	10 9b       	mov	r11,r8
80005ba6:	e6 1b 03 00 	andh	r11,0x300,COH
80005baa:	16 4a       	or	r10,r11
80005bac:	10 9b       	mov	r11,r8
80005bae:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005bb2:	16 4a       	or	r10,r11
80005bb4:	10 9b       	mov	r11,r8
80005bb6:	e6 1b 00 30 	andh	r11,0x30,COH
80005bba:	16 4a       	or	r10,r11
80005bbc:	10 9b       	mov	r11,r8
80005bbe:	e6 1b 00 0c 	andh	r11,0xc,COH
80005bc2:	16 4a       	or	r10,r11
80005bc4:	10 9b       	mov	r11,r8
80005bc6:	e6 1b 00 03 	andh	r11,0x3,COH
80005bca:	16 4a       	or	r10,r11
80005bcc:	10 9b       	mov	r11,r8
80005bce:	e2 1b 60 00 	andl	r11,0x6000,COH
80005bd2:	16 4a       	or	r10,r11
80005bd4:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005bd8:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005bdc:	10 9b       	mov	r11,r8
80005bde:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005be2:	16 4a       	or	r10,r11
80005be4:	10 9b       	mov	r11,r8
80005be6:	e2 1b 03 00 	andl	r11,0x300,COH
80005bea:	16 4a       	or	r10,r11
80005bec:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005bf0:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005bf4:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005bf8:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005bfc:	10 9b       	mov	r11,r8
80005bfe:	e2 1b 00 30 	andl	r11,0x30,COH
80005c02:	16 4a       	or	r10,r11
80005c04:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005c08:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005c0c:	a5 69       	lsl	r9,0x4
80005c0e:	2f f9       	sub	r9,-1
80005c10:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005c14:	5e fd       	retal	0

80005c16 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005c16:	58 2b       	cp.w	r11,2
80005c18:	e0 88 00 03 	brls	80005c1e <tc_start+0x8>
80005c1c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005c1e:	a7 6b       	lsl	r11,0x6
80005c20:	16 0c       	add	r12,r11
80005c22:	30 58       	mov	r8,5
80005c24:	99 08       	st.w	r12[0x0],r8
80005c26:	5e fd       	retal	0

80005c28 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005c28:	58 2b       	cp.w	r11,2
80005c2a:	e0 88 00 03 	brls	80005c30 <tc_read_sr+0x8>
80005c2e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80005c30:	a7 6b       	lsl	r11,0x6
80005c32:	2e 0b       	sub	r11,-32
80005c34:	16 0c       	add	r12,r11
80005c36:	78 0c       	ld.w	r12,r12[0x0]
}
80005c38:	5e fc       	retal	r12

80005c3a <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005c3a:	58 2b       	cp.w	r11,2
80005c3c:	e0 88 00 03 	brls	80005c42 <tc_write_rc+0x8>
80005c40:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80005c42:	f6 08 15 04 	lsl	r8,r11,0x4
80005c46:	2f f8       	sub	r8,-1
80005c48:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005c4c:	e2 18 80 00 	andl	r8,0x8000,COH
80005c50:	c0 c0       	breq	80005c68 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80005c52:	a7 6b       	lsl	r11,0x6
80005c54:	16 0c       	add	r12,r11
80005c56:	2e 4c       	sub	r12,-28
80005c58:	78 08       	ld.w	r8,r12[0x0]
80005c5a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005c5e:	e0 18 00 00 	andl	r8,0x0
80005c62:	f3 e8 10 08 	or	r8,r9,r8
80005c66:	99 08       	st.w	r12[0x0],r8

  return value;
80005c68:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005c6c:	5e fc       	retal	r12

80005c6e <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80005c6e:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80005c72:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005c76:	58 2b       	cp.w	r11,2
80005c78:	e0 88 00 04 	brls	80005c80 <tc_configure_interrupts+0x12>
80005c7c:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005c80:	ee 19 00 01 	eorh	r9,0x1
80005c84:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005c88:	74 08       	ld.w	r8,r10[0x0]
80005c8a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005c8e:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80005c92:	a7 6e       	lsl	lr,0x6
80005c94:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005c98:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005c9c:	0e 4e       	or	lr,r7
80005c9e:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80005ca2:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005ca6:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005caa:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005cae:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80005cb2:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005cb6:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005cba:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005cbe:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005cc2:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005cc6:	f6 0e 15 06 	lsl	lr,r11,0x6
80005cca:	f8 0e 00 0e 	add	lr,r12,lr
80005cce:	2d ce       	sub	lr,-36
80005cd0:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80005cd2:	58 09       	cp.w	r9,0
80005cd4:	c0 20       	breq	80005cd8 <tc_configure_interrupts+0x6a>
80005cd6:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005cd8:	74 08       	ld.w	r8,r10[0x0]
80005cda:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005cde:	e0 65 00 80 	mov	r5,128
80005ce2:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80005ce6:	74 08       	ld.w	r8,r10[0x0]
80005ce8:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005cec:	f9 b4 00 40 	moveq	r4,64
80005cf0:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80005cf4:	74 08       	ld.w	r8,r10[0x0]
80005cf6:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80005cfa:	f9 b3 00 20 	moveq	r3,32
80005cfe:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80005d02:	74 08       	ld.w	r8,r10[0x0]
80005d04:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005d08:	f9 b2 00 10 	moveq	r2,16
80005d0c:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005d10:	74 08       	ld.w	r8,r10[0x0]
80005d12:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005d16:	f9 b6 00 08 	moveq	r6,8
80005d1a:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80005d1e:	74 08       	ld.w	r8,r10[0x0]
80005d20:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80005d24:	f9 b7 00 04 	moveq	r7,4
80005d28:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80005d2c:	74 08       	ld.w	r8,r10[0x0]
80005d2e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005d32:	f9 be 00 02 	moveq	lr,2
80005d36:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005d3a:	74 08       	ld.w	r8,r10[0x0]
80005d3c:	ec 18 00 01 	eorl	r8,0x1
80005d40:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005d44:	eb e8 10 08 	or	r8,r5,r8
80005d48:	08 48       	or	r8,r4
80005d4a:	06 48       	or	r8,r3
80005d4c:	04 48       	or	r8,r2
80005d4e:	0c 48       	or	r8,r6
80005d50:	0e 48       	or	r8,r7
80005d52:	1c 48       	or	r8,lr
80005d54:	f6 0a 15 06 	lsl	r10,r11,0x6
80005d58:	f8 0a 00 0a 	add	r10,r12,r10
80005d5c:	2d 8a       	sub	r10,-40
80005d5e:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80005d60:	a7 6b       	lsl	r11,0x6
80005d62:	2e 0b       	sub	r11,-32
80005d64:	16 0c       	add	r12,r11
80005d66:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005d68:	58 09       	cp.w	r9,0
80005d6a:	c0 31       	brne	80005d70 <tc_configure_interrupts+0x102>
80005d6c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005d70:	d5 03       	csrf	0x10
80005d72:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005d76:	d7 03       	nop

80005d78 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80005d78:	4a 78       	lddpc	r8,80005e14 <twi_master_interrupt_handler+0x9c>
80005d7a:	70 08       	ld.w	r8,r8[0x0]
80005d7c:	70 89       	ld.w	r9,r8[0x20]
80005d7e:	4a 7a       	lddpc	r10,80005e18 <twi_master_interrupt_handler+0xa0>
80005d80:	74 0a       	ld.w	r10,r10[0x0]
80005d82:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80005d86:	12 9a       	mov	r10,r9
80005d88:	e2 1a 01 00 	andl	r10,0x100,COH
80005d8c:	c3 91       	brne	80005dfe <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80005d8e:	12 9a       	mov	r10,r9
80005d90:	e2 1a 00 02 	andl	r10,0x2,COH
80005d94:	c1 70       	breq	80005dc2 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80005d96:	4a 29       	lddpc	r9,80005e1c <twi_master_interrupt_handler+0xa4>
80005d98:	72 0a       	ld.w	r10,r9[0x0]
80005d9a:	70 cb       	ld.w	r11,r8[0x30]
80005d9c:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80005d9e:	72 0a       	ld.w	r10,r9[0x0]
80005da0:	2f fa       	sub	r10,-1
80005da2:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80005da4:	49 f9       	lddpc	r9,80005e20 <twi_master_interrupt_handler+0xa8>
80005da6:	72 0a       	ld.w	r10,r9[0x0]
80005da8:	20 1a       	sub	r10,1
80005daa:	93 0a       	st.w	r9[0x0],r10
80005dac:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80005dae:	58 19       	cp.w	r9,1
80005db0:	f9 b9 00 02 	moveq	r9,2
80005db4:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80005db8:	49 a9       	lddpc	r9,80005e20 <twi_master_interrupt_handler+0xa8>
80005dba:	72 09       	ld.w	r9,r9[0x0]
80005dbc:	58 09       	cp.w	r9,0
80005dbe:	c2 30       	breq	80005e04 <twi_master_interrupt_handler+0x8c>
80005dc0:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80005dc2:	12 9a       	mov	r10,r9
80005dc4:	e2 1a 00 04 	andl	r10,0x4,COH
80005dc8:	c1 70       	breq	80005df6 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80005dca:	49 79       	lddpc	r9,80005e24 <twi_master_interrupt_handler+0xac>
80005dcc:	72 0a       	ld.w	r10,r9[0x0]
80005dce:	20 1a       	sub	r10,1
80005dd0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80005dd2:	72 09       	ld.w	r9,r9[0x0]
80005dd4:	58 09       	cp.w	r9,0
80005dd6:	e0 89 00 0a 	brgt	80005dea <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80005dda:	49 09       	lddpc	r9,80005e18 <twi_master_interrupt_handler+0xa0>
80005ddc:	30 1a       	mov	r10,1
80005dde:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80005de0:	3f fa       	mov	r10,-1
80005de2:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80005de4:	72 09       	ld.w	r9,r9[0x0]
80005de6:	91 99       	st.w	r8[0x24],r9
80005de8:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80005dea:	49 0a       	lddpc	r10,80005e28 <twi_master_interrupt_handler+0xb0>
80005dec:	74 09       	ld.w	r9,r10[0x0]
80005dee:	13 3b       	ld.ub	r11,r9++
80005df0:	91 db       	st.w	r8[0x34],r11
80005df2:	95 09       	st.w	r10[0x0],r9
80005df4:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80005df6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005dfa:	c0 51       	brne	80005e04 <twi_master_interrupt_handler+0x8c>
80005dfc:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80005dfe:	30 1a       	mov	r10,1
80005e00:	48 b9       	lddpc	r9,80005e2c <twi_master_interrupt_handler+0xb4>
80005e02:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80005e04:	3f f9       	mov	r9,-1
80005e06:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80005e08:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80005e0a:	30 09       	mov	r9,0
80005e0c:	48 98       	lddpc	r8,80005e30 <twi_master_interrupt_handler+0xb8>
80005e0e:	b0 89       	st.b	r8[0x0],r9
80005e10:	d6 03       	rete
80005e12:	00 00       	add	r0,r0
80005e14:	00 00       	add	r0,r0
80005e16:	11 34       	ld.ub	r4,r8++
80005e18:	00 00       	add	r0,r0
80005e1a:	11 30       	ld.ub	r0,r8++
80005e1c:	00 00       	add	r0,r0
80005e1e:	11 40       	ld.w	r0,--r8
80005e20:	00 00       	add	r0,r0
80005e22:	11 3c       	ld.ub	r12,r8++
80005e24:	00 00       	add	r0,r0
80005e26:	11 2c       	ld.uh	r12,r8++
80005e28:	00 00       	add	r0,r0
80005e2a:	11 38       	ld.ub	r8,r8++
80005e2c:	00 00       	add	r0,r0
80005e2e:	11 29       	ld.uh	r9,r8++
80005e30:	00 00       	add	r0,r0
80005e32:	11 28       	ld.uh	r8,r8++

80005e34 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80005e34:	eb cd 40 e0 	pushm	r5-r7,lr
80005e38:	18 97       	mov	r7,r12
80005e3a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80005e3c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80005e40:	49 f9       	lddpc	r9,80005ebc <twi_master_init+0x88>
80005e42:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80005e44:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80005e46:	3f f9       	mov	r9,-1
80005e48:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80005e4a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80005e4c:	e0 69 00 80 	mov	r9,128
80005e50:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005e52:	e6 18 00 01 	andh	r8,0x1,COH
80005e56:	c0 21       	brne	80005e5a <twi_master_init+0x26>
      cpu_irq_enable();
80005e58:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80005e5a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005e5c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80005e60:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80005e62:	30 3a       	mov	r10,3
80005e64:	e0 6b 01 60 	mov	r11,352
80005e68:	49 6c       	lddpc	r12,80005ec0 <twi_master_init+0x8c>
80005e6a:	f0 1f 00 17 	mcall	80005ec4 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005e6e:	e6 16 00 01 	andh	r6,0x1,COH
80005e72:	c0 21       	brne	80005e76 <twi_master_init+0x42>
      cpu_irq_enable();
80005e74:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80005e76:	6a 19       	ld.w	r9,r5[0x4]
80005e78:	a1 79       	lsl	r9,0x1
80005e7a:	6a 08       	ld.w	r8,r5[0x0]
80005e7c:	f0 09 0d 08 	divu	r8,r8,r9
80005e80:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005e82:	e0 48 00 ff 	cp.w	r8,255
80005e86:	e0 8b 00 04 	brhi	80005e8e <twi_master_init+0x5a>
80005e8a:	30 09       	mov	r9,0
80005e8c:	c0 f8       	rjmp	80005eaa <twi_master_init+0x76>
80005e8e:	30 09       	mov	r9,0
80005e90:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80005e92:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80005e94:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005e96:	e0 48 00 ff 	cp.w	r8,255
80005e9a:	5f bb       	srhi	r11
80005e9c:	58 69       	cp.w	r9,6
80005e9e:	5f 8a       	srls	r10
80005ea0:	f7 ea 00 0a 	and	r10,r11,r10
80005ea4:	f8 0a 18 00 	cp.b	r10,r12
80005ea8:	cf 51       	brne	80005e92 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80005eaa:	b1 69       	lsl	r9,0x10
80005eac:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80005eb0:	f3 e8 10 08 	or	r8,r9,r8
80005eb4:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80005eb6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80005eba:	00 00       	add	r0,r0
80005ebc:	00 00       	add	r0,r0
80005ebe:	11 34       	ld.ub	r4,r8++
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	5d 78       	*unknown*
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	58 94       	cp.w	r4,9

80005ec8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005ec8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005eca:	f6 08 15 04 	lsl	r8,r11,0x4
80005ece:	14 38       	cp.w	r8,r10
80005ed0:	f9 b8 08 10 	movls	r8,16
80005ed4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005ed8:	f0 0b 02 4b 	mul	r11,r8,r11
80005edc:	f6 09 16 01 	lsr	r9,r11,0x1
80005ee0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005ee4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005ee8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005eec:	f2 cb 00 01 	sub	r11,r9,1
80005ef0:	e0 4b ff fe 	cp.w	r11,65534
80005ef4:	e0 88 00 03 	brls	80005efa <usart_set_async_baudrate+0x32>
80005ef8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005efa:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005efc:	e8 6e 00 00 	mov	lr,524288
80005f00:	59 08       	cp.w	r8,16
80005f02:	fc 08 17 10 	movne	r8,lr
80005f06:	f9 b8 00 00 	moveq	r8,0
80005f0a:	e4 1b ff f7 	andh	r11,0xfff7
80005f0e:	e0 1b fe cf 	andl	r11,0xfecf
80005f12:	16 48       	or	r8,r11
80005f14:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005f16:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005f1a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005f1e:	99 89       	st.w	r12[0x20],r9
80005f20:	d8 0a       	popm	pc,r12=0

80005f22 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005f22:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005f24:	e2 18 00 02 	andl	r8,0x2,COH
80005f28:	c0 31       	brne	80005f2e <usart_write_char+0xc>
80005f2a:	30 2c       	mov	r12,2
80005f2c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005f2e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005f32:	99 7b       	st.w	r12[0x1c],r11
80005f34:	5e fd       	retal	0
80005f36:	d7 03       	nop

80005f38 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005f38:	eb cd 40 e0 	pushm	r5-r7,lr
80005f3c:	18 96       	mov	r6,r12
80005f3e:	16 95       	mov	r5,r11
80005f40:	e0 67 27 0f 	mov	r7,9999
80005f44:	c0 68       	rjmp	80005f50 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005f46:	58 07       	cp.w	r7,0
80005f48:	c0 31       	brne	80005f4e <usart_putchar+0x16>
80005f4a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005f4e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005f50:	0a 9b       	mov	r11,r5
80005f52:	0c 9c       	mov	r12,r6
80005f54:	f0 1f 00 03 	mcall	80005f60 <usart_putchar+0x28>
80005f58:	cf 71       	brne	80005f46 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005f5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005f5e:	00 00       	add	r0,r0
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	5f 22       	srhs	r2

80005f64 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005f64:	78 58       	ld.w	r8,r12[0x14]
80005f66:	e2 18 00 e0 	andl	r8,0xe0,COH
80005f6a:	c0 30       	breq	80005f70 <usart_read_char+0xc>
80005f6c:	30 4c       	mov	r12,4
80005f6e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005f70:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005f72:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005f76:	c0 31       	brne	80005f7c <usart_read_char+0x18>
80005f78:	30 3c       	mov	r12,3
80005f7a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005f7c:	78 68       	ld.w	r8,r12[0x18]
80005f7e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005f82:	97 08       	st.w	r11[0x0],r8
80005f84:	5e fd       	retal	0
80005f86:	d7 03       	nop

80005f88 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005f88:	eb cd 40 c0 	pushm	r6-r7,lr
80005f8c:	20 1d       	sub	sp,4
80005f8e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005f90:	1a 97       	mov	r7,sp
80005f92:	1a 9b       	mov	r11,sp
80005f94:	0c 9c       	mov	r12,r6
80005f96:	f0 1f 00 07 	mcall	80005fb0 <usart_getchar+0x28>
80005f9a:	58 3c       	cp.w	r12,3
80005f9c:	cf b0       	breq	80005f92 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005f9e:	58 4c       	cp.w	r12,4
80005fa0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005fa4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005fa8:	2f fd       	sub	sp,-4
80005faa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fae:	00 00       	add	r0,r0
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	5f 64       	srmi	r4

80005fb4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005fb4:	eb cd 40 c0 	pushm	r6-r7,lr
80005fb8:	18 96       	mov	r6,r12
80005fba:	16 97       	mov	r7,r11
  while (*string != '\0')
80005fbc:	17 8b       	ld.ub	r11,r11[0x0]
80005fbe:	58 0b       	cp.w	r11,0
80005fc0:	c0 80       	breq	80005fd0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005fc2:	2f f7       	sub	r7,-1
80005fc4:	0c 9c       	mov	r12,r6
80005fc6:	f0 1f 00 04 	mcall	80005fd4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005fca:	0f 8b       	ld.ub	r11,r7[0x0]
80005fcc:	58 0b       	cp.w	r11,0
80005fce:	cf a1       	brne	80005fc2 <usart_write_line+0xe>
80005fd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	5f 38       	srlo	r8

80005fd8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005fd8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005fdc:	e6 18 00 01 	andh	r8,0x1,COH
80005fe0:	c0 71       	brne	80005fee <usart_reset+0x16>
80005fe2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005fe4:	3f f8       	mov	r8,-1
80005fe6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005fe8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005fea:	d5 03       	csrf	0x10
80005fec:	c0 48       	rjmp	80005ff4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005fee:	3f f8       	mov	r8,-1
80005ff0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005ff2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005ff4:	30 08       	mov	r8,0
80005ff6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005ff8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005ffa:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005ffc:	ea 68 61 0c 	mov	r8,680204
80006000:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006002:	5e fc       	retal	r12

80006004 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006004:	eb cd 40 e0 	pushm	r5-r7,lr
80006008:	18 96       	mov	r6,r12
8000600a:	16 97       	mov	r7,r11
8000600c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000600e:	f0 1f 00 2f 	mcall	800060c8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006012:	58 07       	cp.w	r7,0
80006014:	c5 80       	breq	800060c4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006016:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006018:	30 49       	mov	r9,4
8000601a:	f2 08 18 00 	cp.b	r8,r9
8000601e:	e0 88 00 53 	brls	800060c4 <usart_init_rs232+0xc0>
80006022:	30 99       	mov	r9,9
80006024:	f2 08 18 00 	cp.b	r8,r9
80006028:	e0 8b 00 4e 	brhi	800060c4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000602c:	0f d9       	ld.ub	r9,r7[0x5]
8000602e:	30 78       	mov	r8,7
80006030:	f0 09 18 00 	cp.b	r9,r8
80006034:	e0 8b 00 48 	brhi	800060c4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006038:	8e 39       	ld.sh	r9,r7[0x6]
8000603a:	e0 68 01 01 	mov	r8,257
8000603e:	f0 09 19 00 	cp.h	r9,r8
80006042:	e0 8b 00 41 	brhi	800060c4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006046:	ef 39 00 08 	ld.ub	r9,r7[8]
8000604a:	30 38       	mov	r8,3
8000604c:	f0 09 18 00 	cp.b	r9,r8
80006050:	e0 8b 00 3a 	brhi	800060c4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006054:	0a 9a       	mov	r10,r5
80006056:	6e 0b       	ld.w	r11,r7[0x0]
80006058:	0c 9c       	mov	r12,r6
8000605a:	f0 1f 00 1d 	mcall	800060cc <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000605e:	58 1c       	cp.w	r12,1
80006060:	c3 20       	breq	800060c4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006062:	0f c8       	ld.ub	r8,r7[0x4]
80006064:	30 99       	mov	r9,9
80006066:	f2 08 18 00 	cp.b	r8,r9
8000606a:	c0 51       	brne	80006074 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000606c:	6c 18       	ld.w	r8,r6[0x4]
8000606e:	b1 b8       	sbr	r8,0x11
80006070:	8d 18       	st.w	r6[0x4],r8
80006072:	c0 68       	rjmp	8000607e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006074:	6c 19       	ld.w	r9,r6[0x4]
80006076:	20 58       	sub	r8,5
80006078:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000607c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000607e:	6c 19       	ld.w	r9,r6[0x4]
80006080:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006084:	0f d8       	ld.ub	r8,r7[0x5]
80006086:	a9 78       	lsl	r8,0x9
80006088:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000608c:	12 48       	or	r8,r9
8000608e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006090:	8e 38       	ld.sh	r8,r7[0x6]
80006092:	30 29       	mov	r9,2
80006094:	f2 08 19 00 	cp.h	r8,r9
80006098:	e0 88 00 09 	brls	800060aa <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000609c:	6c 18       	ld.w	r8,r6[0x4]
8000609e:	ad b8       	sbr	r8,0xd
800060a0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800060a2:	8e b8       	ld.uh	r8,r7[0x6]
800060a4:	20 28       	sub	r8,2
800060a6:	8d a8       	st.w	r6[0x28],r8
800060a8:	c0 68       	rjmp	800060b4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800060aa:	6c 19       	ld.w	r9,r6[0x4]
800060ac:	5c 78       	castu.h	r8
800060ae:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800060b2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800060b4:	6c 18       	ld.w	r8,r6[0x4]
800060b6:	e0 18 ff f0 	andl	r8,0xfff0
800060ba:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800060bc:	35 08       	mov	r8,80
800060be:	8d 08       	st.w	r6[0x0],r8
800060c0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800060c4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	5f d8       	srvc	r8
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	5e c8       	retvs	r8

800060d0 <disk_status>:


	return RES_OK;

	
}
800060d0:	5e fd       	retal	0

800060d2 <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
800060d2:	5e fd       	retal	0

800060d4 <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
800060d4:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
800060d6:	f0 1f 00 0e 	mcall	8000610c <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
800060da:	19 89       	ld.ub	r9,r12[0x0]
800060dc:	19 98       	ld.ub	r8,r12[0x1]
800060de:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800060e2:	f0 c8 07 bc 	sub	r8,r8,1980
800060e6:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
800060e8:	19 aa       	ld.ub	r10,r12[0x2]
800060ea:	b5 7a       	lsl	r10,0x15
800060ec:	19 b9       	ld.ub	r9,r12[0x3]
800060ee:	b1 69       	lsl	r9,0x10
800060f0:	12 0a       	add	r10,r9
	current_time += t->day << 16;
800060f2:	19 f9       	ld.ub	r9,r12[0x7]
800060f4:	a1 99       	lsr	r9,0x1
800060f6:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
800060f8:	19 d9       	ld.ub	r9,r12[0x5]
800060fa:	ab 79       	lsl	r9,0xb
800060fc:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
800060fe:	19 e9       	ld.ub	r9,r12[0x6]
80006100:	a5 79       	lsl	r9,0x5
80006102:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
80006106:	10 0c       	add	r12,r8
80006108:	d8 02       	popm	pc
8000610a:	00 00       	add	r0,r0
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	57 2c       	stdsp	sp[0x1c8],r12

80006110 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
80006110:	eb cd 40 80 	pushm	r7,lr
80006114:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
80006116:	30 18       	mov	r8,1
80006118:	f0 0b 18 00 	cp.b	r11,r8
8000611c:	c1 a0       	breq	80006150 <disk_ioctl+0x40>
8000611e:	58 0b       	cp.w	r11,0
80006120:	c0 c0       	breq	80006138 <disk_ioctl+0x28>
80006122:	30 28       	mov	r8,2
80006124:	f0 0b 18 00 	cp.b	r11,r8
80006128:	c0 a0       	breq	8000613c <disk_ioctl+0x2c>
8000612a:	30 38       	mov	r8,3
8000612c:	f0 0b 18 00 	cp.b	r11,r8
80006130:	c0 b0       	breq	80006146 <disk_ioctl+0x36>
80006132:	30 4c       	mov	r12,4
80006134:	e3 cd 80 80 	ldm	sp++,r7,pc
80006138:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
8000613c:	e0 68 02 00 	mov	r8,512
80006140:	b4 08       	st.h	r10[0x0],r8
80006142:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
80006146:	e0 68 02 00 	mov	r8,512
8000614a:	b4 08       	st.h	r10[0x0],r8
8000614c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
80006150:	f0 1f 00 03 	mcall	8000615c <disk_ioctl+0x4c>
80006154:	8f 0c       	st.w	r7[0x0],r12
80006156:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000615a:	00 00       	add	r0,r0
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	34 44       	mov	r4,68

80006160 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
80006160:	d4 01       	pushm	lr
80006162:	16 9c       	mov	r12,r11
80006164:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
80006166:	5c 59       	castu.b	r9
80006168:	e0 6a 02 00 	mov	r10,512
8000616c:	f0 1f 00 03 	mcall	80006178 <disk_write+0x18>
80006170:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
80006172:	5f 1c       	srne	r12
80006174:	d8 02       	popm	pc
80006176:	00 00       	add	r0,r0
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	34 64       	mov	r4,70

8000617c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
8000617c:	d4 01       	pushm	lr
8000617e:	16 9c       	mov	r12,r11
80006180:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
80006182:	5c 59       	castu.b	r9
80006184:	e0 6a 02 00 	mov	r10,512
80006188:	f0 1f 00 03 	mcall	80006194 <disk_read+0x18>
8000618c:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
8000618e:	5f 1c       	srne	r12
80006190:	d8 02       	popm	pc
80006192:	00 00       	add	r0,r0
80006194:	80 00       	ld.sh	r0,r0[0x0]
80006196:	34 94       	mov	r4,73

80006198 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
80006198:	58 0a       	cp.w	r10,0
8000619a:	5e 0c       	reteq	r12
8000619c:	30 08       	mov	r8,0
		*d++ = *s++;
8000619e:	f6 08 07 09 	ld.ub	r9,r11[r8]
800061a2:	f8 08 0b 09 	st.b	r12[r8],r9
800061a6:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800061a8:	14 38       	cp.w	r8,r10
800061aa:	cf a1       	brne	8000619e <mem_cpy+0x6>
800061ac:	5e fc       	retal	r12

800061ae <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800061ae:	58 0a       	cp.w	r10,0
800061b0:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
800061b2:	18 cb       	st.b	r12++,r11
800061b4:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800061b6:	cf e1       	brne	800061b2 <mem_set+0x4>
800061b8:	5e fc       	retal	r12

800061ba <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
800061ba:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
800061bc:	19 8c       	ld.ub	r12,r12[0x0]
800061be:	58 0c       	cp.w	r12,0
800061c0:	5e 0c       	reteq	r12
800061c2:	16 3c       	cp.w	r12,r11
800061c4:	5e 0c       	reteq	r12
800061c6:	2f f8       	sub	r8,-1
800061c8:	11 8c       	ld.ub	r12,r8[0x0]
800061ca:	58 0c       	cp.w	r12,0
800061cc:	5e 0c       	reteq	r12
800061ce:	16 3c       	cp.w	r12,r11
800061d0:	cf b1       	brne	800061c6 <chk_chr+0xc>
	return *str;
}
800061d2:	5e fc       	retal	r12

800061d4 <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
800061d4:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
800061d6:	78 58       	ld.w	r8,r12[0x14]
800061d8:	20 28       	sub	r8,2
800061da:	10 3b       	cp.w	r11,r8
800061dc:	c0 23       	brcs	800061e0 <clust2sect+0xc>
800061de:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
800061e0:	19 a8       	ld.ub	r8,r12[0x2]
800061e2:	b1 3b       	mul	r11,r8
800061e4:	78 a8       	ld.w	r8,r12[0x28]
800061e6:	f6 08 00 0c 	add	r12,r11,r8
}
800061ea:	5e fc       	retal	r12

800061ec <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
800061ec:	78 9a       	ld.w	r10,r12[0x24]
800061ee:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
800061f0:	78 08       	ld.w	r8,r12[0x0]
800061f2:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800061f4:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
800061f6:	58 0c       	cp.w	r12,0
800061f8:	c1 80       	breq	80006228 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
800061fa:	f6 09 16 09 	lsr	r9,r11,0x9
800061fe:	f2 08 0d 08 	divu	r8,r9,r8
80006202:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006204:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006206:	18 38       	cp.w	r8,r12
80006208:	c0 82       	brcc	80006218 <clmt_clust+0x2c>
8000620a:	c0 b8       	rjmp	80006220 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
8000620c:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
8000620e:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006210:	12 38       	cp.w	r8,r9
80006212:	e0 8b 00 07 	brhi	80006220 <clmt_clust+0x34>
80006216:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006218:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
8000621a:	58 08       	cp.w	r8,0
8000621c:	cf 81       	brne	8000620c <clmt_clust+0x20>
8000621e:	c0 58       	rjmp	80006228 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006220:	74 0c       	ld.w	r12,r10[0x0]
80006222:	f2 0c 00 0c 	add	r12,r9,r12
80006226:	5e fc       	retal	r12
80006228:	5e fd       	retal	0

8000622a <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
8000622a:	f7 39 00 1b 	ld.ub	r9,r11[27]
8000622e:	f7 38 00 1a 	ld.ub	r8,r11[26]
80006232:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
80006236:	19 8a       	ld.ub	r10,r12[0x0]
80006238:	30 39       	mov	r9,3
8000623a:	f2 0a 18 00 	cp.b	r10,r9
8000623e:	c0 91       	brne	80006250 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
80006240:	f7 3a 00 15 	ld.ub	r10,r11[21]
80006244:	f7 39 00 14 	ld.ub	r9,r11[20]
80006248:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000624c:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
80006250:	5e f8       	retal	r8

80006252 <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
80006252:	f9 6b 00 1a 	st.b	r12[26],r11
80006256:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
8000625a:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
8000625e:	b1 8b       	lsr	r11,0x10
80006260:	f9 6b 00 14 	st.b	r12[20],r11
80006264:	a9 8b       	lsr	r11,0x8
80006266:	f9 6b 00 15 	st.b	r12[21],r11
}
8000626a:	5e fc       	retal	r12

8000626c <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
8000626c:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
8000626e:	78 05       	ld.w	r5,r12[0x0]
80006270:	58 05       	cp.w	r5,0
80006272:	c5 50       	breq	8000631c <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
80006274:	0b 84       	ld.ub	r4,r5[0x0]
80006276:	32 08       	mov	r8,32
80006278:	f0 04 18 00 	cp.b	r4,r8
8000627c:	5f b9       	srhi	r9
8000627e:	33 a8       	mov	r8,58
80006280:	f0 04 18 00 	cp.b	r4,r8
80006284:	5f 18       	srne	r8
80006286:	f3 e8 00 08 	and	r8,r9,r8
8000628a:	c0 41       	brne	80006292 <get_ldnumber+0x26>
8000628c:	08 99       	mov	r9,r4
8000628e:	0a 98       	mov	r8,r5
80006290:	c1 28       	rjmp	800062b4 <get_ldnumber+0x48>
80006292:	0a 98       	mov	r8,r5
80006294:	32 06       	mov	r6,32
80006296:	33 a7       	mov	r7,58
80006298:	30 0e       	mov	lr,0
8000629a:	2f f8       	sub	r8,-1
8000629c:	11 89       	ld.ub	r9,r8[0x0]
8000629e:	ec 09 18 00 	cp.b	r9,r6
800062a2:	5f bb       	srhi	r11
800062a4:	ee 09 18 00 	cp.b	r9,r7
800062a8:	5f 1a       	srne	r10
800062aa:	f7 ea 00 0a 	and	r10,r11,r10
800062ae:	fc 0a 18 00 	cp.b	r10,lr
800062b2:	cf 41       	brne	8000629a <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
800062b4:	33 aa       	mov	r10,58
800062b6:	f4 09 18 00 	cp.b	r9,r10
800062ba:	c0 30       	breq	800062c0 <get_ldnumber+0x54>
800062bc:	30 04       	mov	r4,0
800062be:	c3 08       	rjmp	8000631e <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
800062c0:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
800062c2:	58 94       	cp.w	r4,9
800062c4:	5f 8a       	srls	r10
800062c6:	ea c9 ff ff 	sub	r9,r5,-1
800062ca:	12 38       	cp.w	r8,r9
800062cc:	5f 09       	sreq	r9
800062ce:	f5 e9 00 09 	and	r9,r10,r9
800062d2:	c0 60       	breq	800062de <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
800062d4:	58 04       	cp.w	r4,0
800062d6:	c2 31       	brne	8000631c <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
800062d8:	2f f8       	sub	r8,-1
800062da:	99 08       	st.w	r12[0x0],r8
800062dc:	c2 18       	rjmp	8000631e <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
800062de:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
800062e0:	49 17       	lddpc	r7,80006324 <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
800062e2:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
800062e4:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
800062e6:	0f 3a       	ld.ub	r10,r7++
800062e8:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
800062ea:	f2 cb 00 61 	sub	r11,r9,97
800062ee:	ec 0b 18 00 	cp.b	r11,r6
800062f2:	e0 8b 00 03 	brhi	800062f8 <get_ldnumber+0x8c>
800062f6:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
800062f8:	fc 0a 18 00 	cp.b	r10,lr
800062fc:	5f 1b       	srne	r11
800062fe:	f2 0a 18 00 	cp.b	r10,r9
80006302:	5f 09       	sreq	r9
80006304:	f7 e9 00 09 	and	r9,r11,r9
80006308:	fc 09 18 00 	cp.b	r9,lr
8000630c:	ce d1       	brne	800062e6 <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
8000630e:	10 35       	cp.w	r5,r8
80006310:	5f 19       	srne	r9
80006312:	12 4b       	or	r11,r9
80006314:	c0 41       	brne	8000631c <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
80006316:	99 08       	st.w	r12[0x0],r8
80006318:	30 04       	mov	r4,0
8000631a:	c0 28       	rjmp	8000631e <get_ldnumber+0xb2>
8000631c:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
8000631e:	08 9c       	mov	r12,r4
80006320:	d8 22       	popm	r4-r7,pc
80006322:	00 00       	add	r0,r0
80006324:	80 01       	ld.sh	r1,r0[0x0]
80006326:	89 60       	st.w	r4[0x18],r0

80006328 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006328:	eb cd 40 f8 	pushm	r3-r7,lr
8000632c:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
8000632e:	19 c9       	ld.ub	r9,r12[0x4]
80006330:	30 08       	mov	r8,0
80006332:	f0 09 18 00 	cp.b	r9,r8
80006336:	c2 60       	breq	80006382 <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006338:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
8000633a:	f8 c4 ff d0 	sub	r4,r12,-48
8000633e:	30 19       	mov	r9,1
80006340:	0c 9a       	mov	r10,r6
80006342:	08 9b       	mov	r11,r4
80006344:	19 9c       	ld.ub	r12,r12[0x1]
80006346:	f0 1f 00 11 	mcall	80006388 <sync_window+0x60>
8000634a:	c0 30       	breq	80006350 <sync_window+0x28>
8000634c:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
80006350:	30 08       	mov	r8,0
80006352:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
80006354:	6e 89       	ld.w	r9,r7[0x20]
80006356:	ec 09 01 09 	sub	r9,r6,r9
8000635a:	6e 68       	ld.w	r8,r7[0x18]
8000635c:	10 39       	cp.w	r9,r8
8000635e:	c1 22       	brcc	80006382 <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006360:	0f b5       	ld.ub	r5,r7[0x3]
80006362:	58 15       	cp.w	r5,1
80006364:	e0 88 00 0f 	brls	80006382 <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
80006368:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
8000636a:	6e 68       	ld.w	r8,r7[0x18]
8000636c:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
8000636e:	06 99       	mov	r9,r3
80006370:	0c 9a       	mov	r10,r6
80006372:	08 9b       	mov	r11,r4
80006374:	0f 9c       	ld.ub	r12,r7[0x1]
80006376:	f0 1f 00 05 	mcall	80006388 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
8000637a:	20 15       	sub	r5,1
8000637c:	58 15       	cp.w	r5,1
8000637e:	fe 9b ff f6 	brhi	8000636a <sync_window+0x42>
80006382:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006386:	00 00       	add	r0,r0
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	61 60       	ld.w	r0,r0[0x58]

8000638c <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
8000638c:	eb cd 40 e0 	pushm	r5-r7,lr
80006390:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
80006392:	f0 1f 00 31 	mcall	80006454 <sync_fs+0xc8>
80006396:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80006398:	c5 a1       	brne	8000644c <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
8000639a:	0d 89       	ld.ub	r9,r6[0x0]
8000639c:	30 38       	mov	r8,3
8000639e:	f0 09 18 00 	cp.b	r9,r8
800063a2:	c4 e1       	brne	8000643e <sync_fs+0xb2>
800063a4:	0d d9       	ld.ub	r9,r6[0x5]
800063a6:	30 18       	mov	r8,1
800063a8:	f0 09 18 00 	cp.b	r9,r8
800063ac:	c4 91       	brne	8000643e <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
800063ae:	ec c5 ff d0 	sub	r5,r6,-48
800063b2:	e0 6a 02 00 	mov	r10,512
800063b6:	30 0b       	mov	r11,0
800063b8:	0a 9c       	mov	r12,r5
800063ba:	f0 1f 00 28 	mcall	80006458 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
800063be:	35 58       	mov	r8,85
800063c0:	ed 68 02 2e 	st.b	r6[558],r8
800063c4:	3a a8       	mov	r8,-86
800063c6:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
800063ca:	35 28       	mov	r8,82
800063cc:	ed 68 00 30 	st.b	r6[48],r8
800063d0:	ed 68 00 31 	st.b	r6[49],r8
800063d4:	36 18       	mov	r8,97
800063d6:	ed 68 00 32 	st.b	r6[50],r8
800063da:	34 19       	mov	r9,65
800063dc:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
800063e0:	37 2a       	mov	r10,114
800063e2:	ed 6a 02 14 	st.b	r6[532],r10
800063e6:	ed 6a 02 15 	st.b	r6[533],r10
800063ea:	ed 69 02 16 	st.b	r6[534],r9
800063ee:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
800063f2:	6c 48       	ld.w	r8,r6[0x10]
800063f4:	ed 68 02 18 	st.b	r6[536],r8
800063f8:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800063fc:	ed 69 02 19 	st.b	r6[537],r9
80006400:	f0 09 16 10 	lsr	r9,r8,0x10
80006404:	ed 69 02 1a 	st.b	r6[538],r9
80006408:	b9 88       	lsr	r8,0x18
8000640a:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
8000640e:	6c 38       	ld.w	r8,r6[0xc]
80006410:	ed 68 02 1c 	st.b	r6[540],r8
80006414:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006418:	ed 69 02 1d 	st.b	r6[541],r9
8000641c:	f0 09 16 10 	lsr	r9,r8,0x10
80006420:	ed 69 02 1e 	st.b	r6[542],r9
80006424:	b9 88       	lsr	r8,0x18
80006426:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
8000642a:	6c 7a       	ld.w	r10,r6[0x1c]
8000642c:	2f fa       	sub	r10,-1
8000642e:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
80006430:	30 19       	mov	r9,1
80006432:	0a 9b       	mov	r11,r5
80006434:	0d 9c       	ld.ub	r12,r6[0x1]
80006436:	f0 1f 00 0a 	mcall	8000645c <sync_fs+0xd0>
			fs->fsi_flag = 0;
8000643a:	30 08       	mov	r8,0
8000643c:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
8000643e:	30 0a       	mov	r10,0
80006440:	14 9b       	mov	r11,r10
80006442:	0d 9c       	ld.ub	r12,r6[0x1]
80006444:	f0 1f 00 07 	mcall	80006460 <sync_fs+0xd4>
80006448:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
8000644c:	0e 9c       	mov	r12,r7
8000644e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006452:	00 00       	add	r0,r0
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	63 28       	ld.w	r8,r1[0x48]
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	61 ae       	ld.w	lr,r0[0x68]
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	61 60       	ld.w	r0,r0[0x58]
80006460:	80 00       	ld.sh	r0,r0[0x0]
80006462:	61 10       	ld.w	r0,r0[0x44]

80006464 <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
80006464:	d4 31       	pushm	r0-r7,lr
80006466:	20 ad       	sub	sp,40
80006468:	50 7c       	stdsp	sp[0x1c],r12
8000646a:	16 97       	mov	r7,r11
8000646c:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
8000646e:	30 18       	mov	r8,1
80006470:	f0 0b 18 00 	cp.b	r11,r8
80006474:	e0 88 00 05 	brls	8000647e <f_mkfs+0x1a>
80006478:	31 3c       	mov	r12,19
8000647a:	e0 8f 03 16 	bral	80006aa6 <f_mkfs+0x642>
	vol = get_ldnumber(&path);
8000647e:	fa cc ff e4 	sub	r12,sp,-28
80006482:	f0 1f 01 8e 	mcall	80006ab8 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
80006486:	c0 44       	brge	8000648e <f_mkfs+0x2a>
80006488:	30 bc       	mov	r12,11
8000648a:	e0 8f 03 0e 	bral	80006aa6 <f_mkfs+0x642>
	fs = FatFs[vol];
8000648e:	fe f8 06 2e 	ld.w	r8,pc[1582]
80006492:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
80006496:	58 05       	cp.w	r5,0
80006498:	c0 41       	brne	800064a0 <f_mkfs+0x3c>
8000649a:	30 cc       	mov	r12,12
8000649c:	e0 8f 03 05 	bral	80006aa6 <f_mkfs+0x642>
	fs->fs_type = 0;
800064a0:	30 08       	mov	r8,0
800064a2:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
800064a4:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
800064a8:	08 9c       	mov	r12,r4
800064aa:	f0 1f 01 86 	mcall	80006ac0 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
800064ae:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800064b2:	c0 40       	breq	800064ba <f_mkfs+0x56>
800064b4:	30 3c       	mov	r12,3
800064b6:	e0 8f 02 f8 	bral	80006aa6 <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
800064ba:	e2 1c 00 04 	andl	r12,0x4,COH
800064be:	c0 40       	breq	800064c6 <f_mkfs+0x62>
800064c0:	30 ac       	mov	r12,10
800064c2:	e0 8f 02 f2 	bral	80006aa6 <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
800064c6:	fa ca ff e0 	sub	r10,sp,-32
800064ca:	30 1b       	mov	r11,1
800064cc:	08 9c       	mov	r12,r4
800064ce:	f0 1f 01 7e 	mcall	80006ac4 <f_mkfs+0x660>
800064d2:	e0 81 02 e7 	brne	80006aa0 <f_mkfs+0x63c>
800064d6:	40 89       	lddsp	r9,sp[0x20]
800064d8:	e0 49 00 7f 	cp.w	r9,127
800064dc:	e0 88 02 e2 	brls	80006aa0 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
800064e0:	58 07       	cp.w	r7,0
800064e2:	f9 b1 01 00 	movne	r1,0
800064e6:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
800064ea:	02 19       	sub	r9,r1
800064ec:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
800064ee:	ec c8 00 01 	sub	r8,r6,1
800064f2:	0c 68       	and	r8,r6
800064f4:	c0 31       	brne	800064fa <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
800064f6:	58 06       	cp.w	r6,0
800064f8:	c1 a1       	brne	8000652c <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
800064fa:	e0 6b 4d d3 	mov	r11,19923
800064fe:	ea 1b 10 62 	orh	r11,0x1062
80006502:	f2 0b 06 4a 	mulu.d	r10,r9,r11
80006506:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
8000650a:	e0 4c 04 00 	cp.w	r12,1024
8000650e:	c0 33       	brcs	80006514 <f_mkfs+0xb0>
80006510:	30 08       	mov	r8,0
80006512:	c0 98       	rjmp	80006524 <f_mkfs+0xc0>
80006514:	fe fa 05 b4 	ld.w	r10,pc[1460]
80006518:	2f ea       	sub	r10,-2
8000651a:	30 08       	mov	r8,0
8000651c:	2f f8       	sub	r8,-1
8000651e:	15 2b       	ld.uh	r11,r10++
80006520:	16 3c       	cp.w	r12,r11
80006522:	cf d3       	brcs	8000651c <f_mkfs+0xb8>
		au = cst[i];
80006524:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006528:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
8000652c:	e0 46 01 ff 	cp.w	r6,511
80006530:	e0 88 00 03 	brls	80006536 <f_mkfs+0xd2>
80006534:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
80006536:	58 06       	cp.w	r6,0
80006538:	f9 b6 00 01 	moveq	r6,1
8000653c:	e0 60 00 80 	mov	r0,128
80006540:	00 36       	cp.w	r6,r0
80006542:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
80006546:	f2 00 0d 0a 	divu	r10,r9,r0
8000654a:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
8000654c:	e0 4a 0f f6 	cp.w	r10,4086
80006550:	f9 b3 03 01 	movlo	r3,1
80006554:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
80006558:	e0 4a ff f5 	cp.w	r10,65525
8000655c:	e0 88 00 04 	brls	80006564 <f_mkfs+0x100>
80006560:	30 33       	mov	r3,3
80006562:	c0 58       	rjmp	8000656c <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
80006564:	30 3a       	mov	r10,3
80006566:	f4 03 18 00 	cp.b	r3,r10
8000656a:	c0 a1       	brne	8000657e <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
8000656c:	a3 68       	lsl	r8,0x2
8000656e:	f0 c2 fd f9 	sub	r2,r8,-519
80006572:	a9 92       	lsr	r2,0x9
80006574:	30 0b       	mov	r11,0
80006576:	50 2b       	stdsp	sp[0x8],r11
80006578:	32 0a       	mov	r10,32
8000657a:	50 0a       	stdsp	sp[0x0],r10
8000657c:	c1 68       	rjmp	800065a8 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
8000657e:	30 1a       	mov	r10,1
80006580:	f4 03 18 00 	cp.b	r3,r10
80006584:	c0 81       	brne	80006594 <f_mkfs+0x130>
80006586:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000658a:	f0 c2 ff ff 	sub	r2,r8,-1
8000658e:	a1 92       	lsr	r2,0x1
80006590:	2f d2       	sub	r2,-3
80006592:	c0 48       	rjmp	8000659a <f_mkfs+0x136>
80006594:	2f e8       	sub	r8,-2
80006596:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
8000659a:	e4 c2 fe 01 	sub	r2,r2,-511
8000659e:	a9 92       	lsr	r2,0x9
800065a0:	32 08       	mov	r8,32
800065a2:	50 28       	stdsp	sp[0x8],r8
800065a4:	30 1c       	mov	r12,1
800065a6:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
800065a8:	40 0b       	lddsp	r11,sp[0x0]
800065aa:	02 0b       	add	r11,r1
800065ac:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
800065ae:	40 26       	lddsp	r6,sp[0x8]
800065b0:	04 06       	add	r6,r2
800065b2:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
800065b4:	e0 01 01 08 	sub	r8,r0,r1
800065b8:	0c 08       	add	r8,r6
800065ba:	10 39       	cp.w	r9,r8
800065bc:	e0 83 02 74 	brlo	80006aa4 <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
800065c0:	fa ca ff dc 	sub	r10,sp,-36
800065c4:	30 3b       	mov	r11,3
800065c6:	08 9c       	mov	r12,r4
800065c8:	f0 1f 01 3f 	mcall	80006ac4 <f_mkfs+0x660>
800065cc:	c0 81       	brne	800065dc <f_mkfs+0x178>
800065ce:	40 98       	lddsp	r8,sp[0x24]
800065d0:	58 08       	cp.w	r8,0
800065d2:	c0 50       	breq	800065dc <f_mkfs+0x178>
800065d4:	e0 48 80 00 	cp.w	r8,32768
800065d8:	e0 88 00 04 	brls	800065e0 <f_mkfs+0x17c>
800065dc:	30 18       	mov	r8,1
800065de:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
800065e0:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
800065e2:	f0 c9 00 01 	sub	r9,r8,1
800065e6:	0c 09       	add	r9,r6
800065e8:	5c 38       	neg	r8
800065ea:	f3 e8 00 08 	and	r8,r9,r8
800065ee:	f0 06 01 06 	sub	r6,r8,r6
800065f2:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
800065f4:	30 38       	mov	r8,3
800065f6:	f0 03 18 00 	cp.b	r3,r8
800065fa:	c1 d1       	brne	80006634 <f_mkfs+0x1d0>
		n_rsv += n;
800065fc:	40 0a       	lddsp	r10,sp[0x0]
800065fe:	0c 0a       	add	r10,r6
80006600:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
80006602:	40 19       	lddsp	r9,sp[0x4]
80006604:	0c 09       	add	r9,r6
80006606:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006608:	40 88       	lddsp	r8,sp[0x20]
8000660a:	f0 0a 01 0b 	sub	r11,r8,r10
8000660e:	04 1b       	sub	r11,r2
80006610:	40 2c       	lddsp	r12,sp[0x8]
80006612:	18 1b       	sub	r11,r12
80006614:	f6 00 0d 0a 	divu	r10,r11,r0
80006618:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
8000661a:	30 39       	mov	r9,3
8000661c:	f2 03 18 00 	cp.b	r3,r9
80006620:	5f 0b       	sreq	r11
80006622:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006624:	e0 4a ff f5 	cp.w	r10,65525
80006628:	5f 89       	srls	r9
8000662a:	f7 e9 00 09 	and	r9,r11,r9
8000662e:	e0 81 02 3b 	brne	80006aa4 <f_mkfs+0x640>
80006632:	c1 a8       	rjmp	80006666 <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006634:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006636:	40 88       	lddsp	r8,sp[0x20]
80006638:	40 0a       	lddsp	r10,sp[0x0]
8000663a:	f0 0a 01 0b 	sub	r11,r8,r10
8000663e:	04 1b       	sub	r11,r2
80006640:	40 29       	lddsp	r9,sp[0x8]
80006642:	12 1b       	sub	r11,r9
80006644:	f6 00 0d 0a 	divu	r10,r11,r0
80006648:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
8000664a:	30 29       	mov	r9,2
8000664c:	f2 03 18 00 	cp.b	r3,r9
80006650:	5f 0a       	sreq	r10
80006652:	40 4c       	lddsp	r12,sp[0x10]
80006654:	e0 4c 0f f5 	cp.w	r12,4085
80006658:	5f 89       	srls	r9
8000665a:	f5 e9 00 09 	and	r9,r10,r9
8000665e:	e0 80 02 26 	breq	80006aaa <f_mkfs+0x646>
80006662:	e0 8f 02 21 	bral	80006aa4 <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006666:	40 3b       	lddsp	r11,sp[0xc]
80006668:	58 0b       	cp.w	r11,0
8000666a:	c0 30       	breq	80006670 <f_mkfs+0x20c>
8000666c:	30 c6       	mov	r6,12
8000666e:	c1 28       	rjmp	80006692 <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
80006670:	30 19       	mov	r9,1
80006672:	f2 03 18 00 	cp.b	r3,r9
80006676:	c0 71       	brne	80006684 <f_mkfs+0x220>
80006678:	e0 48 ff ff 	cp.w	r8,65535
8000667c:	e0 8b 00 0a 	brhi	80006690 <f_mkfs+0x22c>
80006680:	30 16       	mov	r6,1
80006682:	c0 88       	rjmp	80006692 <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
80006684:	e0 48 ff ff 	cp.w	r8,65535
80006688:	e0 8b 00 04 	brhi	80006690 <f_mkfs+0x22c>
8000668c:	30 46       	mov	r6,4
8000668e:	c0 28       	rjmp	80006692 <f_mkfs+0x22e>
80006690:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
80006692:	58 07       	cp.w	r7,0
80006694:	c0 40       	breq	8000669c <f_mkfs+0x238>
80006696:	e0 67 00 f0 	mov	r7,240
8000669a:	c5 68       	rjmp	80006746 <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
8000669c:	ea ca ff d0 	sub	r10,r5,-48
800066a0:	50 5a       	stdsp	sp[0x14],r10
800066a2:	e0 6a 02 00 	mov	r10,512
800066a6:	30 0b       	mov	r11,0
800066a8:	40 5c       	lddsp	r12,sp[0x14]
800066aa:	f0 1f 01 0a 	mcall	80006ad0 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
800066ae:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
800066b2:	30 19       	mov	r9,1
800066b4:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
800066b6:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
800066b8:	30 09       	mov	r9,0
800066ba:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
800066bc:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
800066be:	3f ea       	mov	r10,-2
800066c0:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
800066c2:	40 8b       	lddsp	r11,sp[0x20]
800066c4:	e2 0b 00 0b 	add	r11,r1,r11
800066c8:	e0 6a 56 5b 	mov	r10,22107
800066cc:	ea 1a 05 15 	orh	r10,0x515
800066d0:	f6 0a 06 46 	mulu.d	r6,r11,r10
800066d4:	0e 9c       	mov	r12,r7
800066d6:	f6 0c 01 0a 	sub	r10,r11,r12
800066da:	a1 9a       	lsr	r10,0x1
800066dc:	f4 0c 00 07 	add	r7,r10,r12
800066e0:	ee 0a 16 0d 	lsr	r10,r7,0xd
800066e4:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
800066e6:	ee 0b 16 0f 	lsr	r11,r7,0xf
800066ea:	16 97       	mov	r7,r11
800066ec:	e8 17 00 3f 	orl	r7,0x3f
800066f0:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
800066f2:	40 9a       	lddsp	r10,sp[0x24]
800066f4:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
800066f6:	33 fa       	mov	r10,63
800066f8:	f1 6a 00 08 	st.b	r8[8],r10
800066fc:	f1 69 00 09 	st.b	r8[9],r9
80006700:	f1 69 00 0a 	st.b	r8[10],r9
80006704:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006708:	40 89       	lddsp	r9,sp[0x20]
8000670a:	f1 69 00 0c 	st.b	r8[12],r9
8000670e:	fb 39 00 22 	ld.ub	r9,sp[34]
80006712:	f1 69 00 0d 	st.b	r8[13],r9
80006716:	fb 19 00 20 	ld.uh	r9,sp[32]
8000671a:	f1 69 00 0e 	st.b	r8[14],r9
8000671e:	fb 39 00 20 	ld.ub	r9,sp[32]
80006722:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006726:	35 58       	mov	r8,85
80006728:	eb 68 02 2e 	st.b	r5[558],r8
8000672c:	3a a8       	mov	r8,-86
8000672e:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006732:	30 19       	mov	r9,1
80006734:	30 0a       	mov	r10,0
80006736:	40 5b       	lddsp	r11,sp[0x14]
80006738:	08 9c       	mov	r12,r4
8000673a:	f0 1f 00 e7 	mcall	80006ad4 <f_mkfs+0x670>
8000673e:	e0 81 01 b1 	brne	80006aa0 <f_mkfs+0x63c>
80006742:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006746:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
8000674a:	e0 6a 02 00 	mov	r10,512
8000674e:	30 0b       	mov	r11,0
80006750:	0c 9c       	mov	r12,r6
80006752:	f0 1f 00 e0 	mcall	80006ad0 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006756:	30 ba       	mov	r10,11
80006758:	fe fb 03 80 	ld.w	r11,pc[896]
8000675c:	0c 9c       	mov	r12,r6
8000675e:	f0 1f 00 e0 	mcall	80006adc <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006762:	ea ca ff c5 	sub	r10,r5,-59
80006766:	50 5a       	stdsp	sp[0x14],r10
80006768:	30 08       	mov	r8,0
8000676a:	b4 88       	st.b	r10[0x0],r8
8000676c:	30 28       	mov	r8,2
8000676e:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
80006772:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
80006776:	40 09       	lddsp	r9,sp[0x0]
80006778:	ed 69 00 0e 	st.b	r6[14],r9
8000677c:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
80006780:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
80006784:	30 18       	mov	r8,1
80006786:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
8000678a:	e0 68 02 00 	mov	r8,512
8000678e:	40 3c       	lddsp	r12,sp[0xc]
80006790:	58 0c       	cp.w	r12,0
80006792:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
80006796:	ed 68 00 11 	st.b	r6[17],r8
8000679a:	58 08       	cp.w	r8,0
8000679c:	f9 b8 01 02 	movne	r8,2
800067a0:	f9 b8 00 00 	moveq	r8,0
800067a4:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
800067a8:	40 88       	lddsp	r8,sp[0x20]
800067aa:	e0 48 ff ff 	cp.w	r8,65535
800067ae:	e0 8b 00 09 	brhi	800067c0 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
800067b2:	ed 68 00 13 	st.b	r6[19],r8
800067b6:	fb 38 00 22 	ld.ub	r8,sp[34]
800067ba:	ed 68 00 14 	st.b	r6[20],r8
800067be:	c0 f8       	rjmp	800067dc <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
800067c0:	ed 68 00 20 	st.b	r6[32],r8
800067c4:	fb 38 00 22 	ld.ub	r8,sp[34]
800067c8:	ed 68 00 21 	st.b	r6[33],r8
800067cc:	fb 18 00 20 	ld.uh	r8,sp[32]
800067d0:	ed 68 00 22 	st.b	r6[34],r8
800067d4:	fb 38 00 20 	ld.ub	r8,sp[32]
800067d8:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
800067dc:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
800067e0:	33 f8       	mov	r8,63
800067e2:	ed 68 00 18 	st.b	r6[24],r8
800067e6:	30 08       	mov	r8,0
800067e8:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
800067ec:	3f f9       	mov	r9,-1
800067ee:	ed 69 00 1a 	st.b	r6[26],r9
800067f2:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
800067f6:	ed 61 00 1c 	st.b	r6[28],r1
800067fa:	30 08       	mov	r8,0
800067fc:	ed 68 00 1d 	st.b	r6[29],r8
80006800:	e2 08 16 10 	lsr	r8,r1,0x10
80006804:	ed 68 00 1e 	st.b	r6[30],r8
80006808:	e2 08 16 18 	lsr	r8,r1,0x18
8000680c:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
80006810:	f0 1f 00 b4 	mcall	80006ae0 <f_mkfs+0x67c>
80006814:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
80006816:	40 3a       	lddsp	r10,sp[0xc]
80006818:	58 0a       	cp.w	r10,0
8000681a:	c3 f0       	breq	80006898 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
8000681c:	ed 6c 00 43 	st.b	r6[67],r12
80006820:	fb 38 00 26 	ld.ub	r8,sp[38]
80006824:	ed 68 00 44 	st.b	r6[68],r8
80006828:	fb 18 00 24 	ld.uh	r8,sp[36]
8000682c:	ed 68 00 45 	st.b	r6[69],r8
80006830:	fb 38 00 24 	ld.ub	r8,sp[36]
80006834:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006838:	ed 62 00 24 	st.b	r6[36],r2
8000683c:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006840:	ed 68 00 25 	st.b	r6[37],r8
80006844:	e4 08 16 10 	lsr	r8,r2,0x10
80006848:	ed 68 00 26 	st.b	r6[38],r8
8000684c:	e4 08 16 18 	lsr	r8,r2,0x18
80006850:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
80006854:	30 28       	mov	r8,2
80006856:	ed 68 00 2c 	st.b	r6[44],r8
8000685a:	30 08       	mov	r8,0
8000685c:	ed 68 00 2d 	st.b	r6[45],r8
80006860:	ed 68 00 2e 	st.b	r6[46],r8
80006864:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80006868:	30 19       	mov	r9,1
8000686a:	ed 69 00 30 	st.b	r6[48],r9
8000686e:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
80006872:	30 69       	mov	r9,6
80006874:	ed 69 00 32 	st.b	r6[50],r9
80006878:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
8000687c:	38 08       	mov	r8,-128
8000687e:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
80006882:	32 98       	mov	r8,41
80006884:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
80006888:	31 3a       	mov	r10,19
8000688a:	fe fb 02 5a 	ld.w	r11,pc[602]
8000688e:	ec cc ff b9 	sub	r12,r6,-71
80006892:	f0 1f 00 93 	mcall	80006adc <f_mkfs+0x678>
80006896:	c2 28       	rjmp	800068da <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
80006898:	ed 6c 00 27 	st.b	r6[39],r12
8000689c:	fb 38 00 26 	ld.ub	r8,sp[38]
800068a0:	ed 68 00 28 	st.b	r6[40],r8
800068a4:	fb 18 00 24 	ld.uh	r8,sp[36]
800068a8:	ed 68 00 29 	st.b	r6[41],r8
800068ac:	fb 38 00 24 	ld.ub	r8,sp[36]
800068b0:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
800068b4:	ed 62 00 16 	st.b	r6[22],r2
800068b8:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
800068bc:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
800068c0:	38 08       	mov	r8,-128
800068c2:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
800068c6:	32 98       	mov	r8,41
800068c8:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
800068cc:	31 3a       	mov	r10,19
800068ce:	fe fb 02 1a 	ld.w	r11,pc[538]
800068d2:	ec cc ff d5 	sub	r12,r6,-43
800068d6:	f0 1f 00 82 	mcall	80006adc <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
800068da:	ec c9 fe 02 	sub	r9,r6,-510
800068de:	50 69       	stdsp	sp[0x18],r9
800068e0:	35 58       	mov	r8,85
800068e2:	b2 88       	st.b	r9[0x0],r8
800068e4:	ec c8 fe 01 	sub	r8,r6,-511
800068e8:	50 08       	stdsp	sp[0x0],r8
800068ea:	3a a8       	mov	r8,-86
800068ec:	40 0c       	lddsp	r12,sp[0x0]
800068ee:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
800068f0:	30 19       	mov	r9,1
800068f2:	02 9a       	mov	r10,r1
800068f4:	0c 9b       	mov	r11,r6
800068f6:	08 9c       	mov	r12,r4
800068f8:	f0 1f 00 77 	mcall	80006ad4 <f_mkfs+0x670>
800068fc:	e0 81 00 d2 	brne	80006aa0 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80006900:	40 3b       	lddsp	r11,sp[0xc]
80006902:	58 0b       	cp.w	r11,0
80006904:	c0 80       	breq	80006914 <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
80006906:	30 19       	mov	r9,1
80006908:	e2 ca ff fa 	sub	r10,r1,-6
8000690c:	0c 9b       	mov	r11,r6
8000690e:	08 9c       	mov	r12,r4
80006910:	f0 1f 00 71 	mcall	80006ad4 <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
80006914:	e0 6a 02 00 	mov	r10,512
80006918:	30 0b       	mov	r11,0
8000691a:	0c 9c       	mov	r12,r6
8000691c:	f0 1f 00 6d 	mcall	80006ad0 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006920:	30 38       	mov	r8,3
80006922:	f0 03 18 00 	cp.b	r3,r8
80006926:	c1 d0       	breq	80006960 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006928:	30 18       	mov	r8,1
8000692a:	fe 7a ff 00 	mov	r10,-256
8000692e:	e0 69 ff 00 	mov	r9,65280
80006932:	ea 19 00 ff 	orh	r9,0xff
80006936:	e6 08 18 00 	cp.b	r8,r3
8000693a:	f2 08 17 00 	moveq	r8,r9
8000693e:	f4 08 17 10 	movne	r8,r10
80006942:	f1 e7 10 07 	or	r7,r8,r7
80006946:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006948:	eb 67 00 30 	st.b	r5[48],r7
8000694c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006950:	ac 98       	st.b	r6[0x1],r8
80006952:	fb 18 00 24 	ld.uh	r8,sp[36]
80006956:	ac a8       	st.b	r6[0x2],r8
80006958:	fb 38 00 24 	ld.ub	r8,sp[36]
8000695c:	ac b8       	st.b	r6[0x3],r8
8000695e:	c1 f8       	rjmp	8000699c <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006960:	ea 17 ff ff 	orh	r7,0xffff
80006964:	e8 17 ff 00 	orl	r7,0xff00
80006968:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
8000696a:	eb 67 00 30 	st.b	r5[48],r7
8000696e:	fb 38 00 26 	ld.ub	r8,sp[38]
80006972:	ac 98       	st.b	r6[0x1],r8
80006974:	fb 18 00 24 	ld.uh	r8,sp[36]
80006978:	ac a8       	st.b	r6[0x2],r8
8000697a:	fb 38 00 24 	ld.ub	r8,sp[36]
8000697e:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006980:	3f f8       	mov	r8,-1
80006982:	ac c8       	st.b	r6[0x4],r8
80006984:	ac d8       	st.b	r6[0x5],r8
80006986:	ac e8       	st.b	r6[0x6],r8
80006988:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
8000698a:	ed 68 00 08 	st.b	r6[8],r8
8000698e:	ed 68 00 09 	st.b	r6[9],r8
80006992:	ed 68 00 0a 	st.b	r6[10],r8
80006996:	30 f8       	mov	r8,15
80006998:	40 5a       	lddsp	r10,sp[0x14]
8000699a:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
8000699c:	30 19       	mov	r9,1
8000699e:	40 1a       	lddsp	r10,sp[0x4]
800069a0:	0c 9b       	mov	r11,r6
800069a2:	08 9c       	mov	r12,r4
800069a4:	f0 1f 00 4c 	mcall	80006ad4 <f_mkfs+0x670>
800069a8:	c7 c1       	brne	80006aa0 <f_mkfs+0x63c>
800069aa:	40 13       	lddsp	r3,sp[0x4]
800069ac:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
800069ae:	e0 6a 02 00 	mov	r10,512
800069b2:	30 0b       	mov	r11,0
800069b4:	0c 9c       	mov	r12,r6
800069b6:	f0 1f 00 47 	mcall	80006ad0 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
800069ba:	30 18       	mov	r8,1
800069bc:	50 98       	stdsp	sp[0x24],r8
800069be:	10 32       	cp.w	r2,r8
800069c0:	e0 88 00 11 	brls	800069e2 <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
800069c4:	10 97       	mov	r7,r8
800069c6:	0e 99       	mov	r9,r7
800069c8:	06 9a       	mov	r10,r3
800069ca:	0c 9b       	mov	r11,r6
800069cc:	08 9c       	mov	r12,r4
800069ce:	f0 1f 00 42 	mcall	80006ad4 <f_mkfs+0x670>
800069d2:	c6 71       	brne	80006aa0 <f_mkfs+0x63c>
800069d4:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
800069d6:	40 98       	lddsp	r8,sp[0x24]
800069d8:	2f f8       	sub	r8,-1
800069da:	50 98       	stdsp	sp[0x24],r8
800069dc:	10 32       	cp.w	r2,r8
800069de:	fe 9b ff f4 	brhi	800069c6 <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
800069e2:	40 29       	lddsp	r9,sp[0x8]
800069e4:	40 38       	lddsp	r8,sp[0xc]
800069e6:	58 08       	cp.w	r8,0
800069e8:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
800069ec:	30 12       	mov	r2,1
800069ee:	06 9a       	mov	r10,r3
800069f0:	f4 c7 ff ff 	sub	r7,r10,-1
800069f4:	04 99       	mov	r9,r2
800069f6:	0c 9b       	mov	r11,r6
800069f8:	08 9c       	mov	r12,r4
800069fa:	f0 1f 00 37 	mcall	80006ad4 <f_mkfs+0x670>
800069fe:	c5 11       	brne	80006aa0 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006a00:	20 10       	sub	r0,1
80006a02:	c0 30       	breq	80006a08 <f_mkfs+0x5a4>
80006a04:	0e 9a       	mov	r10,r7
80006a06:	cf 5b       	rjmp	800069f0 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006a08:	40 3c       	lddsp	r12,sp[0xc]
80006a0a:	58 0c       	cp.w	r12,0
80006a0c:	c4 30       	breq	80006a92 <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006a0e:	35 28       	mov	r8,82
80006a10:	eb 68 00 30 	st.b	r5[48],r8
80006a14:	ac 98       	st.b	r6[0x1],r8
80006a16:	36 18       	mov	r8,97
80006a18:	ac a8       	st.b	r6[0x2],r8
80006a1a:	34 19       	mov	r9,65
80006a1c:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006a1e:	37 2a       	mov	r10,114
80006a20:	ed 6a 01 e4 	st.b	r6[484],r10
80006a24:	ed 6a 01 e5 	st.b	r6[485],r10
80006a28:	ed 69 01 e6 	st.b	r6[486],r9
80006a2c:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006a30:	40 48       	lddsp	r8,sp[0x10]
80006a32:	20 18       	sub	r8,1
80006a34:	ed 68 01 e8 	st.b	r6[488],r8
80006a38:	40 48       	lddsp	r8,sp[0x10]
80006a3a:	20 18       	sub	r8,1
80006a3c:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006a40:	ed 68 01 e9 	st.b	r6[489],r8
80006a44:	40 48       	lddsp	r8,sp[0x10]
80006a46:	20 18       	sub	r8,1
80006a48:	f0 09 16 10 	lsr	r9,r8,0x10
80006a4c:	ed 69 01 ea 	st.b	r6[490],r9
80006a50:	b9 88       	lsr	r8,0x18
80006a52:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006a56:	30 28       	mov	r8,2
80006a58:	ed 68 01 ec 	st.b	r6[492],r8
80006a5c:	30 08       	mov	r8,0
80006a5e:	ed 68 01 ed 	st.b	r6[493],r8
80006a62:	ed 68 01 ee 	st.b	r6[494],r8
80006a66:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006a6a:	35 58       	mov	r8,85
80006a6c:	40 6b       	lddsp	r11,sp[0x18]
80006a6e:	b6 88       	st.b	r11[0x0],r8
80006a70:	3a a8       	mov	r8,-86
80006a72:	40 0a       	lddsp	r10,sp[0x0]
80006a74:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006a76:	30 19       	mov	r9,1
80006a78:	e2 09 00 0a 	add	r10,r1,r9
80006a7c:	0c 9b       	mov	r11,r6
80006a7e:	08 9c       	mov	r12,r4
80006a80:	f0 1f 00 15 	mcall	80006ad4 <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006a84:	30 19       	mov	r9,1
80006a86:	e2 ca ff f9 	sub	r10,r1,-7
80006a8a:	0c 9b       	mov	r11,r6
80006a8c:	08 9c       	mov	r12,r4
80006a8e:	f0 1f 00 12 	mcall	80006ad4 <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006a92:	30 0a       	mov	r10,0
80006a94:	14 9b       	mov	r11,r10
80006a96:	08 9c       	mov	r12,r4
80006a98:	f0 1f 00 0b 	mcall	80006ac4 <f_mkfs+0x660>
80006a9c:	5f 1c       	srne	r12
80006a9e:	c0 48       	rjmp	80006aa6 <f_mkfs+0x642>
80006aa0:	30 1c       	mov	r12,1
80006aa2:	c0 28       	rjmp	80006aa6 <f_mkfs+0x642>
80006aa4:	30 ec       	mov	r12,14
}
80006aa6:	2f 6d       	sub	sp,-40
80006aa8:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006aaa:	30 39       	mov	r9,3
80006aac:	f2 03 18 00 	cp.b	r3,r9
80006ab0:	5f 09       	sreq	r9
80006ab2:	50 39       	stdsp	sp[0xc],r9
80006ab4:	fe 9f fd d9 	bral	80006666 <f_mkfs+0x202>
80006ab8:	80 00       	ld.sh	r0,r0[0x0]
80006aba:	62 6c       	ld.w	r12,r1[0x18]
80006abc:	00 00       	add	r0,r0
80006abe:	11 48       	ld.w	r8,--r8
80006ac0:	80 00       	ld.sh	r0,r0[0x0]
80006ac2:	60 d2       	ld.w	r2,r0[0x34]
80006ac4:	80 00       	ld.sh	r0,r0[0x0]
80006ac6:	61 10       	ld.w	r0,r0[0x44]
80006ac8:	80 01       	ld.sh	r1,r0[0x0]
80006aca:	89 4a       	st.w	r4[0x10],r10
80006acc:	80 01       	ld.sh	r1,r0[0x0]
80006ace:	89 34       	st.w	r4[0xc],r4
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	61 ae       	ld.w	lr,r0[0x68]
80006ad4:	80 00       	ld.sh	r0,r0[0x0]
80006ad6:	61 60       	ld.w	r0,r0[0x58]
80006ad8:	80 01       	ld.sh	r1,r0[0x0]
80006ada:	89 64       	st.w	r4[0x18],r4
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	61 98       	ld.w	r8,r0[0x64]
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	60 d4       	ld.w	r4,r0[0x34]
80006ae4:	80 01       	ld.sh	r1,r0[0x0]
80006ae6:	89 70       	st.w	r4[0x1c],r0
80006ae8:	80 01       	ld.sh	r1,r0[0x0]
80006aea:	89 84       	st.w	r4[0x20],r4

80006aec <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006aec:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006aee:	58 0c       	cp.w	r12,0
80006af0:	c1 40       	breq	80006b18 <validate+0x2c>
80006af2:	78 08       	ld.w	r8,r12[0x0]
80006af4:	58 08       	cp.w	r8,0
80006af6:	c1 10       	breq	80006b18 <validate+0x2c>
80006af8:	11 8a       	ld.ub	r10,r8[0x0]
80006afa:	30 09       	mov	r9,0
80006afc:	f2 0a 18 00 	cp.b	r10,r9
80006b00:	c0 c0       	breq	80006b18 <validate+0x2c>
80006b02:	90 3a       	ld.sh	r10,r8[0x6]
80006b04:	98 29       	ld.sh	r9,r12[0x4]
80006b06:	f2 0a 19 00 	cp.h	r10,r9
80006b0a:	c0 71       	brne	80006b18 <validate+0x2c>
80006b0c:	11 9c       	ld.ub	r12,r8[0x1]
80006b0e:	f0 1f 00 04 	mcall	80006b1c <validate+0x30>
80006b12:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006b16:	c0 20       	breq	80006b1a <validate+0x2e>
80006b18:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006b1a:	d8 02       	popm	pc
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	60 d0       	ld.w	r0,r0[0x34]

80006b20 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006b20:	eb cd 40 e0 	pushm	r5-r7,lr
80006b24:	18 97       	mov	r7,r12
80006b26:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006b28:	78 b8       	ld.w	r8,r12[0x2c]
80006b2a:	16 38       	cp.w	r8,r11
80006b2c:	c0 31       	brne	80006b32 <move_window+0x12>
80006b2e:	30 06       	mov	r6,0
80006b30:	c1 18       	rjmp	80006b52 <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006b32:	f0 1f 00 0a 	mcall	80006b58 <move_window+0x38>
80006b36:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006b38:	c0 d1       	brne	80006b52 <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006b3a:	30 19       	mov	r9,1
80006b3c:	0a 9a       	mov	r10,r5
80006b3e:	ee cb ff d0 	sub	r11,r7,-48
80006b42:	0f 9c       	ld.ub	r12,r7[0x1]
80006b44:	f0 1f 00 06 	mcall	80006b5c <move_window+0x3c>
80006b48:	f9 b6 01 01 	movne	r6,1
80006b4c:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006b50:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006b52:	0c 9c       	mov	r12,r6
80006b54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	63 28       	ld.w	r8,r1[0x48]
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	61 7c       	ld.w	r12,r0[0x5c]

80006b60 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006b60:	eb cd 40 80 	pushm	r7,lr
80006b64:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006b66:	30 08       	mov	r8,0
80006b68:	b8 c8       	st.b	r12[0x4],r8
80006b6a:	3f f8       	mov	r8,-1
80006b6c:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006b6e:	f0 1f 00 23 	mcall	80006bf8 <check_fs+0x98>
80006b72:	c0 40       	breq	80006b7a <check_fs+0x1a>
80006b74:	30 3c       	mov	r12,3
80006b76:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006b7a:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006b7e:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006b82:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006b86:	fe 78 aa 55 	mov	r8,-21931
80006b8a:	f0 09 19 00 	cp.h	r9,r8
80006b8e:	c0 40       	breq	80006b96 <check_fs+0x36>
80006b90:	30 2c       	mov	r12,2
80006b92:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
80006b96:	ef 39 00 69 	ld.ub	r9,r7[105]
80006b9a:	ef 38 00 68 	ld.ub	r8,r7[104]
80006b9e:	b1 68       	lsl	r8,0x10
80006ba0:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006ba4:	ef 39 00 66 	ld.ub	r9,r7[102]
80006ba8:	12 48       	or	r8,r9
80006baa:	ef 39 00 67 	ld.ub	r9,r7[103]
80006bae:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006bb2:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006bb6:	e0 69 41 46 	mov	r9,16710
80006bba:	ea 19 00 54 	orh	r9,0x54
80006bbe:	12 38       	cp.w	r8,r9
80006bc0:	c0 31       	brne	80006bc6 <check_fs+0x66>
80006bc2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006bc6:	ef 39 00 85 	ld.ub	r9,r7[133]
80006bca:	ef 38 00 84 	ld.ub	r8,r7[132]
80006bce:	b1 68       	lsl	r8,0x10
80006bd0:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006bd4:	ef 39 00 82 	ld.ub	r9,r7[130]
80006bd8:	12 48       	or	r8,r9
80006bda:	ef 39 00 83 	ld.ub	r9,r7[131]
80006bde:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006be2:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006be6:	e0 69 41 46 	mov	r9,16710
80006bea:	ea 19 00 54 	orh	r9,0x54
80006bee:	12 38       	cp.w	r8,r9
80006bf0:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
80006bf2:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bf6:	00 00       	add	r0,r0
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	6b 20       	ld.w	r0,r5[0x48]

80006bfc <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80006bfc:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80006c00:	20 4d       	sub	sp,16
80006c02:	18 95       	mov	r5,r12
80006c04:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
80006c06:	30 08       	mov	r8,0
80006c08:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80006c0a:	16 9c       	mov	r12,r11
80006c0c:	f0 1f 00 de 	mcall	80006f84 <find_volume+0x388>
80006c10:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
80006c12:	c0 34       	brge	80006c18 <find_volume+0x1c>
80006c14:	30 bc       	mov	r12,11
80006c16:	ca a9       	rjmp	80006f6a <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80006c18:	fe f8 03 70 	ld.w	r8,pc[880]
80006c1c:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80006c20:	58 07       	cp.w	r7,0
80006c22:	c0 31       	brne	80006c28 <find_volume+0x2c>
80006c24:	30 cc       	mov	r12,12
80006c26:	ca 29       	rjmp	80006f6a <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80006c28:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
80006c2a:	0f 89       	ld.ub	r9,r7[0x0]
80006c2c:	30 08       	mov	r8,0
80006c2e:	f0 09 18 00 	cp.b	r9,r8
80006c32:	c0 f0       	breq	80006c50 <find_volume+0x54>
		stat = disk_status(fs->drv);
80006c34:	0f 9c       	ld.ub	r12,r7[0x1]
80006c36:	f0 1f 00 d6 	mcall	80006f8c <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
80006c3a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006c3e:	c0 91       	brne	80006c50 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80006c40:	58 04       	cp.w	r4,0
80006c42:	e0 80 01 91 	breq	80006f64 <find_volume+0x368>
80006c46:	e2 1c 00 04 	andl	r12,0x4,COH
80006c4a:	e0 81 01 8b 	brne	80006f60 <find_volume+0x364>
80006c4e:	c8 b9       	rjmp	80006f64 <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80006c50:	30 08       	mov	r8,0
80006c52:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
80006c54:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80006c58:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
80006c5a:	f0 1f 00 ce 	mcall	80006f90 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
80006c5e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006c62:	c0 30       	breq	80006c68 <find_volume+0x6c>
80006c64:	30 3c       	mov	r12,3
80006c66:	c8 29       	rjmp	80006f6a <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80006c68:	58 04       	cp.w	r4,0
80006c6a:	c0 50       	breq	80006c74 <find_volume+0x78>
80006c6c:	e2 1c 00 04 	andl	r12,0x4,COH
80006c70:	e0 81 01 78 	brne	80006f60 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
80006c74:	30 0b       	mov	r11,0
80006c76:	0e 9c       	mov	r12,r7
80006c78:	f0 1f 00 c7 	mcall	80006f94 <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
80006c7c:	30 18       	mov	r8,1
80006c7e:	f0 0c 18 00 	cp.b	r12,r8
80006c82:	c0 30       	breq	80006c88 <find_volume+0x8c>
80006c84:	30 05       	mov	r5,0
80006c86:	c3 48       	rjmp	80006cee <find_volume+0xf2>
80006c88:	1a 96       	mov	r6,sp
80006c8a:	1a 9a       	mov	r10,sp
80006c8c:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006c90:	30 0c       	mov	r12,0
80006c92:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
80006c94:	f0 c9 ff d0 	sub	r9,r8,-48
80006c98:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006c9c:	13 cb       	ld.ub	r11,r9[0x4]
80006c9e:	f8 0b 18 00 	cp.b	r11,r12
80006ca2:	c0 31       	brne	80006ca8 <find_volume+0xac>
80006ca4:	08 99       	mov	r9,r4
80006ca6:	c0 f8       	rjmp	80006cc4 <find_volume+0xc8>
80006ca8:	f3 35 00 0b 	ld.ub	r5,r9[11]
80006cac:	f3 3b 00 0a 	ld.ub	r11,r9[10]
80006cb0:	b1 6b       	lsl	r11,0x10
80006cb2:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
80006cb6:	f3 35 00 08 	ld.ub	r5,r9[8]
80006cba:	0a 4b       	or	r11,r5
80006cbc:	f3 39 00 09 	ld.ub	r9,r9[9]
80006cc0:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80006cc4:	14 a9       	st.w	r10++,r9
80006cc6:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
80006cc8:	e0 48 01 fe 	cp.w	r8,510
80006ccc:	ce 41       	brne	80006c94 <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
80006cce:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006cd2:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
80006cd4:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006cd6:	58 05       	cp.w	r5,0
80006cd8:	c0 31       	brne	80006cde <find_volume+0xe2>
80006cda:	06 9c       	mov	r12,r3
80006cdc:	c0 68       	rjmp	80006ce8 <find_volume+0xec>
80006cde:	0a 9b       	mov	r11,r5
80006ce0:	0e 9c       	mov	r12,r7
80006ce2:	f0 1f 00 ad 	mcall	80006f94 <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
80006ce6:	c0 d0       	breq	80006d00 <find_volume+0x104>
80006ce8:	2f c6       	sub	r6,-4
80006cea:	08 36       	cp.w	r6,r4
80006cec:	cf 41       	brne	80006cd4 <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80006cee:	30 38       	mov	r8,3
80006cf0:	f0 0c 18 00 	cp.b	r12,r8
80006cf4:	c0 31       	brne	80006cfa <find_volume+0xfe>
80006cf6:	30 1c       	mov	r12,1
80006cf8:	c3 99       	rjmp	80006f6a <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
80006cfa:	58 0c       	cp.w	r12,0
80006cfc:	e0 81 01 36 	brne	80006f68 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80006d00:	ef 39 00 3c 	ld.ub	r9,r7[60]
80006d04:	ef 38 00 3b 	ld.ub	r8,r7[59]
80006d08:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006d0c:	e0 68 02 00 	mov	r8,512
80006d10:	f0 09 19 00 	cp.h	r9,r8
80006d14:	e0 81 01 2a 	brne	80006f68 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
80006d18:	ef 39 00 47 	ld.ub	r9,r7[71]
80006d1c:	ef 38 00 46 	ld.ub	r8,r7[70]
80006d20:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
80006d24:	c1 01       	brne	80006d44 <find_volume+0x148>
80006d26:	ef 39 00 57 	ld.ub	r9,r7[87]
80006d2a:	ef 38 00 56 	ld.ub	r8,r7[86]
80006d2e:	b1 68       	lsl	r8,0x10
80006d30:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006d34:	ef 38 00 54 	ld.ub	r8,r7[84]
80006d38:	f3 e8 10 08 	or	r8,r9,r8
80006d3c:	ef 39 00 55 	ld.ub	r9,r7[85]
80006d40:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
80006d44:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
80006d46:	ef 39 00 40 	ld.ub	r9,r7[64]
80006d4a:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
80006d4c:	f2 cb 00 01 	sub	r11,r9,1
80006d50:	30 1a       	mov	r10,1
80006d52:	f4 0b 18 00 	cp.b	r11,r10
80006d56:	e0 8b 01 09 	brhi	80006f68 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
80006d5a:	ef 3a 00 3d 	ld.ub	r10,r7[61]
80006d5e:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80006d60:	58 0a       	cp.w	r10,0
80006d62:	e0 80 01 03 	breq	80006f68 <find_volume+0x36c>
80006d66:	f4 cb 00 01 	sub	r11,r10,1
80006d6a:	14 6b       	and	r11,r10
80006d6c:	e0 81 00 fe 	brne	80006f68 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80006d70:	ef 3c 00 42 	ld.ub	r12,r7[66]
80006d74:	ef 3b 00 41 	ld.ub	r11,r7[65]
80006d78:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
80006d7c:	5c 8b       	casts.h	r11
80006d7e:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
80006d80:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
80006d84:	e0 81 00 f2 	brne	80006f68 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
80006d88:	ef 36 00 44 	ld.ub	r6,r7[68]
80006d8c:	ef 3c 00 43 	ld.ub	r12,r7[67]
80006d90:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
80006d94:	c1 01       	brne	80006db4 <find_volume+0x1b8>
80006d96:	ef 36 00 53 	ld.ub	r6,r7[83]
80006d9a:	ef 3c 00 52 	ld.ub	r12,r7[82]
80006d9e:	b1 6c       	lsl	r12,0x10
80006da0:	f9 e6 11 86 	or	r6,r12,r6<<0x18
80006da4:	ef 3c 00 50 	ld.ub	r12,r7[80]
80006da8:	ed ec 10 0c 	or	r12,r6,r12
80006dac:	ef 36 00 51 	ld.ub	r6,r7[81]
80006db0:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
80006db4:	ef 34 00 3f 	ld.ub	r4,r7[63]
80006db8:	ef 36 00 3e 	ld.ub	r6,r7[62]
80006dbc:	ed e4 10 86 	or	r6,r6,r4<<0x8
80006dc0:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
80006dc2:	e0 80 00 d3 	breq	80006f68 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
80006dc6:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
80006dc8:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
80006dcc:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
80006dd0:	06 04       	add	r4,r3
80006dd2:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
80006dd4:	08 3c       	cp.w	r12,r4
80006dd6:	e0 83 00 c9 	brlo	80006f68 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
80006dda:	f8 04 01 01 	sub	r1,r12,r4
80006dde:	e2 0a 0d 00 	divu	r0,r1,r10
80006de2:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
80006de4:	58 00       	cp.w	r0,0
80006de6:	e0 80 00 c1 	breq	80006f68 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
80006dea:	e0 40 0f f6 	cp.w	r0,4086
80006dee:	f9 b6 03 01 	movlo	r6,1
80006df2:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
80006df6:	e0 40 ff f5 	cp.w	r0,65525
80006dfa:	e0 8b 00 bb 	brhi	80006f70 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80006dfe:	2f e9       	sub	r9,-2
80006e00:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80006e02:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80006e04:	ea 03 00 03 	add	r3,r5,r3
80006e08:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80006e0a:	0a 04       	add	r4,r5
80006e0c:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80006e0e:	30 3a       	mov	r10,3
80006e10:	f4 06 18 00 	cp.b	r6,r10
80006e14:	c1 61       	brne	80006e40 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
80006e16:	58 0b       	cp.w	r11,0
80006e18:	e0 81 00 a8 	brne	80006f68 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80006e1c:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80006e20:	ef 38 00 5e 	ld.ub	r8,r7[94]
80006e24:	b1 68       	lsl	r8,0x10
80006e26:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80006e2a:	ef 38 00 5c 	ld.ub	r8,r7[92]
80006e2e:	f5 e8 10 08 	or	r8,r10,r8
80006e32:	ef 3a 00 5d 	ld.ub	r10,r7[93]
80006e36:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80006e3a:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
80006e3c:	a3 69       	lsl	r9,0x2
80006e3e:	c1 38       	rjmp	80006e64 <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80006e40:	58 0b       	cp.w	r11,0
80006e42:	e0 80 00 93 	breq	80006f68 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
80006e46:	06 08       	add	r8,r3
80006e48:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
80006e4a:	30 28       	mov	r8,2
80006e4c:	f0 06 18 00 	cp.b	r6,r8
80006e50:	c0 31       	brne	80006e56 <find_volume+0x25a>
80006e52:	a1 79       	lsl	r9,0x1
80006e54:	c0 88       	rjmp	80006e64 <find_volume+0x268>
80006e56:	f2 09 00 18 	add	r8,r9,r9<<0x1
80006e5a:	a1 98       	lsr	r8,0x1
80006e5c:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006e60:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
80006e64:	f2 c8 fe 01 	sub	r8,r9,-511
80006e68:	a9 98       	lsr	r8,0x9
80006e6a:	6e 69       	ld.w	r9,r7[0x18]
80006e6c:	10 39       	cp.w	r9,r8
80006e6e:	c7 d3       	brcs	80006f68 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80006e70:	3f f8       	mov	r8,-1
80006e72:	8f 48       	st.w	r7[0x10],r8
80006e74:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
80006e76:	38 08       	mov	r8,-128
80006e78:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006e7a:	30 38       	mov	r8,3
80006e7c:	f0 06 18 00 	cp.b	r6,r8
80006e80:	c6 81       	brne	80006f50 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
80006e82:	ef 39 00 61 	ld.ub	r9,r7[97]
80006e86:	ef 38 00 60 	ld.ub	r8,r7[96]
80006e8a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006e8e:	30 18       	mov	r8,1
80006e90:	f0 09 19 00 	cp.h	r9,r8
80006e94:	c5 e1       	brne	80006f50 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
80006e96:	ea cb ff ff 	sub	r11,r5,-1
80006e9a:	0e 9c       	mov	r12,r7
80006e9c:	f0 1f 00 3f 	mcall	80006f98 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006ea0:	c5 81       	brne	80006f50 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
80006ea2:	30 08       	mov	r8,0
80006ea4:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
80006ea6:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006eaa:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006eae:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006eb2:	fe 78 aa 55 	mov	r8,-21931
80006eb6:	f0 09 19 00 	cp.h	r9,r8
80006eba:	c4 b1       	brne	80006f50 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
80006ebc:	ef 39 00 33 	ld.ub	r9,r7[51]
80006ec0:	ef 38 00 32 	ld.ub	r8,r7[50]
80006ec4:	b1 68       	lsl	r8,0x10
80006ec6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006eca:	ef 38 00 30 	ld.ub	r8,r7[48]
80006ece:	f3 e8 10 08 	or	r8,r9,r8
80006ed2:	ef 39 00 31 	ld.ub	r9,r7[49]
80006ed6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006eda:	e0 69 52 52 	mov	r9,21074
80006ede:	ea 19 41 61 	orh	r9,0x4161
80006ee2:	12 38       	cp.w	r8,r9
80006ee4:	c3 61       	brne	80006f50 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
80006ee6:	ef 39 02 17 	ld.ub	r9,r7[535]
80006eea:	ef 38 02 16 	ld.ub	r8,r7[534]
80006eee:	b1 68       	lsl	r8,0x10
80006ef0:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006ef4:	ef 38 02 14 	ld.ub	r8,r7[532]
80006ef8:	f3 e8 10 08 	or	r8,r9,r8
80006efc:	ef 39 02 15 	ld.ub	r9,r7[533]
80006f00:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006f04:	e0 69 72 72 	mov	r9,29298
80006f08:	ea 19 61 41 	orh	r9,0x6141
80006f0c:	12 38       	cp.w	r8,r9
80006f0e:	c2 11       	brne	80006f50 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
80006f10:	ef 39 02 1b 	ld.ub	r9,r7[539]
80006f14:	ef 38 02 1a 	ld.ub	r8,r7[538]
80006f18:	b1 68       	lsl	r8,0x10
80006f1a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006f1e:	ef 38 02 18 	ld.ub	r8,r7[536]
80006f22:	f3 e8 10 08 	or	r8,r9,r8
80006f26:	ef 39 02 19 	ld.ub	r9,r7[537]
80006f2a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006f2e:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
80006f30:	ef 39 02 1f 	ld.ub	r9,r7[543]
80006f34:	ef 38 02 1e 	ld.ub	r8,r7[542]
80006f38:	b1 68       	lsl	r8,0x10
80006f3a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006f3e:	ef 38 02 1c 	ld.ub	r8,r7[540]
80006f42:	f3 e8 10 08 	or	r8,r9,r8
80006f46:	ef 39 02 1d 	ld.ub	r9,r7[541]
80006f4a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006f4e:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
80006f50:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
80006f52:	49 39       	lddpc	r9,80006f9c <find_volume+0x3a0>
80006f54:	92 08       	ld.sh	r8,r9[0x0]
80006f56:	2f f8       	sub	r8,-1
80006f58:	b2 08       	st.h	r9[0x0],r8
80006f5a:	ae 38       	st.h	r7[0x6],r8
80006f5c:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
80006f5e:	c0 68       	rjmp	80006f6a <find_volume+0x36e>
80006f60:	30 ac       	mov	r12,10
80006f62:	c0 48       	rjmp	80006f6a <find_volume+0x36e>
80006f64:	30 0c       	mov	r12,0
80006f66:	c0 28       	rjmp	80006f6a <find_volume+0x36e>
80006f68:	30 dc       	mov	r12,13
}
80006f6a:	2f cd       	sub	sp,-16
80006f6c:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80006f70:	2f e9       	sub	r9,-2
80006f72:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80006f74:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80006f76:	ea 03 00 03 	add	r3,r5,r3
80006f7a:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80006f7c:	0a 04       	add	r4,r5
80006f7e:	8f a4       	st.w	r7[0x28],r4
80006f80:	30 36       	mov	r6,3
80006f82:	c4 ab       	rjmp	80006e16 <find_volume+0x21a>
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	62 6c       	ld.w	r12,r1[0x18]
80006f88:	00 00       	add	r0,r0
80006f8a:	11 48       	ld.w	r8,--r8
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	60 d0       	ld.w	r0,r0[0x34]
80006f90:	80 00       	ld.sh	r0,r0[0x0]
80006f92:	60 d2       	ld.w	r2,r0[0x34]
80006f94:	80 00       	ld.sh	r0,r0[0x0]
80006f96:	6b 60       	ld.w	r0,r5[0x58]
80006f98:	80 00       	ld.sh	r0,r0[0x0]
80006f9a:	6b 20       	ld.w	r0,r5[0x48]
80006f9c:	00 00       	add	r0,r0
80006f9e:	11 44       	ld.w	r4,--r8

80006fa0 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
80006fa0:	eb cd 40 40 	pushm	r6,lr
80006fa4:	20 3d       	sub	sp,12
80006fa6:	50 1c       	stdsp	sp[0x4],r12
80006fa8:	50 0b       	stdsp	sp[0x0],r11
80006faa:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
80006fac:	fa cc ff f4 	sub	r12,sp,-12
80006fb0:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
80006fb2:	f0 1f 00 1a 	mcall	80007018 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
80006fb6:	c0 34       	brge	80006fbc <f_mount+0x1c>
80006fb8:	30 bc       	mov	r12,11
80006fba:	c2 58       	rjmp	80007004 <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
80006fbc:	49 88       	lddpc	r8,8000701c <f_mount+0x7c>
80006fbe:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
80006fc2:	58 08       	cp.w	r8,0
80006fc4:	f9 b9 01 00 	movne	r9,0
80006fc8:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
80006fcc:	40 18       	lddsp	r8,sp[0x4]
80006fce:	58 08       	cp.w	r8,0
80006fd0:	c1 d0       	breq	8000700a <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
80006fd2:	30 09       	mov	r9,0
80006fd4:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
80006fd6:	40 18       	lddsp	r8,sp[0x4]
80006fd8:	49 1a       	lddpc	r10,8000701c <f_mount+0x7c>
80006fda:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
80006fde:	58 08       	cp.w	r8,0
80006fe0:	5f 0a       	sreq	r10
80006fe2:	30 18       	mov	r8,1
80006fe4:	f0 06 18 00 	cp.b	r6,r8
80006fe8:	5f 18       	srne	r8
80006fea:	f5 e8 10 08 	or	r8,r10,r8
80006fee:	f2 08 18 00 	cp.b	r8,r9
80006ff2:	c0 30       	breq	80006ff8 <f_mount+0x58>
80006ff4:	30 0c       	mov	r12,0
80006ff6:	c0 78       	rjmp	80007004 <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
80006ff8:	30 0a       	mov	r10,0
80006ffa:	1a 9b       	mov	r11,sp
80006ffc:	fa cc ff fc 	sub	r12,sp,-4
80007000:	f0 1f 00 08 	mcall	80007020 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
80007004:	2f dd       	sub	sp,-12
80007006:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
8000700a:	30 08       	mov	r8,0
8000700c:	48 49       	lddpc	r9,8000701c <f_mount+0x7c>
8000700e:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
80007012:	10 9c       	mov	r12,r8
80007014:	cf 8b       	rjmp	80007004 <f_mount+0x64>
80007016:	00 00       	add	r0,r0
80007018:	80 00       	ld.sh	r0,r0[0x0]
8000701a:	62 6c       	ld.w	r12,r1[0x18]
8000701c:	00 00       	add	r0,r0
8000701e:	11 48       	ld.w	r8,--r8
80007020:	80 00       	ld.sh	r0,r0[0x0]
80007022:	6b fc       	ld.w	r12,r5[0x7c]

80007024 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
80007024:	eb cd 40 c0 	pushm	r6-r7,lr
80007028:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
8000702a:	f0 1f 00 2b 	mcall	800070d4 <f_sync+0xb0>
	if (res == FR_OK) {
8000702e:	c5 11       	brne	800070d0 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
80007030:	0f e8       	ld.ub	r8,r7[0x6]
80007032:	10 99       	mov	r9,r8
80007034:	e2 19 00 20 	andl	r9,0x20,COH
80007038:	c4 c0       	breq	800070d0 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
8000703a:	e2 18 00 40 	andl	r8,0x40,COH
8000703e:	c0 f0       	breq	8000705c <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80007040:	6e 08       	ld.w	r8,r7[0x0]
80007042:	30 19       	mov	r9,1
80007044:	6e 6a       	ld.w	r10,r7[0x18]
80007046:	ee cb ff d8 	sub	r11,r7,-40
8000704a:	11 9c       	ld.ub	r12,r8[0x1]
8000704c:	f0 1f 00 23 	mcall	800070d8 <f_sync+0xb4>
80007050:	c0 30       	breq	80007056 <f_sync+0x32>
80007052:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
80007056:	0f e8       	ld.ub	r8,r7[0x6]
80007058:	a7 c8       	cbr	r8,0x6
8000705a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
8000705c:	6e 7b       	ld.w	r11,r7[0x1c]
8000705e:	6e 0c       	ld.w	r12,r7[0x0]
80007060:	f0 1f 00 1f 	mcall	800070dc <f_sync+0xb8>
			if (res == FR_OK) {
80007064:	c3 61       	brne	800070d0 <f_sync+0xac>
				dir = fp->dir_ptr;
80007066:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
80007068:	ec c8 ff f5 	sub	r8,r6,-11
8000706c:	11 89       	ld.ub	r9,r8[0x0]
8000706e:	a5 b9       	sbr	r9,0x5
80007070:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
80007072:	6e 38       	ld.w	r8,r7[0xc]
80007074:	ed 68 00 1c 	st.b	r6[28],r8
80007078:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000707c:	ed 68 00 1d 	st.b	r6[29],r8
80007080:	8e e8       	ld.uh	r8,r7[0xc]
80007082:	ed 68 00 1e 	st.b	r6[30],r8
80007086:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000708a:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
8000708e:	6e 4b       	ld.w	r11,r7[0x10]
80007090:	0c 9c       	mov	r12,r6
80007092:	f0 1f 00 14 	mcall	800070e0 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
80007096:	f0 1f 00 14 	mcall	800070e4 <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
8000709a:	ed 6c 00 16 	st.b	r6[22],r12
8000709e:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
800070a2:	ed 68 00 17 	st.b	r6[23],r8
800070a6:	f8 08 16 10 	lsr	r8,r12,0x10
800070aa:	ed 68 00 18 	st.b	r6[24],r8
800070ae:	b9 8c       	lsr	r12,0x18
800070b0:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
800070b4:	30 08       	mov	r8,0
800070b6:	ed 68 00 12 	st.b	r6[18],r8
800070ba:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
800070be:	0f e8       	ld.ub	r8,r7[0x6]
800070c0:	a5 d8       	cbr	r8,0x5
800070c2:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
800070c4:	6e 08       	ld.w	r8,r7[0x0]
800070c6:	30 19       	mov	r9,1
800070c8:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
800070ca:	6e 0c       	ld.w	r12,r7[0x0]
800070cc:	f0 1f 00 07 	mcall	800070e8 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
800070d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	6a ec       	ld.w	r12,r5[0x38]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	61 60       	ld.w	r0,r0[0x58]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	6b 20       	ld.w	r0,r5[0x48]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	62 52       	ld.w	r2,r1[0x14]
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	60 d4       	ld.w	r4,r0[0x34]
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	63 8c       	ld.w	r12,r1[0x60]

800070ec <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
800070ec:	eb cd 40 80 	pushm	r7,lr
800070f0:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
800070f2:	f0 1f 00 07 	mcall	8000710c <f_close+0x20>
	if (res == FR_OK)
800070f6:	c0 81       	brne	80007106 <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
800070f8:	0e 9c       	mov	r12,r7
800070fa:	f0 1f 00 06 	mcall	80007110 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
800070fe:	f9 b8 00 00 	moveq	r8,0
80007102:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
80007106:	e3 cd 80 80 	ldm	sp++,r7,pc
8000710a:	00 00       	add	r0,r0
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	70 24       	ld.w	r4,r8[0x8]
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	6a ec       	ld.w	r12,r5[0x38]

80007114 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
80007114:	d4 21       	pushm	r4-r7,lr
80007116:	18 97       	mov	r7,r12
80007118:	16 96       	mov	r6,r11
8000711a:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000711c:	58 1b       	cp.w	r11,1
8000711e:	e0 88 00 90 	brls	8000723e <put_fat+0x12a>
80007122:	78 58       	ld.w	r8,r12[0x14]
80007124:	10 3b       	cp.w	r11,r8
80007126:	e0 82 00 8c 	brhs	8000723e <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
8000712a:	19 88       	ld.ub	r8,r12[0x0]
8000712c:	30 29       	mov	r9,2
8000712e:	f2 08 18 00 	cp.b	r8,r9
80007132:	c4 d0       	breq	800071cc <put_fat+0xb8>
80007134:	30 39       	mov	r9,3
80007136:	f2 08 18 00 	cp.b	r8,r9
8000713a:	c5 e0       	breq	800071f6 <put_fat+0xe2>
8000713c:	30 19       	mov	r9,1
8000713e:	f2 08 18 00 	cp.b	r8,r9
80007142:	c7 e1       	brne	8000723e <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007144:	f6 04 16 01 	lsr	r4,r11,0x1
80007148:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000714a:	e8 0b 16 09 	lsr	r11,r4,0x9
8000714e:	78 88       	ld.w	r8,r12[0x20]
80007150:	10 0b       	add	r11,r8
80007152:	f0 1f 00 3d 	mcall	80007244 <put_fat+0x130>
			if (res != FR_OK) break;
80007156:	c7 51       	brne	80007240 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
80007158:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000715c:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
8000715e:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007162:	c0 d0       	breq	8000717c <put_fat+0x68>
80007164:	ee 08 00 09 	add	r9,r7,r8
80007168:	f3 39 00 30 	ld.ub	r9,r9[48]
8000716c:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
80007170:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80007174:	f3 ea 10 49 	or	r9,r9,r10<<0x4
80007178:	5c 59       	castu.b	r9
8000717a:	c0 38       	rjmp	80007180 <put_fat+0x6c>
8000717c:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
80007180:	ee 08 00 08 	add	r8,r7,r8
80007184:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
80007188:	30 18       	mov	r8,1
8000718a:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000718c:	e8 0b 16 09 	lsr	r11,r4,0x9
80007190:	6e 88       	ld.w	r8,r7[0x20]
80007192:	10 0b       	add	r11,r8
80007194:	0e 9c       	mov	r12,r7
80007196:	f0 1f 00 2c 	mcall	80007244 <put_fat+0x130>
			if (res != FR_OK) break;
8000719a:	c5 31       	brne	80007240 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
8000719c:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
800071a0:	58 06       	cp.w	r6,0
800071a2:	c0 40       	breq	800071aa <put_fat+0x96>
800071a4:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
800071a8:	c0 b8       	rjmp	800071be <put_fat+0xaa>
800071aa:	ee 04 00 08 	add	r8,r7,r4
800071ae:	f1 38 00 30 	ld.ub	r8,r8[48]
800071b2:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
800071b6:	e2 18 00 f0 	andl	r8,0xf0,COH
800071ba:	f1 e5 10 05 	or	r5,r8,r5
800071be:	ee 04 00 04 	add	r4,r7,r4
800071c2:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
800071c6:	30 18       	mov	r8,1
800071c8:	ae c8       	st.b	r7[0x4],r8
			break;
800071ca:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
800071cc:	a9 8b       	lsr	r11,0x8
800071ce:	78 88       	ld.w	r8,r12[0x20]
800071d0:	10 0b       	add	r11,r8
800071d2:	f0 1f 00 1d 	mcall	80007244 <put_fat+0x130>
			if (res != FR_OK) break;
800071d6:	c3 51       	brne	80007240 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
800071d8:	a1 76       	lsl	r6,0x1
800071da:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
800071de:	ee 06 00 08 	add	r8,r7,r6
800071e2:	f1 65 00 30 	st.b	r8[48],r5
800071e6:	10 96       	mov	r6,r8
800071e8:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
800071ec:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
800071f0:	30 18       	mov	r8,1
800071f2:	ae c8       	st.b	r7[0x4],r8
			break;
800071f4:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
800071f6:	a7 9b       	lsr	r11,0x7
800071f8:	78 88       	ld.w	r8,r12[0x20]
800071fa:	10 0b       	add	r11,r8
800071fc:	f0 1f 00 12 	mcall	80007244 <put_fat+0x130>
			if (res != FR_OK) break;
80007200:	c2 01       	brne	80007240 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
80007202:	a3 66       	lsl	r6,0x2
80007204:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007208:	ec c8 ff d0 	sub	r8,r6,-48
8000720c:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
80007210:	f0 c9 ff fd 	sub	r9,r8,-3
80007214:	13 8a       	ld.ub	r10,r9[0x0]
80007216:	b9 6a       	lsl	r10,0x18
80007218:	ee 06 00 06 	add	r6,r7,r6
8000721c:	e6 1a f0 00 	andh	r10,0xf000,COH
80007220:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007224:	ed 65 00 30 	st.b	r6[48],r5
80007228:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
8000722c:	b0 9a       	st.b	r8[0x1],r10
8000722e:	ea 0a 16 10 	lsr	r10,r5,0x10
80007232:	b0 aa       	st.b	r8[0x2],r10
80007234:	b9 85       	lsr	r5,0x18
80007236:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007238:	30 18       	mov	r8,1
8000723a:	ae c8       	st.b	r7[0x4],r8
			break;
8000723c:	d8 22       	popm	r4-r7,pc
8000723e:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
80007240:	d8 22       	popm	r4-r7,pc
80007242:	00 00       	add	r0,r0
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	6b 20       	ld.w	r0,r5[0x48]

80007248 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007248:	d4 21       	pushm	r4-r7,lr
8000724a:	18 97       	mov	r7,r12
8000724c:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000724e:	58 1b       	cp.w	r11,1
80007250:	e0 88 00 69 	brls	80007322 <get_fat+0xda>
80007254:	78 58       	ld.w	r8,r12[0x14]
80007256:	10 3b       	cp.w	r11,r8
80007258:	c6 52       	brcc	80007322 <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
8000725a:	19 88       	ld.ub	r8,r12[0x0]
8000725c:	30 29       	mov	r9,2
8000725e:	f2 08 18 00 	cp.b	r8,r9
80007262:	c3 10       	breq	800072c4 <get_fat+0x7c>
80007264:	30 39       	mov	r9,3
80007266:	f2 08 18 00 	cp.b	r8,r9
8000726a:	c4 00       	breq	800072ea <get_fat+0xa2>
8000726c:	30 19       	mov	r9,1
8000726e:	f2 08 18 00 	cp.b	r8,r9
80007272:	c5 81       	brne	80007322 <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007274:	f6 05 16 01 	lsr	r5,r11,0x1
80007278:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
8000727a:	ea 0b 16 09 	lsr	r11,r5,0x9
8000727e:	78 88       	ld.w	r8,r12[0x20]
80007280:	10 0b       	add	r11,r8
80007282:	f0 1f 00 2a 	mcall	80007328 <get_fat+0xe0>
80007286:	c4 f1       	brne	80007324 <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
80007288:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
8000728c:	ee 08 00 08 	add	r8,r7,r8
80007290:	f1 34 00 30 	ld.ub	r4,r8[48]
80007294:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
80007296:	ea 0b 16 09 	lsr	r11,r5,0x9
8000729a:	6e 88       	ld.w	r8,r7[0x20]
8000729c:	10 0b       	add	r11,r8
8000729e:	0e 9c       	mov	r12,r7
800072a0:	f0 1f 00 22 	mcall	80007328 <get_fat+0xe0>
800072a4:	c4 01       	brne	80007324 <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
800072a6:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
800072aa:	0a 07       	add	r7,r5
800072ac:	ef 3c 00 30 	ld.ub	r12,r7[48]
800072b0:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
800072b4:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800072b8:	c0 30       	breq	800072be <get_fat+0x76>
800072ba:	a5 8c       	lsr	r12,0x4
800072bc:	d8 22       	popm	r4-r7,pc
800072be:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
800072c2:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
800072c4:	a9 8b       	lsr	r11,0x8
800072c6:	78 88       	ld.w	r8,r12[0x20]
800072c8:	10 0b       	add	r11,r8
800072ca:	f0 1f 00 18 	mcall	80007328 <get_fat+0xe0>
800072ce:	c2 b1       	brne	80007324 <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
800072d0:	a1 76       	lsl	r6,0x1
800072d2:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
800072d6:	ee 06 00 08 	add	r8,r7,r6
800072da:	10 97       	mov	r7,r8
800072dc:	f1 3c 00 31 	ld.ub	r12,r8[49]
800072e0:	f1 38 00 30 	ld.ub	r8,r8[48]
800072e4:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
800072e8:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
800072ea:	a7 9b       	lsr	r11,0x7
800072ec:	78 88       	ld.w	r8,r12[0x20]
800072ee:	10 0b       	add	r11,r8
800072f0:	f0 1f 00 0e 	mcall	80007328 <get_fat+0xe0>
800072f4:	c1 81       	brne	80007324 <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
800072f6:	a3 66       	lsl	r6,0x2
800072f8:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
800072fc:	ec c8 ff d0 	sub	r8,r6,-48
80007300:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
80007304:	11 a9       	ld.ub	r9,r8[0x2]
80007306:	11 bc       	ld.ub	r12,r8[0x3]
80007308:	b9 6c       	lsl	r12,0x18
8000730a:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
8000730e:	11 98       	ld.ub	r8,r8[0x1]
80007310:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
80007314:	0c 07       	add	r7,r6
80007316:	ef 38 00 30 	ld.ub	r8,r7[48]
8000731a:	10 4c       	or	r12,r8
8000731c:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007320:	d8 22       	popm	r4-r7,pc
80007322:	da 2a       	popm	r4-r7,pc,r12=1
80007324:	dc 2a       	popm	r4-r7,pc,r12=-1
80007326:	00 00       	add	r0,r0
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	6b 20       	ld.w	r0,r5[0x48]

8000732c <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
8000732c:	eb cd 40 f8 	pushm	r3-r7,lr
80007330:	18 96       	mov	r6,r12
80007332:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
80007334:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
80007336:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007338:	58 18       	cp.w	r8,1
8000733a:	c4 c0       	breq	800073d2 <dir_sdi+0xa6>
8000733c:	78 09       	ld.w	r9,r12[0x0]
8000733e:	72 5a       	ld.w	r10,r9[0x14]
80007340:	14 38       	cp.w	r8,r10
80007342:	c4 82       	brcc	800073d2 <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
80007344:	58 08       	cp.w	r8,0
80007346:	c0 f1       	brne	80007364 <dir_sdi+0x38>
80007348:	13 8b       	ld.ub	r11,r9[0x0]
8000734a:	30 3a       	mov	r10,3
8000734c:	f4 0b 18 00 	cp.b	r11,r10
80007350:	c0 41       	brne	80007358 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
80007352:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
80007354:	58 07       	cp.w	r7,0
80007356:	c0 81       	brne	80007366 <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
80007358:	92 ca       	ld.uh	r10,r9[0x8]
8000735a:	14 35       	cp.w	r5,r10
8000735c:	c3 b2       	brcc	800073d2 <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
8000735e:	72 9c       	ld.w	r12,r9[0x24]
80007360:	10 97       	mov	r7,r8
80007362:	c2 68       	rjmp	800073ae <dir_sdi+0x82>
80007364:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
80007366:	13 a4       	ld.ub	r4,r9[0x2]
80007368:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
8000736a:	08 35       	cp.w	r5,r4
8000736c:	c1 d3       	brcs	800073a6 <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
8000736e:	e8 03 11 00 	rsub	r3,r4,0
80007372:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
80007374:	0e 9b       	mov	r11,r7
80007376:	6c 0c       	ld.w	r12,r6[0x0]
80007378:	f0 1f 00 18 	mcall	800073d8 <dir_sdi+0xac>
8000737c:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
8000737e:	5b fc       	cp.w	r12,-1
80007380:	c0 31       	brne	80007386 <dir_sdi+0x5a>
80007382:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
80007386:	58 1c       	cp.w	r12,1
80007388:	e0 88 00 25 	brls	800073d2 <dir_sdi+0xa6>
8000738c:	6c 08       	ld.w	r8,r6[0x0]
8000738e:	70 58       	ld.w	r8,r8[0x14]
80007390:	10 3c       	cp.w	r12,r8
80007392:	c2 02       	brcc	800073d2 <dir_sdi+0xa6>
80007394:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
80007398:	f0 04 00 09 	add	r9,r8,r4
8000739c:	12 34       	cp.w	r4,r9
8000739e:	e0 8b 00 04 	brhi	800073a6 <dir_sdi+0x7a>
800073a2:	10 95       	mov	r5,r8
800073a4:	ce 8b       	rjmp	80007374 <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
800073a6:	0e 9b       	mov	r11,r7
800073a8:	6c 0c       	ld.w	r12,r6[0x0]
800073aa:	f0 1f 00 0d 	mcall	800073dc <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
800073ae:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
800073b0:	58 0c       	cp.w	r12,0
800073b2:	c1 00       	breq	800073d2 <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
800073b4:	ea 08 16 04 	lsr	r8,r5,0x4
800073b8:	f0 0c 00 0c 	add	r12,r8,r12
800073bc:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
800073be:	6c 08       	ld.w	r8,r6[0x0]
800073c0:	2d 08       	sub	r8,-48
800073c2:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
800073c6:	a5 75       	lsl	r5,0x5
800073c8:	f0 05 00 05 	add	r5,r8,r5
800073cc:	8d 55       	st.w	r6[0x14],r5
800073ce:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
800073d2:	30 2c       	mov	r12,2
}
800073d4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	72 48       	ld.w	r8,r9[0x10]
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	61 d4       	ld.w	r4,r0[0x74]

800073e0 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
800073e0:	eb cd 40 fc 	pushm	r2-r7,lr
800073e4:	18 96       	mov	r6,r12
800073e6:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
800073e8:	58 0b       	cp.w	r11,0
800073ea:	c0 81       	brne	800073fa <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
800073ec:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
800073ee:	58 05       	cp.w	r5,0
800073f0:	c1 10       	breq	80007412 <create_chain+0x32>
800073f2:	78 58       	ld.w	r8,r12[0x14]
800073f4:	10 35       	cp.w	r5,r8
800073f6:	c0 e2       	brcc	80007412 <create_chain+0x32>
800073f8:	c0 e8       	rjmp	80007414 <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
800073fa:	f0 1f 00 2c 	mcall	800074a8 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
800073fe:	58 1c       	cp.w	r12,1
80007400:	e0 88 00 4f 	brls	8000749e <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
80007404:	5b fc       	cp.w	r12,-1
80007406:	c4 f0       	breq	800074a4 <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
80007408:	6c 58       	ld.w	r8,r6[0x14]
8000740a:	10 3c       	cp.w	r12,r8
8000740c:	c4 c3       	brcs	800074a4 <create_chain+0xc4>
8000740e:	04 95       	mov	r5,r2
80007410:	c0 28       	rjmp	80007414 <create_chain+0x34>
80007412:	30 15       	mov	r5,1
80007414:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007416:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007418:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
8000741a:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
8000741c:	6c 58       	ld.w	r8,r6[0x14]
8000741e:	10 37       	cp.w	r7,r8
80007420:	c0 53       	brcs	8000742a <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007422:	58 15       	cp.w	r5,1
80007424:	e0 88 00 3f 	brls	800074a2 <create_chain+0xc2>
80007428:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
8000742a:	0e 9b       	mov	r11,r7
8000742c:	0c 9c       	mov	r12,r6
8000742e:	f0 1f 00 1f 	mcall	800074a8 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
80007432:	c0 d0       	breq	8000744c <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007434:	5b fc       	cp.w	r12,-1
80007436:	5f 09       	sreq	r9
80007438:	58 1c       	cp.w	r12,1
8000743a:	5f 08       	sreq	r8
8000743c:	f3 e8 10 08 	or	r8,r9,r8
80007440:	e8 08 18 00 	cp.b	r8,r4
80007444:	c3 01       	brne	800074a4 <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
80007446:	0a 37       	cp.w	r7,r5
80007448:	ce 91       	brne	8000741a <create_chain+0x3a>
8000744a:	c2 c8       	rjmp	800074a2 <create_chain+0xc2>
8000744c:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
8000744e:	e0 6a ff ff 	mov	r10,65535
80007452:	ea 1a 0f ff 	orh	r10,0xfff
80007456:	0e 9b       	mov	r11,r7
80007458:	0c 9c       	mov	r12,r6
8000745a:	f0 1f 00 15 	mcall	800074ac <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
8000745e:	5f 09       	sreq	r9
80007460:	58 02       	cp.w	r2,0
80007462:	5f 18       	srne	r8
80007464:	f3 e8 00 08 	and	r8,r9,r8
80007468:	c0 60       	breq	80007474 <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
8000746a:	0e 9a       	mov	r10,r7
8000746c:	04 9b       	mov	r11,r2
8000746e:	0c 9c       	mov	r12,r6
80007470:	f0 1f 00 0f 	mcall	800074ac <create_chain+0xcc>
	}
	if (res == FR_OK) {
80007474:	58 0c       	cp.w	r12,0
80007476:	c1 01       	brne	80007496 <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
80007478:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
8000747a:	6c 48       	ld.w	r8,r6[0x10]
8000747c:	5b f8       	cp.w	r8,-1
8000747e:	c0 41       	brne	80007486 <create_chain+0xa6>
80007480:	0e 9c       	mov	r12,r7
80007482:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
80007486:	20 18       	sub	r8,1
80007488:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
8000748a:	0d d8       	ld.ub	r8,r6[0x5]
8000748c:	a1 a8       	sbr	r8,0x0
8000748e:	ac d8       	st.b	r6[0x5],r8
80007490:	0e 9c       	mov	r12,r7
80007492:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
80007496:	58 1c       	cp.w	r12,1
80007498:	c0 31       	brne	8000749e <create_chain+0xbe>
8000749a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
8000749e:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800074a2:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
800074a4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800074a8:	80 00       	ld.sh	r0,r0[0x0]
800074aa:	72 48       	ld.w	r8,r9[0x10]
800074ac:	80 00       	ld.sh	r0,r0[0x0]
800074ae:	71 14       	ld.w	r4,r8[0x44]

800074b0 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
800074b0:	eb cd 40 fc 	pushm	r2-r7,lr
800074b4:	18 97       	mov	r7,r12
800074b6:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
800074b8:	98 b5       	ld.uh	r5,r12[0x6]
800074ba:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
800074bc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800074c0:	c6 d0       	breq	8000759a <dir_next+0xea>
800074c2:	78 48       	ld.w	r8,r12[0x10]
800074c4:	58 08       	cp.w	r8,0
800074c6:	c6 a0       	breq	8000759a <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
800074c8:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
800074cc:	c5 e1       	brne	80007588 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
800074ce:	2f f8       	sub	r8,-1
800074d0:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
800074d2:	78 3b       	ld.w	r11,r12[0xc]
800074d4:	58 0b       	cp.w	r11,0
800074d6:	c0 61       	brne	800074e2 <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
800074d8:	78 08       	ld.w	r8,r12[0x0]
800074da:	90 c8       	ld.uh	r8,r8[0x8]
800074dc:	10 35       	cp.w	r5,r8
800074de:	c5 53       	brcs	80007588 <dir_next+0xd8>
800074e0:	c5 d8       	rjmp	8000759a <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
800074e2:	78 0c       	ld.w	r12,r12[0x0]
800074e4:	19 a8       	ld.ub	r8,r12[0x2]
800074e6:	20 18       	sub	r8,1
800074e8:	f1 e5 02 48 	and	r8,r8,r5>>0x4
800074ec:	c4 e1       	brne	80007588 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
800074ee:	f0 1f 00 30 	mcall	800075ac <dir_next+0xfc>
800074f2:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
800074f4:	58 1c       	cp.w	r12,1
800074f6:	e0 88 00 55 	brls	800075a0 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
800074fa:	5b fc       	cp.w	r12,-1
800074fc:	c5 50       	breq	800075a6 <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
800074fe:	6e 0c       	ld.w	r12,r7[0x0]
80007500:	78 58       	ld.w	r8,r12[0x14]
80007502:	10 33       	cp.w	r3,r8
80007504:	c3 c3       	brcs	8000757c <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
80007506:	58 06       	cp.w	r6,0
80007508:	c4 90       	breq	8000759a <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
8000750a:	6e 3b       	ld.w	r11,r7[0xc]
8000750c:	f0 1f 00 29 	mcall	800075b0 <dir_next+0x100>
80007510:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
80007512:	c0 41       	brne	8000751a <dir_next+0x6a>
80007514:	30 7c       	mov	r12,7
80007516:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
8000751a:	58 1c       	cp.w	r12,1
8000751c:	c4 20       	breq	800075a0 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
8000751e:	5b fc       	cp.w	r12,-1
80007520:	c4 30       	breq	800075a6 <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
80007522:	6e 0c       	ld.w	r12,r7[0x0]
80007524:	f0 1f 00 24 	mcall	800075b4 <dir_next+0x104>
80007528:	c3 f1       	brne	800075a6 <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
8000752a:	6e 0c       	ld.w	r12,r7[0x0]
8000752c:	e0 6a 02 00 	mov	r10,512
80007530:	30 0b       	mov	r11,0
80007532:	2d 0c       	sub	r12,-48
80007534:	f0 1f 00 21 	mcall	800075b8 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007538:	6e 06       	ld.w	r6,r7[0x0]
8000753a:	06 9b       	mov	r11,r3
8000753c:	0c 9c       	mov	r12,r6
8000753e:	f0 1f 00 20 	mcall	800075bc <dir_next+0x10c>
80007542:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007544:	6e 08       	ld.w	r8,r7[0x0]
80007546:	11 aa       	ld.ub	r10,r8[0x2]
80007548:	30 09       	mov	r9,0
8000754a:	f2 0a 18 00 	cp.b	r10,r9
8000754e:	c0 31       	brne	80007554 <dir_next+0xa4>
80007550:	30 06       	mov	r6,0
80007552:	c1 28       	rjmp	80007576 <dir_next+0xc6>
80007554:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
80007556:	30 12       	mov	r2,1
80007558:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
8000755a:	6e 0c       	ld.w	r12,r7[0x0]
8000755c:	f0 1f 00 16 	mcall	800075b4 <dir_next+0x104>
80007560:	c2 31       	brne	800075a6 <dir_next+0xf6>
						dp->fs->winsect++;
80007562:	6e 08       	ld.w	r8,r7[0x0]
80007564:	70 b9       	ld.w	r9,r8[0x2c]
80007566:	2f f9       	sub	r9,-1
80007568:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
8000756a:	2f f6       	sub	r6,-1
8000756c:	6e 08       	ld.w	r8,r7[0x0]
8000756e:	11 a9       	ld.ub	r9,r8[0x2]
80007570:	0c 39       	cp.w	r9,r6
80007572:	fe 9b ff f3 	brhi	80007558 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
80007576:	70 b9       	ld.w	r9,r8[0x2c]
80007578:	0c 19       	sub	r9,r6
8000757a:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
8000757c:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
8000757e:	06 9b       	mov	r11,r3
80007580:	6e 0c       	ld.w	r12,r7[0x0]
80007582:	f0 1f 00 0f 	mcall	800075bc <dir_next+0x10c>
80007586:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
80007588:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
8000758a:	6e 08       	ld.w	r8,r7[0x0]
8000758c:	2d 08       	sub	r8,-48
8000758e:	a5 74       	lsl	r4,0x5
80007590:	f0 04 00 04 	add	r4,r8,r4
80007594:	8f 54       	st.w	r7[0x14],r4
80007596:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
8000759a:	30 4c       	mov	r12,4
8000759c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800075a0:	30 2c       	mov	r12,2
800075a2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800075a6:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800075aa:	00 00       	add	r0,r0
800075ac:	80 00       	ld.sh	r0,r0[0x0]
800075ae:	72 48       	ld.w	r8,r9[0x10]
800075b0:	80 00       	ld.sh	r0,r0[0x0]
800075b2:	73 e0       	ld.w	r0,r9[0x78]
800075b4:	80 00       	ld.sh	r0,r0[0x0]
800075b6:	63 28       	ld.w	r8,r1[0x48]
800075b8:	80 00       	ld.sh	r0,r0[0x0]
800075ba:	61 ae       	ld.w	lr,r0[0x68]
800075bc:	80 00       	ld.sh	r0,r0[0x0]
800075be:	61 d4       	ld.w	r4,r0[0x74]

800075c0 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
800075c0:	d4 21       	pushm	r4-r7,lr
800075c2:	18 97       	mov	r7,r12
800075c4:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800075c6:	58 1b       	cp.w	r11,1
800075c8:	e0 88 00 26 	brls	80007614 <remove_chain+0x54>
800075cc:	78 58       	ld.w	r8,r12[0x14]
800075ce:	10 3b       	cp.w	r11,r8
800075d0:	c2 22       	brcc	80007614 <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800075d2:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
800075d4:	0a 9b       	mov	r11,r5
800075d6:	0e 9c       	mov	r12,r7
800075d8:	f0 1f 00 10 	mcall	80007618 <remove_chain+0x58>
800075dc:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
800075de:	c0 21       	brne	800075e2 <remove_chain+0x22>
800075e0:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
800075e2:	58 1c       	cp.w	r12,1
800075e4:	c1 80       	breq	80007614 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
800075e6:	5b fc       	cp.w	r12,-1
800075e8:	c0 21       	brne	800075ec <remove_chain+0x2c>
800075ea:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800075ec:	08 9a       	mov	r10,r4
800075ee:	0a 9b       	mov	r11,r5
800075f0:	0e 9c       	mov	r12,r7
800075f2:	f0 1f 00 0b 	mcall	8000761c <remove_chain+0x5c>
			if (res != FR_OK) break;
800075f6:	c1 01       	brne	80007616 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
800075f8:	6e 48       	ld.w	r8,r7[0x10]
800075fa:	5b f8       	cp.w	r8,-1
800075fc:	c0 60       	breq	80007608 <remove_chain+0x48>
				fs->free_clust++;
800075fe:	2f f8       	sub	r8,-1
80007600:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
80007602:	0f d8       	ld.ub	r8,r7[0x5]
80007604:	a1 a8       	sbr	r8,0x0
80007606:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
80007608:	6e 58       	ld.w	r8,r7[0x14]
8000760a:	0c 38       	cp.w	r8,r6
8000760c:	e0 88 00 05 	brls	80007616 <remove_chain+0x56>
80007610:	0c 95       	mov	r5,r6
80007612:	ce 1b       	rjmp	800075d4 <remove_chain+0x14>
80007614:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
80007616:	d8 22       	popm	r4-r7,pc
80007618:	80 00       	ld.sh	r0,r0[0x0]
8000761a:	72 48       	ld.w	r8,r9[0x10]
8000761c:	80 00       	ld.sh	r0,r0[0x0]
8000761e:	71 14       	ld.w	r4,r8[0x44]

80007620 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007620:	eb cd 40 fe 	pushm	r1-r7,lr
80007624:	18 97       	mov	r7,r12
80007626:	16 91       	mov	r1,r11
80007628:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
8000762a:	3e 56       	mov	r6,-27
8000762c:	32 e5       	mov	r5,46
8000762e:	30 04       	mov	r4,0
80007630:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007632:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007634:	c2 58       	rjmp	8000767e <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007636:	6e 0c       	ld.w	r12,r7[0x0]
80007638:	f0 1f 00 17 	mcall	80007694 <dir_read+0x74>
		if (res != FR_OK) break;
8000763c:	c2 61       	brne	80007688 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
8000763e:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007640:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007642:	58 08       	cp.w	r8,0
80007644:	c2 60       	breq	80007690 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007646:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
8000764a:	ec 08 18 00 	cp.b	r8,r6
8000764e:	5f 19       	srne	r9
80007650:	ea 08 18 00 	cp.b	r8,r5
80007654:	5f 18       	srne	r8
80007656:	f3 e8 00 08 	and	r8,r9,r8
8000765a:	e8 08 18 00 	cp.b	r8,r4
8000765e:	c0 b0       	breq	80007674 <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007660:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007664:	e4 08 18 00 	cp.b	r8,r2
80007668:	c0 60       	breq	80007674 <dir_read+0x54>
8000766a:	a5 d8       	cbr	r8,0x5
8000766c:	58 88       	cp.w	r8,8
8000766e:	5f 08       	sreq	r8
80007670:	02 38       	cp.w	r8,r1
80007672:	c0 d0       	breq	8000768c <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007674:	06 9b       	mov	r11,r3
80007676:	0e 9c       	mov	r12,r7
80007678:	f0 1f 00 08 	mcall	80007698 <dir_read+0x78>
		if (res != FR_OK) break;
8000767c:	c0 61       	brne	80007688 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
8000767e:	6e 4b       	ld.w	r11,r7[0x10]
80007680:	58 0b       	cp.w	r11,0
80007682:	cd a1       	brne	80007636 <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007684:	58 0c       	cp.w	r12,0
80007686:	c0 30       	breq	8000768c <dir_read+0x6c>
80007688:	30 08       	mov	r8,0
8000768a:	8f 48       	st.w	r7[0x10],r8

	return res;
}
8000768c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007690:	30 4c       	mov	r12,4
80007692:	cf bb       	rjmp	80007688 <dir_read+0x68>
80007694:	80 00       	ld.sh	r0,r0[0x0]
80007696:	6b 20       	ld.w	r0,r5[0x48]
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	74 b0       	ld.w	r0,r10[0x2c]

8000769c <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
8000769c:	d4 21       	pushm	r4-r7,lr
8000769e:	20 9d       	sub	sp,36
800076a0:	50 0c       	stdsp	sp[0x0],r12
800076a2:	16 96       	mov	r6,r11
800076a4:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
800076a6:	30 0a       	mov	r10,0
800076a8:	1a 9b       	mov	r11,sp
800076aa:	fa cc ff fc 	sub	r12,sp,-4
800076ae:	f0 1f 00 30 	mcall	8000776c <f_getlabel+0xd0>
800076b2:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
800076b4:	5f 09       	sreq	r9
800076b6:	58 06       	cp.w	r6,0
800076b8:	5f 18       	srne	r8
800076ba:	f3 e8 00 08 	and	r8,r9,r8
800076be:	c2 d0       	breq	80007718 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
800076c0:	30 0b       	mov	r11,0
800076c2:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
800076c4:	fa cc ff fc 	sub	r12,sp,-4
800076c8:	f0 1f 00 2a 	mcall	80007770 <f_getlabel+0xd4>
800076cc:	18 97       	mov	r7,r12
		if (res == FR_OK) {
800076ce:	c4 c1       	brne	80007766 <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
800076d0:	30 1b       	mov	r11,1
800076d2:	fa cc ff fc 	sub	r12,sp,-4
800076d6:	f0 1f 00 28 	mcall	80007774 <f_getlabel+0xd8>
800076da:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
800076dc:	c1 81       	brne	8000770c <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
800076de:	30 ba       	mov	r10,11
800076e0:	40 6b       	lddsp	r11,sp[0x18]
800076e2:	0c 9c       	mov	r12,r6
800076e4:	f0 1f 00 25 	mcall	80007778 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
800076e8:	30 08       	mov	r8,0
800076ea:	ed 68 00 0b 	st.b	r6[11],r8
800076ee:	2f 66       	sub	r6,-10
800076f0:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
800076f2:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
800076f4:	30 0b       	mov	r11,0
800076f6:	c0 58       	rjmp	80007700 <f_getlabel+0x64>
800076f8:	ac 8b       	st.b	r6[0x0],r11
800076fa:	20 16       	sub	r6,1
					if (!j) break;
800076fc:	58 08       	cp.w	r8,0
800076fe:	c0 c0       	breq	80007716 <f_getlabel+0x7a>
				} while (label[--j] == ' ');
80007700:	20 18       	sub	r8,1
80007702:	0d 89       	ld.ub	r9,r6[0x0]
80007704:	f4 09 18 00 	cp.b	r9,r10
80007708:	cf 80       	breq	800076f8 <f_getlabel+0x5c>
8000770a:	c0 68       	rjmp	80007716 <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
8000770c:	58 4c       	cp.w	r12,4
8000770e:	c0 41       	brne	80007716 <f_getlabel+0x7a>
				label[0] = 0;
80007710:	30 08       	mov	r8,0
80007712:	ac 88       	st.b	r6[0x0],r8
80007714:	c0 28       	rjmp	80007718 <f_getlabel+0x7c>
80007716:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007718:	58 07       	cp.w	r7,0
8000771a:	5f 09       	sreq	r9
8000771c:	58 05       	cp.w	r5,0
8000771e:	5f 18       	srne	r8
80007720:	f3 e8 00 08 	and	r8,r9,r8
80007724:	c2 10       	breq	80007766 <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007726:	40 1c       	lddsp	r12,sp[0x4]
80007728:	78 7b       	ld.w	r11,r12[0x1c]
8000772a:	f0 1f 00 15 	mcall	8000777c <f_getlabel+0xe0>
8000772e:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007730:	c1 b1       	brne	80007766 <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007732:	40 19       	lddsp	r9,sp[0x4]
80007734:	13 8a       	ld.ub	r10,r9[0x0]
80007736:	30 38       	mov	r8,3
80007738:	f0 0a 18 00 	cp.b	r10,r8
8000773c:	f9 b8 00 43 	moveq	r8,67
80007740:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007744:	f2 08 00 08 	add	r8,r9,r8
80007748:	f1 3a 00 33 	ld.ub	r10,r8[51]
8000774c:	f1 39 00 32 	ld.ub	r9,r8[50]
80007750:	b1 69       	lsl	r9,0x10
80007752:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007756:	f1 3a 00 30 	ld.ub	r10,r8[48]
8000775a:	14 49       	or	r9,r10
8000775c:	f1 38 00 31 	ld.ub	r8,r8[49]
80007760:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007764:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007766:	0e 9c       	mov	r12,r7
80007768:	2f 7d       	sub	sp,-36
8000776a:	d8 22       	popm	r4-r7,pc
8000776c:	80 00       	ld.sh	r0,r0[0x0]
8000776e:	6b fc       	ld.w	r12,r5[0x7c]
80007770:	80 00       	ld.sh	r0,r0[0x0]
80007772:	73 2c       	ld.w	r12,r9[0x48]
80007774:	80 00       	ld.sh	r0,r0[0x0]
80007776:	76 20       	ld.w	r0,r11[0x8]
80007778:	80 00       	ld.sh	r0,r0[0x0]
8000777a:	61 98       	ld.w	r8,r0[0x64]
8000777c:	80 00       	ld.sh	r0,r0[0x0]
8000777e:	6b 20       	ld.w	r0,r5[0x48]

80007780 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
80007780:	eb cd 40 fe 	pushm	r1-r7,lr
80007784:	18 97       	mov	r7,r12
80007786:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
80007788:	30 0b       	mov	r11,0
8000778a:	f0 1f 00 15 	mcall	800077dc <dir_alloc+0x5c>
	if (res == FR_OK) {
8000778e:	c2 21       	brne	800077d2 <dir_alloc+0x52>
80007790:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007792:	3e 54       	mov	r4,-27
80007794:	30 06       	mov	r6,0
80007796:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007798:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
8000779a:	6e 4b       	ld.w	r11,r7[0x10]
8000779c:	6e 0c       	ld.w	r12,r7[0x0]
8000779e:	f0 1f 00 11 	mcall	800077e0 <dir_alloc+0x60>
			if (res != FR_OK) break;
800077a2:	c1 81       	brne	800077d2 <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
800077a4:	6e 58       	ld.w	r8,r7[0x14]
800077a6:	11 88       	ld.ub	r8,r8[0x0]
800077a8:	e8 08 18 00 	cp.b	r8,r4
800077ac:	5f 09       	sreq	r9
800077ae:	ec 08 18 00 	cp.b	r8,r6
800077b2:	5f 08       	sreq	r8
800077b4:	f3 e8 10 08 	or	r8,r9,r8
800077b8:	ec 08 18 00 	cp.b	r8,r6
800077bc:	c0 31       	brne	800077c2 <dir_alloc+0x42>
800077be:	02 95       	mov	r5,r1
800077c0:	c0 48       	rjmp	800077c8 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
800077c2:	2f f5       	sub	r5,-1
800077c4:	04 35       	cp.w	r5,r2
800077c6:	c0 90       	breq	800077d8 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
800077c8:	06 9b       	mov	r11,r3
800077ca:	0e 9c       	mov	r12,r7
800077cc:	f0 1f 00 06 	mcall	800077e4 <dir_alloc+0x64>
		} while (res == FR_OK);
800077d0:	ce 50       	breq	8000779a <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
800077d2:	58 4c       	cp.w	r12,4
800077d4:	f9 bc 00 07 	moveq	r12,7
	return res;
}
800077d8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800077dc:	80 00       	ld.sh	r0,r0[0x0]
800077de:	73 2c       	ld.w	r12,r9[0x48]
800077e0:	80 00       	ld.sh	r0,r0[0x0]
800077e2:	6b 20       	ld.w	r0,r5[0x48]
800077e4:	80 00       	ld.sh	r0,r0[0x0]
800077e6:	74 b0       	ld.w	r0,r10[0x2c]

800077e8 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
800077e8:	d4 31       	pushm	r0-r7,lr
800077ea:	20 cd       	sub	sp,48
800077ec:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
800077ee:	30 1a       	mov	r10,1
800077f0:	1a 9b       	mov	r11,sp
800077f2:	fa cc ff f0 	sub	r12,sp,-16
800077f6:	f0 1f 00 8b 	mcall	80007a20 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
800077fa:	e0 81 01 08 	brne	80007a0a <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
800077fe:	30 08       	mov	r8,0
80007800:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
80007802:	40 0a       	lddsp	r10,sp[0x0]
80007804:	15 89       	ld.ub	r9,r10[0x0]
80007806:	f0 09 18 00 	cp.b	r9,r8
8000780a:	e0 80 00 90 	breq	8000792a <f_setlabel+0x142>
8000780e:	30 07       	mov	r7,0
80007810:	2f f7       	sub	r7,-1
80007812:	f4 07 07 09 	ld.ub	r9,r10[r7]
80007816:	f0 09 18 00 	cp.b	r9,r8
8000781a:	cf b1       	brne	80007810 <f_setlabel+0x28>
8000781c:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
8000781e:	58 07       	cp.w	r7,0
80007820:	e0 80 00 85 	breq	8000792a <f_setlabel+0x142>
80007824:	f4 07 00 09 	add	r9,r10,r7
80007828:	f3 3b ff ff 	ld.ub	r11,r9[-1]
8000782c:	32 09       	mov	r9,32
8000782e:	f2 0b 18 00 	cp.b	r11,r9
80007832:	e0 81 00 ee 	brne	80007a0e <f_setlabel+0x226>
80007836:	20 28       	sub	r8,2
80007838:	f4 08 00 08 	add	r8,r10,r8
8000783c:	12 9a       	mov	r10,r9
8000783e:	20 17       	sub	r7,1
80007840:	c7 50       	breq	8000792a <f_setlabel+0x142>
80007842:	11 89       	ld.ub	r9,r8[0x0]
80007844:	20 18       	sub	r8,1
80007846:	f4 09 18 00 	cp.b	r9,r10
8000784a:	cf a0       	breq	8000783e <f_setlabel+0x56>
8000784c:	ce 18       	rjmp	80007a0e <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
8000784e:	40 08       	lddsp	r8,sp[0x0]
80007850:	f0 04 07 06 	ld.ub	r6,r8[r4]
80007854:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
80007856:	ec c9 ff 81 	sub	r9,r6,-127
8000785a:	e4 09 18 00 	cp.b	r9,r2
8000785e:	e0 8b 00 24 	brhi	800078a6 <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007862:	58 95       	cp.w	r5,9
80007864:	5f 8a       	srls	r10
80007866:	0e 34       	cp.w	r4,r7
80007868:	5f 39       	srlo	r9
8000786a:	f5 e9 00 09 	and	r9,r10,r9
8000786e:	e2 09 18 00 	cp.b	r9,r1
80007872:	e0 80 00 c9 	breq	80007a04 <f_setlabel+0x21c>
80007876:	f0 04 07 08 	ld.ub	r8,r8[r4]
8000787a:	f0 c9 00 40 	sub	r9,r8,64
8000787e:	33 eb       	mov	r11,62
80007880:	f6 09 18 00 	cp.b	r9,r11
80007884:	5f 8a       	srls	r10
80007886:	f0 c9 00 80 	sub	r9,r8,128
8000788a:	37 eb       	mov	r11,126
8000788c:	f6 09 18 00 	cp.b	r9,r11
80007890:	5f 89       	srls	r9
80007892:	f5 e9 10 09 	or	r9,r10,r9
80007896:	e2 09 18 00 	cp.b	r9,r1
8000789a:	e0 80 00 b5 	breq	80007a04 <f_setlabel+0x21c>
8000789e:	f1 e6 10 86 	or	r6,r8,r6<<0x8
800078a2:	5c 86       	casts.h	r6
800078a4:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
800078a6:	ec c8 00 61 	sub	r8,r6,97
800078aa:	31 9a       	mov	r10,25
800078ac:	f4 08 19 00 	cp.h	r8,r10
800078b0:	e0 8b 00 04 	brhi	800078b8 <f_setlabel+0xd0>
800078b4:	22 06       	sub	r6,32
800078b6:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
800078b8:	58 06       	cp.w	r6,0
800078ba:	e0 80 00 a5 	breq	80007a04 <f_setlabel+0x21c>
800078be:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800078c2:	00 9c       	mov	r12,r0
800078c4:	f0 1f 00 58 	mcall	80007a24 <f_setlabel+0x23c>
800078c8:	e0 81 00 9e 	brne	80007a04 <f_setlabel+0x21c>
800078cc:	ec 03 19 00 	cp.h	r3,r6
800078d0:	f9 b8 03 0a 	movlo	r8,10
800078d4:	f9 b8 02 0b 	movhs	r8,11
800078d8:	10 35       	cp.w	r5,r8
800078da:	e0 82 00 95 	brhs	80007a04 <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
800078de:	e6 06 19 00 	cp.h	r6,r3
800078e2:	e0 88 00 0a 	brls	800078f6 <f_setlabel+0x10e>
800078e6:	fa c8 ff d0 	sub	r8,sp,-48
800078ea:	0a 08       	add	r8,r5
800078ec:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
800078f0:	f1 69 ff d4 	st.b	r8[-44],r9
800078f4:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
800078f6:	fa c8 ff d0 	sub	r8,sp,-48
800078fa:	0a 08       	add	r8,r5
800078fc:	f1 66 ff d4 	st.b	r8[-44],r6
80007900:	2f f5       	sub	r5,-1
		} while (i < sl);
80007902:	0e 34       	cp.w	r4,r7
80007904:	ca 53       	brcs	8000784e <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
80007906:	58 a5       	cp.w	r5,10
80007908:	e0 8b 00 0c 	brhi	80007920 <f_setlabel+0x138>
8000790c:	fa c9 ff fc 	sub	r9,sp,-4
80007910:	f2 05 00 08 	add	r8,r9,r5
80007914:	32 09       	mov	r9,32
80007916:	10 c9       	st.b	r8++,r9
80007918:	2f f5       	sub	r5,-1
8000791a:	58 a5       	cp.w	r5,10
8000791c:	fe 98 ff fd 	brls	80007916 <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007920:	3e 58       	mov	r8,-27
80007922:	1b c9       	ld.ub	r9,sp[0x4]
80007924:	f0 09 18 00 	cp.b	r9,r8
80007928:	c6 e0       	breq	80007a04 <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
8000792a:	30 0b       	mov	r11,0
8000792c:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
8000792e:	fa cc ff f0 	sub	r12,sp,-16
80007932:	f0 1f 00 3e 	mcall	80007a28 <f_setlabel+0x240>
80007936:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007938:	c6 81       	brne	80007a08 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
8000793a:	30 1b       	mov	r11,1
8000793c:	fa cc ff f0 	sub	r12,sp,-16
80007940:	f0 1f 00 3b 	mcall	80007a2c <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007944:	c2 a1       	brne	80007998 <f_setlabel+0x1b0>
			if (vn[0]) {
80007946:	30 08       	mov	r8,0
80007948:	1b c9       	ld.ub	r9,sp[0x4]
8000794a:	f0 09 18 00 	cp.b	r9,r8
8000794e:	c1 b0       	breq	80007984 <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007950:	30 ba       	mov	r10,11
80007952:	fa cb ff fc 	sub	r11,sp,-4
80007956:	40 9c       	lddsp	r12,sp[0x24]
80007958:	f0 1f 00 36 	mcall	80007a30 <f_setlabel+0x248>
				tm = GET_FATTIME();
8000795c:	f0 1f 00 36 	mcall	80007a34 <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007960:	40 98       	lddsp	r8,sp[0x24]
80007962:	f1 6c 00 16 	st.b	r8[22],r12
80007966:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
8000796a:	40 98       	lddsp	r8,sp[0x24]
8000796c:	f1 69 00 17 	st.b	r8[23],r9
80007970:	f8 09 16 10 	lsr	r9,r12,0x10
80007974:	40 98       	lddsp	r8,sp[0x24]
80007976:	f1 69 00 18 	st.b	r8[24],r9
8000797a:	b9 8c       	lsr	r12,0x18
8000797c:	40 98       	lddsp	r8,sp[0x24]
8000797e:	f1 6c 00 19 	st.b	r8[25],r12
80007982:	c0 48       	rjmp	8000798a <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007984:	3e 59       	mov	r9,-27
80007986:	40 98       	lddsp	r8,sp[0x24]
80007988:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
8000798a:	30 19       	mov	r9,1
8000798c:	40 48       	lddsp	r8,sp[0x10]
8000798e:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007990:	40 4c       	lddsp	r12,sp[0x10]
80007992:	f0 1f 00 2a 	mcall	80007a38 <f_setlabel+0x250>
80007996:	c3 a8       	rjmp	80007a0a <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007998:	58 4c       	cp.w	r12,4
8000799a:	c3 81       	brne	80007a0a <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
8000799c:	30 08       	mov	r8,0
8000799e:	1b c9       	ld.ub	r9,sp[0x4]
800079a0:	f0 09 18 00 	cp.b	r9,r8
800079a4:	c3 20       	breq	80007a08 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
800079a6:	30 1b       	mov	r11,1
800079a8:	fa cc ff f0 	sub	r12,sp,-16
800079ac:	f0 1f 00 24 	mcall	80007a3c <f_setlabel+0x254>
					if (res == FR_OK) {
800079b0:	c2 d1       	brne	80007a0a <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
800079b2:	32 0a       	mov	r10,32
800079b4:	30 0b       	mov	r11,0
800079b6:	40 9c       	lddsp	r12,sp[0x24]
800079b8:	f0 1f 00 22 	mcall	80007a40 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
800079bc:	30 ba       	mov	r10,11
800079be:	fa cb ff fc 	sub	r11,sp,-4
800079c2:	40 9c       	lddsp	r12,sp[0x24]
800079c4:	f0 1f 00 1b 	mcall	80007a30 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
800079c8:	30 89       	mov	r9,8
800079ca:	40 98       	lddsp	r8,sp[0x24]
800079cc:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
800079d0:	f0 1f 00 19 	mcall	80007a34 <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
800079d4:	40 98       	lddsp	r8,sp[0x24]
800079d6:	f1 6c 00 16 	st.b	r8[22],r12
800079da:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
800079de:	40 98       	lddsp	r8,sp[0x24]
800079e0:	f1 69 00 17 	st.b	r8[23],r9
800079e4:	f8 09 16 10 	lsr	r9,r12,0x10
800079e8:	40 98       	lddsp	r8,sp[0x24]
800079ea:	f1 69 00 18 	st.b	r8[24],r9
800079ee:	b9 8c       	lsr	r12,0x18
800079f0:	40 98       	lddsp	r8,sp[0x24]
800079f2:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
800079f6:	30 19       	mov	r9,1
800079f8:	40 48       	lddsp	r8,sp[0x10]
800079fa:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
800079fc:	40 4c       	lddsp	r12,sp[0x10]
800079fe:	f0 1f 00 0f 	mcall	80007a38 <f_setlabel+0x250>
80007a02:	c0 48       	rjmp	80007a0a <f_setlabel+0x222>
80007a04:	30 6c       	mov	r12,6
80007a06:	c0 28       	rjmp	80007a0a <f_setlabel+0x222>
80007a08:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007a0a:	2f 4d       	sub	sp,-48
80007a0c:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007a0e:	30 05       	mov	r5,0
80007a10:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007a12:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007a14:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007a16:	48 c0       	lddpc	r0,80007a44 <f_setlabel+0x25c>
80007a18:	e0 63 00 ff 	mov	r3,255
80007a1c:	c1 9b       	rjmp	8000784e <f_setlabel+0x66>
80007a1e:	00 00       	add	r0,r0
80007a20:	80 00       	ld.sh	r0,r0[0x0]
80007a22:	6b fc       	ld.w	r12,r5[0x7c]
80007a24:	80 00       	ld.sh	r0,r0[0x0]
80007a26:	61 ba       	ld.w	r10,r0[0x6c]
80007a28:	80 00       	ld.sh	r0,r0[0x0]
80007a2a:	73 2c       	ld.w	r12,r9[0x48]
80007a2c:	80 00       	ld.sh	r0,r0[0x0]
80007a2e:	76 20       	ld.w	r0,r11[0x8]
80007a30:	80 00       	ld.sh	r0,r0[0x0]
80007a32:	61 98       	ld.w	r8,r0[0x64]
80007a34:	80 00       	ld.sh	r0,r0[0x0]
80007a36:	60 d4       	ld.w	r4,r0[0x34]
80007a38:	80 00       	ld.sh	r0,r0[0x0]
80007a3a:	63 8c       	ld.w	r12,r1[0x60]
80007a3c:	80 00       	ld.sh	r0,r0[0x0]
80007a3e:	77 80       	ld.w	r0,r11[0x60]
80007a40:	80 00       	ld.sh	r0,r0[0x0]
80007a42:	61 ae       	ld.w	lr,r0[0x68]
80007a44:	80 01       	ld.sh	r1,r0[0x0]
80007a46:	89 98       	st.w	r4[0x24],r8

80007a48 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007a48:	eb cd 40 c0 	pushm	r6-r7,lr
80007a4c:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007a4e:	30 1b       	mov	r11,1
80007a50:	f0 1f 00 0d 	mcall	80007a84 <dir_register+0x3c>
80007a54:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007a56:	c1 41       	brne	80007a7e <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007a58:	6c 4b       	ld.w	r11,r6[0x10]
80007a5a:	6c 0c       	ld.w	r12,r6[0x0]
80007a5c:	f0 1f 00 0b 	mcall	80007a88 <dir_register+0x40>
80007a60:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007a62:	c0 e1       	brne	80007a7e <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007a64:	32 0a       	mov	r10,32
80007a66:	30 0b       	mov	r11,0
80007a68:	6c 5c       	ld.w	r12,r6[0x14]
80007a6a:	f0 1f 00 09 	mcall	80007a8c <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007a6e:	30 ba       	mov	r10,11
80007a70:	6c 6b       	ld.w	r11,r6[0x18]
80007a72:	6c 5c       	ld.w	r12,r6[0x14]
80007a74:	f0 1f 00 07 	mcall	80007a90 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007a78:	6c 08       	ld.w	r8,r6[0x0]
80007a7a:	30 19       	mov	r9,1
80007a7c:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007a7e:	0e 9c       	mov	r12,r7
80007a80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a84:	80 00       	ld.sh	r0,r0[0x0]
80007a86:	77 80       	ld.w	r0,r11[0x60]
80007a88:	80 00       	ld.sh	r0,r0[0x0]
80007a8a:	6b 20       	ld.w	r0,r5[0x48]
80007a8c:	80 00       	ld.sh	r0,r0[0x0]
80007a8e:	61 ae       	ld.w	lr,r0[0x68]
80007a90:	80 00       	ld.sh	r0,r0[0x0]
80007a92:	61 98       	ld.w	r8,r0[0x64]

80007a94 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007a94:	d4 31       	pushm	r0-r7,lr
80007a96:	20 3d       	sub	sp,12
80007a98:	18 92       	mov	r2,r12
80007a9a:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007a9c:	17 88       	ld.ub	r8,r11[0x0]
80007a9e:	32 f9       	mov	r9,47
80007aa0:	f2 08 18 00 	cp.b	r8,r9
80007aa4:	5f 09       	sreq	r9
80007aa6:	35 ca       	mov	r10,92
80007aa8:	f4 08 18 00 	cp.b	r8,r10
80007aac:	5f 08       	sreq	r8
80007aae:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007ab2:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007ab6:	30 08       	mov	r8,0
80007ab8:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007aba:	0f 89       	ld.ub	r9,r7[0x0]
80007abc:	31 f8       	mov	r8,31
80007abe:	f0 09 18 00 	cp.b	r9,r8
80007ac2:	e0 8b 00 08 	brhi	80007ad2 <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007ac6:	30 0b       	mov	r11,0
80007ac8:	f0 1f 00 93 	mcall	80007d14 <follow_path+0x280>
		dp->dir = 0;
80007acc:	30 08       	mov	r8,0
80007ace:	85 58       	st.w	r2[0x14],r8
80007ad0:	c1 49       	rjmp	80007cf8 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007ad2:	32 f4       	mov	r4,47
80007ad4:	35 c3       	mov	r3,92
80007ad6:	30 06       	mov	r6,0
80007ad8:	0f 88       	ld.ub	r8,r7[0x0]
80007ada:	e8 08 18 00 	cp.b	r8,r4
80007ade:	5f 09       	sreq	r9
80007ae0:	e6 08 18 00 	cp.b	r8,r3
80007ae4:	5f 08       	sreq	r8
80007ae6:	f3 e8 10 08 	or	r8,r9,r8
80007aea:	ec 08 18 00 	cp.b	r8,r6
80007aee:	c0 e0       	breq	80007b0a <follow_path+0x76>
80007af0:	2f f7       	sub	r7,-1
80007af2:	0f 88       	ld.ub	r8,r7[0x0]
80007af4:	e8 08 18 00 	cp.b	r8,r4
80007af8:	5f 09       	sreq	r9
80007afa:	e6 08 18 00 	cp.b	r8,r3
80007afe:	5f 08       	sreq	r8
80007b00:	f3 e8 10 08 	or	r8,r9,r8
80007b04:	ec 08 18 00 	cp.b	r8,r6
80007b08:	cf 41       	brne	80007af0 <follow_path+0x5c>
	sfn = dp->fn;
80007b0a:	64 6a       	ld.w	r10,r2[0x18]
80007b0c:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007b0e:	30 ba       	mov	r10,11
80007b10:	32 0b       	mov	r11,32
80007b12:	40 2c       	lddsp	r12,sp[0x8]
80007b14:	f0 1f 00 81 	mcall	80007d18 <follow_path+0x284>
80007b18:	30 89       	mov	r9,8
80007b1a:	50 09       	stdsp	sp[0x0],r9
80007b1c:	30 08       	mov	r8,0
80007b1e:	50 18       	stdsp	sp[0x4],r8
80007b20:	10 90       	mov	r0,r8
80007b22:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007b24:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007b26:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007b2a:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007b2c:	32 09       	mov	r9,32
80007b2e:	f2 07 18 00 	cp.b	r7,r9
80007b32:	5f 88       	srls	r8
80007b34:	e8 07 18 00 	cp.b	r7,r4
80007b38:	5f 09       	sreq	r9
80007b3a:	f1 e9 10 09 	or	r9,r8,r9
80007b3e:	ec 09 18 00 	cp.b	r9,r6
80007b42:	c7 51       	brne	80007c2c <follow_path+0x198>
80007b44:	e6 07 18 00 	cp.b	r7,r3
80007b48:	c7 20       	breq	80007c2c <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007b4a:	32 e8       	mov	r8,46
80007b4c:	f0 07 18 00 	cp.b	r7,r8
80007b50:	5f 09       	sreq	r9
80007b52:	40 0a       	lddsp	r10,sp[0x0]
80007b54:	14 30       	cp.w	r0,r10
80007b56:	5f 28       	srhs	r8
80007b58:	f3 e8 10 08 	or	r8,r9,r8
80007b5c:	ec 08 18 00 	cp.b	r8,r6
80007b60:	c1 50       	breq	80007b8a <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007b62:	58 8a       	cp.w	r10,8
80007b64:	5f 19       	srne	r9
80007b66:	32 e8       	mov	r8,46
80007b68:	f0 07 18 00 	cp.b	r7,r8
80007b6c:	5f 18       	srne	r8
80007b6e:	f3 e8 10 08 	or	r8,r9,r8
80007b72:	ec 08 18 00 	cp.b	r8,r6
80007b76:	e0 81 00 be 	brne	80007cf2 <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007b7a:	40 18       	lddsp	r8,sp[0x4]
80007b7c:	a3 68       	lsl	r8,0x2
80007b7e:	5c 58       	castu.b	r8
80007b80:	50 18       	stdsp	sp[0x4],r8
80007b82:	30 ba       	mov	r10,11
80007b84:	50 0a       	stdsp	sp[0x0],r10
80007b86:	30 80       	mov	r0,8
80007b88:	cc fb       	rjmp	80007b26 <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007b8a:	ec 07 18 00 	cp.b	r7,r6
80007b8e:	c0 54       	brge	80007b98 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80007b90:	40 18       	lddsp	r8,sp[0x4]
80007b92:	e8 18 00 03 	orl	r8,0x3
80007b96:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
80007b98:	0e 98       	mov	r8,r7
80007b9a:	28 18       	sub	r8,-127
80007b9c:	37 da       	mov	r10,125
80007b9e:	f4 08 18 00 	cp.b	r8,r10
80007ba2:	e0 8b 00 23 	brhi	80007be8 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007ba6:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007baa:	f0 c9 00 40 	sub	r9,r8,64
80007bae:	33 ea       	mov	r10,62
80007bb0:	f4 09 18 00 	cp.b	r9,r10
80007bb4:	5f b9       	srhi	r9
80007bb6:	f0 cb 00 80 	sub	r11,r8,128
80007bba:	37 ea       	mov	r10,126
80007bbc:	f4 0b 18 00 	cp.b	r11,r10
80007bc0:	5f ba       	srhi	r10
80007bc2:	14 69       	and	r9,r10
80007bc4:	ec 09 18 00 	cp.b	r9,r6
80007bc8:	e0 81 00 95 	brne	80007cf2 <follow_path+0x25e>
80007bcc:	40 09       	lddsp	r9,sp[0x0]
80007bce:	20 19       	sub	r9,1
80007bd0:	12 30       	cp.w	r0,r9
80007bd2:	e0 82 00 90 	brhs	80007cf2 <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007bd6:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80007bd8:	40 29       	lddsp	r9,sp[0x8]
80007bda:	f2 00 0b 07 	st.b	r9[r0],r7
80007bde:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80007be0:	f2 00 0b 08 	st.b	r9[r0],r8
80007be4:	2f f0       	sub	r0,-1
80007be6:	ca 0b       	rjmp	80007b26 <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80007be8:	0e 9b       	mov	r11,r7
80007bea:	4c dc       	lddpc	r12,80007d1c <follow_path+0x288>
80007bec:	f0 1f 00 4d 	mcall	80007d20 <follow_path+0x28c>
80007bf0:	e0 81 00 81 	brne	80007cf2 <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
80007bf4:	0e 98       	mov	r8,r7
80007bf6:	24 18       	sub	r8,65
80007bf8:	31 99       	mov	r9,25
80007bfa:	f2 08 18 00 	cp.b	r8,r9
80007bfe:	e0 8b 00 06 	brhi	80007c0a <follow_path+0x176>
				b |= 2;
80007c02:	40 18       	lddsp	r8,sp[0x4]
80007c04:	a1 b8       	sbr	r8,0x1
80007c06:	50 18       	stdsp	sp[0x4],r8
80007c08:	c0 d8       	rjmp	80007c22 <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80007c0a:	0e 98       	mov	r8,r7
80007c0c:	26 18       	sub	r8,97
80007c0e:	31 9a       	mov	r10,25
80007c10:	f4 08 18 00 	cp.b	r8,r10
80007c14:	e0 8b 00 07 	brhi	80007c22 <follow_path+0x18e>
					b |= 1; c -= 0x20;
80007c18:	40 19       	lddsp	r9,sp[0x4]
80007c1a:	a1 a9       	sbr	r9,0x0
80007c1c:	50 19       	stdsp	sp[0x4],r9
80007c1e:	22 07       	sub	r7,32
80007c20:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
80007c22:	40 28       	lddsp	r8,sp[0x8]
80007c24:	f0 00 0b 07 	st.b	r8[r0],r7
80007c28:	2f f0       	sub	r0,-1
80007c2a:	c7 eb       	rjmp	80007b26 <follow_path+0x92>
80007c2c:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
80007c2e:	58 08       	cp.w	r8,0
80007c30:	f9 b8 01 04 	movne	r8,4
80007c34:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80007c38:	58 00       	cp.w	r0,0
80007c3a:	c5 c0       	breq	80007cf2 <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
80007c3c:	40 29       	lddsp	r9,sp[0x8]
80007c3e:	13 8a       	ld.ub	r10,r9[0x0]
80007c40:	3e 59       	mov	r9,-27
80007c42:	f2 0a 18 00 	cp.b	r10,r9
80007c46:	f9 b9 00 05 	moveq	r9,5
80007c4a:	fb fa 00 02 	ld.weq	r10,sp[0x8]
80007c4e:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
80007c52:	40 09       	lddsp	r9,sp[0x0]
80007c54:	58 89       	cp.w	r9,8
80007c56:	c0 51       	brne	80007c60 <follow_path+0x1cc>
80007c58:	40 19       	lddsp	r9,sp[0x4]
80007c5a:	a3 69       	lsl	r9,0x2
80007c5c:	5c 59       	castu.b	r9
80007c5e:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80007c60:	40 19       	lddsp	r9,sp[0x4]
80007c62:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80007c66:	58 1a       	cp.w	r10,1
80007c68:	c0 21       	brne	80007c6c <follow_path+0x1d8>
80007c6a:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
80007c6c:	e2 19 00 0c 	andl	r9,0xc,COH
80007c70:	58 49       	cp.w	r9,4
80007c72:	c0 21       	brne	80007c76 <follow_path+0x1e2>
80007c74:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
80007c76:	40 2a       	lddsp	r10,sp[0x8]
80007c78:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
80007c7c:	30 0b       	mov	r11,0
80007c7e:	04 9c       	mov	r12,r2
80007c80:	f0 1f 00 25 	mcall	80007d14 <follow_path+0x280>
	if (res != FR_OK) return res;
80007c84:	c2 11       	brne	80007cc6 <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
80007c86:	64 4b       	ld.w	r11,r2[0x10]
80007c88:	64 0c       	ld.w	r12,r2[0x0]
80007c8a:	f0 1f 00 27 	mcall	80007d24 <follow_path+0x290>
		if (res != FR_OK) break;
80007c8e:	c1 c1       	brne	80007cc6 <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007c90:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007c92:	13 88       	ld.ub	r8,r9[0x0]
80007c94:	ec 08 18 00 	cp.b	r8,r6
80007c98:	c3 90       	breq	80007d0a <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
80007c9a:	f3 38 00 0b 	ld.ub	r8,r9[11]
80007c9e:	e2 18 00 08 	andl	r8,0x8,COH
80007ca2:	c0 d1       	brne	80007cbc <follow_path+0x228>
80007ca4:	64 65       	ld.w	r5,r2[0x18]
80007ca6:	c0 48       	rjmp	80007cae <follow_path+0x21a>
80007ca8:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
80007caa:	58 b8       	cp.w	r8,11
80007cac:	c2 80       	breq	80007cfc <follow_path+0x268>
80007cae:	f2 08 07 0b 	ld.ub	r11,r9[r8]
80007cb2:	ea 08 07 0a 	ld.ub	r10,r5[r8]
80007cb6:	f4 0b 18 00 	cp.b	r11,r10
80007cba:	cf 70       	breq	80007ca8 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
80007cbc:	30 0b       	mov	r11,0
80007cbe:	04 9c       	mov	r12,r2
80007cc0:	f0 1f 00 1a 	mcall	80007d28 <follow_path+0x294>
	} while (res == FR_OK);
80007cc4:	ce 10       	breq	80007c86 <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007cc6:	64 68       	ld.w	r8,r2[0x18]
80007cc8:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
80007ccc:	58 4c       	cp.w	r12,4
80007cce:	c1 51       	brne	80007cf8 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
80007cd0:	e2 18 00 04 	andl	r8,0x4,COH
80007cd4:	c1 10       	breq	80007cf6 <follow_path+0x262>
80007cd6:	30 4c       	mov	r12,4
80007cd8:	c1 08       	rjmp	80007cf8 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
80007cda:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80007cdc:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007ce0:	e2 18 00 10 	andl	r8,0x10,COH
80007ce4:	c0 90       	breq	80007cf6 <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
80007ce6:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
80007ce8:	64 0c       	ld.w	r12,r2[0x0]
80007cea:	f0 1f 00 11 	mcall	80007d2c <follow_path+0x298>
80007cee:	85 2c       	st.w	r2[0x8],r12
		}
80007cf0:	cf 4a       	rjmp	80007ad8 <follow_path+0x44>
80007cf2:	30 6c       	mov	r12,6
80007cf4:	c0 28       	rjmp	80007cf8 <follow_path+0x264>
80007cf6:	30 5c       	mov	r12,5
	}

	return res;
}
80007cf8:	2f dd       	sub	sp,-12
80007cfa:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007cfc:	64 68       	ld.w	r8,r2[0x18]
80007cfe:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007d02:	e2 18 00 04 	andl	r8,0x4,COH
80007d06:	ce a0       	breq	80007cda <follow_path+0x246>
80007d08:	cf 8b       	rjmp	80007cf8 <follow_path+0x264>
80007d0a:	64 68       	ld.w	r8,r2[0x18]
80007d0c:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007d10:	ce 0b       	rjmp	80007cd0 <follow_path+0x23c>
80007d12:	00 00       	add	r0,r0
80007d14:	80 00       	ld.sh	r0,r0[0x0]
80007d16:	73 2c       	ld.w	r12,r9[0x48]
80007d18:	80 00       	ld.sh	r0,r0[0x0]
80007d1a:	61 ae       	ld.w	lr,r0[0x68]
80007d1c:	80 01       	ld.sh	r1,r0[0x0]
80007d1e:	89 a8       	st.w	r4[0x28],r8
80007d20:	80 00       	ld.sh	r0,r0[0x0]
80007d22:	61 ba       	ld.w	r10,r0[0x6c]
80007d24:	80 00       	ld.sh	r0,r0[0x0]
80007d26:	6b 20       	ld.w	r0,r5[0x48]
80007d28:	80 00       	ld.sh	r0,r0[0x0]
80007d2a:	74 b0       	ld.w	r0,r10[0x2c]
80007d2c:	80 00       	ld.sh	r0,r0[0x0]
80007d2e:	62 2a       	ld.w	r10,r1[0x8]

80007d30 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80007d30:	eb cd 40 80 	pushm	r7,lr
80007d34:	20 5d       	sub	sp,20
80007d36:	18 97       	mov	r7,r12
80007d38:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
80007d3a:	58 0c       	cp.w	r12,0
80007d3c:	c0 31       	brne	80007d42 <f_opendir+0x12>
80007d3e:	30 9c       	mov	r12,9
80007d40:	c2 d8       	rjmp	80007d9a <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
80007d42:	30 0a       	mov	r10,0
80007d44:	1a 9b       	mov	r11,sp
80007d46:	fa cc ff f0 	sub	r12,sp,-16
80007d4a:	f0 1f 00 17 	mcall	80007da4 <f_opendir+0x74>
	if (res == FR_OK) {
80007d4e:	c2 41       	brne	80007d96 <f_opendir+0x66>
		dp->fs = fs;
80007d50:	40 48       	lddsp	r8,sp[0x10]
80007d52:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
80007d54:	fa c8 ff fc 	sub	r8,sp,-4
80007d58:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
80007d5a:	40 0b       	lddsp	r11,sp[0x0]
80007d5c:	0e 9c       	mov	r12,r7
80007d5e:	f0 1f 00 13 	mcall	80007da8 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
80007d62:	c1 61       	brne	80007d8e <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
80007d64:	6e 5b       	ld.w	r11,r7[0x14]
80007d66:	58 0b       	cp.w	r11,0
80007d68:	c0 c0       	breq	80007d80 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
80007d6a:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007d6e:	e2 18 00 10 	andl	r8,0x10,COH
80007d72:	c0 31       	brne	80007d78 <f_opendir+0x48>
80007d74:	30 5c       	mov	r12,5
80007d76:	c0 e8       	rjmp	80007d92 <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
80007d78:	40 4c       	lddsp	r12,sp[0x10]
80007d7a:	f0 1f 00 0d 	mcall	80007dac <f_opendir+0x7c>
80007d7e:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
80007d80:	40 48       	lddsp	r8,sp[0x10]
80007d82:	90 38       	ld.sh	r8,r8[0x6]
80007d84:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
80007d86:	30 0b       	mov	r11,0
80007d88:	0e 9c       	mov	r12,r7
80007d8a:	f0 1f 00 0a 	mcall	80007db0 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
80007d8e:	58 4c       	cp.w	r12,4
80007d90:	c0 80       	breq	80007da0 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007d92:	58 0c       	cp.w	r12,0
80007d94:	c0 30       	breq	80007d9a <f_opendir+0x6a>
80007d96:	30 08       	mov	r8,0
80007d98:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
80007d9a:	2f bd       	sub	sp,-20
80007d9c:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007da0:	30 5c       	mov	r12,5
80007da2:	cf ab       	rjmp	80007d96 <f_opendir+0x66>
80007da4:	80 00       	ld.sh	r0,r0[0x0]
80007da6:	6b fc       	ld.w	r12,r5[0x7c]
80007da8:	80 00       	ld.sh	r0,r0[0x0]
80007daa:	7a 94       	ld.w	r4,sp[0x24]
80007dac:	80 00       	ld.sh	r0,r0[0x0]
80007dae:	62 2a       	ld.w	r10,r1[0x8]
80007db0:	80 00       	ld.sh	r0,r0[0x0]
80007db2:	73 2c       	ld.w	r12,r9[0x48]

80007db4 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
80007db4:	d4 31       	pushm	r0-r7,lr
80007db6:	21 0d       	sub	sp,64
80007db8:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
80007dba:	f0 1f 00 61 	mcall	80007f3c <f_mkdir+0x188>
80007dbe:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
80007dc0:	30 1a       	mov	r10,1
80007dc2:	fa cb ff f0 	sub	r11,sp,-16
80007dc6:	fa cc ff e0 	sub	r12,sp,-32
80007dca:	f0 1f 00 5e 	mcall	80007f40 <f_mkdir+0x18c>
80007dce:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007dd0:	c0 30       	breq	80007dd6 <f_mkdir+0x22>
80007dd2:	18 96       	mov	r6,r12
80007dd4:	ca 78       	rjmp	80007f22 <f_mkdir+0x16e>
		INIT_BUF(dj);
80007dd6:	fa c8 ff ec 	sub	r8,sp,-20
80007dda:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80007ddc:	40 4b       	lddsp	r11,sp[0x10]
80007dde:	fa cc ff e0 	sub	r12,sp,-32
80007de2:	f0 1f 00 59 	mcall	80007f44 <f_mkdir+0x190>
80007de6:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
80007de8:	c0 31       	brne	80007dee <f_mkdir+0x3a>
80007dea:	30 86       	mov	r6,8
80007dec:	c9 b8       	rjmp	80007f22 <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80007dee:	58 4c       	cp.w	r12,4
80007df0:	e0 81 00 99 	brne	80007f22 <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
80007df4:	30 0b       	mov	r11,0
80007df6:	40 8c       	lddsp	r12,sp[0x20]
80007df8:	f0 1f 00 54 	mcall	80007f48 <f_mkdir+0x194>
80007dfc:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80007dfe:	c0 31       	brne	80007e04 <f_mkdir+0x50>
80007e00:	30 77       	mov	r7,7
80007e02:	c0 88       	rjmp	80007e12 <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
80007e04:	58 1c       	cp.w	r12,1
80007e06:	c0 31       	brne	80007e0c <f_mkdir+0x58>
80007e08:	30 27       	mov	r7,2
80007e0a:	c6 c8       	rjmp	80007ee2 <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80007e0c:	5b fc       	cp.w	r12,-1
80007e0e:	e0 80 00 8d 	breq	80007f28 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
80007e12:	58 07       	cp.w	r7,0
80007e14:	c6 71       	brne	80007ee2 <f_mkdir+0x12e>
				res = sync_window(dj.fs);
80007e16:	40 8c       	lddsp	r12,sp[0x20]
80007e18:	f0 1f 00 4d 	mcall	80007f4c <f_mkdir+0x198>
80007e1c:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80007e1e:	c6 21       	brne	80007ee2 <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80007e20:	40 87       	lddsp	r7,sp[0x20]
80007e22:	04 9b       	mov	r11,r2
80007e24:	0e 9c       	mov	r12,r7
80007e26:	f0 1f 00 4b 	mcall	80007f50 <f_mkdir+0x19c>
80007e2a:	18 94       	mov	r4,r12
				dir = dj.fs->win;
80007e2c:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80007e30:	e0 6a 02 00 	mov	r10,512
80007e34:	30 0b       	mov	r11,0
80007e36:	06 9c       	mov	r12,r3
80007e38:	f0 1f 00 47 	mcall	80007f54 <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
80007e3c:	30 ba       	mov	r10,11
80007e3e:	32 0b       	mov	r11,32
80007e40:	06 9c       	mov	r12,r3
80007e42:	f0 1f 00 45 	mcall	80007f54 <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
80007e46:	32 e6       	mov	r6,46
80007e48:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
80007e4c:	31 08       	mov	r8,16
80007e4e:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
80007e52:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80007e56:	50 38       	stdsp	sp[0xc],r8
80007e58:	e7 68 00 16 	st.b	r3[22],r8
80007e5c:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80007e60:	50 28       	stdsp	sp[0x8],r8
80007e62:	e7 68 00 17 	st.b	r3[23],r8
80007e66:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
80007e6a:	50 18       	stdsp	sp[0x4],r8
80007e6c:	e7 68 00 18 	st.b	r3[24],r8
80007e70:	b9 85       	lsr	r5,0x18
80007e72:	50 05       	stdsp	sp[0x0],r5
80007e74:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
80007e78:	04 9b       	mov	r11,r2
80007e7a:	06 9c       	mov	r12,r3
80007e7c:	f0 1f 00 37 	mcall	80007f58 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
80007e80:	2b 07       	sub	r7,-80
80007e82:	32 0a       	mov	r10,32
80007e84:	06 9b       	mov	r11,r3
80007e86:	0e 9c       	mov	r12,r7
80007e88:	f0 1f 00 35 	mcall	80007f5c <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
80007e8c:	e7 66 00 21 	st.b	r3[33],r6
80007e90:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
80007e92:	40 88       	lddsp	r8,sp[0x20]
80007e94:	11 8a       	ld.ub	r10,r8[0x0]
80007e96:	30 39       	mov	r9,3
80007e98:	f2 0a 18 00 	cp.b	r10,r9
80007e9c:	c0 51       	brne	80007ea6 <f_mkdir+0xf2>
80007e9e:	70 98       	ld.w	r8,r8[0x24]
80007ea0:	16 38       	cp.w	r8,r11
80007ea2:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
80007ea6:	0e 9c       	mov	r12,r7
80007ea8:	f0 1f 00 2c 	mcall	80007f58 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80007eac:	40 88       	lddsp	r8,sp[0x20]
80007eae:	11 a6       	ld.ub	r6,r8[0x2]
80007eb0:	58 06       	cp.w	r6,0
80007eb2:	c3 d0       	breq	80007f2c <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
80007eb4:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
80007eb6:	e0 61 02 00 	mov	r1,512
80007eba:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
80007ebc:	40 88       	lddsp	r8,sp[0x20]
80007ebe:	91 b4       	st.w	r8[0x2c],r4
80007ec0:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
80007ec2:	40 88       	lddsp	r8,sp[0x20]
80007ec4:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
80007ec6:	40 8c       	lddsp	r12,sp[0x20]
80007ec8:	f0 1f 00 21 	mcall	80007f4c <f_mkdir+0x198>
					if (res != FR_OK) break;
80007ecc:	c0 a1       	brne	80007ee0 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
80007ece:	02 9a       	mov	r10,r1
80007ed0:	00 9b       	mov	r11,r0
80007ed2:	06 9c       	mov	r12,r3
80007ed4:	f0 1f 00 20 	mcall	80007f54 <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80007ed8:	20 16       	sub	r6,1
80007eda:	5c 56       	castu.b	r6
80007edc:	cf 01       	brne	80007ebc <f_mkdir+0x108>
80007ede:	c2 78       	rjmp	80007f2c <f_mkdir+0x178>
80007ee0:	18 97       	mov	r7,r12
80007ee2:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
80007ee4:	04 9b       	mov	r11,r2
80007ee6:	40 8c       	lddsp	r12,sp[0x20]
80007ee8:	f0 1f 00 1e 	mcall	80007f60 <f_mkdir+0x1ac>
80007eec:	c1 b8       	rjmp	80007f22 <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
80007eee:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
80007ef0:	31 08       	mov	r8,16
80007ef2:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
80007ef6:	40 38       	lddsp	r8,sp[0xc]
80007ef8:	f9 68 00 16 	st.b	r12[22],r8
80007efc:	40 28       	lddsp	r8,sp[0x8]
80007efe:	f9 68 00 17 	st.b	r12[23],r8
80007f02:	40 18       	lddsp	r8,sp[0x4]
80007f04:	f9 68 00 18 	st.b	r12[24],r8
80007f08:	40 08       	lddsp	r8,sp[0x0]
80007f0a:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
80007f0e:	04 9b       	mov	r11,r2
80007f10:	f0 1f 00 12 	mcall	80007f58 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
80007f14:	30 19       	mov	r9,1
80007f16:	40 88       	lddsp	r8,sp[0x20]
80007f18:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
80007f1a:	40 8c       	lddsp	r12,sp[0x20]
80007f1c:	f0 1f 00 12 	mcall	80007f64 <f_mkdir+0x1b0>
80007f20:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
80007f22:	0c 9c       	mov	r12,r6
80007f24:	2f 0d       	sub	sp,-64
80007f26:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80007f28:	30 17       	mov	r7,1
80007f2a:	cd cb       	rjmp	80007ee2 <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
80007f2c:	fa cc ff e0 	sub	r12,sp,-32
80007f30:	f0 1f 00 0e 	mcall	80007f68 <f_mkdir+0x1b4>
80007f34:	18 96       	mov	r6,r12
			if (res != FR_OK) {
80007f36:	cd c0       	breq	80007eee <f_mkdir+0x13a>
80007f38:	cd 6b       	rjmp	80007ee4 <f_mkdir+0x130>
80007f3a:	00 00       	add	r0,r0
80007f3c:	80 00       	ld.sh	r0,r0[0x0]
80007f3e:	60 d4       	ld.w	r4,r0[0x34]
80007f40:	80 00       	ld.sh	r0,r0[0x0]
80007f42:	6b fc       	ld.w	r12,r5[0x7c]
80007f44:	80 00       	ld.sh	r0,r0[0x0]
80007f46:	7a 94       	ld.w	r4,sp[0x24]
80007f48:	80 00       	ld.sh	r0,r0[0x0]
80007f4a:	73 e0       	ld.w	r0,r9[0x78]
80007f4c:	80 00       	ld.sh	r0,r0[0x0]
80007f4e:	63 28       	ld.w	r8,r1[0x48]
80007f50:	80 00       	ld.sh	r0,r0[0x0]
80007f52:	61 d4       	ld.w	r4,r0[0x74]
80007f54:	80 00       	ld.sh	r0,r0[0x0]
80007f56:	61 ae       	ld.w	lr,r0[0x68]
80007f58:	80 00       	ld.sh	r0,r0[0x0]
80007f5a:	62 52       	ld.w	r2,r1[0x14]
80007f5c:	80 00       	ld.sh	r0,r0[0x0]
80007f5e:	61 98       	ld.w	r8,r0[0x64]
80007f60:	80 00       	ld.sh	r0,r0[0x0]
80007f62:	75 c0       	ld.w	r0,r10[0x70]
80007f64:	80 00       	ld.sh	r0,r0[0x0]
80007f66:	63 8c       	ld.w	r12,r1[0x60]
80007f68:	80 00       	ld.sh	r0,r0[0x0]
80007f6a:	7a 48       	ld.w	r8,sp[0x10]

80007f6c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
80007f6c:	eb cd 40 fc 	pushm	r2-r7,lr
80007f70:	20 cd       	sub	sp,48
80007f72:	18 97       	mov	r7,r12
80007f74:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
80007f76:	58 0c       	cp.w	r12,0
80007f78:	c0 31       	brne	80007f7e <f_open+0x12>
80007f7a:	30 96       	mov	r6,9
80007f7c:	cb 68       	rjmp	800080e8 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
80007f7e:	30 08       	mov	r8,0
80007f80:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
80007f82:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
80007f86:	0a 93       	mov	r3,r5
80007f88:	e2 1a 00 1e 	andl	r10,0x1e,COH
80007f8c:	1a 9b       	mov	r11,sp
80007f8e:	fa cc ff f0 	sub	r12,sp,-16
80007f92:	f0 1f 00 5c 	mcall	80008100 <f_open+0x194>
80007f96:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
80007f98:	e0 81 00 a8 	brne	800080e8 <f_open+0x17c>
		INIT_BUF(dj);
80007f9c:	fa c8 ff fc 	sub	r8,sp,-4
80007fa0:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
80007fa2:	40 0b       	lddsp	r11,sp[0x0]
80007fa4:	fa cc ff f0 	sub	r12,sp,-16
80007fa8:	f0 1f 00 57 	mcall	80008104 <f_open+0x198>
		dir = dj.dir;
80007fac:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
80007fae:	c0 41       	brne	80007fb6 <f_open+0x4a>
			if (!dir)	/* Default directory itself */
80007fb0:	58 04       	cp.w	r4,0
80007fb2:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
80007fb6:	06 98       	mov	r8,r3
80007fb8:	e2 18 00 1c 	andl	r8,0x1c,COH
80007fbc:	c5 f0       	breq	8000807a <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
80007fbe:	58 0c       	cp.w	r12,0
80007fc0:	c0 d0       	breq	80007fda <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
80007fc2:	58 4c       	cp.w	r12,4
80007fc4:	e0 81 00 91 	brne	800080e6 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
80007fc8:	fa cc ff f0 	sub	r12,sp,-16
80007fcc:	f0 1f 00 4f 	mcall	80008108 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
80007fd0:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80007fd2:	e0 81 00 8a 	brne	800080e6 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
80007fd6:	a3 b5       	sbr	r5,0x3
80007fd8:	c0 c8       	rjmp	80007ff0 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
80007fda:	e9 38 00 0b 	ld.ub	r8,r4[11]
80007fde:	e2 18 00 11 	andl	r8,0x11,COH
80007fe2:	c0 30       	breq	80007fe8 <f_open+0x7c>
80007fe4:	30 7c       	mov	r12,7
80007fe6:	c8 08       	rjmp	800080e6 <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
80007fe8:	e2 13 00 04 	andl	r3,0x4,COH
80007fec:	e0 81 00 82 	brne	800080f0 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80007ff0:	0a 98       	mov	r8,r5
80007ff2:	e2 18 00 08 	andl	r8,0x8,COH
80007ff6:	c7 f0       	breq	800080f4 <f_open+0x188>
				dw = GET_FATTIME();
80007ff8:	f0 1f 00 45 	mcall	8000810c <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
80007ffc:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
80008000:	e9 6a 00 0e 	st.b	r4[14],r10
80008004:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008008:	e9 69 00 0f 	st.b	r4[15],r9
8000800c:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80008010:	e9 68 00 10 	st.b	r4[16],r8
80008014:	b9 8c       	lsr	r12,0x18
80008016:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
8000801a:	e9 6a 00 16 	st.b	r4[22],r10
8000801e:	e9 69 00 17 	st.b	r4[23],r9
80008022:	e9 68 00 18 	st.b	r4[24],r8
80008026:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
8000802a:	30 08       	mov	r8,0
8000802c:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
80008030:	e9 68 00 1c 	st.b	r4[28],r8
80008034:	e9 68 00 1d 	st.b	r4[29],r8
80008038:	e9 68 00 1e 	st.b	r4[30],r8
8000803c:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
80008040:	08 9b       	mov	r11,r4
80008042:	40 4c       	lddsp	r12,sp[0x10]
80008044:	f0 1f 00 33 	mcall	80008110 <f_open+0x1a4>
80008048:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
8000804a:	30 0b       	mov	r11,0
8000804c:	08 9c       	mov	r12,r4
8000804e:	f0 1f 00 32 	mcall	80008114 <f_open+0x1a8>
				dj.fs->wflag = 1;
80008052:	30 19       	mov	r9,1
80008054:	40 48       	lddsp	r8,sp[0x10]
80008056:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
80008058:	58 03       	cp.w	r3,0
8000805a:	c4 d0       	breq	800080f4 <f_open+0x188>
					dw = dj.fs->winsect;
8000805c:	40 4c       	lddsp	r12,sp[0x10]
8000805e:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
80008060:	06 9b       	mov	r11,r3
80008062:	f0 1f 00 2e 	mcall	80008118 <f_open+0x1ac>
					if (res == FR_OK) {
80008066:	c4 01       	brne	800080e6 <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
80008068:	20 13       	sub	r3,1
8000806a:	40 48       	lddsp	r8,sp[0x10]
8000806c:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
8000806e:	04 9b       	mov	r11,r2
80008070:	40 4c       	lddsp	r12,sp[0x10]
80008072:	f0 1f 00 2b 	mcall	8000811c <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
80008076:	c1 40       	breq	8000809e <f_open+0x132>
80008078:	c3 78       	rjmp	800080e6 <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
8000807a:	58 0c       	cp.w	r12,0
8000807c:	c3 51       	brne	800080e6 <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
8000807e:	e9 38 00 0b 	ld.ub	r8,r4[11]
80008082:	10 99       	mov	r9,r8
80008084:	e2 19 00 10 	andl	r9,0x10,COH
80008088:	c0 30       	breq	8000808e <f_open+0x122>
8000808a:	30 4c       	mov	r12,4
8000808c:	c2 d8       	rjmp	800080e6 <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
8000808e:	e2 13 00 02 	andl	r3,0x2,COH
80008092:	c3 10       	breq	800080f4 <f_open+0x188>
80008094:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008098:	c2 e0       	breq	800080f4 <f_open+0x188>
8000809a:	30 7c       	mov	r12,7
8000809c:	c2 58       	rjmp	800080e6 <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
8000809e:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
800080a0:	40 43       	lddsp	r3,sp[0x10]
800080a2:	66 b8       	ld.w	r8,r3[0x2c]
800080a4:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
800080a6:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
800080a8:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
800080aa:	30 08       	mov	r8,0
800080ac:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
800080ae:	08 9b       	mov	r11,r4
800080b0:	06 9c       	mov	r12,r3
800080b2:	f0 1f 00 18 	mcall	80008110 <f_open+0x1a4>
800080b6:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
800080b8:	e9 39 00 1f 	ld.ub	r9,r4[31]
800080bc:	e9 38 00 1e 	ld.ub	r8,r4[30]
800080c0:	b1 68       	lsl	r8,0x10
800080c2:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800080c6:	e9 39 00 1c 	ld.ub	r9,r4[28]
800080ca:	12 48       	or	r8,r9
800080cc:	e9 39 00 1d 	ld.ub	r9,r4[29]
800080d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800080d4:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
800080d6:	30 08       	mov	r8,0
800080d8:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
800080da:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
800080dc:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
800080de:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
800080e0:	86 38       	ld.sh	r8,r3[0x6]
800080e2:	ae 28       	st.h	r7[0x4],r8
800080e4:	c0 28       	rjmp	800080e8 <f_open+0x17c>
800080e6:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
800080e8:	0c 9c       	mov	r12,r6
800080ea:	2f 4d       	sub	sp,-48
800080ec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
800080f0:	30 8c       	mov	r12,8
800080f2:	cf ab       	rjmp	800080e6 <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
800080f4:	0a 98       	mov	r8,r5
800080f6:	e2 18 00 08 	andl	r8,0x8,COH
800080fa:	cd 30       	breq	800080a0 <f_open+0x134>
800080fc:	cd 1b       	rjmp	8000809e <f_open+0x132>
800080fe:	00 00       	add	r0,r0
80008100:	80 00       	ld.sh	r0,r0[0x0]
80008102:	6b fc       	ld.w	r12,r5[0x7c]
80008104:	80 00       	ld.sh	r0,r0[0x0]
80008106:	7a 94       	ld.w	r4,sp[0x24]
80008108:	80 00       	ld.sh	r0,r0[0x0]
8000810a:	7a 48       	ld.w	r8,sp[0x10]
8000810c:	80 00       	ld.sh	r0,r0[0x0]
8000810e:	60 d4       	ld.w	r4,r0[0x34]
80008110:	80 00       	ld.sh	r0,r0[0x0]
80008112:	62 2a       	ld.w	r10,r1[0x8]
80008114:	80 00       	ld.sh	r0,r0[0x0]
80008116:	62 52       	ld.w	r2,r1[0x14]
80008118:	80 00       	ld.sh	r0,r0[0x0]
8000811a:	75 c0       	ld.w	r0,r10[0x70]
8000811c:	80 00       	ld.sh	r0,r0[0x0]
8000811e:	6b 20       	ld.w	r0,r5[0x48]

80008120 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008120:	d4 31       	pushm	r0-r7,lr
80008122:	20 2d       	sub	sp,8
80008124:	fa c7 ff f8 	sub	r7,sp,-8
80008128:	0e dc       	st.w	--r7,r12
8000812a:	16 90       	mov	r0,r11
8000812c:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
8000812e:	30 0a       	mov	r10,0
80008130:	0e 9b       	mov	r11,r7
80008132:	0c 9c       	mov	r12,r6
80008134:	f0 1f 00 33 	mcall	80008200 <f_getfree+0xe0>
80008138:	18 93       	mov	r3,r12
	fs = *fatfs;
8000813a:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
8000813c:	c5 f1       	brne	800081fa <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
8000813e:	6c 48       	ld.w	r8,r6[0x10]
80008140:	6c 57       	ld.w	r7,r6[0x14]
80008142:	ee c9 00 02 	sub	r9,r7,2
80008146:	12 38       	cp.w	r8,r9
80008148:	e0 8b 00 04 	brhi	80008150 <f_getfree+0x30>
			*nclst = fs->free_clust;
8000814c:	81 08       	st.w	r0[0x0],r8
8000814e:	c5 68       	rjmp	800081fa <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
80008150:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
80008152:	30 18       	mov	r8,1
80008154:	f0 04 18 00 	cp.b	r4,r8
80008158:	c1 71       	brne	80008186 <f_getfree+0x66>
8000815a:	30 27       	mov	r7,2
8000815c:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
8000815e:	0e 9b       	mov	r11,r7
80008160:	0c 9c       	mov	r12,r6
80008162:	f0 1f 00 29 	mcall	80008204 <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
80008166:	5b fc       	cp.w	r12,-1
80008168:	c0 31       	brne	8000816e <f_getfree+0x4e>
8000816a:	30 1c       	mov	r12,1
8000816c:	c4 28       	rjmp	800081f0 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
8000816e:	58 1c       	cp.w	r12,1
80008170:	c0 31       	brne	80008176 <f_getfree+0x56>
80008172:	30 2c       	mov	r12,2
80008174:	c3 e8       	rjmp	800081f0 <f_getfree+0xd0>
					if (stat == 0) nfree++;
80008176:	58 0c       	cp.w	r12,0
80008178:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
8000817c:	2f f7       	sub	r7,-1
8000817e:	6c 58       	ld.w	r8,r6[0x14]
80008180:	10 37       	cp.w	r7,r8
80008182:	ce e3       	brcs	8000815e <f_getfree+0x3e>
80008184:	c3 58       	rjmp	800081ee <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
80008186:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
80008188:	30 08       	mov	r8,0
8000818a:	10 99       	mov	r9,r8
8000818c:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
8000818e:	ec ca ff d0 	sub	r10,r6,-48
80008192:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
80008194:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
80008196:	58 09       	cp.w	r9,0
80008198:	c0 a1       	brne	800081ac <f_getfree+0x8c>
						res = move_window(fs, sect++);
8000819a:	02 9b       	mov	r11,r1
8000819c:	0c 9c       	mov	r12,r6
8000819e:	f0 1f 00 1b 	mcall	80008208 <f_getfree+0xe8>
						if (res != FR_OK) break;
800081a2:	c2 71       	brne	800081f0 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800081a4:	2f f1       	sub	r1,-1
800081a6:	40 08       	lddsp	r8,sp[0x0]
800081a8:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800081ac:	e4 04 18 00 	cp.b	r4,r2
800081b0:	c0 d1       	brne	800081ca <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
800081b2:	11 9b       	ld.ub	r11,r8[0x1]
800081b4:	11 8a       	ld.ub	r10,r8[0x0]
800081b6:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800081ba:	30 0b       	mov	r11,0
800081bc:	f6 0a 19 00 	cp.h	r10,r11
800081c0:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
800081c4:	2f e8       	sub	r8,-2
800081c6:	20 29       	sub	r9,2
800081c8:	c1 18       	rjmp	800081ea <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
800081ca:	11 bb       	ld.ub	r11,r8[0x3]
800081cc:	11 aa       	ld.ub	r10,r8[0x2]
800081ce:	b1 6a       	lsl	r10,0x10
800081d0:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
800081d4:	11 8b       	ld.ub	r11,r8[0x0]
800081d6:	16 4a       	or	r10,r11
800081d8:	11 9b       	ld.ub	r11,r8[0x1]
800081da:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800081de:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
800081e2:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
800081e6:	2f c8       	sub	r8,-4
800081e8:	20 49       	sub	r9,4
					}
				} while (--clst);
800081ea:	20 17       	sub	r7,1
800081ec:	cd 51       	brne	80008196 <f_getfree+0x76>
800081ee:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
800081f0:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
800081f2:	0d d8       	ld.ub	r8,r6[0x5]
800081f4:	a1 a8       	sbr	r8,0x0
800081f6:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
800081f8:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
800081fa:	2f ed       	sub	sp,-8
800081fc:	d8 32       	popm	r0-r7,pc
800081fe:	00 00       	add	r0,r0
80008200:	80 00       	ld.sh	r0,r0[0x0]
80008202:	6b fc       	ld.w	r12,r5[0x7c]
80008204:	80 00       	ld.sh	r0,r0[0x0]
80008206:	72 48       	ld.w	r8,r9[0x10]
80008208:	80 00       	ld.sh	r0,r0[0x0]
8000820a:	6b 20       	ld.w	r0,r5[0x48]

8000820c <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
8000820c:	d4 31       	pushm	r0-r7,lr
8000820e:	18 97       	mov	r7,r12
80008210:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
80008212:	f0 1f 00 a5 	mcall	800084a4 <f_lseek+0x298>
80008216:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008218:	e0 81 01 44 	brne	800084a0 <f_lseek+0x294>
	if (fp->err)						/* Check error */
8000821c:	0f f8       	ld.ub	r8,r7[0x7]
8000821e:	58 08       	cp.w	r8,0
80008220:	c0 30       	breq	80008226 <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008222:	10 96       	mov	r6,r8
80008224:	c3 e9       	rjmp	800084a0 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
80008226:	6e 93       	ld.w	r3,r7[0x24]
80008228:	58 03       	cp.w	r3,0
8000822a:	e0 80 00 85 	breq	80008334 <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
8000822e:	5b f5       	cp.w	r5,-1
80008230:	c3 71       	brne	8000829e <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
80008232:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
80008234:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
80008236:	58 01       	cp.w	r1,0
80008238:	c2 80       	breq	80008288 <f_lseek+0x7c>
8000823a:	30 22       	mov	r2,2
8000823c:	02 95       	mov	r5,r1
8000823e:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
80008240:	0a 9b       	mov	r11,r5
80008242:	6e 0c       	ld.w	r12,r7[0x0]
80008244:	f0 1f 00 99 	mcall	800084a8 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008248:	58 1c       	cp.w	r12,1
8000824a:	e0 8b 00 06 	brhi	80008256 <f_lseek+0x4a>
8000824e:	30 28       	mov	r8,2
80008250:	ae f8       	st.b	r7[0x7],r8
80008252:	30 26       	mov	r6,2
80008254:	c2 69       	rjmp	800084a0 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008256:	5b fc       	cp.w	r12,-1
80008258:	c0 51       	brne	80008262 <f_lseek+0x56>
8000825a:	30 18       	mov	r8,1
8000825c:	ae f8       	st.b	r7[0x7],r8
8000825e:	30 16       	mov	r6,1
80008260:	c2 09       	rjmp	800084a0 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
80008262:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
80008264:	2f f5       	sub	r5,-1
80008266:	0a 3c       	cp.w	r12,r5
80008268:	c0 31       	brne	8000826e <f_lseek+0x62>
8000826a:	18 95       	mov	r5,r12
8000826c:	ce ab       	rjmp	80008240 <f_lseek+0x34>
8000826e:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
80008270:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
80008272:	04 30       	cp.w	r0,r2
80008274:	c0 33       	brcs	8000827a <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
80008276:	06 a4       	st.w	r3++,r4
80008278:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
8000827a:	6e 09       	ld.w	r9,r7[0x0]
8000827c:	72 59       	ld.w	r9,r9[0x14]
8000827e:	10 39       	cp.w	r9,r8
80008280:	e0 88 00 05 	brls	8000828a <f_lseek+0x7e>
80008284:	18 91       	mov	r1,r12
80008286:	cd bb       	rjmp	8000823c <f_lseek+0x30>
80008288:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
8000828a:	6e 98       	ld.w	r8,r7[0x24]
8000828c:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
8000828e:	00 32       	cp.w	r2,r0
80008290:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
80008294:	f9 b8 08 00 	movls	r8,0
80008298:	e7 f8 8a 00 	st.wls	r3[0x0],r8
8000829c:	c0 29       	rjmp	800084a0 <f_lseek+0x294>
8000829e:	6e 34       	ld.w	r4,r7[0xc]
800082a0:	08 35       	cp.w	r5,r4
800082a2:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
800082a6:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
800082a8:	58 05       	cp.w	r5,0
800082aa:	e0 80 00 fb 	breq	800084a0 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
800082ae:	ea c4 00 01 	sub	r4,r5,1
800082b2:	08 9b       	mov	r11,r4
800082b4:	0e 9c       	mov	r12,r7
800082b6:	f0 1f 00 7e 	mcall	800084ac <f_lseek+0x2a0>
800082ba:	18 9b       	mov	r11,r12
800082bc:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
800082be:	6e 05       	ld.w	r5,r7[0x0]
800082c0:	0a 9c       	mov	r12,r5
800082c2:	f0 1f 00 7c 	mcall	800084b0 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
800082c6:	c0 51       	brne	800082d0 <f_lseek+0xc4>
800082c8:	30 28       	mov	r8,2
800082ca:	ae f8       	st.b	r7[0x7],r8
800082cc:	30 26       	mov	r6,2
800082ce:	ce 98       	rjmp	800084a0 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800082d0:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800082d2:	6e 28       	ld.w	r8,r7[0x8]
800082d4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800082d8:	e0 80 00 e4 	breq	800084a0 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800082dc:	20 19       	sub	r9,1
800082de:	f3 e4 02 94 	and	r4,r9,r4>>0x9
800082e2:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800082e6:	6e 6a       	ld.w	r10,r7[0x18]
800082e8:	08 3a       	cp.w	r10,r4
800082ea:	e0 80 00 db 	breq	800084a0 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
800082ee:	0f e8       	ld.ub	r8,r7[0x6]
800082f0:	e2 18 00 40 	andl	r8,0x40,COH
800082f4:	c0 f0       	breq	80008312 <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800082f6:	30 19       	mov	r9,1
800082f8:	ee cb ff d8 	sub	r11,r7,-40
800082fc:	0b 9c       	ld.ub	r12,r5[0x1]
800082fe:	f0 1f 00 6e 	mcall	800084b4 <f_lseek+0x2a8>
80008302:	c0 50       	breq	8000830c <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
80008304:	30 18       	mov	r8,1
80008306:	ae f8       	st.b	r7[0x7],r8
80008308:	30 16       	mov	r6,1
8000830a:	cc b8       	rjmp	800084a0 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
8000830c:	0f e8       	ld.ub	r8,r7[0x6]
8000830e:	a7 c8       	cbr	r8,0x6
80008310:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
80008312:	6e 08       	ld.w	r8,r7[0x0]
80008314:	30 19       	mov	r9,1
80008316:	08 9a       	mov	r10,r4
80008318:	ee cb ff d8 	sub	r11,r7,-40
8000831c:	11 9c       	ld.ub	r12,r8[0x1]
8000831e:	f0 1f 00 67 	mcall	800084b8 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
80008322:	f9 b8 01 01 	movne	r8,1
80008326:	ef f8 1e 07 	st.bne	r7[0x7],r8
8000832a:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
8000832e:	ef f4 0a 06 	st.weq	r7[0x18],r4
80008332:	cb 78       	rjmp	800084a0 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008334:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
80008336:	08 35       	cp.w	r5,r4
80008338:	e0 88 00 06 	brls	80008344 <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
8000833c:	0f e8       	ld.ub	r8,r7[0x6]
8000833e:	e2 18 00 02 	andl	r8,0x2,COH
80008342:	c0 20       	breq	80008346 <f_lseek+0x13a>
80008344:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
80008346:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008348:	30 08       	mov	r8,0
8000834a:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
8000834c:	58 04       	cp.w	r4,0
8000834e:	e0 80 00 a9 	breq	800084a0 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
80008352:	6e 08       	ld.w	r8,r7[0x0]
80008354:	11 a5       	ld.ub	r5,r8[0x2]
80008356:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
80008358:	58 09       	cp.w	r9,0
8000835a:	c1 30       	breq	80008380 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
8000835c:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000835e:	e8 cb 00 01 	sub	r11,r4,1
80008362:	f6 05 0d 0a 	divu	r10,r11,r5
80008366:	14 9b       	mov	r11,r10
80008368:	f2 05 0d 02 	divu	r2,r9,r5
8000836c:	04 3b       	cp.w	r11,r2
8000836e:	c0 93       	brcs	80008380 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
80008370:	ea 08 11 00 	rsub	r8,r5,0
80008374:	f1 e9 00 09 	and	r9,r8,r9
80008378:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
8000837a:	12 14       	sub	r4,r9
				clst = fp->clust;
8000837c:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000837e:	c1 68       	rjmp	800083aa <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
80008380:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
80008382:	58 0c       	cp.w	r12,0
80008384:	c1 21       	brne	800083a8 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
80008386:	30 0b       	mov	r11,0
80008388:	10 9c       	mov	r12,r8
8000838a:	f0 1f 00 4d 	mcall	800084bc <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
8000838e:	58 1c       	cp.w	r12,1
80008390:	c0 51       	brne	8000839a <f_lseek+0x18e>
80008392:	30 28       	mov	r8,2
80008394:	ae f8       	st.b	r7[0x7],r8
80008396:	30 26       	mov	r6,2
80008398:	c8 48       	rjmp	800084a0 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
8000839a:	5b fc       	cp.w	r12,-1
8000839c:	c0 51       	brne	800083a6 <f_lseek+0x19a>
8000839e:	30 18       	mov	r8,1
800083a0:	ae f8       	st.b	r7[0x7],r8
800083a2:	30 16       	mov	r6,1
800083a4:	c7 e8       	rjmp	800084a0 <f_lseek+0x294>
					fp->sclust = clst;
800083a6:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
800083a8:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
800083aa:	58 0c       	cp.w	r12,0
800083ac:	c4 80       	breq	8000843c <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
800083ae:	0a 34       	cp.w	r4,r5
800083b0:	e0 88 00 32 	brls	80008414 <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
800083b4:	ea 03 11 00 	rsub	r3,r5,0
800083b8:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
800083ba:	0f e8       	ld.ub	r8,r7[0x6]
800083bc:	e2 18 00 02 	andl	r8,0x2,COH
800083c0:	c0 70       	breq	800083ce <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
800083c2:	18 9b       	mov	r11,r12
800083c4:	6e 0c       	ld.w	r12,r7[0x0]
800083c6:	f0 1f 00 3e 	mcall	800084bc <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
800083ca:	c0 61       	brne	800083d6 <f_lseek+0x1ca>
800083cc:	c2 38       	rjmp	80008412 <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
800083ce:	18 9b       	mov	r11,r12
800083d0:	6e 0c       	ld.w	r12,r7[0x0]
800083d2:	f0 1f 00 36 	mcall	800084a8 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800083d6:	5b fc       	cp.w	r12,-1
800083d8:	c0 51       	brne	800083e2 <f_lseek+0x1d6>
800083da:	30 18       	mov	r8,1
800083dc:	ae f8       	st.b	r7[0x7],r8
800083de:	30 16       	mov	r6,1
800083e0:	c6 08       	rjmp	800084a0 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
800083e2:	58 1c       	cp.w	r12,1
800083e4:	e0 88 00 06 	brls	800083f0 <f_lseek+0x1e4>
800083e8:	6e 08       	ld.w	r8,r7[0x0]
800083ea:	70 58       	ld.w	r8,r8[0x14]
800083ec:	10 3c       	cp.w	r12,r8
800083ee:	c0 53       	brcs	800083f8 <f_lseek+0x1ec>
800083f0:	30 28       	mov	r8,2
800083f2:	ae f8       	st.b	r7[0x7],r8
800083f4:	30 26       	mov	r6,2
800083f6:	c5 58       	rjmp	800084a0 <f_lseek+0x294>
					fp->clust = clst;
800083f8:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
800083fa:	6e 28       	ld.w	r8,r7[0x8]
800083fc:	0a 08       	add	r8,r5
800083fe:	8f 28       	st.w	r7[0x8],r8
80008400:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
80008404:	f0 05 00 09 	add	r9,r8,r5
80008408:	0a 39       	cp.w	r9,r5
8000840a:	e0 88 00 05 	brls	80008414 <f_lseek+0x208>
8000840e:	10 94       	mov	r4,r8
80008410:	cd 5b       	rjmp	800083ba <f_lseek+0x1ae>
80008412:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
80008414:	6e 28       	ld.w	r8,r7[0x8]
80008416:	08 08       	add	r8,r4
80008418:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
8000841a:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000841e:	c0 f0       	breq	8000843c <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008420:	18 9b       	mov	r11,r12
80008422:	6e 0c       	ld.w	r12,r7[0x0]
80008424:	f0 1f 00 23 	mcall	800084b0 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008428:	c0 51       	brne	80008432 <f_lseek+0x226>
8000842a:	30 28       	mov	r8,2
8000842c:	ae f8       	st.b	r7[0x7],r8
8000842e:	30 26       	mov	r6,2
80008430:	c3 88       	rjmp	800084a0 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
80008432:	e8 05 16 09 	lsr	r5,r4,0x9
80008436:	f8 05 00 05 	add	r5,r12,r5
8000843a:	c0 28       	rjmp	8000843e <f_lseek+0x232>
8000843c:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
8000843e:	6e 28       	ld.w	r8,r7[0x8]
80008440:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008444:	c2 50       	breq	8000848e <f_lseek+0x282>
80008446:	6e 6a       	ld.w	r10,r7[0x18]
80008448:	0a 3a       	cp.w	r10,r5
8000844a:	c2 20       	breq	8000848e <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
8000844c:	0f e8       	ld.ub	r8,r7[0x6]
8000844e:	e2 18 00 40 	andl	r8,0x40,COH
80008452:	c1 00       	breq	80008472 <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008454:	6e 08       	ld.w	r8,r7[0x0]
80008456:	30 19       	mov	r9,1
80008458:	ee cb ff d8 	sub	r11,r7,-40
8000845c:	11 9c       	ld.ub	r12,r8[0x1]
8000845e:	f0 1f 00 16 	mcall	800084b4 <f_lseek+0x2a8>
80008462:	c0 50       	breq	8000846c <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
80008464:	30 18       	mov	r8,1
80008466:	ae f8       	st.b	r7[0x7],r8
80008468:	30 16       	mov	r6,1
8000846a:	c1 b8       	rjmp	800084a0 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
8000846c:	0f e8       	ld.ub	r8,r7[0x6]
8000846e:	a7 c8       	cbr	r8,0x6
80008470:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
80008472:	6e 08       	ld.w	r8,r7[0x0]
80008474:	30 19       	mov	r9,1
80008476:	0a 9a       	mov	r10,r5
80008478:	ee cb ff d8 	sub	r11,r7,-40
8000847c:	11 9c       	ld.ub	r12,r8[0x1]
8000847e:	f0 1f 00 0f 	mcall	800084b8 <f_lseek+0x2ac>
80008482:	c0 50       	breq	8000848c <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
80008484:	30 18       	mov	r8,1
80008486:	ae f8       	st.b	r7[0x7],r8
80008488:	30 16       	mov	r6,1
8000848a:	c0 b8       	rjmp	800084a0 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
8000848c:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
8000848e:	6e 28       	ld.w	r8,r7[0x8]
80008490:	6e 39       	ld.w	r9,r7[0xc]
80008492:	12 38       	cp.w	r8,r9
80008494:	e0 88 00 06 	brls	800084a0 <f_lseek+0x294>
			fp->fsize = fp->fptr;
80008498:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
8000849a:	0f e8       	ld.ub	r8,r7[0x6]
8000849c:	a5 b8       	sbr	r8,0x5
8000849e:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
800084a0:	0c 9c       	mov	r12,r6
800084a2:	d8 32       	popm	r0-r7,pc
800084a4:	80 00       	ld.sh	r0,r0[0x0]
800084a6:	6a ec       	ld.w	r12,r5[0x38]
800084a8:	80 00       	ld.sh	r0,r0[0x0]
800084aa:	72 48       	ld.w	r8,r9[0x10]
800084ac:	80 00       	ld.sh	r0,r0[0x0]
800084ae:	61 ec       	ld.w	r12,r0[0x78]
800084b0:	80 00       	ld.sh	r0,r0[0x0]
800084b2:	61 d4       	ld.w	r4,r0[0x74]
800084b4:	80 00       	ld.sh	r0,r0[0x0]
800084b6:	61 60       	ld.w	r0,r0[0x58]
800084b8:	80 00       	ld.sh	r0,r0[0x0]
800084ba:	61 7c       	ld.w	r12,r0[0x5c]
800084bc:	80 00       	ld.sh	r0,r0[0x0]
800084be:	73 e0       	ld.w	r0,r9[0x78]

800084c0 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
800084c0:	d4 31       	pushm	r0-r7,lr
800084c2:	20 3d       	sub	sp,12
800084c4:	18 97       	mov	r7,r12
800084c6:	16 93       	mov	r3,r11
800084c8:	14 96       	mov	r6,r10
800084ca:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
800084cc:	30 08       	mov	r8,0
800084ce:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
800084d0:	f0 1f 00 6d 	mcall	80008684 <f_write+0x1c4>
800084d4:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
800084d6:	e0 81 00 d3 	brne	8000867c <f_write+0x1bc>
	if (fp->err)							/* Check error */
800084da:	0f f8       	ld.ub	r8,r7[0x7]
800084dc:	58 08       	cp.w	r8,0
800084de:	c0 30       	breq	800084e4 <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
800084e0:	10 92       	mov	r2,r8
800084e2:	cc d8       	rjmp	8000867c <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
800084e4:	0f e8       	ld.ub	r8,r7[0x6]
800084e6:	e2 18 00 02 	andl	r8,0x2,COH
800084ea:	c0 31       	brne	800084f0 <f_write+0x30>
800084ec:	30 72       	mov	r2,7
800084ee:	cc 78       	rjmp	8000867c <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
800084f0:	6e 28       	ld.w	r8,r7[0x8]
800084f2:	ec 08 00 09 	add	r9,r6,r8
800084f6:	12 38       	cp.w	r8,r9
800084f8:	e0 8b 00 ba 	brhi	8000866c <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
800084fc:	58 06       	cp.w	r6,0
800084fe:	e0 80 00 b7 	breq	8000866c <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008502:	ee c8 ff d8 	sub	r8,r7,-40
80008506:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008508:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
8000850a:	50 2c       	stdsp	sp[0x8],r12
8000850c:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
8000850e:	6e 2b       	ld.w	r11,r7[0x8]
80008510:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008514:	e0 81 00 8c 	brne	8000862c <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008518:	6e 08       	ld.w	r8,r7[0x0]
8000851a:	11 a6       	ld.ub	r6,r8[0x2]
8000851c:	20 16       	sub	r6,1
8000851e:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008522:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008524:	c2 91       	brne	80008576 <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
80008526:	58 0b       	cp.w	r11,0
80008528:	c0 81       	brne	80008538 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
8000852a:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
8000852c:	58 0c       	cp.w	r12,0
8000852e:	c1 31       	brne	80008554 <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008530:	10 9c       	mov	r12,r8
80008532:	f0 1f 00 56 	mcall	80008688 <f_write+0x1c8>
80008536:	c0 c8       	rjmp	8000854e <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008538:	6e 99       	ld.w	r9,r7[0x24]
8000853a:	58 09       	cp.w	r9,0
8000853c:	c0 50       	breq	80008546 <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
8000853e:	0e 9c       	mov	r12,r7
80008540:	f0 1f 00 53 	mcall	8000868c <f_write+0x1cc>
80008544:	c0 58       	rjmp	8000854e <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
80008546:	6e 5b       	ld.w	r11,r7[0x14]
80008548:	10 9c       	mov	r12,r8
8000854a:	f0 1f 00 50 	mcall	80008688 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
8000854e:	58 0c       	cp.w	r12,0
80008550:	e0 80 00 8b 	breq	80008666 <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008554:	58 1c       	cp.w	r12,1
80008556:	c0 51       	brne	80008560 <f_write+0xa0>
80008558:	30 28       	mov	r8,2
8000855a:	ae f8       	st.b	r7[0x7],r8
8000855c:	30 22       	mov	r2,2
8000855e:	c8 f8       	rjmp	8000867c <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008560:	5b fc       	cp.w	r12,-1
80008562:	c0 51       	brne	8000856c <f_write+0xac>
80008564:	30 18       	mov	r8,1
80008566:	ae f8       	st.b	r7[0x7],r8
80008568:	30 12       	mov	r2,1
8000856a:	c8 98       	rjmp	8000867c <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
8000856c:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
8000856e:	6e 48       	ld.w	r8,r7[0x10]
80008570:	58 08       	cp.w	r8,0
80008572:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
80008576:	0f e8       	ld.ub	r8,r7[0x6]
80008578:	e2 18 00 40 	andl	r8,0x40,COH
8000857c:	c1 00       	breq	8000859c <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000857e:	6e 08       	ld.w	r8,r7[0x0]
80008580:	30 19       	mov	r9,1
80008582:	6e 6a       	ld.w	r10,r7[0x18]
80008584:	40 1b       	lddsp	r11,sp[0x4]
80008586:	11 9c       	ld.ub	r12,r8[0x1]
80008588:	f0 1f 00 42 	mcall	80008690 <f_write+0x1d0>
8000858c:	c0 50       	breq	80008596 <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
8000858e:	30 18       	mov	r8,1
80008590:	ae f8       	st.b	r7[0x7],r8
80008592:	30 12       	mov	r2,1
80008594:	c7 48       	rjmp	8000867c <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
80008596:	0f e8       	ld.ub	r8,r7[0x6]
80008598:	a7 c8       	cbr	r8,0x6
8000859a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
8000859c:	6e 01       	ld.w	r1,r7[0x0]
8000859e:	6e 5b       	ld.w	r11,r7[0x14]
800085a0:	02 9c       	mov	r12,r1
800085a2:	f0 1f 00 3d 	mcall	80008694 <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
800085a6:	c0 51       	brne	800085b0 <f_write+0xf0>
800085a8:	30 28       	mov	r8,2
800085aa:	ae f8       	st.b	r7[0x7],r8
800085ac:	30 22       	mov	r2,2
800085ae:	c6 78       	rjmp	8000867c <f_write+0x1bc>
			sect += csect;
800085b0:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
800085b4:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
800085b8:	c2 70       	breq	80008606 <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
800085ba:	03 a9       	ld.ub	r9,r1[0x2]
800085bc:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
800085c0:	12 38       	cp.w	r8,r9
800085c2:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
800085c6:	04 99       	mov	r9,r2
800085c8:	00 9a       	mov	r10,r0
800085ca:	06 9b       	mov	r11,r3
800085cc:	03 9c       	ld.ub	r12,r1[0x1]
800085ce:	f0 1f 00 31 	mcall	80008690 <f_write+0x1d0>
800085d2:	c0 50       	breq	800085dc <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
800085d4:	30 18       	mov	r8,1
800085d6:	ae f8       	st.b	r7[0x7],r8
800085d8:	30 12       	mov	r2,1
800085da:	c5 18       	rjmp	8000867c <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
800085dc:	6e 6b       	ld.w	r11,r7[0x18]
800085de:	f6 00 01 00 	sub	r0,r11,r0
800085e2:	00 32       	cp.w	r2,r0
800085e4:	e0 88 00 0e 	brls	80008600 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
800085e8:	e0 0b 15 09 	lsl	r11,r0,0x9
800085ec:	e0 6a 02 00 	mov	r10,512
800085f0:	e6 0b 00 0b 	add	r11,r3,r11
800085f4:	40 0c       	lddsp	r12,sp[0x0]
800085f6:	f0 1f 00 29 	mcall	80008698 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
800085fa:	0f e8       	ld.ub	r8,r7[0x6]
800085fc:	a7 c8       	cbr	r8,0x6
800085fe:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
80008600:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008604:	c2 78       	rjmp	80008652 <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
80008606:	6e 68       	ld.w	r8,r7[0x18]
80008608:	00 38       	cp.w	r8,r0
8000860a:	c1 00       	breq	8000862a <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
8000860c:	6e 29       	ld.w	r9,r7[0x8]
8000860e:	6e 38       	ld.w	r8,r7[0xc]
80008610:	10 39       	cp.w	r9,r8
80008612:	c0 c2       	brcc	8000862a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
80008614:	30 19       	mov	r9,1
80008616:	00 9a       	mov	r10,r0
80008618:	40 1b       	lddsp	r11,sp[0x4]
8000861a:	03 9c       	ld.ub	r12,r1[0x1]
8000861c:	f0 1f 00 20 	mcall	8000869c <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008620:	c0 50       	breq	8000862a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008622:	30 18       	mov	r8,1
80008624:	ae f8       	st.b	r7[0x7],r8
80008626:	30 12       	mov	r2,1
80008628:	c2 a8       	rjmp	8000867c <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
8000862a:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
8000862c:	6e 2c       	ld.w	r12,r7[0x8]
8000862e:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008632:	e0 66 02 00 	mov	r6,512
80008636:	18 16       	sub	r6,r12
80008638:	0c 35       	cp.w	r5,r6
8000863a:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
8000863e:	0c 9a       	mov	r10,r6
80008640:	06 9b       	mov	r11,r3
80008642:	40 08       	lddsp	r8,sp[0x0]
80008644:	f0 0c 00 0c 	add	r12,r8,r12
80008648:	f0 1f 00 14 	mcall	80008698 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
8000864c:	0f e8       	ld.ub	r8,r7[0x6]
8000864e:	a7 a8       	sbr	r8,0x6
80008650:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008652:	6e 28       	ld.w	r8,r7[0x8]
80008654:	0c 08       	add	r8,r6
80008656:	8f 28       	st.w	r7[0x8],r8
80008658:	68 08       	ld.w	r8,r4[0x0]
8000865a:	0c 08       	add	r8,r6
8000865c:	89 08       	st.w	r4[0x0],r8
8000865e:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008660:	c0 50       	breq	8000866a <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008662:	0c 03       	add	r3,r6
80008664:	c5 5b       	rjmp	8000850e <f_write+0x4e>
80008666:	40 22       	lddsp	r2,sp[0x8]
80008668:	c0 28       	rjmp	8000866c <f_write+0x1ac>
8000866a:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
8000866c:	6e 28       	ld.w	r8,r7[0x8]
8000866e:	6e 39       	ld.w	r9,r7[0xc]
80008670:	12 38       	cp.w	r8,r9
80008672:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
80008676:	0f e8       	ld.ub	r8,r7[0x6]
80008678:	a5 b8       	sbr	r8,0x5
8000867a:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
8000867c:	04 9c       	mov	r12,r2
8000867e:	2f dd       	sub	sp,-12
80008680:	d8 32       	popm	r0-r7,pc
80008682:	00 00       	add	r0,r0
80008684:	80 00       	ld.sh	r0,r0[0x0]
80008686:	6a ec       	ld.w	r12,r5[0x38]
80008688:	80 00       	ld.sh	r0,r0[0x0]
8000868a:	73 e0       	ld.w	r0,r9[0x78]
8000868c:	80 00       	ld.sh	r0,r0[0x0]
8000868e:	61 ec       	ld.w	r12,r0[0x78]
80008690:	80 00       	ld.sh	r0,r0[0x0]
80008692:	61 60       	ld.w	r0,r0[0x58]
80008694:	80 00       	ld.sh	r0,r0[0x0]
80008696:	61 d4       	ld.w	r4,r0[0x74]
80008698:	80 00       	ld.sh	r0,r0[0x0]
8000869a:	61 98       	ld.w	r8,r0[0x64]
8000869c:	80 00       	ld.sh	r0,r0[0x0]
8000869e:	61 7c       	ld.w	r12,r0[0x5c]

800086a0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800086a0:	f8 c8 ff f8 	sub	r8,r12,-8
800086a4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800086a6:	3f f9       	mov	r9,-1
800086a8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800086aa:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800086ac:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800086ae:	30 08       	mov	r8,0
800086b0:	99 08       	st.w	r12[0x0],r8
}
800086b2:	5e fc       	retal	r12

800086b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800086b4:	30 08       	mov	r8,0
800086b6:	99 48       	st.w	r12[0x10],r8
}
800086b8:	5e fc       	retal	r12

800086ba <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800086ba:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800086bc:	70 19       	ld.w	r9,r8[0x4]
800086be:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800086c0:	78 19       	ld.w	r9,r12[0x4]
800086c2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800086c4:	70 19       	ld.w	r9,r8[0x4]
800086c6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800086c8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800086ca:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800086cc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800086ce:	78 08       	ld.w	r8,r12[0x0]
800086d0:	2f f8       	sub	r8,-1
800086d2:	99 08       	st.w	r12[0x0],r8
}
800086d4:	5e fc       	retal	r12

800086d6 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800086d6:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800086d8:	5b fa       	cp.w	r10,-1
800086da:	c0 31       	brne	800086e0 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800086dc:	78 48       	ld.w	r8,r12[0x10]
800086de:	c0 c8       	rjmp	800086f6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800086e0:	f8 c8 ff f8 	sub	r8,r12,-8
800086e4:	70 19       	ld.w	r9,r8[0x4]
800086e6:	72 09       	ld.w	r9,r9[0x0]
800086e8:	12 3a       	cp.w	r10,r9
800086ea:	c0 63       	brcs	800086f6 <vListInsert+0x20>
800086ec:	70 18       	ld.w	r8,r8[0x4]
800086ee:	70 19       	ld.w	r9,r8[0x4]
800086f0:	72 09       	ld.w	r9,r9[0x0]
800086f2:	12 3a       	cp.w	r10,r9
800086f4:	cf c2       	brcc	800086ec <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800086f6:	70 19       	ld.w	r9,r8[0x4]
800086f8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800086fa:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800086fc:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800086fe:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008700:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008702:	78 08       	ld.w	r8,r12[0x0]
80008704:	2f f8       	sub	r8,-1
80008706:	99 08       	st.w	r12[0x0],r8
}
80008708:	5e fc       	retal	r12

8000870a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000870a:	78 18       	ld.w	r8,r12[0x4]
8000870c:	78 29       	ld.w	r9,r12[0x8]
8000870e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80008710:	78 28       	ld.w	r8,r12[0x8]
80008712:	78 19       	ld.w	r9,r12[0x4]
80008714:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80008716:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008718:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000871a:	18 39       	cp.w	r9,r12
8000871c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80008720:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008724:	30 09       	mov	r9,0
80008726:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008728:	70 09       	ld.w	r9,r8[0x0]
8000872a:	20 19       	sub	r9,1
8000872c:	91 09       	st.w	r8[0x0],r9
}
8000872e:	5e fc       	retal	r12

80008730 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008730:	e0 68 08 08 	mov	r8,2056
80008734:	ea 18 08 08 	orh	r8,0x808
80008738:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000873a:	e0 68 09 09 	mov	r8,2313
8000873e:	ea 18 09 09 	orh	r8,0x909
80008742:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008744:	e0 68 0a 0a 	mov	r8,2570
80008748:	ea 18 0a 0a 	orh	r8,0xa0a
8000874c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000874e:	e0 68 0b 0b 	mov	r8,2827
80008752:	ea 18 0b 0b 	orh	r8,0xb0b
80008756:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008758:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000875a:	e0 68 be ef 	mov	r8,48879
8000875e:	ea 18 de ad 	orh	r8,0xdead
80008762:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008764:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008766:	fc 18 00 40 	movh	r8,0x40
8000876a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000876c:	e0 68 00 ff 	mov	r8,255
80008770:	ea 18 ff 00 	orh	r8,0xff00
80008774:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008776:	e0 68 01 01 	mov	r8,257
8000877a:	ea 18 01 01 	orh	r8,0x101
8000877e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80008780:	e0 68 02 02 	mov	r8,514
80008784:	ea 18 02 02 	orh	r8,0x202
80008788:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000878a:	e0 68 03 03 	mov	r8,771
8000878e:	ea 18 03 03 	orh	r8,0x303
80008792:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80008794:	e0 68 04 04 	mov	r8,1028
80008798:	ea 18 04 04 	orh	r8,0x404
8000879c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000879e:	e0 68 05 05 	mov	r8,1285
800087a2:	ea 18 05 05 	orh	r8,0x505
800087a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800087a8:	e0 68 06 06 	mov	r8,1542
800087ac:	ea 18 06 06 	orh	r8,0x606
800087b0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800087b2:	e0 68 07 07 	mov	r8,1799
800087b6:	ea 18 07 07 	orh	r8,0x707
800087ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800087bc:	30 08       	mov	r8,0
800087be:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800087c0:	5e fc       	retal	r12
800087c2:	d7 03       	nop

800087c4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800087c4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800087c6:	48 38       	lddpc	r8,800087d0 <vPortEnterCritical+0xc>
800087c8:	70 09       	ld.w	r9,r8[0x0]
800087ca:	2f f9       	sub	r9,-1
800087cc:	91 09       	st.w	r8[0x0],r9
}
800087ce:	5e fc       	retal	r12
800087d0:	00 00       	add	r0,r0
800087d2:	05 30       	ld.ub	r0,r2++

800087d4 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800087d4:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800087d6:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800087d8:	30 0a       	mov	r10,0
800087da:	14 9b       	mov	r11,r10
800087dc:	49 2c       	lddpc	r12,80008824 <xPortStartScheduler+0x50>
800087de:	f0 1f 00 13 	mcall	80008828 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800087e2:	e0 68 5d c0 	mov	r8,24000
800087e6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800087ea:	30 08       	mov	r8,0
800087ec:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800087f0:	e0 68 12 1c 	mov	r8,4636
800087f4:	ea 18 00 00 	orh	r8,0x0
800087f8:	70 00       	ld.w	r0,r8[0x0]
800087fa:	60 0d       	ld.w	sp,r0[0x0]
800087fc:	1b 00       	ld.w	r0,sp++
800087fe:	e0 68 05 30 	mov	r8,1328
80008802:	ea 18 00 00 	orh	r8,0x0
80008806:	91 00       	st.w	r8[0x0],r0
80008808:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000880c:	2f ed       	sub	sp,-8
8000880e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008812:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008816:	e3 b0 00 00 	mtsr	0x0,r0
8000881a:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000881e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80008822:	d8 0a       	popm	pc,r12=0
80008824:	80 00       	ld.sh	r0,r0[0x0]
80008826:	88 f0       	ld.uh	r0,r4[0xe]
80008828:	80 00       	ld.sh	r0,r0[0x0]
8000882a:	58 94       	cp.w	r4,9

8000882c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000882c:	20 6d       	sub	sp,24
8000882e:	eb cd 00 ff 	pushm	r0-r7
80008832:	fa c7 ff c0 	sub	r7,sp,-64
80008836:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000883a:	ef 40 ff e0 	st.w	r7[-32],r0
8000883e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80008842:	ef 40 ff e4 	st.w	r7[-28],r0
80008846:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000884a:	e0 68 05 30 	mov	r8,1328
8000884e:	ea 18 00 00 	orh	r8,0x0
80008852:	70 00       	ld.w	r0,r8[0x0]
80008854:	1a d0       	st.w	--sp,r0
80008856:	f0 1f 00 1a 	mcall	800088bc <LABEL_RET_SCALL_263+0x14>
8000885a:	e0 68 12 1c 	mov	r8,4636
8000885e:	ea 18 00 00 	orh	r8,0x0
80008862:	70 00       	ld.w	r0,r8[0x0]
80008864:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80008866:	f0 1f 00 17 	mcall	800088c0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000886a:	e0 68 12 1c 	mov	r8,4636
8000886e:	ea 18 00 00 	orh	r8,0x0
80008872:	70 00       	ld.w	r0,r8[0x0]
80008874:	60 0d       	ld.w	sp,r0[0x0]
80008876:	1b 00       	ld.w	r0,sp++
80008878:	e0 68 05 30 	mov	r8,1328
8000887c:	ea 18 00 00 	orh	r8,0x0
80008880:	91 00       	st.w	r8[0x0],r0
80008882:	fa c7 ff d8 	sub	r7,sp,-40
80008886:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000888a:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000888e:	e0 61 05 30 	mov	r1,1328
80008892:	ea 11 00 00 	orh	r1,0x0
80008896:	62 02       	ld.w	r2,r1[0x0]
80008898:	58 02       	cp.w	r2,0
8000889a:	c0 70       	breq	800088a8 <LABEL_RET_SCALL_263>
8000889c:	e4 c2 00 01 	sub	r2,r2,1
800088a0:	83 02       	st.w	r1[0x0],r2
800088a2:	58 02       	cp.w	r2,0
800088a4:	c0 21       	brne	800088a8 <LABEL_RET_SCALL_263>
800088a6:	b1 c0       	cbr	r0,0x10

800088a8 <LABEL_RET_SCALL_263>:
800088a8:	ef 40 ff f8 	st.w	r7[-8],r0
800088ac:	ee f0 ff e4 	ld.w	r0,r7[-28]
800088b0:	ef 40 ff fc 	st.w	r7[-4],r0
800088b4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800088b8:	2f ad       	sub	sp,-24
800088ba:	d6 13       	rets
800088bc:	80 00       	ld.sh	r0,r0[0x0]
800088be:	87 c4       	st.w	r3[0x30],r4
800088c0:	80 00       	ld.sh	r0,r0[0x0]
800088c2:	8f 60       	st.w	r7[0x18],r0

800088c4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800088c4:	e1 b8 00 43 	mfsr	r8,0x10c
800088c8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800088cc:	5e fc       	retal	r12
800088ce:	d7 03       	nop

800088d0 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800088d0:	48 78       	lddpc	r8,800088ec <vPortExitCritical+0x1c>
800088d2:	70 08       	ld.w	r8,r8[0x0]
800088d4:	58 08       	cp.w	r8,0
800088d6:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800088d8:	48 58       	lddpc	r8,800088ec <vPortExitCritical+0x1c>
800088da:	70 09       	ld.w	r9,r8[0x0]
800088dc:	20 19       	sub	r9,1
800088de:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800088e0:	70 08       	ld.w	r8,r8[0x0]
800088e2:	58 08       	cp.w	r8,0
800088e4:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800088e6:	d5 03       	csrf	0x10
800088e8:	5e fc       	retal	r12
800088ea:	00 00       	add	r0,r0
800088ec:	00 00       	add	r0,r0
800088ee:	05 30       	ld.ub	r0,r2++

800088f0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800088f0:	eb cd 00 ff 	pushm	r0-r7
800088f4:	e0 68 05 30 	mov	r8,1328
800088f8:	ea 18 00 00 	orh	r8,0x0
800088fc:	70 00       	ld.w	r0,r8[0x0]
800088fe:	1a d0       	st.w	--sp,r0
80008900:	7a 90       	ld.w	r0,sp[0x24]
80008902:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008906:	58 10       	cp.w	r0,1
80008908:	e0 8b 00 08 	brhi	80008918 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
8000890c:	e0 68 12 1c 	mov	r8,4636
80008910:	ea 18 00 00 	orh	r8,0x0
80008914:	70 00       	ld.w	r0,r8[0x0]
80008916:	81 0d       	st.w	r0[0x0],sp

80008918 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008918:	f0 1f 00 12 	mcall	80008960 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
8000891c:	f0 1f 00 12 	mcall	80008964 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008920:	f0 1f 00 12 	mcall	80008968 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008924:	f0 1f 00 12 	mcall	8000896c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008928:	7a 90       	ld.w	r0,sp[0x24]
8000892a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000892e:	58 10       	cp.w	r0,1
80008930:	e0 8b 00 0e 	brhi	8000894c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008934:	f0 1f 00 0c 	mcall	80008964 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008938:	f0 1f 00 0e 	mcall	80008970 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
8000893c:	f0 1f 00 0c 	mcall	8000896c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008940:	e0 68 12 1c 	mov	r8,4636
80008944:	ea 18 00 00 	orh	r8,0x0
80008948:	70 00       	ld.w	r0,r8[0x0]
8000894a:	60 0d       	ld.w	sp,r0[0x0]

8000894c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
8000894c:	1b 00       	ld.w	r0,sp++
8000894e:	e0 68 05 30 	mov	r8,1328
80008952:	ea 18 00 00 	orh	r8,0x0
80008956:	91 00       	st.w	r8[0x0],r0
80008958:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000895c:	d6 03       	rete
8000895e:	00 00       	add	r0,r0
80008960:	80 00       	ld.sh	r0,r0[0x0]
80008962:	88 c4       	ld.uh	r4,r4[0x8]
80008964:	80 00       	ld.sh	r0,r0[0x0]
80008966:	87 c4       	st.w	r3[0x30],r4
80008968:	80 00       	ld.sh	r0,r0[0x0]
8000896a:	91 64       	st.w	r8[0x18],r4
8000896c:	80 00       	ld.sh	r0,r0[0x0]
8000896e:	88 d0       	ld.uh	r0,r4[0xa]
80008970:	80 00       	ld.sh	r0,r0[0x0]
80008972:	8f 60       	st.w	r7[0x18],r0

80008974 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008974:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008976:	f0 1f 00 02 	mcall	8000897c <__malloc_lock+0x8>
}
8000897a:	d8 02       	popm	pc
8000897c:	80 00       	ld.sh	r0,r0[0x0]
8000897e:	8f 50       	st.w	r7[0x14],r0

80008980 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008980:	d4 01       	pushm	lr
	xTaskResumeAll();
80008982:	f0 1f 00 02 	mcall	80008988 <__malloc_unlock+0x8>
}
80008986:	d8 02       	popm	pc
80008988:	80 00       	ld.sh	r0,r0[0x0]
8000898a:	93 0c       	st.w	r9[0x0],r12

8000898c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
8000898c:	d4 21       	pushm	r4-r7,lr
8000898e:	16 95       	mov	r5,r11
80008990:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008992:	58 0c       	cp.w	r12,0
80008994:	c0 30       	breq	8000899a <_read+0xe>
80008996:	3f f7       	mov	r7,-1
80008998:	c1 48       	rjmp	800089c0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000899a:	58 0a       	cp.w	r10,0
8000899c:	e0 89 00 04 	brgt	800089a4 <_read+0x18>
800089a0:	30 07       	mov	r7,0
800089a2:	c0 f8       	rjmp	800089c0 <_read+0x34>
800089a4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800089a6:	48 84       	lddpc	r4,800089c4 <_read+0x38>
800089a8:	68 0c       	ld.w	r12,r4[0x0]
800089aa:	f0 1f 00 08 	mcall	800089c8 <_read+0x3c>
    if (c < 0)
800089ae:	c0 95       	brlt	800089c0 <_read+0x34>
      break;

    *ptr++ = c;
800089b0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800089b4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800089b6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800089ba:	58 08       	cp.w	r8,0
800089bc:	fe 99 ff f6 	brgt	800089a8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800089c0:	0e 9c       	mov	r12,r7
800089c2:	d8 22       	popm	r4-r7,pc
800089c4:	00 00       	add	r0,r0
800089c6:	46 18       	lddsp	r8,sp[0x184]
800089c8:	80 00       	ld.sh	r0,r0[0x0]
800089ca:	5f 88       	srls	r8

800089cc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800089cc:	d4 21       	pushm	r4-r7,lr
800089ce:	16 95       	mov	r5,r11
800089d0:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800089d2:	20 1c       	sub	r12,1
800089d4:	58 2c       	cp.w	r12,2
800089d6:	e0 8b 00 12 	brhi	800089fa <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800089da:	58 0a       	cp.w	r10,0
800089dc:	c0 31       	brne	800089e2 <_write+0x16>
800089de:	30 07       	mov	r7,0
800089e0:	c0 e8       	rjmp	800089fc <_write+0x30>
800089e2:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800089e4:	48 74       	lddpc	r4,80008a00 <_write+0x34>
800089e6:	68 0c       	ld.w	r12,r4[0x0]
800089e8:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800089ec:	f0 1f 00 06 	mcall	80008a04 <_write+0x38>
800089f0:	c0 55       	brlt	800089fa <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800089f2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800089f4:	0e 36       	cp.w	r6,r7
800089f6:	cf 81       	brne	800089e6 <_write+0x1a>
800089f8:	c0 28       	rjmp	800089fc <_write+0x30>
800089fa:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800089fc:	0e 9c       	mov	r12,r7
800089fe:	d8 22       	popm	r4-r7,pc
80008a00:	00 00       	add	r0,r0
80008a02:	46 18       	lddsp	r8,sp[0x184]
80008a04:	80 00       	ld.sh	r0,r0[0x0]
80008a06:	5f 38       	srlo	r8

80008a08 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008a08:	eb cd 40 80 	pushm	r7,lr
80008a0c:	18 97       	mov	r7,r12
	if( pv )
80008a0e:	58 0c       	cp.w	r12,0
80008a10:	c0 80       	breq	80008a20 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80008a12:	f0 1f 00 05 	mcall	80008a24 <vPortFree+0x1c>
		{
			free( pv );
80008a16:	0e 9c       	mov	r12,r7
80008a18:	f0 1f 00 04 	mcall	80008a28 <vPortFree+0x20>
		}
		xTaskResumeAll();
80008a1c:	f0 1f 00 04 	mcall	80008a2c <vPortFree+0x24>
80008a20:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a24:	80 00       	ld.sh	r0,r0[0x0]
80008a26:	8f 50       	st.w	r7[0x14],r0
80008a28:	80 00       	ld.sh	r0,r0[0x0]
80008a2a:	9e bc       	ld.uh	r12,pc[0x6]
80008a2c:	80 00       	ld.sh	r0,r0[0x0]
80008a2e:	93 0c       	st.w	r9[0x0],r12

80008a30 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008a30:	eb cd 40 80 	pushm	r7,lr
80008a34:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80008a36:	f0 1f 00 06 	mcall	80008a4c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80008a3a:	0e 9c       	mov	r12,r7
80008a3c:	f0 1f 00 05 	mcall	80008a50 <pvPortMalloc+0x20>
80008a40:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80008a42:	f0 1f 00 05 	mcall	80008a54 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80008a46:	0e 9c       	mov	r12,r7
80008a48:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a4c:	80 00       	ld.sh	r0,r0[0x0]
80008a4e:	8f 50       	st.w	r7[0x14],r0
80008a50:	80 00       	ld.sh	r0,r0[0x0]
80008a52:	9e cc       	ld.uh	r12,pc[0x8]
80008a54:	80 00       	ld.sh	r0,r0[0x0]
80008a56:	93 0c       	st.w	r9[0x0],r12

80008a58 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008a58:	d4 01       	pushm	lr
80008a5a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80008a5c:	78 09       	ld.w	r9,r12[0x0]
80008a5e:	58 09       	cp.w	r9,0
80008a60:	c1 10       	breq	80008a82 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80008a62:	78 3a       	ld.w	r10,r12[0xc]
80008a64:	79 09       	ld.w	r9,r12[0x40]
80008a66:	f4 09 00 09 	add	r9,r10,r9
80008a6a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80008a6c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80008a6e:	14 39       	cp.w	r9,r10
80008a70:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80008a74:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80008a78:	79 0a       	ld.w	r10,r12[0x40]
80008a7a:	78 3b       	ld.w	r11,r12[0xc]
80008a7c:	10 9c       	mov	r12,r8
80008a7e:	f0 1f 00 02 	mcall	80008a84 <prvCopyDataFromQueue+0x2c>
80008a82:	d8 02       	popm	pc
80008a84:	80 00       	ld.sh	r0,r0[0x0]
80008a86:	a3 3a       	mul	r10,r1

80008a88 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80008a88:	eb cd 40 c0 	pushm	r6-r7,lr
80008a8c:	18 97       	mov	r7,r12
80008a8e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008a90:	78 e8       	ld.w	r8,r12[0x38]
80008a92:	58 08       	cp.w	r8,0
80008a94:	c0 31       	brne	80008a9a <xQueueReceiveFromISR+0x12>
80008a96:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80008a9a:	f0 1f 00 0e 	mcall	80008ad0 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80008a9e:	6e e8       	ld.w	r8,r7[0x38]
80008aa0:	20 18       	sub	r8,1
80008aa2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80008aa4:	6f 18       	ld.w	r8,r7[0x44]
80008aa6:	5b f8       	cp.w	r8,-1
80008aa8:	c0 d1       	brne	80008ac2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008aaa:	6e 48       	ld.w	r8,r7[0x10]
80008aac:	58 08       	cp.w	r8,0
80008aae:	c0 f0       	breq	80008acc <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008ab0:	ee cc ff f0 	sub	r12,r7,-16
80008ab4:	f0 1f 00 08 	mcall	80008ad4 <xQueueReceiveFromISR+0x4c>
80008ab8:	c0 a0       	breq	80008acc <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80008aba:	30 1c       	mov	r12,1
80008abc:	8d 0c       	st.w	r6[0x0],r12
80008abe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80008ac2:	2f f8       	sub	r8,-1
80008ac4:	ef 48 00 44 	st.w	r7[68],r8
80008ac8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008acc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008ad0:	80 00       	ld.sh	r0,r0[0x0]
80008ad2:	8a 58       	ld.sh	r8,r5[0xa]
80008ad4:	80 00       	ld.sh	r0,r0[0x0]
80008ad6:	90 e8       	ld.uh	r8,r8[0xc]

80008ad8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80008ad8:	eb cd 40 c0 	pushm	r6-r7,lr
80008adc:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80008ade:	f0 1f 00 23 	mcall	80008b68 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008ae2:	6f 28       	ld.w	r8,r7[0x48]
80008ae4:	58 08       	cp.w	r8,0
80008ae6:	e0 8a 00 18 	brle	80008b16 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008aea:	6e 98       	ld.w	r8,r7[0x24]
80008aec:	58 08       	cp.w	r8,0
80008aee:	c1 40       	breq	80008b16 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008af0:	ee c6 ff dc 	sub	r6,r7,-36
80008af4:	c0 48       	rjmp	80008afc <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008af6:	6e 98       	ld.w	r8,r7[0x24]
80008af8:	58 08       	cp.w	r8,0
80008afa:	c0 e0       	breq	80008b16 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008afc:	0c 9c       	mov	r12,r6
80008afe:	f0 1f 00 1c 	mcall	80008b6c <prvUnlockQueue+0x94>
80008b02:	c0 30       	breq	80008b08 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80008b04:	f0 1f 00 1b 	mcall	80008b70 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80008b08:	6f 28       	ld.w	r8,r7[0x48]
80008b0a:	20 18       	sub	r8,1
80008b0c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008b10:	58 08       	cp.w	r8,0
80008b12:	fe 99 ff f2 	brgt	80008af6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80008b16:	3f f8       	mov	r8,-1
80008b18:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80008b1c:	f0 1f 00 16 	mcall	80008b74 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80008b20:	f0 1f 00 12 	mcall	80008b68 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008b24:	6f 18       	ld.w	r8,r7[0x44]
80008b26:	58 08       	cp.w	r8,0
80008b28:	e0 8a 00 18 	brle	80008b58 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008b2c:	6e 48       	ld.w	r8,r7[0x10]
80008b2e:	58 08       	cp.w	r8,0
80008b30:	c1 40       	breq	80008b58 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008b32:	ee c6 ff f0 	sub	r6,r7,-16
80008b36:	c0 48       	rjmp	80008b3e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008b38:	6e 48       	ld.w	r8,r7[0x10]
80008b3a:	58 08       	cp.w	r8,0
80008b3c:	c0 e0       	breq	80008b58 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008b3e:	0c 9c       	mov	r12,r6
80008b40:	f0 1f 00 0b 	mcall	80008b6c <prvUnlockQueue+0x94>
80008b44:	c0 30       	breq	80008b4a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80008b46:	f0 1f 00 0b 	mcall	80008b70 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80008b4a:	6f 18       	ld.w	r8,r7[0x44]
80008b4c:	20 18       	sub	r8,1
80008b4e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008b52:	58 08       	cp.w	r8,0
80008b54:	fe 99 ff f2 	brgt	80008b38 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80008b58:	3f f8       	mov	r8,-1
80008b5a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80008b5e:	f0 1f 00 06 	mcall	80008b74 <prvUnlockQueue+0x9c>
}
80008b62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008b66:	00 00       	add	r0,r0
80008b68:	80 00       	ld.sh	r0,r0[0x0]
80008b6a:	87 c4       	st.w	r3[0x30],r4
80008b6c:	80 00       	ld.sh	r0,r0[0x0]
80008b6e:	90 e8       	ld.uh	r8,r8[0xc]
80008b70:	80 00       	ld.sh	r0,r0[0x0]
80008b72:	8f f4       	st.w	r7[0x3c],r4
80008b74:	80 00       	ld.sh	r0,r0[0x0]
80008b76:	88 d0       	ld.uh	r0,r4[0xa]

80008b78 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80008b78:	d4 31       	pushm	r0-r7,lr
80008b7a:	20 5d       	sub	sp,20
80008b7c:	18 97       	mov	r7,r12
80008b7e:	50 0b       	stdsp	sp[0x0],r11
80008b80:	50 2a       	stdsp	sp[0x8],r10
80008b82:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008b84:	f8 c2 ff dc 	sub	r2,r12,-36
80008b88:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008b8a:	fa c4 ff f4 	sub	r4,sp,-12
80008b8e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008b90:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008b92:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80008b96:	f0 1f 00 3e 	mcall	80008c8c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008b9a:	6e e8       	ld.w	r8,r7[0x38]
80008b9c:	58 08       	cp.w	r8,0
80008b9e:	c2 a0       	breq	80008bf2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80008ba0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80008ba2:	40 0b       	lddsp	r11,sp[0x0]
80008ba4:	0e 9c       	mov	r12,r7
80008ba6:	f0 1f 00 3b 	mcall	80008c90 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80008baa:	40 18       	lddsp	r8,sp[0x4]
80008bac:	58 08       	cp.w	r8,0
80008bae:	c1 51       	brne	80008bd8 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80008bb0:	6e e8       	ld.w	r8,r7[0x38]
80008bb2:	20 18       	sub	r8,1
80008bb4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008bb6:	6e 08       	ld.w	r8,r7[0x0]
80008bb8:	58 08       	cp.w	r8,0
80008bba:	c0 41       	brne	80008bc2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80008bbc:	f0 1f 00 36 	mcall	80008c94 <xQueueGenericReceive+0x11c>
80008bc0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008bc2:	6e 48       	ld.w	r8,r7[0x10]
80008bc4:	58 08       	cp.w	r8,0
80008bc6:	c1 20       	breq	80008bea <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80008bc8:	ee cc ff f0 	sub	r12,r7,-16
80008bcc:	f0 1f 00 33 	mcall	80008c98 <xQueueGenericReceive+0x120>
80008bd0:	58 1c       	cp.w	r12,1
80008bd2:	c0 c1       	brne	80008bea <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80008bd4:	d7 33       	scall
80008bd6:	c0 a8       	rjmp	80008bea <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80008bd8:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008bda:	6e 98       	ld.w	r8,r7[0x24]
80008bdc:	58 08       	cp.w	r8,0
80008bde:	c0 60       	breq	80008bea <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008be0:	04 9c       	mov	r12,r2
80008be2:	f0 1f 00 2e 	mcall	80008c98 <xQueueGenericReceive+0x120>
80008be6:	c0 20       	breq	80008bea <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80008be8:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80008bea:	f0 1f 00 2d 	mcall	80008c9c <xQueueGenericReceive+0x124>
80008bee:	30 1c       	mov	r12,1
				return pdPASS;
80008bf0:	c4 c8       	rjmp	80008c88 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008bf2:	40 28       	lddsp	r8,sp[0x8]
80008bf4:	58 08       	cp.w	r8,0
80008bf6:	c0 51       	brne	80008c00 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008bf8:	f0 1f 00 29 	mcall	80008c9c <xQueueGenericReceive+0x124>
80008bfc:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80008bfe:	c4 58       	rjmp	80008c88 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80008c00:	58 05       	cp.w	r5,0
80008c02:	c0 51       	brne	80008c0c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008c04:	08 9c       	mov	r12,r4
80008c06:	f0 1f 00 27 	mcall	80008ca0 <xQueueGenericReceive+0x128>
80008c0a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008c0c:	f0 1f 00 24 	mcall	80008c9c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008c10:	f0 1f 00 25 	mcall	80008ca4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80008c14:	f0 1f 00 1e 	mcall	80008c8c <xQueueGenericReceive+0x114>
80008c18:	6f 18       	ld.w	r8,r7[0x44]
80008c1a:	5b f8       	cp.w	r8,-1
80008c1c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008c20:	6f 28       	ld.w	r8,r7[0x48]
80008c22:	5b f8       	cp.w	r8,-1
80008c24:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008c28:	f0 1f 00 1d 	mcall	80008c9c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008c2c:	06 9b       	mov	r11,r3
80008c2e:	08 9c       	mov	r12,r4
80008c30:	f0 1f 00 1e 	mcall	80008ca8 <xQueueGenericReceive+0x130>
80008c34:	c2 41       	brne	80008c7c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008c36:	f0 1f 00 16 	mcall	80008c8c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80008c3a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80008c3c:	f0 1f 00 18 	mcall	80008c9c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80008c40:	58 06       	cp.w	r6,0
80008c42:	c1 71       	brne	80008c70 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008c44:	6e 08       	ld.w	r8,r7[0x0]
80008c46:	58 08       	cp.w	r8,0
80008c48:	c0 81       	brne	80008c58 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80008c4a:	f0 1f 00 11 	mcall	80008c8c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80008c4e:	6e 1c       	ld.w	r12,r7[0x4]
80008c50:	f0 1f 00 17 	mcall	80008cac <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80008c54:	f0 1f 00 12 	mcall	80008c9c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008c58:	40 2b       	lddsp	r11,sp[0x8]
80008c5a:	04 9c       	mov	r12,r2
80008c5c:	f0 1f 00 15 	mcall	80008cb0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80008c60:	0e 9c       	mov	r12,r7
80008c62:	f0 1f 00 15 	mcall	80008cb4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80008c66:	f0 1f 00 15 	mcall	80008cb8 <xQueueGenericReceive+0x140>
80008c6a:	c9 61       	brne	80008b96 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80008c6c:	d7 33       	scall
80008c6e:	c9 4b       	rjmp	80008b96 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008c70:	0e 9c       	mov	r12,r7
80008c72:	f0 1f 00 11 	mcall	80008cb4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80008c76:	f0 1f 00 11 	mcall	80008cb8 <xQueueGenericReceive+0x140>
80008c7a:	c8 eb       	rjmp	80008b96 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80008c7c:	0e 9c       	mov	r12,r7
80008c7e:	f0 1f 00 0e 	mcall	80008cb4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80008c82:	f0 1f 00 0e 	mcall	80008cb8 <xQueueGenericReceive+0x140>
80008c86:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80008c88:	2f bd       	sub	sp,-20
80008c8a:	d8 32       	popm	r0-r7,pc
80008c8c:	80 00       	ld.sh	r0,r0[0x0]
80008c8e:	87 c4       	st.w	r3[0x30],r4
80008c90:	80 00       	ld.sh	r0,r0[0x0]
80008c92:	8a 58       	ld.sh	r8,r5[0xa]
80008c94:	80 00       	ld.sh	r0,r0[0x0]
80008c96:	90 00       	ld.sh	r0,r8[0x0]
80008c98:	80 00       	ld.sh	r0,r0[0x0]
80008c9a:	90 e8       	ld.uh	r8,r8[0xc]
80008c9c:	80 00       	ld.sh	r0,r0[0x0]
80008c9e:	88 d0       	ld.uh	r0,r4[0xa]
80008ca0:	80 00       	ld.sh	r0,r0[0x0]
80008ca2:	8f dc       	st.w	r7[0x34],r12
80008ca4:	80 00       	ld.sh	r0,r0[0x0]
80008ca6:	8f 50       	st.w	r7[0x14],r0
80008ca8:	80 00       	ld.sh	r0,r0[0x0]
80008caa:	92 78       	ld.sh	r8,r9[0xe]
80008cac:	80 00       	ld.sh	r0,r0[0x0]
80008cae:	90 64       	ld.sh	r4,r8[0xc]
80008cb0:	80 00       	ld.sh	r0,r0[0x0]
80008cb2:	94 d0       	ld.uh	r0,r10[0xa]
80008cb4:	80 00       	ld.sh	r0,r0[0x0]
80008cb6:	8a d8       	ld.uh	r8,r5[0xa]
80008cb8:	80 00       	ld.sh	r0,r0[0x0]
80008cba:	93 0c       	st.w	r9[0x0],r12

80008cbc <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80008cbc:	eb cd 40 80 	pushm	r7,lr
80008cc0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80008cc2:	79 08       	ld.w	r8,r12[0x40]
80008cc4:	58 08       	cp.w	r8,0
80008cc6:	c0 a1       	brne	80008cda <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008cc8:	78 08       	ld.w	r8,r12[0x0]
80008cca:	58 08       	cp.w	r8,0
80008ccc:	c2 b1       	brne	80008d22 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80008cce:	78 1c       	ld.w	r12,r12[0x4]
80008cd0:	f0 1f 00 17 	mcall	80008d2c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80008cd4:	30 08       	mov	r8,0
80008cd6:	8f 18       	st.w	r7[0x4],r8
80008cd8:	c2 58       	rjmp	80008d22 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80008cda:	58 0a       	cp.w	r10,0
80008cdc:	c1 01       	brne	80008cfc <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008cde:	10 9a       	mov	r10,r8
80008ce0:	78 2c       	ld.w	r12,r12[0x8]
80008ce2:	f0 1f 00 14 	mcall	80008d30 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80008ce6:	6e 29       	ld.w	r9,r7[0x8]
80008ce8:	6f 08       	ld.w	r8,r7[0x40]
80008cea:	f2 08 00 08 	add	r8,r9,r8
80008cee:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80008cf0:	6e 19       	ld.w	r9,r7[0x4]
80008cf2:	12 38       	cp.w	r8,r9
80008cf4:	c1 73       	brcs	80008d22 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80008cf6:	6e 08       	ld.w	r8,r7[0x0]
80008cf8:	8f 28       	st.w	r7[0x8],r8
80008cfa:	c1 48       	rjmp	80008d22 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008cfc:	10 9a       	mov	r10,r8
80008cfe:	78 3c       	ld.w	r12,r12[0xc]
80008d00:	f0 1f 00 0c 	mcall	80008d30 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80008d04:	6f 08       	ld.w	r8,r7[0x40]
80008d06:	6e 39       	ld.w	r9,r7[0xc]
80008d08:	f2 08 01 08 	sub	r8,r9,r8
80008d0c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80008d0e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80008d10:	12 38       	cp.w	r8,r9
80008d12:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80008d16:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80008d1a:	f3 d8 e3 19 	subcs	r9,r9,r8
80008d1e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80008d22:	6e e8       	ld.w	r8,r7[0x38]
80008d24:	2f f8       	sub	r8,-1
80008d26:	8f e8       	st.w	r7[0x38],r8
}
80008d28:	e3 cd 80 80 	ldm	sp++,r7,pc
80008d2c:	80 00       	ld.sh	r0,r0[0x0]
80008d2e:	90 0c       	ld.sh	r12,r8[0x0]
80008d30:	80 00       	ld.sh	r0,r0[0x0]
80008d32:	a3 3a       	mul	r10,r1

80008d34 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80008d34:	eb cd 40 c0 	pushm	r6-r7,lr
80008d38:	18 97       	mov	r7,r12
80008d3a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008d3c:	78 ec       	ld.w	r12,r12[0x38]
80008d3e:	6e f8       	ld.w	r8,r7[0x3c]
80008d40:	10 3c       	cp.w	r12,r8
80008d42:	c0 33       	brcs	80008d48 <xQueueGenericSendFromISR+0x14>
80008d44:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008d48:	12 9a       	mov	r10,r9
80008d4a:	0e 9c       	mov	r12,r7
80008d4c:	f0 1f 00 0c 	mcall	80008d7c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80008d50:	6f 28       	ld.w	r8,r7[0x48]
80008d52:	5b f8       	cp.w	r8,-1
80008d54:	c0 d1       	brne	80008d6e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008d56:	6e 98       	ld.w	r8,r7[0x24]
80008d58:	58 08       	cp.w	r8,0
80008d5a:	c0 f0       	breq	80008d78 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008d5c:	ee cc ff dc 	sub	r12,r7,-36
80008d60:	f0 1f 00 08 	mcall	80008d80 <xQueueGenericSendFromISR+0x4c>
80008d64:	c0 a0       	breq	80008d78 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80008d66:	30 1c       	mov	r12,1
80008d68:	8d 0c       	st.w	r6[0x0],r12
80008d6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80008d6e:	2f f8       	sub	r8,-1
80008d70:	ef 48 00 48 	st.w	r7[72],r8
80008d74:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008d78:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008d7c:	80 00       	ld.sh	r0,r0[0x0]
80008d7e:	8c bc       	ld.uh	r12,r6[0x6]
80008d80:	80 00       	ld.sh	r0,r0[0x0]
80008d82:	90 e8       	ld.uh	r8,r8[0xc]

80008d84 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008d84:	d4 31       	pushm	r0-r7,lr
80008d86:	20 5d       	sub	sp,20
80008d88:	18 97       	mov	r7,r12
80008d8a:	50 0b       	stdsp	sp[0x0],r11
80008d8c:	50 2a       	stdsp	sp[0x8],r10
80008d8e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008d90:	f8 c0 ff f0 	sub	r0,r12,-16
80008d94:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008d96:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008d9a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008d9c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80008da0:	f0 1f 00 2f 	mcall	80008e5c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008da4:	6e e9       	ld.w	r9,r7[0x38]
80008da6:	6e f8       	ld.w	r8,r7[0x3c]
80008da8:	10 39       	cp.w	r9,r8
80008daa:	c1 42       	brcc	80008dd2 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008dac:	40 1a       	lddsp	r10,sp[0x4]
80008dae:	40 0b       	lddsp	r11,sp[0x0]
80008db0:	0e 9c       	mov	r12,r7
80008db2:	f0 1f 00 2c 	mcall	80008e60 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008db6:	6e 98       	ld.w	r8,r7[0x24]
80008db8:	58 08       	cp.w	r8,0
80008dba:	c0 80       	breq	80008dca <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80008dbc:	ee cc ff dc 	sub	r12,r7,-36
80008dc0:	f0 1f 00 29 	mcall	80008e64 <xQueueGenericSend+0xe0>
80008dc4:	58 1c       	cp.w	r12,1
80008dc6:	c0 21       	brne	80008dca <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80008dc8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80008dca:	f0 1f 00 28 	mcall	80008e68 <xQueueGenericSend+0xe4>
80008dce:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80008dd0:	c4 38       	rjmp	80008e56 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008dd2:	40 28       	lddsp	r8,sp[0x8]
80008dd4:	58 08       	cp.w	r8,0
80008dd6:	c0 51       	brne	80008de0 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008dd8:	f0 1f 00 24 	mcall	80008e68 <xQueueGenericSend+0xe4>
80008ddc:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80008dde:	c3 c8       	rjmp	80008e56 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80008de0:	58 04       	cp.w	r4,0
80008de2:	c0 51       	brne	80008dec <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008de4:	06 9c       	mov	r12,r3
80008de6:	f0 1f 00 22 	mcall	80008e6c <xQueueGenericSend+0xe8>
80008dea:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008dec:	f0 1f 00 1f 	mcall	80008e68 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008df0:	f0 1f 00 20 	mcall	80008e70 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80008df4:	f0 1f 00 1a 	mcall	80008e5c <xQueueGenericSend+0xd8>
80008df8:	6f 18       	ld.w	r8,r7[0x44]
80008dfa:	5b f8       	cp.w	r8,-1
80008dfc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008e00:	6f 28       	ld.w	r8,r7[0x48]
80008e02:	5b f8       	cp.w	r8,-1
80008e04:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008e08:	f0 1f 00 18 	mcall	80008e68 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008e0c:	04 9b       	mov	r11,r2
80008e0e:	06 9c       	mov	r12,r3
80008e10:	f0 1f 00 19 	mcall	80008e74 <xQueueGenericSend+0xf0>
80008e14:	c1 b1       	brne	80008e4a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008e16:	f0 1f 00 12 	mcall	80008e5c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80008e1a:	6e e5       	ld.w	r5,r7[0x38]
80008e1c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80008e1e:	f0 1f 00 13 	mcall	80008e68 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80008e22:	0c 35       	cp.w	r5,r6
80008e24:	c0 d1       	brne	80008e3e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008e26:	40 2b       	lddsp	r11,sp[0x8]
80008e28:	00 9c       	mov	r12,r0
80008e2a:	f0 1f 00 14 	mcall	80008e78 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80008e2e:	0e 9c       	mov	r12,r7
80008e30:	f0 1f 00 13 	mcall	80008e7c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80008e34:	f0 1f 00 13 	mcall	80008e80 <xQueueGenericSend+0xfc>
80008e38:	cb 41       	brne	80008da0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80008e3a:	d7 33       	scall
80008e3c:	cb 2b       	rjmp	80008da0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008e3e:	0e 9c       	mov	r12,r7
80008e40:	f0 1f 00 0f 	mcall	80008e7c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80008e44:	f0 1f 00 0f 	mcall	80008e80 <xQueueGenericSend+0xfc>
80008e48:	ca cb       	rjmp	80008da0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80008e4a:	0e 9c       	mov	r12,r7
80008e4c:	f0 1f 00 0c 	mcall	80008e7c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80008e50:	f0 1f 00 0c 	mcall	80008e80 <xQueueGenericSend+0xfc>
80008e54:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80008e56:	2f bd       	sub	sp,-20
80008e58:	d8 32       	popm	r0-r7,pc
80008e5a:	00 00       	add	r0,r0
80008e5c:	80 00       	ld.sh	r0,r0[0x0]
80008e5e:	87 c4       	st.w	r3[0x30],r4
80008e60:	80 00       	ld.sh	r0,r0[0x0]
80008e62:	8c bc       	ld.uh	r12,r6[0x6]
80008e64:	80 00       	ld.sh	r0,r0[0x0]
80008e66:	90 e8       	ld.uh	r8,r8[0xc]
80008e68:	80 00       	ld.sh	r0,r0[0x0]
80008e6a:	88 d0       	ld.uh	r0,r4[0xa]
80008e6c:	80 00       	ld.sh	r0,r0[0x0]
80008e6e:	8f dc       	st.w	r7[0x34],r12
80008e70:	80 00       	ld.sh	r0,r0[0x0]
80008e72:	8f 50       	st.w	r7[0x14],r0
80008e74:	80 00       	ld.sh	r0,r0[0x0]
80008e76:	92 78       	ld.sh	r8,r9[0xe]
80008e78:	80 00       	ld.sh	r0,r0[0x0]
80008e7a:	94 d0       	ld.uh	r0,r10[0xa]
80008e7c:	80 00       	ld.sh	r0,r0[0x0]
80008e7e:	8a d8       	ld.uh	r8,r5[0xa]
80008e80:	80 00       	ld.sh	r0,r0[0x0]
80008e82:	93 0c       	st.w	r9[0x0],r12

80008e84 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80008e84:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008e88:	34 cc       	mov	r12,76
80008e8a:	f0 1f 00 12 	mcall	80008ed0 <xQueueCreateMutex+0x4c>
80008e8e:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80008e90:	c1 d0       	breq	80008eca <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80008e92:	30 06       	mov	r6,0
80008e94:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80008e96:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80008e98:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80008e9a:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008e9c:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80008e9e:	30 18       	mov	r8,1
80008ea0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80008ea2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80008ea6:	3f f8       	mov	r8,-1
80008ea8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80008eac:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008eb0:	2f 0c       	sub	r12,-16
80008eb2:	f0 1f 00 09 	mcall	80008ed4 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008eb6:	ee cc ff dc 	sub	r12,r7,-36
80008eba:	f0 1f 00 07 	mcall	80008ed4 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80008ebe:	0c 99       	mov	r9,r6
80008ec0:	0c 9a       	mov	r10,r6
80008ec2:	0c 9b       	mov	r11,r6
80008ec4:	0e 9c       	mov	r12,r7
80008ec6:	f0 1f 00 05 	mcall	80008ed8 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80008eca:	0e 9c       	mov	r12,r7
80008ecc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008ed0:	80 00       	ld.sh	r0,r0[0x0]
80008ed2:	8a 30       	ld.sh	r0,r5[0x6]
80008ed4:	80 00       	ld.sh	r0,r0[0x0]
80008ed6:	86 a0       	ld.uh	r0,r3[0x4]
80008ed8:	80 00       	ld.sh	r0,r0[0x0]
80008eda:	8d 84       	st.w	r6[0x20],r4

80008edc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80008edc:	d4 21       	pushm	r4-r7,lr
80008ede:	18 97       	mov	r7,r12
80008ee0:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80008ee2:	58 0c       	cp.w	r12,0
80008ee4:	c2 f0       	breq	80008f42 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008ee6:	34 cc       	mov	r12,76
80008ee8:	f0 1f 00 17 	mcall	80008f44 <xQueueCreate+0x68>
80008eec:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80008eee:	c2 a0       	breq	80008f42 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80008ef0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80008ef4:	e8 cc ff ff 	sub	r12,r4,-1
80008ef8:	f0 1f 00 13 	mcall	80008f44 <xQueueCreate+0x68>
80008efc:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80008efe:	c1 e0       	breq	80008f3a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80008f00:	f8 04 00 04 	add	r4,r12,r4
80008f04:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008f06:	30 08       	mov	r8,0
80008f08:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80008f0a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80008f0c:	ee c8 00 01 	sub	r8,r7,1
80008f10:	ad 38       	mul	r8,r6
80008f12:	10 0c       	add	r12,r8
80008f14:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80008f16:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80008f18:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80008f1c:	3f f8       	mov	r8,-1
80008f1e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80008f22:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008f26:	ea cc ff f0 	sub	r12,r5,-16
80008f2a:	f0 1f 00 08 	mcall	80008f48 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008f2e:	ea cc ff dc 	sub	r12,r5,-36
80008f32:	f0 1f 00 06 	mcall	80008f48 <xQueueCreate+0x6c>
80008f36:	0a 9c       	mov	r12,r5
80008f38:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80008f3a:	0a 9c       	mov	r12,r5
80008f3c:	f0 1f 00 04 	mcall	80008f4c <xQueueCreate+0x70>
80008f40:	d8 2a       	popm	r4-r7,pc,r12=0
80008f42:	d8 2a       	popm	r4-r7,pc,r12=0
80008f44:	80 00       	ld.sh	r0,r0[0x0]
80008f46:	8a 30       	ld.sh	r0,r5[0x6]
80008f48:	80 00       	ld.sh	r0,r0[0x0]
80008f4a:	86 a0       	ld.uh	r0,r3[0x4]
80008f4c:	80 00       	ld.sh	r0,r0[0x0]
80008f4e:	8a 08       	ld.sh	r8,r5[0x0]

80008f50 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80008f50:	48 38       	lddpc	r8,80008f5c <vTaskSuspendAll+0xc>
80008f52:	70 09       	ld.w	r9,r8[0x0]
80008f54:	2f f9       	sub	r9,-1
80008f56:	91 09       	st.w	r8[0x0],r9
}
80008f58:	5e fc       	retal	r12
80008f5a:	00 00       	add	r0,r0
80008f5c:	00 00       	add	r0,r0
80008f5e:	12 4c       	or	r12,r9

80008f60 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80008f60:	49 a8       	lddpc	r8,80008fc8 <vTaskSwitchContext+0x68>
80008f62:	70 08       	ld.w	r8,r8[0x0]
80008f64:	58 08       	cp.w	r8,0
80008f66:	c0 b1       	brne	80008f7c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80008f68:	49 98       	lddpc	r8,80008fcc <vTaskSwitchContext+0x6c>
80008f6a:	70 08       	ld.w	r8,r8[0x0]
80008f6c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80008f70:	49 89       	lddpc	r9,80008fd0 <vTaskSwitchContext+0x70>
80008f72:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80008f76:	58 08       	cp.w	r8,0
80008f78:	c0 60       	breq	80008f84 <vTaskSwitchContext+0x24>
80008f7a:	c1 18       	rjmp	80008f9c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80008f7c:	30 19       	mov	r9,1
80008f7e:	49 68       	lddpc	r8,80008fd4 <vTaskSwitchContext+0x74>
80008f80:	91 09       	st.w	r8[0x0],r9
80008f82:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80008f84:	49 28       	lddpc	r8,80008fcc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80008f86:	49 3a       	lddpc	r10,80008fd0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80008f88:	70 09       	ld.w	r9,r8[0x0]
80008f8a:	20 19       	sub	r9,1
80008f8c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80008f8e:	70 09       	ld.w	r9,r8[0x0]
80008f90:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008f94:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80008f98:	58 09       	cp.w	r9,0
80008f9a:	cf 70       	breq	80008f88 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80008f9c:	48 c8       	lddpc	r8,80008fcc <vTaskSwitchContext+0x6c>
80008f9e:	70 08       	ld.w	r8,r8[0x0]
80008fa0:	f0 08 00 28 	add	r8,r8,r8<<0x2
80008fa4:	48 b9       	lddpc	r9,80008fd0 <vTaskSwitchContext+0x70>
80008fa6:	f2 08 00 28 	add	r8,r9,r8<<0x2
80008faa:	70 19       	ld.w	r9,r8[0x4]
80008fac:	72 19       	ld.w	r9,r9[0x4]
80008fae:	91 19       	st.w	r8[0x4],r9
80008fb0:	f0 ca ff f8 	sub	r10,r8,-8
80008fb4:	14 39       	cp.w	r9,r10
80008fb6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80008fba:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80008fbe:	70 18       	ld.w	r8,r8[0x4]
80008fc0:	70 39       	ld.w	r9,r8[0xc]
80008fc2:	48 68       	lddpc	r8,80008fd8 <vTaskSwitchContext+0x78>
80008fc4:	91 09       	st.w	r8[0x0],r9
80008fc6:	5e fc       	retal	r12
80008fc8:	00 00       	add	r0,r0
80008fca:	12 4c       	or	r12,r9
80008fcc:	00 00       	add	r0,r0
80008fce:	12 84       	andn	r4,r9
80008fd0:	00 00       	add	r0,r0
80008fd2:	11 68       	ld.uh	r8,--r8
80008fd4:	00 00       	add	r0,r0
80008fd6:	12 6c       	and	r12,r9
80008fd8:	00 00       	add	r0,r0
80008fda:	12 1c       	sub	r12,r9

80008fdc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80008fdc:	48 48       	lddpc	r8,80008fec <vTaskSetTimeOutState+0x10>
80008fde:	70 08       	ld.w	r8,r8[0x0]
80008fe0:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80008fe2:	48 48       	lddpc	r8,80008ff0 <vTaskSetTimeOutState+0x14>
80008fe4:	70 08       	ld.w	r8,r8[0x0]
80008fe6:	99 18       	st.w	r12[0x4],r8
}
80008fe8:	5e fc       	retal	r12
80008fea:	00 00       	add	r0,r0
80008fec:	00 00       	add	r0,r0
80008fee:	11 60       	ld.uh	r0,--r8
80008ff0:	00 00       	add	r0,r0
80008ff2:	12 48       	or	r8,r9

80008ff4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80008ff4:	30 19       	mov	r9,1
80008ff6:	48 28       	lddpc	r8,80008ffc <vTaskMissedYield+0x8>
80008ff8:	91 09       	st.w	r8[0x0],r9
}
80008ffa:	5e fc       	retal	r12
80008ffc:	00 00       	add	r0,r0
80008ffe:	12 6c       	and	r12,r9

80009000 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80009000:	48 28       	lddpc	r8,80009008 <xTaskGetCurrentTaskHandle+0x8>
80009002:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80009004:	5e fc       	retal	r12
80009006:	00 00       	add	r0,r0
80009008:	00 00       	add	r0,r0
8000900a:	12 1c       	sub	r12,r9

8000900c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000900c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80009010:	58 0c       	cp.w	r12,0
80009012:	c1 f0       	breq	80009050 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009014:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80009016:	78 b9       	ld.w	r9,r12[0x2c]
80009018:	79 18       	ld.w	r8,r12[0x44]
8000901a:	10 39       	cp.w	r9,r8
8000901c:	c1 a0       	breq	80009050 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000901e:	f8 c6 ff fc 	sub	r6,r12,-4
80009022:	0c 9c       	mov	r12,r6
80009024:	f0 1f 00 0c 	mcall	80009054 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009028:	6f 1c       	ld.w	r12,r7[0x44]
8000902a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000902c:	f8 08 11 08 	rsub	r8,r12,8
80009030:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80009032:	48 a8       	lddpc	r8,80009058 <vTaskPriorityDisinherit+0x4c>
80009034:	70 08       	ld.w	r8,r8[0x0]
80009036:	10 3c       	cp.w	r12,r8
80009038:	e0 88 00 04 	brls	80009040 <vTaskPriorityDisinherit+0x34>
8000903c:	48 78       	lddpc	r8,80009058 <vTaskPriorityDisinherit+0x4c>
8000903e:	91 0c       	st.w	r8[0x0],r12
80009040:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009044:	0c 9b       	mov	r11,r6
80009046:	48 68       	lddpc	r8,8000905c <vTaskPriorityDisinherit+0x50>
80009048:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000904c:	f0 1f 00 05 	mcall	80009060 <vTaskPriorityDisinherit+0x54>
80009050:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009054:	80 00       	ld.sh	r0,r0[0x0]
80009056:	87 0a       	st.w	r3[0x0],r10
80009058:	00 00       	add	r0,r0
8000905a:	12 84       	andn	r4,r9
8000905c:	00 00       	add	r0,r0
8000905e:	11 68       	ld.uh	r8,--r8
80009060:	80 00       	ld.sh	r0,r0[0x0]
80009062:	86 ba       	ld.uh	r10,r3[0x6]

80009064 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80009064:	eb cd 40 c0 	pushm	r6-r7,lr
80009068:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000906a:	49 b8       	lddpc	r8,800090d4 <vTaskPriorityInherit+0x70>
8000906c:	70 08       	ld.w	r8,r8[0x0]
8000906e:	78 b9       	ld.w	r9,r12[0x2c]
80009070:	70 b8       	ld.w	r8,r8[0x2c]
80009072:	10 39       	cp.w	r9,r8
80009074:	c2 d2       	brcc	800090ce <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80009076:	49 88       	lddpc	r8,800090d4 <vTaskPriorityInherit+0x70>
80009078:	70 08       	ld.w	r8,r8[0x0]
8000907a:	70 b8       	ld.w	r8,r8[0x2c]
8000907c:	f0 08 11 08 	rsub	r8,r8,8
80009080:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80009082:	f2 09 00 28 	add	r8,r9,r9<<0x2
80009086:	49 59       	lddpc	r9,800090d8 <vTaskPriorityInherit+0x74>
80009088:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000908c:	78 59       	ld.w	r9,r12[0x14]
8000908e:	10 39       	cp.w	r9,r8
80009090:	c1 b1       	brne	800090c6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80009092:	f8 c6 ff fc 	sub	r6,r12,-4
80009096:	0c 9c       	mov	r12,r6
80009098:	f0 1f 00 11 	mcall	800090dc <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000909c:	48 e8       	lddpc	r8,800090d4 <vTaskPriorityInherit+0x70>
8000909e:	70 08       	ld.w	r8,r8[0x0]
800090a0:	70 bc       	ld.w	r12,r8[0x2c]
800090a2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800090a4:	48 f8       	lddpc	r8,800090e0 <vTaskPriorityInherit+0x7c>
800090a6:	70 08       	ld.w	r8,r8[0x0]
800090a8:	10 3c       	cp.w	r12,r8
800090aa:	e0 88 00 04 	brls	800090b2 <vTaskPriorityInherit+0x4e>
800090ae:	48 d8       	lddpc	r8,800090e0 <vTaskPriorityInherit+0x7c>
800090b0:	91 0c       	st.w	r8[0x0],r12
800090b2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800090b6:	0c 9b       	mov	r11,r6
800090b8:	48 88       	lddpc	r8,800090d8 <vTaskPriorityInherit+0x74>
800090ba:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800090be:	f0 1f 00 0a 	mcall	800090e4 <vTaskPriorityInherit+0x80>
800090c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800090c6:	48 48       	lddpc	r8,800090d4 <vTaskPriorityInherit+0x70>
800090c8:	70 08       	ld.w	r8,r8[0x0]
800090ca:	70 b8       	ld.w	r8,r8[0x2c]
800090cc:	99 b8       	st.w	r12[0x2c],r8
800090ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800090d2:	00 00       	add	r0,r0
800090d4:	00 00       	add	r0,r0
800090d6:	12 1c       	sub	r12,r9
800090d8:	00 00       	add	r0,r0
800090da:	11 68       	ld.uh	r8,--r8
800090dc:	80 00       	ld.sh	r0,r0[0x0]
800090de:	87 0a       	st.w	r3[0x0],r10
800090e0:	00 00       	add	r0,r0
800090e2:	12 84       	andn	r4,r9
800090e4:	80 00       	ld.sh	r0,r0[0x0]
800090e6:	86 ba       	ld.uh	r10,r3[0x6]

800090e8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800090e8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800090ec:	78 38       	ld.w	r8,r12[0xc]
800090ee:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800090f0:	ee c6 ff e8 	sub	r6,r7,-24
800090f4:	0c 9c       	mov	r12,r6
800090f6:	f0 1f 00 15 	mcall	80009148 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800090fa:	49 58       	lddpc	r8,8000914c <xTaskRemoveFromEventList+0x64>
800090fc:	70 08       	ld.w	r8,r8[0x0]
800090fe:	58 08       	cp.w	r8,0
80009100:	c1 71       	brne	8000912e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80009102:	ee c6 ff fc 	sub	r6,r7,-4
80009106:	0c 9c       	mov	r12,r6
80009108:	f0 1f 00 10 	mcall	80009148 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000910c:	6e bc       	ld.w	r12,r7[0x2c]
8000910e:	49 18       	lddpc	r8,80009150 <xTaskRemoveFromEventList+0x68>
80009110:	70 08       	ld.w	r8,r8[0x0]
80009112:	10 3c       	cp.w	r12,r8
80009114:	e0 88 00 04 	brls	8000911c <xTaskRemoveFromEventList+0x34>
80009118:	48 e8       	lddpc	r8,80009150 <xTaskRemoveFromEventList+0x68>
8000911a:	91 0c       	st.w	r8[0x0],r12
8000911c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009120:	0c 9b       	mov	r11,r6
80009122:	48 d8       	lddpc	r8,80009154 <xTaskRemoveFromEventList+0x6c>
80009124:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009128:	f0 1f 00 0c 	mcall	80009158 <xTaskRemoveFromEventList+0x70>
8000912c:	c0 58       	rjmp	80009136 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000912e:	0c 9b       	mov	r11,r6
80009130:	48 bc       	lddpc	r12,8000915c <xTaskRemoveFromEventList+0x74>
80009132:	f0 1f 00 0a 	mcall	80009158 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009136:	48 b8       	lddpc	r8,80009160 <xTaskRemoveFromEventList+0x78>
80009138:	70 08       	ld.w	r8,r8[0x0]
8000913a:	6e b9       	ld.w	r9,r7[0x2c]
8000913c:	70 b8       	ld.w	r8,r8[0x2c]
8000913e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80009140:	5f 2c       	srhs	r12
80009142:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009146:	00 00       	add	r0,r0
80009148:	80 00       	ld.sh	r0,r0[0x0]
8000914a:	87 0a       	st.w	r3[0x0],r10
8000914c:	00 00       	add	r0,r0
8000914e:	12 4c       	or	r12,r9
80009150:	00 00       	add	r0,r0
80009152:	12 84       	andn	r4,r9
80009154:	00 00       	add	r0,r0
80009156:	11 68       	ld.uh	r8,--r8
80009158:	80 00       	ld.sh	r0,r0[0x0]
8000915a:	86 ba       	ld.uh	r10,r3[0x6]
8000915c:	00 00       	add	r0,r0
8000915e:	12 20       	rsub	r0,r9
80009160:	00 00       	add	r0,r0
80009162:	12 1c       	sub	r12,r9

80009164 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009164:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009168:	4b 98       	lddpc	r8,8000924c <vTaskIncrementTick+0xe8>
8000916a:	70 08       	ld.w	r8,r8[0x0]
8000916c:	58 08       	cp.w	r8,0
8000916e:	c6 91       	brne	80009240 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80009170:	4b 88       	lddpc	r8,80009250 <vTaskIncrementTick+0xec>
80009172:	70 09       	ld.w	r9,r8[0x0]
80009174:	2f f9       	sub	r9,-1
80009176:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80009178:	70 08       	ld.w	r8,r8[0x0]
8000917a:	58 08       	cp.w	r8,0
8000917c:	c1 a1       	brne	800091b0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000917e:	4b 68       	lddpc	r8,80009254 <vTaskIncrementTick+0xf0>
80009180:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80009182:	4b 69       	lddpc	r9,80009258 <vTaskIncrementTick+0xf4>
80009184:	72 0b       	ld.w	r11,r9[0x0]
80009186:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80009188:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000918a:	4b 59       	lddpc	r9,8000925c <vTaskIncrementTick+0xf8>
8000918c:	72 0a       	ld.w	r10,r9[0x0]
8000918e:	2f fa       	sub	r10,-1
80009190:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80009192:	70 08       	ld.w	r8,r8[0x0]
80009194:	70 08       	ld.w	r8,r8[0x0]
80009196:	58 08       	cp.w	r8,0
80009198:	c0 51       	brne	800091a2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000919a:	3f f9       	mov	r9,-1
8000919c:	4b 18       	lddpc	r8,80009260 <vTaskIncrementTick+0xfc>
8000919e:	91 09       	st.w	r8[0x0],r9
800091a0:	c0 88       	rjmp	800091b0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800091a2:	4a d8       	lddpc	r8,80009254 <vTaskIncrementTick+0xf0>
800091a4:	70 08       	ld.w	r8,r8[0x0]
800091a6:	70 38       	ld.w	r8,r8[0xc]
800091a8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800091aa:	70 19       	ld.w	r9,r8[0x4]
800091ac:	4a d8       	lddpc	r8,80009260 <vTaskIncrementTick+0xfc>
800091ae:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800091b0:	4a 88       	lddpc	r8,80009250 <vTaskIncrementTick+0xec>
800091b2:	70 09       	ld.w	r9,r8[0x0]
800091b4:	4a b8       	lddpc	r8,80009260 <vTaskIncrementTick+0xfc>
800091b6:	70 08       	ld.w	r8,r8[0x0]
800091b8:	10 39       	cp.w	r9,r8
800091ba:	c4 73       	brcs	80009248 <vTaskIncrementTick+0xe4>
800091bc:	4a 68       	lddpc	r8,80009254 <vTaskIncrementTick+0xf0>
800091be:	70 08       	ld.w	r8,r8[0x0]
800091c0:	70 08       	ld.w	r8,r8[0x0]
800091c2:	58 08       	cp.w	r8,0
800091c4:	c0 c0       	breq	800091dc <vTaskIncrementTick+0x78>
800091c6:	4a 48       	lddpc	r8,80009254 <vTaskIncrementTick+0xf0>
800091c8:	70 08       	ld.w	r8,r8[0x0]
800091ca:	70 38       	ld.w	r8,r8[0xc]
800091cc:	70 37       	ld.w	r7,r8[0xc]
800091ce:	6e 18       	ld.w	r8,r7[0x4]
800091d0:	4a 09       	lddpc	r9,80009250 <vTaskIncrementTick+0xec>
800091d2:	72 09       	ld.w	r9,r9[0x0]
800091d4:	12 38       	cp.w	r8,r9
800091d6:	e0 88 00 14 	brls	800091fe <vTaskIncrementTick+0x9a>
800091da:	c0 e8       	rjmp	800091f6 <vTaskIncrementTick+0x92>
800091dc:	3f f9       	mov	r9,-1
800091de:	4a 18       	lddpc	r8,80009260 <vTaskIncrementTick+0xfc>
800091e0:	91 09       	st.w	r8[0x0],r9
800091e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800091e6:	6a 08       	ld.w	r8,r5[0x0]
800091e8:	70 38       	ld.w	r8,r8[0xc]
800091ea:	70 37       	ld.w	r7,r8[0xc]
800091ec:	6e 18       	ld.w	r8,r7[0x4]
800091ee:	64 09       	ld.w	r9,r2[0x0]
800091f0:	12 38       	cp.w	r8,r9
800091f2:	e0 88 00 0a 	brls	80009206 <vTaskIncrementTick+0xa2>
800091f6:	49 b9       	lddpc	r9,80009260 <vTaskIncrementTick+0xfc>
800091f8:	93 08       	st.w	r9[0x0],r8
800091fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800091fe:	49 a4       	lddpc	r4,80009264 <vTaskIncrementTick+0x100>
80009200:	49 a3       	lddpc	r3,80009268 <vTaskIncrementTick+0x104>
80009202:	49 55       	lddpc	r5,80009254 <vTaskIncrementTick+0xf0>
80009204:	49 32       	lddpc	r2,80009250 <vTaskIncrementTick+0xec>
80009206:	ee c6 ff fc 	sub	r6,r7,-4
8000920a:	0c 9c       	mov	r12,r6
8000920c:	f0 1f 00 18 	mcall	8000926c <vTaskIncrementTick+0x108>
80009210:	6e a8       	ld.w	r8,r7[0x28]
80009212:	58 08       	cp.w	r8,0
80009214:	c0 50       	breq	8000921e <vTaskIncrementTick+0xba>
80009216:	ee cc ff e8 	sub	r12,r7,-24
8000921a:	f0 1f 00 15 	mcall	8000926c <vTaskIncrementTick+0x108>
8000921e:	6e bc       	ld.w	r12,r7[0x2c]
80009220:	68 08       	ld.w	r8,r4[0x0]
80009222:	10 3c       	cp.w	r12,r8
80009224:	e9 fc ba 00 	st.whi	r4[0x0],r12
80009228:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000922c:	0c 9b       	mov	r11,r6
8000922e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80009232:	f0 1f 00 10 	mcall	80009270 <vTaskIncrementTick+0x10c>
80009236:	6a 08       	ld.w	r8,r5[0x0]
80009238:	70 08       	ld.w	r8,r8[0x0]
8000923a:	58 08       	cp.w	r8,0
8000923c:	cd 51       	brne	800091e6 <vTaskIncrementTick+0x82>
8000923e:	cc fb       	rjmp	800091dc <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80009240:	48 d8       	lddpc	r8,80009274 <vTaskIncrementTick+0x110>
80009242:	70 09       	ld.w	r9,r8[0x0]
80009244:	2f f9       	sub	r9,-1
80009246:	91 09       	st.w	r8[0x0],r9
80009248:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000924c:	00 00       	add	r0,r0
8000924e:	12 4c       	or	r12,r9
80009250:	00 00       	add	r0,r0
80009252:	12 48       	or	r8,r9
80009254:	00 00       	add	r0,r0
80009256:	11 54       	ld.sh	r4,--r8
80009258:	00 00       	add	r0,r0
8000925a:	11 64       	ld.uh	r4,--r8
8000925c:	00 00       	add	r0,r0
8000925e:	11 60       	ld.uh	r0,--r8
80009260:	00 00       	add	r0,r0
80009262:	05 34       	ld.ub	r4,r2++
80009264:	00 00       	add	r0,r0
80009266:	12 84       	andn	r4,r9
80009268:	00 00       	add	r0,r0
8000926a:	11 68       	ld.uh	r8,--r8
8000926c:	80 00       	ld.sh	r0,r0[0x0]
8000926e:	87 0a       	st.w	r3[0x0],r10
80009270:	80 00       	ld.sh	r0,r0[0x0]
80009272:	86 ba       	ld.uh	r10,r3[0x6]
80009274:	00 00       	add	r0,r0
80009276:	11 4c       	ld.w	r12,--r8

80009278 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80009278:	eb cd 40 c0 	pushm	r6-r7,lr
8000927c:	18 97       	mov	r7,r12
8000927e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80009280:	f0 1f 00 15 	mcall	800092d4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80009284:	6c 08       	ld.w	r8,r6[0x0]
80009286:	5b f8       	cp.w	r8,-1
80009288:	c0 31       	brne	8000928e <xTaskCheckForTimeOut+0x16>
8000928a:	30 07       	mov	r7,0
8000928c:	c1 f8       	rjmp	800092ca <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000928e:	49 39       	lddpc	r9,800092d8 <xTaskCheckForTimeOut+0x60>
80009290:	72 09       	ld.w	r9,r9[0x0]
80009292:	6e 0a       	ld.w	r10,r7[0x0]
80009294:	12 3a       	cp.w	r10,r9
80009296:	c0 70       	breq	800092a4 <xTaskCheckForTimeOut+0x2c>
80009298:	49 19       	lddpc	r9,800092dc <xTaskCheckForTimeOut+0x64>
8000929a:	72 09       	ld.w	r9,r9[0x0]
8000929c:	6e 1a       	ld.w	r10,r7[0x4]
8000929e:	12 3a       	cp.w	r10,r9
800092a0:	e0 88 00 14 	brls	800092c8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800092a4:	48 e9       	lddpc	r9,800092dc <xTaskCheckForTimeOut+0x64>
800092a6:	72 0a       	ld.w	r10,r9[0x0]
800092a8:	6e 19       	ld.w	r9,r7[0x4]
800092aa:	12 1a       	sub	r10,r9
800092ac:	14 38       	cp.w	r8,r10
800092ae:	e0 88 00 0d 	brls	800092c8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800092b2:	48 ba       	lddpc	r10,800092dc <xTaskCheckForTimeOut+0x64>
800092b4:	74 0a       	ld.w	r10,r10[0x0]
800092b6:	14 19       	sub	r9,r10
800092b8:	f2 08 00 08 	add	r8,r9,r8
800092bc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800092be:	0e 9c       	mov	r12,r7
800092c0:	f0 1f 00 08 	mcall	800092e0 <xTaskCheckForTimeOut+0x68>
800092c4:	30 07       	mov	r7,0
800092c6:	c0 28       	rjmp	800092ca <xTaskCheckForTimeOut+0x52>
800092c8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800092ca:	f0 1f 00 07 	mcall	800092e4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800092ce:	0e 9c       	mov	r12,r7
800092d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800092d4:	80 00       	ld.sh	r0,r0[0x0]
800092d6:	87 c4       	st.w	r3[0x30],r4
800092d8:	00 00       	add	r0,r0
800092da:	11 60       	ld.uh	r0,--r8
800092dc:	00 00       	add	r0,r0
800092de:	12 48       	or	r8,r9
800092e0:	80 00       	ld.sh	r0,r0[0x0]
800092e2:	8f dc       	st.w	r7[0x34],r12
800092e4:	80 00       	ld.sh	r0,r0[0x0]
800092e6:	88 d0       	ld.uh	r0,r4[0xa]

800092e8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800092e8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800092ec:	f0 1f 00 05 	mcall	80009300 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800092f0:	48 58       	lddpc	r8,80009304 <xTaskGetTickCount+0x1c>
800092f2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800092f4:	f0 1f 00 05 	mcall	80009308 <xTaskGetTickCount+0x20>

	return xTicks;
}
800092f8:	0e 9c       	mov	r12,r7
800092fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800092fe:	00 00       	add	r0,r0
80009300:	80 00       	ld.sh	r0,r0[0x0]
80009302:	87 c4       	st.w	r3[0x30],r4
80009304:	00 00       	add	r0,r0
80009306:	12 48       	or	r8,r9
80009308:	80 00       	ld.sh	r0,r0[0x0]
8000930a:	88 d0       	ld.uh	r0,r4[0xa]

8000930c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000930c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80009310:	f0 1f 00 2c 	mcall	800093c0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80009314:	4a c8       	lddpc	r8,800093c4 <xTaskResumeAll+0xb8>
80009316:	70 09       	ld.w	r9,r8[0x0]
80009318:	20 19       	sub	r9,1
8000931a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000931c:	70 08       	ld.w	r8,r8[0x0]
8000931e:	58 08       	cp.w	r8,0
80009320:	c4 91       	brne	800093b2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80009322:	4a a8       	lddpc	r8,800093c8 <xTaskResumeAll+0xbc>
80009324:	70 08       	ld.w	r8,r8[0x0]
80009326:	58 08       	cp.w	r8,0
80009328:	c4 50       	breq	800093b2 <xTaskResumeAll+0xa6>
8000932a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000932c:	4a 85       	lddpc	r5,800093cc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000932e:	4a 93       	lddpc	r3,800093d0 <xTaskResumeAll+0xc4>
80009330:	4a 92       	lddpc	r2,800093d4 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009332:	4a a1       	lddpc	r1,800093d8 <xTaskResumeAll+0xcc>
80009334:	c1 e8       	rjmp	80009370 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80009336:	6a 38       	ld.w	r8,r5[0xc]
80009338:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000933a:	ee cc ff e8 	sub	r12,r7,-24
8000933e:	f0 1f 00 28 	mcall	800093dc <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80009342:	ee c6 ff fc 	sub	r6,r7,-4
80009346:	0c 9c       	mov	r12,r6
80009348:	f0 1f 00 25 	mcall	800093dc <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000934c:	6e bc       	ld.w	r12,r7[0x2c]
8000934e:	66 08       	ld.w	r8,r3[0x0]
80009350:	10 3c       	cp.w	r12,r8
80009352:	e7 fc ba 00 	st.whi	r3[0x0],r12
80009356:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000935a:	0c 9b       	mov	r11,r6
8000935c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80009360:	f0 1f 00 20 	mcall	800093e0 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009364:	62 08       	ld.w	r8,r1[0x0]
80009366:	6e b9       	ld.w	r9,r7[0x2c]
80009368:	70 b8       	ld.w	r8,r8[0x2c]
8000936a:	10 39       	cp.w	r9,r8
8000936c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009370:	6a 08       	ld.w	r8,r5[0x0]
80009372:	58 08       	cp.w	r8,0
80009374:	ce 11       	brne	80009336 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009376:	49 c8       	lddpc	r8,800093e4 <xTaskResumeAll+0xd8>
80009378:	70 08       	ld.w	r8,r8[0x0]
8000937a:	58 08       	cp.w	r8,0
8000937c:	c0 f0       	breq	8000939a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000937e:	49 a8       	lddpc	r8,800093e4 <xTaskResumeAll+0xd8>
80009380:	70 08       	ld.w	r8,r8[0x0]
80009382:	58 08       	cp.w	r8,0
80009384:	c1 10       	breq	800093a6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80009386:	49 87       	lddpc	r7,800093e4 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80009388:	f0 1f 00 18 	mcall	800093e8 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000938c:	6e 08       	ld.w	r8,r7[0x0]
8000938e:	20 18       	sub	r8,1
80009390:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009392:	6e 08       	ld.w	r8,r7[0x0]
80009394:	58 08       	cp.w	r8,0
80009396:	cf 91       	brne	80009388 <xTaskResumeAll+0x7c>
80009398:	c0 78       	rjmp	800093a6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000939a:	58 14       	cp.w	r4,1
8000939c:	c0 50       	breq	800093a6 <xTaskResumeAll+0x9a>
8000939e:	49 48       	lddpc	r8,800093ec <xTaskResumeAll+0xe0>
800093a0:	70 08       	ld.w	r8,r8[0x0]
800093a2:	58 18       	cp.w	r8,1
800093a4:	c0 71       	brne	800093b2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800093a6:	30 09       	mov	r9,0
800093a8:	49 18       	lddpc	r8,800093ec <xTaskResumeAll+0xe0>
800093aa:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800093ac:	d7 33       	scall
800093ae:	30 17       	mov	r7,1
800093b0:	c0 28       	rjmp	800093b4 <xTaskResumeAll+0xa8>
800093b2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800093b4:	f0 1f 00 0f 	mcall	800093f0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800093b8:	0e 9c       	mov	r12,r7
800093ba:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800093be:	00 00       	add	r0,r0
800093c0:	80 00       	ld.sh	r0,r0[0x0]
800093c2:	87 c4       	st.w	r3[0x30],r4
800093c4:	00 00       	add	r0,r0
800093c6:	12 4c       	or	r12,r9
800093c8:	00 00       	add	r0,r0
800093ca:	12 68       	and	r8,r9
800093cc:	00 00       	add	r0,r0
800093ce:	12 20       	rsub	r0,r9
800093d0:	00 00       	add	r0,r0
800093d2:	12 84       	andn	r4,r9
800093d4:	00 00       	add	r0,r0
800093d6:	11 68       	ld.uh	r8,--r8
800093d8:	00 00       	add	r0,r0
800093da:	12 1c       	sub	r12,r9
800093dc:	80 00       	ld.sh	r0,r0[0x0]
800093de:	87 0a       	st.w	r3[0x0],r10
800093e0:	80 00       	ld.sh	r0,r0[0x0]
800093e2:	86 ba       	ld.uh	r10,r3[0x6]
800093e4:	00 00       	add	r0,r0
800093e6:	11 4c       	ld.w	r12,--r8
800093e8:	80 00       	ld.sh	r0,r0[0x0]
800093ea:	91 64       	st.w	r8[0x18],r4
800093ec:	00 00       	add	r0,r0
800093ee:	12 6c       	and	r12,r9
800093f0:	80 00       	ld.sh	r0,r0[0x0]
800093f2:	88 d0       	ld.uh	r0,r4[0xa]

800093f4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800093f4:	eb cd 40 80 	pushm	r7,lr
800093f8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800093fa:	49 08       	lddpc	r8,80009438 <prvAddCurrentTaskToDelayedList+0x44>
800093fc:	70 08       	ld.w	r8,r8[0x0]
800093fe:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80009400:	48 f8       	lddpc	r8,8000943c <prvAddCurrentTaskToDelayedList+0x48>
80009402:	70 08       	ld.w	r8,r8[0x0]
80009404:	10 3c       	cp.w	r12,r8
80009406:	c0 a2       	brcc	8000941a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009408:	48 c8       	lddpc	r8,80009438 <prvAddCurrentTaskToDelayedList+0x44>
8000940a:	70 0b       	ld.w	r11,r8[0x0]
8000940c:	48 d8       	lddpc	r8,80009440 <prvAddCurrentTaskToDelayedList+0x4c>
8000940e:	70 0c       	ld.w	r12,r8[0x0]
80009410:	2f cb       	sub	r11,-4
80009412:	f0 1f 00 0d 	mcall	80009444 <prvAddCurrentTaskToDelayedList+0x50>
80009416:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000941a:	48 88       	lddpc	r8,80009438 <prvAddCurrentTaskToDelayedList+0x44>
8000941c:	70 0b       	ld.w	r11,r8[0x0]
8000941e:	48 b8       	lddpc	r8,80009448 <prvAddCurrentTaskToDelayedList+0x54>
80009420:	70 0c       	ld.w	r12,r8[0x0]
80009422:	2f cb       	sub	r11,-4
80009424:	f0 1f 00 08 	mcall	80009444 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009428:	48 98       	lddpc	r8,8000944c <prvAddCurrentTaskToDelayedList+0x58>
8000942a:	70 08       	ld.w	r8,r8[0x0]
8000942c:	10 37       	cp.w	r7,r8
8000942e:	c0 32       	brcc	80009434 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80009430:	48 78       	lddpc	r8,8000944c <prvAddCurrentTaskToDelayedList+0x58>
80009432:	91 07       	st.w	r8[0x0],r7
80009434:	e3 cd 80 80 	ldm	sp++,r7,pc
80009438:	00 00       	add	r0,r0
8000943a:	12 1c       	sub	r12,r9
8000943c:	00 00       	add	r0,r0
8000943e:	12 48       	or	r8,r9
80009440:	00 00       	add	r0,r0
80009442:	11 64       	ld.uh	r4,--r8
80009444:	80 00       	ld.sh	r0,r0[0x0]
80009446:	86 d6       	ld.uh	r6,r3[0xa]
80009448:	00 00       	add	r0,r0
8000944a:	11 54       	ld.sh	r4,--r8
8000944c:	00 00       	add	r0,r0
8000944e:	05 34       	ld.ub	r4,r2++

80009450 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009450:	eb cd 40 c0 	pushm	r6-r7,lr
80009454:	18 96       	mov	r6,r12
80009456:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80009458:	f0 1f 00 18 	mcall	800094b8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000945c:	6c 08       	ld.w	r8,r6[0x0]
8000945e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80009460:	49 79       	lddpc	r9,800094bc <vTaskDelayUntil+0x6c>
80009462:	72 09       	ld.w	r9,r9[0x0]
80009464:	12 38       	cp.w	r8,r9
80009466:	e0 88 00 0c 	brls	8000947e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000946a:	0e 38       	cp.w	r8,r7
8000946c:	e0 88 00 22 	brls	800094b0 <vTaskDelayUntil+0x60>
80009470:	49 38       	lddpc	r8,800094bc <vTaskDelayUntil+0x6c>
80009472:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009474:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80009476:	10 37       	cp.w	r7,r8
80009478:	e0 88 00 14 	brls	800094a0 <vTaskDelayUntil+0x50>
8000947c:	c0 a8       	rjmp	80009490 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000947e:	0e 38       	cp.w	r8,r7
80009480:	e0 8b 00 16 	brhi	800094ac <vTaskDelayUntil+0x5c>
80009484:	48 e8       	lddpc	r8,800094bc <vTaskDelayUntil+0x6c>
80009486:	70 08       	ld.w	r8,r8[0x0]
80009488:	10 37       	cp.w	r7,r8
8000948a:	e0 8b 00 11 	brhi	800094ac <vTaskDelayUntil+0x5c>
8000948e:	c1 18       	rjmp	800094b0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009490:	48 c8       	lddpc	r8,800094c0 <vTaskDelayUntil+0x70>
80009492:	70 0c       	ld.w	r12,r8[0x0]
80009494:	2f cc       	sub	r12,-4
80009496:	f0 1f 00 0c 	mcall	800094c4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000949a:	0e 9c       	mov	r12,r7
8000949c:	f0 1f 00 0b 	mcall	800094c8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800094a0:	f0 1f 00 0b 	mcall	800094cc <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800094a4:	c0 81       	brne	800094b4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800094a6:	d7 33       	scall
800094a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800094ac:	8d 07       	st.w	r6[0x0],r7
800094ae:	cf 1b       	rjmp	80009490 <vTaskDelayUntil+0x40>
800094b0:	8d 07       	st.w	r6[0x0],r7
800094b2:	cf 7b       	rjmp	800094a0 <vTaskDelayUntil+0x50>
800094b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800094b8:	80 00       	ld.sh	r0,r0[0x0]
800094ba:	8f 50       	st.w	r7[0x14],r0
800094bc:	00 00       	add	r0,r0
800094be:	12 48       	or	r8,r9
800094c0:	00 00       	add	r0,r0
800094c2:	12 1c       	sub	r12,r9
800094c4:	80 00       	ld.sh	r0,r0[0x0]
800094c6:	87 0a       	st.w	r3[0x0],r10
800094c8:	80 00       	ld.sh	r0,r0[0x0]
800094ca:	93 f4       	st.w	r9[0x3c],r4
800094cc:	80 00       	ld.sh	r0,r0[0x0]
800094ce:	93 0c       	st.w	r9[0x0],r12

800094d0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800094d0:	eb cd 40 c0 	pushm	r6-r7,lr
800094d4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800094d6:	48 e7       	lddpc	r7,8000950c <vTaskPlaceOnEventList+0x3c>
800094d8:	6e 0b       	ld.w	r11,r7[0x0]
800094da:	2e 8b       	sub	r11,-24
800094dc:	f0 1f 00 0d 	mcall	80009510 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800094e0:	6e 0c       	ld.w	r12,r7[0x0]
800094e2:	2f cc       	sub	r12,-4
800094e4:	f0 1f 00 0c 	mcall	80009514 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800094e8:	5b f6       	cp.w	r6,-1
800094ea:	c0 81       	brne	800094fa <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800094ec:	6e 0b       	ld.w	r11,r7[0x0]
800094ee:	2f cb       	sub	r11,-4
800094f0:	48 ac       	lddpc	r12,80009518 <vTaskPlaceOnEventList+0x48>
800094f2:	f0 1f 00 0b 	mcall	8000951c <vTaskPlaceOnEventList+0x4c>
800094f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800094fa:	48 a8       	lddpc	r8,80009520 <vTaskPlaceOnEventList+0x50>
800094fc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800094fe:	ec 0c 00 0c 	add	r12,r6,r12
80009502:	f0 1f 00 09 	mcall	80009524 <vTaskPlaceOnEventList+0x54>
80009506:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000950a:	00 00       	add	r0,r0
8000950c:	00 00       	add	r0,r0
8000950e:	12 1c       	sub	r12,r9
80009510:	80 00       	ld.sh	r0,r0[0x0]
80009512:	86 d6       	ld.uh	r6,r3[0xa]
80009514:	80 00       	ld.sh	r0,r0[0x0]
80009516:	87 0a       	st.w	r3[0x0],r10
80009518:	00 00       	add	r0,r0
8000951a:	12 70       	tst	r0,r9
8000951c:	80 00       	ld.sh	r0,r0[0x0]
8000951e:	86 ba       	ld.uh	r10,r3[0x6]
80009520:	00 00       	add	r0,r0
80009522:	12 48       	or	r8,r9
80009524:	80 00       	ld.sh	r0,r0[0x0]
80009526:	93 f4       	st.w	r9[0x3c],r4

80009528 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009528:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000952c:	49 67       	lddpc	r7,80009584 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000952e:	49 74       	lddpc	r4,80009588 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009530:	49 73       	lddpc	r3,8000958c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009532:	49 85       	lddpc	r5,80009590 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009534:	6e 08       	ld.w	r8,r7[0x0]
80009536:	58 08       	cp.w	r8,0
80009538:	c1 e0       	breq	80009574 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000953a:	f0 1f 00 17 	mcall	80009594 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000953e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009540:	f0 1f 00 16 	mcall	80009598 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009544:	58 06       	cp.w	r6,0
80009546:	c1 70       	breq	80009574 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009548:	f0 1f 00 15 	mcall	8000959c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000954c:	68 38       	ld.w	r8,r4[0xc]
8000954e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009550:	ec cc ff fc 	sub	r12,r6,-4
80009554:	f0 1f 00 13 	mcall	800095a0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009558:	66 08       	ld.w	r8,r3[0x0]
8000955a:	20 18       	sub	r8,1
8000955c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000955e:	6e 08       	ld.w	r8,r7[0x0]
80009560:	20 18       	sub	r8,1
80009562:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009564:	f0 1f 00 10 	mcall	800095a4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009568:	6c cc       	ld.w	r12,r6[0x30]
8000956a:	f0 1f 00 10 	mcall	800095a8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000956e:	0c 9c       	mov	r12,r6
80009570:	f0 1f 00 0e 	mcall	800095a8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009574:	6a 08       	ld.w	r8,r5[0x0]
80009576:	58 18       	cp.w	r8,1
80009578:	e0 88 00 03 	brls	8000957e <prvIdleTask+0x56>
			{
				taskYIELD();
8000957c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000957e:	f0 1f 00 0c 	mcall	800095ac <prvIdleTask+0x84>
		}
		#endif
	}
80009582:	cd 9b       	rjmp	80009534 <prvIdleTask+0xc>
80009584:	00 00       	add	r0,r0
80009586:	11 5c       	ld.sh	r12,--r8
80009588:	00 00       	add	r0,r0
8000958a:	12 08       	add	r8,r9
8000958c:	00 00       	add	r0,r0
8000958e:	12 68       	and	r8,r9
80009590:	00 00       	add	r0,r0
80009592:	11 68       	ld.uh	r8,--r8
80009594:	80 00       	ld.sh	r0,r0[0x0]
80009596:	8f 50       	st.w	r7[0x14],r0
80009598:	80 00       	ld.sh	r0,r0[0x0]
8000959a:	93 0c       	st.w	r9[0x0],r12
8000959c:	80 00       	ld.sh	r0,r0[0x0]
8000959e:	87 c4       	st.w	r3[0x30],r4
800095a0:	80 00       	ld.sh	r0,r0[0x0]
800095a2:	87 0a       	st.w	r3[0x0],r10
800095a4:	80 00       	ld.sh	r0,r0[0x0]
800095a6:	88 d0       	ld.uh	r0,r4[0xa]
800095a8:	80 00       	ld.sh	r0,r0[0x0]
800095aa:	8a 08       	ld.sh	r8,r5[0x0]
800095ac:	80 00       	ld.sh	r0,r0[0x0]
800095ae:	20 34       	sub	r4,3

800095b0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800095b0:	d4 31       	pushm	r0-r7,lr
800095b2:	20 1d       	sub	sp,4
800095b4:	fa c4 ff d8 	sub	r4,sp,-40
800095b8:	50 0c       	stdsp	sp[0x0],r12
800095ba:	16 91       	mov	r1,r11
800095bc:	14 97       	mov	r7,r10
800095be:	12 90       	mov	r0,r9
800095c0:	10 93       	mov	r3,r8
800095c2:	68 02       	ld.w	r2,r4[0x0]
800095c4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800095c6:	34 8c       	mov	r12,72
800095c8:	f0 1f 00 5c 	mcall	80009738 <xTaskGenericCreate+0x188>
800095cc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800095ce:	c0 31       	brne	800095d4 <xTaskGenericCreate+0x24>
800095d0:	3f fc       	mov	r12,-1
800095d2:	ca f8       	rjmp	80009730 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800095d4:	58 06       	cp.w	r6,0
800095d6:	e0 81 00 af 	brne	80009734 <xTaskGenericCreate+0x184>
800095da:	0e 9c       	mov	r12,r7
800095dc:	5c 7c       	castu.h	r12
800095de:	a3 6c       	lsl	r12,0x2
800095e0:	f0 1f 00 56 	mcall	80009738 <xTaskGenericCreate+0x188>
800095e4:	18 96       	mov	r6,r12
800095e6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800095e8:	c0 61       	brne	800095f4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800095ea:	0a 9c       	mov	r12,r5
800095ec:	f0 1f 00 54 	mcall	8000973c <xTaskGenericCreate+0x18c>
800095f0:	3f fc       	mov	r12,-1
800095f2:	c9 f8       	rjmp	80009730 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800095f4:	5c 77       	castu.h	r7
800095f6:	ee 0a 15 02 	lsl	r10,r7,0x2
800095fa:	e0 6b 00 a5 	mov	r11,165
800095fe:	0c 9c       	mov	r12,r6
80009600:	f0 1f 00 50 	mcall	80009740 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009604:	ee c6 00 01 	sub	r6,r7,1
80009608:	6a c8       	ld.w	r8,r5[0x30]
8000960a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000960e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009612:	31 0a       	mov	r10,16
80009614:	02 9b       	mov	r11,r1
80009616:	ea cc ff cc 	sub	r12,r5,-52
8000961a:	f0 1f 00 4b 	mcall	80009744 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000961e:	30 08       	mov	r8,0
80009620:	eb 68 00 43 	st.b	r5[67],r8
80009624:	58 73       	cp.w	r3,7
80009626:	e6 07 17 80 	movls	r7,r3
8000962a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000962e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009630:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009634:	ea c4 ff fc 	sub	r4,r5,-4
80009638:	08 9c       	mov	r12,r4
8000963a:	f0 1f 00 44 	mcall	80009748 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000963e:	ea cc ff e8 	sub	r12,r5,-24
80009642:	f0 1f 00 42 	mcall	80009748 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009646:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009648:	ee 07 11 08 	rsub	r7,r7,8
8000964c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000964e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009650:	00 9a       	mov	r10,r0
80009652:	40 0b       	lddsp	r11,sp[0x0]
80009654:	0c 9c       	mov	r12,r6
80009656:	f0 1f 00 3e 	mcall	8000974c <xTaskGenericCreate+0x19c>
8000965a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000965c:	58 02       	cp.w	r2,0
8000965e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80009662:	f0 1f 00 3c 	mcall	80009750 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80009666:	4b c8       	lddpc	r8,80009754 <xTaskGenericCreate+0x1a4>
80009668:	70 09       	ld.w	r9,r8[0x0]
8000966a:	2f f9       	sub	r9,-1
8000966c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000966e:	4b b8       	lddpc	r8,80009758 <xTaskGenericCreate+0x1a8>
80009670:	70 08       	ld.w	r8,r8[0x0]
80009672:	58 08       	cp.w	r8,0
80009674:	c2 61       	brne	800096c0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009676:	4b 98       	lddpc	r8,80009758 <xTaskGenericCreate+0x1a8>
80009678:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000967a:	4b 78       	lddpc	r8,80009754 <xTaskGenericCreate+0x1a4>
8000967c:	70 08       	ld.w	r8,r8[0x0]
8000967e:	58 18       	cp.w	r8,1
80009680:	c2 b1       	brne	800096d6 <xTaskGenericCreate+0x126>
80009682:	4b 77       	lddpc	r7,8000975c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80009684:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009688:	0e 9c       	mov	r12,r7
8000968a:	f0 1f 00 36 	mcall	80009760 <xTaskGenericCreate+0x1b0>
8000968e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009690:	0c 37       	cp.w	r7,r6
80009692:	cf b1       	brne	80009688 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80009694:	4b 47       	lddpc	r7,80009764 <xTaskGenericCreate+0x1b4>
80009696:	0e 9c       	mov	r12,r7
80009698:	f0 1f 00 32 	mcall	80009760 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000969c:	4b 36       	lddpc	r6,80009768 <xTaskGenericCreate+0x1b8>
8000969e:	0c 9c       	mov	r12,r6
800096a0:	f0 1f 00 30 	mcall	80009760 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800096a4:	4b 2c       	lddpc	r12,8000976c <xTaskGenericCreate+0x1bc>
800096a6:	f0 1f 00 2f 	mcall	80009760 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800096aa:	4b 2c       	lddpc	r12,80009770 <xTaskGenericCreate+0x1c0>
800096ac:	f0 1f 00 2d 	mcall	80009760 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800096b0:	4b 1c       	lddpc	r12,80009774 <xTaskGenericCreate+0x1c4>
800096b2:	f0 1f 00 2c 	mcall	80009760 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800096b6:	4b 18       	lddpc	r8,80009778 <xTaskGenericCreate+0x1c8>
800096b8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800096ba:	4b 18       	lddpc	r8,8000977c <xTaskGenericCreate+0x1cc>
800096bc:	91 06       	st.w	r8[0x0],r6
800096be:	c0 c8       	rjmp	800096d6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800096c0:	4b 08       	lddpc	r8,80009780 <xTaskGenericCreate+0x1d0>
800096c2:	70 08       	ld.w	r8,r8[0x0]
800096c4:	58 08       	cp.w	r8,0
800096c6:	c0 81       	brne	800096d6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800096c8:	4a 48       	lddpc	r8,80009758 <xTaskGenericCreate+0x1a8>
800096ca:	70 08       	ld.w	r8,r8[0x0]
800096cc:	70 b8       	ld.w	r8,r8[0x2c]
800096ce:	10 33       	cp.w	r3,r8
800096d0:	c0 33       	brcs	800096d6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800096d2:	4a 28       	lddpc	r8,80009758 <xTaskGenericCreate+0x1a8>
800096d4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800096d6:	6a b8       	ld.w	r8,r5[0x2c]
800096d8:	4a b9       	lddpc	r9,80009784 <xTaskGenericCreate+0x1d4>
800096da:	72 09       	ld.w	r9,r9[0x0]
800096dc:	12 38       	cp.w	r8,r9
800096de:	e0 88 00 04 	brls	800096e6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800096e2:	4a 99       	lddpc	r9,80009784 <xTaskGenericCreate+0x1d4>
800096e4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800096e6:	4a 98       	lddpc	r8,80009788 <xTaskGenericCreate+0x1d8>
800096e8:	70 09       	ld.w	r9,r8[0x0]
800096ea:	2f f9       	sub	r9,-1
800096ec:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800096ee:	6a b8       	ld.w	r8,r5[0x2c]
800096f0:	4a 79       	lddpc	r9,8000978c <xTaskGenericCreate+0x1dc>
800096f2:	72 09       	ld.w	r9,r9[0x0]
800096f4:	12 38       	cp.w	r8,r9
800096f6:	e0 88 00 04 	brls	800096fe <xTaskGenericCreate+0x14e>
800096fa:	4a 59       	lddpc	r9,8000978c <xTaskGenericCreate+0x1dc>
800096fc:	93 08       	st.w	r9[0x0],r8
800096fe:	6a bc       	ld.w	r12,r5[0x2c]
80009700:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009704:	08 9b       	mov	r11,r4
80009706:	49 68       	lddpc	r8,8000975c <xTaskGenericCreate+0x1ac>
80009708:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000970c:	f0 1f 00 21 	mcall	80009790 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80009710:	f0 1f 00 21 	mcall	80009794 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80009714:	49 b8       	lddpc	r8,80009780 <xTaskGenericCreate+0x1d0>
80009716:	70 08       	ld.w	r8,r8[0x0]
80009718:	58 08       	cp.w	r8,0
8000971a:	c0 a0       	breq	8000972e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000971c:	48 f8       	lddpc	r8,80009758 <xTaskGenericCreate+0x1a8>
8000971e:	70 08       	ld.w	r8,r8[0x0]
80009720:	70 b8       	ld.w	r8,r8[0x2c]
80009722:	10 33       	cp.w	r3,r8
80009724:	e0 88 00 05 	brls	8000972e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009728:	d7 33       	scall
8000972a:	30 1c       	mov	r12,1
8000972c:	c0 28       	rjmp	80009730 <xTaskGenericCreate+0x180>
8000972e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80009730:	2f fd       	sub	sp,-4
80009732:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009734:	99 c6       	st.w	r12[0x30],r6
80009736:	c5 fb       	rjmp	800095f4 <xTaskGenericCreate+0x44>
80009738:	80 00       	ld.sh	r0,r0[0x0]
8000973a:	8a 30       	ld.sh	r0,r5[0x6]
8000973c:	80 00       	ld.sh	r0,r0[0x0]
8000973e:	8a 08       	ld.sh	r8,r5[0x0]
80009740:	80 00       	ld.sh	r0,r0[0x0]
80009742:	a4 82       	st.b	r2[0x0],r2
80009744:	80 00       	ld.sh	r0,r0[0x0]
80009746:	a7 d4       	cbr	r4,0x7
80009748:	80 00       	ld.sh	r0,r0[0x0]
8000974a:	86 b4       	ld.uh	r4,r3[0x6]
8000974c:	80 00       	ld.sh	r0,r0[0x0]
8000974e:	87 30       	st.w	r3[0xc],r0
80009750:	80 00       	ld.sh	r0,r0[0x0]
80009752:	87 c4       	st.w	r3[0x30],r4
80009754:	00 00       	add	r0,r0
80009756:	12 68       	and	r8,r9
80009758:	00 00       	add	r0,r0
8000975a:	12 1c       	sub	r12,r9
8000975c:	00 00       	add	r0,r0
8000975e:	11 68       	ld.uh	r8,--r8
80009760:	80 00       	ld.sh	r0,r0[0x0]
80009762:	86 a0       	ld.uh	r0,r3[0x4]
80009764:	00 00       	add	r0,r0
80009766:	12 34       	cp.w	r4,r9
80009768:	00 00       	add	r0,r0
8000976a:	12 50       	eor	r0,r9
8000976c:	00 00       	add	r0,r0
8000976e:	12 20       	rsub	r0,r9
80009770:	00 00       	add	r0,r0
80009772:	12 08       	add	r8,r9
80009774:	00 00       	add	r0,r0
80009776:	12 70       	tst	r0,r9
80009778:	00 00       	add	r0,r0
8000977a:	11 54       	ld.sh	r4,--r8
8000977c:	00 00       	add	r0,r0
8000977e:	11 64       	ld.uh	r4,--r8
80009780:	00 00       	add	r0,r0
80009782:	11 58       	ld.sh	r8,--r8
80009784:	00 00       	add	r0,r0
80009786:	11 50       	ld.sh	r0,--r8
80009788:	00 00       	add	r0,r0
8000978a:	12 64       	and	r4,r9
8000978c:	00 00       	add	r0,r0
8000978e:	12 84       	andn	r4,r9
80009790:	80 00       	ld.sh	r0,r0[0x0]
80009792:	86 ba       	ld.uh	r10,r3[0x6]
80009794:	80 00       	ld.sh	r0,r0[0x0]
80009796:	88 d0       	ld.uh	r0,r4[0xa]

80009798 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009798:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000979a:	30 09       	mov	r9,0
8000979c:	1a d9       	st.w	--sp,r9
8000979e:	1a d9       	st.w	--sp,r9
800097a0:	1a d9       	st.w	--sp,r9
800097a2:	12 98       	mov	r8,r9
800097a4:	e0 6a 01 00 	mov	r10,256
800097a8:	48 9b       	lddpc	r11,800097cc <vTaskStartScheduler+0x34>
800097aa:	48 ac       	lddpc	r12,800097d0 <vTaskStartScheduler+0x38>
800097ac:	f0 1f 00 0a 	mcall	800097d4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800097b0:	2f dd       	sub	sp,-12
800097b2:	58 1c       	cp.w	r12,1
800097b4:	c0 a1       	brne	800097c8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800097b6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800097b8:	30 19       	mov	r9,1
800097ba:	48 88       	lddpc	r8,800097d8 <vTaskStartScheduler+0x40>
800097bc:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800097be:	30 09       	mov	r9,0
800097c0:	48 78       	lddpc	r8,800097dc <vTaskStartScheduler+0x44>
800097c2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800097c4:	f0 1f 00 07 	mcall	800097e0 <vTaskStartScheduler+0x48>
800097c8:	d8 02       	popm	pc
800097ca:	00 00       	add	r0,r0
800097cc:	80 01       	ld.sh	r1,r0[0x0]
800097ce:	89 b8       	st.w	r4[0x2c],r8
800097d0:	80 00       	ld.sh	r0,r0[0x0]
800097d2:	95 28       	st.w	r10[0x8],r8
800097d4:	80 00       	ld.sh	r0,r0[0x0]
800097d6:	95 b0       	st.w	r10[0x2c],r0
800097d8:	00 00       	add	r0,r0
800097da:	11 58       	ld.sh	r8,--r8
800097dc:	00 00       	add	r0,r0
800097de:	12 48       	or	r8,r9
800097e0:	80 00       	ld.sh	r0,r0[0x0]
800097e2:	87 d4       	st.w	r3[0x34],r4

800097e4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800097e4:	16 cc       	st.b	r11++,r12
	return str;
}
800097e6:	5e fb       	retal	r11

800097e8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800097e8:	eb cd 40 c0 	pushm	r6-r7,lr
800097ec:	20 3d       	sub	sp,12
800097ee:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800097f0:	30 06       	mov	r6,0
800097f2:	30 07       	mov	r7,0
800097f4:	fa e7 00 00 	st.d	sp[0],r6
800097f8:	30 0c       	mov	r12,0
800097fa:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800097fc:	58 08       	cp.w	r8,0
800097fe:	c1 30       	breq	80009824 <PrintHex+0x3c>
80009800:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80009802:	1a 9c       	mov	r12,sp
80009804:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009808:	58 9e       	cp.w	lr,9
8000980a:	e0 8a 00 04 	brle	80009812 <PrintHex+0x2a>
8000980e:	2c 9e       	sub	lr,-55
80009810:	c0 48       	rjmp	80009818 <PrintHex+0x30>
80009812:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009816:	2d 0e       	sub	lr,-48
80009818:	f8 09 0b 0e 	st.b	r12[r9],lr
8000981c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000981e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009820:	cf 21       	brne	80009804 <PrintHex+0x1c>
80009822:	c0 48       	rjmp	8000982a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009824:	33 08       	mov	r8,48
80009826:	ba 88       	st.b	sp[0x0],r8
80009828:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000982a:	f6 09 01 08 	sub	r8,r11,r9
8000982e:	58 08       	cp.w	r8,0
80009830:	e0 8a 00 13 	brle	80009856 <PrintHex+0x6e>
	{
		char num = len - cnt;
80009834:	12 1b       	sub	r11,r9
80009836:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000983a:	18 9e       	mov	lr,r12
8000983c:	58 0c       	cp.w	r12,0
8000983e:	e0 8a 00 0c 	brle	80009856 <PrintHex+0x6e>
80009842:	1a 9b       	mov	r11,sp
80009844:	12 0b       	add	r11,r9
80009846:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009848:	33 07       	mov	r7,48
8000984a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000984c:	2f f8       	sub	r8,-1
8000984e:	1c 38       	cp.w	r8,lr
80009850:	cf d5       	brlt	8000984a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009852:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009856:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000985a:	f0 cb ff ff 	sub	r11,r8,-1
8000985e:	58 0b       	cp.w	r11,0
80009860:	e0 8a 00 19 	brle	80009892 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009864:	fa cb ff f4 	sub	r11,sp,-12
80009868:	f6 09 00 09 	add	r9,r11,r9
8000986c:	37 8b       	mov	r11,120
8000986e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80009872:	fa c9 ff f4 	sub	r9,sp,-12
80009876:	10 09       	add	r9,r8
80009878:	33 0b       	mov	r11,48
8000987a:	f3 6b ff f4 	st.b	r9[-12],r11
8000987e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009882:	fa ce 00 01 	sub	lr,sp,1
80009886:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80009888:	11 8b       	ld.ub	r11,r8[0x0]
8000988a:	12 cb       	st.b	r9++,r11
8000988c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000988e:	1c 38       	cp.w	r8,lr
80009890:	cf c1       	brne	80009888 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80009892:	14 9c       	mov	r12,r10
80009894:	2f dd       	sub	sp,-12
80009896:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000989a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000989a:	d4 21       	pushm	r4-r7,lr
8000989c:	20 3d       	sub	sp,12
8000989e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800098a0:	30 06       	mov	r6,0
800098a2:	30 07       	mov	r7,0
800098a4:	fa e7 00 00 	st.d	sp[0],r6
800098a8:	30 0c       	mov	r12,0
800098aa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800098ac:	58 08       	cp.w	r8,0
800098ae:	c0 35       	brlt	800098b4 <PrintDec+0x1a>
800098b0:	14 97       	mov	r7,r10
800098b2:	c0 58       	rjmp	800098bc <PrintDec+0x22>
	{
		*p++ = '-';
800098b4:	14 97       	mov	r7,r10
800098b6:	32 d9       	mov	r9,45
800098b8:	0e c9       	st.b	r7++,r9
		i = -i;
800098ba:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800098bc:	58 08       	cp.w	r8,0
800098be:	c0 51       	brne	800098c8 <PrintDec+0x2e>
800098c0:	33 08       	mov	r8,48
800098c2:	ba 88       	st.b	sp[0x0],r8
800098c4:	30 1e       	mov	lr,1
800098c6:	c2 f8       	rjmp	80009924 <PrintDec+0x8a>
	
	int ten = i%10;
800098c8:	e0 65 66 67 	mov	r5,26215
800098cc:	ea 15 66 66 	orh	r5,0x6666
800098d0:	f0 05 04 44 	muls.d	r4,r8,r5
800098d4:	ea 0c 14 02 	asr	r12,r5,0x2
800098d8:	f0 09 14 1f 	asr	r9,r8,0x1f
800098dc:	f8 09 01 09 	sub	r9,r12,r9
800098e0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800098e4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800098e8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800098ea:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800098ec:	e0 66 66 67 	mov	r6,26215
800098f0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800098f4:	2d 09       	sub	r9,-48
800098f6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800098fa:	2f fe       	sub	lr,-1
		i /= 10;
800098fc:	f0 06 04 44 	muls.d	r4,r8,r6
80009900:	ea 09 14 02 	asr	r9,r5,0x2
80009904:	bf 58       	asr	r8,0x1f
80009906:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000990a:	f0 06 04 44 	muls.d	r4,r8,r6
8000990e:	ea 09 14 02 	asr	r9,r5,0x2
80009912:	f0 05 14 1f 	asr	r5,r8,0x1f
80009916:	0a 19       	sub	r9,r5
80009918:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000991c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009920:	58 08       	cp.w	r8,0
80009922:	ce 91       	brne	800098f4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009924:	f6 0e 01 08 	sub	r8,r11,lr
80009928:	58 08       	cp.w	r8,0
8000992a:	e0 89 00 06 	brgt	80009936 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000992e:	58 0e       	cp.w	lr,0
80009930:	e0 89 00 14 	brgt	80009958 <PrintDec+0xbe>
80009934:	c1 d8       	rjmp	8000996e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009936:	1c 1b       	sub	r11,lr
80009938:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000993a:	16 9c       	mov	r12,r11
8000993c:	58 0b       	cp.w	r11,0
8000993e:	fe 9a ff f8 	brle	8000992e <PrintDec+0x94>
80009942:	1a 99       	mov	r9,sp
80009944:	1c 09       	add	r9,lr
80009946:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009948:	33 06       	mov	r6,48
8000994a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000994c:	2f f8       	sub	r8,-1
8000994e:	18 38       	cp.w	r8,r12
80009950:	cf d5       	brlt	8000994a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009952:	f6 0e 00 0e 	add	lr,r11,lr
80009956:	ce cb       	rjmp	8000992e <PrintDec+0x94>
80009958:	fa c8 ff f4 	sub	r8,sp,-12
8000995c:	1c 08       	add	r8,lr
8000995e:	20 d8       	sub	r8,13
80009960:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009964:	11 89       	ld.ub	r9,r8[0x0]
80009966:	0e c9       	st.b	r7++,r9
80009968:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000996a:	16 38       	cp.w	r8,r11
8000996c:	cf c1       	brne	80009964 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000996e:	14 9c       	mov	r12,r10
80009970:	2f dd       	sub	sp,-12
80009972:	d8 22       	popm	r4-r7,pc

80009974 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009974:	d4 31       	pushm	r0-r7,lr
80009976:	fa cd 02 08 	sub	sp,sp,520
8000997a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000997c:	e0 6a 01 00 	mov	r10,256
80009980:	30 0b       	mov	r11,0
80009982:	fa cc fe f8 	sub	r12,sp,-264
80009986:	f0 1f 00 4e 	mcall	80009abc <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000998a:	fa c4 fd d4 	sub	r4,sp,-556
8000998e:	30 0a       	mov	r10,0
80009990:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009992:	fa c3 ff fc 	sub	r3,sp,-4
80009996:	e0 61 01 00 	mov	r1,256
8000999a:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000999c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000999e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800099a2:	02 9a       	mov	r10,r1
800099a4:	00 9b       	mov	r11,r0
800099a6:	06 9c       	mov	r12,r3
800099a8:	f0 1f 00 45 	mcall	80009abc <log+0x148>
			
					if(*str == '%')
800099ac:	0f 88       	ld.ub	r8,r7[0x0]
800099ae:	e4 08 18 00 	cp.b	r8,r2
800099b2:	c5 71       	brne	80009a60 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800099b4:	ee c8 ff ff 	sub	r8,r7,-1
800099b8:	11 89       	ld.ub	r9,r8[0x0]
800099ba:	4c 2a       	lddpc	r10,80009ac0 <log+0x14c>
800099bc:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800099be:	23 09       	sub	r9,48
800099c0:	30 9a       	mov	r10,9
800099c2:	f4 09 18 00 	cp.b	r9,r10
800099c6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800099ca:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800099ce:	f7 b9 08 30 	subls	r9,48
800099d2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800099d6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800099da:	0f 88       	ld.ub	r8,r7[0x0]
800099dc:	22 58       	sub	r8,37
800099de:	e0 48 00 53 	cp.w	r8,83
800099e2:	e0 8b 00 31 	brhi	80009a44 <log+0xd0>
800099e6:	4b 89       	lddpc	r9,80009ac4 <log+0x150>
800099e8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800099ec:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800099f0:	06 9a       	mov	r10,r3
800099f2:	40 0b       	lddsp	r11,sp[0x0]
800099f4:	5c 5b       	castu.b	r11
800099f6:	68 0c       	ld.w	r12,r4[0x0]
800099f8:	f0 1f 00 34 	mcall	80009ac8 <log+0x154>
							break;
800099fc:	c2 98       	rjmp	80009a4e <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800099fe:	4b 4c       	lddpc	r12,80009acc <log+0x158>
80009a00:	f0 1f 00 34 	mcall	80009ad0 <log+0x15c>
80009a04:	08 95       	mov	r5,r4
80009a06:	06 9c       	mov	r12,r3
							break;
80009a08:	c2 38       	rjmp	80009a4e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80009a0a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80009a0e:	06 9a       	mov	r10,r3
80009a10:	40 0b       	lddsp	r11,sp[0x0]
80009a12:	5c 5b       	castu.b	r11
80009a14:	68 0c       	ld.w	r12,r4[0x0]
80009a16:	f0 1f 00 30 	mcall	80009ad4 <log+0x160>
80009a1a:	06 9c       	mov	r12,r3
							break;
80009a1c:	c1 98       	rjmp	80009a4e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80009a1e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80009a22:	06 9b       	mov	r11,r3
80009a24:	09 bc       	ld.ub	r12,r4[0x3]
80009a26:	f0 1f 00 2d 	mcall	80009ad8 <log+0x164>
80009a2a:	06 9c       	mov	r12,r3
							break;
80009a2c:	c1 18       	rjmp	80009a4e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80009a2e:	e8 c5 ff fc 	sub	r5,r4,-4
80009a32:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80009a34:	c0 d8       	rjmp	80009a4e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80009a36:	06 9b       	mov	r11,r3
80009a38:	32 5c       	mov	r12,37
80009a3a:	f0 1f 00 28 	mcall	80009ad8 <log+0x164>
80009a3e:	08 95       	mov	r5,r4
80009a40:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80009a42:	c0 68       	rjmp	80009a4e <log+0xda>
							
							default:
							log("I need relax.");
80009a44:	4a 6c       	lddpc	r12,80009adc <log+0x168>
80009a46:	f0 1f 00 23 	mcall	80009ad0 <log+0x15c>
80009a4a:	08 95       	mov	r5,r4
80009a4c:	06 9c       	mov	r12,r3
						}
						str++;
80009a4e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009a50:	1a dc       	st.w	--sp,r12
80009a52:	1a d6       	st.w	--sp,r6
80009a54:	4a 3b       	lddpc	r11,80009ae0 <log+0x16c>
80009a56:	0c 9c       	mov	r12,r6
80009a58:	f0 1f 00 23 	mcall	80009ae4 <log+0x170>
80009a5c:	2f ed       	sub	sp,-8
80009a5e:	c0 a8       	rjmp	80009a72 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009a60:	2f f7       	sub	r7,-1
80009a62:	1a d8       	st.w	--sp,r8
80009a64:	1a d6       	st.w	--sp,r6
80009a66:	4a 1b       	lddpc	r11,80009ae8 <log+0x174>
80009a68:	0c 9c       	mov	r12,r6
80009a6a:	f0 1f 00 1f 	mcall	80009ae4 <log+0x170>
80009a6e:	08 95       	mov	r5,r4
80009a70:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80009a72:	0f 89       	ld.ub	r9,r7[0x0]
80009a74:	30 08       	mov	r8,0
80009a76:	f0 09 18 00 	cp.b	r9,r8
80009a7a:	c0 30       	breq	80009a80 <log+0x10c>
80009a7c:	0a 94       	mov	r4,r5
80009a7e:	c9 2b       	rjmp	800099a2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80009a80:	fa c7 fe f8 	sub	r7,sp,-264
80009a84:	1a d7       	st.w	--sp,r7
80009a86:	49 ab       	lddpc	r11,80009aec <log+0x178>
80009a88:	0e 9c       	mov	r12,r7
80009a8a:	f0 1f 00 17 	mcall	80009ae4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80009a8e:	5c 5c       	castu.b	r12
80009a90:	f8 c6 ff ff 	sub	r6,r12,-1
80009a94:	0c 9c       	mov	r12,r6
80009a96:	f0 1f 00 17 	mcall	80009af0 <log+0x17c>
80009a9a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80009a9c:	0c 9a       	mov	r10,r6
80009a9e:	0e 9b       	mov	r11,r7
80009aa0:	f0 1f 00 15 	mcall	80009af4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80009aa4:	30 09       	mov	r9,0
80009aa6:	30 5a       	mov	r10,5
80009aa8:	fa cb fe f8 	sub	r11,sp,-264
80009aac:	49 38       	lddpc	r8,80009af8 <log+0x184>
80009aae:	70 0c       	ld.w	r12,r8[0x0]
80009ab0:	f0 1f 00 13 	mcall	80009afc <log+0x188>
80009ab4:	2f fd       	sub	sp,-4
}
80009ab6:	fe 3d fd f8 	sub	sp,-520
80009aba:	d8 32       	popm	r0-r7,pc
80009abc:	80 00       	ld.sh	r0,r0[0x0]
80009abe:	a4 82       	st.b	r2[0x0],r2
80009ac0:	00 00       	add	r0,r0
80009ac2:	12 88       	andn	r8,r9
80009ac4:	80 01       	ld.sh	r1,r0[0x0]
80009ac6:	89 c0       	st.w	r4[0x30],r0
80009ac8:	80 00       	ld.sh	r0,r0[0x0]
80009aca:	98 9a       	ld.uh	r10,r12[0x2]
80009acc:	80 01       	ld.sh	r1,r0[0x0]
80009ace:	8c 6c       	ld.sh	r12,r6[0xc]
80009ad0:	80 00       	ld.sh	r0,r0[0x0]
80009ad2:	99 74       	st.w	r12[0x1c],r4
80009ad4:	80 00       	ld.sh	r0,r0[0x0]
80009ad6:	97 e8       	st.w	r11[0x38],r8
80009ad8:	80 00       	ld.sh	r0,r0[0x0]
80009ada:	97 e4       	st.w	r11[0x38],r4
80009adc:	80 01       	ld.sh	r1,r0[0x0]
80009ade:	8c 7c       	ld.sh	r12,r6[0xe]
80009ae0:	80 01       	ld.sh	r1,r0[0x0]
80009ae2:	8c 8c       	ld.uh	r12,r6[0x0]
80009ae4:	80 00       	ld.sh	r0,r0[0x0]
80009ae6:	a7 70       	lsl	r0,0x7
80009ae8:	80 01       	ld.sh	r1,r0[0x0]
80009aea:	8c 94       	ld.uh	r4,r6[0x2]
80009aec:	80 01       	ld.sh	r1,r0[0x0]
80009aee:	8c 9c       	ld.uh	r12,r6[0x2]
80009af0:	80 00       	ld.sh	r0,r0[0x0]
80009af2:	8a 30       	ld.sh	r0,r5[0x6]
80009af4:	80 00       	ld.sh	r0,r0[0x0]
80009af6:	a3 3a       	mul	r10,r1
80009af8:	00 00       	add	r0,r0
80009afa:	46 1c       	lddsp	r12,sp[0x184]
80009afc:	80 00       	ld.sh	r0,r0[0x0]
80009afe:	8d 84       	st.w	r6[0x20],r4

80009b00 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80009b00:	d4 31       	pushm	r0-r7,lr
80009b02:	fa cd 02 0c 	sub	sp,sp,524
80009b06:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80009b08:	e0 6a 01 00 	mov	r10,256
80009b0c:	30 0b       	mov	r11,0
80009b0e:	fa cc fe f4 	sub	r12,sp,-268
80009b12:	f0 1f 00 4c 	mcall	80009c40 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80009b16:	fa c4 fd d0 	sub	r4,sp,-560
80009b1a:	30 0a       	mov	r10,0
80009b1c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009b1e:	fa c3 ff fc 	sub	r3,sp,-4
80009b22:	e0 61 01 00 	mov	r1,256
80009b26:	14 90       	mov	r0,r10
			
			if(*str == '%')
80009b28:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009b2a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009b2e:	02 9a       	mov	r10,r1
80009b30:	00 9b       	mov	r11,r0
80009b32:	06 9c       	mov	r12,r3
80009b34:	f0 1f 00 43 	mcall	80009c40 <logFromISR+0x140>
			
			if(*str == '%')
80009b38:	0f 88       	ld.ub	r8,r7[0x0]
80009b3a:	e4 08 18 00 	cp.b	r8,r2
80009b3e:	c5 11       	brne	80009be0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80009b40:	ee c8 ff ff 	sub	r8,r7,-1
80009b44:	11 89       	ld.ub	r9,r8[0x0]
80009b46:	4c 0a       	lddpc	r10,80009c44 <logFromISR+0x144>
80009b48:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80009b4a:	23 09       	sub	r9,48
80009b4c:	30 9a       	mov	r10,9
80009b4e:	f4 09 18 00 	cp.b	r9,r10
80009b52:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80009b56:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009b5a:	f7 b9 08 30 	subls	r9,48
80009b5e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80009b62:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80009b66:	0f 88       	ld.ub	r8,r7[0x0]
80009b68:	22 58       	sub	r8,37
80009b6a:	e0 48 00 53 	cp.w	r8,83
80009b6e:	e0 8b 00 2b 	brhi	80009bc4 <logFromISR+0xc4>
80009b72:	4b 69       	lddpc	r9,80009c48 <logFromISR+0x148>
80009b74:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80009b78:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80009b7c:	06 9a       	mov	r10,r3
80009b7e:	40 0b       	lddsp	r11,sp[0x0]
80009b80:	5c 5b       	castu.b	r11
80009b82:	68 0c       	ld.w	r12,r4[0x0]
80009b84:	f0 1f 00 32 	mcall	80009c4c <logFromISR+0x14c>
					break;
80009b88:	c2 38       	rjmp	80009bce <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80009b8a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80009b8e:	06 9a       	mov	r10,r3
80009b90:	40 0b       	lddsp	r11,sp[0x0]
80009b92:	5c 5b       	castu.b	r11
80009b94:	68 0c       	ld.w	r12,r4[0x0]
80009b96:	f0 1f 00 2f 	mcall	80009c50 <logFromISR+0x150>
80009b9a:	06 9c       	mov	r12,r3
					break;
80009b9c:	c1 98       	rjmp	80009bce <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80009b9e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80009ba2:	06 9b       	mov	r11,r3
80009ba4:	09 bc       	ld.ub	r12,r4[0x3]
80009ba6:	f0 1f 00 2c 	mcall	80009c54 <logFromISR+0x154>
80009baa:	06 9c       	mov	r12,r3
					break;
80009bac:	c1 18       	rjmp	80009bce <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80009bae:	e8 c5 ff fc 	sub	r5,r4,-4
80009bb2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80009bb4:	c0 d8       	rjmp	80009bce <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80009bb6:	06 9b       	mov	r11,r3
80009bb8:	32 5c       	mov	r12,37
80009bba:	f0 1f 00 27 	mcall	80009c54 <logFromISR+0x154>
80009bbe:	08 95       	mov	r5,r4
80009bc0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80009bc2:	c0 68       	rjmp	80009bce <logFromISR+0xce>
					default:
					log("I need relax.");
80009bc4:	4a 5c       	lddpc	r12,80009c58 <logFromISR+0x158>
80009bc6:	f0 1f 00 26 	mcall	80009c5c <logFromISR+0x15c>
80009bca:	08 95       	mov	r5,r4
80009bcc:	06 9c       	mov	r12,r3
				}
				str++;
80009bce:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009bd0:	1a dc       	st.w	--sp,r12
80009bd2:	1a d6       	st.w	--sp,r6
80009bd4:	4a 3b       	lddpc	r11,80009c60 <logFromISR+0x160>
80009bd6:	0c 9c       	mov	r12,r6
80009bd8:	f0 1f 00 23 	mcall	80009c64 <logFromISR+0x164>
80009bdc:	2f ed       	sub	sp,-8
80009bde:	c0 a8       	rjmp	80009bf2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009be0:	2f f7       	sub	r7,-1
80009be2:	1a d8       	st.w	--sp,r8
80009be4:	1a d6       	st.w	--sp,r6
80009be6:	4a 1b       	lddpc	r11,80009c68 <logFromISR+0x168>
80009be8:	0c 9c       	mov	r12,r6
80009bea:	f0 1f 00 1f 	mcall	80009c64 <logFromISR+0x164>
80009bee:	08 95       	mov	r5,r4
80009bf0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80009bf2:	0f 89       	ld.ub	r9,r7[0x0]
80009bf4:	30 08       	mov	r8,0
80009bf6:	f0 09 18 00 	cp.b	r9,r8
80009bfa:	c0 30       	breq	80009c00 <logFromISR+0x100>
80009bfc:	0a 94       	mov	r4,r5
80009bfe:	c9 8b       	rjmp	80009b2e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80009c00:	fa c7 fe f4 	sub	r7,sp,-268
80009c04:	1a d7       	st.w	--sp,r7
80009c06:	49 ab       	lddpc	r11,80009c6c <logFromISR+0x16c>
80009c08:	0e 9c       	mov	r12,r7
80009c0a:	f0 1f 00 17 	mcall	80009c64 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80009c0e:	5c 5c       	castu.b	r12
80009c10:	f8 c6 ff ff 	sub	r6,r12,-1
80009c14:	0c 9c       	mov	r12,r6
80009c16:	f0 1f 00 17 	mcall	80009c70 <logFromISR+0x170>
80009c1a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80009c1c:	0c 9a       	mov	r10,r6
80009c1e:	0e 9b       	mov	r11,r7
80009c20:	f0 1f 00 15 	mcall	80009c74 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80009c24:	30 09       	mov	r9,0
80009c26:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80009c28:	fa ca fe f8 	sub	r10,sp,-264
80009c2c:	fa cb fe f4 	sub	r11,sp,-268
80009c30:	49 28       	lddpc	r8,80009c78 <logFromISR+0x178>
80009c32:	70 0c       	ld.w	r12,r8[0x0]
80009c34:	f0 1f 00 12 	mcall	80009c7c <logFromISR+0x17c>
80009c38:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80009c3a:	fe 3d fd f4 	sub	sp,-524
80009c3e:	d8 32       	popm	r0-r7,pc
80009c40:	80 00       	ld.sh	r0,r0[0x0]
80009c42:	a4 82       	st.b	r2[0x0],r2
80009c44:	00 00       	add	r0,r0
80009c46:	12 89       	andn	r9,r9
80009c48:	80 01       	ld.sh	r1,r0[0x0]
80009c4a:	8b 10       	st.w	r5[0x4],r0
80009c4c:	80 00       	ld.sh	r0,r0[0x0]
80009c4e:	98 9a       	ld.uh	r10,r12[0x2]
80009c50:	80 00       	ld.sh	r0,r0[0x0]
80009c52:	97 e8       	st.w	r11[0x38],r8
80009c54:	80 00       	ld.sh	r0,r0[0x0]
80009c56:	97 e4       	st.w	r11[0x38],r4
80009c58:	80 01       	ld.sh	r1,r0[0x0]
80009c5a:	8c 7c       	ld.sh	r12,r6[0xe]
80009c5c:	80 00       	ld.sh	r0,r0[0x0]
80009c5e:	99 74       	st.w	r12[0x1c],r4
80009c60:	80 01       	ld.sh	r1,r0[0x0]
80009c62:	8c 8c       	ld.uh	r12,r6[0x0]
80009c64:	80 00       	ld.sh	r0,r0[0x0]
80009c66:	a7 70       	lsl	r0,0x7
80009c68:	80 01       	ld.sh	r1,r0[0x0]
80009c6a:	8c 94       	ld.uh	r4,r6[0x2]
80009c6c:	80 01       	ld.sh	r1,r0[0x0]
80009c6e:	8c 9c       	ld.uh	r12,r6[0x2]
80009c70:	80 00       	ld.sh	r0,r0[0x0]
80009c72:	8a 30       	ld.sh	r0,r5[0x6]
80009c74:	80 00       	ld.sh	r0,r0[0x0]
80009c76:	a3 3a       	mul	r10,r1
80009c78:	00 00       	add	r0,r0
80009c7a:	46 1c       	lddsp	r12,sp[0x184]
80009c7c:	80 00       	ld.sh	r0,r0[0x0]
80009c7e:	8d 34       	st.w	r6[0xc],r4

80009c80 <log_init>:
		
	return str;
}

void log_init(void)
{
80009c80:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80009c82:	30 2b       	mov	r11,2
80009c84:	49 0c       	lddpc	r12,80009cc4 <log_init+0x44>
80009c86:	f0 1f 00 11 	mcall	80009cc8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80009c8a:	e0 6a 36 00 	mov	r10,13824
80009c8e:	ea 1a 01 6e 	orh	r10,0x16e
80009c92:	48 fb       	lddpc	r11,80009ccc <log_init+0x4c>
80009c94:	fe 7c 18 00 	mov	r12,-59392
80009c98:	f0 1f 00 0e 	mcall	80009cd0 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80009c9c:	30 4b       	mov	r11,4
80009c9e:	33 2c       	mov	r12,50
80009ca0:	f0 1f 00 0d 	mcall	80009cd4 <log_init+0x54>
80009ca4:	48 d8       	lddpc	r8,80009cd8 <log_init+0x58>
80009ca6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80009ca8:	30 09       	mov	r9,0
80009caa:	1a d9       	st.w	--sp,r9
80009cac:	1a d9       	st.w	--sp,r9
80009cae:	1a d9       	st.w	--sp,r9
80009cb0:	30 28       	mov	r8,2
80009cb2:	e0 6a 01 80 	mov	r10,384
80009cb6:	48 ab       	lddpc	r11,80009cdc <log_init+0x5c>
80009cb8:	48 ac       	lddpc	r12,80009ce0 <log_init+0x60>
80009cba:	f0 1f 00 0b 	mcall	80009ce4 <log_init+0x64>
80009cbe:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80009cc0:	d8 02       	popm	pc
80009cc2:	00 00       	add	r0,r0
80009cc4:	80 01       	ld.sh	r1,r0[0x0]
80009cc6:	8c a8       	ld.uh	r8,r6[0x4]
80009cc8:	80 00       	ld.sh	r0,r0[0x0]
80009cca:	9e 14       	ld.sh	r4,pc[0x2]
80009ccc:	80 01       	ld.sh	r1,r0[0x0]
80009cce:	8c 60       	ld.sh	r0,r6[0xc]
80009cd0:	80 00       	ld.sh	r0,r0[0x0]
80009cd2:	60 04       	ld.w	r4,r0[0x0]
80009cd4:	80 00       	ld.sh	r0,r0[0x0]
80009cd6:	8e dc       	ld.uh	r12,r7[0xa]
80009cd8:	00 00       	add	r0,r0
80009cda:	46 1c       	lddsp	r12,sp[0x184]
80009cdc:	80 01       	ld.sh	r1,r0[0x0]
80009cde:	8c a4       	ld.uh	r4,r6[0x4]
80009ce0:	80 00       	ld.sh	r0,r0[0x0]
80009ce2:	9c e8       	ld.uh	r8,lr[0xc]
80009ce4:	80 00       	ld.sh	r0,r0[0x0]
80009ce6:	95 b0       	st.w	r10[0x2c],r0

80009ce8 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80009ce8:	eb cd 40 f8 	pushm	r3-r7,lr
80009cec:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009cee:	48 c7       	lddpc	r7,80009d1c <task_log+0x34>
80009cf0:	30 05       	mov	r5,0
80009cf2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80009cf4:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009cf8:	0a 99       	mov	r9,r5
80009cfa:	08 9a       	mov	r10,r4
80009cfc:	1a 9b       	mov	r11,sp
80009cfe:	6e 0c       	ld.w	r12,r7[0x0]
80009d00:	f0 1f 00 08 	mcall	80009d20 <task_log+0x38>
80009d04:	58 1c       	cp.w	r12,1
80009d06:	cf 91       	brne	80009cf8 <task_log+0x10>
		{
			if( NULL != str)
80009d08:	40 0b       	lddsp	r11,sp[0x0]
80009d0a:	58 0b       	cp.w	r11,0
80009d0c:	cf 60       	breq	80009cf8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80009d0e:	06 9c       	mov	r12,r3
80009d10:	f0 1f 00 05 	mcall	80009d24 <task_log+0x3c>
				vPortFree(str);
80009d14:	40 0c       	lddsp	r12,sp[0x0]
80009d16:	f0 1f 00 05 	mcall	80009d28 <task_log+0x40>
80009d1a:	ce fb       	rjmp	80009cf8 <task_log+0x10>
80009d1c:	00 00       	add	r0,r0
80009d1e:	46 1c       	lddsp	r12,sp[0x184]
80009d20:	80 00       	ld.sh	r0,r0[0x0]
80009d22:	8b 78       	st.w	r5[0x1c],r8
80009d24:	80 00       	ld.sh	r0,r0[0x0]
80009d26:	5f b4       	srhi	r4
80009d28:	80 00       	ld.sh	r0,r0[0x0]
80009d2a:	8a 08       	ld.sh	r8,r5[0x0]

80009d2c <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80009d2c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80009d2e:	fe 78 10 00 	mov	r8,-61440
80009d32:	30 19       	mov	r9,1
80009d34:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80009d38:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80009d3c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80009d40:	d3 03       	ssrf	0x10
	local_start_pll0();
80009d42:	f0 1f 00 14 	mcall	80009d90 <main+0x64>
		
	INTC_init_interrupts();
80009d46:	f0 1f 00 14 	mcall	80009d94 <main+0x68>
	
	log_init();		
80009d4a:	f0 1f 00 14 	mcall	80009d98 <main+0x6c>
	log("----start debug----");	
80009d4e:	49 4c       	lddpc	r12,80009d9c <main+0x70>
80009d50:	f0 1f 00 14 	mcall	80009da0 <main+0x74>
		
	rtc_init();
80009d54:	f0 1f 00 14 	mcall	80009da4 <main+0x78>
	
	fs_init();//65795
80009d58:	f0 1f 00 14 	mcall	80009da8 <main+0x7c>

	tc_init();	
80009d5c:	f0 1f 00 14 	mcall	80009dac <main+0x80>
			
	xcmp_init();
80009d60:	f0 1f 00 14 	mcall	80009db0 <main+0x84>
	
	app_init();
80009d64:	f0 1f 00 14 	mcall	80009db4 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80009d68:	fe 79 10 00 	mov	r9,-61440
80009d6c:	f2 f8 01 60 	ld.w	r8,r9[352]
80009d70:	e2 18 00 02 	andl	r8,0x2,COH
80009d74:	cf c0       	breq	80009d6c <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80009d76:	fe 79 10 00 	mov	r9,-61440
80009d7a:	f2 f8 01 60 	ld.w	r8,r9[352]
80009d7e:	e2 18 00 02 	andl	r8,0x2,COH
80009d82:	cf c1       	brne	80009d7a <main+0x4e>
	local_start_timer();
80009d84:	f0 1f 00 0d 	mcall	80009db8 <main+0x8c>
	
	Enable_global_interrupt();
80009d88:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80009d8a:	f0 1f 00 0d 	mcall	80009dbc <main+0x90>
	return 0;
}
80009d8e:	d8 0a       	popm	pc,r12=0
80009d90:	80 00       	ld.sh	r0,r0[0x0]
80009d92:	55 7c       	stdsp	sp[0x15c],r12
80009d94:	80 00       	ld.sh	r0,r0[0x0]
80009d96:	59 14       	cp.w	r4,17
80009d98:	80 00       	ld.sh	r0,r0[0x0]
80009d9a:	9c 80       	ld.uh	r0,lr[0x0]
80009d9c:	80 01       	ld.sh	r1,r0[0x0]
80009d9e:	8c b8       	ld.uh	r8,r6[0x6]
80009da0:	80 00       	ld.sh	r0,r0[0x0]
80009da2:	99 74       	st.w	r12[0x1c],r4
80009da4:	80 00       	ld.sh	r0,r0[0x0]
80009da6:	57 48       	stdsp	sp[0x1d0],r8
80009da8:	80 00       	ld.sh	r0,r0[0x0]
80009daa:	38 bc       	mov	r12,-117
80009dac:	80 00       	ld.sh	r0,r0[0x0]
80009dae:	58 10       	cp.w	r0,1
80009db0:	80 00       	ld.sh	r0,r0[0x0]
80009db2:	4e 80       	lddpc	r0,80009f50 <_malloc_r+0x74>
80009db4:	80 00       	ld.sh	r0,r0[0x0]
80009db6:	20 44       	sub	r4,4
80009db8:	80 00       	ld.sh	r0,r0[0x0]
80009dba:	57 d4       	stdsp	sp[0x1f4],r4
80009dbc:	80 00       	ld.sh	r0,r0[0x0]
80009dbe:	97 98       	st.w	r11[0x24],r8

80009dc0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009dc0:	f8 08 16 05 	lsr	r8,r12,0x5
80009dc4:	a9 68       	lsl	r8,0x8
80009dc6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80009dca:	58 1b       	cp.w	r11,1
80009dcc:	c0 d0       	breq	80009de6 <gpio_enable_module_pin+0x26>
80009dce:	c0 63       	brcs	80009dda <gpio_enable_module_pin+0x1a>
80009dd0:	58 2b       	cp.w	r11,2
80009dd2:	c1 00       	breq	80009df2 <gpio_enable_module_pin+0x32>
80009dd4:	58 3b       	cp.w	r11,3
80009dd6:	c1 40       	breq	80009dfe <gpio_enable_module_pin+0x3e>
80009dd8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009dda:	30 19       	mov	r9,1
80009ddc:	f2 0c 09 49 	lsl	r9,r9,r12
80009de0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009de2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009de4:	c1 28       	rjmp	80009e08 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009de6:	30 19       	mov	r9,1
80009de8:	f2 0c 09 49 	lsl	r9,r9,r12
80009dec:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009dee:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009df0:	c0 c8       	rjmp	80009e08 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009df2:	30 19       	mov	r9,1
80009df4:	f2 0c 09 49 	lsl	r9,r9,r12
80009df8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009dfa:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009dfc:	c0 68       	rjmp	80009e08 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009dfe:	30 19       	mov	r9,1
80009e00:	f2 0c 09 49 	lsl	r9,r9,r12
80009e04:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009e06:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80009e08:	30 19       	mov	r9,1
80009e0a:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e0e:	91 2c       	st.w	r8[0x8],r12
80009e10:	5e fd       	retal	0
80009e12:	d7 03       	nop

80009e14 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80009e14:	d4 21       	pushm	r4-r7,lr
80009e16:	18 97       	mov	r7,r12
80009e18:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009e1a:	58 0b       	cp.w	r11,0
80009e1c:	c0 31       	brne	80009e22 <gpio_enable_module+0xe>
80009e1e:	30 05       	mov	r5,0
80009e20:	c0 d8       	rjmp	80009e3a <gpio_enable_module+0x26>
80009e22:	30 06       	mov	r6,0
80009e24:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80009e26:	6e 1b       	ld.w	r11,r7[0x4]
80009e28:	6e 0c       	ld.w	r12,r7[0x0]
80009e2a:	f0 1f 00 06 	mcall	80009e40 <gpio_enable_module+0x2c>
80009e2e:	18 45       	or	r5,r12
		gpiomap++;
80009e30:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009e32:	2f f6       	sub	r6,-1
80009e34:	0c 34       	cp.w	r4,r6
80009e36:	fe 9b ff f8 	brhi	80009e26 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80009e3a:	0a 9c       	mov	r12,r5
80009e3c:	d8 22       	popm	r4-r7,pc
80009e3e:	00 00       	add	r0,r0
80009e40:	80 00       	ld.sh	r0,r0[0x0]
80009e42:	9d c0       	st.w	lr[0x30],r0

80009e44 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009e44:	f8 08 16 05 	lsr	r8,r12,0x5
80009e48:	a9 68       	lsl	r8,0x8
80009e4a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80009e4e:	30 19       	mov	r9,1
80009e50:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e54:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80009e58:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009e5c:	91 1c       	st.w	r8[0x4],r12
}
80009e5e:	5e fc       	retal	r12

80009e60 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009e60:	f8 08 16 05 	lsr	r8,r12,0x5
80009e64:	a9 68       	lsl	r8,0x8
80009e66:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80009e6a:	30 19       	mov	r9,1
80009e6c:	f2 0c 09 4c 	lsl	r12,r9,r12
80009e70:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80009e74:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009e78:	91 1c       	st.w	r8[0x4],r12
}
80009e7a:	5e fc       	retal	r12

80009e7c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80009e7c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80009e80:	fe c0 a4 80 	sub	r0,pc,-23424

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80009e84:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80009e88:	d5 53       	csrf	0x15
  cp      r0, r1
80009e8a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80009e8c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80009e90:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80009e92:	c0 62       	brcc	80009e9e <idata_load_loop_end>
  cp      r0, r1
80009e94:	48 92       	lddpc	r2,80009eb8 <udata_clear_loop_end+0x4>

80009e96 <idata_load_loop>:
  brlo    idata_load_loop
80009e96:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80009e98:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80009e9a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80009e9c:	cf d3       	brcs	80009e96 <idata_load_loop>

80009e9e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80009e9e:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80009ea2:	e0 61 46 28 	mov	r1,17960
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80009ea6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80009ea8:	c0 62       	brcc	80009eb4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80009eaa:	30 02       	mov	r2,0
80009eac:	30 03       	mov	r3,0

80009eae <udata_clear_loop>:
80009eae:	a1 22       	st.d	r0++,r2
80009eb0:	02 30       	cp.w	r0,r1
80009eb2:	cf e3       	brcs	80009eae <udata_clear_loop>

80009eb4 <udata_clear_loop_end>:
80009eb4:	fe cf 01 88 	sub	pc,pc,392
80009eb8:	80 01       	ld.sh	r1,r0[0x0]
80009eba:	92 50       	ld.sh	r0,r9[0xa]

80009ebc <free>:
80009ebc:	d4 01       	pushm	lr
80009ebe:	e0 68 0a 38 	mov	r8,2616
80009ec2:	18 9b       	mov	r11,r12
80009ec4:	70 0c       	ld.w	r12,r8[0x0]
80009ec6:	e0 a0 1f 19 	rcall	8000dcf8 <_free_r>
80009eca:	d8 02       	popm	pc

80009ecc <malloc>:
80009ecc:	d4 01       	pushm	lr
80009ece:	e0 68 0a 38 	mov	r8,2616
80009ed2:	18 9b       	mov	r11,r12
80009ed4:	70 0c       	ld.w	r12,r8[0x0]
80009ed6:	c0 3c       	rcall	80009edc <_malloc_r>
80009ed8:	d8 02       	popm	pc
80009eda:	d7 03       	nop

80009edc <_malloc_r>:
80009edc:	d4 31       	pushm	r0-r7,lr
80009ede:	f6 c8 ff f5 	sub	r8,r11,-11
80009ee2:	18 95       	mov	r5,r12
80009ee4:	10 97       	mov	r7,r8
80009ee6:	e0 17 ff f8 	andl	r7,0xfff8
80009eea:	59 68       	cp.w	r8,22
80009eec:	f9 b7 08 10 	movls	r7,16
80009ef0:	16 37       	cp.w	r7,r11
80009ef2:	5f 38       	srlo	r8
80009ef4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80009ef8:	c0 50       	breq	80009f02 <_malloc_r+0x26>
80009efa:	30 c8       	mov	r8,12
80009efc:	99 38       	st.w	r12[0xc],r8
80009efe:	e0 8f 01 fa 	bral	8000a2f2 <_malloc_r+0x416>
80009f02:	fe b0 f5 39 	rcall	80008974 <__malloc_lock>
80009f06:	e0 47 01 f7 	cp.w	r7,503
80009f0a:	e0 8b 00 1d 	brhi	80009f44 <_malloc_r+0x68>
80009f0e:	ee 03 16 03 	lsr	r3,r7,0x3
80009f12:	e0 68 05 38 	mov	r8,1336
80009f16:	f0 03 00 38 	add	r8,r8,r3<<0x3
80009f1a:	70 36       	ld.w	r6,r8[0xc]
80009f1c:	10 36       	cp.w	r6,r8
80009f1e:	c0 61       	brne	80009f2a <_malloc_r+0x4e>
80009f20:	ec c8 ff f8 	sub	r8,r6,-8
80009f24:	70 36       	ld.w	r6,r8[0xc]
80009f26:	10 36       	cp.w	r6,r8
80009f28:	c0 c0       	breq	80009f40 <_malloc_r+0x64>
80009f2a:	6c 18       	ld.w	r8,r6[0x4]
80009f2c:	e0 18 ff fc 	andl	r8,0xfffc
80009f30:	6c 3a       	ld.w	r10,r6[0xc]
80009f32:	ec 08 00 09 	add	r9,r6,r8
80009f36:	0a 9c       	mov	r12,r5
80009f38:	6c 28       	ld.w	r8,r6[0x8]
80009f3a:	95 28       	st.w	r10[0x8],r8
80009f3c:	91 3a       	st.w	r8[0xc],r10
80009f3e:	c4 78       	rjmp	80009fcc <_malloc_r+0xf0>
80009f40:	2f e3       	sub	r3,-2
80009f42:	c4 d8       	rjmp	80009fdc <_malloc_r+0x100>
80009f44:	ee 03 16 09 	lsr	r3,r7,0x9
80009f48:	c0 41       	brne	80009f50 <_malloc_r+0x74>
80009f4a:	ee 03 16 03 	lsr	r3,r7,0x3
80009f4e:	c2 68       	rjmp	80009f9a <_malloc_r+0xbe>
80009f50:	58 43       	cp.w	r3,4
80009f52:	e0 8b 00 06 	brhi	80009f5e <_malloc_r+0x82>
80009f56:	ee 03 16 06 	lsr	r3,r7,0x6
80009f5a:	2c 83       	sub	r3,-56
80009f5c:	c1 f8       	rjmp	80009f9a <_malloc_r+0xbe>
80009f5e:	59 43       	cp.w	r3,20
80009f60:	e0 8b 00 04 	brhi	80009f68 <_malloc_r+0x8c>
80009f64:	2a 53       	sub	r3,-91
80009f66:	c1 a8       	rjmp	80009f9a <_malloc_r+0xbe>
80009f68:	e0 43 00 54 	cp.w	r3,84
80009f6c:	e0 8b 00 06 	brhi	80009f78 <_malloc_r+0x9c>
80009f70:	ee 03 16 0c 	lsr	r3,r7,0xc
80009f74:	29 23       	sub	r3,-110
80009f76:	c1 28       	rjmp	80009f9a <_malloc_r+0xbe>
80009f78:	e0 43 01 54 	cp.w	r3,340
80009f7c:	e0 8b 00 06 	brhi	80009f88 <_malloc_r+0xac>
80009f80:	ee 03 16 0f 	lsr	r3,r7,0xf
80009f84:	28 93       	sub	r3,-119
80009f86:	c0 a8       	rjmp	80009f9a <_malloc_r+0xbe>
80009f88:	e0 43 05 54 	cp.w	r3,1364
80009f8c:	e0 88 00 04 	brls	80009f94 <_malloc_r+0xb8>
80009f90:	37 e3       	mov	r3,126
80009f92:	c0 48       	rjmp	80009f9a <_malloc_r+0xbe>
80009f94:	ee 03 16 12 	lsr	r3,r7,0x12
80009f98:	28 43       	sub	r3,-124
80009f9a:	e0 6a 05 38 	mov	r10,1336
80009f9e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80009fa2:	74 36       	ld.w	r6,r10[0xc]
80009fa4:	c1 98       	rjmp	80009fd6 <_malloc_r+0xfa>
80009fa6:	6c 19       	ld.w	r9,r6[0x4]
80009fa8:	e0 19 ff fc 	andl	r9,0xfffc
80009fac:	f2 07 01 0b 	sub	r11,r9,r7
80009fb0:	58 fb       	cp.w	r11,15
80009fb2:	e0 8a 00 04 	brle	80009fba <_malloc_r+0xde>
80009fb6:	20 13       	sub	r3,1
80009fb8:	c1 18       	rjmp	80009fda <_malloc_r+0xfe>
80009fba:	6c 38       	ld.w	r8,r6[0xc]
80009fbc:	58 0b       	cp.w	r11,0
80009fbe:	c0 b5       	brlt	80009fd4 <_malloc_r+0xf8>
80009fc0:	6c 2a       	ld.w	r10,r6[0x8]
80009fc2:	ec 09 00 09 	add	r9,r6,r9
80009fc6:	0a 9c       	mov	r12,r5
80009fc8:	91 2a       	st.w	r8[0x8],r10
80009fca:	95 38       	st.w	r10[0xc],r8
80009fcc:	72 18       	ld.w	r8,r9[0x4]
80009fce:	a1 a8       	sbr	r8,0x0
80009fd0:	93 18       	st.w	r9[0x4],r8
80009fd2:	cb c8       	rjmp	8000a14a <_malloc_r+0x26e>
80009fd4:	10 96       	mov	r6,r8
80009fd6:	14 36       	cp.w	r6,r10
80009fd8:	ce 71       	brne	80009fa6 <_malloc_r+0xca>
80009fda:	2f f3       	sub	r3,-1
80009fdc:	e0 6a 05 38 	mov	r10,1336
80009fe0:	f4 cc ff f8 	sub	r12,r10,-8
80009fe4:	78 26       	ld.w	r6,r12[0x8]
80009fe6:	18 36       	cp.w	r6,r12
80009fe8:	c6 c0       	breq	8000a0c0 <_malloc_r+0x1e4>
80009fea:	6c 19       	ld.w	r9,r6[0x4]
80009fec:	e0 19 ff fc 	andl	r9,0xfffc
80009ff0:	f2 07 01 08 	sub	r8,r9,r7
80009ff4:	58 f8       	cp.w	r8,15
80009ff6:	e0 89 00 8f 	brgt	8000a114 <_malloc_r+0x238>
80009ffa:	99 3c       	st.w	r12[0xc],r12
80009ffc:	99 2c       	st.w	r12[0x8],r12
80009ffe:	58 08       	cp.w	r8,0
8000a000:	c0 55       	brlt	8000a00a <_malloc_r+0x12e>
8000a002:	ec 09 00 09 	add	r9,r6,r9
8000a006:	0a 9c       	mov	r12,r5
8000a008:	ce 2b       	rjmp	80009fcc <_malloc_r+0xf0>
8000a00a:	e0 49 01 ff 	cp.w	r9,511
8000a00e:	e0 8b 00 13 	brhi	8000a034 <_malloc_r+0x158>
8000a012:	a3 99       	lsr	r9,0x3
8000a014:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a018:	70 2b       	ld.w	r11,r8[0x8]
8000a01a:	8d 38       	st.w	r6[0xc],r8
8000a01c:	8d 2b       	st.w	r6[0x8],r11
8000a01e:	97 36       	st.w	r11[0xc],r6
8000a020:	91 26       	st.w	r8[0x8],r6
8000a022:	a3 49       	asr	r9,0x2
8000a024:	74 18       	ld.w	r8,r10[0x4]
8000a026:	30 1b       	mov	r11,1
8000a028:	f6 09 09 49 	lsl	r9,r11,r9
8000a02c:	f1 e9 10 09 	or	r9,r8,r9
8000a030:	95 19       	st.w	r10[0x4],r9
8000a032:	c4 78       	rjmp	8000a0c0 <_malloc_r+0x1e4>
8000a034:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a038:	58 4a       	cp.w	r10,4
8000a03a:	e0 8b 00 07 	brhi	8000a048 <_malloc_r+0x16c>
8000a03e:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a042:	2c 8a       	sub	r10,-56
8000a044:	c2 08       	rjmp	8000a084 <_malloc_r+0x1a8>
8000a046:	d7 03       	nop
8000a048:	59 4a       	cp.w	r10,20
8000a04a:	e0 8b 00 04 	brhi	8000a052 <_malloc_r+0x176>
8000a04e:	2a 5a       	sub	r10,-91
8000a050:	c1 a8       	rjmp	8000a084 <_malloc_r+0x1a8>
8000a052:	e0 4a 00 54 	cp.w	r10,84
8000a056:	e0 8b 00 06 	brhi	8000a062 <_malloc_r+0x186>
8000a05a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a05e:	29 2a       	sub	r10,-110
8000a060:	c1 28       	rjmp	8000a084 <_malloc_r+0x1a8>
8000a062:	e0 4a 01 54 	cp.w	r10,340
8000a066:	e0 8b 00 06 	brhi	8000a072 <_malloc_r+0x196>
8000a06a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a06e:	28 9a       	sub	r10,-119
8000a070:	c0 a8       	rjmp	8000a084 <_malloc_r+0x1a8>
8000a072:	e0 4a 05 54 	cp.w	r10,1364
8000a076:	e0 88 00 04 	brls	8000a07e <_malloc_r+0x1a2>
8000a07a:	37 ea       	mov	r10,126
8000a07c:	c0 48       	rjmp	8000a084 <_malloc_r+0x1a8>
8000a07e:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a082:	28 4a       	sub	r10,-124
8000a084:	e0 6b 05 38 	mov	r11,1336
8000a088:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a08c:	68 28       	ld.w	r8,r4[0x8]
8000a08e:	08 38       	cp.w	r8,r4
8000a090:	c0 e1       	brne	8000a0ac <_malloc_r+0x1d0>
8000a092:	76 19       	ld.w	r9,r11[0x4]
8000a094:	a3 4a       	asr	r10,0x2
8000a096:	30 1e       	mov	lr,1
8000a098:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a09c:	f3 ea 10 0a 	or	r10,r9,r10
8000a0a0:	10 99       	mov	r9,r8
8000a0a2:	97 1a       	st.w	r11[0x4],r10
8000a0a4:	c0 a8       	rjmp	8000a0b8 <_malloc_r+0x1dc>
8000a0a6:	70 28       	ld.w	r8,r8[0x8]
8000a0a8:	08 38       	cp.w	r8,r4
8000a0aa:	c0 60       	breq	8000a0b6 <_malloc_r+0x1da>
8000a0ac:	70 1a       	ld.w	r10,r8[0x4]
8000a0ae:	e0 1a ff fc 	andl	r10,0xfffc
8000a0b2:	14 39       	cp.w	r9,r10
8000a0b4:	cf 93       	brcs	8000a0a6 <_malloc_r+0x1ca>
8000a0b6:	70 39       	ld.w	r9,r8[0xc]
8000a0b8:	8d 39       	st.w	r6[0xc],r9
8000a0ba:	8d 28       	st.w	r6[0x8],r8
8000a0bc:	91 36       	st.w	r8[0xc],r6
8000a0be:	93 26       	st.w	r9[0x8],r6
8000a0c0:	e6 08 14 02 	asr	r8,r3,0x2
8000a0c4:	30 1b       	mov	r11,1
8000a0c6:	e0 64 05 38 	mov	r4,1336
8000a0ca:	f6 08 09 4b 	lsl	r11,r11,r8
8000a0ce:	68 18       	ld.w	r8,r4[0x4]
8000a0d0:	10 3b       	cp.w	r11,r8
8000a0d2:	e0 8b 00 6b 	brhi	8000a1a8 <_malloc_r+0x2cc>
8000a0d6:	f7 e8 00 09 	and	r9,r11,r8
8000a0da:	c0 b1       	brne	8000a0f0 <_malloc_r+0x214>
8000a0dc:	e0 13 ff fc 	andl	r3,0xfffc
8000a0e0:	a1 7b       	lsl	r11,0x1
8000a0e2:	2f c3       	sub	r3,-4
8000a0e4:	c0 38       	rjmp	8000a0ea <_malloc_r+0x20e>
8000a0e6:	2f c3       	sub	r3,-4
8000a0e8:	a1 7b       	lsl	r11,0x1
8000a0ea:	f7 e8 00 09 	and	r9,r11,r8
8000a0ee:	cf c0       	breq	8000a0e6 <_malloc_r+0x20a>
8000a0f0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a0f4:	06 92       	mov	r2,r3
8000a0f6:	1c 91       	mov	r1,lr
8000a0f8:	62 36       	ld.w	r6,r1[0xc]
8000a0fa:	c2 e8       	rjmp	8000a156 <_malloc_r+0x27a>
8000a0fc:	6c 1a       	ld.w	r10,r6[0x4]
8000a0fe:	e0 1a ff fc 	andl	r10,0xfffc
8000a102:	f4 07 01 08 	sub	r8,r10,r7
8000a106:	58 f8       	cp.w	r8,15
8000a108:	e0 8a 00 15 	brle	8000a132 <_malloc_r+0x256>
8000a10c:	6c 3a       	ld.w	r10,r6[0xc]
8000a10e:	6c 29       	ld.w	r9,r6[0x8]
8000a110:	95 29       	st.w	r10[0x8],r9
8000a112:	93 3a       	st.w	r9[0xc],r10
8000a114:	0e 99       	mov	r9,r7
8000a116:	ec 07 00 07 	add	r7,r6,r7
8000a11a:	a1 a9       	sbr	r9,0x0
8000a11c:	99 37       	st.w	r12[0xc],r7
8000a11e:	99 27       	st.w	r12[0x8],r7
8000a120:	8d 19       	st.w	r6[0x4],r9
8000a122:	ee 08 09 08 	st.w	r7[r8],r8
8000a126:	8f 2c       	st.w	r7[0x8],r12
8000a128:	8f 3c       	st.w	r7[0xc],r12
8000a12a:	a1 a8       	sbr	r8,0x0
8000a12c:	0a 9c       	mov	r12,r5
8000a12e:	8f 18       	st.w	r7[0x4],r8
8000a130:	c0 d8       	rjmp	8000a14a <_malloc_r+0x26e>
8000a132:	6c 39       	ld.w	r9,r6[0xc]
8000a134:	58 08       	cp.w	r8,0
8000a136:	c0 f5       	brlt	8000a154 <_malloc_r+0x278>
8000a138:	ec 0a 00 0a 	add	r10,r6,r10
8000a13c:	74 18       	ld.w	r8,r10[0x4]
8000a13e:	a1 a8       	sbr	r8,0x0
8000a140:	0a 9c       	mov	r12,r5
8000a142:	95 18       	st.w	r10[0x4],r8
8000a144:	6c 28       	ld.w	r8,r6[0x8]
8000a146:	93 28       	st.w	r9[0x8],r8
8000a148:	91 39       	st.w	r8[0xc],r9
8000a14a:	fe b0 f4 1b 	rcall	80008980 <__malloc_unlock>
8000a14e:	ec cc ff f8 	sub	r12,r6,-8
8000a152:	d8 32       	popm	r0-r7,pc
8000a154:	12 96       	mov	r6,r9
8000a156:	02 36       	cp.w	r6,r1
8000a158:	cd 21       	brne	8000a0fc <_malloc_r+0x220>
8000a15a:	2f f2       	sub	r2,-1
8000a15c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a160:	c0 30       	breq	8000a166 <_malloc_r+0x28a>
8000a162:	2f 81       	sub	r1,-8
8000a164:	cc ab       	rjmp	8000a0f8 <_malloc_r+0x21c>
8000a166:	1c 98       	mov	r8,lr
8000a168:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a16c:	c0 81       	brne	8000a17c <_malloc_r+0x2a0>
8000a16e:	68 19       	ld.w	r9,r4[0x4]
8000a170:	f6 08 11 ff 	rsub	r8,r11,-1
8000a174:	f3 e8 00 08 	and	r8,r9,r8
8000a178:	89 18       	st.w	r4[0x4],r8
8000a17a:	c0 78       	rjmp	8000a188 <_malloc_r+0x2ac>
8000a17c:	f0 c9 00 08 	sub	r9,r8,8
8000a180:	20 13       	sub	r3,1
8000a182:	70 08       	ld.w	r8,r8[0x0]
8000a184:	12 38       	cp.w	r8,r9
8000a186:	cf 10       	breq	8000a168 <_malloc_r+0x28c>
8000a188:	a1 7b       	lsl	r11,0x1
8000a18a:	68 18       	ld.w	r8,r4[0x4]
8000a18c:	10 3b       	cp.w	r11,r8
8000a18e:	e0 8b 00 0d 	brhi	8000a1a8 <_malloc_r+0x2cc>
8000a192:	58 0b       	cp.w	r11,0
8000a194:	c0 a0       	breq	8000a1a8 <_malloc_r+0x2cc>
8000a196:	04 93       	mov	r3,r2
8000a198:	c0 38       	rjmp	8000a19e <_malloc_r+0x2c2>
8000a19a:	2f c3       	sub	r3,-4
8000a19c:	a1 7b       	lsl	r11,0x1
8000a19e:	f7 e8 00 09 	and	r9,r11,r8
8000a1a2:	ca 71       	brne	8000a0f0 <_malloc_r+0x214>
8000a1a4:	cf bb       	rjmp	8000a19a <_malloc_r+0x2be>
8000a1a6:	d7 03       	nop
8000a1a8:	68 23       	ld.w	r3,r4[0x8]
8000a1aa:	66 12       	ld.w	r2,r3[0x4]
8000a1ac:	e0 12 ff fc 	andl	r2,0xfffc
8000a1b0:	0e 32       	cp.w	r2,r7
8000a1b2:	5f 39       	srlo	r9
8000a1b4:	e4 07 01 08 	sub	r8,r2,r7
8000a1b8:	58 f8       	cp.w	r8,15
8000a1ba:	5f aa       	srle	r10
8000a1bc:	f5 e9 10 09 	or	r9,r10,r9
8000a1c0:	e0 80 00 9a 	breq	8000a2f4 <_malloc_r+0x418>
8000a1c4:	e0 68 12 94 	mov	r8,4756
8000a1c8:	70 01       	ld.w	r1,r8[0x0]
8000a1ca:	e0 68 09 44 	mov	r8,2372
8000a1ce:	2f 01       	sub	r1,-16
8000a1d0:	70 08       	ld.w	r8,r8[0x0]
8000a1d2:	0e 01       	add	r1,r7
8000a1d4:	5b f8       	cp.w	r8,-1
8000a1d6:	c0 40       	breq	8000a1de <_malloc_r+0x302>
8000a1d8:	28 11       	sub	r1,-127
8000a1da:	e0 11 ff 80 	andl	r1,0xff80
8000a1de:	02 9b       	mov	r11,r1
8000a1e0:	0a 9c       	mov	r12,r5
8000a1e2:	e0 a0 02 b7 	rcall	8000a750 <_sbrk_r>
8000a1e6:	18 96       	mov	r6,r12
8000a1e8:	5b fc       	cp.w	r12,-1
8000a1ea:	c7 50       	breq	8000a2d4 <_malloc_r+0x3f8>
8000a1ec:	e6 02 00 08 	add	r8,r3,r2
8000a1f0:	10 3c       	cp.w	r12,r8
8000a1f2:	c0 32       	brcc	8000a1f8 <_malloc_r+0x31c>
8000a1f4:	08 33       	cp.w	r3,r4
8000a1f6:	c6 f1       	brne	8000a2d4 <_malloc_r+0x3f8>
8000a1f8:	e0 6a 12 98 	mov	r10,4760
8000a1fc:	74 09       	ld.w	r9,r10[0x0]
8000a1fe:	e2 09 00 09 	add	r9,r1,r9
8000a202:	95 09       	st.w	r10[0x0],r9
8000a204:	10 36       	cp.w	r6,r8
8000a206:	c0 a1       	brne	8000a21a <_malloc_r+0x33e>
8000a208:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a20c:	c0 71       	brne	8000a21a <_malloc_r+0x33e>
8000a20e:	e2 02 00 02 	add	r2,r1,r2
8000a212:	68 28       	ld.w	r8,r4[0x8]
8000a214:	a1 a2       	sbr	r2,0x0
8000a216:	91 12       	st.w	r8[0x4],r2
8000a218:	c4 f8       	rjmp	8000a2b6 <_malloc_r+0x3da>
8000a21a:	e0 6a 09 44 	mov	r10,2372
8000a21e:	74 0b       	ld.w	r11,r10[0x0]
8000a220:	5b fb       	cp.w	r11,-1
8000a222:	c0 31       	brne	8000a228 <_malloc_r+0x34c>
8000a224:	95 06       	st.w	r10[0x0],r6
8000a226:	c0 78       	rjmp	8000a234 <_malloc_r+0x358>
8000a228:	ec 09 00 09 	add	r9,r6,r9
8000a22c:	e0 6a 12 98 	mov	r10,4760
8000a230:	10 19       	sub	r9,r8
8000a232:	95 09       	st.w	r10[0x0],r9
8000a234:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a238:	f0 09 11 08 	rsub	r9,r8,8
8000a23c:	58 08       	cp.w	r8,0
8000a23e:	f2 08 17 10 	movne	r8,r9
8000a242:	ed d8 e1 06 	addne	r6,r6,r8
8000a246:	28 08       	sub	r8,-128
8000a248:	ec 01 00 01 	add	r1,r6,r1
8000a24c:	0a 9c       	mov	r12,r5
8000a24e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a252:	f0 01 01 01 	sub	r1,r8,r1
8000a256:	02 9b       	mov	r11,r1
8000a258:	e0 a0 02 7c 	rcall	8000a750 <_sbrk_r>
8000a25c:	e0 68 12 98 	mov	r8,4760
8000a260:	5b fc       	cp.w	r12,-1
8000a262:	ec 0c 17 00 	moveq	r12,r6
8000a266:	f9 b1 00 00 	moveq	r1,0
8000a26a:	70 09       	ld.w	r9,r8[0x0]
8000a26c:	0c 1c       	sub	r12,r6
8000a26e:	89 26       	st.w	r4[0x8],r6
8000a270:	02 0c       	add	r12,r1
8000a272:	12 01       	add	r1,r9
8000a274:	a1 ac       	sbr	r12,0x0
8000a276:	91 01       	st.w	r8[0x0],r1
8000a278:	8d 1c       	st.w	r6[0x4],r12
8000a27a:	08 33       	cp.w	r3,r4
8000a27c:	c1 d0       	breq	8000a2b6 <_malloc_r+0x3da>
8000a27e:	58 f2       	cp.w	r2,15
8000a280:	e0 8b 00 05 	brhi	8000a28a <_malloc_r+0x3ae>
8000a284:	30 18       	mov	r8,1
8000a286:	8d 18       	st.w	r6[0x4],r8
8000a288:	c2 68       	rjmp	8000a2d4 <_malloc_r+0x3f8>
8000a28a:	30 59       	mov	r9,5
8000a28c:	20 c2       	sub	r2,12
8000a28e:	e0 12 ff f8 	andl	r2,0xfff8
8000a292:	e6 02 00 08 	add	r8,r3,r2
8000a296:	91 29       	st.w	r8[0x8],r9
8000a298:	91 19       	st.w	r8[0x4],r9
8000a29a:	66 18       	ld.w	r8,r3[0x4]
8000a29c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a2a0:	e5 e8 10 08 	or	r8,r2,r8
8000a2a4:	87 18       	st.w	r3[0x4],r8
8000a2a6:	58 f2       	cp.w	r2,15
8000a2a8:	e0 88 00 07 	brls	8000a2b6 <_malloc_r+0x3da>
8000a2ac:	e6 cb ff f8 	sub	r11,r3,-8
8000a2b0:	0a 9c       	mov	r12,r5
8000a2b2:	e0 a0 1d 23 	rcall	8000dcf8 <_free_r>
8000a2b6:	e0 69 12 90 	mov	r9,4752
8000a2ba:	72 0a       	ld.w	r10,r9[0x0]
8000a2bc:	e0 68 12 98 	mov	r8,4760
8000a2c0:	70 08       	ld.w	r8,r8[0x0]
8000a2c2:	14 38       	cp.w	r8,r10
8000a2c4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a2c8:	e0 69 12 8c 	mov	r9,4748
8000a2cc:	72 0a       	ld.w	r10,r9[0x0]
8000a2ce:	14 38       	cp.w	r8,r10
8000a2d0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a2d4:	68 28       	ld.w	r8,r4[0x8]
8000a2d6:	70 18       	ld.w	r8,r8[0x4]
8000a2d8:	e0 18 ff fc 	andl	r8,0xfffc
8000a2dc:	0e 38       	cp.w	r8,r7
8000a2de:	5f 39       	srlo	r9
8000a2e0:	0e 18       	sub	r8,r7
8000a2e2:	58 f8       	cp.w	r8,15
8000a2e4:	5f aa       	srle	r10
8000a2e6:	f5 e9 10 09 	or	r9,r10,r9
8000a2ea:	c0 50       	breq	8000a2f4 <_malloc_r+0x418>
8000a2ec:	0a 9c       	mov	r12,r5
8000a2ee:	fe b0 f3 49 	rcall	80008980 <__malloc_unlock>
8000a2f2:	d8 3a       	popm	r0-r7,pc,r12=0
8000a2f4:	68 26       	ld.w	r6,r4[0x8]
8000a2f6:	a1 a8       	sbr	r8,0x0
8000a2f8:	0e 99       	mov	r9,r7
8000a2fa:	a1 a9       	sbr	r9,0x0
8000a2fc:	8d 19       	st.w	r6[0x4],r9
8000a2fe:	ec 07 00 07 	add	r7,r6,r7
8000a302:	0a 9c       	mov	r12,r5
8000a304:	89 27       	st.w	r4[0x8],r7
8000a306:	8f 18       	st.w	r7[0x4],r8
8000a308:	fe b0 f3 3c 	rcall	80008980 <__malloc_unlock>
8000a30c:	ec cc ff f8 	sub	r12,r6,-8
8000a310:	d8 32       	popm	r0-r7,pc
8000a312:	d7 03       	nop

8000a314 <memcmp>:
8000a314:	d4 01       	pushm	lr
8000a316:	30 08       	mov	r8,0
8000a318:	c0 d8       	rjmp	8000a332 <memcmp+0x1e>
8000a31a:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a31e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a322:	20 1a       	sub	r10,1
8000a324:	2f f8       	sub	r8,-1
8000a326:	f2 0e 18 00 	cp.b	lr,r9
8000a32a:	c0 40       	breq	8000a332 <memcmp+0x1e>
8000a32c:	fc 09 01 0c 	sub	r12,lr,r9
8000a330:	d8 02       	popm	pc
8000a332:	58 0a       	cp.w	r10,0
8000a334:	cf 31       	brne	8000a31a <memcmp+0x6>
8000a336:	14 9c       	mov	r12,r10
8000a338:	d8 02       	popm	pc

8000a33a <memcpy>:
8000a33a:	58 8a       	cp.w	r10,8
8000a33c:	c2 f5       	brlt	8000a39a <memcpy+0x60>
8000a33e:	f9 eb 10 09 	or	r9,r12,r11
8000a342:	e2 19 00 03 	andl	r9,0x3,COH
8000a346:	e0 81 00 97 	brne	8000a474 <memcpy+0x13a>
8000a34a:	e0 4a 00 20 	cp.w	r10,32
8000a34e:	c3 b4       	brge	8000a3c4 <memcpy+0x8a>
8000a350:	f4 08 14 02 	asr	r8,r10,0x2
8000a354:	f0 09 11 08 	rsub	r9,r8,8
8000a358:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a35c:	76 69       	ld.w	r9,r11[0x18]
8000a35e:	99 69       	st.w	r12[0x18],r9
8000a360:	76 59       	ld.w	r9,r11[0x14]
8000a362:	99 59       	st.w	r12[0x14],r9
8000a364:	76 49       	ld.w	r9,r11[0x10]
8000a366:	99 49       	st.w	r12[0x10],r9
8000a368:	76 39       	ld.w	r9,r11[0xc]
8000a36a:	99 39       	st.w	r12[0xc],r9
8000a36c:	76 29       	ld.w	r9,r11[0x8]
8000a36e:	99 29       	st.w	r12[0x8],r9
8000a370:	76 19       	ld.w	r9,r11[0x4]
8000a372:	99 19       	st.w	r12[0x4],r9
8000a374:	76 09       	ld.w	r9,r11[0x0]
8000a376:	99 09       	st.w	r12[0x0],r9
8000a378:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a37c:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a380:	e0 1a 00 03 	andl	r10,0x3
8000a384:	f4 0a 11 04 	rsub	r10,r10,4
8000a388:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a38c:	17 a9       	ld.ub	r9,r11[0x2]
8000a38e:	b0 a9       	st.b	r8[0x2],r9
8000a390:	17 99       	ld.ub	r9,r11[0x1]
8000a392:	b0 99       	st.b	r8[0x1],r9
8000a394:	17 89       	ld.ub	r9,r11[0x0]
8000a396:	b0 89       	st.b	r8[0x0],r9
8000a398:	5e fc       	retal	r12
8000a39a:	f4 0a 11 09 	rsub	r10,r10,9
8000a39e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a3a2:	17 f9       	ld.ub	r9,r11[0x7]
8000a3a4:	b8 f9       	st.b	r12[0x7],r9
8000a3a6:	17 e9       	ld.ub	r9,r11[0x6]
8000a3a8:	b8 e9       	st.b	r12[0x6],r9
8000a3aa:	17 d9       	ld.ub	r9,r11[0x5]
8000a3ac:	b8 d9       	st.b	r12[0x5],r9
8000a3ae:	17 c9       	ld.ub	r9,r11[0x4]
8000a3b0:	b8 c9       	st.b	r12[0x4],r9
8000a3b2:	17 b9       	ld.ub	r9,r11[0x3]
8000a3b4:	b8 b9       	st.b	r12[0x3],r9
8000a3b6:	17 a9       	ld.ub	r9,r11[0x2]
8000a3b8:	b8 a9       	st.b	r12[0x2],r9
8000a3ba:	17 99       	ld.ub	r9,r11[0x1]
8000a3bc:	b8 99       	st.b	r12[0x1],r9
8000a3be:	17 89       	ld.ub	r9,r11[0x0]
8000a3c0:	b8 89       	st.b	r12[0x0],r9
8000a3c2:	5e fc       	retal	r12
8000a3c4:	eb cd 40 c0 	pushm	r6-r7,lr
8000a3c8:	18 99       	mov	r9,r12
8000a3ca:	22 0a       	sub	r10,32
8000a3cc:	b7 07       	ld.d	r6,r11++
8000a3ce:	b3 26       	st.d	r9++,r6
8000a3d0:	b7 07       	ld.d	r6,r11++
8000a3d2:	b3 26       	st.d	r9++,r6
8000a3d4:	b7 07       	ld.d	r6,r11++
8000a3d6:	b3 26       	st.d	r9++,r6
8000a3d8:	b7 07       	ld.d	r6,r11++
8000a3da:	b3 26       	st.d	r9++,r6
8000a3dc:	22 0a       	sub	r10,32
8000a3de:	cf 74       	brge	8000a3cc <memcpy+0x92>
8000a3e0:	2f 0a       	sub	r10,-16
8000a3e2:	c0 65       	brlt	8000a3ee <memcpy+0xb4>
8000a3e4:	b7 07       	ld.d	r6,r11++
8000a3e6:	b3 26       	st.d	r9++,r6
8000a3e8:	b7 07       	ld.d	r6,r11++
8000a3ea:	b3 26       	st.d	r9++,r6
8000a3ec:	21 0a       	sub	r10,16
8000a3ee:	5c 3a       	neg	r10
8000a3f0:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a3f4:	d7 03       	nop
8000a3f6:	d7 03       	nop
8000a3f8:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a3fc:	f3 66 00 0e 	st.b	r9[14],r6
8000a400:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a404:	f3 66 00 0d 	st.b	r9[13],r6
8000a408:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a40c:	f3 66 00 0c 	st.b	r9[12],r6
8000a410:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a414:	f3 66 00 0b 	st.b	r9[11],r6
8000a418:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a41c:	f3 66 00 0a 	st.b	r9[10],r6
8000a420:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a424:	f3 66 00 09 	st.b	r9[9],r6
8000a428:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a42c:	f3 66 00 08 	st.b	r9[8],r6
8000a430:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a434:	f3 66 00 07 	st.b	r9[7],r6
8000a438:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a43c:	f3 66 00 06 	st.b	r9[6],r6
8000a440:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a444:	f3 66 00 05 	st.b	r9[5],r6
8000a448:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a44c:	f3 66 00 04 	st.b	r9[4],r6
8000a450:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a454:	f3 66 00 03 	st.b	r9[3],r6
8000a458:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a45c:	f3 66 00 02 	st.b	r9[2],r6
8000a460:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a464:	f3 66 00 01 	st.b	r9[1],r6
8000a468:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a46c:	f3 66 00 00 	st.b	r9[0],r6
8000a470:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a474:	20 1a       	sub	r10,1
8000a476:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a47a:	f8 0a 0b 09 	st.b	r12[r10],r9
8000a47e:	cf b1       	brne	8000a474 <memcpy+0x13a>
8000a480:	5e fc       	retal	r12

8000a482 <memset>:
8000a482:	18 98       	mov	r8,r12
8000a484:	c0 38       	rjmp	8000a48a <memset+0x8>
8000a486:	10 cb       	st.b	r8++,r11
8000a488:	20 1a       	sub	r10,1
8000a48a:	58 0a       	cp.w	r10,0
8000a48c:	cf d1       	brne	8000a486 <memset+0x4>
8000a48e:	5e fc       	retal	r12

8000a490 <_realloc_r>:
8000a490:	d4 31       	pushm	r0-r7,lr
8000a492:	20 1d       	sub	sp,4
8000a494:	16 94       	mov	r4,r11
8000a496:	18 92       	mov	r2,r12
8000a498:	14 9b       	mov	r11,r10
8000a49a:	58 04       	cp.w	r4,0
8000a49c:	c0 51       	brne	8000a4a6 <_realloc_r+0x16>
8000a49e:	fe b0 fd 1f 	rcall	80009edc <_malloc_r>
8000a4a2:	18 95       	mov	r5,r12
8000a4a4:	c5 39       	rjmp	8000a74a <_realloc_r+0x2ba>
8000a4a6:	50 0a       	stdsp	sp[0x0],r10
8000a4a8:	fe b0 f2 66 	rcall	80008974 <__malloc_lock>
8000a4ac:	40 0b       	lddsp	r11,sp[0x0]
8000a4ae:	f6 c8 ff f5 	sub	r8,r11,-11
8000a4b2:	e8 c1 00 08 	sub	r1,r4,8
8000a4b6:	10 96       	mov	r6,r8
8000a4b8:	62 1c       	ld.w	r12,r1[0x4]
8000a4ba:	e0 16 ff f8 	andl	r6,0xfff8
8000a4be:	59 68       	cp.w	r8,22
8000a4c0:	f9 b6 08 10 	movls	r6,16
8000a4c4:	16 36       	cp.w	r6,r11
8000a4c6:	5f 38       	srlo	r8
8000a4c8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000a4cc:	c0 50       	breq	8000a4d6 <_realloc_r+0x46>
8000a4ce:	30 c8       	mov	r8,12
8000a4d0:	30 05       	mov	r5,0
8000a4d2:	85 38       	st.w	r2[0xc],r8
8000a4d4:	c3 b9       	rjmp	8000a74a <_realloc_r+0x2ba>
8000a4d6:	18 90       	mov	r0,r12
8000a4d8:	e0 10 ff fc 	andl	r0,0xfffc
8000a4dc:	0c 30       	cp.w	r0,r6
8000a4de:	e0 84 01 0b 	brge	8000a6f4 <_realloc_r+0x264>
8000a4e2:	e0 68 05 38 	mov	r8,1336
8000a4e6:	e2 00 00 09 	add	r9,r1,r0
8000a4ea:	70 25       	ld.w	r5,r8[0x8]
8000a4ec:	0a 39       	cp.w	r9,r5
8000a4ee:	c0 90       	breq	8000a500 <_realloc_r+0x70>
8000a4f0:	72 1a       	ld.w	r10,r9[0x4]
8000a4f2:	a1 ca       	cbr	r10,0x0
8000a4f4:	f2 0a 00 0a 	add	r10,r9,r10
8000a4f8:	74 1a       	ld.w	r10,r10[0x4]
8000a4fa:	ed ba 00 00 	bld	r10,0x0
8000a4fe:	c2 20       	breq	8000a542 <_realloc_r+0xb2>
8000a500:	72 1a       	ld.w	r10,r9[0x4]
8000a502:	e0 1a ff fc 	andl	r10,0xfffc
8000a506:	f4 00 00 03 	add	r3,r10,r0
8000a50a:	0a 39       	cp.w	r9,r5
8000a50c:	c1 31       	brne	8000a532 <_realloc_r+0xa2>
8000a50e:	ec c7 ff f0 	sub	r7,r6,-16
8000a512:	0e 33       	cp.w	r3,r7
8000a514:	c1 95       	brlt	8000a546 <_realloc_r+0xb6>
8000a516:	e2 06 00 09 	add	r9,r1,r6
8000a51a:	0c 13       	sub	r3,r6
8000a51c:	a1 a3       	sbr	r3,0x0
8000a51e:	93 13       	st.w	r9[0x4],r3
8000a520:	91 29       	st.w	r8[0x8],r9
8000a522:	04 9c       	mov	r12,r2
8000a524:	62 18       	ld.w	r8,r1[0x4]
8000a526:	08 95       	mov	r5,r4
8000a528:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a52c:	10 46       	or	r6,r8
8000a52e:	83 16       	st.w	r1[0x4],r6
8000a530:	c0 b9       	rjmp	8000a746 <_realloc_r+0x2b6>
8000a532:	0c 33       	cp.w	r3,r6
8000a534:	c0 95       	brlt	8000a546 <_realloc_r+0xb6>
8000a536:	72 28       	ld.w	r8,r9[0x8]
8000a538:	02 97       	mov	r7,r1
8000a53a:	72 39       	ld.w	r9,r9[0xc]
8000a53c:	93 28       	st.w	r9[0x8],r8
8000a53e:	91 39       	st.w	r8[0xc],r9
8000a540:	cd c8       	rjmp	8000a6f8 <_realloc_r+0x268>
8000a542:	30 0a       	mov	r10,0
8000a544:	14 99       	mov	r9,r10
8000a546:	ed bc 00 00 	bld	r12,0x0
8000a54a:	e0 80 00 95 	breq	8000a674 <_realloc_r+0x1e4>
8000a54e:	62 07       	ld.w	r7,r1[0x0]
8000a550:	e2 07 01 07 	sub	r7,r1,r7
8000a554:	6e 1c       	ld.w	r12,r7[0x4]
8000a556:	e0 1c ff fc 	andl	r12,0xfffc
8000a55a:	58 09       	cp.w	r9,0
8000a55c:	c5 60       	breq	8000a608 <_realloc_r+0x178>
8000a55e:	f8 00 00 03 	add	r3,r12,r0
8000a562:	0a 39       	cp.w	r9,r5
8000a564:	c4 81       	brne	8000a5f4 <_realloc_r+0x164>
8000a566:	14 03       	add	r3,r10
8000a568:	ec c9 ff f0 	sub	r9,r6,-16
8000a56c:	12 33       	cp.w	r3,r9
8000a56e:	c4 d5       	brlt	8000a608 <_realloc_r+0x178>
8000a570:	6e 3a       	ld.w	r10,r7[0xc]
8000a572:	6e 29       	ld.w	r9,r7[0x8]
8000a574:	95 29       	st.w	r10[0x8],r9
8000a576:	93 3a       	st.w	r9[0xc],r10
8000a578:	ee c5 ff f8 	sub	r5,r7,-8
8000a57c:	e0 ca 00 04 	sub	r10,r0,4
8000a580:	e0 4a 00 24 	cp.w	r10,36
8000a584:	e0 8b 00 25 	brhi	8000a5ce <_realloc_r+0x13e>
8000a588:	0a 99       	mov	r9,r5
8000a58a:	59 3a       	cp.w	r10,19
8000a58c:	e0 88 00 1a 	brls	8000a5c0 <_realloc_r+0x130>
8000a590:	09 09       	ld.w	r9,r4++
8000a592:	8b 09       	st.w	r5[0x0],r9
8000a594:	09 09       	ld.w	r9,r4++
8000a596:	8f 39       	st.w	r7[0xc],r9
8000a598:	ee c9 ff f0 	sub	r9,r7,-16
8000a59c:	59 ba       	cp.w	r10,27
8000a59e:	e0 88 00 11 	brls	8000a5c0 <_realloc_r+0x130>
8000a5a2:	09 0b       	ld.w	r11,r4++
8000a5a4:	93 0b       	st.w	r9[0x0],r11
8000a5a6:	09 09       	ld.w	r9,r4++
8000a5a8:	8f 59       	st.w	r7[0x14],r9
8000a5aa:	ee c9 ff e8 	sub	r9,r7,-24
8000a5ae:	e0 4a 00 24 	cp.w	r10,36
8000a5b2:	c0 71       	brne	8000a5c0 <_realloc_r+0x130>
8000a5b4:	09 0a       	ld.w	r10,r4++
8000a5b6:	93 0a       	st.w	r9[0x0],r10
8000a5b8:	ee c9 ff e0 	sub	r9,r7,-32
8000a5bc:	09 0a       	ld.w	r10,r4++
8000a5be:	8f 7a       	st.w	r7[0x1c],r10
8000a5c0:	09 0a       	ld.w	r10,r4++
8000a5c2:	12 aa       	st.w	r9++,r10
8000a5c4:	68 0a       	ld.w	r10,r4[0x0]
8000a5c6:	93 0a       	st.w	r9[0x0],r10
8000a5c8:	68 1a       	ld.w	r10,r4[0x4]
8000a5ca:	93 1a       	st.w	r9[0x4],r10
8000a5cc:	c0 78       	rjmp	8000a5da <_realloc_r+0x14a>
8000a5ce:	50 08       	stdsp	sp[0x0],r8
8000a5d0:	08 9b       	mov	r11,r4
8000a5d2:	0a 9c       	mov	r12,r5
8000a5d4:	e0 a0 1e 35 	rcall	8000e23e <memmove>
8000a5d8:	40 08       	lddsp	r8,sp[0x0]
8000a5da:	ee 06 00 09 	add	r9,r7,r6
8000a5de:	0c 13       	sub	r3,r6
8000a5e0:	a1 a3       	sbr	r3,0x0
8000a5e2:	93 13       	st.w	r9[0x4],r3
8000a5e4:	91 29       	st.w	r8[0x8],r9
8000a5e6:	04 9c       	mov	r12,r2
8000a5e8:	6e 18       	ld.w	r8,r7[0x4]
8000a5ea:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a5ee:	10 46       	or	r6,r8
8000a5f0:	8f 16       	st.w	r7[0x4],r6
8000a5f2:	ca a8       	rjmp	8000a746 <_realloc_r+0x2b6>
8000a5f4:	14 03       	add	r3,r10
8000a5f6:	0c 33       	cp.w	r3,r6
8000a5f8:	c0 85       	brlt	8000a608 <_realloc_r+0x178>
8000a5fa:	72 28       	ld.w	r8,r9[0x8]
8000a5fc:	72 39       	ld.w	r9,r9[0xc]
8000a5fe:	93 28       	st.w	r9[0x8],r8
8000a600:	91 39       	st.w	r8[0xc],r9
8000a602:	6e 28       	ld.w	r8,r7[0x8]
8000a604:	6e 39       	ld.w	r9,r7[0xc]
8000a606:	c0 78       	rjmp	8000a614 <_realloc_r+0x184>
8000a608:	f8 00 00 03 	add	r3,r12,r0
8000a60c:	0c 33       	cp.w	r3,r6
8000a60e:	c3 35       	brlt	8000a674 <_realloc_r+0x1e4>
8000a610:	6e 39       	ld.w	r9,r7[0xc]
8000a612:	6e 28       	ld.w	r8,r7[0x8]
8000a614:	93 28       	st.w	r9[0x8],r8
8000a616:	91 39       	st.w	r8[0xc],r9
8000a618:	e0 ca 00 04 	sub	r10,r0,4
8000a61c:	ee cc ff f8 	sub	r12,r7,-8
8000a620:	e0 4a 00 24 	cp.w	r10,36
8000a624:	e0 8b 00 24 	brhi	8000a66c <_realloc_r+0x1dc>
8000a628:	59 3a       	cp.w	r10,19
8000a62a:	e0 88 00 1a 	brls	8000a65e <_realloc_r+0x1ce>
8000a62e:	09 08       	ld.w	r8,r4++
8000a630:	99 08       	st.w	r12[0x0],r8
8000a632:	09 08       	ld.w	r8,r4++
8000a634:	8f 38       	st.w	r7[0xc],r8
8000a636:	ee cc ff f0 	sub	r12,r7,-16
8000a63a:	59 ba       	cp.w	r10,27
8000a63c:	e0 88 00 11 	brls	8000a65e <_realloc_r+0x1ce>
8000a640:	09 08       	ld.w	r8,r4++
8000a642:	99 08       	st.w	r12[0x0],r8
8000a644:	09 08       	ld.w	r8,r4++
8000a646:	8f 58       	st.w	r7[0x14],r8
8000a648:	ee cc ff e8 	sub	r12,r7,-24
8000a64c:	e0 4a 00 24 	cp.w	r10,36
8000a650:	c0 71       	brne	8000a65e <_realloc_r+0x1ce>
8000a652:	09 08       	ld.w	r8,r4++
8000a654:	99 08       	st.w	r12[0x0],r8
8000a656:	ee cc ff e0 	sub	r12,r7,-32
8000a65a:	09 08       	ld.w	r8,r4++
8000a65c:	8f 78       	st.w	r7[0x1c],r8
8000a65e:	09 08       	ld.w	r8,r4++
8000a660:	18 a8       	st.w	r12++,r8
8000a662:	68 08       	ld.w	r8,r4[0x0]
8000a664:	99 08       	st.w	r12[0x0],r8
8000a666:	68 18       	ld.w	r8,r4[0x4]
8000a668:	99 18       	st.w	r12[0x4],r8
8000a66a:	c4 78       	rjmp	8000a6f8 <_realloc_r+0x268>
8000a66c:	08 9b       	mov	r11,r4
8000a66e:	e0 a0 1d e8 	rcall	8000e23e <memmove>
8000a672:	c4 38       	rjmp	8000a6f8 <_realloc_r+0x268>
8000a674:	04 9c       	mov	r12,r2
8000a676:	fe b0 fc 33 	rcall	80009edc <_malloc_r>
8000a67a:	18 95       	mov	r5,r12
8000a67c:	c3 a0       	breq	8000a6f0 <_realloc_r+0x260>
8000a67e:	62 18       	ld.w	r8,r1[0x4]
8000a680:	f8 c9 00 08 	sub	r9,r12,8
8000a684:	a1 c8       	cbr	r8,0x0
8000a686:	e2 08 00 08 	add	r8,r1,r8
8000a68a:	10 39       	cp.w	r9,r8
8000a68c:	c0 71       	brne	8000a69a <_realloc_r+0x20a>
8000a68e:	72 13       	ld.w	r3,r9[0x4]
8000a690:	02 97       	mov	r7,r1
8000a692:	e0 13 ff fc 	andl	r3,0xfffc
8000a696:	00 03       	add	r3,r0
8000a698:	c3 08       	rjmp	8000a6f8 <_realloc_r+0x268>
8000a69a:	e0 ca 00 04 	sub	r10,r0,4
8000a69e:	e0 4a 00 24 	cp.w	r10,36
8000a6a2:	e0 8b 00 20 	brhi	8000a6e2 <_realloc_r+0x252>
8000a6a6:	08 99       	mov	r9,r4
8000a6a8:	18 98       	mov	r8,r12
8000a6aa:	59 3a       	cp.w	r10,19
8000a6ac:	e0 88 00 14 	brls	8000a6d4 <_realloc_r+0x244>
8000a6b0:	13 0b       	ld.w	r11,r9++
8000a6b2:	10 ab       	st.w	r8++,r11
8000a6b4:	13 0b       	ld.w	r11,r9++
8000a6b6:	10 ab       	st.w	r8++,r11
8000a6b8:	59 ba       	cp.w	r10,27
8000a6ba:	e0 88 00 0d 	brls	8000a6d4 <_realloc_r+0x244>
8000a6be:	13 0b       	ld.w	r11,r9++
8000a6c0:	10 ab       	st.w	r8++,r11
8000a6c2:	13 0b       	ld.w	r11,r9++
8000a6c4:	10 ab       	st.w	r8++,r11
8000a6c6:	e0 4a 00 24 	cp.w	r10,36
8000a6ca:	c0 51       	brne	8000a6d4 <_realloc_r+0x244>
8000a6cc:	13 0a       	ld.w	r10,r9++
8000a6ce:	10 aa       	st.w	r8++,r10
8000a6d0:	13 0a       	ld.w	r10,r9++
8000a6d2:	10 aa       	st.w	r8++,r10
8000a6d4:	13 0a       	ld.w	r10,r9++
8000a6d6:	10 aa       	st.w	r8++,r10
8000a6d8:	72 0a       	ld.w	r10,r9[0x0]
8000a6da:	91 0a       	st.w	r8[0x0],r10
8000a6dc:	72 19       	ld.w	r9,r9[0x4]
8000a6de:	91 19       	st.w	r8[0x4],r9
8000a6e0:	c0 48       	rjmp	8000a6e8 <_realloc_r+0x258>
8000a6e2:	08 9b       	mov	r11,r4
8000a6e4:	e0 a0 1d ad 	rcall	8000e23e <memmove>
8000a6e8:	08 9b       	mov	r11,r4
8000a6ea:	04 9c       	mov	r12,r2
8000a6ec:	e0 a0 1b 06 	rcall	8000dcf8 <_free_r>
8000a6f0:	04 9c       	mov	r12,r2
8000a6f2:	c2 a8       	rjmp	8000a746 <_realloc_r+0x2b6>
8000a6f4:	00 93       	mov	r3,r0
8000a6f6:	02 97       	mov	r7,r1
8000a6f8:	e6 06 01 09 	sub	r9,r3,r6
8000a6fc:	6e 18       	ld.w	r8,r7[0x4]
8000a6fe:	58 f9       	cp.w	r9,15
8000a700:	e0 88 00 16 	brls	8000a72c <_realloc_r+0x29c>
8000a704:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a708:	ed e8 10 08 	or	r8,r6,r8
8000a70c:	8f 18       	st.w	r7[0x4],r8
8000a70e:	12 98       	mov	r8,r9
8000a710:	a1 a8       	sbr	r8,0x0
8000a712:	ee 06 00 0b 	add	r11,r7,r6
8000a716:	f6 09 00 09 	add	r9,r11,r9
8000a71a:	97 18       	st.w	r11[0x4],r8
8000a71c:	72 18       	ld.w	r8,r9[0x4]
8000a71e:	a1 a8       	sbr	r8,0x0
8000a720:	2f 8b       	sub	r11,-8
8000a722:	93 18       	st.w	r9[0x4],r8
8000a724:	04 9c       	mov	r12,r2
8000a726:	e0 a0 1a e9 	rcall	8000dcf8 <_free_r>
8000a72a:	c0 b8       	rjmp	8000a740 <_realloc_r+0x2b0>
8000a72c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a730:	e7 e8 10 08 	or	r8,r3,r8
8000a734:	8f 18       	st.w	r7[0x4],r8
8000a736:	ee 03 00 03 	add	r3,r7,r3
8000a73a:	66 18       	ld.w	r8,r3[0x4]
8000a73c:	a1 a8       	sbr	r8,0x0
8000a73e:	87 18       	st.w	r3[0x4],r8
8000a740:	04 9c       	mov	r12,r2
8000a742:	ee c5 ff f8 	sub	r5,r7,-8
8000a746:	fe b0 f1 1d 	rcall	80008980 <__malloc_unlock>
8000a74a:	0a 9c       	mov	r12,r5
8000a74c:	2f fd       	sub	sp,-4
8000a74e:	d8 32       	popm	r0-r7,pc

8000a750 <_sbrk_r>:
8000a750:	d4 21       	pushm	r4-r7,lr
8000a752:	30 08       	mov	r8,0
8000a754:	18 97       	mov	r7,r12
8000a756:	e0 66 46 20 	mov	r6,17952
8000a75a:	16 9c       	mov	r12,r11
8000a75c:	8d 08       	st.w	r6[0x0],r8
8000a75e:	c1 1d       	rcall	8000a980 <_sbrk>
8000a760:	5b fc       	cp.w	r12,-1
8000a762:	c0 51       	brne	8000a76c <_sbrk_r+0x1c>
8000a764:	6c 08       	ld.w	r8,r6[0x0]
8000a766:	58 08       	cp.w	r8,0
8000a768:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a76c:	d8 22       	popm	r4-r7,pc
8000a76e:	d7 03       	nop

8000a770 <sprintf>:
8000a770:	d4 01       	pushm	lr
8000a772:	21 7d       	sub	sp,92
8000a774:	e0 68 ff ff 	mov	r8,65535
8000a778:	ea 18 7f ff 	orh	r8,0x7fff
8000a77c:	50 58       	stdsp	sp[0x14],r8
8000a77e:	50 28       	stdsp	sp[0x8],r8
8000a780:	e0 68 02 08 	mov	r8,520
8000a784:	ba 68       	st.h	sp[0xc],r8
8000a786:	3f f8       	mov	r8,-1
8000a788:	ba 78       	st.h	sp[0xe],r8
8000a78a:	e0 68 0a 38 	mov	r8,2616
8000a78e:	50 4c       	stdsp	sp[0x10],r12
8000a790:	16 9a       	mov	r10,r11
8000a792:	50 0c       	stdsp	sp[0x0],r12
8000a794:	fa c9 ff a0 	sub	r9,sp,-96
8000a798:	70 0c       	ld.w	r12,r8[0x0]
8000a79a:	1a 9b       	mov	r11,sp
8000a79c:	e0 a0 02 ac 	rcall	8000acf4 <_vfprintf_r>
8000a7a0:	30 09       	mov	r9,0
8000a7a2:	40 08       	lddsp	r8,sp[0x0]
8000a7a4:	b0 89       	st.b	r8[0x0],r9
8000a7a6:	2e 9d       	sub	sp,-92
8000a7a8:	d8 02       	popm	pc
8000a7aa:	d7 03       	nop

8000a7ac <strcpy>:
8000a7ac:	30 08       	mov	r8,0
8000a7ae:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a7b2:	f8 08 0b 09 	st.b	r12[r8],r9
8000a7b6:	2f f8       	sub	r8,-1
8000a7b8:	58 09       	cp.w	r9,0
8000a7ba:	cf a1       	brne	8000a7ae <strcpy+0x2>
8000a7bc:	5e fc       	retal	r12

8000a7be <strlen>:
8000a7be:	30 09       	mov	r9,0
8000a7c0:	18 98       	mov	r8,r12
8000a7c2:	c0 28       	rjmp	8000a7c6 <strlen+0x8>
8000a7c4:	2f f8       	sub	r8,-1
8000a7c6:	11 8a       	ld.ub	r10,r8[0x0]
8000a7c8:	f2 0a 18 00 	cp.b	r10,r9
8000a7cc:	cf c1       	brne	8000a7c4 <strlen+0x6>
8000a7ce:	f0 0c 01 0c 	sub	r12,r8,r12
8000a7d2:	5e fc       	retal	r12

8000a7d4 <strncpy>:
8000a7d4:	30 08       	mov	r8,0
8000a7d6:	10 3a       	cp.w	r10,r8
8000a7d8:	5e 0c       	reteq	r12
8000a7da:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a7de:	f8 08 0b 09 	st.b	r12[r8],r9
8000a7e2:	2f f8       	sub	r8,-1
8000a7e4:	58 09       	cp.w	r9,0
8000a7e6:	cf 81       	brne	8000a7d6 <strncpy+0x2>
8000a7e8:	10 3a       	cp.w	r10,r8
8000a7ea:	5e 0c       	reteq	r12
8000a7ec:	f8 08 0b 09 	st.b	r12[r8],r9
8000a7f0:	2f f8       	sub	r8,-1
8000a7f2:	cf bb       	rjmp	8000a7e8 <strncpy+0x14>

8000a7f4 <strtok>:
8000a7f4:	d4 21       	pushm	r4-r7,lr
8000a7f6:	20 1d       	sub	sp,4
8000a7f8:	e0 65 0a 38 	mov	r5,2616
8000a7fc:	18 97       	mov	r7,r12
8000a7fe:	6a 04       	ld.w	r4,r5[0x0]
8000a800:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000a804:	58 06       	cp.w	r6,0
8000a806:	c3 51       	brne	8000a870 <strtok+0x7c>
8000a808:	50 0b       	stdsp	sp[0x0],r11
8000a80a:	35 0c       	mov	r12,80
8000a80c:	fe b0 fb 60 	rcall	80009ecc <malloc>
8000a810:	6a 08       	ld.w	r8,r5[0x0]
8000a812:	e9 4c 00 e8 	st.w	r4[232],r12
8000a816:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a81a:	93 26       	st.w	r9[0x8],r6
8000a81c:	93 06       	st.w	r9[0x0],r6
8000a81e:	93 16       	st.w	r9[0x4],r6
8000a820:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a824:	93 46       	st.w	r9[0x10],r6
8000a826:	93 36       	st.w	r9[0xc],r6
8000a828:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a82c:	93 66       	st.w	r9[0x18],r6
8000a82e:	93 56       	st.w	r9[0x14],r6
8000a830:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a834:	93 b6       	st.w	r9[0x2c],r6
8000a836:	93 a6       	st.w	r9[0x28],r6
8000a838:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a83c:	93 d6       	st.w	r9[0x34],r6
8000a83e:	93 c6       	st.w	r9[0x30],r6
8000a840:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a844:	93 f6       	st.w	r9[0x3c],r6
8000a846:	93 e6       	st.w	r9[0x38],r6
8000a848:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a84c:	f3 46 00 44 	st.w	r9[68],r6
8000a850:	f3 46 00 40 	st.w	r9[64],r6
8000a854:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a858:	f3 46 00 4c 	st.w	r9[76],r6
8000a85c:	f3 46 00 48 	st.w	r9[72],r6
8000a860:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a864:	f3 66 00 1c 	st.b	r9[28],r6
8000a868:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000a86c:	40 0b       	lddsp	r11,sp[0x0]
8000a86e:	91 96       	st.w	r8[0x24],r6
8000a870:	e0 68 0a 38 	mov	r8,2616
8000a874:	70 08       	ld.w	r8,r8[0x0]
8000a876:	0e 9c       	mov	r12,r7
8000a878:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000a87c:	30 19       	mov	r9,1
8000a87e:	c0 3c       	rcall	8000a884 <__strtok_r>
8000a880:	2f fd       	sub	sp,-4
8000a882:	d8 22       	popm	r4-r7,pc

8000a884 <__strtok_r>:
8000a884:	d4 21       	pushm	r4-r7,lr
8000a886:	58 0c       	cp.w	r12,0
8000a888:	c0 41       	brne	8000a890 <__strtok_r+0xc>
8000a88a:	74 0c       	ld.w	r12,r10[0x0]
8000a88c:	58 0c       	cp.w	r12,0
8000a88e:	c2 90       	breq	8000a8e0 <__strtok_r+0x5c>
8000a890:	18 98       	mov	r8,r12
8000a892:	16 97       	mov	r7,r11
8000a894:	11 3e       	ld.ub	lr,r8++
8000a896:	c0 a8       	rjmp	8000a8aa <__strtok_r+0x26>
8000a898:	0c 3e       	cp.w	lr,r6
8000a89a:	c0 81       	brne	8000a8aa <__strtok_r+0x26>
8000a89c:	58 09       	cp.w	r9,0
8000a89e:	c0 30       	breq	8000a8a4 <__strtok_r+0x20>
8000a8a0:	10 9c       	mov	r12,r8
8000a8a2:	cf 7b       	rjmp	8000a890 <__strtok_r+0xc>
8000a8a4:	95 08       	st.w	r10[0x0],r8
8000a8a6:	b8 89       	st.b	r12[0x0],r9
8000a8a8:	d8 22       	popm	r4-r7,pc
8000a8aa:	0f 36       	ld.ub	r6,r7++
8000a8ac:	58 06       	cp.w	r6,0
8000a8ae:	cf 51       	brne	8000a898 <__strtok_r+0x14>
8000a8b0:	58 0e       	cp.w	lr,0
8000a8b2:	c0 51       	brne	8000a8bc <__strtok_r+0x38>
8000a8b4:	95 0e       	st.w	r10[0x0],lr
8000a8b6:	1c 9c       	mov	r12,lr
8000a8b8:	d8 22       	popm	r4-r7,pc
8000a8ba:	12 98       	mov	r8,r9
8000a8bc:	10 99       	mov	r9,r8
8000a8be:	16 97       	mov	r7,r11
8000a8c0:	13 3e       	ld.ub	lr,r9++
8000a8c2:	0f 36       	ld.ub	r6,r7++
8000a8c4:	1c 36       	cp.w	r6,lr
8000a8c6:	c0 a1       	brne	8000a8da <__strtok_r+0x56>
8000a8c8:	58 0e       	cp.w	lr,0
8000a8ca:	fc 09 17 00 	moveq	r9,lr
8000a8ce:	f9 bb 01 00 	movne	r11,0
8000a8d2:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000a8d6:	95 09       	st.w	r10[0x0],r9
8000a8d8:	d8 22       	popm	r4-r7,pc
8000a8da:	58 06       	cp.w	r6,0
8000a8dc:	cf 31       	brne	8000a8c2 <__strtok_r+0x3e>
8000a8de:	ce eb       	rjmp	8000a8ba <__strtok_r+0x36>
8000a8e0:	d8 22       	popm	r4-r7,pc
8000a8e2:	d7 03       	nop

8000a8e4 <_close>:
8000a8e4:	30 28       	mov	r8,2
8000a8e6:	d6 73       	breakpoint
8000a8e8:	3f fc       	mov	r12,-1
8000a8ea:	35 8b       	mov	r11,88
8000a8ec:	58 0c       	cp.w	r12,0
8000a8ee:	5e 4c       	retge	r12
8000a8f0:	e0 6a 46 20 	mov	r10,17952
8000a8f4:	95 0b       	st.w	r10[0x0],r11
8000a8f6:	5e fc       	retal	r12

8000a8f8 <_lseek>:
8000a8f8:	30 58       	mov	r8,5
8000a8fa:	d6 73       	breakpoint
8000a8fc:	3f fc       	mov	r12,-1
8000a8fe:	35 8b       	mov	r11,88
8000a900:	58 0c       	cp.w	r12,0
8000a902:	5e 4c       	retge	r12
8000a904:	e0 6a 46 20 	mov	r10,17952
8000a908:	95 0b       	st.w	r10[0x0],r11
8000a90a:	5e fc       	retal	r12

8000a90c <isatty>:
8000a90c:	30 b8       	mov	r8,11
8000a90e:	d6 73       	breakpoint
8000a910:	3f fc       	mov	r12,-1
8000a912:	35 8b       	mov	r11,88
8000a914:	58 0c       	cp.w	r12,0
8000a916:	5e 4c       	retge	r12
8000a918:	e0 6a 46 20 	mov	r10,17952
8000a91c:	95 0b       	st.w	r10[0x0],r11
8000a91e:	5e fc       	retal	r12

8000a920 <_fstat_host>:
8000a920:	30 98       	mov	r8,9
8000a922:	d6 73       	breakpoint
8000a924:	3f fc       	mov	r12,-1
8000a926:	35 8b       	mov	r11,88
8000a928:	58 0c       	cp.w	r12,0
8000a92a:	5e 4c       	retge	r12
8000a92c:	e0 6a 46 20 	mov	r10,17952
8000a930:	95 0b       	st.w	r10[0x0],r11
8000a932:	5e fc       	retal	r12

8000a934 <_fstat>:
8000a934:	d4 21       	pushm	r4-r7,lr
8000a936:	21 0d       	sub	sp,64
8000a938:	16 97       	mov	r7,r11
8000a93a:	1a 9b       	mov	r11,sp
8000a93c:	cf 2f       	rcall	8000a920 <_fstat_host>
8000a93e:	c0 34       	brge	8000a944 <_fstat+0x10>
8000a940:	3f fc       	mov	r12,-1
8000a942:	c1 c8       	rjmp	8000a97a <_fstat+0x46>
8000a944:	40 08       	lddsp	r8,sp[0x0]
8000a946:	ae 08       	st.h	r7[0x0],r8
8000a948:	40 18       	lddsp	r8,sp[0x4]
8000a94a:	ae 18       	st.h	r7[0x2],r8
8000a94c:	40 28       	lddsp	r8,sp[0x8]
8000a94e:	8f 18       	st.w	r7[0x4],r8
8000a950:	40 38       	lddsp	r8,sp[0xc]
8000a952:	ae 48       	st.h	r7[0x8],r8
8000a954:	40 48       	lddsp	r8,sp[0x10]
8000a956:	ae 58       	st.h	r7[0xa],r8
8000a958:	40 58       	lddsp	r8,sp[0x14]
8000a95a:	ae 68       	st.h	r7[0xc],r8
8000a95c:	40 68       	lddsp	r8,sp[0x18]
8000a95e:	ae 78       	st.h	r7[0xe],r8
8000a960:	40 88       	lddsp	r8,sp[0x20]
8000a962:	8f 48       	st.w	r7[0x10],r8
8000a964:	40 a8       	lddsp	r8,sp[0x28]
8000a966:	8f b8       	st.w	r7[0x2c],r8
8000a968:	40 c8       	lddsp	r8,sp[0x30]
8000a96a:	8f c8       	st.w	r7[0x30],r8
8000a96c:	40 d8       	lddsp	r8,sp[0x34]
8000a96e:	8f 58       	st.w	r7[0x14],r8
8000a970:	40 e8       	lddsp	r8,sp[0x38]
8000a972:	30 0c       	mov	r12,0
8000a974:	8f 78       	st.w	r7[0x1c],r8
8000a976:	40 f8       	lddsp	r8,sp[0x3c]
8000a978:	8f 98       	st.w	r7[0x24],r8
8000a97a:	2f 0d       	sub	sp,-64
8000a97c:	d8 22       	popm	r4-r7,pc
8000a97e:	d7 03       	nop

8000a980 <_sbrk>:
8000a980:	d4 01       	pushm	lr
8000a982:	e0 68 12 c0 	mov	r8,4800
8000a986:	70 09       	ld.w	r9,r8[0x0]
8000a988:	58 09       	cp.w	r9,0
8000a98a:	c0 41       	brne	8000a992 <_sbrk+0x12>
8000a98c:	e0 69 46 28 	mov	r9,17960
8000a990:	91 09       	st.w	r8[0x0],r9
8000a992:	e0 69 12 c0 	mov	r9,4800
8000a996:	e0 7a 70 00 	mov	r10,94208
8000a99a:	72 08       	ld.w	r8,r9[0x0]
8000a99c:	f0 0c 00 0c 	add	r12,r8,r12
8000a9a0:	14 3c       	cp.w	r12,r10
8000a9a2:	e0 8b 00 04 	brhi	8000a9aa <_sbrk+0x2a>
8000a9a6:	93 0c       	st.w	r9[0x0],r12
8000a9a8:	c0 68       	rjmp	8000a9b4 <_sbrk+0x34>
8000a9aa:	e0 a0 18 2b 	rcall	8000da00 <__errno>
8000a9ae:	30 c8       	mov	r8,12
8000a9b0:	99 08       	st.w	r12[0x0],r8
8000a9b2:	3f f8       	mov	r8,-1
8000a9b4:	10 9c       	mov	r12,r8
8000a9b6:	d8 02       	popm	pc

8000a9b8 <get_arg>:
8000a9b8:	d4 31       	pushm	r0-r7,lr
8000a9ba:	20 8d       	sub	sp,32
8000a9bc:	fa c4 ff bc 	sub	r4,sp,-68
8000a9c0:	50 4b       	stdsp	sp[0x10],r11
8000a9c2:	68 2e       	ld.w	lr,r4[0x8]
8000a9c4:	50 58       	stdsp	sp[0x14],r8
8000a9c6:	12 96       	mov	r6,r9
8000a9c8:	7c 0b       	ld.w	r11,lr[0x0]
8000a9ca:	70 05       	ld.w	r5,r8[0x0]
8000a9cc:	50 6e       	stdsp	sp[0x18],lr
8000a9ce:	58 0b       	cp.w	r11,0
8000a9d0:	f4 0b 17 00 	moveq	r11,r10
8000a9d4:	68 03       	ld.w	r3,r4[0x0]
8000a9d6:	68 11       	ld.w	r1,r4[0x4]
8000a9d8:	40 49       	lddsp	r9,sp[0x10]
8000a9da:	30 08       	mov	r8,0
8000a9dc:	c2 e9       	rjmp	8000ac38 <get_arg+0x280>
8000a9de:	2f fb       	sub	r11,-1
8000a9e0:	32 5c       	mov	r12,37
8000a9e2:	17 8a       	ld.ub	r10,r11[0x0]
8000a9e4:	f8 0a 18 00 	cp.b	r10,r12
8000a9e8:	5f 1e       	srne	lr
8000a9ea:	f0 0a 18 00 	cp.b	r10,r8
8000a9ee:	5f 1c       	srne	r12
8000a9f0:	fd ec 00 0c 	and	r12,lr,r12
8000a9f4:	f0 0c 18 00 	cp.b	r12,r8
8000a9f8:	cf 31       	brne	8000a9de <get_arg+0x26>
8000a9fa:	58 0a       	cp.w	r10,0
8000a9fc:	e0 80 01 2b 	breq	8000ac52 <get_arg+0x29a>
8000aa00:	30 0c       	mov	r12,0
8000aa02:	3f fa       	mov	r10,-1
8000aa04:	18 90       	mov	r0,r12
8000aa06:	50 3a       	stdsp	sp[0xc],r10
8000aa08:	18 94       	mov	r4,r12
8000aa0a:	18 92       	mov	r2,r12
8000aa0c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000aa10:	16 97       	mov	r7,r11
8000aa12:	50 7c       	stdsp	sp[0x1c],r12
8000aa14:	4c ec       	lddpc	r12,8000ab4c <get_arg+0x194>
8000aa16:	0f 3a       	ld.ub	r10,r7++
8000aa18:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000aa1c:	40 7c       	lddsp	r12,sp[0x1c]
8000aa1e:	1c 0c       	add	r12,lr
8000aa20:	4c ce       	lddpc	lr,8000ab50 <get_arg+0x198>
8000aa22:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000aa26:	20 1e       	sub	lr,1
8000aa28:	50 0e       	stdsp	sp[0x0],lr
8000aa2a:	4c be       	lddpc	lr,8000ab54 <get_arg+0x19c>
8000aa2c:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000aa30:	50 7c       	stdsp	sp[0x1c],r12
8000aa32:	40 0c       	lddsp	r12,sp[0x0]
8000aa34:	58 7c       	cp.w	r12,7
8000aa36:	e0 8b 00 fa 	brhi	8000ac2a <get_arg+0x272>
8000aa3a:	4c 8e       	lddpc	lr,8000ab58 <get_arg+0x1a0>
8000aa3c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000aa40:	36 8b       	mov	r11,104
8000aa42:	f6 0a 18 00 	cp.b	r10,r11
8000aa46:	e0 80 00 f2 	breq	8000ac2a <get_arg+0x272>
8000aa4a:	37 1b       	mov	r11,113
8000aa4c:	f6 0a 18 00 	cp.b	r10,r11
8000aa50:	c0 70       	breq	8000aa5e <get_arg+0xa6>
8000aa52:	34 cb       	mov	r11,76
8000aa54:	f6 0a 18 00 	cp.b	r10,r11
8000aa58:	c0 51       	brne	8000aa62 <get_arg+0xaa>
8000aa5a:	a3 b4       	sbr	r4,0x3
8000aa5c:	ce 78       	rjmp	8000ac2a <get_arg+0x272>
8000aa5e:	a5 b4       	sbr	r4,0x5
8000aa60:	ce 58       	rjmp	8000ac2a <get_arg+0x272>
8000aa62:	08 9a       	mov	r10,r4
8000aa64:	0e 9b       	mov	r11,r7
8000aa66:	a5 aa       	sbr	r10,0x4
8000aa68:	17 3c       	ld.ub	r12,r11++
8000aa6a:	a5 b4       	sbr	r4,0x5
8000aa6c:	36 ce       	mov	lr,108
8000aa6e:	fc 0c 18 00 	cp.b	r12,lr
8000aa72:	e0 80 00 dd 	breq	8000ac2c <get_arg+0x274>
8000aa76:	14 94       	mov	r4,r10
8000aa78:	cd 98       	rjmp	8000ac2a <get_arg+0x272>
8000aa7a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000aa7e:	36 7c       	mov	r12,103
8000aa80:	f8 0a 18 00 	cp.b	r10,r12
8000aa84:	e0 8b 00 27 	brhi	8000aad2 <get_arg+0x11a>
8000aa88:	36 5b       	mov	r11,101
8000aa8a:	f6 0a 18 00 	cp.b	r10,r11
8000aa8e:	c4 82       	brcc	8000ab1e <get_arg+0x166>
8000aa90:	34 fb       	mov	r11,79
8000aa92:	f6 0a 18 00 	cp.b	r10,r11
8000aa96:	c4 80       	breq	8000ab26 <get_arg+0x16e>
8000aa98:	e0 8b 00 0c 	brhi	8000aab0 <get_arg+0xf8>
8000aa9c:	34 5b       	mov	r11,69
8000aa9e:	f6 0a 18 00 	cp.b	r10,r11
8000aaa2:	c3 e0       	breq	8000ab1e <get_arg+0x166>
8000aaa4:	34 7b       	mov	r11,71
8000aaa6:	f6 0a 18 00 	cp.b	r10,r11
8000aaaa:	c3 a0       	breq	8000ab1e <get_arg+0x166>
8000aaac:	34 4b       	mov	r11,68
8000aaae:	c0 88       	rjmp	8000aabe <get_arg+0x106>
8000aab0:	35 8b       	mov	r11,88
8000aab2:	f6 0a 18 00 	cp.b	r10,r11
8000aab6:	c2 c0       	breq	8000ab0e <get_arg+0x156>
8000aab8:	e0 8b 00 07 	brhi	8000aac6 <get_arg+0x10e>
8000aabc:	35 5b       	mov	r11,85
8000aabe:	f6 0a 18 00 	cp.b	r10,r11
8000aac2:	c3 51       	brne	8000ab2c <get_arg+0x174>
8000aac4:	c3 18       	rjmp	8000ab26 <get_arg+0x16e>
8000aac6:	36 3b       	mov	r11,99
8000aac8:	f6 0a 18 00 	cp.b	r10,r11
8000aacc:	c2 f0       	breq	8000ab2a <get_arg+0x172>
8000aace:	36 4b       	mov	r11,100
8000aad0:	c0 e8       	rjmp	8000aaec <get_arg+0x134>
8000aad2:	37 0b       	mov	r11,112
8000aad4:	f6 0a 18 00 	cp.b	r10,r11
8000aad8:	c2 50       	breq	8000ab22 <get_arg+0x16a>
8000aada:	e0 8b 00 0d 	brhi	8000aaf4 <get_arg+0x13c>
8000aade:	36 eb       	mov	r11,110
8000aae0:	f6 0a 18 00 	cp.b	r10,r11
8000aae4:	c1 f0       	breq	8000ab22 <get_arg+0x16a>
8000aae6:	e0 8b 00 14 	brhi	8000ab0e <get_arg+0x156>
8000aaea:	36 9b       	mov	r11,105
8000aaec:	f6 0a 18 00 	cp.b	r10,r11
8000aaf0:	c1 e1       	brne	8000ab2c <get_arg+0x174>
8000aaf2:	c0 e8       	rjmp	8000ab0e <get_arg+0x156>
8000aaf4:	37 5b       	mov	r11,117
8000aaf6:	f6 0a 18 00 	cp.b	r10,r11
8000aafa:	c0 a0       	breq	8000ab0e <get_arg+0x156>
8000aafc:	37 8b       	mov	r11,120
8000aafe:	f6 0a 18 00 	cp.b	r10,r11
8000ab02:	c0 60       	breq	8000ab0e <get_arg+0x156>
8000ab04:	37 3b       	mov	r11,115
8000ab06:	f6 0a 18 00 	cp.b	r10,r11
8000ab0a:	c1 11       	brne	8000ab2c <get_arg+0x174>
8000ab0c:	c0 b8       	rjmp	8000ab22 <get_arg+0x16a>
8000ab0e:	ed b4 00 04 	bld	r4,0x4
8000ab12:	c0 a0       	breq	8000ab26 <get_arg+0x16e>
8000ab14:	ed b4 00 05 	bld	r4,0x5
8000ab18:	c0 91       	brne	8000ab2a <get_arg+0x172>
8000ab1a:	30 20       	mov	r0,2
8000ab1c:	c0 88       	rjmp	8000ab2c <get_arg+0x174>
8000ab1e:	30 40       	mov	r0,4
8000ab20:	c0 68       	rjmp	8000ab2c <get_arg+0x174>
8000ab22:	30 30       	mov	r0,3
8000ab24:	c0 48       	rjmp	8000ab2c <get_arg+0x174>
8000ab26:	30 10       	mov	r0,1
8000ab28:	c0 28       	rjmp	8000ab2c <get_arg+0x174>
8000ab2a:	30 00       	mov	r0,0
8000ab2c:	40 3b       	lddsp	r11,sp[0xc]
8000ab2e:	5b fb       	cp.w	r11,-1
8000ab30:	c0 40       	breq	8000ab38 <get_arg+0x180>
8000ab32:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000ab36:	c7 a8       	rjmp	8000ac2a <get_arg+0x272>
8000ab38:	58 60       	cp.w	r0,6
8000ab3a:	e0 8b 00 78 	brhi	8000ac2a <get_arg+0x272>
8000ab3e:	6c 0a       	ld.w	r10,r6[0x0]
8000ab40:	ea cc ff ff 	sub	r12,r5,-1
8000ab44:	48 6e       	lddpc	lr,8000ab5c <get_arg+0x1a4>
8000ab46:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000ab4a:	d7 03       	nop
8000ab4c:	80 01       	ld.sh	r1,r0[0x0]
8000ab4e:	8f a0       	st.w	r7[0x28],r0
8000ab50:	80 01       	ld.sh	r1,r0[0x0]
8000ab52:	8e d8       	ld.uh	r8,r7[0xa]
8000ab54:	80 01       	ld.sh	r1,r0[0x0]
8000ab56:	8e 6c       	ld.sh	r12,r7[0xc]
8000ab58:	80 01       	ld.sh	r1,r0[0x0]
8000ab5a:	8c cc       	ld.uh	r12,r6[0x8]
8000ab5c:	80 01       	ld.sh	r1,r0[0x0]
8000ab5e:	8c ec       	ld.uh	r12,r6[0xc]
8000ab60:	f4 cb ff f8 	sub	r11,r10,-8
8000ab64:	8d 0b       	st.w	r6[0x0],r11
8000ab66:	f4 ea 00 00 	ld.d	r10,r10[0]
8000ab6a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000ab6e:	c0 f8       	rjmp	8000ab8c <get_arg+0x1d4>
8000ab70:	f4 cb ff fc 	sub	r11,r10,-4
8000ab74:	8d 0b       	st.w	r6[0x0],r11
8000ab76:	74 0a       	ld.w	r10,r10[0x0]
8000ab78:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000ab7c:	c0 88       	rjmp	8000ab8c <get_arg+0x1d4>
8000ab7e:	f4 cb ff f8 	sub	r11,r10,-8
8000ab82:	8d 0b       	st.w	r6[0x0],r11
8000ab84:	f4 ea 00 00 	ld.d	r10,r10[0]
8000ab88:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000ab8c:	0e 9b       	mov	r11,r7
8000ab8e:	18 95       	mov	r5,r12
8000ab90:	c4 e8       	rjmp	8000ac2c <get_arg+0x274>
8000ab92:	62 0a       	ld.w	r10,r1[0x0]
8000ab94:	5b fa       	cp.w	r10,-1
8000ab96:	c0 b1       	brne	8000abac <get_arg+0x1f4>
8000ab98:	50 19       	stdsp	sp[0x4],r9
8000ab9a:	50 28       	stdsp	sp[0x8],r8
8000ab9c:	e0 6a 00 80 	mov	r10,128
8000aba0:	30 0b       	mov	r11,0
8000aba2:	02 9c       	mov	r12,r1
8000aba4:	fe b0 fc 6f 	rcall	8000a482 <memset>
8000aba8:	40 28       	lddsp	r8,sp[0x8]
8000abaa:	40 19       	lddsp	r9,sp[0x4]
8000abac:	e4 cc 00 01 	sub	r12,r2,1
8000abb0:	0e 9b       	mov	r11,r7
8000abb2:	50 3c       	stdsp	sp[0xc],r12
8000abb4:	f2 0c 0c 49 	max	r9,r9,r12
8000abb8:	c3 a8       	rjmp	8000ac2c <get_arg+0x274>
8000abba:	62 0a       	ld.w	r10,r1[0x0]
8000abbc:	5b fa       	cp.w	r10,-1
8000abbe:	c0 b1       	brne	8000abd4 <get_arg+0x21c>
8000abc0:	50 19       	stdsp	sp[0x4],r9
8000abc2:	50 28       	stdsp	sp[0x8],r8
8000abc4:	e0 6a 00 80 	mov	r10,128
8000abc8:	30 0b       	mov	r11,0
8000abca:	02 9c       	mov	r12,r1
8000abcc:	fe b0 fc 5b 	rcall	8000a482 <memset>
8000abd0:	40 28       	lddsp	r8,sp[0x8]
8000abd2:	40 19       	lddsp	r9,sp[0x4]
8000abd4:	20 12       	sub	r2,1
8000abd6:	30 0a       	mov	r10,0
8000abd8:	0e 9b       	mov	r11,r7
8000abda:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000abde:	f2 02 0c 49 	max	r9,r9,r2
8000abe2:	c2 58       	rjmp	8000ac2c <get_arg+0x274>
8000abe4:	16 97       	mov	r7,r11
8000abe6:	6c 0a       	ld.w	r10,r6[0x0]
8000abe8:	f4 cb ff fc 	sub	r11,r10,-4
8000abec:	8d 0b       	st.w	r6[0x0],r11
8000abee:	74 0a       	ld.w	r10,r10[0x0]
8000abf0:	0e 9b       	mov	r11,r7
8000abf2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000abf6:	2f f5       	sub	r5,-1
8000abf8:	c1 a8       	rjmp	8000ac2c <get_arg+0x274>
8000abfa:	f4 c2 00 30 	sub	r2,r10,48
8000abfe:	c0 68       	rjmp	8000ac0a <get_arg+0x252>
8000ac00:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000ac04:	2f f7       	sub	r7,-1
8000ac06:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000ac0a:	0f 8a       	ld.ub	r10,r7[0x0]
8000ac0c:	58 0a       	cp.w	r10,0
8000ac0e:	c0 e0       	breq	8000ac2a <get_arg+0x272>
8000ac10:	23 0a       	sub	r10,48
8000ac12:	58 9a       	cp.w	r10,9
8000ac14:	fe 98 ff f6 	brls	8000ac00 <get_arg+0x248>
8000ac18:	c0 98       	rjmp	8000ac2a <get_arg+0x272>
8000ac1a:	2f f7       	sub	r7,-1
8000ac1c:	0f 8a       	ld.ub	r10,r7[0x0]
8000ac1e:	58 0a       	cp.w	r10,0
8000ac20:	c0 50       	breq	8000ac2a <get_arg+0x272>
8000ac22:	23 0a       	sub	r10,48
8000ac24:	58 9a       	cp.w	r10,9
8000ac26:	fe 98 ff fa 	brls	8000ac1a <get_arg+0x262>
8000ac2a:	0e 9b       	mov	r11,r7
8000ac2c:	40 7c       	lddsp	r12,sp[0x1c]
8000ac2e:	30 ba       	mov	r10,11
8000ac30:	f4 0c 18 00 	cp.b	r12,r10
8000ac34:	fe 91 fe ec 	brne	8000aa0c <get_arg+0x54>
8000ac38:	40 42       	lddsp	r2,sp[0x10]
8000ac3a:	17 8c       	ld.ub	r12,r11[0x0]
8000ac3c:	0a 32       	cp.w	r2,r5
8000ac3e:	5f 4a       	srge	r10
8000ac40:	f0 0c 18 00 	cp.b	r12,r8
8000ac44:	5f 1c       	srne	r12
8000ac46:	f9 ea 00 0a 	and	r10,r12,r10
8000ac4a:	f0 0a 18 00 	cp.b	r10,r8
8000ac4e:	fe 91 fe c9 	brne	8000a9e0 <get_arg+0x28>
8000ac52:	30 08       	mov	r8,0
8000ac54:	40 4e       	lddsp	lr,sp[0x10]
8000ac56:	17 8a       	ld.ub	r10,r11[0x0]
8000ac58:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000ac5c:	f0 0a 18 00 	cp.b	r10,r8
8000ac60:	fc 09 17 10 	movne	r9,lr
8000ac64:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000ac68:	06 9e       	mov	lr,r3
8000ac6a:	c2 a8       	rjmp	8000acbe <get_arg+0x306>
8000ac6c:	62 0a       	ld.w	r10,r1[0x0]
8000ac6e:	58 3a       	cp.w	r10,3
8000ac70:	c1 e0       	breq	8000acac <get_arg+0x2f4>
8000ac72:	e0 89 00 07 	brgt	8000ac80 <get_arg+0x2c8>
8000ac76:	58 1a       	cp.w	r10,1
8000ac78:	c1 a0       	breq	8000acac <get_arg+0x2f4>
8000ac7a:	58 2a       	cp.w	r10,2
8000ac7c:	c1 81       	brne	8000acac <get_arg+0x2f4>
8000ac7e:	c0 58       	rjmp	8000ac88 <get_arg+0x2d0>
8000ac80:	58 5a       	cp.w	r10,5
8000ac82:	c0 c0       	breq	8000ac9a <get_arg+0x2e2>
8000ac84:	c0 b5       	brlt	8000ac9a <get_arg+0x2e2>
8000ac86:	c1 38       	rjmp	8000acac <get_arg+0x2f4>
8000ac88:	6c 0a       	ld.w	r10,r6[0x0]
8000ac8a:	f4 cc ff f8 	sub	r12,r10,-8
8000ac8e:	8d 0c       	st.w	r6[0x0],r12
8000ac90:	f4 e2 00 00 	ld.d	r2,r10[0]
8000ac94:	f0 e3 00 00 	st.d	r8[0],r2
8000ac98:	c1 08       	rjmp	8000acb8 <get_arg+0x300>
8000ac9a:	6c 0a       	ld.w	r10,r6[0x0]
8000ac9c:	f4 cc ff f8 	sub	r12,r10,-8
8000aca0:	8d 0c       	st.w	r6[0x0],r12
8000aca2:	f4 e2 00 00 	ld.d	r2,r10[0]
8000aca6:	f0 e3 00 00 	st.d	r8[0],r2
8000acaa:	c0 78       	rjmp	8000acb8 <get_arg+0x300>
8000acac:	6c 0a       	ld.w	r10,r6[0x0]
8000acae:	f4 cc ff fc 	sub	r12,r10,-4
8000acb2:	8d 0c       	st.w	r6[0x0],r12
8000acb4:	74 0a       	ld.w	r10,r10[0x0]
8000acb6:	91 0a       	st.w	r8[0x0],r10
8000acb8:	2f f5       	sub	r5,-1
8000acba:	2f 88       	sub	r8,-8
8000acbc:	2f c1       	sub	r1,-4
8000acbe:	12 35       	cp.w	r5,r9
8000acc0:	fe 9a ff d6 	brle	8000ac6c <get_arg+0x2b4>
8000acc4:	1c 93       	mov	r3,lr
8000acc6:	40 52       	lddsp	r2,sp[0x14]
8000acc8:	40 6e       	lddsp	lr,sp[0x18]
8000acca:	85 05       	st.w	r2[0x0],r5
8000accc:	9d 0b       	st.w	lr[0x0],r11
8000acce:	40 4b       	lddsp	r11,sp[0x10]
8000acd0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000acd4:	2f 8d       	sub	sp,-32
8000acd6:	d8 32       	popm	r0-r7,pc

8000acd8 <__sprint_r>:
8000acd8:	d4 21       	pushm	r4-r7,lr
8000acda:	14 97       	mov	r7,r10
8000acdc:	74 28       	ld.w	r8,r10[0x8]
8000acde:	58 08       	cp.w	r8,0
8000ace0:	c0 41       	brne	8000ace8 <__sprint_r+0x10>
8000ace2:	95 18       	st.w	r10[0x4],r8
8000ace4:	10 9c       	mov	r12,r8
8000ace6:	d8 22       	popm	r4-r7,pc
8000ace8:	e0 a0 18 ce 	rcall	8000de84 <__sfvwrite_r>
8000acec:	30 08       	mov	r8,0
8000acee:	8f 18       	st.w	r7[0x4],r8
8000acf0:	8f 28       	st.w	r7[0x8],r8
8000acf2:	d8 22       	popm	r4-r7,pc

8000acf4 <_vfprintf_r>:
8000acf4:	d4 31       	pushm	r0-r7,lr
8000acf6:	fa cd 06 bc 	sub	sp,sp,1724
8000acfa:	51 09       	stdsp	sp[0x40],r9
8000acfc:	16 91       	mov	r1,r11
8000acfe:	14 97       	mov	r7,r10
8000ad00:	18 95       	mov	r5,r12
8000ad02:	e0 a0 1a 31 	rcall	8000e164 <_localeconv_r>
8000ad06:	78 0c       	ld.w	r12,r12[0x0]
8000ad08:	50 cc       	stdsp	sp[0x30],r12
8000ad0a:	58 05       	cp.w	r5,0
8000ad0c:	c0 70       	breq	8000ad1a <_vfprintf_r+0x26>
8000ad0e:	6a 68       	ld.w	r8,r5[0x18]
8000ad10:	58 08       	cp.w	r8,0
8000ad12:	c0 41       	brne	8000ad1a <_vfprintf_r+0x26>
8000ad14:	0a 9c       	mov	r12,r5
8000ad16:	e0 a0 17 57 	rcall	8000dbc4 <__sinit>
8000ad1a:	4d 08       	lddpc	r8,8000ae58 <_vfprintf_r+0x164>
8000ad1c:	10 31       	cp.w	r1,r8
8000ad1e:	c0 31       	brne	8000ad24 <_vfprintf_r+0x30>
8000ad20:	6a 01       	ld.w	r1,r5[0x0]
8000ad22:	c0 a8       	rjmp	8000ad36 <_vfprintf_r+0x42>
8000ad24:	4c e8       	lddpc	r8,8000ae5c <_vfprintf_r+0x168>
8000ad26:	10 31       	cp.w	r1,r8
8000ad28:	c0 31       	brne	8000ad2e <_vfprintf_r+0x3a>
8000ad2a:	6a 11       	ld.w	r1,r5[0x4]
8000ad2c:	c0 58       	rjmp	8000ad36 <_vfprintf_r+0x42>
8000ad2e:	4c d8       	lddpc	r8,8000ae60 <_vfprintf_r+0x16c>
8000ad30:	10 31       	cp.w	r1,r8
8000ad32:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000ad36:	82 68       	ld.sh	r8,r1[0xc]
8000ad38:	ed b8 00 03 	bld	r8,0x3
8000ad3c:	c0 41       	brne	8000ad44 <_vfprintf_r+0x50>
8000ad3e:	62 48       	ld.w	r8,r1[0x10]
8000ad40:	58 08       	cp.w	r8,0
8000ad42:	c0 71       	brne	8000ad50 <_vfprintf_r+0x5c>
8000ad44:	02 9b       	mov	r11,r1
8000ad46:	0a 9c       	mov	r12,r5
8000ad48:	e0 a0 0f 6c 	rcall	8000cc20 <__swsetup_r>
8000ad4c:	e0 81 0f 63 	brne	8000cc12 <_vfprintf_r+0x1f1e>
8000ad50:	82 68       	ld.sh	r8,r1[0xc]
8000ad52:	10 99       	mov	r9,r8
8000ad54:	e2 19 00 1a 	andl	r9,0x1a,COH
8000ad58:	58 a9       	cp.w	r9,10
8000ad5a:	c3 c1       	brne	8000add2 <_vfprintf_r+0xde>
8000ad5c:	82 79       	ld.sh	r9,r1[0xe]
8000ad5e:	30 0a       	mov	r10,0
8000ad60:	f4 09 19 00 	cp.h	r9,r10
8000ad64:	c3 75       	brlt	8000add2 <_vfprintf_r+0xde>
8000ad66:	a1 d8       	cbr	r8,0x1
8000ad68:	fb 58 05 d0 	st.h	sp[1488],r8
8000ad6c:	62 88       	ld.w	r8,r1[0x20]
8000ad6e:	fb 48 05 e4 	st.w	sp[1508],r8
8000ad72:	62 a8       	ld.w	r8,r1[0x28]
8000ad74:	fb 48 05 ec 	st.w	sp[1516],r8
8000ad78:	fa c8 ff bc 	sub	r8,sp,-68
8000ad7c:	fb 48 05 d4 	st.w	sp[1492],r8
8000ad80:	fb 48 05 c4 	st.w	sp[1476],r8
8000ad84:	e0 68 04 00 	mov	r8,1024
8000ad88:	fb 48 05 d8 	st.w	sp[1496],r8
8000ad8c:	fb 48 05 cc 	st.w	sp[1484],r8
8000ad90:	30 08       	mov	r8,0
8000ad92:	fb 59 05 d2 	st.h	sp[1490],r9
8000ad96:	0e 9a       	mov	r10,r7
8000ad98:	41 09       	lddsp	r9,sp[0x40]
8000ad9a:	fa c7 fa 3c 	sub	r7,sp,-1476
8000ad9e:	fb 48 05 dc 	st.w	sp[1500],r8
8000ada2:	0a 9c       	mov	r12,r5
8000ada4:	0e 9b       	mov	r11,r7
8000ada6:	ca 7f       	rcall	8000acf4 <_vfprintf_r>
8000ada8:	50 bc       	stdsp	sp[0x2c],r12
8000adaa:	c0 95       	brlt	8000adbc <_vfprintf_r+0xc8>
8000adac:	0e 9b       	mov	r11,r7
8000adae:	0a 9c       	mov	r12,r5
8000adb0:	e0 a0 16 2e 	rcall	8000da0c <_fflush_r>
8000adb4:	40 be       	lddsp	lr,sp[0x2c]
8000adb6:	f9 be 01 ff 	movne	lr,-1
8000adba:	50 be       	stdsp	sp[0x2c],lr
8000adbc:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000adc0:	ed b8 00 06 	bld	r8,0x6
8000adc4:	e0 81 0f 29 	brne	8000cc16 <_vfprintf_r+0x1f22>
8000adc8:	82 68       	ld.sh	r8,r1[0xc]
8000adca:	a7 a8       	sbr	r8,0x6
8000adcc:	a2 68       	st.h	r1[0xc],r8
8000adce:	e0 8f 0f 24 	bral	8000cc16 <_vfprintf_r+0x1f22>
8000add2:	30 08       	mov	r8,0
8000add4:	fb 48 06 b4 	st.w	sp[1716],r8
8000add8:	fb 48 06 90 	st.w	sp[1680],r8
8000addc:	fb 48 06 8c 	st.w	sp[1676],r8
8000ade0:	fb 48 06 b0 	st.w	sp[1712],r8
8000ade4:	30 08       	mov	r8,0
8000ade6:	30 09       	mov	r9,0
8000ade8:	50 a7       	stdsp	sp[0x28],r7
8000adea:	50 78       	stdsp	sp[0x1c],r8
8000adec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adf0:	3f f8       	mov	r8,-1
8000adf2:	50 59       	stdsp	sp[0x14],r9
8000adf4:	fb 43 06 88 	st.w	sp[1672],r3
8000adf8:	fb 48 05 44 	st.w	sp[1348],r8
8000adfc:	12 9c       	mov	r12,r9
8000adfe:	50 69       	stdsp	sp[0x18],r9
8000ae00:	50 d9       	stdsp	sp[0x34],r9
8000ae02:	50 e9       	stdsp	sp[0x38],r9
8000ae04:	50 b9       	stdsp	sp[0x2c],r9
8000ae06:	12 97       	mov	r7,r9
8000ae08:	0a 94       	mov	r4,r5
8000ae0a:	40 a2       	lddsp	r2,sp[0x28]
8000ae0c:	32 5a       	mov	r10,37
8000ae0e:	30 08       	mov	r8,0
8000ae10:	c0 28       	rjmp	8000ae14 <_vfprintf_r+0x120>
8000ae12:	2f f2       	sub	r2,-1
8000ae14:	05 89       	ld.ub	r9,r2[0x0]
8000ae16:	f0 09 18 00 	cp.b	r9,r8
8000ae1a:	5f 1b       	srne	r11
8000ae1c:	f4 09 18 00 	cp.b	r9,r10
8000ae20:	5f 19       	srne	r9
8000ae22:	f3 eb 00 0b 	and	r11,r9,r11
8000ae26:	f0 0b 18 00 	cp.b	r11,r8
8000ae2a:	cf 41       	brne	8000ae12 <_vfprintf_r+0x11e>
8000ae2c:	40 ab       	lddsp	r11,sp[0x28]
8000ae2e:	e4 0b 01 06 	sub	r6,r2,r11
8000ae32:	c2 50       	breq	8000ae7c <_vfprintf_r+0x188>
8000ae34:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae38:	0c 08       	add	r8,r6
8000ae3a:	87 0b       	st.w	r3[0x0],r11
8000ae3c:	fb 48 06 90 	st.w	sp[1680],r8
8000ae40:	87 16       	st.w	r3[0x4],r6
8000ae42:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae46:	2f f8       	sub	r8,-1
8000ae48:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae4c:	58 78       	cp.w	r8,7
8000ae4e:	e0 89 00 0b 	brgt	8000ae64 <_vfprintf_r+0x170>
8000ae52:	2f 83       	sub	r3,-8
8000ae54:	c1 18       	rjmp	8000ae76 <_vfprintf_r+0x182>
8000ae56:	d7 03       	nop
8000ae58:	80 01       	ld.sh	r1,r0[0x0]
8000ae5a:	90 b0       	ld.uh	r0,r8[0x6]
8000ae5c:	80 01       	ld.sh	r1,r0[0x0]
8000ae5e:	90 d0       	ld.uh	r0,r8[0xa]
8000ae60:	80 01       	ld.sh	r1,r0[0x0]
8000ae62:	90 f0       	ld.uh	r0,r8[0xe]
8000ae64:	fa ca f9 78 	sub	r10,sp,-1672
8000ae68:	02 9b       	mov	r11,r1
8000ae6a:	08 9c       	mov	r12,r4
8000ae6c:	c3 6f       	rcall	8000acd8 <__sprint_r>
8000ae6e:	e0 81 0e ce 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000ae72:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae76:	40 ba       	lddsp	r10,sp[0x2c]
8000ae78:	0c 0a       	add	r10,r6
8000ae7a:	50 ba       	stdsp	sp[0x2c],r10
8000ae7c:	05 89       	ld.ub	r9,r2[0x0]
8000ae7e:	30 08       	mov	r8,0
8000ae80:	f0 09 18 00 	cp.b	r9,r8
8000ae84:	e0 80 0e b2 	breq	8000cbe8 <_vfprintf_r+0x1ef4>
8000ae88:	30 09       	mov	r9,0
8000ae8a:	fb 68 06 bb 	st.b	sp[1723],r8
8000ae8e:	0e 96       	mov	r6,r7
8000ae90:	e4 c8 ff ff 	sub	r8,r2,-1
8000ae94:	3f fe       	mov	lr,-1
8000ae96:	50 93       	stdsp	sp[0x24],r3
8000ae98:	50 41       	stdsp	sp[0x10],r1
8000ae9a:	0e 93       	mov	r3,r7
8000ae9c:	04 91       	mov	r1,r2
8000ae9e:	50 89       	stdsp	sp[0x20],r9
8000aea0:	50 a8       	stdsp	sp[0x28],r8
8000aea2:	50 2e       	stdsp	sp[0x8],lr
8000aea4:	50 39       	stdsp	sp[0xc],r9
8000aea6:	12 95       	mov	r5,r9
8000aea8:	12 90       	mov	r0,r9
8000aeaa:	10 97       	mov	r7,r8
8000aeac:	08 92       	mov	r2,r4
8000aeae:	c0 78       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000aeb0:	3f fc       	mov	r12,-1
8000aeb2:	08 97       	mov	r7,r4
8000aeb4:	50 2c       	stdsp	sp[0x8],r12
8000aeb6:	c0 38       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000aeb8:	30 0b       	mov	r11,0
8000aeba:	50 3b       	stdsp	sp[0xc],r11
8000aebc:	0f 38       	ld.ub	r8,r7++
8000aebe:	c0 28       	rjmp	8000aec2 <_vfprintf_r+0x1ce>
8000aec0:	12 90       	mov	r0,r9
8000aec2:	f0 c9 00 20 	sub	r9,r8,32
8000aec6:	e0 49 00 58 	cp.w	r9,88
8000aeca:	e0 8b 0a 36 	brhi	8000c336 <_vfprintf_r+0x1642>
8000aece:	4d 9a       	lddpc	r10,8000b030 <_vfprintf_r+0x33c>
8000aed0:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000aed4:	50 a7       	stdsp	sp[0x28],r7
8000aed6:	50 80       	stdsp	sp[0x20],r0
8000aed8:	0c 97       	mov	r7,r6
8000aeda:	04 94       	mov	r4,r2
8000aedc:	06 96       	mov	r6,r3
8000aede:	02 92       	mov	r2,r1
8000aee0:	4d 59       	lddpc	r9,8000b034 <_vfprintf_r+0x340>
8000aee2:	40 93       	lddsp	r3,sp[0x24]
8000aee4:	10 90       	mov	r0,r8
8000aee6:	40 41       	lddsp	r1,sp[0x10]
8000aee8:	50 d9       	stdsp	sp[0x34],r9
8000aeea:	e0 8f 08 95 	bral	8000c014 <_vfprintf_r+0x1320>
8000aeee:	30 08       	mov	r8,0
8000aef0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000aef4:	f0 09 18 00 	cp.b	r9,r8
8000aef8:	ce 21       	brne	8000aebc <_vfprintf_r+0x1c8>
8000aefa:	32 08       	mov	r8,32
8000aefc:	c6 e8       	rjmp	8000afd8 <_vfprintf_r+0x2e4>
8000aefe:	a1 a5       	sbr	r5,0x0
8000af00:	cd eb       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000af02:	0f 89       	ld.ub	r9,r7[0x0]
8000af04:	f2 c8 00 30 	sub	r8,r9,48
8000af08:	58 98       	cp.w	r8,9
8000af0a:	e0 8b 00 1d 	brhi	8000af44 <_vfprintf_r+0x250>
8000af0e:	ee c8 ff ff 	sub	r8,r7,-1
8000af12:	30 0b       	mov	r11,0
8000af14:	23 09       	sub	r9,48
8000af16:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000af1a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000af1e:	11 39       	ld.ub	r9,r8++
8000af20:	f2 ca 00 30 	sub	r10,r9,48
8000af24:	58 9a       	cp.w	r10,9
8000af26:	fe 98 ff f7 	brls	8000af14 <_vfprintf_r+0x220>
8000af2a:	e0 49 00 24 	cp.w	r9,36
8000af2e:	cc 51       	brne	8000aeb8 <_vfprintf_r+0x1c4>
8000af30:	e0 4b 00 20 	cp.w	r11,32
8000af34:	e0 89 0e 6a 	brgt	8000cc08 <_vfprintf_r+0x1f14>
8000af38:	20 1b       	sub	r11,1
8000af3a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000af3e:	12 3b       	cp.w	r11,r9
8000af40:	c0 95       	brlt	8000af52 <_vfprintf_r+0x25e>
8000af42:	c1 08       	rjmp	8000af62 <_vfprintf_r+0x26e>
8000af44:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000af48:	ec ca ff ff 	sub	r10,r6,-1
8000af4c:	12 36       	cp.w	r6,r9
8000af4e:	c1 f5       	brlt	8000af8c <_vfprintf_r+0x298>
8000af50:	c2 68       	rjmp	8000af9c <_vfprintf_r+0x2a8>
8000af52:	fa ce f9 44 	sub	lr,sp,-1724
8000af56:	10 97       	mov	r7,r8
8000af58:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000af5c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000af60:	c3 58       	rjmp	8000afca <_vfprintf_r+0x2d6>
8000af62:	10 97       	mov	r7,r8
8000af64:	fa c8 f9 50 	sub	r8,sp,-1712
8000af68:	1a d8       	st.w	--sp,r8
8000af6a:	fa c8 fa b8 	sub	r8,sp,-1352
8000af6e:	1a d8       	st.w	--sp,r8
8000af70:	fa c8 fb b4 	sub	r8,sp,-1100
8000af74:	02 9a       	mov	r10,r1
8000af76:	1a d8       	st.w	--sp,r8
8000af78:	04 9c       	mov	r12,r2
8000af7a:	fa c8 f9 40 	sub	r8,sp,-1728
8000af7e:	fa c9 ff b4 	sub	r9,sp,-76
8000af82:	fe b0 fd 1b 	rcall	8000a9b8 <get_arg>
8000af86:	2f dd       	sub	sp,-12
8000af88:	78 00       	ld.w	r0,r12[0x0]
8000af8a:	c2 08       	rjmp	8000afca <_vfprintf_r+0x2d6>
8000af8c:	fa cc f9 44 	sub	r12,sp,-1724
8000af90:	14 96       	mov	r6,r10
8000af92:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000af96:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000af9a:	c1 88       	rjmp	8000afca <_vfprintf_r+0x2d6>
8000af9c:	41 08       	lddsp	r8,sp[0x40]
8000af9e:	59 f9       	cp.w	r9,31
8000afa0:	e0 89 00 11 	brgt	8000afc2 <_vfprintf_r+0x2ce>
8000afa4:	f0 cb ff fc 	sub	r11,r8,-4
8000afa8:	51 0b       	stdsp	sp[0x40],r11
8000afaa:	70 00       	ld.w	r0,r8[0x0]
8000afac:	fa cb f9 44 	sub	r11,sp,-1724
8000afb0:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000afb4:	f1 40 fd 88 	st.w	r8[-632],r0
8000afb8:	2f f9       	sub	r9,-1
8000afba:	14 96       	mov	r6,r10
8000afbc:	fb 49 06 b4 	st.w	sp[1716],r9
8000afc0:	c0 58       	rjmp	8000afca <_vfprintf_r+0x2d6>
8000afc2:	70 00       	ld.w	r0,r8[0x0]
8000afc4:	14 96       	mov	r6,r10
8000afc6:	2f c8       	sub	r8,-4
8000afc8:	51 08       	stdsp	sp[0x40],r8
8000afca:	58 00       	cp.w	r0,0
8000afcc:	fe 94 ff 78 	brge	8000aebc <_vfprintf_r+0x1c8>
8000afd0:	5c 30       	neg	r0
8000afd2:	a3 a5       	sbr	r5,0x2
8000afd4:	c7 4b       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000afd6:	32 b8       	mov	r8,43
8000afd8:	fb 68 06 bb 	st.b	sp[1723],r8
8000afdc:	c7 0b       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000afde:	0f 38       	ld.ub	r8,r7++
8000afe0:	e0 48 00 2a 	cp.w	r8,42
8000afe4:	c0 30       	breq	8000afea <_vfprintf_r+0x2f6>
8000afe6:	30 09       	mov	r9,0
8000afe8:	c7 d8       	rjmp	8000b0e2 <_vfprintf_r+0x3ee>
8000afea:	0f 88       	ld.ub	r8,r7[0x0]
8000afec:	f0 c9 00 30 	sub	r9,r8,48
8000aff0:	58 99       	cp.w	r9,9
8000aff2:	e0 8b 00 23 	brhi	8000b038 <_vfprintf_r+0x344>
8000aff6:	ee c4 ff ff 	sub	r4,r7,-1
8000affa:	30 0b       	mov	r11,0
8000affc:	23 08       	sub	r8,48
8000affe:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b002:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b006:	09 38       	ld.ub	r8,r4++
8000b008:	f0 c9 00 30 	sub	r9,r8,48
8000b00c:	58 99       	cp.w	r9,9
8000b00e:	fe 98 ff f7 	brls	8000affc <_vfprintf_r+0x308>
8000b012:	e0 48 00 24 	cp.w	r8,36
8000b016:	fe 91 ff 51 	brne	8000aeb8 <_vfprintf_r+0x1c4>
8000b01a:	e0 4b 00 20 	cp.w	r11,32
8000b01e:	e0 89 0d f5 	brgt	8000cc08 <_vfprintf_r+0x1f14>
8000b022:	20 1b       	sub	r11,1
8000b024:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b028:	10 3b       	cp.w	r11,r8
8000b02a:	c0 e5       	brlt	8000b046 <_vfprintf_r+0x352>
8000b02c:	c1 58       	rjmp	8000b056 <_vfprintf_r+0x362>
8000b02e:	d7 03       	nop
8000b030:	80 01       	ld.sh	r1,r0[0x0]
8000b032:	8d 08       	st.w	r6[0x0],r8
8000b034:	80 01       	ld.sh	r1,r0[0x0]
8000b036:	8f 44       	st.w	r7[0x10],r4
8000b038:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b03c:	ec c9 ff ff 	sub	r9,r6,-1
8000b040:	14 36       	cp.w	r6,r10
8000b042:	c1 f5       	brlt	8000b080 <_vfprintf_r+0x38c>
8000b044:	c2 88       	rjmp	8000b094 <_vfprintf_r+0x3a0>
8000b046:	fa ca f9 44 	sub	r10,sp,-1724
8000b04a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b04e:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b052:	50 2b       	stdsp	sp[0x8],r11
8000b054:	c3 c8       	rjmp	8000b0cc <_vfprintf_r+0x3d8>
8000b056:	fa c8 f9 50 	sub	r8,sp,-1712
8000b05a:	1a d8       	st.w	--sp,r8
8000b05c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b060:	1a d8       	st.w	--sp,r8
8000b062:	fa c8 fb b4 	sub	r8,sp,-1100
8000b066:	02 9a       	mov	r10,r1
8000b068:	1a d8       	st.w	--sp,r8
8000b06a:	04 9c       	mov	r12,r2
8000b06c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b070:	fa c9 ff b4 	sub	r9,sp,-76
8000b074:	fe b0 fc a2 	rcall	8000a9b8 <get_arg>
8000b078:	2f dd       	sub	sp,-12
8000b07a:	78 0c       	ld.w	r12,r12[0x0]
8000b07c:	50 2c       	stdsp	sp[0x8],r12
8000b07e:	c2 78       	rjmp	8000b0cc <_vfprintf_r+0x3d8>
8000b080:	12 96       	mov	r6,r9
8000b082:	0e 94       	mov	r4,r7
8000b084:	fa c9 f9 44 	sub	r9,sp,-1724
8000b088:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b08c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b090:	50 28       	stdsp	sp[0x8],r8
8000b092:	c1 d8       	rjmp	8000b0cc <_vfprintf_r+0x3d8>
8000b094:	41 08       	lddsp	r8,sp[0x40]
8000b096:	59 fa       	cp.w	r10,31
8000b098:	e0 89 00 14 	brgt	8000b0c0 <_vfprintf_r+0x3cc>
8000b09c:	f0 cb ff fc 	sub	r11,r8,-4
8000b0a0:	70 08       	ld.w	r8,r8[0x0]
8000b0a2:	51 0b       	stdsp	sp[0x40],r11
8000b0a4:	50 28       	stdsp	sp[0x8],r8
8000b0a6:	fa c6 f9 44 	sub	r6,sp,-1724
8000b0aa:	40 2e       	lddsp	lr,sp[0x8]
8000b0ac:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b0b0:	f1 4e fd 88 	st.w	r8[-632],lr
8000b0b4:	2f fa       	sub	r10,-1
8000b0b6:	0e 94       	mov	r4,r7
8000b0b8:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b0bc:	12 96       	mov	r6,r9
8000b0be:	c0 78       	rjmp	8000b0cc <_vfprintf_r+0x3d8>
8000b0c0:	70 0c       	ld.w	r12,r8[0x0]
8000b0c2:	0e 94       	mov	r4,r7
8000b0c4:	2f c8       	sub	r8,-4
8000b0c6:	50 2c       	stdsp	sp[0x8],r12
8000b0c8:	12 96       	mov	r6,r9
8000b0ca:	51 08       	stdsp	sp[0x40],r8
8000b0cc:	40 2b       	lddsp	r11,sp[0x8]
8000b0ce:	58 0b       	cp.w	r11,0
8000b0d0:	fe 95 fe f0 	brlt	8000aeb0 <_vfprintf_r+0x1bc>
8000b0d4:	08 97       	mov	r7,r4
8000b0d6:	cf 3a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b0d8:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b0dc:	0f 38       	ld.ub	r8,r7++
8000b0de:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b0e2:	f0 ca 00 30 	sub	r10,r8,48
8000b0e6:	58 9a       	cp.w	r10,9
8000b0e8:	fe 98 ff f8 	brls	8000b0d8 <_vfprintf_r+0x3e4>
8000b0ec:	3f fa       	mov	r10,-1
8000b0ee:	f2 0a 0c 49 	max	r9,r9,r10
8000b0f2:	50 29       	stdsp	sp[0x8],r9
8000b0f4:	ce 7a       	rjmp	8000aec2 <_vfprintf_r+0x1ce>
8000b0f6:	a7 b5       	sbr	r5,0x7
8000b0f8:	ce 2a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b0fa:	30 09       	mov	r9,0
8000b0fc:	23 08       	sub	r8,48
8000b0fe:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b102:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b106:	0f 38       	ld.ub	r8,r7++
8000b108:	f0 ca 00 30 	sub	r10,r8,48
8000b10c:	58 9a       	cp.w	r10,9
8000b10e:	fe 98 ff f7 	brls	8000b0fc <_vfprintf_r+0x408>
8000b112:	e0 48 00 24 	cp.w	r8,36
8000b116:	fe 91 fe d5 	brne	8000aec0 <_vfprintf_r+0x1cc>
8000b11a:	e0 49 00 20 	cp.w	r9,32
8000b11e:	e0 89 0d 75 	brgt	8000cc08 <_vfprintf_r+0x1f14>
8000b122:	f2 c3 00 01 	sub	r3,r9,1
8000b126:	30 19       	mov	r9,1
8000b128:	50 39       	stdsp	sp[0xc],r9
8000b12a:	cc 9a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b12c:	a3 b5       	sbr	r5,0x3
8000b12e:	cc 7a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b130:	a7 a5       	sbr	r5,0x6
8000b132:	cc 5a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b134:	0a 98       	mov	r8,r5
8000b136:	a5 b5       	sbr	r5,0x5
8000b138:	a5 a8       	sbr	r8,0x4
8000b13a:	0f 89       	ld.ub	r9,r7[0x0]
8000b13c:	36 ce       	mov	lr,108
8000b13e:	fc 09 18 00 	cp.b	r9,lr
8000b142:	f7 b7 00 ff 	subeq	r7,-1
8000b146:	f0 05 17 10 	movne	r5,r8
8000b14a:	cb 9a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b14c:	a5 b5       	sbr	r5,0x5
8000b14e:	cb 7a       	rjmp	8000aebc <_vfprintf_r+0x1c8>
8000b150:	50 a7       	stdsp	sp[0x28],r7
8000b152:	50 80       	stdsp	sp[0x20],r0
8000b154:	0c 97       	mov	r7,r6
8000b156:	10 90       	mov	r0,r8
8000b158:	06 96       	mov	r6,r3
8000b15a:	04 94       	mov	r4,r2
8000b15c:	40 93       	lddsp	r3,sp[0x24]
8000b15e:	02 92       	mov	r2,r1
8000b160:	0e 99       	mov	r9,r7
8000b162:	40 41       	lddsp	r1,sp[0x10]
8000b164:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b168:	40 3c       	lddsp	r12,sp[0xc]
8000b16a:	58 0c       	cp.w	r12,0
8000b16c:	c1 d0       	breq	8000b1a6 <_vfprintf_r+0x4b2>
8000b16e:	10 36       	cp.w	r6,r8
8000b170:	c0 64       	brge	8000b17c <_vfprintf_r+0x488>
8000b172:	fa cb f9 44 	sub	r11,sp,-1724
8000b176:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b17a:	c1 d8       	rjmp	8000b1b4 <_vfprintf_r+0x4c0>
8000b17c:	fa c8 f9 50 	sub	r8,sp,-1712
8000b180:	1a d8       	st.w	--sp,r8
8000b182:	fa c8 fa b8 	sub	r8,sp,-1352
8000b186:	1a d8       	st.w	--sp,r8
8000b188:	fa c8 fb b4 	sub	r8,sp,-1100
8000b18c:	1a d8       	st.w	--sp,r8
8000b18e:	fa c8 f9 40 	sub	r8,sp,-1728
8000b192:	fa c9 ff b4 	sub	r9,sp,-76
8000b196:	04 9a       	mov	r10,r2
8000b198:	0c 9b       	mov	r11,r6
8000b19a:	08 9c       	mov	r12,r4
8000b19c:	fe b0 fc 0e 	rcall	8000a9b8 <get_arg>
8000b1a0:	2f dd       	sub	sp,-12
8000b1a2:	19 b8       	ld.ub	r8,r12[0x3]
8000b1a4:	c2 28       	rjmp	8000b1e8 <_vfprintf_r+0x4f4>
8000b1a6:	2f f7       	sub	r7,-1
8000b1a8:	10 39       	cp.w	r9,r8
8000b1aa:	c0 84       	brge	8000b1ba <_vfprintf_r+0x4c6>
8000b1ac:	fa ca f9 44 	sub	r10,sp,-1724
8000b1b0:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b1b4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b1b8:	c1 88       	rjmp	8000b1e8 <_vfprintf_r+0x4f4>
8000b1ba:	41 09       	lddsp	r9,sp[0x40]
8000b1bc:	59 f8       	cp.w	r8,31
8000b1be:	e0 89 00 12 	brgt	8000b1e2 <_vfprintf_r+0x4ee>
8000b1c2:	f2 ca ff fc 	sub	r10,r9,-4
8000b1c6:	51 0a       	stdsp	sp[0x40],r10
8000b1c8:	72 09       	ld.w	r9,r9[0x0]
8000b1ca:	fa c6 f9 44 	sub	r6,sp,-1724
8000b1ce:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b1d2:	2f f8       	sub	r8,-1
8000b1d4:	f5 49 fd 88 	st.w	r10[-632],r9
8000b1d8:	fb 48 06 b4 	st.w	sp[1716],r8
8000b1dc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b1e0:	c0 48       	rjmp	8000b1e8 <_vfprintf_r+0x4f4>
8000b1e2:	13 b8       	ld.ub	r8,r9[0x3]
8000b1e4:	2f c9       	sub	r9,-4
8000b1e6:	51 09       	stdsp	sp[0x40],r9
8000b1e8:	fb 68 06 60 	st.b	sp[1632],r8
8000b1ec:	30 0e       	mov	lr,0
8000b1ee:	30 08       	mov	r8,0
8000b1f0:	30 12       	mov	r2,1
8000b1f2:	fb 68 06 bb 	st.b	sp[1723],r8
8000b1f6:	50 2e       	stdsp	sp[0x8],lr
8000b1f8:	e0 8f 08 b1 	bral	8000c35a <_vfprintf_r+0x1666>
8000b1fc:	50 a7       	stdsp	sp[0x28],r7
8000b1fe:	50 80       	stdsp	sp[0x20],r0
8000b200:	0c 97       	mov	r7,r6
8000b202:	04 94       	mov	r4,r2
8000b204:	06 96       	mov	r6,r3
8000b206:	02 92       	mov	r2,r1
8000b208:	40 93       	lddsp	r3,sp[0x24]
8000b20a:	10 90       	mov	r0,r8
8000b20c:	40 41       	lddsp	r1,sp[0x10]
8000b20e:	a5 a5       	sbr	r5,0x4
8000b210:	c0 a8       	rjmp	8000b224 <_vfprintf_r+0x530>
8000b212:	50 a7       	stdsp	sp[0x28],r7
8000b214:	50 80       	stdsp	sp[0x20],r0
8000b216:	0c 97       	mov	r7,r6
8000b218:	04 94       	mov	r4,r2
8000b21a:	06 96       	mov	r6,r3
8000b21c:	02 92       	mov	r2,r1
8000b21e:	40 93       	lddsp	r3,sp[0x24]
8000b220:	10 90       	mov	r0,r8
8000b222:	40 41       	lddsp	r1,sp[0x10]
8000b224:	ed b5 00 05 	bld	r5,0x5
8000b228:	c5 11       	brne	8000b2ca <_vfprintf_r+0x5d6>
8000b22a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b22e:	40 3c       	lddsp	r12,sp[0xc]
8000b230:	58 0c       	cp.w	r12,0
8000b232:	c1 e0       	breq	8000b26e <_vfprintf_r+0x57a>
8000b234:	10 36       	cp.w	r6,r8
8000b236:	c0 64       	brge	8000b242 <_vfprintf_r+0x54e>
8000b238:	fa cb f9 44 	sub	r11,sp,-1724
8000b23c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b240:	c2 08       	rjmp	8000b280 <_vfprintf_r+0x58c>
8000b242:	fa c8 f9 50 	sub	r8,sp,-1712
8000b246:	1a d8       	st.w	--sp,r8
8000b248:	fa c8 fa b8 	sub	r8,sp,-1352
8000b24c:	0c 9b       	mov	r11,r6
8000b24e:	1a d8       	st.w	--sp,r8
8000b250:	fa c8 fb b4 	sub	r8,sp,-1100
8000b254:	1a d8       	st.w	--sp,r8
8000b256:	fa c9 ff b4 	sub	r9,sp,-76
8000b25a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b25e:	04 9a       	mov	r10,r2
8000b260:	08 9c       	mov	r12,r4
8000b262:	fe b0 fb ab 	rcall	8000a9b8 <get_arg>
8000b266:	2f dd       	sub	sp,-12
8000b268:	78 1b       	ld.w	r11,r12[0x4]
8000b26a:	78 09       	ld.w	r9,r12[0x0]
8000b26c:	c2 b8       	rjmp	8000b2c2 <_vfprintf_r+0x5ce>
8000b26e:	ee ca ff ff 	sub	r10,r7,-1
8000b272:	10 37       	cp.w	r7,r8
8000b274:	c0 b4       	brge	8000b28a <_vfprintf_r+0x596>
8000b276:	fa c9 f9 44 	sub	r9,sp,-1724
8000b27a:	14 97       	mov	r7,r10
8000b27c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b280:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b284:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b288:	c1 d8       	rjmp	8000b2c2 <_vfprintf_r+0x5ce>
8000b28a:	41 09       	lddsp	r9,sp[0x40]
8000b28c:	59 f8       	cp.w	r8,31
8000b28e:	e0 89 00 14 	brgt	8000b2b6 <_vfprintf_r+0x5c2>
8000b292:	f2 cb ff f8 	sub	r11,r9,-8
8000b296:	51 0b       	stdsp	sp[0x40],r11
8000b298:	fa c6 f9 44 	sub	r6,sp,-1724
8000b29c:	72 1b       	ld.w	r11,r9[0x4]
8000b29e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b2a2:	72 09       	ld.w	r9,r9[0x0]
8000b2a4:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b2a8:	f9 49 fd 88 	st.w	r12[-632],r9
8000b2ac:	2f f8       	sub	r8,-1
8000b2ae:	14 97       	mov	r7,r10
8000b2b0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b2b4:	c0 78       	rjmp	8000b2c2 <_vfprintf_r+0x5ce>
8000b2b6:	f2 c8 ff f8 	sub	r8,r9,-8
8000b2ba:	72 1b       	ld.w	r11,r9[0x4]
8000b2bc:	14 97       	mov	r7,r10
8000b2be:	51 08       	stdsp	sp[0x40],r8
8000b2c0:	72 09       	ld.w	r9,r9[0x0]
8000b2c2:	16 98       	mov	r8,r11
8000b2c4:	fa e9 00 00 	st.d	sp[0],r8
8000b2c8:	ca e8       	rjmp	8000b424 <_vfprintf_r+0x730>
8000b2ca:	ed b5 00 04 	bld	r5,0x4
8000b2ce:	c1 71       	brne	8000b2fc <_vfprintf_r+0x608>
8000b2d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b2d4:	40 3e       	lddsp	lr,sp[0xc]
8000b2d6:	58 0e       	cp.w	lr,0
8000b2d8:	c0 80       	breq	8000b2e8 <_vfprintf_r+0x5f4>
8000b2da:	10 36       	cp.w	r6,r8
8000b2dc:	c6 94       	brge	8000b3ae <_vfprintf_r+0x6ba>
8000b2de:	fa cc f9 44 	sub	r12,sp,-1724
8000b2e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b2e6:	c8 28       	rjmp	8000b3ea <_vfprintf_r+0x6f6>
8000b2e8:	ee ca ff ff 	sub	r10,r7,-1
8000b2ec:	10 37       	cp.w	r7,r8
8000b2ee:	e0 84 00 81 	brge	8000b3f0 <_vfprintf_r+0x6fc>
8000b2f2:	fa cb f9 44 	sub	r11,sp,-1724
8000b2f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b2fa:	c7 78       	rjmp	8000b3e8 <_vfprintf_r+0x6f4>
8000b2fc:	ed b5 00 06 	bld	r5,0x6
8000b300:	c4 b1       	brne	8000b396 <_vfprintf_r+0x6a2>
8000b302:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b306:	40 3c       	lddsp	r12,sp[0xc]
8000b308:	58 0c       	cp.w	r12,0
8000b30a:	c1 d0       	breq	8000b344 <_vfprintf_r+0x650>
8000b30c:	10 36       	cp.w	r6,r8
8000b30e:	c0 64       	brge	8000b31a <_vfprintf_r+0x626>
8000b310:	fa cb f9 44 	sub	r11,sp,-1724
8000b314:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b318:	c1 f8       	rjmp	8000b356 <_vfprintf_r+0x662>
8000b31a:	fa c8 f9 50 	sub	r8,sp,-1712
8000b31e:	1a d8       	st.w	--sp,r8
8000b320:	fa c8 fa b8 	sub	r8,sp,-1352
8000b324:	1a d8       	st.w	--sp,r8
8000b326:	fa c8 fb b4 	sub	r8,sp,-1100
8000b32a:	1a d8       	st.w	--sp,r8
8000b32c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b330:	fa c9 ff b4 	sub	r9,sp,-76
8000b334:	04 9a       	mov	r10,r2
8000b336:	0c 9b       	mov	r11,r6
8000b338:	08 9c       	mov	r12,r4
8000b33a:	fe b0 fb 3f 	rcall	8000a9b8 <get_arg>
8000b33e:	2f dd       	sub	sp,-12
8000b340:	98 18       	ld.sh	r8,r12[0x2]
8000b342:	c2 68       	rjmp	8000b38e <_vfprintf_r+0x69a>
8000b344:	ee ca ff ff 	sub	r10,r7,-1
8000b348:	10 37       	cp.w	r7,r8
8000b34a:	c0 94       	brge	8000b35c <_vfprintf_r+0x668>
8000b34c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b350:	14 97       	mov	r7,r10
8000b352:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b356:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b35a:	c1 a8       	rjmp	8000b38e <_vfprintf_r+0x69a>
8000b35c:	41 09       	lddsp	r9,sp[0x40]
8000b35e:	59 f8       	cp.w	r8,31
8000b360:	e0 89 00 13 	brgt	8000b386 <_vfprintf_r+0x692>
8000b364:	f2 cb ff fc 	sub	r11,r9,-4
8000b368:	51 0b       	stdsp	sp[0x40],r11
8000b36a:	72 09       	ld.w	r9,r9[0x0]
8000b36c:	fa c6 f9 44 	sub	r6,sp,-1724
8000b370:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b374:	2f f8       	sub	r8,-1
8000b376:	f7 49 fd 88 	st.w	r11[-632],r9
8000b37a:	fb 48 06 b4 	st.w	sp[1716],r8
8000b37e:	14 97       	mov	r7,r10
8000b380:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b384:	c0 58       	rjmp	8000b38e <_vfprintf_r+0x69a>
8000b386:	92 18       	ld.sh	r8,r9[0x2]
8000b388:	14 97       	mov	r7,r10
8000b38a:	2f c9       	sub	r9,-4
8000b38c:	51 09       	stdsp	sp[0x40],r9
8000b38e:	50 18       	stdsp	sp[0x4],r8
8000b390:	bf 58       	asr	r8,0x1f
8000b392:	50 08       	stdsp	sp[0x0],r8
8000b394:	c4 88       	rjmp	8000b424 <_vfprintf_r+0x730>
8000b396:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b39a:	40 3c       	lddsp	r12,sp[0xc]
8000b39c:	58 0c       	cp.w	r12,0
8000b39e:	c1 d0       	breq	8000b3d8 <_vfprintf_r+0x6e4>
8000b3a0:	10 36       	cp.w	r6,r8
8000b3a2:	c0 64       	brge	8000b3ae <_vfprintf_r+0x6ba>
8000b3a4:	fa cb f9 44 	sub	r11,sp,-1724
8000b3a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b3ac:	c1 f8       	rjmp	8000b3ea <_vfprintf_r+0x6f6>
8000b3ae:	fa c8 f9 50 	sub	r8,sp,-1712
8000b3b2:	1a d8       	st.w	--sp,r8
8000b3b4:	fa c8 fa b8 	sub	r8,sp,-1352
8000b3b8:	0c 9b       	mov	r11,r6
8000b3ba:	1a d8       	st.w	--sp,r8
8000b3bc:	fa c8 fb b4 	sub	r8,sp,-1100
8000b3c0:	04 9a       	mov	r10,r2
8000b3c2:	1a d8       	st.w	--sp,r8
8000b3c4:	08 9c       	mov	r12,r4
8000b3c6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b3ca:	fa c9 ff b4 	sub	r9,sp,-76
8000b3ce:	fe b0 fa f5 	rcall	8000a9b8 <get_arg>
8000b3d2:	2f dd       	sub	sp,-12
8000b3d4:	78 0b       	ld.w	r11,r12[0x0]
8000b3d6:	c2 48       	rjmp	8000b41e <_vfprintf_r+0x72a>
8000b3d8:	ee ca ff ff 	sub	r10,r7,-1
8000b3dc:	10 37       	cp.w	r7,r8
8000b3de:	c0 94       	brge	8000b3f0 <_vfprintf_r+0x6fc>
8000b3e0:	fa c9 f9 44 	sub	r9,sp,-1724
8000b3e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b3e8:	14 97       	mov	r7,r10
8000b3ea:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b3ee:	c1 88       	rjmp	8000b41e <_vfprintf_r+0x72a>
8000b3f0:	41 09       	lddsp	r9,sp[0x40]
8000b3f2:	59 f8       	cp.w	r8,31
8000b3f4:	e0 89 00 11 	brgt	8000b416 <_vfprintf_r+0x722>
8000b3f8:	f2 cb ff fc 	sub	r11,r9,-4
8000b3fc:	51 0b       	stdsp	sp[0x40],r11
8000b3fe:	fa c6 f9 44 	sub	r6,sp,-1724
8000b402:	72 0b       	ld.w	r11,r9[0x0]
8000b404:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b408:	f3 4b fd 88 	st.w	r9[-632],r11
8000b40c:	2f f8       	sub	r8,-1
8000b40e:	14 97       	mov	r7,r10
8000b410:	fb 48 06 b4 	st.w	sp[1716],r8
8000b414:	c0 58       	rjmp	8000b41e <_vfprintf_r+0x72a>
8000b416:	72 0b       	ld.w	r11,r9[0x0]
8000b418:	14 97       	mov	r7,r10
8000b41a:	2f c9       	sub	r9,-4
8000b41c:	51 09       	stdsp	sp[0x40],r9
8000b41e:	50 1b       	stdsp	sp[0x4],r11
8000b420:	bf 5b       	asr	r11,0x1f
8000b422:	50 0b       	stdsp	sp[0x0],r11
8000b424:	fa ea 00 00 	ld.d	r10,sp[0]
8000b428:	58 0a       	cp.w	r10,0
8000b42a:	5c 2b       	cpc	r11
8000b42c:	c0 e4       	brge	8000b448 <_vfprintf_r+0x754>
8000b42e:	30 08       	mov	r8,0
8000b430:	fa ea 00 00 	ld.d	r10,sp[0]
8000b434:	30 09       	mov	r9,0
8000b436:	f0 0a 01 0a 	sub	r10,r8,r10
8000b43a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000b43e:	32 d8       	mov	r8,45
8000b440:	fa eb 00 00 	st.d	sp[0],r10
8000b444:	fb 68 06 bb 	st.b	sp[1723],r8
8000b448:	30 18       	mov	r8,1
8000b44a:	e0 8f 06 fe 	bral	8000c246 <_vfprintf_r+0x1552>
8000b44e:	50 a7       	stdsp	sp[0x28],r7
8000b450:	50 80       	stdsp	sp[0x20],r0
8000b452:	0c 97       	mov	r7,r6
8000b454:	04 94       	mov	r4,r2
8000b456:	06 96       	mov	r6,r3
8000b458:	02 92       	mov	r2,r1
8000b45a:	40 93       	lddsp	r3,sp[0x24]
8000b45c:	10 90       	mov	r0,r8
8000b45e:	40 41       	lddsp	r1,sp[0x10]
8000b460:	0e 99       	mov	r9,r7
8000b462:	ed b5 00 03 	bld	r5,0x3
8000b466:	c4 11       	brne	8000b4e8 <_vfprintf_r+0x7f4>
8000b468:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b46c:	40 3a       	lddsp	r10,sp[0xc]
8000b46e:	58 0a       	cp.w	r10,0
8000b470:	c1 90       	breq	8000b4a2 <_vfprintf_r+0x7ae>
8000b472:	10 36       	cp.w	r6,r8
8000b474:	c6 45       	brlt	8000b53c <_vfprintf_r+0x848>
8000b476:	fa c8 f9 50 	sub	r8,sp,-1712
8000b47a:	1a d8       	st.w	--sp,r8
8000b47c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b480:	1a d8       	st.w	--sp,r8
8000b482:	fa c8 fb b4 	sub	r8,sp,-1100
8000b486:	0c 9b       	mov	r11,r6
8000b488:	1a d8       	st.w	--sp,r8
8000b48a:	04 9a       	mov	r10,r2
8000b48c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b490:	fa c9 ff b4 	sub	r9,sp,-76
8000b494:	08 9c       	mov	r12,r4
8000b496:	fe b0 fa 91 	rcall	8000a9b8 <get_arg>
8000b49a:	2f dd       	sub	sp,-12
8000b49c:	78 16       	ld.w	r6,r12[0x4]
8000b49e:	50 76       	stdsp	sp[0x1c],r6
8000b4a0:	c4 88       	rjmp	8000b530 <_vfprintf_r+0x83c>
8000b4a2:	2f f7       	sub	r7,-1
8000b4a4:	10 39       	cp.w	r9,r8
8000b4a6:	c0 c4       	brge	8000b4be <_vfprintf_r+0x7ca>
8000b4a8:	fa ce f9 44 	sub	lr,sp,-1724
8000b4ac:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000b4b0:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000b4b4:	50 7c       	stdsp	sp[0x1c],r12
8000b4b6:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000b4ba:	50 56       	stdsp	sp[0x14],r6
8000b4bc:	c6 68       	rjmp	8000b588 <_vfprintf_r+0x894>
8000b4be:	41 09       	lddsp	r9,sp[0x40]
8000b4c0:	59 f8       	cp.w	r8,31
8000b4c2:	e0 89 00 10 	brgt	8000b4e2 <_vfprintf_r+0x7ee>
8000b4c6:	f2 ca ff f8 	sub	r10,r9,-8
8000b4ca:	72 1b       	ld.w	r11,r9[0x4]
8000b4cc:	51 0a       	stdsp	sp[0x40],r10
8000b4ce:	72 09       	ld.w	r9,r9[0x0]
8000b4d0:	fa ca f9 44 	sub	r10,sp,-1724
8000b4d4:	50 7b       	stdsp	sp[0x1c],r11
8000b4d6:	50 59       	stdsp	sp[0x14],r9
8000b4d8:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b4dc:	40 5b       	lddsp	r11,sp[0x14]
8000b4de:	40 7a       	lddsp	r10,sp[0x1c]
8000b4e0:	c4 78       	rjmp	8000b56e <_vfprintf_r+0x87a>
8000b4e2:	72 18       	ld.w	r8,r9[0x4]
8000b4e4:	50 78       	stdsp	sp[0x1c],r8
8000b4e6:	c4 c8       	rjmp	8000b57e <_vfprintf_r+0x88a>
8000b4e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b4ec:	40 3e       	lddsp	lr,sp[0xc]
8000b4ee:	58 0e       	cp.w	lr,0
8000b4f0:	c2 30       	breq	8000b536 <_vfprintf_r+0x842>
8000b4f2:	10 36       	cp.w	r6,r8
8000b4f4:	c0 94       	brge	8000b506 <_vfprintf_r+0x812>
8000b4f6:	fa cc f9 44 	sub	r12,sp,-1724
8000b4fa:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b4fe:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b502:	50 7b       	stdsp	sp[0x1c],r11
8000b504:	cd 9b       	rjmp	8000b4b6 <_vfprintf_r+0x7c2>
8000b506:	fa c8 f9 50 	sub	r8,sp,-1712
8000b50a:	1a d8       	st.w	--sp,r8
8000b50c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b510:	04 9a       	mov	r10,r2
8000b512:	1a d8       	st.w	--sp,r8
8000b514:	fa c8 fb b4 	sub	r8,sp,-1100
8000b518:	0c 9b       	mov	r11,r6
8000b51a:	1a d8       	st.w	--sp,r8
8000b51c:	08 9c       	mov	r12,r4
8000b51e:	fa c8 f9 40 	sub	r8,sp,-1728
8000b522:	fa c9 ff b4 	sub	r9,sp,-76
8000b526:	fe b0 fa 49 	rcall	8000a9b8 <get_arg>
8000b52a:	2f dd       	sub	sp,-12
8000b52c:	78 1a       	ld.w	r10,r12[0x4]
8000b52e:	50 7a       	stdsp	sp[0x1c],r10
8000b530:	78 0c       	ld.w	r12,r12[0x0]
8000b532:	50 5c       	stdsp	sp[0x14],r12
8000b534:	c2 a8       	rjmp	8000b588 <_vfprintf_r+0x894>
8000b536:	2f f7       	sub	r7,-1
8000b538:	10 39       	cp.w	r9,r8
8000b53a:	c0 94       	brge	8000b54c <_vfprintf_r+0x858>
8000b53c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b540:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b544:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000b548:	50 78       	stdsp	sp[0x1c],r8
8000b54a:	cb 6b       	rjmp	8000b4b6 <_vfprintf_r+0x7c2>
8000b54c:	41 09       	lddsp	r9,sp[0x40]
8000b54e:	59 f8       	cp.w	r8,31
8000b550:	e0 89 00 15 	brgt	8000b57a <_vfprintf_r+0x886>
8000b554:	f2 ca ff f8 	sub	r10,r9,-8
8000b558:	72 16       	ld.w	r6,r9[0x4]
8000b55a:	72 09       	ld.w	r9,r9[0x0]
8000b55c:	51 0a       	stdsp	sp[0x40],r10
8000b55e:	50 59       	stdsp	sp[0x14],r9
8000b560:	fa ce f9 44 	sub	lr,sp,-1724
8000b564:	50 76       	stdsp	sp[0x1c],r6
8000b566:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000b56a:	40 5b       	lddsp	r11,sp[0x14]
8000b56c:	0c 9a       	mov	r10,r6
8000b56e:	f2 eb fd 88 	st.d	r9[-632],r10
8000b572:	2f f8       	sub	r8,-1
8000b574:	fb 48 06 b4 	st.w	sp[1716],r8
8000b578:	c0 88       	rjmp	8000b588 <_vfprintf_r+0x894>
8000b57a:	72 1c       	ld.w	r12,r9[0x4]
8000b57c:	50 7c       	stdsp	sp[0x1c],r12
8000b57e:	f2 c8 ff f8 	sub	r8,r9,-8
8000b582:	51 08       	stdsp	sp[0x40],r8
8000b584:	72 09       	ld.w	r9,r9[0x0]
8000b586:	50 59       	stdsp	sp[0x14],r9
8000b588:	40 5b       	lddsp	r11,sp[0x14]
8000b58a:	40 7a       	lddsp	r10,sp[0x1c]
8000b58c:	e0 a0 19 64 	rcall	8000e854 <__isinfd>
8000b590:	18 96       	mov	r6,r12
8000b592:	c1 50       	breq	8000b5bc <_vfprintf_r+0x8c8>
8000b594:	30 08       	mov	r8,0
8000b596:	30 09       	mov	r9,0
8000b598:	40 5b       	lddsp	r11,sp[0x14]
8000b59a:	40 7a       	lddsp	r10,sp[0x1c]
8000b59c:	e0 a0 1d ba 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000b5a0:	c0 40       	breq	8000b5a8 <_vfprintf_r+0x8b4>
8000b5a2:	32 d8       	mov	r8,45
8000b5a4:	fb 68 06 bb 	st.b	sp[1723],r8
8000b5a8:	4d 18       	lddpc	r8,8000b6ec <_vfprintf_r+0x9f8>
8000b5aa:	4d 26       	lddpc	r6,8000b6f0 <_vfprintf_r+0x9fc>
8000b5ac:	a7 d5       	cbr	r5,0x7
8000b5ae:	e0 40 00 47 	cp.w	r0,71
8000b5b2:	f0 06 17 a0 	movle	r6,r8
8000b5b6:	30 32       	mov	r2,3
8000b5b8:	e0 8f 06 d4 	bral	8000c360 <_vfprintf_r+0x166c>
8000b5bc:	40 5b       	lddsp	r11,sp[0x14]
8000b5be:	40 7a       	lddsp	r10,sp[0x1c]
8000b5c0:	e0 a0 19 5f 	rcall	8000e87e <__isnand>
8000b5c4:	c0 c0       	breq	8000b5dc <_vfprintf_r+0x8e8>
8000b5c6:	50 26       	stdsp	sp[0x8],r6
8000b5c8:	4c b8       	lddpc	r8,8000b6f4 <_vfprintf_r+0xa00>
8000b5ca:	4c c6       	lddpc	r6,8000b6f8 <_vfprintf_r+0xa04>
8000b5cc:	a7 d5       	cbr	r5,0x7
8000b5ce:	e0 40 00 47 	cp.w	r0,71
8000b5d2:	f0 06 17 a0 	movle	r6,r8
8000b5d6:	30 32       	mov	r2,3
8000b5d8:	e0 8f 06 ca 	bral	8000c36c <_vfprintf_r+0x1678>
8000b5dc:	40 2a       	lddsp	r10,sp[0x8]
8000b5de:	5b fa       	cp.w	r10,-1
8000b5e0:	c0 41       	brne	8000b5e8 <_vfprintf_r+0x8f4>
8000b5e2:	30 69       	mov	r9,6
8000b5e4:	50 29       	stdsp	sp[0x8],r9
8000b5e6:	c1 18       	rjmp	8000b608 <_vfprintf_r+0x914>
8000b5e8:	e0 40 00 47 	cp.w	r0,71
8000b5ec:	5f 09       	sreq	r9
8000b5ee:	e0 40 00 67 	cp.w	r0,103
8000b5f2:	5f 08       	sreq	r8
8000b5f4:	f3 e8 10 08 	or	r8,r9,r8
8000b5f8:	f8 08 18 00 	cp.b	r8,r12
8000b5fc:	c0 60       	breq	8000b608 <_vfprintf_r+0x914>
8000b5fe:	40 28       	lddsp	r8,sp[0x8]
8000b600:	58 08       	cp.w	r8,0
8000b602:	f9 b8 00 01 	moveq	r8,1
8000b606:	50 28       	stdsp	sp[0x8],r8
8000b608:	40 78       	lddsp	r8,sp[0x1c]
8000b60a:	40 59       	lddsp	r9,sp[0x14]
8000b60c:	fa e9 06 94 	st.d	sp[1684],r8
8000b610:	a9 a5       	sbr	r5,0x8
8000b612:	fa f8 06 94 	ld.w	r8,sp[1684]
8000b616:	58 08       	cp.w	r8,0
8000b618:	c0 65       	brlt	8000b624 <_vfprintf_r+0x930>
8000b61a:	40 5e       	lddsp	lr,sp[0x14]
8000b61c:	30 0c       	mov	r12,0
8000b61e:	50 6e       	stdsp	sp[0x18],lr
8000b620:	50 9c       	stdsp	sp[0x24],r12
8000b622:	c0 78       	rjmp	8000b630 <_vfprintf_r+0x93c>
8000b624:	40 5b       	lddsp	r11,sp[0x14]
8000b626:	32 da       	mov	r10,45
8000b628:	ee 1b 80 00 	eorh	r11,0x8000
8000b62c:	50 9a       	stdsp	sp[0x24],r10
8000b62e:	50 6b       	stdsp	sp[0x18],r11
8000b630:	e0 40 00 46 	cp.w	r0,70
8000b634:	5f 09       	sreq	r9
8000b636:	e0 40 00 66 	cp.w	r0,102
8000b63a:	5f 08       	sreq	r8
8000b63c:	f3 e8 10 08 	or	r8,r9,r8
8000b640:	50 48       	stdsp	sp[0x10],r8
8000b642:	c0 40       	breq	8000b64a <_vfprintf_r+0x956>
8000b644:	40 22       	lddsp	r2,sp[0x8]
8000b646:	30 39       	mov	r9,3
8000b648:	c1 08       	rjmp	8000b668 <_vfprintf_r+0x974>
8000b64a:	e0 40 00 45 	cp.w	r0,69
8000b64e:	5f 09       	sreq	r9
8000b650:	e0 40 00 65 	cp.w	r0,101
8000b654:	5f 08       	sreq	r8
8000b656:	40 22       	lddsp	r2,sp[0x8]
8000b658:	10 49       	or	r9,r8
8000b65a:	2f f2       	sub	r2,-1
8000b65c:	40 46       	lddsp	r6,sp[0x10]
8000b65e:	ec 09 18 00 	cp.b	r9,r6
8000b662:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000b666:	30 29       	mov	r9,2
8000b668:	fa c8 f9 5c 	sub	r8,sp,-1700
8000b66c:	1a d8       	st.w	--sp,r8
8000b66e:	fa c8 f9 54 	sub	r8,sp,-1708
8000b672:	1a d8       	st.w	--sp,r8
8000b674:	fa c8 f9 4c 	sub	r8,sp,-1716
8000b678:	08 9c       	mov	r12,r4
8000b67a:	1a d8       	st.w	--sp,r8
8000b67c:	04 98       	mov	r8,r2
8000b67e:	40 9b       	lddsp	r11,sp[0x24]
8000b680:	40 aa       	lddsp	r10,sp[0x28]
8000b682:	e0 a0 0b cf 	rcall	8000ce20 <_dtoa_r>
8000b686:	e0 40 00 47 	cp.w	r0,71
8000b68a:	5f 19       	srne	r9
8000b68c:	e0 40 00 67 	cp.w	r0,103
8000b690:	5f 18       	srne	r8
8000b692:	18 96       	mov	r6,r12
8000b694:	2f dd       	sub	sp,-12
8000b696:	f3 e8 00 08 	and	r8,r9,r8
8000b69a:	c0 41       	brne	8000b6a2 <_vfprintf_r+0x9ae>
8000b69c:	ed b5 00 00 	bld	r5,0x0
8000b6a0:	c3 81       	brne	8000b710 <_vfprintf_r+0xa1c>
8000b6a2:	ec 02 00 0e 	add	lr,r6,r2
8000b6a6:	50 3e       	stdsp	sp[0xc],lr
8000b6a8:	40 4c       	lddsp	r12,sp[0x10]
8000b6aa:	58 0c       	cp.w	r12,0
8000b6ac:	c1 50       	breq	8000b6d6 <_vfprintf_r+0x9e2>
8000b6ae:	0d 89       	ld.ub	r9,r6[0x0]
8000b6b0:	33 08       	mov	r8,48
8000b6b2:	f0 09 18 00 	cp.b	r9,r8
8000b6b6:	c0 b1       	brne	8000b6cc <_vfprintf_r+0x9d8>
8000b6b8:	30 08       	mov	r8,0
8000b6ba:	30 09       	mov	r9,0
8000b6bc:	40 6b       	lddsp	r11,sp[0x18]
8000b6be:	40 7a       	lddsp	r10,sp[0x1c]
8000b6c0:	e0 a0 1c e1 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000b6c4:	fb b2 00 01 	rsubeq	r2,1
8000b6c8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000b6cc:	40 3b       	lddsp	r11,sp[0xc]
8000b6ce:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b6d2:	10 0b       	add	r11,r8
8000b6d4:	50 3b       	stdsp	sp[0xc],r11
8000b6d6:	40 6b       	lddsp	r11,sp[0x18]
8000b6d8:	30 08       	mov	r8,0
8000b6da:	30 09       	mov	r9,0
8000b6dc:	40 7a       	lddsp	r10,sp[0x1c]
8000b6de:	e0 a0 1c d2 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000b6e2:	c1 10       	breq	8000b704 <_vfprintf_r+0xa10>
8000b6e4:	40 3a       	lddsp	r10,sp[0xc]
8000b6e6:	fb 4a 06 a4 	st.w	sp[1700],r10
8000b6ea:	c0 d8       	rjmp	8000b704 <_vfprintf_r+0xa10>
8000b6ec:	80 01       	ld.sh	r1,r0[0x0]
8000b6ee:	8f 58       	st.w	r7[0x14],r8
8000b6f0:	80 01       	ld.sh	r1,r0[0x0]
8000b6f2:	8f 5c       	st.w	r7[0x14],r12
8000b6f4:	80 01       	ld.sh	r1,r0[0x0]
8000b6f6:	8f 60       	st.w	r7[0x18],r0
8000b6f8:	80 01       	ld.sh	r1,r0[0x0]
8000b6fa:	8f 64       	st.w	r7[0x18],r4
8000b6fc:	10 c9       	st.b	r8++,r9
8000b6fe:	fb 48 06 a4 	st.w	sp[1700],r8
8000b702:	c0 28       	rjmp	8000b706 <_vfprintf_r+0xa12>
8000b704:	33 09       	mov	r9,48
8000b706:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000b70a:	40 3e       	lddsp	lr,sp[0xc]
8000b70c:	1c 38       	cp.w	r8,lr
8000b70e:	cf 73       	brcs	8000b6fc <_vfprintf_r+0xa08>
8000b710:	e0 40 00 47 	cp.w	r0,71
8000b714:	5f 09       	sreq	r9
8000b716:	e0 40 00 67 	cp.w	r0,103
8000b71a:	5f 08       	sreq	r8
8000b71c:	f3 e8 10 08 	or	r8,r9,r8
8000b720:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000b724:	0c 19       	sub	r9,r6
8000b726:	50 69       	stdsp	sp[0x18],r9
8000b728:	58 08       	cp.w	r8,0
8000b72a:	c0 b0       	breq	8000b740 <_vfprintf_r+0xa4c>
8000b72c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b730:	5b d8       	cp.w	r8,-3
8000b732:	c0 55       	brlt	8000b73c <_vfprintf_r+0xa48>
8000b734:	40 2c       	lddsp	r12,sp[0x8]
8000b736:	18 38       	cp.w	r8,r12
8000b738:	e0 8a 00 6a 	brle	8000b80c <_vfprintf_r+0xb18>
8000b73c:	20 20       	sub	r0,2
8000b73e:	c0 58       	rjmp	8000b748 <_vfprintf_r+0xa54>
8000b740:	e0 40 00 65 	cp.w	r0,101
8000b744:	e0 89 00 46 	brgt	8000b7d0 <_vfprintf_r+0xadc>
8000b748:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000b74c:	fb 60 06 9c 	st.b	sp[1692],r0
8000b750:	20 1b       	sub	r11,1
8000b752:	fb 4b 06 ac 	st.w	sp[1708],r11
8000b756:	c0 47       	brpl	8000b75e <_vfprintf_r+0xa6a>
8000b758:	5c 3b       	neg	r11
8000b75a:	32 d8       	mov	r8,45
8000b75c:	c0 28       	rjmp	8000b760 <_vfprintf_r+0xa6c>
8000b75e:	32 b8       	mov	r8,43
8000b760:	fb 68 06 9d 	st.b	sp[1693],r8
8000b764:	58 9b       	cp.w	r11,9
8000b766:	e0 8a 00 1d 	brle	8000b7a0 <_vfprintf_r+0xaac>
8000b76a:	fa c9 fa 35 	sub	r9,sp,-1483
8000b76e:	30 aa       	mov	r10,10
8000b770:	12 98       	mov	r8,r9
8000b772:	0e 9c       	mov	r12,r7
8000b774:	0c 92       	mov	r2,r6
8000b776:	f6 0a 0c 06 	divs	r6,r11,r10
8000b77a:	0e 9b       	mov	r11,r7
8000b77c:	2d 0b       	sub	r11,-48
8000b77e:	10 fb       	st.b	--r8,r11
8000b780:	0c 9b       	mov	r11,r6
8000b782:	58 96       	cp.w	r6,9
8000b784:	fe 99 ff f9 	brgt	8000b776 <_vfprintf_r+0xa82>
8000b788:	2d 0b       	sub	r11,-48
8000b78a:	18 97       	mov	r7,r12
8000b78c:	04 96       	mov	r6,r2
8000b78e:	10 fb       	st.b	--r8,r11
8000b790:	fa ca f9 62 	sub	r10,sp,-1694
8000b794:	c0 38       	rjmp	8000b79a <_vfprintf_r+0xaa6>
8000b796:	11 3b       	ld.ub	r11,r8++
8000b798:	14 cb       	st.b	r10++,r11
8000b79a:	12 38       	cp.w	r8,r9
8000b79c:	cf d3       	brcs	8000b796 <_vfprintf_r+0xaa2>
8000b79e:	c0 98       	rjmp	8000b7b0 <_vfprintf_r+0xabc>
8000b7a0:	2d 0b       	sub	r11,-48
8000b7a2:	33 08       	mov	r8,48
8000b7a4:	fb 6b 06 9f 	st.b	sp[1695],r11
8000b7a8:	fb 68 06 9e 	st.b	sp[1694],r8
8000b7ac:	fa ca f9 60 	sub	r10,sp,-1696
8000b7b0:	fa c8 f9 64 	sub	r8,sp,-1692
8000b7b4:	f4 08 01 08 	sub	r8,r10,r8
8000b7b8:	50 e8       	stdsp	sp[0x38],r8
8000b7ba:	10 92       	mov	r2,r8
8000b7bc:	40 6b       	lddsp	r11,sp[0x18]
8000b7be:	16 02       	add	r2,r11
8000b7c0:	58 1b       	cp.w	r11,1
8000b7c2:	e0 89 00 05 	brgt	8000b7cc <_vfprintf_r+0xad8>
8000b7c6:	ed b5 00 00 	bld	r5,0x0
8000b7ca:	c3 51       	brne	8000b834 <_vfprintf_r+0xb40>
8000b7cc:	2f f2       	sub	r2,-1
8000b7ce:	c3 38       	rjmp	8000b834 <_vfprintf_r+0xb40>
8000b7d0:	e0 40 00 66 	cp.w	r0,102
8000b7d4:	c1 c1       	brne	8000b80c <_vfprintf_r+0xb18>
8000b7d6:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b7da:	58 02       	cp.w	r2,0
8000b7dc:	e0 8a 00 0c 	brle	8000b7f4 <_vfprintf_r+0xb00>
8000b7e0:	40 2a       	lddsp	r10,sp[0x8]
8000b7e2:	58 0a       	cp.w	r10,0
8000b7e4:	c0 41       	brne	8000b7ec <_vfprintf_r+0xaf8>
8000b7e6:	ed b5 00 00 	bld	r5,0x0
8000b7ea:	c2 51       	brne	8000b834 <_vfprintf_r+0xb40>
8000b7ec:	2f f2       	sub	r2,-1
8000b7ee:	40 29       	lddsp	r9,sp[0x8]
8000b7f0:	12 02       	add	r2,r9
8000b7f2:	c0 b8       	rjmp	8000b808 <_vfprintf_r+0xb14>
8000b7f4:	40 28       	lddsp	r8,sp[0x8]
8000b7f6:	58 08       	cp.w	r8,0
8000b7f8:	c0 61       	brne	8000b804 <_vfprintf_r+0xb10>
8000b7fa:	ed b5 00 00 	bld	r5,0x0
8000b7fe:	c0 30       	breq	8000b804 <_vfprintf_r+0xb10>
8000b800:	30 12       	mov	r2,1
8000b802:	c1 98       	rjmp	8000b834 <_vfprintf_r+0xb40>
8000b804:	40 22       	lddsp	r2,sp[0x8]
8000b806:	2f e2       	sub	r2,-2
8000b808:	36 60       	mov	r0,102
8000b80a:	c1 58       	rjmp	8000b834 <_vfprintf_r+0xb40>
8000b80c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b810:	40 6e       	lddsp	lr,sp[0x18]
8000b812:	1c 32       	cp.w	r2,lr
8000b814:	c0 65       	brlt	8000b820 <_vfprintf_r+0xb2c>
8000b816:	ed b5 00 00 	bld	r5,0x0
8000b81a:	f7 b2 00 ff 	subeq	r2,-1
8000b81e:	c0 a8       	rjmp	8000b832 <_vfprintf_r+0xb3e>
8000b820:	e4 08 11 02 	rsub	r8,r2,2
8000b824:	40 6c       	lddsp	r12,sp[0x18]
8000b826:	58 02       	cp.w	r2,0
8000b828:	f0 02 17 a0 	movle	r2,r8
8000b82c:	f9 b2 09 01 	movgt	r2,1
8000b830:	18 02       	add	r2,r12
8000b832:	36 70       	mov	r0,103
8000b834:	40 9b       	lddsp	r11,sp[0x24]
8000b836:	58 0b       	cp.w	r11,0
8000b838:	e0 80 05 94 	breq	8000c360 <_vfprintf_r+0x166c>
8000b83c:	32 d8       	mov	r8,45
8000b83e:	fb 68 06 bb 	st.b	sp[1723],r8
8000b842:	e0 8f 05 93 	bral	8000c368 <_vfprintf_r+0x1674>
8000b846:	50 a7       	stdsp	sp[0x28],r7
8000b848:	04 94       	mov	r4,r2
8000b84a:	0c 97       	mov	r7,r6
8000b84c:	02 92       	mov	r2,r1
8000b84e:	06 96       	mov	r6,r3
8000b850:	40 41       	lddsp	r1,sp[0x10]
8000b852:	40 93       	lddsp	r3,sp[0x24]
8000b854:	0e 99       	mov	r9,r7
8000b856:	ed b5 00 05 	bld	r5,0x5
8000b85a:	c4 81       	brne	8000b8ea <_vfprintf_r+0xbf6>
8000b85c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b860:	40 3e       	lddsp	lr,sp[0xc]
8000b862:	58 0e       	cp.w	lr,0
8000b864:	c1 d0       	breq	8000b89e <_vfprintf_r+0xbaa>
8000b866:	10 36       	cp.w	r6,r8
8000b868:	c0 64       	brge	8000b874 <_vfprintf_r+0xb80>
8000b86a:	fa cc f9 44 	sub	r12,sp,-1724
8000b86e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b872:	c1 d8       	rjmp	8000b8ac <_vfprintf_r+0xbb8>
8000b874:	fa c8 f9 50 	sub	r8,sp,-1712
8000b878:	1a d8       	st.w	--sp,r8
8000b87a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b87e:	04 9a       	mov	r10,r2
8000b880:	1a d8       	st.w	--sp,r8
8000b882:	fa c8 fb b4 	sub	r8,sp,-1100
8000b886:	0c 9b       	mov	r11,r6
8000b888:	1a d8       	st.w	--sp,r8
8000b88a:	08 9c       	mov	r12,r4
8000b88c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b890:	fa c9 ff b4 	sub	r9,sp,-76
8000b894:	fe b0 f8 92 	rcall	8000a9b8 <get_arg>
8000b898:	2f dd       	sub	sp,-12
8000b89a:	78 0a       	ld.w	r10,r12[0x0]
8000b89c:	c2 08       	rjmp	8000b8dc <_vfprintf_r+0xbe8>
8000b89e:	2f f7       	sub	r7,-1
8000b8a0:	10 39       	cp.w	r9,r8
8000b8a2:	c0 84       	brge	8000b8b2 <_vfprintf_r+0xbbe>
8000b8a4:	fa cb f9 44 	sub	r11,sp,-1724
8000b8a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b8ac:	ec fa fd 88 	ld.w	r10,r6[-632]
8000b8b0:	c1 68       	rjmp	8000b8dc <_vfprintf_r+0xbe8>
8000b8b2:	41 09       	lddsp	r9,sp[0x40]
8000b8b4:	59 f8       	cp.w	r8,31
8000b8b6:	e0 89 00 10 	brgt	8000b8d6 <_vfprintf_r+0xbe2>
8000b8ba:	f2 ca ff fc 	sub	r10,r9,-4
8000b8be:	51 0a       	stdsp	sp[0x40],r10
8000b8c0:	fa c6 f9 44 	sub	r6,sp,-1724
8000b8c4:	72 0a       	ld.w	r10,r9[0x0]
8000b8c6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b8ca:	f3 4a fd 88 	st.w	r9[-632],r10
8000b8ce:	2f f8       	sub	r8,-1
8000b8d0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b8d4:	c0 48       	rjmp	8000b8dc <_vfprintf_r+0xbe8>
8000b8d6:	72 0a       	ld.w	r10,r9[0x0]
8000b8d8:	2f c9       	sub	r9,-4
8000b8da:	51 09       	stdsp	sp[0x40],r9
8000b8dc:	40 be       	lddsp	lr,sp[0x2c]
8000b8de:	1c 98       	mov	r8,lr
8000b8e0:	95 1e       	st.w	r10[0x4],lr
8000b8e2:	bf 58       	asr	r8,0x1f
8000b8e4:	95 08       	st.w	r10[0x0],r8
8000b8e6:	fe 9f fa 92 	bral	8000ae0a <_vfprintf_r+0x116>
8000b8ea:	ed b5 00 04 	bld	r5,0x4
8000b8ee:	c4 80       	breq	8000b97e <_vfprintf_r+0xc8a>
8000b8f0:	e2 15 00 40 	andl	r5,0x40,COH
8000b8f4:	c4 50       	breq	8000b97e <_vfprintf_r+0xc8a>
8000b8f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b8fa:	40 3c       	lddsp	r12,sp[0xc]
8000b8fc:	58 0c       	cp.w	r12,0
8000b8fe:	c1 d0       	breq	8000b938 <_vfprintf_r+0xc44>
8000b900:	10 36       	cp.w	r6,r8
8000b902:	c0 64       	brge	8000b90e <_vfprintf_r+0xc1a>
8000b904:	fa cb f9 44 	sub	r11,sp,-1724
8000b908:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b90c:	c1 d8       	rjmp	8000b946 <_vfprintf_r+0xc52>
8000b90e:	fa c8 f9 50 	sub	r8,sp,-1712
8000b912:	1a d8       	st.w	--sp,r8
8000b914:	fa c8 fa b8 	sub	r8,sp,-1352
8000b918:	04 9a       	mov	r10,r2
8000b91a:	1a d8       	st.w	--sp,r8
8000b91c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b920:	0c 9b       	mov	r11,r6
8000b922:	1a d8       	st.w	--sp,r8
8000b924:	08 9c       	mov	r12,r4
8000b926:	fa c8 f9 40 	sub	r8,sp,-1728
8000b92a:	fa c9 ff b4 	sub	r9,sp,-76
8000b92e:	fe b0 f8 45 	rcall	8000a9b8 <get_arg>
8000b932:	2f dd       	sub	sp,-12
8000b934:	78 0a       	ld.w	r10,r12[0x0]
8000b936:	c2 08       	rjmp	8000b976 <_vfprintf_r+0xc82>
8000b938:	2f f7       	sub	r7,-1
8000b93a:	10 39       	cp.w	r9,r8
8000b93c:	c0 84       	brge	8000b94c <_vfprintf_r+0xc58>
8000b93e:	fa ca f9 44 	sub	r10,sp,-1724
8000b942:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b946:	ec fa fd 88 	ld.w	r10,r6[-632]
8000b94a:	c1 68       	rjmp	8000b976 <_vfprintf_r+0xc82>
8000b94c:	41 09       	lddsp	r9,sp[0x40]
8000b94e:	59 f8       	cp.w	r8,31
8000b950:	e0 89 00 10 	brgt	8000b970 <_vfprintf_r+0xc7c>
8000b954:	f2 ca ff fc 	sub	r10,r9,-4
8000b958:	51 0a       	stdsp	sp[0x40],r10
8000b95a:	fa c6 f9 44 	sub	r6,sp,-1724
8000b95e:	72 0a       	ld.w	r10,r9[0x0]
8000b960:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b964:	f3 4a fd 88 	st.w	r9[-632],r10
8000b968:	2f f8       	sub	r8,-1
8000b96a:	fb 48 06 b4 	st.w	sp[1716],r8
8000b96e:	c0 48       	rjmp	8000b976 <_vfprintf_r+0xc82>
8000b970:	72 0a       	ld.w	r10,r9[0x0]
8000b972:	2f c9       	sub	r9,-4
8000b974:	51 09       	stdsp	sp[0x40],r9
8000b976:	40 be       	lddsp	lr,sp[0x2c]
8000b978:	b4 0e       	st.h	r10[0x0],lr
8000b97a:	fe 9f fa 48 	bral	8000ae0a <_vfprintf_r+0x116>
8000b97e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b982:	40 3c       	lddsp	r12,sp[0xc]
8000b984:	58 0c       	cp.w	r12,0
8000b986:	c1 d0       	breq	8000b9c0 <_vfprintf_r+0xccc>
8000b988:	10 36       	cp.w	r6,r8
8000b98a:	c0 64       	brge	8000b996 <_vfprintf_r+0xca2>
8000b98c:	fa cb f9 44 	sub	r11,sp,-1724
8000b990:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b994:	c1 d8       	rjmp	8000b9ce <_vfprintf_r+0xcda>
8000b996:	fa c8 f9 50 	sub	r8,sp,-1712
8000b99a:	1a d8       	st.w	--sp,r8
8000b99c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b9a0:	04 9a       	mov	r10,r2
8000b9a2:	1a d8       	st.w	--sp,r8
8000b9a4:	fa c8 fb b4 	sub	r8,sp,-1100
8000b9a8:	0c 9b       	mov	r11,r6
8000b9aa:	1a d8       	st.w	--sp,r8
8000b9ac:	08 9c       	mov	r12,r4
8000b9ae:	fa c8 f9 40 	sub	r8,sp,-1728
8000b9b2:	fa c9 ff b4 	sub	r9,sp,-76
8000b9b6:	fe b0 f8 01 	rcall	8000a9b8 <get_arg>
8000b9ba:	2f dd       	sub	sp,-12
8000b9bc:	78 0a       	ld.w	r10,r12[0x0]
8000b9be:	c2 08       	rjmp	8000b9fe <_vfprintf_r+0xd0a>
8000b9c0:	2f f7       	sub	r7,-1
8000b9c2:	10 39       	cp.w	r9,r8
8000b9c4:	c0 84       	brge	8000b9d4 <_vfprintf_r+0xce0>
8000b9c6:	fa ca f9 44 	sub	r10,sp,-1724
8000b9ca:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b9ce:	ec fa fd 88 	ld.w	r10,r6[-632]
8000b9d2:	c1 68       	rjmp	8000b9fe <_vfprintf_r+0xd0a>
8000b9d4:	41 09       	lddsp	r9,sp[0x40]
8000b9d6:	59 f8       	cp.w	r8,31
8000b9d8:	e0 89 00 10 	brgt	8000b9f8 <_vfprintf_r+0xd04>
8000b9dc:	f2 ca ff fc 	sub	r10,r9,-4
8000b9e0:	51 0a       	stdsp	sp[0x40],r10
8000b9e2:	fa c6 f9 44 	sub	r6,sp,-1724
8000b9e6:	72 0a       	ld.w	r10,r9[0x0]
8000b9e8:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b9ec:	f3 4a fd 88 	st.w	r9[-632],r10
8000b9f0:	2f f8       	sub	r8,-1
8000b9f2:	fb 48 06 b4 	st.w	sp[1716],r8
8000b9f6:	c0 48       	rjmp	8000b9fe <_vfprintf_r+0xd0a>
8000b9f8:	72 0a       	ld.w	r10,r9[0x0]
8000b9fa:	2f c9       	sub	r9,-4
8000b9fc:	51 09       	stdsp	sp[0x40],r9
8000b9fe:	40 be       	lddsp	lr,sp[0x2c]
8000ba00:	95 0e       	st.w	r10[0x0],lr
8000ba02:	fe 9f fa 04 	bral	8000ae0a <_vfprintf_r+0x116>
8000ba06:	50 a7       	stdsp	sp[0x28],r7
8000ba08:	50 80       	stdsp	sp[0x20],r0
8000ba0a:	0c 97       	mov	r7,r6
8000ba0c:	04 94       	mov	r4,r2
8000ba0e:	06 96       	mov	r6,r3
8000ba10:	02 92       	mov	r2,r1
8000ba12:	40 93       	lddsp	r3,sp[0x24]
8000ba14:	10 90       	mov	r0,r8
8000ba16:	40 41       	lddsp	r1,sp[0x10]
8000ba18:	a5 a5       	sbr	r5,0x4
8000ba1a:	c0 a8       	rjmp	8000ba2e <_vfprintf_r+0xd3a>
8000ba1c:	50 a7       	stdsp	sp[0x28],r7
8000ba1e:	50 80       	stdsp	sp[0x20],r0
8000ba20:	0c 97       	mov	r7,r6
8000ba22:	04 94       	mov	r4,r2
8000ba24:	06 96       	mov	r6,r3
8000ba26:	02 92       	mov	r2,r1
8000ba28:	40 93       	lddsp	r3,sp[0x24]
8000ba2a:	10 90       	mov	r0,r8
8000ba2c:	40 41       	lddsp	r1,sp[0x10]
8000ba2e:	ed b5 00 05 	bld	r5,0x5
8000ba32:	c5 d1       	brne	8000baec <_vfprintf_r+0xdf8>
8000ba34:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba38:	40 3c       	lddsp	r12,sp[0xc]
8000ba3a:	58 0c       	cp.w	r12,0
8000ba3c:	c2 60       	breq	8000ba88 <_vfprintf_r+0xd94>
8000ba3e:	10 36       	cp.w	r6,r8
8000ba40:	c0 a4       	brge	8000ba54 <_vfprintf_r+0xd60>
8000ba42:	fa cb f9 44 	sub	r11,sp,-1724
8000ba46:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ba4a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000ba4e:	fa e9 00 00 	st.d	sp[0],r8
8000ba52:	c1 88       	rjmp	8000ba82 <_vfprintf_r+0xd8e>
8000ba54:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba58:	1a d8       	st.w	--sp,r8
8000ba5a:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba5e:	04 9a       	mov	r10,r2
8000ba60:	1a d8       	st.w	--sp,r8
8000ba62:	0c 9b       	mov	r11,r6
8000ba64:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba68:	08 9c       	mov	r12,r4
8000ba6a:	1a d8       	st.w	--sp,r8
8000ba6c:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba70:	fa c9 ff b4 	sub	r9,sp,-76
8000ba74:	fe b0 f7 a2 	rcall	8000a9b8 <get_arg>
8000ba78:	2f dd       	sub	sp,-12
8000ba7a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000ba7e:	fa eb 00 00 	st.d	sp[0],r10
8000ba82:	30 08       	mov	r8,0
8000ba84:	e0 8f 03 de 	bral	8000c240 <_vfprintf_r+0x154c>
8000ba88:	ee ca ff ff 	sub	r10,r7,-1
8000ba8c:	10 37       	cp.w	r7,r8
8000ba8e:	c0 b4       	brge	8000baa4 <_vfprintf_r+0xdb0>
8000ba90:	fa c9 f9 44 	sub	r9,sp,-1724
8000ba94:	14 97       	mov	r7,r10
8000ba96:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ba9a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000ba9e:	fa eb 00 00 	st.d	sp[0],r10
8000baa2:	c1 88       	rjmp	8000bad2 <_vfprintf_r+0xdde>
8000baa4:	41 09       	lddsp	r9,sp[0x40]
8000baa6:	59 f8       	cp.w	r8,31
8000baa8:	e0 89 00 18 	brgt	8000bad8 <_vfprintf_r+0xde4>
8000baac:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bab0:	f2 cb ff f8 	sub	r11,r9,-8
8000bab4:	fa e7 00 00 	st.d	sp[0],r6
8000bab8:	51 0b       	stdsp	sp[0x40],r11
8000baba:	fa c6 f9 44 	sub	r6,sp,-1724
8000babe:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bac2:	fa e6 00 00 	ld.d	r6,sp[0]
8000bac6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000baca:	2f f8       	sub	r8,-1
8000bacc:	14 97       	mov	r7,r10
8000bace:	fb 48 06 b4 	st.w	sp[1716],r8
8000bad2:	40 38       	lddsp	r8,sp[0xc]
8000bad4:	e0 8f 03 b6 	bral	8000c240 <_vfprintf_r+0x154c>
8000bad8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000badc:	40 38       	lddsp	r8,sp[0xc]
8000bade:	fa e7 00 00 	st.d	sp[0],r6
8000bae2:	2f 89       	sub	r9,-8
8000bae4:	14 97       	mov	r7,r10
8000bae6:	51 09       	stdsp	sp[0x40],r9
8000bae8:	e0 8f 03 ac 	bral	8000c240 <_vfprintf_r+0x154c>
8000baec:	ed b5 00 04 	bld	r5,0x4
8000baf0:	c1 61       	brne	8000bb1c <_vfprintf_r+0xe28>
8000baf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000baf6:	40 3e       	lddsp	lr,sp[0xc]
8000baf8:	58 0e       	cp.w	lr,0
8000bafa:	c0 80       	breq	8000bb0a <_vfprintf_r+0xe16>
8000bafc:	10 36       	cp.w	r6,r8
8000bafe:	c6 74       	brge	8000bbcc <_vfprintf_r+0xed8>
8000bb00:	fa cc f9 44 	sub	r12,sp,-1724
8000bb04:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bb08:	c8 08       	rjmp	8000bc08 <_vfprintf_r+0xf14>
8000bb0a:	ee ca ff ff 	sub	r10,r7,-1
8000bb0e:	10 37       	cp.w	r7,r8
8000bb10:	c7 f4       	brge	8000bc0e <_vfprintf_r+0xf1a>
8000bb12:	fa cb f9 44 	sub	r11,sp,-1724
8000bb16:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb1a:	c7 68       	rjmp	8000bc06 <_vfprintf_r+0xf12>
8000bb1c:	ed b5 00 06 	bld	r5,0x6
8000bb20:	c4 a1       	brne	8000bbb4 <_vfprintf_r+0xec0>
8000bb22:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb26:	40 3c       	lddsp	r12,sp[0xc]
8000bb28:	58 0c       	cp.w	r12,0
8000bb2a:	c1 d0       	breq	8000bb64 <_vfprintf_r+0xe70>
8000bb2c:	10 36       	cp.w	r6,r8
8000bb2e:	c0 64       	brge	8000bb3a <_vfprintf_r+0xe46>
8000bb30:	fa cb f9 44 	sub	r11,sp,-1724
8000bb34:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb38:	c1 f8       	rjmp	8000bb76 <_vfprintf_r+0xe82>
8000bb3a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb3e:	1a d8       	st.w	--sp,r8
8000bb40:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb44:	1a d8       	st.w	--sp,r8
8000bb46:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb4a:	1a d8       	st.w	--sp,r8
8000bb4c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bb50:	fa c9 ff b4 	sub	r9,sp,-76
8000bb54:	04 9a       	mov	r10,r2
8000bb56:	0c 9b       	mov	r11,r6
8000bb58:	08 9c       	mov	r12,r4
8000bb5a:	fe b0 f7 2f 	rcall	8000a9b8 <get_arg>
8000bb5e:	2f dd       	sub	sp,-12
8000bb60:	98 18       	ld.sh	r8,r12[0x2]
8000bb62:	c2 68       	rjmp	8000bbae <_vfprintf_r+0xeba>
8000bb64:	ee ca ff ff 	sub	r10,r7,-1
8000bb68:	10 37       	cp.w	r7,r8
8000bb6a:	c0 94       	brge	8000bb7c <_vfprintf_r+0xe88>
8000bb6c:	fa c9 f9 44 	sub	r9,sp,-1724
8000bb70:	14 97       	mov	r7,r10
8000bb72:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bb76:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bb7a:	c1 a8       	rjmp	8000bbae <_vfprintf_r+0xeba>
8000bb7c:	41 09       	lddsp	r9,sp[0x40]
8000bb7e:	59 f8       	cp.w	r8,31
8000bb80:	e0 89 00 13 	brgt	8000bba6 <_vfprintf_r+0xeb2>
8000bb84:	f2 cb ff fc 	sub	r11,r9,-4
8000bb88:	51 0b       	stdsp	sp[0x40],r11
8000bb8a:	72 09       	ld.w	r9,r9[0x0]
8000bb8c:	fa c6 f9 44 	sub	r6,sp,-1724
8000bb90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bb94:	2f f8       	sub	r8,-1
8000bb96:	f7 49 fd 88 	st.w	r11[-632],r9
8000bb9a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bb9e:	14 97       	mov	r7,r10
8000bba0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bba4:	c0 58       	rjmp	8000bbae <_vfprintf_r+0xeba>
8000bba6:	92 18       	ld.sh	r8,r9[0x2]
8000bba8:	14 97       	mov	r7,r10
8000bbaa:	2f c9       	sub	r9,-4
8000bbac:	51 09       	stdsp	sp[0x40],r9
8000bbae:	5c 78       	castu.h	r8
8000bbb0:	50 18       	stdsp	sp[0x4],r8
8000bbb2:	c4 68       	rjmp	8000bc3e <_vfprintf_r+0xf4a>
8000bbb4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bbb8:	40 3c       	lddsp	r12,sp[0xc]
8000bbba:	58 0c       	cp.w	r12,0
8000bbbc:	c1 d0       	breq	8000bbf6 <_vfprintf_r+0xf02>
8000bbbe:	10 36       	cp.w	r6,r8
8000bbc0:	c0 64       	brge	8000bbcc <_vfprintf_r+0xed8>
8000bbc2:	fa cb f9 44 	sub	r11,sp,-1724
8000bbc6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bbca:	c1 f8       	rjmp	8000bc08 <_vfprintf_r+0xf14>
8000bbcc:	fa c8 f9 50 	sub	r8,sp,-1712
8000bbd0:	1a d8       	st.w	--sp,r8
8000bbd2:	fa c8 fa b8 	sub	r8,sp,-1352
8000bbd6:	0c 9b       	mov	r11,r6
8000bbd8:	1a d8       	st.w	--sp,r8
8000bbda:	fa c8 fb b4 	sub	r8,sp,-1100
8000bbde:	04 9a       	mov	r10,r2
8000bbe0:	1a d8       	st.w	--sp,r8
8000bbe2:	08 9c       	mov	r12,r4
8000bbe4:	fa c8 f9 40 	sub	r8,sp,-1728
8000bbe8:	fa c9 ff b4 	sub	r9,sp,-76
8000bbec:	fe b0 f6 e6 	rcall	8000a9b8 <get_arg>
8000bbf0:	2f dd       	sub	sp,-12
8000bbf2:	78 0b       	ld.w	r11,r12[0x0]
8000bbf4:	c2 48       	rjmp	8000bc3c <_vfprintf_r+0xf48>
8000bbf6:	ee ca ff ff 	sub	r10,r7,-1
8000bbfa:	10 37       	cp.w	r7,r8
8000bbfc:	c0 94       	brge	8000bc0e <_vfprintf_r+0xf1a>
8000bbfe:	fa c9 f9 44 	sub	r9,sp,-1724
8000bc02:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bc06:	14 97       	mov	r7,r10
8000bc08:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bc0c:	c1 88       	rjmp	8000bc3c <_vfprintf_r+0xf48>
8000bc0e:	41 09       	lddsp	r9,sp[0x40]
8000bc10:	59 f8       	cp.w	r8,31
8000bc12:	e0 89 00 11 	brgt	8000bc34 <_vfprintf_r+0xf40>
8000bc16:	f2 cb ff fc 	sub	r11,r9,-4
8000bc1a:	51 0b       	stdsp	sp[0x40],r11
8000bc1c:	fa c6 f9 44 	sub	r6,sp,-1724
8000bc20:	72 0b       	ld.w	r11,r9[0x0]
8000bc22:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bc26:	f3 4b fd 88 	st.w	r9[-632],r11
8000bc2a:	2f f8       	sub	r8,-1
8000bc2c:	14 97       	mov	r7,r10
8000bc2e:	fb 48 06 b4 	st.w	sp[1716],r8
8000bc32:	c0 58       	rjmp	8000bc3c <_vfprintf_r+0xf48>
8000bc34:	72 0b       	ld.w	r11,r9[0x0]
8000bc36:	14 97       	mov	r7,r10
8000bc38:	2f c9       	sub	r9,-4
8000bc3a:	51 09       	stdsp	sp[0x40],r9
8000bc3c:	50 1b       	stdsp	sp[0x4],r11
8000bc3e:	30 0e       	mov	lr,0
8000bc40:	50 0e       	stdsp	sp[0x0],lr
8000bc42:	1c 98       	mov	r8,lr
8000bc44:	e0 8f 02 fe 	bral	8000c240 <_vfprintf_r+0x154c>
8000bc48:	50 a7       	stdsp	sp[0x28],r7
8000bc4a:	50 80       	stdsp	sp[0x20],r0
8000bc4c:	0c 97       	mov	r7,r6
8000bc4e:	04 94       	mov	r4,r2
8000bc50:	06 96       	mov	r6,r3
8000bc52:	02 92       	mov	r2,r1
8000bc54:	40 93       	lddsp	r3,sp[0x24]
8000bc56:	40 41       	lddsp	r1,sp[0x10]
8000bc58:	0e 99       	mov	r9,r7
8000bc5a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc5e:	40 3c       	lddsp	r12,sp[0xc]
8000bc60:	58 0c       	cp.w	r12,0
8000bc62:	c1 d0       	breq	8000bc9c <_vfprintf_r+0xfa8>
8000bc64:	10 36       	cp.w	r6,r8
8000bc66:	c0 64       	brge	8000bc72 <_vfprintf_r+0xf7e>
8000bc68:	fa cb f9 44 	sub	r11,sp,-1724
8000bc6c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc70:	c1 d8       	rjmp	8000bcaa <_vfprintf_r+0xfb6>
8000bc72:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc76:	1a d8       	st.w	--sp,r8
8000bc78:	fa c8 fa b8 	sub	r8,sp,-1352
8000bc7c:	1a d8       	st.w	--sp,r8
8000bc7e:	fa c8 fb b4 	sub	r8,sp,-1100
8000bc82:	1a d8       	st.w	--sp,r8
8000bc84:	fa c9 ff b4 	sub	r9,sp,-76
8000bc88:	fa c8 f9 40 	sub	r8,sp,-1728
8000bc8c:	04 9a       	mov	r10,r2
8000bc8e:	0c 9b       	mov	r11,r6
8000bc90:	08 9c       	mov	r12,r4
8000bc92:	fe b0 f6 93 	rcall	8000a9b8 <get_arg>
8000bc96:	2f dd       	sub	sp,-12
8000bc98:	78 09       	ld.w	r9,r12[0x0]
8000bc9a:	c2 18       	rjmp	8000bcdc <_vfprintf_r+0xfe8>
8000bc9c:	2f f7       	sub	r7,-1
8000bc9e:	10 39       	cp.w	r9,r8
8000bca0:	c0 84       	brge	8000bcb0 <_vfprintf_r+0xfbc>
8000bca2:	fa ca f9 44 	sub	r10,sp,-1724
8000bca6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bcaa:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000bcae:	c1 78       	rjmp	8000bcdc <_vfprintf_r+0xfe8>
8000bcb0:	41 09       	lddsp	r9,sp[0x40]
8000bcb2:	59 f8       	cp.w	r8,31
8000bcb4:	e0 89 00 10 	brgt	8000bcd4 <_vfprintf_r+0xfe0>
8000bcb8:	f2 ca ff fc 	sub	r10,r9,-4
8000bcbc:	51 0a       	stdsp	sp[0x40],r10
8000bcbe:	fa c6 f9 44 	sub	r6,sp,-1724
8000bcc2:	72 09       	ld.w	r9,r9[0x0]
8000bcc4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000bcc8:	f5 49 fd 88 	st.w	r10[-632],r9
8000bccc:	2f f8       	sub	r8,-1
8000bcce:	fb 48 06 b4 	st.w	sp[1716],r8
8000bcd2:	c0 58       	rjmp	8000bcdc <_vfprintf_r+0xfe8>
8000bcd4:	f2 c8 ff fc 	sub	r8,r9,-4
8000bcd8:	51 08       	stdsp	sp[0x40],r8
8000bcda:	72 09       	ld.w	r9,r9[0x0]
8000bcdc:	33 08       	mov	r8,48
8000bcde:	fb 68 06 b8 	st.b	sp[1720],r8
8000bce2:	37 88       	mov	r8,120
8000bce4:	30 0e       	mov	lr,0
8000bce6:	fb 68 06 b9 	st.b	sp[1721],r8
8000bcea:	4c ac       	lddpc	r12,8000be10 <_vfprintf_r+0x111c>
8000bcec:	50 19       	stdsp	sp[0x4],r9
8000bcee:	a1 b5       	sbr	r5,0x1
8000bcf0:	50 0e       	stdsp	sp[0x0],lr
8000bcf2:	50 dc       	stdsp	sp[0x34],r12
8000bcf4:	30 28       	mov	r8,2
8000bcf6:	37 80       	mov	r0,120
8000bcf8:	e0 8f 02 a4 	bral	8000c240 <_vfprintf_r+0x154c>
8000bcfc:	50 a7       	stdsp	sp[0x28],r7
8000bcfe:	50 80       	stdsp	sp[0x20],r0
8000bd00:	10 90       	mov	r0,r8
8000bd02:	30 08       	mov	r8,0
8000bd04:	fb 68 06 bb 	st.b	sp[1723],r8
8000bd08:	0c 97       	mov	r7,r6
8000bd0a:	04 94       	mov	r4,r2
8000bd0c:	06 96       	mov	r6,r3
8000bd0e:	02 92       	mov	r2,r1
8000bd10:	40 93       	lddsp	r3,sp[0x24]
8000bd12:	40 41       	lddsp	r1,sp[0x10]
8000bd14:	0e 99       	mov	r9,r7
8000bd16:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd1a:	40 3b       	lddsp	r11,sp[0xc]
8000bd1c:	58 0b       	cp.w	r11,0
8000bd1e:	c1 d0       	breq	8000bd58 <_vfprintf_r+0x1064>
8000bd20:	10 36       	cp.w	r6,r8
8000bd22:	c0 64       	brge	8000bd2e <_vfprintf_r+0x103a>
8000bd24:	fa ca f9 44 	sub	r10,sp,-1724
8000bd28:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bd2c:	c1 d8       	rjmp	8000bd66 <_vfprintf_r+0x1072>
8000bd2e:	fa c8 f9 50 	sub	r8,sp,-1712
8000bd32:	1a d8       	st.w	--sp,r8
8000bd34:	fa c8 fa b8 	sub	r8,sp,-1352
8000bd38:	1a d8       	st.w	--sp,r8
8000bd3a:	fa c8 fb b4 	sub	r8,sp,-1100
8000bd3e:	0c 9b       	mov	r11,r6
8000bd40:	1a d8       	st.w	--sp,r8
8000bd42:	04 9a       	mov	r10,r2
8000bd44:	fa c8 f9 40 	sub	r8,sp,-1728
8000bd48:	fa c9 ff b4 	sub	r9,sp,-76
8000bd4c:	08 9c       	mov	r12,r4
8000bd4e:	fe b0 f6 35 	rcall	8000a9b8 <get_arg>
8000bd52:	2f dd       	sub	sp,-12
8000bd54:	78 06       	ld.w	r6,r12[0x0]
8000bd56:	c2 08       	rjmp	8000bd96 <_vfprintf_r+0x10a2>
8000bd58:	2f f7       	sub	r7,-1
8000bd5a:	10 39       	cp.w	r9,r8
8000bd5c:	c0 84       	brge	8000bd6c <_vfprintf_r+0x1078>
8000bd5e:	fa c9 f9 44 	sub	r9,sp,-1724
8000bd62:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bd66:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000bd6a:	c1 68       	rjmp	8000bd96 <_vfprintf_r+0x10a2>
8000bd6c:	41 09       	lddsp	r9,sp[0x40]
8000bd6e:	59 f8       	cp.w	r8,31
8000bd70:	e0 89 00 10 	brgt	8000bd90 <_vfprintf_r+0x109c>
8000bd74:	f2 ca ff fc 	sub	r10,r9,-4
8000bd78:	51 0a       	stdsp	sp[0x40],r10
8000bd7a:	72 06       	ld.w	r6,r9[0x0]
8000bd7c:	fa ce f9 44 	sub	lr,sp,-1724
8000bd80:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000bd84:	f3 46 fd 88 	st.w	r9[-632],r6
8000bd88:	2f f8       	sub	r8,-1
8000bd8a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bd8e:	c0 48       	rjmp	8000bd96 <_vfprintf_r+0x10a2>
8000bd90:	72 06       	ld.w	r6,r9[0x0]
8000bd92:	2f c9       	sub	r9,-4
8000bd94:	51 09       	stdsp	sp[0x40],r9
8000bd96:	40 2c       	lddsp	r12,sp[0x8]
8000bd98:	58 0c       	cp.w	r12,0
8000bd9a:	c1 05       	brlt	8000bdba <_vfprintf_r+0x10c6>
8000bd9c:	18 9a       	mov	r10,r12
8000bd9e:	30 0b       	mov	r11,0
8000bda0:	0c 9c       	mov	r12,r6
8000bda2:	e0 a0 12 43 	rcall	8000e228 <memchr>
8000bda6:	e0 80 02 e0 	breq	8000c366 <_vfprintf_r+0x1672>
8000bdaa:	f8 06 01 02 	sub	r2,r12,r6
8000bdae:	40 2b       	lddsp	r11,sp[0x8]
8000bdb0:	16 32       	cp.w	r2,r11
8000bdb2:	e0 89 02 da 	brgt	8000c366 <_vfprintf_r+0x1672>
8000bdb6:	e0 8f 02 d5 	bral	8000c360 <_vfprintf_r+0x166c>
8000bdba:	30 0a       	mov	r10,0
8000bdbc:	0c 9c       	mov	r12,r6
8000bdbe:	50 2a       	stdsp	sp[0x8],r10
8000bdc0:	fe b0 f4 ff 	rcall	8000a7be <strlen>
8000bdc4:	18 92       	mov	r2,r12
8000bdc6:	e0 8f 02 d3 	bral	8000c36c <_vfprintf_r+0x1678>
8000bdca:	50 a7       	stdsp	sp[0x28],r7
8000bdcc:	50 80       	stdsp	sp[0x20],r0
8000bdce:	0c 97       	mov	r7,r6
8000bdd0:	04 94       	mov	r4,r2
8000bdd2:	06 96       	mov	r6,r3
8000bdd4:	02 92       	mov	r2,r1
8000bdd6:	40 93       	lddsp	r3,sp[0x24]
8000bdd8:	10 90       	mov	r0,r8
8000bdda:	40 41       	lddsp	r1,sp[0x10]
8000bddc:	a5 a5       	sbr	r5,0x4
8000bdde:	c0 a8       	rjmp	8000bdf2 <_vfprintf_r+0x10fe>
8000bde0:	50 a7       	stdsp	sp[0x28],r7
8000bde2:	50 80       	stdsp	sp[0x20],r0
8000bde4:	0c 97       	mov	r7,r6
8000bde6:	04 94       	mov	r4,r2
8000bde8:	06 96       	mov	r6,r3
8000bdea:	02 92       	mov	r2,r1
8000bdec:	40 93       	lddsp	r3,sp[0x24]
8000bdee:	10 90       	mov	r0,r8
8000bdf0:	40 41       	lddsp	r1,sp[0x10]
8000bdf2:	ed b5 00 05 	bld	r5,0x5
8000bdf6:	c5 71       	brne	8000bea4 <_vfprintf_r+0x11b0>
8000bdf8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bdfc:	40 39       	lddsp	r9,sp[0xc]
8000bdfe:	58 09       	cp.w	r9,0
8000be00:	c2 20       	breq	8000be44 <_vfprintf_r+0x1150>
8000be02:	10 36       	cp.w	r6,r8
8000be04:	c0 84       	brge	8000be14 <_vfprintf_r+0x1120>
8000be06:	fa c8 f9 44 	sub	r8,sp,-1724
8000be0a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000be0e:	c2 48       	rjmp	8000be56 <_vfprintf_r+0x1162>
8000be10:	80 01       	ld.sh	r1,r0[0x0]
8000be12:	8f 68       	st.w	r7[0x18],r8
8000be14:	fa c8 f9 50 	sub	r8,sp,-1712
8000be18:	1a d8       	st.w	--sp,r8
8000be1a:	fa c8 fa b8 	sub	r8,sp,-1352
8000be1e:	1a d8       	st.w	--sp,r8
8000be20:	fa c8 fb b4 	sub	r8,sp,-1100
8000be24:	1a d8       	st.w	--sp,r8
8000be26:	fa c8 f9 40 	sub	r8,sp,-1728
8000be2a:	fa c9 ff b4 	sub	r9,sp,-76
8000be2e:	04 9a       	mov	r10,r2
8000be30:	0c 9b       	mov	r11,r6
8000be32:	08 9c       	mov	r12,r4
8000be34:	fe b0 f5 c2 	rcall	8000a9b8 <get_arg>
8000be38:	2f dd       	sub	sp,-12
8000be3a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000be3e:	fa e9 00 00 	st.d	sp[0],r8
8000be42:	c2 e8       	rjmp	8000be9e <_vfprintf_r+0x11aa>
8000be44:	ee ca ff ff 	sub	r10,r7,-1
8000be48:	10 37       	cp.w	r7,r8
8000be4a:	c0 b4       	brge	8000be60 <_vfprintf_r+0x116c>
8000be4c:	fa c8 f9 44 	sub	r8,sp,-1724
8000be50:	14 97       	mov	r7,r10
8000be52:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000be56:	ec ea fd 88 	ld.d	r10,r6[-632]
8000be5a:	fa eb 00 00 	st.d	sp[0],r10
8000be5e:	c2 08       	rjmp	8000be9e <_vfprintf_r+0x11aa>
8000be60:	41 09       	lddsp	r9,sp[0x40]
8000be62:	59 f8       	cp.w	r8,31
8000be64:	e0 89 00 16 	brgt	8000be90 <_vfprintf_r+0x119c>
8000be68:	f2 e6 00 00 	ld.d	r6,r9[0]
8000be6c:	f2 cb ff f8 	sub	r11,r9,-8
8000be70:	fa e7 00 00 	st.d	sp[0],r6
8000be74:	51 0b       	stdsp	sp[0x40],r11
8000be76:	fa c6 f9 44 	sub	r6,sp,-1724
8000be7a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000be7e:	fa e6 00 00 	ld.d	r6,sp[0]
8000be82:	f2 e7 fd 88 	st.d	r9[-632],r6
8000be86:	2f f8       	sub	r8,-1
8000be88:	14 97       	mov	r7,r10
8000be8a:	fb 48 06 b4 	st.w	sp[1716],r8
8000be8e:	c0 88       	rjmp	8000be9e <_vfprintf_r+0x11aa>
8000be90:	f2 e6 00 00 	ld.d	r6,r9[0]
8000be94:	2f 89       	sub	r9,-8
8000be96:	fa e7 00 00 	st.d	sp[0],r6
8000be9a:	51 09       	stdsp	sp[0x40],r9
8000be9c:	14 97       	mov	r7,r10
8000be9e:	30 18       	mov	r8,1
8000bea0:	e0 8f 01 d0 	bral	8000c240 <_vfprintf_r+0x154c>
8000bea4:	ed b5 00 04 	bld	r5,0x4
8000bea8:	c1 61       	brne	8000bed4 <_vfprintf_r+0x11e0>
8000beaa:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000beae:	40 3e       	lddsp	lr,sp[0xc]
8000beb0:	58 0e       	cp.w	lr,0
8000beb2:	c0 80       	breq	8000bec2 <_vfprintf_r+0x11ce>
8000beb4:	10 36       	cp.w	r6,r8
8000beb6:	c6 74       	brge	8000bf84 <_vfprintf_r+0x1290>
8000beb8:	fa cc f9 44 	sub	r12,sp,-1724
8000bebc:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bec0:	c8 08       	rjmp	8000bfc0 <_vfprintf_r+0x12cc>
8000bec2:	ee ca ff ff 	sub	r10,r7,-1
8000bec6:	10 37       	cp.w	r7,r8
8000bec8:	c7 f4       	brge	8000bfc6 <_vfprintf_r+0x12d2>
8000beca:	fa cb f9 44 	sub	r11,sp,-1724
8000bece:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bed2:	c7 68       	rjmp	8000bfbe <_vfprintf_r+0x12ca>
8000bed4:	ed b5 00 06 	bld	r5,0x6
8000bed8:	c4 a1       	brne	8000bf6c <_vfprintf_r+0x1278>
8000beda:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bede:	40 3c       	lddsp	r12,sp[0xc]
8000bee0:	58 0c       	cp.w	r12,0
8000bee2:	c1 d0       	breq	8000bf1c <_vfprintf_r+0x1228>
8000bee4:	10 36       	cp.w	r6,r8
8000bee6:	c0 64       	brge	8000bef2 <_vfprintf_r+0x11fe>
8000bee8:	fa cb f9 44 	sub	r11,sp,-1724
8000beec:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bef0:	c1 f8       	rjmp	8000bf2e <_vfprintf_r+0x123a>
8000bef2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bef6:	1a d8       	st.w	--sp,r8
8000bef8:	fa c8 fa b8 	sub	r8,sp,-1352
8000befc:	1a d8       	st.w	--sp,r8
8000befe:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf02:	1a d8       	st.w	--sp,r8
8000bf04:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf08:	fa c9 ff b4 	sub	r9,sp,-76
8000bf0c:	04 9a       	mov	r10,r2
8000bf0e:	0c 9b       	mov	r11,r6
8000bf10:	08 9c       	mov	r12,r4
8000bf12:	fe b0 f5 53 	rcall	8000a9b8 <get_arg>
8000bf16:	2f dd       	sub	sp,-12
8000bf18:	98 18       	ld.sh	r8,r12[0x2]
8000bf1a:	c2 68       	rjmp	8000bf66 <_vfprintf_r+0x1272>
8000bf1c:	ee ca ff ff 	sub	r10,r7,-1
8000bf20:	10 37       	cp.w	r7,r8
8000bf22:	c0 94       	brge	8000bf34 <_vfprintf_r+0x1240>
8000bf24:	fa c9 f9 44 	sub	r9,sp,-1724
8000bf28:	14 97       	mov	r7,r10
8000bf2a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bf2e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bf32:	c1 a8       	rjmp	8000bf66 <_vfprintf_r+0x1272>
8000bf34:	41 09       	lddsp	r9,sp[0x40]
8000bf36:	59 f8       	cp.w	r8,31
8000bf38:	e0 89 00 13 	brgt	8000bf5e <_vfprintf_r+0x126a>
8000bf3c:	f2 cb ff fc 	sub	r11,r9,-4
8000bf40:	51 0b       	stdsp	sp[0x40],r11
8000bf42:	72 09       	ld.w	r9,r9[0x0]
8000bf44:	fa c6 f9 44 	sub	r6,sp,-1724
8000bf48:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bf4c:	2f f8       	sub	r8,-1
8000bf4e:	f7 49 fd 88 	st.w	r11[-632],r9
8000bf52:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf56:	14 97       	mov	r7,r10
8000bf58:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bf5c:	c0 58       	rjmp	8000bf66 <_vfprintf_r+0x1272>
8000bf5e:	92 18       	ld.sh	r8,r9[0x2]
8000bf60:	14 97       	mov	r7,r10
8000bf62:	2f c9       	sub	r9,-4
8000bf64:	51 09       	stdsp	sp[0x40],r9
8000bf66:	5c 78       	castu.h	r8
8000bf68:	50 18       	stdsp	sp[0x4],r8
8000bf6a:	c4 68       	rjmp	8000bff6 <_vfprintf_r+0x1302>
8000bf6c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf70:	40 3c       	lddsp	r12,sp[0xc]
8000bf72:	58 0c       	cp.w	r12,0
8000bf74:	c1 d0       	breq	8000bfae <_vfprintf_r+0x12ba>
8000bf76:	10 36       	cp.w	r6,r8
8000bf78:	c0 64       	brge	8000bf84 <_vfprintf_r+0x1290>
8000bf7a:	fa cb f9 44 	sub	r11,sp,-1724
8000bf7e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bf82:	c1 f8       	rjmp	8000bfc0 <_vfprintf_r+0x12cc>
8000bf84:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf88:	1a d8       	st.w	--sp,r8
8000bf8a:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf8e:	0c 9b       	mov	r11,r6
8000bf90:	1a d8       	st.w	--sp,r8
8000bf92:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf96:	04 9a       	mov	r10,r2
8000bf98:	1a d8       	st.w	--sp,r8
8000bf9a:	08 9c       	mov	r12,r4
8000bf9c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bfa0:	fa c9 ff b4 	sub	r9,sp,-76
8000bfa4:	fe b0 f5 0a 	rcall	8000a9b8 <get_arg>
8000bfa8:	2f dd       	sub	sp,-12
8000bfaa:	78 0b       	ld.w	r11,r12[0x0]
8000bfac:	c2 48       	rjmp	8000bff4 <_vfprintf_r+0x1300>
8000bfae:	ee ca ff ff 	sub	r10,r7,-1
8000bfb2:	10 37       	cp.w	r7,r8
8000bfb4:	c0 94       	brge	8000bfc6 <_vfprintf_r+0x12d2>
8000bfb6:	fa c9 f9 44 	sub	r9,sp,-1724
8000bfba:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bfbe:	14 97       	mov	r7,r10
8000bfc0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bfc4:	c1 88       	rjmp	8000bff4 <_vfprintf_r+0x1300>
8000bfc6:	41 09       	lddsp	r9,sp[0x40]
8000bfc8:	59 f8       	cp.w	r8,31
8000bfca:	e0 89 00 11 	brgt	8000bfec <_vfprintf_r+0x12f8>
8000bfce:	f2 cb ff fc 	sub	r11,r9,-4
8000bfd2:	51 0b       	stdsp	sp[0x40],r11
8000bfd4:	fa c6 f9 44 	sub	r6,sp,-1724
8000bfd8:	72 0b       	ld.w	r11,r9[0x0]
8000bfda:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bfde:	f3 4b fd 88 	st.w	r9[-632],r11
8000bfe2:	2f f8       	sub	r8,-1
8000bfe4:	14 97       	mov	r7,r10
8000bfe6:	fb 48 06 b4 	st.w	sp[1716],r8
8000bfea:	c0 58       	rjmp	8000bff4 <_vfprintf_r+0x1300>
8000bfec:	72 0b       	ld.w	r11,r9[0x0]
8000bfee:	14 97       	mov	r7,r10
8000bff0:	2f c9       	sub	r9,-4
8000bff2:	51 09       	stdsp	sp[0x40],r9
8000bff4:	50 1b       	stdsp	sp[0x4],r11
8000bff6:	30 0e       	mov	lr,0
8000bff8:	30 18       	mov	r8,1
8000bffa:	50 0e       	stdsp	sp[0x0],lr
8000bffc:	c2 29       	rjmp	8000c240 <_vfprintf_r+0x154c>
8000bffe:	50 a7       	stdsp	sp[0x28],r7
8000c000:	50 80       	stdsp	sp[0x20],r0
8000c002:	0c 97       	mov	r7,r6
8000c004:	04 94       	mov	r4,r2
8000c006:	06 96       	mov	r6,r3
8000c008:	02 92       	mov	r2,r1
8000c00a:	4d 3c       	lddpc	r12,8000c154 <_vfprintf_r+0x1460>
8000c00c:	40 93       	lddsp	r3,sp[0x24]
8000c00e:	10 90       	mov	r0,r8
8000c010:	40 41       	lddsp	r1,sp[0x10]
8000c012:	50 dc       	stdsp	sp[0x34],r12
8000c014:	ed b5 00 05 	bld	r5,0x5
8000c018:	c5 51       	brne	8000c0c2 <_vfprintf_r+0x13ce>
8000c01a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c01e:	40 3b       	lddsp	r11,sp[0xc]
8000c020:	58 0b       	cp.w	r11,0
8000c022:	c2 20       	breq	8000c066 <_vfprintf_r+0x1372>
8000c024:	10 36       	cp.w	r6,r8
8000c026:	c0 a4       	brge	8000c03a <_vfprintf_r+0x1346>
8000c028:	fa ca f9 44 	sub	r10,sp,-1724
8000c02c:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c030:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c034:	fa e9 00 00 	st.d	sp[0],r8
8000c038:	cf 38       	rjmp	8000c21e <_vfprintf_r+0x152a>
8000c03a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c03e:	1a d8       	st.w	--sp,r8
8000c040:	fa c8 fa b8 	sub	r8,sp,-1352
8000c044:	04 9a       	mov	r10,r2
8000c046:	1a d8       	st.w	--sp,r8
8000c048:	0c 9b       	mov	r11,r6
8000c04a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c04e:	08 9c       	mov	r12,r4
8000c050:	1a d8       	st.w	--sp,r8
8000c052:	fa c8 f9 40 	sub	r8,sp,-1728
8000c056:	fa c9 ff b4 	sub	r9,sp,-76
8000c05a:	fe b0 f4 af 	rcall	8000a9b8 <get_arg>
8000c05e:	2f dd       	sub	sp,-12
8000c060:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c064:	c0 c8       	rjmp	8000c07c <_vfprintf_r+0x1388>
8000c066:	ee ca ff ff 	sub	r10,r7,-1
8000c06a:	10 37       	cp.w	r7,r8
8000c06c:	c0 b4       	brge	8000c082 <_vfprintf_r+0x138e>
8000c06e:	fa c9 f9 44 	sub	r9,sp,-1724
8000c072:	14 97       	mov	r7,r10
8000c074:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c078:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c07c:	fa eb 00 00 	st.d	sp[0],r10
8000c080:	cc f8       	rjmp	8000c21e <_vfprintf_r+0x152a>
8000c082:	41 09       	lddsp	r9,sp[0x40]
8000c084:	59 f8       	cp.w	r8,31
8000c086:	e0 89 00 16 	brgt	8000c0b2 <_vfprintf_r+0x13be>
8000c08a:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c08e:	f2 cb ff f8 	sub	r11,r9,-8
8000c092:	fa e7 00 00 	st.d	sp[0],r6
8000c096:	51 0b       	stdsp	sp[0x40],r11
8000c098:	fa c6 f9 44 	sub	r6,sp,-1724
8000c09c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c0a0:	fa e6 00 00 	ld.d	r6,sp[0]
8000c0a4:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c0a8:	2f f8       	sub	r8,-1
8000c0aa:	14 97       	mov	r7,r10
8000c0ac:	fb 48 06 b4 	st.w	sp[1716],r8
8000c0b0:	cb 78       	rjmp	8000c21e <_vfprintf_r+0x152a>
8000c0b2:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c0b6:	2f 89       	sub	r9,-8
8000c0b8:	fa e7 00 00 	st.d	sp[0],r6
8000c0bc:	51 09       	stdsp	sp[0x40],r9
8000c0be:	14 97       	mov	r7,r10
8000c0c0:	ca f8       	rjmp	8000c21e <_vfprintf_r+0x152a>
8000c0c2:	ed b5 00 04 	bld	r5,0x4
8000c0c6:	c1 71       	brne	8000c0f4 <_vfprintf_r+0x1400>
8000c0c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0cc:	40 3e       	lddsp	lr,sp[0xc]
8000c0ce:	58 0e       	cp.w	lr,0
8000c0d0:	c0 80       	breq	8000c0e0 <_vfprintf_r+0x13ec>
8000c0d2:	10 36       	cp.w	r6,r8
8000c0d4:	c6 a4       	brge	8000c1a8 <_vfprintf_r+0x14b4>
8000c0d6:	fa cc f9 44 	sub	r12,sp,-1724
8000c0da:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c0de:	c8 38       	rjmp	8000c1e4 <_vfprintf_r+0x14f0>
8000c0e0:	ee ca ff ff 	sub	r10,r7,-1
8000c0e4:	10 37       	cp.w	r7,r8
8000c0e6:	e0 84 00 82 	brge	8000c1ea <_vfprintf_r+0x14f6>
8000c0ea:	fa cb f9 44 	sub	r11,sp,-1724
8000c0ee:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c0f2:	c7 88       	rjmp	8000c1e2 <_vfprintf_r+0x14ee>
8000c0f4:	ed b5 00 06 	bld	r5,0x6
8000c0f8:	c4 c1       	brne	8000c190 <_vfprintf_r+0x149c>
8000c0fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0fe:	40 3c       	lddsp	r12,sp[0xc]
8000c100:	58 0c       	cp.w	r12,0
8000c102:	c1 d0       	breq	8000c13c <_vfprintf_r+0x1448>
8000c104:	10 36       	cp.w	r6,r8
8000c106:	c0 64       	brge	8000c112 <_vfprintf_r+0x141e>
8000c108:	fa cb f9 44 	sub	r11,sp,-1724
8000c10c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c110:	c1 f8       	rjmp	8000c14e <_vfprintf_r+0x145a>
8000c112:	fa c8 f9 50 	sub	r8,sp,-1712
8000c116:	1a d8       	st.w	--sp,r8
8000c118:	fa c8 fa b8 	sub	r8,sp,-1352
8000c11c:	1a d8       	st.w	--sp,r8
8000c11e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c122:	1a d8       	st.w	--sp,r8
8000c124:	fa c8 f9 40 	sub	r8,sp,-1728
8000c128:	fa c9 ff b4 	sub	r9,sp,-76
8000c12c:	04 9a       	mov	r10,r2
8000c12e:	0c 9b       	mov	r11,r6
8000c130:	08 9c       	mov	r12,r4
8000c132:	fe b0 f4 43 	rcall	8000a9b8 <get_arg>
8000c136:	2f dd       	sub	sp,-12
8000c138:	98 18       	ld.sh	r8,r12[0x2]
8000c13a:	c2 88       	rjmp	8000c18a <_vfprintf_r+0x1496>
8000c13c:	ee ca ff ff 	sub	r10,r7,-1
8000c140:	10 37       	cp.w	r7,r8
8000c142:	c0 b4       	brge	8000c158 <_vfprintf_r+0x1464>
8000c144:	fa c9 f9 44 	sub	r9,sp,-1724
8000c148:	14 97       	mov	r7,r10
8000c14a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c14e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c152:	c1 c8       	rjmp	8000c18a <_vfprintf_r+0x1496>
8000c154:	80 01       	ld.sh	r1,r0[0x0]
8000c156:	8f 68       	st.w	r7[0x18],r8
8000c158:	41 09       	lddsp	r9,sp[0x40]
8000c15a:	59 f8       	cp.w	r8,31
8000c15c:	e0 89 00 13 	brgt	8000c182 <_vfprintf_r+0x148e>
8000c160:	f2 cb ff fc 	sub	r11,r9,-4
8000c164:	51 0b       	stdsp	sp[0x40],r11
8000c166:	72 09       	ld.w	r9,r9[0x0]
8000c168:	fa c6 f9 44 	sub	r6,sp,-1724
8000c16c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c170:	2f f8       	sub	r8,-1
8000c172:	f7 49 fd 88 	st.w	r11[-632],r9
8000c176:	fb 48 06 b4 	st.w	sp[1716],r8
8000c17a:	14 97       	mov	r7,r10
8000c17c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c180:	c0 58       	rjmp	8000c18a <_vfprintf_r+0x1496>
8000c182:	92 18       	ld.sh	r8,r9[0x2]
8000c184:	14 97       	mov	r7,r10
8000c186:	2f c9       	sub	r9,-4
8000c188:	51 09       	stdsp	sp[0x40],r9
8000c18a:	5c 78       	castu.h	r8
8000c18c:	50 18       	stdsp	sp[0x4],r8
8000c18e:	c4 68       	rjmp	8000c21a <_vfprintf_r+0x1526>
8000c190:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c194:	40 3c       	lddsp	r12,sp[0xc]
8000c196:	58 0c       	cp.w	r12,0
8000c198:	c1 d0       	breq	8000c1d2 <_vfprintf_r+0x14de>
8000c19a:	10 36       	cp.w	r6,r8
8000c19c:	c0 64       	brge	8000c1a8 <_vfprintf_r+0x14b4>
8000c19e:	fa cb f9 44 	sub	r11,sp,-1724
8000c1a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c1a6:	c1 f8       	rjmp	8000c1e4 <_vfprintf_r+0x14f0>
8000c1a8:	fa c8 f9 50 	sub	r8,sp,-1712
8000c1ac:	1a d8       	st.w	--sp,r8
8000c1ae:	fa c8 fa b8 	sub	r8,sp,-1352
8000c1b2:	0c 9b       	mov	r11,r6
8000c1b4:	1a d8       	st.w	--sp,r8
8000c1b6:	fa c8 fb b4 	sub	r8,sp,-1100
8000c1ba:	04 9a       	mov	r10,r2
8000c1bc:	1a d8       	st.w	--sp,r8
8000c1be:	08 9c       	mov	r12,r4
8000c1c0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c1c4:	fa c9 ff b4 	sub	r9,sp,-76
8000c1c8:	fe b0 f3 f8 	rcall	8000a9b8 <get_arg>
8000c1cc:	2f dd       	sub	sp,-12
8000c1ce:	78 0b       	ld.w	r11,r12[0x0]
8000c1d0:	c2 48       	rjmp	8000c218 <_vfprintf_r+0x1524>
8000c1d2:	ee ca ff ff 	sub	r10,r7,-1
8000c1d6:	10 37       	cp.w	r7,r8
8000c1d8:	c0 94       	brge	8000c1ea <_vfprintf_r+0x14f6>
8000c1da:	fa c9 f9 44 	sub	r9,sp,-1724
8000c1de:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c1e2:	14 97       	mov	r7,r10
8000c1e4:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c1e8:	c1 88       	rjmp	8000c218 <_vfprintf_r+0x1524>
8000c1ea:	41 09       	lddsp	r9,sp[0x40]
8000c1ec:	59 f8       	cp.w	r8,31
8000c1ee:	e0 89 00 11 	brgt	8000c210 <_vfprintf_r+0x151c>
8000c1f2:	f2 cb ff fc 	sub	r11,r9,-4
8000c1f6:	51 0b       	stdsp	sp[0x40],r11
8000c1f8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1fc:	72 0b       	ld.w	r11,r9[0x0]
8000c1fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c202:	f3 4b fd 88 	st.w	r9[-632],r11
8000c206:	2f f8       	sub	r8,-1
8000c208:	14 97       	mov	r7,r10
8000c20a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c20e:	c0 58       	rjmp	8000c218 <_vfprintf_r+0x1524>
8000c210:	72 0b       	ld.w	r11,r9[0x0]
8000c212:	14 97       	mov	r7,r10
8000c214:	2f c9       	sub	r9,-4
8000c216:	51 09       	stdsp	sp[0x40],r9
8000c218:	50 1b       	stdsp	sp[0x4],r11
8000c21a:	30 0e       	mov	lr,0
8000c21c:	50 0e       	stdsp	sp[0x0],lr
8000c21e:	40 08       	lddsp	r8,sp[0x0]
8000c220:	40 1c       	lddsp	r12,sp[0x4]
8000c222:	18 48       	or	r8,r12
8000c224:	5f 19       	srne	r9
8000c226:	0a 98       	mov	r8,r5
8000c228:	eb e9 00 09 	and	r9,r5,r9
8000c22c:	a1 b8       	sbr	r8,0x1
8000c22e:	58 09       	cp.w	r9,0
8000c230:	c0 70       	breq	8000c23e <_vfprintf_r+0x154a>
8000c232:	10 95       	mov	r5,r8
8000c234:	fb 60 06 b9 	st.b	sp[1721],r0
8000c238:	33 08       	mov	r8,48
8000c23a:	fb 68 06 b8 	st.b	sp[1720],r8
8000c23e:	30 28       	mov	r8,2
8000c240:	30 09       	mov	r9,0
8000c242:	fb 69 06 bb 	st.b	sp[1723],r9
8000c246:	0a 99       	mov	r9,r5
8000c248:	a7 d9       	cbr	r9,0x7
8000c24a:	40 2b       	lddsp	r11,sp[0x8]
8000c24c:	40 16       	lddsp	r6,sp[0x4]
8000c24e:	58 0b       	cp.w	r11,0
8000c250:	5f 1a       	srne	r10
8000c252:	f2 05 17 40 	movge	r5,r9
8000c256:	fa c2 f9 78 	sub	r2,sp,-1672
8000c25a:	40 09       	lddsp	r9,sp[0x0]
8000c25c:	0c 49       	or	r9,r6
8000c25e:	5f 19       	srne	r9
8000c260:	f5 e9 10 09 	or	r9,r10,r9
8000c264:	c5 c0       	breq	8000c31c <_vfprintf_r+0x1628>
8000c266:	30 19       	mov	r9,1
8000c268:	f2 08 18 00 	cp.b	r8,r9
8000c26c:	c0 60       	breq	8000c278 <_vfprintf_r+0x1584>
8000c26e:	30 29       	mov	r9,2
8000c270:	f2 08 18 00 	cp.b	r8,r9
8000c274:	c0 41       	brne	8000c27c <_vfprintf_r+0x1588>
8000c276:	c3 c8       	rjmp	8000c2ee <_vfprintf_r+0x15fa>
8000c278:	04 96       	mov	r6,r2
8000c27a:	c3 08       	rjmp	8000c2da <_vfprintf_r+0x15e6>
8000c27c:	04 96       	mov	r6,r2
8000c27e:	fa e8 00 00 	ld.d	r8,sp[0]
8000c282:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c286:	2d 0a       	sub	r10,-48
8000c288:	0c fa       	st.b	--r6,r10
8000c28a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c28e:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c292:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c296:	18 99       	mov	r9,r12
8000c298:	16 98       	mov	r8,r11
8000c29a:	58 08       	cp.w	r8,0
8000c29c:	5c 29       	cpc	r9
8000c29e:	cf 21       	brne	8000c282 <_vfprintf_r+0x158e>
8000c2a0:	fa e9 00 00 	st.d	sp[0],r8
8000c2a4:	ed b5 00 00 	bld	r5,0x0
8000c2a8:	c4 51       	brne	8000c332 <_vfprintf_r+0x163e>
8000c2aa:	33 09       	mov	r9,48
8000c2ac:	f2 0a 18 00 	cp.b	r10,r9
8000c2b0:	c4 10       	breq	8000c332 <_vfprintf_r+0x163e>
8000c2b2:	0c f9       	st.b	--r6,r9
8000c2b4:	c3 f8       	rjmp	8000c332 <_vfprintf_r+0x163e>
8000c2b6:	fa ea 00 00 	ld.d	r10,sp[0]
8000c2ba:	30 a8       	mov	r8,10
8000c2bc:	30 09       	mov	r9,0
8000c2be:	e0 a0 1a 1b 	rcall	8000f6f4 <__avr32_umod64>
8000c2c2:	30 a8       	mov	r8,10
8000c2c4:	2d 0a       	sub	r10,-48
8000c2c6:	30 09       	mov	r9,0
8000c2c8:	ac 8a       	st.b	r6[0x0],r10
8000c2ca:	fa ea 00 00 	ld.d	r10,sp[0]
8000c2ce:	e0 a0 18 e1 	rcall	8000f490 <__avr32_udiv64>
8000c2d2:	16 99       	mov	r9,r11
8000c2d4:	14 98       	mov	r8,r10
8000c2d6:	fa e9 00 00 	st.d	sp[0],r8
8000c2da:	20 16       	sub	r6,1
8000c2dc:	fa ea 00 00 	ld.d	r10,sp[0]
8000c2e0:	58 9a       	cp.w	r10,9
8000c2e2:	5c 2b       	cpc	r11
8000c2e4:	fe 9b ff e9 	brhi	8000c2b6 <_vfprintf_r+0x15c2>
8000c2e8:	1b f8       	ld.ub	r8,sp[0x7]
8000c2ea:	2d 08       	sub	r8,-48
8000c2ec:	c2 08       	rjmp	8000c32c <_vfprintf_r+0x1638>
8000c2ee:	04 96       	mov	r6,r2
8000c2f0:	fa e8 00 00 	ld.d	r8,sp[0]
8000c2f4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c2f8:	40 de       	lddsp	lr,sp[0x34]
8000c2fa:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c2fe:	0c fa       	st.b	--r6,r10
8000c300:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c304:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c308:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c30c:	16 99       	mov	r9,r11
8000c30e:	14 98       	mov	r8,r10
8000c310:	58 08       	cp.w	r8,0
8000c312:	5c 29       	cpc	r9
8000c314:	cf 01       	brne	8000c2f4 <_vfprintf_r+0x1600>
8000c316:	fa e9 00 00 	st.d	sp[0],r8
8000c31a:	c0 c8       	rjmp	8000c332 <_vfprintf_r+0x163e>
8000c31c:	58 08       	cp.w	r8,0
8000c31e:	c0 91       	brne	8000c330 <_vfprintf_r+0x163c>
8000c320:	ed b5 00 00 	bld	r5,0x0
8000c324:	c0 61       	brne	8000c330 <_vfprintf_r+0x163c>
8000c326:	fa c6 f9 79 	sub	r6,sp,-1671
8000c32a:	33 08       	mov	r8,48
8000c32c:	ac 88       	st.b	r6[0x0],r8
8000c32e:	c0 28       	rjmp	8000c332 <_vfprintf_r+0x163e>
8000c330:	04 96       	mov	r6,r2
8000c332:	0c 12       	sub	r2,r6
8000c334:	c1 c8       	rjmp	8000c36c <_vfprintf_r+0x1678>
8000c336:	50 a7       	stdsp	sp[0x28],r7
8000c338:	50 80       	stdsp	sp[0x20],r0
8000c33a:	40 93       	lddsp	r3,sp[0x24]
8000c33c:	0c 97       	mov	r7,r6
8000c33e:	10 90       	mov	r0,r8
8000c340:	04 94       	mov	r4,r2
8000c342:	40 41       	lddsp	r1,sp[0x10]
8000c344:	58 08       	cp.w	r8,0
8000c346:	e0 80 04 51 	breq	8000cbe8 <_vfprintf_r+0x1ef4>
8000c34a:	fb 68 06 60 	st.b	sp[1632],r8
8000c34e:	30 0c       	mov	r12,0
8000c350:	30 08       	mov	r8,0
8000c352:	30 12       	mov	r2,1
8000c354:	fb 68 06 bb 	st.b	sp[1723],r8
8000c358:	50 2c       	stdsp	sp[0x8],r12
8000c35a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c35e:	c0 78       	rjmp	8000c36c <_vfprintf_r+0x1678>
8000c360:	30 0b       	mov	r11,0
8000c362:	50 2b       	stdsp	sp[0x8],r11
8000c364:	c0 48       	rjmp	8000c36c <_vfprintf_r+0x1678>
8000c366:	40 22       	lddsp	r2,sp[0x8]
8000c368:	30 0a       	mov	r10,0
8000c36a:	50 2a       	stdsp	sp[0x8],r10
8000c36c:	40 29       	lddsp	r9,sp[0x8]
8000c36e:	e4 09 0c 49 	max	r9,r2,r9
8000c372:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c376:	50 39       	stdsp	sp[0xc],r9
8000c378:	0a 9e       	mov	lr,r5
8000c37a:	30 09       	mov	r9,0
8000c37c:	e2 1e 00 02 	andl	lr,0x2,COH
8000c380:	f2 08 18 00 	cp.b	r8,r9
8000c384:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c388:	f7 b8 01 ff 	subne	r8,-1
8000c38c:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c390:	0a 9b       	mov	r11,r5
8000c392:	58 0e       	cp.w	lr,0
8000c394:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c398:	f7 bc 01 fe 	subne	r12,-2
8000c39c:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c3a0:	e2 1b 00 84 	andl	r11,0x84,COH
8000c3a4:	50 fe       	stdsp	sp[0x3c],lr
8000c3a6:	50 9b       	stdsp	sp[0x24],r11
8000c3a8:	c4 51       	brne	8000c432 <_vfprintf_r+0x173e>
8000c3aa:	40 8a       	lddsp	r10,sp[0x20]
8000c3ac:	40 39       	lddsp	r9,sp[0xc]
8000c3ae:	12 1a       	sub	r10,r9
8000c3b0:	50 4a       	stdsp	sp[0x10],r10
8000c3b2:	58 0a       	cp.w	r10,0
8000c3b4:	e0 89 00 1f 	brgt	8000c3f2 <_vfprintf_r+0x16fe>
8000c3b8:	c3 d8       	rjmp	8000c432 <_vfprintf_r+0x173e>
8000c3ba:	2f 09       	sub	r9,-16
8000c3bc:	2f f8       	sub	r8,-1
8000c3be:	4c ee       	lddpc	lr,8000c4f4 <_vfprintf_r+0x1800>
8000c3c0:	31 0c       	mov	r12,16
8000c3c2:	fb 49 06 90 	st.w	sp[1680],r9
8000c3c6:	87 0e       	st.w	r3[0x0],lr
8000c3c8:	87 1c       	st.w	r3[0x4],r12
8000c3ca:	fb 48 06 8c 	st.w	sp[1676],r8
8000c3ce:	58 78       	cp.w	r8,7
8000c3d0:	e0 89 00 04 	brgt	8000c3d8 <_vfprintf_r+0x16e4>
8000c3d4:	2f 83       	sub	r3,-8
8000c3d6:	c0 b8       	rjmp	8000c3ec <_vfprintf_r+0x16f8>
8000c3d8:	fa ca f9 78 	sub	r10,sp,-1672
8000c3dc:	02 9b       	mov	r11,r1
8000c3de:	08 9c       	mov	r12,r4
8000c3e0:	fe b0 f4 7c 	rcall	8000acd8 <__sprint_r>
8000c3e4:	e0 81 04 13 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c3e8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c3ec:	40 4b       	lddsp	r11,sp[0x10]
8000c3ee:	21 0b       	sub	r11,16
8000c3f0:	50 4b       	stdsp	sp[0x10],r11
8000c3f2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c3f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c3fa:	4b fa       	lddpc	r10,8000c4f4 <_vfprintf_r+0x1800>
8000c3fc:	40 4e       	lddsp	lr,sp[0x10]
8000c3fe:	59 0e       	cp.w	lr,16
8000c400:	fe 99 ff dd 	brgt	8000c3ba <_vfprintf_r+0x16c6>
8000c404:	1c 09       	add	r9,lr
8000c406:	2f f8       	sub	r8,-1
8000c408:	87 0a       	st.w	r3[0x0],r10
8000c40a:	fb 49 06 90 	st.w	sp[1680],r9
8000c40e:	87 1e       	st.w	r3[0x4],lr
8000c410:	fb 48 06 8c 	st.w	sp[1676],r8
8000c414:	58 78       	cp.w	r8,7
8000c416:	e0 89 00 04 	brgt	8000c41e <_vfprintf_r+0x172a>
8000c41a:	2f 83       	sub	r3,-8
8000c41c:	c0 b8       	rjmp	8000c432 <_vfprintf_r+0x173e>
8000c41e:	fa ca f9 78 	sub	r10,sp,-1672
8000c422:	02 9b       	mov	r11,r1
8000c424:	08 9c       	mov	r12,r4
8000c426:	fe b0 f4 59 	rcall	8000acd8 <__sprint_r>
8000c42a:	e0 81 03 f0 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c42e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c432:	30 09       	mov	r9,0
8000c434:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c438:	f2 08 18 00 	cp.b	r8,r9
8000c43c:	c1 f0       	breq	8000c47a <_vfprintf_r+0x1786>
8000c43e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c442:	fa c9 f9 45 	sub	r9,sp,-1723
8000c446:	2f f8       	sub	r8,-1
8000c448:	87 09       	st.w	r3[0x0],r9
8000c44a:	fb 48 06 90 	st.w	sp[1680],r8
8000c44e:	30 19       	mov	r9,1
8000c450:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c454:	87 19       	st.w	r3[0x4],r9
8000c456:	2f f8       	sub	r8,-1
8000c458:	fb 48 06 8c 	st.w	sp[1676],r8
8000c45c:	58 78       	cp.w	r8,7
8000c45e:	e0 89 00 04 	brgt	8000c466 <_vfprintf_r+0x1772>
8000c462:	2f 83       	sub	r3,-8
8000c464:	c0 b8       	rjmp	8000c47a <_vfprintf_r+0x1786>
8000c466:	fa ca f9 78 	sub	r10,sp,-1672
8000c46a:	02 9b       	mov	r11,r1
8000c46c:	08 9c       	mov	r12,r4
8000c46e:	fe b0 f4 35 	rcall	8000acd8 <__sprint_r>
8000c472:	e0 81 03 cc 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c476:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c47a:	40 fc       	lddsp	r12,sp[0x3c]
8000c47c:	58 0c       	cp.w	r12,0
8000c47e:	c1 f0       	breq	8000c4bc <_vfprintf_r+0x17c8>
8000c480:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c484:	fa c9 f9 48 	sub	r9,sp,-1720
8000c488:	2f e8       	sub	r8,-2
8000c48a:	87 09       	st.w	r3[0x0],r9
8000c48c:	fb 48 06 90 	st.w	sp[1680],r8
8000c490:	30 29       	mov	r9,2
8000c492:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c496:	87 19       	st.w	r3[0x4],r9
8000c498:	2f f8       	sub	r8,-1
8000c49a:	fb 48 06 8c 	st.w	sp[1676],r8
8000c49e:	58 78       	cp.w	r8,7
8000c4a0:	e0 89 00 04 	brgt	8000c4a8 <_vfprintf_r+0x17b4>
8000c4a4:	2f 83       	sub	r3,-8
8000c4a6:	c0 b8       	rjmp	8000c4bc <_vfprintf_r+0x17c8>
8000c4a8:	fa ca f9 78 	sub	r10,sp,-1672
8000c4ac:	02 9b       	mov	r11,r1
8000c4ae:	08 9c       	mov	r12,r4
8000c4b0:	fe b0 f4 14 	rcall	8000acd8 <__sprint_r>
8000c4b4:	e0 81 03 ab 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c4b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c4bc:	40 9b       	lddsp	r11,sp[0x24]
8000c4be:	e0 4b 00 80 	cp.w	r11,128
8000c4c2:	c4 a1       	brne	8000c556 <_vfprintf_r+0x1862>
8000c4c4:	40 8a       	lddsp	r10,sp[0x20]
8000c4c6:	40 39       	lddsp	r9,sp[0xc]
8000c4c8:	12 1a       	sub	r10,r9
8000c4ca:	50 4a       	stdsp	sp[0x10],r10
8000c4cc:	58 0a       	cp.w	r10,0
8000c4ce:	e0 89 00 24 	brgt	8000c516 <_vfprintf_r+0x1822>
8000c4d2:	c4 28       	rjmp	8000c556 <_vfprintf_r+0x1862>
8000c4d4:	2f 09       	sub	r9,-16
8000c4d6:	2f f8       	sub	r8,-1
8000c4d8:	48 8e       	lddpc	lr,8000c4f8 <_vfprintf_r+0x1804>
8000c4da:	31 0c       	mov	r12,16
8000c4dc:	fb 49 06 90 	st.w	sp[1680],r9
8000c4e0:	87 0e       	st.w	r3[0x0],lr
8000c4e2:	87 1c       	st.w	r3[0x4],r12
8000c4e4:	fb 48 06 8c 	st.w	sp[1676],r8
8000c4e8:	58 78       	cp.w	r8,7
8000c4ea:	e0 89 00 09 	brgt	8000c4fc <_vfprintf_r+0x1808>
8000c4ee:	2f 83       	sub	r3,-8
8000c4f0:	c1 08       	rjmp	8000c510 <_vfprintf_r+0x181c>
8000c4f2:	d7 03       	nop
8000c4f4:	80 01       	ld.sh	r1,r0[0x0]
8000c4f6:	8f 80       	st.w	r7[0x20],r0
8000c4f8:	80 01       	ld.sh	r1,r0[0x0]
8000c4fa:	8f 90       	st.w	r7[0x24],r0
8000c4fc:	fa ca f9 78 	sub	r10,sp,-1672
8000c500:	02 9b       	mov	r11,r1
8000c502:	08 9c       	mov	r12,r4
8000c504:	fe b0 f3 ea 	rcall	8000acd8 <__sprint_r>
8000c508:	e0 81 03 81 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c50c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c510:	40 4b       	lddsp	r11,sp[0x10]
8000c512:	21 0b       	sub	r11,16
8000c514:	50 4b       	stdsp	sp[0x10],r11
8000c516:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c51a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c51e:	4c 6a       	lddpc	r10,8000c634 <_vfprintf_r+0x1940>
8000c520:	40 4e       	lddsp	lr,sp[0x10]
8000c522:	59 0e       	cp.w	lr,16
8000c524:	fe 99 ff d8 	brgt	8000c4d4 <_vfprintf_r+0x17e0>
8000c528:	1c 09       	add	r9,lr
8000c52a:	2f f8       	sub	r8,-1
8000c52c:	87 0a       	st.w	r3[0x0],r10
8000c52e:	fb 49 06 90 	st.w	sp[1680],r9
8000c532:	87 1e       	st.w	r3[0x4],lr
8000c534:	fb 48 06 8c 	st.w	sp[1676],r8
8000c538:	58 78       	cp.w	r8,7
8000c53a:	e0 89 00 04 	brgt	8000c542 <_vfprintf_r+0x184e>
8000c53e:	2f 83       	sub	r3,-8
8000c540:	c0 b8       	rjmp	8000c556 <_vfprintf_r+0x1862>
8000c542:	fa ca f9 78 	sub	r10,sp,-1672
8000c546:	02 9b       	mov	r11,r1
8000c548:	08 9c       	mov	r12,r4
8000c54a:	fe b0 f3 c7 	rcall	8000acd8 <__sprint_r>
8000c54e:	e0 81 03 5e 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c552:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c556:	40 2c       	lddsp	r12,sp[0x8]
8000c558:	04 1c       	sub	r12,r2
8000c55a:	50 2c       	stdsp	sp[0x8],r12
8000c55c:	58 0c       	cp.w	r12,0
8000c55e:	e0 89 00 1f 	brgt	8000c59c <_vfprintf_r+0x18a8>
8000c562:	c3 d8       	rjmp	8000c5dc <_vfprintf_r+0x18e8>
8000c564:	2f 09       	sub	r9,-16
8000c566:	2f f8       	sub	r8,-1
8000c568:	4b 3b       	lddpc	r11,8000c634 <_vfprintf_r+0x1940>
8000c56a:	31 0a       	mov	r10,16
8000c56c:	fb 49 06 90 	st.w	sp[1680],r9
8000c570:	87 0b       	st.w	r3[0x0],r11
8000c572:	87 1a       	st.w	r3[0x4],r10
8000c574:	fb 48 06 8c 	st.w	sp[1676],r8
8000c578:	58 78       	cp.w	r8,7
8000c57a:	e0 89 00 04 	brgt	8000c582 <_vfprintf_r+0x188e>
8000c57e:	2f 83       	sub	r3,-8
8000c580:	c0 b8       	rjmp	8000c596 <_vfprintf_r+0x18a2>
8000c582:	fa ca f9 78 	sub	r10,sp,-1672
8000c586:	02 9b       	mov	r11,r1
8000c588:	08 9c       	mov	r12,r4
8000c58a:	fe b0 f3 a7 	rcall	8000acd8 <__sprint_r>
8000c58e:	e0 81 03 3e 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c592:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c596:	40 29       	lddsp	r9,sp[0x8]
8000c598:	21 09       	sub	r9,16
8000c59a:	50 29       	stdsp	sp[0x8],r9
8000c59c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c5a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c5a4:	4a 4a       	lddpc	r10,8000c634 <_vfprintf_r+0x1940>
8000c5a6:	40 2e       	lddsp	lr,sp[0x8]
8000c5a8:	59 0e       	cp.w	lr,16
8000c5aa:	fe 99 ff dd 	brgt	8000c564 <_vfprintf_r+0x1870>
8000c5ae:	1c 09       	add	r9,lr
8000c5b0:	2f f8       	sub	r8,-1
8000c5b2:	87 0a       	st.w	r3[0x0],r10
8000c5b4:	fb 49 06 90 	st.w	sp[1680],r9
8000c5b8:	87 1e       	st.w	r3[0x4],lr
8000c5ba:	fb 48 06 8c 	st.w	sp[1676],r8
8000c5be:	58 78       	cp.w	r8,7
8000c5c0:	e0 89 00 04 	brgt	8000c5c8 <_vfprintf_r+0x18d4>
8000c5c4:	2f 83       	sub	r3,-8
8000c5c6:	c0 b8       	rjmp	8000c5dc <_vfprintf_r+0x18e8>
8000c5c8:	fa ca f9 78 	sub	r10,sp,-1672
8000c5cc:	02 9b       	mov	r11,r1
8000c5ce:	08 9c       	mov	r12,r4
8000c5d0:	fe b0 f3 84 	rcall	8000acd8 <__sprint_r>
8000c5d4:	e0 81 03 1b 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c5d8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c5dc:	ed b5 00 08 	bld	r5,0x8
8000c5e0:	c0 b0       	breq	8000c5f6 <_vfprintf_r+0x1902>
8000c5e2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c5e6:	87 12       	st.w	r3[0x4],r2
8000c5e8:	87 06       	st.w	r3[0x0],r6
8000c5ea:	f0 02 00 02 	add	r2,r8,r2
8000c5ee:	fb 42 06 90 	st.w	sp[1680],r2
8000c5f2:	e0 8f 01 d5 	bral	8000c99c <_vfprintf_r+0x1ca8>
8000c5f6:	e0 40 00 65 	cp.w	r0,101
8000c5fa:	e0 8a 01 d7 	brle	8000c9a8 <_vfprintf_r+0x1cb4>
8000c5fe:	30 08       	mov	r8,0
8000c600:	30 09       	mov	r9,0
8000c602:	40 5b       	lddsp	r11,sp[0x14]
8000c604:	40 7a       	lddsp	r10,sp[0x1c]
8000c606:	e0 a0 15 3e 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000c60a:	c7 a0       	breq	8000c6fe <_vfprintf_r+0x1a0a>
8000c60c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c610:	48 a9       	lddpc	r9,8000c638 <_vfprintf_r+0x1944>
8000c612:	2f f8       	sub	r8,-1
8000c614:	87 09       	st.w	r3[0x0],r9
8000c616:	fb 48 06 90 	st.w	sp[1680],r8
8000c61a:	30 19       	mov	r9,1
8000c61c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c620:	87 19       	st.w	r3[0x4],r9
8000c622:	2f f8       	sub	r8,-1
8000c624:	fb 48 06 8c 	st.w	sp[1676],r8
8000c628:	58 78       	cp.w	r8,7
8000c62a:	e0 89 00 09 	brgt	8000c63c <_vfprintf_r+0x1948>
8000c62e:	2f 83       	sub	r3,-8
8000c630:	c1 08       	rjmp	8000c650 <_vfprintf_r+0x195c>
8000c632:	d7 03       	nop
8000c634:	80 01       	ld.sh	r1,r0[0x0]
8000c636:	8f 90       	st.w	r7[0x24],r0
8000c638:	80 01       	ld.sh	r1,r0[0x0]
8000c63a:	8f 7c       	st.w	r7[0x1c],r12
8000c63c:	fa ca f9 78 	sub	r10,sp,-1672
8000c640:	02 9b       	mov	r11,r1
8000c642:	08 9c       	mov	r12,r4
8000c644:	fe b0 f3 4a 	rcall	8000acd8 <__sprint_r>
8000c648:	e0 81 02 e1 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c64c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c650:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c654:	40 6c       	lddsp	r12,sp[0x18]
8000c656:	18 38       	cp.w	r8,r12
8000c658:	c0 55       	brlt	8000c662 <_vfprintf_r+0x196e>
8000c65a:	ed b5 00 00 	bld	r5,0x0
8000c65e:	e0 81 02 69 	brne	8000cb30 <_vfprintf_r+0x1e3c>
8000c662:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c666:	2f f8       	sub	r8,-1
8000c668:	40 cb       	lddsp	r11,sp[0x30]
8000c66a:	fb 48 06 90 	st.w	sp[1680],r8
8000c66e:	30 19       	mov	r9,1
8000c670:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c674:	87 0b       	st.w	r3[0x0],r11
8000c676:	2f f8       	sub	r8,-1
8000c678:	87 19       	st.w	r3[0x4],r9
8000c67a:	fb 48 06 8c 	st.w	sp[1676],r8
8000c67e:	58 78       	cp.w	r8,7
8000c680:	e0 89 00 04 	brgt	8000c688 <_vfprintf_r+0x1994>
8000c684:	2f 83       	sub	r3,-8
8000c686:	c0 b8       	rjmp	8000c69c <_vfprintf_r+0x19a8>
8000c688:	fa ca f9 78 	sub	r10,sp,-1672
8000c68c:	02 9b       	mov	r11,r1
8000c68e:	08 9c       	mov	r12,r4
8000c690:	fe b0 f3 24 	rcall	8000acd8 <__sprint_r>
8000c694:	e0 81 02 bb 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c698:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c69c:	40 66       	lddsp	r6,sp[0x18]
8000c69e:	20 16       	sub	r6,1
8000c6a0:	58 06       	cp.w	r6,0
8000c6a2:	e0 89 00 1d 	brgt	8000c6dc <_vfprintf_r+0x19e8>
8000c6a6:	e0 8f 02 45 	bral	8000cb30 <_vfprintf_r+0x1e3c>
8000c6aa:	2f 09       	sub	r9,-16
8000c6ac:	2f f8       	sub	r8,-1
8000c6ae:	fb 49 06 90 	st.w	sp[1680],r9
8000c6b2:	87 02       	st.w	r3[0x0],r2
8000c6b4:	87 10       	st.w	r3[0x4],r0
8000c6b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000c6ba:	58 78       	cp.w	r8,7
8000c6bc:	e0 89 00 04 	brgt	8000c6c4 <_vfprintf_r+0x19d0>
8000c6c0:	2f 83       	sub	r3,-8
8000c6c2:	c0 b8       	rjmp	8000c6d8 <_vfprintf_r+0x19e4>
8000c6c4:	fa ca f9 78 	sub	r10,sp,-1672
8000c6c8:	02 9b       	mov	r11,r1
8000c6ca:	08 9c       	mov	r12,r4
8000c6cc:	fe b0 f3 06 	rcall	8000acd8 <__sprint_r>
8000c6d0:	e0 81 02 9d 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c6d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c6d8:	21 06       	sub	r6,16
8000c6da:	c0 38       	rjmp	8000c6e0 <_vfprintf_r+0x19ec>
8000c6dc:	4d 22       	lddpc	r2,8000c824 <_vfprintf_r+0x1b30>
8000c6de:	31 00       	mov	r0,16
8000c6e0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c6e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c6e8:	4c fa       	lddpc	r10,8000c824 <_vfprintf_r+0x1b30>
8000c6ea:	59 06       	cp.w	r6,16
8000c6ec:	fe 99 ff df 	brgt	8000c6aa <_vfprintf_r+0x19b6>
8000c6f0:	0c 09       	add	r9,r6
8000c6f2:	87 0a       	st.w	r3[0x0],r10
8000c6f4:	fb 49 06 90 	st.w	sp[1680],r9
8000c6f8:	2f f8       	sub	r8,-1
8000c6fa:	87 16       	st.w	r3[0x4],r6
8000c6fc:	c5 39       	rjmp	8000c9a2 <_vfprintf_r+0x1cae>
8000c6fe:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000c702:	58 0a       	cp.w	r10,0
8000c704:	e0 89 00 94 	brgt	8000c82c <_vfprintf_r+0x1b38>
8000c708:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c70c:	4c 79       	lddpc	r9,8000c828 <_vfprintf_r+0x1b34>
8000c70e:	2f f8       	sub	r8,-1
8000c710:	87 09       	st.w	r3[0x0],r9
8000c712:	fb 48 06 90 	st.w	sp[1680],r8
8000c716:	30 19       	mov	r9,1
8000c718:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c71c:	87 19       	st.w	r3[0x4],r9
8000c71e:	2f f8       	sub	r8,-1
8000c720:	fb 48 06 8c 	st.w	sp[1676],r8
8000c724:	58 78       	cp.w	r8,7
8000c726:	e0 89 00 04 	brgt	8000c72e <_vfprintf_r+0x1a3a>
8000c72a:	2f 83       	sub	r3,-8
8000c72c:	c0 b8       	rjmp	8000c742 <_vfprintf_r+0x1a4e>
8000c72e:	fa ca f9 78 	sub	r10,sp,-1672
8000c732:	02 9b       	mov	r11,r1
8000c734:	08 9c       	mov	r12,r4
8000c736:	fe b0 f2 d1 	rcall	8000acd8 <__sprint_r>
8000c73a:	e0 81 02 68 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c73e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c742:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c746:	58 08       	cp.w	r8,0
8000c748:	c0 81       	brne	8000c758 <_vfprintf_r+0x1a64>
8000c74a:	40 6a       	lddsp	r10,sp[0x18]
8000c74c:	58 0a       	cp.w	r10,0
8000c74e:	c0 51       	brne	8000c758 <_vfprintf_r+0x1a64>
8000c750:	ed b5 00 00 	bld	r5,0x0
8000c754:	e0 81 01 ee 	brne	8000cb30 <_vfprintf_r+0x1e3c>
8000c758:	40 c9       	lddsp	r9,sp[0x30]
8000c75a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c75e:	2f f8       	sub	r8,-1
8000c760:	87 09       	st.w	r3[0x0],r9
8000c762:	fb 48 06 90 	st.w	sp[1680],r8
8000c766:	30 19       	mov	r9,1
8000c768:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c76c:	87 19       	st.w	r3[0x4],r9
8000c76e:	2f f8       	sub	r8,-1
8000c770:	fb 48 06 8c 	st.w	sp[1676],r8
8000c774:	58 78       	cp.w	r8,7
8000c776:	e0 89 00 04 	brgt	8000c77e <_vfprintf_r+0x1a8a>
8000c77a:	2f 83       	sub	r3,-8
8000c77c:	c0 b8       	rjmp	8000c792 <_vfprintf_r+0x1a9e>
8000c77e:	fa ca f9 78 	sub	r10,sp,-1672
8000c782:	02 9b       	mov	r11,r1
8000c784:	08 9c       	mov	r12,r4
8000c786:	fe b0 f2 a9 	rcall	8000acd8 <__sprint_r>
8000c78a:	e0 81 02 40 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c78e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c792:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c796:	5c 32       	neg	r2
8000c798:	58 02       	cp.w	r2,0
8000c79a:	e0 89 00 1d 	brgt	8000c7d4 <_vfprintf_r+0x1ae0>
8000c79e:	c3 b8       	rjmp	8000c814 <_vfprintf_r+0x1b20>
8000c7a0:	2f 09       	sub	r9,-16
8000c7a2:	2f f8       	sub	r8,-1
8000c7a4:	31 0e       	mov	lr,16
8000c7a6:	fb 49 06 90 	st.w	sp[1680],r9
8000c7aa:	87 00       	st.w	r3[0x0],r0
8000c7ac:	87 1e       	st.w	r3[0x4],lr
8000c7ae:	fb 48 06 8c 	st.w	sp[1676],r8
8000c7b2:	58 78       	cp.w	r8,7
8000c7b4:	e0 89 00 04 	brgt	8000c7bc <_vfprintf_r+0x1ac8>
8000c7b8:	2f 83       	sub	r3,-8
8000c7ba:	c0 b8       	rjmp	8000c7d0 <_vfprintf_r+0x1adc>
8000c7bc:	fa ca f9 78 	sub	r10,sp,-1672
8000c7c0:	02 9b       	mov	r11,r1
8000c7c2:	08 9c       	mov	r12,r4
8000c7c4:	fe b0 f2 8a 	rcall	8000acd8 <__sprint_r>
8000c7c8:	e0 81 02 21 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c7cc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c7d0:	21 02       	sub	r2,16
8000c7d2:	c0 28       	rjmp	8000c7d6 <_vfprintf_r+0x1ae2>
8000c7d4:	49 40       	lddpc	r0,8000c824 <_vfprintf_r+0x1b30>
8000c7d6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c7da:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c7de:	49 2a       	lddpc	r10,8000c824 <_vfprintf_r+0x1b30>
8000c7e0:	59 02       	cp.w	r2,16
8000c7e2:	fe 99 ff df 	brgt	8000c7a0 <_vfprintf_r+0x1aac>
8000c7e6:	04 09       	add	r9,r2
8000c7e8:	2f f8       	sub	r8,-1
8000c7ea:	87 0a       	st.w	r3[0x0],r10
8000c7ec:	fb 49 06 90 	st.w	sp[1680],r9
8000c7f0:	87 12       	st.w	r3[0x4],r2
8000c7f2:	fb 48 06 8c 	st.w	sp[1676],r8
8000c7f6:	58 78       	cp.w	r8,7
8000c7f8:	e0 89 00 04 	brgt	8000c800 <_vfprintf_r+0x1b0c>
8000c7fc:	2f 83       	sub	r3,-8
8000c7fe:	c0 b8       	rjmp	8000c814 <_vfprintf_r+0x1b20>
8000c800:	fa ca f9 78 	sub	r10,sp,-1672
8000c804:	02 9b       	mov	r11,r1
8000c806:	08 9c       	mov	r12,r4
8000c808:	fe b0 f2 68 	rcall	8000acd8 <__sprint_r>
8000c80c:	e0 81 01 ff 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c810:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c814:	40 6c       	lddsp	r12,sp[0x18]
8000c816:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c81a:	87 06       	st.w	r3[0x0],r6
8000c81c:	87 1c       	st.w	r3[0x4],r12
8000c81e:	18 08       	add	r8,r12
8000c820:	cb c8       	rjmp	8000c998 <_vfprintf_r+0x1ca4>
8000c822:	d7 03       	nop
8000c824:	80 01       	ld.sh	r1,r0[0x0]
8000c826:	8f 90       	st.w	r7[0x24],r0
8000c828:	80 01       	ld.sh	r1,r0[0x0]
8000c82a:	8f 7c       	st.w	r7[0x1c],r12
8000c82c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c830:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c834:	40 6b       	lddsp	r11,sp[0x18]
8000c836:	16 3a       	cp.w	r10,r11
8000c838:	c6 d5       	brlt	8000c912 <_vfprintf_r+0x1c1e>
8000c83a:	16 09       	add	r9,r11
8000c83c:	2f f8       	sub	r8,-1
8000c83e:	87 06       	st.w	r3[0x0],r6
8000c840:	fb 49 06 90 	st.w	sp[1680],r9
8000c844:	87 1b       	st.w	r3[0x4],r11
8000c846:	fb 48 06 8c 	st.w	sp[1676],r8
8000c84a:	58 78       	cp.w	r8,7
8000c84c:	e0 89 00 04 	brgt	8000c854 <_vfprintf_r+0x1b60>
8000c850:	2f 83       	sub	r3,-8
8000c852:	c0 b8       	rjmp	8000c868 <_vfprintf_r+0x1b74>
8000c854:	fa ca f9 78 	sub	r10,sp,-1672
8000c858:	02 9b       	mov	r11,r1
8000c85a:	08 9c       	mov	r12,r4
8000c85c:	fe b0 f2 3e 	rcall	8000acd8 <__sprint_r>
8000c860:	e0 81 01 d5 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c864:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c868:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000c86c:	40 6a       	lddsp	r10,sp[0x18]
8000c86e:	14 16       	sub	r6,r10
8000c870:	58 06       	cp.w	r6,0
8000c872:	e0 89 00 1c 	brgt	8000c8aa <_vfprintf_r+0x1bb6>
8000c876:	c3 b8       	rjmp	8000c8ec <_vfprintf_r+0x1bf8>
8000c878:	2f 09       	sub	r9,-16
8000c87a:	2f f8       	sub	r8,-1
8000c87c:	fb 49 06 90 	st.w	sp[1680],r9
8000c880:	87 02       	st.w	r3[0x0],r2
8000c882:	87 10       	st.w	r3[0x4],r0
8000c884:	fb 48 06 8c 	st.w	sp[1676],r8
8000c888:	58 78       	cp.w	r8,7
8000c88a:	e0 89 00 04 	brgt	8000c892 <_vfprintf_r+0x1b9e>
8000c88e:	2f 83       	sub	r3,-8
8000c890:	c0 b8       	rjmp	8000c8a6 <_vfprintf_r+0x1bb2>
8000c892:	fa ca f9 78 	sub	r10,sp,-1672
8000c896:	02 9b       	mov	r11,r1
8000c898:	08 9c       	mov	r12,r4
8000c89a:	fe b0 f2 1f 	rcall	8000acd8 <__sprint_r>
8000c89e:	e0 81 01 b6 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c8a2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c8a6:	21 06       	sub	r6,16
8000c8a8:	c0 38       	rjmp	8000c8ae <_vfprintf_r+0x1bba>
8000c8aa:	4d c2       	lddpc	r2,8000ca18 <_vfprintf_r+0x1d24>
8000c8ac:	31 00       	mov	r0,16
8000c8ae:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c8b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c8b6:	4d 9a       	lddpc	r10,8000ca18 <_vfprintf_r+0x1d24>
8000c8b8:	59 06       	cp.w	r6,16
8000c8ba:	fe 99 ff df 	brgt	8000c878 <_vfprintf_r+0x1b84>
8000c8be:	0c 09       	add	r9,r6
8000c8c0:	2f f8       	sub	r8,-1
8000c8c2:	87 0a       	st.w	r3[0x0],r10
8000c8c4:	fb 49 06 90 	st.w	sp[1680],r9
8000c8c8:	87 16       	st.w	r3[0x4],r6
8000c8ca:	fb 48 06 8c 	st.w	sp[1676],r8
8000c8ce:	58 78       	cp.w	r8,7
8000c8d0:	e0 89 00 04 	brgt	8000c8d8 <_vfprintf_r+0x1be4>
8000c8d4:	2f 83       	sub	r3,-8
8000c8d6:	c0 b8       	rjmp	8000c8ec <_vfprintf_r+0x1bf8>
8000c8d8:	fa ca f9 78 	sub	r10,sp,-1672
8000c8dc:	02 9b       	mov	r11,r1
8000c8de:	08 9c       	mov	r12,r4
8000c8e0:	fe b0 f1 fc 	rcall	8000acd8 <__sprint_r>
8000c8e4:	e0 81 01 93 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c8e8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c8ec:	ed b5 00 00 	bld	r5,0x0
8000c8f0:	e0 81 01 20 	brne	8000cb30 <_vfprintf_r+0x1e3c>
8000c8f4:	40 c9       	lddsp	r9,sp[0x30]
8000c8f6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c8fa:	2f f8       	sub	r8,-1
8000c8fc:	87 09       	st.w	r3[0x0],r9
8000c8fe:	fb 48 06 90 	st.w	sp[1680],r8
8000c902:	30 19       	mov	r9,1
8000c904:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c908:	87 19       	st.w	r3[0x4],r9
8000c90a:	2f f8       	sub	r8,-1
8000c90c:	fb 48 06 8c 	st.w	sp[1676],r8
8000c910:	c0 29       	rjmp	8000cb14 <_vfprintf_r+0x1e20>
8000c912:	14 09       	add	r9,r10
8000c914:	2f f8       	sub	r8,-1
8000c916:	fb 49 06 90 	st.w	sp[1680],r9
8000c91a:	87 06       	st.w	r3[0x0],r6
8000c91c:	87 1a       	st.w	r3[0x4],r10
8000c91e:	fb 48 06 8c 	st.w	sp[1676],r8
8000c922:	58 78       	cp.w	r8,7
8000c924:	e0 89 00 04 	brgt	8000c92c <_vfprintf_r+0x1c38>
8000c928:	2f 83       	sub	r3,-8
8000c92a:	c0 b8       	rjmp	8000c940 <_vfprintf_r+0x1c4c>
8000c92c:	fa ca f9 78 	sub	r10,sp,-1672
8000c930:	02 9b       	mov	r11,r1
8000c932:	08 9c       	mov	r12,r4
8000c934:	fe b0 f1 d2 	rcall	8000acd8 <__sprint_r>
8000c938:	e0 81 01 69 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c93c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c940:	40 c8       	lddsp	r8,sp[0x30]
8000c942:	87 08       	st.w	r3[0x0],r8
8000c944:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c948:	2f f8       	sub	r8,-1
8000c94a:	30 19       	mov	r9,1
8000c94c:	fb 48 06 90 	st.w	sp[1680],r8
8000c950:	87 19       	st.w	r3[0x4],r9
8000c952:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c956:	2f f8       	sub	r8,-1
8000c958:	fb 48 06 8c 	st.w	sp[1676],r8
8000c95c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c960:	58 78       	cp.w	r8,7
8000c962:	e0 89 00 04 	brgt	8000c96a <_vfprintf_r+0x1c76>
8000c966:	2f 83       	sub	r3,-8
8000c968:	c0 b8       	rjmp	8000c97e <_vfprintf_r+0x1c8a>
8000c96a:	fa ca f9 78 	sub	r10,sp,-1672
8000c96e:	02 9b       	mov	r11,r1
8000c970:	08 9c       	mov	r12,r4
8000c972:	fe b0 f1 b3 	rcall	8000acd8 <__sprint_r>
8000c976:	e0 81 01 4a 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c97a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c97e:	04 06       	add	r6,r2
8000c980:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c984:	87 06       	st.w	r3[0x0],r6
8000c986:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c98a:	40 66       	lddsp	r6,sp[0x18]
8000c98c:	40 6e       	lddsp	lr,sp[0x18]
8000c98e:	10 16       	sub	r6,r8
8000c990:	f2 08 01 08 	sub	r8,r9,r8
8000c994:	87 16       	st.w	r3[0x4],r6
8000c996:	1c 08       	add	r8,lr
8000c998:	fb 48 06 90 	st.w	sp[1680],r8
8000c99c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c9a0:	2f f8       	sub	r8,-1
8000c9a2:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9a6:	cb 78       	rjmp	8000cb14 <_vfprintf_r+0x1e20>
8000c9a8:	40 6c       	lddsp	r12,sp[0x18]
8000c9aa:	58 1c       	cp.w	r12,1
8000c9ac:	e0 89 00 06 	brgt	8000c9b8 <_vfprintf_r+0x1cc4>
8000c9b0:	ed b5 00 00 	bld	r5,0x0
8000c9b4:	e0 81 00 85 	brne	8000cabe <_vfprintf_r+0x1dca>
8000c9b8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c9bc:	2f f8       	sub	r8,-1
8000c9be:	30 19       	mov	r9,1
8000c9c0:	fb 48 06 90 	st.w	sp[1680],r8
8000c9c4:	87 06       	st.w	r3[0x0],r6
8000c9c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c9ca:	87 19       	st.w	r3[0x4],r9
8000c9cc:	2f f8       	sub	r8,-1
8000c9ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9d2:	58 78       	cp.w	r8,7
8000c9d4:	e0 89 00 04 	brgt	8000c9dc <_vfprintf_r+0x1ce8>
8000c9d8:	2f 83       	sub	r3,-8
8000c9da:	c0 b8       	rjmp	8000c9f0 <_vfprintf_r+0x1cfc>
8000c9dc:	fa ca f9 78 	sub	r10,sp,-1672
8000c9e0:	02 9b       	mov	r11,r1
8000c9e2:	08 9c       	mov	r12,r4
8000c9e4:	fe b0 f1 7a 	rcall	8000acd8 <__sprint_r>
8000c9e8:	e0 81 01 11 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000c9ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9f0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c9f4:	2f f8       	sub	r8,-1
8000c9f6:	40 cb       	lddsp	r11,sp[0x30]
8000c9f8:	fb 48 06 90 	st.w	sp[1680],r8
8000c9fc:	30 19       	mov	r9,1
8000c9fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca02:	87 0b       	st.w	r3[0x0],r11
8000ca04:	2f f8       	sub	r8,-1
8000ca06:	87 19       	st.w	r3[0x4],r9
8000ca08:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca0c:	58 78       	cp.w	r8,7
8000ca0e:	e0 89 00 07 	brgt	8000ca1c <_vfprintf_r+0x1d28>
8000ca12:	2f 83       	sub	r3,-8
8000ca14:	c0 e8       	rjmp	8000ca30 <_vfprintf_r+0x1d3c>
8000ca16:	d7 03       	nop
8000ca18:	80 01       	ld.sh	r1,r0[0x0]
8000ca1a:	8f 90       	st.w	r7[0x24],r0
8000ca1c:	fa ca f9 78 	sub	r10,sp,-1672
8000ca20:	02 9b       	mov	r11,r1
8000ca22:	08 9c       	mov	r12,r4
8000ca24:	fe b0 f1 5a 	rcall	8000acd8 <__sprint_r>
8000ca28:	e0 81 00 f1 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000ca2c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca30:	30 08       	mov	r8,0
8000ca32:	30 09       	mov	r9,0
8000ca34:	40 5b       	lddsp	r11,sp[0x14]
8000ca36:	40 7a       	lddsp	r10,sp[0x1c]
8000ca38:	e0 a0 13 25 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000ca3c:	40 68       	lddsp	r8,sp[0x18]
8000ca3e:	20 18       	sub	r8,1
8000ca40:	58 0c       	cp.w	r12,0
8000ca42:	c0 d1       	brne	8000ca5c <_vfprintf_r+0x1d68>
8000ca44:	2f f6       	sub	r6,-1
8000ca46:	87 18       	st.w	r3[0x4],r8
8000ca48:	87 06       	st.w	r3[0x0],r6
8000ca4a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ca4e:	10 06       	add	r6,r8
8000ca50:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca54:	fb 46 06 90 	st.w	sp[1680],r6
8000ca58:	2f f8       	sub	r8,-1
8000ca5a:	c2 f8       	rjmp	8000cab8 <_vfprintf_r+0x1dc4>
8000ca5c:	10 96       	mov	r6,r8
8000ca5e:	58 08       	cp.w	r8,0
8000ca60:	e0 89 00 1c 	brgt	8000ca98 <_vfprintf_r+0x1da4>
8000ca64:	c4 98       	rjmp	8000caf6 <_vfprintf_r+0x1e02>
8000ca66:	2f 09       	sub	r9,-16
8000ca68:	2f f8       	sub	r8,-1
8000ca6a:	fb 49 06 90 	st.w	sp[1680],r9
8000ca6e:	87 02       	st.w	r3[0x0],r2
8000ca70:	87 10       	st.w	r3[0x4],r0
8000ca72:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca76:	58 78       	cp.w	r8,7
8000ca78:	e0 89 00 04 	brgt	8000ca80 <_vfprintf_r+0x1d8c>
8000ca7c:	2f 83       	sub	r3,-8
8000ca7e:	c0 b8       	rjmp	8000ca94 <_vfprintf_r+0x1da0>
8000ca80:	fa ca f9 78 	sub	r10,sp,-1672
8000ca84:	02 9b       	mov	r11,r1
8000ca86:	08 9c       	mov	r12,r4
8000ca88:	fe b0 f1 28 	rcall	8000acd8 <__sprint_r>
8000ca8c:	e0 81 00 bf 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000ca90:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca94:	21 06       	sub	r6,16
8000ca96:	c0 38       	rjmp	8000ca9c <_vfprintf_r+0x1da8>
8000ca98:	4d 22       	lddpc	r2,8000cbe0 <_vfprintf_r+0x1eec>
8000ca9a:	31 00       	mov	r0,16
8000ca9c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000caa0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caa4:	4c fa       	lddpc	r10,8000cbe0 <_vfprintf_r+0x1eec>
8000caa6:	59 06       	cp.w	r6,16
8000caa8:	fe 99 ff df 	brgt	8000ca66 <_vfprintf_r+0x1d72>
8000caac:	0c 09       	add	r9,r6
8000caae:	87 0a       	st.w	r3[0x0],r10
8000cab0:	fb 49 06 90 	st.w	sp[1680],r9
8000cab4:	2f f8       	sub	r8,-1
8000cab6:	87 16       	st.w	r3[0x4],r6
8000cab8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cabc:	c0 e8       	rjmp	8000cad8 <_vfprintf_r+0x1de4>
8000cabe:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cac2:	2f f8       	sub	r8,-1
8000cac4:	30 19       	mov	r9,1
8000cac6:	fb 48 06 90 	st.w	sp[1680],r8
8000caca:	87 06       	st.w	r3[0x0],r6
8000cacc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cad0:	87 19       	st.w	r3[0x4],r9
8000cad2:	2f f8       	sub	r8,-1
8000cad4:	fb 48 06 8c 	st.w	sp[1676],r8
8000cad8:	58 78       	cp.w	r8,7
8000cada:	e0 89 00 04 	brgt	8000cae2 <_vfprintf_r+0x1dee>
8000cade:	2f 83       	sub	r3,-8
8000cae0:	c0 b8       	rjmp	8000caf6 <_vfprintf_r+0x1e02>
8000cae2:	fa ca f9 78 	sub	r10,sp,-1672
8000cae6:	02 9b       	mov	r11,r1
8000cae8:	08 9c       	mov	r12,r4
8000caea:	fe b0 f0 f7 	rcall	8000acd8 <__sprint_r>
8000caee:	e0 81 00 8e 	brne	8000cc0a <_vfprintf_r+0x1f16>
8000caf2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000caf6:	40 ea       	lddsp	r10,sp[0x38]
8000caf8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cafc:	14 08       	add	r8,r10
8000cafe:	fa c9 f9 64 	sub	r9,sp,-1692
8000cb02:	fb 48 06 90 	st.w	sp[1680],r8
8000cb06:	87 1a       	st.w	r3[0x4],r10
8000cb08:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb0c:	87 09       	st.w	r3[0x0],r9
8000cb0e:	2f f8       	sub	r8,-1
8000cb10:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb14:	58 78       	cp.w	r8,7
8000cb16:	e0 89 00 04 	brgt	8000cb1e <_vfprintf_r+0x1e2a>
8000cb1a:	2f 83       	sub	r3,-8
8000cb1c:	c0 a8       	rjmp	8000cb30 <_vfprintf_r+0x1e3c>
8000cb1e:	fa ca f9 78 	sub	r10,sp,-1672
8000cb22:	02 9b       	mov	r11,r1
8000cb24:	08 9c       	mov	r12,r4
8000cb26:	fe b0 f0 d9 	rcall	8000acd8 <__sprint_r>
8000cb2a:	c7 01       	brne	8000cc0a <_vfprintf_r+0x1f16>
8000cb2c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb30:	e2 15 00 04 	andl	r5,0x4,COH
8000cb34:	c3 d0       	breq	8000cbae <_vfprintf_r+0x1eba>
8000cb36:	40 86       	lddsp	r6,sp[0x20]
8000cb38:	40 39       	lddsp	r9,sp[0xc]
8000cb3a:	12 16       	sub	r6,r9
8000cb3c:	58 06       	cp.w	r6,0
8000cb3e:	e0 89 00 1a 	brgt	8000cb72 <_vfprintf_r+0x1e7e>
8000cb42:	c3 68       	rjmp	8000cbae <_vfprintf_r+0x1eba>
8000cb44:	2f 09       	sub	r9,-16
8000cb46:	2f f8       	sub	r8,-1
8000cb48:	fb 49 06 90 	st.w	sp[1680],r9
8000cb4c:	87 05       	st.w	r3[0x0],r5
8000cb4e:	87 12       	st.w	r3[0x4],r2
8000cb50:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb54:	58 78       	cp.w	r8,7
8000cb56:	e0 89 00 04 	brgt	8000cb5e <_vfprintf_r+0x1e6a>
8000cb5a:	2f 83       	sub	r3,-8
8000cb5c:	c0 98       	rjmp	8000cb6e <_vfprintf_r+0x1e7a>
8000cb5e:	00 9a       	mov	r10,r0
8000cb60:	02 9b       	mov	r11,r1
8000cb62:	08 9c       	mov	r12,r4
8000cb64:	fe b0 f0 ba 	rcall	8000acd8 <__sprint_r>
8000cb68:	c5 11       	brne	8000cc0a <_vfprintf_r+0x1f16>
8000cb6a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb6e:	21 06       	sub	r6,16
8000cb70:	c0 58       	rjmp	8000cb7a <_vfprintf_r+0x1e86>
8000cb72:	49 d5       	lddpc	r5,8000cbe4 <_vfprintf_r+0x1ef0>
8000cb74:	31 02       	mov	r2,16
8000cb76:	fa c0 f9 78 	sub	r0,sp,-1672
8000cb7a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cb7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb82:	49 9a       	lddpc	r10,8000cbe4 <_vfprintf_r+0x1ef0>
8000cb84:	59 06       	cp.w	r6,16
8000cb86:	fe 99 ff df 	brgt	8000cb44 <_vfprintf_r+0x1e50>
8000cb8a:	0c 09       	add	r9,r6
8000cb8c:	2f f8       	sub	r8,-1
8000cb8e:	87 0a       	st.w	r3[0x0],r10
8000cb90:	87 16       	st.w	r3[0x4],r6
8000cb92:	fb 49 06 90 	st.w	sp[1680],r9
8000cb96:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb9a:	58 78       	cp.w	r8,7
8000cb9c:	e0 8a 00 09 	brle	8000cbae <_vfprintf_r+0x1eba>
8000cba0:	fa ca f9 78 	sub	r10,sp,-1672
8000cba4:	02 9b       	mov	r11,r1
8000cba6:	08 9c       	mov	r12,r4
8000cba8:	fe b0 f0 98 	rcall	8000acd8 <__sprint_r>
8000cbac:	c2 f1       	brne	8000cc0a <_vfprintf_r+0x1f16>
8000cbae:	40 bc       	lddsp	r12,sp[0x2c]
8000cbb0:	40 36       	lddsp	r6,sp[0xc]
8000cbb2:	40 8e       	lddsp	lr,sp[0x20]
8000cbb4:	ec 0e 0c 48 	max	r8,r6,lr
8000cbb8:	10 0c       	add	r12,r8
8000cbba:	50 bc       	stdsp	sp[0x2c],r12
8000cbbc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbc0:	58 08       	cp.w	r8,0
8000cbc2:	c0 80       	breq	8000cbd2 <_vfprintf_r+0x1ede>
8000cbc4:	fa ca f9 78 	sub	r10,sp,-1672
8000cbc8:	02 9b       	mov	r11,r1
8000cbca:	08 9c       	mov	r12,r4
8000cbcc:	fe b0 f0 86 	rcall	8000acd8 <__sprint_r>
8000cbd0:	c1 d1       	brne	8000cc0a <_vfprintf_r+0x1f16>
8000cbd2:	30 0b       	mov	r11,0
8000cbd4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbd8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000cbdc:	fe 9f f1 17 	bral	8000ae0a <_vfprintf_r+0x116>
8000cbe0:	80 01       	ld.sh	r1,r0[0x0]
8000cbe2:	8f 90       	st.w	r7[0x24],r0
8000cbe4:	80 01       	ld.sh	r1,r0[0x0]
8000cbe6:	8f 80       	st.w	r7[0x20],r0
8000cbe8:	08 95       	mov	r5,r4
8000cbea:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbee:	58 08       	cp.w	r8,0
8000cbf0:	c0 80       	breq	8000cc00 <_vfprintf_r+0x1f0c>
8000cbf2:	08 9c       	mov	r12,r4
8000cbf4:	fa ca f9 78 	sub	r10,sp,-1672
8000cbf8:	02 9b       	mov	r11,r1
8000cbfa:	fe b0 f0 6f 	rcall	8000acd8 <__sprint_r>
8000cbfe:	c0 61       	brne	8000cc0a <_vfprintf_r+0x1f16>
8000cc00:	30 08       	mov	r8,0
8000cc02:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc06:	c0 28       	rjmp	8000cc0a <_vfprintf_r+0x1f16>
8000cc08:	40 41       	lddsp	r1,sp[0x10]
8000cc0a:	82 68       	ld.sh	r8,r1[0xc]
8000cc0c:	ed b8 00 06 	bld	r8,0x6
8000cc10:	c0 31       	brne	8000cc16 <_vfprintf_r+0x1f22>
8000cc12:	3f fa       	mov	r10,-1
8000cc14:	50 ba       	stdsp	sp[0x2c],r10
8000cc16:	40 bc       	lddsp	r12,sp[0x2c]
8000cc18:	fe 3d f9 44 	sub	sp,-1724
8000cc1c:	d8 32       	popm	r0-r7,pc
8000cc1e:	d7 03       	nop

8000cc20 <__swsetup_r>:
8000cc20:	d4 21       	pushm	r4-r7,lr
8000cc22:	e0 68 0a 38 	mov	r8,2616
8000cc26:	18 96       	mov	r6,r12
8000cc28:	16 97       	mov	r7,r11
8000cc2a:	70 0c       	ld.w	r12,r8[0x0]
8000cc2c:	58 0c       	cp.w	r12,0
8000cc2e:	c0 60       	breq	8000cc3a <__swsetup_r+0x1a>
8000cc30:	78 68       	ld.w	r8,r12[0x18]
8000cc32:	58 08       	cp.w	r8,0
8000cc34:	c0 31       	brne	8000cc3a <__swsetup_r+0x1a>
8000cc36:	e0 a0 07 c7 	rcall	8000dbc4 <__sinit>
8000cc3a:	4a f8       	lddpc	r8,8000ccf4 <__swsetup_r+0xd4>
8000cc3c:	10 37       	cp.w	r7,r8
8000cc3e:	c0 61       	brne	8000cc4a <__swsetup_r+0x2a>
8000cc40:	e0 68 0a 38 	mov	r8,2616
8000cc44:	70 08       	ld.w	r8,r8[0x0]
8000cc46:	70 07       	ld.w	r7,r8[0x0]
8000cc48:	c1 08       	rjmp	8000cc68 <__swsetup_r+0x48>
8000cc4a:	4a c8       	lddpc	r8,8000ccf8 <__swsetup_r+0xd8>
8000cc4c:	10 37       	cp.w	r7,r8
8000cc4e:	c0 61       	brne	8000cc5a <__swsetup_r+0x3a>
8000cc50:	e0 68 0a 38 	mov	r8,2616
8000cc54:	70 08       	ld.w	r8,r8[0x0]
8000cc56:	70 17       	ld.w	r7,r8[0x4]
8000cc58:	c0 88       	rjmp	8000cc68 <__swsetup_r+0x48>
8000cc5a:	4a 98       	lddpc	r8,8000ccfc <__swsetup_r+0xdc>
8000cc5c:	10 37       	cp.w	r7,r8
8000cc5e:	c0 51       	brne	8000cc68 <__swsetup_r+0x48>
8000cc60:	e0 68 0a 38 	mov	r8,2616
8000cc64:	70 08       	ld.w	r8,r8[0x0]
8000cc66:	70 27       	ld.w	r7,r8[0x8]
8000cc68:	8e 68       	ld.sh	r8,r7[0xc]
8000cc6a:	ed b8 00 03 	bld	r8,0x3
8000cc6e:	c1 e0       	breq	8000ccaa <__swsetup_r+0x8a>
8000cc70:	ed b8 00 04 	bld	r8,0x4
8000cc74:	c3 e1       	brne	8000ccf0 <__swsetup_r+0xd0>
8000cc76:	ed b8 00 02 	bld	r8,0x2
8000cc7a:	c1 51       	brne	8000cca4 <__swsetup_r+0x84>
8000cc7c:	6e db       	ld.w	r11,r7[0x34]
8000cc7e:	58 0b       	cp.w	r11,0
8000cc80:	c0 a0       	breq	8000cc94 <__swsetup_r+0x74>
8000cc82:	ee c8 ff bc 	sub	r8,r7,-68
8000cc86:	10 3b       	cp.w	r11,r8
8000cc88:	c0 40       	breq	8000cc90 <__swsetup_r+0x70>
8000cc8a:	0c 9c       	mov	r12,r6
8000cc8c:	e0 a0 08 36 	rcall	8000dcf8 <_free_r>
8000cc90:	30 08       	mov	r8,0
8000cc92:	8f d8       	st.w	r7[0x34],r8
8000cc94:	8e 68       	ld.sh	r8,r7[0xc]
8000cc96:	e0 18 ff db 	andl	r8,0xffdb
8000cc9a:	ae 68       	st.h	r7[0xc],r8
8000cc9c:	30 08       	mov	r8,0
8000cc9e:	8f 18       	st.w	r7[0x4],r8
8000cca0:	6e 48       	ld.w	r8,r7[0x10]
8000cca2:	8f 08       	st.w	r7[0x0],r8
8000cca4:	8e 68       	ld.sh	r8,r7[0xc]
8000cca6:	a3 b8       	sbr	r8,0x3
8000cca8:	ae 68       	st.h	r7[0xc],r8
8000ccaa:	6e 48       	ld.w	r8,r7[0x10]
8000ccac:	58 08       	cp.w	r8,0
8000ccae:	c0 b1       	brne	8000ccc4 <__swsetup_r+0xa4>
8000ccb0:	8e 68       	ld.sh	r8,r7[0xc]
8000ccb2:	e2 18 02 80 	andl	r8,0x280,COH
8000ccb6:	e0 48 02 00 	cp.w	r8,512
8000ccba:	c0 50       	breq	8000ccc4 <__swsetup_r+0xa4>
8000ccbc:	0c 9c       	mov	r12,r6
8000ccbe:	0e 9b       	mov	r11,r7
8000ccc0:	e0 a0 0a 56 	rcall	8000e16c <__smakebuf_r>
8000ccc4:	8e 69       	ld.sh	r9,r7[0xc]
8000ccc6:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000ccca:	c0 70       	breq	8000ccd8 <__swsetup_r+0xb8>
8000cccc:	30 08       	mov	r8,0
8000ccce:	8f 28       	st.w	r7[0x8],r8
8000ccd0:	6e 58       	ld.w	r8,r7[0x14]
8000ccd2:	5c 38       	neg	r8
8000ccd4:	8f 68       	st.w	r7[0x18],r8
8000ccd6:	c0 68       	rjmp	8000cce2 <__swsetup_r+0xc2>
8000ccd8:	ed b9 00 01 	bld	r9,0x1
8000ccdc:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000cce0:	8f 28       	st.w	r7[0x8],r8
8000cce2:	6e 48       	ld.w	r8,r7[0x10]
8000cce4:	58 08       	cp.w	r8,0
8000cce6:	c0 61       	brne	8000ccf2 <__swsetup_r+0xd2>
8000cce8:	8e 68       	ld.sh	r8,r7[0xc]
8000ccea:	ed b8 00 07 	bld	r8,0x7
8000ccee:	c0 21       	brne	8000ccf2 <__swsetup_r+0xd2>
8000ccf0:	dc 2a       	popm	r4-r7,pc,r12=-1
8000ccf2:	d8 2a       	popm	r4-r7,pc,r12=0
8000ccf4:	80 01       	ld.sh	r1,r0[0x0]
8000ccf6:	90 b0       	ld.uh	r0,r8[0x6]
8000ccf8:	80 01       	ld.sh	r1,r0[0x0]
8000ccfa:	90 d0       	ld.uh	r0,r8[0xa]
8000ccfc:	80 01       	ld.sh	r1,r0[0x0]
8000ccfe:	90 f0       	ld.uh	r0,r8[0xe]

8000cd00 <quorem>:
8000cd00:	d4 31       	pushm	r0-r7,lr
8000cd02:	20 2d       	sub	sp,8
8000cd04:	18 97       	mov	r7,r12
8000cd06:	78 48       	ld.w	r8,r12[0x10]
8000cd08:	76 46       	ld.w	r6,r11[0x10]
8000cd0a:	0c 38       	cp.w	r8,r6
8000cd0c:	c0 34       	brge	8000cd12 <quorem+0x12>
8000cd0e:	30 0c       	mov	r12,0
8000cd10:	c8 58       	rjmp	8000ce1a <quorem+0x11a>
8000cd12:	ec c2 ff fc 	sub	r2,r6,-4
8000cd16:	f6 c3 ff ec 	sub	r3,r11,-20
8000cd1a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000cd1e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000cd22:	2f f9       	sub	r9,-1
8000cd24:	20 16       	sub	r6,1
8000cd26:	f8 09 0d 08 	divu	r8,r12,r9
8000cd2a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000cd2e:	ee c4 ff ec 	sub	r4,r7,-20
8000cd32:	10 95       	mov	r5,r8
8000cd34:	58 08       	cp.w	r8,0
8000cd36:	c4 10       	breq	8000cdb8 <quorem+0xb8>
8000cd38:	30 09       	mov	r9,0
8000cd3a:	06 9a       	mov	r10,r3
8000cd3c:	08 98       	mov	r8,r4
8000cd3e:	12 91       	mov	r1,r9
8000cd40:	50 0b       	stdsp	sp[0x0],r11
8000cd42:	70 0e       	ld.w	lr,r8[0x0]
8000cd44:	b1 8e       	lsr	lr,0x10
8000cd46:	50 1e       	stdsp	sp[0x4],lr
8000cd48:	15 0e       	ld.w	lr,r10++
8000cd4a:	fc 00 16 10 	lsr	r0,lr,0x10
8000cd4e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cd52:	ea 0e 03 41 	mac	r1,r5,lr
8000cd56:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000cd5a:	b1 81       	lsr	r1,0x10
8000cd5c:	40 1b       	lddsp	r11,sp[0x4]
8000cd5e:	ea 00 02 40 	mul	r0,r5,r0
8000cd62:	e2 00 00 00 	add	r0,r1,r0
8000cd66:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000cd6a:	02 1b       	sub	r11,r1
8000cd6c:	50 1b       	stdsp	sp[0x4],r11
8000cd6e:	70 0b       	ld.w	r11,r8[0x0]
8000cd70:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000cd74:	02 09       	add	r9,r1
8000cd76:	f2 0e 01 0e 	sub	lr,r9,lr
8000cd7a:	b0 1e       	st.h	r8[0x2],lr
8000cd7c:	fc 09 14 10 	asr	r9,lr,0x10
8000cd80:	40 1e       	lddsp	lr,sp[0x4]
8000cd82:	fc 09 00 09 	add	r9,lr,r9
8000cd86:	b0 09       	st.h	r8[0x0],r9
8000cd88:	e0 01 16 10 	lsr	r1,r0,0x10
8000cd8c:	2f c8       	sub	r8,-4
8000cd8e:	b1 49       	asr	r9,0x10
8000cd90:	04 3a       	cp.w	r10,r2
8000cd92:	fe 98 ff d8 	brls	8000cd42 <quorem+0x42>
8000cd96:	40 0b       	lddsp	r11,sp[0x0]
8000cd98:	58 0c       	cp.w	r12,0
8000cd9a:	c0 f1       	brne	8000cdb8 <quorem+0xb8>
8000cd9c:	ec c8 ff fb 	sub	r8,r6,-5
8000cda0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000cda4:	c0 28       	rjmp	8000cda8 <quorem+0xa8>
8000cda6:	20 16       	sub	r6,1
8000cda8:	20 48       	sub	r8,4
8000cdaa:	08 38       	cp.w	r8,r4
8000cdac:	e0 88 00 05 	brls	8000cdb6 <quorem+0xb6>
8000cdb0:	70 09       	ld.w	r9,r8[0x0]
8000cdb2:	58 09       	cp.w	r9,0
8000cdb4:	cf 90       	breq	8000cda6 <quorem+0xa6>
8000cdb6:	8f 46       	st.w	r7[0x10],r6
8000cdb8:	0e 9c       	mov	r12,r7
8000cdba:	e0 a0 0a d8 	rcall	8000e36a <__mcmp>
8000cdbe:	c2 d5       	brlt	8000ce18 <quorem+0x118>
8000cdc0:	2f f5       	sub	r5,-1
8000cdc2:	08 98       	mov	r8,r4
8000cdc4:	30 09       	mov	r9,0
8000cdc6:	07 0b       	ld.w	r11,r3++
8000cdc8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000cdcc:	70 0c       	ld.w	r12,r8[0x0]
8000cdce:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000cdd2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000cdd6:	14 1e       	sub	lr,r10
8000cdd8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000cddc:	16 1a       	sub	r10,r11
8000cdde:	12 0a       	add	r10,r9
8000cde0:	b0 1a       	st.h	r8[0x2],r10
8000cde2:	b1 4a       	asr	r10,0x10
8000cde4:	fc 0a 00 09 	add	r9,lr,r10
8000cde8:	b0 09       	st.h	r8[0x0],r9
8000cdea:	2f c8       	sub	r8,-4
8000cdec:	b1 49       	asr	r9,0x10
8000cdee:	04 33       	cp.w	r3,r2
8000cdf0:	fe 98 ff eb 	brls	8000cdc6 <quorem+0xc6>
8000cdf4:	ec c8 ff fb 	sub	r8,r6,-5
8000cdf8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000cdfc:	58 09       	cp.w	r9,0
8000cdfe:	c0 d1       	brne	8000ce18 <quorem+0x118>
8000ce00:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000ce04:	c0 28       	rjmp	8000ce08 <quorem+0x108>
8000ce06:	20 16       	sub	r6,1
8000ce08:	20 48       	sub	r8,4
8000ce0a:	08 38       	cp.w	r8,r4
8000ce0c:	e0 88 00 05 	brls	8000ce16 <quorem+0x116>
8000ce10:	70 09       	ld.w	r9,r8[0x0]
8000ce12:	58 09       	cp.w	r9,0
8000ce14:	cf 90       	breq	8000ce06 <quorem+0x106>
8000ce16:	8f 46       	st.w	r7[0x10],r6
8000ce18:	0a 9c       	mov	r12,r5
8000ce1a:	2f ed       	sub	sp,-8
8000ce1c:	d8 32       	popm	r0-r7,pc
8000ce1e:	d7 03       	nop

8000ce20 <_dtoa_r>:
8000ce20:	d4 31       	pushm	r0-r7,lr
8000ce22:	21 ad       	sub	sp,104
8000ce24:	fa c4 ff 74 	sub	r4,sp,-140
8000ce28:	18 97       	mov	r7,r12
8000ce2a:	16 95       	mov	r5,r11
8000ce2c:	68 2c       	ld.w	r12,r4[0x8]
8000ce2e:	50 c9       	stdsp	sp[0x30],r9
8000ce30:	68 16       	ld.w	r6,r4[0x4]
8000ce32:	68 09       	ld.w	r9,r4[0x0]
8000ce34:	50 e8       	stdsp	sp[0x38],r8
8000ce36:	14 94       	mov	r4,r10
8000ce38:	51 2c       	stdsp	sp[0x48],r12
8000ce3a:	fa e5 00 08 	st.d	sp[8],r4
8000ce3e:	51 59       	stdsp	sp[0x54],r9
8000ce40:	6e 95       	ld.w	r5,r7[0x24]
8000ce42:	58 05       	cp.w	r5,0
8000ce44:	c0 91       	brne	8000ce56 <_dtoa_r+0x36>
8000ce46:	31 0c       	mov	r12,16
8000ce48:	fe b0 e8 42 	rcall	80009ecc <malloc>
8000ce4c:	99 35       	st.w	r12[0xc],r5
8000ce4e:	8f 9c       	st.w	r7[0x24],r12
8000ce50:	99 15       	st.w	r12[0x4],r5
8000ce52:	99 25       	st.w	r12[0x8],r5
8000ce54:	99 05       	st.w	r12[0x0],r5
8000ce56:	6e 99       	ld.w	r9,r7[0x24]
8000ce58:	72 08       	ld.w	r8,r9[0x0]
8000ce5a:	58 08       	cp.w	r8,0
8000ce5c:	c0 f0       	breq	8000ce7a <_dtoa_r+0x5a>
8000ce5e:	72 1a       	ld.w	r10,r9[0x4]
8000ce60:	91 1a       	st.w	r8[0x4],r10
8000ce62:	30 1a       	mov	r10,1
8000ce64:	72 19       	ld.w	r9,r9[0x4]
8000ce66:	f4 09 09 49 	lsl	r9,r10,r9
8000ce6a:	10 9b       	mov	r11,r8
8000ce6c:	91 29       	st.w	r8[0x8],r9
8000ce6e:	0e 9c       	mov	r12,r7
8000ce70:	e0 a0 0a 96 	rcall	8000e39c <_Bfree>
8000ce74:	6e 98       	ld.w	r8,r7[0x24]
8000ce76:	30 09       	mov	r9,0
8000ce78:	91 09       	st.w	r8[0x0],r9
8000ce7a:	40 28       	lddsp	r8,sp[0x8]
8000ce7c:	10 94       	mov	r4,r8
8000ce7e:	58 08       	cp.w	r8,0
8000ce80:	c0 64       	brge	8000ce8c <_dtoa_r+0x6c>
8000ce82:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000ce86:	50 28       	stdsp	sp[0x8],r8
8000ce88:	30 18       	mov	r8,1
8000ce8a:	c0 28       	rjmp	8000ce8e <_dtoa_r+0x6e>
8000ce8c:	30 08       	mov	r8,0
8000ce8e:	8d 08       	st.w	r6[0x0],r8
8000ce90:	fc 1c 7f f0 	movh	r12,0x7ff0
8000ce94:	40 26       	lddsp	r6,sp[0x8]
8000ce96:	0c 98       	mov	r8,r6
8000ce98:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ce9c:	18 38       	cp.w	r8,r12
8000ce9e:	c1 e1       	brne	8000ceda <_dtoa_r+0xba>
8000cea0:	e0 68 27 0f 	mov	r8,9999
8000cea4:	41 5b       	lddsp	r11,sp[0x54]
8000cea6:	97 08       	st.w	r11[0x0],r8
8000cea8:	40 3a       	lddsp	r10,sp[0xc]
8000ceaa:	58 0a       	cp.w	r10,0
8000ceac:	c0 61       	brne	8000ceb8 <_dtoa_r+0x98>
8000ceae:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000ceb2:	c0 31       	brne	8000ceb8 <_dtoa_r+0x98>
8000ceb4:	4a cc       	lddpc	r12,8000cf64 <_dtoa_r+0x144>
8000ceb6:	c0 28       	rjmp	8000ceba <_dtoa_r+0x9a>
8000ceb8:	4a cc       	lddpc	r12,8000cf68 <_dtoa_r+0x148>
8000ceba:	41 29       	lddsp	r9,sp[0x48]
8000cebc:	58 09       	cp.w	r9,0
8000cebe:	e0 80 05 9e 	breq	8000d9fa <_dtoa_r+0xbda>
8000cec2:	f8 c8 ff fd 	sub	r8,r12,-3
8000cec6:	f8 c9 ff f8 	sub	r9,r12,-8
8000ceca:	11 8b       	ld.ub	r11,r8[0x0]
8000cecc:	30 0a       	mov	r10,0
8000cece:	41 25       	lddsp	r5,sp[0x48]
8000ced0:	f4 0b 18 00 	cp.b	r11,r10
8000ced4:	f2 08 17 10 	movne	r8,r9
8000ced8:	c1 58       	rjmp	8000cf02 <_dtoa_r+0xe2>
8000ceda:	fa ea 00 08 	ld.d	r10,sp[8]
8000cede:	30 08       	mov	r8,0
8000cee0:	fa eb 00 3c 	st.d	sp[60],r10
8000cee4:	30 09       	mov	r9,0
8000cee6:	e0 a0 10 ce 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000ceea:	c0 f0       	breq	8000cf08 <_dtoa_r+0xe8>
8000ceec:	30 18       	mov	r8,1
8000ceee:	41 5a       	lddsp	r10,sp[0x54]
8000cef0:	95 08       	st.w	r10[0x0],r8
8000cef2:	49 fc       	lddpc	r12,8000cf6c <_dtoa_r+0x14c>
8000cef4:	41 29       	lddsp	r9,sp[0x48]
8000cef6:	f8 08 00 08 	add	r8,r12,r8
8000cefa:	58 09       	cp.w	r9,0
8000cefc:	e0 80 05 7f 	breq	8000d9fa <_dtoa_r+0xbda>
8000cf00:	12 95       	mov	r5,r9
8000cf02:	8b 08       	st.w	r5[0x0],r8
8000cf04:	e0 8f 05 7b 	bral	8000d9fa <_dtoa_r+0xbda>
8000cf08:	fa c8 ff 9c 	sub	r8,sp,-100
8000cf0c:	fa c9 ff a0 	sub	r9,sp,-96
8000cf10:	fa ea 00 3c 	ld.d	r10,sp[60]
8000cf14:	0e 9c       	mov	r12,r7
8000cf16:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000cf1a:	e0 a0 0a 93 	rcall	8000e440 <__d2b>
8000cf1e:	18 93       	mov	r3,r12
8000cf20:	58 05       	cp.w	r5,0
8000cf22:	c0 d0       	breq	8000cf3c <_dtoa_r+0x11c>
8000cf24:	fa ea 00 3c 	ld.d	r10,sp[60]
8000cf28:	30 04       	mov	r4,0
8000cf2a:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000cf2e:	ea c5 03 ff 	sub	r5,r5,1023
8000cf32:	10 9b       	mov	r11,r8
8000cf34:	51 74       	stdsp	sp[0x5c],r4
8000cf36:	ea 1b 3f f0 	orh	r11,0x3ff0
8000cf3a:	c2 a8       	rjmp	8000cf8e <_dtoa_r+0x16e>
8000cf3c:	41 88       	lddsp	r8,sp[0x60]
8000cf3e:	41 9c       	lddsp	r12,sp[0x64]
8000cf40:	10 0c       	add	r12,r8
8000cf42:	f8 c5 fb ce 	sub	r5,r12,-1074
8000cf46:	e0 45 00 20 	cp.w	r5,32
8000cf4a:	e0 8a 00 13 	brle	8000cf70 <_dtoa_r+0x150>
8000cf4e:	f8 cc fb ee 	sub	r12,r12,-1042
8000cf52:	40 3b       	lddsp	r11,sp[0xc]
8000cf54:	ea 08 11 40 	rsub	r8,r5,64
8000cf58:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000cf5c:	ec 08 09 46 	lsl	r6,r6,r8
8000cf60:	0c 4c       	or	r12,r6
8000cf62:	c0 c8       	rjmp	8000cf7a <_dtoa_r+0x15a>
8000cf64:	80 01       	ld.sh	r1,r0[0x0]
8000cf66:	90 a0       	ld.uh	r0,r8[0x4]
8000cf68:	80 01       	ld.sh	r1,r0[0x0]
8000cf6a:	90 ac       	ld.uh	r12,r8[0x4]
8000cf6c:	80 01       	ld.sh	r1,r0[0x0]
8000cf6e:	8f 7c       	st.w	r7[0x1c],r12
8000cf70:	ea 0c 11 20 	rsub	r12,r5,32
8000cf74:	40 3a       	lddsp	r10,sp[0xc]
8000cf76:	f4 0c 09 4c 	lsl	r12,r10,r12
8000cf7a:	e0 a0 10 10 	rcall	8000ef9a <__avr32_u32_to_f64>
8000cf7e:	fc 18 fe 10 	movh	r8,0xfe10
8000cf82:	30 19       	mov	r9,1
8000cf84:	ea c5 04 33 	sub	r5,r5,1075
8000cf88:	f0 0b 00 0b 	add	r11,r8,r11
8000cf8c:	51 79       	stdsp	sp[0x5c],r9
8000cf8e:	30 08       	mov	r8,0
8000cf90:	fc 19 3f f8 	movh	r9,0x3ff8
8000cf94:	e0 a0 0e 98 	rcall	8000ecc4 <__avr32_f64_sub>
8000cf98:	e0 68 43 61 	mov	r8,17249
8000cf9c:	ea 18 63 6f 	orh	r8,0x636f
8000cfa0:	e0 69 87 a7 	mov	r9,34727
8000cfa4:	ea 19 3f d2 	orh	r9,0x3fd2
8000cfa8:	e0 a0 0d a2 	rcall	8000eaec <__avr32_f64_mul>
8000cfac:	e0 68 c8 b3 	mov	r8,51379
8000cfb0:	ea 18 8b 60 	orh	r8,0x8b60
8000cfb4:	e0 69 8a 28 	mov	r9,35368
8000cfb8:	ea 19 3f c6 	orh	r9,0x3fc6
8000cfbc:	e0 a0 0f 52 	rcall	8000ee60 <__avr32_f64_add>
8000cfc0:	0a 9c       	mov	r12,r5
8000cfc2:	14 90       	mov	r0,r10
8000cfc4:	16 91       	mov	r1,r11
8000cfc6:	e0 a0 0f ee 	rcall	8000efa2 <__avr32_s32_to_f64>
8000cfca:	e0 68 79 fb 	mov	r8,31227
8000cfce:	ea 18 50 9f 	orh	r8,0x509f
8000cfd2:	e0 69 44 13 	mov	r9,17427
8000cfd6:	ea 19 3f d3 	orh	r9,0x3fd3
8000cfda:	e0 a0 0d 89 	rcall	8000eaec <__avr32_f64_mul>
8000cfde:	14 98       	mov	r8,r10
8000cfe0:	16 99       	mov	r9,r11
8000cfe2:	00 9a       	mov	r10,r0
8000cfe4:	02 9b       	mov	r11,r1
8000cfe6:	e0 a0 0f 3d 	rcall	8000ee60 <__avr32_f64_add>
8000cfea:	14 90       	mov	r0,r10
8000cfec:	16 91       	mov	r1,r11
8000cfee:	e0 a0 0f c3 	rcall	8000ef74 <__avr32_f64_to_s32>
8000cff2:	30 08       	mov	r8,0
8000cff4:	18 96       	mov	r6,r12
8000cff6:	30 09       	mov	r9,0
8000cff8:	00 9a       	mov	r10,r0
8000cffa:	02 9b       	mov	r11,r1
8000cffc:	e0 a0 10 8a 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d000:	c0 c0       	breq	8000d018 <_dtoa_r+0x1f8>
8000d002:	0c 9c       	mov	r12,r6
8000d004:	e0 a0 0f cf 	rcall	8000efa2 <__avr32_s32_to_f64>
8000d008:	14 98       	mov	r8,r10
8000d00a:	16 99       	mov	r9,r11
8000d00c:	00 9a       	mov	r10,r0
8000d00e:	02 9b       	mov	r11,r1
8000d010:	e0 a0 10 39 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000d014:	f7 b6 00 01 	subeq	r6,1
8000d018:	59 66       	cp.w	r6,22
8000d01a:	e0 88 00 05 	brls	8000d024 <_dtoa_r+0x204>
8000d01e:	30 18       	mov	r8,1
8000d020:	51 48       	stdsp	sp[0x50],r8
8000d022:	c1 28       	rjmp	8000d046 <_dtoa_r+0x226>
8000d024:	4c 08       	lddpc	r8,8000d124 <_dtoa_r+0x304>
8000d026:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d02a:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d02e:	e0 a0 10 71 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d032:	f9 b4 00 00 	moveq	r4,0
8000d036:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d03a:	f7 b6 01 01 	subne	r6,1
8000d03e:	f9 bc 01 00 	movne	r12,0
8000d042:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d046:	41 90       	lddsp	r0,sp[0x64]
8000d048:	20 10       	sub	r0,1
8000d04a:	0a 10       	sub	r0,r5
8000d04c:	c0 46       	brmi	8000d054 <_dtoa_r+0x234>
8000d04e:	50 40       	stdsp	sp[0x10],r0
8000d050:	30 00       	mov	r0,0
8000d052:	c0 48       	rjmp	8000d05a <_dtoa_r+0x23a>
8000d054:	30 0b       	mov	r11,0
8000d056:	5c 30       	neg	r0
8000d058:	50 4b       	stdsp	sp[0x10],r11
8000d05a:	ec 02 11 00 	rsub	r2,r6,0
8000d05e:	58 06       	cp.w	r6,0
8000d060:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d064:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d068:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d06c:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d070:	f9 b2 04 00 	movge	r2,0
8000d074:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d078:	f9 b9 05 00 	movlt	r9,0
8000d07c:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d080:	40 c8       	lddsp	r8,sp[0x30]
8000d082:	58 98       	cp.w	r8,9
8000d084:	e0 8b 00 20 	brhi	8000d0c4 <_dtoa_r+0x2a4>
8000d088:	58 58       	cp.w	r8,5
8000d08a:	f9 b4 0a 01 	movle	r4,1
8000d08e:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d092:	f7 b5 09 04 	subgt	r5,4
8000d096:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d09a:	f9 b4 09 00 	movgt	r4,0
8000d09e:	40 cc       	lddsp	r12,sp[0x30]
8000d0a0:	58 3c       	cp.w	r12,3
8000d0a2:	c2 d0       	breq	8000d0fc <_dtoa_r+0x2dc>
8000d0a4:	e0 89 00 05 	brgt	8000d0ae <_dtoa_r+0x28e>
8000d0a8:	58 2c       	cp.w	r12,2
8000d0aa:	c1 01       	brne	8000d0ca <_dtoa_r+0x2aa>
8000d0ac:	c1 88       	rjmp	8000d0dc <_dtoa_r+0x2bc>
8000d0ae:	40 cb       	lddsp	r11,sp[0x30]
8000d0b0:	58 4b       	cp.w	r11,4
8000d0b2:	c0 60       	breq	8000d0be <_dtoa_r+0x29e>
8000d0b4:	58 5b       	cp.w	r11,5
8000d0b6:	c0 a1       	brne	8000d0ca <_dtoa_r+0x2aa>
8000d0b8:	30 1a       	mov	r10,1
8000d0ba:	50 da       	stdsp	sp[0x34],r10
8000d0bc:	c2 28       	rjmp	8000d100 <_dtoa_r+0x2e0>
8000d0be:	30 19       	mov	r9,1
8000d0c0:	50 d9       	stdsp	sp[0x34],r9
8000d0c2:	c0 f8       	rjmp	8000d0e0 <_dtoa_r+0x2c0>
8000d0c4:	30 08       	mov	r8,0
8000d0c6:	30 14       	mov	r4,1
8000d0c8:	50 c8       	stdsp	sp[0x30],r8
8000d0ca:	3f f5       	mov	r5,-1
8000d0cc:	30 1c       	mov	r12,1
8000d0ce:	30 0b       	mov	r11,0
8000d0d0:	50 95       	stdsp	sp[0x24],r5
8000d0d2:	50 dc       	stdsp	sp[0x34],r12
8000d0d4:	0a 91       	mov	r1,r5
8000d0d6:	31 28       	mov	r8,18
8000d0d8:	50 eb       	stdsp	sp[0x38],r11
8000d0da:	c2 08       	rjmp	8000d11a <_dtoa_r+0x2fa>
8000d0dc:	30 0a       	mov	r10,0
8000d0de:	50 da       	stdsp	sp[0x34],r10
8000d0e0:	40 e9       	lddsp	r9,sp[0x38]
8000d0e2:	58 09       	cp.w	r9,0
8000d0e4:	e0 89 00 07 	brgt	8000d0f2 <_dtoa_r+0x2d2>
8000d0e8:	30 18       	mov	r8,1
8000d0ea:	50 98       	stdsp	sp[0x24],r8
8000d0ec:	10 91       	mov	r1,r8
8000d0ee:	50 e8       	stdsp	sp[0x38],r8
8000d0f0:	c1 58       	rjmp	8000d11a <_dtoa_r+0x2fa>
8000d0f2:	40 e5       	lddsp	r5,sp[0x38]
8000d0f4:	50 95       	stdsp	sp[0x24],r5
8000d0f6:	0a 91       	mov	r1,r5
8000d0f8:	0a 98       	mov	r8,r5
8000d0fa:	c1 08       	rjmp	8000d11a <_dtoa_r+0x2fa>
8000d0fc:	30 0c       	mov	r12,0
8000d0fe:	50 dc       	stdsp	sp[0x34],r12
8000d100:	40 eb       	lddsp	r11,sp[0x38]
8000d102:	ec 0b 00 0b 	add	r11,r6,r11
8000d106:	50 9b       	stdsp	sp[0x24],r11
8000d108:	16 98       	mov	r8,r11
8000d10a:	2f f8       	sub	r8,-1
8000d10c:	58 08       	cp.w	r8,0
8000d10e:	e0 89 00 05 	brgt	8000d118 <_dtoa_r+0x2f8>
8000d112:	10 91       	mov	r1,r8
8000d114:	30 18       	mov	r8,1
8000d116:	c0 28       	rjmp	8000d11a <_dtoa_r+0x2fa>
8000d118:	10 91       	mov	r1,r8
8000d11a:	30 09       	mov	r9,0
8000d11c:	6e 9a       	ld.w	r10,r7[0x24]
8000d11e:	95 19       	st.w	r10[0x4],r9
8000d120:	30 49       	mov	r9,4
8000d122:	c0 78       	rjmp	8000d130 <_dtoa_r+0x310>
8000d124:	80 01       	ld.sh	r1,r0[0x0]
8000d126:	91 60       	st.w	r8[0x18],r0
8000d128:	6a 1a       	ld.w	r10,r5[0x4]
8000d12a:	a1 79       	lsl	r9,0x1
8000d12c:	2f fa       	sub	r10,-1
8000d12e:	8b 1a       	st.w	r5[0x4],r10
8000d130:	6e 95       	ld.w	r5,r7[0x24]
8000d132:	f2 ca ff ec 	sub	r10,r9,-20
8000d136:	10 3a       	cp.w	r10,r8
8000d138:	fe 98 ff f8 	brls	8000d128 <_dtoa_r+0x308>
8000d13c:	6a 1b       	ld.w	r11,r5[0x4]
8000d13e:	0e 9c       	mov	r12,r7
8000d140:	e0 a0 09 48 	rcall	8000e3d0 <_Balloc>
8000d144:	58 e1       	cp.w	r1,14
8000d146:	5f 88       	srls	r8
8000d148:	8b 0c       	st.w	r5[0x0],r12
8000d14a:	f1 e4 00 04 	and	r4,r8,r4
8000d14e:	6e 98       	ld.w	r8,r7[0x24]
8000d150:	70 08       	ld.w	r8,r8[0x0]
8000d152:	50 88       	stdsp	sp[0x20],r8
8000d154:	e0 80 01 82 	breq	8000d458 <_dtoa_r+0x638>
8000d158:	58 06       	cp.w	r6,0
8000d15a:	e0 8a 00 40 	brle	8000d1da <_dtoa_r+0x3ba>
8000d15e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d162:	4c b8       	lddpc	r8,8000d28c <_dtoa_r+0x46c>
8000d164:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d168:	fa e5 00 18 	st.d	sp[24],r4
8000d16c:	ec 04 14 04 	asr	r4,r6,0x4
8000d170:	ed b4 00 04 	bld	r4,0x4
8000d174:	c0 30       	breq	8000d17a <_dtoa_r+0x35a>
8000d176:	30 25       	mov	r5,2
8000d178:	c0 f8       	rjmp	8000d196 <_dtoa_r+0x376>
8000d17a:	4c 68       	lddpc	r8,8000d290 <_dtoa_r+0x470>
8000d17c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d180:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d184:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d188:	e0 a0 0f f8 	rcall	8000f178 <__avr32_f64_div>
8000d18c:	30 35       	mov	r5,3
8000d18e:	14 98       	mov	r8,r10
8000d190:	16 99       	mov	r9,r11
8000d192:	fa e9 00 08 	st.d	sp[8],r8
8000d196:	4b fc       	lddpc	r12,8000d290 <_dtoa_r+0x470>
8000d198:	50 a3       	stdsp	sp[0x28],r3
8000d19a:	0c 93       	mov	r3,r6
8000d19c:	18 96       	mov	r6,r12
8000d19e:	c0 f8       	rjmp	8000d1bc <_dtoa_r+0x39c>
8000d1a0:	fa ea 00 18 	ld.d	r10,sp[24]
8000d1a4:	ed b4 00 00 	bld	r4,0x0
8000d1a8:	c0 81       	brne	8000d1b8 <_dtoa_r+0x398>
8000d1aa:	ec e8 00 00 	ld.d	r8,r6[0]
8000d1ae:	2f f5       	sub	r5,-1
8000d1b0:	e0 a0 0c 9e 	rcall	8000eaec <__avr32_f64_mul>
8000d1b4:	fa eb 00 18 	st.d	sp[24],r10
8000d1b8:	a1 54       	asr	r4,0x1
8000d1ba:	2f 86       	sub	r6,-8
8000d1bc:	58 04       	cp.w	r4,0
8000d1be:	cf 11       	brne	8000d1a0 <_dtoa_r+0x380>
8000d1c0:	fa e8 00 18 	ld.d	r8,sp[24]
8000d1c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000d1c8:	06 96       	mov	r6,r3
8000d1ca:	e0 a0 0f d7 	rcall	8000f178 <__avr32_f64_div>
8000d1ce:	40 a3       	lddsp	r3,sp[0x28]
8000d1d0:	14 98       	mov	r8,r10
8000d1d2:	16 99       	mov	r9,r11
8000d1d4:	fa e9 00 08 	st.d	sp[8],r8
8000d1d8:	c2 d8       	rjmp	8000d232 <_dtoa_r+0x412>
8000d1da:	ec 08 11 00 	rsub	r8,r6,0
8000d1de:	c0 31       	brne	8000d1e4 <_dtoa_r+0x3c4>
8000d1e0:	30 25       	mov	r5,2
8000d1e2:	c2 88       	rjmp	8000d232 <_dtoa_r+0x412>
8000d1e4:	4a bc       	lddpc	r12,8000d290 <_dtoa_r+0x470>
8000d1e6:	f0 04 14 04 	asr	r4,r8,0x4
8000d1ea:	50 1c       	stdsp	sp[0x4],r12
8000d1ec:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d1f0:	4a 79       	lddpc	r9,8000d28c <_dtoa_r+0x46c>
8000d1f2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d1f6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d1fa:	e0 a0 0c 79 	rcall	8000eaec <__avr32_f64_mul>
8000d1fe:	40 1c       	lddsp	r12,sp[0x4]
8000d200:	50 63       	stdsp	sp[0x18],r3
8000d202:	30 25       	mov	r5,2
8000d204:	0c 93       	mov	r3,r6
8000d206:	fa eb 00 08 	st.d	sp[8],r10
8000d20a:	18 96       	mov	r6,r12
8000d20c:	c0 f8       	rjmp	8000d22a <_dtoa_r+0x40a>
8000d20e:	fa ea 00 08 	ld.d	r10,sp[8]
8000d212:	ed b4 00 00 	bld	r4,0x0
8000d216:	c0 81       	brne	8000d226 <_dtoa_r+0x406>
8000d218:	ec e8 00 00 	ld.d	r8,r6[0]
8000d21c:	2f f5       	sub	r5,-1
8000d21e:	e0 a0 0c 67 	rcall	8000eaec <__avr32_f64_mul>
8000d222:	fa eb 00 08 	st.d	sp[8],r10
8000d226:	a1 54       	asr	r4,0x1
8000d228:	2f 86       	sub	r6,-8
8000d22a:	58 04       	cp.w	r4,0
8000d22c:	cf 11       	brne	8000d20e <_dtoa_r+0x3ee>
8000d22e:	06 96       	mov	r6,r3
8000d230:	40 63       	lddsp	r3,sp[0x18]
8000d232:	41 4a       	lddsp	r10,sp[0x50]
8000d234:	58 0a       	cp.w	r10,0
8000d236:	c2 f0       	breq	8000d294 <_dtoa_r+0x474>
8000d238:	fa e8 00 08 	ld.d	r8,sp[8]
8000d23c:	58 01       	cp.w	r1,0
8000d23e:	5f 94       	srgt	r4
8000d240:	fa e9 00 18 	st.d	sp[24],r8
8000d244:	30 08       	mov	r8,0
8000d246:	fc 19 3f f0 	movh	r9,0x3ff0
8000d24a:	fa ea 00 18 	ld.d	r10,sp[24]
8000d24e:	e0 a0 0f 61 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d252:	f9 bc 00 00 	moveq	r12,0
8000d256:	f9 bc 01 01 	movne	r12,1
8000d25a:	e9 ec 00 0c 	and	r12,r4,r12
8000d25e:	c1 b0       	breq	8000d294 <_dtoa_r+0x474>
8000d260:	40 98       	lddsp	r8,sp[0x24]
8000d262:	58 08       	cp.w	r8,0
8000d264:	e0 8a 00 f6 	brle	8000d450 <_dtoa_r+0x630>
8000d268:	30 08       	mov	r8,0
8000d26a:	fc 19 40 24 	movh	r9,0x4024
8000d26e:	ec c4 00 01 	sub	r4,r6,1
8000d272:	fa ea 00 18 	ld.d	r10,sp[24]
8000d276:	2f f5       	sub	r5,-1
8000d278:	50 64       	stdsp	sp[0x18],r4
8000d27a:	e0 a0 0c 39 	rcall	8000eaec <__avr32_f64_mul>
8000d27e:	40 94       	lddsp	r4,sp[0x24]
8000d280:	14 98       	mov	r8,r10
8000d282:	16 99       	mov	r9,r11
8000d284:	fa e9 00 08 	st.d	sp[8],r8
8000d288:	c0 88       	rjmp	8000d298 <_dtoa_r+0x478>
8000d28a:	d7 03       	nop
8000d28c:	80 01       	ld.sh	r1,r0[0x0]
8000d28e:	91 60       	st.w	r8[0x18],r0
8000d290:	80 01       	ld.sh	r1,r0[0x0]
8000d292:	92 28       	ld.sh	r8,r9[0x4]
8000d294:	50 66       	stdsp	sp[0x18],r6
8000d296:	02 94       	mov	r4,r1
8000d298:	0a 9c       	mov	r12,r5
8000d29a:	e0 a0 0e 84 	rcall	8000efa2 <__avr32_s32_to_f64>
8000d29e:	fa e8 00 08 	ld.d	r8,sp[8]
8000d2a2:	e0 a0 0c 25 	rcall	8000eaec <__avr32_f64_mul>
8000d2a6:	30 08       	mov	r8,0
8000d2a8:	fc 19 40 1c 	movh	r9,0x401c
8000d2ac:	e0 a0 0d da 	rcall	8000ee60 <__avr32_f64_add>
8000d2b0:	14 98       	mov	r8,r10
8000d2b2:	16 99       	mov	r9,r11
8000d2b4:	fa e9 00 28 	st.d	sp[40],r8
8000d2b8:	fc 18 fc c0 	movh	r8,0xfcc0
8000d2bc:	40 a5       	lddsp	r5,sp[0x28]
8000d2be:	10 05       	add	r5,r8
8000d2c0:	50 a5       	stdsp	sp[0x28],r5
8000d2c2:	58 04       	cp.w	r4,0
8000d2c4:	c2 11       	brne	8000d306 <_dtoa_r+0x4e6>
8000d2c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d2ca:	30 08       	mov	r8,0
8000d2cc:	fc 19 40 14 	movh	r9,0x4014
8000d2d0:	e0 a0 0c fa 	rcall	8000ecc4 <__avr32_f64_sub>
8000d2d4:	40 bc       	lddsp	r12,sp[0x2c]
8000d2d6:	fa eb 00 08 	st.d	sp[8],r10
8000d2da:	14 98       	mov	r8,r10
8000d2dc:	16 99       	mov	r9,r11
8000d2de:	18 9a       	mov	r10,r12
8000d2e0:	0a 9b       	mov	r11,r5
8000d2e2:	e0 a0 0f 17 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d2e6:	e0 81 02 54 	brne	8000d78e <_dtoa_r+0x96e>
8000d2ea:	0a 98       	mov	r8,r5
8000d2ec:	40 b9       	lddsp	r9,sp[0x2c]
8000d2ee:	ee 18 80 00 	eorh	r8,0x8000
8000d2f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000d2f6:	10 95       	mov	r5,r8
8000d2f8:	12 98       	mov	r8,r9
8000d2fa:	0a 99       	mov	r9,r5
8000d2fc:	e0 a0 0f 0a 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d300:	e0 81 02 3e 	brne	8000d77c <_dtoa_r+0x95c>
8000d304:	ca 68       	rjmp	8000d450 <_dtoa_r+0x630>
8000d306:	4c e9       	lddpc	r9,8000d43c <_dtoa_r+0x61c>
8000d308:	e8 c8 00 01 	sub	r8,r4,1
8000d30c:	40 d5       	lddsp	r5,sp[0x34]
8000d30e:	58 05       	cp.w	r5,0
8000d310:	c4 f0       	breq	8000d3ae <_dtoa_r+0x58e>
8000d312:	30 0c       	mov	r12,0
8000d314:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d318:	51 3c       	stdsp	sp[0x4c],r12
8000d31a:	30 0a       	mov	r10,0
8000d31c:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d320:	e0 a0 0f 2c 	rcall	8000f178 <__avr32_f64_div>
8000d324:	fa e8 00 28 	ld.d	r8,sp[40]
8000d328:	40 85       	lddsp	r5,sp[0x20]
8000d32a:	e0 a0 0c cd 	rcall	8000ecc4 <__avr32_f64_sub>
8000d32e:	fa eb 00 28 	st.d	sp[40],r10
8000d332:	fa ea 00 08 	ld.d	r10,sp[8]
8000d336:	e0 a0 0e 1f 	rcall	8000ef74 <__avr32_f64_to_s32>
8000d33a:	51 6c       	stdsp	sp[0x58],r12
8000d33c:	e0 a0 0e 33 	rcall	8000efa2 <__avr32_s32_to_f64>
8000d340:	14 98       	mov	r8,r10
8000d342:	16 99       	mov	r9,r11
8000d344:	fa ea 00 08 	ld.d	r10,sp[8]
8000d348:	e0 a0 0c be 	rcall	8000ecc4 <__avr32_f64_sub>
8000d34c:	fa eb 00 08 	st.d	sp[8],r10
8000d350:	41 68       	lddsp	r8,sp[0x58]
8000d352:	2d 08       	sub	r8,-48
8000d354:	0a c8       	st.b	r5++,r8
8000d356:	41 39       	lddsp	r9,sp[0x4c]
8000d358:	2f f9       	sub	r9,-1
8000d35a:	51 39       	stdsp	sp[0x4c],r9
8000d35c:	fa e8 00 28 	ld.d	r8,sp[40]
8000d360:	e0 a0 0e d8 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d364:	e0 81 03 3a 	brne	8000d9d8 <_dtoa_r+0xbb8>
8000d368:	fa e8 00 08 	ld.d	r8,sp[8]
8000d36c:	30 0a       	mov	r10,0
8000d36e:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d372:	e0 a0 0c a9 	rcall	8000ecc4 <__avr32_f64_sub>
8000d376:	fa e8 00 28 	ld.d	r8,sp[40]
8000d37a:	e0 a0 0e cb 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d37e:	fa ea 00 28 	ld.d	r10,sp[40]
8000d382:	30 08       	mov	r8,0
8000d384:	fc 19 40 24 	movh	r9,0x4024
8000d388:	e0 81 00 da 	brne	8000d53c <_dtoa_r+0x71c>
8000d38c:	41 3c       	lddsp	r12,sp[0x4c]
8000d38e:	08 3c       	cp.w	r12,r4
8000d390:	c6 04       	brge	8000d450 <_dtoa_r+0x630>
8000d392:	e0 a0 0b ad 	rcall	8000eaec <__avr32_f64_mul>
8000d396:	30 08       	mov	r8,0
8000d398:	fa eb 00 28 	st.d	sp[40],r10
8000d39c:	fc 19 40 24 	movh	r9,0x4024
8000d3a0:	fa ea 00 08 	ld.d	r10,sp[8]
8000d3a4:	e0 a0 0b a4 	rcall	8000eaec <__avr32_f64_mul>
8000d3a8:	fa eb 00 08 	st.d	sp[8],r10
8000d3ac:	cc 3b       	rjmp	8000d332 <_dtoa_r+0x512>
8000d3ae:	40 85       	lddsp	r5,sp[0x20]
8000d3b0:	08 05       	add	r5,r4
8000d3b2:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d3b6:	51 35       	stdsp	sp[0x4c],r5
8000d3b8:	fa e8 00 28 	ld.d	r8,sp[40]
8000d3bc:	40 85       	lddsp	r5,sp[0x20]
8000d3be:	e0 a0 0b 97 	rcall	8000eaec <__avr32_f64_mul>
8000d3c2:	fa eb 00 28 	st.d	sp[40],r10
8000d3c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d3ca:	e0 a0 0d d5 	rcall	8000ef74 <__avr32_f64_to_s32>
8000d3ce:	51 6c       	stdsp	sp[0x58],r12
8000d3d0:	e0 a0 0d e9 	rcall	8000efa2 <__avr32_s32_to_f64>
8000d3d4:	14 98       	mov	r8,r10
8000d3d6:	16 99       	mov	r9,r11
8000d3d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000d3dc:	e0 a0 0c 74 	rcall	8000ecc4 <__avr32_f64_sub>
8000d3e0:	fa eb 00 08 	st.d	sp[8],r10
8000d3e4:	41 68       	lddsp	r8,sp[0x58]
8000d3e6:	2d 08       	sub	r8,-48
8000d3e8:	0a c8       	st.b	r5++,r8
8000d3ea:	41 3c       	lddsp	r12,sp[0x4c]
8000d3ec:	18 35       	cp.w	r5,r12
8000d3ee:	c2 91       	brne	8000d440 <_dtoa_r+0x620>
8000d3f0:	30 08       	mov	r8,0
8000d3f2:	fc 19 3f e0 	movh	r9,0x3fe0
8000d3f6:	fa ea 00 28 	ld.d	r10,sp[40]
8000d3fa:	e0 a0 0d 33 	rcall	8000ee60 <__avr32_f64_add>
8000d3fe:	40 85       	lddsp	r5,sp[0x20]
8000d400:	fa e8 00 08 	ld.d	r8,sp[8]
8000d404:	08 05       	add	r5,r4
8000d406:	e0 a0 0e 85 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d40a:	e0 81 00 99 	brne	8000d53c <_dtoa_r+0x71c>
8000d40e:	fa e8 00 28 	ld.d	r8,sp[40]
8000d412:	30 0a       	mov	r10,0
8000d414:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d418:	e0 a0 0c 56 	rcall	8000ecc4 <__avr32_f64_sub>
8000d41c:	14 98       	mov	r8,r10
8000d41e:	16 99       	mov	r9,r11
8000d420:	fa ea 00 08 	ld.d	r10,sp[8]
8000d424:	e0 a0 0e 76 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d428:	c1 40       	breq	8000d450 <_dtoa_r+0x630>
8000d42a:	33 09       	mov	r9,48
8000d42c:	0a 98       	mov	r8,r5
8000d42e:	11 7a       	ld.ub	r10,--r8
8000d430:	f2 0a 18 00 	cp.b	r10,r9
8000d434:	e0 81 02 d2 	brne	8000d9d8 <_dtoa_r+0xbb8>
8000d438:	10 95       	mov	r5,r8
8000d43a:	cf 9b       	rjmp	8000d42c <_dtoa_r+0x60c>
8000d43c:	80 01       	ld.sh	r1,r0[0x0]
8000d43e:	91 60       	st.w	r8[0x18],r0
8000d440:	30 08       	mov	r8,0
8000d442:	fc 19 40 24 	movh	r9,0x4024
8000d446:	e0 a0 0b 53 	rcall	8000eaec <__avr32_f64_mul>
8000d44a:	fa eb 00 08 	st.d	sp[8],r10
8000d44e:	cb cb       	rjmp	8000d3c6 <_dtoa_r+0x5a6>
8000d450:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d454:	fa eb 00 08 	st.d	sp[8],r10
8000d458:	58 e6       	cp.w	r6,14
8000d45a:	5f ab       	srle	r11
8000d45c:	41 8a       	lddsp	r10,sp[0x60]
8000d45e:	30 08       	mov	r8,0
8000d460:	f4 09 11 ff 	rsub	r9,r10,-1
8000d464:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000d468:	f0 09 18 00 	cp.b	r9,r8
8000d46c:	e0 80 00 81 	breq	8000d56e <_dtoa_r+0x74e>
8000d470:	40 ea       	lddsp	r10,sp[0x38]
8000d472:	58 01       	cp.w	r1,0
8000d474:	5f a9       	srle	r9
8000d476:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000d47a:	4c 9a       	lddpc	r10,8000d59c <_dtoa_r+0x77c>
8000d47c:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000d480:	fa e5 00 10 	st.d	sp[16],r4
8000d484:	f0 09 18 00 	cp.b	r9,r8
8000d488:	c1 40       	breq	8000d4b0 <_dtoa_r+0x690>
8000d48a:	58 01       	cp.w	r1,0
8000d48c:	e0 81 01 78 	brne	8000d77c <_dtoa_r+0x95c>
8000d490:	30 08       	mov	r8,0
8000d492:	fc 19 40 14 	movh	r9,0x4014
8000d496:	08 9a       	mov	r10,r4
8000d498:	0a 9b       	mov	r11,r5
8000d49a:	e0 a0 0b 29 	rcall	8000eaec <__avr32_f64_mul>
8000d49e:	fa e8 00 08 	ld.d	r8,sp[8]
8000d4a2:	e0 a0 0e 03 	rcall	8000f0a8 <__avr32_f64_cmp_ge>
8000d4a6:	e0 81 01 6b 	brne	8000d77c <_dtoa_r+0x95c>
8000d4aa:	02 92       	mov	r2,r1
8000d4ac:	e0 8f 01 73 	bral	8000d792 <_dtoa_r+0x972>
8000d4b0:	40 85       	lddsp	r5,sp[0x20]
8000d4b2:	30 14       	mov	r4,1
8000d4b4:	fa e8 00 10 	ld.d	r8,sp[16]
8000d4b8:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4bc:	e0 a0 0e 5e 	rcall	8000f178 <__avr32_f64_div>
8000d4c0:	e0 a0 0d 5a 	rcall	8000ef74 <__avr32_f64_to_s32>
8000d4c4:	18 92       	mov	r2,r12
8000d4c6:	e0 a0 0d 6e 	rcall	8000efa2 <__avr32_s32_to_f64>
8000d4ca:	fa e8 00 10 	ld.d	r8,sp[16]
8000d4ce:	e0 a0 0b 0f 	rcall	8000eaec <__avr32_f64_mul>
8000d4d2:	14 98       	mov	r8,r10
8000d4d4:	16 99       	mov	r9,r11
8000d4d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4da:	e0 a0 0b f5 	rcall	8000ecc4 <__avr32_f64_sub>
8000d4de:	fa eb 00 08 	st.d	sp[8],r10
8000d4e2:	e4 c8 ff d0 	sub	r8,r2,-48
8000d4e6:	0a c8       	st.b	r5++,r8
8000d4e8:	fc 19 40 24 	movh	r9,0x4024
8000d4ec:	30 08       	mov	r8,0
8000d4ee:	02 34       	cp.w	r4,r1
8000d4f0:	c3 31       	brne	8000d556 <_dtoa_r+0x736>
8000d4f2:	fa e8 00 08 	ld.d	r8,sp[8]
8000d4f6:	e0 a0 0c b5 	rcall	8000ee60 <__avr32_f64_add>
8000d4fa:	16 91       	mov	r1,r11
8000d4fc:	14 90       	mov	r0,r10
8000d4fe:	14 98       	mov	r8,r10
8000d500:	02 99       	mov	r9,r1
8000d502:	fa ea 00 10 	ld.d	r10,sp[16]
8000d506:	e0 a0 0e 05 	rcall	8000f110 <__avr32_f64_cmp_lt>
8000d50a:	c1 a1       	brne	8000d53e <_dtoa_r+0x71e>
8000d50c:	fa e8 00 10 	ld.d	r8,sp[16]
8000d510:	00 9a       	mov	r10,r0
8000d512:	02 9b       	mov	r11,r1
8000d514:	e0 a0 0d b7 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000d518:	e0 80 02 5f 	breq	8000d9d6 <_dtoa_r+0xbb6>
8000d51c:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000d520:	c0 f1       	brne	8000d53e <_dtoa_r+0x71e>
8000d522:	e0 8f 02 5a 	bral	8000d9d6 <_dtoa_r+0xbb6>
8000d526:	40 8a       	lddsp	r10,sp[0x20]
8000d528:	14 38       	cp.w	r8,r10
8000d52a:	c0 30       	breq	8000d530 <_dtoa_r+0x710>
8000d52c:	10 95       	mov	r5,r8
8000d52e:	c0 98       	rjmp	8000d540 <_dtoa_r+0x720>
8000d530:	33 08       	mov	r8,48
8000d532:	40 89       	lddsp	r9,sp[0x20]
8000d534:	2f f6       	sub	r6,-1
8000d536:	b2 88       	st.b	r9[0x0],r8
8000d538:	40 88       	lddsp	r8,sp[0x20]
8000d53a:	c0 88       	rjmp	8000d54a <_dtoa_r+0x72a>
8000d53c:	40 66       	lddsp	r6,sp[0x18]
8000d53e:	33 99       	mov	r9,57
8000d540:	0a 98       	mov	r8,r5
8000d542:	11 7a       	ld.ub	r10,--r8
8000d544:	f2 0a 18 00 	cp.b	r10,r9
8000d548:	ce f0       	breq	8000d526 <_dtoa_r+0x706>
8000d54a:	50 66       	stdsp	sp[0x18],r6
8000d54c:	11 89       	ld.ub	r9,r8[0x0]
8000d54e:	2f f9       	sub	r9,-1
8000d550:	b0 89       	st.b	r8[0x0],r9
8000d552:	e0 8f 02 43 	bral	8000d9d8 <_dtoa_r+0xbb8>
8000d556:	e0 a0 0a cb 	rcall	8000eaec <__avr32_f64_mul>
8000d55a:	2f f4       	sub	r4,-1
8000d55c:	fa eb 00 08 	st.d	sp[8],r10
8000d560:	30 08       	mov	r8,0
8000d562:	30 09       	mov	r9,0
8000d564:	e0 a0 0d 8f 	rcall	8000f082 <__avr32_f64_cmp_eq>
8000d568:	ca 60       	breq	8000d4b4 <_dtoa_r+0x694>
8000d56a:	e0 8f 02 36 	bral	8000d9d6 <_dtoa_r+0xbb6>
8000d56e:	40 d8       	lddsp	r8,sp[0x34]
8000d570:	58 08       	cp.w	r8,0
8000d572:	c0 51       	brne	8000d57c <_dtoa_r+0x75c>
8000d574:	04 98       	mov	r8,r2
8000d576:	00 95       	mov	r5,r0
8000d578:	40 d4       	lddsp	r4,sp[0x34]
8000d57a:	c3 88       	rjmp	8000d5ea <_dtoa_r+0x7ca>
8000d57c:	40 c5       	lddsp	r5,sp[0x30]
8000d57e:	58 15       	cp.w	r5,1
8000d580:	e0 89 00 10 	brgt	8000d5a0 <_dtoa_r+0x780>
8000d584:	41 74       	lddsp	r4,sp[0x5c]
8000d586:	58 04       	cp.w	r4,0
8000d588:	c0 40       	breq	8000d590 <_dtoa_r+0x770>
8000d58a:	f4 c9 fb cd 	sub	r9,r10,-1075
8000d58e:	c0 48       	rjmp	8000d596 <_dtoa_r+0x776>
8000d590:	41 99       	lddsp	r9,sp[0x64]
8000d592:	f2 09 11 36 	rsub	r9,r9,54
8000d596:	04 98       	mov	r8,r2
8000d598:	00 95       	mov	r5,r0
8000d59a:	c1 d8       	rjmp	8000d5d4 <_dtoa_r+0x7b4>
8000d59c:	80 01       	ld.sh	r1,r0[0x0]
8000d59e:	91 60       	st.w	r8[0x18],r0
8000d5a0:	e2 c8 00 01 	sub	r8,r1,1
8000d5a4:	58 01       	cp.w	r1,0
8000d5a6:	e0 05 17 40 	movge	r5,r0
8000d5aa:	e2 09 17 40 	movge	r9,r1
8000d5ae:	e1 d1 e5 15 	sublt	r5,r0,r1
8000d5b2:	f9 b9 05 00 	movlt	r9,0
8000d5b6:	10 32       	cp.w	r2,r8
8000d5b8:	e5 d8 e4 18 	subge	r8,r2,r8
8000d5bc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000d5c0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000d5c4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000d5c8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000d5cc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000d5d0:	f9 b8 05 00 	movlt	r8,0
8000d5d4:	40 4b       	lddsp	r11,sp[0x10]
8000d5d6:	12 0b       	add	r11,r9
8000d5d8:	50 08       	stdsp	sp[0x0],r8
8000d5da:	50 4b       	stdsp	sp[0x10],r11
8000d5dc:	12 00       	add	r0,r9
8000d5de:	30 1b       	mov	r11,1
8000d5e0:	0e 9c       	mov	r12,r7
8000d5e2:	e0 a0 08 ab 	rcall	8000e738 <__i2b>
8000d5e6:	40 08       	lddsp	r8,sp[0x0]
8000d5e8:	18 94       	mov	r4,r12
8000d5ea:	40 4a       	lddsp	r10,sp[0x10]
8000d5ec:	58 05       	cp.w	r5,0
8000d5ee:	5f 99       	srgt	r9
8000d5f0:	58 0a       	cp.w	r10,0
8000d5f2:	5f 9a       	srgt	r10
8000d5f4:	f5 e9 00 09 	and	r9,r10,r9
8000d5f8:	c0 80       	breq	8000d608 <_dtoa_r+0x7e8>
8000d5fa:	40 4c       	lddsp	r12,sp[0x10]
8000d5fc:	f8 05 0d 49 	min	r9,r12,r5
8000d600:	12 1c       	sub	r12,r9
8000d602:	12 10       	sub	r0,r9
8000d604:	50 4c       	stdsp	sp[0x10],r12
8000d606:	12 15       	sub	r5,r9
8000d608:	58 02       	cp.w	r2,0
8000d60a:	e0 8a 00 27 	brle	8000d658 <_dtoa_r+0x838>
8000d60e:	40 db       	lddsp	r11,sp[0x34]
8000d610:	58 0b       	cp.w	r11,0
8000d612:	c1 d0       	breq	8000d64c <_dtoa_r+0x82c>
8000d614:	58 08       	cp.w	r8,0
8000d616:	e0 8a 00 17 	brle	8000d644 <_dtoa_r+0x824>
8000d61a:	10 9a       	mov	r10,r8
8000d61c:	50 08       	stdsp	sp[0x0],r8
8000d61e:	08 9b       	mov	r11,r4
8000d620:	0e 9c       	mov	r12,r7
8000d622:	e0 a0 08 d1 	rcall	8000e7c4 <__pow5mult>
8000d626:	06 9a       	mov	r10,r3
8000d628:	18 9b       	mov	r11,r12
8000d62a:	18 94       	mov	r4,r12
8000d62c:	0e 9c       	mov	r12,r7
8000d62e:	e0 a0 08 05 	rcall	8000e638 <__multiply>
8000d632:	18 99       	mov	r9,r12
8000d634:	06 9b       	mov	r11,r3
8000d636:	50 19       	stdsp	sp[0x4],r9
8000d638:	0e 9c       	mov	r12,r7
8000d63a:	e0 a0 06 b1 	rcall	8000e39c <_Bfree>
8000d63e:	40 19       	lddsp	r9,sp[0x4]
8000d640:	40 08       	lddsp	r8,sp[0x0]
8000d642:	12 93       	mov	r3,r9
8000d644:	e4 08 01 0a 	sub	r10,r2,r8
8000d648:	c0 80       	breq	8000d658 <_dtoa_r+0x838>
8000d64a:	c0 28       	rjmp	8000d64e <_dtoa_r+0x82e>
8000d64c:	04 9a       	mov	r10,r2
8000d64e:	06 9b       	mov	r11,r3
8000d650:	0e 9c       	mov	r12,r7
8000d652:	e0 a0 08 b9 	rcall	8000e7c4 <__pow5mult>
8000d656:	18 93       	mov	r3,r12
8000d658:	30 1b       	mov	r11,1
8000d65a:	0e 9c       	mov	r12,r7
8000d65c:	e0 a0 08 6e 	rcall	8000e738 <__i2b>
8000d660:	41 1a       	lddsp	r10,sp[0x44]
8000d662:	18 92       	mov	r2,r12
8000d664:	58 0a       	cp.w	r10,0
8000d666:	e0 8a 00 07 	brle	8000d674 <_dtoa_r+0x854>
8000d66a:	18 9b       	mov	r11,r12
8000d66c:	0e 9c       	mov	r12,r7
8000d66e:	e0 a0 08 ab 	rcall	8000e7c4 <__pow5mult>
8000d672:	18 92       	mov	r2,r12
8000d674:	40 c9       	lddsp	r9,sp[0x30]
8000d676:	58 19       	cp.w	r9,1
8000d678:	e0 89 00 14 	brgt	8000d6a0 <_dtoa_r+0x880>
8000d67c:	40 38       	lddsp	r8,sp[0xc]
8000d67e:	58 08       	cp.w	r8,0
8000d680:	c1 01       	brne	8000d6a0 <_dtoa_r+0x880>
8000d682:	40 29       	lddsp	r9,sp[0x8]
8000d684:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000d688:	c0 c1       	brne	8000d6a0 <_dtoa_r+0x880>
8000d68a:	12 98       	mov	r8,r9
8000d68c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d690:	c0 80       	breq	8000d6a0 <_dtoa_r+0x880>
8000d692:	40 4c       	lddsp	r12,sp[0x10]
8000d694:	30 1b       	mov	r11,1
8000d696:	2f fc       	sub	r12,-1
8000d698:	2f f0       	sub	r0,-1
8000d69a:	50 4c       	stdsp	sp[0x10],r12
8000d69c:	50 6b       	stdsp	sp[0x18],r11
8000d69e:	c0 38       	rjmp	8000d6a4 <_dtoa_r+0x884>
8000d6a0:	30 0a       	mov	r10,0
8000d6a2:	50 6a       	stdsp	sp[0x18],r10
8000d6a4:	41 19       	lddsp	r9,sp[0x44]
8000d6a6:	58 09       	cp.w	r9,0
8000d6a8:	c0 31       	brne	8000d6ae <_dtoa_r+0x88e>
8000d6aa:	30 1c       	mov	r12,1
8000d6ac:	c0 98       	rjmp	8000d6be <_dtoa_r+0x89e>
8000d6ae:	64 48       	ld.w	r8,r2[0x10]
8000d6b0:	2f c8       	sub	r8,-4
8000d6b2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000d6b6:	e0 a0 05 e3 	rcall	8000e27c <__hi0bits>
8000d6ba:	f8 0c 11 20 	rsub	r12,r12,32
8000d6be:	40 4b       	lddsp	r11,sp[0x10]
8000d6c0:	f8 0b 00 08 	add	r8,r12,r11
8000d6c4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000d6c8:	c0 c0       	breq	8000d6e0 <_dtoa_r+0x8c0>
8000d6ca:	f0 08 11 20 	rsub	r8,r8,32
8000d6ce:	58 48       	cp.w	r8,4
8000d6d0:	e0 8a 00 06 	brle	8000d6dc <_dtoa_r+0x8bc>
8000d6d4:	20 48       	sub	r8,4
8000d6d6:	10 0b       	add	r11,r8
8000d6d8:	50 4b       	stdsp	sp[0x10],r11
8000d6da:	c0 78       	rjmp	8000d6e8 <_dtoa_r+0x8c8>
8000d6dc:	58 48       	cp.w	r8,4
8000d6de:	c0 70       	breq	8000d6ec <_dtoa_r+0x8cc>
8000d6e0:	40 4a       	lddsp	r10,sp[0x10]
8000d6e2:	2e 48       	sub	r8,-28
8000d6e4:	10 0a       	add	r10,r8
8000d6e6:	50 4a       	stdsp	sp[0x10],r10
8000d6e8:	10 00       	add	r0,r8
8000d6ea:	10 05       	add	r5,r8
8000d6ec:	58 00       	cp.w	r0,0
8000d6ee:	e0 8a 00 08 	brle	8000d6fe <_dtoa_r+0x8de>
8000d6f2:	06 9b       	mov	r11,r3
8000d6f4:	00 9a       	mov	r10,r0
8000d6f6:	0e 9c       	mov	r12,r7
8000d6f8:	e0 a0 07 5c 	rcall	8000e5b0 <__lshift>
8000d6fc:	18 93       	mov	r3,r12
8000d6fe:	40 49       	lddsp	r9,sp[0x10]
8000d700:	58 09       	cp.w	r9,0
8000d702:	e0 8a 00 08 	brle	8000d712 <_dtoa_r+0x8f2>
8000d706:	04 9b       	mov	r11,r2
8000d708:	12 9a       	mov	r10,r9
8000d70a:	0e 9c       	mov	r12,r7
8000d70c:	e0 a0 07 52 	rcall	8000e5b0 <__lshift>
8000d710:	18 92       	mov	r2,r12
8000d712:	41 48       	lddsp	r8,sp[0x50]
8000d714:	58 08       	cp.w	r8,0
8000d716:	c1 b0       	breq	8000d74c <_dtoa_r+0x92c>
8000d718:	04 9b       	mov	r11,r2
8000d71a:	06 9c       	mov	r12,r3
8000d71c:	e0 a0 06 27 	rcall	8000e36a <__mcmp>
8000d720:	c1 64       	brge	8000d74c <_dtoa_r+0x92c>
8000d722:	06 9b       	mov	r11,r3
8000d724:	30 09       	mov	r9,0
8000d726:	30 aa       	mov	r10,10
8000d728:	0e 9c       	mov	r12,r7
8000d72a:	e0 a0 08 0f 	rcall	8000e748 <__multadd>
8000d72e:	20 16       	sub	r6,1
8000d730:	18 93       	mov	r3,r12
8000d732:	40 dc       	lddsp	r12,sp[0x34]
8000d734:	58 0c       	cp.w	r12,0
8000d736:	c0 31       	brne	8000d73c <_dtoa_r+0x91c>
8000d738:	40 91       	lddsp	r1,sp[0x24]
8000d73a:	c0 98       	rjmp	8000d74c <_dtoa_r+0x92c>
8000d73c:	08 9b       	mov	r11,r4
8000d73e:	40 91       	lddsp	r1,sp[0x24]
8000d740:	30 09       	mov	r9,0
8000d742:	30 aa       	mov	r10,10
8000d744:	0e 9c       	mov	r12,r7
8000d746:	e0 a0 08 01 	rcall	8000e748 <__multadd>
8000d74a:	18 94       	mov	r4,r12
8000d74c:	58 01       	cp.w	r1,0
8000d74e:	5f a9       	srle	r9
8000d750:	40 cb       	lddsp	r11,sp[0x30]
8000d752:	58 2b       	cp.w	r11,2
8000d754:	5f 98       	srgt	r8
8000d756:	f3 e8 00 08 	and	r8,r9,r8
8000d75a:	c2 50       	breq	8000d7a4 <_dtoa_r+0x984>
8000d75c:	58 01       	cp.w	r1,0
8000d75e:	c1 11       	brne	8000d780 <_dtoa_r+0x960>
8000d760:	04 9b       	mov	r11,r2
8000d762:	02 99       	mov	r9,r1
8000d764:	30 5a       	mov	r10,5
8000d766:	0e 9c       	mov	r12,r7
8000d768:	e0 a0 07 f0 	rcall	8000e748 <__multadd>
8000d76c:	18 92       	mov	r2,r12
8000d76e:	18 9b       	mov	r11,r12
8000d770:	06 9c       	mov	r12,r3
8000d772:	e0 a0 05 fc 	rcall	8000e36a <__mcmp>
8000d776:	e0 89 00 0f 	brgt	8000d794 <_dtoa_r+0x974>
8000d77a:	c0 38       	rjmp	8000d780 <_dtoa_r+0x960>
8000d77c:	30 02       	mov	r2,0
8000d77e:	04 94       	mov	r4,r2
8000d780:	40 ea       	lddsp	r10,sp[0x38]
8000d782:	30 09       	mov	r9,0
8000d784:	5c da       	com	r10
8000d786:	40 85       	lddsp	r5,sp[0x20]
8000d788:	50 6a       	stdsp	sp[0x18],r10
8000d78a:	50 49       	stdsp	sp[0x10],r9
8000d78c:	c0 f9       	rjmp	8000d9aa <_dtoa_r+0xb8a>
8000d78e:	08 92       	mov	r2,r4
8000d790:	40 66       	lddsp	r6,sp[0x18]
8000d792:	04 94       	mov	r4,r2
8000d794:	2f f6       	sub	r6,-1
8000d796:	50 66       	stdsp	sp[0x18],r6
8000d798:	33 18       	mov	r8,49
8000d79a:	40 85       	lddsp	r5,sp[0x20]
8000d79c:	0a c8       	st.b	r5++,r8
8000d79e:	30 08       	mov	r8,0
8000d7a0:	50 48       	stdsp	sp[0x10],r8
8000d7a2:	c0 49       	rjmp	8000d9aa <_dtoa_r+0xb8a>
8000d7a4:	40 dc       	lddsp	r12,sp[0x34]
8000d7a6:	58 0c       	cp.w	r12,0
8000d7a8:	e0 80 00 b5 	breq	8000d912 <_dtoa_r+0xaf2>
8000d7ac:	58 05       	cp.w	r5,0
8000d7ae:	e0 8a 00 08 	brle	8000d7be <_dtoa_r+0x99e>
8000d7b2:	08 9b       	mov	r11,r4
8000d7b4:	0a 9a       	mov	r10,r5
8000d7b6:	0e 9c       	mov	r12,r7
8000d7b8:	e0 a0 06 fc 	rcall	8000e5b0 <__lshift>
8000d7bc:	18 94       	mov	r4,r12
8000d7be:	40 6b       	lddsp	r11,sp[0x18]
8000d7c0:	58 0b       	cp.w	r11,0
8000d7c2:	c0 31       	brne	8000d7c8 <_dtoa_r+0x9a8>
8000d7c4:	08 9c       	mov	r12,r4
8000d7c6:	c1 38       	rjmp	8000d7ec <_dtoa_r+0x9cc>
8000d7c8:	68 1b       	ld.w	r11,r4[0x4]
8000d7ca:	0e 9c       	mov	r12,r7
8000d7cc:	e0 a0 06 02 	rcall	8000e3d0 <_Balloc>
8000d7d0:	68 4a       	ld.w	r10,r4[0x10]
8000d7d2:	18 95       	mov	r5,r12
8000d7d4:	e8 cb ff f4 	sub	r11,r4,-12
8000d7d8:	2f ea       	sub	r10,-2
8000d7da:	2f 4c       	sub	r12,-12
8000d7dc:	a3 6a       	lsl	r10,0x2
8000d7de:	fe b0 e5 ae 	rcall	8000a33a <memcpy>
8000d7e2:	0a 9b       	mov	r11,r5
8000d7e4:	30 1a       	mov	r10,1
8000d7e6:	0e 9c       	mov	r12,r7
8000d7e8:	e0 a0 06 e4 	rcall	8000e5b0 <__lshift>
8000d7ec:	50 44       	stdsp	sp[0x10],r4
8000d7ee:	40 3a       	lddsp	r10,sp[0xc]
8000d7f0:	30 19       	mov	r9,1
8000d7f2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d7f6:	18 94       	mov	r4,r12
8000d7f8:	50 da       	stdsp	sp[0x34],r10
8000d7fa:	40 85       	lddsp	r5,sp[0x20]
8000d7fc:	50 99       	stdsp	sp[0x24],r9
8000d7fe:	50 26       	stdsp	sp[0x8],r6
8000d800:	50 e1       	stdsp	sp[0x38],r1
8000d802:	04 9b       	mov	r11,r2
8000d804:	06 9c       	mov	r12,r3
8000d806:	fe b0 fa 7d 	rcall	8000cd00 <quorem>
8000d80a:	40 4b       	lddsp	r11,sp[0x10]
8000d80c:	f8 c0 ff d0 	sub	r0,r12,-48
8000d810:	06 9c       	mov	r12,r3
8000d812:	e0 a0 05 ac 	rcall	8000e36a <__mcmp>
8000d816:	08 9a       	mov	r10,r4
8000d818:	50 6c       	stdsp	sp[0x18],r12
8000d81a:	04 9b       	mov	r11,r2
8000d81c:	0e 9c       	mov	r12,r7
8000d81e:	e0 a0 06 61 	rcall	8000e4e0 <__mdiff>
8000d822:	18 91       	mov	r1,r12
8000d824:	78 38       	ld.w	r8,r12[0xc]
8000d826:	58 08       	cp.w	r8,0
8000d828:	c0 30       	breq	8000d82e <_dtoa_r+0xa0e>
8000d82a:	30 16       	mov	r6,1
8000d82c:	c0 68       	rjmp	8000d838 <_dtoa_r+0xa18>
8000d82e:	18 9b       	mov	r11,r12
8000d830:	06 9c       	mov	r12,r3
8000d832:	e0 a0 05 9c 	rcall	8000e36a <__mcmp>
8000d836:	18 96       	mov	r6,r12
8000d838:	0e 9c       	mov	r12,r7
8000d83a:	02 9b       	mov	r11,r1
8000d83c:	e0 a0 05 b0 	rcall	8000e39c <_Bfree>
8000d840:	40 cc       	lddsp	r12,sp[0x30]
8000d842:	ed ec 10 08 	or	r8,r6,r12
8000d846:	c0 d1       	brne	8000d860 <_dtoa_r+0xa40>
8000d848:	40 db       	lddsp	r11,sp[0x34]
8000d84a:	58 0b       	cp.w	r11,0
8000d84c:	c0 a1       	brne	8000d860 <_dtoa_r+0xa40>
8000d84e:	40 26       	lddsp	r6,sp[0x8]
8000d850:	e0 40 00 39 	cp.w	r0,57
8000d854:	c3 00       	breq	8000d8b4 <_dtoa_r+0xa94>
8000d856:	40 6a       	lddsp	r10,sp[0x18]
8000d858:	58 0a       	cp.w	r10,0
8000d85a:	e0 89 00 24 	brgt	8000d8a2 <_dtoa_r+0xa82>
8000d85e:	c2 f8       	rjmp	8000d8bc <_dtoa_r+0xa9c>
8000d860:	40 69       	lddsp	r9,sp[0x18]
8000d862:	58 09       	cp.w	r9,0
8000d864:	c0 85       	brlt	8000d874 <_dtoa_r+0xa54>
8000d866:	12 98       	mov	r8,r9
8000d868:	40 cc       	lddsp	r12,sp[0x30]
8000d86a:	18 48       	or	r8,r12
8000d86c:	c1 d1       	brne	8000d8a6 <_dtoa_r+0xa86>
8000d86e:	40 db       	lddsp	r11,sp[0x34]
8000d870:	58 0b       	cp.w	r11,0
8000d872:	c1 a1       	brne	8000d8a6 <_dtoa_r+0xa86>
8000d874:	0c 99       	mov	r9,r6
8000d876:	40 26       	lddsp	r6,sp[0x8]
8000d878:	58 09       	cp.w	r9,0
8000d87a:	e0 8a 00 21 	brle	8000d8bc <_dtoa_r+0xa9c>
8000d87e:	06 9b       	mov	r11,r3
8000d880:	30 1a       	mov	r10,1
8000d882:	0e 9c       	mov	r12,r7
8000d884:	e0 a0 06 96 	rcall	8000e5b0 <__lshift>
8000d888:	04 9b       	mov	r11,r2
8000d88a:	18 93       	mov	r3,r12
8000d88c:	e0 a0 05 6f 	rcall	8000e36a <__mcmp>
8000d890:	e0 89 00 06 	brgt	8000d89c <_dtoa_r+0xa7c>
8000d894:	c1 41       	brne	8000d8bc <_dtoa_r+0xa9c>
8000d896:	ed b0 00 00 	bld	r0,0x0
8000d89a:	c1 11       	brne	8000d8bc <_dtoa_r+0xa9c>
8000d89c:	e0 40 00 39 	cp.w	r0,57
8000d8a0:	c0 a0       	breq	8000d8b4 <_dtoa_r+0xa94>
8000d8a2:	2f f0       	sub	r0,-1
8000d8a4:	c0 c8       	rjmp	8000d8bc <_dtoa_r+0xa9c>
8000d8a6:	58 06       	cp.w	r6,0
8000d8a8:	e0 8a 00 0c 	brle	8000d8c0 <_dtoa_r+0xaa0>
8000d8ac:	40 26       	lddsp	r6,sp[0x8]
8000d8ae:	e0 40 00 39 	cp.w	r0,57
8000d8b2:	c0 41       	brne	8000d8ba <_dtoa_r+0xa9a>
8000d8b4:	33 98       	mov	r8,57
8000d8b6:	0a c8       	st.b	r5++,r8
8000d8b8:	c6 78       	rjmp	8000d986 <_dtoa_r+0xb66>
8000d8ba:	2f f0       	sub	r0,-1
8000d8bc:	0a c0       	st.b	r5++,r0
8000d8be:	c7 58       	rjmp	8000d9a8 <_dtoa_r+0xb88>
8000d8c0:	0a c0       	st.b	r5++,r0
8000d8c2:	40 9a       	lddsp	r10,sp[0x24]
8000d8c4:	40 e9       	lddsp	r9,sp[0x38]
8000d8c6:	12 3a       	cp.w	r10,r9
8000d8c8:	c4 30       	breq	8000d94e <_dtoa_r+0xb2e>
8000d8ca:	06 9b       	mov	r11,r3
8000d8cc:	30 09       	mov	r9,0
8000d8ce:	30 aa       	mov	r10,10
8000d8d0:	0e 9c       	mov	r12,r7
8000d8d2:	e0 a0 07 3b 	rcall	8000e748 <__multadd>
8000d8d6:	40 48       	lddsp	r8,sp[0x10]
8000d8d8:	18 93       	mov	r3,r12
8000d8da:	08 38       	cp.w	r8,r4
8000d8dc:	c0 91       	brne	8000d8ee <_dtoa_r+0xace>
8000d8de:	10 9b       	mov	r11,r8
8000d8e0:	30 09       	mov	r9,0
8000d8e2:	30 aa       	mov	r10,10
8000d8e4:	0e 9c       	mov	r12,r7
8000d8e6:	e0 a0 07 31 	rcall	8000e748 <__multadd>
8000d8ea:	50 4c       	stdsp	sp[0x10],r12
8000d8ec:	c0 e8       	rjmp	8000d908 <_dtoa_r+0xae8>
8000d8ee:	40 4b       	lddsp	r11,sp[0x10]
8000d8f0:	30 09       	mov	r9,0
8000d8f2:	30 aa       	mov	r10,10
8000d8f4:	0e 9c       	mov	r12,r7
8000d8f6:	e0 a0 07 29 	rcall	8000e748 <__multadd>
8000d8fa:	08 9b       	mov	r11,r4
8000d8fc:	50 4c       	stdsp	sp[0x10],r12
8000d8fe:	30 09       	mov	r9,0
8000d900:	30 aa       	mov	r10,10
8000d902:	0e 9c       	mov	r12,r7
8000d904:	e0 a0 07 22 	rcall	8000e748 <__multadd>
8000d908:	18 94       	mov	r4,r12
8000d90a:	40 9c       	lddsp	r12,sp[0x24]
8000d90c:	2f fc       	sub	r12,-1
8000d90e:	50 9c       	stdsp	sp[0x24],r12
8000d910:	c7 9b       	rjmp	8000d802 <_dtoa_r+0x9e2>
8000d912:	30 18       	mov	r8,1
8000d914:	06 90       	mov	r0,r3
8000d916:	40 85       	lddsp	r5,sp[0x20]
8000d918:	08 93       	mov	r3,r4
8000d91a:	0c 94       	mov	r4,r6
8000d91c:	10 96       	mov	r6,r8
8000d91e:	04 9b       	mov	r11,r2
8000d920:	00 9c       	mov	r12,r0
8000d922:	fe b0 f9 ef 	rcall	8000cd00 <quorem>
8000d926:	2d 0c       	sub	r12,-48
8000d928:	0a cc       	st.b	r5++,r12
8000d92a:	02 36       	cp.w	r6,r1
8000d92c:	c0 a4       	brge	8000d940 <_dtoa_r+0xb20>
8000d92e:	00 9b       	mov	r11,r0
8000d930:	30 09       	mov	r9,0
8000d932:	30 aa       	mov	r10,10
8000d934:	0e 9c       	mov	r12,r7
8000d936:	2f f6       	sub	r6,-1
8000d938:	e0 a0 07 08 	rcall	8000e748 <__multadd>
8000d93c:	18 90       	mov	r0,r12
8000d93e:	cf 0b       	rjmp	8000d91e <_dtoa_r+0xafe>
8000d940:	08 96       	mov	r6,r4
8000d942:	30 0b       	mov	r11,0
8000d944:	06 94       	mov	r4,r3
8000d946:	50 4b       	stdsp	sp[0x10],r11
8000d948:	00 93       	mov	r3,r0
8000d94a:	18 90       	mov	r0,r12
8000d94c:	c0 28       	rjmp	8000d950 <_dtoa_r+0xb30>
8000d94e:	40 26       	lddsp	r6,sp[0x8]
8000d950:	06 9b       	mov	r11,r3
8000d952:	30 1a       	mov	r10,1
8000d954:	0e 9c       	mov	r12,r7
8000d956:	e0 a0 06 2d 	rcall	8000e5b0 <__lshift>
8000d95a:	04 9b       	mov	r11,r2
8000d95c:	18 93       	mov	r3,r12
8000d95e:	e0 a0 05 06 	rcall	8000e36a <__mcmp>
8000d962:	e0 89 00 12 	brgt	8000d986 <_dtoa_r+0xb66>
8000d966:	c1 b1       	brne	8000d99c <_dtoa_r+0xb7c>
8000d968:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000d96c:	c0 d1       	brne	8000d986 <_dtoa_r+0xb66>
8000d96e:	c1 78       	rjmp	8000d99c <_dtoa_r+0xb7c>
8000d970:	40 89       	lddsp	r9,sp[0x20]
8000d972:	12 38       	cp.w	r8,r9
8000d974:	c0 30       	breq	8000d97a <_dtoa_r+0xb5a>
8000d976:	10 95       	mov	r5,r8
8000d978:	c0 88       	rjmp	8000d988 <_dtoa_r+0xb68>
8000d97a:	2f f6       	sub	r6,-1
8000d97c:	50 66       	stdsp	sp[0x18],r6
8000d97e:	33 18       	mov	r8,49
8000d980:	40 8c       	lddsp	r12,sp[0x20]
8000d982:	b8 88       	st.b	r12[0x0],r8
8000d984:	c1 38       	rjmp	8000d9aa <_dtoa_r+0xb8a>
8000d986:	33 9a       	mov	r10,57
8000d988:	0a 98       	mov	r8,r5
8000d98a:	11 79       	ld.ub	r9,--r8
8000d98c:	f4 09 18 00 	cp.b	r9,r10
8000d990:	cf 00       	breq	8000d970 <_dtoa_r+0xb50>
8000d992:	2f f9       	sub	r9,-1
8000d994:	b0 89       	st.b	r8[0x0],r9
8000d996:	c0 98       	rjmp	8000d9a8 <_dtoa_r+0xb88>
8000d998:	10 95       	mov	r5,r8
8000d99a:	c0 28       	rjmp	8000d99e <_dtoa_r+0xb7e>
8000d99c:	33 09       	mov	r9,48
8000d99e:	0a 98       	mov	r8,r5
8000d9a0:	11 7a       	ld.ub	r10,--r8
8000d9a2:	f2 0a 18 00 	cp.b	r10,r9
8000d9a6:	cf 90       	breq	8000d998 <_dtoa_r+0xb78>
8000d9a8:	50 66       	stdsp	sp[0x18],r6
8000d9aa:	04 9b       	mov	r11,r2
8000d9ac:	0e 9c       	mov	r12,r7
8000d9ae:	e0 a0 04 f7 	rcall	8000e39c <_Bfree>
8000d9b2:	58 04       	cp.w	r4,0
8000d9b4:	c1 20       	breq	8000d9d8 <_dtoa_r+0xbb8>
8000d9b6:	40 4b       	lddsp	r11,sp[0x10]
8000d9b8:	08 3b       	cp.w	r11,r4
8000d9ba:	5f 19       	srne	r9
8000d9bc:	58 0b       	cp.w	r11,0
8000d9be:	5f 18       	srne	r8
8000d9c0:	f3 e8 00 08 	and	r8,r9,r8
8000d9c4:	c0 40       	breq	8000d9cc <_dtoa_r+0xbac>
8000d9c6:	0e 9c       	mov	r12,r7
8000d9c8:	e0 a0 04 ea 	rcall	8000e39c <_Bfree>
8000d9cc:	08 9b       	mov	r11,r4
8000d9ce:	0e 9c       	mov	r12,r7
8000d9d0:	e0 a0 04 e6 	rcall	8000e39c <_Bfree>
8000d9d4:	c0 28       	rjmp	8000d9d8 <_dtoa_r+0xbb8>
8000d9d6:	50 66       	stdsp	sp[0x18],r6
8000d9d8:	0e 9c       	mov	r12,r7
8000d9da:	06 9b       	mov	r11,r3
8000d9dc:	e0 a0 04 e0 	rcall	8000e39c <_Bfree>
8000d9e0:	30 08       	mov	r8,0
8000d9e2:	aa 88       	st.b	r5[0x0],r8
8000d9e4:	40 68       	lddsp	r8,sp[0x18]
8000d9e6:	41 5a       	lddsp	r10,sp[0x54]
8000d9e8:	2f f8       	sub	r8,-1
8000d9ea:	41 29       	lddsp	r9,sp[0x48]
8000d9ec:	95 08       	st.w	r10[0x0],r8
8000d9ee:	40 8c       	lddsp	r12,sp[0x20]
8000d9f0:	58 09       	cp.w	r9,0
8000d9f2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000d9f6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000d9fa:	2e 6d       	sub	sp,-104
8000d9fc:	d8 32       	popm	r0-r7,pc
8000d9fe:	d7 03       	nop

8000da00 <__errno>:
8000da00:	e0 68 0a 38 	mov	r8,2616
8000da04:	70 0c       	ld.w	r12,r8[0x0]
8000da06:	2f 4c       	sub	r12,-12
8000da08:	5e fc       	retal	r12
8000da0a:	d7 03       	nop

8000da0c <_fflush_r>:
8000da0c:	d4 21       	pushm	r4-r7,lr
8000da0e:	16 97       	mov	r7,r11
8000da10:	18 96       	mov	r6,r12
8000da12:	76 48       	ld.w	r8,r11[0x10]
8000da14:	58 08       	cp.w	r8,0
8000da16:	c7 c0       	breq	8000db0e <_fflush_r+0x102>
8000da18:	58 0c       	cp.w	r12,0
8000da1a:	c0 50       	breq	8000da24 <_fflush_r+0x18>
8000da1c:	78 68       	ld.w	r8,r12[0x18]
8000da1e:	58 08       	cp.w	r8,0
8000da20:	c0 21       	brne	8000da24 <_fflush_r+0x18>
8000da22:	cd 1c       	rcall	8000dbc4 <__sinit>
8000da24:	4b b8       	lddpc	r8,8000db10 <_fflush_r+0x104>
8000da26:	10 37       	cp.w	r7,r8
8000da28:	c0 31       	brne	8000da2e <_fflush_r+0x22>
8000da2a:	6c 07       	ld.w	r7,r6[0x0]
8000da2c:	c0 a8       	rjmp	8000da40 <_fflush_r+0x34>
8000da2e:	4b a8       	lddpc	r8,8000db14 <_fflush_r+0x108>
8000da30:	10 37       	cp.w	r7,r8
8000da32:	c0 31       	brne	8000da38 <_fflush_r+0x2c>
8000da34:	6c 17       	ld.w	r7,r6[0x4]
8000da36:	c0 58       	rjmp	8000da40 <_fflush_r+0x34>
8000da38:	4b 88       	lddpc	r8,8000db18 <_fflush_r+0x10c>
8000da3a:	10 37       	cp.w	r7,r8
8000da3c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000da40:	8e 6a       	ld.sh	r10,r7[0xc]
8000da42:	14 98       	mov	r8,r10
8000da44:	ed ba 00 03 	bld	r10,0x3
8000da48:	c4 20       	breq	8000dacc <_fflush_r+0xc0>
8000da4a:	ab ba       	sbr	r10,0xb
8000da4c:	ae 6a       	st.h	r7[0xc],r10
8000da4e:	6e 18       	ld.w	r8,r7[0x4]
8000da50:	58 08       	cp.w	r8,0
8000da52:	e0 89 00 06 	brgt	8000da5e <_fflush_r+0x52>
8000da56:	6f 08       	ld.w	r8,r7[0x40]
8000da58:	58 08       	cp.w	r8,0
8000da5a:	e0 8a 00 5a 	brle	8000db0e <_fflush_r+0x102>
8000da5e:	6e b8       	ld.w	r8,r7[0x2c]
8000da60:	58 08       	cp.w	r8,0
8000da62:	c5 60       	breq	8000db0e <_fflush_r+0x102>
8000da64:	e2 1a 10 00 	andl	r10,0x1000,COH
8000da68:	c0 30       	breq	8000da6e <_fflush_r+0x62>
8000da6a:	6f 55       	ld.w	r5,r7[0x54]
8000da6c:	c0 f8       	rjmp	8000da8a <_fflush_r+0x7e>
8000da6e:	30 19       	mov	r9,1
8000da70:	6e 8b       	ld.w	r11,r7[0x20]
8000da72:	0c 9c       	mov	r12,r6
8000da74:	5d 18       	icall	r8
8000da76:	18 95       	mov	r5,r12
8000da78:	5b fc       	cp.w	r12,-1
8000da7a:	c0 81       	brne	8000da8a <_fflush_r+0x7e>
8000da7c:	6c 38       	ld.w	r8,r6[0xc]
8000da7e:	59 d8       	cp.w	r8,29
8000da80:	c4 70       	breq	8000db0e <_fflush_r+0x102>
8000da82:	8e 68       	ld.sh	r8,r7[0xc]
8000da84:	a7 a8       	sbr	r8,0x6
8000da86:	ae 68       	st.h	r7[0xc],r8
8000da88:	d8 22       	popm	r4-r7,pc
8000da8a:	8e 68       	ld.sh	r8,r7[0xc]
8000da8c:	ed b8 00 02 	bld	r8,0x2
8000da90:	c0 91       	brne	8000daa2 <_fflush_r+0x96>
8000da92:	6e 18       	ld.w	r8,r7[0x4]
8000da94:	10 15       	sub	r5,r8
8000da96:	6e d8       	ld.w	r8,r7[0x34]
8000da98:	58 08       	cp.w	r8,0
8000da9a:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000da9e:	eb d8 e1 15 	subne	r5,r5,r8
8000daa2:	6e b8       	ld.w	r8,r7[0x2c]
8000daa4:	0c 9c       	mov	r12,r6
8000daa6:	30 09       	mov	r9,0
8000daa8:	0a 9a       	mov	r10,r5
8000daaa:	6e 8b       	ld.w	r11,r7[0x20]
8000daac:	5d 18       	icall	r8
8000daae:	8e 68       	ld.sh	r8,r7[0xc]
8000dab0:	0a 3c       	cp.w	r12,r5
8000dab2:	c2 61       	brne	8000dafe <_fflush_r+0xf2>
8000dab4:	ab d8       	cbr	r8,0xb
8000dab6:	30 0c       	mov	r12,0
8000dab8:	6e 49       	ld.w	r9,r7[0x10]
8000daba:	ae 68       	st.h	r7[0xc],r8
8000dabc:	8f 1c       	st.w	r7[0x4],r12
8000dabe:	8f 09       	st.w	r7[0x0],r9
8000dac0:	ed b8 00 0c 	bld	r8,0xc
8000dac4:	c2 51       	brne	8000db0e <_fflush_r+0x102>
8000dac6:	ef 45 00 54 	st.w	r7[84],r5
8000daca:	d8 22       	popm	r4-r7,pc
8000dacc:	6e 45       	ld.w	r5,r7[0x10]
8000dace:	58 05       	cp.w	r5,0
8000dad0:	c1 f0       	breq	8000db0e <_fflush_r+0x102>
8000dad2:	6e 04       	ld.w	r4,r7[0x0]
8000dad4:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000dad8:	8f 05       	st.w	r7[0x0],r5
8000dada:	f9 b8 01 00 	movne	r8,0
8000dade:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000dae2:	0a 14       	sub	r4,r5
8000dae4:	8f 28       	st.w	r7[0x8],r8
8000dae6:	c1 18       	rjmp	8000db08 <_fflush_r+0xfc>
8000dae8:	08 99       	mov	r9,r4
8000daea:	0a 9a       	mov	r10,r5
8000daec:	6e a8       	ld.w	r8,r7[0x28]
8000daee:	6e 8b       	ld.w	r11,r7[0x20]
8000daf0:	0c 9c       	mov	r12,r6
8000daf2:	5d 18       	icall	r8
8000daf4:	18 14       	sub	r4,r12
8000daf6:	58 0c       	cp.w	r12,0
8000daf8:	e0 89 00 07 	brgt	8000db06 <_fflush_r+0xfa>
8000dafc:	8e 68       	ld.sh	r8,r7[0xc]
8000dafe:	a7 a8       	sbr	r8,0x6
8000db00:	3f fc       	mov	r12,-1
8000db02:	ae 68       	st.h	r7[0xc],r8
8000db04:	d8 22       	popm	r4-r7,pc
8000db06:	18 05       	add	r5,r12
8000db08:	58 04       	cp.w	r4,0
8000db0a:	fe 99 ff ef 	brgt	8000dae8 <_fflush_r+0xdc>
8000db0e:	d8 2a       	popm	r4-r7,pc,r12=0
8000db10:	80 01       	ld.sh	r1,r0[0x0]
8000db12:	90 b0       	ld.uh	r0,r8[0x6]
8000db14:	80 01       	ld.sh	r1,r0[0x0]
8000db16:	90 d0       	ld.uh	r0,r8[0xa]
8000db18:	80 01       	ld.sh	r1,r0[0x0]
8000db1a:	90 f0       	ld.uh	r0,r8[0xe]

8000db1c <__sfp_lock_acquire>:
8000db1c:	5e fc       	retal	r12

8000db1e <__sfp_lock_release>:
8000db1e:	5e fc       	retal	r12

8000db20 <_cleanup_r>:
8000db20:	d4 01       	pushm	lr
8000db22:	fe cb f0 ba 	sub	r11,pc,-3910
8000db26:	e0 a0 02 f9 	rcall	8000e118 <_fwalk>
8000db2a:	d8 02       	popm	pc

8000db2c <__sfmoreglue>:
8000db2c:	d4 21       	pushm	r4-r7,lr
8000db2e:	16 95       	mov	r5,r11
8000db30:	f6 06 10 5c 	mul	r6,r11,92
8000db34:	ec cb ff f4 	sub	r11,r6,-12
8000db38:	fe b0 e1 d2 	rcall	80009edc <_malloc_r>
8000db3c:	18 97       	mov	r7,r12
8000db3e:	c0 90       	breq	8000db50 <__sfmoreglue+0x24>
8000db40:	99 15       	st.w	r12[0x4],r5
8000db42:	30 0b       	mov	r11,0
8000db44:	2f 4c       	sub	r12,-12
8000db46:	0c 9a       	mov	r10,r6
8000db48:	8f 2c       	st.w	r7[0x8],r12
8000db4a:	8f 0b       	st.w	r7[0x0],r11
8000db4c:	fe b0 e4 9b 	rcall	8000a482 <memset>
8000db50:	0e 9c       	mov	r12,r7
8000db52:	d8 22       	popm	r4-r7,pc

8000db54 <__sfp>:
8000db54:	d4 21       	pushm	r4-r7,lr
8000db56:	49 b8       	lddpc	r8,8000dbc0 <__sfp+0x6c>
8000db58:	18 96       	mov	r6,r12
8000db5a:	70 07       	ld.w	r7,r8[0x0]
8000db5c:	6e 68       	ld.w	r8,r7[0x18]
8000db5e:	58 08       	cp.w	r8,0
8000db60:	c0 31       	brne	8000db66 <__sfp+0x12>
8000db62:	0e 9c       	mov	r12,r7
8000db64:	c3 0c       	rcall	8000dbc4 <__sinit>
8000db66:	ee c7 ff 28 	sub	r7,r7,-216
8000db6a:	30 05       	mov	r5,0
8000db6c:	6e 2c       	ld.w	r12,r7[0x8]
8000db6e:	6e 18       	ld.w	r8,r7[0x4]
8000db70:	c0 68       	rjmp	8000db7c <__sfp+0x28>
8000db72:	98 69       	ld.sh	r9,r12[0xc]
8000db74:	ea 09 19 00 	cp.h	r9,r5
8000db78:	c1 10       	breq	8000db9a <__sfp+0x46>
8000db7a:	2a 4c       	sub	r12,-92
8000db7c:	20 18       	sub	r8,1
8000db7e:	cf a7       	brpl	8000db72 <__sfp+0x1e>
8000db80:	6e 08       	ld.w	r8,r7[0x0]
8000db82:	58 08       	cp.w	r8,0
8000db84:	c0 61       	brne	8000db90 <__sfp+0x3c>
8000db86:	30 4b       	mov	r11,4
8000db88:	0c 9c       	mov	r12,r6
8000db8a:	cd 1f       	rcall	8000db2c <__sfmoreglue>
8000db8c:	8f 0c       	st.w	r7[0x0],r12
8000db8e:	c0 30       	breq	8000db94 <__sfp+0x40>
8000db90:	6e 07       	ld.w	r7,r7[0x0]
8000db92:	ce db       	rjmp	8000db6c <__sfp+0x18>
8000db94:	30 c8       	mov	r8,12
8000db96:	8d 38       	st.w	r6[0xc],r8
8000db98:	d8 22       	popm	r4-r7,pc
8000db9a:	30 08       	mov	r8,0
8000db9c:	f9 48 00 4c 	st.w	r12[76],r8
8000dba0:	99 08       	st.w	r12[0x0],r8
8000dba2:	99 28       	st.w	r12[0x8],r8
8000dba4:	99 18       	st.w	r12[0x4],r8
8000dba6:	99 48       	st.w	r12[0x10],r8
8000dba8:	99 58       	st.w	r12[0x14],r8
8000dbaa:	99 68       	st.w	r12[0x18],r8
8000dbac:	99 d8       	st.w	r12[0x34],r8
8000dbae:	99 e8       	st.w	r12[0x38],r8
8000dbb0:	f9 48 00 48 	st.w	r12[72],r8
8000dbb4:	3f f8       	mov	r8,-1
8000dbb6:	b8 78       	st.h	r12[0xe],r8
8000dbb8:	30 18       	mov	r8,1
8000dbba:	b8 68       	st.h	r12[0xc],r8
8000dbbc:	d8 22       	popm	r4-r7,pc
8000dbbe:	d7 03       	nop
8000dbc0:	80 01       	ld.sh	r1,r0[0x0]
8000dbc2:	91 14       	st.w	r8[0x4],r4

8000dbc4 <__sinit>:
8000dbc4:	d4 21       	pushm	r4-r7,lr
8000dbc6:	18 96       	mov	r6,r12
8000dbc8:	78 67       	ld.w	r7,r12[0x18]
8000dbca:	58 07       	cp.w	r7,0
8000dbcc:	c4 91       	brne	8000dc5e <__sinit+0x9a>
8000dbce:	fe c8 00 ae 	sub	r8,pc,174
8000dbd2:	30 15       	mov	r5,1
8000dbd4:	99 a8       	st.w	r12[0x28],r8
8000dbd6:	f9 47 00 d8 	st.w	r12[216],r7
8000dbda:	f9 47 00 dc 	st.w	r12[220],r7
8000dbde:	f9 47 00 e0 	st.w	r12[224],r7
8000dbe2:	99 65       	st.w	r12[0x18],r5
8000dbe4:	cb 8f       	rcall	8000db54 <__sfp>
8000dbe6:	8d 0c       	st.w	r6[0x0],r12
8000dbe8:	0c 9c       	mov	r12,r6
8000dbea:	cb 5f       	rcall	8000db54 <__sfp>
8000dbec:	8d 1c       	st.w	r6[0x4],r12
8000dbee:	0c 9c       	mov	r12,r6
8000dbf0:	cb 2f       	rcall	8000db54 <__sfp>
8000dbf2:	6c 09       	ld.w	r9,r6[0x0]
8000dbf4:	30 48       	mov	r8,4
8000dbf6:	93 07       	st.w	r9[0x0],r7
8000dbf8:	b2 68       	st.h	r9[0xc],r8
8000dbfa:	93 17       	st.w	r9[0x4],r7
8000dbfc:	93 27       	st.w	r9[0x8],r7
8000dbfe:	6c 18       	ld.w	r8,r6[0x4]
8000dc00:	b2 77       	st.h	r9[0xe],r7
8000dc02:	93 47       	st.w	r9[0x10],r7
8000dc04:	93 57       	st.w	r9[0x14],r7
8000dc06:	93 67       	st.w	r9[0x18],r7
8000dc08:	93 89       	st.w	r9[0x20],r9
8000dc0a:	91 07       	st.w	r8[0x0],r7
8000dc0c:	91 17       	st.w	r8[0x4],r7
8000dc0e:	91 27       	st.w	r8[0x8],r7
8000dc10:	fe ce f3 20 	sub	lr,pc,-3296
8000dc14:	fe cb f3 50 	sub	r11,pc,-3248
8000dc18:	93 9e       	st.w	r9[0x24],lr
8000dc1a:	93 ab       	st.w	r9[0x28],r11
8000dc1c:	fe ca f3 78 	sub	r10,pc,-3208
8000dc20:	fe c4 f3 84 	sub	r4,pc,-3196
8000dc24:	93 ba       	st.w	r9[0x2c],r10
8000dc26:	93 c4       	st.w	r9[0x30],r4
8000dc28:	30 99       	mov	r9,9
8000dc2a:	b0 69       	st.h	r8[0xc],r9
8000dc2c:	b0 75       	st.h	r8[0xe],r5
8000dc2e:	91 c4       	st.w	r8[0x30],r4
8000dc30:	91 47       	st.w	r8[0x10],r7
8000dc32:	91 57       	st.w	r8[0x14],r7
8000dc34:	91 67       	st.w	r8[0x18],r7
8000dc36:	91 88       	st.w	r8[0x20],r8
8000dc38:	91 9e       	st.w	r8[0x24],lr
8000dc3a:	91 ab       	st.w	r8[0x28],r11
8000dc3c:	91 ba       	st.w	r8[0x2c],r10
8000dc3e:	8d 2c       	st.w	r6[0x8],r12
8000dc40:	31 28       	mov	r8,18
8000dc42:	99 07       	st.w	r12[0x0],r7
8000dc44:	b8 68       	st.h	r12[0xc],r8
8000dc46:	99 17       	st.w	r12[0x4],r7
8000dc48:	99 27       	st.w	r12[0x8],r7
8000dc4a:	30 28       	mov	r8,2
8000dc4c:	b8 78       	st.h	r12[0xe],r8
8000dc4e:	99 c4       	st.w	r12[0x30],r4
8000dc50:	99 67       	st.w	r12[0x18],r7
8000dc52:	99 9e       	st.w	r12[0x24],lr
8000dc54:	99 ab       	st.w	r12[0x28],r11
8000dc56:	99 ba       	st.w	r12[0x2c],r10
8000dc58:	99 47       	st.w	r12[0x10],r7
8000dc5a:	99 57       	st.w	r12[0x14],r7
8000dc5c:	99 8c       	st.w	r12[0x20],r12
8000dc5e:	d8 22       	popm	r4-r7,pc

8000dc60 <_malloc_trim_r>:
8000dc60:	d4 21       	pushm	r4-r7,lr
8000dc62:	16 95       	mov	r5,r11
8000dc64:	18 97       	mov	r7,r12
8000dc66:	fe b0 d6 87 	rcall	80008974 <__malloc_lock>
8000dc6a:	e0 64 05 38 	mov	r4,1336
8000dc6e:	68 28       	ld.w	r8,r4[0x8]
8000dc70:	70 16       	ld.w	r6,r8[0x4]
8000dc72:	e0 16 ff fc 	andl	r6,0xfffc
8000dc76:	ec c8 ff 91 	sub	r8,r6,-111
8000dc7a:	f0 05 01 05 	sub	r5,r8,r5
8000dc7e:	e0 15 ff 80 	andl	r5,0xff80
8000dc82:	ea c5 00 80 	sub	r5,r5,128
8000dc86:	e0 45 00 7f 	cp.w	r5,127
8000dc8a:	e0 8a 00 25 	brle	8000dcd4 <_malloc_trim_r+0x74>
8000dc8e:	30 0b       	mov	r11,0
8000dc90:	0e 9c       	mov	r12,r7
8000dc92:	fe b0 e5 5f 	rcall	8000a750 <_sbrk_r>
8000dc96:	68 28       	ld.w	r8,r4[0x8]
8000dc98:	0c 08       	add	r8,r6
8000dc9a:	10 3c       	cp.w	r12,r8
8000dc9c:	c1 c1       	brne	8000dcd4 <_malloc_trim_r+0x74>
8000dc9e:	ea 0b 11 00 	rsub	r11,r5,0
8000dca2:	0e 9c       	mov	r12,r7
8000dca4:	fe b0 e5 56 	rcall	8000a750 <_sbrk_r>
8000dca8:	5b fc       	cp.w	r12,-1
8000dcaa:	c1 91       	brne	8000dcdc <_malloc_trim_r+0x7c>
8000dcac:	30 0b       	mov	r11,0
8000dcae:	0e 9c       	mov	r12,r7
8000dcb0:	fe b0 e5 50 	rcall	8000a750 <_sbrk_r>
8000dcb4:	68 28       	ld.w	r8,r4[0x8]
8000dcb6:	f8 08 01 09 	sub	r9,r12,r8
8000dcba:	58 f9       	cp.w	r9,15
8000dcbc:	e0 8a 00 0c 	brle	8000dcd4 <_malloc_trim_r+0x74>
8000dcc0:	a1 a9       	sbr	r9,0x0
8000dcc2:	91 19       	st.w	r8[0x4],r9
8000dcc4:	e0 68 09 44 	mov	r8,2372
8000dcc8:	70 09       	ld.w	r9,r8[0x0]
8000dcca:	e0 68 12 98 	mov	r8,4760
8000dcce:	f8 09 01 09 	sub	r9,r12,r9
8000dcd2:	91 09       	st.w	r8[0x0],r9
8000dcd4:	0e 9c       	mov	r12,r7
8000dcd6:	fe b0 d6 55 	rcall	80008980 <__malloc_unlock>
8000dcda:	d8 2a       	popm	r4-r7,pc,r12=0
8000dcdc:	68 28       	ld.w	r8,r4[0x8]
8000dcde:	0a 16       	sub	r6,r5
8000dce0:	a1 a6       	sbr	r6,0x0
8000dce2:	91 16       	st.w	r8[0x4],r6
8000dce4:	e0 68 12 98 	mov	r8,4760
8000dce8:	70 09       	ld.w	r9,r8[0x0]
8000dcea:	0a 19       	sub	r9,r5
8000dcec:	0e 9c       	mov	r12,r7
8000dcee:	91 09       	st.w	r8[0x0],r9
8000dcf0:	fe b0 d6 48 	rcall	80008980 <__malloc_unlock>
8000dcf4:	da 2a       	popm	r4-r7,pc,r12=1
8000dcf6:	d7 03       	nop

8000dcf8 <_free_r>:
8000dcf8:	d4 21       	pushm	r4-r7,lr
8000dcfa:	16 96       	mov	r6,r11
8000dcfc:	18 97       	mov	r7,r12
8000dcfe:	58 0b       	cp.w	r11,0
8000dd00:	e0 80 00 c0 	breq	8000de80 <_free_r+0x188>
8000dd04:	fe b0 d6 38 	rcall	80008974 <__malloc_lock>
8000dd08:	20 86       	sub	r6,8
8000dd0a:	e0 6a 05 38 	mov	r10,1336
8000dd0e:	6c 18       	ld.w	r8,r6[0x4]
8000dd10:	74 2e       	ld.w	lr,r10[0x8]
8000dd12:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000dd16:	a1 c8       	cbr	r8,0x0
8000dd18:	ec 08 00 09 	add	r9,r6,r8
8000dd1c:	72 1b       	ld.w	r11,r9[0x4]
8000dd1e:	e0 1b ff fc 	andl	r11,0xfffc
8000dd22:	1c 39       	cp.w	r9,lr
8000dd24:	c1 e1       	brne	8000dd60 <_free_r+0x68>
8000dd26:	f6 08 00 08 	add	r8,r11,r8
8000dd2a:	58 0c       	cp.w	r12,0
8000dd2c:	c0 81       	brne	8000dd3c <_free_r+0x44>
8000dd2e:	6c 09       	ld.w	r9,r6[0x0]
8000dd30:	12 16       	sub	r6,r9
8000dd32:	12 08       	add	r8,r9
8000dd34:	6c 3b       	ld.w	r11,r6[0xc]
8000dd36:	6c 29       	ld.w	r9,r6[0x8]
8000dd38:	97 29       	st.w	r11[0x8],r9
8000dd3a:	93 3b       	st.w	r9[0xc],r11
8000dd3c:	10 99       	mov	r9,r8
8000dd3e:	95 26       	st.w	r10[0x8],r6
8000dd40:	a1 a9       	sbr	r9,0x0
8000dd42:	8d 19       	st.w	r6[0x4],r9
8000dd44:	e0 69 09 40 	mov	r9,2368
8000dd48:	72 09       	ld.w	r9,r9[0x0]
8000dd4a:	12 38       	cp.w	r8,r9
8000dd4c:	c0 63       	brcs	8000dd58 <_free_r+0x60>
8000dd4e:	e0 68 12 94 	mov	r8,4756
8000dd52:	0e 9c       	mov	r12,r7
8000dd54:	70 0b       	ld.w	r11,r8[0x0]
8000dd56:	c8 5f       	rcall	8000dc60 <_malloc_trim_r>
8000dd58:	0e 9c       	mov	r12,r7
8000dd5a:	fe b0 d6 13 	rcall	80008980 <__malloc_unlock>
8000dd5e:	d8 22       	popm	r4-r7,pc
8000dd60:	93 1b       	st.w	r9[0x4],r11
8000dd62:	58 0c       	cp.w	r12,0
8000dd64:	c0 30       	breq	8000dd6a <_free_r+0x72>
8000dd66:	30 0c       	mov	r12,0
8000dd68:	c1 08       	rjmp	8000dd88 <_free_r+0x90>
8000dd6a:	6c 0e       	ld.w	lr,r6[0x0]
8000dd6c:	f4 c5 ff f8 	sub	r5,r10,-8
8000dd70:	1c 16       	sub	r6,lr
8000dd72:	1c 08       	add	r8,lr
8000dd74:	6c 2e       	ld.w	lr,r6[0x8]
8000dd76:	0a 3e       	cp.w	lr,r5
8000dd78:	f9 bc 00 01 	moveq	r12,1
8000dd7c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000dd80:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000dd84:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000dd88:	f2 0b 00 0e 	add	lr,r9,r11
8000dd8c:	7c 1e       	ld.w	lr,lr[0x4]
8000dd8e:	ed be 00 00 	bld	lr,0x0
8000dd92:	c1 40       	breq	8000ddba <_free_r+0xc2>
8000dd94:	16 08       	add	r8,r11
8000dd96:	58 0c       	cp.w	r12,0
8000dd98:	c0 d1       	brne	8000ddb2 <_free_r+0xba>
8000dd9a:	e0 6e 05 38 	mov	lr,1336
8000dd9e:	72 2b       	ld.w	r11,r9[0x8]
8000dda0:	2f 8e       	sub	lr,-8
8000dda2:	1c 3b       	cp.w	r11,lr
8000dda4:	c0 71       	brne	8000ddb2 <_free_r+0xba>
8000dda6:	97 36       	st.w	r11[0xc],r6
8000dda8:	97 26       	st.w	r11[0x8],r6
8000ddaa:	8d 2b       	st.w	r6[0x8],r11
8000ddac:	8d 3b       	st.w	r6[0xc],r11
8000ddae:	30 1c       	mov	r12,1
8000ddb0:	c0 58       	rjmp	8000ddba <_free_r+0xc2>
8000ddb2:	72 2b       	ld.w	r11,r9[0x8]
8000ddb4:	72 39       	ld.w	r9,r9[0xc]
8000ddb6:	93 2b       	st.w	r9[0x8],r11
8000ddb8:	97 39       	st.w	r11[0xc],r9
8000ddba:	10 99       	mov	r9,r8
8000ddbc:	ec 08 09 08 	st.w	r6[r8],r8
8000ddc0:	a1 a9       	sbr	r9,0x0
8000ddc2:	8d 19       	st.w	r6[0x4],r9
8000ddc4:	58 0c       	cp.w	r12,0
8000ddc6:	c5 a1       	brne	8000de7a <_free_r+0x182>
8000ddc8:	e0 48 01 ff 	cp.w	r8,511
8000ddcc:	e0 8b 00 13 	brhi	8000ddf2 <_free_r+0xfa>
8000ddd0:	a3 98       	lsr	r8,0x3
8000ddd2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ddd6:	72 2b       	ld.w	r11,r9[0x8]
8000ddd8:	8d 39       	st.w	r6[0xc],r9
8000ddda:	8d 2b       	st.w	r6[0x8],r11
8000dddc:	97 36       	st.w	r11[0xc],r6
8000ddde:	93 26       	st.w	r9[0x8],r6
8000dde0:	a3 48       	asr	r8,0x2
8000dde2:	74 19       	ld.w	r9,r10[0x4]
8000dde4:	30 1b       	mov	r11,1
8000dde6:	f6 08 09 48 	lsl	r8,r11,r8
8000ddea:	f3 e8 10 08 	or	r8,r9,r8
8000ddee:	95 18       	st.w	r10[0x4],r8
8000ddf0:	c4 58       	rjmp	8000de7a <_free_r+0x182>
8000ddf2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ddf6:	58 4b       	cp.w	r11,4
8000ddf8:	e0 8b 00 06 	brhi	8000de04 <_free_r+0x10c>
8000ddfc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000de00:	2c 8b       	sub	r11,-56
8000de02:	c2 08       	rjmp	8000de42 <_free_r+0x14a>
8000de04:	59 4b       	cp.w	r11,20
8000de06:	e0 8b 00 04 	brhi	8000de0e <_free_r+0x116>
8000de0a:	2a 5b       	sub	r11,-91
8000de0c:	c1 b8       	rjmp	8000de42 <_free_r+0x14a>
8000de0e:	e0 4b 00 54 	cp.w	r11,84
8000de12:	e0 8b 00 06 	brhi	8000de1e <_free_r+0x126>
8000de16:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000de1a:	29 2b       	sub	r11,-110
8000de1c:	c1 38       	rjmp	8000de42 <_free_r+0x14a>
8000de1e:	e0 4b 01 54 	cp.w	r11,340
8000de22:	e0 8b 00 06 	brhi	8000de2e <_free_r+0x136>
8000de26:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000de2a:	28 9b       	sub	r11,-119
8000de2c:	c0 b8       	rjmp	8000de42 <_free_r+0x14a>
8000de2e:	e0 4b 05 54 	cp.w	r11,1364
8000de32:	e0 88 00 05 	brls	8000de3c <_free_r+0x144>
8000de36:	37 eb       	mov	r11,126
8000de38:	c0 58       	rjmp	8000de42 <_free_r+0x14a>
8000de3a:	d7 03       	nop
8000de3c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000de40:	28 4b       	sub	r11,-124
8000de42:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000de46:	78 29       	ld.w	r9,r12[0x8]
8000de48:	18 39       	cp.w	r9,r12
8000de4a:	c0 e1       	brne	8000de66 <_free_r+0x16e>
8000de4c:	74 18       	ld.w	r8,r10[0x4]
8000de4e:	a3 4b       	asr	r11,0x2
8000de50:	30 1c       	mov	r12,1
8000de52:	f8 0b 09 4b 	lsl	r11,r12,r11
8000de56:	f1 eb 10 0b 	or	r11,r8,r11
8000de5a:	12 98       	mov	r8,r9
8000de5c:	95 1b       	st.w	r10[0x4],r11
8000de5e:	c0 a8       	rjmp	8000de72 <_free_r+0x17a>
8000de60:	72 29       	ld.w	r9,r9[0x8]
8000de62:	18 39       	cp.w	r9,r12
8000de64:	c0 60       	breq	8000de70 <_free_r+0x178>
8000de66:	72 1a       	ld.w	r10,r9[0x4]
8000de68:	e0 1a ff fc 	andl	r10,0xfffc
8000de6c:	14 38       	cp.w	r8,r10
8000de6e:	cf 93       	brcs	8000de60 <_free_r+0x168>
8000de70:	72 38       	ld.w	r8,r9[0xc]
8000de72:	8d 38       	st.w	r6[0xc],r8
8000de74:	8d 29       	st.w	r6[0x8],r9
8000de76:	93 36       	st.w	r9[0xc],r6
8000de78:	91 26       	st.w	r8[0x8],r6
8000de7a:	0e 9c       	mov	r12,r7
8000de7c:	fe b0 d5 82 	rcall	80008980 <__malloc_unlock>
8000de80:	d8 22       	popm	r4-r7,pc
8000de82:	d7 03       	nop

8000de84 <__sfvwrite_r>:
8000de84:	d4 31       	pushm	r0-r7,lr
8000de86:	20 3d       	sub	sp,12
8000de88:	14 94       	mov	r4,r10
8000de8a:	18 95       	mov	r5,r12
8000de8c:	16 97       	mov	r7,r11
8000de8e:	74 28       	ld.w	r8,r10[0x8]
8000de90:	58 08       	cp.w	r8,0
8000de92:	e0 80 01 40 	breq	8000e112 <__sfvwrite_r+0x28e>
8000de96:	96 68       	ld.sh	r8,r11[0xc]
8000de98:	ed b8 00 03 	bld	r8,0x3
8000de9c:	c0 41       	brne	8000dea4 <__sfvwrite_r+0x20>
8000de9e:	76 48       	ld.w	r8,r11[0x10]
8000dea0:	58 08       	cp.w	r8,0
8000dea2:	c0 c1       	brne	8000deba <__sfvwrite_r+0x36>
8000dea4:	0e 9b       	mov	r11,r7
8000dea6:	0a 9c       	mov	r12,r5
8000dea8:	fe b0 f6 bc 	rcall	8000cc20 <__swsetup_r>
8000deac:	c0 70       	breq	8000deba <__sfvwrite_r+0x36>
8000deae:	8e 68       	ld.sh	r8,r7[0xc]
8000deb0:	a7 a8       	sbr	r8,0x6
8000deb2:	ae 68       	st.h	r7[0xc],r8
8000deb4:	30 98       	mov	r8,9
8000deb6:	8b 38       	st.w	r5[0xc],r8
8000deb8:	c2 b9       	rjmp	8000e10e <__sfvwrite_r+0x28a>
8000deba:	8e 63       	ld.sh	r3,r7[0xc]
8000debc:	68 00       	ld.w	r0,r4[0x0]
8000debe:	06 96       	mov	r6,r3
8000dec0:	e2 16 00 02 	andl	r6,0x2,COH
8000dec4:	c2 10       	breq	8000df06 <__sfvwrite_r+0x82>
8000dec6:	30 03       	mov	r3,0
8000dec8:	e0 62 04 00 	mov	r2,1024
8000decc:	06 96       	mov	r6,r3
8000dece:	c0 48       	rjmp	8000ded6 <__sfvwrite_r+0x52>
8000ded0:	60 03       	ld.w	r3,r0[0x0]
8000ded2:	60 16       	ld.w	r6,r0[0x4]
8000ded4:	2f 80       	sub	r0,-8
8000ded6:	58 06       	cp.w	r6,0
8000ded8:	cf c0       	breq	8000ded0 <__sfvwrite_r+0x4c>
8000deda:	e0 46 04 00 	cp.w	r6,1024
8000dede:	ec 09 17 80 	movls	r9,r6
8000dee2:	e4 09 17 b0 	movhi	r9,r2
8000dee6:	06 9a       	mov	r10,r3
8000dee8:	6e a8       	ld.w	r8,r7[0x28]
8000deea:	6e 8b       	ld.w	r11,r7[0x20]
8000deec:	0a 9c       	mov	r12,r5
8000deee:	5d 18       	icall	r8
8000def0:	18 16       	sub	r6,r12
8000def2:	58 0c       	cp.w	r12,0
8000def4:	e0 8a 01 0a 	brle	8000e108 <__sfvwrite_r+0x284>
8000def8:	68 28       	ld.w	r8,r4[0x8]
8000defa:	18 18       	sub	r8,r12
8000defc:	89 28       	st.w	r4[0x8],r8
8000defe:	e0 80 01 0a 	breq	8000e112 <__sfvwrite_r+0x28e>
8000df02:	18 03       	add	r3,r12
8000df04:	ce 9b       	rjmp	8000ded6 <__sfvwrite_r+0x52>
8000df06:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000df0a:	c0 70       	breq	8000df18 <__sfvwrite_r+0x94>
8000df0c:	50 06       	stdsp	sp[0x0],r6
8000df0e:	0c 93       	mov	r3,r6
8000df10:	0c 91       	mov	r1,r6
8000df12:	50 15       	stdsp	sp[0x4],r5
8000df14:	08 92       	mov	r2,r4
8000df16:	c9 c8       	rjmp	8000e04e <__sfvwrite_r+0x1ca>
8000df18:	06 96       	mov	r6,r3
8000df1a:	08 91       	mov	r1,r4
8000df1c:	c0 48       	rjmp	8000df24 <__sfvwrite_r+0xa0>
8000df1e:	60 03       	ld.w	r3,r0[0x0]
8000df20:	60 16       	ld.w	r6,r0[0x4]
8000df22:	2f 80       	sub	r0,-8
8000df24:	58 06       	cp.w	r6,0
8000df26:	cf c0       	breq	8000df1e <__sfvwrite_r+0x9a>
8000df28:	8e 68       	ld.sh	r8,r7[0xc]
8000df2a:	6e 24       	ld.w	r4,r7[0x8]
8000df2c:	10 99       	mov	r9,r8
8000df2e:	e2 19 02 00 	andl	r9,0x200,COH
8000df32:	c5 50       	breq	8000dfdc <__sfvwrite_r+0x158>
8000df34:	08 36       	cp.w	r6,r4
8000df36:	c4 43       	brcs	8000dfbe <__sfvwrite_r+0x13a>
8000df38:	10 99       	mov	r9,r8
8000df3a:	e2 19 04 80 	andl	r9,0x480,COH
8000df3e:	c4 00       	breq	8000dfbe <__sfvwrite_r+0x13a>
8000df40:	6e 4b       	ld.w	r11,r7[0x10]
8000df42:	6e 09       	ld.w	r9,r7[0x0]
8000df44:	16 19       	sub	r9,r11
8000df46:	50 09       	stdsp	sp[0x0],r9
8000df48:	6e 59       	ld.w	r9,r7[0x14]
8000df4a:	10 9c       	mov	r12,r8
8000df4c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000df50:	30 28       	mov	r8,2
8000df52:	f4 08 0c 08 	divs	r8,r10,r8
8000df56:	fa e9 00 04 	st.d	sp[4],r8
8000df5a:	10 94       	mov	r4,r8
8000df5c:	40 09       	lddsp	r9,sp[0x0]
8000df5e:	e2 1c 04 00 	andl	r12,0x400,COH
8000df62:	2f f9       	sub	r9,-1
8000df64:	0c 09       	add	r9,r6
8000df66:	12 38       	cp.w	r8,r9
8000df68:	f2 04 17 30 	movlo	r4,r9
8000df6c:	58 0c       	cp.w	r12,0
8000df6e:	c1 10       	breq	8000df90 <__sfvwrite_r+0x10c>
8000df70:	08 9b       	mov	r11,r4
8000df72:	0a 9c       	mov	r12,r5
8000df74:	fe b0 df b4 	rcall	80009edc <_malloc_r>
8000df78:	18 92       	mov	r2,r12
8000df7a:	c1 40       	breq	8000dfa2 <__sfvwrite_r+0x11e>
8000df7c:	40 0a       	lddsp	r10,sp[0x0]
8000df7e:	6e 4b       	ld.w	r11,r7[0x10]
8000df80:	fe b0 e1 dd 	rcall	8000a33a <memcpy>
8000df84:	8e 68       	ld.sh	r8,r7[0xc]
8000df86:	e0 18 fb 7f 	andl	r8,0xfb7f
8000df8a:	a7 b8       	sbr	r8,0x7
8000df8c:	ae 68       	st.h	r7[0xc],r8
8000df8e:	c0 d8       	rjmp	8000dfa8 <__sfvwrite_r+0x124>
8000df90:	08 9a       	mov	r10,r4
8000df92:	0a 9c       	mov	r12,r5
8000df94:	fe b0 e2 7e 	rcall	8000a490 <_realloc_r>
8000df98:	18 92       	mov	r2,r12
8000df9a:	c0 71       	brne	8000dfa8 <__sfvwrite_r+0x124>
8000df9c:	6e 4b       	ld.w	r11,r7[0x10]
8000df9e:	0a 9c       	mov	r12,r5
8000dfa0:	ca ce       	rcall	8000dcf8 <_free_r>
8000dfa2:	30 c8       	mov	r8,12
8000dfa4:	8b 38       	st.w	r5[0xc],r8
8000dfa6:	cb 18       	rjmp	8000e108 <__sfvwrite_r+0x284>
8000dfa8:	40 0a       	lddsp	r10,sp[0x0]
8000dfaa:	40 09       	lddsp	r9,sp[0x0]
8000dfac:	e8 0a 01 0a 	sub	r10,r4,r10
8000dfb0:	e4 09 00 08 	add	r8,r2,r9
8000dfb4:	8f 54       	st.w	r7[0x14],r4
8000dfb6:	8f 2a       	st.w	r7[0x8],r10
8000dfb8:	8f 08       	st.w	r7[0x0],r8
8000dfba:	8f 42       	st.w	r7[0x10],r2
8000dfbc:	0c 94       	mov	r4,r6
8000dfbe:	08 36       	cp.w	r6,r4
8000dfc0:	ec 04 17 30 	movlo	r4,r6
8000dfc4:	06 9b       	mov	r11,r3
8000dfc6:	08 9a       	mov	r10,r4
8000dfc8:	6e 0c       	ld.w	r12,r7[0x0]
8000dfca:	c3 ad       	rcall	8000e23e <memmove>
8000dfcc:	6e 08       	ld.w	r8,r7[0x0]
8000dfce:	08 08       	add	r8,r4
8000dfd0:	8f 08       	st.w	r7[0x0],r8
8000dfd2:	6e 28       	ld.w	r8,r7[0x8]
8000dfd4:	08 18       	sub	r8,r4
8000dfd6:	0c 94       	mov	r4,r6
8000dfd8:	8f 28       	st.w	r7[0x8],r8
8000dfda:	c2 e8       	rjmp	8000e036 <__sfvwrite_r+0x1b2>
8000dfdc:	08 36       	cp.w	r6,r4
8000dfde:	5f ba       	srhi	r10
8000dfe0:	6e 0c       	ld.w	r12,r7[0x0]
8000dfe2:	6e 48       	ld.w	r8,r7[0x10]
8000dfe4:	10 3c       	cp.w	r12,r8
8000dfe6:	5f b8       	srhi	r8
8000dfe8:	f5 e8 00 08 	and	r8,r10,r8
8000dfec:	f2 08 18 00 	cp.b	r8,r9
8000dff0:	c0 d0       	breq	8000e00a <__sfvwrite_r+0x186>
8000dff2:	06 9b       	mov	r11,r3
8000dff4:	08 9a       	mov	r10,r4
8000dff6:	c2 4d       	rcall	8000e23e <memmove>
8000dff8:	6e 08       	ld.w	r8,r7[0x0]
8000dffa:	08 08       	add	r8,r4
8000dffc:	0e 9b       	mov	r11,r7
8000dffe:	8f 08       	st.w	r7[0x0],r8
8000e000:	0a 9c       	mov	r12,r5
8000e002:	fe b0 fd 05 	rcall	8000da0c <_fflush_r>
8000e006:	c1 80       	breq	8000e036 <__sfvwrite_r+0x1b2>
8000e008:	c8 08       	rjmp	8000e108 <__sfvwrite_r+0x284>
8000e00a:	6e 59       	ld.w	r9,r7[0x14]
8000e00c:	12 36       	cp.w	r6,r9
8000e00e:	c0 a3       	brcs	8000e022 <__sfvwrite_r+0x19e>
8000e010:	6e a8       	ld.w	r8,r7[0x28]
8000e012:	06 9a       	mov	r10,r3
8000e014:	6e 8b       	ld.w	r11,r7[0x20]
8000e016:	0a 9c       	mov	r12,r5
8000e018:	5d 18       	icall	r8
8000e01a:	18 94       	mov	r4,r12
8000e01c:	e0 89 00 0d 	brgt	8000e036 <__sfvwrite_r+0x1b2>
8000e020:	c7 48       	rjmp	8000e108 <__sfvwrite_r+0x284>
8000e022:	0c 9a       	mov	r10,r6
8000e024:	06 9b       	mov	r11,r3
8000e026:	c0 cd       	rcall	8000e23e <memmove>
8000e028:	6e 08       	ld.w	r8,r7[0x0]
8000e02a:	0c 08       	add	r8,r6
8000e02c:	0c 94       	mov	r4,r6
8000e02e:	8f 08       	st.w	r7[0x0],r8
8000e030:	6e 28       	ld.w	r8,r7[0x8]
8000e032:	0c 18       	sub	r8,r6
8000e034:	8f 28       	st.w	r7[0x8],r8
8000e036:	62 28       	ld.w	r8,r1[0x8]
8000e038:	08 18       	sub	r8,r4
8000e03a:	83 28       	st.w	r1[0x8],r8
8000e03c:	c6 b0       	breq	8000e112 <__sfvwrite_r+0x28e>
8000e03e:	08 16       	sub	r6,r4
8000e040:	08 03       	add	r3,r4
8000e042:	c7 1b       	rjmp	8000df24 <__sfvwrite_r+0xa0>
8000e044:	60 03       	ld.w	r3,r0[0x0]
8000e046:	60 11       	ld.w	r1,r0[0x4]
8000e048:	30 08       	mov	r8,0
8000e04a:	2f 80       	sub	r0,-8
8000e04c:	50 08       	stdsp	sp[0x0],r8
8000e04e:	58 01       	cp.w	r1,0
8000e050:	cf a0       	breq	8000e044 <__sfvwrite_r+0x1c0>
8000e052:	40 0a       	lddsp	r10,sp[0x0]
8000e054:	58 0a       	cp.w	r10,0
8000e056:	c1 41       	brne	8000e07e <__sfvwrite_r+0x1fa>
8000e058:	e2 c6 ff ff 	sub	r6,r1,-1
8000e05c:	02 9a       	mov	r10,r1
8000e05e:	30 ab       	mov	r11,10
8000e060:	06 9c       	mov	r12,r3
8000e062:	ce 3c       	rcall	8000e228 <memchr>
8000e064:	f8 c8 ff ff 	sub	r8,r12,-1
8000e068:	58 0c       	cp.w	r12,0
8000e06a:	f1 d3 e1 16 	subne	r6,r8,r3
8000e06e:	f9 b9 01 01 	movne	r9,1
8000e072:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e076:	f9 b8 00 01 	moveq	r8,1
8000e07a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e07e:	02 36       	cp.w	r6,r1
8000e080:	ec 04 17 80 	movls	r4,r6
8000e084:	e2 04 17 b0 	movhi	r4,r1
8000e088:	6e 59       	ld.w	r9,r7[0x14]
8000e08a:	6e 25       	ld.w	r5,r7[0x8]
8000e08c:	f2 05 00 05 	add	r5,r9,r5
8000e090:	0a 34       	cp.w	r4,r5
8000e092:	5f 9a       	srgt	r10
8000e094:	6e 0c       	ld.w	r12,r7[0x0]
8000e096:	6e 48       	ld.w	r8,r7[0x10]
8000e098:	10 3c       	cp.w	r12,r8
8000e09a:	5f b8       	srhi	r8
8000e09c:	f5 e8 00 08 	and	r8,r10,r8
8000e0a0:	30 0a       	mov	r10,0
8000e0a2:	f4 08 18 00 	cp.b	r8,r10
8000e0a6:	c0 d0       	breq	8000e0c0 <__sfvwrite_r+0x23c>
8000e0a8:	06 9b       	mov	r11,r3
8000e0aa:	0a 9a       	mov	r10,r5
8000e0ac:	cc 9c       	rcall	8000e23e <memmove>
8000e0ae:	6e 08       	ld.w	r8,r7[0x0]
8000e0b0:	0a 08       	add	r8,r5
8000e0b2:	0e 9b       	mov	r11,r7
8000e0b4:	8f 08       	st.w	r7[0x0],r8
8000e0b6:	40 1c       	lddsp	r12,sp[0x4]
8000e0b8:	fe b0 fc aa 	rcall	8000da0c <_fflush_r>
8000e0bc:	c1 70       	breq	8000e0ea <__sfvwrite_r+0x266>
8000e0be:	c2 58       	rjmp	8000e108 <__sfvwrite_r+0x284>
8000e0c0:	12 34       	cp.w	r4,r9
8000e0c2:	c0 a5       	brlt	8000e0d6 <__sfvwrite_r+0x252>
8000e0c4:	6e a8       	ld.w	r8,r7[0x28]
8000e0c6:	06 9a       	mov	r10,r3
8000e0c8:	6e 8b       	ld.w	r11,r7[0x20]
8000e0ca:	40 1c       	lddsp	r12,sp[0x4]
8000e0cc:	5d 18       	icall	r8
8000e0ce:	18 95       	mov	r5,r12
8000e0d0:	e0 89 00 0d 	brgt	8000e0ea <__sfvwrite_r+0x266>
8000e0d4:	c1 a8       	rjmp	8000e108 <__sfvwrite_r+0x284>
8000e0d6:	08 9a       	mov	r10,r4
8000e0d8:	06 9b       	mov	r11,r3
8000e0da:	cb 2c       	rcall	8000e23e <memmove>
8000e0dc:	6e 08       	ld.w	r8,r7[0x0]
8000e0de:	08 08       	add	r8,r4
8000e0e0:	08 95       	mov	r5,r4
8000e0e2:	8f 08       	st.w	r7[0x0],r8
8000e0e4:	6e 28       	ld.w	r8,r7[0x8]
8000e0e6:	08 18       	sub	r8,r4
8000e0e8:	8f 28       	st.w	r7[0x8],r8
8000e0ea:	0a 16       	sub	r6,r5
8000e0ec:	c0 71       	brne	8000e0fa <__sfvwrite_r+0x276>
8000e0ee:	0e 9b       	mov	r11,r7
8000e0f0:	40 1c       	lddsp	r12,sp[0x4]
8000e0f2:	fe b0 fc 8d 	rcall	8000da0c <_fflush_r>
8000e0f6:	c0 91       	brne	8000e108 <__sfvwrite_r+0x284>
8000e0f8:	50 06       	stdsp	sp[0x0],r6
8000e0fa:	64 28       	ld.w	r8,r2[0x8]
8000e0fc:	0a 18       	sub	r8,r5
8000e0fe:	85 28       	st.w	r2[0x8],r8
8000e100:	c0 90       	breq	8000e112 <__sfvwrite_r+0x28e>
8000e102:	0a 11       	sub	r1,r5
8000e104:	0a 03       	add	r3,r5
8000e106:	ca 4b       	rjmp	8000e04e <__sfvwrite_r+0x1ca>
8000e108:	8e 68       	ld.sh	r8,r7[0xc]
8000e10a:	a7 a8       	sbr	r8,0x6
8000e10c:	ae 68       	st.h	r7[0xc],r8
8000e10e:	3f fc       	mov	r12,-1
8000e110:	c0 28       	rjmp	8000e114 <__sfvwrite_r+0x290>
8000e112:	30 0c       	mov	r12,0
8000e114:	2f dd       	sub	sp,-12
8000e116:	d8 32       	popm	r0-r7,pc

8000e118 <_fwalk>:
8000e118:	d4 31       	pushm	r0-r7,lr
8000e11a:	30 05       	mov	r5,0
8000e11c:	16 91       	mov	r1,r11
8000e11e:	f8 c7 ff 28 	sub	r7,r12,-216
8000e122:	0a 92       	mov	r2,r5
8000e124:	fe b0 fc fc 	rcall	8000db1c <__sfp_lock_acquire>
8000e128:	3f f3       	mov	r3,-1
8000e12a:	c1 68       	rjmp	8000e156 <_fwalk+0x3e>
8000e12c:	6e 26       	ld.w	r6,r7[0x8]
8000e12e:	6e 14       	ld.w	r4,r7[0x4]
8000e130:	2f 46       	sub	r6,-12
8000e132:	c0 c8       	rjmp	8000e14a <_fwalk+0x32>
8000e134:	8c 08       	ld.sh	r8,r6[0x0]
8000e136:	e4 08 19 00 	cp.h	r8,r2
8000e13a:	c0 70       	breq	8000e148 <_fwalk+0x30>
8000e13c:	8c 18       	ld.sh	r8,r6[0x2]
8000e13e:	e6 08 19 00 	cp.h	r8,r3
8000e142:	c0 30       	breq	8000e148 <_fwalk+0x30>
8000e144:	5d 11       	icall	r1
8000e146:	18 45       	or	r5,r12
8000e148:	2a 46       	sub	r6,-92
8000e14a:	20 14       	sub	r4,1
8000e14c:	ec cc 00 0c 	sub	r12,r6,12
8000e150:	58 04       	cp.w	r4,0
8000e152:	cf 14       	brge	8000e134 <_fwalk+0x1c>
8000e154:	6e 07       	ld.w	r7,r7[0x0]
8000e156:	58 07       	cp.w	r7,0
8000e158:	ce a1       	brne	8000e12c <_fwalk+0x14>
8000e15a:	fe b0 fc e2 	rcall	8000db1e <__sfp_lock_release>
8000e15e:	0a 9c       	mov	r12,r5
8000e160:	d8 32       	popm	r0-r7,pc
8000e162:	d7 03       	nop

8000e164 <_localeconv_r>:
8000e164:	48 1c       	lddpc	r12,8000e168 <_localeconv_r+0x4>
8000e166:	5e fc       	retal	r12
8000e168:	80 01       	ld.sh	r1,r0[0x0]
8000e16a:	91 18       	st.w	r8[0x4],r8

8000e16c <__smakebuf_r>:
8000e16c:	d4 21       	pushm	r4-r7,lr
8000e16e:	20 fd       	sub	sp,60
8000e170:	96 68       	ld.sh	r8,r11[0xc]
8000e172:	16 97       	mov	r7,r11
8000e174:	18 96       	mov	r6,r12
8000e176:	e2 18 00 02 	andl	r8,0x2,COH
8000e17a:	c3 d1       	brne	8000e1f4 <__smakebuf_r+0x88>
8000e17c:	96 7b       	ld.sh	r11,r11[0xe]
8000e17e:	f0 0b 19 00 	cp.h	r11,r8
8000e182:	c0 55       	brlt	8000e18c <__smakebuf_r+0x20>
8000e184:	1a 9a       	mov	r10,sp
8000e186:	e0 a0 04 79 	rcall	8000ea78 <_fstat_r>
8000e18a:	c0 f4       	brge	8000e1a8 <__smakebuf_r+0x3c>
8000e18c:	8e 65       	ld.sh	r5,r7[0xc]
8000e18e:	0a 98       	mov	r8,r5
8000e190:	ab b8       	sbr	r8,0xb
8000e192:	e2 15 00 80 	andl	r5,0x80,COH
8000e196:	ae 68       	st.h	r7[0xc],r8
8000e198:	30 04       	mov	r4,0
8000e19a:	e0 68 04 00 	mov	r8,1024
8000e19e:	f9 b5 01 40 	movne	r5,64
8000e1a2:	f0 05 17 00 	moveq	r5,r8
8000e1a6:	c1 c8       	rjmp	8000e1de <__smakebuf_r+0x72>
8000e1a8:	40 18       	lddsp	r8,sp[0x4]
8000e1aa:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e1ae:	e0 48 20 00 	cp.w	r8,8192
8000e1b2:	5f 04       	sreq	r4
8000e1b4:	e0 48 80 00 	cp.w	r8,32768
8000e1b8:	c0 e1       	brne	8000e1d4 <__smakebuf_r+0x68>
8000e1ba:	6e b9       	ld.w	r9,r7[0x2c]
8000e1bc:	fe c8 f9 18 	sub	r8,pc,-1768
8000e1c0:	10 39       	cp.w	r9,r8
8000e1c2:	c0 91       	brne	8000e1d4 <__smakebuf_r+0x68>
8000e1c4:	8e 68       	ld.sh	r8,r7[0xc]
8000e1c6:	e0 65 04 00 	mov	r5,1024
8000e1ca:	ab a8       	sbr	r8,0xa
8000e1cc:	ef 45 00 50 	st.w	r7[80],r5
8000e1d0:	ae 68       	st.h	r7[0xc],r8
8000e1d2:	c0 68       	rjmp	8000e1de <__smakebuf_r+0x72>
8000e1d4:	8e 68       	ld.sh	r8,r7[0xc]
8000e1d6:	e0 65 04 00 	mov	r5,1024
8000e1da:	ab b8       	sbr	r8,0xb
8000e1dc:	ae 68       	st.h	r7[0xc],r8
8000e1de:	0a 9b       	mov	r11,r5
8000e1e0:	0c 9c       	mov	r12,r6
8000e1e2:	fe b0 de 7d 	rcall	80009edc <_malloc_r>
8000e1e6:	8e 68       	ld.sh	r8,r7[0xc]
8000e1e8:	c0 d1       	brne	8000e202 <__smakebuf_r+0x96>
8000e1ea:	ed b8 00 09 	bld	r8,0x9
8000e1ee:	c1 b0       	breq	8000e224 <__smakebuf_r+0xb8>
8000e1f0:	a1 b8       	sbr	r8,0x1
8000e1f2:	ae 68       	st.h	r7[0xc],r8
8000e1f4:	ee c8 ff b9 	sub	r8,r7,-71
8000e1f8:	8f 48       	st.w	r7[0x10],r8
8000e1fa:	8f 08       	st.w	r7[0x0],r8
8000e1fc:	30 18       	mov	r8,1
8000e1fe:	8f 58       	st.w	r7[0x14],r8
8000e200:	c1 28       	rjmp	8000e224 <__smakebuf_r+0xb8>
8000e202:	a7 b8       	sbr	r8,0x7
8000e204:	8f 4c       	st.w	r7[0x10],r12
8000e206:	ae 68       	st.h	r7[0xc],r8
8000e208:	8f 55       	st.w	r7[0x14],r5
8000e20a:	fe c8 06 ea 	sub	r8,pc,1770
8000e20e:	8f 0c       	st.w	r7[0x0],r12
8000e210:	8d a8       	st.w	r6[0x28],r8
8000e212:	58 04       	cp.w	r4,0
8000e214:	c0 80       	breq	8000e224 <__smakebuf_r+0xb8>
8000e216:	8e 7c       	ld.sh	r12,r7[0xe]
8000e218:	fe b0 e3 7a 	rcall	8000a90c <isatty>
8000e21c:	c0 40       	breq	8000e224 <__smakebuf_r+0xb8>
8000e21e:	8e 68       	ld.sh	r8,r7[0xc]
8000e220:	a1 a8       	sbr	r8,0x0
8000e222:	ae 68       	st.h	r7[0xc],r8
8000e224:	2f 1d       	sub	sp,-60
8000e226:	d8 22       	popm	r4-r7,pc

8000e228 <memchr>:
8000e228:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e22c:	c0 68       	rjmp	8000e238 <memchr+0x10>
8000e22e:	20 1a       	sub	r10,1
8000e230:	19 88       	ld.ub	r8,r12[0x0]
8000e232:	16 38       	cp.w	r8,r11
8000e234:	5e 0c       	reteq	r12
8000e236:	2f fc       	sub	r12,-1
8000e238:	58 0a       	cp.w	r10,0
8000e23a:	cf a1       	brne	8000e22e <memchr+0x6>
8000e23c:	5e fa       	retal	r10

8000e23e <memmove>:
8000e23e:	d4 01       	pushm	lr
8000e240:	18 3b       	cp.w	r11,r12
8000e242:	c1 92       	brcc	8000e274 <memmove+0x36>
8000e244:	f6 0a 00 09 	add	r9,r11,r10
8000e248:	12 3c       	cp.w	r12,r9
8000e24a:	c1 52       	brcc	8000e274 <memmove+0x36>
8000e24c:	f8 0a 00 0b 	add	r11,r12,r10
8000e250:	30 08       	mov	r8,0
8000e252:	c0 68       	rjmp	8000e25e <memmove+0x20>
8000e254:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e258:	20 1a       	sub	r10,1
8000e25a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e25e:	20 18       	sub	r8,1
8000e260:	58 0a       	cp.w	r10,0
8000e262:	cf 91       	brne	8000e254 <memmove+0x16>
8000e264:	d8 02       	popm	pc
8000e266:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e26a:	20 1a       	sub	r10,1
8000e26c:	f8 08 0b 09 	st.b	r12[r8],r9
8000e270:	2f f8       	sub	r8,-1
8000e272:	c0 28       	rjmp	8000e276 <memmove+0x38>
8000e274:	30 08       	mov	r8,0
8000e276:	58 0a       	cp.w	r10,0
8000e278:	cf 71       	brne	8000e266 <memmove+0x28>
8000e27a:	d8 02       	popm	pc

8000e27c <__hi0bits>:
8000e27c:	18 98       	mov	r8,r12
8000e27e:	e0 1c 00 00 	andl	r12,0x0
8000e282:	f0 09 15 10 	lsl	r9,r8,0x10
8000e286:	58 0c       	cp.w	r12,0
8000e288:	f2 08 17 00 	moveq	r8,r9
8000e28c:	f9 bc 00 10 	moveq	r12,16
8000e290:	f9 bc 01 00 	movne	r12,0
8000e294:	10 9a       	mov	r10,r8
8000e296:	f0 09 15 08 	lsl	r9,r8,0x8
8000e29a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e29e:	f7 bc 00 f8 	subeq	r12,-8
8000e2a2:	f2 08 17 00 	moveq	r8,r9
8000e2a6:	10 9a       	mov	r10,r8
8000e2a8:	f0 09 15 04 	lsl	r9,r8,0x4
8000e2ac:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e2b0:	f7 bc 00 fc 	subeq	r12,-4
8000e2b4:	f2 08 17 00 	moveq	r8,r9
8000e2b8:	10 9a       	mov	r10,r8
8000e2ba:	f0 09 15 02 	lsl	r9,r8,0x2
8000e2be:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e2c2:	f7 bc 00 fe 	subeq	r12,-2
8000e2c6:	f2 08 17 00 	moveq	r8,r9
8000e2ca:	58 08       	cp.w	r8,0
8000e2cc:	5e 5c       	retlt	r12
8000e2ce:	ed b8 00 1e 	bld	r8,0x1e
8000e2d2:	f9 bc 01 20 	movne	r12,32
8000e2d6:	f7 bc 00 ff 	subeq	r12,-1
8000e2da:	5e fc       	retal	r12

8000e2dc <__lo0bits>:
8000e2dc:	18 99       	mov	r9,r12
8000e2de:	78 08       	ld.w	r8,r12[0x0]
8000e2e0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e2e4:	c1 50       	breq	8000e30e <__lo0bits+0x32>
8000e2e6:	ed b8 00 00 	bld	r8,0x0
8000e2ea:	c0 21       	brne	8000e2ee <__lo0bits+0x12>
8000e2ec:	5e fd       	retal	0
8000e2ee:	10 9b       	mov	r11,r8
8000e2f0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e2f4:	e2 1b 00 02 	andl	r11,0x2,COH
8000e2f8:	a3 88       	lsr	r8,0x2
8000e2fa:	58 0b       	cp.w	r11,0
8000e2fc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e300:	f9 bc 01 01 	movne	r12,1
8000e304:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e308:	f9 bc 00 02 	moveq	r12,2
8000e30c:	5e fc       	retal	r12
8000e30e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e312:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e316:	58 0a       	cp.w	r10,0
8000e318:	f6 08 17 00 	moveq	r8,r11
8000e31c:	f9 bc 00 10 	moveq	r12,16
8000e320:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e324:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e328:	58 0b       	cp.w	r11,0
8000e32a:	f7 bc 00 f8 	subeq	r12,-8
8000e32e:	f4 08 17 00 	moveq	r8,r10
8000e332:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e336:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e33a:	58 0b       	cp.w	r11,0
8000e33c:	f7 bc 00 fc 	subeq	r12,-4
8000e340:	f4 08 17 00 	moveq	r8,r10
8000e344:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e348:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e34c:	58 0b       	cp.w	r11,0
8000e34e:	f7 bc 00 fe 	subeq	r12,-2
8000e352:	f4 08 17 00 	moveq	r8,r10
8000e356:	ed b8 00 00 	bld	r8,0x0
8000e35a:	c0 60       	breq	8000e366 <__lo0bits+0x8a>
8000e35c:	a1 98       	lsr	r8,0x1
8000e35e:	c0 31       	brne	8000e364 <__lo0bits+0x88>
8000e360:	32 0c       	mov	r12,32
8000e362:	5e fc       	retal	r12
8000e364:	2f fc       	sub	r12,-1
8000e366:	93 08       	st.w	r9[0x0],r8
8000e368:	5e fc       	retal	r12

8000e36a <__mcmp>:
8000e36a:	d4 01       	pushm	lr
8000e36c:	18 98       	mov	r8,r12
8000e36e:	76 49       	ld.w	r9,r11[0x10]
8000e370:	78 4c       	ld.w	r12,r12[0x10]
8000e372:	12 1c       	sub	r12,r9
8000e374:	c1 31       	brne	8000e39a <__mcmp+0x30>
8000e376:	2f b9       	sub	r9,-5
8000e378:	a3 69       	lsl	r9,0x2
8000e37a:	12 0b       	add	r11,r9
8000e37c:	f0 09 00 09 	add	r9,r8,r9
8000e380:	2e c8       	sub	r8,-20
8000e382:	13 4e       	ld.w	lr,--r9
8000e384:	17 4a       	ld.w	r10,--r11
8000e386:	14 3e       	cp.w	lr,r10
8000e388:	c0 60       	breq	8000e394 <__mcmp+0x2a>
8000e38a:	f9 bc 03 ff 	movlo	r12,-1
8000e38e:	f9 bc 02 01 	movhs	r12,1
8000e392:	d8 02       	popm	pc
8000e394:	10 39       	cp.w	r9,r8
8000e396:	fe 9b ff f6 	brhi	8000e382 <__mcmp+0x18>
8000e39a:	d8 02       	popm	pc

8000e39c <_Bfree>:
8000e39c:	d4 21       	pushm	r4-r7,lr
8000e39e:	18 97       	mov	r7,r12
8000e3a0:	16 95       	mov	r5,r11
8000e3a2:	78 96       	ld.w	r6,r12[0x24]
8000e3a4:	58 06       	cp.w	r6,0
8000e3a6:	c0 91       	brne	8000e3b8 <_Bfree+0x1c>
8000e3a8:	31 0c       	mov	r12,16
8000e3aa:	fe b0 dd 91 	rcall	80009ecc <malloc>
8000e3ae:	99 36       	st.w	r12[0xc],r6
8000e3b0:	8f 9c       	st.w	r7[0x24],r12
8000e3b2:	99 16       	st.w	r12[0x4],r6
8000e3b4:	99 26       	st.w	r12[0x8],r6
8000e3b6:	99 06       	st.w	r12[0x0],r6
8000e3b8:	58 05       	cp.w	r5,0
8000e3ba:	c0 90       	breq	8000e3cc <_Bfree+0x30>
8000e3bc:	6a 19       	ld.w	r9,r5[0x4]
8000e3be:	6e 98       	ld.w	r8,r7[0x24]
8000e3c0:	70 38       	ld.w	r8,r8[0xc]
8000e3c2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e3c6:	8b 0a       	st.w	r5[0x0],r10
8000e3c8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e3cc:	d8 22       	popm	r4-r7,pc
8000e3ce:	d7 03       	nop

8000e3d0 <_Balloc>:
8000e3d0:	d4 21       	pushm	r4-r7,lr
8000e3d2:	18 97       	mov	r7,r12
8000e3d4:	16 96       	mov	r6,r11
8000e3d6:	78 95       	ld.w	r5,r12[0x24]
8000e3d8:	58 05       	cp.w	r5,0
8000e3da:	c0 91       	brne	8000e3ec <_Balloc+0x1c>
8000e3dc:	31 0c       	mov	r12,16
8000e3de:	fe b0 dd 77 	rcall	80009ecc <malloc>
8000e3e2:	99 35       	st.w	r12[0xc],r5
8000e3e4:	8f 9c       	st.w	r7[0x24],r12
8000e3e6:	99 15       	st.w	r12[0x4],r5
8000e3e8:	99 25       	st.w	r12[0x8],r5
8000e3ea:	99 05       	st.w	r12[0x0],r5
8000e3ec:	6e 95       	ld.w	r5,r7[0x24]
8000e3ee:	6a 38       	ld.w	r8,r5[0xc]
8000e3f0:	58 08       	cp.w	r8,0
8000e3f2:	c0 b1       	brne	8000e408 <_Balloc+0x38>
8000e3f4:	31 0a       	mov	r10,16
8000e3f6:	30 4b       	mov	r11,4
8000e3f8:	0e 9c       	mov	r12,r7
8000e3fa:	e0 a0 02 9d 	rcall	8000e934 <_calloc_r>
8000e3fe:	8b 3c       	st.w	r5[0xc],r12
8000e400:	6e 98       	ld.w	r8,r7[0x24]
8000e402:	70 3c       	ld.w	r12,r8[0xc]
8000e404:	58 0c       	cp.w	r12,0
8000e406:	c1 b0       	breq	8000e43c <_Balloc+0x6c>
8000e408:	6e 98       	ld.w	r8,r7[0x24]
8000e40a:	70 38       	ld.w	r8,r8[0xc]
8000e40c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000e410:	70 0c       	ld.w	r12,r8[0x0]
8000e412:	58 0c       	cp.w	r12,0
8000e414:	c0 40       	breq	8000e41c <_Balloc+0x4c>
8000e416:	78 09       	ld.w	r9,r12[0x0]
8000e418:	91 09       	st.w	r8[0x0],r9
8000e41a:	c0 e8       	rjmp	8000e436 <_Balloc+0x66>
8000e41c:	0e 9c       	mov	r12,r7
8000e41e:	30 17       	mov	r7,1
8000e420:	0e 9b       	mov	r11,r7
8000e422:	ee 06 09 47 	lsl	r7,r7,r6
8000e426:	ee ca ff fb 	sub	r10,r7,-5
8000e42a:	a3 6a       	lsl	r10,0x2
8000e42c:	e0 a0 02 84 	rcall	8000e934 <_calloc_r>
8000e430:	c0 60       	breq	8000e43c <_Balloc+0x6c>
8000e432:	99 16       	st.w	r12[0x4],r6
8000e434:	99 27       	st.w	r12[0x8],r7
8000e436:	30 08       	mov	r8,0
8000e438:	99 38       	st.w	r12[0xc],r8
8000e43a:	99 48       	st.w	r12[0x10],r8
8000e43c:	d8 22       	popm	r4-r7,pc
8000e43e:	d7 03       	nop

8000e440 <__d2b>:
8000e440:	d4 31       	pushm	r0-r7,lr
8000e442:	20 2d       	sub	sp,8
8000e444:	16 93       	mov	r3,r11
8000e446:	12 96       	mov	r6,r9
8000e448:	10 95       	mov	r5,r8
8000e44a:	14 92       	mov	r2,r10
8000e44c:	30 1b       	mov	r11,1
8000e44e:	cc 1f       	rcall	8000e3d0 <_Balloc>
8000e450:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000e454:	50 09       	stdsp	sp[0x0],r9
8000e456:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000e45a:	b5 a9       	sbr	r9,0x14
8000e45c:	f0 01 16 14 	lsr	r1,r8,0x14
8000e460:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e464:	18 94       	mov	r4,r12
8000e466:	58 02       	cp.w	r2,0
8000e468:	c1 d0       	breq	8000e4a2 <__d2b+0x62>
8000e46a:	fa cc ff f8 	sub	r12,sp,-8
8000e46e:	18 d2       	st.w	--r12,r2
8000e470:	c3 6f       	rcall	8000e2dc <__lo0bits>
8000e472:	40 18       	lddsp	r8,sp[0x4]
8000e474:	c0 d0       	breq	8000e48e <__d2b+0x4e>
8000e476:	40 09       	lddsp	r9,sp[0x0]
8000e478:	f8 0a 11 20 	rsub	r10,r12,32
8000e47c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000e480:	f5 e8 10 08 	or	r8,r10,r8
8000e484:	89 58       	st.w	r4[0x14],r8
8000e486:	f2 0c 0a 49 	lsr	r9,r9,r12
8000e48a:	50 09       	stdsp	sp[0x0],r9
8000e48c:	c0 28       	rjmp	8000e490 <__d2b+0x50>
8000e48e:	89 58       	st.w	r4[0x14],r8
8000e490:	40 08       	lddsp	r8,sp[0x0]
8000e492:	58 08       	cp.w	r8,0
8000e494:	f9 b3 01 02 	movne	r3,2
8000e498:	f9 b3 00 01 	moveq	r3,1
8000e49c:	89 68       	st.w	r4[0x18],r8
8000e49e:	89 43       	st.w	r4[0x10],r3
8000e4a0:	c0 88       	rjmp	8000e4b0 <__d2b+0x70>
8000e4a2:	1a 9c       	mov	r12,sp
8000e4a4:	c1 cf       	rcall	8000e2dc <__lo0bits>
8000e4a6:	30 13       	mov	r3,1
8000e4a8:	40 08       	lddsp	r8,sp[0x0]
8000e4aa:	2e 0c       	sub	r12,-32
8000e4ac:	89 43       	st.w	r4[0x10],r3
8000e4ae:	89 58       	st.w	r4[0x14],r8
8000e4b0:	58 01       	cp.w	r1,0
8000e4b2:	c0 90       	breq	8000e4c4 <__d2b+0x84>
8000e4b4:	e2 c1 04 33 	sub	r1,r1,1075
8000e4b8:	18 01       	add	r1,r12
8000e4ba:	8d 01       	st.w	r6[0x0],r1
8000e4bc:	f8 0c 11 35 	rsub	r12,r12,53
8000e4c0:	8b 0c       	st.w	r5[0x0],r12
8000e4c2:	c0 c8       	rjmp	8000e4da <__d2b+0x9a>
8000e4c4:	e6 c8 ff fc 	sub	r8,r3,-4
8000e4c8:	f8 cc 04 32 	sub	r12,r12,1074
8000e4cc:	a5 73       	lsl	r3,0x5
8000e4ce:	8d 0c       	st.w	r6[0x0],r12
8000e4d0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000e4d4:	cd 4e       	rcall	8000e27c <__hi0bits>
8000e4d6:	18 13       	sub	r3,r12
8000e4d8:	8b 03       	st.w	r5[0x0],r3
8000e4da:	08 9c       	mov	r12,r4
8000e4dc:	2f ed       	sub	sp,-8
8000e4de:	d8 32       	popm	r0-r7,pc

8000e4e0 <__mdiff>:
8000e4e0:	d4 31       	pushm	r0-r7,lr
8000e4e2:	74 48       	ld.w	r8,r10[0x10]
8000e4e4:	76 45       	ld.w	r5,r11[0x10]
8000e4e6:	16 97       	mov	r7,r11
8000e4e8:	14 96       	mov	r6,r10
8000e4ea:	10 15       	sub	r5,r8
8000e4ec:	c1 31       	brne	8000e512 <__mdiff+0x32>
8000e4ee:	2f b8       	sub	r8,-5
8000e4f0:	ee ce ff ec 	sub	lr,r7,-20
8000e4f4:	a3 68       	lsl	r8,0x2
8000e4f6:	f4 08 00 0b 	add	r11,r10,r8
8000e4fa:	ee 08 00 08 	add	r8,r7,r8
8000e4fe:	11 4a       	ld.w	r10,--r8
8000e500:	17 49       	ld.w	r9,--r11
8000e502:	12 3a       	cp.w	r10,r9
8000e504:	c0 30       	breq	8000e50a <__mdiff+0x2a>
8000e506:	c0 e2       	brcc	8000e522 <__mdiff+0x42>
8000e508:	c0 78       	rjmp	8000e516 <__mdiff+0x36>
8000e50a:	1c 38       	cp.w	r8,lr
8000e50c:	fe 9b ff f9 	brhi	8000e4fe <__mdiff+0x1e>
8000e510:	c4 98       	rjmp	8000e5a2 <__mdiff+0xc2>
8000e512:	58 05       	cp.w	r5,0
8000e514:	c0 64       	brge	8000e520 <__mdiff+0x40>
8000e516:	0e 98       	mov	r8,r7
8000e518:	30 15       	mov	r5,1
8000e51a:	0c 97       	mov	r7,r6
8000e51c:	10 96       	mov	r6,r8
8000e51e:	c0 28       	rjmp	8000e522 <__mdiff+0x42>
8000e520:	30 05       	mov	r5,0
8000e522:	6e 1b       	ld.w	r11,r7[0x4]
8000e524:	c5 6f       	rcall	8000e3d0 <_Balloc>
8000e526:	6e 49       	ld.w	r9,r7[0x10]
8000e528:	6c 44       	ld.w	r4,r6[0x10]
8000e52a:	99 35       	st.w	r12[0xc],r5
8000e52c:	2f b4       	sub	r4,-5
8000e52e:	f2 c5 ff fb 	sub	r5,r9,-5
8000e532:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000e536:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000e53a:	2e c6       	sub	r6,-20
8000e53c:	2e c7       	sub	r7,-20
8000e53e:	f8 c8 ff ec 	sub	r8,r12,-20
8000e542:	30 0a       	mov	r10,0
8000e544:	0f 0e       	ld.w	lr,r7++
8000e546:	0d 0b       	ld.w	r11,r6++
8000e548:	fc 02 16 10 	lsr	r2,lr,0x10
8000e54c:	f6 03 16 10 	lsr	r3,r11,0x10
8000e550:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000e554:	e4 03 01 03 	sub	r3,r2,r3
8000e558:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e55c:	fc 0b 01 0b 	sub	r11,lr,r11
8000e560:	f6 0a 00 0a 	add	r10,r11,r10
8000e564:	b0 1a       	st.h	r8[0x2],r10
8000e566:	b1 4a       	asr	r10,0x10
8000e568:	e6 0a 00 0a 	add	r10,r3,r10
8000e56c:	b0 0a       	st.h	r8[0x0],r10
8000e56e:	2f c8       	sub	r8,-4
8000e570:	b1 4a       	asr	r10,0x10
8000e572:	08 36       	cp.w	r6,r4
8000e574:	ce 83       	brcs	8000e544 <__mdiff+0x64>
8000e576:	c0 d8       	rjmp	8000e590 <__mdiff+0xb0>
8000e578:	0f 0b       	ld.w	r11,r7++
8000e57a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000e57e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e582:	16 0a       	add	r10,r11
8000e584:	b0 1a       	st.h	r8[0x2],r10
8000e586:	b1 4a       	asr	r10,0x10
8000e588:	1c 0a       	add	r10,lr
8000e58a:	b0 0a       	st.h	r8[0x0],r10
8000e58c:	2f c8       	sub	r8,-4
8000e58e:	b1 4a       	asr	r10,0x10
8000e590:	0a 37       	cp.w	r7,r5
8000e592:	cf 33       	brcs	8000e578 <__mdiff+0x98>
8000e594:	c0 28       	rjmp	8000e598 <__mdiff+0xb8>
8000e596:	20 19       	sub	r9,1
8000e598:	11 4a       	ld.w	r10,--r8
8000e59a:	58 0a       	cp.w	r10,0
8000e59c:	cf d0       	breq	8000e596 <__mdiff+0xb6>
8000e59e:	99 49       	st.w	r12[0x10],r9
8000e5a0:	d8 32       	popm	r0-r7,pc
8000e5a2:	30 0b       	mov	r11,0
8000e5a4:	c1 6f       	rcall	8000e3d0 <_Balloc>
8000e5a6:	30 18       	mov	r8,1
8000e5a8:	99 48       	st.w	r12[0x10],r8
8000e5aa:	30 08       	mov	r8,0
8000e5ac:	99 58       	st.w	r12[0x14],r8
8000e5ae:	d8 32       	popm	r0-r7,pc

8000e5b0 <__lshift>:
8000e5b0:	d4 31       	pushm	r0-r7,lr
8000e5b2:	16 97       	mov	r7,r11
8000e5b4:	76 46       	ld.w	r6,r11[0x10]
8000e5b6:	f4 02 14 05 	asr	r2,r10,0x5
8000e5ba:	2f f6       	sub	r6,-1
8000e5bc:	14 93       	mov	r3,r10
8000e5be:	18 94       	mov	r4,r12
8000e5c0:	04 06       	add	r6,r2
8000e5c2:	76 1b       	ld.w	r11,r11[0x4]
8000e5c4:	6e 28       	ld.w	r8,r7[0x8]
8000e5c6:	c0 38       	rjmp	8000e5cc <__lshift+0x1c>
8000e5c8:	2f fb       	sub	r11,-1
8000e5ca:	a1 78       	lsl	r8,0x1
8000e5cc:	10 36       	cp.w	r6,r8
8000e5ce:	fe 99 ff fd 	brgt	8000e5c8 <__lshift+0x18>
8000e5d2:	08 9c       	mov	r12,r4
8000e5d4:	cf ee       	rcall	8000e3d0 <_Balloc>
8000e5d6:	30 09       	mov	r9,0
8000e5d8:	18 95       	mov	r5,r12
8000e5da:	f8 c8 ff ec 	sub	r8,r12,-20
8000e5de:	12 9a       	mov	r10,r9
8000e5e0:	c0 38       	rjmp	8000e5e6 <__lshift+0x36>
8000e5e2:	10 aa       	st.w	r8++,r10
8000e5e4:	2f f9       	sub	r9,-1
8000e5e6:	04 39       	cp.w	r9,r2
8000e5e8:	cf d5       	brlt	8000e5e2 <__lshift+0x32>
8000e5ea:	6e 4b       	ld.w	r11,r7[0x10]
8000e5ec:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000e5f0:	2f bb       	sub	r11,-5
8000e5f2:	ee c9 ff ec 	sub	r9,r7,-20
8000e5f6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000e5fa:	58 03       	cp.w	r3,0
8000e5fc:	c1 30       	breq	8000e622 <__lshift+0x72>
8000e5fe:	e6 0c 11 20 	rsub	r12,r3,32
8000e602:	30 0a       	mov	r10,0
8000e604:	72 02       	ld.w	r2,r9[0x0]
8000e606:	e4 03 09 42 	lsl	r2,r2,r3
8000e60a:	04 4a       	or	r10,r2
8000e60c:	10 aa       	st.w	r8++,r10
8000e60e:	13 0a       	ld.w	r10,r9++
8000e610:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000e614:	16 39       	cp.w	r9,r11
8000e616:	cf 73       	brcs	8000e604 <__lshift+0x54>
8000e618:	91 0a       	st.w	r8[0x0],r10
8000e61a:	58 0a       	cp.w	r10,0
8000e61c:	c0 70       	breq	8000e62a <__lshift+0x7a>
8000e61e:	2f f6       	sub	r6,-1
8000e620:	c0 58       	rjmp	8000e62a <__lshift+0x7a>
8000e622:	13 0a       	ld.w	r10,r9++
8000e624:	10 aa       	st.w	r8++,r10
8000e626:	16 39       	cp.w	r9,r11
8000e628:	cf d3       	brcs	8000e622 <__lshift+0x72>
8000e62a:	08 9c       	mov	r12,r4
8000e62c:	20 16       	sub	r6,1
8000e62e:	0e 9b       	mov	r11,r7
8000e630:	8b 46       	st.w	r5[0x10],r6
8000e632:	cb 5e       	rcall	8000e39c <_Bfree>
8000e634:	0a 9c       	mov	r12,r5
8000e636:	d8 32       	popm	r0-r7,pc

8000e638 <__multiply>:
8000e638:	d4 31       	pushm	r0-r7,lr
8000e63a:	20 2d       	sub	sp,8
8000e63c:	76 49       	ld.w	r9,r11[0x10]
8000e63e:	74 48       	ld.w	r8,r10[0x10]
8000e640:	16 96       	mov	r6,r11
8000e642:	14 95       	mov	r5,r10
8000e644:	10 39       	cp.w	r9,r8
8000e646:	ec 08 17 50 	movlt	r8,r6
8000e64a:	ea 06 17 50 	movlt	r6,r5
8000e64e:	f0 05 17 50 	movlt	r5,r8
8000e652:	6c 28       	ld.w	r8,r6[0x8]
8000e654:	76 43       	ld.w	r3,r11[0x10]
8000e656:	74 42       	ld.w	r2,r10[0x10]
8000e658:	76 1b       	ld.w	r11,r11[0x4]
8000e65a:	e4 03 00 07 	add	r7,r2,r3
8000e65e:	10 37       	cp.w	r7,r8
8000e660:	f7 bb 09 ff 	subgt	r11,-1
8000e664:	cb 6e       	rcall	8000e3d0 <_Balloc>
8000e666:	ee c4 ff fb 	sub	r4,r7,-5
8000e66a:	f8 c9 ff ec 	sub	r9,r12,-20
8000e66e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e672:	30 0a       	mov	r10,0
8000e674:	12 98       	mov	r8,r9
8000e676:	c0 28       	rjmp	8000e67a <__multiply+0x42>
8000e678:	10 aa       	st.w	r8++,r10
8000e67a:	08 38       	cp.w	r8,r4
8000e67c:	cf e3       	brcs	8000e678 <__multiply+0x40>
8000e67e:	2f b3       	sub	r3,-5
8000e680:	2f b2       	sub	r2,-5
8000e682:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000e686:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000e68a:	ec cb ff ec 	sub	r11,r6,-20
8000e68e:	50 12       	stdsp	sp[0x4],r2
8000e690:	ea ca ff ec 	sub	r10,r5,-20
8000e694:	c4 48       	rjmp	8000e71c <__multiply+0xe4>
8000e696:	94 95       	ld.uh	r5,r10[0x2]
8000e698:	58 05       	cp.w	r5,0
8000e69a:	c2 00       	breq	8000e6da <__multiply+0xa2>
8000e69c:	12 98       	mov	r8,r9
8000e69e:	16 96       	mov	r6,r11
8000e6a0:	30 0e       	mov	lr,0
8000e6a2:	50 09       	stdsp	sp[0x0],r9
8000e6a4:	0d 02       	ld.w	r2,r6++
8000e6a6:	e4 00 16 10 	lsr	r0,r2,0x10
8000e6aa:	70 01       	ld.w	r1,r8[0x0]
8000e6ac:	70 09       	ld.w	r9,r8[0x0]
8000e6ae:	b1 81       	lsr	r1,0x10
8000e6b0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000e6b4:	e0 05 03 41 	mac	r1,r0,r5
8000e6b8:	ab 32       	mul	r2,r5
8000e6ba:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000e6be:	00 02       	add	r2,r0
8000e6c0:	e4 0e 00 0e 	add	lr,r2,lr
8000e6c4:	b0 1e       	st.h	r8[0x2],lr
8000e6c6:	b1 8e       	lsr	lr,0x10
8000e6c8:	1c 01       	add	r1,lr
8000e6ca:	b0 01       	st.h	r8[0x0],r1
8000e6cc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000e6d0:	2f c8       	sub	r8,-4
8000e6d2:	06 36       	cp.w	r6,r3
8000e6d4:	ce 83       	brcs	8000e6a4 <__multiply+0x6c>
8000e6d6:	40 09       	lddsp	r9,sp[0x0]
8000e6d8:	91 0e       	st.w	r8[0x0],lr
8000e6da:	94 86       	ld.uh	r6,r10[0x0]
8000e6dc:	58 06       	cp.w	r6,0
8000e6de:	c1 d0       	breq	8000e718 <__multiply+0xe0>
8000e6e0:	72 02       	ld.w	r2,r9[0x0]
8000e6e2:	12 98       	mov	r8,r9
8000e6e4:	16 9e       	mov	lr,r11
8000e6e6:	30 05       	mov	r5,0
8000e6e8:	b0 12       	st.h	r8[0x2],r2
8000e6ea:	1d 01       	ld.w	r1,lr++
8000e6ec:	90 82       	ld.uh	r2,r8[0x0]
8000e6ee:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000e6f2:	ad 30       	mul	r0,r6
8000e6f4:	e0 02 00 02 	add	r2,r0,r2
8000e6f8:	e4 05 00 05 	add	r5,r2,r5
8000e6fc:	b0 05       	st.h	r8[0x0],r5
8000e6fe:	b1 85       	lsr	r5,0x10
8000e700:	b1 81       	lsr	r1,0x10
8000e702:	2f c8       	sub	r8,-4
8000e704:	ad 31       	mul	r1,r6
8000e706:	90 92       	ld.uh	r2,r8[0x2]
8000e708:	e2 02 00 02 	add	r2,r1,r2
8000e70c:	0a 02       	add	r2,r5
8000e70e:	e4 05 16 10 	lsr	r5,r2,0x10
8000e712:	06 3e       	cp.w	lr,r3
8000e714:	ce a3       	brcs	8000e6e8 <__multiply+0xb0>
8000e716:	91 02       	st.w	r8[0x0],r2
8000e718:	2f ca       	sub	r10,-4
8000e71a:	2f c9       	sub	r9,-4
8000e71c:	40 18       	lddsp	r8,sp[0x4]
8000e71e:	10 3a       	cp.w	r10,r8
8000e720:	cb b3       	brcs	8000e696 <__multiply+0x5e>
8000e722:	c0 28       	rjmp	8000e726 <__multiply+0xee>
8000e724:	20 17       	sub	r7,1
8000e726:	58 07       	cp.w	r7,0
8000e728:	e0 8a 00 05 	brle	8000e732 <__multiply+0xfa>
8000e72c:	09 48       	ld.w	r8,--r4
8000e72e:	58 08       	cp.w	r8,0
8000e730:	cf a0       	breq	8000e724 <__multiply+0xec>
8000e732:	99 47       	st.w	r12[0x10],r7
8000e734:	2f ed       	sub	sp,-8
8000e736:	d8 32       	popm	r0-r7,pc

8000e738 <__i2b>:
8000e738:	d4 21       	pushm	r4-r7,lr
8000e73a:	16 97       	mov	r7,r11
8000e73c:	30 1b       	mov	r11,1
8000e73e:	c4 9e       	rcall	8000e3d0 <_Balloc>
8000e740:	30 19       	mov	r9,1
8000e742:	99 57       	st.w	r12[0x14],r7
8000e744:	99 49       	st.w	r12[0x10],r9
8000e746:	d8 22       	popm	r4-r7,pc

8000e748 <__multadd>:
8000e748:	d4 31       	pushm	r0-r7,lr
8000e74a:	30 08       	mov	r8,0
8000e74c:	12 95       	mov	r5,r9
8000e74e:	16 97       	mov	r7,r11
8000e750:	18 96       	mov	r6,r12
8000e752:	76 44       	ld.w	r4,r11[0x10]
8000e754:	f6 c9 ff ec 	sub	r9,r11,-20
8000e758:	72 0b       	ld.w	r11,r9[0x0]
8000e75a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000e75e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e762:	f4 0c 02 4c 	mul	r12,r10,r12
8000e766:	f4 0b 03 45 	mac	r5,r10,r11
8000e76a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000e76e:	b1 85       	lsr	r5,0x10
8000e770:	18 05       	add	r5,r12
8000e772:	ea 0c 15 10 	lsl	r12,r5,0x10
8000e776:	f8 0b 00 0b 	add	r11,r12,r11
8000e77a:	12 ab       	st.w	r9++,r11
8000e77c:	2f f8       	sub	r8,-1
8000e77e:	b1 85       	lsr	r5,0x10
8000e780:	08 38       	cp.w	r8,r4
8000e782:	ce b5       	brlt	8000e758 <__multadd+0x10>
8000e784:	58 05       	cp.w	r5,0
8000e786:	c1 c0       	breq	8000e7be <__multadd+0x76>
8000e788:	6e 28       	ld.w	r8,r7[0x8]
8000e78a:	10 34       	cp.w	r4,r8
8000e78c:	c1 35       	brlt	8000e7b2 <__multadd+0x6a>
8000e78e:	6e 1b       	ld.w	r11,r7[0x4]
8000e790:	0c 9c       	mov	r12,r6
8000e792:	2f fb       	sub	r11,-1
8000e794:	c1 ee       	rcall	8000e3d0 <_Balloc>
8000e796:	6e 4a       	ld.w	r10,r7[0x10]
8000e798:	ee cb ff f4 	sub	r11,r7,-12
8000e79c:	18 93       	mov	r3,r12
8000e79e:	2f ea       	sub	r10,-2
8000e7a0:	2f 4c       	sub	r12,-12
8000e7a2:	a3 6a       	lsl	r10,0x2
8000e7a4:	fe b0 dd cb 	rcall	8000a33a <memcpy>
8000e7a8:	0e 9b       	mov	r11,r7
8000e7aa:	0c 9c       	mov	r12,r6
8000e7ac:	fe b0 fd f8 	rcall	8000e39c <_Bfree>
8000e7b0:	06 97       	mov	r7,r3
8000e7b2:	e8 c8 ff ff 	sub	r8,r4,-1
8000e7b6:	2f b4       	sub	r4,-5
8000e7b8:	8f 48       	st.w	r7[0x10],r8
8000e7ba:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000e7be:	0e 9c       	mov	r12,r7
8000e7c0:	d8 32       	popm	r0-r7,pc
8000e7c2:	d7 03       	nop

8000e7c4 <__pow5mult>:
8000e7c4:	d4 31       	pushm	r0-r7,lr
8000e7c6:	14 96       	mov	r6,r10
8000e7c8:	18 97       	mov	r7,r12
8000e7ca:	16 94       	mov	r4,r11
8000e7cc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000e7d0:	c0 80       	breq	8000e7e0 <__pow5mult+0x1c>
8000e7d2:	20 18       	sub	r8,1
8000e7d4:	49 f9       	lddpc	r9,8000e850 <__pow5mult+0x8c>
8000e7d6:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000e7da:	30 09       	mov	r9,0
8000e7dc:	cb 6f       	rcall	8000e748 <__multadd>
8000e7de:	18 94       	mov	r4,r12
8000e7e0:	a3 46       	asr	r6,0x2
8000e7e2:	c3 40       	breq	8000e84a <__pow5mult+0x86>
8000e7e4:	6e 95       	ld.w	r5,r7[0x24]
8000e7e6:	58 05       	cp.w	r5,0
8000e7e8:	c0 91       	brne	8000e7fa <__pow5mult+0x36>
8000e7ea:	31 0c       	mov	r12,16
8000e7ec:	fe b0 db 70 	rcall	80009ecc <malloc>
8000e7f0:	99 35       	st.w	r12[0xc],r5
8000e7f2:	8f 9c       	st.w	r7[0x24],r12
8000e7f4:	99 15       	st.w	r12[0x4],r5
8000e7f6:	99 25       	st.w	r12[0x8],r5
8000e7f8:	99 05       	st.w	r12[0x0],r5
8000e7fa:	6e 93       	ld.w	r3,r7[0x24]
8000e7fc:	66 25       	ld.w	r5,r3[0x8]
8000e7fe:	58 05       	cp.w	r5,0
8000e800:	c0 c1       	brne	8000e818 <__pow5mult+0x54>
8000e802:	e0 6b 02 71 	mov	r11,625
8000e806:	0e 9c       	mov	r12,r7
8000e808:	c9 8f       	rcall	8000e738 <__i2b>
8000e80a:	87 2c       	st.w	r3[0x8],r12
8000e80c:	30 08       	mov	r8,0
8000e80e:	18 95       	mov	r5,r12
8000e810:	99 08       	st.w	r12[0x0],r8
8000e812:	c0 38       	rjmp	8000e818 <__pow5mult+0x54>
8000e814:	06 9c       	mov	r12,r3
8000e816:	18 95       	mov	r5,r12
8000e818:	ed b6 00 00 	bld	r6,0x0
8000e81c:	c0 b1       	brne	8000e832 <__pow5mult+0x6e>
8000e81e:	08 9b       	mov	r11,r4
8000e820:	0a 9a       	mov	r10,r5
8000e822:	0e 9c       	mov	r12,r7
8000e824:	c0 af       	rcall	8000e638 <__multiply>
8000e826:	08 9b       	mov	r11,r4
8000e828:	18 93       	mov	r3,r12
8000e82a:	0e 9c       	mov	r12,r7
8000e82c:	06 94       	mov	r4,r3
8000e82e:	fe b0 fd b7 	rcall	8000e39c <_Bfree>
8000e832:	a1 56       	asr	r6,0x1
8000e834:	c0 b0       	breq	8000e84a <__pow5mult+0x86>
8000e836:	6a 03       	ld.w	r3,r5[0x0]
8000e838:	58 03       	cp.w	r3,0
8000e83a:	ce d1       	brne	8000e814 <__pow5mult+0x50>
8000e83c:	0a 9a       	mov	r10,r5
8000e83e:	0a 9b       	mov	r11,r5
8000e840:	0e 9c       	mov	r12,r7
8000e842:	cf be       	rcall	8000e638 <__multiply>
8000e844:	8b 0c       	st.w	r5[0x0],r12
8000e846:	99 03       	st.w	r12[0x0],r3
8000e848:	ce 7b       	rjmp	8000e816 <__pow5mult+0x52>
8000e84a:	08 9c       	mov	r12,r4
8000e84c:	d8 32       	popm	r0-r7,pc
8000e84e:	d7 03       	nop
8000e850:	80 01       	ld.sh	r1,r0[0x0]
8000e852:	91 54       	st.w	r8[0x14],r4

8000e854 <__isinfd>:
8000e854:	14 98       	mov	r8,r10
8000e856:	fc 19 7f f0 	movh	r9,0x7ff0
8000e85a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e85e:	f0 0b 11 00 	rsub	r11,r8,0
8000e862:	f7 e8 10 08 	or	r8,r11,r8
8000e866:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000e86a:	f2 08 01 08 	sub	r8,r9,r8
8000e86e:	f0 0c 11 00 	rsub	r12,r8,0
8000e872:	f9 e8 10 08 	or	r8,r12,r8
8000e876:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000e87a:	2f fc       	sub	r12,-1
8000e87c:	5e fc       	retal	r12

8000e87e <__isnand>:
8000e87e:	14 98       	mov	r8,r10
8000e880:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e884:	f0 0c 11 00 	rsub	r12,r8,0
8000e888:	10 4c       	or	r12,r8
8000e88a:	fc 18 7f f0 	movh	r8,0x7ff0
8000e88e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000e892:	f0 0c 01 0c 	sub	r12,r8,r12
8000e896:	bf 9c       	lsr	r12,0x1f
8000e898:	5e fc       	retal	r12
8000e89a:	d7 03       	nop

8000e89c <__sclose>:
8000e89c:	d4 01       	pushm	lr
8000e89e:	96 7b       	ld.sh	r11,r11[0xe]
8000e8a0:	c7 6c       	rcall	8000e98c <_close_r>
8000e8a2:	d8 02       	popm	pc

8000e8a4 <__sseek>:
8000e8a4:	d4 21       	pushm	r4-r7,lr
8000e8a6:	16 97       	mov	r7,r11
8000e8a8:	96 7b       	ld.sh	r11,r11[0xe]
8000e8aa:	cf 9c       	rcall	8000ea9c <_lseek_r>
8000e8ac:	8e 68       	ld.sh	r8,r7[0xc]
8000e8ae:	10 99       	mov	r9,r8
8000e8b0:	ad c8       	cbr	r8,0xc
8000e8b2:	ad a9       	sbr	r9,0xc
8000e8b4:	5b fc       	cp.w	r12,-1
8000e8b6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000e8ba:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000e8be:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000e8c2:	d8 22       	popm	r4-r7,pc

8000e8c4 <__swrite>:
8000e8c4:	d4 21       	pushm	r4-r7,lr
8000e8c6:	96 68       	ld.sh	r8,r11[0xc]
8000e8c8:	16 97       	mov	r7,r11
8000e8ca:	14 95       	mov	r5,r10
8000e8cc:	12 94       	mov	r4,r9
8000e8ce:	e2 18 01 00 	andl	r8,0x100,COH
8000e8d2:	18 96       	mov	r6,r12
8000e8d4:	c0 50       	breq	8000e8de <__swrite+0x1a>
8000e8d6:	30 29       	mov	r9,2
8000e8d8:	30 0a       	mov	r10,0
8000e8da:	96 7b       	ld.sh	r11,r11[0xe]
8000e8dc:	ce 0c       	rcall	8000ea9c <_lseek_r>
8000e8de:	8e 68       	ld.sh	r8,r7[0xc]
8000e8e0:	ad c8       	cbr	r8,0xc
8000e8e2:	08 99       	mov	r9,r4
8000e8e4:	0a 9a       	mov	r10,r5
8000e8e6:	8e 7b       	ld.sh	r11,r7[0xe]
8000e8e8:	0c 9c       	mov	r12,r6
8000e8ea:	ae 68       	st.h	r7[0xc],r8
8000e8ec:	c1 0c       	rcall	8000e90c <_write_r>
8000e8ee:	d8 22       	popm	r4-r7,pc

8000e8f0 <__sread>:
8000e8f0:	d4 21       	pushm	r4-r7,lr
8000e8f2:	16 97       	mov	r7,r11
8000e8f4:	96 7b       	ld.sh	r11,r11[0xe]
8000e8f6:	ce 7c       	rcall	8000eac4 <_read_r>
8000e8f8:	c0 65       	brlt	8000e904 <__sread+0x14>
8000e8fa:	6f 58       	ld.w	r8,r7[0x54]
8000e8fc:	18 08       	add	r8,r12
8000e8fe:	ef 48 00 54 	st.w	r7[84],r8
8000e902:	d8 22       	popm	r4-r7,pc
8000e904:	8e 68       	ld.sh	r8,r7[0xc]
8000e906:	ad c8       	cbr	r8,0xc
8000e908:	ae 68       	st.h	r7[0xc],r8
8000e90a:	d8 22       	popm	r4-r7,pc

8000e90c <_write_r>:
8000e90c:	d4 21       	pushm	r4-r7,lr
8000e90e:	16 98       	mov	r8,r11
8000e910:	18 97       	mov	r7,r12
8000e912:	10 9c       	mov	r12,r8
8000e914:	30 08       	mov	r8,0
8000e916:	14 9b       	mov	r11,r10
8000e918:	e0 66 46 20 	mov	r6,17952
8000e91c:	12 9a       	mov	r10,r9
8000e91e:	8d 08       	st.w	r6[0x0],r8
8000e920:	fe b0 d0 56 	rcall	800089cc <_write>
8000e924:	5b fc       	cp.w	r12,-1
8000e926:	c0 51       	brne	8000e930 <_write_r+0x24>
8000e928:	6c 08       	ld.w	r8,r6[0x0]
8000e92a:	58 08       	cp.w	r8,0
8000e92c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000e930:	d8 22       	popm	r4-r7,pc
8000e932:	d7 03       	nop

8000e934 <_calloc_r>:
8000e934:	d4 21       	pushm	r4-r7,lr
8000e936:	f4 0b 02 4b 	mul	r11,r10,r11
8000e93a:	fe b0 da d1 	rcall	80009edc <_malloc_r>
8000e93e:	18 97       	mov	r7,r12
8000e940:	c2 30       	breq	8000e986 <_calloc_r+0x52>
8000e942:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000e946:	e0 1a ff fc 	andl	r10,0xfffc
8000e94a:	20 4a       	sub	r10,4
8000e94c:	e0 4a 00 24 	cp.w	r10,36
8000e950:	e0 8b 00 18 	brhi	8000e980 <_calloc_r+0x4c>
8000e954:	18 98       	mov	r8,r12
8000e956:	59 3a       	cp.w	r10,19
8000e958:	e0 88 00 0f 	brls	8000e976 <_calloc_r+0x42>
8000e95c:	30 09       	mov	r9,0
8000e95e:	10 a9       	st.w	r8++,r9
8000e960:	10 a9       	st.w	r8++,r9
8000e962:	59 ba       	cp.w	r10,27
8000e964:	e0 88 00 09 	brls	8000e976 <_calloc_r+0x42>
8000e968:	10 a9       	st.w	r8++,r9
8000e96a:	10 a9       	st.w	r8++,r9
8000e96c:	e0 4a 00 24 	cp.w	r10,36
8000e970:	c0 31       	brne	8000e976 <_calloc_r+0x42>
8000e972:	10 a9       	st.w	r8++,r9
8000e974:	10 a9       	st.w	r8++,r9
8000e976:	30 09       	mov	r9,0
8000e978:	10 a9       	st.w	r8++,r9
8000e97a:	91 19       	st.w	r8[0x4],r9
8000e97c:	91 09       	st.w	r8[0x0],r9
8000e97e:	c0 48       	rjmp	8000e986 <_calloc_r+0x52>
8000e980:	30 0b       	mov	r11,0
8000e982:	fe b0 dd 80 	rcall	8000a482 <memset>
8000e986:	0e 9c       	mov	r12,r7
8000e988:	d8 22       	popm	r4-r7,pc
8000e98a:	d7 03       	nop

8000e98c <_close_r>:
8000e98c:	d4 21       	pushm	r4-r7,lr
8000e98e:	30 08       	mov	r8,0
8000e990:	18 97       	mov	r7,r12
8000e992:	e0 66 46 20 	mov	r6,17952
8000e996:	16 9c       	mov	r12,r11
8000e998:	8d 08       	st.w	r6[0x0],r8
8000e99a:	fe b0 df a5 	rcall	8000a8e4 <_close>
8000e99e:	5b fc       	cp.w	r12,-1
8000e9a0:	c0 51       	brne	8000e9aa <_close_r+0x1e>
8000e9a2:	6c 08       	ld.w	r8,r6[0x0]
8000e9a4:	58 08       	cp.w	r8,0
8000e9a6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000e9aa:	d8 22       	popm	r4-r7,pc

8000e9ac <_fclose_r>:
8000e9ac:	d4 21       	pushm	r4-r7,lr
8000e9ae:	18 96       	mov	r6,r12
8000e9b0:	16 97       	mov	r7,r11
8000e9b2:	58 0b       	cp.w	r11,0
8000e9b4:	c0 31       	brne	8000e9ba <_fclose_r+0xe>
8000e9b6:	16 95       	mov	r5,r11
8000e9b8:	c5 08       	rjmp	8000ea58 <_fclose_r+0xac>
8000e9ba:	fe b0 f8 b1 	rcall	8000db1c <__sfp_lock_acquire>
8000e9be:	58 06       	cp.w	r6,0
8000e9c0:	c0 70       	breq	8000e9ce <_fclose_r+0x22>
8000e9c2:	6c 68       	ld.w	r8,r6[0x18]
8000e9c4:	58 08       	cp.w	r8,0
8000e9c6:	c0 41       	brne	8000e9ce <_fclose_r+0x22>
8000e9c8:	0c 9c       	mov	r12,r6
8000e9ca:	fe b0 f8 fd 	rcall	8000dbc4 <__sinit>
8000e9ce:	4a 48       	lddpc	r8,8000ea5c <_fclose_r+0xb0>
8000e9d0:	10 37       	cp.w	r7,r8
8000e9d2:	c0 31       	brne	8000e9d8 <_fclose_r+0x2c>
8000e9d4:	6c 07       	ld.w	r7,r6[0x0]
8000e9d6:	c0 a8       	rjmp	8000e9ea <_fclose_r+0x3e>
8000e9d8:	4a 28       	lddpc	r8,8000ea60 <_fclose_r+0xb4>
8000e9da:	10 37       	cp.w	r7,r8
8000e9dc:	c0 31       	brne	8000e9e2 <_fclose_r+0x36>
8000e9de:	6c 17       	ld.w	r7,r6[0x4]
8000e9e0:	c0 58       	rjmp	8000e9ea <_fclose_r+0x3e>
8000e9e2:	4a 18       	lddpc	r8,8000ea64 <_fclose_r+0xb8>
8000e9e4:	10 37       	cp.w	r7,r8
8000e9e6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e9ea:	8e 69       	ld.sh	r9,r7[0xc]
8000e9ec:	30 08       	mov	r8,0
8000e9ee:	f0 09 19 00 	cp.h	r9,r8
8000e9f2:	c0 51       	brne	8000e9fc <_fclose_r+0x50>
8000e9f4:	fe b0 f8 95 	rcall	8000db1e <__sfp_lock_release>
8000e9f8:	30 05       	mov	r5,0
8000e9fa:	c2 f8       	rjmp	8000ea58 <_fclose_r+0xac>
8000e9fc:	0e 9b       	mov	r11,r7
8000e9fe:	0c 9c       	mov	r12,r6
8000ea00:	fe b0 f8 06 	rcall	8000da0c <_fflush_r>
8000ea04:	6e c8       	ld.w	r8,r7[0x30]
8000ea06:	18 95       	mov	r5,r12
8000ea08:	58 08       	cp.w	r8,0
8000ea0a:	c0 60       	breq	8000ea16 <_fclose_r+0x6a>
8000ea0c:	6e 8b       	ld.w	r11,r7[0x20]
8000ea0e:	0c 9c       	mov	r12,r6
8000ea10:	5d 18       	icall	r8
8000ea12:	f9 b5 05 ff 	movlt	r5,-1
8000ea16:	8e 68       	ld.sh	r8,r7[0xc]
8000ea18:	ed b8 00 07 	bld	r8,0x7
8000ea1c:	c0 51       	brne	8000ea26 <_fclose_r+0x7a>
8000ea1e:	6e 4b       	ld.w	r11,r7[0x10]
8000ea20:	0c 9c       	mov	r12,r6
8000ea22:	fe b0 f9 6b 	rcall	8000dcf8 <_free_r>
8000ea26:	6e db       	ld.w	r11,r7[0x34]
8000ea28:	58 0b       	cp.w	r11,0
8000ea2a:	c0 a0       	breq	8000ea3e <_fclose_r+0x92>
8000ea2c:	ee c8 ff bc 	sub	r8,r7,-68
8000ea30:	10 3b       	cp.w	r11,r8
8000ea32:	c0 40       	breq	8000ea3a <_fclose_r+0x8e>
8000ea34:	0c 9c       	mov	r12,r6
8000ea36:	fe b0 f9 61 	rcall	8000dcf8 <_free_r>
8000ea3a:	30 08       	mov	r8,0
8000ea3c:	8f d8       	st.w	r7[0x34],r8
8000ea3e:	6f 2b       	ld.w	r11,r7[0x48]
8000ea40:	58 0b       	cp.w	r11,0
8000ea42:	c0 70       	breq	8000ea50 <_fclose_r+0xa4>
8000ea44:	0c 9c       	mov	r12,r6
8000ea46:	fe b0 f9 59 	rcall	8000dcf8 <_free_r>
8000ea4a:	30 08       	mov	r8,0
8000ea4c:	ef 48 00 48 	st.w	r7[72],r8
8000ea50:	30 08       	mov	r8,0
8000ea52:	ae 68       	st.h	r7[0xc],r8
8000ea54:	fe b0 f8 65 	rcall	8000db1e <__sfp_lock_release>
8000ea58:	0a 9c       	mov	r12,r5
8000ea5a:	d8 22       	popm	r4-r7,pc
8000ea5c:	80 01       	ld.sh	r1,r0[0x0]
8000ea5e:	90 b0       	ld.uh	r0,r8[0x6]
8000ea60:	80 01       	ld.sh	r1,r0[0x0]
8000ea62:	90 d0       	ld.uh	r0,r8[0xa]
8000ea64:	80 01       	ld.sh	r1,r0[0x0]
8000ea66:	90 f0       	ld.uh	r0,r8[0xe]

8000ea68 <fclose>:
8000ea68:	d4 01       	pushm	lr
8000ea6a:	e0 68 0a 38 	mov	r8,2616
8000ea6e:	18 9b       	mov	r11,r12
8000ea70:	70 0c       	ld.w	r12,r8[0x0]
8000ea72:	c9 df       	rcall	8000e9ac <_fclose_r>
8000ea74:	d8 02       	popm	pc
8000ea76:	d7 03       	nop

8000ea78 <_fstat_r>:
8000ea78:	d4 21       	pushm	r4-r7,lr
8000ea7a:	16 98       	mov	r8,r11
8000ea7c:	18 97       	mov	r7,r12
8000ea7e:	10 9c       	mov	r12,r8
8000ea80:	30 08       	mov	r8,0
8000ea82:	e0 66 46 20 	mov	r6,17952
8000ea86:	14 9b       	mov	r11,r10
8000ea88:	8d 08       	st.w	r6[0x0],r8
8000ea8a:	fe b0 df 55 	rcall	8000a934 <_fstat>
8000ea8e:	5b fc       	cp.w	r12,-1
8000ea90:	c0 51       	brne	8000ea9a <_fstat_r+0x22>
8000ea92:	6c 08       	ld.w	r8,r6[0x0]
8000ea94:	58 08       	cp.w	r8,0
8000ea96:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ea9a:	d8 22       	popm	r4-r7,pc

8000ea9c <_lseek_r>:
8000ea9c:	d4 21       	pushm	r4-r7,lr
8000ea9e:	16 98       	mov	r8,r11
8000eaa0:	18 97       	mov	r7,r12
8000eaa2:	10 9c       	mov	r12,r8
8000eaa4:	30 08       	mov	r8,0
8000eaa6:	14 9b       	mov	r11,r10
8000eaa8:	e0 66 46 20 	mov	r6,17952
8000eaac:	12 9a       	mov	r10,r9
8000eaae:	8d 08       	st.w	r6[0x0],r8
8000eab0:	fe b0 df 24 	rcall	8000a8f8 <_lseek>
8000eab4:	5b fc       	cp.w	r12,-1
8000eab6:	c0 51       	brne	8000eac0 <_lseek_r+0x24>
8000eab8:	6c 08       	ld.w	r8,r6[0x0]
8000eaba:	58 08       	cp.w	r8,0
8000eabc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eac0:	d8 22       	popm	r4-r7,pc
8000eac2:	d7 03       	nop

8000eac4 <_read_r>:
8000eac4:	d4 21       	pushm	r4-r7,lr
8000eac6:	16 98       	mov	r8,r11
8000eac8:	18 97       	mov	r7,r12
8000eaca:	10 9c       	mov	r12,r8
8000eacc:	30 08       	mov	r8,0
8000eace:	14 9b       	mov	r11,r10
8000ead0:	e0 66 46 20 	mov	r6,17952
8000ead4:	12 9a       	mov	r10,r9
8000ead6:	8d 08       	st.w	r6[0x0],r8
8000ead8:	fe b0 cf 5a 	rcall	8000898c <_read>
8000eadc:	5b fc       	cp.w	r12,-1
8000eade:	c0 51       	brne	8000eae8 <_read_r+0x24>
8000eae0:	6c 08       	ld.w	r8,r6[0x0]
8000eae2:	58 08       	cp.w	r8,0
8000eae4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eae8:	d8 22       	popm	r4-r7,pc
8000eaea:	d7 03       	nop

8000eaec <__avr32_f64_mul>:
8000eaec:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000eaf0:	e0 80 00 dc 	breq	8000eca8 <__avr32_f64_mul_op1_zero>
8000eaf4:	d4 21       	pushm	r4-r7,lr
8000eaf6:	f7 e9 20 0e 	eor	lr,r11,r9
8000eafa:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000eafe:	30 15       	mov	r5,1
8000eb00:	c4 30       	breq	8000eb86 <__avr32_f64_mul_op1_subnormal>
8000eb02:	ab 6b       	lsl	r11,0xa
8000eb04:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000eb08:	ab 6a       	lsl	r10,0xa
8000eb0a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000eb0e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000eb12:	c5 c0       	breq	8000ebca <__avr32_f64_mul_op2_subnormal>
8000eb14:	a1 78       	lsl	r8,0x1
8000eb16:	5c f9       	rol	r9
8000eb18:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000eb1c:	e0 47 07 ff 	cp.w	r7,2047
8000eb20:	c7 70       	breq	8000ec0e <__avr32_f64_mul_op_nan_or_inf>
8000eb22:	e0 46 07 ff 	cp.w	r6,2047
8000eb26:	c7 40       	breq	8000ec0e <__avr32_f64_mul_op_nan_or_inf>
8000eb28:	ee 06 00 0c 	add	r12,r7,r6
8000eb2c:	e0 2c 03 fe 	sub	r12,1022
8000eb30:	f6 08 06 44 	mulu.d	r4,r11,r8
8000eb34:	f4 09 07 44 	macu.d	r4,r10,r9
8000eb38:	f4 08 06 46 	mulu.d	r6,r10,r8
8000eb3c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000eb40:	08 07       	add	r7,r4
8000eb42:	f4 05 00 4a 	adc	r10,r10,r5
8000eb46:	5c 0b       	acr	r11
8000eb48:	ed bb 00 14 	bld	r11,0x14
8000eb4c:	c0 50       	breq	8000eb56 <__avr32_f64_mul+0x6a>
8000eb4e:	a1 77       	lsl	r7,0x1
8000eb50:	5c fa       	rol	r10
8000eb52:	5c fb       	rol	r11
8000eb54:	20 1c       	sub	r12,1
8000eb56:	58 0c       	cp.w	r12,0
8000eb58:	e0 8a 00 6f 	brle	8000ec36 <__avr32_f64_mul_res_subnormal>
8000eb5c:	e0 4c 07 ff 	cp.w	r12,2047
8000eb60:	e0 84 00 9c 	brge	8000ec98 <__avr32_f64_mul_res_inf>
8000eb64:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000eb68:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000eb6c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000eb70:	ee 17 80 00 	eorh	r7,0x8000
8000eb74:	f1 b7 04 20 	satu	r7,0x1
8000eb78:	0e 0a       	add	r10,r7
8000eb7a:	5c 0b       	acr	r11
8000eb7c:	ed be 00 1f 	bld	lr,0x1f
8000eb80:	ef bb 00 1f 	bst	r11,0x1f
8000eb84:	d8 22       	popm	r4-r7,pc

8000eb86 <__avr32_f64_mul_op1_subnormal>:
8000eb86:	e4 1b 00 0f 	andh	r11,0xf
8000eb8a:	f4 0c 12 00 	clz	r12,r10
8000eb8e:	f6 06 12 00 	clz	r6,r11
8000eb92:	f7 bc 03 e1 	sublo	r12,-31
8000eb96:	f8 06 17 30 	movlo	r6,r12
8000eb9a:	f7 b6 02 01 	subhs	r6,1
8000eb9e:	e0 46 00 20 	cp.w	r6,32
8000eba2:	c0 d4       	brge	8000ebbc <__avr32_f64_mul_op1_subnormal+0x36>
8000eba4:	ec 0c 11 20 	rsub	r12,r6,32
8000eba8:	f6 06 09 4b 	lsl	r11,r11,r6
8000ebac:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ebb0:	18 4b       	or	r11,r12
8000ebb2:	f4 06 09 4a 	lsl	r10,r10,r6
8000ebb6:	20 b6       	sub	r6,11
8000ebb8:	0c 17       	sub	r7,r6
8000ebba:	ca ab       	rjmp	8000eb0e <__avr32_f64_mul+0x22>
8000ebbc:	f4 06 09 4b 	lsl	r11,r10,r6
8000ebc0:	c6 40       	breq	8000ec88 <__avr32_f64_mul_res_zero>
8000ebc2:	30 0a       	mov	r10,0
8000ebc4:	20 b6       	sub	r6,11
8000ebc6:	0c 17       	sub	r7,r6
8000ebc8:	ca 3b       	rjmp	8000eb0e <__avr32_f64_mul+0x22>

8000ebca <__avr32_f64_mul_op2_subnormal>:
8000ebca:	e4 19 00 0f 	andh	r9,0xf
8000ebce:	f0 0c 12 00 	clz	r12,r8
8000ebd2:	f2 05 12 00 	clz	r5,r9
8000ebd6:	f7 bc 03 ea 	sublo	r12,-22
8000ebda:	f8 05 17 30 	movlo	r5,r12
8000ebde:	f7 b5 02 0a 	subhs	r5,10
8000ebe2:	e0 45 00 20 	cp.w	r5,32
8000ebe6:	c0 d4       	brge	8000ec00 <__avr32_f64_mul_op2_subnormal+0x36>
8000ebe8:	ea 0c 11 20 	rsub	r12,r5,32
8000ebec:	f2 05 09 49 	lsl	r9,r9,r5
8000ebf0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ebf4:	18 49       	or	r9,r12
8000ebf6:	f0 05 09 48 	lsl	r8,r8,r5
8000ebfa:	20 25       	sub	r5,2
8000ebfc:	0a 16       	sub	r6,r5
8000ebfe:	c8 fb       	rjmp	8000eb1c <__avr32_f64_mul+0x30>
8000ec00:	f0 05 09 49 	lsl	r9,r8,r5
8000ec04:	c4 20       	breq	8000ec88 <__avr32_f64_mul_res_zero>
8000ec06:	30 08       	mov	r8,0
8000ec08:	20 25       	sub	r5,2
8000ec0a:	0a 16       	sub	r6,r5
8000ec0c:	c8 8b       	rjmp	8000eb1c <__avr32_f64_mul+0x30>

8000ec0e <__avr32_f64_mul_op_nan_or_inf>:
8000ec0e:	e4 19 00 0f 	andh	r9,0xf
8000ec12:	e4 1b 00 0f 	andh	r11,0xf
8000ec16:	14 4b       	or	r11,r10
8000ec18:	10 49       	or	r9,r8
8000ec1a:	e0 47 07 ff 	cp.w	r7,2047
8000ec1e:	c0 91       	brne	8000ec30 <__avr32_f64_mul_op1_not_naninf>
8000ec20:	58 0b       	cp.w	r11,0
8000ec22:	c3 81       	brne	8000ec92 <__avr32_f64_mul_res_nan>
8000ec24:	e0 46 07 ff 	cp.w	r6,2047
8000ec28:	c3 81       	brne	8000ec98 <__avr32_f64_mul_res_inf>
8000ec2a:	58 09       	cp.w	r9,0
8000ec2c:	c3 60       	breq	8000ec98 <__avr32_f64_mul_res_inf>
8000ec2e:	c3 28       	rjmp	8000ec92 <__avr32_f64_mul_res_nan>

8000ec30 <__avr32_f64_mul_op1_not_naninf>:
8000ec30:	58 09       	cp.w	r9,0
8000ec32:	c3 30       	breq	8000ec98 <__avr32_f64_mul_res_inf>
8000ec34:	c2 f8       	rjmp	8000ec92 <__avr32_f64_mul_res_nan>

8000ec36 <__avr32_f64_mul_res_subnormal>:
8000ec36:	5c 3c       	neg	r12
8000ec38:	2f fc       	sub	r12,-1
8000ec3a:	f1 bc 04 c0 	satu	r12,0x6
8000ec3e:	e0 4c 00 20 	cp.w	r12,32
8000ec42:	c1 14       	brge	8000ec64 <__avr32_f64_mul_res_subnormal+0x2e>
8000ec44:	f8 08 11 20 	rsub	r8,r12,32
8000ec48:	0e 46       	or	r6,r7
8000ec4a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ec4e:	f4 08 09 49 	lsl	r9,r10,r8
8000ec52:	12 47       	or	r7,r9
8000ec54:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ec58:	f6 08 09 49 	lsl	r9,r11,r8
8000ec5c:	12 4a       	or	r10,r9
8000ec5e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ec62:	c8 3b       	rjmp	8000eb68 <__avr32_f64_mul+0x7c>
8000ec64:	f8 08 11 20 	rsub	r8,r12,32
8000ec68:	f9 b9 00 00 	moveq	r9,0
8000ec6c:	c0 30       	breq	8000ec72 <__avr32_f64_mul_res_subnormal+0x3c>
8000ec6e:	f6 08 09 49 	lsl	r9,r11,r8
8000ec72:	0e 46       	or	r6,r7
8000ec74:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ec78:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ec7c:	f3 ea 10 07 	or	r7,r9,r10
8000ec80:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ec84:	30 0b       	mov	r11,0
8000ec86:	c7 1b       	rjmp	8000eb68 <__avr32_f64_mul+0x7c>

8000ec88 <__avr32_f64_mul_res_zero>:
8000ec88:	1c 9b       	mov	r11,lr
8000ec8a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ec8e:	30 0a       	mov	r10,0
8000ec90:	d8 22       	popm	r4-r7,pc

8000ec92 <__avr32_f64_mul_res_nan>:
8000ec92:	3f fb       	mov	r11,-1
8000ec94:	3f fa       	mov	r10,-1
8000ec96:	d8 22       	popm	r4-r7,pc

8000ec98 <__avr32_f64_mul_res_inf>:
8000ec98:	f0 6b 00 00 	mov	r11,-1048576
8000ec9c:	ed be 00 1f 	bld	lr,0x1f
8000eca0:	ef bb 00 1f 	bst	r11,0x1f
8000eca4:	30 0a       	mov	r10,0
8000eca6:	d8 22       	popm	r4-r7,pc

8000eca8 <__avr32_f64_mul_op1_zero>:
8000eca8:	f7 e9 20 0b 	eor	r11,r11,r9
8000ecac:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ecb0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ecb4:	e0 4c 07 ff 	cp.w	r12,2047
8000ecb8:	5e 1c       	retne	r12
8000ecba:	3f fa       	mov	r10,-1
8000ecbc:	3f fb       	mov	r11,-1
8000ecbe:	5e fc       	retal	r12

8000ecc0 <__avr32_f64_sub_from_add>:
8000ecc0:	ee 19 80 00 	eorh	r9,0x8000

8000ecc4 <__avr32_f64_sub>:
8000ecc4:	f7 e9 20 0c 	eor	r12,r11,r9
8000ecc8:	e0 86 00 ca 	brmi	8000ee5c <__avr32_f64_add_from_sub>
8000eccc:	eb cd 40 e0 	pushm	r5-r7,lr
8000ecd0:	16 9c       	mov	r12,r11
8000ecd2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ecd6:	bf db       	cbr	r11,0x1f
8000ecd8:	bf d9       	cbr	r9,0x1f
8000ecda:	10 3a       	cp.w	r10,r8
8000ecdc:	f2 0b 13 00 	cpc	r11,r9
8000ece0:	c0 92       	brcc	8000ecf2 <__avr32_f64_sub+0x2e>
8000ece2:	16 97       	mov	r7,r11
8000ece4:	12 9b       	mov	r11,r9
8000ece6:	0e 99       	mov	r9,r7
8000ece8:	14 97       	mov	r7,r10
8000ecea:	10 9a       	mov	r10,r8
8000ecec:	0e 98       	mov	r8,r7
8000ecee:	ee 1c 80 00 	eorh	r12,0x8000
8000ecf2:	f6 07 16 14 	lsr	r7,r11,0x14
8000ecf6:	ab 7b       	lsl	r11,0xb
8000ecf8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ecfc:	ab 7a       	lsl	r10,0xb
8000ecfe:	bf bb       	sbr	r11,0x1f
8000ed00:	f2 06 16 14 	lsr	r6,r9,0x14
8000ed04:	c4 40       	breq	8000ed8c <__avr32_f64_sub_opL_subnormal>
8000ed06:	ab 79       	lsl	r9,0xb
8000ed08:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ed0c:	ab 78       	lsl	r8,0xb
8000ed0e:	bf b9       	sbr	r9,0x1f

8000ed10 <__avr32_f64_sub_opL_subnormal_done>:
8000ed10:	e0 47 07 ff 	cp.w	r7,2047
8000ed14:	c4 f0       	breq	8000edb2 <__avr32_f64_sub_opH_nan_or_inf>
8000ed16:	0e 26       	rsub	r6,r7
8000ed18:	c1 20       	breq	8000ed3c <__avr32_f64_sub_shift_done>
8000ed1a:	ec 05 11 20 	rsub	r5,r6,32
8000ed1e:	e0 46 00 20 	cp.w	r6,32
8000ed22:	c7 c2       	brcc	8000ee1a <__avr32_f64_sub_longshift>
8000ed24:	f0 05 09 4e 	lsl	lr,r8,r5
8000ed28:	f2 05 09 45 	lsl	r5,r9,r5
8000ed2c:	f0 06 0a 48 	lsr	r8,r8,r6
8000ed30:	f2 06 0a 49 	lsr	r9,r9,r6
8000ed34:	0a 48       	or	r8,r5
8000ed36:	58 0e       	cp.w	lr,0
8000ed38:	5f 1e       	srne	lr
8000ed3a:	1c 48       	or	r8,lr

8000ed3c <__avr32_f64_sub_shift_done>:
8000ed3c:	10 1a       	sub	r10,r8
8000ed3e:	f6 09 01 4b 	sbc	r11,r11,r9
8000ed42:	f6 06 12 00 	clz	r6,r11
8000ed46:	c0 e0       	breq	8000ed62 <__avr32_f64_sub_longnormalize_done>
8000ed48:	c7 83       	brcs	8000ee38 <__avr32_f64_sub_longnormalize>
8000ed4a:	ec 0e 11 20 	rsub	lr,r6,32
8000ed4e:	f6 06 09 4b 	lsl	r11,r11,r6
8000ed52:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ed56:	1c 4b       	or	r11,lr
8000ed58:	f4 06 09 4a 	lsl	r10,r10,r6
8000ed5c:	0c 17       	sub	r7,r6
8000ed5e:	e0 8a 00 39 	brle	8000edd0 <__avr32_f64_sub_subnormal_result>

8000ed62 <__avr32_f64_sub_longnormalize_done>:
8000ed62:	f4 09 15 15 	lsl	r9,r10,0x15
8000ed66:	ab 9a       	lsr	r10,0xb
8000ed68:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ed6c:	ab 9b       	lsr	r11,0xb
8000ed6e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ed72:	18 4b       	or	r11,r12

8000ed74 <__avr32_f64_sub_round>:
8000ed74:	fc 17 80 00 	movh	r7,0x8000
8000ed78:	ed ba 00 00 	bld	r10,0x0
8000ed7c:	f7 b7 01 ff 	subne	r7,-1
8000ed80:	0e 39       	cp.w	r9,r7
8000ed82:	5f 29       	srhs	r9
8000ed84:	12 0a       	add	r10,r9
8000ed86:	5c 0b       	acr	r11
8000ed88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ed8c <__avr32_f64_sub_opL_subnormal>:
8000ed8c:	ab 79       	lsl	r9,0xb
8000ed8e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ed92:	ab 78       	lsl	r8,0xb
8000ed94:	f3 e8 10 0e 	or	lr,r9,r8
8000ed98:	f9 b6 01 01 	movne	r6,1
8000ed9c:	ee 0e 11 00 	rsub	lr,r7,0
8000eda0:	f9 b7 00 01 	moveq	r7,1
8000eda4:	ef bb 00 1f 	bst	r11,0x1f
8000eda8:	f7 ea 10 0e 	or	lr,r11,r10
8000edac:	f9 b7 00 00 	moveq	r7,0
8000edb0:	cb 0b       	rjmp	8000ed10 <__avr32_f64_sub_opL_subnormal_done>

8000edb2 <__avr32_f64_sub_opH_nan_or_inf>:
8000edb2:	bf db       	cbr	r11,0x1f
8000edb4:	f7 ea 10 0e 	or	lr,r11,r10
8000edb8:	c0 81       	brne	8000edc8 <__avr32_f64_sub_return_nan>
8000edba:	e0 46 07 ff 	cp.w	r6,2047
8000edbe:	c0 50       	breq	8000edc8 <__avr32_f64_sub_return_nan>
8000edc0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000edc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000edc8 <__avr32_f64_sub_return_nan>:
8000edc8:	3f fa       	mov	r10,-1
8000edca:	3f fb       	mov	r11,-1
8000edcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000edd0 <__avr32_f64_sub_subnormal_result>:
8000edd0:	5c 37       	neg	r7
8000edd2:	2f f7       	sub	r7,-1
8000edd4:	f1 b7 04 c0 	satu	r7,0x6
8000edd8:	e0 47 00 20 	cp.w	r7,32
8000eddc:	c1 14       	brge	8000edfe <__avr32_f64_sub_subnormal_result+0x2e>
8000edde:	ee 08 11 20 	rsub	r8,r7,32
8000ede2:	f4 08 09 49 	lsl	r9,r10,r8
8000ede6:	5f 16       	srne	r6
8000ede8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000edec:	0c 4a       	or	r10,r6
8000edee:	f6 08 09 49 	lsl	r9,r11,r8
8000edf2:	f5 e9 10 0a 	or	r10,r10,r9
8000edf6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000edfa:	30 07       	mov	r7,0
8000edfc:	cb 3b       	rjmp	8000ed62 <__avr32_f64_sub_longnormalize_done>
8000edfe:	ee 08 11 40 	rsub	r8,r7,64
8000ee02:	f6 08 09 49 	lsl	r9,r11,r8
8000ee06:	14 49       	or	r9,r10
8000ee08:	5f 16       	srne	r6
8000ee0a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ee0e:	0c 4a       	or	r10,r6
8000ee10:	30 0b       	mov	r11,0
8000ee12:	30 07       	mov	r7,0
8000ee14:	ca 7b       	rjmp	8000ed62 <__avr32_f64_sub_longnormalize_done>
8000ee16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ee1a <__avr32_f64_sub_longshift>:
8000ee1a:	f1 b6 04 c0 	satu	r6,0x6
8000ee1e:	f0 0e 17 00 	moveq	lr,r8
8000ee22:	c0 40       	breq	8000ee2a <__avr32_f64_sub_longshift+0x10>
8000ee24:	f2 05 09 4e 	lsl	lr,r9,r5
8000ee28:	10 4e       	or	lr,r8
8000ee2a:	f2 06 0a 48 	lsr	r8,r9,r6
8000ee2e:	30 09       	mov	r9,0
8000ee30:	58 0e       	cp.w	lr,0
8000ee32:	5f 1e       	srne	lr
8000ee34:	1c 48       	or	r8,lr
8000ee36:	c8 3b       	rjmp	8000ed3c <__avr32_f64_sub_shift_done>

8000ee38 <__avr32_f64_sub_longnormalize>:
8000ee38:	f4 06 12 00 	clz	r6,r10
8000ee3c:	f9 b7 03 00 	movlo	r7,0
8000ee40:	f9 b6 03 00 	movlo	r6,0
8000ee44:	f9 bc 03 00 	movlo	r12,0
8000ee48:	f7 b6 02 e0 	subhs	r6,-32
8000ee4c:	f4 06 09 4b 	lsl	r11,r10,r6
8000ee50:	30 0a       	mov	r10,0
8000ee52:	0c 17       	sub	r7,r6
8000ee54:	fe 9a ff be 	brle	8000edd0 <__avr32_f64_sub_subnormal_result>
8000ee58:	c8 5b       	rjmp	8000ed62 <__avr32_f64_sub_longnormalize_done>
8000ee5a:	d7 03       	nop

8000ee5c <__avr32_f64_add_from_sub>:
8000ee5c:	ee 19 80 00 	eorh	r9,0x8000

8000ee60 <__avr32_f64_add>:
8000ee60:	f7 e9 20 0c 	eor	r12,r11,r9
8000ee64:	fe 96 ff 2e 	brmi	8000ecc0 <__avr32_f64_sub_from_add>
8000ee68:	eb cd 40 e0 	pushm	r5-r7,lr
8000ee6c:	16 9c       	mov	r12,r11
8000ee6e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ee72:	bf db       	cbr	r11,0x1f
8000ee74:	bf d9       	cbr	r9,0x1f
8000ee76:	12 3b       	cp.w	r11,r9
8000ee78:	c0 72       	brcc	8000ee86 <__avr32_f64_add+0x26>
8000ee7a:	16 97       	mov	r7,r11
8000ee7c:	12 9b       	mov	r11,r9
8000ee7e:	0e 99       	mov	r9,r7
8000ee80:	14 97       	mov	r7,r10
8000ee82:	10 9a       	mov	r10,r8
8000ee84:	0e 98       	mov	r8,r7
8000ee86:	30 0e       	mov	lr,0
8000ee88:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ee8c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ee90:	b5 ab       	sbr	r11,0x14
8000ee92:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ee96:	c6 20       	breq	8000ef5a <__avr32_f64_add_op2_subnormal>
8000ee98:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ee9c:	b5 a9       	sbr	r9,0x14
8000ee9e:	e0 47 07 ff 	cp.w	r7,2047
8000eea2:	c2 80       	breq	8000eef2 <__avr32_f64_add_opH_nan_or_inf>
8000eea4:	0e 26       	rsub	r6,r7
8000eea6:	c1 20       	breq	8000eeca <__avr32_f64_add_shift_done>
8000eea8:	e0 46 00 36 	cp.w	r6,54
8000eeac:	c1 52       	brcc	8000eed6 <__avr32_f64_add_res_of_done>
8000eeae:	ec 05 11 20 	rsub	r5,r6,32
8000eeb2:	e0 46 00 20 	cp.w	r6,32
8000eeb6:	c3 52       	brcc	8000ef20 <__avr32_f64_add_longshift>
8000eeb8:	f0 05 09 4e 	lsl	lr,r8,r5
8000eebc:	f2 05 09 45 	lsl	r5,r9,r5
8000eec0:	f0 06 0a 48 	lsr	r8,r8,r6
8000eec4:	f2 06 0a 49 	lsr	r9,r9,r6
8000eec8:	0a 48       	or	r8,r5

8000eeca <__avr32_f64_add_shift_done>:
8000eeca:	10 0a       	add	r10,r8
8000eecc:	f6 09 00 4b 	adc	r11,r11,r9
8000eed0:	ed bb 00 15 	bld	r11,0x15
8000eed4:	c3 40       	breq	8000ef3c <__avr32_f64_add_res_of>

8000eed6 <__avr32_f64_add_res_of_done>:
8000eed6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000eeda:	18 4b       	or	r11,r12

8000eedc <__avr32_f64_add_round>:
8000eedc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000eee0:	18 4e       	or	lr,r12
8000eee2:	ee 1e 80 00 	eorh	lr,0x8000
8000eee6:	f1 be 04 20 	satu	lr,0x1
8000eeea:	1c 0a       	add	r10,lr
8000eeec:	5c 0b       	acr	r11
8000eeee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eef2 <__avr32_f64_add_opH_nan_or_inf>:
8000eef2:	b5 cb       	cbr	r11,0x14
8000eef4:	f7 ea 10 0e 	or	lr,r11,r10
8000eef8:	c1 01       	brne	8000ef18 <__avr32_f64_add_return_nan>
8000eefa:	e0 46 07 ff 	cp.w	r6,2047
8000eefe:	c0 30       	breq	8000ef04 <__avr32_f64_add_opL_nan_or_inf>
8000ef00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef04 <__avr32_f64_add_opL_nan_or_inf>:
8000ef04:	b5 c9       	cbr	r9,0x14
8000ef06:	f3 e8 10 0e 	or	lr,r9,r8
8000ef0a:	c0 71       	brne	8000ef18 <__avr32_f64_add_return_nan>
8000ef0c:	30 0a       	mov	r10,0
8000ef0e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000ef12:	18 4b       	or	r11,r12
8000ef14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef18 <__avr32_f64_add_return_nan>:
8000ef18:	3f fa       	mov	r10,-1
8000ef1a:	3f fb       	mov	r11,-1
8000ef1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef20 <__avr32_f64_add_longshift>:
8000ef20:	f1 b6 04 c0 	satu	r6,0x6
8000ef24:	f0 0e 17 00 	moveq	lr,r8
8000ef28:	c0 60       	breq	8000ef34 <__avr32_f64_add_longshift+0x14>
8000ef2a:	f2 05 09 4e 	lsl	lr,r9,r5
8000ef2e:	58 08       	cp.w	r8,0
8000ef30:	5f 18       	srne	r8
8000ef32:	10 4e       	or	lr,r8
8000ef34:	f2 06 0a 48 	lsr	r8,r9,r6
8000ef38:	30 09       	mov	r9,0
8000ef3a:	cc 8b       	rjmp	8000eeca <__avr32_f64_add_shift_done>

8000ef3c <__avr32_f64_add_res_of>:
8000ef3c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000ef40:	a1 9b       	lsr	r11,0x1
8000ef42:	5d 0a       	ror	r10
8000ef44:	5d 0e       	ror	lr
8000ef46:	2f f7       	sub	r7,-1
8000ef48:	e0 47 07 ff 	cp.w	r7,2047
8000ef4c:	f9 ba 00 00 	moveq	r10,0
8000ef50:	f9 bb 00 00 	moveq	r11,0
8000ef54:	f9 be 00 00 	moveq	lr,0
8000ef58:	cb fb       	rjmp	8000eed6 <__avr32_f64_add_res_of_done>

8000ef5a <__avr32_f64_add_op2_subnormal>:
8000ef5a:	30 16       	mov	r6,1
8000ef5c:	58 07       	cp.w	r7,0
8000ef5e:	ca 01       	brne	8000ee9e <__avr32_f64_add+0x3e>
8000ef60:	b5 cb       	cbr	r11,0x14
8000ef62:	10 0a       	add	r10,r8
8000ef64:	f6 09 00 4b 	adc	r11,r11,r9
8000ef68:	18 4b       	or	r11,r12
8000ef6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ef6e:	d7 03       	nop

8000ef70 <__avr32_f64_to_u32>:
8000ef70:	58 0b       	cp.w	r11,0
8000ef72:	5e 6d       	retmi	0

8000ef74 <__avr32_f64_to_s32>:
8000ef74:	f6 0c 15 01 	lsl	r12,r11,0x1
8000ef78:	b5 9c       	lsr	r12,0x15
8000ef7a:	e0 2c 03 ff 	sub	r12,1023
8000ef7e:	5e 3d       	retlo	0
8000ef80:	f8 0c 11 1f 	rsub	r12,r12,31
8000ef84:	16 99       	mov	r9,r11
8000ef86:	ab 7b       	lsl	r11,0xb
8000ef88:	bf bb       	sbr	r11,0x1f
8000ef8a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ef8e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ef92:	a1 79       	lsl	r9,0x1
8000ef94:	5e 2b       	reths	r11
8000ef96:	5c 3b       	neg	r11
8000ef98:	5e fb       	retal	r11

8000ef9a <__avr32_u32_to_f64>:
8000ef9a:	f8 cb 00 00 	sub	r11,r12,0
8000ef9e:	30 0c       	mov	r12,0
8000efa0:	c0 38       	rjmp	8000efa6 <__avr32_s32_to_f64+0x4>

8000efa2 <__avr32_s32_to_f64>:
8000efa2:	18 9b       	mov	r11,r12
8000efa4:	5c 4b       	abs	r11
8000efa6:	30 0a       	mov	r10,0
8000efa8:	5e 0b       	reteq	r11
8000efaa:	d4 01       	pushm	lr
8000efac:	e0 69 04 1e 	mov	r9,1054
8000efb0:	f6 08 12 00 	clz	r8,r11
8000efb4:	c1 70       	breq	8000efe2 <__avr32_s32_to_f64+0x40>
8000efb6:	c0 c3       	brcs	8000efce <__avr32_s32_to_f64+0x2c>
8000efb8:	f0 0e 11 20 	rsub	lr,r8,32
8000efbc:	f6 08 09 4b 	lsl	r11,r11,r8
8000efc0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000efc4:	1c 4b       	or	r11,lr
8000efc6:	f4 08 09 4a 	lsl	r10,r10,r8
8000efca:	10 19       	sub	r9,r8
8000efcc:	c0 b8       	rjmp	8000efe2 <__avr32_s32_to_f64+0x40>
8000efce:	f4 08 12 00 	clz	r8,r10
8000efd2:	f9 b8 03 00 	movlo	r8,0
8000efd6:	f7 b8 02 e0 	subhs	r8,-32
8000efda:	f4 08 09 4b 	lsl	r11,r10,r8
8000efde:	30 0a       	mov	r10,0
8000efe0:	10 19       	sub	r9,r8
8000efe2:	58 09       	cp.w	r9,0
8000efe4:	e0 89 00 30 	brgt	8000f044 <__avr32_s32_to_f64+0xa2>
8000efe8:	5c 39       	neg	r9
8000efea:	2f f9       	sub	r9,-1
8000efec:	e0 49 00 36 	cp.w	r9,54
8000eff0:	c0 43       	brcs	8000eff8 <__avr32_s32_to_f64+0x56>
8000eff2:	30 0b       	mov	r11,0
8000eff4:	30 0a       	mov	r10,0
8000eff6:	c2 68       	rjmp	8000f042 <__avr32_s32_to_f64+0xa0>
8000eff8:	2f 69       	sub	r9,-10
8000effa:	f2 08 11 20 	rsub	r8,r9,32
8000effe:	e0 49 00 20 	cp.w	r9,32
8000f002:	c0 b2       	brcc	8000f018 <__avr32_s32_to_f64+0x76>
8000f004:	f4 08 09 4e 	lsl	lr,r10,r8
8000f008:	f6 08 09 48 	lsl	r8,r11,r8
8000f00c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f010:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f014:	10 4b       	or	r11,r8
8000f016:	c0 88       	rjmp	8000f026 <__avr32_s32_to_f64+0x84>
8000f018:	f6 08 09 4e 	lsl	lr,r11,r8
8000f01c:	14 4e       	or	lr,r10
8000f01e:	16 9a       	mov	r10,r11
8000f020:	30 0b       	mov	r11,0
8000f022:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f026:	ed ba 00 00 	bld	r10,0x0
8000f02a:	c0 92       	brcc	8000f03c <__avr32_s32_to_f64+0x9a>
8000f02c:	1c 7e       	tst	lr,lr
8000f02e:	c0 41       	brne	8000f036 <__avr32_s32_to_f64+0x94>
8000f030:	ed ba 00 01 	bld	r10,0x1
8000f034:	c0 42       	brcc	8000f03c <__avr32_s32_to_f64+0x9a>
8000f036:	2f fa       	sub	r10,-1
8000f038:	f7 bb 02 ff 	subhs	r11,-1
8000f03c:	5c fc       	rol	r12
8000f03e:	5d 0b       	ror	r11
8000f040:	5d 0a       	ror	r10
8000f042:	d8 02       	popm	pc
8000f044:	e0 68 03 ff 	mov	r8,1023
8000f048:	ed ba 00 0b 	bld	r10,0xb
8000f04c:	f7 b8 00 ff 	subeq	r8,-1
8000f050:	10 0a       	add	r10,r8
8000f052:	5c 0b       	acr	r11
8000f054:	f7 b9 03 fe 	sublo	r9,-2
8000f058:	e0 49 07 ff 	cp.w	r9,2047
8000f05c:	c0 55       	brlt	8000f066 <__avr32_s32_to_f64+0xc4>
8000f05e:	30 0a       	mov	r10,0
8000f060:	fc 1b ff e0 	movh	r11,0xffe0
8000f064:	c0 c8       	rjmp	8000f07c <__floatsidf_return_op1>
8000f066:	ed bb 00 1f 	bld	r11,0x1f
8000f06a:	f7 b9 01 01 	subne	r9,1
8000f06e:	ab 9a       	lsr	r10,0xb
8000f070:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f074:	a1 7b       	lsl	r11,0x1
8000f076:	ab 9b       	lsr	r11,0xb
8000f078:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f07c <__floatsidf_return_op1>:
8000f07c:	a1 7c       	lsl	r12,0x1
8000f07e:	5d 0b       	ror	r11
8000f080:	d8 02       	popm	pc

8000f082 <__avr32_f64_cmp_eq>:
8000f082:	10 3a       	cp.w	r10,r8
8000f084:	f2 0b 13 00 	cpc	r11,r9
8000f088:	c0 80       	breq	8000f098 <__avr32_f64_cmp_eq+0x16>
8000f08a:	a1 7b       	lsl	r11,0x1
8000f08c:	a1 79       	lsl	r9,0x1
8000f08e:	14 4b       	or	r11,r10
8000f090:	12 4b       	or	r11,r9
8000f092:	10 4b       	or	r11,r8
8000f094:	5e 0f       	reteq	1
8000f096:	5e fd       	retal	0
8000f098:	a1 7b       	lsl	r11,0x1
8000f09a:	fc 1c ff e0 	movh	r12,0xffe0
8000f09e:	58 0a       	cp.w	r10,0
8000f0a0:	f8 0b 13 00 	cpc	r11,r12
8000f0a4:	5e 8f       	retls	1
8000f0a6:	5e fd       	retal	0

8000f0a8 <__avr32_f64_cmp_ge>:
8000f0a8:	1a de       	st.w	--sp,lr
8000f0aa:	1a d7       	st.w	--sp,r7
8000f0ac:	a1 7b       	lsl	r11,0x1
8000f0ae:	5f 3c       	srlo	r12
8000f0b0:	a1 79       	lsl	r9,0x1
8000f0b2:	5f 37       	srlo	r7
8000f0b4:	5c fc       	rol	r12
8000f0b6:	fc 1e ff e0 	movh	lr,0xffe0
8000f0ba:	58 0a       	cp.w	r10,0
8000f0bc:	fc 0b 13 00 	cpc	r11,lr
8000f0c0:	e0 8b 00 1d 	brhi	8000f0fa <__avr32_f64_cmp_ge+0x52>
8000f0c4:	58 08       	cp.w	r8,0
8000f0c6:	fc 09 13 00 	cpc	r9,lr
8000f0ca:	e0 8b 00 18 	brhi	8000f0fa <__avr32_f64_cmp_ge+0x52>
8000f0ce:	58 0b       	cp.w	r11,0
8000f0d0:	f5 ba 00 00 	subfeq	r10,0
8000f0d4:	c1 50       	breq	8000f0fe <__avr32_f64_cmp_ge+0x56>
8000f0d6:	1b 07       	ld.w	r7,sp++
8000f0d8:	1b 0e       	ld.w	lr,sp++
8000f0da:	58 3c       	cp.w	r12,3
8000f0dc:	c0 a0       	breq	8000f0f0 <__avr32_f64_cmp_ge+0x48>
8000f0de:	58 1c       	cp.w	r12,1
8000f0e0:	c0 33       	brcs	8000f0e6 <__avr32_f64_cmp_ge+0x3e>
8000f0e2:	5e 0f       	reteq	1
8000f0e4:	5e 1d       	retne	0
8000f0e6:	10 3a       	cp.w	r10,r8
8000f0e8:	f2 0b 13 00 	cpc	r11,r9
8000f0ec:	5e 2f       	reths	1
8000f0ee:	5e 3d       	retlo	0
8000f0f0:	14 38       	cp.w	r8,r10
8000f0f2:	f6 09 13 00 	cpc	r9,r11
8000f0f6:	5e 2f       	reths	1
8000f0f8:	5e 3d       	retlo	0
8000f0fa:	1b 07       	ld.w	r7,sp++
8000f0fc:	d8 0a       	popm	pc,r12=0
8000f0fe:	58 17       	cp.w	r7,1
8000f100:	5f 0c       	sreq	r12
8000f102:	58 09       	cp.w	r9,0
8000f104:	f5 b8 00 00 	subfeq	r8,0
8000f108:	1b 07       	ld.w	r7,sp++
8000f10a:	1b 0e       	ld.w	lr,sp++
8000f10c:	5e 0f       	reteq	1
8000f10e:	5e fc       	retal	r12

8000f110 <__avr32_f64_cmp_lt>:
8000f110:	1a de       	st.w	--sp,lr
8000f112:	1a d7       	st.w	--sp,r7
8000f114:	a1 7b       	lsl	r11,0x1
8000f116:	5f 3c       	srlo	r12
8000f118:	a1 79       	lsl	r9,0x1
8000f11a:	5f 37       	srlo	r7
8000f11c:	5c fc       	rol	r12
8000f11e:	fc 1e ff e0 	movh	lr,0xffe0
8000f122:	58 0a       	cp.w	r10,0
8000f124:	fc 0b 13 00 	cpc	r11,lr
8000f128:	e0 8b 00 1d 	brhi	8000f162 <__avr32_f64_cmp_lt+0x52>
8000f12c:	58 08       	cp.w	r8,0
8000f12e:	fc 09 13 00 	cpc	r9,lr
8000f132:	e0 8b 00 18 	brhi	8000f162 <__avr32_f64_cmp_lt+0x52>
8000f136:	58 0b       	cp.w	r11,0
8000f138:	f5 ba 00 00 	subfeq	r10,0
8000f13c:	c1 50       	breq	8000f166 <__avr32_f64_cmp_lt+0x56>
8000f13e:	1b 07       	ld.w	r7,sp++
8000f140:	1b 0e       	ld.w	lr,sp++
8000f142:	58 3c       	cp.w	r12,3
8000f144:	c0 a0       	breq	8000f158 <__avr32_f64_cmp_lt+0x48>
8000f146:	58 1c       	cp.w	r12,1
8000f148:	c0 33       	brcs	8000f14e <__avr32_f64_cmp_lt+0x3e>
8000f14a:	5e 0d       	reteq	0
8000f14c:	5e 1f       	retne	1
8000f14e:	10 3a       	cp.w	r10,r8
8000f150:	f2 0b 13 00 	cpc	r11,r9
8000f154:	5e 2d       	reths	0
8000f156:	5e 3f       	retlo	1
8000f158:	14 38       	cp.w	r8,r10
8000f15a:	f6 09 13 00 	cpc	r9,r11
8000f15e:	5e 2d       	reths	0
8000f160:	5e 3f       	retlo	1
8000f162:	1b 07       	ld.w	r7,sp++
8000f164:	d8 0a       	popm	pc,r12=0
8000f166:	58 17       	cp.w	r7,1
8000f168:	5f 1c       	srne	r12
8000f16a:	58 09       	cp.w	r9,0
8000f16c:	f5 b8 00 00 	subfeq	r8,0
8000f170:	1b 07       	ld.w	r7,sp++
8000f172:	1b 0e       	ld.w	lr,sp++
8000f174:	5e 0d       	reteq	0
8000f176:	5e fc       	retal	r12

8000f178 <__avr32_f64_div>:
8000f178:	eb cd 40 ff 	pushm	r0-r7,lr
8000f17c:	f7 e9 20 0e 	eor	lr,r11,r9
8000f180:	f6 07 16 14 	lsr	r7,r11,0x14
8000f184:	a9 7b       	lsl	r11,0x9
8000f186:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f18a:	a9 7a       	lsl	r10,0x9
8000f18c:	bd bb       	sbr	r11,0x1d
8000f18e:	e4 1b 3f ff 	andh	r11,0x3fff
8000f192:	ab d7       	cbr	r7,0xb
8000f194:	e0 80 00 cc 	breq	8000f32c <__avr32_f64_div_round_subnormal+0x54>
8000f198:	e0 47 07 ff 	cp.w	r7,2047
8000f19c:	e0 84 00 b5 	brge	8000f306 <__avr32_f64_div_round_subnormal+0x2e>
8000f1a0:	f2 06 16 14 	lsr	r6,r9,0x14
8000f1a4:	a9 79       	lsl	r9,0x9
8000f1a6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f1aa:	a9 78       	lsl	r8,0x9
8000f1ac:	bd b9       	sbr	r9,0x1d
8000f1ae:	e4 19 3f ff 	andh	r9,0x3fff
8000f1b2:	ab d6       	cbr	r6,0xb
8000f1b4:	e0 80 00 e2 	breq	8000f378 <__avr32_f64_div_round_subnormal+0xa0>
8000f1b8:	e0 46 07 ff 	cp.w	r6,2047
8000f1bc:	e0 84 00 b2 	brge	8000f320 <__avr32_f64_div_round_subnormal+0x48>
8000f1c0:	0c 17       	sub	r7,r6
8000f1c2:	fe 37 fc 01 	sub	r7,-1023
8000f1c6:	fc 1c 80 00 	movh	r12,0x8000
8000f1ca:	f8 03 16 01 	lsr	r3,r12,0x1
8000f1ce:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f1d2:	5c d4       	com	r4
8000f1d4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f1d8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f1dc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f1e0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f1e4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f1e8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f1ec:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f1f0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f1f4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f1f8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f1fc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f200:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f204:	ea 03 15 02 	lsl	r3,r5,0x2
8000f208:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f20c:	e4 09 07 40 	macu.d	r0,r2,r9
8000f210:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f214:	02 04       	add	r4,r1
8000f216:	5c 05       	acr	r5
8000f218:	a3 65       	lsl	r5,0x2
8000f21a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f21e:	a3 64       	lsl	r4,0x2
8000f220:	5c 34       	neg	r4
8000f222:	f8 05 01 45 	sbc	r5,r12,r5
8000f226:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f22a:	e4 05 07 40 	macu.d	r0,r2,r5
8000f22e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f232:	02 04       	add	r4,r1
8000f234:	5c 05       	acr	r5
8000f236:	ea 03 15 02 	lsl	r3,r5,0x2
8000f23a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f23e:	e8 02 15 02 	lsl	r2,r4,0x2
8000f242:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f246:	e4 09 07 40 	macu.d	r0,r2,r9
8000f24a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f24e:	02 04       	add	r4,r1
8000f250:	5c 05       	acr	r5
8000f252:	a3 65       	lsl	r5,0x2
8000f254:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f258:	a3 64       	lsl	r4,0x2
8000f25a:	5c 34       	neg	r4
8000f25c:	f8 05 01 45 	sbc	r5,r12,r5
8000f260:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f264:	e4 05 07 40 	macu.d	r0,r2,r5
8000f268:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f26c:	02 04       	add	r4,r1
8000f26e:	5c 05       	acr	r5
8000f270:	ea 03 15 02 	lsl	r3,r5,0x2
8000f274:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f278:	e8 02 15 02 	lsl	r2,r4,0x2
8000f27c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f280:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f284:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f288:	02 02       	add	r2,r1
8000f28a:	5c 03       	acr	r3
8000f28c:	ed b3 00 1c 	bld	r3,0x1c
8000f290:	c0 90       	breq	8000f2a2 <__avr32_f64_div+0x12a>
8000f292:	a1 72       	lsl	r2,0x1
8000f294:	5c f3       	rol	r3
8000f296:	20 17       	sub	r7,1
8000f298:	a3 9a       	lsr	r10,0x3
8000f29a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f29e:	a3 9b       	lsr	r11,0x3
8000f2a0:	c0 58       	rjmp	8000f2aa <__avr32_f64_div+0x132>
8000f2a2:	a5 8a       	lsr	r10,0x4
8000f2a4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f2a8:	a5 8b       	lsr	r11,0x4
8000f2aa:	58 07       	cp.w	r7,0
8000f2ac:	e0 8a 00 8b 	brle	8000f3c2 <__avr32_f64_div_res_subnormal>
8000f2b0:	e0 12 ff 00 	andl	r2,0xff00
8000f2b4:	e8 12 00 80 	orl	r2,0x80
8000f2b8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f2bc:	e4 09 07 40 	macu.d	r0,r2,r9
8000f2c0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f2c4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f2c8:	00 05       	add	r5,r0
8000f2ca:	f0 01 00 48 	adc	r8,r8,r1
8000f2ce:	5c 09       	acr	r9
8000f2d0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f2d4:	58 04       	cp.w	r4,0
8000f2d6:	5c 25       	cpc	r5

8000f2d8 <__avr32_f64_div_round_subnormal>:
8000f2d8:	f4 08 13 00 	cpc	r8,r10
8000f2dc:	f6 09 13 00 	cpc	r9,r11
8000f2e0:	5f 36       	srlo	r6
8000f2e2:	f8 06 17 00 	moveq	r6,r12
8000f2e6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f2ea:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f2ee:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f2f2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f2f6:	ed be 00 1f 	bld	lr,0x1f
8000f2fa:	ef bb 00 1f 	bst	r11,0x1f
8000f2fe:	0c 0a       	add	r10,r6
8000f300:	5c 0b       	acr	r11
8000f302:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f306:	e4 1b 00 0f 	andh	r11,0xf
8000f30a:	14 4b       	or	r11,r10
8000f30c:	e0 81 00 a7 	brne	8000f45a <__avr32_f64_div_res_subnormal+0x98>
8000f310:	f2 06 16 14 	lsr	r6,r9,0x14
8000f314:	ab d6       	cbr	r6,0xb
8000f316:	e0 46 07 ff 	cp.w	r6,2047
8000f31a:	e0 81 00 a4 	brne	8000f462 <__avr32_f64_div_res_subnormal+0xa0>
8000f31e:	c9 e8       	rjmp	8000f45a <__avr32_f64_div_res_subnormal+0x98>
8000f320:	e4 19 00 0f 	andh	r9,0xf
8000f324:	10 49       	or	r9,r8
8000f326:	e0 81 00 9a 	brne	8000f45a <__avr32_f64_div_res_subnormal+0x98>
8000f32a:	c9 28       	rjmp	8000f44e <__avr32_f64_div_res_subnormal+0x8c>
8000f32c:	a3 7b       	lsl	r11,0x3
8000f32e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f332:	a3 7a       	lsl	r10,0x3
8000f334:	f5 eb 10 04 	or	r4,r10,r11
8000f338:	e0 80 00 a0 	breq	8000f478 <__avr32_f64_div_op1_zero>
8000f33c:	f6 04 12 00 	clz	r4,r11
8000f340:	c1 70       	breq	8000f36e <__avr32_f64_div_round_subnormal+0x96>
8000f342:	c0 c3       	brcs	8000f35a <__avr32_f64_div_round_subnormal+0x82>
8000f344:	e8 05 11 20 	rsub	r5,r4,32
8000f348:	f6 04 09 4b 	lsl	r11,r11,r4
8000f34c:	f4 05 0a 45 	lsr	r5,r10,r5
8000f350:	0a 4b       	or	r11,r5
8000f352:	f4 04 09 4a 	lsl	r10,r10,r4
8000f356:	08 17       	sub	r7,r4
8000f358:	c0 b8       	rjmp	8000f36e <__avr32_f64_div_round_subnormal+0x96>
8000f35a:	f4 04 12 00 	clz	r4,r10
8000f35e:	f9 b4 03 00 	movlo	r4,0
8000f362:	f7 b4 02 e0 	subhs	r4,-32
8000f366:	f4 04 09 4b 	lsl	r11,r10,r4
8000f36a:	30 0a       	mov	r10,0
8000f36c:	08 17       	sub	r7,r4
8000f36e:	a3 8a       	lsr	r10,0x2
8000f370:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f374:	a3 8b       	lsr	r11,0x2
8000f376:	c1 1b       	rjmp	8000f198 <__avr32_f64_div+0x20>
8000f378:	a3 79       	lsl	r9,0x3
8000f37a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f37e:	a3 78       	lsl	r8,0x3
8000f380:	f3 e8 10 04 	or	r4,r9,r8
8000f384:	c6 f0       	breq	8000f462 <__avr32_f64_div_res_subnormal+0xa0>
8000f386:	f2 04 12 00 	clz	r4,r9
8000f38a:	c1 70       	breq	8000f3b8 <__avr32_f64_div_round_subnormal+0xe0>
8000f38c:	c0 c3       	brcs	8000f3a4 <__avr32_f64_div_round_subnormal+0xcc>
8000f38e:	e8 05 11 20 	rsub	r5,r4,32
8000f392:	f2 04 09 49 	lsl	r9,r9,r4
8000f396:	f0 05 0a 45 	lsr	r5,r8,r5
8000f39a:	0a 49       	or	r9,r5
8000f39c:	f0 04 09 48 	lsl	r8,r8,r4
8000f3a0:	08 16       	sub	r6,r4
8000f3a2:	c0 b8       	rjmp	8000f3b8 <__avr32_f64_div_round_subnormal+0xe0>
8000f3a4:	f0 04 12 00 	clz	r4,r8
8000f3a8:	f9 b4 03 00 	movlo	r4,0
8000f3ac:	f7 b4 02 e0 	subhs	r4,-32
8000f3b0:	f0 04 09 49 	lsl	r9,r8,r4
8000f3b4:	30 08       	mov	r8,0
8000f3b6:	08 16       	sub	r6,r4
8000f3b8:	a3 88       	lsr	r8,0x2
8000f3ba:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f3be:	a3 89       	lsr	r9,0x2
8000f3c0:	cf ca       	rjmp	8000f1b8 <__avr32_f64_div+0x40>

8000f3c2 <__avr32_f64_div_res_subnormal>:
8000f3c2:	5c 37       	neg	r7
8000f3c4:	2f f7       	sub	r7,-1
8000f3c6:	f1 b7 04 c0 	satu	r7,0x6
8000f3ca:	e0 47 00 20 	cp.w	r7,32
8000f3ce:	c1 54       	brge	8000f3f8 <__avr32_f64_div_res_subnormal+0x36>
8000f3d0:	ee 06 11 20 	rsub	r6,r7,32
8000f3d4:	e4 07 0a 42 	lsr	r2,r2,r7
8000f3d8:	e6 06 09 4c 	lsl	r12,r3,r6
8000f3dc:	18 42       	or	r2,r12
8000f3de:	e6 07 0a 43 	lsr	r3,r3,r7
8000f3e2:	f4 06 09 41 	lsl	r1,r10,r6
8000f3e6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f3ea:	f6 06 09 4c 	lsl	r12,r11,r6
8000f3ee:	18 4a       	or	r10,r12
8000f3f0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000f3f4:	30 00       	mov	r0,0
8000f3f6:	c1 58       	rjmp	8000f420 <__avr32_f64_div_res_subnormal+0x5e>
8000f3f8:	ee 06 11 20 	rsub	r6,r7,32
8000f3fc:	f9 b0 00 00 	moveq	r0,0
8000f400:	f9 bc 00 00 	moveq	r12,0
8000f404:	c0 50       	breq	8000f40e <__avr32_f64_div_res_subnormal+0x4c>
8000f406:	f4 06 09 40 	lsl	r0,r10,r6
8000f40a:	f6 06 09 4c 	lsl	r12,r11,r6
8000f40e:	e6 07 0a 42 	lsr	r2,r3,r7
8000f412:	30 03       	mov	r3,0
8000f414:	f4 07 0a 41 	lsr	r1,r10,r7
8000f418:	18 41       	or	r1,r12
8000f41a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f41e:	30 0b       	mov	r11,0
8000f420:	e0 12 ff 00 	andl	r2,0xff00
8000f424:	e8 12 00 80 	orl	r2,0x80
8000f428:	e6 08 06 46 	mulu.d	r6,r3,r8
8000f42c:	e4 09 07 46 	macu.d	r6,r2,r9
8000f430:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f434:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f438:	0c 05       	add	r5,r6
8000f43a:	f0 07 00 48 	adc	r8,r8,r7
8000f43e:	5c 09       	acr	r9
8000f440:	30 07       	mov	r7,0
8000f442:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f446:	00 34       	cp.w	r4,r0
8000f448:	e2 05 13 00 	cpc	r5,r1
8000f44c:	c4 6b       	rjmp	8000f2d8 <__avr32_f64_div_round_subnormal>
8000f44e:	1c 9b       	mov	r11,lr
8000f450:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f454:	30 0a       	mov	r10,0
8000f456:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f45a:	3f fb       	mov	r11,-1
8000f45c:	30 0a       	mov	r10,0
8000f45e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f462:	f5 eb 10 04 	or	r4,r10,r11
8000f466:	c0 90       	breq	8000f478 <__avr32_f64_div_op1_zero>
8000f468:	1c 9b       	mov	r11,lr
8000f46a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f46e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000f472:	30 0a       	mov	r10,0
8000f474:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000f478 <__avr32_f64_div_op1_zero>:
8000f478:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000f47c:	ce f0       	breq	8000f45a <__avr32_f64_div_res_subnormal+0x98>
8000f47e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000f482:	e0 44 07 ff 	cp.w	r4,2047
8000f486:	ce 41       	brne	8000f44e <__avr32_f64_div_res_subnormal+0x8c>
8000f488:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000f48c:	ce 10       	breq	8000f44e <__avr32_f64_div_res_subnormal+0x8c>
8000f48e:	ce 6b       	rjmp	8000f45a <__avr32_f64_div_res_subnormal+0x98>

8000f490 <__avr32_udiv64>:
8000f490:	d4 31       	pushm	r0-r7,lr
8000f492:	1a 97       	mov	r7,sp
8000f494:	20 3d       	sub	sp,12
8000f496:	10 9c       	mov	r12,r8
8000f498:	12 9e       	mov	lr,r9
8000f49a:	14 93       	mov	r3,r10
8000f49c:	58 09       	cp.w	r9,0
8000f49e:	e0 81 00 bd 	brne	8000f618 <__avr32_udiv64+0x188>
8000f4a2:	16 38       	cp.w	r8,r11
8000f4a4:	e0 88 00 40 	brls	8000f524 <__avr32_udiv64+0x94>
8000f4a8:	f0 08 12 00 	clz	r8,r8
8000f4ac:	c0 d0       	breq	8000f4c6 <__avr32_udiv64+0x36>
8000f4ae:	f6 08 09 4b 	lsl	r11,r11,r8
8000f4b2:	f0 09 11 20 	rsub	r9,r8,32
8000f4b6:	f8 08 09 4c 	lsl	r12,r12,r8
8000f4ba:	f4 09 0a 49 	lsr	r9,r10,r9
8000f4be:	f4 08 09 43 	lsl	r3,r10,r8
8000f4c2:	f3 eb 10 0b 	or	r11,r9,r11
8000f4c6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000f4ca:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000f4ce:	f6 0e 0d 00 	divu	r0,r11,lr
8000f4d2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f4d6:	00 99       	mov	r9,r0
8000f4d8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f4dc:	e0 0a 02 48 	mul	r8,r0,r10
8000f4e0:	10 3b       	cp.w	r11,r8
8000f4e2:	c0 a2       	brcc	8000f4f6 <__avr32_udiv64+0x66>
8000f4e4:	20 19       	sub	r9,1
8000f4e6:	18 0b       	add	r11,r12
8000f4e8:	18 3b       	cp.w	r11,r12
8000f4ea:	c0 63       	brcs	8000f4f6 <__avr32_udiv64+0x66>
8000f4ec:	10 3b       	cp.w	r11,r8
8000f4ee:	f7 b9 03 01 	sublo	r9,1
8000f4f2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f4f6:	f6 08 01 01 	sub	r1,r11,r8
8000f4fa:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f4fe:	e2 0e 0d 00 	divu	r0,r1,lr
8000f502:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f506:	00 98       	mov	r8,r0
8000f508:	e0 0a 02 4a 	mul	r10,r0,r10
8000f50c:	14 33       	cp.w	r3,r10
8000f50e:	c0 82       	brcc	8000f51e <__avr32_udiv64+0x8e>
8000f510:	20 18       	sub	r8,1
8000f512:	18 03       	add	r3,r12
8000f514:	18 33       	cp.w	r3,r12
8000f516:	c0 43       	brcs	8000f51e <__avr32_udiv64+0x8e>
8000f518:	14 33       	cp.w	r3,r10
8000f51a:	f7 b8 03 01 	sublo	r8,1
8000f51e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000f522:	cd f8       	rjmp	8000f6e0 <__avr32_udiv64+0x250>
8000f524:	58 08       	cp.w	r8,0
8000f526:	c0 51       	brne	8000f530 <__avr32_udiv64+0xa0>
8000f528:	30 19       	mov	r9,1
8000f52a:	f2 08 0d 08 	divu	r8,r9,r8
8000f52e:	10 9c       	mov	r12,r8
8000f530:	f8 06 12 00 	clz	r6,r12
8000f534:	c0 41       	brne	8000f53c <__avr32_udiv64+0xac>
8000f536:	18 1b       	sub	r11,r12
8000f538:	30 19       	mov	r9,1
8000f53a:	c4 08       	rjmp	8000f5ba <__avr32_udiv64+0x12a>
8000f53c:	ec 01 11 20 	rsub	r1,r6,32
8000f540:	f4 01 0a 49 	lsr	r9,r10,r1
8000f544:	f8 06 09 4c 	lsl	r12,r12,r6
8000f548:	f6 06 09 48 	lsl	r8,r11,r6
8000f54c:	f6 01 0a 41 	lsr	r1,r11,r1
8000f550:	f3 e8 10 08 	or	r8,r9,r8
8000f554:	f8 03 16 10 	lsr	r3,r12,0x10
8000f558:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f55c:	e2 03 0d 00 	divu	r0,r1,r3
8000f560:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f564:	00 9e       	mov	lr,r0
8000f566:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f56a:	e0 05 02 49 	mul	r9,r0,r5
8000f56e:	12 3b       	cp.w	r11,r9
8000f570:	c0 a2       	brcc	8000f584 <__avr32_udiv64+0xf4>
8000f572:	20 1e       	sub	lr,1
8000f574:	18 0b       	add	r11,r12
8000f576:	18 3b       	cp.w	r11,r12
8000f578:	c0 63       	brcs	8000f584 <__avr32_udiv64+0xf4>
8000f57a:	12 3b       	cp.w	r11,r9
8000f57c:	f7 be 03 01 	sublo	lr,1
8000f580:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f584:	12 1b       	sub	r11,r9
8000f586:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000f58a:	f6 03 0d 02 	divu	r2,r11,r3
8000f58e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000f592:	04 99       	mov	r9,r2
8000f594:	e4 05 02 4b 	mul	r11,r2,r5
8000f598:	16 38       	cp.w	r8,r11
8000f59a:	c0 a2       	brcc	8000f5ae <__avr32_udiv64+0x11e>
8000f59c:	20 19       	sub	r9,1
8000f59e:	18 08       	add	r8,r12
8000f5a0:	18 38       	cp.w	r8,r12
8000f5a2:	c0 63       	brcs	8000f5ae <__avr32_udiv64+0x11e>
8000f5a4:	16 38       	cp.w	r8,r11
8000f5a6:	f7 b9 03 01 	sublo	r9,1
8000f5aa:	f1 dc e3 08 	addcs	r8,r8,r12
8000f5ae:	f4 06 09 43 	lsl	r3,r10,r6
8000f5b2:	f0 0b 01 0b 	sub	r11,r8,r11
8000f5b6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000f5ba:	f8 06 16 10 	lsr	r6,r12,0x10
8000f5be:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000f5c2:	f6 06 0d 00 	divu	r0,r11,r6
8000f5c6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f5ca:	00 9a       	mov	r10,r0
8000f5cc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f5d0:	e0 0e 02 48 	mul	r8,r0,lr
8000f5d4:	10 3b       	cp.w	r11,r8
8000f5d6:	c0 a2       	brcc	8000f5ea <__avr32_udiv64+0x15a>
8000f5d8:	20 1a       	sub	r10,1
8000f5da:	18 0b       	add	r11,r12
8000f5dc:	18 3b       	cp.w	r11,r12
8000f5de:	c0 63       	brcs	8000f5ea <__avr32_udiv64+0x15a>
8000f5e0:	10 3b       	cp.w	r11,r8
8000f5e2:	f7 ba 03 01 	sublo	r10,1
8000f5e6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f5ea:	f6 08 01 01 	sub	r1,r11,r8
8000f5ee:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f5f2:	e2 06 0d 00 	divu	r0,r1,r6
8000f5f6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f5fa:	00 98       	mov	r8,r0
8000f5fc:	e0 0e 02 4b 	mul	r11,r0,lr
8000f600:	16 33       	cp.w	r3,r11
8000f602:	c0 82       	brcc	8000f612 <__avr32_udiv64+0x182>
8000f604:	20 18       	sub	r8,1
8000f606:	18 03       	add	r3,r12
8000f608:	18 33       	cp.w	r3,r12
8000f60a:	c0 43       	brcs	8000f612 <__avr32_udiv64+0x182>
8000f60c:	16 33       	cp.w	r3,r11
8000f60e:	f7 b8 03 01 	sublo	r8,1
8000f612:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000f616:	c6 98       	rjmp	8000f6e8 <__avr32_udiv64+0x258>
8000f618:	16 39       	cp.w	r9,r11
8000f61a:	e0 8b 00 65 	brhi	8000f6e4 <__avr32_udiv64+0x254>
8000f61e:	f2 09 12 00 	clz	r9,r9
8000f622:	c0 b1       	brne	8000f638 <__avr32_udiv64+0x1a8>
8000f624:	10 3a       	cp.w	r10,r8
8000f626:	5f 2a       	srhs	r10
8000f628:	1c 3b       	cp.w	r11,lr
8000f62a:	5f b8       	srhi	r8
8000f62c:	10 4a       	or	r10,r8
8000f62e:	f2 0a 18 00 	cp.b	r10,r9
8000f632:	c5 90       	breq	8000f6e4 <__avr32_udiv64+0x254>
8000f634:	30 18       	mov	r8,1
8000f636:	c5 98       	rjmp	8000f6e8 <__avr32_udiv64+0x258>
8000f638:	f0 09 09 46 	lsl	r6,r8,r9
8000f63c:	f2 03 11 20 	rsub	r3,r9,32
8000f640:	fc 09 09 4e 	lsl	lr,lr,r9
8000f644:	f0 03 0a 48 	lsr	r8,r8,r3
8000f648:	f6 09 09 4c 	lsl	r12,r11,r9
8000f64c:	f4 03 0a 42 	lsr	r2,r10,r3
8000f650:	ef 46 ff f4 	st.w	r7[-12],r6
8000f654:	f6 03 0a 43 	lsr	r3,r11,r3
8000f658:	18 42       	or	r2,r12
8000f65a:	f1 ee 10 0c 	or	r12,r8,lr
8000f65e:	f8 01 16 10 	lsr	r1,r12,0x10
8000f662:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f666:	e6 01 0d 04 	divu	r4,r3,r1
8000f66a:	e4 03 16 10 	lsr	r3,r2,0x10
8000f66e:	08 9e       	mov	lr,r4
8000f670:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000f674:	e8 06 02 48 	mul	r8,r4,r6
8000f678:	10 33       	cp.w	r3,r8
8000f67a:	c0 a2       	brcc	8000f68e <__avr32_udiv64+0x1fe>
8000f67c:	20 1e       	sub	lr,1
8000f67e:	18 03       	add	r3,r12
8000f680:	18 33       	cp.w	r3,r12
8000f682:	c0 63       	brcs	8000f68e <__avr32_udiv64+0x1fe>
8000f684:	10 33       	cp.w	r3,r8
8000f686:	f7 be 03 01 	sublo	lr,1
8000f68a:	e7 dc e3 03 	addcs	r3,r3,r12
8000f68e:	10 13       	sub	r3,r8
8000f690:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000f694:	e6 01 0d 00 	divu	r0,r3,r1
8000f698:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f69c:	00 98       	mov	r8,r0
8000f69e:	e0 06 02 46 	mul	r6,r0,r6
8000f6a2:	0c 3b       	cp.w	r11,r6
8000f6a4:	c0 a2       	brcc	8000f6b8 <__avr32_udiv64+0x228>
8000f6a6:	20 18       	sub	r8,1
8000f6a8:	18 0b       	add	r11,r12
8000f6aa:	18 3b       	cp.w	r11,r12
8000f6ac:	c0 63       	brcs	8000f6b8 <__avr32_udiv64+0x228>
8000f6ae:	0c 3b       	cp.w	r11,r6
8000f6b0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f6b4:	f7 b8 03 01 	sublo	r8,1
8000f6b8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000f6bc:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000f6c0:	0c 1b       	sub	r11,r6
8000f6c2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000f6c6:	06 95       	mov	r5,r3
8000f6c8:	16 35       	cp.w	r5,r11
8000f6ca:	e0 8b 00 0a 	brhi	8000f6de <__avr32_udiv64+0x24e>
8000f6ce:	5f 0b       	sreq	r11
8000f6d0:	f4 09 09 49 	lsl	r9,r10,r9
8000f6d4:	12 32       	cp.w	r2,r9
8000f6d6:	5f b9       	srhi	r9
8000f6d8:	f7 e9 00 09 	and	r9,r11,r9
8000f6dc:	c0 60       	breq	8000f6e8 <__avr32_udiv64+0x258>
8000f6de:	20 18       	sub	r8,1
8000f6e0:	30 09       	mov	r9,0
8000f6e2:	c0 38       	rjmp	8000f6e8 <__avr32_udiv64+0x258>
8000f6e4:	30 09       	mov	r9,0
8000f6e6:	12 98       	mov	r8,r9
8000f6e8:	10 9a       	mov	r10,r8
8000f6ea:	12 93       	mov	r3,r9
8000f6ec:	10 92       	mov	r2,r8
8000f6ee:	12 9b       	mov	r11,r9
8000f6f0:	2f dd       	sub	sp,-12
8000f6f2:	d8 32       	popm	r0-r7,pc

8000f6f4 <__avr32_umod64>:
8000f6f4:	d4 31       	pushm	r0-r7,lr
8000f6f6:	1a 97       	mov	r7,sp
8000f6f8:	20 3d       	sub	sp,12
8000f6fa:	10 9c       	mov	r12,r8
8000f6fc:	12 95       	mov	r5,r9
8000f6fe:	14 9e       	mov	lr,r10
8000f700:	16 91       	mov	r1,r11
8000f702:	16 96       	mov	r6,r11
8000f704:	58 09       	cp.w	r9,0
8000f706:	e0 81 00 81 	brne	8000f808 <__avr32_umod64+0x114>
8000f70a:	16 38       	cp.w	r8,r11
8000f70c:	e0 88 00 12 	brls	8000f730 <__avr32_umod64+0x3c>
8000f710:	f0 08 12 00 	clz	r8,r8
8000f714:	c4 e0       	breq	8000f7b0 <__avr32_umod64+0xbc>
8000f716:	f6 08 09 46 	lsl	r6,r11,r8
8000f71a:	f8 08 09 4c 	lsl	r12,r12,r8
8000f71e:	f0 0b 11 20 	rsub	r11,r8,32
8000f722:	f4 08 09 4e 	lsl	lr,r10,r8
8000f726:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000f72a:	f7 e6 10 06 	or	r6,r11,r6
8000f72e:	c4 18       	rjmp	8000f7b0 <__avr32_umod64+0xbc>
8000f730:	58 08       	cp.w	r8,0
8000f732:	c0 51       	brne	8000f73c <__avr32_umod64+0x48>
8000f734:	30 19       	mov	r9,1
8000f736:	f2 08 0d 08 	divu	r8,r9,r8
8000f73a:	10 9c       	mov	r12,r8
8000f73c:	f8 08 12 00 	clz	r8,r12
8000f740:	c0 31       	brne	8000f746 <__avr32_umod64+0x52>
8000f742:	18 16       	sub	r6,r12
8000f744:	c3 68       	rjmp	8000f7b0 <__avr32_umod64+0xbc>
8000f746:	f0 03 11 20 	rsub	r3,r8,32
8000f74a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000f74e:	f8 08 09 4c 	lsl	r12,r12,r8
8000f752:	ec 08 09 49 	lsl	r9,r6,r8
8000f756:	ec 03 0a 43 	lsr	r3,r6,r3
8000f75a:	f7 e9 10 09 	or	r9,r11,r9
8000f75e:	f8 05 16 10 	lsr	r5,r12,0x10
8000f762:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f766:	e6 05 0d 02 	divu	r2,r3,r5
8000f76a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000f76e:	ec 02 02 4b 	mul	r11,r6,r2
8000f772:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000f776:	16 3e       	cp.w	lr,r11
8000f778:	c0 72       	brcc	8000f786 <__avr32_umod64+0x92>
8000f77a:	18 0e       	add	lr,r12
8000f77c:	18 3e       	cp.w	lr,r12
8000f77e:	c0 43       	brcs	8000f786 <__avr32_umod64+0x92>
8000f780:	16 3e       	cp.w	lr,r11
8000f782:	fd dc e3 0e 	addcs	lr,lr,r12
8000f786:	fc 0b 01 03 	sub	r3,lr,r11
8000f78a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000f78e:	e6 05 0d 02 	divu	r2,r3,r5
8000f792:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f796:	a5 36       	mul	r6,r2
8000f798:	0c 39       	cp.w	r9,r6
8000f79a:	c0 72       	brcc	8000f7a8 <__avr32_umod64+0xb4>
8000f79c:	18 09       	add	r9,r12
8000f79e:	18 39       	cp.w	r9,r12
8000f7a0:	c0 43       	brcs	8000f7a8 <__avr32_umod64+0xb4>
8000f7a2:	0c 39       	cp.w	r9,r6
8000f7a4:	f3 dc e3 09 	addcs	r9,r9,r12
8000f7a8:	f2 06 01 06 	sub	r6,r9,r6
8000f7ac:	f4 08 09 4e 	lsl	lr,r10,r8
8000f7b0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000f7b4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f7b8:	ec 0a 0d 02 	divu	r2,r6,r10
8000f7bc:	fc 09 16 10 	lsr	r9,lr,0x10
8000f7c0:	ea 02 02 4b 	mul	r11,r5,r2
8000f7c4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f7c8:	16 39       	cp.w	r9,r11
8000f7ca:	c0 72       	brcc	8000f7d8 <__avr32_umod64+0xe4>
8000f7cc:	18 09       	add	r9,r12
8000f7ce:	18 39       	cp.w	r9,r12
8000f7d0:	c0 43       	brcs	8000f7d8 <__avr32_umod64+0xe4>
8000f7d2:	16 39       	cp.w	r9,r11
8000f7d4:	f3 dc e3 09 	addcs	r9,r9,r12
8000f7d8:	f2 0b 01 0b 	sub	r11,r9,r11
8000f7dc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f7e0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000f7e4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000f7e8:	ea 0a 02 4a 	mul	r10,r5,r10
8000f7ec:	14 3e       	cp.w	lr,r10
8000f7ee:	c0 72       	brcc	8000f7fc <__avr32_umod64+0x108>
8000f7f0:	18 0e       	add	lr,r12
8000f7f2:	18 3e       	cp.w	lr,r12
8000f7f4:	c0 43       	brcs	8000f7fc <__avr32_umod64+0x108>
8000f7f6:	14 3e       	cp.w	lr,r10
8000f7f8:	fd dc e3 0e 	addcs	lr,lr,r12
8000f7fc:	fc 0a 01 0a 	sub	r10,lr,r10
8000f800:	30 0b       	mov	r11,0
8000f802:	f4 08 0a 4a 	lsr	r10,r10,r8
8000f806:	c7 b8       	rjmp	8000f8fc <__avr32_umod64+0x208>
8000f808:	16 39       	cp.w	r9,r11
8000f80a:	e0 8b 00 79 	brhi	8000f8fc <__avr32_umod64+0x208>
8000f80e:	f2 09 12 00 	clz	r9,r9
8000f812:	c1 21       	brne	8000f836 <__avr32_umod64+0x142>
8000f814:	10 3a       	cp.w	r10,r8
8000f816:	5f 2b       	srhs	r11
8000f818:	0a 31       	cp.w	r1,r5
8000f81a:	5f ba       	srhi	r10
8000f81c:	f7 ea 10 0a 	or	r10,r11,r10
8000f820:	f2 0a 18 00 	cp.b	r10,r9
8000f824:	c0 60       	breq	8000f830 <__avr32_umod64+0x13c>
8000f826:	fc 08 01 0c 	sub	r12,lr,r8
8000f82a:	e2 05 01 46 	sbc	r6,r1,r5
8000f82e:	18 9e       	mov	lr,r12
8000f830:	0c 9b       	mov	r11,r6
8000f832:	1c 9a       	mov	r10,lr
8000f834:	c6 48       	rjmp	8000f8fc <__avr32_umod64+0x208>
8000f836:	ea 09 09 4c 	lsl	r12,r5,r9
8000f83a:	f2 06 11 20 	rsub	r6,r9,32
8000f83e:	f6 09 09 4b 	lsl	r11,r11,r9
8000f842:	f0 09 09 42 	lsl	r2,r8,r9
8000f846:	ef 46 ff f4 	st.w	r7[-12],r6
8000f84a:	f0 06 0a 48 	lsr	r8,r8,r6
8000f84e:	18 48       	or	r8,r12
8000f850:	e2 06 0a 4c 	lsr	r12,r1,r6
8000f854:	f4 09 09 43 	lsl	r3,r10,r9
8000f858:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000f85c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000f860:	16 4a       	or	r10,r11
8000f862:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f866:	f8 0b 0d 04 	divu	r4,r12,r11
8000f86a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000f86e:	08 91       	mov	r1,r4
8000f870:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000f874:	e8 0e 02 46 	mul	r6,r4,lr
8000f878:	0c 3c       	cp.w	r12,r6
8000f87a:	c0 a2       	brcc	8000f88e <__avr32_umod64+0x19a>
8000f87c:	20 11       	sub	r1,1
8000f87e:	10 0c       	add	r12,r8
8000f880:	10 3c       	cp.w	r12,r8
8000f882:	c0 63       	brcs	8000f88e <__avr32_umod64+0x19a>
8000f884:	0c 3c       	cp.w	r12,r6
8000f886:	f7 b1 03 01 	sublo	r1,1
8000f88a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000f88e:	0c 1c       	sub	r12,r6
8000f890:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000f894:	f8 0b 0d 04 	divu	r4,r12,r11
8000f898:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000f89c:	08 96       	mov	r6,r4
8000f89e:	e8 0e 02 4e 	mul	lr,r4,lr
8000f8a2:	1c 3b       	cp.w	r11,lr
8000f8a4:	c0 a2       	brcc	8000f8b8 <__avr32_umod64+0x1c4>
8000f8a6:	20 16       	sub	r6,1
8000f8a8:	10 0b       	add	r11,r8
8000f8aa:	10 3b       	cp.w	r11,r8
8000f8ac:	c0 63       	brcs	8000f8b8 <__avr32_umod64+0x1c4>
8000f8ae:	1c 3b       	cp.w	r11,lr
8000f8b0:	f7 b6 03 01 	sublo	r6,1
8000f8b4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000f8b8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000f8bc:	1c 1b       	sub	r11,lr
8000f8be:	e2 02 06 40 	mulu.d	r0,r1,r2
8000f8c2:	00 9e       	mov	lr,r0
8000f8c4:	02 9c       	mov	r12,r1
8000f8c6:	16 3c       	cp.w	r12,r11
8000f8c8:	e0 8b 00 08 	brhi	8000f8d8 <__avr32_umod64+0x1e4>
8000f8cc:	5f 06       	sreq	r6
8000f8ce:	06 30       	cp.w	r0,r3
8000f8d0:	5f ba       	srhi	r10
8000f8d2:	ed ea 00 0a 	and	r10,r6,r10
8000f8d6:	c0 60       	breq	8000f8e2 <__avr32_umod64+0x1ee>
8000f8d8:	fc 02 01 04 	sub	r4,lr,r2
8000f8dc:	f8 08 01 4c 	sbc	r12,r12,r8
8000f8e0:	08 9e       	mov	lr,r4
8000f8e2:	e6 0e 01 0a 	sub	r10,r3,lr
8000f8e6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000f8ea:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000f8ee:	f8 09 0a 4b 	lsr	r11,r12,r9
8000f8f2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f8f6:	f8 01 09 4c 	lsl	r12,r12,r1
8000f8fa:	18 4a       	or	r10,r12
8000f8fc:	2f dd       	sub	sp,-12
8000f8fe:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000fa00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000fa00:	c0 08       	rjmp	8000fa00 <_evba>
	...

8000fa04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000fa04:	c0 08       	rjmp	8000fa04 <_handle_TLB_Multiple_Hit>
	...

8000fa08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000fa08:	c0 08       	rjmp	8000fa08 <_handle_Bus_Error_Data_Fetch>
	...

8000fa0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000fa0c:	c0 08       	rjmp	8000fa0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000fa10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000fa10:	c0 08       	rjmp	8000fa10 <_handle_NMI>
	...

8000fa14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000fa14:	c0 08       	rjmp	8000fa14 <_handle_Instruction_Address>
	...

8000fa18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000fa18:	c0 08       	rjmp	8000fa18 <_handle_ITLB_Protection>
	...

8000fa1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000fa1c:	c0 08       	rjmp	8000fa1c <_handle_Breakpoint>
	...

8000fa20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000fa20:	c0 08       	rjmp	8000fa20 <_handle_Illegal_Opcode>
	...

8000fa24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000fa24:	c0 08       	rjmp	8000fa24 <_handle_Unimplemented_Instruction>
	...

8000fa28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000fa28:	c0 08       	rjmp	8000fa28 <_handle_Privilege_Violation>
	...

8000fa2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000fa2c:	c0 08       	rjmp	8000fa2c <_handle_Floating_Point>
	...

8000fa30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000fa30:	c0 08       	rjmp	8000fa30 <_handle_Coprocessor_Absent>
	...

8000fa34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000fa34:	c0 08       	rjmp	8000fa34 <_handle_Data_Address_Read>
	...

8000fa38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000fa38:	c0 08       	rjmp	8000fa38 <_handle_Data_Address_Write>
	...

8000fa3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000fa3c:	c0 08       	rjmp	8000fa3c <_handle_DTLB_Protection_Read>
	...

8000fa40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000fa40:	c0 08       	rjmp	8000fa40 <_handle_DTLB_Protection_Write>
	...

8000fa44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000fa44:	c0 08       	rjmp	8000fa44 <_handle_DTLB_Modified>
	...

8000fa50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000fa50:	c0 08       	rjmp	8000fa50 <_handle_ITLB_Miss>
	...

8000fa60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000fa60:	c0 08       	rjmp	8000fa60 <_handle_DTLB_Miss_Read>
	...

8000fa70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000fa70:	c0 08       	rjmp	8000fa70 <_handle_DTLB_Miss_Write>
	...

8000fb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000fb00:	fe cf 72 d4 	sub	pc,pc,29396

8000fb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000fb04:	30 0c       	mov	r12,0
8000fb06:	fe b0 af 31 	rcall	80005968 <_get_interrupt_handler>
8000fb0a:	58 0c       	cp.w	r12,0
8000fb0c:	f8 0f 17 10 	movne	pc,r12
8000fb10:	d6 03       	rete

8000fb12 <_int1>:
8000fb12:	30 1c       	mov	r12,1
8000fb14:	fe b0 af 2a 	rcall	80005968 <_get_interrupt_handler>
8000fb18:	58 0c       	cp.w	r12,0
8000fb1a:	f8 0f 17 10 	movne	pc,r12
8000fb1e:	d6 03       	rete

8000fb20 <_int2>:
8000fb20:	30 2c       	mov	r12,2
8000fb22:	fe b0 af 23 	rcall	80005968 <_get_interrupt_handler>
8000fb26:	58 0c       	cp.w	r12,0
8000fb28:	f8 0f 17 10 	movne	pc,r12
8000fb2c:	d6 03       	rete

8000fb2e <_int3>:
8000fb2e:	30 3c       	mov	r12,3
8000fb30:	fe b0 af 1c 	rcall	80005968 <_get_interrupt_handler>
8000fb34:	58 0c       	cp.w	r12,0
8000fb36:	f8 0f 17 10 	movne	pc,r12
8000fb3a:	d6 03       	rete

8000fb3c <ipr_val>:
8000fb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000fb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbfc:	d7 03 d7 03                                         ....
