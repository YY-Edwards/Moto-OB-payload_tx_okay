
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009d98  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000be00  8000be00  0000c200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001130  8000c000  8000c000  0000c400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a40  00000008  8000d130  0000d808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000036c0  00000a48  00000a48  00000000  2**2
                  ALLOC
  8 .heap         00012ef8  00004108  00004108  00000000  2**0
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000e248  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000010e8  00000000  00000000  0000e278  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002447  00000000  00000000  0000f360  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000273fc  00000000  00000000  000117a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000064ef  00000000  00000000  00038ba3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000145c4  00000000  00000000  0003f092  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002c00  00000000  00000000  00053658  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00006b23  00000000  00000000  00056258  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000c674  00000000  00000000  0005cd7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 013579a4  00000000  00000000  000693ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 000011d8  00000000  00000000  013c0d98  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9b 84 	sub	pc,pc,-25724

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf bb 88 	sub	pc,pc,-17528

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 80       	ld.ub	r0,r6[0x0]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 64       	and	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 14       	sub	r4,17
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 3c       	sub	r12,-125
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 dc       	sub	r12,-115
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e 5c       	mov	r12,-27
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c0 00       	breq	80002086 <app_init+0x46>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5b f8       	cp.w	r8,-1
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 19 	mcall	800020f8 <app_cfg+0x64>
8000209a:	49 98       	lddpc	r8,800020fc <app_cfg+0x68>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 96       	lddpc	r6,80002100 <app_cfg+0x6c>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 94       	lddpc	r4,80002104 <app_cfg+0x70>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 07 d0 	mov	r5,2000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 b1       	brne	800020ee <app_cfg+0x5a>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020ba:	f0 1f 00 14 	mcall	80002108 <app_cfg+0x74>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020be:	68 08       	ld.w	r8,r4[0x0]
800020c0:	58 08       	cp.w	r8,0
800020c2:	c0 51       	brne	800020cc <app_cfg+0x38>
				{
					xcmp_data_session();
800020c4:	f0 1f 00 12 	mcall	8000210c <app_cfg+0x78>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c8:	89 03       	st.w	r4[0x0],r3
800020ca:	c1 28       	rjmp	800020ee <app_cfg+0x5a>
				}
				else if(isAudioRouting == 1)
800020cc:	58 18       	cp.w	r8,1
800020ce:	c0 31       	brne	800020d4 <app_cfg+0x40>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d0:	89 02       	st.w	r4[0x0],r2
800020d2:	c0 e8       	rjmp	800020ee <app_cfg+0x5a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d4:	58 28       	cp.w	r8,2
800020d6:	c0 51       	brne	800020e0 <app_cfg+0x4c>
				{
					xcmp_data_session();
800020d8:	f0 1f 00 0d 	mcall	8000210c <app_cfg+0x78>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020dc:	89 00       	st.w	r4[0x0],r0
800020de:	c0 88       	rjmp	800020ee <app_cfg+0x5a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e0:	58 38       	cp.w	r8,3
800020e2:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020e6:	f7 b8 01 ff 	subne	r8,-1
800020ea:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020ee:	0a 9b       	mov	r11,r5
800020f0:	0e 9c       	mov	r12,r7
800020f2:	f0 1f 00 08 	mcall	80002110 <app_cfg+0x7c>
	}
800020f6:	cd db       	rjmp	800020b0 <app_cfg+0x1c>
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	59 30       	cp.w	r0,19
800020fc:	00 00       	add	r0,r0
800020fe:	0a 58       	eor	r8,r5
80002100:	00 00       	add	r0,r0
80002102:	0d 80       	ld.ub	r0,r6[0x0]
80002104:	00 00       	add	r0,r0
80002106:	0a 54       	eor	r4,r5
80002108:	80 00       	ld.sh	r0,r0[0x0]
8000210a:	3f c4       	mov	r4,-4
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	3e b0       	mov	r0,-21
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	5a 98       	cp.w	r8,-23

80002114 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002114:	d4 01       	pushm	lr
  log("R");
80002116:	48 3c       	lddpc	r12,80002120 <app_payload_tx_proc+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	c0 08       	rjmp	80002122 <app_payload_tx_proc+0xe>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	5f bc       	srhi	r12

80002128 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002128:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000212a:	48 3c       	lddpc	r12,80002134 <FD_brdcst_func+0xc>
8000212c:	f0 1f 00 03 	mcall	80002138 <FD_brdcst_func+0x10>
	
}
80002130:	d8 02       	popm	pc
80002132:	00 00       	add	r0,r0
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	c0 0c       	rcall	80002136 <FD_brdcst_func+0xe>
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	5f bc       	srhi	r12

8000213c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000213c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000213e:	48 3c       	lddpc	r12,80002148 <FD_reply_func+0xc>
80002140:	f0 1f 00 03 	mcall	8000214c <FD_reply_func+0x10>
	
	
}
80002144:	d8 02       	popm	pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	c0 2c       	rcall	8000214e <FD_reply_func+0x12>
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	5f bc       	srhi	r12

80002150 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002150:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002152:	48 3c       	lddpc	r12,8000215c <FD_request_func+0xc>
80002154:	f0 1f 00 03 	mcall	80002160 <FD_request_func+0x10>
	
	
}
80002158:	d8 02       	popm	pc
8000215a:	00 00       	add	r0,r0
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	c0 48       	rjmp	80002166 <EnOB_brdcst_func+0x2>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	5f bc       	srhi	r12

80002164 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002164:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002166:	48 3c       	lddpc	r12,80002170 <EnOB_brdcst_func+0xc>
80002168:	f0 1f 00 03 	mcall	80002174 <EnOB_brdcst_func+0x10>
}
8000216c:	d8 02       	popm	pc
8000216e:	00 00       	add	r0,r0
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	c0 64       	brge	8000217e <EnOB_reply_func+0x6>
80002174:	80 00       	ld.sh	r0,r0[0x0]
80002176:	5f bc       	srhi	r12

80002178 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002178:	eb cd 40 80 	pushm	r7,lr
8000217c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000217e:	19 a9       	ld.ub	r9,r12[0x2]
80002180:	30 08       	mov	r8,0
80002182:	f0 09 18 00 	cp.b	r9,r8
80002186:	c1 91       	brne	800021b8 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002188:	19 b8       	ld.ub	r8,r12[0x3]
8000218a:	30 19       	mov	r9,1
8000218c:	f2 08 18 00 	cp.b	r8,r9
80002190:	c0 61       	brne	8000219c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002192:	49 0c       	lddpc	r12,800021d0 <EnOB_reply_func+0x58>
80002194:	f0 1f 00 10 	mcall	800021d4 <EnOB_reply_func+0x5c>
80002198:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000219c:	58 08       	cp.w	r8,0
8000219e:	c0 61       	brne	800021aa <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021a0:	48 ec       	lddpc	r12,800021d8 <EnOB_reply_func+0x60>
800021a2:	f0 1f 00 0d 	mcall	800021d4 <EnOB_reply_func+0x5c>
800021a6:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021aa:	1a d8       	st.w	--sp,r8
800021ac:	48 cc       	lddpc	r12,800021dc <EnOB_reply_func+0x64>
800021ae:	f0 1f 00 0a 	mcall	800021d4 <EnOB_reply_func+0x5c>
800021b2:	2f fd       	sub	sp,-4
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021b8:	48 ac       	lddpc	r12,800021e0 <EnOB_reply_func+0x68>
800021ba:	f0 1f 00 07 	mcall	800021d4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 9c       	lddpc	r12,800021e4 <EnOB_reply_func+0x6c>
800021c4:	f0 1f 00 04 	mcall	800021d4 <EnOB_reply_func+0x5c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c0 7c       	rcall	800021e0 <EnOB_reply_func+0x68>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	5f bc       	srhi	r12
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c0 94       	brge	800021ec <SingleDetection_brdcst_func+0x4>
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c0 a8       	rjmp	800021f2 <SingleDetection_brdcst_func+0xa>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	c0 c0       	breq	800021fa <SingleDetection_brdcst_func+0x12>
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c0 dc       	rcall	80002200 <SingleDetection_brdcst_func+0x18>

800021e8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021ea:	19 a9       	ld.ub	r9,r12[0x2]
800021ec:	31 18       	mov	r8,17
800021ee:	f0 09 18 00 	cp.b	r9,r8
800021f2:	c0 41       	brne	800021fa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021f4:	48 2c       	lddpc	r12,800021fc <SingleDetection_brdcst_func+0x14>
800021f6:	f0 1f 00 03 	mcall	80002200 <SingleDetection_brdcst_func+0x18>
800021fa:	d8 02       	popm	pc
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	c0 f4       	brge	8000221c <ButtonConfig_brdcst_func+0x18>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	5f bc       	srhi	r12

80002204 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002204:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002206:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000220a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000220c:	4a bc       	lddpc	r12,800022b8 <ButtonConfig_brdcst_func+0xb4>
8000220e:	f0 1f 00 2c 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002212:	0f 88       	ld.ub	r8,r7[0x0]
80002214:	1a d8       	st.w	--sp,r8
80002216:	4a bc       	lddpc	r12,800022c0 <ButtonConfig_brdcst_func+0xbc>
80002218:	f0 1f 00 29 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000221c:	1a d5       	st.w	--sp,r5
8000221e:	4a ac       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xc0>
80002220:	f0 1f 00 27 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002224:	0f a8       	ld.ub	r8,r7[0x2]
80002226:	1a d8       	st.w	--sp,r8
80002228:	4a 8c       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xc4>
8000222a:	f0 1f 00 25 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000222e:	2f dd       	sub	sp,-12
80002230:	58 05       	cp.w	r5,0
80002232:	c4 10       	breq	800022b4 <ButtonConfig_brdcst_func+0xb0>
80002234:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002236:	4a 64       	lddpc	r4,800022cc <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002238:	4a 63       	lddpc	r3,800022d0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000223a:	4a 72       	lddpc	r2,800022d4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000223c:	4a 71       	lddpc	r1,800022d8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	4a 80       	lddpc	r0,800022dc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002240:	0f b9       	ld.ub	r9,r7[0x3]
80002242:	0f c8       	ld.ub	r8,r7[0x4]
80002244:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002248:	1a d8       	st.w	--sp,r8
8000224a:	1a d6       	st.w	--sp,r6
8000224c:	08 9c       	mov	r12,r4
8000224e:	f0 1f 00 1c 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002252:	0f d9       	ld.ub	r9,r7[0x5]
80002254:	0f e8       	ld.ub	r8,r7[0x6]
80002256:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225a:	1a d8       	st.w	--sp,r8
8000225c:	1a d6       	st.w	--sp,r6
8000225e:	06 9c       	mov	r12,r3
80002260:	f0 1f 00 17 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002264:	0f f9       	ld.ub	r9,r7[0x7]
80002266:	ef 38 00 08 	ld.ub	r8,r7[8]
8000226a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226e:	1a d8       	st.w	--sp,r8
80002270:	1a d6       	st.w	--sp,r6
80002272:	04 9c       	mov	r12,r2
80002274:	f0 1f 00 12 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002278:	ef 39 00 09 	ld.ub	r9,r7[9]
8000227c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002280:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002284:	1a d8       	st.w	--sp,r8
80002286:	1a d6       	st.w	--sp,r6
80002288:	02 9c       	mov	r12,r1
8000228a:	f0 1f 00 0d 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000228e:	2f 8d       	sub	sp,-32
80002290:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002294:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002298:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000229c:	1a d8       	st.w	--sp,r8
8000229e:	1a d6       	st.w	--sp,r6
800022a0:	00 9c       	mov	r12,r0
800022a2:	f0 1f 00 07 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
800022a6:	2f f6       	sub	r6,-1
800022a8:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022aa:	2f ed       	sub	sp,-8
800022ac:	ec 05 18 00 	cp.b	r5,r6
800022b0:	fe 9b ff c8 	brhi	80002240 <ButtonConfig_brdcst_func+0x3c>
800022b4:	d8 32       	popm	r0-r7,pc
800022b6:	00 00       	add	r0,r0
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c1 08       	rjmp	800022da <ButtonConfig_brdcst_func+0xd6>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	5f bc       	srhi	r12
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	c1 28       	rjmp	800022e6 <Phyuserinput_brdcst_func+0x6>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c1 3c       	rcall	800022ec <Phyuserinput_brdcst_func+0xc>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c1 54       	brge	800022f4 <Phyuserinput_brdcst_func+0x14>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c1 74       	brge	800022fc <Phyuserinput_brdcst_func+0x1c>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c1 9c       	rcall	80002304 <Phyuserinput_brdcst_func+0x24>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c1 c4       	brge	8000230e <Phyuserinput_brdcst_func+0x2e>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c1 e8       	rjmp	80002316 <Phyuserinput_brdcst_func+0x36>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c2 10       	breq	80002320 <Phyuserinput_brdcst_func+0x40>

800022e0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e0:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022e4:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022e6:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022e8:	19 c7       	ld.ub	r7,r12[0x4]
800022ea:	19 d8       	ld.ub	r8,r12[0x5]
800022ec:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022f0:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022f2:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022f4:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022f8:	49 0c       	lddpc	r12,80002338 <Phyuserinput_brdcst_func+0x58>
800022fa:	f0 1f 00 11 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022fe:	1a d6       	st.w	--sp,r6
80002300:	49 0c       	lddpc	r12,80002340 <Phyuserinput_brdcst_func+0x60>
80002302:	f0 1f 00 0f 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002306:	1a d5       	st.w	--sp,r5
80002308:	48 fc       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x64>
8000230a:	f0 1f 00 0d 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000230e:	5c 77       	castu.h	r7
80002310:	1a d7       	st.w	--sp,r7
80002312:	48 ec       	lddpc	r12,80002348 <Phyuserinput_brdcst_func+0x68>
80002314:	f0 1f 00 0a 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002318:	1a d4       	st.w	--sp,r4
8000231a:	48 dc       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x6c>
8000231c:	f0 1f 00 08 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002320:	1a d3       	st.w	--sp,r3
80002322:	48 cc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x70>
80002324:	f0 1f 00 06 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002328:	1a d2       	st.w	--sp,r2
8000232a:	48 bc       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x74>
8000232c:	f0 1f 00 04 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
80002330:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002332:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	c2 34       	brge	80002380 <ButtonConfig_reply_func+0x28>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	5f bc       	srhi	r12
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	c2 58       	rjmp	8000238c <ButtonConfig_reply_func+0x34>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c2 70       	breq	80002394 <ButtonConfig_reply_func+0x3c>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	c2 84       	brge	8000239a <ButtonConfig_reply_func+0x42>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c2 98       	rjmp	800023a0 <DataSession_brdcst_func+0x4>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c2 ac       	rcall	800023a6 <DataSession_brdcst_func+0xa>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c2 cc       	rcall	800023ae <DataSession_brdcst_func+0x12>

80002358 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002358:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000235c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002360:	0f 89       	ld.ub	r9,r7[0x0]
80002362:	30 08       	mov	r8,0
80002364:	f0 09 18 00 	cp.b	r9,r8
80002368:	c0 c1       	brne	80002380 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000236a:	48 9c       	lddpc	r12,8000238c <ButtonConfig_reply_func+0x34>
8000236c:	f0 1f 00 09 	mcall	80002390 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002370:	0f 98       	ld.ub	r8,r7[0x1]
80002372:	1a d8       	st.w	--sp,r8
80002374:	48 8c       	lddpc	r12,80002394 <ButtonConfig_reply_func+0x3c>
80002376:	f0 1f 00 07 	mcall	80002390 <ButtonConfig_reply_func+0x38>
8000237a:	2f fd       	sub	sp,-4
8000237c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002380:	48 6c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x40>
80002382:	f0 1f 00 04 	mcall	80002390 <ButtonConfig_reply_func+0x38>
80002386:	e3 cd 80 80 	ldm	sp++,r7,pc
8000238a:	00 00       	add	r0,r0
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	c2 ec       	rcall	800023ea <DataSession_brdcst_func+0x4e>
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	5f bc       	srhi	r12
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	c1 28       	rjmp	800023ba <DataSession_brdcst_func+0x1e>
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c3 04       	brge	800023fa <DataSession_brdcst_func+0x5e>

8000239c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000239c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000239e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023a2:	0d 88       	ld.ub	r8,r6[0x0]
800023a4:	32 49       	mov	r9,36
800023a6:	f2 08 18 00 	cp.b	r8,r9
800023aa:	c2 91       	brne	800023fc <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023ac:	49 7c       	lddpc	r12,80002408 <DataSession_brdcst_func+0x6c>
800023ae:	f0 1f 00 18 	mcall	8000240c <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023b2:	0d a5       	ld.ub	r5,r6[0x2]
800023b4:	0d b8       	ld.ub	r8,r6[0x3]
800023b6:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023ba:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023bc:	0d 98       	ld.ub	r8,r6[0x1]
800023be:	1a d8       	st.w	--sp,r8
800023c0:	49 4c       	lddpc	r12,80002410 <DataSession_brdcst_func+0x74>
800023c2:	f0 1f 00 13 	mcall	8000240c <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023c6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 2c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x78>
800023ce:	f0 1f 00 10 	mcall	8000240c <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023d2:	2f ed       	sub	sp,-8
800023d4:	58 05       	cp.w	r5,0
800023d6:	c1 80       	breq	80002406 <DataSession_brdcst_func+0x6a>
800023d8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023da:	49 04       	lddpc	r4,80002418 <DataSession_brdcst_func+0x7c>
800023dc:	ec 07 00 08 	add	r8,r6,r7
800023e0:	11 c8       	ld.ub	r8,r8[0x4]
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	1a d7       	st.w	--sp,r7
800023e6:	08 9c       	mov	r12,r4
800023e8:	f0 1f 00 09 	mcall	8000240c <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023ec:	2f f7       	sub	r7,-1
800023ee:	5c 57       	castu.b	r7
800023f0:	2f ed       	sub	sp,-8
800023f2:	ee 05 19 00 	cp.h	r5,r7
800023f6:	fe 9b ff f3 	brhi	800023dc <DataSession_brdcst_func+0x40>
800023fa:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023fc:	1a d8       	st.w	--sp,r8
800023fe:	48 8c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x80>
80002400:	f0 1f 00 03 	mcall	8000240c <DataSession_brdcst_func+0x70>
80002404:	2f fd       	sub	sp,-4
80002406:	d8 22       	popm	r4-r7,pc
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	c3 20       	breq	8000246e <DataSession_reply_func+0x4e>
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	5f bc       	srhi	r12
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	c3 34       	brge	80002478 <CallControl_brdcst_func>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c3 4c       	rcall	8000247e <CallControl_brdcst_func+0x6>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	c3 68       	rjmp	80002486 <CallControl_brdcst_func+0xe>
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	c3 80       	breq	8000248e <CallControl_brdcst_func+0x16>

80002420 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002420:	eb cd 40 80 	pushm	r7,lr
80002424:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002426:	19 a8       	ld.ub	r8,r12[0x2]
80002428:	58 08       	cp.w	r8,0
8000242a:	c0 61       	brne	80002436 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
8000242c:	48 dc       	lddpc	r12,80002460 <DataSession_reply_func+0x40>
8000242e:	f0 1f 00 0e 	mcall	80002464 <DataSession_reply_func+0x44>
80002432:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002436:	1a d8       	st.w	--sp,r8
80002438:	48 cc       	lddpc	r12,80002468 <DataSession_reply_func+0x48>
8000243a:	f0 1f 00 0b 	mcall	80002464 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000243e:	48 cc       	lddpc	r12,8000246c <DataSession_reply_func+0x4c>
80002440:	f0 1f 00 09 	mcall	80002464 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002444:	0f b8       	ld.ub	r8,r7[0x3]
80002446:	1a d8       	st.w	--sp,r8
80002448:	48 ac       	lddpc	r12,80002470 <DataSession_reply_func+0x50>
8000244a:	f0 1f 00 07 	mcall	80002464 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000244e:	0f c8       	ld.ub	r8,r7[0x4]
80002450:	1a d8       	st.w	--sp,r8
80002452:	48 9c       	lddpc	r12,80002474 <DataSession_reply_func+0x54>
80002454:	f0 1f 00 04 	mcall	80002464 <DataSession_reply_func+0x44>
80002458:	2f dd       	sub	sp,-12
8000245a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245e:	00 00       	add	r0,r0
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c3 94       	brge	800024d4 <TransmitControl_brdcst_func+0x18>
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	5f bc       	srhi	r12
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	c3 a8       	rjmp	800024de <TransmitControl_brdcst_func+0x22>
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	c3 bc       	rcall	800024e4 <TransmitControl_brdcst_func+0x28>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	c3 d0       	breq	800024ec <TransmitControl_brdcst_func+0x30>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c3 e0       	breq	800024f2 <TransmitControl_brdcst_func+0x36>

80002478 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002478:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000247c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002480:	0f 98       	ld.ub	r8,r7[0x1]
80002482:	1a d8       	st.w	--sp,r8
80002484:	48 bc       	lddpc	r12,800024b0 <CallControl_brdcst_func+0x38>
80002486:	f0 1f 00 0c 	mcall	800024b4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000248a:	2f fd       	sub	sp,-4
8000248c:	0f 99       	ld.ub	r9,r7[0x1]
8000248e:	30 38       	mov	r8,3
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c0 41       	brne	8000249c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002496:	30 09       	mov	r9,0
80002498:	48 88       	lddpc	r8,800024b8 <CallControl_brdcst_func+0x40>
8000249a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000249c:	0f 99       	ld.ub	r9,r7[0x1]
8000249e:	30 48       	mov	r8,4
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c0 41       	brne	800024ac <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024a6:	30 19       	mov	r9,1
800024a8:	48 48       	lddpc	r8,800024b8 <CallControl_brdcst_func+0x40>
800024aa:	b0 89       	st.b	r8[0x0],r9
800024ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	c3 f0       	breq	80002530 <TransmitControl_reply_func+0x2c>
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	5f bc       	srhi	r12
800024b8:	00 00       	add	r0,r0
800024ba:	0a 5d       	eor	sp,r5

800024bc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024c0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024c4:	0f 99       	ld.ub	r9,r7[0x1]
800024c6:	30 08       	mov	r8,0
800024c8:	f0 09 18 00 	cp.b	r9,r8
800024cc:	c0 71       	brne	800024da <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024ce:	48 ac       	lddpc	r12,800024f4 <TransmitControl_brdcst_func+0x38>
800024d0:	f0 1f 00 0a 	mcall	800024f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024d4:	30 09       	mov	r9,0
800024d6:	48 a8       	lddpc	r8,800024fc <TransmitControl_brdcst_func+0x40>
800024d8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024da:	0f 99       	ld.ub	r9,r7[0x1]
800024dc:	30 18       	mov	r8,1
800024de:	f0 09 18 00 	cp.b	r9,r8
800024e2:	c0 71       	brne	800024f0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024e4:	48 7c       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x44>
800024e6:	f0 1f 00 05 	mcall	800024f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024ea:	30 19       	mov	r9,1
800024ec:	48 48       	lddpc	r8,800024fc <TransmitControl_brdcst_func+0x40>
800024ee:	b0 89       	st.b	r8[0x0],r9
800024f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	c4 08       	rjmp	80002576 <AudioRoutingControl_reply_func+0x12>
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	5f bc       	srhi	r12
800024fc:	00 00       	add	r0,r0
800024fe:	0a 5c       	eor	r12,r5
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	c4 20       	breq	80002586 <AudioRoutingControl_reply_func+0x22>

80002504 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002504:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002508:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000250c:	0f 89       	ld.ub	r9,r7[0x0]
8000250e:	30 08       	mov	r8,0
80002510:	f0 09 18 00 	cp.b	r9,r8
80002514:	c1 61       	brne	80002540 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002516:	48 ec       	lddpc	r12,8000254c <TransmitControl_reply_func+0x48>
80002518:	f0 1f 00 0e 	mcall	80002550 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000251c:	0f 98       	ld.ub	r8,r7[0x1]
8000251e:	1a d8       	st.w	--sp,r8
80002520:	48 dc       	lddpc	r12,80002554 <TransmitControl_reply_func+0x50>
80002522:	f0 1f 00 0c 	mcall	80002550 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002526:	0f a8       	ld.ub	r8,r7[0x2]
80002528:	1a d8       	st.w	--sp,r8
8000252a:	48 cc       	lddpc	r12,80002558 <TransmitControl_reply_func+0x54>
8000252c:	f0 1f 00 09 	mcall	80002550 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002530:	0f b8       	ld.ub	r8,r7[0x3]
80002532:	1a d8       	st.w	--sp,r8
80002534:	48 ac       	lddpc	r12,8000255c <TransmitControl_reply_func+0x58>
80002536:	f0 1f 00 07 	mcall	80002550 <TransmitControl_reply_func+0x4c>
8000253a:	2f dd       	sub	sp,-12
8000253c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002540:	48 8c       	lddpc	r12,80002560 <TransmitControl_reply_func+0x5c>
80002542:	f0 1f 00 04 	mcall	80002550 <TransmitControl_reply_func+0x4c>
80002546:	e3 cd 80 80 	ldm	sp++,r7,pc
8000254a:	00 00       	add	r0,r0
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	c4 34       	brge	800025d4 <Volume_reply_func+0x40>
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	5f bc       	srhi	r12
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	c4 50       	breq	800025e0 <Volume_reply_func+0x4c>
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	c4 64       	brge	800025e6 <Volume_reply_func+0x52>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	c4 80       	breq	800025ee <Volume_reply_func+0x5a>
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	c4 90       	breq	800025f4 <Volume_reply_func+0x60>

80002564 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002564:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002566:	19 a9       	ld.ub	r9,r12[0x2]
80002568:	30 08       	mov	r8,0
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 71       	brne	8000257c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002570:	48 5c       	lddpc	r12,80002584 <AudioRoutingControl_reply_func+0x20>
80002572:	f0 1f 00 06 	mcall	80002588 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002576:	f0 1f 00 06 	mcall	8000258c <AudioRoutingControl_reply_func+0x28>
8000257a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000257c:	48 5c       	lddpc	r12,80002590 <AudioRoutingControl_reply_func+0x2c>
8000257e:	f0 1f 00 03 	mcall	80002588 <AudioRoutingControl_reply_func+0x24>
80002582:	d8 02       	popm	pc
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	c4 a8       	rjmp	8000261a <spk_brdcst_func+0x22>
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	5f bc       	srhi	r12
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	3f c4       	mov	r4,-4
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	c4 b8       	rjmp	80002628 <spk_brdcst_func+0x30>

80002594 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002594:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002598:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000259c:	0f 89       	ld.ub	r9,r7[0x0]
8000259e:	30 08       	mov	r8,0
800025a0:	f0 09 18 00 	cp.b	r9,r8
800025a4:	c1 b1       	brne	800025da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025a6:	0f b8       	ld.ub	r8,r7[0x3]
800025a8:	31 09       	mov	r9,16
800025aa:	f2 08 18 00 	cp.b	r8,r9
800025ae:	c0 f1       	brne	800025cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025b0:	48 dc       	lddpc	r12,800025e4 <Volume_reply_func+0x50>
800025b2:	f0 1f 00 0e 	mcall	800025e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025b6:	0f 99       	ld.ub	r9,r7[0x1]
800025b8:	0f a8       	ld.ub	r8,r7[0x2]
800025ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025be:	1a d8       	st.w	--sp,r8
800025c0:	48 bc       	lddpc	r12,800025ec <Volume_reply_func+0x58>
800025c2:	f0 1f 00 0a 	mcall	800025e8 <Volume_reply_func+0x54>
800025c6:	2f fd       	sub	sp,-4
800025c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025cc:	1a d8       	st.w	--sp,r8
800025ce:	48 9c       	lddpc	r12,800025f0 <Volume_reply_func+0x5c>
800025d0:	f0 1f 00 06 	mcall	800025e8 <Volume_reply_func+0x54>
800025d4:	2f fd       	sub	sp,-4
800025d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025da:	48 7c       	lddpc	r12,800025f4 <Volume_reply_func+0x60>
800025dc:	f0 1f 00 03 	mcall	800025e8 <Volume_reply_func+0x54>
800025e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	c4 cc       	rcall	8000267e <mic_brdcst_func+0x6>
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	5f bc       	srhi	r12
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	c4 e0       	breq	8000268a <mic_brdcst_func+0x12>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	c4 fc       	rcall	80002690 <mic_brdcst_func+0x18>
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	c5 14       	brge	80002698 <mic_brdcst_func+0x20>

800025f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025fa:	19 d9       	ld.ub	r9,r12[0x5]
800025fc:	30 08       	mov	r8,0
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 81       	brne	80002612 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002604:	10 99       	mov	r9,r8
80002606:	48 78       	lddpc	r8,80002620 <spk_brdcst_func+0x28>
80002608:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000260a:	48 7c       	lddpc	r12,80002624 <spk_brdcst_func+0x2c>
8000260c:	f0 1f 00 07 	mcall	80002628 <spk_brdcst_func+0x30>
80002610:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002612:	30 19       	mov	r9,1
80002614:	48 38       	lddpc	r8,80002620 <spk_brdcst_func+0x28>
80002616:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002618:	48 5c       	lddpc	r12,8000262c <spk_brdcst_func+0x34>
8000261a:	f0 1f 00 04 	mcall	80002628 <spk_brdcst_func+0x30>
8000261e:	d8 02       	popm	pc
80002620:	00 00       	add	r0,r0
80002622:	0a 48       	or	r8,r5
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	c5 2c       	rcall	800026ca <mic_brdcst_func+0x52>
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	5f bc       	srhi	r12
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	c5 3c       	rcall	800026d4 <mic_reply_func+0x4>

80002630 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002630:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002632:	19 a9       	ld.ub	r9,r12[0x2]
80002634:	30 08       	mov	r8,0
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 f1       	brne	80002658 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000263c:	19 e9       	ld.ub	r9,r12[0x6]
8000263e:	f0 09 18 00 	cp.b	r9,r8
80002642:	c0 40       	breq	8000264a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002644:	30 19       	mov	r9,1
80002646:	48 98       	lddpc	r8,80002668 <spk_reply_func+0x38>
80002648:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000264a:	19 e8       	ld.ub	r8,r12[0x6]
8000264c:	1a d8       	st.w	--sp,r8
8000264e:	48 8c       	lddpc	r12,8000266c <spk_reply_func+0x3c>
80002650:	f0 1f 00 08 	mcall	80002670 <spk_reply_func+0x40>
80002654:	2f fd       	sub	sp,-4
80002656:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002658:	30 09       	mov	r9,0
8000265a:	48 48       	lddpc	r8,80002668 <spk_reply_func+0x38>
8000265c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000265e:	48 6c       	lddpc	r12,80002674 <spk_reply_func+0x44>
80002660:	f0 1f 00 04 	mcall	80002670 <spk_reply_func+0x40>
80002664:	d8 02       	popm	pc
80002666:	00 00       	add	r0,r0
80002668:	00 00       	add	r0,r0
8000266a:	0a 48       	or	r8,r5
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	c5 48       	rjmp	80002716 <mic_reply_func+0x46>
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	5f bc       	srhi	r12
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	c5 58       	rjmp	80002720 <mic_reply_func+0x50>

80002678 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002678:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000267c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002680:	0f a9       	ld.ub	r9,r7[0x2]
80002682:	30 08       	mov	r8,0
80002684:	f0 09 18 00 	cp.b	r9,r8
80002688:	c0 71       	brne	80002696 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000268a:	48 dc       	lddpc	r12,800026bc <mic_brdcst_func+0x44>
8000268c:	f0 1f 00 0d 	mcall	800026c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002690:	30 09       	mov	r9,0
80002692:	48 d8       	lddpc	r8,800026c4 <mic_brdcst_func+0x4c>
80002694:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002696:	0f a9       	ld.ub	r9,r7[0x2]
80002698:	31 18       	mov	r8,17
8000269a:	f0 09 18 00 	cp.b	r9,r8
8000269e:	c0 d1       	brne	800026b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026a0:	48 ac       	lddpc	r12,800026c8 <mic_brdcst_func+0x50>
800026a2:	f0 1f 00 08 	mcall	800026c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026a6:	48 89       	lddpc	r9,800026c4 <mic_brdcst_func+0x4c>
800026a8:	30 18       	mov	r8,1
800026aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026ac:	13 89       	ld.ub	r9,r9[0x0]
800026ae:	f0 09 18 00 	cp.b	r9,r8
800026b2:	c0 31       	brne	800026b8 <mic_brdcst_func+0x40>
800026b4:	48 68       	lddpc	r8,800026cc <mic_brdcst_func+0x54>
800026b6:	11 88       	ld.ub	r8,r8[0x0]
800026b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	c5 64       	brge	8000276a <dcm_brdcst_func+0x6>
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	5f bc       	srhi	r12
800026c4:	00 00       	add	r0,r0
800026c6:	0a 61       	and	r1,r5
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	c5 78       	rjmp	80002778 <dcm_brdcst_func+0x14>
800026cc:	00 00       	add	r0,r0
800026ce:	0a 5d       	eor	sp,r5

800026d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026d8:	49 ac       	lddpc	r12,80002740 <mic_reply_func+0x70>
800026da:	f0 1f 00 1b 	mcall	80002744 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026de:	0f 89       	ld.ub	r9,r7[0x0]
800026e0:	30 08       	mov	r8,0
800026e2:	f0 09 18 00 	cp.b	r9,r8
800026e6:	c2 71       	brne	80002734 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026e8:	0f 98       	ld.ub	r8,r7[0x1]
800026ea:	30 29       	mov	r9,2
800026ec:	f2 08 18 00 	cp.b	r8,r9
800026f0:	c1 b1       	brne	80002726 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026f2:	49 6c       	lddpc	r12,80002748 <mic_reply_func+0x78>
800026f4:	f0 1f 00 14 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026f8:	0f a8       	ld.ub	r8,r7[0x2]
800026fa:	1a d8       	st.w	--sp,r8
800026fc:	49 4c       	lddpc	r12,8000274c <mic_reply_func+0x7c>
800026fe:	f0 1f 00 12 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002702:	0f b8       	ld.ub	r8,r7[0x3]
80002704:	1a d8       	st.w	--sp,r8
80002706:	49 3c       	lddpc	r12,80002750 <mic_reply_func+0x80>
80002708:	f0 1f 00 0f 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000270c:	0f c8       	ld.ub	r8,r7[0x4]
8000270e:	1a d8       	st.w	--sp,r8
80002710:	49 1c       	lddpc	r12,80002754 <mic_reply_func+0x84>
80002712:	f0 1f 00 0d 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002716:	0f d8       	ld.ub	r8,r7[0x5]
80002718:	1a d8       	st.w	--sp,r8
8000271a:	49 0c       	lddpc	r12,80002758 <mic_reply_func+0x88>
8000271c:	f0 1f 00 0a 	mcall	80002744 <mic_reply_func+0x74>
80002720:	2f cd       	sub	sp,-16
80002722:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002726:	1a d8       	st.w	--sp,r8
80002728:	48 dc       	lddpc	r12,8000275c <mic_reply_func+0x8c>
8000272a:	f0 1f 00 07 	mcall	80002744 <mic_reply_func+0x74>
8000272e:	2f fd       	sub	sp,-4
80002730:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002734:	48 bc       	lddpc	r12,80002760 <mic_reply_func+0x90>
80002736:	f0 1f 00 04 	mcall	80002744 <mic_reply_func+0x74>
8000273a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000273e:	00 00       	add	r0,r0
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	c5 8c       	rcall	800027f2 <dcm_reply_func+0x46>
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	5f bc       	srhi	r12
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	c5 9c       	rcall	800027fc <dcm_reply_func+0x50>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	c5 b0       	breq	80002804 <dcm_reply_func+0x58>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	c5 c4       	brge	8000280a <dcm_reply_func+0x5e>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	c5 e0       	breq	80002812 <dcm_reply_func+0x66>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	c5 f8       	rjmp	80002818 <ToneControl_reply_func+0x4>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	c6 10       	breq	80002820 <ToneControl_reply_func+0xc>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	c6 28       	rjmp	80002826 <ToneControl_reply_func+0x12>

80002764 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002764:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002768:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000276c:	48 bc       	lddpc	r12,80002798 <dcm_brdcst_func+0x34>
8000276e:	f0 1f 00 0c 	mcall	8000279c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002772:	0f 88       	ld.ub	r8,r7[0x0]
80002774:	1a d8       	st.w	--sp,r8
80002776:	48 bc       	lddpc	r12,800027a0 <dcm_brdcst_func+0x3c>
80002778:	f0 1f 00 09 	mcall	8000279c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000277c:	0f a8       	ld.ub	r8,r7[0x2]
8000277e:	1a d8       	st.w	--sp,r8
80002780:	48 9c       	lddpc	r12,800027a4 <dcm_brdcst_func+0x40>
80002782:	f0 1f 00 07 	mcall	8000279c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002786:	0f 98       	ld.ub	r8,r7[0x1]
80002788:	1a d8       	st.w	--sp,r8
8000278a:	48 8c       	lddpc	r12,800027a8 <dcm_brdcst_func+0x44>
8000278c:	f0 1f 00 04 	mcall	8000279c <dcm_brdcst_func+0x38>
80002790:	2f dd       	sub	sp,-12
	
	
}
80002792:	e3 cd 80 80 	ldm	sp++,r7,pc
80002796:	00 00       	add	r0,r0
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	c6 38       	rjmp	80002860 <app_payload_rx_proc+0x24>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	5f bc       	srhi	r12
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	c6 4c       	rcall	8000286a <app_payload_rx_proc+0x2e>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	c6 60       	breq	80002872 <app_payload_rx_proc+0x36>
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	c6 78       	rjmp	80002878 <app_payload_rx_proc+0x3c>

800027ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027ac:	eb cd 40 80 	pushm	r7,lr
800027b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027b2:	19 a9       	ld.ub	r9,r12[0x2]
800027b4:	30 08       	mov	r8,0
800027b6:	f0 09 18 00 	cp.b	r9,r8
800027ba:	c1 b1       	brne	800027f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027bc:	19 b8       	ld.ub	r8,r12[0x3]
800027be:	30 19       	mov	r9,1
800027c0:	f2 08 18 00 	cp.b	r8,r9
800027c4:	c0 51       	brne	800027ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027c6:	48 ec       	lddpc	r12,800027fc <dcm_reply_func+0x50>
800027c8:	f0 1f 00 0e 	mcall	80002800 <dcm_reply_func+0x54>
800027cc:	c0 a8       	rjmp	800027e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027ce:	58 08       	cp.w	r8,0
800027d0:	c0 51       	brne	800027da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027d2:	48 dc       	lddpc	r12,80002804 <dcm_reply_func+0x58>
800027d4:	f0 1f 00 0b 	mcall	80002800 <dcm_reply_func+0x54>
800027d8:	c0 48       	rjmp	800027e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027da:	48 cc       	lddpc	r12,80002808 <dcm_reply_func+0x5c>
800027dc:	f0 1f 00 09 	mcall	80002800 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027e0:	0f d8       	ld.ub	r8,r7[0x5]
800027e2:	1a d8       	st.w	--sp,r8
800027e4:	48 ac       	lddpc	r12,8000280c <dcm_reply_func+0x60>
800027e6:	f0 1f 00 07 	mcall	80002800 <dcm_reply_func+0x54>
800027ea:	2f fd       	sub	sp,-4
800027ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027f0:	48 8c       	lddpc	r12,80002810 <dcm_reply_func+0x64>
800027f2:	f0 1f 00 04 	mcall	80002800 <dcm_reply_func+0x54>
800027f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027fa:	00 00       	add	r0,r0
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	c6 94       	brge	800028d0 <CalculateBurst+0x10>
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	5f bc       	srhi	r12
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	c6 a8       	rjmp	800028da <CalculateBurst+0x1a>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	c6 bc       	rcall	800028e0 <payload_init+0x4>
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	c6 d0       	breq	800028e8 <payload_init+0xc>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	c6 dc       	rcall	800028ec <payload_init+0x10>

80002814 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002814:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002816:	19 a9       	ld.ub	r9,r12[0x2]
80002818:	30 08       	mov	r8,0
8000281a:	f0 09 18 00 	cp.b	r9,r8
8000281e:	c0 51       	brne	80002828 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002820:	48 4c       	lddpc	r12,80002830 <ToneControl_reply_func+0x1c>
80002822:	f0 1f 00 05 	mcall	80002834 <ToneControl_reply_func+0x20>
80002826:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002828:	48 4c       	lddpc	r12,80002838 <ToneControl_reply_func+0x24>
8000282a:	f0 1f 00 03 	mcall	80002834 <ToneControl_reply_func+0x20>
8000282e:	d8 02       	popm	pc
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	c6 e8       	rjmp	8000290e <payload_init+0x32>
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	5f bc       	srhi	r12
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	c6 f0       	breq	80002918 <payload_rx_process+0x4>

8000283c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000283c:	eb cd 40 80 	pushm	r7,lr
80002840:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002842:	48 c9       	lddpc	r9,80002870 <app_payload_rx_proc+0x34>
80002844:	13 88       	ld.ub	r8,r9[0x0]
80002846:	2f f8       	sub	r8,-1
80002848:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000284a:	30 39       	mov	r9,3
8000284c:	f2 08 18 00 	cp.b	r8,r9
80002850:	c0 71       	brne	8000285e <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002852:	30 09       	mov	r9,0
80002854:	48 78       	lddpc	r8,80002870 <app_payload_rx_proc+0x34>
80002856:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002858:	48 7c       	lddpc	r12,80002874 <app_payload_rx_proc+0x38>
8000285a:	f0 1f 00 08 	mcall	80002878 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000285e:	48 88       	lddpc	r8,8000287c <app_payload_rx_proc+0x40>
80002860:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002862:	48 88       	lddpc	r8,80002880 <app_payload_rx_proc+0x44>
80002864:	70 0c       	ld.w	r12,r8[0x0]
80002866:	0e 9b       	mov	r11,r7
80002868:	f0 1f 00 07 	mcall	80002884 <app_payload_rx_proc+0x48>

}
8000286c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002870:	00 00       	add	r0,r0
80002872:	0a 60       	and	r0,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	c6 fc       	rcall	80002954 <payload_rx_process+0x40>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	5f bc       	srhi	r12
8000287c:	00 00       	add	r0,r0
8000287e:	0a 62       	and	r2,r5
80002880:	00 00       	add	r0,r0
80002882:	0a 7c       	tst	r12,r5
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	29 b4       	sub	r4,-101

80002888 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002888:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000288a:	19 e8       	ld.ub	r8,r12[0x6]
8000288c:	30 19       	mov	r9,1
8000288e:	f2 08 18 00 	cp.b	r8,r9
80002892:	c0 61       	brne	8000289e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002894:	48 98       	lddpc	r8,800028b8 <DeviceInitializationStatus_brdcst_func+0x30>
80002896:	70 09       	ld.w	r9,r8[0x0]
80002898:	a1 a9       	sbr	r9,0x0
8000289a:	91 09       	st.w	r8[0x0],r9
8000289c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000289e:	30 29       	mov	r9,2
800028a0:	f2 08 18 00 	cp.b	r8,r9
800028a4:	c0 80       	breq	800028b4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028a6:	48 58       	lddpc	r8,800028b8 <DeviceInitializationStatus_brdcst_func+0x30>
800028a8:	70 09       	ld.w	r9,r8[0x0]
800028aa:	e0 19 ff fc 	andl	r9,0xfffc
800028ae:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028b0:	f0 1f 00 03 	mcall	800028bc <DeviceInitializationStatus_brdcst_func+0x34>
800028b4:	d8 02       	popm	pc
800028b6:	00 00       	add	r0,r0
800028b8:	00 00       	add	r0,r0
800028ba:	0d 80       	ld.ub	r0,r6[0x0]
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	3f 18       	mov	r8,-15

800028c0 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028c0:	20 1c       	sub	r12,1
800028c2:	5c 5c       	castu.b	r12
800028c4:	31 18       	mov	r8,17
800028c6:	f0 0c 18 00 	cp.b	r12,r8
800028ca:	e0 88 00 03 	brls	800028d0 <CalculateBurst+0x10>
800028ce:	5e fd       	retal	0
800028d0:	48 28       	lddpc	r8,800028d8 <CalculateBurst+0x18>
800028d2:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028d6:	5e fc       	retal	r12
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	c7 10       	breq	800029bc <set_idle_store+0x8>

800028dc <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028dc:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028de:	48 98       	lddpc	r8,80002900 <payload_init+0x24>
800028e0:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028e2:	48 98       	lddpc	r8,80002904 <payload_init+0x28>
800028e4:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028e6:	30 09       	mov	r9,0
800028e8:	1a d9       	st.w	--sp,r9
800028ea:	1a d9       	st.w	--sp,r9
800028ec:	1a d9       	st.w	--sp,r9
800028ee:	30 28       	mov	r8,2
800028f0:	e0 6a 04 00 	mov	r10,1024
800028f4:	48 5b       	lddpc	r11,80002908 <payload_init+0x2c>
800028f6:	48 6c       	lddpc	r12,8000290c <payload_init+0x30>
800028f8:	f0 1f 00 06 	mcall	80002910 <payload_init+0x34>
800028fc:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800028fe:	d8 02       	popm	pc
80002900:	00 00       	add	r0,r0
80002902:	0a 68       	and	r8,r5
80002904:	00 00       	add	r0,r0
80002906:	0a 6c       	and	r12,r5
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	c7 58       	rjmp	800029f4 <phy_tx+0x20>
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	29 14       	sub	r4,-111
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	5b f8       	cp.w	r8,-1

80002914 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002914:	eb cd 40 f8 	pushm	r3-r7,lr
80002918:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000291a:	48 e8       	lddpc	r8,80002950 <payload_rx_process+0x3c>
8000291c:	70 08       	ld.w	r8,r8[0x0]
8000291e:	58 08       	cp.w	r8,0
80002920:	c0 71       	brne	8000292e <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002922:	30 4b       	mov	r11,4
80002924:	30 5c       	mov	r12,5
80002926:	f0 1f 00 0c 	mcall	80002954 <payload_rx_process+0x40>
8000292a:	48 a8       	lddpc	r8,80002950 <payload_rx_process+0x3c>
8000292c:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000292e:	48 96       	lddpc	r6,80002950 <payload_rx_process+0x3c>
80002930:	30 05       	mov	r5,0
80002932:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002934:	48 93       	lddpc	r3,80002958 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002936:	6c 0c       	ld.w	r12,r6[0x0]
80002938:	0a 99       	mov	r9,r5
8000293a:	08 9a       	mov	r10,r4
8000293c:	1a 9b       	mov	r11,sp
8000293e:	f0 1f 00 08 	mcall	8000295c <payload_rx_process+0x48>
80002942:	58 1c       	cp.w	r12,1
80002944:	cf 91       	brne	80002936 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002946:	66 08       	ld.w	r8,r3[0x0]
80002948:	40 0c       	lddsp	r12,sp[0x0]
8000294a:	5d 18       	icall	r8
8000294c:	cf 5b       	rjmp	80002936 <payload_rx_process+0x22>
8000294e:	00 00       	add	r0,r0
80002950:	00 00       	add	r0,r0
80002952:	0a 98       	mov	r8,r5
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	55 24       	stdsp	sp[0x148],r4
80002958:	00 00       	add	r0,r0
8000295a:	0a 68       	and	r8,r5
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	52 18       	stdsp	sp[0x84],r8

80002960 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002960:	d4 01       	pushm	lr
80002962:	20 2d       	sub	sp,8
80002964:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002966:	30 09       	mov	r9,0
80002968:	fa ca ff f8 	sub	r10,sp,-8
8000296c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000296e:	1a 9b       	mov	r11,sp
80002970:	f0 1f 00 02 	mcall	80002978 <set_idle_store_isr+0x18>
}
80002974:	2f ed       	sub	sp,-8
80002976:	d8 02       	popm	pc
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	53 d4       	stdsp	sp[0xf4],r4

8000297c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
8000297c:	d4 01       	pushm	lr
8000297e:	20 2d       	sub	sp,8
80002980:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002982:	58 0c       	cp.w	r12,0
80002984:	c1 10       	breq	800029a6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002986:	30 08       	mov	r8,0
80002988:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000298a:	98 88       	ld.uh	r8,r12[0x0]
8000298c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002990:	e0 48 40 00 	cp.w	r8,16384
80002994:	c0 91       	brne	800029a6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002996:	48 68       	lddpc	r8,800029ac <phy_rx+0x30>
80002998:	70 0c       	ld.w	r12,r8[0x0]
8000299a:	30 09       	mov	r9,0
8000299c:	fa ca ff fc 	sub	r10,sp,-4
800029a0:	1a 9b       	mov	r11,sp
800029a2:	f0 1f 00 04 	mcall	800029b0 <phy_rx+0x34>
		}	

    }
		
 
}
800029a6:	2f ed       	sub	sp,-8
800029a8:	d8 02       	popm	pc
800029aa:	00 00       	add	r0,r0
800029ac:	00 00       	add	r0,r0
800029ae:	0a c8       	st.b	r5++,r8
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	53 d4       	stdsp	sp[0xf4],r4

800029b4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029b4:	eb cd 40 80 	pushm	r7,lr
800029b8:	20 1d       	sub	sp,4
800029ba:	fa c7 ff fc 	sub	r7,sp,-4
800029be:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029c0:	30 09       	mov	r9,0
800029c2:	12 9a       	mov	r10,r9
800029c4:	1a 9b       	mov	r11,sp
800029c6:	f0 1f 00 03 	mcall	800029d0 <set_idle_store+0x1c>
}
800029ca:	2f fd       	sub	sp,-4
800029cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	54 24       	stdsp	sp[0x108],r4

800029d4 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029d4:	d4 01       	pushm	lr
800029d6:	20 1d       	sub	sp,4
800029d8:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029da:	98 88       	ld.uh	r8,r12[0x0]
800029dc:	e2 18 f0 00 	andl	r8,0xf000,COH
800029e0:	e0 48 40 00 	cp.w	r8,16384
800029e4:	c0 d1       	brne	800029fe <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029e6:	49 08       	lddpc	r8,80002a24 <phy_tx+0x50>
800029e8:	70 08       	ld.w	r8,r8[0x0]
800029ea:	58 08       	cp.w	r8,0
800029ec:	c1 a0       	breq	80002a20 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029ee:	48 e8       	lddpc	r8,80002a24 <phy_tx+0x50>
800029f0:	70 0c       	ld.w	r12,r8[0x0]
800029f2:	30 09       	mov	r9,0
800029f4:	12 9a       	mov	r10,r9
800029f6:	1a 9b       	mov	r11,sp
800029f8:	f0 1f 00 0c 	mcall	80002a28 <phy_tx+0x54>
800029fc:	c1 28       	rjmp	80002a20 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800029fe:	e0 48 10 00 	cp.w	r8,4096
80002a02:	5f 0a       	sreq	r10
80002a04:	e0 48 20 00 	cp.w	r8,8192
80002a08:	5f 09       	sreq	r9
80002a0a:	f5 e9 10 09 	or	r9,r10,r9
80002a0e:	c0 71       	brne	80002a1c <phy_tx+0x48>
80002a10:	e0 48 50 00 	cp.w	r8,20480
80002a14:	c0 40       	breq	80002a1c <phy_tx+0x48>
80002a16:	e0 48 60 00 	cp.w	r8,24576
80002a1a:	c0 31       	brne	80002a20 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a1c:	48 48       	lddpc	r8,80002a2c <phy_tx+0x58>
80002a1e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a20:	2f fd       	sub	sp,-4
80002a22:	d8 02       	popm	pc
80002a24:	00 00       	add	r0,r0
80002a26:	0a d4       	st.w	--r5,r4
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	54 24       	stdsp	sp[0x108],r4
80002a2c:	00 00       	add	r0,r0
80002a2e:	0a c4       	st.b	r5++,r4

80002a30 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a30:	d4 01       	pushm	lr
80002a32:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a34:	30 08       	mov	r8,0
80002a36:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a38:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a3a:	1a 9a       	mov	r10,sp
80002a3c:	fa cb ff fc 	sub	r11,sp,-4
80002a40:	f0 1f 00 05 	mcall	80002a54 <get_idle_store_isr+0x24>
80002a44:	58 1c       	cp.w	r12,1
80002a46:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a4a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a4e:	2f ed       	sub	sp,-8
80002a50:	d8 02       	popm	pc
80002a52:	00 00       	add	r0,r0
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	51 28       	stdsp	sp[0x48],r8

80002a58 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a58:	eb cd 40 c0 	pushm	r6-r7,lr
80002a5c:	20 1d       	sub	sp,4
80002a5e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a60:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a64:	70 08       	ld.w	r8,r8[0x0]
80002a66:	58 08       	cp.w	r8,0
80002a68:	c7 40       	breq	80002b50 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a6a:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a6c:	30 08       	mov	r8,0
80002a6e:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a70:	fe f8 04 64 	ld.w	r8,pc[1124]
80002a74:	70 08       	ld.w	r8,r8[0x0]
80002a76:	58 18       	cp.w	r8,1
80002a78:	c2 90       	breq	80002aca <phy_tx_func+0x72>
80002a7a:	c0 43       	brcs	80002a82 <phy_tx_func+0x2a>
80002a7c:	58 28       	cp.w	r8,2
80002a7e:	c6 91       	brne	80002b50 <phy_tx_func+0xf8>
80002a80:	c6 18       	rjmp	80002b42 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a82:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002a86:	70 0c       	ld.w	r12,r8[0x0]
80002a88:	1a 9a       	mov	r10,sp
80002a8a:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002a8e:	f0 1f 01 14 	mcall	80002edc <phy_tx_func+0x484>
80002a92:	58 1c       	cp.w	r12,1
80002a94:	c1 51       	brne	80002abe <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002a96:	fe f8 04 42 	ld.w	r8,pc[1090]
80002a9a:	70 08       	ld.w	r8,r8[0x0]
80002a9c:	11 9a       	ld.ub	r10,r8[0x1]
80002a9e:	fe f9 04 42 	ld.w	r9,pc[1090]
80002aa2:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002aa4:	90 88       	ld.uh	r8,r8[0x0]
80002aa6:	ea 18 ab cd 	orh	r8,0xabcd
80002aaa:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002aac:	30 19       	mov	r9,1
80002aae:	fe f8 04 36 	ld.w	r8,pc[1078]
80002ab2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ab4:	30 19       	mov	r9,1
80002ab6:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002aba:	91 09       	st.w	r8[0x0],r9
80002abc:	c4 a8       	rjmp	80002b50 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002abe:	e0 68 5a 5a 	mov	r8,23130
80002ac2:	ea 18 ab cd 	orh	r8,0xabcd
80002ac6:	8f 18       	st.w	r7[0x4],r8
80002ac8:	c4 48       	rjmp	80002b50 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aca:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002ace:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ad0:	fe fa 04 08 	ld.w	r10,pc[1032]
80002ad4:	74 0a       	ld.w	r10,r10[0x0]
80002ad6:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ada:	b1 6a       	lsl	r10,0x10
80002adc:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ade:	2f f8       	sub	r8,-1
80002ae0:	5c 58       	castu.b	r8
80002ae2:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002ae4:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002ae8:	94 09       	ld.sh	r9,r10[0x0]
80002aea:	20 29       	sub	r9,2
80002aec:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002aee:	30 0a       	mov	r10,0
80002af0:	f4 09 19 00 	cp.h	r9,r10
80002af4:	e0 89 00 0b 	brgt	80002b0a <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002af8:	78 18       	ld.w	r8,r12[0x4]
80002afa:	e8 18 00 ba 	orl	r8,0xba
80002afe:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b00:	30 09       	mov	r9,0
80002b02:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b06:	91 09       	st.w	r8[0x0],r9
80002b08:	c2 48       	rjmp	80002b50 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b0a:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b0e:	72 09       	ld.w	r9,r9[0x0]
80002b10:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b14:	78 1a       	ld.w	r10,r12[0x4]
80002b16:	f5 e9 10 09 	or	r9,r10,r9
80002b1a:	99 19       	st.w	r12[0x4],r9
80002b1c:	2f f8       	sub	r8,-1
80002b1e:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b22:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b24:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b28:	92 08       	ld.sh	r8,r9[0x0]
80002b2a:	20 28       	sub	r8,2
80002b2c:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b2e:	30 09       	mov	r9,0
80002b30:	f2 08 19 00 	cp.h	r8,r9
80002b34:	e0 89 00 0e 	brgt	80002b50 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b38:	30 29       	mov	r9,2
80002b3a:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b3e:	91 09       	st.w	r8[0x0],r9
80002b40:	c0 88       	rjmp	80002b50 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b42:	fc 18 00 ba 	movh	r8,0xba
80002b46:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b48:	30 09       	mov	r9,0
80002b4a:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b4e:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b50:	fe f8 03 98 	ld.w	r8,pc[920]
80002b54:	11 89       	ld.ub	r9,r8[0x0]
80002b56:	30 18       	mov	r8,1
80002b58:	f0 09 18 00 	cp.b	r9,r8
80002b5c:	e0 81 01 af 	brne	80002eba <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b60:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b64:	70 08       	ld.w	r8,r8[0x0]
80002b66:	e0 48 05 b0 	cp.w	r8,1456
80002b6a:	f9 b8 02 00 	movhs	r8,0
80002b6e:	fe f9 03 7e 	ld.w	r9,pc[894]
80002b72:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b74:	fe f8 03 7c 	ld.w	r8,pc[892]
80002b78:	70 08       	ld.w	r8,r8[0x0]
80002b7a:	58 68       	cp.w	r8,6
80002b7c:	e0 8b 01 95 	brhi	80002ea6 <phy_tx_func+0x44e>
80002b80:	fe f9 03 74 	ld.w	r9,pc[884]
80002b84:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002b88:	fe f8 03 70 	ld.w	r8,pc[880]
80002b8c:	70 08       	ld.w	r8,r8[0x0]
80002b8e:	58 08       	cp.w	r8,0
80002b90:	c0 b0       	breq	80002ba6 <phy_tx_func+0x14e>
80002b92:	fe f8 03 66 	ld.w	r8,pc[870]
80002b96:	70 08       	ld.w	r8,r8[0x0]
80002b98:	58 a8       	cp.w	r8,10
80002b9a:	c0 60       	breq	80002ba6 <phy_tx_func+0x14e>
80002b9c:	fe f8 03 5c 	ld.w	r8,pc[860]
80002ba0:	70 08       	ld.w	r8,r8[0x0]
80002ba2:	58 18       	cp.w	r8,1
80002ba4:	c0 a1       	brne	80002bb8 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ba6:	e0 68 5a 5a 	mov	r8,23130
80002baa:	ea 18 ab cd 	orh	r8,0xabcd
80002bae:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bb0:	30 08       	mov	r8,0
80002bb2:	8f 38       	st.w	r7[0xc],r8
80002bb4:	e0 8f 01 8a 	bral	80002ec8 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bb8:	fe f8 03 40 	ld.w	r8,pc[832]
80002bbc:	70 08       	ld.w	r8,r8[0x0]
80002bbe:	58 38       	cp.w	r8,3
80002bc0:	c0 91       	brne	80002bd2 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bc2:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bc6:	70 09       	ld.w	r9,r8[0x0]
80002bc8:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bca:	70 18       	ld.w	r8,r8[0x4]
80002bcc:	8f 38       	st.w	r7[0xc],r8
80002bce:	e0 8f 01 7d 	bral	80002ec8 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bd2:	fe f8 03 26 	ld.w	r8,pc[806]
80002bd6:	70 08       	ld.w	r8,r8[0x0]
80002bd8:	58 28       	cp.w	r8,2
80002bda:	c1 31       	brne	80002c00 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002bdc:	e0 68 c0 32 	mov	r8,49202
80002be0:	ea 18 ab cd 	orh	r8,0xabcd
80002be4:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002be6:	fe 78 84 7f 	mov	r8,-31617
80002bea:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002bec:	fe f8 03 14 	ld.w	r8,pc[788]
80002bf0:	90 08       	ld.sh	r8,r8[0x0]
80002bf2:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002bf4:	30 39       	mov	r9,3
80002bf6:	fe f8 02 fa 	ld.w	r8,pc[762]
80002bfa:	91 09       	st.w	r8[0x0],r9
80002bfc:	e0 8f 01 66 	bral	80002ec8 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c00:	e0 68 c0 0e 	mov	r8,49166
80002c04:	ea 18 ab cd 	orh	r8,0xabcd
80002c08:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c0a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c0e:	90 09       	ld.sh	r9,r8[0x0]
80002c10:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c12:	90 18       	ld.sh	r8,r8[0x2]
80002c14:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c16:	30 19       	mov	r9,1
80002c18:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c1c:	91 09       	st.w	r8[0x0],r9
80002c1e:	e0 8f 01 55 	bral	80002ec8 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c22:	fe 78 88 f2 	mov	r8,-30478
80002c26:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c28:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c2c:	70 08       	ld.w	r8,r8[0x0]
80002c2e:	58 48       	cp.w	r8,4
80002c30:	c0 60       	breq	80002c3c <phy_tx_func+0x1e4>
80002c32:	c4 53       	brcs	80002cbc <phy_tx_func+0x264>
80002c34:	58 98       	cp.w	r8,9
80002c36:	e0 8b 00 43 	brhi	80002cbc <phy_tx_func+0x264>
80002c3a:	c2 98       	rjmp	80002c8c <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c3c:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c40:	11 89       	ld.ub	r9,r8[0x0]
80002c42:	30 18       	mov	r8,1
80002c44:	f0 09 18 00 	cp.b	r9,r8
80002c48:	c0 a1       	brne	80002c5c <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c4a:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c4e:	90 09       	ld.sh	r9,r8[0x0]
80002c50:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c52:	90 19       	ld.sh	r9,r8[0x2]
80002c54:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c56:	90 28       	ld.sh	r8,r8[0x4]
80002c58:	ae 78       	st.h	r7[0xe],r8
80002c5a:	c1 48       	rjmp	80002c82 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c5c:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c60:	92 0b       	ld.sh	r11,r9[0x0]
80002c62:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c66:	90 0a       	ld.sh	r10,r8[0x0]
80002c68:	f7 ea 20 0a 	eor	r10,r11,r10
80002c6c:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c6e:	92 1b       	ld.sh	r11,r9[0x2]
80002c70:	90 1a       	ld.sh	r10,r8[0x2]
80002c72:	f7 ea 20 0a 	eor	r10,r11,r10
80002c76:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c78:	92 29       	ld.sh	r9,r9[0x4]
80002c7a:	90 28       	ld.sh	r8,r8[0x4]
80002c7c:	f3 e8 20 08 	eor	r8,r9,r8
80002c80:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002c82:	30 29       	mov	r9,2
80002c84:	fe f8 02 6c 	ld.w	r8,pc[620]
80002c88:	91 09       	st.w	r8[0x0],r9
80002c8a:	c1 f9       	rjmp	80002ec8 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c8c:	fe f9 02 84 	ld.w	r9,pc[644]
80002c90:	92 0b       	ld.sh	r11,r9[0x0]
80002c92:	fe f8 02 7a 	ld.w	r8,pc[634]
80002c96:	90 0a       	ld.sh	r10,r8[0x0]
80002c98:	f7 ea 20 0a 	eor	r10,r11,r10
80002c9c:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c9e:	92 1b       	ld.sh	r11,r9[0x2]
80002ca0:	90 1a       	ld.sh	r10,r8[0x2]
80002ca2:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca6:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002ca8:	92 29       	ld.sh	r9,r9[0x4]
80002caa:	90 28       	ld.sh	r8,r8[0x4]
80002cac:	f3 e8 20 08 	eor	r8,r9,r8
80002cb0:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cb2:	30 29       	mov	r9,2
80002cb4:	fe f8 02 3c 	ld.w	r8,pc[572]
80002cb8:	91 09       	st.w	r8[0x0],r9
80002cba:	c0 79       	rjmp	80002ec8 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cbc:	e0 68 5a 5a 	mov	r8,23130
80002cc0:	ea 18 ab cd 	orh	r8,0xabcd
80002cc4:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cc6:	30 08       	mov	r8,0
80002cc8:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cca:	fe f9 02 26 	ld.w	r9,pc[550]
80002cce:	93 08       	st.w	r9[0x0],r8
80002cd0:	cf c8       	rjmp	80002ec8 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002cd2:	fe f8 02 3e 	ld.w	r8,pc[574]
80002cd6:	90 38       	ld.sh	r8,r8[0x6]
80002cd8:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002cda:	e0 68 00 ba 	mov	r8,186
80002cde:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002ce0:	30 08       	mov	r8,0
80002ce2:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002ce4:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002ce6:	30 09       	mov	r9,0
80002ce8:	fe f8 02 08 	ld.w	r8,pc[520]
80002cec:	91 09       	st.w	r8[0x0],r9
80002cee:	ce d8       	rjmp	80002ec8 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002cf0:	fe f8 02 10 	ld.w	r8,pc[528]
80002cf4:	90 18       	ld.sh	r8,r8[0x2]
80002cf6:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002cf8:	fe f8 02 0c 	ld.w	r8,pc[524]
80002cfc:	90 08       	ld.sh	r8,r8[0x0]
80002cfe:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d00:	4f e8       	lddpc	r8,80002ef8 <phy_tx_func+0x4a0>
80002d02:	70 08       	ld.w	r8,r8[0x0]
80002d04:	58 48       	cp.w	r8,4
80002d06:	c0 d1       	brne	80002d20 <phy_tx_func+0x2c8>
80002d08:	fe f8 02 00 	ld.w	r8,pc[512]
80002d0c:	11 89       	ld.ub	r9,r8[0x0]
80002d0e:	30 18       	mov	r8,1
80002d10:	f0 09 18 00 	cp.b	r9,r8
80002d14:	c0 61       	brne	80002d20 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d16:	4f c8       	lddpc	r8,80002f04 <phy_tx_func+0x4ac>
80002d18:	90 18       	ld.sh	r8,r8[0x2]
80002d1a:	a9 a8       	sbr	r8,0x8
80002d1c:	ae 68       	st.h	r7[0xc],r8
80002d1e:	c0 48       	rjmp	80002d26 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d20:	4f 98       	lddpc	r8,80002f04 <phy_tx_func+0x4ac>
80002d22:	90 18       	ld.sh	r8,r8[0x2]
80002d24:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d26:	fe 78 9a 13 	mov	r8,-26093
80002d2a:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d2c:	30 49       	mov	r9,4
80002d2e:	4f 18       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002d30:	91 09       	st.w	r8[0x0],r9
80002d32:	cc b8       	rjmp	80002ec8 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d34:	4f 88       	lddpc	r8,80002f14 <phy_tx_func+0x4bc>
80002d36:	70 0a       	ld.w	r10,r8[0x0]
80002d38:	4f 89       	lddpc	r9,80002f18 <phy_tx_func+0x4c0>
80002d3a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d3e:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d40:	70 0a       	ld.w	r10,r8[0x0]
80002d42:	2f fa       	sub	r10,-1
80002d44:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d48:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d4a:	70 0a       	ld.w	r10,r8[0x0]
80002d4c:	2f ea       	sub	r10,-2
80002d4e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d52:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d54:	70 0a       	ld.w	r10,r8[0x0]
80002d56:	2f da       	sub	r10,-3
80002d58:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d5c:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d5e:	70 09       	ld.w	r9,r8[0x0]
80002d60:	2f c9       	sub	r9,-4
80002d62:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d64:	58 c9       	cp.w	r9,12
80002d66:	c0 51       	brne	80002d70 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d68:	30 59       	mov	r9,5
80002d6a:	4e 28       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002d6c:	91 09       	st.w	r8[0x0],r9
80002d6e:	ca d8       	rjmp	80002ec8 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d70:	30 49       	mov	r9,4
80002d72:	4e 08       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002d74:	91 09       	st.w	r8[0x0],r9
80002d76:	ca 98       	rjmp	80002ec8 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d78:	4e 78       	lddpc	r8,80002f14 <phy_tx_func+0x4bc>
80002d7a:	70 0a       	ld.w	r10,r8[0x0]
80002d7c:	4e 79       	lddpc	r9,80002f18 <phy_tx_func+0x4c0>
80002d7e:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d82:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002d84:	30 09       	mov	r9,0
80002d86:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002d88:	fe 78 80 03 	mov	r8,-32765
80002d8c:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002d8e:	fe 78 88 f3 	mov	r8,-30477
80002d92:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002d94:	4d 98       	lddpc	r8,80002ef8 <phy_tx_func+0x4a0>
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	58 48       	cp.w	r8,4
80002d9a:	c0 60       	breq	80002da6 <phy_tx_func+0x34e>
80002d9c:	c2 83       	brcs	80002dec <phy_tx_func+0x394>
80002d9e:	58 98       	cp.w	r8,9
80002da0:	e0 8b 00 26 	brhi	80002dec <phy_tx_func+0x394>
80002da4:	c1 98       	rjmp	80002dd6 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002da6:	4d 98       	lddpc	r8,80002f08 <phy_tx_func+0x4b0>
80002da8:	11 89       	ld.ub	r9,r8[0x0]
80002daa:	30 18       	mov	r8,1
80002dac:	f0 09 18 00 	cp.b	r9,r8
80002db0:	c0 81       	brne	80002dc0 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002db2:	4d 88       	lddpc	r8,80002f10 <phy_tx_func+0x4b8>
80002db4:	90 0a       	ld.sh	r10,r8[0x0]
80002db6:	4d a9       	lddpc	r9,80002f1c <phy_tx_func+0x4c4>
80002db8:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dba:	90 08       	ld.sh	r8,r8[0x0]
80002dbc:	ae 78       	st.h	r7[0xe],r8
80002dbe:	c0 88       	rjmp	80002dce <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dc0:	4d 78       	lddpc	r8,80002f1c <phy_tx_func+0x4c4>
80002dc2:	90 08       	ld.sh	r8,r8[0x0]
80002dc4:	4d 39       	lddpc	r9,80002f10 <phy_tx_func+0x4b8>
80002dc6:	92 09       	ld.sh	r9,r9[0x0]
80002dc8:	f3 e8 20 08 	eor	r8,r9,r8
80002dcc:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dce:	30 69       	mov	r9,6
80002dd0:	4c 88       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002dd2:	91 09       	st.w	r8[0x0],r9
80002dd4:	c7 a8       	rjmp	80002ec8 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dd6:	4d 28       	lddpc	r8,80002f1c <phy_tx_func+0x4c4>
80002dd8:	90 08       	ld.sh	r8,r8[0x0]
80002dda:	4c e9       	lddpc	r9,80002f10 <phy_tx_func+0x4b8>
80002ddc:	92 09       	ld.sh	r9,r9[0x0]
80002dde:	f3 e8 20 08 	eor	r8,r9,r8
80002de2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002de4:	30 69       	mov	r9,6
80002de6:	4c 38       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002de8:	91 09       	st.w	r8[0x0],r9
80002dea:	c6 f8       	rjmp	80002ec8 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002dec:	e0 68 5a 5a 	mov	r8,23130
80002df0:	ea 18 ab cd 	orh	r8,0xabcd
80002df4:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002df6:	30 08       	mov	r8,0
80002df8:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002dfa:	4b e9       	lddpc	r9,80002ef0 <phy_tx_func+0x498>
80002dfc:	93 08       	st.w	r9[0x0],r8
80002dfe:	c6 58       	rjmp	80002ec8 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e00:	4b e8       	lddpc	r8,80002ef8 <phy_tx_func+0x4a0>
80002e02:	70 08       	ld.w	r8,r8[0x0]
80002e04:	58 48       	cp.w	r8,4
80002e06:	c0 60       	breq	80002e12 <phy_tx_func+0x3ba>
80002e08:	c4 53       	brcs	80002e92 <phy_tx_func+0x43a>
80002e0a:	58 98       	cp.w	r8,9
80002e0c:	e0 8b 00 43 	brhi	80002e92 <phy_tx_func+0x43a>
80002e10:	c2 d8       	rjmp	80002e6a <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e12:	4b e8       	lddpc	r8,80002f08 <phy_tx_func+0x4b0>
80002e14:	11 89       	ld.ub	r9,r8[0x0]
80002e16:	30 18       	mov	r8,1
80002e18:	f0 09 18 00 	cp.b	r9,r8
80002e1c:	c1 31       	brne	80002e42 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e1e:	4b d8       	lddpc	r8,80002f10 <phy_tx_func+0x4b8>
80002e20:	90 1a       	ld.sh	r10,r8[0x2]
80002e22:	4b f9       	lddpc	r9,80002f1c <phy_tx_func+0x4c4>
80002e24:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e26:	90 2a       	ld.sh	r10,r8[0x4]
80002e28:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e2a:	90 3a       	ld.sh	r10,r8[0x6]
80002e2c:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e2e:	90 19       	ld.sh	r9,r8[0x2]
80002e30:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e32:	90 29       	ld.sh	r9,r8[0x4]
80002e34:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e36:	90 38       	ld.sh	r8,r8[0x6]
80002e38:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e3a:	e0 68 00 ba 	mov	r8,186
80002e3e:	ae 78       	st.h	r7[0xe],r8
80002e40:	c1 18       	rjmp	80002e62 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e42:	4b 48       	lddpc	r8,80002f10 <phy_tx_func+0x4b8>
80002e44:	90 1a       	ld.sh	r10,r8[0x2]
80002e46:	4b 69       	lddpc	r9,80002f1c <phy_tx_func+0x4c4>
80002e48:	92 1b       	ld.sh	r11,r9[0x2]
80002e4a:	f7 ea 20 0a 	eor	r10,r11,r10
80002e4e:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e50:	90 2a       	ld.sh	r10,r8[0x4]
80002e52:	92 29       	ld.sh	r9,r9[0x4]
80002e54:	14 59       	eor	r9,r10
80002e56:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e58:	90 38       	ld.sh	r8,r8[0x6]
80002e5a:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e5c:	e0 68 00 ba 	mov	r8,186
80002e60:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e62:	30 09       	mov	r9,0
80002e64:	4a 38       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002e66:	91 09       	st.w	r8[0x0],r9
80002e68:	c3 08       	rjmp	80002ec8 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e6a:	4a a8       	lddpc	r8,80002f10 <phy_tx_func+0x4b8>
80002e6c:	90 1a       	ld.sh	r10,r8[0x2]
80002e6e:	4a c9       	lddpc	r9,80002f1c <phy_tx_func+0x4c4>
80002e70:	92 1b       	ld.sh	r11,r9[0x2]
80002e72:	f7 ea 20 0a 	eor	r10,r11,r10
80002e76:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e78:	90 2a       	ld.sh	r10,r8[0x4]
80002e7a:	92 29       	ld.sh	r9,r9[0x4]
80002e7c:	14 59       	eor	r9,r10
80002e7e:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e80:	90 38       	ld.sh	r8,r8[0x6]
80002e82:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002e84:	e0 68 00 ba 	mov	r8,186
80002e88:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e8a:	30 09       	mov	r9,0
80002e8c:	49 98       	lddpc	r8,80002ef0 <phy_tx_func+0x498>
80002e8e:	91 09       	st.w	r8[0x0],r9
80002e90:	c1 c8       	rjmp	80002ec8 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e92:	e0 68 5a 5a 	mov	r8,23130
80002e96:	ea 18 ab cd 	orh	r8,0xabcd
80002e9a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e9c:	30 08       	mov	r8,0
80002e9e:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ea0:	49 49       	lddpc	r9,80002ef0 <phy_tx_func+0x498>
80002ea2:	93 08       	st.w	r9[0x0],r8
80002ea4:	c1 28       	rjmp	80002ec8 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ea6:	e0 68 5a 5a 	mov	r8,23130
80002eaa:	ea 18 ab cd 	orh	r8,0xabcd
80002eae:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002eb0:	30 08       	mov	r8,0
80002eb2:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002eb4:	48 f9       	lddpc	r9,80002ef0 <phy_tx_func+0x498>
80002eb6:	93 08       	st.w	r9[0x0],r8
80002eb8:	c0 88       	rjmp	80002ec8 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eba:	e0 68 5a 5a 	mov	r8,23130
80002ebe:	ea 18 ab cd 	orh	r8,0xabcd
80002ec2:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ec4:	30 08       	mov	r8,0
80002ec6:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ec8:	2f fd       	sub	sp,-4
80002eca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ece:	00 00       	add	r0,r0
80002ed0:	00 00       	add	r0,r0
80002ed2:	0a d4       	st.w	--r5,r4
80002ed4:	00 00       	add	r0,r0
80002ed6:	0a ac       	st.w	r5++,r12
80002ed8:	00 00       	add	r0,r0
80002eda:	0a 88       	andn	r8,r5
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	51 28       	stdsp	sp[0x48],r8
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a cc       	st.b	r5++,r12
80002ee4:	00 00       	add	r0,r0
80002ee6:	0a 91       	mov	r1,r5
80002ee8:	00 00       	add	r0,r0
80002eea:	0a 5f       	eor	pc,r5
80002eec:	00 00       	add	r0,r0
80002eee:	0a 84       	andn	r4,r5
80002ef0:	00 00       	add	r0,r0
80002ef2:	0a bc       	st.h	r5++,r12
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	c7 64       	brge	80002fe2 <phy_init+0x9a>
80002ef8:	00 00       	add	r0,r0
80002efa:	0a 78       	tst	r8,r5
80002efc:	00 00       	add	r0,r0
80002efe:	0a dc       	st.w	--r5,r12
80002f00:	00 00       	add	r0,r0
80002f02:	0d 8c       	ld.ub	r12,r6[0x0]
80002f04:	00 00       	add	r0,r0
80002f06:	0e 88       	andn	r8,r7
80002f08:	00 00       	add	r0,r0
80002f0a:	0a 50       	eor	r0,r5
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	c7 06       	brmi	80002fee <phy_init+0xa6>
80002f10:	00 00       	add	r0,r0
80002f12:	0d 84       	ld.ub	r4,r6[0x0]
80002f14:	00 00       	add	r0,r0
80002f16:	0a a8       	st.w	r5++,r8
80002f18:	00 00       	add	r0,r0
80002f1a:	0e 8c       	andn	r12,r7
80002f1c:	00 00       	add	r0,r0
80002f1e:	0d 90       	ld.ub	r0,r6[0x1]

80002f20 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f20:	d4 01       	pushm	lr
80002f22:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f24:	30 0a       	mov	r10,0
80002f26:	fa cb ff fc 	sub	r11,sp,-4
80002f2a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f2c:	14 99       	mov	r9,r10
80002f2e:	1a 9b       	mov	r11,sp
80002f30:	f0 1f 00 05 	mcall	80002f44 <get_idle_store+0x24>
80002f34:	58 1c       	cp.w	r12,1
80002f36:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f3a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f3e:	2f fd       	sub	sp,-4
80002f40:	d8 02       	popm	pc
80002f42:	00 00       	add	r0,r0
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	52 18       	stdsp	sp[0x84],r8

80002f48 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f48:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f4c:	f0 1f 00 21 	mcall	80002fd0 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f50:	4a 1b       	lddpc	r11,80002fd4 <phy_init+0x8c>
80002f52:	4a 2c       	lddpc	r12,80002fd8 <phy_init+0x90>
80002f54:	f0 1f 00 22 	mcall	80002fdc <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f58:	30 4b       	mov	r11,4
80002f5a:	31 ec       	mov	r12,30
80002f5c:	f0 1f 00 21 	mcall	80002fe0 <phy_init+0x98>
80002f60:	4a 18       	lddpc	r8,80002fe4 <phy_init+0x9c>
80002f62:	91 0c       	st.w	r8[0x0],r12
80002f64:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f66:	10 96       	mov	r6,r8
80002f68:	4a 05       	lddpc	r5,80002fe8 <phy_init+0xa0>
80002f6a:	6c 0c       	ld.w	r12,r6[0x0]
80002f6c:	ea 07 00 0b 	add	r11,r5,r7
80002f70:	f0 1f 00 1f 	mcall	80002fec <phy_init+0xa4>
80002f74:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f78:	e0 47 1e 00 	cp.w	r7,7680
80002f7c:	cf 71       	brne	80002f6a <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f7e:	30 4b       	mov	r11,4
80002f80:	31 4c       	mov	r12,20
80002f82:	f0 1f 00 18 	mcall	80002fe0 <phy_init+0x98>
80002f86:	49 b8       	lddpc	r8,80002ff0 <phy_init+0xa8>
80002f88:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f8a:	30 4b       	mov	r11,4
80002f8c:	30 ac       	mov	r12,10
80002f8e:	f0 1f 00 15 	mcall	80002fe0 <phy_init+0x98>
80002f92:	49 98       	lddpc	r8,80002ff4 <phy_init+0xac>
80002f94:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002f96:	30 4b       	mov	r11,4
80002f98:	30 ac       	mov	r12,10
80002f9a:	f0 1f 00 12 	mcall	80002fe0 <phy_init+0x98>
80002f9e:	49 78       	lddpc	r8,80002ff8 <phy_init+0xb0>
80002fa0:	91 0c       	st.w	r8[0x0],r12
80002fa2:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002fa4:	10 96       	mov	r6,r8
80002fa6:	49 65       	lddpc	r5,80002ffc <phy_init+0xb4>
80002fa8:	6c 0c       	ld.w	r12,r6[0x0]
80002faa:	ea 07 00 0b 	add	r11,r5,r7
80002fae:	f0 1f 00 10 	mcall	80002fec <phy_init+0xa4>
80002fb2:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002fb6:	e0 47 14 00 	cp.w	r7,5120
80002fba:	cf 71       	brne	80002fa8 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002fbc:	e0 6b 01 00 	mov	r11,256
80002fc0:	30 5c       	mov	r12,5
80002fc2:	f0 1f 00 08 	mcall	80002fe0 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002fc6:	48 f8       	lddpc	r8,80003000 <phy_init+0xb8>
80002fc8:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002fca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fce:	00 00       	add	r0,r0
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	3d f4       	mov	r4,-33
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	2a 58       	sub	r8,-91
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	30 64       	mov	r4,6
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	3d e0       	mov	r0,-34
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	55 24       	stdsp	sp[0x148],r4
80002fe4:	00 00       	add	r0,r0
80002fe6:	0a a0       	st.w	r5++,r0
80002fe8:	00 00       	add	r0,r0
80002fea:	22 a6       	sub	r6,42
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	29 b4       	sub	r4,-101
80002ff0:	00 00       	add	r0,r0
80002ff2:	0a d4       	st.w	--r5,r4
80002ff4:	00 00       	add	r0,r0
80002ff6:	0a c8       	st.b	r5++,r8
80002ff8:	00 00       	add	r0,r0
80002ffa:	0a 7c       	tst	r12,r5
80002ffc:	00 00       	add	r0,r0
80002ffe:	0e a6       	st.w	r7++,r6
80003000:	00 00       	add	r0,r0
80003002:	0a c4       	st.b	r5++,r4

80003004 <payload_rx>:




static void payload_rx(void * payload)
{
80003004:	d4 01       	pushm	lr
80003006:	20 2d       	sub	sp,8
80003008:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000300a:	30 08       	mov	r8,0
8000300c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000300e:	48 f8       	lddpc	r8,80003048 <payload_rx+0x44>
80003010:	70 08       	ld.w	r8,r8[0x0]
80003012:	58 08       	cp.w	r8,0
80003014:	c0 71       	brne	80003022 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003016:	30 4b       	mov	r11,4
80003018:	30 5c       	mov	r12,5
8000301a:	f0 1f 00 0d 	mcall	8000304c <payload_rx+0x48>
8000301e:	48 b8       	lddpc	r8,80003048 <payload_rx+0x44>
80003020:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80003022:	48 a8       	lddpc	r8,80003048 <payload_rx+0x44>
80003024:	70 0c       	ld.w	r12,r8[0x0]
80003026:	30 09       	mov	r9,0
80003028:	fa ca ff fc 	sub	r10,sp,-4
8000302c:	1a 9b       	mov	r11,sp
8000302e:	f0 1f 00 09 	mcall	80003050 <payload_rx+0x4c>
80003032:	c0 91       	brne	80003044 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003034:	48 88       	lddpc	r8,80003054 <payload_rx+0x50>
80003036:	70 0c       	ld.w	r12,r8[0x0]
80003038:	40 0b       	lddsp	r11,sp[0x0]
8000303a:	f0 1f 00 08 	mcall	80003058 <payload_rx+0x54>
		logFromISR("mm");
8000303e:	48 8c       	lddpc	r12,8000305c <payload_rx+0x58>
80003040:	f0 1f 00 08 	mcall	80003060 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003044:	2f ed       	sub	sp,-8
80003046:	d8 02       	popm	pc
80003048:	00 00       	add	r0,r0
8000304a:	0a 98       	mov	r8,r5
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	55 24       	stdsp	sp[0x148],r4
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	53 d4       	stdsp	sp[0xf4],r4
80003054:	00 00       	add	r0,r0
80003056:	0a 7c       	tst	r12,r5
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	29 60       	sub	r0,-106
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	c7 80       	breq	8000314e <phy_rx_func+0xea>
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	61 48       	ld.w	r8,r0[0x50]

80003064 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003064:	eb cd 40 e0 	pushm	r5-r7,lr
80003068:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000306a:	fe f8 0b be 	ld.w	r8,pc[3006]
8000306e:	70 08       	ld.w	r8,r8[0x0]
80003070:	58 08       	cp.w	r8,0
80003072:	e0 80 01 05 	breq	8000327c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003076:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003078:	fe f8 0b b4 	ld.w	r8,pc[2996]
8000307c:	70 09       	ld.w	r9,r8[0x0]
8000307e:	2f f9       	sub	r9,-1
80003080:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003082:	fe f8 0b ae 	ld.w	r8,pc[2990]
80003086:	70 08       	ld.w	r8,r8[0x0]
80003088:	58 18       	cp.w	r8,1
8000308a:	e0 80 00 84 	breq	80003192 <phy_rx_func+0x12e>
8000308e:	c0 73       	brcs	8000309c <phy_rx_func+0x38>
80003090:	58 28       	cp.w	r8,2
80003092:	c5 b0       	breq	80003148 <phy_rx_func+0xe4>
80003094:	58 38       	cp.w	r8,3
80003096:	e0 81 00 f3 	brne	8000327c <phy_rx_func+0x218>
8000309a:	cd 38       	rjmp	80003240 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000309c:	e0 6a 5a 5a 	mov	r10,23130
800030a0:	ea 1a ab cd 	orh	r10,0xabcd
800030a4:	14 36       	cp.w	r6,r10
800030a6:	e0 80 00 eb 	breq	8000327c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030aa:	ec 08 16 10 	lsr	r8,r6,0x10
800030ae:	e0 48 ab cd 	cp.w	r8,43981
800030b2:	e0 81 00 e5 	brne	8000327c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030b6:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030ba:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030be:	20 28       	sub	r8,2
800030c0:	fe f9 0b 74 	ld.w	r9,pc[2932]
800030c4:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030c6:	30 09       	mov	r9,0
800030c8:	f2 08 19 00 	cp.h	r8,r9
800030cc:	e0 8a 00 d8 	brle	8000327c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030d0:	fe f8 0b 68 	ld.w	r8,pc[2920]
800030d4:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030d6:	fe f8 0b 66 	ld.w	r8,pc[2918]
800030da:	70 0c       	ld.w	r12,r8[0x0]
800030dc:	f0 1f 02 d9 	mcall	80003c40 <phy_rx_func+0xbdc>
800030e0:	fe f8 0b 64 	ld.w	r8,pc[2916]
800030e4:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030e6:	58 0c       	cp.w	r12,0
800030e8:	e0 80 00 ca 	breq	8000327c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030ec:	fe f8 0b 4c 	ld.w	r8,pc[2892]
800030f0:	90 09       	ld.sh	r9,r8[0x0]
800030f2:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800030f6:	2f f9       	sub	r9,-1
800030f8:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800030fa:	fe fa 0b 4a 	ld.w	r10,pc[2890]
800030fe:	74 0a       	ld.w	r10,r10[0x0]
80003100:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003104:	76 0b       	ld.w	r11,r11[0x0]
80003106:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000310a:	2f f9       	sub	r9,-1
8000310c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000310e:	e2 16 0f 00 	andl	r6,0xf00,COH
80003112:	e0 46 01 00 	cp.w	r6,256
80003116:	c0 c0       	breq	8000312e <phy_rx_func+0xca>
80003118:	e0 8b 00 05 	brhi	80003122 <phy_rx_func+0xbe>
8000311c:	58 06       	cp.w	r6,0
8000311e:	c0 80       	breq	8000312e <phy_rx_func+0xca>
80003120:	c0 c8       	rjmp	80003138 <phy_rx_func+0xd4>
80003122:	e0 46 02 00 	cp.w	r6,512
80003126:	c0 40       	breq	8000312e <phy_rx_func+0xca>
80003128:	e0 46 03 00 	cp.w	r6,768
8000312c:	c0 61       	brne	80003138 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000312e:	30 29       	mov	r9,2
80003130:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003134:	91 09       	st.w	r8[0x0],r9
80003136:	ca 38       	rjmp	8000327c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003138:	fe f6 0b 0c 	ld.w	r6,pc[2828]
8000313c:	6c 0c       	ld.w	r12,r6[0x0]
8000313e:	f0 1f 02 c3 	mcall	80003c48 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
80003142:	30 08       	mov	r8,0
80003144:	8d 08       	st.w	r6[0x0],r8
80003146:	c9 b8       	rjmp	8000327c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003148:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000314c:	b1 86       	lsr	r6,0x10
8000314e:	14 06       	add	r6,r10
80003150:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003154:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003156:	fe f8 0a e2 	ld.w	r8,pc[2786]
8000315a:	90 09       	ld.sh	r9,r8[0x0]
8000315c:	fe fb 0a e8 	ld.w	r11,pc[2792]
80003160:	76 0b       	ld.w	r11,r11[0x0]
80003162:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003166:	2f f9       	sub	r9,-1
80003168:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000316a:	fe f9 0a ca 	ld.w	r9,pc[2762]
8000316e:	92 08       	ld.sh	r8,r9[0x0]
80003170:	20 28       	sub	r8,2
80003172:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003174:	30 09       	mov	r9,0
80003176:	f2 08 19 00 	cp.h	r8,r9
8000317a:	e0 8a 00 07 	brle	80003188 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000317e:	30 19       	mov	r9,1
80003180:	fe f8 0a b0 	ld.w	r8,pc[2736]
80003184:	91 09       	st.w	r8[0x0],r9
80003186:	c7 b8       	rjmp	8000327c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003188:	30 39       	mov	r9,3
8000318a:	fe f8 0a a6 	ld.w	r8,pc[2726]
8000318e:	91 09       	st.w	r8[0x0],r9
80003190:	c7 68       	rjmp	8000327c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003192:	ec 0a 14 10 	asr	r10,r6,0x10
80003196:	fe f8 0a b6 	ld.w	r8,pc[2742]
8000319a:	90 09       	ld.sh	r9,r8[0x0]
8000319c:	14 09       	add	r9,r10
8000319e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031a0:	fe f9 0a 98 	ld.w	r9,pc[2712]
800031a4:	92 08       	ld.sh	r8,r9[0x0]
800031a6:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800031aa:	76 0b       	ld.w	r11,r11[0x0]
800031ac:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031b0:	2f f8       	sub	r8,-1
800031b2:	5c 88       	casts.h	r8
800031b4:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031b6:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800031ba:	94 09       	ld.sh	r9,r10[0x0]
800031bc:	20 29       	sub	r9,2
800031be:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031c0:	30 0a       	mov	r10,0
800031c2:	f4 09 19 00 	cp.h	r9,r10
800031c6:	e0 89 00 1f 	brgt	80003204 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031ca:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031ce:	e0 46 00 ba 	cp.w	r6,186
800031d2:	c0 d1       	brne	800031ec <phy_rx_func+0x188>
800031d4:	fe f8 0a 78 	ld.w	r8,pc[2680]
800031d8:	90 09       	ld.sh	r9,r8[0x0]
800031da:	f4 09 19 00 	cp.h	r9,r10
800031de:	c0 71       	brne	800031ec <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031e0:	fe f8 0a 64 	ld.w	r8,pc[2660]
800031e4:	70 0c       	ld.w	r12,r8[0x0]
800031e6:	f0 1f 02 9b 	mcall	80003c50 <phy_rx_func+0xbec>
800031ea:	c0 88       	rjmp	800031fa <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800031ec:	fe f6 0a 58 	ld.w	r6,pc[2648]
800031f0:	6c 0c       	ld.w	r12,r6[0x0]
800031f2:	f0 1f 02 96 	mcall	80003c48 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
800031f6:	30 08       	mov	r8,0
800031f8:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800031fa:	30 09       	mov	r9,0
800031fc:	fe f8 0a 34 	ld.w	r8,pc[2612]
80003200:	91 09       	st.w	r8[0x0],r9
80003202:	c3 d8       	rjmp	8000327c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003204:	5c 86       	casts.h	r6
80003206:	fe f9 0a 46 	ld.w	r9,pc[2630]
8000320a:	92 0a       	ld.sh	r10,r9[0x0]
8000320c:	0c 0a       	add	r10,r6
8000320e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003210:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003214:	72 09       	ld.w	r9,r9[0x0]
80003216:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000321a:	2f f8       	sub	r8,-1
8000321c:	fe f9 0a 1c 	ld.w	r9,pc[2588]
80003220:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003222:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003226:	92 08       	ld.sh	r8,r9[0x0]
80003228:	20 28       	sub	r8,2
8000322a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000322c:	30 09       	mov	r9,0
8000322e:	f2 08 19 00 	cp.h	r8,r9
80003232:	e0 89 00 25 	brgt	8000327c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003236:	30 39       	mov	r9,3
80003238:	fe f8 09 f8 	ld.w	r8,pc[2552]
8000323c:	91 09       	st.w	r8[0x0],r9
8000323e:	c1 f8       	rjmp	8000327c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003240:	e6 16 00 ff 	andh	r6,0xff,COH
80003244:	fc 19 00 ba 	movh	r9,0xba
80003248:	12 36       	cp.w	r6,r9
8000324a:	c0 e1       	brne	80003266 <phy_rx_func+0x202>
8000324c:	fe f8 0a 00 	ld.w	r8,pc[2560]
80003250:	90 09       	ld.sh	r9,r8[0x0]
80003252:	30 08       	mov	r8,0
80003254:	f0 09 19 00 	cp.h	r9,r8
80003258:	c0 71       	brne	80003266 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000325a:	fe f8 09 ea 	ld.w	r8,pc[2538]
8000325e:	70 0c       	ld.w	r12,r8[0x0]
80003260:	f0 1f 02 7c 	mcall	80003c50 <phy_rx_func+0xbec>
80003264:	c0 88       	rjmp	80003274 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003266:	fe f6 09 de 	ld.w	r6,pc[2526]
8000326a:	6c 0c       	ld.w	r12,r6[0x0]
8000326c:	f0 1f 02 77 	mcall	80003c48 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
80003270:	30 08       	mov	r8,0
80003272:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003274:	30 09       	mov	r9,0
80003276:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000327a:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
8000327c:	fe f8 09 d8 	ld.w	r8,pc[2520]
80003280:	11 89       	ld.ub	r9,r8[0x0]
80003282:	30 08       	mov	r8,0
80003284:	f0 09 18 00 	cp.b	r9,r8
80003288:	c0 d1       	brne	800032a2 <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
8000328a:	fe f8 09 ce 	ld.w	r8,pc[2510]
8000328e:	70 0c       	ld.w	r12,r8[0x0]
80003290:	f0 1f 02 6c 	mcall	80003c40 <phy_rx_func+0xbdc>
80003294:	fe f8 09 c8 	ld.w	r8,pc[2504]
80003298:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000329a:	30 19       	mov	r9,1
8000329c:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032a0:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032a2:	fe f8 09 be 	ld.w	r8,pc[2494]
800032a6:	70 08       	ld.w	r8,r8[0x0]
800032a8:	58 38       	cp.w	r8,3
800032aa:	e0 80 04 7a 	breq	80003b9e <phy_rx_func+0xb3a>
800032ae:	58 48       	cp.w	r8,4
800032b0:	e0 80 01 02 	breq	800034b4 <phy_rx_func+0x450>
800032b4:	58 08       	cp.w	r8,0
800032b6:	e0 81 04 b7 	brne	80003c24 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032ba:	6e 28       	ld.w	r8,r7[0x8]
800032bc:	e0 6a 5a 5a 	mov	r10,23130
800032c0:	ea 1a ab cd 	orh	r10,0xabcd
800032c4:	14 38       	cp.w	r8,r10
800032c6:	c0 71       	brne	800032d4 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800032c8:	30 09       	mov	r9,0
800032ca:	fe f8 09 9a 	ld.w	r8,pc[2458]
800032ce:	91 09       	st.w	r8[0x0],r9
800032d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032d4:	10 99       	mov	r9,r8
800032d6:	e0 19 00 00 	andl	r9,0x0
800032da:	fc 1a ab cd 	movh	r10,0xabcd
800032de:	14 39       	cp.w	r9,r10
800032e0:	e0 81 04 a2 	brne	80003c24 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032e4:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032e8:	fe f9 09 80 	ld.w	r9,pc[2432]
800032ec:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
800032ee:	fe f8 09 6e 	ld.w	r8,pc[2414]
800032f2:	70 08       	ld.w	r8,r8[0x0]
800032f4:	58 08       	cp.w	r8,0
800032f6:	c1 11       	brne	80003318 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
800032f8:	fe f8 09 60 	ld.w	r8,pc[2400]
800032fc:	70 0c       	ld.w	r12,r8[0x0]
800032fe:	f0 1f 02 51 	mcall	80003c40 <phy_rx_func+0xbdc>
80003302:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003306:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003308:	58 0c       	cp.w	r12,0
8000330a:	c0 71       	brne	80003318 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000330c:	fe fc 09 60 	ld.w	r12,pc[2400]
80003310:	f0 1f 02 58 	mcall	80003c70 <phy_rx_func+0xc0c>
80003314:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003318:	6e 28       	ld.w	r8,r7[0x8]
8000331a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000331e:	e0 48 c0 00 	cp.w	r8,49152
80003322:	e0 81 00 c3 	brne	800034a8 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003326:	30 19       	mov	r9,1
80003328:	fe f8 09 4c 	ld.w	r8,pc[2380]
8000332c:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000332e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003332:	fe f8 09 46 	ld.w	r8,pc[2374]
80003336:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003338:	ef 3a 00 0c 	ld.ub	r10,r7[12]
8000333c:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003340:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003344:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003346:	11 88       	ld.ub	r8,r8[0x0]
80003348:	37 f9       	mov	r9,127
8000334a:	f2 08 18 00 	cp.b	r8,r9
8000334e:	c6 d0       	breq	80003428 <phy_rx_func+0x3c4>
80003350:	e0 8b 00 0c 	brhi	80003368 <phy_rx_func+0x304>
80003354:	31 29       	mov	r9,18
80003356:	f2 08 18 00 	cp.b	r8,r9
8000335a:	c4 20       	breq	800033de <phy_rx_func+0x37a>
8000335c:	31 39       	mov	r9,19
8000335e:	f2 08 18 00 	cp.b	r8,r9
80003362:	e0 81 00 83 	brne	80003468 <phy_rx_func+0x404>
80003366:	c5 b8       	rjmp	8000341c <phy_rx_func+0x3b8>
80003368:	2f 08       	sub	r8,-16
8000336a:	30 19       	mov	r9,1
8000336c:	f2 08 18 00 	cp.b	r8,r9
80003370:	e0 8b 00 7c 	brhi	80003468 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003374:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003378:	e2 18 00 f0 	andl	r8,0xf0,COH
8000337c:	59 08       	cp.w	r8,16
8000337e:	c0 71       	brne	8000338c <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
80003380:	30 19       	mov	r9,1
80003382:	fe f8 08 e2 	ld.w	r8,pc[2274]
80003386:	91 09       	st.w	r8[0x0],r9
80003388:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000338c:	e0 48 00 20 	cp.w	r8,32
80003390:	c2 11       	brne	800033d2 <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
80003392:	30 a9       	mov	r9,10
80003394:	fe f8 08 d0 	ld.w	r8,pc[2256]
80003398:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000339a:	fe f6 08 e6 	ld.w	r6,pc[2278]
8000339e:	6c 08       	ld.w	r8,r6[0x0]
800033a0:	f0 0a 11 ff 	rsub	r10,r8,-1
800033a4:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033a8:	2f f8       	sub	r8,-1
800033aa:	6e 0c       	ld.w	r12,r7[0x0]
800033ac:	f4 ca fe 00 	sub	r10,r10,-512
800033b0:	30 0b       	mov	r11,0
800033b2:	10 0c       	add	r12,r8
800033b4:	f0 1f 02 34 	mcall	80003c84 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800033b8:	30 08       	mov	r8,0
800033ba:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033bc:	6e 0c       	ld.w	r12,r7[0x0]
800033be:	f0 1f 02 33 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800033c2:	fe f8 08 96 	ld.w	r8,pc[2198]
800033c6:	70 0c       	ld.w	r12,r8[0x0]
800033c8:	f0 1f 02 1e 	mcall	80003c40 <phy_rx_func+0xbdc>
800033cc:	8f 0c       	st.w	r7[0x0],r12
800033ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033d2:	30 09       	mov	r9,0
800033d4:	fe f8 08 90 	ld.w	r8,pc[2192]
800033d8:	91 09       	st.w	r8[0x0],r9
800033da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033de:	fe f9 08 8a 	ld.w	r9,pc[2186]
800033e2:	72 08       	ld.w	r8,r9[0x0]
800033e4:	20 48       	sub	r8,4
800033e6:	93 08       	st.w	r9[0x0],r8
800033e8:	e0 80 04 1e 	breq	80003c24 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800033ec:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033f0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800033f4:	fe f8 08 98 	ld.w	r8,pc[2200]
800033f8:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800033fa:	8e 69       	ld.sh	r9,r7[0xc]
800033fc:	fe f8 08 94 	ld.w	r8,pc[2196]
80003400:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003402:	8e 79       	ld.sh	r9,r7[0xe]
80003404:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003406:	f0 1f 02 24 	mcall	80003c94 <phy_rx_func+0xc30>
8000340a:	fe f8 08 5a 	ld.w	r8,pc[2138]
8000340e:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003410:	30 49       	mov	r9,4
80003412:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003416:	91 09       	st.w	r8[0x0],r9
80003418:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000341c:	30 09       	mov	r9,0
8000341e:	fe f8 08 46 	ld.w	r8,pc[2118]
80003422:	91 09       	st.w	r8[0x0],r9
80003424:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003428:	fe f9 08 40 	ld.w	r9,pc[2112]
8000342c:	72 08       	ld.w	r8,r9[0x0]
8000342e:	20 48       	sub	r8,4
80003430:	93 08       	st.w	r9[0x0],r8
80003432:	e0 80 03 f9 	breq	80003c24 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003436:	fe f8 08 62 	ld.w	r8,pc[2146]
8000343a:	70 09       	ld.w	r9,r8[0x0]
8000343c:	8e 7b       	ld.sh	r11,r7[0xe]
8000343e:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003442:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003446:	2f f9       	sub	r9,-1
80003448:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000344a:	fe f8 08 32 	ld.w	r8,pc[2098]
8000344e:	70 09       	ld.w	r9,r8[0x0]
80003450:	20 29       	sub	r9,2
80003452:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003454:	30 29       	mov	r9,2
80003456:	fe f8 08 0e 	ld.w	r8,pc[2062]
8000345a:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000345c:	30 39       	mov	r9,3
8000345e:	fe f8 08 02 	ld.w	r8,pc[2050]
80003462:	91 09       	st.w	r8[0x0],r9
80003464:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003468:	30 39       	mov	r9,3
8000346a:	fe f8 07 fa 	ld.w	r8,pc[2042]
8000346e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003470:	6e 29       	ld.w	r9,r7[0x8]
80003472:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003476:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003478:	6e 39       	ld.w	r9,r7[0xc]
8000347a:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
8000347c:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003480:	70 08       	ld.w	r8,r8[0x0]
80003482:	59 48       	cp.w	r8,20
80003484:	c0 61       	brne	80003490 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003486:	31 89       	mov	r9,24
80003488:	fe f8 07 e0 	ld.w	r8,pc[2016]
8000348c:	91 09       	st.w	r8[0x0],r9
8000348e:	c0 78       	rjmp	8000349c <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003490:	59 08       	cp.w	r8,16
80003492:	c0 51       	brne	8000349c <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003494:	31 09       	mov	r9,16
80003496:	fe f8 07 d2 	ld.w	r8,pc[2002]
8000349a:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000349c:	30 49       	mov	r9,4
8000349e:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034a2:	91 09       	st.w	r8[0x0],r9
800034a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034a8:	30 09       	mov	r9,0
800034aa:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034ae:	b0 89       	st.b	r8[0x0],r9
800034b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034b4:	fe f8 07 c4 	ld.w	r8,pc[1988]
800034b8:	11 89       	ld.ub	r9,r8[0x0]
800034ba:	31 28       	mov	r8,18
800034bc:	f0 09 18 00 	cp.b	r9,r8
800034c0:	e0 81 01 4c 	brne	80003758 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800034c4:	ef 39 00 09 	ld.ub	r9,r7[9]
800034c8:	fe f8 07 b0 	ld.w	r8,pc[1968]
800034cc:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034ce:	11 89       	ld.ub	r9,r8[0x0]
800034d0:	3f 28       	mov	r8,-14
800034d2:	f0 09 18 00 	cp.b	r9,r8
800034d6:	e0 81 01 3b 	brne	8000374c <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
800034da:	30 19       	mov	r9,1
800034dc:	fe f8 07 c8 	ld.w	r8,pc[1992]
800034e0:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800034e2:	6e 29       	ld.w	r9,r7[0x8]
800034e4:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800034e8:	fe f8 07 80 	ld.w	r8,pc[1920]
800034ec:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800034ee:	8e 59       	ld.sh	r9,r7[0xa]
800034f0:	fe f8 07 b8 	ld.w	r8,pc[1976]
800034f4:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800034f6:	8e 69       	ld.sh	r9,r7[0xc]
800034f8:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800034fa:	8e 79       	ld.sh	r9,r7[0xe]
800034fc:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800034fe:	fe f8 07 82 	ld.w	r8,pc[1922]
80003502:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003506:	72 0a       	ld.w	r10,r9[0x0]
80003508:	70 09       	ld.w	r9,r8[0x0]
8000350a:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000350e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003512:	70 09       	ld.w	r9,r8[0x0]
80003514:	2f f9       	sub	r9,-1
80003516:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003518:	e0 49 01 ff 	cp.w	r9,511
8000351c:	e0 88 00 16 	brls	80003548 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003520:	30 09       	mov	r9,0
80003522:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003524:	fe f6 07 38 	ld.w	r6,pc[1848]
80003528:	6c 0c       	ld.w	r12,r6[0x0]
8000352a:	f0 1f 01 d8 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000352e:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003532:	70 0c       	ld.w	r12,r8[0x0]
80003534:	f0 1f 01 c3 	mcall	80003c40 <phy_rx_func+0xbdc>
80003538:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000353a:	c0 71       	brne	80003548 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
8000353c:	30 09       	mov	r9,0
8000353e:	fe f8 07 22 	ld.w	r8,pc[1826]
80003542:	91 09       	st.w	r8[0x0],r9
80003544:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003548:	fe f9 07 20 	ld.w	r9,pc[1824]
8000354c:	72 08       	ld.w	r8,r9[0x0]
8000354e:	20 18       	sub	r8,1
80003550:	93 08       	st.w	r9[0x0],r8
80003552:	c0 71       	brne	80003560 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003554:	30 09       	mov	r9,0
80003556:	fe f8 07 0a 	ld.w	r8,pc[1802]
8000355a:	91 09       	st.w	r8[0x0],r9
8000355c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003560:	fe f8 07 20 	ld.w	r8,pc[1824]
80003564:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003568:	72 0a       	ld.w	r10,r9[0x0]
8000356a:	70 09       	ld.w	r9,r8[0x0]
8000356c:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003570:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003574:	70 09       	ld.w	r9,r8[0x0]
80003576:	2f f9       	sub	r9,-1
80003578:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000357a:	e0 49 01 ff 	cp.w	r9,511
8000357e:	e0 88 00 16 	brls	800035aa <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
80003582:	30 09       	mov	r9,0
80003584:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003586:	fe f6 06 d6 	ld.w	r6,pc[1750]
8000358a:	6c 0c       	ld.w	r12,r6[0x0]
8000358c:	f0 1f 01 bf 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003590:	fe f8 06 c8 	ld.w	r8,pc[1736]
80003594:	70 0c       	ld.w	r12,r8[0x0]
80003596:	f0 1f 01 ab 	mcall	80003c40 <phy_rx_func+0xbdc>
8000359a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000359c:	c0 71       	brne	800035aa <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
8000359e:	30 09       	mov	r9,0
800035a0:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035a4:	91 09       	st.w	r8[0x0],r9
800035a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035aa:	fe f9 06 be 	ld.w	r9,pc[1726]
800035ae:	72 08       	ld.w	r8,r9[0x0]
800035b0:	20 18       	sub	r8,1
800035b2:	93 08       	st.w	r9[0x0],r8
800035b4:	c0 71       	brne	800035c2 <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
800035b6:	30 09       	mov	r9,0
800035b8:	fe f8 06 a8 	ld.w	r8,pc[1704]
800035bc:	91 09       	st.w	r8[0x0],r9
800035be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035c2:	fe f8 06 be 	ld.w	r8,pc[1726]
800035c6:	fe f9 06 96 	ld.w	r9,pc[1686]
800035ca:	72 0a       	ld.w	r10,r9[0x0]
800035cc:	70 09       	ld.w	r9,r8[0x0]
800035ce:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035d2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035d6:	70 09       	ld.w	r9,r8[0x0]
800035d8:	2f f9       	sub	r9,-1
800035da:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035dc:	e0 49 01 ff 	cp.w	r9,511
800035e0:	e0 88 00 16 	brls	8000360c <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
800035e4:	30 09       	mov	r9,0
800035e6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035e8:	fe f6 06 74 	ld.w	r6,pc[1652]
800035ec:	6c 0c       	ld.w	r12,r6[0x0]
800035ee:	f0 1f 01 a7 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035f2:	fe f8 06 66 	ld.w	r8,pc[1638]
800035f6:	70 0c       	ld.w	r12,r8[0x0]
800035f8:	f0 1f 01 92 	mcall	80003c40 <phy_rx_func+0xbdc>
800035fc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035fe:	c0 71       	brne	8000360c <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003600:	30 09       	mov	r9,0
80003602:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003606:	91 09       	st.w	r8[0x0],r9
80003608:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000360c:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003610:	72 08       	ld.w	r8,r9[0x0]
80003612:	20 18       	sub	r8,1
80003614:	93 08       	st.w	r9[0x0],r8
80003616:	c0 71       	brne	80003624 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003618:	30 09       	mov	r9,0
8000361a:	fe f8 06 46 	ld.w	r8,pc[1606]
8000361e:	91 09       	st.w	r8[0x0],r9
80003620:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003624:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003628:	fe f9 06 34 	ld.w	r9,pc[1588]
8000362c:	72 0a       	ld.w	r10,r9[0x0]
8000362e:	70 09       	ld.w	r9,r8[0x0]
80003630:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003634:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003638:	70 09       	ld.w	r9,r8[0x0]
8000363a:	2f f9       	sub	r9,-1
8000363c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000363e:	e0 49 01 ff 	cp.w	r9,511
80003642:	e0 88 00 16 	brls	8000366e <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003646:	30 09       	mov	r9,0
80003648:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000364a:	fe f6 06 12 	ld.w	r6,pc[1554]
8000364e:	6c 0c       	ld.w	r12,r6[0x0]
80003650:	f0 1f 01 8e 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003654:	fe f8 06 04 	ld.w	r8,pc[1540]
80003658:	70 0c       	ld.w	r12,r8[0x0]
8000365a:	f0 1f 01 7a 	mcall	80003c40 <phy_rx_func+0xbdc>
8000365e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003660:	c0 71       	brne	8000366e <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
80003662:	30 09       	mov	r9,0
80003664:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003668:	91 09       	st.w	r8[0x0],r9
8000366a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000366e:	fe f9 05 fa 	ld.w	r9,pc[1530]
80003672:	72 08       	ld.w	r8,r9[0x0]
80003674:	20 18       	sub	r8,1
80003676:	93 08       	st.w	r9[0x0],r8
80003678:	c0 71       	brne	80003686 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
8000367a:	30 09       	mov	r9,0
8000367c:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003680:	91 09       	st.w	r8[0x0],r9
80003682:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003686:	fe f8 05 fa 	ld.w	r8,pc[1530]
8000368a:	fe f9 05 d2 	ld.w	r9,pc[1490]
8000368e:	72 0a       	ld.w	r10,r9[0x0]
80003690:	70 09       	ld.w	r9,r8[0x0]
80003692:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003696:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000369a:	70 09       	ld.w	r9,r8[0x0]
8000369c:	2f f9       	sub	r9,-1
8000369e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036a0:	e0 49 01 ff 	cp.w	r9,511
800036a4:	e0 88 00 16 	brls	800036d0 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036a8:	30 09       	mov	r9,0
800036aa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036ac:	fe f6 05 b0 	ld.w	r6,pc[1456]
800036b0:	6c 0c       	ld.w	r12,r6[0x0]
800036b2:	f0 1f 01 76 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036b6:	fe f8 05 a2 	ld.w	r8,pc[1442]
800036ba:	70 0c       	ld.w	r12,r8[0x0]
800036bc:	f0 1f 01 61 	mcall	80003c40 <phy_rx_func+0xbdc>
800036c0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036c2:	c0 71       	brne	800036d0 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
800036c4:	30 09       	mov	r9,0
800036c6:	fe f8 05 9a 	ld.w	r8,pc[1434]
800036ca:	91 09       	st.w	r8[0x0],r9
800036cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036d0:	fe f9 05 98 	ld.w	r9,pc[1432]
800036d4:	72 08       	ld.w	r8,r9[0x0]
800036d6:	20 18       	sub	r8,1
800036d8:	93 08       	st.w	r9[0x0],r8
800036da:	c0 71       	brne	800036e8 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
800036dc:	30 09       	mov	r9,0
800036de:	fe f8 05 82 	ld.w	r8,pc[1410]
800036e2:	91 09       	st.w	r8[0x0],r9
800036e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800036e8:	fe f8 05 98 	ld.w	r8,pc[1432]
800036ec:	fe f9 05 70 	ld.w	r9,pc[1392]
800036f0:	72 0a       	ld.w	r10,r9[0x0]
800036f2:	70 09       	ld.w	r9,r8[0x0]
800036f4:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800036f8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036fc:	70 09       	ld.w	r9,r8[0x0]
800036fe:	2f f9       	sub	r9,-1
80003700:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003702:	e0 49 01 ff 	cp.w	r9,511
80003706:	e0 88 00 16 	brls	80003732 <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
8000370a:	30 09       	mov	r9,0
8000370c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000370e:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003712:	6e 0c       	ld.w	r12,r7[0x0]
80003714:	f0 1f 01 5d 	mcall	80003c88 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003718:	fe f8 05 40 	ld.w	r8,pc[1344]
8000371c:	70 0c       	ld.w	r12,r8[0x0]
8000371e:	f0 1f 01 49 	mcall	80003c40 <phy_rx_func+0xbdc>
80003722:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003724:	c0 71       	brne	80003732 <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003726:	30 09       	mov	r9,0
80003728:	fe f8 05 38 	ld.w	r8,pc[1336]
8000372c:	91 09       	st.w	r8[0x0],r9
8000372e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003732:	fe f9 05 36 	ld.w	r9,pc[1334]
80003736:	72 08       	ld.w	r8,r9[0x0]
80003738:	20 18       	sub	r8,1
8000373a:	93 08       	st.w	r9[0x0],r8
8000373c:	e0 81 02 74 	brne	80003c24 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003740:	30 09       	mov	r9,0
80003742:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003746:	91 09       	st.w	r8[0x0],r9
80003748:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000374c:	30 09       	mov	r9,0
8000374e:	fe f8 05 12 	ld.w	r8,pc[1298]
80003752:	91 09       	st.w	r8[0x0],r9
80003754:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003758:	fe f8 05 20 	ld.w	r8,pc[1312]
8000375c:	11 89       	ld.ub	r9,r8[0x0]
8000375e:	3f 28       	mov	r8,-14
80003760:	f0 09 18 00 	cp.b	r9,r8
80003764:	c4 31       	brne	800037ea <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003766:	8e 49       	ld.sh	r9,r7[0x8]
80003768:	fe f8 05 40 	ld.w	r8,pc[1344]
8000376c:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000376e:	fe f8 05 12 	ld.w	r8,pc[1298]
80003772:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003776:	72 0a       	ld.w	r10,r9[0x0]
80003778:	70 09       	ld.w	r9,r8[0x0]
8000377a:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000377e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003782:	70 09       	ld.w	r9,r8[0x0]
80003784:	2f f9       	sub	r9,-1
80003786:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003788:	e0 49 01 ff 	cp.w	r9,511
8000378c:	e0 88 00 16 	brls	800037b8 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003790:	30 09       	mov	r9,0
80003792:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003794:	fe f7 04 c8 	ld.w	r7,pc[1224]
80003798:	6e 0c       	ld.w	r12,r7[0x0]
8000379a:	f0 1f 01 3c 	mcall	80003c88 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000379e:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037a2:	70 0c       	ld.w	r12,r8[0x0]
800037a4:	f0 1f 01 27 	mcall	80003c40 <phy_rx_func+0xbdc>
800037a8:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037aa:	c0 71       	brne	800037b8 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
800037ac:	30 09       	mov	r9,0
800037ae:	fe f8 04 b2 	ld.w	r8,pc[1202]
800037b2:	91 09       	st.w	r8[0x0],r9
800037b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037b8:	fe f9 04 b0 	ld.w	r9,pc[1200]
800037bc:	72 08       	ld.w	r8,r9[0x0]
800037be:	20 18       	sub	r8,1
800037c0:	93 08       	st.w	r9[0x0],r8
800037c2:	c0 71       	brne	800037d0 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
800037c4:	30 09       	mov	r9,0
800037c6:	fe f8 04 9a 	ld.w	r8,pc[1178]
800037ca:	91 09       	st.w	r8[0x0],r9
800037cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037d0:	20 18       	sub	r8,1
800037d2:	fe f9 04 96 	ld.w	r9,pc[1174]
800037d6:	93 08       	st.w	r9[0x0],r8
800037d8:	58 08       	cp.w	r8,0
800037da:	e0 81 02 25 	brne	80003c24 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
800037de:	30 09       	mov	r9,0
800037e0:	fe f8 04 80 	ld.w	r8,pc[1152]
800037e4:	91 09       	st.w	r8[0x0],r9
800037e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800037ea:	fe f8 04 8e 	ld.w	r8,pc[1166]
800037ee:	11 89       	ld.ub	r9,r8[0x0]
800037f0:	3f 38       	mov	r8,-13
800037f2:	f0 09 18 00 	cp.b	r9,r8
800037f6:	e0 81 01 0c 	brne	80003a0e <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800037fa:	8e 49       	ld.sh	r9,r7[0x8]
800037fc:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003800:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003802:	8e 59       	ld.sh	r9,r7[0xa]
80003804:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003806:	8e 69       	ld.sh	r9,r7[0xc]
80003808:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000380a:	fe f8 04 76 	ld.w	r8,pc[1142]
8000380e:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003812:	72 0a       	ld.w	r10,r9[0x0]
80003814:	70 09       	ld.w	r9,r8[0x0]
80003816:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000381a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000381e:	70 09       	ld.w	r9,r8[0x0]
80003820:	2f f9       	sub	r9,-1
80003822:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003824:	e0 49 01 ff 	cp.w	r9,511
80003828:	e0 88 00 16 	brls	80003854 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
8000382c:	30 09       	mov	r9,0
8000382e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003830:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003834:	6c 0c       	ld.w	r12,r6[0x0]
80003836:	f0 1f 01 15 	mcall	80003c88 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000383a:	fe f8 04 1e 	ld.w	r8,pc[1054]
8000383e:	70 0c       	ld.w	r12,r8[0x0]
80003840:	f0 1f 01 00 	mcall	80003c40 <phy_rx_func+0xbdc>
80003844:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003846:	c0 71       	brne	80003854 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003848:	30 09       	mov	r9,0
8000384a:	fe f8 04 16 	ld.w	r8,pc[1046]
8000384e:	91 09       	st.w	r8[0x0],r9
80003850:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003854:	fe f9 04 14 	ld.w	r9,pc[1044]
80003858:	72 08       	ld.w	r8,r9[0x0]
8000385a:	20 18       	sub	r8,1
8000385c:	93 08       	st.w	r9[0x0],r8
8000385e:	c0 71       	brne	8000386c <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003860:	30 09       	mov	r9,0
80003862:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003866:	91 09       	st.w	r8[0x0],r9
80003868:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000386c:	fe f8 04 14 	ld.w	r8,pc[1044]
80003870:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003874:	72 0a       	ld.w	r10,r9[0x0]
80003876:	70 09       	ld.w	r9,r8[0x0]
80003878:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000387c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003880:	70 09       	ld.w	r9,r8[0x0]
80003882:	2f f9       	sub	r9,-1
80003884:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003886:	e0 49 01 ff 	cp.w	r9,511
8000388a:	e0 88 00 16 	brls	800038b6 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
8000388e:	30 09       	mov	r9,0
80003890:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003892:	fe f6 03 ca 	ld.w	r6,pc[970]
80003896:	6c 0c       	ld.w	r12,r6[0x0]
80003898:	f0 1f 00 fc 	mcall	80003c88 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000389c:	fe f8 03 bc 	ld.w	r8,pc[956]
800038a0:	70 0c       	ld.w	r12,r8[0x0]
800038a2:	f0 1f 00 e8 	mcall	80003c40 <phy_rx_func+0xbdc>
800038a6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a8:	c0 71       	brne	800038b6 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038aa:	30 09       	mov	r9,0
800038ac:	fe f8 03 b4 	ld.w	r8,pc[948]
800038b0:	91 09       	st.w	r8[0x0],r9
800038b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038b6:	fe f9 03 b2 	ld.w	r9,pc[946]
800038ba:	72 08       	ld.w	r8,r9[0x0]
800038bc:	20 18       	sub	r8,1
800038be:	93 08       	st.w	r9[0x0],r8
800038c0:	c0 71       	brne	800038ce <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
800038c2:	30 09       	mov	r9,0
800038c4:	fe f8 03 9c 	ld.w	r8,pc[924]
800038c8:	91 09       	st.w	r8[0x0],r9
800038ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038ce:	fe f8 03 b2 	ld.w	r8,pc[946]
800038d2:	fe f9 03 8a 	ld.w	r9,pc[906]
800038d6:	72 0a       	ld.w	r10,r9[0x0]
800038d8:	70 09       	ld.w	r9,r8[0x0]
800038da:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038de:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038e2:	70 09       	ld.w	r9,r8[0x0]
800038e4:	2f f9       	sub	r9,-1
800038e6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e8:	e0 49 01 ff 	cp.w	r9,511
800038ec:	e0 88 00 16 	brls	80003918 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
800038f0:	30 09       	mov	r9,0
800038f2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038f4:	fe f6 03 68 	ld.w	r6,pc[872]
800038f8:	6c 0c       	ld.w	r12,r6[0x0]
800038fa:	f0 1f 00 e4 	mcall	80003c88 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038fe:	fe f8 03 5a 	ld.w	r8,pc[858]
80003902:	70 0c       	ld.w	r12,r8[0x0]
80003904:	f0 1f 00 cf 	mcall	80003c40 <phy_rx_func+0xbdc>
80003908:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000390a:	c0 71       	brne	80003918 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
8000390c:	30 09       	mov	r9,0
8000390e:	fe f8 03 52 	ld.w	r8,pc[850]
80003912:	91 09       	st.w	r8[0x0],r9
80003914:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003918:	fe f9 03 50 	ld.w	r9,pc[848]
8000391c:	72 08       	ld.w	r8,r9[0x0]
8000391e:	20 18       	sub	r8,1
80003920:	93 08       	st.w	r9[0x0],r8
80003922:	c0 71       	brne	80003930 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003924:	30 09       	mov	r9,0
80003926:	fe f8 03 3a 	ld.w	r8,pc[826]
8000392a:	91 09       	st.w	r8[0x0],r9
8000392c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003930:	fe f8 03 50 	ld.w	r8,pc[848]
80003934:	fe f9 03 28 	ld.w	r9,pc[808]
80003938:	72 0a       	ld.w	r10,r9[0x0]
8000393a:	70 09       	ld.w	r9,r8[0x0]
8000393c:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003940:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003944:	70 09       	ld.w	r9,r8[0x0]
80003946:	2f f9       	sub	r9,-1
80003948:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000394a:	e0 49 01 ff 	cp.w	r9,511
8000394e:	e0 88 00 16 	brls	8000397a <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
80003952:	30 09       	mov	r9,0
80003954:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003956:	fe f6 03 06 	ld.w	r6,pc[774]
8000395a:	6c 0c       	ld.w	r12,r6[0x0]
8000395c:	f0 1f 00 cb 	mcall	80003c88 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003960:	fe f8 02 f8 	ld.w	r8,pc[760]
80003964:	70 0c       	ld.w	r12,r8[0x0]
80003966:	f0 1f 00 b7 	mcall	80003c40 <phy_rx_func+0xbdc>
8000396a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000396c:	c0 71       	brne	8000397a <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
8000396e:	30 09       	mov	r9,0
80003970:	fe f8 02 f0 	ld.w	r8,pc[752]
80003974:	91 09       	st.w	r8[0x0],r9
80003976:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000397a:	fe f9 02 ee 	ld.w	r9,pc[750]
8000397e:	72 08       	ld.w	r8,r9[0x0]
80003980:	20 18       	sub	r8,1
80003982:	93 08       	st.w	r9[0x0],r8
80003984:	c0 71       	brne	80003992 <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003986:	30 09       	mov	r9,0
80003988:	fe f8 02 d8 	ld.w	r8,pc[728]
8000398c:	91 09       	st.w	r8[0x0],r9
8000398e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003992:	fe f8 02 ee 	ld.w	r8,pc[750]
80003996:	fe f9 02 c6 	ld.w	r9,pc[710]
8000399a:	72 0a       	ld.w	r10,r9[0x0]
8000399c:	70 09       	ld.w	r9,r8[0x0]
8000399e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039a2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039a6:	70 09       	ld.w	r9,r8[0x0]
800039a8:	2f f9       	sub	r9,-1
800039aa:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039ac:	e0 49 01 ff 	cp.w	r9,511
800039b0:	e0 88 00 16 	brls	800039dc <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
800039b4:	30 09       	mov	r9,0
800039b6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039b8:	fe f7 02 a4 	ld.w	r7,pc[676]
800039bc:	6e 0c       	ld.w	r12,r7[0x0]
800039be:	f0 1f 00 b3 	mcall	80003c88 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039c2:	fe f8 02 96 	ld.w	r8,pc[662]
800039c6:	70 0c       	ld.w	r12,r8[0x0]
800039c8:	f0 1f 00 9e 	mcall	80003c40 <phy_rx_func+0xbdc>
800039cc:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ce:	c0 71       	brne	800039dc <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
800039d0:	30 09       	mov	r9,0
800039d2:	fe f8 02 8e 	ld.w	r8,pc[654]
800039d6:	91 09       	st.w	r8[0x0],r9
800039d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039dc:	fe f9 02 8c 	ld.w	r9,pc[652]
800039e0:	72 08       	ld.w	r8,r9[0x0]
800039e2:	20 18       	sub	r8,1
800039e4:	93 08       	st.w	r9[0x0],r8
800039e6:	c0 71       	brne	800039f4 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
800039e8:	30 09       	mov	r9,0
800039ea:	fe f8 02 76 	ld.w	r8,pc[630]
800039ee:	91 09       	st.w	r8[0x0],r9
800039f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
800039f4:	20 18       	sub	r8,1
800039f6:	fe f9 02 72 	ld.w	r9,pc[626]
800039fa:	93 08       	st.w	r9[0x0],r8
800039fc:	58 08       	cp.w	r8,0
800039fe:	e0 81 01 13 	brne	80003c24 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a02:	30 09       	mov	r9,0
80003a04:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a08:	91 09       	st.w	r8[0x0],r9
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a0e:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a12:	11 89       	ld.ub	r9,r8[0x0]
80003a14:	30 48       	mov	r8,4
80003a16:	f0 09 18 00 	cp.b	r9,r8
80003a1a:	c0 80       	breq	80003a2a <phy_rx_func+0x9c6>
80003a1c:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a20:	11 89       	ld.ub	r9,r8[0x0]
80003a22:	30 38       	mov	r8,3
80003a24:	f0 09 18 00 	cp.b	r9,r8
80003a28:	c1 41       	brne	80003a50 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a2a:	6e 29       	ld.w	r9,r7[0x8]
80003a2c:	fe f8 02 74 	ld.w	r8,pc[628]
80003a30:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a32:	6e 39       	ld.w	r9,r7[0xc]
80003a34:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a36:	fe f9 02 32 	ld.w	r9,pc[562]
80003a3a:	72 08       	ld.w	r8,r9[0x0]
80003a3c:	20 88       	sub	r8,8
80003a3e:	93 08       	st.w	r9[0x0],r8
80003a40:	e0 81 00 f2 	brne	80003c24 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a44:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a46:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a4a:	93 08       	st.w	r9[0x0],r8
80003a4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a50:	fe f8 02 28 	ld.w	r8,pc[552]
80003a54:	11 89       	ld.ub	r9,r8[0x0]
80003a56:	31 38       	mov	r8,19
80003a58:	f0 09 18 00 	cp.b	r9,r8
80003a5c:	e0 81 00 9c 	brne	80003b94 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003a60:	fe f8 02 4c 	ld.w	r8,pc[588]
80003a64:	11 88       	ld.ub	r8,r8[0x0]
80003a66:	30 c9       	mov	r9,12
80003a68:	f2 08 18 00 	cp.b	r8,r9
80003a6c:	e0 81 00 7b 	brne	80003b62 <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a70:	8e 49       	ld.sh	r9,r7[0x8]
80003a72:	fe f8 02 3e 	ld.w	r8,pc[574]
80003a76:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003a7a:	30 09       	mov	r9,0
80003a7c:	fe f8 02 30 	ld.w	r8,pc[560]
80003a80:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a82:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003a86:	3f 38       	mov	r8,-13
80003a88:	f0 09 18 00 	cp.b	r9,r8
80003a8c:	c6 61       	brne	80003b58 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003a8e:	10 99       	mov	r9,r8
80003a90:	4f a8       	lddpc	r8,80003c78 <phy_rx_func+0xc14>
80003a92:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003a94:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003a98:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003a9c:	4f 38       	lddpc	r8,80003c68 <phy_rx_func+0xc04>
80003a9e:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003aa0:	30 19       	mov	r9,1
80003aa2:	fe f8 02 12 	ld.w	r8,pc[530]
80003aa6:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003aa8:	8e 79       	ld.sh	r9,r7[0xe]
80003aaa:	fe f8 01 fe 	ld.w	r8,pc[510]
80003aae:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ab0:	4f 48       	lddpc	r8,80003c80 <phy_rx_func+0xc1c>
80003ab2:	4e b9       	lddpc	r9,80003c5c <phy_rx_func+0xbf8>
80003ab4:	72 0a       	ld.w	r10,r9[0x0]
80003ab6:	70 09       	ld.w	r9,r8[0x0]
80003ab8:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003abc:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ac0:	70 09       	ld.w	r9,r8[0x0]
80003ac2:	2f f9       	sub	r9,-1
80003ac4:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ac6:	e0 49 01 ff 	cp.w	r9,511
80003aca:	e0 88 00 13 	brls	80003af0 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003ace:	30 09       	mov	r9,0
80003ad0:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ad2:	4e 36       	lddpc	r6,80003c5c <phy_rx_func+0xbf8>
80003ad4:	6c 0c       	ld.w	r12,r6[0x0]
80003ad6:	f0 1f 00 6d 	mcall	80003c88 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003ada:	4e 08       	lddpc	r8,80003c58 <phy_rx_func+0xbf4>
80003adc:	70 0c       	ld.w	r12,r8[0x0]
80003ade:	f0 1f 00 59 	mcall	80003c40 <phy_rx_func+0xbdc>
80003ae2:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003ae4:	c0 61       	brne	80003af0 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003ae6:	30 09       	mov	r9,0
80003ae8:	4d e8       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003aea:	91 09       	st.w	r8[0x0],r9
80003aec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003af0:	4d e9       	lddpc	r9,80003c68 <phy_rx_func+0xc04>
80003af2:	72 08       	ld.w	r8,r9[0x0]
80003af4:	20 18       	sub	r8,1
80003af6:	93 08       	st.w	r9[0x0],r8
80003af8:	c0 61       	brne	80003b04 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003afa:	30 09       	mov	r9,0
80003afc:	4d 98       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003afe:	91 09       	st.w	r8[0x0],r9
80003b00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b04:	4d f8       	lddpc	r8,80003c80 <phy_rx_func+0xc1c>
80003b06:	4d 69       	lddpc	r9,80003c5c <phy_rx_func+0xbf8>
80003b08:	72 0a       	ld.w	r10,r9[0x0]
80003b0a:	70 09       	ld.w	r9,r8[0x0]
80003b0c:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b10:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b14:	70 09       	ld.w	r9,r8[0x0]
80003b16:	2f f9       	sub	r9,-1
80003b18:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b1a:	e0 49 01 ff 	cp.w	r9,511
80003b1e:	e0 88 00 13 	brls	80003b44 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b22:	30 09       	mov	r9,0
80003b24:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b26:	4c e7       	lddpc	r7,80003c5c <phy_rx_func+0xbf8>
80003b28:	6e 0c       	ld.w	r12,r7[0x0]
80003b2a:	f0 1f 00 58 	mcall	80003c88 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b2e:	4c b8       	lddpc	r8,80003c58 <phy_rx_func+0xbf4>
80003b30:	70 0c       	ld.w	r12,r8[0x0]
80003b32:	f0 1f 00 44 	mcall	80003c40 <phy_rx_func+0xbdc>
80003b36:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b38:	c0 61       	brne	80003b44 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b3a:	30 09       	mov	r9,0
80003b3c:	4c 98       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003b3e:	91 09       	st.w	r8[0x0],r9
80003b40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b44:	4c 99       	lddpc	r9,80003c68 <phy_rx_func+0xc04>
80003b46:	72 08       	ld.w	r8,r9[0x0]
80003b48:	20 18       	sub	r8,1
80003b4a:	93 08       	st.w	r9[0x0],r8
80003b4c:	c6 c1       	brne	80003c24 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003b4e:	30 09       	mov	r9,0
80003b50:	4c 48       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003b52:	91 09       	st.w	r8[0x0],r9
80003b54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b58:	30 09       	mov	r9,0
80003b5a:	4c 28       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003b5c:	91 09       	st.w	r8[0x0],r9
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b62:	8e 4a       	ld.sh	r10,r7[0x8]
80003b64:	4d 39       	lddpc	r9,80003cb0 <phy_rx_func+0xc4c>
80003b66:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b6a:	4d 1a       	lddpc	r10,80003cac <phy_rx_func+0xc48>
80003b6c:	15 88       	ld.ub	r8,r10[0x0]
80003b6e:	f0 cb ff ff 	sub	r11,r8,-1
80003b72:	8e 5c       	ld.sh	r12,r7[0xa]
80003b74:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b78:	f0 cb ff fe 	sub	r11,r8,-2
80003b7c:	8e 6c       	ld.sh	r12,r7[0xc]
80003b7e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003b82:	f0 cb ff fd 	sub	r11,r8,-3
80003b86:	8e 7c       	ld.sh	r12,r7[0xe]
80003b88:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003b8c:	2f c8       	sub	r8,-4
80003b8e:	b4 88       	st.b	r10[0x0],r8
80003b90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003b94:	30 09       	mov	r9,0
80003b96:	4b 38       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003b98:	91 09       	st.w	r8[0x0],r9
80003b9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003b9e:	4b f8       	lddpc	r8,80003c98 <phy_rx_func+0xc34>
80003ba0:	70 09       	ld.w	r9,r8[0x0]
80003ba2:	8e 4b       	ld.sh	r11,r7[0x8]
80003ba4:	4b ea       	lddpc	r10,80003c9c <phy_rx_func+0xc38>
80003ba6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003baa:	2f f9       	sub	r9,-1
80003bac:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bae:	4b 48       	lddpc	r8,80003c7c <phy_rx_func+0xc18>
80003bb0:	70 09       	ld.w	r9,r8[0x0]
80003bb2:	20 29       	sub	r9,2
80003bb4:	91 09       	st.w	r8[0x0],r9
80003bb6:	70 08       	ld.w	r8,r8[0x0]
80003bb8:	58 08       	cp.w	r8,0
80003bba:	c2 f1       	brne	80003c18 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003bbc:	30 09       	mov	r9,0
80003bbe:	4b 78       	lddpc	r8,80003c98 <phy_rx_func+0xc34>
80003bc0:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bc2:	8e 59       	ld.sh	r9,r7[0xa]
80003bc4:	fe 78 82 12 	mov	r8,-32238
80003bc8:	f0 09 19 00 	cp.h	r9,r8
80003bcc:	c2 11       	brne	80003c0e <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bce:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bd2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003bd6:	4a e8       	lddpc	r8,80003c8c <phy_rx_func+0xc28>
80003bd8:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003bda:	8e 59       	ld.sh	r9,r7[0xa]
80003bdc:	4a d8       	lddpc	r8,80003c90 <phy_rx_func+0xc2c>
80003bde:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003be0:	8e 69       	ld.sh	r9,r7[0xc]
80003be2:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003be4:	f0 1f 00 2c 	mcall	80003c94 <phy_rx_func+0xc30>
80003be8:	49 f8       	lddpc	r8,80003c64 <phy_rx_func+0xc00>
80003bea:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bec:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003bf0:	31 38       	mov	r8,19
80003bf2:	f0 09 18 00 	cp.b	r9,r8
80003bf6:	c0 71       	brne	80003c04 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003bf8:	10 99       	mov	r9,r8
80003bfa:	4a 08       	lddpc	r8,80003c78 <phy_rx_func+0xc14>
80003bfc:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003bfe:	30 09       	mov	r9,0
80003c00:	49 a8       	lddpc	r8,80003c68 <phy_rx_func+0xc04>
80003c02:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c04:	30 49       	mov	r9,4
80003c06:	49 78       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003c08:	91 09       	st.w	r8[0x0],r9
80003c0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c0e:	30 09       	mov	r9,0
80003c10:	49 48       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003c12:	91 09       	st.w	r8[0x0],r9
80003c14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c18:	4a 8c       	lddpc	r12,80003cb8 <phy_rx_func+0xc54>
80003c1a:	f0 1f 00 16 	mcall	80003c70 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c1e:	30 09       	mov	r9,0
80003c20:	49 08       	lddpc	r8,80003c60 <phy_rx_func+0xbfc>
80003c22:	91 09       	st.w	r8[0x0],r9
80003c24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c28:	00 00       	add	r0,r0
80003c2a:	0a c8       	st.b	r5++,r8
80003c2c:	00 00       	add	r0,r0
80003c2e:	0a c0       	st.b	r5++,r0
80003c30:	00 00       	add	r0,r0
80003c32:	0a 94       	mov	r4,r5
80003c34:	00 00       	add	r0,r0
80003c36:	0a 70       	tst	r0,r5
80003c38:	00 00       	add	r0,r0
80003c3a:	0a da       	st.w	--r5,r10
80003c3c:	00 00       	add	r0,r0
80003c3e:	0a a0       	st.w	r5++,r0
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	2a 30       	sub	r0,-93
80003c44:	00 00       	add	r0,r0
80003c46:	0a 80       	andn	r0,r5
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	50 a8       	stdsp	sp[0x28],r8
80003c4c:	00 00       	add	r0,r0
80003c4e:	0a 9c       	mov	r12,r5
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	29 7c       	sub	r12,-105
80003c54:	00 00       	add	r0,r0
80003c56:	0a b0       	st.h	r5++,r0
80003c58:	00 00       	add	r0,r0
80003c5a:	0a 7c       	tst	r12,r5
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a b8       	st.h	r5++,r8
80003c60:	00 00       	add	r0,r0
80003c62:	0a 8c       	andn	r12,r5
80003c64:	00 00       	add	r0,r0
80003c66:	0a 78       	tst	r8,r5
80003c68:	00 00       	add	r0,r0
80003c6a:	0a a4       	st.w	r5++,r4
80003c6c:	80 00       	ld.sh	r0,r0[0x0]
80003c6e:	c7 84       	brge	80003d5e <local_start_SSC+0x2e>
80003c70:	80 00       	ld.sh	r0,r0[0x0]
80003c72:	61 48       	ld.w	r8,r0[0x50]
80003c74:	00 00       	add	r0,r0
80003c76:	0a 5f       	eor	pc,r5
80003c78:	00 00       	add	r0,r0
80003c7a:	0a d8       	st.w	--r5,r8
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 74       	tst	r4,r5
80003c80:	00 00       	add	r0,r0
80003c82:	0a b4       	st.h	r5++,r4
80003c84:	80 00       	ld.sh	r0,r0[0x0]
80003c86:	6a 5c       	ld.w	r12,r5[0x14]
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	30 04       	mov	r4,0
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a 50       	eor	r0,r5
80003c90:	00 00       	add	r0,r0
80003c92:	0e 88       	andn	r8,r7
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	28 c0       	sub	r0,-116
80003c98:	00 00       	add	r0,r0
80003c9a:	0a d0       	st.w	--r5,r0
80003c9c:	00 00       	add	r0,r0
80003c9e:	0d 8c       	ld.ub	r12,r6[0x0]
80003ca0:	00 00       	add	r0,r0
80003ca2:	0a dc       	st.w	--r5,r12
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 62       	and	r2,r5
80003ca8:	00 00       	add	r0,r0
80003caa:	0d 84       	ld.ub	r4,r6[0x0]
80003cac:	00 00       	add	r0,r0
80003cae:	0a 90       	mov	r0,r5
80003cb0:	00 00       	add	r0,r0
80003cb2:	0e 8c       	andn	r12,r7
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 5e       	eor	lr,r5
80003cb8:	80 00       	ld.sh	r0,r0[0x0]
80003cba:	c7 9c       	rcall	80003dac <local_start_PDC+0x38>

80003cbc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cbc:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003cbe:	49 88       	lddpc	r8,80003d1c <pdca_int_handler+0x60>
80003cc0:	11 89       	ld.ub	r9,r8[0x0]
80003cc2:	ec 19 00 01 	eorl	r9,0x1
80003cc6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cc8:	11 89       	ld.ub	r9,r8[0x0]
80003cca:	a5 69       	lsl	r9,0x4
80003ccc:	2f c9       	sub	r9,-4
80003cce:	49 5a       	lddpc	r10,80003d20 <pdca_int_handler+0x64>
80003cd0:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cd2:	fe 7a 00 40 	mov	r10,-65472
80003cd6:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003cd8:	30 39       	mov	r9,3
80003cda:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003cdc:	11 8a       	ld.ub	r10,r8[0x0]
80003cde:	a5 6a       	lsl	r10,0x4
80003ce0:	2f ca       	sub	r10,-4
80003ce2:	49 18       	lddpc	r8,80003d24 <pdca_int_handler+0x68>
80003ce4:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003ce6:	fe 78 00 00 	mov	r8,-65536
80003cea:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cec:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003cee:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003cf0:	48 e8       	lddpc	r8,80003d28 <pdca_int_handler+0x6c>
80003cf2:	70 08       	ld.w	r8,r8[0x0]
80003cf4:	58 08       	cp.w	r8,0
80003cf6:	c0 70       	breq	80003d04 <pdca_int_handler+0x48>
80003cf8:	48 99       	lddpc	r9,80003d1c <pdca_int_handler+0x60>
80003cfa:	13 89       	ld.ub	r9,r9[0x0]
80003cfc:	a5 69       	lsl	r9,0x4
80003cfe:	48 ac       	lddpc	r12,80003d24 <pdca_int_handler+0x68>
80003d00:	12 0c       	add	r12,r9
80003d02:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d04:	48 a8       	lddpc	r8,80003d2c <pdca_int_handler+0x70>
80003d06:	70 08       	ld.w	r8,r8[0x0]
80003d08:	58 08       	cp.w	r8,0
80003d0a:	c0 70       	breq	80003d18 <pdca_int_handler+0x5c>
80003d0c:	48 49       	lddpc	r9,80003d1c <pdca_int_handler+0x60>
80003d0e:	13 89       	ld.ub	r9,r9[0x0]
80003d10:	a5 69       	lsl	r9,0x4
80003d12:	48 4c       	lddpc	r12,80003d20 <pdca_int_handler+0x64>
80003d14:	12 0c       	add	r12,r9
80003d16:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d18:	d4 02       	popm	lr
80003d1a:	d6 03       	rete
80003d1c:	00 00       	add	r0,r0
80003d1e:	40 ac       	lddsp	r12,sp[0x28]
80003d20:	00 00       	add	r0,r0
80003d22:	40 d4       	lddsp	r4,sp[0x34]
80003d24:	00 00       	add	r0,r0
80003d26:	40 b4       	lddsp	r4,sp[0x2c]
80003d28:	00 00       	add	r0,r0
80003d2a:	0a e4       	st.h	--r5,r4
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a e8       	st.h	--r5,r8

80003d30 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d30:	fe 78 10 00 	mov	r8,-61440
80003d34:	e0 69 0d c0 	mov	r9,3520
80003d38:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d3c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d40:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d44:	fe 78 34 00 	mov	r8,-52224
80003d48:	e0 69 80 00 	mov	r9,32768
80003d4c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d4e:	30 09       	mov	r9,0
80003d50:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d52:	e0 69 04 21 	mov	r9,1057
80003d56:	ea 19 3f 20 	orh	r9,0x3f20
80003d5a:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003d5c:	e0 69 02 9f 	mov	r9,671
80003d60:	ea 19 01 00 	orh	r9,0x100
80003d64:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003d66:	e0 6a 04 02 	mov	r10,1026
80003d6a:	ea 1a 3f 20 	orh	r10,0x3f20
80003d6e:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003d70:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d72:	5e fc       	retal	r12

80003d74 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d74:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d76:	30 19       	mov	r9,1
80003d78:	49 78       	lddpc	r8,80003dd4 <local_start_PDC+0x60>
80003d7a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d7c:	fe 78 00 00 	mov	r8,-65536
80003d80:	30 7b       	mov	r11,7
80003d82:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003d84:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003d86:	49 59       	lddpc	r9,80003dd8 <local_start_PDC+0x64>
80003d88:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003d8c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003d8e:	30 3a       	mov	r10,3
80003d90:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003d92:	30 1c       	mov	r12,1
80003d94:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003d96:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003d98:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d9a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d9c:	30 2c       	mov	r12,2
80003d9e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003da0:	48 f9       	lddpc	r9,80003ddc <local_start_PDC+0x68>
80003da2:	e0 68 5a 5a 	mov	r8,23130
80003da6:	ea 18 ab cd 	orh	r8,0xabcd
80003daa:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003dac:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dae:	30 0e       	mov	lr,0
80003db0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003db2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003db4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003db6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003db8:	fe 78 00 40 	mov	r8,-65472
80003dbc:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003dbe:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003dc0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003dc4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003dc6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003dc8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003dca:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003dcc:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dce:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dd0:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003dd2:	d8 02       	popm	pc
80003dd4:	00 00       	add	r0,r0
80003dd6:	40 ac       	lddsp	r12,sp[0x28]
80003dd8:	00 00       	add	r0,r0
80003dda:	40 b4       	lddsp	r4,sp[0x2c]
80003ddc:	00 00       	add	r0,r0
80003dde:	40 d4       	lddsp	r4,sp[0x34]

80003de0 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003de0:	48 38       	lddpc	r8,80003dec <register_rx_tx_func+0xc>
80003de2:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003de4:	48 38       	lddpc	r8,80003df0 <register_rx_tx_func+0x10>
80003de6:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003de8:	5e fc       	retal	r12
80003dea:	00 00       	add	r0,r0
80003dec:	00 00       	add	r0,r0
80003dee:	0a e4       	st.h	--r5,r4
80003df0:	00 00       	add	r0,r0
80003df2:	0a e8       	st.h	--r5,r8

80003df4 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003df4:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;	
80003df6:	fe 78 10 00 	mov	r8,-61440
80003dfa:	30 29       	mov	r9,2
80003dfc:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e00:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e04:	10 99       	mov	r9,r8
80003e06:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e0a:	e2 18 00 02 	andl	r8,0x2,COH
80003e0e:	cf c0       	breq	80003e06 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e10:	fe 79 10 00 	mov	r9,-61440
80003e14:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e18:	e2 18 00 02 	andl	r8,0x2,COH
80003e1c:	cf c1       	brne	80003e14 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e1e:	30 3a       	mov	r10,3
80003e20:	36 0b       	mov	r11,96
80003e22:	48 bc       	lddpc	r12,80003e4c <ssc_init+0x58>
80003e24:	f0 1f 00 0b 	mcall	80003e50 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e28:	f0 1f 00 0b 	mcall	80003e54 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e2c:	f0 1f 00 0b 	mcall	80003e58 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e30:	fe 79 00 00 	mov	r9,-65536
80003e34:	30 18       	mov	r8,1
80003e36:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e38:	fe 7a 00 40 	mov	r10,-65472
80003e3c:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e3e:	e0 6b 01 01 	mov	r11,257
80003e42:	fe 7a 34 00 	mov	r10,-52224
80003e46:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003e48:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003e4a:	d8 02       	popm	pc
80003e4c:	80 00       	ld.sh	r0,r0[0x0]
80003e4e:	3c bc       	mov	r12,-53
80003e50:	80 00       	ld.sh	r0,r0[0x0]
80003e52:	48 30       	lddpc	r0,80003e5c <xcmp_register_app_list>
80003e54:	80 00       	ld.sh	r0,r0[0x0]
80003e56:	3d 30       	mov	r0,-45
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	3d 74       	mov	r4,-41

80003e5c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e5c:	48 28       	lddpc	r8,80003e64 <xcmp_register_app_list+0x8>
80003e5e:	91 0c       	st.w	r8[0x0],r12
}
80003e60:	5e fc       	retal	r12
80003e62:	00 00       	add	r0,r0
80003e64:	00 00       	add	r0,r0
80003e66:	40 f4       	lddsp	r4,sp[0x3c]

80003e68 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e68:	eb cd 40 80 	pushm	r7,lr
80003e6c:	fa cd 01 00 	sub	sp,sp,256
80003e70:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e72:	16 98       	mov	r8,r11
80003e74:	2f 08       	sub	r8,-16
80003e76:	af a8       	sbr	r8,0xe
80003e78:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e7a:	3f f8       	mov	r8,-1
80003e7c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e7e:	30 b9       	mov	r9,11
80003e80:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e82:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003e84:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003e86:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e88:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003e8a:	f6 ca ff fe 	sub	r10,r11,-2
80003e8e:	18 9b       	mov	r11,r12
80003e90:	fa cc ff f0 	sub	r12,sp,-16
80003e94:	f0 1f 00 05 	mcall	80003ea8 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003e98:	2f e7       	sub	r7,-2
80003e9a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003e9c:	1a 9c       	mov	r12,sp
80003e9e:	f0 1f 00 04 	mcall	80003eac <xcmp_tx+0x44>
}
80003ea2:	2c 0d       	sub	sp,-256
80003ea4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	69 14       	ld.w	r4,r4[0x44]
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	43 20       	lddsp	r0,sp[0xc8]

80003eb0 <xcmp_data_session>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
{
80003eb0:	d4 01       	pushm	lr
80003eb2:	fa cd 00 cc 	sub	sp,sp,204
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_DATA_REQUEST;
80003eb6:	e0 68 04 1d 	mov	r8,1053
80003eba:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003ebc:	fa c8 ff fc 	sub	r8,sp,-4
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//ID:2
	//
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
	
	ptr->Function = Single_Data_Uint;//0x01
80003ec0:	30 19       	mov	r9,1
80003ec2:	b0 89       	st.b	r8[0x0],r9
	
	ptr->DataDefinition.Data_Protocol_Version = DMR_CSBK_Data;//0x70
80003ec4:	37 0a       	mov	r10,112
80003ec6:	b0 9a       	st.b	r8[0x1],r10
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_Mototrbo_Address;//0x01
80003ec8:	b0 a9       	st.b	r8[0x2],r9
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_Mototrbo_Address_Size;//0x03
80003eca:	30 39       	mov	r9,3
80003ecc:	b0 b9       	st.b	r8[0x3],r9
	
	ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x00;
80003ece:	30 09       	mov	r9,0
80003ed0:	b0 c9       	st.b	r8[0x4],r9
	ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;
80003ed2:	b0 d9       	st.b	r8[0x5],r9
	ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x02;//ID:2
80003ed4:	30 2a       	mov	r10,2
80003ed6:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
80003ed8:	34 0a       	mov	r10,64
80003eda:	b0 fa       	st.b	r8[0x7],r10
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
80003edc:	36 1a       	mov	r10,97
80003ede:	f1 6a 00 08 	st.b	r8[8],r10
	    ////
    ////}
	//
	
	//
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003ee2:	f1 69 00 09 	st.b	r8[9],r9
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//可能会变化
80003ee6:	f1 69 00 0a 	st.b	r8[10],r9
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
80003eea:	31 49       	mov	r9,20
80003eec:	f1 69 00 0b 	st.b	r8[11],r9
80003ef0:	48 88       	lddpc	r8,80003f10 <xcmp_data_session+0x60>
80003ef2:	fa c9 ff f0 	sub	r9,sp,-16
Parameters:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
80003ef6:	f0 cb ff ec 	sub	r11,r8,-20
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
	
	for (i=0; i< sizeof(DataPayload) ; i++)
	{
	
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//长度计算了吗？
80003efa:	11 3a       	ld.ub	r10,r8++
80003efc:	12 ca       	st.b	r9++,r10
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//可能会变化
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
	
	for (i=0; i< sizeof(DataPayload) ; i++)
80003efe:	16 38       	cp.w	r8,r11
80003f00:	cf d1       	brne	80003efa <xcmp_data_session+0x4a>
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//长度计算了吗？
		
	}
	
	/*send xcmp frame*///注意！！！！！！！！！！
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t));
80003f02:	32 0b       	mov	r11,32
80003f04:	fa cc ff fe 	sub	r12,sp,-2
80003f08:	f0 1f 00 03 	mcall	80003f14 <xcmp_data_session+0x64>
}
80003f0c:	2c dd       	sub	sp,-204
80003f0e:	d8 02       	popm	pc
80003f10:	00 00       	add	r0,r0
80003f12:	04 f4       	st.b	--r2,r4
80003f14:	80 00       	ld.sh	r0,r0[0x0]
80003f16:	3e 68       	mov	r8,-26

80003f18 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f18:	d4 01       	pushm	lr
80003f1a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f1e:	fe 78 b4 00 	mov	r8,-19456
80003f22:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003f24:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003f28:	30 89       	mov	r9,8
80003f2a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003f2c:	30 19       	mov	r9,1
80003f2e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003f30:	30 09       	mov	r9,0
80003f32:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003f34:	30 5a       	mov	r10,5
80003f36:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003f38:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003f3a:	30 7a       	mov	r10,7
80003f3c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f3e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f40:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f42:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003f46:	30 9b       	mov	r11,9
80003f48:	fa cc ff fe 	sub	r12,sp,-2
80003f4c:	f0 1f 00 02 	mcall	80003f54 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003f50:	2c dd       	sub	sp,-204
80003f52:	d8 02       	popm	pc
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	3e 68       	mov	r8,-26

80003f58 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003f58:	d4 01       	pushm	lr
80003f5a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003f5e:	fe 78 80 00 	mov	r8,-32768
80003f62:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003f64:	30 38       	mov	r8,3
80003f66:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003f68:	30 1b       	mov	r11,1
80003f6a:	fa cc ff fe 	sub	r12,sp,-2
80003f6e:	f0 1f 00 03 	mcall	80003f78 <xcmp_opcode_not_supported+0x20>
}
80003f72:	2c dd       	sub	sp,-204
80003f74:	d8 02       	popm	pc
80003f76:	00 00       	add	r0,r0
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	3e 68       	mov	r8,-26

80003f7c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f7c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f7e:	96 88       	ld.uh	r8,r11[0x0]
80003f80:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f84:	e0 48 80 00 	cp.w	r8,32768
80003f88:	c0 f0       	breq	80003fa6 <xcmp_exec_func+0x2a>
80003f8a:	e0 48 b0 00 	cp.w	r8,45056
80003f8e:	c1 20       	breq	80003fb2 <xcmp_exec_func+0x36>
80003f90:	58 08       	cp.w	r8,0
80003f92:	c1 51       	brne	80003fbc <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f94:	78 08       	ld.w	r8,r12[0x0]
80003f96:	58 08       	cp.w	r8,0
80003f98:	c0 40       	breq	80003fa0 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f9a:	16 9c       	mov	r12,r11
80003f9c:	5d 18       	icall	r8
80003f9e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
80003fa0:	f0 1f 00 08 	mcall	80003fc0 <xcmp_exec_func+0x44>
80003fa4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003fa6:	78 18       	ld.w	r8,r12[0x4]
80003fa8:	58 08       	cp.w	r8,0
80003faa:	c0 90       	breq	80003fbc <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003fac:	16 9c       	mov	r12,r11
80003fae:	5d 18       	icall	r8
80003fb0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003fb2:	78 28       	ld.w	r8,r12[0x8]
80003fb4:	58 08       	cp.w	r8,0
80003fb6:	c0 30       	breq	80003fbc <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003fb8:	16 9c       	mov	r12,r11
80003fba:	5d 18       	icall	r8
80003fbc:	d8 02       	popm	pc
80003fbe:	00 00       	add	r0,r0
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	3f 58       	mov	r8,-11

80003fc4 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003fc4:	d4 01       	pushm	lr
80003fc6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003fca:	e0 68 04 09 	mov	r8,1033
80003fce:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003fd0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003fd4:	30 19       	mov	r9,1
80003fd6:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003fd8:	30 09       	mov	r9,0
80003fda:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003fdc:	30 ca       	mov	r10,12
80003fde:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003fe0:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003fe2:	fb 69 00 08 	st.b	sp[8],r9
80003fe6:	fa c8 ff f7 	sub	r8,sp,-9
80003fea:	b0 89       	st.b	r8[0x0],r9
80003fec:	fa c8 ff f6 	sub	r8,sp,-10
80003ff0:	b0 89       	st.b	r8[0x0],r9
80003ff2:	fa c8 ff f5 	sub	r8,sp,-11
80003ff6:	b0 89       	st.b	r8[0x0],r9
80003ff8:	fa c8 ff f4 	sub	r8,sp,-12
80003ffc:	b0 89       	st.b	r8[0x0],r9
80003ffe:	fa c8 ff f3 	sub	r8,sp,-13
80004002:	b0 89       	st.b	r8[0x0],r9
80004004:	fa c8 ff f2 	sub	r8,sp,-14
80004008:	b0 89       	st.b	r8[0x0],r9
8000400a:	fa c8 ff f1 	sub	r8,sp,-15
8000400e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004010:	30 cb       	mov	r11,12
80004012:	fa cc ff fe 	sub	r12,sp,-2
80004016:	f0 1f 00 03 	mcall	80004020 <xcmp_IdleTestTone+0x5c>
}
8000401a:	2c dd       	sub	sp,-204
8000401c:	d8 02       	popm	pc
8000401e:	00 00       	add	r0,r0
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	3e 68       	mov	r8,-26

80004024 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004024:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004026:	f0 1f 00 0d 	mcall	80004058 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000402a:	48 dc       	lddpc	r12,8000405c <xcmp_init+0x38>
8000402c:	f0 1f 00 0d 	mcall	80004060 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004030:	30 4b       	mov	r11,4
80004032:	31 4c       	mov	r12,20
80004034:	f0 1f 00 0c 	mcall	80004064 <xcmp_init+0x40>
80004038:	48 c8       	lddpc	r8,80004068 <xcmp_init+0x44>
8000403a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000403c:	30 09       	mov	r9,0
8000403e:	1a d9       	st.w	--sp,r9
80004040:	1a d9       	st.w	--sp,r9
80004042:	1a d9       	st.w	--sp,r9
80004044:	30 38       	mov	r8,3
80004046:	e0 6a 01 80 	mov	r10,384
8000404a:	48 9b       	lddpc	r11,8000406c <xcmp_init+0x48>
8000404c:	48 9c       	lddpc	r12,80004070 <xcmp_init+0x4c>
8000404e:	f0 1f 00 0a 	mcall	80004074 <xcmp_init+0x50>
80004052:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004054:	d8 02       	popm	pc
80004056:	00 00       	add	r0,r0
80004058:	80 00       	ld.sh	r0,r0[0x0]
8000405a:	44 04       	lddsp	r4,sp[0x100]
8000405c:	80 00       	ld.sh	r0,r0[0x0]
8000405e:	41 74       	lddsp	r4,sp[0x5c]
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	41 c0       	lddsp	r0,sp[0x70]
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	55 24       	stdsp	sp[0x148],r4
80004068:	00 00       	add	r0,r0
8000406a:	0a f8       	st.b	--r5,r8
8000406c:	80 00       	ld.sh	r0,r0[0x0]
8000406e:	c7 c8       	rjmp	80004166 <xcmp_rx_process+0xee>
80004070:	80 00       	ld.sh	r0,r0[0x0]
80004072:	40 78       	lddsp	r8,sp[0x1c]
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	5b f8       	cp.w	r8,-1

80004078 <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004078:	d4 31       	pushm	r0-r7,lr
8000407a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000407c:	4b 16       	lddpc	r6,80004140 <xcmp_rx_process+0xc8>
8000407e:	30 05       	mov	r5,0
80004080:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004082:	4b 13       	lddpc	r3,80004144 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004084:	4b 12       	lddpc	r2,80004148 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004086:	4b 21       	lddpc	r1,8000414c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004088:	4b 20       	lddpc	r0,80004150 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000408a:	6c 0c       	ld.w	r12,r6[0x0]
8000408c:	0a 99       	mov	r9,r5
8000408e:	08 9a       	mov	r10,r4
80004090:	1a 9b       	mov	r11,sp
80004092:	f0 1f 00 31 	mcall	80004154 <xcmp_rx_process+0xdc>
80004096:	58 1c       	cp.w	r12,1
80004098:	cf 91       	brne	8000408a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000409a:	40 0b       	lddsp	r11,sp[0x0]
8000409c:	58 0b       	cp.w	r11,0
8000409e:	cf 60       	breq	8000408a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800040a0:	96 0a       	ld.sh	r10,r11[0x0]
800040a2:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800040a6:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800040aa:	59 c8       	cp.w	r8,28
800040ac:	c1 e0       	breq	800040e8 <xcmp_rx_process+0x70>
800040ae:	e0 89 00 07 	brgt	800040bc <xcmp_rx_process+0x44>
800040b2:	58 e8       	cp.w	r8,14
800040b4:	c0 e0       	breq	800040d0 <xcmp_rx_process+0x58>
800040b6:	58 f8       	cp.w	r8,15
800040b8:	c2 41       	brne	80004100 <xcmp_rx_process+0x88>
800040ba:	c0 f8       	rjmp	800040d8 <xcmp_rx_process+0x60>
800040bc:	e0 48 01 09 	cp.w	r8,265
800040c0:	c1 80       	breq	800040f0 <xcmp_rx_process+0x78>
800040c2:	e0 48 01 0a 	cp.w	r8,266
800040c6:	c1 90       	breq	800040f8 <xcmp_rx_process+0x80>
800040c8:	e0 48 00 2c 	cp.w	r8,44
800040cc:	c1 a1       	brne	80004100 <xcmp_rx_process+0x88>
800040ce:	c0 98       	rjmp	800040e0 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800040d0:	4a 2c       	lddpc	r12,80004158 <xcmp_rx_process+0xe0>
800040d2:	f0 1f 00 23 	mcall	8000415c <xcmp_rx_process+0xe4>
					break;
800040d6:	c2 f8       	rjmp	80004134 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800040d8:	4a 2c       	lddpc	r12,80004160 <xcmp_rx_process+0xe8>
800040da:	f0 1f 00 21 	mcall	8000415c <xcmp_rx_process+0xe4>
					break;
800040de:	c2 b8       	rjmp	80004134 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800040e0:	4a 1c       	lddpc	r12,80004164 <xcmp_rx_process+0xec>
800040e2:	f0 1f 00 1f 	mcall	8000415c <xcmp_rx_process+0xe4>
					break;
800040e6:	c2 78       	rjmp	80004134 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040e8:	04 9c       	mov	r12,r2
800040ea:	f0 1f 00 1d 	mcall	8000415c <xcmp_rx_process+0xe4>
						, ptr);
					break;
800040ee:	c2 38       	rjmp	80004134 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040f0:	02 9c       	mov	r12,r1
800040f2:	f0 1f 00 1b 	mcall	8000415c <xcmp_rx_process+0xe4>
					break;
800040f6:	c1 f8       	rjmp	80004134 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800040f8:	00 9c       	mov	r12,r0
800040fa:	f0 1f 00 19 	mcall	8000415c <xcmp_rx_process+0xe4>
					break;
800040fe:	c1 b8       	rjmp	80004134 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004100:	12 98       	mov	r8,r9
80004102:	e2 18 04 00 	andl	r8,0x400,COH
80004106:	c0 70       	breq	80004114 <xcmp_rx_process+0x9c>
80004108:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000410c:	e0 48 00 68 	cp.w	r8,104
80004110:	e0 8a 00 08 	brle	80004120 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004114:	e2 19 f0 00 	andl	r9,0xf000,COH
80004118:	c0 e1       	brne	80004134 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000411a:	f0 1f 00 14 	mcall	80004168 <xcmp_rx_process+0xf0>
8000411e:	c0 b8       	rjmp	80004134 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004120:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004124:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004128:	49 19       	lddpc	r9,8000416c <xcmp_rx_process+0xf4>
8000412a:	72 08       	ld.w	r8,r9[0x0]
8000412c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004130:	f0 1f 00 0b 	mcall	8000415c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004134:	66 0c       	ld.w	r12,r3[0x0]
80004136:	40 0b       	lddsp	r11,sp[0x0]
80004138:	f0 1f 00 0e 	mcall	80004170 <xcmp_rx_process+0xf8>
8000413c:	ca 7b       	rjmp	8000408a <xcmp_rx_process+0x12>
8000413e:	00 00       	add	r0,r0
80004140:	00 00       	add	r0,r0
80004142:	0a f8       	st.b	--r5,r8
80004144:	00 00       	add	r0,r0
80004146:	0a a0       	st.w	r5++,r0
80004148:	00 00       	add	r0,r0
8000414a:	0b 08       	ld.w	r8,r5++
8000414c:	00 00       	add	r0,r0
8000414e:	0a fc       	st.b	--r5,r12
80004150:	00 00       	add	r0,r0
80004152:	0b 14       	ld.sh	r4,r5++
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	52 18       	stdsp	sp[0x84],r8
80004158:	00 00       	add	r0,r0
8000415a:	0b 2c       	ld.uh	r12,r5++
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	3f 7c       	mov	r12,-9
80004160:	00 00       	add	r0,r0
80004162:	0a ec       	st.h	--r5,r12
80004164:	00 00       	add	r0,r0
80004166:	0b 20       	ld.uh	r0,r5++
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	3f 58       	mov	r8,-11
8000416c:	00 00       	add	r0,r0
8000416e:	40 f4       	lddsp	r4,sp[0x3c]
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	29 b4       	sub	r4,-101

80004174 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004174:	eb cd 40 90 	pushm	r4,r7,lr
80004178:	20 1d       	sub	sp,4
8000417a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000417e:	48 c8       	lddpc	r8,800041ac <xcmp_rx+0x38>
80004180:	70 0c       	ld.w	r12,r8[0x0]
80004182:	f0 1f 00 0c 	mcall	800041b0 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004186:	c1 00       	breq	800041a6 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004188:	fa c7 ff fc 	sub	r7,sp,-4
8000418c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000418e:	e0 6a 00 ca 	mov	r10,202
80004192:	08 9b       	mov	r11,r4
80004194:	f0 1f 00 08 	mcall	800041b4 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004198:	48 88       	lddpc	r8,800041b8 <xcmp_rx+0x44>
8000419a:	70 0c       	ld.w	r12,r8[0x0]
8000419c:	30 09       	mov	r9,0
8000419e:	12 9a       	mov	r10,r9
800041a0:	1a 9b       	mov	r11,sp
800041a2:	f0 1f 00 07 	mcall	800041bc <xcmp_rx+0x48>
	}	
}
800041a6:	2f fd       	sub	sp,-4
800041a8:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800041ac:	00 00       	add	r0,r0
800041ae:	0a a0       	st.w	r5++,r0
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	2f 20       	sub	r0,-14
800041b4:	80 00       	ld.sh	r0,r0[0x0]
800041b6:	69 14       	ld.w	r4,r4[0x44]
800041b8:	00 00       	add	r0,r0
800041ba:	0a f8       	st.b	--r5,r8
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	54 24       	stdsp	sp[0x108],r4

800041c0 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800041c0:	48 28       	lddpc	r8,800041c8 <xnl_register_xcmp_func+0x8>
800041c2:	91 0c       	st.w	r8[0x0],r12
}
800041c4:	5e fc       	retal	r12
800041c6:	00 00       	add	r0,r0
800041c8:	00 00       	add	r0,r0
800041ca:	0b 58       	ld.sh	r8,--r5

800041cc <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800041cc:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800041ce:	48 88       	lddpc	r8,800041ec <xnl_get_msg_ack_func+0x20>
800041d0:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800041d2:	98 49       	ld.sh	r9,r12[0x8]
800041d4:	f0 09 19 00 	cp.h	r9,r8
800041d8:	c0 81       	brne	800041e8 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800041da:	48 68       	lddpc	r8,800041f0 <xnl_get_msg_ack_func+0x24>
800041dc:	70 0c       	ld.w	r12,r8[0x0]
800041de:	30 09       	mov	r9,0
800041e0:	12 9a       	mov	r10,r9
800041e2:	12 9b       	mov	r11,r9
800041e4:	f0 1f 00 04 	mcall	800041f4 <xnl_get_msg_ack_func+0x28>
800041e8:	d8 02       	popm	pc
800041ea:	00 00       	add	r0,r0
800041ec:	00 00       	add	r0,r0
800041ee:	0b 3e       	ld.ub	lr,r5++
800041f0:	00 00       	add	r0,r0
800041f2:	0b 38       	ld.ub	r8,r5++
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	54 24       	stdsp	sp[0x108],r4

800041f8 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800041f8:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800041fa:	4a 86       	lddpc	r6,80004298 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800041fc:	4a 82       	lddpc	r2,8000429c <xnl_tx_process+0xa4>
800041fe:	4a 94       	lddpc	r4,800042a0 <xnl_tx_process+0xa8>
80004200:	30 07       	mov	r7,0
80004202:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004204:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004206:	4a 85       	lddpc	r5,800042a4 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004208:	4a 83       	lddpc	r3,800042a8 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000420a:	6c 08       	ld.w	r8,r6[0x0]
8000420c:	58 08       	cp.w	r8,0
8000420e:	c0 40       	breq	80004216 <xnl_tx_process+0x1e>
80004210:	58 18       	cp.w	r8,1
80004212:	cf d1       	brne	8000420c <xnl_tx_process+0x14>
80004214:	c2 08       	rjmp	80004254 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004216:	64 0c       	ld.w	r12,r2[0x0]
80004218:	0e 99       	mov	r9,r7
8000421a:	02 9a       	mov	r10,r1
8000421c:	08 9b       	mov	r11,r4
8000421e:	f0 1f 00 24 	mcall	800042ac <xnl_tx_process+0xb4>
80004222:	58 1c       	cp.w	r12,1
80004224:	cf 31       	brne	8000420a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004226:	68 0c       	ld.w	r12,r4[0x0]
80004228:	58 0c       	cp.w	r12,0
8000422a:	cf 00       	breq	8000420a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000422c:	98 28       	ld.sh	r8,r12[0x4]
8000422e:	e0 08 19 00 	cp.h	r8,r0
80004232:	c0 41       	brne	8000423a <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004234:	f0 1f 00 1f 	mcall	800042b0 <xnl_tx_process+0xb8>
						break;
80004238:	ce 9b       	rjmp	8000420a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000423a:	f0 1f 00 1f 	mcall	800042b4 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000423e:	30 18       	mov	r8,1
80004240:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004242:	66 0c       	ld.w	r12,r3[0x0]
80004244:	0e 99       	mov	r9,r7
80004246:	0e 9a       	mov	r10,r7
80004248:	0e 9b       	mov	r11,r7
8000424a:	f0 1f 00 19 	mcall	800042ac <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000424e:	30 18       	mov	r8,1
80004250:	8d 08       	st.w	r6[0x0],r8
80004252:	cd cb       	rjmp	8000420a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004254:	66 0c       	ld.w	r12,r3[0x0]
80004256:	0e 99       	mov	r9,r7
80004258:	36 4a       	mov	r10,100
8000425a:	0e 9b       	mov	r11,r7
8000425c:	f0 1f 00 14 	mcall	800042ac <xnl_tx_process+0xb4>
80004260:	58 1c       	cp.w	r12,1
80004262:	c0 81       	brne	80004272 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004264:	49 58       	lddpc	r8,800042b8 <xnl_tx_process+0xc0>
80004266:	70 0c       	ld.w	r12,r8[0x0]
80004268:	68 0b       	ld.w	r11,r4[0x0]
8000426a:	f0 1f 00 15 	mcall	800042bc <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000426e:	8d 07       	st.w	r6[0x0],r7
80004270:	cc db       	rjmp	8000420a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004272:	6a 08       	ld.w	r8,r5[0x0]
80004274:	58 38       	cp.w	r8,3
80004276:	e0 89 00 09 	brgt	80004288 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000427a:	68 0c       	ld.w	r12,r4[0x0]
8000427c:	f0 1f 00 0e 	mcall	800042b4 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004280:	6a 08       	ld.w	r8,r5[0x0]
80004282:	2f f8       	sub	r8,-1
80004284:	8b 08       	st.w	r5[0x0],r8
80004286:	cc 2b       	rjmp	8000420a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004288:	48 c8       	lddpc	r8,800042b8 <xnl_tx_process+0xc0>
8000428a:	70 0c       	ld.w	r12,r8[0x0]
8000428c:	68 0b       	ld.w	r11,r4[0x0]
8000428e:	f0 1f 00 0c 	mcall	800042bc <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004292:	8d 07       	st.w	r6[0x0],r7
80004294:	cb bb       	rjmp	8000420a <xnl_tx_process+0x12>
80004296:	00 00       	add	r0,r0
80004298:	00 00       	add	r0,r0
8000429a:	0b 54       	ld.sh	r4,--r5
8000429c:	00 00       	add	r0,r0
8000429e:	0b 48       	ld.w	r8,--r5
800042a0:	00 00       	add	r0,r0
800042a2:	0b 4c       	ld.w	r12,--r5
800042a4:	00 00       	add	r0,r0
800042a6:	0b 50       	ld.sh	r0,--r5
800042a8:	00 00       	add	r0,r0
800042aa:	0b 38       	ld.ub	r8,r5++
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	52 18       	stdsp	sp[0x84],r8
800042b0:	80 00       	ld.sh	r0,r0[0x0]
800042b2:	50 a8       	stdsp	sp[0x28],r8
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	29 d4       	sub	r4,-99
800042b8:	00 00       	add	r0,r0
800042ba:	0a a0       	st.w	r5++,r0
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	29 b4       	sub	r4,-101

800042c0 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800042c0:	eb cd 40 fe 	pushm	r1-r7,lr
800042c4:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042c6:	49 26       	lddpc	r6,8000430c <xnl_rx_process+0x4c>
800042c8:	30 05       	mov	r5,0
800042ca:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042cc:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ce:	49 11       	lddpc	r1,80004310 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042d0:	49 12       	lddpc	r2,80004314 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042d2:	6c 0c       	ld.w	r12,r6[0x0]
800042d4:	0a 99       	mov	r9,r5
800042d6:	08 9a       	mov	r10,r4
800042d8:	1a 9b       	mov	r11,sp
800042da:	f0 1f 00 10 	mcall	80004318 <xnl_rx_process+0x58>
800042de:	58 1c       	cp.w	r12,1
800042e0:	cf 91       	brne	800042d2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042e2:	40 0c       	lddsp	r12,sp[0x0]
800042e4:	58 0c       	cp.w	r12,0
800042e6:	cf 60       	breq	800042d2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042e8:	98 28       	ld.sh	r8,r12[0x4]
800042ea:	e6 08 19 00 	cp.h	r8,r3
800042ee:	e0 8b 00 0a 	brhi	80004302 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042f2:	5c 78       	castu.h	r8
800042f4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800042f8:	58 09       	cp.w	r9,0
800042fa:	c0 40       	breq	80004302 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800042fc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004300:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004302:	62 0c       	ld.w	r12,r1[0x0]
80004304:	40 0b       	lddsp	r11,sp[0x0]
80004306:	f0 1f 00 06 	mcall	8000431c <xnl_rx_process+0x5c>
8000430a:	ce 4b       	rjmp	800042d2 <xnl_rx_process+0x12>
8000430c:	00 00       	add	r0,r0
8000430e:	0a c8       	st.b	r5++,r8
80004310:	00 00       	add	r0,r0
80004312:	0a a0       	st.w	r5++,r0
80004314:	00 00       	add	r0,r0
80004316:	05 08       	ld.w	r8,r2++
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	52 18       	stdsp	sp[0x84],r8
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	29 b4       	sub	r4,-101

80004320 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004320:	eb cd 40 c0 	pushm	r6-r7,lr
80004324:	20 1d       	sub	sp,4
80004326:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004328:	98 39       	ld.sh	r9,r12[0x6]
8000432a:	3f f8       	mov	r8,-1
8000432c:	f0 09 19 00 	cp.h	r9,r8
80004330:	c0 a1       	brne	80004344 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004332:	4a e9       	lddpc	r9,800043e8 <xnl_tx+0xc8>
80004334:	13 88       	ld.ub	r8,r9[0x0]
80004336:	2f f8       	sub	r8,-1
80004338:	5c 58       	castu.b	r8
8000433a:	b2 88       	st.b	r9[0x0],r8
8000433c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004340:	a9 a8       	sbr	r8,0x8
80004342:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004344:	8c 49       	ld.sh	r9,r6[0x8]
80004346:	3f f8       	mov	r8,-1
80004348:	f0 09 19 00 	cp.h	r9,r8
8000434c:	c0 41       	brne	80004354 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000434e:	4a 88       	lddpc	r8,800043ec <xnl_tx+0xcc>
80004350:	90 18       	ld.sh	r8,r8[0x2]
80004352:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004354:	8c 59       	ld.sh	r9,r6[0xa]
80004356:	3f f8       	mov	r8,-1
80004358:	f0 09 19 00 	cp.h	r9,r8
8000435c:	c0 41       	brne	80004364 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000435e:	4a 48       	lddpc	r8,800043ec <xnl_tx+0xcc>
80004360:	90 28       	ld.sh	r8,r8[0x4]
80004362:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004364:	8c 69       	ld.sh	r9,r6[0xc]
80004366:	3f f8       	mov	r8,-1
80004368:	f0 09 19 00 	cp.h	r9,r8
8000436c:	c0 e1       	brne	80004388 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000436e:	4a 08       	lddpc	r8,800043ec <xnl_tx+0xcc>
80004370:	90 49       	ld.sh	r9,r8[0x8]
80004372:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004374:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004376:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004378:	90 49       	ld.sh	r9,r8[0x8]
8000437a:	e0 19 ff 00 	andl	r9,0xff00
8000437e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004382:	f3 e8 10 08 	or	r8,r9,r8
80004386:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004388:	0d 98       	ld.ub	r8,r6[0x1]
8000438a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000438c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004390:	10 0c       	add	r12,r8
80004392:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004394:	58 0c       	cp.w	r12,0
80004396:	e0 89 00 04 	brgt	8000439e <xnl_tx+0x7e>
8000439a:	30 09       	mov	r9,0
8000439c:	c0 d8       	rjmp	800043b6 <xnl_tx+0x96>
8000439e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800043a2:	2f ec       	sub	r12,-2
800043a4:	30 09       	mov	r9,0
800043a6:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800043a8:	15 1b       	ld.sh	r11,r10++
800043aa:	f6 09 00 09 	add	r9,r11,r9
800043ae:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043b0:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043b2:	18 38       	cp.w	r8,r12
800043b4:	cf a1       	brne	800043a8 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043b6:	5c 39       	neg	r9
800043b8:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043ba:	48 e8       	lddpc	r8,800043f0 <xnl_tx+0xd0>
800043bc:	70 0c       	ld.w	r12,r8[0x0]
800043be:	f0 1f 00 0e 	mcall	800043f4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043c2:	c1 00       	breq	800043e2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043c4:	fa c7 ff fc 	sub	r7,sp,-4
800043c8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043ca:	e0 6a 01 00 	mov	r10,256
800043ce:	0c 9b       	mov	r11,r6
800043d0:	f0 1f 00 0a 	mcall	800043f8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043d4:	48 a8       	lddpc	r8,800043fc <xnl_tx+0xdc>
800043d6:	70 0c       	ld.w	r12,r8[0x0]
800043d8:	30 09       	mov	r9,0
800043da:	12 9a       	mov	r10,r9
800043dc:	1a 9b       	mov	r11,sp
800043de:	f0 1f 00 09 	mcall	80004400 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043e2:	2f fd       	sub	sp,-4
800043e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043e8:	00 00       	add	r0,r0
800043ea:	0b 3c       	ld.ub	r12,r5++
800043ec:	00 00       	add	r0,r0
800043ee:	0b 3e       	ld.ub	lr,r5++
800043f0:	00 00       	add	r0,r0
800043f2:	0a a0       	st.w	r5++,r0
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	2f 20       	sub	r0,-14
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	69 14       	ld.w	r4,r4[0x44]
800043fc:	00 00       	add	r0,r0
800043fe:	0b 48       	ld.w	r8,--r5
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	54 24       	stdsp	sp[0x108],r4

80004404 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004404:	eb cd 40 80 	pushm	r7,lr
80004408:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
8000440c:	f0 1f 00 27 	mcall	800044a8 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80004410:	30 09       	mov	r9,0
80004412:	4a 78       	lddpc	r8,800044ac <xnl_init+0xa8>
80004414:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004416:	30 0b       	mov	r11,0
80004418:	30 1c       	mov	r12,1
8000441a:	f0 1f 00 26 	mcall	800044b0 <xnl_init+0xac>
8000441e:	4a 68       	lddpc	r8,800044b4 <xnl_init+0xb0>
80004420:	91 0c       	st.w	r8[0x0],r12
80004422:	70 08       	ld.w	r8,r8[0x0]
80004424:	58 08       	cp.w	r8,0
80004426:	c0 80       	breq	80004436 <xnl_init+0x32>
80004428:	4a 38       	lddpc	r8,800044b4 <xnl_init+0xb0>
8000442a:	70 0c       	ld.w	r12,r8[0x0]
8000442c:	30 09       	mov	r9,0
8000442e:	12 9a       	mov	r10,r9
80004430:	12 9b       	mov	r11,r9
80004432:	f0 1f 00 22 	mcall	800044b8 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004436:	30 4b       	mov	r11,4
80004438:	31 4c       	mov	r12,20
8000443a:	f0 1f 00 1e 	mcall	800044b0 <xnl_init+0xac>
8000443e:	4a 08       	lddpc	r8,800044bc <xnl_init+0xb8>
80004440:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004442:	30 07       	mov	r7,0
80004444:	1a d7       	st.w	--sp,r7
80004446:	1a d7       	st.w	--sp,r7
80004448:	1a d7       	st.w	--sp,r7
8000444a:	30 38       	mov	r8,3
8000444c:	0e 99       	mov	r9,r7
8000444e:	e0 6a 02 00 	mov	r10,512
80004452:	49 cb       	lddpc	r11,800044c0 <xnl_init+0xbc>
80004454:	49 cc       	lddpc	r12,800044c4 <xnl_init+0xc0>
80004456:	f0 1f 00 1d 	mcall	800044c8 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000445a:	1a d7       	st.w	--sp,r7
8000445c:	1a d7       	st.w	--sp,r7
8000445e:	1a d7       	st.w	--sp,r7
80004460:	30 38       	mov	r8,3
80004462:	0e 99       	mov	r9,r7
80004464:	e0 6a 03 20 	mov	r10,800
80004468:	49 9b       	lddpc	r11,800044cc <xnl_init+0xc8>
8000446a:	49 ac       	lddpc	r12,800044d0 <xnl_init+0xcc>
8000446c:	f0 1f 00 17 	mcall	800044c8 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004470:	e0 68 40 0e 	mov	r8,16398
80004474:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004478:	3f f8       	mov	r8,-1
8000447a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000447e:	30 38       	mov	r8,3
80004480:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004484:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004488:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000448c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004490:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004494:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004498:	fa cc ff e8 	sub	r12,sp,-24
8000449c:	f0 1f 00 0e 	mcall	800044d4 <xnl_init+0xd0>
800044a0:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800044a2:	2c 0d       	sub	sp,-256
800044a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800044a8:	80 00       	ld.sh	r0,r0[0x0]
800044aa:	2f 48       	sub	r8,-12
800044ac:	00 00       	add	r0,r0
800044ae:	0b 3e       	ld.ub	lr,r5++
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	55 24       	stdsp	sp[0x148],r4
800044b4:	00 00       	add	r0,r0
800044b6:	0b 38       	ld.ub	r8,r5++
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	54 24       	stdsp	sp[0x108],r4
800044bc:	00 00       	add	r0,r0
800044be:	0b 48       	ld.w	r8,--r5
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	c7 d0       	breq	800045bc <xnl_device_auth_reply_func+0x84>
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	42 c0       	lddsp	r0,sp[0xb0]
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	5b f8       	cp.w	r8,-1
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	c0 00       	breq	800044ce <xnl_init+0xca>
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	41 f8       	lddsp	r8,sp[0x7c]
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	43 20       	lddsp	r0,sp[0xc8]

800044d8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044d8:	eb cd 40 80 	pushm	r7,lr
800044dc:	fa cd 01 00 	sub	sp,sp,256
800044e0:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044e2:	e0 68 40 0e 	mov	r8,16398
800044e6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044e8:	3f f8       	mov	r8,-1
800044ea:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800044ec:	30 c8       	mov	r8,12
800044ee:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800044f0:	98 38       	ld.sh	r8,r12[0x6]
800044f2:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800044f4:	98 58       	ld.sh	r8,r12[0xa]
800044f6:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800044f8:	98 48       	ld.sh	r8,r12[0x8]
800044fa:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800044fc:	98 68       	ld.sh	r8,r12[0xc]
800044fe:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004500:	30 08       	mov	r8,0
80004502:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004504:	1a 9c       	mov	r12,sp
80004506:	f0 1f 00 0a 	mcall	8000452c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000450a:	fa cd 00 cc 	sub	sp,sp,204
8000450e:	e0 6a 00 ca 	mov	r10,202
80004512:	ee cb ff f0 	sub	r11,r7,-16
80004516:	1a 9c       	mov	r12,sp
80004518:	f0 1f 00 06 	mcall	80004530 <xnl_data_msg_func+0x58>
8000451c:	48 68       	lddpc	r8,80004534 <xnl_data_msg_func+0x5c>
8000451e:	70 08       	ld.w	r8,r8[0x0]
80004520:	5d 18       	icall	r8
80004522:	fa cd ff 34 	sub	sp,sp,-204
}
80004526:	2c 0d       	sub	sp,-256
80004528:	e3 cd 80 80 	ldm	sp++,r7,pc
8000452c:	80 00       	ld.sh	r0,r0[0x0]
8000452e:	43 20       	lddsp	r0,sp[0xc8]
80004530:	80 00       	ld.sh	r0,r0[0x0]
80004532:	69 14       	ld.w	r4,r4[0x44]
80004534:	00 00       	add	r0,r0
80004536:	0b 58       	ld.sh	r8,--r5

80004538 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004538:	d4 21       	pushm	r4-r7,lr
8000453a:	fa cd 01 00 	sub	sp,sp,256
8000453e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004540:	4c 28       	lddpc	r8,80004648 <xnl_device_auth_reply_func+0x110>
80004542:	11 88       	ld.ub	r8,r8[0x0]
80004544:	58 08       	cp.w	r8,0
80004546:	e0 81 00 7f 	brne	80004644 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000454a:	4c 18       	lddpc	r8,8000464c <xnl_device_auth_reply_func+0x114>
8000454c:	70 0c       	ld.w	r12,r8[0x0]
8000454e:	30 09       	mov	r9,0
80004550:	12 9a       	mov	r10,r9
80004552:	12 9b       	mov	r11,r9
80004554:	f0 1f 00 3f 	mcall	80004650 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004558:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000455c:	4b b8       	lddpc	r8,80004648 <xnl_device_auth_reply_func+0x110>
8000455e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004560:	ef 39 00 12 	ld.ub	r9,r7[18]
80004564:	ef 38 00 13 	ld.ub	r8,r7[19]
80004568:	b1 68       	lsl	r8,0x10
8000456a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000456e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004572:	f3 e8 10 08 	or	r8,r9,r8
80004576:	ef 39 00 14 	ld.ub	r9,r7[20]
8000457a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000457e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004582:	ef 38 00 17 	ld.ub	r8,r7[23]
80004586:	b1 68       	lsl	r8,0x10
80004588:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000458c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004590:	f5 e8 10 08 	or	r8,r10,r8
80004594:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004598:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000459c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000459e:	e0 64 79 b9 	mov	r4,31161
800045a2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045a6:	e0 65 45 07 	mov	r5,17671
800045aa:	ea 15 8a bd 	orh	r5,0x8abd
800045ae:	e0 66 f9 3d 	mov	r6,63805
800045b2:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045b6:	e0 6e b8 cf 	mov	lr,47311
800045ba:	ea 1e 36 83 	orh	lr,0x3683
800045be:	e0 67 aa 1c 	mov	r7,43548
800045c2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045c6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045c8:	f4 08 00 0c 	add	r12,r10,r8
800045cc:	f0 0b 15 04 	lsl	r11,r8,0x4
800045d0:	0a 0b       	add	r11,r5
800045d2:	f9 eb 20 0b 	eor	r11,r12,r11
800045d6:	f0 0c 16 05 	lsr	r12,r8,0x5
800045da:	0c 0c       	add	r12,r6
800045dc:	18 5b       	eor	r11,r12
800045de:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045e0:	f2 0c 15 04 	lsl	r12,r9,0x4
800045e4:	1c 0c       	add	r12,lr
800045e6:	f2 0b 16 05 	lsr	r11,r9,0x5
800045ea:	0e 0b       	add	r11,r7
800045ec:	f9 eb 20 0b 	eor	r11,r12,r11
800045f0:	f2 0a 00 0c 	add	r12,r9,r10
800045f4:	18 5b       	eor	r11,r12
800045f6:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800045f8:	e0 6b 37 20 	mov	r11,14112
800045fc:	ea 1b c6 ef 	orh	r11,0xc6ef
80004600:	16 3a       	cp.w	r10,r11
80004602:	ce 21       	brne	800045c6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004604:	e0 6a 40 1a 	mov	r10,16410
80004608:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000460a:	3f fa       	mov	r10,-1
8000460c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000460e:	30 6b       	mov	r11,6
80004610:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004612:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004614:	48 db       	lddpc	r11,80004648 <xnl_device_auth_reply_func+0x110>
80004616:	96 1c       	ld.sh	r12,r11[0x2]
80004618:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000461a:	96 2b       	ld.sh	r11,r11[0x4]
8000461c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000461e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004620:	30 ca       	mov	r10,12
80004622:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004624:	30 0a       	mov	r10,0
80004626:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000462a:	30 7a       	mov	r10,7
8000462c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004630:	30 2a       	mov	r10,2
80004632:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004636:	fa ca ff ec 	sub	r10,sp,-20
8000463a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000463c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000463e:	1a 9c       	mov	r12,sp
80004640:	f0 1f 00 05 	mcall	80004654 <xnl_device_auth_reply_func+0x11c>
}
80004644:	2c 0d       	sub	sp,-256
80004646:	d8 22       	popm	r4-r7,pc
80004648:	00 00       	add	r0,r0
8000464a:	0b 3e       	ld.ub	lr,r5++
8000464c:	00 00       	add	r0,r0
8000464e:	0b 38       	ld.ub	r8,r5++
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	54 24       	stdsp	sp[0x108],r4
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	43 20       	lddsp	r0,sp[0xc8]

80004658 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004658:	eb cd 40 80 	pushm	r7,lr
8000465c:	fa cd 01 00 	sub	sp,sp,256
80004660:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004662:	49 28       	lddpc	r8,800046a8 <xnl_master_status_brdcst_func+0x50>
80004664:	11 88       	ld.ub	r8,r8[0x0]
80004666:	58 08       	cp.w	r8,0
80004668:	c1 c1       	brne	800046a0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000466a:	49 18       	lddpc	r8,800046ac <xnl_master_status_brdcst_func+0x54>
8000466c:	70 0c       	ld.w	r12,r8[0x0]
8000466e:	30 09       	mov	r9,0
80004670:	12 9a       	mov	r10,r9
80004672:	12 9b       	mov	r11,r9
80004674:	f0 1f 00 0f 	mcall	800046b0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004678:	8e 58       	ld.sh	r8,r7[0xa]
8000467a:	48 c9       	lddpc	r9,800046a8 <xnl_master_status_brdcst_func+0x50>
8000467c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000467e:	e0 68 40 0e 	mov	r8,16398
80004682:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004684:	3f f8       	mov	r8,-1
80004686:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004688:	30 4a       	mov	r10,4
8000468a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000468c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000468e:	92 19       	ld.sh	r9,r9[0x2]
80004690:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004692:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004694:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004696:	30 08       	mov	r8,0
80004698:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000469a:	1a 9c       	mov	r12,sp
8000469c:	f0 1f 00 06 	mcall	800046b4 <xnl_master_status_brdcst_func+0x5c>
}
800046a0:	2c 0d       	sub	sp,-256
800046a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800046a6:	00 00       	add	r0,r0
800046a8:	00 00       	add	r0,r0
800046aa:	0b 3e       	ld.ub	lr,r5++
800046ac:	00 00       	add	r0,r0
800046ae:	0b 38       	ld.ub	r8,r5++
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	54 24       	stdsp	sp[0x108],r4
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	43 20       	lddsp	r0,sp[0xc8]

800046b8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800046b8:	eb cd 40 80 	pushm	r7,lr
800046bc:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046be:	49 38       	lddpc	r8,80004708 <xnl_device_conn_reply_func+0x50>
800046c0:	70 0c       	ld.w	r12,r8[0x0]
800046c2:	30 09       	mov	r9,0
800046c4:	12 9a       	mov	r10,r9
800046c6:	12 9b       	mov	r11,r9
800046c8:	f0 1f 00 11 	mcall	8000470c <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046cc:	ef 18 00 10 	ld.uh	r8,r7[16]
800046d0:	10 99       	mov	r9,r8
800046d2:	e2 19 ff 00 	andl	r9,0xff00,COH
800046d6:	e0 49 01 00 	cp.w	r9,256
800046da:	c0 60       	breq	800046e6 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046dc:	0e 9c       	mov	r12,r7
800046de:	f0 1f 00 0d 	mcall	80004710 <xnl_device_conn_reply_func+0x58>
800046e2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800046e6:	a9 68       	lsl	r8,0x8
800046e8:	48 b9       	lddpc	r9,80004714 <xnl_device_conn_reply_func+0x5c>
800046ea:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800046ec:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800046f0:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800046f2:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800046f6:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800046f8:	30 18       	mov	r8,1
800046fa:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
800046fc:	48 7c       	lddpc	r12,80004718 <xnl_device_conn_reply_func+0x60>
800046fe:	f0 1f 00 08 	mcall	8000471c <xnl_device_conn_reply_func+0x64>
80004702:	e3 cd 80 80 	ldm	sp++,r7,pc
80004706:	00 00       	add	r0,r0
80004708:	00 00       	add	r0,r0
8000470a:	0b 38       	ld.ub	r8,r5++
8000470c:	80 00       	ld.sh	r0,r0[0x0]
8000470e:	54 24       	stdsp	sp[0x108],r4
80004710:	80 00       	ld.sh	r0,r0[0x0]
80004712:	46 58       	lddsp	r8,sp[0x194]
80004714:	00 00       	add	r0,r0
80004716:	0b 3e       	ld.ub	lr,r5++
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	c7 d8       	rjmp	80004814 <_tc_interrupt+0x8>
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	5f bc       	srhi	r12

80004720 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004720:	fe 78 0c 00 	mov	r8,-62464
80004724:	e0 69 03 07 	mov	r9,775
80004728:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
8000472a:	30 49       	mov	r9,4
8000472c:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000472e:	71 59       	ld.w	r9,r8[0x54]
80004730:	e2 19 00 80 	andl	r9,0x80,COH
80004734:	cf d0       	breq	8000472e <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004736:	fe 78 0c 00 	mov	r8,-62464
8000473a:	30 59       	mov	r9,5
8000473c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000473e:	e0 69 01 0d 	mov	r9,269
80004742:	ea 19 10 07 	orh	r9,0x1007
80004746:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004748:	71 59       	ld.w	r9,r8[0x54]
8000474a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000474e:	cf d0       	breq	80004748 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004750:	fe 78 0c 00 	mov	r8,-62464
80004754:	fc 19 00 80 	movh	r9,0x80
80004758:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
8000475a:	34 0a       	mov	r10,64
8000475c:	fe 69 14 00 	mov	r9,-125952
80004760:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004762:	30 69       	mov	r9,6
80004764:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004766:	30 19       	mov	r9,1
80004768:	fe 68 10 00 	mov	r8,-126976
8000476c:	91 19       	st.w	r8[0x4],r9
}
8000476e:	5e fc       	retal	r12

80004770 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004770:	fe 78 10 00 	mov	r8,-61440
80004774:	fc 19 00 10 	movh	r9,0x10
80004778:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000477a:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
8000477c:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000477e:	30 39       	mov	r9,3
80004780:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004784:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004788:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
8000478c:	fe 78 38 00 	mov	r8,-51200
80004790:	30 49       	mov	r9,4
80004792:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004796:	e0 69 91 0d 	mov	r9,37133
8000479a:	ea 19 00 52 	orh	r9,0x52
8000479e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800047a0:	32 09       	mov	r9,32
800047a2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800047a4:	30 59       	mov	r9,5
800047a6:	91 09       	st.w	r8[0x0],r9
}
800047a8:	5e fc       	retal	r12
800047aa:	d7 03       	nop

800047ac <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800047ac:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800047ae:	30 2a       	mov	r10,2
800047b0:	e0 6b 01 c1 	mov	r11,449
800047b4:	48 ec       	lddpc	r12,800047ec <tc_init+0x40>
800047b6:	f0 1f 00 0f 	mcall	800047f0 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800047ba:	48 fb       	lddpc	r11,800047f4 <tc_init+0x48>
800047bc:	fe 7c 38 00 	mov	r12,-51200
800047c0:	f0 1f 00 0e 	mcall	800047f8 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800047c4:	e0 6a 75 30 	mov	r10,30000
800047c8:	30 1b       	mov	r11,1
800047ca:	fe 7c 38 00 	mov	r12,-51200
800047ce:	f0 1f 00 0c 	mcall	800047fc <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800047d2:	48 ca       	lddpc	r10,80004800 <tc_init+0x54>
800047d4:	30 1b       	mov	r11,1
800047d6:	fe 7c 38 00 	mov	r12,-51200
800047da:	f0 1f 00 0b 	mcall	80004804 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800047de:	30 1b       	mov	r11,1
800047e0:	fe 7c 38 00 	mov	r12,-51200
800047e4:	f0 1f 00 09 	mcall	80004808 <tc_init+0x5c>
800047e8:	d8 02       	popm	pc
800047ea:	00 00       	add	r0,r0
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	48 0c       	lddpc	r12,800047ec <tc_init+0x40>
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	48 30       	lddpc	r0,800047fc <tc_init+0x50>
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	c7 f0       	breq	800048f4 <INTC_init_interrupts+0x44>
800047f8:	80 00       	ld.sh	r0,r0[0x0]
800047fa:	49 3c       	lddpc	r12,80004844 <INTC_register_interrupt+0x14>
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	49 fc       	lddpc	r12,80004878 <INTC_register_interrupt+0x48>
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	c7 ec       	rcall	800048fe <INTC_init_interrupts+0x4e>
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	4a 30       	lddpc	r0,80004890 <INTC_register_interrupt+0x60>
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	49 d8       	lddpc	r8,8000487c <INTC_register_interrupt+0x4c>

8000480c <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
8000480c:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000480e:	48 68       	lddpc	r8,80004824 <_tc_interrupt+0x18>
80004810:	70 09       	ld.w	r9,r8[0x0]
80004812:	2f f9       	sub	r9,-1
80004814:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004816:	30 1b       	mov	r11,1
80004818:	fe 7c 38 00 	mov	r12,-51200
8000481c:	f0 1f 00 03 	mcall	80004828 <_tc_interrupt+0x1c>
	
}
80004820:	d4 02       	popm	lr
80004822:	d6 03       	rete
80004824:	00 00       	add	r0,r0
80004826:	0b 5c       	ld.sh	r12,--r5
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	49 ea       	lddpc	r10,800048a0 <INTC_register_interrupt+0x70>

8000482c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000482c:	c0 08       	rjmp	8000482c <_unhandled_interrupt>
8000482e:	d7 03       	nop

80004830 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004830:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004834:	49 99       	lddpc	r9,80004898 <INTC_register_interrupt+0x68>
80004836:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000483a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000483e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004840:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004844:	58 0a       	cp.w	r10,0
80004846:	c0 91       	brne	80004858 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004848:	49 59       	lddpc	r9,8000489c <INTC_register_interrupt+0x6c>
8000484a:	49 6a       	lddpc	r10,800048a0 <INTC_register_interrupt+0x70>
8000484c:	12 1a       	sub	r10,r9
8000484e:	fe 79 08 00 	mov	r9,-63488
80004852:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004856:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004858:	58 1a       	cp.w	r10,1
8000485a:	c0 a1       	brne	8000486e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000485c:	49 09       	lddpc	r9,8000489c <INTC_register_interrupt+0x6c>
8000485e:	49 2a       	lddpc	r10,800048a4 <INTC_register_interrupt+0x74>
80004860:	12 1a       	sub	r10,r9
80004862:	bf aa       	sbr	r10,0x1e
80004864:	fe 79 08 00 	mov	r9,-63488
80004868:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000486c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000486e:	58 2a       	cp.w	r10,2
80004870:	c0 a1       	brne	80004884 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004872:	48 b9       	lddpc	r9,8000489c <INTC_register_interrupt+0x6c>
80004874:	48 da       	lddpc	r10,800048a8 <INTC_register_interrupt+0x78>
80004876:	12 1a       	sub	r10,r9
80004878:	bf ba       	sbr	r10,0x1f
8000487a:	fe 79 08 00 	mov	r9,-63488
8000487e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004882:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004884:	48 69       	lddpc	r9,8000489c <INTC_register_interrupt+0x6c>
80004886:	48 aa       	lddpc	r10,800048ac <INTC_register_interrupt+0x7c>
80004888:	12 1a       	sub	r10,r9
8000488a:	ea 1a c0 00 	orh	r10,0xc000
8000488e:	fe 79 08 00 	mov	r9,-63488
80004892:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004896:	5e fc       	retal	r12
80004898:	80 00       	ld.sh	r0,r0[0x0]
8000489a:	c7 f8       	rjmp	80004998 <tc_init_waveform+0x5c>
8000489c:	80 00       	ld.sh	r0,r0[0x0]
8000489e:	be 00       	st.h	pc[0x0],r0
800048a0:	80 00       	ld.sh	r0,r0[0x0]
800048a2:	bf 04       	ld.d	r4,pc
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	bf 12       	ld.d	r2,--pc
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	bf 20       	st.d	pc++,r0
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	bf 2e       	st.d	pc++,lr

800048b0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800048b0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048b2:	49 18       	lddpc	r8,800048f4 <INTC_init_interrupts+0x44>
800048b4:	e3 b8 00 01 	mtsr	0x4,r8
800048b8:	49 0e       	lddpc	lr,800048f8 <INTC_init_interrupts+0x48>
800048ba:	30 07       	mov	r7,0
800048bc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800048be:	49 0c       	lddpc	r12,800048fc <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800048c0:	49 05       	lddpc	r5,80004900 <INTC_init_interrupts+0x50>
800048c2:	10 15       	sub	r5,r8
800048c4:	fe 76 08 00 	mov	r6,-63488
800048c8:	c1 08       	rjmp	800048e8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048ca:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800048cc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800048ce:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800048d0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800048d4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800048d6:	10 3a       	cp.w	r10,r8
800048d8:	fe 9b ff fc 	brhi	800048d0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800048dc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800048e0:	2f f7       	sub	r7,-1
800048e2:	2f 8e       	sub	lr,-8
800048e4:	59 37       	cp.w	r7,19
800048e6:	c0 50       	breq	800048f0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800048e8:	7c 08       	ld.w	r8,lr[0x0]
800048ea:	58 08       	cp.w	r8,0
800048ec:	ce f1       	brne	800048ca <INTC_init_interrupts+0x1a>
800048ee:	cf 7b       	rjmp	800048dc <INTC_init_interrupts+0x2c>
800048f0:	d8 22       	popm	r4-r7,pc
800048f2:	00 00       	add	r0,r0
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	be 00       	st.h	pc[0x0],r0
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	c7 f8       	rjmp	800049f8 <tc_read_sr+0xe>
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	48 2c       	lddpc	r12,80004904 <_get_interrupt_handler>
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	bf 04       	ld.d	r4,pc

80004904 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004904:	fe 78 08 00 	mov	r8,-63488
80004908:	e0 69 00 83 	mov	r9,131
8000490c:	f2 0c 01 0c 	sub	r12,r9,r12
80004910:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004914:	f2 ca ff c0 	sub	r10,r9,-64
80004918:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000491c:	58 08       	cp.w	r8,0
8000491e:	c0 21       	brne	80004922 <_get_interrupt_handler+0x1e>
80004920:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004922:	f0 08 12 00 	clz	r8,r8
80004926:	48 5a       	lddpc	r10,80004938 <_get_interrupt_handler+0x34>
80004928:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000492c:	f0 08 11 1f 	rsub	r8,r8,31
80004930:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004932:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004936:	5e fc       	retal	r12
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	c7 f8       	rjmp	80004a38 <tc_configure_interrupts+0x8>

8000493c <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
8000493c:	76 09       	ld.w	r9,r11[0x0]
8000493e:	58 29       	cp.w	r9,2
80004940:	e0 88 00 03 	brls	80004946 <tc_init_waveform+0xa>
80004944:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004946:	76 18       	ld.w	r8,r11[0x4]
80004948:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000494c:	af ba       	sbr	r10,0xf
8000494e:	10 9b       	mov	r11,r8
80004950:	e6 1b c0 00 	andh	r11,0xc000,COH
80004954:	16 4a       	or	r10,r11
80004956:	10 9b       	mov	r11,r8
80004958:	e6 1b 30 00 	andh	r11,0x3000,COH
8000495c:	16 4a       	or	r10,r11
8000495e:	10 9b       	mov	r11,r8
80004960:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004964:	16 4a       	or	r10,r11
80004966:	10 9b       	mov	r11,r8
80004968:	e6 1b 03 00 	andh	r11,0x300,COH
8000496c:	16 4a       	or	r10,r11
8000496e:	10 9b       	mov	r11,r8
80004970:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004974:	16 4a       	or	r10,r11
80004976:	10 9b       	mov	r11,r8
80004978:	e6 1b 00 30 	andh	r11,0x30,COH
8000497c:	16 4a       	or	r10,r11
8000497e:	10 9b       	mov	r11,r8
80004980:	e6 1b 00 0c 	andh	r11,0xc,COH
80004984:	16 4a       	or	r10,r11
80004986:	10 9b       	mov	r11,r8
80004988:	e6 1b 00 03 	andh	r11,0x3,COH
8000498c:	16 4a       	or	r10,r11
8000498e:	10 9b       	mov	r11,r8
80004990:	e2 1b 60 00 	andl	r11,0x6000,COH
80004994:	16 4a       	or	r10,r11
80004996:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
8000499a:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
8000499e:	10 9b       	mov	r11,r8
800049a0:	e2 1b 0c 00 	andl	r11,0xc00,COH
800049a4:	16 4a       	or	r10,r11
800049a6:	10 9b       	mov	r11,r8
800049a8:	e2 1b 03 00 	andl	r11,0x300,COH
800049ac:	16 4a       	or	r10,r11
800049ae:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800049b2:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800049b6:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800049ba:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800049be:	10 9b       	mov	r11,r8
800049c0:	e2 1b 00 30 	andl	r11,0x30,COH
800049c4:	16 4a       	or	r10,r11
800049c6:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800049ca:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800049ce:	a5 69       	lsl	r9,0x4
800049d0:	2f f9       	sub	r9,-1
800049d2:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800049d6:	5e fd       	retal	0

800049d8 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800049d8:	58 2b       	cp.w	r11,2
800049da:	e0 88 00 03 	brls	800049e0 <tc_start+0x8>
800049de:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800049e0:	a7 6b       	lsl	r11,0x6
800049e2:	16 0c       	add	r12,r11
800049e4:	30 58       	mov	r8,5
800049e6:	99 08       	st.w	r12[0x0],r8
800049e8:	5e fd       	retal	0

800049ea <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800049ea:	58 2b       	cp.w	r11,2
800049ec:	e0 88 00 03 	brls	800049f2 <tc_read_sr+0x8>
800049f0:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800049f2:	a7 6b       	lsl	r11,0x6
800049f4:	2e 0b       	sub	r11,-32
800049f6:	16 0c       	add	r12,r11
800049f8:	78 0c       	ld.w	r12,r12[0x0]
}
800049fa:	5e fc       	retal	r12

800049fc <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800049fc:	58 2b       	cp.w	r11,2
800049fe:	e0 88 00 03 	brls	80004a04 <tc_write_rc+0x8>
80004a02:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004a04:	f6 08 15 04 	lsl	r8,r11,0x4
80004a08:	2f f8       	sub	r8,-1
80004a0a:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004a0e:	e2 18 80 00 	andl	r8,0x8000,COH
80004a12:	c0 c0       	breq	80004a2a <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004a14:	a7 6b       	lsl	r11,0x6
80004a16:	16 0c       	add	r12,r11
80004a18:	2e 4c       	sub	r12,-28
80004a1a:	78 08       	ld.w	r8,r12[0x0]
80004a1c:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a20:	e0 18 00 00 	andl	r8,0x0
80004a24:	f3 e8 10 08 	or	r8,r9,r8
80004a28:	99 08       	st.w	r12[0x0],r8

  return value;
80004a2a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004a2e:	5e fc       	retal	r12

80004a30 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004a30:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004a34:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a38:	58 2b       	cp.w	r11,2
80004a3a:	e0 88 00 04 	brls	80004a42 <tc_configure_interrupts+0x12>
80004a3e:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004a42:	ee 19 00 01 	eorh	r9,0x1
80004a46:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004a4a:	74 08       	ld.w	r8,r10[0x0]
80004a4c:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004a50:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004a54:	a7 6e       	lsl	lr,0x6
80004a56:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004a5a:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004a5e:	0e 4e       	or	lr,r7
80004a60:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004a64:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004a68:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004a6c:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004a70:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004a74:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004a78:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004a7c:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004a80:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004a84:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004a88:	f6 0e 15 06 	lsl	lr,r11,0x6
80004a8c:	f8 0e 00 0e 	add	lr,r12,lr
80004a90:	2d ce       	sub	lr,-36
80004a92:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004a94:	58 09       	cp.w	r9,0
80004a96:	c0 20       	breq	80004a9a <tc_configure_interrupts+0x6a>
80004a98:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004a9a:	74 08       	ld.w	r8,r10[0x0]
80004a9c:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004aa0:	e0 65 00 80 	mov	r5,128
80004aa4:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004aa8:	74 08       	ld.w	r8,r10[0x0]
80004aaa:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004aae:	f9 b4 00 40 	moveq	r4,64
80004ab2:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004ab6:	74 08       	ld.w	r8,r10[0x0]
80004ab8:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004abc:	f9 b3 00 20 	moveq	r3,32
80004ac0:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004ac4:	74 08       	ld.w	r8,r10[0x0]
80004ac6:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004aca:	f9 b2 00 10 	moveq	r2,16
80004ace:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004ad2:	74 08       	ld.w	r8,r10[0x0]
80004ad4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004ad8:	f9 b6 00 08 	moveq	r6,8
80004adc:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004ae0:	74 08       	ld.w	r8,r10[0x0]
80004ae2:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004ae6:	f9 b7 00 04 	moveq	r7,4
80004aea:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004aee:	74 08       	ld.w	r8,r10[0x0]
80004af0:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004af4:	f9 be 00 02 	moveq	lr,2
80004af8:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004afc:	74 08       	ld.w	r8,r10[0x0]
80004afe:	ec 18 00 01 	eorl	r8,0x1
80004b02:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b06:	eb e8 10 08 	or	r8,r5,r8
80004b0a:	08 48       	or	r8,r4
80004b0c:	06 48       	or	r8,r3
80004b0e:	04 48       	or	r8,r2
80004b10:	0c 48       	or	r8,r6
80004b12:	0e 48       	or	r8,r7
80004b14:	1c 48       	or	r8,lr
80004b16:	f6 0a 15 06 	lsl	r10,r11,0x6
80004b1a:	f8 0a 00 0a 	add	r10,r12,r10
80004b1e:	2d 8a       	sub	r10,-40
80004b20:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004b22:	a7 6b       	lsl	r11,0x6
80004b24:	2e 0b       	sub	r11,-32
80004b26:	16 0c       	add	r12,r11
80004b28:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004b2a:	58 09       	cp.w	r9,0
80004b2c:	c0 31       	brne	80004b32 <tc_configure_interrupts+0x102>
80004b2e:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004b32:	d5 03       	csrf	0x10
80004b34:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004b38 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004b38:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004b3a:	f6 08 15 04 	lsl	r8,r11,0x4
80004b3e:	14 38       	cp.w	r8,r10
80004b40:	f9 b8 08 10 	movls	r8,16
80004b44:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004b48:	f0 0b 02 4b 	mul	r11,r8,r11
80004b4c:	f6 09 16 01 	lsr	r9,r11,0x1
80004b50:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004b54:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004b58:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004b5c:	f2 cb 00 01 	sub	r11,r9,1
80004b60:	e0 4b ff fe 	cp.w	r11,65534
80004b64:	e0 88 00 03 	brls	80004b6a <usart_set_async_baudrate+0x32>
80004b68:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004b6a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004b6c:	e8 6e 00 00 	mov	lr,524288
80004b70:	59 08       	cp.w	r8,16
80004b72:	fc 08 17 10 	movne	r8,lr
80004b76:	f9 b8 00 00 	moveq	r8,0
80004b7a:	e4 1b ff f7 	andh	r11,0xfff7
80004b7e:	e0 1b fe cf 	andl	r11,0xfecf
80004b82:	16 48       	or	r8,r11
80004b84:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004b86:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004b8a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004b8e:	99 89       	st.w	r12[0x20],r9
80004b90:	d8 0a       	popm	pc,r12=0

80004b92 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004b92:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004b94:	e2 18 00 02 	andl	r8,0x2,COH
80004b98:	c0 31       	brne	80004b9e <usart_write_char+0xc>
80004b9a:	30 2c       	mov	r12,2
80004b9c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004b9e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004ba2:	99 7b       	st.w	r12[0x1c],r11
80004ba4:	5e fd       	retal	0
80004ba6:	d7 03       	nop

80004ba8 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004ba8:	eb cd 40 e0 	pushm	r5-r7,lr
80004bac:	18 96       	mov	r6,r12
80004bae:	16 95       	mov	r5,r11
80004bb0:	e0 67 27 0f 	mov	r7,9999
80004bb4:	c0 68       	rjmp	80004bc0 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004bb6:	58 07       	cp.w	r7,0
80004bb8:	c0 31       	brne	80004bbe <usart_putchar+0x16>
80004bba:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004bbe:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004bc0:	0a 9b       	mov	r11,r5
80004bc2:	0c 9c       	mov	r12,r6
80004bc4:	f0 1f 00 03 	mcall	80004bd0 <usart_putchar+0x28>
80004bc8:	cf 71       	brne	80004bb6 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004bce:	00 00       	add	r0,r0
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	4b 92       	lddpc	r2,80004cb4 <usart_init_rs232+0x40>

80004bd4 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004bd4:	78 58       	ld.w	r8,r12[0x14]
80004bd6:	e2 18 00 e0 	andl	r8,0xe0,COH
80004bda:	c0 30       	breq	80004be0 <usart_read_char+0xc>
80004bdc:	30 4c       	mov	r12,4
80004bde:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004be0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004be2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004be6:	c0 31       	brne	80004bec <usart_read_char+0x18>
80004be8:	30 3c       	mov	r12,3
80004bea:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004bec:	78 68       	ld.w	r8,r12[0x18]
80004bee:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004bf2:	97 08       	st.w	r11[0x0],r8
80004bf4:	5e fd       	retal	0
80004bf6:	d7 03       	nop

80004bf8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004bf8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bfc:	20 1d       	sub	sp,4
80004bfe:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004c00:	1a 97       	mov	r7,sp
80004c02:	1a 9b       	mov	r11,sp
80004c04:	0c 9c       	mov	r12,r6
80004c06:	f0 1f 00 07 	mcall	80004c20 <usart_getchar+0x28>
80004c0a:	58 3c       	cp.w	r12,3
80004c0c:	cf b0       	breq	80004c02 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004c0e:	58 4c       	cp.w	r12,4
80004c10:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004c14:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004c18:	2f fd       	sub	sp,-4
80004c1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c1e:	00 00       	add	r0,r0
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	4b d4       	lddpc	r4,80004d14 <usart_init_rs232+0xa0>

80004c24 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004c24:	eb cd 40 c0 	pushm	r6-r7,lr
80004c28:	18 96       	mov	r6,r12
80004c2a:	16 97       	mov	r7,r11
  while (*string != '\0')
80004c2c:	17 8b       	ld.ub	r11,r11[0x0]
80004c2e:	58 0b       	cp.w	r11,0
80004c30:	c0 80       	breq	80004c40 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004c32:	2f f7       	sub	r7,-1
80004c34:	0c 9c       	mov	r12,r6
80004c36:	f0 1f 00 04 	mcall	80004c44 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004c3a:	0f 8b       	ld.ub	r11,r7[0x0]
80004c3c:	58 0b       	cp.w	r11,0
80004c3e:	cf a1       	brne	80004c32 <usart_write_line+0xe>
80004c40:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	4b a8       	lddpc	r8,80004d2c <usart_init_rs232+0xb8>

80004c48 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004c48:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004c4c:	e6 18 00 01 	andh	r8,0x1,COH
80004c50:	c0 71       	brne	80004c5e <usart_reset+0x16>
80004c52:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004c54:	3f f8       	mov	r8,-1
80004c56:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004c58:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004c5a:	d5 03       	csrf	0x10
80004c5c:	c0 48       	rjmp	80004c64 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004c5e:	3f f8       	mov	r8,-1
80004c60:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004c62:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004c64:	30 08       	mov	r8,0
80004c66:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004c68:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004c6a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004c6c:	ea 68 61 0c 	mov	r8,680204
80004c70:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004c72:	5e fc       	retal	r12

80004c74 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004c74:	eb cd 40 e0 	pushm	r5-r7,lr
80004c78:	18 96       	mov	r6,r12
80004c7a:	16 97       	mov	r7,r11
80004c7c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004c7e:	f0 1f 00 2f 	mcall	80004d38 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004c82:	58 07       	cp.w	r7,0
80004c84:	c5 80       	breq	80004d34 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004c86:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004c88:	30 49       	mov	r9,4
80004c8a:	f2 08 18 00 	cp.b	r8,r9
80004c8e:	e0 88 00 53 	brls	80004d34 <usart_init_rs232+0xc0>
80004c92:	30 99       	mov	r9,9
80004c94:	f2 08 18 00 	cp.b	r8,r9
80004c98:	e0 8b 00 4e 	brhi	80004d34 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004c9c:	0f d9       	ld.ub	r9,r7[0x5]
80004c9e:	30 78       	mov	r8,7
80004ca0:	f0 09 18 00 	cp.b	r9,r8
80004ca4:	e0 8b 00 48 	brhi	80004d34 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004ca8:	8e 39       	ld.sh	r9,r7[0x6]
80004caa:	e0 68 01 01 	mov	r8,257
80004cae:	f0 09 19 00 	cp.h	r9,r8
80004cb2:	e0 8b 00 41 	brhi	80004d34 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004cb6:	ef 39 00 08 	ld.ub	r9,r7[8]
80004cba:	30 38       	mov	r8,3
80004cbc:	f0 09 18 00 	cp.b	r9,r8
80004cc0:	e0 8b 00 3a 	brhi	80004d34 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004cc4:	0a 9a       	mov	r10,r5
80004cc6:	6e 0b       	ld.w	r11,r7[0x0]
80004cc8:	0c 9c       	mov	r12,r6
80004cca:	f0 1f 00 1d 	mcall	80004d3c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004cce:	58 1c       	cp.w	r12,1
80004cd0:	c3 20       	breq	80004d34 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004cd2:	0f c8       	ld.ub	r8,r7[0x4]
80004cd4:	30 99       	mov	r9,9
80004cd6:	f2 08 18 00 	cp.b	r8,r9
80004cda:	c0 51       	brne	80004ce4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004cdc:	6c 18       	ld.w	r8,r6[0x4]
80004cde:	b1 b8       	sbr	r8,0x11
80004ce0:	8d 18       	st.w	r6[0x4],r8
80004ce2:	c0 68       	rjmp	80004cee <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004ce4:	6c 19       	ld.w	r9,r6[0x4]
80004ce6:	20 58       	sub	r8,5
80004ce8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004cec:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004cee:	6c 19       	ld.w	r9,r6[0x4]
80004cf0:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004cf4:	0f d8       	ld.ub	r8,r7[0x5]
80004cf6:	a9 78       	lsl	r8,0x9
80004cf8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004cfc:	12 48       	or	r8,r9
80004cfe:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004d00:	8e 38       	ld.sh	r8,r7[0x6]
80004d02:	30 29       	mov	r9,2
80004d04:	f2 08 19 00 	cp.h	r8,r9
80004d08:	e0 88 00 09 	brls	80004d1a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004d0c:	6c 18       	ld.w	r8,r6[0x4]
80004d0e:	ad b8       	sbr	r8,0xd
80004d10:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004d12:	8e b8       	ld.uh	r8,r7[0x6]
80004d14:	20 28       	sub	r8,2
80004d16:	8d a8       	st.w	r6[0x28],r8
80004d18:	c0 68       	rjmp	80004d24 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004d1a:	6c 19       	ld.w	r9,r6[0x4]
80004d1c:	5c 78       	castu.h	r8
80004d1e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004d22:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004d24:	6c 18       	ld.w	r8,r6[0x4]
80004d26:	e0 18 ff f0 	andl	r8,0xfff0
80004d2a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004d2c:	35 08       	mov	r8,80
80004d2e:	8d 08       	st.w	r6[0x0],r8
80004d30:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004d34:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	4c 48       	lddpc	r8,80004e48 <pxPortInitialiseStack+0x78>
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	4b 38       	lddpc	r8,80004e08 <pxPortInitialiseStack+0x38>

80004d40 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004d40:	f8 c8 ff f8 	sub	r8,r12,-8
80004d44:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004d46:	3f f9       	mov	r9,-1
80004d48:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004d4a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004d4c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004d4e:	30 08       	mov	r8,0
80004d50:	99 08       	st.w	r12[0x0],r8
}
80004d52:	5e fc       	retal	r12

80004d54 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004d54:	30 08       	mov	r8,0
80004d56:	99 48       	st.w	r12[0x10],r8
}
80004d58:	5e fc       	retal	r12

80004d5a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004d5a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004d5c:	70 19       	ld.w	r9,r8[0x4]
80004d5e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004d60:	78 19       	ld.w	r9,r12[0x4]
80004d62:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004d64:	70 19       	ld.w	r9,r8[0x4]
80004d66:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004d68:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004d6a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004d6c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004d6e:	78 08       	ld.w	r8,r12[0x0]
80004d70:	2f f8       	sub	r8,-1
80004d72:	99 08       	st.w	r12[0x0],r8
}
80004d74:	5e fc       	retal	r12

80004d76 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004d76:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004d78:	5b fa       	cp.w	r10,-1
80004d7a:	c0 31       	brne	80004d80 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004d7c:	78 48       	ld.w	r8,r12[0x10]
80004d7e:	c0 c8       	rjmp	80004d96 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004d80:	f8 c8 ff f8 	sub	r8,r12,-8
80004d84:	70 19       	ld.w	r9,r8[0x4]
80004d86:	72 09       	ld.w	r9,r9[0x0]
80004d88:	12 3a       	cp.w	r10,r9
80004d8a:	c0 63       	brcs	80004d96 <vListInsert+0x20>
80004d8c:	70 18       	ld.w	r8,r8[0x4]
80004d8e:	70 19       	ld.w	r9,r8[0x4]
80004d90:	72 09       	ld.w	r9,r9[0x0]
80004d92:	12 3a       	cp.w	r10,r9
80004d94:	cf c2       	brcc	80004d8c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004d96:	70 19       	ld.w	r9,r8[0x4]
80004d98:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004d9a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004d9c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004d9e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004da0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004da2:	78 08       	ld.w	r8,r12[0x0]
80004da4:	2f f8       	sub	r8,-1
80004da6:	99 08       	st.w	r12[0x0],r8
}
80004da8:	5e fc       	retal	r12

80004daa <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004daa:	78 18       	ld.w	r8,r12[0x4]
80004dac:	78 29       	ld.w	r9,r12[0x8]
80004dae:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004db0:	78 28       	ld.w	r8,r12[0x8]
80004db2:	78 19       	ld.w	r9,r12[0x4]
80004db4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004db6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004db8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004dba:	18 39       	cp.w	r9,r12
80004dbc:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004dc0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004dc4:	30 09       	mov	r9,0
80004dc6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004dc8:	70 09       	ld.w	r9,r8[0x0]
80004dca:	20 19       	sub	r9,1
80004dcc:	91 09       	st.w	r8[0x0],r9
}
80004dce:	5e fc       	retal	r12

80004dd0 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004dd0:	e0 68 08 08 	mov	r8,2056
80004dd4:	ea 18 08 08 	orh	r8,0x808
80004dd8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004dda:	e0 68 09 09 	mov	r8,2313
80004dde:	ea 18 09 09 	orh	r8,0x909
80004de2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004de4:	e0 68 0a 0a 	mov	r8,2570
80004de8:	ea 18 0a 0a 	orh	r8,0xa0a
80004dec:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004dee:	e0 68 0b 0b 	mov	r8,2827
80004df2:	ea 18 0b 0b 	orh	r8,0xb0b
80004df6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004df8:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004dfa:	e0 68 be ef 	mov	r8,48879
80004dfe:	ea 18 de ad 	orh	r8,0xdead
80004e02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004e04:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004e06:	fc 18 00 40 	movh	r8,0x40
80004e0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004e0c:	e0 68 00 ff 	mov	r8,255
80004e10:	ea 18 ff 00 	orh	r8,0xff00
80004e14:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004e16:	e0 68 01 01 	mov	r8,257
80004e1a:	ea 18 01 01 	orh	r8,0x101
80004e1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004e20:	e0 68 02 02 	mov	r8,514
80004e24:	ea 18 02 02 	orh	r8,0x202
80004e28:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004e2a:	e0 68 03 03 	mov	r8,771
80004e2e:	ea 18 03 03 	orh	r8,0x303
80004e32:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004e34:	e0 68 04 04 	mov	r8,1028
80004e38:	ea 18 04 04 	orh	r8,0x404
80004e3c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004e3e:	e0 68 05 05 	mov	r8,1285
80004e42:	ea 18 05 05 	orh	r8,0x505
80004e46:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004e48:	e0 68 06 06 	mov	r8,1542
80004e4c:	ea 18 06 06 	orh	r8,0x606
80004e50:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004e52:	e0 68 07 07 	mov	r8,1799
80004e56:	ea 18 07 07 	orh	r8,0x707
80004e5a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004e5c:	30 08       	mov	r8,0
80004e5e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004e60:	5e fc       	retal	r12
80004e62:	d7 03       	nop

80004e64 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004e64:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004e66:	48 38       	lddpc	r8,80004e70 <vPortEnterCritical+0xc>
80004e68:	70 09       	ld.w	r9,r8[0x0]
80004e6a:	2f f9       	sub	r9,-1
80004e6c:	91 09       	st.w	r8[0x0],r9
}
80004e6e:	5e fc       	retal	r12
80004e70:	00 00       	add	r0,r0
80004e72:	05 3c       	ld.ub	r12,r2++

80004e74 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004e74:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004e76:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004e78:	30 0a       	mov	r10,0
80004e7a:	14 9b       	mov	r11,r10
80004e7c:	49 2c       	lddpc	r12,80004ec4 <xPortStartScheduler+0x50>
80004e7e:	f0 1f 00 13 	mcall	80004ec8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004e82:	e0 68 5d c0 	mov	r8,24000
80004e86:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004e8a:	30 08       	mov	r8,0
80004e8c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004e90:	e0 68 0c d8 	mov	r8,3288
80004e94:	ea 18 00 00 	orh	r8,0x0
80004e98:	70 00       	ld.w	r0,r8[0x0]
80004e9a:	60 0d       	ld.w	sp,r0[0x0]
80004e9c:	1b 00       	ld.w	r0,sp++
80004e9e:	e0 68 05 3c 	mov	r8,1340
80004ea2:	ea 18 00 00 	orh	r8,0x0
80004ea6:	91 00       	st.w	r8[0x0],r0
80004ea8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004eac:	2f ed       	sub	sp,-8
80004eae:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004eb2:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004eb6:	e3 b0 00 00 	mtsr	0x0,r0
80004eba:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004ebe:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004ec2:	d8 0a       	popm	pc,r12=0
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	4f 90       	lddpc	r0,800050a8 <vPortFree>
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	48 30       	lddpc	r0,80004ed4 <SCALLYield+0x8>

80004ecc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004ecc:	20 6d       	sub	sp,24
80004ece:	eb cd 00 ff 	pushm	r0-r7
80004ed2:	fa c7 ff c0 	sub	r7,sp,-64
80004ed6:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004eda:	ef 40 ff e0 	st.w	r7[-32],r0
80004ede:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004ee2:	ef 40 ff e4 	st.w	r7[-28],r0
80004ee6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004eea:	e0 68 05 3c 	mov	r8,1340
80004eee:	ea 18 00 00 	orh	r8,0x0
80004ef2:	70 00       	ld.w	r0,r8[0x0]
80004ef4:	1a d0       	st.w	--sp,r0
80004ef6:	f0 1f 00 1a 	mcall	80004f5c <LABEL_RET_SCALL_263+0x14>
80004efa:	e0 68 0c d8 	mov	r8,3288
80004efe:	ea 18 00 00 	orh	r8,0x0
80004f02:	70 00       	ld.w	r0,r8[0x0]
80004f04:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f06:	f0 1f 00 17 	mcall	80004f60 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f0a:	e0 68 0c d8 	mov	r8,3288
80004f0e:	ea 18 00 00 	orh	r8,0x0
80004f12:	70 00       	ld.w	r0,r8[0x0]
80004f14:	60 0d       	ld.w	sp,r0[0x0]
80004f16:	1b 00       	ld.w	r0,sp++
80004f18:	e0 68 05 3c 	mov	r8,1340
80004f1c:	ea 18 00 00 	orh	r8,0x0
80004f20:	91 00       	st.w	r8[0x0],r0
80004f22:	fa c7 ff d8 	sub	r7,sp,-40
80004f26:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004f2a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004f2e:	e0 61 05 3c 	mov	r1,1340
80004f32:	ea 11 00 00 	orh	r1,0x0
80004f36:	62 02       	ld.w	r2,r1[0x0]
80004f38:	58 02       	cp.w	r2,0
80004f3a:	c0 70       	breq	80004f48 <LABEL_RET_SCALL_263>
80004f3c:	e4 c2 00 01 	sub	r2,r2,1
80004f40:	83 02       	st.w	r1[0x0],r2
80004f42:	58 02       	cp.w	r2,0
80004f44:	c0 21       	brne	80004f48 <LABEL_RET_SCALL_263>
80004f46:	b1 c0       	cbr	r0,0x10

80004f48 <LABEL_RET_SCALL_263>:
80004f48:	ef 40 ff f8 	st.w	r7[-8],r0
80004f4c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004f50:	ef 40 ff fc 	st.w	r7[-4],r0
80004f54:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f58:	2f ad       	sub	sp,-24
80004f5a:	d6 13       	rets
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	4e 64       	lddpc	r4,800050f4 <pvPortMalloc+0x24>
80004f60:	80 00       	ld.sh	r0,r0[0x0]
80004f62:	55 a8       	stdsp	sp[0x168],r8

80004f64 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004f64:	e1 b8 00 43 	mfsr	r8,0x10c
80004f68:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004f6c:	5e fc       	retal	r12
80004f6e:	d7 03       	nop

80004f70 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004f70:	48 78       	lddpc	r8,80004f8c <vPortExitCritical+0x1c>
80004f72:	70 08       	ld.w	r8,r8[0x0]
80004f74:	58 08       	cp.w	r8,0
80004f76:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004f78:	48 58       	lddpc	r8,80004f8c <vPortExitCritical+0x1c>
80004f7a:	70 09       	ld.w	r9,r8[0x0]
80004f7c:	20 19       	sub	r9,1
80004f7e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004f80:	70 08       	ld.w	r8,r8[0x0]
80004f82:	58 08       	cp.w	r8,0
80004f84:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004f86:	d5 03       	csrf	0x10
80004f88:	5e fc       	retal	r12
80004f8a:	00 00       	add	r0,r0
80004f8c:	00 00       	add	r0,r0
80004f8e:	05 3c       	ld.ub	r12,r2++

80004f90 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004f90:	eb cd 00 ff 	pushm	r0-r7
80004f94:	e0 68 05 3c 	mov	r8,1340
80004f98:	ea 18 00 00 	orh	r8,0x0
80004f9c:	70 00       	ld.w	r0,r8[0x0]
80004f9e:	1a d0       	st.w	--sp,r0
80004fa0:	7a 90       	ld.w	r0,sp[0x24]
80004fa2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004fa6:	58 10       	cp.w	r0,1
80004fa8:	e0 8b 00 08 	brhi	80004fb8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004fac:	e0 68 0c d8 	mov	r8,3288
80004fb0:	ea 18 00 00 	orh	r8,0x0
80004fb4:	70 00       	ld.w	r0,r8[0x0]
80004fb6:	81 0d       	st.w	r0[0x0],sp

80004fb8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004fb8:	f0 1f 00 12 	mcall	80005000 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004fbc:	f0 1f 00 12 	mcall	80005004 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004fc0:	f0 1f 00 12 	mcall	80005008 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004fc4:	f0 1f 00 12 	mcall	8000500c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004fc8:	7a 90       	ld.w	r0,sp[0x24]
80004fca:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004fce:	58 10       	cp.w	r0,1
80004fd0:	e0 8b 00 0e 	brhi	80004fec <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004fd4:	f0 1f 00 0c 	mcall	80005004 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004fd8:	f0 1f 00 0e 	mcall	80005010 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004fdc:	f0 1f 00 0c 	mcall	8000500c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004fe0:	e0 68 0c d8 	mov	r8,3288
80004fe4:	ea 18 00 00 	orh	r8,0x0
80004fe8:	70 00       	ld.w	r0,r8[0x0]
80004fea:	60 0d       	ld.w	sp,r0[0x0]

80004fec <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004fec:	1b 00       	ld.w	r0,sp++
80004fee:	e0 68 05 3c 	mov	r8,1340
80004ff2:	ea 18 00 00 	orh	r8,0x0
80004ff6:	91 00       	st.w	r8[0x0],r0
80004ff8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004ffc:	d6 03       	rete
80004ffe:	00 00       	add	r0,r0
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	4f 64       	lddpc	r4,800051d8 <prvUnlockQueue+0x60>
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	4e 64       	lddpc	r4,8000519c <prvUnlockQueue+0x24>
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	57 ac       	stdsp	sp[0x1e8],r12
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	4f 70       	lddpc	r0,800051e8 <prvUnlockQueue+0x70>
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	55 a8       	stdsp	sp[0x168],r8

80005014 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005014:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005016:	f0 1f 00 02 	mcall	8000501c <__malloc_lock+0x8>
}
8000501a:	d8 02       	popm	pc
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	55 98       	stdsp	sp[0x164],r8

80005020 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005020:	d4 01       	pushm	lr
	xTaskResumeAll();
80005022:	f0 1f 00 02 	mcall	80005028 <__malloc_unlock+0x8>
}
80005026:	d8 02       	popm	pc
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	59 54       	cp.w	r4,21

8000502c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
8000502c:	d4 21       	pushm	r4-r7,lr
8000502e:	16 95       	mov	r5,r11
80005030:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005032:	58 0c       	cp.w	r12,0
80005034:	c0 30       	breq	8000503a <_read+0xe>
80005036:	3f f7       	mov	r7,-1
80005038:	c1 48       	rjmp	80005060 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000503a:	58 0a       	cp.w	r10,0
8000503c:	e0 89 00 04 	brgt	80005044 <_read+0x18>
80005040:	30 07       	mov	r7,0
80005042:	c0 f8       	rjmp	80005060 <_read+0x34>
80005044:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005046:	48 84       	lddpc	r4,80005064 <_read+0x38>
80005048:	68 0c       	ld.w	r12,r4[0x0]
8000504a:	f0 1f 00 08 	mcall	80005068 <_read+0x3c>
    if (c < 0)
8000504e:	c0 95       	brlt	80005060 <_read+0x34>
      break;

    *ptr++ = c;
80005050:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005054:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005056:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000505a:	58 08       	cp.w	r8,0
8000505c:	fe 99 ff f6 	brgt	80005048 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005060:	0e 9c       	mov	r12,r7
80005062:	d8 22       	popm	r4-r7,pc
80005064:	00 00       	add	r0,r0
80005066:	40 f8       	lddsp	r8,sp[0x3c]
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	4b f8       	lddpc	r8,80005164 <xQueueReceiveFromISR+0x3c>

8000506c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
8000506c:	d4 21       	pushm	r4-r7,lr
8000506e:	16 95       	mov	r5,r11
80005070:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005072:	20 1c       	sub	r12,1
80005074:	58 2c       	cp.w	r12,2
80005076:	e0 8b 00 12 	brhi	8000509a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000507a:	58 0a       	cp.w	r10,0
8000507c:	c0 31       	brne	80005082 <_write+0x16>
8000507e:	30 07       	mov	r7,0
80005080:	c0 e8       	rjmp	8000509c <_write+0x30>
80005082:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005084:	48 74       	lddpc	r4,800050a0 <_write+0x34>
80005086:	68 0c       	ld.w	r12,r4[0x0]
80005088:	ea 07 07 0b 	ld.ub	r11,r5[r7]
8000508c:	f0 1f 00 06 	mcall	800050a4 <_write+0x38>
80005090:	c0 55       	brlt	8000509a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005092:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005094:	0e 36       	cp.w	r6,r7
80005096:	cf 81       	brne	80005086 <_write+0x1a>
80005098:	c0 28       	rjmp	8000509c <_write+0x30>
8000509a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
8000509c:	0e 9c       	mov	r12,r7
8000509e:	d8 22       	popm	r4-r7,pc
800050a0:	00 00       	add	r0,r0
800050a2:	40 f8       	lddsp	r8,sp[0x3c]
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	4b a8       	lddpc	r8,8000518c <prvUnlockQueue+0x14>

800050a8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800050a8:	eb cd 40 80 	pushm	r7,lr
800050ac:	18 97       	mov	r7,r12
	if( pv )
800050ae:	58 0c       	cp.w	r12,0
800050b0:	c0 80       	breq	800050c0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800050b2:	f0 1f 00 05 	mcall	800050c4 <vPortFree+0x1c>
		{
			free( pv );
800050b6:	0e 9c       	mov	r12,r7
800050b8:	f0 1f 00 04 	mcall	800050c8 <vPortFree+0x20>
		}
		xTaskResumeAll();
800050bc:	f0 1f 00 04 	mcall	800050cc <vPortFree+0x24>
800050c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	55 98       	stdsp	sp[0x164],r8
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	64 bc       	ld.w	r12,r2[0x2c]
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	59 54       	cp.w	r4,21

800050d0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800050d0:	eb cd 40 80 	pushm	r7,lr
800050d4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800050d6:	f0 1f 00 06 	mcall	800050ec <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800050da:	0e 9c       	mov	r12,r7
800050dc:	f0 1f 00 05 	mcall	800050f0 <pvPortMalloc+0x20>
800050e0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800050e2:	f0 1f 00 05 	mcall	800050f4 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800050e6:	0e 9c       	mov	r12,r7
800050e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	55 98       	stdsp	sp[0x164],r8
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	64 cc       	ld.w	r12,r2[0x30]
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	59 54       	cp.w	r4,21

800050f8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800050f8:	d4 01       	pushm	lr
800050fa:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800050fc:	78 09       	ld.w	r9,r12[0x0]
800050fe:	58 09       	cp.w	r9,0
80005100:	c1 10       	breq	80005122 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005102:	78 3a       	ld.w	r10,r12[0xc]
80005104:	79 09       	ld.w	r9,r12[0x40]
80005106:	f4 09 00 09 	add	r9,r10,r9
8000510a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000510c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000510e:	14 39       	cp.w	r9,r10
80005110:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005114:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005118:	79 0a       	ld.w	r10,r12[0x40]
8000511a:	78 3b       	ld.w	r11,r12[0xc]
8000511c:	10 9c       	mov	r12,r8
8000511e:	f0 1f 00 02 	mcall	80005124 <prvCopyDataFromQueue+0x2c>
80005122:	d8 02       	popm	pc
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	69 14       	ld.w	r4,r4[0x44]

80005128 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005128:	eb cd 40 c0 	pushm	r6-r7,lr
8000512c:	18 97       	mov	r7,r12
8000512e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005130:	78 e8       	ld.w	r8,r12[0x38]
80005132:	58 08       	cp.w	r8,0
80005134:	c0 31       	brne	8000513a <xQueueReceiveFromISR+0x12>
80005136:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000513a:	f0 1f 00 0e 	mcall	80005170 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000513e:	6e e8       	ld.w	r8,r7[0x38]
80005140:	20 18       	sub	r8,1
80005142:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005144:	6f 18       	ld.w	r8,r7[0x44]
80005146:	5b f8       	cp.w	r8,-1
80005148:	c0 d1       	brne	80005162 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000514a:	6e 48       	ld.w	r8,r7[0x10]
8000514c:	58 08       	cp.w	r8,0
8000514e:	c0 f0       	breq	8000516c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005150:	ee cc ff f0 	sub	r12,r7,-16
80005154:	f0 1f 00 08 	mcall	80005174 <xQueueReceiveFromISR+0x4c>
80005158:	c0 a0       	breq	8000516c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000515a:	30 1c       	mov	r12,1
8000515c:	8d 0c       	st.w	r6[0x0],r12
8000515e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005162:	2f f8       	sub	r8,-1
80005164:	ef 48 00 44 	st.w	r7[68],r8
80005168:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000516c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	50 f8       	stdsp	sp[0x3c],r8
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	57 30       	stdsp	sp[0x1cc],r0

80005178 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005178:	eb cd 40 c0 	pushm	r6-r7,lr
8000517c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000517e:	f0 1f 00 23 	mcall	80005208 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005182:	6f 28       	ld.w	r8,r7[0x48]
80005184:	58 08       	cp.w	r8,0
80005186:	e0 8a 00 18 	brle	800051b6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000518a:	6e 98       	ld.w	r8,r7[0x24]
8000518c:	58 08       	cp.w	r8,0
8000518e:	c1 40       	breq	800051b6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005190:	ee c6 ff dc 	sub	r6,r7,-36
80005194:	c0 48       	rjmp	8000519c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005196:	6e 98       	ld.w	r8,r7[0x24]
80005198:	58 08       	cp.w	r8,0
8000519a:	c0 e0       	breq	800051b6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000519c:	0c 9c       	mov	r12,r6
8000519e:	f0 1f 00 1c 	mcall	8000520c <prvUnlockQueue+0x94>
800051a2:	c0 30       	breq	800051a8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800051a4:	f0 1f 00 1b 	mcall	80005210 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800051a8:	6f 28       	ld.w	r8,r7[0x48]
800051aa:	20 18       	sub	r8,1
800051ac:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800051b0:	58 08       	cp.w	r8,0
800051b2:	fe 99 ff f2 	brgt	80005196 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800051b6:	3f f8       	mov	r8,-1
800051b8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800051bc:	f0 1f 00 16 	mcall	80005214 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800051c0:	f0 1f 00 12 	mcall	80005208 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800051c4:	6f 18       	ld.w	r8,r7[0x44]
800051c6:	58 08       	cp.w	r8,0
800051c8:	e0 8a 00 18 	brle	800051f8 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800051cc:	6e 48       	ld.w	r8,r7[0x10]
800051ce:	58 08       	cp.w	r8,0
800051d0:	c1 40       	breq	800051f8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800051d2:	ee c6 ff f0 	sub	r6,r7,-16
800051d6:	c0 48       	rjmp	800051de <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800051d8:	6e 48       	ld.w	r8,r7[0x10]
800051da:	58 08       	cp.w	r8,0
800051dc:	c0 e0       	breq	800051f8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800051de:	0c 9c       	mov	r12,r6
800051e0:	f0 1f 00 0b 	mcall	8000520c <prvUnlockQueue+0x94>
800051e4:	c0 30       	breq	800051ea <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800051e6:	f0 1f 00 0b 	mcall	80005210 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800051ea:	6f 18       	ld.w	r8,r7[0x44]
800051ec:	20 18       	sub	r8,1
800051ee:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800051f2:	58 08       	cp.w	r8,0
800051f4:	fe 99 ff f2 	brgt	800051d8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800051f8:	3f f8       	mov	r8,-1
800051fa:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800051fe:	f0 1f 00 06 	mcall	80005214 <prvUnlockQueue+0x9c>
}
80005202:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005206:	00 00       	add	r0,r0
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	4e 64       	lddpc	r4,800053a0 <prvCopyDataToQueue+0x44>
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	57 30       	stdsp	sp[0x1cc],r0
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	56 3c       	stdsp	sp[0x18c],r12
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	4f 70       	lddpc	r0,800053f0 <xQueueGenericSendFromISR+0x1c>

80005218 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005218:	d4 31       	pushm	r0-r7,lr
8000521a:	20 5d       	sub	sp,20
8000521c:	18 97       	mov	r7,r12
8000521e:	50 0b       	stdsp	sp[0x0],r11
80005220:	50 2a       	stdsp	sp[0x8],r10
80005222:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005224:	f8 c2 ff dc 	sub	r2,r12,-36
80005228:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000522a:	fa c4 ff f4 	sub	r4,sp,-12
8000522e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005230:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005232:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005236:	f0 1f 00 3e 	mcall	8000532c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000523a:	6e e8       	ld.w	r8,r7[0x38]
8000523c:	58 08       	cp.w	r8,0
8000523e:	c2 a0       	breq	80005292 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005240:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005242:	40 0b       	lddsp	r11,sp[0x0]
80005244:	0e 9c       	mov	r12,r7
80005246:	f0 1f 00 3b 	mcall	80005330 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000524a:	40 18       	lddsp	r8,sp[0x4]
8000524c:	58 08       	cp.w	r8,0
8000524e:	c1 51       	brne	80005278 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005250:	6e e8       	ld.w	r8,r7[0x38]
80005252:	20 18       	sub	r8,1
80005254:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005256:	6e 08       	ld.w	r8,r7[0x0]
80005258:	58 08       	cp.w	r8,0
8000525a:	c0 41       	brne	80005262 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
8000525c:	f0 1f 00 36 	mcall	80005334 <xQueueGenericReceive+0x11c>
80005260:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005262:	6e 48       	ld.w	r8,r7[0x10]
80005264:	58 08       	cp.w	r8,0
80005266:	c1 20       	breq	8000528a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005268:	ee cc ff f0 	sub	r12,r7,-16
8000526c:	f0 1f 00 33 	mcall	80005338 <xQueueGenericReceive+0x120>
80005270:	58 1c       	cp.w	r12,1
80005272:	c0 c1       	brne	8000528a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005274:	d7 33       	scall
80005276:	c0 a8       	rjmp	8000528a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005278:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000527a:	6e 98       	ld.w	r8,r7[0x24]
8000527c:	58 08       	cp.w	r8,0
8000527e:	c0 60       	breq	8000528a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005280:	04 9c       	mov	r12,r2
80005282:	f0 1f 00 2e 	mcall	80005338 <xQueueGenericReceive+0x120>
80005286:	c0 20       	breq	8000528a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005288:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000528a:	f0 1f 00 2d 	mcall	8000533c <xQueueGenericReceive+0x124>
8000528e:	30 1c       	mov	r12,1
				return pdPASS;
80005290:	c4 c8       	rjmp	80005328 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005292:	40 28       	lddsp	r8,sp[0x8]
80005294:	58 08       	cp.w	r8,0
80005296:	c0 51       	brne	800052a0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005298:	f0 1f 00 29 	mcall	8000533c <xQueueGenericReceive+0x124>
8000529c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000529e:	c4 58       	rjmp	80005328 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800052a0:	58 05       	cp.w	r5,0
800052a2:	c0 51       	brne	800052ac <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800052a4:	08 9c       	mov	r12,r4
800052a6:	f0 1f 00 27 	mcall	80005340 <xQueueGenericReceive+0x128>
800052aa:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800052ac:	f0 1f 00 24 	mcall	8000533c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800052b0:	f0 1f 00 25 	mcall	80005344 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800052b4:	f0 1f 00 1e 	mcall	8000532c <xQueueGenericReceive+0x114>
800052b8:	6f 18       	ld.w	r8,r7[0x44]
800052ba:	5b f8       	cp.w	r8,-1
800052bc:	ef f1 0a 11 	st.weq	r7[0x44],r1
800052c0:	6f 28       	ld.w	r8,r7[0x48]
800052c2:	5b f8       	cp.w	r8,-1
800052c4:	ef f1 0a 12 	st.weq	r7[0x48],r1
800052c8:	f0 1f 00 1d 	mcall	8000533c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800052cc:	06 9b       	mov	r11,r3
800052ce:	08 9c       	mov	r12,r4
800052d0:	f0 1f 00 1e 	mcall	80005348 <xQueueGenericReceive+0x130>
800052d4:	c2 41       	brne	8000531c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800052d6:	f0 1f 00 16 	mcall	8000532c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800052da:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800052dc:	f0 1f 00 18 	mcall	8000533c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800052e0:	58 06       	cp.w	r6,0
800052e2:	c1 71       	brne	80005310 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800052e4:	6e 08       	ld.w	r8,r7[0x0]
800052e6:	58 08       	cp.w	r8,0
800052e8:	c0 81       	brne	800052f8 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800052ea:	f0 1f 00 11 	mcall	8000532c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800052ee:	6e 1c       	ld.w	r12,r7[0x4]
800052f0:	f0 1f 00 17 	mcall	8000534c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800052f4:	f0 1f 00 12 	mcall	8000533c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800052f8:	40 2b       	lddsp	r11,sp[0x8]
800052fa:	04 9c       	mov	r12,r2
800052fc:	f0 1f 00 15 	mcall	80005350 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005300:	0e 9c       	mov	r12,r7
80005302:	f0 1f 00 15 	mcall	80005354 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005306:	f0 1f 00 15 	mcall	80005358 <xQueueGenericReceive+0x140>
8000530a:	c9 61       	brne	80005236 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000530c:	d7 33       	scall
8000530e:	c9 4b       	rjmp	80005236 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005310:	0e 9c       	mov	r12,r7
80005312:	f0 1f 00 11 	mcall	80005354 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005316:	f0 1f 00 11 	mcall	80005358 <xQueueGenericReceive+0x140>
8000531a:	c8 eb       	rjmp	80005236 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
8000531c:	0e 9c       	mov	r12,r7
8000531e:	f0 1f 00 0e 	mcall	80005354 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005322:	f0 1f 00 0e 	mcall	80005358 <xQueueGenericReceive+0x140>
80005326:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005328:	2f bd       	sub	sp,-20
8000532a:	d8 32       	popm	r0-r7,pc
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	4e 64       	lddpc	r4,800054c4 <xQueueGenericSend+0xa0>
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	50 f8       	stdsp	sp[0x3c],r8
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	56 48       	stdsp	sp[0x190],r8
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	57 30       	stdsp	sp[0x1cc],r0
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	4f 70       	lddpc	r0,80005518 <xQueueGenericSend+0xf4>
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	56 24       	stdsp	sp[0x188],r4
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	55 98       	stdsp	sp[0x164],r8
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	58 c0       	cp.w	r0,12
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	56 ac       	stdsp	sp[0x1a8],r12
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	5b 18       	cp.w	r8,-15
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	51 78       	stdsp	sp[0x5c],r8
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	59 54       	cp.w	r4,21

8000535c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
8000535c:	eb cd 40 80 	pushm	r7,lr
80005360:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005362:	79 08       	ld.w	r8,r12[0x40]
80005364:	58 08       	cp.w	r8,0
80005366:	c0 a1       	brne	8000537a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005368:	78 08       	ld.w	r8,r12[0x0]
8000536a:	58 08       	cp.w	r8,0
8000536c:	c2 b1       	brne	800053c2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000536e:	78 1c       	ld.w	r12,r12[0x4]
80005370:	f0 1f 00 17 	mcall	800053cc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005374:	30 08       	mov	r8,0
80005376:	8f 18       	st.w	r7[0x4],r8
80005378:	c2 58       	rjmp	800053c2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000537a:	58 0a       	cp.w	r10,0
8000537c:	c1 01       	brne	8000539c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000537e:	10 9a       	mov	r10,r8
80005380:	78 2c       	ld.w	r12,r12[0x8]
80005382:	f0 1f 00 14 	mcall	800053d0 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005386:	6e 29       	ld.w	r9,r7[0x8]
80005388:	6f 08       	ld.w	r8,r7[0x40]
8000538a:	f2 08 00 08 	add	r8,r9,r8
8000538e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005390:	6e 19       	ld.w	r9,r7[0x4]
80005392:	12 38       	cp.w	r8,r9
80005394:	c1 73       	brcs	800053c2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005396:	6e 08       	ld.w	r8,r7[0x0]
80005398:	8f 28       	st.w	r7[0x8],r8
8000539a:	c1 48       	rjmp	800053c2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000539c:	10 9a       	mov	r10,r8
8000539e:	78 3c       	ld.w	r12,r12[0xc]
800053a0:	f0 1f 00 0c 	mcall	800053d0 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800053a4:	6f 08       	ld.w	r8,r7[0x40]
800053a6:	6e 39       	ld.w	r9,r7[0xc]
800053a8:	f2 08 01 08 	sub	r8,r9,r8
800053ac:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800053ae:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800053b0:	12 38       	cp.w	r8,r9
800053b2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800053b6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800053ba:	f3 d8 e3 19 	subcs	r9,r9,r8
800053be:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800053c2:	6e e8       	ld.w	r8,r7[0x38]
800053c4:	2f f8       	sub	r8,-1
800053c6:	8f e8       	st.w	r7[0x38],r8
}
800053c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	56 54       	stdsp	sp[0x194],r4
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	69 14       	ld.w	r4,r4[0x44]

800053d4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800053d4:	eb cd 40 c0 	pushm	r6-r7,lr
800053d8:	18 97       	mov	r7,r12
800053da:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800053dc:	78 ec       	ld.w	r12,r12[0x38]
800053de:	6e f8       	ld.w	r8,r7[0x3c]
800053e0:	10 3c       	cp.w	r12,r8
800053e2:	c0 33       	brcs	800053e8 <xQueueGenericSendFromISR+0x14>
800053e4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800053e8:	12 9a       	mov	r10,r9
800053ea:	0e 9c       	mov	r12,r7
800053ec:	f0 1f 00 0c 	mcall	8000541c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800053f0:	6f 28       	ld.w	r8,r7[0x48]
800053f2:	5b f8       	cp.w	r8,-1
800053f4:	c0 d1       	brne	8000540e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053f6:	6e 98       	ld.w	r8,r7[0x24]
800053f8:	58 08       	cp.w	r8,0
800053fa:	c0 f0       	breq	80005418 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053fc:	ee cc ff dc 	sub	r12,r7,-36
80005400:	f0 1f 00 08 	mcall	80005420 <xQueueGenericSendFromISR+0x4c>
80005404:	c0 a0       	breq	80005418 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005406:	30 1c       	mov	r12,1
80005408:	8d 0c       	st.w	r6[0x0],r12
8000540a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000540e:	2f f8       	sub	r8,-1
80005410:	ef 48 00 48 	st.w	r7[72],r8
80005414:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005418:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000541c:	80 00       	ld.sh	r0,r0[0x0]
8000541e:	53 5c       	stdsp	sp[0xd4],r12
80005420:	80 00       	ld.sh	r0,r0[0x0]
80005422:	57 30       	stdsp	sp[0x1cc],r0

80005424 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005424:	d4 31       	pushm	r0-r7,lr
80005426:	20 5d       	sub	sp,20
80005428:	18 97       	mov	r7,r12
8000542a:	50 0b       	stdsp	sp[0x0],r11
8000542c:	50 2a       	stdsp	sp[0x8],r10
8000542e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005430:	f8 c0 ff f0 	sub	r0,r12,-16
80005434:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005436:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000543a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000543c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005440:	f0 1f 00 2f 	mcall	800054fc <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005444:	6e e9       	ld.w	r9,r7[0x38]
80005446:	6e f8       	ld.w	r8,r7[0x3c]
80005448:	10 39       	cp.w	r9,r8
8000544a:	c1 42       	brcc	80005472 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000544c:	40 1a       	lddsp	r10,sp[0x4]
8000544e:	40 0b       	lddsp	r11,sp[0x0]
80005450:	0e 9c       	mov	r12,r7
80005452:	f0 1f 00 2c 	mcall	80005500 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005456:	6e 98       	ld.w	r8,r7[0x24]
80005458:	58 08       	cp.w	r8,0
8000545a:	c0 80       	breq	8000546a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
8000545c:	ee cc ff dc 	sub	r12,r7,-36
80005460:	f0 1f 00 29 	mcall	80005504 <xQueueGenericSend+0xe0>
80005464:	58 1c       	cp.w	r12,1
80005466:	c0 21       	brne	8000546a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005468:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000546a:	f0 1f 00 28 	mcall	80005508 <xQueueGenericSend+0xe4>
8000546e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005470:	c4 38       	rjmp	800054f6 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005472:	40 28       	lddsp	r8,sp[0x8]
80005474:	58 08       	cp.w	r8,0
80005476:	c0 51       	brne	80005480 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005478:	f0 1f 00 24 	mcall	80005508 <xQueueGenericSend+0xe4>
8000547c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000547e:	c3 c8       	rjmp	800054f6 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005480:	58 04       	cp.w	r4,0
80005482:	c0 51       	brne	8000548c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005484:	06 9c       	mov	r12,r3
80005486:	f0 1f 00 22 	mcall	8000550c <xQueueGenericSend+0xe8>
8000548a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000548c:	f0 1f 00 1f 	mcall	80005508 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005490:	f0 1f 00 20 	mcall	80005510 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005494:	f0 1f 00 1a 	mcall	800054fc <xQueueGenericSend+0xd8>
80005498:	6f 18       	ld.w	r8,r7[0x44]
8000549a:	5b f8       	cp.w	r8,-1
8000549c:	ef f1 0a 11 	st.weq	r7[0x44],r1
800054a0:	6f 28       	ld.w	r8,r7[0x48]
800054a2:	5b f8       	cp.w	r8,-1
800054a4:	ef f1 0a 12 	st.weq	r7[0x48],r1
800054a8:	f0 1f 00 18 	mcall	80005508 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054ac:	04 9b       	mov	r11,r2
800054ae:	06 9c       	mov	r12,r3
800054b0:	f0 1f 00 19 	mcall	80005514 <xQueueGenericSend+0xf0>
800054b4:	c1 b1       	brne	800054ea <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800054b6:	f0 1f 00 12 	mcall	800054fc <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800054ba:	6e e5       	ld.w	r5,r7[0x38]
800054bc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800054be:	f0 1f 00 13 	mcall	80005508 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800054c2:	0c 35       	cp.w	r5,r6
800054c4:	c0 d1       	brne	800054de <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800054c6:	40 2b       	lddsp	r11,sp[0x8]
800054c8:	00 9c       	mov	r12,r0
800054ca:	f0 1f 00 14 	mcall	80005518 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800054ce:	0e 9c       	mov	r12,r7
800054d0:	f0 1f 00 13 	mcall	8000551c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800054d4:	f0 1f 00 13 	mcall	80005520 <xQueueGenericSend+0xfc>
800054d8:	cb 41       	brne	80005440 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800054da:	d7 33       	scall
800054dc:	cb 2b       	rjmp	80005440 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800054de:	0e 9c       	mov	r12,r7
800054e0:	f0 1f 00 0f 	mcall	8000551c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800054e4:	f0 1f 00 0f 	mcall	80005520 <xQueueGenericSend+0xfc>
800054e8:	ca cb       	rjmp	80005440 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800054ea:	0e 9c       	mov	r12,r7
800054ec:	f0 1f 00 0c 	mcall	8000551c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800054f0:	f0 1f 00 0c 	mcall	80005520 <xQueueGenericSend+0xfc>
800054f4:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800054f6:	2f bd       	sub	sp,-20
800054f8:	d8 32       	popm	r0-r7,pc
800054fa:	00 00       	add	r0,r0
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	4e 64       	lddpc	r4,80005694 <vTaskPriorityDisinherit+0x40>
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	53 5c       	stdsp	sp[0xd4],r12
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	57 30       	stdsp	sp[0x1cc],r0
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	4f 70       	lddpc	r0,800056e4 <vTaskPriorityInherit+0x38>
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	56 24       	stdsp	sp[0x188],r4
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	55 98       	stdsp	sp[0x164],r8
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	58 c0       	cp.w	r0,12
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	5b 18       	cp.w	r8,-15
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	51 78       	stdsp	sp[0x5c],r8
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	59 54       	cp.w	r4,21

80005524 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005524:	d4 21       	pushm	r4-r7,lr
80005526:	18 97       	mov	r7,r12
80005528:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000552a:	58 0c       	cp.w	r12,0
8000552c:	c2 f0       	breq	8000558a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000552e:	34 cc       	mov	r12,76
80005530:	f0 1f 00 17 	mcall	8000558c <xQueueCreate+0x68>
80005534:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005536:	c2 a0       	breq	8000558a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005538:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000553c:	e8 cc ff ff 	sub	r12,r4,-1
80005540:	f0 1f 00 13 	mcall	8000558c <xQueueCreate+0x68>
80005544:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005546:	c1 e0       	breq	80005582 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005548:	f8 04 00 04 	add	r4,r12,r4
8000554c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000554e:	30 08       	mov	r8,0
80005550:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005552:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005554:	ee c8 00 01 	sub	r8,r7,1
80005558:	ad 38       	mul	r8,r6
8000555a:	10 0c       	add	r12,r8
8000555c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000555e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005560:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005564:	3f f8       	mov	r8,-1
80005566:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000556a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000556e:	ea cc ff f0 	sub	r12,r5,-16
80005572:	f0 1f 00 08 	mcall	80005590 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005576:	ea cc ff dc 	sub	r12,r5,-36
8000557a:	f0 1f 00 06 	mcall	80005590 <xQueueCreate+0x6c>
8000557e:	0a 9c       	mov	r12,r5
80005580:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005582:	0a 9c       	mov	r12,r5
80005584:	f0 1f 00 04 	mcall	80005594 <xQueueCreate+0x70>
80005588:	d8 2a       	popm	r4-r7,pc,r12=0
8000558a:	d8 2a       	popm	r4-r7,pc,r12=0
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	50 d0       	stdsp	sp[0x34],r0
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	4d 40       	lddpc	r0,800056e0 <vTaskPriorityInherit+0x34>
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	50 a8       	stdsp	sp[0x28],r8

80005598 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005598:	48 38       	lddpc	r8,800055a4 <vTaskSuspendAll+0xc>
8000559a:	70 09       	ld.w	r9,r8[0x0]
8000559c:	2f f9       	sub	r9,-1
8000559e:	91 09       	st.w	r8[0x0],r9
}
800055a0:	5e fc       	retal	r12
800055a2:	00 00       	add	r0,r0
800055a4:	00 00       	add	r0,r0
800055a6:	0d 08       	ld.w	r8,r6++

800055a8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800055a8:	49 a8       	lddpc	r8,80005610 <vTaskSwitchContext+0x68>
800055aa:	70 08       	ld.w	r8,r8[0x0]
800055ac:	58 08       	cp.w	r8,0
800055ae:	c0 b1       	brne	800055c4 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055b0:	49 98       	lddpc	r8,80005614 <vTaskSwitchContext+0x6c>
800055b2:	70 08       	ld.w	r8,r8[0x0]
800055b4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800055b8:	49 89       	lddpc	r9,80005618 <vTaskSwitchContext+0x70>
800055ba:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800055be:	58 08       	cp.w	r8,0
800055c0:	c0 60       	breq	800055cc <vTaskSwitchContext+0x24>
800055c2:	c1 18       	rjmp	800055e4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800055c4:	30 19       	mov	r9,1
800055c6:	49 68       	lddpc	r8,8000561c <vTaskSwitchContext+0x74>
800055c8:	91 09       	st.w	r8[0x0],r9
800055ca:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800055cc:	49 28       	lddpc	r8,80005614 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055ce:	49 3a       	lddpc	r10,80005618 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800055d0:	70 09       	ld.w	r9,r8[0x0]
800055d2:	20 19       	sub	r9,1
800055d4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055d6:	70 09       	ld.w	r9,r8[0x0]
800055d8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800055dc:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800055e0:	58 09       	cp.w	r9,0
800055e2:	cf 70       	breq	800055d0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800055e4:	48 c8       	lddpc	r8,80005614 <vTaskSwitchContext+0x6c>
800055e6:	70 08       	ld.w	r8,r8[0x0]
800055e8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800055ec:	48 b9       	lddpc	r9,80005618 <vTaskSwitchContext+0x70>
800055ee:	f2 08 00 28 	add	r8,r9,r8<<0x2
800055f2:	70 19       	ld.w	r9,r8[0x4]
800055f4:	72 19       	ld.w	r9,r9[0x4]
800055f6:	91 19       	st.w	r8[0x4],r9
800055f8:	f0 ca ff f8 	sub	r10,r8,-8
800055fc:	14 39       	cp.w	r9,r10
800055fe:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005602:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005606:	70 18       	ld.w	r8,r8[0x4]
80005608:	70 39       	ld.w	r9,r8[0xc]
8000560a:	48 68       	lddpc	r8,80005620 <vTaskSwitchContext+0x78>
8000560c:	91 09       	st.w	r8[0x0],r9
8000560e:	5e fc       	retal	r12
80005610:	00 00       	add	r0,r0
80005612:	0d 08       	ld.w	r8,r6++
80005614:	00 00       	add	r0,r0
80005616:	0d 40       	ld.w	r0,--r6
80005618:	00 00       	add	r0,r0
8000561a:	0c 24       	rsub	r4,r6
8000561c:	00 00       	add	r0,r0
8000561e:	0d 28       	ld.uh	r8,r6++
80005620:	00 00       	add	r0,r0
80005622:	0c d8       	st.w	--r6,r8

80005624 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005624:	48 48       	lddpc	r8,80005634 <vTaskSetTimeOutState+0x10>
80005626:	70 08       	ld.w	r8,r8[0x0]
80005628:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000562a:	48 48       	lddpc	r8,80005638 <vTaskSetTimeOutState+0x14>
8000562c:	70 08       	ld.w	r8,r8[0x0]
8000562e:	99 18       	st.w	r12[0x4],r8
}
80005630:	5e fc       	retal	r12
80005632:	00 00       	add	r0,r0
80005634:	00 00       	add	r0,r0
80005636:	0c 1c       	sub	r12,r6
80005638:	00 00       	add	r0,r0
8000563a:	0d 04       	ld.w	r4,r6++

8000563c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000563c:	30 19       	mov	r9,1
8000563e:	48 28       	lddpc	r8,80005644 <vTaskMissedYield+0x8>
80005640:	91 09       	st.w	r8[0x0],r9
}
80005642:	5e fc       	retal	r12
80005644:	00 00       	add	r0,r0
80005646:	0d 28       	ld.uh	r8,r6++

80005648 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005648:	48 28       	lddpc	r8,80005650 <xTaskGetCurrentTaskHandle+0x8>
8000564a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000564c:	5e fc       	retal	r12
8000564e:	00 00       	add	r0,r0
80005650:	00 00       	add	r0,r0
80005652:	0c d8       	st.w	--r6,r8

80005654 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005654:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005658:	58 0c       	cp.w	r12,0
8000565a:	c1 f0       	breq	80005698 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000565c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000565e:	78 b9       	ld.w	r9,r12[0x2c]
80005660:	79 18       	ld.w	r8,r12[0x44]
80005662:	10 39       	cp.w	r9,r8
80005664:	c1 a0       	breq	80005698 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005666:	f8 c6 ff fc 	sub	r6,r12,-4
8000566a:	0c 9c       	mov	r12,r6
8000566c:	f0 1f 00 0c 	mcall	8000569c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005670:	6f 1c       	ld.w	r12,r7[0x44]
80005672:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005674:	f8 08 11 08 	rsub	r8,r12,8
80005678:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000567a:	48 a8       	lddpc	r8,800056a0 <vTaskPriorityDisinherit+0x4c>
8000567c:	70 08       	ld.w	r8,r8[0x0]
8000567e:	10 3c       	cp.w	r12,r8
80005680:	e0 88 00 04 	brls	80005688 <vTaskPriorityDisinherit+0x34>
80005684:	48 78       	lddpc	r8,800056a0 <vTaskPriorityDisinherit+0x4c>
80005686:	91 0c       	st.w	r8[0x0],r12
80005688:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000568c:	0c 9b       	mov	r11,r6
8000568e:	48 68       	lddpc	r8,800056a4 <vTaskPriorityDisinherit+0x50>
80005690:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005694:	f0 1f 00 05 	mcall	800056a8 <vTaskPriorityDisinherit+0x54>
80005698:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	4d aa       	lddpc	r10,80005804 <vTaskIncrementTick+0x58>
800056a0:	00 00       	add	r0,r0
800056a2:	0d 40       	ld.w	r0,--r6
800056a4:	00 00       	add	r0,r0
800056a6:	0c 24       	rsub	r4,r6
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	4d 5a       	lddpc	r10,800057fc <vTaskIncrementTick+0x50>

800056ac <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800056ac:	eb cd 40 c0 	pushm	r6-r7,lr
800056b0:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800056b2:	49 b8       	lddpc	r8,8000571c <vTaskPriorityInherit+0x70>
800056b4:	70 08       	ld.w	r8,r8[0x0]
800056b6:	78 b9       	ld.w	r9,r12[0x2c]
800056b8:	70 b8       	ld.w	r8,r8[0x2c]
800056ba:	10 39       	cp.w	r9,r8
800056bc:	c2 d2       	brcc	80005716 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800056be:	49 88       	lddpc	r8,8000571c <vTaskPriorityInherit+0x70>
800056c0:	70 08       	ld.w	r8,r8[0x0]
800056c2:	70 b8       	ld.w	r8,r8[0x2c]
800056c4:	f0 08 11 08 	rsub	r8,r8,8
800056c8:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800056ca:	f2 09 00 28 	add	r8,r9,r9<<0x2
800056ce:	49 59       	lddpc	r9,80005720 <vTaskPriorityInherit+0x74>
800056d0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800056d4:	78 59       	ld.w	r9,r12[0x14]
800056d6:	10 39       	cp.w	r9,r8
800056d8:	c1 b1       	brne	8000570e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800056da:	f8 c6 ff fc 	sub	r6,r12,-4
800056de:	0c 9c       	mov	r12,r6
800056e0:	f0 1f 00 11 	mcall	80005724 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800056e4:	48 e8       	lddpc	r8,8000571c <vTaskPriorityInherit+0x70>
800056e6:	70 08       	ld.w	r8,r8[0x0]
800056e8:	70 bc       	ld.w	r12,r8[0x2c]
800056ea:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800056ec:	48 f8       	lddpc	r8,80005728 <vTaskPriorityInherit+0x7c>
800056ee:	70 08       	ld.w	r8,r8[0x0]
800056f0:	10 3c       	cp.w	r12,r8
800056f2:	e0 88 00 04 	brls	800056fa <vTaskPriorityInherit+0x4e>
800056f6:	48 d8       	lddpc	r8,80005728 <vTaskPriorityInherit+0x7c>
800056f8:	91 0c       	st.w	r8[0x0],r12
800056fa:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800056fe:	0c 9b       	mov	r11,r6
80005700:	48 88       	lddpc	r8,80005720 <vTaskPriorityInherit+0x74>
80005702:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005706:	f0 1f 00 0a 	mcall	8000572c <vTaskPriorityInherit+0x80>
8000570a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000570e:	48 48       	lddpc	r8,8000571c <vTaskPriorityInherit+0x70>
80005710:	70 08       	ld.w	r8,r8[0x0]
80005712:	70 b8       	ld.w	r8,r8[0x2c]
80005714:	99 b8       	st.w	r12[0x2c],r8
80005716:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000571a:	00 00       	add	r0,r0
8000571c:	00 00       	add	r0,r0
8000571e:	0c d8       	st.w	--r6,r8
80005720:	00 00       	add	r0,r0
80005722:	0c 24       	rsub	r4,r6
80005724:	80 00       	ld.sh	r0,r0[0x0]
80005726:	4d aa       	lddpc	r10,8000588c <vTaskIncrementTick+0xe0>
80005728:	00 00       	add	r0,r0
8000572a:	0d 40       	ld.w	r0,--r6
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	4d 5a       	lddpc	r10,80005880 <vTaskIncrementTick+0xd4>

80005730 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005730:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005734:	78 38       	ld.w	r8,r12[0xc]
80005736:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005738:	ee c6 ff e8 	sub	r6,r7,-24
8000573c:	0c 9c       	mov	r12,r6
8000573e:	f0 1f 00 15 	mcall	80005790 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005742:	49 58       	lddpc	r8,80005794 <xTaskRemoveFromEventList+0x64>
80005744:	70 08       	ld.w	r8,r8[0x0]
80005746:	58 08       	cp.w	r8,0
80005748:	c1 71       	brne	80005776 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000574a:	ee c6 ff fc 	sub	r6,r7,-4
8000574e:	0c 9c       	mov	r12,r6
80005750:	f0 1f 00 10 	mcall	80005790 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005754:	6e bc       	ld.w	r12,r7[0x2c]
80005756:	49 18       	lddpc	r8,80005798 <xTaskRemoveFromEventList+0x68>
80005758:	70 08       	ld.w	r8,r8[0x0]
8000575a:	10 3c       	cp.w	r12,r8
8000575c:	e0 88 00 04 	brls	80005764 <xTaskRemoveFromEventList+0x34>
80005760:	48 e8       	lddpc	r8,80005798 <xTaskRemoveFromEventList+0x68>
80005762:	91 0c       	st.w	r8[0x0],r12
80005764:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005768:	0c 9b       	mov	r11,r6
8000576a:	48 d8       	lddpc	r8,8000579c <xTaskRemoveFromEventList+0x6c>
8000576c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005770:	f0 1f 00 0c 	mcall	800057a0 <xTaskRemoveFromEventList+0x70>
80005774:	c0 58       	rjmp	8000577e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005776:	0c 9b       	mov	r11,r6
80005778:	48 bc       	lddpc	r12,800057a4 <xTaskRemoveFromEventList+0x74>
8000577a:	f0 1f 00 0a 	mcall	800057a0 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000577e:	48 b8       	lddpc	r8,800057a8 <xTaskRemoveFromEventList+0x78>
80005780:	70 08       	ld.w	r8,r8[0x0]
80005782:	6e b9       	ld.w	r9,r7[0x2c]
80005784:	70 b8       	ld.w	r8,r8[0x2c]
80005786:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005788:	5f 2c       	srhs	r12
8000578a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000578e:	00 00       	add	r0,r0
80005790:	80 00       	ld.sh	r0,r0[0x0]
80005792:	4d aa       	lddpc	r10,800058f8 <xTaskCheckForTimeOut+0x38>
80005794:	00 00       	add	r0,r0
80005796:	0d 08       	ld.w	r8,r6++
80005798:	00 00       	add	r0,r0
8000579a:	0d 40       	ld.w	r0,--r6
8000579c:	00 00       	add	r0,r0
8000579e:	0c 24       	rsub	r4,r6
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	4d 5a       	lddpc	r10,800058f4 <xTaskCheckForTimeOut+0x34>
800057a4:	00 00       	add	r0,r0
800057a6:	0c dc       	st.w	--r6,r12
800057a8:	00 00       	add	r0,r0
800057aa:	0c d8       	st.w	--r6,r8

800057ac <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800057ac:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800057b0:	4b 98       	lddpc	r8,80005894 <vTaskIncrementTick+0xe8>
800057b2:	70 08       	ld.w	r8,r8[0x0]
800057b4:	58 08       	cp.w	r8,0
800057b6:	c6 91       	brne	80005888 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800057b8:	4b 88       	lddpc	r8,80005898 <vTaskIncrementTick+0xec>
800057ba:	70 09       	ld.w	r9,r8[0x0]
800057bc:	2f f9       	sub	r9,-1
800057be:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800057c0:	70 08       	ld.w	r8,r8[0x0]
800057c2:	58 08       	cp.w	r8,0
800057c4:	c1 a1       	brne	800057f8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800057c6:	4b 68       	lddpc	r8,8000589c <vTaskIncrementTick+0xf0>
800057c8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800057ca:	4b 69       	lddpc	r9,800058a0 <vTaskIncrementTick+0xf4>
800057cc:	72 0b       	ld.w	r11,r9[0x0]
800057ce:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800057d0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800057d2:	4b 59       	lddpc	r9,800058a4 <vTaskIncrementTick+0xf8>
800057d4:	72 0a       	ld.w	r10,r9[0x0]
800057d6:	2f fa       	sub	r10,-1
800057d8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800057da:	70 08       	ld.w	r8,r8[0x0]
800057dc:	70 08       	ld.w	r8,r8[0x0]
800057de:	58 08       	cp.w	r8,0
800057e0:	c0 51       	brne	800057ea <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800057e2:	3f f9       	mov	r9,-1
800057e4:	4b 18       	lddpc	r8,800058a8 <vTaskIncrementTick+0xfc>
800057e6:	91 09       	st.w	r8[0x0],r9
800057e8:	c0 88       	rjmp	800057f8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800057ea:	4a d8       	lddpc	r8,8000589c <vTaskIncrementTick+0xf0>
800057ec:	70 08       	ld.w	r8,r8[0x0]
800057ee:	70 38       	ld.w	r8,r8[0xc]
800057f0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800057f2:	70 19       	ld.w	r9,r8[0x4]
800057f4:	4a d8       	lddpc	r8,800058a8 <vTaskIncrementTick+0xfc>
800057f6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800057f8:	4a 88       	lddpc	r8,80005898 <vTaskIncrementTick+0xec>
800057fa:	70 09       	ld.w	r9,r8[0x0]
800057fc:	4a b8       	lddpc	r8,800058a8 <vTaskIncrementTick+0xfc>
800057fe:	70 08       	ld.w	r8,r8[0x0]
80005800:	10 39       	cp.w	r9,r8
80005802:	c4 73       	brcs	80005890 <vTaskIncrementTick+0xe4>
80005804:	4a 68       	lddpc	r8,8000589c <vTaskIncrementTick+0xf0>
80005806:	70 08       	ld.w	r8,r8[0x0]
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	58 08       	cp.w	r8,0
8000580c:	c0 c0       	breq	80005824 <vTaskIncrementTick+0x78>
8000580e:	4a 48       	lddpc	r8,8000589c <vTaskIncrementTick+0xf0>
80005810:	70 08       	ld.w	r8,r8[0x0]
80005812:	70 38       	ld.w	r8,r8[0xc]
80005814:	70 37       	ld.w	r7,r8[0xc]
80005816:	6e 18       	ld.w	r8,r7[0x4]
80005818:	4a 09       	lddpc	r9,80005898 <vTaskIncrementTick+0xec>
8000581a:	72 09       	ld.w	r9,r9[0x0]
8000581c:	12 38       	cp.w	r8,r9
8000581e:	e0 88 00 14 	brls	80005846 <vTaskIncrementTick+0x9a>
80005822:	c0 e8       	rjmp	8000583e <vTaskIncrementTick+0x92>
80005824:	3f f9       	mov	r9,-1
80005826:	4a 18       	lddpc	r8,800058a8 <vTaskIncrementTick+0xfc>
80005828:	91 09       	st.w	r8[0x0],r9
8000582a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000582e:	6a 08       	ld.w	r8,r5[0x0]
80005830:	70 38       	ld.w	r8,r8[0xc]
80005832:	70 37       	ld.w	r7,r8[0xc]
80005834:	6e 18       	ld.w	r8,r7[0x4]
80005836:	64 09       	ld.w	r9,r2[0x0]
80005838:	12 38       	cp.w	r8,r9
8000583a:	e0 88 00 0a 	brls	8000584e <vTaskIncrementTick+0xa2>
8000583e:	49 b9       	lddpc	r9,800058a8 <vTaskIncrementTick+0xfc>
80005840:	93 08       	st.w	r9[0x0],r8
80005842:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005846:	49 a4       	lddpc	r4,800058ac <vTaskIncrementTick+0x100>
80005848:	49 a3       	lddpc	r3,800058b0 <vTaskIncrementTick+0x104>
8000584a:	49 55       	lddpc	r5,8000589c <vTaskIncrementTick+0xf0>
8000584c:	49 32       	lddpc	r2,80005898 <vTaskIncrementTick+0xec>
8000584e:	ee c6 ff fc 	sub	r6,r7,-4
80005852:	0c 9c       	mov	r12,r6
80005854:	f0 1f 00 18 	mcall	800058b4 <vTaskIncrementTick+0x108>
80005858:	6e a8       	ld.w	r8,r7[0x28]
8000585a:	58 08       	cp.w	r8,0
8000585c:	c0 50       	breq	80005866 <vTaskIncrementTick+0xba>
8000585e:	ee cc ff e8 	sub	r12,r7,-24
80005862:	f0 1f 00 15 	mcall	800058b4 <vTaskIncrementTick+0x108>
80005866:	6e bc       	ld.w	r12,r7[0x2c]
80005868:	68 08       	ld.w	r8,r4[0x0]
8000586a:	10 3c       	cp.w	r12,r8
8000586c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005870:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005874:	0c 9b       	mov	r11,r6
80005876:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000587a:	f0 1f 00 10 	mcall	800058b8 <vTaskIncrementTick+0x10c>
8000587e:	6a 08       	ld.w	r8,r5[0x0]
80005880:	70 08       	ld.w	r8,r8[0x0]
80005882:	58 08       	cp.w	r8,0
80005884:	cd 51       	brne	8000582e <vTaskIncrementTick+0x82>
80005886:	cc fb       	rjmp	80005824 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005888:	48 d8       	lddpc	r8,800058bc <vTaskIncrementTick+0x110>
8000588a:	70 09       	ld.w	r9,r8[0x0]
8000588c:	2f f9       	sub	r9,-1
8000588e:	91 09       	st.w	r8[0x0],r9
80005890:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005894:	00 00       	add	r0,r0
80005896:	0d 08       	ld.w	r8,r6++
80005898:	00 00       	add	r0,r0
8000589a:	0d 04       	ld.w	r4,r6++
8000589c:	00 00       	add	r0,r0
8000589e:	0c 10       	sub	r0,r6
800058a0:	00 00       	add	r0,r0
800058a2:	0c 20       	rsub	r0,r6
800058a4:	00 00       	add	r0,r0
800058a6:	0c 1c       	sub	r12,r6
800058a8:	00 00       	add	r0,r0
800058aa:	05 40       	ld.w	r0,--r2
800058ac:	00 00       	add	r0,r0
800058ae:	0d 40       	ld.w	r0,--r6
800058b0:	00 00       	add	r0,r0
800058b2:	0c 24       	rsub	r4,r6
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	4d aa       	lddpc	r10,80005a1c <xTaskResumeAll+0xc8>
800058b8:	80 00       	ld.sh	r0,r0[0x0]
800058ba:	4d 5a       	lddpc	r10,80005a0c <xTaskResumeAll+0xb8>
800058bc:	00 00       	add	r0,r0
800058be:	0c 08       	add	r8,r6

800058c0 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800058c0:	eb cd 40 c0 	pushm	r6-r7,lr
800058c4:	18 97       	mov	r7,r12
800058c6:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800058c8:	f0 1f 00 15 	mcall	8000591c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800058cc:	6c 08       	ld.w	r8,r6[0x0]
800058ce:	5b f8       	cp.w	r8,-1
800058d0:	c0 31       	brne	800058d6 <xTaskCheckForTimeOut+0x16>
800058d2:	30 07       	mov	r7,0
800058d4:	c1 f8       	rjmp	80005912 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800058d6:	49 39       	lddpc	r9,80005920 <xTaskCheckForTimeOut+0x60>
800058d8:	72 09       	ld.w	r9,r9[0x0]
800058da:	6e 0a       	ld.w	r10,r7[0x0]
800058dc:	12 3a       	cp.w	r10,r9
800058de:	c0 70       	breq	800058ec <xTaskCheckForTimeOut+0x2c>
800058e0:	49 19       	lddpc	r9,80005924 <xTaskCheckForTimeOut+0x64>
800058e2:	72 09       	ld.w	r9,r9[0x0]
800058e4:	6e 1a       	ld.w	r10,r7[0x4]
800058e6:	12 3a       	cp.w	r10,r9
800058e8:	e0 88 00 14 	brls	80005910 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800058ec:	48 e9       	lddpc	r9,80005924 <xTaskCheckForTimeOut+0x64>
800058ee:	72 0a       	ld.w	r10,r9[0x0]
800058f0:	6e 19       	ld.w	r9,r7[0x4]
800058f2:	12 1a       	sub	r10,r9
800058f4:	14 38       	cp.w	r8,r10
800058f6:	e0 88 00 0d 	brls	80005910 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800058fa:	48 ba       	lddpc	r10,80005924 <xTaskCheckForTimeOut+0x64>
800058fc:	74 0a       	ld.w	r10,r10[0x0]
800058fe:	14 19       	sub	r9,r10
80005900:	f2 08 00 08 	add	r8,r9,r8
80005904:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005906:	0e 9c       	mov	r12,r7
80005908:	f0 1f 00 08 	mcall	80005928 <xTaskCheckForTimeOut+0x68>
8000590c:	30 07       	mov	r7,0
8000590e:	c0 28       	rjmp	80005912 <xTaskCheckForTimeOut+0x52>
80005910:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005912:	f0 1f 00 07 	mcall	8000592c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005916:	0e 9c       	mov	r12,r7
80005918:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	4e 64       	lddpc	r4,80005ab4 <vTaskDelayUntil+0x1c>
80005920:	00 00       	add	r0,r0
80005922:	0c 1c       	sub	r12,r6
80005924:	00 00       	add	r0,r0
80005926:	0d 04       	ld.w	r4,r6++
80005928:	80 00       	ld.sh	r0,r0[0x0]
8000592a:	56 24       	stdsp	sp[0x188],r4
8000592c:	80 00       	ld.sh	r0,r0[0x0]
8000592e:	4f 70       	lddpc	r0,80005b08 <vTaskDelayUntil+0x70>

80005930 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005930:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005934:	f0 1f 00 05 	mcall	80005948 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005938:	48 58       	lddpc	r8,8000594c <xTaskGetTickCount+0x1c>
8000593a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000593c:	f0 1f 00 05 	mcall	80005950 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005940:	0e 9c       	mov	r12,r7
80005942:	e3 cd 80 80 	ldm	sp++,r7,pc
80005946:	00 00       	add	r0,r0
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	4e 64       	lddpc	r4,80005ae0 <vTaskDelayUntil+0x48>
8000594c:	00 00       	add	r0,r0
8000594e:	0d 04       	ld.w	r4,r6++
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	4f 70       	lddpc	r0,80005b2c <vTaskPlaceOnEventList+0x14>

80005954 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005954:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005958:	f0 1f 00 2c 	mcall	80005a08 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000595c:	4a c8       	lddpc	r8,80005a0c <xTaskResumeAll+0xb8>
8000595e:	70 09       	ld.w	r9,r8[0x0]
80005960:	20 19       	sub	r9,1
80005962:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005964:	70 08       	ld.w	r8,r8[0x0]
80005966:	58 08       	cp.w	r8,0
80005968:	c4 91       	brne	800059fa <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000596a:	4a a8       	lddpc	r8,80005a10 <xTaskResumeAll+0xbc>
8000596c:	70 08       	ld.w	r8,r8[0x0]
8000596e:	58 08       	cp.w	r8,0
80005970:	c4 50       	breq	800059fa <xTaskResumeAll+0xa6>
80005972:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005974:	4a 85       	lddpc	r5,80005a14 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005976:	4a 93       	lddpc	r3,80005a18 <xTaskResumeAll+0xc4>
80005978:	4a 92       	lddpc	r2,80005a1c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000597a:	4a a1       	lddpc	r1,80005a20 <xTaskResumeAll+0xcc>
8000597c:	c1 e8       	rjmp	800059b8 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000597e:	6a 38       	ld.w	r8,r5[0xc]
80005980:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005982:	ee cc ff e8 	sub	r12,r7,-24
80005986:	f0 1f 00 28 	mcall	80005a24 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000598a:	ee c6 ff fc 	sub	r6,r7,-4
8000598e:	0c 9c       	mov	r12,r6
80005990:	f0 1f 00 25 	mcall	80005a24 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005994:	6e bc       	ld.w	r12,r7[0x2c]
80005996:	66 08       	ld.w	r8,r3[0x0]
80005998:	10 3c       	cp.w	r12,r8
8000599a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000599e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059a2:	0c 9b       	mov	r11,r6
800059a4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800059a8:	f0 1f 00 20 	mcall	80005a28 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800059ac:	62 08       	ld.w	r8,r1[0x0]
800059ae:	6e b9       	ld.w	r9,r7[0x2c]
800059b0:	70 b8       	ld.w	r8,r8[0x2c]
800059b2:	10 39       	cp.w	r9,r8
800059b4:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800059b8:	6a 08       	ld.w	r8,r5[0x0]
800059ba:	58 08       	cp.w	r8,0
800059bc:	ce 11       	brne	8000597e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059be:	49 c8       	lddpc	r8,80005a2c <xTaskResumeAll+0xd8>
800059c0:	70 08       	ld.w	r8,r8[0x0]
800059c2:	58 08       	cp.w	r8,0
800059c4:	c0 f0       	breq	800059e2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059c6:	49 a8       	lddpc	r8,80005a2c <xTaskResumeAll+0xd8>
800059c8:	70 08       	ld.w	r8,r8[0x0]
800059ca:	58 08       	cp.w	r8,0
800059cc:	c1 10       	breq	800059ee <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800059ce:	49 87       	lddpc	r7,80005a2c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800059d0:	f0 1f 00 18 	mcall	80005a30 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800059d4:	6e 08       	ld.w	r8,r7[0x0]
800059d6:	20 18       	sub	r8,1
800059d8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059da:	6e 08       	ld.w	r8,r7[0x0]
800059dc:	58 08       	cp.w	r8,0
800059de:	cf 91       	brne	800059d0 <xTaskResumeAll+0x7c>
800059e0:	c0 78       	rjmp	800059ee <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800059e2:	58 14       	cp.w	r4,1
800059e4:	c0 50       	breq	800059ee <xTaskResumeAll+0x9a>
800059e6:	49 48       	lddpc	r8,80005a34 <xTaskResumeAll+0xe0>
800059e8:	70 08       	ld.w	r8,r8[0x0]
800059ea:	58 18       	cp.w	r8,1
800059ec:	c0 71       	brne	800059fa <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800059ee:	30 09       	mov	r9,0
800059f0:	49 18       	lddpc	r8,80005a34 <xTaskResumeAll+0xe0>
800059f2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800059f4:	d7 33       	scall
800059f6:	30 17       	mov	r7,1
800059f8:	c0 28       	rjmp	800059fc <xTaskResumeAll+0xa8>
800059fa:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800059fc:	f0 1f 00 0f 	mcall	80005a38 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005a00:	0e 9c       	mov	r12,r7
80005a02:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005a06:	00 00       	add	r0,r0
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	4e 64       	lddpc	r4,80005ba0 <prvIdleTask+0x30>
80005a0c:	00 00       	add	r0,r0
80005a0e:	0d 08       	ld.w	r8,r6++
80005a10:	00 00       	add	r0,r0
80005a12:	0d 24       	ld.uh	r4,r6++
80005a14:	00 00       	add	r0,r0
80005a16:	0c dc       	st.w	--r6,r12
80005a18:	00 00       	add	r0,r0
80005a1a:	0d 40       	ld.w	r0,--r6
80005a1c:	00 00       	add	r0,r0
80005a1e:	0c 24       	rsub	r4,r6
80005a20:	00 00       	add	r0,r0
80005a22:	0c d8       	st.w	--r6,r8
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	4d aa       	lddpc	r10,80005b8c <prvIdleTask+0x1c>
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	4d 5a       	lddpc	r10,80005b7c <prvIdleTask+0xc>
80005a2c:	00 00       	add	r0,r0
80005a2e:	0c 08       	add	r8,r6
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	57 ac       	stdsp	sp[0x1e8],r12
80005a34:	00 00       	add	r0,r0
80005a36:	0d 28       	ld.uh	r8,r6++
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	4f 70       	lddpc	r0,80005c14 <xTaskGenericCreate+0x1c>

80005a3c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005a3c:	eb cd 40 80 	pushm	r7,lr
80005a40:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005a42:	49 08       	lddpc	r8,80005a80 <prvAddCurrentTaskToDelayedList+0x44>
80005a44:	70 08       	ld.w	r8,r8[0x0]
80005a46:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005a48:	48 f8       	lddpc	r8,80005a84 <prvAddCurrentTaskToDelayedList+0x48>
80005a4a:	70 08       	ld.w	r8,r8[0x0]
80005a4c:	10 3c       	cp.w	r12,r8
80005a4e:	c0 a2       	brcc	80005a62 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a50:	48 c8       	lddpc	r8,80005a80 <prvAddCurrentTaskToDelayedList+0x44>
80005a52:	70 0b       	ld.w	r11,r8[0x0]
80005a54:	48 d8       	lddpc	r8,80005a88 <prvAddCurrentTaskToDelayedList+0x4c>
80005a56:	70 0c       	ld.w	r12,r8[0x0]
80005a58:	2f cb       	sub	r11,-4
80005a5a:	f0 1f 00 0d 	mcall	80005a8c <prvAddCurrentTaskToDelayedList+0x50>
80005a5e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a62:	48 88       	lddpc	r8,80005a80 <prvAddCurrentTaskToDelayedList+0x44>
80005a64:	70 0b       	ld.w	r11,r8[0x0]
80005a66:	48 b8       	lddpc	r8,80005a90 <prvAddCurrentTaskToDelayedList+0x54>
80005a68:	70 0c       	ld.w	r12,r8[0x0]
80005a6a:	2f cb       	sub	r11,-4
80005a6c:	f0 1f 00 08 	mcall	80005a8c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005a70:	48 98       	lddpc	r8,80005a94 <prvAddCurrentTaskToDelayedList+0x58>
80005a72:	70 08       	ld.w	r8,r8[0x0]
80005a74:	10 37       	cp.w	r7,r8
80005a76:	c0 32       	brcc	80005a7c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005a78:	48 78       	lddpc	r8,80005a94 <prvAddCurrentTaskToDelayedList+0x58>
80005a7a:	91 07       	st.w	r8[0x0],r7
80005a7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a80:	00 00       	add	r0,r0
80005a82:	0c d8       	st.w	--r6,r8
80005a84:	00 00       	add	r0,r0
80005a86:	0d 04       	ld.w	r4,r6++
80005a88:	00 00       	add	r0,r0
80005a8a:	0c 20       	rsub	r0,r6
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	4d 76       	lddpc	r6,80005be8 <prvIdleTask+0x78>
80005a90:	00 00       	add	r0,r0
80005a92:	0c 10       	sub	r0,r6
80005a94:	00 00       	add	r0,r0
80005a96:	05 40       	ld.w	r0,--r2

80005a98 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005a98:	eb cd 40 c0 	pushm	r6-r7,lr
80005a9c:	18 96       	mov	r6,r12
80005a9e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005aa0:	f0 1f 00 18 	mcall	80005b00 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005aa4:	6c 08       	ld.w	r8,r6[0x0]
80005aa6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005aa8:	49 79       	lddpc	r9,80005b04 <vTaskDelayUntil+0x6c>
80005aaa:	72 09       	ld.w	r9,r9[0x0]
80005aac:	12 38       	cp.w	r8,r9
80005aae:	e0 88 00 0c 	brls	80005ac6 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005ab2:	0e 38       	cp.w	r8,r7
80005ab4:	e0 88 00 22 	brls	80005af8 <vTaskDelayUntil+0x60>
80005ab8:	49 38       	lddpc	r8,80005b04 <vTaskDelayUntil+0x6c>
80005aba:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005abc:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005abe:	10 37       	cp.w	r7,r8
80005ac0:	e0 88 00 14 	brls	80005ae8 <vTaskDelayUntil+0x50>
80005ac4:	c0 a8       	rjmp	80005ad8 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005ac6:	0e 38       	cp.w	r8,r7
80005ac8:	e0 8b 00 16 	brhi	80005af4 <vTaskDelayUntil+0x5c>
80005acc:	48 e8       	lddpc	r8,80005b04 <vTaskDelayUntil+0x6c>
80005ace:	70 08       	ld.w	r8,r8[0x0]
80005ad0:	10 37       	cp.w	r7,r8
80005ad2:	e0 8b 00 11 	brhi	80005af4 <vTaskDelayUntil+0x5c>
80005ad6:	c1 18       	rjmp	80005af8 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ad8:	48 c8       	lddpc	r8,80005b08 <vTaskDelayUntil+0x70>
80005ada:	70 0c       	ld.w	r12,r8[0x0]
80005adc:	2f cc       	sub	r12,-4
80005ade:	f0 1f 00 0c 	mcall	80005b0c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005ae2:	0e 9c       	mov	r12,r7
80005ae4:	f0 1f 00 0b 	mcall	80005b10 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005ae8:	f0 1f 00 0b 	mcall	80005b14 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005aec:	c0 81       	brne	80005afc <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005aee:	d7 33       	scall
80005af0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005af4:	8d 07       	st.w	r6[0x0],r7
80005af6:	cf 1b       	rjmp	80005ad8 <vTaskDelayUntil+0x40>
80005af8:	8d 07       	st.w	r6[0x0],r7
80005afa:	cf 7b       	rjmp	80005ae8 <vTaskDelayUntil+0x50>
80005afc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	55 98       	stdsp	sp[0x164],r8
80005b04:	00 00       	add	r0,r0
80005b06:	0d 04       	ld.w	r4,r6++
80005b08:	00 00       	add	r0,r0
80005b0a:	0c d8       	st.w	--r6,r8
80005b0c:	80 00       	ld.sh	r0,r0[0x0]
80005b0e:	4d aa       	lddpc	r10,80005c74 <xTaskGenericCreate+0x7c>
80005b10:	80 00       	ld.sh	r0,r0[0x0]
80005b12:	5a 3c       	cp.w	r12,-29
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	59 54       	cp.w	r4,21

80005b18 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005b18:	eb cd 40 c0 	pushm	r6-r7,lr
80005b1c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005b1e:	48 e7       	lddpc	r7,80005b54 <vTaskPlaceOnEventList+0x3c>
80005b20:	6e 0b       	ld.w	r11,r7[0x0]
80005b22:	2e 8b       	sub	r11,-24
80005b24:	f0 1f 00 0d 	mcall	80005b58 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b28:	6e 0c       	ld.w	r12,r7[0x0]
80005b2a:	2f cc       	sub	r12,-4
80005b2c:	f0 1f 00 0c 	mcall	80005b5c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005b30:	5b f6       	cp.w	r6,-1
80005b32:	c0 81       	brne	80005b42 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b34:	6e 0b       	ld.w	r11,r7[0x0]
80005b36:	2f cb       	sub	r11,-4
80005b38:	48 ac       	lddpc	r12,80005b60 <vTaskPlaceOnEventList+0x48>
80005b3a:	f0 1f 00 0b 	mcall	80005b64 <vTaskPlaceOnEventList+0x4c>
80005b3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005b42:	48 a8       	lddpc	r8,80005b68 <vTaskPlaceOnEventList+0x50>
80005b44:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005b46:	ec 0c 00 0c 	add	r12,r6,r12
80005b4a:	f0 1f 00 09 	mcall	80005b6c <vTaskPlaceOnEventList+0x54>
80005b4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b52:	00 00       	add	r0,r0
80005b54:	00 00       	add	r0,r0
80005b56:	0c d8       	st.w	--r6,r8
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	4d 76       	lddpc	r6,80005cb4 <xTaskGenericCreate+0xbc>
80005b5c:	80 00       	ld.sh	r0,r0[0x0]
80005b5e:	4d aa       	lddpc	r10,80005cc4 <xTaskGenericCreate+0xcc>
80005b60:	00 00       	add	r0,r0
80005b62:	0d 2c       	ld.uh	r12,r6++
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	4d 5a       	lddpc	r10,80005cb8 <xTaskGenericCreate+0xc0>
80005b68:	00 00       	add	r0,r0
80005b6a:	0d 04       	ld.w	r4,r6++
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	5a 3c       	cp.w	r12,-29

80005b70 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005b70:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005b74:	49 67       	lddpc	r7,80005bcc <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005b76:	49 74       	lddpc	r4,80005bd0 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005b78:	49 73       	lddpc	r3,80005bd4 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005b7a:	49 85       	lddpc	r5,80005bd8 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005b7c:	6e 08       	ld.w	r8,r7[0x0]
80005b7e:	58 08       	cp.w	r8,0
80005b80:	c1 e0       	breq	80005bbc <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005b82:	f0 1f 00 17 	mcall	80005bdc <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005b86:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005b88:	f0 1f 00 16 	mcall	80005be0 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005b8c:	58 06       	cp.w	r6,0
80005b8e:	c1 70       	breq	80005bbc <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005b90:	f0 1f 00 15 	mcall	80005be4 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005b94:	68 38       	ld.w	r8,r4[0xc]
80005b96:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005b98:	ec cc ff fc 	sub	r12,r6,-4
80005b9c:	f0 1f 00 13 	mcall	80005be8 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005ba0:	66 08       	ld.w	r8,r3[0x0]
80005ba2:	20 18       	sub	r8,1
80005ba4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005ba6:	6e 08       	ld.w	r8,r7[0x0]
80005ba8:	20 18       	sub	r8,1
80005baa:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005bac:	f0 1f 00 10 	mcall	80005bec <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005bb0:	6c cc       	ld.w	r12,r6[0x30]
80005bb2:	f0 1f 00 10 	mcall	80005bf0 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005bb6:	0c 9c       	mov	r12,r6
80005bb8:	f0 1f 00 0e 	mcall	80005bf0 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005bbc:	6a 08       	ld.w	r8,r5[0x0]
80005bbe:	58 18       	cp.w	r8,1
80005bc0:	e0 88 00 03 	brls	80005bc6 <prvIdleTask+0x56>
			{
				taskYIELD();
80005bc4:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005bc6:	f0 1f 00 0c 	mcall	80005bf4 <prvIdleTask+0x84>
		}
		#endif
	}
80005bca:	cd 9b       	rjmp	80005b7c <prvIdleTask+0xc>
80005bcc:	00 00       	add	r0,r0
80005bce:	0c 18       	sub	r8,r6
80005bd0:	00 00       	add	r0,r0
80005bd2:	0c c4       	st.b	r6++,r4
80005bd4:	00 00       	add	r0,r0
80005bd6:	0d 24       	ld.uh	r4,r6++
80005bd8:	00 00       	add	r0,r0
80005bda:	0c 24       	rsub	r4,r6
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	55 98       	stdsp	sp[0x164],r8
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	59 54       	cp.w	r4,21
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	4e 64       	lddpc	r4,80005d7c <xTaskGenericCreate+0x184>
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	4d aa       	lddpc	r10,80005d50 <xTaskGenericCreate+0x158>
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	4f 70       	lddpc	r0,80005dc8 <xTaskGenericCreate+0x1d0>
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	50 a8       	stdsp	sp[0x28],r8
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	20 30       	sub	r0,3

80005bf8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005bf8:	d4 31       	pushm	r0-r7,lr
80005bfa:	20 1d       	sub	sp,4
80005bfc:	fa c4 ff d8 	sub	r4,sp,-40
80005c00:	50 0c       	stdsp	sp[0x0],r12
80005c02:	16 91       	mov	r1,r11
80005c04:	14 97       	mov	r7,r10
80005c06:	12 90       	mov	r0,r9
80005c08:	10 93       	mov	r3,r8
80005c0a:	68 02       	ld.w	r2,r4[0x0]
80005c0c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005c0e:	34 8c       	mov	r12,72
80005c10:	f0 1f 00 5c 	mcall	80005d80 <xTaskGenericCreate+0x188>
80005c14:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005c16:	c0 31       	brne	80005c1c <xTaskGenericCreate+0x24>
80005c18:	3f fc       	mov	r12,-1
80005c1a:	ca f8       	rjmp	80005d78 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005c1c:	58 06       	cp.w	r6,0
80005c1e:	e0 81 00 af 	brne	80005d7c <xTaskGenericCreate+0x184>
80005c22:	0e 9c       	mov	r12,r7
80005c24:	5c 7c       	castu.h	r12
80005c26:	a3 6c       	lsl	r12,0x2
80005c28:	f0 1f 00 56 	mcall	80005d80 <xTaskGenericCreate+0x188>
80005c2c:	18 96       	mov	r6,r12
80005c2e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005c30:	c0 61       	brne	80005c3c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005c32:	0a 9c       	mov	r12,r5
80005c34:	f0 1f 00 54 	mcall	80005d84 <xTaskGenericCreate+0x18c>
80005c38:	3f fc       	mov	r12,-1
80005c3a:	c9 f8       	rjmp	80005d78 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005c3c:	5c 77       	castu.h	r7
80005c3e:	ee 0a 15 02 	lsl	r10,r7,0x2
80005c42:	e0 6b 00 a5 	mov	r11,165
80005c46:	0c 9c       	mov	r12,r6
80005c48:	f0 1f 00 50 	mcall	80005d88 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005c4c:	ee c6 00 01 	sub	r6,r7,1
80005c50:	6a c8       	ld.w	r8,r5[0x30]
80005c52:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005c56:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005c5a:	31 0a       	mov	r10,16
80005c5c:	02 9b       	mov	r11,r1
80005c5e:	ea cc ff cc 	sub	r12,r5,-52
80005c62:	f0 1f 00 4b 	mcall	80005d8c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005c66:	30 08       	mov	r8,0
80005c68:	eb 68 00 43 	st.b	r5[67],r8
80005c6c:	58 73       	cp.w	r3,7
80005c6e:	e6 07 17 80 	movls	r7,r3
80005c72:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005c76:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005c78:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005c7c:	ea c4 ff fc 	sub	r4,r5,-4
80005c80:	08 9c       	mov	r12,r4
80005c82:	f0 1f 00 44 	mcall	80005d90 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005c86:	ea cc ff e8 	sub	r12,r5,-24
80005c8a:	f0 1f 00 42 	mcall	80005d90 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005c8e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005c90:	ee 07 11 08 	rsub	r7,r7,8
80005c94:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005c96:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005c98:	00 9a       	mov	r10,r0
80005c9a:	40 0b       	lddsp	r11,sp[0x0]
80005c9c:	0c 9c       	mov	r12,r6
80005c9e:	f0 1f 00 3e 	mcall	80005d94 <xTaskGenericCreate+0x19c>
80005ca2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005ca4:	58 02       	cp.w	r2,0
80005ca6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005caa:	f0 1f 00 3c 	mcall	80005d98 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005cae:	4b c8       	lddpc	r8,80005d9c <xTaskGenericCreate+0x1a4>
80005cb0:	70 09       	ld.w	r9,r8[0x0]
80005cb2:	2f f9       	sub	r9,-1
80005cb4:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005cb6:	4b b8       	lddpc	r8,80005da0 <xTaskGenericCreate+0x1a8>
80005cb8:	70 08       	ld.w	r8,r8[0x0]
80005cba:	58 08       	cp.w	r8,0
80005cbc:	c2 61       	brne	80005d08 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005cbe:	4b 98       	lddpc	r8,80005da0 <xTaskGenericCreate+0x1a8>
80005cc0:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005cc2:	4b 78       	lddpc	r8,80005d9c <xTaskGenericCreate+0x1a4>
80005cc4:	70 08       	ld.w	r8,r8[0x0]
80005cc6:	58 18       	cp.w	r8,1
80005cc8:	c2 b1       	brne	80005d1e <xTaskGenericCreate+0x126>
80005cca:	4b 77       	lddpc	r7,80005da4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005ccc:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005cd0:	0e 9c       	mov	r12,r7
80005cd2:	f0 1f 00 36 	mcall	80005da8 <xTaskGenericCreate+0x1b0>
80005cd6:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005cd8:	0c 37       	cp.w	r7,r6
80005cda:	cf b1       	brne	80005cd0 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005cdc:	4b 47       	lddpc	r7,80005dac <xTaskGenericCreate+0x1b4>
80005cde:	0e 9c       	mov	r12,r7
80005ce0:	f0 1f 00 32 	mcall	80005da8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005ce4:	4b 36       	lddpc	r6,80005db0 <xTaskGenericCreate+0x1b8>
80005ce6:	0c 9c       	mov	r12,r6
80005ce8:	f0 1f 00 30 	mcall	80005da8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005cec:	4b 2c       	lddpc	r12,80005db4 <xTaskGenericCreate+0x1bc>
80005cee:	f0 1f 00 2f 	mcall	80005da8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005cf2:	4b 2c       	lddpc	r12,80005db8 <xTaskGenericCreate+0x1c0>
80005cf4:	f0 1f 00 2d 	mcall	80005da8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005cf8:	4b 1c       	lddpc	r12,80005dbc <xTaskGenericCreate+0x1c4>
80005cfa:	f0 1f 00 2c 	mcall	80005da8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005cfe:	4b 18       	lddpc	r8,80005dc0 <xTaskGenericCreate+0x1c8>
80005d00:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005d02:	4b 18       	lddpc	r8,80005dc4 <xTaskGenericCreate+0x1cc>
80005d04:	91 06       	st.w	r8[0x0],r6
80005d06:	c0 c8       	rjmp	80005d1e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005d08:	4b 08       	lddpc	r8,80005dc8 <xTaskGenericCreate+0x1d0>
80005d0a:	70 08       	ld.w	r8,r8[0x0]
80005d0c:	58 08       	cp.w	r8,0
80005d0e:	c0 81       	brne	80005d1e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005d10:	4a 48       	lddpc	r8,80005da0 <xTaskGenericCreate+0x1a8>
80005d12:	70 08       	ld.w	r8,r8[0x0]
80005d14:	70 b8       	ld.w	r8,r8[0x2c]
80005d16:	10 33       	cp.w	r3,r8
80005d18:	c0 33       	brcs	80005d1e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005d1a:	4a 28       	lddpc	r8,80005da0 <xTaskGenericCreate+0x1a8>
80005d1c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005d1e:	6a b8       	ld.w	r8,r5[0x2c]
80005d20:	4a b9       	lddpc	r9,80005dcc <xTaskGenericCreate+0x1d4>
80005d22:	72 09       	ld.w	r9,r9[0x0]
80005d24:	12 38       	cp.w	r8,r9
80005d26:	e0 88 00 04 	brls	80005d2e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005d2a:	4a 99       	lddpc	r9,80005dcc <xTaskGenericCreate+0x1d4>
80005d2c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005d2e:	4a 98       	lddpc	r8,80005dd0 <xTaskGenericCreate+0x1d8>
80005d30:	70 09       	ld.w	r9,r8[0x0]
80005d32:	2f f9       	sub	r9,-1
80005d34:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005d36:	6a b8       	ld.w	r8,r5[0x2c]
80005d38:	4a 79       	lddpc	r9,80005dd4 <xTaskGenericCreate+0x1dc>
80005d3a:	72 09       	ld.w	r9,r9[0x0]
80005d3c:	12 38       	cp.w	r8,r9
80005d3e:	e0 88 00 04 	brls	80005d46 <xTaskGenericCreate+0x14e>
80005d42:	4a 59       	lddpc	r9,80005dd4 <xTaskGenericCreate+0x1dc>
80005d44:	93 08       	st.w	r9[0x0],r8
80005d46:	6a bc       	ld.w	r12,r5[0x2c]
80005d48:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d4c:	08 9b       	mov	r11,r4
80005d4e:	49 68       	lddpc	r8,80005da4 <xTaskGenericCreate+0x1ac>
80005d50:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005d54:	f0 1f 00 21 	mcall	80005dd8 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005d58:	f0 1f 00 21 	mcall	80005ddc <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005d5c:	49 b8       	lddpc	r8,80005dc8 <xTaskGenericCreate+0x1d0>
80005d5e:	70 08       	ld.w	r8,r8[0x0]
80005d60:	58 08       	cp.w	r8,0
80005d62:	c0 a0       	breq	80005d76 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005d64:	48 f8       	lddpc	r8,80005da0 <xTaskGenericCreate+0x1a8>
80005d66:	70 08       	ld.w	r8,r8[0x0]
80005d68:	70 b8       	ld.w	r8,r8[0x2c]
80005d6a:	10 33       	cp.w	r3,r8
80005d6c:	e0 88 00 05 	brls	80005d76 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005d70:	d7 33       	scall
80005d72:	30 1c       	mov	r12,1
80005d74:	c0 28       	rjmp	80005d78 <xTaskGenericCreate+0x180>
80005d76:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005d78:	2f fd       	sub	sp,-4
80005d7a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005d7c:	99 c6       	st.w	r12[0x30],r6
80005d7e:	c5 fb       	rjmp	80005c3c <xTaskGenericCreate+0x44>
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	50 d0       	stdsp	sp[0x34],r0
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	50 a8       	stdsp	sp[0x28],r8
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	6a 5c       	ld.w	r12,r5[0x14]
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	6d a0       	ld.w	r0,r6[0x68]
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	4d 54       	lddpc	r4,80005ee4 <PrintDec+0x2>
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	4d d0       	lddpc	r0,80005f08 <PrintDec+0x26>
80005d98:	80 00       	ld.sh	r0,r0[0x0]
80005d9a:	4e 64       	lddpc	r4,80005f30 <PrintDec+0x4e>
80005d9c:	00 00       	add	r0,r0
80005d9e:	0d 24       	ld.uh	r4,r6++
80005da0:	00 00       	add	r0,r0
80005da2:	0c d8       	st.w	--r6,r8
80005da4:	00 00       	add	r0,r0
80005da6:	0c 24       	rsub	r4,r6
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	4d 40       	lddpc	r0,80005ef8 <PrintDec+0x16>
80005dac:	00 00       	add	r0,r0
80005dae:	0c f0       	st.b	--r6,r0
80005db0:	00 00       	add	r0,r0
80005db2:	0d 0c       	ld.w	r12,r6++
80005db4:	00 00       	add	r0,r0
80005db6:	0c dc       	st.w	--r6,r12
80005db8:	00 00       	add	r0,r0
80005dba:	0c c4       	st.b	r6++,r4
80005dbc:	00 00       	add	r0,r0
80005dbe:	0d 2c       	ld.uh	r12,r6++
80005dc0:	00 00       	add	r0,r0
80005dc2:	0c 10       	sub	r0,r6
80005dc4:	00 00       	add	r0,r0
80005dc6:	0c 20       	rsub	r0,r6
80005dc8:	00 00       	add	r0,r0
80005dca:	0c 14       	sub	r4,r6
80005dcc:	00 00       	add	r0,r0
80005dce:	0c 0c       	add	r12,r6
80005dd0:	00 00       	add	r0,r0
80005dd2:	0d 20       	ld.uh	r0,r6++
80005dd4:	00 00       	add	r0,r0
80005dd6:	0d 40       	ld.w	r0,--r6
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	4d 5a       	lddpc	r10,80005f2c <PrintDec+0x4a>
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	4f 70       	lddpc	r0,80005fb8 <PrintDec+0xd6>

80005de0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005de0:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005de2:	30 09       	mov	r9,0
80005de4:	1a d9       	st.w	--sp,r9
80005de6:	1a d9       	st.w	--sp,r9
80005de8:	1a d9       	st.w	--sp,r9
80005dea:	12 98       	mov	r8,r9
80005dec:	e0 6a 01 00 	mov	r10,256
80005df0:	48 9b       	lddpc	r11,80005e14 <vTaskStartScheduler+0x34>
80005df2:	48 ac       	lddpc	r12,80005e18 <vTaskStartScheduler+0x38>
80005df4:	f0 1f 00 0a 	mcall	80005e1c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005df8:	2f dd       	sub	sp,-12
80005dfa:	58 1c       	cp.w	r12,1
80005dfc:	c0 a1       	brne	80005e10 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005dfe:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005e00:	30 19       	mov	r9,1
80005e02:	48 88       	lddpc	r8,80005e20 <vTaskStartScheduler+0x40>
80005e04:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005e06:	30 09       	mov	r9,0
80005e08:	48 78       	lddpc	r8,80005e24 <vTaskStartScheduler+0x44>
80005e0a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005e0c:	f0 1f 00 07 	mcall	80005e28 <vTaskStartScheduler+0x48>
80005e10:	d8 02       	popm	pc
80005e12:	00 00       	add	r0,r0
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	c8 90       	breq	80005d28 <xTaskGenericCreate+0x130>
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	5b 70       	cp.w	r0,-9
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	5b f8       	cp.w	r8,-1
80005e20:	00 00       	add	r0,r0
80005e22:	0c 14       	sub	r4,r6
80005e24:	00 00       	add	r0,r0
80005e26:	0d 04       	ld.w	r4,r6++
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	4e 74       	lddpc	r4,80005fc4 <log+0x8>

80005e2c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005e2c:	16 cc       	st.b	r11++,r12
	return str;
}
80005e2e:	5e fb       	retal	r11

80005e30 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005e30:	eb cd 40 c0 	pushm	r6-r7,lr
80005e34:	20 3d       	sub	sp,12
80005e36:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005e38:	30 06       	mov	r6,0
80005e3a:	30 07       	mov	r7,0
80005e3c:	fa e7 00 00 	st.d	sp[0],r6
80005e40:	30 0c       	mov	r12,0
80005e42:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005e44:	58 08       	cp.w	r8,0
80005e46:	c1 30       	breq	80005e6c <PrintHex+0x3c>
80005e48:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005e4a:	1a 9c       	mov	r12,sp
80005e4c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005e50:	58 9e       	cp.w	lr,9
80005e52:	e0 8a 00 04 	brle	80005e5a <PrintHex+0x2a>
80005e56:	2c 9e       	sub	lr,-55
80005e58:	c0 48       	rjmp	80005e60 <PrintHex+0x30>
80005e5a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005e5e:	2d 0e       	sub	lr,-48
80005e60:	f8 09 0b 0e 	st.b	r12[r9],lr
80005e64:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005e66:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005e68:	cf 21       	brne	80005e4c <PrintHex+0x1c>
80005e6a:	c0 48       	rjmp	80005e72 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005e6c:	33 08       	mov	r8,48
80005e6e:	ba 88       	st.b	sp[0x0],r8
80005e70:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005e72:	f6 09 01 08 	sub	r8,r11,r9
80005e76:	58 08       	cp.w	r8,0
80005e78:	e0 8a 00 13 	brle	80005e9e <PrintHex+0x6e>
	{
		char num = len - cnt;
80005e7c:	12 1b       	sub	r11,r9
80005e7e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005e82:	18 9e       	mov	lr,r12
80005e84:	58 0c       	cp.w	r12,0
80005e86:	e0 8a 00 0c 	brle	80005e9e <PrintHex+0x6e>
80005e8a:	1a 9b       	mov	r11,sp
80005e8c:	12 0b       	add	r11,r9
80005e8e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005e90:	33 07       	mov	r7,48
80005e92:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005e94:	2f f8       	sub	r8,-1
80005e96:	1c 38       	cp.w	r8,lr
80005e98:	cf d5       	brlt	80005e92 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005e9a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005e9e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005ea2:	f0 cb ff ff 	sub	r11,r8,-1
80005ea6:	58 0b       	cp.w	r11,0
80005ea8:	e0 8a 00 19 	brle	80005eda <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005eac:	fa cb ff f4 	sub	r11,sp,-12
80005eb0:	f6 09 00 09 	add	r9,r11,r9
80005eb4:	37 8b       	mov	r11,120
80005eb6:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005eba:	fa c9 ff f4 	sub	r9,sp,-12
80005ebe:	10 09       	add	r9,r8
80005ec0:	33 0b       	mov	r11,48
80005ec2:	f3 6b ff f4 	st.b	r9[-12],r11
80005ec6:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005eca:	fa ce 00 01 	sub	lr,sp,1
80005ece:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005ed0:	11 8b       	ld.ub	r11,r8[0x0]
80005ed2:	12 cb       	st.b	r9++,r11
80005ed4:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005ed6:	1c 38       	cp.w	r8,lr
80005ed8:	cf c1       	brne	80005ed0 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005eda:	14 9c       	mov	r12,r10
80005edc:	2f dd       	sub	sp,-12
80005ede:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005ee2 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005ee2:	d4 21       	pushm	r4-r7,lr
80005ee4:	20 3d       	sub	sp,12
80005ee6:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005ee8:	30 06       	mov	r6,0
80005eea:	30 07       	mov	r7,0
80005eec:	fa e7 00 00 	st.d	sp[0],r6
80005ef0:	30 0c       	mov	r12,0
80005ef2:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005ef4:	58 08       	cp.w	r8,0
80005ef6:	c0 35       	brlt	80005efc <PrintDec+0x1a>
80005ef8:	14 97       	mov	r7,r10
80005efa:	c0 58       	rjmp	80005f04 <PrintDec+0x22>
	{
		*p++ = '-';
80005efc:	14 97       	mov	r7,r10
80005efe:	32 d9       	mov	r9,45
80005f00:	0e c9       	st.b	r7++,r9
		i = -i;
80005f02:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005f04:	58 08       	cp.w	r8,0
80005f06:	c0 51       	brne	80005f10 <PrintDec+0x2e>
80005f08:	33 08       	mov	r8,48
80005f0a:	ba 88       	st.b	sp[0x0],r8
80005f0c:	30 1e       	mov	lr,1
80005f0e:	c2 f8       	rjmp	80005f6c <PrintDec+0x8a>
	
	int ten = i%10;
80005f10:	e0 65 66 67 	mov	r5,26215
80005f14:	ea 15 66 66 	orh	r5,0x6666
80005f18:	f0 05 04 44 	muls.d	r4,r8,r5
80005f1c:	ea 0c 14 02 	asr	r12,r5,0x2
80005f20:	f0 09 14 1f 	asr	r9,r8,0x1f
80005f24:	f8 09 01 09 	sub	r9,r12,r9
80005f28:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005f2c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005f30:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005f32:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005f34:	e0 66 66 67 	mov	r6,26215
80005f38:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005f3c:	2d 09       	sub	r9,-48
80005f3e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005f42:	2f fe       	sub	lr,-1
		i /= 10;
80005f44:	f0 06 04 44 	muls.d	r4,r8,r6
80005f48:	ea 09 14 02 	asr	r9,r5,0x2
80005f4c:	bf 58       	asr	r8,0x1f
80005f4e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005f52:	f0 06 04 44 	muls.d	r4,r8,r6
80005f56:	ea 09 14 02 	asr	r9,r5,0x2
80005f5a:	f0 05 14 1f 	asr	r5,r8,0x1f
80005f5e:	0a 19       	sub	r9,r5
80005f60:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005f64:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005f68:	58 08       	cp.w	r8,0
80005f6a:	ce 91       	brne	80005f3c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005f6c:	f6 0e 01 08 	sub	r8,r11,lr
80005f70:	58 08       	cp.w	r8,0
80005f72:	e0 89 00 06 	brgt	80005f7e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005f76:	58 0e       	cp.w	lr,0
80005f78:	e0 89 00 14 	brgt	80005fa0 <PrintDec+0xbe>
80005f7c:	c1 d8       	rjmp	80005fb6 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005f7e:	1c 1b       	sub	r11,lr
80005f80:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005f82:	16 9c       	mov	r12,r11
80005f84:	58 0b       	cp.w	r11,0
80005f86:	fe 9a ff f8 	brle	80005f76 <PrintDec+0x94>
80005f8a:	1a 99       	mov	r9,sp
80005f8c:	1c 09       	add	r9,lr
80005f8e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005f90:	33 06       	mov	r6,48
80005f92:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005f94:	2f f8       	sub	r8,-1
80005f96:	18 38       	cp.w	r8,r12
80005f98:	cf d5       	brlt	80005f92 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005f9a:	f6 0e 00 0e 	add	lr,r11,lr
80005f9e:	ce cb       	rjmp	80005f76 <PrintDec+0x94>
80005fa0:	fa c8 ff f4 	sub	r8,sp,-12
80005fa4:	1c 08       	add	r8,lr
80005fa6:	20 d8       	sub	r8,13
80005fa8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005fac:	11 89       	ld.ub	r9,r8[0x0]
80005fae:	0e c9       	st.b	r7++,r9
80005fb0:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005fb2:	16 38       	cp.w	r8,r11
80005fb4:	cf c1       	brne	80005fac <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005fb6:	14 9c       	mov	r12,r10
80005fb8:	2f dd       	sub	sp,-12
80005fba:	d8 22       	popm	r4-r7,pc

80005fbc <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005fbc:	d4 31       	pushm	r0-r7,lr
80005fbe:	fa cd 02 08 	sub	sp,sp,520
80005fc2:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005fc4:	e0 6a 01 00 	mov	r10,256
80005fc8:	30 0b       	mov	r11,0
80005fca:	fa cc fe f8 	sub	r12,sp,-264
80005fce:	f0 1f 00 4e 	mcall	80006104 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005fd2:	fa c4 fd d4 	sub	r4,sp,-556
80005fd6:	30 0a       	mov	r10,0
80005fd8:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005fda:	fa c3 ff fc 	sub	r3,sp,-4
80005fde:	e0 61 01 00 	mov	r1,256
80005fe2:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005fe4:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005fe6:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005fea:	02 9a       	mov	r10,r1
80005fec:	00 9b       	mov	r11,r0
80005fee:	06 9c       	mov	r12,r3
80005ff0:	f0 1f 00 45 	mcall	80006104 <log+0x148>
			
					if(*str == '%')
80005ff4:	0f 88       	ld.ub	r8,r7[0x0]
80005ff6:	e4 08 18 00 	cp.b	r8,r2
80005ffa:	c5 71       	brne	800060a8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005ffc:	ee c8 ff ff 	sub	r8,r7,-1
80006000:	11 89       	ld.ub	r9,r8[0x0]
80006002:	4c 2a       	lddpc	r10,80006108 <log+0x14c>
80006004:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006006:	23 09       	sub	r9,48
80006008:	30 9a       	mov	r10,9
8000600a:	f4 09 18 00 	cp.b	r9,r10
8000600e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006012:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006016:	f7 b9 08 30 	subls	r9,48
8000601a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000601e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006022:	0f 88       	ld.ub	r8,r7[0x0]
80006024:	22 58       	sub	r8,37
80006026:	e0 48 00 53 	cp.w	r8,83
8000602a:	e0 8b 00 31 	brhi	8000608c <log+0xd0>
8000602e:	4b 89       	lddpc	r9,8000610c <log+0x150>
80006030:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006034:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006038:	06 9a       	mov	r10,r3
8000603a:	40 0b       	lddsp	r11,sp[0x0]
8000603c:	5c 5b       	castu.b	r11
8000603e:	68 0c       	ld.w	r12,r4[0x0]
80006040:	f0 1f 00 34 	mcall	80006110 <log+0x154>
							break;
80006044:	c2 98       	rjmp	80006096 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006046:	4b 4c       	lddpc	r12,80006114 <log+0x158>
80006048:	f0 1f 00 34 	mcall	80006118 <log+0x15c>
8000604c:	08 95       	mov	r5,r4
8000604e:	06 9c       	mov	r12,r3
							break;
80006050:	c2 38       	rjmp	80006096 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006052:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006056:	06 9a       	mov	r10,r3
80006058:	40 0b       	lddsp	r11,sp[0x0]
8000605a:	5c 5b       	castu.b	r11
8000605c:	68 0c       	ld.w	r12,r4[0x0]
8000605e:	f0 1f 00 30 	mcall	8000611c <log+0x160>
80006062:	06 9c       	mov	r12,r3
							break;
80006064:	c1 98       	rjmp	80006096 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006066:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000606a:	06 9b       	mov	r11,r3
8000606c:	09 bc       	ld.ub	r12,r4[0x3]
8000606e:	f0 1f 00 2d 	mcall	80006120 <log+0x164>
80006072:	06 9c       	mov	r12,r3
							break;
80006074:	c1 18       	rjmp	80006096 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006076:	e8 c5 ff fc 	sub	r5,r4,-4
8000607a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000607c:	c0 d8       	rjmp	80006096 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000607e:	06 9b       	mov	r11,r3
80006080:	32 5c       	mov	r12,37
80006082:	f0 1f 00 28 	mcall	80006120 <log+0x164>
80006086:	08 95       	mov	r5,r4
80006088:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000608a:	c0 68       	rjmp	80006096 <log+0xda>
							
							default:
							log("I need relax.");
8000608c:	4a 6c       	lddpc	r12,80006124 <log+0x168>
8000608e:	f0 1f 00 23 	mcall	80006118 <log+0x15c>
80006092:	08 95       	mov	r5,r4
80006094:	06 9c       	mov	r12,r3
						}
						str++;
80006096:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006098:	1a dc       	st.w	--sp,r12
8000609a:	1a d6       	st.w	--sp,r6
8000609c:	4a 3b       	lddpc	r11,80006128 <log+0x16c>
8000609e:	0c 9c       	mov	r12,r6
800060a0:	f0 1f 00 23 	mcall	8000612c <log+0x170>
800060a4:	2f ed       	sub	sp,-8
800060a6:	c0 a8       	rjmp	800060ba <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800060a8:	2f f7       	sub	r7,-1
800060aa:	1a d8       	st.w	--sp,r8
800060ac:	1a d6       	st.w	--sp,r6
800060ae:	4a 1b       	lddpc	r11,80006130 <log+0x174>
800060b0:	0c 9c       	mov	r12,r6
800060b2:	f0 1f 00 1f 	mcall	8000612c <log+0x170>
800060b6:	08 95       	mov	r5,r4
800060b8:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800060ba:	0f 89       	ld.ub	r9,r7[0x0]
800060bc:	30 08       	mov	r8,0
800060be:	f0 09 18 00 	cp.b	r9,r8
800060c2:	c0 30       	breq	800060c8 <log+0x10c>
800060c4:	0a 94       	mov	r4,r5
800060c6:	c9 2b       	rjmp	80005fea <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800060c8:	fa c7 fe f8 	sub	r7,sp,-264
800060cc:	1a d7       	st.w	--sp,r7
800060ce:	49 ab       	lddpc	r11,80006134 <log+0x178>
800060d0:	0e 9c       	mov	r12,r7
800060d2:	f0 1f 00 17 	mcall	8000612c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800060d6:	5c 5c       	castu.b	r12
800060d8:	f8 c6 ff ff 	sub	r6,r12,-1
800060dc:	0c 9c       	mov	r12,r6
800060de:	f0 1f 00 17 	mcall	80006138 <log+0x17c>
800060e2:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800060e4:	0c 9a       	mov	r10,r6
800060e6:	0e 9b       	mov	r11,r7
800060e8:	f0 1f 00 15 	mcall	8000613c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800060ec:	30 09       	mov	r9,0
800060ee:	30 5a       	mov	r10,5
800060f0:	fa cb fe f8 	sub	r11,sp,-264
800060f4:	49 38       	lddpc	r8,80006140 <log+0x184>
800060f6:	70 0c       	ld.w	r12,r8[0x0]
800060f8:	f0 1f 00 13 	mcall	80006144 <log+0x188>
800060fc:	2f fd       	sub	sp,-4
	
	
}
800060fe:	fe 3d fd f8 	sub	sp,-520
80006102:	d8 32       	popm	r0-r7,pc
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	6a 5c       	ld.w	r12,r5[0x14]
80006108:	00 00       	add	r0,r0
8000610a:	0d 44       	ld.w	r4,--r6
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	c8 98       	rjmp	80006220 <logFromISR+0xd8>
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	5e e2       	retqs	r2
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	cb 44       	brge	8000607e <log+0xc2>
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	5f bc       	srhi	r12
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	5e 30       	retlo	r0
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	5e 2c       	reths	r12
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	cb 54       	brge	80006090 <log+0xd4>
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	cb 64       	brge	80006096 <log+0xda>
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	6d 4c       	ld.w	r12,r6[0x50]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	cb 6c       	rcall	8000629e <logFromISR+0x156>
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	cb 74       	brge	800060a4 <log+0xe8>
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	50 d0       	stdsp	sp[0x34],r0
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	69 14       	ld.w	r4,r4[0x44]
80006140:	00 00       	add	r0,r0
80006142:	40 fc       	lddsp	r12,sp[0x3c]
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	54 24       	stdsp	sp[0x108],r4

80006148 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006148:	d4 31       	pushm	r0-r7,lr
8000614a:	fa cd 02 0c 	sub	sp,sp,524
8000614e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006150:	e0 6a 01 00 	mov	r10,256
80006154:	30 0b       	mov	r11,0
80006156:	fa cc fe f4 	sub	r12,sp,-268
8000615a:	f0 1f 00 4c 	mcall	80006288 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000615e:	fa c4 fd d0 	sub	r4,sp,-560
80006162:	30 0a       	mov	r10,0
80006164:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006166:	fa c3 ff fc 	sub	r3,sp,-4
8000616a:	e0 61 01 00 	mov	r1,256
8000616e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006170:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006172:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006176:	02 9a       	mov	r10,r1
80006178:	00 9b       	mov	r11,r0
8000617a:	06 9c       	mov	r12,r3
8000617c:	f0 1f 00 43 	mcall	80006288 <logFromISR+0x140>
			
			if(*str == '%')
80006180:	0f 88       	ld.ub	r8,r7[0x0]
80006182:	e4 08 18 00 	cp.b	r8,r2
80006186:	c5 11       	brne	80006228 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006188:	ee c8 ff ff 	sub	r8,r7,-1
8000618c:	11 89       	ld.ub	r9,r8[0x0]
8000618e:	4c 0a       	lddpc	r10,8000628c <logFromISR+0x144>
80006190:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006192:	23 09       	sub	r9,48
80006194:	30 9a       	mov	r10,9
80006196:	f4 09 18 00 	cp.b	r9,r10
8000619a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000619e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800061a2:	f7 b9 08 30 	subls	r9,48
800061a6:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800061aa:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800061ae:	0f 88       	ld.ub	r8,r7[0x0]
800061b0:	22 58       	sub	r8,37
800061b2:	e0 48 00 53 	cp.w	r8,83
800061b6:	e0 8b 00 2b 	brhi	8000620c <logFromISR+0xc4>
800061ba:	4b 69       	lddpc	r9,80006290 <logFromISR+0x148>
800061bc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800061c0:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800061c4:	06 9a       	mov	r10,r3
800061c6:	40 0b       	lddsp	r11,sp[0x0]
800061c8:	5c 5b       	castu.b	r11
800061ca:	68 0c       	ld.w	r12,r4[0x0]
800061cc:	f0 1f 00 32 	mcall	80006294 <logFromISR+0x14c>
					break;
800061d0:	c2 38       	rjmp	80006216 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800061d2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800061d6:	06 9a       	mov	r10,r3
800061d8:	40 0b       	lddsp	r11,sp[0x0]
800061da:	5c 5b       	castu.b	r11
800061dc:	68 0c       	ld.w	r12,r4[0x0]
800061de:	f0 1f 00 2f 	mcall	80006298 <logFromISR+0x150>
800061e2:	06 9c       	mov	r12,r3
					break;
800061e4:	c1 98       	rjmp	80006216 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800061e6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800061ea:	06 9b       	mov	r11,r3
800061ec:	09 bc       	ld.ub	r12,r4[0x3]
800061ee:	f0 1f 00 2c 	mcall	8000629c <logFromISR+0x154>
800061f2:	06 9c       	mov	r12,r3
					break;
800061f4:	c1 18       	rjmp	80006216 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800061f6:	e8 c5 ff fc 	sub	r5,r4,-4
800061fa:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800061fc:	c0 d8       	rjmp	80006216 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800061fe:	06 9b       	mov	r11,r3
80006200:	32 5c       	mov	r12,37
80006202:	f0 1f 00 27 	mcall	8000629c <logFromISR+0x154>
80006206:	08 95       	mov	r5,r4
80006208:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000620a:	c0 68       	rjmp	80006216 <logFromISR+0xce>
					default:
					log("I need relax.");
8000620c:	4a 5c       	lddpc	r12,800062a0 <logFromISR+0x158>
8000620e:	f0 1f 00 26 	mcall	800062a4 <logFromISR+0x15c>
80006212:	08 95       	mov	r5,r4
80006214:	06 9c       	mov	r12,r3
				}
				str++;
80006216:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006218:	1a dc       	st.w	--sp,r12
8000621a:	1a d6       	st.w	--sp,r6
8000621c:	4a 3b       	lddpc	r11,800062a8 <logFromISR+0x160>
8000621e:	0c 9c       	mov	r12,r6
80006220:	f0 1f 00 23 	mcall	800062ac <logFromISR+0x164>
80006224:	2f ed       	sub	sp,-8
80006226:	c0 a8       	rjmp	8000623a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006228:	2f f7       	sub	r7,-1
8000622a:	1a d8       	st.w	--sp,r8
8000622c:	1a d6       	st.w	--sp,r6
8000622e:	4a 1b       	lddpc	r11,800062b0 <logFromISR+0x168>
80006230:	0c 9c       	mov	r12,r6
80006232:	f0 1f 00 1f 	mcall	800062ac <logFromISR+0x164>
80006236:	08 95       	mov	r5,r4
80006238:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000623a:	0f 89       	ld.ub	r9,r7[0x0]
8000623c:	30 08       	mov	r8,0
8000623e:	f0 09 18 00 	cp.b	r9,r8
80006242:	c0 30       	breq	80006248 <logFromISR+0x100>
80006244:	0a 94       	mov	r4,r5
80006246:	c9 8b       	rjmp	80006176 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006248:	fa c7 fe f4 	sub	r7,sp,-268
8000624c:	1a d7       	st.w	--sp,r7
8000624e:	49 ab       	lddpc	r11,800062b4 <logFromISR+0x16c>
80006250:	0e 9c       	mov	r12,r7
80006252:	f0 1f 00 17 	mcall	800062ac <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006256:	5c 5c       	castu.b	r12
80006258:	f8 c6 ff ff 	sub	r6,r12,-1
8000625c:	0c 9c       	mov	r12,r6
8000625e:	f0 1f 00 17 	mcall	800062b8 <logFromISR+0x170>
80006262:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006264:	0c 9a       	mov	r10,r6
80006266:	0e 9b       	mov	r11,r7
80006268:	f0 1f 00 15 	mcall	800062bc <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000626c:	30 09       	mov	r9,0
8000626e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006270:	fa ca fe f8 	sub	r10,sp,-264
80006274:	fa cb fe f4 	sub	r11,sp,-268
80006278:	49 28       	lddpc	r8,800062c0 <logFromISR+0x178>
8000627a:	70 0c       	ld.w	r12,r8[0x0]
8000627c:	f0 1f 00 12 	mcall	800062c4 <logFromISR+0x17c>
80006280:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006282:	fe 3d fd f4 	sub	sp,-524
80006286:	d8 32       	popm	r0-r7,pc
80006288:	80 00       	ld.sh	r0,r0[0x0]
8000628a:	6a 5c       	ld.w	r12,r5[0x14]
8000628c:	00 00       	add	r0,r0
8000628e:	0d 45       	ld.w	r5,--r6
80006290:	80 00       	ld.sh	r0,r0[0x0]
80006292:	c9 e8       	rjmp	800063ce <main+0x5a>
80006294:	80 00       	ld.sh	r0,r0[0x0]
80006296:	5e e2       	retqs	r2
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	5e 30       	retlo	r0
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	5e 2c       	reths	r12
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	cb 54       	brge	8000620c <logFromISR+0xc4>
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	5f bc       	srhi	r12
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	cb 64       	brge	80006216 <logFromISR+0xce>
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	6d 4c       	ld.w	r12,r6[0x50]
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	cb 6c       	rcall	8000641e <gpio_enable_module_pin+0x26>
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	cb 74       	brge	80006224 <logFromISR+0xdc>
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	50 d0       	stdsp	sp[0x34],r0
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	69 14       	ld.w	r4,r4[0x44]
800062c0:	00 00       	add	r0,r0
800062c2:	40 fc       	lddsp	r12,sp[0x3c]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	53 d4       	stdsp	sp[0xf4],r4

800062c8 <log_init>:
		
	return str;
}

void log_init(void)
{
800062c8:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800062ca:	30 2b       	mov	r11,2
800062cc:	49 0c       	lddpc	r12,8000630c <log_init+0x44>
800062ce:	f0 1f 00 11 	mcall	80006310 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);		
800062d2:	e0 6a 36 00 	mov	r10,13824
800062d6:	ea 1a 01 6e 	orh	r10,0x16e
800062da:	48 fb       	lddpc	r11,80006314 <log_init+0x4c>
800062dc:	fe 7c 18 00 	mov	r12,-59392
800062e0:	f0 1f 00 0e 	mcall	80006318 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800062e4:	30 4b       	mov	r11,4
800062e6:	33 2c       	mov	r12,50
800062e8:	f0 1f 00 0d 	mcall	8000631c <log_init+0x54>
800062ec:	48 d8       	lddpc	r8,80006320 <log_init+0x58>
800062ee:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800062f0:	30 09       	mov	r9,0
800062f2:	1a d9       	st.w	--sp,r9
800062f4:	1a d9       	st.w	--sp,r9
800062f6:	1a d9       	st.w	--sp,r9
800062f8:	30 28       	mov	r8,2
800062fa:	e0 6a 01 80 	mov	r10,384
800062fe:	48 ab       	lddpc	r11,80006324 <log_init+0x5c>
80006300:	48 ac       	lddpc	r12,80006328 <log_init+0x60>
80006302:	f0 1f 00 0b 	mcall	8000632c <log_init+0x64>
80006306:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006308:	d8 02       	popm	pc
8000630a:	00 00       	add	r0,r0
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	cb 80       	breq	8000627e <logFromISR+0x136>
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	64 4c       	ld.w	r12,r2[0x10]
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	cb 38       	rjmp	8000647c <_stext>
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	4c 74       	lddpc	r4,80006434 <gpio_enable_module_pin+0x3c>
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	55 24       	stdsp	sp[0x148],r4
80006320:	00 00       	add	r0,r0
80006322:	40 fc       	lddsp	r12,sp[0x3c]
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	cb 7c       	rcall	80006494 <_stext+0x18>
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	63 30       	ld.w	r0,r1[0x4c]
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	5b f8       	cp.w	r8,-1

80006330 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006330:	eb cd 40 f8 	pushm	r3-r7,lr
80006334:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006336:	48 c7       	lddpc	r7,80006364 <task_log+0x34>
80006338:	30 05       	mov	r5,0
8000633a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000633c:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006340:	0a 99       	mov	r9,r5
80006342:	08 9a       	mov	r10,r4
80006344:	1a 9b       	mov	r11,sp
80006346:	6e 0c       	ld.w	r12,r7[0x0]
80006348:	f0 1f 00 08 	mcall	80006368 <task_log+0x38>
8000634c:	58 1c       	cp.w	r12,1
8000634e:	cf 91       	brne	80006340 <task_log+0x10>
		{
			if( NULL != str)
80006350:	40 0b       	lddsp	r11,sp[0x0]
80006352:	58 0b       	cp.w	r11,0
80006354:	cf 60       	breq	80006340 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006356:	06 9c       	mov	r12,r3
80006358:	f0 1f 00 05 	mcall	8000636c <task_log+0x3c>
				vPortFree(str);
8000635c:	40 0c       	lddsp	r12,sp[0x0]
8000635e:	f0 1f 00 05 	mcall	80006370 <task_log+0x40>
80006362:	ce fb       	rjmp	80006340 <task_log+0x10>
80006364:	00 00       	add	r0,r0
80006366:	40 fc       	lddsp	r12,sp[0x3c]
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	52 18       	stdsp	sp[0x84],r8
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	4c 24       	lddpc	r4,80006474 <gpio_enable_module+0x28>
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	50 a8       	stdsp	sp[0x28],r8

80006374 <main>:
//#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
80006374:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006376:	fe 78 10 00 	mov	r8,-61440
8000637a:	30 19       	mov	r9,1
8000637c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006380:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006384:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006388:	d3 03       	ssrf	0x10
	local_start_pll0();
8000638a:	f0 1f 00 12 	mcall	800063d0 <main+0x5c>
		
	INTC_init_interrupts();
8000638e:	f0 1f 00 12 	mcall	800063d4 <main+0x60>
	
	log_init();		
80006392:	f0 1f 00 12 	mcall	800063d8 <main+0x64>
	log("----start debug， yoyo----");	
80006396:	49 2c       	lddpc	r12,800063dc <main+0x68>
80006398:	f0 1f 00 12 	mcall	800063e0 <main+0x6c>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。

	tc_init();	
8000639c:	f0 1f 00 12 	mcall	800063e4 <main+0x70>
			
	xcmp_init();
800063a0:	f0 1f 00 12 	mcall	800063e8 <main+0x74>
	
	app_init();
800063a4:	f0 1f 00 12 	mcall	800063ec <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800063a8:	fe 79 10 00 	mov	r9,-61440
800063ac:	f2 f8 01 60 	ld.w	r8,r9[352]
800063b0:	e2 18 00 02 	andl	r8,0x2,COH
800063b4:	cf c0       	breq	800063ac <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800063b6:	fe 79 10 00 	mov	r9,-61440
800063ba:	f2 f8 01 60 	ld.w	r8,r9[352]
800063be:	e2 18 00 02 	andl	r8,0x2,COH
800063c2:	cf c1       	brne	800063ba <main+0x46>
	local_start_timer();
800063c4:	f0 1f 00 0b 	mcall	800063f0 <main+0x7c>
	
	Enable_global_interrupt();
800063c8:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
800063ca:	f0 1f 00 0b 	mcall	800063f4 <main+0x80>
	return 0;
}
800063ce:	d8 0a       	popm	pc,r12=0
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	47 20       	lddsp	r0,sp[0x1c8]
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	48 b0       	lddpc	r0,80006400 <gpio_enable_module_pin+0x8>
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	62 c8       	ld.w	r8,r1[0x30]
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	cb 90       	breq	80006350 <task_log+0x20>
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	5f bc       	srhi	r12
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	47 ac       	lddsp	r12,sp[0x1e8]
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	40 24       	lddsp	r4,sp[0x8]
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	20 40       	sub	r0,4
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	47 70       	lddsp	r0,sp[0x1dc]
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	5d e0       	*unknown*

800063f8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800063f8:	f8 08 16 05 	lsr	r8,r12,0x5
800063fc:	a9 68       	lsl	r8,0x8
800063fe:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006402:	58 1b       	cp.w	r11,1
80006404:	c0 d0       	breq	8000641e <gpio_enable_module_pin+0x26>
80006406:	c0 63       	brcs	80006412 <gpio_enable_module_pin+0x1a>
80006408:	58 2b       	cp.w	r11,2
8000640a:	c1 00       	breq	8000642a <gpio_enable_module_pin+0x32>
8000640c:	58 3b       	cp.w	r11,3
8000640e:	c1 40       	breq	80006436 <gpio_enable_module_pin+0x3e>
80006410:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006412:	30 19       	mov	r9,1
80006414:	f2 0c 09 49 	lsl	r9,r9,r12
80006418:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000641a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000641c:	c1 28       	rjmp	80006440 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000641e:	30 19       	mov	r9,1
80006420:	f2 0c 09 49 	lsl	r9,r9,r12
80006424:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006426:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006428:	c0 c8       	rjmp	80006440 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000642a:	30 19       	mov	r9,1
8000642c:	f2 0c 09 49 	lsl	r9,r9,r12
80006430:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006432:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006434:	c0 68       	rjmp	80006440 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006436:	30 19       	mov	r9,1
80006438:	f2 0c 09 49 	lsl	r9,r9,r12
8000643c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000643e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006440:	30 19       	mov	r9,1
80006442:	f2 0c 09 4c 	lsl	r12,r9,r12
80006446:	91 2c       	st.w	r8[0x8],r12
80006448:	5e fd       	retal	0
8000644a:	d7 03       	nop

8000644c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000644c:	d4 21       	pushm	r4-r7,lr
8000644e:	18 97       	mov	r7,r12
80006450:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006452:	58 0b       	cp.w	r11,0
80006454:	c0 31       	brne	8000645a <gpio_enable_module+0xe>
80006456:	30 05       	mov	r5,0
80006458:	c0 d8       	rjmp	80006472 <gpio_enable_module+0x26>
8000645a:	30 06       	mov	r6,0
8000645c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000645e:	6e 1b       	ld.w	r11,r7[0x4]
80006460:	6e 0c       	ld.w	r12,r7[0x0]
80006462:	f0 1f 00 06 	mcall	80006478 <gpio_enable_module+0x2c>
80006466:	18 45       	or	r5,r12
		gpiomap++;
80006468:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000646a:	2f f6       	sub	r6,-1
8000646c:	0c 34       	cp.w	r4,r6
8000646e:	fe 9b ff f8 	brhi	8000645e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006472:	0a 9c       	mov	r12,r5
80006474:	d8 22       	popm	r4-r7,pc
80006476:	00 00       	add	r0,r0
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	63 f8       	ld.w	r8,r1[0x7c]

8000647c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000647c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006480:	fe c0 a6 80 	sub	r0,pc,-22912

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006484:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006488:	d5 53       	csrf	0x15
  cp      r0, r1
8000648a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000648c:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006490:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006492:	c0 72       	brcc	800064a0 <idata_load_loop_end>
  cp      r0, r1
80006494:	fe c2 93 64 	sub	r2,pc,-27804

80006498 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006498:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000649a:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000649c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000649e:	cf d3       	brcs	80006498 <idata_load_loop>

800064a0 <idata_load_loop_end>:
  mov     r2, 0
800064a0:	e0 60 0a 48 	mov	r0,2632
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800064a4:	e0 61 41 08 	mov	r1,16648
  cp      r0, r1
  brlo    udata_clear_loop
800064a8:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800064aa:	c0 62       	brcc	800064b6 <udata_clear_loop_end>
800064ac:	30 02       	mov	r2,0
800064ae:	30 03       	mov	r3,0

800064b0 <udata_clear_loop>:
800064b0:	a1 22       	st.d	r0++,r2
800064b2:	02 30       	cp.w	r0,r1
800064b4:	cf e3       	brcs	800064b0 <udata_clear_loop>

800064b6 <udata_clear_loop_end>:
800064b6:	fe cf 01 42 	sub	pc,pc,322
800064ba:	d7 03       	nop

800064bc <free>:
800064bc:	d4 01       	pushm	lr
800064be:	e0 68 0a 44 	mov	r8,2628
800064c2:	18 9b       	mov	r11,r12
800064c4:	70 0c       	ld.w	r12,r8[0x0]
800064c6:	e0 a0 1e 6d 	rcall	8000a1a0 <_free_r>
800064ca:	d8 02       	popm	pc

800064cc <malloc>:
800064cc:	d4 01       	pushm	lr
800064ce:	e0 68 0a 44 	mov	r8,2628
800064d2:	18 9b       	mov	r11,r12
800064d4:	70 0c       	ld.w	r12,r8[0x0]
800064d6:	c0 3c       	rcall	800064dc <_malloc_r>
800064d8:	d8 02       	popm	pc
800064da:	d7 03       	nop

800064dc <_malloc_r>:
800064dc:	d4 31       	pushm	r0-r7,lr
800064de:	f6 c8 ff f5 	sub	r8,r11,-11
800064e2:	18 95       	mov	r5,r12
800064e4:	10 97       	mov	r7,r8
800064e6:	e0 17 ff f8 	andl	r7,0xfff8
800064ea:	59 68       	cp.w	r8,22
800064ec:	f9 b7 08 10 	movls	r7,16
800064f0:	16 37       	cp.w	r7,r11
800064f2:	5f 38       	srlo	r8
800064f4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800064f8:	c0 50       	breq	80006502 <_malloc_r+0x26>
800064fa:	30 c8       	mov	r8,12
800064fc:	99 38       	st.w	r12[0xc],r8
800064fe:	e0 8f 01 fa 	bral	800068f2 <_malloc_r+0x416>
80006502:	fe b0 f5 89 	rcall	80005014 <__malloc_lock>
80006506:	e0 47 01 f7 	cp.w	r7,503
8000650a:	e0 8b 00 1d 	brhi	80006544 <_malloc_r+0x68>
8000650e:	ee 03 16 03 	lsr	r3,r7,0x3
80006512:	e0 68 05 44 	mov	r8,1348
80006516:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000651a:	70 36       	ld.w	r6,r8[0xc]
8000651c:	10 36       	cp.w	r6,r8
8000651e:	c0 61       	brne	8000652a <_malloc_r+0x4e>
80006520:	ec c8 ff f8 	sub	r8,r6,-8
80006524:	70 36       	ld.w	r6,r8[0xc]
80006526:	10 36       	cp.w	r6,r8
80006528:	c0 c0       	breq	80006540 <_malloc_r+0x64>
8000652a:	6c 18       	ld.w	r8,r6[0x4]
8000652c:	e0 18 ff fc 	andl	r8,0xfffc
80006530:	6c 3a       	ld.w	r10,r6[0xc]
80006532:	ec 08 00 09 	add	r9,r6,r8
80006536:	0a 9c       	mov	r12,r5
80006538:	6c 28       	ld.w	r8,r6[0x8]
8000653a:	95 28       	st.w	r10[0x8],r8
8000653c:	91 3a       	st.w	r8[0xc],r10
8000653e:	c4 78       	rjmp	800065cc <_malloc_r+0xf0>
80006540:	2f e3       	sub	r3,-2
80006542:	c4 d8       	rjmp	800065dc <_malloc_r+0x100>
80006544:	ee 03 16 09 	lsr	r3,r7,0x9
80006548:	c0 41       	brne	80006550 <_malloc_r+0x74>
8000654a:	ee 03 16 03 	lsr	r3,r7,0x3
8000654e:	c2 68       	rjmp	8000659a <_malloc_r+0xbe>
80006550:	58 43       	cp.w	r3,4
80006552:	e0 8b 00 06 	brhi	8000655e <_malloc_r+0x82>
80006556:	ee 03 16 06 	lsr	r3,r7,0x6
8000655a:	2c 83       	sub	r3,-56
8000655c:	c1 f8       	rjmp	8000659a <_malloc_r+0xbe>
8000655e:	59 43       	cp.w	r3,20
80006560:	e0 8b 00 04 	brhi	80006568 <_malloc_r+0x8c>
80006564:	2a 53       	sub	r3,-91
80006566:	c1 a8       	rjmp	8000659a <_malloc_r+0xbe>
80006568:	e0 43 00 54 	cp.w	r3,84
8000656c:	e0 8b 00 06 	brhi	80006578 <_malloc_r+0x9c>
80006570:	ee 03 16 0c 	lsr	r3,r7,0xc
80006574:	29 23       	sub	r3,-110
80006576:	c1 28       	rjmp	8000659a <_malloc_r+0xbe>
80006578:	e0 43 01 54 	cp.w	r3,340
8000657c:	e0 8b 00 06 	brhi	80006588 <_malloc_r+0xac>
80006580:	ee 03 16 0f 	lsr	r3,r7,0xf
80006584:	28 93       	sub	r3,-119
80006586:	c0 a8       	rjmp	8000659a <_malloc_r+0xbe>
80006588:	e0 43 05 54 	cp.w	r3,1364
8000658c:	e0 88 00 04 	brls	80006594 <_malloc_r+0xb8>
80006590:	37 e3       	mov	r3,126
80006592:	c0 48       	rjmp	8000659a <_malloc_r+0xbe>
80006594:	ee 03 16 12 	lsr	r3,r7,0x12
80006598:	28 43       	sub	r3,-124
8000659a:	e0 6a 05 44 	mov	r10,1348
8000659e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800065a2:	74 36       	ld.w	r6,r10[0xc]
800065a4:	c1 98       	rjmp	800065d6 <_malloc_r+0xfa>
800065a6:	6c 19       	ld.w	r9,r6[0x4]
800065a8:	e0 19 ff fc 	andl	r9,0xfffc
800065ac:	f2 07 01 0b 	sub	r11,r9,r7
800065b0:	58 fb       	cp.w	r11,15
800065b2:	e0 8a 00 04 	brle	800065ba <_malloc_r+0xde>
800065b6:	20 13       	sub	r3,1
800065b8:	c1 18       	rjmp	800065da <_malloc_r+0xfe>
800065ba:	6c 38       	ld.w	r8,r6[0xc]
800065bc:	58 0b       	cp.w	r11,0
800065be:	c0 b5       	brlt	800065d4 <_malloc_r+0xf8>
800065c0:	6c 2a       	ld.w	r10,r6[0x8]
800065c2:	ec 09 00 09 	add	r9,r6,r9
800065c6:	0a 9c       	mov	r12,r5
800065c8:	91 2a       	st.w	r8[0x8],r10
800065ca:	95 38       	st.w	r10[0xc],r8
800065cc:	72 18       	ld.w	r8,r9[0x4]
800065ce:	a1 a8       	sbr	r8,0x0
800065d0:	93 18       	st.w	r9[0x4],r8
800065d2:	cb c8       	rjmp	8000674a <_malloc_r+0x26e>
800065d4:	10 96       	mov	r6,r8
800065d6:	14 36       	cp.w	r6,r10
800065d8:	ce 71       	brne	800065a6 <_malloc_r+0xca>
800065da:	2f f3       	sub	r3,-1
800065dc:	e0 6a 05 44 	mov	r10,1348
800065e0:	f4 cc ff f8 	sub	r12,r10,-8
800065e4:	78 26       	ld.w	r6,r12[0x8]
800065e6:	18 36       	cp.w	r6,r12
800065e8:	c6 c0       	breq	800066c0 <_malloc_r+0x1e4>
800065ea:	6c 19       	ld.w	r9,r6[0x4]
800065ec:	e0 19 ff fc 	andl	r9,0xfffc
800065f0:	f2 07 01 08 	sub	r8,r9,r7
800065f4:	58 f8       	cp.w	r8,15
800065f6:	e0 89 00 8f 	brgt	80006714 <_malloc_r+0x238>
800065fa:	99 3c       	st.w	r12[0xc],r12
800065fc:	99 2c       	st.w	r12[0x8],r12
800065fe:	58 08       	cp.w	r8,0
80006600:	c0 55       	brlt	8000660a <_malloc_r+0x12e>
80006602:	ec 09 00 09 	add	r9,r6,r9
80006606:	0a 9c       	mov	r12,r5
80006608:	ce 2b       	rjmp	800065cc <_malloc_r+0xf0>
8000660a:	e0 49 01 ff 	cp.w	r9,511
8000660e:	e0 8b 00 13 	brhi	80006634 <_malloc_r+0x158>
80006612:	a3 99       	lsr	r9,0x3
80006614:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006618:	70 2b       	ld.w	r11,r8[0x8]
8000661a:	8d 38       	st.w	r6[0xc],r8
8000661c:	8d 2b       	st.w	r6[0x8],r11
8000661e:	97 36       	st.w	r11[0xc],r6
80006620:	91 26       	st.w	r8[0x8],r6
80006622:	a3 49       	asr	r9,0x2
80006624:	74 18       	ld.w	r8,r10[0x4]
80006626:	30 1b       	mov	r11,1
80006628:	f6 09 09 49 	lsl	r9,r11,r9
8000662c:	f1 e9 10 09 	or	r9,r8,r9
80006630:	95 19       	st.w	r10[0x4],r9
80006632:	c4 78       	rjmp	800066c0 <_malloc_r+0x1e4>
80006634:	f2 0a 16 09 	lsr	r10,r9,0x9
80006638:	58 4a       	cp.w	r10,4
8000663a:	e0 8b 00 07 	brhi	80006648 <_malloc_r+0x16c>
8000663e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006642:	2c 8a       	sub	r10,-56
80006644:	c2 08       	rjmp	80006684 <_malloc_r+0x1a8>
80006646:	d7 03       	nop
80006648:	59 4a       	cp.w	r10,20
8000664a:	e0 8b 00 04 	brhi	80006652 <_malloc_r+0x176>
8000664e:	2a 5a       	sub	r10,-91
80006650:	c1 a8       	rjmp	80006684 <_malloc_r+0x1a8>
80006652:	e0 4a 00 54 	cp.w	r10,84
80006656:	e0 8b 00 06 	brhi	80006662 <_malloc_r+0x186>
8000665a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000665e:	29 2a       	sub	r10,-110
80006660:	c1 28       	rjmp	80006684 <_malloc_r+0x1a8>
80006662:	e0 4a 01 54 	cp.w	r10,340
80006666:	e0 8b 00 06 	brhi	80006672 <_malloc_r+0x196>
8000666a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000666e:	28 9a       	sub	r10,-119
80006670:	c0 a8       	rjmp	80006684 <_malloc_r+0x1a8>
80006672:	e0 4a 05 54 	cp.w	r10,1364
80006676:	e0 88 00 04 	brls	8000667e <_malloc_r+0x1a2>
8000667a:	37 ea       	mov	r10,126
8000667c:	c0 48       	rjmp	80006684 <_malloc_r+0x1a8>
8000667e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006682:	28 4a       	sub	r10,-124
80006684:	e0 6b 05 44 	mov	r11,1348
80006688:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000668c:	68 28       	ld.w	r8,r4[0x8]
8000668e:	08 38       	cp.w	r8,r4
80006690:	c0 e1       	brne	800066ac <_malloc_r+0x1d0>
80006692:	76 19       	ld.w	r9,r11[0x4]
80006694:	a3 4a       	asr	r10,0x2
80006696:	30 1e       	mov	lr,1
80006698:	fc 0a 09 4a 	lsl	r10,lr,r10
8000669c:	f3 ea 10 0a 	or	r10,r9,r10
800066a0:	10 99       	mov	r9,r8
800066a2:	97 1a       	st.w	r11[0x4],r10
800066a4:	c0 a8       	rjmp	800066b8 <_malloc_r+0x1dc>
800066a6:	70 28       	ld.w	r8,r8[0x8]
800066a8:	08 38       	cp.w	r8,r4
800066aa:	c0 60       	breq	800066b6 <_malloc_r+0x1da>
800066ac:	70 1a       	ld.w	r10,r8[0x4]
800066ae:	e0 1a ff fc 	andl	r10,0xfffc
800066b2:	14 39       	cp.w	r9,r10
800066b4:	cf 93       	brcs	800066a6 <_malloc_r+0x1ca>
800066b6:	70 39       	ld.w	r9,r8[0xc]
800066b8:	8d 39       	st.w	r6[0xc],r9
800066ba:	8d 28       	st.w	r6[0x8],r8
800066bc:	91 36       	st.w	r8[0xc],r6
800066be:	93 26       	st.w	r9[0x8],r6
800066c0:	e6 08 14 02 	asr	r8,r3,0x2
800066c4:	30 1b       	mov	r11,1
800066c6:	e0 64 05 44 	mov	r4,1348
800066ca:	f6 08 09 4b 	lsl	r11,r11,r8
800066ce:	68 18       	ld.w	r8,r4[0x4]
800066d0:	10 3b       	cp.w	r11,r8
800066d2:	e0 8b 00 6b 	brhi	800067a8 <_malloc_r+0x2cc>
800066d6:	f7 e8 00 09 	and	r9,r11,r8
800066da:	c0 b1       	brne	800066f0 <_malloc_r+0x214>
800066dc:	e0 13 ff fc 	andl	r3,0xfffc
800066e0:	a1 7b       	lsl	r11,0x1
800066e2:	2f c3       	sub	r3,-4
800066e4:	c0 38       	rjmp	800066ea <_malloc_r+0x20e>
800066e6:	2f c3       	sub	r3,-4
800066e8:	a1 7b       	lsl	r11,0x1
800066ea:	f7 e8 00 09 	and	r9,r11,r8
800066ee:	cf c0       	breq	800066e6 <_malloc_r+0x20a>
800066f0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800066f4:	06 92       	mov	r2,r3
800066f6:	1c 91       	mov	r1,lr
800066f8:	62 36       	ld.w	r6,r1[0xc]
800066fa:	c2 e8       	rjmp	80006756 <_malloc_r+0x27a>
800066fc:	6c 1a       	ld.w	r10,r6[0x4]
800066fe:	e0 1a ff fc 	andl	r10,0xfffc
80006702:	f4 07 01 08 	sub	r8,r10,r7
80006706:	58 f8       	cp.w	r8,15
80006708:	e0 8a 00 15 	brle	80006732 <_malloc_r+0x256>
8000670c:	6c 3a       	ld.w	r10,r6[0xc]
8000670e:	6c 29       	ld.w	r9,r6[0x8]
80006710:	95 29       	st.w	r10[0x8],r9
80006712:	93 3a       	st.w	r9[0xc],r10
80006714:	0e 99       	mov	r9,r7
80006716:	ec 07 00 07 	add	r7,r6,r7
8000671a:	a1 a9       	sbr	r9,0x0
8000671c:	99 37       	st.w	r12[0xc],r7
8000671e:	99 27       	st.w	r12[0x8],r7
80006720:	8d 19       	st.w	r6[0x4],r9
80006722:	ee 08 09 08 	st.w	r7[r8],r8
80006726:	8f 2c       	st.w	r7[0x8],r12
80006728:	8f 3c       	st.w	r7[0xc],r12
8000672a:	a1 a8       	sbr	r8,0x0
8000672c:	0a 9c       	mov	r12,r5
8000672e:	8f 18       	st.w	r7[0x4],r8
80006730:	c0 d8       	rjmp	8000674a <_malloc_r+0x26e>
80006732:	6c 39       	ld.w	r9,r6[0xc]
80006734:	58 08       	cp.w	r8,0
80006736:	c0 f5       	brlt	80006754 <_malloc_r+0x278>
80006738:	ec 0a 00 0a 	add	r10,r6,r10
8000673c:	74 18       	ld.w	r8,r10[0x4]
8000673e:	a1 a8       	sbr	r8,0x0
80006740:	0a 9c       	mov	r12,r5
80006742:	95 18       	st.w	r10[0x4],r8
80006744:	6c 28       	ld.w	r8,r6[0x8]
80006746:	93 28       	st.w	r9[0x8],r8
80006748:	91 39       	st.w	r8[0xc],r9
8000674a:	fe b0 f4 6b 	rcall	80005020 <__malloc_unlock>
8000674e:	ec cc ff f8 	sub	r12,r6,-8
80006752:	d8 32       	popm	r0-r7,pc
80006754:	12 96       	mov	r6,r9
80006756:	02 36       	cp.w	r6,r1
80006758:	cd 21       	brne	800066fc <_malloc_r+0x220>
8000675a:	2f f2       	sub	r2,-1
8000675c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006760:	c0 30       	breq	80006766 <_malloc_r+0x28a>
80006762:	2f 81       	sub	r1,-8
80006764:	cc ab       	rjmp	800066f8 <_malloc_r+0x21c>
80006766:	1c 98       	mov	r8,lr
80006768:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000676c:	c0 81       	brne	8000677c <_malloc_r+0x2a0>
8000676e:	68 19       	ld.w	r9,r4[0x4]
80006770:	f6 08 11 ff 	rsub	r8,r11,-1
80006774:	f3 e8 00 08 	and	r8,r9,r8
80006778:	89 18       	st.w	r4[0x4],r8
8000677a:	c0 78       	rjmp	80006788 <_malloc_r+0x2ac>
8000677c:	f0 c9 00 08 	sub	r9,r8,8
80006780:	20 13       	sub	r3,1
80006782:	70 08       	ld.w	r8,r8[0x0]
80006784:	12 38       	cp.w	r8,r9
80006786:	cf 10       	breq	80006768 <_malloc_r+0x28c>
80006788:	a1 7b       	lsl	r11,0x1
8000678a:	68 18       	ld.w	r8,r4[0x4]
8000678c:	10 3b       	cp.w	r11,r8
8000678e:	e0 8b 00 0d 	brhi	800067a8 <_malloc_r+0x2cc>
80006792:	58 0b       	cp.w	r11,0
80006794:	c0 a0       	breq	800067a8 <_malloc_r+0x2cc>
80006796:	04 93       	mov	r3,r2
80006798:	c0 38       	rjmp	8000679e <_malloc_r+0x2c2>
8000679a:	2f c3       	sub	r3,-4
8000679c:	a1 7b       	lsl	r11,0x1
8000679e:	f7 e8 00 09 	and	r9,r11,r8
800067a2:	ca 71       	brne	800066f0 <_malloc_r+0x214>
800067a4:	cf bb       	rjmp	8000679a <_malloc_r+0x2be>
800067a6:	d7 03       	nop
800067a8:	68 23       	ld.w	r3,r4[0x8]
800067aa:	66 12       	ld.w	r2,r3[0x4]
800067ac:	e0 12 ff fc 	andl	r2,0xfffc
800067b0:	0e 32       	cp.w	r2,r7
800067b2:	5f 39       	srlo	r9
800067b4:	e4 07 01 08 	sub	r8,r2,r7
800067b8:	58 f8       	cp.w	r8,15
800067ba:	5f aa       	srle	r10
800067bc:	f5 e9 10 09 	or	r9,r10,r9
800067c0:	e0 80 00 9a 	breq	800068f4 <_malloc_r+0x418>
800067c4:	e0 68 0d 50 	mov	r8,3408
800067c8:	70 01       	ld.w	r1,r8[0x0]
800067ca:	e0 68 09 50 	mov	r8,2384
800067ce:	2f 01       	sub	r1,-16
800067d0:	70 08       	ld.w	r8,r8[0x0]
800067d2:	0e 01       	add	r1,r7
800067d4:	5b f8       	cp.w	r8,-1
800067d6:	c0 40       	breq	800067de <_malloc_r+0x302>
800067d8:	28 11       	sub	r1,-127
800067da:	e0 11 ff 80 	andl	r1,0xff80
800067de:	02 9b       	mov	r11,r1
800067e0:	0a 9c       	mov	r12,r5
800067e2:	e0 a0 02 a5 	rcall	80006d2c <_sbrk_r>
800067e6:	18 96       	mov	r6,r12
800067e8:	5b fc       	cp.w	r12,-1
800067ea:	c7 50       	breq	800068d4 <_malloc_r+0x3f8>
800067ec:	e6 02 00 08 	add	r8,r3,r2
800067f0:	10 3c       	cp.w	r12,r8
800067f2:	c0 32       	brcc	800067f8 <_malloc_r+0x31c>
800067f4:	08 33       	cp.w	r3,r4
800067f6:	c6 f1       	brne	800068d4 <_malloc_r+0x3f8>
800067f8:	e0 6a 0d 54 	mov	r10,3412
800067fc:	74 09       	ld.w	r9,r10[0x0]
800067fe:	e2 09 00 09 	add	r9,r1,r9
80006802:	95 09       	st.w	r10[0x0],r9
80006804:	10 36       	cp.w	r6,r8
80006806:	c0 a1       	brne	8000681a <_malloc_r+0x33e>
80006808:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000680c:	c0 71       	brne	8000681a <_malloc_r+0x33e>
8000680e:	e2 02 00 02 	add	r2,r1,r2
80006812:	68 28       	ld.w	r8,r4[0x8]
80006814:	a1 a2       	sbr	r2,0x0
80006816:	91 12       	st.w	r8[0x4],r2
80006818:	c4 f8       	rjmp	800068b6 <_malloc_r+0x3da>
8000681a:	e0 6a 09 50 	mov	r10,2384
8000681e:	74 0b       	ld.w	r11,r10[0x0]
80006820:	5b fb       	cp.w	r11,-1
80006822:	c0 31       	brne	80006828 <_malloc_r+0x34c>
80006824:	95 06       	st.w	r10[0x0],r6
80006826:	c0 78       	rjmp	80006834 <_malloc_r+0x358>
80006828:	ec 09 00 09 	add	r9,r6,r9
8000682c:	e0 6a 0d 54 	mov	r10,3412
80006830:	10 19       	sub	r9,r8
80006832:	95 09       	st.w	r10[0x0],r9
80006834:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006838:	f0 09 11 08 	rsub	r9,r8,8
8000683c:	58 08       	cp.w	r8,0
8000683e:	f2 08 17 10 	movne	r8,r9
80006842:	ed d8 e1 06 	addne	r6,r6,r8
80006846:	28 08       	sub	r8,-128
80006848:	ec 01 00 01 	add	r1,r6,r1
8000684c:	0a 9c       	mov	r12,r5
8000684e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006852:	f0 01 01 01 	sub	r1,r8,r1
80006856:	02 9b       	mov	r11,r1
80006858:	e0 a0 02 6a 	rcall	80006d2c <_sbrk_r>
8000685c:	e0 68 0d 54 	mov	r8,3412
80006860:	5b fc       	cp.w	r12,-1
80006862:	ec 0c 17 00 	moveq	r12,r6
80006866:	f9 b1 00 00 	moveq	r1,0
8000686a:	70 09       	ld.w	r9,r8[0x0]
8000686c:	0c 1c       	sub	r12,r6
8000686e:	89 26       	st.w	r4[0x8],r6
80006870:	02 0c       	add	r12,r1
80006872:	12 01       	add	r1,r9
80006874:	a1 ac       	sbr	r12,0x0
80006876:	91 01       	st.w	r8[0x0],r1
80006878:	8d 1c       	st.w	r6[0x4],r12
8000687a:	08 33       	cp.w	r3,r4
8000687c:	c1 d0       	breq	800068b6 <_malloc_r+0x3da>
8000687e:	58 f2       	cp.w	r2,15
80006880:	e0 8b 00 05 	brhi	8000688a <_malloc_r+0x3ae>
80006884:	30 18       	mov	r8,1
80006886:	8d 18       	st.w	r6[0x4],r8
80006888:	c2 68       	rjmp	800068d4 <_malloc_r+0x3f8>
8000688a:	30 59       	mov	r9,5
8000688c:	20 c2       	sub	r2,12
8000688e:	e0 12 ff f8 	andl	r2,0xfff8
80006892:	e6 02 00 08 	add	r8,r3,r2
80006896:	91 29       	st.w	r8[0x8],r9
80006898:	91 19       	st.w	r8[0x4],r9
8000689a:	66 18       	ld.w	r8,r3[0x4]
8000689c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068a0:	e5 e8 10 08 	or	r8,r2,r8
800068a4:	87 18       	st.w	r3[0x4],r8
800068a6:	58 f2       	cp.w	r2,15
800068a8:	e0 88 00 07 	brls	800068b6 <_malloc_r+0x3da>
800068ac:	e6 cb ff f8 	sub	r11,r3,-8
800068b0:	0a 9c       	mov	r12,r5
800068b2:	e0 a0 1c 77 	rcall	8000a1a0 <_free_r>
800068b6:	e0 69 0d 4c 	mov	r9,3404
800068ba:	72 0a       	ld.w	r10,r9[0x0]
800068bc:	e0 68 0d 54 	mov	r8,3412
800068c0:	70 08       	ld.w	r8,r8[0x0]
800068c2:	14 38       	cp.w	r8,r10
800068c4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800068c8:	e0 69 0d 48 	mov	r9,3400
800068cc:	72 0a       	ld.w	r10,r9[0x0]
800068ce:	14 38       	cp.w	r8,r10
800068d0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800068d4:	68 28       	ld.w	r8,r4[0x8]
800068d6:	70 18       	ld.w	r8,r8[0x4]
800068d8:	e0 18 ff fc 	andl	r8,0xfffc
800068dc:	0e 38       	cp.w	r8,r7
800068de:	5f 39       	srlo	r9
800068e0:	0e 18       	sub	r8,r7
800068e2:	58 f8       	cp.w	r8,15
800068e4:	5f aa       	srle	r10
800068e6:	f5 e9 10 09 	or	r9,r10,r9
800068ea:	c0 50       	breq	800068f4 <_malloc_r+0x418>
800068ec:	0a 9c       	mov	r12,r5
800068ee:	fe b0 f3 99 	rcall	80005020 <__malloc_unlock>
800068f2:	d8 3a       	popm	r0-r7,pc,r12=0
800068f4:	68 26       	ld.w	r6,r4[0x8]
800068f6:	a1 a8       	sbr	r8,0x0
800068f8:	0e 99       	mov	r9,r7
800068fa:	a1 a9       	sbr	r9,0x0
800068fc:	8d 19       	st.w	r6[0x4],r9
800068fe:	ec 07 00 07 	add	r7,r6,r7
80006902:	0a 9c       	mov	r12,r5
80006904:	89 27       	st.w	r4[0x8],r7
80006906:	8f 18       	st.w	r7[0x4],r8
80006908:	fe b0 f3 8c 	rcall	80005020 <__malloc_unlock>
8000690c:	ec cc ff f8 	sub	r12,r6,-8
80006910:	d8 32       	popm	r0-r7,pc
80006912:	d7 03       	nop

80006914 <memcpy>:
80006914:	58 8a       	cp.w	r10,8
80006916:	c2 f5       	brlt	80006974 <memcpy+0x60>
80006918:	f9 eb 10 09 	or	r9,r12,r11
8000691c:	e2 19 00 03 	andl	r9,0x3,COH
80006920:	e0 81 00 97 	brne	80006a4e <memcpy+0x13a>
80006924:	e0 4a 00 20 	cp.w	r10,32
80006928:	c3 b4       	brge	8000699e <memcpy+0x8a>
8000692a:	f4 08 14 02 	asr	r8,r10,0x2
8000692e:	f0 09 11 08 	rsub	r9,r8,8
80006932:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006936:	76 69       	ld.w	r9,r11[0x18]
80006938:	99 69       	st.w	r12[0x18],r9
8000693a:	76 59       	ld.w	r9,r11[0x14]
8000693c:	99 59       	st.w	r12[0x14],r9
8000693e:	76 49       	ld.w	r9,r11[0x10]
80006940:	99 49       	st.w	r12[0x10],r9
80006942:	76 39       	ld.w	r9,r11[0xc]
80006944:	99 39       	st.w	r12[0xc],r9
80006946:	76 29       	ld.w	r9,r11[0x8]
80006948:	99 29       	st.w	r12[0x8],r9
8000694a:	76 19       	ld.w	r9,r11[0x4]
8000694c:	99 19       	st.w	r12[0x4],r9
8000694e:	76 09       	ld.w	r9,r11[0x0]
80006950:	99 09       	st.w	r12[0x0],r9
80006952:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006956:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000695a:	e0 1a 00 03 	andl	r10,0x3
8000695e:	f4 0a 11 04 	rsub	r10,r10,4
80006962:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006966:	17 a9       	ld.ub	r9,r11[0x2]
80006968:	b0 a9       	st.b	r8[0x2],r9
8000696a:	17 99       	ld.ub	r9,r11[0x1]
8000696c:	b0 99       	st.b	r8[0x1],r9
8000696e:	17 89       	ld.ub	r9,r11[0x0]
80006970:	b0 89       	st.b	r8[0x0],r9
80006972:	5e fc       	retal	r12
80006974:	f4 0a 11 09 	rsub	r10,r10,9
80006978:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000697c:	17 f9       	ld.ub	r9,r11[0x7]
8000697e:	b8 f9       	st.b	r12[0x7],r9
80006980:	17 e9       	ld.ub	r9,r11[0x6]
80006982:	b8 e9       	st.b	r12[0x6],r9
80006984:	17 d9       	ld.ub	r9,r11[0x5]
80006986:	b8 d9       	st.b	r12[0x5],r9
80006988:	17 c9       	ld.ub	r9,r11[0x4]
8000698a:	b8 c9       	st.b	r12[0x4],r9
8000698c:	17 b9       	ld.ub	r9,r11[0x3]
8000698e:	b8 b9       	st.b	r12[0x3],r9
80006990:	17 a9       	ld.ub	r9,r11[0x2]
80006992:	b8 a9       	st.b	r12[0x2],r9
80006994:	17 99       	ld.ub	r9,r11[0x1]
80006996:	b8 99       	st.b	r12[0x1],r9
80006998:	17 89       	ld.ub	r9,r11[0x0]
8000699a:	b8 89       	st.b	r12[0x0],r9
8000699c:	5e fc       	retal	r12
8000699e:	eb cd 40 c0 	pushm	r6-r7,lr
800069a2:	18 99       	mov	r9,r12
800069a4:	22 0a       	sub	r10,32
800069a6:	b7 07       	ld.d	r6,r11++
800069a8:	b3 26       	st.d	r9++,r6
800069aa:	b7 07       	ld.d	r6,r11++
800069ac:	b3 26       	st.d	r9++,r6
800069ae:	b7 07       	ld.d	r6,r11++
800069b0:	b3 26       	st.d	r9++,r6
800069b2:	b7 07       	ld.d	r6,r11++
800069b4:	b3 26       	st.d	r9++,r6
800069b6:	22 0a       	sub	r10,32
800069b8:	cf 74       	brge	800069a6 <memcpy+0x92>
800069ba:	2f 0a       	sub	r10,-16
800069bc:	c0 65       	brlt	800069c8 <memcpy+0xb4>
800069be:	b7 07       	ld.d	r6,r11++
800069c0:	b3 26       	st.d	r9++,r6
800069c2:	b7 07       	ld.d	r6,r11++
800069c4:	b3 26       	st.d	r9++,r6
800069c6:	21 0a       	sub	r10,16
800069c8:	5c 3a       	neg	r10
800069ca:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800069ce:	d7 03       	nop
800069d0:	d7 03       	nop
800069d2:	f7 36 00 0e 	ld.ub	r6,r11[14]
800069d6:	f3 66 00 0e 	st.b	r9[14],r6
800069da:	f7 36 00 0d 	ld.ub	r6,r11[13]
800069de:	f3 66 00 0d 	st.b	r9[13],r6
800069e2:	f7 36 00 0c 	ld.ub	r6,r11[12]
800069e6:	f3 66 00 0c 	st.b	r9[12],r6
800069ea:	f7 36 00 0b 	ld.ub	r6,r11[11]
800069ee:	f3 66 00 0b 	st.b	r9[11],r6
800069f2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800069f6:	f3 66 00 0a 	st.b	r9[10],r6
800069fa:	f7 36 00 09 	ld.ub	r6,r11[9]
800069fe:	f3 66 00 09 	st.b	r9[9],r6
80006a02:	f7 36 00 08 	ld.ub	r6,r11[8]
80006a06:	f3 66 00 08 	st.b	r9[8],r6
80006a0a:	f7 36 00 07 	ld.ub	r6,r11[7]
80006a0e:	f3 66 00 07 	st.b	r9[7],r6
80006a12:	f7 36 00 06 	ld.ub	r6,r11[6]
80006a16:	f3 66 00 06 	st.b	r9[6],r6
80006a1a:	f7 36 00 05 	ld.ub	r6,r11[5]
80006a1e:	f3 66 00 05 	st.b	r9[5],r6
80006a22:	f7 36 00 04 	ld.ub	r6,r11[4]
80006a26:	f3 66 00 04 	st.b	r9[4],r6
80006a2a:	f7 36 00 03 	ld.ub	r6,r11[3]
80006a2e:	f3 66 00 03 	st.b	r9[3],r6
80006a32:	f7 36 00 02 	ld.ub	r6,r11[2]
80006a36:	f3 66 00 02 	st.b	r9[2],r6
80006a3a:	f7 36 00 01 	ld.ub	r6,r11[1]
80006a3e:	f3 66 00 01 	st.b	r9[1],r6
80006a42:	f7 36 00 00 	ld.ub	r6,r11[0]
80006a46:	f3 66 00 00 	st.b	r9[0],r6
80006a4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a4e:	20 1a       	sub	r10,1
80006a50:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006a54:	f8 0a 0b 09 	st.b	r12[r10],r9
80006a58:	cf b1       	brne	80006a4e <memcpy+0x13a>
80006a5a:	5e fc       	retal	r12

80006a5c <memset>:
80006a5c:	18 98       	mov	r8,r12
80006a5e:	c0 38       	rjmp	80006a64 <memset+0x8>
80006a60:	10 cb       	st.b	r8++,r11
80006a62:	20 1a       	sub	r10,1
80006a64:	58 0a       	cp.w	r10,0
80006a66:	cf d1       	brne	80006a60 <memset+0x4>
80006a68:	5e fc       	retal	r12
80006a6a:	d7 03       	nop

80006a6c <_realloc_r>:
80006a6c:	d4 31       	pushm	r0-r7,lr
80006a6e:	20 1d       	sub	sp,4
80006a70:	16 94       	mov	r4,r11
80006a72:	18 92       	mov	r2,r12
80006a74:	14 9b       	mov	r11,r10
80006a76:	58 04       	cp.w	r4,0
80006a78:	c0 51       	brne	80006a82 <_realloc_r+0x16>
80006a7a:	fe b0 fd 31 	rcall	800064dc <_malloc_r>
80006a7e:	18 95       	mov	r5,r12
80006a80:	c5 39       	rjmp	80006d26 <_realloc_r+0x2ba>
80006a82:	50 0a       	stdsp	sp[0x0],r10
80006a84:	fe b0 f2 c8 	rcall	80005014 <__malloc_lock>
80006a88:	40 0b       	lddsp	r11,sp[0x0]
80006a8a:	f6 c8 ff f5 	sub	r8,r11,-11
80006a8e:	e8 c1 00 08 	sub	r1,r4,8
80006a92:	10 96       	mov	r6,r8
80006a94:	62 1c       	ld.w	r12,r1[0x4]
80006a96:	e0 16 ff f8 	andl	r6,0xfff8
80006a9a:	59 68       	cp.w	r8,22
80006a9c:	f9 b6 08 10 	movls	r6,16
80006aa0:	16 36       	cp.w	r6,r11
80006aa2:	5f 38       	srlo	r8
80006aa4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006aa8:	c0 50       	breq	80006ab2 <_realloc_r+0x46>
80006aaa:	30 c8       	mov	r8,12
80006aac:	30 05       	mov	r5,0
80006aae:	85 38       	st.w	r2[0xc],r8
80006ab0:	c3 b9       	rjmp	80006d26 <_realloc_r+0x2ba>
80006ab2:	18 90       	mov	r0,r12
80006ab4:	e0 10 ff fc 	andl	r0,0xfffc
80006ab8:	0c 30       	cp.w	r0,r6
80006aba:	e0 84 01 0b 	brge	80006cd0 <_realloc_r+0x264>
80006abe:	e0 68 05 44 	mov	r8,1348
80006ac2:	e2 00 00 09 	add	r9,r1,r0
80006ac6:	70 25       	ld.w	r5,r8[0x8]
80006ac8:	0a 39       	cp.w	r9,r5
80006aca:	c0 90       	breq	80006adc <_realloc_r+0x70>
80006acc:	72 1a       	ld.w	r10,r9[0x4]
80006ace:	a1 ca       	cbr	r10,0x0
80006ad0:	f2 0a 00 0a 	add	r10,r9,r10
80006ad4:	74 1a       	ld.w	r10,r10[0x4]
80006ad6:	ed ba 00 00 	bld	r10,0x0
80006ada:	c2 20       	breq	80006b1e <_realloc_r+0xb2>
80006adc:	72 1a       	ld.w	r10,r9[0x4]
80006ade:	e0 1a ff fc 	andl	r10,0xfffc
80006ae2:	f4 00 00 03 	add	r3,r10,r0
80006ae6:	0a 39       	cp.w	r9,r5
80006ae8:	c1 31       	brne	80006b0e <_realloc_r+0xa2>
80006aea:	ec c7 ff f0 	sub	r7,r6,-16
80006aee:	0e 33       	cp.w	r3,r7
80006af0:	c1 95       	brlt	80006b22 <_realloc_r+0xb6>
80006af2:	e2 06 00 09 	add	r9,r1,r6
80006af6:	0c 13       	sub	r3,r6
80006af8:	a1 a3       	sbr	r3,0x0
80006afa:	93 13       	st.w	r9[0x4],r3
80006afc:	91 29       	st.w	r8[0x8],r9
80006afe:	04 9c       	mov	r12,r2
80006b00:	62 18       	ld.w	r8,r1[0x4]
80006b02:	08 95       	mov	r5,r4
80006b04:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b08:	10 46       	or	r6,r8
80006b0a:	83 16       	st.w	r1[0x4],r6
80006b0c:	c0 b9       	rjmp	80006d22 <_realloc_r+0x2b6>
80006b0e:	0c 33       	cp.w	r3,r6
80006b10:	c0 95       	brlt	80006b22 <_realloc_r+0xb6>
80006b12:	72 28       	ld.w	r8,r9[0x8]
80006b14:	02 97       	mov	r7,r1
80006b16:	72 39       	ld.w	r9,r9[0xc]
80006b18:	93 28       	st.w	r9[0x8],r8
80006b1a:	91 39       	st.w	r8[0xc],r9
80006b1c:	cd c8       	rjmp	80006cd4 <_realloc_r+0x268>
80006b1e:	30 0a       	mov	r10,0
80006b20:	14 99       	mov	r9,r10
80006b22:	ed bc 00 00 	bld	r12,0x0
80006b26:	e0 80 00 95 	breq	80006c50 <_realloc_r+0x1e4>
80006b2a:	62 07       	ld.w	r7,r1[0x0]
80006b2c:	e2 07 01 07 	sub	r7,r1,r7
80006b30:	6e 1c       	ld.w	r12,r7[0x4]
80006b32:	e0 1c ff fc 	andl	r12,0xfffc
80006b36:	58 09       	cp.w	r9,0
80006b38:	c5 60       	breq	80006be4 <_realloc_r+0x178>
80006b3a:	f8 00 00 03 	add	r3,r12,r0
80006b3e:	0a 39       	cp.w	r9,r5
80006b40:	c4 81       	brne	80006bd0 <_realloc_r+0x164>
80006b42:	14 03       	add	r3,r10
80006b44:	ec c9 ff f0 	sub	r9,r6,-16
80006b48:	12 33       	cp.w	r3,r9
80006b4a:	c4 d5       	brlt	80006be4 <_realloc_r+0x178>
80006b4c:	6e 3a       	ld.w	r10,r7[0xc]
80006b4e:	6e 29       	ld.w	r9,r7[0x8]
80006b50:	95 29       	st.w	r10[0x8],r9
80006b52:	93 3a       	st.w	r9[0xc],r10
80006b54:	ee c5 ff f8 	sub	r5,r7,-8
80006b58:	e0 ca 00 04 	sub	r10,r0,4
80006b5c:	e0 4a 00 24 	cp.w	r10,36
80006b60:	e0 8b 00 25 	brhi	80006baa <_realloc_r+0x13e>
80006b64:	0a 99       	mov	r9,r5
80006b66:	59 3a       	cp.w	r10,19
80006b68:	e0 88 00 1a 	brls	80006b9c <_realloc_r+0x130>
80006b6c:	09 09       	ld.w	r9,r4++
80006b6e:	8b 09       	st.w	r5[0x0],r9
80006b70:	09 09       	ld.w	r9,r4++
80006b72:	8f 39       	st.w	r7[0xc],r9
80006b74:	ee c9 ff f0 	sub	r9,r7,-16
80006b78:	59 ba       	cp.w	r10,27
80006b7a:	e0 88 00 11 	brls	80006b9c <_realloc_r+0x130>
80006b7e:	09 0b       	ld.w	r11,r4++
80006b80:	93 0b       	st.w	r9[0x0],r11
80006b82:	09 09       	ld.w	r9,r4++
80006b84:	8f 59       	st.w	r7[0x14],r9
80006b86:	ee c9 ff e8 	sub	r9,r7,-24
80006b8a:	e0 4a 00 24 	cp.w	r10,36
80006b8e:	c0 71       	brne	80006b9c <_realloc_r+0x130>
80006b90:	09 0a       	ld.w	r10,r4++
80006b92:	93 0a       	st.w	r9[0x0],r10
80006b94:	ee c9 ff e0 	sub	r9,r7,-32
80006b98:	09 0a       	ld.w	r10,r4++
80006b9a:	8f 7a       	st.w	r7[0x1c],r10
80006b9c:	09 0a       	ld.w	r10,r4++
80006b9e:	12 aa       	st.w	r9++,r10
80006ba0:	68 0a       	ld.w	r10,r4[0x0]
80006ba2:	93 0a       	st.w	r9[0x0],r10
80006ba4:	68 1a       	ld.w	r10,r4[0x4]
80006ba6:	93 1a       	st.w	r9[0x4],r10
80006ba8:	c0 78       	rjmp	80006bb6 <_realloc_r+0x14a>
80006baa:	50 08       	stdsp	sp[0x0],r8
80006bac:	08 9b       	mov	r11,r4
80006bae:	0a 9c       	mov	r12,r5
80006bb0:	e0 a0 1d 9b 	rcall	8000a6e6 <memmove>
80006bb4:	40 08       	lddsp	r8,sp[0x0]
80006bb6:	ee 06 00 09 	add	r9,r7,r6
80006bba:	0c 13       	sub	r3,r6
80006bbc:	a1 a3       	sbr	r3,0x0
80006bbe:	93 13       	st.w	r9[0x4],r3
80006bc0:	91 29       	st.w	r8[0x8],r9
80006bc2:	04 9c       	mov	r12,r2
80006bc4:	6e 18       	ld.w	r8,r7[0x4]
80006bc6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006bca:	10 46       	or	r6,r8
80006bcc:	8f 16       	st.w	r7[0x4],r6
80006bce:	ca a8       	rjmp	80006d22 <_realloc_r+0x2b6>
80006bd0:	14 03       	add	r3,r10
80006bd2:	0c 33       	cp.w	r3,r6
80006bd4:	c0 85       	brlt	80006be4 <_realloc_r+0x178>
80006bd6:	72 28       	ld.w	r8,r9[0x8]
80006bd8:	72 39       	ld.w	r9,r9[0xc]
80006bda:	93 28       	st.w	r9[0x8],r8
80006bdc:	91 39       	st.w	r8[0xc],r9
80006bde:	6e 28       	ld.w	r8,r7[0x8]
80006be0:	6e 39       	ld.w	r9,r7[0xc]
80006be2:	c0 78       	rjmp	80006bf0 <_realloc_r+0x184>
80006be4:	f8 00 00 03 	add	r3,r12,r0
80006be8:	0c 33       	cp.w	r3,r6
80006bea:	c3 35       	brlt	80006c50 <_realloc_r+0x1e4>
80006bec:	6e 39       	ld.w	r9,r7[0xc]
80006bee:	6e 28       	ld.w	r8,r7[0x8]
80006bf0:	93 28       	st.w	r9[0x8],r8
80006bf2:	91 39       	st.w	r8[0xc],r9
80006bf4:	e0 ca 00 04 	sub	r10,r0,4
80006bf8:	ee cc ff f8 	sub	r12,r7,-8
80006bfc:	e0 4a 00 24 	cp.w	r10,36
80006c00:	e0 8b 00 24 	brhi	80006c48 <_realloc_r+0x1dc>
80006c04:	59 3a       	cp.w	r10,19
80006c06:	e0 88 00 1a 	brls	80006c3a <_realloc_r+0x1ce>
80006c0a:	09 08       	ld.w	r8,r4++
80006c0c:	99 08       	st.w	r12[0x0],r8
80006c0e:	09 08       	ld.w	r8,r4++
80006c10:	8f 38       	st.w	r7[0xc],r8
80006c12:	ee cc ff f0 	sub	r12,r7,-16
80006c16:	59 ba       	cp.w	r10,27
80006c18:	e0 88 00 11 	brls	80006c3a <_realloc_r+0x1ce>
80006c1c:	09 08       	ld.w	r8,r4++
80006c1e:	99 08       	st.w	r12[0x0],r8
80006c20:	09 08       	ld.w	r8,r4++
80006c22:	8f 58       	st.w	r7[0x14],r8
80006c24:	ee cc ff e8 	sub	r12,r7,-24
80006c28:	e0 4a 00 24 	cp.w	r10,36
80006c2c:	c0 71       	brne	80006c3a <_realloc_r+0x1ce>
80006c2e:	09 08       	ld.w	r8,r4++
80006c30:	99 08       	st.w	r12[0x0],r8
80006c32:	ee cc ff e0 	sub	r12,r7,-32
80006c36:	09 08       	ld.w	r8,r4++
80006c38:	8f 78       	st.w	r7[0x1c],r8
80006c3a:	09 08       	ld.w	r8,r4++
80006c3c:	18 a8       	st.w	r12++,r8
80006c3e:	68 08       	ld.w	r8,r4[0x0]
80006c40:	99 08       	st.w	r12[0x0],r8
80006c42:	68 18       	ld.w	r8,r4[0x4]
80006c44:	99 18       	st.w	r12[0x4],r8
80006c46:	c4 78       	rjmp	80006cd4 <_realloc_r+0x268>
80006c48:	08 9b       	mov	r11,r4
80006c4a:	e0 a0 1d 4e 	rcall	8000a6e6 <memmove>
80006c4e:	c4 38       	rjmp	80006cd4 <_realloc_r+0x268>
80006c50:	04 9c       	mov	r12,r2
80006c52:	fe b0 fc 45 	rcall	800064dc <_malloc_r>
80006c56:	18 95       	mov	r5,r12
80006c58:	c3 a0       	breq	80006ccc <_realloc_r+0x260>
80006c5a:	62 18       	ld.w	r8,r1[0x4]
80006c5c:	f8 c9 00 08 	sub	r9,r12,8
80006c60:	a1 c8       	cbr	r8,0x0
80006c62:	e2 08 00 08 	add	r8,r1,r8
80006c66:	10 39       	cp.w	r9,r8
80006c68:	c0 71       	brne	80006c76 <_realloc_r+0x20a>
80006c6a:	72 13       	ld.w	r3,r9[0x4]
80006c6c:	02 97       	mov	r7,r1
80006c6e:	e0 13 ff fc 	andl	r3,0xfffc
80006c72:	00 03       	add	r3,r0
80006c74:	c3 08       	rjmp	80006cd4 <_realloc_r+0x268>
80006c76:	e0 ca 00 04 	sub	r10,r0,4
80006c7a:	e0 4a 00 24 	cp.w	r10,36
80006c7e:	e0 8b 00 20 	brhi	80006cbe <_realloc_r+0x252>
80006c82:	08 99       	mov	r9,r4
80006c84:	18 98       	mov	r8,r12
80006c86:	59 3a       	cp.w	r10,19
80006c88:	e0 88 00 14 	brls	80006cb0 <_realloc_r+0x244>
80006c8c:	13 0b       	ld.w	r11,r9++
80006c8e:	10 ab       	st.w	r8++,r11
80006c90:	13 0b       	ld.w	r11,r9++
80006c92:	10 ab       	st.w	r8++,r11
80006c94:	59 ba       	cp.w	r10,27
80006c96:	e0 88 00 0d 	brls	80006cb0 <_realloc_r+0x244>
80006c9a:	13 0b       	ld.w	r11,r9++
80006c9c:	10 ab       	st.w	r8++,r11
80006c9e:	13 0b       	ld.w	r11,r9++
80006ca0:	10 ab       	st.w	r8++,r11
80006ca2:	e0 4a 00 24 	cp.w	r10,36
80006ca6:	c0 51       	brne	80006cb0 <_realloc_r+0x244>
80006ca8:	13 0a       	ld.w	r10,r9++
80006caa:	10 aa       	st.w	r8++,r10
80006cac:	13 0a       	ld.w	r10,r9++
80006cae:	10 aa       	st.w	r8++,r10
80006cb0:	13 0a       	ld.w	r10,r9++
80006cb2:	10 aa       	st.w	r8++,r10
80006cb4:	72 0a       	ld.w	r10,r9[0x0]
80006cb6:	91 0a       	st.w	r8[0x0],r10
80006cb8:	72 19       	ld.w	r9,r9[0x4]
80006cba:	91 19       	st.w	r8[0x4],r9
80006cbc:	c0 48       	rjmp	80006cc4 <_realloc_r+0x258>
80006cbe:	08 9b       	mov	r11,r4
80006cc0:	e0 a0 1d 13 	rcall	8000a6e6 <memmove>
80006cc4:	08 9b       	mov	r11,r4
80006cc6:	04 9c       	mov	r12,r2
80006cc8:	e0 a0 1a 6c 	rcall	8000a1a0 <_free_r>
80006ccc:	04 9c       	mov	r12,r2
80006cce:	c2 a8       	rjmp	80006d22 <_realloc_r+0x2b6>
80006cd0:	00 93       	mov	r3,r0
80006cd2:	02 97       	mov	r7,r1
80006cd4:	e6 06 01 09 	sub	r9,r3,r6
80006cd8:	6e 18       	ld.w	r8,r7[0x4]
80006cda:	58 f9       	cp.w	r9,15
80006cdc:	e0 88 00 16 	brls	80006d08 <_realloc_r+0x29c>
80006ce0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ce4:	ed e8 10 08 	or	r8,r6,r8
80006ce8:	8f 18       	st.w	r7[0x4],r8
80006cea:	12 98       	mov	r8,r9
80006cec:	a1 a8       	sbr	r8,0x0
80006cee:	ee 06 00 0b 	add	r11,r7,r6
80006cf2:	f6 09 00 09 	add	r9,r11,r9
80006cf6:	97 18       	st.w	r11[0x4],r8
80006cf8:	72 18       	ld.w	r8,r9[0x4]
80006cfa:	a1 a8       	sbr	r8,0x0
80006cfc:	2f 8b       	sub	r11,-8
80006cfe:	93 18       	st.w	r9[0x4],r8
80006d00:	04 9c       	mov	r12,r2
80006d02:	e0 a0 1a 4f 	rcall	8000a1a0 <_free_r>
80006d06:	c0 b8       	rjmp	80006d1c <_realloc_r+0x2b0>
80006d08:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d0c:	e7 e8 10 08 	or	r8,r3,r8
80006d10:	8f 18       	st.w	r7[0x4],r8
80006d12:	ee 03 00 03 	add	r3,r7,r3
80006d16:	66 18       	ld.w	r8,r3[0x4]
80006d18:	a1 a8       	sbr	r8,0x0
80006d1a:	87 18       	st.w	r3[0x4],r8
80006d1c:	04 9c       	mov	r12,r2
80006d1e:	ee c5 ff f8 	sub	r5,r7,-8
80006d22:	fe b0 f1 7f 	rcall	80005020 <__malloc_unlock>
80006d26:	0a 9c       	mov	r12,r5
80006d28:	2f fd       	sub	sp,-4
80006d2a:	d8 32       	popm	r0-r7,pc

80006d2c <_sbrk_r>:
80006d2c:	d4 21       	pushm	r4-r7,lr
80006d2e:	30 08       	mov	r8,0
80006d30:	18 97       	mov	r7,r12
80006d32:	e0 66 41 00 	mov	r6,16640
80006d36:	16 9c       	mov	r12,r11
80006d38:	8d 08       	st.w	r6[0x0],r8
80006d3a:	c9 1c       	rcall	80006e5c <_sbrk>
80006d3c:	5b fc       	cp.w	r12,-1
80006d3e:	c0 51       	brne	80006d48 <_sbrk_r+0x1c>
80006d40:	6c 08       	ld.w	r8,r6[0x0]
80006d42:	58 08       	cp.w	r8,0
80006d44:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006d48:	d8 22       	popm	r4-r7,pc
80006d4a:	d7 03       	nop

80006d4c <sprintf>:
80006d4c:	d4 01       	pushm	lr
80006d4e:	21 7d       	sub	sp,92
80006d50:	e0 68 ff ff 	mov	r8,65535
80006d54:	ea 18 7f ff 	orh	r8,0x7fff
80006d58:	50 58       	stdsp	sp[0x14],r8
80006d5a:	50 28       	stdsp	sp[0x8],r8
80006d5c:	e0 68 02 08 	mov	r8,520
80006d60:	ba 68       	st.h	sp[0xc],r8
80006d62:	3f f8       	mov	r8,-1
80006d64:	ba 78       	st.h	sp[0xe],r8
80006d66:	e0 68 0a 44 	mov	r8,2628
80006d6a:	50 4c       	stdsp	sp[0x10],r12
80006d6c:	16 9a       	mov	r10,r11
80006d6e:	50 0c       	stdsp	sp[0x0],r12
80006d70:	fa c9 ff a0 	sub	r9,sp,-96
80006d74:	70 0c       	ld.w	r12,r8[0x0]
80006d76:	1a 9b       	mov	r11,sp
80006d78:	e0 a0 02 26 	rcall	800071c4 <_vfprintf_r>
80006d7c:	30 09       	mov	r9,0
80006d7e:	40 08       	lddsp	r8,sp[0x0]
80006d80:	b0 89       	st.b	r8[0x0],r9
80006d82:	2e 9d       	sub	sp,-92
80006d84:	d8 02       	popm	pc
80006d86:	d7 03       	nop

80006d88 <strlen>:
80006d88:	30 09       	mov	r9,0
80006d8a:	18 98       	mov	r8,r12
80006d8c:	c0 28       	rjmp	80006d90 <strlen+0x8>
80006d8e:	2f f8       	sub	r8,-1
80006d90:	11 8a       	ld.ub	r10,r8[0x0]
80006d92:	f2 0a 18 00 	cp.b	r10,r9
80006d96:	cf c1       	brne	80006d8e <strlen+0x6>
80006d98:	f0 0c 01 0c 	sub	r12,r8,r12
80006d9c:	5e fc       	retal	r12
80006d9e:	d7 03       	nop

80006da0 <strncpy>:
80006da0:	30 08       	mov	r8,0
80006da2:	10 3a       	cp.w	r10,r8
80006da4:	5e 0c       	reteq	r12
80006da6:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006daa:	f8 08 0b 09 	st.b	r12[r8],r9
80006dae:	2f f8       	sub	r8,-1
80006db0:	58 09       	cp.w	r9,0
80006db2:	cf 81       	brne	80006da2 <strncpy+0x2>
80006db4:	10 3a       	cp.w	r10,r8
80006db6:	5e 0c       	reteq	r12
80006db8:	f8 08 0b 09 	st.b	r12[r8],r9
80006dbc:	2f f8       	sub	r8,-1
80006dbe:	cf bb       	rjmp	80006db4 <strncpy+0x14>

80006dc0 <_close>:
80006dc0:	30 28       	mov	r8,2
80006dc2:	d6 73       	breakpoint
80006dc4:	3f fc       	mov	r12,-1
80006dc6:	35 8b       	mov	r11,88
80006dc8:	58 0c       	cp.w	r12,0
80006dca:	5e 4c       	retge	r12
80006dcc:	e0 6a 41 00 	mov	r10,16640
80006dd0:	95 0b       	st.w	r10[0x0],r11
80006dd2:	5e fc       	retal	r12

80006dd4 <_lseek>:
80006dd4:	30 58       	mov	r8,5
80006dd6:	d6 73       	breakpoint
80006dd8:	3f fc       	mov	r12,-1
80006dda:	35 8b       	mov	r11,88
80006ddc:	58 0c       	cp.w	r12,0
80006dde:	5e 4c       	retge	r12
80006de0:	e0 6a 41 00 	mov	r10,16640
80006de4:	95 0b       	st.w	r10[0x0],r11
80006de6:	5e fc       	retal	r12

80006de8 <isatty>:
80006de8:	30 b8       	mov	r8,11
80006dea:	d6 73       	breakpoint
80006dec:	3f fc       	mov	r12,-1
80006dee:	35 8b       	mov	r11,88
80006df0:	58 0c       	cp.w	r12,0
80006df2:	5e 4c       	retge	r12
80006df4:	e0 6a 41 00 	mov	r10,16640
80006df8:	95 0b       	st.w	r10[0x0],r11
80006dfa:	5e fc       	retal	r12

80006dfc <_fstat_host>:
80006dfc:	30 98       	mov	r8,9
80006dfe:	d6 73       	breakpoint
80006e00:	3f fc       	mov	r12,-1
80006e02:	35 8b       	mov	r11,88
80006e04:	58 0c       	cp.w	r12,0
80006e06:	5e 4c       	retge	r12
80006e08:	e0 6a 41 00 	mov	r10,16640
80006e0c:	95 0b       	st.w	r10[0x0],r11
80006e0e:	5e fc       	retal	r12

80006e10 <_fstat>:
80006e10:	d4 21       	pushm	r4-r7,lr
80006e12:	21 0d       	sub	sp,64
80006e14:	16 97       	mov	r7,r11
80006e16:	1a 9b       	mov	r11,sp
80006e18:	cf 2f       	rcall	80006dfc <_fstat_host>
80006e1a:	c0 34       	brge	80006e20 <_fstat+0x10>
80006e1c:	3f fc       	mov	r12,-1
80006e1e:	c1 c8       	rjmp	80006e56 <_fstat+0x46>
80006e20:	40 08       	lddsp	r8,sp[0x0]
80006e22:	ae 08       	st.h	r7[0x0],r8
80006e24:	40 18       	lddsp	r8,sp[0x4]
80006e26:	ae 18       	st.h	r7[0x2],r8
80006e28:	40 28       	lddsp	r8,sp[0x8]
80006e2a:	8f 18       	st.w	r7[0x4],r8
80006e2c:	40 38       	lddsp	r8,sp[0xc]
80006e2e:	ae 48       	st.h	r7[0x8],r8
80006e30:	40 48       	lddsp	r8,sp[0x10]
80006e32:	ae 58       	st.h	r7[0xa],r8
80006e34:	40 58       	lddsp	r8,sp[0x14]
80006e36:	ae 68       	st.h	r7[0xc],r8
80006e38:	40 68       	lddsp	r8,sp[0x18]
80006e3a:	ae 78       	st.h	r7[0xe],r8
80006e3c:	40 88       	lddsp	r8,sp[0x20]
80006e3e:	8f 48       	st.w	r7[0x10],r8
80006e40:	40 a8       	lddsp	r8,sp[0x28]
80006e42:	8f b8       	st.w	r7[0x2c],r8
80006e44:	40 c8       	lddsp	r8,sp[0x30]
80006e46:	8f c8       	st.w	r7[0x30],r8
80006e48:	40 d8       	lddsp	r8,sp[0x34]
80006e4a:	8f 58       	st.w	r7[0x14],r8
80006e4c:	40 e8       	lddsp	r8,sp[0x38]
80006e4e:	30 0c       	mov	r12,0
80006e50:	8f 78       	st.w	r7[0x1c],r8
80006e52:	40 f8       	lddsp	r8,sp[0x3c]
80006e54:	8f 98       	st.w	r7[0x24],r8
80006e56:	2f 0d       	sub	sp,-64
80006e58:	d8 22       	popm	r4-r7,pc
80006e5a:	d7 03       	nop

80006e5c <_sbrk>:
80006e5c:	d4 01       	pushm	lr
80006e5e:	e0 68 0d 7c 	mov	r8,3452
80006e62:	70 09       	ld.w	r9,r8[0x0]
80006e64:	58 09       	cp.w	r9,0
80006e66:	c0 41       	brne	80006e6e <_sbrk+0x12>
80006e68:	e0 69 41 08 	mov	r9,16648
80006e6c:	91 09       	st.w	r8[0x0],r9
80006e6e:	e0 69 0d 7c 	mov	r9,3452
80006e72:	e0 7a 70 00 	mov	r10,94208
80006e76:	72 08       	ld.w	r8,r9[0x0]
80006e78:	f0 0c 00 0c 	add	r12,r8,r12
80006e7c:	14 3c       	cp.w	r12,r10
80006e7e:	e0 8b 00 04 	brhi	80006e86 <_sbrk+0x2a>
80006e82:	93 0c       	st.w	r9[0x0],r12
80006e84:	c0 68       	rjmp	80006e90 <_sbrk+0x34>
80006e86:	e0 a0 18 15 	rcall	80009eb0 <__errno>
80006e8a:	30 c8       	mov	r8,12
80006e8c:	99 08       	st.w	r12[0x0],r8
80006e8e:	3f f8       	mov	r8,-1
80006e90:	10 9c       	mov	r12,r8
80006e92:	d8 02       	popm	pc

80006e94 <get_arg>:
80006e94:	d4 31       	pushm	r0-r7,lr
80006e96:	20 8d       	sub	sp,32
80006e98:	fa c4 ff bc 	sub	r4,sp,-68
80006e9c:	50 4b       	stdsp	sp[0x10],r11
80006e9e:	68 2e       	ld.w	lr,r4[0x8]
80006ea0:	50 58       	stdsp	sp[0x14],r8
80006ea2:	12 96       	mov	r6,r9
80006ea4:	7c 0b       	ld.w	r11,lr[0x0]
80006ea6:	70 05       	ld.w	r5,r8[0x0]
80006ea8:	50 6e       	stdsp	sp[0x18],lr
80006eaa:	58 0b       	cp.w	r11,0
80006eac:	f4 0b 17 00 	moveq	r11,r10
80006eb0:	68 03       	ld.w	r3,r4[0x0]
80006eb2:	68 11       	ld.w	r1,r4[0x4]
80006eb4:	40 49       	lddsp	r9,sp[0x10]
80006eb6:	30 08       	mov	r8,0
80006eb8:	c2 89       	rjmp	80007108 <get_arg+0x274>
80006eba:	2f fb       	sub	r11,-1
80006ebc:	32 5c       	mov	r12,37
80006ebe:	17 8a       	ld.ub	r10,r11[0x0]
80006ec0:	f8 0a 18 00 	cp.b	r10,r12
80006ec4:	5f 1e       	srne	lr
80006ec6:	f0 0a 18 00 	cp.b	r10,r8
80006eca:	5f 1c       	srne	r12
80006ecc:	fd ec 00 0c 	and	r12,lr,r12
80006ed0:	f0 0c 18 00 	cp.b	r12,r8
80006ed4:	cf 31       	brne	80006eba <get_arg+0x26>
80006ed6:	58 0a       	cp.w	r10,0
80006ed8:	e0 80 01 25 	breq	80007122 <get_arg+0x28e>
80006edc:	30 0c       	mov	r12,0
80006ede:	3f fa       	mov	r10,-1
80006ee0:	18 90       	mov	r0,r12
80006ee2:	50 3a       	stdsp	sp[0xc],r10
80006ee4:	18 94       	mov	r4,r12
80006ee6:	18 92       	mov	r2,r12
80006ee8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006eec:	16 97       	mov	r7,r11
80006eee:	50 7c       	stdsp	sp[0x1c],r12
80006ef0:	fe cc a0 70 	sub	r12,pc,-24464
80006ef4:	0f 3a       	ld.ub	r10,r7++
80006ef6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006efa:	40 7c       	lddsp	r12,sp[0x1c]
80006efc:	1c 0c       	add	r12,lr
80006efe:	fe ce a1 46 	sub	lr,pc,-24250
80006f02:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006f06:	20 1e       	sub	lr,1
80006f08:	50 0e       	stdsp	sp[0x0],lr
80006f0a:	fe ce a1 be 	sub	lr,pc,-24130
80006f0e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006f12:	50 7c       	stdsp	sp[0x1c],r12
80006f14:	40 0c       	lddsp	r12,sp[0x0]
80006f16:	58 7c       	cp.w	r12,7
80006f18:	e0 8b 00 f1 	brhi	800070fa <get_arg+0x266>
80006f1c:	fe ce a3 70 	sub	lr,pc,-23696
80006f20:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006f24:	36 8b       	mov	r11,104
80006f26:	f6 0a 18 00 	cp.b	r10,r11
80006f2a:	e0 80 00 e8 	breq	800070fa <get_arg+0x266>
80006f2e:	37 1b       	mov	r11,113
80006f30:	f6 0a 18 00 	cp.b	r10,r11
80006f34:	c0 70       	breq	80006f42 <get_arg+0xae>
80006f36:	34 cb       	mov	r11,76
80006f38:	f6 0a 18 00 	cp.b	r10,r11
80006f3c:	c0 51       	brne	80006f46 <get_arg+0xb2>
80006f3e:	a3 b4       	sbr	r4,0x3
80006f40:	cd d8       	rjmp	800070fa <get_arg+0x266>
80006f42:	a5 b4       	sbr	r4,0x5
80006f44:	cd b8       	rjmp	800070fa <get_arg+0x266>
80006f46:	08 9a       	mov	r10,r4
80006f48:	0e 9b       	mov	r11,r7
80006f4a:	a5 aa       	sbr	r10,0x4
80006f4c:	17 3c       	ld.ub	r12,r11++
80006f4e:	a5 b4       	sbr	r4,0x5
80006f50:	36 ce       	mov	lr,108
80006f52:	fc 0c 18 00 	cp.b	r12,lr
80006f56:	e0 80 00 d3 	breq	800070fc <get_arg+0x268>
80006f5a:	14 94       	mov	r4,r10
80006f5c:	cc f8       	rjmp	800070fa <get_arg+0x266>
80006f5e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006f62:	36 7c       	mov	r12,103
80006f64:	f8 0a 18 00 	cp.b	r10,r12
80006f68:	e0 8b 00 27 	brhi	80006fb6 <get_arg+0x122>
80006f6c:	36 5b       	mov	r11,101
80006f6e:	f6 0a 18 00 	cp.b	r10,r11
80006f72:	c4 82       	brcc	80007002 <get_arg+0x16e>
80006f74:	34 fb       	mov	r11,79
80006f76:	f6 0a 18 00 	cp.b	r10,r11
80006f7a:	c4 80       	breq	8000700a <get_arg+0x176>
80006f7c:	e0 8b 00 0c 	brhi	80006f94 <get_arg+0x100>
80006f80:	34 5b       	mov	r11,69
80006f82:	f6 0a 18 00 	cp.b	r10,r11
80006f86:	c3 e0       	breq	80007002 <get_arg+0x16e>
80006f88:	34 7b       	mov	r11,71
80006f8a:	f6 0a 18 00 	cp.b	r10,r11
80006f8e:	c3 a0       	breq	80007002 <get_arg+0x16e>
80006f90:	34 4b       	mov	r11,68
80006f92:	c0 88       	rjmp	80006fa2 <get_arg+0x10e>
80006f94:	35 8b       	mov	r11,88
80006f96:	f6 0a 18 00 	cp.b	r10,r11
80006f9a:	c2 c0       	breq	80006ff2 <get_arg+0x15e>
80006f9c:	e0 8b 00 07 	brhi	80006faa <get_arg+0x116>
80006fa0:	35 5b       	mov	r11,85
80006fa2:	f6 0a 18 00 	cp.b	r10,r11
80006fa6:	c3 51       	brne	80007010 <get_arg+0x17c>
80006fa8:	c3 18       	rjmp	8000700a <get_arg+0x176>
80006faa:	36 3b       	mov	r11,99
80006fac:	f6 0a 18 00 	cp.b	r10,r11
80006fb0:	c2 f0       	breq	8000700e <get_arg+0x17a>
80006fb2:	36 4b       	mov	r11,100
80006fb4:	c0 e8       	rjmp	80006fd0 <get_arg+0x13c>
80006fb6:	37 0b       	mov	r11,112
80006fb8:	f6 0a 18 00 	cp.b	r10,r11
80006fbc:	c2 50       	breq	80007006 <get_arg+0x172>
80006fbe:	e0 8b 00 0d 	brhi	80006fd8 <get_arg+0x144>
80006fc2:	36 eb       	mov	r11,110
80006fc4:	f6 0a 18 00 	cp.b	r10,r11
80006fc8:	c1 f0       	breq	80007006 <get_arg+0x172>
80006fca:	e0 8b 00 14 	brhi	80006ff2 <get_arg+0x15e>
80006fce:	36 9b       	mov	r11,105
80006fd0:	f6 0a 18 00 	cp.b	r10,r11
80006fd4:	c1 e1       	brne	80007010 <get_arg+0x17c>
80006fd6:	c0 e8       	rjmp	80006ff2 <get_arg+0x15e>
80006fd8:	37 5b       	mov	r11,117
80006fda:	f6 0a 18 00 	cp.b	r10,r11
80006fde:	c0 a0       	breq	80006ff2 <get_arg+0x15e>
80006fe0:	37 8b       	mov	r11,120
80006fe2:	f6 0a 18 00 	cp.b	r10,r11
80006fe6:	c0 60       	breq	80006ff2 <get_arg+0x15e>
80006fe8:	37 3b       	mov	r11,115
80006fea:	f6 0a 18 00 	cp.b	r10,r11
80006fee:	c1 11       	brne	80007010 <get_arg+0x17c>
80006ff0:	c0 b8       	rjmp	80007006 <get_arg+0x172>
80006ff2:	ed b4 00 04 	bld	r4,0x4
80006ff6:	c0 a0       	breq	8000700a <get_arg+0x176>
80006ff8:	ed b4 00 05 	bld	r4,0x5
80006ffc:	c0 91       	brne	8000700e <get_arg+0x17a>
80006ffe:	30 20       	mov	r0,2
80007000:	c0 88       	rjmp	80007010 <get_arg+0x17c>
80007002:	30 40       	mov	r0,4
80007004:	c0 68       	rjmp	80007010 <get_arg+0x17c>
80007006:	30 30       	mov	r0,3
80007008:	c0 48       	rjmp	80007010 <get_arg+0x17c>
8000700a:	30 10       	mov	r0,1
8000700c:	c0 28       	rjmp	80007010 <get_arg+0x17c>
8000700e:	30 00       	mov	r0,0
80007010:	40 3b       	lddsp	r11,sp[0xc]
80007012:	5b fb       	cp.w	r11,-1
80007014:	c0 40       	breq	8000701c <get_arg+0x188>
80007016:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000701a:	c7 08       	rjmp	800070fa <get_arg+0x266>
8000701c:	58 60       	cp.w	r0,6
8000701e:	e0 8b 00 6e 	brhi	800070fa <get_arg+0x266>
80007022:	6c 0a       	ld.w	r10,r6[0x0]
80007024:	ea cc ff ff 	sub	r12,r5,-1
80007028:	fe ce a4 5c 	sub	lr,pc,-23460
8000702c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007030:	f4 cb ff f8 	sub	r11,r10,-8
80007034:	8d 0b       	st.w	r6[0x0],r11
80007036:	f4 ea 00 00 	ld.d	r10,r10[0]
8000703a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000703e:	c0 f8       	rjmp	8000705c <get_arg+0x1c8>
80007040:	f4 cb ff fc 	sub	r11,r10,-4
80007044:	8d 0b       	st.w	r6[0x0],r11
80007046:	74 0a       	ld.w	r10,r10[0x0]
80007048:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000704c:	c0 88       	rjmp	8000705c <get_arg+0x1c8>
8000704e:	f4 cb ff f8 	sub	r11,r10,-8
80007052:	8d 0b       	st.w	r6[0x0],r11
80007054:	f4 ea 00 00 	ld.d	r10,r10[0]
80007058:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000705c:	0e 9b       	mov	r11,r7
8000705e:	18 95       	mov	r5,r12
80007060:	c4 e8       	rjmp	800070fc <get_arg+0x268>
80007062:	62 0a       	ld.w	r10,r1[0x0]
80007064:	5b fa       	cp.w	r10,-1
80007066:	c0 b1       	brne	8000707c <get_arg+0x1e8>
80007068:	50 19       	stdsp	sp[0x4],r9
8000706a:	50 28       	stdsp	sp[0x8],r8
8000706c:	e0 6a 00 80 	mov	r10,128
80007070:	30 0b       	mov	r11,0
80007072:	02 9c       	mov	r12,r1
80007074:	fe b0 fc f4 	rcall	80006a5c <memset>
80007078:	40 28       	lddsp	r8,sp[0x8]
8000707a:	40 19       	lddsp	r9,sp[0x4]
8000707c:	e4 cc 00 01 	sub	r12,r2,1
80007080:	0e 9b       	mov	r11,r7
80007082:	50 3c       	stdsp	sp[0xc],r12
80007084:	f2 0c 0c 49 	max	r9,r9,r12
80007088:	c3 a8       	rjmp	800070fc <get_arg+0x268>
8000708a:	62 0a       	ld.w	r10,r1[0x0]
8000708c:	5b fa       	cp.w	r10,-1
8000708e:	c0 b1       	brne	800070a4 <get_arg+0x210>
80007090:	50 19       	stdsp	sp[0x4],r9
80007092:	50 28       	stdsp	sp[0x8],r8
80007094:	e0 6a 00 80 	mov	r10,128
80007098:	30 0b       	mov	r11,0
8000709a:	02 9c       	mov	r12,r1
8000709c:	fe b0 fc e0 	rcall	80006a5c <memset>
800070a0:	40 28       	lddsp	r8,sp[0x8]
800070a2:	40 19       	lddsp	r9,sp[0x4]
800070a4:	20 12       	sub	r2,1
800070a6:	30 0a       	mov	r10,0
800070a8:	0e 9b       	mov	r11,r7
800070aa:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800070ae:	f2 02 0c 49 	max	r9,r9,r2
800070b2:	c2 58       	rjmp	800070fc <get_arg+0x268>
800070b4:	16 97       	mov	r7,r11
800070b6:	6c 0a       	ld.w	r10,r6[0x0]
800070b8:	f4 cb ff fc 	sub	r11,r10,-4
800070bc:	8d 0b       	st.w	r6[0x0],r11
800070be:	74 0a       	ld.w	r10,r10[0x0]
800070c0:	0e 9b       	mov	r11,r7
800070c2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800070c6:	2f f5       	sub	r5,-1
800070c8:	c1 a8       	rjmp	800070fc <get_arg+0x268>
800070ca:	f4 c2 00 30 	sub	r2,r10,48
800070ce:	c0 68       	rjmp	800070da <get_arg+0x246>
800070d0:	e4 02 00 22 	add	r2,r2,r2<<0x2
800070d4:	2f f7       	sub	r7,-1
800070d6:	f4 02 00 12 	add	r2,r10,r2<<0x1
800070da:	0f 8a       	ld.ub	r10,r7[0x0]
800070dc:	58 0a       	cp.w	r10,0
800070de:	c0 e0       	breq	800070fa <get_arg+0x266>
800070e0:	23 0a       	sub	r10,48
800070e2:	58 9a       	cp.w	r10,9
800070e4:	fe 98 ff f6 	brls	800070d0 <get_arg+0x23c>
800070e8:	c0 98       	rjmp	800070fa <get_arg+0x266>
800070ea:	2f f7       	sub	r7,-1
800070ec:	0f 8a       	ld.ub	r10,r7[0x0]
800070ee:	58 0a       	cp.w	r10,0
800070f0:	c0 50       	breq	800070fa <get_arg+0x266>
800070f2:	23 0a       	sub	r10,48
800070f4:	58 9a       	cp.w	r10,9
800070f6:	fe 98 ff fa 	brls	800070ea <get_arg+0x256>
800070fa:	0e 9b       	mov	r11,r7
800070fc:	40 7c       	lddsp	r12,sp[0x1c]
800070fe:	30 ba       	mov	r10,11
80007100:	f4 0c 18 00 	cp.b	r12,r10
80007104:	fe 91 fe f2 	brne	80006ee8 <get_arg+0x54>
80007108:	40 42       	lddsp	r2,sp[0x10]
8000710a:	17 8c       	ld.ub	r12,r11[0x0]
8000710c:	0a 32       	cp.w	r2,r5
8000710e:	5f 4a       	srge	r10
80007110:	f0 0c 18 00 	cp.b	r12,r8
80007114:	5f 1c       	srne	r12
80007116:	f9 ea 00 0a 	and	r10,r12,r10
8000711a:	f0 0a 18 00 	cp.b	r10,r8
8000711e:	fe 91 fe cf 	brne	80006ebc <get_arg+0x28>
80007122:	30 08       	mov	r8,0
80007124:	40 4e       	lddsp	lr,sp[0x10]
80007126:	17 8a       	ld.ub	r10,r11[0x0]
80007128:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000712c:	f0 0a 18 00 	cp.b	r10,r8
80007130:	fc 09 17 10 	movne	r9,lr
80007134:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007138:	06 9e       	mov	lr,r3
8000713a:	c2 a8       	rjmp	8000718e <get_arg+0x2fa>
8000713c:	62 0a       	ld.w	r10,r1[0x0]
8000713e:	58 3a       	cp.w	r10,3
80007140:	c1 e0       	breq	8000717c <get_arg+0x2e8>
80007142:	e0 89 00 07 	brgt	80007150 <get_arg+0x2bc>
80007146:	58 1a       	cp.w	r10,1
80007148:	c1 a0       	breq	8000717c <get_arg+0x2e8>
8000714a:	58 2a       	cp.w	r10,2
8000714c:	c1 81       	brne	8000717c <get_arg+0x2e8>
8000714e:	c0 58       	rjmp	80007158 <get_arg+0x2c4>
80007150:	58 5a       	cp.w	r10,5
80007152:	c0 c0       	breq	8000716a <get_arg+0x2d6>
80007154:	c0 b5       	brlt	8000716a <get_arg+0x2d6>
80007156:	c1 38       	rjmp	8000717c <get_arg+0x2e8>
80007158:	6c 0a       	ld.w	r10,r6[0x0]
8000715a:	f4 cc ff f8 	sub	r12,r10,-8
8000715e:	8d 0c       	st.w	r6[0x0],r12
80007160:	f4 e2 00 00 	ld.d	r2,r10[0]
80007164:	f0 e3 00 00 	st.d	r8[0],r2
80007168:	c1 08       	rjmp	80007188 <get_arg+0x2f4>
8000716a:	6c 0a       	ld.w	r10,r6[0x0]
8000716c:	f4 cc ff f8 	sub	r12,r10,-8
80007170:	8d 0c       	st.w	r6[0x0],r12
80007172:	f4 e2 00 00 	ld.d	r2,r10[0]
80007176:	f0 e3 00 00 	st.d	r8[0],r2
8000717a:	c0 78       	rjmp	80007188 <get_arg+0x2f4>
8000717c:	6c 0a       	ld.w	r10,r6[0x0]
8000717e:	f4 cc ff fc 	sub	r12,r10,-4
80007182:	8d 0c       	st.w	r6[0x0],r12
80007184:	74 0a       	ld.w	r10,r10[0x0]
80007186:	91 0a       	st.w	r8[0x0],r10
80007188:	2f f5       	sub	r5,-1
8000718a:	2f 88       	sub	r8,-8
8000718c:	2f c1       	sub	r1,-4
8000718e:	12 35       	cp.w	r5,r9
80007190:	fe 9a ff d6 	brle	8000713c <get_arg+0x2a8>
80007194:	1c 93       	mov	r3,lr
80007196:	40 52       	lddsp	r2,sp[0x14]
80007198:	40 6e       	lddsp	lr,sp[0x18]
8000719a:	85 05       	st.w	r2[0x0],r5
8000719c:	9d 0b       	st.w	lr[0x0],r11
8000719e:	40 4b       	lddsp	r11,sp[0x10]
800071a0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800071a4:	2f 8d       	sub	sp,-32
800071a6:	d8 32       	popm	r0-r7,pc

800071a8 <__sprint_r>:
800071a8:	d4 21       	pushm	r4-r7,lr
800071aa:	14 97       	mov	r7,r10
800071ac:	74 28       	ld.w	r8,r10[0x8]
800071ae:	58 08       	cp.w	r8,0
800071b0:	c0 41       	brne	800071b8 <__sprint_r+0x10>
800071b2:	95 18       	st.w	r10[0x4],r8
800071b4:	10 9c       	mov	r12,r8
800071b6:	d8 22       	popm	r4-r7,pc
800071b8:	e0 a0 18 ba 	rcall	8000a32c <__sfvwrite_r>
800071bc:	30 08       	mov	r8,0
800071be:	8f 18       	st.w	r7[0x4],r8
800071c0:	8f 28       	st.w	r7[0x8],r8
800071c2:	d8 22       	popm	r4-r7,pc

800071c4 <_vfprintf_r>:
800071c4:	d4 31       	pushm	r0-r7,lr
800071c6:	fa cd 06 bc 	sub	sp,sp,1724
800071ca:	51 09       	stdsp	sp[0x40],r9
800071cc:	16 91       	mov	r1,r11
800071ce:	14 97       	mov	r7,r10
800071d0:	18 95       	mov	r5,r12
800071d2:	e0 a0 1a 1d 	rcall	8000a60c <_localeconv_r>
800071d6:	78 0c       	ld.w	r12,r12[0x0]
800071d8:	50 cc       	stdsp	sp[0x30],r12
800071da:	58 05       	cp.w	r5,0
800071dc:	c0 70       	breq	800071ea <_vfprintf_r+0x26>
800071de:	6a 68       	ld.w	r8,r5[0x18]
800071e0:	58 08       	cp.w	r8,0
800071e2:	c0 41       	brne	800071ea <_vfprintf_r+0x26>
800071e4:	0a 9c       	mov	r12,r5
800071e6:	e0 a0 17 43 	rcall	8000a06c <__sinit>
800071ea:	fe c8 a2 5a 	sub	r8,pc,-23974
800071ee:	10 31       	cp.w	r1,r8
800071f0:	c0 31       	brne	800071f6 <_vfprintf_r+0x32>
800071f2:	6a 01       	ld.w	r1,r5[0x0]
800071f4:	c0 c8       	rjmp	8000720c <_vfprintf_r+0x48>
800071f6:	fe c8 a2 46 	sub	r8,pc,-23994
800071fa:	10 31       	cp.w	r1,r8
800071fc:	c0 31       	brne	80007202 <_vfprintf_r+0x3e>
800071fe:	6a 11       	ld.w	r1,r5[0x4]
80007200:	c0 68       	rjmp	8000720c <_vfprintf_r+0x48>
80007202:	fe c8 a2 32 	sub	r8,pc,-24014
80007206:	10 31       	cp.w	r1,r8
80007208:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000720c:	82 68       	ld.sh	r8,r1[0xc]
8000720e:	ed b8 00 03 	bld	r8,0x3
80007212:	c0 41       	brne	8000721a <_vfprintf_r+0x56>
80007214:	62 48       	ld.w	r8,r1[0x10]
80007216:	58 08       	cp.w	r8,0
80007218:	c0 71       	brne	80007226 <_vfprintf_r+0x62>
8000721a:	02 9b       	mov	r11,r1
8000721c:	0a 9c       	mov	r12,r5
8000721e:	e0 a0 0f 5d 	rcall	800090d8 <__swsetup_r>
80007222:	e0 81 0f 54 	brne	800090ca <_vfprintf_r+0x1f06>
80007226:	82 68       	ld.sh	r8,r1[0xc]
80007228:	10 99       	mov	r9,r8
8000722a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000722e:	58 a9       	cp.w	r9,10
80007230:	c3 c1       	brne	800072a8 <_vfprintf_r+0xe4>
80007232:	82 79       	ld.sh	r9,r1[0xe]
80007234:	30 0a       	mov	r10,0
80007236:	f4 09 19 00 	cp.h	r9,r10
8000723a:	c3 75       	brlt	800072a8 <_vfprintf_r+0xe4>
8000723c:	a1 d8       	cbr	r8,0x1
8000723e:	fb 58 05 d0 	st.h	sp[1488],r8
80007242:	62 88       	ld.w	r8,r1[0x20]
80007244:	fb 48 05 e4 	st.w	sp[1508],r8
80007248:	62 a8       	ld.w	r8,r1[0x28]
8000724a:	fb 48 05 ec 	st.w	sp[1516],r8
8000724e:	fa c8 ff bc 	sub	r8,sp,-68
80007252:	fb 48 05 d4 	st.w	sp[1492],r8
80007256:	fb 48 05 c4 	st.w	sp[1476],r8
8000725a:	e0 68 04 00 	mov	r8,1024
8000725e:	fb 48 05 d8 	st.w	sp[1496],r8
80007262:	fb 48 05 cc 	st.w	sp[1484],r8
80007266:	30 08       	mov	r8,0
80007268:	fb 59 05 d2 	st.h	sp[1490],r9
8000726c:	0e 9a       	mov	r10,r7
8000726e:	41 09       	lddsp	r9,sp[0x40]
80007270:	fa c7 fa 3c 	sub	r7,sp,-1476
80007274:	fb 48 05 dc 	st.w	sp[1500],r8
80007278:	0a 9c       	mov	r12,r5
8000727a:	0e 9b       	mov	r11,r7
8000727c:	ca 4f       	rcall	800071c4 <_vfprintf_r>
8000727e:	50 bc       	stdsp	sp[0x2c],r12
80007280:	c0 95       	brlt	80007292 <_vfprintf_r+0xce>
80007282:	0e 9b       	mov	r11,r7
80007284:	0a 9c       	mov	r12,r5
80007286:	e0 a0 16 1b 	rcall	80009ebc <_fflush_r>
8000728a:	40 be       	lddsp	lr,sp[0x2c]
8000728c:	f9 be 01 ff 	movne	lr,-1
80007290:	50 be       	stdsp	sp[0x2c],lr
80007292:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007296:	ed b8 00 06 	bld	r8,0x6
8000729a:	e0 81 0f 1a 	brne	800090ce <_vfprintf_r+0x1f0a>
8000729e:	82 68       	ld.sh	r8,r1[0xc]
800072a0:	a7 a8       	sbr	r8,0x6
800072a2:	a2 68       	st.h	r1[0xc],r8
800072a4:	e0 8f 0f 15 	bral	800090ce <_vfprintf_r+0x1f0a>
800072a8:	30 08       	mov	r8,0
800072aa:	fb 48 06 b4 	st.w	sp[1716],r8
800072ae:	fb 48 06 90 	st.w	sp[1680],r8
800072b2:	fb 48 06 8c 	st.w	sp[1676],r8
800072b6:	fb 48 06 b0 	st.w	sp[1712],r8
800072ba:	30 08       	mov	r8,0
800072bc:	30 09       	mov	r9,0
800072be:	50 a7       	stdsp	sp[0x28],r7
800072c0:	50 78       	stdsp	sp[0x1c],r8
800072c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800072c6:	3f f8       	mov	r8,-1
800072c8:	50 59       	stdsp	sp[0x14],r9
800072ca:	fb 43 06 88 	st.w	sp[1672],r3
800072ce:	fb 48 05 44 	st.w	sp[1348],r8
800072d2:	12 9c       	mov	r12,r9
800072d4:	50 69       	stdsp	sp[0x18],r9
800072d6:	50 d9       	stdsp	sp[0x34],r9
800072d8:	50 e9       	stdsp	sp[0x38],r9
800072da:	50 b9       	stdsp	sp[0x2c],r9
800072dc:	12 97       	mov	r7,r9
800072de:	0a 94       	mov	r4,r5
800072e0:	40 a2       	lddsp	r2,sp[0x28]
800072e2:	32 5a       	mov	r10,37
800072e4:	30 08       	mov	r8,0
800072e6:	c0 28       	rjmp	800072ea <_vfprintf_r+0x126>
800072e8:	2f f2       	sub	r2,-1
800072ea:	05 89       	ld.ub	r9,r2[0x0]
800072ec:	f0 09 18 00 	cp.b	r9,r8
800072f0:	5f 1b       	srne	r11
800072f2:	f4 09 18 00 	cp.b	r9,r10
800072f6:	5f 19       	srne	r9
800072f8:	f3 eb 00 0b 	and	r11,r9,r11
800072fc:	f0 0b 18 00 	cp.b	r11,r8
80007300:	cf 41       	brne	800072e8 <_vfprintf_r+0x124>
80007302:	40 ab       	lddsp	r11,sp[0x28]
80007304:	e4 0b 01 06 	sub	r6,r2,r11
80007308:	c1 e0       	breq	80007344 <_vfprintf_r+0x180>
8000730a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000730e:	0c 08       	add	r8,r6
80007310:	87 0b       	st.w	r3[0x0],r11
80007312:	fb 48 06 90 	st.w	sp[1680],r8
80007316:	87 16       	st.w	r3[0x4],r6
80007318:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000731c:	2f f8       	sub	r8,-1
8000731e:	fb 48 06 8c 	st.w	sp[1676],r8
80007322:	58 78       	cp.w	r8,7
80007324:	e0 89 00 04 	brgt	8000732c <_vfprintf_r+0x168>
80007328:	2f 83       	sub	r3,-8
8000732a:	c0 a8       	rjmp	8000733e <_vfprintf_r+0x17a>
8000732c:	fa ca f9 78 	sub	r10,sp,-1672
80007330:	02 9b       	mov	r11,r1
80007332:	08 9c       	mov	r12,r4
80007334:	c3 af       	rcall	800071a8 <__sprint_r>
80007336:	e0 81 0e c6 	brne	800090c2 <_vfprintf_r+0x1efe>
8000733a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000733e:	40 ba       	lddsp	r10,sp[0x2c]
80007340:	0c 0a       	add	r10,r6
80007342:	50 ba       	stdsp	sp[0x2c],r10
80007344:	05 89       	ld.ub	r9,r2[0x0]
80007346:	30 08       	mov	r8,0
80007348:	f0 09 18 00 	cp.b	r9,r8
8000734c:	e0 80 0e aa 	breq	800090a0 <_vfprintf_r+0x1edc>
80007350:	30 09       	mov	r9,0
80007352:	fb 68 06 bb 	st.b	sp[1723],r8
80007356:	0e 96       	mov	r6,r7
80007358:	e4 c8 ff ff 	sub	r8,r2,-1
8000735c:	3f fe       	mov	lr,-1
8000735e:	50 93       	stdsp	sp[0x24],r3
80007360:	50 41       	stdsp	sp[0x10],r1
80007362:	0e 93       	mov	r3,r7
80007364:	04 91       	mov	r1,r2
80007366:	50 89       	stdsp	sp[0x20],r9
80007368:	50 a8       	stdsp	sp[0x28],r8
8000736a:	50 2e       	stdsp	sp[0x8],lr
8000736c:	50 39       	stdsp	sp[0xc],r9
8000736e:	12 95       	mov	r5,r9
80007370:	12 90       	mov	r0,r9
80007372:	10 97       	mov	r7,r8
80007374:	08 92       	mov	r2,r4
80007376:	c0 78       	rjmp	80007384 <_vfprintf_r+0x1c0>
80007378:	3f fc       	mov	r12,-1
8000737a:	08 97       	mov	r7,r4
8000737c:	50 2c       	stdsp	sp[0x8],r12
8000737e:	c0 38       	rjmp	80007384 <_vfprintf_r+0x1c0>
80007380:	30 0b       	mov	r11,0
80007382:	50 3b       	stdsp	sp[0xc],r11
80007384:	0f 38       	ld.ub	r8,r7++
80007386:	c0 28       	rjmp	8000738a <_vfprintf_r+0x1c6>
80007388:	12 90       	mov	r0,r9
8000738a:	f0 c9 00 20 	sub	r9,r8,32
8000738e:	e0 49 00 58 	cp.w	r9,88
80007392:	e0 8b 0a 30 	brhi	800087f2 <_vfprintf_r+0x162e>
80007396:	fe ca a7 ae 	sub	r10,pc,-22610
8000739a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000739e:	50 a7       	stdsp	sp[0x28],r7
800073a0:	50 80       	stdsp	sp[0x20],r0
800073a2:	0c 97       	mov	r7,r6
800073a4:	04 94       	mov	r4,r2
800073a6:	06 96       	mov	r6,r3
800073a8:	02 92       	mov	r2,r1
800073aa:	fe c9 a5 86 	sub	r9,pc,-23162
800073ae:	40 93       	lddsp	r3,sp[0x24]
800073b0:	10 90       	mov	r0,r8
800073b2:	40 41       	lddsp	r1,sp[0x10]
800073b4:	50 d9       	stdsp	sp[0x34],r9
800073b6:	e0 8f 08 8e 	bral	800084d2 <_vfprintf_r+0x130e>
800073ba:	30 08       	mov	r8,0
800073bc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800073c0:	f0 09 18 00 	cp.b	r9,r8
800073c4:	ce 01       	brne	80007384 <_vfprintf_r+0x1c0>
800073c6:	32 08       	mov	r8,32
800073c8:	c6 e8       	rjmp	800074a4 <_vfprintf_r+0x2e0>
800073ca:	a1 a5       	sbr	r5,0x0
800073cc:	cd cb       	rjmp	80007384 <_vfprintf_r+0x1c0>
800073ce:	0f 89       	ld.ub	r9,r7[0x0]
800073d0:	f2 c8 00 30 	sub	r8,r9,48
800073d4:	58 98       	cp.w	r8,9
800073d6:	e0 8b 00 1d 	brhi	80007410 <_vfprintf_r+0x24c>
800073da:	ee c8 ff ff 	sub	r8,r7,-1
800073de:	30 0b       	mov	r11,0
800073e0:	23 09       	sub	r9,48
800073e2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800073e6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800073ea:	11 39       	ld.ub	r9,r8++
800073ec:	f2 ca 00 30 	sub	r10,r9,48
800073f0:	58 9a       	cp.w	r10,9
800073f2:	fe 98 ff f7 	brls	800073e0 <_vfprintf_r+0x21c>
800073f6:	e0 49 00 24 	cp.w	r9,36
800073fa:	cc 31       	brne	80007380 <_vfprintf_r+0x1bc>
800073fc:	e0 4b 00 20 	cp.w	r11,32
80007400:	e0 89 0e 60 	brgt	800090c0 <_vfprintf_r+0x1efc>
80007404:	20 1b       	sub	r11,1
80007406:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000740a:	12 3b       	cp.w	r11,r9
8000740c:	c0 95       	brlt	8000741e <_vfprintf_r+0x25a>
8000740e:	c1 08       	rjmp	8000742e <_vfprintf_r+0x26a>
80007410:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007414:	ec ca ff ff 	sub	r10,r6,-1
80007418:	12 36       	cp.w	r6,r9
8000741a:	c1 f5       	brlt	80007458 <_vfprintf_r+0x294>
8000741c:	c2 68       	rjmp	80007468 <_vfprintf_r+0x2a4>
8000741e:	fa ce f9 44 	sub	lr,sp,-1724
80007422:	10 97       	mov	r7,r8
80007424:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007428:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000742c:	c3 58       	rjmp	80007496 <_vfprintf_r+0x2d2>
8000742e:	10 97       	mov	r7,r8
80007430:	fa c8 f9 50 	sub	r8,sp,-1712
80007434:	1a d8       	st.w	--sp,r8
80007436:	fa c8 fa b8 	sub	r8,sp,-1352
8000743a:	1a d8       	st.w	--sp,r8
8000743c:	fa c8 fb b4 	sub	r8,sp,-1100
80007440:	02 9a       	mov	r10,r1
80007442:	1a d8       	st.w	--sp,r8
80007444:	04 9c       	mov	r12,r2
80007446:	fa c8 f9 40 	sub	r8,sp,-1728
8000744a:	fa c9 ff b4 	sub	r9,sp,-76
8000744e:	fe b0 fd 23 	rcall	80006e94 <get_arg>
80007452:	2f dd       	sub	sp,-12
80007454:	78 00       	ld.w	r0,r12[0x0]
80007456:	c2 08       	rjmp	80007496 <_vfprintf_r+0x2d2>
80007458:	fa cc f9 44 	sub	r12,sp,-1724
8000745c:	14 96       	mov	r6,r10
8000745e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007462:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007466:	c1 88       	rjmp	80007496 <_vfprintf_r+0x2d2>
80007468:	41 08       	lddsp	r8,sp[0x40]
8000746a:	59 f9       	cp.w	r9,31
8000746c:	e0 89 00 11 	brgt	8000748e <_vfprintf_r+0x2ca>
80007470:	f0 cb ff fc 	sub	r11,r8,-4
80007474:	51 0b       	stdsp	sp[0x40],r11
80007476:	70 00       	ld.w	r0,r8[0x0]
80007478:	fa cb f9 44 	sub	r11,sp,-1724
8000747c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007480:	f1 40 fd 88 	st.w	r8[-632],r0
80007484:	2f f9       	sub	r9,-1
80007486:	14 96       	mov	r6,r10
80007488:	fb 49 06 b4 	st.w	sp[1716],r9
8000748c:	c0 58       	rjmp	80007496 <_vfprintf_r+0x2d2>
8000748e:	70 00       	ld.w	r0,r8[0x0]
80007490:	14 96       	mov	r6,r10
80007492:	2f c8       	sub	r8,-4
80007494:	51 08       	stdsp	sp[0x40],r8
80007496:	58 00       	cp.w	r0,0
80007498:	fe 94 ff 76 	brge	80007384 <_vfprintf_r+0x1c0>
8000749c:	5c 30       	neg	r0
8000749e:	a3 a5       	sbr	r5,0x2
800074a0:	c7 2b       	rjmp	80007384 <_vfprintf_r+0x1c0>
800074a2:	32 b8       	mov	r8,43
800074a4:	fb 68 06 bb 	st.b	sp[1723],r8
800074a8:	c6 eb       	rjmp	80007384 <_vfprintf_r+0x1c0>
800074aa:	0f 38       	ld.ub	r8,r7++
800074ac:	e0 48 00 2a 	cp.w	r8,42
800074b0:	c0 30       	breq	800074b6 <_vfprintf_r+0x2f2>
800074b2:	30 09       	mov	r9,0
800074b4:	c7 98       	rjmp	800075a6 <_vfprintf_r+0x3e2>
800074b6:	0f 88       	ld.ub	r8,r7[0x0]
800074b8:	f0 c9 00 30 	sub	r9,r8,48
800074bc:	58 99       	cp.w	r9,9
800074be:	e0 8b 00 1f 	brhi	800074fc <_vfprintf_r+0x338>
800074c2:	ee c4 ff ff 	sub	r4,r7,-1
800074c6:	30 0b       	mov	r11,0
800074c8:	23 08       	sub	r8,48
800074ca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800074ce:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800074d2:	09 38       	ld.ub	r8,r4++
800074d4:	f0 c9 00 30 	sub	r9,r8,48
800074d8:	58 99       	cp.w	r9,9
800074da:	fe 98 ff f7 	brls	800074c8 <_vfprintf_r+0x304>
800074de:	e0 48 00 24 	cp.w	r8,36
800074e2:	fe 91 ff 4f 	brne	80007380 <_vfprintf_r+0x1bc>
800074e6:	e0 4b 00 20 	cp.w	r11,32
800074ea:	e0 89 0d eb 	brgt	800090c0 <_vfprintf_r+0x1efc>
800074ee:	20 1b       	sub	r11,1
800074f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800074f4:	10 3b       	cp.w	r11,r8
800074f6:	c0 a5       	brlt	8000750a <_vfprintf_r+0x346>
800074f8:	c1 18       	rjmp	8000751a <_vfprintf_r+0x356>
800074fa:	d7 03       	nop
800074fc:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007500:	ec c9 ff ff 	sub	r9,r6,-1
80007504:	14 36       	cp.w	r6,r10
80007506:	c1 f5       	brlt	80007544 <_vfprintf_r+0x380>
80007508:	c2 88       	rjmp	80007558 <_vfprintf_r+0x394>
8000750a:	fa ca f9 44 	sub	r10,sp,-1724
8000750e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007512:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007516:	50 2b       	stdsp	sp[0x8],r11
80007518:	c3 c8       	rjmp	80007590 <_vfprintf_r+0x3cc>
8000751a:	fa c8 f9 50 	sub	r8,sp,-1712
8000751e:	1a d8       	st.w	--sp,r8
80007520:	fa c8 fa b8 	sub	r8,sp,-1352
80007524:	1a d8       	st.w	--sp,r8
80007526:	fa c8 fb b4 	sub	r8,sp,-1100
8000752a:	02 9a       	mov	r10,r1
8000752c:	1a d8       	st.w	--sp,r8
8000752e:	04 9c       	mov	r12,r2
80007530:	fa c8 f9 40 	sub	r8,sp,-1728
80007534:	fa c9 ff b4 	sub	r9,sp,-76
80007538:	fe b0 fc ae 	rcall	80006e94 <get_arg>
8000753c:	2f dd       	sub	sp,-12
8000753e:	78 0c       	ld.w	r12,r12[0x0]
80007540:	50 2c       	stdsp	sp[0x8],r12
80007542:	c2 78       	rjmp	80007590 <_vfprintf_r+0x3cc>
80007544:	12 96       	mov	r6,r9
80007546:	0e 94       	mov	r4,r7
80007548:	fa c9 f9 44 	sub	r9,sp,-1724
8000754c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007550:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007554:	50 28       	stdsp	sp[0x8],r8
80007556:	c1 d8       	rjmp	80007590 <_vfprintf_r+0x3cc>
80007558:	41 08       	lddsp	r8,sp[0x40]
8000755a:	59 fa       	cp.w	r10,31
8000755c:	e0 89 00 14 	brgt	80007584 <_vfprintf_r+0x3c0>
80007560:	f0 cb ff fc 	sub	r11,r8,-4
80007564:	70 08       	ld.w	r8,r8[0x0]
80007566:	51 0b       	stdsp	sp[0x40],r11
80007568:	50 28       	stdsp	sp[0x8],r8
8000756a:	fa c6 f9 44 	sub	r6,sp,-1724
8000756e:	40 2e       	lddsp	lr,sp[0x8]
80007570:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007574:	f1 4e fd 88 	st.w	r8[-632],lr
80007578:	2f fa       	sub	r10,-1
8000757a:	0e 94       	mov	r4,r7
8000757c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007580:	12 96       	mov	r6,r9
80007582:	c0 78       	rjmp	80007590 <_vfprintf_r+0x3cc>
80007584:	70 0c       	ld.w	r12,r8[0x0]
80007586:	0e 94       	mov	r4,r7
80007588:	2f c8       	sub	r8,-4
8000758a:	50 2c       	stdsp	sp[0x8],r12
8000758c:	12 96       	mov	r6,r9
8000758e:	51 08       	stdsp	sp[0x40],r8
80007590:	40 2b       	lddsp	r11,sp[0x8]
80007592:	58 0b       	cp.w	r11,0
80007594:	fe 95 fe f2 	brlt	80007378 <_vfprintf_r+0x1b4>
80007598:	08 97       	mov	r7,r4
8000759a:	cf 5a       	rjmp	80007384 <_vfprintf_r+0x1c0>
8000759c:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075a0:	0f 38       	ld.ub	r8,r7++
800075a2:	f4 09 00 19 	add	r9,r10,r9<<0x1
800075a6:	f0 ca 00 30 	sub	r10,r8,48
800075aa:	58 9a       	cp.w	r10,9
800075ac:	fe 98 ff f8 	brls	8000759c <_vfprintf_r+0x3d8>
800075b0:	3f fa       	mov	r10,-1
800075b2:	f2 0a 0c 49 	max	r9,r9,r10
800075b6:	50 29       	stdsp	sp[0x8],r9
800075b8:	ce 9a       	rjmp	8000738a <_vfprintf_r+0x1c6>
800075ba:	a7 b5       	sbr	r5,0x7
800075bc:	ce 4a       	rjmp	80007384 <_vfprintf_r+0x1c0>
800075be:	30 09       	mov	r9,0
800075c0:	23 08       	sub	r8,48
800075c2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075c6:	f0 09 00 19 	add	r9,r8,r9<<0x1
800075ca:	0f 38       	ld.ub	r8,r7++
800075cc:	f0 ca 00 30 	sub	r10,r8,48
800075d0:	58 9a       	cp.w	r10,9
800075d2:	fe 98 ff f7 	brls	800075c0 <_vfprintf_r+0x3fc>
800075d6:	e0 48 00 24 	cp.w	r8,36
800075da:	fe 91 fe d7 	brne	80007388 <_vfprintf_r+0x1c4>
800075de:	e0 49 00 20 	cp.w	r9,32
800075e2:	e0 89 0d 6f 	brgt	800090c0 <_vfprintf_r+0x1efc>
800075e6:	f2 c3 00 01 	sub	r3,r9,1
800075ea:	30 19       	mov	r9,1
800075ec:	50 39       	stdsp	sp[0xc],r9
800075ee:	cc ba       	rjmp	80007384 <_vfprintf_r+0x1c0>
800075f0:	a3 b5       	sbr	r5,0x3
800075f2:	cc 9a       	rjmp	80007384 <_vfprintf_r+0x1c0>
800075f4:	a7 a5       	sbr	r5,0x6
800075f6:	cc 7a       	rjmp	80007384 <_vfprintf_r+0x1c0>
800075f8:	0a 98       	mov	r8,r5
800075fa:	a5 b5       	sbr	r5,0x5
800075fc:	a5 a8       	sbr	r8,0x4
800075fe:	0f 89       	ld.ub	r9,r7[0x0]
80007600:	36 ce       	mov	lr,108
80007602:	fc 09 18 00 	cp.b	r9,lr
80007606:	f7 b7 00 ff 	subeq	r7,-1
8000760a:	f0 05 17 10 	movne	r5,r8
8000760e:	cb ba       	rjmp	80007384 <_vfprintf_r+0x1c0>
80007610:	a5 b5       	sbr	r5,0x5
80007612:	cb 9a       	rjmp	80007384 <_vfprintf_r+0x1c0>
80007614:	50 a7       	stdsp	sp[0x28],r7
80007616:	50 80       	stdsp	sp[0x20],r0
80007618:	0c 97       	mov	r7,r6
8000761a:	10 90       	mov	r0,r8
8000761c:	06 96       	mov	r6,r3
8000761e:	04 94       	mov	r4,r2
80007620:	40 93       	lddsp	r3,sp[0x24]
80007622:	02 92       	mov	r2,r1
80007624:	0e 99       	mov	r9,r7
80007626:	40 41       	lddsp	r1,sp[0x10]
80007628:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000762c:	40 3c       	lddsp	r12,sp[0xc]
8000762e:	58 0c       	cp.w	r12,0
80007630:	c1 d0       	breq	8000766a <_vfprintf_r+0x4a6>
80007632:	10 36       	cp.w	r6,r8
80007634:	c0 64       	brge	80007640 <_vfprintf_r+0x47c>
80007636:	fa cb f9 44 	sub	r11,sp,-1724
8000763a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000763e:	c1 d8       	rjmp	80007678 <_vfprintf_r+0x4b4>
80007640:	fa c8 f9 50 	sub	r8,sp,-1712
80007644:	1a d8       	st.w	--sp,r8
80007646:	fa c8 fa b8 	sub	r8,sp,-1352
8000764a:	1a d8       	st.w	--sp,r8
8000764c:	fa c8 fb b4 	sub	r8,sp,-1100
80007650:	1a d8       	st.w	--sp,r8
80007652:	fa c8 f9 40 	sub	r8,sp,-1728
80007656:	fa c9 ff b4 	sub	r9,sp,-76
8000765a:	04 9a       	mov	r10,r2
8000765c:	0c 9b       	mov	r11,r6
8000765e:	08 9c       	mov	r12,r4
80007660:	fe b0 fc 1a 	rcall	80006e94 <get_arg>
80007664:	2f dd       	sub	sp,-12
80007666:	19 b8       	ld.ub	r8,r12[0x3]
80007668:	c2 28       	rjmp	800076ac <_vfprintf_r+0x4e8>
8000766a:	2f f7       	sub	r7,-1
8000766c:	10 39       	cp.w	r9,r8
8000766e:	c0 84       	brge	8000767e <_vfprintf_r+0x4ba>
80007670:	fa ca f9 44 	sub	r10,sp,-1724
80007674:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007678:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000767c:	c1 88       	rjmp	800076ac <_vfprintf_r+0x4e8>
8000767e:	41 09       	lddsp	r9,sp[0x40]
80007680:	59 f8       	cp.w	r8,31
80007682:	e0 89 00 12 	brgt	800076a6 <_vfprintf_r+0x4e2>
80007686:	f2 ca ff fc 	sub	r10,r9,-4
8000768a:	51 0a       	stdsp	sp[0x40],r10
8000768c:	72 09       	ld.w	r9,r9[0x0]
8000768e:	fa c6 f9 44 	sub	r6,sp,-1724
80007692:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007696:	2f f8       	sub	r8,-1
80007698:	f5 49 fd 88 	st.w	r10[-632],r9
8000769c:	fb 48 06 b4 	st.w	sp[1716],r8
800076a0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800076a4:	c0 48       	rjmp	800076ac <_vfprintf_r+0x4e8>
800076a6:	13 b8       	ld.ub	r8,r9[0x3]
800076a8:	2f c9       	sub	r9,-4
800076aa:	51 09       	stdsp	sp[0x40],r9
800076ac:	fb 68 06 60 	st.b	sp[1632],r8
800076b0:	30 0e       	mov	lr,0
800076b2:	30 08       	mov	r8,0
800076b4:	30 12       	mov	r2,1
800076b6:	fb 68 06 bb 	st.b	sp[1723],r8
800076ba:	50 2e       	stdsp	sp[0x8],lr
800076bc:	e0 8f 08 ad 	bral	80008816 <_vfprintf_r+0x1652>
800076c0:	50 a7       	stdsp	sp[0x28],r7
800076c2:	50 80       	stdsp	sp[0x20],r0
800076c4:	0c 97       	mov	r7,r6
800076c6:	04 94       	mov	r4,r2
800076c8:	06 96       	mov	r6,r3
800076ca:	02 92       	mov	r2,r1
800076cc:	40 93       	lddsp	r3,sp[0x24]
800076ce:	10 90       	mov	r0,r8
800076d0:	40 41       	lddsp	r1,sp[0x10]
800076d2:	a5 a5       	sbr	r5,0x4
800076d4:	c0 a8       	rjmp	800076e8 <_vfprintf_r+0x524>
800076d6:	50 a7       	stdsp	sp[0x28],r7
800076d8:	50 80       	stdsp	sp[0x20],r0
800076da:	0c 97       	mov	r7,r6
800076dc:	04 94       	mov	r4,r2
800076de:	06 96       	mov	r6,r3
800076e0:	02 92       	mov	r2,r1
800076e2:	40 93       	lddsp	r3,sp[0x24]
800076e4:	10 90       	mov	r0,r8
800076e6:	40 41       	lddsp	r1,sp[0x10]
800076e8:	ed b5 00 05 	bld	r5,0x5
800076ec:	c5 11       	brne	8000778e <_vfprintf_r+0x5ca>
800076ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076f2:	40 3c       	lddsp	r12,sp[0xc]
800076f4:	58 0c       	cp.w	r12,0
800076f6:	c1 e0       	breq	80007732 <_vfprintf_r+0x56e>
800076f8:	10 36       	cp.w	r6,r8
800076fa:	c0 64       	brge	80007706 <_vfprintf_r+0x542>
800076fc:	fa cb f9 44 	sub	r11,sp,-1724
80007700:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007704:	c2 08       	rjmp	80007744 <_vfprintf_r+0x580>
80007706:	fa c8 f9 50 	sub	r8,sp,-1712
8000770a:	1a d8       	st.w	--sp,r8
8000770c:	fa c8 fa b8 	sub	r8,sp,-1352
80007710:	0c 9b       	mov	r11,r6
80007712:	1a d8       	st.w	--sp,r8
80007714:	fa c8 fb b4 	sub	r8,sp,-1100
80007718:	1a d8       	st.w	--sp,r8
8000771a:	fa c9 ff b4 	sub	r9,sp,-76
8000771e:	fa c8 f9 40 	sub	r8,sp,-1728
80007722:	04 9a       	mov	r10,r2
80007724:	08 9c       	mov	r12,r4
80007726:	fe b0 fb b7 	rcall	80006e94 <get_arg>
8000772a:	2f dd       	sub	sp,-12
8000772c:	78 1b       	ld.w	r11,r12[0x4]
8000772e:	78 09       	ld.w	r9,r12[0x0]
80007730:	c2 b8       	rjmp	80007786 <_vfprintf_r+0x5c2>
80007732:	ee ca ff ff 	sub	r10,r7,-1
80007736:	10 37       	cp.w	r7,r8
80007738:	c0 b4       	brge	8000774e <_vfprintf_r+0x58a>
8000773a:	fa c9 f9 44 	sub	r9,sp,-1724
8000773e:	14 97       	mov	r7,r10
80007740:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007744:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007748:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000774c:	c1 d8       	rjmp	80007786 <_vfprintf_r+0x5c2>
8000774e:	41 09       	lddsp	r9,sp[0x40]
80007750:	59 f8       	cp.w	r8,31
80007752:	e0 89 00 14 	brgt	8000777a <_vfprintf_r+0x5b6>
80007756:	f2 cb ff f8 	sub	r11,r9,-8
8000775a:	51 0b       	stdsp	sp[0x40],r11
8000775c:	fa c6 f9 44 	sub	r6,sp,-1724
80007760:	72 1b       	ld.w	r11,r9[0x4]
80007762:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007766:	72 09       	ld.w	r9,r9[0x0]
80007768:	f9 4b fd 8c 	st.w	r12[-628],r11
8000776c:	f9 49 fd 88 	st.w	r12[-632],r9
80007770:	2f f8       	sub	r8,-1
80007772:	14 97       	mov	r7,r10
80007774:	fb 48 06 b4 	st.w	sp[1716],r8
80007778:	c0 78       	rjmp	80007786 <_vfprintf_r+0x5c2>
8000777a:	f2 c8 ff f8 	sub	r8,r9,-8
8000777e:	72 1b       	ld.w	r11,r9[0x4]
80007780:	14 97       	mov	r7,r10
80007782:	51 08       	stdsp	sp[0x40],r8
80007784:	72 09       	ld.w	r9,r9[0x0]
80007786:	16 98       	mov	r8,r11
80007788:	fa e9 00 00 	st.d	sp[0],r8
8000778c:	ca e8       	rjmp	800078e8 <_vfprintf_r+0x724>
8000778e:	ed b5 00 04 	bld	r5,0x4
80007792:	c1 71       	brne	800077c0 <_vfprintf_r+0x5fc>
80007794:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007798:	40 3e       	lddsp	lr,sp[0xc]
8000779a:	58 0e       	cp.w	lr,0
8000779c:	c0 80       	breq	800077ac <_vfprintf_r+0x5e8>
8000779e:	10 36       	cp.w	r6,r8
800077a0:	c6 94       	brge	80007872 <_vfprintf_r+0x6ae>
800077a2:	fa cc f9 44 	sub	r12,sp,-1724
800077a6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800077aa:	c8 28       	rjmp	800078ae <_vfprintf_r+0x6ea>
800077ac:	ee ca ff ff 	sub	r10,r7,-1
800077b0:	10 37       	cp.w	r7,r8
800077b2:	e0 84 00 81 	brge	800078b4 <_vfprintf_r+0x6f0>
800077b6:	fa cb f9 44 	sub	r11,sp,-1724
800077ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077be:	c7 78       	rjmp	800078ac <_vfprintf_r+0x6e8>
800077c0:	ed b5 00 06 	bld	r5,0x6
800077c4:	c4 b1       	brne	8000785a <_vfprintf_r+0x696>
800077c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077ca:	40 3c       	lddsp	r12,sp[0xc]
800077cc:	58 0c       	cp.w	r12,0
800077ce:	c1 d0       	breq	80007808 <_vfprintf_r+0x644>
800077d0:	10 36       	cp.w	r6,r8
800077d2:	c0 64       	brge	800077de <_vfprintf_r+0x61a>
800077d4:	fa cb f9 44 	sub	r11,sp,-1724
800077d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077dc:	c1 f8       	rjmp	8000781a <_vfprintf_r+0x656>
800077de:	fa c8 f9 50 	sub	r8,sp,-1712
800077e2:	1a d8       	st.w	--sp,r8
800077e4:	fa c8 fa b8 	sub	r8,sp,-1352
800077e8:	1a d8       	st.w	--sp,r8
800077ea:	fa c8 fb b4 	sub	r8,sp,-1100
800077ee:	1a d8       	st.w	--sp,r8
800077f0:	fa c8 f9 40 	sub	r8,sp,-1728
800077f4:	fa c9 ff b4 	sub	r9,sp,-76
800077f8:	04 9a       	mov	r10,r2
800077fa:	0c 9b       	mov	r11,r6
800077fc:	08 9c       	mov	r12,r4
800077fe:	fe b0 fb 4b 	rcall	80006e94 <get_arg>
80007802:	2f dd       	sub	sp,-12
80007804:	98 18       	ld.sh	r8,r12[0x2]
80007806:	c2 68       	rjmp	80007852 <_vfprintf_r+0x68e>
80007808:	ee ca ff ff 	sub	r10,r7,-1
8000780c:	10 37       	cp.w	r7,r8
8000780e:	c0 94       	brge	80007820 <_vfprintf_r+0x65c>
80007810:	fa c9 f9 44 	sub	r9,sp,-1724
80007814:	14 97       	mov	r7,r10
80007816:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000781a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000781e:	c1 a8       	rjmp	80007852 <_vfprintf_r+0x68e>
80007820:	41 09       	lddsp	r9,sp[0x40]
80007822:	59 f8       	cp.w	r8,31
80007824:	e0 89 00 13 	brgt	8000784a <_vfprintf_r+0x686>
80007828:	f2 cb ff fc 	sub	r11,r9,-4
8000782c:	51 0b       	stdsp	sp[0x40],r11
8000782e:	72 09       	ld.w	r9,r9[0x0]
80007830:	fa c6 f9 44 	sub	r6,sp,-1724
80007834:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007838:	2f f8       	sub	r8,-1
8000783a:	f7 49 fd 88 	st.w	r11[-632],r9
8000783e:	fb 48 06 b4 	st.w	sp[1716],r8
80007842:	14 97       	mov	r7,r10
80007844:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007848:	c0 58       	rjmp	80007852 <_vfprintf_r+0x68e>
8000784a:	92 18       	ld.sh	r8,r9[0x2]
8000784c:	14 97       	mov	r7,r10
8000784e:	2f c9       	sub	r9,-4
80007850:	51 09       	stdsp	sp[0x40],r9
80007852:	50 18       	stdsp	sp[0x4],r8
80007854:	bf 58       	asr	r8,0x1f
80007856:	50 08       	stdsp	sp[0x0],r8
80007858:	c4 88       	rjmp	800078e8 <_vfprintf_r+0x724>
8000785a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000785e:	40 3c       	lddsp	r12,sp[0xc]
80007860:	58 0c       	cp.w	r12,0
80007862:	c1 d0       	breq	8000789c <_vfprintf_r+0x6d8>
80007864:	10 36       	cp.w	r6,r8
80007866:	c0 64       	brge	80007872 <_vfprintf_r+0x6ae>
80007868:	fa cb f9 44 	sub	r11,sp,-1724
8000786c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007870:	c1 f8       	rjmp	800078ae <_vfprintf_r+0x6ea>
80007872:	fa c8 f9 50 	sub	r8,sp,-1712
80007876:	1a d8       	st.w	--sp,r8
80007878:	fa c8 fa b8 	sub	r8,sp,-1352
8000787c:	0c 9b       	mov	r11,r6
8000787e:	1a d8       	st.w	--sp,r8
80007880:	fa c8 fb b4 	sub	r8,sp,-1100
80007884:	04 9a       	mov	r10,r2
80007886:	1a d8       	st.w	--sp,r8
80007888:	08 9c       	mov	r12,r4
8000788a:	fa c8 f9 40 	sub	r8,sp,-1728
8000788e:	fa c9 ff b4 	sub	r9,sp,-76
80007892:	fe b0 fb 01 	rcall	80006e94 <get_arg>
80007896:	2f dd       	sub	sp,-12
80007898:	78 0b       	ld.w	r11,r12[0x0]
8000789a:	c2 48       	rjmp	800078e2 <_vfprintf_r+0x71e>
8000789c:	ee ca ff ff 	sub	r10,r7,-1
800078a0:	10 37       	cp.w	r7,r8
800078a2:	c0 94       	brge	800078b4 <_vfprintf_r+0x6f0>
800078a4:	fa c9 f9 44 	sub	r9,sp,-1724
800078a8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800078ac:	14 97       	mov	r7,r10
800078ae:	ec fb fd 88 	ld.w	r11,r6[-632]
800078b2:	c1 88       	rjmp	800078e2 <_vfprintf_r+0x71e>
800078b4:	41 09       	lddsp	r9,sp[0x40]
800078b6:	59 f8       	cp.w	r8,31
800078b8:	e0 89 00 11 	brgt	800078da <_vfprintf_r+0x716>
800078bc:	f2 cb ff fc 	sub	r11,r9,-4
800078c0:	51 0b       	stdsp	sp[0x40],r11
800078c2:	fa c6 f9 44 	sub	r6,sp,-1724
800078c6:	72 0b       	ld.w	r11,r9[0x0]
800078c8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800078cc:	f3 4b fd 88 	st.w	r9[-632],r11
800078d0:	2f f8       	sub	r8,-1
800078d2:	14 97       	mov	r7,r10
800078d4:	fb 48 06 b4 	st.w	sp[1716],r8
800078d8:	c0 58       	rjmp	800078e2 <_vfprintf_r+0x71e>
800078da:	72 0b       	ld.w	r11,r9[0x0]
800078dc:	14 97       	mov	r7,r10
800078de:	2f c9       	sub	r9,-4
800078e0:	51 09       	stdsp	sp[0x40],r9
800078e2:	50 1b       	stdsp	sp[0x4],r11
800078e4:	bf 5b       	asr	r11,0x1f
800078e6:	50 0b       	stdsp	sp[0x0],r11
800078e8:	fa ea 00 00 	ld.d	r10,sp[0]
800078ec:	58 0a       	cp.w	r10,0
800078ee:	5c 2b       	cpc	r11
800078f0:	c0 e4       	brge	8000790c <_vfprintf_r+0x748>
800078f2:	30 08       	mov	r8,0
800078f4:	fa ea 00 00 	ld.d	r10,sp[0]
800078f8:	30 09       	mov	r9,0
800078fa:	f0 0a 01 0a 	sub	r10,r8,r10
800078fe:	f2 0b 01 4b 	sbc	r11,r9,r11
80007902:	32 d8       	mov	r8,45
80007904:	fa eb 00 00 	st.d	sp[0],r10
80007908:	fb 68 06 bb 	st.b	sp[1723],r8
8000790c:	30 18       	mov	r8,1
8000790e:	e0 8f 06 fa 	bral	80008702 <_vfprintf_r+0x153e>
80007912:	50 a7       	stdsp	sp[0x28],r7
80007914:	50 80       	stdsp	sp[0x20],r0
80007916:	0c 97       	mov	r7,r6
80007918:	04 94       	mov	r4,r2
8000791a:	06 96       	mov	r6,r3
8000791c:	02 92       	mov	r2,r1
8000791e:	40 93       	lddsp	r3,sp[0x24]
80007920:	10 90       	mov	r0,r8
80007922:	40 41       	lddsp	r1,sp[0x10]
80007924:	0e 99       	mov	r9,r7
80007926:	ed b5 00 03 	bld	r5,0x3
8000792a:	c4 11       	brne	800079ac <_vfprintf_r+0x7e8>
8000792c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007930:	40 3a       	lddsp	r10,sp[0xc]
80007932:	58 0a       	cp.w	r10,0
80007934:	c1 90       	breq	80007966 <_vfprintf_r+0x7a2>
80007936:	10 36       	cp.w	r6,r8
80007938:	c6 45       	brlt	80007a00 <_vfprintf_r+0x83c>
8000793a:	fa c8 f9 50 	sub	r8,sp,-1712
8000793e:	1a d8       	st.w	--sp,r8
80007940:	fa c8 fa b8 	sub	r8,sp,-1352
80007944:	1a d8       	st.w	--sp,r8
80007946:	fa c8 fb b4 	sub	r8,sp,-1100
8000794a:	0c 9b       	mov	r11,r6
8000794c:	1a d8       	st.w	--sp,r8
8000794e:	04 9a       	mov	r10,r2
80007950:	fa c8 f9 40 	sub	r8,sp,-1728
80007954:	fa c9 ff b4 	sub	r9,sp,-76
80007958:	08 9c       	mov	r12,r4
8000795a:	fe b0 fa 9d 	rcall	80006e94 <get_arg>
8000795e:	2f dd       	sub	sp,-12
80007960:	78 16       	ld.w	r6,r12[0x4]
80007962:	50 76       	stdsp	sp[0x1c],r6
80007964:	c4 88       	rjmp	800079f4 <_vfprintf_r+0x830>
80007966:	2f f7       	sub	r7,-1
80007968:	10 39       	cp.w	r9,r8
8000796a:	c0 c4       	brge	80007982 <_vfprintf_r+0x7be>
8000796c:	fa ce f9 44 	sub	lr,sp,-1724
80007970:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007974:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007978:	50 7c       	stdsp	sp[0x1c],r12
8000797a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000797e:	50 56       	stdsp	sp[0x14],r6
80007980:	c6 68       	rjmp	80007a4c <_vfprintf_r+0x888>
80007982:	41 09       	lddsp	r9,sp[0x40]
80007984:	59 f8       	cp.w	r8,31
80007986:	e0 89 00 10 	brgt	800079a6 <_vfprintf_r+0x7e2>
8000798a:	f2 ca ff f8 	sub	r10,r9,-8
8000798e:	72 1b       	ld.w	r11,r9[0x4]
80007990:	51 0a       	stdsp	sp[0x40],r10
80007992:	72 09       	ld.w	r9,r9[0x0]
80007994:	fa ca f9 44 	sub	r10,sp,-1724
80007998:	50 7b       	stdsp	sp[0x1c],r11
8000799a:	50 59       	stdsp	sp[0x14],r9
8000799c:	f4 08 00 39 	add	r9,r10,r8<<0x3
800079a0:	40 5b       	lddsp	r11,sp[0x14]
800079a2:	40 7a       	lddsp	r10,sp[0x1c]
800079a4:	c4 78       	rjmp	80007a32 <_vfprintf_r+0x86e>
800079a6:	72 18       	ld.w	r8,r9[0x4]
800079a8:	50 78       	stdsp	sp[0x1c],r8
800079aa:	c4 c8       	rjmp	80007a42 <_vfprintf_r+0x87e>
800079ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079b0:	40 3e       	lddsp	lr,sp[0xc]
800079b2:	58 0e       	cp.w	lr,0
800079b4:	c2 30       	breq	800079fa <_vfprintf_r+0x836>
800079b6:	10 36       	cp.w	r6,r8
800079b8:	c0 94       	brge	800079ca <_vfprintf_r+0x806>
800079ba:	fa cc f9 44 	sub	r12,sp,-1724
800079be:	f8 06 00 36 	add	r6,r12,r6<<0x3
800079c2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800079c6:	50 7b       	stdsp	sp[0x1c],r11
800079c8:	cd 9b       	rjmp	8000797a <_vfprintf_r+0x7b6>
800079ca:	fa c8 f9 50 	sub	r8,sp,-1712
800079ce:	1a d8       	st.w	--sp,r8
800079d0:	fa c8 fa b8 	sub	r8,sp,-1352
800079d4:	04 9a       	mov	r10,r2
800079d6:	1a d8       	st.w	--sp,r8
800079d8:	fa c8 fb b4 	sub	r8,sp,-1100
800079dc:	0c 9b       	mov	r11,r6
800079de:	1a d8       	st.w	--sp,r8
800079e0:	08 9c       	mov	r12,r4
800079e2:	fa c8 f9 40 	sub	r8,sp,-1728
800079e6:	fa c9 ff b4 	sub	r9,sp,-76
800079ea:	fe b0 fa 55 	rcall	80006e94 <get_arg>
800079ee:	2f dd       	sub	sp,-12
800079f0:	78 1a       	ld.w	r10,r12[0x4]
800079f2:	50 7a       	stdsp	sp[0x1c],r10
800079f4:	78 0c       	ld.w	r12,r12[0x0]
800079f6:	50 5c       	stdsp	sp[0x14],r12
800079f8:	c2 a8       	rjmp	80007a4c <_vfprintf_r+0x888>
800079fa:	2f f7       	sub	r7,-1
800079fc:	10 39       	cp.w	r9,r8
800079fe:	c0 94       	brge	80007a10 <_vfprintf_r+0x84c>
80007a00:	fa c9 f9 44 	sub	r9,sp,-1724
80007a04:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a08:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007a0c:	50 78       	stdsp	sp[0x1c],r8
80007a0e:	cb 6b       	rjmp	8000797a <_vfprintf_r+0x7b6>
80007a10:	41 09       	lddsp	r9,sp[0x40]
80007a12:	59 f8       	cp.w	r8,31
80007a14:	e0 89 00 15 	brgt	80007a3e <_vfprintf_r+0x87a>
80007a18:	f2 ca ff f8 	sub	r10,r9,-8
80007a1c:	72 16       	ld.w	r6,r9[0x4]
80007a1e:	72 09       	ld.w	r9,r9[0x0]
80007a20:	51 0a       	stdsp	sp[0x40],r10
80007a22:	50 59       	stdsp	sp[0x14],r9
80007a24:	fa ce f9 44 	sub	lr,sp,-1724
80007a28:	50 76       	stdsp	sp[0x1c],r6
80007a2a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007a2e:	40 5b       	lddsp	r11,sp[0x14]
80007a30:	0c 9a       	mov	r10,r6
80007a32:	f2 eb fd 88 	st.d	r9[-632],r10
80007a36:	2f f8       	sub	r8,-1
80007a38:	fb 48 06 b4 	st.w	sp[1716],r8
80007a3c:	c0 88       	rjmp	80007a4c <_vfprintf_r+0x888>
80007a3e:	72 1c       	ld.w	r12,r9[0x4]
80007a40:	50 7c       	stdsp	sp[0x1c],r12
80007a42:	f2 c8 ff f8 	sub	r8,r9,-8
80007a46:	51 08       	stdsp	sp[0x40],r8
80007a48:	72 09       	ld.w	r9,r9[0x0]
80007a4a:	50 59       	stdsp	sp[0x14],r9
80007a4c:	40 5b       	lddsp	r11,sp[0x14]
80007a4e:	40 7a       	lddsp	r10,sp[0x1c]
80007a50:	e0 a0 19 54 	rcall	8000acf8 <__isinfd>
80007a54:	18 96       	mov	r6,r12
80007a56:	c1 70       	breq	80007a84 <_vfprintf_r+0x8c0>
80007a58:	30 08       	mov	r8,0
80007a5a:	30 09       	mov	r9,0
80007a5c:	40 5b       	lddsp	r11,sp[0x14]
80007a5e:	40 7a       	lddsp	r10,sp[0x1c]
80007a60:	e0 a0 1d a8 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
80007a64:	c0 40       	breq	80007a6c <_vfprintf_r+0x8a8>
80007a66:	32 d8       	mov	r8,45
80007a68:	fb 68 06 bb 	st.b	sp[1723],r8
80007a6c:	fe c8 ac 34 	sub	r8,pc,-21452
80007a70:	fe c6 ac 34 	sub	r6,pc,-21452
80007a74:	a7 d5       	cbr	r5,0x7
80007a76:	e0 40 00 47 	cp.w	r0,71
80007a7a:	f0 06 17 a0 	movle	r6,r8
80007a7e:	30 32       	mov	r2,3
80007a80:	e0 8f 06 ce 	bral	8000881c <_vfprintf_r+0x1658>
80007a84:	40 5b       	lddsp	r11,sp[0x14]
80007a86:	40 7a       	lddsp	r10,sp[0x1c]
80007a88:	e0 a0 19 4d 	rcall	8000ad22 <__isnand>
80007a8c:	c0 e0       	breq	80007aa8 <_vfprintf_r+0x8e4>
80007a8e:	50 26       	stdsp	sp[0x8],r6
80007a90:	fe c8 ac 50 	sub	r8,pc,-21424
80007a94:	fe c6 ac 50 	sub	r6,pc,-21424
80007a98:	a7 d5       	cbr	r5,0x7
80007a9a:	e0 40 00 47 	cp.w	r0,71
80007a9e:	f0 06 17 a0 	movle	r6,r8
80007aa2:	30 32       	mov	r2,3
80007aa4:	e0 8f 06 c2 	bral	80008828 <_vfprintf_r+0x1664>
80007aa8:	40 2a       	lddsp	r10,sp[0x8]
80007aaa:	5b fa       	cp.w	r10,-1
80007aac:	c0 41       	brne	80007ab4 <_vfprintf_r+0x8f0>
80007aae:	30 69       	mov	r9,6
80007ab0:	50 29       	stdsp	sp[0x8],r9
80007ab2:	c1 18       	rjmp	80007ad4 <_vfprintf_r+0x910>
80007ab4:	e0 40 00 47 	cp.w	r0,71
80007ab8:	5f 09       	sreq	r9
80007aba:	e0 40 00 67 	cp.w	r0,103
80007abe:	5f 08       	sreq	r8
80007ac0:	f3 e8 10 08 	or	r8,r9,r8
80007ac4:	f8 08 18 00 	cp.b	r8,r12
80007ac8:	c0 60       	breq	80007ad4 <_vfprintf_r+0x910>
80007aca:	40 28       	lddsp	r8,sp[0x8]
80007acc:	58 08       	cp.w	r8,0
80007ace:	f9 b8 00 01 	moveq	r8,1
80007ad2:	50 28       	stdsp	sp[0x8],r8
80007ad4:	40 78       	lddsp	r8,sp[0x1c]
80007ad6:	40 59       	lddsp	r9,sp[0x14]
80007ad8:	fa e9 06 94 	st.d	sp[1684],r8
80007adc:	a9 a5       	sbr	r5,0x8
80007ade:	fa f8 06 94 	ld.w	r8,sp[1684]
80007ae2:	58 08       	cp.w	r8,0
80007ae4:	c0 65       	brlt	80007af0 <_vfprintf_r+0x92c>
80007ae6:	40 5e       	lddsp	lr,sp[0x14]
80007ae8:	30 0c       	mov	r12,0
80007aea:	50 6e       	stdsp	sp[0x18],lr
80007aec:	50 9c       	stdsp	sp[0x24],r12
80007aee:	c0 78       	rjmp	80007afc <_vfprintf_r+0x938>
80007af0:	40 5b       	lddsp	r11,sp[0x14]
80007af2:	32 da       	mov	r10,45
80007af4:	ee 1b 80 00 	eorh	r11,0x8000
80007af8:	50 9a       	stdsp	sp[0x24],r10
80007afa:	50 6b       	stdsp	sp[0x18],r11
80007afc:	e0 40 00 46 	cp.w	r0,70
80007b00:	5f 09       	sreq	r9
80007b02:	e0 40 00 66 	cp.w	r0,102
80007b06:	5f 08       	sreq	r8
80007b08:	f3 e8 10 08 	or	r8,r9,r8
80007b0c:	50 48       	stdsp	sp[0x10],r8
80007b0e:	c0 40       	breq	80007b16 <_vfprintf_r+0x952>
80007b10:	40 22       	lddsp	r2,sp[0x8]
80007b12:	30 39       	mov	r9,3
80007b14:	c1 08       	rjmp	80007b34 <_vfprintf_r+0x970>
80007b16:	e0 40 00 45 	cp.w	r0,69
80007b1a:	5f 09       	sreq	r9
80007b1c:	e0 40 00 65 	cp.w	r0,101
80007b20:	5f 08       	sreq	r8
80007b22:	40 22       	lddsp	r2,sp[0x8]
80007b24:	10 49       	or	r9,r8
80007b26:	2f f2       	sub	r2,-1
80007b28:	40 46       	lddsp	r6,sp[0x10]
80007b2a:	ec 09 18 00 	cp.b	r9,r6
80007b2e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007b32:	30 29       	mov	r9,2
80007b34:	fa c8 f9 5c 	sub	r8,sp,-1700
80007b38:	1a d8       	st.w	--sp,r8
80007b3a:	fa c8 f9 54 	sub	r8,sp,-1708
80007b3e:	1a d8       	st.w	--sp,r8
80007b40:	fa c8 f9 4c 	sub	r8,sp,-1716
80007b44:	08 9c       	mov	r12,r4
80007b46:	1a d8       	st.w	--sp,r8
80007b48:	04 98       	mov	r8,r2
80007b4a:	40 9b       	lddsp	r11,sp[0x24]
80007b4c:	40 aa       	lddsp	r10,sp[0x28]
80007b4e:	e0 a0 0b c3 	rcall	800092d4 <_dtoa_r>
80007b52:	e0 40 00 47 	cp.w	r0,71
80007b56:	5f 19       	srne	r9
80007b58:	e0 40 00 67 	cp.w	r0,103
80007b5c:	5f 18       	srne	r8
80007b5e:	18 96       	mov	r6,r12
80007b60:	2f dd       	sub	sp,-12
80007b62:	f3 e8 00 08 	and	r8,r9,r8
80007b66:	c0 41       	brne	80007b6e <_vfprintf_r+0x9aa>
80007b68:	ed b5 00 00 	bld	r5,0x0
80007b6c:	c3 01       	brne	80007bcc <_vfprintf_r+0xa08>
80007b6e:	ec 02 00 0e 	add	lr,r6,r2
80007b72:	50 3e       	stdsp	sp[0xc],lr
80007b74:	40 4c       	lddsp	r12,sp[0x10]
80007b76:	58 0c       	cp.w	r12,0
80007b78:	c1 50       	breq	80007ba2 <_vfprintf_r+0x9de>
80007b7a:	0d 89       	ld.ub	r9,r6[0x0]
80007b7c:	33 08       	mov	r8,48
80007b7e:	f0 09 18 00 	cp.b	r9,r8
80007b82:	c0 b1       	brne	80007b98 <_vfprintf_r+0x9d4>
80007b84:	30 08       	mov	r8,0
80007b86:	30 09       	mov	r9,0
80007b88:	40 6b       	lddsp	r11,sp[0x18]
80007b8a:	40 7a       	lddsp	r10,sp[0x1c]
80007b8c:	e0 a0 1c cb 	rcall	8000b522 <__avr32_f64_cmp_eq>
80007b90:	fb b2 00 01 	rsubeq	r2,1
80007b94:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007b98:	40 3b       	lddsp	r11,sp[0xc]
80007b9a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007b9e:	10 0b       	add	r11,r8
80007ba0:	50 3b       	stdsp	sp[0xc],r11
80007ba2:	40 6b       	lddsp	r11,sp[0x18]
80007ba4:	30 08       	mov	r8,0
80007ba6:	30 09       	mov	r9,0
80007ba8:	40 7a       	lddsp	r10,sp[0x1c]
80007baa:	e0 a0 1c bc 	rcall	8000b522 <__avr32_f64_cmp_eq>
80007bae:	c0 90       	breq	80007bc0 <_vfprintf_r+0x9fc>
80007bb0:	40 3a       	lddsp	r10,sp[0xc]
80007bb2:	fb 4a 06 a4 	st.w	sp[1700],r10
80007bb6:	c0 58       	rjmp	80007bc0 <_vfprintf_r+0x9fc>
80007bb8:	10 c9       	st.b	r8++,r9
80007bba:	fb 48 06 a4 	st.w	sp[1700],r8
80007bbe:	c0 28       	rjmp	80007bc2 <_vfprintf_r+0x9fe>
80007bc0:	33 09       	mov	r9,48
80007bc2:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007bc6:	40 3e       	lddsp	lr,sp[0xc]
80007bc8:	1c 38       	cp.w	r8,lr
80007bca:	cf 73       	brcs	80007bb8 <_vfprintf_r+0x9f4>
80007bcc:	e0 40 00 47 	cp.w	r0,71
80007bd0:	5f 09       	sreq	r9
80007bd2:	e0 40 00 67 	cp.w	r0,103
80007bd6:	5f 08       	sreq	r8
80007bd8:	f3 e8 10 08 	or	r8,r9,r8
80007bdc:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007be0:	0c 19       	sub	r9,r6
80007be2:	50 69       	stdsp	sp[0x18],r9
80007be4:	58 08       	cp.w	r8,0
80007be6:	c0 b0       	breq	80007bfc <_vfprintf_r+0xa38>
80007be8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007bec:	5b d8       	cp.w	r8,-3
80007bee:	c0 55       	brlt	80007bf8 <_vfprintf_r+0xa34>
80007bf0:	40 2c       	lddsp	r12,sp[0x8]
80007bf2:	18 38       	cp.w	r8,r12
80007bf4:	e0 8a 00 6a 	brle	80007cc8 <_vfprintf_r+0xb04>
80007bf8:	20 20       	sub	r0,2
80007bfa:	c0 58       	rjmp	80007c04 <_vfprintf_r+0xa40>
80007bfc:	e0 40 00 65 	cp.w	r0,101
80007c00:	e0 89 00 46 	brgt	80007c8c <_vfprintf_r+0xac8>
80007c04:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007c08:	fb 60 06 9c 	st.b	sp[1692],r0
80007c0c:	20 1b       	sub	r11,1
80007c0e:	fb 4b 06 ac 	st.w	sp[1708],r11
80007c12:	c0 47       	brpl	80007c1a <_vfprintf_r+0xa56>
80007c14:	5c 3b       	neg	r11
80007c16:	32 d8       	mov	r8,45
80007c18:	c0 28       	rjmp	80007c1c <_vfprintf_r+0xa58>
80007c1a:	32 b8       	mov	r8,43
80007c1c:	fb 68 06 9d 	st.b	sp[1693],r8
80007c20:	58 9b       	cp.w	r11,9
80007c22:	e0 8a 00 1d 	brle	80007c5c <_vfprintf_r+0xa98>
80007c26:	fa c9 fa 35 	sub	r9,sp,-1483
80007c2a:	30 aa       	mov	r10,10
80007c2c:	12 98       	mov	r8,r9
80007c2e:	0e 9c       	mov	r12,r7
80007c30:	0c 92       	mov	r2,r6
80007c32:	f6 0a 0c 06 	divs	r6,r11,r10
80007c36:	0e 9b       	mov	r11,r7
80007c38:	2d 0b       	sub	r11,-48
80007c3a:	10 fb       	st.b	--r8,r11
80007c3c:	0c 9b       	mov	r11,r6
80007c3e:	58 96       	cp.w	r6,9
80007c40:	fe 99 ff f9 	brgt	80007c32 <_vfprintf_r+0xa6e>
80007c44:	2d 0b       	sub	r11,-48
80007c46:	18 97       	mov	r7,r12
80007c48:	04 96       	mov	r6,r2
80007c4a:	10 fb       	st.b	--r8,r11
80007c4c:	fa ca f9 62 	sub	r10,sp,-1694
80007c50:	c0 38       	rjmp	80007c56 <_vfprintf_r+0xa92>
80007c52:	11 3b       	ld.ub	r11,r8++
80007c54:	14 cb       	st.b	r10++,r11
80007c56:	12 38       	cp.w	r8,r9
80007c58:	cf d3       	brcs	80007c52 <_vfprintf_r+0xa8e>
80007c5a:	c0 98       	rjmp	80007c6c <_vfprintf_r+0xaa8>
80007c5c:	2d 0b       	sub	r11,-48
80007c5e:	33 08       	mov	r8,48
80007c60:	fb 6b 06 9f 	st.b	sp[1695],r11
80007c64:	fb 68 06 9e 	st.b	sp[1694],r8
80007c68:	fa ca f9 60 	sub	r10,sp,-1696
80007c6c:	fa c8 f9 64 	sub	r8,sp,-1692
80007c70:	f4 08 01 08 	sub	r8,r10,r8
80007c74:	50 e8       	stdsp	sp[0x38],r8
80007c76:	10 92       	mov	r2,r8
80007c78:	40 6b       	lddsp	r11,sp[0x18]
80007c7a:	16 02       	add	r2,r11
80007c7c:	58 1b       	cp.w	r11,1
80007c7e:	e0 89 00 05 	brgt	80007c88 <_vfprintf_r+0xac4>
80007c82:	ed b5 00 00 	bld	r5,0x0
80007c86:	c3 51       	brne	80007cf0 <_vfprintf_r+0xb2c>
80007c88:	2f f2       	sub	r2,-1
80007c8a:	c3 38       	rjmp	80007cf0 <_vfprintf_r+0xb2c>
80007c8c:	e0 40 00 66 	cp.w	r0,102
80007c90:	c1 c1       	brne	80007cc8 <_vfprintf_r+0xb04>
80007c92:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007c96:	58 02       	cp.w	r2,0
80007c98:	e0 8a 00 0c 	brle	80007cb0 <_vfprintf_r+0xaec>
80007c9c:	40 2a       	lddsp	r10,sp[0x8]
80007c9e:	58 0a       	cp.w	r10,0
80007ca0:	c0 41       	brne	80007ca8 <_vfprintf_r+0xae4>
80007ca2:	ed b5 00 00 	bld	r5,0x0
80007ca6:	c2 51       	brne	80007cf0 <_vfprintf_r+0xb2c>
80007ca8:	2f f2       	sub	r2,-1
80007caa:	40 29       	lddsp	r9,sp[0x8]
80007cac:	12 02       	add	r2,r9
80007cae:	c0 b8       	rjmp	80007cc4 <_vfprintf_r+0xb00>
80007cb0:	40 28       	lddsp	r8,sp[0x8]
80007cb2:	58 08       	cp.w	r8,0
80007cb4:	c0 61       	brne	80007cc0 <_vfprintf_r+0xafc>
80007cb6:	ed b5 00 00 	bld	r5,0x0
80007cba:	c0 30       	breq	80007cc0 <_vfprintf_r+0xafc>
80007cbc:	30 12       	mov	r2,1
80007cbe:	c1 98       	rjmp	80007cf0 <_vfprintf_r+0xb2c>
80007cc0:	40 22       	lddsp	r2,sp[0x8]
80007cc2:	2f e2       	sub	r2,-2
80007cc4:	36 60       	mov	r0,102
80007cc6:	c1 58       	rjmp	80007cf0 <_vfprintf_r+0xb2c>
80007cc8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007ccc:	40 6e       	lddsp	lr,sp[0x18]
80007cce:	1c 32       	cp.w	r2,lr
80007cd0:	c0 65       	brlt	80007cdc <_vfprintf_r+0xb18>
80007cd2:	ed b5 00 00 	bld	r5,0x0
80007cd6:	f7 b2 00 ff 	subeq	r2,-1
80007cda:	c0 a8       	rjmp	80007cee <_vfprintf_r+0xb2a>
80007cdc:	e4 08 11 02 	rsub	r8,r2,2
80007ce0:	40 6c       	lddsp	r12,sp[0x18]
80007ce2:	58 02       	cp.w	r2,0
80007ce4:	f0 02 17 a0 	movle	r2,r8
80007ce8:	f9 b2 09 01 	movgt	r2,1
80007cec:	18 02       	add	r2,r12
80007cee:	36 70       	mov	r0,103
80007cf0:	40 9b       	lddsp	r11,sp[0x24]
80007cf2:	58 0b       	cp.w	r11,0
80007cf4:	e0 80 05 94 	breq	8000881c <_vfprintf_r+0x1658>
80007cf8:	32 d8       	mov	r8,45
80007cfa:	fb 68 06 bb 	st.b	sp[1723],r8
80007cfe:	e0 8f 05 93 	bral	80008824 <_vfprintf_r+0x1660>
80007d02:	50 a7       	stdsp	sp[0x28],r7
80007d04:	04 94       	mov	r4,r2
80007d06:	0c 97       	mov	r7,r6
80007d08:	02 92       	mov	r2,r1
80007d0a:	06 96       	mov	r6,r3
80007d0c:	40 41       	lddsp	r1,sp[0x10]
80007d0e:	40 93       	lddsp	r3,sp[0x24]
80007d10:	0e 99       	mov	r9,r7
80007d12:	ed b5 00 05 	bld	r5,0x5
80007d16:	c4 81       	brne	80007da6 <_vfprintf_r+0xbe2>
80007d18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d1c:	40 3e       	lddsp	lr,sp[0xc]
80007d1e:	58 0e       	cp.w	lr,0
80007d20:	c1 d0       	breq	80007d5a <_vfprintf_r+0xb96>
80007d22:	10 36       	cp.w	r6,r8
80007d24:	c0 64       	brge	80007d30 <_vfprintf_r+0xb6c>
80007d26:	fa cc f9 44 	sub	r12,sp,-1724
80007d2a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d2e:	c1 d8       	rjmp	80007d68 <_vfprintf_r+0xba4>
80007d30:	fa c8 f9 50 	sub	r8,sp,-1712
80007d34:	1a d8       	st.w	--sp,r8
80007d36:	fa c8 fa b8 	sub	r8,sp,-1352
80007d3a:	04 9a       	mov	r10,r2
80007d3c:	1a d8       	st.w	--sp,r8
80007d3e:	fa c8 fb b4 	sub	r8,sp,-1100
80007d42:	0c 9b       	mov	r11,r6
80007d44:	1a d8       	st.w	--sp,r8
80007d46:	08 9c       	mov	r12,r4
80007d48:	fa c8 f9 40 	sub	r8,sp,-1728
80007d4c:	fa c9 ff b4 	sub	r9,sp,-76
80007d50:	fe b0 f8 a2 	rcall	80006e94 <get_arg>
80007d54:	2f dd       	sub	sp,-12
80007d56:	78 0a       	ld.w	r10,r12[0x0]
80007d58:	c2 08       	rjmp	80007d98 <_vfprintf_r+0xbd4>
80007d5a:	2f f7       	sub	r7,-1
80007d5c:	10 39       	cp.w	r9,r8
80007d5e:	c0 84       	brge	80007d6e <_vfprintf_r+0xbaa>
80007d60:	fa cb f9 44 	sub	r11,sp,-1724
80007d64:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d68:	ec fa fd 88 	ld.w	r10,r6[-632]
80007d6c:	c1 68       	rjmp	80007d98 <_vfprintf_r+0xbd4>
80007d6e:	41 09       	lddsp	r9,sp[0x40]
80007d70:	59 f8       	cp.w	r8,31
80007d72:	e0 89 00 10 	brgt	80007d92 <_vfprintf_r+0xbce>
80007d76:	f2 ca ff fc 	sub	r10,r9,-4
80007d7a:	51 0a       	stdsp	sp[0x40],r10
80007d7c:	fa c6 f9 44 	sub	r6,sp,-1724
80007d80:	72 0a       	ld.w	r10,r9[0x0]
80007d82:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d86:	f3 4a fd 88 	st.w	r9[-632],r10
80007d8a:	2f f8       	sub	r8,-1
80007d8c:	fb 48 06 b4 	st.w	sp[1716],r8
80007d90:	c0 48       	rjmp	80007d98 <_vfprintf_r+0xbd4>
80007d92:	72 0a       	ld.w	r10,r9[0x0]
80007d94:	2f c9       	sub	r9,-4
80007d96:	51 09       	stdsp	sp[0x40],r9
80007d98:	40 be       	lddsp	lr,sp[0x2c]
80007d9a:	1c 98       	mov	r8,lr
80007d9c:	95 1e       	st.w	r10[0x4],lr
80007d9e:	bf 58       	asr	r8,0x1f
80007da0:	95 08       	st.w	r10[0x0],r8
80007da2:	fe 9f fa 9f 	bral	800072e0 <_vfprintf_r+0x11c>
80007da6:	ed b5 00 04 	bld	r5,0x4
80007daa:	c4 80       	breq	80007e3a <_vfprintf_r+0xc76>
80007dac:	e2 15 00 40 	andl	r5,0x40,COH
80007db0:	c4 50       	breq	80007e3a <_vfprintf_r+0xc76>
80007db2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007db6:	40 3c       	lddsp	r12,sp[0xc]
80007db8:	58 0c       	cp.w	r12,0
80007dba:	c1 d0       	breq	80007df4 <_vfprintf_r+0xc30>
80007dbc:	10 36       	cp.w	r6,r8
80007dbe:	c0 64       	brge	80007dca <_vfprintf_r+0xc06>
80007dc0:	fa cb f9 44 	sub	r11,sp,-1724
80007dc4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007dc8:	c1 d8       	rjmp	80007e02 <_vfprintf_r+0xc3e>
80007dca:	fa c8 f9 50 	sub	r8,sp,-1712
80007dce:	1a d8       	st.w	--sp,r8
80007dd0:	fa c8 fa b8 	sub	r8,sp,-1352
80007dd4:	04 9a       	mov	r10,r2
80007dd6:	1a d8       	st.w	--sp,r8
80007dd8:	fa c8 fb b4 	sub	r8,sp,-1100
80007ddc:	0c 9b       	mov	r11,r6
80007dde:	1a d8       	st.w	--sp,r8
80007de0:	08 9c       	mov	r12,r4
80007de2:	fa c8 f9 40 	sub	r8,sp,-1728
80007de6:	fa c9 ff b4 	sub	r9,sp,-76
80007dea:	fe b0 f8 55 	rcall	80006e94 <get_arg>
80007dee:	2f dd       	sub	sp,-12
80007df0:	78 0a       	ld.w	r10,r12[0x0]
80007df2:	c2 08       	rjmp	80007e32 <_vfprintf_r+0xc6e>
80007df4:	2f f7       	sub	r7,-1
80007df6:	10 39       	cp.w	r9,r8
80007df8:	c0 84       	brge	80007e08 <_vfprintf_r+0xc44>
80007dfa:	fa ca f9 44 	sub	r10,sp,-1724
80007dfe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e02:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e06:	c1 68       	rjmp	80007e32 <_vfprintf_r+0xc6e>
80007e08:	41 09       	lddsp	r9,sp[0x40]
80007e0a:	59 f8       	cp.w	r8,31
80007e0c:	e0 89 00 10 	brgt	80007e2c <_vfprintf_r+0xc68>
80007e10:	f2 ca ff fc 	sub	r10,r9,-4
80007e14:	51 0a       	stdsp	sp[0x40],r10
80007e16:	fa c6 f9 44 	sub	r6,sp,-1724
80007e1a:	72 0a       	ld.w	r10,r9[0x0]
80007e1c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e20:	f3 4a fd 88 	st.w	r9[-632],r10
80007e24:	2f f8       	sub	r8,-1
80007e26:	fb 48 06 b4 	st.w	sp[1716],r8
80007e2a:	c0 48       	rjmp	80007e32 <_vfprintf_r+0xc6e>
80007e2c:	72 0a       	ld.w	r10,r9[0x0]
80007e2e:	2f c9       	sub	r9,-4
80007e30:	51 09       	stdsp	sp[0x40],r9
80007e32:	40 be       	lddsp	lr,sp[0x2c]
80007e34:	b4 0e       	st.h	r10[0x0],lr
80007e36:	fe 9f fa 55 	bral	800072e0 <_vfprintf_r+0x11c>
80007e3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e3e:	40 3c       	lddsp	r12,sp[0xc]
80007e40:	58 0c       	cp.w	r12,0
80007e42:	c1 d0       	breq	80007e7c <_vfprintf_r+0xcb8>
80007e44:	10 36       	cp.w	r6,r8
80007e46:	c0 64       	brge	80007e52 <_vfprintf_r+0xc8e>
80007e48:	fa cb f9 44 	sub	r11,sp,-1724
80007e4c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e50:	c1 d8       	rjmp	80007e8a <_vfprintf_r+0xcc6>
80007e52:	fa c8 f9 50 	sub	r8,sp,-1712
80007e56:	1a d8       	st.w	--sp,r8
80007e58:	fa c8 fa b8 	sub	r8,sp,-1352
80007e5c:	04 9a       	mov	r10,r2
80007e5e:	1a d8       	st.w	--sp,r8
80007e60:	fa c8 fb b4 	sub	r8,sp,-1100
80007e64:	0c 9b       	mov	r11,r6
80007e66:	1a d8       	st.w	--sp,r8
80007e68:	08 9c       	mov	r12,r4
80007e6a:	fa c8 f9 40 	sub	r8,sp,-1728
80007e6e:	fa c9 ff b4 	sub	r9,sp,-76
80007e72:	fe b0 f8 11 	rcall	80006e94 <get_arg>
80007e76:	2f dd       	sub	sp,-12
80007e78:	78 0a       	ld.w	r10,r12[0x0]
80007e7a:	c2 08       	rjmp	80007eba <_vfprintf_r+0xcf6>
80007e7c:	2f f7       	sub	r7,-1
80007e7e:	10 39       	cp.w	r9,r8
80007e80:	c0 84       	brge	80007e90 <_vfprintf_r+0xccc>
80007e82:	fa ca f9 44 	sub	r10,sp,-1724
80007e86:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e8a:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e8e:	c1 68       	rjmp	80007eba <_vfprintf_r+0xcf6>
80007e90:	41 09       	lddsp	r9,sp[0x40]
80007e92:	59 f8       	cp.w	r8,31
80007e94:	e0 89 00 10 	brgt	80007eb4 <_vfprintf_r+0xcf0>
80007e98:	f2 ca ff fc 	sub	r10,r9,-4
80007e9c:	51 0a       	stdsp	sp[0x40],r10
80007e9e:	fa c6 f9 44 	sub	r6,sp,-1724
80007ea2:	72 0a       	ld.w	r10,r9[0x0]
80007ea4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ea8:	f3 4a fd 88 	st.w	r9[-632],r10
80007eac:	2f f8       	sub	r8,-1
80007eae:	fb 48 06 b4 	st.w	sp[1716],r8
80007eb2:	c0 48       	rjmp	80007eba <_vfprintf_r+0xcf6>
80007eb4:	72 0a       	ld.w	r10,r9[0x0]
80007eb6:	2f c9       	sub	r9,-4
80007eb8:	51 09       	stdsp	sp[0x40],r9
80007eba:	40 be       	lddsp	lr,sp[0x2c]
80007ebc:	95 0e       	st.w	r10[0x0],lr
80007ebe:	fe 9f fa 11 	bral	800072e0 <_vfprintf_r+0x11c>
80007ec2:	50 a7       	stdsp	sp[0x28],r7
80007ec4:	50 80       	stdsp	sp[0x20],r0
80007ec6:	0c 97       	mov	r7,r6
80007ec8:	04 94       	mov	r4,r2
80007eca:	06 96       	mov	r6,r3
80007ecc:	02 92       	mov	r2,r1
80007ece:	40 93       	lddsp	r3,sp[0x24]
80007ed0:	10 90       	mov	r0,r8
80007ed2:	40 41       	lddsp	r1,sp[0x10]
80007ed4:	a5 a5       	sbr	r5,0x4
80007ed6:	c0 a8       	rjmp	80007eea <_vfprintf_r+0xd26>
80007ed8:	50 a7       	stdsp	sp[0x28],r7
80007eda:	50 80       	stdsp	sp[0x20],r0
80007edc:	0c 97       	mov	r7,r6
80007ede:	04 94       	mov	r4,r2
80007ee0:	06 96       	mov	r6,r3
80007ee2:	02 92       	mov	r2,r1
80007ee4:	40 93       	lddsp	r3,sp[0x24]
80007ee6:	10 90       	mov	r0,r8
80007ee8:	40 41       	lddsp	r1,sp[0x10]
80007eea:	ed b5 00 05 	bld	r5,0x5
80007eee:	c5 d1       	brne	80007fa8 <_vfprintf_r+0xde4>
80007ef0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ef4:	40 3c       	lddsp	r12,sp[0xc]
80007ef6:	58 0c       	cp.w	r12,0
80007ef8:	c2 60       	breq	80007f44 <_vfprintf_r+0xd80>
80007efa:	10 36       	cp.w	r6,r8
80007efc:	c0 a4       	brge	80007f10 <_vfprintf_r+0xd4c>
80007efe:	fa cb f9 44 	sub	r11,sp,-1724
80007f02:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f06:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007f0a:	fa e9 00 00 	st.d	sp[0],r8
80007f0e:	c1 88       	rjmp	80007f3e <_vfprintf_r+0xd7a>
80007f10:	fa c8 f9 50 	sub	r8,sp,-1712
80007f14:	1a d8       	st.w	--sp,r8
80007f16:	fa c8 fa b8 	sub	r8,sp,-1352
80007f1a:	04 9a       	mov	r10,r2
80007f1c:	1a d8       	st.w	--sp,r8
80007f1e:	0c 9b       	mov	r11,r6
80007f20:	fa c8 fb b4 	sub	r8,sp,-1100
80007f24:	08 9c       	mov	r12,r4
80007f26:	1a d8       	st.w	--sp,r8
80007f28:	fa c8 f9 40 	sub	r8,sp,-1728
80007f2c:	fa c9 ff b4 	sub	r9,sp,-76
80007f30:	fe b0 f7 b2 	rcall	80006e94 <get_arg>
80007f34:	2f dd       	sub	sp,-12
80007f36:	f8 ea 00 00 	ld.d	r10,r12[0]
80007f3a:	fa eb 00 00 	st.d	sp[0],r10
80007f3e:	30 08       	mov	r8,0
80007f40:	e0 8f 03 de 	bral	800086fc <_vfprintf_r+0x1538>
80007f44:	ee ca ff ff 	sub	r10,r7,-1
80007f48:	10 37       	cp.w	r7,r8
80007f4a:	c0 b4       	brge	80007f60 <_vfprintf_r+0xd9c>
80007f4c:	fa c9 f9 44 	sub	r9,sp,-1724
80007f50:	14 97       	mov	r7,r10
80007f52:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f56:	ec ea fd 88 	ld.d	r10,r6[-632]
80007f5a:	fa eb 00 00 	st.d	sp[0],r10
80007f5e:	c1 88       	rjmp	80007f8e <_vfprintf_r+0xdca>
80007f60:	41 09       	lddsp	r9,sp[0x40]
80007f62:	59 f8       	cp.w	r8,31
80007f64:	e0 89 00 18 	brgt	80007f94 <_vfprintf_r+0xdd0>
80007f68:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f6c:	f2 cb ff f8 	sub	r11,r9,-8
80007f70:	fa e7 00 00 	st.d	sp[0],r6
80007f74:	51 0b       	stdsp	sp[0x40],r11
80007f76:	fa c6 f9 44 	sub	r6,sp,-1724
80007f7a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f7e:	fa e6 00 00 	ld.d	r6,sp[0]
80007f82:	f2 e7 fd 88 	st.d	r9[-632],r6
80007f86:	2f f8       	sub	r8,-1
80007f88:	14 97       	mov	r7,r10
80007f8a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f8e:	40 38       	lddsp	r8,sp[0xc]
80007f90:	e0 8f 03 b6 	bral	800086fc <_vfprintf_r+0x1538>
80007f94:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f98:	40 38       	lddsp	r8,sp[0xc]
80007f9a:	fa e7 00 00 	st.d	sp[0],r6
80007f9e:	2f 89       	sub	r9,-8
80007fa0:	14 97       	mov	r7,r10
80007fa2:	51 09       	stdsp	sp[0x40],r9
80007fa4:	e0 8f 03 ac 	bral	800086fc <_vfprintf_r+0x1538>
80007fa8:	ed b5 00 04 	bld	r5,0x4
80007fac:	c1 61       	brne	80007fd8 <_vfprintf_r+0xe14>
80007fae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fb2:	40 3e       	lddsp	lr,sp[0xc]
80007fb4:	58 0e       	cp.w	lr,0
80007fb6:	c0 80       	breq	80007fc6 <_vfprintf_r+0xe02>
80007fb8:	10 36       	cp.w	r6,r8
80007fba:	c6 74       	brge	80008088 <_vfprintf_r+0xec4>
80007fbc:	fa cc f9 44 	sub	r12,sp,-1724
80007fc0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007fc4:	c8 08       	rjmp	800080c4 <_vfprintf_r+0xf00>
80007fc6:	ee ca ff ff 	sub	r10,r7,-1
80007fca:	10 37       	cp.w	r7,r8
80007fcc:	c7 f4       	brge	800080ca <_vfprintf_r+0xf06>
80007fce:	fa cb f9 44 	sub	r11,sp,-1724
80007fd2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fd6:	c7 68       	rjmp	800080c2 <_vfprintf_r+0xefe>
80007fd8:	ed b5 00 06 	bld	r5,0x6
80007fdc:	c4 a1       	brne	80008070 <_vfprintf_r+0xeac>
80007fde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fe2:	40 3c       	lddsp	r12,sp[0xc]
80007fe4:	58 0c       	cp.w	r12,0
80007fe6:	c1 d0       	breq	80008020 <_vfprintf_r+0xe5c>
80007fe8:	10 36       	cp.w	r6,r8
80007fea:	c0 64       	brge	80007ff6 <_vfprintf_r+0xe32>
80007fec:	fa cb f9 44 	sub	r11,sp,-1724
80007ff0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ff4:	c1 f8       	rjmp	80008032 <_vfprintf_r+0xe6e>
80007ff6:	fa c8 f9 50 	sub	r8,sp,-1712
80007ffa:	1a d8       	st.w	--sp,r8
80007ffc:	fa c8 fa b8 	sub	r8,sp,-1352
80008000:	1a d8       	st.w	--sp,r8
80008002:	fa c8 fb b4 	sub	r8,sp,-1100
80008006:	1a d8       	st.w	--sp,r8
80008008:	fa c8 f9 40 	sub	r8,sp,-1728
8000800c:	fa c9 ff b4 	sub	r9,sp,-76
80008010:	04 9a       	mov	r10,r2
80008012:	0c 9b       	mov	r11,r6
80008014:	08 9c       	mov	r12,r4
80008016:	fe b0 f7 3f 	rcall	80006e94 <get_arg>
8000801a:	2f dd       	sub	sp,-12
8000801c:	98 18       	ld.sh	r8,r12[0x2]
8000801e:	c2 68       	rjmp	8000806a <_vfprintf_r+0xea6>
80008020:	ee ca ff ff 	sub	r10,r7,-1
80008024:	10 37       	cp.w	r7,r8
80008026:	c0 94       	brge	80008038 <_vfprintf_r+0xe74>
80008028:	fa c9 f9 44 	sub	r9,sp,-1724
8000802c:	14 97       	mov	r7,r10
8000802e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008032:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008036:	c1 a8       	rjmp	8000806a <_vfprintf_r+0xea6>
80008038:	41 09       	lddsp	r9,sp[0x40]
8000803a:	59 f8       	cp.w	r8,31
8000803c:	e0 89 00 13 	brgt	80008062 <_vfprintf_r+0xe9e>
80008040:	f2 cb ff fc 	sub	r11,r9,-4
80008044:	51 0b       	stdsp	sp[0x40],r11
80008046:	72 09       	ld.w	r9,r9[0x0]
80008048:	fa c6 f9 44 	sub	r6,sp,-1724
8000804c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008050:	2f f8       	sub	r8,-1
80008052:	f7 49 fd 88 	st.w	r11[-632],r9
80008056:	fb 48 06 b4 	st.w	sp[1716],r8
8000805a:	14 97       	mov	r7,r10
8000805c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008060:	c0 58       	rjmp	8000806a <_vfprintf_r+0xea6>
80008062:	92 18       	ld.sh	r8,r9[0x2]
80008064:	14 97       	mov	r7,r10
80008066:	2f c9       	sub	r9,-4
80008068:	51 09       	stdsp	sp[0x40],r9
8000806a:	5c 78       	castu.h	r8
8000806c:	50 18       	stdsp	sp[0x4],r8
8000806e:	c4 68       	rjmp	800080fa <_vfprintf_r+0xf36>
80008070:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008074:	40 3c       	lddsp	r12,sp[0xc]
80008076:	58 0c       	cp.w	r12,0
80008078:	c1 d0       	breq	800080b2 <_vfprintf_r+0xeee>
8000807a:	10 36       	cp.w	r6,r8
8000807c:	c0 64       	brge	80008088 <_vfprintf_r+0xec4>
8000807e:	fa cb f9 44 	sub	r11,sp,-1724
80008082:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008086:	c1 f8       	rjmp	800080c4 <_vfprintf_r+0xf00>
80008088:	fa c8 f9 50 	sub	r8,sp,-1712
8000808c:	1a d8       	st.w	--sp,r8
8000808e:	fa c8 fa b8 	sub	r8,sp,-1352
80008092:	0c 9b       	mov	r11,r6
80008094:	1a d8       	st.w	--sp,r8
80008096:	fa c8 fb b4 	sub	r8,sp,-1100
8000809a:	04 9a       	mov	r10,r2
8000809c:	1a d8       	st.w	--sp,r8
8000809e:	08 9c       	mov	r12,r4
800080a0:	fa c8 f9 40 	sub	r8,sp,-1728
800080a4:	fa c9 ff b4 	sub	r9,sp,-76
800080a8:	fe b0 f6 f6 	rcall	80006e94 <get_arg>
800080ac:	2f dd       	sub	sp,-12
800080ae:	78 0b       	ld.w	r11,r12[0x0]
800080b0:	c2 48       	rjmp	800080f8 <_vfprintf_r+0xf34>
800080b2:	ee ca ff ff 	sub	r10,r7,-1
800080b6:	10 37       	cp.w	r7,r8
800080b8:	c0 94       	brge	800080ca <_vfprintf_r+0xf06>
800080ba:	fa c9 f9 44 	sub	r9,sp,-1724
800080be:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080c2:	14 97       	mov	r7,r10
800080c4:	ec fb fd 88 	ld.w	r11,r6[-632]
800080c8:	c1 88       	rjmp	800080f8 <_vfprintf_r+0xf34>
800080ca:	41 09       	lddsp	r9,sp[0x40]
800080cc:	59 f8       	cp.w	r8,31
800080ce:	e0 89 00 11 	brgt	800080f0 <_vfprintf_r+0xf2c>
800080d2:	f2 cb ff fc 	sub	r11,r9,-4
800080d6:	51 0b       	stdsp	sp[0x40],r11
800080d8:	fa c6 f9 44 	sub	r6,sp,-1724
800080dc:	72 0b       	ld.w	r11,r9[0x0]
800080de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080e2:	f3 4b fd 88 	st.w	r9[-632],r11
800080e6:	2f f8       	sub	r8,-1
800080e8:	14 97       	mov	r7,r10
800080ea:	fb 48 06 b4 	st.w	sp[1716],r8
800080ee:	c0 58       	rjmp	800080f8 <_vfprintf_r+0xf34>
800080f0:	72 0b       	ld.w	r11,r9[0x0]
800080f2:	14 97       	mov	r7,r10
800080f4:	2f c9       	sub	r9,-4
800080f6:	51 09       	stdsp	sp[0x40],r9
800080f8:	50 1b       	stdsp	sp[0x4],r11
800080fa:	30 0e       	mov	lr,0
800080fc:	50 0e       	stdsp	sp[0x0],lr
800080fe:	1c 98       	mov	r8,lr
80008100:	e0 8f 02 fe 	bral	800086fc <_vfprintf_r+0x1538>
80008104:	50 a7       	stdsp	sp[0x28],r7
80008106:	50 80       	stdsp	sp[0x20],r0
80008108:	0c 97       	mov	r7,r6
8000810a:	04 94       	mov	r4,r2
8000810c:	06 96       	mov	r6,r3
8000810e:	02 92       	mov	r2,r1
80008110:	40 93       	lddsp	r3,sp[0x24]
80008112:	40 41       	lddsp	r1,sp[0x10]
80008114:	0e 99       	mov	r9,r7
80008116:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000811a:	40 3c       	lddsp	r12,sp[0xc]
8000811c:	58 0c       	cp.w	r12,0
8000811e:	c1 d0       	breq	80008158 <_vfprintf_r+0xf94>
80008120:	10 36       	cp.w	r6,r8
80008122:	c0 64       	brge	8000812e <_vfprintf_r+0xf6a>
80008124:	fa cb f9 44 	sub	r11,sp,-1724
80008128:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000812c:	c1 d8       	rjmp	80008166 <_vfprintf_r+0xfa2>
8000812e:	fa c8 f9 50 	sub	r8,sp,-1712
80008132:	1a d8       	st.w	--sp,r8
80008134:	fa c8 fa b8 	sub	r8,sp,-1352
80008138:	1a d8       	st.w	--sp,r8
8000813a:	fa c8 fb b4 	sub	r8,sp,-1100
8000813e:	1a d8       	st.w	--sp,r8
80008140:	fa c9 ff b4 	sub	r9,sp,-76
80008144:	fa c8 f9 40 	sub	r8,sp,-1728
80008148:	04 9a       	mov	r10,r2
8000814a:	0c 9b       	mov	r11,r6
8000814c:	08 9c       	mov	r12,r4
8000814e:	fe b0 f6 a3 	rcall	80006e94 <get_arg>
80008152:	2f dd       	sub	sp,-12
80008154:	78 09       	ld.w	r9,r12[0x0]
80008156:	c2 18       	rjmp	80008198 <_vfprintf_r+0xfd4>
80008158:	2f f7       	sub	r7,-1
8000815a:	10 39       	cp.w	r9,r8
8000815c:	c0 84       	brge	8000816c <_vfprintf_r+0xfa8>
8000815e:	fa ca f9 44 	sub	r10,sp,-1724
80008162:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008166:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000816a:	c1 78       	rjmp	80008198 <_vfprintf_r+0xfd4>
8000816c:	41 09       	lddsp	r9,sp[0x40]
8000816e:	59 f8       	cp.w	r8,31
80008170:	e0 89 00 10 	brgt	80008190 <_vfprintf_r+0xfcc>
80008174:	f2 ca ff fc 	sub	r10,r9,-4
80008178:	51 0a       	stdsp	sp[0x40],r10
8000817a:	fa c6 f9 44 	sub	r6,sp,-1724
8000817e:	72 09       	ld.w	r9,r9[0x0]
80008180:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008184:	f5 49 fd 88 	st.w	r10[-632],r9
80008188:	2f f8       	sub	r8,-1
8000818a:	fb 48 06 b4 	st.w	sp[1716],r8
8000818e:	c0 58       	rjmp	80008198 <_vfprintf_r+0xfd4>
80008190:	f2 c8 ff fc 	sub	r8,r9,-4
80008194:	51 08       	stdsp	sp[0x40],r8
80008196:	72 09       	ld.w	r9,r9[0x0]
80008198:	33 08       	mov	r8,48
8000819a:	fb 68 06 b8 	st.b	sp[1720],r8
8000819e:	37 88       	mov	r8,120
800081a0:	30 0e       	mov	lr,0
800081a2:	fb 68 06 b9 	st.b	sp[1721],r8
800081a6:	fe cc b3 5e 	sub	r12,pc,-19618
800081aa:	50 19       	stdsp	sp[0x4],r9
800081ac:	a1 b5       	sbr	r5,0x1
800081ae:	50 0e       	stdsp	sp[0x0],lr
800081b0:	50 dc       	stdsp	sp[0x34],r12
800081b2:	30 28       	mov	r8,2
800081b4:	37 80       	mov	r0,120
800081b6:	e0 8f 02 a3 	bral	800086fc <_vfprintf_r+0x1538>
800081ba:	50 a7       	stdsp	sp[0x28],r7
800081bc:	50 80       	stdsp	sp[0x20],r0
800081be:	10 90       	mov	r0,r8
800081c0:	30 08       	mov	r8,0
800081c2:	fb 68 06 bb 	st.b	sp[1723],r8
800081c6:	0c 97       	mov	r7,r6
800081c8:	04 94       	mov	r4,r2
800081ca:	06 96       	mov	r6,r3
800081cc:	02 92       	mov	r2,r1
800081ce:	40 93       	lddsp	r3,sp[0x24]
800081d0:	40 41       	lddsp	r1,sp[0x10]
800081d2:	0e 99       	mov	r9,r7
800081d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081d8:	40 3b       	lddsp	r11,sp[0xc]
800081da:	58 0b       	cp.w	r11,0
800081dc:	c1 d0       	breq	80008216 <_vfprintf_r+0x1052>
800081de:	10 36       	cp.w	r6,r8
800081e0:	c0 64       	brge	800081ec <_vfprintf_r+0x1028>
800081e2:	fa ca f9 44 	sub	r10,sp,-1724
800081e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800081ea:	c1 d8       	rjmp	80008224 <_vfprintf_r+0x1060>
800081ec:	fa c8 f9 50 	sub	r8,sp,-1712
800081f0:	1a d8       	st.w	--sp,r8
800081f2:	fa c8 fa b8 	sub	r8,sp,-1352
800081f6:	1a d8       	st.w	--sp,r8
800081f8:	fa c8 fb b4 	sub	r8,sp,-1100
800081fc:	0c 9b       	mov	r11,r6
800081fe:	1a d8       	st.w	--sp,r8
80008200:	04 9a       	mov	r10,r2
80008202:	fa c8 f9 40 	sub	r8,sp,-1728
80008206:	fa c9 ff b4 	sub	r9,sp,-76
8000820a:	08 9c       	mov	r12,r4
8000820c:	fe b0 f6 44 	rcall	80006e94 <get_arg>
80008210:	2f dd       	sub	sp,-12
80008212:	78 06       	ld.w	r6,r12[0x0]
80008214:	c2 08       	rjmp	80008254 <_vfprintf_r+0x1090>
80008216:	2f f7       	sub	r7,-1
80008218:	10 39       	cp.w	r9,r8
8000821a:	c0 84       	brge	8000822a <_vfprintf_r+0x1066>
8000821c:	fa c9 f9 44 	sub	r9,sp,-1724
80008220:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008224:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008228:	c1 68       	rjmp	80008254 <_vfprintf_r+0x1090>
8000822a:	41 09       	lddsp	r9,sp[0x40]
8000822c:	59 f8       	cp.w	r8,31
8000822e:	e0 89 00 10 	brgt	8000824e <_vfprintf_r+0x108a>
80008232:	f2 ca ff fc 	sub	r10,r9,-4
80008236:	51 0a       	stdsp	sp[0x40],r10
80008238:	72 06       	ld.w	r6,r9[0x0]
8000823a:	fa ce f9 44 	sub	lr,sp,-1724
8000823e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008242:	f3 46 fd 88 	st.w	r9[-632],r6
80008246:	2f f8       	sub	r8,-1
80008248:	fb 48 06 b4 	st.w	sp[1716],r8
8000824c:	c0 48       	rjmp	80008254 <_vfprintf_r+0x1090>
8000824e:	72 06       	ld.w	r6,r9[0x0]
80008250:	2f c9       	sub	r9,-4
80008252:	51 09       	stdsp	sp[0x40],r9
80008254:	40 2c       	lddsp	r12,sp[0x8]
80008256:	58 0c       	cp.w	r12,0
80008258:	c1 05       	brlt	80008278 <_vfprintf_r+0x10b4>
8000825a:	18 9a       	mov	r10,r12
8000825c:	30 0b       	mov	r11,0
8000825e:	0c 9c       	mov	r12,r6
80008260:	e0 a0 12 38 	rcall	8000a6d0 <memchr>
80008264:	e0 80 02 df 	breq	80008822 <_vfprintf_r+0x165e>
80008268:	f8 06 01 02 	sub	r2,r12,r6
8000826c:	40 2b       	lddsp	r11,sp[0x8]
8000826e:	16 32       	cp.w	r2,r11
80008270:	e0 89 02 d9 	brgt	80008822 <_vfprintf_r+0x165e>
80008274:	e0 8f 02 d4 	bral	8000881c <_vfprintf_r+0x1658>
80008278:	30 0a       	mov	r10,0
8000827a:	0c 9c       	mov	r12,r6
8000827c:	50 2a       	stdsp	sp[0x8],r10
8000827e:	fe b0 f5 85 	rcall	80006d88 <strlen>
80008282:	18 92       	mov	r2,r12
80008284:	e0 8f 02 d2 	bral	80008828 <_vfprintf_r+0x1664>
80008288:	50 a7       	stdsp	sp[0x28],r7
8000828a:	50 80       	stdsp	sp[0x20],r0
8000828c:	0c 97       	mov	r7,r6
8000828e:	04 94       	mov	r4,r2
80008290:	06 96       	mov	r6,r3
80008292:	02 92       	mov	r2,r1
80008294:	40 93       	lddsp	r3,sp[0x24]
80008296:	10 90       	mov	r0,r8
80008298:	40 41       	lddsp	r1,sp[0x10]
8000829a:	a5 a5       	sbr	r5,0x4
8000829c:	c0 a8       	rjmp	800082b0 <_vfprintf_r+0x10ec>
8000829e:	50 a7       	stdsp	sp[0x28],r7
800082a0:	50 80       	stdsp	sp[0x20],r0
800082a2:	0c 97       	mov	r7,r6
800082a4:	04 94       	mov	r4,r2
800082a6:	06 96       	mov	r6,r3
800082a8:	02 92       	mov	r2,r1
800082aa:	40 93       	lddsp	r3,sp[0x24]
800082ac:	10 90       	mov	r0,r8
800082ae:	40 41       	lddsp	r1,sp[0x10]
800082b0:	ed b5 00 05 	bld	r5,0x5
800082b4:	c5 61       	brne	80008360 <_vfprintf_r+0x119c>
800082b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082ba:	40 39       	lddsp	r9,sp[0xc]
800082bc:	58 09       	cp.w	r9,0
800082be:	c2 10       	breq	80008300 <_vfprintf_r+0x113c>
800082c0:	10 36       	cp.w	r6,r8
800082c2:	c0 74       	brge	800082d0 <_vfprintf_r+0x110c>
800082c4:	fa c8 f9 44 	sub	r8,sp,-1724
800082c8:	f0 06 00 36 	add	r6,r8,r6<<0x3
800082cc:	c2 38       	rjmp	80008312 <_vfprintf_r+0x114e>
800082ce:	d7 03       	nop
800082d0:	fa c8 f9 50 	sub	r8,sp,-1712
800082d4:	1a d8       	st.w	--sp,r8
800082d6:	fa c8 fa b8 	sub	r8,sp,-1352
800082da:	1a d8       	st.w	--sp,r8
800082dc:	fa c8 fb b4 	sub	r8,sp,-1100
800082e0:	1a d8       	st.w	--sp,r8
800082e2:	fa c8 f9 40 	sub	r8,sp,-1728
800082e6:	fa c9 ff b4 	sub	r9,sp,-76
800082ea:	04 9a       	mov	r10,r2
800082ec:	0c 9b       	mov	r11,r6
800082ee:	08 9c       	mov	r12,r4
800082f0:	fe b0 f5 d2 	rcall	80006e94 <get_arg>
800082f4:	2f dd       	sub	sp,-12
800082f6:	f8 e8 00 00 	ld.d	r8,r12[0]
800082fa:	fa e9 00 00 	st.d	sp[0],r8
800082fe:	c2 e8       	rjmp	8000835a <_vfprintf_r+0x1196>
80008300:	ee ca ff ff 	sub	r10,r7,-1
80008304:	10 37       	cp.w	r7,r8
80008306:	c0 b4       	brge	8000831c <_vfprintf_r+0x1158>
80008308:	fa c8 f9 44 	sub	r8,sp,-1724
8000830c:	14 97       	mov	r7,r10
8000830e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008312:	ec ea fd 88 	ld.d	r10,r6[-632]
80008316:	fa eb 00 00 	st.d	sp[0],r10
8000831a:	c2 08       	rjmp	8000835a <_vfprintf_r+0x1196>
8000831c:	41 09       	lddsp	r9,sp[0x40]
8000831e:	59 f8       	cp.w	r8,31
80008320:	e0 89 00 16 	brgt	8000834c <_vfprintf_r+0x1188>
80008324:	f2 e6 00 00 	ld.d	r6,r9[0]
80008328:	f2 cb ff f8 	sub	r11,r9,-8
8000832c:	fa e7 00 00 	st.d	sp[0],r6
80008330:	51 0b       	stdsp	sp[0x40],r11
80008332:	fa c6 f9 44 	sub	r6,sp,-1724
80008336:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000833a:	fa e6 00 00 	ld.d	r6,sp[0]
8000833e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008342:	2f f8       	sub	r8,-1
80008344:	14 97       	mov	r7,r10
80008346:	fb 48 06 b4 	st.w	sp[1716],r8
8000834a:	c0 88       	rjmp	8000835a <_vfprintf_r+0x1196>
8000834c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008350:	2f 89       	sub	r9,-8
80008352:	fa e7 00 00 	st.d	sp[0],r6
80008356:	51 09       	stdsp	sp[0x40],r9
80008358:	14 97       	mov	r7,r10
8000835a:	30 18       	mov	r8,1
8000835c:	e0 8f 01 d0 	bral	800086fc <_vfprintf_r+0x1538>
80008360:	ed b5 00 04 	bld	r5,0x4
80008364:	c1 61       	brne	80008390 <_vfprintf_r+0x11cc>
80008366:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000836a:	40 3e       	lddsp	lr,sp[0xc]
8000836c:	58 0e       	cp.w	lr,0
8000836e:	c0 80       	breq	8000837e <_vfprintf_r+0x11ba>
80008370:	10 36       	cp.w	r6,r8
80008372:	c6 74       	brge	80008440 <_vfprintf_r+0x127c>
80008374:	fa cc f9 44 	sub	r12,sp,-1724
80008378:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000837c:	c8 08       	rjmp	8000847c <_vfprintf_r+0x12b8>
8000837e:	ee ca ff ff 	sub	r10,r7,-1
80008382:	10 37       	cp.w	r7,r8
80008384:	c7 f4       	brge	80008482 <_vfprintf_r+0x12be>
80008386:	fa cb f9 44 	sub	r11,sp,-1724
8000838a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000838e:	c7 68       	rjmp	8000847a <_vfprintf_r+0x12b6>
80008390:	ed b5 00 06 	bld	r5,0x6
80008394:	c4 a1       	brne	80008428 <_vfprintf_r+0x1264>
80008396:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000839a:	40 3c       	lddsp	r12,sp[0xc]
8000839c:	58 0c       	cp.w	r12,0
8000839e:	c1 d0       	breq	800083d8 <_vfprintf_r+0x1214>
800083a0:	10 36       	cp.w	r6,r8
800083a2:	c0 64       	brge	800083ae <_vfprintf_r+0x11ea>
800083a4:	fa cb f9 44 	sub	r11,sp,-1724
800083a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083ac:	c1 f8       	rjmp	800083ea <_vfprintf_r+0x1226>
800083ae:	fa c8 f9 50 	sub	r8,sp,-1712
800083b2:	1a d8       	st.w	--sp,r8
800083b4:	fa c8 fa b8 	sub	r8,sp,-1352
800083b8:	1a d8       	st.w	--sp,r8
800083ba:	fa c8 fb b4 	sub	r8,sp,-1100
800083be:	1a d8       	st.w	--sp,r8
800083c0:	fa c8 f9 40 	sub	r8,sp,-1728
800083c4:	fa c9 ff b4 	sub	r9,sp,-76
800083c8:	04 9a       	mov	r10,r2
800083ca:	0c 9b       	mov	r11,r6
800083cc:	08 9c       	mov	r12,r4
800083ce:	fe b0 f5 63 	rcall	80006e94 <get_arg>
800083d2:	2f dd       	sub	sp,-12
800083d4:	98 18       	ld.sh	r8,r12[0x2]
800083d6:	c2 68       	rjmp	80008422 <_vfprintf_r+0x125e>
800083d8:	ee ca ff ff 	sub	r10,r7,-1
800083dc:	10 37       	cp.w	r7,r8
800083de:	c0 94       	brge	800083f0 <_vfprintf_r+0x122c>
800083e0:	fa c9 f9 44 	sub	r9,sp,-1724
800083e4:	14 97       	mov	r7,r10
800083e6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083ea:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800083ee:	c1 a8       	rjmp	80008422 <_vfprintf_r+0x125e>
800083f0:	41 09       	lddsp	r9,sp[0x40]
800083f2:	59 f8       	cp.w	r8,31
800083f4:	e0 89 00 13 	brgt	8000841a <_vfprintf_r+0x1256>
800083f8:	f2 cb ff fc 	sub	r11,r9,-4
800083fc:	51 0b       	stdsp	sp[0x40],r11
800083fe:	72 09       	ld.w	r9,r9[0x0]
80008400:	fa c6 f9 44 	sub	r6,sp,-1724
80008404:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008408:	2f f8       	sub	r8,-1
8000840a:	f7 49 fd 88 	st.w	r11[-632],r9
8000840e:	fb 48 06 b4 	st.w	sp[1716],r8
80008412:	14 97       	mov	r7,r10
80008414:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008418:	c0 58       	rjmp	80008422 <_vfprintf_r+0x125e>
8000841a:	92 18       	ld.sh	r8,r9[0x2]
8000841c:	14 97       	mov	r7,r10
8000841e:	2f c9       	sub	r9,-4
80008420:	51 09       	stdsp	sp[0x40],r9
80008422:	5c 78       	castu.h	r8
80008424:	50 18       	stdsp	sp[0x4],r8
80008426:	c4 68       	rjmp	800084b2 <_vfprintf_r+0x12ee>
80008428:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000842c:	40 3c       	lddsp	r12,sp[0xc]
8000842e:	58 0c       	cp.w	r12,0
80008430:	c1 d0       	breq	8000846a <_vfprintf_r+0x12a6>
80008432:	10 36       	cp.w	r6,r8
80008434:	c0 64       	brge	80008440 <_vfprintf_r+0x127c>
80008436:	fa cb f9 44 	sub	r11,sp,-1724
8000843a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000843e:	c1 f8       	rjmp	8000847c <_vfprintf_r+0x12b8>
80008440:	fa c8 f9 50 	sub	r8,sp,-1712
80008444:	1a d8       	st.w	--sp,r8
80008446:	fa c8 fa b8 	sub	r8,sp,-1352
8000844a:	0c 9b       	mov	r11,r6
8000844c:	1a d8       	st.w	--sp,r8
8000844e:	fa c8 fb b4 	sub	r8,sp,-1100
80008452:	04 9a       	mov	r10,r2
80008454:	1a d8       	st.w	--sp,r8
80008456:	08 9c       	mov	r12,r4
80008458:	fa c8 f9 40 	sub	r8,sp,-1728
8000845c:	fa c9 ff b4 	sub	r9,sp,-76
80008460:	fe b0 f5 1a 	rcall	80006e94 <get_arg>
80008464:	2f dd       	sub	sp,-12
80008466:	78 0b       	ld.w	r11,r12[0x0]
80008468:	c2 48       	rjmp	800084b0 <_vfprintf_r+0x12ec>
8000846a:	ee ca ff ff 	sub	r10,r7,-1
8000846e:	10 37       	cp.w	r7,r8
80008470:	c0 94       	brge	80008482 <_vfprintf_r+0x12be>
80008472:	fa c9 f9 44 	sub	r9,sp,-1724
80008476:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000847a:	14 97       	mov	r7,r10
8000847c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008480:	c1 88       	rjmp	800084b0 <_vfprintf_r+0x12ec>
80008482:	41 09       	lddsp	r9,sp[0x40]
80008484:	59 f8       	cp.w	r8,31
80008486:	e0 89 00 11 	brgt	800084a8 <_vfprintf_r+0x12e4>
8000848a:	f2 cb ff fc 	sub	r11,r9,-4
8000848e:	51 0b       	stdsp	sp[0x40],r11
80008490:	fa c6 f9 44 	sub	r6,sp,-1724
80008494:	72 0b       	ld.w	r11,r9[0x0]
80008496:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000849a:	f3 4b fd 88 	st.w	r9[-632],r11
8000849e:	2f f8       	sub	r8,-1
800084a0:	14 97       	mov	r7,r10
800084a2:	fb 48 06 b4 	st.w	sp[1716],r8
800084a6:	c0 58       	rjmp	800084b0 <_vfprintf_r+0x12ec>
800084a8:	72 0b       	ld.w	r11,r9[0x0]
800084aa:	14 97       	mov	r7,r10
800084ac:	2f c9       	sub	r9,-4
800084ae:	51 09       	stdsp	sp[0x40],r9
800084b0:	50 1b       	stdsp	sp[0x4],r11
800084b2:	30 0e       	mov	lr,0
800084b4:	30 18       	mov	r8,1
800084b6:	50 0e       	stdsp	sp[0x0],lr
800084b8:	c2 29       	rjmp	800086fc <_vfprintf_r+0x1538>
800084ba:	50 a7       	stdsp	sp[0x28],r7
800084bc:	50 80       	stdsp	sp[0x20],r0
800084be:	0c 97       	mov	r7,r6
800084c0:	04 94       	mov	r4,r2
800084c2:	06 96       	mov	r6,r3
800084c4:	02 92       	mov	r2,r1
800084c6:	fe cc b6 7e 	sub	r12,pc,-18818
800084ca:	40 93       	lddsp	r3,sp[0x24]
800084cc:	10 90       	mov	r0,r8
800084ce:	40 41       	lddsp	r1,sp[0x10]
800084d0:	50 dc       	stdsp	sp[0x34],r12
800084d2:	ed b5 00 05 	bld	r5,0x5
800084d6:	c5 51       	brne	80008580 <_vfprintf_r+0x13bc>
800084d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084dc:	40 3b       	lddsp	r11,sp[0xc]
800084de:	58 0b       	cp.w	r11,0
800084e0:	c2 20       	breq	80008524 <_vfprintf_r+0x1360>
800084e2:	10 36       	cp.w	r6,r8
800084e4:	c0 a4       	brge	800084f8 <_vfprintf_r+0x1334>
800084e6:	fa ca f9 44 	sub	r10,sp,-1724
800084ea:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084ee:	ec e8 fd 88 	ld.d	r8,r6[-632]
800084f2:	fa e9 00 00 	st.d	sp[0],r8
800084f6:	cf 28       	rjmp	800086da <_vfprintf_r+0x1516>
800084f8:	fa c8 f9 50 	sub	r8,sp,-1712
800084fc:	1a d8       	st.w	--sp,r8
800084fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008502:	04 9a       	mov	r10,r2
80008504:	1a d8       	st.w	--sp,r8
80008506:	0c 9b       	mov	r11,r6
80008508:	fa c8 fb b4 	sub	r8,sp,-1100
8000850c:	08 9c       	mov	r12,r4
8000850e:	1a d8       	st.w	--sp,r8
80008510:	fa c8 f9 40 	sub	r8,sp,-1728
80008514:	fa c9 ff b4 	sub	r9,sp,-76
80008518:	fe b0 f4 be 	rcall	80006e94 <get_arg>
8000851c:	2f dd       	sub	sp,-12
8000851e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008522:	c0 c8       	rjmp	8000853a <_vfprintf_r+0x1376>
80008524:	ee ca ff ff 	sub	r10,r7,-1
80008528:	10 37       	cp.w	r7,r8
8000852a:	c0 b4       	brge	80008540 <_vfprintf_r+0x137c>
8000852c:	fa c9 f9 44 	sub	r9,sp,-1724
80008530:	14 97       	mov	r7,r10
80008532:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008536:	ec ea fd 88 	ld.d	r10,r6[-632]
8000853a:	fa eb 00 00 	st.d	sp[0],r10
8000853e:	cc e8       	rjmp	800086da <_vfprintf_r+0x1516>
80008540:	41 09       	lddsp	r9,sp[0x40]
80008542:	59 f8       	cp.w	r8,31
80008544:	e0 89 00 16 	brgt	80008570 <_vfprintf_r+0x13ac>
80008548:	f2 e6 00 00 	ld.d	r6,r9[0]
8000854c:	f2 cb ff f8 	sub	r11,r9,-8
80008550:	fa e7 00 00 	st.d	sp[0],r6
80008554:	51 0b       	stdsp	sp[0x40],r11
80008556:	fa c6 f9 44 	sub	r6,sp,-1724
8000855a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000855e:	fa e6 00 00 	ld.d	r6,sp[0]
80008562:	f2 e7 fd 88 	st.d	r9[-632],r6
80008566:	2f f8       	sub	r8,-1
80008568:	14 97       	mov	r7,r10
8000856a:	fb 48 06 b4 	st.w	sp[1716],r8
8000856e:	cb 68       	rjmp	800086da <_vfprintf_r+0x1516>
80008570:	f2 e6 00 00 	ld.d	r6,r9[0]
80008574:	2f 89       	sub	r9,-8
80008576:	fa e7 00 00 	st.d	sp[0],r6
8000857a:	51 09       	stdsp	sp[0x40],r9
8000857c:	14 97       	mov	r7,r10
8000857e:	ca e8       	rjmp	800086da <_vfprintf_r+0x1516>
80008580:	ed b5 00 04 	bld	r5,0x4
80008584:	c1 71       	brne	800085b2 <_vfprintf_r+0x13ee>
80008586:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000858a:	40 3e       	lddsp	lr,sp[0xc]
8000858c:	58 0e       	cp.w	lr,0
8000858e:	c0 80       	breq	8000859e <_vfprintf_r+0x13da>
80008590:	10 36       	cp.w	r6,r8
80008592:	c6 94       	brge	80008664 <_vfprintf_r+0x14a0>
80008594:	fa cc f9 44 	sub	r12,sp,-1724
80008598:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000859c:	c8 28       	rjmp	800086a0 <_vfprintf_r+0x14dc>
8000859e:	ee ca ff ff 	sub	r10,r7,-1
800085a2:	10 37       	cp.w	r7,r8
800085a4:	e0 84 00 81 	brge	800086a6 <_vfprintf_r+0x14e2>
800085a8:	fa cb f9 44 	sub	r11,sp,-1724
800085ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085b0:	c7 78       	rjmp	8000869e <_vfprintf_r+0x14da>
800085b2:	ed b5 00 06 	bld	r5,0x6
800085b6:	c4 b1       	brne	8000864c <_vfprintf_r+0x1488>
800085b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085bc:	40 3c       	lddsp	r12,sp[0xc]
800085be:	58 0c       	cp.w	r12,0
800085c0:	c1 d0       	breq	800085fa <_vfprintf_r+0x1436>
800085c2:	10 36       	cp.w	r6,r8
800085c4:	c0 64       	brge	800085d0 <_vfprintf_r+0x140c>
800085c6:	fa cb f9 44 	sub	r11,sp,-1724
800085ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085ce:	c1 f8       	rjmp	8000860c <_vfprintf_r+0x1448>
800085d0:	fa c8 f9 50 	sub	r8,sp,-1712
800085d4:	1a d8       	st.w	--sp,r8
800085d6:	fa c8 fa b8 	sub	r8,sp,-1352
800085da:	1a d8       	st.w	--sp,r8
800085dc:	fa c8 fb b4 	sub	r8,sp,-1100
800085e0:	1a d8       	st.w	--sp,r8
800085e2:	fa c8 f9 40 	sub	r8,sp,-1728
800085e6:	fa c9 ff b4 	sub	r9,sp,-76
800085ea:	04 9a       	mov	r10,r2
800085ec:	0c 9b       	mov	r11,r6
800085ee:	08 9c       	mov	r12,r4
800085f0:	fe b0 f4 52 	rcall	80006e94 <get_arg>
800085f4:	2f dd       	sub	sp,-12
800085f6:	98 18       	ld.sh	r8,r12[0x2]
800085f8:	c2 78       	rjmp	80008646 <_vfprintf_r+0x1482>
800085fa:	ee ca ff ff 	sub	r10,r7,-1
800085fe:	10 37       	cp.w	r7,r8
80008600:	c0 a4       	brge	80008614 <_vfprintf_r+0x1450>
80008602:	fa c9 f9 44 	sub	r9,sp,-1724
80008606:	14 97       	mov	r7,r10
80008608:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000860c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008610:	c1 b8       	rjmp	80008646 <_vfprintf_r+0x1482>
80008612:	d7 03       	nop
80008614:	41 09       	lddsp	r9,sp[0x40]
80008616:	59 f8       	cp.w	r8,31
80008618:	e0 89 00 13 	brgt	8000863e <_vfprintf_r+0x147a>
8000861c:	f2 cb ff fc 	sub	r11,r9,-4
80008620:	51 0b       	stdsp	sp[0x40],r11
80008622:	72 09       	ld.w	r9,r9[0x0]
80008624:	fa c6 f9 44 	sub	r6,sp,-1724
80008628:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000862c:	2f f8       	sub	r8,-1
8000862e:	f7 49 fd 88 	st.w	r11[-632],r9
80008632:	fb 48 06 b4 	st.w	sp[1716],r8
80008636:	14 97       	mov	r7,r10
80008638:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000863c:	c0 58       	rjmp	80008646 <_vfprintf_r+0x1482>
8000863e:	92 18       	ld.sh	r8,r9[0x2]
80008640:	14 97       	mov	r7,r10
80008642:	2f c9       	sub	r9,-4
80008644:	51 09       	stdsp	sp[0x40],r9
80008646:	5c 78       	castu.h	r8
80008648:	50 18       	stdsp	sp[0x4],r8
8000864a:	c4 68       	rjmp	800086d6 <_vfprintf_r+0x1512>
8000864c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008650:	40 3c       	lddsp	r12,sp[0xc]
80008652:	58 0c       	cp.w	r12,0
80008654:	c1 d0       	breq	8000868e <_vfprintf_r+0x14ca>
80008656:	10 36       	cp.w	r6,r8
80008658:	c0 64       	brge	80008664 <_vfprintf_r+0x14a0>
8000865a:	fa cb f9 44 	sub	r11,sp,-1724
8000865e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008662:	c1 f8       	rjmp	800086a0 <_vfprintf_r+0x14dc>
80008664:	fa c8 f9 50 	sub	r8,sp,-1712
80008668:	1a d8       	st.w	--sp,r8
8000866a:	fa c8 fa b8 	sub	r8,sp,-1352
8000866e:	0c 9b       	mov	r11,r6
80008670:	1a d8       	st.w	--sp,r8
80008672:	fa c8 fb b4 	sub	r8,sp,-1100
80008676:	04 9a       	mov	r10,r2
80008678:	1a d8       	st.w	--sp,r8
8000867a:	08 9c       	mov	r12,r4
8000867c:	fa c8 f9 40 	sub	r8,sp,-1728
80008680:	fa c9 ff b4 	sub	r9,sp,-76
80008684:	fe b0 f4 08 	rcall	80006e94 <get_arg>
80008688:	2f dd       	sub	sp,-12
8000868a:	78 0b       	ld.w	r11,r12[0x0]
8000868c:	c2 48       	rjmp	800086d4 <_vfprintf_r+0x1510>
8000868e:	ee ca ff ff 	sub	r10,r7,-1
80008692:	10 37       	cp.w	r7,r8
80008694:	c0 94       	brge	800086a6 <_vfprintf_r+0x14e2>
80008696:	fa c9 f9 44 	sub	r9,sp,-1724
8000869a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000869e:	14 97       	mov	r7,r10
800086a0:	ec fb fd 88 	ld.w	r11,r6[-632]
800086a4:	c1 88       	rjmp	800086d4 <_vfprintf_r+0x1510>
800086a6:	41 09       	lddsp	r9,sp[0x40]
800086a8:	59 f8       	cp.w	r8,31
800086aa:	e0 89 00 11 	brgt	800086cc <_vfprintf_r+0x1508>
800086ae:	f2 cb ff fc 	sub	r11,r9,-4
800086b2:	51 0b       	stdsp	sp[0x40],r11
800086b4:	fa c6 f9 44 	sub	r6,sp,-1724
800086b8:	72 0b       	ld.w	r11,r9[0x0]
800086ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086be:	f3 4b fd 88 	st.w	r9[-632],r11
800086c2:	2f f8       	sub	r8,-1
800086c4:	14 97       	mov	r7,r10
800086c6:	fb 48 06 b4 	st.w	sp[1716],r8
800086ca:	c0 58       	rjmp	800086d4 <_vfprintf_r+0x1510>
800086cc:	72 0b       	ld.w	r11,r9[0x0]
800086ce:	14 97       	mov	r7,r10
800086d0:	2f c9       	sub	r9,-4
800086d2:	51 09       	stdsp	sp[0x40],r9
800086d4:	50 1b       	stdsp	sp[0x4],r11
800086d6:	30 0e       	mov	lr,0
800086d8:	50 0e       	stdsp	sp[0x0],lr
800086da:	40 08       	lddsp	r8,sp[0x0]
800086dc:	40 1c       	lddsp	r12,sp[0x4]
800086de:	18 48       	or	r8,r12
800086e0:	5f 19       	srne	r9
800086e2:	0a 98       	mov	r8,r5
800086e4:	eb e9 00 09 	and	r9,r5,r9
800086e8:	a1 b8       	sbr	r8,0x1
800086ea:	58 09       	cp.w	r9,0
800086ec:	c0 70       	breq	800086fa <_vfprintf_r+0x1536>
800086ee:	10 95       	mov	r5,r8
800086f0:	fb 60 06 b9 	st.b	sp[1721],r0
800086f4:	33 08       	mov	r8,48
800086f6:	fb 68 06 b8 	st.b	sp[1720],r8
800086fa:	30 28       	mov	r8,2
800086fc:	30 09       	mov	r9,0
800086fe:	fb 69 06 bb 	st.b	sp[1723],r9
80008702:	0a 99       	mov	r9,r5
80008704:	a7 d9       	cbr	r9,0x7
80008706:	40 2b       	lddsp	r11,sp[0x8]
80008708:	40 16       	lddsp	r6,sp[0x4]
8000870a:	58 0b       	cp.w	r11,0
8000870c:	5f 1a       	srne	r10
8000870e:	f2 05 17 40 	movge	r5,r9
80008712:	fa c2 f9 78 	sub	r2,sp,-1672
80008716:	40 09       	lddsp	r9,sp[0x0]
80008718:	0c 49       	or	r9,r6
8000871a:	5f 19       	srne	r9
8000871c:	f5 e9 10 09 	or	r9,r10,r9
80008720:	c5 c0       	breq	800087d8 <_vfprintf_r+0x1614>
80008722:	30 19       	mov	r9,1
80008724:	f2 08 18 00 	cp.b	r8,r9
80008728:	c0 60       	breq	80008734 <_vfprintf_r+0x1570>
8000872a:	30 29       	mov	r9,2
8000872c:	f2 08 18 00 	cp.b	r8,r9
80008730:	c0 41       	brne	80008738 <_vfprintf_r+0x1574>
80008732:	c3 c8       	rjmp	800087aa <_vfprintf_r+0x15e6>
80008734:	04 96       	mov	r6,r2
80008736:	c3 08       	rjmp	80008796 <_vfprintf_r+0x15d2>
80008738:	04 96       	mov	r6,r2
8000873a:	fa e8 00 00 	ld.d	r8,sp[0]
8000873e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008742:	2d 0a       	sub	r10,-48
80008744:	0c fa       	st.b	--r6,r10
80008746:	f0 0b 16 03 	lsr	r11,r8,0x3
8000874a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000874e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008752:	18 99       	mov	r9,r12
80008754:	16 98       	mov	r8,r11
80008756:	58 08       	cp.w	r8,0
80008758:	5c 29       	cpc	r9
8000875a:	cf 21       	brne	8000873e <_vfprintf_r+0x157a>
8000875c:	fa e9 00 00 	st.d	sp[0],r8
80008760:	ed b5 00 00 	bld	r5,0x0
80008764:	c4 51       	brne	800087ee <_vfprintf_r+0x162a>
80008766:	33 09       	mov	r9,48
80008768:	f2 0a 18 00 	cp.b	r10,r9
8000876c:	c4 10       	breq	800087ee <_vfprintf_r+0x162a>
8000876e:	0c f9       	st.b	--r6,r9
80008770:	c3 f8       	rjmp	800087ee <_vfprintf_r+0x162a>
80008772:	fa ea 00 00 	ld.d	r10,sp[0]
80008776:	30 a8       	mov	r8,10
80008778:	30 09       	mov	r9,0
8000877a:	e0 a0 1a 0d 	rcall	8000bb94 <__avr32_umod64>
8000877e:	30 a8       	mov	r8,10
80008780:	2d 0a       	sub	r10,-48
80008782:	30 09       	mov	r9,0
80008784:	ac 8a       	st.b	r6[0x0],r10
80008786:	fa ea 00 00 	ld.d	r10,sp[0]
8000878a:	e0 a0 18 d3 	rcall	8000b930 <__avr32_udiv64>
8000878e:	16 99       	mov	r9,r11
80008790:	14 98       	mov	r8,r10
80008792:	fa e9 00 00 	st.d	sp[0],r8
80008796:	20 16       	sub	r6,1
80008798:	fa ea 00 00 	ld.d	r10,sp[0]
8000879c:	58 9a       	cp.w	r10,9
8000879e:	5c 2b       	cpc	r11
800087a0:	fe 9b ff e9 	brhi	80008772 <_vfprintf_r+0x15ae>
800087a4:	1b f8       	ld.ub	r8,sp[0x7]
800087a6:	2d 08       	sub	r8,-48
800087a8:	c2 08       	rjmp	800087e8 <_vfprintf_r+0x1624>
800087aa:	04 96       	mov	r6,r2
800087ac:	fa e8 00 00 	ld.d	r8,sp[0]
800087b0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800087b4:	40 de       	lddsp	lr,sp[0x34]
800087b6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800087ba:	0c fa       	st.b	--r6,r10
800087bc:	f2 0b 16 04 	lsr	r11,r9,0x4
800087c0:	f0 0a 16 04 	lsr	r10,r8,0x4
800087c4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800087c8:	16 99       	mov	r9,r11
800087ca:	14 98       	mov	r8,r10
800087cc:	58 08       	cp.w	r8,0
800087ce:	5c 29       	cpc	r9
800087d0:	cf 01       	brne	800087b0 <_vfprintf_r+0x15ec>
800087d2:	fa e9 00 00 	st.d	sp[0],r8
800087d6:	c0 c8       	rjmp	800087ee <_vfprintf_r+0x162a>
800087d8:	58 08       	cp.w	r8,0
800087da:	c0 91       	brne	800087ec <_vfprintf_r+0x1628>
800087dc:	ed b5 00 00 	bld	r5,0x0
800087e0:	c0 61       	brne	800087ec <_vfprintf_r+0x1628>
800087e2:	fa c6 f9 79 	sub	r6,sp,-1671
800087e6:	33 08       	mov	r8,48
800087e8:	ac 88       	st.b	r6[0x0],r8
800087ea:	c0 28       	rjmp	800087ee <_vfprintf_r+0x162a>
800087ec:	04 96       	mov	r6,r2
800087ee:	0c 12       	sub	r2,r6
800087f0:	c1 c8       	rjmp	80008828 <_vfprintf_r+0x1664>
800087f2:	50 a7       	stdsp	sp[0x28],r7
800087f4:	50 80       	stdsp	sp[0x20],r0
800087f6:	40 93       	lddsp	r3,sp[0x24]
800087f8:	0c 97       	mov	r7,r6
800087fa:	10 90       	mov	r0,r8
800087fc:	04 94       	mov	r4,r2
800087fe:	40 41       	lddsp	r1,sp[0x10]
80008800:	58 08       	cp.w	r8,0
80008802:	e0 80 04 4f 	breq	800090a0 <_vfprintf_r+0x1edc>
80008806:	fb 68 06 60 	st.b	sp[1632],r8
8000880a:	30 0c       	mov	r12,0
8000880c:	30 08       	mov	r8,0
8000880e:	30 12       	mov	r2,1
80008810:	fb 68 06 bb 	st.b	sp[1723],r8
80008814:	50 2c       	stdsp	sp[0x8],r12
80008816:	fa c6 f9 a0 	sub	r6,sp,-1632
8000881a:	c0 78       	rjmp	80008828 <_vfprintf_r+0x1664>
8000881c:	30 0b       	mov	r11,0
8000881e:	50 2b       	stdsp	sp[0x8],r11
80008820:	c0 48       	rjmp	80008828 <_vfprintf_r+0x1664>
80008822:	40 22       	lddsp	r2,sp[0x8]
80008824:	30 0a       	mov	r10,0
80008826:	50 2a       	stdsp	sp[0x8],r10
80008828:	40 29       	lddsp	r9,sp[0x8]
8000882a:	e4 09 0c 49 	max	r9,r2,r9
8000882e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008832:	50 39       	stdsp	sp[0xc],r9
80008834:	0a 9e       	mov	lr,r5
80008836:	30 09       	mov	r9,0
80008838:	e2 1e 00 02 	andl	lr,0x2,COH
8000883c:	f2 08 18 00 	cp.b	r8,r9
80008840:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008844:	f7 b8 01 ff 	subne	r8,-1
80008848:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000884c:	0a 9b       	mov	r11,r5
8000884e:	58 0e       	cp.w	lr,0
80008850:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008854:	f7 bc 01 fe 	subne	r12,-2
80008858:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000885c:	e2 1b 00 84 	andl	r11,0x84,COH
80008860:	50 fe       	stdsp	sp[0x3c],lr
80008862:	50 9b       	stdsp	sp[0x24],r11
80008864:	c4 71       	brne	800088f2 <_vfprintf_r+0x172e>
80008866:	40 8a       	lddsp	r10,sp[0x20]
80008868:	40 39       	lddsp	r9,sp[0xc]
8000886a:	12 1a       	sub	r10,r9
8000886c:	50 4a       	stdsp	sp[0x10],r10
8000886e:	58 0a       	cp.w	r10,0
80008870:	e0 89 00 20 	brgt	800088b0 <_vfprintf_r+0x16ec>
80008874:	c3 f8       	rjmp	800088f2 <_vfprintf_r+0x172e>
80008876:	2f 09       	sub	r9,-16
80008878:	2f f8       	sub	r8,-1
8000887a:	fe ce ba 1a 	sub	lr,pc,-17894
8000887e:	31 0c       	mov	r12,16
80008880:	fb 49 06 90 	st.w	sp[1680],r9
80008884:	87 0e       	st.w	r3[0x0],lr
80008886:	87 1c       	st.w	r3[0x4],r12
80008888:	fb 48 06 8c 	st.w	sp[1676],r8
8000888c:	58 78       	cp.w	r8,7
8000888e:	e0 89 00 04 	brgt	80008896 <_vfprintf_r+0x16d2>
80008892:	2f 83       	sub	r3,-8
80008894:	c0 b8       	rjmp	800088aa <_vfprintf_r+0x16e6>
80008896:	fa ca f9 78 	sub	r10,sp,-1672
8000889a:	02 9b       	mov	r11,r1
8000889c:	08 9c       	mov	r12,r4
8000889e:	fe b0 f4 85 	rcall	800071a8 <__sprint_r>
800088a2:	e0 81 04 10 	brne	800090c2 <_vfprintf_r+0x1efe>
800088a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800088aa:	40 4b       	lddsp	r11,sp[0x10]
800088ac:	21 0b       	sub	r11,16
800088ae:	50 4b       	stdsp	sp[0x10],r11
800088b0:	fa f9 06 90 	ld.w	r9,sp[1680]
800088b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088b8:	fe ca ba 58 	sub	r10,pc,-17832
800088bc:	40 4e       	lddsp	lr,sp[0x10]
800088be:	59 0e       	cp.w	lr,16
800088c0:	fe 99 ff db 	brgt	80008876 <_vfprintf_r+0x16b2>
800088c4:	1c 09       	add	r9,lr
800088c6:	2f f8       	sub	r8,-1
800088c8:	87 0a       	st.w	r3[0x0],r10
800088ca:	fb 49 06 90 	st.w	sp[1680],r9
800088ce:	87 1e       	st.w	r3[0x4],lr
800088d0:	fb 48 06 8c 	st.w	sp[1676],r8
800088d4:	58 78       	cp.w	r8,7
800088d6:	e0 89 00 04 	brgt	800088de <_vfprintf_r+0x171a>
800088da:	2f 83       	sub	r3,-8
800088dc:	c0 b8       	rjmp	800088f2 <_vfprintf_r+0x172e>
800088de:	fa ca f9 78 	sub	r10,sp,-1672
800088e2:	02 9b       	mov	r11,r1
800088e4:	08 9c       	mov	r12,r4
800088e6:	fe b0 f4 61 	rcall	800071a8 <__sprint_r>
800088ea:	e0 81 03 ec 	brne	800090c2 <_vfprintf_r+0x1efe>
800088ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800088f2:	30 09       	mov	r9,0
800088f4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800088f8:	f2 08 18 00 	cp.b	r8,r9
800088fc:	c1 f0       	breq	8000893a <_vfprintf_r+0x1776>
800088fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80008902:	fa c9 f9 45 	sub	r9,sp,-1723
80008906:	2f f8       	sub	r8,-1
80008908:	87 09       	st.w	r3[0x0],r9
8000890a:	fb 48 06 90 	st.w	sp[1680],r8
8000890e:	30 19       	mov	r9,1
80008910:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008914:	87 19       	st.w	r3[0x4],r9
80008916:	2f f8       	sub	r8,-1
80008918:	fb 48 06 8c 	st.w	sp[1676],r8
8000891c:	58 78       	cp.w	r8,7
8000891e:	e0 89 00 04 	brgt	80008926 <_vfprintf_r+0x1762>
80008922:	2f 83       	sub	r3,-8
80008924:	c0 b8       	rjmp	8000893a <_vfprintf_r+0x1776>
80008926:	fa ca f9 78 	sub	r10,sp,-1672
8000892a:	02 9b       	mov	r11,r1
8000892c:	08 9c       	mov	r12,r4
8000892e:	fe b0 f4 3d 	rcall	800071a8 <__sprint_r>
80008932:	e0 81 03 c8 	brne	800090c2 <_vfprintf_r+0x1efe>
80008936:	fa c3 f9 e0 	sub	r3,sp,-1568
8000893a:	40 fc       	lddsp	r12,sp[0x3c]
8000893c:	58 0c       	cp.w	r12,0
8000893e:	c1 f0       	breq	8000897c <_vfprintf_r+0x17b8>
80008940:	fa f8 06 90 	ld.w	r8,sp[1680]
80008944:	fa c9 f9 48 	sub	r9,sp,-1720
80008948:	2f e8       	sub	r8,-2
8000894a:	87 09       	st.w	r3[0x0],r9
8000894c:	fb 48 06 90 	st.w	sp[1680],r8
80008950:	30 29       	mov	r9,2
80008952:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008956:	87 19       	st.w	r3[0x4],r9
80008958:	2f f8       	sub	r8,-1
8000895a:	fb 48 06 8c 	st.w	sp[1676],r8
8000895e:	58 78       	cp.w	r8,7
80008960:	e0 89 00 04 	brgt	80008968 <_vfprintf_r+0x17a4>
80008964:	2f 83       	sub	r3,-8
80008966:	c0 b8       	rjmp	8000897c <_vfprintf_r+0x17b8>
80008968:	fa ca f9 78 	sub	r10,sp,-1672
8000896c:	02 9b       	mov	r11,r1
8000896e:	08 9c       	mov	r12,r4
80008970:	fe b0 f4 1c 	rcall	800071a8 <__sprint_r>
80008974:	e0 81 03 a7 	brne	800090c2 <_vfprintf_r+0x1efe>
80008978:	fa c3 f9 e0 	sub	r3,sp,-1568
8000897c:	40 9b       	lddsp	r11,sp[0x24]
8000897e:	e0 4b 00 80 	cp.w	r11,128
80008982:	c4 71       	brne	80008a10 <_vfprintf_r+0x184c>
80008984:	40 8a       	lddsp	r10,sp[0x20]
80008986:	40 39       	lddsp	r9,sp[0xc]
80008988:	12 1a       	sub	r10,r9
8000898a:	50 4a       	stdsp	sp[0x10],r10
8000898c:	58 0a       	cp.w	r10,0
8000898e:	e0 89 00 20 	brgt	800089ce <_vfprintf_r+0x180a>
80008992:	c3 f8       	rjmp	80008a10 <_vfprintf_r+0x184c>
80008994:	2f 09       	sub	r9,-16
80008996:	2f f8       	sub	r8,-1
80008998:	fe ce bb 28 	sub	lr,pc,-17624
8000899c:	31 0c       	mov	r12,16
8000899e:	fb 49 06 90 	st.w	sp[1680],r9
800089a2:	87 0e       	st.w	r3[0x0],lr
800089a4:	87 1c       	st.w	r3[0x4],r12
800089a6:	fb 48 06 8c 	st.w	sp[1676],r8
800089aa:	58 78       	cp.w	r8,7
800089ac:	e0 89 00 04 	brgt	800089b4 <_vfprintf_r+0x17f0>
800089b0:	2f 83       	sub	r3,-8
800089b2:	c0 b8       	rjmp	800089c8 <_vfprintf_r+0x1804>
800089b4:	fa ca f9 78 	sub	r10,sp,-1672
800089b8:	02 9b       	mov	r11,r1
800089ba:	08 9c       	mov	r12,r4
800089bc:	fe b0 f3 f6 	rcall	800071a8 <__sprint_r>
800089c0:	e0 81 03 81 	brne	800090c2 <_vfprintf_r+0x1efe>
800089c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800089c8:	40 4b       	lddsp	r11,sp[0x10]
800089ca:	21 0b       	sub	r11,16
800089cc:	50 4b       	stdsp	sp[0x10],r11
800089ce:	fa f9 06 90 	ld.w	r9,sp[1680]
800089d2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089d6:	fe ca bb 66 	sub	r10,pc,-17562
800089da:	40 4e       	lddsp	lr,sp[0x10]
800089dc:	59 0e       	cp.w	lr,16
800089de:	fe 99 ff db 	brgt	80008994 <_vfprintf_r+0x17d0>
800089e2:	1c 09       	add	r9,lr
800089e4:	2f f8       	sub	r8,-1
800089e6:	87 0a       	st.w	r3[0x0],r10
800089e8:	fb 49 06 90 	st.w	sp[1680],r9
800089ec:	87 1e       	st.w	r3[0x4],lr
800089ee:	fb 48 06 8c 	st.w	sp[1676],r8
800089f2:	58 78       	cp.w	r8,7
800089f4:	e0 89 00 04 	brgt	800089fc <_vfprintf_r+0x1838>
800089f8:	2f 83       	sub	r3,-8
800089fa:	c0 b8       	rjmp	80008a10 <_vfprintf_r+0x184c>
800089fc:	fa ca f9 78 	sub	r10,sp,-1672
80008a00:	02 9b       	mov	r11,r1
80008a02:	08 9c       	mov	r12,r4
80008a04:	fe b0 f3 d2 	rcall	800071a8 <__sprint_r>
80008a08:	e0 81 03 5d 	brne	800090c2 <_vfprintf_r+0x1efe>
80008a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a10:	40 2c       	lddsp	r12,sp[0x8]
80008a12:	04 1c       	sub	r12,r2
80008a14:	50 2c       	stdsp	sp[0x8],r12
80008a16:	58 0c       	cp.w	r12,0
80008a18:	e0 89 00 20 	brgt	80008a58 <_vfprintf_r+0x1894>
80008a1c:	c3 f8       	rjmp	80008a9a <_vfprintf_r+0x18d6>
80008a1e:	2f 09       	sub	r9,-16
80008a20:	2f f8       	sub	r8,-1
80008a22:	fe cb bb b2 	sub	r11,pc,-17486
80008a26:	31 0a       	mov	r10,16
80008a28:	fb 49 06 90 	st.w	sp[1680],r9
80008a2c:	87 0b       	st.w	r3[0x0],r11
80008a2e:	87 1a       	st.w	r3[0x4],r10
80008a30:	fb 48 06 8c 	st.w	sp[1676],r8
80008a34:	58 78       	cp.w	r8,7
80008a36:	e0 89 00 04 	brgt	80008a3e <_vfprintf_r+0x187a>
80008a3a:	2f 83       	sub	r3,-8
80008a3c:	c0 b8       	rjmp	80008a52 <_vfprintf_r+0x188e>
80008a3e:	fa ca f9 78 	sub	r10,sp,-1672
80008a42:	02 9b       	mov	r11,r1
80008a44:	08 9c       	mov	r12,r4
80008a46:	fe b0 f3 b1 	rcall	800071a8 <__sprint_r>
80008a4a:	e0 81 03 3c 	brne	800090c2 <_vfprintf_r+0x1efe>
80008a4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a52:	40 29       	lddsp	r9,sp[0x8]
80008a54:	21 09       	sub	r9,16
80008a56:	50 29       	stdsp	sp[0x8],r9
80008a58:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a5c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a60:	fe ca bb f0 	sub	r10,pc,-17424
80008a64:	40 2e       	lddsp	lr,sp[0x8]
80008a66:	59 0e       	cp.w	lr,16
80008a68:	fe 99 ff db 	brgt	80008a1e <_vfprintf_r+0x185a>
80008a6c:	1c 09       	add	r9,lr
80008a6e:	2f f8       	sub	r8,-1
80008a70:	87 0a       	st.w	r3[0x0],r10
80008a72:	fb 49 06 90 	st.w	sp[1680],r9
80008a76:	87 1e       	st.w	r3[0x4],lr
80008a78:	fb 48 06 8c 	st.w	sp[1676],r8
80008a7c:	58 78       	cp.w	r8,7
80008a7e:	e0 89 00 04 	brgt	80008a86 <_vfprintf_r+0x18c2>
80008a82:	2f 83       	sub	r3,-8
80008a84:	c0 b8       	rjmp	80008a9a <_vfprintf_r+0x18d6>
80008a86:	fa ca f9 78 	sub	r10,sp,-1672
80008a8a:	02 9b       	mov	r11,r1
80008a8c:	08 9c       	mov	r12,r4
80008a8e:	fe b0 f3 8d 	rcall	800071a8 <__sprint_r>
80008a92:	e0 81 03 18 	brne	800090c2 <_vfprintf_r+0x1efe>
80008a96:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a9a:	ed b5 00 08 	bld	r5,0x8
80008a9e:	c0 b0       	breq	80008ab4 <_vfprintf_r+0x18f0>
80008aa0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008aa4:	87 12       	st.w	r3[0x4],r2
80008aa6:	87 06       	st.w	r3[0x0],r6
80008aa8:	f0 02 00 02 	add	r2,r8,r2
80008aac:	fb 42 06 90 	st.w	sp[1680],r2
80008ab0:	e0 8f 01 d4 	bral	80008e58 <_vfprintf_r+0x1c94>
80008ab4:	e0 40 00 65 	cp.w	r0,101
80008ab8:	e0 8a 01 d6 	brle	80008e64 <_vfprintf_r+0x1ca0>
80008abc:	30 08       	mov	r8,0
80008abe:	30 09       	mov	r9,0
80008ac0:	40 5b       	lddsp	r11,sp[0x14]
80008ac2:	40 7a       	lddsp	r10,sp[0x1c]
80008ac4:	e0 a0 15 2f 	rcall	8000b522 <__avr32_f64_cmp_eq>
80008ac8:	c7 90       	breq	80008bba <_vfprintf_r+0x19f6>
80008aca:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ace:	fe c9 bc 72 	sub	r9,pc,-17294
80008ad2:	2f f8       	sub	r8,-1
80008ad4:	87 09       	st.w	r3[0x0],r9
80008ad6:	fb 48 06 90 	st.w	sp[1680],r8
80008ada:	30 19       	mov	r9,1
80008adc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ae0:	87 19       	st.w	r3[0x4],r9
80008ae2:	2f f8       	sub	r8,-1
80008ae4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ae8:	58 78       	cp.w	r8,7
80008aea:	e0 89 00 05 	brgt	80008af4 <_vfprintf_r+0x1930>
80008aee:	2f 83       	sub	r3,-8
80008af0:	c0 c8       	rjmp	80008b08 <_vfprintf_r+0x1944>
80008af2:	d7 03       	nop
80008af4:	fa ca f9 78 	sub	r10,sp,-1672
80008af8:	02 9b       	mov	r11,r1
80008afa:	08 9c       	mov	r12,r4
80008afc:	fe b0 f3 56 	rcall	800071a8 <__sprint_r>
80008b00:	e0 81 02 e1 	brne	800090c2 <_vfprintf_r+0x1efe>
80008b04:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b08:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b0c:	40 6c       	lddsp	r12,sp[0x18]
80008b0e:	18 38       	cp.w	r8,r12
80008b10:	c0 55       	brlt	80008b1a <_vfprintf_r+0x1956>
80008b12:	ed b5 00 00 	bld	r5,0x0
80008b16:	e0 81 02 6b 	brne	80008fec <_vfprintf_r+0x1e28>
80008b1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b1e:	2f f8       	sub	r8,-1
80008b20:	40 cb       	lddsp	r11,sp[0x30]
80008b22:	fb 48 06 90 	st.w	sp[1680],r8
80008b26:	30 19       	mov	r9,1
80008b28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b2c:	87 0b       	st.w	r3[0x0],r11
80008b2e:	2f f8       	sub	r8,-1
80008b30:	87 19       	st.w	r3[0x4],r9
80008b32:	fb 48 06 8c 	st.w	sp[1676],r8
80008b36:	58 78       	cp.w	r8,7
80008b38:	e0 89 00 04 	brgt	80008b40 <_vfprintf_r+0x197c>
80008b3c:	2f 83       	sub	r3,-8
80008b3e:	c0 b8       	rjmp	80008b54 <_vfprintf_r+0x1990>
80008b40:	fa ca f9 78 	sub	r10,sp,-1672
80008b44:	02 9b       	mov	r11,r1
80008b46:	08 9c       	mov	r12,r4
80008b48:	fe b0 f3 30 	rcall	800071a8 <__sprint_r>
80008b4c:	e0 81 02 bb 	brne	800090c2 <_vfprintf_r+0x1efe>
80008b50:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b54:	40 66       	lddsp	r6,sp[0x18]
80008b56:	20 16       	sub	r6,1
80008b58:	58 06       	cp.w	r6,0
80008b5a:	e0 89 00 1d 	brgt	80008b94 <_vfprintf_r+0x19d0>
80008b5e:	e0 8f 02 47 	bral	80008fec <_vfprintf_r+0x1e28>
80008b62:	2f 09       	sub	r9,-16
80008b64:	2f f8       	sub	r8,-1
80008b66:	fb 49 06 90 	st.w	sp[1680],r9
80008b6a:	87 02       	st.w	r3[0x0],r2
80008b6c:	87 10       	st.w	r3[0x4],r0
80008b6e:	fb 48 06 8c 	st.w	sp[1676],r8
80008b72:	58 78       	cp.w	r8,7
80008b74:	e0 89 00 04 	brgt	80008b7c <_vfprintf_r+0x19b8>
80008b78:	2f 83       	sub	r3,-8
80008b7a:	c0 b8       	rjmp	80008b90 <_vfprintf_r+0x19cc>
80008b7c:	fa ca f9 78 	sub	r10,sp,-1672
80008b80:	02 9b       	mov	r11,r1
80008b82:	08 9c       	mov	r12,r4
80008b84:	fe b0 f3 12 	rcall	800071a8 <__sprint_r>
80008b88:	e0 81 02 9d 	brne	800090c2 <_vfprintf_r+0x1efe>
80008b8c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b90:	21 06       	sub	r6,16
80008b92:	c0 48       	rjmp	80008b9a <_vfprintf_r+0x19d6>
80008b94:	fe c2 bd 24 	sub	r2,pc,-17116
80008b98:	31 00       	mov	r0,16
80008b9a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ba2:	fe ca bd 32 	sub	r10,pc,-17102
80008ba6:	59 06       	cp.w	r6,16
80008ba8:	fe 99 ff dd 	brgt	80008b62 <_vfprintf_r+0x199e>
80008bac:	0c 09       	add	r9,r6
80008bae:	87 0a       	st.w	r3[0x0],r10
80008bb0:	fb 49 06 90 	st.w	sp[1680],r9
80008bb4:	2f f8       	sub	r8,-1
80008bb6:	87 16       	st.w	r3[0x4],r6
80008bb8:	c5 39       	rjmp	80008e5e <_vfprintf_r+0x1c9a>
80008bba:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008bbe:	58 0a       	cp.w	r10,0
80008bc0:	e0 89 00 92 	brgt	80008ce4 <_vfprintf_r+0x1b20>
80008bc4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bc8:	fe c9 bd 6c 	sub	r9,pc,-17044
80008bcc:	2f f8       	sub	r8,-1
80008bce:	87 09       	st.w	r3[0x0],r9
80008bd0:	fb 48 06 90 	st.w	sp[1680],r8
80008bd4:	30 19       	mov	r9,1
80008bd6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bda:	87 19       	st.w	r3[0x4],r9
80008bdc:	2f f8       	sub	r8,-1
80008bde:	fb 48 06 8c 	st.w	sp[1676],r8
80008be2:	58 78       	cp.w	r8,7
80008be4:	e0 89 00 04 	brgt	80008bec <_vfprintf_r+0x1a28>
80008be8:	2f 83       	sub	r3,-8
80008bea:	c0 b8       	rjmp	80008c00 <_vfprintf_r+0x1a3c>
80008bec:	fa ca f9 78 	sub	r10,sp,-1672
80008bf0:	02 9b       	mov	r11,r1
80008bf2:	08 9c       	mov	r12,r4
80008bf4:	fe b0 f2 da 	rcall	800071a8 <__sprint_r>
80008bf8:	e0 81 02 65 	brne	800090c2 <_vfprintf_r+0x1efe>
80008bfc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c00:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c04:	58 08       	cp.w	r8,0
80008c06:	c0 81       	brne	80008c16 <_vfprintf_r+0x1a52>
80008c08:	40 6a       	lddsp	r10,sp[0x18]
80008c0a:	58 0a       	cp.w	r10,0
80008c0c:	c0 51       	brne	80008c16 <_vfprintf_r+0x1a52>
80008c0e:	ed b5 00 00 	bld	r5,0x0
80008c12:	e0 81 01 ed 	brne	80008fec <_vfprintf_r+0x1e28>
80008c16:	40 c9       	lddsp	r9,sp[0x30]
80008c18:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c1c:	2f f8       	sub	r8,-1
80008c1e:	87 09       	st.w	r3[0x0],r9
80008c20:	fb 48 06 90 	st.w	sp[1680],r8
80008c24:	30 19       	mov	r9,1
80008c26:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c2a:	87 19       	st.w	r3[0x4],r9
80008c2c:	2f f8       	sub	r8,-1
80008c2e:	fb 48 06 8c 	st.w	sp[1676],r8
80008c32:	58 78       	cp.w	r8,7
80008c34:	e0 89 00 04 	brgt	80008c3c <_vfprintf_r+0x1a78>
80008c38:	2f 83       	sub	r3,-8
80008c3a:	c0 b8       	rjmp	80008c50 <_vfprintf_r+0x1a8c>
80008c3c:	fa ca f9 78 	sub	r10,sp,-1672
80008c40:	02 9b       	mov	r11,r1
80008c42:	08 9c       	mov	r12,r4
80008c44:	fe b0 f2 b2 	rcall	800071a8 <__sprint_r>
80008c48:	e0 81 02 3d 	brne	800090c2 <_vfprintf_r+0x1efe>
80008c4c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c50:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c54:	5c 32       	neg	r2
80008c56:	58 02       	cp.w	r2,0
80008c58:	e0 89 00 1d 	brgt	80008c92 <_vfprintf_r+0x1ace>
80008c5c:	c3 d8       	rjmp	80008cd6 <_vfprintf_r+0x1b12>
80008c5e:	2f 09       	sub	r9,-16
80008c60:	2f f8       	sub	r8,-1
80008c62:	31 0e       	mov	lr,16
80008c64:	fb 49 06 90 	st.w	sp[1680],r9
80008c68:	87 00       	st.w	r3[0x0],r0
80008c6a:	87 1e       	st.w	r3[0x4],lr
80008c6c:	fb 48 06 8c 	st.w	sp[1676],r8
80008c70:	58 78       	cp.w	r8,7
80008c72:	e0 89 00 04 	brgt	80008c7a <_vfprintf_r+0x1ab6>
80008c76:	2f 83       	sub	r3,-8
80008c78:	c0 b8       	rjmp	80008c8e <_vfprintf_r+0x1aca>
80008c7a:	fa ca f9 78 	sub	r10,sp,-1672
80008c7e:	02 9b       	mov	r11,r1
80008c80:	08 9c       	mov	r12,r4
80008c82:	fe b0 f2 93 	rcall	800071a8 <__sprint_r>
80008c86:	e0 81 02 1e 	brne	800090c2 <_vfprintf_r+0x1efe>
80008c8a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c8e:	21 02       	sub	r2,16
80008c90:	c0 38       	rjmp	80008c96 <_vfprintf_r+0x1ad2>
80008c92:	fe c0 be 22 	sub	r0,pc,-16862
80008c96:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c9e:	fe ca be 2e 	sub	r10,pc,-16850
80008ca2:	59 02       	cp.w	r2,16
80008ca4:	fe 99 ff dd 	brgt	80008c5e <_vfprintf_r+0x1a9a>
80008ca8:	04 09       	add	r9,r2
80008caa:	2f f8       	sub	r8,-1
80008cac:	87 0a       	st.w	r3[0x0],r10
80008cae:	fb 49 06 90 	st.w	sp[1680],r9
80008cb2:	87 12       	st.w	r3[0x4],r2
80008cb4:	fb 48 06 8c 	st.w	sp[1676],r8
80008cb8:	58 78       	cp.w	r8,7
80008cba:	e0 89 00 04 	brgt	80008cc2 <_vfprintf_r+0x1afe>
80008cbe:	2f 83       	sub	r3,-8
80008cc0:	c0 b8       	rjmp	80008cd6 <_vfprintf_r+0x1b12>
80008cc2:	fa ca f9 78 	sub	r10,sp,-1672
80008cc6:	02 9b       	mov	r11,r1
80008cc8:	08 9c       	mov	r12,r4
80008cca:	fe b0 f2 6f 	rcall	800071a8 <__sprint_r>
80008cce:	e0 81 01 fa 	brne	800090c2 <_vfprintf_r+0x1efe>
80008cd2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cd6:	40 6c       	lddsp	r12,sp[0x18]
80008cd8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008cdc:	87 06       	st.w	r3[0x0],r6
80008cde:	87 1c       	st.w	r3[0x4],r12
80008ce0:	18 08       	add	r8,r12
80008ce2:	cb 98       	rjmp	80008e54 <_vfprintf_r+0x1c90>
80008ce4:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ce8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cec:	40 6b       	lddsp	r11,sp[0x18]
80008cee:	16 3a       	cp.w	r10,r11
80008cf0:	c6 f5       	brlt	80008dce <_vfprintf_r+0x1c0a>
80008cf2:	16 09       	add	r9,r11
80008cf4:	2f f8       	sub	r8,-1
80008cf6:	87 06       	st.w	r3[0x0],r6
80008cf8:	fb 49 06 90 	st.w	sp[1680],r9
80008cfc:	87 1b       	st.w	r3[0x4],r11
80008cfe:	fb 48 06 8c 	st.w	sp[1676],r8
80008d02:	58 78       	cp.w	r8,7
80008d04:	e0 89 00 04 	brgt	80008d0c <_vfprintf_r+0x1b48>
80008d08:	2f 83       	sub	r3,-8
80008d0a:	c0 b8       	rjmp	80008d20 <_vfprintf_r+0x1b5c>
80008d0c:	fa ca f9 78 	sub	r10,sp,-1672
80008d10:	02 9b       	mov	r11,r1
80008d12:	08 9c       	mov	r12,r4
80008d14:	fe b0 f2 4a 	rcall	800071a8 <__sprint_r>
80008d18:	e0 81 01 d5 	brne	800090c2 <_vfprintf_r+0x1efe>
80008d1c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d20:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008d24:	40 6a       	lddsp	r10,sp[0x18]
80008d26:	14 16       	sub	r6,r10
80008d28:	58 06       	cp.w	r6,0
80008d2a:	e0 89 00 1c 	brgt	80008d62 <_vfprintf_r+0x1b9e>
80008d2e:	c3 d8       	rjmp	80008da8 <_vfprintf_r+0x1be4>
80008d30:	2f 09       	sub	r9,-16
80008d32:	2f f8       	sub	r8,-1
80008d34:	fb 49 06 90 	st.w	sp[1680],r9
80008d38:	87 02       	st.w	r3[0x0],r2
80008d3a:	87 10       	st.w	r3[0x4],r0
80008d3c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d40:	58 78       	cp.w	r8,7
80008d42:	e0 89 00 04 	brgt	80008d4a <_vfprintf_r+0x1b86>
80008d46:	2f 83       	sub	r3,-8
80008d48:	c0 b8       	rjmp	80008d5e <_vfprintf_r+0x1b9a>
80008d4a:	fa ca f9 78 	sub	r10,sp,-1672
80008d4e:	02 9b       	mov	r11,r1
80008d50:	08 9c       	mov	r12,r4
80008d52:	fe b0 f2 2b 	rcall	800071a8 <__sprint_r>
80008d56:	e0 81 01 b6 	brne	800090c2 <_vfprintf_r+0x1efe>
80008d5a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d5e:	21 06       	sub	r6,16
80008d60:	c0 48       	rjmp	80008d68 <_vfprintf_r+0x1ba4>
80008d62:	fe c2 be f2 	sub	r2,pc,-16654
80008d66:	31 00       	mov	r0,16
80008d68:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d70:	fe ca bf 00 	sub	r10,pc,-16640
80008d74:	59 06       	cp.w	r6,16
80008d76:	fe 99 ff dd 	brgt	80008d30 <_vfprintf_r+0x1b6c>
80008d7a:	0c 09       	add	r9,r6
80008d7c:	2f f8       	sub	r8,-1
80008d7e:	87 0a       	st.w	r3[0x0],r10
80008d80:	fb 49 06 90 	st.w	sp[1680],r9
80008d84:	87 16       	st.w	r3[0x4],r6
80008d86:	fb 48 06 8c 	st.w	sp[1676],r8
80008d8a:	58 78       	cp.w	r8,7
80008d8c:	e0 89 00 04 	brgt	80008d94 <_vfprintf_r+0x1bd0>
80008d90:	2f 83       	sub	r3,-8
80008d92:	c0 b8       	rjmp	80008da8 <_vfprintf_r+0x1be4>
80008d94:	fa ca f9 78 	sub	r10,sp,-1672
80008d98:	02 9b       	mov	r11,r1
80008d9a:	08 9c       	mov	r12,r4
80008d9c:	fe b0 f2 06 	rcall	800071a8 <__sprint_r>
80008da0:	e0 81 01 91 	brne	800090c2 <_vfprintf_r+0x1efe>
80008da4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008da8:	ed b5 00 00 	bld	r5,0x0
80008dac:	e0 81 01 20 	brne	80008fec <_vfprintf_r+0x1e28>
80008db0:	40 c9       	lddsp	r9,sp[0x30]
80008db2:	fa f8 06 90 	ld.w	r8,sp[1680]
80008db6:	2f f8       	sub	r8,-1
80008db8:	87 09       	st.w	r3[0x0],r9
80008dba:	fb 48 06 90 	st.w	sp[1680],r8
80008dbe:	30 19       	mov	r9,1
80008dc0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dc4:	87 19       	st.w	r3[0x4],r9
80008dc6:	2f f8       	sub	r8,-1
80008dc8:	fb 48 06 8c 	st.w	sp[1676],r8
80008dcc:	c0 29       	rjmp	80008fd0 <_vfprintf_r+0x1e0c>
80008dce:	14 09       	add	r9,r10
80008dd0:	2f f8       	sub	r8,-1
80008dd2:	fb 49 06 90 	st.w	sp[1680],r9
80008dd6:	87 06       	st.w	r3[0x0],r6
80008dd8:	87 1a       	st.w	r3[0x4],r10
80008dda:	fb 48 06 8c 	st.w	sp[1676],r8
80008dde:	58 78       	cp.w	r8,7
80008de0:	e0 89 00 04 	brgt	80008de8 <_vfprintf_r+0x1c24>
80008de4:	2f 83       	sub	r3,-8
80008de6:	c0 b8       	rjmp	80008dfc <_vfprintf_r+0x1c38>
80008de8:	fa ca f9 78 	sub	r10,sp,-1672
80008dec:	02 9b       	mov	r11,r1
80008dee:	08 9c       	mov	r12,r4
80008df0:	fe b0 f1 dc 	rcall	800071a8 <__sprint_r>
80008df4:	e0 81 01 67 	brne	800090c2 <_vfprintf_r+0x1efe>
80008df8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dfc:	40 c8       	lddsp	r8,sp[0x30]
80008dfe:	87 08       	st.w	r3[0x0],r8
80008e00:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e04:	2f f8       	sub	r8,-1
80008e06:	30 19       	mov	r9,1
80008e08:	fb 48 06 90 	st.w	sp[1680],r8
80008e0c:	87 19       	st.w	r3[0x4],r9
80008e0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e12:	2f f8       	sub	r8,-1
80008e14:	fb 48 06 8c 	st.w	sp[1676],r8
80008e18:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e1c:	58 78       	cp.w	r8,7
80008e1e:	e0 89 00 04 	brgt	80008e26 <_vfprintf_r+0x1c62>
80008e22:	2f 83       	sub	r3,-8
80008e24:	c0 b8       	rjmp	80008e3a <_vfprintf_r+0x1c76>
80008e26:	fa ca f9 78 	sub	r10,sp,-1672
80008e2a:	02 9b       	mov	r11,r1
80008e2c:	08 9c       	mov	r12,r4
80008e2e:	fe b0 f1 bd 	rcall	800071a8 <__sprint_r>
80008e32:	e0 81 01 48 	brne	800090c2 <_vfprintf_r+0x1efe>
80008e36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e3a:	04 06       	add	r6,r2
80008e3c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008e40:	87 06       	st.w	r3[0x0],r6
80008e42:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e46:	40 66       	lddsp	r6,sp[0x18]
80008e48:	40 6e       	lddsp	lr,sp[0x18]
80008e4a:	10 16       	sub	r6,r8
80008e4c:	f2 08 01 08 	sub	r8,r9,r8
80008e50:	87 16       	st.w	r3[0x4],r6
80008e52:	1c 08       	add	r8,lr
80008e54:	fb 48 06 90 	st.w	sp[1680],r8
80008e58:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e5c:	2f f8       	sub	r8,-1
80008e5e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e62:	cb 78       	rjmp	80008fd0 <_vfprintf_r+0x1e0c>
80008e64:	40 6c       	lddsp	r12,sp[0x18]
80008e66:	58 1c       	cp.w	r12,1
80008e68:	e0 89 00 06 	brgt	80008e74 <_vfprintf_r+0x1cb0>
80008e6c:	ed b5 00 00 	bld	r5,0x0
80008e70:	e0 81 00 85 	brne	80008f7a <_vfprintf_r+0x1db6>
80008e74:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e78:	2f f8       	sub	r8,-1
80008e7a:	30 19       	mov	r9,1
80008e7c:	fb 48 06 90 	st.w	sp[1680],r8
80008e80:	87 06       	st.w	r3[0x0],r6
80008e82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e86:	87 19       	st.w	r3[0x4],r9
80008e88:	2f f8       	sub	r8,-1
80008e8a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e8e:	58 78       	cp.w	r8,7
80008e90:	e0 89 00 04 	brgt	80008e98 <_vfprintf_r+0x1cd4>
80008e94:	2f 83       	sub	r3,-8
80008e96:	c0 b8       	rjmp	80008eac <_vfprintf_r+0x1ce8>
80008e98:	fa ca f9 78 	sub	r10,sp,-1672
80008e9c:	02 9b       	mov	r11,r1
80008e9e:	08 9c       	mov	r12,r4
80008ea0:	fe b0 f1 84 	rcall	800071a8 <__sprint_r>
80008ea4:	e0 81 01 0f 	brne	800090c2 <_vfprintf_r+0x1efe>
80008ea8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eac:	fa f8 06 90 	ld.w	r8,sp[1680]
80008eb0:	2f f8       	sub	r8,-1
80008eb2:	40 cb       	lddsp	r11,sp[0x30]
80008eb4:	fb 48 06 90 	st.w	sp[1680],r8
80008eb8:	30 19       	mov	r9,1
80008eba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ebe:	87 0b       	st.w	r3[0x0],r11
80008ec0:	2f f8       	sub	r8,-1
80008ec2:	87 19       	st.w	r3[0x4],r9
80008ec4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ec8:	58 78       	cp.w	r8,7
80008eca:	e0 89 00 05 	brgt	80008ed4 <_vfprintf_r+0x1d10>
80008ece:	2f 83       	sub	r3,-8
80008ed0:	c0 c8       	rjmp	80008ee8 <_vfprintf_r+0x1d24>
80008ed2:	d7 03       	nop
80008ed4:	fa ca f9 78 	sub	r10,sp,-1672
80008ed8:	02 9b       	mov	r11,r1
80008eda:	08 9c       	mov	r12,r4
80008edc:	fe b0 f1 66 	rcall	800071a8 <__sprint_r>
80008ee0:	e0 81 00 f1 	brne	800090c2 <_vfprintf_r+0x1efe>
80008ee4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ee8:	30 08       	mov	r8,0
80008eea:	30 09       	mov	r9,0
80008eec:	40 5b       	lddsp	r11,sp[0x14]
80008eee:	40 7a       	lddsp	r10,sp[0x1c]
80008ef0:	e0 a0 13 19 	rcall	8000b522 <__avr32_f64_cmp_eq>
80008ef4:	40 68       	lddsp	r8,sp[0x18]
80008ef6:	20 18       	sub	r8,1
80008ef8:	58 0c       	cp.w	r12,0
80008efa:	c0 d1       	brne	80008f14 <_vfprintf_r+0x1d50>
80008efc:	2f f6       	sub	r6,-1
80008efe:	87 18       	st.w	r3[0x4],r8
80008f00:	87 06       	st.w	r3[0x0],r6
80008f02:	fa f6 06 90 	ld.w	r6,sp[1680]
80008f06:	10 06       	add	r6,r8
80008f08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f0c:	fb 46 06 90 	st.w	sp[1680],r6
80008f10:	2f f8       	sub	r8,-1
80008f12:	c3 18       	rjmp	80008f74 <_vfprintf_r+0x1db0>
80008f14:	10 96       	mov	r6,r8
80008f16:	58 08       	cp.w	r8,0
80008f18:	e0 89 00 1c 	brgt	80008f50 <_vfprintf_r+0x1d8c>
80008f1c:	c4 b8       	rjmp	80008fb2 <_vfprintf_r+0x1dee>
80008f1e:	2f 09       	sub	r9,-16
80008f20:	2f f8       	sub	r8,-1
80008f22:	fb 49 06 90 	st.w	sp[1680],r9
80008f26:	87 02       	st.w	r3[0x0],r2
80008f28:	87 10       	st.w	r3[0x4],r0
80008f2a:	fb 48 06 8c 	st.w	sp[1676],r8
80008f2e:	58 78       	cp.w	r8,7
80008f30:	e0 89 00 04 	brgt	80008f38 <_vfprintf_r+0x1d74>
80008f34:	2f 83       	sub	r3,-8
80008f36:	c0 b8       	rjmp	80008f4c <_vfprintf_r+0x1d88>
80008f38:	fa ca f9 78 	sub	r10,sp,-1672
80008f3c:	02 9b       	mov	r11,r1
80008f3e:	08 9c       	mov	r12,r4
80008f40:	fe b0 f1 34 	rcall	800071a8 <__sprint_r>
80008f44:	e0 81 00 bf 	brne	800090c2 <_vfprintf_r+0x1efe>
80008f48:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f4c:	21 06       	sub	r6,16
80008f4e:	c0 48       	rjmp	80008f56 <_vfprintf_r+0x1d92>
80008f50:	fe c2 c0 e0 	sub	r2,pc,-16160
80008f54:	31 00       	mov	r0,16
80008f56:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f5e:	fe ca c0 ee 	sub	r10,pc,-16146
80008f62:	59 06       	cp.w	r6,16
80008f64:	fe 99 ff dd 	brgt	80008f1e <_vfprintf_r+0x1d5a>
80008f68:	0c 09       	add	r9,r6
80008f6a:	87 0a       	st.w	r3[0x0],r10
80008f6c:	fb 49 06 90 	st.w	sp[1680],r9
80008f70:	2f f8       	sub	r8,-1
80008f72:	87 16       	st.w	r3[0x4],r6
80008f74:	fb 48 06 8c 	st.w	sp[1676],r8
80008f78:	c0 e8       	rjmp	80008f94 <_vfprintf_r+0x1dd0>
80008f7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f7e:	2f f8       	sub	r8,-1
80008f80:	30 19       	mov	r9,1
80008f82:	fb 48 06 90 	st.w	sp[1680],r8
80008f86:	87 06       	st.w	r3[0x0],r6
80008f88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f8c:	87 19       	st.w	r3[0x4],r9
80008f8e:	2f f8       	sub	r8,-1
80008f90:	fb 48 06 8c 	st.w	sp[1676],r8
80008f94:	58 78       	cp.w	r8,7
80008f96:	e0 89 00 04 	brgt	80008f9e <_vfprintf_r+0x1dda>
80008f9a:	2f 83       	sub	r3,-8
80008f9c:	c0 b8       	rjmp	80008fb2 <_vfprintf_r+0x1dee>
80008f9e:	fa ca f9 78 	sub	r10,sp,-1672
80008fa2:	02 9b       	mov	r11,r1
80008fa4:	08 9c       	mov	r12,r4
80008fa6:	fe b0 f1 01 	rcall	800071a8 <__sprint_r>
80008faa:	e0 81 00 8c 	brne	800090c2 <_vfprintf_r+0x1efe>
80008fae:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fb2:	40 ea       	lddsp	r10,sp[0x38]
80008fb4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fb8:	14 08       	add	r8,r10
80008fba:	fa c9 f9 64 	sub	r9,sp,-1692
80008fbe:	fb 48 06 90 	st.w	sp[1680],r8
80008fc2:	87 1a       	st.w	r3[0x4],r10
80008fc4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fc8:	87 09       	st.w	r3[0x0],r9
80008fca:	2f f8       	sub	r8,-1
80008fcc:	fb 48 06 8c 	st.w	sp[1676],r8
80008fd0:	58 78       	cp.w	r8,7
80008fd2:	e0 89 00 04 	brgt	80008fda <_vfprintf_r+0x1e16>
80008fd6:	2f 83       	sub	r3,-8
80008fd8:	c0 a8       	rjmp	80008fec <_vfprintf_r+0x1e28>
80008fda:	fa ca f9 78 	sub	r10,sp,-1672
80008fde:	02 9b       	mov	r11,r1
80008fe0:	08 9c       	mov	r12,r4
80008fe2:	fe b0 f0 e3 	rcall	800071a8 <__sprint_r>
80008fe6:	c6 e1       	brne	800090c2 <_vfprintf_r+0x1efe>
80008fe8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fec:	e2 15 00 04 	andl	r5,0x4,COH
80008ff0:	c3 f0       	breq	8000906e <_vfprintf_r+0x1eaa>
80008ff2:	40 86       	lddsp	r6,sp[0x20]
80008ff4:	40 39       	lddsp	r9,sp[0xc]
80008ff6:	12 16       	sub	r6,r9
80008ff8:	58 06       	cp.w	r6,0
80008ffa:	e0 89 00 1a 	brgt	8000902e <_vfprintf_r+0x1e6a>
80008ffe:	c3 88       	rjmp	8000906e <_vfprintf_r+0x1eaa>
80009000:	2f 09       	sub	r9,-16
80009002:	2f f8       	sub	r8,-1
80009004:	fb 49 06 90 	st.w	sp[1680],r9
80009008:	87 05       	st.w	r3[0x0],r5
8000900a:	87 12       	st.w	r3[0x4],r2
8000900c:	fb 48 06 8c 	st.w	sp[1676],r8
80009010:	58 78       	cp.w	r8,7
80009012:	e0 89 00 04 	brgt	8000901a <_vfprintf_r+0x1e56>
80009016:	2f 83       	sub	r3,-8
80009018:	c0 98       	rjmp	8000902a <_vfprintf_r+0x1e66>
8000901a:	00 9a       	mov	r10,r0
8000901c:	02 9b       	mov	r11,r1
8000901e:	08 9c       	mov	r12,r4
80009020:	fe b0 f0 c4 	rcall	800071a8 <__sprint_r>
80009024:	c4 f1       	brne	800090c2 <_vfprintf_r+0x1efe>
80009026:	fa c3 f9 e0 	sub	r3,sp,-1568
8000902a:	21 06       	sub	r6,16
8000902c:	c0 68       	rjmp	80009038 <_vfprintf_r+0x1e74>
8000902e:	fe c5 c1 ce 	sub	r5,pc,-15922
80009032:	31 02       	mov	r2,16
80009034:	fa c0 f9 78 	sub	r0,sp,-1672
80009038:	fa f9 06 90 	ld.w	r9,sp[1680]
8000903c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009040:	fe ca c1 e0 	sub	r10,pc,-15904
80009044:	59 06       	cp.w	r6,16
80009046:	fe 99 ff dd 	brgt	80009000 <_vfprintf_r+0x1e3c>
8000904a:	0c 09       	add	r9,r6
8000904c:	2f f8       	sub	r8,-1
8000904e:	87 0a       	st.w	r3[0x0],r10
80009050:	87 16       	st.w	r3[0x4],r6
80009052:	fb 49 06 90 	st.w	sp[1680],r9
80009056:	fb 48 06 8c 	st.w	sp[1676],r8
8000905a:	58 78       	cp.w	r8,7
8000905c:	e0 8a 00 09 	brle	8000906e <_vfprintf_r+0x1eaa>
80009060:	fa ca f9 78 	sub	r10,sp,-1672
80009064:	02 9b       	mov	r11,r1
80009066:	08 9c       	mov	r12,r4
80009068:	fe b0 f0 a0 	rcall	800071a8 <__sprint_r>
8000906c:	c2 b1       	brne	800090c2 <_vfprintf_r+0x1efe>
8000906e:	40 bc       	lddsp	r12,sp[0x2c]
80009070:	40 36       	lddsp	r6,sp[0xc]
80009072:	40 8e       	lddsp	lr,sp[0x20]
80009074:	ec 0e 0c 48 	max	r8,r6,lr
80009078:	10 0c       	add	r12,r8
8000907a:	50 bc       	stdsp	sp[0x2c],r12
8000907c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009080:	58 08       	cp.w	r8,0
80009082:	c0 80       	breq	80009092 <_vfprintf_r+0x1ece>
80009084:	fa ca f9 78 	sub	r10,sp,-1672
80009088:	02 9b       	mov	r11,r1
8000908a:	08 9c       	mov	r12,r4
8000908c:	fe b0 f0 8e 	rcall	800071a8 <__sprint_r>
80009090:	c1 91       	brne	800090c2 <_vfprintf_r+0x1efe>
80009092:	30 0b       	mov	r11,0
80009094:	fa c3 f9 e0 	sub	r3,sp,-1568
80009098:	fb 4b 06 8c 	st.w	sp[1676],r11
8000909c:	fe 9f f1 22 	bral	800072e0 <_vfprintf_r+0x11c>
800090a0:	08 95       	mov	r5,r4
800090a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800090a6:	58 08       	cp.w	r8,0
800090a8:	c0 80       	breq	800090b8 <_vfprintf_r+0x1ef4>
800090aa:	08 9c       	mov	r12,r4
800090ac:	fa ca f9 78 	sub	r10,sp,-1672
800090b0:	02 9b       	mov	r11,r1
800090b2:	fe b0 f0 7b 	rcall	800071a8 <__sprint_r>
800090b6:	c0 61       	brne	800090c2 <_vfprintf_r+0x1efe>
800090b8:	30 08       	mov	r8,0
800090ba:	fb 48 06 8c 	st.w	sp[1676],r8
800090be:	c0 28       	rjmp	800090c2 <_vfprintf_r+0x1efe>
800090c0:	40 41       	lddsp	r1,sp[0x10]
800090c2:	82 68       	ld.sh	r8,r1[0xc]
800090c4:	ed b8 00 06 	bld	r8,0x6
800090c8:	c0 31       	brne	800090ce <_vfprintf_r+0x1f0a>
800090ca:	3f fa       	mov	r10,-1
800090cc:	50 ba       	stdsp	sp[0x2c],r10
800090ce:	40 bc       	lddsp	r12,sp[0x2c]
800090d0:	fe 3d f9 44 	sub	sp,-1724
800090d4:	d8 32       	popm	r0-r7,pc
800090d6:	d7 03       	nop

800090d8 <__swsetup_r>:
800090d8:	d4 21       	pushm	r4-r7,lr
800090da:	e0 68 0a 44 	mov	r8,2628
800090de:	18 96       	mov	r6,r12
800090e0:	16 97       	mov	r7,r11
800090e2:	70 0c       	ld.w	r12,r8[0x0]
800090e4:	58 0c       	cp.w	r12,0
800090e6:	c0 60       	breq	800090f2 <__swsetup_r+0x1a>
800090e8:	78 68       	ld.w	r8,r12[0x18]
800090ea:	58 08       	cp.w	r8,0
800090ec:	c0 31       	brne	800090f2 <__swsetup_r+0x1a>
800090ee:	e0 a0 07 bf 	rcall	8000a06c <__sinit>
800090f2:	fe c8 c1 62 	sub	r8,pc,-16030
800090f6:	10 37       	cp.w	r7,r8
800090f8:	c0 61       	brne	80009104 <__swsetup_r+0x2c>
800090fa:	e0 68 0a 44 	mov	r8,2628
800090fe:	70 08       	ld.w	r8,r8[0x0]
80009100:	70 07       	ld.w	r7,r8[0x0]
80009102:	c1 28       	rjmp	80009126 <__swsetup_r+0x4e>
80009104:	fe c8 c1 54 	sub	r8,pc,-16044
80009108:	10 37       	cp.w	r7,r8
8000910a:	c0 61       	brne	80009116 <__swsetup_r+0x3e>
8000910c:	e0 68 0a 44 	mov	r8,2628
80009110:	70 08       	ld.w	r8,r8[0x0]
80009112:	70 17       	ld.w	r7,r8[0x4]
80009114:	c0 98       	rjmp	80009126 <__swsetup_r+0x4e>
80009116:	fe c8 c1 46 	sub	r8,pc,-16058
8000911a:	10 37       	cp.w	r7,r8
8000911c:	c0 51       	brne	80009126 <__swsetup_r+0x4e>
8000911e:	e0 68 0a 44 	mov	r8,2628
80009122:	70 08       	ld.w	r8,r8[0x0]
80009124:	70 27       	ld.w	r7,r8[0x8]
80009126:	8e 68       	ld.sh	r8,r7[0xc]
80009128:	ed b8 00 03 	bld	r8,0x3
8000912c:	c1 e0       	breq	80009168 <__swsetup_r+0x90>
8000912e:	ed b8 00 04 	bld	r8,0x4
80009132:	c3 e1       	brne	800091ae <__swsetup_r+0xd6>
80009134:	ed b8 00 02 	bld	r8,0x2
80009138:	c1 51       	brne	80009162 <__swsetup_r+0x8a>
8000913a:	6e db       	ld.w	r11,r7[0x34]
8000913c:	58 0b       	cp.w	r11,0
8000913e:	c0 a0       	breq	80009152 <__swsetup_r+0x7a>
80009140:	ee c8 ff bc 	sub	r8,r7,-68
80009144:	10 3b       	cp.w	r11,r8
80009146:	c0 40       	breq	8000914e <__swsetup_r+0x76>
80009148:	0c 9c       	mov	r12,r6
8000914a:	e0 a0 08 2b 	rcall	8000a1a0 <_free_r>
8000914e:	30 08       	mov	r8,0
80009150:	8f d8       	st.w	r7[0x34],r8
80009152:	8e 68       	ld.sh	r8,r7[0xc]
80009154:	e0 18 ff db 	andl	r8,0xffdb
80009158:	ae 68       	st.h	r7[0xc],r8
8000915a:	30 08       	mov	r8,0
8000915c:	8f 18       	st.w	r7[0x4],r8
8000915e:	6e 48       	ld.w	r8,r7[0x10]
80009160:	8f 08       	st.w	r7[0x0],r8
80009162:	8e 68       	ld.sh	r8,r7[0xc]
80009164:	a3 b8       	sbr	r8,0x3
80009166:	ae 68       	st.h	r7[0xc],r8
80009168:	6e 48       	ld.w	r8,r7[0x10]
8000916a:	58 08       	cp.w	r8,0
8000916c:	c0 b1       	brne	80009182 <__swsetup_r+0xaa>
8000916e:	8e 68       	ld.sh	r8,r7[0xc]
80009170:	e2 18 02 80 	andl	r8,0x280,COH
80009174:	e0 48 02 00 	cp.w	r8,512
80009178:	c0 50       	breq	80009182 <__swsetup_r+0xaa>
8000917a:	0c 9c       	mov	r12,r6
8000917c:	0e 9b       	mov	r11,r7
8000917e:	e0 a0 0a 4b 	rcall	8000a614 <__smakebuf_r>
80009182:	8e 69       	ld.sh	r9,r7[0xc]
80009184:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009188:	c0 70       	breq	80009196 <__swsetup_r+0xbe>
8000918a:	30 08       	mov	r8,0
8000918c:	8f 28       	st.w	r7[0x8],r8
8000918e:	6e 58       	ld.w	r8,r7[0x14]
80009190:	5c 38       	neg	r8
80009192:	8f 68       	st.w	r7[0x18],r8
80009194:	c0 68       	rjmp	800091a0 <__swsetup_r+0xc8>
80009196:	ed b9 00 01 	bld	r9,0x1
8000919a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000919e:	8f 28       	st.w	r7[0x8],r8
800091a0:	6e 48       	ld.w	r8,r7[0x10]
800091a2:	58 08       	cp.w	r8,0
800091a4:	c0 61       	brne	800091b0 <__swsetup_r+0xd8>
800091a6:	8e 68       	ld.sh	r8,r7[0xc]
800091a8:	ed b8 00 07 	bld	r8,0x7
800091ac:	c0 21       	brne	800091b0 <__swsetup_r+0xd8>
800091ae:	dc 2a       	popm	r4-r7,pc,r12=-1
800091b0:	d8 2a       	popm	r4-r7,pc,r12=0
800091b2:	d7 03       	nop

800091b4 <quorem>:
800091b4:	d4 31       	pushm	r0-r7,lr
800091b6:	20 2d       	sub	sp,8
800091b8:	18 97       	mov	r7,r12
800091ba:	78 48       	ld.w	r8,r12[0x10]
800091bc:	76 46       	ld.w	r6,r11[0x10]
800091be:	0c 38       	cp.w	r8,r6
800091c0:	c0 34       	brge	800091c6 <quorem+0x12>
800091c2:	30 0c       	mov	r12,0
800091c4:	c8 58       	rjmp	800092ce <quorem+0x11a>
800091c6:	ec c2 ff fc 	sub	r2,r6,-4
800091ca:	f6 c3 ff ec 	sub	r3,r11,-20
800091ce:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800091d2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800091d6:	2f f9       	sub	r9,-1
800091d8:	20 16       	sub	r6,1
800091da:	f8 09 0d 08 	divu	r8,r12,r9
800091de:	f6 02 00 22 	add	r2,r11,r2<<0x2
800091e2:	ee c4 ff ec 	sub	r4,r7,-20
800091e6:	10 95       	mov	r5,r8
800091e8:	58 08       	cp.w	r8,0
800091ea:	c4 10       	breq	8000926c <quorem+0xb8>
800091ec:	30 09       	mov	r9,0
800091ee:	06 9a       	mov	r10,r3
800091f0:	08 98       	mov	r8,r4
800091f2:	12 91       	mov	r1,r9
800091f4:	50 0b       	stdsp	sp[0x0],r11
800091f6:	70 0e       	ld.w	lr,r8[0x0]
800091f8:	b1 8e       	lsr	lr,0x10
800091fa:	50 1e       	stdsp	sp[0x4],lr
800091fc:	15 0e       	ld.w	lr,r10++
800091fe:	fc 00 16 10 	lsr	r0,lr,0x10
80009202:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009206:	ea 0e 03 41 	mac	r1,r5,lr
8000920a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000920e:	b1 81       	lsr	r1,0x10
80009210:	40 1b       	lddsp	r11,sp[0x4]
80009212:	ea 00 02 40 	mul	r0,r5,r0
80009216:	e2 00 00 00 	add	r0,r1,r0
8000921a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000921e:	02 1b       	sub	r11,r1
80009220:	50 1b       	stdsp	sp[0x4],r11
80009222:	70 0b       	ld.w	r11,r8[0x0]
80009224:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009228:	02 09       	add	r9,r1
8000922a:	f2 0e 01 0e 	sub	lr,r9,lr
8000922e:	b0 1e       	st.h	r8[0x2],lr
80009230:	fc 09 14 10 	asr	r9,lr,0x10
80009234:	40 1e       	lddsp	lr,sp[0x4]
80009236:	fc 09 00 09 	add	r9,lr,r9
8000923a:	b0 09       	st.h	r8[0x0],r9
8000923c:	e0 01 16 10 	lsr	r1,r0,0x10
80009240:	2f c8       	sub	r8,-4
80009242:	b1 49       	asr	r9,0x10
80009244:	04 3a       	cp.w	r10,r2
80009246:	fe 98 ff d8 	brls	800091f6 <quorem+0x42>
8000924a:	40 0b       	lddsp	r11,sp[0x0]
8000924c:	58 0c       	cp.w	r12,0
8000924e:	c0 f1       	brne	8000926c <quorem+0xb8>
80009250:	ec c8 ff fb 	sub	r8,r6,-5
80009254:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009258:	c0 28       	rjmp	8000925c <quorem+0xa8>
8000925a:	20 16       	sub	r6,1
8000925c:	20 48       	sub	r8,4
8000925e:	08 38       	cp.w	r8,r4
80009260:	e0 88 00 05 	brls	8000926a <quorem+0xb6>
80009264:	70 09       	ld.w	r9,r8[0x0]
80009266:	58 09       	cp.w	r9,0
80009268:	cf 90       	breq	8000925a <quorem+0xa6>
8000926a:	8f 46       	st.w	r7[0x10],r6
8000926c:	0e 9c       	mov	r12,r7
8000926e:	e0 a0 0a d2 	rcall	8000a812 <__mcmp>
80009272:	c2 d5       	brlt	800092cc <quorem+0x118>
80009274:	2f f5       	sub	r5,-1
80009276:	08 98       	mov	r8,r4
80009278:	30 09       	mov	r9,0
8000927a:	07 0b       	ld.w	r11,r3++
8000927c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009280:	70 0c       	ld.w	r12,r8[0x0]
80009282:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009286:	f8 0e 16 10 	lsr	lr,r12,0x10
8000928a:	14 1e       	sub	lr,r10
8000928c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009290:	16 1a       	sub	r10,r11
80009292:	12 0a       	add	r10,r9
80009294:	b0 1a       	st.h	r8[0x2],r10
80009296:	b1 4a       	asr	r10,0x10
80009298:	fc 0a 00 09 	add	r9,lr,r10
8000929c:	b0 09       	st.h	r8[0x0],r9
8000929e:	2f c8       	sub	r8,-4
800092a0:	b1 49       	asr	r9,0x10
800092a2:	04 33       	cp.w	r3,r2
800092a4:	fe 98 ff eb 	brls	8000927a <quorem+0xc6>
800092a8:	ec c8 ff fb 	sub	r8,r6,-5
800092ac:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800092b0:	58 09       	cp.w	r9,0
800092b2:	c0 d1       	brne	800092cc <quorem+0x118>
800092b4:	ee 08 00 28 	add	r8,r7,r8<<0x2
800092b8:	c0 28       	rjmp	800092bc <quorem+0x108>
800092ba:	20 16       	sub	r6,1
800092bc:	20 48       	sub	r8,4
800092be:	08 38       	cp.w	r8,r4
800092c0:	e0 88 00 05 	brls	800092ca <quorem+0x116>
800092c4:	70 09       	ld.w	r9,r8[0x0]
800092c6:	58 09       	cp.w	r9,0
800092c8:	cf 90       	breq	800092ba <quorem+0x106>
800092ca:	8f 46       	st.w	r7[0x10],r6
800092cc:	0a 9c       	mov	r12,r5
800092ce:	2f ed       	sub	sp,-8
800092d0:	d8 32       	popm	r0-r7,pc
800092d2:	d7 03       	nop

800092d4 <_dtoa_r>:
800092d4:	d4 31       	pushm	r0-r7,lr
800092d6:	21 ad       	sub	sp,104
800092d8:	fa c4 ff 74 	sub	r4,sp,-140
800092dc:	18 97       	mov	r7,r12
800092de:	16 95       	mov	r5,r11
800092e0:	68 2c       	ld.w	r12,r4[0x8]
800092e2:	50 c9       	stdsp	sp[0x30],r9
800092e4:	68 16       	ld.w	r6,r4[0x4]
800092e6:	68 09       	ld.w	r9,r4[0x0]
800092e8:	50 e8       	stdsp	sp[0x38],r8
800092ea:	14 94       	mov	r4,r10
800092ec:	51 2c       	stdsp	sp[0x48],r12
800092ee:	fa e5 00 08 	st.d	sp[8],r4
800092f2:	51 59       	stdsp	sp[0x54],r9
800092f4:	6e 95       	ld.w	r5,r7[0x24]
800092f6:	58 05       	cp.w	r5,0
800092f8:	c0 91       	brne	8000930a <_dtoa_r+0x36>
800092fa:	31 0c       	mov	r12,16
800092fc:	fe b0 e8 e8 	rcall	800064cc <malloc>
80009300:	99 35       	st.w	r12[0xc],r5
80009302:	8f 9c       	st.w	r7[0x24],r12
80009304:	99 15       	st.w	r12[0x4],r5
80009306:	99 25       	st.w	r12[0x8],r5
80009308:	99 05       	st.w	r12[0x0],r5
8000930a:	6e 99       	ld.w	r9,r7[0x24]
8000930c:	72 08       	ld.w	r8,r9[0x0]
8000930e:	58 08       	cp.w	r8,0
80009310:	c0 f0       	breq	8000932e <_dtoa_r+0x5a>
80009312:	72 1a       	ld.w	r10,r9[0x4]
80009314:	91 1a       	st.w	r8[0x4],r10
80009316:	30 1a       	mov	r10,1
80009318:	72 19       	ld.w	r9,r9[0x4]
8000931a:	f4 09 09 49 	lsl	r9,r10,r9
8000931e:	10 9b       	mov	r11,r8
80009320:	91 29       	st.w	r8[0x8],r9
80009322:	0e 9c       	mov	r12,r7
80009324:	e0 a0 0a 90 	rcall	8000a844 <_Bfree>
80009328:	6e 98       	ld.w	r8,r7[0x24]
8000932a:	30 09       	mov	r9,0
8000932c:	91 09       	st.w	r8[0x0],r9
8000932e:	40 28       	lddsp	r8,sp[0x8]
80009330:	10 94       	mov	r4,r8
80009332:	58 08       	cp.w	r8,0
80009334:	c0 64       	brge	80009340 <_dtoa_r+0x6c>
80009336:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000933a:	50 28       	stdsp	sp[0x8],r8
8000933c:	30 18       	mov	r8,1
8000933e:	c0 28       	rjmp	80009342 <_dtoa_r+0x6e>
80009340:	30 08       	mov	r8,0
80009342:	8d 08       	st.w	r6[0x0],r8
80009344:	fc 1c 7f f0 	movh	r12,0x7ff0
80009348:	40 26       	lddsp	r6,sp[0x8]
8000934a:	0c 98       	mov	r8,r6
8000934c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009350:	18 38       	cp.w	r8,r12
80009352:	c2 01       	brne	80009392 <_dtoa_r+0xbe>
80009354:	e0 68 27 0f 	mov	r8,9999
80009358:	41 5b       	lddsp	r11,sp[0x54]
8000935a:	97 08       	st.w	r11[0x0],r8
8000935c:	40 3a       	lddsp	r10,sp[0xc]
8000935e:	58 0a       	cp.w	r10,0
80009360:	c0 71       	brne	8000936e <_dtoa_r+0x9a>
80009362:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009366:	c0 41       	brne	8000936e <_dtoa_r+0x9a>
80009368:	fe cc c3 e8 	sub	r12,pc,-15384
8000936c:	c0 38       	rjmp	80009372 <_dtoa_r+0x9e>
8000936e:	fe cc c3 e2 	sub	r12,pc,-15390
80009372:	41 29       	lddsp	r9,sp[0x48]
80009374:	58 09       	cp.w	r9,0
80009376:	e0 80 05 9a 	breq	80009eaa <_dtoa_r+0xbd6>
8000937a:	f8 c8 ff fd 	sub	r8,r12,-3
8000937e:	f8 c9 ff f8 	sub	r9,r12,-8
80009382:	11 8b       	ld.ub	r11,r8[0x0]
80009384:	30 0a       	mov	r10,0
80009386:	41 25       	lddsp	r5,sp[0x48]
80009388:	f4 0b 18 00 	cp.b	r11,r10
8000938c:	f2 08 17 10 	movne	r8,r9
80009390:	c1 68       	rjmp	800093bc <_dtoa_r+0xe8>
80009392:	fa ea 00 08 	ld.d	r10,sp[8]
80009396:	30 08       	mov	r8,0
80009398:	fa eb 00 3c 	st.d	sp[60],r10
8000939c:	30 09       	mov	r9,0
8000939e:	e0 a0 10 c2 	rcall	8000b522 <__avr32_f64_cmp_eq>
800093a2:	c1 00       	breq	800093c2 <_dtoa_r+0xee>
800093a4:	30 18       	mov	r8,1
800093a6:	41 5a       	lddsp	r10,sp[0x54]
800093a8:	95 08       	st.w	r10[0x0],r8
800093aa:	fe cc c5 4e 	sub	r12,pc,-15026
800093ae:	41 29       	lddsp	r9,sp[0x48]
800093b0:	f8 08 00 08 	add	r8,r12,r8
800093b4:	58 09       	cp.w	r9,0
800093b6:	e0 80 05 7a 	breq	80009eaa <_dtoa_r+0xbd6>
800093ba:	12 95       	mov	r5,r9
800093bc:	8b 08       	st.w	r5[0x0],r8
800093be:	e0 8f 05 76 	bral	80009eaa <_dtoa_r+0xbd6>
800093c2:	fa c8 ff 9c 	sub	r8,sp,-100
800093c6:	fa c9 ff a0 	sub	r9,sp,-96
800093ca:	fa ea 00 3c 	ld.d	r10,sp[60]
800093ce:	0e 9c       	mov	r12,r7
800093d0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800093d4:	e0 a0 0a 8a 	rcall	8000a8e8 <__d2b>
800093d8:	18 93       	mov	r3,r12
800093da:	58 05       	cp.w	r5,0
800093dc:	c0 d0       	breq	800093f6 <_dtoa_r+0x122>
800093de:	fa ea 00 3c 	ld.d	r10,sp[60]
800093e2:	30 04       	mov	r4,0
800093e4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800093e8:	ea c5 03 ff 	sub	r5,r5,1023
800093ec:	10 9b       	mov	r11,r8
800093ee:	51 74       	stdsp	sp[0x5c],r4
800093f0:	ea 1b 3f f0 	orh	r11,0x3ff0
800093f4:	c2 58       	rjmp	8000943e <_dtoa_r+0x16a>
800093f6:	41 88       	lddsp	r8,sp[0x60]
800093f8:	41 9c       	lddsp	r12,sp[0x64]
800093fa:	10 0c       	add	r12,r8
800093fc:	f8 c5 fb ce 	sub	r5,r12,-1074
80009400:	e0 45 00 20 	cp.w	r5,32
80009404:	e0 8a 00 0e 	brle	80009420 <_dtoa_r+0x14c>
80009408:	f8 cc fb ee 	sub	r12,r12,-1042
8000940c:	40 3b       	lddsp	r11,sp[0xc]
8000940e:	ea 08 11 40 	rsub	r8,r5,64
80009412:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009416:	ec 08 09 46 	lsl	r6,r6,r8
8000941a:	0c 4c       	or	r12,r6
8000941c:	c0 78       	rjmp	8000942a <_dtoa_r+0x156>
8000941e:	d7 03       	nop
80009420:	ea 0c 11 20 	rsub	r12,r5,32
80009424:	40 3a       	lddsp	r10,sp[0xc]
80009426:	f4 0c 09 4c 	lsl	r12,r10,r12
8000942a:	e0 a0 10 08 	rcall	8000b43a <__avr32_u32_to_f64>
8000942e:	fc 18 fe 10 	movh	r8,0xfe10
80009432:	30 19       	mov	r9,1
80009434:	ea c5 04 33 	sub	r5,r5,1075
80009438:	f0 0b 00 0b 	add	r11,r8,r11
8000943c:	51 79       	stdsp	sp[0x5c],r9
8000943e:	30 08       	mov	r8,0
80009440:	fc 19 3f f8 	movh	r9,0x3ff8
80009444:	e0 a0 0e 90 	rcall	8000b164 <__avr32_f64_sub>
80009448:	e0 68 43 61 	mov	r8,17249
8000944c:	ea 18 63 6f 	orh	r8,0x636f
80009450:	e0 69 87 a7 	mov	r9,34727
80009454:	ea 19 3f d2 	orh	r9,0x3fd2
80009458:	e0 a0 0d 9a 	rcall	8000af8c <__avr32_f64_mul>
8000945c:	e0 68 c8 b3 	mov	r8,51379
80009460:	ea 18 8b 60 	orh	r8,0x8b60
80009464:	e0 69 8a 28 	mov	r9,35368
80009468:	ea 19 3f c6 	orh	r9,0x3fc6
8000946c:	e0 a0 0f 4a 	rcall	8000b300 <__avr32_f64_add>
80009470:	0a 9c       	mov	r12,r5
80009472:	14 90       	mov	r0,r10
80009474:	16 91       	mov	r1,r11
80009476:	e0 a0 0f e6 	rcall	8000b442 <__avr32_s32_to_f64>
8000947a:	e0 68 79 fb 	mov	r8,31227
8000947e:	ea 18 50 9f 	orh	r8,0x509f
80009482:	e0 69 44 13 	mov	r9,17427
80009486:	ea 19 3f d3 	orh	r9,0x3fd3
8000948a:	e0 a0 0d 81 	rcall	8000af8c <__avr32_f64_mul>
8000948e:	14 98       	mov	r8,r10
80009490:	16 99       	mov	r9,r11
80009492:	00 9a       	mov	r10,r0
80009494:	02 9b       	mov	r11,r1
80009496:	e0 a0 0f 35 	rcall	8000b300 <__avr32_f64_add>
8000949a:	14 90       	mov	r0,r10
8000949c:	16 91       	mov	r1,r11
8000949e:	e0 a0 0f bb 	rcall	8000b414 <__avr32_f64_to_s32>
800094a2:	30 08       	mov	r8,0
800094a4:	18 96       	mov	r6,r12
800094a6:	30 09       	mov	r9,0
800094a8:	00 9a       	mov	r10,r0
800094aa:	02 9b       	mov	r11,r1
800094ac:	e0 a0 10 82 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
800094b0:	c0 c0       	breq	800094c8 <_dtoa_r+0x1f4>
800094b2:	0c 9c       	mov	r12,r6
800094b4:	e0 a0 0f c7 	rcall	8000b442 <__avr32_s32_to_f64>
800094b8:	14 98       	mov	r8,r10
800094ba:	16 99       	mov	r9,r11
800094bc:	00 9a       	mov	r10,r0
800094be:	02 9b       	mov	r11,r1
800094c0:	e0 a0 10 31 	rcall	8000b522 <__avr32_f64_cmp_eq>
800094c4:	f7 b6 00 01 	subeq	r6,1
800094c8:	59 66       	cp.w	r6,22
800094ca:	e0 88 00 05 	brls	800094d4 <_dtoa_r+0x200>
800094ce:	30 18       	mov	r8,1
800094d0:	51 48       	stdsp	sp[0x50],r8
800094d2:	c1 38       	rjmp	800094f8 <_dtoa_r+0x224>
800094d4:	fe c8 c4 94 	sub	r8,pc,-15212
800094d8:	fa ea 00 3c 	ld.d	r10,sp[60]
800094dc:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800094e0:	e0 a0 10 68 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
800094e4:	f9 b4 00 00 	moveq	r4,0
800094e8:	fb f4 0a 14 	st.weq	sp[0x50],r4
800094ec:	f7 b6 01 01 	subne	r6,1
800094f0:	f9 bc 01 00 	movne	r12,0
800094f4:	fb fc 1a 14 	st.wne	sp[0x50],r12
800094f8:	41 90       	lddsp	r0,sp[0x64]
800094fa:	20 10       	sub	r0,1
800094fc:	0a 10       	sub	r0,r5
800094fe:	c0 46       	brmi	80009506 <_dtoa_r+0x232>
80009500:	50 40       	stdsp	sp[0x10],r0
80009502:	30 00       	mov	r0,0
80009504:	c0 48       	rjmp	8000950c <_dtoa_r+0x238>
80009506:	30 0b       	mov	r11,0
80009508:	5c 30       	neg	r0
8000950a:	50 4b       	stdsp	sp[0x10],r11
8000950c:	ec 02 11 00 	rsub	r2,r6,0
80009510:	58 06       	cp.w	r6,0
80009512:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009516:	f5 d6 e4 0a 	addge	r10,r10,r6
8000951a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000951e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009522:	f9 b2 04 00 	movge	r2,0
80009526:	e1 d6 e5 10 	sublt	r0,r0,r6
8000952a:	f9 b9 05 00 	movlt	r9,0
8000952e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009532:	40 c8       	lddsp	r8,sp[0x30]
80009534:	58 98       	cp.w	r8,9
80009536:	e0 8b 00 20 	brhi	80009576 <_dtoa_r+0x2a2>
8000953a:	58 58       	cp.w	r8,5
8000953c:	f9 b4 0a 01 	movle	r4,1
80009540:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009544:	f7 b5 09 04 	subgt	r5,4
80009548:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000954c:	f9 b4 09 00 	movgt	r4,0
80009550:	40 cc       	lddsp	r12,sp[0x30]
80009552:	58 3c       	cp.w	r12,3
80009554:	c2 d0       	breq	800095ae <_dtoa_r+0x2da>
80009556:	e0 89 00 05 	brgt	80009560 <_dtoa_r+0x28c>
8000955a:	58 2c       	cp.w	r12,2
8000955c:	c1 01       	brne	8000957c <_dtoa_r+0x2a8>
8000955e:	c1 88       	rjmp	8000958e <_dtoa_r+0x2ba>
80009560:	40 cb       	lddsp	r11,sp[0x30]
80009562:	58 4b       	cp.w	r11,4
80009564:	c0 60       	breq	80009570 <_dtoa_r+0x29c>
80009566:	58 5b       	cp.w	r11,5
80009568:	c0 a1       	brne	8000957c <_dtoa_r+0x2a8>
8000956a:	30 1a       	mov	r10,1
8000956c:	50 da       	stdsp	sp[0x34],r10
8000956e:	c2 28       	rjmp	800095b2 <_dtoa_r+0x2de>
80009570:	30 19       	mov	r9,1
80009572:	50 d9       	stdsp	sp[0x34],r9
80009574:	c0 f8       	rjmp	80009592 <_dtoa_r+0x2be>
80009576:	30 08       	mov	r8,0
80009578:	30 14       	mov	r4,1
8000957a:	50 c8       	stdsp	sp[0x30],r8
8000957c:	3f f5       	mov	r5,-1
8000957e:	30 1c       	mov	r12,1
80009580:	30 0b       	mov	r11,0
80009582:	50 95       	stdsp	sp[0x24],r5
80009584:	50 dc       	stdsp	sp[0x34],r12
80009586:	0a 91       	mov	r1,r5
80009588:	31 28       	mov	r8,18
8000958a:	50 eb       	stdsp	sp[0x38],r11
8000958c:	c2 08       	rjmp	800095cc <_dtoa_r+0x2f8>
8000958e:	30 0a       	mov	r10,0
80009590:	50 da       	stdsp	sp[0x34],r10
80009592:	40 e9       	lddsp	r9,sp[0x38]
80009594:	58 09       	cp.w	r9,0
80009596:	e0 89 00 07 	brgt	800095a4 <_dtoa_r+0x2d0>
8000959a:	30 18       	mov	r8,1
8000959c:	50 98       	stdsp	sp[0x24],r8
8000959e:	10 91       	mov	r1,r8
800095a0:	50 e8       	stdsp	sp[0x38],r8
800095a2:	c1 58       	rjmp	800095cc <_dtoa_r+0x2f8>
800095a4:	40 e5       	lddsp	r5,sp[0x38]
800095a6:	50 95       	stdsp	sp[0x24],r5
800095a8:	0a 91       	mov	r1,r5
800095aa:	0a 98       	mov	r8,r5
800095ac:	c1 08       	rjmp	800095cc <_dtoa_r+0x2f8>
800095ae:	30 0c       	mov	r12,0
800095b0:	50 dc       	stdsp	sp[0x34],r12
800095b2:	40 eb       	lddsp	r11,sp[0x38]
800095b4:	ec 0b 00 0b 	add	r11,r6,r11
800095b8:	50 9b       	stdsp	sp[0x24],r11
800095ba:	16 98       	mov	r8,r11
800095bc:	2f f8       	sub	r8,-1
800095be:	58 08       	cp.w	r8,0
800095c0:	e0 89 00 05 	brgt	800095ca <_dtoa_r+0x2f6>
800095c4:	10 91       	mov	r1,r8
800095c6:	30 18       	mov	r8,1
800095c8:	c0 28       	rjmp	800095cc <_dtoa_r+0x2f8>
800095ca:	10 91       	mov	r1,r8
800095cc:	30 09       	mov	r9,0
800095ce:	6e 9a       	ld.w	r10,r7[0x24]
800095d0:	95 19       	st.w	r10[0x4],r9
800095d2:	30 49       	mov	r9,4
800095d4:	c0 68       	rjmp	800095e0 <_dtoa_r+0x30c>
800095d6:	d7 03       	nop
800095d8:	6a 1a       	ld.w	r10,r5[0x4]
800095da:	a1 79       	lsl	r9,0x1
800095dc:	2f fa       	sub	r10,-1
800095de:	8b 1a       	st.w	r5[0x4],r10
800095e0:	6e 95       	ld.w	r5,r7[0x24]
800095e2:	f2 ca ff ec 	sub	r10,r9,-20
800095e6:	10 3a       	cp.w	r10,r8
800095e8:	fe 98 ff f8 	brls	800095d8 <_dtoa_r+0x304>
800095ec:	6a 1b       	ld.w	r11,r5[0x4]
800095ee:	0e 9c       	mov	r12,r7
800095f0:	e0 a0 09 44 	rcall	8000a878 <_Balloc>
800095f4:	58 e1       	cp.w	r1,14
800095f6:	5f 88       	srls	r8
800095f8:	8b 0c       	st.w	r5[0x0],r12
800095fa:	f1 e4 00 04 	and	r4,r8,r4
800095fe:	6e 98       	ld.w	r8,r7[0x24]
80009600:	70 08       	ld.w	r8,r8[0x0]
80009602:	50 88       	stdsp	sp[0x20],r8
80009604:	e0 80 01 82 	breq	80009908 <_dtoa_r+0x634>
80009608:	58 06       	cp.w	r6,0
8000960a:	e0 8a 00 43 	brle	80009690 <_dtoa_r+0x3bc>
8000960e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009612:	fe c8 c5 d2 	sub	r8,pc,-14894
80009616:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000961a:	fa e5 00 18 	st.d	sp[24],r4
8000961e:	ec 04 14 04 	asr	r4,r6,0x4
80009622:	ed b4 00 04 	bld	r4,0x4
80009626:	c0 30       	breq	8000962c <_dtoa_r+0x358>
80009628:	30 25       	mov	r5,2
8000962a:	c1 08       	rjmp	8000964a <_dtoa_r+0x376>
8000962c:	fe c8 c5 24 	sub	r8,pc,-15068
80009630:	f0 e8 00 20 	ld.d	r8,r8[32]
80009634:	fa ea 00 3c 	ld.d	r10,sp[60]
80009638:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000963c:	e0 a0 0f ee 	rcall	8000b618 <__avr32_f64_div>
80009640:	30 35       	mov	r5,3
80009642:	14 98       	mov	r8,r10
80009644:	16 99       	mov	r9,r11
80009646:	fa e9 00 08 	st.d	sp[8],r8
8000964a:	fe cc c5 42 	sub	r12,pc,-15038
8000964e:	50 a3       	stdsp	sp[0x28],r3
80009650:	0c 93       	mov	r3,r6
80009652:	18 96       	mov	r6,r12
80009654:	c0 f8       	rjmp	80009672 <_dtoa_r+0x39e>
80009656:	fa ea 00 18 	ld.d	r10,sp[24]
8000965a:	ed b4 00 00 	bld	r4,0x0
8000965e:	c0 81       	brne	8000966e <_dtoa_r+0x39a>
80009660:	ec e8 00 00 	ld.d	r8,r6[0]
80009664:	2f f5       	sub	r5,-1
80009666:	e0 a0 0c 93 	rcall	8000af8c <__avr32_f64_mul>
8000966a:	fa eb 00 18 	st.d	sp[24],r10
8000966e:	a1 54       	asr	r4,0x1
80009670:	2f 86       	sub	r6,-8
80009672:	58 04       	cp.w	r4,0
80009674:	cf 11       	brne	80009656 <_dtoa_r+0x382>
80009676:	fa e8 00 18 	ld.d	r8,sp[24]
8000967a:	fa ea 00 08 	ld.d	r10,sp[8]
8000967e:	06 96       	mov	r6,r3
80009680:	e0 a0 0f cc 	rcall	8000b618 <__avr32_f64_div>
80009684:	40 a3       	lddsp	r3,sp[0x28]
80009686:	14 98       	mov	r8,r10
80009688:	16 99       	mov	r9,r11
8000968a:	fa e9 00 08 	st.d	sp[8],r8
8000968e:	c2 f8       	rjmp	800096ec <_dtoa_r+0x418>
80009690:	ec 08 11 00 	rsub	r8,r6,0
80009694:	c0 31       	brne	8000969a <_dtoa_r+0x3c6>
80009696:	30 25       	mov	r5,2
80009698:	c2 a8       	rjmp	800096ec <_dtoa_r+0x418>
8000969a:	fe cc c5 92 	sub	r12,pc,-14958
8000969e:	f0 04 14 04 	asr	r4,r8,0x4
800096a2:	50 1c       	stdsp	sp[0x4],r12
800096a4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800096a8:	fe c9 c6 68 	sub	r9,pc,-14744
800096ac:	fa ea 00 3c 	ld.d	r10,sp[60]
800096b0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800096b4:	e0 a0 0c 6c 	rcall	8000af8c <__avr32_f64_mul>
800096b8:	40 1c       	lddsp	r12,sp[0x4]
800096ba:	50 63       	stdsp	sp[0x18],r3
800096bc:	30 25       	mov	r5,2
800096be:	0c 93       	mov	r3,r6
800096c0:	fa eb 00 08 	st.d	sp[8],r10
800096c4:	18 96       	mov	r6,r12
800096c6:	c0 f8       	rjmp	800096e4 <_dtoa_r+0x410>
800096c8:	fa ea 00 08 	ld.d	r10,sp[8]
800096cc:	ed b4 00 00 	bld	r4,0x0
800096d0:	c0 81       	brne	800096e0 <_dtoa_r+0x40c>
800096d2:	ec e8 00 00 	ld.d	r8,r6[0]
800096d6:	2f f5       	sub	r5,-1
800096d8:	e0 a0 0c 5a 	rcall	8000af8c <__avr32_f64_mul>
800096dc:	fa eb 00 08 	st.d	sp[8],r10
800096e0:	a1 54       	asr	r4,0x1
800096e2:	2f 86       	sub	r6,-8
800096e4:	58 04       	cp.w	r4,0
800096e6:	cf 11       	brne	800096c8 <_dtoa_r+0x3f4>
800096e8:	06 96       	mov	r6,r3
800096ea:	40 63       	lddsp	r3,sp[0x18]
800096ec:	41 4a       	lddsp	r10,sp[0x50]
800096ee:	58 0a       	cp.w	r10,0
800096f0:	c2 a0       	breq	80009744 <_dtoa_r+0x470>
800096f2:	fa e8 00 08 	ld.d	r8,sp[8]
800096f6:	58 01       	cp.w	r1,0
800096f8:	5f 94       	srgt	r4
800096fa:	fa e9 00 18 	st.d	sp[24],r8
800096fe:	30 08       	mov	r8,0
80009700:	fc 19 3f f0 	movh	r9,0x3ff0
80009704:	fa ea 00 18 	ld.d	r10,sp[24]
80009708:	e0 a0 0f 54 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
8000970c:	f9 bc 00 00 	moveq	r12,0
80009710:	f9 bc 01 01 	movne	r12,1
80009714:	e9 ec 00 0c 	and	r12,r4,r12
80009718:	c1 60       	breq	80009744 <_dtoa_r+0x470>
8000971a:	40 98       	lddsp	r8,sp[0x24]
8000971c:	58 08       	cp.w	r8,0
8000971e:	e0 8a 00 f1 	brle	80009900 <_dtoa_r+0x62c>
80009722:	30 08       	mov	r8,0
80009724:	fc 19 40 24 	movh	r9,0x4024
80009728:	ec c4 00 01 	sub	r4,r6,1
8000972c:	fa ea 00 18 	ld.d	r10,sp[24]
80009730:	2f f5       	sub	r5,-1
80009732:	50 64       	stdsp	sp[0x18],r4
80009734:	e0 a0 0c 2c 	rcall	8000af8c <__avr32_f64_mul>
80009738:	40 94       	lddsp	r4,sp[0x24]
8000973a:	14 98       	mov	r8,r10
8000973c:	16 99       	mov	r9,r11
8000973e:	fa e9 00 08 	st.d	sp[8],r8
80009742:	c0 38       	rjmp	80009748 <_dtoa_r+0x474>
80009744:	50 66       	stdsp	sp[0x18],r6
80009746:	02 94       	mov	r4,r1
80009748:	0a 9c       	mov	r12,r5
8000974a:	e0 a0 0e 7c 	rcall	8000b442 <__avr32_s32_to_f64>
8000974e:	fa e8 00 08 	ld.d	r8,sp[8]
80009752:	e0 a0 0c 1d 	rcall	8000af8c <__avr32_f64_mul>
80009756:	30 08       	mov	r8,0
80009758:	fc 19 40 1c 	movh	r9,0x401c
8000975c:	e0 a0 0d d2 	rcall	8000b300 <__avr32_f64_add>
80009760:	14 98       	mov	r8,r10
80009762:	16 99       	mov	r9,r11
80009764:	fa e9 00 28 	st.d	sp[40],r8
80009768:	fc 18 fc c0 	movh	r8,0xfcc0
8000976c:	40 a5       	lddsp	r5,sp[0x28]
8000976e:	10 05       	add	r5,r8
80009770:	50 a5       	stdsp	sp[0x28],r5
80009772:	58 04       	cp.w	r4,0
80009774:	c2 11       	brne	800097b6 <_dtoa_r+0x4e2>
80009776:	fa ea 00 08 	ld.d	r10,sp[8]
8000977a:	30 08       	mov	r8,0
8000977c:	fc 19 40 14 	movh	r9,0x4014
80009780:	e0 a0 0c f2 	rcall	8000b164 <__avr32_f64_sub>
80009784:	40 bc       	lddsp	r12,sp[0x2c]
80009786:	fa eb 00 08 	st.d	sp[8],r10
8000978a:	14 98       	mov	r8,r10
8000978c:	16 99       	mov	r9,r11
8000978e:	18 9a       	mov	r10,r12
80009790:	0a 9b       	mov	r11,r5
80009792:	e0 a0 0f 0f 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
80009796:	e0 81 02 54 	brne	80009c3e <_dtoa_r+0x96a>
8000979a:	0a 98       	mov	r8,r5
8000979c:	40 b9       	lddsp	r9,sp[0x2c]
8000979e:	ee 18 80 00 	eorh	r8,0x8000
800097a2:	fa ea 00 08 	ld.d	r10,sp[8]
800097a6:	10 95       	mov	r5,r8
800097a8:	12 98       	mov	r8,r9
800097aa:	0a 99       	mov	r9,r5
800097ac:	e0 a0 0f 02 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
800097b0:	e0 81 02 3e 	brne	80009c2c <_dtoa_r+0x958>
800097b4:	ca 68       	rjmp	80009900 <_dtoa_r+0x62c>
800097b6:	fe c9 c7 76 	sub	r9,pc,-14474
800097ba:	e8 c8 00 01 	sub	r8,r4,1
800097be:	40 d5       	lddsp	r5,sp[0x34]
800097c0:	58 05       	cp.w	r5,0
800097c2:	c4 f0       	breq	80009860 <_dtoa_r+0x58c>
800097c4:	30 0c       	mov	r12,0
800097c6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800097ca:	51 3c       	stdsp	sp[0x4c],r12
800097cc:	30 0a       	mov	r10,0
800097ce:	fc 1b 3f e0 	movh	r11,0x3fe0
800097d2:	e0 a0 0f 23 	rcall	8000b618 <__avr32_f64_div>
800097d6:	fa e8 00 28 	ld.d	r8,sp[40]
800097da:	40 85       	lddsp	r5,sp[0x20]
800097dc:	e0 a0 0c c4 	rcall	8000b164 <__avr32_f64_sub>
800097e0:	fa eb 00 28 	st.d	sp[40],r10
800097e4:	fa ea 00 08 	ld.d	r10,sp[8]
800097e8:	e0 a0 0e 16 	rcall	8000b414 <__avr32_f64_to_s32>
800097ec:	51 6c       	stdsp	sp[0x58],r12
800097ee:	e0 a0 0e 2a 	rcall	8000b442 <__avr32_s32_to_f64>
800097f2:	14 98       	mov	r8,r10
800097f4:	16 99       	mov	r9,r11
800097f6:	fa ea 00 08 	ld.d	r10,sp[8]
800097fa:	e0 a0 0c b5 	rcall	8000b164 <__avr32_f64_sub>
800097fe:	fa eb 00 08 	st.d	sp[8],r10
80009802:	41 68       	lddsp	r8,sp[0x58]
80009804:	2d 08       	sub	r8,-48
80009806:	0a c8       	st.b	r5++,r8
80009808:	41 39       	lddsp	r9,sp[0x4c]
8000980a:	2f f9       	sub	r9,-1
8000980c:	51 39       	stdsp	sp[0x4c],r9
8000980e:	fa e8 00 28 	ld.d	r8,sp[40]
80009812:	e0 a0 0e cf 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
80009816:	e0 81 03 39 	brne	80009e88 <_dtoa_r+0xbb4>
8000981a:	fa e8 00 08 	ld.d	r8,sp[8]
8000981e:	30 0a       	mov	r10,0
80009820:	fc 1b 3f f0 	movh	r11,0x3ff0
80009824:	e0 a0 0c a0 	rcall	8000b164 <__avr32_f64_sub>
80009828:	fa e8 00 28 	ld.d	r8,sp[40]
8000982c:	e0 a0 0e c2 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
80009830:	fa ea 00 28 	ld.d	r10,sp[40]
80009834:	30 08       	mov	r8,0
80009836:	fc 19 40 24 	movh	r9,0x4024
8000983a:	e0 81 00 da 	brne	800099ee <_dtoa_r+0x71a>
8000983e:	41 3c       	lddsp	r12,sp[0x4c]
80009840:	08 3c       	cp.w	r12,r4
80009842:	c5 f4       	brge	80009900 <_dtoa_r+0x62c>
80009844:	e0 a0 0b a4 	rcall	8000af8c <__avr32_f64_mul>
80009848:	30 08       	mov	r8,0
8000984a:	fa eb 00 28 	st.d	sp[40],r10
8000984e:	fc 19 40 24 	movh	r9,0x4024
80009852:	fa ea 00 08 	ld.d	r10,sp[8]
80009856:	e0 a0 0b 9b 	rcall	8000af8c <__avr32_f64_mul>
8000985a:	fa eb 00 08 	st.d	sp[8],r10
8000985e:	cc 3b       	rjmp	800097e4 <_dtoa_r+0x510>
80009860:	40 85       	lddsp	r5,sp[0x20]
80009862:	08 05       	add	r5,r4
80009864:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009868:	51 35       	stdsp	sp[0x4c],r5
8000986a:	fa e8 00 28 	ld.d	r8,sp[40]
8000986e:	40 85       	lddsp	r5,sp[0x20]
80009870:	e0 a0 0b 8e 	rcall	8000af8c <__avr32_f64_mul>
80009874:	fa eb 00 28 	st.d	sp[40],r10
80009878:	fa ea 00 08 	ld.d	r10,sp[8]
8000987c:	e0 a0 0d cc 	rcall	8000b414 <__avr32_f64_to_s32>
80009880:	51 6c       	stdsp	sp[0x58],r12
80009882:	e0 a0 0d e0 	rcall	8000b442 <__avr32_s32_to_f64>
80009886:	14 98       	mov	r8,r10
80009888:	16 99       	mov	r9,r11
8000988a:	fa ea 00 08 	ld.d	r10,sp[8]
8000988e:	e0 a0 0c 6b 	rcall	8000b164 <__avr32_f64_sub>
80009892:	fa eb 00 08 	st.d	sp[8],r10
80009896:	41 68       	lddsp	r8,sp[0x58]
80009898:	2d 08       	sub	r8,-48
8000989a:	0a c8       	st.b	r5++,r8
8000989c:	41 3c       	lddsp	r12,sp[0x4c]
8000989e:	18 35       	cp.w	r5,r12
800098a0:	c2 81       	brne	800098f0 <_dtoa_r+0x61c>
800098a2:	30 08       	mov	r8,0
800098a4:	fc 19 3f e0 	movh	r9,0x3fe0
800098a8:	fa ea 00 28 	ld.d	r10,sp[40]
800098ac:	e0 a0 0d 2a 	rcall	8000b300 <__avr32_f64_add>
800098b0:	40 85       	lddsp	r5,sp[0x20]
800098b2:	fa e8 00 08 	ld.d	r8,sp[8]
800098b6:	08 05       	add	r5,r4
800098b8:	e0 a0 0e 7c 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
800098bc:	e0 81 00 99 	brne	800099ee <_dtoa_r+0x71a>
800098c0:	fa e8 00 28 	ld.d	r8,sp[40]
800098c4:	30 0a       	mov	r10,0
800098c6:	fc 1b 3f e0 	movh	r11,0x3fe0
800098ca:	e0 a0 0c 4d 	rcall	8000b164 <__avr32_f64_sub>
800098ce:	14 98       	mov	r8,r10
800098d0:	16 99       	mov	r9,r11
800098d2:	fa ea 00 08 	ld.d	r10,sp[8]
800098d6:	e0 a0 0e 6d 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
800098da:	c1 30       	breq	80009900 <_dtoa_r+0x62c>
800098dc:	33 09       	mov	r9,48
800098de:	0a 98       	mov	r8,r5
800098e0:	11 7a       	ld.ub	r10,--r8
800098e2:	f2 0a 18 00 	cp.b	r10,r9
800098e6:	e0 81 02 d1 	brne	80009e88 <_dtoa_r+0xbb4>
800098ea:	10 95       	mov	r5,r8
800098ec:	cf 9b       	rjmp	800098de <_dtoa_r+0x60a>
800098ee:	d7 03       	nop
800098f0:	30 08       	mov	r8,0
800098f2:	fc 19 40 24 	movh	r9,0x4024
800098f6:	e0 a0 0b 4b 	rcall	8000af8c <__avr32_f64_mul>
800098fa:	fa eb 00 08 	st.d	sp[8],r10
800098fe:	cb db       	rjmp	80009878 <_dtoa_r+0x5a4>
80009900:	fa ea 00 3c 	ld.d	r10,sp[60]
80009904:	fa eb 00 08 	st.d	sp[8],r10
80009908:	58 e6       	cp.w	r6,14
8000990a:	5f ab       	srle	r11
8000990c:	41 8a       	lddsp	r10,sp[0x60]
8000990e:	30 08       	mov	r8,0
80009910:	f4 09 11 ff 	rsub	r9,r10,-1
80009914:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009918:	f0 09 18 00 	cp.b	r9,r8
8000991c:	e0 80 00 82 	breq	80009a20 <_dtoa_r+0x74c>
80009920:	40 ea       	lddsp	r10,sp[0x38]
80009922:	58 01       	cp.w	r1,0
80009924:	5f a9       	srle	r9
80009926:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000992a:	fe ca c8 ea 	sub	r10,pc,-14102
8000992e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009932:	fa e5 00 10 	st.d	sp[16],r4
80009936:	f0 09 18 00 	cp.b	r9,r8
8000993a:	c1 40       	breq	80009962 <_dtoa_r+0x68e>
8000993c:	58 01       	cp.w	r1,0
8000993e:	e0 81 01 77 	brne	80009c2c <_dtoa_r+0x958>
80009942:	30 08       	mov	r8,0
80009944:	fc 19 40 14 	movh	r9,0x4014
80009948:	08 9a       	mov	r10,r4
8000994a:	0a 9b       	mov	r11,r5
8000994c:	e0 a0 0b 20 	rcall	8000af8c <__avr32_f64_mul>
80009950:	fa e8 00 08 	ld.d	r8,sp[8]
80009954:	e0 a0 0d fa 	rcall	8000b548 <__avr32_f64_cmp_ge>
80009958:	e0 81 01 6a 	brne	80009c2c <_dtoa_r+0x958>
8000995c:	02 92       	mov	r2,r1
8000995e:	e0 8f 01 72 	bral	80009c42 <_dtoa_r+0x96e>
80009962:	40 85       	lddsp	r5,sp[0x20]
80009964:	30 14       	mov	r4,1
80009966:	fa e8 00 10 	ld.d	r8,sp[16]
8000996a:	fa ea 00 08 	ld.d	r10,sp[8]
8000996e:	e0 a0 0e 55 	rcall	8000b618 <__avr32_f64_div>
80009972:	e0 a0 0d 51 	rcall	8000b414 <__avr32_f64_to_s32>
80009976:	18 92       	mov	r2,r12
80009978:	e0 a0 0d 65 	rcall	8000b442 <__avr32_s32_to_f64>
8000997c:	fa e8 00 10 	ld.d	r8,sp[16]
80009980:	e0 a0 0b 06 	rcall	8000af8c <__avr32_f64_mul>
80009984:	14 98       	mov	r8,r10
80009986:	16 99       	mov	r9,r11
80009988:	fa ea 00 08 	ld.d	r10,sp[8]
8000998c:	e0 a0 0b ec 	rcall	8000b164 <__avr32_f64_sub>
80009990:	fa eb 00 08 	st.d	sp[8],r10
80009994:	e4 c8 ff d0 	sub	r8,r2,-48
80009998:	0a c8       	st.b	r5++,r8
8000999a:	fc 19 40 24 	movh	r9,0x4024
8000999e:	30 08       	mov	r8,0
800099a0:	02 34       	cp.w	r4,r1
800099a2:	c3 31       	brne	80009a08 <_dtoa_r+0x734>
800099a4:	fa e8 00 08 	ld.d	r8,sp[8]
800099a8:	e0 a0 0c ac 	rcall	8000b300 <__avr32_f64_add>
800099ac:	16 91       	mov	r1,r11
800099ae:	14 90       	mov	r0,r10
800099b0:	14 98       	mov	r8,r10
800099b2:	02 99       	mov	r9,r1
800099b4:	fa ea 00 10 	ld.d	r10,sp[16]
800099b8:	e0 a0 0d fc 	rcall	8000b5b0 <__avr32_f64_cmp_lt>
800099bc:	c1 a1       	brne	800099f0 <_dtoa_r+0x71c>
800099be:	fa e8 00 10 	ld.d	r8,sp[16]
800099c2:	00 9a       	mov	r10,r0
800099c4:	02 9b       	mov	r11,r1
800099c6:	e0 a0 0d ae 	rcall	8000b522 <__avr32_f64_cmp_eq>
800099ca:	e0 80 02 5e 	breq	80009e86 <_dtoa_r+0xbb2>
800099ce:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800099d2:	c0 f1       	brne	800099f0 <_dtoa_r+0x71c>
800099d4:	e0 8f 02 59 	bral	80009e86 <_dtoa_r+0xbb2>
800099d8:	40 8a       	lddsp	r10,sp[0x20]
800099da:	14 38       	cp.w	r8,r10
800099dc:	c0 30       	breq	800099e2 <_dtoa_r+0x70e>
800099de:	10 95       	mov	r5,r8
800099e0:	c0 98       	rjmp	800099f2 <_dtoa_r+0x71e>
800099e2:	33 08       	mov	r8,48
800099e4:	40 89       	lddsp	r9,sp[0x20]
800099e6:	2f f6       	sub	r6,-1
800099e8:	b2 88       	st.b	r9[0x0],r8
800099ea:	40 88       	lddsp	r8,sp[0x20]
800099ec:	c0 88       	rjmp	800099fc <_dtoa_r+0x728>
800099ee:	40 66       	lddsp	r6,sp[0x18]
800099f0:	33 99       	mov	r9,57
800099f2:	0a 98       	mov	r8,r5
800099f4:	11 7a       	ld.ub	r10,--r8
800099f6:	f2 0a 18 00 	cp.b	r10,r9
800099fa:	ce f0       	breq	800099d8 <_dtoa_r+0x704>
800099fc:	50 66       	stdsp	sp[0x18],r6
800099fe:	11 89       	ld.ub	r9,r8[0x0]
80009a00:	2f f9       	sub	r9,-1
80009a02:	b0 89       	st.b	r8[0x0],r9
80009a04:	e0 8f 02 42 	bral	80009e88 <_dtoa_r+0xbb4>
80009a08:	e0 a0 0a c2 	rcall	8000af8c <__avr32_f64_mul>
80009a0c:	2f f4       	sub	r4,-1
80009a0e:	fa eb 00 08 	st.d	sp[8],r10
80009a12:	30 08       	mov	r8,0
80009a14:	30 09       	mov	r9,0
80009a16:	e0 a0 0d 86 	rcall	8000b522 <__avr32_f64_cmp_eq>
80009a1a:	ca 60       	breq	80009966 <_dtoa_r+0x692>
80009a1c:	e0 8f 02 35 	bral	80009e86 <_dtoa_r+0xbb2>
80009a20:	40 d8       	lddsp	r8,sp[0x34]
80009a22:	58 08       	cp.w	r8,0
80009a24:	c0 51       	brne	80009a2e <_dtoa_r+0x75a>
80009a26:	04 98       	mov	r8,r2
80009a28:	00 95       	mov	r5,r0
80009a2a:	40 d4       	lddsp	r4,sp[0x34]
80009a2c:	c3 78       	rjmp	80009a9a <_dtoa_r+0x7c6>
80009a2e:	40 c5       	lddsp	r5,sp[0x30]
80009a30:	58 15       	cp.w	r5,1
80009a32:	e0 89 00 0f 	brgt	80009a50 <_dtoa_r+0x77c>
80009a36:	41 74       	lddsp	r4,sp[0x5c]
80009a38:	58 04       	cp.w	r4,0
80009a3a:	c0 40       	breq	80009a42 <_dtoa_r+0x76e>
80009a3c:	f4 c9 fb cd 	sub	r9,r10,-1075
80009a40:	c0 48       	rjmp	80009a48 <_dtoa_r+0x774>
80009a42:	41 99       	lddsp	r9,sp[0x64]
80009a44:	f2 09 11 36 	rsub	r9,r9,54
80009a48:	04 98       	mov	r8,r2
80009a4a:	00 95       	mov	r5,r0
80009a4c:	c1 c8       	rjmp	80009a84 <_dtoa_r+0x7b0>
80009a4e:	d7 03       	nop
80009a50:	e2 c8 00 01 	sub	r8,r1,1
80009a54:	58 01       	cp.w	r1,0
80009a56:	e0 05 17 40 	movge	r5,r0
80009a5a:	e2 09 17 40 	movge	r9,r1
80009a5e:	e1 d1 e5 15 	sublt	r5,r0,r1
80009a62:	f9 b9 05 00 	movlt	r9,0
80009a66:	10 32       	cp.w	r2,r8
80009a68:	e5 d8 e4 18 	subge	r8,r2,r8
80009a6c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009a70:	e5 d8 e5 02 	addlt	r2,r2,r8
80009a74:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009a78:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009a7c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009a80:	f9 b8 05 00 	movlt	r8,0
80009a84:	40 4b       	lddsp	r11,sp[0x10]
80009a86:	12 0b       	add	r11,r9
80009a88:	50 08       	stdsp	sp[0x0],r8
80009a8a:	50 4b       	stdsp	sp[0x10],r11
80009a8c:	12 00       	add	r0,r9
80009a8e:	30 1b       	mov	r11,1
80009a90:	0e 9c       	mov	r12,r7
80009a92:	e0 a0 08 a7 	rcall	8000abe0 <__i2b>
80009a96:	40 08       	lddsp	r8,sp[0x0]
80009a98:	18 94       	mov	r4,r12
80009a9a:	40 4a       	lddsp	r10,sp[0x10]
80009a9c:	58 05       	cp.w	r5,0
80009a9e:	5f 99       	srgt	r9
80009aa0:	58 0a       	cp.w	r10,0
80009aa2:	5f 9a       	srgt	r10
80009aa4:	f5 e9 00 09 	and	r9,r10,r9
80009aa8:	c0 80       	breq	80009ab8 <_dtoa_r+0x7e4>
80009aaa:	40 4c       	lddsp	r12,sp[0x10]
80009aac:	f8 05 0d 49 	min	r9,r12,r5
80009ab0:	12 1c       	sub	r12,r9
80009ab2:	12 10       	sub	r0,r9
80009ab4:	50 4c       	stdsp	sp[0x10],r12
80009ab6:	12 15       	sub	r5,r9
80009ab8:	58 02       	cp.w	r2,0
80009aba:	e0 8a 00 27 	brle	80009b08 <_dtoa_r+0x834>
80009abe:	40 db       	lddsp	r11,sp[0x34]
80009ac0:	58 0b       	cp.w	r11,0
80009ac2:	c1 d0       	breq	80009afc <_dtoa_r+0x828>
80009ac4:	58 08       	cp.w	r8,0
80009ac6:	e0 8a 00 17 	brle	80009af4 <_dtoa_r+0x820>
80009aca:	10 9a       	mov	r10,r8
80009acc:	50 08       	stdsp	sp[0x0],r8
80009ace:	08 9b       	mov	r11,r4
80009ad0:	0e 9c       	mov	r12,r7
80009ad2:	e0 a0 08 cd 	rcall	8000ac6c <__pow5mult>
80009ad6:	06 9a       	mov	r10,r3
80009ad8:	18 9b       	mov	r11,r12
80009ada:	18 94       	mov	r4,r12
80009adc:	0e 9c       	mov	r12,r7
80009ade:	e0 a0 08 01 	rcall	8000aae0 <__multiply>
80009ae2:	18 99       	mov	r9,r12
80009ae4:	06 9b       	mov	r11,r3
80009ae6:	50 19       	stdsp	sp[0x4],r9
80009ae8:	0e 9c       	mov	r12,r7
80009aea:	e0 a0 06 ad 	rcall	8000a844 <_Bfree>
80009aee:	40 19       	lddsp	r9,sp[0x4]
80009af0:	40 08       	lddsp	r8,sp[0x0]
80009af2:	12 93       	mov	r3,r9
80009af4:	e4 08 01 0a 	sub	r10,r2,r8
80009af8:	c0 80       	breq	80009b08 <_dtoa_r+0x834>
80009afa:	c0 28       	rjmp	80009afe <_dtoa_r+0x82a>
80009afc:	04 9a       	mov	r10,r2
80009afe:	06 9b       	mov	r11,r3
80009b00:	0e 9c       	mov	r12,r7
80009b02:	e0 a0 08 b5 	rcall	8000ac6c <__pow5mult>
80009b06:	18 93       	mov	r3,r12
80009b08:	30 1b       	mov	r11,1
80009b0a:	0e 9c       	mov	r12,r7
80009b0c:	e0 a0 08 6a 	rcall	8000abe0 <__i2b>
80009b10:	41 1a       	lddsp	r10,sp[0x44]
80009b12:	18 92       	mov	r2,r12
80009b14:	58 0a       	cp.w	r10,0
80009b16:	e0 8a 00 07 	brle	80009b24 <_dtoa_r+0x850>
80009b1a:	18 9b       	mov	r11,r12
80009b1c:	0e 9c       	mov	r12,r7
80009b1e:	e0 a0 08 a7 	rcall	8000ac6c <__pow5mult>
80009b22:	18 92       	mov	r2,r12
80009b24:	40 c9       	lddsp	r9,sp[0x30]
80009b26:	58 19       	cp.w	r9,1
80009b28:	e0 89 00 14 	brgt	80009b50 <_dtoa_r+0x87c>
80009b2c:	40 38       	lddsp	r8,sp[0xc]
80009b2e:	58 08       	cp.w	r8,0
80009b30:	c1 01       	brne	80009b50 <_dtoa_r+0x87c>
80009b32:	40 29       	lddsp	r9,sp[0x8]
80009b34:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009b38:	c0 c1       	brne	80009b50 <_dtoa_r+0x87c>
80009b3a:	12 98       	mov	r8,r9
80009b3c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009b40:	c0 80       	breq	80009b50 <_dtoa_r+0x87c>
80009b42:	40 4c       	lddsp	r12,sp[0x10]
80009b44:	30 1b       	mov	r11,1
80009b46:	2f fc       	sub	r12,-1
80009b48:	2f f0       	sub	r0,-1
80009b4a:	50 4c       	stdsp	sp[0x10],r12
80009b4c:	50 6b       	stdsp	sp[0x18],r11
80009b4e:	c0 38       	rjmp	80009b54 <_dtoa_r+0x880>
80009b50:	30 0a       	mov	r10,0
80009b52:	50 6a       	stdsp	sp[0x18],r10
80009b54:	41 19       	lddsp	r9,sp[0x44]
80009b56:	58 09       	cp.w	r9,0
80009b58:	c0 31       	brne	80009b5e <_dtoa_r+0x88a>
80009b5a:	30 1c       	mov	r12,1
80009b5c:	c0 98       	rjmp	80009b6e <_dtoa_r+0x89a>
80009b5e:	64 48       	ld.w	r8,r2[0x10]
80009b60:	2f c8       	sub	r8,-4
80009b62:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009b66:	e0 a0 05 df 	rcall	8000a724 <__hi0bits>
80009b6a:	f8 0c 11 20 	rsub	r12,r12,32
80009b6e:	40 4b       	lddsp	r11,sp[0x10]
80009b70:	f8 0b 00 08 	add	r8,r12,r11
80009b74:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009b78:	c0 c0       	breq	80009b90 <_dtoa_r+0x8bc>
80009b7a:	f0 08 11 20 	rsub	r8,r8,32
80009b7e:	58 48       	cp.w	r8,4
80009b80:	e0 8a 00 06 	brle	80009b8c <_dtoa_r+0x8b8>
80009b84:	20 48       	sub	r8,4
80009b86:	10 0b       	add	r11,r8
80009b88:	50 4b       	stdsp	sp[0x10],r11
80009b8a:	c0 78       	rjmp	80009b98 <_dtoa_r+0x8c4>
80009b8c:	58 48       	cp.w	r8,4
80009b8e:	c0 70       	breq	80009b9c <_dtoa_r+0x8c8>
80009b90:	40 4a       	lddsp	r10,sp[0x10]
80009b92:	2e 48       	sub	r8,-28
80009b94:	10 0a       	add	r10,r8
80009b96:	50 4a       	stdsp	sp[0x10],r10
80009b98:	10 00       	add	r0,r8
80009b9a:	10 05       	add	r5,r8
80009b9c:	58 00       	cp.w	r0,0
80009b9e:	e0 8a 00 08 	brle	80009bae <_dtoa_r+0x8da>
80009ba2:	06 9b       	mov	r11,r3
80009ba4:	00 9a       	mov	r10,r0
80009ba6:	0e 9c       	mov	r12,r7
80009ba8:	e0 a0 07 58 	rcall	8000aa58 <__lshift>
80009bac:	18 93       	mov	r3,r12
80009bae:	40 49       	lddsp	r9,sp[0x10]
80009bb0:	58 09       	cp.w	r9,0
80009bb2:	e0 8a 00 08 	brle	80009bc2 <_dtoa_r+0x8ee>
80009bb6:	04 9b       	mov	r11,r2
80009bb8:	12 9a       	mov	r10,r9
80009bba:	0e 9c       	mov	r12,r7
80009bbc:	e0 a0 07 4e 	rcall	8000aa58 <__lshift>
80009bc0:	18 92       	mov	r2,r12
80009bc2:	41 48       	lddsp	r8,sp[0x50]
80009bc4:	58 08       	cp.w	r8,0
80009bc6:	c1 b0       	breq	80009bfc <_dtoa_r+0x928>
80009bc8:	04 9b       	mov	r11,r2
80009bca:	06 9c       	mov	r12,r3
80009bcc:	e0 a0 06 23 	rcall	8000a812 <__mcmp>
80009bd0:	c1 64       	brge	80009bfc <_dtoa_r+0x928>
80009bd2:	06 9b       	mov	r11,r3
80009bd4:	30 09       	mov	r9,0
80009bd6:	30 aa       	mov	r10,10
80009bd8:	0e 9c       	mov	r12,r7
80009bda:	e0 a0 08 0b 	rcall	8000abf0 <__multadd>
80009bde:	20 16       	sub	r6,1
80009be0:	18 93       	mov	r3,r12
80009be2:	40 dc       	lddsp	r12,sp[0x34]
80009be4:	58 0c       	cp.w	r12,0
80009be6:	c0 31       	brne	80009bec <_dtoa_r+0x918>
80009be8:	40 91       	lddsp	r1,sp[0x24]
80009bea:	c0 98       	rjmp	80009bfc <_dtoa_r+0x928>
80009bec:	08 9b       	mov	r11,r4
80009bee:	40 91       	lddsp	r1,sp[0x24]
80009bf0:	30 09       	mov	r9,0
80009bf2:	30 aa       	mov	r10,10
80009bf4:	0e 9c       	mov	r12,r7
80009bf6:	e0 a0 07 fd 	rcall	8000abf0 <__multadd>
80009bfa:	18 94       	mov	r4,r12
80009bfc:	58 01       	cp.w	r1,0
80009bfe:	5f a9       	srle	r9
80009c00:	40 cb       	lddsp	r11,sp[0x30]
80009c02:	58 2b       	cp.w	r11,2
80009c04:	5f 98       	srgt	r8
80009c06:	f3 e8 00 08 	and	r8,r9,r8
80009c0a:	c2 50       	breq	80009c54 <_dtoa_r+0x980>
80009c0c:	58 01       	cp.w	r1,0
80009c0e:	c1 11       	brne	80009c30 <_dtoa_r+0x95c>
80009c10:	04 9b       	mov	r11,r2
80009c12:	02 99       	mov	r9,r1
80009c14:	30 5a       	mov	r10,5
80009c16:	0e 9c       	mov	r12,r7
80009c18:	e0 a0 07 ec 	rcall	8000abf0 <__multadd>
80009c1c:	18 92       	mov	r2,r12
80009c1e:	18 9b       	mov	r11,r12
80009c20:	06 9c       	mov	r12,r3
80009c22:	e0 a0 05 f8 	rcall	8000a812 <__mcmp>
80009c26:	e0 89 00 0f 	brgt	80009c44 <_dtoa_r+0x970>
80009c2a:	c0 38       	rjmp	80009c30 <_dtoa_r+0x95c>
80009c2c:	30 02       	mov	r2,0
80009c2e:	04 94       	mov	r4,r2
80009c30:	40 ea       	lddsp	r10,sp[0x38]
80009c32:	30 09       	mov	r9,0
80009c34:	5c da       	com	r10
80009c36:	40 85       	lddsp	r5,sp[0x20]
80009c38:	50 6a       	stdsp	sp[0x18],r10
80009c3a:	50 49       	stdsp	sp[0x10],r9
80009c3c:	c0 f9       	rjmp	80009e5a <_dtoa_r+0xb86>
80009c3e:	08 92       	mov	r2,r4
80009c40:	40 66       	lddsp	r6,sp[0x18]
80009c42:	04 94       	mov	r4,r2
80009c44:	2f f6       	sub	r6,-1
80009c46:	50 66       	stdsp	sp[0x18],r6
80009c48:	33 18       	mov	r8,49
80009c4a:	40 85       	lddsp	r5,sp[0x20]
80009c4c:	0a c8       	st.b	r5++,r8
80009c4e:	30 08       	mov	r8,0
80009c50:	50 48       	stdsp	sp[0x10],r8
80009c52:	c0 49       	rjmp	80009e5a <_dtoa_r+0xb86>
80009c54:	40 dc       	lddsp	r12,sp[0x34]
80009c56:	58 0c       	cp.w	r12,0
80009c58:	e0 80 00 b5 	breq	80009dc2 <_dtoa_r+0xaee>
80009c5c:	58 05       	cp.w	r5,0
80009c5e:	e0 8a 00 08 	brle	80009c6e <_dtoa_r+0x99a>
80009c62:	08 9b       	mov	r11,r4
80009c64:	0a 9a       	mov	r10,r5
80009c66:	0e 9c       	mov	r12,r7
80009c68:	e0 a0 06 f8 	rcall	8000aa58 <__lshift>
80009c6c:	18 94       	mov	r4,r12
80009c6e:	40 6b       	lddsp	r11,sp[0x18]
80009c70:	58 0b       	cp.w	r11,0
80009c72:	c0 31       	brne	80009c78 <_dtoa_r+0x9a4>
80009c74:	08 9c       	mov	r12,r4
80009c76:	c1 38       	rjmp	80009c9c <_dtoa_r+0x9c8>
80009c78:	68 1b       	ld.w	r11,r4[0x4]
80009c7a:	0e 9c       	mov	r12,r7
80009c7c:	e0 a0 05 fe 	rcall	8000a878 <_Balloc>
80009c80:	68 4a       	ld.w	r10,r4[0x10]
80009c82:	18 95       	mov	r5,r12
80009c84:	e8 cb ff f4 	sub	r11,r4,-12
80009c88:	2f ea       	sub	r10,-2
80009c8a:	2f 4c       	sub	r12,-12
80009c8c:	a3 6a       	lsl	r10,0x2
80009c8e:	fe b0 e6 43 	rcall	80006914 <memcpy>
80009c92:	0a 9b       	mov	r11,r5
80009c94:	30 1a       	mov	r10,1
80009c96:	0e 9c       	mov	r12,r7
80009c98:	e0 a0 06 e0 	rcall	8000aa58 <__lshift>
80009c9c:	50 44       	stdsp	sp[0x10],r4
80009c9e:	40 3a       	lddsp	r10,sp[0xc]
80009ca0:	30 19       	mov	r9,1
80009ca2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009ca6:	18 94       	mov	r4,r12
80009ca8:	50 da       	stdsp	sp[0x34],r10
80009caa:	40 85       	lddsp	r5,sp[0x20]
80009cac:	50 99       	stdsp	sp[0x24],r9
80009cae:	50 26       	stdsp	sp[0x8],r6
80009cb0:	50 e1       	stdsp	sp[0x38],r1
80009cb2:	04 9b       	mov	r11,r2
80009cb4:	06 9c       	mov	r12,r3
80009cb6:	fe b0 fa 7f 	rcall	800091b4 <quorem>
80009cba:	40 4b       	lddsp	r11,sp[0x10]
80009cbc:	f8 c0 ff d0 	sub	r0,r12,-48
80009cc0:	06 9c       	mov	r12,r3
80009cc2:	e0 a0 05 a8 	rcall	8000a812 <__mcmp>
80009cc6:	08 9a       	mov	r10,r4
80009cc8:	50 6c       	stdsp	sp[0x18],r12
80009cca:	04 9b       	mov	r11,r2
80009ccc:	0e 9c       	mov	r12,r7
80009cce:	e0 a0 06 5d 	rcall	8000a988 <__mdiff>
80009cd2:	18 91       	mov	r1,r12
80009cd4:	78 38       	ld.w	r8,r12[0xc]
80009cd6:	58 08       	cp.w	r8,0
80009cd8:	c0 30       	breq	80009cde <_dtoa_r+0xa0a>
80009cda:	30 16       	mov	r6,1
80009cdc:	c0 68       	rjmp	80009ce8 <_dtoa_r+0xa14>
80009cde:	18 9b       	mov	r11,r12
80009ce0:	06 9c       	mov	r12,r3
80009ce2:	e0 a0 05 98 	rcall	8000a812 <__mcmp>
80009ce6:	18 96       	mov	r6,r12
80009ce8:	0e 9c       	mov	r12,r7
80009cea:	02 9b       	mov	r11,r1
80009cec:	e0 a0 05 ac 	rcall	8000a844 <_Bfree>
80009cf0:	40 cc       	lddsp	r12,sp[0x30]
80009cf2:	ed ec 10 08 	or	r8,r6,r12
80009cf6:	c0 d1       	brne	80009d10 <_dtoa_r+0xa3c>
80009cf8:	40 db       	lddsp	r11,sp[0x34]
80009cfa:	58 0b       	cp.w	r11,0
80009cfc:	c0 a1       	brne	80009d10 <_dtoa_r+0xa3c>
80009cfe:	40 26       	lddsp	r6,sp[0x8]
80009d00:	e0 40 00 39 	cp.w	r0,57
80009d04:	c3 00       	breq	80009d64 <_dtoa_r+0xa90>
80009d06:	40 6a       	lddsp	r10,sp[0x18]
80009d08:	58 0a       	cp.w	r10,0
80009d0a:	e0 89 00 24 	brgt	80009d52 <_dtoa_r+0xa7e>
80009d0e:	c2 f8       	rjmp	80009d6c <_dtoa_r+0xa98>
80009d10:	40 69       	lddsp	r9,sp[0x18]
80009d12:	58 09       	cp.w	r9,0
80009d14:	c0 85       	brlt	80009d24 <_dtoa_r+0xa50>
80009d16:	12 98       	mov	r8,r9
80009d18:	40 cc       	lddsp	r12,sp[0x30]
80009d1a:	18 48       	or	r8,r12
80009d1c:	c1 d1       	brne	80009d56 <_dtoa_r+0xa82>
80009d1e:	40 db       	lddsp	r11,sp[0x34]
80009d20:	58 0b       	cp.w	r11,0
80009d22:	c1 a1       	brne	80009d56 <_dtoa_r+0xa82>
80009d24:	0c 99       	mov	r9,r6
80009d26:	40 26       	lddsp	r6,sp[0x8]
80009d28:	58 09       	cp.w	r9,0
80009d2a:	e0 8a 00 21 	brle	80009d6c <_dtoa_r+0xa98>
80009d2e:	06 9b       	mov	r11,r3
80009d30:	30 1a       	mov	r10,1
80009d32:	0e 9c       	mov	r12,r7
80009d34:	e0 a0 06 92 	rcall	8000aa58 <__lshift>
80009d38:	04 9b       	mov	r11,r2
80009d3a:	18 93       	mov	r3,r12
80009d3c:	e0 a0 05 6b 	rcall	8000a812 <__mcmp>
80009d40:	e0 89 00 06 	brgt	80009d4c <_dtoa_r+0xa78>
80009d44:	c1 41       	brne	80009d6c <_dtoa_r+0xa98>
80009d46:	ed b0 00 00 	bld	r0,0x0
80009d4a:	c1 11       	brne	80009d6c <_dtoa_r+0xa98>
80009d4c:	e0 40 00 39 	cp.w	r0,57
80009d50:	c0 a0       	breq	80009d64 <_dtoa_r+0xa90>
80009d52:	2f f0       	sub	r0,-1
80009d54:	c0 c8       	rjmp	80009d6c <_dtoa_r+0xa98>
80009d56:	58 06       	cp.w	r6,0
80009d58:	e0 8a 00 0c 	brle	80009d70 <_dtoa_r+0xa9c>
80009d5c:	40 26       	lddsp	r6,sp[0x8]
80009d5e:	e0 40 00 39 	cp.w	r0,57
80009d62:	c0 41       	brne	80009d6a <_dtoa_r+0xa96>
80009d64:	33 98       	mov	r8,57
80009d66:	0a c8       	st.b	r5++,r8
80009d68:	c6 78       	rjmp	80009e36 <_dtoa_r+0xb62>
80009d6a:	2f f0       	sub	r0,-1
80009d6c:	0a c0       	st.b	r5++,r0
80009d6e:	c7 58       	rjmp	80009e58 <_dtoa_r+0xb84>
80009d70:	0a c0       	st.b	r5++,r0
80009d72:	40 9a       	lddsp	r10,sp[0x24]
80009d74:	40 e9       	lddsp	r9,sp[0x38]
80009d76:	12 3a       	cp.w	r10,r9
80009d78:	c4 30       	breq	80009dfe <_dtoa_r+0xb2a>
80009d7a:	06 9b       	mov	r11,r3
80009d7c:	30 09       	mov	r9,0
80009d7e:	30 aa       	mov	r10,10
80009d80:	0e 9c       	mov	r12,r7
80009d82:	e0 a0 07 37 	rcall	8000abf0 <__multadd>
80009d86:	40 48       	lddsp	r8,sp[0x10]
80009d88:	18 93       	mov	r3,r12
80009d8a:	08 38       	cp.w	r8,r4
80009d8c:	c0 91       	brne	80009d9e <_dtoa_r+0xaca>
80009d8e:	10 9b       	mov	r11,r8
80009d90:	30 09       	mov	r9,0
80009d92:	30 aa       	mov	r10,10
80009d94:	0e 9c       	mov	r12,r7
80009d96:	e0 a0 07 2d 	rcall	8000abf0 <__multadd>
80009d9a:	50 4c       	stdsp	sp[0x10],r12
80009d9c:	c0 e8       	rjmp	80009db8 <_dtoa_r+0xae4>
80009d9e:	40 4b       	lddsp	r11,sp[0x10]
80009da0:	30 09       	mov	r9,0
80009da2:	30 aa       	mov	r10,10
80009da4:	0e 9c       	mov	r12,r7
80009da6:	e0 a0 07 25 	rcall	8000abf0 <__multadd>
80009daa:	08 9b       	mov	r11,r4
80009dac:	50 4c       	stdsp	sp[0x10],r12
80009dae:	30 09       	mov	r9,0
80009db0:	30 aa       	mov	r10,10
80009db2:	0e 9c       	mov	r12,r7
80009db4:	e0 a0 07 1e 	rcall	8000abf0 <__multadd>
80009db8:	18 94       	mov	r4,r12
80009dba:	40 9c       	lddsp	r12,sp[0x24]
80009dbc:	2f fc       	sub	r12,-1
80009dbe:	50 9c       	stdsp	sp[0x24],r12
80009dc0:	c7 9b       	rjmp	80009cb2 <_dtoa_r+0x9de>
80009dc2:	30 18       	mov	r8,1
80009dc4:	06 90       	mov	r0,r3
80009dc6:	40 85       	lddsp	r5,sp[0x20]
80009dc8:	08 93       	mov	r3,r4
80009dca:	0c 94       	mov	r4,r6
80009dcc:	10 96       	mov	r6,r8
80009dce:	04 9b       	mov	r11,r2
80009dd0:	00 9c       	mov	r12,r0
80009dd2:	fe b0 f9 f1 	rcall	800091b4 <quorem>
80009dd6:	2d 0c       	sub	r12,-48
80009dd8:	0a cc       	st.b	r5++,r12
80009dda:	02 36       	cp.w	r6,r1
80009ddc:	c0 a4       	brge	80009df0 <_dtoa_r+0xb1c>
80009dde:	00 9b       	mov	r11,r0
80009de0:	30 09       	mov	r9,0
80009de2:	30 aa       	mov	r10,10
80009de4:	0e 9c       	mov	r12,r7
80009de6:	2f f6       	sub	r6,-1
80009de8:	e0 a0 07 04 	rcall	8000abf0 <__multadd>
80009dec:	18 90       	mov	r0,r12
80009dee:	cf 0b       	rjmp	80009dce <_dtoa_r+0xafa>
80009df0:	08 96       	mov	r6,r4
80009df2:	30 0b       	mov	r11,0
80009df4:	06 94       	mov	r4,r3
80009df6:	50 4b       	stdsp	sp[0x10],r11
80009df8:	00 93       	mov	r3,r0
80009dfa:	18 90       	mov	r0,r12
80009dfc:	c0 28       	rjmp	80009e00 <_dtoa_r+0xb2c>
80009dfe:	40 26       	lddsp	r6,sp[0x8]
80009e00:	06 9b       	mov	r11,r3
80009e02:	30 1a       	mov	r10,1
80009e04:	0e 9c       	mov	r12,r7
80009e06:	e0 a0 06 29 	rcall	8000aa58 <__lshift>
80009e0a:	04 9b       	mov	r11,r2
80009e0c:	18 93       	mov	r3,r12
80009e0e:	e0 a0 05 02 	rcall	8000a812 <__mcmp>
80009e12:	e0 89 00 12 	brgt	80009e36 <_dtoa_r+0xb62>
80009e16:	c1 b1       	brne	80009e4c <_dtoa_r+0xb78>
80009e18:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009e1c:	c0 d1       	brne	80009e36 <_dtoa_r+0xb62>
80009e1e:	c1 78       	rjmp	80009e4c <_dtoa_r+0xb78>
80009e20:	40 89       	lddsp	r9,sp[0x20]
80009e22:	12 38       	cp.w	r8,r9
80009e24:	c0 30       	breq	80009e2a <_dtoa_r+0xb56>
80009e26:	10 95       	mov	r5,r8
80009e28:	c0 88       	rjmp	80009e38 <_dtoa_r+0xb64>
80009e2a:	2f f6       	sub	r6,-1
80009e2c:	50 66       	stdsp	sp[0x18],r6
80009e2e:	33 18       	mov	r8,49
80009e30:	40 8c       	lddsp	r12,sp[0x20]
80009e32:	b8 88       	st.b	r12[0x0],r8
80009e34:	c1 38       	rjmp	80009e5a <_dtoa_r+0xb86>
80009e36:	33 9a       	mov	r10,57
80009e38:	0a 98       	mov	r8,r5
80009e3a:	11 79       	ld.ub	r9,--r8
80009e3c:	f4 09 18 00 	cp.b	r9,r10
80009e40:	cf 00       	breq	80009e20 <_dtoa_r+0xb4c>
80009e42:	2f f9       	sub	r9,-1
80009e44:	b0 89       	st.b	r8[0x0],r9
80009e46:	c0 98       	rjmp	80009e58 <_dtoa_r+0xb84>
80009e48:	10 95       	mov	r5,r8
80009e4a:	c0 28       	rjmp	80009e4e <_dtoa_r+0xb7a>
80009e4c:	33 09       	mov	r9,48
80009e4e:	0a 98       	mov	r8,r5
80009e50:	11 7a       	ld.ub	r10,--r8
80009e52:	f2 0a 18 00 	cp.b	r10,r9
80009e56:	cf 90       	breq	80009e48 <_dtoa_r+0xb74>
80009e58:	50 66       	stdsp	sp[0x18],r6
80009e5a:	04 9b       	mov	r11,r2
80009e5c:	0e 9c       	mov	r12,r7
80009e5e:	e0 a0 04 f3 	rcall	8000a844 <_Bfree>
80009e62:	58 04       	cp.w	r4,0
80009e64:	c1 20       	breq	80009e88 <_dtoa_r+0xbb4>
80009e66:	40 4b       	lddsp	r11,sp[0x10]
80009e68:	08 3b       	cp.w	r11,r4
80009e6a:	5f 19       	srne	r9
80009e6c:	58 0b       	cp.w	r11,0
80009e6e:	5f 18       	srne	r8
80009e70:	f3 e8 00 08 	and	r8,r9,r8
80009e74:	c0 40       	breq	80009e7c <_dtoa_r+0xba8>
80009e76:	0e 9c       	mov	r12,r7
80009e78:	e0 a0 04 e6 	rcall	8000a844 <_Bfree>
80009e7c:	08 9b       	mov	r11,r4
80009e7e:	0e 9c       	mov	r12,r7
80009e80:	e0 a0 04 e2 	rcall	8000a844 <_Bfree>
80009e84:	c0 28       	rjmp	80009e88 <_dtoa_r+0xbb4>
80009e86:	50 66       	stdsp	sp[0x18],r6
80009e88:	0e 9c       	mov	r12,r7
80009e8a:	06 9b       	mov	r11,r3
80009e8c:	e0 a0 04 dc 	rcall	8000a844 <_Bfree>
80009e90:	30 08       	mov	r8,0
80009e92:	aa 88       	st.b	r5[0x0],r8
80009e94:	40 68       	lddsp	r8,sp[0x18]
80009e96:	41 5a       	lddsp	r10,sp[0x54]
80009e98:	2f f8       	sub	r8,-1
80009e9a:	41 29       	lddsp	r9,sp[0x48]
80009e9c:	95 08       	st.w	r10[0x0],r8
80009e9e:	40 8c       	lddsp	r12,sp[0x20]
80009ea0:	58 09       	cp.w	r9,0
80009ea2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009ea6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009eaa:	2e 6d       	sub	sp,-104
80009eac:	d8 32       	popm	r0-r7,pc
80009eae:	d7 03       	nop

80009eb0 <__errno>:
80009eb0:	e0 68 0a 44 	mov	r8,2628
80009eb4:	70 0c       	ld.w	r12,r8[0x0]
80009eb6:	2f 4c       	sub	r12,-12
80009eb8:	5e fc       	retal	r12
80009eba:	d7 03       	nop

80009ebc <_fflush_r>:
80009ebc:	d4 21       	pushm	r4-r7,lr
80009ebe:	16 97       	mov	r7,r11
80009ec0:	18 96       	mov	r6,r12
80009ec2:	76 48       	ld.w	r8,r11[0x10]
80009ec4:	58 08       	cp.w	r8,0
80009ec6:	c7 f0       	breq	80009fc4 <_fflush_r+0x108>
80009ec8:	58 0c       	cp.w	r12,0
80009eca:	c0 50       	breq	80009ed4 <_fflush_r+0x18>
80009ecc:	78 68       	ld.w	r8,r12[0x18]
80009ece:	58 08       	cp.w	r8,0
80009ed0:	c0 21       	brne	80009ed4 <_fflush_r+0x18>
80009ed2:	cc dc       	rcall	8000a06c <__sinit>
80009ed4:	fe c8 cf 44 	sub	r8,pc,-12476
80009ed8:	10 37       	cp.w	r7,r8
80009eda:	c0 31       	brne	80009ee0 <_fflush_r+0x24>
80009edc:	6c 07       	ld.w	r7,r6[0x0]
80009ede:	c0 c8       	rjmp	80009ef6 <_fflush_r+0x3a>
80009ee0:	fe c8 cf 30 	sub	r8,pc,-12496
80009ee4:	10 37       	cp.w	r7,r8
80009ee6:	c0 31       	brne	80009eec <_fflush_r+0x30>
80009ee8:	6c 17       	ld.w	r7,r6[0x4]
80009eea:	c0 68       	rjmp	80009ef6 <_fflush_r+0x3a>
80009eec:	fe c8 cf 1c 	sub	r8,pc,-12516
80009ef0:	10 37       	cp.w	r7,r8
80009ef2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009ef6:	8e 6a       	ld.sh	r10,r7[0xc]
80009ef8:	14 98       	mov	r8,r10
80009efa:	ed ba 00 03 	bld	r10,0x3
80009efe:	c4 20       	breq	80009f82 <_fflush_r+0xc6>
80009f00:	ab ba       	sbr	r10,0xb
80009f02:	ae 6a       	st.h	r7[0xc],r10
80009f04:	6e 18       	ld.w	r8,r7[0x4]
80009f06:	58 08       	cp.w	r8,0
80009f08:	e0 89 00 06 	brgt	80009f14 <_fflush_r+0x58>
80009f0c:	6f 08       	ld.w	r8,r7[0x40]
80009f0e:	58 08       	cp.w	r8,0
80009f10:	e0 8a 00 5a 	brle	80009fc4 <_fflush_r+0x108>
80009f14:	6e b8       	ld.w	r8,r7[0x2c]
80009f16:	58 08       	cp.w	r8,0
80009f18:	c5 60       	breq	80009fc4 <_fflush_r+0x108>
80009f1a:	e2 1a 10 00 	andl	r10,0x1000,COH
80009f1e:	c0 30       	breq	80009f24 <_fflush_r+0x68>
80009f20:	6f 55       	ld.w	r5,r7[0x54]
80009f22:	c0 f8       	rjmp	80009f40 <_fflush_r+0x84>
80009f24:	30 19       	mov	r9,1
80009f26:	6e 8b       	ld.w	r11,r7[0x20]
80009f28:	0c 9c       	mov	r12,r6
80009f2a:	5d 18       	icall	r8
80009f2c:	18 95       	mov	r5,r12
80009f2e:	5b fc       	cp.w	r12,-1
80009f30:	c0 81       	brne	80009f40 <_fflush_r+0x84>
80009f32:	6c 38       	ld.w	r8,r6[0xc]
80009f34:	59 d8       	cp.w	r8,29
80009f36:	c4 70       	breq	80009fc4 <_fflush_r+0x108>
80009f38:	8e 68       	ld.sh	r8,r7[0xc]
80009f3a:	a7 a8       	sbr	r8,0x6
80009f3c:	ae 68       	st.h	r7[0xc],r8
80009f3e:	d8 22       	popm	r4-r7,pc
80009f40:	8e 68       	ld.sh	r8,r7[0xc]
80009f42:	ed b8 00 02 	bld	r8,0x2
80009f46:	c0 91       	brne	80009f58 <_fflush_r+0x9c>
80009f48:	6e 18       	ld.w	r8,r7[0x4]
80009f4a:	10 15       	sub	r5,r8
80009f4c:	6e d8       	ld.w	r8,r7[0x34]
80009f4e:	58 08       	cp.w	r8,0
80009f50:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009f54:	eb d8 e1 15 	subne	r5,r5,r8
80009f58:	6e b8       	ld.w	r8,r7[0x2c]
80009f5a:	0c 9c       	mov	r12,r6
80009f5c:	30 09       	mov	r9,0
80009f5e:	0a 9a       	mov	r10,r5
80009f60:	6e 8b       	ld.w	r11,r7[0x20]
80009f62:	5d 18       	icall	r8
80009f64:	8e 68       	ld.sh	r8,r7[0xc]
80009f66:	0a 3c       	cp.w	r12,r5
80009f68:	c2 61       	brne	80009fb4 <_fflush_r+0xf8>
80009f6a:	ab d8       	cbr	r8,0xb
80009f6c:	30 0c       	mov	r12,0
80009f6e:	6e 49       	ld.w	r9,r7[0x10]
80009f70:	ae 68       	st.h	r7[0xc],r8
80009f72:	8f 1c       	st.w	r7[0x4],r12
80009f74:	8f 09       	st.w	r7[0x0],r9
80009f76:	ed b8 00 0c 	bld	r8,0xc
80009f7a:	c2 51       	brne	80009fc4 <_fflush_r+0x108>
80009f7c:	ef 45 00 54 	st.w	r7[84],r5
80009f80:	d8 22       	popm	r4-r7,pc
80009f82:	6e 45       	ld.w	r5,r7[0x10]
80009f84:	58 05       	cp.w	r5,0
80009f86:	c1 f0       	breq	80009fc4 <_fflush_r+0x108>
80009f88:	6e 04       	ld.w	r4,r7[0x0]
80009f8a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009f8e:	8f 05       	st.w	r7[0x0],r5
80009f90:	f9 b8 01 00 	movne	r8,0
80009f94:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009f98:	0a 14       	sub	r4,r5
80009f9a:	8f 28       	st.w	r7[0x8],r8
80009f9c:	c1 18       	rjmp	80009fbe <_fflush_r+0x102>
80009f9e:	08 99       	mov	r9,r4
80009fa0:	0a 9a       	mov	r10,r5
80009fa2:	6e a8       	ld.w	r8,r7[0x28]
80009fa4:	6e 8b       	ld.w	r11,r7[0x20]
80009fa6:	0c 9c       	mov	r12,r6
80009fa8:	5d 18       	icall	r8
80009faa:	18 14       	sub	r4,r12
80009fac:	58 0c       	cp.w	r12,0
80009fae:	e0 89 00 07 	brgt	80009fbc <_fflush_r+0x100>
80009fb2:	8e 68       	ld.sh	r8,r7[0xc]
80009fb4:	a7 a8       	sbr	r8,0x6
80009fb6:	3f fc       	mov	r12,-1
80009fb8:	ae 68       	st.h	r7[0xc],r8
80009fba:	d8 22       	popm	r4-r7,pc
80009fbc:	18 05       	add	r5,r12
80009fbe:	58 04       	cp.w	r4,0
80009fc0:	fe 99 ff ef 	brgt	80009f9e <_fflush_r+0xe2>
80009fc4:	d8 2a       	popm	r4-r7,pc,r12=0
80009fc6:	d7 03       	nop

80009fc8 <__sfp_lock_acquire>:
80009fc8:	5e fc       	retal	r12

80009fca <__sfp_lock_release>:
80009fca:	5e fc       	retal	r12

80009fcc <_cleanup_r>:
80009fcc:	d4 01       	pushm	lr
80009fce:	fe cb f0 c6 	sub	r11,pc,-3898
80009fd2:	e0 a0 02 f7 	rcall	8000a5c0 <_fwalk>
80009fd6:	d8 02       	popm	pc

80009fd8 <__sfmoreglue>:
80009fd8:	d4 21       	pushm	r4-r7,lr
80009fda:	16 95       	mov	r5,r11
80009fdc:	f6 06 10 5c 	mul	r6,r11,92
80009fe0:	ec cb ff f4 	sub	r11,r6,-12
80009fe4:	fe b0 e2 7c 	rcall	800064dc <_malloc_r>
80009fe8:	18 97       	mov	r7,r12
80009fea:	c0 90       	breq	80009ffc <__sfmoreglue+0x24>
80009fec:	99 15       	st.w	r12[0x4],r5
80009fee:	30 0b       	mov	r11,0
80009ff0:	2f 4c       	sub	r12,-12
80009ff2:	0c 9a       	mov	r10,r6
80009ff4:	8f 2c       	st.w	r7[0x8],r12
80009ff6:	8f 0b       	st.w	r7[0x0],r11
80009ff8:	fe b0 e5 32 	rcall	80006a5c <memset>
80009ffc:	0e 9c       	mov	r12,r7
80009ffe:	d8 22       	popm	r4-r7,pc

8000a000 <__sfp>:
8000a000:	d4 21       	pushm	r4-r7,lr
8000a002:	fe c8 d0 0e 	sub	r8,pc,-12274
8000a006:	18 96       	mov	r6,r12
8000a008:	70 07       	ld.w	r7,r8[0x0]
8000a00a:	6e 68       	ld.w	r8,r7[0x18]
8000a00c:	58 08       	cp.w	r8,0
8000a00e:	c0 31       	brne	8000a014 <__sfp+0x14>
8000a010:	0e 9c       	mov	r12,r7
8000a012:	c2 dc       	rcall	8000a06c <__sinit>
8000a014:	ee c7 ff 28 	sub	r7,r7,-216
8000a018:	30 05       	mov	r5,0
8000a01a:	6e 2c       	ld.w	r12,r7[0x8]
8000a01c:	6e 18       	ld.w	r8,r7[0x4]
8000a01e:	c0 68       	rjmp	8000a02a <__sfp+0x2a>
8000a020:	98 69       	ld.sh	r9,r12[0xc]
8000a022:	ea 09 19 00 	cp.h	r9,r5
8000a026:	c1 10       	breq	8000a048 <__sfp+0x48>
8000a028:	2a 4c       	sub	r12,-92
8000a02a:	20 18       	sub	r8,1
8000a02c:	cf a7       	brpl	8000a020 <__sfp+0x20>
8000a02e:	6e 08       	ld.w	r8,r7[0x0]
8000a030:	58 08       	cp.w	r8,0
8000a032:	c0 61       	brne	8000a03e <__sfp+0x3e>
8000a034:	30 4b       	mov	r11,4
8000a036:	0c 9c       	mov	r12,r6
8000a038:	cd 0f       	rcall	80009fd8 <__sfmoreglue>
8000a03a:	8f 0c       	st.w	r7[0x0],r12
8000a03c:	c0 30       	breq	8000a042 <__sfp+0x42>
8000a03e:	6e 07       	ld.w	r7,r7[0x0]
8000a040:	ce db       	rjmp	8000a01a <__sfp+0x1a>
8000a042:	30 c8       	mov	r8,12
8000a044:	8d 38       	st.w	r6[0xc],r8
8000a046:	d8 22       	popm	r4-r7,pc
8000a048:	30 08       	mov	r8,0
8000a04a:	f9 48 00 4c 	st.w	r12[76],r8
8000a04e:	99 08       	st.w	r12[0x0],r8
8000a050:	99 28       	st.w	r12[0x8],r8
8000a052:	99 18       	st.w	r12[0x4],r8
8000a054:	99 48       	st.w	r12[0x10],r8
8000a056:	99 58       	st.w	r12[0x14],r8
8000a058:	99 68       	st.w	r12[0x18],r8
8000a05a:	99 d8       	st.w	r12[0x34],r8
8000a05c:	99 e8       	st.w	r12[0x38],r8
8000a05e:	f9 48 00 48 	st.w	r12[72],r8
8000a062:	3f f8       	mov	r8,-1
8000a064:	b8 78       	st.h	r12[0xe],r8
8000a066:	30 18       	mov	r8,1
8000a068:	b8 68       	st.h	r12[0xc],r8
8000a06a:	d8 22       	popm	r4-r7,pc

8000a06c <__sinit>:
8000a06c:	d4 21       	pushm	r4-r7,lr
8000a06e:	18 96       	mov	r6,r12
8000a070:	78 67       	ld.w	r7,r12[0x18]
8000a072:	58 07       	cp.w	r7,0
8000a074:	c4 91       	brne	8000a106 <__sinit+0x9a>
8000a076:	fe c8 00 aa 	sub	r8,pc,170
8000a07a:	30 15       	mov	r5,1
8000a07c:	99 a8       	st.w	r12[0x28],r8
8000a07e:	f9 47 00 d8 	st.w	r12[216],r7
8000a082:	f9 47 00 dc 	st.w	r12[220],r7
8000a086:	f9 47 00 e0 	st.w	r12[224],r7
8000a08a:	99 65       	st.w	r12[0x18],r5
8000a08c:	cb af       	rcall	8000a000 <__sfp>
8000a08e:	8d 0c       	st.w	r6[0x0],r12
8000a090:	0c 9c       	mov	r12,r6
8000a092:	cb 7f       	rcall	8000a000 <__sfp>
8000a094:	8d 1c       	st.w	r6[0x4],r12
8000a096:	0c 9c       	mov	r12,r6
8000a098:	cb 4f       	rcall	8000a000 <__sfp>
8000a09a:	6c 09       	ld.w	r9,r6[0x0]
8000a09c:	30 48       	mov	r8,4
8000a09e:	93 07       	st.w	r9[0x0],r7
8000a0a0:	b2 68       	st.h	r9[0xc],r8
8000a0a2:	93 17       	st.w	r9[0x4],r7
8000a0a4:	93 27       	st.w	r9[0x8],r7
8000a0a6:	6c 18       	ld.w	r8,r6[0x4]
8000a0a8:	b2 77       	st.h	r9[0xe],r7
8000a0aa:	93 47       	st.w	r9[0x10],r7
8000a0ac:	93 57       	st.w	r9[0x14],r7
8000a0ae:	93 67       	st.w	r9[0x18],r7
8000a0b0:	93 89       	st.w	r9[0x20],r9
8000a0b2:	91 07       	st.w	r8[0x0],r7
8000a0b4:	91 17       	st.w	r8[0x4],r7
8000a0b6:	91 27       	st.w	r8[0x8],r7
8000a0b8:	fe ce f3 24 	sub	lr,pc,-3292
8000a0bc:	fe cb f3 54 	sub	r11,pc,-3244
8000a0c0:	93 9e       	st.w	r9[0x24],lr
8000a0c2:	93 ab       	st.w	r9[0x28],r11
8000a0c4:	fe ca f3 7c 	sub	r10,pc,-3204
8000a0c8:	fe c4 f3 88 	sub	r4,pc,-3192
8000a0cc:	93 ba       	st.w	r9[0x2c],r10
8000a0ce:	93 c4       	st.w	r9[0x30],r4
8000a0d0:	30 99       	mov	r9,9
8000a0d2:	b0 69       	st.h	r8[0xc],r9
8000a0d4:	b0 75       	st.h	r8[0xe],r5
8000a0d6:	91 c4       	st.w	r8[0x30],r4
8000a0d8:	91 47       	st.w	r8[0x10],r7
8000a0da:	91 57       	st.w	r8[0x14],r7
8000a0dc:	91 67       	st.w	r8[0x18],r7
8000a0de:	91 88       	st.w	r8[0x20],r8
8000a0e0:	91 9e       	st.w	r8[0x24],lr
8000a0e2:	91 ab       	st.w	r8[0x28],r11
8000a0e4:	91 ba       	st.w	r8[0x2c],r10
8000a0e6:	8d 2c       	st.w	r6[0x8],r12
8000a0e8:	31 28       	mov	r8,18
8000a0ea:	99 07       	st.w	r12[0x0],r7
8000a0ec:	b8 68       	st.h	r12[0xc],r8
8000a0ee:	99 17       	st.w	r12[0x4],r7
8000a0f0:	99 27       	st.w	r12[0x8],r7
8000a0f2:	30 28       	mov	r8,2
8000a0f4:	b8 78       	st.h	r12[0xe],r8
8000a0f6:	99 c4       	st.w	r12[0x30],r4
8000a0f8:	99 67       	st.w	r12[0x18],r7
8000a0fa:	99 9e       	st.w	r12[0x24],lr
8000a0fc:	99 ab       	st.w	r12[0x28],r11
8000a0fe:	99 ba       	st.w	r12[0x2c],r10
8000a100:	99 47       	st.w	r12[0x10],r7
8000a102:	99 57       	st.w	r12[0x14],r7
8000a104:	99 8c       	st.w	r12[0x20],r12
8000a106:	d8 22       	popm	r4-r7,pc

8000a108 <_malloc_trim_r>:
8000a108:	d4 21       	pushm	r4-r7,lr
8000a10a:	16 95       	mov	r5,r11
8000a10c:	18 97       	mov	r7,r12
8000a10e:	fe b0 d7 83 	rcall	80005014 <__malloc_lock>
8000a112:	e0 64 05 44 	mov	r4,1348
8000a116:	68 28       	ld.w	r8,r4[0x8]
8000a118:	70 16       	ld.w	r6,r8[0x4]
8000a11a:	e0 16 ff fc 	andl	r6,0xfffc
8000a11e:	ec c8 ff 91 	sub	r8,r6,-111
8000a122:	f0 05 01 05 	sub	r5,r8,r5
8000a126:	e0 15 ff 80 	andl	r5,0xff80
8000a12a:	ea c5 00 80 	sub	r5,r5,128
8000a12e:	e0 45 00 7f 	cp.w	r5,127
8000a132:	e0 8a 00 25 	brle	8000a17c <_malloc_trim_r+0x74>
8000a136:	30 0b       	mov	r11,0
8000a138:	0e 9c       	mov	r12,r7
8000a13a:	fe b0 e5 f9 	rcall	80006d2c <_sbrk_r>
8000a13e:	68 28       	ld.w	r8,r4[0x8]
8000a140:	0c 08       	add	r8,r6
8000a142:	10 3c       	cp.w	r12,r8
8000a144:	c1 c1       	brne	8000a17c <_malloc_trim_r+0x74>
8000a146:	ea 0b 11 00 	rsub	r11,r5,0
8000a14a:	0e 9c       	mov	r12,r7
8000a14c:	fe b0 e5 f0 	rcall	80006d2c <_sbrk_r>
8000a150:	5b fc       	cp.w	r12,-1
8000a152:	c1 91       	brne	8000a184 <_malloc_trim_r+0x7c>
8000a154:	30 0b       	mov	r11,0
8000a156:	0e 9c       	mov	r12,r7
8000a158:	fe b0 e5 ea 	rcall	80006d2c <_sbrk_r>
8000a15c:	68 28       	ld.w	r8,r4[0x8]
8000a15e:	f8 08 01 09 	sub	r9,r12,r8
8000a162:	58 f9       	cp.w	r9,15
8000a164:	e0 8a 00 0c 	brle	8000a17c <_malloc_trim_r+0x74>
8000a168:	a1 a9       	sbr	r9,0x0
8000a16a:	91 19       	st.w	r8[0x4],r9
8000a16c:	e0 68 09 50 	mov	r8,2384
8000a170:	70 09       	ld.w	r9,r8[0x0]
8000a172:	e0 68 0d 54 	mov	r8,3412
8000a176:	f8 09 01 09 	sub	r9,r12,r9
8000a17a:	91 09       	st.w	r8[0x0],r9
8000a17c:	0e 9c       	mov	r12,r7
8000a17e:	fe b0 d7 51 	rcall	80005020 <__malloc_unlock>
8000a182:	d8 2a       	popm	r4-r7,pc,r12=0
8000a184:	68 28       	ld.w	r8,r4[0x8]
8000a186:	0a 16       	sub	r6,r5
8000a188:	a1 a6       	sbr	r6,0x0
8000a18a:	91 16       	st.w	r8[0x4],r6
8000a18c:	e0 68 0d 54 	mov	r8,3412
8000a190:	70 09       	ld.w	r9,r8[0x0]
8000a192:	0a 19       	sub	r9,r5
8000a194:	0e 9c       	mov	r12,r7
8000a196:	91 09       	st.w	r8[0x0],r9
8000a198:	fe b0 d7 44 	rcall	80005020 <__malloc_unlock>
8000a19c:	da 2a       	popm	r4-r7,pc,r12=1
8000a19e:	d7 03       	nop

8000a1a0 <_free_r>:
8000a1a0:	d4 21       	pushm	r4-r7,lr
8000a1a2:	16 96       	mov	r6,r11
8000a1a4:	18 97       	mov	r7,r12
8000a1a6:	58 0b       	cp.w	r11,0
8000a1a8:	e0 80 00 c0 	breq	8000a328 <_free_r+0x188>
8000a1ac:	fe b0 d7 34 	rcall	80005014 <__malloc_lock>
8000a1b0:	20 86       	sub	r6,8
8000a1b2:	e0 6a 05 44 	mov	r10,1348
8000a1b6:	6c 18       	ld.w	r8,r6[0x4]
8000a1b8:	74 2e       	ld.w	lr,r10[0x8]
8000a1ba:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a1be:	a1 c8       	cbr	r8,0x0
8000a1c0:	ec 08 00 09 	add	r9,r6,r8
8000a1c4:	72 1b       	ld.w	r11,r9[0x4]
8000a1c6:	e0 1b ff fc 	andl	r11,0xfffc
8000a1ca:	1c 39       	cp.w	r9,lr
8000a1cc:	c1 e1       	brne	8000a208 <_free_r+0x68>
8000a1ce:	f6 08 00 08 	add	r8,r11,r8
8000a1d2:	58 0c       	cp.w	r12,0
8000a1d4:	c0 81       	brne	8000a1e4 <_free_r+0x44>
8000a1d6:	6c 09       	ld.w	r9,r6[0x0]
8000a1d8:	12 16       	sub	r6,r9
8000a1da:	12 08       	add	r8,r9
8000a1dc:	6c 3b       	ld.w	r11,r6[0xc]
8000a1de:	6c 29       	ld.w	r9,r6[0x8]
8000a1e0:	97 29       	st.w	r11[0x8],r9
8000a1e2:	93 3b       	st.w	r9[0xc],r11
8000a1e4:	10 99       	mov	r9,r8
8000a1e6:	95 26       	st.w	r10[0x8],r6
8000a1e8:	a1 a9       	sbr	r9,0x0
8000a1ea:	8d 19       	st.w	r6[0x4],r9
8000a1ec:	e0 69 09 4c 	mov	r9,2380
8000a1f0:	72 09       	ld.w	r9,r9[0x0]
8000a1f2:	12 38       	cp.w	r8,r9
8000a1f4:	c0 63       	brcs	8000a200 <_free_r+0x60>
8000a1f6:	e0 68 0d 50 	mov	r8,3408
8000a1fa:	0e 9c       	mov	r12,r7
8000a1fc:	70 0b       	ld.w	r11,r8[0x0]
8000a1fe:	c8 5f       	rcall	8000a108 <_malloc_trim_r>
8000a200:	0e 9c       	mov	r12,r7
8000a202:	fe b0 d7 0f 	rcall	80005020 <__malloc_unlock>
8000a206:	d8 22       	popm	r4-r7,pc
8000a208:	93 1b       	st.w	r9[0x4],r11
8000a20a:	58 0c       	cp.w	r12,0
8000a20c:	c0 30       	breq	8000a212 <_free_r+0x72>
8000a20e:	30 0c       	mov	r12,0
8000a210:	c1 08       	rjmp	8000a230 <_free_r+0x90>
8000a212:	6c 0e       	ld.w	lr,r6[0x0]
8000a214:	f4 c5 ff f8 	sub	r5,r10,-8
8000a218:	1c 16       	sub	r6,lr
8000a21a:	1c 08       	add	r8,lr
8000a21c:	6c 2e       	ld.w	lr,r6[0x8]
8000a21e:	0a 3e       	cp.w	lr,r5
8000a220:	f9 bc 00 01 	moveq	r12,1
8000a224:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a228:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a22c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a230:	f2 0b 00 0e 	add	lr,r9,r11
8000a234:	7c 1e       	ld.w	lr,lr[0x4]
8000a236:	ed be 00 00 	bld	lr,0x0
8000a23a:	c1 40       	breq	8000a262 <_free_r+0xc2>
8000a23c:	16 08       	add	r8,r11
8000a23e:	58 0c       	cp.w	r12,0
8000a240:	c0 d1       	brne	8000a25a <_free_r+0xba>
8000a242:	e0 6e 05 44 	mov	lr,1348
8000a246:	72 2b       	ld.w	r11,r9[0x8]
8000a248:	2f 8e       	sub	lr,-8
8000a24a:	1c 3b       	cp.w	r11,lr
8000a24c:	c0 71       	brne	8000a25a <_free_r+0xba>
8000a24e:	97 36       	st.w	r11[0xc],r6
8000a250:	97 26       	st.w	r11[0x8],r6
8000a252:	8d 2b       	st.w	r6[0x8],r11
8000a254:	8d 3b       	st.w	r6[0xc],r11
8000a256:	30 1c       	mov	r12,1
8000a258:	c0 58       	rjmp	8000a262 <_free_r+0xc2>
8000a25a:	72 2b       	ld.w	r11,r9[0x8]
8000a25c:	72 39       	ld.w	r9,r9[0xc]
8000a25e:	93 2b       	st.w	r9[0x8],r11
8000a260:	97 39       	st.w	r11[0xc],r9
8000a262:	10 99       	mov	r9,r8
8000a264:	ec 08 09 08 	st.w	r6[r8],r8
8000a268:	a1 a9       	sbr	r9,0x0
8000a26a:	8d 19       	st.w	r6[0x4],r9
8000a26c:	58 0c       	cp.w	r12,0
8000a26e:	c5 a1       	brne	8000a322 <_free_r+0x182>
8000a270:	e0 48 01 ff 	cp.w	r8,511
8000a274:	e0 8b 00 13 	brhi	8000a29a <_free_r+0xfa>
8000a278:	a3 98       	lsr	r8,0x3
8000a27a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a27e:	72 2b       	ld.w	r11,r9[0x8]
8000a280:	8d 39       	st.w	r6[0xc],r9
8000a282:	8d 2b       	st.w	r6[0x8],r11
8000a284:	97 36       	st.w	r11[0xc],r6
8000a286:	93 26       	st.w	r9[0x8],r6
8000a288:	a3 48       	asr	r8,0x2
8000a28a:	74 19       	ld.w	r9,r10[0x4]
8000a28c:	30 1b       	mov	r11,1
8000a28e:	f6 08 09 48 	lsl	r8,r11,r8
8000a292:	f3 e8 10 08 	or	r8,r9,r8
8000a296:	95 18       	st.w	r10[0x4],r8
8000a298:	c4 58       	rjmp	8000a322 <_free_r+0x182>
8000a29a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a29e:	58 4b       	cp.w	r11,4
8000a2a0:	e0 8b 00 06 	brhi	8000a2ac <_free_r+0x10c>
8000a2a4:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a2a8:	2c 8b       	sub	r11,-56
8000a2aa:	c2 08       	rjmp	8000a2ea <_free_r+0x14a>
8000a2ac:	59 4b       	cp.w	r11,20
8000a2ae:	e0 8b 00 04 	brhi	8000a2b6 <_free_r+0x116>
8000a2b2:	2a 5b       	sub	r11,-91
8000a2b4:	c1 b8       	rjmp	8000a2ea <_free_r+0x14a>
8000a2b6:	e0 4b 00 54 	cp.w	r11,84
8000a2ba:	e0 8b 00 06 	brhi	8000a2c6 <_free_r+0x126>
8000a2be:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a2c2:	29 2b       	sub	r11,-110
8000a2c4:	c1 38       	rjmp	8000a2ea <_free_r+0x14a>
8000a2c6:	e0 4b 01 54 	cp.w	r11,340
8000a2ca:	e0 8b 00 06 	brhi	8000a2d6 <_free_r+0x136>
8000a2ce:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a2d2:	28 9b       	sub	r11,-119
8000a2d4:	c0 b8       	rjmp	8000a2ea <_free_r+0x14a>
8000a2d6:	e0 4b 05 54 	cp.w	r11,1364
8000a2da:	e0 88 00 05 	brls	8000a2e4 <_free_r+0x144>
8000a2de:	37 eb       	mov	r11,126
8000a2e0:	c0 58       	rjmp	8000a2ea <_free_r+0x14a>
8000a2e2:	d7 03       	nop
8000a2e4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a2e8:	28 4b       	sub	r11,-124
8000a2ea:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a2ee:	78 29       	ld.w	r9,r12[0x8]
8000a2f0:	18 39       	cp.w	r9,r12
8000a2f2:	c0 e1       	brne	8000a30e <_free_r+0x16e>
8000a2f4:	74 18       	ld.w	r8,r10[0x4]
8000a2f6:	a3 4b       	asr	r11,0x2
8000a2f8:	30 1c       	mov	r12,1
8000a2fa:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a2fe:	f1 eb 10 0b 	or	r11,r8,r11
8000a302:	12 98       	mov	r8,r9
8000a304:	95 1b       	st.w	r10[0x4],r11
8000a306:	c0 a8       	rjmp	8000a31a <_free_r+0x17a>
8000a308:	72 29       	ld.w	r9,r9[0x8]
8000a30a:	18 39       	cp.w	r9,r12
8000a30c:	c0 60       	breq	8000a318 <_free_r+0x178>
8000a30e:	72 1a       	ld.w	r10,r9[0x4]
8000a310:	e0 1a ff fc 	andl	r10,0xfffc
8000a314:	14 38       	cp.w	r8,r10
8000a316:	cf 93       	brcs	8000a308 <_free_r+0x168>
8000a318:	72 38       	ld.w	r8,r9[0xc]
8000a31a:	8d 38       	st.w	r6[0xc],r8
8000a31c:	8d 29       	st.w	r6[0x8],r9
8000a31e:	93 36       	st.w	r9[0xc],r6
8000a320:	91 26       	st.w	r8[0x8],r6
8000a322:	0e 9c       	mov	r12,r7
8000a324:	fe b0 d6 7e 	rcall	80005020 <__malloc_unlock>
8000a328:	d8 22       	popm	r4-r7,pc
8000a32a:	d7 03       	nop

8000a32c <__sfvwrite_r>:
8000a32c:	d4 31       	pushm	r0-r7,lr
8000a32e:	20 3d       	sub	sp,12
8000a330:	14 94       	mov	r4,r10
8000a332:	18 95       	mov	r5,r12
8000a334:	16 97       	mov	r7,r11
8000a336:	74 28       	ld.w	r8,r10[0x8]
8000a338:	58 08       	cp.w	r8,0
8000a33a:	e0 80 01 40 	breq	8000a5ba <__sfvwrite_r+0x28e>
8000a33e:	96 68       	ld.sh	r8,r11[0xc]
8000a340:	ed b8 00 03 	bld	r8,0x3
8000a344:	c0 41       	brne	8000a34c <__sfvwrite_r+0x20>
8000a346:	76 48       	ld.w	r8,r11[0x10]
8000a348:	58 08       	cp.w	r8,0
8000a34a:	c0 c1       	brne	8000a362 <__sfvwrite_r+0x36>
8000a34c:	0e 9b       	mov	r11,r7
8000a34e:	0a 9c       	mov	r12,r5
8000a350:	fe b0 f6 c4 	rcall	800090d8 <__swsetup_r>
8000a354:	c0 70       	breq	8000a362 <__sfvwrite_r+0x36>
8000a356:	8e 68       	ld.sh	r8,r7[0xc]
8000a358:	a7 a8       	sbr	r8,0x6
8000a35a:	ae 68       	st.h	r7[0xc],r8
8000a35c:	30 98       	mov	r8,9
8000a35e:	8b 38       	st.w	r5[0xc],r8
8000a360:	c2 b9       	rjmp	8000a5b6 <__sfvwrite_r+0x28a>
8000a362:	8e 63       	ld.sh	r3,r7[0xc]
8000a364:	68 00       	ld.w	r0,r4[0x0]
8000a366:	06 96       	mov	r6,r3
8000a368:	e2 16 00 02 	andl	r6,0x2,COH
8000a36c:	c2 10       	breq	8000a3ae <__sfvwrite_r+0x82>
8000a36e:	30 03       	mov	r3,0
8000a370:	e0 62 04 00 	mov	r2,1024
8000a374:	06 96       	mov	r6,r3
8000a376:	c0 48       	rjmp	8000a37e <__sfvwrite_r+0x52>
8000a378:	60 03       	ld.w	r3,r0[0x0]
8000a37a:	60 16       	ld.w	r6,r0[0x4]
8000a37c:	2f 80       	sub	r0,-8
8000a37e:	58 06       	cp.w	r6,0
8000a380:	cf c0       	breq	8000a378 <__sfvwrite_r+0x4c>
8000a382:	e0 46 04 00 	cp.w	r6,1024
8000a386:	ec 09 17 80 	movls	r9,r6
8000a38a:	e4 09 17 b0 	movhi	r9,r2
8000a38e:	06 9a       	mov	r10,r3
8000a390:	6e a8       	ld.w	r8,r7[0x28]
8000a392:	6e 8b       	ld.w	r11,r7[0x20]
8000a394:	0a 9c       	mov	r12,r5
8000a396:	5d 18       	icall	r8
8000a398:	18 16       	sub	r6,r12
8000a39a:	58 0c       	cp.w	r12,0
8000a39c:	e0 8a 01 0a 	brle	8000a5b0 <__sfvwrite_r+0x284>
8000a3a0:	68 28       	ld.w	r8,r4[0x8]
8000a3a2:	18 18       	sub	r8,r12
8000a3a4:	89 28       	st.w	r4[0x8],r8
8000a3a6:	e0 80 01 0a 	breq	8000a5ba <__sfvwrite_r+0x28e>
8000a3aa:	18 03       	add	r3,r12
8000a3ac:	ce 9b       	rjmp	8000a37e <__sfvwrite_r+0x52>
8000a3ae:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a3b2:	c0 70       	breq	8000a3c0 <__sfvwrite_r+0x94>
8000a3b4:	50 06       	stdsp	sp[0x0],r6
8000a3b6:	0c 93       	mov	r3,r6
8000a3b8:	0c 91       	mov	r1,r6
8000a3ba:	50 15       	stdsp	sp[0x4],r5
8000a3bc:	08 92       	mov	r2,r4
8000a3be:	c9 c8       	rjmp	8000a4f6 <__sfvwrite_r+0x1ca>
8000a3c0:	06 96       	mov	r6,r3
8000a3c2:	08 91       	mov	r1,r4
8000a3c4:	c0 48       	rjmp	8000a3cc <__sfvwrite_r+0xa0>
8000a3c6:	60 03       	ld.w	r3,r0[0x0]
8000a3c8:	60 16       	ld.w	r6,r0[0x4]
8000a3ca:	2f 80       	sub	r0,-8
8000a3cc:	58 06       	cp.w	r6,0
8000a3ce:	cf c0       	breq	8000a3c6 <__sfvwrite_r+0x9a>
8000a3d0:	8e 68       	ld.sh	r8,r7[0xc]
8000a3d2:	6e 24       	ld.w	r4,r7[0x8]
8000a3d4:	10 99       	mov	r9,r8
8000a3d6:	e2 19 02 00 	andl	r9,0x200,COH
8000a3da:	c5 50       	breq	8000a484 <__sfvwrite_r+0x158>
8000a3dc:	08 36       	cp.w	r6,r4
8000a3de:	c4 43       	brcs	8000a466 <__sfvwrite_r+0x13a>
8000a3e0:	10 99       	mov	r9,r8
8000a3e2:	e2 19 04 80 	andl	r9,0x480,COH
8000a3e6:	c4 00       	breq	8000a466 <__sfvwrite_r+0x13a>
8000a3e8:	6e 4b       	ld.w	r11,r7[0x10]
8000a3ea:	6e 09       	ld.w	r9,r7[0x0]
8000a3ec:	16 19       	sub	r9,r11
8000a3ee:	50 09       	stdsp	sp[0x0],r9
8000a3f0:	6e 59       	ld.w	r9,r7[0x14]
8000a3f2:	10 9c       	mov	r12,r8
8000a3f4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a3f8:	30 28       	mov	r8,2
8000a3fa:	f4 08 0c 08 	divs	r8,r10,r8
8000a3fe:	fa e9 00 04 	st.d	sp[4],r8
8000a402:	10 94       	mov	r4,r8
8000a404:	40 09       	lddsp	r9,sp[0x0]
8000a406:	e2 1c 04 00 	andl	r12,0x400,COH
8000a40a:	2f f9       	sub	r9,-1
8000a40c:	0c 09       	add	r9,r6
8000a40e:	12 38       	cp.w	r8,r9
8000a410:	f2 04 17 30 	movlo	r4,r9
8000a414:	58 0c       	cp.w	r12,0
8000a416:	c1 10       	breq	8000a438 <__sfvwrite_r+0x10c>
8000a418:	08 9b       	mov	r11,r4
8000a41a:	0a 9c       	mov	r12,r5
8000a41c:	fe b0 e0 60 	rcall	800064dc <_malloc_r>
8000a420:	18 92       	mov	r2,r12
8000a422:	c1 40       	breq	8000a44a <__sfvwrite_r+0x11e>
8000a424:	40 0a       	lddsp	r10,sp[0x0]
8000a426:	6e 4b       	ld.w	r11,r7[0x10]
8000a428:	fe b0 e2 76 	rcall	80006914 <memcpy>
8000a42c:	8e 68       	ld.sh	r8,r7[0xc]
8000a42e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a432:	a7 b8       	sbr	r8,0x7
8000a434:	ae 68       	st.h	r7[0xc],r8
8000a436:	c0 d8       	rjmp	8000a450 <__sfvwrite_r+0x124>
8000a438:	08 9a       	mov	r10,r4
8000a43a:	0a 9c       	mov	r12,r5
8000a43c:	fe b0 e3 18 	rcall	80006a6c <_realloc_r>
8000a440:	18 92       	mov	r2,r12
8000a442:	c0 71       	brne	8000a450 <__sfvwrite_r+0x124>
8000a444:	6e 4b       	ld.w	r11,r7[0x10]
8000a446:	0a 9c       	mov	r12,r5
8000a448:	ca ce       	rcall	8000a1a0 <_free_r>
8000a44a:	30 c8       	mov	r8,12
8000a44c:	8b 38       	st.w	r5[0xc],r8
8000a44e:	cb 18       	rjmp	8000a5b0 <__sfvwrite_r+0x284>
8000a450:	40 0a       	lddsp	r10,sp[0x0]
8000a452:	40 09       	lddsp	r9,sp[0x0]
8000a454:	e8 0a 01 0a 	sub	r10,r4,r10
8000a458:	e4 09 00 08 	add	r8,r2,r9
8000a45c:	8f 54       	st.w	r7[0x14],r4
8000a45e:	8f 2a       	st.w	r7[0x8],r10
8000a460:	8f 08       	st.w	r7[0x0],r8
8000a462:	8f 42       	st.w	r7[0x10],r2
8000a464:	0c 94       	mov	r4,r6
8000a466:	08 36       	cp.w	r6,r4
8000a468:	ec 04 17 30 	movlo	r4,r6
8000a46c:	06 9b       	mov	r11,r3
8000a46e:	08 9a       	mov	r10,r4
8000a470:	6e 0c       	ld.w	r12,r7[0x0]
8000a472:	c3 ad       	rcall	8000a6e6 <memmove>
8000a474:	6e 08       	ld.w	r8,r7[0x0]
8000a476:	08 08       	add	r8,r4
8000a478:	8f 08       	st.w	r7[0x0],r8
8000a47a:	6e 28       	ld.w	r8,r7[0x8]
8000a47c:	08 18       	sub	r8,r4
8000a47e:	0c 94       	mov	r4,r6
8000a480:	8f 28       	st.w	r7[0x8],r8
8000a482:	c2 e8       	rjmp	8000a4de <__sfvwrite_r+0x1b2>
8000a484:	08 36       	cp.w	r6,r4
8000a486:	5f ba       	srhi	r10
8000a488:	6e 0c       	ld.w	r12,r7[0x0]
8000a48a:	6e 48       	ld.w	r8,r7[0x10]
8000a48c:	10 3c       	cp.w	r12,r8
8000a48e:	5f b8       	srhi	r8
8000a490:	f5 e8 00 08 	and	r8,r10,r8
8000a494:	f2 08 18 00 	cp.b	r8,r9
8000a498:	c0 d0       	breq	8000a4b2 <__sfvwrite_r+0x186>
8000a49a:	06 9b       	mov	r11,r3
8000a49c:	08 9a       	mov	r10,r4
8000a49e:	c2 4d       	rcall	8000a6e6 <memmove>
8000a4a0:	6e 08       	ld.w	r8,r7[0x0]
8000a4a2:	08 08       	add	r8,r4
8000a4a4:	0e 9b       	mov	r11,r7
8000a4a6:	8f 08       	st.w	r7[0x0],r8
8000a4a8:	0a 9c       	mov	r12,r5
8000a4aa:	fe b0 fd 09 	rcall	80009ebc <_fflush_r>
8000a4ae:	c1 80       	breq	8000a4de <__sfvwrite_r+0x1b2>
8000a4b0:	c8 08       	rjmp	8000a5b0 <__sfvwrite_r+0x284>
8000a4b2:	6e 59       	ld.w	r9,r7[0x14]
8000a4b4:	12 36       	cp.w	r6,r9
8000a4b6:	c0 a3       	brcs	8000a4ca <__sfvwrite_r+0x19e>
8000a4b8:	6e a8       	ld.w	r8,r7[0x28]
8000a4ba:	06 9a       	mov	r10,r3
8000a4bc:	6e 8b       	ld.w	r11,r7[0x20]
8000a4be:	0a 9c       	mov	r12,r5
8000a4c0:	5d 18       	icall	r8
8000a4c2:	18 94       	mov	r4,r12
8000a4c4:	e0 89 00 0d 	brgt	8000a4de <__sfvwrite_r+0x1b2>
8000a4c8:	c7 48       	rjmp	8000a5b0 <__sfvwrite_r+0x284>
8000a4ca:	0c 9a       	mov	r10,r6
8000a4cc:	06 9b       	mov	r11,r3
8000a4ce:	c0 cd       	rcall	8000a6e6 <memmove>
8000a4d0:	6e 08       	ld.w	r8,r7[0x0]
8000a4d2:	0c 08       	add	r8,r6
8000a4d4:	0c 94       	mov	r4,r6
8000a4d6:	8f 08       	st.w	r7[0x0],r8
8000a4d8:	6e 28       	ld.w	r8,r7[0x8]
8000a4da:	0c 18       	sub	r8,r6
8000a4dc:	8f 28       	st.w	r7[0x8],r8
8000a4de:	62 28       	ld.w	r8,r1[0x8]
8000a4e0:	08 18       	sub	r8,r4
8000a4e2:	83 28       	st.w	r1[0x8],r8
8000a4e4:	c6 b0       	breq	8000a5ba <__sfvwrite_r+0x28e>
8000a4e6:	08 16       	sub	r6,r4
8000a4e8:	08 03       	add	r3,r4
8000a4ea:	c7 1b       	rjmp	8000a3cc <__sfvwrite_r+0xa0>
8000a4ec:	60 03       	ld.w	r3,r0[0x0]
8000a4ee:	60 11       	ld.w	r1,r0[0x4]
8000a4f0:	30 08       	mov	r8,0
8000a4f2:	2f 80       	sub	r0,-8
8000a4f4:	50 08       	stdsp	sp[0x0],r8
8000a4f6:	58 01       	cp.w	r1,0
8000a4f8:	cf a0       	breq	8000a4ec <__sfvwrite_r+0x1c0>
8000a4fa:	40 0a       	lddsp	r10,sp[0x0]
8000a4fc:	58 0a       	cp.w	r10,0
8000a4fe:	c1 41       	brne	8000a526 <__sfvwrite_r+0x1fa>
8000a500:	e2 c6 ff ff 	sub	r6,r1,-1
8000a504:	02 9a       	mov	r10,r1
8000a506:	30 ab       	mov	r11,10
8000a508:	06 9c       	mov	r12,r3
8000a50a:	ce 3c       	rcall	8000a6d0 <memchr>
8000a50c:	f8 c8 ff ff 	sub	r8,r12,-1
8000a510:	58 0c       	cp.w	r12,0
8000a512:	f1 d3 e1 16 	subne	r6,r8,r3
8000a516:	f9 b9 01 01 	movne	r9,1
8000a51a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a51e:	f9 b8 00 01 	moveq	r8,1
8000a522:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a526:	02 36       	cp.w	r6,r1
8000a528:	ec 04 17 80 	movls	r4,r6
8000a52c:	e2 04 17 b0 	movhi	r4,r1
8000a530:	6e 59       	ld.w	r9,r7[0x14]
8000a532:	6e 25       	ld.w	r5,r7[0x8]
8000a534:	f2 05 00 05 	add	r5,r9,r5
8000a538:	0a 34       	cp.w	r4,r5
8000a53a:	5f 9a       	srgt	r10
8000a53c:	6e 0c       	ld.w	r12,r7[0x0]
8000a53e:	6e 48       	ld.w	r8,r7[0x10]
8000a540:	10 3c       	cp.w	r12,r8
8000a542:	5f b8       	srhi	r8
8000a544:	f5 e8 00 08 	and	r8,r10,r8
8000a548:	30 0a       	mov	r10,0
8000a54a:	f4 08 18 00 	cp.b	r8,r10
8000a54e:	c0 d0       	breq	8000a568 <__sfvwrite_r+0x23c>
8000a550:	06 9b       	mov	r11,r3
8000a552:	0a 9a       	mov	r10,r5
8000a554:	cc 9c       	rcall	8000a6e6 <memmove>
8000a556:	6e 08       	ld.w	r8,r7[0x0]
8000a558:	0a 08       	add	r8,r5
8000a55a:	0e 9b       	mov	r11,r7
8000a55c:	8f 08       	st.w	r7[0x0],r8
8000a55e:	40 1c       	lddsp	r12,sp[0x4]
8000a560:	fe b0 fc ae 	rcall	80009ebc <_fflush_r>
8000a564:	c1 70       	breq	8000a592 <__sfvwrite_r+0x266>
8000a566:	c2 58       	rjmp	8000a5b0 <__sfvwrite_r+0x284>
8000a568:	12 34       	cp.w	r4,r9
8000a56a:	c0 a5       	brlt	8000a57e <__sfvwrite_r+0x252>
8000a56c:	6e a8       	ld.w	r8,r7[0x28]
8000a56e:	06 9a       	mov	r10,r3
8000a570:	6e 8b       	ld.w	r11,r7[0x20]
8000a572:	40 1c       	lddsp	r12,sp[0x4]
8000a574:	5d 18       	icall	r8
8000a576:	18 95       	mov	r5,r12
8000a578:	e0 89 00 0d 	brgt	8000a592 <__sfvwrite_r+0x266>
8000a57c:	c1 a8       	rjmp	8000a5b0 <__sfvwrite_r+0x284>
8000a57e:	08 9a       	mov	r10,r4
8000a580:	06 9b       	mov	r11,r3
8000a582:	cb 2c       	rcall	8000a6e6 <memmove>
8000a584:	6e 08       	ld.w	r8,r7[0x0]
8000a586:	08 08       	add	r8,r4
8000a588:	08 95       	mov	r5,r4
8000a58a:	8f 08       	st.w	r7[0x0],r8
8000a58c:	6e 28       	ld.w	r8,r7[0x8]
8000a58e:	08 18       	sub	r8,r4
8000a590:	8f 28       	st.w	r7[0x8],r8
8000a592:	0a 16       	sub	r6,r5
8000a594:	c0 71       	brne	8000a5a2 <__sfvwrite_r+0x276>
8000a596:	0e 9b       	mov	r11,r7
8000a598:	40 1c       	lddsp	r12,sp[0x4]
8000a59a:	fe b0 fc 91 	rcall	80009ebc <_fflush_r>
8000a59e:	c0 91       	brne	8000a5b0 <__sfvwrite_r+0x284>
8000a5a0:	50 06       	stdsp	sp[0x0],r6
8000a5a2:	64 28       	ld.w	r8,r2[0x8]
8000a5a4:	0a 18       	sub	r8,r5
8000a5a6:	85 28       	st.w	r2[0x8],r8
8000a5a8:	c0 90       	breq	8000a5ba <__sfvwrite_r+0x28e>
8000a5aa:	0a 11       	sub	r1,r5
8000a5ac:	0a 03       	add	r3,r5
8000a5ae:	ca 4b       	rjmp	8000a4f6 <__sfvwrite_r+0x1ca>
8000a5b0:	8e 68       	ld.sh	r8,r7[0xc]
8000a5b2:	a7 a8       	sbr	r8,0x6
8000a5b4:	ae 68       	st.h	r7[0xc],r8
8000a5b6:	3f fc       	mov	r12,-1
8000a5b8:	c0 28       	rjmp	8000a5bc <__sfvwrite_r+0x290>
8000a5ba:	30 0c       	mov	r12,0
8000a5bc:	2f dd       	sub	sp,-12
8000a5be:	d8 32       	popm	r0-r7,pc

8000a5c0 <_fwalk>:
8000a5c0:	d4 31       	pushm	r0-r7,lr
8000a5c2:	30 05       	mov	r5,0
8000a5c4:	16 91       	mov	r1,r11
8000a5c6:	f8 c7 ff 28 	sub	r7,r12,-216
8000a5ca:	0a 92       	mov	r2,r5
8000a5cc:	fe b0 fc fe 	rcall	80009fc8 <__sfp_lock_acquire>
8000a5d0:	3f f3       	mov	r3,-1
8000a5d2:	c1 68       	rjmp	8000a5fe <_fwalk+0x3e>
8000a5d4:	6e 26       	ld.w	r6,r7[0x8]
8000a5d6:	6e 14       	ld.w	r4,r7[0x4]
8000a5d8:	2f 46       	sub	r6,-12
8000a5da:	c0 c8       	rjmp	8000a5f2 <_fwalk+0x32>
8000a5dc:	8c 08       	ld.sh	r8,r6[0x0]
8000a5de:	e4 08 19 00 	cp.h	r8,r2
8000a5e2:	c0 70       	breq	8000a5f0 <_fwalk+0x30>
8000a5e4:	8c 18       	ld.sh	r8,r6[0x2]
8000a5e6:	e6 08 19 00 	cp.h	r8,r3
8000a5ea:	c0 30       	breq	8000a5f0 <_fwalk+0x30>
8000a5ec:	5d 11       	icall	r1
8000a5ee:	18 45       	or	r5,r12
8000a5f0:	2a 46       	sub	r6,-92
8000a5f2:	20 14       	sub	r4,1
8000a5f4:	ec cc 00 0c 	sub	r12,r6,12
8000a5f8:	58 04       	cp.w	r4,0
8000a5fa:	cf 14       	brge	8000a5dc <_fwalk+0x1c>
8000a5fc:	6e 07       	ld.w	r7,r7[0x0]
8000a5fe:	58 07       	cp.w	r7,0
8000a600:	ce a1       	brne	8000a5d4 <_fwalk+0x14>
8000a602:	fe b0 fc e4 	rcall	80009fca <__sfp_lock_release>
8000a606:	0a 9c       	mov	r12,r5
8000a608:	d8 32       	popm	r0-r7,pc
8000a60a:	d7 03       	nop

8000a60c <_localeconv_r>:
8000a60c:	fe cc d6 14 	sub	r12,pc,-10732
8000a610:	5e fc       	retal	r12
8000a612:	d7 03       	nop

8000a614 <__smakebuf_r>:
8000a614:	d4 21       	pushm	r4-r7,lr
8000a616:	20 fd       	sub	sp,60
8000a618:	96 68       	ld.sh	r8,r11[0xc]
8000a61a:	16 97       	mov	r7,r11
8000a61c:	18 96       	mov	r6,r12
8000a61e:	e2 18 00 02 	andl	r8,0x2,COH
8000a622:	c3 d1       	brne	8000a69c <__smakebuf_r+0x88>
8000a624:	96 7b       	ld.sh	r11,r11[0xe]
8000a626:	f0 0b 19 00 	cp.h	r11,r8
8000a62a:	c0 55       	brlt	8000a634 <__smakebuf_r+0x20>
8000a62c:	1a 9a       	mov	r10,sp
8000a62e:	e0 a0 04 75 	rcall	8000af18 <_fstat_r>
8000a632:	c0 f4       	brge	8000a650 <__smakebuf_r+0x3c>
8000a634:	8e 65       	ld.sh	r5,r7[0xc]
8000a636:	0a 98       	mov	r8,r5
8000a638:	ab b8       	sbr	r8,0xb
8000a63a:	e2 15 00 80 	andl	r5,0x80,COH
8000a63e:	ae 68       	st.h	r7[0xc],r8
8000a640:	30 04       	mov	r4,0
8000a642:	e0 68 04 00 	mov	r8,1024
8000a646:	f9 b5 01 40 	movne	r5,64
8000a64a:	f0 05 17 00 	moveq	r5,r8
8000a64e:	c1 c8       	rjmp	8000a686 <__smakebuf_r+0x72>
8000a650:	40 18       	lddsp	r8,sp[0x4]
8000a652:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a656:	e0 48 20 00 	cp.w	r8,8192
8000a65a:	5f 04       	sreq	r4
8000a65c:	e0 48 80 00 	cp.w	r8,32768
8000a660:	c0 e1       	brne	8000a67c <__smakebuf_r+0x68>
8000a662:	6e b9       	ld.w	r9,r7[0x2c]
8000a664:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a668:	10 39       	cp.w	r9,r8
8000a66a:	c0 91       	brne	8000a67c <__smakebuf_r+0x68>
8000a66c:	8e 68       	ld.sh	r8,r7[0xc]
8000a66e:	e0 65 04 00 	mov	r5,1024
8000a672:	ab a8       	sbr	r8,0xa
8000a674:	ef 45 00 50 	st.w	r7[80],r5
8000a678:	ae 68       	st.h	r7[0xc],r8
8000a67a:	c0 68       	rjmp	8000a686 <__smakebuf_r+0x72>
8000a67c:	8e 68       	ld.sh	r8,r7[0xc]
8000a67e:	e0 65 04 00 	mov	r5,1024
8000a682:	ab b8       	sbr	r8,0xb
8000a684:	ae 68       	st.h	r7[0xc],r8
8000a686:	0a 9b       	mov	r11,r5
8000a688:	0c 9c       	mov	r12,r6
8000a68a:	fe b0 df 29 	rcall	800064dc <_malloc_r>
8000a68e:	8e 68       	ld.sh	r8,r7[0xc]
8000a690:	c0 d1       	brne	8000a6aa <__smakebuf_r+0x96>
8000a692:	ed b8 00 09 	bld	r8,0x9
8000a696:	c1 b0       	breq	8000a6cc <__smakebuf_r+0xb8>
8000a698:	a1 b8       	sbr	r8,0x1
8000a69a:	ae 68       	st.h	r7[0xc],r8
8000a69c:	ee c8 ff b9 	sub	r8,r7,-71
8000a6a0:	8f 48       	st.w	r7[0x10],r8
8000a6a2:	8f 08       	st.w	r7[0x0],r8
8000a6a4:	30 18       	mov	r8,1
8000a6a6:	8f 58       	st.w	r7[0x14],r8
8000a6a8:	c1 28       	rjmp	8000a6cc <__smakebuf_r+0xb8>
8000a6aa:	a7 b8       	sbr	r8,0x7
8000a6ac:	8f 4c       	st.w	r7[0x10],r12
8000a6ae:	ae 68       	st.h	r7[0xc],r8
8000a6b0:	8f 55       	st.w	r7[0x14],r5
8000a6b2:	fe c8 06 e6 	sub	r8,pc,1766
8000a6b6:	8f 0c       	st.w	r7[0x0],r12
8000a6b8:	8d a8       	st.w	r6[0x28],r8
8000a6ba:	58 04       	cp.w	r4,0
8000a6bc:	c0 80       	breq	8000a6cc <__smakebuf_r+0xb8>
8000a6be:	8e 7c       	ld.sh	r12,r7[0xe]
8000a6c0:	fe b0 e3 94 	rcall	80006de8 <isatty>
8000a6c4:	c0 40       	breq	8000a6cc <__smakebuf_r+0xb8>
8000a6c6:	8e 68       	ld.sh	r8,r7[0xc]
8000a6c8:	a1 a8       	sbr	r8,0x0
8000a6ca:	ae 68       	st.h	r7[0xc],r8
8000a6cc:	2f 1d       	sub	sp,-60
8000a6ce:	d8 22       	popm	r4-r7,pc

8000a6d0 <memchr>:
8000a6d0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a6d4:	c0 68       	rjmp	8000a6e0 <memchr+0x10>
8000a6d6:	20 1a       	sub	r10,1
8000a6d8:	19 88       	ld.ub	r8,r12[0x0]
8000a6da:	16 38       	cp.w	r8,r11
8000a6dc:	5e 0c       	reteq	r12
8000a6de:	2f fc       	sub	r12,-1
8000a6e0:	58 0a       	cp.w	r10,0
8000a6e2:	cf a1       	brne	8000a6d6 <memchr+0x6>
8000a6e4:	5e fa       	retal	r10

8000a6e6 <memmove>:
8000a6e6:	d4 01       	pushm	lr
8000a6e8:	18 3b       	cp.w	r11,r12
8000a6ea:	c1 92       	brcc	8000a71c <memmove+0x36>
8000a6ec:	f6 0a 00 09 	add	r9,r11,r10
8000a6f0:	12 3c       	cp.w	r12,r9
8000a6f2:	c1 52       	brcc	8000a71c <memmove+0x36>
8000a6f4:	f8 0a 00 0b 	add	r11,r12,r10
8000a6f8:	30 08       	mov	r8,0
8000a6fa:	c0 68       	rjmp	8000a706 <memmove+0x20>
8000a6fc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a700:	20 1a       	sub	r10,1
8000a702:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a706:	20 18       	sub	r8,1
8000a708:	58 0a       	cp.w	r10,0
8000a70a:	cf 91       	brne	8000a6fc <memmove+0x16>
8000a70c:	d8 02       	popm	pc
8000a70e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a712:	20 1a       	sub	r10,1
8000a714:	f8 08 0b 09 	st.b	r12[r8],r9
8000a718:	2f f8       	sub	r8,-1
8000a71a:	c0 28       	rjmp	8000a71e <memmove+0x38>
8000a71c:	30 08       	mov	r8,0
8000a71e:	58 0a       	cp.w	r10,0
8000a720:	cf 71       	brne	8000a70e <memmove+0x28>
8000a722:	d8 02       	popm	pc

8000a724 <__hi0bits>:
8000a724:	18 98       	mov	r8,r12
8000a726:	e0 1c 00 00 	andl	r12,0x0
8000a72a:	f0 09 15 10 	lsl	r9,r8,0x10
8000a72e:	58 0c       	cp.w	r12,0
8000a730:	f2 08 17 00 	moveq	r8,r9
8000a734:	f9 bc 00 10 	moveq	r12,16
8000a738:	f9 bc 01 00 	movne	r12,0
8000a73c:	10 9a       	mov	r10,r8
8000a73e:	f0 09 15 08 	lsl	r9,r8,0x8
8000a742:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a746:	f7 bc 00 f8 	subeq	r12,-8
8000a74a:	f2 08 17 00 	moveq	r8,r9
8000a74e:	10 9a       	mov	r10,r8
8000a750:	f0 09 15 04 	lsl	r9,r8,0x4
8000a754:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a758:	f7 bc 00 fc 	subeq	r12,-4
8000a75c:	f2 08 17 00 	moveq	r8,r9
8000a760:	10 9a       	mov	r10,r8
8000a762:	f0 09 15 02 	lsl	r9,r8,0x2
8000a766:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a76a:	f7 bc 00 fe 	subeq	r12,-2
8000a76e:	f2 08 17 00 	moveq	r8,r9
8000a772:	58 08       	cp.w	r8,0
8000a774:	5e 5c       	retlt	r12
8000a776:	ed b8 00 1e 	bld	r8,0x1e
8000a77a:	f9 bc 01 20 	movne	r12,32
8000a77e:	f7 bc 00 ff 	subeq	r12,-1
8000a782:	5e fc       	retal	r12

8000a784 <__lo0bits>:
8000a784:	18 99       	mov	r9,r12
8000a786:	78 08       	ld.w	r8,r12[0x0]
8000a788:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a78c:	c1 50       	breq	8000a7b6 <__lo0bits+0x32>
8000a78e:	ed b8 00 00 	bld	r8,0x0
8000a792:	c0 21       	brne	8000a796 <__lo0bits+0x12>
8000a794:	5e fd       	retal	0
8000a796:	10 9b       	mov	r11,r8
8000a798:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a79c:	e2 1b 00 02 	andl	r11,0x2,COH
8000a7a0:	a3 88       	lsr	r8,0x2
8000a7a2:	58 0b       	cp.w	r11,0
8000a7a4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a7a8:	f9 bc 01 01 	movne	r12,1
8000a7ac:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a7b0:	f9 bc 00 02 	moveq	r12,2
8000a7b4:	5e fc       	retal	r12
8000a7b6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a7ba:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a7be:	58 0a       	cp.w	r10,0
8000a7c0:	f6 08 17 00 	moveq	r8,r11
8000a7c4:	f9 bc 00 10 	moveq	r12,16
8000a7c8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a7cc:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a7d0:	58 0b       	cp.w	r11,0
8000a7d2:	f7 bc 00 f8 	subeq	r12,-8
8000a7d6:	f4 08 17 00 	moveq	r8,r10
8000a7da:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a7de:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a7e2:	58 0b       	cp.w	r11,0
8000a7e4:	f7 bc 00 fc 	subeq	r12,-4
8000a7e8:	f4 08 17 00 	moveq	r8,r10
8000a7ec:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a7f0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a7f4:	58 0b       	cp.w	r11,0
8000a7f6:	f7 bc 00 fe 	subeq	r12,-2
8000a7fa:	f4 08 17 00 	moveq	r8,r10
8000a7fe:	ed b8 00 00 	bld	r8,0x0
8000a802:	c0 60       	breq	8000a80e <__lo0bits+0x8a>
8000a804:	a1 98       	lsr	r8,0x1
8000a806:	c0 31       	brne	8000a80c <__lo0bits+0x88>
8000a808:	32 0c       	mov	r12,32
8000a80a:	5e fc       	retal	r12
8000a80c:	2f fc       	sub	r12,-1
8000a80e:	93 08       	st.w	r9[0x0],r8
8000a810:	5e fc       	retal	r12

8000a812 <__mcmp>:
8000a812:	d4 01       	pushm	lr
8000a814:	18 98       	mov	r8,r12
8000a816:	76 49       	ld.w	r9,r11[0x10]
8000a818:	78 4c       	ld.w	r12,r12[0x10]
8000a81a:	12 1c       	sub	r12,r9
8000a81c:	c1 31       	brne	8000a842 <__mcmp+0x30>
8000a81e:	2f b9       	sub	r9,-5
8000a820:	a3 69       	lsl	r9,0x2
8000a822:	12 0b       	add	r11,r9
8000a824:	f0 09 00 09 	add	r9,r8,r9
8000a828:	2e c8       	sub	r8,-20
8000a82a:	13 4e       	ld.w	lr,--r9
8000a82c:	17 4a       	ld.w	r10,--r11
8000a82e:	14 3e       	cp.w	lr,r10
8000a830:	c0 60       	breq	8000a83c <__mcmp+0x2a>
8000a832:	f9 bc 03 ff 	movlo	r12,-1
8000a836:	f9 bc 02 01 	movhs	r12,1
8000a83a:	d8 02       	popm	pc
8000a83c:	10 39       	cp.w	r9,r8
8000a83e:	fe 9b ff f6 	brhi	8000a82a <__mcmp+0x18>
8000a842:	d8 02       	popm	pc

8000a844 <_Bfree>:
8000a844:	d4 21       	pushm	r4-r7,lr
8000a846:	18 97       	mov	r7,r12
8000a848:	16 95       	mov	r5,r11
8000a84a:	78 96       	ld.w	r6,r12[0x24]
8000a84c:	58 06       	cp.w	r6,0
8000a84e:	c0 91       	brne	8000a860 <_Bfree+0x1c>
8000a850:	31 0c       	mov	r12,16
8000a852:	fe b0 de 3d 	rcall	800064cc <malloc>
8000a856:	99 36       	st.w	r12[0xc],r6
8000a858:	8f 9c       	st.w	r7[0x24],r12
8000a85a:	99 16       	st.w	r12[0x4],r6
8000a85c:	99 26       	st.w	r12[0x8],r6
8000a85e:	99 06       	st.w	r12[0x0],r6
8000a860:	58 05       	cp.w	r5,0
8000a862:	c0 90       	breq	8000a874 <_Bfree+0x30>
8000a864:	6a 19       	ld.w	r9,r5[0x4]
8000a866:	6e 98       	ld.w	r8,r7[0x24]
8000a868:	70 38       	ld.w	r8,r8[0xc]
8000a86a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a86e:	8b 0a       	st.w	r5[0x0],r10
8000a870:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a874:	d8 22       	popm	r4-r7,pc
8000a876:	d7 03       	nop

8000a878 <_Balloc>:
8000a878:	d4 21       	pushm	r4-r7,lr
8000a87a:	18 97       	mov	r7,r12
8000a87c:	16 96       	mov	r6,r11
8000a87e:	78 95       	ld.w	r5,r12[0x24]
8000a880:	58 05       	cp.w	r5,0
8000a882:	c0 91       	brne	8000a894 <_Balloc+0x1c>
8000a884:	31 0c       	mov	r12,16
8000a886:	fe b0 de 23 	rcall	800064cc <malloc>
8000a88a:	99 35       	st.w	r12[0xc],r5
8000a88c:	8f 9c       	st.w	r7[0x24],r12
8000a88e:	99 15       	st.w	r12[0x4],r5
8000a890:	99 25       	st.w	r12[0x8],r5
8000a892:	99 05       	st.w	r12[0x0],r5
8000a894:	6e 95       	ld.w	r5,r7[0x24]
8000a896:	6a 38       	ld.w	r8,r5[0xc]
8000a898:	58 08       	cp.w	r8,0
8000a89a:	c0 b1       	brne	8000a8b0 <_Balloc+0x38>
8000a89c:	31 0a       	mov	r10,16
8000a89e:	30 4b       	mov	r11,4
8000a8a0:	0e 9c       	mov	r12,r7
8000a8a2:	e0 a0 02 9b 	rcall	8000add8 <_calloc_r>
8000a8a6:	8b 3c       	st.w	r5[0xc],r12
8000a8a8:	6e 98       	ld.w	r8,r7[0x24]
8000a8aa:	70 3c       	ld.w	r12,r8[0xc]
8000a8ac:	58 0c       	cp.w	r12,0
8000a8ae:	c1 b0       	breq	8000a8e4 <_Balloc+0x6c>
8000a8b0:	6e 98       	ld.w	r8,r7[0x24]
8000a8b2:	70 38       	ld.w	r8,r8[0xc]
8000a8b4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a8b8:	70 0c       	ld.w	r12,r8[0x0]
8000a8ba:	58 0c       	cp.w	r12,0
8000a8bc:	c0 40       	breq	8000a8c4 <_Balloc+0x4c>
8000a8be:	78 09       	ld.w	r9,r12[0x0]
8000a8c0:	91 09       	st.w	r8[0x0],r9
8000a8c2:	c0 e8       	rjmp	8000a8de <_Balloc+0x66>
8000a8c4:	0e 9c       	mov	r12,r7
8000a8c6:	30 17       	mov	r7,1
8000a8c8:	0e 9b       	mov	r11,r7
8000a8ca:	ee 06 09 47 	lsl	r7,r7,r6
8000a8ce:	ee ca ff fb 	sub	r10,r7,-5
8000a8d2:	a3 6a       	lsl	r10,0x2
8000a8d4:	e0 a0 02 82 	rcall	8000add8 <_calloc_r>
8000a8d8:	c0 60       	breq	8000a8e4 <_Balloc+0x6c>
8000a8da:	99 16       	st.w	r12[0x4],r6
8000a8dc:	99 27       	st.w	r12[0x8],r7
8000a8de:	30 08       	mov	r8,0
8000a8e0:	99 38       	st.w	r12[0xc],r8
8000a8e2:	99 48       	st.w	r12[0x10],r8
8000a8e4:	d8 22       	popm	r4-r7,pc
8000a8e6:	d7 03       	nop

8000a8e8 <__d2b>:
8000a8e8:	d4 31       	pushm	r0-r7,lr
8000a8ea:	20 2d       	sub	sp,8
8000a8ec:	16 93       	mov	r3,r11
8000a8ee:	12 96       	mov	r6,r9
8000a8f0:	10 95       	mov	r5,r8
8000a8f2:	14 92       	mov	r2,r10
8000a8f4:	30 1b       	mov	r11,1
8000a8f6:	cc 1f       	rcall	8000a878 <_Balloc>
8000a8f8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a8fc:	50 09       	stdsp	sp[0x0],r9
8000a8fe:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a902:	b5 a9       	sbr	r9,0x14
8000a904:	f0 01 16 14 	lsr	r1,r8,0x14
8000a908:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a90c:	18 94       	mov	r4,r12
8000a90e:	58 02       	cp.w	r2,0
8000a910:	c1 d0       	breq	8000a94a <__d2b+0x62>
8000a912:	fa cc ff f8 	sub	r12,sp,-8
8000a916:	18 d2       	st.w	--r12,r2
8000a918:	c3 6f       	rcall	8000a784 <__lo0bits>
8000a91a:	40 18       	lddsp	r8,sp[0x4]
8000a91c:	c0 d0       	breq	8000a936 <__d2b+0x4e>
8000a91e:	40 09       	lddsp	r9,sp[0x0]
8000a920:	f8 0a 11 20 	rsub	r10,r12,32
8000a924:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a928:	f5 e8 10 08 	or	r8,r10,r8
8000a92c:	89 58       	st.w	r4[0x14],r8
8000a92e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a932:	50 09       	stdsp	sp[0x0],r9
8000a934:	c0 28       	rjmp	8000a938 <__d2b+0x50>
8000a936:	89 58       	st.w	r4[0x14],r8
8000a938:	40 08       	lddsp	r8,sp[0x0]
8000a93a:	58 08       	cp.w	r8,0
8000a93c:	f9 b3 01 02 	movne	r3,2
8000a940:	f9 b3 00 01 	moveq	r3,1
8000a944:	89 68       	st.w	r4[0x18],r8
8000a946:	89 43       	st.w	r4[0x10],r3
8000a948:	c0 88       	rjmp	8000a958 <__d2b+0x70>
8000a94a:	1a 9c       	mov	r12,sp
8000a94c:	c1 cf       	rcall	8000a784 <__lo0bits>
8000a94e:	30 13       	mov	r3,1
8000a950:	40 08       	lddsp	r8,sp[0x0]
8000a952:	2e 0c       	sub	r12,-32
8000a954:	89 43       	st.w	r4[0x10],r3
8000a956:	89 58       	st.w	r4[0x14],r8
8000a958:	58 01       	cp.w	r1,0
8000a95a:	c0 90       	breq	8000a96c <__d2b+0x84>
8000a95c:	e2 c1 04 33 	sub	r1,r1,1075
8000a960:	18 01       	add	r1,r12
8000a962:	8d 01       	st.w	r6[0x0],r1
8000a964:	f8 0c 11 35 	rsub	r12,r12,53
8000a968:	8b 0c       	st.w	r5[0x0],r12
8000a96a:	c0 c8       	rjmp	8000a982 <__d2b+0x9a>
8000a96c:	e6 c8 ff fc 	sub	r8,r3,-4
8000a970:	f8 cc 04 32 	sub	r12,r12,1074
8000a974:	a5 73       	lsl	r3,0x5
8000a976:	8d 0c       	st.w	r6[0x0],r12
8000a978:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a97c:	cd 4e       	rcall	8000a724 <__hi0bits>
8000a97e:	18 13       	sub	r3,r12
8000a980:	8b 03       	st.w	r5[0x0],r3
8000a982:	08 9c       	mov	r12,r4
8000a984:	2f ed       	sub	sp,-8
8000a986:	d8 32       	popm	r0-r7,pc

8000a988 <__mdiff>:
8000a988:	d4 31       	pushm	r0-r7,lr
8000a98a:	74 48       	ld.w	r8,r10[0x10]
8000a98c:	76 45       	ld.w	r5,r11[0x10]
8000a98e:	16 97       	mov	r7,r11
8000a990:	14 96       	mov	r6,r10
8000a992:	10 15       	sub	r5,r8
8000a994:	c1 31       	brne	8000a9ba <__mdiff+0x32>
8000a996:	2f b8       	sub	r8,-5
8000a998:	ee ce ff ec 	sub	lr,r7,-20
8000a99c:	a3 68       	lsl	r8,0x2
8000a99e:	f4 08 00 0b 	add	r11,r10,r8
8000a9a2:	ee 08 00 08 	add	r8,r7,r8
8000a9a6:	11 4a       	ld.w	r10,--r8
8000a9a8:	17 49       	ld.w	r9,--r11
8000a9aa:	12 3a       	cp.w	r10,r9
8000a9ac:	c0 30       	breq	8000a9b2 <__mdiff+0x2a>
8000a9ae:	c0 e2       	brcc	8000a9ca <__mdiff+0x42>
8000a9b0:	c0 78       	rjmp	8000a9be <__mdiff+0x36>
8000a9b2:	1c 38       	cp.w	r8,lr
8000a9b4:	fe 9b ff f9 	brhi	8000a9a6 <__mdiff+0x1e>
8000a9b8:	c4 98       	rjmp	8000aa4a <__mdiff+0xc2>
8000a9ba:	58 05       	cp.w	r5,0
8000a9bc:	c0 64       	brge	8000a9c8 <__mdiff+0x40>
8000a9be:	0e 98       	mov	r8,r7
8000a9c0:	30 15       	mov	r5,1
8000a9c2:	0c 97       	mov	r7,r6
8000a9c4:	10 96       	mov	r6,r8
8000a9c6:	c0 28       	rjmp	8000a9ca <__mdiff+0x42>
8000a9c8:	30 05       	mov	r5,0
8000a9ca:	6e 1b       	ld.w	r11,r7[0x4]
8000a9cc:	c5 6f       	rcall	8000a878 <_Balloc>
8000a9ce:	6e 49       	ld.w	r9,r7[0x10]
8000a9d0:	6c 44       	ld.w	r4,r6[0x10]
8000a9d2:	99 35       	st.w	r12[0xc],r5
8000a9d4:	2f b4       	sub	r4,-5
8000a9d6:	f2 c5 ff fb 	sub	r5,r9,-5
8000a9da:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a9de:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a9e2:	2e c6       	sub	r6,-20
8000a9e4:	2e c7       	sub	r7,-20
8000a9e6:	f8 c8 ff ec 	sub	r8,r12,-20
8000a9ea:	30 0a       	mov	r10,0
8000a9ec:	0f 0e       	ld.w	lr,r7++
8000a9ee:	0d 0b       	ld.w	r11,r6++
8000a9f0:	fc 02 16 10 	lsr	r2,lr,0x10
8000a9f4:	f6 03 16 10 	lsr	r3,r11,0x10
8000a9f8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a9fc:	e4 03 01 03 	sub	r3,r2,r3
8000aa00:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa04:	fc 0b 01 0b 	sub	r11,lr,r11
8000aa08:	f6 0a 00 0a 	add	r10,r11,r10
8000aa0c:	b0 1a       	st.h	r8[0x2],r10
8000aa0e:	b1 4a       	asr	r10,0x10
8000aa10:	e6 0a 00 0a 	add	r10,r3,r10
8000aa14:	b0 0a       	st.h	r8[0x0],r10
8000aa16:	2f c8       	sub	r8,-4
8000aa18:	b1 4a       	asr	r10,0x10
8000aa1a:	08 36       	cp.w	r6,r4
8000aa1c:	ce 83       	brcs	8000a9ec <__mdiff+0x64>
8000aa1e:	c0 d8       	rjmp	8000aa38 <__mdiff+0xb0>
8000aa20:	0f 0b       	ld.w	r11,r7++
8000aa22:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aa26:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa2a:	16 0a       	add	r10,r11
8000aa2c:	b0 1a       	st.h	r8[0x2],r10
8000aa2e:	b1 4a       	asr	r10,0x10
8000aa30:	1c 0a       	add	r10,lr
8000aa32:	b0 0a       	st.h	r8[0x0],r10
8000aa34:	2f c8       	sub	r8,-4
8000aa36:	b1 4a       	asr	r10,0x10
8000aa38:	0a 37       	cp.w	r7,r5
8000aa3a:	cf 33       	brcs	8000aa20 <__mdiff+0x98>
8000aa3c:	c0 28       	rjmp	8000aa40 <__mdiff+0xb8>
8000aa3e:	20 19       	sub	r9,1
8000aa40:	11 4a       	ld.w	r10,--r8
8000aa42:	58 0a       	cp.w	r10,0
8000aa44:	cf d0       	breq	8000aa3e <__mdiff+0xb6>
8000aa46:	99 49       	st.w	r12[0x10],r9
8000aa48:	d8 32       	popm	r0-r7,pc
8000aa4a:	30 0b       	mov	r11,0
8000aa4c:	c1 6f       	rcall	8000a878 <_Balloc>
8000aa4e:	30 18       	mov	r8,1
8000aa50:	99 48       	st.w	r12[0x10],r8
8000aa52:	30 08       	mov	r8,0
8000aa54:	99 58       	st.w	r12[0x14],r8
8000aa56:	d8 32       	popm	r0-r7,pc

8000aa58 <__lshift>:
8000aa58:	d4 31       	pushm	r0-r7,lr
8000aa5a:	16 97       	mov	r7,r11
8000aa5c:	76 46       	ld.w	r6,r11[0x10]
8000aa5e:	f4 02 14 05 	asr	r2,r10,0x5
8000aa62:	2f f6       	sub	r6,-1
8000aa64:	14 93       	mov	r3,r10
8000aa66:	18 94       	mov	r4,r12
8000aa68:	04 06       	add	r6,r2
8000aa6a:	76 1b       	ld.w	r11,r11[0x4]
8000aa6c:	6e 28       	ld.w	r8,r7[0x8]
8000aa6e:	c0 38       	rjmp	8000aa74 <__lshift+0x1c>
8000aa70:	2f fb       	sub	r11,-1
8000aa72:	a1 78       	lsl	r8,0x1
8000aa74:	10 36       	cp.w	r6,r8
8000aa76:	fe 99 ff fd 	brgt	8000aa70 <__lshift+0x18>
8000aa7a:	08 9c       	mov	r12,r4
8000aa7c:	cf ee       	rcall	8000a878 <_Balloc>
8000aa7e:	30 09       	mov	r9,0
8000aa80:	18 95       	mov	r5,r12
8000aa82:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa86:	12 9a       	mov	r10,r9
8000aa88:	c0 38       	rjmp	8000aa8e <__lshift+0x36>
8000aa8a:	10 aa       	st.w	r8++,r10
8000aa8c:	2f f9       	sub	r9,-1
8000aa8e:	04 39       	cp.w	r9,r2
8000aa90:	cf d5       	brlt	8000aa8a <__lshift+0x32>
8000aa92:	6e 4b       	ld.w	r11,r7[0x10]
8000aa94:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aa98:	2f bb       	sub	r11,-5
8000aa9a:	ee c9 ff ec 	sub	r9,r7,-20
8000aa9e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000aaa2:	58 03       	cp.w	r3,0
8000aaa4:	c1 30       	breq	8000aaca <__lshift+0x72>
8000aaa6:	e6 0c 11 20 	rsub	r12,r3,32
8000aaaa:	30 0a       	mov	r10,0
8000aaac:	72 02       	ld.w	r2,r9[0x0]
8000aaae:	e4 03 09 42 	lsl	r2,r2,r3
8000aab2:	04 4a       	or	r10,r2
8000aab4:	10 aa       	st.w	r8++,r10
8000aab6:	13 0a       	ld.w	r10,r9++
8000aab8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aabc:	16 39       	cp.w	r9,r11
8000aabe:	cf 73       	brcs	8000aaac <__lshift+0x54>
8000aac0:	91 0a       	st.w	r8[0x0],r10
8000aac2:	58 0a       	cp.w	r10,0
8000aac4:	c0 70       	breq	8000aad2 <__lshift+0x7a>
8000aac6:	2f f6       	sub	r6,-1
8000aac8:	c0 58       	rjmp	8000aad2 <__lshift+0x7a>
8000aaca:	13 0a       	ld.w	r10,r9++
8000aacc:	10 aa       	st.w	r8++,r10
8000aace:	16 39       	cp.w	r9,r11
8000aad0:	cf d3       	brcs	8000aaca <__lshift+0x72>
8000aad2:	08 9c       	mov	r12,r4
8000aad4:	20 16       	sub	r6,1
8000aad6:	0e 9b       	mov	r11,r7
8000aad8:	8b 46       	st.w	r5[0x10],r6
8000aada:	cb 5e       	rcall	8000a844 <_Bfree>
8000aadc:	0a 9c       	mov	r12,r5
8000aade:	d8 32       	popm	r0-r7,pc

8000aae0 <__multiply>:
8000aae0:	d4 31       	pushm	r0-r7,lr
8000aae2:	20 2d       	sub	sp,8
8000aae4:	76 49       	ld.w	r9,r11[0x10]
8000aae6:	74 48       	ld.w	r8,r10[0x10]
8000aae8:	16 96       	mov	r6,r11
8000aaea:	14 95       	mov	r5,r10
8000aaec:	10 39       	cp.w	r9,r8
8000aaee:	ec 08 17 50 	movlt	r8,r6
8000aaf2:	ea 06 17 50 	movlt	r6,r5
8000aaf6:	f0 05 17 50 	movlt	r5,r8
8000aafa:	6c 28       	ld.w	r8,r6[0x8]
8000aafc:	76 43       	ld.w	r3,r11[0x10]
8000aafe:	74 42       	ld.w	r2,r10[0x10]
8000ab00:	76 1b       	ld.w	r11,r11[0x4]
8000ab02:	e4 03 00 07 	add	r7,r2,r3
8000ab06:	10 37       	cp.w	r7,r8
8000ab08:	f7 bb 09 ff 	subgt	r11,-1
8000ab0c:	cb 6e       	rcall	8000a878 <_Balloc>
8000ab0e:	ee c4 ff fb 	sub	r4,r7,-5
8000ab12:	f8 c9 ff ec 	sub	r9,r12,-20
8000ab16:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ab1a:	30 0a       	mov	r10,0
8000ab1c:	12 98       	mov	r8,r9
8000ab1e:	c0 28       	rjmp	8000ab22 <__multiply+0x42>
8000ab20:	10 aa       	st.w	r8++,r10
8000ab22:	08 38       	cp.w	r8,r4
8000ab24:	cf e3       	brcs	8000ab20 <__multiply+0x40>
8000ab26:	2f b3       	sub	r3,-5
8000ab28:	2f b2       	sub	r2,-5
8000ab2a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ab2e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ab32:	ec cb ff ec 	sub	r11,r6,-20
8000ab36:	50 12       	stdsp	sp[0x4],r2
8000ab38:	ea ca ff ec 	sub	r10,r5,-20
8000ab3c:	c4 48       	rjmp	8000abc4 <__multiply+0xe4>
8000ab3e:	94 95       	ld.uh	r5,r10[0x2]
8000ab40:	58 05       	cp.w	r5,0
8000ab42:	c2 00       	breq	8000ab82 <__multiply+0xa2>
8000ab44:	12 98       	mov	r8,r9
8000ab46:	16 96       	mov	r6,r11
8000ab48:	30 0e       	mov	lr,0
8000ab4a:	50 09       	stdsp	sp[0x0],r9
8000ab4c:	0d 02       	ld.w	r2,r6++
8000ab4e:	e4 00 16 10 	lsr	r0,r2,0x10
8000ab52:	70 01       	ld.w	r1,r8[0x0]
8000ab54:	70 09       	ld.w	r9,r8[0x0]
8000ab56:	b1 81       	lsr	r1,0x10
8000ab58:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ab5c:	e0 05 03 41 	mac	r1,r0,r5
8000ab60:	ab 32       	mul	r2,r5
8000ab62:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ab66:	00 02       	add	r2,r0
8000ab68:	e4 0e 00 0e 	add	lr,r2,lr
8000ab6c:	b0 1e       	st.h	r8[0x2],lr
8000ab6e:	b1 8e       	lsr	lr,0x10
8000ab70:	1c 01       	add	r1,lr
8000ab72:	b0 01       	st.h	r8[0x0],r1
8000ab74:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ab78:	2f c8       	sub	r8,-4
8000ab7a:	06 36       	cp.w	r6,r3
8000ab7c:	ce 83       	brcs	8000ab4c <__multiply+0x6c>
8000ab7e:	40 09       	lddsp	r9,sp[0x0]
8000ab80:	91 0e       	st.w	r8[0x0],lr
8000ab82:	94 86       	ld.uh	r6,r10[0x0]
8000ab84:	58 06       	cp.w	r6,0
8000ab86:	c1 d0       	breq	8000abc0 <__multiply+0xe0>
8000ab88:	72 02       	ld.w	r2,r9[0x0]
8000ab8a:	12 98       	mov	r8,r9
8000ab8c:	16 9e       	mov	lr,r11
8000ab8e:	30 05       	mov	r5,0
8000ab90:	b0 12       	st.h	r8[0x2],r2
8000ab92:	1d 01       	ld.w	r1,lr++
8000ab94:	90 82       	ld.uh	r2,r8[0x0]
8000ab96:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ab9a:	ad 30       	mul	r0,r6
8000ab9c:	e0 02 00 02 	add	r2,r0,r2
8000aba0:	e4 05 00 05 	add	r5,r2,r5
8000aba4:	b0 05       	st.h	r8[0x0],r5
8000aba6:	b1 85       	lsr	r5,0x10
8000aba8:	b1 81       	lsr	r1,0x10
8000abaa:	2f c8       	sub	r8,-4
8000abac:	ad 31       	mul	r1,r6
8000abae:	90 92       	ld.uh	r2,r8[0x2]
8000abb0:	e2 02 00 02 	add	r2,r1,r2
8000abb4:	0a 02       	add	r2,r5
8000abb6:	e4 05 16 10 	lsr	r5,r2,0x10
8000abba:	06 3e       	cp.w	lr,r3
8000abbc:	ce a3       	brcs	8000ab90 <__multiply+0xb0>
8000abbe:	91 02       	st.w	r8[0x0],r2
8000abc0:	2f ca       	sub	r10,-4
8000abc2:	2f c9       	sub	r9,-4
8000abc4:	40 18       	lddsp	r8,sp[0x4]
8000abc6:	10 3a       	cp.w	r10,r8
8000abc8:	cb b3       	brcs	8000ab3e <__multiply+0x5e>
8000abca:	c0 28       	rjmp	8000abce <__multiply+0xee>
8000abcc:	20 17       	sub	r7,1
8000abce:	58 07       	cp.w	r7,0
8000abd0:	e0 8a 00 05 	brle	8000abda <__multiply+0xfa>
8000abd4:	09 48       	ld.w	r8,--r4
8000abd6:	58 08       	cp.w	r8,0
8000abd8:	cf a0       	breq	8000abcc <__multiply+0xec>
8000abda:	99 47       	st.w	r12[0x10],r7
8000abdc:	2f ed       	sub	sp,-8
8000abde:	d8 32       	popm	r0-r7,pc

8000abe0 <__i2b>:
8000abe0:	d4 21       	pushm	r4-r7,lr
8000abe2:	16 97       	mov	r7,r11
8000abe4:	30 1b       	mov	r11,1
8000abe6:	c4 9e       	rcall	8000a878 <_Balloc>
8000abe8:	30 19       	mov	r9,1
8000abea:	99 57       	st.w	r12[0x14],r7
8000abec:	99 49       	st.w	r12[0x10],r9
8000abee:	d8 22       	popm	r4-r7,pc

8000abf0 <__multadd>:
8000abf0:	d4 31       	pushm	r0-r7,lr
8000abf2:	30 08       	mov	r8,0
8000abf4:	12 95       	mov	r5,r9
8000abf6:	16 97       	mov	r7,r11
8000abf8:	18 96       	mov	r6,r12
8000abfa:	76 44       	ld.w	r4,r11[0x10]
8000abfc:	f6 c9 ff ec 	sub	r9,r11,-20
8000ac00:	72 0b       	ld.w	r11,r9[0x0]
8000ac02:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ac06:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ac0a:	f4 0c 02 4c 	mul	r12,r10,r12
8000ac0e:	f4 0b 03 45 	mac	r5,r10,r11
8000ac12:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ac16:	b1 85       	lsr	r5,0x10
8000ac18:	18 05       	add	r5,r12
8000ac1a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ac1e:	f8 0b 00 0b 	add	r11,r12,r11
8000ac22:	12 ab       	st.w	r9++,r11
8000ac24:	2f f8       	sub	r8,-1
8000ac26:	b1 85       	lsr	r5,0x10
8000ac28:	08 38       	cp.w	r8,r4
8000ac2a:	ce b5       	brlt	8000ac00 <__multadd+0x10>
8000ac2c:	58 05       	cp.w	r5,0
8000ac2e:	c1 c0       	breq	8000ac66 <__multadd+0x76>
8000ac30:	6e 28       	ld.w	r8,r7[0x8]
8000ac32:	10 34       	cp.w	r4,r8
8000ac34:	c1 35       	brlt	8000ac5a <__multadd+0x6a>
8000ac36:	6e 1b       	ld.w	r11,r7[0x4]
8000ac38:	0c 9c       	mov	r12,r6
8000ac3a:	2f fb       	sub	r11,-1
8000ac3c:	c1 ee       	rcall	8000a878 <_Balloc>
8000ac3e:	6e 4a       	ld.w	r10,r7[0x10]
8000ac40:	ee cb ff f4 	sub	r11,r7,-12
8000ac44:	18 93       	mov	r3,r12
8000ac46:	2f ea       	sub	r10,-2
8000ac48:	2f 4c       	sub	r12,-12
8000ac4a:	a3 6a       	lsl	r10,0x2
8000ac4c:	fe b0 de 64 	rcall	80006914 <memcpy>
8000ac50:	0e 9b       	mov	r11,r7
8000ac52:	0c 9c       	mov	r12,r6
8000ac54:	fe b0 fd f8 	rcall	8000a844 <_Bfree>
8000ac58:	06 97       	mov	r7,r3
8000ac5a:	e8 c8 ff ff 	sub	r8,r4,-1
8000ac5e:	2f b4       	sub	r4,-5
8000ac60:	8f 48       	st.w	r7[0x10],r8
8000ac62:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ac66:	0e 9c       	mov	r12,r7
8000ac68:	d8 32       	popm	r0-r7,pc
8000ac6a:	d7 03       	nop

8000ac6c <__pow5mult>:
8000ac6c:	d4 31       	pushm	r0-r7,lr
8000ac6e:	14 96       	mov	r6,r10
8000ac70:	18 97       	mov	r7,r12
8000ac72:	16 94       	mov	r4,r11
8000ac74:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ac78:	c0 90       	breq	8000ac8a <__pow5mult+0x1e>
8000ac7a:	20 18       	sub	r8,1
8000ac7c:	fe c9 dc 48 	sub	r9,pc,-9144
8000ac80:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ac84:	30 09       	mov	r9,0
8000ac86:	cb 5f       	rcall	8000abf0 <__multadd>
8000ac88:	18 94       	mov	r4,r12
8000ac8a:	a3 46       	asr	r6,0x2
8000ac8c:	c3 40       	breq	8000acf4 <__pow5mult+0x88>
8000ac8e:	6e 95       	ld.w	r5,r7[0x24]
8000ac90:	58 05       	cp.w	r5,0
8000ac92:	c0 91       	brne	8000aca4 <__pow5mult+0x38>
8000ac94:	31 0c       	mov	r12,16
8000ac96:	fe b0 dc 1b 	rcall	800064cc <malloc>
8000ac9a:	99 35       	st.w	r12[0xc],r5
8000ac9c:	8f 9c       	st.w	r7[0x24],r12
8000ac9e:	99 15       	st.w	r12[0x4],r5
8000aca0:	99 25       	st.w	r12[0x8],r5
8000aca2:	99 05       	st.w	r12[0x0],r5
8000aca4:	6e 93       	ld.w	r3,r7[0x24]
8000aca6:	66 25       	ld.w	r5,r3[0x8]
8000aca8:	58 05       	cp.w	r5,0
8000acaa:	c0 c1       	brne	8000acc2 <__pow5mult+0x56>
8000acac:	e0 6b 02 71 	mov	r11,625
8000acb0:	0e 9c       	mov	r12,r7
8000acb2:	c9 7f       	rcall	8000abe0 <__i2b>
8000acb4:	87 2c       	st.w	r3[0x8],r12
8000acb6:	30 08       	mov	r8,0
8000acb8:	18 95       	mov	r5,r12
8000acba:	99 08       	st.w	r12[0x0],r8
8000acbc:	c0 38       	rjmp	8000acc2 <__pow5mult+0x56>
8000acbe:	06 9c       	mov	r12,r3
8000acc0:	18 95       	mov	r5,r12
8000acc2:	ed b6 00 00 	bld	r6,0x0
8000acc6:	c0 b1       	brne	8000acdc <__pow5mult+0x70>
8000acc8:	08 9b       	mov	r11,r4
8000acca:	0a 9a       	mov	r10,r5
8000accc:	0e 9c       	mov	r12,r7
8000acce:	c0 9f       	rcall	8000aae0 <__multiply>
8000acd0:	08 9b       	mov	r11,r4
8000acd2:	18 93       	mov	r3,r12
8000acd4:	0e 9c       	mov	r12,r7
8000acd6:	06 94       	mov	r4,r3
8000acd8:	fe b0 fd b6 	rcall	8000a844 <_Bfree>
8000acdc:	a1 56       	asr	r6,0x1
8000acde:	c0 b0       	breq	8000acf4 <__pow5mult+0x88>
8000ace0:	6a 03       	ld.w	r3,r5[0x0]
8000ace2:	58 03       	cp.w	r3,0
8000ace4:	ce d1       	brne	8000acbe <__pow5mult+0x52>
8000ace6:	0a 9a       	mov	r10,r5
8000ace8:	0a 9b       	mov	r11,r5
8000acea:	0e 9c       	mov	r12,r7
8000acec:	cf ae       	rcall	8000aae0 <__multiply>
8000acee:	8b 0c       	st.w	r5[0x0],r12
8000acf0:	99 03       	st.w	r12[0x0],r3
8000acf2:	ce 7b       	rjmp	8000acc0 <__pow5mult+0x54>
8000acf4:	08 9c       	mov	r12,r4
8000acf6:	d8 32       	popm	r0-r7,pc

8000acf8 <__isinfd>:
8000acf8:	14 98       	mov	r8,r10
8000acfa:	fc 19 7f f0 	movh	r9,0x7ff0
8000acfe:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad02:	f0 0b 11 00 	rsub	r11,r8,0
8000ad06:	f7 e8 10 08 	or	r8,r11,r8
8000ad0a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ad0e:	f2 08 01 08 	sub	r8,r9,r8
8000ad12:	f0 0c 11 00 	rsub	r12,r8,0
8000ad16:	f9 e8 10 08 	or	r8,r12,r8
8000ad1a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ad1e:	2f fc       	sub	r12,-1
8000ad20:	5e fc       	retal	r12

8000ad22 <__isnand>:
8000ad22:	14 98       	mov	r8,r10
8000ad24:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad28:	f0 0c 11 00 	rsub	r12,r8,0
8000ad2c:	10 4c       	or	r12,r8
8000ad2e:	fc 18 7f f0 	movh	r8,0x7ff0
8000ad32:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ad36:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad3a:	bf 9c       	lsr	r12,0x1f
8000ad3c:	5e fc       	retal	r12
8000ad3e:	d7 03       	nop

8000ad40 <__sclose>:
8000ad40:	d4 01       	pushm	lr
8000ad42:	96 7b       	ld.sh	r11,r11[0xe]
8000ad44:	c7 6c       	rcall	8000ae30 <_close_r>
8000ad46:	d8 02       	popm	pc

8000ad48 <__sseek>:
8000ad48:	d4 21       	pushm	r4-r7,lr
8000ad4a:	16 97       	mov	r7,r11
8000ad4c:	96 7b       	ld.sh	r11,r11[0xe]
8000ad4e:	cf 7c       	rcall	8000af3c <_lseek_r>
8000ad50:	8e 68       	ld.sh	r8,r7[0xc]
8000ad52:	10 99       	mov	r9,r8
8000ad54:	ad c8       	cbr	r8,0xc
8000ad56:	ad a9       	sbr	r9,0xc
8000ad58:	5b fc       	cp.w	r12,-1
8000ad5a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ad5e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ad62:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ad66:	d8 22       	popm	r4-r7,pc

8000ad68 <__swrite>:
8000ad68:	d4 21       	pushm	r4-r7,lr
8000ad6a:	96 68       	ld.sh	r8,r11[0xc]
8000ad6c:	16 97       	mov	r7,r11
8000ad6e:	14 95       	mov	r5,r10
8000ad70:	12 94       	mov	r4,r9
8000ad72:	e2 18 01 00 	andl	r8,0x100,COH
8000ad76:	18 96       	mov	r6,r12
8000ad78:	c0 50       	breq	8000ad82 <__swrite+0x1a>
8000ad7a:	30 29       	mov	r9,2
8000ad7c:	30 0a       	mov	r10,0
8000ad7e:	96 7b       	ld.sh	r11,r11[0xe]
8000ad80:	cd ec       	rcall	8000af3c <_lseek_r>
8000ad82:	8e 68       	ld.sh	r8,r7[0xc]
8000ad84:	ad c8       	cbr	r8,0xc
8000ad86:	08 99       	mov	r9,r4
8000ad88:	0a 9a       	mov	r10,r5
8000ad8a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ad8c:	0c 9c       	mov	r12,r6
8000ad8e:	ae 68       	st.h	r7[0xc],r8
8000ad90:	c1 0c       	rcall	8000adb0 <_write_r>
8000ad92:	d8 22       	popm	r4-r7,pc

8000ad94 <__sread>:
8000ad94:	d4 21       	pushm	r4-r7,lr
8000ad96:	16 97       	mov	r7,r11
8000ad98:	96 7b       	ld.sh	r11,r11[0xe]
8000ad9a:	ce 5c       	rcall	8000af64 <_read_r>
8000ad9c:	c0 65       	brlt	8000ada8 <__sread+0x14>
8000ad9e:	6f 58       	ld.w	r8,r7[0x54]
8000ada0:	18 08       	add	r8,r12
8000ada2:	ef 48 00 54 	st.w	r7[84],r8
8000ada6:	d8 22       	popm	r4-r7,pc
8000ada8:	8e 68       	ld.sh	r8,r7[0xc]
8000adaa:	ad c8       	cbr	r8,0xc
8000adac:	ae 68       	st.h	r7[0xc],r8
8000adae:	d8 22       	popm	r4-r7,pc

8000adb0 <_write_r>:
8000adb0:	d4 21       	pushm	r4-r7,lr
8000adb2:	16 98       	mov	r8,r11
8000adb4:	18 97       	mov	r7,r12
8000adb6:	10 9c       	mov	r12,r8
8000adb8:	30 08       	mov	r8,0
8000adba:	14 9b       	mov	r11,r10
8000adbc:	e0 66 41 00 	mov	r6,16640
8000adc0:	12 9a       	mov	r10,r9
8000adc2:	8d 08       	st.w	r6[0x0],r8
8000adc4:	fe b0 d1 54 	rcall	8000506c <_write>
8000adc8:	5b fc       	cp.w	r12,-1
8000adca:	c0 51       	brne	8000add4 <_write_r+0x24>
8000adcc:	6c 08       	ld.w	r8,r6[0x0]
8000adce:	58 08       	cp.w	r8,0
8000add0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000add4:	d8 22       	popm	r4-r7,pc
8000add6:	d7 03       	nop

8000add8 <_calloc_r>:
8000add8:	d4 21       	pushm	r4-r7,lr
8000adda:	f4 0b 02 4b 	mul	r11,r10,r11
8000adde:	fe b0 db 7f 	rcall	800064dc <_malloc_r>
8000ade2:	18 97       	mov	r7,r12
8000ade4:	c2 30       	breq	8000ae2a <_calloc_r+0x52>
8000ade6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000adea:	e0 1a ff fc 	andl	r10,0xfffc
8000adee:	20 4a       	sub	r10,4
8000adf0:	e0 4a 00 24 	cp.w	r10,36
8000adf4:	e0 8b 00 18 	brhi	8000ae24 <_calloc_r+0x4c>
8000adf8:	18 98       	mov	r8,r12
8000adfa:	59 3a       	cp.w	r10,19
8000adfc:	e0 88 00 0f 	brls	8000ae1a <_calloc_r+0x42>
8000ae00:	30 09       	mov	r9,0
8000ae02:	10 a9       	st.w	r8++,r9
8000ae04:	10 a9       	st.w	r8++,r9
8000ae06:	59 ba       	cp.w	r10,27
8000ae08:	e0 88 00 09 	brls	8000ae1a <_calloc_r+0x42>
8000ae0c:	10 a9       	st.w	r8++,r9
8000ae0e:	10 a9       	st.w	r8++,r9
8000ae10:	e0 4a 00 24 	cp.w	r10,36
8000ae14:	c0 31       	brne	8000ae1a <_calloc_r+0x42>
8000ae16:	10 a9       	st.w	r8++,r9
8000ae18:	10 a9       	st.w	r8++,r9
8000ae1a:	30 09       	mov	r9,0
8000ae1c:	10 a9       	st.w	r8++,r9
8000ae1e:	91 19       	st.w	r8[0x4],r9
8000ae20:	91 09       	st.w	r8[0x0],r9
8000ae22:	c0 48       	rjmp	8000ae2a <_calloc_r+0x52>
8000ae24:	30 0b       	mov	r11,0
8000ae26:	fe b0 de 1b 	rcall	80006a5c <memset>
8000ae2a:	0e 9c       	mov	r12,r7
8000ae2c:	d8 22       	popm	r4-r7,pc
8000ae2e:	d7 03       	nop

8000ae30 <_close_r>:
8000ae30:	d4 21       	pushm	r4-r7,lr
8000ae32:	30 08       	mov	r8,0
8000ae34:	18 97       	mov	r7,r12
8000ae36:	e0 66 41 00 	mov	r6,16640
8000ae3a:	16 9c       	mov	r12,r11
8000ae3c:	8d 08       	st.w	r6[0x0],r8
8000ae3e:	fe b0 df c1 	rcall	80006dc0 <_close>
8000ae42:	5b fc       	cp.w	r12,-1
8000ae44:	c0 51       	brne	8000ae4e <_close_r+0x1e>
8000ae46:	6c 08       	ld.w	r8,r6[0x0]
8000ae48:	58 08       	cp.w	r8,0
8000ae4a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae4e:	d8 22       	popm	r4-r7,pc

8000ae50 <_fclose_r>:
8000ae50:	d4 21       	pushm	r4-r7,lr
8000ae52:	18 96       	mov	r6,r12
8000ae54:	16 97       	mov	r7,r11
8000ae56:	58 0b       	cp.w	r11,0
8000ae58:	c0 31       	brne	8000ae5e <_fclose_r+0xe>
8000ae5a:	16 95       	mov	r5,r11
8000ae5c:	c5 38       	rjmp	8000af02 <_fclose_r+0xb2>
8000ae5e:	fe b0 f8 b5 	rcall	80009fc8 <__sfp_lock_acquire>
8000ae62:	58 06       	cp.w	r6,0
8000ae64:	c0 70       	breq	8000ae72 <_fclose_r+0x22>
8000ae66:	6c 68       	ld.w	r8,r6[0x18]
8000ae68:	58 08       	cp.w	r8,0
8000ae6a:	c0 41       	brne	8000ae72 <_fclose_r+0x22>
8000ae6c:	0c 9c       	mov	r12,r6
8000ae6e:	fe b0 f8 ff 	rcall	8000a06c <__sinit>
8000ae72:	fe c8 de e2 	sub	r8,pc,-8478
8000ae76:	10 37       	cp.w	r7,r8
8000ae78:	c0 31       	brne	8000ae7e <_fclose_r+0x2e>
8000ae7a:	6c 07       	ld.w	r7,r6[0x0]
8000ae7c:	c0 c8       	rjmp	8000ae94 <_fclose_r+0x44>
8000ae7e:	fe c8 de ce 	sub	r8,pc,-8498
8000ae82:	10 37       	cp.w	r7,r8
8000ae84:	c0 31       	brne	8000ae8a <_fclose_r+0x3a>
8000ae86:	6c 17       	ld.w	r7,r6[0x4]
8000ae88:	c0 68       	rjmp	8000ae94 <_fclose_r+0x44>
8000ae8a:	fe c8 de ba 	sub	r8,pc,-8518
8000ae8e:	10 37       	cp.w	r7,r8
8000ae90:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae94:	8e 69       	ld.sh	r9,r7[0xc]
8000ae96:	30 08       	mov	r8,0
8000ae98:	f0 09 19 00 	cp.h	r9,r8
8000ae9c:	c0 51       	brne	8000aea6 <_fclose_r+0x56>
8000ae9e:	fe b0 f8 96 	rcall	80009fca <__sfp_lock_release>
8000aea2:	30 05       	mov	r5,0
8000aea4:	c2 f8       	rjmp	8000af02 <_fclose_r+0xb2>
8000aea6:	0e 9b       	mov	r11,r7
8000aea8:	0c 9c       	mov	r12,r6
8000aeaa:	fe b0 f8 09 	rcall	80009ebc <_fflush_r>
8000aeae:	6e c8       	ld.w	r8,r7[0x30]
8000aeb0:	18 95       	mov	r5,r12
8000aeb2:	58 08       	cp.w	r8,0
8000aeb4:	c0 60       	breq	8000aec0 <_fclose_r+0x70>
8000aeb6:	6e 8b       	ld.w	r11,r7[0x20]
8000aeb8:	0c 9c       	mov	r12,r6
8000aeba:	5d 18       	icall	r8
8000aebc:	f9 b5 05 ff 	movlt	r5,-1
8000aec0:	8e 68       	ld.sh	r8,r7[0xc]
8000aec2:	ed b8 00 07 	bld	r8,0x7
8000aec6:	c0 51       	brne	8000aed0 <_fclose_r+0x80>
8000aec8:	6e 4b       	ld.w	r11,r7[0x10]
8000aeca:	0c 9c       	mov	r12,r6
8000aecc:	fe b0 f9 6a 	rcall	8000a1a0 <_free_r>
8000aed0:	6e db       	ld.w	r11,r7[0x34]
8000aed2:	58 0b       	cp.w	r11,0
8000aed4:	c0 a0       	breq	8000aee8 <_fclose_r+0x98>
8000aed6:	ee c8 ff bc 	sub	r8,r7,-68
8000aeda:	10 3b       	cp.w	r11,r8
8000aedc:	c0 40       	breq	8000aee4 <_fclose_r+0x94>
8000aede:	0c 9c       	mov	r12,r6
8000aee0:	fe b0 f9 60 	rcall	8000a1a0 <_free_r>
8000aee4:	30 08       	mov	r8,0
8000aee6:	8f d8       	st.w	r7[0x34],r8
8000aee8:	6f 2b       	ld.w	r11,r7[0x48]
8000aeea:	58 0b       	cp.w	r11,0
8000aeec:	c0 70       	breq	8000aefa <_fclose_r+0xaa>
8000aeee:	0c 9c       	mov	r12,r6
8000aef0:	fe b0 f9 58 	rcall	8000a1a0 <_free_r>
8000aef4:	30 08       	mov	r8,0
8000aef6:	ef 48 00 48 	st.w	r7[72],r8
8000aefa:	30 08       	mov	r8,0
8000aefc:	ae 68       	st.h	r7[0xc],r8
8000aefe:	fe b0 f8 66 	rcall	80009fca <__sfp_lock_release>
8000af02:	0a 9c       	mov	r12,r5
8000af04:	d8 22       	popm	r4-r7,pc
8000af06:	d7 03       	nop

8000af08 <fclose>:
8000af08:	d4 01       	pushm	lr
8000af0a:	e0 68 0a 44 	mov	r8,2628
8000af0e:	18 9b       	mov	r11,r12
8000af10:	70 0c       	ld.w	r12,r8[0x0]
8000af12:	c9 ff       	rcall	8000ae50 <_fclose_r>
8000af14:	d8 02       	popm	pc
8000af16:	d7 03       	nop

8000af18 <_fstat_r>:
8000af18:	d4 21       	pushm	r4-r7,lr
8000af1a:	16 98       	mov	r8,r11
8000af1c:	18 97       	mov	r7,r12
8000af1e:	10 9c       	mov	r12,r8
8000af20:	30 08       	mov	r8,0
8000af22:	e0 66 41 00 	mov	r6,16640
8000af26:	14 9b       	mov	r11,r10
8000af28:	8d 08       	st.w	r6[0x0],r8
8000af2a:	fe b0 df 73 	rcall	80006e10 <_fstat>
8000af2e:	5b fc       	cp.w	r12,-1
8000af30:	c0 51       	brne	8000af3a <_fstat_r+0x22>
8000af32:	6c 08       	ld.w	r8,r6[0x0]
8000af34:	58 08       	cp.w	r8,0
8000af36:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af3a:	d8 22       	popm	r4-r7,pc

8000af3c <_lseek_r>:
8000af3c:	d4 21       	pushm	r4-r7,lr
8000af3e:	16 98       	mov	r8,r11
8000af40:	18 97       	mov	r7,r12
8000af42:	10 9c       	mov	r12,r8
8000af44:	30 08       	mov	r8,0
8000af46:	14 9b       	mov	r11,r10
8000af48:	e0 66 41 00 	mov	r6,16640
8000af4c:	12 9a       	mov	r10,r9
8000af4e:	8d 08       	st.w	r6[0x0],r8
8000af50:	fe b0 df 42 	rcall	80006dd4 <_lseek>
8000af54:	5b fc       	cp.w	r12,-1
8000af56:	c0 51       	brne	8000af60 <_lseek_r+0x24>
8000af58:	6c 08       	ld.w	r8,r6[0x0]
8000af5a:	58 08       	cp.w	r8,0
8000af5c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af60:	d8 22       	popm	r4-r7,pc
8000af62:	d7 03       	nop

8000af64 <_read_r>:
8000af64:	d4 21       	pushm	r4-r7,lr
8000af66:	16 98       	mov	r8,r11
8000af68:	18 97       	mov	r7,r12
8000af6a:	10 9c       	mov	r12,r8
8000af6c:	30 08       	mov	r8,0
8000af6e:	14 9b       	mov	r11,r10
8000af70:	e0 66 41 00 	mov	r6,16640
8000af74:	12 9a       	mov	r10,r9
8000af76:	8d 08       	st.w	r6[0x0],r8
8000af78:	fe b0 d0 5a 	rcall	8000502c <_read>
8000af7c:	5b fc       	cp.w	r12,-1
8000af7e:	c0 51       	brne	8000af88 <_read_r+0x24>
8000af80:	6c 08       	ld.w	r8,r6[0x0]
8000af82:	58 08       	cp.w	r8,0
8000af84:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af88:	d8 22       	popm	r4-r7,pc
8000af8a:	d7 03       	nop

8000af8c <__avr32_f64_mul>:
8000af8c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000af90:	e0 80 00 dc 	breq	8000b148 <__avr32_f64_mul_op1_zero>
8000af94:	d4 21       	pushm	r4-r7,lr
8000af96:	f7 e9 20 0e 	eor	lr,r11,r9
8000af9a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000af9e:	30 15       	mov	r5,1
8000afa0:	c4 30       	breq	8000b026 <__avr32_f64_mul_op1_subnormal>
8000afa2:	ab 6b       	lsl	r11,0xa
8000afa4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000afa8:	ab 6a       	lsl	r10,0xa
8000afaa:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000afae:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000afb2:	c5 c0       	breq	8000b06a <__avr32_f64_mul_op2_subnormal>
8000afb4:	a1 78       	lsl	r8,0x1
8000afb6:	5c f9       	rol	r9
8000afb8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000afbc:	e0 47 07 ff 	cp.w	r7,2047
8000afc0:	c7 70       	breq	8000b0ae <__avr32_f64_mul_op_nan_or_inf>
8000afc2:	e0 46 07 ff 	cp.w	r6,2047
8000afc6:	c7 40       	breq	8000b0ae <__avr32_f64_mul_op_nan_or_inf>
8000afc8:	ee 06 00 0c 	add	r12,r7,r6
8000afcc:	e0 2c 03 fe 	sub	r12,1022
8000afd0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000afd4:	f4 09 07 44 	macu.d	r4,r10,r9
8000afd8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000afdc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000afe0:	08 07       	add	r7,r4
8000afe2:	f4 05 00 4a 	adc	r10,r10,r5
8000afe6:	5c 0b       	acr	r11
8000afe8:	ed bb 00 14 	bld	r11,0x14
8000afec:	c0 50       	breq	8000aff6 <__avr32_f64_mul+0x6a>
8000afee:	a1 77       	lsl	r7,0x1
8000aff0:	5c fa       	rol	r10
8000aff2:	5c fb       	rol	r11
8000aff4:	20 1c       	sub	r12,1
8000aff6:	58 0c       	cp.w	r12,0
8000aff8:	e0 8a 00 6f 	brle	8000b0d6 <__avr32_f64_mul_res_subnormal>
8000affc:	e0 4c 07 ff 	cp.w	r12,2047
8000b000:	e0 84 00 9c 	brge	8000b138 <__avr32_f64_mul_res_inf>
8000b004:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b008:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b00c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b010:	ee 17 80 00 	eorh	r7,0x8000
8000b014:	f1 b7 04 20 	satu	r7,0x1
8000b018:	0e 0a       	add	r10,r7
8000b01a:	5c 0b       	acr	r11
8000b01c:	ed be 00 1f 	bld	lr,0x1f
8000b020:	ef bb 00 1f 	bst	r11,0x1f
8000b024:	d8 22       	popm	r4-r7,pc

8000b026 <__avr32_f64_mul_op1_subnormal>:
8000b026:	e4 1b 00 0f 	andh	r11,0xf
8000b02a:	f4 0c 12 00 	clz	r12,r10
8000b02e:	f6 06 12 00 	clz	r6,r11
8000b032:	f7 bc 03 e1 	sublo	r12,-31
8000b036:	f8 06 17 30 	movlo	r6,r12
8000b03a:	f7 b6 02 01 	subhs	r6,1
8000b03e:	e0 46 00 20 	cp.w	r6,32
8000b042:	c0 d4       	brge	8000b05c <__avr32_f64_mul_op1_subnormal+0x36>
8000b044:	ec 0c 11 20 	rsub	r12,r6,32
8000b048:	f6 06 09 4b 	lsl	r11,r11,r6
8000b04c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b050:	18 4b       	or	r11,r12
8000b052:	f4 06 09 4a 	lsl	r10,r10,r6
8000b056:	20 b6       	sub	r6,11
8000b058:	0c 17       	sub	r7,r6
8000b05a:	ca ab       	rjmp	8000afae <__avr32_f64_mul+0x22>
8000b05c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b060:	c6 40       	breq	8000b128 <__avr32_f64_mul_res_zero>
8000b062:	30 0a       	mov	r10,0
8000b064:	20 b6       	sub	r6,11
8000b066:	0c 17       	sub	r7,r6
8000b068:	ca 3b       	rjmp	8000afae <__avr32_f64_mul+0x22>

8000b06a <__avr32_f64_mul_op2_subnormal>:
8000b06a:	e4 19 00 0f 	andh	r9,0xf
8000b06e:	f0 0c 12 00 	clz	r12,r8
8000b072:	f2 05 12 00 	clz	r5,r9
8000b076:	f7 bc 03 ea 	sublo	r12,-22
8000b07a:	f8 05 17 30 	movlo	r5,r12
8000b07e:	f7 b5 02 0a 	subhs	r5,10
8000b082:	e0 45 00 20 	cp.w	r5,32
8000b086:	c0 d4       	brge	8000b0a0 <__avr32_f64_mul_op2_subnormal+0x36>
8000b088:	ea 0c 11 20 	rsub	r12,r5,32
8000b08c:	f2 05 09 49 	lsl	r9,r9,r5
8000b090:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b094:	18 49       	or	r9,r12
8000b096:	f0 05 09 48 	lsl	r8,r8,r5
8000b09a:	20 25       	sub	r5,2
8000b09c:	0a 16       	sub	r6,r5
8000b09e:	c8 fb       	rjmp	8000afbc <__avr32_f64_mul+0x30>
8000b0a0:	f0 05 09 49 	lsl	r9,r8,r5
8000b0a4:	c4 20       	breq	8000b128 <__avr32_f64_mul_res_zero>
8000b0a6:	30 08       	mov	r8,0
8000b0a8:	20 25       	sub	r5,2
8000b0aa:	0a 16       	sub	r6,r5
8000b0ac:	c8 8b       	rjmp	8000afbc <__avr32_f64_mul+0x30>

8000b0ae <__avr32_f64_mul_op_nan_or_inf>:
8000b0ae:	e4 19 00 0f 	andh	r9,0xf
8000b0b2:	e4 1b 00 0f 	andh	r11,0xf
8000b0b6:	14 4b       	or	r11,r10
8000b0b8:	10 49       	or	r9,r8
8000b0ba:	e0 47 07 ff 	cp.w	r7,2047
8000b0be:	c0 91       	brne	8000b0d0 <__avr32_f64_mul_op1_not_naninf>
8000b0c0:	58 0b       	cp.w	r11,0
8000b0c2:	c3 81       	brne	8000b132 <__avr32_f64_mul_res_nan>
8000b0c4:	e0 46 07 ff 	cp.w	r6,2047
8000b0c8:	c3 81       	brne	8000b138 <__avr32_f64_mul_res_inf>
8000b0ca:	58 09       	cp.w	r9,0
8000b0cc:	c3 60       	breq	8000b138 <__avr32_f64_mul_res_inf>
8000b0ce:	c3 28       	rjmp	8000b132 <__avr32_f64_mul_res_nan>

8000b0d0 <__avr32_f64_mul_op1_not_naninf>:
8000b0d0:	58 09       	cp.w	r9,0
8000b0d2:	c3 30       	breq	8000b138 <__avr32_f64_mul_res_inf>
8000b0d4:	c2 f8       	rjmp	8000b132 <__avr32_f64_mul_res_nan>

8000b0d6 <__avr32_f64_mul_res_subnormal>:
8000b0d6:	5c 3c       	neg	r12
8000b0d8:	2f fc       	sub	r12,-1
8000b0da:	f1 bc 04 c0 	satu	r12,0x6
8000b0de:	e0 4c 00 20 	cp.w	r12,32
8000b0e2:	c1 14       	brge	8000b104 <__avr32_f64_mul_res_subnormal+0x2e>
8000b0e4:	f8 08 11 20 	rsub	r8,r12,32
8000b0e8:	0e 46       	or	r6,r7
8000b0ea:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b0ee:	f4 08 09 49 	lsl	r9,r10,r8
8000b0f2:	12 47       	or	r7,r9
8000b0f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b0f8:	f6 08 09 49 	lsl	r9,r11,r8
8000b0fc:	12 4a       	or	r10,r9
8000b0fe:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b102:	c8 3b       	rjmp	8000b008 <__avr32_f64_mul+0x7c>
8000b104:	f8 08 11 20 	rsub	r8,r12,32
8000b108:	f9 b9 00 00 	moveq	r9,0
8000b10c:	c0 30       	breq	8000b112 <__avr32_f64_mul_res_subnormal+0x3c>
8000b10e:	f6 08 09 49 	lsl	r9,r11,r8
8000b112:	0e 46       	or	r6,r7
8000b114:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b118:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b11c:	f3 ea 10 07 	or	r7,r9,r10
8000b120:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b124:	30 0b       	mov	r11,0
8000b126:	c7 1b       	rjmp	8000b008 <__avr32_f64_mul+0x7c>

8000b128 <__avr32_f64_mul_res_zero>:
8000b128:	1c 9b       	mov	r11,lr
8000b12a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b12e:	30 0a       	mov	r10,0
8000b130:	d8 22       	popm	r4-r7,pc

8000b132 <__avr32_f64_mul_res_nan>:
8000b132:	3f fb       	mov	r11,-1
8000b134:	3f fa       	mov	r10,-1
8000b136:	d8 22       	popm	r4-r7,pc

8000b138 <__avr32_f64_mul_res_inf>:
8000b138:	f0 6b 00 00 	mov	r11,-1048576
8000b13c:	ed be 00 1f 	bld	lr,0x1f
8000b140:	ef bb 00 1f 	bst	r11,0x1f
8000b144:	30 0a       	mov	r10,0
8000b146:	d8 22       	popm	r4-r7,pc

8000b148 <__avr32_f64_mul_op1_zero>:
8000b148:	f7 e9 20 0b 	eor	r11,r11,r9
8000b14c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b150:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b154:	e0 4c 07 ff 	cp.w	r12,2047
8000b158:	5e 1c       	retne	r12
8000b15a:	3f fa       	mov	r10,-1
8000b15c:	3f fb       	mov	r11,-1
8000b15e:	5e fc       	retal	r12

8000b160 <__avr32_f64_sub_from_add>:
8000b160:	ee 19 80 00 	eorh	r9,0x8000

8000b164 <__avr32_f64_sub>:
8000b164:	f7 e9 20 0c 	eor	r12,r11,r9
8000b168:	e0 86 00 ca 	brmi	8000b2fc <__avr32_f64_add_from_sub>
8000b16c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b170:	16 9c       	mov	r12,r11
8000b172:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b176:	bf db       	cbr	r11,0x1f
8000b178:	bf d9       	cbr	r9,0x1f
8000b17a:	10 3a       	cp.w	r10,r8
8000b17c:	f2 0b 13 00 	cpc	r11,r9
8000b180:	c0 92       	brcc	8000b192 <__avr32_f64_sub+0x2e>
8000b182:	16 97       	mov	r7,r11
8000b184:	12 9b       	mov	r11,r9
8000b186:	0e 99       	mov	r9,r7
8000b188:	14 97       	mov	r7,r10
8000b18a:	10 9a       	mov	r10,r8
8000b18c:	0e 98       	mov	r8,r7
8000b18e:	ee 1c 80 00 	eorh	r12,0x8000
8000b192:	f6 07 16 14 	lsr	r7,r11,0x14
8000b196:	ab 7b       	lsl	r11,0xb
8000b198:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b19c:	ab 7a       	lsl	r10,0xb
8000b19e:	bf bb       	sbr	r11,0x1f
8000b1a0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1a4:	c4 40       	breq	8000b22c <__avr32_f64_sub_opL_subnormal>
8000b1a6:	ab 79       	lsl	r9,0xb
8000b1a8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b1ac:	ab 78       	lsl	r8,0xb
8000b1ae:	bf b9       	sbr	r9,0x1f

8000b1b0 <__avr32_f64_sub_opL_subnormal_done>:
8000b1b0:	e0 47 07 ff 	cp.w	r7,2047
8000b1b4:	c4 f0       	breq	8000b252 <__avr32_f64_sub_opH_nan_or_inf>
8000b1b6:	0e 26       	rsub	r6,r7
8000b1b8:	c1 20       	breq	8000b1dc <__avr32_f64_sub_shift_done>
8000b1ba:	ec 05 11 20 	rsub	r5,r6,32
8000b1be:	e0 46 00 20 	cp.w	r6,32
8000b1c2:	c7 c2       	brcc	8000b2ba <__avr32_f64_sub_longshift>
8000b1c4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b1c8:	f2 05 09 45 	lsl	r5,r9,r5
8000b1cc:	f0 06 0a 48 	lsr	r8,r8,r6
8000b1d0:	f2 06 0a 49 	lsr	r9,r9,r6
8000b1d4:	0a 48       	or	r8,r5
8000b1d6:	58 0e       	cp.w	lr,0
8000b1d8:	5f 1e       	srne	lr
8000b1da:	1c 48       	or	r8,lr

8000b1dc <__avr32_f64_sub_shift_done>:
8000b1dc:	10 1a       	sub	r10,r8
8000b1de:	f6 09 01 4b 	sbc	r11,r11,r9
8000b1e2:	f6 06 12 00 	clz	r6,r11
8000b1e6:	c0 e0       	breq	8000b202 <__avr32_f64_sub_longnormalize_done>
8000b1e8:	c7 83       	brcs	8000b2d8 <__avr32_f64_sub_longnormalize>
8000b1ea:	ec 0e 11 20 	rsub	lr,r6,32
8000b1ee:	f6 06 09 4b 	lsl	r11,r11,r6
8000b1f2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b1f6:	1c 4b       	or	r11,lr
8000b1f8:	f4 06 09 4a 	lsl	r10,r10,r6
8000b1fc:	0c 17       	sub	r7,r6
8000b1fe:	e0 8a 00 39 	brle	8000b270 <__avr32_f64_sub_subnormal_result>

8000b202 <__avr32_f64_sub_longnormalize_done>:
8000b202:	f4 09 15 15 	lsl	r9,r10,0x15
8000b206:	ab 9a       	lsr	r10,0xb
8000b208:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b20c:	ab 9b       	lsr	r11,0xb
8000b20e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b212:	18 4b       	or	r11,r12

8000b214 <__avr32_f64_sub_round>:
8000b214:	fc 17 80 00 	movh	r7,0x8000
8000b218:	ed ba 00 00 	bld	r10,0x0
8000b21c:	f7 b7 01 ff 	subne	r7,-1
8000b220:	0e 39       	cp.w	r9,r7
8000b222:	5f 29       	srhs	r9
8000b224:	12 0a       	add	r10,r9
8000b226:	5c 0b       	acr	r11
8000b228:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b22c <__avr32_f64_sub_opL_subnormal>:
8000b22c:	ab 79       	lsl	r9,0xb
8000b22e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b232:	ab 78       	lsl	r8,0xb
8000b234:	f3 e8 10 0e 	or	lr,r9,r8
8000b238:	f9 b6 01 01 	movne	r6,1
8000b23c:	ee 0e 11 00 	rsub	lr,r7,0
8000b240:	f9 b7 00 01 	moveq	r7,1
8000b244:	ef bb 00 1f 	bst	r11,0x1f
8000b248:	f7 ea 10 0e 	or	lr,r11,r10
8000b24c:	f9 b7 00 00 	moveq	r7,0
8000b250:	cb 0b       	rjmp	8000b1b0 <__avr32_f64_sub_opL_subnormal_done>

8000b252 <__avr32_f64_sub_opH_nan_or_inf>:
8000b252:	bf db       	cbr	r11,0x1f
8000b254:	f7 ea 10 0e 	or	lr,r11,r10
8000b258:	c0 81       	brne	8000b268 <__avr32_f64_sub_return_nan>
8000b25a:	e0 46 07 ff 	cp.w	r6,2047
8000b25e:	c0 50       	breq	8000b268 <__avr32_f64_sub_return_nan>
8000b260:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b264:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b268 <__avr32_f64_sub_return_nan>:
8000b268:	3f fa       	mov	r10,-1
8000b26a:	3f fb       	mov	r11,-1
8000b26c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b270 <__avr32_f64_sub_subnormal_result>:
8000b270:	5c 37       	neg	r7
8000b272:	2f f7       	sub	r7,-1
8000b274:	f1 b7 04 c0 	satu	r7,0x6
8000b278:	e0 47 00 20 	cp.w	r7,32
8000b27c:	c1 14       	brge	8000b29e <__avr32_f64_sub_subnormal_result+0x2e>
8000b27e:	ee 08 11 20 	rsub	r8,r7,32
8000b282:	f4 08 09 49 	lsl	r9,r10,r8
8000b286:	5f 16       	srne	r6
8000b288:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b28c:	0c 4a       	or	r10,r6
8000b28e:	f6 08 09 49 	lsl	r9,r11,r8
8000b292:	f5 e9 10 0a 	or	r10,r10,r9
8000b296:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b29a:	30 07       	mov	r7,0
8000b29c:	cb 3b       	rjmp	8000b202 <__avr32_f64_sub_longnormalize_done>
8000b29e:	ee 08 11 40 	rsub	r8,r7,64
8000b2a2:	f6 08 09 49 	lsl	r9,r11,r8
8000b2a6:	14 49       	or	r9,r10
8000b2a8:	5f 16       	srne	r6
8000b2aa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b2ae:	0c 4a       	or	r10,r6
8000b2b0:	30 0b       	mov	r11,0
8000b2b2:	30 07       	mov	r7,0
8000b2b4:	ca 7b       	rjmp	8000b202 <__avr32_f64_sub_longnormalize_done>
8000b2b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2ba <__avr32_f64_sub_longshift>:
8000b2ba:	f1 b6 04 c0 	satu	r6,0x6
8000b2be:	f0 0e 17 00 	moveq	lr,r8
8000b2c2:	c0 40       	breq	8000b2ca <__avr32_f64_sub_longshift+0x10>
8000b2c4:	f2 05 09 4e 	lsl	lr,r9,r5
8000b2c8:	10 4e       	or	lr,r8
8000b2ca:	f2 06 0a 48 	lsr	r8,r9,r6
8000b2ce:	30 09       	mov	r9,0
8000b2d0:	58 0e       	cp.w	lr,0
8000b2d2:	5f 1e       	srne	lr
8000b2d4:	1c 48       	or	r8,lr
8000b2d6:	c8 3b       	rjmp	8000b1dc <__avr32_f64_sub_shift_done>

8000b2d8 <__avr32_f64_sub_longnormalize>:
8000b2d8:	f4 06 12 00 	clz	r6,r10
8000b2dc:	f9 b7 03 00 	movlo	r7,0
8000b2e0:	f9 b6 03 00 	movlo	r6,0
8000b2e4:	f9 bc 03 00 	movlo	r12,0
8000b2e8:	f7 b6 02 e0 	subhs	r6,-32
8000b2ec:	f4 06 09 4b 	lsl	r11,r10,r6
8000b2f0:	30 0a       	mov	r10,0
8000b2f2:	0c 17       	sub	r7,r6
8000b2f4:	fe 9a ff be 	brle	8000b270 <__avr32_f64_sub_subnormal_result>
8000b2f8:	c8 5b       	rjmp	8000b202 <__avr32_f64_sub_longnormalize_done>
8000b2fa:	d7 03       	nop

8000b2fc <__avr32_f64_add_from_sub>:
8000b2fc:	ee 19 80 00 	eorh	r9,0x8000

8000b300 <__avr32_f64_add>:
8000b300:	f7 e9 20 0c 	eor	r12,r11,r9
8000b304:	fe 96 ff 2e 	brmi	8000b160 <__avr32_f64_sub_from_add>
8000b308:	eb cd 40 e0 	pushm	r5-r7,lr
8000b30c:	16 9c       	mov	r12,r11
8000b30e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b312:	bf db       	cbr	r11,0x1f
8000b314:	bf d9       	cbr	r9,0x1f
8000b316:	12 3b       	cp.w	r11,r9
8000b318:	c0 72       	brcc	8000b326 <__avr32_f64_add+0x26>
8000b31a:	16 97       	mov	r7,r11
8000b31c:	12 9b       	mov	r11,r9
8000b31e:	0e 99       	mov	r9,r7
8000b320:	14 97       	mov	r7,r10
8000b322:	10 9a       	mov	r10,r8
8000b324:	0e 98       	mov	r8,r7
8000b326:	30 0e       	mov	lr,0
8000b328:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b32c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b330:	b5 ab       	sbr	r11,0x14
8000b332:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b336:	c6 20       	breq	8000b3fa <__avr32_f64_add_op2_subnormal>
8000b338:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b33c:	b5 a9       	sbr	r9,0x14
8000b33e:	e0 47 07 ff 	cp.w	r7,2047
8000b342:	c2 80       	breq	8000b392 <__avr32_f64_add_opH_nan_or_inf>
8000b344:	0e 26       	rsub	r6,r7
8000b346:	c1 20       	breq	8000b36a <__avr32_f64_add_shift_done>
8000b348:	e0 46 00 36 	cp.w	r6,54
8000b34c:	c1 52       	brcc	8000b376 <__avr32_f64_add_res_of_done>
8000b34e:	ec 05 11 20 	rsub	r5,r6,32
8000b352:	e0 46 00 20 	cp.w	r6,32
8000b356:	c3 52       	brcc	8000b3c0 <__avr32_f64_add_longshift>
8000b358:	f0 05 09 4e 	lsl	lr,r8,r5
8000b35c:	f2 05 09 45 	lsl	r5,r9,r5
8000b360:	f0 06 0a 48 	lsr	r8,r8,r6
8000b364:	f2 06 0a 49 	lsr	r9,r9,r6
8000b368:	0a 48       	or	r8,r5

8000b36a <__avr32_f64_add_shift_done>:
8000b36a:	10 0a       	add	r10,r8
8000b36c:	f6 09 00 4b 	adc	r11,r11,r9
8000b370:	ed bb 00 15 	bld	r11,0x15
8000b374:	c3 40       	breq	8000b3dc <__avr32_f64_add_res_of>

8000b376 <__avr32_f64_add_res_of_done>:
8000b376:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b37a:	18 4b       	or	r11,r12

8000b37c <__avr32_f64_add_round>:
8000b37c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b380:	18 4e       	or	lr,r12
8000b382:	ee 1e 80 00 	eorh	lr,0x8000
8000b386:	f1 be 04 20 	satu	lr,0x1
8000b38a:	1c 0a       	add	r10,lr
8000b38c:	5c 0b       	acr	r11
8000b38e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b392 <__avr32_f64_add_opH_nan_or_inf>:
8000b392:	b5 cb       	cbr	r11,0x14
8000b394:	f7 ea 10 0e 	or	lr,r11,r10
8000b398:	c1 01       	brne	8000b3b8 <__avr32_f64_add_return_nan>
8000b39a:	e0 46 07 ff 	cp.w	r6,2047
8000b39e:	c0 30       	breq	8000b3a4 <__avr32_f64_add_opL_nan_or_inf>
8000b3a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3a4 <__avr32_f64_add_opL_nan_or_inf>:
8000b3a4:	b5 c9       	cbr	r9,0x14
8000b3a6:	f3 e8 10 0e 	or	lr,r9,r8
8000b3aa:	c0 71       	brne	8000b3b8 <__avr32_f64_add_return_nan>
8000b3ac:	30 0a       	mov	r10,0
8000b3ae:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b3b2:	18 4b       	or	r11,r12
8000b3b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3b8 <__avr32_f64_add_return_nan>:
8000b3b8:	3f fa       	mov	r10,-1
8000b3ba:	3f fb       	mov	r11,-1
8000b3bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3c0 <__avr32_f64_add_longshift>:
8000b3c0:	f1 b6 04 c0 	satu	r6,0x6
8000b3c4:	f0 0e 17 00 	moveq	lr,r8
8000b3c8:	c0 60       	breq	8000b3d4 <__avr32_f64_add_longshift+0x14>
8000b3ca:	f2 05 09 4e 	lsl	lr,r9,r5
8000b3ce:	58 08       	cp.w	r8,0
8000b3d0:	5f 18       	srne	r8
8000b3d2:	10 4e       	or	lr,r8
8000b3d4:	f2 06 0a 48 	lsr	r8,r9,r6
8000b3d8:	30 09       	mov	r9,0
8000b3da:	cc 8b       	rjmp	8000b36a <__avr32_f64_add_shift_done>

8000b3dc <__avr32_f64_add_res_of>:
8000b3dc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b3e0:	a1 9b       	lsr	r11,0x1
8000b3e2:	5d 0a       	ror	r10
8000b3e4:	5d 0e       	ror	lr
8000b3e6:	2f f7       	sub	r7,-1
8000b3e8:	e0 47 07 ff 	cp.w	r7,2047
8000b3ec:	f9 ba 00 00 	moveq	r10,0
8000b3f0:	f9 bb 00 00 	moveq	r11,0
8000b3f4:	f9 be 00 00 	moveq	lr,0
8000b3f8:	cb fb       	rjmp	8000b376 <__avr32_f64_add_res_of_done>

8000b3fa <__avr32_f64_add_op2_subnormal>:
8000b3fa:	30 16       	mov	r6,1
8000b3fc:	58 07       	cp.w	r7,0
8000b3fe:	ca 01       	brne	8000b33e <__avr32_f64_add+0x3e>
8000b400:	b5 cb       	cbr	r11,0x14
8000b402:	10 0a       	add	r10,r8
8000b404:	f6 09 00 4b 	adc	r11,r11,r9
8000b408:	18 4b       	or	r11,r12
8000b40a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b40e:	d7 03       	nop

8000b410 <__avr32_f64_to_u32>:
8000b410:	58 0b       	cp.w	r11,0
8000b412:	5e 6d       	retmi	0

8000b414 <__avr32_f64_to_s32>:
8000b414:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b418:	b5 9c       	lsr	r12,0x15
8000b41a:	e0 2c 03 ff 	sub	r12,1023
8000b41e:	5e 3d       	retlo	0
8000b420:	f8 0c 11 1f 	rsub	r12,r12,31
8000b424:	16 99       	mov	r9,r11
8000b426:	ab 7b       	lsl	r11,0xb
8000b428:	bf bb       	sbr	r11,0x1f
8000b42a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b42e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b432:	a1 79       	lsl	r9,0x1
8000b434:	5e 2b       	reths	r11
8000b436:	5c 3b       	neg	r11
8000b438:	5e fb       	retal	r11

8000b43a <__avr32_u32_to_f64>:
8000b43a:	f8 cb 00 00 	sub	r11,r12,0
8000b43e:	30 0c       	mov	r12,0
8000b440:	c0 38       	rjmp	8000b446 <__avr32_s32_to_f64+0x4>

8000b442 <__avr32_s32_to_f64>:
8000b442:	18 9b       	mov	r11,r12
8000b444:	5c 4b       	abs	r11
8000b446:	30 0a       	mov	r10,0
8000b448:	5e 0b       	reteq	r11
8000b44a:	d4 01       	pushm	lr
8000b44c:	e0 69 04 1e 	mov	r9,1054
8000b450:	f6 08 12 00 	clz	r8,r11
8000b454:	c1 70       	breq	8000b482 <__avr32_s32_to_f64+0x40>
8000b456:	c0 c3       	brcs	8000b46e <__avr32_s32_to_f64+0x2c>
8000b458:	f0 0e 11 20 	rsub	lr,r8,32
8000b45c:	f6 08 09 4b 	lsl	r11,r11,r8
8000b460:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b464:	1c 4b       	or	r11,lr
8000b466:	f4 08 09 4a 	lsl	r10,r10,r8
8000b46a:	10 19       	sub	r9,r8
8000b46c:	c0 b8       	rjmp	8000b482 <__avr32_s32_to_f64+0x40>
8000b46e:	f4 08 12 00 	clz	r8,r10
8000b472:	f9 b8 03 00 	movlo	r8,0
8000b476:	f7 b8 02 e0 	subhs	r8,-32
8000b47a:	f4 08 09 4b 	lsl	r11,r10,r8
8000b47e:	30 0a       	mov	r10,0
8000b480:	10 19       	sub	r9,r8
8000b482:	58 09       	cp.w	r9,0
8000b484:	e0 89 00 30 	brgt	8000b4e4 <__avr32_s32_to_f64+0xa2>
8000b488:	5c 39       	neg	r9
8000b48a:	2f f9       	sub	r9,-1
8000b48c:	e0 49 00 36 	cp.w	r9,54
8000b490:	c0 43       	brcs	8000b498 <__avr32_s32_to_f64+0x56>
8000b492:	30 0b       	mov	r11,0
8000b494:	30 0a       	mov	r10,0
8000b496:	c2 68       	rjmp	8000b4e2 <__avr32_s32_to_f64+0xa0>
8000b498:	2f 69       	sub	r9,-10
8000b49a:	f2 08 11 20 	rsub	r8,r9,32
8000b49e:	e0 49 00 20 	cp.w	r9,32
8000b4a2:	c0 b2       	brcc	8000b4b8 <__avr32_s32_to_f64+0x76>
8000b4a4:	f4 08 09 4e 	lsl	lr,r10,r8
8000b4a8:	f6 08 09 48 	lsl	r8,r11,r8
8000b4ac:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4b0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b4b4:	10 4b       	or	r11,r8
8000b4b6:	c0 88       	rjmp	8000b4c6 <__avr32_s32_to_f64+0x84>
8000b4b8:	f6 08 09 4e 	lsl	lr,r11,r8
8000b4bc:	14 4e       	or	lr,r10
8000b4be:	16 9a       	mov	r10,r11
8000b4c0:	30 0b       	mov	r11,0
8000b4c2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4c6:	ed ba 00 00 	bld	r10,0x0
8000b4ca:	c0 92       	brcc	8000b4dc <__avr32_s32_to_f64+0x9a>
8000b4cc:	1c 7e       	tst	lr,lr
8000b4ce:	c0 41       	brne	8000b4d6 <__avr32_s32_to_f64+0x94>
8000b4d0:	ed ba 00 01 	bld	r10,0x1
8000b4d4:	c0 42       	brcc	8000b4dc <__avr32_s32_to_f64+0x9a>
8000b4d6:	2f fa       	sub	r10,-1
8000b4d8:	f7 bb 02 ff 	subhs	r11,-1
8000b4dc:	5c fc       	rol	r12
8000b4de:	5d 0b       	ror	r11
8000b4e0:	5d 0a       	ror	r10
8000b4e2:	d8 02       	popm	pc
8000b4e4:	e0 68 03 ff 	mov	r8,1023
8000b4e8:	ed ba 00 0b 	bld	r10,0xb
8000b4ec:	f7 b8 00 ff 	subeq	r8,-1
8000b4f0:	10 0a       	add	r10,r8
8000b4f2:	5c 0b       	acr	r11
8000b4f4:	f7 b9 03 fe 	sublo	r9,-2
8000b4f8:	e0 49 07 ff 	cp.w	r9,2047
8000b4fc:	c0 55       	brlt	8000b506 <__avr32_s32_to_f64+0xc4>
8000b4fe:	30 0a       	mov	r10,0
8000b500:	fc 1b ff e0 	movh	r11,0xffe0
8000b504:	c0 c8       	rjmp	8000b51c <__floatsidf_return_op1>
8000b506:	ed bb 00 1f 	bld	r11,0x1f
8000b50a:	f7 b9 01 01 	subne	r9,1
8000b50e:	ab 9a       	lsr	r10,0xb
8000b510:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b514:	a1 7b       	lsl	r11,0x1
8000b516:	ab 9b       	lsr	r11,0xb
8000b518:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b51c <__floatsidf_return_op1>:
8000b51c:	a1 7c       	lsl	r12,0x1
8000b51e:	5d 0b       	ror	r11
8000b520:	d8 02       	popm	pc

8000b522 <__avr32_f64_cmp_eq>:
8000b522:	10 3a       	cp.w	r10,r8
8000b524:	f2 0b 13 00 	cpc	r11,r9
8000b528:	c0 80       	breq	8000b538 <__avr32_f64_cmp_eq+0x16>
8000b52a:	a1 7b       	lsl	r11,0x1
8000b52c:	a1 79       	lsl	r9,0x1
8000b52e:	14 4b       	or	r11,r10
8000b530:	12 4b       	or	r11,r9
8000b532:	10 4b       	or	r11,r8
8000b534:	5e 0f       	reteq	1
8000b536:	5e fd       	retal	0
8000b538:	a1 7b       	lsl	r11,0x1
8000b53a:	fc 1c ff e0 	movh	r12,0xffe0
8000b53e:	58 0a       	cp.w	r10,0
8000b540:	f8 0b 13 00 	cpc	r11,r12
8000b544:	5e 8f       	retls	1
8000b546:	5e fd       	retal	0

8000b548 <__avr32_f64_cmp_ge>:
8000b548:	1a de       	st.w	--sp,lr
8000b54a:	1a d7       	st.w	--sp,r7
8000b54c:	a1 7b       	lsl	r11,0x1
8000b54e:	5f 3c       	srlo	r12
8000b550:	a1 79       	lsl	r9,0x1
8000b552:	5f 37       	srlo	r7
8000b554:	5c fc       	rol	r12
8000b556:	fc 1e ff e0 	movh	lr,0xffe0
8000b55a:	58 0a       	cp.w	r10,0
8000b55c:	fc 0b 13 00 	cpc	r11,lr
8000b560:	e0 8b 00 1d 	brhi	8000b59a <__avr32_f64_cmp_ge+0x52>
8000b564:	58 08       	cp.w	r8,0
8000b566:	fc 09 13 00 	cpc	r9,lr
8000b56a:	e0 8b 00 18 	brhi	8000b59a <__avr32_f64_cmp_ge+0x52>
8000b56e:	58 0b       	cp.w	r11,0
8000b570:	f5 ba 00 00 	subfeq	r10,0
8000b574:	c1 50       	breq	8000b59e <__avr32_f64_cmp_ge+0x56>
8000b576:	1b 07       	ld.w	r7,sp++
8000b578:	1b 0e       	ld.w	lr,sp++
8000b57a:	58 3c       	cp.w	r12,3
8000b57c:	c0 a0       	breq	8000b590 <__avr32_f64_cmp_ge+0x48>
8000b57e:	58 1c       	cp.w	r12,1
8000b580:	c0 33       	brcs	8000b586 <__avr32_f64_cmp_ge+0x3e>
8000b582:	5e 0f       	reteq	1
8000b584:	5e 1d       	retne	0
8000b586:	10 3a       	cp.w	r10,r8
8000b588:	f2 0b 13 00 	cpc	r11,r9
8000b58c:	5e 2f       	reths	1
8000b58e:	5e 3d       	retlo	0
8000b590:	14 38       	cp.w	r8,r10
8000b592:	f6 09 13 00 	cpc	r9,r11
8000b596:	5e 2f       	reths	1
8000b598:	5e 3d       	retlo	0
8000b59a:	1b 07       	ld.w	r7,sp++
8000b59c:	d8 0a       	popm	pc,r12=0
8000b59e:	58 17       	cp.w	r7,1
8000b5a0:	5f 0c       	sreq	r12
8000b5a2:	58 09       	cp.w	r9,0
8000b5a4:	f5 b8 00 00 	subfeq	r8,0
8000b5a8:	1b 07       	ld.w	r7,sp++
8000b5aa:	1b 0e       	ld.w	lr,sp++
8000b5ac:	5e 0f       	reteq	1
8000b5ae:	5e fc       	retal	r12

8000b5b0 <__avr32_f64_cmp_lt>:
8000b5b0:	1a de       	st.w	--sp,lr
8000b5b2:	1a d7       	st.w	--sp,r7
8000b5b4:	a1 7b       	lsl	r11,0x1
8000b5b6:	5f 3c       	srlo	r12
8000b5b8:	a1 79       	lsl	r9,0x1
8000b5ba:	5f 37       	srlo	r7
8000b5bc:	5c fc       	rol	r12
8000b5be:	fc 1e ff e0 	movh	lr,0xffe0
8000b5c2:	58 0a       	cp.w	r10,0
8000b5c4:	fc 0b 13 00 	cpc	r11,lr
8000b5c8:	e0 8b 00 1d 	brhi	8000b602 <__avr32_f64_cmp_lt+0x52>
8000b5cc:	58 08       	cp.w	r8,0
8000b5ce:	fc 09 13 00 	cpc	r9,lr
8000b5d2:	e0 8b 00 18 	brhi	8000b602 <__avr32_f64_cmp_lt+0x52>
8000b5d6:	58 0b       	cp.w	r11,0
8000b5d8:	f5 ba 00 00 	subfeq	r10,0
8000b5dc:	c1 50       	breq	8000b606 <__avr32_f64_cmp_lt+0x56>
8000b5de:	1b 07       	ld.w	r7,sp++
8000b5e0:	1b 0e       	ld.w	lr,sp++
8000b5e2:	58 3c       	cp.w	r12,3
8000b5e4:	c0 a0       	breq	8000b5f8 <__avr32_f64_cmp_lt+0x48>
8000b5e6:	58 1c       	cp.w	r12,1
8000b5e8:	c0 33       	brcs	8000b5ee <__avr32_f64_cmp_lt+0x3e>
8000b5ea:	5e 0d       	reteq	0
8000b5ec:	5e 1f       	retne	1
8000b5ee:	10 3a       	cp.w	r10,r8
8000b5f0:	f2 0b 13 00 	cpc	r11,r9
8000b5f4:	5e 2d       	reths	0
8000b5f6:	5e 3f       	retlo	1
8000b5f8:	14 38       	cp.w	r8,r10
8000b5fa:	f6 09 13 00 	cpc	r9,r11
8000b5fe:	5e 2d       	reths	0
8000b600:	5e 3f       	retlo	1
8000b602:	1b 07       	ld.w	r7,sp++
8000b604:	d8 0a       	popm	pc,r12=0
8000b606:	58 17       	cp.w	r7,1
8000b608:	5f 1c       	srne	r12
8000b60a:	58 09       	cp.w	r9,0
8000b60c:	f5 b8 00 00 	subfeq	r8,0
8000b610:	1b 07       	ld.w	r7,sp++
8000b612:	1b 0e       	ld.w	lr,sp++
8000b614:	5e 0d       	reteq	0
8000b616:	5e fc       	retal	r12

8000b618 <__avr32_f64_div>:
8000b618:	eb cd 40 ff 	pushm	r0-r7,lr
8000b61c:	f7 e9 20 0e 	eor	lr,r11,r9
8000b620:	f6 07 16 14 	lsr	r7,r11,0x14
8000b624:	a9 7b       	lsl	r11,0x9
8000b626:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b62a:	a9 7a       	lsl	r10,0x9
8000b62c:	bd bb       	sbr	r11,0x1d
8000b62e:	e4 1b 3f ff 	andh	r11,0x3fff
8000b632:	ab d7       	cbr	r7,0xb
8000b634:	e0 80 00 cc 	breq	8000b7cc <__avr32_f64_div_round_subnormal+0x54>
8000b638:	e0 47 07 ff 	cp.w	r7,2047
8000b63c:	e0 84 00 b5 	brge	8000b7a6 <__avr32_f64_div_round_subnormal+0x2e>
8000b640:	f2 06 16 14 	lsr	r6,r9,0x14
8000b644:	a9 79       	lsl	r9,0x9
8000b646:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b64a:	a9 78       	lsl	r8,0x9
8000b64c:	bd b9       	sbr	r9,0x1d
8000b64e:	e4 19 3f ff 	andh	r9,0x3fff
8000b652:	ab d6       	cbr	r6,0xb
8000b654:	e0 80 00 e2 	breq	8000b818 <__avr32_f64_div_round_subnormal+0xa0>
8000b658:	e0 46 07 ff 	cp.w	r6,2047
8000b65c:	e0 84 00 b2 	brge	8000b7c0 <__avr32_f64_div_round_subnormal+0x48>
8000b660:	0c 17       	sub	r7,r6
8000b662:	fe 37 fc 01 	sub	r7,-1023
8000b666:	fc 1c 80 00 	movh	r12,0x8000
8000b66a:	f8 03 16 01 	lsr	r3,r12,0x1
8000b66e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b672:	5c d4       	com	r4
8000b674:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b678:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b67c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b680:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b684:	ea 03 15 02 	lsl	r3,r5,0x2
8000b688:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b68c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b690:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b694:	ea 03 15 02 	lsl	r3,r5,0x2
8000b698:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b69c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6a4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6a8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b6ac:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6b0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6b4:	02 04       	add	r4,r1
8000b6b6:	5c 05       	acr	r5
8000b6b8:	a3 65       	lsl	r5,0x2
8000b6ba:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b6be:	a3 64       	lsl	r4,0x2
8000b6c0:	5c 34       	neg	r4
8000b6c2:	f8 05 01 45 	sbc	r5,r12,r5
8000b6c6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b6ca:	e4 05 07 40 	macu.d	r0,r2,r5
8000b6ce:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6d2:	02 04       	add	r4,r1
8000b6d4:	5c 05       	acr	r5
8000b6d6:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6da:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b6de:	e8 02 15 02 	lsl	r2,r4,0x2
8000b6e2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b6e6:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6ea:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6ee:	02 04       	add	r4,r1
8000b6f0:	5c 05       	acr	r5
8000b6f2:	a3 65       	lsl	r5,0x2
8000b6f4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b6f8:	a3 64       	lsl	r4,0x2
8000b6fa:	5c 34       	neg	r4
8000b6fc:	f8 05 01 45 	sbc	r5,r12,r5
8000b700:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b704:	e4 05 07 40 	macu.d	r0,r2,r5
8000b708:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b70c:	02 04       	add	r4,r1
8000b70e:	5c 05       	acr	r5
8000b710:	ea 03 15 02 	lsl	r3,r5,0x2
8000b714:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b718:	e8 02 15 02 	lsl	r2,r4,0x2
8000b71c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b720:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b724:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b728:	02 02       	add	r2,r1
8000b72a:	5c 03       	acr	r3
8000b72c:	ed b3 00 1c 	bld	r3,0x1c
8000b730:	c0 90       	breq	8000b742 <__avr32_f64_div+0x12a>
8000b732:	a1 72       	lsl	r2,0x1
8000b734:	5c f3       	rol	r3
8000b736:	20 17       	sub	r7,1
8000b738:	a3 9a       	lsr	r10,0x3
8000b73a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b73e:	a3 9b       	lsr	r11,0x3
8000b740:	c0 58       	rjmp	8000b74a <__avr32_f64_div+0x132>
8000b742:	a5 8a       	lsr	r10,0x4
8000b744:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b748:	a5 8b       	lsr	r11,0x4
8000b74a:	58 07       	cp.w	r7,0
8000b74c:	e0 8a 00 8b 	brle	8000b862 <__avr32_f64_div_res_subnormal>
8000b750:	e0 12 ff 00 	andl	r2,0xff00
8000b754:	e8 12 00 80 	orl	r2,0x80
8000b758:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b75c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b760:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b764:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b768:	00 05       	add	r5,r0
8000b76a:	f0 01 00 48 	adc	r8,r8,r1
8000b76e:	5c 09       	acr	r9
8000b770:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b774:	58 04       	cp.w	r4,0
8000b776:	5c 25       	cpc	r5

8000b778 <__avr32_f64_div_round_subnormal>:
8000b778:	f4 08 13 00 	cpc	r8,r10
8000b77c:	f6 09 13 00 	cpc	r9,r11
8000b780:	5f 36       	srlo	r6
8000b782:	f8 06 17 00 	moveq	r6,r12
8000b786:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b78a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b78e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b792:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b796:	ed be 00 1f 	bld	lr,0x1f
8000b79a:	ef bb 00 1f 	bst	r11,0x1f
8000b79e:	0c 0a       	add	r10,r6
8000b7a0:	5c 0b       	acr	r11
8000b7a2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b7a6:	e4 1b 00 0f 	andh	r11,0xf
8000b7aa:	14 4b       	or	r11,r10
8000b7ac:	e0 81 00 a7 	brne	8000b8fa <__avr32_f64_div_res_subnormal+0x98>
8000b7b0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b7b4:	ab d6       	cbr	r6,0xb
8000b7b6:	e0 46 07 ff 	cp.w	r6,2047
8000b7ba:	e0 81 00 a4 	brne	8000b902 <__avr32_f64_div_res_subnormal+0xa0>
8000b7be:	c9 e8       	rjmp	8000b8fa <__avr32_f64_div_res_subnormal+0x98>
8000b7c0:	e4 19 00 0f 	andh	r9,0xf
8000b7c4:	10 49       	or	r9,r8
8000b7c6:	e0 81 00 9a 	brne	8000b8fa <__avr32_f64_div_res_subnormal+0x98>
8000b7ca:	c9 28       	rjmp	8000b8ee <__avr32_f64_div_res_subnormal+0x8c>
8000b7cc:	a3 7b       	lsl	r11,0x3
8000b7ce:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b7d2:	a3 7a       	lsl	r10,0x3
8000b7d4:	f5 eb 10 04 	or	r4,r10,r11
8000b7d8:	e0 80 00 a0 	breq	8000b918 <__avr32_f64_div_op1_zero>
8000b7dc:	f6 04 12 00 	clz	r4,r11
8000b7e0:	c1 70       	breq	8000b80e <__avr32_f64_div_round_subnormal+0x96>
8000b7e2:	c0 c3       	brcs	8000b7fa <__avr32_f64_div_round_subnormal+0x82>
8000b7e4:	e8 05 11 20 	rsub	r5,r4,32
8000b7e8:	f6 04 09 4b 	lsl	r11,r11,r4
8000b7ec:	f4 05 0a 45 	lsr	r5,r10,r5
8000b7f0:	0a 4b       	or	r11,r5
8000b7f2:	f4 04 09 4a 	lsl	r10,r10,r4
8000b7f6:	08 17       	sub	r7,r4
8000b7f8:	c0 b8       	rjmp	8000b80e <__avr32_f64_div_round_subnormal+0x96>
8000b7fa:	f4 04 12 00 	clz	r4,r10
8000b7fe:	f9 b4 03 00 	movlo	r4,0
8000b802:	f7 b4 02 e0 	subhs	r4,-32
8000b806:	f4 04 09 4b 	lsl	r11,r10,r4
8000b80a:	30 0a       	mov	r10,0
8000b80c:	08 17       	sub	r7,r4
8000b80e:	a3 8a       	lsr	r10,0x2
8000b810:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b814:	a3 8b       	lsr	r11,0x2
8000b816:	c1 1b       	rjmp	8000b638 <__avr32_f64_div+0x20>
8000b818:	a3 79       	lsl	r9,0x3
8000b81a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b81e:	a3 78       	lsl	r8,0x3
8000b820:	f3 e8 10 04 	or	r4,r9,r8
8000b824:	c6 f0       	breq	8000b902 <__avr32_f64_div_res_subnormal+0xa0>
8000b826:	f2 04 12 00 	clz	r4,r9
8000b82a:	c1 70       	breq	8000b858 <__avr32_f64_div_round_subnormal+0xe0>
8000b82c:	c0 c3       	brcs	8000b844 <__avr32_f64_div_round_subnormal+0xcc>
8000b82e:	e8 05 11 20 	rsub	r5,r4,32
8000b832:	f2 04 09 49 	lsl	r9,r9,r4
8000b836:	f0 05 0a 45 	lsr	r5,r8,r5
8000b83a:	0a 49       	or	r9,r5
8000b83c:	f0 04 09 48 	lsl	r8,r8,r4
8000b840:	08 16       	sub	r6,r4
8000b842:	c0 b8       	rjmp	8000b858 <__avr32_f64_div_round_subnormal+0xe0>
8000b844:	f0 04 12 00 	clz	r4,r8
8000b848:	f9 b4 03 00 	movlo	r4,0
8000b84c:	f7 b4 02 e0 	subhs	r4,-32
8000b850:	f0 04 09 49 	lsl	r9,r8,r4
8000b854:	30 08       	mov	r8,0
8000b856:	08 16       	sub	r6,r4
8000b858:	a3 88       	lsr	r8,0x2
8000b85a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b85e:	a3 89       	lsr	r9,0x2
8000b860:	cf ca       	rjmp	8000b658 <__avr32_f64_div+0x40>

8000b862 <__avr32_f64_div_res_subnormal>:
8000b862:	5c 37       	neg	r7
8000b864:	2f f7       	sub	r7,-1
8000b866:	f1 b7 04 c0 	satu	r7,0x6
8000b86a:	e0 47 00 20 	cp.w	r7,32
8000b86e:	c1 54       	brge	8000b898 <__avr32_f64_div_res_subnormal+0x36>
8000b870:	ee 06 11 20 	rsub	r6,r7,32
8000b874:	e4 07 0a 42 	lsr	r2,r2,r7
8000b878:	e6 06 09 4c 	lsl	r12,r3,r6
8000b87c:	18 42       	or	r2,r12
8000b87e:	e6 07 0a 43 	lsr	r3,r3,r7
8000b882:	f4 06 09 41 	lsl	r1,r10,r6
8000b886:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b88a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b88e:	18 4a       	or	r10,r12
8000b890:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b894:	30 00       	mov	r0,0
8000b896:	c1 58       	rjmp	8000b8c0 <__avr32_f64_div_res_subnormal+0x5e>
8000b898:	ee 06 11 20 	rsub	r6,r7,32
8000b89c:	f9 b0 00 00 	moveq	r0,0
8000b8a0:	f9 bc 00 00 	moveq	r12,0
8000b8a4:	c0 50       	breq	8000b8ae <__avr32_f64_div_res_subnormal+0x4c>
8000b8a6:	f4 06 09 40 	lsl	r0,r10,r6
8000b8aa:	f6 06 09 4c 	lsl	r12,r11,r6
8000b8ae:	e6 07 0a 42 	lsr	r2,r3,r7
8000b8b2:	30 03       	mov	r3,0
8000b8b4:	f4 07 0a 41 	lsr	r1,r10,r7
8000b8b8:	18 41       	or	r1,r12
8000b8ba:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b8be:	30 0b       	mov	r11,0
8000b8c0:	e0 12 ff 00 	andl	r2,0xff00
8000b8c4:	e8 12 00 80 	orl	r2,0x80
8000b8c8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b8cc:	e4 09 07 46 	macu.d	r6,r2,r9
8000b8d0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b8d4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b8d8:	0c 05       	add	r5,r6
8000b8da:	f0 07 00 48 	adc	r8,r8,r7
8000b8de:	5c 09       	acr	r9
8000b8e0:	30 07       	mov	r7,0
8000b8e2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b8e6:	00 34       	cp.w	r4,r0
8000b8e8:	e2 05 13 00 	cpc	r5,r1
8000b8ec:	c4 6b       	rjmp	8000b778 <__avr32_f64_div_round_subnormal>
8000b8ee:	1c 9b       	mov	r11,lr
8000b8f0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b8f4:	30 0a       	mov	r10,0
8000b8f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b8fa:	3f fb       	mov	r11,-1
8000b8fc:	30 0a       	mov	r10,0
8000b8fe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b902:	f5 eb 10 04 	or	r4,r10,r11
8000b906:	c0 90       	breq	8000b918 <__avr32_f64_div_op1_zero>
8000b908:	1c 9b       	mov	r11,lr
8000b90a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b90e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b912:	30 0a       	mov	r10,0
8000b914:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b918 <__avr32_f64_div_op1_zero>:
8000b918:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b91c:	ce f0       	breq	8000b8fa <__avr32_f64_div_res_subnormal+0x98>
8000b91e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b922:	e0 44 07 ff 	cp.w	r4,2047
8000b926:	ce 41       	brne	8000b8ee <__avr32_f64_div_res_subnormal+0x8c>
8000b928:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b92c:	ce 10       	breq	8000b8ee <__avr32_f64_div_res_subnormal+0x8c>
8000b92e:	ce 6b       	rjmp	8000b8fa <__avr32_f64_div_res_subnormal+0x98>

8000b930 <__avr32_udiv64>:
8000b930:	d4 31       	pushm	r0-r7,lr
8000b932:	1a 97       	mov	r7,sp
8000b934:	20 3d       	sub	sp,12
8000b936:	10 9c       	mov	r12,r8
8000b938:	12 9e       	mov	lr,r9
8000b93a:	14 93       	mov	r3,r10
8000b93c:	58 09       	cp.w	r9,0
8000b93e:	e0 81 00 bd 	brne	8000bab8 <__avr32_udiv64+0x188>
8000b942:	16 38       	cp.w	r8,r11
8000b944:	e0 88 00 40 	brls	8000b9c4 <__avr32_udiv64+0x94>
8000b948:	f0 08 12 00 	clz	r8,r8
8000b94c:	c0 d0       	breq	8000b966 <__avr32_udiv64+0x36>
8000b94e:	f6 08 09 4b 	lsl	r11,r11,r8
8000b952:	f0 09 11 20 	rsub	r9,r8,32
8000b956:	f8 08 09 4c 	lsl	r12,r12,r8
8000b95a:	f4 09 0a 49 	lsr	r9,r10,r9
8000b95e:	f4 08 09 43 	lsl	r3,r10,r8
8000b962:	f3 eb 10 0b 	or	r11,r9,r11
8000b966:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b96a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b96e:	f6 0e 0d 00 	divu	r0,r11,lr
8000b972:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b976:	00 99       	mov	r9,r0
8000b978:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b97c:	e0 0a 02 48 	mul	r8,r0,r10
8000b980:	10 3b       	cp.w	r11,r8
8000b982:	c0 a2       	brcc	8000b996 <__avr32_udiv64+0x66>
8000b984:	20 19       	sub	r9,1
8000b986:	18 0b       	add	r11,r12
8000b988:	18 3b       	cp.w	r11,r12
8000b98a:	c0 63       	brcs	8000b996 <__avr32_udiv64+0x66>
8000b98c:	10 3b       	cp.w	r11,r8
8000b98e:	f7 b9 03 01 	sublo	r9,1
8000b992:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b996:	f6 08 01 01 	sub	r1,r11,r8
8000b99a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b99e:	e2 0e 0d 00 	divu	r0,r1,lr
8000b9a2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b9a6:	00 98       	mov	r8,r0
8000b9a8:	e0 0a 02 4a 	mul	r10,r0,r10
8000b9ac:	14 33       	cp.w	r3,r10
8000b9ae:	c0 82       	brcc	8000b9be <__avr32_udiv64+0x8e>
8000b9b0:	20 18       	sub	r8,1
8000b9b2:	18 03       	add	r3,r12
8000b9b4:	18 33       	cp.w	r3,r12
8000b9b6:	c0 43       	brcs	8000b9be <__avr32_udiv64+0x8e>
8000b9b8:	14 33       	cp.w	r3,r10
8000b9ba:	f7 b8 03 01 	sublo	r8,1
8000b9be:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b9c2:	cd f8       	rjmp	8000bb80 <__avr32_udiv64+0x250>
8000b9c4:	58 08       	cp.w	r8,0
8000b9c6:	c0 51       	brne	8000b9d0 <__avr32_udiv64+0xa0>
8000b9c8:	30 19       	mov	r9,1
8000b9ca:	f2 08 0d 08 	divu	r8,r9,r8
8000b9ce:	10 9c       	mov	r12,r8
8000b9d0:	f8 06 12 00 	clz	r6,r12
8000b9d4:	c0 41       	brne	8000b9dc <__avr32_udiv64+0xac>
8000b9d6:	18 1b       	sub	r11,r12
8000b9d8:	30 19       	mov	r9,1
8000b9da:	c4 08       	rjmp	8000ba5a <__avr32_udiv64+0x12a>
8000b9dc:	ec 01 11 20 	rsub	r1,r6,32
8000b9e0:	f4 01 0a 49 	lsr	r9,r10,r1
8000b9e4:	f8 06 09 4c 	lsl	r12,r12,r6
8000b9e8:	f6 06 09 48 	lsl	r8,r11,r6
8000b9ec:	f6 01 0a 41 	lsr	r1,r11,r1
8000b9f0:	f3 e8 10 08 	or	r8,r9,r8
8000b9f4:	f8 03 16 10 	lsr	r3,r12,0x10
8000b9f8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b9fc:	e2 03 0d 00 	divu	r0,r1,r3
8000ba00:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ba04:	00 9e       	mov	lr,r0
8000ba06:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba0a:	e0 05 02 49 	mul	r9,r0,r5
8000ba0e:	12 3b       	cp.w	r11,r9
8000ba10:	c0 a2       	brcc	8000ba24 <__avr32_udiv64+0xf4>
8000ba12:	20 1e       	sub	lr,1
8000ba14:	18 0b       	add	r11,r12
8000ba16:	18 3b       	cp.w	r11,r12
8000ba18:	c0 63       	brcs	8000ba24 <__avr32_udiv64+0xf4>
8000ba1a:	12 3b       	cp.w	r11,r9
8000ba1c:	f7 be 03 01 	sublo	lr,1
8000ba20:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba24:	12 1b       	sub	r11,r9
8000ba26:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ba2a:	f6 03 0d 02 	divu	r2,r11,r3
8000ba2e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000ba32:	04 99       	mov	r9,r2
8000ba34:	e4 05 02 4b 	mul	r11,r2,r5
8000ba38:	16 38       	cp.w	r8,r11
8000ba3a:	c0 a2       	brcc	8000ba4e <__avr32_udiv64+0x11e>
8000ba3c:	20 19       	sub	r9,1
8000ba3e:	18 08       	add	r8,r12
8000ba40:	18 38       	cp.w	r8,r12
8000ba42:	c0 63       	brcs	8000ba4e <__avr32_udiv64+0x11e>
8000ba44:	16 38       	cp.w	r8,r11
8000ba46:	f7 b9 03 01 	sublo	r9,1
8000ba4a:	f1 dc e3 08 	addcs	r8,r8,r12
8000ba4e:	f4 06 09 43 	lsl	r3,r10,r6
8000ba52:	f0 0b 01 0b 	sub	r11,r8,r11
8000ba56:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ba5a:	f8 06 16 10 	lsr	r6,r12,0x10
8000ba5e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ba62:	f6 06 0d 00 	divu	r0,r11,r6
8000ba66:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ba6a:	00 9a       	mov	r10,r0
8000ba6c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba70:	e0 0e 02 48 	mul	r8,r0,lr
8000ba74:	10 3b       	cp.w	r11,r8
8000ba76:	c0 a2       	brcc	8000ba8a <__avr32_udiv64+0x15a>
8000ba78:	20 1a       	sub	r10,1
8000ba7a:	18 0b       	add	r11,r12
8000ba7c:	18 3b       	cp.w	r11,r12
8000ba7e:	c0 63       	brcs	8000ba8a <__avr32_udiv64+0x15a>
8000ba80:	10 3b       	cp.w	r11,r8
8000ba82:	f7 ba 03 01 	sublo	r10,1
8000ba86:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba8a:	f6 08 01 01 	sub	r1,r11,r8
8000ba8e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ba92:	e2 06 0d 00 	divu	r0,r1,r6
8000ba96:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ba9a:	00 98       	mov	r8,r0
8000ba9c:	e0 0e 02 4b 	mul	r11,r0,lr
8000baa0:	16 33       	cp.w	r3,r11
8000baa2:	c0 82       	brcc	8000bab2 <__avr32_udiv64+0x182>
8000baa4:	20 18       	sub	r8,1
8000baa6:	18 03       	add	r3,r12
8000baa8:	18 33       	cp.w	r3,r12
8000baaa:	c0 43       	brcs	8000bab2 <__avr32_udiv64+0x182>
8000baac:	16 33       	cp.w	r3,r11
8000baae:	f7 b8 03 01 	sublo	r8,1
8000bab2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bab6:	c6 98       	rjmp	8000bb88 <__avr32_udiv64+0x258>
8000bab8:	16 39       	cp.w	r9,r11
8000baba:	e0 8b 00 65 	brhi	8000bb84 <__avr32_udiv64+0x254>
8000babe:	f2 09 12 00 	clz	r9,r9
8000bac2:	c0 b1       	brne	8000bad8 <__avr32_udiv64+0x1a8>
8000bac4:	10 3a       	cp.w	r10,r8
8000bac6:	5f 2a       	srhs	r10
8000bac8:	1c 3b       	cp.w	r11,lr
8000baca:	5f b8       	srhi	r8
8000bacc:	10 4a       	or	r10,r8
8000bace:	f2 0a 18 00 	cp.b	r10,r9
8000bad2:	c5 90       	breq	8000bb84 <__avr32_udiv64+0x254>
8000bad4:	30 18       	mov	r8,1
8000bad6:	c5 98       	rjmp	8000bb88 <__avr32_udiv64+0x258>
8000bad8:	f0 09 09 46 	lsl	r6,r8,r9
8000badc:	f2 03 11 20 	rsub	r3,r9,32
8000bae0:	fc 09 09 4e 	lsl	lr,lr,r9
8000bae4:	f0 03 0a 48 	lsr	r8,r8,r3
8000bae8:	f6 09 09 4c 	lsl	r12,r11,r9
8000baec:	f4 03 0a 42 	lsr	r2,r10,r3
8000baf0:	ef 46 ff f4 	st.w	r7[-12],r6
8000baf4:	f6 03 0a 43 	lsr	r3,r11,r3
8000baf8:	18 42       	or	r2,r12
8000bafa:	f1 ee 10 0c 	or	r12,r8,lr
8000bafe:	f8 01 16 10 	lsr	r1,r12,0x10
8000bb02:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bb06:	e6 01 0d 04 	divu	r4,r3,r1
8000bb0a:	e4 03 16 10 	lsr	r3,r2,0x10
8000bb0e:	08 9e       	mov	lr,r4
8000bb10:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bb14:	e8 06 02 48 	mul	r8,r4,r6
8000bb18:	10 33       	cp.w	r3,r8
8000bb1a:	c0 a2       	brcc	8000bb2e <__avr32_udiv64+0x1fe>
8000bb1c:	20 1e       	sub	lr,1
8000bb1e:	18 03       	add	r3,r12
8000bb20:	18 33       	cp.w	r3,r12
8000bb22:	c0 63       	brcs	8000bb2e <__avr32_udiv64+0x1fe>
8000bb24:	10 33       	cp.w	r3,r8
8000bb26:	f7 be 03 01 	sublo	lr,1
8000bb2a:	e7 dc e3 03 	addcs	r3,r3,r12
8000bb2e:	10 13       	sub	r3,r8
8000bb30:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bb34:	e6 01 0d 00 	divu	r0,r3,r1
8000bb38:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb3c:	00 98       	mov	r8,r0
8000bb3e:	e0 06 02 46 	mul	r6,r0,r6
8000bb42:	0c 3b       	cp.w	r11,r6
8000bb44:	c0 a2       	brcc	8000bb58 <__avr32_udiv64+0x228>
8000bb46:	20 18       	sub	r8,1
8000bb48:	18 0b       	add	r11,r12
8000bb4a:	18 3b       	cp.w	r11,r12
8000bb4c:	c0 63       	brcs	8000bb58 <__avr32_udiv64+0x228>
8000bb4e:	0c 3b       	cp.w	r11,r6
8000bb50:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb54:	f7 b8 03 01 	sublo	r8,1
8000bb58:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bb5c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bb60:	0c 1b       	sub	r11,r6
8000bb62:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bb66:	06 95       	mov	r5,r3
8000bb68:	16 35       	cp.w	r5,r11
8000bb6a:	e0 8b 00 0a 	brhi	8000bb7e <__avr32_udiv64+0x24e>
8000bb6e:	5f 0b       	sreq	r11
8000bb70:	f4 09 09 49 	lsl	r9,r10,r9
8000bb74:	12 32       	cp.w	r2,r9
8000bb76:	5f b9       	srhi	r9
8000bb78:	f7 e9 00 09 	and	r9,r11,r9
8000bb7c:	c0 60       	breq	8000bb88 <__avr32_udiv64+0x258>
8000bb7e:	20 18       	sub	r8,1
8000bb80:	30 09       	mov	r9,0
8000bb82:	c0 38       	rjmp	8000bb88 <__avr32_udiv64+0x258>
8000bb84:	30 09       	mov	r9,0
8000bb86:	12 98       	mov	r8,r9
8000bb88:	10 9a       	mov	r10,r8
8000bb8a:	12 93       	mov	r3,r9
8000bb8c:	10 92       	mov	r2,r8
8000bb8e:	12 9b       	mov	r11,r9
8000bb90:	2f dd       	sub	sp,-12
8000bb92:	d8 32       	popm	r0-r7,pc

8000bb94 <__avr32_umod64>:
8000bb94:	d4 31       	pushm	r0-r7,lr
8000bb96:	1a 97       	mov	r7,sp
8000bb98:	20 3d       	sub	sp,12
8000bb9a:	10 9c       	mov	r12,r8
8000bb9c:	12 95       	mov	r5,r9
8000bb9e:	14 9e       	mov	lr,r10
8000bba0:	16 91       	mov	r1,r11
8000bba2:	16 96       	mov	r6,r11
8000bba4:	58 09       	cp.w	r9,0
8000bba6:	e0 81 00 81 	brne	8000bca8 <__avr32_umod64+0x114>
8000bbaa:	16 38       	cp.w	r8,r11
8000bbac:	e0 88 00 12 	brls	8000bbd0 <__avr32_umod64+0x3c>
8000bbb0:	f0 08 12 00 	clz	r8,r8
8000bbb4:	c4 e0       	breq	8000bc50 <__avr32_umod64+0xbc>
8000bbb6:	f6 08 09 46 	lsl	r6,r11,r8
8000bbba:	f8 08 09 4c 	lsl	r12,r12,r8
8000bbbe:	f0 0b 11 20 	rsub	r11,r8,32
8000bbc2:	f4 08 09 4e 	lsl	lr,r10,r8
8000bbc6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bbca:	f7 e6 10 06 	or	r6,r11,r6
8000bbce:	c4 18       	rjmp	8000bc50 <__avr32_umod64+0xbc>
8000bbd0:	58 08       	cp.w	r8,0
8000bbd2:	c0 51       	brne	8000bbdc <__avr32_umod64+0x48>
8000bbd4:	30 19       	mov	r9,1
8000bbd6:	f2 08 0d 08 	divu	r8,r9,r8
8000bbda:	10 9c       	mov	r12,r8
8000bbdc:	f8 08 12 00 	clz	r8,r12
8000bbe0:	c0 31       	brne	8000bbe6 <__avr32_umod64+0x52>
8000bbe2:	18 16       	sub	r6,r12
8000bbe4:	c3 68       	rjmp	8000bc50 <__avr32_umod64+0xbc>
8000bbe6:	f0 03 11 20 	rsub	r3,r8,32
8000bbea:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bbee:	f8 08 09 4c 	lsl	r12,r12,r8
8000bbf2:	ec 08 09 49 	lsl	r9,r6,r8
8000bbf6:	ec 03 0a 43 	lsr	r3,r6,r3
8000bbfa:	f7 e9 10 09 	or	r9,r11,r9
8000bbfe:	f8 05 16 10 	lsr	r5,r12,0x10
8000bc02:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bc06:	e6 05 0d 02 	divu	r2,r3,r5
8000bc0a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bc0e:	ec 02 02 4b 	mul	r11,r6,r2
8000bc12:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bc16:	16 3e       	cp.w	lr,r11
8000bc18:	c0 72       	brcc	8000bc26 <__avr32_umod64+0x92>
8000bc1a:	18 0e       	add	lr,r12
8000bc1c:	18 3e       	cp.w	lr,r12
8000bc1e:	c0 43       	brcs	8000bc26 <__avr32_umod64+0x92>
8000bc20:	16 3e       	cp.w	lr,r11
8000bc22:	fd dc e3 0e 	addcs	lr,lr,r12
8000bc26:	fc 0b 01 03 	sub	r3,lr,r11
8000bc2a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bc2e:	e6 05 0d 02 	divu	r2,r3,r5
8000bc32:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc36:	a5 36       	mul	r6,r2
8000bc38:	0c 39       	cp.w	r9,r6
8000bc3a:	c0 72       	brcc	8000bc48 <__avr32_umod64+0xb4>
8000bc3c:	18 09       	add	r9,r12
8000bc3e:	18 39       	cp.w	r9,r12
8000bc40:	c0 43       	brcs	8000bc48 <__avr32_umod64+0xb4>
8000bc42:	0c 39       	cp.w	r9,r6
8000bc44:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc48:	f2 06 01 06 	sub	r6,r9,r6
8000bc4c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc50:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bc54:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bc58:	ec 0a 0d 02 	divu	r2,r6,r10
8000bc5c:	fc 09 16 10 	lsr	r9,lr,0x10
8000bc60:	ea 02 02 4b 	mul	r11,r5,r2
8000bc64:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc68:	16 39       	cp.w	r9,r11
8000bc6a:	c0 72       	brcc	8000bc78 <__avr32_umod64+0xe4>
8000bc6c:	18 09       	add	r9,r12
8000bc6e:	18 39       	cp.w	r9,r12
8000bc70:	c0 43       	brcs	8000bc78 <__avr32_umod64+0xe4>
8000bc72:	16 39       	cp.w	r9,r11
8000bc74:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc78:	f2 0b 01 0b 	sub	r11,r9,r11
8000bc7c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bc80:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bc84:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bc88:	ea 0a 02 4a 	mul	r10,r5,r10
8000bc8c:	14 3e       	cp.w	lr,r10
8000bc8e:	c0 72       	brcc	8000bc9c <__avr32_umod64+0x108>
8000bc90:	18 0e       	add	lr,r12
8000bc92:	18 3e       	cp.w	lr,r12
8000bc94:	c0 43       	brcs	8000bc9c <__avr32_umod64+0x108>
8000bc96:	14 3e       	cp.w	lr,r10
8000bc98:	fd dc e3 0e 	addcs	lr,lr,r12
8000bc9c:	fc 0a 01 0a 	sub	r10,lr,r10
8000bca0:	30 0b       	mov	r11,0
8000bca2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bca6:	c7 b8       	rjmp	8000bd9c <__avr32_umod64+0x208>
8000bca8:	16 39       	cp.w	r9,r11
8000bcaa:	e0 8b 00 79 	brhi	8000bd9c <__avr32_umod64+0x208>
8000bcae:	f2 09 12 00 	clz	r9,r9
8000bcb2:	c1 21       	brne	8000bcd6 <__avr32_umod64+0x142>
8000bcb4:	10 3a       	cp.w	r10,r8
8000bcb6:	5f 2b       	srhs	r11
8000bcb8:	0a 31       	cp.w	r1,r5
8000bcba:	5f ba       	srhi	r10
8000bcbc:	f7 ea 10 0a 	or	r10,r11,r10
8000bcc0:	f2 0a 18 00 	cp.b	r10,r9
8000bcc4:	c0 60       	breq	8000bcd0 <__avr32_umod64+0x13c>
8000bcc6:	fc 08 01 0c 	sub	r12,lr,r8
8000bcca:	e2 05 01 46 	sbc	r6,r1,r5
8000bcce:	18 9e       	mov	lr,r12
8000bcd0:	0c 9b       	mov	r11,r6
8000bcd2:	1c 9a       	mov	r10,lr
8000bcd4:	c6 48       	rjmp	8000bd9c <__avr32_umod64+0x208>
8000bcd6:	ea 09 09 4c 	lsl	r12,r5,r9
8000bcda:	f2 06 11 20 	rsub	r6,r9,32
8000bcde:	f6 09 09 4b 	lsl	r11,r11,r9
8000bce2:	f0 09 09 42 	lsl	r2,r8,r9
8000bce6:	ef 46 ff f4 	st.w	r7[-12],r6
8000bcea:	f0 06 0a 48 	lsr	r8,r8,r6
8000bcee:	18 48       	or	r8,r12
8000bcf0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bcf4:	f4 09 09 43 	lsl	r3,r10,r9
8000bcf8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bcfc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bd00:	16 4a       	or	r10,r11
8000bd02:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bd06:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd0a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bd0e:	08 91       	mov	r1,r4
8000bd10:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bd14:	e8 0e 02 46 	mul	r6,r4,lr
8000bd18:	0c 3c       	cp.w	r12,r6
8000bd1a:	c0 a2       	brcc	8000bd2e <__avr32_umod64+0x19a>
8000bd1c:	20 11       	sub	r1,1
8000bd1e:	10 0c       	add	r12,r8
8000bd20:	10 3c       	cp.w	r12,r8
8000bd22:	c0 63       	brcs	8000bd2e <__avr32_umod64+0x19a>
8000bd24:	0c 3c       	cp.w	r12,r6
8000bd26:	f7 b1 03 01 	sublo	r1,1
8000bd2a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bd2e:	0c 1c       	sub	r12,r6
8000bd30:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bd34:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd38:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bd3c:	08 96       	mov	r6,r4
8000bd3e:	e8 0e 02 4e 	mul	lr,r4,lr
8000bd42:	1c 3b       	cp.w	r11,lr
8000bd44:	c0 a2       	brcc	8000bd58 <__avr32_umod64+0x1c4>
8000bd46:	20 16       	sub	r6,1
8000bd48:	10 0b       	add	r11,r8
8000bd4a:	10 3b       	cp.w	r11,r8
8000bd4c:	c0 63       	brcs	8000bd58 <__avr32_umod64+0x1c4>
8000bd4e:	1c 3b       	cp.w	r11,lr
8000bd50:	f7 b6 03 01 	sublo	r6,1
8000bd54:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bd58:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bd5c:	1c 1b       	sub	r11,lr
8000bd5e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bd62:	00 9e       	mov	lr,r0
8000bd64:	02 9c       	mov	r12,r1
8000bd66:	16 3c       	cp.w	r12,r11
8000bd68:	e0 8b 00 08 	brhi	8000bd78 <__avr32_umod64+0x1e4>
8000bd6c:	5f 06       	sreq	r6
8000bd6e:	06 30       	cp.w	r0,r3
8000bd70:	5f ba       	srhi	r10
8000bd72:	ed ea 00 0a 	and	r10,r6,r10
8000bd76:	c0 60       	breq	8000bd82 <__avr32_umod64+0x1ee>
8000bd78:	fc 02 01 04 	sub	r4,lr,r2
8000bd7c:	f8 08 01 4c 	sbc	r12,r12,r8
8000bd80:	08 9e       	mov	lr,r4
8000bd82:	e6 0e 01 0a 	sub	r10,r3,lr
8000bd86:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bd8a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bd8e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bd92:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bd96:	f8 01 09 4c 	lsl	r12,r12,r1
8000bd9a:	18 4a       	or	r10,r12
8000bd9c:	2f dd       	sub	sp,-12
8000bd9e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000be00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000be00:	c0 08       	rjmp	8000be00 <_evba>
	...

8000be04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000be04:	c0 08       	rjmp	8000be04 <_handle_TLB_Multiple_Hit>
	...

8000be08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000be08:	c0 08       	rjmp	8000be08 <_handle_Bus_Error_Data_Fetch>
	...

8000be0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000be0c:	c0 08       	rjmp	8000be0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000be10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000be10:	c0 08       	rjmp	8000be10 <_handle_NMI>
	...

8000be14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000be14:	c0 08       	rjmp	8000be14 <_handle_Instruction_Address>
	...

8000be18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000be18:	c0 08       	rjmp	8000be18 <_handle_ITLB_Protection>
	...

8000be1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000be1c:	c0 08       	rjmp	8000be1c <_handle_Breakpoint>
	...

8000be20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000be20:	c0 08       	rjmp	8000be20 <_handle_Illegal_Opcode>
	...

8000be24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000be24:	c0 08       	rjmp	8000be24 <_handle_Unimplemented_Instruction>
	...

8000be28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000be28:	c0 08       	rjmp	8000be28 <_handle_Privilege_Violation>
	...

8000be2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000be2c:	c0 08       	rjmp	8000be2c <_handle_Floating_Point>
	...

8000be30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000be30:	c0 08       	rjmp	8000be30 <_handle_Coprocessor_Absent>
	...

8000be34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000be34:	c0 08       	rjmp	8000be34 <_handle_Data_Address_Read>
	...

8000be38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000be38:	c0 08       	rjmp	8000be38 <_handle_Data_Address_Write>
	...

8000be3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000be3c:	c0 08       	rjmp	8000be3c <_handle_DTLB_Protection_Read>
	...

8000be40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000be40:	c0 08       	rjmp	8000be40 <_handle_DTLB_Protection_Write>
	...

8000be44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000be44:	c0 08       	rjmp	8000be44 <_handle_DTLB_Modified>
	...

8000be50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000be50:	c0 08       	rjmp	8000be50 <_handle_ITLB_Miss>
	...

8000be60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000be60:	c0 08       	rjmp	8000be60 <_handle_DTLB_Miss_Read>
	...

8000be70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000be70:	c0 08       	rjmp	8000be70 <_handle_DTLB_Miss_Write>
	...

8000bf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bf00:	fe cf 70 34 	sub	pc,pc,28724

8000bf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bf04:	30 0c       	mov	r12,0
8000bf06:	fe b0 c4 ff 	rcall	80004904 <_get_interrupt_handler>
8000bf0a:	58 0c       	cp.w	r12,0
8000bf0c:	f8 0f 17 10 	movne	pc,r12
8000bf10:	d6 03       	rete

8000bf12 <_int1>:
8000bf12:	30 1c       	mov	r12,1
8000bf14:	fe b0 c4 f8 	rcall	80004904 <_get_interrupt_handler>
8000bf18:	58 0c       	cp.w	r12,0
8000bf1a:	f8 0f 17 10 	movne	pc,r12
8000bf1e:	d6 03       	rete

8000bf20 <_int2>:
8000bf20:	30 2c       	mov	r12,2
8000bf22:	fe b0 c4 f1 	rcall	80004904 <_get_interrupt_handler>
8000bf26:	58 0c       	cp.w	r12,0
8000bf28:	f8 0f 17 10 	movne	pc,r12
8000bf2c:	d6 03       	rete

8000bf2e <_int3>:
8000bf2e:	30 3c       	mov	r12,3
8000bf30:	fe b0 c4 ea 	rcall	80004904 <_get_interrupt_handler>
8000bf34:	58 0c       	cp.w	r12,0
8000bf36:	f8 0f 17 10 	movne	pc,r12
8000bf3a:	d6 03       	rete

8000bf3c <ipr_val>:
8000bf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bffc:	d7 03 d7 03                                         ....
