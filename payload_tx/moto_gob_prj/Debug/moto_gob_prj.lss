
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000d9d4  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000fa00  8000fa00  0000fe00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009670  8000fc00  8000fc00  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019270  00019808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  80019ca4  0001a23c  2**0
                  ALLOC
  8 .bss          00003be8  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         000129d8  00004628  00004628  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001a23c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001620  00000000  00000000  0001a270  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002ade  00000000  00000000  0001b890  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ea03  00000000  00000000  0001e36e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00007853  00000000  00000000  0004cd71  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000df7d  00000000  00000000  000545c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003cdc  00000000  00000000  00062544  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007ff6  00000000  00000000  00066220  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0001208a  00000000  00000000  0006e216  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001718  00000000  00000000  000802a0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	9f 5c       	st.w	pc[0x14],r12

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 80 ac 	sub	pc,pc,-32596

Disassembly of section .text:

8000200c <DeviceManagement_brdcst_func>:
8000200c:	19 a9       	ld.ub	r9,r12[0x2]
8000200e:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	f0 09 18 00 	cp.b	r9,r8
80002014:	c0 61       	brne	80002020 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002016:	48 68       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002018:	70 09       	ld.w	r9,r8[0x0]
8000201a:	a1 b9       	sbr	r9,0x1
8000201c:	91 09       	st.w	r8[0x0],r9
8000201e:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002020:	48 38       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002022:	70 09       	ld.w	r9,r8[0x0]
80002024:	a1 d9       	cbr	r9,0x1
80002026:	91 09       	st.w	r8[0x0],r9
80002028:	5e fc       	retal	r12
8000202a:	00 00       	add	r0,r0
8000202c:	00 00       	add	r0,r0
8000202e:	12 c4       	st.b	r9++,r4

80002030 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002030:	5e fc       	retal	r12

80002032 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002032:	5e fc       	retal	r12

80002034 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002034:	48 38       	lddpc	r8,80002040 <vApplicationIdleHook+0xc>
80002036:	70 09       	ld.w	r9,r8[0x0]
80002038:	2f f9       	sub	r9,-1
8000203a:	91 09       	st.w	r8[0x0],r9
	
}
8000203c:	5e fc       	retal	r12
8000203e:	00 00       	add	r0,r0
80002040:	00 00       	add	r0,r0
80002042:	0a 58       	eor	r8,r5

80002044 <app_init>:
														
		
};

void app_init(void)
{	
80002044:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002046:	48 cb       	lddpc	r11,80002074 <app_init+0x30>
80002048:	48 cc       	lddpc	r12,80002078 <app_init+0x34>
8000204a:	f0 1f 00 0d 	mcall	8000207c <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204e:	48 dc       	lddpc	r12,80002080 <app_init+0x3c>
80002050:	f0 1f 00 0d 	mcall	80002084 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002054:	30 09       	mov	r9,0
80002056:	1a d9       	st.w	--sp,r9
80002058:	1a d9       	st.w	--sp,r9
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	30 18       	mov	r8,1
8000205e:	e0 6a 01 80 	mov	r10,384
80002062:	48 ab       	lddpc	r11,80002088 <app_init+0x44>
80002064:	48 ac       	lddpc	r12,8000208c <app_init+0x48>
80002066:	f0 1f 00 0b 	mcall	80002090 <app_init+0x4c>
8000206a:	48 b8       	lddpc	r8,80002094 <app_init+0x50>
8000206c:	91 0c       	st.w	r8[0x0],r12
8000206e:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002070:	d8 02       	popm	pc
80002072:	00 00       	add	r0,r0
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 8c       	sub	r12,-120
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 b8       	sub	r8,-117
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	39 78       	mov	r8,-105
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	4d 94       	lddpc	r4,800021e8 <ButtonConfig_brdcst_func+0x50>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	fc 00       	*unknown*
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	27 cc       	sub	r12,124
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	96 90       	ld.uh	r0,r11[0x2]
80002094:	00 00       	add	r0,r0
80002096:	0a 50       	eor	r0,r5

80002098 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_brdcst_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_brdcst_func+0x10>
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	fc 08       	*unknown*
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	9a 54       	ld.sh	r4,sp[0xa]

800020ac <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_reply_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_reply_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	fc 28 80 00 	sub	r8,-229376
800020be:	9a 54       	ld.sh	r4,sp[0xa]

800020c0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <FD_request_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <FD_request_func+0x10>
	
	
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	fc 44 80 00 	cp.w	r4,-229376
800020d2:	9a 54       	ld.sh	r4,sp[0xa]

800020d4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020d6:	48 3c       	lddpc	r12,800020e0 <EnOB_brdcst_func+0xc>
800020d8:	f0 1f 00 03 	mcall	800020e4 <EnOB_brdcst_func+0x10>
}
800020dc:	d8 02       	popm	pc
800020de:	00 00       	add	r0,r0
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	fc 60 80 00 	mov	r0,-229376
800020e6:	9a 54       	ld.sh	r4,sp[0xa]

800020e8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020e8:	eb cd 40 80 	pushm	r7,lr
800020ec:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020ee:	19 a9       	ld.ub	r9,r12[0x2]
800020f0:	30 08       	mov	r8,0
800020f2:	f0 09 18 00 	cp.b	r9,r8
800020f6:	c1 91       	brne	80002128 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020f8:	19 b8       	ld.ub	r8,r12[0x3]
800020fa:	30 19       	mov	r9,1
800020fc:	f2 08 18 00 	cp.b	r8,r9
80002100:	c0 61       	brne	8000210c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002102:	49 0c       	lddpc	r12,80002140 <EnOB_reply_func+0x58>
80002104:	f0 1f 00 10 	mcall	80002144 <EnOB_reply_func+0x5c>
80002108:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000210c:	58 08       	cp.w	r8,0
8000210e:	c0 61       	brne	8000211a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002110:	48 ec       	lddpc	r12,80002148 <EnOB_reply_func+0x60>
80002112:	f0 1f 00 0d 	mcall	80002144 <EnOB_reply_func+0x5c>
80002116:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211a:	1a d8       	st.w	--sp,r8
8000211c:	48 cc       	lddpc	r12,8000214c <EnOB_reply_func+0x64>
8000211e:	f0 1f 00 0a 	mcall	80002144 <EnOB_reply_func+0x5c>
80002122:	2f fd       	sub	sp,-4
80002124:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002128:	48 ac       	lddpc	r12,80002150 <EnOB_reply_func+0x68>
8000212a:	f0 1f 00 07 	mcall	80002144 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000212e:	0f a8       	ld.ub	r8,r7[0x2]
80002130:	1a d8       	st.w	--sp,r8
80002132:	48 9c       	lddpc	r12,80002154 <EnOB_reply_func+0x6c>
80002134:	f0 1f 00 04 	mcall	80002144 <EnOB_reply_func+0x5c>
80002138:	2f fd       	sub	sp,-4
8000213a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	fc 78 80 00 	mov	r8,-163840
80002146:	9a 54       	ld.sh	r4,sp[0xa]
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	fc 90 80 00 	breq	7ffb214a <_estack+0x7ff9a14a>
8000214e:	fc a4       	*unknown*
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	fc bc       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	fc d8 eb cd 	satsub.w	r8,lr,-5171

80002158 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	eb cd 40 80 	pushm	r7,lr
8000215c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000215e:	19 a9       	ld.ub	r9,r12[0x2]
80002160:	31 18       	mov	r8,17
80002162:	f0 09 18 00 	cp.b	r9,r8
80002166:	c0 61       	brne	80002172 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002168:	48 8c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x30>
8000216a:	f0 1f 00 09 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
8000216e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002172:	48 8c       	lddpc	r12,80002190 <SingleDetection_brdcst_func+0x38>
80002174:	f0 1f 00 06 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002178:	0f a8       	ld.ub	r8,r7[0x2]
8000217a:	1a d8       	st.w	--sp,r8
8000217c:	48 6c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x3c>
8000217e:	f0 1f 00 04 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
80002182:	2f fd       	sub	sp,-4
80002184:	e3 cd 80 80 	ldm	sp++,r7,pc
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	fc f0 80 00 	ld.w	r0,lr[-32768]
8000218e:	9a 54       	ld.sh	r4,sp[0xa]
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	fd 04 80 00 	ld.sh	r4,lr[-32768]
80002196:	fd 14 d4 31 	ld.uh	r4,lr[-11215]

80002198 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000219e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a0:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xb4>
800021a2:	f0 1f 00 2c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021a6:	0f 88       	ld.ub	r8,r7[0x0]
800021a8:	1a d8       	st.w	--sp,r8
800021aa:	4a bc       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xbc>
800021ac:	f0 1f 00 29 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b0:	1a d5       	st.w	--sp,r5
800021b2:	4a ac       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xc0>
800021b4:	f0 1f 00 27 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b8:	0f a8       	ld.ub	r8,r7[0x2]
800021ba:	1a d8       	st.w	--sp,r8
800021bc:	4a 8c       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc4>
800021be:	f0 1f 00 25 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c2:	2f dd       	sub	sp,-12
800021c4:	58 05       	cp.w	r5,0
800021c6:	c4 10       	breq	80002248 <ButtonConfig_brdcst_func+0xb0>
800021c8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ca:	4a 64       	lddpc	r4,80002260 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021cc:	4a 63       	lddpc	r3,80002264 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ce:	4a 72       	lddpc	r2,80002268 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d0:	4a 71       	lddpc	r1,8000226c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d2:	4a 80       	lddpc	r0,80002270 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d4:	0f b9       	ld.ub	r9,r7[0x3]
800021d6:	0f c8       	ld.ub	r8,r7[0x4]
800021d8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021dc:	1a d8       	st.w	--sp,r8
800021de:	1a d6       	st.w	--sp,r6
800021e0:	08 9c       	mov	r12,r4
800021e2:	f0 1f 00 1c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e6:	0f d9       	ld.ub	r9,r7[0x5]
800021e8:	0f e8       	ld.ub	r8,r7[0x6]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	06 9c       	mov	r12,r3
800021f4:	f0 1f 00 17 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f8:	0f f9       	ld.ub	r9,r7[0x7]
800021fa:	ef 38 00 08 	ld.ub	r8,r7[8]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	04 9c       	mov	r12,r2
80002208:	f0 1f 00 12 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000220c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002210:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	02 9c       	mov	r12,r1
8000221e:	f0 1f 00 0d 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002222:	2f 8d       	sub	sp,-32
80002224:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002228:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000222c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002230:	1a d8       	st.w	--sp,r8
80002232:	1a d6       	st.w	--sp,r6
80002234:	00 9c       	mov	r12,r0
80002236:	f0 1f 00 07 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
8000223a:	2f f6       	sub	r6,-1
8000223c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000223e:	2f ed       	sub	sp,-8
80002240:	ec 05 18 00 	cp.b	r5,r6
80002244:	fe 9b ff c8 	brhi	800021d4 <ButtonConfig_brdcst_func+0x3c>
80002248:	d8 32       	popm	r0-r7,pc
8000224a:	00 00       	add	r0,r0
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	fd 2c 80 00 	ld.sb	r12,lr[-32768]
80002252:	9a 54       	ld.sh	r4,sp[0xa]
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	fd 4c 80 00 	st.w	lr[-32768],r12
8000225a:	fd 60 80 00 	st.b	lr[-32768],r0
8000225e:	fd 78 80 00 	stcond	lr[-32768],r8
80002262:	fd 98       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	fd c0       	*unknown*
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	fd e8 80 00 	sthh.w	r0[r0],lr:b,r8:b
8000226e:	fe 0c       	*unknown*
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	fe 34 eb cd 	sub	r4,-5171

80002274 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002274:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002278:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000227c:	19 c7       	ld.ub	r7,r12[0x4]
8000227e:	19 d8       	ld.ub	r8,r12[0x5]
80002280:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002284:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002286:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002288:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000228c:	49 0c       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x58>
8000228e:	f0 1f 00 11 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002292:	1a d6       	st.w	--sp,r6
80002294:	49 0c       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x60>
80002296:	f0 1f 00 0f 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229a:	1a d5       	st.w	--sp,r5
8000229c:	48 fc       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x64>
8000229e:	f0 1f 00 0d 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a2:	5c 77       	castu.h	r7
800022a4:	1a d7       	st.w	--sp,r7
800022a6:	48 ec       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x68>
800022a8:	f0 1f 00 0a 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022ac:	1a d4       	st.w	--sp,r4
800022ae:	48 dc       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x6c>
800022b0:	f0 1f 00 08 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b4:	1a d3       	st.w	--sp,r3
800022b6:	48 cc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x70>
800022b8:	f0 1f 00 06 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022bc:	1a d2       	st.w	--sp,r2
800022be:	48 bc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x74>
800022c0:	f0 1f 00 04 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
800022c4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ca:	00 00       	add	r0,r0
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	fe 58 80 00 	cp.w	r8,-32768
800022d2:	9a 54       	ld.sh	r4,sp[0xa]
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	fe 7c 80 00 	mov	r12,-32768
800022da:	fe 94 80 00 	brge	7fff22da <_estack+0x7ffda2da>
800022de:	fe a8       	*unknown*
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	fe bc       	*unknown*
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	fe d0 80 00 	satsub.w	r0,pc,-32768
800022ea:	fe f0 eb cd 	ld.w	r0,pc[-5171]

800022ec <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f0:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f4:	0f 89       	ld.ub	r9,r7[0x0]
800022f6:	30 08       	mov	r8,0
800022f8:	f0 09 18 00 	cp.b	r9,r8
800022fc:	c0 c1       	brne	80002314 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022fe:	48 9c       	lddpc	r12,80002320 <ButtonConfig_reply_func+0x34>
80002300:	f0 1f 00 09 	mcall	80002324 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002304:	0f 98       	ld.ub	r8,r7[0x1]
80002306:	1a d8       	st.w	--sp,r8
80002308:	48 8c       	lddpc	r12,80002328 <ButtonConfig_reply_func+0x3c>
8000230a:	f0 1f 00 07 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000230e:	2f fd       	sub	sp,-4
80002310:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002314:	48 6c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x40>
80002316:	f0 1f 00 04 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000231a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000231e:	00 00       	add	r0,r0
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	ff 10 80 00 	ld.uh	r0,pc[-32768]
80002326:	9a 54       	ld.sh	r4,sp[0xa]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	fd 4c 80 00 	st.w	lr[-32768],r12
8000232e:	ff 28 d4 21 	ld.sb	r8,pc[-11231]

80002330 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002330:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002332:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002336:	0d 88       	ld.ub	r8,r6[0x0]
80002338:	32 49       	mov	r9,36
8000233a:	f2 08 18 00 	cp.b	r8,r9
8000233e:	c2 91       	brne	80002390 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002340:	49 7c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x6c>
80002342:	f0 1f 00 18 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002346:	0d a5       	ld.ub	r5,r6[0x2]
80002348:	0d b8       	ld.ub	r8,r6[0x3]
8000234a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000234e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002350:	0d 98       	ld.ub	r8,r6[0x1]
80002352:	1a d8       	st.w	--sp,r8
80002354:	49 4c       	lddpc	r12,800023a4 <DataSession_brdcst_func+0x74>
80002356:	f0 1f 00 13 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000235e:	1a d8       	st.w	--sp,r8
80002360:	49 2c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x78>
80002362:	f0 1f 00 10 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002366:	2f ed       	sub	sp,-8
80002368:	58 05       	cp.w	r5,0
8000236a:	c1 80       	breq	8000239a <DataSession_brdcst_func+0x6a>
8000236c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000236e:	49 04       	lddpc	r4,800023ac <DataSession_brdcst_func+0x7c>
80002370:	ec 07 00 08 	add	r8,r6,r7
80002374:	11 c8       	ld.ub	r8,r8[0x4]
80002376:	1a d8       	st.w	--sp,r8
80002378:	1a d7       	st.w	--sp,r7
8000237a:	08 9c       	mov	r12,r4
8000237c:	f0 1f 00 09 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002380:	2f f7       	sub	r7,-1
80002382:	5c 57       	castu.b	r7
80002384:	2f ed       	sub	sp,-8
80002386:	ee 05 19 00 	cp.h	r5,r7
8000238a:	fe 9b ff f3 	brhi	80002370 <DataSession_brdcst_func+0x40>
8000238e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002390:	1a d8       	st.w	--sp,r8
80002392:	48 8c       	lddpc	r12,800023b0 <DataSession_brdcst_func+0x80>
80002394:	f0 1f 00 03 	mcall	800023a0 <DataSession_brdcst_func+0x70>
80002398:	2f fd       	sub	sp,-4
8000239a:	d8 22       	popm	r4-r7,pc
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	ff 44 80 00 	st.w	pc[-32768],r4
800023a2:	9a 54       	ld.sh	r4,sp[0xa]
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	ff 58 80 00 	st.h	pc[-32768],r8
800023aa:	ff 70 80 00 	stcond	pc[-32768],r0
800023ae:	ff 8c       	*unknown*
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	ff a4       	*unknown*

800023b4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b4:	eb cd 40 80 	pushm	r7,lr
800023b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ba:	19 a8       	ld.ub	r8,r12[0x2]
800023bc:	58 08       	cp.w	r8,0
800023be:	c0 61       	brne	800023ca <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c0:	48 dc       	lddpc	r12,800023f4 <DataSession_reply_func+0x40>
800023c2:	f0 1f 00 0e 	mcall	800023f8 <DataSession_reply_func+0x44>
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	48 cc       	lddpc	r12,800023fc <DataSession_reply_func+0x48>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d2:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x4c>
800023d4:	f0 1f 00 09 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023d8:	0f b8       	ld.ub	r8,r7[0x3]
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 ac       	lddpc	r12,80002404 <DataSession_reply_func+0x50>
800023de:	f0 1f 00 07 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e2:	0f c8       	ld.ub	r8,r7[0x4]
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	48 9c       	lddpc	r12,80002408 <DataSession_reply_func+0x54>
800023e8:	f0 1f 00 04 	mcall	800023f8 <DataSession_reply_func+0x44>
800023ec:	2f dd       	sub	sp,-12
800023ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	ff b8       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	9a 54       	ld.sh	r4,sp[0xa]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	ff cc       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	ff e0 80 00 	sthh.w	r0[r0],pc:b,r0:b
80002406:	ff f4 80 01 	ld.wls	r4,pc[0x4]
8000240a:	00 04       	add	r4,r0

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c2 21       	brne	80002460 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	49 4c       	lddpc	r12,8000246c <TransmitControl_reply_func+0x60>
80002420:	f0 1f 00 14 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	49 3c       	lddpc	r12,80002474 <TransmitControl_reply_func+0x68>
8000242a:	f0 1f 00 12 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	49 2c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x6c>
80002434:	f0 1f 00 0f 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	49 0c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x70>
8000243e:	f0 1f 00 0d 	mcall	80002470 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002442:	0f 98       	ld.ub	r8,r7[0x1]
80002444:	2f dd       	sub	sp,-12
80002446:	30 19       	mov	r9,1
80002448:	f2 08 18 00 	cp.b	r8,r9
8000244c:	c0 d0       	breq	80002466 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000244e:	30 29       	mov	r9,2
80002450:	f2 08 18 00 	cp.b	r8,r9
80002454:	c0 91       	brne	80002466 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002456:	30 09       	mov	r9,0
80002458:	48 a8       	lddpc	r8,80002480 <TransmitControl_reply_func+0x74>
8000245a:	b0 89       	st.b	r8[0x0],r9
8000245c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002460:	48 9c       	lddpc	r12,80002484 <TransmitControl_reply_func+0x78>
80002462:	f0 1f 00 04 	mcall	80002470 <TransmitControl_reply_func+0x64>
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 01       	ld.sh	r1,r0[0x0]
8000246e:	00 14       	sub	r4,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	9a 54       	ld.sh	r4,sp[0xa]
80002474:	80 01       	ld.sh	r1,r0[0x0]
80002476:	00 30       	cp.w	r0,r0
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	00 44       	or	r4,r0
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	00 60       	and	r0,r0
80002480:	00 00       	add	r0,r0
80002482:	0a 4d       	or	sp,r5
80002484:	80 01       	ld.sh	r1,r0[0x0]
80002486:	00 70       	tst	r0,r0

80002488 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002488:	eb cd 40 f8 	pushm	r3-r7,lr
8000248c:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000248e:	19 a5       	ld.ub	r5,r12[0x2]
80002490:	19 b8       	ld.ub	r8,r12[0x3]
80002492:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002496:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
80002498:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	49 6c       	lddpc	r12,800024f4 <AudioRoutingControl_brdcst_func+0x6c>
800024a0:	f0 1f 00 16 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a4:	2f fd       	sub	sp,-4
800024a6:	58 05       	cp.w	r5,0
800024a8:	c0 31       	brne	800024ae <AudioRoutingControl_brdcst_func+0x26>
800024aa:	30 07       	mov	r7,0
800024ac:	c1 98       	rjmp	800024de <AudioRoutingControl_brdcst_func+0x56>
800024ae:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b0:	49 34       	lddpc	r4,800024fc <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b2:	49 43       	lddpc	r3,80002500 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024b8:	11 c8       	ld.ub	r8,r8[0x4]
800024ba:	1a d8       	st.w	--sp,r8
800024bc:	08 9c       	mov	r12,r4
800024be:	f0 1f 00 0f 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c2:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024c6:	11 d8       	ld.ub	r8,r8[0x5]
800024c8:	1a d8       	st.w	--sp,r8
800024ca:	06 9c       	mov	r12,r3
800024cc:	f0 1f 00 0b 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d0:	2f f7       	sub	r7,-1
800024d2:	5c 57       	castu.b	r7
800024d4:	2f ed       	sub	sp,-8
800024d6:	ee 05 19 00 	cp.h	r5,r7
800024da:	fe 9b ff ed 	brhi	800024b4 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024de:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e2:	0f c8       	ld.ub	r8,r7[0x4]
800024e4:	1a d8       	st.w	--sp,r8
800024e6:	48 8c       	lddpc	r12,80002504 <AudioRoutingControl_brdcst_func+0x7c>
800024e8:	f0 1f 00 04 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
800024ec:	2f fd       	sub	sp,-4
	
	
	
}
800024ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f2:	00 00       	add	r0,r0
800024f4:	80 01       	ld.sh	r1,r0[0x0]
800024f6:	00 88       	andn	r8,r0
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	9a 54       	ld.sh	r4,sp[0xa]
800024fc:	80 01       	ld.sh	r1,r0[0x0]
800024fe:	00 a0       	st.w	r0++,r0
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	00 b8       	st.h	r0++,r8
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	00 d0       	st.w	--r0,r0

80002508 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002508:	eb cd 40 80 	pushm	r7,lr
8000250c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000250e:	19 a9       	ld.ub	r9,r12[0x2]
80002510:	30 08       	mov	r8,0
80002512:	f0 09 18 00 	cp.b	r9,r8
80002516:	c0 61       	brne	80002522 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
80002518:	48 8c       	lddpc	r12,80002538 <AudioRoutingControl_reply_func+0x30>
8000251a:	f0 1f 00 09 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
8000251e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002522:	48 8c       	lddpc	r12,80002540 <AudioRoutingControl_reply_func+0x38>
80002524:	f0 1f 00 06 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002528:	0f a8       	ld.ub	r8,r7[0x2]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 6c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x3c>
8000252e:	f0 1f 00 04 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
80002538:	80 01       	ld.sh	r1,r0[0x0]
8000253a:	00 ec       	st.h	--r0,r12
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	9a 54       	ld.sh	r4,sp[0xa]
80002540:	80 01       	ld.sh	r1,r0[0x0]
80002542:	00 fc       	st.b	--r0,r12
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	01 10       	ld.sh	r0,r0++

80002548 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002550:	0f 89       	ld.ub	r9,r7[0x0]
80002552:	0f 98       	ld.ub	r8,r7[0x1]
80002554:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002558:	1a d8       	st.w	--sp,r8
8000255a:	48 6c       	lddpc	r12,80002570 <Volume_brdcst_func+0x28>
8000255c:	f0 1f 00 06 	mcall	80002574 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002560:	0f b8       	ld.ub	r8,r7[0x3]
80002562:	1a d8       	st.w	--sp,r8
80002564:	48 5c       	lddpc	r12,80002578 <Volume_brdcst_func+0x30>
80002566:	f0 1f 00 04 	mcall	80002574 <Volume_brdcst_func+0x2c>
8000256a:	2f ed       	sub	sp,-8
	
	
}
8000256c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002570:	80 01       	ld.sh	r1,r0[0x0]
80002572:	01 30       	ld.ub	r0,r0++
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	9a 54       	ld.sh	r4,sp[0xa]
80002578:	80 01       	ld.sh	r1,r0[0x0]
8000257a:	01 4c       	ld.w	r12,--r0

8000257c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002580:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002584:	0f 89       	ld.ub	r9,r7[0x0]
80002586:	30 08       	mov	r8,0
80002588:	f0 09 18 00 	cp.b	r9,r8
8000258c:	c1 b1       	brne	800025c2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000258e:	0f b8       	ld.ub	r8,r7[0x3]
80002590:	31 09       	mov	r9,16
80002592:	f2 08 18 00 	cp.b	r8,r9
80002596:	c0 f1       	brne	800025b4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002598:	48 dc       	lddpc	r12,800025cc <Volume_reply_func+0x50>
8000259a:	f0 1f 00 0e 	mcall	800025d0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000259e:	0f 99       	ld.ub	r9,r7[0x1]
800025a0:	0f a8       	ld.ub	r8,r7[0x2]
800025a2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025a6:	1a d8       	st.w	--sp,r8
800025a8:	48 bc       	lddpc	r12,800025d4 <Volume_reply_func+0x58>
800025aa:	f0 1f 00 0a 	mcall	800025d0 <Volume_reply_func+0x54>
800025ae:	2f fd       	sub	sp,-4
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b4:	1a d8       	st.w	--sp,r8
800025b6:	48 9c       	lddpc	r12,800025d8 <Volume_reply_func+0x5c>
800025b8:	f0 1f 00 06 	mcall	800025d0 <Volume_reply_func+0x54>
800025bc:	2f fd       	sub	sp,-4
800025be:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c2:	48 7c       	lddpc	r12,800025dc <Volume_reply_func+0x60>
800025c4:	f0 1f 00 03 	mcall	800025d0 <Volume_reply_func+0x54>
800025c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025cc:	80 01       	ld.sh	r1,r0[0x0]
800025ce:	01 68       	ld.uh	r8,--r0
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	9a 54       	ld.sh	r4,sp[0xa]
800025d4:	80 01       	ld.sh	r1,r0[0x0]
800025d6:	01 30       	ld.ub	r0,r0++
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	01 7c       	ld.ub	r12,--r0
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	01 94       	ld.ub	r4,r0[0x1]

800025e0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e2:	19 d9       	ld.ub	r9,r12[0x5]
800025e4:	30 08       	mov	r8,0
800025e6:	f0 09 18 00 	cp.b	r9,r8
800025ea:	c0 91       	brne	800025fc <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025ec:	48 89       	lddpc	r9,8000260c <spk_brdcst_func+0x2c>
800025ee:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f0:	48 89       	lddpc	r9,80002610 <spk_brdcst_func+0x30>
800025f2:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f4:	48 8c       	lddpc	r12,80002614 <spk_brdcst_func+0x34>
800025f6:	f0 1f 00 09 	mcall	80002618 <spk_brdcst_func+0x38>
800025fa:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025fc:	30 19       	mov	r9,1
800025fe:	48 58       	lddpc	r8,80002610 <spk_brdcst_func+0x30>
80002600:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
80002602:	48 7c       	lddpc	r12,8000261c <spk_brdcst_func+0x3c>
80002604:	f0 1f 00 05 	mcall	80002618 <spk_brdcst_func+0x38>
80002608:	d8 02       	popm	pc
8000260a:	00 00       	add	r0,r0
8000260c:	00 00       	add	r0,r0
8000260e:	0a 4d       	or	sp,r5
80002610:	00 00       	add	r0,r0
80002612:	0a 54       	eor	r4,r5
80002614:	80 01       	ld.sh	r1,r0[0x0]
80002616:	01 ac       	ld.ub	r12,r0[0x2]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	9a 54       	ld.sh	r4,sp[0xa]
8000261c:	80 01       	ld.sh	r1,r0[0x0]
8000261e:	01 bc       	ld.ub	r12,r0[0x3]

80002620 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002620:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002622:	19 a9       	ld.ub	r9,r12[0x2]
80002624:	30 08       	mov	r8,0
80002626:	f0 09 18 00 	cp.b	r9,r8
8000262a:	c0 f1       	brne	80002648 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000262c:	19 e9       	ld.ub	r9,r12[0x6]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 40       	breq	8000263a <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002634:	30 19       	mov	r9,1
80002636:	48 78       	lddpc	r8,80002650 <spk_reply_func+0x30>
80002638:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263a:	19 e8       	ld.ub	r8,r12[0x6]
8000263c:	1a d8       	st.w	--sp,r8
8000263e:	48 6c       	lddpc	r12,80002654 <spk_reply_func+0x34>
80002640:	f0 1f 00 06 	mcall	80002658 <spk_reply_func+0x38>
80002644:	2f fd       	sub	sp,-4
80002646:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002648:	48 5c       	lddpc	r12,8000265c <spk_reply_func+0x3c>
8000264a:	f0 1f 00 04 	mcall	80002658 <spk_reply_func+0x38>
8000264e:	d8 02       	popm	pc
80002650:	00 00       	add	r0,r0
80002652:	0a 4d       	or	sp,r5
80002654:	80 01       	ld.sh	r1,r0[0x0]
80002656:	01 c8       	ld.ub	r8,r0[0x4]
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	9a 54       	ld.sh	r4,sp[0xa]
8000265c:	80 01       	ld.sh	r1,r0[0x0]
8000265e:	01 d8       	ld.ub	r8,r0[0x5]

80002660 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002660:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002664:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002668:	49 ac       	lddpc	r12,800026d0 <mic_reply_func+0x70>
8000266a:	f0 1f 00 1b 	mcall	800026d4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000266e:	0f 89       	ld.ub	r9,r7[0x0]
80002670:	30 08       	mov	r8,0
80002672:	f0 09 18 00 	cp.b	r9,r8
80002676:	c2 71       	brne	800026c4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002678:	0f 98       	ld.ub	r8,r7[0x1]
8000267a:	30 29       	mov	r9,2
8000267c:	f2 08 18 00 	cp.b	r8,r9
80002680:	c1 b1       	brne	800026b6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002682:	49 6c       	lddpc	r12,800026d8 <mic_reply_func+0x78>
80002684:	f0 1f 00 14 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002688:	0f a8       	ld.ub	r8,r7[0x2]
8000268a:	1a d8       	st.w	--sp,r8
8000268c:	49 4c       	lddpc	r12,800026dc <mic_reply_func+0x7c>
8000268e:	f0 1f 00 12 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002692:	0f b8       	ld.ub	r8,r7[0x3]
80002694:	1a d8       	st.w	--sp,r8
80002696:	49 3c       	lddpc	r12,800026e0 <mic_reply_func+0x80>
80002698:	f0 1f 00 0f 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000269c:	0f c8       	ld.ub	r8,r7[0x4]
8000269e:	1a d8       	st.w	--sp,r8
800026a0:	49 1c       	lddpc	r12,800026e4 <mic_reply_func+0x84>
800026a2:	f0 1f 00 0d 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026a6:	0f d8       	ld.ub	r8,r7[0x5]
800026a8:	1a d8       	st.w	--sp,r8
800026aa:	49 0c       	lddpc	r12,800026e8 <mic_reply_func+0x88>
800026ac:	f0 1f 00 0a 	mcall	800026d4 <mic_reply_func+0x74>
800026b0:	2f cd       	sub	sp,-16
800026b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026b6:	1a d8       	st.w	--sp,r8
800026b8:	48 dc       	lddpc	r12,800026ec <mic_reply_func+0x8c>
800026ba:	f0 1f 00 07 	mcall	800026d4 <mic_reply_func+0x74>
800026be:	2f fd       	sub	sp,-4
800026c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c4:	48 bc       	lddpc	r12,800026f0 <mic_reply_func+0x90>
800026c6:	f0 1f 00 04 	mcall	800026d4 <mic_reply_func+0x74>
800026ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ce:	00 00       	add	r0,r0
800026d0:	80 01       	ld.sh	r1,r0[0x0]
800026d2:	01 e4       	ld.ub	r4,r0[0x6]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	9a 54       	ld.sh	r4,sp[0xa]
800026d8:	80 01       	ld.sh	r1,r0[0x0]
800026da:	01 f4       	ld.ub	r4,r0[0x7]
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	02 08       	add	r8,r1
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	02 1c       	sub	r12,r1
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	02 38       	cp.w	r8,r1
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	02 50       	eor	r0,r1
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	02 68       	and	r8,r1
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	02 80       	andn	r0,r1

800026f4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026fc:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x34>
800026fe:	f0 1f 00 0c 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002702:	0f 88       	ld.ub	r8,r7[0x0]
80002704:	1a d8       	st.w	--sp,r8
80002706:	48 bc       	lddpc	r12,80002730 <dcm_brdcst_func+0x3c>
80002708:	f0 1f 00 09 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000270c:	0f a8       	ld.ub	r8,r7[0x2]
8000270e:	1a d8       	st.w	--sp,r8
80002710:	48 9c       	lddpc	r12,80002734 <dcm_brdcst_func+0x40>
80002712:	f0 1f 00 07 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002716:	0f 98       	ld.ub	r8,r7[0x1]
80002718:	1a d8       	st.w	--sp,r8
8000271a:	48 8c       	lddpc	r12,80002738 <dcm_brdcst_func+0x44>
8000271c:	f0 1f 00 04 	mcall	8000272c <dcm_brdcst_func+0x38>
80002720:	2f dd       	sub	sp,-12
	
	
}
80002722:	e3 cd 80 80 	ldm	sp++,r7,pc
80002726:	00 00       	add	r0,r0
80002728:	80 01       	ld.sh	r1,r0[0x0]
8000272a:	02 90       	mov	r0,r1
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	9a 54       	ld.sh	r4,sp[0xa]
80002730:	80 01       	ld.sh	r1,r0[0x0]
80002732:	02 a4       	st.w	r1++,r4
80002734:	80 01       	ld.sh	r1,r0[0x0]
80002736:	02 b8       	st.h	r1++,r8
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	02 d0       	st.w	--r1,r0

8000273c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000273c:	eb cd 40 80 	pushm	r7,lr
80002740:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002742:	19 a9       	ld.ub	r9,r12[0x2]
80002744:	30 08       	mov	r8,0
80002746:	f0 09 18 00 	cp.b	r9,r8
8000274a:	c1 b1       	brne	80002780 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000274c:	19 b8       	ld.ub	r8,r12[0x3]
8000274e:	30 19       	mov	r9,1
80002750:	f2 08 18 00 	cp.b	r8,r9
80002754:	c0 51       	brne	8000275e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002756:	48 ec       	lddpc	r12,8000278c <dcm_reply_func+0x50>
80002758:	f0 1f 00 0e 	mcall	80002790 <dcm_reply_func+0x54>
8000275c:	c0 a8       	rjmp	80002770 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 51       	brne	8000276a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002762:	48 dc       	lddpc	r12,80002794 <dcm_reply_func+0x58>
80002764:	f0 1f 00 0b 	mcall	80002790 <dcm_reply_func+0x54>
80002768:	c0 48       	rjmp	80002770 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276a:	48 cc       	lddpc	r12,80002798 <dcm_reply_func+0x5c>
8000276c:	f0 1f 00 09 	mcall	80002790 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002770:	0f d8       	ld.ub	r8,r7[0x5]
80002772:	1a d8       	st.w	--sp,r8
80002774:	48 ac       	lddpc	r12,8000279c <dcm_reply_func+0x60>
80002776:	f0 1f 00 07 	mcall	80002790 <dcm_reply_func+0x54>
8000277a:	2f fd       	sub	sp,-4
8000277c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002780:	48 8c       	lddpc	r12,800027a0 <dcm_reply_func+0x64>
80002782:	f0 1f 00 04 	mcall	80002790 <dcm_reply_func+0x54>
80002786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278a:	00 00       	add	r0,r0
8000278c:	80 01       	ld.sh	r1,r0[0x0]
8000278e:	02 ec       	st.h	--r1,r12
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	9a 54       	ld.sh	r4,sp[0xa]
80002794:	80 01       	ld.sh	r1,r0[0x0]
80002796:	03 00       	ld.w	r0,r1++
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	03 14       	ld.sh	r4,r1++
8000279c:	80 01       	ld.sh	r1,r0[0x0]
8000279e:	03 28       	ld.uh	r8,r1++
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	03 34       	ld.ub	r4,r1++

800027a4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a6:	19 a9       	ld.ub	r9,r12[0x2]
800027a8:	30 08       	mov	r8,0
800027aa:	f0 09 18 00 	cp.b	r9,r8
800027ae:	c0 51       	brne	800027b8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x1c>
800027b2:	f0 1f 00 05 	mcall	800027c4 <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b8:	48 4c       	lddpc	r12,800027c8 <ToneControl_reply_func+0x24>
800027ba:	f0 1f 00 03 	mcall	800027c4 <ToneControl_reply_func+0x20>
800027be:	d8 02       	popm	pc
800027c0:	80 01       	ld.sh	r1,r0[0x0]
800027c2:	03 40       	ld.w	r0,--r1
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	9a 54       	ld.sh	r4,sp[0xa]
800027c8:	80 01       	ld.sh	r1,r0[0x0]
800027ca:	03 48       	ld.w	r8,--r1

800027cc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027cc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 22 	mcall	80002854 <app_cfg+0x88>
800027d2:	4a 28       	lddpc	r8,80002858 <app_cfg+0x8c>
800027d4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027d6:	4a 27       	lddpc	r7,8000285c <app_cfg+0x90>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027d8:	4a 26       	lddpc	r6,80002860 <app_cfg+0x94>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027da:	4a 35       	lddpc	r5,80002864 <app_cfg+0x98>
800027dc:	4a 34       	lddpc	r4,80002868 <app_cfg+0x9c>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
800027de:	4a 43       	lddpc	r3,8000286c <app_cfg+0xa0>
800027e0:	4a 42       	lddpc	r2,80002870 <app_cfg+0xa4>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027e2:	30 41       	mov	r1,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027e4:	30 20       	mov	r0,2
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027e6:	6e 08       	ld.w	r8,r7[0x0]
800027e8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027ec:	58 38       	cp.w	r8,3
800027ee:	c2 d1       	brne	80002848 <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027f0:	6c 08       	ld.w	r8,r6[0x0]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c0 61       	brne	80002800 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027f6:	f0 1f 00 20 	mcall	80002874 <app_cfg+0xa8>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fa:	30 18       	mov	r8,1
800027fc:	8d 08       	st.w	r6[0x0],r8
800027fe:	c1 58       	rjmp	80002828 <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
80002800:	58 18       	cp.w	r8,1
80002802:	c0 51       	brne	8000280c <app_cfg+0x40>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002804:	f0 1f 00 1d 	mcall	80002878 <app_cfg+0xac>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002808:	8d 00       	st.w	r6[0x0],r0
8000280a:	c0 f8       	rjmp	80002828 <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
8000280c:	58 28       	cp.w	r8,2
8000280e:	c0 61       	brne	8000281a <app_cfg+0x4e>
				{
					
					//xcmp_volume_control();
					//xcmp_data_session();
					xcmp_audio_route_AMBE();
80002810:	f0 1f 00 1b 	mcall	8000287c <app_cfg+0xb0>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002814:	30 38       	mov	r8,3
80002816:	8d 08       	st.w	r6[0x0],r8
80002818:	c0 88       	rjmp	80002828 <app_cfg+0x5c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000281a:	58 38       	cp.w	r8,3
8000281c:	ed f1 0a 00 	st.weq	r6[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
80002820:	f7 b8 01 ff 	subne	r8,-1
80002824:	ed f8 1a 00 	st.wne	r6[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
80002828:	09 88       	ld.ub	r8,r4[0x0]
8000282a:	1a d8       	st.w	--sp,r8
8000282c:	0a 9c       	mov	r12,r5
8000282e:	f0 1f 00 15 	mcall	80002880 <app_cfg+0xb4>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
80002832:	05 88       	ld.ub	r8,r2[0x0]
80002834:	1a d8       	st.w	--sp,r8
80002836:	06 9c       	mov	r12,r3
80002838:	f0 1f 00 12 	mcall	80002880 <app_cfg+0xb4>
				//log("\n\r VF_SN: %x \n\r",  VF_SN);
				//log("\n\r time: %d \n\r", tc_tick);
				
				if(isAudioRouting  == 6)
8000283c:	2f ed       	sub	sp,-8
8000283e:	6c 08       	ld.w	r8,r6[0x0]
80002840:	58 68       	cp.w	r8,6
80002842:	c0 31       	brne	80002848 <app_cfg+0x7c>
					
					//xcmp_audio_route_speaker();
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					xcmp_exit_device_control_mode();
80002844:	f0 1f 00 10 	mcall	80002884 <app_cfg+0xb8>
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
80002848:	e0 6b 0f a0 	mov	r11,4000
8000284c:	48 3c       	lddpc	r12,80002858 <app_cfg+0x8c>
8000284e:	f0 1f 00 0f 	mcall	80002888 <app_cfg+0xbc>
	}
80002852:	cc ab       	rjmp	800027e6 <app_cfg+0x1a>
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	93 c8       	st.w	r9[0x30],r8
80002858:	00 00       	add	r0,r0
8000285a:	0a 48       	or	r8,r5
8000285c:	00 00       	add	r0,r0
8000285e:	12 c4       	st.b	r9++,r4
80002860:	00 00       	add	r0,r0
80002862:	0a 40       	or	r0,r5
80002864:	80 01       	ld.sh	r1,r0[0x0]
80002866:	03 54       	ld.sh	r4,--r1
80002868:	00 00       	add	r0,r0
8000286a:	0a 4d       	or	sp,r5
8000286c:	80 01       	ld.sh	r1,r0[0x0]
8000286e:	03 64       	ld.uh	r4,--r1
80002870:	00 00       	add	r0,r0
80002872:	0a 44       	or	r4,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	4e 18       	lddpc	r8,800029f8 <SD_LowLevel_Init+0x60>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	4e 90       	lddpc	r0,80002a1c <SD_ReadByte+0xc>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	4e 44       	lddpc	r4,80002a0c <SD_LowLevel_Init+0x74>
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	9a 54       	ld.sh	r4,sp[0xa]
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	4d e8       	lddpc	r8,800029fc <SD_LowLevel_Init+0x64>
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	95 30       	st.w	r10[0xc],r0

8000288c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000288c:	eb cd 40 80 	pushm	r7,lr
80002890:	18 97       	mov	r7,r12
  log("R");
80002892:	48 6c       	lddpc	r12,800028a8 <app_payload_tx_proc+0x1c>
80002894:	f0 1f 00 06 	mcall	800028ac <app_payload_tx_proc+0x20>
  //fl_write("voice.dat", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  
  //vTaskDelay(100);
  
  //payload_fragment_t * ptr = (payload_fragment_t *)payload;
  set_payload_idle(payload);
80002898:	48 68       	lddpc	r8,800028b0 <app_payload_tx_proc+0x24>
8000289a:	70 0c       	ld.w	r12,r8[0x0]
8000289c:	0e 9b       	mov	r11,r7
8000289e:	f0 1f 00 06 	mcall	800028b4 <app_payload_tx_proc+0x28>

//

}
800028a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028a6:	00 00       	add	r0,r0
800028a8:	80 01       	ld.sh	r1,r0[0x0]
800028aa:	03 78       	ld.ub	r8,--r1
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	9a 54       	ld.sh	r4,sp[0xa]
800028b0:	00 00       	add	r0,r0
800028b2:	0f 98       	ld.ub	r8,r7[0x1]
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	3a 50       	mov	r0,-91

800028b8 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028b8:	eb cd 40 80 	pushm	r7,lr
800028bc:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
800028be:	49 0c       	lddpc	r12,800028fc <app_payload_rx_proc+0x44>
800028c0:	f0 1f 00 10 	mcall	80002900 <app_payload_rx_proc+0x48>
	if (AMBE_flag)
800028c4:	49 08       	lddpc	r8,80002904 <app_payload_rx_proc+0x4c>
800028c6:	11 89       	ld.ub	r9,r8[0x0]
800028c8:	30 08       	mov	r8,0
800028ca:	f0 09 18 00 	cp.b	r9,r8
800028ce:	c0 90       	breq	800028e0 <app_payload_rx_proc+0x28>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028d0:	e0 69 02 00 	mov	r9,512
800028d4:	0e 9a       	mov	r10,r7
800028d6:	3f fb       	mov	r11,-1
800028d8:	48 cc       	lddpc	r12,80002908 <app_payload_rx_proc+0x50>
800028da:	f0 1f 00 0d 	mcall	8000290c <app_payload_rx_proc+0x54>
800028de:	c0 88       	rjmp	800028ee <app_payload_rx_proc+0x36>
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028e0:	e0 69 02 00 	mov	r9,512
800028e4:	0e 9a       	mov	r10,r7
800028e6:	3f fb       	mov	r11,-1
800028e8:	48 ac       	lddpc	r12,80002910 <app_payload_rx_proc+0x58>
800028ea:	f0 1f 00 09 	mcall	8000290c <app_payload_rx_proc+0x54>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028ee:	48 a8       	lddpc	r8,80002914 <app_payload_rx_proc+0x5c>
800028f0:	70 0c       	ld.w	r12,r8[0x0]
800028f2:	0e 9b       	mov	r11,r7
800028f4:	f0 1f 00 09 	mcall	80002918 <app_payload_rx_proc+0x60>

}
800028f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028fc:	80 01       	ld.sh	r1,r0[0x0]
800028fe:	03 7c       	ld.ub	r12,--r1
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	9a 54       	ld.sh	r4,sp[0xa]
80002904:	00 00       	add	r0,r0
80002906:	0a 44       	or	r4,r5
80002908:	80 01       	ld.sh	r1,r0[0x0]
8000290a:	03 88       	ld.ub	r8,r1[0x0]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	35 38       	mov	r8,83
80002910:	80 01       	ld.sh	r1,r0[0x0]
80002912:	03 94       	ld.ub	r4,r1[0x1]
80002914:	00 00       	add	r0,r0
80002916:	0f 98       	ld.ub	r8,r7[0x1]
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	3a 50       	mov	r0,-91

8000291c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000291c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000291e:	19 e8       	ld.ub	r8,r12[0x6]
80002920:	30 19       	mov	r9,1
80002922:	f2 08 18 00 	cp.b	r8,r9
80002926:	c0 61       	brne	80002932 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002928:	48 98       	lddpc	r8,8000294c <DeviceInitializationStatus_brdcst_func+0x30>
8000292a:	70 09       	ld.w	r9,r8[0x0]
8000292c:	a1 a9       	sbr	r9,0x0
8000292e:	91 09       	st.w	r8[0x0],r9
80002930:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002932:	30 29       	mov	r9,2
80002934:	f2 08 18 00 	cp.b	r8,r9
80002938:	c0 80       	breq	80002948 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000293a:	48 58       	lddpc	r8,8000294c <DeviceInitializationStatus_brdcst_func+0x30>
8000293c:	70 09       	ld.w	r9,r8[0x0]
8000293e:	e0 19 ff fc 	andl	r9,0xfffc
80002942:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002944:	f0 1f 00 03 	mcall	80002950 <DeviceInitializationStatus_brdcst_func+0x34>
80002948:	d8 02       	popm	pc
8000294a:	00 00       	add	r0,r0
8000294c:	00 00       	add	r0,r0
8000294e:	12 c4       	st.b	r9++,r4
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	4e b4       	lddpc	r4,80002afc <SD_WriteByte+0x34>

80002954 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002954:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
80002956:	48 78       	lddpc	r8,80002970 <SD_SPI_SetSpeed+0x1c>
80002958:	70 09       	ld.w	r9,r8[0x0]
8000295a:	72 ca       	ld.w	r10,r9[0x30]
8000295c:	5c 7c       	castu.h	r12
8000295e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002962:	f9 ea 10 0a 	or	r10,r12,r10
80002966:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
80002968:	70 0c       	ld.w	r12,r8[0x0]
8000296a:	f0 1f 00 03 	mcall	80002974 <SD_SPI_SetSpeed+0x20>
	
 
}
8000296e:	d8 02       	popm	pc
80002970:	00 00       	add	r0,r0
80002972:	12 c8       	st.b	r9++,r8
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	5c 18       	scr	r8

80002978 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
80002978:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
8000297a:	e0 6c 01 00 	mov	r12,256
8000297e:	f0 1f 00 02 	mcall	80002984 <SD_SPI_SetSpeedHi+0xc>

}
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	29 54       	sub	r4,-107

80002988 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
80002988:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
8000298a:	e0 6c ff 00 	mov	r12,65280
8000298e:	f0 1f 00 02 	mcall	80002994 <SD_SPI_SetSpeedLow+0xc>


	
}
80002992:	d8 02       	popm	pc
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	29 54       	sub	r4,-107

80002998 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
80002998:	eb cd 40 c0 	pushm	r6-r7,lr
8000299c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000299e:	49 58       	lddpc	r8,800029f0 <SD_LowLevel_Init+0x58>
800029a0:	1a 96       	mov	r6,sp
800029a2:	f0 ea 00 00 	ld.d	r10,r8[0]
800029a6:	fa eb 00 00 	st.d	sp[0],r10
800029aa:	f0 e8 00 08 	ld.d	r8,r8[8]
800029ae:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
800029b2:	30 4b       	mov	r11,4
800029b4:	49 0c       	lddpc	r12,800029f4 <SD_LowLevel_Init+0x5c>
800029b6:	f0 1f 00 11 	mcall	800029f8 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
800029ba:	49 17       	lddpc	r7,800029fc <SD_LowLevel_Init+0x64>
800029bc:	fe 7c 24 00 	mov	r12,-56320
800029c0:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800029c2:	1a 9b       	mov	r11,sp
800029c4:	f0 1f 00 0f 	mcall	80002a00 <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800029c8:	30 09       	mov	r9,0
800029ca:	12 9a       	mov	r10,r9
800029cc:	12 9b       	mov	r11,r9
800029ce:	6e 0c       	ld.w	r12,r7[0x0]
800029d0:	f0 1f 00 0d 	mcall	80002a04 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
800029d4:	6e 0c       	ld.w	r12,r7[0x0]
800029d6:	f0 1f 00 0d 	mcall	80002a08 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
800029da:	e0 6a 36 00 	mov	r10,13824
800029de:	ea 1a 01 6e 	orh	r10,0x16e
800029e2:	1a 9b       	mov	r11,sp
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 0a 	mcall	80002a0c <SD_LowLevel_Init+0x74>
	return;
	}


	
}
800029ea:	2f cd       	sub	sp,-16
800029ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029f0:	80 01       	ld.sh	r1,r0[0x0]
800029f2:	03 b4       	ld.ub	r4,r1[0x3]
800029f4:	80 01       	ld.sh	r1,r0[0x0]
800029f6:	03 c4       	ld.ub	r4,r1[0x4]
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	9e f4       	ld.uh	r4,pc[0xe]
800029fc:	00 00       	add	r0,r0
800029fe:	12 c8       	st.b	r9++,r8
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	5a 80       	cp.w	r0,-24
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	5a b8       	cp.w	r8,-21
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	5c 18       	scr	r8
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	5b 56       	cp.w	r6,-11

80002a10 <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
80002a10:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a14:	48 b7       	lddpc	r7,80002a40 <SD_ReadByte+0x30>
80002a16:	30 0b       	mov	r11,0
80002a18:	6e 0c       	ld.w	r12,r7[0x0]
80002a1a:	f0 1f 00 0b 	mcall	80002a44 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
80002a1e:	e0 6b 00 ff 	mov	r11,255
80002a22:	6e 0c       	ld.w	r12,r7[0x0]
80002a24:	f0 1f 00 09 	mcall	80002a48 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
80002a28:	30 06       	mov	r6,0
80002a2a:	0c 9b       	mov	r11,r6
80002a2c:	6e 0c       	ld.w	r12,r7[0x0]
80002a2e:	f0 1f 00 08 	mcall	80002a4c <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002a32:	0c 9b       	mov	r11,r6
80002a34:	6e 0c       	ld.w	r12,r7[0x0]
80002a36:	f0 1f 00 07 	mcall	80002a50 <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
80002a3a:	0d 9c       	ld.ub	r12,r6[0x1]
80002a3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a40:	00 00       	add	r0,r0
80002a42:	12 c8       	st.b	r9++,r8
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	5a e4       	cp.w	r4,-18
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	5c 1e       	scr	lr
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	5c 3a       	neg	r10
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	5b 30       	cp.w	r0,-13

80002a54 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a54:	eb cd 40 c0 	pushm	r6-r7,lr
80002a58:	18 96       	mov	r6,r12
80002a5a:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a5e:	c0 28       	rjmp	80002a62 <SD_GetResponse+0xe>
  {
    Count--;
80002a60:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a62:	f0 1f 00 09 	mcall	80002a84 <SD_GetResponse+0x30>
80002a66:	ec 0c 18 00 	cp.b	r12,r6
80002a6a:	c0 40       	breq	80002a72 <SD_GetResponse+0x1e>
80002a6c:	58 07       	cp.w	r7,0
80002a6e:	cf 91       	brne	80002a60 <SD_GetResponse+0xc>
80002a70:	c0 58       	rjmp	80002a7a <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002a72:	58 07       	cp.w	r7,0
80002a74:	c0 30       	breq	80002a7a <SD_GetResponse+0x26>
80002a76:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002a7a:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002a7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a82:	00 00       	add	r0,r0
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	2a 10       	sub	r0,-95

80002a88 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002a88:	eb cd 40 f8 	pushm	r3-r7,lr
80002a8c:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002a8e:	30 b5       	mov	r5,11
80002a90:	30 d4       	mov	r4,13
80002a92:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002a94:	f0 1f 00 0c 	mcall	80002ac4 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002a98:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002a9c:	ea 07 18 00 	cp.b	r7,r5
80002aa0:	c0 e0       	breq	80002abc <SD_GetDataResponse+0x34>
80002aa2:	e8 07 18 00 	cp.b	r7,r4
80002aa6:	c0 b0       	breq	80002abc <SD_GetDataResponse+0x34>
80002aa8:	e6 07 18 00 	cp.b	r7,r3
80002aac:	c0 50       	breq	80002ab6 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002aae:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002ab0:	e0 46 00 41 	cp.w	r6,65
80002ab4:	cf 01       	brne	80002a94 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002ab6:	f0 1f 00 04 	mcall	80002ac4 <SD_GetDataResponse+0x3c>
80002aba:	cf e0       	breq	80002ab6 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002abc:	0e 9c       	mov	r12,r7
80002abe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	2a 10       	sub	r0,-95

80002ac8 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80002acc:	20 1d       	sub	sp,4
80002ace:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002ad0:	48 c7       	lddpc	r7,80002b00 <SD_WriteByte+0x38>
80002ad2:	30 0b       	mov	r11,0
80002ad4:	6e 0c       	ld.w	r12,r7[0x0]
80002ad6:	f0 1f 00 0c 	mcall	80002b04 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002ada:	1b 8b       	ld.ub	r11,sp[0x0]
80002adc:	6e 0c       	ld.w	r12,r7[0x0]
80002ade:	f0 1f 00 0b 	mcall	80002b08 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002ae2:	1a 9b       	mov	r11,sp
80002ae4:	6e 0c       	ld.w	r12,r7[0x0]
80002ae6:	f0 1f 00 0a 	mcall	80002b0c <SD_WriteByte+0x44>
80002aea:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002aec:	30 0b       	mov	r11,0
80002aee:	6e 0c       	ld.w	r12,r7[0x0]
80002af0:	f0 1f 00 08 	mcall	80002b10 <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002af4:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002af8:	2f fd       	sub	sp,-4
80002afa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002afe:	00 00       	add	r0,r0
80002b00:	00 00       	add	r0,r0
80002b02:	12 c8       	st.b	r9++,r8
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	5a e4       	cp.w	r4,-18
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	5c 1e       	scr	lr
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	5c 3a       	neg	r10
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	5b 30       	cp.w	r0,-13

80002b14 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002b14:	eb cd 40 c0 	pushm	r6-r7,lr
80002b18:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002b1a:	a7 ac       	sbr	r12,0x6
80002b1c:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002b1e:	f6 08 16 18 	lsr	r8,r11,0x18
80002b22:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002b24:	f6 08 16 10 	lsr	r8,r11,0x10
80002b28:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002b2a:	f6 08 16 08 	lsr	r8,r11,0x8
80002b2e:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002b30:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002b32:	ba da       	st.b	sp[0x5],r10
80002b34:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002b36:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002b3a:	0f 3c       	ld.ub	r12,r7++
80002b3c:	f0 1f 00 04 	mcall	80002b4c <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002b40:	0c 37       	cp.w	r7,r6
80002b42:	cf c1       	brne	80002b3a <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002b44:	2f ed       	sub	sp,-8
80002b46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b4a:	00 00       	add	r0,r0
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	2a c8       	sub	r8,-84

80002b50 <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b50:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b52:	31 8c       	mov	r12,24
80002b54:	f0 1f 00 6a 	mcall	80002cfc <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b58:	e0 6a 00 95 	mov	r10,149
80002b5c:	30 0b       	mov	r11,0
80002b5e:	16 9c       	mov	r12,r11
80002b60:	f0 1f 00 68 	mcall	80002d00 <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002b64:	30 1c       	mov	r12,1
80002b66:	f0 1f 00 68 	mcall	80002d04 <SD_GoIdleState+0x1b4>
80002b6a:	e0 81 00 a8 	brne	80002cba <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002b6e:	e0 6a 00 87 	mov	r10,135
80002b72:	e0 6b 01 aa 	mov	r11,426
80002b76:	30 8c       	mov	r12,8
80002b78:	f0 1f 00 62 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002b7c:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b80:	3f f6       	mov	r6,-1
80002b82:	c0 38       	rjmp	80002b88 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002b84:	20 17       	sub	r7,1
80002b86:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b88:	f0 1f 00 60 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002b8c:	ec 0c 18 00 	cp.b	r12,r6
80002b90:	c0 41       	brne	80002b98 <SD_GoIdleState+0x48>
80002b92:	58 07       	cp.w	r7,0
80002b94:	cf 81       	brne	80002b84 <SD_GoIdleState+0x34>
80002b96:	c2 68       	rjmp	80002be2 <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002b98:	30 58       	mov	r8,5
80002b9a:	f0 0c 18 00 	cp.b	r12,r8
80002b9e:	c2 21       	brne	80002be2 <SD_GoIdleState+0x92>
80002ba0:	c9 48       	rjmp	80002cc8 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002ba2:	08 9c       	mov	r12,r4
80002ba4:	f0 1f 00 5a 	mcall	80002d0c <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002ba8:	06 9c       	mov	r12,r3
80002baa:	f0 1f 00 5a 	mcall	80002d10 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002bae:	08 9c       	mov	r12,r4
80002bb0:	f0 1f 00 53 	mcall	80002cfc <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002bb4:	06 9a       	mov	r10,r3
80002bb6:	0a 9b       	mov	r11,r5
80002bb8:	02 9c       	mov	r12,r1
80002bba:	f0 1f 00 52 	mcall	80002d00 <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002bbe:	2f f6       	sub	r6,-1
80002bc0:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002bc2:	e4 06 19 00 	cp.h	r6,r2
80002bc6:	c0 60       	breq	80002bd2 <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002bc8:	0a 9c       	mov	r12,r5
80002bca:	f0 1f 00 4f 	mcall	80002d04 <SD_GoIdleState+0x1b4>
80002bce:	18 97       	mov	r7,r12
    }
    while (Status);
80002bd0:	ce 91       	brne	80002ba2 <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002bd2:	31 8c       	mov	r12,24
80002bd4:	f0 1f 00 4e 	mcall	80002d0c <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002bd8:	e0 6c 00 ff 	mov	r12,255
80002bdc:	f0 1f 00 4d 	mcall	80002d10 <SD_GoIdleState+0x1c0>
80002be0:	c6 f8       	rjmp	80002cbe <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002be2:	f0 1f 00 4a 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002be6:	f0 1f 00 49 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bea:	f0 1f 00 48 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bee:	f0 1f 00 47 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bf2:	f0 1f 00 46 	mcall	80002d08 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002bf6:	31 8c       	mov	r12,24
80002bf8:	f0 1f 00 45 	mcall	80002d0c <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bfc:	e0 6c 00 ff 	mov	r12,255
80002c00:	f0 1f 00 44 	mcall	80002d10 <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002c04:	31 8c       	mov	r12,24
80002c06:	f0 1f 00 3e 	mcall	80002cfc <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c0a:	e0 6c 00 ff 	mov	r12,255
80002c0e:	f0 1f 00 41 	mcall	80002d10 <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c12:	e0 6c 00 ff 	mov	r12,255
80002c16:	f0 1f 00 3f 	mcall	80002d10 <SD_GoIdleState+0x1c0>
80002c1a:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c1e:	08 91       	mov	r1,r4
80002c20:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002c22:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c24:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c26:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c2a:	02 9a       	mov	r10,r1
80002c2c:	04 9b       	mov	r11,r2
80002c2e:	33 7c       	mov	r12,55
80002c30:	f0 1f 00 34 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002c34:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002c36:	f0 1f 00 35 	mcall	80002d08 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002c3a:	f8 05 18 00 	cp.b	r5,r12
80002c3e:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c42:	2f f7       	sub	r7,-1
80002c44:	5c 87       	casts.h	r7
80002c46:	e6 07 19 00 	cp.h	r7,r3
80002c4a:	cf 61       	brne	80002c36 <SD_GoIdleState+0xe6>
80002c4c:	08 90       	mov	r0,r4
80002c4e:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c50:	04 9a       	mov	r10,r2
80002c52:	fc 1b 40 00 	movh	r11,0x4000
80002c56:	32 9c       	mov	r12,41
80002c58:	f0 1f 00 2a 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002c5c:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c5e:	f0 1f 00 2b 	mcall	80002d08 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c62:	c3 00       	breq	80002cc2 <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c64:	2f f7       	sub	r7,-1
80002c66:	5c 87       	casts.h	r7
80002c68:	ec 07 19 00 	cp.h	r7,r6
80002c6c:	cf 91       	brne	80002c5e <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c6e:	e0 c4 00 01 	sub	r4,r0,1
80002c72:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002c74:	30 08       	mov	r8,0
80002c76:	f0 0c 18 00 	cp.b	r12,r8
80002c7a:	5f 1a       	srne	r10
80002c7c:	30 09       	mov	r9,0
80002c7e:	f2 04 19 00 	cp.h	r4,r9
80002c82:	5f 19       	srne	r9
80002c84:	f5 e9 00 09 	and	r9,r10,r9
80002c88:	f0 09 18 00 	cp.b	r9,r8
80002c8c:	cc f1       	brne	80002c2a <SD_GoIdleState+0xda>

    if(n==0)
80002c8e:	58 04       	cp.w	r4,0
80002c90:	c1 50       	breq	80002cba <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002c92:	30 0a       	mov	r10,0
80002c94:	14 9b       	mov	r11,r10
80002c96:	33 ac       	mov	r12,58
80002c98:	f0 1f 00 1a 	mcall	80002d00 <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002c9c:	f0 1f 00 1b 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca0:	f0 1f 00 1a 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca4:	f0 1f 00 19 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca8:	f0 1f 00 18 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002cac:	f0 1f 00 17 	mcall	80002d08 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002cb0:	30 19       	mov	r9,1
80002cb2:	49 98       	lddpc	r8,80002d14 <SD_GoIdleState+0x1c4>
80002cb4:	b0 89       	st.b	r8[0x0],r9
80002cb6:	30 07       	mov	r7,0
80002cb8:	c0 38       	rjmp	80002cbe <SD_GoIdleState+0x16e>
80002cba:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002cbe:	0e 9c       	mov	r12,r7
80002cc0:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002cc2:	20 14       	sub	r4,1
80002cc4:	5c 84       	casts.h	r4
80002cc6:	ce 4b       	rjmp	80002c8e <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cc8:	31 8c       	mov	r12,24
80002cca:	f0 1f 00 11 	mcall	80002d0c <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cce:	e0 6c 00 ff 	mov	r12,255
80002cd2:	f0 1f 00 10 	mcall	80002d10 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002cd6:	31 8c       	mov	r12,24
80002cd8:	f0 1f 00 09 	mcall	80002cfc <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cdc:	e0 6a 00 ff 	mov	r10,255
80002ce0:	30 0b       	mov	r11,0
80002ce2:	30 1c       	mov	r12,1
80002ce4:	f0 1f 00 07 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002ce8:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002cea:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cec:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cee:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cf2:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002cf4:	e0 62 00 f0 	mov	r2,240
80002cf8:	c6 8b       	rjmp	80002bc8 <SD_GoIdleState+0x78>
80002cfa:	00 00       	add	r0,r0
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	9f 40       	st.w	pc[0x10],r0
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	2b 14       	sub	r4,-79
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	2a 54       	sub	r4,-91
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	2a 10       	sub	r0,-95
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	9f 24       	st.w	pc[0x8],r4
80002d10:	80 00       	ld.sh	r0,r0[0x0]
80002d12:	2a c8       	sub	r8,-84
80002d14:	00 00       	add	r0,r0
80002d16:	0a 68       	and	r8,r5

80002d18 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002d18:	eb cd 40 e0 	pushm	r5-r7,lr
80002d1c:	20 4d       	sub	sp,16
80002d1e:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002d20:	31 8c       	mov	r12,24
80002d22:	f0 1f 00 44 	mcall	80002e30 <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002d26:	e0 6a 00 ff 	mov	r10,255
80002d2a:	30 0b       	mov	r11,0
80002d2c:	30 ac       	mov	r12,10
80002d2e:	f0 1f 00 42 	mcall	80002e34 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002d32:	30 0c       	mov	r12,0
80002d34:	f0 1f 00 41 	mcall	80002e38 <SD_GetCIDRegister+0x120>
80002d38:	c0 40       	breq	80002d40 <SD_GetCIDRegister+0x28>
80002d3a:	e0 66 00 ff 	mov	r6,255
80002d3e:	c1 78       	rjmp	80002d6c <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002d40:	e0 6c 00 fe 	mov	r12,254
80002d44:	f0 1f 00 3d 	mcall	80002e38 <SD_GetCIDRegister+0x120>
80002d48:	c0 91       	brne	80002d5a <SD_GetCIDRegister+0x42>
80002d4a:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002d4c:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d50:	f0 1f 00 3b 	mcall	80002e3c <SD_GetCIDRegister+0x124>
80002d54:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d56:	0a 36       	cp.w	r6,r5
80002d58:	cf c1       	brne	80002d50 <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d5a:	e0 6c 00 ff 	mov	r12,255
80002d5e:	f0 1f 00 39 	mcall	80002e40 <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d62:	e0 6c 00 ff 	mov	r12,255
80002d66:	f0 1f 00 37 	mcall	80002e40 <SD_GetCIDRegister+0x128>
80002d6a:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002d6c:	31 8c       	mov	r12,24
80002d6e:	f0 1f 00 36 	mcall	80002e44 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002d72:	e0 6c 00 ff 	mov	r12,255
80002d76:	f0 1f 00 33 	mcall	80002e40 <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002d7a:	1b 88       	ld.ub	r8,sp[0x0]
80002d7c:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002d7e:	fb 28 00 01 	ld.sb	r8,sp[1]
80002d82:	a9 68       	lsl	r8,0x8
80002d84:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002d86:	8e 19       	ld.sh	r9,r7[0x2]
80002d88:	1b a8       	ld.ub	r8,sp[0x2]
80002d8a:	f3 e8 10 08 	or	r8,r9,r8
80002d8e:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002d90:	1b b8       	ld.ub	r8,sp[0x3]
80002d92:	b9 68       	lsl	r8,0x18
80002d94:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002d96:	6e 18       	ld.w	r8,r7[0x4]
80002d98:	1b c9       	ld.ub	r9,sp[0x4]
80002d9a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d9e:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002da0:	6e 18       	ld.w	r8,r7[0x4]
80002da2:	1b d9       	ld.ub	r9,sp[0x5]
80002da4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002da8:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002daa:	6e 18       	ld.w	r8,r7[0x4]
80002dac:	1b e9       	ld.ub	r9,sp[0x6]
80002dae:	f3 e8 10 08 	or	r8,r9,r8
80002db2:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002db4:	1b f8       	ld.ub	r8,sp[0x7]
80002db6:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002dba:	fb 38 00 08 	ld.ub	r8,sp[8]
80002dbe:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002dc2:	fb 38 00 09 	ld.ub	r8,sp[9]
80002dc6:	b9 68       	lsl	r8,0x18
80002dc8:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002dca:	6e 38       	ld.w	r8,r7[0xc]
80002dcc:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002dd0:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002dd4:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002dd6:	6e 38       	ld.w	r8,r7[0xc]
80002dd8:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002ddc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002de0:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002de2:	6e 38       	ld.w	r8,r7[0xc]
80002de4:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002de8:	f3 e8 10 08 	or	r8,r9,r8
80002dec:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002dee:	ef 39 00 10 	ld.ub	r9,r7[16]
80002df2:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002df6:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002dfa:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002dfe:	a9 68       	lsl	r8,0x8
80002e00:	e2 18 0f 00 	andl	r8,0xf00,COH
80002e04:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002e08:	ef 09 00 12 	ld.sh	r9,r7[18]
80002e0c:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002e10:	f3 e8 10 08 	or	r8,r9,r8
80002e14:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002e18:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002e1c:	a1 98       	lsr	r8,0x1
80002e1e:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002e22:	30 18       	mov	r8,1
80002e24:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002e28:	0c 9c       	mov	r12,r6
80002e2a:	2f cd       	sub	sp,-16
80002e2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	9f 40       	st.w	pc[0x10],r0
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	2b 14       	sub	r4,-79
80002e38:	80 00       	ld.sh	r0,r0[0x0]
80002e3a:	2a 54       	sub	r4,-91
80002e3c:	80 00       	ld.sh	r0,r0[0x0]
80002e3e:	2a 10       	sub	r0,-95
80002e40:	80 00       	ld.sh	r0,r0[0x0]
80002e42:	2a c8       	sub	r8,-84
80002e44:	80 00       	ld.sh	r0,r0[0x0]
80002e46:	9f 24       	st.w	pc[0x8],r4

80002e48 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002e48:	d4 31       	pushm	r0-r7,lr
80002e4a:	18 95       	mov	r5,r12
80002e4c:	16 93       	mov	r3,r11
80002e4e:	14 96       	mov	r6,r10
80002e50:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e52:	31 8c       	mov	r12,24
80002e54:	f0 1f 00 27 	mcall	80002ef0 <SD_WriteMultiBlocks+0xa8>
80002e58:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e5c:	4a 60       	lddpc	r0,80002ef4 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e5e:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e60:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e62:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e64:	c3 a8       	rjmp	80002ed8 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002e66:	01 88       	ld.ub	r8,r0[0x0]
80002e68:	30 19       	mov	r9,1
80002e6a:	f2 08 18 00 	cp.b	r8,r9
80002e6e:	c0 81       	brne	80002e7e <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002e70:	04 9a       	mov	r10,r2
80002e72:	e6 0b 16 09 	lsr	r11,r3,0x9
80002e76:	31 8c       	mov	r12,24
80002e78:	f0 1f 00 20 	mcall	80002ef8 <SD_WriteMultiBlocks+0xb0>
80002e7c:	c0 68       	rjmp	80002e88 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e7e:	04 9a       	mov	r10,r2
80002e80:	06 9b       	mov	r11,r3
80002e82:	31 8c       	mov	r12,24
80002e84:	f0 1f 00 1d 	mcall	80002ef8 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002e88:	30 0c       	mov	r12,0
80002e8a:	f0 1f 00 1d 	mcall	80002efc <SD_WriteMultiBlocks+0xb4>
80002e8e:	c0 40       	breq	80002e96 <SD_WriteMultiBlocks+0x4e>
80002e90:	e0 67 00 ff 	mov	r7,255
80002e94:	c2 b8       	rjmp	80002eea <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002e96:	04 9c       	mov	r12,r2
80002e98:	f0 1f 00 1a 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002e9c:	e0 6c 00 fe 	mov	r12,254
80002ea0:	f0 1f 00 18 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002ea4:	58 06       	cp.w	r6,0
80002ea6:	c0 a0       	breq	80002eba <SD_WriteMultiBlocks+0x72>
80002ea8:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002eaa:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002eae:	f0 1f 00 15 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002eb2:	2f f7       	sub	r7,-1
80002eb4:	0c 37       	cp.w	r7,r6
80002eb6:	cf a3       	brcs	80002eaa <SD_WriteMultiBlocks+0x62>
80002eb8:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002eba:	f0 1f 00 13 	mcall	80002f04 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002ebe:	f0 1f 00 12 	mcall	80002f04 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002ec2:	f0 1f 00 12 	mcall	80002f08 <SD_WriteMultiBlocks+0xc0>
80002ec6:	f8 01 18 00 	cp.b	r1,r12
80002eca:	f9 b7 00 00 	moveq	r7,0
80002ece:	e4 07 17 10 	movne	r7,r2
80002ed2:	20 14       	sub	r4,1
80002ed4:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ed8:	58 04       	cp.w	r4,0
80002eda:	cc 61       	brne	80002e66 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002edc:	31 8c       	mov	r12,24
80002ede:	f0 1f 00 0c 	mcall	80002f0c <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002ee2:	e0 6c 00 ff 	mov	r12,255
80002ee6:	f0 1f 00 07 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002eea:	0e 9c       	mov	r12,r7
80002eec:	d8 32       	popm	r0-r7,pc
80002eee:	00 00       	add	r0,r0
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	9f 40       	st.w	pc[0x10],r0
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 68       	and	r8,r5
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	2b 14       	sub	r4,-79
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	2a 54       	sub	r4,-91
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	2a c8       	sub	r8,-84
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	2a 10       	sub	r0,-95
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	2a 88       	sub	r8,-88
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	9f 24       	st.w	pc[0x8],r4

80002f10 <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002f10:	eb cd 40 e0 	pushm	r5-r7,lr
80002f14:	18 95       	mov	r5,r12
80002f16:	16 97       	mov	r7,r11
80002f18:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002f1a:	31 8c       	mov	r12,24
80002f1c:	f0 1f 00 1f 	mcall	80002f98 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002f20:	49 f8       	lddpc	r8,80002f9c <SD_WriteBlock+0x8c>
80002f22:	11 89       	ld.ub	r9,r8[0x0]
80002f24:	30 18       	mov	r8,1
80002f26:	f0 09 18 00 	cp.b	r9,r8
80002f2a:	c0 21       	brne	80002f2e <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002f2c:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002f2e:	e0 6a 00 ff 	mov	r10,255
80002f32:	0e 9b       	mov	r11,r7
80002f34:	31 8c       	mov	r12,24
80002f36:	f0 1f 00 1b 	mcall	80002fa0 <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f3a:	30 0c       	mov	r12,0
80002f3c:	f0 1f 00 1a 	mcall	80002fa4 <SD_WriteBlock+0x94>
80002f40:	c1 f1       	brne	80002f7e <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f42:	e0 6c 00 ff 	mov	r12,255
80002f46:	f0 1f 00 19 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002f4a:	e0 6c 00 fe 	mov	r12,254
80002f4e:	f0 1f 00 17 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f52:	5c 76       	castu.h	r6
80002f54:	c0 90       	breq	80002f66 <SD_WriteBlock+0x56>
80002f56:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f58:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f5c:	f0 1f 00 13 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f60:	2f f7       	sub	r7,-1
80002f62:	0c 37       	cp.w	r7,r6
80002f64:	cf a3       	brcs	80002f58 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002f66:	f0 1f 00 12 	mcall	80002fac <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002f6a:	f0 1f 00 11 	mcall	80002fac <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002f6e:	f0 1f 00 11 	mcall	80002fb0 <SD_WriteBlock+0xa0>
80002f72:	30 58       	mov	r8,5
80002f74:	f0 0c 18 00 	cp.b	r12,r8
80002f78:	c0 31       	brne	80002f7e <SD_WriteBlock+0x6e>
80002f7a:	30 07       	mov	r7,0
80002f7c:	c0 38       	rjmp	80002f82 <SD_WriteBlock+0x72>
80002f7e:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f82:	31 8c       	mov	r12,24
80002f84:	f0 1f 00 0c 	mcall	80002fb4 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f88:	e0 6c 00 ff 	mov	r12,255
80002f8c:	f0 1f 00 07 	mcall	80002fa8 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002f90:	0e 9c       	mov	r12,r7
80002f92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f96:	00 00       	add	r0,r0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	9f 40       	st.w	pc[0x10],r0
80002f9c:	00 00       	add	r0,r0
80002f9e:	0a 68       	and	r8,r5
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	2b 14       	sub	r4,-79
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	2a 54       	sub	r4,-91
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	2a c8       	sub	r8,-84
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	2a 10       	sub	r0,-95
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	2a 88       	sub	r8,-88
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	9f 24       	st.w	pc[0x8],r4

80002fb8 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002fb8:	d4 31       	pushm	r0-r7,lr
80002fba:	20 1d       	sub	sp,4
80002fbc:	18 95       	mov	r5,r12
80002fbe:	50 0b       	stdsp	sp[0x0],r11
80002fc0:	14 96       	mov	r6,r10
80002fc2:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002fc4:	31 8c       	mov	r12,24
80002fc6:	f0 1f 00 27 	mcall	80003060 <SD_ReadMultiBlocks+0xa8>
80002fca:	e0 67 00 ff 	mov	r7,255
80002fce:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002fd0:	4a 53       	lddpc	r3,80003064 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002fd2:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002fd4:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002fd6:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002fd8:	c3 78       	rjmp	80003046 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80002fda:	07 88       	ld.ub	r8,r3[0x0]
80002fdc:	30 19       	mov	r9,1
80002fde:	f2 08 18 00 	cp.b	r8,r9
80002fe2:	c0 a1       	brne	80002ff6 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80002fe4:	40 08       	lddsp	r8,sp[0x0]
80002fe6:	e4 08 00 0b 	add	r11,r2,r8
80002fea:	00 9a       	mov	r10,r0
80002fec:	a9 9b       	lsr	r11,0x9
80002fee:	31 1c       	mov	r12,17
80002ff0:	f0 1f 00 1e 	mcall	80003068 <SD_ReadMultiBlocks+0xb0>
80002ff4:	c0 88       	rjmp	80003004 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002ff6:	00 9a       	mov	r10,r0
80002ff8:	40 09       	lddsp	r9,sp[0x0]
80002ffa:	e4 09 00 0b 	add	r11,r2,r9
80002ffe:	31 1c       	mov	r12,17
80003000:	f0 1f 00 1a 	mcall	80003068 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003004:	02 9c       	mov	r12,r1
80003006:	f0 1f 00 1a 	mcall	8000306c <SD_ReadMultiBlocks+0xb4>
8000300a:	c0 40       	breq	80003012 <SD_ReadMultiBlocks+0x5a>
8000300c:	e0 67 00 ff 	mov	r7,255
80003010:	c2 48       	rjmp	80003058 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003012:	e0 6c 00 fe 	mov	r12,254
80003016:	f0 1f 00 16 	mcall	8000306c <SD_ReadMultiBlocks+0xb4>
8000301a:	c0 30       	breq	80003020 <SD_ReadMultiBlocks+0x68>
8000301c:	00 97       	mov	r7,r0
8000301e:	c1 38       	rjmp	80003044 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003020:	58 06       	cp.w	r6,0
80003022:	c0 a0       	breq	80003036 <SD_ReadMultiBlocks+0x7e>
80003024:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80003026:	f0 1f 00 13 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
8000302a:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000302e:	2f f7       	sub	r7,-1
80003030:	0c 37       	cp.w	r7,r6
80003032:	cf a3       	brcs	80003026 <SD_ReadMultiBlocks+0x6e>
80003034:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80003036:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
8000303a:	f0 1f 00 0e 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
8000303e:	f0 1f 00 0d 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
80003042:	02 97       	mov	r7,r1
80003044:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003046:	58 04       	cp.w	r4,0
80003048:	cc 91       	brne	80002fda <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000304a:	31 8c       	mov	r12,24
8000304c:	f0 1f 00 0a 	mcall	80003074 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003050:	e0 6c 00 ff 	mov	r12,255
80003054:	f0 1f 00 09 	mcall	80003078 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
80003058:	0e 9c       	mov	r12,r7
8000305a:	2f fd       	sub	sp,-4
8000305c:	d8 32       	popm	r0-r7,pc
8000305e:	00 00       	add	r0,r0
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	9f 40       	st.w	pc[0x10],r0
80003064:	00 00       	add	r0,r0
80003066:	0a 68       	and	r8,r5
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	2b 14       	sub	r4,-79
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	2a 54       	sub	r4,-91
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	2a 10       	sub	r0,-95
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	9f 24       	st.w	pc[0x8],r4
80003078:	80 00       	ld.sh	r0,r0[0x0]
8000307a:	2a c8       	sub	r8,-84

8000307c <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
8000307c:	eb cd 40 e0 	pushm	r5-r7,lr
80003080:	18 95       	mov	r5,r12
80003082:	16 97       	mov	r7,r11
80003084:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80003086:	31 8c       	mov	r12,24
80003088:	f0 1f 00 1a 	mcall	800030f0 <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
8000308c:	49 a8       	lddpc	r8,800030f4 <SD_ReadBlock+0x78>
8000308e:	11 89       	ld.ub	r9,r8[0x0]
80003090:	30 18       	mov	r8,1
80003092:	f0 09 18 00 	cp.b	r9,r8
80003096:	c0 21       	brne	8000309a <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
80003098:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
8000309a:	e0 6a 00 ff 	mov	r10,255
8000309e:	0e 9b       	mov	r11,r7
800030a0:	31 1c       	mov	r12,17
800030a2:	f0 1f 00 16 	mcall	800030f8 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800030a6:	30 0c       	mov	r12,0
800030a8:	f0 1f 00 15 	mcall	800030fc <SD_ReadBlock+0x80>
800030ac:	c1 61       	brne	800030d8 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800030ae:	e0 6c 00 fe 	mov	r12,254
800030b2:	f0 1f 00 13 	mcall	800030fc <SD_ReadBlock+0x80>
800030b6:	c1 11       	brne	800030d8 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030b8:	5c 76       	castu.h	r6
800030ba:	c0 90       	breq	800030cc <SD_ReadBlock+0x50>
800030bc:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
800030be:	f0 1f 00 11 	mcall	80003100 <SD_ReadBlock+0x84>
800030c2:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030c6:	2f f7       	sub	r7,-1
800030c8:	0c 37       	cp.w	r7,r6
800030ca:	cf a3       	brcs	800030be <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
800030cc:	f0 1f 00 0d 	mcall	80003100 <SD_ReadBlock+0x84>
      SD_ReadByte();
800030d0:	f0 1f 00 0c 	mcall	80003100 <SD_ReadBlock+0x84>
800030d4:	30 07       	mov	r7,0
800030d6:	c0 38       	rjmp	800030dc <SD_ReadBlock+0x60>
800030d8:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800030dc:	31 8c       	mov	r12,24
800030de:	f0 1f 00 0a 	mcall	80003104 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800030e2:	e0 6c 00 ff 	mov	r12,255
800030e6:	f0 1f 00 09 	mcall	80003108 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
800030ea:	0e 9c       	mov	r12,r7
800030ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	9f 40       	st.w	pc[0x10],r0
800030f4:	00 00       	add	r0,r0
800030f6:	0a 68       	and	r8,r5
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	2b 14       	sub	r4,-79
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	2a 54       	sub	r4,-91
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	2a 10       	sub	r0,-95
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	9f 24       	st.w	pc[0x8],r4
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	2a c8       	sub	r8,-84

8000310c <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
8000310c:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
80003110:	f0 1f 00 11 	mcall	80003154 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
80003114:	f0 1f 00 11 	mcall	80003158 <SD_Init+0x4c>
80003118:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
8000311a:	31 84       	mov	r4,24
8000311c:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000311e:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
80003122:	08 9c       	mov	r12,r4
80003124:	f0 1f 00 0e 	mcall	8000315c <SD_Init+0x50>
80003128:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000312a:	0c 9c       	mov	r12,r6
8000312c:	f0 1f 00 0d 	mcall	80003160 <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
80003130:	2f f7       	sub	r7,-1
80003132:	58 a7       	cp.w	r7,10
80003134:	cf b1       	brne	8000312a <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
80003136:	f0 1f 00 0c 	mcall	80003164 <SD_Init+0x58>
8000313a:	18 97       	mov	r7,r12

    if(TimeOut > 6)
8000313c:	58 75       	cp.w	r5,7
8000313e:	c0 50       	breq	80003148 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
80003140:	58 0c       	cp.w	r12,0
80003142:	c0 30       	breq	80003148 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
80003144:	2f f5       	sub	r5,-1
80003146:	ce eb       	rjmp	80003122 <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
80003148:	f0 1f 00 08 	mcall	80003168 <SD_Init+0x5c>
  return (Status);
}
8000314c:	0e 9c       	mov	r12,r7
8000314e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003152:	00 00       	add	r0,r0
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	29 98       	sub	r8,-103
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	29 88       	sub	r8,-104
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	9f 24       	st.w	pc[0x8],r4
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	2a c8       	sub	r8,-84
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	2b 50       	sub	r0,-75
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	29 78       	sub	r8,-105

8000316c <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
8000316c:	eb cd 40 e0 	pushm	r5-r7,lr
80003170:	20 9d       	sub	sp,36
80003172:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
80003174:	31 8c       	mov	r12,24
80003176:	f0 1f 00 a6 	mcall	8000340c <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
8000317a:	e0 6a 00 ff 	mov	r10,255
8000317e:	30 0b       	mov	r11,0
80003180:	30 9c       	mov	r12,9
80003182:	f0 1f 00 a4 	mcall	80003410 <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003186:	30 0c       	mov	r12,0
80003188:	f0 1f 00 a3 	mcall	80003414 <SD_GetCSDRegister+0x2a8>
8000318c:	c0 40       	breq	80003194 <SD_GetCSDRegister+0x28>
8000318e:	e0 6c 00 ff 	mov	r12,255
80003192:	c3 99       	rjmp	80003404 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003194:	e0 6c 00 fe 	mov	r12,254
80003198:	f0 1f 00 9f 	mcall	80003414 <SD_GetCSDRegister+0x2a8>
8000319c:	c0 a1       	brne	800031b0 <SD_GetCSDRegister+0x44>
8000319e:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
800031a2:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
800031a6:	f0 1f 00 9d 	mcall	80003418 <SD_GetCSDRegister+0x2ac>
800031aa:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
800031ac:	0a 36       	cp.w	r6,r5
800031ae:	cf c1       	brne	800031a6 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
800031b0:	e0 6c 00 ff 	mov	r12,255
800031b4:	f0 1f 00 9a 	mcall	8000341c <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
800031b8:	e0 6c 00 ff 	mov	r12,255
800031bc:	f0 1f 00 98 	mcall	8000341c <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800031c0:	31 8c       	mov	r12,24
800031c2:	f0 1f 00 98 	mcall	80003420 <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800031c6:	e0 6c 00 ff 	mov	r12,255
800031ca:	f0 1f 00 95 	mcall	8000341c <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
800031ce:	fb 38 00 14 	ld.ub	r8,sp[20]
800031d2:	f0 09 16 06 	lsr	r9,r8,0x6
800031d6:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
800031d8:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
800031dc:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
800031de:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800031e2:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
800031e4:	fe f8 02 40 	ld.w	r8,pc[576]
800031e8:	70 08       	ld.w	r8,r8[0x0]
800031ea:	58 08       	cp.w	r8,0
800031ec:	c0 f1       	brne	8000320a <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
800031ee:	0f 89       	ld.ub	r9,r7[0x0]
800031f0:	30 18       	mov	r8,1
800031f2:	f0 09 18 00 	cp.b	r9,r8
800031f6:	c0 61       	brne	80003202 <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
800031f8:	10 99       	mov	r9,r8
800031fa:	fe f8 02 2e 	ld.w	r8,pc[558]
800031fe:	b0 89       	st.b	r8[0x0],r9
80003200:	c0 58       	rjmp	8000320a <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
80003202:	30 09       	mov	r9,0
80003204:	fe f8 02 24 	ld.w	r8,pc[548]
80003208:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
8000320a:	fb 38 00 15 	ld.ub	r8,sp[21]
8000320e:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
80003210:	fb 38 00 16 	ld.ub	r8,sp[22]
80003214:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
80003216:	fb 38 00 17 	ld.ub	r8,sp[23]
8000321a:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
8000321c:	fb 38 00 18 	ld.ub	r8,sp[24]
80003220:	a5 68       	lsl	r8,0x4
80003222:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
80003224:	8e 39       	ld.sh	r9,r7[0x6]
80003226:	fb 38 00 19 	ld.ub	r8,sp[25]
8000322a:	f3 e8 12 49 	or	r9,r9,r8>>0x4
8000322e:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
80003230:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003234:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
80003238:	fb 38 00 1a 	ld.ub	r8,sp[26]
8000323c:	f0 09 16 07 	lsr	r9,r8,0x7
80003240:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
80003244:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003248:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
8000324c:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003250:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003254:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003258:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
8000325c:	30 09       	mov	r9,0
8000325e:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
80003262:	4f 2a       	lddpc	r10,80003428 <SD_GetCSDRegister+0x2bc>
80003264:	15 8a       	ld.ub	r10,r10[0x0]
80003266:	f2 0a 18 00 	cp.b	r10,r9
8000326a:	c1 21       	brne	8000328e <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
8000326c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003270:	ab 68       	lsl	r8,0xa
80003272:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
80003274:	6e 48       	ld.w	r8,r7[0x10]
80003276:	fb 39 00 1b 	ld.ub	r9,sp[27]
8000327a:	f1 e9 10 28 	or	r8,r8,r9<<0x2
8000327e:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
80003280:	6e 48       	ld.w	r8,r7[0x10]
80003282:	fb 39 00 1c 	ld.ub	r9,sp[28]
80003286:	f1 e9 12 68 	or	r8,r8,r9>>0x6
8000328a:	8f 48       	st.w	r7[0x10],r8
8000328c:	c1 38       	rjmp	800032b2 <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
8000328e:	fb 38 00 1b 	ld.ub	r8,sp[27]
80003292:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003296:	b1 68       	lsl	r8,0x10
80003298:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
8000329a:	6e 49       	ld.w	r9,r7[0x10]
8000329c:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032a0:	a9 68       	lsl	r8,0x8
800032a2:	12 08       	add	r8,r9
800032a4:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
800032a6:	6e 48       	ld.w	r8,r7[0x10]
800032a8:	fb 39 00 1d 	ld.ub	r9,sp[29]
800032ac:	f2 08 00 08 	add	r8,r9,r8
800032b0:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
800032b2:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032b6:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
800032ba:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
800032be:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800032c2:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
800032c6:	fb 38 00 1d 	ld.ub	r8,sp[29]
800032ca:	f0 09 16 05 	lsr	r9,r8,0x5
800032ce:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
800032d2:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
800032d6:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
800032da:	a1 78       	lsl	r8,0x1
800032dc:	e2 18 00 06 	andl	r8,0x6,COH
800032e0:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
800032e4:	ef 39 00 18 	ld.ub	r9,r7[24]
800032e8:	fb 38 00 1e 	ld.ub	r8,sp[30]
800032ec:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032f0:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
800032f4:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800032f8:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
800032fc:	a1 78       	lsl	r8,0x1
800032fe:	e2 18 00 7e 	andl	r8,0x7e,COH
80003302:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
80003306:	ef 39 00 1a 	ld.ub	r9,r7[26]
8000330a:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000330e:	f3 e8 12 79 	or	r9,r9,r8>>0x7
80003312:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
80003316:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
8000331a:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
8000331e:	fb 38 00 20 	ld.ub	r8,sp[32]
80003322:	f0 09 16 07 	lsr	r9,r8,0x7
80003326:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
8000332a:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
8000332e:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
80003332:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003336:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
8000333a:	a3 68       	lsl	r8,0x2
8000333c:	e2 18 00 0c 	andl	r8,0xc,COH
80003340:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
80003344:	ef 39 00 1f 	ld.ub	r9,r7[31]
80003348:	fb 38 00 21 	ld.ub	r8,sp[33]
8000334c:	f3 e8 12 69 	or	r9,r9,r8>>0x6
80003350:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003354:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003358:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
8000335c:	30 09       	mov	r9,0
8000335e:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
80003362:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003366:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
8000336a:	fb 38 00 22 	ld.ub	r8,sp[34]
8000336e:	f0 09 16 07 	lsr	r9,r8,0x7
80003372:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
80003376:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
8000337a:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
8000337e:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003382:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
80003386:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
8000338a:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
8000338e:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
80003392:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
80003396:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000339a:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
8000339e:	fb 38 00 23 	ld.ub	r8,sp[35]
800033a2:	a1 98       	lsr	r8,0x1
800033a4:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
800033a8:	30 18       	mov	r8,1
800033aa:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
800033ae:	49 e8       	lddpc	r8,80003424 <SD_GetCSDRegister+0x2b8>
800033b0:	70 08       	ld.w	r8,r8[0x0]
800033b2:	58 28       	cp.w	r8,2
800033b4:	e0 88 00 04 	brls	800033bc <SD_GetCSDRegister+0x250>
800033b8:	30 0c       	mov	r12,0
800033ba:	c2 58       	rjmp	80003404 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
800033bc:	49 b9       	lddpc	r9,80003428 <SD_GetCSDRegister+0x2bc>
800033be:	13 8a       	ld.ub	r10,r9[0x0]
800033c0:	30 19       	mov	r9,1
800033c2:	f2 0a 18 00 	cp.b	r10,r9
800033c6:	c0 51       	brne	800033d0 <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
800033c8:	6e 49       	ld.w	r9,r7[0x10]
800033ca:	2f f9       	sub	r9,-1
800033cc:	a9 79       	lsl	r9,0x9
800033ce:	c0 c8       	rjmp	800033e6 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
800033d0:	6e 4a       	ld.w	r10,r7[0x10]
800033d2:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
800033d4:	ef 39 00 18 	ld.ub	r9,r7[24]
800033d8:	2f e9       	sub	r9,-2
800033da:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
800033de:	ef 39 00 08 	ld.ub	r9,r7[8]
800033e2:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
800033e6:	58 08       	cp.w	r8,0
800033e8:	c0 91       	brne	800033fa <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
800033ea:	b5 89       	lsr	r9,0x14
800033ec:	1a d9       	st.w	--sp,r9
800033ee:	49 0b       	lddpc	r11,8000342c <SD_GetCSDRegister+0x2c0>
800033f0:	fa cc ff fc 	sub	r12,sp,-4
800033f4:	f0 1f 00 0f 	mcall	80003430 <SD_GetCSDRegister+0x2c4>
800033f8:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
800033fa:	48 b8       	lddpc	r8,80003424 <SD_GetCSDRegister+0x2b8>
800033fc:	70 09       	ld.w	r9,r8[0x0]
800033fe:	2f f9       	sub	r9,-1
80003400:	91 09       	st.w	r8[0x0],r9
80003402:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
80003404:	2f 7d       	sub	sp,-36
80003406:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000340a:	00 00       	add	r0,r0
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	9f 40       	st.w	pc[0x10],r0
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	2b 14       	sub	r4,-79
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	2a 54       	sub	r4,-91
80003418:	80 00       	ld.sh	r0,r0[0x0]
8000341a:	2a 10       	sub	r0,-95
8000341c:	80 00       	ld.sh	r0,r0[0x0]
8000341e:	2a c8       	sub	r8,-84
80003420:	80 00       	ld.sh	r0,r0[0x0]
80003422:	9f 24       	st.w	pc[0x8],r4
80003424:	00 00       	add	r0,r0
80003426:	0a 64       	and	r4,r5
80003428:	00 00       	add	r0,r0
8000342a:	0a 68       	and	r8,r5
8000342c:	80 01       	ld.sh	r1,r0[0x0]
8000342e:	03 a0       	ld.ub	r0,r1[0x2]
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	a8 50       	st.h	r4[0xa],r0

80003434 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
80003434:	eb cd 40 c0 	pushm	r6-r7,lr
80003438:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
8000343a:	18 96       	mov	r6,r12
8000343c:	f0 1f 00 12 	mcall	80003484 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
80003440:	e0 4c 00 ff 	cp.w	r12,255
80003444:	c0 41       	brne	8000344c <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003446:	0e 9c       	mov	r12,r7
80003448:	f0 1f 00 0f 	mcall	80003484 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
8000344c:	ee cc ff d4 	sub	r12,r7,-44
80003450:	f0 1f 00 0e 	mcall	80003488 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003454:	30 19       	mov	r9,1
80003456:	48 e8       	lddpc	r8,8000348c <SD_GetCardInfo+0x58>
80003458:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
8000345a:	6e 48       	ld.w	r8,r7[0x10]
8000345c:	2f f8       	sub	r8,-1
8000345e:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
80003462:	ef 39 00 08 	ld.ub	r9,r7[8]
80003466:	30 1a       	mov	r10,1
80003468:	f4 09 09 49 	lsl	r9,r10,r9
8000346c:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
80003470:	f2 08 02 48 	mul	r8,r9,r8
80003474:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
80003478:	48 68       	lddpc	r8,80003490 <SD_GetCardInfo+0x5c>
8000347a:	70 09       	ld.w	r9,r8[0x0]
8000347c:	14 09       	add	r9,r10
8000347e:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
80003480:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	31 6c       	mov	r12,22
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	2d 18       	sub	r8,-47
8000348c:	00 00       	add	r0,r0
8000348e:	0a 68       	and	r8,r5
80003490:	00 00       	add	r0,r0
80003492:	0a 60       	and	r0,r5

80003494 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
80003494:	d4 01       	pushm	lr
80003496:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
80003498:	1a 9c       	mov	r12,sp
8000349a:	f0 1f 00 05 	mcall	800034ac <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
8000349e:	41 1c       	lddsp	r12,sp[0x44]
800034a0:	a1 7c       	lsl	r12,0x1
800034a2:	48 48       	lddpc	r8,800034b0 <SD_GetSectorCount+0x1c>
800034a4:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
800034a6:	2e dd       	sub	sp,-76
800034a8:	d8 02       	popm	pc
800034aa:	00 00       	add	r0,r0
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	34 34       	mov	r4,67
800034b0:	00 00       	add	r0,r0
800034b2:	0a 5c       	eor	r12,r5

800034b4 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034b4:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034b6:	30 18       	mov	r8,1
800034b8:	f0 09 18 00 	cp.b	r9,r8
800034bc:	c0 71       	brne	800034ca <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034be:	5c 7a       	castu.h	r10
800034c0:	a9 7b       	lsl	r11,0x9
800034c2:	f0 1f 00 07 	mcall	800034dc <MAL_WriteDisk+0x28>
800034c6:	c0 91       	brne	800034d8 <MAL_WriteDisk+0x24>
800034c8:	c0 68       	rjmp	800034d4 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034ca:	5c 7a       	castu.h	r10
800034cc:	a9 7b       	lsl	r11,0x9
800034ce:	f0 1f 00 05 	mcall	800034e0 <MAL_WriteDisk+0x2c>
800034d2:	c0 31       	brne	800034d8 <MAL_WriteDisk+0x24>
800034d4:	30 4c       	mov	r12,4
800034d6:	d8 02       	popm	pc
800034d8:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
800034da:	d8 02       	popm	pc
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	2f 10       	sub	r0,-15
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	2e 48       	sub	r8,-28

800034e4 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034e4:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034e6:	30 18       	mov	r8,1
800034e8:	f0 09 18 00 	cp.b	r9,r8
800034ec:	c0 71       	brne	800034fa <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034ee:	5c 7a       	castu.h	r10
800034f0:	a9 7b       	lsl	r11,0x9
800034f2:	f0 1f 00 07 	mcall	8000350c <MAL_ReadDisk+0x28>
800034f6:	c0 91       	brne	80003508 <MAL_ReadDisk+0x24>
800034f8:	c0 68       	rjmp	80003504 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034fa:	5c 7a       	castu.h	r10
800034fc:	a9 7b       	lsl	r11,0x9
800034fe:	f0 1f 00 05 	mcall	80003510 <MAL_ReadDisk+0x2c>
80003502:	c0 31       	brne	80003508 <MAL_ReadDisk+0x24>
80003504:	30 8c       	mov	r12,8
80003506:	d8 02       	popm	pc
80003508:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
8000350a:	d8 02       	popm	pc
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	30 7c       	mov	r12,7
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	2f b8       	sub	r8,-5

80003514 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
80003514:	d4 01       	pushm	lr
80003516:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
80003518:	f0 1f 00 06 	mcall	80003530 <MAL_InitConfig+0x1c>
8000351c:	c0 30       	breq	80003522 <MAL_InitConfig+0xe>
8000351e:	30 1c       	mov	r12,1
80003520:	c0 58       	rjmp	8000352a <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
80003522:	1a 9c       	mov	r12,sp
80003524:	f0 1f 00 04 	mcall	80003534 <MAL_InitConfig+0x20>
80003528:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
8000352a:	2e dd       	sub	sp,-76
8000352c:	d8 02       	popm	pc
8000352e:	00 00       	add	r0,r0
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	31 0c       	mov	r12,16
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	34 34       	mov	r4,67

80003538 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
80003538:	eb cd 40 f8 	pushm	r3-r7,lr
8000353c:	20 2d       	sub	sp,8
8000353e:	18 95       	mov	r5,r12
80003540:	16 94       	mov	r4,r11
80003542:	14 93       	mov	r3,r10
80003544:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
80003546:	34 cc       	mov	r12,76
80003548:	f0 1f 00 16 	mcall	800035a0 <fl_write+0x68>
8000354c:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
8000354e:	0a 9b       	mov	r11,r5
80003550:	f0 1f 00 15 	mcall	800035a4 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003554:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80003558:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
8000355c:	0c 9c       	mov	r12,r6
8000355e:	f0 1f 00 11 	mcall	800035a0 <fl_write+0x68>
80003562:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
80003566:	0c 9a       	mov	r10,r6
80003568:	06 9b       	mov	r11,r3
8000356a:	f0 1f 00 10 	mcall	800035a8 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
8000356e:	e0 68 40 00 	mov	r8,16384
80003572:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003574:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
80003576:	48 e8       	lddpc	r8,800035ac <fl_write+0x74>
80003578:	70 0c       	ld.w	r12,r8[0x0]
8000357a:	30 09       	mov	r9,0
8000357c:	12 9a       	mov	r10,r9
8000357e:	1a 9b       	mov	r11,sp
80003580:	f0 1f 00 0c 	mcall	800035b0 <fl_write+0x78>
80003584:	58 1c       	cp.w	r12,1
80003586:	c0 a0       	breq	8000359a <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
80003588:	6f 2c       	ld.w	r12,r7[0x48]
8000358a:	f0 1f 00 0b 	mcall	800035b4 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
8000358e:	0e 9c       	mov	r12,r7
80003590:	f0 1f 00 09 	mcall	800035b4 <fl_write+0x7c>
		log("\n\r fsmm \n\r");//man...SPI_PBA
80003594:	48 9c       	lddpc	r12,800035b8 <fl_write+0x80>
80003596:	f0 1f 00 0a 	mcall	800035bc <fl_write+0x84>
	}
	
}
8000359a:	2f ed       	sub	sp,-8
8000359c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800035a0:	80 00       	ld.sh	r0,r0[0x0]
800035a2:	8b 10       	st.w	r5[0x4],r0
800035a4:	80 00       	ld.sh	r0,r0[0x0]
800035a6:	a8 8c       	st.b	r4[0x0],r12
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	a4 1a       	st.h	r2[0x2],r10
800035ac:	00 00       	add	r0,r0
800035ae:	0d 40       	ld.w	r0,--r6
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	8e 64       	ld.sh	r4,r7[0xc]
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	8a e8       	ld.uh	r8,r5[0xc]
800035b8:	80 01       	ld.sh	r1,r0[0x0]
800035ba:	03 e8       	ld.ub	r8,r1[0x6]
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	9a 54       	ld.sh	r4,sp[0xa]

800035c0 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
800035c0:	d4 31       	pushm	r0-r7,lr
800035c2:	20 1d       	sub	sp,4
800035c4:	18 97       	mov	r7,r12
800035c6:	16 96       	mov	r6,r11
800035c8:	14 94       	mov	r4,r10
800035ca:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
800035cc:	30 1a       	mov	r10,1
800035ce:	4c 7b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035d0:	4c 7c       	lddpc	r12,800036ec <fl_write_func+0x12c>
800035d2:	f0 1f 00 48 	mcall	800036f0 <fl_write_func+0x130>
800035d6:	e0 81 00 86 	brne	800036e2 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
800035da:	0e 91       	mov	r1,r7
800035dc:	31 2a       	mov	r10,18
800035de:	0e 9b       	mov	r11,r7
800035e0:	4c 5c       	lddpc	r12,800036f4 <fl_write_func+0x134>
800035e2:	f0 1f 00 46 	mcall	800036f8 <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800035e6:	58 5c       	cp.w	r12,5
800035e8:	c5 91       	brne	8000369a <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800035ea:	4c 0b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035ec:	4c 4c       	lddpc	r12,800036fc <fl_write_func+0x13c>
800035ee:	f0 1f 00 45 	mcall	80003700 <fl_write_func+0x140>
800035f2:	c0 80       	breq	80003602 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800035f4:	30 1a       	mov	r10,1
800035f6:	4b db       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035f8:	30 0c       	mov	r12,0
800035fa:	f0 1f 00 3e 	mcall	800036f0 <fl_write_func+0x130>
800035fe:	30 6c       	mov	r12,6
			return fs_err;
80003600:	c7 28       	rjmp	800036e4 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
80003602:	0e 9c       	mov	r12,r7
80003604:	f0 1f 00 40 	mcall	80003704 <fl_write_func+0x144>
80003608:	4c 03       	lddpc	r3,80003708 <fl_write_func+0x148>
8000360a:	18 9a       	mov	r10,r12
8000360c:	0e 9b       	mov	r11,r7
8000360e:	06 9c       	mov	r12,r3
80003610:	f0 1f 00 3f 	mcall	8000370c <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
80003614:	4b 57       	lddpc	r7,800036e8 <fl_write_func+0x128>
80003616:	0e 9b       	mov	r11,r7
80003618:	06 9c       	mov	r12,r3
8000361a:	f0 1f 00 3e 	mcall	80003710 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
8000361e:	1a dc       	st.w	--sp,r12
80003620:	4b db       	lddpc	r11,80003714 <fl_write_func+0x154>
80003622:	4b ec       	lddpc	r12,80003718 <fl_write_func+0x158>
80003624:	f0 1f 00 3e 	mcall	8000371c <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
80003628:	0e 9b       	mov	r11,r7
8000362a:	30 0c       	mov	r12,0
8000362c:	f0 1f 00 39 	mcall	80003710 <fl_write_func+0x150>
80003630:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
80003632:	2f fd       	sub	sp,-4
80003634:	58 0c       	cp.w	r12,0
80003636:	c2 50       	breq	80003680 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
80003638:	4b 83       	lddpc	r3,80003718 <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
8000363a:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
8000363c:	4b 90       	lddpc	r0,80003720 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
8000363e:	06 9c       	mov	r12,r3
80003640:	f0 1f 00 39 	mcall	80003724 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003644:	5f 09       	sreq	r9
80003646:	58 8c       	cp.w	r12,8
80003648:	5f 08       	sreq	r8
8000364a:	f3 e8 10 08 	or	r8,r9,r8
8000364e:	e4 08 18 00 	cp.b	r8,r2
80003652:	c1 00       	breq	80003672 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003654:	1a d7       	st.w	--sp,r7
80003656:	1a d3       	st.w	--sp,r3
80003658:	00 9b       	mov	r11,r0
8000365a:	06 9c       	mov	r12,r3
8000365c:	f0 1f 00 30 	mcall	8000371c <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003660:	4a 2b       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003662:	30 0c       	mov	r12,0
80003664:	f0 1f 00 2b 	mcall	80003710 <fl_write_func+0x150>
80003668:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000366a:	2f ed       	sub	sp,-8
8000366c:	58 0c       	cp.w	r12,0
8000366e:	ce 81       	brne	8000363e <fl_write_func+0x7e>
80003670:	c0 88       	rjmp	80003680 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003672:	30 1a       	mov	r10,1
80003674:	49 db       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003676:	30 0c       	mov	r12,0
80003678:	f0 1f 00 1e 	mcall	800036f0 <fl_write_func+0x130>
8000367c:	30 4c       	mov	r12,4
					return new_dir_err;
8000367e:	c3 38       	rjmp	800036e4 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003680:	31 2a       	mov	r10,18
80003682:	02 9b       	mov	r11,r1
80003684:	49 cc       	lddpc	r12,800036f4 <fl_write_func+0x134>
80003686:	f0 1f 00 1d 	mcall	800036f8 <fl_write_func+0x138>
				if(res != FR_OK)
8000368a:	c1 10       	breq	800036ac <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
8000368c:	30 1a       	mov	r10,1
8000368e:	49 7b       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003690:	30 0c       	mov	r12,0
80003692:	f0 1f 00 18 	mcall	800036f0 <fl_write_func+0x130>
80003696:	30 3c       	mov	r12,3
					return open_fl_err;
80003698:	c2 68       	rjmp	800036e4 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000369a:	58 0c       	cp.w	r12,0
8000369c:	c0 80       	breq	800036ac <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
8000369e:	30 1a       	mov	r10,1
800036a0:	49 2b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800036a2:	30 0c       	mov	r12,0
800036a4:	f0 1f 00 13 	mcall	800036f0 <fl_write_func+0x130>
800036a8:	30 3c       	mov	r12,3
		return open_fl_err;
800036aa:	c1 d8       	rjmp	800036e4 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
800036ac:	5b f6       	cp.w	r6,-1
800036ae:	c0 61       	brne	800036ba <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
800036b0:	49 1c       	lddpc	r12,800036f4 <fl_write_func+0x134>
800036b2:	78 3b       	ld.w	r11,r12[0xc]
800036b4:	f0 1f 00 1d 	mcall	80003728 <fl_write_func+0x168>
800036b8:	c0 58       	rjmp	800036c2 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
800036ba:	0c 9b       	mov	r11,r6
800036bc:	48 ec       	lddpc	r12,800036f4 <fl_write_func+0x134>
800036be:	f0 1f 00 1b 	mcall	80003728 <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
800036c2:	48 d7       	lddpc	r7,800036f4 <fl_write_func+0x134>
800036c4:	1a 99       	mov	r9,sp
800036c6:	0a 9a       	mov	r10,r5
800036c8:	08 9b       	mov	r11,r4
800036ca:	0e 9c       	mov	r12,r7
800036cc:	f0 1f 00 18 	mcall	8000372c <fl_write_func+0x16c>

	f_close (&fl);
800036d0:	0e 9c       	mov	r12,r7
800036d2:	f0 1f 00 18 	mcall	80003730 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
800036d6:	30 1a       	mov	r10,1
800036d8:	48 4b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800036da:	30 0c       	mov	r12,0
800036dc:	f0 1f 00 05 	mcall	800036f0 <fl_write_func+0x130>
800036e0:	c0 28       	rjmp	800036e4 <fl_write_func+0x124>
}
800036e2:	30 2c       	mov	r12,2
800036e4:	2f fd       	sub	sp,-4
800036e6:	d8 32       	popm	r0-r7,pc
800036e8:	80 01       	ld.sh	r1,r0[0x0]
800036ea:	03 e4       	ld.ub	r4,r1[0x6]
800036ec:	00 00       	add	r0,r0
800036ee:	0a 70       	tst	r0,r5
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	70 80       	ld.w	r0,r8[0x20]
800036f4:	00 00       	add	r0,r0
800036f6:	0d 48       	ld.w	r8,--r6
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	80 4c       	ld.sh	r12,r0[0x8]
800036fc:	00 00       	add	r0,r0
800036fe:	0c e0       	st.h	--r6,r0
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	7e 10       	ld.w	r0,pc[0x4]
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	a8 9e       	st.b	r4[0x1],lr
80003708:	00 00       	add	r0,r0
8000370a:	0d 00       	ld.w	r0,r6++
8000370c:	80 00       	ld.sh	r0,r0[0x0]
8000370e:	a4 1a       	st.h	r2[0x2],r10
80003710:	80 00       	ld.sh	r0,r0[0x0]
80003712:	a8 d4       	st.b	r4[0x5],r4
80003714:	80 01       	ld.sh	r1,r0[0x0]
80003716:	03 f4       	ld.ub	r4,r1[0x7]
80003718:	00 00       	add	r0,r0
8000371a:	0c a0       	st.w	r6++,r0
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	a8 50       	st.h	r4[0xa],r0
80003720:	80 01       	ld.sh	r1,r0[0x0]
80003722:	03 fc       	ld.ub	r12,r1[0x7]
80003724:	80 00       	ld.sh	r0,r0[0x0]
80003726:	7e 94       	ld.w	r4,pc[0x24]
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	82 ec       	ld.uh	r12,r1[0xc]
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	85 a0       	st.w	r2[0x28],r0
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	71 cc       	ld.w	r12,r8[0x70]

80003734 <fl_oper_process>:


static void fl_oper_process(void * pvParameters)
{
80003734:	eb cd 40 f8 	pushm	r3-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
80003738:	30 8c       	mov	r12,8
8000373a:	f0 1f 00 17 	mcall	80003794 <fl_oper_process+0x60>
8000373e:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003740:	49 66       	lddpc	r6,80003798 <fl_oper_process+0x64>
80003742:	30 05       	mov	r5,0
80003744:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
80003746:	e0 63 40 00 	mov	r3,16384
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
8000374a:	6c 0c       	ld.w	r12,r6[0x0]
8000374c:	0a 99       	mov	r9,r5
8000374e:	08 9a       	mov	r10,r4
80003750:	0e 9b       	mov	r11,r7
80003752:	f0 1f 00 13 	mcall	8000379c <fl_oper_process+0x68>
80003756:	58 1c       	cp.w	r12,1
80003758:	cf 91       	brne	8000374a <fl_oper_process+0x16>
		{  
			switch(fl_oper->opcode)
8000375a:	8e 08       	ld.sh	r8,r7[0x0]
8000375c:	e6 08 19 00 	cp.h	r8,r3
80003760:	c1 31       	brne	80003786 <fl_oper_process+0x52>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
80003762:	6e 1c       	ld.w	r12,r7[0x4]
80003764:	58 0c       	cp.w	r12,0
80003766:	cf 20       	breq	8000374a <fl_oper_process+0x16>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
80003768:	79 2a       	ld.w	r10,r12[0x48]
8000376a:	58 0a       	cp.w	r10,0
8000376c:	c0 90       	breq	8000377e <fl_oper_process+0x4a>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
8000376e:	79 19       	ld.w	r9,r12[0x44]
80003770:	79 0b       	ld.w	r11,r12[0x40]
80003772:	f0 1f 00 0c 	mcall	800037a0 <fl_oper_process+0x6c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
80003776:	6e 18       	ld.w	r8,r7[0x4]
80003778:	71 2c       	ld.w	r12,r8[0x48]
8000377a:	f0 1f 00 0b 	mcall	800037a4 <fl_oper_process+0x70>
					}
					vPortFree(fl_oper->payload);					
8000377e:	6e 1c       	ld.w	r12,r7[0x4]
80003780:	f0 1f 00 09 	mcall	800037a4 <fl_oper_process+0x70>
80003784:	ce 3b       	rjmp	8000374a <fl_oper_process+0x16>
				}
				break;
								
			default:
				if(NULL != fl_oper->payload)
80003786:	6e 1c       	ld.w	r12,r7[0x4]
80003788:	58 0c       	cp.w	r12,0
8000378a:	ce 00       	breq	8000374a <fl_oper_process+0x16>
				{
					vPortFree(fl_oper->payload);
8000378c:	f0 1f 00 06 	mcall	800037a4 <fl_oper_process+0x70>
80003790:	cd db       	rjmp	8000374a <fl_oper_process+0x16>
80003792:	00 00       	add	r0,r0
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	8b 10       	st.w	r5[0x4],r0
80003798:	00 00       	add	r0,r0
8000379a:	0d 40       	ld.w	r0,--r6
8000379c:	80 00       	ld.sh	r0,r0[0x0]
8000379e:	8c 58       	ld.sh	r8,r6[0xa]
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	35 c0       	mov	r0,92
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	8a e8       	ld.uh	r8,r5[0xc]

800037a8 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
800037a8:	d4 01       	pushm	lr
800037aa:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
800037ac:	f0 1f 00 41 	mcall	800038b0 <disk_init+0x108>
800037b0:	5c 8c       	casts.h	r12
800037b2:	c0 30       	breq	800037b8 <disk_init+0x10>
800037b4:	30 1c       	mov	r12,1
800037b6:	c7 a8       	rjmp	800038aa <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
800037b8:	30 1a       	mov	r10,1
800037ba:	4b fb       	lddpc	r11,800038b4 <disk_init+0x10c>
800037bc:	4b fc       	lddpc	r12,800038b8 <disk_init+0x110>
800037be:	f0 1f 00 40 	mcall	800038bc <disk_init+0x114>
800037c2:	c0 30       	breq	800037c8 <disk_init+0x20>
800037c4:	30 2c       	mov	r12,2
800037c6:	c7 28       	rjmp	800038aa <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
800037c8:	4b ea       	lddpc	r10,800038c0 <disk_init+0x118>
800037ca:	4b fb       	lddpc	r11,800038c4 <disk_init+0x11c>
800037cc:	4b ac       	lddpc	r12,800038b4 <disk_init+0x10c>
800037ce:	f0 1f 00 3f 	mcall	800038c8 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
800037d2:	58 dc       	cp.w	r12,13
800037d4:	c1 41       	brne	800037fc <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
800037d6:	e0 6a 10 00 	mov	r10,4096
800037da:	30 0b       	mov	r11,0
800037dc:	16 9c       	mov	r12,r11
800037de:	f0 1f 00 3c 	mcall	800038cc <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
800037e2:	4b 8a       	lddpc	r10,800038c0 <disk_init+0x118>
800037e4:	4b 8b       	lddpc	r11,800038c4 <disk_init+0x11c>
800037e6:	4b 4c       	lddpc	r12,800038b4 <disk_init+0x10c>
800037e8:	f0 1f 00 38 	mcall	800038c8 <disk_init+0x120>
800037ec:	c1 10       	breq	8000380e <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
800037ee:	30 1a       	mov	r10,1
800037f0:	4b 1b       	lddpc	r11,800038b4 <disk_init+0x10c>
800037f2:	30 0c       	mov	r12,0
800037f4:	f0 1f 00 32 	mcall	800038bc <disk_init+0x114>
800037f8:	30 5c       	mov	r12,5
			return no_fs;
800037fa:	c5 88       	rjmp	800038aa <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
800037fc:	58 0c       	cp.w	r12,0
800037fe:	c0 80       	breq	8000380e <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
80003800:	30 1a       	mov	r10,1
80003802:	4a db       	lddpc	r11,800038b4 <disk_init+0x10c>
80003804:	30 0c       	mov	r12,0
80003806:	f0 1f 00 2e 	mcall	800038bc <disk_init+0x114>
8000380a:	30 6c       	mov	r12,6
		return fs_err;
8000380c:	c4 f8       	rjmp	800038aa <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
8000380e:	1a 9b       	mov	r11,sp
80003810:	30 08       	mov	r8,0
80003812:	30 09       	mov	r9,0
80003814:	fa e9 00 00 	st.d	sp[0],r8
80003818:	30 0a       	mov	r10,0
8000381a:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
8000381c:	4a 6c       	lddpc	r12,800038b4 <disk_init+0x10c>
8000381e:	f0 1f 00 2d 	mcall	800038d0 <disk_init+0x128>
80003822:	c0 80       	breq	80003832 <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003824:	30 1a       	mov	r10,1
80003826:	4a 4b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003828:	30 0c       	mov	r12,0
8000382a:	f0 1f 00 25 	mcall	800038bc <disk_init+0x114>
8000382e:	30 6c       	mov	r12,6
		return fs_err;
80003830:	c3 d8       	rjmp	800038aa <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
80003832:	30 7a       	mov	r10,7
80003834:	1a 9b       	mov	r11,sp
80003836:	4a 8c       	lddpc	r12,800038d4 <disk_init+0x12c>
80003838:	f0 1f 00 28 	mcall	800038d8 <disk_init+0x130>
8000383c:	c0 c0       	breq	80003854 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
8000383e:	4a 8c       	lddpc	r12,800038dc <disk_init+0x134>
80003840:	f0 1f 00 28 	mcall	800038e0 <disk_init+0x138>
80003844:	c0 80       	breq	80003854 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
80003846:	30 1a       	mov	r10,1
80003848:	49 bb       	lddpc	r11,800038b4 <disk_init+0x10c>
8000384a:	30 0c       	mov	r12,0
8000384c:	f0 1f 00 1c 	mcall	800038bc <disk_init+0x114>
80003850:	30 6c       	mov	r12,6
			return fs_err;
80003852:	c2 c8       	rjmp	800038aa <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003854:	49 8b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003856:	4a 4c       	lddpc	r12,800038e4 <disk_init+0x13c>
80003858:	f0 1f 00 24 	mcall	800038e8 <disk_init+0x140>
8000385c:	c2 11       	brne	8000389e <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
8000385e:	30 aa       	mov	r10,10
80003860:	4a 3b       	lddpc	r11,800038ec <disk_init+0x144>
80003862:	4a 4c       	lddpc	r12,800038f0 <disk_init+0x148>
80003864:	f0 1f 00 24 	mcall	800038f4 <disk_init+0x14c>
80003868:	c1 41       	brne	80003890 <disk_init+0xe8>
		{
			f_close(&fl);
8000386a:	4a 2c       	lddpc	r12,800038f0 <disk_init+0x148>
8000386c:	f0 1f 00 23 	mcall	800038f8 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003870:	4a 3c       	lddpc	r12,800038fc <disk_init+0x154>
80003872:	f0 1f 00 24 	mcall	80003900 <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003876:	4a 4c       	lddpc	r12,80003904 <disk_init+0x15c>
80003878:	f0 1f 00 22 	mcall	80003900 <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
8000387c:	4a 3c       	lddpc	r12,80003908 <disk_init+0x160>
8000387e:	f0 1f 00 21 	mcall	80003900 <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003882:	30 1a       	mov	r10,1
80003884:	48 cb       	lddpc	r11,800038b4 <disk_init+0x10c>
80003886:	30 0c       	mov	r12,0
80003888:	f0 1f 00 0d 	mcall	800038bc <disk_init+0x114>
8000388c:	30 0c       	mov	r12,0
	return fs_ok;
8000388e:	c0 e8       	rjmp	800038aa <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003890:	30 1a       	mov	r10,1
80003892:	48 9b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003894:	30 0c       	mov	r12,0
80003896:	f0 1f 00 0a 	mcall	800038bc <disk_init+0x114>
8000389a:	30 6c       	mov	r12,6
			return fs_err;
8000389c:	c0 78       	rjmp	800038aa <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
8000389e:	30 1a       	mov	r10,1
800038a0:	48 5b       	lddpc	r11,800038b4 <disk_init+0x10c>
800038a2:	30 0c       	mov	r12,0
800038a4:	f0 1f 00 06 	mcall	800038bc <disk_init+0x114>
800038a8:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
800038aa:	2f dd       	sub	sp,-12
800038ac:	d8 02       	popm	pc
800038ae:	00 00       	add	r0,r0
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	35 14       	mov	r4,81
800038b4:	80 01       	ld.sh	r1,r0[0x0]
800038b6:	03 e4       	ld.ub	r4,r1[0x6]
800038b8:	00 00       	add	r0,r0
800038ba:	0a 70       	tst	r0,r5
800038bc:	80 00       	ld.sh	r0,r0[0x0]
800038be:	70 80       	ld.w	r0,r8[0x20]
800038c0:	00 00       	add	r0,r0
800038c2:	0d 44       	ld.w	r4,--r6
800038c4:	00 00       	add	r0,r0
800038c6:	0a 6c       	and	r12,r5
800038c8:	80 00       	ld.sh	r0,r0[0x0]
800038ca:	82 00       	ld.sh	r0,r1[0x0]
800038cc:	80 00       	ld.sh	r0,r0[0x0]
800038ce:	65 44       	ld.w	r4,r2[0x50]
800038d0:	80 00       	ld.sh	r0,r0[0x0]
800038d2:	77 7c       	ld.w	r12,r11[0x5c]
800038d4:	00 00       	add	r0,r0
800038d6:	04 f4       	st.b	--r2,r4
800038d8:	80 00       	ld.sh	r0,r0[0x0]
800038da:	a3 f4       	*unknown*
800038dc:	80 01       	ld.sh	r1,r0[0x0]
800038de:	04 04       	add	r4,r2
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	78 c8       	ld.w	r8,r12[0x30]
800038e4:	00 00       	add	r0,r0
800038e6:	0c e0       	st.h	--r6,r0
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	7e 10       	ld.w	r0,pc[0x4]
800038ec:	80 01       	ld.sh	r1,r0[0x0]
800038ee:	04 0c       	add	r12,r2
800038f0:	00 00       	add	r0,r0
800038f2:	0d 48       	ld.w	r8,--r6
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	80 4c       	ld.sh	r12,r0[0x8]
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	71 cc       	ld.w	r12,r8[0x70]
800038fc:	80 01       	ld.sh	r1,r0[0x0]
800038fe:	04 14       	sub	r4,r2
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	7e 94       	ld.w	r4,pc[0x24]
80003904:	80 01       	ld.sh	r1,r0[0x0]
80003906:	04 1c       	sub	r12,r2
80003908:	80 01       	ld.sh	r1,r0[0x0]
8000390a:	04 28       	rsub	r8,r2

8000390c <fs_init>:
	}
	
}

fs_err_t fs_init(void)
{
8000390c:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003910:	f0 1f 00 0d 	mcall	80003944 <fs_init+0x38>
80003914:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003916:	c1 31       	brne	8000393c <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(50, sizeof(fl_oper_t)); //50*512bytes = 25k
80003918:	30 8b       	mov	r11,8
8000391a:	33 2c       	mov	r12,50
8000391c:	f0 1f 00 0b 	mcall	80003948 <fs_init+0x3c>
80003920:	48 b8       	lddpc	r8,8000394c <fs_init+0x40>
80003922:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003924:	30 09       	mov	r9,0
80003926:	1a d9       	st.w	--sp,r9
80003928:	1a d9       	st.w	--sp,r9
8000392a:	1a d9       	st.w	--sp,r9
8000392c:	30 28       	mov	r8,2
8000392e:	e0 6a 02 00 	mov	r10,512
80003932:	48 8b       	lddpc	r11,80003950 <fs_init+0x44>
80003934:	48 8c       	lddpc	r12,80003954 <fs_init+0x48>
80003936:	f0 1f 00 09 	mcall	80003958 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
8000393a:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
8000393c:	0e 9c       	mov	r12,r7
8000393e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003942:	00 00       	add	r0,r0
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	37 a8       	mov	r8,122
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	8f bc       	st.w	r7[0x2c],r12
8000394c:	00 00       	add	r0,r0
8000394e:	0d 40       	ld.w	r0,--r6
80003950:	80 01       	ld.sh	r1,r0[0x0]
80003952:	04 3c       	cp.w	r12,r2
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	37 34       	mov	r4,115
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	96 90       	ld.uh	r0,r11[0x2]

8000395c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000395c:	20 1c       	sub	r12,1
8000395e:	5c 5c       	castu.b	r12
80003960:	31 18       	mov	r8,17
80003962:	f0 0c 18 00 	cp.b	r12,r8
80003966:	e0 88 00 03 	brls	8000396c <CalculateBurst+0x10>
8000396a:	5e fd       	retal	0
8000396c:	48 28       	lddpc	r8,80003974 <CalculateBurst+0x18>
8000396e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003972:	5e fc       	retal	r12
80003974:	80 01       	ld.sh	r1,r0[0x0]
80003976:	04 54       	eor	r4,r2

80003978 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003978:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000397a:	48 98       	lddpc	r8,8000399c <payload_init+0x24>
8000397c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000397e:	48 98       	lddpc	r8,800039a0 <payload_init+0x28>
80003980:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003982:	30 09       	mov	r9,0
80003984:	1a d9       	st.w	--sp,r9
80003986:	1a d9       	st.w	--sp,r9
80003988:	1a d9       	st.w	--sp,r9
8000398a:	30 28       	mov	r8,2
8000398c:	e0 6a 04 00 	mov	r10,1024
80003990:	48 5b       	lddpc	r11,800039a4 <payload_init+0x2c>
80003992:	48 6c       	lddpc	r12,800039a8 <payload_init+0x30>
80003994:	f0 1f 00 06 	mcall	800039ac <payload_init+0x34>
80003998:	2f dd       	sub	sp,-12
	
	
	
	
	
}
8000399a:	d8 02       	popm	pc
8000399c:	00 00       	add	r0,r0
8000399e:	0f 70       	ld.ub	r0,--r7
800039a0:	00 00       	add	r0,r0
800039a2:	0f 74       	ld.ub	r4,--r7
800039a4:	80 01       	ld.sh	r1,r0[0x0]
800039a6:	04 9c       	mov	r12,r2
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	39 b0       	mov	r0,-101
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	96 90       	ld.uh	r0,r11[0x2]

800039b0 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800039b0:	eb cd 40 f8 	pushm	r3-r7,lr
800039b4:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800039b6:	48 e8       	lddpc	r8,800039ec <payload_rx_process+0x3c>
800039b8:	70 08       	ld.w	r8,r8[0x0]
800039ba:	58 08       	cp.w	r8,0
800039bc:	c0 71       	brne	800039ca <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800039be:	30 4b       	mov	r11,4
800039c0:	30 5c       	mov	r12,5
800039c2:	f0 1f 00 0c 	mcall	800039f0 <payload_rx_process+0x40>
800039c6:	48 a8       	lddpc	r8,800039ec <payload_rx_process+0x3c>
800039c8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800039ca:	48 96       	lddpc	r6,800039ec <payload_rx_process+0x3c>
800039cc:	30 05       	mov	r5,0
800039ce:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800039d0:	48 93       	lddpc	r3,800039f4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800039d2:	6c 0c       	ld.w	r12,r6[0x0]
800039d4:	0a 99       	mov	r9,r5
800039d6:	08 9a       	mov	r10,r4
800039d8:	1a 9b       	mov	r11,sp
800039da:	f0 1f 00 08 	mcall	800039f8 <payload_rx_process+0x48>
800039de:	58 1c       	cp.w	r12,1
800039e0:	cf 91       	brne	800039d2 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800039e2:	66 08       	ld.w	r8,r3[0x0]
800039e4:	40 0c       	lddsp	r12,sp[0x0]
800039e6:	5d 18       	icall	r8
800039e8:	cf 5b       	rjmp	800039d2 <payload_rx_process+0x22>
800039ea:	00 00       	add	r0,r0
800039ec:	00 00       	add	r0,r0
800039ee:	0f 88       	ld.ub	r8,r7[0x0]
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	8f bc       	st.w	r7[0x2c],r12
800039f4:	00 00       	add	r0,r0
800039f6:	0f 70       	ld.ub	r0,--r7
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	8c 58       	ld.sh	r8,r6[0xa]

800039fc <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800039fc:	d4 01       	pushm	lr
800039fe:	20 2d       	sub	sp,8
80003a00:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a02:	30 09       	mov	r9,0
80003a04:	fa ca ff f8 	sub	r10,sp,-8
80003a08:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003a0a:	1a 9b       	mov	r11,sp
80003a0c:	f0 1f 00 02 	mcall	80003a14 <set_idle_store_isr+0x18>
}
80003a10:	2f ed       	sub	sp,-8
80003a12:	d8 02       	popm	pc
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	8e 14       	ld.sh	r4,r7[0x2]

80003a18 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003a18:	d4 01       	pushm	lr
80003a1a:	20 2d       	sub	sp,8
80003a1c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003a1e:	58 0c       	cp.w	r12,0
80003a20:	c1 10       	breq	80003a42 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a22:	30 08       	mov	r8,0
80003a24:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003a26:	98 88       	ld.uh	r8,r12[0x0]
80003a28:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a2c:	e0 48 40 00 	cp.w	r8,16384
80003a30:	c0 91       	brne	80003a42 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003a32:	48 68       	lddpc	r8,80003a48 <phy_rx+0x30>
80003a34:	70 0c       	ld.w	r12,r8[0x0]
80003a36:	30 09       	mov	r9,0
80003a38:	fa ca ff fc 	sub	r10,sp,-4
80003a3c:	1a 9b       	mov	r11,sp
80003a3e:	f0 1f 00 04 	mcall	80003a4c <phy_rx+0x34>
		}	

    }
		
 
}
80003a42:	2f ed       	sub	sp,-8
80003a44:	d8 02       	popm	pc
80003a46:	00 00       	add	r0,r0
80003a48:	00 00       	add	r0,r0
80003a4a:	0f c4       	ld.ub	r4,r7[0x4]
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	8e 14       	ld.sh	r4,r7[0x2]

80003a50 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003a50:	eb cd 40 80 	pushm	r7,lr
80003a54:	20 1d       	sub	sp,4
80003a56:	fa c7 ff fc 	sub	r7,sp,-4
80003a5a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003a5c:	30 09       	mov	r9,0
80003a5e:	12 9a       	mov	r10,r9
80003a60:	1a 9b       	mov	r11,sp
80003a62:	f0 1f 00 03 	mcall	80003a6c <set_idle_store+0x1c>
}
80003a66:	2f fd       	sub	sp,-4
80003a68:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	8e 64       	ld.sh	r4,r7[0xc]

80003a70 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003a70:	d4 01       	pushm	lr
80003a72:	20 1d       	sub	sp,4
80003a74:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003a76:	98 88       	ld.uh	r8,r12[0x0]
80003a78:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a7c:	e0 48 40 00 	cp.w	r8,16384
80003a80:	c0 d1       	brne	80003a9a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003a82:	49 08       	lddpc	r8,80003ac0 <phy_tx+0x50>
80003a84:	70 08       	ld.w	r8,r8[0x0]
80003a86:	58 08       	cp.w	r8,0
80003a88:	c1 a0       	breq	80003abc <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003a8a:	48 e8       	lddpc	r8,80003ac0 <phy_tx+0x50>
80003a8c:	70 0c       	ld.w	r12,r8[0x0]
80003a8e:	30 09       	mov	r9,0
80003a90:	12 9a       	mov	r10,r9
80003a92:	1a 9b       	mov	r11,sp
80003a94:	f0 1f 00 0c 	mcall	80003ac4 <phy_tx+0x54>
80003a98:	c1 28       	rjmp	80003abc <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003a9a:	e0 48 10 00 	cp.w	r8,4096
80003a9e:	5f 0a       	sreq	r10
80003aa0:	e0 48 20 00 	cp.w	r8,8192
80003aa4:	5f 09       	sreq	r9
80003aa6:	f5 e9 10 09 	or	r9,r10,r9
80003aaa:	c0 71       	brne	80003ab8 <phy_tx+0x48>
80003aac:	e0 48 50 00 	cp.w	r8,20480
80003ab0:	c0 40       	breq	80003ab8 <phy_tx+0x48>
80003ab2:	e0 48 60 00 	cp.w	r8,24576
80003ab6:	c0 31       	brne	80003abc <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003ab8:	48 48       	lddpc	r8,80003ac8 <phy_tx+0x58>
80003aba:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003abc:	2f fd       	sub	sp,-4
80003abe:	d8 02       	popm	pc
80003ac0:	00 00       	add	r0,r0
80003ac2:	0f d8       	ld.ub	r8,r7[0x5]
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	8e 64       	ld.sh	r4,r7[0xc]
80003ac8:	00 00       	add	r0,r0
80003aca:	0f bc       	ld.ub	r12,r7[0x3]

80003acc <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003acc:	d4 01       	pushm	lr
80003ace:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003ad0:	30 08       	mov	r8,0
80003ad2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003ad4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003ad6:	1a 9a       	mov	r10,sp
80003ad8:	fa cb ff fc 	sub	r11,sp,-4
80003adc:	f0 1f 00 05 	mcall	80003af0 <get_idle_store_isr+0x24>
80003ae0:	58 1c       	cp.w	r12,1
80003ae2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003ae6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003aea:	2f ed       	sub	sp,-8
80003aec:	d8 02       	popm	pc
80003aee:	00 00       	add	r0,r0
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	8b 68       	st.w	r5[0x18],r8

80003af4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003af4:	eb cd 40 c0 	pushm	r6-r7,lr
80003af8:	20 1d       	sub	sp,4
80003afa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003afc:	fe f8 05 54 	ld.w	r8,pc[1364]
80003b00:	70 08       	ld.w	r8,r8[0x0]
80003b02:	58 08       	cp.w	r8,0
80003b04:	c7 40       	breq	80003bec <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003b06:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003b08:	30 08       	mov	r8,0
80003b0a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003b0c:	fe f8 05 48 	ld.w	r8,pc[1352]
80003b10:	70 08       	ld.w	r8,r8[0x0]
80003b12:	58 18       	cp.w	r8,1
80003b14:	c2 90       	breq	80003b66 <phy_tx_func+0x72>
80003b16:	c0 43       	brcs	80003b1e <phy_tx_func+0x2a>
80003b18:	58 28       	cp.w	r8,2
80003b1a:	c6 91       	brne	80003bec <phy_tx_func+0xf8>
80003b1c:	c6 18       	rjmp	80003bde <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003b1e:	fe f8 05 32 	ld.w	r8,pc[1330]
80003b22:	70 0c       	ld.w	r12,r8[0x0]
80003b24:	1a 9a       	mov	r10,sp
80003b26:	fe fb 05 32 	ld.w	r11,pc[1330]
80003b2a:	f0 1f 01 4d 	mcall	8000405c <phy_tx_func+0x568>
80003b2e:	58 1c       	cp.w	r12,1
80003b30:	c1 51       	brne	80003b5a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003b32:	fe f8 05 26 	ld.w	r8,pc[1318]
80003b36:	70 08       	ld.w	r8,r8[0x0]
80003b38:	11 9a       	ld.ub	r10,r8[0x1]
80003b3a:	fe f9 05 26 	ld.w	r9,pc[1318]
80003b3e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003b40:	90 88       	ld.uh	r8,r8[0x0]
80003b42:	ea 18 ab cd 	orh	r8,0xabcd
80003b46:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003b48:	30 19       	mov	r9,1
80003b4a:	fe f8 05 1a 	ld.w	r8,pc[1306]
80003b4e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003b50:	30 19       	mov	r9,1
80003b52:	fe f8 05 02 	ld.w	r8,pc[1282]
80003b56:	91 09       	st.w	r8[0x0],r9
80003b58:	c4 a8       	rjmp	80003bec <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003b5a:	e0 68 5a 5a 	mov	r8,23130
80003b5e:	ea 18 ab cd 	orh	r8,0xabcd
80003b62:	8f 18       	st.w	r7[0x4],r8
80003b64:	c4 48       	rjmp	80003bec <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b66:	fe f9 04 fe 	ld.w	r9,pc[1278]
80003b6a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003b6c:	fe fa 04 ec 	ld.w	r10,pc[1260]
80003b70:	74 0a       	ld.w	r10,r10[0x0]
80003b72:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003b76:	b1 6a       	lsl	r10,0x10
80003b78:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b7a:	2f f8       	sub	r8,-1
80003b7c:	5c 58       	castu.b	r8
80003b7e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003b80:	fe fa 04 e0 	ld.w	r10,pc[1248]
80003b84:	94 09       	ld.sh	r9,r10[0x0]
80003b86:	20 29       	sub	r9,2
80003b88:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003b8a:	30 0a       	mov	r10,0
80003b8c:	f4 09 19 00 	cp.h	r9,r10
80003b90:	e0 89 00 0b 	brgt	80003ba6 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003b94:	78 18       	ld.w	r8,r12[0x4]
80003b96:	e8 18 00 ba 	orl	r8,0xba
80003b9a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003b9c:	30 09       	mov	r9,0
80003b9e:	fe f8 04 b6 	ld.w	r8,pc[1206]
80003ba2:	91 09       	st.w	r8[0x0],r9
80003ba4:	c2 48       	rjmp	80003bec <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003ba6:	fe f9 04 b2 	ld.w	r9,pc[1202]
80003baa:	72 09       	ld.w	r9,r9[0x0]
80003bac:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003bb0:	78 1a       	ld.w	r10,r12[0x4]
80003bb2:	f5 e9 10 09 	or	r9,r10,r9
80003bb6:	99 19       	st.w	r12[0x4],r9
80003bb8:	2f f8       	sub	r8,-1
80003bba:	fe f9 04 aa 	ld.w	r9,pc[1194]
80003bbe:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003bc0:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003bc4:	92 08       	ld.sh	r8,r9[0x0]
80003bc6:	20 28       	sub	r8,2
80003bc8:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003bca:	30 09       	mov	r9,0
80003bcc:	f2 08 19 00 	cp.h	r8,r9
80003bd0:	e0 89 00 0e 	brgt	80003bec <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003bd4:	30 29       	mov	r9,2
80003bd6:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003bda:	91 09       	st.w	r8[0x0],r9
80003bdc:	c0 88       	rjmp	80003bec <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003bde:	fc 18 00 ba 	movh	r8,0xba
80003be2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003be4:	30 09       	mov	r9,0
80003be6:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003bea:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003bec:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003bf0:	11 89       	ld.ub	r9,r8[0x0]
80003bf2:	30 08       	mov	r8,0
80003bf4:	f0 09 18 00 	cp.b	r9,r8
80003bf8:	e0 80 00 c6 	breq	80003d84 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80003bfc:	fe f8 04 70 	ld.w	r8,pc[1136]
80003c00:	11 88       	ld.ub	r8,r8[0x0]
80003c02:	30 19       	mov	r9,1
80003c04:	f2 08 18 00 	cp.b	r8,r9
80003c08:	c3 e0       	breq	80003c84 <phy_tx_func+0x190>
80003c0a:	c0 73       	brcs	80003c18 <phy_tx_func+0x124>
80003c0c:	30 29       	mov	r9,2
80003c0e:	f2 08 18 00 	cp.b	r8,r9
80003c12:	e0 81 02 1b 	brne	80004048 <phy_tx_func+0x554>
80003c16:	c9 28       	rjmp	80003d3a <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003c18:	fe f8 04 58 	ld.w	r8,pc[1112]
80003c1c:	70 08       	ld.w	r8,r8[0x0]
80003c1e:	58 08       	cp.w	r8,0
80003c20:	c0 b0       	breq	80003c36 <phy_tx_func+0x142>
80003c22:	fe f8 04 4e 	ld.w	r8,pc[1102]
80003c26:	70 08       	ld.w	r8,r8[0x0]
80003c28:	58 98       	cp.w	r8,9
80003c2a:	c0 60       	breq	80003c36 <phy_tx_func+0x142>
80003c2c:	fe f8 04 44 	ld.w	r8,pc[1092]
80003c30:	70 08       	ld.w	r8,r8[0x0]
80003c32:	58 18       	cp.w	r8,1
80003c34:	c0 a1       	brne	80003c48 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003c36:	e0 68 5a 5a 	mov	r8,23130
80003c3a:	ea 18 ab cd 	orh	r8,0xabcd
80003c3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003c40:	30 08       	mov	r8,0
80003c42:	8f 38       	st.w	r7[0xc],r8
80003c44:	e0 8f 02 02 	bral	80004048 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003c48:	fe f8 04 28 	ld.w	r8,pc[1064]
80003c4c:	70 08       	ld.w	r8,r8[0x0]
80003c4e:	58 28       	cp.w	r8,2
80003c50:	c0 91       	brne	80003c62 <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003c52:	fe f8 04 22 	ld.w	r8,pc[1058]
80003c56:	70 09       	ld.w	r9,r8[0x0]
80003c58:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003c5a:	70 18       	ld.w	r8,r8[0x4]
80003c5c:	8f 38       	st.w	r7[0xc],r8
80003c5e:	e0 8f 01 f5 	bral	80004048 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
80003c62:	30 19       	mov	r9,1
80003c64:	fe f8 04 08 	ld.w	r8,pc[1032]
80003c68:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003c6a:	e0 68 c0 0e 	mov	r8,49166
80003c6e:	ea 18 ab cd 	orh	r8,0xabcd
80003c72:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003c74:	fe f8 04 04 	ld.w	r8,pc[1028]
80003c78:	90 09       	ld.sh	r9,r8[0x0]
80003c7a:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003c7c:	90 18       	ld.sh	r8,r8[0x2]
80003c7e:	ae 78       	st.h	r7[0xe],r8
80003c80:	e0 8f 01 e4 	bral	80004048 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003c84:	fe 78 88 f2 	mov	r8,-30478
80003c88:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//
80003c8a:	fe f8 03 e6 	ld.w	r8,pc[998]
80003c8e:	70 08       	ld.w	r8,r8[0x0]
80003c90:	58 38       	cp.w	r8,3
80003c92:	c0 60       	breq	80003c9e <phy_tx_func+0x1aa>
80003c94:	c4 73       	brcs	80003d22 <phy_tx_func+0x22e>
80003c96:	58 88       	cp.w	r8,8
80003c98:	e0 8b 00 45 	brhi	80003d22 <phy_tx_func+0x22e>
80003c9c:	c2 a8       	rjmp	80003cf0 <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003c9e:	fe f8 03 de 	ld.w	r8,pc[990]
80003ca2:	11 89       	ld.ub	r9,r8[0x0]
80003ca4:	30 18       	mov	r8,1
80003ca6:	f0 09 18 00 	cp.b	r9,r8
80003caa:	c0 a1       	brne	80003cbe <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003cac:	fe f8 03 d4 	ld.w	r8,pc[980]
80003cb0:	90 09       	ld.sh	r9,r8[0x0]
80003cb2:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003cb4:	90 19       	ld.sh	r9,r8[0x2]
80003cb6:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003cb8:	90 28       	ld.sh	r8,r8[0x4]
80003cba:	ae 78       	st.h	r7[0xe],r8
80003cbc:	c1 48       	rjmp	80003ce4 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003cbe:	fe f9 03 c6 	ld.w	r9,pc[966]
80003cc2:	92 0b       	ld.sh	r11,r9[0x0]
80003cc4:	fe f8 03 bc 	ld.w	r8,pc[956]
80003cc8:	90 0a       	ld.sh	r10,r8[0x0]
80003cca:	f7 ea 20 0a 	eor	r10,r11,r10
80003cce:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003cd0:	92 1b       	ld.sh	r11,r9[0x2]
80003cd2:	90 1a       	ld.sh	r10,r8[0x2]
80003cd4:	f7 ea 20 0a 	eor	r10,r11,r10
80003cd8:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003cda:	92 29       	ld.sh	r9,r9[0x4]
80003cdc:	90 28       	ld.sh	r8,r8[0x4]
80003cde:	f3 e8 20 08 	eor	r8,r9,r8
80003ce2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80003ce4:	30 29       	mov	r9,2
80003ce6:	fe f8 03 86 	ld.w	r8,pc[902]
80003cea:	b0 89       	st.b	r8[0x0],r9
80003cec:	e0 8f 01 ae 	bral	80004048 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003cf0:	fe f9 03 94 	ld.w	r9,pc[916]
80003cf4:	92 0b       	ld.sh	r11,r9[0x0]
80003cf6:	fe f8 03 8a 	ld.w	r8,pc[906]
80003cfa:	90 0a       	ld.sh	r10,r8[0x0]
80003cfc:	f7 ea 20 0a 	eor	r10,r11,r10
80003d00:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003d02:	92 1b       	ld.sh	r11,r9[0x2]
80003d04:	90 1a       	ld.sh	r10,r8[0x2]
80003d06:	f7 ea 20 0a 	eor	r10,r11,r10
80003d0a:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003d0c:	92 29       	ld.sh	r9,r9[0x4]
80003d0e:	90 28       	ld.sh	r8,r8[0x4]
80003d10:	f3 e8 20 08 	eor	r8,r9,r8
80003d14:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80003d16:	30 29       	mov	r9,2
80003d18:	fe f8 03 54 	ld.w	r8,pc[852]
80003d1c:	b0 89       	st.b	r8[0x0],r9
80003d1e:	e0 8f 01 95 	bral	80004048 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003d22:	e0 68 5a 5a 	mov	r8,23130
80003d26:	ea 18 ab cd 	orh	r8,0xabcd
80003d2a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003d2c:	30 08       	mov	r8,0
80003d2e:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
80003d30:	fe f9 03 3c 	ld.w	r9,pc[828]
80003d34:	b2 88       	st.b	r9[0x0],r8
80003d36:	e0 8f 01 89 	bral	80004048 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80003d3a:	fe f8 03 36 	ld.w	r8,pc[822]
80003d3e:	70 08       	ld.w	r8,r8[0x0]
80003d40:	58 38       	cp.w	r8,3
80003d42:	c0 d1       	brne	80003d5c <phy_tx_func+0x268>
80003d44:	fe f8 03 38 	ld.w	r8,pc[824]
80003d48:	11 89       	ld.ub	r9,r8[0x0]
80003d4a:	30 18       	mov	r8,1
80003d4c:	f0 09 18 00 	cp.b	r9,r8
80003d50:	c0 61       	brne	80003d5c <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80003d52:	fe f8 03 2e 	ld.w	r8,pc[814]
80003d56:	90 38       	ld.sh	r8,r8[0x6]
80003d58:	ae 48       	st.h	r7[0x8],r8
80003d5a:	c0 a8       	rjmp	80003d6e <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80003d5c:	fe f8 03 28 	ld.w	r8,pc[808]
80003d60:	90 39       	ld.sh	r9,r8[0x6]
80003d62:	fe f8 03 1e 	ld.w	r8,pc[798]
80003d66:	90 38       	ld.sh	r8,r8[0x6]
80003d68:	f3 e8 20 08 	eor	r8,r9,r8
80003d6c:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
80003d6e:	e0 68 00 ba 	mov	r8,186
80003d72:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003d74:	30 08       	mov	r8,0
80003d76:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003d78:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80003d7a:	fe f9 02 f2 	ld.w	r9,pc[754]
80003d7e:	b2 88       	st.b	r9[0x0],r8
80003d80:	e0 8f 01 64 	bral	80004048 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80003d84:	fe f8 03 04 	ld.w	r8,pc[772]
80003d88:	70 08       	ld.w	r8,r8[0x0]
80003d8a:	e0 48 76 20 	cp.w	r8,30240
80003d8e:	f9 b8 02 00 	movhs	r8,0
80003d92:	fe f9 02 f6 	ld.w	r9,pc[758]
80003d96:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80003d98:	fe f8 02 f4 	ld.w	r8,pc[756]
80003d9c:	11 89       	ld.ub	r9,r8[0x0]
80003d9e:	30 18       	mov	r8,1
80003da0:	f0 09 18 00 	cp.b	r9,r8
80003da4:	c0 61       	brne	80003db0 <phy_tx_func+0x2bc>
80003da6:	fe f8 02 ea 	ld.w	r8,pc[746]
80003daa:	70 09       	ld.w	r9,r8[0x0]
80003dac:	2f f9       	sub	r9,-1
80003dae:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80003db0:	fe f8 02 bc 	ld.w	r8,pc[700]
80003db4:	11 88       	ld.ub	r8,r8[0x0]
80003db6:	30 19       	mov	r9,1
80003db8:	f2 08 18 00 	cp.b	r8,r9
80003dbc:	c3 60       	breq	80003e28 <phy_tx_func+0x334>
80003dbe:	c0 73       	brcs	80003dcc <phy_tx_func+0x2d8>
80003dc0:	30 29       	mov	r9,2
80003dc2:	f2 08 18 00 	cp.b	r8,r9
80003dc6:	e0 81 01 3e 	brne	80004042 <phy_tx_func+0x54e>
80003dca:	c7 c8       	rjmp	80003ec2 <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003dcc:	e0 68 5a 5a 	mov	r8,23130
80003dd0:	ea 18 ab cd 	orh	r8,0xabcd
80003dd4:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003dd6:	30 08       	mov	r8,0
80003dd8:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80003dda:	fe f8 02 b6 	ld.w	r8,pc[694]
80003dde:	70 08       	ld.w	r8,r8[0x0]
80003de0:	e0 6b cc cd 	mov	r11,52429
80003de4:	ea 1b cc cc 	orh	r11,0xcccc
80003de8:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80003dec:	f6 09 16 04 	lsr	r9,r11,0x4
80003df0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003df4:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80003df8:	c1 21       	brne	80003e1c <phy_tx_func+0x328>
80003dfa:	58 08       	cp.w	r8,0
80003dfc:	c1 00       	breq	80003e1c <phy_tx_func+0x328>
80003dfe:	fe f8 02 8e 	ld.w	r8,pc[654]
80003e02:	11 89       	ld.ub	r9,r8[0x0]
80003e04:	30 18       	mov	r8,1
80003e06:	f0 09 18 00 	cp.b	r9,r8
80003e0a:	c0 91       	brne	80003e1c <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
80003e0c:	10 99       	mov	r9,r8
80003e0e:	fe f8 02 5e 	ld.w	r8,pc[606]
80003e12:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80003e14:	30 09       	mov	r9,0
80003e16:	fe f8 02 7e 	ld.w	r8,pc[638]
80003e1a:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80003e1c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003e20:	70 09       	ld.w	r9,r8[0x0]
80003e22:	2f f9       	sub	r9,-1
80003e24:	91 09       	st.w	r8[0x0],r9
80003e26:	c1 19       	rjmp	80004048 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80003e28:	fe 78 ab cd 	mov	r8,-21555
80003e2c:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80003e2e:	fe f8 02 66 	ld.w	r8,pc[614]
80003e32:	11 89       	ld.ub	r9,r8[0x0]
80003e34:	30 08       	mov	r8,0
80003e36:	f0 09 18 00 	cp.b	r9,r8
80003e3a:	c1 b1       	brne	80003e70 <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
80003e3c:	fe f8 02 60 	ld.w	r8,pc[608]
80003e40:	11 89       	ld.ub	r9,r8[0x0]
80003e42:	30 18       	mov	r8,1
80003e44:	f0 09 18 00 	cp.b	r9,r8
80003e48:	c0 91       	brne	80003e5a <phy_tx_func+0x366>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80003e4a:	32 c9       	mov	r9,44
80003e4c:	fe f8 02 54 	ld.w	r8,pc[596]
80003e50:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80003e52:	e0 68 10 2c 	mov	r8,4140
80003e56:	ae 58       	st.h	r7[0xa],r8
80003e58:	c0 88       	rjmp	80003e68 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80003e5a:	32 a9       	mov	r9,42
80003e5c:	fe f8 02 44 	ld.w	r8,pc[580]
80003e60:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80003e62:	e0 68 10 2a 	mov	r8,4138
80003e66:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80003e68:	30 19       	mov	r9,1
80003e6a:	fe f8 02 3a 	ld.w	r8,pc[570]
80003e6e:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80003e70:	fe f8 02 2c 	ld.w	r8,pc[556]
80003e74:	11 89       	ld.ub	r9,r8[0x0]
80003e76:	30 18       	mov	r8,1
80003e78:	f0 09 18 00 	cp.b	r9,r8
80003e7c:	c0 61       	brne	80003e88 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80003e7e:	30 18       	mov	r8,1
80003e80:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80003e82:	30 48       	mov	r8,4
80003e84:	ae 78       	st.h	r7[0xe],r8
80003e86:	c1 38       	rjmp	80003eac <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80003e88:	30 08       	mov	r8,0
80003e8a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003e8c:	4f f8       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003e8e:	70 09       	ld.w	r9,r8[0x0]
80003e90:	fe fa 02 18 	ld.w	r10,pc[536]
80003e94:	f4 09 00 0b 	add	r11,r10,r9
80003e98:	17 9b       	ld.ub	r11,r11[0x1]
80003e9a:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003e9e:	a9 69       	lsl	r9,0x8
80003ea0:	f6 09 00 09 	add	r9,r11,r9
80003ea4:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003ea6:	70 09       	ld.w	r9,r8[0x0]
80003ea8:	2f e9       	sub	r9,-2
80003eaa:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80003eac:	4f d8       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
80003eae:	90 09       	ld.sh	r9,r8[0x0]
80003eb0:	20 49       	sub	r9,4
80003eb2:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80003eb4:	30 29       	mov	r9,2
80003eb6:	4e e8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003eb8:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80003eba:	30 09       	mov	r9,0
80003ebc:	4f c8       	lddpc	r8,800040ac <phy_tx_func+0x5b8>
80003ebe:	91 09       	st.w	r8[0x0],r9
80003ec0:	cc 48       	rjmp	80004048 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80003ec2:	4f 88       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
80003ec4:	90 09       	ld.sh	r9,r8[0x0]
80003ec6:	30 08       	mov	r8,0
80003ec8:	f0 09 19 00 	cp.h	r9,r8
80003ecc:	e0 89 00 12 	brgt	80003ef0 <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ed0:	4f 58       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003ed2:	11 89       	ld.ub	r9,r8[0x0]
80003ed4:	30 08       	mov	r8,0
80003ed6:	f0 09 18 00 	cp.b	r9,r8
80003eda:	5f 09       	sreq	r9
80003edc:	4e 48       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003ede:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80003ee0:	e0 68 00 ba 	mov	r8,186
80003ee4:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80003ee6:	30 08       	mov	r8,0
80003ee8:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003eea:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003eec:	ae 78       	st.h	r7[0xe],r8
80003eee:	ca d8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003ef0:	4e b8       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003ef2:	11 89       	ld.ub	r9,r8[0x0]
80003ef4:	30 18       	mov	r8,1
80003ef6:	f0 09 18 00 	cp.b	r9,r8
80003efa:	c0 41       	brne	80003f02 <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
80003efc:	30 08       	mov	r8,0
80003efe:	ae 48       	st.h	r7[0x8],r8
80003f00:	c1 08       	rjmp	80003f20 <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f02:	4e 28       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003f04:	70 09       	ld.w	r9,r8[0x0]
80003f06:	4e 9a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003f08:	f4 09 00 0b 	add	r11,r10,r9
80003f0c:	17 9b       	ld.ub	r11,r11[0x1]
80003f0e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f12:	a9 69       	lsl	r9,0x8
80003f14:	f6 09 00 09 	add	r9,r11,r9
80003f18:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80003f1a:	70 09       	ld.w	r9,r8[0x0]
80003f1c:	2f e9       	sub	r9,-2
80003f1e:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
80003f20:	4e 09       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003f22:	92 08       	ld.sh	r8,r9[0x0]
80003f24:	20 28       	sub	r8,2
80003f26:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f28:	30 09       	mov	r9,0
80003f2a:	f2 08 19 00 	cp.h	r8,r9
80003f2e:	e0 89 00 11 	brgt	80003f50 <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f32:	4d d8       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003f34:	11 89       	ld.ub	r9,r8[0x0]
80003f36:	30 08       	mov	r8,0
80003f38:	f0 09 18 00 	cp.b	r9,r8
80003f3c:	5f 09       	sreq	r9
80003f3e:	4c c8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003f40:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80003f42:	e0 68 00 ba 	mov	r8,186
80003f46:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003f48:	30 08       	mov	r8,0
80003f4a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003f4c:	ae 78       	st.h	r7[0xe],r8
80003f4e:	c7 d8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003f50:	4d 38       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003f52:	11 89       	ld.ub	r9,r8[0x0]
80003f54:	30 18       	mov	r8,1
80003f56:	f0 09 18 00 	cp.b	r9,r8
80003f5a:	c0 41       	brne	80003f62 <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
80003f5c:	30 08       	mov	r8,0
80003f5e:	ae 58       	st.h	r7[0xa],r8
80003f60:	c1 08       	rjmp	80003f80 <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f62:	4c a8       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003f64:	70 09       	ld.w	r9,r8[0x0]
80003f66:	4d 1a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003f68:	f4 09 00 0b 	add	r11,r10,r9
80003f6c:	17 9b       	ld.ub	r11,r11[0x1]
80003f6e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f72:	a9 69       	lsl	r9,0x8
80003f74:	f6 09 00 09 	add	r9,r11,r9
80003f78:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80003f7a:	70 09       	ld.w	r9,r8[0x0]
80003f7c:	2f e9       	sub	r9,-2
80003f7e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003f80:	4c 89       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003f82:	92 08       	ld.sh	r8,r9[0x0]
80003f84:	20 28       	sub	r8,2
80003f86:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f88:	30 09       	mov	r9,0
80003f8a:	f2 08 19 00 	cp.h	r8,r9
80003f8e:	e0 89 00 10 	brgt	80003fae <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f92:	4c 58       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003f94:	11 89       	ld.ub	r9,r8[0x0]
80003f96:	30 08       	mov	r8,0
80003f98:	f0 09 18 00 	cp.b	r9,r8
80003f9c:	5f 09       	sreq	r9
80003f9e:	4b 48       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003fa0:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
80003fa2:	e0 68 00 ba 	mov	r8,186
80003fa6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003fa8:	30 08       	mov	r8,0
80003faa:	ae 78       	st.h	r7[0xe],r8
80003fac:	c4 e8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003fae:	4b c8       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003fb0:	11 89       	ld.ub	r9,r8[0x0]
80003fb2:	30 18       	mov	r8,1
80003fb4:	f0 09 18 00 	cp.b	r9,r8
80003fb8:	c0 41       	brne	80003fc0 <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80003fba:	30 08       	mov	r8,0
80003fbc:	ae 68       	st.h	r7[0xc],r8
80003fbe:	c1 08       	rjmp	80003fde <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003fc0:	4b 28       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003fc2:	70 09       	ld.w	r9,r8[0x0]
80003fc4:	4b 9a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003fc6:	f4 09 00 0b 	add	r11,r10,r9
80003fca:	17 9b       	ld.ub	r11,r11[0x1]
80003fcc:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003fd0:	a9 69       	lsl	r9,0x8
80003fd2:	f6 09 00 09 	add	r9,r11,r9
80003fd6:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80003fd8:	70 09       	ld.w	r9,r8[0x0]
80003fda:	2f e9       	sub	r9,-2
80003fdc:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003fde:	4b 19       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003fe0:	92 08       	ld.sh	r8,r9[0x0]
80003fe2:	20 28       	sub	r8,2
80003fe4:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003fe6:	30 09       	mov	r9,0
80003fe8:	f2 08 19 00 	cp.h	r8,r9
80003fec:	e0 89 00 0e 	brgt	80004008 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ff0:	4a d8       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003ff2:	11 89       	ld.ub	r9,r8[0x0]
80003ff4:	30 08       	mov	r8,0
80003ff6:	f0 09 18 00 	cp.b	r9,r8
80003ffa:	5f 09       	sreq	r9
80003ffc:	49 c8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003ffe:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80004000:	e0 68 00 ba 	mov	r8,186
80004004:	ae 78       	st.h	r7[0xe],r8
80004006:	c2 18       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80004008:	4a 58       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
8000400a:	11 89       	ld.ub	r9,r8[0x0]
8000400c:	30 18       	mov	r8,1
8000400e:	f0 09 18 00 	cp.b	r9,r8
80004012:	c0 41       	brne	8000401a <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
80004014:	30 08       	mov	r8,0
80004016:	ae 78       	st.h	r7[0xe],r8
80004018:	c1 08       	rjmp	80004038 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000401a:	49 c8       	lddpc	r8,80004088 <phy_tx_func+0x594>
8000401c:	70 09       	ld.w	r9,r8[0x0]
8000401e:	4a 3a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80004020:	f4 09 00 0b 	add	r11,r10,r9
80004024:	17 9b       	ld.ub	r11,r11[0x1]
80004026:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000402a:	a9 69       	lsl	r9,0x8
8000402c:	f6 09 00 09 	add	r9,r11,r9
80004030:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80004032:	70 09       	ld.w	r9,r8[0x0]
80004034:	2f e9       	sub	r9,-2
80004036:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004038:	49 a8       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
8000403a:	90 09       	ld.sh	r9,r8[0x0]
8000403c:	20 29       	sub	r9,2
8000403e:	b0 09       	st.h	r8[0x0],r9
80004040:	c0 48       	rjmp	80004048 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
80004042:	30 09       	mov	r9,0
80004044:	48 a8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80004046:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004048:	2f fd       	sub	sp,-4
8000404a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000404e:	00 00       	add	r0,r0
80004050:	00 00       	add	r0,r0
80004052:	0f d8       	ld.ub	r8,r7[0x5]
80004054:	00 00       	add	r0,r0
80004056:	0f 9c       	ld.ub	r12,r7[0x1]
80004058:	00 00       	add	r0,r0
8000405a:	0f 78       	ld.ub	r8,--r7
8000405c:	80 00       	ld.sh	r0,r0[0x0]
8000405e:	8b 68       	st.w	r5[0x18],r8
80004060:	00 00       	add	r0,r0
80004062:	0f c2       	ld.ub	r2,r7[0x4]
80004064:	00 00       	add	r0,r0
80004066:	0f b1       	ld.ub	r1,r7[0x3]
80004068:	00 00       	add	r0,r0
8000406a:	0a 44       	or	r4,r5
8000406c:	00 00       	add	r0,r0
8000406e:	0f b8       	ld.ub	r8,r7[0x3]
80004070:	00 00       	add	r0,r0
80004072:	0f 80       	ld.ub	r0,r7[0x0]
80004074:	00 00       	add	r0,r0
80004076:	0f a0       	ld.ub	r0,r7[0x2]
80004078:	00 00       	add	r0,r0
8000407a:	13 c4       	ld.ub	r4,r9[0x4]
8000407c:	00 00       	add	r0,r0
8000407e:	0a 4c       	or	r12,r5
80004080:	80 01       	ld.sh	r1,r0[0x0]
80004082:	04 4c       	or	r12,r2
80004084:	00 00       	add	r0,r0
80004086:	12 cc       	st.b	r9++,r12
80004088:	00 00       	add	r0,r0
8000408a:	0f 90       	ld.ub	r0,r7[0x1]
8000408c:	00 00       	add	r0,r0
8000408e:	0a 4d       	or	sp,r5
80004090:	00 00       	add	r0,r0
80004092:	0f dc       	ld.ub	r12,r7[0x5]
80004094:	00 00       	add	r0,r0
80004096:	0f b0       	ld.ub	r0,r7[0x3]
80004098:	00 00       	add	r0,r0
8000409a:	0f cc       	ld.ub	r12,r7[0x4]
8000409c:	00 00       	add	r0,r0
8000409e:	0a 54       	eor	r4,r5
800040a0:	00 00       	add	r0,r0
800040a2:	0f e8       	ld.ub	r8,r7[0x6]
800040a4:	00 00       	add	r0,r0
800040a6:	0f 84       	ld.ub	r4,r7[0x0]
800040a8:	80 01       	ld.sh	r1,r0[0x0]
800040aa:	04 a8       	st.w	r2++,r8
800040ac:	00 00       	add	r0,r0
800040ae:	0f ec       	ld.ub	r12,r7[0x6]

800040b0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800040b0:	d4 01       	pushm	lr
800040b2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800040b4:	30 0a       	mov	r10,0
800040b6:	fa cb ff fc 	sub	r11,sp,-4
800040ba:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800040bc:	14 99       	mov	r9,r10
800040be:	1a 9b       	mov	r11,sp
800040c0:	f0 1f 00 05 	mcall	800040d4 <get_idle_store+0x24>
800040c4:	58 1c       	cp.w	r12,1
800040c6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800040ca:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800040ce:	2f fd       	sub	sp,-4
800040d0:	d8 02       	popm	pc
800040d2:	00 00       	add	r0,r0
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	8c 58       	ld.sh	r8,r6[0xa]

800040d8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800040d8:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
800040dc:	f0 1f 00 21 	mcall	80004160 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800040e0:	4a 1b       	lddpc	r11,80004164 <phy_init+0x8c>
800040e2:	4a 2c       	lddpc	r12,80004168 <phy_init+0x90>
800040e4:	f0 1f 00 22 	mcall	8000416c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040e8:	30 4b       	mov	r11,4
800040ea:	31 ec       	mov	r12,30
800040ec:	f0 1f 00 21 	mcall	80004170 <phy_init+0x98>
800040f0:	4a 18       	lddpc	r8,80004174 <phy_init+0x9c>
800040f2:	91 0c       	st.w	r8[0x0],r12
800040f4:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040f6:	10 96       	mov	r6,r8
800040f8:	4a 05       	lddpc	r5,80004178 <phy_init+0xa0>
800040fa:	6c 0c       	ld.w	r12,r6[0x0]
800040fc:	ea 07 00 0b 	add	r11,r5,r7
80004100:	f0 1f 00 1f 	mcall	8000417c <phy_init+0xa4>
80004104:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004108:	e0 47 1e 00 	cp.w	r7,7680
8000410c:	cf 71       	brne	800040fa <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000410e:	30 4b       	mov	r11,4
80004110:	31 4c       	mov	r12,20
80004112:	f0 1f 00 18 	mcall	80004170 <phy_init+0x98>
80004116:	49 b8       	lddpc	r8,80004180 <phy_init+0xa8>
80004118:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000411a:	30 4b       	mov	r11,4
8000411c:	30 ac       	mov	r12,10
8000411e:	f0 1f 00 15 	mcall	80004170 <phy_init+0x98>
80004122:	49 98       	lddpc	r8,80004184 <phy_init+0xac>
80004124:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004126:	30 4b       	mov	r11,4
80004128:	30 ac       	mov	r12,10
8000412a:	f0 1f 00 12 	mcall	80004170 <phy_init+0x98>
8000412e:	49 78       	lddpc	r8,80004188 <phy_init+0xb0>
80004130:	91 0c       	st.w	r8[0x0],r12
80004132:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004134:	10 96       	mov	r6,r8
80004136:	49 65       	lddpc	r5,8000418c <phy_init+0xb4>
80004138:	6c 0c       	ld.w	r12,r6[0x0]
8000413a:	ea 07 00 0b 	add	r11,r5,r7
8000413e:	f0 1f 00 10 	mcall	8000417c <phy_init+0xa4>
80004142:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004146:	e0 47 14 00 	cp.w	r7,5120
8000414a:	cf 71       	brne	80004138 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
8000414c:	e0 6b 01 00 	mov	r11,256
80004150:	30 5c       	mov	r12,5
80004152:	f0 1f 00 08 	mcall	80004170 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80004156:	48 f8       	lddpc	r8,80004190 <phy_init+0xb8>
80004158:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000415a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000415e:	00 00       	add	r0,r0
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	4d 2c       	lddpc	r12,800042a8 <phy_rx_func+0xb4>
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	3a f4       	mov	r4,-81
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	41 f4       	lddsp	r4,sp[0x7c]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	4d 18       	lddpc	r8,800042b0 <phy_rx_func+0xbc>
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	8f bc       	st.w	r7[0x2c],r12
80004174:	00 00       	add	r0,r0
80004176:	0f a8       	ld.ub	r8,r7[0x2]
80004178:	00 00       	add	r0,r0
8000417a:	27 c8       	sub	r8,124
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	3a 50       	mov	r0,-91
80004180:	00 00       	add	r0,r0
80004182:	0f d8       	ld.ub	r8,r7[0x5]
80004184:	00 00       	add	r0,r0
80004186:	0f c4       	ld.ub	r4,r7[0x4]
80004188:	00 00       	add	r0,r0
8000418a:	0f 98       	ld.ub	r8,r7[0x1]
8000418c:	00 00       	add	r0,r0
8000418e:	13 c8       	ld.ub	r8,r9[0x4]
80004190:	00 00       	add	r0,r0
80004192:	0f bc       	ld.ub	r12,r7[0x3]

80004194 <payload_rx>:




static void payload_rx(void * payload)
{
80004194:	d4 01       	pushm	lr
80004196:	20 2d       	sub	sp,8
80004198:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000419a:	30 08       	mov	r8,0
8000419c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000419e:	48 f8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041a0:	70 08       	ld.w	r8,r8[0x0]
800041a2:	58 08       	cp.w	r8,0
800041a4:	c0 71       	brne	800041b2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800041a6:	30 4b       	mov	r11,4
800041a8:	30 5c       	mov	r12,5
800041aa:	f0 1f 00 0d 	mcall	800041dc <payload_rx+0x48>
800041ae:	48 b8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041b0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800041b2:	48 a8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041b4:	70 0c       	ld.w	r12,r8[0x0]
800041b6:	30 09       	mov	r9,0
800041b8:	fa ca ff fc 	sub	r10,sp,-4
800041bc:	1a 9b       	mov	r11,sp
800041be:	f0 1f 00 09 	mcall	800041e0 <payload_rx+0x4c>
800041c2:	c0 91       	brne	800041d4 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800041c4:	48 88       	lddpc	r8,800041e4 <payload_rx+0x50>
800041c6:	70 0c       	ld.w	r12,r8[0x0]
800041c8:	40 0b       	lddsp	r11,sp[0x0]
800041ca:	f0 1f 00 08 	mcall	800041e8 <payload_rx+0x54>
		logFromISR("mm");
800041ce:	48 8c       	lddpc	r12,800041ec <payload_rx+0x58>
800041d0:	f0 1f 00 08 	mcall	800041f0 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800041d4:	2f ed       	sub	sp,-8
800041d6:	d8 02       	popm	pc
800041d8:	00 00       	add	r0,r0
800041da:	0f 88       	ld.ub	r8,r7[0x0]
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	8f bc       	st.w	r7[0x2c],r12
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	8e 14       	ld.sh	r4,r7[0x2]
800041e4:	00 00       	add	r0,r0
800041e6:	0f 98       	ld.ub	r8,r7[0x1]
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	39 fc       	mov	r12,-97
800041ec:	80 01       	ld.sh	r1,r0[0x0]
800041ee:	88 58       	ld.sh	r8,r4[0xa]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	9b e0       	st.w	sp[0x38],r0

800041f4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800041f4:	eb cd 40 e0 	pushm	r5-r7,lr
800041f8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800041fa:	fe f8 09 7e 	ld.w	r8,pc[2430]
800041fe:	70 08       	ld.w	r8,r8[0x0]
80004200:	58 08       	cp.w	r8,0
80004202:	e0 80 01 05 	breq	8000440c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80004206:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80004208:	fe f8 09 74 	ld.w	r8,pc[2420]
8000420c:	70 09       	ld.w	r9,r8[0x0]
8000420e:	2f f9       	sub	r9,-1
80004210:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80004212:	fe f8 09 6e 	ld.w	r8,pc[2414]
80004216:	70 08       	ld.w	r8,r8[0x0]
80004218:	58 18       	cp.w	r8,1
8000421a:	e0 80 00 84 	breq	80004322 <phy_rx_func+0x12e>
8000421e:	c0 73       	brcs	8000422c <phy_rx_func+0x38>
80004220:	58 28       	cp.w	r8,2
80004222:	c5 b0       	breq	800042d8 <phy_rx_func+0xe4>
80004224:	58 38       	cp.w	r8,3
80004226:	e0 81 00 f3 	brne	8000440c <phy_rx_func+0x218>
8000422a:	cd 38       	rjmp	800043d0 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000422c:	e0 6a 5a 5a 	mov	r10,23130
80004230:	ea 1a ab cd 	orh	r10,0xabcd
80004234:	14 36       	cp.w	r6,r10
80004236:	e0 80 00 eb 	breq	8000440c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000423a:	ec 08 16 10 	lsr	r8,r6,0x10
8000423e:	e0 48 ab cd 	cp.w	r8,43981
80004242:	e0 81 00 e5 	brne	8000440c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80004246:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000424a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000424e:	20 28       	sub	r8,2
80004250:	fe f9 09 34 	ld.w	r9,pc[2356]
80004254:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004256:	30 09       	mov	r9,0
80004258:	f2 08 19 00 	cp.h	r8,r9
8000425c:	e0 8a 00 d8 	brle	8000440c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80004260:	fe f8 09 28 	ld.w	r8,pc[2344]
80004264:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80004266:	fe f8 09 26 	ld.w	r8,pc[2342]
8000426a:	70 0c       	ld.w	r12,r8[0x0]
8000426c:	f0 1f 02 49 	mcall	80004b90 <phy_rx_func+0x99c>
80004270:	fe f8 09 24 	ld.w	r8,pc[2340]
80004274:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80004276:	58 0c       	cp.w	r12,0
80004278:	e0 80 00 ca 	breq	8000440c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000427c:	fe f8 09 0c 	ld.w	r8,pc[2316]
80004280:	90 09       	ld.sh	r9,r8[0x0]
80004282:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80004286:	2f f9       	sub	r9,-1
80004288:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000428a:	fe fa 09 0a 	ld.w	r10,pc[2314]
8000428e:	74 0a       	ld.w	r10,r10[0x0]
80004290:	fe fb 08 ec 	ld.w	r11,pc[2284]
80004294:	76 0b       	ld.w	r11,r11[0x0]
80004296:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000429a:	2f f9       	sub	r9,-1
8000429c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000429e:	e2 16 0f 00 	andl	r6,0xf00,COH
800042a2:	e0 46 01 00 	cp.w	r6,256
800042a6:	c0 c0       	breq	800042be <phy_rx_func+0xca>
800042a8:	e0 8b 00 05 	brhi	800042b2 <phy_rx_func+0xbe>
800042ac:	58 06       	cp.w	r6,0
800042ae:	c0 80       	breq	800042be <phy_rx_func+0xca>
800042b0:	c0 c8       	rjmp	800042c8 <phy_rx_func+0xd4>
800042b2:	e0 46 02 00 	cp.w	r6,512
800042b6:	c0 40       	breq	800042be <phy_rx_func+0xca>
800042b8:	e0 46 03 00 	cp.w	r6,768
800042bc:	c0 61       	brne	800042c8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800042be:	30 29       	mov	r9,2
800042c0:	fe f8 08 c0 	ld.w	r8,pc[2240]
800042c4:	91 09       	st.w	r8[0x0],r9
800042c6:	ca 38       	rjmp	8000440c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800042c8:	fe f6 08 cc 	ld.w	r6,pc[2252]
800042cc:	6c 0c       	ld.w	r12,r6[0x0]
800042ce:	f0 1f 02 33 	mcall	80004b98 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;					
800042d2:	30 08       	mov	r8,0
800042d4:	8d 08       	st.w	r6[0x0],r8
800042d6:	c9 b8       	rjmp	8000440c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800042d8:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800042dc:	b1 86       	lsr	r6,0x10
800042de:	14 06       	add	r6,r10
800042e0:	fe f8 08 bc 	ld.w	r8,pc[2236]
800042e4:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800042e6:	fe f8 08 a2 	ld.w	r8,pc[2210]
800042ea:	90 09       	ld.sh	r9,r8[0x0]
800042ec:	fe fb 08 a8 	ld.w	r11,pc[2216]
800042f0:	76 0b       	ld.w	r11,r11[0x0]
800042f2:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800042f6:	2f f9       	sub	r9,-1
800042f8:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800042fa:	fe f9 08 8a 	ld.w	r9,pc[2186]
800042fe:	92 08       	ld.sh	r8,r9[0x0]
80004300:	20 28       	sub	r8,2
80004302:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80004304:	30 09       	mov	r9,0
80004306:	f2 08 19 00 	cp.h	r8,r9
8000430a:	e0 8a 00 07 	brle	80004318 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000430e:	30 19       	mov	r9,1
80004310:	fe f8 08 70 	ld.w	r8,pc[2160]
80004314:	91 09       	st.w	r8[0x0],r9
80004316:	c7 b8       	rjmp	8000440c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004318:	30 39       	mov	r9,3
8000431a:	fe f8 08 66 	ld.w	r8,pc[2150]
8000431e:	91 09       	st.w	r8[0x0],r9
80004320:	c7 68       	rjmp	8000440c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80004322:	ec 0a 14 10 	asr	r10,r6,0x10
80004326:	fe f8 08 76 	ld.w	r8,pc[2166]
8000432a:	90 09       	ld.sh	r9,r8[0x0]
8000432c:	14 09       	add	r9,r10
8000432e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004330:	fe f9 08 58 	ld.w	r9,pc[2136]
80004334:	92 08       	ld.sh	r8,r9[0x0]
80004336:	fe fb 08 5e 	ld.w	r11,pc[2142]
8000433a:	76 0b       	ld.w	r11,r11[0x0]
8000433c:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80004340:	2f f8       	sub	r8,-1
80004342:	5c 88       	casts.h	r8
80004344:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80004346:	fe fa 08 3e 	ld.w	r10,pc[2110]
8000434a:	94 09       	ld.sh	r9,r10[0x0]
8000434c:	20 29       	sub	r9,2
8000434e:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80004350:	30 0a       	mov	r10,0
80004352:	f4 09 19 00 	cp.h	r9,r10
80004356:	e0 89 00 1f 	brgt	80004394 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000435a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000435e:	e0 46 00 ba 	cp.w	r6,186
80004362:	c0 d1       	brne	8000437c <phy_rx_func+0x188>
80004364:	fe f8 08 38 	ld.w	r8,pc[2104]
80004368:	90 09       	ld.sh	r9,r8[0x0]
8000436a:	f4 09 19 00 	cp.h	r9,r10
8000436e:	c0 71       	brne	8000437c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004370:	fe f8 08 24 	ld.w	r8,pc[2084]
80004374:	70 0c       	ld.w	r12,r8[0x0]
80004376:	f0 1f 02 0b 	mcall	80004ba0 <phy_rx_func+0x9ac>
8000437a:	c0 88       	rjmp	8000438a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000437c:	fe f6 08 18 	ld.w	r6,pc[2072]
80004380:	6c 0c       	ld.w	r12,r6[0x0]
80004382:	f0 1f 02 06 	mcall	80004b98 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;
80004386:	30 08       	mov	r8,0
80004388:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000438a:	30 09       	mov	r9,0
8000438c:	fe f8 07 f4 	ld.w	r8,pc[2036]
80004390:	91 09       	st.w	r8[0x0],r9
80004392:	c3 d8       	rjmp	8000440c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004394:	5c 86       	casts.h	r6
80004396:	fe f9 08 06 	ld.w	r9,pc[2054]
8000439a:	92 0a       	ld.sh	r10,r9[0x0]
8000439c:	0c 0a       	add	r10,r6
8000439e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800043a0:	fe f9 07 f4 	ld.w	r9,pc[2036]
800043a4:	72 09       	ld.w	r9,r9[0x0]
800043a6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800043aa:	2f f8       	sub	r8,-1
800043ac:	fe f9 07 dc 	ld.w	r9,pc[2012]
800043b0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800043b2:	fe f9 07 d2 	ld.w	r9,pc[2002]
800043b6:	92 08       	ld.sh	r8,r9[0x0]
800043b8:	20 28       	sub	r8,2
800043ba:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800043bc:	30 09       	mov	r9,0
800043be:	f2 08 19 00 	cp.h	r8,r9
800043c2:	e0 89 00 25 	brgt	8000440c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800043c6:	30 39       	mov	r9,3
800043c8:	fe f8 07 b8 	ld.w	r8,pc[1976]
800043cc:	91 09       	st.w	r8[0x0],r9
800043ce:	c1 f8       	rjmp	8000440c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800043d0:	e6 16 00 ff 	andh	r6,0xff,COH
800043d4:	fc 19 00 ba 	movh	r9,0xba
800043d8:	12 36       	cp.w	r6,r9
800043da:	c0 e1       	brne	800043f6 <phy_rx_func+0x202>
800043dc:	fe f8 07 c0 	ld.w	r8,pc[1984]
800043e0:	90 09       	ld.sh	r9,r8[0x0]
800043e2:	30 08       	mov	r8,0
800043e4:	f0 09 19 00 	cp.h	r9,r8
800043e8:	c0 71       	brne	800043f6 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800043ea:	fe f8 07 aa 	ld.w	r8,pc[1962]
800043ee:	70 0c       	ld.w	r12,r8[0x0]
800043f0:	f0 1f 01 ec 	mcall	80004ba0 <phy_rx_func+0x9ac>
800043f4:	c0 88       	rjmp	80004404 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800043f6:	fe f6 07 9e 	ld.w	r6,pc[1950]
800043fa:	6c 0c       	ld.w	r12,r6[0x0]
800043fc:	f0 1f 01 e7 	mcall	80004b98 <phy_rx_func+0x9a4>
				phy_frame_ptr = NULL;
80004400:	30 08       	mov	r8,0
80004402:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80004404:	30 09       	mov	r9,0
80004406:	fe f8 07 7a 	ld.w	r8,pc[1914]
8000440a:	91 09       	st.w	r8[0x0],r9
	
	static U8 _flag = 1;//0xABCDC014_flag0
						//0xABCDC010_flag1
	
	
	if(is_first == FALSE)
8000440c:	fe f8 07 98 	ld.w	r8,pc[1944]
80004410:	11 89       	ld.ub	r9,r8[0x0]
80004412:	30 08       	mov	r8,0
80004414:	f0 09 18 00 	cp.b	r9,r8
80004418:	c0 d1       	brne	80004432 <phy_rx_func+0x23e>
	{
		payload_ptr = get_payload_idle_isr();
8000441a:	fe f8 07 8e 	ld.w	r8,pc[1934]
8000441e:	70 0c       	ld.w	r12,r8[0x0]
80004420:	f0 1f 01 dc 	mcall	80004b90 <phy_rx_func+0x99c>
80004424:	fe f8 07 88 	ld.w	r8,pc[1928]
80004428:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000442a:	30 19       	mov	r9,1
8000442c:	fe f8 07 78 	ld.w	r8,pc[1912]
80004430:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80004432:	fe f8 07 7e 	ld.w	r8,pc[1918]
80004436:	70 08       	ld.w	r8,r8[0x0]
80004438:	58 28       	cp.w	r8,2
8000443a:	e0 80 01 58 	breq	800046ea <phy_rx_func+0x4f6>
8000443e:	58 38       	cp.w	r8,3
80004440:	e0 80 02 16 	breq	8000486c <phy_rx_func+0x678>
80004444:	58 08       	cp.w	r8,0
80004446:	e0 81 03 96 	brne	80004b72 <phy_rx_func+0x97e>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000444a:	6e 28       	ld.w	r8,r7[0x8]
8000444c:	e0 6a 5a 5a 	mov	r10,23130
80004450:	ea 1a ab cd 	orh	r10,0xabcd
80004454:	14 38       	cp.w	r8,r10
80004456:	c0 71       	brne	80004464 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80004458:	30 09       	mov	r9,0
8000445a:	fe f8 07 5a 	ld.w	r8,pc[1882]
8000445e:	91 09       	st.w	r8[0x0],r9
80004460:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004464:	10 99       	mov	r9,r8
80004466:	e0 19 00 00 	andl	r9,0x0
8000446a:	fc 1a ab cd 	movh	r10,0xabcd
8000446e:	14 39       	cp.w	r9,r10
80004470:	e0 81 03 81 	brne	80004b72 <phy_rx_func+0x97e>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004474:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004478:	fe f9 07 40 	ld.w	r9,pc[1856]
8000447c:	93 08       	st.w	r9[0x0],r8
		
			if(NULL== payload_ptr)
8000447e:	fe f8 07 2e 	ld.w	r8,pc[1838]
80004482:	70 08       	ld.w	r8,r8[0x0]
80004484:	58 08       	cp.w	r8,0
80004486:	c0 c1       	brne	8000449e <phy_rx_func+0x2aa>
			{
				payload_ptr = get_payload_idle_isr();
80004488:	fe f8 07 20 	ld.w	r8,pc[1824]
8000448c:	70 0c       	ld.w	r12,r8[0x0]
8000448e:	f0 1f 01 c1 	mcall	80004b90 <phy_rx_func+0x99c>
80004492:	fe f8 07 1a 	ld.w	r8,pc[1818]
80004496:	91 0c       	st.w	r8[0x0],r12
				if(NULL== payload_ptr)
80004498:	58 0c       	cp.w	r12,0
8000449a:	e0 80 03 6c 	breq	80004b72 <phy_rx_func+0x97e>
				}
			}
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000449e:	6e 28       	ld.w	r8,r7[0x8]
800044a0:	e2 18 f0 00 	andl	r8,0xf000,COH
800044a4:	e0 48 c0 00 	cp.w	r8,49152
800044a8:	e0 81 00 8e 	brne	800045c4 <phy_rx_func+0x3d0>
			{
				AMBE_flag = 1;
800044ac:	30 19       	mov	r9,1
800044ae:	fe f8 07 0e 	ld.w	r8,pc[1806]
800044b2:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
800044b4:	ef 39 00 0d 	ld.ub	r9,r7[13]
800044b8:	fe f8 07 08 	ld.w	r8,pc[1800]
800044bc:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loopback Radio, as a reference.
800044be:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800044c2:	fe f9 07 02 	ld.w	r9,pc[1794]
800044c6:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
800044c8:	11 89       	ld.ub	r9,r8[0x0]
800044ca:	3f 08       	mov	r8,-16
800044cc:	f0 09 18 00 	cp.b	r9,r8
800044d0:	c2 b1       	brne	80004526 <phy_rx_func+0x332>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800044d2:	ef 38 00 0e 	ld.ub	r8,r7[14]
800044d6:	e2 18 00 f0 	andl	r8,0xf0,COH
800044da:	59 08       	cp.w	r8,16
800044dc:	c0 71       	brne	800044ea <phy_rx_func+0x2f6>
					{
						m_RxBurstType = VOICEHEADER;		
800044de:	30 19       	mov	r9,1
800044e0:	fe f8 06 d4 	ld.w	r8,pc[1748]
800044e4:	91 09       	st.w	r8[0x0],r9
800044e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800044ea:	e0 48 00 20 	cp.w	r8,32
800044ee:	c1 61       	brne	8000451a <phy_rx_func+0x326>
					{
						m_RxBurstType = VOICETERMINATOR;
800044f0:	30 99       	mov	r9,9
800044f2:	fe f8 06 c2 	ld.w	r8,pc[1730]
800044f6:	91 09       	st.w	r8[0x0],r9
						//In order to complete the save data AMBE stream to SDcard.
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						RxMedia_IsFillingNext16 = 0;
800044f8:	30 09       	mov	r9,0
800044fa:	fe f8 06 ce 	ld.w	r8,pc[1742]
800044fe:	91 09       	st.w	r8[0x0],r9
						payload_rx(payload_ptr);//0
80004500:	fe f7 06 ac 	ld.w	r7,pc[1708]
80004504:	6e 0c       	ld.w	r12,r7[0x0]
80004506:	f0 1f 01 b2 	mcall	80004bcc <phy_rx_func+0x9d8>
						payload_ptr = get_payload_idle_isr();
8000450a:	fe f8 06 9e 	ld.w	r8,pc[1694]
8000450e:	70 0c       	ld.w	r12,r8[0x0]
80004510:	f0 1f 01 a0 	mcall	80004b90 <phy_rx_func+0x99c>
80004514:	8f 0c       	st.w	r7[0x0],r12
80004516:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
8000451a:	30 09       	mov	r9,0
8000451c:	fe f8 06 98 	ld.w	r8,pc[1688]
80004520:	91 09       	st.w	r8[0x0],r9
80004522:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
80004526:	fe f8 06 9a 	ld.w	r8,pc[1690]
8000452a:	11 89       	ld.ub	r9,r8[0x0]
8000452c:	31 28       	mov	r8,18
8000452e:	f0 09 18 00 	cp.b	r9,r8
80004532:	c0 d1       	brne	8000454c <phy_rx_func+0x358>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
80004534:	8e 69       	ld.sh	r9,r7[0xc]
80004536:	fe f8 06 9a 	ld.w	r8,pc[1690]
8000453a:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
8000453c:	8e 79       	ld.sh	r9,r7[0xe]
8000453e:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
80004540:	f0 1f 01 a5 	mcall	80004bd4 <phy_rx_func+0x9e0>
80004544:	fe f8 06 70 	ld.w	r8,pc[1648]
80004548:	91 0c       	st.w	r8[0x0],r12
8000454a:	c3 78       	rjmp	800045b8 <phy_rx_func+0x3c4>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
8000454c:	fe f8 06 74 	ld.w	r8,pc[1652]
80004550:	11 89       	ld.ub	r9,r8[0x0]
80004552:	30 48       	mov	r8,4
80004554:	f0 09 18 00 	cp.b	r9,r8
80004558:	c0 80       	breq	80004568 <phy_rx_func+0x374>
8000455a:	fe f8 06 66 	ld.w	r8,pc[1638]
8000455e:	11 89       	ld.ub	r9,r8[0x0]
80004560:	30 38       	mov	r8,3
80004562:	f0 09 18 00 	cp.b	r9,r8
80004566:	c1 c1       	brne	8000459e <phy_rx_func+0x3aa>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
80004568:	30 29       	mov	r9,2
8000456a:	fe f8 06 4a 	ld.w	r8,pc[1610]
8000456e:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
80004570:	6e 29       	ld.w	r9,r7[0x8]
80004572:	fe f8 06 66 	ld.w	r8,pc[1638]
80004576:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
80004578:	6e 39       	ld.w	r9,r7[0xc]
8000457a:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
8000457c:	fe f8 06 3c 	ld.w	r8,pc[1596]
80004580:	70 08       	ld.w	r8,r8[0x0]
80004582:	59 48       	cp.w	r8,20
80004584:	c0 61       	brne	80004590 <phy_rx_func+0x39c>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
80004586:	31 89       	mov	r9,24
80004588:	fe f8 06 30 	ld.w	r8,pc[1584]
8000458c:	91 09       	st.w	r8[0x0],r9
8000458e:	c1 58       	rjmp	800045b8 <phy_rx_func+0x3c4>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
80004590:	59 08       	cp.w	r8,16
80004592:	c1 31       	brne	800045b8 <phy_rx_func+0x3c4>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
80004594:	31 09       	mov	r9,16
80004596:	fe f8 06 22 	ld.w	r8,pc[1570]
8000459a:	91 09       	st.w	r8[0x0],r9
8000459c:	c0 e8       	rjmp	800045b8 <phy_rx_func+0x3c4>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
8000459e:	8e e8       	ld.uh	r8,r7[0xc]
800045a0:	1a d8       	st.w	--sp,r8
800045a2:	fe fc 06 3a 	ld.w	r12,pc[1594]
800045a6:	f0 1f 01 8f 	mcall	80004be0 <phy_rx_func+0x9ec>
					logFromISR("\n\r Axiba \n\r");
800045aa:	fe fc 06 3a 	ld.w	r12,pc[1594]
800045ae:	f0 1f 01 8d 	mcall	80004be0 <phy_rx_func+0x9ec>
800045b2:	2f fd       	sub	sp,-4
800045b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
800045b8:	30 39       	mov	r9,3
800045ba:	fe f8 05 f6 	ld.w	r8,pc[1526]
800045be:	91 09       	st.w	r8[0x0],r9
800045c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800045c4:	e0 48 10 00 	cp.w	r8,4096
800045c8:	5f 19       	srne	r9
800045ca:	e0 48 20 00 	cp.w	r8,8192
800045ce:	5f 18       	srne	r8
800045d0:	f3 e8 00 08 	and	r8,r9,r8
800045d4:	e0 81 02 cf 	brne	80004b72 <phy_rx_func+0x97e>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
800045d8:	fe f9 05 e4 	ld.w	r9,pc[1508]
800045dc:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800045de:	fe f9 05 e2 	ld.w	r9,pc[1506]
800045e2:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800045e4:	6e 28       	ld.w	r8,r7[0x8]
800045e6:	e2 18 0f 00 	andl	r8,0xf00,COH
800045ea:	58 18       	cp.w	r8,1
800045ec:	e0 8b 00 4d 	brhi	80004686 <phy_rx_func+0x492>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Frag type must process Array Discriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800045f0:	fe f9 05 c8 	ld.w	r9,pc[1480]
800045f4:	72 08       	ld.w	r8,r9[0x0]
800045f6:	20 48       	sub	r8,4
800045f8:	93 08       	st.w	r9[0x0],r8
800045fa:	e0 80 02 bc 	breq	80004b72 <phy_rx_func+0x97e>
				ArrayDiscLength = payload_rx_channel->word[2];
800045fe:	8e 68       	ld.sh	r8,r7[0xc]
80004600:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004604:	fe f9 05 e4 	ld.w	r9,pc[1508]
80004608:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
8000460a:	30 09       	mov	r9,0
8000460c:	f2 08 19 00 	cp.h	r8,r9
80004610:	c0 70       	breq	8000461e <phy_rx_func+0x42a>
80004612:	30 19       	mov	r9,1
80004614:	f2 08 19 00 	cp.h	r8,r9
80004618:	e0 81 02 ad 	brne	80004b72 <phy_rx_func+0x97e>
8000461c:	c2 68       	rjmp	80004668 <phy_rx_func+0x474>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000461e:	fe f8 05 aa 	ld.w	r8,pc[1450]
80004622:	70 0a       	ld.w	r10,r8[0x0]
80004624:	fe f9 05 88 	ld.w	r9,pc[1416]
80004628:	72 09       	ld.w	r9,r9[0x0]
8000462a:	8e 7b       	ld.sh	r11,r7[0xe]
8000462c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004630:	70 09       	ld.w	r9,r8[0x0]
80004632:	2f f9       	sub	r9,-1
80004634:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004636:	e0 49 00 ff 	cp.w	r9,255
8000463a:	e0 88 00 11 	brls	8000465c <phy_rx_func+0x468>
						{
							RxMedia_IsFillingNext16 = 0;	
8000463e:	30 09       	mov	r9,0
80004640:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80004642:	fe f7 05 6a 	ld.w	r7,pc[1386]
80004646:	6e 0c       	ld.w	r12,r7[0x0]
80004648:	f0 1f 01 61 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
8000464c:	fe f8 05 5c 	ld.w	r8,pc[1372]
80004650:	70 0c       	ld.w	r12,r8[0x0]
80004652:	f0 1f 01 50 	mcall	80004b90 <phy_rx_func+0x99c>
80004656:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004658:	e0 80 02 8d 	breq	80004b72 <phy_rx_func+0x97e>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000465c:	30 29       	mov	r9,2
8000465e:	fe f8 05 52 	ld.w	r8,pc[1362]
80004662:	91 09       	st.w	r8[0x0],r9
80004664:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004668:	8e 79       	ld.sh	r9,r7[0xe]
8000466a:	30 38       	mov	r8,3
8000466c:	f0 09 19 00 	cp.h	r9,r8
80004670:	c0 51       	brne	8000467a <phy_rx_func+0x486>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80004672:	30 19       	mov	r9,1
80004674:	fe f8 05 78 	ld.w	r8,pc[1400]
80004678:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000467a:	30 29       	mov	r9,2
8000467c:	fe f8 05 34 	ld.w	r8,pc[1332]
80004680:	91 09       	st.w	r8[0x0],r9
80004682:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80004686:	fe f8 05 32 	ld.w	r8,pc[1330]
8000468a:	70 08       	ld.w	r8,r8[0x0]
8000468c:	58 18       	cp.w	r8,1
8000468e:	e0 88 02 72 	brls	80004b72 <phy_rx_func+0x97e>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80004692:	fe f8 05 36 	ld.w	r8,pc[1334]
80004696:	70 0a       	ld.w	r10,r8[0x0]
80004698:	fe f9 05 14 	ld.w	r9,pc[1300]
8000469c:	72 09       	ld.w	r9,r9[0x0]
8000469e:	6e 3b       	ld.w	r11,r7[0xc]
800046a0:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800046a4:	70 09       	ld.w	r9,r8[0x0]
800046a6:	2f f9       	sub	r9,-1
800046a8:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800046aa:	e0 49 00 ff 	cp.w	r9,255
800046ae:	e0 88 00 11 	brls	800046d0 <phy_rx_func+0x4dc>
				{
					RxMedia_IsFillingNext16 = 0;
800046b2:	30 09       	mov	r9,0
800046b4:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800046b6:	fe f7 04 f6 	ld.w	r7,pc[1270]
800046ba:	6e 0c       	ld.w	r12,r7[0x0]
800046bc:	f0 1f 01 44 	mcall	80004bcc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800046c0:	fe f8 04 e8 	ld.w	r8,pc[1256]
800046c4:	70 0c       	ld.w	r12,r8[0x0]
800046c6:	f0 1f 01 33 	mcall	80004b90 <phy_rx_func+0x99c>
800046ca:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800046cc:	e0 80 02 53 	breq	80004b72 <phy_rx_func+0x97e>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800046d0:	fe f9 04 e8 	ld.w	r9,pc[1256]
800046d4:	72 08       	ld.w	r8,r9[0x0]
800046d6:	20 28       	sub	r8,2
800046d8:	93 08       	st.w	r9[0x0],r8
800046da:	e0 80 02 4c 	breq	80004b72 <phy_rx_func+0x97e>
				RxMediaState = READINGMEDIA;
800046de:	30 29       	mov	r9,2
800046e0:	fe f8 04 d0 	ld.w	r8,pc[1232]
800046e4:	91 09       	st.w	r8[0x0],r9
800046e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800046ea:	fe f8 04 de 	ld.w	r8,pc[1246]
800046ee:	70 0a       	ld.w	r10,r8[0x0]
800046f0:	fe f9 04 bc 	ld.w	r9,pc[1212]
800046f4:	72 09       	ld.w	r9,r9[0x0]
800046f6:	8e 4b       	ld.sh	r11,r7[0x8]
800046f8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800046fc:	70 09       	ld.w	r9,r8[0x0]
800046fe:	2f f9       	sub	r9,-1
80004700:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004702:	e0 49 00 ff 	cp.w	r9,255
80004706:	e0 88 00 16 	brls	80004732 <phy_rx_func+0x53e>
					{
							RxMedia_IsFillingNext16 = 0;
8000470a:	30 09       	mov	r9,0
8000470c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000470e:	fe f6 04 9e 	ld.w	r6,pc[1182]
80004712:	6c 0c       	ld.w	r12,r6[0x0]
80004714:	f0 1f 01 2e 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004718:	fe f8 04 90 	ld.w	r8,pc[1168]
8000471c:	70 0c       	ld.w	r12,r8[0x0]
8000471e:	f0 1f 01 1d 	mcall	80004b90 <phy_rx_func+0x99c>
80004722:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80004724:	c0 71       	brne	80004732 <phy_rx_func+0x53e>
							{
								RxMediaState = WAITINGABAB;
80004726:	30 09       	mov	r9,0
80004728:	fe f8 04 88 	ld.w	r8,pc[1160]
8000472c:	91 09       	st.w	r8[0x0],r9
8000472e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80004732:	fe f9 04 86 	ld.w	r9,pc[1158]
80004736:	72 08       	ld.w	r8,r9[0x0]
80004738:	20 28       	sub	r8,2
8000473a:	93 08       	st.w	r9[0x0],r8
8000473c:	c0 71       	brne	8000474a <phy_rx_func+0x556>
				{
					RxMediaState = WAITINGABAB;
8000473e:	30 09       	mov	r9,0
80004740:	fe f8 04 70 	ld.w	r8,pc[1136]
80004744:	91 09       	st.w	r8[0x0],r9
80004746:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000474a:	fe f8 04 7e 	ld.w	r8,pc[1150]
8000474e:	70 0a       	ld.w	r10,r8[0x0]
80004750:	fe f9 04 5c 	ld.w	r9,pc[1116]
80004754:	72 09       	ld.w	r9,r9[0x0]
80004756:	8e 5b       	ld.sh	r11,r7[0xa]
80004758:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000475c:	70 09       	ld.w	r9,r8[0x0]
8000475e:	2f f9       	sub	r9,-1
80004760:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004762:	e0 49 00 ff 	cp.w	r9,255
80004766:	e0 88 00 16 	brls	80004792 <phy_rx_func+0x59e>
						{
							RxMedia_IsFillingNext16 = 0;
8000476a:	30 09       	mov	r9,0
8000476c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000476e:	fe f6 04 3e 	ld.w	r6,pc[1086]
80004772:	6c 0c       	ld.w	r12,r6[0x0]
80004774:	f0 1f 01 16 	mcall	80004bcc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80004778:	fe f8 04 30 	ld.w	r8,pc[1072]
8000477c:	70 0c       	ld.w	r12,r8[0x0]
8000477e:	f0 1f 01 05 	mcall	80004b90 <phy_rx_func+0x99c>
80004782:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004784:	c0 71       	brne	80004792 <phy_rx_func+0x59e>
								{
									RxMediaState = WAITINGABAB;
80004786:	30 09       	mov	r9,0
80004788:	fe f8 04 28 	ld.w	r8,pc[1064]
8000478c:	91 09       	st.w	r8[0x0],r9
8000478e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004792:	fe f9 04 26 	ld.w	r9,pc[1062]
80004796:	72 08       	ld.w	r8,r9[0x0]
80004798:	20 28       	sub	r8,2
8000479a:	93 08       	st.w	r9[0x0],r8
8000479c:	c0 71       	brne	800047aa <phy_rx_func+0x5b6>
					RxMediaState = WAITINGABAB;
8000479e:	30 09       	mov	r9,0
800047a0:	fe f8 04 10 	ld.w	r8,pc[1040]
800047a4:	91 09       	st.w	r8[0x0],r9
800047a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800047aa:	fe f8 04 1e 	ld.w	r8,pc[1054]
800047ae:	70 0a       	ld.w	r10,r8[0x0]
800047b0:	fe f9 03 fc 	ld.w	r9,pc[1020]
800047b4:	72 09       	ld.w	r9,r9[0x0]
800047b6:	8e 6b       	ld.sh	r11,r7[0xc]
800047b8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800047bc:	70 09       	ld.w	r9,r8[0x0]
800047be:	2f f9       	sub	r9,-1
800047c0:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800047c2:	e0 49 00 ff 	cp.w	r9,255
800047c6:	e0 88 00 16 	brls	800047f2 <phy_rx_func+0x5fe>
						{
							RxMedia_IsFillingNext16 = 0;
800047ca:	30 09       	mov	r9,0
800047cc:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800047ce:	fe f6 03 de 	ld.w	r6,pc[990]
800047d2:	6c 0c       	ld.w	r12,r6[0x0]
800047d4:	f0 1f 00 fe 	mcall	80004bcc <phy_rx_func+0x9d8>
									payload_ptr = get_payload_idle_isr();
800047d8:	fe f8 03 d0 	ld.w	r8,pc[976]
800047dc:	70 0c       	ld.w	r12,r8[0x0]
800047de:	f0 1f 00 ed 	mcall	80004b90 <phy_rx_func+0x99c>
800047e2:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
800047e4:	c0 71       	brne	800047f2 <phy_rx_func+0x5fe>
									{
										RxMediaState = WAITINGABAB;
800047e6:	30 09       	mov	r9,0
800047e8:	fe f8 03 c8 	ld.w	r8,pc[968]
800047ec:	91 09       	st.w	r8[0x0],r9
800047ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800047f2:	fe f9 03 c6 	ld.w	r9,pc[966]
800047f6:	72 08       	ld.w	r8,r9[0x0]
800047f8:	20 28       	sub	r8,2
800047fa:	93 08       	st.w	r9[0x0],r8
800047fc:	c0 71       	brne	8000480a <phy_rx_func+0x616>
					RxMediaState = WAITINGABAB;
800047fe:	30 09       	mov	r9,0
80004800:	fe f8 03 b0 	ld.w	r8,pc[944]
80004804:	91 09       	st.w	r8[0x0],r9
80004806:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000480a:	fe f8 03 be 	ld.w	r8,pc[958]
8000480e:	70 0a       	ld.w	r10,r8[0x0]
80004810:	fe f9 03 9c 	ld.w	r9,pc[924]
80004814:	72 09       	ld.w	r9,r9[0x0]
80004816:	8e 7b       	ld.sh	r11,r7[0xe]
80004818:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000481c:	70 09       	ld.w	r9,r8[0x0]
8000481e:	2f f9       	sub	r9,-1
80004820:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004822:	e0 49 00 ff 	cp.w	r9,255
80004826:	e0 88 00 16 	brls	80004852 <phy_rx_func+0x65e>
						{
							RxMedia_IsFillingNext16 = 0;
8000482a:	30 09       	mov	r9,0
8000482c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000482e:	fe f7 03 7e 	ld.w	r7,pc[894]
80004832:	6e 0c       	ld.w	r12,r7[0x0]
80004834:	f0 1f 00 e6 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004838:	fe f8 03 70 	ld.w	r8,pc[880]
8000483c:	70 0c       	ld.w	r12,r8[0x0]
8000483e:	f0 1f 00 d5 	mcall	80004b90 <phy_rx_func+0x99c>
80004842:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004844:	c0 71       	brne	80004852 <phy_rx_func+0x65e>
							{
								RxMediaState = WAITINGABAB;
80004846:	30 09       	mov	r9,0
80004848:	fe f8 03 68 	ld.w	r8,pc[872]
8000484c:	91 09       	st.w	r8[0x0],r9
8000484e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004852:	fe f9 03 66 	ld.w	r9,pc[870]
80004856:	72 08       	ld.w	r8,r9[0x0]
80004858:	20 28       	sub	r8,2
8000485a:	93 08       	st.w	r9[0x0],r8
8000485c:	e0 81 01 8b 	brne	80004b72 <phy_rx_func+0x97e>
					RxMediaState = WAITINGABAB;
80004860:	30 09       	mov	r9,0
80004862:	fe f8 03 4e 	ld.w	r8,pc[846]
80004866:	91 09       	st.w	r8[0x0],r9
80004868:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000486c:	fe f8 03 54 	ld.w	r8,pc[852]
80004870:	11 89       	ld.ub	r9,r8[0x0]
80004872:	31 28       	mov	r8,18
80004874:	f0 09 18 00 	cp.b	r9,r8
80004878:	e0 81 00 b0 	brne	800049d8 <phy_rx_func+0x7e4>
					{
						Item_ID = payload_rx_channel->byte[1];
8000487c:	ef 39 00 09 	ld.ub	r9,r7[9]
80004880:	fe f8 03 40 	ld.w	r8,pc[832]
80004884:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80004886:	11 89       	ld.ub	r9,r8[0x0]
80004888:	3f 28       	mov	r8,-14
8000488a:	f0 09 18 00 	cp.b	r9,r8
8000488e:	e0 81 00 a0 	brne	800049ce <phy_rx_func+0x7da>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004892:	6e 29       	ld.w	r9,r7[0x8]
80004894:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004898:	fe f8 03 20 	ld.w	r8,pc[800]
8000489c:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000489e:	8e 59       	ld.sh	r9,r7[0xa]
800048a0:	fe f8 03 50 	ld.w	r8,pc[848]
800048a4:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800048a6:	8e 69       	ld.sh	r9,r7[0xc]
800048a8:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800048aa:	8e 79       	ld.sh	r9,r7[0xe]
800048ac:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800048ae:	fe f8 03 1a 	ld.w	r8,pc[794]
800048b2:	70 0a       	ld.w	r10,r8[0x0]
800048b4:	fe f9 02 f8 	ld.w	r9,pc[760]
800048b8:	72 09       	ld.w	r9,r9[0x0]
800048ba:	8e 5b       	ld.sh	r11,r7[0xa]
800048bc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800048c0:	70 09       	ld.w	r9,r8[0x0]
800048c2:	2f f9       	sub	r9,-1
800048c4:	91 09       	st.w	r8[0x0],r9
							
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800048c6:	e0 49 00 ff 	cp.w	r9,255
800048ca:	e0 88 00 16 	brls	800048f6 <phy_rx_func+0x702>
							{
								RxMedia_IsFillingNext16 = 0;
800048ce:	30 09       	mov	r9,0
800048d0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800048d2:	fe f6 02 da 	ld.w	r6,pc[730]
800048d6:	6c 0c       	ld.w	r12,r6[0x0]
800048d8:	f0 1f 00 bd 	mcall	80004bcc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800048dc:	fe f8 02 cc 	ld.w	r8,pc[716]
800048e0:	70 0c       	ld.w	r12,r8[0x0]
800048e2:	f0 1f 00 ac 	mcall	80004b90 <phy_rx_func+0x99c>
800048e6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800048e8:	c0 71       	brne	800048f6 <phy_rx_func+0x702>
								{
									RxMediaState = WAITINGABAB;
800048ea:	30 09       	mov	r9,0
800048ec:	fe f8 02 c4 	ld.w	r8,pc[708]
800048f0:	91 09       	st.w	r8[0x0],r9
800048f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
800048f6:	fe f9 02 c2 	ld.w	r9,pc[706]
800048fa:	72 08       	ld.w	r8,r9[0x0]
800048fc:	20 28       	sub	r8,2
800048fe:	93 08       	st.w	r9[0x0],r8
80004900:	c0 71       	brne	8000490e <phy_rx_func+0x71a>
								RxMediaState = WAITINGABAB;
80004902:	30 09       	mov	r9,0
80004904:	fe f8 02 ac 	ld.w	r8,pc[684]
80004908:	91 09       	st.w	r8[0x0],r9
8000490a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000490e:	fe f8 02 ba 	ld.w	r8,pc[698]
80004912:	70 0a       	ld.w	r10,r8[0x0]
80004914:	fe f9 02 98 	ld.w	r9,pc[664]
80004918:	72 09       	ld.w	r9,r9[0x0]
8000491a:	8e 6b       	ld.sh	r11,r7[0xc]
8000491c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80004920:	70 09       	ld.w	r9,r8[0x0]
80004922:	2f f9       	sub	r9,-1
80004924:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004926:	e0 49 00 ff 	cp.w	r9,255
8000492a:	e0 88 00 16 	brls	80004956 <phy_rx_func+0x762>
							{
								RxMedia_IsFillingNext16 = 0;
8000492e:	30 09       	mov	r9,0
80004930:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004932:	fe f6 02 7a 	ld.w	r6,pc[634]
80004936:	6c 0c       	ld.w	r12,r6[0x0]
80004938:	f0 1f 00 a5 	mcall	80004bcc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
8000493c:	fe f8 02 6c 	ld.w	r8,pc[620]
80004940:	70 0c       	ld.w	r12,r8[0x0]
80004942:	f0 1f 00 94 	mcall	80004b90 <phy_rx_func+0x99c>
80004946:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004948:	c0 71       	brne	80004956 <phy_rx_func+0x762>
								{
									RxMediaState = WAITINGABAB;
8000494a:	30 09       	mov	r9,0
8000494c:	fe f8 02 64 	ld.w	r8,pc[612]
80004950:	91 09       	st.w	r8[0x0],r9
80004952:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80004956:	fe f9 02 62 	ld.w	r9,pc[610]
8000495a:	72 08       	ld.w	r8,r9[0x0]
8000495c:	20 28       	sub	r8,2
8000495e:	93 08       	st.w	r9[0x0],r8
80004960:	c0 71       	brne	8000496e <phy_rx_func+0x77a>
								RxMediaState = WAITINGABAB;
80004962:	30 09       	mov	r9,0
80004964:	fe f8 02 4c 	ld.w	r8,pc[588]
80004968:	91 09       	st.w	r8[0x0],r9
8000496a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000496e:	fe f8 02 5a 	ld.w	r8,pc[602]
80004972:	70 0a       	ld.w	r10,r8[0x0]
80004974:	fe f9 02 38 	ld.w	r9,pc[568]
80004978:	72 09       	ld.w	r9,r9[0x0]
8000497a:	8e 7b       	ld.sh	r11,r7[0xe]
8000497c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80004980:	70 09       	ld.w	r9,r8[0x0]
80004982:	2f f9       	sub	r9,-1
80004984:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004986:	e0 49 00 ff 	cp.w	r9,255
8000498a:	e0 88 00 16 	brls	800049b6 <phy_rx_func+0x7c2>
							{
								RxMedia_IsFillingNext16 = 0;
8000498e:	30 09       	mov	r9,0
80004990:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004992:	fe f7 02 1a 	ld.w	r7,pc[538]
80004996:	6e 0c       	ld.w	r12,r7[0x0]
80004998:	f0 1f 00 8d 	mcall	80004bcc <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
8000499c:	fe f8 02 0c 	ld.w	r8,pc[524]
800049a0:	70 0c       	ld.w	r12,r8[0x0]
800049a2:	f0 1f 00 7c 	mcall	80004b90 <phy_rx_func+0x99c>
800049a6:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr)
800049a8:	c0 71       	brne	800049b6 <phy_rx_func+0x7c2>
								{
									RxMediaState = WAITINGABAB;
800049aa:	30 09       	mov	r9,0
800049ac:	fe f8 02 04 	ld.w	r8,pc[516]
800049b0:	91 09       	st.w	r8[0x0],r9
800049b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
800049b6:	fe f9 02 02 	ld.w	r9,pc[514]
800049ba:	72 08       	ld.w	r8,r9[0x0]
800049bc:	20 28       	sub	r8,2
800049be:	93 08       	st.w	r9[0x0],r8
800049c0:	e0 81 00 d9 	brne	80004b72 <phy_rx_func+0x97e>
								RxMediaState = WAITINGABAB;
800049c4:	30 09       	mov	r9,0
800049c6:	4f b8       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
800049c8:	91 09       	st.w	r8[0x0],r9
800049ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800049ce:	30 09       	mov	r9,0
800049d0:	4f 88       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
800049d2:	91 09       	st.w	r8[0x0],r9
800049d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800049d8:	4f a8       	lddpc	r8,80004bc0 <phy_rx_func+0x9cc>
800049da:	11 89       	ld.ub	r9,r8[0x0]
800049dc:	3f 28       	mov	r8,-14
800049de:	f0 09 18 00 	cp.b	r9,r8
800049e2:	e0 81 00 aa 	brne	80004b36 <phy_rx_func+0x942>
					{
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800049e6:	8e 49       	ld.sh	r9,r7[0x8]
800049e8:	fe f8 02 08 	ld.w	r8,pc[520]
800049ec:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800049ee:	4f 78       	lddpc	r8,80004bc8 <phy_rx_func+0x9d4>
800049f0:	70 0a       	ld.w	r10,r8[0x0]
800049f2:	4e f9       	lddpc	r9,80004bac <phy_rx_func+0x9b8>
800049f4:	72 09       	ld.w	r9,r9[0x0]
800049f6:	8e 4b       	ld.sh	r11,r7[0x8]
800049f8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800049fc:	70 09       	ld.w	r9,r8[0x0]
800049fe:	2f f9       	sub	r9,-1
80004a00:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a02:	e0 49 00 ff 	cp.w	r9,255
80004a06:	e0 88 00 13 	brls	80004a2c <phy_rx_func+0x838>
						{
							RxMedia_IsFillingNext16 = 0;
80004a0a:	30 09       	mov	r9,0
80004a0c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a0e:	4e 86       	lddpc	r6,80004bac <phy_rx_func+0x9b8>
80004a10:	6c 0c       	ld.w	r12,r6[0x0]
80004a12:	f0 1f 00 6f 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004a16:	4e 58       	lddpc	r8,80004ba8 <phy_rx_func+0x9b4>
80004a18:	70 0c       	ld.w	r12,r8[0x0]
80004a1a:	f0 1f 00 5e 	mcall	80004b90 <phy_rx_func+0x99c>
80004a1e:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80004a20:	c0 61       	brne	80004a2c <phy_rx_func+0x838>
								RxMediaState = WAITINGABAB;
80004a22:	30 09       	mov	r9,0
80004a24:	4e 38       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004a26:	91 09       	st.w	r8[0x0],r9
80004a28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				
						if ((RxBytesWaiting -= 2) <= 0)
80004a2c:	4e 39       	lddpc	r9,80004bb8 <phy_rx_func+0x9c4>
80004a2e:	72 08       	ld.w	r8,r9[0x0]
80004a30:	20 28       	sub	r8,2
80004a32:	93 08       	st.w	r9[0x0],r8
80004a34:	c0 61       	brne	80004a40 <phy_rx_func+0x84c>
						{
							RxMediaState = WAITINGABAB;
80004a36:	30 09       	mov	r9,0
80004a38:	4d e8       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004a3a:	91 09       	st.w	r8[0x0],r9
80004a3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						}
						
						/******************************
						*******************/
						//(49bits)This shouldn't happen, but must check.
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80004a40:	4e 28       	lddpc	r8,80004bc8 <phy_rx_func+0x9d4>
80004a42:	70 0a       	ld.w	r10,r8[0x0]
80004a44:	4d a9       	lddpc	r9,80004bac <phy_rx_func+0x9b8>
80004a46:	72 09       	ld.w	r9,r9[0x0]
80004a48:	8e 5b       	ld.sh	r11,r7[0xa]
80004a4a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004a4e:	70 09       	ld.w	r9,r8[0x0]
80004a50:	2f f9       	sub	r9,-1
80004a52:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a54:	e0 49 00 ff 	cp.w	r9,255
80004a58:	e0 88 00 13 	brls	80004a7e <phy_rx_func+0x88a>
						{
							RxMedia_IsFillingNext16 = 0;
80004a5c:	30 09       	mov	r9,0
80004a5e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a60:	4d 36       	lddpc	r6,80004bac <phy_rx_func+0x9b8>
80004a62:	6c 0c       	ld.w	r12,r6[0x0]
80004a64:	f0 1f 00 5a 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004a68:	4d 08       	lddpc	r8,80004ba8 <phy_rx_func+0x9b4>
80004a6a:	70 0c       	ld.w	r12,r8[0x0]
80004a6c:	f0 1f 00 49 	mcall	80004b90 <phy_rx_func+0x99c>
80004a70:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80004a72:	c0 61       	brne	80004a7e <phy_rx_func+0x88a>
								RxMediaState = WAITINGABAB;
80004a74:	30 09       	mov	r9,0
80004a76:	4c f8       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004a78:	91 09       	st.w	r8[0x0],r9
80004a7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80004a7e:	4c f9       	lddpc	r9,80004bb8 <phy_rx_func+0x9c4>
80004a80:	72 08       	ld.w	r8,r9[0x0]
80004a82:	20 28       	sub	r8,2
80004a84:	93 08       	st.w	r9[0x0],r8
80004a86:	c0 61       	brne	80004a92 <phy_rx_func+0x89e>
							RxMediaState = WAITINGABAB;
80004a88:	30 09       	mov	r9,0
80004a8a:	4c a8       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004a8c:	91 09       	st.w	r8[0x0],r9
80004a8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}

						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80004a92:	4c e8       	lddpc	r8,80004bc8 <phy_rx_func+0x9d4>
80004a94:	70 0a       	ld.w	r10,r8[0x0]
80004a96:	4c 69       	lddpc	r9,80004bac <phy_rx_func+0x9b8>
80004a98:	72 09       	ld.w	r9,r9[0x0]
80004a9a:	8e 6b       	ld.sh	r11,r7[0xc]
80004a9c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;							
80004aa0:	70 09       	ld.w	r9,r8[0x0]
80004aa2:	2f f9       	sub	r9,-1
80004aa4:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004aa6:	e0 49 00 ff 	cp.w	r9,255
80004aaa:	e0 88 00 13 	brls	80004ad0 <phy_rx_func+0x8dc>
						{
							RxMedia_IsFillingNext16 = 0;
80004aae:	30 09       	mov	r9,0
80004ab0:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004ab2:	4b f6       	lddpc	r6,80004bac <phy_rx_func+0x9b8>
80004ab4:	6c 0c       	ld.w	r12,r6[0x0]
80004ab6:	f0 1f 00 46 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004aba:	4b c8       	lddpc	r8,80004ba8 <phy_rx_func+0x9b4>
80004abc:	70 0c       	ld.w	r12,r8[0x0]
80004abe:	f0 1f 00 35 	mcall	80004b90 <phy_rx_func+0x99c>
80004ac2:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80004ac4:	c0 61       	brne	80004ad0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80004ac6:	30 09       	mov	r9,0
80004ac8:	4b a8       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004aca:	91 09       	st.w	r8[0x0],r9
80004acc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80004ad0:	4b a9       	lddpc	r9,80004bb8 <phy_rx_func+0x9c4>
80004ad2:	72 08       	ld.w	r8,r9[0x0]
80004ad4:	20 28       	sub	r8,2
80004ad6:	93 08       	st.w	r9[0x0],r8
80004ad8:	c0 61       	brne	80004ae4 <phy_rx_func+0x8f0>
							RxMediaState = WAITINGABAB;
80004ada:	30 09       	mov	r9,0
80004adc:	4b 58       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004ade:	91 09       	st.w	r8[0x0],r9
80004ae0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
							
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004ae4:	4b 98       	lddpc	r8,80004bc8 <phy_rx_func+0x9d4>
80004ae6:	70 0a       	ld.w	r10,r8[0x0]
80004ae8:	4b 19       	lddpc	r9,80004bac <phy_rx_func+0x9b8>
80004aea:	72 09       	ld.w	r9,r9[0x0]
80004aec:	8e 7b       	ld.sh	r11,r7[0xe]
80004aee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004af2:	70 09       	ld.w	r9,r8[0x0]
80004af4:	2f f9       	sub	r9,-1
80004af6:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004af8:	e0 49 00 ff 	cp.w	r9,255
80004afc:	e0 88 00 13 	brls	80004b22 <phy_rx_func+0x92e>
						{
							RxMedia_IsFillingNext16 = 0;
80004b00:	30 09       	mov	r9,0
80004b02:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004b04:	4a a7       	lddpc	r7,80004bac <phy_rx_func+0x9b8>
80004b06:	6e 0c       	ld.w	r12,r7[0x0]
80004b08:	f0 1f 00 31 	mcall	80004bcc <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004b0c:	4a 78       	lddpc	r8,80004ba8 <phy_rx_func+0x9b4>
80004b0e:	70 0c       	ld.w	r12,r8[0x0]
80004b10:	f0 1f 00 20 	mcall	80004b90 <phy_rx_func+0x99c>
80004b14:	8f 0c       	st.w	r7[0x0],r12
							
							if(NULL == payload_ptr){
80004b16:	c0 61       	brne	80004b22 <phy_rx_func+0x92e>
								RxMediaState = WAITINGABAB;
80004b18:	30 09       	mov	r9,0
80004b1a:	4a 68       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004b1c:	91 09       	st.w	r8[0x0],r9
80004b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
80004b22:	4a 69       	lddpc	r9,80004bb8 <phy_rx_func+0x9c4>
80004b24:	72 08       	ld.w	r8,r9[0x0]
80004b26:	20 28       	sub	r8,2
80004b28:	93 08       	st.w	r9[0x0],r8
80004b2a:	c2 41       	brne	80004b72 <phy_rx_func+0x97e>
							RxMediaState = WAITINGABAB;
80004b2c:	30 09       	mov	r9,0
80004b2e:	4a 18       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004b30:	91 09       	st.w	r8[0x0],r9
80004b32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004b36:	4a 38       	lddpc	r8,80004bc0 <phy_rx_func+0x9cc>
80004b38:	11 89       	ld.ub	r9,r8[0x0]
80004b3a:	30 48       	mov	r8,4
80004b3c:	f0 09 18 00 	cp.b	r9,r8
80004b40:	c0 70       	breq	80004b4e <phy_rx_func+0x95a>
80004b42:	4a 08       	lddpc	r8,80004bc0 <phy_rx_func+0x9cc>
80004b44:	11 89       	ld.ub	r9,r8[0x0]
80004b46:	30 38       	mov	r8,3
80004b48:	f0 09 18 00 	cp.b	r9,r8
80004b4c:	c1 01       	brne	80004b6c <phy_rx_func+0x978>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004b4e:	6e 29       	ld.w	r9,r7[0x8]
80004b50:	4a 28       	lddpc	r8,80004bd8 <phy_rx_func+0x9e4>
80004b52:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004b54:	6e 39       	ld.w	r9,r7[0xc]
80004b56:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004b58:	49 89       	lddpc	r9,80004bb8 <phy_rx_func+0x9c4>
80004b5a:	72 08       	ld.w	r8,r9[0x0]
80004b5c:	20 88       	sub	r8,8
80004b5e:	93 08       	st.w	r9[0x0],r8
80004b60:	c0 91       	brne	80004b72 <phy_rx_func+0x97e>
						{
					
							RxBytesWaiting = 0;
80004b62:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004b64:	49 39       	lddpc	r9,80004bb0 <phy_rx_func+0x9bc>
80004b66:	93 08       	st.w	r9[0x0],r8
80004b68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004b6c:	30 09       	mov	r9,0
80004b6e:	49 18       	lddpc	r8,80004bb0 <phy_rx_func+0x9bc>
80004b70:	91 09       	st.w	r8[0x0],r9
80004b72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b76:	00 00       	add	r0,r0
80004b78:	00 00       	add	r0,r0
80004b7a:	0f c4       	ld.ub	r4,r7[0x4]
80004b7c:	00 00       	add	r0,r0
80004b7e:	0f e0       	ld.ub	r0,r7[0x6]
80004b80:	00 00       	add	r0,r0
80004b82:	0f ac       	ld.ub	r12,r7[0x2]
80004b84:	00 00       	add	r0,r0
80004b86:	0f 94       	ld.ub	r4,r7[0x1]
80004b88:	00 00       	add	r0,r0
80004b8a:	0f 8e       	ld.ub	lr,r7[0x0]
80004b8c:	00 00       	add	r0,r0
80004b8e:	0f a8       	ld.ub	r8,r7[0x2]
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	3a cc       	mov	r12,-84
80004b94:	00 00       	add	r0,r0
80004b96:	0f e4       	ld.ub	r4,r7[0x6]
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	8a e8       	ld.uh	r8,r5[0xc]
80004b9c:	00 00       	add	r0,r0
80004b9e:	0f c0       	ld.ub	r0,r7[0x4]
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	3a 18       	mov	r8,-95
80004ba4:	00 00       	add	r0,r0
80004ba6:	0f 8d       	ld.ub	sp,r7[0x0]
80004ba8:	00 00       	add	r0,r0
80004baa:	0f 98       	ld.ub	r8,r7[0x1]
80004bac:	00 00       	add	r0,r0
80004bae:	0f b4       	ld.ub	r4,r7[0x3]
80004bb0:	00 00       	add	r0,r0
80004bb2:	0f d4       	ld.ub	r4,r7[0x5]
80004bb4:	00 00       	add	r0,r0
80004bb6:	0f 80       	ld.ub	r0,r7[0x0]
80004bb8:	00 00       	add	r0,r0
80004bba:	0f 7c       	ld.ub	r12,--r7
80004bbc:	00 00       	add	r0,r0
80004bbe:	0a 44       	or	r4,r5
80004bc0:	00 00       	add	r0,r0
80004bc2:	0f 8c       	ld.ub	r12,r7[0x0]
80004bc4:	00 00       	add	r0,r0
80004bc6:	0a 4c       	or	r12,r5
80004bc8:	00 00       	add	r0,r0
80004bca:	0f c8       	ld.ub	r8,r7[0x4]
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	41 94       	lddsp	r4,sp[0x64]
80004bd0:	00 00       	add	r0,r0
80004bd2:	13 c4       	ld.ub	r4,r9[0x4]
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	39 5c       	mov	r12,-107
80004bd8:	00 00       	add	r0,r0
80004bda:	0f a0       	ld.ub	r0,r7[0x2]
80004bdc:	80 01       	ld.sh	r1,r0[0x0]
80004bde:	88 5c       	ld.sh	r12,r4[0xa]
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	9b e0       	st.w	sp[0x38],r0
80004be4:	80 01       	ld.sh	r1,r0[0x0]
80004be6:	88 70       	ld.sh	r0,r4[0xe]
80004be8:	00 00       	add	r0,r0
80004bea:	0f d0       	ld.ub	r0,r7[0x5]
80004bec:	00 00       	add	r0,r0
80004bee:	0a 55       	eor	r5,r5
80004bf0:	00 00       	add	r0,r0
80004bf2:	12 cc       	st.b	r9++,r12

80004bf4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004bf4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004bf6:	49 88       	lddpc	r8,80004c54 <pdca_int_handler+0x60>
80004bf8:	11 89       	ld.ub	r9,r8[0x0]
80004bfa:	ec 19 00 01 	eorl	r9,0x1
80004bfe:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004c00:	11 89       	ld.ub	r9,r8[0x0]
80004c02:	a5 69       	lsl	r9,0x4
80004c04:	2f c9       	sub	r9,-4
80004c06:	49 5a       	lddpc	r10,80004c58 <pdca_int_handler+0x64>
80004c08:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004c0a:	fe 7a 00 40 	mov	r10,-65472
80004c0e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004c10:	30 39       	mov	r9,3
80004c12:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004c14:	11 8a       	ld.ub	r10,r8[0x0]
80004c16:	a5 6a       	lsl	r10,0x4
80004c18:	2f ca       	sub	r10,-4
80004c1a:	49 18       	lddpc	r8,80004c5c <pdca_int_handler+0x68>
80004c1c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004c1e:	fe 78 00 00 	mov	r8,-65536
80004c22:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004c24:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004c26:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004c28:	48 e8       	lddpc	r8,80004c60 <pdca_int_handler+0x6c>
80004c2a:	70 08       	ld.w	r8,r8[0x0]
80004c2c:	58 08       	cp.w	r8,0
80004c2e:	c0 70       	breq	80004c3c <pdca_int_handler+0x48>
80004c30:	48 99       	lddpc	r9,80004c54 <pdca_int_handler+0x60>
80004c32:	13 89       	ld.ub	r9,r9[0x0]
80004c34:	a5 69       	lsl	r9,0x4
80004c36:	48 ac       	lddpc	r12,80004c5c <pdca_int_handler+0x68>
80004c38:	12 0c       	add	r12,r9
80004c3a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004c3c:	48 a8       	lddpc	r8,80004c64 <pdca_int_handler+0x70>
80004c3e:	70 08       	ld.w	r8,r8[0x0]
80004c40:	58 08       	cp.w	r8,0
80004c42:	c0 70       	breq	80004c50 <pdca_int_handler+0x5c>
80004c44:	48 49       	lddpc	r9,80004c54 <pdca_int_handler+0x60>
80004c46:	13 89       	ld.ub	r9,r9[0x0]
80004c48:	a5 69       	lsl	r9,0x4
80004c4a:	48 4c       	lddpc	r12,80004c58 <pdca_int_handler+0x64>
80004c4c:	12 0c       	add	r12,r9
80004c4e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004c50:	d4 02       	popm	lr
80004c52:	d6 03       	rete
80004c54:	00 00       	add	r0,r0
80004c56:	45 cc       	lddsp	r12,sp[0x170]
80004c58:	00 00       	add	r0,r0
80004c5a:	45 f4       	lddsp	r4,sp[0x17c]
80004c5c:	00 00       	add	r0,r0
80004c5e:	45 d4       	lddsp	r4,sp[0x174]
80004c60:	00 00       	add	r0,r0
80004c62:	0f f0       	ld.ub	r0,r7[0x7]
80004c64:	00 00       	add	r0,r0
80004c66:	0f f4       	ld.ub	r4,r7[0x7]

80004c68 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004c68:	fe 78 10 00 	mov	r8,-61440
80004c6c:	e0 69 0d c0 	mov	r9,3520
80004c70:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004c74:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004c78:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004c7c:	fe 78 34 00 	mov	r8,-52224
80004c80:	e0 69 80 00 	mov	r9,32768
80004c84:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004c86:	30 09       	mov	r9,0
80004c88:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004c8a:	e0 69 04 21 	mov	r9,1057
80004c8e:	ea 19 3f 20 	orh	r9,0x3f20
80004c92:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004c94:	e0 69 02 9f 	mov	r9,671
80004c98:	ea 19 01 00 	orh	r9,0x100
80004c9c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004c9e:	e0 6a 04 02 	mov	r10,1026
80004ca2:	ea 1a 3f 20 	orh	r10,0x3f20
80004ca6:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004ca8:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004caa:	5e fc       	retal	r12

80004cac <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004cac:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004cae:	30 19       	mov	r9,1
80004cb0:	49 78       	lddpc	r8,80004d0c <local_start_PDC+0x60>
80004cb2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004cb4:	fe 78 00 00 	mov	r8,-65536
80004cb8:	30 7b       	mov	r11,7
80004cba:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004cbc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004cbe:	49 59       	lddpc	r9,80004d10 <local_start_PDC+0x64>
80004cc0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004cc4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004cc6:	30 3a       	mov	r10,3
80004cc8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004cca:	30 1c       	mov	r12,1
80004ccc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004cce:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004cd0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004cd2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004cd4:	30 2c       	mov	r12,2
80004cd6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004cd8:	48 f9       	lddpc	r9,80004d14 <local_start_PDC+0x68>
80004cda:	e0 68 5a 5a 	mov	r8,23130
80004cde:	ea 18 ab cd 	orh	r8,0xabcd
80004ce2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004ce4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004ce6:	30 0e       	mov	lr,0
80004ce8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004cea:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004cec:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004cee:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004cf0:	fe 78 00 40 	mov	r8,-65472
80004cf4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004cf6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004cf8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004cfc:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004cfe:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004d00:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004d02:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004d04:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004d06:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004d08:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004d0a:	d8 02       	popm	pc
80004d0c:	00 00       	add	r0,r0
80004d0e:	45 cc       	lddsp	r12,sp[0x170]
80004d10:	00 00       	add	r0,r0
80004d12:	45 d4       	lddsp	r4,sp[0x174]
80004d14:	00 00       	add	r0,r0
80004d16:	45 f4       	lddsp	r4,sp[0x17c]

80004d18 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004d18:	48 38       	lddpc	r8,80004d24 <register_rx_tx_func+0xc>
80004d1a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004d1c:	48 38       	lddpc	r8,80004d28 <register_rx_tx_func+0x10>
80004d1e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004d20:	5e fc       	retal	r12
80004d22:	00 00       	add	r0,r0
80004d24:	00 00       	add	r0,r0
80004d26:	0f f0       	ld.ub	r0,r7[0x7]
80004d28:	00 00       	add	r0,r0
80004d2a:	0f f4       	ld.ub	r4,r7[0x7]

80004d2c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004d2c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004d2e:	fe 78 10 00 	mov	r8,-61440
80004d32:	30 29       	mov	r9,2
80004d34:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004d38:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004d3c:	10 99       	mov	r9,r8
80004d3e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004d42:	e2 18 00 02 	andl	r8,0x2,COH
80004d46:	cf c0       	breq	80004d3e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004d48:	fe 79 10 00 	mov	r9,-61440
80004d4c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004d50:	e2 18 00 02 	andl	r8,0x2,COH
80004d54:	cf c1       	brne	80004d4c <ssc_init+0x20>
				
    INTC_register_interrupt (
80004d56:	30 3a       	mov	r10,3
80004d58:	36 0b       	mov	r11,96
80004d5a:	48 bc       	lddpc	r12,80004d84 <ssc_init+0x58>
80004d5c:	f0 1f 00 0b 	mcall	80004d88 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004d60:	f0 1f 00 0b 	mcall	80004d8c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004d64:	f0 1f 00 0b 	mcall	80004d90 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004d68:	fe 79 00 00 	mov	r9,-65536
80004d6c:	30 18       	mov	r8,1
80004d6e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004d70:	fe 7a 00 40 	mov	r10,-65472
80004d74:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004d76:	e0 6b 01 01 	mov	r11,257
80004d7a:	fe 7a 34 00 	mov	r10,-52224
80004d7e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004d80:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004d82:	d8 02       	popm	pc
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4b f4       	lddpc	r4,80004e80 <xcmp_audio_route_AMBE+0x3c>
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	59 74       	cp.w	r4,23
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4c 68       	lddpc	r8,80004ea4 <xcmp_enter_enhanced_OB_mode+0x14>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	4c ac       	lddpc	r12,80004eb8 <xcmp_DeviceInitializationStatus_request+0x4>

80004d94 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004d94:	48 28       	lddpc	r8,80004d9c <xcmp_register_app_list+0x8>
80004d96:	91 0c       	st.w	r8[0x0],r12
}
80004d98:	5e fc       	retal	r12
80004d9a:	00 00       	add	r0,r0
80004d9c:	00 00       	add	r0,r0
80004d9e:	46 14       	lddsp	r4,sp[0x184]

80004da0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004da0:	eb cd 40 80 	pushm	r7,lr
80004da4:	fa cd 01 00 	sub	sp,sp,256
80004da8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004daa:	16 98       	mov	r8,r11
80004dac:	2f 08       	sub	r8,-16
80004dae:	af a8       	sbr	r8,0xe
80004db0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004db2:	3f f8       	mov	r8,-1
80004db4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004db6:	30 b9       	mov	r9,11
80004db8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004dba:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004dbc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004dbe:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004dc0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004dc2:	f6 ca ff fe 	sub	r10,r11,-2
80004dc6:	18 9b       	mov	r11,r12
80004dc8:	fa cc ff f0 	sub	r12,sp,-16
80004dcc:	f0 1f 00 05 	mcall	80004de0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004dd0:	2f e7       	sub	r7,-2
80004dd2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004dd4:	1a 9c       	mov	r12,sp
80004dd6:	f0 1f 00 04 	mcall	80004de4 <xcmp_tx+0x44>
}
80004dda:	2c 0d       	sub	sp,-256
80004ddc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	a4 1a       	st.h	r2[0x2],r10
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	52 5c       	stdsp	sp[0x94],r12

80004de8 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80004de8:	d4 01       	pushm	lr
80004dea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004dee:	e0 68 04 21 	mov	r8,1057
80004df2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004df4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80004df8:	30 09       	mov	r9,0
80004dfa:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004dfc:	30 19       	mov	r9,1
80004dfe:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80004e00:	30 39       	mov	r9,3
80004e02:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004e04:	30 3b       	mov	r11,3
80004e06:	fa cc ff fe 	sub	r12,sp,-2
80004e0a:	f0 1f 00 03 	mcall	80004e14 <xcmp_exit_device_control_mode+0x2c>
}
80004e0e:	2c dd       	sub	sp,-204
80004e10:	d8 02       	popm	pc
80004e12:	00 00       	add	r0,r0
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	4d a0       	lddpc	r0,80004f7c <xcmp_init+0x1c>

80004e18 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80004e18:	d4 01       	pushm	lr
80004e1a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004e1e:	e0 68 04 21 	mov	r8,1057
80004e22:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004e24:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80004e28:	30 19       	mov	r9,1
80004e2a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004e2c:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80004e2e:	30 39       	mov	r9,3
80004e30:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004e32:	30 3b       	mov	r11,3
80004e34:	fa cc ff fe 	sub	r12,sp,-2
80004e38:	f0 1f 00 02 	mcall	80004e40 <xcmp_enter_device_control_mode+0x28>
}
80004e3c:	2c dd       	sub	sp,-204
80004e3e:	d8 02       	popm	pc
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	4d a0       	lddpc	r0,80004fa8 <xcmp_init+0x48>

80004e44 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
80004e44:	d4 01       	pushm	lr
80004e46:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004e4a:	e0 68 04 14 	mov	r8,1044
80004e4e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004e50:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004e54:	30 19       	mov	r9,1
80004e56:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004e58:	30 09       	mov	r9,0
80004e5a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004e5c:	30 49       	mov	r9,4
80004e5e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004e60:	30 fa       	mov	r10,15
80004e62:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004e64:	30 c9       	mov	r9,12
80004e66:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004e68:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80004e6a:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
80004e6c:	31 1a       	mov	r10,17
80004e6e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004e70:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80004e74:	31 3a       	mov	r10,19
80004e76:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004e7a:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004e7e:	30 bb       	mov	r11,11
80004e80:	fa cc ff fe 	sub	r12,sp,-2
80004e84:	f0 1f 00 02 	mcall	80004e8c <xcmp_audio_route_AMBE+0x48>
}
80004e88:	2c dd       	sub	sp,-204
80004e8a:	d8 02       	popm	pc
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	4d a0       	lddpc	r0,80004ff4 <xcmp_rx_process+0x40>

80004e90 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004e90:	d4 01       	pushm	lr
80004e92:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80004e96:	e0 68 04 65 	mov	r8,1125
80004e9a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004e9c:	fa cc ff fe 	sub	r12,sp,-2
80004ea0:	30 18       	mov	r8,1
80004ea2:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80004ea4:	30 1b       	mov	r11,1
80004ea6:	f0 1f 00 03 	mcall	80004eb0 <xcmp_enter_enhanced_OB_mode+0x20>
}
80004eaa:	2c dd       	sub	sp,-204
80004eac:	d8 02       	popm	pc
80004eae:	00 00       	add	r0,r0
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	4d a0       	lddpc	r0,80005018 <xcmp_rx_process+0x64>

80004eb4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004eb4:	d4 01       	pushm	lr
80004eb6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004eba:	fe 78 b4 00 	mov	r8,-19456
80004ebe:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004ec0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80004ec4:	30 89       	mov	r9,8
80004ec6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004ec8:	30 19       	mov	r9,1
80004eca:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004ecc:	30 09       	mov	r9,0
80004ece:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004ed0:	30 5a       	mov	r10,5
80004ed2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004ed4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004ed6:	30 7a       	mov	r10,7
80004ed8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004eda:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004edc:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004ede:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004ee2:	30 9b       	mov	r11,9
80004ee4:	fa cc ff fe 	sub	r12,sp,-2
80004ee8:	f0 1f 00 02 	mcall	80004ef0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004eec:	2c dd       	sub	sp,-204
80004eee:	d8 02       	popm	pc
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	4d a0       	lddpc	r0,80005058 <xcmp_rx_process+0xa4>

80004ef4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004ef4:	d4 01       	pushm	lr
80004ef6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004efa:	fe 78 80 00 	mov	r8,-32768
80004efe:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004f00:	30 38       	mov	r8,3
80004f02:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004f04:	30 1b       	mov	r11,1
80004f06:	fa cc ff fe 	sub	r12,sp,-2
80004f0a:	f0 1f 00 03 	mcall	80004f14 <xcmp_opcode_not_supported+0x20>
}
80004f0e:	2c dd       	sub	sp,-204
80004f10:	d8 02       	popm	pc
80004f12:	00 00       	add	r0,r0
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	4d a0       	lddpc	r0,8000507c <xcmp_rx_process+0xc8>

80004f18 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004f18:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004f1a:	96 88       	ld.uh	r8,r11[0x0]
80004f1c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004f20:	e0 48 80 00 	cp.w	r8,32768
80004f24:	c0 f0       	breq	80004f42 <xcmp_exec_func+0x2a>
80004f26:	e0 48 b0 00 	cp.w	r8,45056
80004f2a:	c1 20       	breq	80004f4e <xcmp_exec_func+0x36>
80004f2c:	58 08       	cp.w	r8,0
80004f2e:	c1 51       	brne	80004f58 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004f30:	78 08       	ld.w	r8,r12[0x0]
80004f32:	58 08       	cp.w	r8,0
80004f34:	c0 40       	breq	80004f3c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004f36:	16 9c       	mov	r12,r11
80004f38:	5d 18       	icall	r8
80004f3a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004f3c:	f0 1f 00 08 	mcall	80004f5c <xcmp_exec_func+0x44>
80004f40:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004f42:	78 18       	ld.w	r8,r12[0x4]
80004f44:	58 08       	cp.w	r8,0
80004f46:	c0 90       	breq	80004f58 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004f48:	16 9c       	mov	r12,r11
80004f4a:	5d 18       	icall	r8
80004f4c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004f4e:	78 28       	ld.w	r8,r12[0x8]
80004f50:	58 08       	cp.w	r8,0
80004f52:	c0 30       	breq	80004f58 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004f54:	16 9c       	mov	r12,r11
80004f56:	5d 18       	icall	r8
80004f58:	d8 02       	popm	pc
80004f5a:	00 00       	add	r0,r0
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	4e f4       	lddpc	r4,80005118 <xnl_get_msg_ack_func+0x10>

80004f60 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004f60:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004f62:	f0 1f 00 0d 	mcall	80004f94 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004f66:	48 dc       	lddpc	r12,80004f98 <xcmp_init+0x38>
80004f68:	f0 1f 00 0d 	mcall	80004f9c <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004f6c:	30 4b       	mov	r11,4
80004f6e:	31 4c       	mov	r12,20
80004f70:	f0 1f 00 0c 	mcall	80004fa0 <xcmp_init+0x40>
80004f74:	48 c8       	lddpc	r8,80004fa4 <xcmp_init+0x44>
80004f76:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004f78:	30 09       	mov	r9,0
80004f7a:	1a d9       	st.w	--sp,r9
80004f7c:	1a d9       	st.w	--sp,r9
80004f7e:	1a d9       	st.w	--sp,r9
80004f80:	30 38       	mov	r8,3
80004f82:	e0 6a 01 80 	mov	r10,384
80004f86:	48 9b       	lddpc	r11,80004fa8 <xcmp_init+0x48>
80004f88:	48 9c       	lddpc	r12,80004fac <xcmp_init+0x4c>
80004f8a:	f0 1f 00 0a 	mcall	80004fb0 <xcmp_init+0x50>
80004f8e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004f90:	d8 02       	popm	pc
80004f92:	00 00       	add	r0,r0
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	53 40       	stdsp	sp[0xd0],r0
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	50 b0       	stdsp	sp[0x2c],r0
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	50 fc       	stdsp	sp[0x3c],r12
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	8f bc       	st.w	r7[0x2c],r12
80004fa4:	00 00       	add	r0,r0
80004fa6:	10 04       	add	r4,r8
80004fa8:	80 01       	ld.sh	r1,r0[0x0]
80004faa:	88 7c       	ld.sh	r12,r4[0xe]
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	4f b4       	lddpc	r4,80005198 <xnl_tx_process+0x64>
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	96 90       	ld.uh	r0,r11[0x2]

80004fb4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004fb4:	d4 31       	pushm	r0-r7,lr
80004fb6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80004fb8:	4b 16       	lddpc	r6,8000507c <xcmp_rx_process+0xc8>
80004fba:	30 05       	mov	r5,0
80004fbc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004fbe:	4b 13       	lddpc	r3,80005080 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004fc0:	4b 12       	lddpc	r2,80005084 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004fc2:	4b 21       	lddpc	r1,80005088 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004fc4:	4b 20       	lddpc	r0,8000508c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80004fc6:	6c 0c       	ld.w	r12,r6[0x0]
80004fc8:	0a 99       	mov	r9,r5
80004fca:	08 9a       	mov	r10,r4
80004fcc:	1a 9b       	mov	r11,sp
80004fce:	f0 1f 00 31 	mcall	80005090 <xcmp_rx_process+0xdc>
80004fd2:	58 1c       	cp.w	r12,1
80004fd4:	cf 91       	brne	80004fc6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004fd6:	40 0b       	lddsp	r11,sp[0x0]
80004fd8:	58 0b       	cp.w	r11,0
80004fda:	cf 60       	breq	80004fc6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004fdc:	96 0a       	ld.sh	r10,r11[0x0]
80004fde:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004fe2:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004fe6:	59 c8       	cp.w	r8,28
80004fe8:	c1 e0       	breq	80005024 <xcmp_rx_process+0x70>
80004fea:	e0 89 00 07 	brgt	80004ff8 <xcmp_rx_process+0x44>
80004fee:	58 e8       	cp.w	r8,14
80004ff0:	c0 e0       	breq	8000500c <xcmp_rx_process+0x58>
80004ff2:	58 f8       	cp.w	r8,15
80004ff4:	c2 41       	brne	8000503c <xcmp_rx_process+0x88>
80004ff6:	c0 f8       	rjmp	80005014 <xcmp_rx_process+0x60>
80004ff8:	e0 48 01 09 	cp.w	r8,265
80004ffc:	c1 80       	breq	8000502c <xcmp_rx_process+0x78>
80004ffe:	e0 48 01 0a 	cp.w	r8,266
80005002:	c1 90       	breq	80005034 <xcmp_rx_process+0x80>
80005004:	e0 48 00 2c 	cp.w	r8,44
80005008:	c1 a1       	brne	8000503c <xcmp_rx_process+0x88>
8000500a:	c0 98       	rjmp	8000501c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000500c:	4a 2c       	lddpc	r12,80005094 <xcmp_rx_process+0xe0>
8000500e:	f0 1f 00 23 	mcall	80005098 <xcmp_rx_process+0xe4>
					break;
80005012:	c2 f8       	rjmp	80005070 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80005014:	4a 2c       	lddpc	r12,8000509c <xcmp_rx_process+0xe8>
80005016:	f0 1f 00 21 	mcall	80005098 <xcmp_rx_process+0xe4>
					break;
8000501a:	c2 b8       	rjmp	80005070 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000501c:	4a 1c       	lddpc	r12,800050a0 <xcmp_rx_process+0xec>
8000501e:	f0 1f 00 1f 	mcall	80005098 <xcmp_rx_process+0xe4>
					break;
80005022:	c2 78       	rjmp	80005070 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005024:	04 9c       	mov	r12,r2
80005026:	f0 1f 00 1d 	mcall	80005098 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000502a:	c2 38       	rjmp	80005070 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000502c:	02 9c       	mov	r12,r1
8000502e:	f0 1f 00 1b 	mcall	80005098 <xcmp_rx_process+0xe4>
					break;
80005032:	c1 f8       	rjmp	80005070 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80005034:	00 9c       	mov	r12,r0
80005036:	f0 1f 00 19 	mcall	80005098 <xcmp_rx_process+0xe4>
					break;
8000503a:	c1 b8       	rjmp	80005070 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000503c:	12 98       	mov	r8,r9
8000503e:	e2 18 04 00 	andl	r8,0x400,COH
80005042:	c0 70       	breq	80005050 <xcmp_rx_process+0x9c>
80005044:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80005048:	e0 48 00 68 	cp.w	r8,104
8000504c:	e0 8a 00 08 	brle	8000505c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80005050:	e2 19 f0 00 	andl	r9,0xf000,COH
80005054:	c0 e1       	brne	80005070 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80005056:	f0 1f 00 14 	mcall	800050a4 <xcmp_rx_process+0xf0>
8000505a:	c0 b8       	rjmp	80005070 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000505c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80005060:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80005064:	49 19       	lddpc	r9,800050a8 <xcmp_rx_process+0xf4>
80005066:	72 08       	ld.w	r8,r9[0x0]
80005068:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000506c:	f0 1f 00 0b 	mcall	80005098 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80005070:	66 0c       	ld.w	r12,r3[0x0]
80005072:	40 0b       	lddsp	r11,sp[0x0]
80005074:	f0 1f 00 0e 	mcall	800050ac <xcmp_rx_process+0xf8>
80005078:	ca 7b       	rjmp	80004fc6 <xcmp_rx_process+0x12>
8000507a:	00 00       	add	r0,r0
8000507c:	00 00       	add	r0,r0
8000507e:	10 04       	add	r4,r8
80005080:	00 00       	add	r0,r0
80005082:	0f a8       	ld.ub	r8,r7[0x2]
80005084:	00 00       	add	r0,r0
80005086:	10 14       	sub	r4,r8
80005088:	00 00       	add	r0,r0
8000508a:	10 08       	add	r8,r8
8000508c:	00 00       	add	r0,r0
8000508e:	10 20       	rsub	r0,r8
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	8c 58       	ld.sh	r8,r6[0xa]
80005094:	00 00       	add	r0,r0
80005096:	10 38       	cp.w	r8,r8
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4f 18       	lddpc	r8,8000525c <xnl_tx>
8000509c:	00 00       	add	r0,r0
8000509e:	0f f8       	ld.ub	r8,r7[0x7]
800050a0:	00 00       	add	r0,r0
800050a2:	10 2c       	rsub	r12,r8
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	4e f4       	lddpc	r4,80005260 <xnl_tx+0x4>
800050a8:	00 00       	add	r0,r0
800050aa:	46 14       	lddsp	r4,sp[0x184]
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	3a 50       	mov	r0,-91

800050b0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800050b0:	eb cd 40 90 	pushm	r4,r7,lr
800050b4:	20 1d       	sub	sp,4
800050b6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800050ba:	48 c8       	lddpc	r8,800050e8 <xcmp_rx+0x38>
800050bc:	70 0c       	ld.w	r12,r8[0x0]
800050be:	f0 1f 00 0c 	mcall	800050ec <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800050c2:	c1 00       	breq	800050e2 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800050c4:	fa c7 ff fc 	sub	r7,sp,-4
800050c8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800050ca:	e0 6a 00 ca 	mov	r10,202
800050ce:	08 9b       	mov	r11,r4
800050d0:	f0 1f 00 08 	mcall	800050f0 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800050d4:	48 88       	lddpc	r8,800050f4 <xcmp_rx+0x44>
800050d6:	70 0c       	ld.w	r12,r8[0x0]
800050d8:	30 09       	mov	r9,0
800050da:	12 9a       	mov	r10,r9
800050dc:	1a 9b       	mov	r11,sp
800050de:	f0 1f 00 07 	mcall	800050f8 <xcmp_rx+0x48>
	}	
}
800050e2:	2f fd       	sub	sp,-4
800050e4:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800050e8:	00 00       	add	r0,r0
800050ea:	0f a8       	ld.ub	r8,r7[0x2]
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	40 b0       	lddsp	r0,sp[0x2c]
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	a4 1a       	st.h	r2[0x2],r10
800050f4:	00 00       	add	r0,r0
800050f6:	10 04       	add	r4,r8
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	8e 64       	ld.sh	r4,r7[0xc]

800050fc <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800050fc:	48 28       	lddpc	r8,80005104 <xnl_register_xcmp_func+0x8>
800050fe:	91 0c       	st.w	r8[0x0],r12
}
80005100:	5e fc       	retal	r12
80005102:	00 00       	add	r0,r0
80005104:	00 00       	add	r0,r0
80005106:	10 68       	and	r8,r8

80005108 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005108:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000510a:	48 88       	lddpc	r8,80005128 <xnl_get_msg_ack_func+0x20>
8000510c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000510e:	98 49       	ld.sh	r9,r12[0x8]
80005110:	f0 09 19 00 	cp.h	r9,r8
80005114:	c0 81       	brne	80005124 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80005116:	48 68       	lddpc	r8,8000512c <xnl_get_msg_ack_func+0x24>
80005118:	70 0c       	ld.w	r12,r8[0x0]
8000511a:	30 09       	mov	r9,0
8000511c:	12 9a       	mov	r10,r9
8000511e:	12 9b       	mov	r11,r9
80005120:	f0 1f 00 04 	mcall	80005130 <xnl_get_msg_ack_func+0x28>
80005124:	d8 02       	popm	pc
80005126:	00 00       	add	r0,r0
80005128:	00 00       	add	r0,r0
8000512a:	10 48       	or	r8,r8
8000512c:	00 00       	add	r0,r0
8000512e:	10 44       	or	r4,r8
80005130:	80 00       	ld.sh	r0,r0[0x0]
80005132:	8e 64       	ld.sh	r4,r7[0xc]

80005134 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80005134:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005136:	4a 86       	lddpc	r6,800051d4 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005138:	4a 82       	lddpc	r2,800051d8 <xnl_tx_process+0xa4>
8000513a:	4a 94       	lddpc	r4,800051dc <xnl_tx_process+0xa8>
8000513c:	30 07       	mov	r7,0
8000513e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005140:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80005142:	4a 85       	lddpc	r5,800051e0 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80005144:	4a 83       	lddpc	r3,800051e4 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005146:	6c 08       	ld.w	r8,r6[0x0]
80005148:	58 08       	cp.w	r8,0
8000514a:	c0 40       	breq	80005152 <xnl_tx_process+0x1e>
8000514c:	58 18       	cp.w	r8,1
8000514e:	cf d1       	brne	80005148 <xnl_tx_process+0x14>
80005150:	c2 08       	rjmp	80005190 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005152:	64 0c       	ld.w	r12,r2[0x0]
80005154:	0e 99       	mov	r9,r7
80005156:	02 9a       	mov	r10,r1
80005158:	08 9b       	mov	r11,r4
8000515a:	f0 1f 00 24 	mcall	800051e8 <xnl_tx_process+0xb4>
8000515e:	58 1c       	cp.w	r12,1
80005160:	cf 31       	brne	80005146 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80005162:	68 0c       	ld.w	r12,r4[0x0]
80005164:	58 0c       	cp.w	r12,0
80005166:	cf 00       	breq	80005146 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005168:	98 28       	ld.sh	r8,r12[0x4]
8000516a:	e0 08 19 00 	cp.h	r8,r0
8000516e:	c0 41       	brne	80005176 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80005170:	f0 1f 00 1f 	mcall	800051ec <xnl_tx_process+0xb8>
						break;
80005174:	ce 9b       	rjmp	80005146 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80005176:	f0 1f 00 1f 	mcall	800051f0 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000517a:	30 18       	mov	r8,1
8000517c:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000517e:	66 0c       	ld.w	r12,r3[0x0]
80005180:	0e 99       	mov	r9,r7
80005182:	0e 9a       	mov	r10,r7
80005184:	0e 9b       	mov	r11,r7
80005186:	f0 1f 00 19 	mcall	800051e8 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000518a:	30 18       	mov	r8,1
8000518c:	8d 08       	st.w	r6[0x0],r8
8000518e:	cd cb       	rjmp	80005146 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80005190:	66 0c       	ld.w	r12,r3[0x0]
80005192:	0e 99       	mov	r9,r7
80005194:	36 4a       	mov	r10,100
80005196:	0e 9b       	mov	r11,r7
80005198:	f0 1f 00 14 	mcall	800051e8 <xnl_tx_process+0xb4>
8000519c:	58 1c       	cp.w	r12,1
8000519e:	c0 81       	brne	800051ae <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800051a0:	49 58       	lddpc	r8,800051f4 <xnl_tx_process+0xc0>
800051a2:	70 0c       	ld.w	r12,r8[0x0]
800051a4:	68 0b       	ld.w	r11,r4[0x0]
800051a6:	f0 1f 00 15 	mcall	800051f8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800051aa:	8d 07       	st.w	r6[0x0],r7
800051ac:	cc db       	rjmp	80005146 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800051ae:	6a 08       	ld.w	r8,r5[0x0]
800051b0:	58 38       	cp.w	r8,3
800051b2:	e0 89 00 09 	brgt	800051c4 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800051b6:	68 0c       	ld.w	r12,r4[0x0]
800051b8:	f0 1f 00 0e 	mcall	800051f0 <xnl_tx_process+0xbc>
						xnl_send_times++;
800051bc:	6a 08       	ld.w	r8,r5[0x0]
800051be:	2f f8       	sub	r8,-1
800051c0:	8b 08       	st.w	r5[0x0],r8
800051c2:	cc 2b       	rjmp	80005146 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800051c4:	48 c8       	lddpc	r8,800051f4 <xnl_tx_process+0xc0>
800051c6:	70 0c       	ld.w	r12,r8[0x0]
800051c8:	68 0b       	ld.w	r11,r4[0x0]
800051ca:	f0 1f 00 0c 	mcall	800051f8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800051ce:	8d 07       	st.w	r6[0x0],r7
800051d0:	cb bb       	rjmp	80005146 <xnl_tx_process+0x12>
800051d2:	00 00       	add	r0,r0
800051d4:	00 00       	add	r0,r0
800051d6:	10 5c       	eor	r12,r8
800051d8:	00 00       	add	r0,r0
800051da:	10 58       	eor	r8,r8
800051dc:	00 00       	add	r0,r0
800051de:	10 54       	eor	r4,r8
800051e0:	00 00       	add	r0,r0
800051e2:	10 60       	and	r0,r8
800051e4:	00 00       	add	r0,r0
800051e6:	10 44       	or	r4,r8
800051e8:	80 00       	ld.sh	r0,r0[0x0]
800051ea:	8c 58       	ld.sh	r8,r6[0xa]
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	8a e8       	ld.uh	r8,r5[0xc]
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	3a 70       	mov	r0,-89
800051f4:	00 00       	add	r0,r0
800051f6:	0f a8       	ld.ub	r8,r7[0x2]
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	3a 50       	mov	r0,-91

800051fc <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800051fc:	eb cd 40 fe 	pushm	r1-r7,lr
80005200:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005202:	49 26       	lddpc	r6,80005248 <xnl_rx_process+0x4c>
80005204:	30 05       	mov	r5,0
80005206:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005208:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000520a:	49 11       	lddpc	r1,8000524c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000520c:	49 12       	lddpc	r2,80005250 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000520e:	6c 0c       	ld.w	r12,r6[0x0]
80005210:	0a 99       	mov	r9,r5
80005212:	08 9a       	mov	r10,r4
80005214:	1a 9b       	mov	r11,sp
80005216:	f0 1f 00 10 	mcall	80005254 <xnl_rx_process+0x58>
8000521a:	58 1c       	cp.w	r12,1
8000521c:	cf 91       	brne	8000520e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000521e:	40 0c       	lddsp	r12,sp[0x0]
80005220:	58 0c       	cp.w	r12,0
80005222:	cf 60       	breq	8000520e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005224:	98 28       	ld.sh	r8,r12[0x4]
80005226:	e6 08 19 00 	cp.h	r8,r3
8000522a:	e0 8b 00 0a 	brhi	8000523e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000522e:	5c 78       	castu.h	r8
80005230:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80005234:	58 09       	cp.w	r9,0
80005236:	c0 40       	breq	8000523e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80005238:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000523c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000523e:	62 0c       	ld.w	r12,r1[0x0]
80005240:	40 0b       	lddsp	r11,sp[0x0]
80005242:	f0 1f 00 06 	mcall	80005258 <xnl_rx_process+0x5c>
80005246:	ce 4b       	rjmp	8000520e <xnl_rx_process+0x12>
80005248:	00 00       	add	r0,r0
8000524a:	0f c4       	ld.ub	r4,r7[0x4]
8000524c:	00 00       	add	r0,r0
8000524e:	0f a8       	ld.ub	r8,r7[0x2]
80005250:	00 00       	add	r0,r0
80005252:	04 fc       	st.b	--r2,r12
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	8c 58       	ld.sh	r8,r6[0xa]
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	3a 50       	mov	r0,-91

8000525c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000525c:	eb cd 40 c0 	pushm	r6-r7,lr
80005260:	20 1d       	sub	sp,4
80005262:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80005264:	98 39       	ld.sh	r9,r12[0x6]
80005266:	3f f8       	mov	r8,-1
80005268:	f0 09 19 00 	cp.h	r9,r8
8000526c:	c0 a1       	brne	80005280 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000526e:	4a e9       	lddpc	r9,80005324 <xnl_tx+0xc8>
80005270:	13 88       	ld.ub	r8,r9[0x0]
80005272:	2f f8       	sub	r8,-1
80005274:	5c 58       	castu.b	r8
80005276:	b2 88       	st.b	r9[0x0],r8
80005278:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000527c:	a9 a8       	sbr	r8,0x8
8000527e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80005280:	8c 49       	ld.sh	r9,r6[0x8]
80005282:	3f f8       	mov	r8,-1
80005284:	f0 09 19 00 	cp.h	r9,r8
80005288:	c0 41       	brne	80005290 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000528a:	4a 88       	lddpc	r8,80005328 <xnl_tx+0xcc>
8000528c:	90 18       	ld.sh	r8,r8[0x2]
8000528e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80005290:	8c 59       	ld.sh	r9,r6[0xa]
80005292:	3f f8       	mov	r8,-1
80005294:	f0 09 19 00 	cp.h	r9,r8
80005298:	c0 41       	brne	800052a0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000529a:	4a 48       	lddpc	r8,80005328 <xnl_tx+0xcc>
8000529c:	90 28       	ld.sh	r8,r8[0x4]
8000529e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800052a0:	8c 69       	ld.sh	r9,r6[0xc]
800052a2:	3f f8       	mov	r8,-1
800052a4:	f0 09 19 00 	cp.h	r9,r8
800052a8:	c0 e1       	brne	800052c4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800052aa:	4a 08       	lddpc	r8,80005328 <xnl_tx+0xcc>
800052ac:	90 49       	ld.sh	r9,r8[0x8]
800052ae:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800052b0:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800052b2:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800052b4:	90 49       	ld.sh	r9,r8[0x8]
800052b6:	e0 19 ff 00 	andl	r9,0xff00
800052ba:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800052be:	f3 e8 10 08 	or	r8,r9,r8
800052c2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800052c4:	0d 98       	ld.ub	r8,r6[0x1]
800052c6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800052c8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800052cc:	10 0c       	add	r12,r8
800052ce:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800052d0:	58 0c       	cp.w	r12,0
800052d2:	e0 89 00 04 	brgt	800052da <xnl_tx+0x7e>
800052d6:	30 09       	mov	r9,0
800052d8:	c0 d8       	rjmp	800052f2 <xnl_tx+0x96>
800052da:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800052de:	2f ec       	sub	r12,-2
800052e0:	30 09       	mov	r9,0
800052e2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800052e4:	15 1b       	ld.sh	r11,r10++
800052e6:	f6 09 00 09 	add	r9,r11,r9
800052ea:	5c 89       	casts.h	r9
		indextohWord     += 1;
800052ec:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800052ee:	18 38       	cp.w	r8,r12
800052f0:	cf a1       	brne	800052e4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800052f2:	5c 39       	neg	r9
800052f4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800052f6:	48 e8       	lddpc	r8,8000532c <xnl_tx+0xd0>
800052f8:	70 0c       	ld.w	r12,r8[0x0]
800052fa:	f0 1f 00 0e 	mcall	80005330 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800052fe:	c1 00       	breq	8000531e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005300:	fa c7 ff fc 	sub	r7,sp,-4
80005304:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80005306:	e0 6a 01 00 	mov	r10,256
8000530a:	0c 9b       	mov	r11,r6
8000530c:	f0 1f 00 0a 	mcall	80005334 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80005310:	48 a8       	lddpc	r8,80005338 <xnl_tx+0xdc>
80005312:	70 0c       	ld.w	r12,r8[0x0]
80005314:	30 09       	mov	r9,0
80005316:	12 9a       	mov	r10,r9
80005318:	1a 9b       	mov	r11,sp
8000531a:	f0 1f 00 09 	mcall	8000533c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000531e:	2f fd       	sub	sp,-4
80005320:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005324:	00 00       	add	r0,r0
80005326:	10 64       	and	r4,r8
80005328:	00 00       	add	r0,r0
8000532a:	10 48       	or	r8,r8
8000532c:	00 00       	add	r0,r0
8000532e:	0f a8       	ld.ub	r8,r7[0x2]
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	40 b0       	lddsp	r0,sp[0x2c]
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	a4 1a       	st.h	r2[0x2],r10
80005338:	00 00       	add	r0,r0
8000533a:	10 58       	eor	r8,r8
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	8e 64       	ld.sh	r4,r7[0xc]

80005340 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80005340:	eb cd 40 80 	pushm	r7,lr
80005344:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80005348:	f0 1f 00 27 	mcall	800053e4 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000534c:	30 09       	mov	r9,0
8000534e:	4a 78       	lddpc	r8,800053e8 <xnl_init+0xa8>
80005350:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80005352:	30 0b       	mov	r11,0
80005354:	30 1c       	mov	r12,1
80005356:	f0 1f 00 26 	mcall	800053ec <xnl_init+0xac>
8000535a:	4a 68       	lddpc	r8,800053f0 <xnl_init+0xb0>
8000535c:	91 0c       	st.w	r8[0x0],r12
8000535e:	70 08       	ld.w	r8,r8[0x0]
80005360:	58 08       	cp.w	r8,0
80005362:	c0 80       	breq	80005372 <xnl_init+0x32>
80005364:	4a 38       	lddpc	r8,800053f0 <xnl_init+0xb0>
80005366:	70 0c       	ld.w	r12,r8[0x0]
80005368:	30 09       	mov	r9,0
8000536a:	12 9a       	mov	r10,r9
8000536c:	12 9b       	mov	r11,r9
8000536e:	f0 1f 00 22 	mcall	800053f4 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80005372:	30 4b       	mov	r11,4
80005374:	31 4c       	mov	r12,20
80005376:	f0 1f 00 1e 	mcall	800053ec <xnl_init+0xac>
8000537a:	4a 08       	lddpc	r8,800053f8 <xnl_init+0xb8>
8000537c:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000537e:	30 07       	mov	r7,0
80005380:	1a d7       	st.w	--sp,r7
80005382:	1a d7       	st.w	--sp,r7
80005384:	1a d7       	st.w	--sp,r7
80005386:	30 38       	mov	r8,3
80005388:	0e 99       	mov	r9,r7
8000538a:	e0 6a 02 00 	mov	r10,512
8000538e:	49 cb       	lddpc	r11,800053fc <xnl_init+0xbc>
80005390:	49 cc       	lddpc	r12,80005400 <xnl_init+0xc0>
80005392:	f0 1f 00 1d 	mcall	80005404 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80005396:	1a d7       	st.w	--sp,r7
80005398:	1a d7       	st.w	--sp,r7
8000539a:	1a d7       	st.w	--sp,r7
8000539c:	30 38       	mov	r8,3
8000539e:	0e 99       	mov	r9,r7
800053a0:	e0 6a 03 20 	mov	r10,800
800053a4:	49 9b       	lddpc	r11,80005408 <xnl_init+0xc8>
800053a6:	49 ac       	lddpc	r12,8000540c <xnl_init+0xcc>
800053a8:	f0 1f 00 17 	mcall	80005404 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800053ac:	e0 68 40 0e 	mov	r8,16398
800053b0:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800053b4:	3f f8       	mov	r8,-1
800053b6:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800053ba:	30 38       	mov	r8,3
800053bc:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800053c0:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800053c4:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800053c8:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800053cc:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800053d0:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800053d4:	fa cc ff e8 	sub	r12,sp,-24
800053d8:	f0 1f 00 0e 	mcall	80005410 <xnl_init+0xd0>
800053dc:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800053de:	2c 0d       	sub	sp,-256
800053e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	40 d8       	lddsp	r8,sp[0x34]
800053e8:	00 00       	add	r0,r0
800053ea:	10 48       	or	r8,r8
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	8f bc       	st.w	r7[0x2c],r12
800053f0:	00 00       	add	r0,r0
800053f2:	10 44       	or	r4,r8
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	8e 64       	ld.sh	r4,r7[0xc]
800053f8:	00 00       	add	r0,r0
800053fa:	10 58       	eor	r8,r8
800053fc:	80 01       	ld.sh	r1,r0[0x0]
800053fe:	88 84       	ld.uh	r4,r4[0x0]
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	51 fc       	stdsp	sp[0x7c],r12
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	96 90       	ld.uh	r0,r11[0x2]
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	fc 00       	*unknown*
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	51 34       	stdsp	sp[0x4c],r4
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	52 5c       	stdsp	sp[0x94],r12

80005414 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005414:	eb cd 40 80 	pushm	r7,lr
80005418:	fa cd 01 00 	sub	sp,sp,256
8000541c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000541e:	e0 68 40 0e 	mov	r8,16398
80005422:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005424:	3f f8       	mov	r8,-1
80005426:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005428:	30 c8       	mov	r8,12
8000542a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000542c:	98 38       	ld.sh	r8,r12[0x6]
8000542e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005430:	98 58       	ld.sh	r8,r12[0xa]
80005432:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80005434:	98 48       	ld.sh	r8,r12[0x8]
80005436:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005438:	98 68       	ld.sh	r8,r12[0xc]
8000543a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000543c:	30 08       	mov	r8,0
8000543e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005440:	1a 9c       	mov	r12,sp
80005442:	f0 1f 00 0a 	mcall	80005468 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80005446:	fa cd 00 cc 	sub	sp,sp,204
8000544a:	e0 6a 00 ca 	mov	r10,202
8000544e:	ee cb ff f0 	sub	r11,r7,-16
80005452:	1a 9c       	mov	r12,sp
80005454:	f0 1f 00 06 	mcall	8000546c <xnl_data_msg_func+0x58>
80005458:	48 68       	lddpc	r8,80005470 <xnl_data_msg_func+0x5c>
8000545a:	70 08       	ld.w	r8,r8[0x0]
8000545c:	5d 18       	icall	r8
8000545e:	fa cd ff 34 	sub	sp,sp,-204
}
80005462:	2c 0d       	sub	sp,-256
80005464:	e3 cd 80 80 	ldm	sp++,r7,pc
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	52 5c       	stdsp	sp[0x94],r12
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	a4 1a       	st.h	r2[0x2],r10
80005470:	00 00       	add	r0,r0
80005472:	10 68       	and	r8,r8

80005474 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005474:	d4 21       	pushm	r4-r7,lr
80005476:	fa cd 01 00 	sub	sp,sp,256
8000547a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000547c:	4c 28       	lddpc	r8,80005584 <xnl_device_auth_reply_func+0x110>
8000547e:	11 88       	ld.ub	r8,r8[0x0]
80005480:	58 08       	cp.w	r8,0
80005482:	c7 e1       	brne	8000557e <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80005484:	4c 18       	lddpc	r8,80005588 <xnl_device_auth_reply_func+0x114>
80005486:	70 0c       	ld.w	r12,r8[0x0]
80005488:	30 09       	mov	r9,0
8000548a:	12 9a       	mov	r10,r9
8000548c:	12 9b       	mov	r11,r9
8000548e:	f0 1f 00 40 	mcall	8000558c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80005492:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005496:	4b c8       	lddpc	r8,80005584 <xnl_device_auth_reply_func+0x110>
80005498:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000549a:	ef 39 00 12 	ld.ub	r9,r7[18]
8000549e:	ef 38 00 13 	ld.ub	r8,r7[19]
800054a2:	b1 68       	lsl	r8,0x10
800054a4:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800054a8:	ef 38 00 15 	ld.ub	r8,r7[21]
800054ac:	f3 e8 10 08 	or	r8,r9,r8
800054b0:	ef 39 00 14 	ld.ub	r9,r7[20]
800054b4:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800054b8:	ef 3a 00 16 	ld.ub	r10,r7[22]
800054bc:	ef 38 00 17 	ld.ub	r8,r7[23]
800054c0:	b1 68       	lsl	r8,0x10
800054c2:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800054c6:	ef 38 00 19 	ld.ub	r8,r7[25]
800054ca:	f5 e8 10 08 	or	r8,r10,r8
800054ce:	ef 3a 00 18 	ld.ub	r10,r7[24]
800054d2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800054d6:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800054d8:	e0 64 79 b9 	mov	r4,31161
800054dc:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800054e0:	e0 65 45 07 	mov	r5,17671
800054e4:	ea 15 8a bd 	orh	r5,0x8abd
800054e8:	e0 66 f9 3d 	mov	r6,63805
800054ec:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800054f0:	e0 6e b8 cf 	mov	lr,47311
800054f4:	ea 1e 36 83 	orh	lr,0x3683
800054f8:	e0 67 aa 1c 	mov	r7,43548
800054fc:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005500:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005502:	f4 08 00 0c 	add	r12,r10,r8
80005506:	f0 0b 15 04 	lsl	r11,r8,0x4
8000550a:	0a 0b       	add	r11,r5
8000550c:	f9 eb 20 0b 	eor	r11,r12,r11
80005510:	f0 0c 16 05 	lsr	r12,r8,0x5
80005514:	0c 0c       	add	r12,r6
80005516:	18 5b       	eor	r11,r12
80005518:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000551a:	f2 0c 15 04 	lsl	r12,r9,0x4
8000551e:	1c 0c       	add	r12,lr
80005520:	f2 0b 16 05 	lsr	r11,r9,0x5
80005524:	0e 0b       	add	r11,r7
80005526:	f9 eb 20 0b 	eor	r11,r12,r11
8000552a:	f2 0a 00 0c 	add	r12,r9,r10
8000552e:	18 5b       	eor	r11,r12
80005530:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005532:	e0 6b 37 20 	mov	r11,14112
80005536:	ea 1b c6 ef 	orh	r11,0xc6ef
8000553a:	16 3a       	cp.w	r10,r11
8000553c:	ce 21       	brne	80005500 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000553e:	e0 6a 40 1a 	mov	r10,16410
80005542:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005544:	3f fa       	mov	r10,-1
80005546:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005548:	30 6b       	mov	r11,6
8000554a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000554c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000554e:	48 eb       	lddpc	r11,80005584 <xnl_device_auth_reply_func+0x110>
80005550:	96 1c       	ld.sh	r12,r11[0x2]
80005552:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80005554:	96 2b       	ld.sh	r11,r11[0x4]
80005556:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005558:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000555a:	30 ca       	mov	r10,12
8000555c:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000555e:	30 0a       	mov	r10,0
80005560:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80005564:	30 7a       	mov	r10,7
80005566:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000556a:	30 2a       	mov	r10,2
8000556c:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005570:	fa ca ff ec 	sub	r10,sp,-20
80005574:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005576:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005578:	1a 9c       	mov	r12,sp
8000557a:	f0 1f 00 06 	mcall	80005590 <xnl_device_auth_reply_func+0x11c>
}
8000557e:	2c 0d       	sub	sp,-256
80005580:	d8 22       	popm	r4-r7,pc
80005582:	00 00       	add	r0,r0
80005584:	00 00       	add	r0,r0
80005586:	10 48       	or	r8,r8
80005588:	00 00       	add	r0,r0
8000558a:	10 44       	or	r4,r8
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	8e 64       	ld.sh	r4,r7[0xc]
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	52 5c       	stdsp	sp[0x94],r12

80005594 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005594:	eb cd 40 80 	pushm	r7,lr
80005598:	fa cd 01 00 	sub	sp,sp,256
8000559c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000559e:	49 28       	lddpc	r8,800055e4 <xnl_master_status_brdcst_func+0x50>
800055a0:	11 88       	ld.ub	r8,r8[0x0]
800055a2:	58 08       	cp.w	r8,0
800055a4:	c1 c1       	brne	800055dc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800055a6:	49 18       	lddpc	r8,800055e8 <xnl_master_status_brdcst_func+0x54>
800055a8:	70 0c       	ld.w	r12,r8[0x0]
800055aa:	30 09       	mov	r9,0
800055ac:	12 9a       	mov	r10,r9
800055ae:	12 9b       	mov	r11,r9
800055b0:	f0 1f 00 0f 	mcall	800055ec <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800055b4:	8e 58       	ld.sh	r8,r7[0xa]
800055b6:	48 c9       	lddpc	r9,800055e4 <xnl_master_status_brdcst_func+0x50>
800055b8:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800055ba:	e0 68 40 0e 	mov	r8,16398
800055be:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800055c0:	3f f8       	mov	r8,-1
800055c2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800055c4:	30 4a       	mov	r10,4
800055c6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800055c8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800055ca:	92 19       	ld.sh	r9,r9[0x2]
800055cc:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800055ce:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800055d0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800055d2:	30 08       	mov	r8,0
800055d4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800055d6:	1a 9c       	mov	r12,sp
800055d8:	f0 1f 00 06 	mcall	800055f0 <xnl_master_status_brdcst_func+0x5c>
}
800055dc:	2c 0d       	sub	sp,-256
800055de:	e3 cd 80 80 	ldm	sp++,r7,pc
800055e2:	00 00       	add	r0,r0
800055e4:	00 00       	add	r0,r0
800055e6:	10 48       	or	r8,r8
800055e8:	00 00       	add	r0,r0
800055ea:	10 44       	or	r4,r8
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	8e 64       	ld.sh	r4,r7[0xc]
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	52 5c       	stdsp	sp[0x94],r12

800055f4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800055f4:	eb cd 40 80 	pushm	r7,lr
800055f8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800055fa:	49 38       	lddpc	r8,80005644 <xnl_device_conn_reply_func+0x50>
800055fc:	70 0c       	ld.w	r12,r8[0x0]
800055fe:	30 09       	mov	r9,0
80005600:	12 9a       	mov	r10,r9
80005602:	12 9b       	mov	r11,r9
80005604:	f0 1f 00 11 	mcall	80005648 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005608:	ef 18 00 10 	ld.uh	r8,r7[16]
8000560c:	10 99       	mov	r9,r8
8000560e:	e2 19 ff 00 	andl	r9,0xff00,COH
80005612:	e0 49 01 00 	cp.w	r9,256
80005616:	c0 60       	breq	80005622 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005618:	0e 9c       	mov	r12,r7
8000561a:	f0 1f 00 0d 	mcall	8000564c <xnl_device_conn_reply_func+0x58>
8000561e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005622:	a9 68       	lsl	r8,0x8
80005624:	48 b9       	lddpc	r9,80005650 <xnl_device_conn_reply_func+0x5c>
80005626:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005628:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000562c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000562e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80005632:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005634:	30 18       	mov	r8,1
80005636:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005638:	48 7c       	lddpc	r12,80005654 <xnl_device_conn_reply_func+0x60>
8000563a:	f0 1f 00 08 	mcall	80005658 <xnl_device_conn_reply_func+0x64>
8000563e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005642:	00 00       	add	r0,r0
80005644:	00 00       	add	r0,r0
80005646:	10 44       	or	r4,r8
80005648:	80 00       	ld.sh	r0,r0[0x0]
8000564a:	8e 64       	ld.sh	r4,r7[0xc]
8000564c:	80 00       	ld.sh	r0,r0[0x0]
8000564e:	55 94       	stdsp	sp[0x164],r4
80005650:	00 00       	add	r0,r0
80005652:	10 48       	or	r8,r8
80005654:	80 01       	ld.sh	r1,r0[0x0]
80005656:	88 8c       	ld.uh	r12,r4[0x0]
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	9a 54       	ld.sh	r4,sp[0xa]

8000565c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000565c:	fe 78 0c 00 	mov	r8,-62464
80005660:	e0 69 03 07 	mov	r9,775
80005664:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005666:	30 49       	mov	r9,4
80005668:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000566a:	71 59       	ld.w	r9,r8[0x54]
8000566c:	e2 19 00 80 	andl	r9,0x80,COH
80005670:	cf d0       	breq	8000566a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005672:	fe 78 0c 00 	mov	r8,-62464
80005676:	30 59       	mov	r9,5
80005678:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000567a:	e0 69 01 0d 	mov	r9,269
8000567e:	ea 19 10 07 	orh	r9,0x1007
80005682:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005684:	71 59       	ld.w	r9,r8[0x54]
80005686:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000568a:	cf d0       	breq	80005684 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000568c:	fe 78 0c 00 	mov	r8,-62464
80005690:	fc 19 00 80 	movh	r9,0x80
80005694:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005696:	34 0a       	mov	r10,64
80005698:	fe 69 14 00 	mov	r9,-125952
8000569c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000569e:	30 69       	mov	r9,6
800056a0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800056a2:	30 19       	mov	r9,1
800056a4:	fe 68 10 00 	mov	r8,-126976
800056a8:	91 19       	st.w	r8[0x4],r9
}
800056aa:	5e fc       	retal	r12

800056ac <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
800056ac:	fe 78 2c 00 	mov	r8,-54272
800056b0:	32 49       	mov	r9,36
800056b2:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
800056b4:	e0 69 11 00 	mov	r9,4352
800056b8:	ea 19 00 51 	orh	r9,0x51
800056bc:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
800056be:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
800056c0:	30 39       	mov	r9,3
800056c2:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
800056c4:	70 8c       	ld.w	r12,r8[0x20]
800056c6:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
800056ca:	cf d0       	breq	800056c4 <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
800056cc:	18 98       	mov	r8,r12
800056ce:	e2 18 01 00 	andl	r8,0x100,COH
800056d2:	c0 51       	brne	800056dc <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
800056d4:	fe 78 2c 00 	mov	r8,-54272
800056d8:	70 c8       	ld.w	r8,r8[0x30]
800056da:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
800056dc:	fe 78 2c 00 	mov	r8,-54272
800056e0:	70 89       	ld.w	r9,r8[0x20]
800056e2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800056e6:	cf d0       	breq	800056e0 <read_a_byte+0x34>
	return (TWI_Status);
}
800056e8:	5e fc       	retal	r12
800056ea:	d7 03       	nop

800056ec <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
800056ec:	eb cd 40 e0 	pushm	r5-r7,lr
800056f0:	20 2d       	sub	sp,8
800056f2:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
800056f4:	4c 28       	lddpc	r8,800057fc <rtc_read_time+0x110>
800056f6:	70 08       	ld.w	r8,r8[0x0]
800056f8:	58 08       	cp.w	r8,0
800056fa:	c0 31       	brne	80005700 <rtc_read_time+0x14>
800056fc:	30 3c       	mov	r12,3
800056fe:	c7 b8       	rjmp	800057f4 <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005700:	4b f6       	lddpc	r6,800057fc <rtc_read_time+0x110>
80005702:	6c 0c       	ld.w	r12,r6[0x0]
80005704:	30 09       	mov	r9,0
80005706:	3f fa       	mov	r10,-1
80005708:	12 9b       	mov	r11,r9
8000570a:	f0 1f 00 3e 	mcall	80005800 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
8000570e:	1a 9b       	mov	r11,sp
80005710:	30 2c       	mov	r12,2
80005712:	f0 1f 00 3d 	mcall	80005804 <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005716:	1b 88       	ld.ub	r8,sp[0x0]
80005718:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
8000571c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005720:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005724:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005728:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
8000572a:	fa cb ff ff 	sub	r11,sp,-1
8000572e:	30 3c       	mov	r12,3
80005730:	f0 1f 00 35 	mcall	80005804 <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005734:	1b 98       	ld.ub	r8,sp[0x1]
80005736:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
8000573a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000573e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005742:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005746:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005748:	fa cb ff fe 	sub	r11,sp,-2
8000574c:	30 4c       	mov	r12,4
8000574e:	f0 1f 00 2e 	mcall	80005804 <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
80005752:	1b a8       	ld.ub	r8,sp[0x2]
80005754:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005758:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000575c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005760:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005764:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
80005766:	fa cb ff fd 	sub	r11,sp,-3
8000576a:	30 5c       	mov	r12,5
8000576c:	f0 1f 00 26 	mcall	80005804 <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
80005770:	1b b8       	ld.ub	r8,sp[0x3]
80005772:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005776:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000577a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000577e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005782:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
80005784:	fa cb ff fc 	sub	r11,sp,-4
80005788:	30 6c       	mov	r12,6
8000578a:	f0 1f 00 1f 	mcall	80005804 <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
8000578e:	1b c8       	ld.ub	r8,sp[0x4]
80005790:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005794:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
80005796:	fa cb ff fb 	sub	r11,sp,-5
8000579a:	30 7c       	mov	r12,7
8000579c:	f0 1f 00 1a 	mcall	80005804 <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
800057a0:	1b d8       	ld.ub	r8,sp[0x5]
800057a2:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
800057a6:	f2 0a 15 02 	lsl	r10,r9,0x2
800057aa:	14 09       	add	r9,r10
800057ac:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057b0:	f0 09 00 18 	add	r8,r8,r9<<0x1
800057b4:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
800057b6:	fa cb ff fa 	sub	r11,sp,-6
800057ba:	30 8c       	mov	r12,8
800057bc:	f0 1f 00 12 	mcall	80005804 <rtc_read_time+0x118>
800057c0:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
800057c2:	1b e9       	ld.ub	r9,sp[0x6]
800057c4:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
800057c8:	f0 c8 f8 30 	sub	r8,r8,-2000
800057cc:	a5 89       	lsr	r9,0x4
800057ce:	f2 09 10 0a 	mul	r9,r9,10
800057d2:	12 08       	add	r8,r9
800057d4:	5c 78       	castu.h	r8
800057d6:	30 0b       	mov	r11,0
800057d8:	f0 09 16 08 	lsr	r9,r8,0x8
800057dc:	ae 89       	st.b	r7[0x0],r9
800057de:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
800057e0:	6c 0c       	ld.w	r12,r6[0x0]
800057e2:	16 99       	mov	r9,r11
800057e4:	16 9a       	mov	r10,r11
800057e6:	f0 1f 00 09 	mcall	80005808 <rtc_read_time+0x11c>
		
	if(res)
800057ea:	58 05       	cp.w	r5,0
800057ec:	f9 bc 01 00 	movne	r12,0
800057f0:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
800057f4:	2f ed       	sub	sp,-8
800057f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800057fa:	00 00       	add	r0,r0
800057fc:	00 00       	add	r0,r0
800057fe:	10 78       	tst	r8,r8
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	8c 58       	ld.sh	r8,r6[0xa]
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	56 ac       	stdsp	sp[0x1a8],r12
80005808:	80 00       	ld.sh	r0,r0[0x0]
8000580a:	8e 64       	ld.sh	r4,r7[0xc]

8000580c <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
8000580c:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005810:	48 47       	lddpc	r7,80005820 <getTime+0x14>
80005812:	0e 9c       	mov	r12,r7
80005814:	f0 1f 00 04 	mcall	80005824 <getTime+0x18>
	return &date_time;
80005818:	0e 9c       	mov	r12,r7
8000581a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000581e:	00 00       	add	r0,r0
80005820:	00 00       	add	r0,r0
80005822:	10 70       	tst	r0,r8
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	56 ec       	stdsp	sp[0x1b8],r12

80005828 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005828:	eb cd 40 c0 	pushm	r6-r7,lr
8000582c:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
8000582e:	f0 1f 00 1a 	mcall	80005894 <rtc_init+0x6c>
80005832:	49 a8       	lddpc	r8,80005898 <rtc_init+0x70>
80005834:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005836:	70 08       	ld.w	r8,r8[0x0]
80005838:	58 08       	cp.w	r8,0
8000583a:	c0 31       	brne	80005840 <rtc_init+0x18>
8000583c:	30 3c       	mov	r12,3
8000583e:	c2 78       	rjmp	8000588c <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005840:	49 66       	lddpc	r6,80005898 <rtc_init+0x70>
80005842:	6c 0c       	ld.w	r12,r6[0x0]
80005844:	30 09       	mov	r9,0
80005846:	3f fa       	mov	r10,-1
80005848:	12 9b       	mov	r11,r9
8000584a:	f0 1f 00 15 	mcall	8000589c <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
8000584e:	30 2b       	mov	r11,2
80005850:	49 4c       	lddpc	r12,800058a0 <rtc_init+0x78>
80005852:	f0 1f 00 15 	mcall	800058a4 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80005856:	e0 68 36 00 	mov	r8,13824
8000585a:	ea 18 01 6e 	orh	r8,0x16e
8000585e:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80005860:	e2 78 0d 40 	mov	r8,200000
80005864:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80005866:	35 18       	mov	r8,81
80005868:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
8000586c:	1a 9b       	mov	r11,sp
8000586e:	fe 7c 2c 00 	mov	r12,-54272
80005872:	f0 1f 00 0e 	mcall	800058a8 <rtc_init+0x80>
80005876:	48 e7       	lddpc	r7,800058ac <rtc_init+0x84>
80005878:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
8000587a:	6c 0c       	ld.w	r12,r6[0x0]
8000587c:	30 09       	mov	r9,0
8000587e:	12 9a       	mov	r10,r9
80005880:	12 9b       	mov	r11,r9
80005882:	f0 1f 00 0c 	mcall	800058b0 <rtc_init+0x88>
80005886:	6e 08       	ld.w	r8,r7[0x0]
80005888:	58 08       	cp.w	r8,0
8000588a:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
8000588c:	2f dd       	sub	sp,-12
8000588e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005892:	00 00       	add	r0,r0
80005894:	80 00       	ld.sh	r0,r0[0x0]
80005896:	8f 64       	st.w	r7[0x18],r4
80005898:	00 00       	add	r0,r0
8000589a:	10 78       	tst	r8,r8
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	8c 58       	ld.sh	r8,r6[0xa]
800058a0:	80 01       	ld.sh	r1,r0[0x0]
800058a2:	88 a0       	ld.uh	r0,r4[0x4]
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	9e f4       	ld.uh	r4,pc[0xe]
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	5f 14       	srne	r4
800058ac:	00 00       	add	r0,r0
800058ae:	10 6c       	and	r12,r8
800058b0:	80 00       	ld.sh	r0,r0[0x0]
800058b2:	8e 64       	ld.sh	r4,r7[0xc]

800058b4 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800058b4:	fe 78 10 00 	mov	r8,-61440
800058b8:	fc 19 00 10 	movh	r9,0x10
800058bc:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800058be:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800058c0:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800058c2:	30 39       	mov	r9,3
800058c4:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800058c8:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800058cc:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800058d0:	fe 78 38 00 	mov	r8,-51200
800058d4:	30 49       	mov	r9,4
800058d6:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800058da:	e0 69 91 0d 	mov	r9,37133
800058de:	ea 19 00 52 	orh	r9,0x52
800058e2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800058e4:	32 09       	mov	r9,32
800058e6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800058e8:	30 59       	mov	r9,5
800058ea:	91 09       	st.w	r8[0x0],r9
}
800058ec:	5e fc       	retal	r12
800058ee:	d7 03       	nop

800058f0 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800058f0:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800058f2:	30 2a       	mov	r10,2
800058f4:	e0 6b 01 c1 	mov	r11,449
800058f8:	48 ec       	lddpc	r12,80005930 <tc_init+0x40>
800058fa:	f0 1f 00 0f 	mcall	80005934 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800058fe:	48 fb       	lddpc	r11,80005938 <tc_init+0x48>
80005900:	fe 7c 38 00 	mov	r12,-51200
80005904:	f0 1f 00 0e 	mcall	8000593c <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005908:	e0 6a 75 30 	mov	r10,30000
8000590c:	30 1b       	mov	r11,1
8000590e:	fe 7c 38 00 	mov	r12,-51200
80005912:	f0 1f 00 0c 	mcall	80005940 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005916:	48 ca       	lddpc	r10,80005944 <tc_init+0x54>
80005918:	30 1b       	mov	r11,1
8000591a:	fe 7c 38 00 	mov	r12,-51200
8000591e:	f0 1f 00 0b 	mcall	80005948 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80005922:	30 1b       	mov	r11,1
80005924:	fe 7c 38 00 	mov	r12,-51200
80005928:	f0 1f 00 09 	mcall	8000594c <tc_init+0x5c>
8000592c:	d8 02       	popm	pc
8000592e:	00 00       	add	r0,r0
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	59 50       	cp.w	r0,21
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	59 74       	cp.w	r4,23
80005938:	80 01       	ld.sh	r1,r0[0x0]
8000593a:	88 b4       	ld.uh	r4,r4[0x6]
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	5c 5a       	castu.b	r10
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	5d 1a       	icall	r10
80005944:	80 01       	ld.sh	r1,r0[0x0]
80005946:	88 b0       	ld.uh	r0,r4[0x6]
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	5d 4e       	*unknown*
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	5c f6       	rol	r6

80005950 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80005950:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80005952:	48 68       	lddpc	r8,80005968 <_tc_interrupt+0x18>
80005954:	70 09       	ld.w	r9,r8[0x0]
80005956:	2f f9       	sub	r9,-1
80005958:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
8000595a:	30 1b       	mov	r11,1
8000595c:	fe 7c 38 00 	mov	r12,-51200
80005960:	f0 1f 00 03 	mcall	8000596c <_tc_interrupt+0x1c>
	
}
80005964:	d4 02       	popm	lr
80005966:	d6 03       	rete
80005968:	00 00       	add	r0,r0
8000596a:	10 7c       	tst	r12,r8
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	5d 08       	ror	r8

80005970 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005970:	c0 08       	rjmp	80005970 <_unhandled_interrupt>
80005972:	d7 03       	nop

80005974 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005974:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005978:	49 99       	lddpc	r9,800059dc <INTC_register_interrupt+0x68>
8000597a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000597e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005982:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005984:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005988:	58 0a       	cp.w	r10,0
8000598a:	c0 91       	brne	8000599c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000598c:	49 59       	lddpc	r9,800059e0 <INTC_register_interrupt+0x6c>
8000598e:	49 6a       	lddpc	r10,800059e4 <INTC_register_interrupt+0x70>
80005990:	12 1a       	sub	r10,r9
80005992:	fe 79 08 00 	mov	r9,-63488
80005996:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000599a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000599c:	58 1a       	cp.w	r10,1
8000599e:	c0 a1       	brne	800059b2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800059a0:	49 09       	lddpc	r9,800059e0 <INTC_register_interrupt+0x6c>
800059a2:	49 2a       	lddpc	r10,800059e8 <INTC_register_interrupt+0x74>
800059a4:	12 1a       	sub	r10,r9
800059a6:	bf aa       	sbr	r10,0x1e
800059a8:	fe 79 08 00 	mov	r9,-63488
800059ac:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059b0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800059b2:	58 2a       	cp.w	r10,2
800059b4:	c0 a1       	brne	800059c8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800059b6:	48 b9       	lddpc	r9,800059e0 <INTC_register_interrupt+0x6c>
800059b8:	48 da       	lddpc	r10,800059ec <INTC_register_interrupt+0x78>
800059ba:	12 1a       	sub	r10,r9
800059bc:	bf ba       	sbr	r10,0x1f
800059be:	fe 79 08 00 	mov	r9,-63488
800059c2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059c6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800059c8:	48 69       	lddpc	r9,800059e0 <INTC_register_interrupt+0x6c>
800059ca:	48 aa       	lddpc	r10,800059f0 <INTC_register_interrupt+0x7c>
800059cc:	12 1a       	sub	r10,r9
800059ce:	ea 1a c0 00 	orh	r10,0xc000
800059d2:	fe 79 08 00 	mov	r9,-63488
800059d6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059da:	5e fc       	retal	r12
800059dc:	80 01       	ld.sh	r1,r0[0x0]
800059de:	88 bc       	ld.uh	r12,r4[0x6]
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	fa 00       	*unknown*
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	fb 04 80 00 	ld.sh	r4,sp[-32768]
800059ea:	fb 12 80 00 	ld.uh	r2,sp[-32768]
800059ee:	fb 20 80 00 	ld.sb	r0,sp[-32768]
800059f2:	fb 2e d4 21 	ld.sb	lr,sp[-11231]

800059f4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800059f4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800059f6:	49 18       	lddpc	r8,80005a38 <INTC_init_interrupts+0x44>
800059f8:	e3 b8 00 01 	mtsr	0x4,r8
800059fc:	49 0e       	lddpc	lr,80005a3c <INTC_init_interrupts+0x48>
800059fe:	30 07       	mov	r7,0
80005a00:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a02:	49 0c       	lddpc	r12,80005a40 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a04:	49 05       	lddpc	r5,80005a44 <INTC_init_interrupts+0x50>
80005a06:	10 15       	sub	r5,r8
80005a08:	fe 76 08 00 	mov	r6,-63488
80005a0c:	c1 08       	rjmp	80005a2c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005a0e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005a10:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a12:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a14:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005a18:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a1a:	10 3a       	cp.w	r10,r8
80005a1c:	fe 9b ff fc 	brhi	80005a14 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a20:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005a24:	2f f7       	sub	r7,-1
80005a26:	2f 8e       	sub	lr,-8
80005a28:	59 37       	cp.w	r7,19
80005a2a:	c0 50       	breq	80005a34 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a2c:	7c 08       	ld.w	r8,lr[0x0]
80005a2e:	58 08       	cp.w	r8,0
80005a30:	ce f1       	brne	80005a0e <INTC_init_interrupts+0x1a>
80005a32:	cf 7b       	rjmp	80005a20 <INTC_init_interrupts+0x2c>
80005a34:	d8 22       	popm	r4-r7,pc
80005a36:	00 00       	add	r0,r0
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	fa 00       	*unknown*
80005a3c:	80 01       	ld.sh	r1,r0[0x0]
80005a3e:	88 bc       	ld.uh	r12,r4[0x6]
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	59 70       	cp.w	r0,23
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	fb 04 fe 78 	ld.sh	r4,sp[-392]

80005a48 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005a48:	fe 78 08 00 	mov	r8,-63488
80005a4c:	e0 69 00 83 	mov	r9,131
80005a50:	f2 0c 01 0c 	sub	r12,r9,r12
80005a54:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005a58:	f2 ca ff c0 	sub	r10,r9,-64
80005a5c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005a60:	58 08       	cp.w	r8,0
80005a62:	c0 21       	brne	80005a66 <_get_interrupt_handler+0x1e>
80005a64:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005a66:	f0 08 12 00 	clz	r8,r8
80005a6a:	48 5a       	lddpc	r10,80005a7c <_get_interrupt_handler+0x34>
80005a6c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005a70:	f0 08 11 1f 	rsub	r8,r8,31
80005a74:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005a76:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005a7a:	5e fc       	retal	r12
80005a7c:	80 01       	ld.sh	r1,r0[0x0]
80005a7e:	88 bc       	ld.uh	r12,r4[0x6]

80005a80 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005a80:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005a84:	30 18       	mov	r8,1
80005a86:	f0 09 18 00 	cp.b	r9,r8
80005a8a:	e0 88 00 04 	brls	80005a92 <spi_initMaster+0x12>
80005a8e:	30 2c       	mov	r12,2
80005a90:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005a92:	e0 68 00 80 	mov	r8,128
80005a96:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005a98:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005a9a:	30 19       	mov	r9,1
80005a9c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005aa0:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005aa4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005aa8:	30 09       	mov	r9,0
80005aaa:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005aae:	30 fa       	mov	r10,15
80005ab0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005ab4:	99 18       	st.w	r12[0x4],r8
80005ab6:	5e f9       	retal	r9

80005ab8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005ab8:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005aba:	30 18       	mov	r8,1
80005abc:	f0 0b 18 00 	cp.b	r11,r8
80005ac0:	5f be       	srhi	lr
80005ac2:	f0 0a 18 00 	cp.b	r10,r8
80005ac6:	5f b8       	srhi	r8
80005ac8:	fd e8 10 08 	or	r8,lr,r8
80005acc:	c0 30       	breq	80005ad2 <spi_selectionMode+0x1a>
80005ace:	30 2c       	mov	r12,2
80005ad0:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80005ad2:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005ad4:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005ad8:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005adc:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005ae0:	99 18       	st.w	r12[0x4],r8
80005ae2:	d8 0a       	popm	pc,r12=0

80005ae4 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005ae4:	78 18       	ld.w	r8,r12[0x4]
80005ae6:	ea 18 00 0f 	orh	r8,0xf
80005aea:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005aec:	78 18       	ld.w	r8,r12[0x4]
80005aee:	e2 18 00 04 	andl	r8,0x4,COH
80005af2:	c0 f0       	breq	80005b10 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005af4:	30 e8       	mov	r8,14
80005af6:	f0 0b 18 00 	cp.b	r11,r8
80005afa:	e0 8b 00 19 	brhi	80005b2c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005afe:	78 18       	ld.w	r8,r12[0x4]
80005b00:	b1 6b       	lsl	r11,0x10
80005b02:	ea 1b ff f0 	orh	r11,0xfff0
80005b06:	e8 1b ff ff 	orl	r11,0xffff
80005b0a:	10 6b       	and	r11,r8
80005b0c:	99 1b       	st.w	r12[0x4],r11
80005b0e:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005b10:	30 38       	mov	r8,3
80005b12:	f0 0b 18 00 	cp.b	r11,r8
80005b16:	e0 8b 00 0b 	brhi	80005b2c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005b1a:	78 18       	ld.w	r8,r12[0x4]
80005b1c:	2f 0b       	sub	r11,-16
80005b1e:	30 19       	mov	r9,1
80005b20:	f2 0b 09 4b 	lsl	r11,r9,r11
80005b24:	5c db       	com	r11
80005b26:	10 6b       	and	r11,r8
80005b28:	99 1b       	st.w	r12[0x4],r11
80005b2a:	5e fd       	retal	0
80005b2c:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005b2e:	5e fc       	retal	r12

80005b30 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005b30:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b34:	c0 58       	rjmp	80005b3e <spi_unselectChip+0xe>
    if (!timeout--) {
80005b36:	58 08       	cp.w	r8,0
80005b38:	c0 21       	brne	80005b3c <spi_unselectChip+0xc>
80005b3a:	5e ff       	retal	1
80005b3c:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b3e:	78 49       	ld.w	r9,r12[0x10]
80005b40:	e2 19 02 00 	andl	r9,0x200,COH
80005b44:	cf 90       	breq	80005b36 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b46:	78 18       	ld.w	r8,r12[0x4]
80005b48:	ea 18 00 0f 	orh	r8,0xf
80005b4c:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005b4e:	fc 18 01 00 	movh	r8,0x100
80005b52:	99 08       	st.w	r12[0x0],r8
80005b54:	5e fd       	retal	0

80005b56 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005b56:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005b5a:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005b5e:	30 39       	mov	r9,3
80005b60:	f2 08 18 00 	cp.b	r8,r9
80005b64:	e0 8b 00 57 	brhi	80005c12 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005b68:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005b6c:	30 1e       	mov	lr,1
80005b6e:	fc 09 18 00 	cp.b	r9,lr
80005b72:	e0 8b 00 50 	brhi	80005c12 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005b76:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005b7a:	30 77       	mov	r7,7
80005b7c:	ee 0e 18 00 	cp.b	lr,r7
80005b80:	e0 88 00 49 	brls	80005c12 <spi_setupChipReg+0xbc>
80005b84:	31 07       	mov	r7,16
80005b86:	ee 0e 18 00 	cp.b	lr,r7
80005b8a:	e0 8b 00 44 	brhi	80005c12 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005b8e:	76 17       	ld.w	r7,r11[0x4]
80005b90:	ee 06 16 01 	lsr	r6,r7,0x1
80005b94:	0c 0a       	add	r10,r6
80005b96:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005b9a:	ec c7 00 01 	sub	r7,r6,1
80005b9e:	e0 47 00 fe 	cp.w	r7,254
80005ba2:	e0 8b 00 38 	brhi	80005c12 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005ba6:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005ba8:	58 06       	cp.w	r6,0
80005baa:	c3 45       	brlt	80005c12 <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005bac:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005bae:	f0 06 16 01 	lsr	r6,r8,0x1
80005bb2:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005bb6:	ec 18 00 01 	eorl	r8,0x1
80005bba:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005bbe:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005bc2:	20 8e       	sub	lr,8
80005bc4:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005bc8:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005bcc:	f7 38 00 09 	ld.ub	r8,r11[9]
80005bd0:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005bd4:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005bd8:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005bdc:	17 88       	ld.ub	r8,r11[0x0]
80005bde:	30 19       	mov	r9,1
80005be0:	f2 08 18 00 	cp.b	r8,r9
80005be4:	c0 e0       	breq	80005c00 <spi_setupChipReg+0xaa>
80005be6:	c0 a3       	brcs	80005bfa <spi_setupChipReg+0xa4>
80005be8:	30 29       	mov	r9,2
80005bea:	f2 08 18 00 	cp.b	r8,r9
80005bee:	c0 c0       	breq	80005c06 <spi_setupChipReg+0xb0>
80005bf0:	30 39       	mov	r9,3
80005bf2:	f2 08 18 00 	cp.b	r8,r9
80005bf6:	c0 e1       	brne	80005c12 <spi_setupChipReg+0xbc>
80005bf8:	c0 a8       	rjmp	80005c0c <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005bfa:	99 ca       	st.w	r12[0x30],r10
80005bfc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005c00:	99 da       	st.w	r12[0x34],r10
80005c02:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005c06:	99 ea       	st.w	r12[0x38],r10
80005c08:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005c0c:	99 fa       	st.w	r12[0x3c],r10
80005c0e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005c12:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005c14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005c18 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005c18:	30 18       	mov	r8,1
80005c1a:	99 08       	st.w	r12[0x0],r8
}
80005c1c:	5e fc       	retal	r12

80005c1e <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005c1e:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005c22:	c0 58       	rjmp	80005c2c <spi_write+0xe>
    if (!timeout--) {
80005c24:	58 08       	cp.w	r8,0
80005c26:	c0 21       	brne	80005c2a <spi_write+0xc>
80005c28:	5e ff       	retal	1
80005c2a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005c2c:	78 49       	ld.w	r9,r12[0x10]
80005c2e:	e2 19 00 02 	andl	r9,0x2,COH
80005c32:	cf 90       	breq	80005c24 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005c34:	5c 7b       	castu.h	r11
80005c36:	99 3b       	st.w	r12[0xc],r11
80005c38:	5e fd       	retal	0

80005c3a <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005c3a:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005c3e:	c0 58       	rjmp	80005c48 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005c40:	58 08       	cp.w	r8,0
80005c42:	c0 21       	brne	80005c46 <spi_read+0xc>
80005c44:	5e ff       	retal	1
80005c46:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005c48:	78 49       	ld.w	r9,r12[0x10]
80005c4a:	e2 19 02 01 	andl	r9,0x201,COH
80005c4e:	e0 49 02 01 	cp.w	r9,513
80005c52:	cf 71       	brne	80005c40 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005c54:	78 28       	ld.w	r8,r12[0x8]
80005c56:	b6 08       	st.h	r11[0x0],r8
80005c58:	5e fd       	retal	0

80005c5a <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005c5a:	76 09       	ld.w	r9,r11[0x0]
80005c5c:	58 29       	cp.w	r9,2
80005c5e:	e0 88 00 03 	brls	80005c64 <tc_init_waveform+0xa>
80005c62:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005c64:	76 18       	ld.w	r8,r11[0x4]
80005c66:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005c6a:	af ba       	sbr	r10,0xf
80005c6c:	10 9b       	mov	r11,r8
80005c6e:	e6 1b c0 00 	andh	r11,0xc000,COH
80005c72:	16 4a       	or	r10,r11
80005c74:	10 9b       	mov	r11,r8
80005c76:	e6 1b 30 00 	andh	r11,0x3000,COH
80005c7a:	16 4a       	or	r10,r11
80005c7c:	10 9b       	mov	r11,r8
80005c7e:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005c82:	16 4a       	or	r10,r11
80005c84:	10 9b       	mov	r11,r8
80005c86:	e6 1b 03 00 	andh	r11,0x300,COH
80005c8a:	16 4a       	or	r10,r11
80005c8c:	10 9b       	mov	r11,r8
80005c8e:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005c92:	16 4a       	or	r10,r11
80005c94:	10 9b       	mov	r11,r8
80005c96:	e6 1b 00 30 	andh	r11,0x30,COH
80005c9a:	16 4a       	or	r10,r11
80005c9c:	10 9b       	mov	r11,r8
80005c9e:	e6 1b 00 0c 	andh	r11,0xc,COH
80005ca2:	16 4a       	or	r10,r11
80005ca4:	10 9b       	mov	r11,r8
80005ca6:	e6 1b 00 03 	andh	r11,0x3,COH
80005caa:	16 4a       	or	r10,r11
80005cac:	10 9b       	mov	r11,r8
80005cae:	e2 1b 60 00 	andl	r11,0x6000,COH
80005cb2:	16 4a       	or	r10,r11
80005cb4:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005cb8:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005cbc:	10 9b       	mov	r11,r8
80005cbe:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005cc2:	16 4a       	or	r10,r11
80005cc4:	10 9b       	mov	r11,r8
80005cc6:	e2 1b 03 00 	andl	r11,0x300,COH
80005cca:	16 4a       	or	r10,r11
80005ccc:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005cd0:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005cd4:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005cd8:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005cdc:	10 9b       	mov	r11,r8
80005cde:	e2 1b 00 30 	andl	r11,0x30,COH
80005ce2:	16 4a       	or	r10,r11
80005ce4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005ce8:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005cec:	a5 69       	lsl	r9,0x4
80005cee:	2f f9       	sub	r9,-1
80005cf0:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005cf4:	5e fd       	retal	0

80005cf6 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005cf6:	58 2b       	cp.w	r11,2
80005cf8:	e0 88 00 03 	brls	80005cfe <tc_start+0x8>
80005cfc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005cfe:	a7 6b       	lsl	r11,0x6
80005d00:	16 0c       	add	r12,r11
80005d02:	30 58       	mov	r8,5
80005d04:	99 08       	st.w	r12[0x0],r8
80005d06:	5e fd       	retal	0

80005d08 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d08:	58 2b       	cp.w	r11,2
80005d0a:	e0 88 00 03 	brls	80005d10 <tc_read_sr+0x8>
80005d0e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80005d10:	a7 6b       	lsl	r11,0x6
80005d12:	2e 0b       	sub	r11,-32
80005d14:	16 0c       	add	r12,r11
80005d16:	78 0c       	ld.w	r12,r12[0x0]
}
80005d18:	5e fc       	retal	r12

80005d1a <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d1a:	58 2b       	cp.w	r11,2
80005d1c:	e0 88 00 03 	brls	80005d22 <tc_write_rc+0x8>
80005d20:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80005d22:	f6 08 15 04 	lsl	r8,r11,0x4
80005d26:	2f f8       	sub	r8,-1
80005d28:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005d2c:	e2 18 80 00 	andl	r8,0x8000,COH
80005d30:	c0 c0       	breq	80005d48 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80005d32:	a7 6b       	lsl	r11,0x6
80005d34:	16 0c       	add	r12,r11
80005d36:	2e 4c       	sub	r12,-28
80005d38:	78 08       	ld.w	r8,r12[0x0]
80005d3a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005d3e:	e0 18 00 00 	andl	r8,0x0
80005d42:	f3 e8 10 08 	or	r8,r9,r8
80005d46:	99 08       	st.w	r12[0x0],r8

  return value;
80005d48:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005d4c:	5e fc       	retal	r12

80005d4e <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80005d4e:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80005d52:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d56:	58 2b       	cp.w	r11,2
80005d58:	e0 88 00 04 	brls	80005d60 <tc_configure_interrupts+0x12>
80005d5c:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005d60:	ee 19 00 01 	eorh	r9,0x1
80005d64:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005d68:	74 08       	ld.w	r8,r10[0x0]
80005d6a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005d6e:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80005d72:	a7 6e       	lsl	lr,0x6
80005d74:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005d78:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005d7c:	0e 4e       	or	lr,r7
80005d7e:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80005d82:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005d86:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005d8a:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005d8e:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80005d92:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005d96:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005d9a:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005d9e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005da2:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005da6:	f6 0e 15 06 	lsl	lr,r11,0x6
80005daa:	f8 0e 00 0e 	add	lr,r12,lr
80005dae:	2d ce       	sub	lr,-36
80005db0:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80005db2:	58 09       	cp.w	r9,0
80005db4:	c0 20       	breq	80005db8 <tc_configure_interrupts+0x6a>
80005db6:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005db8:	74 08       	ld.w	r8,r10[0x0]
80005dba:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005dbe:	e0 65 00 80 	mov	r5,128
80005dc2:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80005dc6:	74 08       	ld.w	r8,r10[0x0]
80005dc8:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005dcc:	f9 b4 00 40 	moveq	r4,64
80005dd0:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80005dd4:	74 08       	ld.w	r8,r10[0x0]
80005dd6:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80005dda:	f9 b3 00 20 	moveq	r3,32
80005dde:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80005de2:	74 08       	ld.w	r8,r10[0x0]
80005de4:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005de8:	f9 b2 00 10 	moveq	r2,16
80005dec:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005df0:	74 08       	ld.w	r8,r10[0x0]
80005df2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005df6:	f9 b6 00 08 	moveq	r6,8
80005dfa:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80005dfe:	74 08       	ld.w	r8,r10[0x0]
80005e00:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80005e04:	f9 b7 00 04 	moveq	r7,4
80005e08:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80005e0c:	74 08       	ld.w	r8,r10[0x0]
80005e0e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005e12:	f9 be 00 02 	moveq	lr,2
80005e16:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005e1a:	74 08       	ld.w	r8,r10[0x0]
80005e1c:	ec 18 00 01 	eorl	r8,0x1
80005e20:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e24:	eb e8 10 08 	or	r8,r5,r8
80005e28:	08 48       	or	r8,r4
80005e2a:	06 48       	or	r8,r3
80005e2c:	04 48       	or	r8,r2
80005e2e:	0c 48       	or	r8,r6
80005e30:	0e 48       	or	r8,r7
80005e32:	1c 48       	or	r8,lr
80005e34:	f6 0a 15 06 	lsl	r10,r11,0x6
80005e38:	f8 0a 00 0a 	add	r10,r12,r10
80005e3c:	2d 8a       	sub	r10,-40
80005e3e:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80005e40:	a7 6b       	lsl	r11,0x6
80005e42:	2e 0b       	sub	r11,-32
80005e44:	16 0c       	add	r12,r11
80005e46:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005e48:	58 09       	cp.w	r9,0
80005e4a:	c0 31       	brne	80005e50 <tc_configure_interrupts+0x102>
80005e4c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005e50:	d5 03       	csrf	0x10
80005e52:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005e56:	d7 03       	nop

80005e58 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80005e58:	4a 78       	lddpc	r8,80005ef4 <twi_master_interrupt_handler+0x9c>
80005e5a:	70 08       	ld.w	r8,r8[0x0]
80005e5c:	70 89       	ld.w	r9,r8[0x20]
80005e5e:	4a 7a       	lddpc	r10,80005ef8 <twi_master_interrupt_handler+0xa0>
80005e60:	74 0a       	ld.w	r10,r10[0x0]
80005e62:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80005e66:	12 9a       	mov	r10,r9
80005e68:	e2 1a 01 00 	andl	r10,0x100,COH
80005e6c:	c3 91       	brne	80005ede <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80005e6e:	12 9a       	mov	r10,r9
80005e70:	e2 1a 00 02 	andl	r10,0x2,COH
80005e74:	c1 70       	breq	80005ea2 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80005e76:	4a 29       	lddpc	r9,80005efc <twi_master_interrupt_handler+0xa4>
80005e78:	72 0a       	ld.w	r10,r9[0x0]
80005e7a:	70 cb       	ld.w	r11,r8[0x30]
80005e7c:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80005e7e:	72 0a       	ld.w	r10,r9[0x0]
80005e80:	2f fa       	sub	r10,-1
80005e82:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80005e84:	49 f9       	lddpc	r9,80005f00 <twi_master_interrupt_handler+0xa8>
80005e86:	72 0a       	ld.w	r10,r9[0x0]
80005e88:	20 1a       	sub	r10,1
80005e8a:	93 0a       	st.w	r9[0x0],r10
80005e8c:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80005e8e:	58 19       	cp.w	r9,1
80005e90:	f9 b9 00 02 	moveq	r9,2
80005e94:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80005e98:	49 a9       	lddpc	r9,80005f00 <twi_master_interrupt_handler+0xa8>
80005e9a:	72 09       	ld.w	r9,r9[0x0]
80005e9c:	58 09       	cp.w	r9,0
80005e9e:	c2 30       	breq	80005ee4 <twi_master_interrupt_handler+0x8c>
80005ea0:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80005ea2:	12 9a       	mov	r10,r9
80005ea4:	e2 1a 00 04 	andl	r10,0x4,COH
80005ea8:	c1 70       	breq	80005ed6 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80005eaa:	49 79       	lddpc	r9,80005f04 <twi_master_interrupt_handler+0xac>
80005eac:	72 0a       	ld.w	r10,r9[0x0]
80005eae:	20 1a       	sub	r10,1
80005eb0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80005eb2:	72 09       	ld.w	r9,r9[0x0]
80005eb4:	58 09       	cp.w	r9,0
80005eb6:	e0 89 00 0a 	brgt	80005eca <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80005eba:	49 09       	lddpc	r9,80005ef8 <twi_master_interrupt_handler+0xa0>
80005ebc:	30 1a       	mov	r10,1
80005ebe:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80005ec0:	3f fa       	mov	r10,-1
80005ec2:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80005ec4:	72 09       	ld.w	r9,r9[0x0]
80005ec6:	91 99       	st.w	r8[0x24],r9
80005ec8:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80005eca:	49 0a       	lddpc	r10,80005f08 <twi_master_interrupt_handler+0xb0>
80005ecc:	74 09       	ld.w	r9,r10[0x0]
80005ece:	13 3b       	ld.ub	r11,r9++
80005ed0:	91 db       	st.w	r8[0x34],r11
80005ed2:	95 09       	st.w	r10[0x0],r9
80005ed4:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80005ed6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005eda:	c0 51       	brne	80005ee4 <twi_master_interrupt_handler+0x8c>
80005edc:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80005ede:	30 1a       	mov	r10,1
80005ee0:	48 b9       	lddpc	r9,80005f0c <twi_master_interrupt_handler+0xb4>
80005ee2:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80005ee4:	3f f9       	mov	r9,-1
80005ee6:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80005ee8:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80005eea:	30 09       	mov	r9,0
80005eec:	48 98       	lddpc	r8,80005f10 <twi_master_interrupt_handler+0xb8>
80005eee:	b0 89       	st.b	r8[0x0],r9
80005ef0:	d6 03       	rete
80005ef2:	00 00       	add	r0,r0
80005ef4:	00 00       	add	r0,r0
80005ef6:	11 34       	ld.ub	r4,r8++
80005ef8:	00 00       	add	r0,r0
80005efa:	11 30       	ld.ub	r0,r8++
80005efc:	00 00       	add	r0,r0
80005efe:	11 40       	ld.w	r0,--r8
80005f00:	00 00       	add	r0,r0
80005f02:	11 3c       	ld.ub	r12,r8++
80005f04:	00 00       	add	r0,r0
80005f06:	11 2c       	ld.uh	r12,r8++
80005f08:	00 00       	add	r0,r0
80005f0a:	11 38       	ld.ub	r8,r8++
80005f0c:	00 00       	add	r0,r0
80005f0e:	11 29       	ld.uh	r9,r8++
80005f10:	00 00       	add	r0,r0
80005f12:	11 28       	ld.uh	r8,r8++

80005f14 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80005f14:	eb cd 40 e0 	pushm	r5-r7,lr
80005f18:	18 97       	mov	r7,r12
80005f1a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80005f1c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80005f20:	49 f9       	lddpc	r9,80005f9c <twi_master_init+0x88>
80005f22:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80005f24:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80005f26:	3f f9       	mov	r9,-1
80005f28:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80005f2a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80005f2c:	e0 69 00 80 	mov	r9,128
80005f30:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005f32:	e6 18 00 01 	andh	r8,0x1,COH
80005f36:	c0 21       	brne	80005f3a <twi_master_init+0x26>
      cpu_irq_enable();
80005f38:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80005f3a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005f3c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80005f40:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80005f42:	30 3a       	mov	r10,3
80005f44:	e0 6b 01 60 	mov	r11,352
80005f48:	49 6c       	lddpc	r12,80005fa0 <twi_master_init+0x8c>
80005f4a:	f0 1f 00 17 	mcall	80005fa4 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005f4e:	e6 16 00 01 	andh	r6,0x1,COH
80005f52:	c0 21       	brne	80005f56 <twi_master_init+0x42>
      cpu_irq_enable();
80005f54:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80005f56:	6a 19       	ld.w	r9,r5[0x4]
80005f58:	a1 79       	lsl	r9,0x1
80005f5a:	6a 08       	ld.w	r8,r5[0x0]
80005f5c:	f0 09 0d 08 	divu	r8,r8,r9
80005f60:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005f62:	e0 48 00 ff 	cp.w	r8,255
80005f66:	e0 8b 00 04 	brhi	80005f6e <twi_master_init+0x5a>
80005f6a:	30 09       	mov	r9,0
80005f6c:	c0 f8       	rjmp	80005f8a <twi_master_init+0x76>
80005f6e:	30 09       	mov	r9,0
80005f70:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80005f72:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80005f74:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005f76:	e0 48 00 ff 	cp.w	r8,255
80005f7a:	5f bb       	srhi	r11
80005f7c:	58 69       	cp.w	r9,6
80005f7e:	5f 8a       	srls	r10
80005f80:	f7 ea 00 0a 	and	r10,r11,r10
80005f84:	f8 0a 18 00 	cp.b	r10,r12
80005f88:	cf 51       	brne	80005f72 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80005f8a:	b1 69       	lsl	r9,0x10
80005f8c:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80005f90:	f3 e8 10 08 	or	r8,r9,r8
80005f94:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80005f96:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80005f9a:	00 00       	add	r0,r0
80005f9c:	00 00       	add	r0,r0
80005f9e:	11 34       	ld.ub	r4,r8++
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	5e 58       	retlt	r8
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	59 74       	cp.w	r4,23

80005fa8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005fa8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005faa:	f6 08 15 04 	lsl	r8,r11,0x4
80005fae:	14 38       	cp.w	r8,r10
80005fb0:	f9 b8 08 10 	movls	r8,16
80005fb4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005fb8:	f0 0b 02 4b 	mul	r11,r8,r11
80005fbc:	f6 09 16 01 	lsr	r9,r11,0x1
80005fc0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005fc4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005fc8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005fcc:	f2 cb 00 01 	sub	r11,r9,1
80005fd0:	e0 4b ff fe 	cp.w	r11,65534
80005fd4:	e0 88 00 03 	brls	80005fda <usart_set_async_baudrate+0x32>
80005fd8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005fda:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005fdc:	e8 6e 00 00 	mov	lr,524288
80005fe0:	59 08       	cp.w	r8,16
80005fe2:	fc 08 17 10 	movne	r8,lr
80005fe6:	f9 b8 00 00 	moveq	r8,0
80005fea:	e4 1b ff f7 	andh	r11,0xfff7
80005fee:	e0 1b fe cf 	andl	r11,0xfecf
80005ff2:	16 48       	or	r8,r11
80005ff4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005ff6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005ffa:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005ffe:	99 89       	st.w	r12[0x20],r9
80006000:	d8 0a       	popm	pc,r12=0

80006002 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006002:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006004:	e2 18 00 02 	andl	r8,0x2,COH
80006008:	c0 31       	brne	8000600e <usart_write_char+0xc>
8000600a:	30 2c       	mov	r12,2
8000600c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000600e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006012:	99 7b       	st.w	r12[0x1c],r11
80006014:	5e fd       	retal	0
80006016:	d7 03       	nop

80006018 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006018:	eb cd 40 e0 	pushm	r5-r7,lr
8000601c:	18 96       	mov	r6,r12
8000601e:	16 95       	mov	r5,r11
80006020:	e0 67 27 0f 	mov	r7,9999
80006024:	c0 68       	rjmp	80006030 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006026:	58 07       	cp.w	r7,0
80006028:	c0 31       	brne	8000602e <usart_putchar+0x16>
8000602a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000602e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006030:	0a 9b       	mov	r11,r5
80006032:	0c 9c       	mov	r12,r6
80006034:	f0 1f 00 03 	mcall	80006040 <usart_putchar+0x28>
80006038:	cf 71       	brne	80006026 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000603a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000603e:	00 00       	add	r0,r0
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	60 02       	ld.w	r2,r0[0x0]

80006044 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006044:	78 58       	ld.w	r8,r12[0x14]
80006046:	e2 18 00 e0 	andl	r8,0xe0,COH
8000604a:	c0 30       	breq	80006050 <usart_read_char+0xc>
8000604c:	30 4c       	mov	r12,4
8000604e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006050:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006052:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006056:	c0 31       	brne	8000605c <usart_read_char+0x18>
80006058:	30 3c       	mov	r12,3
8000605a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000605c:	78 68       	ld.w	r8,r12[0x18]
8000605e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006062:	97 08       	st.w	r11[0x0],r8
80006064:	5e fd       	retal	0
80006066:	d7 03       	nop

80006068 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006068:	eb cd 40 c0 	pushm	r6-r7,lr
8000606c:	20 1d       	sub	sp,4
8000606e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006070:	1a 97       	mov	r7,sp
80006072:	1a 9b       	mov	r11,sp
80006074:	0c 9c       	mov	r12,r6
80006076:	f0 1f 00 07 	mcall	80006090 <usart_getchar+0x28>
8000607a:	58 3c       	cp.w	r12,3
8000607c:	cf b0       	breq	80006072 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000607e:	58 4c       	cp.w	r12,4
80006080:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006084:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006088:	2f fd       	sub	sp,-4
8000608a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000608e:	00 00       	add	r0,r0
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	60 44       	ld.w	r4,r0[0x10]

80006094 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006094:	eb cd 40 c0 	pushm	r6-r7,lr
80006098:	18 96       	mov	r6,r12
8000609a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000609c:	17 8b       	ld.ub	r11,r11[0x0]
8000609e:	58 0b       	cp.w	r11,0
800060a0:	c0 80       	breq	800060b0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800060a2:	2f f7       	sub	r7,-1
800060a4:	0c 9c       	mov	r12,r6
800060a6:	f0 1f 00 04 	mcall	800060b4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800060aa:	0f 8b       	ld.ub	r11,r7[0x0]
800060ac:	58 0b       	cp.w	r11,0
800060ae:	cf a1       	brne	800060a2 <usart_write_line+0xe>
800060b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	60 18       	ld.w	r8,r0[0x4]

800060b8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800060b8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800060bc:	e6 18 00 01 	andh	r8,0x1,COH
800060c0:	c0 71       	brne	800060ce <usart_reset+0x16>
800060c2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800060c4:	3f f8       	mov	r8,-1
800060c6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800060c8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800060ca:	d5 03       	csrf	0x10
800060cc:	c0 48       	rjmp	800060d4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800060ce:	3f f8       	mov	r8,-1
800060d0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800060d2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800060d4:	30 08       	mov	r8,0
800060d6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800060d8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800060da:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800060dc:	ea 68 61 0c 	mov	r8,680204
800060e0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800060e2:	5e fc       	retal	r12

800060e4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800060e4:	eb cd 40 e0 	pushm	r5-r7,lr
800060e8:	18 96       	mov	r6,r12
800060ea:	16 97       	mov	r7,r11
800060ec:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800060ee:	f0 1f 00 2f 	mcall	800061a8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800060f2:	58 07       	cp.w	r7,0
800060f4:	c5 80       	breq	800061a4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800060f6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800060f8:	30 49       	mov	r9,4
800060fa:	f2 08 18 00 	cp.b	r8,r9
800060fe:	e0 88 00 53 	brls	800061a4 <usart_init_rs232+0xc0>
80006102:	30 99       	mov	r9,9
80006104:	f2 08 18 00 	cp.b	r8,r9
80006108:	e0 8b 00 4e 	brhi	800061a4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000610c:	0f d9       	ld.ub	r9,r7[0x5]
8000610e:	30 78       	mov	r8,7
80006110:	f0 09 18 00 	cp.b	r9,r8
80006114:	e0 8b 00 48 	brhi	800061a4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006118:	8e 39       	ld.sh	r9,r7[0x6]
8000611a:	e0 68 01 01 	mov	r8,257
8000611e:	f0 09 19 00 	cp.h	r9,r8
80006122:	e0 8b 00 41 	brhi	800061a4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006126:	ef 39 00 08 	ld.ub	r9,r7[8]
8000612a:	30 38       	mov	r8,3
8000612c:	f0 09 18 00 	cp.b	r9,r8
80006130:	e0 8b 00 3a 	brhi	800061a4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006134:	0a 9a       	mov	r10,r5
80006136:	6e 0b       	ld.w	r11,r7[0x0]
80006138:	0c 9c       	mov	r12,r6
8000613a:	f0 1f 00 1d 	mcall	800061ac <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000613e:	58 1c       	cp.w	r12,1
80006140:	c3 20       	breq	800061a4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006142:	0f c8       	ld.ub	r8,r7[0x4]
80006144:	30 99       	mov	r9,9
80006146:	f2 08 18 00 	cp.b	r8,r9
8000614a:	c0 51       	brne	80006154 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000614c:	6c 18       	ld.w	r8,r6[0x4]
8000614e:	b1 b8       	sbr	r8,0x11
80006150:	8d 18       	st.w	r6[0x4],r8
80006152:	c0 68       	rjmp	8000615e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006154:	6c 19       	ld.w	r9,r6[0x4]
80006156:	20 58       	sub	r8,5
80006158:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000615c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000615e:	6c 19       	ld.w	r9,r6[0x4]
80006160:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006164:	0f d8       	ld.ub	r8,r7[0x5]
80006166:	a9 78       	lsl	r8,0x9
80006168:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000616c:	12 48       	or	r8,r9
8000616e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006170:	8e 38       	ld.sh	r8,r7[0x6]
80006172:	30 29       	mov	r9,2
80006174:	f2 08 19 00 	cp.h	r8,r9
80006178:	e0 88 00 09 	brls	8000618a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000617c:	6c 18       	ld.w	r8,r6[0x4]
8000617e:	ad b8       	sbr	r8,0xd
80006180:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006182:	8e b8       	ld.uh	r8,r7[0x6]
80006184:	20 28       	sub	r8,2
80006186:	8d a8       	st.w	r6[0x28],r8
80006188:	c0 68       	rjmp	80006194 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000618a:	6c 19       	ld.w	r9,r6[0x4]
8000618c:	5c 78       	castu.h	r8
8000618e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006192:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006194:	6c 18       	ld.w	r8,r6[0x4]
80006196:	e0 18 ff f0 	andl	r8,0xfff0
8000619a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000619c:	35 08       	mov	r8,80
8000619e:	8d 08       	st.w	r6[0x0],r8
800061a0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800061a4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	60 b8       	ld.w	r8,r0[0x2c]
800061ac:	80 00       	ld.sh	r0,r0[0x0]
800061ae:	5f a8       	srle	r8

800061b0 <disk_status>:


	return RES_OK;

	
}
800061b0:	5e fd       	retal	0

800061b2 <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
800061b2:	5e fd       	retal	0

800061b4 <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
800061b4:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
800061b6:	f0 1f 00 0e 	mcall	800061ec <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
800061ba:	19 89       	ld.ub	r9,r12[0x0]
800061bc:	19 98       	ld.ub	r8,r12[0x1]
800061be:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800061c2:	f0 c8 07 bc 	sub	r8,r8,1980
800061c6:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
800061c8:	19 aa       	ld.ub	r10,r12[0x2]
800061ca:	b5 7a       	lsl	r10,0x15
800061cc:	19 b9       	ld.ub	r9,r12[0x3]
800061ce:	b1 69       	lsl	r9,0x10
800061d0:	12 0a       	add	r10,r9
	current_time += t->day << 16;
800061d2:	19 f9       	ld.ub	r9,r12[0x7]
800061d4:	a1 99       	lsr	r9,0x1
800061d6:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
800061d8:	19 d9       	ld.ub	r9,r12[0x5]
800061da:	ab 79       	lsl	r9,0xb
800061dc:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
800061de:	19 e9       	ld.ub	r9,r12[0x6]
800061e0:	a5 79       	lsl	r9,0x5
800061e2:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
800061e6:	10 0c       	add	r12,r8
800061e8:	d8 02       	popm	pc
800061ea:	00 00       	add	r0,r0
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	58 0c       	cp.w	r12,0

800061f0 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
800061f0:	eb cd 40 80 	pushm	r7,lr
800061f4:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
800061f6:	30 18       	mov	r8,1
800061f8:	f0 0b 18 00 	cp.b	r11,r8
800061fc:	c1 a0       	breq	80006230 <disk_ioctl+0x40>
800061fe:	58 0b       	cp.w	r11,0
80006200:	c0 c0       	breq	80006218 <disk_ioctl+0x28>
80006202:	30 28       	mov	r8,2
80006204:	f0 0b 18 00 	cp.b	r11,r8
80006208:	c0 a0       	breq	8000621c <disk_ioctl+0x2c>
8000620a:	30 38       	mov	r8,3
8000620c:	f0 0b 18 00 	cp.b	r11,r8
80006210:	c0 b0       	breq	80006226 <disk_ioctl+0x36>
80006212:	30 4c       	mov	r12,4
80006214:	e3 cd 80 80 	ldm	sp++,r7,pc
80006218:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
8000621c:	e0 68 02 00 	mov	r8,512
80006220:	b4 08       	st.h	r10[0x0],r8
80006222:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
80006226:	e0 68 02 00 	mov	r8,512
8000622a:	b4 08       	st.h	r10[0x0],r8
8000622c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
80006230:	f0 1f 00 03 	mcall	8000623c <disk_ioctl+0x4c>
80006234:	8f 0c       	st.w	r7[0x0],r12
80006236:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000623a:	00 00       	add	r0,r0
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	34 94       	mov	r4,73

80006240 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
80006240:	d4 01       	pushm	lr
80006242:	16 9c       	mov	r12,r11
80006244:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
80006246:	5c 59       	castu.b	r9
80006248:	e0 6a 02 00 	mov	r10,512
8000624c:	f0 1f 00 03 	mcall	80006258 <disk_write+0x18>
80006250:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
80006252:	5f 1c       	srne	r12
80006254:	d8 02       	popm	pc
80006256:	00 00       	add	r0,r0
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	34 b4       	mov	r4,75

8000625c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
8000625c:	d4 01       	pushm	lr
8000625e:	16 9c       	mov	r12,r11
80006260:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
80006262:	5c 59       	castu.b	r9
80006264:	e0 6a 02 00 	mov	r10,512
80006268:	f0 1f 00 03 	mcall	80006274 <disk_read+0x18>
8000626c:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
8000626e:	5f 1c       	srne	r12
80006270:	d8 02       	popm	pc
80006272:	00 00       	add	r0,r0
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	34 e4       	mov	r4,78

80006278 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
80006278:	58 0a       	cp.w	r10,0
8000627a:	5e 0c       	reteq	r12
8000627c:	30 08       	mov	r8,0
		*d++ = *s++;
8000627e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006282:	f8 08 0b 09 	st.b	r12[r8],r9
80006286:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
80006288:	14 38       	cp.w	r8,r10
8000628a:	cf a1       	brne	8000627e <mem_cpy+0x6>
8000628c:	5e fc       	retal	r12

8000628e <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
8000628e:	58 0a       	cp.w	r10,0
80006290:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
80006292:	18 cb       	st.b	r12++,r11
80006294:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
80006296:	cf e1       	brne	80006292 <mem_set+0x4>
80006298:	5e fc       	retal	r12

8000629a <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
8000629a:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
8000629c:	19 8c       	ld.ub	r12,r12[0x0]
8000629e:	58 0c       	cp.w	r12,0
800062a0:	5e 0c       	reteq	r12
800062a2:	16 3c       	cp.w	r12,r11
800062a4:	5e 0c       	reteq	r12
800062a6:	2f f8       	sub	r8,-1
800062a8:	11 8c       	ld.ub	r12,r8[0x0]
800062aa:	58 0c       	cp.w	r12,0
800062ac:	5e 0c       	reteq	r12
800062ae:	16 3c       	cp.w	r12,r11
800062b0:	cf b1       	brne	800062a6 <chk_chr+0xc>
	return *str;
}
800062b2:	5e fc       	retal	r12

800062b4 <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
800062b4:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
800062b6:	78 58       	ld.w	r8,r12[0x14]
800062b8:	20 28       	sub	r8,2
800062ba:	10 3b       	cp.w	r11,r8
800062bc:	c0 23       	brcs	800062c0 <clust2sect+0xc>
800062be:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
800062c0:	19 a8       	ld.ub	r8,r12[0x2]
800062c2:	b1 3b       	mul	r11,r8
800062c4:	78 a8       	ld.w	r8,r12[0x28]
800062c6:	f6 08 00 0c 	add	r12,r11,r8
}
800062ca:	5e fc       	retal	r12

800062cc <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
800062cc:	78 9a       	ld.w	r10,r12[0x24]
800062ce:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
800062d0:	78 08       	ld.w	r8,r12[0x0]
800062d2:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800062d4:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
800062d6:	58 0c       	cp.w	r12,0
800062d8:	c1 80       	breq	80006308 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
800062da:	f6 09 16 09 	lsr	r9,r11,0x9
800062de:	f2 08 0d 08 	divu	r8,r9,r8
800062e2:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800062e4:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
800062e6:	18 38       	cp.w	r8,r12
800062e8:	c0 82       	brcc	800062f8 <clmt_clust+0x2c>
800062ea:	c0 b8       	rjmp	80006300 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
800062ec:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
800062ee:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
800062f0:	12 38       	cp.w	r8,r9
800062f2:	e0 8b 00 07 	brhi	80006300 <clmt_clust+0x34>
800062f6:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800062f8:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
800062fa:	58 08       	cp.w	r8,0
800062fc:	cf 81       	brne	800062ec <clmt_clust+0x20>
800062fe:	c0 58       	rjmp	80006308 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006300:	74 0c       	ld.w	r12,r10[0x0]
80006302:	f2 0c 00 0c 	add	r12,r9,r12
80006306:	5e fc       	retal	r12
80006308:	5e fd       	retal	0

8000630a <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
8000630a:	f7 39 00 1b 	ld.ub	r9,r11[27]
8000630e:	f7 38 00 1a 	ld.ub	r8,r11[26]
80006312:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
80006316:	19 8a       	ld.ub	r10,r12[0x0]
80006318:	30 39       	mov	r9,3
8000631a:	f2 0a 18 00 	cp.b	r10,r9
8000631e:	c0 91       	brne	80006330 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
80006320:	f7 3a 00 15 	ld.ub	r10,r11[21]
80006324:	f7 39 00 14 	ld.ub	r9,r11[20]
80006328:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000632c:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
80006330:	5e f8       	retal	r8

80006332 <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
80006332:	f9 6b 00 1a 	st.b	r12[26],r11
80006336:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
8000633a:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
8000633e:	b1 8b       	lsr	r11,0x10
80006340:	f9 6b 00 14 	st.b	r12[20],r11
80006344:	a9 8b       	lsr	r11,0x8
80006346:	f9 6b 00 15 	st.b	r12[21],r11
}
8000634a:	5e fc       	retal	r12

8000634c <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
8000634c:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
8000634e:	78 05       	ld.w	r5,r12[0x0]
80006350:	58 05       	cp.w	r5,0
80006352:	c5 50       	breq	800063fc <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
80006354:	0b 84       	ld.ub	r4,r5[0x0]
80006356:	32 08       	mov	r8,32
80006358:	f0 04 18 00 	cp.b	r4,r8
8000635c:	5f b9       	srhi	r9
8000635e:	33 a8       	mov	r8,58
80006360:	f0 04 18 00 	cp.b	r4,r8
80006364:	5f 18       	srne	r8
80006366:	f3 e8 00 08 	and	r8,r9,r8
8000636a:	c0 41       	brne	80006372 <get_ldnumber+0x26>
8000636c:	08 99       	mov	r9,r4
8000636e:	0a 98       	mov	r8,r5
80006370:	c1 28       	rjmp	80006394 <get_ldnumber+0x48>
80006372:	0a 98       	mov	r8,r5
80006374:	32 06       	mov	r6,32
80006376:	33 a7       	mov	r7,58
80006378:	30 0e       	mov	lr,0
8000637a:	2f f8       	sub	r8,-1
8000637c:	11 89       	ld.ub	r9,r8[0x0]
8000637e:	ec 09 18 00 	cp.b	r9,r6
80006382:	5f bb       	srhi	r11
80006384:	ee 09 18 00 	cp.b	r9,r7
80006388:	5f 1a       	srne	r10
8000638a:	f7 ea 00 0a 	and	r10,r11,r10
8000638e:	fc 0a 18 00 	cp.b	r10,lr
80006392:	cf 41       	brne	8000637a <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
80006394:	33 aa       	mov	r10,58
80006396:	f4 09 18 00 	cp.b	r9,r10
8000639a:	c0 30       	breq	800063a0 <get_ldnumber+0x54>
8000639c:	30 04       	mov	r4,0
8000639e:	c3 08       	rjmp	800063fe <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
800063a0:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
800063a2:	58 94       	cp.w	r4,9
800063a4:	5f 8a       	srls	r10
800063a6:	ea c9 ff ff 	sub	r9,r5,-1
800063aa:	12 38       	cp.w	r8,r9
800063ac:	5f 09       	sreq	r9
800063ae:	f5 e9 00 09 	and	r9,r10,r9
800063b2:	c0 60       	breq	800063be <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
800063b4:	58 04       	cp.w	r4,0
800063b6:	c2 31       	brne	800063fc <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
800063b8:	2f f8       	sub	r8,-1
800063ba:	99 08       	st.w	r12[0x0],r8
800063bc:	c2 18       	rjmp	800063fe <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
800063be:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
800063c0:	49 17       	lddpc	r7,80006404 <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
800063c2:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
800063c4:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
800063c6:	0f 3a       	ld.ub	r10,r7++
800063c8:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
800063ca:	f2 cb 00 61 	sub	r11,r9,97
800063ce:	ec 0b 18 00 	cp.b	r11,r6
800063d2:	e0 8b 00 03 	brhi	800063d8 <get_ldnumber+0x8c>
800063d6:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
800063d8:	fc 0a 18 00 	cp.b	r10,lr
800063dc:	5f 1b       	srne	r11
800063de:	f2 0a 18 00 	cp.b	r10,r9
800063e2:	5f 09       	sreq	r9
800063e4:	f7 e9 00 09 	and	r9,r11,r9
800063e8:	fc 09 18 00 	cp.b	r9,lr
800063ec:	ce d1       	brne	800063c6 <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
800063ee:	10 35       	cp.w	r5,r8
800063f0:	5f 19       	srne	r9
800063f2:	12 4b       	or	r11,r9
800063f4:	c0 41       	brne	800063fc <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
800063f6:	99 08       	st.w	r12[0x0],r8
800063f8:	30 04       	mov	r4,0
800063fa:	c0 28       	rjmp	800063fe <get_ldnumber+0xb2>
800063fc:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
800063fe:	08 9c       	mov	r12,r4
80006400:	d8 22       	popm	r4-r7,pc
80006402:	00 00       	add	r0,r0
80006404:	80 01       	ld.sh	r1,r0[0x0]
80006406:	89 80       	st.w	r4[0x20],r0

80006408 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006408:	eb cd 40 f8 	pushm	r3-r7,lr
8000640c:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
8000640e:	19 c9       	ld.ub	r9,r12[0x4]
80006410:	30 08       	mov	r8,0
80006412:	f0 09 18 00 	cp.b	r9,r8
80006416:	c2 60       	breq	80006462 <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006418:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
8000641a:	f8 c4 ff d0 	sub	r4,r12,-48
8000641e:	30 19       	mov	r9,1
80006420:	0c 9a       	mov	r10,r6
80006422:	08 9b       	mov	r11,r4
80006424:	19 9c       	ld.ub	r12,r12[0x1]
80006426:	f0 1f 00 11 	mcall	80006468 <sync_window+0x60>
8000642a:	c0 30       	breq	80006430 <sync_window+0x28>
8000642c:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
80006430:	30 08       	mov	r8,0
80006432:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
80006434:	6e 89       	ld.w	r9,r7[0x20]
80006436:	ec 09 01 09 	sub	r9,r6,r9
8000643a:	6e 68       	ld.w	r8,r7[0x18]
8000643c:	10 39       	cp.w	r9,r8
8000643e:	c1 22       	brcc	80006462 <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006440:	0f b5       	ld.ub	r5,r7[0x3]
80006442:	58 15       	cp.w	r5,1
80006444:	e0 88 00 0f 	brls	80006462 <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
80006448:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
8000644a:	6e 68       	ld.w	r8,r7[0x18]
8000644c:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
8000644e:	06 99       	mov	r9,r3
80006450:	0c 9a       	mov	r10,r6
80006452:	08 9b       	mov	r11,r4
80006454:	0f 9c       	ld.ub	r12,r7[0x1]
80006456:	f0 1f 00 05 	mcall	80006468 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
8000645a:	20 15       	sub	r5,1
8000645c:	58 15       	cp.w	r5,1
8000645e:	fe 9b ff f6 	brhi	8000644a <sync_window+0x42>
80006462:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006466:	00 00       	add	r0,r0
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	62 40       	ld.w	r0,r1[0x10]

8000646c <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
8000646c:	eb cd 40 e0 	pushm	r5-r7,lr
80006470:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
80006472:	f0 1f 00 31 	mcall	80006534 <sync_fs+0xc8>
80006476:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80006478:	c5 a1       	brne	8000652c <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
8000647a:	0d 89       	ld.ub	r9,r6[0x0]
8000647c:	30 38       	mov	r8,3
8000647e:	f0 09 18 00 	cp.b	r9,r8
80006482:	c4 e1       	brne	8000651e <sync_fs+0xb2>
80006484:	0d d9       	ld.ub	r9,r6[0x5]
80006486:	30 18       	mov	r8,1
80006488:	f0 09 18 00 	cp.b	r9,r8
8000648c:	c4 91       	brne	8000651e <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
8000648e:	ec c5 ff d0 	sub	r5,r6,-48
80006492:	e0 6a 02 00 	mov	r10,512
80006496:	30 0b       	mov	r11,0
80006498:	0a 9c       	mov	r12,r5
8000649a:	f0 1f 00 28 	mcall	80006538 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
8000649e:	35 58       	mov	r8,85
800064a0:	ed 68 02 2e 	st.b	r6[558],r8
800064a4:	3a a8       	mov	r8,-86
800064a6:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
800064aa:	35 28       	mov	r8,82
800064ac:	ed 68 00 30 	st.b	r6[48],r8
800064b0:	ed 68 00 31 	st.b	r6[49],r8
800064b4:	36 18       	mov	r8,97
800064b6:	ed 68 00 32 	st.b	r6[50],r8
800064ba:	34 19       	mov	r9,65
800064bc:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
800064c0:	37 2a       	mov	r10,114
800064c2:	ed 6a 02 14 	st.b	r6[532],r10
800064c6:	ed 6a 02 15 	st.b	r6[533],r10
800064ca:	ed 69 02 16 	st.b	r6[534],r9
800064ce:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
800064d2:	6c 48       	ld.w	r8,r6[0x10]
800064d4:	ed 68 02 18 	st.b	r6[536],r8
800064d8:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800064dc:	ed 69 02 19 	st.b	r6[537],r9
800064e0:	f0 09 16 10 	lsr	r9,r8,0x10
800064e4:	ed 69 02 1a 	st.b	r6[538],r9
800064e8:	b9 88       	lsr	r8,0x18
800064ea:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
800064ee:	6c 38       	ld.w	r8,r6[0xc]
800064f0:	ed 68 02 1c 	st.b	r6[540],r8
800064f4:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800064f8:	ed 69 02 1d 	st.b	r6[541],r9
800064fc:	f0 09 16 10 	lsr	r9,r8,0x10
80006500:	ed 69 02 1e 	st.b	r6[542],r9
80006504:	b9 88       	lsr	r8,0x18
80006506:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
8000650a:	6c 7a       	ld.w	r10,r6[0x1c]
8000650c:	2f fa       	sub	r10,-1
8000650e:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
80006510:	30 19       	mov	r9,1
80006512:	0a 9b       	mov	r11,r5
80006514:	0d 9c       	ld.ub	r12,r6[0x1]
80006516:	f0 1f 00 0a 	mcall	8000653c <sync_fs+0xd0>
			fs->fsi_flag = 0;
8000651a:	30 08       	mov	r8,0
8000651c:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
8000651e:	30 0a       	mov	r10,0
80006520:	14 9b       	mov	r11,r10
80006522:	0d 9c       	ld.ub	r12,r6[0x1]
80006524:	f0 1f 00 07 	mcall	80006540 <sync_fs+0xd4>
80006528:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
8000652c:	0e 9c       	mov	r12,r7
8000652e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006532:	00 00       	add	r0,r0
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	64 08       	ld.w	r8,r2[0x0]
80006538:	80 00       	ld.sh	r0,r0[0x0]
8000653a:	62 8e       	ld.w	lr,r1[0x20]
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	62 40       	ld.w	r0,r1[0x10]
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	61 f0       	ld.w	r0,r0[0x7c]

80006544 <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
80006544:	d4 31       	pushm	r0-r7,lr
80006546:	20 ad       	sub	sp,40
80006548:	50 7c       	stdsp	sp[0x1c],r12
8000654a:	16 97       	mov	r7,r11
8000654c:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
8000654e:	30 18       	mov	r8,1
80006550:	f0 0b 18 00 	cp.b	r11,r8
80006554:	e0 88 00 05 	brls	8000655e <f_mkfs+0x1a>
80006558:	31 3c       	mov	r12,19
8000655a:	e0 8f 03 16 	bral	80006b86 <f_mkfs+0x642>
	vol = get_ldnumber(&path);
8000655e:	fa cc ff e4 	sub	r12,sp,-28
80006562:	f0 1f 01 8e 	mcall	80006b98 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
80006566:	c0 44       	brge	8000656e <f_mkfs+0x2a>
80006568:	30 bc       	mov	r12,11
8000656a:	e0 8f 03 0e 	bral	80006b86 <f_mkfs+0x642>
	fs = FatFs[vol];
8000656e:	fe f8 06 2e 	ld.w	r8,pc[1582]
80006572:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
80006576:	58 05       	cp.w	r5,0
80006578:	c0 41       	brne	80006580 <f_mkfs+0x3c>
8000657a:	30 cc       	mov	r12,12
8000657c:	e0 8f 03 05 	bral	80006b86 <f_mkfs+0x642>
	fs->fs_type = 0;
80006580:	30 08       	mov	r8,0
80006582:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
80006584:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
80006588:	08 9c       	mov	r12,r4
8000658a:	f0 1f 01 86 	mcall	80006ba0 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
8000658e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006592:	c0 40       	breq	8000659a <f_mkfs+0x56>
80006594:	30 3c       	mov	r12,3
80006596:	e0 8f 02 f8 	bral	80006b86 <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
8000659a:	e2 1c 00 04 	andl	r12,0x4,COH
8000659e:	c0 40       	breq	800065a6 <f_mkfs+0x62>
800065a0:	30 ac       	mov	r12,10
800065a2:	e0 8f 02 f2 	bral	80006b86 <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
800065a6:	fa ca ff e0 	sub	r10,sp,-32
800065aa:	30 1b       	mov	r11,1
800065ac:	08 9c       	mov	r12,r4
800065ae:	f0 1f 01 7e 	mcall	80006ba4 <f_mkfs+0x660>
800065b2:	e0 81 02 e7 	brne	80006b80 <f_mkfs+0x63c>
800065b6:	40 89       	lddsp	r9,sp[0x20]
800065b8:	e0 49 00 7f 	cp.w	r9,127
800065bc:	e0 88 02 e2 	brls	80006b80 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
800065c0:	58 07       	cp.w	r7,0
800065c2:	f9 b1 01 00 	movne	r1,0
800065c6:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
800065ca:	02 19       	sub	r9,r1
800065cc:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
800065ce:	ec c8 00 01 	sub	r8,r6,1
800065d2:	0c 68       	and	r8,r6
800065d4:	c0 31       	brne	800065da <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
800065d6:	58 06       	cp.w	r6,0
800065d8:	c1 a1       	brne	8000660c <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
800065da:	e0 6b 4d d3 	mov	r11,19923
800065de:	ea 1b 10 62 	orh	r11,0x1062
800065e2:	f2 0b 06 4a 	mulu.d	r10,r9,r11
800065e6:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
800065ea:	e0 4c 04 00 	cp.w	r12,1024
800065ee:	c0 33       	brcs	800065f4 <f_mkfs+0xb0>
800065f0:	30 08       	mov	r8,0
800065f2:	c0 98       	rjmp	80006604 <f_mkfs+0xc0>
800065f4:	fe fa 05 b4 	ld.w	r10,pc[1460]
800065f8:	2f ea       	sub	r10,-2
800065fa:	30 08       	mov	r8,0
800065fc:	2f f8       	sub	r8,-1
800065fe:	15 2b       	ld.uh	r11,r10++
80006600:	16 3c       	cp.w	r12,r11
80006602:	cf d3       	brcs	800065fc <f_mkfs+0xb8>
		au = cst[i];
80006604:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006608:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
8000660c:	e0 46 01 ff 	cp.w	r6,511
80006610:	e0 88 00 03 	brls	80006616 <f_mkfs+0xd2>
80006614:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
80006616:	58 06       	cp.w	r6,0
80006618:	f9 b6 00 01 	moveq	r6,1
8000661c:	e0 60 00 80 	mov	r0,128
80006620:	00 36       	cp.w	r6,r0
80006622:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
80006626:	f2 00 0d 0a 	divu	r10,r9,r0
8000662a:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
8000662c:	e0 4a 0f f6 	cp.w	r10,4086
80006630:	f9 b3 03 01 	movlo	r3,1
80006634:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
80006638:	e0 4a ff f5 	cp.w	r10,65525
8000663c:	e0 88 00 04 	brls	80006644 <f_mkfs+0x100>
80006640:	30 33       	mov	r3,3
80006642:	c0 58       	rjmp	8000664c <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
80006644:	30 3a       	mov	r10,3
80006646:	f4 03 18 00 	cp.b	r3,r10
8000664a:	c0 a1       	brne	8000665e <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
8000664c:	a3 68       	lsl	r8,0x2
8000664e:	f0 c2 fd f9 	sub	r2,r8,-519
80006652:	a9 92       	lsr	r2,0x9
80006654:	30 0b       	mov	r11,0
80006656:	50 2b       	stdsp	sp[0x8],r11
80006658:	32 0a       	mov	r10,32
8000665a:	50 0a       	stdsp	sp[0x0],r10
8000665c:	c1 68       	rjmp	80006688 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
8000665e:	30 1a       	mov	r10,1
80006660:	f4 03 18 00 	cp.b	r3,r10
80006664:	c0 81       	brne	80006674 <f_mkfs+0x130>
80006666:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000666a:	f0 c2 ff ff 	sub	r2,r8,-1
8000666e:	a1 92       	lsr	r2,0x1
80006670:	2f d2       	sub	r2,-3
80006672:	c0 48       	rjmp	8000667a <f_mkfs+0x136>
80006674:	2f e8       	sub	r8,-2
80006676:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
8000667a:	e4 c2 fe 01 	sub	r2,r2,-511
8000667e:	a9 92       	lsr	r2,0x9
80006680:	32 08       	mov	r8,32
80006682:	50 28       	stdsp	sp[0x8],r8
80006684:	30 1c       	mov	r12,1
80006686:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
80006688:	40 0b       	lddsp	r11,sp[0x0]
8000668a:	02 0b       	add	r11,r1
8000668c:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
8000668e:	40 26       	lddsp	r6,sp[0x8]
80006690:	04 06       	add	r6,r2
80006692:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
80006694:	e0 01 01 08 	sub	r8,r0,r1
80006698:	0c 08       	add	r8,r6
8000669a:	10 39       	cp.w	r9,r8
8000669c:	e0 83 02 74 	brlo	80006b84 <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
800066a0:	fa ca ff dc 	sub	r10,sp,-36
800066a4:	30 3b       	mov	r11,3
800066a6:	08 9c       	mov	r12,r4
800066a8:	f0 1f 01 3f 	mcall	80006ba4 <f_mkfs+0x660>
800066ac:	c0 81       	brne	800066bc <f_mkfs+0x178>
800066ae:	40 98       	lddsp	r8,sp[0x24]
800066b0:	58 08       	cp.w	r8,0
800066b2:	c0 50       	breq	800066bc <f_mkfs+0x178>
800066b4:	e0 48 80 00 	cp.w	r8,32768
800066b8:	e0 88 00 04 	brls	800066c0 <f_mkfs+0x17c>
800066bc:	30 18       	mov	r8,1
800066be:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
800066c0:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
800066c2:	f0 c9 00 01 	sub	r9,r8,1
800066c6:	0c 09       	add	r9,r6
800066c8:	5c 38       	neg	r8
800066ca:	f3 e8 00 08 	and	r8,r9,r8
800066ce:	f0 06 01 06 	sub	r6,r8,r6
800066d2:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
800066d4:	30 38       	mov	r8,3
800066d6:	f0 03 18 00 	cp.b	r3,r8
800066da:	c1 d1       	brne	80006714 <f_mkfs+0x1d0>
		n_rsv += n;
800066dc:	40 0a       	lddsp	r10,sp[0x0]
800066de:	0c 0a       	add	r10,r6
800066e0:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
800066e2:	40 19       	lddsp	r9,sp[0x4]
800066e4:	0c 09       	add	r9,r6
800066e6:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
800066e8:	40 88       	lddsp	r8,sp[0x20]
800066ea:	f0 0a 01 0b 	sub	r11,r8,r10
800066ee:	04 1b       	sub	r11,r2
800066f0:	40 2c       	lddsp	r12,sp[0x8]
800066f2:	18 1b       	sub	r11,r12
800066f4:	f6 00 0d 0a 	divu	r10,r11,r0
800066f8:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
800066fa:	30 39       	mov	r9,3
800066fc:	f2 03 18 00 	cp.b	r3,r9
80006700:	5f 0b       	sreq	r11
80006702:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006704:	e0 4a ff f5 	cp.w	r10,65525
80006708:	5f 89       	srls	r9
8000670a:	f7 e9 00 09 	and	r9,r11,r9
8000670e:	e0 81 02 3b 	brne	80006b84 <f_mkfs+0x640>
80006712:	c1 a8       	rjmp	80006746 <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006714:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006716:	40 88       	lddsp	r8,sp[0x20]
80006718:	40 0a       	lddsp	r10,sp[0x0]
8000671a:	f0 0a 01 0b 	sub	r11,r8,r10
8000671e:	04 1b       	sub	r11,r2
80006720:	40 29       	lddsp	r9,sp[0x8]
80006722:	12 1b       	sub	r11,r9
80006724:	f6 00 0d 0a 	divu	r10,r11,r0
80006728:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
8000672a:	30 29       	mov	r9,2
8000672c:	f2 03 18 00 	cp.b	r3,r9
80006730:	5f 0a       	sreq	r10
80006732:	40 4c       	lddsp	r12,sp[0x10]
80006734:	e0 4c 0f f5 	cp.w	r12,4085
80006738:	5f 89       	srls	r9
8000673a:	f5 e9 00 09 	and	r9,r10,r9
8000673e:	e0 80 02 26 	breq	80006b8a <f_mkfs+0x646>
80006742:	e0 8f 02 21 	bral	80006b84 <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006746:	40 3b       	lddsp	r11,sp[0xc]
80006748:	58 0b       	cp.w	r11,0
8000674a:	c0 30       	breq	80006750 <f_mkfs+0x20c>
8000674c:	30 c6       	mov	r6,12
8000674e:	c1 28       	rjmp	80006772 <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
80006750:	30 19       	mov	r9,1
80006752:	f2 03 18 00 	cp.b	r3,r9
80006756:	c0 71       	brne	80006764 <f_mkfs+0x220>
80006758:	e0 48 ff ff 	cp.w	r8,65535
8000675c:	e0 8b 00 0a 	brhi	80006770 <f_mkfs+0x22c>
80006760:	30 16       	mov	r6,1
80006762:	c0 88       	rjmp	80006772 <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
80006764:	e0 48 ff ff 	cp.w	r8,65535
80006768:	e0 8b 00 04 	brhi	80006770 <f_mkfs+0x22c>
8000676c:	30 46       	mov	r6,4
8000676e:	c0 28       	rjmp	80006772 <f_mkfs+0x22e>
80006770:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
80006772:	58 07       	cp.w	r7,0
80006774:	c0 40       	breq	8000677c <f_mkfs+0x238>
80006776:	e0 67 00 f0 	mov	r7,240
8000677a:	c5 68       	rjmp	80006826 <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
8000677c:	ea ca ff d0 	sub	r10,r5,-48
80006780:	50 5a       	stdsp	sp[0x14],r10
80006782:	e0 6a 02 00 	mov	r10,512
80006786:	30 0b       	mov	r11,0
80006788:	40 5c       	lddsp	r12,sp[0x14]
8000678a:	f0 1f 01 0a 	mcall	80006bb0 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
8000678e:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
80006792:	30 19       	mov	r9,1
80006794:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
80006796:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
80006798:	30 09       	mov	r9,0
8000679a:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
8000679c:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
8000679e:	3f ea       	mov	r10,-2
800067a0:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
800067a2:	40 8b       	lddsp	r11,sp[0x20]
800067a4:	e2 0b 00 0b 	add	r11,r1,r11
800067a8:	e0 6a 56 5b 	mov	r10,22107
800067ac:	ea 1a 05 15 	orh	r10,0x515
800067b0:	f6 0a 06 46 	mulu.d	r6,r11,r10
800067b4:	0e 9c       	mov	r12,r7
800067b6:	f6 0c 01 0a 	sub	r10,r11,r12
800067ba:	a1 9a       	lsr	r10,0x1
800067bc:	f4 0c 00 07 	add	r7,r10,r12
800067c0:	ee 0a 16 0d 	lsr	r10,r7,0xd
800067c4:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
800067c6:	ee 0b 16 0f 	lsr	r11,r7,0xf
800067ca:	16 97       	mov	r7,r11
800067cc:	e8 17 00 3f 	orl	r7,0x3f
800067d0:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
800067d2:	40 9a       	lddsp	r10,sp[0x24]
800067d4:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
800067d6:	33 fa       	mov	r10,63
800067d8:	f1 6a 00 08 	st.b	r8[8],r10
800067dc:	f1 69 00 09 	st.b	r8[9],r9
800067e0:	f1 69 00 0a 	st.b	r8[10],r9
800067e4:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
800067e8:	40 89       	lddsp	r9,sp[0x20]
800067ea:	f1 69 00 0c 	st.b	r8[12],r9
800067ee:	fb 39 00 22 	ld.ub	r9,sp[34]
800067f2:	f1 69 00 0d 	st.b	r8[13],r9
800067f6:	fb 19 00 20 	ld.uh	r9,sp[32]
800067fa:	f1 69 00 0e 	st.b	r8[14],r9
800067fe:	fb 39 00 20 	ld.ub	r9,sp[32]
80006802:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006806:	35 58       	mov	r8,85
80006808:	eb 68 02 2e 	st.b	r5[558],r8
8000680c:	3a a8       	mov	r8,-86
8000680e:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006812:	30 19       	mov	r9,1
80006814:	30 0a       	mov	r10,0
80006816:	40 5b       	lddsp	r11,sp[0x14]
80006818:	08 9c       	mov	r12,r4
8000681a:	f0 1f 00 e7 	mcall	80006bb4 <f_mkfs+0x670>
8000681e:	e0 81 01 b1 	brne	80006b80 <f_mkfs+0x63c>
80006822:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006826:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
8000682a:	e0 6a 02 00 	mov	r10,512
8000682e:	30 0b       	mov	r11,0
80006830:	0c 9c       	mov	r12,r6
80006832:	f0 1f 00 e0 	mcall	80006bb0 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006836:	30 ba       	mov	r10,11
80006838:	fe fb 03 80 	ld.w	r11,pc[896]
8000683c:	0c 9c       	mov	r12,r6
8000683e:	f0 1f 00 e0 	mcall	80006bbc <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006842:	ea ca ff c5 	sub	r10,r5,-59
80006846:	50 5a       	stdsp	sp[0x14],r10
80006848:	30 08       	mov	r8,0
8000684a:	b4 88       	st.b	r10[0x0],r8
8000684c:	30 28       	mov	r8,2
8000684e:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
80006852:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
80006856:	40 09       	lddsp	r9,sp[0x0]
80006858:	ed 69 00 0e 	st.b	r6[14],r9
8000685c:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
80006860:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
80006864:	30 18       	mov	r8,1
80006866:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
8000686a:	e0 68 02 00 	mov	r8,512
8000686e:	40 3c       	lddsp	r12,sp[0xc]
80006870:	58 0c       	cp.w	r12,0
80006872:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
80006876:	ed 68 00 11 	st.b	r6[17],r8
8000687a:	58 08       	cp.w	r8,0
8000687c:	f9 b8 01 02 	movne	r8,2
80006880:	f9 b8 00 00 	moveq	r8,0
80006884:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
80006888:	40 88       	lddsp	r8,sp[0x20]
8000688a:	e0 48 ff ff 	cp.w	r8,65535
8000688e:	e0 8b 00 09 	brhi	800068a0 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
80006892:	ed 68 00 13 	st.b	r6[19],r8
80006896:	fb 38 00 22 	ld.ub	r8,sp[34]
8000689a:	ed 68 00 14 	st.b	r6[20],r8
8000689e:	c0 f8       	rjmp	800068bc <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
800068a0:	ed 68 00 20 	st.b	r6[32],r8
800068a4:	fb 38 00 22 	ld.ub	r8,sp[34]
800068a8:	ed 68 00 21 	st.b	r6[33],r8
800068ac:	fb 18 00 20 	ld.uh	r8,sp[32]
800068b0:	ed 68 00 22 	st.b	r6[34],r8
800068b4:	fb 38 00 20 	ld.ub	r8,sp[32]
800068b8:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
800068bc:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
800068c0:	33 f8       	mov	r8,63
800068c2:	ed 68 00 18 	st.b	r6[24],r8
800068c6:	30 08       	mov	r8,0
800068c8:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
800068cc:	3f f9       	mov	r9,-1
800068ce:	ed 69 00 1a 	st.b	r6[26],r9
800068d2:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
800068d6:	ed 61 00 1c 	st.b	r6[28],r1
800068da:	30 08       	mov	r8,0
800068dc:	ed 68 00 1d 	st.b	r6[29],r8
800068e0:	e2 08 16 10 	lsr	r8,r1,0x10
800068e4:	ed 68 00 1e 	st.b	r6[30],r8
800068e8:	e2 08 16 18 	lsr	r8,r1,0x18
800068ec:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
800068f0:	f0 1f 00 b4 	mcall	80006bc0 <f_mkfs+0x67c>
800068f4:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
800068f6:	40 3a       	lddsp	r10,sp[0xc]
800068f8:	58 0a       	cp.w	r10,0
800068fa:	c3 f0       	breq	80006978 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
800068fc:	ed 6c 00 43 	st.b	r6[67],r12
80006900:	fb 38 00 26 	ld.ub	r8,sp[38]
80006904:	ed 68 00 44 	st.b	r6[68],r8
80006908:	fb 18 00 24 	ld.uh	r8,sp[36]
8000690c:	ed 68 00 45 	st.b	r6[69],r8
80006910:	fb 38 00 24 	ld.ub	r8,sp[36]
80006914:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006918:	ed 62 00 24 	st.b	r6[36],r2
8000691c:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006920:	ed 68 00 25 	st.b	r6[37],r8
80006924:	e4 08 16 10 	lsr	r8,r2,0x10
80006928:	ed 68 00 26 	st.b	r6[38],r8
8000692c:	e4 08 16 18 	lsr	r8,r2,0x18
80006930:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
80006934:	30 28       	mov	r8,2
80006936:	ed 68 00 2c 	st.b	r6[44],r8
8000693a:	30 08       	mov	r8,0
8000693c:	ed 68 00 2d 	st.b	r6[45],r8
80006940:	ed 68 00 2e 	st.b	r6[46],r8
80006944:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80006948:	30 19       	mov	r9,1
8000694a:	ed 69 00 30 	st.b	r6[48],r9
8000694e:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
80006952:	30 69       	mov	r9,6
80006954:	ed 69 00 32 	st.b	r6[50],r9
80006958:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
8000695c:	38 08       	mov	r8,-128
8000695e:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
80006962:	32 98       	mov	r8,41
80006964:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
80006968:	31 3a       	mov	r10,19
8000696a:	fe fb 02 5a 	ld.w	r11,pc[602]
8000696e:	ec cc ff b9 	sub	r12,r6,-71
80006972:	f0 1f 00 93 	mcall	80006bbc <f_mkfs+0x678>
80006976:	c2 28       	rjmp	800069ba <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
80006978:	ed 6c 00 27 	st.b	r6[39],r12
8000697c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006980:	ed 68 00 28 	st.b	r6[40],r8
80006984:	fb 18 00 24 	ld.uh	r8,sp[36]
80006988:	ed 68 00 29 	st.b	r6[41],r8
8000698c:	fb 38 00 24 	ld.ub	r8,sp[36]
80006990:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
80006994:	ed 62 00 16 	st.b	r6[22],r2
80006998:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
8000699c:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
800069a0:	38 08       	mov	r8,-128
800069a2:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
800069a6:	32 98       	mov	r8,41
800069a8:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
800069ac:	31 3a       	mov	r10,19
800069ae:	fe fb 02 1a 	ld.w	r11,pc[538]
800069b2:	ec cc ff d5 	sub	r12,r6,-43
800069b6:	f0 1f 00 82 	mcall	80006bbc <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
800069ba:	ec c9 fe 02 	sub	r9,r6,-510
800069be:	50 69       	stdsp	sp[0x18],r9
800069c0:	35 58       	mov	r8,85
800069c2:	b2 88       	st.b	r9[0x0],r8
800069c4:	ec c8 fe 01 	sub	r8,r6,-511
800069c8:	50 08       	stdsp	sp[0x0],r8
800069ca:	3a a8       	mov	r8,-86
800069cc:	40 0c       	lddsp	r12,sp[0x0]
800069ce:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
800069d0:	30 19       	mov	r9,1
800069d2:	02 9a       	mov	r10,r1
800069d4:	0c 9b       	mov	r11,r6
800069d6:	08 9c       	mov	r12,r4
800069d8:	f0 1f 00 77 	mcall	80006bb4 <f_mkfs+0x670>
800069dc:	e0 81 00 d2 	brne	80006b80 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
800069e0:	40 3b       	lddsp	r11,sp[0xc]
800069e2:	58 0b       	cp.w	r11,0
800069e4:	c0 80       	breq	800069f4 <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
800069e6:	30 19       	mov	r9,1
800069e8:	e2 ca ff fa 	sub	r10,r1,-6
800069ec:	0c 9b       	mov	r11,r6
800069ee:	08 9c       	mov	r12,r4
800069f0:	f0 1f 00 71 	mcall	80006bb4 <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
800069f4:	e0 6a 02 00 	mov	r10,512
800069f8:	30 0b       	mov	r11,0
800069fa:	0c 9c       	mov	r12,r6
800069fc:	f0 1f 00 6d 	mcall	80006bb0 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006a00:	30 38       	mov	r8,3
80006a02:	f0 03 18 00 	cp.b	r3,r8
80006a06:	c1 d0       	breq	80006a40 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006a08:	30 18       	mov	r8,1
80006a0a:	fe 7a ff 00 	mov	r10,-256
80006a0e:	e0 69 ff 00 	mov	r9,65280
80006a12:	ea 19 00 ff 	orh	r9,0xff
80006a16:	e6 08 18 00 	cp.b	r8,r3
80006a1a:	f2 08 17 00 	moveq	r8,r9
80006a1e:	f4 08 17 10 	movne	r8,r10
80006a22:	f1 e7 10 07 	or	r7,r8,r7
80006a26:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006a28:	eb 67 00 30 	st.b	r5[48],r7
80006a2c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006a30:	ac 98       	st.b	r6[0x1],r8
80006a32:	fb 18 00 24 	ld.uh	r8,sp[36]
80006a36:	ac a8       	st.b	r6[0x2],r8
80006a38:	fb 38 00 24 	ld.ub	r8,sp[36]
80006a3c:	ac b8       	st.b	r6[0x3],r8
80006a3e:	c1 f8       	rjmp	80006a7c <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006a40:	ea 17 ff ff 	orh	r7,0xffff
80006a44:	e8 17 ff 00 	orl	r7,0xff00
80006a48:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80006a4a:	eb 67 00 30 	st.b	r5[48],r7
80006a4e:	fb 38 00 26 	ld.ub	r8,sp[38]
80006a52:	ac 98       	st.b	r6[0x1],r8
80006a54:	fb 18 00 24 	ld.uh	r8,sp[36]
80006a58:	ac a8       	st.b	r6[0x2],r8
80006a5a:	fb 38 00 24 	ld.ub	r8,sp[36]
80006a5e:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006a60:	3f f8       	mov	r8,-1
80006a62:	ac c8       	st.b	r6[0x4],r8
80006a64:	ac d8       	st.b	r6[0x5],r8
80006a66:	ac e8       	st.b	r6[0x6],r8
80006a68:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
80006a6a:	ed 68 00 08 	st.b	r6[8],r8
80006a6e:	ed 68 00 09 	st.b	r6[9],r8
80006a72:	ed 68 00 0a 	st.b	r6[10],r8
80006a76:	30 f8       	mov	r8,15
80006a78:	40 5a       	lddsp	r10,sp[0x14]
80006a7a:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006a7c:	30 19       	mov	r9,1
80006a7e:	40 1a       	lddsp	r10,sp[0x4]
80006a80:	0c 9b       	mov	r11,r6
80006a82:	08 9c       	mov	r12,r4
80006a84:	f0 1f 00 4c 	mcall	80006bb4 <f_mkfs+0x670>
80006a88:	c7 c1       	brne	80006b80 <f_mkfs+0x63c>
80006a8a:	40 13       	lddsp	r3,sp[0x4]
80006a8c:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
80006a8e:	e0 6a 02 00 	mov	r10,512
80006a92:	30 0b       	mov	r11,0
80006a94:	0c 9c       	mov	r12,r6
80006a96:	f0 1f 00 47 	mcall	80006bb0 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006a9a:	30 18       	mov	r8,1
80006a9c:	50 98       	stdsp	sp[0x24],r8
80006a9e:	10 32       	cp.w	r2,r8
80006aa0:	e0 88 00 11 	brls	80006ac2 <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006aa4:	10 97       	mov	r7,r8
80006aa6:	0e 99       	mov	r9,r7
80006aa8:	06 9a       	mov	r10,r3
80006aaa:	0c 9b       	mov	r11,r6
80006aac:	08 9c       	mov	r12,r4
80006aae:	f0 1f 00 42 	mcall	80006bb4 <f_mkfs+0x670>
80006ab2:	c6 71       	brne	80006b80 <f_mkfs+0x63c>
80006ab4:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006ab6:	40 98       	lddsp	r8,sp[0x24]
80006ab8:	2f f8       	sub	r8,-1
80006aba:	50 98       	stdsp	sp[0x24],r8
80006abc:	10 32       	cp.w	r2,r8
80006abe:	fe 9b ff f4 	brhi	80006aa6 <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
80006ac2:	40 29       	lddsp	r9,sp[0x8]
80006ac4:	40 38       	lddsp	r8,sp[0xc]
80006ac6:	58 08       	cp.w	r8,0
80006ac8:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006acc:	30 12       	mov	r2,1
80006ace:	06 9a       	mov	r10,r3
80006ad0:	f4 c7 ff ff 	sub	r7,r10,-1
80006ad4:	04 99       	mov	r9,r2
80006ad6:	0c 9b       	mov	r11,r6
80006ad8:	08 9c       	mov	r12,r4
80006ada:	f0 1f 00 37 	mcall	80006bb4 <f_mkfs+0x670>
80006ade:	c5 11       	brne	80006b80 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006ae0:	20 10       	sub	r0,1
80006ae2:	c0 30       	breq	80006ae8 <f_mkfs+0x5a4>
80006ae4:	0e 9a       	mov	r10,r7
80006ae6:	cf 5b       	rjmp	80006ad0 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006ae8:	40 3c       	lddsp	r12,sp[0xc]
80006aea:	58 0c       	cp.w	r12,0
80006aec:	c4 30       	breq	80006b72 <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006aee:	35 28       	mov	r8,82
80006af0:	eb 68 00 30 	st.b	r5[48],r8
80006af4:	ac 98       	st.b	r6[0x1],r8
80006af6:	36 18       	mov	r8,97
80006af8:	ac a8       	st.b	r6[0x2],r8
80006afa:	34 19       	mov	r9,65
80006afc:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006afe:	37 2a       	mov	r10,114
80006b00:	ed 6a 01 e4 	st.b	r6[484],r10
80006b04:	ed 6a 01 e5 	st.b	r6[485],r10
80006b08:	ed 69 01 e6 	st.b	r6[486],r9
80006b0c:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006b10:	40 48       	lddsp	r8,sp[0x10]
80006b12:	20 18       	sub	r8,1
80006b14:	ed 68 01 e8 	st.b	r6[488],r8
80006b18:	40 48       	lddsp	r8,sp[0x10]
80006b1a:	20 18       	sub	r8,1
80006b1c:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006b20:	ed 68 01 e9 	st.b	r6[489],r8
80006b24:	40 48       	lddsp	r8,sp[0x10]
80006b26:	20 18       	sub	r8,1
80006b28:	f0 09 16 10 	lsr	r9,r8,0x10
80006b2c:	ed 69 01 ea 	st.b	r6[490],r9
80006b30:	b9 88       	lsr	r8,0x18
80006b32:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006b36:	30 28       	mov	r8,2
80006b38:	ed 68 01 ec 	st.b	r6[492],r8
80006b3c:	30 08       	mov	r8,0
80006b3e:	ed 68 01 ed 	st.b	r6[493],r8
80006b42:	ed 68 01 ee 	st.b	r6[494],r8
80006b46:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006b4a:	35 58       	mov	r8,85
80006b4c:	40 6b       	lddsp	r11,sp[0x18]
80006b4e:	b6 88       	st.b	r11[0x0],r8
80006b50:	3a a8       	mov	r8,-86
80006b52:	40 0a       	lddsp	r10,sp[0x0]
80006b54:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006b56:	30 19       	mov	r9,1
80006b58:	e2 09 00 0a 	add	r10,r1,r9
80006b5c:	0c 9b       	mov	r11,r6
80006b5e:	08 9c       	mov	r12,r4
80006b60:	f0 1f 00 15 	mcall	80006bb4 <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006b64:	30 19       	mov	r9,1
80006b66:	e2 ca ff f9 	sub	r10,r1,-7
80006b6a:	0c 9b       	mov	r11,r6
80006b6c:	08 9c       	mov	r12,r4
80006b6e:	f0 1f 00 12 	mcall	80006bb4 <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006b72:	30 0a       	mov	r10,0
80006b74:	14 9b       	mov	r11,r10
80006b76:	08 9c       	mov	r12,r4
80006b78:	f0 1f 00 0b 	mcall	80006ba4 <f_mkfs+0x660>
80006b7c:	5f 1c       	srne	r12
80006b7e:	c0 48       	rjmp	80006b86 <f_mkfs+0x642>
80006b80:	30 1c       	mov	r12,1
80006b82:	c0 28       	rjmp	80006b86 <f_mkfs+0x642>
80006b84:	30 ec       	mov	r12,14
}
80006b86:	2f 6d       	sub	sp,-40
80006b88:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006b8a:	30 39       	mov	r9,3
80006b8c:	f2 03 18 00 	cp.b	r3,r9
80006b90:	5f 09       	sreq	r9
80006b92:	50 39       	stdsp	sp[0xc],r9
80006b94:	fe 9f fd d9 	bral	80006746 <f_mkfs+0x202>
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	63 4c       	ld.w	r12,r1[0x50]
80006b9c:	00 00       	add	r0,r0
80006b9e:	11 48       	ld.w	r8,--r8
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	61 b2       	ld.w	r2,r0[0x6c]
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	61 f0       	ld.w	r0,r0[0x7c]
80006ba8:	80 01       	ld.sh	r1,r0[0x0]
80006baa:	89 6a       	st.w	r4[0x18],r10
80006bac:	80 01       	ld.sh	r1,r0[0x0]
80006bae:	89 54       	st.w	r4[0x14],r4
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	62 8e       	ld.w	lr,r1[0x20]
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	62 40       	ld.w	r0,r1[0x10]
80006bb8:	80 01       	ld.sh	r1,r0[0x0]
80006bba:	89 84       	st.w	r4[0x20],r4
80006bbc:	80 00       	ld.sh	r0,r0[0x0]
80006bbe:	62 78       	ld.w	r8,r1[0x1c]
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	61 b4       	ld.w	r4,r0[0x6c]
80006bc4:	80 01       	ld.sh	r1,r0[0x0]
80006bc6:	89 90       	st.w	r4[0x24],r0
80006bc8:	80 01       	ld.sh	r1,r0[0x0]
80006bca:	89 a4       	st.w	r4[0x28],r4

80006bcc <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006bcc:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006bce:	58 0c       	cp.w	r12,0
80006bd0:	c1 40       	breq	80006bf8 <validate+0x2c>
80006bd2:	78 08       	ld.w	r8,r12[0x0]
80006bd4:	58 08       	cp.w	r8,0
80006bd6:	c1 10       	breq	80006bf8 <validate+0x2c>
80006bd8:	11 8a       	ld.ub	r10,r8[0x0]
80006bda:	30 09       	mov	r9,0
80006bdc:	f2 0a 18 00 	cp.b	r10,r9
80006be0:	c0 c0       	breq	80006bf8 <validate+0x2c>
80006be2:	90 3a       	ld.sh	r10,r8[0x6]
80006be4:	98 29       	ld.sh	r9,r12[0x4]
80006be6:	f2 0a 19 00 	cp.h	r10,r9
80006bea:	c0 71       	brne	80006bf8 <validate+0x2c>
80006bec:	11 9c       	ld.ub	r12,r8[0x1]
80006bee:	f0 1f 00 04 	mcall	80006bfc <validate+0x30>
80006bf2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006bf6:	c0 20       	breq	80006bfa <validate+0x2e>
80006bf8:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006bfa:	d8 02       	popm	pc
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	61 b0       	ld.w	r0,r0[0x6c]

80006c00 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006c00:	eb cd 40 e0 	pushm	r5-r7,lr
80006c04:	18 97       	mov	r7,r12
80006c06:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006c08:	78 b8       	ld.w	r8,r12[0x2c]
80006c0a:	16 38       	cp.w	r8,r11
80006c0c:	c0 31       	brne	80006c12 <move_window+0x12>
80006c0e:	30 06       	mov	r6,0
80006c10:	c1 18       	rjmp	80006c32 <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006c12:	f0 1f 00 0a 	mcall	80006c38 <move_window+0x38>
80006c16:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006c18:	c0 d1       	brne	80006c32 <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006c1a:	30 19       	mov	r9,1
80006c1c:	0a 9a       	mov	r10,r5
80006c1e:	ee cb ff d0 	sub	r11,r7,-48
80006c22:	0f 9c       	ld.ub	r12,r7[0x1]
80006c24:	f0 1f 00 06 	mcall	80006c3c <move_window+0x3c>
80006c28:	f9 b6 01 01 	movne	r6,1
80006c2c:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006c30:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006c32:	0c 9c       	mov	r12,r6
80006c34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006c38:	80 00       	ld.sh	r0,r0[0x0]
80006c3a:	64 08       	ld.w	r8,r2[0x0]
80006c3c:	80 00       	ld.sh	r0,r0[0x0]
80006c3e:	62 5c       	ld.w	r12,r1[0x14]

80006c40 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006c40:	eb cd 40 80 	pushm	r7,lr
80006c44:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006c46:	30 08       	mov	r8,0
80006c48:	b8 c8       	st.b	r12[0x4],r8
80006c4a:	3f f8       	mov	r8,-1
80006c4c:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006c4e:	f0 1f 00 23 	mcall	80006cd8 <check_fs+0x98>
80006c52:	c0 40       	breq	80006c5a <check_fs+0x1a>
80006c54:	30 3c       	mov	r12,3
80006c56:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006c5a:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006c5e:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006c62:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006c66:	fe 78 aa 55 	mov	r8,-21931
80006c6a:	f0 09 19 00 	cp.h	r9,r8
80006c6e:	c0 40       	breq	80006c76 <check_fs+0x36>
80006c70:	30 2c       	mov	r12,2
80006c72:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
80006c76:	ef 39 00 69 	ld.ub	r9,r7[105]
80006c7a:	ef 38 00 68 	ld.ub	r8,r7[104]
80006c7e:	b1 68       	lsl	r8,0x10
80006c80:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006c84:	ef 39 00 66 	ld.ub	r9,r7[102]
80006c88:	12 48       	or	r8,r9
80006c8a:	ef 39 00 67 	ld.ub	r9,r7[103]
80006c8e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006c92:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006c96:	e0 69 41 46 	mov	r9,16710
80006c9a:	ea 19 00 54 	orh	r9,0x54
80006c9e:	12 38       	cp.w	r8,r9
80006ca0:	c0 31       	brne	80006ca6 <check_fs+0x66>
80006ca2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006ca6:	ef 39 00 85 	ld.ub	r9,r7[133]
80006caa:	ef 38 00 84 	ld.ub	r8,r7[132]
80006cae:	b1 68       	lsl	r8,0x10
80006cb0:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006cb4:	ef 39 00 82 	ld.ub	r9,r7[130]
80006cb8:	12 48       	or	r8,r9
80006cba:	ef 39 00 83 	ld.ub	r9,r7[131]
80006cbe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006cc2:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006cc6:	e0 69 41 46 	mov	r9,16710
80006cca:	ea 19 00 54 	orh	r9,0x54
80006cce:	12 38       	cp.w	r8,r9
80006cd0:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
80006cd2:	e3 cd 80 80 	ldm	sp++,r7,pc
80006cd6:	00 00       	add	r0,r0
80006cd8:	80 00       	ld.sh	r0,r0[0x0]
80006cda:	6c 00       	ld.w	r0,r6[0x0]

80006cdc <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80006cdc:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80006ce0:	20 4d       	sub	sp,16
80006ce2:	18 95       	mov	r5,r12
80006ce4:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
80006ce6:	30 08       	mov	r8,0
80006ce8:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80006cea:	16 9c       	mov	r12,r11
80006cec:	f0 1f 00 de 	mcall	80007064 <find_volume+0x388>
80006cf0:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
80006cf2:	c0 34       	brge	80006cf8 <find_volume+0x1c>
80006cf4:	30 bc       	mov	r12,11
80006cf6:	ca a9       	rjmp	8000704a <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80006cf8:	fe f8 03 70 	ld.w	r8,pc[880]
80006cfc:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80006d00:	58 07       	cp.w	r7,0
80006d02:	c0 31       	brne	80006d08 <find_volume+0x2c>
80006d04:	30 cc       	mov	r12,12
80006d06:	ca 29       	rjmp	8000704a <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80006d08:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
80006d0a:	0f 89       	ld.ub	r9,r7[0x0]
80006d0c:	30 08       	mov	r8,0
80006d0e:	f0 09 18 00 	cp.b	r9,r8
80006d12:	c0 f0       	breq	80006d30 <find_volume+0x54>
		stat = disk_status(fs->drv);
80006d14:	0f 9c       	ld.ub	r12,r7[0x1]
80006d16:	f0 1f 00 d6 	mcall	8000706c <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
80006d1a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006d1e:	c0 91       	brne	80006d30 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80006d20:	58 04       	cp.w	r4,0
80006d22:	e0 80 01 91 	breq	80007044 <find_volume+0x368>
80006d26:	e2 1c 00 04 	andl	r12,0x4,COH
80006d2a:	e0 81 01 8b 	brne	80007040 <find_volume+0x364>
80006d2e:	c8 b9       	rjmp	80007044 <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80006d30:	30 08       	mov	r8,0
80006d32:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
80006d34:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80006d38:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
80006d3a:	f0 1f 00 ce 	mcall	80007070 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
80006d3e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006d42:	c0 30       	breq	80006d48 <find_volume+0x6c>
80006d44:	30 3c       	mov	r12,3
80006d46:	c8 29       	rjmp	8000704a <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80006d48:	58 04       	cp.w	r4,0
80006d4a:	c0 50       	breq	80006d54 <find_volume+0x78>
80006d4c:	e2 1c 00 04 	andl	r12,0x4,COH
80006d50:	e0 81 01 78 	brne	80007040 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
80006d54:	30 0b       	mov	r11,0
80006d56:	0e 9c       	mov	r12,r7
80006d58:	f0 1f 00 c7 	mcall	80007074 <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
80006d5c:	30 18       	mov	r8,1
80006d5e:	f0 0c 18 00 	cp.b	r12,r8
80006d62:	c0 30       	breq	80006d68 <find_volume+0x8c>
80006d64:	30 05       	mov	r5,0
80006d66:	c3 48       	rjmp	80006dce <find_volume+0xf2>
80006d68:	1a 96       	mov	r6,sp
80006d6a:	1a 9a       	mov	r10,sp
80006d6c:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006d70:	30 0c       	mov	r12,0
80006d72:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
80006d74:	f0 c9 ff d0 	sub	r9,r8,-48
80006d78:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006d7c:	13 cb       	ld.ub	r11,r9[0x4]
80006d7e:	f8 0b 18 00 	cp.b	r11,r12
80006d82:	c0 31       	brne	80006d88 <find_volume+0xac>
80006d84:	08 99       	mov	r9,r4
80006d86:	c0 f8       	rjmp	80006da4 <find_volume+0xc8>
80006d88:	f3 35 00 0b 	ld.ub	r5,r9[11]
80006d8c:	f3 3b 00 0a 	ld.ub	r11,r9[10]
80006d90:	b1 6b       	lsl	r11,0x10
80006d92:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
80006d96:	f3 35 00 08 	ld.ub	r5,r9[8]
80006d9a:	0a 4b       	or	r11,r5
80006d9c:	f3 39 00 09 	ld.ub	r9,r9[9]
80006da0:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80006da4:	14 a9       	st.w	r10++,r9
80006da6:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
80006da8:	e0 48 01 fe 	cp.w	r8,510
80006dac:	ce 41       	brne	80006d74 <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
80006dae:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006db2:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
80006db4:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006db6:	58 05       	cp.w	r5,0
80006db8:	c0 31       	brne	80006dbe <find_volume+0xe2>
80006dba:	06 9c       	mov	r12,r3
80006dbc:	c0 68       	rjmp	80006dc8 <find_volume+0xec>
80006dbe:	0a 9b       	mov	r11,r5
80006dc0:	0e 9c       	mov	r12,r7
80006dc2:	f0 1f 00 ad 	mcall	80007074 <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
80006dc6:	c0 d0       	breq	80006de0 <find_volume+0x104>
80006dc8:	2f c6       	sub	r6,-4
80006dca:	08 36       	cp.w	r6,r4
80006dcc:	cf 41       	brne	80006db4 <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80006dce:	30 38       	mov	r8,3
80006dd0:	f0 0c 18 00 	cp.b	r12,r8
80006dd4:	c0 31       	brne	80006dda <find_volume+0xfe>
80006dd6:	30 1c       	mov	r12,1
80006dd8:	c3 99       	rjmp	8000704a <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
80006dda:	58 0c       	cp.w	r12,0
80006ddc:	e0 81 01 36 	brne	80007048 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80006de0:	ef 39 00 3c 	ld.ub	r9,r7[60]
80006de4:	ef 38 00 3b 	ld.ub	r8,r7[59]
80006de8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006dec:	e0 68 02 00 	mov	r8,512
80006df0:	f0 09 19 00 	cp.h	r9,r8
80006df4:	e0 81 01 2a 	brne	80007048 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
80006df8:	ef 39 00 47 	ld.ub	r9,r7[71]
80006dfc:	ef 38 00 46 	ld.ub	r8,r7[70]
80006e00:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
80006e04:	c1 01       	brne	80006e24 <find_volume+0x148>
80006e06:	ef 39 00 57 	ld.ub	r9,r7[87]
80006e0a:	ef 38 00 56 	ld.ub	r8,r7[86]
80006e0e:	b1 68       	lsl	r8,0x10
80006e10:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006e14:	ef 38 00 54 	ld.ub	r8,r7[84]
80006e18:	f3 e8 10 08 	or	r8,r9,r8
80006e1c:	ef 39 00 55 	ld.ub	r9,r7[85]
80006e20:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
80006e24:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
80006e26:	ef 39 00 40 	ld.ub	r9,r7[64]
80006e2a:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
80006e2c:	f2 cb 00 01 	sub	r11,r9,1
80006e30:	30 1a       	mov	r10,1
80006e32:	f4 0b 18 00 	cp.b	r11,r10
80006e36:	e0 8b 01 09 	brhi	80007048 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
80006e3a:	ef 3a 00 3d 	ld.ub	r10,r7[61]
80006e3e:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80006e40:	58 0a       	cp.w	r10,0
80006e42:	e0 80 01 03 	breq	80007048 <find_volume+0x36c>
80006e46:	f4 cb 00 01 	sub	r11,r10,1
80006e4a:	14 6b       	and	r11,r10
80006e4c:	e0 81 00 fe 	brne	80007048 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80006e50:	ef 3c 00 42 	ld.ub	r12,r7[66]
80006e54:	ef 3b 00 41 	ld.ub	r11,r7[65]
80006e58:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
80006e5c:	5c 8b       	casts.h	r11
80006e5e:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
80006e60:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
80006e64:	e0 81 00 f2 	brne	80007048 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
80006e68:	ef 36 00 44 	ld.ub	r6,r7[68]
80006e6c:	ef 3c 00 43 	ld.ub	r12,r7[67]
80006e70:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
80006e74:	c1 01       	brne	80006e94 <find_volume+0x1b8>
80006e76:	ef 36 00 53 	ld.ub	r6,r7[83]
80006e7a:	ef 3c 00 52 	ld.ub	r12,r7[82]
80006e7e:	b1 6c       	lsl	r12,0x10
80006e80:	f9 e6 11 86 	or	r6,r12,r6<<0x18
80006e84:	ef 3c 00 50 	ld.ub	r12,r7[80]
80006e88:	ed ec 10 0c 	or	r12,r6,r12
80006e8c:	ef 36 00 51 	ld.ub	r6,r7[81]
80006e90:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
80006e94:	ef 34 00 3f 	ld.ub	r4,r7[63]
80006e98:	ef 36 00 3e 	ld.ub	r6,r7[62]
80006e9c:	ed e4 10 86 	or	r6,r6,r4<<0x8
80006ea0:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
80006ea2:	e0 80 00 d3 	breq	80007048 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
80006ea6:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
80006ea8:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
80006eac:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
80006eb0:	06 04       	add	r4,r3
80006eb2:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
80006eb4:	08 3c       	cp.w	r12,r4
80006eb6:	e0 83 00 c9 	brlo	80007048 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
80006eba:	f8 04 01 01 	sub	r1,r12,r4
80006ebe:	e2 0a 0d 00 	divu	r0,r1,r10
80006ec2:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
80006ec4:	58 00       	cp.w	r0,0
80006ec6:	e0 80 00 c1 	breq	80007048 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
80006eca:	e0 40 0f f6 	cp.w	r0,4086
80006ece:	f9 b6 03 01 	movlo	r6,1
80006ed2:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
80006ed6:	e0 40 ff f5 	cp.w	r0,65525
80006eda:	e0 8b 00 bb 	brhi	80007050 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80006ede:	2f e9       	sub	r9,-2
80006ee0:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80006ee2:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80006ee4:	ea 03 00 03 	add	r3,r5,r3
80006ee8:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80006eea:	0a 04       	add	r4,r5
80006eec:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80006eee:	30 3a       	mov	r10,3
80006ef0:	f4 06 18 00 	cp.b	r6,r10
80006ef4:	c1 61       	brne	80006f20 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
80006ef6:	58 0b       	cp.w	r11,0
80006ef8:	e0 81 00 a8 	brne	80007048 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80006efc:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80006f00:	ef 38 00 5e 	ld.ub	r8,r7[94]
80006f04:	b1 68       	lsl	r8,0x10
80006f06:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80006f0a:	ef 38 00 5c 	ld.ub	r8,r7[92]
80006f0e:	f5 e8 10 08 	or	r8,r10,r8
80006f12:	ef 3a 00 5d 	ld.ub	r10,r7[93]
80006f16:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80006f1a:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
80006f1c:	a3 69       	lsl	r9,0x2
80006f1e:	c1 38       	rjmp	80006f44 <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80006f20:	58 0b       	cp.w	r11,0
80006f22:	e0 80 00 93 	breq	80007048 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
80006f26:	06 08       	add	r8,r3
80006f28:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
80006f2a:	30 28       	mov	r8,2
80006f2c:	f0 06 18 00 	cp.b	r6,r8
80006f30:	c0 31       	brne	80006f36 <find_volume+0x25a>
80006f32:	a1 79       	lsl	r9,0x1
80006f34:	c0 88       	rjmp	80006f44 <find_volume+0x268>
80006f36:	f2 09 00 18 	add	r8,r9,r9<<0x1
80006f3a:	a1 98       	lsr	r8,0x1
80006f3c:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006f40:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
80006f44:	f2 c8 fe 01 	sub	r8,r9,-511
80006f48:	a9 98       	lsr	r8,0x9
80006f4a:	6e 69       	ld.w	r9,r7[0x18]
80006f4c:	10 39       	cp.w	r9,r8
80006f4e:	c7 d3       	brcs	80007048 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80006f50:	3f f8       	mov	r8,-1
80006f52:	8f 48       	st.w	r7[0x10],r8
80006f54:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
80006f56:	38 08       	mov	r8,-128
80006f58:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006f5a:	30 38       	mov	r8,3
80006f5c:	f0 06 18 00 	cp.b	r6,r8
80006f60:	c6 81       	brne	80007030 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
80006f62:	ef 39 00 61 	ld.ub	r9,r7[97]
80006f66:	ef 38 00 60 	ld.ub	r8,r7[96]
80006f6a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006f6e:	30 18       	mov	r8,1
80006f70:	f0 09 19 00 	cp.h	r9,r8
80006f74:	c5 e1       	brne	80007030 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
80006f76:	ea cb ff ff 	sub	r11,r5,-1
80006f7a:	0e 9c       	mov	r12,r7
80006f7c:	f0 1f 00 3f 	mcall	80007078 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006f80:	c5 81       	brne	80007030 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
80006f82:	30 08       	mov	r8,0
80006f84:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
80006f86:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006f8a:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006f8e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006f92:	fe 78 aa 55 	mov	r8,-21931
80006f96:	f0 09 19 00 	cp.h	r9,r8
80006f9a:	c4 b1       	brne	80007030 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
80006f9c:	ef 39 00 33 	ld.ub	r9,r7[51]
80006fa0:	ef 38 00 32 	ld.ub	r8,r7[50]
80006fa4:	b1 68       	lsl	r8,0x10
80006fa6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006faa:	ef 38 00 30 	ld.ub	r8,r7[48]
80006fae:	f3 e8 10 08 	or	r8,r9,r8
80006fb2:	ef 39 00 31 	ld.ub	r9,r7[49]
80006fb6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006fba:	e0 69 52 52 	mov	r9,21074
80006fbe:	ea 19 41 61 	orh	r9,0x4161
80006fc2:	12 38       	cp.w	r8,r9
80006fc4:	c3 61       	brne	80007030 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
80006fc6:	ef 39 02 17 	ld.ub	r9,r7[535]
80006fca:	ef 38 02 16 	ld.ub	r8,r7[534]
80006fce:	b1 68       	lsl	r8,0x10
80006fd0:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006fd4:	ef 38 02 14 	ld.ub	r8,r7[532]
80006fd8:	f3 e8 10 08 	or	r8,r9,r8
80006fdc:	ef 39 02 15 	ld.ub	r9,r7[533]
80006fe0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006fe4:	e0 69 72 72 	mov	r9,29298
80006fe8:	ea 19 61 41 	orh	r9,0x6141
80006fec:	12 38       	cp.w	r8,r9
80006fee:	c2 11       	brne	80007030 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
80006ff0:	ef 39 02 1b 	ld.ub	r9,r7[539]
80006ff4:	ef 38 02 1a 	ld.ub	r8,r7[538]
80006ff8:	b1 68       	lsl	r8,0x10
80006ffa:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006ffe:	ef 38 02 18 	ld.ub	r8,r7[536]
80007002:	f3 e8 10 08 	or	r8,r9,r8
80007006:	ef 39 02 19 	ld.ub	r9,r7[537]
8000700a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000700e:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
80007010:	ef 39 02 1f 	ld.ub	r9,r7[543]
80007014:	ef 38 02 1e 	ld.ub	r8,r7[542]
80007018:	b1 68       	lsl	r8,0x10
8000701a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000701e:	ef 38 02 1c 	ld.ub	r8,r7[540]
80007022:	f3 e8 10 08 	or	r8,r9,r8
80007026:	ef 39 02 1d 	ld.ub	r9,r7[541]
8000702a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000702e:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
80007030:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
80007032:	49 39       	lddpc	r9,8000707c <find_volume+0x3a0>
80007034:	92 08       	ld.sh	r8,r9[0x0]
80007036:	2f f8       	sub	r8,-1
80007038:	b2 08       	st.h	r9[0x0],r8
8000703a:	ae 38       	st.h	r7[0x6],r8
8000703c:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
8000703e:	c0 68       	rjmp	8000704a <find_volume+0x36e>
80007040:	30 ac       	mov	r12,10
80007042:	c0 48       	rjmp	8000704a <find_volume+0x36e>
80007044:	30 0c       	mov	r12,0
80007046:	c0 28       	rjmp	8000704a <find_volume+0x36e>
80007048:	30 dc       	mov	r12,13
}
8000704a:	2f cd       	sub	sp,-16
8000704c:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007050:	2f e9       	sub	r9,-2
80007052:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80007054:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80007056:	ea 03 00 03 	add	r3,r5,r3
8000705a:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
8000705c:	0a 04       	add	r4,r5
8000705e:	8f a4       	st.w	r7[0x28],r4
80007060:	30 36       	mov	r6,3
80007062:	c4 ab       	rjmp	80006ef6 <find_volume+0x21a>
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	63 4c       	ld.w	r12,r1[0x50]
80007068:	00 00       	add	r0,r0
8000706a:	11 48       	ld.w	r8,--r8
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	61 b0       	ld.w	r0,r0[0x6c]
80007070:	80 00       	ld.sh	r0,r0[0x0]
80007072:	61 b2       	ld.w	r2,r0[0x6c]
80007074:	80 00       	ld.sh	r0,r0[0x0]
80007076:	6c 40       	ld.w	r0,r6[0x10]
80007078:	80 00       	ld.sh	r0,r0[0x0]
8000707a:	6c 00       	ld.w	r0,r6[0x0]
8000707c:	00 00       	add	r0,r0
8000707e:	11 44       	ld.w	r4,--r8

80007080 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
80007080:	eb cd 40 40 	pushm	r6,lr
80007084:	20 3d       	sub	sp,12
80007086:	50 1c       	stdsp	sp[0x4],r12
80007088:	50 0b       	stdsp	sp[0x0],r11
8000708a:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
8000708c:	fa cc ff f4 	sub	r12,sp,-12
80007090:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
80007092:	f0 1f 00 1a 	mcall	800070f8 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
80007096:	c0 34       	brge	8000709c <f_mount+0x1c>
80007098:	30 bc       	mov	r12,11
8000709a:	c2 58       	rjmp	800070e4 <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
8000709c:	49 88       	lddpc	r8,800070fc <f_mount+0x7c>
8000709e:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
800070a2:	58 08       	cp.w	r8,0
800070a4:	f9 b9 01 00 	movne	r9,0
800070a8:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
800070ac:	40 18       	lddsp	r8,sp[0x4]
800070ae:	58 08       	cp.w	r8,0
800070b0:	c1 d0       	breq	800070ea <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
800070b2:	30 09       	mov	r9,0
800070b4:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
800070b6:	40 18       	lddsp	r8,sp[0x4]
800070b8:	49 1a       	lddpc	r10,800070fc <f_mount+0x7c>
800070ba:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
800070be:	58 08       	cp.w	r8,0
800070c0:	5f 0a       	sreq	r10
800070c2:	30 18       	mov	r8,1
800070c4:	f0 06 18 00 	cp.b	r6,r8
800070c8:	5f 18       	srne	r8
800070ca:	f5 e8 10 08 	or	r8,r10,r8
800070ce:	f2 08 18 00 	cp.b	r8,r9
800070d2:	c0 30       	breq	800070d8 <f_mount+0x58>
800070d4:	30 0c       	mov	r12,0
800070d6:	c0 78       	rjmp	800070e4 <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
800070d8:	30 0a       	mov	r10,0
800070da:	1a 9b       	mov	r11,sp
800070dc:	fa cc ff fc 	sub	r12,sp,-4
800070e0:	f0 1f 00 08 	mcall	80007100 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
800070e4:	2f dd       	sub	sp,-12
800070e6:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
800070ea:	30 08       	mov	r8,0
800070ec:	48 49       	lddpc	r9,800070fc <f_mount+0x7c>
800070ee:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
800070f2:	10 9c       	mov	r12,r8
800070f4:	cf 8b       	rjmp	800070e4 <f_mount+0x64>
800070f6:	00 00       	add	r0,r0
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	63 4c       	ld.w	r12,r1[0x50]
800070fc:	00 00       	add	r0,r0
800070fe:	11 48       	ld.w	r8,--r8
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	6c dc       	ld.w	r12,r6[0x34]

80007104 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
80007104:	eb cd 40 c0 	pushm	r6-r7,lr
80007108:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
8000710a:	f0 1f 00 2b 	mcall	800071b4 <f_sync+0xb0>
	if (res == FR_OK) {
8000710e:	c5 11       	brne	800071b0 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
80007110:	0f e8       	ld.ub	r8,r7[0x6]
80007112:	10 99       	mov	r9,r8
80007114:	e2 19 00 20 	andl	r9,0x20,COH
80007118:	c4 c0       	breq	800071b0 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
8000711a:	e2 18 00 40 	andl	r8,0x40,COH
8000711e:	c0 f0       	breq	8000713c <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80007120:	6e 08       	ld.w	r8,r7[0x0]
80007122:	30 19       	mov	r9,1
80007124:	6e 6a       	ld.w	r10,r7[0x18]
80007126:	ee cb ff d8 	sub	r11,r7,-40
8000712a:	11 9c       	ld.ub	r12,r8[0x1]
8000712c:	f0 1f 00 23 	mcall	800071b8 <f_sync+0xb4>
80007130:	c0 30       	breq	80007136 <f_sync+0x32>
80007132:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
80007136:	0f e8       	ld.ub	r8,r7[0x6]
80007138:	a7 c8       	cbr	r8,0x6
8000713a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
8000713c:	6e 7b       	ld.w	r11,r7[0x1c]
8000713e:	6e 0c       	ld.w	r12,r7[0x0]
80007140:	f0 1f 00 1f 	mcall	800071bc <f_sync+0xb8>
			if (res == FR_OK) {
80007144:	c3 61       	brne	800071b0 <f_sync+0xac>
				dir = fp->dir_ptr;
80007146:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
80007148:	ec c8 ff f5 	sub	r8,r6,-11
8000714c:	11 89       	ld.ub	r9,r8[0x0]
8000714e:	a5 b9       	sbr	r9,0x5
80007150:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
80007152:	6e 38       	ld.w	r8,r7[0xc]
80007154:	ed 68 00 1c 	st.b	r6[28],r8
80007158:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000715c:	ed 68 00 1d 	st.b	r6[29],r8
80007160:	8e e8       	ld.uh	r8,r7[0xc]
80007162:	ed 68 00 1e 	st.b	r6[30],r8
80007166:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000716a:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
8000716e:	6e 4b       	ld.w	r11,r7[0x10]
80007170:	0c 9c       	mov	r12,r6
80007172:	f0 1f 00 14 	mcall	800071c0 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
80007176:	f0 1f 00 14 	mcall	800071c4 <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
8000717a:	ed 6c 00 16 	st.b	r6[22],r12
8000717e:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80007182:	ed 68 00 17 	st.b	r6[23],r8
80007186:	f8 08 16 10 	lsr	r8,r12,0x10
8000718a:	ed 68 00 18 	st.b	r6[24],r8
8000718e:	b9 8c       	lsr	r12,0x18
80007190:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
80007194:	30 08       	mov	r8,0
80007196:	ed 68 00 12 	st.b	r6[18],r8
8000719a:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
8000719e:	0f e8       	ld.ub	r8,r7[0x6]
800071a0:	a5 d8       	cbr	r8,0x5
800071a2:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
800071a4:	6e 08       	ld.w	r8,r7[0x0]
800071a6:	30 19       	mov	r9,1
800071a8:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
800071aa:	6e 0c       	ld.w	r12,r7[0x0]
800071ac:	f0 1f 00 07 	mcall	800071c8 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
800071b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800071b4:	80 00       	ld.sh	r0,r0[0x0]
800071b6:	6b cc       	ld.w	r12,r5[0x70]
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	62 40       	ld.w	r0,r1[0x10]
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	6c 00       	ld.w	r0,r6[0x0]
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	63 32       	ld.w	r2,r1[0x4c]
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	61 b4       	ld.w	r4,r0[0x6c]
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	64 6c       	ld.w	r12,r2[0x18]

800071cc <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
800071cc:	eb cd 40 80 	pushm	r7,lr
800071d0:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
800071d2:	f0 1f 00 07 	mcall	800071ec <f_close+0x20>
	if (res == FR_OK)
800071d6:	c0 81       	brne	800071e6 <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
800071d8:	0e 9c       	mov	r12,r7
800071da:	f0 1f 00 06 	mcall	800071f0 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
800071de:	f9 b8 00 00 	moveq	r8,0
800071e2:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
800071e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800071ea:	00 00       	add	r0,r0
800071ec:	80 00       	ld.sh	r0,r0[0x0]
800071ee:	71 04       	ld.w	r4,r8[0x40]
800071f0:	80 00       	ld.sh	r0,r0[0x0]
800071f2:	6b cc       	ld.w	r12,r5[0x70]

800071f4 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
800071f4:	d4 21       	pushm	r4-r7,lr
800071f6:	18 97       	mov	r7,r12
800071f8:	16 96       	mov	r6,r11
800071fa:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800071fc:	58 1b       	cp.w	r11,1
800071fe:	e0 88 00 90 	brls	8000731e <put_fat+0x12a>
80007202:	78 58       	ld.w	r8,r12[0x14]
80007204:	10 3b       	cp.w	r11,r8
80007206:	e0 82 00 8c 	brhs	8000731e <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
8000720a:	19 88       	ld.ub	r8,r12[0x0]
8000720c:	30 29       	mov	r9,2
8000720e:	f2 08 18 00 	cp.b	r8,r9
80007212:	c4 d0       	breq	800072ac <put_fat+0xb8>
80007214:	30 39       	mov	r9,3
80007216:	f2 08 18 00 	cp.b	r8,r9
8000721a:	c5 e0       	breq	800072d6 <put_fat+0xe2>
8000721c:	30 19       	mov	r9,1
8000721e:	f2 08 18 00 	cp.b	r8,r9
80007222:	c7 e1       	brne	8000731e <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007224:	f6 04 16 01 	lsr	r4,r11,0x1
80007228:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000722a:	e8 0b 16 09 	lsr	r11,r4,0x9
8000722e:	78 88       	ld.w	r8,r12[0x20]
80007230:	10 0b       	add	r11,r8
80007232:	f0 1f 00 3d 	mcall	80007324 <put_fat+0x130>
			if (res != FR_OK) break;
80007236:	c7 51       	brne	80007320 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
80007238:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000723c:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
8000723e:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007242:	c0 d0       	breq	8000725c <put_fat+0x68>
80007244:	ee 08 00 09 	add	r9,r7,r8
80007248:	f3 39 00 30 	ld.ub	r9,r9[48]
8000724c:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
80007250:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80007254:	f3 ea 10 49 	or	r9,r9,r10<<0x4
80007258:	5c 59       	castu.b	r9
8000725a:	c0 38       	rjmp	80007260 <put_fat+0x6c>
8000725c:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
80007260:	ee 08 00 08 	add	r8,r7,r8
80007264:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
80007268:	30 18       	mov	r8,1
8000726a:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000726c:	e8 0b 16 09 	lsr	r11,r4,0x9
80007270:	6e 88       	ld.w	r8,r7[0x20]
80007272:	10 0b       	add	r11,r8
80007274:	0e 9c       	mov	r12,r7
80007276:	f0 1f 00 2c 	mcall	80007324 <put_fat+0x130>
			if (res != FR_OK) break;
8000727a:	c5 31       	brne	80007320 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
8000727c:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
80007280:	58 06       	cp.w	r6,0
80007282:	c0 40       	breq	8000728a <put_fat+0x96>
80007284:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
80007288:	c0 b8       	rjmp	8000729e <put_fat+0xaa>
8000728a:	ee 04 00 08 	add	r8,r7,r4
8000728e:	f1 38 00 30 	ld.ub	r8,r8[48]
80007292:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
80007296:	e2 18 00 f0 	andl	r8,0xf0,COH
8000729a:	f1 e5 10 05 	or	r5,r8,r5
8000729e:	ee 04 00 04 	add	r4,r7,r4
800072a2:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
800072a6:	30 18       	mov	r8,1
800072a8:	ae c8       	st.b	r7[0x4],r8
			break;
800072aa:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
800072ac:	a9 8b       	lsr	r11,0x8
800072ae:	78 88       	ld.w	r8,r12[0x20]
800072b0:	10 0b       	add	r11,r8
800072b2:	f0 1f 00 1d 	mcall	80007324 <put_fat+0x130>
			if (res != FR_OK) break;
800072b6:	c3 51       	brne	80007320 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
800072b8:	a1 76       	lsl	r6,0x1
800072ba:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
800072be:	ee 06 00 08 	add	r8,r7,r6
800072c2:	f1 65 00 30 	st.b	r8[48],r5
800072c6:	10 96       	mov	r6,r8
800072c8:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
800072cc:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
800072d0:	30 18       	mov	r8,1
800072d2:	ae c8       	st.b	r7[0x4],r8
			break;
800072d4:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
800072d6:	a7 9b       	lsr	r11,0x7
800072d8:	78 88       	ld.w	r8,r12[0x20]
800072da:	10 0b       	add	r11,r8
800072dc:	f0 1f 00 12 	mcall	80007324 <put_fat+0x130>
			if (res != FR_OK) break;
800072e0:	c2 01       	brne	80007320 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
800072e2:	a3 66       	lsl	r6,0x2
800072e4:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
800072e8:	ec c8 ff d0 	sub	r8,r6,-48
800072ec:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
800072f0:	f0 c9 ff fd 	sub	r9,r8,-3
800072f4:	13 8a       	ld.ub	r10,r9[0x0]
800072f6:	b9 6a       	lsl	r10,0x18
800072f8:	ee 06 00 06 	add	r6,r7,r6
800072fc:	e6 1a f0 00 	andh	r10,0xf000,COH
80007300:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007304:	ed 65 00 30 	st.b	r6[48],r5
80007308:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
8000730c:	b0 9a       	st.b	r8[0x1],r10
8000730e:	ea 0a 16 10 	lsr	r10,r5,0x10
80007312:	b0 aa       	st.b	r8[0x2],r10
80007314:	b9 85       	lsr	r5,0x18
80007316:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007318:	30 18       	mov	r8,1
8000731a:	ae c8       	st.b	r7[0x4],r8
			break;
8000731c:	d8 22       	popm	r4-r7,pc
8000731e:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
80007320:	d8 22       	popm	r4-r7,pc
80007322:	00 00       	add	r0,r0
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	6c 00       	ld.w	r0,r6[0x0]

80007328 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007328:	d4 21       	pushm	r4-r7,lr
8000732a:	18 97       	mov	r7,r12
8000732c:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000732e:	58 1b       	cp.w	r11,1
80007330:	e0 88 00 69 	brls	80007402 <get_fat+0xda>
80007334:	78 58       	ld.w	r8,r12[0x14]
80007336:	10 3b       	cp.w	r11,r8
80007338:	c6 52       	brcc	80007402 <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
8000733a:	19 88       	ld.ub	r8,r12[0x0]
8000733c:	30 29       	mov	r9,2
8000733e:	f2 08 18 00 	cp.b	r8,r9
80007342:	c3 10       	breq	800073a4 <get_fat+0x7c>
80007344:	30 39       	mov	r9,3
80007346:	f2 08 18 00 	cp.b	r8,r9
8000734a:	c4 00       	breq	800073ca <get_fat+0xa2>
8000734c:	30 19       	mov	r9,1
8000734e:	f2 08 18 00 	cp.b	r8,r9
80007352:	c5 81       	brne	80007402 <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007354:	f6 05 16 01 	lsr	r5,r11,0x1
80007358:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
8000735a:	ea 0b 16 09 	lsr	r11,r5,0x9
8000735e:	78 88       	ld.w	r8,r12[0x20]
80007360:	10 0b       	add	r11,r8
80007362:	f0 1f 00 2a 	mcall	80007408 <get_fat+0xe0>
80007366:	c4 f1       	brne	80007404 <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
80007368:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
8000736c:	ee 08 00 08 	add	r8,r7,r8
80007370:	f1 34 00 30 	ld.ub	r4,r8[48]
80007374:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
80007376:	ea 0b 16 09 	lsr	r11,r5,0x9
8000737a:	6e 88       	ld.w	r8,r7[0x20]
8000737c:	10 0b       	add	r11,r8
8000737e:	0e 9c       	mov	r12,r7
80007380:	f0 1f 00 22 	mcall	80007408 <get_fat+0xe0>
80007384:	c4 01       	brne	80007404 <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
80007386:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
8000738a:	0a 07       	add	r7,r5
8000738c:	ef 3c 00 30 	ld.ub	r12,r7[48]
80007390:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
80007394:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007398:	c0 30       	breq	8000739e <get_fat+0x76>
8000739a:	a5 8c       	lsr	r12,0x4
8000739c:	d8 22       	popm	r4-r7,pc
8000739e:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
800073a2:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
800073a4:	a9 8b       	lsr	r11,0x8
800073a6:	78 88       	ld.w	r8,r12[0x20]
800073a8:	10 0b       	add	r11,r8
800073aa:	f0 1f 00 18 	mcall	80007408 <get_fat+0xe0>
800073ae:	c2 b1       	brne	80007404 <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
800073b0:	a1 76       	lsl	r6,0x1
800073b2:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
800073b6:	ee 06 00 08 	add	r8,r7,r6
800073ba:	10 97       	mov	r7,r8
800073bc:	f1 3c 00 31 	ld.ub	r12,r8[49]
800073c0:	f1 38 00 30 	ld.ub	r8,r8[48]
800073c4:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
800073c8:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
800073ca:	a7 9b       	lsr	r11,0x7
800073cc:	78 88       	ld.w	r8,r12[0x20]
800073ce:	10 0b       	add	r11,r8
800073d0:	f0 1f 00 0e 	mcall	80007408 <get_fat+0xe0>
800073d4:	c1 81       	brne	80007404 <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
800073d6:	a3 66       	lsl	r6,0x2
800073d8:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
800073dc:	ec c8 ff d0 	sub	r8,r6,-48
800073e0:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
800073e4:	11 a9       	ld.ub	r9,r8[0x2]
800073e6:	11 bc       	ld.ub	r12,r8[0x3]
800073e8:	b9 6c       	lsl	r12,0x18
800073ea:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
800073ee:	11 98       	ld.ub	r8,r8[0x1]
800073f0:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
800073f4:	0c 07       	add	r7,r6
800073f6:	ef 38 00 30 	ld.ub	r8,r7[48]
800073fa:	10 4c       	or	r12,r8
800073fc:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007400:	d8 22       	popm	r4-r7,pc
80007402:	da 2a       	popm	r4-r7,pc,r12=1
80007404:	dc 2a       	popm	r4-r7,pc,r12=-1
80007406:	00 00       	add	r0,r0
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	6c 00       	ld.w	r0,r6[0x0]

8000740c <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
8000740c:	eb cd 40 f8 	pushm	r3-r7,lr
80007410:	18 96       	mov	r6,r12
80007412:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
80007414:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
80007416:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007418:	58 18       	cp.w	r8,1
8000741a:	c4 c0       	breq	800074b2 <dir_sdi+0xa6>
8000741c:	78 09       	ld.w	r9,r12[0x0]
8000741e:	72 5a       	ld.w	r10,r9[0x14]
80007420:	14 38       	cp.w	r8,r10
80007422:	c4 82       	brcc	800074b2 <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
80007424:	58 08       	cp.w	r8,0
80007426:	c0 f1       	brne	80007444 <dir_sdi+0x38>
80007428:	13 8b       	ld.ub	r11,r9[0x0]
8000742a:	30 3a       	mov	r10,3
8000742c:	f4 0b 18 00 	cp.b	r11,r10
80007430:	c0 41       	brne	80007438 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
80007432:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
80007434:	58 07       	cp.w	r7,0
80007436:	c0 81       	brne	80007446 <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
80007438:	92 ca       	ld.uh	r10,r9[0x8]
8000743a:	14 35       	cp.w	r5,r10
8000743c:	c3 b2       	brcc	800074b2 <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
8000743e:	72 9c       	ld.w	r12,r9[0x24]
80007440:	10 97       	mov	r7,r8
80007442:	c2 68       	rjmp	8000748e <dir_sdi+0x82>
80007444:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
80007446:	13 a4       	ld.ub	r4,r9[0x2]
80007448:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
8000744a:	08 35       	cp.w	r5,r4
8000744c:	c1 d3       	brcs	80007486 <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
8000744e:	e8 03 11 00 	rsub	r3,r4,0
80007452:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
80007454:	0e 9b       	mov	r11,r7
80007456:	6c 0c       	ld.w	r12,r6[0x0]
80007458:	f0 1f 00 18 	mcall	800074b8 <dir_sdi+0xac>
8000745c:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
8000745e:	5b fc       	cp.w	r12,-1
80007460:	c0 31       	brne	80007466 <dir_sdi+0x5a>
80007462:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
80007466:	58 1c       	cp.w	r12,1
80007468:	e0 88 00 25 	brls	800074b2 <dir_sdi+0xa6>
8000746c:	6c 08       	ld.w	r8,r6[0x0]
8000746e:	70 58       	ld.w	r8,r8[0x14]
80007470:	10 3c       	cp.w	r12,r8
80007472:	c2 02       	brcc	800074b2 <dir_sdi+0xa6>
80007474:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
80007478:	f0 04 00 09 	add	r9,r8,r4
8000747c:	12 34       	cp.w	r4,r9
8000747e:	e0 8b 00 04 	brhi	80007486 <dir_sdi+0x7a>
80007482:	10 95       	mov	r5,r8
80007484:	ce 8b       	rjmp	80007454 <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
80007486:	0e 9b       	mov	r11,r7
80007488:	6c 0c       	ld.w	r12,r6[0x0]
8000748a:	f0 1f 00 0d 	mcall	800074bc <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
8000748e:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
80007490:	58 0c       	cp.w	r12,0
80007492:	c1 00       	breq	800074b2 <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
80007494:	ea 08 16 04 	lsr	r8,r5,0x4
80007498:	f0 0c 00 0c 	add	r12,r8,r12
8000749c:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
8000749e:	6c 08       	ld.w	r8,r6[0x0]
800074a0:	2d 08       	sub	r8,-48
800074a2:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
800074a6:	a5 75       	lsl	r5,0x5
800074a8:	f0 05 00 05 	add	r5,r8,r5
800074ac:	8d 55       	st.w	r6[0x14],r5
800074ae:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
800074b2:	30 2c       	mov	r12,2
}
800074b4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800074b8:	80 00       	ld.sh	r0,r0[0x0]
800074ba:	73 28       	ld.w	r8,r9[0x48]
800074bc:	80 00       	ld.sh	r0,r0[0x0]
800074be:	62 b4       	ld.w	r4,r1[0x2c]

800074c0 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
800074c0:	eb cd 40 fc 	pushm	r2-r7,lr
800074c4:	18 96       	mov	r6,r12
800074c6:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
800074c8:	58 0b       	cp.w	r11,0
800074ca:	c0 81       	brne	800074da <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
800074cc:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
800074ce:	58 05       	cp.w	r5,0
800074d0:	c1 10       	breq	800074f2 <create_chain+0x32>
800074d2:	78 58       	ld.w	r8,r12[0x14]
800074d4:	10 35       	cp.w	r5,r8
800074d6:	c0 e2       	brcc	800074f2 <create_chain+0x32>
800074d8:	c0 e8       	rjmp	800074f4 <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
800074da:	f0 1f 00 2c 	mcall	80007588 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
800074de:	58 1c       	cp.w	r12,1
800074e0:	e0 88 00 4f 	brls	8000757e <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
800074e4:	5b fc       	cp.w	r12,-1
800074e6:	c4 f0       	breq	80007584 <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
800074e8:	6c 58       	ld.w	r8,r6[0x14]
800074ea:	10 3c       	cp.w	r12,r8
800074ec:	c4 c3       	brcs	80007584 <create_chain+0xc4>
800074ee:	04 95       	mov	r5,r2
800074f0:	c0 28       	rjmp	800074f4 <create_chain+0x34>
800074f2:	30 15       	mov	r5,1
800074f4:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
800074f6:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
800074f8:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
800074fa:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
800074fc:	6c 58       	ld.w	r8,r6[0x14]
800074fe:	10 37       	cp.w	r7,r8
80007500:	c0 53       	brcs	8000750a <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007502:	58 15       	cp.w	r5,1
80007504:	e0 88 00 3f 	brls	80007582 <create_chain+0xc2>
80007508:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
8000750a:	0e 9b       	mov	r11,r7
8000750c:	0c 9c       	mov	r12,r6
8000750e:	f0 1f 00 1f 	mcall	80007588 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
80007512:	c0 d0       	breq	8000752c <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007514:	5b fc       	cp.w	r12,-1
80007516:	5f 09       	sreq	r9
80007518:	58 1c       	cp.w	r12,1
8000751a:	5f 08       	sreq	r8
8000751c:	f3 e8 10 08 	or	r8,r9,r8
80007520:	e8 08 18 00 	cp.b	r8,r4
80007524:	c3 01       	brne	80007584 <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
80007526:	0a 37       	cp.w	r7,r5
80007528:	ce 91       	brne	800074fa <create_chain+0x3a>
8000752a:	c2 c8       	rjmp	80007582 <create_chain+0xc2>
8000752c:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
8000752e:	e0 6a ff ff 	mov	r10,65535
80007532:	ea 1a 0f ff 	orh	r10,0xfff
80007536:	0e 9b       	mov	r11,r7
80007538:	0c 9c       	mov	r12,r6
8000753a:	f0 1f 00 15 	mcall	8000758c <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
8000753e:	5f 09       	sreq	r9
80007540:	58 02       	cp.w	r2,0
80007542:	5f 18       	srne	r8
80007544:	f3 e8 00 08 	and	r8,r9,r8
80007548:	c0 60       	breq	80007554 <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
8000754a:	0e 9a       	mov	r10,r7
8000754c:	04 9b       	mov	r11,r2
8000754e:	0c 9c       	mov	r12,r6
80007550:	f0 1f 00 0f 	mcall	8000758c <create_chain+0xcc>
	}
	if (res == FR_OK) {
80007554:	58 0c       	cp.w	r12,0
80007556:	c1 01       	brne	80007576 <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
80007558:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
8000755a:	6c 48       	ld.w	r8,r6[0x10]
8000755c:	5b f8       	cp.w	r8,-1
8000755e:	c0 41       	brne	80007566 <create_chain+0xa6>
80007560:	0e 9c       	mov	r12,r7
80007562:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
80007566:	20 18       	sub	r8,1
80007568:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
8000756a:	0d d8       	ld.ub	r8,r6[0x5]
8000756c:	a1 a8       	sbr	r8,0x0
8000756e:	ac d8       	st.b	r6[0x5],r8
80007570:	0e 9c       	mov	r12,r7
80007572:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
80007576:	58 1c       	cp.w	r12,1
80007578:	c0 31       	brne	8000757e <create_chain+0xbe>
8000757a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
8000757e:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80007582:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
80007584:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	73 28       	ld.w	r8,r9[0x48]
8000758c:	80 00       	ld.sh	r0,r0[0x0]
8000758e:	71 f4       	ld.w	r4,r8[0x7c]

80007590 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
80007590:	eb cd 40 fc 	pushm	r2-r7,lr
80007594:	18 97       	mov	r7,r12
80007596:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
80007598:	98 b5       	ld.uh	r5,r12[0x6]
8000759a:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
8000759c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800075a0:	c6 d0       	breq	8000767a <dir_next+0xea>
800075a2:	78 48       	ld.w	r8,r12[0x10]
800075a4:	58 08       	cp.w	r8,0
800075a6:	c6 a0       	breq	8000767a <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
800075a8:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
800075ac:	c5 e1       	brne	80007668 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
800075ae:	2f f8       	sub	r8,-1
800075b0:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
800075b2:	78 3b       	ld.w	r11,r12[0xc]
800075b4:	58 0b       	cp.w	r11,0
800075b6:	c0 61       	brne	800075c2 <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
800075b8:	78 08       	ld.w	r8,r12[0x0]
800075ba:	90 c8       	ld.uh	r8,r8[0x8]
800075bc:	10 35       	cp.w	r5,r8
800075be:	c5 53       	brcs	80007668 <dir_next+0xd8>
800075c0:	c5 d8       	rjmp	8000767a <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
800075c2:	78 0c       	ld.w	r12,r12[0x0]
800075c4:	19 a8       	ld.ub	r8,r12[0x2]
800075c6:	20 18       	sub	r8,1
800075c8:	f1 e5 02 48 	and	r8,r8,r5>>0x4
800075cc:	c4 e1       	brne	80007668 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
800075ce:	f0 1f 00 30 	mcall	8000768c <dir_next+0xfc>
800075d2:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
800075d4:	58 1c       	cp.w	r12,1
800075d6:	e0 88 00 55 	brls	80007680 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
800075da:	5b fc       	cp.w	r12,-1
800075dc:	c5 50       	breq	80007686 <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
800075de:	6e 0c       	ld.w	r12,r7[0x0]
800075e0:	78 58       	ld.w	r8,r12[0x14]
800075e2:	10 33       	cp.w	r3,r8
800075e4:	c3 c3       	brcs	8000765c <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
800075e6:	58 06       	cp.w	r6,0
800075e8:	c4 90       	breq	8000767a <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
800075ea:	6e 3b       	ld.w	r11,r7[0xc]
800075ec:	f0 1f 00 29 	mcall	80007690 <dir_next+0x100>
800075f0:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
800075f2:	c0 41       	brne	800075fa <dir_next+0x6a>
800075f4:	30 7c       	mov	r12,7
800075f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
800075fa:	58 1c       	cp.w	r12,1
800075fc:	c4 20       	breq	80007680 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
800075fe:	5b fc       	cp.w	r12,-1
80007600:	c4 30       	breq	80007686 <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
80007602:	6e 0c       	ld.w	r12,r7[0x0]
80007604:	f0 1f 00 24 	mcall	80007694 <dir_next+0x104>
80007608:	c3 f1       	brne	80007686 <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
8000760a:	6e 0c       	ld.w	r12,r7[0x0]
8000760c:	e0 6a 02 00 	mov	r10,512
80007610:	30 0b       	mov	r11,0
80007612:	2d 0c       	sub	r12,-48
80007614:	f0 1f 00 21 	mcall	80007698 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007618:	6e 06       	ld.w	r6,r7[0x0]
8000761a:	06 9b       	mov	r11,r3
8000761c:	0c 9c       	mov	r12,r6
8000761e:	f0 1f 00 20 	mcall	8000769c <dir_next+0x10c>
80007622:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007624:	6e 08       	ld.w	r8,r7[0x0]
80007626:	11 aa       	ld.ub	r10,r8[0x2]
80007628:	30 09       	mov	r9,0
8000762a:	f2 0a 18 00 	cp.b	r10,r9
8000762e:	c0 31       	brne	80007634 <dir_next+0xa4>
80007630:	30 06       	mov	r6,0
80007632:	c1 28       	rjmp	80007656 <dir_next+0xc6>
80007634:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
80007636:	30 12       	mov	r2,1
80007638:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
8000763a:	6e 0c       	ld.w	r12,r7[0x0]
8000763c:	f0 1f 00 16 	mcall	80007694 <dir_next+0x104>
80007640:	c2 31       	brne	80007686 <dir_next+0xf6>
						dp->fs->winsect++;
80007642:	6e 08       	ld.w	r8,r7[0x0]
80007644:	70 b9       	ld.w	r9,r8[0x2c]
80007646:	2f f9       	sub	r9,-1
80007648:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
8000764a:	2f f6       	sub	r6,-1
8000764c:	6e 08       	ld.w	r8,r7[0x0]
8000764e:	11 a9       	ld.ub	r9,r8[0x2]
80007650:	0c 39       	cp.w	r9,r6
80007652:	fe 9b ff f3 	brhi	80007638 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
80007656:	70 b9       	ld.w	r9,r8[0x2c]
80007658:	0c 19       	sub	r9,r6
8000765a:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
8000765c:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
8000765e:	06 9b       	mov	r11,r3
80007660:	6e 0c       	ld.w	r12,r7[0x0]
80007662:	f0 1f 00 0f 	mcall	8000769c <dir_next+0x10c>
80007666:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
80007668:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
8000766a:	6e 08       	ld.w	r8,r7[0x0]
8000766c:	2d 08       	sub	r8,-48
8000766e:	a5 74       	lsl	r4,0x5
80007670:	f0 04 00 04 	add	r4,r8,r4
80007674:	8f 54       	st.w	r7[0x14],r4
80007676:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
8000767a:	30 4c       	mov	r12,4
8000767c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007680:	30 2c       	mov	r12,2
80007682:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007686:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8000768a:	00 00       	add	r0,r0
8000768c:	80 00       	ld.sh	r0,r0[0x0]
8000768e:	73 28       	ld.w	r8,r9[0x48]
80007690:	80 00       	ld.sh	r0,r0[0x0]
80007692:	74 c0       	ld.w	r0,r10[0x30]
80007694:	80 00       	ld.sh	r0,r0[0x0]
80007696:	64 08       	ld.w	r8,r2[0x0]
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	62 8e       	ld.w	lr,r1[0x20]
8000769c:	80 00       	ld.sh	r0,r0[0x0]
8000769e:	62 b4       	ld.w	r4,r1[0x2c]

800076a0 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
800076a0:	d4 21       	pushm	r4-r7,lr
800076a2:	18 97       	mov	r7,r12
800076a4:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800076a6:	58 1b       	cp.w	r11,1
800076a8:	e0 88 00 26 	brls	800076f4 <remove_chain+0x54>
800076ac:	78 58       	ld.w	r8,r12[0x14]
800076ae:	10 3b       	cp.w	r11,r8
800076b0:	c2 22       	brcc	800076f4 <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800076b2:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
800076b4:	0a 9b       	mov	r11,r5
800076b6:	0e 9c       	mov	r12,r7
800076b8:	f0 1f 00 10 	mcall	800076f8 <remove_chain+0x58>
800076bc:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
800076be:	c0 21       	brne	800076c2 <remove_chain+0x22>
800076c0:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
800076c2:	58 1c       	cp.w	r12,1
800076c4:	c1 80       	breq	800076f4 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
800076c6:	5b fc       	cp.w	r12,-1
800076c8:	c0 21       	brne	800076cc <remove_chain+0x2c>
800076ca:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800076cc:	08 9a       	mov	r10,r4
800076ce:	0a 9b       	mov	r11,r5
800076d0:	0e 9c       	mov	r12,r7
800076d2:	f0 1f 00 0b 	mcall	800076fc <remove_chain+0x5c>
			if (res != FR_OK) break;
800076d6:	c1 01       	brne	800076f6 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
800076d8:	6e 48       	ld.w	r8,r7[0x10]
800076da:	5b f8       	cp.w	r8,-1
800076dc:	c0 60       	breq	800076e8 <remove_chain+0x48>
				fs->free_clust++;
800076de:	2f f8       	sub	r8,-1
800076e0:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
800076e2:	0f d8       	ld.ub	r8,r7[0x5]
800076e4:	a1 a8       	sbr	r8,0x0
800076e6:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
800076e8:	6e 58       	ld.w	r8,r7[0x14]
800076ea:	0c 38       	cp.w	r8,r6
800076ec:	e0 88 00 05 	brls	800076f6 <remove_chain+0x56>
800076f0:	0c 95       	mov	r5,r6
800076f2:	ce 1b       	rjmp	800076b4 <remove_chain+0x14>
800076f4:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
800076f6:	d8 22       	popm	r4-r7,pc
800076f8:	80 00       	ld.sh	r0,r0[0x0]
800076fa:	73 28       	ld.w	r8,r9[0x48]
800076fc:	80 00       	ld.sh	r0,r0[0x0]
800076fe:	71 f4       	ld.w	r4,r8[0x7c]

80007700 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007700:	eb cd 40 fe 	pushm	r1-r7,lr
80007704:	18 97       	mov	r7,r12
80007706:	16 91       	mov	r1,r11
80007708:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
8000770a:	3e 56       	mov	r6,-27
8000770c:	32 e5       	mov	r5,46
8000770e:	30 04       	mov	r4,0
80007710:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007712:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007714:	c2 58       	rjmp	8000775e <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007716:	6e 0c       	ld.w	r12,r7[0x0]
80007718:	f0 1f 00 17 	mcall	80007774 <dir_read+0x74>
		if (res != FR_OK) break;
8000771c:	c2 61       	brne	80007768 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
8000771e:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007720:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007722:	58 08       	cp.w	r8,0
80007724:	c2 60       	breq	80007770 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007726:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
8000772a:	ec 08 18 00 	cp.b	r8,r6
8000772e:	5f 19       	srne	r9
80007730:	ea 08 18 00 	cp.b	r8,r5
80007734:	5f 18       	srne	r8
80007736:	f3 e8 00 08 	and	r8,r9,r8
8000773a:	e8 08 18 00 	cp.b	r8,r4
8000773e:	c0 b0       	breq	80007754 <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007740:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007744:	e4 08 18 00 	cp.b	r8,r2
80007748:	c0 60       	breq	80007754 <dir_read+0x54>
8000774a:	a5 d8       	cbr	r8,0x5
8000774c:	58 88       	cp.w	r8,8
8000774e:	5f 08       	sreq	r8
80007750:	02 38       	cp.w	r8,r1
80007752:	c0 d0       	breq	8000776c <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007754:	06 9b       	mov	r11,r3
80007756:	0e 9c       	mov	r12,r7
80007758:	f0 1f 00 08 	mcall	80007778 <dir_read+0x78>
		if (res != FR_OK) break;
8000775c:	c0 61       	brne	80007768 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
8000775e:	6e 4b       	ld.w	r11,r7[0x10]
80007760:	58 0b       	cp.w	r11,0
80007762:	cd a1       	brne	80007716 <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007764:	58 0c       	cp.w	r12,0
80007766:	c0 30       	breq	8000776c <dir_read+0x6c>
80007768:	30 08       	mov	r8,0
8000776a:	8f 48       	st.w	r7[0x10],r8

	return res;
}
8000776c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007770:	30 4c       	mov	r12,4
80007772:	cf bb       	rjmp	80007768 <dir_read+0x68>
80007774:	80 00       	ld.sh	r0,r0[0x0]
80007776:	6c 00       	ld.w	r0,r6[0x0]
80007778:	80 00       	ld.sh	r0,r0[0x0]
8000777a:	75 90       	ld.w	r0,r10[0x64]

8000777c <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
8000777c:	d4 21       	pushm	r4-r7,lr
8000777e:	20 9d       	sub	sp,36
80007780:	50 0c       	stdsp	sp[0x0],r12
80007782:	16 96       	mov	r6,r11
80007784:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
80007786:	30 0a       	mov	r10,0
80007788:	1a 9b       	mov	r11,sp
8000778a:	fa cc ff fc 	sub	r12,sp,-4
8000778e:	f0 1f 00 30 	mcall	8000784c <f_getlabel+0xd0>
80007792:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
80007794:	5f 09       	sreq	r9
80007796:	58 06       	cp.w	r6,0
80007798:	5f 18       	srne	r8
8000779a:	f3 e8 00 08 	and	r8,r9,r8
8000779e:	c2 d0       	breq	800077f8 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
800077a0:	30 0b       	mov	r11,0
800077a2:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
800077a4:	fa cc ff fc 	sub	r12,sp,-4
800077a8:	f0 1f 00 2a 	mcall	80007850 <f_getlabel+0xd4>
800077ac:	18 97       	mov	r7,r12
		if (res == FR_OK) {
800077ae:	c4 c1       	brne	80007846 <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
800077b0:	30 1b       	mov	r11,1
800077b2:	fa cc ff fc 	sub	r12,sp,-4
800077b6:	f0 1f 00 28 	mcall	80007854 <f_getlabel+0xd8>
800077ba:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
800077bc:	c1 81       	brne	800077ec <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
800077be:	30 ba       	mov	r10,11
800077c0:	40 6b       	lddsp	r11,sp[0x18]
800077c2:	0c 9c       	mov	r12,r6
800077c4:	f0 1f 00 25 	mcall	80007858 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
800077c8:	30 08       	mov	r8,0
800077ca:	ed 68 00 0b 	st.b	r6[11],r8
800077ce:	2f 66       	sub	r6,-10
800077d0:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
800077d2:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
800077d4:	30 0b       	mov	r11,0
800077d6:	c0 58       	rjmp	800077e0 <f_getlabel+0x64>
800077d8:	ac 8b       	st.b	r6[0x0],r11
800077da:	20 16       	sub	r6,1
					if (!j) break;
800077dc:	58 08       	cp.w	r8,0
800077de:	c0 c0       	breq	800077f6 <f_getlabel+0x7a>
				} while (label[--j] == ' ');
800077e0:	20 18       	sub	r8,1
800077e2:	0d 89       	ld.ub	r9,r6[0x0]
800077e4:	f4 09 18 00 	cp.b	r9,r10
800077e8:	cf 80       	breq	800077d8 <f_getlabel+0x5c>
800077ea:	c0 68       	rjmp	800077f6 <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
800077ec:	58 4c       	cp.w	r12,4
800077ee:	c0 41       	brne	800077f6 <f_getlabel+0x7a>
				label[0] = 0;
800077f0:	30 08       	mov	r8,0
800077f2:	ac 88       	st.b	r6[0x0],r8
800077f4:	c0 28       	rjmp	800077f8 <f_getlabel+0x7c>
800077f6:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
800077f8:	58 07       	cp.w	r7,0
800077fa:	5f 09       	sreq	r9
800077fc:	58 05       	cp.w	r5,0
800077fe:	5f 18       	srne	r8
80007800:	f3 e8 00 08 	and	r8,r9,r8
80007804:	c2 10       	breq	80007846 <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007806:	40 1c       	lddsp	r12,sp[0x4]
80007808:	78 7b       	ld.w	r11,r12[0x1c]
8000780a:	f0 1f 00 15 	mcall	8000785c <f_getlabel+0xe0>
8000780e:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007810:	c1 b1       	brne	80007846 <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007812:	40 19       	lddsp	r9,sp[0x4]
80007814:	13 8a       	ld.ub	r10,r9[0x0]
80007816:	30 38       	mov	r8,3
80007818:	f0 0a 18 00 	cp.b	r10,r8
8000781c:	f9 b8 00 43 	moveq	r8,67
80007820:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007824:	f2 08 00 08 	add	r8,r9,r8
80007828:	f1 3a 00 33 	ld.ub	r10,r8[51]
8000782c:	f1 39 00 32 	ld.ub	r9,r8[50]
80007830:	b1 69       	lsl	r9,0x10
80007832:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007836:	f1 3a 00 30 	ld.ub	r10,r8[48]
8000783a:	14 49       	or	r9,r10
8000783c:	f1 38 00 31 	ld.ub	r8,r8[49]
80007840:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007844:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007846:	0e 9c       	mov	r12,r7
80007848:	2f 7d       	sub	sp,-36
8000784a:	d8 22       	popm	r4-r7,pc
8000784c:	80 00       	ld.sh	r0,r0[0x0]
8000784e:	6c dc       	ld.w	r12,r6[0x34]
80007850:	80 00       	ld.sh	r0,r0[0x0]
80007852:	74 0c       	ld.w	r12,r10[0x0]
80007854:	80 00       	ld.sh	r0,r0[0x0]
80007856:	77 00       	ld.w	r0,r11[0x40]
80007858:	80 00       	ld.sh	r0,r0[0x0]
8000785a:	62 78       	ld.w	r8,r1[0x1c]
8000785c:	80 00       	ld.sh	r0,r0[0x0]
8000785e:	6c 00       	ld.w	r0,r6[0x0]

80007860 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
80007860:	eb cd 40 fe 	pushm	r1-r7,lr
80007864:	18 97       	mov	r7,r12
80007866:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
80007868:	30 0b       	mov	r11,0
8000786a:	f0 1f 00 15 	mcall	800078bc <dir_alloc+0x5c>
	if (res == FR_OK) {
8000786e:	c2 21       	brne	800078b2 <dir_alloc+0x52>
80007870:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007872:	3e 54       	mov	r4,-27
80007874:	30 06       	mov	r6,0
80007876:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007878:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
8000787a:	6e 4b       	ld.w	r11,r7[0x10]
8000787c:	6e 0c       	ld.w	r12,r7[0x0]
8000787e:	f0 1f 00 11 	mcall	800078c0 <dir_alloc+0x60>
			if (res != FR_OK) break;
80007882:	c1 81       	brne	800078b2 <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007884:	6e 58       	ld.w	r8,r7[0x14]
80007886:	11 88       	ld.ub	r8,r8[0x0]
80007888:	e8 08 18 00 	cp.b	r8,r4
8000788c:	5f 09       	sreq	r9
8000788e:	ec 08 18 00 	cp.b	r8,r6
80007892:	5f 08       	sreq	r8
80007894:	f3 e8 10 08 	or	r8,r9,r8
80007898:	ec 08 18 00 	cp.b	r8,r6
8000789c:	c0 31       	brne	800078a2 <dir_alloc+0x42>
8000789e:	02 95       	mov	r5,r1
800078a0:	c0 48       	rjmp	800078a8 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
800078a2:	2f f5       	sub	r5,-1
800078a4:	04 35       	cp.w	r5,r2
800078a6:	c0 90       	breq	800078b8 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
800078a8:	06 9b       	mov	r11,r3
800078aa:	0e 9c       	mov	r12,r7
800078ac:	f0 1f 00 06 	mcall	800078c4 <dir_alloc+0x64>
		} while (res == FR_OK);
800078b0:	ce 50       	breq	8000787a <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
800078b2:	58 4c       	cp.w	r12,4
800078b4:	f9 bc 00 07 	moveq	r12,7
	return res;
}
800078b8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800078bc:	80 00       	ld.sh	r0,r0[0x0]
800078be:	74 0c       	ld.w	r12,r10[0x0]
800078c0:	80 00       	ld.sh	r0,r0[0x0]
800078c2:	6c 00       	ld.w	r0,r6[0x0]
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	75 90       	ld.w	r0,r10[0x64]

800078c8 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
800078c8:	d4 31       	pushm	r0-r7,lr
800078ca:	20 cd       	sub	sp,48
800078cc:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
800078ce:	30 1a       	mov	r10,1
800078d0:	1a 9b       	mov	r11,sp
800078d2:	fa cc ff f0 	sub	r12,sp,-16
800078d6:	f0 1f 00 8b 	mcall	80007b00 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
800078da:	e0 81 01 08 	brne	80007aea <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
800078de:	30 08       	mov	r8,0
800078e0:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
800078e2:	40 0a       	lddsp	r10,sp[0x0]
800078e4:	15 89       	ld.ub	r9,r10[0x0]
800078e6:	f0 09 18 00 	cp.b	r9,r8
800078ea:	e0 80 00 90 	breq	80007a0a <f_setlabel+0x142>
800078ee:	30 07       	mov	r7,0
800078f0:	2f f7       	sub	r7,-1
800078f2:	f4 07 07 09 	ld.ub	r9,r10[r7]
800078f6:	f0 09 18 00 	cp.b	r9,r8
800078fa:	cf b1       	brne	800078f0 <f_setlabel+0x28>
800078fc:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
800078fe:	58 07       	cp.w	r7,0
80007900:	e0 80 00 85 	breq	80007a0a <f_setlabel+0x142>
80007904:	f4 07 00 09 	add	r9,r10,r7
80007908:	f3 3b ff ff 	ld.ub	r11,r9[-1]
8000790c:	32 09       	mov	r9,32
8000790e:	f2 0b 18 00 	cp.b	r11,r9
80007912:	e0 81 00 ee 	brne	80007aee <f_setlabel+0x226>
80007916:	20 28       	sub	r8,2
80007918:	f4 08 00 08 	add	r8,r10,r8
8000791c:	12 9a       	mov	r10,r9
8000791e:	20 17       	sub	r7,1
80007920:	c7 50       	breq	80007a0a <f_setlabel+0x142>
80007922:	11 89       	ld.ub	r9,r8[0x0]
80007924:	20 18       	sub	r8,1
80007926:	f4 09 18 00 	cp.b	r9,r10
8000792a:	cf a0       	breq	8000791e <f_setlabel+0x56>
8000792c:	ce 18       	rjmp	80007aee <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
8000792e:	40 08       	lddsp	r8,sp[0x0]
80007930:	f0 04 07 06 	ld.ub	r6,r8[r4]
80007934:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
80007936:	ec c9 ff 81 	sub	r9,r6,-127
8000793a:	e4 09 18 00 	cp.b	r9,r2
8000793e:	e0 8b 00 24 	brhi	80007986 <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007942:	58 95       	cp.w	r5,9
80007944:	5f 8a       	srls	r10
80007946:	0e 34       	cp.w	r4,r7
80007948:	5f 39       	srlo	r9
8000794a:	f5 e9 00 09 	and	r9,r10,r9
8000794e:	e2 09 18 00 	cp.b	r9,r1
80007952:	e0 80 00 c9 	breq	80007ae4 <f_setlabel+0x21c>
80007956:	f0 04 07 08 	ld.ub	r8,r8[r4]
8000795a:	f0 c9 00 40 	sub	r9,r8,64
8000795e:	33 eb       	mov	r11,62
80007960:	f6 09 18 00 	cp.b	r9,r11
80007964:	5f 8a       	srls	r10
80007966:	f0 c9 00 80 	sub	r9,r8,128
8000796a:	37 eb       	mov	r11,126
8000796c:	f6 09 18 00 	cp.b	r9,r11
80007970:	5f 89       	srls	r9
80007972:	f5 e9 10 09 	or	r9,r10,r9
80007976:	e2 09 18 00 	cp.b	r9,r1
8000797a:	e0 80 00 b5 	breq	80007ae4 <f_setlabel+0x21c>
8000797e:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80007982:	5c 86       	casts.h	r6
80007984:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
80007986:	ec c8 00 61 	sub	r8,r6,97
8000798a:	31 9a       	mov	r10,25
8000798c:	f4 08 19 00 	cp.h	r8,r10
80007990:	e0 8b 00 04 	brhi	80007998 <f_setlabel+0xd0>
80007994:	22 06       	sub	r6,32
80007996:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007998:	58 06       	cp.w	r6,0
8000799a:	e0 80 00 a5 	breq	80007ae4 <f_setlabel+0x21c>
8000799e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800079a2:	00 9c       	mov	r12,r0
800079a4:	f0 1f 00 58 	mcall	80007b04 <f_setlabel+0x23c>
800079a8:	e0 81 00 9e 	brne	80007ae4 <f_setlabel+0x21c>
800079ac:	ec 03 19 00 	cp.h	r3,r6
800079b0:	f9 b8 03 0a 	movlo	r8,10
800079b4:	f9 b8 02 0b 	movhs	r8,11
800079b8:	10 35       	cp.w	r5,r8
800079ba:	e0 82 00 95 	brhs	80007ae4 <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
800079be:	e6 06 19 00 	cp.h	r6,r3
800079c2:	e0 88 00 0a 	brls	800079d6 <f_setlabel+0x10e>
800079c6:	fa c8 ff d0 	sub	r8,sp,-48
800079ca:	0a 08       	add	r8,r5
800079cc:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
800079d0:	f1 69 ff d4 	st.b	r8[-44],r9
800079d4:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
800079d6:	fa c8 ff d0 	sub	r8,sp,-48
800079da:	0a 08       	add	r8,r5
800079dc:	f1 66 ff d4 	st.b	r8[-44],r6
800079e0:	2f f5       	sub	r5,-1
		} while (i < sl);
800079e2:	0e 34       	cp.w	r4,r7
800079e4:	ca 53       	brcs	8000792e <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
800079e6:	58 a5       	cp.w	r5,10
800079e8:	e0 8b 00 0c 	brhi	80007a00 <f_setlabel+0x138>
800079ec:	fa c9 ff fc 	sub	r9,sp,-4
800079f0:	f2 05 00 08 	add	r8,r9,r5
800079f4:	32 09       	mov	r9,32
800079f6:	10 c9       	st.b	r8++,r9
800079f8:	2f f5       	sub	r5,-1
800079fa:	58 a5       	cp.w	r5,10
800079fc:	fe 98 ff fd 	brls	800079f6 <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007a00:	3e 58       	mov	r8,-27
80007a02:	1b c9       	ld.ub	r9,sp[0x4]
80007a04:	f0 09 18 00 	cp.b	r9,r8
80007a08:	c6 e0       	breq	80007ae4 <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80007a0a:	30 0b       	mov	r11,0
80007a0c:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80007a0e:	fa cc ff f0 	sub	r12,sp,-16
80007a12:	f0 1f 00 3e 	mcall	80007b08 <f_setlabel+0x240>
80007a16:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007a18:	c6 81       	brne	80007ae8 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007a1a:	30 1b       	mov	r11,1
80007a1c:	fa cc ff f0 	sub	r12,sp,-16
80007a20:	f0 1f 00 3b 	mcall	80007b0c <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007a24:	c2 a1       	brne	80007a78 <f_setlabel+0x1b0>
			if (vn[0]) {
80007a26:	30 08       	mov	r8,0
80007a28:	1b c9       	ld.ub	r9,sp[0x4]
80007a2a:	f0 09 18 00 	cp.b	r9,r8
80007a2e:	c1 b0       	breq	80007a64 <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007a30:	30 ba       	mov	r10,11
80007a32:	fa cb ff fc 	sub	r11,sp,-4
80007a36:	40 9c       	lddsp	r12,sp[0x24]
80007a38:	f0 1f 00 36 	mcall	80007b10 <f_setlabel+0x248>
				tm = GET_FATTIME();
80007a3c:	f0 1f 00 36 	mcall	80007b14 <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007a40:	40 98       	lddsp	r8,sp[0x24]
80007a42:	f1 6c 00 16 	st.b	r8[22],r12
80007a46:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007a4a:	40 98       	lddsp	r8,sp[0x24]
80007a4c:	f1 69 00 17 	st.b	r8[23],r9
80007a50:	f8 09 16 10 	lsr	r9,r12,0x10
80007a54:	40 98       	lddsp	r8,sp[0x24]
80007a56:	f1 69 00 18 	st.b	r8[24],r9
80007a5a:	b9 8c       	lsr	r12,0x18
80007a5c:	40 98       	lddsp	r8,sp[0x24]
80007a5e:	f1 6c 00 19 	st.b	r8[25],r12
80007a62:	c0 48       	rjmp	80007a6a <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007a64:	3e 59       	mov	r9,-27
80007a66:	40 98       	lddsp	r8,sp[0x24]
80007a68:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
80007a6a:	30 19       	mov	r9,1
80007a6c:	40 48       	lddsp	r8,sp[0x10]
80007a6e:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007a70:	40 4c       	lddsp	r12,sp[0x10]
80007a72:	f0 1f 00 2a 	mcall	80007b18 <f_setlabel+0x250>
80007a76:	c3 a8       	rjmp	80007aea <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007a78:	58 4c       	cp.w	r12,4
80007a7a:	c3 81       	brne	80007aea <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
80007a7c:	30 08       	mov	r8,0
80007a7e:	1b c9       	ld.ub	r9,sp[0x4]
80007a80:	f0 09 18 00 	cp.b	r9,r8
80007a84:	c3 20       	breq	80007ae8 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
80007a86:	30 1b       	mov	r11,1
80007a88:	fa cc ff f0 	sub	r12,sp,-16
80007a8c:	f0 1f 00 24 	mcall	80007b1c <f_setlabel+0x254>
					if (res == FR_OK) {
80007a90:	c2 d1       	brne	80007aea <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
80007a92:	32 0a       	mov	r10,32
80007a94:	30 0b       	mov	r11,0
80007a96:	40 9c       	lddsp	r12,sp[0x24]
80007a98:	f0 1f 00 22 	mcall	80007b20 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
80007a9c:	30 ba       	mov	r10,11
80007a9e:	fa cb ff fc 	sub	r11,sp,-4
80007aa2:	40 9c       	lddsp	r12,sp[0x24]
80007aa4:	f0 1f 00 1b 	mcall	80007b10 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
80007aa8:	30 89       	mov	r9,8
80007aaa:	40 98       	lddsp	r8,sp[0x24]
80007aac:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
80007ab0:	f0 1f 00 19 	mcall	80007b14 <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007ab4:	40 98       	lddsp	r8,sp[0x24]
80007ab6:	f1 6c 00 16 	st.b	r8[22],r12
80007aba:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007abe:	40 98       	lddsp	r8,sp[0x24]
80007ac0:	f1 69 00 17 	st.b	r8[23],r9
80007ac4:	f8 09 16 10 	lsr	r9,r12,0x10
80007ac8:	40 98       	lddsp	r8,sp[0x24]
80007aca:	f1 69 00 18 	st.b	r8[24],r9
80007ace:	b9 8c       	lsr	r12,0x18
80007ad0:	40 98       	lddsp	r8,sp[0x24]
80007ad2:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
80007ad6:	30 19       	mov	r9,1
80007ad8:	40 48       	lddsp	r8,sp[0x10]
80007ada:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80007adc:	40 4c       	lddsp	r12,sp[0x10]
80007ade:	f0 1f 00 0f 	mcall	80007b18 <f_setlabel+0x250>
80007ae2:	c0 48       	rjmp	80007aea <f_setlabel+0x222>
80007ae4:	30 6c       	mov	r12,6
80007ae6:	c0 28       	rjmp	80007aea <f_setlabel+0x222>
80007ae8:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007aea:	2f 4d       	sub	sp,-48
80007aec:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007aee:	30 05       	mov	r5,0
80007af0:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007af2:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007af4:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007af6:	48 c0       	lddpc	r0,80007b24 <f_setlabel+0x25c>
80007af8:	e0 63 00 ff 	mov	r3,255
80007afc:	c1 9b       	rjmp	8000792e <f_setlabel+0x66>
80007afe:	00 00       	add	r0,r0
80007b00:	80 00       	ld.sh	r0,r0[0x0]
80007b02:	6c dc       	ld.w	r12,r6[0x34]
80007b04:	80 00       	ld.sh	r0,r0[0x0]
80007b06:	62 9a       	ld.w	r10,r1[0x24]
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	74 0c       	ld.w	r12,r10[0x0]
80007b0c:	80 00       	ld.sh	r0,r0[0x0]
80007b0e:	77 00       	ld.w	r0,r11[0x40]
80007b10:	80 00       	ld.sh	r0,r0[0x0]
80007b12:	62 78       	ld.w	r8,r1[0x1c]
80007b14:	80 00       	ld.sh	r0,r0[0x0]
80007b16:	61 b4       	ld.w	r4,r0[0x6c]
80007b18:	80 00       	ld.sh	r0,r0[0x0]
80007b1a:	64 6c       	ld.w	r12,r2[0x18]
80007b1c:	80 00       	ld.sh	r0,r0[0x0]
80007b1e:	78 60       	ld.w	r0,r12[0x18]
80007b20:	80 00       	ld.sh	r0,r0[0x0]
80007b22:	62 8e       	ld.w	lr,r1[0x20]
80007b24:	80 01       	ld.sh	r1,r0[0x0]
80007b26:	89 b8       	st.w	r4[0x2c],r8

80007b28 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007b28:	eb cd 40 c0 	pushm	r6-r7,lr
80007b2c:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007b2e:	30 1b       	mov	r11,1
80007b30:	f0 1f 00 0d 	mcall	80007b64 <dir_register+0x3c>
80007b34:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007b36:	c1 41       	brne	80007b5e <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007b38:	6c 4b       	ld.w	r11,r6[0x10]
80007b3a:	6c 0c       	ld.w	r12,r6[0x0]
80007b3c:	f0 1f 00 0b 	mcall	80007b68 <dir_register+0x40>
80007b40:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007b42:	c0 e1       	brne	80007b5e <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007b44:	32 0a       	mov	r10,32
80007b46:	30 0b       	mov	r11,0
80007b48:	6c 5c       	ld.w	r12,r6[0x14]
80007b4a:	f0 1f 00 09 	mcall	80007b6c <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007b4e:	30 ba       	mov	r10,11
80007b50:	6c 6b       	ld.w	r11,r6[0x18]
80007b52:	6c 5c       	ld.w	r12,r6[0x14]
80007b54:	f0 1f 00 07 	mcall	80007b70 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007b58:	6c 08       	ld.w	r8,r6[0x0]
80007b5a:	30 19       	mov	r9,1
80007b5c:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007b5e:	0e 9c       	mov	r12,r7
80007b60:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b64:	80 00       	ld.sh	r0,r0[0x0]
80007b66:	78 60       	ld.w	r0,r12[0x18]
80007b68:	80 00       	ld.sh	r0,r0[0x0]
80007b6a:	6c 00       	ld.w	r0,r6[0x0]
80007b6c:	80 00       	ld.sh	r0,r0[0x0]
80007b6e:	62 8e       	ld.w	lr,r1[0x20]
80007b70:	80 00       	ld.sh	r0,r0[0x0]
80007b72:	62 78       	ld.w	r8,r1[0x1c]

80007b74 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007b74:	d4 31       	pushm	r0-r7,lr
80007b76:	20 3d       	sub	sp,12
80007b78:	18 92       	mov	r2,r12
80007b7a:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007b7c:	17 88       	ld.ub	r8,r11[0x0]
80007b7e:	32 f9       	mov	r9,47
80007b80:	f2 08 18 00 	cp.b	r8,r9
80007b84:	5f 09       	sreq	r9
80007b86:	35 ca       	mov	r10,92
80007b88:	f4 08 18 00 	cp.b	r8,r10
80007b8c:	5f 08       	sreq	r8
80007b8e:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007b92:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007b96:	30 08       	mov	r8,0
80007b98:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007b9a:	0f 89       	ld.ub	r9,r7[0x0]
80007b9c:	31 f8       	mov	r8,31
80007b9e:	f0 09 18 00 	cp.b	r9,r8
80007ba2:	e0 8b 00 08 	brhi	80007bb2 <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007ba6:	30 0b       	mov	r11,0
80007ba8:	f0 1f 00 93 	mcall	80007df4 <follow_path+0x280>
		dp->dir = 0;
80007bac:	30 08       	mov	r8,0
80007bae:	85 58       	st.w	r2[0x14],r8
80007bb0:	c1 49       	rjmp	80007dd8 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007bb2:	32 f4       	mov	r4,47
80007bb4:	35 c3       	mov	r3,92
80007bb6:	30 06       	mov	r6,0
80007bb8:	0f 88       	ld.ub	r8,r7[0x0]
80007bba:	e8 08 18 00 	cp.b	r8,r4
80007bbe:	5f 09       	sreq	r9
80007bc0:	e6 08 18 00 	cp.b	r8,r3
80007bc4:	5f 08       	sreq	r8
80007bc6:	f3 e8 10 08 	or	r8,r9,r8
80007bca:	ec 08 18 00 	cp.b	r8,r6
80007bce:	c0 e0       	breq	80007bea <follow_path+0x76>
80007bd0:	2f f7       	sub	r7,-1
80007bd2:	0f 88       	ld.ub	r8,r7[0x0]
80007bd4:	e8 08 18 00 	cp.b	r8,r4
80007bd8:	5f 09       	sreq	r9
80007bda:	e6 08 18 00 	cp.b	r8,r3
80007bde:	5f 08       	sreq	r8
80007be0:	f3 e8 10 08 	or	r8,r9,r8
80007be4:	ec 08 18 00 	cp.b	r8,r6
80007be8:	cf 41       	brne	80007bd0 <follow_path+0x5c>
	sfn = dp->fn;
80007bea:	64 6a       	ld.w	r10,r2[0x18]
80007bec:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007bee:	30 ba       	mov	r10,11
80007bf0:	32 0b       	mov	r11,32
80007bf2:	40 2c       	lddsp	r12,sp[0x8]
80007bf4:	f0 1f 00 81 	mcall	80007df8 <follow_path+0x284>
80007bf8:	30 89       	mov	r9,8
80007bfa:	50 09       	stdsp	sp[0x0],r9
80007bfc:	30 08       	mov	r8,0
80007bfe:	50 18       	stdsp	sp[0x4],r8
80007c00:	10 90       	mov	r0,r8
80007c02:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007c04:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007c06:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007c0a:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007c0c:	32 09       	mov	r9,32
80007c0e:	f2 07 18 00 	cp.b	r7,r9
80007c12:	5f 88       	srls	r8
80007c14:	e8 07 18 00 	cp.b	r7,r4
80007c18:	5f 09       	sreq	r9
80007c1a:	f1 e9 10 09 	or	r9,r8,r9
80007c1e:	ec 09 18 00 	cp.b	r9,r6
80007c22:	c7 51       	brne	80007d0c <follow_path+0x198>
80007c24:	e6 07 18 00 	cp.b	r7,r3
80007c28:	c7 20       	breq	80007d0c <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007c2a:	32 e8       	mov	r8,46
80007c2c:	f0 07 18 00 	cp.b	r7,r8
80007c30:	5f 09       	sreq	r9
80007c32:	40 0a       	lddsp	r10,sp[0x0]
80007c34:	14 30       	cp.w	r0,r10
80007c36:	5f 28       	srhs	r8
80007c38:	f3 e8 10 08 	or	r8,r9,r8
80007c3c:	ec 08 18 00 	cp.b	r8,r6
80007c40:	c1 50       	breq	80007c6a <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007c42:	58 8a       	cp.w	r10,8
80007c44:	5f 19       	srne	r9
80007c46:	32 e8       	mov	r8,46
80007c48:	f0 07 18 00 	cp.b	r7,r8
80007c4c:	5f 18       	srne	r8
80007c4e:	f3 e8 10 08 	or	r8,r9,r8
80007c52:	ec 08 18 00 	cp.b	r8,r6
80007c56:	e0 81 00 be 	brne	80007dd2 <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007c5a:	40 18       	lddsp	r8,sp[0x4]
80007c5c:	a3 68       	lsl	r8,0x2
80007c5e:	5c 58       	castu.b	r8
80007c60:	50 18       	stdsp	sp[0x4],r8
80007c62:	30 ba       	mov	r10,11
80007c64:	50 0a       	stdsp	sp[0x0],r10
80007c66:	30 80       	mov	r0,8
80007c68:	cc fb       	rjmp	80007c06 <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007c6a:	ec 07 18 00 	cp.b	r7,r6
80007c6e:	c0 54       	brge	80007c78 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80007c70:	40 18       	lddsp	r8,sp[0x4]
80007c72:	e8 18 00 03 	orl	r8,0x3
80007c76:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
80007c78:	0e 98       	mov	r8,r7
80007c7a:	28 18       	sub	r8,-127
80007c7c:	37 da       	mov	r10,125
80007c7e:	f4 08 18 00 	cp.b	r8,r10
80007c82:	e0 8b 00 23 	brhi	80007cc8 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007c86:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007c8a:	f0 c9 00 40 	sub	r9,r8,64
80007c8e:	33 ea       	mov	r10,62
80007c90:	f4 09 18 00 	cp.b	r9,r10
80007c94:	5f b9       	srhi	r9
80007c96:	f0 cb 00 80 	sub	r11,r8,128
80007c9a:	37 ea       	mov	r10,126
80007c9c:	f4 0b 18 00 	cp.b	r11,r10
80007ca0:	5f ba       	srhi	r10
80007ca2:	14 69       	and	r9,r10
80007ca4:	ec 09 18 00 	cp.b	r9,r6
80007ca8:	e0 81 00 95 	brne	80007dd2 <follow_path+0x25e>
80007cac:	40 09       	lddsp	r9,sp[0x0]
80007cae:	20 19       	sub	r9,1
80007cb0:	12 30       	cp.w	r0,r9
80007cb2:	e0 82 00 90 	brhs	80007dd2 <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007cb6:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80007cb8:	40 29       	lddsp	r9,sp[0x8]
80007cba:	f2 00 0b 07 	st.b	r9[r0],r7
80007cbe:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80007cc0:	f2 00 0b 08 	st.b	r9[r0],r8
80007cc4:	2f f0       	sub	r0,-1
80007cc6:	ca 0b       	rjmp	80007c06 <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80007cc8:	0e 9b       	mov	r11,r7
80007cca:	4c dc       	lddpc	r12,80007dfc <follow_path+0x288>
80007ccc:	f0 1f 00 4d 	mcall	80007e00 <follow_path+0x28c>
80007cd0:	e0 81 00 81 	brne	80007dd2 <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
80007cd4:	0e 98       	mov	r8,r7
80007cd6:	24 18       	sub	r8,65
80007cd8:	31 99       	mov	r9,25
80007cda:	f2 08 18 00 	cp.b	r8,r9
80007cde:	e0 8b 00 06 	brhi	80007cea <follow_path+0x176>
				b |= 2;
80007ce2:	40 18       	lddsp	r8,sp[0x4]
80007ce4:	a1 b8       	sbr	r8,0x1
80007ce6:	50 18       	stdsp	sp[0x4],r8
80007ce8:	c0 d8       	rjmp	80007d02 <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80007cea:	0e 98       	mov	r8,r7
80007cec:	26 18       	sub	r8,97
80007cee:	31 9a       	mov	r10,25
80007cf0:	f4 08 18 00 	cp.b	r8,r10
80007cf4:	e0 8b 00 07 	brhi	80007d02 <follow_path+0x18e>
					b |= 1; c -= 0x20;
80007cf8:	40 19       	lddsp	r9,sp[0x4]
80007cfa:	a1 a9       	sbr	r9,0x0
80007cfc:	50 19       	stdsp	sp[0x4],r9
80007cfe:	22 07       	sub	r7,32
80007d00:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
80007d02:	40 28       	lddsp	r8,sp[0x8]
80007d04:	f0 00 0b 07 	st.b	r8[r0],r7
80007d08:	2f f0       	sub	r0,-1
80007d0a:	c7 eb       	rjmp	80007c06 <follow_path+0x92>
80007d0c:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
80007d0e:	58 08       	cp.w	r8,0
80007d10:	f9 b8 01 04 	movne	r8,4
80007d14:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80007d18:	58 00       	cp.w	r0,0
80007d1a:	c5 c0       	breq	80007dd2 <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
80007d1c:	40 29       	lddsp	r9,sp[0x8]
80007d1e:	13 8a       	ld.ub	r10,r9[0x0]
80007d20:	3e 59       	mov	r9,-27
80007d22:	f2 0a 18 00 	cp.b	r10,r9
80007d26:	f9 b9 00 05 	moveq	r9,5
80007d2a:	fb fa 00 02 	ld.weq	r10,sp[0x8]
80007d2e:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
80007d32:	40 09       	lddsp	r9,sp[0x0]
80007d34:	58 89       	cp.w	r9,8
80007d36:	c0 51       	brne	80007d40 <follow_path+0x1cc>
80007d38:	40 19       	lddsp	r9,sp[0x4]
80007d3a:	a3 69       	lsl	r9,0x2
80007d3c:	5c 59       	castu.b	r9
80007d3e:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80007d40:	40 19       	lddsp	r9,sp[0x4]
80007d42:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80007d46:	58 1a       	cp.w	r10,1
80007d48:	c0 21       	brne	80007d4c <follow_path+0x1d8>
80007d4a:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
80007d4c:	e2 19 00 0c 	andl	r9,0xc,COH
80007d50:	58 49       	cp.w	r9,4
80007d52:	c0 21       	brne	80007d56 <follow_path+0x1e2>
80007d54:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
80007d56:	40 2a       	lddsp	r10,sp[0x8]
80007d58:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
80007d5c:	30 0b       	mov	r11,0
80007d5e:	04 9c       	mov	r12,r2
80007d60:	f0 1f 00 25 	mcall	80007df4 <follow_path+0x280>
	if (res != FR_OK) return res;
80007d64:	c2 11       	brne	80007da6 <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
80007d66:	64 4b       	ld.w	r11,r2[0x10]
80007d68:	64 0c       	ld.w	r12,r2[0x0]
80007d6a:	f0 1f 00 27 	mcall	80007e04 <follow_path+0x290>
		if (res != FR_OK) break;
80007d6e:	c1 c1       	brne	80007da6 <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007d70:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007d72:	13 88       	ld.ub	r8,r9[0x0]
80007d74:	ec 08 18 00 	cp.b	r8,r6
80007d78:	c3 90       	breq	80007dea <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
80007d7a:	f3 38 00 0b 	ld.ub	r8,r9[11]
80007d7e:	e2 18 00 08 	andl	r8,0x8,COH
80007d82:	c0 d1       	brne	80007d9c <follow_path+0x228>
80007d84:	64 65       	ld.w	r5,r2[0x18]
80007d86:	c0 48       	rjmp	80007d8e <follow_path+0x21a>
80007d88:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
80007d8a:	58 b8       	cp.w	r8,11
80007d8c:	c2 80       	breq	80007ddc <follow_path+0x268>
80007d8e:	f2 08 07 0b 	ld.ub	r11,r9[r8]
80007d92:	ea 08 07 0a 	ld.ub	r10,r5[r8]
80007d96:	f4 0b 18 00 	cp.b	r11,r10
80007d9a:	cf 70       	breq	80007d88 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
80007d9c:	30 0b       	mov	r11,0
80007d9e:	04 9c       	mov	r12,r2
80007da0:	f0 1f 00 1a 	mcall	80007e08 <follow_path+0x294>
	} while (res == FR_OK);
80007da4:	ce 10       	breq	80007d66 <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007da6:	64 68       	ld.w	r8,r2[0x18]
80007da8:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
80007dac:	58 4c       	cp.w	r12,4
80007dae:	c1 51       	brne	80007dd8 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
80007db0:	e2 18 00 04 	andl	r8,0x4,COH
80007db4:	c1 10       	breq	80007dd6 <follow_path+0x262>
80007db6:	30 4c       	mov	r12,4
80007db8:	c1 08       	rjmp	80007dd8 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
80007dba:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80007dbc:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007dc0:	e2 18 00 10 	andl	r8,0x10,COH
80007dc4:	c0 90       	breq	80007dd6 <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
80007dc6:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
80007dc8:	64 0c       	ld.w	r12,r2[0x0]
80007dca:	f0 1f 00 11 	mcall	80007e0c <follow_path+0x298>
80007dce:	85 2c       	st.w	r2[0x8],r12
		}
80007dd0:	cf 4a       	rjmp	80007bb8 <follow_path+0x44>
80007dd2:	30 6c       	mov	r12,6
80007dd4:	c0 28       	rjmp	80007dd8 <follow_path+0x264>
80007dd6:	30 5c       	mov	r12,5
	}

	return res;
}
80007dd8:	2f dd       	sub	sp,-12
80007dda:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007ddc:	64 68       	ld.w	r8,r2[0x18]
80007dde:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007de2:	e2 18 00 04 	andl	r8,0x4,COH
80007de6:	ce a0       	breq	80007dba <follow_path+0x246>
80007de8:	cf 8b       	rjmp	80007dd8 <follow_path+0x264>
80007dea:	64 68       	ld.w	r8,r2[0x18]
80007dec:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007df0:	ce 0b       	rjmp	80007db0 <follow_path+0x23c>
80007df2:	00 00       	add	r0,r0
80007df4:	80 00       	ld.sh	r0,r0[0x0]
80007df6:	74 0c       	ld.w	r12,r10[0x0]
80007df8:	80 00       	ld.sh	r0,r0[0x0]
80007dfa:	62 8e       	ld.w	lr,r1[0x20]
80007dfc:	80 01       	ld.sh	r1,r0[0x0]
80007dfe:	89 c8       	st.w	r4[0x30],r8
80007e00:	80 00       	ld.sh	r0,r0[0x0]
80007e02:	62 9a       	ld.w	r10,r1[0x24]
80007e04:	80 00       	ld.sh	r0,r0[0x0]
80007e06:	6c 00       	ld.w	r0,r6[0x0]
80007e08:	80 00       	ld.sh	r0,r0[0x0]
80007e0a:	75 90       	ld.w	r0,r10[0x64]
80007e0c:	80 00       	ld.sh	r0,r0[0x0]
80007e0e:	63 0a       	ld.w	r10,r1[0x40]

80007e10 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80007e10:	eb cd 40 80 	pushm	r7,lr
80007e14:	20 5d       	sub	sp,20
80007e16:	18 97       	mov	r7,r12
80007e18:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
80007e1a:	58 0c       	cp.w	r12,0
80007e1c:	c0 31       	brne	80007e22 <f_opendir+0x12>
80007e1e:	30 9c       	mov	r12,9
80007e20:	c2 d8       	rjmp	80007e7a <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
80007e22:	30 0a       	mov	r10,0
80007e24:	1a 9b       	mov	r11,sp
80007e26:	fa cc ff f0 	sub	r12,sp,-16
80007e2a:	f0 1f 00 17 	mcall	80007e84 <f_opendir+0x74>
	if (res == FR_OK) {
80007e2e:	c2 41       	brne	80007e76 <f_opendir+0x66>
		dp->fs = fs;
80007e30:	40 48       	lddsp	r8,sp[0x10]
80007e32:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
80007e34:	fa c8 ff fc 	sub	r8,sp,-4
80007e38:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
80007e3a:	40 0b       	lddsp	r11,sp[0x0]
80007e3c:	0e 9c       	mov	r12,r7
80007e3e:	f0 1f 00 13 	mcall	80007e88 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
80007e42:	c1 61       	brne	80007e6e <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
80007e44:	6e 5b       	ld.w	r11,r7[0x14]
80007e46:	58 0b       	cp.w	r11,0
80007e48:	c0 c0       	breq	80007e60 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
80007e4a:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007e4e:	e2 18 00 10 	andl	r8,0x10,COH
80007e52:	c0 31       	brne	80007e58 <f_opendir+0x48>
80007e54:	30 5c       	mov	r12,5
80007e56:	c0 e8       	rjmp	80007e72 <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
80007e58:	40 4c       	lddsp	r12,sp[0x10]
80007e5a:	f0 1f 00 0d 	mcall	80007e8c <f_opendir+0x7c>
80007e5e:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
80007e60:	40 48       	lddsp	r8,sp[0x10]
80007e62:	90 38       	ld.sh	r8,r8[0x6]
80007e64:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
80007e66:	30 0b       	mov	r11,0
80007e68:	0e 9c       	mov	r12,r7
80007e6a:	f0 1f 00 0a 	mcall	80007e90 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
80007e6e:	58 4c       	cp.w	r12,4
80007e70:	c0 80       	breq	80007e80 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007e72:	58 0c       	cp.w	r12,0
80007e74:	c0 30       	breq	80007e7a <f_opendir+0x6a>
80007e76:	30 08       	mov	r8,0
80007e78:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
80007e7a:	2f bd       	sub	sp,-20
80007e7c:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007e80:	30 5c       	mov	r12,5
80007e82:	cf ab       	rjmp	80007e76 <f_opendir+0x66>
80007e84:	80 00       	ld.sh	r0,r0[0x0]
80007e86:	6c dc       	ld.w	r12,r6[0x34]
80007e88:	80 00       	ld.sh	r0,r0[0x0]
80007e8a:	7b 74       	ld.w	r4,sp[0x5c]
80007e8c:	80 00       	ld.sh	r0,r0[0x0]
80007e8e:	63 0a       	ld.w	r10,r1[0x40]
80007e90:	80 00       	ld.sh	r0,r0[0x0]
80007e92:	74 0c       	ld.w	r12,r10[0x0]

80007e94 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
80007e94:	d4 31       	pushm	r0-r7,lr
80007e96:	21 0d       	sub	sp,64
80007e98:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
80007e9a:	f0 1f 00 61 	mcall	8000801c <f_mkdir+0x188>
80007e9e:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
80007ea0:	30 1a       	mov	r10,1
80007ea2:	fa cb ff f0 	sub	r11,sp,-16
80007ea6:	fa cc ff e0 	sub	r12,sp,-32
80007eaa:	f0 1f 00 5e 	mcall	80008020 <f_mkdir+0x18c>
80007eae:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007eb0:	c0 30       	breq	80007eb6 <f_mkdir+0x22>
80007eb2:	18 96       	mov	r6,r12
80007eb4:	ca 78       	rjmp	80008002 <f_mkdir+0x16e>
		INIT_BUF(dj);
80007eb6:	fa c8 ff ec 	sub	r8,sp,-20
80007eba:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80007ebc:	40 4b       	lddsp	r11,sp[0x10]
80007ebe:	fa cc ff e0 	sub	r12,sp,-32
80007ec2:	f0 1f 00 59 	mcall	80008024 <f_mkdir+0x190>
80007ec6:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
80007ec8:	c0 31       	brne	80007ece <f_mkdir+0x3a>
80007eca:	30 86       	mov	r6,8
80007ecc:	c9 b8       	rjmp	80008002 <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80007ece:	58 4c       	cp.w	r12,4
80007ed0:	e0 81 00 99 	brne	80008002 <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
80007ed4:	30 0b       	mov	r11,0
80007ed6:	40 8c       	lddsp	r12,sp[0x20]
80007ed8:	f0 1f 00 54 	mcall	80008028 <f_mkdir+0x194>
80007edc:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80007ede:	c0 31       	brne	80007ee4 <f_mkdir+0x50>
80007ee0:	30 77       	mov	r7,7
80007ee2:	c0 88       	rjmp	80007ef2 <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
80007ee4:	58 1c       	cp.w	r12,1
80007ee6:	c0 31       	brne	80007eec <f_mkdir+0x58>
80007ee8:	30 27       	mov	r7,2
80007eea:	c6 c8       	rjmp	80007fc2 <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80007eec:	5b fc       	cp.w	r12,-1
80007eee:	e0 80 00 8d 	breq	80008008 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
80007ef2:	58 07       	cp.w	r7,0
80007ef4:	c6 71       	brne	80007fc2 <f_mkdir+0x12e>
				res = sync_window(dj.fs);
80007ef6:	40 8c       	lddsp	r12,sp[0x20]
80007ef8:	f0 1f 00 4d 	mcall	8000802c <f_mkdir+0x198>
80007efc:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80007efe:	c6 21       	brne	80007fc2 <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80007f00:	40 87       	lddsp	r7,sp[0x20]
80007f02:	04 9b       	mov	r11,r2
80007f04:	0e 9c       	mov	r12,r7
80007f06:	f0 1f 00 4b 	mcall	80008030 <f_mkdir+0x19c>
80007f0a:	18 94       	mov	r4,r12
				dir = dj.fs->win;
80007f0c:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80007f10:	e0 6a 02 00 	mov	r10,512
80007f14:	30 0b       	mov	r11,0
80007f16:	06 9c       	mov	r12,r3
80007f18:	f0 1f 00 47 	mcall	80008034 <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
80007f1c:	30 ba       	mov	r10,11
80007f1e:	32 0b       	mov	r11,32
80007f20:	06 9c       	mov	r12,r3
80007f22:	f0 1f 00 45 	mcall	80008034 <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
80007f26:	32 e6       	mov	r6,46
80007f28:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
80007f2c:	31 08       	mov	r8,16
80007f2e:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
80007f32:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80007f36:	50 38       	stdsp	sp[0xc],r8
80007f38:	e7 68 00 16 	st.b	r3[22],r8
80007f3c:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80007f40:	50 28       	stdsp	sp[0x8],r8
80007f42:	e7 68 00 17 	st.b	r3[23],r8
80007f46:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
80007f4a:	50 18       	stdsp	sp[0x4],r8
80007f4c:	e7 68 00 18 	st.b	r3[24],r8
80007f50:	b9 85       	lsr	r5,0x18
80007f52:	50 05       	stdsp	sp[0x0],r5
80007f54:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
80007f58:	04 9b       	mov	r11,r2
80007f5a:	06 9c       	mov	r12,r3
80007f5c:	f0 1f 00 37 	mcall	80008038 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
80007f60:	2b 07       	sub	r7,-80
80007f62:	32 0a       	mov	r10,32
80007f64:	06 9b       	mov	r11,r3
80007f66:	0e 9c       	mov	r12,r7
80007f68:	f0 1f 00 35 	mcall	8000803c <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
80007f6c:	e7 66 00 21 	st.b	r3[33],r6
80007f70:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
80007f72:	40 88       	lddsp	r8,sp[0x20]
80007f74:	11 8a       	ld.ub	r10,r8[0x0]
80007f76:	30 39       	mov	r9,3
80007f78:	f2 0a 18 00 	cp.b	r10,r9
80007f7c:	c0 51       	brne	80007f86 <f_mkdir+0xf2>
80007f7e:	70 98       	ld.w	r8,r8[0x24]
80007f80:	16 38       	cp.w	r8,r11
80007f82:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
80007f86:	0e 9c       	mov	r12,r7
80007f88:	f0 1f 00 2c 	mcall	80008038 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80007f8c:	40 88       	lddsp	r8,sp[0x20]
80007f8e:	11 a6       	ld.ub	r6,r8[0x2]
80007f90:	58 06       	cp.w	r6,0
80007f92:	c3 d0       	breq	8000800c <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
80007f94:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
80007f96:	e0 61 02 00 	mov	r1,512
80007f9a:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
80007f9c:	40 88       	lddsp	r8,sp[0x20]
80007f9e:	91 b4       	st.w	r8[0x2c],r4
80007fa0:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
80007fa2:	40 88       	lddsp	r8,sp[0x20]
80007fa4:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
80007fa6:	40 8c       	lddsp	r12,sp[0x20]
80007fa8:	f0 1f 00 21 	mcall	8000802c <f_mkdir+0x198>
					if (res != FR_OK) break;
80007fac:	c0 a1       	brne	80007fc0 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
80007fae:	02 9a       	mov	r10,r1
80007fb0:	00 9b       	mov	r11,r0
80007fb2:	06 9c       	mov	r12,r3
80007fb4:	f0 1f 00 20 	mcall	80008034 <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80007fb8:	20 16       	sub	r6,1
80007fba:	5c 56       	castu.b	r6
80007fbc:	cf 01       	brne	80007f9c <f_mkdir+0x108>
80007fbe:	c2 78       	rjmp	8000800c <f_mkdir+0x178>
80007fc0:	18 97       	mov	r7,r12
80007fc2:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
80007fc4:	04 9b       	mov	r11,r2
80007fc6:	40 8c       	lddsp	r12,sp[0x20]
80007fc8:	f0 1f 00 1e 	mcall	80008040 <f_mkdir+0x1ac>
80007fcc:	c1 b8       	rjmp	80008002 <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
80007fce:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
80007fd0:	31 08       	mov	r8,16
80007fd2:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
80007fd6:	40 38       	lddsp	r8,sp[0xc]
80007fd8:	f9 68 00 16 	st.b	r12[22],r8
80007fdc:	40 28       	lddsp	r8,sp[0x8]
80007fde:	f9 68 00 17 	st.b	r12[23],r8
80007fe2:	40 18       	lddsp	r8,sp[0x4]
80007fe4:	f9 68 00 18 	st.b	r12[24],r8
80007fe8:	40 08       	lddsp	r8,sp[0x0]
80007fea:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
80007fee:	04 9b       	mov	r11,r2
80007ff0:	f0 1f 00 12 	mcall	80008038 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
80007ff4:	30 19       	mov	r9,1
80007ff6:	40 88       	lddsp	r8,sp[0x20]
80007ff8:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
80007ffa:	40 8c       	lddsp	r12,sp[0x20]
80007ffc:	f0 1f 00 12 	mcall	80008044 <f_mkdir+0x1b0>
80008000:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
80008002:	0c 9c       	mov	r12,r6
80008004:	2f 0d       	sub	sp,-64
80008006:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80008008:	30 17       	mov	r7,1
8000800a:	cd cb       	rjmp	80007fc2 <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
8000800c:	fa cc ff e0 	sub	r12,sp,-32
80008010:	f0 1f 00 0e 	mcall	80008048 <f_mkdir+0x1b4>
80008014:	18 96       	mov	r6,r12
			if (res != FR_OK) {
80008016:	cd c0       	breq	80007fce <f_mkdir+0x13a>
80008018:	cd 6b       	rjmp	80007fc4 <f_mkdir+0x130>
8000801a:	00 00       	add	r0,r0
8000801c:	80 00       	ld.sh	r0,r0[0x0]
8000801e:	61 b4       	ld.w	r4,r0[0x6c]
80008020:	80 00       	ld.sh	r0,r0[0x0]
80008022:	6c dc       	ld.w	r12,r6[0x34]
80008024:	80 00       	ld.sh	r0,r0[0x0]
80008026:	7b 74       	ld.w	r4,sp[0x5c]
80008028:	80 00       	ld.sh	r0,r0[0x0]
8000802a:	74 c0       	ld.w	r0,r10[0x30]
8000802c:	80 00       	ld.sh	r0,r0[0x0]
8000802e:	64 08       	ld.w	r8,r2[0x0]
80008030:	80 00       	ld.sh	r0,r0[0x0]
80008032:	62 b4       	ld.w	r4,r1[0x2c]
80008034:	80 00       	ld.sh	r0,r0[0x0]
80008036:	62 8e       	ld.w	lr,r1[0x20]
80008038:	80 00       	ld.sh	r0,r0[0x0]
8000803a:	63 32       	ld.w	r2,r1[0x4c]
8000803c:	80 00       	ld.sh	r0,r0[0x0]
8000803e:	62 78       	ld.w	r8,r1[0x1c]
80008040:	80 00       	ld.sh	r0,r0[0x0]
80008042:	76 a0       	ld.w	r0,r11[0x28]
80008044:	80 00       	ld.sh	r0,r0[0x0]
80008046:	64 6c       	ld.w	r12,r2[0x18]
80008048:	80 00       	ld.sh	r0,r0[0x0]
8000804a:	7b 28       	ld.w	r8,sp[0x48]

8000804c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
8000804c:	eb cd 40 fc 	pushm	r2-r7,lr
80008050:	20 cd       	sub	sp,48
80008052:	18 97       	mov	r7,r12
80008054:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
80008056:	58 0c       	cp.w	r12,0
80008058:	c0 31       	brne	8000805e <f_open+0x12>
8000805a:	30 96       	mov	r6,9
8000805c:	cb 68       	rjmp	800081c8 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
8000805e:	30 08       	mov	r8,0
80008060:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
80008062:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
80008066:	0a 93       	mov	r3,r5
80008068:	e2 1a 00 1e 	andl	r10,0x1e,COH
8000806c:	1a 9b       	mov	r11,sp
8000806e:	fa cc ff f0 	sub	r12,sp,-16
80008072:	f0 1f 00 5c 	mcall	800081e0 <f_open+0x194>
80008076:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
80008078:	e0 81 00 a8 	brne	800081c8 <f_open+0x17c>
		INIT_BUF(dj);
8000807c:	fa c8 ff fc 	sub	r8,sp,-4
80008080:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
80008082:	40 0b       	lddsp	r11,sp[0x0]
80008084:	fa cc ff f0 	sub	r12,sp,-16
80008088:	f0 1f 00 57 	mcall	800081e4 <f_open+0x198>
		dir = dj.dir;
8000808c:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
8000808e:	c0 41       	brne	80008096 <f_open+0x4a>
			if (!dir)	/* Default directory itself */
80008090:	58 04       	cp.w	r4,0
80008092:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
80008096:	06 98       	mov	r8,r3
80008098:	e2 18 00 1c 	andl	r8,0x1c,COH
8000809c:	c5 f0       	breq	8000815a <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
8000809e:	58 0c       	cp.w	r12,0
800080a0:	c0 d0       	breq	800080ba <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
800080a2:	58 4c       	cp.w	r12,4
800080a4:	e0 81 00 91 	brne	800081c6 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
800080a8:	fa cc ff f0 	sub	r12,sp,-16
800080ac:	f0 1f 00 4f 	mcall	800081e8 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
800080b0:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
800080b2:	e0 81 00 8a 	brne	800081c6 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
800080b6:	a3 b5       	sbr	r5,0x3
800080b8:	c0 c8       	rjmp	800080d0 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
800080ba:	e9 38 00 0b 	ld.ub	r8,r4[11]
800080be:	e2 18 00 11 	andl	r8,0x11,COH
800080c2:	c0 30       	breq	800080c8 <f_open+0x7c>
800080c4:	30 7c       	mov	r12,7
800080c6:	c8 08       	rjmp	800081c6 <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
800080c8:	e2 13 00 04 	andl	r3,0x4,COH
800080cc:	e0 81 00 82 	brne	800081d0 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
800080d0:	0a 98       	mov	r8,r5
800080d2:	e2 18 00 08 	andl	r8,0x8,COH
800080d6:	c7 f0       	breq	800081d4 <f_open+0x188>
				dw = GET_FATTIME();
800080d8:	f0 1f 00 45 	mcall	800081ec <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
800080dc:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
800080e0:	e9 6a 00 0e 	st.b	r4[14],r10
800080e4:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
800080e8:	e9 69 00 0f 	st.b	r4[15],r9
800080ec:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
800080f0:	e9 68 00 10 	st.b	r4[16],r8
800080f4:	b9 8c       	lsr	r12,0x18
800080f6:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
800080fa:	e9 6a 00 16 	st.b	r4[22],r10
800080fe:	e9 69 00 17 	st.b	r4[23],r9
80008102:	e9 68 00 18 	st.b	r4[24],r8
80008106:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
8000810a:	30 08       	mov	r8,0
8000810c:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
80008110:	e9 68 00 1c 	st.b	r4[28],r8
80008114:	e9 68 00 1d 	st.b	r4[29],r8
80008118:	e9 68 00 1e 	st.b	r4[30],r8
8000811c:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
80008120:	08 9b       	mov	r11,r4
80008122:	40 4c       	lddsp	r12,sp[0x10]
80008124:	f0 1f 00 33 	mcall	800081f0 <f_open+0x1a4>
80008128:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
8000812a:	30 0b       	mov	r11,0
8000812c:	08 9c       	mov	r12,r4
8000812e:	f0 1f 00 32 	mcall	800081f4 <f_open+0x1a8>
				dj.fs->wflag = 1;
80008132:	30 19       	mov	r9,1
80008134:	40 48       	lddsp	r8,sp[0x10]
80008136:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
80008138:	58 03       	cp.w	r3,0
8000813a:	c4 d0       	breq	800081d4 <f_open+0x188>
					dw = dj.fs->winsect;
8000813c:	40 4c       	lddsp	r12,sp[0x10]
8000813e:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
80008140:	06 9b       	mov	r11,r3
80008142:	f0 1f 00 2e 	mcall	800081f8 <f_open+0x1ac>
					if (res == FR_OK) {
80008146:	c4 01       	brne	800081c6 <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
80008148:	20 13       	sub	r3,1
8000814a:	40 48       	lddsp	r8,sp[0x10]
8000814c:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
8000814e:	04 9b       	mov	r11,r2
80008150:	40 4c       	lddsp	r12,sp[0x10]
80008152:	f0 1f 00 2b 	mcall	800081fc <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
80008156:	c1 40       	breq	8000817e <f_open+0x132>
80008158:	c3 78       	rjmp	800081c6 <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
8000815a:	58 0c       	cp.w	r12,0
8000815c:	c3 51       	brne	800081c6 <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
8000815e:	e9 38 00 0b 	ld.ub	r8,r4[11]
80008162:	10 99       	mov	r9,r8
80008164:	e2 19 00 10 	andl	r9,0x10,COH
80008168:	c0 30       	breq	8000816e <f_open+0x122>
8000816a:	30 4c       	mov	r12,4
8000816c:	c2 d8       	rjmp	800081c6 <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
8000816e:	e2 13 00 02 	andl	r3,0x2,COH
80008172:	c3 10       	breq	800081d4 <f_open+0x188>
80008174:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008178:	c2 e0       	breq	800081d4 <f_open+0x188>
8000817a:	30 7c       	mov	r12,7
8000817c:	c2 58       	rjmp	800081c6 <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
8000817e:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
80008180:	40 43       	lddsp	r3,sp[0x10]
80008182:	66 b8       	ld.w	r8,r3[0x2c]
80008184:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
80008186:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
80008188:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
8000818a:	30 08       	mov	r8,0
8000818c:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
8000818e:	08 9b       	mov	r11,r4
80008190:	06 9c       	mov	r12,r3
80008192:	f0 1f 00 18 	mcall	800081f0 <f_open+0x1a4>
80008196:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
80008198:	e9 39 00 1f 	ld.ub	r9,r4[31]
8000819c:	e9 38 00 1e 	ld.ub	r8,r4[30]
800081a0:	b1 68       	lsl	r8,0x10
800081a2:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800081a6:	e9 39 00 1c 	ld.ub	r9,r4[28]
800081aa:	12 48       	or	r8,r9
800081ac:	e9 39 00 1d 	ld.ub	r9,r4[29]
800081b0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800081b4:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
800081b6:	30 08       	mov	r8,0
800081b8:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
800081ba:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
800081bc:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
800081be:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
800081c0:	86 38       	ld.sh	r8,r3[0x6]
800081c2:	ae 28       	st.h	r7[0x4],r8
800081c4:	c0 28       	rjmp	800081c8 <f_open+0x17c>
800081c6:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
800081c8:	0c 9c       	mov	r12,r6
800081ca:	2f 4d       	sub	sp,-48
800081cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
800081d0:	30 8c       	mov	r12,8
800081d2:	cf ab       	rjmp	800081c6 <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
800081d4:	0a 98       	mov	r8,r5
800081d6:	e2 18 00 08 	andl	r8,0x8,COH
800081da:	cd 30       	breq	80008180 <f_open+0x134>
800081dc:	cd 1b       	rjmp	8000817e <f_open+0x132>
800081de:	00 00       	add	r0,r0
800081e0:	80 00       	ld.sh	r0,r0[0x0]
800081e2:	6c dc       	ld.w	r12,r6[0x34]
800081e4:	80 00       	ld.sh	r0,r0[0x0]
800081e6:	7b 74       	ld.w	r4,sp[0x5c]
800081e8:	80 00       	ld.sh	r0,r0[0x0]
800081ea:	7b 28       	ld.w	r8,sp[0x48]
800081ec:	80 00       	ld.sh	r0,r0[0x0]
800081ee:	61 b4       	ld.w	r4,r0[0x6c]
800081f0:	80 00       	ld.sh	r0,r0[0x0]
800081f2:	63 0a       	ld.w	r10,r1[0x40]
800081f4:	80 00       	ld.sh	r0,r0[0x0]
800081f6:	63 32       	ld.w	r2,r1[0x4c]
800081f8:	80 00       	ld.sh	r0,r0[0x0]
800081fa:	76 a0       	ld.w	r0,r11[0x28]
800081fc:	80 00       	ld.sh	r0,r0[0x0]
800081fe:	6c 00       	ld.w	r0,r6[0x0]

80008200 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008200:	d4 31       	pushm	r0-r7,lr
80008202:	20 2d       	sub	sp,8
80008204:	fa c7 ff f8 	sub	r7,sp,-8
80008208:	0e dc       	st.w	--r7,r12
8000820a:	16 90       	mov	r0,r11
8000820c:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
8000820e:	30 0a       	mov	r10,0
80008210:	0e 9b       	mov	r11,r7
80008212:	0c 9c       	mov	r12,r6
80008214:	f0 1f 00 33 	mcall	800082e0 <f_getfree+0xe0>
80008218:	18 93       	mov	r3,r12
	fs = *fatfs;
8000821a:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
8000821c:	c5 f1       	brne	800082da <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
8000821e:	6c 48       	ld.w	r8,r6[0x10]
80008220:	6c 57       	ld.w	r7,r6[0x14]
80008222:	ee c9 00 02 	sub	r9,r7,2
80008226:	12 38       	cp.w	r8,r9
80008228:	e0 8b 00 04 	brhi	80008230 <f_getfree+0x30>
			*nclst = fs->free_clust;
8000822c:	81 08       	st.w	r0[0x0],r8
8000822e:	c5 68       	rjmp	800082da <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
80008230:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
80008232:	30 18       	mov	r8,1
80008234:	f0 04 18 00 	cp.b	r4,r8
80008238:	c1 71       	brne	80008266 <f_getfree+0x66>
8000823a:	30 27       	mov	r7,2
8000823c:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
8000823e:	0e 9b       	mov	r11,r7
80008240:	0c 9c       	mov	r12,r6
80008242:	f0 1f 00 29 	mcall	800082e4 <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
80008246:	5b fc       	cp.w	r12,-1
80008248:	c0 31       	brne	8000824e <f_getfree+0x4e>
8000824a:	30 1c       	mov	r12,1
8000824c:	c4 28       	rjmp	800082d0 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
8000824e:	58 1c       	cp.w	r12,1
80008250:	c0 31       	brne	80008256 <f_getfree+0x56>
80008252:	30 2c       	mov	r12,2
80008254:	c3 e8       	rjmp	800082d0 <f_getfree+0xd0>
					if (stat == 0) nfree++;
80008256:	58 0c       	cp.w	r12,0
80008258:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
8000825c:	2f f7       	sub	r7,-1
8000825e:	6c 58       	ld.w	r8,r6[0x14]
80008260:	10 37       	cp.w	r7,r8
80008262:	ce e3       	brcs	8000823e <f_getfree+0x3e>
80008264:	c3 58       	rjmp	800082ce <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
80008266:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
80008268:	30 08       	mov	r8,0
8000826a:	10 99       	mov	r9,r8
8000826c:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
8000826e:	ec ca ff d0 	sub	r10,r6,-48
80008272:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
80008274:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
80008276:	58 09       	cp.w	r9,0
80008278:	c0 a1       	brne	8000828c <f_getfree+0x8c>
						res = move_window(fs, sect++);
8000827a:	02 9b       	mov	r11,r1
8000827c:	0c 9c       	mov	r12,r6
8000827e:	f0 1f 00 1b 	mcall	800082e8 <f_getfree+0xe8>
						if (res != FR_OK) break;
80008282:	c2 71       	brne	800082d0 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
80008284:	2f f1       	sub	r1,-1
80008286:	40 08       	lddsp	r8,sp[0x0]
80008288:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
8000828c:	e4 04 18 00 	cp.b	r4,r2
80008290:	c0 d1       	brne	800082aa <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
80008292:	11 9b       	ld.ub	r11,r8[0x1]
80008294:	11 8a       	ld.ub	r10,r8[0x0]
80008296:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000829a:	30 0b       	mov	r11,0
8000829c:	f6 0a 19 00 	cp.h	r10,r11
800082a0:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
800082a4:	2f e8       	sub	r8,-2
800082a6:	20 29       	sub	r9,2
800082a8:	c1 18       	rjmp	800082ca <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
800082aa:	11 bb       	ld.ub	r11,r8[0x3]
800082ac:	11 aa       	ld.ub	r10,r8[0x2]
800082ae:	b1 6a       	lsl	r10,0x10
800082b0:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
800082b4:	11 8b       	ld.ub	r11,r8[0x0]
800082b6:	16 4a       	or	r10,r11
800082b8:	11 9b       	ld.ub	r11,r8[0x1]
800082ba:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800082be:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
800082c2:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
800082c6:	2f c8       	sub	r8,-4
800082c8:	20 49       	sub	r9,4
					}
				} while (--clst);
800082ca:	20 17       	sub	r7,1
800082cc:	cd 51       	brne	80008276 <f_getfree+0x76>
800082ce:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
800082d0:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
800082d2:	0d d8       	ld.ub	r8,r6[0x5]
800082d4:	a1 a8       	sbr	r8,0x0
800082d6:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
800082d8:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
800082da:	2f ed       	sub	sp,-8
800082dc:	d8 32       	popm	r0-r7,pc
800082de:	00 00       	add	r0,r0
800082e0:	80 00       	ld.sh	r0,r0[0x0]
800082e2:	6c dc       	ld.w	r12,r6[0x34]
800082e4:	80 00       	ld.sh	r0,r0[0x0]
800082e6:	73 28       	ld.w	r8,r9[0x48]
800082e8:	80 00       	ld.sh	r0,r0[0x0]
800082ea:	6c 00       	ld.w	r0,r6[0x0]

800082ec <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
800082ec:	d4 31       	pushm	r0-r7,lr
800082ee:	18 97       	mov	r7,r12
800082f0:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
800082f2:	f0 1f 00 a5 	mcall	80008584 <f_lseek+0x298>
800082f6:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
800082f8:	e0 81 01 44 	brne	80008580 <f_lseek+0x294>
	if (fp->err)						/* Check error */
800082fc:	0f f8       	ld.ub	r8,r7[0x7]
800082fe:	58 08       	cp.w	r8,0
80008300:	c0 30       	breq	80008306 <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008302:	10 96       	mov	r6,r8
80008304:	c3 e9       	rjmp	80008580 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
80008306:	6e 93       	ld.w	r3,r7[0x24]
80008308:	58 03       	cp.w	r3,0
8000830a:	e0 80 00 85 	breq	80008414 <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
8000830e:	5b f5       	cp.w	r5,-1
80008310:	c3 71       	brne	8000837e <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
80008312:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
80008314:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
80008316:	58 01       	cp.w	r1,0
80008318:	c2 80       	breq	80008368 <f_lseek+0x7c>
8000831a:	30 22       	mov	r2,2
8000831c:	02 95       	mov	r5,r1
8000831e:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
80008320:	0a 9b       	mov	r11,r5
80008322:	6e 0c       	ld.w	r12,r7[0x0]
80008324:	f0 1f 00 99 	mcall	80008588 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008328:	58 1c       	cp.w	r12,1
8000832a:	e0 8b 00 06 	brhi	80008336 <f_lseek+0x4a>
8000832e:	30 28       	mov	r8,2
80008330:	ae f8       	st.b	r7[0x7],r8
80008332:	30 26       	mov	r6,2
80008334:	c2 69       	rjmp	80008580 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008336:	5b fc       	cp.w	r12,-1
80008338:	c0 51       	brne	80008342 <f_lseek+0x56>
8000833a:	30 18       	mov	r8,1
8000833c:	ae f8       	st.b	r7[0x7],r8
8000833e:	30 16       	mov	r6,1
80008340:	c2 09       	rjmp	80008580 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
80008342:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
80008344:	2f f5       	sub	r5,-1
80008346:	0a 3c       	cp.w	r12,r5
80008348:	c0 31       	brne	8000834e <f_lseek+0x62>
8000834a:	18 95       	mov	r5,r12
8000834c:	ce ab       	rjmp	80008320 <f_lseek+0x34>
8000834e:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
80008350:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
80008352:	04 30       	cp.w	r0,r2
80008354:	c0 33       	brcs	8000835a <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
80008356:	06 a4       	st.w	r3++,r4
80008358:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
8000835a:	6e 09       	ld.w	r9,r7[0x0]
8000835c:	72 59       	ld.w	r9,r9[0x14]
8000835e:	10 39       	cp.w	r9,r8
80008360:	e0 88 00 05 	brls	8000836a <f_lseek+0x7e>
80008364:	18 91       	mov	r1,r12
80008366:	cd bb       	rjmp	8000831c <f_lseek+0x30>
80008368:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
8000836a:	6e 98       	ld.w	r8,r7[0x24]
8000836c:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
8000836e:	00 32       	cp.w	r2,r0
80008370:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
80008374:	f9 b8 08 00 	movls	r8,0
80008378:	e7 f8 8a 00 	st.wls	r3[0x0],r8
8000837c:	c0 29       	rjmp	80008580 <f_lseek+0x294>
8000837e:	6e 34       	ld.w	r4,r7[0xc]
80008380:	08 35       	cp.w	r5,r4
80008382:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
80008386:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
80008388:	58 05       	cp.w	r5,0
8000838a:	e0 80 00 fb 	breq	80008580 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
8000838e:	ea c4 00 01 	sub	r4,r5,1
80008392:	08 9b       	mov	r11,r4
80008394:	0e 9c       	mov	r12,r7
80008396:	f0 1f 00 7e 	mcall	8000858c <f_lseek+0x2a0>
8000839a:	18 9b       	mov	r11,r12
8000839c:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
8000839e:	6e 05       	ld.w	r5,r7[0x0]
800083a0:	0a 9c       	mov	r12,r5
800083a2:	f0 1f 00 7c 	mcall	80008590 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
800083a6:	c0 51       	brne	800083b0 <f_lseek+0xc4>
800083a8:	30 28       	mov	r8,2
800083aa:	ae f8       	st.b	r7[0x7],r8
800083ac:	30 26       	mov	r6,2
800083ae:	ce 98       	rjmp	80008580 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800083b0:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800083b2:	6e 28       	ld.w	r8,r7[0x8]
800083b4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800083b8:	e0 80 00 e4 	breq	80008580 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800083bc:	20 19       	sub	r9,1
800083be:	f3 e4 02 94 	and	r4,r9,r4>>0x9
800083c2:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800083c6:	6e 6a       	ld.w	r10,r7[0x18]
800083c8:	08 3a       	cp.w	r10,r4
800083ca:	e0 80 00 db 	breq	80008580 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
800083ce:	0f e8       	ld.ub	r8,r7[0x6]
800083d0:	e2 18 00 40 	andl	r8,0x40,COH
800083d4:	c0 f0       	breq	800083f2 <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800083d6:	30 19       	mov	r9,1
800083d8:	ee cb ff d8 	sub	r11,r7,-40
800083dc:	0b 9c       	ld.ub	r12,r5[0x1]
800083de:	f0 1f 00 6e 	mcall	80008594 <f_lseek+0x2a8>
800083e2:	c0 50       	breq	800083ec <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
800083e4:	30 18       	mov	r8,1
800083e6:	ae f8       	st.b	r7[0x7],r8
800083e8:	30 16       	mov	r6,1
800083ea:	cc b8       	rjmp	80008580 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
800083ec:	0f e8       	ld.ub	r8,r7[0x6]
800083ee:	a7 c8       	cbr	r8,0x6
800083f0:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
800083f2:	6e 08       	ld.w	r8,r7[0x0]
800083f4:	30 19       	mov	r9,1
800083f6:	08 9a       	mov	r10,r4
800083f8:	ee cb ff d8 	sub	r11,r7,-40
800083fc:	11 9c       	ld.ub	r12,r8[0x1]
800083fe:	f0 1f 00 67 	mcall	80008598 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
80008402:	f9 b8 01 01 	movne	r8,1
80008406:	ef f8 1e 07 	st.bne	r7[0x7],r8
8000840a:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
8000840e:	ef f4 0a 06 	st.weq	r7[0x18],r4
80008412:	cb 78       	rjmp	80008580 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008414:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
80008416:	08 35       	cp.w	r5,r4
80008418:	e0 88 00 06 	brls	80008424 <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
8000841c:	0f e8       	ld.ub	r8,r7[0x6]
8000841e:	e2 18 00 02 	andl	r8,0x2,COH
80008422:	c0 20       	breq	80008426 <f_lseek+0x13a>
80008424:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
80008426:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008428:	30 08       	mov	r8,0
8000842a:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
8000842c:	58 04       	cp.w	r4,0
8000842e:	e0 80 00 a9 	breq	80008580 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
80008432:	6e 08       	ld.w	r8,r7[0x0]
80008434:	11 a5       	ld.ub	r5,r8[0x2]
80008436:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
80008438:	58 09       	cp.w	r9,0
8000843a:	c1 30       	breq	80008460 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
8000843c:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000843e:	e8 cb 00 01 	sub	r11,r4,1
80008442:	f6 05 0d 0a 	divu	r10,r11,r5
80008446:	14 9b       	mov	r11,r10
80008448:	f2 05 0d 02 	divu	r2,r9,r5
8000844c:	04 3b       	cp.w	r11,r2
8000844e:	c0 93       	brcs	80008460 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
80008450:	ea 08 11 00 	rsub	r8,r5,0
80008454:	f1 e9 00 09 	and	r9,r8,r9
80008458:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
8000845a:	12 14       	sub	r4,r9
				clst = fp->clust;
8000845c:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000845e:	c1 68       	rjmp	8000848a <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
80008460:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
80008462:	58 0c       	cp.w	r12,0
80008464:	c1 21       	brne	80008488 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
80008466:	30 0b       	mov	r11,0
80008468:	10 9c       	mov	r12,r8
8000846a:	f0 1f 00 4d 	mcall	8000859c <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
8000846e:	58 1c       	cp.w	r12,1
80008470:	c0 51       	brne	8000847a <f_lseek+0x18e>
80008472:	30 28       	mov	r8,2
80008474:	ae f8       	st.b	r7[0x7],r8
80008476:	30 26       	mov	r6,2
80008478:	c8 48       	rjmp	80008580 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
8000847a:	5b fc       	cp.w	r12,-1
8000847c:	c0 51       	brne	80008486 <f_lseek+0x19a>
8000847e:	30 18       	mov	r8,1
80008480:	ae f8       	st.b	r7[0x7],r8
80008482:	30 16       	mov	r6,1
80008484:	c7 e8       	rjmp	80008580 <f_lseek+0x294>
					fp->sclust = clst;
80008486:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
80008488:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
8000848a:	58 0c       	cp.w	r12,0
8000848c:	c4 80       	breq	8000851c <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
8000848e:	0a 34       	cp.w	r4,r5
80008490:	e0 88 00 32 	brls	800084f4 <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
80008494:	ea 03 11 00 	rsub	r3,r5,0
80008498:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
8000849a:	0f e8       	ld.ub	r8,r7[0x6]
8000849c:	e2 18 00 02 	andl	r8,0x2,COH
800084a0:	c0 70       	breq	800084ae <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
800084a2:	18 9b       	mov	r11,r12
800084a4:	6e 0c       	ld.w	r12,r7[0x0]
800084a6:	f0 1f 00 3e 	mcall	8000859c <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
800084aa:	c0 61       	brne	800084b6 <f_lseek+0x1ca>
800084ac:	c2 38       	rjmp	800084f2 <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
800084ae:	18 9b       	mov	r11,r12
800084b0:	6e 0c       	ld.w	r12,r7[0x0]
800084b2:	f0 1f 00 36 	mcall	80008588 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800084b6:	5b fc       	cp.w	r12,-1
800084b8:	c0 51       	brne	800084c2 <f_lseek+0x1d6>
800084ba:	30 18       	mov	r8,1
800084bc:	ae f8       	st.b	r7[0x7],r8
800084be:	30 16       	mov	r6,1
800084c0:	c6 08       	rjmp	80008580 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
800084c2:	58 1c       	cp.w	r12,1
800084c4:	e0 88 00 06 	brls	800084d0 <f_lseek+0x1e4>
800084c8:	6e 08       	ld.w	r8,r7[0x0]
800084ca:	70 58       	ld.w	r8,r8[0x14]
800084cc:	10 3c       	cp.w	r12,r8
800084ce:	c0 53       	brcs	800084d8 <f_lseek+0x1ec>
800084d0:	30 28       	mov	r8,2
800084d2:	ae f8       	st.b	r7[0x7],r8
800084d4:	30 26       	mov	r6,2
800084d6:	c5 58       	rjmp	80008580 <f_lseek+0x294>
					fp->clust = clst;
800084d8:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
800084da:	6e 28       	ld.w	r8,r7[0x8]
800084dc:	0a 08       	add	r8,r5
800084de:	8f 28       	st.w	r7[0x8],r8
800084e0:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
800084e4:	f0 05 00 09 	add	r9,r8,r5
800084e8:	0a 39       	cp.w	r9,r5
800084ea:	e0 88 00 05 	brls	800084f4 <f_lseek+0x208>
800084ee:	10 94       	mov	r4,r8
800084f0:	cd 5b       	rjmp	8000849a <f_lseek+0x1ae>
800084f2:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
800084f4:	6e 28       	ld.w	r8,r7[0x8]
800084f6:	08 08       	add	r8,r4
800084f8:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
800084fa:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
800084fe:	c0 f0       	breq	8000851c <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008500:	18 9b       	mov	r11,r12
80008502:	6e 0c       	ld.w	r12,r7[0x0]
80008504:	f0 1f 00 23 	mcall	80008590 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008508:	c0 51       	brne	80008512 <f_lseek+0x226>
8000850a:	30 28       	mov	r8,2
8000850c:	ae f8       	st.b	r7[0x7],r8
8000850e:	30 26       	mov	r6,2
80008510:	c3 88       	rjmp	80008580 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
80008512:	e8 05 16 09 	lsr	r5,r4,0x9
80008516:	f8 05 00 05 	add	r5,r12,r5
8000851a:	c0 28       	rjmp	8000851e <f_lseek+0x232>
8000851c:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
8000851e:	6e 28       	ld.w	r8,r7[0x8]
80008520:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008524:	c2 50       	breq	8000856e <f_lseek+0x282>
80008526:	6e 6a       	ld.w	r10,r7[0x18]
80008528:	0a 3a       	cp.w	r10,r5
8000852a:	c2 20       	breq	8000856e <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
8000852c:	0f e8       	ld.ub	r8,r7[0x6]
8000852e:	e2 18 00 40 	andl	r8,0x40,COH
80008532:	c1 00       	breq	80008552 <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008534:	6e 08       	ld.w	r8,r7[0x0]
80008536:	30 19       	mov	r9,1
80008538:	ee cb ff d8 	sub	r11,r7,-40
8000853c:	11 9c       	ld.ub	r12,r8[0x1]
8000853e:	f0 1f 00 16 	mcall	80008594 <f_lseek+0x2a8>
80008542:	c0 50       	breq	8000854c <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
80008544:	30 18       	mov	r8,1
80008546:	ae f8       	st.b	r7[0x7],r8
80008548:	30 16       	mov	r6,1
8000854a:	c1 b8       	rjmp	80008580 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
8000854c:	0f e8       	ld.ub	r8,r7[0x6]
8000854e:	a7 c8       	cbr	r8,0x6
80008550:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
80008552:	6e 08       	ld.w	r8,r7[0x0]
80008554:	30 19       	mov	r9,1
80008556:	0a 9a       	mov	r10,r5
80008558:	ee cb ff d8 	sub	r11,r7,-40
8000855c:	11 9c       	ld.ub	r12,r8[0x1]
8000855e:	f0 1f 00 0f 	mcall	80008598 <f_lseek+0x2ac>
80008562:	c0 50       	breq	8000856c <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
80008564:	30 18       	mov	r8,1
80008566:	ae f8       	st.b	r7[0x7],r8
80008568:	30 16       	mov	r6,1
8000856a:	c0 b8       	rjmp	80008580 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
8000856c:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
8000856e:	6e 28       	ld.w	r8,r7[0x8]
80008570:	6e 39       	ld.w	r9,r7[0xc]
80008572:	12 38       	cp.w	r8,r9
80008574:	e0 88 00 06 	brls	80008580 <f_lseek+0x294>
			fp->fsize = fp->fptr;
80008578:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
8000857a:	0f e8       	ld.ub	r8,r7[0x6]
8000857c:	a5 b8       	sbr	r8,0x5
8000857e:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
80008580:	0c 9c       	mov	r12,r6
80008582:	d8 32       	popm	r0-r7,pc
80008584:	80 00       	ld.sh	r0,r0[0x0]
80008586:	6b cc       	ld.w	r12,r5[0x70]
80008588:	80 00       	ld.sh	r0,r0[0x0]
8000858a:	73 28       	ld.w	r8,r9[0x48]
8000858c:	80 00       	ld.sh	r0,r0[0x0]
8000858e:	62 cc       	ld.w	r12,r1[0x30]
80008590:	80 00       	ld.sh	r0,r0[0x0]
80008592:	62 b4       	ld.w	r4,r1[0x2c]
80008594:	80 00       	ld.sh	r0,r0[0x0]
80008596:	62 40       	ld.w	r0,r1[0x10]
80008598:	80 00       	ld.sh	r0,r0[0x0]
8000859a:	62 5c       	ld.w	r12,r1[0x14]
8000859c:	80 00       	ld.sh	r0,r0[0x0]
8000859e:	74 c0       	ld.w	r0,r10[0x30]

800085a0 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
800085a0:	d4 31       	pushm	r0-r7,lr
800085a2:	20 3d       	sub	sp,12
800085a4:	18 97       	mov	r7,r12
800085a6:	16 93       	mov	r3,r11
800085a8:	14 96       	mov	r6,r10
800085aa:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
800085ac:	30 08       	mov	r8,0
800085ae:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
800085b0:	f0 1f 00 6d 	mcall	80008764 <f_write+0x1c4>
800085b4:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
800085b6:	e0 81 00 d3 	brne	8000875c <f_write+0x1bc>
	if (fp->err)							/* Check error */
800085ba:	0f f8       	ld.ub	r8,r7[0x7]
800085bc:	58 08       	cp.w	r8,0
800085be:	c0 30       	breq	800085c4 <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
800085c0:	10 92       	mov	r2,r8
800085c2:	cc d8       	rjmp	8000875c <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
800085c4:	0f e8       	ld.ub	r8,r7[0x6]
800085c6:	e2 18 00 02 	andl	r8,0x2,COH
800085ca:	c0 31       	brne	800085d0 <f_write+0x30>
800085cc:	30 72       	mov	r2,7
800085ce:	cc 78       	rjmp	8000875c <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
800085d0:	6e 28       	ld.w	r8,r7[0x8]
800085d2:	ec 08 00 09 	add	r9,r6,r8
800085d6:	12 38       	cp.w	r8,r9
800085d8:	e0 8b 00 ba 	brhi	8000874c <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
800085dc:	58 06       	cp.w	r6,0
800085de:	e0 80 00 b7 	breq	8000874c <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800085e2:	ee c8 ff d8 	sub	r8,r7,-40
800085e6:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
800085e8:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
800085ea:	50 2c       	stdsp	sp[0x8],r12
800085ec:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
800085ee:	6e 2b       	ld.w	r11,r7[0x8]
800085f0:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
800085f4:	e0 81 00 8c 	brne	8000870c <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
800085f8:	6e 08       	ld.w	r8,r7[0x0]
800085fa:	11 a6       	ld.ub	r6,r8[0x2]
800085fc:	20 16       	sub	r6,1
800085fe:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008602:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008604:	c2 91       	brne	80008656 <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
80008606:	58 0b       	cp.w	r11,0
80008608:	c0 81       	brne	80008618 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
8000860a:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
8000860c:	58 0c       	cp.w	r12,0
8000860e:	c1 31       	brne	80008634 <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008610:	10 9c       	mov	r12,r8
80008612:	f0 1f 00 56 	mcall	80008768 <f_write+0x1c8>
80008616:	c0 c8       	rjmp	8000862e <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008618:	6e 99       	ld.w	r9,r7[0x24]
8000861a:	58 09       	cp.w	r9,0
8000861c:	c0 50       	breq	80008626 <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
8000861e:	0e 9c       	mov	r12,r7
80008620:	f0 1f 00 53 	mcall	8000876c <f_write+0x1cc>
80008624:	c0 58       	rjmp	8000862e <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
80008626:	6e 5b       	ld.w	r11,r7[0x14]
80008628:	10 9c       	mov	r12,r8
8000862a:	f0 1f 00 50 	mcall	80008768 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
8000862e:	58 0c       	cp.w	r12,0
80008630:	e0 80 00 8b 	breq	80008746 <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008634:	58 1c       	cp.w	r12,1
80008636:	c0 51       	brne	80008640 <f_write+0xa0>
80008638:	30 28       	mov	r8,2
8000863a:	ae f8       	st.b	r7[0x7],r8
8000863c:	30 22       	mov	r2,2
8000863e:	c8 f8       	rjmp	8000875c <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008640:	5b fc       	cp.w	r12,-1
80008642:	c0 51       	brne	8000864c <f_write+0xac>
80008644:	30 18       	mov	r8,1
80008646:	ae f8       	st.b	r7[0x7],r8
80008648:	30 12       	mov	r2,1
8000864a:	c8 98       	rjmp	8000875c <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
8000864c:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
8000864e:	6e 48       	ld.w	r8,r7[0x10]
80008650:	58 08       	cp.w	r8,0
80008652:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
80008656:	0f e8       	ld.ub	r8,r7[0x6]
80008658:	e2 18 00 40 	andl	r8,0x40,COH
8000865c:	c1 00       	breq	8000867c <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000865e:	6e 08       	ld.w	r8,r7[0x0]
80008660:	30 19       	mov	r9,1
80008662:	6e 6a       	ld.w	r10,r7[0x18]
80008664:	40 1b       	lddsp	r11,sp[0x4]
80008666:	11 9c       	ld.ub	r12,r8[0x1]
80008668:	f0 1f 00 42 	mcall	80008770 <f_write+0x1d0>
8000866c:	c0 50       	breq	80008676 <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
8000866e:	30 18       	mov	r8,1
80008670:	ae f8       	st.b	r7[0x7],r8
80008672:	30 12       	mov	r2,1
80008674:	c7 48       	rjmp	8000875c <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
80008676:	0f e8       	ld.ub	r8,r7[0x6]
80008678:	a7 c8       	cbr	r8,0x6
8000867a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
8000867c:	6e 01       	ld.w	r1,r7[0x0]
8000867e:	6e 5b       	ld.w	r11,r7[0x14]
80008680:	02 9c       	mov	r12,r1
80008682:	f0 1f 00 3d 	mcall	80008774 <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008686:	c0 51       	brne	80008690 <f_write+0xf0>
80008688:	30 28       	mov	r8,2
8000868a:	ae f8       	st.b	r7[0x7],r8
8000868c:	30 22       	mov	r2,2
8000868e:	c6 78       	rjmp	8000875c <f_write+0x1bc>
			sect += csect;
80008690:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
80008694:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
80008698:	c2 70       	breq	800086e6 <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
8000869a:	03 a9       	ld.ub	r9,r1[0x2]
8000869c:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
800086a0:	12 38       	cp.w	r8,r9
800086a2:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
800086a6:	04 99       	mov	r9,r2
800086a8:	00 9a       	mov	r10,r0
800086aa:	06 9b       	mov	r11,r3
800086ac:	03 9c       	ld.ub	r12,r1[0x1]
800086ae:	f0 1f 00 31 	mcall	80008770 <f_write+0x1d0>
800086b2:	c0 50       	breq	800086bc <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
800086b4:	30 18       	mov	r8,1
800086b6:	ae f8       	st.b	r7[0x7],r8
800086b8:	30 12       	mov	r2,1
800086ba:	c5 18       	rjmp	8000875c <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
800086bc:	6e 6b       	ld.w	r11,r7[0x18]
800086be:	f6 00 01 00 	sub	r0,r11,r0
800086c2:	00 32       	cp.w	r2,r0
800086c4:	e0 88 00 0e 	brls	800086e0 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
800086c8:	e0 0b 15 09 	lsl	r11,r0,0x9
800086cc:	e0 6a 02 00 	mov	r10,512
800086d0:	e6 0b 00 0b 	add	r11,r3,r11
800086d4:	40 0c       	lddsp	r12,sp[0x0]
800086d6:	f0 1f 00 29 	mcall	80008778 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
800086da:	0f e8       	ld.ub	r8,r7[0x6]
800086dc:	a7 c8       	cbr	r8,0x6
800086de:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
800086e0:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
800086e4:	c2 78       	rjmp	80008732 <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
800086e6:	6e 68       	ld.w	r8,r7[0x18]
800086e8:	00 38       	cp.w	r8,r0
800086ea:	c1 00       	breq	8000870a <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
800086ec:	6e 29       	ld.w	r9,r7[0x8]
800086ee:	6e 38       	ld.w	r8,r7[0xc]
800086f0:	10 39       	cp.w	r9,r8
800086f2:	c0 c2       	brcc	8000870a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
800086f4:	30 19       	mov	r9,1
800086f6:	00 9a       	mov	r10,r0
800086f8:	40 1b       	lddsp	r11,sp[0x4]
800086fa:	03 9c       	ld.ub	r12,r1[0x1]
800086fc:	f0 1f 00 20 	mcall	8000877c <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008700:	c0 50       	breq	8000870a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008702:	30 18       	mov	r8,1
80008704:	ae f8       	st.b	r7[0x7],r8
80008706:	30 12       	mov	r2,1
80008708:	c2 a8       	rjmp	8000875c <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
8000870a:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
8000870c:	6e 2c       	ld.w	r12,r7[0x8]
8000870e:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008712:	e0 66 02 00 	mov	r6,512
80008716:	18 16       	sub	r6,r12
80008718:	0c 35       	cp.w	r5,r6
8000871a:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
8000871e:	0c 9a       	mov	r10,r6
80008720:	06 9b       	mov	r11,r3
80008722:	40 08       	lddsp	r8,sp[0x0]
80008724:	f0 0c 00 0c 	add	r12,r8,r12
80008728:	f0 1f 00 14 	mcall	80008778 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
8000872c:	0f e8       	ld.ub	r8,r7[0x6]
8000872e:	a7 a8       	sbr	r8,0x6
80008730:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008732:	6e 28       	ld.w	r8,r7[0x8]
80008734:	0c 08       	add	r8,r6
80008736:	8f 28       	st.w	r7[0x8],r8
80008738:	68 08       	ld.w	r8,r4[0x0]
8000873a:	0c 08       	add	r8,r6
8000873c:	89 08       	st.w	r4[0x0],r8
8000873e:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008740:	c0 50       	breq	8000874a <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008742:	0c 03       	add	r3,r6
80008744:	c5 5b       	rjmp	800085ee <f_write+0x4e>
80008746:	40 22       	lddsp	r2,sp[0x8]
80008748:	c0 28       	rjmp	8000874c <f_write+0x1ac>
8000874a:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
8000874c:	6e 28       	ld.w	r8,r7[0x8]
8000874e:	6e 39       	ld.w	r9,r7[0xc]
80008750:	12 38       	cp.w	r8,r9
80008752:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
80008756:	0f e8       	ld.ub	r8,r7[0x6]
80008758:	a5 b8       	sbr	r8,0x5
8000875a:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
8000875c:	04 9c       	mov	r12,r2
8000875e:	2f dd       	sub	sp,-12
80008760:	d8 32       	popm	r0-r7,pc
80008762:	00 00       	add	r0,r0
80008764:	80 00       	ld.sh	r0,r0[0x0]
80008766:	6b cc       	ld.w	r12,r5[0x70]
80008768:	80 00       	ld.sh	r0,r0[0x0]
8000876a:	74 c0       	ld.w	r0,r10[0x30]
8000876c:	80 00       	ld.sh	r0,r0[0x0]
8000876e:	62 cc       	ld.w	r12,r1[0x30]
80008770:	80 00       	ld.sh	r0,r0[0x0]
80008772:	62 40       	ld.w	r0,r1[0x10]
80008774:	80 00       	ld.sh	r0,r0[0x0]
80008776:	62 b4       	ld.w	r4,r1[0x2c]
80008778:	80 00       	ld.sh	r0,r0[0x0]
8000877a:	62 78       	ld.w	r8,r1[0x1c]
8000877c:	80 00       	ld.sh	r0,r0[0x0]
8000877e:	62 5c       	ld.w	r12,r1[0x14]

80008780 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80008780:	f8 c8 ff f8 	sub	r8,r12,-8
80008784:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80008786:	3f f9       	mov	r9,-1
80008788:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000878a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000878c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000878e:	30 08       	mov	r8,0
80008790:	99 08       	st.w	r12[0x0],r8
}
80008792:	5e fc       	retal	r12

80008794 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008794:	30 08       	mov	r8,0
80008796:	99 48       	st.w	r12[0x10],r8
}
80008798:	5e fc       	retal	r12

8000879a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000879a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
8000879c:	70 19       	ld.w	r9,r8[0x4]
8000879e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800087a0:	78 19       	ld.w	r9,r12[0x4]
800087a2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800087a4:	70 19       	ld.w	r9,r8[0x4]
800087a6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800087a8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800087aa:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800087ac:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800087ae:	78 08       	ld.w	r8,r12[0x0]
800087b0:	2f f8       	sub	r8,-1
800087b2:	99 08       	st.w	r12[0x0],r8
}
800087b4:	5e fc       	retal	r12

800087b6 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800087b6:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800087b8:	5b fa       	cp.w	r10,-1
800087ba:	c0 31       	brne	800087c0 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800087bc:	78 48       	ld.w	r8,r12[0x10]
800087be:	c0 c8       	rjmp	800087d6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800087c0:	f8 c8 ff f8 	sub	r8,r12,-8
800087c4:	70 19       	ld.w	r9,r8[0x4]
800087c6:	72 09       	ld.w	r9,r9[0x0]
800087c8:	12 3a       	cp.w	r10,r9
800087ca:	c0 63       	brcs	800087d6 <vListInsert+0x20>
800087cc:	70 18       	ld.w	r8,r8[0x4]
800087ce:	70 19       	ld.w	r9,r8[0x4]
800087d0:	72 09       	ld.w	r9,r9[0x0]
800087d2:	12 3a       	cp.w	r10,r9
800087d4:	cf c2       	brcc	800087cc <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800087d6:	70 19       	ld.w	r9,r8[0x4]
800087d8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800087da:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800087dc:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800087de:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800087e0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800087e2:	78 08       	ld.w	r8,r12[0x0]
800087e4:	2f f8       	sub	r8,-1
800087e6:	99 08       	st.w	r12[0x0],r8
}
800087e8:	5e fc       	retal	r12

800087ea <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800087ea:	78 18       	ld.w	r8,r12[0x4]
800087ec:	78 29       	ld.w	r9,r12[0x8]
800087ee:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800087f0:	78 28       	ld.w	r8,r12[0x8]
800087f2:	78 19       	ld.w	r9,r12[0x4]
800087f4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800087f6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800087f8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800087fa:	18 39       	cp.w	r9,r12
800087fc:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80008800:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008804:	30 09       	mov	r9,0
80008806:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008808:	70 09       	ld.w	r9,r8[0x0]
8000880a:	20 19       	sub	r9,1
8000880c:	91 09       	st.w	r8[0x0],r9
}
8000880e:	5e fc       	retal	r12

80008810 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008810:	e0 68 08 08 	mov	r8,2056
80008814:	ea 18 08 08 	orh	r8,0x808
80008818:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000881a:	e0 68 09 09 	mov	r8,2313
8000881e:	ea 18 09 09 	orh	r8,0x909
80008822:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008824:	e0 68 0a 0a 	mov	r8,2570
80008828:	ea 18 0a 0a 	orh	r8,0xa0a
8000882c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000882e:	e0 68 0b 0b 	mov	r8,2827
80008832:	ea 18 0b 0b 	orh	r8,0xb0b
80008836:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008838:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000883a:	e0 68 be ef 	mov	r8,48879
8000883e:	ea 18 de ad 	orh	r8,0xdead
80008842:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008844:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008846:	fc 18 00 40 	movh	r8,0x40
8000884a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000884c:	e0 68 00 ff 	mov	r8,255
80008850:	ea 18 ff 00 	orh	r8,0xff00
80008854:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008856:	e0 68 01 01 	mov	r8,257
8000885a:	ea 18 01 01 	orh	r8,0x101
8000885e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80008860:	e0 68 02 02 	mov	r8,514
80008864:	ea 18 02 02 	orh	r8,0x202
80008868:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000886a:	e0 68 03 03 	mov	r8,771
8000886e:	ea 18 03 03 	orh	r8,0x303
80008872:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80008874:	e0 68 04 04 	mov	r8,1028
80008878:	ea 18 04 04 	orh	r8,0x404
8000887c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000887e:	e0 68 05 05 	mov	r8,1285
80008882:	ea 18 05 05 	orh	r8,0x505
80008886:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80008888:	e0 68 06 06 	mov	r8,1542
8000888c:	ea 18 06 06 	orh	r8,0x606
80008890:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80008892:	e0 68 07 07 	mov	r8,1799
80008896:	ea 18 07 07 	orh	r8,0x707
8000889a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000889c:	30 08       	mov	r8,0
8000889e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800088a0:	5e fc       	retal	r12
800088a2:	d7 03       	nop

800088a4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800088a4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800088a6:	48 38       	lddpc	r8,800088b0 <vPortEnterCritical+0xc>
800088a8:	70 09       	ld.w	r9,r8[0x0]
800088aa:	2f f9       	sub	r9,-1
800088ac:	91 09       	st.w	r8[0x0],r9
}
800088ae:	5e fc       	retal	r12
800088b0:	00 00       	add	r0,r0
800088b2:	05 30       	ld.ub	r0,r2++

800088b4 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800088b4:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800088b6:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800088b8:	30 0a       	mov	r10,0
800088ba:	14 9b       	mov	r11,r10
800088bc:	49 2c       	lddpc	r12,80008904 <xPortStartScheduler+0x50>
800088be:	f0 1f 00 13 	mcall	80008908 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800088c2:	e0 68 5d c0 	mov	r8,24000
800088c6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800088ca:	30 08       	mov	r8,0
800088cc:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800088d0:	e0 68 12 1c 	mov	r8,4636
800088d4:	ea 18 00 00 	orh	r8,0x0
800088d8:	70 00       	ld.w	r0,r8[0x0]
800088da:	60 0d       	ld.w	sp,r0[0x0]
800088dc:	1b 00       	ld.w	r0,sp++
800088de:	e0 68 05 30 	mov	r8,1328
800088e2:	ea 18 00 00 	orh	r8,0x0
800088e6:	91 00       	st.w	r8[0x0],r0
800088e8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800088ec:	2f ed       	sub	sp,-8
800088ee:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800088f2:	fa f0 ff e0 	ld.w	r0,sp[-32]
800088f6:	e3 b0 00 00 	mtsr	0x0,r0
800088fa:	fa f0 ff dc 	ld.w	r0,sp[-36]
800088fe:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80008902:	d8 0a       	popm	pc,r12=0
80008904:	80 00       	ld.sh	r0,r0[0x0]
80008906:	89 d0       	st.w	r4[0x34],r0
80008908:	80 00       	ld.sh	r0,r0[0x0]
8000890a:	59 74       	cp.w	r4,23

8000890c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000890c:	20 6d       	sub	sp,24
8000890e:	eb cd 00 ff 	pushm	r0-r7
80008912:	fa c7 ff c0 	sub	r7,sp,-64
80008916:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000891a:	ef 40 ff e0 	st.w	r7[-32],r0
8000891e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80008922:	ef 40 ff e4 	st.w	r7[-28],r0
80008926:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000892a:	e0 68 05 30 	mov	r8,1328
8000892e:	ea 18 00 00 	orh	r8,0x0
80008932:	70 00       	ld.w	r0,r8[0x0]
80008934:	1a d0       	st.w	--sp,r0
80008936:	f0 1f 00 1a 	mcall	8000899c <LABEL_RET_SCALL_263+0x14>
8000893a:	e0 68 12 1c 	mov	r8,4636
8000893e:	ea 18 00 00 	orh	r8,0x0
80008942:	70 00       	ld.w	r0,r8[0x0]
80008944:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80008946:	f0 1f 00 17 	mcall	800089a0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000894a:	e0 68 12 1c 	mov	r8,4636
8000894e:	ea 18 00 00 	orh	r8,0x0
80008952:	70 00       	ld.w	r0,r8[0x0]
80008954:	60 0d       	ld.w	sp,r0[0x0]
80008956:	1b 00       	ld.w	r0,sp++
80008958:	e0 68 05 30 	mov	r8,1328
8000895c:	ea 18 00 00 	orh	r8,0x0
80008960:	91 00       	st.w	r8[0x0],r0
80008962:	fa c7 ff d8 	sub	r7,sp,-40
80008966:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000896a:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000896e:	e0 61 05 30 	mov	r1,1328
80008972:	ea 11 00 00 	orh	r1,0x0
80008976:	62 02       	ld.w	r2,r1[0x0]
80008978:	58 02       	cp.w	r2,0
8000897a:	c0 70       	breq	80008988 <LABEL_RET_SCALL_263>
8000897c:	e4 c2 00 01 	sub	r2,r2,1
80008980:	83 02       	st.w	r1[0x0],r2
80008982:	58 02       	cp.w	r2,0
80008984:	c0 21       	brne	80008988 <LABEL_RET_SCALL_263>
80008986:	b1 c0       	cbr	r0,0x10

80008988 <LABEL_RET_SCALL_263>:
80008988:	ef 40 ff f8 	st.w	r7[-8],r0
8000898c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80008990:	ef 40 ff fc 	st.w	r7[-4],r0
80008994:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008998:	2f ad       	sub	sp,-24
8000899a:	d6 13       	rets
8000899c:	80 00       	ld.sh	r0,r0[0x0]
8000899e:	88 a4       	ld.uh	r4,r4[0x4]
800089a0:	80 00       	ld.sh	r0,r0[0x0]
800089a2:	90 40       	ld.sh	r0,r8[0x8]

800089a4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800089a4:	e1 b8 00 43 	mfsr	r8,0x10c
800089a8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800089ac:	5e fc       	retal	r12
800089ae:	d7 03       	nop

800089b0 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800089b0:	48 78       	lddpc	r8,800089cc <vPortExitCritical+0x1c>
800089b2:	70 08       	ld.w	r8,r8[0x0]
800089b4:	58 08       	cp.w	r8,0
800089b6:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800089b8:	48 58       	lddpc	r8,800089cc <vPortExitCritical+0x1c>
800089ba:	70 09       	ld.w	r9,r8[0x0]
800089bc:	20 19       	sub	r9,1
800089be:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800089c0:	70 08       	ld.w	r8,r8[0x0]
800089c2:	58 08       	cp.w	r8,0
800089c4:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800089c6:	d5 03       	csrf	0x10
800089c8:	5e fc       	retal	r12
800089ca:	00 00       	add	r0,r0
800089cc:	00 00       	add	r0,r0
800089ce:	05 30       	ld.ub	r0,r2++

800089d0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800089d0:	eb cd 00 ff 	pushm	r0-r7
800089d4:	e0 68 05 30 	mov	r8,1328
800089d8:	ea 18 00 00 	orh	r8,0x0
800089dc:	70 00       	ld.w	r0,r8[0x0]
800089de:	1a d0       	st.w	--sp,r0
800089e0:	7a 90       	ld.w	r0,sp[0x24]
800089e2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800089e6:	58 10       	cp.w	r0,1
800089e8:	e0 8b 00 08 	brhi	800089f8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800089ec:	e0 68 12 1c 	mov	r8,4636
800089f0:	ea 18 00 00 	orh	r8,0x0
800089f4:	70 00       	ld.w	r0,r8[0x0]
800089f6:	81 0d       	st.w	r0[0x0],sp

800089f8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800089f8:	f0 1f 00 12 	mcall	80008a40 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800089fc:	f0 1f 00 12 	mcall	80008a44 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008a00:	f0 1f 00 12 	mcall	80008a48 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008a04:	f0 1f 00 12 	mcall	80008a4c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008a08:	7a 90       	ld.w	r0,sp[0x24]
80008a0a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a0e:	58 10       	cp.w	r0,1
80008a10:	e0 8b 00 0e 	brhi	80008a2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008a14:	f0 1f 00 0c 	mcall	80008a44 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008a18:	f0 1f 00 0e 	mcall	80008a50 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008a1c:	f0 1f 00 0c 	mcall	80008a4c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008a20:	e0 68 12 1c 	mov	r8,4636
80008a24:	ea 18 00 00 	orh	r8,0x0
80008a28:	70 00       	ld.w	r0,r8[0x0]
80008a2a:	60 0d       	ld.w	sp,r0[0x0]

80008a2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008a2c:	1b 00       	ld.w	r0,sp++
80008a2e:	e0 68 05 30 	mov	r8,1328
80008a32:	ea 18 00 00 	orh	r8,0x0
80008a36:	91 00       	st.w	r8[0x0],r0
80008a38:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008a3c:	d6 03       	rete
80008a3e:	00 00       	add	r0,r0
80008a40:	80 00       	ld.sh	r0,r0[0x0]
80008a42:	89 a4       	st.w	r4[0x28],r4
80008a44:	80 00       	ld.sh	r0,r0[0x0]
80008a46:	88 a4       	ld.uh	r4,r4[0x4]
80008a48:	80 00       	ld.sh	r0,r0[0x0]
80008a4a:	92 44       	ld.sh	r4,r9[0x8]
80008a4c:	80 00       	ld.sh	r0,r0[0x0]
80008a4e:	89 b0       	st.w	r4[0x2c],r0
80008a50:	80 00       	ld.sh	r0,r0[0x0]
80008a52:	90 40       	ld.sh	r0,r8[0x8]

80008a54 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008a54:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008a56:	f0 1f 00 02 	mcall	80008a5c <__malloc_lock+0x8>
}
80008a5a:	d8 02       	popm	pc
80008a5c:	80 00       	ld.sh	r0,r0[0x0]
80008a5e:	90 30       	ld.sh	r0,r8[0x6]

80008a60 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008a60:	d4 01       	pushm	lr
	xTaskResumeAll();
80008a62:	f0 1f 00 02 	mcall	80008a68 <__malloc_unlock+0x8>
}
80008a66:	d8 02       	popm	pc
80008a68:	80 00       	ld.sh	r0,r0[0x0]
80008a6a:	93 ec       	st.w	r9[0x38],r12

80008a6c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008a6c:	d4 21       	pushm	r4-r7,lr
80008a6e:	16 95       	mov	r5,r11
80008a70:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008a72:	58 0c       	cp.w	r12,0
80008a74:	c0 30       	breq	80008a7a <_read+0xe>
80008a76:	3f f7       	mov	r7,-1
80008a78:	c1 48       	rjmp	80008aa0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80008a7a:	58 0a       	cp.w	r10,0
80008a7c:	e0 89 00 04 	brgt	80008a84 <_read+0x18>
80008a80:	30 07       	mov	r7,0
80008a82:	c0 f8       	rjmp	80008aa0 <_read+0x34>
80008a84:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80008a86:	48 84       	lddpc	r4,80008aa4 <_read+0x38>
80008a88:	68 0c       	ld.w	r12,r4[0x0]
80008a8a:	f0 1f 00 08 	mcall	80008aa8 <_read+0x3c>
    if (c < 0)
80008a8e:	c0 95       	brlt	80008aa0 <_read+0x34>
      break;

    *ptr++ = c;
80008a90:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80008a94:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80008a96:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008a9a:	58 08       	cp.w	r8,0
80008a9c:	fe 99 ff f6 	brgt	80008a88 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80008aa0:	0e 9c       	mov	r12,r7
80008aa2:	d8 22       	popm	r4-r7,pc
80008aa4:	00 00       	add	r0,r0
80008aa6:	46 18       	lddsp	r8,sp[0x184]
80008aa8:	80 00       	ld.sh	r0,r0[0x0]
80008aaa:	60 68       	ld.w	r8,r0[0x18]

80008aac <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008aac:	d4 21       	pushm	r4-r7,lr
80008aae:	16 95       	mov	r5,r11
80008ab0:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80008ab2:	20 1c       	sub	r12,1
80008ab4:	58 2c       	cp.w	r12,2
80008ab6:	e0 8b 00 12 	brhi	80008ada <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008aba:	58 0a       	cp.w	r10,0
80008abc:	c0 31       	brne	80008ac2 <_write+0x16>
80008abe:	30 07       	mov	r7,0
80008ac0:	c0 e8       	rjmp	80008adc <_write+0x30>
80008ac2:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008ac4:	48 74       	lddpc	r4,80008ae0 <_write+0x34>
80008ac6:	68 0c       	ld.w	r12,r4[0x0]
80008ac8:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80008acc:	f0 1f 00 06 	mcall	80008ae4 <_write+0x38>
80008ad0:	c0 55       	brlt	80008ada <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80008ad2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008ad4:	0e 36       	cp.w	r6,r7
80008ad6:	cf 81       	brne	80008ac6 <_write+0x1a>
80008ad8:	c0 28       	rjmp	80008adc <_write+0x30>
80008ada:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80008adc:	0e 9c       	mov	r12,r7
80008ade:	d8 22       	popm	r4-r7,pc
80008ae0:	00 00       	add	r0,r0
80008ae2:	46 18       	lddsp	r8,sp[0x184]
80008ae4:	80 00       	ld.sh	r0,r0[0x0]
80008ae6:	60 18       	ld.w	r8,r0[0x4]

80008ae8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008ae8:	eb cd 40 80 	pushm	r7,lr
80008aec:	18 97       	mov	r7,r12
	if( pv )
80008aee:	58 0c       	cp.w	r12,0
80008af0:	c0 80       	breq	80008b00 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80008af2:	f0 1f 00 05 	mcall	80008b04 <vPortFree+0x1c>
		{
			free( pv );
80008af6:	0e 9c       	mov	r12,r7
80008af8:	f0 1f 00 04 	mcall	80008b08 <vPortFree+0x20>
		}
		xTaskResumeAll();
80008afc:	f0 1f 00 04 	mcall	80008b0c <vPortFree+0x24>
80008b00:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b04:	80 00       	ld.sh	r0,r0[0x0]
80008b06:	90 30       	ld.sh	r0,r8[0x6]
80008b08:	80 00       	ld.sh	r0,r0[0x0]
80008b0a:	9f 9c       	st.w	pc[0x24],r12
80008b0c:	80 00       	ld.sh	r0,r0[0x0]
80008b0e:	93 ec       	st.w	r9[0x38],r12

80008b10 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008b10:	eb cd 40 80 	pushm	r7,lr
80008b14:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80008b16:	f0 1f 00 06 	mcall	80008b2c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80008b1a:	0e 9c       	mov	r12,r7
80008b1c:	f0 1f 00 05 	mcall	80008b30 <pvPortMalloc+0x20>
80008b20:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80008b22:	f0 1f 00 05 	mcall	80008b34 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80008b26:	0e 9c       	mov	r12,r7
80008b28:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b2c:	80 00       	ld.sh	r0,r0[0x0]
80008b2e:	90 30       	ld.sh	r0,r8[0x6]
80008b30:	80 00       	ld.sh	r0,r0[0x0]
80008b32:	9f ac       	st.w	pc[0x28],r12
80008b34:	80 00       	ld.sh	r0,r0[0x0]
80008b36:	93 ec       	st.w	r9[0x38],r12

80008b38 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008b38:	d4 01       	pushm	lr
80008b3a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80008b3c:	78 09       	ld.w	r9,r12[0x0]
80008b3e:	58 09       	cp.w	r9,0
80008b40:	c1 10       	breq	80008b62 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80008b42:	78 3a       	ld.w	r10,r12[0xc]
80008b44:	79 09       	ld.w	r9,r12[0x40]
80008b46:	f4 09 00 09 	add	r9,r10,r9
80008b4a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80008b4c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80008b4e:	14 39       	cp.w	r9,r10
80008b50:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80008b54:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80008b58:	79 0a       	ld.w	r10,r12[0x40]
80008b5a:	78 3b       	ld.w	r11,r12[0xc]
80008b5c:	10 9c       	mov	r12,r8
80008b5e:	f0 1f 00 02 	mcall	80008b64 <prvCopyDataFromQueue+0x2c>
80008b62:	d8 02       	popm	pc
80008b64:	80 00       	ld.sh	r0,r0[0x0]
80008b66:	a4 1a       	st.h	r2[0x2],r10

80008b68 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80008b68:	eb cd 40 c0 	pushm	r6-r7,lr
80008b6c:	18 97       	mov	r7,r12
80008b6e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008b70:	78 e8       	ld.w	r8,r12[0x38]
80008b72:	58 08       	cp.w	r8,0
80008b74:	c0 31       	brne	80008b7a <xQueueReceiveFromISR+0x12>
80008b76:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80008b7a:	f0 1f 00 0e 	mcall	80008bb0 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80008b7e:	6e e8       	ld.w	r8,r7[0x38]
80008b80:	20 18       	sub	r8,1
80008b82:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80008b84:	6f 18       	ld.w	r8,r7[0x44]
80008b86:	5b f8       	cp.w	r8,-1
80008b88:	c0 d1       	brne	80008ba2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008b8a:	6e 48       	ld.w	r8,r7[0x10]
80008b8c:	58 08       	cp.w	r8,0
80008b8e:	c0 f0       	breq	80008bac <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008b90:	ee cc ff f0 	sub	r12,r7,-16
80008b94:	f0 1f 00 08 	mcall	80008bb4 <xQueueReceiveFromISR+0x4c>
80008b98:	c0 a0       	breq	80008bac <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80008b9a:	30 1c       	mov	r12,1
80008b9c:	8d 0c       	st.w	r6[0x0],r12
80008b9e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80008ba2:	2f f8       	sub	r8,-1
80008ba4:	ef 48 00 44 	st.w	r7[68],r8
80008ba8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008bac:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008bb0:	80 00       	ld.sh	r0,r0[0x0]
80008bb2:	8b 38       	st.w	r5[0xc],r8
80008bb4:	80 00       	ld.sh	r0,r0[0x0]
80008bb6:	91 c8       	st.w	r8[0x30],r8

80008bb8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80008bb8:	eb cd 40 c0 	pushm	r6-r7,lr
80008bbc:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80008bbe:	f0 1f 00 23 	mcall	80008c48 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008bc2:	6f 28       	ld.w	r8,r7[0x48]
80008bc4:	58 08       	cp.w	r8,0
80008bc6:	e0 8a 00 18 	brle	80008bf6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008bca:	6e 98       	ld.w	r8,r7[0x24]
80008bcc:	58 08       	cp.w	r8,0
80008bce:	c1 40       	breq	80008bf6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008bd0:	ee c6 ff dc 	sub	r6,r7,-36
80008bd4:	c0 48       	rjmp	80008bdc <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008bd6:	6e 98       	ld.w	r8,r7[0x24]
80008bd8:	58 08       	cp.w	r8,0
80008bda:	c0 e0       	breq	80008bf6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008bdc:	0c 9c       	mov	r12,r6
80008bde:	f0 1f 00 1c 	mcall	80008c4c <prvUnlockQueue+0x94>
80008be2:	c0 30       	breq	80008be8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80008be4:	f0 1f 00 1b 	mcall	80008c50 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80008be8:	6f 28       	ld.w	r8,r7[0x48]
80008bea:	20 18       	sub	r8,1
80008bec:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008bf0:	58 08       	cp.w	r8,0
80008bf2:	fe 99 ff f2 	brgt	80008bd6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80008bf6:	3f f8       	mov	r8,-1
80008bf8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80008bfc:	f0 1f 00 16 	mcall	80008c54 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80008c00:	f0 1f 00 12 	mcall	80008c48 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008c04:	6f 18       	ld.w	r8,r7[0x44]
80008c06:	58 08       	cp.w	r8,0
80008c08:	e0 8a 00 18 	brle	80008c38 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008c0c:	6e 48       	ld.w	r8,r7[0x10]
80008c0e:	58 08       	cp.w	r8,0
80008c10:	c1 40       	breq	80008c38 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008c12:	ee c6 ff f0 	sub	r6,r7,-16
80008c16:	c0 48       	rjmp	80008c1e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008c18:	6e 48       	ld.w	r8,r7[0x10]
80008c1a:	58 08       	cp.w	r8,0
80008c1c:	c0 e0       	breq	80008c38 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008c1e:	0c 9c       	mov	r12,r6
80008c20:	f0 1f 00 0b 	mcall	80008c4c <prvUnlockQueue+0x94>
80008c24:	c0 30       	breq	80008c2a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80008c26:	f0 1f 00 0b 	mcall	80008c50 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80008c2a:	6f 18       	ld.w	r8,r7[0x44]
80008c2c:	20 18       	sub	r8,1
80008c2e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008c32:	58 08       	cp.w	r8,0
80008c34:	fe 99 ff f2 	brgt	80008c18 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80008c38:	3f f8       	mov	r8,-1
80008c3a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80008c3e:	f0 1f 00 06 	mcall	80008c54 <prvUnlockQueue+0x9c>
}
80008c42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008c46:	00 00       	add	r0,r0
80008c48:	80 00       	ld.sh	r0,r0[0x0]
80008c4a:	88 a4       	ld.uh	r4,r4[0x4]
80008c4c:	80 00       	ld.sh	r0,r0[0x0]
80008c4e:	91 c8       	st.w	r8[0x30],r8
80008c50:	80 00       	ld.sh	r0,r0[0x0]
80008c52:	90 d4       	ld.uh	r4,r8[0xa]
80008c54:	80 00       	ld.sh	r0,r0[0x0]
80008c56:	89 b0       	st.w	r4[0x2c],r0

80008c58 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80008c58:	d4 31       	pushm	r0-r7,lr
80008c5a:	20 5d       	sub	sp,20
80008c5c:	18 97       	mov	r7,r12
80008c5e:	50 0b       	stdsp	sp[0x0],r11
80008c60:	50 2a       	stdsp	sp[0x8],r10
80008c62:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008c64:	f8 c2 ff dc 	sub	r2,r12,-36
80008c68:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008c6a:	fa c4 ff f4 	sub	r4,sp,-12
80008c6e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008c70:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008c72:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80008c76:	f0 1f 00 3e 	mcall	80008d6c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008c7a:	6e e8       	ld.w	r8,r7[0x38]
80008c7c:	58 08       	cp.w	r8,0
80008c7e:	c2 a0       	breq	80008cd2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80008c80:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80008c82:	40 0b       	lddsp	r11,sp[0x0]
80008c84:	0e 9c       	mov	r12,r7
80008c86:	f0 1f 00 3b 	mcall	80008d70 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80008c8a:	40 18       	lddsp	r8,sp[0x4]
80008c8c:	58 08       	cp.w	r8,0
80008c8e:	c1 51       	brne	80008cb8 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80008c90:	6e e8       	ld.w	r8,r7[0x38]
80008c92:	20 18       	sub	r8,1
80008c94:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008c96:	6e 08       	ld.w	r8,r7[0x0]
80008c98:	58 08       	cp.w	r8,0
80008c9a:	c0 41       	brne	80008ca2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80008c9c:	f0 1f 00 36 	mcall	80008d74 <xQueueGenericReceive+0x11c>
80008ca0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008ca2:	6e 48       	ld.w	r8,r7[0x10]
80008ca4:	58 08       	cp.w	r8,0
80008ca6:	c1 20       	breq	80008cca <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80008ca8:	ee cc ff f0 	sub	r12,r7,-16
80008cac:	f0 1f 00 33 	mcall	80008d78 <xQueueGenericReceive+0x120>
80008cb0:	58 1c       	cp.w	r12,1
80008cb2:	c0 c1       	brne	80008cca <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80008cb4:	d7 33       	scall
80008cb6:	c0 a8       	rjmp	80008cca <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80008cb8:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008cba:	6e 98       	ld.w	r8,r7[0x24]
80008cbc:	58 08       	cp.w	r8,0
80008cbe:	c0 60       	breq	80008cca <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008cc0:	04 9c       	mov	r12,r2
80008cc2:	f0 1f 00 2e 	mcall	80008d78 <xQueueGenericReceive+0x120>
80008cc6:	c0 20       	breq	80008cca <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80008cc8:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80008cca:	f0 1f 00 2d 	mcall	80008d7c <xQueueGenericReceive+0x124>
80008cce:	30 1c       	mov	r12,1
				return pdPASS;
80008cd0:	c4 c8       	rjmp	80008d68 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008cd2:	40 28       	lddsp	r8,sp[0x8]
80008cd4:	58 08       	cp.w	r8,0
80008cd6:	c0 51       	brne	80008ce0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008cd8:	f0 1f 00 29 	mcall	80008d7c <xQueueGenericReceive+0x124>
80008cdc:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80008cde:	c4 58       	rjmp	80008d68 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80008ce0:	58 05       	cp.w	r5,0
80008ce2:	c0 51       	brne	80008cec <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008ce4:	08 9c       	mov	r12,r4
80008ce6:	f0 1f 00 27 	mcall	80008d80 <xQueueGenericReceive+0x128>
80008cea:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008cec:	f0 1f 00 24 	mcall	80008d7c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008cf0:	f0 1f 00 25 	mcall	80008d84 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80008cf4:	f0 1f 00 1e 	mcall	80008d6c <xQueueGenericReceive+0x114>
80008cf8:	6f 18       	ld.w	r8,r7[0x44]
80008cfa:	5b f8       	cp.w	r8,-1
80008cfc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008d00:	6f 28       	ld.w	r8,r7[0x48]
80008d02:	5b f8       	cp.w	r8,-1
80008d04:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008d08:	f0 1f 00 1d 	mcall	80008d7c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008d0c:	06 9b       	mov	r11,r3
80008d0e:	08 9c       	mov	r12,r4
80008d10:	f0 1f 00 1e 	mcall	80008d88 <xQueueGenericReceive+0x130>
80008d14:	c2 41       	brne	80008d5c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008d16:	f0 1f 00 16 	mcall	80008d6c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80008d1a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80008d1c:	f0 1f 00 18 	mcall	80008d7c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80008d20:	58 06       	cp.w	r6,0
80008d22:	c1 71       	brne	80008d50 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008d24:	6e 08       	ld.w	r8,r7[0x0]
80008d26:	58 08       	cp.w	r8,0
80008d28:	c0 81       	brne	80008d38 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80008d2a:	f0 1f 00 11 	mcall	80008d6c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80008d2e:	6e 1c       	ld.w	r12,r7[0x4]
80008d30:	f0 1f 00 17 	mcall	80008d8c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80008d34:	f0 1f 00 12 	mcall	80008d7c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008d38:	40 2b       	lddsp	r11,sp[0x8]
80008d3a:	04 9c       	mov	r12,r2
80008d3c:	f0 1f 00 15 	mcall	80008d90 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80008d40:	0e 9c       	mov	r12,r7
80008d42:	f0 1f 00 15 	mcall	80008d94 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80008d46:	f0 1f 00 15 	mcall	80008d98 <xQueueGenericReceive+0x140>
80008d4a:	c9 61       	brne	80008c76 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80008d4c:	d7 33       	scall
80008d4e:	c9 4b       	rjmp	80008c76 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008d50:	0e 9c       	mov	r12,r7
80008d52:	f0 1f 00 11 	mcall	80008d94 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80008d56:	f0 1f 00 11 	mcall	80008d98 <xQueueGenericReceive+0x140>
80008d5a:	c8 eb       	rjmp	80008c76 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80008d5c:	0e 9c       	mov	r12,r7
80008d5e:	f0 1f 00 0e 	mcall	80008d94 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80008d62:	f0 1f 00 0e 	mcall	80008d98 <xQueueGenericReceive+0x140>
80008d66:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80008d68:	2f bd       	sub	sp,-20
80008d6a:	d8 32       	popm	r0-r7,pc
80008d6c:	80 00       	ld.sh	r0,r0[0x0]
80008d6e:	88 a4       	ld.uh	r4,r4[0x4]
80008d70:	80 00       	ld.sh	r0,r0[0x0]
80008d72:	8b 38       	st.w	r5[0xc],r8
80008d74:	80 00       	ld.sh	r0,r0[0x0]
80008d76:	90 e0       	ld.uh	r0,r8[0xc]
80008d78:	80 00       	ld.sh	r0,r0[0x0]
80008d7a:	91 c8       	st.w	r8[0x30],r8
80008d7c:	80 00       	ld.sh	r0,r0[0x0]
80008d7e:	89 b0       	st.w	r4[0x2c],r0
80008d80:	80 00       	ld.sh	r0,r0[0x0]
80008d82:	90 bc       	ld.uh	r12,r8[0x6]
80008d84:	80 00       	ld.sh	r0,r0[0x0]
80008d86:	90 30       	ld.sh	r0,r8[0x6]
80008d88:	80 00       	ld.sh	r0,r0[0x0]
80008d8a:	93 58       	st.w	r9[0x14],r8
80008d8c:	80 00       	ld.sh	r0,r0[0x0]
80008d8e:	91 44       	st.w	r8[0x10],r4
80008d90:	80 00       	ld.sh	r0,r0[0x0]
80008d92:	95 b0       	st.w	r10[0x2c],r0
80008d94:	80 00       	ld.sh	r0,r0[0x0]
80008d96:	8b b8       	st.w	r5[0x2c],r8
80008d98:	80 00       	ld.sh	r0,r0[0x0]
80008d9a:	93 ec       	st.w	r9[0x38],r12

80008d9c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80008d9c:	eb cd 40 80 	pushm	r7,lr
80008da0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80008da2:	79 08       	ld.w	r8,r12[0x40]
80008da4:	58 08       	cp.w	r8,0
80008da6:	c0 a1       	brne	80008dba <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008da8:	78 08       	ld.w	r8,r12[0x0]
80008daa:	58 08       	cp.w	r8,0
80008dac:	c2 b1       	brne	80008e02 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80008dae:	78 1c       	ld.w	r12,r12[0x4]
80008db0:	f0 1f 00 17 	mcall	80008e0c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80008db4:	30 08       	mov	r8,0
80008db6:	8f 18       	st.w	r7[0x4],r8
80008db8:	c2 58       	rjmp	80008e02 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80008dba:	58 0a       	cp.w	r10,0
80008dbc:	c1 01       	brne	80008ddc <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008dbe:	10 9a       	mov	r10,r8
80008dc0:	78 2c       	ld.w	r12,r12[0x8]
80008dc2:	f0 1f 00 14 	mcall	80008e10 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80008dc6:	6e 29       	ld.w	r9,r7[0x8]
80008dc8:	6f 08       	ld.w	r8,r7[0x40]
80008dca:	f2 08 00 08 	add	r8,r9,r8
80008dce:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80008dd0:	6e 19       	ld.w	r9,r7[0x4]
80008dd2:	12 38       	cp.w	r8,r9
80008dd4:	c1 73       	brcs	80008e02 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80008dd6:	6e 08       	ld.w	r8,r7[0x0]
80008dd8:	8f 28       	st.w	r7[0x8],r8
80008dda:	c1 48       	rjmp	80008e02 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008ddc:	10 9a       	mov	r10,r8
80008dde:	78 3c       	ld.w	r12,r12[0xc]
80008de0:	f0 1f 00 0c 	mcall	80008e10 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80008de4:	6f 08       	ld.w	r8,r7[0x40]
80008de6:	6e 39       	ld.w	r9,r7[0xc]
80008de8:	f2 08 01 08 	sub	r8,r9,r8
80008dec:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80008dee:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80008df0:	12 38       	cp.w	r8,r9
80008df2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80008df6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80008dfa:	f3 d8 e3 19 	subcs	r9,r9,r8
80008dfe:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80008e02:	6e e8       	ld.w	r8,r7[0x38]
80008e04:	2f f8       	sub	r8,-1
80008e06:	8f e8       	st.w	r7[0x38],r8
}
80008e08:	e3 cd 80 80 	ldm	sp++,r7,pc
80008e0c:	80 00       	ld.sh	r0,r0[0x0]
80008e0e:	90 ec       	ld.uh	r12,r8[0xc]
80008e10:	80 00       	ld.sh	r0,r0[0x0]
80008e12:	a4 1a       	st.h	r2[0x2],r10

80008e14 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80008e14:	eb cd 40 c0 	pushm	r6-r7,lr
80008e18:	18 97       	mov	r7,r12
80008e1a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008e1c:	78 ec       	ld.w	r12,r12[0x38]
80008e1e:	6e f8       	ld.w	r8,r7[0x3c]
80008e20:	10 3c       	cp.w	r12,r8
80008e22:	c0 33       	brcs	80008e28 <xQueueGenericSendFromISR+0x14>
80008e24:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008e28:	12 9a       	mov	r10,r9
80008e2a:	0e 9c       	mov	r12,r7
80008e2c:	f0 1f 00 0c 	mcall	80008e5c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80008e30:	6f 28       	ld.w	r8,r7[0x48]
80008e32:	5b f8       	cp.w	r8,-1
80008e34:	c0 d1       	brne	80008e4e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008e36:	6e 98       	ld.w	r8,r7[0x24]
80008e38:	58 08       	cp.w	r8,0
80008e3a:	c0 f0       	breq	80008e58 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008e3c:	ee cc ff dc 	sub	r12,r7,-36
80008e40:	f0 1f 00 08 	mcall	80008e60 <xQueueGenericSendFromISR+0x4c>
80008e44:	c0 a0       	breq	80008e58 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80008e46:	30 1c       	mov	r12,1
80008e48:	8d 0c       	st.w	r6[0x0],r12
80008e4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80008e4e:	2f f8       	sub	r8,-1
80008e50:	ef 48 00 48 	st.w	r7[72],r8
80008e54:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008e58:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008e5c:	80 00       	ld.sh	r0,r0[0x0]
80008e5e:	8d 9c       	st.w	r6[0x24],r12
80008e60:	80 00       	ld.sh	r0,r0[0x0]
80008e62:	91 c8       	st.w	r8[0x30],r8

80008e64 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008e64:	d4 31       	pushm	r0-r7,lr
80008e66:	20 5d       	sub	sp,20
80008e68:	18 97       	mov	r7,r12
80008e6a:	50 0b       	stdsp	sp[0x0],r11
80008e6c:	50 2a       	stdsp	sp[0x8],r10
80008e6e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008e70:	f8 c0 ff f0 	sub	r0,r12,-16
80008e74:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008e76:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008e7a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008e7c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80008e80:	f0 1f 00 2f 	mcall	80008f3c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008e84:	6e e9       	ld.w	r9,r7[0x38]
80008e86:	6e f8       	ld.w	r8,r7[0x3c]
80008e88:	10 39       	cp.w	r9,r8
80008e8a:	c1 42       	brcc	80008eb2 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008e8c:	40 1a       	lddsp	r10,sp[0x4]
80008e8e:	40 0b       	lddsp	r11,sp[0x0]
80008e90:	0e 9c       	mov	r12,r7
80008e92:	f0 1f 00 2c 	mcall	80008f40 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008e96:	6e 98       	ld.w	r8,r7[0x24]
80008e98:	58 08       	cp.w	r8,0
80008e9a:	c0 80       	breq	80008eaa <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80008e9c:	ee cc ff dc 	sub	r12,r7,-36
80008ea0:	f0 1f 00 29 	mcall	80008f44 <xQueueGenericSend+0xe0>
80008ea4:	58 1c       	cp.w	r12,1
80008ea6:	c0 21       	brne	80008eaa <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80008ea8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80008eaa:	f0 1f 00 28 	mcall	80008f48 <xQueueGenericSend+0xe4>
80008eae:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80008eb0:	c4 38       	rjmp	80008f36 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008eb2:	40 28       	lddsp	r8,sp[0x8]
80008eb4:	58 08       	cp.w	r8,0
80008eb6:	c0 51       	brne	80008ec0 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008eb8:	f0 1f 00 24 	mcall	80008f48 <xQueueGenericSend+0xe4>
80008ebc:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80008ebe:	c3 c8       	rjmp	80008f36 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80008ec0:	58 04       	cp.w	r4,0
80008ec2:	c0 51       	brne	80008ecc <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008ec4:	06 9c       	mov	r12,r3
80008ec6:	f0 1f 00 22 	mcall	80008f4c <xQueueGenericSend+0xe8>
80008eca:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008ecc:	f0 1f 00 1f 	mcall	80008f48 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008ed0:	f0 1f 00 20 	mcall	80008f50 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80008ed4:	f0 1f 00 1a 	mcall	80008f3c <xQueueGenericSend+0xd8>
80008ed8:	6f 18       	ld.w	r8,r7[0x44]
80008eda:	5b f8       	cp.w	r8,-1
80008edc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008ee0:	6f 28       	ld.w	r8,r7[0x48]
80008ee2:	5b f8       	cp.w	r8,-1
80008ee4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008ee8:	f0 1f 00 18 	mcall	80008f48 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008eec:	04 9b       	mov	r11,r2
80008eee:	06 9c       	mov	r12,r3
80008ef0:	f0 1f 00 19 	mcall	80008f54 <xQueueGenericSend+0xf0>
80008ef4:	c1 b1       	brne	80008f2a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008ef6:	f0 1f 00 12 	mcall	80008f3c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80008efa:	6e e5       	ld.w	r5,r7[0x38]
80008efc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80008efe:	f0 1f 00 13 	mcall	80008f48 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80008f02:	0c 35       	cp.w	r5,r6
80008f04:	c0 d1       	brne	80008f1e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008f06:	40 2b       	lddsp	r11,sp[0x8]
80008f08:	00 9c       	mov	r12,r0
80008f0a:	f0 1f 00 14 	mcall	80008f58 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80008f0e:	0e 9c       	mov	r12,r7
80008f10:	f0 1f 00 13 	mcall	80008f5c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80008f14:	f0 1f 00 13 	mcall	80008f60 <xQueueGenericSend+0xfc>
80008f18:	cb 41       	brne	80008e80 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80008f1a:	d7 33       	scall
80008f1c:	cb 2b       	rjmp	80008e80 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008f1e:	0e 9c       	mov	r12,r7
80008f20:	f0 1f 00 0f 	mcall	80008f5c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80008f24:	f0 1f 00 0f 	mcall	80008f60 <xQueueGenericSend+0xfc>
80008f28:	ca cb       	rjmp	80008e80 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80008f2a:	0e 9c       	mov	r12,r7
80008f2c:	f0 1f 00 0c 	mcall	80008f5c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80008f30:	f0 1f 00 0c 	mcall	80008f60 <xQueueGenericSend+0xfc>
80008f34:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80008f36:	2f bd       	sub	sp,-20
80008f38:	d8 32       	popm	r0-r7,pc
80008f3a:	00 00       	add	r0,r0
80008f3c:	80 00       	ld.sh	r0,r0[0x0]
80008f3e:	88 a4       	ld.uh	r4,r4[0x4]
80008f40:	80 00       	ld.sh	r0,r0[0x0]
80008f42:	8d 9c       	st.w	r6[0x24],r12
80008f44:	80 00       	ld.sh	r0,r0[0x0]
80008f46:	91 c8       	st.w	r8[0x30],r8
80008f48:	80 00       	ld.sh	r0,r0[0x0]
80008f4a:	89 b0       	st.w	r4[0x2c],r0
80008f4c:	80 00       	ld.sh	r0,r0[0x0]
80008f4e:	90 bc       	ld.uh	r12,r8[0x6]
80008f50:	80 00       	ld.sh	r0,r0[0x0]
80008f52:	90 30       	ld.sh	r0,r8[0x6]
80008f54:	80 00       	ld.sh	r0,r0[0x0]
80008f56:	93 58       	st.w	r9[0x14],r8
80008f58:	80 00       	ld.sh	r0,r0[0x0]
80008f5a:	95 b0       	st.w	r10[0x2c],r0
80008f5c:	80 00       	ld.sh	r0,r0[0x0]
80008f5e:	8b b8       	st.w	r5[0x2c],r8
80008f60:	80 00       	ld.sh	r0,r0[0x0]
80008f62:	93 ec       	st.w	r9[0x38],r12

80008f64 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80008f64:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008f68:	34 cc       	mov	r12,76
80008f6a:	f0 1f 00 12 	mcall	80008fb0 <xQueueCreateMutex+0x4c>
80008f6e:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80008f70:	c1 d0       	breq	80008faa <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80008f72:	30 06       	mov	r6,0
80008f74:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80008f76:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80008f78:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80008f7a:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008f7c:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80008f7e:	30 18       	mov	r8,1
80008f80:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80008f82:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80008f86:	3f f8       	mov	r8,-1
80008f88:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80008f8c:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008f90:	2f 0c       	sub	r12,-16
80008f92:	f0 1f 00 09 	mcall	80008fb4 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008f96:	ee cc ff dc 	sub	r12,r7,-36
80008f9a:	f0 1f 00 07 	mcall	80008fb4 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80008f9e:	0c 99       	mov	r9,r6
80008fa0:	0c 9a       	mov	r10,r6
80008fa2:	0c 9b       	mov	r11,r6
80008fa4:	0e 9c       	mov	r12,r7
80008fa6:	f0 1f 00 05 	mcall	80008fb8 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80008faa:	0e 9c       	mov	r12,r7
80008fac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008fb0:	80 00       	ld.sh	r0,r0[0x0]
80008fb2:	8b 10       	st.w	r5[0x4],r0
80008fb4:	80 00       	ld.sh	r0,r0[0x0]
80008fb6:	87 80       	st.w	r3[0x20],r0
80008fb8:	80 00       	ld.sh	r0,r0[0x0]
80008fba:	8e 64       	ld.sh	r4,r7[0xc]

80008fbc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80008fbc:	d4 21       	pushm	r4-r7,lr
80008fbe:	18 97       	mov	r7,r12
80008fc0:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80008fc2:	58 0c       	cp.w	r12,0
80008fc4:	c2 f0       	breq	80009022 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008fc6:	34 cc       	mov	r12,76
80008fc8:	f0 1f 00 17 	mcall	80009024 <xQueueCreate+0x68>
80008fcc:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80008fce:	c2 a0       	breq	80009022 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80008fd0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80008fd4:	e8 cc ff ff 	sub	r12,r4,-1
80008fd8:	f0 1f 00 13 	mcall	80009024 <xQueueCreate+0x68>
80008fdc:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80008fde:	c1 e0       	breq	8000901a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80008fe0:	f8 04 00 04 	add	r4,r12,r4
80008fe4:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008fe6:	30 08       	mov	r8,0
80008fe8:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80008fea:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80008fec:	ee c8 00 01 	sub	r8,r7,1
80008ff0:	ad 38       	mul	r8,r6
80008ff2:	10 0c       	add	r12,r8
80008ff4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80008ff6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80008ff8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80008ffc:	3f f8       	mov	r8,-1
80008ffe:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80009002:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80009006:	ea cc ff f0 	sub	r12,r5,-16
8000900a:	f0 1f 00 08 	mcall	80009028 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000900e:	ea cc ff dc 	sub	r12,r5,-36
80009012:	f0 1f 00 06 	mcall	80009028 <xQueueCreate+0x6c>
80009016:	0a 9c       	mov	r12,r5
80009018:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000901a:	0a 9c       	mov	r12,r5
8000901c:	f0 1f 00 04 	mcall	8000902c <xQueueCreate+0x70>
80009020:	d8 2a       	popm	r4-r7,pc,r12=0
80009022:	d8 2a       	popm	r4-r7,pc,r12=0
80009024:	80 00       	ld.sh	r0,r0[0x0]
80009026:	8b 10       	st.w	r5[0x4],r0
80009028:	80 00       	ld.sh	r0,r0[0x0]
8000902a:	87 80       	st.w	r3[0x20],r0
8000902c:	80 00       	ld.sh	r0,r0[0x0]
8000902e:	8a e8       	ld.uh	r8,r5[0xc]

80009030 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80009030:	48 38       	lddpc	r8,8000903c <vTaskSuspendAll+0xc>
80009032:	70 09       	ld.w	r9,r8[0x0]
80009034:	2f f9       	sub	r9,-1
80009036:	91 09       	st.w	r8[0x0],r9
}
80009038:	5e fc       	retal	r12
8000903a:	00 00       	add	r0,r0
8000903c:	00 00       	add	r0,r0
8000903e:	12 4c       	or	r12,r9

80009040 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80009040:	49 a8       	lddpc	r8,800090a8 <vTaskSwitchContext+0x68>
80009042:	70 08       	ld.w	r8,r8[0x0]
80009044:	58 08       	cp.w	r8,0
80009046:	c0 b1       	brne	8000905c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009048:	49 98       	lddpc	r8,800090ac <vTaskSwitchContext+0x6c>
8000904a:	70 08       	ld.w	r8,r8[0x0]
8000904c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009050:	49 89       	lddpc	r9,800090b0 <vTaskSwitchContext+0x70>
80009052:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80009056:	58 08       	cp.w	r8,0
80009058:	c0 60       	breq	80009064 <vTaskSwitchContext+0x24>
8000905a:	c1 18       	rjmp	8000907c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000905c:	30 19       	mov	r9,1
8000905e:	49 68       	lddpc	r8,800090b4 <vTaskSwitchContext+0x74>
80009060:	91 09       	st.w	r8[0x0],r9
80009062:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009064:	49 28       	lddpc	r8,800090ac <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009066:	49 3a       	lddpc	r10,800090b0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009068:	70 09       	ld.w	r9,r8[0x0]
8000906a:	20 19       	sub	r9,1
8000906c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000906e:	70 09       	ld.w	r9,r8[0x0]
80009070:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009074:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80009078:	58 09       	cp.w	r9,0
8000907a:	cf 70       	breq	80009068 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000907c:	48 c8       	lddpc	r8,800090ac <vTaskSwitchContext+0x6c>
8000907e:	70 08       	ld.w	r8,r8[0x0]
80009080:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009084:	48 b9       	lddpc	r9,800090b0 <vTaskSwitchContext+0x70>
80009086:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000908a:	70 19       	ld.w	r9,r8[0x4]
8000908c:	72 19       	ld.w	r9,r9[0x4]
8000908e:	91 19       	st.w	r8[0x4],r9
80009090:	f0 ca ff f8 	sub	r10,r8,-8
80009094:	14 39       	cp.w	r9,r10
80009096:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000909a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000909e:	70 18       	ld.w	r8,r8[0x4]
800090a0:	70 39       	ld.w	r9,r8[0xc]
800090a2:	48 68       	lddpc	r8,800090b8 <vTaskSwitchContext+0x78>
800090a4:	91 09       	st.w	r8[0x0],r9
800090a6:	5e fc       	retal	r12
800090a8:	00 00       	add	r0,r0
800090aa:	12 4c       	or	r12,r9
800090ac:	00 00       	add	r0,r0
800090ae:	12 84       	andn	r4,r9
800090b0:	00 00       	add	r0,r0
800090b2:	11 68       	ld.uh	r8,--r8
800090b4:	00 00       	add	r0,r0
800090b6:	12 6c       	and	r12,r9
800090b8:	00 00       	add	r0,r0
800090ba:	12 1c       	sub	r12,r9

800090bc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800090bc:	48 48       	lddpc	r8,800090cc <vTaskSetTimeOutState+0x10>
800090be:	70 08       	ld.w	r8,r8[0x0]
800090c0:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800090c2:	48 48       	lddpc	r8,800090d0 <vTaskSetTimeOutState+0x14>
800090c4:	70 08       	ld.w	r8,r8[0x0]
800090c6:	99 18       	st.w	r12[0x4],r8
}
800090c8:	5e fc       	retal	r12
800090ca:	00 00       	add	r0,r0
800090cc:	00 00       	add	r0,r0
800090ce:	11 60       	ld.uh	r0,--r8
800090d0:	00 00       	add	r0,r0
800090d2:	12 48       	or	r8,r9

800090d4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800090d4:	30 19       	mov	r9,1
800090d6:	48 28       	lddpc	r8,800090dc <vTaskMissedYield+0x8>
800090d8:	91 09       	st.w	r8[0x0],r9
}
800090da:	5e fc       	retal	r12
800090dc:	00 00       	add	r0,r0
800090de:	12 6c       	and	r12,r9

800090e0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800090e0:	48 28       	lddpc	r8,800090e8 <xTaskGetCurrentTaskHandle+0x8>
800090e2:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800090e4:	5e fc       	retal	r12
800090e6:	00 00       	add	r0,r0
800090e8:	00 00       	add	r0,r0
800090ea:	12 1c       	sub	r12,r9

800090ec <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800090ec:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800090f0:	58 0c       	cp.w	r12,0
800090f2:	c1 f0       	breq	80009130 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800090f4:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800090f6:	78 b9       	ld.w	r9,r12[0x2c]
800090f8:	79 18       	ld.w	r8,r12[0x44]
800090fa:	10 39       	cp.w	r9,r8
800090fc:	c1 a0       	breq	80009130 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800090fe:	f8 c6 ff fc 	sub	r6,r12,-4
80009102:	0c 9c       	mov	r12,r6
80009104:	f0 1f 00 0c 	mcall	80009134 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009108:	6f 1c       	ld.w	r12,r7[0x44]
8000910a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000910c:	f8 08 11 08 	rsub	r8,r12,8
80009110:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80009112:	48 a8       	lddpc	r8,80009138 <vTaskPriorityDisinherit+0x4c>
80009114:	70 08       	ld.w	r8,r8[0x0]
80009116:	10 3c       	cp.w	r12,r8
80009118:	e0 88 00 04 	brls	80009120 <vTaskPriorityDisinherit+0x34>
8000911c:	48 78       	lddpc	r8,80009138 <vTaskPriorityDisinherit+0x4c>
8000911e:	91 0c       	st.w	r8[0x0],r12
80009120:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009124:	0c 9b       	mov	r11,r6
80009126:	48 68       	lddpc	r8,8000913c <vTaskPriorityDisinherit+0x50>
80009128:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000912c:	f0 1f 00 05 	mcall	80009140 <vTaskPriorityDisinherit+0x54>
80009130:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009134:	80 00       	ld.sh	r0,r0[0x0]
80009136:	87 ea       	st.w	r3[0x38],r10
80009138:	00 00       	add	r0,r0
8000913a:	12 84       	andn	r4,r9
8000913c:	00 00       	add	r0,r0
8000913e:	11 68       	ld.uh	r8,--r8
80009140:	80 00       	ld.sh	r0,r0[0x0]
80009142:	87 9a       	st.w	r3[0x24],r10

80009144 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80009144:	eb cd 40 c0 	pushm	r6-r7,lr
80009148:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000914a:	49 b8       	lddpc	r8,800091b4 <vTaskPriorityInherit+0x70>
8000914c:	70 08       	ld.w	r8,r8[0x0]
8000914e:	78 b9       	ld.w	r9,r12[0x2c]
80009150:	70 b8       	ld.w	r8,r8[0x2c]
80009152:	10 39       	cp.w	r9,r8
80009154:	c2 d2       	brcc	800091ae <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80009156:	49 88       	lddpc	r8,800091b4 <vTaskPriorityInherit+0x70>
80009158:	70 08       	ld.w	r8,r8[0x0]
8000915a:	70 b8       	ld.w	r8,r8[0x2c]
8000915c:	f0 08 11 08 	rsub	r8,r8,8
80009160:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80009162:	f2 09 00 28 	add	r8,r9,r9<<0x2
80009166:	49 59       	lddpc	r9,800091b8 <vTaskPriorityInherit+0x74>
80009168:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000916c:	78 59       	ld.w	r9,r12[0x14]
8000916e:	10 39       	cp.w	r9,r8
80009170:	c1 b1       	brne	800091a6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80009172:	f8 c6 ff fc 	sub	r6,r12,-4
80009176:	0c 9c       	mov	r12,r6
80009178:	f0 1f 00 11 	mcall	800091bc <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000917c:	48 e8       	lddpc	r8,800091b4 <vTaskPriorityInherit+0x70>
8000917e:	70 08       	ld.w	r8,r8[0x0]
80009180:	70 bc       	ld.w	r12,r8[0x2c]
80009182:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80009184:	48 f8       	lddpc	r8,800091c0 <vTaskPriorityInherit+0x7c>
80009186:	70 08       	ld.w	r8,r8[0x0]
80009188:	10 3c       	cp.w	r12,r8
8000918a:	e0 88 00 04 	brls	80009192 <vTaskPriorityInherit+0x4e>
8000918e:	48 d8       	lddpc	r8,800091c0 <vTaskPriorityInherit+0x7c>
80009190:	91 0c       	st.w	r8[0x0],r12
80009192:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009196:	0c 9b       	mov	r11,r6
80009198:	48 88       	lddpc	r8,800091b8 <vTaskPriorityInherit+0x74>
8000919a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000919e:	f0 1f 00 0a 	mcall	800091c4 <vTaskPriorityInherit+0x80>
800091a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800091a6:	48 48       	lddpc	r8,800091b4 <vTaskPriorityInherit+0x70>
800091a8:	70 08       	ld.w	r8,r8[0x0]
800091aa:	70 b8       	ld.w	r8,r8[0x2c]
800091ac:	99 b8       	st.w	r12[0x2c],r8
800091ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800091b2:	00 00       	add	r0,r0
800091b4:	00 00       	add	r0,r0
800091b6:	12 1c       	sub	r12,r9
800091b8:	00 00       	add	r0,r0
800091ba:	11 68       	ld.uh	r8,--r8
800091bc:	80 00       	ld.sh	r0,r0[0x0]
800091be:	87 ea       	st.w	r3[0x38],r10
800091c0:	00 00       	add	r0,r0
800091c2:	12 84       	andn	r4,r9
800091c4:	80 00       	ld.sh	r0,r0[0x0]
800091c6:	87 9a       	st.w	r3[0x24],r10

800091c8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800091c8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800091cc:	78 38       	ld.w	r8,r12[0xc]
800091ce:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800091d0:	ee c6 ff e8 	sub	r6,r7,-24
800091d4:	0c 9c       	mov	r12,r6
800091d6:	f0 1f 00 15 	mcall	80009228 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800091da:	49 58       	lddpc	r8,8000922c <xTaskRemoveFromEventList+0x64>
800091dc:	70 08       	ld.w	r8,r8[0x0]
800091de:	58 08       	cp.w	r8,0
800091e0:	c1 71       	brne	8000920e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800091e2:	ee c6 ff fc 	sub	r6,r7,-4
800091e6:	0c 9c       	mov	r12,r6
800091e8:	f0 1f 00 10 	mcall	80009228 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800091ec:	6e bc       	ld.w	r12,r7[0x2c]
800091ee:	49 18       	lddpc	r8,80009230 <xTaskRemoveFromEventList+0x68>
800091f0:	70 08       	ld.w	r8,r8[0x0]
800091f2:	10 3c       	cp.w	r12,r8
800091f4:	e0 88 00 04 	brls	800091fc <xTaskRemoveFromEventList+0x34>
800091f8:	48 e8       	lddpc	r8,80009230 <xTaskRemoveFromEventList+0x68>
800091fa:	91 0c       	st.w	r8[0x0],r12
800091fc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009200:	0c 9b       	mov	r11,r6
80009202:	48 d8       	lddpc	r8,80009234 <xTaskRemoveFromEventList+0x6c>
80009204:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009208:	f0 1f 00 0c 	mcall	80009238 <xTaskRemoveFromEventList+0x70>
8000920c:	c0 58       	rjmp	80009216 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000920e:	0c 9b       	mov	r11,r6
80009210:	48 bc       	lddpc	r12,8000923c <xTaskRemoveFromEventList+0x74>
80009212:	f0 1f 00 0a 	mcall	80009238 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009216:	48 b8       	lddpc	r8,80009240 <xTaskRemoveFromEventList+0x78>
80009218:	70 08       	ld.w	r8,r8[0x0]
8000921a:	6e b9       	ld.w	r9,r7[0x2c]
8000921c:	70 b8       	ld.w	r8,r8[0x2c]
8000921e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80009220:	5f 2c       	srhs	r12
80009222:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009226:	00 00       	add	r0,r0
80009228:	80 00       	ld.sh	r0,r0[0x0]
8000922a:	87 ea       	st.w	r3[0x38],r10
8000922c:	00 00       	add	r0,r0
8000922e:	12 4c       	or	r12,r9
80009230:	00 00       	add	r0,r0
80009232:	12 84       	andn	r4,r9
80009234:	00 00       	add	r0,r0
80009236:	11 68       	ld.uh	r8,--r8
80009238:	80 00       	ld.sh	r0,r0[0x0]
8000923a:	87 9a       	st.w	r3[0x24],r10
8000923c:	00 00       	add	r0,r0
8000923e:	12 20       	rsub	r0,r9
80009240:	00 00       	add	r0,r0
80009242:	12 1c       	sub	r12,r9

80009244 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009244:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009248:	4b 98       	lddpc	r8,8000932c <vTaskIncrementTick+0xe8>
8000924a:	70 08       	ld.w	r8,r8[0x0]
8000924c:	58 08       	cp.w	r8,0
8000924e:	c6 91       	brne	80009320 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80009250:	4b 88       	lddpc	r8,80009330 <vTaskIncrementTick+0xec>
80009252:	70 09       	ld.w	r9,r8[0x0]
80009254:	2f f9       	sub	r9,-1
80009256:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80009258:	70 08       	ld.w	r8,r8[0x0]
8000925a:	58 08       	cp.w	r8,0
8000925c:	c1 a1       	brne	80009290 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000925e:	4b 68       	lddpc	r8,80009334 <vTaskIncrementTick+0xf0>
80009260:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80009262:	4b 69       	lddpc	r9,80009338 <vTaskIncrementTick+0xf4>
80009264:	72 0b       	ld.w	r11,r9[0x0]
80009266:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80009268:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000926a:	4b 59       	lddpc	r9,8000933c <vTaskIncrementTick+0xf8>
8000926c:	72 0a       	ld.w	r10,r9[0x0]
8000926e:	2f fa       	sub	r10,-1
80009270:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80009272:	70 08       	ld.w	r8,r8[0x0]
80009274:	70 08       	ld.w	r8,r8[0x0]
80009276:	58 08       	cp.w	r8,0
80009278:	c0 51       	brne	80009282 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000927a:	3f f9       	mov	r9,-1
8000927c:	4b 18       	lddpc	r8,80009340 <vTaskIncrementTick+0xfc>
8000927e:	91 09       	st.w	r8[0x0],r9
80009280:	c0 88       	rjmp	80009290 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80009282:	4a d8       	lddpc	r8,80009334 <vTaskIncrementTick+0xf0>
80009284:	70 08       	ld.w	r8,r8[0x0]
80009286:	70 38       	ld.w	r8,r8[0xc]
80009288:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000928a:	70 19       	ld.w	r9,r8[0x4]
8000928c:	4a d8       	lddpc	r8,80009340 <vTaskIncrementTick+0xfc>
8000928e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80009290:	4a 88       	lddpc	r8,80009330 <vTaskIncrementTick+0xec>
80009292:	70 09       	ld.w	r9,r8[0x0]
80009294:	4a b8       	lddpc	r8,80009340 <vTaskIncrementTick+0xfc>
80009296:	70 08       	ld.w	r8,r8[0x0]
80009298:	10 39       	cp.w	r9,r8
8000929a:	c4 73       	brcs	80009328 <vTaskIncrementTick+0xe4>
8000929c:	4a 68       	lddpc	r8,80009334 <vTaskIncrementTick+0xf0>
8000929e:	70 08       	ld.w	r8,r8[0x0]
800092a0:	70 08       	ld.w	r8,r8[0x0]
800092a2:	58 08       	cp.w	r8,0
800092a4:	c0 c0       	breq	800092bc <vTaskIncrementTick+0x78>
800092a6:	4a 48       	lddpc	r8,80009334 <vTaskIncrementTick+0xf0>
800092a8:	70 08       	ld.w	r8,r8[0x0]
800092aa:	70 38       	ld.w	r8,r8[0xc]
800092ac:	70 37       	ld.w	r7,r8[0xc]
800092ae:	6e 18       	ld.w	r8,r7[0x4]
800092b0:	4a 09       	lddpc	r9,80009330 <vTaskIncrementTick+0xec>
800092b2:	72 09       	ld.w	r9,r9[0x0]
800092b4:	12 38       	cp.w	r8,r9
800092b6:	e0 88 00 14 	brls	800092de <vTaskIncrementTick+0x9a>
800092ba:	c0 e8       	rjmp	800092d6 <vTaskIncrementTick+0x92>
800092bc:	3f f9       	mov	r9,-1
800092be:	4a 18       	lddpc	r8,80009340 <vTaskIncrementTick+0xfc>
800092c0:	91 09       	st.w	r8[0x0],r9
800092c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800092c6:	6a 08       	ld.w	r8,r5[0x0]
800092c8:	70 38       	ld.w	r8,r8[0xc]
800092ca:	70 37       	ld.w	r7,r8[0xc]
800092cc:	6e 18       	ld.w	r8,r7[0x4]
800092ce:	64 09       	ld.w	r9,r2[0x0]
800092d0:	12 38       	cp.w	r8,r9
800092d2:	e0 88 00 0a 	brls	800092e6 <vTaskIncrementTick+0xa2>
800092d6:	49 b9       	lddpc	r9,80009340 <vTaskIncrementTick+0xfc>
800092d8:	93 08       	st.w	r9[0x0],r8
800092da:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800092de:	49 a4       	lddpc	r4,80009344 <vTaskIncrementTick+0x100>
800092e0:	49 a3       	lddpc	r3,80009348 <vTaskIncrementTick+0x104>
800092e2:	49 55       	lddpc	r5,80009334 <vTaskIncrementTick+0xf0>
800092e4:	49 32       	lddpc	r2,80009330 <vTaskIncrementTick+0xec>
800092e6:	ee c6 ff fc 	sub	r6,r7,-4
800092ea:	0c 9c       	mov	r12,r6
800092ec:	f0 1f 00 18 	mcall	8000934c <vTaskIncrementTick+0x108>
800092f0:	6e a8       	ld.w	r8,r7[0x28]
800092f2:	58 08       	cp.w	r8,0
800092f4:	c0 50       	breq	800092fe <vTaskIncrementTick+0xba>
800092f6:	ee cc ff e8 	sub	r12,r7,-24
800092fa:	f0 1f 00 15 	mcall	8000934c <vTaskIncrementTick+0x108>
800092fe:	6e bc       	ld.w	r12,r7[0x2c]
80009300:	68 08       	ld.w	r8,r4[0x0]
80009302:	10 3c       	cp.w	r12,r8
80009304:	e9 fc ba 00 	st.whi	r4[0x0],r12
80009308:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000930c:	0c 9b       	mov	r11,r6
8000930e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80009312:	f0 1f 00 10 	mcall	80009350 <vTaskIncrementTick+0x10c>
80009316:	6a 08       	ld.w	r8,r5[0x0]
80009318:	70 08       	ld.w	r8,r8[0x0]
8000931a:	58 08       	cp.w	r8,0
8000931c:	cd 51       	brne	800092c6 <vTaskIncrementTick+0x82>
8000931e:	cc fb       	rjmp	800092bc <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80009320:	48 d8       	lddpc	r8,80009354 <vTaskIncrementTick+0x110>
80009322:	70 09       	ld.w	r9,r8[0x0]
80009324:	2f f9       	sub	r9,-1
80009326:	91 09       	st.w	r8[0x0],r9
80009328:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000932c:	00 00       	add	r0,r0
8000932e:	12 4c       	or	r12,r9
80009330:	00 00       	add	r0,r0
80009332:	12 48       	or	r8,r9
80009334:	00 00       	add	r0,r0
80009336:	11 54       	ld.sh	r4,--r8
80009338:	00 00       	add	r0,r0
8000933a:	11 64       	ld.uh	r4,--r8
8000933c:	00 00       	add	r0,r0
8000933e:	11 60       	ld.uh	r0,--r8
80009340:	00 00       	add	r0,r0
80009342:	05 34       	ld.ub	r4,r2++
80009344:	00 00       	add	r0,r0
80009346:	12 84       	andn	r4,r9
80009348:	00 00       	add	r0,r0
8000934a:	11 68       	ld.uh	r8,--r8
8000934c:	80 00       	ld.sh	r0,r0[0x0]
8000934e:	87 ea       	st.w	r3[0x38],r10
80009350:	80 00       	ld.sh	r0,r0[0x0]
80009352:	87 9a       	st.w	r3[0x24],r10
80009354:	00 00       	add	r0,r0
80009356:	11 4c       	ld.w	r12,--r8

80009358 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80009358:	eb cd 40 c0 	pushm	r6-r7,lr
8000935c:	18 97       	mov	r7,r12
8000935e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80009360:	f0 1f 00 15 	mcall	800093b4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80009364:	6c 08       	ld.w	r8,r6[0x0]
80009366:	5b f8       	cp.w	r8,-1
80009368:	c0 31       	brne	8000936e <xTaskCheckForTimeOut+0x16>
8000936a:	30 07       	mov	r7,0
8000936c:	c1 f8       	rjmp	800093aa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000936e:	49 39       	lddpc	r9,800093b8 <xTaskCheckForTimeOut+0x60>
80009370:	72 09       	ld.w	r9,r9[0x0]
80009372:	6e 0a       	ld.w	r10,r7[0x0]
80009374:	12 3a       	cp.w	r10,r9
80009376:	c0 70       	breq	80009384 <xTaskCheckForTimeOut+0x2c>
80009378:	49 19       	lddpc	r9,800093bc <xTaskCheckForTimeOut+0x64>
8000937a:	72 09       	ld.w	r9,r9[0x0]
8000937c:	6e 1a       	ld.w	r10,r7[0x4]
8000937e:	12 3a       	cp.w	r10,r9
80009380:	e0 88 00 14 	brls	800093a8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80009384:	48 e9       	lddpc	r9,800093bc <xTaskCheckForTimeOut+0x64>
80009386:	72 0a       	ld.w	r10,r9[0x0]
80009388:	6e 19       	ld.w	r9,r7[0x4]
8000938a:	12 1a       	sub	r10,r9
8000938c:	14 38       	cp.w	r8,r10
8000938e:	e0 88 00 0d 	brls	800093a8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80009392:	48 ba       	lddpc	r10,800093bc <xTaskCheckForTimeOut+0x64>
80009394:	74 0a       	ld.w	r10,r10[0x0]
80009396:	14 19       	sub	r9,r10
80009398:	f2 08 00 08 	add	r8,r9,r8
8000939c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000939e:	0e 9c       	mov	r12,r7
800093a0:	f0 1f 00 08 	mcall	800093c0 <xTaskCheckForTimeOut+0x68>
800093a4:	30 07       	mov	r7,0
800093a6:	c0 28       	rjmp	800093aa <xTaskCheckForTimeOut+0x52>
800093a8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800093aa:	f0 1f 00 07 	mcall	800093c4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800093ae:	0e 9c       	mov	r12,r7
800093b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800093b4:	80 00       	ld.sh	r0,r0[0x0]
800093b6:	88 a4       	ld.uh	r4,r4[0x4]
800093b8:	00 00       	add	r0,r0
800093ba:	11 60       	ld.uh	r0,--r8
800093bc:	00 00       	add	r0,r0
800093be:	12 48       	or	r8,r9
800093c0:	80 00       	ld.sh	r0,r0[0x0]
800093c2:	90 bc       	ld.uh	r12,r8[0x6]
800093c4:	80 00       	ld.sh	r0,r0[0x0]
800093c6:	89 b0       	st.w	r4[0x2c],r0

800093c8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800093c8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800093cc:	f0 1f 00 05 	mcall	800093e0 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800093d0:	48 58       	lddpc	r8,800093e4 <xTaskGetTickCount+0x1c>
800093d2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800093d4:	f0 1f 00 05 	mcall	800093e8 <xTaskGetTickCount+0x20>

	return xTicks;
}
800093d8:	0e 9c       	mov	r12,r7
800093da:	e3 cd 80 80 	ldm	sp++,r7,pc
800093de:	00 00       	add	r0,r0
800093e0:	80 00       	ld.sh	r0,r0[0x0]
800093e2:	88 a4       	ld.uh	r4,r4[0x4]
800093e4:	00 00       	add	r0,r0
800093e6:	12 48       	or	r8,r9
800093e8:	80 00       	ld.sh	r0,r0[0x0]
800093ea:	89 b0       	st.w	r4[0x2c],r0

800093ec <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800093ec:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800093f0:	f0 1f 00 2c 	mcall	800094a0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800093f4:	4a c8       	lddpc	r8,800094a4 <xTaskResumeAll+0xb8>
800093f6:	70 09       	ld.w	r9,r8[0x0]
800093f8:	20 19       	sub	r9,1
800093fa:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800093fc:	70 08       	ld.w	r8,r8[0x0]
800093fe:	58 08       	cp.w	r8,0
80009400:	c4 91       	brne	80009492 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80009402:	4a a8       	lddpc	r8,800094a8 <xTaskResumeAll+0xbc>
80009404:	70 08       	ld.w	r8,r8[0x0]
80009406:	58 08       	cp.w	r8,0
80009408:	c4 50       	breq	80009492 <xTaskResumeAll+0xa6>
8000940a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000940c:	4a 85       	lddpc	r5,800094ac <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000940e:	4a 93       	lddpc	r3,800094b0 <xTaskResumeAll+0xc4>
80009410:	4a 92       	lddpc	r2,800094b4 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009412:	4a a1       	lddpc	r1,800094b8 <xTaskResumeAll+0xcc>
80009414:	c1 e8       	rjmp	80009450 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80009416:	6a 38       	ld.w	r8,r5[0xc]
80009418:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000941a:	ee cc ff e8 	sub	r12,r7,-24
8000941e:	f0 1f 00 28 	mcall	800094bc <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80009422:	ee c6 ff fc 	sub	r6,r7,-4
80009426:	0c 9c       	mov	r12,r6
80009428:	f0 1f 00 25 	mcall	800094bc <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000942c:	6e bc       	ld.w	r12,r7[0x2c]
8000942e:	66 08       	ld.w	r8,r3[0x0]
80009430:	10 3c       	cp.w	r12,r8
80009432:	e7 fc ba 00 	st.whi	r3[0x0],r12
80009436:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000943a:	0c 9b       	mov	r11,r6
8000943c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80009440:	f0 1f 00 20 	mcall	800094c0 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009444:	62 08       	ld.w	r8,r1[0x0]
80009446:	6e b9       	ld.w	r9,r7[0x2c]
80009448:	70 b8       	ld.w	r8,r8[0x2c]
8000944a:	10 39       	cp.w	r9,r8
8000944c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009450:	6a 08       	ld.w	r8,r5[0x0]
80009452:	58 08       	cp.w	r8,0
80009454:	ce 11       	brne	80009416 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009456:	49 c8       	lddpc	r8,800094c4 <xTaskResumeAll+0xd8>
80009458:	70 08       	ld.w	r8,r8[0x0]
8000945a:	58 08       	cp.w	r8,0
8000945c:	c0 f0       	breq	8000947a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000945e:	49 a8       	lddpc	r8,800094c4 <xTaskResumeAll+0xd8>
80009460:	70 08       	ld.w	r8,r8[0x0]
80009462:	58 08       	cp.w	r8,0
80009464:	c1 10       	breq	80009486 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80009466:	49 87       	lddpc	r7,800094c4 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80009468:	f0 1f 00 18 	mcall	800094c8 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000946c:	6e 08       	ld.w	r8,r7[0x0]
8000946e:	20 18       	sub	r8,1
80009470:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009472:	6e 08       	ld.w	r8,r7[0x0]
80009474:	58 08       	cp.w	r8,0
80009476:	cf 91       	brne	80009468 <xTaskResumeAll+0x7c>
80009478:	c0 78       	rjmp	80009486 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000947a:	58 14       	cp.w	r4,1
8000947c:	c0 50       	breq	80009486 <xTaskResumeAll+0x9a>
8000947e:	49 48       	lddpc	r8,800094cc <xTaskResumeAll+0xe0>
80009480:	70 08       	ld.w	r8,r8[0x0]
80009482:	58 18       	cp.w	r8,1
80009484:	c0 71       	brne	80009492 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80009486:	30 09       	mov	r9,0
80009488:	49 18       	lddpc	r8,800094cc <xTaskResumeAll+0xe0>
8000948a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000948c:	d7 33       	scall
8000948e:	30 17       	mov	r7,1
80009490:	c0 28       	rjmp	80009494 <xTaskResumeAll+0xa8>
80009492:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80009494:	f0 1f 00 0f 	mcall	800094d0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80009498:	0e 9c       	mov	r12,r7
8000949a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000949e:	00 00       	add	r0,r0
800094a0:	80 00       	ld.sh	r0,r0[0x0]
800094a2:	88 a4       	ld.uh	r4,r4[0x4]
800094a4:	00 00       	add	r0,r0
800094a6:	12 4c       	or	r12,r9
800094a8:	00 00       	add	r0,r0
800094aa:	12 68       	and	r8,r9
800094ac:	00 00       	add	r0,r0
800094ae:	12 20       	rsub	r0,r9
800094b0:	00 00       	add	r0,r0
800094b2:	12 84       	andn	r4,r9
800094b4:	00 00       	add	r0,r0
800094b6:	11 68       	ld.uh	r8,--r8
800094b8:	00 00       	add	r0,r0
800094ba:	12 1c       	sub	r12,r9
800094bc:	80 00       	ld.sh	r0,r0[0x0]
800094be:	87 ea       	st.w	r3[0x38],r10
800094c0:	80 00       	ld.sh	r0,r0[0x0]
800094c2:	87 9a       	st.w	r3[0x24],r10
800094c4:	00 00       	add	r0,r0
800094c6:	11 4c       	ld.w	r12,--r8
800094c8:	80 00       	ld.sh	r0,r0[0x0]
800094ca:	92 44       	ld.sh	r4,r9[0x8]
800094cc:	00 00       	add	r0,r0
800094ce:	12 6c       	and	r12,r9
800094d0:	80 00       	ld.sh	r0,r0[0x0]
800094d2:	89 b0       	st.w	r4[0x2c],r0

800094d4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800094d4:	eb cd 40 80 	pushm	r7,lr
800094d8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800094da:	49 08       	lddpc	r8,80009518 <prvAddCurrentTaskToDelayedList+0x44>
800094dc:	70 08       	ld.w	r8,r8[0x0]
800094de:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800094e0:	48 f8       	lddpc	r8,8000951c <prvAddCurrentTaskToDelayedList+0x48>
800094e2:	70 08       	ld.w	r8,r8[0x0]
800094e4:	10 3c       	cp.w	r12,r8
800094e6:	c0 a2       	brcc	800094fa <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800094e8:	48 c8       	lddpc	r8,80009518 <prvAddCurrentTaskToDelayedList+0x44>
800094ea:	70 0b       	ld.w	r11,r8[0x0]
800094ec:	48 d8       	lddpc	r8,80009520 <prvAddCurrentTaskToDelayedList+0x4c>
800094ee:	70 0c       	ld.w	r12,r8[0x0]
800094f0:	2f cb       	sub	r11,-4
800094f2:	f0 1f 00 0d 	mcall	80009524 <prvAddCurrentTaskToDelayedList+0x50>
800094f6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800094fa:	48 88       	lddpc	r8,80009518 <prvAddCurrentTaskToDelayedList+0x44>
800094fc:	70 0b       	ld.w	r11,r8[0x0]
800094fe:	48 b8       	lddpc	r8,80009528 <prvAddCurrentTaskToDelayedList+0x54>
80009500:	70 0c       	ld.w	r12,r8[0x0]
80009502:	2f cb       	sub	r11,-4
80009504:	f0 1f 00 08 	mcall	80009524 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009508:	48 98       	lddpc	r8,8000952c <prvAddCurrentTaskToDelayedList+0x58>
8000950a:	70 08       	ld.w	r8,r8[0x0]
8000950c:	10 37       	cp.w	r7,r8
8000950e:	c0 32       	brcc	80009514 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80009510:	48 78       	lddpc	r8,8000952c <prvAddCurrentTaskToDelayedList+0x58>
80009512:	91 07       	st.w	r8[0x0],r7
80009514:	e3 cd 80 80 	ldm	sp++,r7,pc
80009518:	00 00       	add	r0,r0
8000951a:	12 1c       	sub	r12,r9
8000951c:	00 00       	add	r0,r0
8000951e:	12 48       	or	r8,r9
80009520:	00 00       	add	r0,r0
80009522:	11 64       	ld.uh	r4,--r8
80009524:	80 00       	ld.sh	r0,r0[0x0]
80009526:	87 b6       	st.w	r3[0x2c],r6
80009528:	00 00       	add	r0,r0
8000952a:	11 54       	ld.sh	r4,--r8
8000952c:	00 00       	add	r0,r0
8000952e:	05 34       	ld.ub	r4,r2++

80009530 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009530:	eb cd 40 c0 	pushm	r6-r7,lr
80009534:	18 96       	mov	r6,r12
80009536:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80009538:	f0 1f 00 18 	mcall	80009598 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000953c:	6c 08       	ld.w	r8,r6[0x0]
8000953e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80009540:	49 79       	lddpc	r9,8000959c <vTaskDelayUntil+0x6c>
80009542:	72 09       	ld.w	r9,r9[0x0]
80009544:	12 38       	cp.w	r8,r9
80009546:	e0 88 00 0c 	brls	8000955e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000954a:	0e 38       	cp.w	r8,r7
8000954c:	e0 88 00 22 	brls	80009590 <vTaskDelayUntil+0x60>
80009550:	49 38       	lddpc	r8,8000959c <vTaskDelayUntil+0x6c>
80009552:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009554:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80009556:	10 37       	cp.w	r7,r8
80009558:	e0 88 00 14 	brls	80009580 <vTaskDelayUntil+0x50>
8000955c:	c0 a8       	rjmp	80009570 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000955e:	0e 38       	cp.w	r8,r7
80009560:	e0 8b 00 16 	brhi	8000958c <vTaskDelayUntil+0x5c>
80009564:	48 e8       	lddpc	r8,8000959c <vTaskDelayUntil+0x6c>
80009566:	70 08       	ld.w	r8,r8[0x0]
80009568:	10 37       	cp.w	r7,r8
8000956a:	e0 8b 00 11 	brhi	8000958c <vTaskDelayUntil+0x5c>
8000956e:	c1 18       	rjmp	80009590 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009570:	48 c8       	lddpc	r8,800095a0 <vTaskDelayUntil+0x70>
80009572:	70 0c       	ld.w	r12,r8[0x0]
80009574:	2f cc       	sub	r12,-4
80009576:	f0 1f 00 0c 	mcall	800095a4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000957a:	0e 9c       	mov	r12,r7
8000957c:	f0 1f 00 0b 	mcall	800095a8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009580:	f0 1f 00 0b 	mcall	800095ac <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80009584:	c0 81       	brne	80009594 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80009586:	d7 33       	scall
80009588:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000958c:	8d 07       	st.w	r6[0x0],r7
8000958e:	cf 1b       	rjmp	80009570 <vTaskDelayUntil+0x40>
80009590:	8d 07       	st.w	r6[0x0],r7
80009592:	cf 7b       	rjmp	80009580 <vTaskDelayUntil+0x50>
80009594:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009598:	80 00       	ld.sh	r0,r0[0x0]
8000959a:	90 30       	ld.sh	r0,r8[0x6]
8000959c:	00 00       	add	r0,r0
8000959e:	12 48       	or	r8,r9
800095a0:	00 00       	add	r0,r0
800095a2:	12 1c       	sub	r12,r9
800095a4:	80 00       	ld.sh	r0,r0[0x0]
800095a6:	87 ea       	st.w	r3[0x38],r10
800095a8:	80 00       	ld.sh	r0,r0[0x0]
800095aa:	94 d4       	ld.uh	r4,r10[0xa]
800095ac:	80 00       	ld.sh	r0,r0[0x0]
800095ae:	93 ec       	st.w	r9[0x38],r12

800095b0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800095b0:	eb cd 40 c0 	pushm	r6-r7,lr
800095b4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800095b6:	48 e7       	lddpc	r7,800095ec <vTaskPlaceOnEventList+0x3c>
800095b8:	6e 0b       	ld.w	r11,r7[0x0]
800095ba:	2e 8b       	sub	r11,-24
800095bc:	f0 1f 00 0d 	mcall	800095f0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800095c0:	6e 0c       	ld.w	r12,r7[0x0]
800095c2:	2f cc       	sub	r12,-4
800095c4:	f0 1f 00 0c 	mcall	800095f4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800095c8:	5b f6       	cp.w	r6,-1
800095ca:	c0 81       	brne	800095da <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800095cc:	6e 0b       	ld.w	r11,r7[0x0]
800095ce:	2f cb       	sub	r11,-4
800095d0:	48 ac       	lddpc	r12,800095f8 <vTaskPlaceOnEventList+0x48>
800095d2:	f0 1f 00 0b 	mcall	800095fc <vTaskPlaceOnEventList+0x4c>
800095d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800095da:	48 a8       	lddpc	r8,80009600 <vTaskPlaceOnEventList+0x50>
800095dc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800095de:	ec 0c 00 0c 	add	r12,r6,r12
800095e2:	f0 1f 00 09 	mcall	80009604 <vTaskPlaceOnEventList+0x54>
800095e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800095ea:	00 00       	add	r0,r0
800095ec:	00 00       	add	r0,r0
800095ee:	12 1c       	sub	r12,r9
800095f0:	80 00       	ld.sh	r0,r0[0x0]
800095f2:	87 b6       	st.w	r3[0x2c],r6
800095f4:	80 00       	ld.sh	r0,r0[0x0]
800095f6:	87 ea       	st.w	r3[0x38],r10
800095f8:	00 00       	add	r0,r0
800095fa:	12 70       	tst	r0,r9
800095fc:	80 00       	ld.sh	r0,r0[0x0]
800095fe:	87 9a       	st.w	r3[0x24],r10
80009600:	00 00       	add	r0,r0
80009602:	12 48       	or	r8,r9
80009604:	80 00       	ld.sh	r0,r0[0x0]
80009606:	94 d4       	ld.uh	r4,r10[0xa]

80009608 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009608:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000960c:	49 67       	lddpc	r7,80009664 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000960e:	49 74       	lddpc	r4,80009668 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009610:	49 73       	lddpc	r3,8000966c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009612:	49 85       	lddpc	r5,80009670 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009614:	6e 08       	ld.w	r8,r7[0x0]
80009616:	58 08       	cp.w	r8,0
80009618:	c1 e0       	breq	80009654 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000961a:	f0 1f 00 17 	mcall	80009674 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000961e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009620:	f0 1f 00 16 	mcall	80009678 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009624:	58 06       	cp.w	r6,0
80009626:	c1 70       	breq	80009654 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009628:	f0 1f 00 15 	mcall	8000967c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000962c:	68 38       	ld.w	r8,r4[0xc]
8000962e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009630:	ec cc ff fc 	sub	r12,r6,-4
80009634:	f0 1f 00 13 	mcall	80009680 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009638:	66 08       	ld.w	r8,r3[0x0]
8000963a:	20 18       	sub	r8,1
8000963c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000963e:	6e 08       	ld.w	r8,r7[0x0]
80009640:	20 18       	sub	r8,1
80009642:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009644:	f0 1f 00 10 	mcall	80009684 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009648:	6c cc       	ld.w	r12,r6[0x30]
8000964a:	f0 1f 00 10 	mcall	80009688 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000964e:	0c 9c       	mov	r12,r6
80009650:	f0 1f 00 0e 	mcall	80009688 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009654:	6a 08       	ld.w	r8,r5[0x0]
80009656:	58 18       	cp.w	r8,1
80009658:	e0 88 00 03 	brls	8000965e <prvIdleTask+0x56>
			{
				taskYIELD();
8000965c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000965e:	f0 1f 00 0c 	mcall	8000968c <prvIdleTask+0x84>
		}
		#endif
	}
80009662:	cd 9b       	rjmp	80009614 <prvIdleTask+0xc>
80009664:	00 00       	add	r0,r0
80009666:	11 5c       	ld.sh	r12,--r8
80009668:	00 00       	add	r0,r0
8000966a:	12 08       	add	r8,r9
8000966c:	00 00       	add	r0,r0
8000966e:	12 68       	and	r8,r9
80009670:	00 00       	add	r0,r0
80009672:	11 68       	ld.uh	r8,--r8
80009674:	80 00       	ld.sh	r0,r0[0x0]
80009676:	90 30       	ld.sh	r0,r8[0x6]
80009678:	80 00       	ld.sh	r0,r0[0x0]
8000967a:	93 ec       	st.w	r9[0x38],r12
8000967c:	80 00       	ld.sh	r0,r0[0x0]
8000967e:	88 a4       	ld.uh	r4,r4[0x4]
80009680:	80 00       	ld.sh	r0,r0[0x0]
80009682:	87 ea       	st.w	r3[0x38],r10
80009684:	80 00       	ld.sh	r0,r0[0x0]
80009686:	89 b0       	st.w	r4[0x2c],r0
80009688:	80 00       	ld.sh	r0,r0[0x0]
8000968a:	8a e8       	ld.uh	r8,r5[0xc]
8000968c:	80 00       	ld.sh	r0,r0[0x0]
8000968e:	20 34       	sub	r4,3

80009690 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80009690:	d4 31       	pushm	r0-r7,lr
80009692:	20 1d       	sub	sp,4
80009694:	fa c4 ff d8 	sub	r4,sp,-40
80009698:	50 0c       	stdsp	sp[0x0],r12
8000969a:	16 91       	mov	r1,r11
8000969c:	14 97       	mov	r7,r10
8000969e:	12 90       	mov	r0,r9
800096a0:	10 93       	mov	r3,r8
800096a2:	68 02       	ld.w	r2,r4[0x0]
800096a4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800096a6:	34 8c       	mov	r12,72
800096a8:	f0 1f 00 5c 	mcall	80009818 <xTaskGenericCreate+0x188>
800096ac:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800096ae:	c0 31       	brne	800096b4 <xTaskGenericCreate+0x24>
800096b0:	3f fc       	mov	r12,-1
800096b2:	ca f8       	rjmp	80009810 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800096b4:	58 06       	cp.w	r6,0
800096b6:	e0 81 00 af 	brne	80009814 <xTaskGenericCreate+0x184>
800096ba:	0e 9c       	mov	r12,r7
800096bc:	5c 7c       	castu.h	r12
800096be:	a3 6c       	lsl	r12,0x2
800096c0:	f0 1f 00 56 	mcall	80009818 <xTaskGenericCreate+0x188>
800096c4:	18 96       	mov	r6,r12
800096c6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800096c8:	c0 61       	brne	800096d4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800096ca:	0a 9c       	mov	r12,r5
800096cc:	f0 1f 00 54 	mcall	8000981c <xTaskGenericCreate+0x18c>
800096d0:	3f fc       	mov	r12,-1
800096d2:	c9 f8       	rjmp	80009810 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800096d4:	5c 77       	castu.h	r7
800096d6:	ee 0a 15 02 	lsl	r10,r7,0x2
800096da:	e0 6b 00 a5 	mov	r11,165
800096de:	0c 9c       	mov	r12,r6
800096e0:	f0 1f 00 50 	mcall	80009820 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800096e4:	ee c6 00 01 	sub	r6,r7,1
800096e8:	6a c8       	ld.w	r8,r5[0x30]
800096ea:	f0 06 00 26 	add	r6,r8,r6<<0x2
800096ee:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800096f2:	31 0a       	mov	r10,16
800096f4:	02 9b       	mov	r11,r1
800096f6:	ea cc ff cc 	sub	r12,r5,-52
800096fa:	f0 1f 00 4b 	mcall	80009824 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800096fe:	30 08       	mov	r8,0
80009700:	eb 68 00 43 	st.b	r5[67],r8
80009704:	58 73       	cp.w	r3,7
80009706:	e6 07 17 80 	movls	r7,r3
8000970a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000970e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009710:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009714:	ea c4 ff fc 	sub	r4,r5,-4
80009718:	08 9c       	mov	r12,r4
8000971a:	f0 1f 00 44 	mcall	80009828 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000971e:	ea cc ff e8 	sub	r12,r5,-24
80009722:	f0 1f 00 42 	mcall	80009828 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009726:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009728:	ee 07 11 08 	rsub	r7,r7,8
8000972c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000972e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009730:	00 9a       	mov	r10,r0
80009732:	40 0b       	lddsp	r11,sp[0x0]
80009734:	0c 9c       	mov	r12,r6
80009736:	f0 1f 00 3e 	mcall	8000982c <xTaskGenericCreate+0x19c>
8000973a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000973c:	58 02       	cp.w	r2,0
8000973e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80009742:	f0 1f 00 3c 	mcall	80009830 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80009746:	4b c8       	lddpc	r8,80009834 <xTaskGenericCreate+0x1a4>
80009748:	70 09       	ld.w	r9,r8[0x0]
8000974a:	2f f9       	sub	r9,-1
8000974c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000974e:	4b b8       	lddpc	r8,80009838 <xTaskGenericCreate+0x1a8>
80009750:	70 08       	ld.w	r8,r8[0x0]
80009752:	58 08       	cp.w	r8,0
80009754:	c2 61       	brne	800097a0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009756:	4b 98       	lddpc	r8,80009838 <xTaskGenericCreate+0x1a8>
80009758:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000975a:	4b 78       	lddpc	r8,80009834 <xTaskGenericCreate+0x1a4>
8000975c:	70 08       	ld.w	r8,r8[0x0]
8000975e:	58 18       	cp.w	r8,1
80009760:	c2 b1       	brne	800097b6 <xTaskGenericCreate+0x126>
80009762:	4b 77       	lddpc	r7,8000983c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80009764:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009768:	0e 9c       	mov	r12,r7
8000976a:	f0 1f 00 36 	mcall	80009840 <xTaskGenericCreate+0x1b0>
8000976e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009770:	0c 37       	cp.w	r7,r6
80009772:	cf b1       	brne	80009768 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80009774:	4b 47       	lddpc	r7,80009844 <xTaskGenericCreate+0x1b4>
80009776:	0e 9c       	mov	r12,r7
80009778:	f0 1f 00 32 	mcall	80009840 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000977c:	4b 36       	lddpc	r6,80009848 <xTaskGenericCreate+0x1b8>
8000977e:	0c 9c       	mov	r12,r6
80009780:	f0 1f 00 30 	mcall	80009840 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80009784:	4b 2c       	lddpc	r12,8000984c <xTaskGenericCreate+0x1bc>
80009786:	f0 1f 00 2f 	mcall	80009840 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000978a:	4b 2c       	lddpc	r12,80009850 <xTaskGenericCreate+0x1c0>
8000978c:	f0 1f 00 2d 	mcall	80009840 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80009790:	4b 1c       	lddpc	r12,80009854 <xTaskGenericCreate+0x1c4>
80009792:	f0 1f 00 2c 	mcall	80009840 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80009796:	4b 18       	lddpc	r8,80009858 <xTaskGenericCreate+0x1c8>
80009798:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000979a:	4b 18       	lddpc	r8,8000985c <xTaskGenericCreate+0x1cc>
8000979c:	91 06       	st.w	r8[0x0],r6
8000979e:	c0 c8       	rjmp	800097b6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800097a0:	4b 08       	lddpc	r8,80009860 <xTaskGenericCreate+0x1d0>
800097a2:	70 08       	ld.w	r8,r8[0x0]
800097a4:	58 08       	cp.w	r8,0
800097a6:	c0 81       	brne	800097b6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800097a8:	4a 48       	lddpc	r8,80009838 <xTaskGenericCreate+0x1a8>
800097aa:	70 08       	ld.w	r8,r8[0x0]
800097ac:	70 b8       	ld.w	r8,r8[0x2c]
800097ae:	10 33       	cp.w	r3,r8
800097b0:	c0 33       	brcs	800097b6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800097b2:	4a 28       	lddpc	r8,80009838 <xTaskGenericCreate+0x1a8>
800097b4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800097b6:	6a b8       	ld.w	r8,r5[0x2c]
800097b8:	4a b9       	lddpc	r9,80009864 <xTaskGenericCreate+0x1d4>
800097ba:	72 09       	ld.w	r9,r9[0x0]
800097bc:	12 38       	cp.w	r8,r9
800097be:	e0 88 00 04 	brls	800097c6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800097c2:	4a 99       	lddpc	r9,80009864 <xTaskGenericCreate+0x1d4>
800097c4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800097c6:	4a 98       	lddpc	r8,80009868 <xTaskGenericCreate+0x1d8>
800097c8:	70 09       	ld.w	r9,r8[0x0]
800097ca:	2f f9       	sub	r9,-1
800097cc:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800097ce:	6a b8       	ld.w	r8,r5[0x2c]
800097d0:	4a 79       	lddpc	r9,8000986c <xTaskGenericCreate+0x1dc>
800097d2:	72 09       	ld.w	r9,r9[0x0]
800097d4:	12 38       	cp.w	r8,r9
800097d6:	e0 88 00 04 	brls	800097de <xTaskGenericCreate+0x14e>
800097da:	4a 59       	lddpc	r9,8000986c <xTaskGenericCreate+0x1dc>
800097dc:	93 08       	st.w	r9[0x0],r8
800097de:	6a bc       	ld.w	r12,r5[0x2c]
800097e0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800097e4:	08 9b       	mov	r11,r4
800097e6:	49 68       	lddpc	r8,8000983c <xTaskGenericCreate+0x1ac>
800097e8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800097ec:	f0 1f 00 21 	mcall	80009870 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800097f0:	f0 1f 00 21 	mcall	80009874 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800097f4:	49 b8       	lddpc	r8,80009860 <xTaskGenericCreate+0x1d0>
800097f6:	70 08       	ld.w	r8,r8[0x0]
800097f8:	58 08       	cp.w	r8,0
800097fa:	c0 a0       	breq	8000980e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800097fc:	48 f8       	lddpc	r8,80009838 <xTaskGenericCreate+0x1a8>
800097fe:	70 08       	ld.w	r8,r8[0x0]
80009800:	70 b8       	ld.w	r8,r8[0x2c]
80009802:	10 33       	cp.w	r3,r8
80009804:	e0 88 00 05 	brls	8000980e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009808:	d7 33       	scall
8000980a:	30 1c       	mov	r12,1
8000980c:	c0 28       	rjmp	80009810 <xTaskGenericCreate+0x180>
8000980e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80009810:	2f fd       	sub	sp,-4
80009812:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009814:	99 c6       	st.w	r12[0x30],r6
80009816:	c5 fb       	rjmp	800096d4 <xTaskGenericCreate+0x44>
80009818:	80 00       	ld.sh	r0,r0[0x0]
8000981a:	8b 10       	st.w	r5[0x4],r0
8000981c:	80 00       	ld.sh	r0,r0[0x0]
8000981e:	8a e8       	ld.uh	r8,r5[0xc]
80009820:	80 00       	ld.sh	r0,r0[0x0]
80009822:	a5 62       	lsl	r2,0x4
80009824:	80 00       	ld.sh	r0,r0[0x0]
80009826:	a8 b4       	st.b	r4[0x3],r4
80009828:	80 00       	ld.sh	r0,r0[0x0]
8000982a:	87 94       	st.w	r3[0x24],r4
8000982c:	80 00       	ld.sh	r0,r0[0x0]
8000982e:	88 10       	ld.sh	r0,r4[0x2]
80009830:	80 00       	ld.sh	r0,r0[0x0]
80009832:	88 a4       	ld.uh	r4,r4[0x4]
80009834:	00 00       	add	r0,r0
80009836:	12 68       	and	r8,r9
80009838:	00 00       	add	r0,r0
8000983a:	12 1c       	sub	r12,r9
8000983c:	00 00       	add	r0,r0
8000983e:	11 68       	ld.uh	r8,--r8
80009840:	80 00       	ld.sh	r0,r0[0x0]
80009842:	87 80       	st.w	r3[0x20],r0
80009844:	00 00       	add	r0,r0
80009846:	12 34       	cp.w	r4,r9
80009848:	00 00       	add	r0,r0
8000984a:	12 50       	eor	r0,r9
8000984c:	00 00       	add	r0,r0
8000984e:	12 20       	rsub	r0,r9
80009850:	00 00       	add	r0,r0
80009852:	12 08       	add	r8,r9
80009854:	00 00       	add	r0,r0
80009856:	12 70       	tst	r0,r9
80009858:	00 00       	add	r0,r0
8000985a:	11 54       	ld.sh	r4,--r8
8000985c:	00 00       	add	r0,r0
8000985e:	11 64       	ld.uh	r4,--r8
80009860:	00 00       	add	r0,r0
80009862:	11 58       	ld.sh	r8,--r8
80009864:	00 00       	add	r0,r0
80009866:	11 50       	ld.sh	r0,--r8
80009868:	00 00       	add	r0,r0
8000986a:	12 64       	and	r4,r9
8000986c:	00 00       	add	r0,r0
8000986e:	12 84       	andn	r4,r9
80009870:	80 00       	ld.sh	r0,r0[0x0]
80009872:	87 9a       	st.w	r3[0x24],r10
80009874:	80 00       	ld.sh	r0,r0[0x0]
80009876:	89 b0       	st.w	r4[0x2c],r0

80009878 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009878:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000987a:	30 09       	mov	r9,0
8000987c:	1a d9       	st.w	--sp,r9
8000987e:	1a d9       	st.w	--sp,r9
80009880:	1a d9       	st.w	--sp,r9
80009882:	12 98       	mov	r8,r9
80009884:	e0 6a 01 00 	mov	r10,256
80009888:	48 9b       	lddpc	r11,800098ac <vTaskStartScheduler+0x34>
8000988a:	48 ac       	lddpc	r12,800098b0 <vTaskStartScheduler+0x38>
8000988c:	f0 1f 00 0a 	mcall	800098b4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009890:	2f dd       	sub	sp,-12
80009892:	58 1c       	cp.w	r12,1
80009894:	c0 a1       	brne	800098a8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009896:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80009898:	30 19       	mov	r9,1
8000989a:	48 88       	lddpc	r8,800098b8 <vTaskStartScheduler+0x40>
8000989c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000989e:	30 09       	mov	r9,0
800098a0:	48 78       	lddpc	r8,800098bc <vTaskStartScheduler+0x44>
800098a2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800098a4:	f0 1f 00 07 	mcall	800098c0 <vTaskStartScheduler+0x48>
800098a8:	d8 02       	popm	pc
800098aa:	00 00       	add	r0,r0
800098ac:	80 01       	ld.sh	r1,r0[0x0]
800098ae:	89 d8       	st.w	r4[0x34],r8
800098b0:	80 00       	ld.sh	r0,r0[0x0]
800098b2:	96 08       	ld.sh	r8,r11[0x0]
800098b4:	80 00       	ld.sh	r0,r0[0x0]
800098b6:	96 90       	ld.uh	r0,r11[0x2]
800098b8:	00 00       	add	r0,r0
800098ba:	11 58       	ld.sh	r8,--r8
800098bc:	00 00       	add	r0,r0
800098be:	12 48       	or	r8,r9
800098c0:	80 00       	ld.sh	r0,r0[0x0]
800098c2:	88 b4       	ld.uh	r4,r4[0x6]

800098c4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800098c4:	16 cc       	st.b	r11++,r12
	return str;
}
800098c6:	5e fb       	retal	r11

800098c8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800098c8:	eb cd 40 c0 	pushm	r6-r7,lr
800098cc:	20 3d       	sub	sp,12
800098ce:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800098d0:	30 06       	mov	r6,0
800098d2:	30 07       	mov	r7,0
800098d4:	fa e7 00 00 	st.d	sp[0],r6
800098d8:	30 0c       	mov	r12,0
800098da:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800098dc:	58 08       	cp.w	r8,0
800098de:	c1 30       	breq	80009904 <PrintHex+0x3c>
800098e0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800098e2:	1a 9c       	mov	r12,sp
800098e4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800098e8:	58 9e       	cp.w	lr,9
800098ea:	e0 8a 00 04 	brle	800098f2 <PrintHex+0x2a>
800098ee:	2c 9e       	sub	lr,-55
800098f0:	c0 48       	rjmp	800098f8 <PrintHex+0x30>
800098f2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800098f6:	2d 0e       	sub	lr,-48
800098f8:	f8 09 0b 0e 	st.b	r12[r9],lr
800098fc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800098fe:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009900:	cf 21       	brne	800098e4 <PrintHex+0x1c>
80009902:	c0 48       	rjmp	8000990a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009904:	33 08       	mov	r8,48
80009906:	ba 88       	st.b	sp[0x0],r8
80009908:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000990a:	f6 09 01 08 	sub	r8,r11,r9
8000990e:	58 08       	cp.w	r8,0
80009910:	e0 8a 00 13 	brle	80009936 <PrintHex+0x6e>
	{
		char num = len - cnt;
80009914:	12 1b       	sub	r11,r9
80009916:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000991a:	18 9e       	mov	lr,r12
8000991c:	58 0c       	cp.w	r12,0
8000991e:	e0 8a 00 0c 	brle	80009936 <PrintHex+0x6e>
80009922:	1a 9b       	mov	r11,sp
80009924:	12 0b       	add	r11,r9
80009926:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009928:	33 07       	mov	r7,48
8000992a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000992c:	2f f8       	sub	r8,-1
8000992e:	1c 38       	cp.w	r8,lr
80009930:	cf d5       	brlt	8000992a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009932:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009936:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000993a:	f0 cb ff ff 	sub	r11,r8,-1
8000993e:	58 0b       	cp.w	r11,0
80009940:	e0 8a 00 19 	brle	80009972 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009944:	fa cb ff f4 	sub	r11,sp,-12
80009948:	f6 09 00 09 	add	r9,r11,r9
8000994c:	37 8b       	mov	r11,120
8000994e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80009952:	fa c9 ff f4 	sub	r9,sp,-12
80009956:	10 09       	add	r9,r8
80009958:	33 0b       	mov	r11,48
8000995a:	f3 6b ff f4 	st.b	r9[-12],r11
8000995e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009962:	fa ce 00 01 	sub	lr,sp,1
80009966:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80009968:	11 8b       	ld.ub	r11,r8[0x0]
8000996a:	12 cb       	st.b	r9++,r11
8000996c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000996e:	1c 38       	cp.w	r8,lr
80009970:	cf c1       	brne	80009968 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80009972:	14 9c       	mov	r12,r10
80009974:	2f dd       	sub	sp,-12
80009976:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000997a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000997a:	d4 21       	pushm	r4-r7,lr
8000997c:	20 3d       	sub	sp,12
8000997e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80009980:	30 06       	mov	r6,0
80009982:	30 07       	mov	r7,0
80009984:	fa e7 00 00 	st.d	sp[0],r6
80009988:	30 0c       	mov	r12,0
8000998a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000998c:	58 08       	cp.w	r8,0
8000998e:	c0 35       	brlt	80009994 <PrintDec+0x1a>
80009990:	14 97       	mov	r7,r10
80009992:	c0 58       	rjmp	8000999c <PrintDec+0x22>
	{
		*p++ = '-';
80009994:	14 97       	mov	r7,r10
80009996:	32 d9       	mov	r9,45
80009998:	0e c9       	st.b	r7++,r9
		i = -i;
8000999a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000999c:	58 08       	cp.w	r8,0
8000999e:	c0 51       	brne	800099a8 <PrintDec+0x2e>
800099a0:	33 08       	mov	r8,48
800099a2:	ba 88       	st.b	sp[0x0],r8
800099a4:	30 1e       	mov	lr,1
800099a6:	c2 f8       	rjmp	80009a04 <PrintDec+0x8a>
	
	int ten = i%10;
800099a8:	e0 65 66 67 	mov	r5,26215
800099ac:	ea 15 66 66 	orh	r5,0x6666
800099b0:	f0 05 04 44 	muls.d	r4,r8,r5
800099b4:	ea 0c 14 02 	asr	r12,r5,0x2
800099b8:	f0 09 14 1f 	asr	r9,r8,0x1f
800099bc:	f8 09 01 09 	sub	r9,r12,r9
800099c0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800099c4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800099c8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800099ca:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800099cc:	e0 66 66 67 	mov	r6,26215
800099d0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800099d4:	2d 09       	sub	r9,-48
800099d6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800099da:	2f fe       	sub	lr,-1
		i /= 10;
800099dc:	f0 06 04 44 	muls.d	r4,r8,r6
800099e0:	ea 09 14 02 	asr	r9,r5,0x2
800099e4:	bf 58       	asr	r8,0x1f
800099e6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800099ea:	f0 06 04 44 	muls.d	r4,r8,r6
800099ee:	ea 09 14 02 	asr	r9,r5,0x2
800099f2:	f0 05 14 1f 	asr	r5,r8,0x1f
800099f6:	0a 19       	sub	r9,r5
800099f8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800099fc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009a00:	58 08       	cp.w	r8,0
80009a02:	ce 91       	brne	800099d4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009a04:	f6 0e 01 08 	sub	r8,r11,lr
80009a08:	58 08       	cp.w	r8,0
80009a0a:	e0 89 00 06 	brgt	80009a16 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009a0e:	58 0e       	cp.w	lr,0
80009a10:	e0 89 00 14 	brgt	80009a38 <PrintDec+0xbe>
80009a14:	c1 d8       	rjmp	80009a4e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009a16:	1c 1b       	sub	r11,lr
80009a18:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80009a1a:	16 9c       	mov	r12,r11
80009a1c:	58 0b       	cp.w	r11,0
80009a1e:	fe 9a ff f8 	brle	80009a0e <PrintDec+0x94>
80009a22:	1a 99       	mov	r9,sp
80009a24:	1c 09       	add	r9,lr
80009a26:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009a28:	33 06       	mov	r6,48
80009a2a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009a2c:	2f f8       	sub	r8,-1
80009a2e:	18 38       	cp.w	r8,r12
80009a30:	cf d5       	brlt	80009a2a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009a32:	f6 0e 00 0e 	add	lr,r11,lr
80009a36:	ce cb       	rjmp	80009a0e <PrintDec+0x94>
80009a38:	fa c8 ff f4 	sub	r8,sp,-12
80009a3c:	1c 08       	add	r8,lr
80009a3e:	20 d8       	sub	r8,13
80009a40:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009a44:	11 89       	ld.ub	r9,r8[0x0]
80009a46:	0e c9       	st.b	r7++,r9
80009a48:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009a4a:	16 38       	cp.w	r8,r11
80009a4c:	cf c1       	brne	80009a44 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80009a4e:	14 9c       	mov	r12,r10
80009a50:	2f dd       	sub	sp,-12
80009a52:	d8 22       	popm	r4-r7,pc

80009a54 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009a54:	d4 31       	pushm	r0-r7,lr
80009a56:	fa cd 02 08 	sub	sp,sp,520
80009a5a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009a5c:	e0 6a 01 00 	mov	r10,256
80009a60:	30 0b       	mov	r11,0
80009a62:	fa cc fe f8 	sub	r12,sp,-264
80009a66:	f0 1f 00 4e 	mcall	80009b9c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80009a6a:	fa c4 fd d4 	sub	r4,sp,-556
80009a6e:	30 0a       	mov	r10,0
80009a70:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009a72:	fa c3 ff fc 	sub	r3,sp,-4
80009a76:	e0 61 01 00 	mov	r1,256
80009a7a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80009a7c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009a7e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009a82:	02 9a       	mov	r10,r1
80009a84:	00 9b       	mov	r11,r0
80009a86:	06 9c       	mov	r12,r3
80009a88:	f0 1f 00 45 	mcall	80009b9c <log+0x148>
			
					if(*str == '%')
80009a8c:	0f 88       	ld.ub	r8,r7[0x0]
80009a8e:	e4 08 18 00 	cp.b	r8,r2
80009a92:	c5 71       	brne	80009b40 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80009a94:	ee c8 ff ff 	sub	r8,r7,-1
80009a98:	11 89       	ld.ub	r9,r8[0x0]
80009a9a:	4c 2a       	lddpc	r10,80009ba0 <log+0x14c>
80009a9c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80009a9e:	23 09       	sub	r9,48
80009aa0:	30 9a       	mov	r10,9
80009aa2:	f4 09 18 00 	cp.b	r9,r10
80009aa6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80009aaa:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009aae:	f7 b9 08 30 	subls	r9,48
80009ab2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80009ab6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80009aba:	0f 88       	ld.ub	r8,r7[0x0]
80009abc:	22 58       	sub	r8,37
80009abe:	e0 48 00 53 	cp.w	r8,83
80009ac2:	e0 8b 00 31 	brhi	80009b24 <log+0xd0>
80009ac6:	4b 89       	lddpc	r9,80009ba4 <log+0x150>
80009ac8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80009acc:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80009ad0:	06 9a       	mov	r10,r3
80009ad2:	40 0b       	lddsp	r11,sp[0x0]
80009ad4:	5c 5b       	castu.b	r11
80009ad6:	68 0c       	ld.w	r12,r4[0x0]
80009ad8:	f0 1f 00 34 	mcall	80009ba8 <log+0x154>
							break;
80009adc:	c2 98       	rjmp	80009b2e <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80009ade:	4b 4c       	lddpc	r12,80009bac <log+0x158>
80009ae0:	f0 1f 00 34 	mcall	80009bb0 <log+0x15c>
80009ae4:	08 95       	mov	r5,r4
80009ae6:	06 9c       	mov	r12,r3
							break;
80009ae8:	c2 38       	rjmp	80009b2e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80009aea:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80009aee:	06 9a       	mov	r10,r3
80009af0:	40 0b       	lddsp	r11,sp[0x0]
80009af2:	5c 5b       	castu.b	r11
80009af4:	68 0c       	ld.w	r12,r4[0x0]
80009af6:	f0 1f 00 30 	mcall	80009bb4 <log+0x160>
80009afa:	06 9c       	mov	r12,r3
							break;
80009afc:	c1 98       	rjmp	80009b2e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80009afe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80009b02:	06 9b       	mov	r11,r3
80009b04:	09 bc       	ld.ub	r12,r4[0x3]
80009b06:	f0 1f 00 2d 	mcall	80009bb8 <log+0x164>
80009b0a:	06 9c       	mov	r12,r3
							break;
80009b0c:	c1 18       	rjmp	80009b2e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80009b0e:	e8 c5 ff fc 	sub	r5,r4,-4
80009b12:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80009b14:	c0 d8       	rjmp	80009b2e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80009b16:	06 9b       	mov	r11,r3
80009b18:	32 5c       	mov	r12,37
80009b1a:	f0 1f 00 28 	mcall	80009bb8 <log+0x164>
80009b1e:	08 95       	mov	r5,r4
80009b20:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80009b22:	c0 68       	rjmp	80009b2e <log+0xda>
							
							default:
							log("I need relax.");
80009b24:	4a 6c       	lddpc	r12,80009bbc <log+0x168>
80009b26:	f0 1f 00 23 	mcall	80009bb0 <log+0x15c>
80009b2a:	08 95       	mov	r5,r4
80009b2c:	06 9c       	mov	r12,r3
						}
						str++;
80009b2e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009b30:	1a dc       	st.w	--sp,r12
80009b32:	1a d6       	st.w	--sp,r6
80009b34:	4a 3b       	lddpc	r11,80009bc0 <log+0x16c>
80009b36:	0c 9c       	mov	r12,r6
80009b38:	f0 1f 00 23 	mcall	80009bc4 <log+0x170>
80009b3c:	2f ed       	sub	sp,-8
80009b3e:	c0 a8       	rjmp	80009b52 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009b40:	2f f7       	sub	r7,-1
80009b42:	1a d8       	st.w	--sp,r8
80009b44:	1a d6       	st.w	--sp,r6
80009b46:	4a 1b       	lddpc	r11,80009bc8 <log+0x174>
80009b48:	0c 9c       	mov	r12,r6
80009b4a:	f0 1f 00 1f 	mcall	80009bc4 <log+0x170>
80009b4e:	08 95       	mov	r5,r4
80009b50:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80009b52:	0f 89       	ld.ub	r9,r7[0x0]
80009b54:	30 08       	mov	r8,0
80009b56:	f0 09 18 00 	cp.b	r9,r8
80009b5a:	c0 30       	breq	80009b60 <log+0x10c>
80009b5c:	0a 94       	mov	r4,r5
80009b5e:	c9 2b       	rjmp	80009a82 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80009b60:	fa c7 fe f8 	sub	r7,sp,-264
80009b64:	1a d7       	st.w	--sp,r7
80009b66:	49 ab       	lddpc	r11,80009bcc <log+0x178>
80009b68:	0e 9c       	mov	r12,r7
80009b6a:	f0 1f 00 17 	mcall	80009bc4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80009b6e:	5c 5c       	castu.b	r12
80009b70:	f8 c6 ff ff 	sub	r6,r12,-1
80009b74:	0c 9c       	mov	r12,r6
80009b76:	f0 1f 00 17 	mcall	80009bd0 <log+0x17c>
80009b7a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80009b7c:	0c 9a       	mov	r10,r6
80009b7e:	0e 9b       	mov	r11,r7
80009b80:	f0 1f 00 15 	mcall	80009bd4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80009b84:	30 09       	mov	r9,0
80009b86:	30 5a       	mov	r10,5
80009b88:	fa cb fe f8 	sub	r11,sp,-264
80009b8c:	49 38       	lddpc	r8,80009bd8 <log+0x184>
80009b8e:	70 0c       	ld.w	r12,r8[0x0]
80009b90:	f0 1f 00 13 	mcall	80009bdc <log+0x188>
80009b94:	2f fd       	sub	sp,-4
}
80009b96:	fe 3d fd f8 	sub	sp,-520
80009b9a:	d8 32       	popm	r0-r7,pc
80009b9c:	80 00       	ld.sh	r0,r0[0x0]
80009b9e:	a5 62       	lsl	r2,0x4
80009ba0:	00 00       	add	r0,r0
80009ba2:	12 88       	andn	r8,r9
80009ba4:	80 01       	ld.sh	r1,r0[0x0]
80009ba6:	89 e0       	st.w	r4[0x38],r0
80009ba8:	80 00       	ld.sh	r0,r0[0x0]
80009baa:	99 7a       	st.w	r12[0x1c],r10
80009bac:	80 01       	ld.sh	r1,r0[0x0]
80009bae:	8c 8c       	ld.uh	r12,r6[0x0]
80009bb0:	80 00       	ld.sh	r0,r0[0x0]
80009bb2:	9a 54       	ld.sh	r4,sp[0xa]
80009bb4:	80 00       	ld.sh	r0,r0[0x0]
80009bb6:	98 c8       	ld.uh	r8,r12[0x8]
80009bb8:	80 00       	ld.sh	r0,r0[0x0]
80009bba:	98 c4       	ld.uh	r4,r12[0x8]
80009bbc:	80 01       	ld.sh	r1,r0[0x0]
80009bbe:	8c 9c       	ld.uh	r12,r6[0x2]
80009bc0:	80 01       	ld.sh	r1,r0[0x0]
80009bc2:	8c ac       	ld.uh	r12,r6[0x4]
80009bc4:	80 00       	ld.sh	r0,r0[0x0]
80009bc6:	a8 50       	st.h	r4[0xa],r0
80009bc8:	80 01       	ld.sh	r1,r0[0x0]
80009bca:	8c b4       	ld.uh	r4,r6[0x6]
80009bcc:	80 01       	ld.sh	r1,r0[0x0]
80009bce:	8c bc       	ld.uh	r12,r6[0x6]
80009bd0:	80 00       	ld.sh	r0,r0[0x0]
80009bd2:	8b 10       	st.w	r5[0x4],r0
80009bd4:	80 00       	ld.sh	r0,r0[0x0]
80009bd6:	a4 1a       	st.h	r2[0x2],r10
80009bd8:	00 00       	add	r0,r0
80009bda:	46 1c       	lddsp	r12,sp[0x184]
80009bdc:	80 00       	ld.sh	r0,r0[0x0]
80009bde:	8e 64       	ld.sh	r4,r7[0xc]

80009be0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80009be0:	d4 31       	pushm	r0-r7,lr
80009be2:	fa cd 02 0c 	sub	sp,sp,524
80009be6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80009be8:	e0 6a 01 00 	mov	r10,256
80009bec:	30 0b       	mov	r11,0
80009bee:	fa cc fe f4 	sub	r12,sp,-268
80009bf2:	f0 1f 00 4c 	mcall	80009d20 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80009bf6:	fa c4 fd d0 	sub	r4,sp,-560
80009bfa:	30 0a       	mov	r10,0
80009bfc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009bfe:	fa c3 ff fc 	sub	r3,sp,-4
80009c02:	e0 61 01 00 	mov	r1,256
80009c06:	14 90       	mov	r0,r10
			
			if(*str == '%')
80009c08:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009c0a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009c0e:	02 9a       	mov	r10,r1
80009c10:	00 9b       	mov	r11,r0
80009c12:	06 9c       	mov	r12,r3
80009c14:	f0 1f 00 43 	mcall	80009d20 <logFromISR+0x140>
			
			if(*str == '%')
80009c18:	0f 88       	ld.ub	r8,r7[0x0]
80009c1a:	e4 08 18 00 	cp.b	r8,r2
80009c1e:	c5 11       	brne	80009cc0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80009c20:	ee c8 ff ff 	sub	r8,r7,-1
80009c24:	11 89       	ld.ub	r9,r8[0x0]
80009c26:	4c 0a       	lddpc	r10,80009d24 <logFromISR+0x144>
80009c28:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80009c2a:	23 09       	sub	r9,48
80009c2c:	30 9a       	mov	r10,9
80009c2e:	f4 09 18 00 	cp.b	r9,r10
80009c32:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80009c36:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009c3a:	f7 b9 08 30 	subls	r9,48
80009c3e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80009c42:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80009c46:	0f 88       	ld.ub	r8,r7[0x0]
80009c48:	22 58       	sub	r8,37
80009c4a:	e0 48 00 53 	cp.w	r8,83
80009c4e:	e0 8b 00 2b 	brhi	80009ca4 <logFromISR+0xc4>
80009c52:	4b 69       	lddpc	r9,80009d28 <logFromISR+0x148>
80009c54:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80009c58:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80009c5c:	06 9a       	mov	r10,r3
80009c5e:	40 0b       	lddsp	r11,sp[0x0]
80009c60:	5c 5b       	castu.b	r11
80009c62:	68 0c       	ld.w	r12,r4[0x0]
80009c64:	f0 1f 00 32 	mcall	80009d2c <logFromISR+0x14c>
					break;
80009c68:	c2 38       	rjmp	80009cae <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80009c6a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80009c6e:	06 9a       	mov	r10,r3
80009c70:	40 0b       	lddsp	r11,sp[0x0]
80009c72:	5c 5b       	castu.b	r11
80009c74:	68 0c       	ld.w	r12,r4[0x0]
80009c76:	f0 1f 00 2f 	mcall	80009d30 <logFromISR+0x150>
80009c7a:	06 9c       	mov	r12,r3
					break;
80009c7c:	c1 98       	rjmp	80009cae <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80009c7e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80009c82:	06 9b       	mov	r11,r3
80009c84:	09 bc       	ld.ub	r12,r4[0x3]
80009c86:	f0 1f 00 2c 	mcall	80009d34 <logFromISR+0x154>
80009c8a:	06 9c       	mov	r12,r3
					break;
80009c8c:	c1 18       	rjmp	80009cae <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80009c8e:	e8 c5 ff fc 	sub	r5,r4,-4
80009c92:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80009c94:	c0 d8       	rjmp	80009cae <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80009c96:	06 9b       	mov	r11,r3
80009c98:	32 5c       	mov	r12,37
80009c9a:	f0 1f 00 27 	mcall	80009d34 <logFromISR+0x154>
80009c9e:	08 95       	mov	r5,r4
80009ca0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80009ca2:	c0 68       	rjmp	80009cae <logFromISR+0xce>
					default:
					log("I need relax.");
80009ca4:	4a 5c       	lddpc	r12,80009d38 <logFromISR+0x158>
80009ca6:	f0 1f 00 26 	mcall	80009d3c <logFromISR+0x15c>
80009caa:	08 95       	mov	r5,r4
80009cac:	06 9c       	mov	r12,r3
				}
				str++;
80009cae:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009cb0:	1a dc       	st.w	--sp,r12
80009cb2:	1a d6       	st.w	--sp,r6
80009cb4:	4a 3b       	lddpc	r11,80009d40 <logFromISR+0x160>
80009cb6:	0c 9c       	mov	r12,r6
80009cb8:	f0 1f 00 23 	mcall	80009d44 <logFromISR+0x164>
80009cbc:	2f ed       	sub	sp,-8
80009cbe:	c0 a8       	rjmp	80009cd2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009cc0:	2f f7       	sub	r7,-1
80009cc2:	1a d8       	st.w	--sp,r8
80009cc4:	1a d6       	st.w	--sp,r6
80009cc6:	4a 1b       	lddpc	r11,80009d48 <logFromISR+0x168>
80009cc8:	0c 9c       	mov	r12,r6
80009cca:	f0 1f 00 1f 	mcall	80009d44 <logFromISR+0x164>
80009cce:	08 95       	mov	r5,r4
80009cd0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80009cd2:	0f 89       	ld.ub	r9,r7[0x0]
80009cd4:	30 08       	mov	r8,0
80009cd6:	f0 09 18 00 	cp.b	r9,r8
80009cda:	c0 30       	breq	80009ce0 <logFromISR+0x100>
80009cdc:	0a 94       	mov	r4,r5
80009cde:	c9 8b       	rjmp	80009c0e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80009ce0:	fa c7 fe f4 	sub	r7,sp,-268
80009ce4:	1a d7       	st.w	--sp,r7
80009ce6:	49 ab       	lddpc	r11,80009d4c <logFromISR+0x16c>
80009ce8:	0e 9c       	mov	r12,r7
80009cea:	f0 1f 00 17 	mcall	80009d44 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80009cee:	5c 5c       	castu.b	r12
80009cf0:	f8 c6 ff ff 	sub	r6,r12,-1
80009cf4:	0c 9c       	mov	r12,r6
80009cf6:	f0 1f 00 17 	mcall	80009d50 <logFromISR+0x170>
80009cfa:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80009cfc:	0c 9a       	mov	r10,r6
80009cfe:	0e 9b       	mov	r11,r7
80009d00:	f0 1f 00 15 	mcall	80009d54 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80009d04:	30 09       	mov	r9,0
80009d06:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80009d08:	fa ca fe f8 	sub	r10,sp,-264
80009d0c:	fa cb fe f4 	sub	r11,sp,-268
80009d10:	49 28       	lddpc	r8,80009d58 <logFromISR+0x178>
80009d12:	70 0c       	ld.w	r12,r8[0x0]
80009d14:	f0 1f 00 12 	mcall	80009d5c <logFromISR+0x17c>
80009d18:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80009d1a:	fe 3d fd f4 	sub	sp,-524
80009d1e:	d8 32       	popm	r0-r7,pc
80009d20:	80 00       	ld.sh	r0,r0[0x0]
80009d22:	a5 62       	lsl	r2,0x4
80009d24:	00 00       	add	r0,r0
80009d26:	12 89       	andn	r9,r9
80009d28:	80 01       	ld.sh	r1,r0[0x0]
80009d2a:	8b 30       	st.w	r5[0xc],r0
80009d2c:	80 00       	ld.sh	r0,r0[0x0]
80009d2e:	99 7a       	st.w	r12[0x1c],r10
80009d30:	80 00       	ld.sh	r0,r0[0x0]
80009d32:	98 c8       	ld.uh	r8,r12[0x8]
80009d34:	80 00       	ld.sh	r0,r0[0x0]
80009d36:	98 c4       	ld.uh	r4,r12[0x8]
80009d38:	80 01       	ld.sh	r1,r0[0x0]
80009d3a:	8c 9c       	ld.uh	r12,r6[0x2]
80009d3c:	80 00       	ld.sh	r0,r0[0x0]
80009d3e:	9a 54       	ld.sh	r4,sp[0xa]
80009d40:	80 01       	ld.sh	r1,r0[0x0]
80009d42:	8c ac       	ld.uh	r12,r6[0x4]
80009d44:	80 00       	ld.sh	r0,r0[0x0]
80009d46:	a8 50       	st.h	r4[0xa],r0
80009d48:	80 01       	ld.sh	r1,r0[0x0]
80009d4a:	8c b4       	ld.uh	r4,r6[0x6]
80009d4c:	80 01       	ld.sh	r1,r0[0x0]
80009d4e:	8c bc       	ld.uh	r12,r6[0x6]
80009d50:	80 00       	ld.sh	r0,r0[0x0]
80009d52:	8b 10       	st.w	r5[0x4],r0
80009d54:	80 00       	ld.sh	r0,r0[0x0]
80009d56:	a4 1a       	st.h	r2[0x2],r10
80009d58:	00 00       	add	r0,r0
80009d5a:	46 1c       	lddsp	r12,sp[0x184]
80009d5c:	80 00       	ld.sh	r0,r0[0x0]
80009d5e:	8e 14       	ld.sh	r4,r7[0x2]

80009d60 <log_init>:
		
	return str;
}

void log_init(void)
{
80009d60:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80009d62:	30 2b       	mov	r11,2
80009d64:	49 0c       	lddpc	r12,80009da4 <log_init+0x44>
80009d66:	f0 1f 00 11 	mcall	80009da8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80009d6a:	e0 6a 36 00 	mov	r10,13824
80009d6e:	ea 1a 01 6e 	orh	r10,0x16e
80009d72:	48 fb       	lddpc	r11,80009dac <log_init+0x4c>
80009d74:	fe 7c 18 00 	mov	r12,-59392
80009d78:	f0 1f 00 0e 	mcall	80009db0 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80009d7c:	30 4b       	mov	r11,4
80009d7e:	33 2c       	mov	r12,50
80009d80:	f0 1f 00 0d 	mcall	80009db4 <log_init+0x54>
80009d84:	48 d8       	lddpc	r8,80009db8 <log_init+0x58>
80009d86:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80009d88:	30 09       	mov	r9,0
80009d8a:	1a d9       	st.w	--sp,r9
80009d8c:	1a d9       	st.w	--sp,r9
80009d8e:	1a d9       	st.w	--sp,r9
80009d90:	30 28       	mov	r8,2
80009d92:	e0 6a 01 80 	mov	r10,384
80009d96:	48 ab       	lddpc	r11,80009dbc <log_init+0x5c>
80009d98:	48 ac       	lddpc	r12,80009dc0 <log_init+0x60>
80009d9a:	f0 1f 00 0b 	mcall	80009dc4 <log_init+0x64>
80009d9e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80009da0:	d8 02       	popm	pc
80009da2:	00 00       	add	r0,r0
80009da4:	80 01       	ld.sh	r1,r0[0x0]
80009da6:	8c c8       	ld.uh	r8,r6[0x8]
80009da8:	80 00       	ld.sh	r0,r0[0x0]
80009daa:	9e f4       	ld.uh	r4,pc[0xe]
80009dac:	80 01       	ld.sh	r1,r0[0x0]
80009dae:	8c 80       	ld.uh	r0,r6[0x0]
80009db0:	80 00       	ld.sh	r0,r0[0x0]
80009db2:	60 e4       	ld.w	r4,r0[0x38]
80009db4:	80 00       	ld.sh	r0,r0[0x0]
80009db6:	8f bc       	st.w	r7[0x2c],r12
80009db8:	00 00       	add	r0,r0
80009dba:	46 1c       	lddsp	r12,sp[0x184]
80009dbc:	80 01       	ld.sh	r1,r0[0x0]
80009dbe:	8c c4       	ld.uh	r4,r6[0x8]
80009dc0:	80 00       	ld.sh	r0,r0[0x0]
80009dc2:	9d c8       	st.w	lr[0x30],r8
80009dc4:	80 00       	ld.sh	r0,r0[0x0]
80009dc6:	96 90       	ld.uh	r0,r11[0x2]

80009dc8 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80009dc8:	eb cd 40 f8 	pushm	r3-r7,lr
80009dcc:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009dce:	48 c7       	lddpc	r7,80009dfc <task_log+0x34>
80009dd0:	30 05       	mov	r5,0
80009dd2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80009dd4:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009dd8:	0a 99       	mov	r9,r5
80009dda:	08 9a       	mov	r10,r4
80009ddc:	1a 9b       	mov	r11,sp
80009dde:	6e 0c       	ld.w	r12,r7[0x0]
80009de0:	f0 1f 00 08 	mcall	80009e00 <task_log+0x38>
80009de4:	58 1c       	cp.w	r12,1
80009de6:	cf 91       	brne	80009dd8 <task_log+0x10>
		{
			if( NULL != str)
80009de8:	40 0b       	lddsp	r11,sp[0x0]
80009dea:	58 0b       	cp.w	r11,0
80009dec:	cf 60       	breq	80009dd8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80009dee:	06 9c       	mov	r12,r3
80009df0:	f0 1f 00 05 	mcall	80009e04 <task_log+0x3c>
				vPortFree(str);
80009df4:	40 0c       	lddsp	r12,sp[0x0]
80009df6:	f0 1f 00 05 	mcall	80009e08 <task_log+0x40>
80009dfa:	ce fb       	rjmp	80009dd8 <task_log+0x10>
80009dfc:	00 00       	add	r0,r0
80009dfe:	46 1c       	lddsp	r12,sp[0x184]
80009e00:	80 00       	ld.sh	r0,r0[0x0]
80009e02:	8c 58       	ld.sh	r8,r6[0xa]
80009e04:	80 00       	ld.sh	r0,r0[0x0]
80009e06:	60 94       	ld.w	r4,r0[0x24]
80009e08:	80 00       	ld.sh	r0,r0[0x0]
80009e0a:	8a e8       	ld.uh	r8,r5[0xc]

80009e0c <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80009e0c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80009e0e:	fe 78 10 00 	mov	r8,-61440
80009e12:	30 19       	mov	r9,1
80009e14:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80009e18:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80009e1c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80009e20:	d3 03       	ssrf	0x10
	local_start_pll0();
80009e22:	f0 1f 00 14 	mcall	80009e70 <main+0x64>
		
	INTC_init_interrupts();
80009e26:	f0 1f 00 14 	mcall	80009e74 <main+0x68>
	
	log_init();		
80009e2a:	f0 1f 00 14 	mcall	80009e78 <main+0x6c>
	log("----start debug----");	
80009e2e:	49 4c       	lddpc	r12,80009e7c <main+0x70>
80009e30:	f0 1f 00 14 	mcall	80009e80 <main+0x74>
		
	rtc_init();
80009e34:	f0 1f 00 14 	mcall	80009e84 <main+0x78>
	
	fs_init();//65795
80009e38:	f0 1f 00 14 	mcall	80009e88 <main+0x7c>

	tc_init();	
80009e3c:	f0 1f 00 14 	mcall	80009e8c <main+0x80>
			
	xcmp_init();
80009e40:	f0 1f 00 14 	mcall	80009e90 <main+0x84>
	
	app_init();
80009e44:	f0 1f 00 14 	mcall	80009e94 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80009e48:	fe 79 10 00 	mov	r9,-61440
80009e4c:	f2 f8 01 60 	ld.w	r8,r9[352]
80009e50:	e2 18 00 02 	andl	r8,0x2,COH
80009e54:	cf c0       	breq	80009e4c <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80009e56:	fe 79 10 00 	mov	r9,-61440
80009e5a:	f2 f8 01 60 	ld.w	r8,r9[352]
80009e5e:	e2 18 00 02 	andl	r8,0x2,COH
80009e62:	cf c1       	brne	80009e5a <main+0x4e>
	local_start_timer();
80009e64:	f0 1f 00 0d 	mcall	80009e98 <main+0x8c>
	
	Enable_global_interrupt();
80009e68:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80009e6a:	f0 1f 00 0d 	mcall	80009e9c <main+0x90>
	return 0;
}
80009e6e:	d8 0a       	popm	pc,r12=0
80009e70:	80 00       	ld.sh	r0,r0[0x0]
80009e72:	56 5c       	stdsp	sp[0x194],r12
80009e74:	80 00       	ld.sh	r0,r0[0x0]
80009e76:	59 f4       	cp.w	r4,31
80009e78:	80 00       	ld.sh	r0,r0[0x0]
80009e7a:	9d 60       	st.w	lr[0x18],r0
80009e7c:	80 01       	ld.sh	r1,r0[0x0]
80009e7e:	8c d8       	ld.uh	r8,r6[0xa]
80009e80:	80 00       	ld.sh	r0,r0[0x0]
80009e82:	9a 54       	ld.sh	r4,sp[0xa]
80009e84:	80 00       	ld.sh	r0,r0[0x0]
80009e86:	58 28       	cp.w	r8,2
80009e88:	80 00       	ld.sh	r0,r0[0x0]
80009e8a:	39 0c       	mov	r12,-112
80009e8c:	80 00       	ld.sh	r0,r0[0x0]
80009e8e:	58 f0       	cp.w	r0,15
80009e90:	80 00       	ld.sh	r0,r0[0x0]
80009e92:	4f 60       	lddpc	r0,8000a068 <_malloc_r+0xac>
80009e94:	80 00       	ld.sh	r0,r0[0x0]
80009e96:	20 44       	sub	r4,4
80009e98:	80 00       	ld.sh	r0,r0[0x0]
80009e9a:	58 b4       	cp.w	r4,11
80009e9c:	80 00       	ld.sh	r0,r0[0x0]
80009e9e:	98 78       	ld.sh	r8,r12[0xe]

80009ea0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009ea0:	f8 08 16 05 	lsr	r8,r12,0x5
80009ea4:	a9 68       	lsl	r8,0x8
80009ea6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80009eaa:	58 1b       	cp.w	r11,1
80009eac:	c0 d0       	breq	80009ec6 <gpio_enable_module_pin+0x26>
80009eae:	c0 63       	brcs	80009eba <gpio_enable_module_pin+0x1a>
80009eb0:	58 2b       	cp.w	r11,2
80009eb2:	c1 00       	breq	80009ed2 <gpio_enable_module_pin+0x32>
80009eb4:	58 3b       	cp.w	r11,3
80009eb6:	c1 40       	breq	80009ede <gpio_enable_module_pin+0x3e>
80009eb8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009eba:	30 19       	mov	r9,1
80009ebc:	f2 0c 09 49 	lsl	r9,r9,r12
80009ec0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009ec2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009ec4:	c1 28       	rjmp	80009ee8 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009ec6:	30 19       	mov	r9,1
80009ec8:	f2 0c 09 49 	lsl	r9,r9,r12
80009ecc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009ece:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009ed0:	c0 c8       	rjmp	80009ee8 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009ed2:	30 19       	mov	r9,1
80009ed4:	f2 0c 09 49 	lsl	r9,r9,r12
80009ed8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009eda:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009edc:	c0 68       	rjmp	80009ee8 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009ede:	30 19       	mov	r9,1
80009ee0:	f2 0c 09 49 	lsl	r9,r9,r12
80009ee4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009ee6:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80009ee8:	30 19       	mov	r9,1
80009eea:	f2 0c 09 4c 	lsl	r12,r9,r12
80009eee:	91 2c       	st.w	r8[0x8],r12
80009ef0:	5e fd       	retal	0
80009ef2:	d7 03       	nop

80009ef4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80009ef4:	d4 21       	pushm	r4-r7,lr
80009ef6:	18 97       	mov	r7,r12
80009ef8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009efa:	58 0b       	cp.w	r11,0
80009efc:	c0 31       	brne	80009f02 <gpio_enable_module+0xe>
80009efe:	30 05       	mov	r5,0
80009f00:	c0 d8       	rjmp	80009f1a <gpio_enable_module+0x26>
80009f02:	30 06       	mov	r6,0
80009f04:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80009f06:	6e 1b       	ld.w	r11,r7[0x4]
80009f08:	6e 0c       	ld.w	r12,r7[0x0]
80009f0a:	f0 1f 00 06 	mcall	80009f20 <gpio_enable_module+0x2c>
80009f0e:	18 45       	or	r5,r12
		gpiomap++;
80009f10:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009f12:	2f f6       	sub	r6,-1
80009f14:	0c 34       	cp.w	r4,r6
80009f16:	fe 9b ff f8 	brhi	80009f06 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80009f1a:	0a 9c       	mov	r12,r5
80009f1c:	d8 22       	popm	r4-r7,pc
80009f1e:	00 00       	add	r0,r0
80009f20:	80 00       	ld.sh	r0,r0[0x0]
80009f22:	9e a0       	ld.uh	r0,pc[0x4]

80009f24 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009f24:	f8 08 16 05 	lsr	r8,r12,0x5
80009f28:	a9 68       	lsl	r8,0x8
80009f2a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80009f2e:	30 19       	mov	r9,1
80009f30:	f2 0c 09 4c 	lsl	r12,r9,r12
80009f34:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80009f38:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009f3c:	91 1c       	st.w	r8[0x4],r12
}
80009f3e:	5e fc       	retal	r12

80009f40 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009f40:	f8 08 16 05 	lsr	r8,r12,0x5
80009f44:	a9 68       	lsl	r8,0x8
80009f46:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80009f4a:	30 19       	mov	r9,1
80009f4c:	f2 0c 09 4c 	lsl	r12,r9,r12
80009f50:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80009f54:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009f58:	91 1c       	st.w	r8[0x4],r12
}
80009f5a:	5e fc       	retal	r12

80009f5c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80009f5c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80009f60:	fe c0 a5 60 	sub	r0,pc,-23200

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80009f64:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80009f68:	d5 53       	csrf	0x15
  cp      r0, r1
80009f6a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80009f6c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80009f70:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80009f72:	c0 62       	brcc	80009f7e <idata_load_loop_end>
  cp      r0, r1
80009f74:	48 92       	lddpc	r2,80009f98 <udata_clear_loop_end+0x4>

80009f76 <idata_load_loop>:
  brlo    idata_load_loop
80009f76:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80009f78:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80009f7a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80009f7c:	cf d3       	brcs	80009f76 <idata_load_loop>

80009f7e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80009f7e:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80009f82:	e0 61 46 28 	mov	r1,17960
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80009f86:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80009f88:	c0 62       	brcc	80009f94 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80009f8a:	30 02       	mov	r2,0
80009f8c:	30 03       	mov	r3,0

80009f8e <udata_clear_loop>:
80009f8e:	a1 22       	st.d	r0++,r2
80009f90:	02 30       	cp.w	r0,r1
80009f92:	cf e3       	brcs	80009f8e <udata_clear_loop>

80009f94 <udata_clear_loop_end>:
80009f94:	fe cf 01 88 	sub	pc,pc,392
80009f98:	80 01       	ld.sh	r1,r0[0x0]
80009f9a:	92 70       	ld.sh	r0,r9[0xe]

80009f9c <free>:
80009f9c:	d4 01       	pushm	lr
80009f9e:	e0 68 0a 38 	mov	r8,2616
80009fa2:	18 9b       	mov	r11,r12
80009fa4:	70 0c       	ld.w	r12,r8[0x0]
80009fa6:	e0 a0 1f 19 	rcall	8000ddd8 <_free_r>
80009faa:	d8 02       	popm	pc

80009fac <malloc>:
80009fac:	d4 01       	pushm	lr
80009fae:	e0 68 0a 38 	mov	r8,2616
80009fb2:	18 9b       	mov	r11,r12
80009fb4:	70 0c       	ld.w	r12,r8[0x0]
80009fb6:	c0 3c       	rcall	80009fbc <_malloc_r>
80009fb8:	d8 02       	popm	pc
80009fba:	d7 03       	nop

80009fbc <_malloc_r>:
80009fbc:	d4 31       	pushm	r0-r7,lr
80009fbe:	f6 c8 ff f5 	sub	r8,r11,-11
80009fc2:	18 95       	mov	r5,r12
80009fc4:	10 97       	mov	r7,r8
80009fc6:	e0 17 ff f8 	andl	r7,0xfff8
80009fca:	59 68       	cp.w	r8,22
80009fcc:	f9 b7 08 10 	movls	r7,16
80009fd0:	16 37       	cp.w	r7,r11
80009fd2:	5f 38       	srlo	r8
80009fd4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80009fd8:	c0 50       	breq	80009fe2 <_malloc_r+0x26>
80009fda:	30 c8       	mov	r8,12
80009fdc:	99 38       	st.w	r12[0xc],r8
80009fde:	e0 8f 01 fa 	bral	8000a3d2 <_malloc_r+0x416>
80009fe2:	fe b0 f5 39 	rcall	80008a54 <__malloc_lock>
80009fe6:	e0 47 01 f7 	cp.w	r7,503
80009fea:	e0 8b 00 1d 	brhi	8000a024 <_malloc_r+0x68>
80009fee:	ee 03 16 03 	lsr	r3,r7,0x3
80009ff2:	e0 68 05 38 	mov	r8,1336
80009ff6:	f0 03 00 38 	add	r8,r8,r3<<0x3
80009ffa:	70 36       	ld.w	r6,r8[0xc]
80009ffc:	10 36       	cp.w	r6,r8
80009ffe:	c0 61       	brne	8000a00a <_malloc_r+0x4e>
8000a000:	ec c8 ff f8 	sub	r8,r6,-8
8000a004:	70 36       	ld.w	r6,r8[0xc]
8000a006:	10 36       	cp.w	r6,r8
8000a008:	c0 c0       	breq	8000a020 <_malloc_r+0x64>
8000a00a:	6c 18       	ld.w	r8,r6[0x4]
8000a00c:	e0 18 ff fc 	andl	r8,0xfffc
8000a010:	6c 3a       	ld.w	r10,r6[0xc]
8000a012:	ec 08 00 09 	add	r9,r6,r8
8000a016:	0a 9c       	mov	r12,r5
8000a018:	6c 28       	ld.w	r8,r6[0x8]
8000a01a:	95 28       	st.w	r10[0x8],r8
8000a01c:	91 3a       	st.w	r8[0xc],r10
8000a01e:	c4 78       	rjmp	8000a0ac <_malloc_r+0xf0>
8000a020:	2f e3       	sub	r3,-2
8000a022:	c4 d8       	rjmp	8000a0bc <_malloc_r+0x100>
8000a024:	ee 03 16 09 	lsr	r3,r7,0x9
8000a028:	c0 41       	brne	8000a030 <_malloc_r+0x74>
8000a02a:	ee 03 16 03 	lsr	r3,r7,0x3
8000a02e:	c2 68       	rjmp	8000a07a <_malloc_r+0xbe>
8000a030:	58 43       	cp.w	r3,4
8000a032:	e0 8b 00 06 	brhi	8000a03e <_malloc_r+0x82>
8000a036:	ee 03 16 06 	lsr	r3,r7,0x6
8000a03a:	2c 83       	sub	r3,-56
8000a03c:	c1 f8       	rjmp	8000a07a <_malloc_r+0xbe>
8000a03e:	59 43       	cp.w	r3,20
8000a040:	e0 8b 00 04 	brhi	8000a048 <_malloc_r+0x8c>
8000a044:	2a 53       	sub	r3,-91
8000a046:	c1 a8       	rjmp	8000a07a <_malloc_r+0xbe>
8000a048:	e0 43 00 54 	cp.w	r3,84
8000a04c:	e0 8b 00 06 	brhi	8000a058 <_malloc_r+0x9c>
8000a050:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a054:	29 23       	sub	r3,-110
8000a056:	c1 28       	rjmp	8000a07a <_malloc_r+0xbe>
8000a058:	e0 43 01 54 	cp.w	r3,340
8000a05c:	e0 8b 00 06 	brhi	8000a068 <_malloc_r+0xac>
8000a060:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a064:	28 93       	sub	r3,-119
8000a066:	c0 a8       	rjmp	8000a07a <_malloc_r+0xbe>
8000a068:	e0 43 05 54 	cp.w	r3,1364
8000a06c:	e0 88 00 04 	brls	8000a074 <_malloc_r+0xb8>
8000a070:	37 e3       	mov	r3,126
8000a072:	c0 48       	rjmp	8000a07a <_malloc_r+0xbe>
8000a074:	ee 03 16 12 	lsr	r3,r7,0x12
8000a078:	28 43       	sub	r3,-124
8000a07a:	e0 6a 05 38 	mov	r10,1336
8000a07e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a082:	74 36       	ld.w	r6,r10[0xc]
8000a084:	c1 98       	rjmp	8000a0b6 <_malloc_r+0xfa>
8000a086:	6c 19       	ld.w	r9,r6[0x4]
8000a088:	e0 19 ff fc 	andl	r9,0xfffc
8000a08c:	f2 07 01 0b 	sub	r11,r9,r7
8000a090:	58 fb       	cp.w	r11,15
8000a092:	e0 8a 00 04 	brle	8000a09a <_malloc_r+0xde>
8000a096:	20 13       	sub	r3,1
8000a098:	c1 18       	rjmp	8000a0ba <_malloc_r+0xfe>
8000a09a:	6c 38       	ld.w	r8,r6[0xc]
8000a09c:	58 0b       	cp.w	r11,0
8000a09e:	c0 b5       	brlt	8000a0b4 <_malloc_r+0xf8>
8000a0a0:	6c 2a       	ld.w	r10,r6[0x8]
8000a0a2:	ec 09 00 09 	add	r9,r6,r9
8000a0a6:	0a 9c       	mov	r12,r5
8000a0a8:	91 2a       	st.w	r8[0x8],r10
8000a0aa:	95 38       	st.w	r10[0xc],r8
8000a0ac:	72 18       	ld.w	r8,r9[0x4]
8000a0ae:	a1 a8       	sbr	r8,0x0
8000a0b0:	93 18       	st.w	r9[0x4],r8
8000a0b2:	cb c8       	rjmp	8000a22a <_malloc_r+0x26e>
8000a0b4:	10 96       	mov	r6,r8
8000a0b6:	14 36       	cp.w	r6,r10
8000a0b8:	ce 71       	brne	8000a086 <_malloc_r+0xca>
8000a0ba:	2f f3       	sub	r3,-1
8000a0bc:	e0 6a 05 38 	mov	r10,1336
8000a0c0:	f4 cc ff f8 	sub	r12,r10,-8
8000a0c4:	78 26       	ld.w	r6,r12[0x8]
8000a0c6:	18 36       	cp.w	r6,r12
8000a0c8:	c6 c0       	breq	8000a1a0 <_malloc_r+0x1e4>
8000a0ca:	6c 19       	ld.w	r9,r6[0x4]
8000a0cc:	e0 19 ff fc 	andl	r9,0xfffc
8000a0d0:	f2 07 01 08 	sub	r8,r9,r7
8000a0d4:	58 f8       	cp.w	r8,15
8000a0d6:	e0 89 00 8f 	brgt	8000a1f4 <_malloc_r+0x238>
8000a0da:	99 3c       	st.w	r12[0xc],r12
8000a0dc:	99 2c       	st.w	r12[0x8],r12
8000a0de:	58 08       	cp.w	r8,0
8000a0e0:	c0 55       	brlt	8000a0ea <_malloc_r+0x12e>
8000a0e2:	ec 09 00 09 	add	r9,r6,r9
8000a0e6:	0a 9c       	mov	r12,r5
8000a0e8:	ce 2b       	rjmp	8000a0ac <_malloc_r+0xf0>
8000a0ea:	e0 49 01 ff 	cp.w	r9,511
8000a0ee:	e0 8b 00 13 	brhi	8000a114 <_malloc_r+0x158>
8000a0f2:	a3 99       	lsr	r9,0x3
8000a0f4:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a0f8:	70 2b       	ld.w	r11,r8[0x8]
8000a0fa:	8d 38       	st.w	r6[0xc],r8
8000a0fc:	8d 2b       	st.w	r6[0x8],r11
8000a0fe:	97 36       	st.w	r11[0xc],r6
8000a100:	91 26       	st.w	r8[0x8],r6
8000a102:	a3 49       	asr	r9,0x2
8000a104:	74 18       	ld.w	r8,r10[0x4]
8000a106:	30 1b       	mov	r11,1
8000a108:	f6 09 09 49 	lsl	r9,r11,r9
8000a10c:	f1 e9 10 09 	or	r9,r8,r9
8000a110:	95 19       	st.w	r10[0x4],r9
8000a112:	c4 78       	rjmp	8000a1a0 <_malloc_r+0x1e4>
8000a114:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a118:	58 4a       	cp.w	r10,4
8000a11a:	e0 8b 00 07 	brhi	8000a128 <_malloc_r+0x16c>
8000a11e:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a122:	2c 8a       	sub	r10,-56
8000a124:	c2 08       	rjmp	8000a164 <_malloc_r+0x1a8>
8000a126:	d7 03       	nop
8000a128:	59 4a       	cp.w	r10,20
8000a12a:	e0 8b 00 04 	brhi	8000a132 <_malloc_r+0x176>
8000a12e:	2a 5a       	sub	r10,-91
8000a130:	c1 a8       	rjmp	8000a164 <_malloc_r+0x1a8>
8000a132:	e0 4a 00 54 	cp.w	r10,84
8000a136:	e0 8b 00 06 	brhi	8000a142 <_malloc_r+0x186>
8000a13a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a13e:	29 2a       	sub	r10,-110
8000a140:	c1 28       	rjmp	8000a164 <_malloc_r+0x1a8>
8000a142:	e0 4a 01 54 	cp.w	r10,340
8000a146:	e0 8b 00 06 	brhi	8000a152 <_malloc_r+0x196>
8000a14a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a14e:	28 9a       	sub	r10,-119
8000a150:	c0 a8       	rjmp	8000a164 <_malloc_r+0x1a8>
8000a152:	e0 4a 05 54 	cp.w	r10,1364
8000a156:	e0 88 00 04 	brls	8000a15e <_malloc_r+0x1a2>
8000a15a:	37 ea       	mov	r10,126
8000a15c:	c0 48       	rjmp	8000a164 <_malloc_r+0x1a8>
8000a15e:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a162:	28 4a       	sub	r10,-124
8000a164:	e0 6b 05 38 	mov	r11,1336
8000a168:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a16c:	68 28       	ld.w	r8,r4[0x8]
8000a16e:	08 38       	cp.w	r8,r4
8000a170:	c0 e1       	brne	8000a18c <_malloc_r+0x1d0>
8000a172:	76 19       	ld.w	r9,r11[0x4]
8000a174:	a3 4a       	asr	r10,0x2
8000a176:	30 1e       	mov	lr,1
8000a178:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a17c:	f3 ea 10 0a 	or	r10,r9,r10
8000a180:	10 99       	mov	r9,r8
8000a182:	97 1a       	st.w	r11[0x4],r10
8000a184:	c0 a8       	rjmp	8000a198 <_malloc_r+0x1dc>
8000a186:	70 28       	ld.w	r8,r8[0x8]
8000a188:	08 38       	cp.w	r8,r4
8000a18a:	c0 60       	breq	8000a196 <_malloc_r+0x1da>
8000a18c:	70 1a       	ld.w	r10,r8[0x4]
8000a18e:	e0 1a ff fc 	andl	r10,0xfffc
8000a192:	14 39       	cp.w	r9,r10
8000a194:	cf 93       	brcs	8000a186 <_malloc_r+0x1ca>
8000a196:	70 39       	ld.w	r9,r8[0xc]
8000a198:	8d 39       	st.w	r6[0xc],r9
8000a19a:	8d 28       	st.w	r6[0x8],r8
8000a19c:	91 36       	st.w	r8[0xc],r6
8000a19e:	93 26       	st.w	r9[0x8],r6
8000a1a0:	e6 08 14 02 	asr	r8,r3,0x2
8000a1a4:	30 1b       	mov	r11,1
8000a1a6:	e0 64 05 38 	mov	r4,1336
8000a1aa:	f6 08 09 4b 	lsl	r11,r11,r8
8000a1ae:	68 18       	ld.w	r8,r4[0x4]
8000a1b0:	10 3b       	cp.w	r11,r8
8000a1b2:	e0 8b 00 6b 	brhi	8000a288 <_malloc_r+0x2cc>
8000a1b6:	f7 e8 00 09 	and	r9,r11,r8
8000a1ba:	c0 b1       	brne	8000a1d0 <_malloc_r+0x214>
8000a1bc:	e0 13 ff fc 	andl	r3,0xfffc
8000a1c0:	a1 7b       	lsl	r11,0x1
8000a1c2:	2f c3       	sub	r3,-4
8000a1c4:	c0 38       	rjmp	8000a1ca <_malloc_r+0x20e>
8000a1c6:	2f c3       	sub	r3,-4
8000a1c8:	a1 7b       	lsl	r11,0x1
8000a1ca:	f7 e8 00 09 	and	r9,r11,r8
8000a1ce:	cf c0       	breq	8000a1c6 <_malloc_r+0x20a>
8000a1d0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a1d4:	06 92       	mov	r2,r3
8000a1d6:	1c 91       	mov	r1,lr
8000a1d8:	62 36       	ld.w	r6,r1[0xc]
8000a1da:	c2 e8       	rjmp	8000a236 <_malloc_r+0x27a>
8000a1dc:	6c 1a       	ld.w	r10,r6[0x4]
8000a1de:	e0 1a ff fc 	andl	r10,0xfffc
8000a1e2:	f4 07 01 08 	sub	r8,r10,r7
8000a1e6:	58 f8       	cp.w	r8,15
8000a1e8:	e0 8a 00 15 	brle	8000a212 <_malloc_r+0x256>
8000a1ec:	6c 3a       	ld.w	r10,r6[0xc]
8000a1ee:	6c 29       	ld.w	r9,r6[0x8]
8000a1f0:	95 29       	st.w	r10[0x8],r9
8000a1f2:	93 3a       	st.w	r9[0xc],r10
8000a1f4:	0e 99       	mov	r9,r7
8000a1f6:	ec 07 00 07 	add	r7,r6,r7
8000a1fa:	a1 a9       	sbr	r9,0x0
8000a1fc:	99 37       	st.w	r12[0xc],r7
8000a1fe:	99 27       	st.w	r12[0x8],r7
8000a200:	8d 19       	st.w	r6[0x4],r9
8000a202:	ee 08 09 08 	st.w	r7[r8],r8
8000a206:	8f 2c       	st.w	r7[0x8],r12
8000a208:	8f 3c       	st.w	r7[0xc],r12
8000a20a:	a1 a8       	sbr	r8,0x0
8000a20c:	0a 9c       	mov	r12,r5
8000a20e:	8f 18       	st.w	r7[0x4],r8
8000a210:	c0 d8       	rjmp	8000a22a <_malloc_r+0x26e>
8000a212:	6c 39       	ld.w	r9,r6[0xc]
8000a214:	58 08       	cp.w	r8,0
8000a216:	c0 f5       	brlt	8000a234 <_malloc_r+0x278>
8000a218:	ec 0a 00 0a 	add	r10,r6,r10
8000a21c:	74 18       	ld.w	r8,r10[0x4]
8000a21e:	a1 a8       	sbr	r8,0x0
8000a220:	0a 9c       	mov	r12,r5
8000a222:	95 18       	st.w	r10[0x4],r8
8000a224:	6c 28       	ld.w	r8,r6[0x8]
8000a226:	93 28       	st.w	r9[0x8],r8
8000a228:	91 39       	st.w	r8[0xc],r9
8000a22a:	fe b0 f4 1b 	rcall	80008a60 <__malloc_unlock>
8000a22e:	ec cc ff f8 	sub	r12,r6,-8
8000a232:	d8 32       	popm	r0-r7,pc
8000a234:	12 96       	mov	r6,r9
8000a236:	02 36       	cp.w	r6,r1
8000a238:	cd 21       	brne	8000a1dc <_malloc_r+0x220>
8000a23a:	2f f2       	sub	r2,-1
8000a23c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a240:	c0 30       	breq	8000a246 <_malloc_r+0x28a>
8000a242:	2f 81       	sub	r1,-8
8000a244:	cc ab       	rjmp	8000a1d8 <_malloc_r+0x21c>
8000a246:	1c 98       	mov	r8,lr
8000a248:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a24c:	c0 81       	brne	8000a25c <_malloc_r+0x2a0>
8000a24e:	68 19       	ld.w	r9,r4[0x4]
8000a250:	f6 08 11 ff 	rsub	r8,r11,-1
8000a254:	f3 e8 00 08 	and	r8,r9,r8
8000a258:	89 18       	st.w	r4[0x4],r8
8000a25a:	c0 78       	rjmp	8000a268 <_malloc_r+0x2ac>
8000a25c:	f0 c9 00 08 	sub	r9,r8,8
8000a260:	20 13       	sub	r3,1
8000a262:	70 08       	ld.w	r8,r8[0x0]
8000a264:	12 38       	cp.w	r8,r9
8000a266:	cf 10       	breq	8000a248 <_malloc_r+0x28c>
8000a268:	a1 7b       	lsl	r11,0x1
8000a26a:	68 18       	ld.w	r8,r4[0x4]
8000a26c:	10 3b       	cp.w	r11,r8
8000a26e:	e0 8b 00 0d 	brhi	8000a288 <_malloc_r+0x2cc>
8000a272:	58 0b       	cp.w	r11,0
8000a274:	c0 a0       	breq	8000a288 <_malloc_r+0x2cc>
8000a276:	04 93       	mov	r3,r2
8000a278:	c0 38       	rjmp	8000a27e <_malloc_r+0x2c2>
8000a27a:	2f c3       	sub	r3,-4
8000a27c:	a1 7b       	lsl	r11,0x1
8000a27e:	f7 e8 00 09 	and	r9,r11,r8
8000a282:	ca 71       	brne	8000a1d0 <_malloc_r+0x214>
8000a284:	cf bb       	rjmp	8000a27a <_malloc_r+0x2be>
8000a286:	d7 03       	nop
8000a288:	68 23       	ld.w	r3,r4[0x8]
8000a28a:	66 12       	ld.w	r2,r3[0x4]
8000a28c:	e0 12 ff fc 	andl	r2,0xfffc
8000a290:	0e 32       	cp.w	r2,r7
8000a292:	5f 39       	srlo	r9
8000a294:	e4 07 01 08 	sub	r8,r2,r7
8000a298:	58 f8       	cp.w	r8,15
8000a29a:	5f aa       	srle	r10
8000a29c:	f5 e9 10 09 	or	r9,r10,r9
8000a2a0:	e0 80 00 9a 	breq	8000a3d4 <_malloc_r+0x418>
8000a2a4:	e0 68 12 94 	mov	r8,4756
8000a2a8:	70 01       	ld.w	r1,r8[0x0]
8000a2aa:	e0 68 09 44 	mov	r8,2372
8000a2ae:	2f 01       	sub	r1,-16
8000a2b0:	70 08       	ld.w	r8,r8[0x0]
8000a2b2:	0e 01       	add	r1,r7
8000a2b4:	5b f8       	cp.w	r8,-1
8000a2b6:	c0 40       	breq	8000a2be <_malloc_r+0x302>
8000a2b8:	28 11       	sub	r1,-127
8000a2ba:	e0 11 ff 80 	andl	r1,0xff80
8000a2be:	02 9b       	mov	r11,r1
8000a2c0:	0a 9c       	mov	r12,r5
8000a2c2:	e0 a0 02 b7 	rcall	8000a830 <_sbrk_r>
8000a2c6:	18 96       	mov	r6,r12
8000a2c8:	5b fc       	cp.w	r12,-1
8000a2ca:	c7 50       	breq	8000a3b4 <_malloc_r+0x3f8>
8000a2cc:	e6 02 00 08 	add	r8,r3,r2
8000a2d0:	10 3c       	cp.w	r12,r8
8000a2d2:	c0 32       	brcc	8000a2d8 <_malloc_r+0x31c>
8000a2d4:	08 33       	cp.w	r3,r4
8000a2d6:	c6 f1       	brne	8000a3b4 <_malloc_r+0x3f8>
8000a2d8:	e0 6a 12 98 	mov	r10,4760
8000a2dc:	74 09       	ld.w	r9,r10[0x0]
8000a2de:	e2 09 00 09 	add	r9,r1,r9
8000a2e2:	95 09       	st.w	r10[0x0],r9
8000a2e4:	10 36       	cp.w	r6,r8
8000a2e6:	c0 a1       	brne	8000a2fa <_malloc_r+0x33e>
8000a2e8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a2ec:	c0 71       	brne	8000a2fa <_malloc_r+0x33e>
8000a2ee:	e2 02 00 02 	add	r2,r1,r2
8000a2f2:	68 28       	ld.w	r8,r4[0x8]
8000a2f4:	a1 a2       	sbr	r2,0x0
8000a2f6:	91 12       	st.w	r8[0x4],r2
8000a2f8:	c4 f8       	rjmp	8000a396 <_malloc_r+0x3da>
8000a2fa:	e0 6a 09 44 	mov	r10,2372
8000a2fe:	74 0b       	ld.w	r11,r10[0x0]
8000a300:	5b fb       	cp.w	r11,-1
8000a302:	c0 31       	brne	8000a308 <_malloc_r+0x34c>
8000a304:	95 06       	st.w	r10[0x0],r6
8000a306:	c0 78       	rjmp	8000a314 <_malloc_r+0x358>
8000a308:	ec 09 00 09 	add	r9,r6,r9
8000a30c:	e0 6a 12 98 	mov	r10,4760
8000a310:	10 19       	sub	r9,r8
8000a312:	95 09       	st.w	r10[0x0],r9
8000a314:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a318:	f0 09 11 08 	rsub	r9,r8,8
8000a31c:	58 08       	cp.w	r8,0
8000a31e:	f2 08 17 10 	movne	r8,r9
8000a322:	ed d8 e1 06 	addne	r6,r6,r8
8000a326:	28 08       	sub	r8,-128
8000a328:	ec 01 00 01 	add	r1,r6,r1
8000a32c:	0a 9c       	mov	r12,r5
8000a32e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a332:	f0 01 01 01 	sub	r1,r8,r1
8000a336:	02 9b       	mov	r11,r1
8000a338:	e0 a0 02 7c 	rcall	8000a830 <_sbrk_r>
8000a33c:	e0 68 12 98 	mov	r8,4760
8000a340:	5b fc       	cp.w	r12,-1
8000a342:	ec 0c 17 00 	moveq	r12,r6
8000a346:	f9 b1 00 00 	moveq	r1,0
8000a34a:	70 09       	ld.w	r9,r8[0x0]
8000a34c:	0c 1c       	sub	r12,r6
8000a34e:	89 26       	st.w	r4[0x8],r6
8000a350:	02 0c       	add	r12,r1
8000a352:	12 01       	add	r1,r9
8000a354:	a1 ac       	sbr	r12,0x0
8000a356:	91 01       	st.w	r8[0x0],r1
8000a358:	8d 1c       	st.w	r6[0x4],r12
8000a35a:	08 33       	cp.w	r3,r4
8000a35c:	c1 d0       	breq	8000a396 <_malloc_r+0x3da>
8000a35e:	58 f2       	cp.w	r2,15
8000a360:	e0 8b 00 05 	brhi	8000a36a <_malloc_r+0x3ae>
8000a364:	30 18       	mov	r8,1
8000a366:	8d 18       	st.w	r6[0x4],r8
8000a368:	c2 68       	rjmp	8000a3b4 <_malloc_r+0x3f8>
8000a36a:	30 59       	mov	r9,5
8000a36c:	20 c2       	sub	r2,12
8000a36e:	e0 12 ff f8 	andl	r2,0xfff8
8000a372:	e6 02 00 08 	add	r8,r3,r2
8000a376:	91 29       	st.w	r8[0x8],r9
8000a378:	91 19       	st.w	r8[0x4],r9
8000a37a:	66 18       	ld.w	r8,r3[0x4]
8000a37c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a380:	e5 e8 10 08 	or	r8,r2,r8
8000a384:	87 18       	st.w	r3[0x4],r8
8000a386:	58 f2       	cp.w	r2,15
8000a388:	e0 88 00 07 	brls	8000a396 <_malloc_r+0x3da>
8000a38c:	e6 cb ff f8 	sub	r11,r3,-8
8000a390:	0a 9c       	mov	r12,r5
8000a392:	e0 a0 1d 23 	rcall	8000ddd8 <_free_r>
8000a396:	e0 69 12 90 	mov	r9,4752
8000a39a:	72 0a       	ld.w	r10,r9[0x0]
8000a39c:	e0 68 12 98 	mov	r8,4760
8000a3a0:	70 08       	ld.w	r8,r8[0x0]
8000a3a2:	14 38       	cp.w	r8,r10
8000a3a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a3a8:	e0 69 12 8c 	mov	r9,4748
8000a3ac:	72 0a       	ld.w	r10,r9[0x0]
8000a3ae:	14 38       	cp.w	r8,r10
8000a3b0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a3b4:	68 28       	ld.w	r8,r4[0x8]
8000a3b6:	70 18       	ld.w	r8,r8[0x4]
8000a3b8:	e0 18 ff fc 	andl	r8,0xfffc
8000a3bc:	0e 38       	cp.w	r8,r7
8000a3be:	5f 39       	srlo	r9
8000a3c0:	0e 18       	sub	r8,r7
8000a3c2:	58 f8       	cp.w	r8,15
8000a3c4:	5f aa       	srle	r10
8000a3c6:	f5 e9 10 09 	or	r9,r10,r9
8000a3ca:	c0 50       	breq	8000a3d4 <_malloc_r+0x418>
8000a3cc:	0a 9c       	mov	r12,r5
8000a3ce:	fe b0 f3 49 	rcall	80008a60 <__malloc_unlock>
8000a3d2:	d8 3a       	popm	r0-r7,pc,r12=0
8000a3d4:	68 26       	ld.w	r6,r4[0x8]
8000a3d6:	a1 a8       	sbr	r8,0x0
8000a3d8:	0e 99       	mov	r9,r7
8000a3da:	a1 a9       	sbr	r9,0x0
8000a3dc:	8d 19       	st.w	r6[0x4],r9
8000a3de:	ec 07 00 07 	add	r7,r6,r7
8000a3e2:	0a 9c       	mov	r12,r5
8000a3e4:	89 27       	st.w	r4[0x8],r7
8000a3e6:	8f 18       	st.w	r7[0x4],r8
8000a3e8:	fe b0 f3 3c 	rcall	80008a60 <__malloc_unlock>
8000a3ec:	ec cc ff f8 	sub	r12,r6,-8
8000a3f0:	d8 32       	popm	r0-r7,pc
8000a3f2:	d7 03       	nop

8000a3f4 <memcmp>:
8000a3f4:	d4 01       	pushm	lr
8000a3f6:	30 08       	mov	r8,0
8000a3f8:	c0 d8       	rjmp	8000a412 <memcmp+0x1e>
8000a3fa:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a3fe:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a402:	20 1a       	sub	r10,1
8000a404:	2f f8       	sub	r8,-1
8000a406:	f2 0e 18 00 	cp.b	lr,r9
8000a40a:	c0 40       	breq	8000a412 <memcmp+0x1e>
8000a40c:	fc 09 01 0c 	sub	r12,lr,r9
8000a410:	d8 02       	popm	pc
8000a412:	58 0a       	cp.w	r10,0
8000a414:	cf 31       	brne	8000a3fa <memcmp+0x6>
8000a416:	14 9c       	mov	r12,r10
8000a418:	d8 02       	popm	pc

8000a41a <memcpy>:
8000a41a:	58 8a       	cp.w	r10,8
8000a41c:	c2 f5       	brlt	8000a47a <memcpy+0x60>
8000a41e:	f9 eb 10 09 	or	r9,r12,r11
8000a422:	e2 19 00 03 	andl	r9,0x3,COH
8000a426:	e0 81 00 97 	brne	8000a554 <memcpy+0x13a>
8000a42a:	e0 4a 00 20 	cp.w	r10,32
8000a42e:	c3 b4       	brge	8000a4a4 <memcpy+0x8a>
8000a430:	f4 08 14 02 	asr	r8,r10,0x2
8000a434:	f0 09 11 08 	rsub	r9,r8,8
8000a438:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a43c:	76 69       	ld.w	r9,r11[0x18]
8000a43e:	99 69       	st.w	r12[0x18],r9
8000a440:	76 59       	ld.w	r9,r11[0x14]
8000a442:	99 59       	st.w	r12[0x14],r9
8000a444:	76 49       	ld.w	r9,r11[0x10]
8000a446:	99 49       	st.w	r12[0x10],r9
8000a448:	76 39       	ld.w	r9,r11[0xc]
8000a44a:	99 39       	st.w	r12[0xc],r9
8000a44c:	76 29       	ld.w	r9,r11[0x8]
8000a44e:	99 29       	st.w	r12[0x8],r9
8000a450:	76 19       	ld.w	r9,r11[0x4]
8000a452:	99 19       	st.w	r12[0x4],r9
8000a454:	76 09       	ld.w	r9,r11[0x0]
8000a456:	99 09       	st.w	r12[0x0],r9
8000a458:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a45c:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a460:	e0 1a 00 03 	andl	r10,0x3
8000a464:	f4 0a 11 04 	rsub	r10,r10,4
8000a468:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a46c:	17 a9       	ld.ub	r9,r11[0x2]
8000a46e:	b0 a9       	st.b	r8[0x2],r9
8000a470:	17 99       	ld.ub	r9,r11[0x1]
8000a472:	b0 99       	st.b	r8[0x1],r9
8000a474:	17 89       	ld.ub	r9,r11[0x0]
8000a476:	b0 89       	st.b	r8[0x0],r9
8000a478:	5e fc       	retal	r12
8000a47a:	f4 0a 11 09 	rsub	r10,r10,9
8000a47e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a482:	17 f9       	ld.ub	r9,r11[0x7]
8000a484:	b8 f9       	st.b	r12[0x7],r9
8000a486:	17 e9       	ld.ub	r9,r11[0x6]
8000a488:	b8 e9       	st.b	r12[0x6],r9
8000a48a:	17 d9       	ld.ub	r9,r11[0x5]
8000a48c:	b8 d9       	st.b	r12[0x5],r9
8000a48e:	17 c9       	ld.ub	r9,r11[0x4]
8000a490:	b8 c9       	st.b	r12[0x4],r9
8000a492:	17 b9       	ld.ub	r9,r11[0x3]
8000a494:	b8 b9       	st.b	r12[0x3],r9
8000a496:	17 a9       	ld.ub	r9,r11[0x2]
8000a498:	b8 a9       	st.b	r12[0x2],r9
8000a49a:	17 99       	ld.ub	r9,r11[0x1]
8000a49c:	b8 99       	st.b	r12[0x1],r9
8000a49e:	17 89       	ld.ub	r9,r11[0x0]
8000a4a0:	b8 89       	st.b	r12[0x0],r9
8000a4a2:	5e fc       	retal	r12
8000a4a4:	eb cd 40 c0 	pushm	r6-r7,lr
8000a4a8:	18 99       	mov	r9,r12
8000a4aa:	22 0a       	sub	r10,32
8000a4ac:	b7 07       	ld.d	r6,r11++
8000a4ae:	b3 26       	st.d	r9++,r6
8000a4b0:	b7 07       	ld.d	r6,r11++
8000a4b2:	b3 26       	st.d	r9++,r6
8000a4b4:	b7 07       	ld.d	r6,r11++
8000a4b6:	b3 26       	st.d	r9++,r6
8000a4b8:	b7 07       	ld.d	r6,r11++
8000a4ba:	b3 26       	st.d	r9++,r6
8000a4bc:	22 0a       	sub	r10,32
8000a4be:	cf 74       	brge	8000a4ac <memcpy+0x92>
8000a4c0:	2f 0a       	sub	r10,-16
8000a4c2:	c0 65       	brlt	8000a4ce <memcpy+0xb4>
8000a4c4:	b7 07       	ld.d	r6,r11++
8000a4c6:	b3 26       	st.d	r9++,r6
8000a4c8:	b7 07       	ld.d	r6,r11++
8000a4ca:	b3 26       	st.d	r9++,r6
8000a4cc:	21 0a       	sub	r10,16
8000a4ce:	5c 3a       	neg	r10
8000a4d0:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a4d4:	d7 03       	nop
8000a4d6:	d7 03       	nop
8000a4d8:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a4dc:	f3 66 00 0e 	st.b	r9[14],r6
8000a4e0:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a4e4:	f3 66 00 0d 	st.b	r9[13],r6
8000a4e8:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a4ec:	f3 66 00 0c 	st.b	r9[12],r6
8000a4f0:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a4f4:	f3 66 00 0b 	st.b	r9[11],r6
8000a4f8:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a4fc:	f3 66 00 0a 	st.b	r9[10],r6
8000a500:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a504:	f3 66 00 09 	st.b	r9[9],r6
8000a508:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a50c:	f3 66 00 08 	st.b	r9[8],r6
8000a510:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a514:	f3 66 00 07 	st.b	r9[7],r6
8000a518:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a51c:	f3 66 00 06 	st.b	r9[6],r6
8000a520:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a524:	f3 66 00 05 	st.b	r9[5],r6
8000a528:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a52c:	f3 66 00 04 	st.b	r9[4],r6
8000a530:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a534:	f3 66 00 03 	st.b	r9[3],r6
8000a538:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a53c:	f3 66 00 02 	st.b	r9[2],r6
8000a540:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a544:	f3 66 00 01 	st.b	r9[1],r6
8000a548:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a54c:	f3 66 00 00 	st.b	r9[0],r6
8000a550:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a554:	20 1a       	sub	r10,1
8000a556:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a55a:	f8 0a 0b 09 	st.b	r12[r10],r9
8000a55e:	cf b1       	brne	8000a554 <memcpy+0x13a>
8000a560:	5e fc       	retal	r12

8000a562 <memset>:
8000a562:	18 98       	mov	r8,r12
8000a564:	c0 38       	rjmp	8000a56a <memset+0x8>
8000a566:	10 cb       	st.b	r8++,r11
8000a568:	20 1a       	sub	r10,1
8000a56a:	58 0a       	cp.w	r10,0
8000a56c:	cf d1       	brne	8000a566 <memset+0x4>
8000a56e:	5e fc       	retal	r12

8000a570 <_realloc_r>:
8000a570:	d4 31       	pushm	r0-r7,lr
8000a572:	20 1d       	sub	sp,4
8000a574:	16 94       	mov	r4,r11
8000a576:	18 92       	mov	r2,r12
8000a578:	14 9b       	mov	r11,r10
8000a57a:	58 04       	cp.w	r4,0
8000a57c:	c0 51       	brne	8000a586 <_realloc_r+0x16>
8000a57e:	fe b0 fd 1f 	rcall	80009fbc <_malloc_r>
8000a582:	18 95       	mov	r5,r12
8000a584:	c5 39       	rjmp	8000a82a <_realloc_r+0x2ba>
8000a586:	50 0a       	stdsp	sp[0x0],r10
8000a588:	fe b0 f2 66 	rcall	80008a54 <__malloc_lock>
8000a58c:	40 0b       	lddsp	r11,sp[0x0]
8000a58e:	f6 c8 ff f5 	sub	r8,r11,-11
8000a592:	e8 c1 00 08 	sub	r1,r4,8
8000a596:	10 96       	mov	r6,r8
8000a598:	62 1c       	ld.w	r12,r1[0x4]
8000a59a:	e0 16 ff f8 	andl	r6,0xfff8
8000a59e:	59 68       	cp.w	r8,22
8000a5a0:	f9 b6 08 10 	movls	r6,16
8000a5a4:	16 36       	cp.w	r6,r11
8000a5a6:	5f 38       	srlo	r8
8000a5a8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000a5ac:	c0 50       	breq	8000a5b6 <_realloc_r+0x46>
8000a5ae:	30 c8       	mov	r8,12
8000a5b0:	30 05       	mov	r5,0
8000a5b2:	85 38       	st.w	r2[0xc],r8
8000a5b4:	c3 b9       	rjmp	8000a82a <_realloc_r+0x2ba>
8000a5b6:	18 90       	mov	r0,r12
8000a5b8:	e0 10 ff fc 	andl	r0,0xfffc
8000a5bc:	0c 30       	cp.w	r0,r6
8000a5be:	e0 84 01 0b 	brge	8000a7d4 <_realloc_r+0x264>
8000a5c2:	e0 68 05 38 	mov	r8,1336
8000a5c6:	e2 00 00 09 	add	r9,r1,r0
8000a5ca:	70 25       	ld.w	r5,r8[0x8]
8000a5cc:	0a 39       	cp.w	r9,r5
8000a5ce:	c0 90       	breq	8000a5e0 <_realloc_r+0x70>
8000a5d0:	72 1a       	ld.w	r10,r9[0x4]
8000a5d2:	a1 ca       	cbr	r10,0x0
8000a5d4:	f2 0a 00 0a 	add	r10,r9,r10
8000a5d8:	74 1a       	ld.w	r10,r10[0x4]
8000a5da:	ed ba 00 00 	bld	r10,0x0
8000a5de:	c2 20       	breq	8000a622 <_realloc_r+0xb2>
8000a5e0:	72 1a       	ld.w	r10,r9[0x4]
8000a5e2:	e0 1a ff fc 	andl	r10,0xfffc
8000a5e6:	f4 00 00 03 	add	r3,r10,r0
8000a5ea:	0a 39       	cp.w	r9,r5
8000a5ec:	c1 31       	brne	8000a612 <_realloc_r+0xa2>
8000a5ee:	ec c7 ff f0 	sub	r7,r6,-16
8000a5f2:	0e 33       	cp.w	r3,r7
8000a5f4:	c1 95       	brlt	8000a626 <_realloc_r+0xb6>
8000a5f6:	e2 06 00 09 	add	r9,r1,r6
8000a5fa:	0c 13       	sub	r3,r6
8000a5fc:	a1 a3       	sbr	r3,0x0
8000a5fe:	93 13       	st.w	r9[0x4],r3
8000a600:	91 29       	st.w	r8[0x8],r9
8000a602:	04 9c       	mov	r12,r2
8000a604:	62 18       	ld.w	r8,r1[0x4]
8000a606:	08 95       	mov	r5,r4
8000a608:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a60c:	10 46       	or	r6,r8
8000a60e:	83 16       	st.w	r1[0x4],r6
8000a610:	c0 b9       	rjmp	8000a826 <_realloc_r+0x2b6>
8000a612:	0c 33       	cp.w	r3,r6
8000a614:	c0 95       	brlt	8000a626 <_realloc_r+0xb6>
8000a616:	72 28       	ld.w	r8,r9[0x8]
8000a618:	02 97       	mov	r7,r1
8000a61a:	72 39       	ld.w	r9,r9[0xc]
8000a61c:	93 28       	st.w	r9[0x8],r8
8000a61e:	91 39       	st.w	r8[0xc],r9
8000a620:	cd c8       	rjmp	8000a7d8 <_realloc_r+0x268>
8000a622:	30 0a       	mov	r10,0
8000a624:	14 99       	mov	r9,r10
8000a626:	ed bc 00 00 	bld	r12,0x0
8000a62a:	e0 80 00 95 	breq	8000a754 <_realloc_r+0x1e4>
8000a62e:	62 07       	ld.w	r7,r1[0x0]
8000a630:	e2 07 01 07 	sub	r7,r1,r7
8000a634:	6e 1c       	ld.w	r12,r7[0x4]
8000a636:	e0 1c ff fc 	andl	r12,0xfffc
8000a63a:	58 09       	cp.w	r9,0
8000a63c:	c5 60       	breq	8000a6e8 <_realloc_r+0x178>
8000a63e:	f8 00 00 03 	add	r3,r12,r0
8000a642:	0a 39       	cp.w	r9,r5
8000a644:	c4 81       	brne	8000a6d4 <_realloc_r+0x164>
8000a646:	14 03       	add	r3,r10
8000a648:	ec c9 ff f0 	sub	r9,r6,-16
8000a64c:	12 33       	cp.w	r3,r9
8000a64e:	c4 d5       	brlt	8000a6e8 <_realloc_r+0x178>
8000a650:	6e 3a       	ld.w	r10,r7[0xc]
8000a652:	6e 29       	ld.w	r9,r7[0x8]
8000a654:	95 29       	st.w	r10[0x8],r9
8000a656:	93 3a       	st.w	r9[0xc],r10
8000a658:	ee c5 ff f8 	sub	r5,r7,-8
8000a65c:	e0 ca 00 04 	sub	r10,r0,4
8000a660:	e0 4a 00 24 	cp.w	r10,36
8000a664:	e0 8b 00 25 	brhi	8000a6ae <_realloc_r+0x13e>
8000a668:	0a 99       	mov	r9,r5
8000a66a:	59 3a       	cp.w	r10,19
8000a66c:	e0 88 00 1a 	brls	8000a6a0 <_realloc_r+0x130>
8000a670:	09 09       	ld.w	r9,r4++
8000a672:	8b 09       	st.w	r5[0x0],r9
8000a674:	09 09       	ld.w	r9,r4++
8000a676:	8f 39       	st.w	r7[0xc],r9
8000a678:	ee c9 ff f0 	sub	r9,r7,-16
8000a67c:	59 ba       	cp.w	r10,27
8000a67e:	e0 88 00 11 	brls	8000a6a0 <_realloc_r+0x130>
8000a682:	09 0b       	ld.w	r11,r4++
8000a684:	93 0b       	st.w	r9[0x0],r11
8000a686:	09 09       	ld.w	r9,r4++
8000a688:	8f 59       	st.w	r7[0x14],r9
8000a68a:	ee c9 ff e8 	sub	r9,r7,-24
8000a68e:	e0 4a 00 24 	cp.w	r10,36
8000a692:	c0 71       	brne	8000a6a0 <_realloc_r+0x130>
8000a694:	09 0a       	ld.w	r10,r4++
8000a696:	93 0a       	st.w	r9[0x0],r10
8000a698:	ee c9 ff e0 	sub	r9,r7,-32
8000a69c:	09 0a       	ld.w	r10,r4++
8000a69e:	8f 7a       	st.w	r7[0x1c],r10
8000a6a0:	09 0a       	ld.w	r10,r4++
8000a6a2:	12 aa       	st.w	r9++,r10
8000a6a4:	68 0a       	ld.w	r10,r4[0x0]
8000a6a6:	93 0a       	st.w	r9[0x0],r10
8000a6a8:	68 1a       	ld.w	r10,r4[0x4]
8000a6aa:	93 1a       	st.w	r9[0x4],r10
8000a6ac:	c0 78       	rjmp	8000a6ba <_realloc_r+0x14a>
8000a6ae:	50 08       	stdsp	sp[0x0],r8
8000a6b0:	08 9b       	mov	r11,r4
8000a6b2:	0a 9c       	mov	r12,r5
8000a6b4:	e0 a0 1e 35 	rcall	8000e31e <memmove>
8000a6b8:	40 08       	lddsp	r8,sp[0x0]
8000a6ba:	ee 06 00 09 	add	r9,r7,r6
8000a6be:	0c 13       	sub	r3,r6
8000a6c0:	a1 a3       	sbr	r3,0x0
8000a6c2:	93 13       	st.w	r9[0x4],r3
8000a6c4:	91 29       	st.w	r8[0x8],r9
8000a6c6:	04 9c       	mov	r12,r2
8000a6c8:	6e 18       	ld.w	r8,r7[0x4]
8000a6ca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a6ce:	10 46       	or	r6,r8
8000a6d0:	8f 16       	st.w	r7[0x4],r6
8000a6d2:	ca a8       	rjmp	8000a826 <_realloc_r+0x2b6>
8000a6d4:	14 03       	add	r3,r10
8000a6d6:	0c 33       	cp.w	r3,r6
8000a6d8:	c0 85       	brlt	8000a6e8 <_realloc_r+0x178>
8000a6da:	72 28       	ld.w	r8,r9[0x8]
8000a6dc:	72 39       	ld.w	r9,r9[0xc]
8000a6de:	93 28       	st.w	r9[0x8],r8
8000a6e0:	91 39       	st.w	r8[0xc],r9
8000a6e2:	6e 28       	ld.w	r8,r7[0x8]
8000a6e4:	6e 39       	ld.w	r9,r7[0xc]
8000a6e6:	c0 78       	rjmp	8000a6f4 <_realloc_r+0x184>
8000a6e8:	f8 00 00 03 	add	r3,r12,r0
8000a6ec:	0c 33       	cp.w	r3,r6
8000a6ee:	c3 35       	brlt	8000a754 <_realloc_r+0x1e4>
8000a6f0:	6e 39       	ld.w	r9,r7[0xc]
8000a6f2:	6e 28       	ld.w	r8,r7[0x8]
8000a6f4:	93 28       	st.w	r9[0x8],r8
8000a6f6:	91 39       	st.w	r8[0xc],r9
8000a6f8:	e0 ca 00 04 	sub	r10,r0,4
8000a6fc:	ee cc ff f8 	sub	r12,r7,-8
8000a700:	e0 4a 00 24 	cp.w	r10,36
8000a704:	e0 8b 00 24 	brhi	8000a74c <_realloc_r+0x1dc>
8000a708:	59 3a       	cp.w	r10,19
8000a70a:	e0 88 00 1a 	brls	8000a73e <_realloc_r+0x1ce>
8000a70e:	09 08       	ld.w	r8,r4++
8000a710:	99 08       	st.w	r12[0x0],r8
8000a712:	09 08       	ld.w	r8,r4++
8000a714:	8f 38       	st.w	r7[0xc],r8
8000a716:	ee cc ff f0 	sub	r12,r7,-16
8000a71a:	59 ba       	cp.w	r10,27
8000a71c:	e0 88 00 11 	brls	8000a73e <_realloc_r+0x1ce>
8000a720:	09 08       	ld.w	r8,r4++
8000a722:	99 08       	st.w	r12[0x0],r8
8000a724:	09 08       	ld.w	r8,r4++
8000a726:	8f 58       	st.w	r7[0x14],r8
8000a728:	ee cc ff e8 	sub	r12,r7,-24
8000a72c:	e0 4a 00 24 	cp.w	r10,36
8000a730:	c0 71       	brne	8000a73e <_realloc_r+0x1ce>
8000a732:	09 08       	ld.w	r8,r4++
8000a734:	99 08       	st.w	r12[0x0],r8
8000a736:	ee cc ff e0 	sub	r12,r7,-32
8000a73a:	09 08       	ld.w	r8,r4++
8000a73c:	8f 78       	st.w	r7[0x1c],r8
8000a73e:	09 08       	ld.w	r8,r4++
8000a740:	18 a8       	st.w	r12++,r8
8000a742:	68 08       	ld.w	r8,r4[0x0]
8000a744:	99 08       	st.w	r12[0x0],r8
8000a746:	68 18       	ld.w	r8,r4[0x4]
8000a748:	99 18       	st.w	r12[0x4],r8
8000a74a:	c4 78       	rjmp	8000a7d8 <_realloc_r+0x268>
8000a74c:	08 9b       	mov	r11,r4
8000a74e:	e0 a0 1d e8 	rcall	8000e31e <memmove>
8000a752:	c4 38       	rjmp	8000a7d8 <_realloc_r+0x268>
8000a754:	04 9c       	mov	r12,r2
8000a756:	fe b0 fc 33 	rcall	80009fbc <_malloc_r>
8000a75a:	18 95       	mov	r5,r12
8000a75c:	c3 a0       	breq	8000a7d0 <_realloc_r+0x260>
8000a75e:	62 18       	ld.w	r8,r1[0x4]
8000a760:	f8 c9 00 08 	sub	r9,r12,8
8000a764:	a1 c8       	cbr	r8,0x0
8000a766:	e2 08 00 08 	add	r8,r1,r8
8000a76a:	10 39       	cp.w	r9,r8
8000a76c:	c0 71       	brne	8000a77a <_realloc_r+0x20a>
8000a76e:	72 13       	ld.w	r3,r9[0x4]
8000a770:	02 97       	mov	r7,r1
8000a772:	e0 13 ff fc 	andl	r3,0xfffc
8000a776:	00 03       	add	r3,r0
8000a778:	c3 08       	rjmp	8000a7d8 <_realloc_r+0x268>
8000a77a:	e0 ca 00 04 	sub	r10,r0,4
8000a77e:	e0 4a 00 24 	cp.w	r10,36
8000a782:	e0 8b 00 20 	brhi	8000a7c2 <_realloc_r+0x252>
8000a786:	08 99       	mov	r9,r4
8000a788:	18 98       	mov	r8,r12
8000a78a:	59 3a       	cp.w	r10,19
8000a78c:	e0 88 00 14 	brls	8000a7b4 <_realloc_r+0x244>
8000a790:	13 0b       	ld.w	r11,r9++
8000a792:	10 ab       	st.w	r8++,r11
8000a794:	13 0b       	ld.w	r11,r9++
8000a796:	10 ab       	st.w	r8++,r11
8000a798:	59 ba       	cp.w	r10,27
8000a79a:	e0 88 00 0d 	brls	8000a7b4 <_realloc_r+0x244>
8000a79e:	13 0b       	ld.w	r11,r9++
8000a7a0:	10 ab       	st.w	r8++,r11
8000a7a2:	13 0b       	ld.w	r11,r9++
8000a7a4:	10 ab       	st.w	r8++,r11
8000a7a6:	e0 4a 00 24 	cp.w	r10,36
8000a7aa:	c0 51       	brne	8000a7b4 <_realloc_r+0x244>
8000a7ac:	13 0a       	ld.w	r10,r9++
8000a7ae:	10 aa       	st.w	r8++,r10
8000a7b0:	13 0a       	ld.w	r10,r9++
8000a7b2:	10 aa       	st.w	r8++,r10
8000a7b4:	13 0a       	ld.w	r10,r9++
8000a7b6:	10 aa       	st.w	r8++,r10
8000a7b8:	72 0a       	ld.w	r10,r9[0x0]
8000a7ba:	91 0a       	st.w	r8[0x0],r10
8000a7bc:	72 19       	ld.w	r9,r9[0x4]
8000a7be:	91 19       	st.w	r8[0x4],r9
8000a7c0:	c0 48       	rjmp	8000a7c8 <_realloc_r+0x258>
8000a7c2:	08 9b       	mov	r11,r4
8000a7c4:	e0 a0 1d ad 	rcall	8000e31e <memmove>
8000a7c8:	08 9b       	mov	r11,r4
8000a7ca:	04 9c       	mov	r12,r2
8000a7cc:	e0 a0 1b 06 	rcall	8000ddd8 <_free_r>
8000a7d0:	04 9c       	mov	r12,r2
8000a7d2:	c2 a8       	rjmp	8000a826 <_realloc_r+0x2b6>
8000a7d4:	00 93       	mov	r3,r0
8000a7d6:	02 97       	mov	r7,r1
8000a7d8:	e6 06 01 09 	sub	r9,r3,r6
8000a7dc:	6e 18       	ld.w	r8,r7[0x4]
8000a7de:	58 f9       	cp.w	r9,15
8000a7e0:	e0 88 00 16 	brls	8000a80c <_realloc_r+0x29c>
8000a7e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a7e8:	ed e8 10 08 	or	r8,r6,r8
8000a7ec:	8f 18       	st.w	r7[0x4],r8
8000a7ee:	12 98       	mov	r8,r9
8000a7f0:	a1 a8       	sbr	r8,0x0
8000a7f2:	ee 06 00 0b 	add	r11,r7,r6
8000a7f6:	f6 09 00 09 	add	r9,r11,r9
8000a7fa:	97 18       	st.w	r11[0x4],r8
8000a7fc:	72 18       	ld.w	r8,r9[0x4]
8000a7fe:	a1 a8       	sbr	r8,0x0
8000a800:	2f 8b       	sub	r11,-8
8000a802:	93 18       	st.w	r9[0x4],r8
8000a804:	04 9c       	mov	r12,r2
8000a806:	e0 a0 1a e9 	rcall	8000ddd8 <_free_r>
8000a80a:	c0 b8       	rjmp	8000a820 <_realloc_r+0x2b0>
8000a80c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a810:	e7 e8 10 08 	or	r8,r3,r8
8000a814:	8f 18       	st.w	r7[0x4],r8
8000a816:	ee 03 00 03 	add	r3,r7,r3
8000a81a:	66 18       	ld.w	r8,r3[0x4]
8000a81c:	a1 a8       	sbr	r8,0x0
8000a81e:	87 18       	st.w	r3[0x4],r8
8000a820:	04 9c       	mov	r12,r2
8000a822:	ee c5 ff f8 	sub	r5,r7,-8
8000a826:	fe b0 f1 1d 	rcall	80008a60 <__malloc_unlock>
8000a82a:	0a 9c       	mov	r12,r5
8000a82c:	2f fd       	sub	sp,-4
8000a82e:	d8 32       	popm	r0-r7,pc

8000a830 <_sbrk_r>:
8000a830:	d4 21       	pushm	r4-r7,lr
8000a832:	30 08       	mov	r8,0
8000a834:	18 97       	mov	r7,r12
8000a836:	e0 66 46 20 	mov	r6,17952
8000a83a:	16 9c       	mov	r12,r11
8000a83c:	8d 08       	st.w	r6[0x0],r8
8000a83e:	c1 1d       	rcall	8000aa60 <_sbrk>
8000a840:	5b fc       	cp.w	r12,-1
8000a842:	c0 51       	brne	8000a84c <_sbrk_r+0x1c>
8000a844:	6c 08       	ld.w	r8,r6[0x0]
8000a846:	58 08       	cp.w	r8,0
8000a848:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a84c:	d8 22       	popm	r4-r7,pc
8000a84e:	d7 03       	nop

8000a850 <sprintf>:
8000a850:	d4 01       	pushm	lr
8000a852:	21 7d       	sub	sp,92
8000a854:	e0 68 ff ff 	mov	r8,65535
8000a858:	ea 18 7f ff 	orh	r8,0x7fff
8000a85c:	50 58       	stdsp	sp[0x14],r8
8000a85e:	50 28       	stdsp	sp[0x8],r8
8000a860:	e0 68 02 08 	mov	r8,520
8000a864:	ba 68       	st.h	sp[0xc],r8
8000a866:	3f f8       	mov	r8,-1
8000a868:	ba 78       	st.h	sp[0xe],r8
8000a86a:	e0 68 0a 38 	mov	r8,2616
8000a86e:	50 4c       	stdsp	sp[0x10],r12
8000a870:	16 9a       	mov	r10,r11
8000a872:	50 0c       	stdsp	sp[0x0],r12
8000a874:	fa c9 ff a0 	sub	r9,sp,-96
8000a878:	70 0c       	ld.w	r12,r8[0x0]
8000a87a:	1a 9b       	mov	r11,sp
8000a87c:	e0 a0 02 ac 	rcall	8000add4 <_vfprintf_r>
8000a880:	30 09       	mov	r9,0
8000a882:	40 08       	lddsp	r8,sp[0x0]
8000a884:	b0 89       	st.b	r8[0x0],r9
8000a886:	2e 9d       	sub	sp,-92
8000a888:	d8 02       	popm	pc
8000a88a:	d7 03       	nop

8000a88c <strcpy>:
8000a88c:	30 08       	mov	r8,0
8000a88e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a892:	f8 08 0b 09 	st.b	r12[r8],r9
8000a896:	2f f8       	sub	r8,-1
8000a898:	58 09       	cp.w	r9,0
8000a89a:	cf a1       	brne	8000a88e <strcpy+0x2>
8000a89c:	5e fc       	retal	r12

8000a89e <strlen>:
8000a89e:	30 09       	mov	r9,0
8000a8a0:	18 98       	mov	r8,r12
8000a8a2:	c0 28       	rjmp	8000a8a6 <strlen+0x8>
8000a8a4:	2f f8       	sub	r8,-1
8000a8a6:	11 8a       	ld.ub	r10,r8[0x0]
8000a8a8:	f2 0a 18 00 	cp.b	r10,r9
8000a8ac:	cf c1       	brne	8000a8a4 <strlen+0x6>
8000a8ae:	f0 0c 01 0c 	sub	r12,r8,r12
8000a8b2:	5e fc       	retal	r12

8000a8b4 <strncpy>:
8000a8b4:	30 08       	mov	r8,0
8000a8b6:	10 3a       	cp.w	r10,r8
8000a8b8:	5e 0c       	reteq	r12
8000a8ba:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a8be:	f8 08 0b 09 	st.b	r12[r8],r9
8000a8c2:	2f f8       	sub	r8,-1
8000a8c4:	58 09       	cp.w	r9,0
8000a8c6:	cf 81       	brne	8000a8b6 <strncpy+0x2>
8000a8c8:	10 3a       	cp.w	r10,r8
8000a8ca:	5e 0c       	reteq	r12
8000a8cc:	f8 08 0b 09 	st.b	r12[r8],r9
8000a8d0:	2f f8       	sub	r8,-1
8000a8d2:	cf bb       	rjmp	8000a8c8 <strncpy+0x14>

8000a8d4 <strtok>:
8000a8d4:	d4 21       	pushm	r4-r7,lr
8000a8d6:	20 1d       	sub	sp,4
8000a8d8:	e0 65 0a 38 	mov	r5,2616
8000a8dc:	18 97       	mov	r7,r12
8000a8de:	6a 04       	ld.w	r4,r5[0x0]
8000a8e0:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000a8e4:	58 06       	cp.w	r6,0
8000a8e6:	c3 51       	brne	8000a950 <strtok+0x7c>
8000a8e8:	50 0b       	stdsp	sp[0x0],r11
8000a8ea:	35 0c       	mov	r12,80
8000a8ec:	fe b0 fb 60 	rcall	80009fac <malloc>
8000a8f0:	6a 08       	ld.w	r8,r5[0x0]
8000a8f2:	e9 4c 00 e8 	st.w	r4[232],r12
8000a8f6:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a8fa:	93 26       	st.w	r9[0x8],r6
8000a8fc:	93 06       	st.w	r9[0x0],r6
8000a8fe:	93 16       	st.w	r9[0x4],r6
8000a900:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a904:	93 46       	st.w	r9[0x10],r6
8000a906:	93 36       	st.w	r9[0xc],r6
8000a908:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a90c:	93 66       	st.w	r9[0x18],r6
8000a90e:	93 56       	st.w	r9[0x14],r6
8000a910:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a914:	93 b6       	st.w	r9[0x2c],r6
8000a916:	93 a6       	st.w	r9[0x28],r6
8000a918:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a91c:	93 d6       	st.w	r9[0x34],r6
8000a91e:	93 c6       	st.w	r9[0x30],r6
8000a920:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a924:	93 f6       	st.w	r9[0x3c],r6
8000a926:	93 e6       	st.w	r9[0x38],r6
8000a928:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a92c:	f3 46 00 44 	st.w	r9[68],r6
8000a930:	f3 46 00 40 	st.w	r9[64],r6
8000a934:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a938:	f3 46 00 4c 	st.w	r9[76],r6
8000a93c:	f3 46 00 48 	st.w	r9[72],r6
8000a940:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a944:	f3 66 00 1c 	st.b	r9[28],r6
8000a948:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000a94c:	40 0b       	lddsp	r11,sp[0x0]
8000a94e:	91 96       	st.w	r8[0x24],r6
8000a950:	e0 68 0a 38 	mov	r8,2616
8000a954:	70 08       	ld.w	r8,r8[0x0]
8000a956:	0e 9c       	mov	r12,r7
8000a958:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000a95c:	30 19       	mov	r9,1
8000a95e:	c0 3c       	rcall	8000a964 <__strtok_r>
8000a960:	2f fd       	sub	sp,-4
8000a962:	d8 22       	popm	r4-r7,pc

8000a964 <__strtok_r>:
8000a964:	d4 21       	pushm	r4-r7,lr
8000a966:	58 0c       	cp.w	r12,0
8000a968:	c0 41       	brne	8000a970 <__strtok_r+0xc>
8000a96a:	74 0c       	ld.w	r12,r10[0x0]
8000a96c:	58 0c       	cp.w	r12,0
8000a96e:	c2 90       	breq	8000a9c0 <__strtok_r+0x5c>
8000a970:	18 98       	mov	r8,r12
8000a972:	16 97       	mov	r7,r11
8000a974:	11 3e       	ld.ub	lr,r8++
8000a976:	c0 a8       	rjmp	8000a98a <__strtok_r+0x26>
8000a978:	0c 3e       	cp.w	lr,r6
8000a97a:	c0 81       	brne	8000a98a <__strtok_r+0x26>
8000a97c:	58 09       	cp.w	r9,0
8000a97e:	c0 30       	breq	8000a984 <__strtok_r+0x20>
8000a980:	10 9c       	mov	r12,r8
8000a982:	cf 7b       	rjmp	8000a970 <__strtok_r+0xc>
8000a984:	95 08       	st.w	r10[0x0],r8
8000a986:	b8 89       	st.b	r12[0x0],r9
8000a988:	d8 22       	popm	r4-r7,pc
8000a98a:	0f 36       	ld.ub	r6,r7++
8000a98c:	58 06       	cp.w	r6,0
8000a98e:	cf 51       	brne	8000a978 <__strtok_r+0x14>
8000a990:	58 0e       	cp.w	lr,0
8000a992:	c0 51       	brne	8000a99c <__strtok_r+0x38>
8000a994:	95 0e       	st.w	r10[0x0],lr
8000a996:	1c 9c       	mov	r12,lr
8000a998:	d8 22       	popm	r4-r7,pc
8000a99a:	12 98       	mov	r8,r9
8000a99c:	10 99       	mov	r9,r8
8000a99e:	16 97       	mov	r7,r11
8000a9a0:	13 3e       	ld.ub	lr,r9++
8000a9a2:	0f 36       	ld.ub	r6,r7++
8000a9a4:	1c 36       	cp.w	r6,lr
8000a9a6:	c0 a1       	brne	8000a9ba <__strtok_r+0x56>
8000a9a8:	58 0e       	cp.w	lr,0
8000a9aa:	fc 09 17 00 	moveq	r9,lr
8000a9ae:	f9 bb 01 00 	movne	r11,0
8000a9b2:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000a9b6:	95 09       	st.w	r10[0x0],r9
8000a9b8:	d8 22       	popm	r4-r7,pc
8000a9ba:	58 06       	cp.w	r6,0
8000a9bc:	cf 31       	brne	8000a9a2 <__strtok_r+0x3e>
8000a9be:	ce eb       	rjmp	8000a99a <__strtok_r+0x36>
8000a9c0:	d8 22       	popm	r4-r7,pc
8000a9c2:	d7 03       	nop

8000a9c4 <_close>:
8000a9c4:	30 28       	mov	r8,2
8000a9c6:	d6 73       	breakpoint
8000a9c8:	3f fc       	mov	r12,-1
8000a9ca:	35 8b       	mov	r11,88
8000a9cc:	58 0c       	cp.w	r12,0
8000a9ce:	5e 4c       	retge	r12
8000a9d0:	e0 6a 46 20 	mov	r10,17952
8000a9d4:	95 0b       	st.w	r10[0x0],r11
8000a9d6:	5e fc       	retal	r12

8000a9d8 <_lseek>:
8000a9d8:	30 58       	mov	r8,5
8000a9da:	d6 73       	breakpoint
8000a9dc:	3f fc       	mov	r12,-1
8000a9de:	35 8b       	mov	r11,88
8000a9e0:	58 0c       	cp.w	r12,0
8000a9e2:	5e 4c       	retge	r12
8000a9e4:	e0 6a 46 20 	mov	r10,17952
8000a9e8:	95 0b       	st.w	r10[0x0],r11
8000a9ea:	5e fc       	retal	r12

8000a9ec <isatty>:
8000a9ec:	30 b8       	mov	r8,11
8000a9ee:	d6 73       	breakpoint
8000a9f0:	3f fc       	mov	r12,-1
8000a9f2:	35 8b       	mov	r11,88
8000a9f4:	58 0c       	cp.w	r12,0
8000a9f6:	5e 4c       	retge	r12
8000a9f8:	e0 6a 46 20 	mov	r10,17952
8000a9fc:	95 0b       	st.w	r10[0x0],r11
8000a9fe:	5e fc       	retal	r12

8000aa00 <_fstat_host>:
8000aa00:	30 98       	mov	r8,9
8000aa02:	d6 73       	breakpoint
8000aa04:	3f fc       	mov	r12,-1
8000aa06:	35 8b       	mov	r11,88
8000aa08:	58 0c       	cp.w	r12,0
8000aa0a:	5e 4c       	retge	r12
8000aa0c:	e0 6a 46 20 	mov	r10,17952
8000aa10:	95 0b       	st.w	r10[0x0],r11
8000aa12:	5e fc       	retal	r12

8000aa14 <_fstat>:
8000aa14:	d4 21       	pushm	r4-r7,lr
8000aa16:	21 0d       	sub	sp,64
8000aa18:	16 97       	mov	r7,r11
8000aa1a:	1a 9b       	mov	r11,sp
8000aa1c:	cf 2f       	rcall	8000aa00 <_fstat_host>
8000aa1e:	c0 34       	brge	8000aa24 <_fstat+0x10>
8000aa20:	3f fc       	mov	r12,-1
8000aa22:	c1 c8       	rjmp	8000aa5a <_fstat+0x46>
8000aa24:	40 08       	lddsp	r8,sp[0x0]
8000aa26:	ae 08       	st.h	r7[0x0],r8
8000aa28:	40 18       	lddsp	r8,sp[0x4]
8000aa2a:	ae 18       	st.h	r7[0x2],r8
8000aa2c:	40 28       	lddsp	r8,sp[0x8]
8000aa2e:	8f 18       	st.w	r7[0x4],r8
8000aa30:	40 38       	lddsp	r8,sp[0xc]
8000aa32:	ae 48       	st.h	r7[0x8],r8
8000aa34:	40 48       	lddsp	r8,sp[0x10]
8000aa36:	ae 58       	st.h	r7[0xa],r8
8000aa38:	40 58       	lddsp	r8,sp[0x14]
8000aa3a:	ae 68       	st.h	r7[0xc],r8
8000aa3c:	40 68       	lddsp	r8,sp[0x18]
8000aa3e:	ae 78       	st.h	r7[0xe],r8
8000aa40:	40 88       	lddsp	r8,sp[0x20]
8000aa42:	8f 48       	st.w	r7[0x10],r8
8000aa44:	40 a8       	lddsp	r8,sp[0x28]
8000aa46:	8f b8       	st.w	r7[0x2c],r8
8000aa48:	40 c8       	lddsp	r8,sp[0x30]
8000aa4a:	8f c8       	st.w	r7[0x30],r8
8000aa4c:	40 d8       	lddsp	r8,sp[0x34]
8000aa4e:	8f 58       	st.w	r7[0x14],r8
8000aa50:	40 e8       	lddsp	r8,sp[0x38]
8000aa52:	30 0c       	mov	r12,0
8000aa54:	8f 78       	st.w	r7[0x1c],r8
8000aa56:	40 f8       	lddsp	r8,sp[0x3c]
8000aa58:	8f 98       	st.w	r7[0x24],r8
8000aa5a:	2f 0d       	sub	sp,-64
8000aa5c:	d8 22       	popm	r4-r7,pc
8000aa5e:	d7 03       	nop

8000aa60 <_sbrk>:
8000aa60:	d4 01       	pushm	lr
8000aa62:	e0 68 12 c0 	mov	r8,4800
8000aa66:	70 09       	ld.w	r9,r8[0x0]
8000aa68:	58 09       	cp.w	r9,0
8000aa6a:	c0 41       	brne	8000aa72 <_sbrk+0x12>
8000aa6c:	e0 69 46 28 	mov	r9,17960
8000aa70:	91 09       	st.w	r8[0x0],r9
8000aa72:	e0 69 12 c0 	mov	r9,4800
8000aa76:	e0 7a 70 00 	mov	r10,94208
8000aa7a:	72 08       	ld.w	r8,r9[0x0]
8000aa7c:	f0 0c 00 0c 	add	r12,r8,r12
8000aa80:	14 3c       	cp.w	r12,r10
8000aa82:	e0 8b 00 04 	brhi	8000aa8a <_sbrk+0x2a>
8000aa86:	93 0c       	st.w	r9[0x0],r12
8000aa88:	c0 68       	rjmp	8000aa94 <_sbrk+0x34>
8000aa8a:	e0 a0 18 2b 	rcall	8000dae0 <__errno>
8000aa8e:	30 c8       	mov	r8,12
8000aa90:	99 08       	st.w	r12[0x0],r8
8000aa92:	3f f8       	mov	r8,-1
8000aa94:	10 9c       	mov	r12,r8
8000aa96:	d8 02       	popm	pc

8000aa98 <get_arg>:
8000aa98:	d4 31       	pushm	r0-r7,lr
8000aa9a:	20 8d       	sub	sp,32
8000aa9c:	fa c4 ff bc 	sub	r4,sp,-68
8000aaa0:	50 4b       	stdsp	sp[0x10],r11
8000aaa2:	68 2e       	ld.w	lr,r4[0x8]
8000aaa4:	50 58       	stdsp	sp[0x14],r8
8000aaa6:	12 96       	mov	r6,r9
8000aaa8:	7c 0b       	ld.w	r11,lr[0x0]
8000aaaa:	70 05       	ld.w	r5,r8[0x0]
8000aaac:	50 6e       	stdsp	sp[0x18],lr
8000aaae:	58 0b       	cp.w	r11,0
8000aab0:	f4 0b 17 00 	moveq	r11,r10
8000aab4:	68 03       	ld.w	r3,r4[0x0]
8000aab6:	68 11       	ld.w	r1,r4[0x4]
8000aab8:	40 49       	lddsp	r9,sp[0x10]
8000aaba:	30 08       	mov	r8,0
8000aabc:	c2 e9       	rjmp	8000ad18 <get_arg+0x280>
8000aabe:	2f fb       	sub	r11,-1
8000aac0:	32 5c       	mov	r12,37
8000aac2:	17 8a       	ld.ub	r10,r11[0x0]
8000aac4:	f8 0a 18 00 	cp.b	r10,r12
8000aac8:	5f 1e       	srne	lr
8000aaca:	f0 0a 18 00 	cp.b	r10,r8
8000aace:	5f 1c       	srne	r12
8000aad0:	fd ec 00 0c 	and	r12,lr,r12
8000aad4:	f0 0c 18 00 	cp.b	r12,r8
8000aad8:	cf 31       	brne	8000aabe <get_arg+0x26>
8000aada:	58 0a       	cp.w	r10,0
8000aadc:	e0 80 01 2b 	breq	8000ad32 <get_arg+0x29a>
8000aae0:	30 0c       	mov	r12,0
8000aae2:	3f fa       	mov	r10,-1
8000aae4:	18 90       	mov	r0,r12
8000aae6:	50 3a       	stdsp	sp[0xc],r10
8000aae8:	18 94       	mov	r4,r12
8000aaea:	18 92       	mov	r2,r12
8000aaec:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000aaf0:	16 97       	mov	r7,r11
8000aaf2:	50 7c       	stdsp	sp[0x1c],r12
8000aaf4:	4c ec       	lddpc	r12,8000ac2c <get_arg+0x194>
8000aaf6:	0f 3a       	ld.ub	r10,r7++
8000aaf8:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000aafc:	40 7c       	lddsp	r12,sp[0x1c]
8000aafe:	1c 0c       	add	r12,lr
8000ab00:	4c ce       	lddpc	lr,8000ac30 <get_arg+0x198>
8000ab02:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000ab06:	20 1e       	sub	lr,1
8000ab08:	50 0e       	stdsp	sp[0x0],lr
8000ab0a:	4c be       	lddpc	lr,8000ac34 <get_arg+0x19c>
8000ab0c:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000ab10:	50 7c       	stdsp	sp[0x1c],r12
8000ab12:	40 0c       	lddsp	r12,sp[0x0]
8000ab14:	58 7c       	cp.w	r12,7
8000ab16:	e0 8b 00 fa 	brhi	8000ad0a <get_arg+0x272>
8000ab1a:	4c 8e       	lddpc	lr,8000ac38 <get_arg+0x1a0>
8000ab1c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000ab20:	36 8b       	mov	r11,104
8000ab22:	f6 0a 18 00 	cp.b	r10,r11
8000ab26:	e0 80 00 f2 	breq	8000ad0a <get_arg+0x272>
8000ab2a:	37 1b       	mov	r11,113
8000ab2c:	f6 0a 18 00 	cp.b	r10,r11
8000ab30:	c0 70       	breq	8000ab3e <get_arg+0xa6>
8000ab32:	34 cb       	mov	r11,76
8000ab34:	f6 0a 18 00 	cp.b	r10,r11
8000ab38:	c0 51       	brne	8000ab42 <get_arg+0xaa>
8000ab3a:	a3 b4       	sbr	r4,0x3
8000ab3c:	ce 78       	rjmp	8000ad0a <get_arg+0x272>
8000ab3e:	a5 b4       	sbr	r4,0x5
8000ab40:	ce 58       	rjmp	8000ad0a <get_arg+0x272>
8000ab42:	08 9a       	mov	r10,r4
8000ab44:	0e 9b       	mov	r11,r7
8000ab46:	a5 aa       	sbr	r10,0x4
8000ab48:	17 3c       	ld.ub	r12,r11++
8000ab4a:	a5 b4       	sbr	r4,0x5
8000ab4c:	36 ce       	mov	lr,108
8000ab4e:	fc 0c 18 00 	cp.b	r12,lr
8000ab52:	e0 80 00 dd 	breq	8000ad0c <get_arg+0x274>
8000ab56:	14 94       	mov	r4,r10
8000ab58:	cd 98       	rjmp	8000ad0a <get_arg+0x272>
8000ab5a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000ab5e:	36 7c       	mov	r12,103
8000ab60:	f8 0a 18 00 	cp.b	r10,r12
8000ab64:	e0 8b 00 27 	brhi	8000abb2 <get_arg+0x11a>
8000ab68:	36 5b       	mov	r11,101
8000ab6a:	f6 0a 18 00 	cp.b	r10,r11
8000ab6e:	c4 82       	brcc	8000abfe <get_arg+0x166>
8000ab70:	34 fb       	mov	r11,79
8000ab72:	f6 0a 18 00 	cp.b	r10,r11
8000ab76:	c4 80       	breq	8000ac06 <get_arg+0x16e>
8000ab78:	e0 8b 00 0c 	brhi	8000ab90 <get_arg+0xf8>
8000ab7c:	34 5b       	mov	r11,69
8000ab7e:	f6 0a 18 00 	cp.b	r10,r11
8000ab82:	c3 e0       	breq	8000abfe <get_arg+0x166>
8000ab84:	34 7b       	mov	r11,71
8000ab86:	f6 0a 18 00 	cp.b	r10,r11
8000ab8a:	c3 a0       	breq	8000abfe <get_arg+0x166>
8000ab8c:	34 4b       	mov	r11,68
8000ab8e:	c0 88       	rjmp	8000ab9e <get_arg+0x106>
8000ab90:	35 8b       	mov	r11,88
8000ab92:	f6 0a 18 00 	cp.b	r10,r11
8000ab96:	c2 c0       	breq	8000abee <get_arg+0x156>
8000ab98:	e0 8b 00 07 	brhi	8000aba6 <get_arg+0x10e>
8000ab9c:	35 5b       	mov	r11,85
8000ab9e:	f6 0a 18 00 	cp.b	r10,r11
8000aba2:	c3 51       	brne	8000ac0c <get_arg+0x174>
8000aba4:	c3 18       	rjmp	8000ac06 <get_arg+0x16e>
8000aba6:	36 3b       	mov	r11,99
8000aba8:	f6 0a 18 00 	cp.b	r10,r11
8000abac:	c2 f0       	breq	8000ac0a <get_arg+0x172>
8000abae:	36 4b       	mov	r11,100
8000abb0:	c0 e8       	rjmp	8000abcc <get_arg+0x134>
8000abb2:	37 0b       	mov	r11,112
8000abb4:	f6 0a 18 00 	cp.b	r10,r11
8000abb8:	c2 50       	breq	8000ac02 <get_arg+0x16a>
8000abba:	e0 8b 00 0d 	brhi	8000abd4 <get_arg+0x13c>
8000abbe:	36 eb       	mov	r11,110
8000abc0:	f6 0a 18 00 	cp.b	r10,r11
8000abc4:	c1 f0       	breq	8000ac02 <get_arg+0x16a>
8000abc6:	e0 8b 00 14 	brhi	8000abee <get_arg+0x156>
8000abca:	36 9b       	mov	r11,105
8000abcc:	f6 0a 18 00 	cp.b	r10,r11
8000abd0:	c1 e1       	brne	8000ac0c <get_arg+0x174>
8000abd2:	c0 e8       	rjmp	8000abee <get_arg+0x156>
8000abd4:	37 5b       	mov	r11,117
8000abd6:	f6 0a 18 00 	cp.b	r10,r11
8000abda:	c0 a0       	breq	8000abee <get_arg+0x156>
8000abdc:	37 8b       	mov	r11,120
8000abde:	f6 0a 18 00 	cp.b	r10,r11
8000abe2:	c0 60       	breq	8000abee <get_arg+0x156>
8000abe4:	37 3b       	mov	r11,115
8000abe6:	f6 0a 18 00 	cp.b	r10,r11
8000abea:	c1 11       	brne	8000ac0c <get_arg+0x174>
8000abec:	c0 b8       	rjmp	8000ac02 <get_arg+0x16a>
8000abee:	ed b4 00 04 	bld	r4,0x4
8000abf2:	c0 a0       	breq	8000ac06 <get_arg+0x16e>
8000abf4:	ed b4 00 05 	bld	r4,0x5
8000abf8:	c0 91       	brne	8000ac0a <get_arg+0x172>
8000abfa:	30 20       	mov	r0,2
8000abfc:	c0 88       	rjmp	8000ac0c <get_arg+0x174>
8000abfe:	30 40       	mov	r0,4
8000ac00:	c0 68       	rjmp	8000ac0c <get_arg+0x174>
8000ac02:	30 30       	mov	r0,3
8000ac04:	c0 48       	rjmp	8000ac0c <get_arg+0x174>
8000ac06:	30 10       	mov	r0,1
8000ac08:	c0 28       	rjmp	8000ac0c <get_arg+0x174>
8000ac0a:	30 00       	mov	r0,0
8000ac0c:	40 3b       	lddsp	r11,sp[0xc]
8000ac0e:	5b fb       	cp.w	r11,-1
8000ac10:	c0 40       	breq	8000ac18 <get_arg+0x180>
8000ac12:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000ac16:	c7 a8       	rjmp	8000ad0a <get_arg+0x272>
8000ac18:	58 60       	cp.w	r0,6
8000ac1a:	e0 8b 00 78 	brhi	8000ad0a <get_arg+0x272>
8000ac1e:	6c 0a       	ld.w	r10,r6[0x0]
8000ac20:	ea cc ff ff 	sub	r12,r5,-1
8000ac24:	48 6e       	lddpc	lr,8000ac3c <get_arg+0x1a4>
8000ac26:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000ac2a:	d7 03       	nop
8000ac2c:	80 01       	ld.sh	r1,r0[0x0]
8000ac2e:	8f c0       	st.w	r7[0x30],r0
8000ac30:	80 01       	ld.sh	r1,r0[0x0]
8000ac32:	8e f8       	ld.uh	r8,r7[0xe]
8000ac34:	80 01       	ld.sh	r1,r0[0x0]
8000ac36:	8e 8c       	ld.uh	r12,r7[0x0]
8000ac38:	80 01       	ld.sh	r1,r0[0x0]
8000ac3a:	8c ec       	ld.uh	r12,r6[0xc]
8000ac3c:	80 01       	ld.sh	r1,r0[0x0]
8000ac3e:	8d 0c       	st.w	r6[0x0],r12
8000ac40:	f4 cb ff f8 	sub	r11,r10,-8
8000ac44:	8d 0b       	st.w	r6[0x0],r11
8000ac46:	f4 ea 00 00 	ld.d	r10,r10[0]
8000ac4a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000ac4e:	c0 f8       	rjmp	8000ac6c <get_arg+0x1d4>
8000ac50:	f4 cb ff fc 	sub	r11,r10,-4
8000ac54:	8d 0b       	st.w	r6[0x0],r11
8000ac56:	74 0a       	ld.w	r10,r10[0x0]
8000ac58:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000ac5c:	c0 88       	rjmp	8000ac6c <get_arg+0x1d4>
8000ac5e:	f4 cb ff f8 	sub	r11,r10,-8
8000ac62:	8d 0b       	st.w	r6[0x0],r11
8000ac64:	f4 ea 00 00 	ld.d	r10,r10[0]
8000ac68:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000ac6c:	0e 9b       	mov	r11,r7
8000ac6e:	18 95       	mov	r5,r12
8000ac70:	c4 e8       	rjmp	8000ad0c <get_arg+0x274>
8000ac72:	62 0a       	ld.w	r10,r1[0x0]
8000ac74:	5b fa       	cp.w	r10,-1
8000ac76:	c0 b1       	brne	8000ac8c <get_arg+0x1f4>
8000ac78:	50 19       	stdsp	sp[0x4],r9
8000ac7a:	50 28       	stdsp	sp[0x8],r8
8000ac7c:	e0 6a 00 80 	mov	r10,128
8000ac80:	30 0b       	mov	r11,0
8000ac82:	02 9c       	mov	r12,r1
8000ac84:	fe b0 fc 6f 	rcall	8000a562 <memset>
8000ac88:	40 28       	lddsp	r8,sp[0x8]
8000ac8a:	40 19       	lddsp	r9,sp[0x4]
8000ac8c:	e4 cc 00 01 	sub	r12,r2,1
8000ac90:	0e 9b       	mov	r11,r7
8000ac92:	50 3c       	stdsp	sp[0xc],r12
8000ac94:	f2 0c 0c 49 	max	r9,r9,r12
8000ac98:	c3 a8       	rjmp	8000ad0c <get_arg+0x274>
8000ac9a:	62 0a       	ld.w	r10,r1[0x0]
8000ac9c:	5b fa       	cp.w	r10,-1
8000ac9e:	c0 b1       	brne	8000acb4 <get_arg+0x21c>
8000aca0:	50 19       	stdsp	sp[0x4],r9
8000aca2:	50 28       	stdsp	sp[0x8],r8
8000aca4:	e0 6a 00 80 	mov	r10,128
8000aca8:	30 0b       	mov	r11,0
8000acaa:	02 9c       	mov	r12,r1
8000acac:	fe b0 fc 5b 	rcall	8000a562 <memset>
8000acb0:	40 28       	lddsp	r8,sp[0x8]
8000acb2:	40 19       	lddsp	r9,sp[0x4]
8000acb4:	20 12       	sub	r2,1
8000acb6:	30 0a       	mov	r10,0
8000acb8:	0e 9b       	mov	r11,r7
8000acba:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000acbe:	f2 02 0c 49 	max	r9,r9,r2
8000acc2:	c2 58       	rjmp	8000ad0c <get_arg+0x274>
8000acc4:	16 97       	mov	r7,r11
8000acc6:	6c 0a       	ld.w	r10,r6[0x0]
8000acc8:	f4 cb ff fc 	sub	r11,r10,-4
8000accc:	8d 0b       	st.w	r6[0x0],r11
8000acce:	74 0a       	ld.w	r10,r10[0x0]
8000acd0:	0e 9b       	mov	r11,r7
8000acd2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000acd6:	2f f5       	sub	r5,-1
8000acd8:	c1 a8       	rjmp	8000ad0c <get_arg+0x274>
8000acda:	f4 c2 00 30 	sub	r2,r10,48
8000acde:	c0 68       	rjmp	8000acea <get_arg+0x252>
8000ace0:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000ace4:	2f f7       	sub	r7,-1
8000ace6:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000acea:	0f 8a       	ld.ub	r10,r7[0x0]
8000acec:	58 0a       	cp.w	r10,0
8000acee:	c0 e0       	breq	8000ad0a <get_arg+0x272>
8000acf0:	23 0a       	sub	r10,48
8000acf2:	58 9a       	cp.w	r10,9
8000acf4:	fe 98 ff f6 	brls	8000ace0 <get_arg+0x248>
8000acf8:	c0 98       	rjmp	8000ad0a <get_arg+0x272>
8000acfa:	2f f7       	sub	r7,-1
8000acfc:	0f 8a       	ld.ub	r10,r7[0x0]
8000acfe:	58 0a       	cp.w	r10,0
8000ad00:	c0 50       	breq	8000ad0a <get_arg+0x272>
8000ad02:	23 0a       	sub	r10,48
8000ad04:	58 9a       	cp.w	r10,9
8000ad06:	fe 98 ff fa 	brls	8000acfa <get_arg+0x262>
8000ad0a:	0e 9b       	mov	r11,r7
8000ad0c:	40 7c       	lddsp	r12,sp[0x1c]
8000ad0e:	30 ba       	mov	r10,11
8000ad10:	f4 0c 18 00 	cp.b	r12,r10
8000ad14:	fe 91 fe ec 	brne	8000aaec <get_arg+0x54>
8000ad18:	40 42       	lddsp	r2,sp[0x10]
8000ad1a:	17 8c       	ld.ub	r12,r11[0x0]
8000ad1c:	0a 32       	cp.w	r2,r5
8000ad1e:	5f 4a       	srge	r10
8000ad20:	f0 0c 18 00 	cp.b	r12,r8
8000ad24:	5f 1c       	srne	r12
8000ad26:	f9 ea 00 0a 	and	r10,r12,r10
8000ad2a:	f0 0a 18 00 	cp.b	r10,r8
8000ad2e:	fe 91 fe c9 	brne	8000aac0 <get_arg+0x28>
8000ad32:	30 08       	mov	r8,0
8000ad34:	40 4e       	lddsp	lr,sp[0x10]
8000ad36:	17 8a       	ld.ub	r10,r11[0x0]
8000ad38:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000ad3c:	f0 0a 18 00 	cp.b	r10,r8
8000ad40:	fc 09 17 10 	movne	r9,lr
8000ad44:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000ad48:	06 9e       	mov	lr,r3
8000ad4a:	c2 a8       	rjmp	8000ad9e <get_arg+0x306>
8000ad4c:	62 0a       	ld.w	r10,r1[0x0]
8000ad4e:	58 3a       	cp.w	r10,3
8000ad50:	c1 e0       	breq	8000ad8c <get_arg+0x2f4>
8000ad52:	e0 89 00 07 	brgt	8000ad60 <get_arg+0x2c8>
8000ad56:	58 1a       	cp.w	r10,1
8000ad58:	c1 a0       	breq	8000ad8c <get_arg+0x2f4>
8000ad5a:	58 2a       	cp.w	r10,2
8000ad5c:	c1 81       	brne	8000ad8c <get_arg+0x2f4>
8000ad5e:	c0 58       	rjmp	8000ad68 <get_arg+0x2d0>
8000ad60:	58 5a       	cp.w	r10,5
8000ad62:	c0 c0       	breq	8000ad7a <get_arg+0x2e2>
8000ad64:	c0 b5       	brlt	8000ad7a <get_arg+0x2e2>
8000ad66:	c1 38       	rjmp	8000ad8c <get_arg+0x2f4>
8000ad68:	6c 0a       	ld.w	r10,r6[0x0]
8000ad6a:	f4 cc ff f8 	sub	r12,r10,-8
8000ad6e:	8d 0c       	st.w	r6[0x0],r12
8000ad70:	f4 e2 00 00 	ld.d	r2,r10[0]
8000ad74:	f0 e3 00 00 	st.d	r8[0],r2
8000ad78:	c1 08       	rjmp	8000ad98 <get_arg+0x300>
8000ad7a:	6c 0a       	ld.w	r10,r6[0x0]
8000ad7c:	f4 cc ff f8 	sub	r12,r10,-8
8000ad80:	8d 0c       	st.w	r6[0x0],r12
8000ad82:	f4 e2 00 00 	ld.d	r2,r10[0]
8000ad86:	f0 e3 00 00 	st.d	r8[0],r2
8000ad8a:	c0 78       	rjmp	8000ad98 <get_arg+0x300>
8000ad8c:	6c 0a       	ld.w	r10,r6[0x0]
8000ad8e:	f4 cc ff fc 	sub	r12,r10,-4
8000ad92:	8d 0c       	st.w	r6[0x0],r12
8000ad94:	74 0a       	ld.w	r10,r10[0x0]
8000ad96:	91 0a       	st.w	r8[0x0],r10
8000ad98:	2f f5       	sub	r5,-1
8000ad9a:	2f 88       	sub	r8,-8
8000ad9c:	2f c1       	sub	r1,-4
8000ad9e:	12 35       	cp.w	r5,r9
8000ada0:	fe 9a ff d6 	brle	8000ad4c <get_arg+0x2b4>
8000ada4:	1c 93       	mov	r3,lr
8000ada6:	40 52       	lddsp	r2,sp[0x14]
8000ada8:	40 6e       	lddsp	lr,sp[0x18]
8000adaa:	85 05       	st.w	r2[0x0],r5
8000adac:	9d 0b       	st.w	lr[0x0],r11
8000adae:	40 4b       	lddsp	r11,sp[0x10]
8000adb0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000adb4:	2f 8d       	sub	sp,-32
8000adb6:	d8 32       	popm	r0-r7,pc

8000adb8 <__sprint_r>:
8000adb8:	d4 21       	pushm	r4-r7,lr
8000adba:	14 97       	mov	r7,r10
8000adbc:	74 28       	ld.w	r8,r10[0x8]
8000adbe:	58 08       	cp.w	r8,0
8000adc0:	c0 41       	brne	8000adc8 <__sprint_r+0x10>
8000adc2:	95 18       	st.w	r10[0x4],r8
8000adc4:	10 9c       	mov	r12,r8
8000adc6:	d8 22       	popm	r4-r7,pc
8000adc8:	e0 a0 18 ce 	rcall	8000df64 <__sfvwrite_r>
8000adcc:	30 08       	mov	r8,0
8000adce:	8f 18       	st.w	r7[0x4],r8
8000add0:	8f 28       	st.w	r7[0x8],r8
8000add2:	d8 22       	popm	r4-r7,pc

8000add4 <_vfprintf_r>:
8000add4:	d4 31       	pushm	r0-r7,lr
8000add6:	fa cd 06 bc 	sub	sp,sp,1724
8000adda:	51 09       	stdsp	sp[0x40],r9
8000addc:	16 91       	mov	r1,r11
8000adde:	14 97       	mov	r7,r10
8000ade0:	18 95       	mov	r5,r12
8000ade2:	e0 a0 1a 31 	rcall	8000e244 <_localeconv_r>
8000ade6:	78 0c       	ld.w	r12,r12[0x0]
8000ade8:	50 cc       	stdsp	sp[0x30],r12
8000adea:	58 05       	cp.w	r5,0
8000adec:	c0 70       	breq	8000adfa <_vfprintf_r+0x26>
8000adee:	6a 68       	ld.w	r8,r5[0x18]
8000adf0:	58 08       	cp.w	r8,0
8000adf2:	c0 41       	brne	8000adfa <_vfprintf_r+0x26>
8000adf4:	0a 9c       	mov	r12,r5
8000adf6:	e0 a0 17 57 	rcall	8000dca4 <__sinit>
8000adfa:	4d 08       	lddpc	r8,8000af38 <_vfprintf_r+0x164>
8000adfc:	10 31       	cp.w	r1,r8
8000adfe:	c0 31       	brne	8000ae04 <_vfprintf_r+0x30>
8000ae00:	6a 01       	ld.w	r1,r5[0x0]
8000ae02:	c0 a8       	rjmp	8000ae16 <_vfprintf_r+0x42>
8000ae04:	4c e8       	lddpc	r8,8000af3c <_vfprintf_r+0x168>
8000ae06:	10 31       	cp.w	r1,r8
8000ae08:	c0 31       	brne	8000ae0e <_vfprintf_r+0x3a>
8000ae0a:	6a 11       	ld.w	r1,r5[0x4]
8000ae0c:	c0 58       	rjmp	8000ae16 <_vfprintf_r+0x42>
8000ae0e:	4c d8       	lddpc	r8,8000af40 <_vfprintf_r+0x16c>
8000ae10:	10 31       	cp.w	r1,r8
8000ae12:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000ae16:	82 68       	ld.sh	r8,r1[0xc]
8000ae18:	ed b8 00 03 	bld	r8,0x3
8000ae1c:	c0 41       	brne	8000ae24 <_vfprintf_r+0x50>
8000ae1e:	62 48       	ld.w	r8,r1[0x10]
8000ae20:	58 08       	cp.w	r8,0
8000ae22:	c0 71       	brne	8000ae30 <_vfprintf_r+0x5c>
8000ae24:	02 9b       	mov	r11,r1
8000ae26:	0a 9c       	mov	r12,r5
8000ae28:	e0 a0 0f 6c 	rcall	8000cd00 <__swsetup_r>
8000ae2c:	e0 81 0f 63 	brne	8000ccf2 <_vfprintf_r+0x1f1e>
8000ae30:	82 68       	ld.sh	r8,r1[0xc]
8000ae32:	10 99       	mov	r9,r8
8000ae34:	e2 19 00 1a 	andl	r9,0x1a,COH
8000ae38:	58 a9       	cp.w	r9,10
8000ae3a:	c3 c1       	brne	8000aeb2 <_vfprintf_r+0xde>
8000ae3c:	82 79       	ld.sh	r9,r1[0xe]
8000ae3e:	30 0a       	mov	r10,0
8000ae40:	f4 09 19 00 	cp.h	r9,r10
8000ae44:	c3 75       	brlt	8000aeb2 <_vfprintf_r+0xde>
8000ae46:	a1 d8       	cbr	r8,0x1
8000ae48:	fb 58 05 d0 	st.h	sp[1488],r8
8000ae4c:	62 88       	ld.w	r8,r1[0x20]
8000ae4e:	fb 48 05 e4 	st.w	sp[1508],r8
8000ae52:	62 a8       	ld.w	r8,r1[0x28]
8000ae54:	fb 48 05 ec 	st.w	sp[1516],r8
8000ae58:	fa c8 ff bc 	sub	r8,sp,-68
8000ae5c:	fb 48 05 d4 	st.w	sp[1492],r8
8000ae60:	fb 48 05 c4 	st.w	sp[1476],r8
8000ae64:	e0 68 04 00 	mov	r8,1024
8000ae68:	fb 48 05 d8 	st.w	sp[1496],r8
8000ae6c:	fb 48 05 cc 	st.w	sp[1484],r8
8000ae70:	30 08       	mov	r8,0
8000ae72:	fb 59 05 d2 	st.h	sp[1490],r9
8000ae76:	0e 9a       	mov	r10,r7
8000ae78:	41 09       	lddsp	r9,sp[0x40]
8000ae7a:	fa c7 fa 3c 	sub	r7,sp,-1476
8000ae7e:	fb 48 05 dc 	st.w	sp[1500],r8
8000ae82:	0a 9c       	mov	r12,r5
8000ae84:	0e 9b       	mov	r11,r7
8000ae86:	ca 7f       	rcall	8000add4 <_vfprintf_r>
8000ae88:	50 bc       	stdsp	sp[0x2c],r12
8000ae8a:	c0 95       	brlt	8000ae9c <_vfprintf_r+0xc8>
8000ae8c:	0e 9b       	mov	r11,r7
8000ae8e:	0a 9c       	mov	r12,r5
8000ae90:	e0 a0 16 2e 	rcall	8000daec <_fflush_r>
8000ae94:	40 be       	lddsp	lr,sp[0x2c]
8000ae96:	f9 be 01 ff 	movne	lr,-1
8000ae9a:	50 be       	stdsp	sp[0x2c],lr
8000ae9c:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000aea0:	ed b8 00 06 	bld	r8,0x6
8000aea4:	e0 81 0f 29 	brne	8000ccf6 <_vfprintf_r+0x1f22>
8000aea8:	82 68       	ld.sh	r8,r1[0xc]
8000aeaa:	a7 a8       	sbr	r8,0x6
8000aeac:	a2 68       	st.h	r1[0xc],r8
8000aeae:	e0 8f 0f 24 	bral	8000ccf6 <_vfprintf_r+0x1f22>
8000aeb2:	30 08       	mov	r8,0
8000aeb4:	fb 48 06 b4 	st.w	sp[1716],r8
8000aeb8:	fb 48 06 90 	st.w	sp[1680],r8
8000aebc:	fb 48 06 8c 	st.w	sp[1676],r8
8000aec0:	fb 48 06 b0 	st.w	sp[1712],r8
8000aec4:	30 08       	mov	r8,0
8000aec6:	30 09       	mov	r9,0
8000aec8:	50 a7       	stdsp	sp[0x28],r7
8000aeca:	50 78       	stdsp	sp[0x1c],r8
8000aecc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aed0:	3f f8       	mov	r8,-1
8000aed2:	50 59       	stdsp	sp[0x14],r9
8000aed4:	fb 43 06 88 	st.w	sp[1672],r3
8000aed8:	fb 48 05 44 	st.w	sp[1348],r8
8000aedc:	12 9c       	mov	r12,r9
8000aede:	50 69       	stdsp	sp[0x18],r9
8000aee0:	50 d9       	stdsp	sp[0x34],r9
8000aee2:	50 e9       	stdsp	sp[0x38],r9
8000aee4:	50 b9       	stdsp	sp[0x2c],r9
8000aee6:	12 97       	mov	r7,r9
8000aee8:	0a 94       	mov	r4,r5
8000aeea:	40 a2       	lddsp	r2,sp[0x28]
8000aeec:	32 5a       	mov	r10,37
8000aeee:	30 08       	mov	r8,0
8000aef0:	c0 28       	rjmp	8000aef4 <_vfprintf_r+0x120>
8000aef2:	2f f2       	sub	r2,-1
8000aef4:	05 89       	ld.ub	r9,r2[0x0]
8000aef6:	f0 09 18 00 	cp.b	r9,r8
8000aefa:	5f 1b       	srne	r11
8000aefc:	f4 09 18 00 	cp.b	r9,r10
8000af00:	5f 19       	srne	r9
8000af02:	f3 eb 00 0b 	and	r11,r9,r11
8000af06:	f0 0b 18 00 	cp.b	r11,r8
8000af0a:	cf 41       	brne	8000aef2 <_vfprintf_r+0x11e>
8000af0c:	40 ab       	lddsp	r11,sp[0x28]
8000af0e:	e4 0b 01 06 	sub	r6,r2,r11
8000af12:	c2 50       	breq	8000af5c <_vfprintf_r+0x188>
8000af14:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af18:	0c 08       	add	r8,r6
8000af1a:	87 0b       	st.w	r3[0x0],r11
8000af1c:	fb 48 06 90 	st.w	sp[1680],r8
8000af20:	87 16       	st.w	r3[0x4],r6
8000af22:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af26:	2f f8       	sub	r8,-1
8000af28:	fb 48 06 8c 	st.w	sp[1676],r8
8000af2c:	58 78       	cp.w	r8,7
8000af2e:	e0 89 00 0b 	brgt	8000af44 <_vfprintf_r+0x170>
8000af32:	2f 83       	sub	r3,-8
8000af34:	c1 18       	rjmp	8000af56 <_vfprintf_r+0x182>
8000af36:	d7 03       	nop
8000af38:	80 01       	ld.sh	r1,r0[0x0]
8000af3a:	90 d0       	ld.uh	r0,r8[0xa]
8000af3c:	80 01       	ld.sh	r1,r0[0x0]
8000af3e:	90 f0       	ld.uh	r0,r8[0xe]
8000af40:	80 01       	ld.sh	r1,r0[0x0]
8000af42:	91 10       	st.w	r8[0x4],r0
8000af44:	fa ca f9 78 	sub	r10,sp,-1672
8000af48:	02 9b       	mov	r11,r1
8000af4a:	08 9c       	mov	r12,r4
8000af4c:	c3 6f       	rcall	8000adb8 <__sprint_r>
8000af4e:	e0 81 0e ce 	brne	8000ccea <_vfprintf_r+0x1f16>
8000af52:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af56:	40 ba       	lddsp	r10,sp[0x2c]
8000af58:	0c 0a       	add	r10,r6
8000af5a:	50 ba       	stdsp	sp[0x2c],r10
8000af5c:	05 89       	ld.ub	r9,r2[0x0]
8000af5e:	30 08       	mov	r8,0
8000af60:	f0 09 18 00 	cp.b	r9,r8
8000af64:	e0 80 0e b2 	breq	8000ccc8 <_vfprintf_r+0x1ef4>
8000af68:	30 09       	mov	r9,0
8000af6a:	fb 68 06 bb 	st.b	sp[1723],r8
8000af6e:	0e 96       	mov	r6,r7
8000af70:	e4 c8 ff ff 	sub	r8,r2,-1
8000af74:	3f fe       	mov	lr,-1
8000af76:	50 93       	stdsp	sp[0x24],r3
8000af78:	50 41       	stdsp	sp[0x10],r1
8000af7a:	0e 93       	mov	r3,r7
8000af7c:	04 91       	mov	r1,r2
8000af7e:	50 89       	stdsp	sp[0x20],r9
8000af80:	50 a8       	stdsp	sp[0x28],r8
8000af82:	50 2e       	stdsp	sp[0x8],lr
8000af84:	50 39       	stdsp	sp[0xc],r9
8000af86:	12 95       	mov	r5,r9
8000af88:	12 90       	mov	r0,r9
8000af8a:	10 97       	mov	r7,r8
8000af8c:	08 92       	mov	r2,r4
8000af8e:	c0 78       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000af90:	3f fc       	mov	r12,-1
8000af92:	08 97       	mov	r7,r4
8000af94:	50 2c       	stdsp	sp[0x8],r12
8000af96:	c0 38       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000af98:	30 0b       	mov	r11,0
8000af9a:	50 3b       	stdsp	sp[0xc],r11
8000af9c:	0f 38       	ld.ub	r8,r7++
8000af9e:	c0 28       	rjmp	8000afa2 <_vfprintf_r+0x1ce>
8000afa0:	12 90       	mov	r0,r9
8000afa2:	f0 c9 00 20 	sub	r9,r8,32
8000afa6:	e0 49 00 58 	cp.w	r9,88
8000afaa:	e0 8b 0a 36 	brhi	8000c416 <_vfprintf_r+0x1642>
8000afae:	4d 9a       	lddpc	r10,8000b110 <_vfprintf_r+0x33c>
8000afb0:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000afb4:	50 a7       	stdsp	sp[0x28],r7
8000afb6:	50 80       	stdsp	sp[0x20],r0
8000afb8:	0c 97       	mov	r7,r6
8000afba:	04 94       	mov	r4,r2
8000afbc:	06 96       	mov	r6,r3
8000afbe:	02 92       	mov	r2,r1
8000afc0:	4d 59       	lddpc	r9,8000b114 <_vfprintf_r+0x340>
8000afc2:	40 93       	lddsp	r3,sp[0x24]
8000afc4:	10 90       	mov	r0,r8
8000afc6:	40 41       	lddsp	r1,sp[0x10]
8000afc8:	50 d9       	stdsp	sp[0x34],r9
8000afca:	e0 8f 08 95 	bral	8000c0f4 <_vfprintf_r+0x1320>
8000afce:	30 08       	mov	r8,0
8000afd0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000afd4:	f0 09 18 00 	cp.b	r9,r8
8000afd8:	ce 21       	brne	8000af9c <_vfprintf_r+0x1c8>
8000afda:	32 08       	mov	r8,32
8000afdc:	c6 e8       	rjmp	8000b0b8 <_vfprintf_r+0x2e4>
8000afde:	a1 a5       	sbr	r5,0x0
8000afe0:	cd eb       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000afe2:	0f 89       	ld.ub	r9,r7[0x0]
8000afe4:	f2 c8 00 30 	sub	r8,r9,48
8000afe8:	58 98       	cp.w	r8,9
8000afea:	e0 8b 00 1d 	brhi	8000b024 <_vfprintf_r+0x250>
8000afee:	ee c8 ff ff 	sub	r8,r7,-1
8000aff2:	30 0b       	mov	r11,0
8000aff4:	23 09       	sub	r9,48
8000aff6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000affa:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000affe:	11 39       	ld.ub	r9,r8++
8000b000:	f2 ca 00 30 	sub	r10,r9,48
8000b004:	58 9a       	cp.w	r10,9
8000b006:	fe 98 ff f7 	brls	8000aff4 <_vfprintf_r+0x220>
8000b00a:	e0 49 00 24 	cp.w	r9,36
8000b00e:	cc 51       	brne	8000af98 <_vfprintf_r+0x1c4>
8000b010:	e0 4b 00 20 	cp.w	r11,32
8000b014:	e0 89 0e 6a 	brgt	8000cce8 <_vfprintf_r+0x1f14>
8000b018:	20 1b       	sub	r11,1
8000b01a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b01e:	12 3b       	cp.w	r11,r9
8000b020:	c0 95       	brlt	8000b032 <_vfprintf_r+0x25e>
8000b022:	c1 08       	rjmp	8000b042 <_vfprintf_r+0x26e>
8000b024:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b028:	ec ca ff ff 	sub	r10,r6,-1
8000b02c:	12 36       	cp.w	r6,r9
8000b02e:	c1 f5       	brlt	8000b06c <_vfprintf_r+0x298>
8000b030:	c2 68       	rjmp	8000b07c <_vfprintf_r+0x2a8>
8000b032:	fa ce f9 44 	sub	lr,sp,-1724
8000b036:	10 97       	mov	r7,r8
8000b038:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b03c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b040:	c3 58       	rjmp	8000b0aa <_vfprintf_r+0x2d6>
8000b042:	10 97       	mov	r7,r8
8000b044:	fa c8 f9 50 	sub	r8,sp,-1712
8000b048:	1a d8       	st.w	--sp,r8
8000b04a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b04e:	1a d8       	st.w	--sp,r8
8000b050:	fa c8 fb b4 	sub	r8,sp,-1100
8000b054:	02 9a       	mov	r10,r1
8000b056:	1a d8       	st.w	--sp,r8
8000b058:	04 9c       	mov	r12,r2
8000b05a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b05e:	fa c9 ff b4 	sub	r9,sp,-76
8000b062:	fe b0 fd 1b 	rcall	8000aa98 <get_arg>
8000b066:	2f dd       	sub	sp,-12
8000b068:	78 00       	ld.w	r0,r12[0x0]
8000b06a:	c2 08       	rjmp	8000b0aa <_vfprintf_r+0x2d6>
8000b06c:	fa cc f9 44 	sub	r12,sp,-1724
8000b070:	14 96       	mov	r6,r10
8000b072:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b076:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b07a:	c1 88       	rjmp	8000b0aa <_vfprintf_r+0x2d6>
8000b07c:	41 08       	lddsp	r8,sp[0x40]
8000b07e:	59 f9       	cp.w	r9,31
8000b080:	e0 89 00 11 	brgt	8000b0a2 <_vfprintf_r+0x2ce>
8000b084:	f0 cb ff fc 	sub	r11,r8,-4
8000b088:	51 0b       	stdsp	sp[0x40],r11
8000b08a:	70 00       	ld.w	r0,r8[0x0]
8000b08c:	fa cb f9 44 	sub	r11,sp,-1724
8000b090:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b094:	f1 40 fd 88 	st.w	r8[-632],r0
8000b098:	2f f9       	sub	r9,-1
8000b09a:	14 96       	mov	r6,r10
8000b09c:	fb 49 06 b4 	st.w	sp[1716],r9
8000b0a0:	c0 58       	rjmp	8000b0aa <_vfprintf_r+0x2d6>
8000b0a2:	70 00       	ld.w	r0,r8[0x0]
8000b0a4:	14 96       	mov	r6,r10
8000b0a6:	2f c8       	sub	r8,-4
8000b0a8:	51 08       	stdsp	sp[0x40],r8
8000b0aa:	58 00       	cp.w	r0,0
8000b0ac:	fe 94 ff 78 	brge	8000af9c <_vfprintf_r+0x1c8>
8000b0b0:	5c 30       	neg	r0
8000b0b2:	a3 a5       	sbr	r5,0x2
8000b0b4:	c7 4b       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b0b6:	32 b8       	mov	r8,43
8000b0b8:	fb 68 06 bb 	st.b	sp[1723],r8
8000b0bc:	c7 0b       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b0be:	0f 38       	ld.ub	r8,r7++
8000b0c0:	e0 48 00 2a 	cp.w	r8,42
8000b0c4:	c0 30       	breq	8000b0ca <_vfprintf_r+0x2f6>
8000b0c6:	30 09       	mov	r9,0
8000b0c8:	c7 d8       	rjmp	8000b1c2 <_vfprintf_r+0x3ee>
8000b0ca:	0f 88       	ld.ub	r8,r7[0x0]
8000b0cc:	f0 c9 00 30 	sub	r9,r8,48
8000b0d0:	58 99       	cp.w	r9,9
8000b0d2:	e0 8b 00 23 	brhi	8000b118 <_vfprintf_r+0x344>
8000b0d6:	ee c4 ff ff 	sub	r4,r7,-1
8000b0da:	30 0b       	mov	r11,0
8000b0dc:	23 08       	sub	r8,48
8000b0de:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b0e2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b0e6:	09 38       	ld.ub	r8,r4++
8000b0e8:	f0 c9 00 30 	sub	r9,r8,48
8000b0ec:	58 99       	cp.w	r9,9
8000b0ee:	fe 98 ff f7 	brls	8000b0dc <_vfprintf_r+0x308>
8000b0f2:	e0 48 00 24 	cp.w	r8,36
8000b0f6:	fe 91 ff 51 	brne	8000af98 <_vfprintf_r+0x1c4>
8000b0fa:	e0 4b 00 20 	cp.w	r11,32
8000b0fe:	e0 89 0d f5 	brgt	8000cce8 <_vfprintf_r+0x1f14>
8000b102:	20 1b       	sub	r11,1
8000b104:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b108:	10 3b       	cp.w	r11,r8
8000b10a:	c0 e5       	brlt	8000b126 <_vfprintf_r+0x352>
8000b10c:	c1 58       	rjmp	8000b136 <_vfprintf_r+0x362>
8000b10e:	d7 03       	nop
8000b110:	80 01       	ld.sh	r1,r0[0x0]
8000b112:	8d 28       	st.w	r6[0x8],r8
8000b114:	80 01       	ld.sh	r1,r0[0x0]
8000b116:	8f 64       	st.w	r7[0x18],r4
8000b118:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b11c:	ec c9 ff ff 	sub	r9,r6,-1
8000b120:	14 36       	cp.w	r6,r10
8000b122:	c1 f5       	brlt	8000b160 <_vfprintf_r+0x38c>
8000b124:	c2 88       	rjmp	8000b174 <_vfprintf_r+0x3a0>
8000b126:	fa ca f9 44 	sub	r10,sp,-1724
8000b12a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b12e:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b132:	50 2b       	stdsp	sp[0x8],r11
8000b134:	c3 c8       	rjmp	8000b1ac <_vfprintf_r+0x3d8>
8000b136:	fa c8 f9 50 	sub	r8,sp,-1712
8000b13a:	1a d8       	st.w	--sp,r8
8000b13c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b140:	1a d8       	st.w	--sp,r8
8000b142:	fa c8 fb b4 	sub	r8,sp,-1100
8000b146:	02 9a       	mov	r10,r1
8000b148:	1a d8       	st.w	--sp,r8
8000b14a:	04 9c       	mov	r12,r2
8000b14c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b150:	fa c9 ff b4 	sub	r9,sp,-76
8000b154:	fe b0 fc a2 	rcall	8000aa98 <get_arg>
8000b158:	2f dd       	sub	sp,-12
8000b15a:	78 0c       	ld.w	r12,r12[0x0]
8000b15c:	50 2c       	stdsp	sp[0x8],r12
8000b15e:	c2 78       	rjmp	8000b1ac <_vfprintf_r+0x3d8>
8000b160:	12 96       	mov	r6,r9
8000b162:	0e 94       	mov	r4,r7
8000b164:	fa c9 f9 44 	sub	r9,sp,-1724
8000b168:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b16c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b170:	50 28       	stdsp	sp[0x8],r8
8000b172:	c1 d8       	rjmp	8000b1ac <_vfprintf_r+0x3d8>
8000b174:	41 08       	lddsp	r8,sp[0x40]
8000b176:	59 fa       	cp.w	r10,31
8000b178:	e0 89 00 14 	brgt	8000b1a0 <_vfprintf_r+0x3cc>
8000b17c:	f0 cb ff fc 	sub	r11,r8,-4
8000b180:	70 08       	ld.w	r8,r8[0x0]
8000b182:	51 0b       	stdsp	sp[0x40],r11
8000b184:	50 28       	stdsp	sp[0x8],r8
8000b186:	fa c6 f9 44 	sub	r6,sp,-1724
8000b18a:	40 2e       	lddsp	lr,sp[0x8]
8000b18c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b190:	f1 4e fd 88 	st.w	r8[-632],lr
8000b194:	2f fa       	sub	r10,-1
8000b196:	0e 94       	mov	r4,r7
8000b198:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b19c:	12 96       	mov	r6,r9
8000b19e:	c0 78       	rjmp	8000b1ac <_vfprintf_r+0x3d8>
8000b1a0:	70 0c       	ld.w	r12,r8[0x0]
8000b1a2:	0e 94       	mov	r4,r7
8000b1a4:	2f c8       	sub	r8,-4
8000b1a6:	50 2c       	stdsp	sp[0x8],r12
8000b1a8:	12 96       	mov	r6,r9
8000b1aa:	51 08       	stdsp	sp[0x40],r8
8000b1ac:	40 2b       	lddsp	r11,sp[0x8]
8000b1ae:	58 0b       	cp.w	r11,0
8000b1b0:	fe 95 fe f0 	brlt	8000af90 <_vfprintf_r+0x1bc>
8000b1b4:	08 97       	mov	r7,r4
8000b1b6:	cf 3a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b1b8:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b1bc:	0f 38       	ld.ub	r8,r7++
8000b1be:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b1c2:	f0 ca 00 30 	sub	r10,r8,48
8000b1c6:	58 9a       	cp.w	r10,9
8000b1c8:	fe 98 ff f8 	brls	8000b1b8 <_vfprintf_r+0x3e4>
8000b1cc:	3f fa       	mov	r10,-1
8000b1ce:	f2 0a 0c 49 	max	r9,r9,r10
8000b1d2:	50 29       	stdsp	sp[0x8],r9
8000b1d4:	ce 7a       	rjmp	8000afa2 <_vfprintf_r+0x1ce>
8000b1d6:	a7 b5       	sbr	r5,0x7
8000b1d8:	ce 2a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b1da:	30 09       	mov	r9,0
8000b1dc:	23 08       	sub	r8,48
8000b1de:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b1e2:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b1e6:	0f 38       	ld.ub	r8,r7++
8000b1e8:	f0 ca 00 30 	sub	r10,r8,48
8000b1ec:	58 9a       	cp.w	r10,9
8000b1ee:	fe 98 ff f7 	brls	8000b1dc <_vfprintf_r+0x408>
8000b1f2:	e0 48 00 24 	cp.w	r8,36
8000b1f6:	fe 91 fe d5 	brne	8000afa0 <_vfprintf_r+0x1cc>
8000b1fa:	e0 49 00 20 	cp.w	r9,32
8000b1fe:	e0 89 0d 75 	brgt	8000cce8 <_vfprintf_r+0x1f14>
8000b202:	f2 c3 00 01 	sub	r3,r9,1
8000b206:	30 19       	mov	r9,1
8000b208:	50 39       	stdsp	sp[0xc],r9
8000b20a:	cc 9a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b20c:	a3 b5       	sbr	r5,0x3
8000b20e:	cc 7a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b210:	a7 a5       	sbr	r5,0x6
8000b212:	cc 5a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b214:	0a 98       	mov	r8,r5
8000b216:	a5 b5       	sbr	r5,0x5
8000b218:	a5 a8       	sbr	r8,0x4
8000b21a:	0f 89       	ld.ub	r9,r7[0x0]
8000b21c:	36 ce       	mov	lr,108
8000b21e:	fc 09 18 00 	cp.b	r9,lr
8000b222:	f7 b7 00 ff 	subeq	r7,-1
8000b226:	f0 05 17 10 	movne	r5,r8
8000b22a:	cb 9a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b22c:	a5 b5       	sbr	r5,0x5
8000b22e:	cb 7a       	rjmp	8000af9c <_vfprintf_r+0x1c8>
8000b230:	50 a7       	stdsp	sp[0x28],r7
8000b232:	50 80       	stdsp	sp[0x20],r0
8000b234:	0c 97       	mov	r7,r6
8000b236:	10 90       	mov	r0,r8
8000b238:	06 96       	mov	r6,r3
8000b23a:	04 94       	mov	r4,r2
8000b23c:	40 93       	lddsp	r3,sp[0x24]
8000b23e:	02 92       	mov	r2,r1
8000b240:	0e 99       	mov	r9,r7
8000b242:	40 41       	lddsp	r1,sp[0x10]
8000b244:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b248:	40 3c       	lddsp	r12,sp[0xc]
8000b24a:	58 0c       	cp.w	r12,0
8000b24c:	c1 d0       	breq	8000b286 <_vfprintf_r+0x4b2>
8000b24e:	10 36       	cp.w	r6,r8
8000b250:	c0 64       	brge	8000b25c <_vfprintf_r+0x488>
8000b252:	fa cb f9 44 	sub	r11,sp,-1724
8000b256:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b25a:	c1 d8       	rjmp	8000b294 <_vfprintf_r+0x4c0>
8000b25c:	fa c8 f9 50 	sub	r8,sp,-1712
8000b260:	1a d8       	st.w	--sp,r8
8000b262:	fa c8 fa b8 	sub	r8,sp,-1352
8000b266:	1a d8       	st.w	--sp,r8
8000b268:	fa c8 fb b4 	sub	r8,sp,-1100
8000b26c:	1a d8       	st.w	--sp,r8
8000b26e:	fa c8 f9 40 	sub	r8,sp,-1728
8000b272:	fa c9 ff b4 	sub	r9,sp,-76
8000b276:	04 9a       	mov	r10,r2
8000b278:	0c 9b       	mov	r11,r6
8000b27a:	08 9c       	mov	r12,r4
8000b27c:	fe b0 fc 0e 	rcall	8000aa98 <get_arg>
8000b280:	2f dd       	sub	sp,-12
8000b282:	19 b8       	ld.ub	r8,r12[0x3]
8000b284:	c2 28       	rjmp	8000b2c8 <_vfprintf_r+0x4f4>
8000b286:	2f f7       	sub	r7,-1
8000b288:	10 39       	cp.w	r9,r8
8000b28a:	c0 84       	brge	8000b29a <_vfprintf_r+0x4c6>
8000b28c:	fa ca f9 44 	sub	r10,sp,-1724
8000b290:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b294:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b298:	c1 88       	rjmp	8000b2c8 <_vfprintf_r+0x4f4>
8000b29a:	41 09       	lddsp	r9,sp[0x40]
8000b29c:	59 f8       	cp.w	r8,31
8000b29e:	e0 89 00 12 	brgt	8000b2c2 <_vfprintf_r+0x4ee>
8000b2a2:	f2 ca ff fc 	sub	r10,r9,-4
8000b2a6:	51 0a       	stdsp	sp[0x40],r10
8000b2a8:	72 09       	ld.w	r9,r9[0x0]
8000b2aa:	fa c6 f9 44 	sub	r6,sp,-1724
8000b2ae:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b2b2:	2f f8       	sub	r8,-1
8000b2b4:	f5 49 fd 88 	st.w	r10[-632],r9
8000b2b8:	fb 48 06 b4 	st.w	sp[1716],r8
8000b2bc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b2c0:	c0 48       	rjmp	8000b2c8 <_vfprintf_r+0x4f4>
8000b2c2:	13 b8       	ld.ub	r8,r9[0x3]
8000b2c4:	2f c9       	sub	r9,-4
8000b2c6:	51 09       	stdsp	sp[0x40],r9
8000b2c8:	fb 68 06 60 	st.b	sp[1632],r8
8000b2cc:	30 0e       	mov	lr,0
8000b2ce:	30 08       	mov	r8,0
8000b2d0:	30 12       	mov	r2,1
8000b2d2:	fb 68 06 bb 	st.b	sp[1723],r8
8000b2d6:	50 2e       	stdsp	sp[0x8],lr
8000b2d8:	e0 8f 08 b1 	bral	8000c43a <_vfprintf_r+0x1666>
8000b2dc:	50 a7       	stdsp	sp[0x28],r7
8000b2de:	50 80       	stdsp	sp[0x20],r0
8000b2e0:	0c 97       	mov	r7,r6
8000b2e2:	04 94       	mov	r4,r2
8000b2e4:	06 96       	mov	r6,r3
8000b2e6:	02 92       	mov	r2,r1
8000b2e8:	40 93       	lddsp	r3,sp[0x24]
8000b2ea:	10 90       	mov	r0,r8
8000b2ec:	40 41       	lddsp	r1,sp[0x10]
8000b2ee:	a5 a5       	sbr	r5,0x4
8000b2f0:	c0 a8       	rjmp	8000b304 <_vfprintf_r+0x530>
8000b2f2:	50 a7       	stdsp	sp[0x28],r7
8000b2f4:	50 80       	stdsp	sp[0x20],r0
8000b2f6:	0c 97       	mov	r7,r6
8000b2f8:	04 94       	mov	r4,r2
8000b2fa:	06 96       	mov	r6,r3
8000b2fc:	02 92       	mov	r2,r1
8000b2fe:	40 93       	lddsp	r3,sp[0x24]
8000b300:	10 90       	mov	r0,r8
8000b302:	40 41       	lddsp	r1,sp[0x10]
8000b304:	ed b5 00 05 	bld	r5,0x5
8000b308:	c5 11       	brne	8000b3aa <_vfprintf_r+0x5d6>
8000b30a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b30e:	40 3c       	lddsp	r12,sp[0xc]
8000b310:	58 0c       	cp.w	r12,0
8000b312:	c1 e0       	breq	8000b34e <_vfprintf_r+0x57a>
8000b314:	10 36       	cp.w	r6,r8
8000b316:	c0 64       	brge	8000b322 <_vfprintf_r+0x54e>
8000b318:	fa cb f9 44 	sub	r11,sp,-1724
8000b31c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b320:	c2 08       	rjmp	8000b360 <_vfprintf_r+0x58c>
8000b322:	fa c8 f9 50 	sub	r8,sp,-1712
8000b326:	1a d8       	st.w	--sp,r8
8000b328:	fa c8 fa b8 	sub	r8,sp,-1352
8000b32c:	0c 9b       	mov	r11,r6
8000b32e:	1a d8       	st.w	--sp,r8
8000b330:	fa c8 fb b4 	sub	r8,sp,-1100
8000b334:	1a d8       	st.w	--sp,r8
8000b336:	fa c9 ff b4 	sub	r9,sp,-76
8000b33a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b33e:	04 9a       	mov	r10,r2
8000b340:	08 9c       	mov	r12,r4
8000b342:	fe b0 fb ab 	rcall	8000aa98 <get_arg>
8000b346:	2f dd       	sub	sp,-12
8000b348:	78 1b       	ld.w	r11,r12[0x4]
8000b34a:	78 09       	ld.w	r9,r12[0x0]
8000b34c:	c2 b8       	rjmp	8000b3a2 <_vfprintf_r+0x5ce>
8000b34e:	ee ca ff ff 	sub	r10,r7,-1
8000b352:	10 37       	cp.w	r7,r8
8000b354:	c0 b4       	brge	8000b36a <_vfprintf_r+0x596>
8000b356:	fa c9 f9 44 	sub	r9,sp,-1724
8000b35a:	14 97       	mov	r7,r10
8000b35c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b360:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b364:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b368:	c1 d8       	rjmp	8000b3a2 <_vfprintf_r+0x5ce>
8000b36a:	41 09       	lddsp	r9,sp[0x40]
8000b36c:	59 f8       	cp.w	r8,31
8000b36e:	e0 89 00 14 	brgt	8000b396 <_vfprintf_r+0x5c2>
8000b372:	f2 cb ff f8 	sub	r11,r9,-8
8000b376:	51 0b       	stdsp	sp[0x40],r11
8000b378:	fa c6 f9 44 	sub	r6,sp,-1724
8000b37c:	72 1b       	ld.w	r11,r9[0x4]
8000b37e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b382:	72 09       	ld.w	r9,r9[0x0]
8000b384:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b388:	f9 49 fd 88 	st.w	r12[-632],r9
8000b38c:	2f f8       	sub	r8,-1
8000b38e:	14 97       	mov	r7,r10
8000b390:	fb 48 06 b4 	st.w	sp[1716],r8
8000b394:	c0 78       	rjmp	8000b3a2 <_vfprintf_r+0x5ce>
8000b396:	f2 c8 ff f8 	sub	r8,r9,-8
8000b39a:	72 1b       	ld.w	r11,r9[0x4]
8000b39c:	14 97       	mov	r7,r10
8000b39e:	51 08       	stdsp	sp[0x40],r8
8000b3a0:	72 09       	ld.w	r9,r9[0x0]
8000b3a2:	16 98       	mov	r8,r11
8000b3a4:	fa e9 00 00 	st.d	sp[0],r8
8000b3a8:	ca e8       	rjmp	8000b504 <_vfprintf_r+0x730>
8000b3aa:	ed b5 00 04 	bld	r5,0x4
8000b3ae:	c1 71       	brne	8000b3dc <_vfprintf_r+0x608>
8000b3b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b3b4:	40 3e       	lddsp	lr,sp[0xc]
8000b3b6:	58 0e       	cp.w	lr,0
8000b3b8:	c0 80       	breq	8000b3c8 <_vfprintf_r+0x5f4>
8000b3ba:	10 36       	cp.w	r6,r8
8000b3bc:	c6 94       	brge	8000b48e <_vfprintf_r+0x6ba>
8000b3be:	fa cc f9 44 	sub	r12,sp,-1724
8000b3c2:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b3c6:	c8 28       	rjmp	8000b4ca <_vfprintf_r+0x6f6>
8000b3c8:	ee ca ff ff 	sub	r10,r7,-1
8000b3cc:	10 37       	cp.w	r7,r8
8000b3ce:	e0 84 00 81 	brge	8000b4d0 <_vfprintf_r+0x6fc>
8000b3d2:	fa cb f9 44 	sub	r11,sp,-1724
8000b3d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b3da:	c7 78       	rjmp	8000b4c8 <_vfprintf_r+0x6f4>
8000b3dc:	ed b5 00 06 	bld	r5,0x6
8000b3e0:	c4 b1       	brne	8000b476 <_vfprintf_r+0x6a2>
8000b3e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b3e6:	40 3c       	lddsp	r12,sp[0xc]
8000b3e8:	58 0c       	cp.w	r12,0
8000b3ea:	c1 d0       	breq	8000b424 <_vfprintf_r+0x650>
8000b3ec:	10 36       	cp.w	r6,r8
8000b3ee:	c0 64       	brge	8000b3fa <_vfprintf_r+0x626>
8000b3f0:	fa cb f9 44 	sub	r11,sp,-1724
8000b3f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b3f8:	c1 f8       	rjmp	8000b436 <_vfprintf_r+0x662>
8000b3fa:	fa c8 f9 50 	sub	r8,sp,-1712
8000b3fe:	1a d8       	st.w	--sp,r8
8000b400:	fa c8 fa b8 	sub	r8,sp,-1352
8000b404:	1a d8       	st.w	--sp,r8
8000b406:	fa c8 fb b4 	sub	r8,sp,-1100
8000b40a:	1a d8       	st.w	--sp,r8
8000b40c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b410:	fa c9 ff b4 	sub	r9,sp,-76
8000b414:	04 9a       	mov	r10,r2
8000b416:	0c 9b       	mov	r11,r6
8000b418:	08 9c       	mov	r12,r4
8000b41a:	fe b0 fb 3f 	rcall	8000aa98 <get_arg>
8000b41e:	2f dd       	sub	sp,-12
8000b420:	98 18       	ld.sh	r8,r12[0x2]
8000b422:	c2 68       	rjmp	8000b46e <_vfprintf_r+0x69a>
8000b424:	ee ca ff ff 	sub	r10,r7,-1
8000b428:	10 37       	cp.w	r7,r8
8000b42a:	c0 94       	brge	8000b43c <_vfprintf_r+0x668>
8000b42c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b430:	14 97       	mov	r7,r10
8000b432:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b436:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b43a:	c1 a8       	rjmp	8000b46e <_vfprintf_r+0x69a>
8000b43c:	41 09       	lddsp	r9,sp[0x40]
8000b43e:	59 f8       	cp.w	r8,31
8000b440:	e0 89 00 13 	brgt	8000b466 <_vfprintf_r+0x692>
8000b444:	f2 cb ff fc 	sub	r11,r9,-4
8000b448:	51 0b       	stdsp	sp[0x40],r11
8000b44a:	72 09       	ld.w	r9,r9[0x0]
8000b44c:	fa c6 f9 44 	sub	r6,sp,-1724
8000b450:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b454:	2f f8       	sub	r8,-1
8000b456:	f7 49 fd 88 	st.w	r11[-632],r9
8000b45a:	fb 48 06 b4 	st.w	sp[1716],r8
8000b45e:	14 97       	mov	r7,r10
8000b460:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b464:	c0 58       	rjmp	8000b46e <_vfprintf_r+0x69a>
8000b466:	92 18       	ld.sh	r8,r9[0x2]
8000b468:	14 97       	mov	r7,r10
8000b46a:	2f c9       	sub	r9,-4
8000b46c:	51 09       	stdsp	sp[0x40],r9
8000b46e:	50 18       	stdsp	sp[0x4],r8
8000b470:	bf 58       	asr	r8,0x1f
8000b472:	50 08       	stdsp	sp[0x0],r8
8000b474:	c4 88       	rjmp	8000b504 <_vfprintf_r+0x730>
8000b476:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b47a:	40 3c       	lddsp	r12,sp[0xc]
8000b47c:	58 0c       	cp.w	r12,0
8000b47e:	c1 d0       	breq	8000b4b8 <_vfprintf_r+0x6e4>
8000b480:	10 36       	cp.w	r6,r8
8000b482:	c0 64       	brge	8000b48e <_vfprintf_r+0x6ba>
8000b484:	fa cb f9 44 	sub	r11,sp,-1724
8000b488:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b48c:	c1 f8       	rjmp	8000b4ca <_vfprintf_r+0x6f6>
8000b48e:	fa c8 f9 50 	sub	r8,sp,-1712
8000b492:	1a d8       	st.w	--sp,r8
8000b494:	fa c8 fa b8 	sub	r8,sp,-1352
8000b498:	0c 9b       	mov	r11,r6
8000b49a:	1a d8       	st.w	--sp,r8
8000b49c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b4a0:	04 9a       	mov	r10,r2
8000b4a2:	1a d8       	st.w	--sp,r8
8000b4a4:	08 9c       	mov	r12,r4
8000b4a6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b4aa:	fa c9 ff b4 	sub	r9,sp,-76
8000b4ae:	fe b0 fa f5 	rcall	8000aa98 <get_arg>
8000b4b2:	2f dd       	sub	sp,-12
8000b4b4:	78 0b       	ld.w	r11,r12[0x0]
8000b4b6:	c2 48       	rjmp	8000b4fe <_vfprintf_r+0x72a>
8000b4b8:	ee ca ff ff 	sub	r10,r7,-1
8000b4bc:	10 37       	cp.w	r7,r8
8000b4be:	c0 94       	brge	8000b4d0 <_vfprintf_r+0x6fc>
8000b4c0:	fa c9 f9 44 	sub	r9,sp,-1724
8000b4c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b4c8:	14 97       	mov	r7,r10
8000b4ca:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b4ce:	c1 88       	rjmp	8000b4fe <_vfprintf_r+0x72a>
8000b4d0:	41 09       	lddsp	r9,sp[0x40]
8000b4d2:	59 f8       	cp.w	r8,31
8000b4d4:	e0 89 00 11 	brgt	8000b4f6 <_vfprintf_r+0x722>
8000b4d8:	f2 cb ff fc 	sub	r11,r9,-4
8000b4dc:	51 0b       	stdsp	sp[0x40],r11
8000b4de:	fa c6 f9 44 	sub	r6,sp,-1724
8000b4e2:	72 0b       	ld.w	r11,r9[0x0]
8000b4e4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b4e8:	f3 4b fd 88 	st.w	r9[-632],r11
8000b4ec:	2f f8       	sub	r8,-1
8000b4ee:	14 97       	mov	r7,r10
8000b4f0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b4f4:	c0 58       	rjmp	8000b4fe <_vfprintf_r+0x72a>
8000b4f6:	72 0b       	ld.w	r11,r9[0x0]
8000b4f8:	14 97       	mov	r7,r10
8000b4fa:	2f c9       	sub	r9,-4
8000b4fc:	51 09       	stdsp	sp[0x40],r9
8000b4fe:	50 1b       	stdsp	sp[0x4],r11
8000b500:	bf 5b       	asr	r11,0x1f
8000b502:	50 0b       	stdsp	sp[0x0],r11
8000b504:	fa ea 00 00 	ld.d	r10,sp[0]
8000b508:	58 0a       	cp.w	r10,0
8000b50a:	5c 2b       	cpc	r11
8000b50c:	c0 e4       	brge	8000b528 <_vfprintf_r+0x754>
8000b50e:	30 08       	mov	r8,0
8000b510:	fa ea 00 00 	ld.d	r10,sp[0]
8000b514:	30 09       	mov	r9,0
8000b516:	f0 0a 01 0a 	sub	r10,r8,r10
8000b51a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000b51e:	32 d8       	mov	r8,45
8000b520:	fa eb 00 00 	st.d	sp[0],r10
8000b524:	fb 68 06 bb 	st.b	sp[1723],r8
8000b528:	30 18       	mov	r8,1
8000b52a:	e0 8f 06 fe 	bral	8000c326 <_vfprintf_r+0x1552>
8000b52e:	50 a7       	stdsp	sp[0x28],r7
8000b530:	50 80       	stdsp	sp[0x20],r0
8000b532:	0c 97       	mov	r7,r6
8000b534:	04 94       	mov	r4,r2
8000b536:	06 96       	mov	r6,r3
8000b538:	02 92       	mov	r2,r1
8000b53a:	40 93       	lddsp	r3,sp[0x24]
8000b53c:	10 90       	mov	r0,r8
8000b53e:	40 41       	lddsp	r1,sp[0x10]
8000b540:	0e 99       	mov	r9,r7
8000b542:	ed b5 00 03 	bld	r5,0x3
8000b546:	c4 11       	brne	8000b5c8 <_vfprintf_r+0x7f4>
8000b548:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b54c:	40 3a       	lddsp	r10,sp[0xc]
8000b54e:	58 0a       	cp.w	r10,0
8000b550:	c1 90       	breq	8000b582 <_vfprintf_r+0x7ae>
8000b552:	10 36       	cp.w	r6,r8
8000b554:	c6 45       	brlt	8000b61c <_vfprintf_r+0x848>
8000b556:	fa c8 f9 50 	sub	r8,sp,-1712
8000b55a:	1a d8       	st.w	--sp,r8
8000b55c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b560:	1a d8       	st.w	--sp,r8
8000b562:	fa c8 fb b4 	sub	r8,sp,-1100
8000b566:	0c 9b       	mov	r11,r6
8000b568:	1a d8       	st.w	--sp,r8
8000b56a:	04 9a       	mov	r10,r2
8000b56c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b570:	fa c9 ff b4 	sub	r9,sp,-76
8000b574:	08 9c       	mov	r12,r4
8000b576:	fe b0 fa 91 	rcall	8000aa98 <get_arg>
8000b57a:	2f dd       	sub	sp,-12
8000b57c:	78 16       	ld.w	r6,r12[0x4]
8000b57e:	50 76       	stdsp	sp[0x1c],r6
8000b580:	c4 88       	rjmp	8000b610 <_vfprintf_r+0x83c>
8000b582:	2f f7       	sub	r7,-1
8000b584:	10 39       	cp.w	r9,r8
8000b586:	c0 c4       	brge	8000b59e <_vfprintf_r+0x7ca>
8000b588:	fa ce f9 44 	sub	lr,sp,-1724
8000b58c:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000b590:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000b594:	50 7c       	stdsp	sp[0x1c],r12
8000b596:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000b59a:	50 56       	stdsp	sp[0x14],r6
8000b59c:	c6 68       	rjmp	8000b668 <_vfprintf_r+0x894>
8000b59e:	41 09       	lddsp	r9,sp[0x40]
8000b5a0:	59 f8       	cp.w	r8,31
8000b5a2:	e0 89 00 10 	brgt	8000b5c2 <_vfprintf_r+0x7ee>
8000b5a6:	f2 ca ff f8 	sub	r10,r9,-8
8000b5aa:	72 1b       	ld.w	r11,r9[0x4]
8000b5ac:	51 0a       	stdsp	sp[0x40],r10
8000b5ae:	72 09       	ld.w	r9,r9[0x0]
8000b5b0:	fa ca f9 44 	sub	r10,sp,-1724
8000b5b4:	50 7b       	stdsp	sp[0x1c],r11
8000b5b6:	50 59       	stdsp	sp[0x14],r9
8000b5b8:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b5bc:	40 5b       	lddsp	r11,sp[0x14]
8000b5be:	40 7a       	lddsp	r10,sp[0x1c]
8000b5c0:	c4 78       	rjmp	8000b64e <_vfprintf_r+0x87a>
8000b5c2:	72 18       	ld.w	r8,r9[0x4]
8000b5c4:	50 78       	stdsp	sp[0x1c],r8
8000b5c6:	c4 c8       	rjmp	8000b65e <_vfprintf_r+0x88a>
8000b5c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b5cc:	40 3e       	lddsp	lr,sp[0xc]
8000b5ce:	58 0e       	cp.w	lr,0
8000b5d0:	c2 30       	breq	8000b616 <_vfprintf_r+0x842>
8000b5d2:	10 36       	cp.w	r6,r8
8000b5d4:	c0 94       	brge	8000b5e6 <_vfprintf_r+0x812>
8000b5d6:	fa cc f9 44 	sub	r12,sp,-1724
8000b5da:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b5de:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b5e2:	50 7b       	stdsp	sp[0x1c],r11
8000b5e4:	cd 9b       	rjmp	8000b596 <_vfprintf_r+0x7c2>
8000b5e6:	fa c8 f9 50 	sub	r8,sp,-1712
8000b5ea:	1a d8       	st.w	--sp,r8
8000b5ec:	fa c8 fa b8 	sub	r8,sp,-1352
8000b5f0:	04 9a       	mov	r10,r2
8000b5f2:	1a d8       	st.w	--sp,r8
8000b5f4:	fa c8 fb b4 	sub	r8,sp,-1100
8000b5f8:	0c 9b       	mov	r11,r6
8000b5fa:	1a d8       	st.w	--sp,r8
8000b5fc:	08 9c       	mov	r12,r4
8000b5fe:	fa c8 f9 40 	sub	r8,sp,-1728
8000b602:	fa c9 ff b4 	sub	r9,sp,-76
8000b606:	fe b0 fa 49 	rcall	8000aa98 <get_arg>
8000b60a:	2f dd       	sub	sp,-12
8000b60c:	78 1a       	ld.w	r10,r12[0x4]
8000b60e:	50 7a       	stdsp	sp[0x1c],r10
8000b610:	78 0c       	ld.w	r12,r12[0x0]
8000b612:	50 5c       	stdsp	sp[0x14],r12
8000b614:	c2 a8       	rjmp	8000b668 <_vfprintf_r+0x894>
8000b616:	2f f7       	sub	r7,-1
8000b618:	10 39       	cp.w	r9,r8
8000b61a:	c0 94       	brge	8000b62c <_vfprintf_r+0x858>
8000b61c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b620:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b624:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000b628:	50 78       	stdsp	sp[0x1c],r8
8000b62a:	cb 6b       	rjmp	8000b596 <_vfprintf_r+0x7c2>
8000b62c:	41 09       	lddsp	r9,sp[0x40]
8000b62e:	59 f8       	cp.w	r8,31
8000b630:	e0 89 00 15 	brgt	8000b65a <_vfprintf_r+0x886>
8000b634:	f2 ca ff f8 	sub	r10,r9,-8
8000b638:	72 16       	ld.w	r6,r9[0x4]
8000b63a:	72 09       	ld.w	r9,r9[0x0]
8000b63c:	51 0a       	stdsp	sp[0x40],r10
8000b63e:	50 59       	stdsp	sp[0x14],r9
8000b640:	fa ce f9 44 	sub	lr,sp,-1724
8000b644:	50 76       	stdsp	sp[0x1c],r6
8000b646:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000b64a:	40 5b       	lddsp	r11,sp[0x14]
8000b64c:	0c 9a       	mov	r10,r6
8000b64e:	f2 eb fd 88 	st.d	r9[-632],r10
8000b652:	2f f8       	sub	r8,-1
8000b654:	fb 48 06 b4 	st.w	sp[1716],r8
8000b658:	c0 88       	rjmp	8000b668 <_vfprintf_r+0x894>
8000b65a:	72 1c       	ld.w	r12,r9[0x4]
8000b65c:	50 7c       	stdsp	sp[0x1c],r12
8000b65e:	f2 c8 ff f8 	sub	r8,r9,-8
8000b662:	51 08       	stdsp	sp[0x40],r8
8000b664:	72 09       	ld.w	r9,r9[0x0]
8000b666:	50 59       	stdsp	sp[0x14],r9
8000b668:	40 5b       	lddsp	r11,sp[0x14]
8000b66a:	40 7a       	lddsp	r10,sp[0x1c]
8000b66c:	e0 a0 19 64 	rcall	8000e934 <__isinfd>
8000b670:	18 96       	mov	r6,r12
8000b672:	c1 50       	breq	8000b69c <_vfprintf_r+0x8c8>
8000b674:	30 08       	mov	r8,0
8000b676:	30 09       	mov	r9,0
8000b678:	40 5b       	lddsp	r11,sp[0x14]
8000b67a:	40 7a       	lddsp	r10,sp[0x1c]
8000b67c:	e0 a0 1d ba 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000b680:	c0 40       	breq	8000b688 <_vfprintf_r+0x8b4>
8000b682:	32 d8       	mov	r8,45
8000b684:	fb 68 06 bb 	st.b	sp[1723],r8
8000b688:	4d 18       	lddpc	r8,8000b7cc <_vfprintf_r+0x9f8>
8000b68a:	4d 26       	lddpc	r6,8000b7d0 <_vfprintf_r+0x9fc>
8000b68c:	a7 d5       	cbr	r5,0x7
8000b68e:	e0 40 00 47 	cp.w	r0,71
8000b692:	f0 06 17 a0 	movle	r6,r8
8000b696:	30 32       	mov	r2,3
8000b698:	e0 8f 06 d4 	bral	8000c440 <_vfprintf_r+0x166c>
8000b69c:	40 5b       	lddsp	r11,sp[0x14]
8000b69e:	40 7a       	lddsp	r10,sp[0x1c]
8000b6a0:	e0 a0 19 5f 	rcall	8000e95e <__isnand>
8000b6a4:	c0 c0       	breq	8000b6bc <_vfprintf_r+0x8e8>
8000b6a6:	50 26       	stdsp	sp[0x8],r6
8000b6a8:	4c b8       	lddpc	r8,8000b7d4 <_vfprintf_r+0xa00>
8000b6aa:	4c c6       	lddpc	r6,8000b7d8 <_vfprintf_r+0xa04>
8000b6ac:	a7 d5       	cbr	r5,0x7
8000b6ae:	e0 40 00 47 	cp.w	r0,71
8000b6b2:	f0 06 17 a0 	movle	r6,r8
8000b6b6:	30 32       	mov	r2,3
8000b6b8:	e0 8f 06 ca 	bral	8000c44c <_vfprintf_r+0x1678>
8000b6bc:	40 2a       	lddsp	r10,sp[0x8]
8000b6be:	5b fa       	cp.w	r10,-1
8000b6c0:	c0 41       	brne	8000b6c8 <_vfprintf_r+0x8f4>
8000b6c2:	30 69       	mov	r9,6
8000b6c4:	50 29       	stdsp	sp[0x8],r9
8000b6c6:	c1 18       	rjmp	8000b6e8 <_vfprintf_r+0x914>
8000b6c8:	e0 40 00 47 	cp.w	r0,71
8000b6cc:	5f 09       	sreq	r9
8000b6ce:	e0 40 00 67 	cp.w	r0,103
8000b6d2:	5f 08       	sreq	r8
8000b6d4:	f3 e8 10 08 	or	r8,r9,r8
8000b6d8:	f8 08 18 00 	cp.b	r8,r12
8000b6dc:	c0 60       	breq	8000b6e8 <_vfprintf_r+0x914>
8000b6de:	40 28       	lddsp	r8,sp[0x8]
8000b6e0:	58 08       	cp.w	r8,0
8000b6e2:	f9 b8 00 01 	moveq	r8,1
8000b6e6:	50 28       	stdsp	sp[0x8],r8
8000b6e8:	40 78       	lddsp	r8,sp[0x1c]
8000b6ea:	40 59       	lddsp	r9,sp[0x14]
8000b6ec:	fa e9 06 94 	st.d	sp[1684],r8
8000b6f0:	a9 a5       	sbr	r5,0x8
8000b6f2:	fa f8 06 94 	ld.w	r8,sp[1684]
8000b6f6:	58 08       	cp.w	r8,0
8000b6f8:	c0 65       	brlt	8000b704 <_vfprintf_r+0x930>
8000b6fa:	40 5e       	lddsp	lr,sp[0x14]
8000b6fc:	30 0c       	mov	r12,0
8000b6fe:	50 6e       	stdsp	sp[0x18],lr
8000b700:	50 9c       	stdsp	sp[0x24],r12
8000b702:	c0 78       	rjmp	8000b710 <_vfprintf_r+0x93c>
8000b704:	40 5b       	lddsp	r11,sp[0x14]
8000b706:	32 da       	mov	r10,45
8000b708:	ee 1b 80 00 	eorh	r11,0x8000
8000b70c:	50 9a       	stdsp	sp[0x24],r10
8000b70e:	50 6b       	stdsp	sp[0x18],r11
8000b710:	e0 40 00 46 	cp.w	r0,70
8000b714:	5f 09       	sreq	r9
8000b716:	e0 40 00 66 	cp.w	r0,102
8000b71a:	5f 08       	sreq	r8
8000b71c:	f3 e8 10 08 	or	r8,r9,r8
8000b720:	50 48       	stdsp	sp[0x10],r8
8000b722:	c0 40       	breq	8000b72a <_vfprintf_r+0x956>
8000b724:	40 22       	lddsp	r2,sp[0x8]
8000b726:	30 39       	mov	r9,3
8000b728:	c1 08       	rjmp	8000b748 <_vfprintf_r+0x974>
8000b72a:	e0 40 00 45 	cp.w	r0,69
8000b72e:	5f 09       	sreq	r9
8000b730:	e0 40 00 65 	cp.w	r0,101
8000b734:	5f 08       	sreq	r8
8000b736:	40 22       	lddsp	r2,sp[0x8]
8000b738:	10 49       	or	r9,r8
8000b73a:	2f f2       	sub	r2,-1
8000b73c:	40 46       	lddsp	r6,sp[0x10]
8000b73e:	ec 09 18 00 	cp.b	r9,r6
8000b742:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000b746:	30 29       	mov	r9,2
8000b748:	fa c8 f9 5c 	sub	r8,sp,-1700
8000b74c:	1a d8       	st.w	--sp,r8
8000b74e:	fa c8 f9 54 	sub	r8,sp,-1708
8000b752:	1a d8       	st.w	--sp,r8
8000b754:	fa c8 f9 4c 	sub	r8,sp,-1716
8000b758:	08 9c       	mov	r12,r4
8000b75a:	1a d8       	st.w	--sp,r8
8000b75c:	04 98       	mov	r8,r2
8000b75e:	40 9b       	lddsp	r11,sp[0x24]
8000b760:	40 aa       	lddsp	r10,sp[0x28]
8000b762:	e0 a0 0b cf 	rcall	8000cf00 <_dtoa_r>
8000b766:	e0 40 00 47 	cp.w	r0,71
8000b76a:	5f 19       	srne	r9
8000b76c:	e0 40 00 67 	cp.w	r0,103
8000b770:	5f 18       	srne	r8
8000b772:	18 96       	mov	r6,r12
8000b774:	2f dd       	sub	sp,-12
8000b776:	f3 e8 00 08 	and	r8,r9,r8
8000b77a:	c0 41       	brne	8000b782 <_vfprintf_r+0x9ae>
8000b77c:	ed b5 00 00 	bld	r5,0x0
8000b780:	c3 81       	brne	8000b7f0 <_vfprintf_r+0xa1c>
8000b782:	ec 02 00 0e 	add	lr,r6,r2
8000b786:	50 3e       	stdsp	sp[0xc],lr
8000b788:	40 4c       	lddsp	r12,sp[0x10]
8000b78a:	58 0c       	cp.w	r12,0
8000b78c:	c1 50       	breq	8000b7b6 <_vfprintf_r+0x9e2>
8000b78e:	0d 89       	ld.ub	r9,r6[0x0]
8000b790:	33 08       	mov	r8,48
8000b792:	f0 09 18 00 	cp.b	r9,r8
8000b796:	c0 b1       	brne	8000b7ac <_vfprintf_r+0x9d8>
8000b798:	30 08       	mov	r8,0
8000b79a:	30 09       	mov	r9,0
8000b79c:	40 6b       	lddsp	r11,sp[0x18]
8000b79e:	40 7a       	lddsp	r10,sp[0x1c]
8000b7a0:	e0 a0 1c e1 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000b7a4:	fb b2 00 01 	rsubeq	r2,1
8000b7a8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000b7ac:	40 3b       	lddsp	r11,sp[0xc]
8000b7ae:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b7b2:	10 0b       	add	r11,r8
8000b7b4:	50 3b       	stdsp	sp[0xc],r11
8000b7b6:	40 6b       	lddsp	r11,sp[0x18]
8000b7b8:	30 08       	mov	r8,0
8000b7ba:	30 09       	mov	r9,0
8000b7bc:	40 7a       	lddsp	r10,sp[0x1c]
8000b7be:	e0 a0 1c d2 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000b7c2:	c1 10       	breq	8000b7e4 <_vfprintf_r+0xa10>
8000b7c4:	40 3a       	lddsp	r10,sp[0xc]
8000b7c6:	fb 4a 06 a4 	st.w	sp[1700],r10
8000b7ca:	c0 d8       	rjmp	8000b7e4 <_vfprintf_r+0xa10>
8000b7cc:	80 01       	ld.sh	r1,r0[0x0]
8000b7ce:	8f 78       	st.w	r7[0x1c],r8
8000b7d0:	80 01       	ld.sh	r1,r0[0x0]
8000b7d2:	8f 7c       	st.w	r7[0x1c],r12
8000b7d4:	80 01       	ld.sh	r1,r0[0x0]
8000b7d6:	8f 80       	st.w	r7[0x20],r0
8000b7d8:	80 01       	ld.sh	r1,r0[0x0]
8000b7da:	8f 84       	st.w	r7[0x20],r4
8000b7dc:	10 c9       	st.b	r8++,r9
8000b7de:	fb 48 06 a4 	st.w	sp[1700],r8
8000b7e2:	c0 28       	rjmp	8000b7e6 <_vfprintf_r+0xa12>
8000b7e4:	33 09       	mov	r9,48
8000b7e6:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000b7ea:	40 3e       	lddsp	lr,sp[0xc]
8000b7ec:	1c 38       	cp.w	r8,lr
8000b7ee:	cf 73       	brcs	8000b7dc <_vfprintf_r+0xa08>
8000b7f0:	e0 40 00 47 	cp.w	r0,71
8000b7f4:	5f 09       	sreq	r9
8000b7f6:	e0 40 00 67 	cp.w	r0,103
8000b7fa:	5f 08       	sreq	r8
8000b7fc:	f3 e8 10 08 	or	r8,r9,r8
8000b800:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000b804:	0c 19       	sub	r9,r6
8000b806:	50 69       	stdsp	sp[0x18],r9
8000b808:	58 08       	cp.w	r8,0
8000b80a:	c0 b0       	breq	8000b820 <_vfprintf_r+0xa4c>
8000b80c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b810:	5b d8       	cp.w	r8,-3
8000b812:	c0 55       	brlt	8000b81c <_vfprintf_r+0xa48>
8000b814:	40 2c       	lddsp	r12,sp[0x8]
8000b816:	18 38       	cp.w	r8,r12
8000b818:	e0 8a 00 6a 	brle	8000b8ec <_vfprintf_r+0xb18>
8000b81c:	20 20       	sub	r0,2
8000b81e:	c0 58       	rjmp	8000b828 <_vfprintf_r+0xa54>
8000b820:	e0 40 00 65 	cp.w	r0,101
8000b824:	e0 89 00 46 	brgt	8000b8b0 <_vfprintf_r+0xadc>
8000b828:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000b82c:	fb 60 06 9c 	st.b	sp[1692],r0
8000b830:	20 1b       	sub	r11,1
8000b832:	fb 4b 06 ac 	st.w	sp[1708],r11
8000b836:	c0 47       	brpl	8000b83e <_vfprintf_r+0xa6a>
8000b838:	5c 3b       	neg	r11
8000b83a:	32 d8       	mov	r8,45
8000b83c:	c0 28       	rjmp	8000b840 <_vfprintf_r+0xa6c>
8000b83e:	32 b8       	mov	r8,43
8000b840:	fb 68 06 9d 	st.b	sp[1693],r8
8000b844:	58 9b       	cp.w	r11,9
8000b846:	e0 8a 00 1d 	brle	8000b880 <_vfprintf_r+0xaac>
8000b84a:	fa c9 fa 35 	sub	r9,sp,-1483
8000b84e:	30 aa       	mov	r10,10
8000b850:	12 98       	mov	r8,r9
8000b852:	0e 9c       	mov	r12,r7
8000b854:	0c 92       	mov	r2,r6
8000b856:	f6 0a 0c 06 	divs	r6,r11,r10
8000b85a:	0e 9b       	mov	r11,r7
8000b85c:	2d 0b       	sub	r11,-48
8000b85e:	10 fb       	st.b	--r8,r11
8000b860:	0c 9b       	mov	r11,r6
8000b862:	58 96       	cp.w	r6,9
8000b864:	fe 99 ff f9 	brgt	8000b856 <_vfprintf_r+0xa82>
8000b868:	2d 0b       	sub	r11,-48
8000b86a:	18 97       	mov	r7,r12
8000b86c:	04 96       	mov	r6,r2
8000b86e:	10 fb       	st.b	--r8,r11
8000b870:	fa ca f9 62 	sub	r10,sp,-1694
8000b874:	c0 38       	rjmp	8000b87a <_vfprintf_r+0xaa6>
8000b876:	11 3b       	ld.ub	r11,r8++
8000b878:	14 cb       	st.b	r10++,r11
8000b87a:	12 38       	cp.w	r8,r9
8000b87c:	cf d3       	brcs	8000b876 <_vfprintf_r+0xaa2>
8000b87e:	c0 98       	rjmp	8000b890 <_vfprintf_r+0xabc>
8000b880:	2d 0b       	sub	r11,-48
8000b882:	33 08       	mov	r8,48
8000b884:	fb 6b 06 9f 	st.b	sp[1695],r11
8000b888:	fb 68 06 9e 	st.b	sp[1694],r8
8000b88c:	fa ca f9 60 	sub	r10,sp,-1696
8000b890:	fa c8 f9 64 	sub	r8,sp,-1692
8000b894:	f4 08 01 08 	sub	r8,r10,r8
8000b898:	50 e8       	stdsp	sp[0x38],r8
8000b89a:	10 92       	mov	r2,r8
8000b89c:	40 6b       	lddsp	r11,sp[0x18]
8000b89e:	16 02       	add	r2,r11
8000b8a0:	58 1b       	cp.w	r11,1
8000b8a2:	e0 89 00 05 	brgt	8000b8ac <_vfprintf_r+0xad8>
8000b8a6:	ed b5 00 00 	bld	r5,0x0
8000b8aa:	c3 51       	brne	8000b914 <_vfprintf_r+0xb40>
8000b8ac:	2f f2       	sub	r2,-1
8000b8ae:	c3 38       	rjmp	8000b914 <_vfprintf_r+0xb40>
8000b8b0:	e0 40 00 66 	cp.w	r0,102
8000b8b4:	c1 c1       	brne	8000b8ec <_vfprintf_r+0xb18>
8000b8b6:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b8ba:	58 02       	cp.w	r2,0
8000b8bc:	e0 8a 00 0c 	brle	8000b8d4 <_vfprintf_r+0xb00>
8000b8c0:	40 2a       	lddsp	r10,sp[0x8]
8000b8c2:	58 0a       	cp.w	r10,0
8000b8c4:	c0 41       	brne	8000b8cc <_vfprintf_r+0xaf8>
8000b8c6:	ed b5 00 00 	bld	r5,0x0
8000b8ca:	c2 51       	brne	8000b914 <_vfprintf_r+0xb40>
8000b8cc:	2f f2       	sub	r2,-1
8000b8ce:	40 29       	lddsp	r9,sp[0x8]
8000b8d0:	12 02       	add	r2,r9
8000b8d2:	c0 b8       	rjmp	8000b8e8 <_vfprintf_r+0xb14>
8000b8d4:	40 28       	lddsp	r8,sp[0x8]
8000b8d6:	58 08       	cp.w	r8,0
8000b8d8:	c0 61       	brne	8000b8e4 <_vfprintf_r+0xb10>
8000b8da:	ed b5 00 00 	bld	r5,0x0
8000b8de:	c0 30       	breq	8000b8e4 <_vfprintf_r+0xb10>
8000b8e0:	30 12       	mov	r2,1
8000b8e2:	c1 98       	rjmp	8000b914 <_vfprintf_r+0xb40>
8000b8e4:	40 22       	lddsp	r2,sp[0x8]
8000b8e6:	2f e2       	sub	r2,-2
8000b8e8:	36 60       	mov	r0,102
8000b8ea:	c1 58       	rjmp	8000b914 <_vfprintf_r+0xb40>
8000b8ec:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b8f0:	40 6e       	lddsp	lr,sp[0x18]
8000b8f2:	1c 32       	cp.w	r2,lr
8000b8f4:	c0 65       	brlt	8000b900 <_vfprintf_r+0xb2c>
8000b8f6:	ed b5 00 00 	bld	r5,0x0
8000b8fa:	f7 b2 00 ff 	subeq	r2,-1
8000b8fe:	c0 a8       	rjmp	8000b912 <_vfprintf_r+0xb3e>
8000b900:	e4 08 11 02 	rsub	r8,r2,2
8000b904:	40 6c       	lddsp	r12,sp[0x18]
8000b906:	58 02       	cp.w	r2,0
8000b908:	f0 02 17 a0 	movle	r2,r8
8000b90c:	f9 b2 09 01 	movgt	r2,1
8000b910:	18 02       	add	r2,r12
8000b912:	36 70       	mov	r0,103
8000b914:	40 9b       	lddsp	r11,sp[0x24]
8000b916:	58 0b       	cp.w	r11,0
8000b918:	e0 80 05 94 	breq	8000c440 <_vfprintf_r+0x166c>
8000b91c:	32 d8       	mov	r8,45
8000b91e:	fb 68 06 bb 	st.b	sp[1723],r8
8000b922:	e0 8f 05 93 	bral	8000c448 <_vfprintf_r+0x1674>
8000b926:	50 a7       	stdsp	sp[0x28],r7
8000b928:	04 94       	mov	r4,r2
8000b92a:	0c 97       	mov	r7,r6
8000b92c:	02 92       	mov	r2,r1
8000b92e:	06 96       	mov	r6,r3
8000b930:	40 41       	lddsp	r1,sp[0x10]
8000b932:	40 93       	lddsp	r3,sp[0x24]
8000b934:	0e 99       	mov	r9,r7
8000b936:	ed b5 00 05 	bld	r5,0x5
8000b93a:	c4 81       	brne	8000b9ca <_vfprintf_r+0xbf6>
8000b93c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b940:	40 3e       	lddsp	lr,sp[0xc]
8000b942:	58 0e       	cp.w	lr,0
8000b944:	c1 d0       	breq	8000b97e <_vfprintf_r+0xbaa>
8000b946:	10 36       	cp.w	r6,r8
8000b948:	c0 64       	brge	8000b954 <_vfprintf_r+0xb80>
8000b94a:	fa cc f9 44 	sub	r12,sp,-1724
8000b94e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b952:	c1 d8       	rjmp	8000b98c <_vfprintf_r+0xbb8>
8000b954:	fa c8 f9 50 	sub	r8,sp,-1712
8000b958:	1a d8       	st.w	--sp,r8
8000b95a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b95e:	04 9a       	mov	r10,r2
8000b960:	1a d8       	st.w	--sp,r8
8000b962:	fa c8 fb b4 	sub	r8,sp,-1100
8000b966:	0c 9b       	mov	r11,r6
8000b968:	1a d8       	st.w	--sp,r8
8000b96a:	08 9c       	mov	r12,r4
8000b96c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b970:	fa c9 ff b4 	sub	r9,sp,-76
8000b974:	fe b0 f8 92 	rcall	8000aa98 <get_arg>
8000b978:	2f dd       	sub	sp,-12
8000b97a:	78 0a       	ld.w	r10,r12[0x0]
8000b97c:	c2 08       	rjmp	8000b9bc <_vfprintf_r+0xbe8>
8000b97e:	2f f7       	sub	r7,-1
8000b980:	10 39       	cp.w	r9,r8
8000b982:	c0 84       	brge	8000b992 <_vfprintf_r+0xbbe>
8000b984:	fa cb f9 44 	sub	r11,sp,-1724
8000b988:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b98c:	ec fa fd 88 	ld.w	r10,r6[-632]
8000b990:	c1 68       	rjmp	8000b9bc <_vfprintf_r+0xbe8>
8000b992:	41 09       	lddsp	r9,sp[0x40]
8000b994:	59 f8       	cp.w	r8,31
8000b996:	e0 89 00 10 	brgt	8000b9b6 <_vfprintf_r+0xbe2>
8000b99a:	f2 ca ff fc 	sub	r10,r9,-4
8000b99e:	51 0a       	stdsp	sp[0x40],r10
8000b9a0:	fa c6 f9 44 	sub	r6,sp,-1724
8000b9a4:	72 0a       	ld.w	r10,r9[0x0]
8000b9a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b9aa:	f3 4a fd 88 	st.w	r9[-632],r10
8000b9ae:	2f f8       	sub	r8,-1
8000b9b0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b9b4:	c0 48       	rjmp	8000b9bc <_vfprintf_r+0xbe8>
8000b9b6:	72 0a       	ld.w	r10,r9[0x0]
8000b9b8:	2f c9       	sub	r9,-4
8000b9ba:	51 09       	stdsp	sp[0x40],r9
8000b9bc:	40 be       	lddsp	lr,sp[0x2c]
8000b9be:	1c 98       	mov	r8,lr
8000b9c0:	95 1e       	st.w	r10[0x4],lr
8000b9c2:	bf 58       	asr	r8,0x1f
8000b9c4:	95 08       	st.w	r10[0x0],r8
8000b9c6:	fe 9f fa 92 	bral	8000aeea <_vfprintf_r+0x116>
8000b9ca:	ed b5 00 04 	bld	r5,0x4
8000b9ce:	c4 80       	breq	8000ba5e <_vfprintf_r+0xc8a>
8000b9d0:	e2 15 00 40 	andl	r5,0x40,COH
8000b9d4:	c4 50       	breq	8000ba5e <_vfprintf_r+0xc8a>
8000b9d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b9da:	40 3c       	lddsp	r12,sp[0xc]
8000b9dc:	58 0c       	cp.w	r12,0
8000b9de:	c1 d0       	breq	8000ba18 <_vfprintf_r+0xc44>
8000b9e0:	10 36       	cp.w	r6,r8
8000b9e2:	c0 64       	brge	8000b9ee <_vfprintf_r+0xc1a>
8000b9e4:	fa cb f9 44 	sub	r11,sp,-1724
8000b9e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b9ec:	c1 d8       	rjmp	8000ba26 <_vfprintf_r+0xc52>
8000b9ee:	fa c8 f9 50 	sub	r8,sp,-1712
8000b9f2:	1a d8       	st.w	--sp,r8
8000b9f4:	fa c8 fa b8 	sub	r8,sp,-1352
8000b9f8:	04 9a       	mov	r10,r2
8000b9fa:	1a d8       	st.w	--sp,r8
8000b9fc:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba00:	0c 9b       	mov	r11,r6
8000ba02:	1a d8       	st.w	--sp,r8
8000ba04:	08 9c       	mov	r12,r4
8000ba06:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba0a:	fa c9 ff b4 	sub	r9,sp,-76
8000ba0e:	fe b0 f8 45 	rcall	8000aa98 <get_arg>
8000ba12:	2f dd       	sub	sp,-12
8000ba14:	78 0a       	ld.w	r10,r12[0x0]
8000ba16:	c2 08       	rjmp	8000ba56 <_vfprintf_r+0xc82>
8000ba18:	2f f7       	sub	r7,-1
8000ba1a:	10 39       	cp.w	r9,r8
8000ba1c:	c0 84       	brge	8000ba2c <_vfprintf_r+0xc58>
8000ba1e:	fa ca f9 44 	sub	r10,sp,-1724
8000ba22:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ba26:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ba2a:	c1 68       	rjmp	8000ba56 <_vfprintf_r+0xc82>
8000ba2c:	41 09       	lddsp	r9,sp[0x40]
8000ba2e:	59 f8       	cp.w	r8,31
8000ba30:	e0 89 00 10 	brgt	8000ba50 <_vfprintf_r+0xc7c>
8000ba34:	f2 ca ff fc 	sub	r10,r9,-4
8000ba38:	51 0a       	stdsp	sp[0x40],r10
8000ba3a:	fa c6 f9 44 	sub	r6,sp,-1724
8000ba3e:	72 0a       	ld.w	r10,r9[0x0]
8000ba40:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ba44:	f3 4a fd 88 	st.w	r9[-632],r10
8000ba48:	2f f8       	sub	r8,-1
8000ba4a:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba4e:	c0 48       	rjmp	8000ba56 <_vfprintf_r+0xc82>
8000ba50:	72 0a       	ld.w	r10,r9[0x0]
8000ba52:	2f c9       	sub	r9,-4
8000ba54:	51 09       	stdsp	sp[0x40],r9
8000ba56:	40 be       	lddsp	lr,sp[0x2c]
8000ba58:	b4 0e       	st.h	r10[0x0],lr
8000ba5a:	fe 9f fa 48 	bral	8000aeea <_vfprintf_r+0x116>
8000ba5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba62:	40 3c       	lddsp	r12,sp[0xc]
8000ba64:	58 0c       	cp.w	r12,0
8000ba66:	c1 d0       	breq	8000baa0 <_vfprintf_r+0xccc>
8000ba68:	10 36       	cp.w	r6,r8
8000ba6a:	c0 64       	brge	8000ba76 <_vfprintf_r+0xca2>
8000ba6c:	fa cb f9 44 	sub	r11,sp,-1724
8000ba70:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ba74:	c1 d8       	rjmp	8000baae <_vfprintf_r+0xcda>
8000ba76:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba7a:	1a d8       	st.w	--sp,r8
8000ba7c:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba80:	04 9a       	mov	r10,r2
8000ba82:	1a d8       	st.w	--sp,r8
8000ba84:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba88:	0c 9b       	mov	r11,r6
8000ba8a:	1a d8       	st.w	--sp,r8
8000ba8c:	08 9c       	mov	r12,r4
8000ba8e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba92:	fa c9 ff b4 	sub	r9,sp,-76
8000ba96:	fe b0 f8 01 	rcall	8000aa98 <get_arg>
8000ba9a:	2f dd       	sub	sp,-12
8000ba9c:	78 0a       	ld.w	r10,r12[0x0]
8000ba9e:	c2 08       	rjmp	8000bade <_vfprintf_r+0xd0a>
8000baa0:	2f f7       	sub	r7,-1
8000baa2:	10 39       	cp.w	r9,r8
8000baa4:	c0 84       	brge	8000bab4 <_vfprintf_r+0xce0>
8000baa6:	fa ca f9 44 	sub	r10,sp,-1724
8000baaa:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000baae:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bab2:	c1 68       	rjmp	8000bade <_vfprintf_r+0xd0a>
8000bab4:	41 09       	lddsp	r9,sp[0x40]
8000bab6:	59 f8       	cp.w	r8,31
8000bab8:	e0 89 00 10 	brgt	8000bad8 <_vfprintf_r+0xd04>
8000babc:	f2 ca ff fc 	sub	r10,r9,-4
8000bac0:	51 0a       	stdsp	sp[0x40],r10
8000bac2:	fa c6 f9 44 	sub	r6,sp,-1724
8000bac6:	72 0a       	ld.w	r10,r9[0x0]
8000bac8:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bacc:	f3 4a fd 88 	st.w	r9[-632],r10
8000bad0:	2f f8       	sub	r8,-1
8000bad2:	fb 48 06 b4 	st.w	sp[1716],r8
8000bad6:	c0 48       	rjmp	8000bade <_vfprintf_r+0xd0a>
8000bad8:	72 0a       	ld.w	r10,r9[0x0]
8000bada:	2f c9       	sub	r9,-4
8000badc:	51 09       	stdsp	sp[0x40],r9
8000bade:	40 be       	lddsp	lr,sp[0x2c]
8000bae0:	95 0e       	st.w	r10[0x0],lr
8000bae2:	fe 9f fa 04 	bral	8000aeea <_vfprintf_r+0x116>
8000bae6:	50 a7       	stdsp	sp[0x28],r7
8000bae8:	50 80       	stdsp	sp[0x20],r0
8000baea:	0c 97       	mov	r7,r6
8000baec:	04 94       	mov	r4,r2
8000baee:	06 96       	mov	r6,r3
8000baf0:	02 92       	mov	r2,r1
8000baf2:	40 93       	lddsp	r3,sp[0x24]
8000baf4:	10 90       	mov	r0,r8
8000baf6:	40 41       	lddsp	r1,sp[0x10]
8000baf8:	a5 a5       	sbr	r5,0x4
8000bafa:	c0 a8       	rjmp	8000bb0e <_vfprintf_r+0xd3a>
8000bafc:	50 a7       	stdsp	sp[0x28],r7
8000bafe:	50 80       	stdsp	sp[0x20],r0
8000bb00:	0c 97       	mov	r7,r6
8000bb02:	04 94       	mov	r4,r2
8000bb04:	06 96       	mov	r6,r3
8000bb06:	02 92       	mov	r2,r1
8000bb08:	40 93       	lddsp	r3,sp[0x24]
8000bb0a:	10 90       	mov	r0,r8
8000bb0c:	40 41       	lddsp	r1,sp[0x10]
8000bb0e:	ed b5 00 05 	bld	r5,0x5
8000bb12:	c5 d1       	brne	8000bbcc <_vfprintf_r+0xdf8>
8000bb14:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb18:	40 3c       	lddsp	r12,sp[0xc]
8000bb1a:	58 0c       	cp.w	r12,0
8000bb1c:	c2 60       	breq	8000bb68 <_vfprintf_r+0xd94>
8000bb1e:	10 36       	cp.w	r6,r8
8000bb20:	c0 a4       	brge	8000bb34 <_vfprintf_r+0xd60>
8000bb22:	fa cb f9 44 	sub	r11,sp,-1724
8000bb26:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb2a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000bb2e:	fa e9 00 00 	st.d	sp[0],r8
8000bb32:	c1 88       	rjmp	8000bb62 <_vfprintf_r+0xd8e>
8000bb34:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb38:	1a d8       	st.w	--sp,r8
8000bb3a:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb3e:	04 9a       	mov	r10,r2
8000bb40:	1a d8       	st.w	--sp,r8
8000bb42:	0c 9b       	mov	r11,r6
8000bb44:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb48:	08 9c       	mov	r12,r4
8000bb4a:	1a d8       	st.w	--sp,r8
8000bb4c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bb50:	fa c9 ff b4 	sub	r9,sp,-76
8000bb54:	fe b0 f7 a2 	rcall	8000aa98 <get_arg>
8000bb58:	2f dd       	sub	sp,-12
8000bb5a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000bb5e:	fa eb 00 00 	st.d	sp[0],r10
8000bb62:	30 08       	mov	r8,0
8000bb64:	e0 8f 03 de 	bral	8000c320 <_vfprintf_r+0x154c>
8000bb68:	ee ca ff ff 	sub	r10,r7,-1
8000bb6c:	10 37       	cp.w	r7,r8
8000bb6e:	c0 b4       	brge	8000bb84 <_vfprintf_r+0xdb0>
8000bb70:	fa c9 f9 44 	sub	r9,sp,-1724
8000bb74:	14 97       	mov	r7,r10
8000bb76:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bb7a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000bb7e:	fa eb 00 00 	st.d	sp[0],r10
8000bb82:	c1 88       	rjmp	8000bbb2 <_vfprintf_r+0xdde>
8000bb84:	41 09       	lddsp	r9,sp[0x40]
8000bb86:	59 f8       	cp.w	r8,31
8000bb88:	e0 89 00 18 	brgt	8000bbb8 <_vfprintf_r+0xde4>
8000bb8c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bb90:	f2 cb ff f8 	sub	r11,r9,-8
8000bb94:	fa e7 00 00 	st.d	sp[0],r6
8000bb98:	51 0b       	stdsp	sp[0x40],r11
8000bb9a:	fa c6 f9 44 	sub	r6,sp,-1724
8000bb9e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bba2:	fa e6 00 00 	ld.d	r6,sp[0]
8000bba6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000bbaa:	2f f8       	sub	r8,-1
8000bbac:	14 97       	mov	r7,r10
8000bbae:	fb 48 06 b4 	st.w	sp[1716],r8
8000bbb2:	40 38       	lddsp	r8,sp[0xc]
8000bbb4:	e0 8f 03 b6 	bral	8000c320 <_vfprintf_r+0x154c>
8000bbb8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bbbc:	40 38       	lddsp	r8,sp[0xc]
8000bbbe:	fa e7 00 00 	st.d	sp[0],r6
8000bbc2:	2f 89       	sub	r9,-8
8000bbc4:	14 97       	mov	r7,r10
8000bbc6:	51 09       	stdsp	sp[0x40],r9
8000bbc8:	e0 8f 03 ac 	bral	8000c320 <_vfprintf_r+0x154c>
8000bbcc:	ed b5 00 04 	bld	r5,0x4
8000bbd0:	c1 61       	brne	8000bbfc <_vfprintf_r+0xe28>
8000bbd2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bbd6:	40 3e       	lddsp	lr,sp[0xc]
8000bbd8:	58 0e       	cp.w	lr,0
8000bbda:	c0 80       	breq	8000bbea <_vfprintf_r+0xe16>
8000bbdc:	10 36       	cp.w	r6,r8
8000bbde:	c6 74       	brge	8000bcac <_vfprintf_r+0xed8>
8000bbe0:	fa cc f9 44 	sub	r12,sp,-1724
8000bbe4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bbe8:	c8 08       	rjmp	8000bce8 <_vfprintf_r+0xf14>
8000bbea:	ee ca ff ff 	sub	r10,r7,-1
8000bbee:	10 37       	cp.w	r7,r8
8000bbf0:	c7 f4       	brge	8000bcee <_vfprintf_r+0xf1a>
8000bbf2:	fa cb f9 44 	sub	r11,sp,-1724
8000bbf6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bbfa:	c7 68       	rjmp	8000bce6 <_vfprintf_r+0xf12>
8000bbfc:	ed b5 00 06 	bld	r5,0x6
8000bc00:	c4 a1       	brne	8000bc94 <_vfprintf_r+0xec0>
8000bc02:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc06:	40 3c       	lddsp	r12,sp[0xc]
8000bc08:	58 0c       	cp.w	r12,0
8000bc0a:	c1 d0       	breq	8000bc44 <_vfprintf_r+0xe70>
8000bc0c:	10 36       	cp.w	r6,r8
8000bc0e:	c0 64       	brge	8000bc1a <_vfprintf_r+0xe46>
8000bc10:	fa cb f9 44 	sub	r11,sp,-1724
8000bc14:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc18:	c1 f8       	rjmp	8000bc56 <_vfprintf_r+0xe82>
8000bc1a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc1e:	1a d8       	st.w	--sp,r8
8000bc20:	fa c8 fa b8 	sub	r8,sp,-1352
8000bc24:	1a d8       	st.w	--sp,r8
8000bc26:	fa c8 fb b4 	sub	r8,sp,-1100
8000bc2a:	1a d8       	st.w	--sp,r8
8000bc2c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bc30:	fa c9 ff b4 	sub	r9,sp,-76
8000bc34:	04 9a       	mov	r10,r2
8000bc36:	0c 9b       	mov	r11,r6
8000bc38:	08 9c       	mov	r12,r4
8000bc3a:	fe b0 f7 2f 	rcall	8000aa98 <get_arg>
8000bc3e:	2f dd       	sub	sp,-12
8000bc40:	98 18       	ld.sh	r8,r12[0x2]
8000bc42:	c2 68       	rjmp	8000bc8e <_vfprintf_r+0xeba>
8000bc44:	ee ca ff ff 	sub	r10,r7,-1
8000bc48:	10 37       	cp.w	r7,r8
8000bc4a:	c0 94       	brge	8000bc5c <_vfprintf_r+0xe88>
8000bc4c:	fa c9 f9 44 	sub	r9,sp,-1724
8000bc50:	14 97       	mov	r7,r10
8000bc52:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bc56:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bc5a:	c1 a8       	rjmp	8000bc8e <_vfprintf_r+0xeba>
8000bc5c:	41 09       	lddsp	r9,sp[0x40]
8000bc5e:	59 f8       	cp.w	r8,31
8000bc60:	e0 89 00 13 	brgt	8000bc86 <_vfprintf_r+0xeb2>
8000bc64:	f2 cb ff fc 	sub	r11,r9,-4
8000bc68:	51 0b       	stdsp	sp[0x40],r11
8000bc6a:	72 09       	ld.w	r9,r9[0x0]
8000bc6c:	fa c6 f9 44 	sub	r6,sp,-1724
8000bc70:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bc74:	2f f8       	sub	r8,-1
8000bc76:	f7 49 fd 88 	st.w	r11[-632],r9
8000bc7a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bc7e:	14 97       	mov	r7,r10
8000bc80:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bc84:	c0 58       	rjmp	8000bc8e <_vfprintf_r+0xeba>
8000bc86:	92 18       	ld.sh	r8,r9[0x2]
8000bc88:	14 97       	mov	r7,r10
8000bc8a:	2f c9       	sub	r9,-4
8000bc8c:	51 09       	stdsp	sp[0x40],r9
8000bc8e:	5c 78       	castu.h	r8
8000bc90:	50 18       	stdsp	sp[0x4],r8
8000bc92:	c4 68       	rjmp	8000bd1e <_vfprintf_r+0xf4a>
8000bc94:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc98:	40 3c       	lddsp	r12,sp[0xc]
8000bc9a:	58 0c       	cp.w	r12,0
8000bc9c:	c1 d0       	breq	8000bcd6 <_vfprintf_r+0xf02>
8000bc9e:	10 36       	cp.w	r6,r8
8000bca0:	c0 64       	brge	8000bcac <_vfprintf_r+0xed8>
8000bca2:	fa cb f9 44 	sub	r11,sp,-1724
8000bca6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bcaa:	c1 f8       	rjmp	8000bce8 <_vfprintf_r+0xf14>
8000bcac:	fa c8 f9 50 	sub	r8,sp,-1712
8000bcb0:	1a d8       	st.w	--sp,r8
8000bcb2:	fa c8 fa b8 	sub	r8,sp,-1352
8000bcb6:	0c 9b       	mov	r11,r6
8000bcb8:	1a d8       	st.w	--sp,r8
8000bcba:	fa c8 fb b4 	sub	r8,sp,-1100
8000bcbe:	04 9a       	mov	r10,r2
8000bcc0:	1a d8       	st.w	--sp,r8
8000bcc2:	08 9c       	mov	r12,r4
8000bcc4:	fa c8 f9 40 	sub	r8,sp,-1728
8000bcc8:	fa c9 ff b4 	sub	r9,sp,-76
8000bccc:	fe b0 f6 e6 	rcall	8000aa98 <get_arg>
8000bcd0:	2f dd       	sub	sp,-12
8000bcd2:	78 0b       	ld.w	r11,r12[0x0]
8000bcd4:	c2 48       	rjmp	8000bd1c <_vfprintf_r+0xf48>
8000bcd6:	ee ca ff ff 	sub	r10,r7,-1
8000bcda:	10 37       	cp.w	r7,r8
8000bcdc:	c0 94       	brge	8000bcee <_vfprintf_r+0xf1a>
8000bcde:	fa c9 f9 44 	sub	r9,sp,-1724
8000bce2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bce6:	14 97       	mov	r7,r10
8000bce8:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bcec:	c1 88       	rjmp	8000bd1c <_vfprintf_r+0xf48>
8000bcee:	41 09       	lddsp	r9,sp[0x40]
8000bcf0:	59 f8       	cp.w	r8,31
8000bcf2:	e0 89 00 11 	brgt	8000bd14 <_vfprintf_r+0xf40>
8000bcf6:	f2 cb ff fc 	sub	r11,r9,-4
8000bcfa:	51 0b       	stdsp	sp[0x40],r11
8000bcfc:	fa c6 f9 44 	sub	r6,sp,-1724
8000bd00:	72 0b       	ld.w	r11,r9[0x0]
8000bd02:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bd06:	f3 4b fd 88 	st.w	r9[-632],r11
8000bd0a:	2f f8       	sub	r8,-1
8000bd0c:	14 97       	mov	r7,r10
8000bd0e:	fb 48 06 b4 	st.w	sp[1716],r8
8000bd12:	c0 58       	rjmp	8000bd1c <_vfprintf_r+0xf48>
8000bd14:	72 0b       	ld.w	r11,r9[0x0]
8000bd16:	14 97       	mov	r7,r10
8000bd18:	2f c9       	sub	r9,-4
8000bd1a:	51 09       	stdsp	sp[0x40],r9
8000bd1c:	50 1b       	stdsp	sp[0x4],r11
8000bd1e:	30 0e       	mov	lr,0
8000bd20:	50 0e       	stdsp	sp[0x0],lr
8000bd22:	1c 98       	mov	r8,lr
8000bd24:	e0 8f 02 fe 	bral	8000c320 <_vfprintf_r+0x154c>
8000bd28:	50 a7       	stdsp	sp[0x28],r7
8000bd2a:	50 80       	stdsp	sp[0x20],r0
8000bd2c:	0c 97       	mov	r7,r6
8000bd2e:	04 94       	mov	r4,r2
8000bd30:	06 96       	mov	r6,r3
8000bd32:	02 92       	mov	r2,r1
8000bd34:	40 93       	lddsp	r3,sp[0x24]
8000bd36:	40 41       	lddsp	r1,sp[0x10]
8000bd38:	0e 99       	mov	r9,r7
8000bd3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd3e:	40 3c       	lddsp	r12,sp[0xc]
8000bd40:	58 0c       	cp.w	r12,0
8000bd42:	c1 d0       	breq	8000bd7c <_vfprintf_r+0xfa8>
8000bd44:	10 36       	cp.w	r6,r8
8000bd46:	c0 64       	brge	8000bd52 <_vfprintf_r+0xf7e>
8000bd48:	fa cb f9 44 	sub	r11,sp,-1724
8000bd4c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bd50:	c1 d8       	rjmp	8000bd8a <_vfprintf_r+0xfb6>
8000bd52:	fa c8 f9 50 	sub	r8,sp,-1712
8000bd56:	1a d8       	st.w	--sp,r8
8000bd58:	fa c8 fa b8 	sub	r8,sp,-1352
8000bd5c:	1a d8       	st.w	--sp,r8
8000bd5e:	fa c8 fb b4 	sub	r8,sp,-1100
8000bd62:	1a d8       	st.w	--sp,r8
8000bd64:	fa c9 ff b4 	sub	r9,sp,-76
8000bd68:	fa c8 f9 40 	sub	r8,sp,-1728
8000bd6c:	04 9a       	mov	r10,r2
8000bd6e:	0c 9b       	mov	r11,r6
8000bd70:	08 9c       	mov	r12,r4
8000bd72:	fe b0 f6 93 	rcall	8000aa98 <get_arg>
8000bd76:	2f dd       	sub	sp,-12
8000bd78:	78 09       	ld.w	r9,r12[0x0]
8000bd7a:	c2 18       	rjmp	8000bdbc <_vfprintf_r+0xfe8>
8000bd7c:	2f f7       	sub	r7,-1
8000bd7e:	10 39       	cp.w	r9,r8
8000bd80:	c0 84       	brge	8000bd90 <_vfprintf_r+0xfbc>
8000bd82:	fa ca f9 44 	sub	r10,sp,-1724
8000bd86:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bd8a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000bd8e:	c1 78       	rjmp	8000bdbc <_vfprintf_r+0xfe8>
8000bd90:	41 09       	lddsp	r9,sp[0x40]
8000bd92:	59 f8       	cp.w	r8,31
8000bd94:	e0 89 00 10 	brgt	8000bdb4 <_vfprintf_r+0xfe0>
8000bd98:	f2 ca ff fc 	sub	r10,r9,-4
8000bd9c:	51 0a       	stdsp	sp[0x40],r10
8000bd9e:	fa c6 f9 44 	sub	r6,sp,-1724
8000bda2:	72 09       	ld.w	r9,r9[0x0]
8000bda4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000bda8:	f5 49 fd 88 	st.w	r10[-632],r9
8000bdac:	2f f8       	sub	r8,-1
8000bdae:	fb 48 06 b4 	st.w	sp[1716],r8
8000bdb2:	c0 58       	rjmp	8000bdbc <_vfprintf_r+0xfe8>
8000bdb4:	f2 c8 ff fc 	sub	r8,r9,-4
8000bdb8:	51 08       	stdsp	sp[0x40],r8
8000bdba:	72 09       	ld.w	r9,r9[0x0]
8000bdbc:	33 08       	mov	r8,48
8000bdbe:	fb 68 06 b8 	st.b	sp[1720],r8
8000bdc2:	37 88       	mov	r8,120
8000bdc4:	30 0e       	mov	lr,0
8000bdc6:	fb 68 06 b9 	st.b	sp[1721],r8
8000bdca:	4c ac       	lddpc	r12,8000bef0 <_vfprintf_r+0x111c>
8000bdcc:	50 19       	stdsp	sp[0x4],r9
8000bdce:	a1 b5       	sbr	r5,0x1
8000bdd0:	50 0e       	stdsp	sp[0x0],lr
8000bdd2:	50 dc       	stdsp	sp[0x34],r12
8000bdd4:	30 28       	mov	r8,2
8000bdd6:	37 80       	mov	r0,120
8000bdd8:	e0 8f 02 a4 	bral	8000c320 <_vfprintf_r+0x154c>
8000bddc:	50 a7       	stdsp	sp[0x28],r7
8000bdde:	50 80       	stdsp	sp[0x20],r0
8000bde0:	10 90       	mov	r0,r8
8000bde2:	30 08       	mov	r8,0
8000bde4:	fb 68 06 bb 	st.b	sp[1723],r8
8000bde8:	0c 97       	mov	r7,r6
8000bdea:	04 94       	mov	r4,r2
8000bdec:	06 96       	mov	r6,r3
8000bdee:	02 92       	mov	r2,r1
8000bdf0:	40 93       	lddsp	r3,sp[0x24]
8000bdf2:	40 41       	lddsp	r1,sp[0x10]
8000bdf4:	0e 99       	mov	r9,r7
8000bdf6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bdfa:	40 3b       	lddsp	r11,sp[0xc]
8000bdfc:	58 0b       	cp.w	r11,0
8000bdfe:	c1 d0       	breq	8000be38 <_vfprintf_r+0x1064>
8000be00:	10 36       	cp.w	r6,r8
8000be02:	c0 64       	brge	8000be0e <_vfprintf_r+0x103a>
8000be04:	fa ca f9 44 	sub	r10,sp,-1724
8000be08:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000be0c:	c1 d8       	rjmp	8000be46 <_vfprintf_r+0x1072>
8000be0e:	fa c8 f9 50 	sub	r8,sp,-1712
8000be12:	1a d8       	st.w	--sp,r8
8000be14:	fa c8 fa b8 	sub	r8,sp,-1352
8000be18:	1a d8       	st.w	--sp,r8
8000be1a:	fa c8 fb b4 	sub	r8,sp,-1100
8000be1e:	0c 9b       	mov	r11,r6
8000be20:	1a d8       	st.w	--sp,r8
8000be22:	04 9a       	mov	r10,r2
8000be24:	fa c8 f9 40 	sub	r8,sp,-1728
8000be28:	fa c9 ff b4 	sub	r9,sp,-76
8000be2c:	08 9c       	mov	r12,r4
8000be2e:	fe b0 f6 35 	rcall	8000aa98 <get_arg>
8000be32:	2f dd       	sub	sp,-12
8000be34:	78 06       	ld.w	r6,r12[0x0]
8000be36:	c2 08       	rjmp	8000be76 <_vfprintf_r+0x10a2>
8000be38:	2f f7       	sub	r7,-1
8000be3a:	10 39       	cp.w	r9,r8
8000be3c:	c0 84       	brge	8000be4c <_vfprintf_r+0x1078>
8000be3e:	fa c9 f9 44 	sub	r9,sp,-1724
8000be42:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000be46:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000be4a:	c1 68       	rjmp	8000be76 <_vfprintf_r+0x10a2>
8000be4c:	41 09       	lddsp	r9,sp[0x40]
8000be4e:	59 f8       	cp.w	r8,31
8000be50:	e0 89 00 10 	brgt	8000be70 <_vfprintf_r+0x109c>
8000be54:	f2 ca ff fc 	sub	r10,r9,-4
8000be58:	51 0a       	stdsp	sp[0x40],r10
8000be5a:	72 06       	ld.w	r6,r9[0x0]
8000be5c:	fa ce f9 44 	sub	lr,sp,-1724
8000be60:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000be64:	f3 46 fd 88 	st.w	r9[-632],r6
8000be68:	2f f8       	sub	r8,-1
8000be6a:	fb 48 06 b4 	st.w	sp[1716],r8
8000be6e:	c0 48       	rjmp	8000be76 <_vfprintf_r+0x10a2>
8000be70:	72 06       	ld.w	r6,r9[0x0]
8000be72:	2f c9       	sub	r9,-4
8000be74:	51 09       	stdsp	sp[0x40],r9
8000be76:	40 2c       	lddsp	r12,sp[0x8]
8000be78:	58 0c       	cp.w	r12,0
8000be7a:	c1 05       	brlt	8000be9a <_vfprintf_r+0x10c6>
8000be7c:	18 9a       	mov	r10,r12
8000be7e:	30 0b       	mov	r11,0
8000be80:	0c 9c       	mov	r12,r6
8000be82:	e0 a0 12 43 	rcall	8000e308 <memchr>
8000be86:	e0 80 02 e0 	breq	8000c446 <_vfprintf_r+0x1672>
8000be8a:	f8 06 01 02 	sub	r2,r12,r6
8000be8e:	40 2b       	lddsp	r11,sp[0x8]
8000be90:	16 32       	cp.w	r2,r11
8000be92:	e0 89 02 da 	brgt	8000c446 <_vfprintf_r+0x1672>
8000be96:	e0 8f 02 d5 	bral	8000c440 <_vfprintf_r+0x166c>
8000be9a:	30 0a       	mov	r10,0
8000be9c:	0c 9c       	mov	r12,r6
8000be9e:	50 2a       	stdsp	sp[0x8],r10
8000bea0:	fe b0 f4 ff 	rcall	8000a89e <strlen>
8000bea4:	18 92       	mov	r2,r12
8000bea6:	e0 8f 02 d3 	bral	8000c44c <_vfprintf_r+0x1678>
8000beaa:	50 a7       	stdsp	sp[0x28],r7
8000beac:	50 80       	stdsp	sp[0x20],r0
8000beae:	0c 97       	mov	r7,r6
8000beb0:	04 94       	mov	r4,r2
8000beb2:	06 96       	mov	r6,r3
8000beb4:	02 92       	mov	r2,r1
8000beb6:	40 93       	lddsp	r3,sp[0x24]
8000beb8:	10 90       	mov	r0,r8
8000beba:	40 41       	lddsp	r1,sp[0x10]
8000bebc:	a5 a5       	sbr	r5,0x4
8000bebe:	c0 a8       	rjmp	8000bed2 <_vfprintf_r+0x10fe>
8000bec0:	50 a7       	stdsp	sp[0x28],r7
8000bec2:	50 80       	stdsp	sp[0x20],r0
8000bec4:	0c 97       	mov	r7,r6
8000bec6:	04 94       	mov	r4,r2
8000bec8:	06 96       	mov	r6,r3
8000beca:	02 92       	mov	r2,r1
8000becc:	40 93       	lddsp	r3,sp[0x24]
8000bece:	10 90       	mov	r0,r8
8000bed0:	40 41       	lddsp	r1,sp[0x10]
8000bed2:	ed b5 00 05 	bld	r5,0x5
8000bed6:	c5 71       	brne	8000bf84 <_vfprintf_r+0x11b0>
8000bed8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bedc:	40 39       	lddsp	r9,sp[0xc]
8000bede:	58 09       	cp.w	r9,0
8000bee0:	c2 20       	breq	8000bf24 <_vfprintf_r+0x1150>
8000bee2:	10 36       	cp.w	r6,r8
8000bee4:	c0 84       	brge	8000bef4 <_vfprintf_r+0x1120>
8000bee6:	fa c8 f9 44 	sub	r8,sp,-1724
8000beea:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000beee:	c2 48       	rjmp	8000bf36 <_vfprintf_r+0x1162>
8000bef0:	80 01       	ld.sh	r1,r0[0x0]
8000bef2:	8f 88       	st.w	r7[0x20],r8
8000bef4:	fa c8 f9 50 	sub	r8,sp,-1712
8000bef8:	1a d8       	st.w	--sp,r8
8000befa:	fa c8 fa b8 	sub	r8,sp,-1352
8000befe:	1a d8       	st.w	--sp,r8
8000bf00:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf04:	1a d8       	st.w	--sp,r8
8000bf06:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf0a:	fa c9 ff b4 	sub	r9,sp,-76
8000bf0e:	04 9a       	mov	r10,r2
8000bf10:	0c 9b       	mov	r11,r6
8000bf12:	08 9c       	mov	r12,r4
8000bf14:	fe b0 f5 c2 	rcall	8000aa98 <get_arg>
8000bf18:	2f dd       	sub	sp,-12
8000bf1a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000bf1e:	fa e9 00 00 	st.d	sp[0],r8
8000bf22:	c2 e8       	rjmp	8000bf7e <_vfprintf_r+0x11aa>
8000bf24:	ee ca ff ff 	sub	r10,r7,-1
8000bf28:	10 37       	cp.w	r7,r8
8000bf2a:	c0 b4       	brge	8000bf40 <_vfprintf_r+0x116c>
8000bf2c:	fa c8 f9 44 	sub	r8,sp,-1724
8000bf30:	14 97       	mov	r7,r10
8000bf32:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000bf36:	ec ea fd 88 	ld.d	r10,r6[-632]
8000bf3a:	fa eb 00 00 	st.d	sp[0],r10
8000bf3e:	c2 08       	rjmp	8000bf7e <_vfprintf_r+0x11aa>
8000bf40:	41 09       	lddsp	r9,sp[0x40]
8000bf42:	59 f8       	cp.w	r8,31
8000bf44:	e0 89 00 16 	brgt	8000bf70 <_vfprintf_r+0x119c>
8000bf48:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bf4c:	f2 cb ff f8 	sub	r11,r9,-8
8000bf50:	fa e7 00 00 	st.d	sp[0],r6
8000bf54:	51 0b       	stdsp	sp[0x40],r11
8000bf56:	fa c6 f9 44 	sub	r6,sp,-1724
8000bf5a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bf5e:	fa e6 00 00 	ld.d	r6,sp[0]
8000bf62:	f2 e7 fd 88 	st.d	r9[-632],r6
8000bf66:	2f f8       	sub	r8,-1
8000bf68:	14 97       	mov	r7,r10
8000bf6a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf6e:	c0 88       	rjmp	8000bf7e <_vfprintf_r+0x11aa>
8000bf70:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bf74:	2f 89       	sub	r9,-8
8000bf76:	fa e7 00 00 	st.d	sp[0],r6
8000bf7a:	51 09       	stdsp	sp[0x40],r9
8000bf7c:	14 97       	mov	r7,r10
8000bf7e:	30 18       	mov	r8,1
8000bf80:	e0 8f 01 d0 	bral	8000c320 <_vfprintf_r+0x154c>
8000bf84:	ed b5 00 04 	bld	r5,0x4
8000bf88:	c1 61       	brne	8000bfb4 <_vfprintf_r+0x11e0>
8000bf8a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf8e:	40 3e       	lddsp	lr,sp[0xc]
8000bf90:	58 0e       	cp.w	lr,0
8000bf92:	c0 80       	breq	8000bfa2 <_vfprintf_r+0x11ce>
8000bf94:	10 36       	cp.w	r6,r8
8000bf96:	c6 74       	brge	8000c064 <_vfprintf_r+0x1290>
8000bf98:	fa cc f9 44 	sub	r12,sp,-1724
8000bf9c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bfa0:	c8 08       	rjmp	8000c0a0 <_vfprintf_r+0x12cc>
8000bfa2:	ee ca ff ff 	sub	r10,r7,-1
8000bfa6:	10 37       	cp.w	r7,r8
8000bfa8:	c7 f4       	brge	8000c0a6 <_vfprintf_r+0x12d2>
8000bfaa:	fa cb f9 44 	sub	r11,sp,-1724
8000bfae:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bfb2:	c7 68       	rjmp	8000c09e <_vfprintf_r+0x12ca>
8000bfb4:	ed b5 00 06 	bld	r5,0x6
8000bfb8:	c4 a1       	brne	8000c04c <_vfprintf_r+0x1278>
8000bfba:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bfbe:	40 3c       	lddsp	r12,sp[0xc]
8000bfc0:	58 0c       	cp.w	r12,0
8000bfc2:	c1 d0       	breq	8000bffc <_vfprintf_r+0x1228>
8000bfc4:	10 36       	cp.w	r6,r8
8000bfc6:	c0 64       	brge	8000bfd2 <_vfprintf_r+0x11fe>
8000bfc8:	fa cb f9 44 	sub	r11,sp,-1724
8000bfcc:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bfd0:	c1 f8       	rjmp	8000c00e <_vfprintf_r+0x123a>
8000bfd2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bfd6:	1a d8       	st.w	--sp,r8
8000bfd8:	fa c8 fa b8 	sub	r8,sp,-1352
8000bfdc:	1a d8       	st.w	--sp,r8
8000bfde:	fa c8 fb b4 	sub	r8,sp,-1100
8000bfe2:	1a d8       	st.w	--sp,r8
8000bfe4:	fa c8 f9 40 	sub	r8,sp,-1728
8000bfe8:	fa c9 ff b4 	sub	r9,sp,-76
8000bfec:	04 9a       	mov	r10,r2
8000bfee:	0c 9b       	mov	r11,r6
8000bff0:	08 9c       	mov	r12,r4
8000bff2:	fe b0 f5 53 	rcall	8000aa98 <get_arg>
8000bff6:	2f dd       	sub	sp,-12
8000bff8:	98 18       	ld.sh	r8,r12[0x2]
8000bffa:	c2 68       	rjmp	8000c046 <_vfprintf_r+0x1272>
8000bffc:	ee ca ff ff 	sub	r10,r7,-1
8000c000:	10 37       	cp.w	r7,r8
8000c002:	c0 94       	brge	8000c014 <_vfprintf_r+0x1240>
8000c004:	fa c9 f9 44 	sub	r9,sp,-1724
8000c008:	14 97       	mov	r7,r10
8000c00a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c00e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c012:	c1 a8       	rjmp	8000c046 <_vfprintf_r+0x1272>
8000c014:	41 09       	lddsp	r9,sp[0x40]
8000c016:	59 f8       	cp.w	r8,31
8000c018:	e0 89 00 13 	brgt	8000c03e <_vfprintf_r+0x126a>
8000c01c:	f2 cb ff fc 	sub	r11,r9,-4
8000c020:	51 0b       	stdsp	sp[0x40],r11
8000c022:	72 09       	ld.w	r9,r9[0x0]
8000c024:	fa c6 f9 44 	sub	r6,sp,-1724
8000c028:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c02c:	2f f8       	sub	r8,-1
8000c02e:	f7 49 fd 88 	st.w	r11[-632],r9
8000c032:	fb 48 06 b4 	st.w	sp[1716],r8
8000c036:	14 97       	mov	r7,r10
8000c038:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c03c:	c0 58       	rjmp	8000c046 <_vfprintf_r+0x1272>
8000c03e:	92 18       	ld.sh	r8,r9[0x2]
8000c040:	14 97       	mov	r7,r10
8000c042:	2f c9       	sub	r9,-4
8000c044:	51 09       	stdsp	sp[0x40],r9
8000c046:	5c 78       	castu.h	r8
8000c048:	50 18       	stdsp	sp[0x4],r8
8000c04a:	c4 68       	rjmp	8000c0d6 <_vfprintf_r+0x1302>
8000c04c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c050:	40 3c       	lddsp	r12,sp[0xc]
8000c052:	58 0c       	cp.w	r12,0
8000c054:	c1 d0       	breq	8000c08e <_vfprintf_r+0x12ba>
8000c056:	10 36       	cp.w	r6,r8
8000c058:	c0 64       	brge	8000c064 <_vfprintf_r+0x1290>
8000c05a:	fa cb f9 44 	sub	r11,sp,-1724
8000c05e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c062:	c1 f8       	rjmp	8000c0a0 <_vfprintf_r+0x12cc>
8000c064:	fa c8 f9 50 	sub	r8,sp,-1712
8000c068:	1a d8       	st.w	--sp,r8
8000c06a:	fa c8 fa b8 	sub	r8,sp,-1352
8000c06e:	0c 9b       	mov	r11,r6
8000c070:	1a d8       	st.w	--sp,r8
8000c072:	fa c8 fb b4 	sub	r8,sp,-1100
8000c076:	04 9a       	mov	r10,r2
8000c078:	1a d8       	st.w	--sp,r8
8000c07a:	08 9c       	mov	r12,r4
8000c07c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c080:	fa c9 ff b4 	sub	r9,sp,-76
8000c084:	fe b0 f5 0a 	rcall	8000aa98 <get_arg>
8000c088:	2f dd       	sub	sp,-12
8000c08a:	78 0b       	ld.w	r11,r12[0x0]
8000c08c:	c2 48       	rjmp	8000c0d4 <_vfprintf_r+0x1300>
8000c08e:	ee ca ff ff 	sub	r10,r7,-1
8000c092:	10 37       	cp.w	r7,r8
8000c094:	c0 94       	brge	8000c0a6 <_vfprintf_r+0x12d2>
8000c096:	fa c9 f9 44 	sub	r9,sp,-1724
8000c09a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c09e:	14 97       	mov	r7,r10
8000c0a0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c0a4:	c1 88       	rjmp	8000c0d4 <_vfprintf_r+0x1300>
8000c0a6:	41 09       	lddsp	r9,sp[0x40]
8000c0a8:	59 f8       	cp.w	r8,31
8000c0aa:	e0 89 00 11 	brgt	8000c0cc <_vfprintf_r+0x12f8>
8000c0ae:	f2 cb ff fc 	sub	r11,r9,-4
8000c0b2:	51 0b       	stdsp	sp[0x40],r11
8000c0b4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c0b8:	72 0b       	ld.w	r11,r9[0x0]
8000c0ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c0be:	f3 4b fd 88 	st.w	r9[-632],r11
8000c0c2:	2f f8       	sub	r8,-1
8000c0c4:	14 97       	mov	r7,r10
8000c0c6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c0ca:	c0 58       	rjmp	8000c0d4 <_vfprintf_r+0x1300>
8000c0cc:	72 0b       	ld.w	r11,r9[0x0]
8000c0ce:	14 97       	mov	r7,r10
8000c0d0:	2f c9       	sub	r9,-4
8000c0d2:	51 09       	stdsp	sp[0x40],r9
8000c0d4:	50 1b       	stdsp	sp[0x4],r11
8000c0d6:	30 0e       	mov	lr,0
8000c0d8:	30 18       	mov	r8,1
8000c0da:	50 0e       	stdsp	sp[0x0],lr
8000c0dc:	c2 29       	rjmp	8000c320 <_vfprintf_r+0x154c>
8000c0de:	50 a7       	stdsp	sp[0x28],r7
8000c0e0:	50 80       	stdsp	sp[0x20],r0
8000c0e2:	0c 97       	mov	r7,r6
8000c0e4:	04 94       	mov	r4,r2
8000c0e6:	06 96       	mov	r6,r3
8000c0e8:	02 92       	mov	r2,r1
8000c0ea:	4d 3c       	lddpc	r12,8000c234 <_vfprintf_r+0x1460>
8000c0ec:	40 93       	lddsp	r3,sp[0x24]
8000c0ee:	10 90       	mov	r0,r8
8000c0f0:	40 41       	lddsp	r1,sp[0x10]
8000c0f2:	50 dc       	stdsp	sp[0x34],r12
8000c0f4:	ed b5 00 05 	bld	r5,0x5
8000c0f8:	c5 51       	brne	8000c1a2 <_vfprintf_r+0x13ce>
8000c0fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0fe:	40 3b       	lddsp	r11,sp[0xc]
8000c100:	58 0b       	cp.w	r11,0
8000c102:	c2 20       	breq	8000c146 <_vfprintf_r+0x1372>
8000c104:	10 36       	cp.w	r6,r8
8000c106:	c0 a4       	brge	8000c11a <_vfprintf_r+0x1346>
8000c108:	fa ca f9 44 	sub	r10,sp,-1724
8000c10c:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c110:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c114:	fa e9 00 00 	st.d	sp[0],r8
8000c118:	cf 38       	rjmp	8000c2fe <_vfprintf_r+0x152a>
8000c11a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c11e:	1a d8       	st.w	--sp,r8
8000c120:	fa c8 fa b8 	sub	r8,sp,-1352
8000c124:	04 9a       	mov	r10,r2
8000c126:	1a d8       	st.w	--sp,r8
8000c128:	0c 9b       	mov	r11,r6
8000c12a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c12e:	08 9c       	mov	r12,r4
8000c130:	1a d8       	st.w	--sp,r8
8000c132:	fa c8 f9 40 	sub	r8,sp,-1728
8000c136:	fa c9 ff b4 	sub	r9,sp,-76
8000c13a:	fe b0 f4 af 	rcall	8000aa98 <get_arg>
8000c13e:	2f dd       	sub	sp,-12
8000c140:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c144:	c0 c8       	rjmp	8000c15c <_vfprintf_r+0x1388>
8000c146:	ee ca ff ff 	sub	r10,r7,-1
8000c14a:	10 37       	cp.w	r7,r8
8000c14c:	c0 b4       	brge	8000c162 <_vfprintf_r+0x138e>
8000c14e:	fa c9 f9 44 	sub	r9,sp,-1724
8000c152:	14 97       	mov	r7,r10
8000c154:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c158:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c15c:	fa eb 00 00 	st.d	sp[0],r10
8000c160:	cc f8       	rjmp	8000c2fe <_vfprintf_r+0x152a>
8000c162:	41 09       	lddsp	r9,sp[0x40]
8000c164:	59 f8       	cp.w	r8,31
8000c166:	e0 89 00 16 	brgt	8000c192 <_vfprintf_r+0x13be>
8000c16a:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c16e:	f2 cb ff f8 	sub	r11,r9,-8
8000c172:	fa e7 00 00 	st.d	sp[0],r6
8000c176:	51 0b       	stdsp	sp[0x40],r11
8000c178:	fa c6 f9 44 	sub	r6,sp,-1724
8000c17c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c180:	fa e6 00 00 	ld.d	r6,sp[0]
8000c184:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c188:	2f f8       	sub	r8,-1
8000c18a:	14 97       	mov	r7,r10
8000c18c:	fb 48 06 b4 	st.w	sp[1716],r8
8000c190:	cb 78       	rjmp	8000c2fe <_vfprintf_r+0x152a>
8000c192:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c196:	2f 89       	sub	r9,-8
8000c198:	fa e7 00 00 	st.d	sp[0],r6
8000c19c:	51 09       	stdsp	sp[0x40],r9
8000c19e:	14 97       	mov	r7,r10
8000c1a0:	ca f8       	rjmp	8000c2fe <_vfprintf_r+0x152a>
8000c1a2:	ed b5 00 04 	bld	r5,0x4
8000c1a6:	c1 71       	brne	8000c1d4 <_vfprintf_r+0x1400>
8000c1a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c1ac:	40 3e       	lddsp	lr,sp[0xc]
8000c1ae:	58 0e       	cp.w	lr,0
8000c1b0:	c0 80       	breq	8000c1c0 <_vfprintf_r+0x13ec>
8000c1b2:	10 36       	cp.w	r6,r8
8000c1b4:	c6 a4       	brge	8000c288 <_vfprintf_r+0x14b4>
8000c1b6:	fa cc f9 44 	sub	r12,sp,-1724
8000c1ba:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c1be:	c8 38       	rjmp	8000c2c4 <_vfprintf_r+0x14f0>
8000c1c0:	ee ca ff ff 	sub	r10,r7,-1
8000c1c4:	10 37       	cp.w	r7,r8
8000c1c6:	e0 84 00 82 	brge	8000c2ca <_vfprintf_r+0x14f6>
8000c1ca:	fa cb f9 44 	sub	r11,sp,-1724
8000c1ce:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c1d2:	c7 88       	rjmp	8000c2c2 <_vfprintf_r+0x14ee>
8000c1d4:	ed b5 00 06 	bld	r5,0x6
8000c1d8:	c4 c1       	brne	8000c270 <_vfprintf_r+0x149c>
8000c1da:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c1de:	40 3c       	lddsp	r12,sp[0xc]
8000c1e0:	58 0c       	cp.w	r12,0
8000c1e2:	c1 d0       	breq	8000c21c <_vfprintf_r+0x1448>
8000c1e4:	10 36       	cp.w	r6,r8
8000c1e6:	c0 64       	brge	8000c1f2 <_vfprintf_r+0x141e>
8000c1e8:	fa cb f9 44 	sub	r11,sp,-1724
8000c1ec:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c1f0:	c1 f8       	rjmp	8000c22e <_vfprintf_r+0x145a>
8000c1f2:	fa c8 f9 50 	sub	r8,sp,-1712
8000c1f6:	1a d8       	st.w	--sp,r8
8000c1f8:	fa c8 fa b8 	sub	r8,sp,-1352
8000c1fc:	1a d8       	st.w	--sp,r8
8000c1fe:	fa c8 fb b4 	sub	r8,sp,-1100
8000c202:	1a d8       	st.w	--sp,r8
8000c204:	fa c8 f9 40 	sub	r8,sp,-1728
8000c208:	fa c9 ff b4 	sub	r9,sp,-76
8000c20c:	04 9a       	mov	r10,r2
8000c20e:	0c 9b       	mov	r11,r6
8000c210:	08 9c       	mov	r12,r4
8000c212:	fe b0 f4 43 	rcall	8000aa98 <get_arg>
8000c216:	2f dd       	sub	sp,-12
8000c218:	98 18       	ld.sh	r8,r12[0x2]
8000c21a:	c2 88       	rjmp	8000c26a <_vfprintf_r+0x1496>
8000c21c:	ee ca ff ff 	sub	r10,r7,-1
8000c220:	10 37       	cp.w	r7,r8
8000c222:	c0 b4       	brge	8000c238 <_vfprintf_r+0x1464>
8000c224:	fa c9 f9 44 	sub	r9,sp,-1724
8000c228:	14 97       	mov	r7,r10
8000c22a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c22e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c232:	c1 c8       	rjmp	8000c26a <_vfprintf_r+0x1496>
8000c234:	80 01       	ld.sh	r1,r0[0x0]
8000c236:	8f 88       	st.w	r7[0x20],r8
8000c238:	41 09       	lddsp	r9,sp[0x40]
8000c23a:	59 f8       	cp.w	r8,31
8000c23c:	e0 89 00 13 	brgt	8000c262 <_vfprintf_r+0x148e>
8000c240:	f2 cb ff fc 	sub	r11,r9,-4
8000c244:	51 0b       	stdsp	sp[0x40],r11
8000c246:	72 09       	ld.w	r9,r9[0x0]
8000c248:	fa c6 f9 44 	sub	r6,sp,-1724
8000c24c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c250:	2f f8       	sub	r8,-1
8000c252:	f7 49 fd 88 	st.w	r11[-632],r9
8000c256:	fb 48 06 b4 	st.w	sp[1716],r8
8000c25a:	14 97       	mov	r7,r10
8000c25c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c260:	c0 58       	rjmp	8000c26a <_vfprintf_r+0x1496>
8000c262:	92 18       	ld.sh	r8,r9[0x2]
8000c264:	14 97       	mov	r7,r10
8000c266:	2f c9       	sub	r9,-4
8000c268:	51 09       	stdsp	sp[0x40],r9
8000c26a:	5c 78       	castu.h	r8
8000c26c:	50 18       	stdsp	sp[0x4],r8
8000c26e:	c4 68       	rjmp	8000c2fa <_vfprintf_r+0x1526>
8000c270:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c274:	40 3c       	lddsp	r12,sp[0xc]
8000c276:	58 0c       	cp.w	r12,0
8000c278:	c1 d0       	breq	8000c2b2 <_vfprintf_r+0x14de>
8000c27a:	10 36       	cp.w	r6,r8
8000c27c:	c0 64       	brge	8000c288 <_vfprintf_r+0x14b4>
8000c27e:	fa cb f9 44 	sub	r11,sp,-1724
8000c282:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c286:	c1 f8       	rjmp	8000c2c4 <_vfprintf_r+0x14f0>
8000c288:	fa c8 f9 50 	sub	r8,sp,-1712
8000c28c:	1a d8       	st.w	--sp,r8
8000c28e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c292:	0c 9b       	mov	r11,r6
8000c294:	1a d8       	st.w	--sp,r8
8000c296:	fa c8 fb b4 	sub	r8,sp,-1100
8000c29a:	04 9a       	mov	r10,r2
8000c29c:	1a d8       	st.w	--sp,r8
8000c29e:	08 9c       	mov	r12,r4
8000c2a0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c2a4:	fa c9 ff b4 	sub	r9,sp,-76
8000c2a8:	fe b0 f3 f8 	rcall	8000aa98 <get_arg>
8000c2ac:	2f dd       	sub	sp,-12
8000c2ae:	78 0b       	ld.w	r11,r12[0x0]
8000c2b0:	c2 48       	rjmp	8000c2f8 <_vfprintf_r+0x1524>
8000c2b2:	ee ca ff ff 	sub	r10,r7,-1
8000c2b6:	10 37       	cp.w	r7,r8
8000c2b8:	c0 94       	brge	8000c2ca <_vfprintf_r+0x14f6>
8000c2ba:	fa c9 f9 44 	sub	r9,sp,-1724
8000c2be:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c2c2:	14 97       	mov	r7,r10
8000c2c4:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c2c8:	c1 88       	rjmp	8000c2f8 <_vfprintf_r+0x1524>
8000c2ca:	41 09       	lddsp	r9,sp[0x40]
8000c2cc:	59 f8       	cp.w	r8,31
8000c2ce:	e0 89 00 11 	brgt	8000c2f0 <_vfprintf_r+0x151c>
8000c2d2:	f2 cb ff fc 	sub	r11,r9,-4
8000c2d6:	51 0b       	stdsp	sp[0x40],r11
8000c2d8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c2dc:	72 0b       	ld.w	r11,r9[0x0]
8000c2de:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c2e2:	f3 4b fd 88 	st.w	r9[-632],r11
8000c2e6:	2f f8       	sub	r8,-1
8000c2e8:	14 97       	mov	r7,r10
8000c2ea:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2ee:	c0 58       	rjmp	8000c2f8 <_vfprintf_r+0x1524>
8000c2f0:	72 0b       	ld.w	r11,r9[0x0]
8000c2f2:	14 97       	mov	r7,r10
8000c2f4:	2f c9       	sub	r9,-4
8000c2f6:	51 09       	stdsp	sp[0x40],r9
8000c2f8:	50 1b       	stdsp	sp[0x4],r11
8000c2fa:	30 0e       	mov	lr,0
8000c2fc:	50 0e       	stdsp	sp[0x0],lr
8000c2fe:	40 08       	lddsp	r8,sp[0x0]
8000c300:	40 1c       	lddsp	r12,sp[0x4]
8000c302:	18 48       	or	r8,r12
8000c304:	5f 19       	srne	r9
8000c306:	0a 98       	mov	r8,r5
8000c308:	eb e9 00 09 	and	r9,r5,r9
8000c30c:	a1 b8       	sbr	r8,0x1
8000c30e:	58 09       	cp.w	r9,0
8000c310:	c0 70       	breq	8000c31e <_vfprintf_r+0x154a>
8000c312:	10 95       	mov	r5,r8
8000c314:	fb 60 06 b9 	st.b	sp[1721],r0
8000c318:	33 08       	mov	r8,48
8000c31a:	fb 68 06 b8 	st.b	sp[1720],r8
8000c31e:	30 28       	mov	r8,2
8000c320:	30 09       	mov	r9,0
8000c322:	fb 69 06 bb 	st.b	sp[1723],r9
8000c326:	0a 99       	mov	r9,r5
8000c328:	a7 d9       	cbr	r9,0x7
8000c32a:	40 2b       	lddsp	r11,sp[0x8]
8000c32c:	40 16       	lddsp	r6,sp[0x4]
8000c32e:	58 0b       	cp.w	r11,0
8000c330:	5f 1a       	srne	r10
8000c332:	f2 05 17 40 	movge	r5,r9
8000c336:	fa c2 f9 78 	sub	r2,sp,-1672
8000c33a:	40 09       	lddsp	r9,sp[0x0]
8000c33c:	0c 49       	or	r9,r6
8000c33e:	5f 19       	srne	r9
8000c340:	f5 e9 10 09 	or	r9,r10,r9
8000c344:	c5 c0       	breq	8000c3fc <_vfprintf_r+0x1628>
8000c346:	30 19       	mov	r9,1
8000c348:	f2 08 18 00 	cp.b	r8,r9
8000c34c:	c0 60       	breq	8000c358 <_vfprintf_r+0x1584>
8000c34e:	30 29       	mov	r9,2
8000c350:	f2 08 18 00 	cp.b	r8,r9
8000c354:	c0 41       	brne	8000c35c <_vfprintf_r+0x1588>
8000c356:	c3 c8       	rjmp	8000c3ce <_vfprintf_r+0x15fa>
8000c358:	04 96       	mov	r6,r2
8000c35a:	c3 08       	rjmp	8000c3ba <_vfprintf_r+0x15e6>
8000c35c:	04 96       	mov	r6,r2
8000c35e:	fa e8 00 00 	ld.d	r8,sp[0]
8000c362:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c366:	2d 0a       	sub	r10,-48
8000c368:	0c fa       	st.b	--r6,r10
8000c36a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c36e:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c372:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c376:	18 99       	mov	r9,r12
8000c378:	16 98       	mov	r8,r11
8000c37a:	58 08       	cp.w	r8,0
8000c37c:	5c 29       	cpc	r9
8000c37e:	cf 21       	brne	8000c362 <_vfprintf_r+0x158e>
8000c380:	fa e9 00 00 	st.d	sp[0],r8
8000c384:	ed b5 00 00 	bld	r5,0x0
8000c388:	c4 51       	brne	8000c412 <_vfprintf_r+0x163e>
8000c38a:	33 09       	mov	r9,48
8000c38c:	f2 0a 18 00 	cp.b	r10,r9
8000c390:	c4 10       	breq	8000c412 <_vfprintf_r+0x163e>
8000c392:	0c f9       	st.b	--r6,r9
8000c394:	c3 f8       	rjmp	8000c412 <_vfprintf_r+0x163e>
8000c396:	fa ea 00 00 	ld.d	r10,sp[0]
8000c39a:	30 a8       	mov	r8,10
8000c39c:	30 09       	mov	r9,0
8000c39e:	e0 a0 1a 1b 	rcall	8000f7d4 <__avr32_umod64>
8000c3a2:	30 a8       	mov	r8,10
8000c3a4:	2d 0a       	sub	r10,-48
8000c3a6:	30 09       	mov	r9,0
8000c3a8:	ac 8a       	st.b	r6[0x0],r10
8000c3aa:	fa ea 00 00 	ld.d	r10,sp[0]
8000c3ae:	e0 a0 18 e1 	rcall	8000f570 <__avr32_udiv64>
8000c3b2:	16 99       	mov	r9,r11
8000c3b4:	14 98       	mov	r8,r10
8000c3b6:	fa e9 00 00 	st.d	sp[0],r8
8000c3ba:	20 16       	sub	r6,1
8000c3bc:	fa ea 00 00 	ld.d	r10,sp[0]
8000c3c0:	58 9a       	cp.w	r10,9
8000c3c2:	5c 2b       	cpc	r11
8000c3c4:	fe 9b ff e9 	brhi	8000c396 <_vfprintf_r+0x15c2>
8000c3c8:	1b f8       	ld.ub	r8,sp[0x7]
8000c3ca:	2d 08       	sub	r8,-48
8000c3cc:	c2 08       	rjmp	8000c40c <_vfprintf_r+0x1638>
8000c3ce:	04 96       	mov	r6,r2
8000c3d0:	fa e8 00 00 	ld.d	r8,sp[0]
8000c3d4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c3d8:	40 de       	lddsp	lr,sp[0x34]
8000c3da:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c3de:	0c fa       	st.b	--r6,r10
8000c3e0:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c3e4:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c3e8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c3ec:	16 99       	mov	r9,r11
8000c3ee:	14 98       	mov	r8,r10
8000c3f0:	58 08       	cp.w	r8,0
8000c3f2:	5c 29       	cpc	r9
8000c3f4:	cf 01       	brne	8000c3d4 <_vfprintf_r+0x1600>
8000c3f6:	fa e9 00 00 	st.d	sp[0],r8
8000c3fa:	c0 c8       	rjmp	8000c412 <_vfprintf_r+0x163e>
8000c3fc:	58 08       	cp.w	r8,0
8000c3fe:	c0 91       	brne	8000c410 <_vfprintf_r+0x163c>
8000c400:	ed b5 00 00 	bld	r5,0x0
8000c404:	c0 61       	brne	8000c410 <_vfprintf_r+0x163c>
8000c406:	fa c6 f9 79 	sub	r6,sp,-1671
8000c40a:	33 08       	mov	r8,48
8000c40c:	ac 88       	st.b	r6[0x0],r8
8000c40e:	c0 28       	rjmp	8000c412 <_vfprintf_r+0x163e>
8000c410:	04 96       	mov	r6,r2
8000c412:	0c 12       	sub	r2,r6
8000c414:	c1 c8       	rjmp	8000c44c <_vfprintf_r+0x1678>
8000c416:	50 a7       	stdsp	sp[0x28],r7
8000c418:	50 80       	stdsp	sp[0x20],r0
8000c41a:	40 93       	lddsp	r3,sp[0x24]
8000c41c:	0c 97       	mov	r7,r6
8000c41e:	10 90       	mov	r0,r8
8000c420:	04 94       	mov	r4,r2
8000c422:	40 41       	lddsp	r1,sp[0x10]
8000c424:	58 08       	cp.w	r8,0
8000c426:	e0 80 04 51 	breq	8000ccc8 <_vfprintf_r+0x1ef4>
8000c42a:	fb 68 06 60 	st.b	sp[1632],r8
8000c42e:	30 0c       	mov	r12,0
8000c430:	30 08       	mov	r8,0
8000c432:	30 12       	mov	r2,1
8000c434:	fb 68 06 bb 	st.b	sp[1723],r8
8000c438:	50 2c       	stdsp	sp[0x8],r12
8000c43a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c43e:	c0 78       	rjmp	8000c44c <_vfprintf_r+0x1678>
8000c440:	30 0b       	mov	r11,0
8000c442:	50 2b       	stdsp	sp[0x8],r11
8000c444:	c0 48       	rjmp	8000c44c <_vfprintf_r+0x1678>
8000c446:	40 22       	lddsp	r2,sp[0x8]
8000c448:	30 0a       	mov	r10,0
8000c44a:	50 2a       	stdsp	sp[0x8],r10
8000c44c:	40 29       	lddsp	r9,sp[0x8]
8000c44e:	e4 09 0c 49 	max	r9,r2,r9
8000c452:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c456:	50 39       	stdsp	sp[0xc],r9
8000c458:	0a 9e       	mov	lr,r5
8000c45a:	30 09       	mov	r9,0
8000c45c:	e2 1e 00 02 	andl	lr,0x2,COH
8000c460:	f2 08 18 00 	cp.b	r8,r9
8000c464:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c468:	f7 b8 01 ff 	subne	r8,-1
8000c46c:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c470:	0a 9b       	mov	r11,r5
8000c472:	58 0e       	cp.w	lr,0
8000c474:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c478:	f7 bc 01 fe 	subne	r12,-2
8000c47c:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c480:	e2 1b 00 84 	andl	r11,0x84,COH
8000c484:	50 fe       	stdsp	sp[0x3c],lr
8000c486:	50 9b       	stdsp	sp[0x24],r11
8000c488:	c4 51       	brne	8000c512 <_vfprintf_r+0x173e>
8000c48a:	40 8a       	lddsp	r10,sp[0x20]
8000c48c:	40 39       	lddsp	r9,sp[0xc]
8000c48e:	12 1a       	sub	r10,r9
8000c490:	50 4a       	stdsp	sp[0x10],r10
8000c492:	58 0a       	cp.w	r10,0
8000c494:	e0 89 00 1f 	brgt	8000c4d2 <_vfprintf_r+0x16fe>
8000c498:	c3 d8       	rjmp	8000c512 <_vfprintf_r+0x173e>
8000c49a:	2f 09       	sub	r9,-16
8000c49c:	2f f8       	sub	r8,-1
8000c49e:	4c ee       	lddpc	lr,8000c5d4 <_vfprintf_r+0x1800>
8000c4a0:	31 0c       	mov	r12,16
8000c4a2:	fb 49 06 90 	st.w	sp[1680],r9
8000c4a6:	87 0e       	st.w	r3[0x0],lr
8000c4a8:	87 1c       	st.w	r3[0x4],r12
8000c4aa:	fb 48 06 8c 	st.w	sp[1676],r8
8000c4ae:	58 78       	cp.w	r8,7
8000c4b0:	e0 89 00 04 	brgt	8000c4b8 <_vfprintf_r+0x16e4>
8000c4b4:	2f 83       	sub	r3,-8
8000c4b6:	c0 b8       	rjmp	8000c4cc <_vfprintf_r+0x16f8>
8000c4b8:	fa ca f9 78 	sub	r10,sp,-1672
8000c4bc:	02 9b       	mov	r11,r1
8000c4be:	08 9c       	mov	r12,r4
8000c4c0:	fe b0 f4 7c 	rcall	8000adb8 <__sprint_r>
8000c4c4:	e0 81 04 13 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c4c8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c4cc:	40 4b       	lddsp	r11,sp[0x10]
8000c4ce:	21 0b       	sub	r11,16
8000c4d0:	50 4b       	stdsp	sp[0x10],r11
8000c4d2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c4d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c4da:	4b fa       	lddpc	r10,8000c5d4 <_vfprintf_r+0x1800>
8000c4dc:	40 4e       	lddsp	lr,sp[0x10]
8000c4de:	59 0e       	cp.w	lr,16
8000c4e0:	fe 99 ff dd 	brgt	8000c49a <_vfprintf_r+0x16c6>
8000c4e4:	1c 09       	add	r9,lr
8000c4e6:	2f f8       	sub	r8,-1
8000c4e8:	87 0a       	st.w	r3[0x0],r10
8000c4ea:	fb 49 06 90 	st.w	sp[1680],r9
8000c4ee:	87 1e       	st.w	r3[0x4],lr
8000c4f0:	fb 48 06 8c 	st.w	sp[1676],r8
8000c4f4:	58 78       	cp.w	r8,7
8000c4f6:	e0 89 00 04 	brgt	8000c4fe <_vfprintf_r+0x172a>
8000c4fa:	2f 83       	sub	r3,-8
8000c4fc:	c0 b8       	rjmp	8000c512 <_vfprintf_r+0x173e>
8000c4fe:	fa ca f9 78 	sub	r10,sp,-1672
8000c502:	02 9b       	mov	r11,r1
8000c504:	08 9c       	mov	r12,r4
8000c506:	fe b0 f4 59 	rcall	8000adb8 <__sprint_r>
8000c50a:	e0 81 03 f0 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c50e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c512:	30 09       	mov	r9,0
8000c514:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c518:	f2 08 18 00 	cp.b	r8,r9
8000c51c:	c1 f0       	breq	8000c55a <_vfprintf_r+0x1786>
8000c51e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c522:	fa c9 f9 45 	sub	r9,sp,-1723
8000c526:	2f f8       	sub	r8,-1
8000c528:	87 09       	st.w	r3[0x0],r9
8000c52a:	fb 48 06 90 	st.w	sp[1680],r8
8000c52e:	30 19       	mov	r9,1
8000c530:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c534:	87 19       	st.w	r3[0x4],r9
8000c536:	2f f8       	sub	r8,-1
8000c538:	fb 48 06 8c 	st.w	sp[1676],r8
8000c53c:	58 78       	cp.w	r8,7
8000c53e:	e0 89 00 04 	brgt	8000c546 <_vfprintf_r+0x1772>
8000c542:	2f 83       	sub	r3,-8
8000c544:	c0 b8       	rjmp	8000c55a <_vfprintf_r+0x1786>
8000c546:	fa ca f9 78 	sub	r10,sp,-1672
8000c54a:	02 9b       	mov	r11,r1
8000c54c:	08 9c       	mov	r12,r4
8000c54e:	fe b0 f4 35 	rcall	8000adb8 <__sprint_r>
8000c552:	e0 81 03 cc 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c556:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c55a:	40 fc       	lddsp	r12,sp[0x3c]
8000c55c:	58 0c       	cp.w	r12,0
8000c55e:	c1 f0       	breq	8000c59c <_vfprintf_r+0x17c8>
8000c560:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c564:	fa c9 f9 48 	sub	r9,sp,-1720
8000c568:	2f e8       	sub	r8,-2
8000c56a:	87 09       	st.w	r3[0x0],r9
8000c56c:	fb 48 06 90 	st.w	sp[1680],r8
8000c570:	30 29       	mov	r9,2
8000c572:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c576:	87 19       	st.w	r3[0x4],r9
8000c578:	2f f8       	sub	r8,-1
8000c57a:	fb 48 06 8c 	st.w	sp[1676],r8
8000c57e:	58 78       	cp.w	r8,7
8000c580:	e0 89 00 04 	brgt	8000c588 <_vfprintf_r+0x17b4>
8000c584:	2f 83       	sub	r3,-8
8000c586:	c0 b8       	rjmp	8000c59c <_vfprintf_r+0x17c8>
8000c588:	fa ca f9 78 	sub	r10,sp,-1672
8000c58c:	02 9b       	mov	r11,r1
8000c58e:	08 9c       	mov	r12,r4
8000c590:	fe b0 f4 14 	rcall	8000adb8 <__sprint_r>
8000c594:	e0 81 03 ab 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c598:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c59c:	40 9b       	lddsp	r11,sp[0x24]
8000c59e:	e0 4b 00 80 	cp.w	r11,128
8000c5a2:	c4 a1       	brne	8000c636 <_vfprintf_r+0x1862>
8000c5a4:	40 8a       	lddsp	r10,sp[0x20]
8000c5a6:	40 39       	lddsp	r9,sp[0xc]
8000c5a8:	12 1a       	sub	r10,r9
8000c5aa:	50 4a       	stdsp	sp[0x10],r10
8000c5ac:	58 0a       	cp.w	r10,0
8000c5ae:	e0 89 00 24 	brgt	8000c5f6 <_vfprintf_r+0x1822>
8000c5b2:	c4 28       	rjmp	8000c636 <_vfprintf_r+0x1862>
8000c5b4:	2f 09       	sub	r9,-16
8000c5b6:	2f f8       	sub	r8,-1
8000c5b8:	48 8e       	lddpc	lr,8000c5d8 <_vfprintf_r+0x1804>
8000c5ba:	31 0c       	mov	r12,16
8000c5bc:	fb 49 06 90 	st.w	sp[1680],r9
8000c5c0:	87 0e       	st.w	r3[0x0],lr
8000c5c2:	87 1c       	st.w	r3[0x4],r12
8000c5c4:	fb 48 06 8c 	st.w	sp[1676],r8
8000c5c8:	58 78       	cp.w	r8,7
8000c5ca:	e0 89 00 09 	brgt	8000c5dc <_vfprintf_r+0x1808>
8000c5ce:	2f 83       	sub	r3,-8
8000c5d0:	c1 08       	rjmp	8000c5f0 <_vfprintf_r+0x181c>
8000c5d2:	d7 03       	nop
8000c5d4:	80 01       	ld.sh	r1,r0[0x0]
8000c5d6:	8f a0       	st.w	r7[0x28],r0
8000c5d8:	80 01       	ld.sh	r1,r0[0x0]
8000c5da:	8f b0       	st.w	r7[0x2c],r0
8000c5dc:	fa ca f9 78 	sub	r10,sp,-1672
8000c5e0:	02 9b       	mov	r11,r1
8000c5e2:	08 9c       	mov	r12,r4
8000c5e4:	fe b0 f3 ea 	rcall	8000adb8 <__sprint_r>
8000c5e8:	e0 81 03 81 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c5ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c5f0:	40 4b       	lddsp	r11,sp[0x10]
8000c5f2:	21 0b       	sub	r11,16
8000c5f4:	50 4b       	stdsp	sp[0x10],r11
8000c5f6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c5fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c5fe:	4c 6a       	lddpc	r10,8000c714 <_vfprintf_r+0x1940>
8000c600:	40 4e       	lddsp	lr,sp[0x10]
8000c602:	59 0e       	cp.w	lr,16
8000c604:	fe 99 ff d8 	brgt	8000c5b4 <_vfprintf_r+0x17e0>
8000c608:	1c 09       	add	r9,lr
8000c60a:	2f f8       	sub	r8,-1
8000c60c:	87 0a       	st.w	r3[0x0],r10
8000c60e:	fb 49 06 90 	st.w	sp[1680],r9
8000c612:	87 1e       	st.w	r3[0x4],lr
8000c614:	fb 48 06 8c 	st.w	sp[1676],r8
8000c618:	58 78       	cp.w	r8,7
8000c61a:	e0 89 00 04 	brgt	8000c622 <_vfprintf_r+0x184e>
8000c61e:	2f 83       	sub	r3,-8
8000c620:	c0 b8       	rjmp	8000c636 <_vfprintf_r+0x1862>
8000c622:	fa ca f9 78 	sub	r10,sp,-1672
8000c626:	02 9b       	mov	r11,r1
8000c628:	08 9c       	mov	r12,r4
8000c62a:	fe b0 f3 c7 	rcall	8000adb8 <__sprint_r>
8000c62e:	e0 81 03 5e 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c632:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c636:	40 2c       	lddsp	r12,sp[0x8]
8000c638:	04 1c       	sub	r12,r2
8000c63a:	50 2c       	stdsp	sp[0x8],r12
8000c63c:	58 0c       	cp.w	r12,0
8000c63e:	e0 89 00 1f 	brgt	8000c67c <_vfprintf_r+0x18a8>
8000c642:	c3 d8       	rjmp	8000c6bc <_vfprintf_r+0x18e8>
8000c644:	2f 09       	sub	r9,-16
8000c646:	2f f8       	sub	r8,-1
8000c648:	4b 3b       	lddpc	r11,8000c714 <_vfprintf_r+0x1940>
8000c64a:	31 0a       	mov	r10,16
8000c64c:	fb 49 06 90 	st.w	sp[1680],r9
8000c650:	87 0b       	st.w	r3[0x0],r11
8000c652:	87 1a       	st.w	r3[0x4],r10
8000c654:	fb 48 06 8c 	st.w	sp[1676],r8
8000c658:	58 78       	cp.w	r8,7
8000c65a:	e0 89 00 04 	brgt	8000c662 <_vfprintf_r+0x188e>
8000c65e:	2f 83       	sub	r3,-8
8000c660:	c0 b8       	rjmp	8000c676 <_vfprintf_r+0x18a2>
8000c662:	fa ca f9 78 	sub	r10,sp,-1672
8000c666:	02 9b       	mov	r11,r1
8000c668:	08 9c       	mov	r12,r4
8000c66a:	fe b0 f3 a7 	rcall	8000adb8 <__sprint_r>
8000c66e:	e0 81 03 3e 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c672:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c676:	40 29       	lddsp	r9,sp[0x8]
8000c678:	21 09       	sub	r9,16
8000c67a:	50 29       	stdsp	sp[0x8],r9
8000c67c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c680:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c684:	4a 4a       	lddpc	r10,8000c714 <_vfprintf_r+0x1940>
8000c686:	40 2e       	lddsp	lr,sp[0x8]
8000c688:	59 0e       	cp.w	lr,16
8000c68a:	fe 99 ff dd 	brgt	8000c644 <_vfprintf_r+0x1870>
8000c68e:	1c 09       	add	r9,lr
8000c690:	2f f8       	sub	r8,-1
8000c692:	87 0a       	st.w	r3[0x0],r10
8000c694:	fb 49 06 90 	st.w	sp[1680],r9
8000c698:	87 1e       	st.w	r3[0x4],lr
8000c69a:	fb 48 06 8c 	st.w	sp[1676],r8
8000c69e:	58 78       	cp.w	r8,7
8000c6a0:	e0 89 00 04 	brgt	8000c6a8 <_vfprintf_r+0x18d4>
8000c6a4:	2f 83       	sub	r3,-8
8000c6a6:	c0 b8       	rjmp	8000c6bc <_vfprintf_r+0x18e8>
8000c6a8:	fa ca f9 78 	sub	r10,sp,-1672
8000c6ac:	02 9b       	mov	r11,r1
8000c6ae:	08 9c       	mov	r12,r4
8000c6b0:	fe b0 f3 84 	rcall	8000adb8 <__sprint_r>
8000c6b4:	e0 81 03 1b 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c6b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c6bc:	ed b5 00 08 	bld	r5,0x8
8000c6c0:	c0 b0       	breq	8000c6d6 <_vfprintf_r+0x1902>
8000c6c2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c6c6:	87 12       	st.w	r3[0x4],r2
8000c6c8:	87 06       	st.w	r3[0x0],r6
8000c6ca:	f0 02 00 02 	add	r2,r8,r2
8000c6ce:	fb 42 06 90 	st.w	sp[1680],r2
8000c6d2:	e0 8f 01 d5 	bral	8000ca7c <_vfprintf_r+0x1ca8>
8000c6d6:	e0 40 00 65 	cp.w	r0,101
8000c6da:	e0 8a 01 d7 	brle	8000ca88 <_vfprintf_r+0x1cb4>
8000c6de:	30 08       	mov	r8,0
8000c6e0:	30 09       	mov	r9,0
8000c6e2:	40 5b       	lddsp	r11,sp[0x14]
8000c6e4:	40 7a       	lddsp	r10,sp[0x1c]
8000c6e6:	e0 a0 15 3e 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000c6ea:	c7 a0       	breq	8000c7de <_vfprintf_r+0x1a0a>
8000c6ec:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c6f0:	48 a9       	lddpc	r9,8000c718 <_vfprintf_r+0x1944>
8000c6f2:	2f f8       	sub	r8,-1
8000c6f4:	87 09       	st.w	r3[0x0],r9
8000c6f6:	fb 48 06 90 	st.w	sp[1680],r8
8000c6fa:	30 19       	mov	r9,1
8000c6fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c700:	87 19       	st.w	r3[0x4],r9
8000c702:	2f f8       	sub	r8,-1
8000c704:	fb 48 06 8c 	st.w	sp[1676],r8
8000c708:	58 78       	cp.w	r8,7
8000c70a:	e0 89 00 09 	brgt	8000c71c <_vfprintf_r+0x1948>
8000c70e:	2f 83       	sub	r3,-8
8000c710:	c1 08       	rjmp	8000c730 <_vfprintf_r+0x195c>
8000c712:	d7 03       	nop
8000c714:	80 01       	ld.sh	r1,r0[0x0]
8000c716:	8f b0       	st.w	r7[0x2c],r0
8000c718:	80 01       	ld.sh	r1,r0[0x0]
8000c71a:	8f 9c       	st.w	r7[0x24],r12
8000c71c:	fa ca f9 78 	sub	r10,sp,-1672
8000c720:	02 9b       	mov	r11,r1
8000c722:	08 9c       	mov	r12,r4
8000c724:	fe b0 f3 4a 	rcall	8000adb8 <__sprint_r>
8000c728:	e0 81 02 e1 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c72c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c730:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c734:	40 6c       	lddsp	r12,sp[0x18]
8000c736:	18 38       	cp.w	r8,r12
8000c738:	c0 55       	brlt	8000c742 <_vfprintf_r+0x196e>
8000c73a:	ed b5 00 00 	bld	r5,0x0
8000c73e:	e0 81 02 69 	brne	8000cc10 <_vfprintf_r+0x1e3c>
8000c742:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c746:	2f f8       	sub	r8,-1
8000c748:	40 cb       	lddsp	r11,sp[0x30]
8000c74a:	fb 48 06 90 	st.w	sp[1680],r8
8000c74e:	30 19       	mov	r9,1
8000c750:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c754:	87 0b       	st.w	r3[0x0],r11
8000c756:	2f f8       	sub	r8,-1
8000c758:	87 19       	st.w	r3[0x4],r9
8000c75a:	fb 48 06 8c 	st.w	sp[1676],r8
8000c75e:	58 78       	cp.w	r8,7
8000c760:	e0 89 00 04 	brgt	8000c768 <_vfprintf_r+0x1994>
8000c764:	2f 83       	sub	r3,-8
8000c766:	c0 b8       	rjmp	8000c77c <_vfprintf_r+0x19a8>
8000c768:	fa ca f9 78 	sub	r10,sp,-1672
8000c76c:	02 9b       	mov	r11,r1
8000c76e:	08 9c       	mov	r12,r4
8000c770:	fe b0 f3 24 	rcall	8000adb8 <__sprint_r>
8000c774:	e0 81 02 bb 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c778:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c77c:	40 66       	lddsp	r6,sp[0x18]
8000c77e:	20 16       	sub	r6,1
8000c780:	58 06       	cp.w	r6,0
8000c782:	e0 89 00 1d 	brgt	8000c7bc <_vfprintf_r+0x19e8>
8000c786:	e0 8f 02 45 	bral	8000cc10 <_vfprintf_r+0x1e3c>
8000c78a:	2f 09       	sub	r9,-16
8000c78c:	2f f8       	sub	r8,-1
8000c78e:	fb 49 06 90 	st.w	sp[1680],r9
8000c792:	87 02       	st.w	r3[0x0],r2
8000c794:	87 10       	st.w	r3[0x4],r0
8000c796:	fb 48 06 8c 	st.w	sp[1676],r8
8000c79a:	58 78       	cp.w	r8,7
8000c79c:	e0 89 00 04 	brgt	8000c7a4 <_vfprintf_r+0x19d0>
8000c7a0:	2f 83       	sub	r3,-8
8000c7a2:	c0 b8       	rjmp	8000c7b8 <_vfprintf_r+0x19e4>
8000c7a4:	fa ca f9 78 	sub	r10,sp,-1672
8000c7a8:	02 9b       	mov	r11,r1
8000c7aa:	08 9c       	mov	r12,r4
8000c7ac:	fe b0 f3 06 	rcall	8000adb8 <__sprint_r>
8000c7b0:	e0 81 02 9d 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c7b4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c7b8:	21 06       	sub	r6,16
8000c7ba:	c0 38       	rjmp	8000c7c0 <_vfprintf_r+0x19ec>
8000c7bc:	4d 22       	lddpc	r2,8000c904 <_vfprintf_r+0x1b30>
8000c7be:	31 00       	mov	r0,16
8000c7c0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c7c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c7c8:	4c fa       	lddpc	r10,8000c904 <_vfprintf_r+0x1b30>
8000c7ca:	59 06       	cp.w	r6,16
8000c7cc:	fe 99 ff df 	brgt	8000c78a <_vfprintf_r+0x19b6>
8000c7d0:	0c 09       	add	r9,r6
8000c7d2:	87 0a       	st.w	r3[0x0],r10
8000c7d4:	fb 49 06 90 	st.w	sp[1680],r9
8000c7d8:	2f f8       	sub	r8,-1
8000c7da:	87 16       	st.w	r3[0x4],r6
8000c7dc:	c5 39       	rjmp	8000ca82 <_vfprintf_r+0x1cae>
8000c7de:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000c7e2:	58 0a       	cp.w	r10,0
8000c7e4:	e0 89 00 94 	brgt	8000c90c <_vfprintf_r+0x1b38>
8000c7e8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c7ec:	4c 79       	lddpc	r9,8000c908 <_vfprintf_r+0x1b34>
8000c7ee:	2f f8       	sub	r8,-1
8000c7f0:	87 09       	st.w	r3[0x0],r9
8000c7f2:	fb 48 06 90 	st.w	sp[1680],r8
8000c7f6:	30 19       	mov	r9,1
8000c7f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c7fc:	87 19       	st.w	r3[0x4],r9
8000c7fe:	2f f8       	sub	r8,-1
8000c800:	fb 48 06 8c 	st.w	sp[1676],r8
8000c804:	58 78       	cp.w	r8,7
8000c806:	e0 89 00 04 	brgt	8000c80e <_vfprintf_r+0x1a3a>
8000c80a:	2f 83       	sub	r3,-8
8000c80c:	c0 b8       	rjmp	8000c822 <_vfprintf_r+0x1a4e>
8000c80e:	fa ca f9 78 	sub	r10,sp,-1672
8000c812:	02 9b       	mov	r11,r1
8000c814:	08 9c       	mov	r12,r4
8000c816:	fe b0 f2 d1 	rcall	8000adb8 <__sprint_r>
8000c81a:	e0 81 02 68 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c81e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c822:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c826:	58 08       	cp.w	r8,0
8000c828:	c0 81       	brne	8000c838 <_vfprintf_r+0x1a64>
8000c82a:	40 6a       	lddsp	r10,sp[0x18]
8000c82c:	58 0a       	cp.w	r10,0
8000c82e:	c0 51       	brne	8000c838 <_vfprintf_r+0x1a64>
8000c830:	ed b5 00 00 	bld	r5,0x0
8000c834:	e0 81 01 ee 	brne	8000cc10 <_vfprintf_r+0x1e3c>
8000c838:	40 c9       	lddsp	r9,sp[0x30]
8000c83a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c83e:	2f f8       	sub	r8,-1
8000c840:	87 09       	st.w	r3[0x0],r9
8000c842:	fb 48 06 90 	st.w	sp[1680],r8
8000c846:	30 19       	mov	r9,1
8000c848:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c84c:	87 19       	st.w	r3[0x4],r9
8000c84e:	2f f8       	sub	r8,-1
8000c850:	fb 48 06 8c 	st.w	sp[1676],r8
8000c854:	58 78       	cp.w	r8,7
8000c856:	e0 89 00 04 	brgt	8000c85e <_vfprintf_r+0x1a8a>
8000c85a:	2f 83       	sub	r3,-8
8000c85c:	c0 b8       	rjmp	8000c872 <_vfprintf_r+0x1a9e>
8000c85e:	fa ca f9 78 	sub	r10,sp,-1672
8000c862:	02 9b       	mov	r11,r1
8000c864:	08 9c       	mov	r12,r4
8000c866:	fe b0 f2 a9 	rcall	8000adb8 <__sprint_r>
8000c86a:	e0 81 02 40 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c86e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c872:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c876:	5c 32       	neg	r2
8000c878:	58 02       	cp.w	r2,0
8000c87a:	e0 89 00 1d 	brgt	8000c8b4 <_vfprintf_r+0x1ae0>
8000c87e:	c3 b8       	rjmp	8000c8f4 <_vfprintf_r+0x1b20>
8000c880:	2f 09       	sub	r9,-16
8000c882:	2f f8       	sub	r8,-1
8000c884:	31 0e       	mov	lr,16
8000c886:	fb 49 06 90 	st.w	sp[1680],r9
8000c88a:	87 00       	st.w	r3[0x0],r0
8000c88c:	87 1e       	st.w	r3[0x4],lr
8000c88e:	fb 48 06 8c 	st.w	sp[1676],r8
8000c892:	58 78       	cp.w	r8,7
8000c894:	e0 89 00 04 	brgt	8000c89c <_vfprintf_r+0x1ac8>
8000c898:	2f 83       	sub	r3,-8
8000c89a:	c0 b8       	rjmp	8000c8b0 <_vfprintf_r+0x1adc>
8000c89c:	fa ca f9 78 	sub	r10,sp,-1672
8000c8a0:	02 9b       	mov	r11,r1
8000c8a2:	08 9c       	mov	r12,r4
8000c8a4:	fe b0 f2 8a 	rcall	8000adb8 <__sprint_r>
8000c8a8:	e0 81 02 21 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c8ac:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c8b0:	21 02       	sub	r2,16
8000c8b2:	c0 28       	rjmp	8000c8b6 <_vfprintf_r+0x1ae2>
8000c8b4:	49 40       	lddpc	r0,8000c904 <_vfprintf_r+0x1b30>
8000c8b6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c8ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c8be:	49 2a       	lddpc	r10,8000c904 <_vfprintf_r+0x1b30>
8000c8c0:	59 02       	cp.w	r2,16
8000c8c2:	fe 99 ff df 	brgt	8000c880 <_vfprintf_r+0x1aac>
8000c8c6:	04 09       	add	r9,r2
8000c8c8:	2f f8       	sub	r8,-1
8000c8ca:	87 0a       	st.w	r3[0x0],r10
8000c8cc:	fb 49 06 90 	st.w	sp[1680],r9
8000c8d0:	87 12       	st.w	r3[0x4],r2
8000c8d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000c8d6:	58 78       	cp.w	r8,7
8000c8d8:	e0 89 00 04 	brgt	8000c8e0 <_vfprintf_r+0x1b0c>
8000c8dc:	2f 83       	sub	r3,-8
8000c8de:	c0 b8       	rjmp	8000c8f4 <_vfprintf_r+0x1b20>
8000c8e0:	fa ca f9 78 	sub	r10,sp,-1672
8000c8e4:	02 9b       	mov	r11,r1
8000c8e6:	08 9c       	mov	r12,r4
8000c8e8:	fe b0 f2 68 	rcall	8000adb8 <__sprint_r>
8000c8ec:	e0 81 01 ff 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c8f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c8f4:	40 6c       	lddsp	r12,sp[0x18]
8000c8f6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c8fa:	87 06       	st.w	r3[0x0],r6
8000c8fc:	87 1c       	st.w	r3[0x4],r12
8000c8fe:	18 08       	add	r8,r12
8000c900:	cb c8       	rjmp	8000ca78 <_vfprintf_r+0x1ca4>
8000c902:	d7 03       	nop
8000c904:	80 01       	ld.sh	r1,r0[0x0]
8000c906:	8f b0       	st.w	r7[0x2c],r0
8000c908:	80 01       	ld.sh	r1,r0[0x0]
8000c90a:	8f 9c       	st.w	r7[0x24],r12
8000c90c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c910:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c914:	40 6b       	lddsp	r11,sp[0x18]
8000c916:	16 3a       	cp.w	r10,r11
8000c918:	c6 d5       	brlt	8000c9f2 <_vfprintf_r+0x1c1e>
8000c91a:	16 09       	add	r9,r11
8000c91c:	2f f8       	sub	r8,-1
8000c91e:	87 06       	st.w	r3[0x0],r6
8000c920:	fb 49 06 90 	st.w	sp[1680],r9
8000c924:	87 1b       	st.w	r3[0x4],r11
8000c926:	fb 48 06 8c 	st.w	sp[1676],r8
8000c92a:	58 78       	cp.w	r8,7
8000c92c:	e0 89 00 04 	brgt	8000c934 <_vfprintf_r+0x1b60>
8000c930:	2f 83       	sub	r3,-8
8000c932:	c0 b8       	rjmp	8000c948 <_vfprintf_r+0x1b74>
8000c934:	fa ca f9 78 	sub	r10,sp,-1672
8000c938:	02 9b       	mov	r11,r1
8000c93a:	08 9c       	mov	r12,r4
8000c93c:	fe b0 f2 3e 	rcall	8000adb8 <__sprint_r>
8000c940:	e0 81 01 d5 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c944:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c948:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000c94c:	40 6a       	lddsp	r10,sp[0x18]
8000c94e:	14 16       	sub	r6,r10
8000c950:	58 06       	cp.w	r6,0
8000c952:	e0 89 00 1c 	brgt	8000c98a <_vfprintf_r+0x1bb6>
8000c956:	c3 b8       	rjmp	8000c9cc <_vfprintf_r+0x1bf8>
8000c958:	2f 09       	sub	r9,-16
8000c95a:	2f f8       	sub	r8,-1
8000c95c:	fb 49 06 90 	st.w	sp[1680],r9
8000c960:	87 02       	st.w	r3[0x0],r2
8000c962:	87 10       	st.w	r3[0x4],r0
8000c964:	fb 48 06 8c 	st.w	sp[1676],r8
8000c968:	58 78       	cp.w	r8,7
8000c96a:	e0 89 00 04 	brgt	8000c972 <_vfprintf_r+0x1b9e>
8000c96e:	2f 83       	sub	r3,-8
8000c970:	c0 b8       	rjmp	8000c986 <_vfprintf_r+0x1bb2>
8000c972:	fa ca f9 78 	sub	r10,sp,-1672
8000c976:	02 9b       	mov	r11,r1
8000c978:	08 9c       	mov	r12,r4
8000c97a:	fe b0 f2 1f 	rcall	8000adb8 <__sprint_r>
8000c97e:	e0 81 01 b6 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c982:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c986:	21 06       	sub	r6,16
8000c988:	c0 38       	rjmp	8000c98e <_vfprintf_r+0x1bba>
8000c98a:	4d c2       	lddpc	r2,8000caf8 <_vfprintf_r+0x1d24>
8000c98c:	31 00       	mov	r0,16
8000c98e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c992:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c996:	4d 9a       	lddpc	r10,8000caf8 <_vfprintf_r+0x1d24>
8000c998:	59 06       	cp.w	r6,16
8000c99a:	fe 99 ff df 	brgt	8000c958 <_vfprintf_r+0x1b84>
8000c99e:	0c 09       	add	r9,r6
8000c9a0:	2f f8       	sub	r8,-1
8000c9a2:	87 0a       	st.w	r3[0x0],r10
8000c9a4:	fb 49 06 90 	st.w	sp[1680],r9
8000c9a8:	87 16       	st.w	r3[0x4],r6
8000c9aa:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9ae:	58 78       	cp.w	r8,7
8000c9b0:	e0 89 00 04 	brgt	8000c9b8 <_vfprintf_r+0x1be4>
8000c9b4:	2f 83       	sub	r3,-8
8000c9b6:	c0 b8       	rjmp	8000c9cc <_vfprintf_r+0x1bf8>
8000c9b8:	fa ca f9 78 	sub	r10,sp,-1672
8000c9bc:	02 9b       	mov	r11,r1
8000c9be:	08 9c       	mov	r12,r4
8000c9c0:	fe b0 f1 fc 	rcall	8000adb8 <__sprint_r>
8000c9c4:	e0 81 01 93 	brne	8000ccea <_vfprintf_r+0x1f16>
8000c9c8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9cc:	ed b5 00 00 	bld	r5,0x0
8000c9d0:	e0 81 01 20 	brne	8000cc10 <_vfprintf_r+0x1e3c>
8000c9d4:	40 c9       	lddsp	r9,sp[0x30]
8000c9d6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c9da:	2f f8       	sub	r8,-1
8000c9dc:	87 09       	st.w	r3[0x0],r9
8000c9de:	fb 48 06 90 	st.w	sp[1680],r8
8000c9e2:	30 19       	mov	r9,1
8000c9e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c9e8:	87 19       	st.w	r3[0x4],r9
8000c9ea:	2f f8       	sub	r8,-1
8000c9ec:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9f0:	c0 29       	rjmp	8000cbf4 <_vfprintf_r+0x1e20>
8000c9f2:	14 09       	add	r9,r10
8000c9f4:	2f f8       	sub	r8,-1
8000c9f6:	fb 49 06 90 	st.w	sp[1680],r9
8000c9fa:	87 06       	st.w	r3[0x0],r6
8000c9fc:	87 1a       	st.w	r3[0x4],r10
8000c9fe:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca02:	58 78       	cp.w	r8,7
8000ca04:	e0 89 00 04 	brgt	8000ca0c <_vfprintf_r+0x1c38>
8000ca08:	2f 83       	sub	r3,-8
8000ca0a:	c0 b8       	rjmp	8000ca20 <_vfprintf_r+0x1c4c>
8000ca0c:	fa ca f9 78 	sub	r10,sp,-1672
8000ca10:	02 9b       	mov	r11,r1
8000ca12:	08 9c       	mov	r12,r4
8000ca14:	fe b0 f1 d2 	rcall	8000adb8 <__sprint_r>
8000ca18:	e0 81 01 69 	brne	8000ccea <_vfprintf_r+0x1f16>
8000ca1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca20:	40 c8       	lddsp	r8,sp[0x30]
8000ca22:	87 08       	st.w	r3[0x0],r8
8000ca24:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca28:	2f f8       	sub	r8,-1
8000ca2a:	30 19       	mov	r9,1
8000ca2c:	fb 48 06 90 	st.w	sp[1680],r8
8000ca30:	87 19       	st.w	r3[0x4],r9
8000ca32:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca36:	2f f8       	sub	r8,-1
8000ca38:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca3c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ca40:	58 78       	cp.w	r8,7
8000ca42:	e0 89 00 04 	brgt	8000ca4a <_vfprintf_r+0x1c76>
8000ca46:	2f 83       	sub	r3,-8
8000ca48:	c0 b8       	rjmp	8000ca5e <_vfprintf_r+0x1c8a>
8000ca4a:	fa ca f9 78 	sub	r10,sp,-1672
8000ca4e:	02 9b       	mov	r11,r1
8000ca50:	08 9c       	mov	r12,r4
8000ca52:	fe b0 f1 b3 	rcall	8000adb8 <__sprint_r>
8000ca56:	e0 81 01 4a 	brne	8000ccea <_vfprintf_r+0x1f16>
8000ca5a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca5e:	04 06       	add	r6,r2
8000ca60:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ca64:	87 06       	st.w	r3[0x0],r6
8000ca66:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ca6a:	40 66       	lddsp	r6,sp[0x18]
8000ca6c:	40 6e       	lddsp	lr,sp[0x18]
8000ca6e:	10 16       	sub	r6,r8
8000ca70:	f2 08 01 08 	sub	r8,r9,r8
8000ca74:	87 16       	st.w	r3[0x4],r6
8000ca76:	1c 08       	add	r8,lr
8000ca78:	fb 48 06 90 	st.w	sp[1680],r8
8000ca7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca80:	2f f8       	sub	r8,-1
8000ca82:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca86:	cb 78       	rjmp	8000cbf4 <_vfprintf_r+0x1e20>
8000ca88:	40 6c       	lddsp	r12,sp[0x18]
8000ca8a:	58 1c       	cp.w	r12,1
8000ca8c:	e0 89 00 06 	brgt	8000ca98 <_vfprintf_r+0x1cc4>
8000ca90:	ed b5 00 00 	bld	r5,0x0
8000ca94:	e0 81 00 85 	brne	8000cb9e <_vfprintf_r+0x1dca>
8000ca98:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca9c:	2f f8       	sub	r8,-1
8000ca9e:	30 19       	mov	r9,1
8000caa0:	fb 48 06 90 	st.w	sp[1680],r8
8000caa4:	87 06       	st.w	r3[0x0],r6
8000caa6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caaa:	87 19       	st.w	r3[0x4],r9
8000caac:	2f f8       	sub	r8,-1
8000caae:	fb 48 06 8c 	st.w	sp[1676],r8
8000cab2:	58 78       	cp.w	r8,7
8000cab4:	e0 89 00 04 	brgt	8000cabc <_vfprintf_r+0x1ce8>
8000cab8:	2f 83       	sub	r3,-8
8000caba:	c0 b8       	rjmp	8000cad0 <_vfprintf_r+0x1cfc>
8000cabc:	fa ca f9 78 	sub	r10,sp,-1672
8000cac0:	02 9b       	mov	r11,r1
8000cac2:	08 9c       	mov	r12,r4
8000cac4:	fe b0 f1 7a 	rcall	8000adb8 <__sprint_r>
8000cac8:	e0 81 01 11 	brne	8000ccea <_vfprintf_r+0x1f16>
8000cacc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cad0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cad4:	2f f8       	sub	r8,-1
8000cad6:	40 cb       	lddsp	r11,sp[0x30]
8000cad8:	fb 48 06 90 	st.w	sp[1680],r8
8000cadc:	30 19       	mov	r9,1
8000cade:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cae2:	87 0b       	st.w	r3[0x0],r11
8000cae4:	2f f8       	sub	r8,-1
8000cae6:	87 19       	st.w	r3[0x4],r9
8000cae8:	fb 48 06 8c 	st.w	sp[1676],r8
8000caec:	58 78       	cp.w	r8,7
8000caee:	e0 89 00 07 	brgt	8000cafc <_vfprintf_r+0x1d28>
8000caf2:	2f 83       	sub	r3,-8
8000caf4:	c0 e8       	rjmp	8000cb10 <_vfprintf_r+0x1d3c>
8000caf6:	d7 03       	nop
8000caf8:	80 01       	ld.sh	r1,r0[0x0]
8000cafa:	8f b0       	st.w	r7[0x2c],r0
8000cafc:	fa ca f9 78 	sub	r10,sp,-1672
8000cb00:	02 9b       	mov	r11,r1
8000cb02:	08 9c       	mov	r12,r4
8000cb04:	fe b0 f1 5a 	rcall	8000adb8 <__sprint_r>
8000cb08:	e0 81 00 f1 	brne	8000ccea <_vfprintf_r+0x1f16>
8000cb0c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb10:	30 08       	mov	r8,0
8000cb12:	30 09       	mov	r9,0
8000cb14:	40 5b       	lddsp	r11,sp[0x14]
8000cb16:	40 7a       	lddsp	r10,sp[0x1c]
8000cb18:	e0 a0 13 25 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000cb1c:	40 68       	lddsp	r8,sp[0x18]
8000cb1e:	20 18       	sub	r8,1
8000cb20:	58 0c       	cp.w	r12,0
8000cb22:	c0 d1       	brne	8000cb3c <_vfprintf_r+0x1d68>
8000cb24:	2f f6       	sub	r6,-1
8000cb26:	87 18       	st.w	r3[0x4],r8
8000cb28:	87 06       	st.w	r3[0x0],r6
8000cb2a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000cb2e:	10 06       	add	r6,r8
8000cb30:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb34:	fb 46 06 90 	st.w	sp[1680],r6
8000cb38:	2f f8       	sub	r8,-1
8000cb3a:	c2 f8       	rjmp	8000cb98 <_vfprintf_r+0x1dc4>
8000cb3c:	10 96       	mov	r6,r8
8000cb3e:	58 08       	cp.w	r8,0
8000cb40:	e0 89 00 1c 	brgt	8000cb78 <_vfprintf_r+0x1da4>
8000cb44:	c4 98       	rjmp	8000cbd6 <_vfprintf_r+0x1e02>
8000cb46:	2f 09       	sub	r9,-16
8000cb48:	2f f8       	sub	r8,-1
8000cb4a:	fb 49 06 90 	st.w	sp[1680],r9
8000cb4e:	87 02       	st.w	r3[0x0],r2
8000cb50:	87 10       	st.w	r3[0x4],r0
8000cb52:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb56:	58 78       	cp.w	r8,7
8000cb58:	e0 89 00 04 	brgt	8000cb60 <_vfprintf_r+0x1d8c>
8000cb5c:	2f 83       	sub	r3,-8
8000cb5e:	c0 b8       	rjmp	8000cb74 <_vfprintf_r+0x1da0>
8000cb60:	fa ca f9 78 	sub	r10,sp,-1672
8000cb64:	02 9b       	mov	r11,r1
8000cb66:	08 9c       	mov	r12,r4
8000cb68:	fe b0 f1 28 	rcall	8000adb8 <__sprint_r>
8000cb6c:	e0 81 00 bf 	brne	8000ccea <_vfprintf_r+0x1f16>
8000cb70:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb74:	21 06       	sub	r6,16
8000cb76:	c0 38       	rjmp	8000cb7c <_vfprintf_r+0x1da8>
8000cb78:	4d 22       	lddpc	r2,8000ccc0 <_vfprintf_r+0x1eec>
8000cb7a:	31 00       	mov	r0,16
8000cb7c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cb80:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb84:	4c fa       	lddpc	r10,8000ccc0 <_vfprintf_r+0x1eec>
8000cb86:	59 06       	cp.w	r6,16
8000cb88:	fe 99 ff df 	brgt	8000cb46 <_vfprintf_r+0x1d72>
8000cb8c:	0c 09       	add	r9,r6
8000cb8e:	87 0a       	st.w	r3[0x0],r10
8000cb90:	fb 49 06 90 	st.w	sp[1680],r9
8000cb94:	2f f8       	sub	r8,-1
8000cb96:	87 16       	st.w	r3[0x4],r6
8000cb98:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb9c:	c0 e8       	rjmp	8000cbb8 <_vfprintf_r+0x1de4>
8000cb9e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cba2:	2f f8       	sub	r8,-1
8000cba4:	30 19       	mov	r9,1
8000cba6:	fb 48 06 90 	st.w	sp[1680],r8
8000cbaa:	87 06       	st.w	r3[0x0],r6
8000cbac:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbb0:	87 19       	st.w	r3[0x4],r9
8000cbb2:	2f f8       	sub	r8,-1
8000cbb4:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbb8:	58 78       	cp.w	r8,7
8000cbba:	e0 89 00 04 	brgt	8000cbc2 <_vfprintf_r+0x1dee>
8000cbbe:	2f 83       	sub	r3,-8
8000cbc0:	c0 b8       	rjmp	8000cbd6 <_vfprintf_r+0x1e02>
8000cbc2:	fa ca f9 78 	sub	r10,sp,-1672
8000cbc6:	02 9b       	mov	r11,r1
8000cbc8:	08 9c       	mov	r12,r4
8000cbca:	fe b0 f0 f7 	rcall	8000adb8 <__sprint_r>
8000cbce:	e0 81 00 8e 	brne	8000ccea <_vfprintf_r+0x1f16>
8000cbd2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbd6:	40 ea       	lddsp	r10,sp[0x38]
8000cbd8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbdc:	14 08       	add	r8,r10
8000cbde:	fa c9 f9 64 	sub	r9,sp,-1692
8000cbe2:	fb 48 06 90 	st.w	sp[1680],r8
8000cbe6:	87 1a       	st.w	r3[0x4],r10
8000cbe8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbec:	87 09       	st.w	r3[0x0],r9
8000cbee:	2f f8       	sub	r8,-1
8000cbf0:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbf4:	58 78       	cp.w	r8,7
8000cbf6:	e0 89 00 04 	brgt	8000cbfe <_vfprintf_r+0x1e2a>
8000cbfa:	2f 83       	sub	r3,-8
8000cbfc:	c0 a8       	rjmp	8000cc10 <_vfprintf_r+0x1e3c>
8000cbfe:	fa ca f9 78 	sub	r10,sp,-1672
8000cc02:	02 9b       	mov	r11,r1
8000cc04:	08 9c       	mov	r12,r4
8000cc06:	fe b0 f0 d9 	rcall	8000adb8 <__sprint_r>
8000cc0a:	c7 01       	brne	8000ccea <_vfprintf_r+0x1f16>
8000cc0c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc10:	e2 15 00 04 	andl	r5,0x4,COH
8000cc14:	c3 d0       	breq	8000cc8e <_vfprintf_r+0x1eba>
8000cc16:	40 86       	lddsp	r6,sp[0x20]
8000cc18:	40 39       	lddsp	r9,sp[0xc]
8000cc1a:	12 16       	sub	r6,r9
8000cc1c:	58 06       	cp.w	r6,0
8000cc1e:	e0 89 00 1a 	brgt	8000cc52 <_vfprintf_r+0x1e7e>
8000cc22:	c3 68       	rjmp	8000cc8e <_vfprintf_r+0x1eba>
8000cc24:	2f 09       	sub	r9,-16
8000cc26:	2f f8       	sub	r8,-1
8000cc28:	fb 49 06 90 	st.w	sp[1680],r9
8000cc2c:	87 05       	st.w	r3[0x0],r5
8000cc2e:	87 12       	st.w	r3[0x4],r2
8000cc30:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc34:	58 78       	cp.w	r8,7
8000cc36:	e0 89 00 04 	brgt	8000cc3e <_vfprintf_r+0x1e6a>
8000cc3a:	2f 83       	sub	r3,-8
8000cc3c:	c0 98       	rjmp	8000cc4e <_vfprintf_r+0x1e7a>
8000cc3e:	00 9a       	mov	r10,r0
8000cc40:	02 9b       	mov	r11,r1
8000cc42:	08 9c       	mov	r12,r4
8000cc44:	fe b0 f0 ba 	rcall	8000adb8 <__sprint_r>
8000cc48:	c5 11       	brne	8000ccea <_vfprintf_r+0x1f16>
8000cc4a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc4e:	21 06       	sub	r6,16
8000cc50:	c0 58       	rjmp	8000cc5a <_vfprintf_r+0x1e86>
8000cc52:	49 d5       	lddpc	r5,8000ccc4 <_vfprintf_r+0x1ef0>
8000cc54:	31 02       	mov	r2,16
8000cc56:	fa c0 f9 78 	sub	r0,sp,-1672
8000cc5a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cc5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc62:	49 9a       	lddpc	r10,8000ccc4 <_vfprintf_r+0x1ef0>
8000cc64:	59 06       	cp.w	r6,16
8000cc66:	fe 99 ff df 	brgt	8000cc24 <_vfprintf_r+0x1e50>
8000cc6a:	0c 09       	add	r9,r6
8000cc6c:	2f f8       	sub	r8,-1
8000cc6e:	87 0a       	st.w	r3[0x0],r10
8000cc70:	87 16       	st.w	r3[0x4],r6
8000cc72:	fb 49 06 90 	st.w	sp[1680],r9
8000cc76:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc7a:	58 78       	cp.w	r8,7
8000cc7c:	e0 8a 00 09 	brle	8000cc8e <_vfprintf_r+0x1eba>
8000cc80:	fa ca f9 78 	sub	r10,sp,-1672
8000cc84:	02 9b       	mov	r11,r1
8000cc86:	08 9c       	mov	r12,r4
8000cc88:	fe b0 f0 98 	rcall	8000adb8 <__sprint_r>
8000cc8c:	c2 f1       	brne	8000ccea <_vfprintf_r+0x1f16>
8000cc8e:	40 bc       	lddsp	r12,sp[0x2c]
8000cc90:	40 36       	lddsp	r6,sp[0xc]
8000cc92:	40 8e       	lddsp	lr,sp[0x20]
8000cc94:	ec 0e 0c 48 	max	r8,r6,lr
8000cc98:	10 0c       	add	r12,r8
8000cc9a:	50 bc       	stdsp	sp[0x2c],r12
8000cc9c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cca0:	58 08       	cp.w	r8,0
8000cca2:	c0 80       	breq	8000ccb2 <_vfprintf_r+0x1ede>
8000cca4:	fa ca f9 78 	sub	r10,sp,-1672
8000cca8:	02 9b       	mov	r11,r1
8000ccaa:	08 9c       	mov	r12,r4
8000ccac:	fe b0 f0 86 	rcall	8000adb8 <__sprint_r>
8000ccb0:	c1 d1       	brne	8000ccea <_vfprintf_r+0x1f16>
8000ccb2:	30 0b       	mov	r11,0
8000ccb4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ccb8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000ccbc:	fe 9f f1 17 	bral	8000aeea <_vfprintf_r+0x116>
8000ccc0:	80 01       	ld.sh	r1,r0[0x0]
8000ccc2:	8f b0       	st.w	r7[0x2c],r0
8000ccc4:	80 01       	ld.sh	r1,r0[0x0]
8000ccc6:	8f a0       	st.w	r7[0x28],r0
8000ccc8:	08 95       	mov	r5,r4
8000ccca:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ccce:	58 08       	cp.w	r8,0
8000ccd0:	c0 80       	breq	8000cce0 <_vfprintf_r+0x1f0c>
8000ccd2:	08 9c       	mov	r12,r4
8000ccd4:	fa ca f9 78 	sub	r10,sp,-1672
8000ccd8:	02 9b       	mov	r11,r1
8000ccda:	fe b0 f0 6f 	rcall	8000adb8 <__sprint_r>
8000ccde:	c0 61       	brne	8000ccea <_vfprintf_r+0x1f16>
8000cce0:	30 08       	mov	r8,0
8000cce2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cce6:	c0 28       	rjmp	8000ccea <_vfprintf_r+0x1f16>
8000cce8:	40 41       	lddsp	r1,sp[0x10]
8000ccea:	82 68       	ld.sh	r8,r1[0xc]
8000ccec:	ed b8 00 06 	bld	r8,0x6
8000ccf0:	c0 31       	brne	8000ccf6 <_vfprintf_r+0x1f22>
8000ccf2:	3f fa       	mov	r10,-1
8000ccf4:	50 ba       	stdsp	sp[0x2c],r10
8000ccf6:	40 bc       	lddsp	r12,sp[0x2c]
8000ccf8:	fe 3d f9 44 	sub	sp,-1724
8000ccfc:	d8 32       	popm	r0-r7,pc
8000ccfe:	d7 03       	nop

8000cd00 <__swsetup_r>:
8000cd00:	d4 21       	pushm	r4-r7,lr
8000cd02:	e0 68 0a 38 	mov	r8,2616
8000cd06:	18 96       	mov	r6,r12
8000cd08:	16 97       	mov	r7,r11
8000cd0a:	70 0c       	ld.w	r12,r8[0x0]
8000cd0c:	58 0c       	cp.w	r12,0
8000cd0e:	c0 60       	breq	8000cd1a <__swsetup_r+0x1a>
8000cd10:	78 68       	ld.w	r8,r12[0x18]
8000cd12:	58 08       	cp.w	r8,0
8000cd14:	c0 31       	brne	8000cd1a <__swsetup_r+0x1a>
8000cd16:	e0 a0 07 c7 	rcall	8000dca4 <__sinit>
8000cd1a:	4a f8       	lddpc	r8,8000cdd4 <__swsetup_r+0xd4>
8000cd1c:	10 37       	cp.w	r7,r8
8000cd1e:	c0 61       	brne	8000cd2a <__swsetup_r+0x2a>
8000cd20:	e0 68 0a 38 	mov	r8,2616
8000cd24:	70 08       	ld.w	r8,r8[0x0]
8000cd26:	70 07       	ld.w	r7,r8[0x0]
8000cd28:	c1 08       	rjmp	8000cd48 <__swsetup_r+0x48>
8000cd2a:	4a c8       	lddpc	r8,8000cdd8 <__swsetup_r+0xd8>
8000cd2c:	10 37       	cp.w	r7,r8
8000cd2e:	c0 61       	brne	8000cd3a <__swsetup_r+0x3a>
8000cd30:	e0 68 0a 38 	mov	r8,2616
8000cd34:	70 08       	ld.w	r8,r8[0x0]
8000cd36:	70 17       	ld.w	r7,r8[0x4]
8000cd38:	c0 88       	rjmp	8000cd48 <__swsetup_r+0x48>
8000cd3a:	4a 98       	lddpc	r8,8000cddc <__swsetup_r+0xdc>
8000cd3c:	10 37       	cp.w	r7,r8
8000cd3e:	c0 51       	brne	8000cd48 <__swsetup_r+0x48>
8000cd40:	e0 68 0a 38 	mov	r8,2616
8000cd44:	70 08       	ld.w	r8,r8[0x0]
8000cd46:	70 27       	ld.w	r7,r8[0x8]
8000cd48:	8e 68       	ld.sh	r8,r7[0xc]
8000cd4a:	ed b8 00 03 	bld	r8,0x3
8000cd4e:	c1 e0       	breq	8000cd8a <__swsetup_r+0x8a>
8000cd50:	ed b8 00 04 	bld	r8,0x4
8000cd54:	c3 e1       	brne	8000cdd0 <__swsetup_r+0xd0>
8000cd56:	ed b8 00 02 	bld	r8,0x2
8000cd5a:	c1 51       	brne	8000cd84 <__swsetup_r+0x84>
8000cd5c:	6e db       	ld.w	r11,r7[0x34]
8000cd5e:	58 0b       	cp.w	r11,0
8000cd60:	c0 a0       	breq	8000cd74 <__swsetup_r+0x74>
8000cd62:	ee c8 ff bc 	sub	r8,r7,-68
8000cd66:	10 3b       	cp.w	r11,r8
8000cd68:	c0 40       	breq	8000cd70 <__swsetup_r+0x70>
8000cd6a:	0c 9c       	mov	r12,r6
8000cd6c:	e0 a0 08 36 	rcall	8000ddd8 <_free_r>
8000cd70:	30 08       	mov	r8,0
8000cd72:	8f d8       	st.w	r7[0x34],r8
8000cd74:	8e 68       	ld.sh	r8,r7[0xc]
8000cd76:	e0 18 ff db 	andl	r8,0xffdb
8000cd7a:	ae 68       	st.h	r7[0xc],r8
8000cd7c:	30 08       	mov	r8,0
8000cd7e:	8f 18       	st.w	r7[0x4],r8
8000cd80:	6e 48       	ld.w	r8,r7[0x10]
8000cd82:	8f 08       	st.w	r7[0x0],r8
8000cd84:	8e 68       	ld.sh	r8,r7[0xc]
8000cd86:	a3 b8       	sbr	r8,0x3
8000cd88:	ae 68       	st.h	r7[0xc],r8
8000cd8a:	6e 48       	ld.w	r8,r7[0x10]
8000cd8c:	58 08       	cp.w	r8,0
8000cd8e:	c0 b1       	brne	8000cda4 <__swsetup_r+0xa4>
8000cd90:	8e 68       	ld.sh	r8,r7[0xc]
8000cd92:	e2 18 02 80 	andl	r8,0x280,COH
8000cd96:	e0 48 02 00 	cp.w	r8,512
8000cd9a:	c0 50       	breq	8000cda4 <__swsetup_r+0xa4>
8000cd9c:	0c 9c       	mov	r12,r6
8000cd9e:	0e 9b       	mov	r11,r7
8000cda0:	e0 a0 0a 56 	rcall	8000e24c <__smakebuf_r>
8000cda4:	8e 69       	ld.sh	r9,r7[0xc]
8000cda6:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000cdaa:	c0 70       	breq	8000cdb8 <__swsetup_r+0xb8>
8000cdac:	30 08       	mov	r8,0
8000cdae:	8f 28       	st.w	r7[0x8],r8
8000cdb0:	6e 58       	ld.w	r8,r7[0x14]
8000cdb2:	5c 38       	neg	r8
8000cdb4:	8f 68       	st.w	r7[0x18],r8
8000cdb6:	c0 68       	rjmp	8000cdc2 <__swsetup_r+0xc2>
8000cdb8:	ed b9 00 01 	bld	r9,0x1
8000cdbc:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000cdc0:	8f 28       	st.w	r7[0x8],r8
8000cdc2:	6e 48       	ld.w	r8,r7[0x10]
8000cdc4:	58 08       	cp.w	r8,0
8000cdc6:	c0 61       	brne	8000cdd2 <__swsetup_r+0xd2>
8000cdc8:	8e 68       	ld.sh	r8,r7[0xc]
8000cdca:	ed b8 00 07 	bld	r8,0x7
8000cdce:	c0 21       	brne	8000cdd2 <__swsetup_r+0xd2>
8000cdd0:	dc 2a       	popm	r4-r7,pc,r12=-1
8000cdd2:	d8 2a       	popm	r4-r7,pc,r12=0
8000cdd4:	80 01       	ld.sh	r1,r0[0x0]
8000cdd6:	90 d0       	ld.uh	r0,r8[0xa]
8000cdd8:	80 01       	ld.sh	r1,r0[0x0]
8000cdda:	90 f0       	ld.uh	r0,r8[0xe]
8000cddc:	80 01       	ld.sh	r1,r0[0x0]
8000cdde:	91 10       	st.w	r8[0x4],r0

8000cde0 <quorem>:
8000cde0:	d4 31       	pushm	r0-r7,lr
8000cde2:	20 2d       	sub	sp,8
8000cde4:	18 97       	mov	r7,r12
8000cde6:	78 48       	ld.w	r8,r12[0x10]
8000cde8:	76 46       	ld.w	r6,r11[0x10]
8000cdea:	0c 38       	cp.w	r8,r6
8000cdec:	c0 34       	brge	8000cdf2 <quorem+0x12>
8000cdee:	30 0c       	mov	r12,0
8000cdf0:	c8 58       	rjmp	8000cefa <quorem+0x11a>
8000cdf2:	ec c2 ff fc 	sub	r2,r6,-4
8000cdf6:	f6 c3 ff ec 	sub	r3,r11,-20
8000cdfa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000cdfe:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000ce02:	2f f9       	sub	r9,-1
8000ce04:	20 16       	sub	r6,1
8000ce06:	f8 09 0d 08 	divu	r8,r12,r9
8000ce0a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000ce0e:	ee c4 ff ec 	sub	r4,r7,-20
8000ce12:	10 95       	mov	r5,r8
8000ce14:	58 08       	cp.w	r8,0
8000ce16:	c4 10       	breq	8000ce98 <quorem+0xb8>
8000ce18:	30 09       	mov	r9,0
8000ce1a:	06 9a       	mov	r10,r3
8000ce1c:	08 98       	mov	r8,r4
8000ce1e:	12 91       	mov	r1,r9
8000ce20:	50 0b       	stdsp	sp[0x0],r11
8000ce22:	70 0e       	ld.w	lr,r8[0x0]
8000ce24:	b1 8e       	lsr	lr,0x10
8000ce26:	50 1e       	stdsp	sp[0x4],lr
8000ce28:	15 0e       	ld.w	lr,r10++
8000ce2a:	fc 00 16 10 	lsr	r0,lr,0x10
8000ce2e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ce32:	ea 0e 03 41 	mac	r1,r5,lr
8000ce36:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000ce3a:	b1 81       	lsr	r1,0x10
8000ce3c:	40 1b       	lddsp	r11,sp[0x4]
8000ce3e:	ea 00 02 40 	mul	r0,r5,r0
8000ce42:	e2 00 00 00 	add	r0,r1,r0
8000ce46:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000ce4a:	02 1b       	sub	r11,r1
8000ce4c:	50 1b       	stdsp	sp[0x4],r11
8000ce4e:	70 0b       	ld.w	r11,r8[0x0]
8000ce50:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000ce54:	02 09       	add	r9,r1
8000ce56:	f2 0e 01 0e 	sub	lr,r9,lr
8000ce5a:	b0 1e       	st.h	r8[0x2],lr
8000ce5c:	fc 09 14 10 	asr	r9,lr,0x10
8000ce60:	40 1e       	lddsp	lr,sp[0x4]
8000ce62:	fc 09 00 09 	add	r9,lr,r9
8000ce66:	b0 09       	st.h	r8[0x0],r9
8000ce68:	e0 01 16 10 	lsr	r1,r0,0x10
8000ce6c:	2f c8       	sub	r8,-4
8000ce6e:	b1 49       	asr	r9,0x10
8000ce70:	04 3a       	cp.w	r10,r2
8000ce72:	fe 98 ff d8 	brls	8000ce22 <quorem+0x42>
8000ce76:	40 0b       	lddsp	r11,sp[0x0]
8000ce78:	58 0c       	cp.w	r12,0
8000ce7a:	c0 f1       	brne	8000ce98 <quorem+0xb8>
8000ce7c:	ec c8 ff fb 	sub	r8,r6,-5
8000ce80:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000ce84:	c0 28       	rjmp	8000ce88 <quorem+0xa8>
8000ce86:	20 16       	sub	r6,1
8000ce88:	20 48       	sub	r8,4
8000ce8a:	08 38       	cp.w	r8,r4
8000ce8c:	e0 88 00 05 	brls	8000ce96 <quorem+0xb6>
8000ce90:	70 09       	ld.w	r9,r8[0x0]
8000ce92:	58 09       	cp.w	r9,0
8000ce94:	cf 90       	breq	8000ce86 <quorem+0xa6>
8000ce96:	8f 46       	st.w	r7[0x10],r6
8000ce98:	0e 9c       	mov	r12,r7
8000ce9a:	e0 a0 0a d8 	rcall	8000e44a <__mcmp>
8000ce9e:	c2 d5       	brlt	8000cef8 <quorem+0x118>
8000cea0:	2f f5       	sub	r5,-1
8000cea2:	08 98       	mov	r8,r4
8000cea4:	30 09       	mov	r9,0
8000cea6:	07 0b       	ld.w	r11,r3++
8000cea8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000ceac:	70 0c       	ld.w	r12,r8[0x0]
8000ceae:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ceb2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ceb6:	14 1e       	sub	lr,r10
8000ceb8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000cebc:	16 1a       	sub	r10,r11
8000cebe:	12 0a       	add	r10,r9
8000cec0:	b0 1a       	st.h	r8[0x2],r10
8000cec2:	b1 4a       	asr	r10,0x10
8000cec4:	fc 0a 00 09 	add	r9,lr,r10
8000cec8:	b0 09       	st.h	r8[0x0],r9
8000ceca:	2f c8       	sub	r8,-4
8000cecc:	b1 49       	asr	r9,0x10
8000cece:	04 33       	cp.w	r3,r2
8000ced0:	fe 98 ff eb 	brls	8000cea6 <quorem+0xc6>
8000ced4:	ec c8 ff fb 	sub	r8,r6,-5
8000ced8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000cedc:	58 09       	cp.w	r9,0
8000cede:	c0 d1       	brne	8000cef8 <quorem+0x118>
8000cee0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000cee4:	c0 28       	rjmp	8000cee8 <quorem+0x108>
8000cee6:	20 16       	sub	r6,1
8000cee8:	20 48       	sub	r8,4
8000ceea:	08 38       	cp.w	r8,r4
8000ceec:	e0 88 00 05 	brls	8000cef6 <quorem+0x116>
8000cef0:	70 09       	ld.w	r9,r8[0x0]
8000cef2:	58 09       	cp.w	r9,0
8000cef4:	cf 90       	breq	8000cee6 <quorem+0x106>
8000cef6:	8f 46       	st.w	r7[0x10],r6
8000cef8:	0a 9c       	mov	r12,r5
8000cefa:	2f ed       	sub	sp,-8
8000cefc:	d8 32       	popm	r0-r7,pc
8000cefe:	d7 03       	nop

8000cf00 <_dtoa_r>:
8000cf00:	d4 31       	pushm	r0-r7,lr
8000cf02:	21 ad       	sub	sp,104
8000cf04:	fa c4 ff 74 	sub	r4,sp,-140
8000cf08:	18 97       	mov	r7,r12
8000cf0a:	16 95       	mov	r5,r11
8000cf0c:	68 2c       	ld.w	r12,r4[0x8]
8000cf0e:	50 c9       	stdsp	sp[0x30],r9
8000cf10:	68 16       	ld.w	r6,r4[0x4]
8000cf12:	68 09       	ld.w	r9,r4[0x0]
8000cf14:	50 e8       	stdsp	sp[0x38],r8
8000cf16:	14 94       	mov	r4,r10
8000cf18:	51 2c       	stdsp	sp[0x48],r12
8000cf1a:	fa e5 00 08 	st.d	sp[8],r4
8000cf1e:	51 59       	stdsp	sp[0x54],r9
8000cf20:	6e 95       	ld.w	r5,r7[0x24]
8000cf22:	58 05       	cp.w	r5,0
8000cf24:	c0 91       	brne	8000cf36 <_dtoa_r+0x36>
8000cf26:	31 0c       	mov	r12,16
8000cf28:	fe b0 e8 42 	rcall	80009fac <malloc>
8000cf2c:	99 35       	st.w	r12[0xc],r5
8000cf2e:	8f 9c       	st.w	r7[0x24],r12
8000cf30:	99 15       	st.w	r12[0x4],r5
8000cf32:	99 25       	st.w	r12[0x8],r5
8000cf34:	99 05       	st.w	r12[0x0],r5
8000cf36:	6e 99       	ld.w	r9,r7[0x24]
8000cf38:	72 08       	ld.w	r8,r9[0x0]
8000cf3a:	58 08       	cp.w	r8,0
8000cf3c:	c0 f0       	breq	8000cf5a <_dtoa_r+0x5a>
8000cf3e:	72 1a       	ld.w	r10,r9[0x4]
8000cf40:	91 1a       	st.w	r8[0x4],r10
8000cf42:	30 1a       	mov	r10,1
8000cf44:	72 19       	ld.w	r9,r9[0x4]
8000cf46:	f4 09 09 49 	lsl	r9,r10,r9
8000cf4a:	10 9b       	mov	r11,r8
8000cf4c:	91 29       	st.w	r8[0x8],r9
8000cf4e:	0e 9c       	mov	r12,r7
8000cf50:	e0 a0 0a 96 	rcall	8000e47c <_Bfree>
8000cf54:	6e 98       	ld.w	r8,r7[0x24]
8000cf56:	30 09       	mov	r9,0
8000cf58:	91 09       	st.w	r8[0x0],r9
8000cf5a:	40 28       	lddsp	r8,sp[0x8]
8000cf5c:	10 94       	mov	r4,r8
8000cf5e:	58 08       	cp.w	r8,0
8000cf60:	c0 64       	brge	8000cf6c <_dtoa_r+0x6c>
8000cf62:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000cf66:	50 28       	stdsp	sp[0x8],r8
8000cf68:	30 18       	mov	r8,1
8000cf6a:	c0 28       	rjmp	8000cf6e <_dtoa_r+0x6e>
8000cf6c:	30 08       	mov	r8,0
8000cf6e:	8d 08       	st.w	r6[0x0],r8
8000cf70:	fc 1c 7f f0 	movh	r12,0x7ff0
8000cf74:	40 26       	lddsp	r6,sp[0x8]
8000cf76:	0c 98       	mov	r8,r6
8000cf78:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000cf7c:	18 38       	cp.w	r8,r12
8000cf7e:	c1 e1       	brne	8000cfba <_dtoa_r+0xba>
8000cf80:	e0 68 27 0f 	mov	r8,9999
8000cf84:	41 5b       	lddsp	r11,sp[0x54]
8000cf86:	97 08       	st.w	r11[0x0],r8
8000cf88:	40 3a       	lddsp	r10,sp[0xc]
8000cf8a:	58 0a       	cp.w	r10,0
8000cf8c:	c0 61       	brne	8000cf98 <_dtoa_r+0x98>
8000cf8e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000cf92:	c0 31       	brne	8000cf98 <_dtoa_r+0x98>
8000cf94:	4a cc       	lddpc	r12,8000d044 <_dtoa_r+0x144>
8000cf96:	c0 28       	rjmp	8000cf9a <_dtoa_r+0x9a>
8000cf98:	4a cc       	lddpc	r12,8000d048 <_dtoa_r+0x148>
8000cf9a:	41 29       	lddsp	r9,sp[0x48]
8000cf9c:	58 09       	cp.w	r9,0
8000cf9e:	e0 80 05 9e 	breq	8000dada <_dtoa_r+0xbda>
8000cfa2:	f8 c8 ff fd 	sub	r8,r12,-3
8000cfa6:	f8 c9 ff f8 	sub	r9,r12,-8
8000cfaa:	11 8b       	ld.ub	r11,r8[0x0]
8000cfac:	30 0a       	mov	r10,0
8000cfae:	41 25       	lddsp	r5,sp[0x48]
8000cfb0:	f4 0b 18 00 	cp.b	r11,r10
8000cfb4:	f2 08 17 10 	movne	r8,r9
8000cfb8:	c1 58       	rjmp	8000cfe2 <_dtoa_r+0xe2>
8000cfba:	fa ea 00 08 	ld.d	r10,sp[8]
8000cfbe:	30 08       	mov	r8,0
8000cfc0:	fa eb 00 3c 	st.d	sp[60],r10
8000cfc4:	30 09       	mov	r9,0
8000cfc6:	e0 a0 10 ce 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000cfca:	c0 f0       	breq	8000cfe8 <_dtoa_r+0xe8>
8000cfcc:	30 18       	mov	r8,1
8000cfce:	41 5a       	lddsp	r10,sp[0x54]
8000cfd0:	95 08       	st.w	r10[0x0],r8
8000cfd2:	49 fc       	lddpc	r12,8000d04c <_dtoa_r+0x14c>
8000cfd4:	41 29       	lddsp	r9,sp[0x48]
8000cfd6:	f8 08 00 08 	add	r8,r12,r8
8000cfda:	58 09       	cp.w	r9,0
8000cfdc:	e0 80 05 7f 	breq	8000dada <_dtoa_r+0xbda>
8000cfe0:	12 95       	mov	r5,r9
8000cfe2:	8b 08       	st.w	r5[0x0],r8
8000cfe4:	e0 8f 05 7b 	bral	8000dada <_dtoa_r+0xbda>
8000cfe8:	fa c8 ff 9c 	sub	r8,sp,-100
8000cfec:	fa c9 ff a0 	sub	r9,sp,-96
8000cff0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000cff4:	0e 9c       	mov	r12,r7
8000cff6:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000cffa:	e0 a0 0a 93 	rcall	8000e520 <__d2b>
8000cffe:	18 93       	mov	r3,r12
8000d000:	58 05       	cp.w	r5,0
8000d002:	c0 d0       	breq	8000d01c <_dtoa_r+0x11c>
8000d004:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d008:	30 04       	mov	r4,0
8000d00a:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d00e:	ea c5 03 ff 	sub	r5,r5,1023
8000d012:	10 9b       	mov	r11,r8
8000d014:	51 74       	stdsp	sp[0x5c],r4
8000d016:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d01a:	c2 a8       	rjmp	8000d06e <_dtoa_r+0x16e>
8000d01c:	41 88       	lddsp	r8,sp[0x60]
8000d01e:	41 9c       	lddsp	r12,sp[0x64]
8000d020:	10 0c       	add	r12,r8
8000d022:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d026:	e0 45 00 20 	cp.w	r5,32
8000d02a:	e0 8a 00 13 	brle	8000d050 <_dtoa_r+0x150>
8000d02e:	f8 cc fb ee 	sub	r12,r12,-1042
8000d032:	40 3b       	lddsp	r11,sp[0xc]
8000d034:	ea 08 11 40 	rsub	r8,r5,64
8000d038:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d03c:	ec 08 09 46 	lsl	r6,r6,r8
8000d040:	0c 4c       	or	r12,r6
8000d042:	c0 c8       	rjmp	8000d05a <_dtoa_r+0x15a>
8000d044:	80 01       	ld.sh	r1,r0[0x0]
8000d046:	90 c0       	ld.uh	r0,r8[0x8]
8000d048:	80 01       	ld.sh	r1,r0[0x0]
8000d04a:	90 cc       	ld.uh	r12,r8[0x8]
8000d04c:	80 01       	ld.sh	r1,r0[0x0]
8000d04e:	8f 9c       	st.w	r7[0x24],r12
8000d050:	ea 0c 11 20 	rsub	r12,r5,32
8000d054:	40 3a       	lddsp	r10,sp[0xc]
8000d056:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d05a:	e0 a0 10 10 	rcall	8000f07a <__avr32_u32_to_f64>
8000d05e:	fc 18 fe 10 	movh	r8,0xfe10
8000d062:	30 19       	mov	r9,1
8000d064:	ea c5 04 33 	sub	r5,r5,1075
8000d068:	f0 0b 00 0b 	add	r11,r8,r11
8000d06c:	51 79       	stdsp	sp[0x5c],r9
8000d06e:	30 08       	mov	r8,0
8000d070:	fc 19 3f f8 	movh	r9,0x3ff8
8000d074:	e0 a0 0e 98 	rcall	8000eda4 <__avr32_f64_sub>
8000d078:	e0 68 43 61 	mov	r8,17249
8000d07c:	ea 18 63 6f 	orh	r8,0x636f
8000d080:	e0 69 87 a7 	mov	r9,34727
8000d084:	ea 19 3f d2 	orh	r9,0x3fd2
8000d088:	e0 a0 0d a2 	rcall	8000ebcc <__avr32_f64_mul>
8000d08c:	e0 68 c8 b3 	mov	r8,51379
8000d090:	ea 18 8b 60 	orh	r8,0x8b60
8000d094:	e0 69 8a 28 	mov	r9,35368
8000d098:	ea 19 3f c6 	orh	r9,0x3fc6
8000d09c:	e0 a0 0f 52 	rcall	8000ef40 <__avr32_f64_add>
8000d0a0:	0a 9c       	mov	r12,r5
8000d0a2:	14 90       	mov	r0,r10
8000d0a4:	16 91       	mov	r1,r11
8000d0a6:	e0 a0 0f ee 	rcall	8000f082 <__avr32_s32_to_f64>
8000d0aa:	e0 68 79 fb 	mov	r8,31227
8000d0ae:	ea 18 50 9f 	orh	r8,0x509f
8000d0b2:	e0 69 44 13 	mov	r9,17427
8000d0b6:	ea 19 3f d3 	orh	r9,0x3fd3
8000d0ba:	e0 a0 0d 89 	rcall	8000ebcc <__avr32_f64_mul>
8000d0be:	14 98       	mov	r8,r10
8000d0c0:	16 99       	mov	r9,r11
8000d0c2:	00 9a       	mov	r10,r0
8000d0c4:	02 9b       	mov	r11,r1
8000d0c6:	e0 a0 0f 3d 	rcall	8000ef40 <__avr32_f64_add>
8000d0ca:	14 90       	mov	r0,r10
8000d0cc:	16 91       	mov	r1,r11
8000d0ce:	e0 a0 0f c3 	rcall	8000f054 <__avr32_f64_to_s32>
8000d0d2:	30 08       	mov	r8,0
8000d0d4:	18 96       	mov	r6,r12
8000d0d6:	30 09       	mov	r9,0
8000d0d8:	00 9a       	mov	r10,r0
8000d0da:	02 9b       	mov	r11,r1
8000d0dc:	e0 a0 10 8a 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d0e0:	c0 c0       	breq	8000d0f8 <_dtoa_r+0x1f8>
8000d0e2:	0c 9c       	mov	r12,r6
8000d0e4:	e0 a0 0f cf 	rcall	8000f082 <__avr32_s32_to_f64>
8000d0e8:	14 98       	mov	r8,r10
8000d0ea:	16 99       	mov	r9,r11
8000d0ec:	00 9a       	mov	r10,r0
8000d0ee:	02 9b       	mov	r11,r1
8000d0f0:	e0 a0 10 39 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000d0f4:	f7 b6 00 01 	subeq	r6,1
8000d0f8:	59 66       	cp.w	r6,22
8000d0fa:	e0 88 00 05 	brls	8000d104 <_dtoa_r+0x204>
8000d0fe:	30 18       	mov	r8,1
8000d100:	51 48       	stdsp	sp[0x50],r8
8000d102:	c1 28       	rjmp	8000d126 <_dtoa_r+0x226>
8000d104:	4c 08       	lddpc	r8,8000d204 <_dtoa_r+0x304>
8000d106:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d10a:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d10e:	e0 a0 10 71 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d112:	f9 b4 00 00 	moveq	r4,0
8000d116:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d11a:	f7 b6 01 01 	subne	r6,1
8000d11e:	f9 bc 01 00 	movne	r12,0
8000d122:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d126:	41 90       	lddsp	r0,sp[0x64]
8000d128:	20 10       	sub	r0,1
8000d12a:	0a 10       	sub	r0,r5
8000d12c:	c0 46       	brmi	8000d134 <_dtoa_r+0x234>
8000d12e:	50 40       	stdsp	sp[0x10],r0
8000d130:	30 00       	mov	r0,0
8000d132:	c0 48       	rjmp	8000d13a <_dtoa_r+0x23a>
8000d134:	30 0b       	mov	r11,0
8000d136:	5c 30       	neg	r0
8000d138:	50 4b       	stdsp	sp[0x10],r11
8000d13a:	ec 02 11 00 	rsub	r2,r6,0
8000d13e:	58 06       	cp.w	r6,0
8000d140:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d144:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d148:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d14c:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d150:	f9 b2 04 00 	movge	r2,0
8000d154:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d158:	f9 b9 05 00 	movlt	r9,0
8000d15c:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d160:	40 c8       	lddsp	r8,sp[0x30]
8000d162:	58 98       	cp.w	r8,9
8000d164:	e0 8b 00 20 	brhi	8000d1a4 <_dtoa_r+0x2a4>
8000d168:	58 58       	cp.w	r8,5
8000d16a:	f9 b4 0a 01 	movle	r4,1
8000d16e:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d172:	f7 b5 09 04 	subgt	r5,4
8000d176:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d17a:	f9 b4 09 00 	movgt	r4,0
8000d17e:	40 cc       	lddsp	r12,sp[0x30]
8000d180:	58 3c       	cp.w	r12,3
8000d182:	c2 d0       	breq	8000d1dc <_dtoa_r+0x2dc>
8000d184:	e0 89 00 05 	brgt	8000d18e <_dtoa_r+0x28e>
8000d188:	58 2c       	cp.w	r12,2
8000d18a:	c1 01       	brne	8000d1aa <_dtoa_r+0x2aa>
8000d18c:	c1 88       	rjmp	8000d1bc <_dtoa_r+0x2bc>
8000d18e:	40 cb       	lddsp	r11,sp[0x30]
8000d190:	58 4b       	cp.w	r11,4
8000d192:	c0 60       	breq	8000d19e <_dtoa_r+0x29e>
8000d194:	58 5b       	cp.w	r11,5
8000d196:	c0 a1       	brne	8000d1aa <_dtoa_r+0x2aa>
8000d198:	30 1a       	mov	r10,1
8000d19a:	50 da       	stdsp	sp[0x34],r10
8000d19c:	c2 28       	rjmp	8000d1e0 <_dtoa_r+0x2e0>
8000d19e:	30 19       	mov	r9,1
8000d1a0:	50 d9       	stdsp	sp[0x34],r9
8000d1a2:	c0 f8       	rjmp	8000d1c0 <_dtoa_r+0x2c0>
8000d1a4:	30 08       	mov	r8,0
8000d1a6:	30 14       	mov	r4,1
8000d1a8:	50 c8       	stdsp	sp[0x30],r8
8000d1aa:	3f f5       	mov	r5,-1
8000d1ac:	30 1c       	mov	r12,1
8000d1ae:	30 0b       	mov	r11,0
8000d1b0:	50 95       	stdsp	sp[0x24],r5
8000d1b2:	50 dc       	stdsp	sp[0x34],r12
8000d1b4:	0a 91       	mov	r1,r5
8000d1b6:	31 28       	mov	r8,18
8000d1b8:	50 eb       	stdsp	sp[0x38],r11
8000d1ba:	c2 08       	rjmp	8000d1fa <_dtoa_r+0x2fa>
8000d1bc:	30 0a       	mov	r10,0
8000d1be:	50 da       	stdsp	sp[0x34],r10
8000d1c0:	40 e9       	lddsp	r9,sp[0x38]
8000d1c2:	58 09       	cp.w	r9,0
8000d1c4:	e0 89 00 07 	brgt	8000d1d2 <_dtoa_r+0x2d2>
8000d1c8:	30 18       	mov	r8,1
8000d1ca:	50 98       	stdsp	sp[0x24],r8
8000d1cc:	10 91       	mov	r1,r8
8000d1ce:	50 e8       	stdsp	sp[0x38],r8
8000d1d0:	c1 58       	rjmp	8000d1fa <_dtoa_r+0x2fa>
8000d1d2:	40 e5       	lddsp	r5,sp[0x38]
8000d1d4:	50 95       	stdsp	sp[0x24],r5
8000d1d6:	0a 91       	mov	r1,r5
8000d1d8:	0a 98       	mov	r8,r5
8000d1da:	c1 08       	rjmp	8000d1fa <_dtoa_r+0x2fa>
8000d1dc:	30 0c       	mov	r12,0
8000d1de:	50 dc       	stdsp	sp[0x34],r12
8000d1e0:	40 eb       	lddsp	r11,sp[0x38]
8000d1e2:	ec 0b 00 0b 	add	r11,r6,r11
8000d1e6:	50 9b       	stdsp	sp[0x24],r11
8000d1e8:	16 98       	mov	r8,r11
8000d1ea:	2f f8       	sub	r8,-1
8000d1ec:	58 08       	cp.w	r8,0
8000d1ee:	e0 89 00 05 	brgt	8000d1f8 <_dtoa_r+0x2f8>
8000d1f2:	10 91       	mov	r1,r8
8000d1f4:	30 18       	mov	r8,1
8000d1f6:	c0 28       	rjmp	8000d1fa <_dtoa_r+0x2fa>
8000d1f8:	10 91       	mov	r1,r8
8000d1fa:	30 09       	mov	r9,0
8000d1fc:	6e 9a       	ld.w	r10,r7[0x24]
8000d1fe:	95 19       	st.w	r10[0x4],r9
8000d200:	30 49       	mov	r9,4
8000d202:	c0 78       	rjmp	8000d210 <_dtoa_r+0x310>
8000d204:	80 01       	ld.sh	r1,r0[0x0]
8000d206:	91 80       	st.w	r8[0x20],r0
8000d208:	6a 1a       	ld.w	r10,r5[0x4]
8000d20a:	a1 79       	lsl	r9,0x1
8000d20c:	2f fa       	sub	r10,-1
8000d20e:	8b 1a       	st.w	r5[0x4],r10
8000d210:	6e 95       	ld.w	r5,r7[0x24]
8000d212:	f2 ca ff ec 	sub	r10,r9,-20
8000d216:	10 3a       	cp.w	r10,r8
8000d218:	fe 98 ff f8 	brls	8000d208 <_dtoa_r+0x308>
8000d21c:	6a 1b       	ld.w	r11,r5[0x4]
8000d21e:	0e 9c       	mov	r12,r7
8000d220:	e0 a0 09 48 	rcall	8000e4b0 <_Balloc>
8000d224:	58 e1       	cp.w	r1,14
8000d226:	5f 88       	srls	r8
8000d228:	8b 0c       	st.w	r5[0x0],r12
8000d22a:	f1 e4 00 04 	and	r4,r8,r4
8000d22e:	6e 98       	ld.w	r8,r7[0x24]
8000d230:	70 08       	ld.w	r8,r8[0x0]
8000d232:	50 88       	stdsp	sp[0x20],r8
8000d234:	e0 80 01 82 	breq	8000d538 <_dtoa_r+0x638>
8000d238:	58 06       	cp.w	r6,0
8000d23a:	e0 8a 00 40 	brle	8000d2ba <_dtoa_r+0x3ba>
8000d23e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d242:	4c b8       	lddpc	r8,8000d36c <_dtoa_r+0x46c>
8000d244:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d248:	fa e5 00 18 	st.d	sp[24],r4
8000d24c:	ec 04 14 04 	asr	r4,r6,0x4
8000d250:	ed b4 00 04 	bld	r4,0x4
8000d254:	c0 30       	breq	8000d25a <_dtoa_r+0x35a>
8000d256:	30 25       	mov	r5,2
8000d258:	c0 f8       	rjmp	8000d276 <_dtoa_r+0x376>
8000d25a:	4c 68       	lddpc	r8,8000d370 <_dtoa_r+0x470>
8000d25c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d260:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d264:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d268:	e0 a0 0f f8 	rcall	8000f258 <__avr32_f64_div>
8000d26c:	30 35       	mov	r5,3
8000d26e:	14 98       	mov	r8,r10
8000d270:	16 99       	mov	r9,r11
8000d272:	fa e9 00 08 	st.d	sp[8],r8
8000d276:	4b fc       	lddpc	r12,8000d370 <_dtoa_r+0x470>
8000d278:	50 a3       	stdsp	sp[0x28],r3
8000d27a:	0c 93       	mov	r3,r6
8000d27c:	18 96       	mov	r6,r12
8000d27e:	c0 f8       	rjmp	8000d29c <_dtoa_r+0x39c>
8000d280:	fa ea 00 18 	ld.d	r10,sp[24]
8000d284:	ed b4 00 00 	bld	r4,0x0
8000d288:	c0 81       	brne	8000d298 <_dtoa_r+0x398>
8000d28a:	ec e8 00 00 	ld.d	r8,r6[0]
8000d28e:	2f f5       	sub	r5,-1
8000d290:	e0 a0 0c 9e 	rcall	8000ebcc <__avr32_f64_mul>
8000d294:	fa eb 00 18 	st.d	sp[24],r10
8000d298:	a1 54       	asr	r4,0x1
8000d29a:	2f 86       	sub	r6,-8
8000d29c:	58 04       	cp.w	r4,0
8000d29e:	cf 11       	brne	8000d280 <_dtoa_r+0x380>
8000d2a0:	fa e8 00 18 	ld.d	r8,sp[24]
8000d2a4:	fa ea 00 08 	ld.d	r10,sp[8]
8000d2a8:	06 96       	mov	r6,r3
8000d2aa:	e0 a0 0f d7 	rcall	8000f258 <__avr32_f64_div>
8000d2ae:	40 a3       	lddsp	r3,sp[0x28]
8000d2b0:	14 98       	mov	r8,r10
8000d2b2:	16 99       	mov	r9,r11
8000d2b4:	fa e9 00 08 	st.d	sp[8],r8
8000d2b8:	c2 d8       	rjmp	8000d312 <_dtoa_r+0x412>
8000d2ba:	ec 08 11 00 	rsub	r8,r6,0
8000d2be:	c0 31       	brne	8000d2c4 <_dtoa_r+0x3c4>
8000d2c0:	30 25       	mov	r5,2
8000d2c2:	c2 88       	rjmp	8000d312 <_dtoa_r+0x412>
8000d2c4:	4a bc       	lddpc	r12,8000d370 <_dtoa_r+0x470>
8000d2c6:	f0 04 14 04 	asr	r4,r8,0x4
8000d2ca:	50 1c       	stdsp	sp[0x4],r12
8000d2cc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d2d0:	4a 79       	lddpc	r9,8000d36c <_dtoa_r+0x46c>
8000d2d2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d2d6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d2da:	e0 a0 0c 79 	rcall	8000ebcc <__avr32_f64_mul>
8000d2de:	40 1c       	lddsp	r12,sp[0x4]
8000d2e0:	50 63       	stdsp	sp[0x18],r3
8000d2e2:	30 25       	mov	r5,2
8000d2e4:	0c 93       	mov	r3,r6
8000d2e6:	fa eb 00 08 	st.d	sp[8],r10
8000d2ea:	18 96       	mov	r6,r12
8000d2ec:	c0 f8       	rjmp	8000d30a <_dtoa_r+0x40a>
8000d2ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000d2f2:	ed b4 00 00 	bld	r4,0x0
8000d2f6:	c0 81       	brne	8000d306 <_dtoa_r+0x406>
8000d2f8:	ec e8 00 00 	ld.d	r8,r6[0]
8000d2fc:	2f f5       	sub	r5,-1
8000d2fe:	e0 a0 0c 67 	rcall	8000ebcc <__avr32_f64_mul>
8000d302:	fa eb 00 08 	st.d	sp[8],r10
8000d306:	a1 54       	asr	r4,0x1
8000d308:	2f 86       	sub	r6,-8
8000d30a:	58 04       	cp.w	r4,0
8000d30c:	cf 11       	brne	8000d2ee <_dtoa_r+0x3ee>
8000d30e:	06 96       	mov	r6,r3
8000d310:	40 63       	lddsp	r3,sp[0x18]
8000d312:	41 4a       	lddsp	r10,sp[0x50]
8000d314:	58 0a       	cp.w	r10,0
8000d316:	c2 f0       	breq	8000d374 <_dtoa_r+0x474>
8000d318:	fa e8 00 08 	ld.d	r8,sp[8]
8000d31c:	58 01       	cp.w	r1,0
8000d31e:	5f 94       	srgt	r4
8000d320:	fa e9 00 18 	st.d	sp[24],r8
8000d324:	30 08       	mov	r8,0
8000d326:	fc 19 3f f0 	movh	r9,0x3ff0
8000d32a:	fa ea 00 18 	ld.d	r10,sp[24]
8000d32e:	e0 a0 0f 61 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d332:	f9 bc 00 00 	moveq	r12,0
8000d336:	f9 bc 01 01 	movne	r12,1
8000d33a:	e9 ec 00 0c 	and	r12,r4,r12
8000d33e:	c1 b0       	breq	8000d374 <_dtoa_r+0x474>
8000d340:	40 98       	lddsp	r8,sp[0x24]
8000d342:	58 08       	cp.w	r8,0
8000d344:	e0 8a 00 f6 	brle	8000d530 <_dtoa_r+0x630>
8000d348:	30 08       	mov	r8,0
8000d34a:	fc 19 40 24 	movh	r9,0x4024
8000d34e:	ec c4 00 01 	sub	r4,r6,1
8000d352:	fa ea 00 18 	ld.d	r10,sp[24]
8000d356:	2f f5       	sub	r5,-1
8000d358:	50 64       	stdsp	sp[0x18],r4
8000d35a:	e0 a0 0c 39 	rcall	8000ebcc <__avr32_f64_mul>
8000d35e:	40 94       	lddsp	r4,sp[0x24]
8000d360:	14 98       	mov	r8,r10
8000d362:	16 99       	mov	r9,r11
8000d364:	fa e9 00 08 	st.d	sp[8],r8
8000d368:	c0 88       	rjmp	8000d378 <_dtoa_r+0x478>
8000d36a:	d7 03       	nop
8000d36c:	80 01       	ld.sh	r1,r0[0x0]
8000d36e:	91 80       	st.w	r8[0x20],r0
8000d370:	80 01       	ld.sh	r1,r0[0x0]
8000d372:	92 48       	ld.sh	r8,r9[0x8]
8000d374:	50 66       	stdsp	sp[0x18],r6
8000d376:	02 94       	mov	r4,r1
8000d378:	0a 9c       	mov	r12,r5
8000d37a:	e0 a0 0e 84 	rcall	8000f082 <__avr32_s32_to_f64>
8000d37e:	fa e8 00 08 	ld.d	r8,sp[8]
8000d382:	e0 a0 0c 25 	rcall	8000ebcc <__avr32_f64_mul>
8000d386:	30 08       	mov	r8,0
8000d388:	fc 19 40 1c 	movh	r9,0x401c
8000d38c:	e0 a0 0d da 	rcall	8000ef40 <__avr32_f64_add>
8000d390:	14 98       	mov	r8,r10
8000d392:	16 99       	mov	r9,r11
8000d394:	fa e9 00 28 	st.d	sp[40],r8
8000d398:	fc 18 fc c0 	movh	r8,0xfcc0
8000d39c:	40 a5       	lddsp	r5,sp[0x28]
8000d39e:	10 05       	add	r5,r8
8000d3a0:	50 a5       	stdsp	sp[0x28],r5
8000d3a2:	58 04       	cp.w	r4,0
8000d3a4:	c2 11       	brne	8000d3e6 <_dtoa_r+0x4e6>
8000d3a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d3aa:	30 08       	mov	r8,0
8000d3ac:	fc 19 40 14 	movh	r9,0x4014
8000d3b0:	e0 a0 0c fa 	rcall	8000eda4 <__avr32_f64_sub>
8000d3b4:	40 bc       	lddsp	r12,sp[0x2c]
8000d3b6:	fa eb 00 08 	st.d	sp[8],r10
8000d3ba:	14 98       	mov	r8,r10
8000d3bc:	16 99       	mov	r9,r11
8000d3be:	18 9a       	mov	r10,r12
8000d3c0:	0a 9b       	mov	r11,r5
8000d3c2:	e0 a0 0f 17 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d3c6:	e0 81 02 54 	brne	8000d86e <_dtoa_r+0x96e>
8000d3ca:	0a 98       	mov	r8,r5
8000d3cc:	40 b9       	lddsp	r9,sp[0x2c]
8000d3ce:	ee 18 80 00 	eorh	r8,0x8000
8000d3d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000d3d6:	10 95       	mov	r5,r8
8000d3d8:	12 98       	mov	r8,r9
8000d3da:	0a 99       	mov	r9,r5
8000d3dc:	e0 a0 0f 0a 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d3e0:	e0 81 02 3e 	brne	8000d85c <_dtoa_r+0x95c>
8000d3e4:	ca 68       	rjmp	8000d530 <_dtoa_r+0x630>
8000d3e6:	4c e9       	lddpc	r9,8000d51c <_dtoa_r+0x61c>
8000d3e8:	e8 c8 00 01 	sub	r8,r4,1
8000d3ec:	40 d5       	lddsp	r5,sp[0x34]
8000d3ee:	58 05       	cp.w	r5,0
8000d3f0:	c4 f0       	breq	8000d48e <_dtoa_r+0x58e>
8000d3f2:	30 0c       	mov	r12,0
8000d3f4:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d3f8:	51 3c       	stdsp	sp[0x4c],r12
8000d3fa:	30 0a       	mov	r10,0
8000d3fc:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d400:	e0 a0 0f 2c 	rcall	8000f258 <__avr32_f64_div>
8000d404:	fa e8 00 28 	ld.d	r8,sp[40]
8000d408:	40 85       	lddsp	r5,sp[0x20]
8000d40a:	e0 a0 0c cd 	rcall	8000eda4 <__avr32_f64_sub>
8000d40e:	fa eb 00 28 	st.d	sp[40],r10
8000d412:	fa ea 00 08 	ld.d	r10,sp[8]
8000d416:	e0 a0 0e 1f 	rcall	8000f054 <__avr32_f64_to_s32>
8000d41a:	51 6c       	stdsp	sp[0x58],r12
8000d41c:	e0 a0 0e 33 	rcall	8000f082 <__avr32_s32_to_f64>
8000d420:	14 98       	mov	r8,r10
8000d422:	16 99       	mov	r9,r11
8000d424:	fa ea 00 08 	ld.d	r10,sp[8]
8000d428:	e0 a0 0c be 	rcall	8000eda4 <__avr32_f64_sub>
8000d42c:	fa eb 00 08 	st.d	sp[8],r10
8000d430:	41 68       	lddsp	r8,sp[0x58]
8000d432:	2d 08       	sub	r8,-48
8000d434:	0a c8       	st.b	r5++,r8
8000d436:	41 39       	lddsp	r9,sp[0x4c]
8000d438:	2f f9       	sub	r9,-1
8000d43a:	51 39       	stdsp	sp[0x4c],r9
8000d43c:	fa e8 00 28 	ld.d	r8,sp[40]
8000d440:	e0 a0 0e d8 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d444:	e0 81 03 3a 	brne	8000dab8 <_dtoa_r+0xbb8>
8000d448:	fa e8 00 08 	ld.d	r8,sp[8]
8000d44c:	30 0a       	mov	r10,0
8000d44e:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d452:	e0 a0 0c a9 	rcall	8000eda4 <__avr32_f64_sub>
8000d456:	fa e8 00 28 	ld.d	r8,sp[40]
8000d45a:	e0 a0 0e cb 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d45e:	fa ea 00 28 	ld.d	r10,sp[40]
8000d462:	30 08       	mov	r8,0
8000d464:	fc 19 40 24 	movh	r9,0x4024
8000d468:	e0 81 00 da 	brne	8000d61c <_dtoa_r+0x71c>
8000d46c:	41 3c       	lddsp	r12,sp[0x4c]
8000d46e:	08 3c       	cp.w	r12,r4
8000d470:	c6 04       	brge	8000d530 <_dtoa_r+0x630>
8000d472:	e0 a0 0b ad 	rcall	8000ebcc <__avr32_f64_mul>
8000d476:	30 08       	mov	r8,0
8000d478:	fa eb 00 28 	st.d	sp[40],r10
8000d47c:	fc 19 40 24 	movh	r9,0x4024
8000d480:	fa ea 00 08 	ld.d	r10,sp[8]
8000d484:	e0 a0 0b a4 	rcall	8000ebcc <__avr32_f64_mul>
8000d488:	fa eb 00 08 	st.d	sp[8],r10
8000d48c:	cc 3b       	rjmp	8000d412 <_dtoa_r+0x512>
8000d48e:	40 85       	lddsp	r5,sp[0x20]
8000d490:	08 05       	add	r5,r4
8000d492:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d496:	51 35       	stdsp	sp[0x4c],r5
8000d498:	fa e8 00 28 	ld.d	r8,sp[40]
8000d49c:	40 85       	lddsp	r5,sp[0x20]
8000d49e:	e0 a0 0b 97 	rcall	8000ebcc <__avr32_f64_mul>
8000d4a2:	fa eb 00 28 	st.d	sp[40],r10
8000d4a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4aa:	e0 a0 0d d5 	rcall	8000f054 <__avr32_f64_to_s32>
8000d4ae:	51 6c       	stdsp	sp[0x58],r12
8000d4b0:	e0 a0 0d e9 	rcall	8000f082 <__avr32_s32_to_f64>
8000d4b4:	14 98       	mov	r8,r10
8000d4b6:	16 99       	mov	r9,r11
8000d4b8:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4bc:	e0 a0 0c 74 	rcall	8000eda4 <__avr32_f64_sub>
8000d4c0:	fa eb 00 08 	st.d	sp[8],r10
8000d4c4:	41 68       	lddsp	r8,sp[0x58]
8000d4c6:	2d 08       	sub	r8,-48
8000d4c8:	0a c8       	st.b	r5++,r8
8000d4ca:	41 3c       	lddsp	r12,sp[0x4c]
8000d4cc:	18 35       	cp.w	r5,r12
8000d4ce:	c2 91       	brne	8000d520 <_dtoa_r+0x620>
8000d4d0:	30 08       	mov	r8,0
8000d4d2:	fc 19 3f e0 	movh	r9,0x3fe0
8000d4d6:	fa ea 00 28 	ld.d	r10,sp[40]
8000d4da:	e0 a0 0d 33 	rcall	8000ef40 <__avr32_f64_add>
8000d4de:	40 85       	lddsp	r5,sp[0x20]
8000d4e0:	fa e8 00 08 	ld.d	r8,sp[8]
8000d4e4:	08 05       	add	r5,r4
8000d4e6:	e0 a0 0e 85 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d4ea:	e0 81 00 99 	brne	8000d61c <_dtoa_r+0x71c>
8000d4ee:	fa e8 00 28 	ld.d	r8,sp[40]
8000d4f2:	30 0a       	mov	r10,0
8000d4f4:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d4f8:	e0 a0 0c 56 	rcall	8000eda4 <__avr32_f64_sub>
8000d4fc:	14 98       	mov	r8,r10
8000d4fe:	16 99       	mov	r9,r11
8000d500:	fa ea 00 08 	ld.d	r10,sp[8]
8000d504:	e0 a0 0e 76 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d508:	c1 40       	breq	8000d530 <_dtoa_r+0x630>
8000d50a:	33 09       	mov	r9,48
8000d50c:	0a 98       	mov	r8,r5
8000d50e:	11 7a       	ld.ub	r10,--r8
8000d510:	f2 0a 18 00 	cp.b	r10,r9
8000d514:	e0 81 02 d2 	brne	8000dab8 <_dtoa_r+0xbb8>
8000d518:	10 95       	mov	r5,r8
8000d51a:	cf 9b       	rjmp	8000d50c <_dtoa_r+0x60c>
8000d51c:	80 01       	ld.sh	r1,r0[0x0]
8000d51e:	91 80       	st.w	r8[0x20],r0
8000d520:	30 08       	mov	r8,0
8000d522:	fc 19 40 24 	movh	r9,0x4024
8000d526:	e0 a0 0b 53 	rcall	8000ebcc <__avr32_f64_mul>
8000d52a:	fa eb 00 08 	st.d	sp[8],r10
8000d52e:	cb cb       	rjmp	8000d4a6 <_dtoa_r+0x5a6>
8000d530:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d534:	fa eb 00 08 	st.d	sp[8],r10
8000d538:	58 e6       	cp.w	r6,14
8000d53a:	5f ab       	srle	r11
8000d53c:	41 8a       	lddsp	r10,sp[0x60]
8000d53e:	30 08       	mov	r8,0
8000d540:	f4 09 11 ff 	rsub	r9,r10,-1
8000d544:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000d548:	f0 09 18 00 	cp.b	r9,r8
8000d54c:	e0 80 00 81 	breq	8000d64e <_dtoa_r+0x74e>
8000d550:	40 ea       	lddsp	r10,sp[0x38]
8000d552:	58 01       	cp.w	r1,0
8000d554:	5f a9       	srle	r9
8000d556:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000d55a:	4c 9a       	lddpc	r10,8000d67c <_dtoa_r+0x77c>
8000d55c:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000d560:	fa e5 00 10 	st.d	sp[16],r4
8000d564:	f0 09 18 00 	cp.b	r9,r8
8000d568:	c1 40       	breq	8000d590 <_dtoa_r+0x690>
8000d56a:	58 01       	cp.w	r1,0
8000d56c:	e0 81 01 78 	brne	8000d85c <_dtoa_r+0x95c>
8000d570:	30 08       	mov	r8,0
8000d572:	fc 19 40 14 	movh	r9,0x4014
8000d576:	08 9a       	mov	r10,r4
8000d578:	0a 9b       	mov	r11,r5
8000d57a:	e0 a0 0b 29 	rcall	8000ebcc <__avr32_f64_mul>
8000d57e:	fa e8 00 08 	ld.d	r8,sp[8]
8000d582:	e0 a0 0e 03 	rcall	8000f188 <__avr32_f64_cmp_ge>
8000d586:	e0 81 01 6b 	brne	8000d85c <_dtoa_r+0x95c>
8000d58a:	02 92       	mov	r2,r1
8000d58c:	e0 8f 01 73 	bral	8000d872 <_dtoa_r+0x972>
8000d590:	40 85       	lddsp	r5,sp[0x20]
8000d592:	30 14       	mov	r4,1
8000d594:	fa e8 00 10 	ld.d	r8,sp[16]
8000d598:	fa ea 00 08 	ld.d	r10,sp[8]
8000d59c:	e0 a0 0e 5e 	rcall	8000f258 <__avr32_f64_div>
8000d5a0:	e0 a0 0d 5a 	rcall	8000f054 <__avr32_f64_to_s32>
8000d5a4:	18 92       	mov	r2,r12
8000d5a6:	e0 a0 0d 6e 	rcall	8000f082 <__avr32_s32_to_f64>
8000d5aa:	fa e8 00 10 	ld.d	r8,sp[16]
8000d5ae:	e0 a0 0b 0f 	rcall	8000ebcc <__avr32_f64_mul>
8000d5b2:	14 98       	mov	r8,r10
8000d5b4:	16 99       	mov	r9,r11
8000d5b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d5ba:	e0 a0 0b f5 	rcall	8000eda4 <__avr32_f64_sub>
8000d5be:	fa eb 00 08 	st.d	sp[8],r10
8000d5c2:	e4 c8 ff d0 	sub	r8,r2,-48
8000d5c6:	0a c8       	st.b	r5++,r8
8000d5c8:	fc 19 40 24 	movh	r9,0x4024
8000d5cc:	30 08       	mov	r8,0
8000d5ce:	02 34       	cp.w	r4,r1
8000d5d0:	c3 31       	brne	8000d636 <_dtoa_r+0x736>
8000d5d2:	fa e8 00 08 	ld.d	r8,sp[8]
8000d5d6:	e0 a0 0c b5 	rcall	8000ef40 <__avr32_f64_add>
8000d5da:	16 91       	mov	r1,r11
8000d5dc:	14 90       	mov	r0,r10
8000d5de:	14 98       	mov	r8,r10
8000d5e0:	02 99       	mov	r9,r1
8000d5e2:	fa ea 00 10 	ld.d	r10,sp[16]
8000d5e6:	e0 a0 0e 05 	rcall	8000f1f0 <__avr32_f64_cmp_lt>
8000d5ea:	c1 a1       	brne	8000d61e <_dtoa_r+0x71e>
8000d5ec:	fa e8 00 10 	ld.d	r8,sp[16]
8000d5f0:	00 9a       	mov	r10,r0
8000d5f2:	02 9b       	mov	r11,r1
8000d5f4:	e0 a0 0d b7 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000d5f8:	e0 80 02 5f 	breq	8000dab6 <_dtoa_r+0xbb6>
8000d5fc:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000d600:	c0 f1       	brne	8000d61e <_dtoa_r+0x71e>
8000d602:	e0 8f 02 5a 	bral	8000dab6 <_dtoa_r+0xbb6>
8000d606:	40 8a       	lddsp	r10,sp[0x20]
8000d608:	14 38       	cp.w	r8,r10
8000d60a:	c0 30       	breq	8000d610 <_dtoa_r+0x710>
8000d60c:	10 95       	mov	r5,r8
8000d60e:	c0 98       	rjmp	8000d620 <_dtoa_r+0x720>
8000d610:	33 08       	mov	r8,48
8000d612:	40 89       	lddsp	r9,sp[0x20]
8000d614:	2f f6       	sub	r6,-1
8000d616:	b2 88       	st.b	r9[0x0],r8
8000d618:	40 88       	lddsp	r8,sp[0x20]
8000d61a:	c0 88       	rjmp	8000d62a <_dtoa_r+0x72a>
8000d61c:	40 66       	lddsp	r6,sp[0x18]
8000d61e:	33 99       	mov	r9,57
8000d620:	0a 98       	mov	r8,r5
8000d622:	11 7a       	ld.ub	r10,--r8
8000d624:	f2 0a 18 00 	cp.b	r10,r9
8000d628:	ce f0       	breq	8000d606 <_dtoa_r+0x706>
8000d62a:	50 66       	stdsp	sp[0x18],r6
8000d62c:	11 89       	ld.ub	r9,r8[0x0]
8000d62e:	2f f9       	sub	r9,-1
8000d630:	b0 89       	st.b	r8[0x0],r9
8000d632:	e0 8f 02 43 	bral	8000dab8 <_dtoa_r+0xbb8>
8000d636:	e0 a0 0a cb 	rcall	8000ebcc <__avr32_f64_mul>
8000d63a:	2f f4       	sub	r4,-1
8000d63c:	fa eb 00 08 	st.d	sp[8],r10
8000d640:	30 08       	mov	r8,0
8000d642:	30 09       	mov	r9,0
8000d644:	e0 a0 0d 8f 	rcall	8000f162 <__avr32_f64_cmp_eq>
8000d648:	ca 60       	breq	8000d594 <_dtoa_r+0x694>
8000d64a:	e0 8f 02 36 	bral	8000dab6 <_dtoa_r+0xbb6>
8000d64e:	40 d8       	lddsp	r8,sp[0x34]
8000d650:	58 08       	cp.w	r8,0
8000d652:	c0 51       	brne	8000d65c <_dtoa_r+0x75c>
8000d654:	04 98       	mov	r8,r2
8000d656:	00 95       	mov	r5,r0
8000d658:	40 d4       	lddsp	r4,sp[0x34]
8000d65a:	c3 88       	rjmp	8000d6ca <_dtoa_r+0x7ca>
8000d65c:	40 c5       	lddsp	r5,sp[0x30]
8000d65e:	58 15       	cp.w	r5,1
8000d660:	e0 89 00 10 	brgt	8000d680 <_dtoa_r+0x780>
8000d664:	41 74       	lddsp	r4,sp[0x5c]
8000d666:	58 04       	cp.w	r4,0
8000d668:	c0 40       	breq	8000d670 <_dtoa_r+0x770>
8000d66a:	f4 c9 fb cd 	sub	r9,r10,-1075
8000d66e:	c0 48       	rjmp	8000d676 <_dtoa_r+0x776>
8000d670:	41 99       	lddsp	r9,sp[0x64]
8000d672:	f2 09 11 36 	rsub	r9,r9,54
8000d676:	04 98       	mov	r8,r2
8000d678:	00 95       	mov	r5,r0
8000d67a:	c1 d8       	rjmp	8000d6b4 <_dtoa_r+0x7b4>
8000d67c:	80 01       	ld.sh	r1,r0[0x0]
8000d67e:	91 80       	st.w	r8[0x20],r0
8000d680:	e2 c8 00 01 	sub	r8,r1,1
8000d684:	58 01       	cp.w	r1,0
8000d686:	e0 05 17 40 	movge	r5,r0
8000d68a:	e2 09 17 40 	movge	r9,r1
8000d68e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000d692:	f9 b9 05 00 	movlt	r9,0
8000d696:	10 32       	cp.w	r2,r8
8000d698:	e5 d8 e4 18 	subge	r8,r2,r8
8000d69c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000d6a0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000d6a4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000d6a8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000d6ac:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000d6b0:	f9 b8 05 00 	movlt	r8,0
8000d6b4:	40 4b       	lddsp	r11,sp[0x10]
8000d6b6:	12 0b       	add	r11,r9
8000d6b8:	50 08       	stdsp	sp[0x0],r8
8000d6ba:	50 4b       	stdsp	sp[0x10],r11
8000d6bc:	12 00       	add	r0,r9
8000d6be:	30 1b       	mov	r11,1
8000d6c0:	0e 9c       	mov	r12,r7
8000d6c2:	e0 a0 08 ab 	rcall	8000e818 <__i2b>
8000d6c6:	40 08       	lddsp	r8,sp[0x0]
8000d6c8:	18 94       	mov	r4,r12
8000d6ca:	40 4a       	lddsp	r10,sp[0x10]
8000d6cc:	58 05       	cp.w	r5,0
8000d6ce:	5f 99       	srgt	r9
8000d6d0:	58 0a       	cp.w	r10,0
8000d6d2:	5f 9a       	srgt	r10
8000d6d4:	f5 e9 00 09 	and	r9,r10,r9
8000d6d8:	c0 80       	breq	8000d6e8 <_dtoa_r+0x7e8>
8000d6da:	40 4c       	lddsp	r12,sp[0x10]
8000d6dc:	f8 05 0d 49 	min	r9,r12,r5
8000d6e0:	12 1c       	sub	r12,r9
8000d6e2:	12 10       	sub	r0,r9
8000d6e4:	50 4c       	stdsp	sp[0x10],r12
8000d6e6:	12 15       	sub	r5,r9
8000d6e8:	58 02       	cp.w	r2,0
8000d6ea:	e0 8a 00 27 	brle	8000d738 <_dtoa_r+0x838>
8000d6ee:	40 db       	lddsp	r11,sp[0x34]
8000d6f0:	58 0b       	cp.w	r11,0
8000d6f2:	c1 d0       	breq	8000d72c <_dtoa_r+0x82c>
8000d6f4:	58 08       	cp.w	r8,0
8000d6f6:	e0 8a 00 17 	brle	8000d724 <_dtoa_r+0x824>
8000d6fa:	10 9a       	mov	r10,r8
8000d6fc:	50 08       	stdsp	sp[0x0],r8
8000d6fe:	08 9b       	mov	r11,r4
8000d700:	0e 9c       	mov	r12,r7
8000d702:	e0 a0 08 d1 	rcall	8000e8a4 <__pow5mult>
8000d706:	06 9a       	mov	r10,r3
8000d708:	18 9b       	mov	r11,r12
8000d70a:	18 94       	mov	r4,r12
8000d70c:	0e 9c       	mov	r12,r7
8000d70e:	e0 a0 08 05 	rcall	8000e718 <__multiply>
8000d712:	18 99       	mov	r9,r12
8000d714:	06 9b       	mov	r11,r3
8000d716:	50 19       	stdsp	sp[0x4],r9
8000d718:	0e 9c       	mov	r12,r7
8000d71a:	e0 a0 06 b1 	rcall	8000e47c <_Bfree>
8000d71e:	40 19       	lddsp	r9,sp[0x4]
8000d720:	40 08       	lddsp	r8,sp[0x0]
8000d722:	12 93       	mov	r3,r9
8000d724:	e4 08 01 0a 	sub	r10,r2,r8
8000d728:	c0 80       	breq	8000d738 <_dtoa_r+0x838>
8000d72a:	c0 28       	rjmp	8000d72e <_dtoa_r+0x82e>
8000d72c:	04 9a       	mov	r10,r2
8000d72e:	06 9b       	mov	r11,r3
8000d730:	0e 9c       	mov	r12,r7
8000d732:	e0 a0 08 b9 	rcall	8000e8a4 <__pow5mult>
8000d736:	18 93       	mov	r3,r12
8000d738:	30 1b       	mov	r11,1
8000d73a:	0e 9c       	mov	r12,r7
8000d73c:	e0 a0 08 6e 	rcall	8000e818 <__i2b>
8000d740:	41 1a       	lddsp	r10,sp[0x44]
8000d742:	18 92       	mov	r2,r12
8000d744:	58 0a       	cp.w	r10,0
8000d746:	e0 8a 00 07 	brle	8000d754 <_dtoa_r+0x854>
8000d74a:	18 9b       	mov	r11,r12
8000d74c:	0e 9c       	mov	r12,r7
8000d74e:	e0 a0 08 ab 	rcall	8000e8a4 <__pow5mult>
8000d752:	18 92       	mov	r2,r12
8000d754:	40 c9       	lddsp	r9,sp[0x30]
8000d756:	58 19       	cp.w	r9,1
8000d758:	e0 89 00 14 	brgt	8000d780 <_dtoa_r+0x880>
8000d75c:	40 38       	lddsp	r8,sp[0xc]
8000d75e:	58 08       	cp.w	r8,0
8000d760:	c1 01       	brne	8000d780 <_dtoa_r+0x880>
8000d762:	40 29       	lddsp	r9,sp[0x8]
8000d764:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000d768:	c0 c1       	brne	8000d780 <_dtoa_r+0x880>
8000d76a:	12 98       	mov	r8,r9
8000d76c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d770:	c0 80       	breq	8000d780 <_dtoa_r+0x880>
8000d772:	40 4c       	lddsp	r12,sp[0x10]
8000d774:	30 1b       	mov	r11,1
8000d776:	2f fc       	sub	r12,-1
8000d778:	2f f0       	sub	r0,-1
8000d77a:	50 4c       	stdsp	sp[0x10],r12
8000d77c:	50 6b       	stdsp	sp[0x18],r11
8000d77e:	c0 38       	rjmp	8000d784 <_dtoa_r+0x884>
8000d780:	30 0a       	mov	r10,0
8000d782:	50 6a       	stdsp	sp[0x18],r10
8000d784:	41 19       	lddsp	r9,sp[0x44]
8000d786:	58 09       	cp.w	r9,0
8000d788:	c0 31       	brne	8000d78e <_dtoa_r+0x88e>
8000d78a:	30 1c       	mov	r12,1
8000d78c:	c0 98       	rjmp	8000d79e <_dtoa_r+0x89e>
8000d78e:	64 48       	ld.w	r8,r2[0x10]
8000d790:	2f c8       	sub	r8,-4
8000d792:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000d796:	e0 a0 05 e3 	rcall	8000e35c <__hi0bits>
8000d79a:	f8 0c 11 20 	rsub	r12,r12,32
8000d79e:	40 4b       	lddsp	r11,sp[0x10]
8000d7a0:	f8 0b 00 08 	add	r8,r12,r11
8000d7a4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000d7a8:	c0 c0       	breq	8000d7c0 <_dtoa_r+0x8c0>
8000d7aa:	f0 08 11 20 	rsub	r8,r8,32
8000d7ae:	58 48       	cp.w	r8,4
8000d7b0:	e0 8a 00 06 	brle	8000d7bc <_dtoa_r+0x8bc>
8000d7b4:	20 48       	sub	r8,4
8000d7b6:	10 0b       	add	r11,r8
8000d7b8:	50 4b       	stdsp	sp[0x10],r11
8000d7ba:	c0 78       	rjmp	8000d7c8 <_dtoa_r+0x8c8>
8000d7bc:	58 48       	cp.w	r8,4
8000d7be:	c0 70       	breq	8000d7cc <_dtoa_r+0x8cc>
8000d7c0:	40 4a       	lddsp	r10,sp[0x10]
8000d7c2:	2e 48       	sub	r8,-28
8000d7c4:	10 0a       	add	r10,r8
8000d7c6:	50 4a       	stdsp	sp[0x10],r10
8000d7c8:	10 00       	add	r0,r8
8000d7ca:	10 05       	add	r5,r8
8000d7cc:	58 00       	cp.w	r0,0
8000d7ce:	e0 8a 00 08 	brle	8000d7de <_dtoa_r+0x8de>
8000d7d2:	06 9b       	mov	r11,r3
8000d7d4:	00 9a       	mov	r10,r0
8000d7d6:	0e 9c       	mov	r12,r7
8000d7d8:	e0 a0 07 5c 	rcall	8000e690 <__lshift>
8000d7dc:	18 93       	mov	r3,r12
8000d7de:	40 49       	lddsp	r9,sp[0x10]
8000d7e0:	58 09       	cp.w	r9,0
8000d7e2:	e0 8a 00 08 	brle	8000d7f2 <_dtoa_r+0x8f2>
8000d7e6:	04 9b       	mov	r11,r2
8000d7e8:	12 9a       	mov	r10,r9
8000d7ea:	0e 9c       	mov	r12,r7
8000d7ec:	e0 a0 07 52 	rcall	8000e690 <__lshift>
8000d7f0:	18 92       	mov	r2,r12
8000d7f2:	41 48       	lddsp	r8,sp[0x50]
8000d7f4:	58 08       	cp.w	r8,0
8000d7f6:	c1 b0       	breq	8000d82c <_dtoa_r+0x92c>
8000d7f8:	04 9b       	mov	r11,r2
8000d7fa:	06 9c       	mov	r12,r3
8000d7fc:	e0 a0 06 27 	rcall	8000e44a <__mcmp>
8000d800:	c1 64       	brge	8000d82c <_dtoa_r+0x92c>
8000d802:	06 9b       	mov	r11,r3
8000d804:	30 09       	mov	r9,0
8000d806:	30 aa       	mov	r10,10
8000d808:	0e 9c       	mov	r12,r7
8000d80a:	e0 a0 08 0f 	rcall	8000e828 <__multadd>
8000d80e:	20 16       	sub	r6,1
8000d810:	18 93       	mov	r3,r12
8000d812:	40 dc       	lddsp	r12,sp[0x34]
8000d814:	58 0c       	cp.w	r12,0
8000d816:	c0 31       	brne	8000d81c <_dtoa_r+0x91c>
8000d818:	40 91       	lddsp	r1,sp[0x24]
8000d81a:	c0 98       	rjmp	8000d82c <_dtoa_r+0x92c>
8000d81c:	08 9b       	mov	r11,r4
8000d81e:	40 91       	lddsp	r1,sp[0x24]
8000d820:	30 09       	mov	r9,0
8000d822:	30 aa       	mov	r10,10
8000d824:	0e 9c       	mov	r12,r7
8000d826:	e0 a0 08 01 	rcall	8000e828 <__multadd>
8000d82a:	18 94       	mov	r4,r12
8000d82c:	58 01       	cp.w	r1,0
8000d82e:	5f a9       	srle	r9
8000d830:	40 cb       	lddsp	r11,sp[0x30]
8000d832:	58 2b       	cp.w	r11,2
8000d834:	5f 98       	srgt	r8
8000d836:	f3 e8 00 08 	and	r8,r9,r8
8000d83a:	c2 50       	breq	8000d884 <_dtoa_r+0x984>
8000d83c:	58 01       	cp.w	r1,0
8000d83e:	c1 11       	brne	8000d860 <_dtoa_r+0x960>
8000d840:	04 9b       	mov	r11,r2
8000d842:	02 99       	mov	r9,r1
8000d844:	30 5a       	mov	r10,5
8000d846:	0e 9c       	mov	r12,r7
8000d848:	e0 a0 07 f0 	rcall	8000e828 <__multadd>
8000d84c:	18 92       	mov	r2,r12
8000d84e:	18 9b       	mov	r11,r12
8000d850:	06 9c       	mov	r12,r3
8000d852:	e0 a0 05 fc 	rcall	8000e44a <__mcmp>
8000d856:	e0 89 00 0f 	brgt	8000d874 <_dtoa_r+0x974>
8000d85a:	c0 38       	rjmp	8000d860 <_dtoa_r+0x960>
8000d85c:	30 02       	mov	r2,0
8000d85e:	04 94       	mov	r4,r2
8000d860:	40 ea       	lddsp	r10,sp[0x38]
8000d862:	30 09       	mov	r9,0
8000d864:	5c da       	com	r10
8000d866:	40 85       	lddsp	r5,sp[0x20]
8000d868:	50 6a       	stdsp	sp[0x18],r10
8000d86a:	50 49       	stdsp	sp[0x10],r9
8000d86c:	c0 f9       	rjmp	8000da8a <_dtoa_r+0xb8a>
8000d86e:	08 92       	mov	r2,r4
8000d870:	40 66       	lddsp	r6,sp[0x18]
8000d872:	04 94       	mov	r4,r2
8000d874:	2f f6       	sub	r6,-1
8000d876:	50 66       	stdsp	sp[0x18],r6
8000d878:	33 18       	mov	r8,49
8000d87a:	40 85       	lddsp	r5,sp[0x20]
8000d87c:	0a c8       	st.b	r5++,r8
8000d87e:	30 08       	mov	r8,0
8000d880:	50 48       	stdsp	sp[0x10],r8
8000d882:	c0 49       	rjmp	8000da8a <_dtoa_r+0xb8a>
8000d884:	40 dc       	lddsp	r12,sp[0x34]
8000d886:	58 0c       	cp.w	r12,0
8000d888:	e0 80 00 b5 	breq	8000d9f2 <_dtoa_r+0xaf2>
8000d88c:	58 05       	cp.w	r5,0
8000d88e:	e0 8a 00 08 	brle	8000d89e <_dtoa_r+0x99e>
8000d892:	08 9b       	mov	r11,r4
8000d894:	0a 9a       	mov	r10,r5
8000d896:	0e 9c       	mov	r12,r7
8000d898:	e0 a0 06 fc 	rcall	8000e690 <__lshift>
8000d89c:	18 94       	mov	r4,r12
8000d89e:	40 6b       	lddsp	r11,sp[0x18]
8000d8a0:	58 0b       	cp.w	r11,0
8000d8a2:	c0 31       	brne	8000d8a8 <_dtoa_r+0x9a8>
8000d8a4:	08 9c       	mov	r12,r4
8000d8a6:	c1 38       	rjmp	8000d8cc <_dtoa_r+0x9cc>
8000d8a8:	68 1b       	ld.w	r11,r4[0x4]
8000d8aa:	0e 9c       	mov	r12,r7
8000d8ac:	e0 a0 06 02 	rcall	8000e4b0 <_Balloc>
8000d8b0:	68 4a       	ld.w	r10,r4[0x10]
8000d8b2:	18 95       	mov	r5,r12
8000d8b4:	e8 cb ff f4 	sub	r11,r4,-12
8000d8b8:	2f ea       	sub	r10,-2
8000d8ba:	2f 4c       	sub	r12,-12
8000d8bc:	a3 6a       	lsl	r10,0x2
8000d8be:	fe b0 e5 ae 	rcall	8000a41a <memcpy>
8000d8c2:	0a 9b       	mov	r11,r5
8000d8c4:	30 1a       	mov	r10,1
8000d8c6:	0e 9c       	mov	r12,r7
8000d8c8:	e0 a0 06 e4 	rcall	8000e690 <__lshift>
8000d8cc:	50 44       	stdsp	sp[0x10],r4
8000d8ce:	40 3a       	lddsp	r10,sp[0xc]
8000d8d0:	30 19       	mov	r9,1
8000d8d2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d8d6:	18 94       	mov	r4,r12
8000d8d8:	50 da       	stdsp	sp[0x34],r10
8000d8da:	40 85       	lddsp	r5,sp[0x20]
8000d8dc:	50 99       	stdsp	sp[0x24],r9
8000d8de:	50 26       	stdsp	sp[0x8],r6
8000d8e0:	50 e1       	stdsp	sp[0x38],r1
8000d8e2:	04 9b       	mov	r11,r2
8000d8e4:	06 9c       	mov	r12,r3
8000d8e6:	fe b0 fa 7d 	rcall	8000cde0 <quorem>
8000d8ea:	40 4b       	lddsp	r11,sp[0x10]
8000d8ec:	f8 c0 ff d0 	sub	r0,r12,-48
8000d8f0:	06 9c       	mov	r12,r3
8000d8f2:	e0 a0 05 ac 	rcall	8000e44a <__mcmp>
8000d8f6:	08 9a       	mov	r10,r4
8000d8f8:	50 6c       	stdsp	sp[0x18],r12
8000d8fa:	04 9b       	mov	r11,r2
8000d8fc:	0e 9c       	mov	r12,r7
8000d8fe:	e0 a0 06 61 	rcall	8000e5c0 <__mdiff>
8000d902:	18 91       	mov	r1,r12
8000d904:	78 38       	ld.w	r8,r12[0xc]
8000d906:	58 08       	cp.w	r8,0
8000d908:	c0 30       	breq	8000d90e <_dtoa_r+0xa0e>
8000d90a:	30 16       	mov	r6,1
8000d90c:	c0 68       	rjmp	8000d918 <_dtoa_r+0xa18>
8000d90e:	18 9b       	mov	r11,r12
8000d910:	06 9c       	mov	r12,r3
8000d912:	e0 a0 05 9c 	rcall	8000e44a <__mcmp>
8000d916:	18 96       	mov	r6,r12
8000d918:	0e 9c       	mov	r12,r7
8000d91a:	02 9b       	mov	r11,r1
8000d91c:	e0 a0 05 b0 	rcall	8000e47c <_Bfree>
8000d920:	40 cc       	lddsp	r12,sp[0x30]
8000d922:	ed ec 10 08 	or	r8,r6,r12
8000d926:	c0 d1       	brne	8000d940 <_dtoa_r+0xa40>
8000d928:	40 db       	lddsp	r11,sp[0x34]
8000d92a:	58 0b       	cp.w	r11,0
8000d92c:	c0 a1       	brne	8000d940 <_dtoa_r+0xa40>
8000d92e:	40 26       	lddsp	r6,sp[0x8]
8000d930:	e0 40 00 39 	cp.w	r0,57
8000d934:	c3 00       	breq	8000d994 <_dtoa_r+0xa94>
8000d936:	40 6a       	lddsp	r10,sp[0x18]
8000d938:	58 0a       	cp.w	r10,0
8000d93a:	e0 89 00 24 	brgt	8000d982 <_dtoa_r+0xa82>
8000d93e:	c2 f8       	rjmp	8000d99c <_dtoa_r+0xa9c>
8000d940:	40 69       	lddsp	r9,sp[0x18]
8000d942:	58 09       	cp.w	r9,0
8000d944:	c0 85       	brlt	8000d954 <_dtoa_r+0xa54>
8000d946:	12 98       	mov	r8,r9
8000d948:	40 cc       	lddsp	r12,sp[0x30]
8000d94a:	18 48       	or	r8,r12
8000d94c:	c1 d1       	brne	8000d986 <_dtoa_r+0xa86>
8000d94e:	40 db       	lddsp	r11,sp[0x34]
8000d950:	58 0b       	cp.w	r11,0
8000d952:	c1 a1       	brne	8000d986 <_dtoa_r+0xa86>
8000d954:	0c 99       	mov	r9,r6
8000d956:	40 26       	lddsp	r6,sp[0x8]
8000d958:	58 09       	cp.w	r9,0
8000d95a:	e0 8a 00 21 	brle	8000d99c <_dtoa_r+0xa9c>
8000d95e:	06 9b       	mov	r11,r3
8000d960:	30 1a       	mov	r10,1
8000d962:	0e 9c       	mov	r12,r7
8000d964:	e0 a0 06 96 	rcall	8000e690 <__lshift>
8000d968:	04 9b       	mov	r11,r2
8000d96a:	18 93       	mov	r3,r12
8000d96c:	e0 a0 05 6f 	rcall	8000e44a <__mcmp>
8000d970:	e0 89 00 06 	brgt	8000d97c <_dtoa_r+0xa7c>
8000d974:	c1 41       	brne	8000d99c <_dtoa_r+0xa9c>
8000d976:	ed b0 00 00 	bld	r0,0x0
8000d97a:	c1 11       	brne	8000d99c <_dtoa_r+0xa9c>
8000d97c:	e0 40 00 39 	cp.w	r0,57
8000d980:	c0 a0       	breq	8000d994 <_dtoa_r+0xa94>
8000d982:	2f f0       	sub	r0,-1
8000d984:	c0 c8       	rjmp	8000d99c <_dtoa_r+0xa9c>
8000d986:	58 06       	cp.w	r6,0
8000d988:	e0 8a 00 0c 	brle	8000d9a0 <_dtoa_r+0xaa0>
8000d98c:	40 26       	lddsp	r6,sp[0x8]
8000d98e:	e0 40 00 39 	cp.w	r0,57
8000d992:	c0 41       	brne	8000d99a <_dtoa_r+0xa9a>
8000d994:	33 98       	mov	r8,57
8000d996:	0a c8       	st.b	r5++,r8
8000d998:	c6 78       	rjmp	8000da66 <_dtoa_r+0xb66>
8000d99a:	2f f0       	sub	r0,-1
8000d99c:	0a c0       	st.b	r5++,r0
8000d99e:	c7 58       	rjmp	8000da88 <_dtoa_r+0xb88>
8000d9a0:	0a c0       	st.b	r5++,r0
8000d9a2:	40 9a       	lddsp	r10,sp[0x24]
8000d9a4:	40 e9       	lddsp	r9,sp[0x38]
8000d9a6:	12 3a       	cp.w	r10,r9
8000d9a8:	c4 30       	breq	8000da2e <_dtoa_r+0xb2e>
8000d9aa:	06 9b       	mov	r11,r3
8000d9ac:	30 09       	mov	r9,0
8000d9ae:	30 aa       	mov	r10,10
8000d9b0:	0e 9c       	mov	r12,r7
8000d9b2:	e0 a0 07 3b 	rcall	8000e828 <__multadd>
8000d9b6:	40 48       	lddsp	r8,sp[0x10]
8000d9b8:	18 93       	mov	r3,r12
8000d9ba:	08 38       	cp.w	r8,r4
8000d9bc:	c0 91       	brne	8000d9ce <_dtoa_r+0xace>
8000d9be:	10 9b       	mov	r11,r8
8000d9c0:	30 09       	mov	r9,0
8000d9c2:	30 aa       	mov	r10,10
8000d9c4:	0e 9c       	mov	r12,r7
8000d9c6:	e0 a0 07 31 	rcall	8000e828 <__multadd>
8000d9ca:	50 4c       	stdsp	sp[0x10],r12
8000d9cc:	c0 e8       	rjmp	8000d9e8 <_dtoa_r+0xae8>
8000d9ce:	40 4b       	lddsp	r11,sp[0x10]
8000d9d0:	30 09       	mov	r9,0
8000d9d2:	30 aa       	mov	r10,10
8000d9d4:	0e 9c       	mov	r12,r7
8000d9d6:	e0 a0 07 29 	rcall	8000e828 <__multadd>
8000d9da:	08 9b       	mov	r11,r4
8000d9dc:	50 4c       	stdsp	sp[0x10],r12
8000d9de:	30 09       	mov	r9,0
8000d9e0:	30 aa       	mov	r10,10
8000d9e2:	0e 9c       	mov	r12,r7
8000d9e4:	e0 a0 07 22 	rcall	8000e828 <__multadd>
8000d9e8:	18 94       	mov	r4,r12
8000d9ea:	40 9c       	lddsp	r12,sp[0x24]
8000d9ec:	2f fc       	sub	r12,-1
8000d9ee:	50 9c       	stdsp	sp[0x24],r12
8000d9f0:	c7 9b       	rjmp	8000d8e2 <_dtoa_r+0x9e2>
8000d9f2:	30 18       	mov	r8,1
8000d9f4:	06 90       	mov	r0,r3
8000d9f6:	40 85       	lddsp	r5,sp[0x20]
8000d9f8:	08 93       	mov	r3,r4
8000d9fa:	0c 94       	mov	r4,r6
8000d9fc:	10 96       	mov	r6,r8
8000d9fe:	04 9b       	mov	r11,r2
8000da00:	00 9c       	mov	r12,r0
8000da02:	fe b0 f9 ef 	rcall	8000cde0 <quorem>
8000da06:	2d 0c       	sub	r12,-48
8000da08:	0a cc       	st.b	r5++,r12
8000da0a:	02 36       	cp.w	r6,r1
8000da0c:	c0 a4       	brge	8000da20 <_dtoa_r+0xb20>
8000da0e:	00 9b       	mov	r11,r0
8000da10:	30 09       	mov	r9,0
8000da12:	30 aa       	mov	r10,10
8000da14:	0e 9c       	mov	r12,r7
8000da16:	2f f6       	sub	r6,-1
8000da18:	e0 a0 07 08 	rcall	8000e828 <__multadd>
8000da1c:	18 90       	mov	r0,r12
8000da1e:	cf 0b       	rjmp	8000d9fe <_dtoa_r+0xafe>
8000da20:	08 96       	mov	r6,r4
8000da22:	30 0b       	mov	r11,0
8000da24:	06 94       	mov	r4,r3
8000da26:	50 4b       	stdsp	sp[0x10],r11
8000da28:	00 93       	mov	r3,r0
8000da2a:	18 90       	mov	r0,r12
8000da2c:	c0 28       	rjmp	8000da30 <_dtoa_r+0xb30>
8000da2e:	40 26       	lddsp	r6,sp[0x8]
8000da30:	06 9b       	mov	r11,r3
8000da32:	30 1a       	mov	r10,1
8000da34:	0e 9c       	mov	r12,r7
8000da36:	e0 a0 06 2d 	rcall	8000e690 <__lshift>
8000da3a:	04 9b       	mov	r11,r2
8000da3c:	18 93       	mov	r3,r12
8000da3e:	e0 a0 05 06 	rcall	8000e44a <__mcmp>
8000da42:	e0 89 00 12 	brgt	8000da66 <_dtoa_r+0xb66>
8000da46:	c1 b1       	brne	8000da7c <_dtoa_r+0xb7c>
8000da48:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000da4c:	c0 d1       	brne	8000da66 <_dtoa_r+0xb66>
8000da4e:	c1 78       	rjmp	8000da7c <_dtoa_r+0xb7c>
8000da50:	40 89       	lddsp	r9,sp[0x20]
8000da52:	12 38       	cp.w	r8,r9
8000da54:	c0 30       	breq	8000da5a <_dtoa_r+0xb5a>
8000da56:	10 95       	mov	r5,r8
8000da58:	c0 88       	rjmp	8000da68 <_dtoa_r+0xb68>
8000da5a:	2f f6       	sub	r6,-1
8000da5c:	50 66       	stdsp	sp[0x18],r6
8000da5e:	33 18       	mov	r8,49
8000da60:	40 8c       	lddsp	r12,sp[0x20]
8000da62:	b8 88       	st.b	r12[0x0],r8
8000da64:	c1 38       	rjmp	8000da8a <_dtoa_r+0xb8a>
8000da66:	33 9a       	mov	r10,57
8000da68:	0a 98       	mov	r8,r5
8000da6a:	11 79       	ld.ub	r9,--r8
8000da6c:	f4 09 18 00 	cp.b	r9,r10
8000da70:	cf 00       	breq	8000da50 <_dtoa_r+0xb50>
8000da72:	2f f9       	sub	r9,-1
8000da74:	b0 89       	st.b	r8[0x0],r9
8000da76:	c0 98       	rjmp	8000da88 <_dtoa_r+0xb88>
8000da78:	10 95       	mov	r5,r8
8000da7a:	c0 28       	rjmp	8000da7e <_dtoa_r+0xb7e>
8000da7c:	33 09       	mov	r9,48
8000da7e:	0a 98       	mov	r8,r5
8000da80:	11 7a       	ld.ub	r10,--r8
8000da82:	f2 0a 18 00 	cp.b	r10,r9
8000da86:	cf 90       	breq	8000da78 <_dtoa_r+0xb78>
8000da88:	50 66       	stdsp	sp[0x18],r6
8000da8a:	04 9b       	mov	r11,r2
8000da8c:	0e 9c       	mov	r12,r7
8000da8e:	e0 a0 04 f7 	rcall	8000e47c <_Bfree>
8000da92:	58 04       	cp.w	r4,0
8000da94:	c1 20       	breq	8000dab8 <_dtoa_r+0xbb8>
8000da96:	40 4b       	lddsp	r11,sp[0x10]
8000da98:	08 3b       	cp.w	r11,r4
8000da9a:	5f 19       	srne	r9
8000da9c:	58 0b       	cp.w	r11,0
8000da9e:	5f 18       	srne	r8
8000daa0:	f3 e8 00 08 	and	r8,r9,r8
8000daa4:	c0 40       	breq	8000daac <_dtoa_r+0xbac>
8000daa6:	0e 9c       	mov	r12,r7
8000daa8:	e0 a0 04 ea 	rcall	8000e47c <_Bfree>
8000daac:	08 9b       	mov	r11,r4
8000daae:	0e 9c       	mov	r12,r7
8000dab0:	e0 a0 04 e6 	rcall	8000e47c <_Bfree>
8000dab4:	c0 28       	rjmp	8000dab8 <_dtoa_r+0xbb8>
8000dab6:	50 66       	stdsp	sp[0x18],r6
8000dab8:	0e 9c       	mov	r12,r7
8000daba:	06 9b       	mov	r11,r3
8000dabc:	e0 a0 04 e0 	rcall	8000e47c <_Bfree>
8000dac0:	30 08       	mov	r8,0
8000dac2:	aa 88       	st.b	r5[0x0],r8
8000dac4:	40 68       	lddsp	r8,sp[0x18]
8000dac6:	41 5a       	lddsp	r10,sp[0x54]
8000dac8:	2f f8       	sub	r8,-1
8000daca:	41 29       	lddsp	r9,sp[0x48]
8000dacc:	95 08       	st.w	r10[0x0],r8
8000dace:	40 8c       	lddsp	r12,sp[0x20]
8000dad0:	58 09       	cp.w	r9,0
8000dad2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000dad6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000dada:	2e 6d       	sub	sp,-104
8000dadc:	d8 32       	popm	r0-r7,pc
8000dade:	d7 03       	nop

8000dae0 <__errno>:
8000dae0:	e0 68 0a 38 	mov	r8,2616
8000dae4:	70 0c       	ld.w	r12,r8[0x0]
8000dae6:	2f 4c       	sub	r12,-12
8000dae8:	5e fc       	retal	r12
8000daea:	d7 03       	nop

8000daec <_fflush_r>:
8000daec:	d4 21       	pushm	r4-r7,lr
8000daee:	16 97       	mov	r7,r11
8000daf0:	18 96       	mov	r6,r12
8000daf2:	76 48       	ld.w	r8,r11[0x10]
8000daf4:	58 08       	cp.w	r8,0
8000daf6:	c7 c0       	breq	8000dbee <_fflush_r+0x102>
8000daf8:	58 0c       	cp.w	r12,0
8000dafa:	c0 50       	breq	8000db04 <_fflush_r+0x18>
8000dafc:	78 68       	ld.w	r8,r12[0x18]
8000dafe:	58 08       	cp.w	r8,0
8000db00:	c0 21       	brne	8000db04 <_fflush_r+0x18>
8000db02:	cd 1c       	rcall	8000dca4 <__sinit>
8000db04:	4b b8       	lddpc	r8,8000dbf0 <_fflush_r+0x104>
8000db06:	10 37       	cp.w	r7,r8
8000db08:	c0 31       	brne	8000db0e <_fflush_r+0x22>
8000db0a:	6c 07       	ld.w	r7,r6[0x0]
8000db0c:	c0 a8       	rjmp	8000db20 <_fflush_r+0x34>
8000db0e:	4b a8       	lddpc	r8,8000dbf4 <_fflush_r+0x108>
8000db10:	10 37       	cp.w	r7,r8
8000db12:	c0 31       	brne	8000db18 <_fflush_r+0x2c>
8000db14:	6c 17       	ld.w	r7,r6[0x4]
8000db16:	c0 58       	rjmp	8000db20 <_fflush_r+0x34>
8000db18:	4b 88       	lddpc	r8,8000dbf8 <_fflush_r+0x10c>
8000db1a:	10 37       	cp.w	r7,r8
8000db1c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000db20:	8e 6a       	ld.sh	r10,r7[0xc]
8000db22:	14 98       	mov	r8,r10
8000db24:	ed ba 00 03 	bld	r10,0x3
8000db28:	c4 20       	breq	8000dbac <_fflush_r+0xc0>
8000db2a:	ab ba       	sbr	r10,0xb
8000db2c:	ae 6a       	st.h	r7[0xc],r10
8000db2e:	6e 18       	ld.w	r8,r7[0x4]
8000db30:	58 08       	cp.w	r8,0
8000db32:	e0 89 00 06 	brgt	8000db3e <_fflush_r+0x52>
8000db36:	6f 08       	ld.w	r8,r7[0x40]
8000db38:	58 08       	cp.w	r8,0
8000db3a:	e0 8a 00 5a 	brle	8000dbee <_fflush_r+0x102>
8000db3e:	6e b8       	ld.w	r8,r7[0x2c]
8000db40:	58 08       	cp.w	r8,0
8000db42:	c5 60       	breq	8000dbee <_fflush_r+0x102>
8000db44:	e2 1a 10 00 	andl	r10,0x1000,COH
8000db48:	c0 30       	breq	8000db4e <_fflush_r+0x62>
8000db4a:	6f 55       	ld.w	r5,r7[0x54]
8000db4c:	c0 f8       	rjmp	8000db6a <_fflush_r+0x7e>
8000db4e:	30 19       	mov	r9,1
8000db50:	6e 8b       	ld.w	r11,r7[0x20]
8000db52:	0c 9c       	mov	r12,r6
8000db54:	5d 18       	icall	r8
8000db56:	18 95       	mov	r5,r12
8000db58:	5b fc       	cp.w	r12,-1
8000db5a:	c0 81       	brne	8000db6a <_fflush_r+0x7e>
8000db5c:	6c 38       	ld.w	r8,r6[0xc]
8000db5e:	59 d8       	cp.w	r8,29
8000db60:	c4 70       	breq	8000dbee <_fflush_r+0x102>
8000db62:	8e 68       	ld.sh	r8,r7[0xc]
8000db64:	a7 a8       	sbr	r8,0x6
8000db66:	ae 68       	st.h	r7[0xc],r8
8000db68:	d8 22       	popm	r4-r7,pc
8000db6a:	8e 68       	ld.sh	r8,r7[0xc]
8000db6c:	ed b8 00 02 	bld	r8,0x2
8000db70:	c0 91       	brne	8000db82 <_fflush_r+0x96>
8000db72:	6e 18       	ld.w	r8,r7[0x4]
8000db74:	10 15       	sub	r5,r8
8000db76:	6e d8       	ld.w	r8,r7[0x34]
8000db78:	58 08       	cp.w	r8,0
8000db7a:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000db7e:	eb d8 e1 15 	subne	r5,r5,r8
8000db82:	6e b8       	ld.w	r8,r7[0x2c]
8000db84:	0c 9c       	mov	r12,r6
8000db86:	30 09       	mov	r9,0
8000db88:	0a 9a       	mov	r10,r5
8000db8a:	6e 8b       	ld.w	r11,r7[0x20]
8000db8c:	5d 18       	icall	r8
8000db8e:	8e 68       	ld.sh	r8,r7[0xc]
8000db90:	0a 3c       	cp.w	r12,r5
8000db92:	c2 61       	brne	8000dbde <_fflush_r+0xf2>
8000db94:	ab d8       	cbr	r8,0xb
8000db96:	30 0c       	mov	r12,0
8000db98:	6e 49       	ld.w	r9,r7[0x10]
8000db9a:	ae 68       	st.h	r7[0xc],r8
8000db9c:	8f 1c       	st.w	r7[0x4],r12
8000db9e:	8f 09       	st.w	r7[0x0],r9
8000dba0:	ed b8 00 0c 	bld	r8,0xc
8000dba4:	c2 51       	brne	8000dbee <_fflush_r+0x102>
8000dba6:	ef 45 00 54 	st.w	r7[84],r5
8000dbaa:	d8 22       	popm	r4-r7,pc
8000dbac:	6e 45       	ld.w	r5,r7[0x10]
8000dbae:	58 05       	cp.w	r5,0
8000dbb0:	c1 f0       	breq	8000dbee <_fflush_r+0x102>
8000dbb2:	6e 04       	ld.w	r4,r7[0x0]
8000dbb4:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000dbb8:	8f 05       	st.w	r7[0x0],r5
8000dbba:	f9 b8 01 00 	movne	r8,0
8000dbbe:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000dbc2:	0a 14       	sub	r4,r5
8000dbc4:	8f 28       	st.w	r7[0x8],r8
8000dbc6:	c1 18       	rjmp	8000dbe8 <_fflush_r+0xfc>
8000dbc8:	08 99       	mov	r9,r4
8000dbca:	0a 9a       	mov	r10,r5
8000dbcc:	6e a8       	ld.w	r8,r7[0x28]
8000dbce:	6e 8b       	ld.w	r11,r7[0x20]
8000dbd0:	0c 9c       	mov	r12,r6
8000dbd2:	5d 18       	icall	r8
8000dbd4:	18 14       	sub	r4,r12
8000dbd6:	58 0c       	cp.w	r12,0
8000dbd8:	e0 89 00 07 	brgt	8000dbe6 <_fflush_r+0xfa>
8000dbdc:	8e 68       	ld.sh	r8,r7[0xc]
8000dbde:	a7 a8       	sbr	r8,0x6
8000dbe0:	3f fc       	mov	r12,-1
8000dbe2:	ae 68       	st.h	r7[0xc],r8
8000dbe4:	d8 22       	popm	r4-r7,pc
8000dbe6:	18 05       	add	r5,r12
8000dbe8:	58 04       	cp.w	r4,0
8000dbea:	fe 99 ff ef 	brgt	8000dbc8 <_fflush_r+0xdc>
8000dbee:	d8 2a       	popm	r4-r7,pc,r12=0
8000dbf0:	80 01       	ld.sh	r1,r0[0x0]
8000dbf2:	90 d0       	ld.uh	r0,r8[0xa]
8000dbf4:	80 01       	ld.sh	r1,r0[0x0]
8000dbf6:	90 f0       	ld.uh	r0,r8[0xe]
8000dbf8:	80 01       	ld.sh	r1,r0[0x0]
8000dbfa:	91 10       	st.w	r8[0x4],r0

8000dbfc <__sfp_lock_acquire>:
8000dbfc:	5e fc       	retal	r12

8000dbfe <__sfp_lock_release>:
8000dbfe:	5e fc       	retal	r12

8000dc00 <_cleanup_r>:
8000dc00:	d4 01       	pushm	lr
8000dc02:	fe cb f0 ba 	sub	r11,pc,-3910
8000dc06:	e0 a0 02 f9 	rcall	8000e1f8 <_fwalk>
8000dc0a:	d8 02       	popm	pc

8000dc0c <__sfmoreglue>:
8000dc0c:	d4 21       	pushm	r4-r7,lr
8000dc0e:	16 95       	mov	r5,r11
8000dc10:	f6 06 10 5c 	mul	r6,r11,92
8000dc14:	ec cb ff f4 	sub	r11,r6,-12
8000dc18:	fe b0 e1 d2 	rcall	80009fbc <_malloc_r>
8000dc1c:	18 97       	mov	r7,r12
8000dc1e:	c0 90       	breq	8000dc30 <__sfmoreglue+0x24>
8000dc20:	99 15       	st.w	r12[0x4],r5
8000dc22:	30 0b       	mov	r11,0
8000dc24:	2f 4c       	sub	r12,-12
8000dc26:	0c 9a       	mov	r10,r6
8000dc28:	8f 2c       	st.w	r7[0x8],r12
8000dc2a:	8f 0b       	st.w	r7[0x0],r11
8000dc2c:	fe b0 e4 9b 	rcall	8000a562 <memset>
8000dc30:	0e 9c       	mov	r12,r7
8000dc32:	d8 22       	popm	r4-r7,pc

8000dc34 <__sfp>:
8000dc34:	d4 21       	pushm	r4-r7,lr
8000dc36:	49 b8       	lddpc	r8,8000dca0 <__sfp+0x6c>
8000dc38:	18 96       	mov	r6,r12
8000dc3a:	70 07       	ld.w	r7,r8[0x0]
8000dc3c:	6e 68       	ld.w	r8,r7[0x18]
8000dc3e:	58 08       	cp.w	r8,0
8000dc40:	c0 31       	brne	8000dc46 <__sfp+0x12>
8000dc42:	0e 9c       	mov	r12,r7
8000dc44:	c3 0c       	rcall	8000dca4 <__sinit>
8000dc46:	ee c7 ff 28 	sub	r7,r7,-216
8000dc4a:	30 05       	mov	r5,0
8000dc4c:	6e 2c       	ld.w	r12,r7[0x8]
8000dc4e:	6e 18       	ld.w	r8,r7[0x4]
8000dc50:	c0 68       	rjmp	8000dc5c <__sfp+0x28>
8000dc52:	98 69       	ld.sh	r9,r12[0xc]
8000dc54:	ea 09 19 00 	cp.h	r9,r5
8000dc58:	c1 10       	breq	8000dc7a <__sfp+0x46>
8000dc5a:	2a 4c       	sub	r12,-92
8000dc5c:	20 18       	sub	r8,1
8000dc5e:	cf a7       	brpl	8000dc52 <__sfp+0x1e>
8000dc60:	6e 08       	ld.w	r8,r7[0x0]
8000dc62:	58 08       	cp.w	r8,0
8000dc64:	c0 61       	brne	8000dc70 <__sfp+0x3c>
8000dc66:	30 4b       	mov	r11,4
8000dc68:	0c 9c       	mov	r12,r6
8000dc6a:	cd 1f       	rcall	8000dc0c <__sfmoreglue>
8000dc6c:	8f 0c       	st.w	r7[0x0],r12
8000dc6e:	c0 30       	breq	8000dc74 <__sfp+0x40>
8000dc70:	6e 07       	ld.w	r7,r7[0x0]
8000dc72:	ce db       	rjmp	8000dc4c <__sfp+0x18>
8000dc74:	30 c8       	mov	r8,12
8000dc76:	8d 38       	st.w	r6[0xc],r8
8000dc78:	d8 22       	popm	r4-r7,pc
8000dc7a:	30 08       	mov	r8,0
8000dc7c:	f9 48 00 4c 	st.w	r12[76],r8
8000dc80:	99 08       	st.w	r12[0x0],r8
8000dc82:	99 28       	st.w	r12[0x8],r8
8000dc84:	99 18       	st.w	r12[0x4],r8
8000dc86:	99 48       	st.w	r12[0x10],r8
8000dc88:	99 58       	st.w	r12[0x14],r8
8000dc8a:	99 68       	st.w	r12[0x18],r8
8000dc8c:	99 d8       	st.w	r12[0x34],r8
8000dc8e:	99 e8       	st.w	r12[0x38],r8
8000dc90:	f9 48 00 48 	st.w	r12[72],r8
8000dc94:	3f f8       	mov	r8,-1
8000dc96:	b8 78       	st.h	r12[0xe],r8
8000dc98:	30 18       	mov	r8,1
8000dc9a:	b8 68       	st.h	r12[0xc],r8
8000dc9c:	d8 22       	popm	r4-r7,pc
8000dc9e:	d7 03       	nop
8000dca0:	80 01       	ld.sh	r1,r0[0x0]
8000dca2:	91 34       	st.w	r8[0xc],r4

8000dca4 <__sinit>:
8000dca4:	d4 21       	pushm	r4-r7,lr
8000dca6:	18 96       	mov	r6,r12
8000dca8:	78 67       	ld.w	r7,r12[0x18]
8000dcaa:	58 07       	cp.w	r7,0
8000dcac:	c4 91       	brne	8000dd3e <__sinit+0x9a>
8000dcae:	fe c8 00 ae 	sub	r8,pc,174
8000dcb2:	30 15       	mov	r5,1
8000dcb4:	99 a8       	st.w	r12[0x28],r8
8000dcb6:	f9 47 00 d8 	st.w	r12[216],r7
8000dcba:	f9 47 00 dc 	st.w	r12[220],r7
8000dcbe:	f9 47 00 e0 	st.w	r12[224],r7
8000dcc2:	99 65       	st.w	r12[0x18],r5
8000dcc4:	cb 8f       	rcall	8000dc34 <__sfp>
8000dcc6:	8d 0c       	st.w	r6[0x0],r12
8000dcc8:	0c 9c       	mov	r12,r6
8000dcca:	cb 5f       	rcall	8000dc34 <__sfp>
8000dccc:	8d 1c       	st.w	r6[0x4],r12
8000dcce:	0c 9c       	mov	r12,r6
8000dcd0:	cb 2f       	rcall	8000dc34 <__sfp>
8000dcd2:	6c 09       	ld.w	r9,r6[0x0]
8000dcd4:	30 48       	mov	r8,4
8000dcd6:	93 07       	st.w	r9[0x0],r7
8000dcd8:	b2 68       	st.h	r9[0xc],r8
8000dcda:	93 17       	st.w	r9[0x4],r7
8000dcdc:	93 27       	st.w	r9[0x8],r7
8000dcde:	6c 18       	ld.w	r8,r6[0x4]
8000dce0:	b2 77       	st.h	r9[0xe],r7
8000dce2:	93 47       	st.w	r9[0x10],r7
8000dce4:	93 57       	st.w	r9[0x14],r7
8000dce6:	93 67       	st.w	r9[0x18],r7
8000dce8:	93 89       	st.w	r9[0x20],r9
8000dcea:	91 07       	st.w	r8[0x0],r7
8000dcec:	91 17       	st.w	r8[0x4],r7
8000dcee:	91 27       	st.w	r8[0x8],r7
8000dcf0:	fe ce f3 20 	sub	lr,pc,-3296
8000dcf4:	fe cb f3 50 	sub	r11,pc,-3248
8000dcf8:	93 9e       	st.w	r9[0x24],lr
8000dcfa:	93 ab       	st.w	r9[0x28],r11
8000dcfc:	fe ca f3 78 	sub	r10,pc,-3208
8000dd00:	fe c4 f3 84 	sub	r4,pc,-3196
8000dd04:	93 ba       	st.w	r9[0x2c],r10
8000dd06:	93 c4       	st.w	r9[0x30],r4
8000dd08:	30 99       	mov	r9,9
8000dd0a:	b0 69       	st.h	r8[0xc],r9
8000dd0c:	b0 75       	st.h	r8[0xe],r5
8000dd0e:	91 c4       	st.w	r8[0x30],r4
8000dd10:	91 47       	st.w	r8[0x10],r7
8000dd12:	91 57       	st.w	r8[0x14],r7
8000dd14:	91 67       	st.w	r8[0x18],r7
8000dd16:	91 88       	st.w	r8[0x20],r8
8000dd18:	91 9e       	st.w	r8[0x24],lr
8000dd1a:	91 ab       	st.w	r8[0x28],r11
8000dd1c:	91 ba       	st.w	r8[0x2c],r10
8000dd1e:	8d 2c       	st.w	r6[0x8],r12
8000dd20:	31 28       	mov	r8,18
8000dd22:	99 07       	st.w	r12[0x0],r7
8000dd24:	b8 68       	st.h	r12[0xc],r8
8000dd26:	99 17       	st.w	r12[0x4],r7
8000dd28:	99 27       	st.w	r12[0x8],r7
8000dd2a:	30 28       	mov	r8,2
8000dd2c:	b8 78       	st.h	r12[0xe],r8
8000dd2e:	99 c4       	st.w	r12[0x30],r4
8000dd30:	99 67       	st.w	r12[0x18],r7
8000dd32:	99 9e       	st.w	r12[0x24],lr
8000dd34:	99 ab       	st.w	r12[0x28],r11
8000dd36:	99 ba       	st.w	r12[0x2c],r10
8000dd38:	99 47       	st.w	r12[0x10],r7
8000dd3a:	99 57       	st.w	r12[0x14],r7
8000dd3c:	99 8c       	st.w	r12[0x20],r12
8000dd3e:	d8 22       	popm	r4-r7,pc

8000dd40 <_malloc_trim_r>:
8000dd40:	d4 21       	pushm	r4-r7,lr
8000dd42:	16 95       	mov	r5,r11
8000dd44:	18 97       	mov	r7,r12
8000dd46:	fe b0 d6 87 	rcall	80008a54 <__malloc_lock>
8000dd4a:	e0 64 05 38 	mov	r4,1336
8000dd4e:	68 28       	ld.w	r8,r4[0x8]
8000dd50:	70 16       	ld.w	r6,r8[0x4]
8000dd52:	e0 16 ff fc 	andl	r6,0xfffc
8000dd56:	ec c8 ff 91 	sub	r8,r6,-111
8000dd5a:	f0 05 01 05 	sub	r5,r8,r5
8000dd5e:	e0 15 ff 80 	andl	r5,0xff80
8000dd62:	ea c5 00 80 	sub	r5,r5,128
8000dd66:	e0 45 00 7f 	cp.w	r5,127
8000dd6a:	e0 8a 00 25 	brle	8000ddb4 <_malloc_trim_r+0x74>
8000dd6e:	30 0b       	mov	r11,0
8000dd70:	0e 9c       	mov	r12,r7
8000dd72:	fe b0 e5 5f 	rcall	8000a830 <_sbrk_r>
8000dd76:	68 28       	ld.w	r8,r4[0x8]
8000dd78:	0c 08       	add	r8,r6
8000dd7a:	10 3c       	cp.w	r12,r8
8000dd7c:	c1 c1       	brne	8000ddb4 <_malloc_trim_r+0x74>
8000dd7e:	ea 0b 11 00 	rsub	r11,r5,0
8000dd82:	0e 9c       	mov	r12,r7
8000dd84:	fe b0 e5 56 	rcall	8000a830 <_sbrk_r>
8000dd88:	5b fc       	cp.w	r12,-1
8000dd8a:	c1 91       	brne	8000ddbc <_malloc_trim_r+0x7c>
8000dd8c:	30 0b       	mov	r11,0
8000dd8e:	0e 9c       	mov	r12,r7
8000dd90:	fe b0 e5 50 	rcall	8000a830 <_sbrk_r>
8000dd94:	68 28       	ld.w	r8,r4[0x8]
8000dd96:	f8 08 01 09 	sub	r9,r12,r8
8000dd9a:	58 f9       	cp.w	r9,15
8000dd9c:	e0 8a 00 0c 	brle	8000ddb4 <_malloc_trim_r+0x74>
8000dda0:	a1 a9       	sbr	r9,0x0
8000dda2:	91 19       	st.w	r8[0x4],r9
8000dda4:	e0 68 09 44 	mov	r8,2372
8000dda8:	70 09       	ld.w	r9,r8[0x0]
8000ddaa:	e0 68 12 98 	mov	r8,4760
8000ddae:	f8 09 01 09 	sub	r9,r12,r9
8000ddb2:	91 09       	st.w	r8[0x0],r9
8000ddb4:	0e 9c       	mov	r12,r7
8000ddb6:	fe b0 d6 55 	rcall	80008a60 <__malloc_unlock>
8000ddba:	d8 2a       	popm	r4-r7,pc,r12=0
8000ddbc:	68 28       	ld.w	r8,r4[0x8]
8000ddbe:	0a 16       	sub	r6,r5
8000ddc0:	a1 a6       	sbr	r6,0x0
8000ddc2:	91 16       	st.w	r8[0x4],r6
8000ddc4:	e0 68 12 98 	mov	r8,4760
8000ddc8:	70 09       	ld.w	r9,r8[0x0]
8000ddca:	0a 19       	sub	r9,r5
8000ddcc:	0e 9c       	mov	r12,r7
8000ddce:	91 09       	st.w	r8[0x0],r9
8000ddd0:	fe b0 d6 48 	rcall	80008a60 <__malloc_unlock>
8000ddd4:	da 2a       	popm	r4-r7,pc,r12=1
8000ddd6:	d7 03       	nop

8000ddd8 <_free_r>:
8000ddd8:	d4 21       	pushm	r4-r7,lr
8000ddda:	16 96       	mov	r6,r11
8000dddc:	18 97       	mov	r7,r12
8000ddde:	58 0b       	cp.w	r11,0
8000dde0:	e0 80 00 c0 	breq	8000df60 <_free_r+0x188>
8000dde4:	fe b0 d6 38 	rcall	80008a54 <__malloc_lock>
8000dde8:	20 86       	sub	r6,8
8000ddea:	e0 6a 05 38 	mov	r10,1336
8000ddee:	6c 18       	ld.w	r8,r6[0x4]
8000ddf0:	74 2e       	ld.w	lr,r10[0x8]
8000ddf2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ddf6:	a1 c8       	cbr	r8,0x0
8000ddf8:	ec 08 00 09 	add	r9,r6,r8
8000ddfc:	72 1b       	ld.w	r11,r9[0x4]
8000ddfe:	e0 1b ff fc 	andl	r11,0xfffc
8000de02:	1c 39       	cp.w	r9,lr
8000de04:	c1 e1       	brne	8000de40 <_free_r+0x68>
8000de06:	f6 08 00 08 	add	r8,r11,r8
8000de0a:	58 0c       	cp.w	r12,0
8000de0c:	c0 81       	brne	8000de1c <_free_r+0x44>
8000de0e:	6c 09       	ld.w	r9,r6[0x0]
8000de10:	12 16       	sub	r6,r9
8000de12:	12 08       	add	r8,r9
8000de14:	6c 3b       	ld.w	r11,r6[0xc]
8000de16:	6c 29       	ld.w	r9,r6[0x8]
8000de18:	97 29       	st.w	r11[0x8],r9
8000de1a:	93 3b       	st.w	r9[0xc],r11
8000de1c:	10 99       	mov	r9,r8
8000de1e:	95 26       	st.w	r10[0x8],r6
8000de20:	a1 a9       	sbr	r9,0x0
8000de22:	8d 19       	st.w	r6[0x4],r9
8000de24:	e0 69 09 40 	mov	r9,2368
8000de28:	72 09       	ld.w	r9,r9[0x0]
8000de2a:	12 38       	cp.w	r8,r9
8000de2c:	c0 63       	brcs	8000de38 <_free_r+0x60>
8000de2e:	e0 68 12 94 	mov	r8,4756
8000de32:	0e 9c       	mov	r12,r7
8000de34:	70 0b       	ld.w	r11,r8[0x0]
8000de36:	c8 5f       	rcall	8000dd40 <_malloc_trim_r>
8000de38:	0e 9c       	mov	r12,r7
8000de3a:	fe b0 d6 13 	rcall	80008a60 <__malloc_unlock>
8000de3e:	d8 22       	popm	r4-r7,pc
8000de40:	93 1b       	st.w	r9[0x4],r11
8000de42:	58 0c       	cp.w	r12,0
8000de44:	c0 30       	breq	8000de4a <_free_r+0x72>
8000de46:	30 0c       	mov	r12,0
8000de48:	c1 08       	rjmp	8000de68 <_free_r+0x90>
8000de4a:	6c 0e       	ld.w	lr,r6[0x0]
8000de4c:	f4 c5 ff f8 	sub	r5,r10,-8
8000de50:	1c 16       	sub	r6,lr
8000de52:	1c 08       	add	r8,lr
8000de54:	6c 2e       	ld.w	lr,r6[0x8]
8000de56:	0a 3e       	cp.w	lr,r5
8000de58:	f9 bc 00 01 	moveq	r12,1
8000de5c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000de60:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000de64:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000de68:	f2 0b 00 0e 	add	lr,r9,r11
8000de6c:	7c 1e       	ld.w	lr,lr[0x4]
8000de6e:	ed be 00 00 	bld	lr,0x0
8000de72:	c1 40       	breq	8000de9a <_free_r+0xc2>
8000de74:	16 08       	add	r8,r11
8000de76:	58 0c       	cp.w	r12,0
8000de78:	c0 d1       	brne	8000de92 <_free_r+0xba>
8000de7a:	e0 6e 05 38 	mov	lr,1336
8000de7e:	72 2b       	ld.w	r11,r9[0x8]
8000de80:	2f 8e       	sub	lr,-8
8000de82:	1c 3b       	cp.w	r11,lr
8000de84:	c0 71       	brne	8000de92 <_free_r+0xba>
8000de86:	97 36       	st.w	r11[0xc],r6
8000de88:	97 26       	st.w	r11[0x8],r6
8000de8a:	8d 2b       	st.w	r6[0x8],r11
8000de8c:	8d 3b       	st.w	r6[0xc],r11
8000de8e:	30 1c       	mov	r12,1
8000de90:	c0 58       	rjmp	8000de9a <_free_r+0xc2>
8000de92:	72 2b       	ld.w	r11,r9[0x8]
8000de94:	72 39       	ld.w	r9,r9[0xc]
8000de96:	93 2b       	st.w	r9[0x8],r11
8000de98:	97 39       	st.w	r11[0xc],r9
8000de9a:	10 99       	mov	r9,r8
8000de9c:	ec 08 09 08 	st.w	r6[r8],r8
8000dea0:	a1 a9       	sbr	r9,0x0
8000dea2:	8d 19       	st.w	r6[0x4],r9
8000dea4:	58 0c       	cp.w	r12,0
8000dea6:	c5 a1       	brne	8000df5a <_free_r+0x182>
8000dea8:	e0 48 01 ff 	cp.w	r8,511
8000deac:	e0 8b 00 13 	brhi	8000ded2 <_free_r+0xfa>
8000deb0:	a3 98       	lsr	r8,0x3
8000deb2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000deb6:	72 2b       	ld.w	r11,r9[0x8]
8000deb8:	8d 39       	st.w	r6[0xc],r9
8000deba:	8d 2b       	st.w	r6[0x8],r11
8000debc:	97 36       	st.w	r11[0xc],r6
8000debe:	93 26       	st.w	r9[0x8],r6
8000dec0:	a3 48       	asr	r8,0x2
8000dec2:	74 19       	ld.w	r9,r10[0x4]
8000dec4:	30 1b       	mov	r11,1
8000dec6:	f6 08 09 48 	lsl	r8,r11,r8
8000deca:	f3 e8 10 08 	or	r8,r9,r8
8000dece:	95 18       	st.w	r10[0x4],r8
8000ded0:	c4 58       	rjmp	8000df5a <_free_r+0x182>
8000ded2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ded6:	58 4b       	cp.w	r11,4
8000ded8:	e0 8b 00 06 	brhi	8000dee4 <_free_r+0x10c>
8000dedc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000dee0:	2c 8b       	sub	r11,-56
8000dee2:	c2 08       	rjmp	8000df22 <_free_r+0x14a>
8000dee4:	59 4b       	cp.w	r11,20
8000dee6:	e0 8b 00 04 	brhi	8000deee <_free_r+0x116>
8000deea:	2a 5b       	sub	r11,-91
8000deec:	c1 b8       	rjmp	8000df22 <_free_r+0x14a>
8000deee:	e0 4b 00 54 	cp.w	r11,84
8000def2:	e0 8b 00 06 	brhi	8000defe <_free_r+0x126>
8000def6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000defa:	29 2b       	sub	r11,-110
8000defc:	c1 38       	rjmp	8000df22 <_free_r+0x14a>
8000defe:	e0 4b 01 54 	cp.w	r11,340
8000df02:	e0 8b 00 06 	brhi	8000df0e <_free_r+0x136>
8000df06:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000df0a:	28 9b       	sub	r11,-119
8000df0c:	c0 b8       	rjmp	8000df22 <_free_r+0x14a>
8000df0e:	e0 4b 05 54 	cp.w	r11,1364
8000df12:	e0 88 00 05 	brls	8000df1c <_free_r+0x144>
8000df16:	37 eb       	mov	r11,126
8000df18:	c0 58       	rjmp	8000df22 <_free_r+0x14a>
8000df1a:	d7 03       	nop
8000df1c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000df20:	28 4b       	sub	r11,-124
8000df22:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000df26:	78 29       	ld.w	r9,r12[0x8]
8000df28:	18 39       	cp.w	r9,r12
8000df2a:	c0 e1       	brne	8000df46 <_free_r+0x16e>
8000df2c:	74 18       	ld.w	r8,r10[0x4]
8000df2e:	a3 4b       	asr	r11,0x2
8000df30:	30 1c       	mov	r12,1
8000df32:	f8 0b 09 4b 	lsl	r11,r12,r11
8000df36:	f1 eb 10 0b 	or	r11,r8,r11
8000df3a:	12 98       	mov	r8,r9
8000df3c:	95 1b       	st.w	r10[0x4],r11
8000df3e:	c0 a8       	rjmp	8000df52 <_free_r+0x17a>
8000df40:	72 29       	ld.w	r9,r9[0x8]
8000df42:	18 39       	cp.w	r9,r12
8000df44:	c0 60       	breq	8000df50 <_free_r+0x178>
8000df46:	72 1a       	ld.w	r10,r9[0x4]
8000df48:	e0 1a ff fc 	andl	r10,0xfffc
8000df4c:	14 38       	cp.w	r8,r10
8000df4e:	cf 93       	brcs	8000df40 <_free_r+0x168>
8000df50:	72 38       	ld.w	r8,r9[0xc]
8000df52:	8d 38       	st.w	r6[0xc],r8
8000df54:	8d 29       	st.w	r6[0x8],r9
8000df56:	93 36       	st.w	r9[0xc],r6
8000df58:	91 26       	st.w	r8[0x8],r6
8000df5a:	0e 9c       	mov	r12,r7
8000df5c:	fe b0 d5 82 	rcall	80008a60 <__malloc_unlock>
8000df60:	d8 22       	popm	r4-r7,pc
8000df62:	d7 03       	nop

8000df64 <__sfvwrite_r>:
8000df64:	d4 31       	pushm	r0-r7,lr
8000df66:	20 3d       	sub	sp,12
8000df68:	14 94       	mov	r4,r10
8000df6a:	18 95       	mov	r5,r12
8000df6c:	16 97       	mov	r7,r11
8000df6e:	74 28       	ld.w	r8,r10[0x8]
8000df70:	58 08       	cp.w	r8,0
8000df72:	e0 80 01 40 	breq	8000e1f2 <__sfvwrite_r+0x28e>
8000df76:	96 68       	ld.sh	r8,r11[0xc]
8000df78:	ed b8 00 03 	bld	r8,0x3
8000df7c:	c0 41       	brne	8000df84 <__sfvwrite_r+0x20>
8000df7e:	76 48       	ld.w	r8,r11[0x10]
8000df80:	58 08       	cp.w	r8,0
8000df82:	c0 c1       	brne	8000df9a <__sfvwrite_r+0x36>
8000df84:	0e 9b       	mov	r11,r7
8000df86:	0a 9c       	mov	r12,r5
8000df88:	fe b0 f6 bc 	rcall	8000cd00 <__swsetup_r>
8000df8c:	c0 70       	breq	8000df9a <__sfvwrite_r+0x36>
8000df8e:	8e 68       	ld.sh	r8,r7[0xc]
8000df90:	a7 a8       	sbr	r8,0x6
8000df92:	ae 68       	st.h	r7[0xc],r8
8000df94:	30 98       	mov	r8,9
8000df96:	8b 38       	st.w	r5[0xc],r8
8000df98:	c2 b9       	rjmp	8000e1ee <__sfvwrite_r+0x28a>
8000df9a:	8e 63       	ld.sh	r3,r7[0xc]
8000df9c:	68 00       	ld.w	r0,r4[0x0]
8000df9e:	06 96       	mov	r6,r3
8000dfa0:	e2 16 00 02 	andl	r6,0x2,COH
8000dfa4:	c2 10       	breq	8000dfe6 <__sfvwrite_r+0x82>
8000dfa6:	30 03       	mov	r3,0
8000dfa8:	e0 62 04 00 	mov	r2,1024
8000dfac:	06 96       	mov	r6,r3
8000dfae:	c0 48       	rjmp	8000dfb6 <__sfvwrite_r+0x52>
8000dfb0:	60 03       	ld.w	r3,r0[0x0]
8000dfb2:	60 16       	ld.w	r6,r0[0x4]
8000dfb4:	2f 80       	sub	r0,-8
8000dfb6:	58 06       	cp.w	r6,0
8000dfb8:	cf c0       	breq	8000dfb0 <__sfvwrite_r+0x4c>
8000dfba:	e0 46 04 00 	cp.w	r6,1024
8000dfbe:	ec 09 17 80 	movls	r9,r6
8000dfc2:	e4 09 17 b0 	movhi	r9,r2
8000dfc6:	06 9a       	mov	r10,r3
8000dfc8:	6e a8       	ld.w	r8,r7[0x28]
8000dfca:	6e 8b       	ld.w	r11,r7[0x20]
8000dfcc:	0a 9c       	mov	r12,r5
8000dfce:	5d 18       	icall	r8
8000dfd0:	18 16       	sub	r6,r12
8000dfd2:	58 0c       	cp.w	r12,0
8000dfd4:	e0 8a 01 0a 	brle	8000e1e8 <__sfvwrite_r+0x284>
8000dfd8:	68 28       	ld.w	r8,r4[0x8]
8000dfda:	18 18       	sub	r8,r12
8000dfdc:	89 28       	st.w	r4[0x8],r8
8000dfde:	e0 80 01 0a 	breq	8000e1f2 <__sfvwrite_r+0x28e>
8000dfe2:	18 03       	add	r3,r12
8000dfe4:	ce 9b       	rjmp	8000dfb6 <__sfvwrite_r+0x52>
8000dfe6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000dfea:	c0 70       	breq	8000dff8 <__sfvwrite_r+0x94>
8000dfec:	50 06       	stdsp	sp[0x0],r6
8000dfee:	0c 93       	mov	r3,r6
8000dff0:	0c 91       	mov	r1,r6
8000dff2:	50 15       	stdsp	sp[0x4],r5
8000dff4:	08 92       	mov	r2,r4
8000dff6:	c9 c8       	rjmp	8000e12e <__sfvwrite_r+0x1ca>
8000dff8:	06 96       	mov	r6,r3
8000dffa:	08 91       	mov	r1,r4
8000dffc:	c0 48       	rjmp	8000e004 <__sfvwrite_r+0xa0>
8000dffe:	60 03       	ld.w	r3,r0[0x0]
8000e000:	60 16       	ld.w	r6,r0[0x4]
8000e002:	2f 80       	sub	r0,-8
8000e004:	58 06       	cp.w	r6,0
8000e006:	cf c0       	breq	8000dffe <__sfvwrite_r+0x9a>
8000e008:	8e 68       	ld.sh	r8,r7[0xc]
8000e00a:	6e 24       	ld.w	r4,r7[0x8]
8000e00c:	10 99       	mov	r9,r8
8000e00e:	e2 19 02 00 	andl	r9,0x200,COH
8000e012:	c5 50       	breq	8000e0bc <__sfvwrite_r+0x158>
8000e014:	08 36       	cp.w	r6,r4
8000e016:	c4 43       	brcs	8000e09e <__sfvwrite_r+0x13a>
8000e018:	10 99       	mov	r9,r8
8000e01a:	e2 19 04 80 	andl	r9,0x480,COH
8000e01e:	c4 00       	breq	8000e09e <__sfvwrite_r+0x13a>
8000e020:	6e 4b       	ld.w	r11,r7[0x10]
8000e022:	6e 09       	ld.w	r9,r7[0x0]
8000e024:	16 19       	sub	r9,r11
8000e026:	50 09       	stdsp	sp[0x0],r9
8000e028:	6e 59       	ld.w	r9,r7[0x14]
8000e02a:	10 9c       	mov	r12,r8
8000e02c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e030:	30 28       	mov	r8,2
8000e032:	f4 08 0c 08 	divs	r8,r10,r8
8000e036:	fa e9 00 04 	st.d	sp[4],r8
8000e03a:	10 94       	mov	r4,r8
8000e03c:	40 09       	lddsp	r9,sp[0x0]
8000e03e:	e2 1c 04 00 	andl	r12,0x400,COH
8000e042:	2f f9       	sub	r9,-1
8000e044:	0c 09       	add	r9,r6
8000e046:	12 38       	cp.w	r8,r9
8000e048:	f2 04 17 30 	movlo	r4,r9
8000e04c:	58 0c       	cp.w	r12,0
8000e04e:	c1 10       	breq	8000e070 <__sfvwrite_r+0x10c>
8000e050:	08 9b       	mov	r11,r4
8000e052:	0a 9c       	mov	r12,r5
8000e054:	fe b0 df b4 	rcall	80009fbc <_malloc_r>
8000e058:	18 92       	mov	r2,r12
8000e05a:	c1 40       	breq	8000e082 <__sfvwrite_r+0x11e>
8000e05c:	40 0a       	lddsp	r10,sp[0x0]
8000e05e:	6e 4b       	ld.w	r11,r7[0x10]
8000e060:	fe b0 e1 dd 	rcall	8000a41a <memcpy>
8000e064:	8e 68       	ld.sh	r8,r7[0xc]
8000e066:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e06a:	a7 b8       	sbr	r8,0x7
8000e06c:	ae 68       	st.h	r7[0xc],r8
8000e06e:	c0 d8       	rjmp	8000e088 <__sfvwrite_r+0x124>
8000e070:	08 9a       	mov	r10,r4
8000e072:	0a 9c       	mov	r12,r5
8000e074:	fe b0 e2 7e 	rcall	8000a570 <_realloc_r>
8000e078:	18 92       	mov	r2,r12
8000e07a:	c0 71       	brne	8000e088 <__sfvwrite_r+0x124>
8000e07c:	6e 4b       	ld.w	r11,r7[0x10]
8000e07e:	0a 9c       	mov	r12,r5
8000e080:	ca ce       	rcall	8000ddd8 <_free_r>
8000e082:	30 c8       	mov	r8,12
8000e084:	8b 38       	st.w	r5[0xc],r8
8000e086:	cb 18       	rjmp	8000e1e8 <__sfvwrite_r+0x284>
8000e088:	40 0a       	lddsp	r10,sp[0x0]
8000e08a:	40 09       	lddsp	r9,sp[0x0]
8000e08c:	e8 0a 01 0a 	sub	r10,r4,r10
8000e090:	e4 09 00 08 	add	r8,r2,r9
8000e094:	8f 54       	st.w	r7[0x14],r4
8000e096:	8f 2a       	st.w	r7[0x8],r10
8000e098:	8f 08       	st.w	r7[0x0],r8
8000e09a:	8f 42       	st.w	r7[0x10],r2
8000e09c:	0c 94       	mov	r4,r6
8000e09e:	08 36       	cp.w	r6,r4
8000e0a0:	ec 04 17 30 	movlo	r4,r6
8000e0a4:	06 9b       	mov	r11,r3
8000e0a6:	08 9a       	mov	r10,r4
8000e0a8:	6e 0c       	ld.w	r12,r7[0x0]
8000e0aa:	c3 ad       	rcall	8000e31e <memmove>
8000e0ac:	6e 08       	ld.w	r8,r7[0x0]
8000e0ae:	08 08       	add	r8,r4
8000e0b0:	8f 08       	st.w	r7[0x0],r8
8000e0b2:	6e 28       	ld.w	r8,r7[0x8]
8000e0b4:	08 18       	sub	r8,r4
8000e0b6:	0c 94       	mov	r4,r6
8000e0b8:	8f 28       	st.w	r7[0x8],r8
8000e0ba:	c2 e8       	rjmp	8000e116 <__sfvwrite_r+0x1b2>
8000e0bc:	08 36       	cp.w	r6,r4
8000e0be:	5f ba       	srhi	r10
8000e0c0:	6e 0c       	ld.w	r12,r7[0x0]
8000e0c2:	6e 48       	ld.w	r8,r7[0x10]
8000e0c4:	10 3c       	cp.w	r12,r8
8000e0c6:	5f b8       	srhi	r8
8000e0c8:	f5 e8 00 08 	and	r8,r10,r8
8000e0cc:	f2 08 18 00 	cp.b	r8,r9
8000e0d0:	c0 d0       	breq	8000e0ea <__sfvwrite_r+0x186>
8000e0d2:	06 9b       	mov	r11,r3
8000e0d4:	08 9a       	mov	r10,r4
8000e0d6:	c2 4d       	rcall	8000e31e <memmove>
8000e0d8:	6e 08       	ld.w	r8,r7[0x0]
8000e0da:	08 08       	add	r8,r4
8000e0dc:	0e 9b       	mov	r11,r7
8000e0de:	8f 08       	st.w	r7[0x0],r8
8000e0e0:	0a 9c       	mov	r12,r5
8000e0e2:	fe b0 fd 05 	rcall	8000daec <_fflush_r>
8000e0e6:	c1 80       	breq	8000e116 <__sfvwrite_r+0x1b2>
8000e0e8:	c8 08       	rjmp	8000e1e8 <__sfvwrite_r+0x284>
8000e0ea:	6e 59       	ld.w	r9,r7[0x14]
8000e0ec:	12 36       	cp.w	r6,r9
8000e0ee:	c0 a3       	brcs	8000e102 <__sfvwrite_r+0x19e>
8000e0f0:	6e a8       	ld.w	r8,r7[0x28]
8000e0f2:	06 9a       	mov	r10,r3
8000e0f4:	6e 8b       	ld.w	r11,r7[0x20]
8000e0f6:	0a 9c       	mov	r12,r5
8000e0f8:	5d 18       	icall	r8
8000e0fa:	18 94       	mov	r4,r12
8000e0fc:	e0 89 00 0d 	brgt	8000e116 <__sfvwrite_r+0x1b2>
8000e100:	c7 48       	rjmp	8000e1e8 <__sfvwrite_r+0x284>
8000e102:	0c 9a       	mov	r10,r6
8000e104:	06 9b       	mov	r11,r3
8000e106:	c0 cd       	rcall	8000e31e <memmove>
8000e108:	6e 08       	ld.w	r8,r7[0x0]
8000e10a:	0c 08       	add	r8,r6
8000e10c:	0c 94       	mov	r4,r6
8000e10e:	8f 08       	st.w	r7[0x0],r8
8000e110:	6e 28       	ld.w	r8,r7[0x8]
8000e112:	0c 18       	sub	r8,r6
8000e114:	8f 28       	st.w	r7[0x8],r8
8000e116:	62 28       	ld.w	r8,r1[0x8]
8000e118:	08 18       	sub	r8,r4
8000e11a:	83 28       	st.w	r1[0x8],r8
8000e11c:	c6 b0       	breq	8000e1f2 <__sfvwrite_r+0x28e>
8000e11e:	08 16       	sub	r6,r4
8000e120:	08 03       	add	r3,r4
8000e122:	c7 1b       	rjmp	8000e004 <__sfvwrite_r+0xa0>
8000e124:	60 03       	ld.w	r3,r0[0x0]
8000e126:	60 11       	ld.w	r1,r0[0x4]
8000e128:	30 08       	mov	r8,0
8000e12a:	2f 80       	sub	r0,-8
8000e12c:	50 08       	stdsp	sp[0x0],r8
8000e12e:	58 01       	cp.w	r1,0
8000e130:	cf a0       	breq	8000e124 <__sfvwrite_r+0x1c0>
8000e132:	40 0a       	lddsp	r10,sp[0x0]
8000e134:	58 0a       	cp.w	r10,0
8000e136:	c1 41       	brne	8000e15e <__sfvwrite_r+0x1fa>
8000e138:	e2 c6 ff ff 	sub	r6,r1,-1
8000e13c:	02 9a       	mov	r10,r1
8000e13e:	30 ab       	mov	r11,10
8000e140:	06 9c       	mov	r12,r3
8000e142:	ce 3c       	rcall	8000e308 <memchr>
8000e144:	f8 c8 ff ff 	sub	r8,r12,-1
8000e148:	58 0c       	cp.w	r12,0
8000e14a:	f1 d3 e1 16 	subne	r6,r8,r3
8000e14e:	f9 b9 01 01 	movne	r9,1
8000e152:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e156:	f9 b8 00 01 	moveq	r8,1
8000e15a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e15e:	02 36       	cp.w	r6,r1
8000e160:	ec 04 17 80 	movls	r4,r6
8000e164:	e2 04 17 b0 	movhi	r4,r1
8000e168:	6e 59       	ld.w	r9,r7[0x14]
8000e16a:	6e 25       	ld.w	r5,r7[0x8]
8000e16c:	f2 05 00 05 	add	r5,r9,r5
8000e170:	0a 34       	cp.w	r4,r5
8000e172:	5f 9a       	srgt	r10
8000e174:	6e 0c       	ld.w	r12,r7[0x0]
8000e176:	6e 48       	ld.w	r8,r7[0x10]
8000e178:	10 3c       	cp.w	r12,r8
8000e17a:	5f b8       	srhi	r8
8000e17c:	f5 e8 00 08 	and	r8,r10,r8
8000e180:	30 0a       	mov	r10,0
8000e182:	f4 08 18 00 	cp.b	r8,r10
8000e186:	c0 d0       	breq	8000e1a0 <__sfvwrite_r+0x23c>
8000e188:	06 9b       	mov	r11,r3
8000e18a:	0a 9a       	mov	r10,r5
8000e18c:	cc 9c       	rcall	8000e31e <memmove>
8000e18e:	6e 08       	ld.w	r8,r7[0x0]
8000e190:	0a 08       	add	r8,r5
8000e192:	0e 9b       	mov	r11,r7
8000e194:	8f 08       	st.w	r7[0x0],r8
8000e196:	40 1c       	lddsp	r12,sp[0x4]
8000e198:	fe b0 fc aa 	rcall	8000daec <_fflush_r>
8000e19c:	c1 70       	breq	8000e1ca <__sfvwrite_r+0x266>
8000e19e:	c2 58       	rjmp	8000e1e8 <__sfvwrite_r+0x284>
8000e1a0:	12 34       	cp.w	r4,r9
8000e1a2:	c0 a5       	brlt	8000e1b6 <__sfvwrite_r+0x252>
8000e1a4:	6e a8       	ld.w	r8,r7[0x28]
8000e1a6:	06 9a       	mov	r10,r3
8000e1a8:	6e 8b       	ld.w	r11,r7[0x20]
8000e1aa:	40 1c       	lddsp	r12,sp[0x4]
8000e1ac:	5d 18       	icall	r8
8000e1ae:	18 95       	mov	r5,r12
8000e1b0:	e0 89 00 0d 	brgt	8000e1ca <__sfvwrite_r+0x266>
8000e1b4:	c1 a8       	rjmp	8000e1e8 <__sfvwrite_r+0x284>
8000e1b6:	08 9a       	mov	r10,r4
8000e1b8:	06 9b       	mov	r11,r3
8000e1ba:	cb 2c       	rcall	8000e31e <memmove>
8000e1bc:	6e 08       	ld.w	r8,r7[0x0]
8000e1be:	08 08       	add	r8,r4
8000e1c0:	08 95       	mov	r5,r4
8000e1c2:	8f 08       	st.w	r7[0x0],r8
8000e1c4:	6e 28       	ld.w	r8,r7[0x8]
8000e1c6:	08 18       	sub	r8,r4
8000e1c8:	8f 28       	st.w	r7[0x8],r8
8000e1ca:	0a 16       	sub	r6,r5
8000e1cc:	c0 71       	brne	8000e1da <__sfvwrite_r+0x276>
8000e1ce:	0e 9b       	mov	r11,r7
8000e1d0:	40 1c       	lddsp	r12,sp[0x4]
8000e1d2:	fe b0 fc 8d 	rcall	8000daec <_fflush_r>
8000e1d6:	c0 91       	brne	8000e1e8 <__sfvwrite_r+0x284>
8000e1d8:	50 06       	stdsp	sp[0x0],r6
8000e1da:	64 28       	ld.w	r8,r2[0x8]
8000e1dc:	0a 18       	sub	r8,r5
8000e1de:	85 28       	st.w	r2[0x8],r8
8000e1e0:	c0 90       	breq	8000e1f2 <__sfvwrite_r+0x28e>
8000e1e2:	0a 11       	sub	r1,r5
8000e1e4:	0a 03       	add	r3,r5
8000e1e6:	ca 4b       	rjmp	8000e12e <__sfvwrite_r+0x1ca>
8000e1e8:	8e 68       	ld.sh	r8,r7[0xc]
8000e1ea:	a7 a8       	sbr	r8,0x6
8000e1ec:	ae 68       	st.h	r7[0xc],r8
8000e1ee:	3f fc       	mov	r12,-1
8000e1f0:	c0 28       	rjmp	8000e1f4 <__sfvwrite_r+0x290>
8000e1f2:	30 0c       	mov	r12,0
8000e1f4:	2f dd       	sub	sp,-12
8000e1f6:	d8 32       	popm	r0-r7,pc

8000e1f8 <_fwalk>:
8000e1f8:	d4 31       	pushm	r0-r7,lr
8000e1fa:	30 05       	mov	r5,0
8000e1fc:	16 91       	mov	r1,r11
8000e1fe:	f8 c7 ff 28 	sub	r7,r12,-216
8000e202:	0a 92       	mov	r2,r5
8000e204:	fe b0 fc fc 	rcall	8000dbfc <__sfp_lock_acquire>
8000e208:	3f f3       	mov	r3,-1
8000e20a:	c1 68       	rjmp	8000e236 <_fwalk+0x3e>
8000e20c:	6e 26       	ld.w	r6,r7[0x8]
8000e20e:	6e 14       	ld.w	r4,r7[0x4]
8000e210:	2f 46       	sub	r6,-12
8000e212:	c0 c8       	rjmp	8000e22a <_fwalk+0x32>
8000e214:	8c 08       	ld.sh	r8,r6[0x0]
8000e216:	e4 08 19 00 	cp.h	r8,r2
8000e21a:	c0 70       	breq	8000e228 <_fwalk+0x30>
8000e21c:	8c 18       	ld.sh	r8,r6[0x2]
8000e21e:	e6 08 19 00 	cp.h	r8,r3
8000e222:	c0 30       	breq	8000e228 <_fwalk+0x30>
8000e224:	5d 11       	icall	r1
8000e226:	18 45       	or	r5,r12
8000e228:	2a 46       	sub	r6,-92
8000e22a:	20 14       	sub	r4,1
8000e22c:	ec cc 00 0c 	sub	r12,r6,12
8000e230:	58 04       	cp.w	r4,0
8000e232:	cf 14       	brge	8000e214 <_fwalk+0x1c>
8000e234:	6e 07       	ld.w	r7,r7[0x0]
8000e236:	58 07       	cp.w	r7,0
8000e238:	ce a1       	brne	8000e20c <_fwalk+0x14>
8000e23a:	fe b0 fc e2 	rcall	8000dbfe <__sfp_lock_release>
8000e23e:	0a 9c       	mov	r12,r5
8000e240:	d8 32       	popm	r0-r7,pc
8000e242:	d7 03       	nop

8000e244 <_localeconv_r>:
8000e244:	48 1c       	lddpc	r12,8000e248 <_localeconv_r+0x4>
8000e246:	5e fc       	retal	r12
8000e248:	80 01       	ld.sh	r1,r0[0x0]
8000e24a:	91 38       	st.w	r8[0xc],r8

8000e24c <__smakebuf_r>:
8000e24c:	d4 21       	pushm	r4-r7,lr
8000e24e:	20 fd       	sub	sp,60
8000e250:	96 68       	ld.sh	r8,r11[0xc]
8000e252:	16 97       	mov	r7,r11
8000e254:	18 96       	mov	r6,r12
8000e256:	e2 18 00 02 	andl	r8,0x2,COH
8000e25a:	c3 d1       	brne	8000e2d4 <__smakebuf_r+0x88>
8000e25c:	96 7b       	ld.sh	r11,r11[0xe]
8000e25e:	f0 0b 19 00 	cp.h	r11,r8
8000e262:	c0 55       	brlt	8000e26c <__smakebuf_r+0x20>
8000e264:	1a 9a       	mov	r10,sp
8000e266:	e0 a0 04 79 	rcall	8000eb58 <_fstat_r>
8000e26a:	c0 f4       	brge	8000e288 <__smakebuf_r+0x3c>
8000e26c:	8e 65       	ld.sh	r5,r7[0xc]
8000e26e:	0a 98       	mov	r8,r5
8000e270:	ab b8       	sbr	r8,0xb
8000e272:	e2 15 00 80 	andl	r5,0x80,COH
8000e276:	ae 68       	st.h	r7[0xc],r8
8000e278:	30 04       	mov	r4,0
8000e27a:	e0 68 04 00 	mov	r8,1024
8000e27e:	f9 b5 01 40 	movne	r5,64
8000e282:	f0 05 17 00 	moveq	r5,r8
8000e286:	c1 c8       	rjmp	8000e2be <__smakebuf_r+0x72>
8000e288:	40 18       	lddsp	r8,sp[0x4]
8000e28a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e28e:	e0 48 20 00 	cp.w	r8,8192
8000e292:	5f 04       	sreq	r4
8000e294:	e0 48 80 00 	cp.w	r8,32768
8000e298:	c0 e1       	brne	8000e2b4 <__smakebuf_r+0x68>
8000e29a:	6e b9       	ld.w	r9,r7[0x2c]
8000e29c:	fe c8 f9 18 	sub	r8,pc,-1768
8000e2a0:	10 39       	cp.w	r9,r8
8000e2a2:	c0 91       	brne	8000e2b4 <__smakebuf_r+0x68>
8000e2a4:	8e 68       	ld.sh	r8,r7[0xc]
8000e2a6:	e0 65 04 00 	mov	r5,1024
8000e2aa:	ab a8       	sbr	r8,0xa
8000e2ac:	ef 45 00 50 	st.w	r7[80],r5
8000e2b0:	ae 68       	st.h	r7[0xc],r8
8000e2b2:	c0 68       	rjmp	8000e2be <__smakebuf_r+0x72>
8000e2b4:	8e 68       	ld.sh	r8,r7[0xc]
8000e2b6:	e0 65 04 00 	mov	r5,1024
8000e2ba:	ab b8       	sbr	r8,0xb
8000e2bc:	ae 68       	st.h	r7[0xc],r8
8000e2be:	0a 9b       	mov	r11,r5
8000e2c0:	0c 9c       	mov	r12,r6
8000e2c2:	fe b0 de 7d 	rcall	80009fbc <_malloc_r>
8000e2c6:	8e 68       	ld.sh	r8,r7[0xc]
8000e2c8:	c0 d1       	brne	8000e2e2 <__smakebuf_r+0x96>
8000e2ca:	ed b8 00 09 	bld	r8,0x9
8000e2ce:	c1 b0       	breq	8000e304 <__smakebuf_r+0xb8>
8000e2d0:	a1 b8       	sbr	r8,0x1
8000e2d2:	ae 68       	st.h	r7[0xc],r8
8000e2d4:	ee c8 ff b9 	sub	r8,r7,-71
8000e2d8:	8f 48       	st.w	r7[0x10],r8
8000e2da:	8f 08       	st.w	r7[0x0],r8
8000e2dc:	30 18       	mov	r8,1
8000e2de:	8f 58       	st.w	r7[0x14],r8
8000e2e0:	c1 28       	rjmp	8000e304 <__smakebuf_r+0xb8>
8000e2e2:	a7 b8       	sbr	r8,0x7
8000e2e4:	8f 4c       	st.w	r7[0x10],r12
8000e2e6:	ae 68       	st.h	r7[0xc],r8
8000e2e8:	8f 55       	st.w	r7[0x14],r5
8000e2ea:	fe c8 06 ea 	sub	r8,pc,1770
8000e2ee:	8f 0c       	st.w	r7[0x0],r12
8000e2f0:	8d a8       	st.w	r6[0x28],r8
8000e2f2:	58 04       	cp.w	r4,0
8000e2f4:	c0 80       	breq	8000e304 <__smakebuf_r+0xb8>
8000e2f6:	8e 7c       	ld.sh	r12,r7[0xe]
8000e2f8:	fe b0 e3 7a 	rcall	8000a9ec <isatty>
8000e2fc:	c0 40       	breq	8000e304 <__smakebuf_r+0xb8>
8000e2fe:	8e 68       	ld.sh	r8,r7[0xc]
8000e300:	a1 a8       	sbr	r8,0x0
8000e302:	ae 68       	st.h	r7[0xc],r8
8000e304:	2f 1d       	sub	sp,-60
8000e306:	d8 22       	popm	r4-r7,pc

8000e308 <memchr>:
8000e308:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e30c:	c0 68       	rjmp	8000e318 <memchr+0x10>
8000e30e:	20 1a       	sub	r10,1
8000e310:	19 88       	ld.ub	r8,r12[0x0]
8000e312:	16 38       	cp.w	r8,r11
8000e314:	5e 0c       	reteq	r12
8000e316:	2f fc       	sub	r12,-1
8000e318:	58 0a       	cp.w	r10,0
8000e31a:	cf a1       	brne	8000e30e <memchr+0x6>
8000e31c:	5e fa       	retal	r10

8000e31e <memmove>:
8000e31e:	d4 01       	pushm	lr
8000e320:	18 3b       	cp.w	r11,r12
8000e322:	c1 92       	brcc	8000e354 <memmove+0x36>
8000e324:	f6 0a 00 09 	add	r9,r11,r10
8000e328:	12 3c       	cp.w	r12,r9
8000e32a:	c1 52       	brcc	8000e354 <memmove+0x36>
8000e32c:	f8 0a 00 0b 	add	r11,r12,r10
8000e330:	30 08       	mov	r8,0
8000e332:	c0 68       	rjmp	8000e33e <memmove+0x20>
8000e334:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e338:	20 1a       	sub	r10,1
8000e33a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e33e:	20 18       	sub	r8,1
8000e340:	58 0a       	cp.w	r10,0
8000e342:	cf 91       	brne	8000e334 <memmove+0x16>
8000e344:	d8 02       	popm	pc
8000e346:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e34a:	20 1a       	sub	r10,1
8000e34c:	f8 08 0b 09 	st.b	r12[r8],r9
8000e350:	2f f8       	sub	r8,-1
8000e352:	c0 28       	rjmp	8000e356 <memmove+0x38>
8000e354:	30 08       	mov	r8,0
8000e356:	58 0a       	cp.w	r10,0
8000e358:	cf 71       	brne	8000e346 <memmove+0x28>
8000e35a:	d8 02       	popm	pc

8000e35c <__hi0bits>:
8000e35c:	18 98       	mov	r8,r12
8000e35e:	e0 1c 00 00 	andl	r12,0x0
8000e362:	f0 09 15 10 	lsl	r9,r8,0x10
8000e366:	58 0c       	cp.w	r12,0
8000e368:	f2 08 17 00 	moveq	r8,r9
8000e36c:	f9 bc 00 10 	moveq	r12,16
8000e370:	f9 bc 01 00 	movne	r12,0
8000e374:	10 9a       	mov	r10,r8
8000e376:	f0 09 15 08 	lsl	r9,r8,0x8
8000e37a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e37e:	f7 bc 00 f8 	subeq	r12,-8
8000e382:	f2 08 17 00 	moveq	r8,r9
8000e386:	10 9a       	mov	r10,r8
8000e388:	f0 09 15 04 	lsl	r9,r8,0x4
8000e38c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e390:	f7 bc 00 fc 	subeq	r12,-4
8000e394:	f2 08 17 00 	moveq	r8,r9
8000e398:	10 9a       	mov	r10,r8
8000e39a:	f0 09 15 02 	lsl	r9,r8,0x2
8000e39e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e3a2:	f7 bc 00 fe 	subeq	r12,-2
8000e3a6:	f2 08 17 00 	moveq	r8,r9
8000e3aa:	58 08       	cp.w	r8,0
8000e3ac:	5e 5c       	retlt	r12
8000e3ae:	ed b8 00 1e 	bld	r8,0x1e
8000e3b2:	f9 bc 01 20 	movne	r12,32
8000e3b6:	f7 bc 00 ff 	subeq	r12,-1
8000e3ba:	5e fc       	retal	r12

8000e3bc <__lo0bits>:
8000e3bc:	18 99       	mov	r9,r12
8000e3be:	78 08       	ld.w	r8,r12[0x0]
8000e3c0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e3c4:	c1 50       	breq	8000e3ee <__lo0bits+0x32>
8000e3c6:	ed b8 00 00 	bld	r8,0x0
8000e3ca:	c0 21       	brne	8000e3ce <__lo0bits+0x12>
8000e3cc:	5e fd       	retal	0
8000e3ce:	10 9b       	mov	r11,r8
8000e3d0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e3d4:	e2 1b 00 02 	andl	r11,0x2,COH
8000e3d8:	a3 88       	lsr	r8,0x2
8000e3da:	58 0b       	cp.w	r11,0
8000e3dc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e3e0:	f9 bc 01 01 	movne	r12,1
8000e3e4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e3e8:	f9 bc 00 02 	moveq	r12,2
8000e3ec:	5e fc       	retal	r12
8000e3ee:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e3f2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e3f6:	58 0a       	cp.w	r10,0
8000e3f8:	f6 08 17 00 	moveq	r8,r11
8000e3fc:	f9 bc 00 10 	moveq	r12,16
8000e400:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e404:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e408:	58 0b       	cp.w	r11,0
8000e40a:	f7 bc 00 f8 	subeq	r12,-8
8000e40e:	f4 08 17 00 	moveq	r8,r10
8000e412:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e416:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e41a:	58 0b       	cp.w	r11,0
8000e41c:	f7 bc 00 fc 	subeq	r12,-4
8000e420:	f4 08 17 00 	moveq	r8,r10
8000e424:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e428:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e42c:	58 0b       	cp.w	r11,0
8000e42e:	f7 bc 00 fe 	subeq	r12,-2
8000e432:	f4 08 17 00 	moveq	r8,r10
8000e436:	ed b8 00 00 	bld	r8,0x0
8000e43a:	c0 60       	breq	8000e446 <__lo0bits+0x8a>
8000e43c:	a1 98       	lsr	r8,0x1
8000e43e:	c0 31       	brne	8000e444 <__lo0bits+0x88>
8000e440:	32 0c       	mov	r12,32
8000e442:	5e fc       	retal	r12
8000e444:	2f fc       	sub	r12,-1
8000e446:	93 08       	st.w	r9[0x0],r8
8000e448:	5e fc       	retal	r12

8000e44a <__mcmp>:
8000e44a:	d4 01       	pushm	lr
8000e44c:	18 98       	mov	r8,r12
8000e44e:	76 49       	ld.w	r9,r11[0x10]
8000e450:	78 4c       	ld.w	r12,r12[0x10]
8000e452:	12 1c       	sub	r12,r9
8000e454:	c1 31       	brne	8000e47a <__mcmp+0x30>
8000e456:	2f b9       	sub	r9,-5
8000e458:	a3 69       	lsl	r9,0x2
8000e45a:	12 0b       	add	r11,r9
8000e45c:	f0 09 00 09 	add	r9,r8,r9
8000e460:	2e c8       	sub	r8,-20
8000e462:	13 4e       	ld.w	lr,--r9
8000e464:	17 4a       	ld.w	r10,--r11
8000e466:	14 3e       	cp.w	lr,r10
8000e468:	c0 60       	breq	8000e474 <__mcmp+0x2a>
8000e46a:	f9 bc 03 ff 	movlo	r12,-1
8000e46e:	f9 bc 02 01 	movhs	r12,1
8000e472:	d8 02       	popm	pc
8000e474:	10 39       	cp.w	r9,r8
8000e476:	fe 9b ff f6 	brhi	8000e462 <__mcmp+0x18>
8000e47a:	d8 02       	popm	pc

8000e47c <_Bfree>:
8000e47c:	d4 21       	pushm	r4-r7,lr
8000e47e:	18 97       	mov	r7,r12
8000e480:	16 95       	mov	r5,r11
8000e482:	78 96       	ld.w	r6,r12[0x24]
8000e484:	58 06       	cp.w	r6,0
8000e486:	c0 91       	brne	8000e498 <_Bfree+0x1c>
8000e488:	31 0c       	mov	r12,16
8000e48a:	fe b0 dd 91 	rcall	80009fac <malloc>
8000e48e:	99 36       	st.w	r12[0xc],r6
8000e490:	8f 9c       	st.w	r7[0x24],r12
8000e492:	99 16       	st.w	r12[0x4],r6
8000e494:	99 26       	st.w	r12[0x8],r6
8000e496:	99 06       	st.w	r12[0x0],r6
8000e498:	58 05       	cp.w	r5,0
8000e49a:	c0 90       	breq	8000e4ac <_Bfree+0x30>
8000e49c:	6a 19       	ld.w	r9,r5[0x4]
8000e49e:	6e 98       	ld.w	r8,r7[0x24]
8000e4a0:	70 38       	ld.w	r8,r8[0xc]
8000e4a2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e4a6:	8b 0a       	st.w	r5[0x0],r10
8000e4a8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e4ac:	d8 22       	popm	r4-r7,pc
8000e4ae:	d7 03       	nop

8000e4b0 <_Balloc>:
8000e4b0:	d4 21       	pushm	r4-r7,lr
8000e4b2:	18 97       	mov	r7,r12
8000e4b4:	16 96       	mov	r6,r11
8000e4b6:	78 95       	ld.w	r5,r12[0x24]
8000e4b8:	58 05       	cp.w	r5,0
8000e4ba:	c0 91       	brne	8000e4cc <_Balloc+0x1c>
8000e4bc:	31 0c       	mov	r12,16
8000e4be:	fe b0 dd 77 	rcall	80009fac <malloc>
8000e4c2:	99 35       	st.w	r12[0xc],r5
8000e4c4:	8f 9c       	st.w	r7[0x24],r12
8000e4c6:	99 15       	st.w	r12[0x4],r5
8000e4c8:	99 25       	st.w	r12[0x8],r5
8000e4ca:	99 05       	st.w	r12[0x0],r5
8000e4cc:	6e 95       	ld.w	r5,r7[0x24]
8000e4ce:	6a 38       	ld.w	r8,r5[0xc]
8000e4d0:	58 08       	cp.w	r8,0
8000e4d2:	c0 b1       	brne	8000e4e8 <_Balloc+0x38>
8000e4d4:	31 0a       	mov	r10,16
8000e4d6:	30 4b       	mov	r11,4
8000e4d8:	0e 9c       	mov	r12,r7
8000e4da:	e0 a0 02 9d 	rcall	8000ea14 <_calloc_r>
8000e4de:	8b 3c       	st.w	r5[0xc],r12
8000e4e0:	6e 98       	ld.w	r8,r7[0x24]
8000e4e2:	70 3c       	ld.w	r12,r8[0xc]
8000e4e4:	58 0c       	cp.w	r12,0
8000e4e6:	c1 b0       	breq	8000e51c <_Balloc+0x6c>
8000e4e8:	6e 98       	ld.w	r8,r7[0x24]
8000e4ea:	70 38       	ld.w	r8,r8[0xc]
8000e4ec:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000e4f0:	70 0c       	ld.w	r12,r8[0x0]
8000e4f2:	58 0c       	cp.w	r12,0
8000e4f4:	c0 40       	breq	8000e4fc <_Balloc+0x4c>
8000e4f6:	78 09       	ld.w	r9,r12[0x0]
8000e4f8:	91 09       	st.w	r8[0x0],r9
8000e4fa:	c0 e8       	rjmp	8000e516 <_Balloc+0x66>
8000e4fc:	0e 9c       	mov	r12,r7
8000e4fe:	30 17       	mov	r7,1
8000e500:	0e 9b       	mov	r11,r7
8000e502:	ee 06 09 47 	lsl	r7,r7,r6
8000e506:	ee ca ff fb 	sub	r10,r7,-5
8000e50a:	a3 6a       	lsl	r10,0x2
8000e50c:	e0 a0 02 84 	rcall	8000ea14 <_calloc_r>
8000e510:	c0 60       	breq	8000e51c <_Balloc+0x6c>
8000e512:	99 16       	st.w	r12[0x4],r6
8000e514:	99 27       	st.w	r12[0x8],r7
8000e516:	30 08       	mov	r8,0
8000e518:	99 38       	st.w	r12[0xc],r8
8000e51a:	99 48       	st.w	r12[0x10],r8
8000e51c:	d8 22       	popm	r4-r7,pc
8000e51e:	d7 03       	nop

8000e520 <__d2b>:
8000e520:	d4 31       	pushm	r0-r7,lr
8000e522:	20 2d       	sub	sp,8
8000e524:	16 93       	mov	r3,r11
8000e526:	12 96       	mov	r6,r9
8000e528:	10 95       	mov	r5,r8
8000e52a:	14 92       	mov	r2,r10
8000e52c:	30 1b       	mov	r11,1
8000e52e:	cc 1f       	rcall	8000e4b0 <_Balloc>
8000e530:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000e534:	50 09       	stdsp	sp[0x0],r9
8000e536:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000e53a:	b5 a9       	sbr	r9,0x14
8000e53c:	f0 01 16 14 	lsr	r1,r8,0x14
8000e540:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e544:	18 94       	mov	r4,r12
8000e546:	58 02       	cp.w	r2,0
8000e548:	c1 d0       	breq	8000e582 <__d2b+0x62>
8000e54a:	fa cc ff f8 	sub	r12,sp,-8
8000e54e:	18 d2       	st.w	--r12,r2
8000e550:	c3 6f       	rcall	8000e3bc <__lo0bits>
8000e552:	40 18       	lddsp	r8,sp[0x4]
8000e554:	c0 d0       	breq	8000e56e <__d2b+0x4e>
8000e556:	40 09       	lddsp	r9,sp[0x0]
8000e558:	f8 0a 11 20 	rsub	r10,r12,32
8000e55c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000e560:	f5 e8 10 08 	or	r8,r10,r8
8000e564:	89 58       	st.w	r4[0x14],r8
8000e566:	f2 0c 0a 49 	lsr	r9,r9,r12
8000e56a:	50 09       	stdsp	sp[0x0],r9
8000e56c:	c0 28       	rjmp	8000e570 <__d2b+0x50>
8000e56e:	89 58       	st.w	r4[0x14],r8
8000e570:	40 08       	lddsp	r8,sp[0x0]
8000e572:	58 08       	cp.w	r8,0
8000e574:	f9 b3 01 02 	movne	r3,2
8000e578:	f9 b3 00 01 	moveq	r3,1
8000e57c:	89 68       	st.w	r4[0x18],r8
8000e57e:	89 43       	st.w	r4[0x10],r3
8000e580:	c0 88       	rjmp	8000e590 <__d2b+0x70>
8000e582:	1a 9c       	mov	r12,sp
8000e584:	c1 cf       	rcall	8000e3bc <__lo0bits>
8000e586:	30 13       	mov	r3,1
8000e588:	40 08       	lddsp	r8,sp[0x0]
8000e58a:	2e 0c       	sub	r12,-32
8000e58c:	89 43       	st.w	r4[0x10],r3
8000e58e:	89 58       	st.w	r4[0x14],r8
8000e590:	58 01       	cp.w	r1,0
8000e592:	c0 90       	breq	8000e5a4 <__d2b+0x84>
8000e594:	e2 c1 04 33 	sub	r1,r1,1075
8000e598:	18 01       	add	r1,r12
8000e59a:	8d 01       	st.w	r6[0x0],r1
8000e59c:	f8 0c 11 35 	rsub	r12,r12,53
8000e5a0:	8b 0c       	st.w	r5[0x0],r12
8000e5a2:	c0 c8       	rjmp	8000e5ba <__d2b+0x9a>
8000e5a4:	e6 c8 ff fc 	sub	r8,r3,-4
8000e5a8:	f8 cc 04 32 	sub	r12,r12,1074
8000e5ac:	a5 73       	lsl	r3,0x5
8000e5ae:	8d 0c       	st.w	r6[0x0],r12
8000e5b0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000e5b4:	cd 4e       	rcall	8000e35c <__hi0bits>
8000e5b6:	18 13       	sub	r3,r12
8000e5b8:	8b 03       	st.w	r5[0x0],r3
8000e5ba:	08 9c       	mov	r12,r4
8000e5bc:	2f ed       	sub	sp,-8
8000e5be:	d8 32       	popm	r0-r7,pc

8000e5c0 <__mdiff>:
8000e5c0:	d4 31       	pushm	r0-r7,lr
8000e5c2:	74 48       	ld.w	r8,r10[0x10]
8000e5c4:	76 45       	ld.w	r5,r11[0x10]
8000e5c6:	16 97       	mov	r7,r11
8000e5c8:	14 96       	mov	r6,r10
8000e5ca:	10 15       	sub	r5,r8
8000e5cc:	c1 31       	brne	8000e5f2 <__mdiff+0x32>
8000e5ce:	2f b8       	sub	r8,-5
8000e5d0:	ee ce ff ec 	sub	lr,r7,-20
8000e5d4:	a3 68       	lsl	r8,0x2
8000e5d6:	f4 08 00 0b 	add	r11,r10,r8
8000e5da:	ee 08 00 08 	add	r8,r7,r8
8000e5de:	11 4a       	ld.w	r10,--r8
8000e5e0:	17 49       	ld.w	r9,--r11
8000e5e2:	12 3a       	cp.w	r10,r9
8000e5e4:	c0 30       	breq	8000e5ea <__mdiff+0x2a>
8000e5e6:	c0 e2       	brcc	8000e602 <__mdiff+0x42>
8000e5e8:	c0 78       	rjmp	8000e5f6 <__mdiff+0x36>
8000e5ea:	1c 38       	cp.w	r8,lr
8000e5ec:	fe 9b ff f9 	brhi	8000e5de <__mdiff+0x1e>
8000e5f0:	c4 98       	rjmp	8000e682 <__mdiff+0xc2>
8000e5f2:	58 05       	cp.w	r5,0
8000e5f4:	c0 64       	brge	8000e600 <__mdiff+0x40>
8000e5f6:	0e 98       	mov	r8,r7
8000e5f8:	30 15       	mov	r5,1
8000e5fa:	0c 97       	mov	r7,r6
8000e5fc:	10 96       	mov	r6,r8
8000e5fe:	c0 28       	rjmp	8000e602 <__mdiff+0x42>
8000e600:	30 05       	mov	r5,0
8000e602:	6e 1b       	ld.w	r11,r7[0x4]
8000e604:	c5 6f       	rcall	8000e4b0 <_Balloc>
8000e606:	6e 49       	ld.w	r9,r7[0x10]
8000e608:	6c 44       	ld.w	r4,r6[0x10]
8000e60a:	99 35       	st.w	r12[0xc],r5
8000e60c:	2f b4       	sub	r4,-5
8000e60e:	f2 c5 ff fb 	sub	r5,r9,-5
8000e612:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000e616:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000e61a:	2e c6       	sub	r6,-20
8000e61c:	2e c7       	sub	r7,-20
8000e61e:	f8 c8 ff ec 	sub	r8,r12,-20
8000e622:	30 0a       	mov	r10,0
8000e624:	0f 0e       	ld.w	lr,r7++
8000e626:	0d 0b       	ld.w	r11,r6++
8000e628:	fc 02 16 10 	lsr	r2,lr,0x10
8000e62c:	f6 03 16 10 	lsr	r3,r11,0x10
8000e630:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000e634:	e4 03 01 03 	sub	r3,r2,r3
8000e638:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e63c:	fc 0b 01 0b 	sub	r11,lr,r11
8000e640:	f6 0a 00 0a 	add	r10,r11,r10
8000e644:	b0 1a       	st.h	r8[0x2],r10
8000e646:	b1 4a       	asr	r10,0x10
8000e648:	e6 0a 00 0a 	add	r10,r3,r10
8000e64c:	b0 0a       	st.h	r8[0x0],r10
8000e64e:	2f c8       	sub	r8,-4
8000e650:	b1 4a       	asr	r10,0x10
8000e652:	08 36       	cp.w	r6,r4
8000e654:	ce 83       	brcs	8000e624 <__mdiff+0x64>
8000e656:	c0 d8       	rjmp	8000e670 <__mdiff+0xb0>
8000e658:	0f 0b       	ld.w	r11,r7++
8000e65a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000e65e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e662:	16 0a       	add	r10,r11
8000e664:	b0 1a       	st.h	r8[0x2],r10
8000e666:	b1 4a       	asr	r10,0x10
8000e668:	1c 0a       	add	r10,lr
8000e66a:	b0 0a       	st.h	r8[0x0],r10
8000e66c:	2f c8       	sub	r8,-4
8000e66e:	b1 4a       	asr	r10,0x10
8000e670:	0a 37       	cp.w	r7,r5
8000e672:	cf 33       	brcs	8000e658 <__mdiff+0x98>
8000e674:	c0 28       	rjmp	8000e678 <__mdiff+0xb8>
8000e676:	20 19       	sub	r9,1
8000e678:	11 4a       	ld.w	r10,--r8
8000e67a:	58 0a       	cp.w	r10,0
8000e67c:	cf d0       	breq	8000e676 <__mdiff+0xb6>
8000e67e:	99 49       	st.w	r12[0x10],r9
8000e680:	d8 32       	popm	r0-r7,pc
8000e682:	30 0b       	mov	r11,0
8000e684:	c1 6f       	rcall	8000e4b0 <_Balloc>
8000e686:	30 18       	mov	r8,1
8000e688:	99 48       	st.w	r12[0x10],r8
8000e68a:	30 08       	mov	r8,0
8000e68c:	99 58       	st.w	r12[0x14],r8
8000e68e:	d8 32       	popm	r0-r7,pc

8000e690 <__lshift>:
8000e690:	d4 31       	pushm	r0-r7,lr
8000e692:	16 97       	mov	r7,r11
8000e694:	76 46       	ld.w	r6,r11[0x10]
8000e696:	f4 02 14 05 	asr	r2,r10,0x5
8000e69a:	2f f6       	sub	r6,-1
8000e69c:	14 93       	mov	r3,r10
8000e69e:	18 94       	mov	r4,r12
8000e6a0:	04 06       	add	r6,r2
8000e6a2:	76 1b       	ld.w	r11,r11[0x4]
8000e6a4:	6e 28       	ld.w	r8,r7[0x8]
8000e6a6:	c0 38       	rjmp	8000e6ac <__lshift+0x1c>
8000e6a8:	2f fb       	sub	r11,-1
8000e6aa:	a1 78       	lsl	r8,0x1
8000e6ac:	10 36       	cp.w	r6,r8
8000e6ae:	fe 99 ff fd 	brgt	8000e6a8 <__lshift+0x18>
8000e6b2:	08 9c       	mov	r12,r4
8000e6b4:	cf ee       	rcall	8000e4b0 <_Balloc>
8000e6b6:	30 09       	mov	r9,0
8000e6b8:	18 95       	mov	r5,r12
8000e6ba:	f8 c8 ff ec 	sub	r8,r12,-20
8000e6be:	12 9a       	mov	r10,r9
8000e6c0:	c0 38       	rjmp	8000e6c6 <__lshift+0x36>
8000e6c2:	10 aa       	st.w	r8++,r10
8000e6c4:	2f f9       	sub	r9,-1
8000e6c6:	04 39       	cp.w	r9,r2
8000e6c8:	cf d5       	brlt	8000e6c2 <__lshift+0x32>
8000e6ca:	6e 4b       	ld.w	r11,r7[0x10]
8000e6cc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000e6d0:	2f bb       	sub	r11,-5
8000e6d2:	ee c9 ff ec 	sub	r9,r7,-20
8000e6d6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000e6da:	58 03       	cp.w	r3,0
8000e6dc:	c1 30       	breq	8000e702 <__lshift+0x72>
8000e6de:	e6 0c 11 20 	rsub	r12,r3,32
8000e6e2:	30 0a       	mov	r10,0
8000e6e4:	72 02       	ld.w	r2,r9[0x0]
8000e6e6:	e4 03 09 42 	lsl	r2,r2,r3
8000e6ea:	04 4a       	or	r10,r2
8000e6ec:	10 aa       	st.w	r8++,r10
8000e6ee:	13 0a       	ld.w	r10,r9++
8000e6f0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000e6f4:	16 39       	cp.w	r9,r11
8000e6f6:	cf 73       	brcs	8000e6e4 <__lshift+0x54>
8000e6f8:	91 0a       	st.w	r8[0x0],r10
8000e6fa:	58 0a       	cp.w	r10,0
8000e6fc:	c0 70       	breq	8000e70a <__lshift+0x7a>
8000e6fe:	2f f6       	sub	r6,-1
8000e700:	c0 58       	rjmp	8000e70a <__lshift+0x7a>
8000e702:	13 0a       	ld.w	r10,r9++
8000e704:	10 aa       	st.w	r8++,r10
8000e706:	16 39       	cp.w	r9,r11
8000e708:	cf d3       	brcs	8000e702 <__lshift+0x72>
8000e70a:	08 9c       	mov	r12,r4
8000e70c:	20 16       	sub	r6,1
8000e70e:	0e 9b       	mov	r11,r7
8000e710:	8b 46       	st.w	r5[0x10],r6
8000e712:	cb 5e       	rcall	8000e47c <_Bfree>
8000e714:	0a 9c       	mov	r12,r5
8000e716:	d8 32       	popm	r0-r7,pc

8000e718 <__multiply>:
8000e718:	d4 31       	pushm	r0-r7,lr
8000e71a:	20 2d       	sub	sp,8
8000e71c:	76 49       	ld.w	r9,r11[0x10]
8000e71e:	74 48       	ld.w	r8,r10[0x10]
8000e720:	16 96       	mov	r6,r11
8000e722:	14 95       	mov	r5,r10
8000e724:	10 39       	cp.w	r9,r8
8000e726:	ec 08 17 50 	movlt	r8,r6
8000e72a:	ea 06 17 50 	movlt	r6,r5
8000e72e:	f0 05 17 50 	movlt	r5,r8
8000e732:	6c 28       	ld.w	r8,r6[0x8]
8000e734:	76 43       	ld.w	r3,r11[0x10]
8000e736:	74 42       	ld.w	r2,r10[0x10]
8000e738:	76 1b       	ld.w	r11,r11[0x4]
8000e73a:	e4 03 00 07 	add	r7,r2,r3
8000e73e:	10 37       	cp.w	r7,r8
8000e740:	f7 bb 09 ff 	subgt	r11,-1
8000e744:	cb 6e       	rcall	8000e4b0 <_Balloc>
8000e746:	ee c4 ff fb 	sub	r4,r7,-5
8000e74a:	f8 c9 ff ec 	sub	r9,r12,-20
8000e74e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e752:	30 0a       	mov	r10,0
8000e754:	12 98       	mov	r8,r9
8000e756:	c0 28       	rjmp	8000e75a <__multiply+0x42>
8000e758:	10 aa       	st.w	r8++,r10
8000e75a:	08 38       	cp.w	r8,r4
8000e75c:	cf e3       	brcs	8000e758 <__multiply+0x40>
8000e75e:	2f b3       	sub	r3,-5
8000e760:	2f b2       	sub	r2,-5
8000e762:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000e766:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000e76a:	ec cb ff ec 	sub	r11,r6,-20
8000e76e:	50 12       	stdsp	sp[0x4],r2
8000e770:	ea ca ff ec 	sub	r10,r5,-20
8000e774:	c4 48       	rjmp	8000e7fc <__multiply+0xe4>
8000e776:	94 95       	ld.uh	r5,r10[0x2]
8000e778:	58 05       	cp.w	r5,0
8000e77a:	c2 00       	breq	8000e7ba <__multiply+0xa2>
8000e77c:	12 98       	mov	r8,r9
8000e77e:	16 96       	mov	r6,r11
8000e780:	30 0e       	mov	lr,0
8000e782:	50 09       	stdsp	sp[0x0],r9
8000e784:	0d 02       	ld.w	r2,r6++
8000e786:	e4 00 16 10 	lsr	r0,r2,0x10
8000e78a:	70 01       	ld.w	r1,r8[0x0]
8000e78c:	70 09       	ld.w	r9,r8[0x0]
8000e78e:	b1 81       	lsr	r1,0x10
8000e790:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000e794:	e0 05 03 41 	mac	r1,r0,r5
8000e798:	ab 32       	mul	r2,r5
8000e79a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000e79e:	00 02       	add	r2,r0
8000e7a0:	e4 0e 00 0e 	add	lr,r2,lr
8000e7a4:	b0 1e       	st.h	r8[0x2],lr
8000e7a6:	b1 8e       	lsr	lr,0x10
8000e7a8:	1c 01       	add	r1,lr
8000e7aa:	b0 01       	st.h	r8[0x0],r1
8000e7ac:	e2 0e 16 10 	lsr	lr,r1,0x10
8000e7b0:	2f c8       	sub	r8,-4
8000e7b2:	06 36       	cp.w	r6,r3
8000e7b4:	ce 83       	brcs	8000e784 <__multiply+0x6c>
8000e7b6:	40 09       	lddsp	r9,sp[0x0]
8000e7b8:	91 0e       	st.w	r8[0x0],lr
8000e7ba:	94 86       	ld.uh	r6,r10[0x0]
8000e7bc:	58 06       	cp.w	r6,0
8000e7be:	c1 d0       	breq	8000e7f8 <__multiply+0xe0>
8000e7c0:	72 02       	ld.w	r2,r9[0x0]
8000e7c2:	12 98       	mov	r8,r9
8000e7c4:	16 9e       	mov	lr,r11
8000e7c6:	30 05       	mov	r5,0
8000e7c8:	b0 12       	st.h	r8[0x2],r2
8000e7ca:	1d 01       	ld.w	r1,lr++
8000e7cc:	90 82       	ld.uh	r2,r8[0x0]
8000e7ce:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000e7d2:	ad 30       	mul	r0,r6
8000e7d4:	e0 02 00 02 	add	r2,r0,r2
8000e7d8:	e4 05 00 05 	add	r5,r2,r5
8000e7dc:	b0 05       	st.h	r8[0x0],r5
8000e7de:	b1 85       	lsr	r5,0x10
8000e7e0:	b1 81       	lsr	r1,0x10
8000e7e2:	2f c8       	sub	r8,-4
8000e7e4:	ad 31       	mul	r1,r6
8000e7e6:	90 92       	ld.uh	r2,r8[0x2]
8000e7e8:	e2 02 00 02 	add	r2,r1,r2
8000e7ec:	0a 02       	add	r2,r5
8000e7ee:	e4 05 16 10 	lsr	r5,r2,0x10
8000e7f2:	06 3e       	cp.w	lr,r3
8000e7f4:	ce a3       	brcs	8000e7c8 <__multiply+0xb0>
8000e7f6:	91 02       	st.w	r8[0x0],r2
8000e7f8:	2f ca       	sub	r10,-4
8000e7fa:	2f c9       	sub	r9,-4
8000e7fc:	40 18       	lddsp	r8,sp[0x4]
8000e7fe:	10 3a       	cp.w	r10,r8
8000e800:	cb b3       	brcs	8000e776 <__multiply+0x5e>
8000e802:	c0 28       	rjmp	8000e806 <__multiply+0xee>
8000e804:	20 17       	sub	r7,1
8000e806:	58 07       	cp.w	r7,0
8000e808:	e0 8a 00 05 	brle	8000e812 <__multiply+0xfa>
8000e80c:	09 48       	ld.w	r8,--r4
8000e80e:	58 08       	cp.w	r8,0
8000e810:	cf a0       	breq	8000e804 <__multiply+0xec>
8000e812:	99 47       	st.w	r12[0x10],r7
8000e814:	2f ed       	sub	sp,-8
8000e816:	d8 32       	popm	r0-r7,pc

8000e818 <__i2b>:
8000e818:	d4 21       	pushm	r4-r7,lr
8000e81a:	16 97       	mov	r7,r11
8000e81c:	30 1b       	mov	r11,1
8000e81e:	c4 9e       	rcall	8000e4b0 <_Balloc>
8000e820:	30 19       	mov	r9,1
8000e822:	99 57       	st.w	r12[0x14],r7
8000e824:	99 49       	st.w	r12[0x10],r9
8000e826:	d8 22       	popm	r4-r7,pc

8000e828 <__multadd>:
8000e828:	d4 31       	pushm	r0-r7,lr
8000e82a:	30 08       	mov	r8,0
8000e82c:	12 95       	mov	r5,r9
8000e82e:	16 97       	mov	r7,r11
8000e830:	18 96       	mov	r6,r12
8000e832:	76 44       	ld.w	r4,r11[0x10]
8000e834:	f6 c9 ff ec 	sub	r9,r11,-20
8000e838:	72 0b       	ld.w	r11,r9[0x0]
8000e83a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000e83e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e842:	f4 0c 02 4c 	mul	r12,r10,r12
8000e846:	f4 0b 03 45 	mac	r5,r10,r11
8000e84a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000e84e:	b1 85       	lsr	r5,0x10
8000e850:	18 05       	add	r5,r12
8000e852:	ea 0c 15 10 	lsl	r12,r5,0x10
8000e856:	f8 0b 00 0b 	add	r11,r12,r11
8000e85a:	12 ab       	st.w	r9++,r11
8000e85c:	2f f8       	sub	r8,-1
8000e85e:	b1 85       	lsr	r5,0x10
8000e860:	08 38       	cp.w	r8,r4
8000e862:	ce b5       	brlt	8000e838 <__multadd+0x10>
8000e864:	58 05       	cp.w	r5,0
8000e866:	c1 c0       	breq	8000e89e <__multadd+0x76>
8000e868:	6e 28       	ld.w	r8,r7[0x8]
8000e86a:	10 34       	cp.w	r4,r8
8000e86c:	c1 35       	brlt	8000e892 <__multadd+0x6a>
8000e86e:	6e 1b       	ld.w	r11,r7[0x4]
8000e870:	0c 9c       	mov	r12,r6
8000e872:	2f fb       	sub	r11,-1
8000e874:	c1 ee       	rcall	8000e4b0 <_Balloc>
8000e876:	6e 4a       	ld.w	r10,r7[0x10]
8000e878:	ee cb ff f4 	sub	r11,r7,-12
8000e87c:	18 93       	mov	r3,r12
8000e87e:	2f ea       	sub	r10,-2
8000e880:	2f 4c       	sub	r12,-12
8000e882:	a3 6a       	lsl	r10,0x2
8000e884:	fe b0 dd cb 	rcall	8000a41a <memcpy>
8000e888:	0e 9b       	mov	r11,r7
8000e88a:	0c 9c       	mov	r12,r6
8000e88c:	fe b0 fd f8 	rcall	8000e47c <_Bfree>
8000e890:	06 97       	mov	r7,r3
8000e892:	e8 c8 ff ff 	sub	r8,r4,-1
8000e896:	2f b4       	sub	r4,-5
8000e898:	8f 48       	st.w	r7[0x10],r8
8000e89a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000e89e:	0e 9c       	mov	r12,r7
8000e8a0:	d8 32       	popm	r0-r7,pc
8000e8a2:	d7 03       	nop

8000e8a4 <__pow5mult>:
8000e8a4:	d4 31       	pushm	r0-r7,lr
8000e8a6:	14 96       	mov	r6,r10
8000e8a8:	18 97       	mov	r7,r12
8000e8aa:	16 94       	mov	r4,r11
8000e8ac:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000e8b0:	c0 80       	breq	8000e8c0 <__pow5mult+0x1c>
8000e8b2:	20 18       	sub	r8,1
8000e8b4:	49 f9       	lddpc	r9,8000e930 <__pow5mult+0x8c>
8000e8b6:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000e8ba:	30 09       	mov	r9,0
8000e8bc:	cb 6f       	rcall	8000e828 <__multadd>
8000e8be:	18 94       	mov	r4,r12
8000e8c0:	a3 46       	asr	r6,0x2
8000e8c2:	c3 40       	breq	8000e92a <__pow5mult+0x86>
8000e8c4:	6e 95       	ld.w	r5,r7[0x24]
8000e8c6:	58 05       	cp.w	r5,0
8000e8c8:	c0 91       	brne	8000e8da <__pow5mult+0x36>
8000e8ca:	31 0c       	mov	r12,16
8000e8cc:	fe b0 db 70 	rcall	80009fac <malloc>
8000e8d0:	99 35       	st.w	r12[0xc],r5
8000e8d2:	8f 9c       	st.w	r7[0x24],r12
8000e8d4:	99 15       	st.w	r12[0x4],r5
8000e8d6:	99 25       	st.w	r12[0x8],r5
8000e8d8:	99 05       	st.w	r12[0x0],r5
8000e8da:	6e 93       	ld.w	r3,r7[0x24]
8000e8dc:	66 25       	ld.w	r5,r3[0x8]
8000e8de:	58 05       	cp.w	r5,0
8000e8e0:	c0 c1       	brne	8000e8f8 <__pow5mult+0x54>
8000e8e2:	e0 6b 02 71 	mov	r11,625
8000e8e6:	0e 9c       	mov	r12,r7
8000e8e8:	c9 8f       	rcall	8000e818 <__i2b>
8000e8ea:	87 2c       	st.w	r3[0x8],r12
8000e8ec:	30 08       	mov	r8,0
8000e8ee:	18 95       	mov	r5,r12
8000e8f0:	99 08       	st.w	r12[0x0],r8
8000e8f2:	c0 38       	rjmp	8000e8f8 <__pow5mult+0x54>
8000e8f4:	06 9c       	mov	r12,r3
8000e8f6:	18 95       	mov	r5,r12
8000e8f8:	ed b6 00 00 	bld	r6,0x0
8000e8fc:	c0 b1       	brne	8000e912 <__pow5mult+0x6e>
8000e8fe:	08 9b       	mov	r11,r4
8000e900:	0a 9a       	mov	r10,r5
8000e902:	0e 9c       	mov	r12,r7
8000e904:	c0 af       	rcall	8000e718 <__multiply>
8000e906:	08 9b       	mov	r11,r4
8000e908:	18 93       	mov	r3,r12
8000e90a:	0e 9c       	mov	r12,r7
8000e90c:	06 94       	mov	r4,r3
8000e90e:	fe b0 fd b7 	rcall	8000e47c <_Bfree>
8000e912:	a1 56       	asr	r6,0x1
8000e914:	c0 b0       	breq	8000e92a <__pow5mult+0x86>
8000e916:	6a 03       	ld.w	r3,r5[0x0]
8000e918:	58 03       	cp.w	r3,0
8000e91a:	ce d1       	brne	8000e8f4 <__pow5mult+0x50>
8000e91c:	0a 9a       	mov	r10,r5
8000e91e:	0a 9b       	mov	r11,r5
8000e920:	0e 9c       	mov	r12,r7
8000e922:	cf be       	rcall	8000e718 <__multiply>
8000e924:	8b 0c       	st.w	r5[0x0],r12
8000e926:	99 03       	st.w	r12[0x0],r3
8000e928:	ce 7b       	rjmp	8000e8f6 <__pow5mult+0x52>
8000e92a:	08 9c       	mov	r12,r4
8000e92c:	d8 32       	popm	r0-r7,pc
8000e92e:	d7 03       	nop
8000e930:	80 01       	ld.sh	r1,r0[0x0]
8000e932:	91 74       	st.w	r8[0x1c],r4

8000e934 <__isinfd>:
8000e934:	14 98       	mov	r8,r10
8000e936:	fc 19 7f f0 	movh	r9,0x7ff0
8000e93a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e93e:	f0 0b 11 00 	rsub	r11,r8,0
8000e942:	f7 e8 10 08 	or	r8,r11,r8
8000e946:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000e94a:	f2 08 01 08 	sub	r8,r9,r8
8000e94e:	f0 0c 11 00 	rsub	r12,r8,0
8000e952:	f9 e8 10 08 	or	r8,r12,r8
8000e956:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000e95a:	2f fc       	sub	r12,-1
8000e95c:	5e fc       	retal	r12

8000e95e <__isnand>:
8000e95e:	14 98       	mov	r8,r10
8000e960:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e964:	f0 0c 11 00 	rsub	r12,r8,0
8000e968:	10 4c       	or	r12,r8
8000e96a:	fc 18 7f f0 	movh	r8,0x7ff0
8000e96e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000e972:	f0 0c 01 0c 	sub	r12,r8,r12
8000e976:	bf 9c       	lsr	r12,0x1f
8000e978:	5e fc       	retal	r12
8000e97a:	d7 03       	nop

8000e97c <__sclose>:
8000e97c:	d4 01       	pushm	lr
8000e97e:	96 7b       	ld.sh	r11,r11[0xe]
8000e980:	c7 6c       	rcall	8000ea6c <_close_r>
8000e982:	d8 02       	popm	pc

8000e984 <__sseek>:
8000e984:	d4 21       	pushm	r4-r7,lr
8000e986:	16 97       	mov	r7,r11
8000e988:	96 7b       	ld.sh	r11,r11[0xe]
8000e98a:	cf 9c       	rcall	8000eb7c <_lseek_r>
8000e98c:	8e 68       	ld.sh	r8,r7[0xc]
8000e98e:	10 99       	mov	r9,r8
8000e990:	ad c8       	cbr	r8,0xc
8000e992:	ad a9       	sbr	r9,0xc
8000e994:	5b fc       	cp.w	r12,-1
8000e996:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000e99a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000e99e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000e9a2:	d8 22       	popm	r4-r7,pc

8000e9a4 <__swrite>:
8000e9a4:	d4 21       	pushm	r4-r7,lr
8000e9a6:	96 68       	ld.sh	r8,r11[0xc]
8000e9a8:	16 97       	mov	r7,r11
8000e9aa:	14 95       	mov	r5,r10
8000e9ac:	12 94       	mov	r4,r9
8000e9ae:	e2 18 01 00 	andl	r8,0x100,COH
8000e9b2:	18 96       	mov	r6,r12
8000e9b4:	c0 50       	breq	8000e9be <__swrite+0x1a>
8000e9b6:	30 29       	mov	r9,2
8000e9b8:	30 0a       	mov	r10,0
8000e9ba:	96 7b       	ld.sh	r11,r11[0xe]
8000e9bc:	ce 0c       	rcall	8000eb7c <_lseek_r>
8000e9be:	8e 68       	ld.sh	r8,r7[0xc]
8000e9c0:	ad c8       	cbr	r8,0xc
8000e9c2:	08 99       	mov	r9,r4
8000e9c4:	0a 9a       	mov	r10,r5
8000e9c6:	8e 7b       	ld.sh	r11,r7[0xe]
8000e9c8:	0c 9c       	mov	r12,r6
8000e9ca:	ae 68       	st.h	r7[0xc],r8
8000e9cc:	c1 0c       	rcall	8000e9ec <_write_r>
8000e9ce:	d8 22       	popm	r4-r7,pc

8000e9d0 <__sread>:
8000e9d0:	d4 21       	pushm	r4-r7,lr
8000e9d2:	16 97       	mov	r7,r11
8000e9d4:	96 7b       	ld.sh	r11,r11[0xe]
8000e9d6:	ce 7c       	rcall	8000eba4 <_read_r>
8000e9d8:	c0 65       	brlt	8000e9e4 <__sread+0x14>
8000e9da:	6f 58       	ld.w	r8,r7[0x54]
8000e9dc:	18 08       	add	r8,r12
8000e9de:	ef 48 00 54 	st.w	r7[84],r8
8000e9e2:	d8 22       	popm	r4-r7,pc
8000e9e4:	8e 68       	ld.sh	r8,r7[0xc]
8000e9e6:	ad c8       	cbr	r8,0xc
8000e9e8:	ae 68       	st.h	r7[0xc],r8
8000e9ea:	d8 22       	popm	r4-r7,pc

8000e9ec <_write_r>:
8000e9ec:	d4 21       	pushm	r4-r7,lr
8000e9ee:	16 98       	mov	r8,r11
8000e9f0:	18 97       	mov	r7,r12
8000e9f2:	10 9c       	mov	r12,r8
8000e9f4:	30 08       	mov	r8,0
8000e9f6:	14 9b       	mov	r11,r10
8000e9f8:	e0 66 46 20 	mov	r6,17952
8000e9fc:	12 9a       	mov	r10,r9
8000e9fe:	8d 08       	st.w	r6[0x0],r8
8000ea00:	fe b0 d0 56 	rcall	80008aac <_write>
8000ea04:	5b fc       	cp.w	r12,-1
8000ea06:	c0 51       	brne	8000ea10 <_write_r+0x24>
8000ea08:	6c 08       	ld.w	r8,r6[0x0]
8000ea0a:	58 08       	cp.w	r8,0
8000ea0c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ea10:	d8 22       	popm	r4-r7,pc
8000ea12:	d7 03       	nop

8000ea14 <_calloc_r>:
8000ea14:	d4 21       	pushm	r4-r7,lr
8000ea16:	f4 0b 02 4b 	mul	r11,r10,r11
8000ea1a:	fe b0 da d1 	rcall	80009fbc <_malloc_r>
8000ea1e:	18 97       	mov	r7,r12
8000ea20:	c2 30       	breq	8000ea66 <_calloc_r+0x52>
8000ea22:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ea26:	e0 1a ff fc 	andl	r10,0xfffc
8000ea2a:	20 4a       	sub	r10,4
8000ea2c:	e0 4a 00 24 	cp.w	r10,36
8000ea30:	e0 8b 00 18 	brhi	8000ea60 <_calloc_r+0x4c>
8000ea34:	18 98       	mov	r8,r12
8000ea36:	59 3a       	cp.w	r10,19
8000ea38:	e0 88 00 0f 	brls	8000ea56 <_calloc_r+0x42>
8000ea3c:	30 09       	mov	r9,0
8000ea3e:	10 a9       	st.w	r8++,r9
8000ea40:	10 a9       	st.w	r8++,r9
8000ea42:	59 ba       	cp.w	r10,27
8000ea44:	e0 88 00 09 	brls	8000ea56 <_calloc_r+0x42>
8000ea48:	10 a9       	st.w	r8++,r9
8000ea4a:	10 a9       	st.w	r8++,r9
8000ea4c:	e0 4a 00 24 	cp.w	r10,36
8000ea50:	c0 31       	brne	8000ea56 <_calloc_r+0x42>
8000ea52:	10 a9       	st.w	r8++,r9
8000ea54:	10 a9       	st.w	r8++,r9
8000ea56:	30 09       	mov	r9,0
8000ea58:	10 a9       	st.w	r8++,r9
8000ea5a:	91 19       	st.w	r8[0x4],r9
8000ea5c:	91 09       	st.w	r8[0x0],r9
8000ea5e:	c0 48       	rjmp	8000ea66 <_calloc_r+0x52>
8000ea60:	30 0b       	mov	r11,0
8000ea62:	fe b0 dd 80 	rcall	8000a562 <memset>
8000ea66:	0e 9c       	mov	r12,r7
8000ea68:	d8 22       	popm	r4-r7,pc
8000ea6a:	d7 03       	nop

8000ea6c <_close_r>:
8000ea6c:	d4 21       	pushm	r4-r7,lr
8000ea6e:	30 08       	mov	r8,0
8000ea70:	18 97       	mov	r7,r12
8000ea72:	e0 66 46 20 	mov	r6,17952
8000ea76:	16 9c       	mov	r12,r11
8000ea78:	8d 08       	st.w	r6[0x0],r8
8000ea7a:	fe b0 df a5 	rcall	8000a9c4 <_close>
8000ea7e:	5b fc       	cp.w	r12,-1
8000ea80:	c0 51       	brne	8000ea8a <_close_r+0x1e>
8000ea82:	6c 08       	ld.w	r8,r6[0x0]
8000ea84:	58 08       	cp.w	r8,0
8000ea86:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ea8a:	d8 22       	popm	r4-r7,pc

8000ea8c <_fclose_r>:
8000ea8c:	d4 21       	pushm	r4-r7,lr
8000ea8e:	18 96       	mov	r6,r12
8000ea90:	16 97       	mov	r7,r11
8000ea92:	58 0b       	cp.w	r11,0
8000ea94:	c0 31       	brne	8000ea9a <_fclose_r+0xe>
8000ea96:	16 95       	mov	r5,r11
8000ea98:	c5 08       	rjmp	8000eb38 <_fclose_r+0xac>
8000ea9a:	fe b0 f8 b1 	rcall	8000dbfc <__sfp_lock_acquire>
8000ea9e:	58 06       	cp.w	r6,0
8000eaa0:	c0 70       	breq	8000eaae <_fclose_r+0x22>
8000eaa2:	6c 68       	ld.w	r8,r6[0x18]
8000eaa4:	58 08       	cp.w	r8,0
8000eaa6:	c0 41       	brne	8000eaae <_fclose_r+0x22>
8000eaa8:	0c 9c       	mov	r12,r6
8000eaaa:	fe b0 f8 fd 	rcall	8000dca4 <__sinit>
8000eaae:	4a 48       	lddpc	r8,8000eb3c <_fclose_r+0xb0>
8000eab0:	10 37       	cp.w	r7,r8
8000eab2:	c0 31       	brne	8000eab8 <_fclose_r+0x2c>
8000eab4:	6c 07       	ld.w	r7,r6[0x0]
8000eab6:	c0 a8       	rjmp	8000eaca <_fclose_r+0x3e>
8000eab8:	4a 28       	lddpc	r8,8000eb40 <_fclose_r+0xb4>
8000eaba:	10 37       	cp.w	r7,r8
8000eabc:	c0 31       	brne	8000eac2 <_fclose_r+0x36>
8000eabe:	6c 17       	ld.w	r7,r6[0x4]
8000eac0:	c0 58       	rjmp	8000eaca <_fclose_r+0x3e>
8000eac2:	4a 18       	lddpc	r8,8000eb44 <_fclose_r+0xb8>
8000eac4:	10 37       	cp.w	r7,r8
8000eac6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000eaca:	8e 69       	ld.sh	r9,r7[0xc]
8000eacc:	30 08       	mov	r8,0
8000eace:	f0 09 19 00 	cp.h	r9,r8
8000ead2:	c0 51       	brne	8000eadc <_fclose_r+0x50>
8000ead4:	fe b0 f8 95 	rcall	8000dbfe <__sfp_lock_release>
8000ead8:	30 05       	mov	r5,0
8000eada:	c2 f8       	rjmp	8000eb38 <_fclose_r+0xac>
8000eadc:	0e 9b       	mov	r11,r7
8000eade:	0c 9c       	mov	r12,r6
8000eae0:	fe b0 f8 06 	rcall	8000daec <_fflush_r>
8000eae4:	6e c8       	ld.w	r8,r7[0x30]
8000eae6:	18 95       	mov	r5,r12
8000eae8:	58 08       	cp.w	r8,0
8000eaea:	c0 60       	breq	8000eaf6 <_fclose_r+0x6a>
8000eaec:	6e 8b       	ld.w	r11,r7[0x20]
8000eaee:	0c 9c       	mov	r12,r6
8000eaf0:	5d 18       	icall	r8
8000eaf2:	f9 b5 05 ff 	movlt	r5,-1
8000eaf6:	8e 68       	ld.sh	r8,r7[0xc]
8000eaf8:	ed b8 00 07 	bld	r8,0x7
8000eafc:	c0 51       	brne	8000eb06 <_fclose_r+0x7a>
8000eafe:	6e 4b       	ld.w	r11,r7[0x10]
8000eb00:	0c 9c       	mov	r12,r6
8000eb02:	fe b0 f9 6b 	rcall	8000ddd8 <_free_r>
8000eb06:	6e db       	ld.w	r11,r7[0x34]
8000eb08:	58 0b       	cp.w	r11,0
8000eb0a:	c0 a0       	breq	8000eb1e <_fclose_r+0x92>
8000eb0c:	ee c8 ff bc 	sub	r8,r7,-68
8000eb10:	10 3b       	cp.w	r11,r8
8000eb12:	c0 40       	breq	8000eb1a <_fclose_r+0x8e>
8000eb14:	0c 9c       	mov	r12,r6
8000eb16:	fe b0 f9 61 	rcall	8000ddd8 <_free_r>
8000eb1a:	30 08       	mov	r8,0
8000eb1c:	8f d8       	st.w	r7[0x34],r8
8000eb1e:	6f 2b       	ld.w	r11,r7[0x48]
8000eb20:	58 0b       	cp.w	r11,0
8000eb22:	c0 70       	breq	8000eb30 <_fclose_r+0xa4>
8000eb24:	0c 9c       	mov	r12,r6
8000eb26:	fe b0 f9 59 	rcall	8000ddd8 <_free_r>
8000eb2a:	30 08       	mov	r8,0
8000eb2c:	ef 48 00 48 	st.w	r7[72],r8
8000eb30:	30 08       	mov	r8,0
8000eb32:	ae 68       	st.h	r7[0xc],r8
8000eb34:	fe b0 f8 65 	rcall	8000dbfe <__sfp_lock_release>
8000eb38:	0a 9c       	mov	r12,r5
8000eb3a:	d8 22       	popm	r4-r7,pc
8000eb3c:	80 01       	ld.sh	r1,r0[0x0]
8000eb3e:	90 d0       	ld.uh	r0,r8[0xa]
8000eb40:	80 01       	ld.sh	r1,r0[0x0]
8000eb42:	90 f0       	ld.uh	r0,r8[0xe]
8000eb44:	80 01       	ld.sh	r1,r0[0x0]
8000eb46:	91 10       	st.w	r8[0x4],r0

8000eb48 <fclose>:
8000eb48:	d4 01       	pushm	lr
8000eb4a:	e0 68 0a 38 	mov	r8,2616
8000eb4e:	18 9b       	mov	r11,r12
8000eb50:	70 0c       	ld.w	r12,r8[0x0]
8000eb52:	c9 df       	rcall	8000ea8c <_fclose_r>
8000eb54:	d8 02       	popm	pc
8000eb56:	d7 03       	nop

8000eb58 <_fstat_r>:
8000eb58:	d4 21       	pushm	r4-r7,lr
8000eb5a:	16 98       	mov	r8,r11
8000eb5c:	18 97       	mov	r7,r12
8000eb5e:	10 9c       	mov	r12,r8
8000eb60:	30 08       	mov	r8,0
8000eb62:	e0 66 46 20 	mov	r6,17952
8000eb66:	14 9b       	mov	r11,r10
8000eb68:	8d 08       	st.w	r6[0x0],r8
8000eb6a:	fe b0 df 55 	rcall	8000aa14 <_fstat>
8000eb6e:	5b fc       	cp.w	r12,-1
8000eb70:	c0 51       	brne	8000eb7a <_fstat_r+0x22>
8000eb72:	6c 08       	ld.w	r8,r6[0x0]
8000eb74:	58 08       	cp.w	r8,0
8000eb76:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eb7a:	d8 22       	popm	r4-r7,pc

8000eb7c <_lseek_r>:
8000eb7c:	d4 21       	pushm	r4-r7,lr
8000eb7e:	16 98       	mov	r8,r11
8000eb80:	18 97       	mov	r7,r12
8000eb82:	10 9c       	mov	r12,r8
8000eb84:	30 08       	mov	r8,0
8000eb86:	14 9b       	mov	r11,r10
8000eb88:	e0 66 46 20 	mov	r6,17952
8000eb8c:	12 9a       	mov	r10,r9
8000eb8e:	8d 08       	st.w	r6[0x0],r8
8000eb90:	fe b0 df 24 	rcall	8000a9d8 <_lseek>
8000eb94:	5b fc       	cp.w	r12,-1
8000eb96:	c0 51       	brne	8000eba0 <_lseek_r+0x24>
8000eb98:	6c 08       	ld.w	r8,r6[0x0]
8000eb9a:	58 08       	cp.w	r8,0
8000eb9c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eba0:	d8 22       	popm	r4-r7,pc
8000eba2:	d7 03       	nop

8000eba4 <_read_r>:
8000eba4:	d4 21       	pushm	r4-r7,lr
8000eba6:	16 98       	mov	r8,r11
8000eba8:	18 97       	mov	r7,r12
8000ebaa:	10 9c       	mov	r12,r8
8000ebac:	30 08       	mov	r8,0
8000ebae:	14 9b       	mov	r11,r10
8000ebb0:	e0 66 46 20 	mov	r6,17952
8000ebb4:	12 9a       	mov	r10,r9
8000ebb6:	8d 08       	st.w	r6[0x0],r8
8000ebb8:	fe b0 cf 5a 	rcall	80008a6c <_read>
8000ebbc:	5b fc       	cp.w	r12,-1
8000ebbe:	c0 51       	brne	8000ebc8 <_read_r+0x24>
8000ebc0:	6c 08       	ld.w	r8,r6[0x0]
8000ebc2:	58 08       	cp.w	r8,0
8000ebc4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ebc8:	d8 22       	popm	r4-r7,pc
8000ebca:	d7 03       	nop

8000ebcc <__avr32_f64_mul>:
8000ebcc:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ebd0:	e0 80 00 dc 	breq	8000ed88 <__avr32_f64_mul_op1_zero>
8000ebd4:	d4 21       	pushm	r4-r7,lr
8000ebd6:	f7 e9 20 0e 	eor	lr,r11,r9
8000ebda:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ebde:	30 15       	mov	r5,1
8000ebe0:	c4 30       	breq	8000ec66 <__avr32_f64_mul_op1_subnormal>
8000ebe2:	ab 6b       	lsl	r11,0xa
8000ebe4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ebe8:	ab 6a       	lsl	r10,0xa
8000ebea:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ebee:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ebf2:	c5 c0       	breq	8000ecaa <__avr32_f64_mul_op2_subnormal>
8000ebf4:	a1 78       	lsl	r8,0x1
8000ebf6:	5c f9       	rol	r9
8000ebf8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ebfc:	e0 47 07 ff 	cp.w	r7,2047
8000ec00:	c7 70       	breq	8000ecee <__avr32_f64_mul_op_nan_or_inf>
8000ec02:	e0 46 07 ff 	cp.w	r6,2047
8000ec06:	c7 40       	breq	8000ecee <__avr32_f64_mul_op_nan_or_inf>
8000ec08:	ee 06 00 0c 	add	r12,r7,r6
8000ec0c:	e0 2c 03 fe 	sub	r12,1022
8000ec10:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ec14:	f4 09 07 44 	macu.d	r4,r10,r9
8000ec18:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ec1c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ec20:	08 07       	add	r7,r4
8000ec22:	f4 05 00 4a 	adc	r10,r10,r5
8000ec26:	5c 0b       	acr	r11
8000ec28:	ed bb 00 14 	bld	r11,0x14
8000ec2c:	c0 50       	breq	8000ec36 <__avr32_f64_mul+0x6a>
8000ec2e:	a1 77       	lsl	r7,0x1
8000ec30:	5c fa       	rol	r10
8000ec32:	5c fb       	rol	r11
8000ec34:	20 1c       	sub	r12,1
8000ec36:	58 0c       	cp.w	r12,0
8000ec38:	e0 8a 00 6f 	brle	8000ed16 <__avr32_f64_mul_res_subnormal>
8000ec3c:	e0 4c 07 ff 	cp.w	r12,2047
8000ec40:	e0 84 00 9c 	brge	8000ed78 <__avr32_f64_mul_res_inf>
8000ec44:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ec48:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ec4c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ec50:	ee 17 80 00 	eorh	r7,0x8000
8000ec54:	f1 b7 04 20 	satu	r7,0x1
8000ec58:	0e 0a       	add	r10,r7
8000ec5a:	5c 0b       	acr	r11
8000ec5c:	ed be 00 1f 	bld	lr,0x1f
8000ec60:	ef bb 00 1f 	bst	r11,0x1f
8000ec64:	d8 22       	popm	r4-r7,pc

8000ec66 <__avr32_f64_mul_op1_subnormal>:
8000ec66:	e4 1b 00 0f 	andh	r11,0xf
8000ec6a:	f4 0c 12 00 	clz	r12,r10
8000ec6e:	f6 06 12 00 	clz	r6,r11
8000ec72:	f7 bc 03 e1 	sublo	r12,-31
8000ec76:	f8 06 17 30 	movlo	r6,r12
8000ec7a:	f7 b6 02 01 	subhs	r6,1
8000ec7e:	e0 46 00 20 	cp.w	r6,32
8000ec82:	c0 d4       	brge	8000ec9c <__avr32_f64_mul_op1_subnormal+0x36>
8000ec84:	ec 0c 11 20 	rsub	r12,r6,32
8000ec88:	f6 06 09 4b 	lsl	r11,r11,r6
8000ec8c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ec90:	18 4b       	or	r11,r12
8000ec92:	f4 06 09 4a 	lsl	r10,r10,r6
8000ec96:	20 b6       	sub	r6,11
8000ec98:	0c 17       	sub	r7,r6
8000ec9a:	ca ab       	rjmp	8000ebee <__avr32_f64_mul+0x22>
8000ec9c:	f4 06 09 4b 	lsl	r11,r10,r6
8000eca0:	c6 40       	breq	8000ed68 <__avr32_f64_mul_res_zero>
8000eca2:	30 0a       	mov	r10,0
8000eca4:	20 b6       	sub	r6,11
8000eca6:	0c 17       	sub	r7,r6
8000eca8:	ca 3b       	rjmp	8000ebee <__avr32_f64_mul+0x22>

8000ecaa <__avr32_f64_mul_op2_subnormal>:
8000ecaa:	e4 19 00 0f 	andh	r9,0xf
8000ecae:	f0 0c 12 00 	clz	r12,r8
8000ecb2:	f2 05 12 00 	clz	r5,r9
8000ecb6:	f7 bc 03 ea 	sublo	r12,-22
8000ecba:	f8 05 17 30 	movlo	r5,r12
8000ecbe:	f7 b5 02 0a 	subhs	r5,10
8000ecc2:	e0 45 00 20 	cp.w	r5,32
8000ecc6:	c0 d4       	brge	8000ece0 <__avr32_f64_mul_op2_subnormal+0x36>
8000ecc8:	ea 0c 11 20 	rsub	r12,r5,32
8000eccc:	f2 05 09 49 	lsl	r9,r9,r5
8000ecd0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ecd4:	18 49       	or	r9,r12
8000ecd6:	f0 05 09 48 	lsl	r8,r8,r5
8000ecda:	20 25       	sub	r5,2
8000ecdc:	0a 16       	sub	r6,r5
8000ecde:	c8 fb       	rjmp	8000ebfc <__avr32_f64_mul+0x30>
8000ece0:	f0 05 09 49 	lsl	r9,r8,r5
8000ece4:	c4 20       	breq	8000ed68 <__avr32_f64_mul_res_zero>
8000ece6:	30 08       	mov	r8,0
8000ece8:	20 25       	sub	r5,2
8000ecea:	0a 16       	sub	r6,r5
8000ecec:	c8 8b       	rjmp	8000ebfc <__avr32_f64_mul+0x30>

8000ecee <__avr32_f64_mul_op_nan_or_inf>:
8000ecee:	e4 19 00 0f 	andh	r9,0xf
8000ecf2:	e4 1b 00 0f 	andh	r11,0xf
8000ecf6:	14 4b       	or	r11,r10
8000ecf8:	10 49       	or	r9,r8
8000ecfa:	e0 47 07 ff 	cp.w	r7,2047
8000ecfe:	c0 91       	brne	8000ed10 <__avr32_f64_mul_op1_not_naninf>
8000ed00:	58 0b       	cp.w	r11,0
8000ed02:	c3 81       	brne	8000ed72 <__avr32_f64_mul_res_nan>
8000ed04:	e0 46 07 ff 	cp.w	r6,2047
8000ed08:	c3 81       	brne	8000ed78 <__avr32_f64_mul_res_inf>
8000ed0a:	58 09       	cp.w	r9,0
8000ed0c:	c3 60       	breq	8000ed78 <__avr32_f64_mul_res_inf>
8000ed0e:	c3 28       	rjmp	8000ed72 <__avr32_f64_mul_res_nan>

8000ed10 <__avr32_f64_mul_op1_not_naninf>:
8000ed10:	58 09       	cp.w	r9,0
8000ed12:	c3 30       	breq	8000ed78 <__avr32_f64_mul_res_inf>
8000ed14:	c2 f8       	rjmp	8000ed72 <__avr32_f64_mul_res_nan>

8000ed16 <__avr32_f64_mul_res_subnormal>:
8000ed16:	5c 3c       	neg	r12
8000ed18:	2f fc       	sub	r12,-1
8000ed1a:	f1 bc 04 c0 	satu	r12,0x6
8000ed1e:	e0 4c 00 20 	cp.w	r12,32
8000ed22:	c1 14       	brge	8000ed44 <__avr32_f64_mul_res_subnormal+0x2e>
8000ed24:	f8 08 11 20 	rsub	r8,r12,32
8000ed28:	0e 46       	or	r6,r7
8000ed2a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ed2e:	f4 08 09 49 	lsl	r9,r10,r8
8000ed32:	12 47       	or	r7,r9
8000ed34:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ed38:	f6 08 09 49 	lsl	r9,r11,r8
8000ed3c:	12 4a       	or	r10,r9
8000ed3e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ed42:	c8 3b       	rjmp	8000ec48 <__avr32_f64_mul+0x7c>
8000ed44:	f8 08 11 20 	rsub	r8,r12,32
8000ed48:	f9 b9 00 00 	moveq	r9,0
8000ed4c:	c0 30       	breq	8000ed52 <__avr32_f64_mul_res_subnormal+0x3c>
8000ed4e:	f6 08 09 49 	lsl	r9,r11,r8
8000ed52:	0e 46       	or	r6,r7
8000ed54:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ed58:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ed5c:	f3 ea 10 07 	or	r7,r9,r10
8000ed60:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ed64:	30 0b       	mov	r11,0
8000ed66:	c7 1b       	rjmp	8000ec48 <__avr32_f64_mul+0x7c>

8000ed68 <__avr32_f64_mul_res_zero>:
8000ed68:	1c 9b       	mov	r11,lr
8000ed6a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ed6e:	30 0a       	mov	r10,0
8000ed70:	d8 22       	popm	r4-r7,pc

8000ed72 <__avr32_f64_mul_res_nan>:
8000ed72:	3f fb       	mov	r11,-1
8000ed74:	3f fa       	mov	r10,-1
8000ed76:	d8 22       	popm	r4-r7,pc

8000ed78 <__avr32_f64_mul_res_inf>:
8000ed78:	f0 6b 00 00 	mov	r11,-1048576
8000ed7c:	ed be 00 1f 	bld	lr,0x1f
8000ed80:	ef bb 00 1f 	bst	r11,0x1f
8000ed84:	30 0a       	mov	r10,0
8000ed86:	d8 22       	popm	r4-r7,pc

8000ed88 <__avr32_f64_mul_op1_zero>:
8000ed88:	f7 e9 20 0b 	eor	r11,r11,r9
8000ed8c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ed90:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ed94:	e0 4c 07 ff 	cp.w	r12,2047
8000ed98:	5e 1c       	retne	r12
8000ed9a:	3f fa       	mov	r10,-1
8000ed9c:	3f fb       	mov	r11,-1
8000ed9e:	5e fc       	retal	r12

8000eda0 <__avr32_f64_sub_from_add>:
8000eda0:	ee 19 80 00 	eorh	r9,0x8000

8000eda4 <__avr32_f64_sub>:
8000eda4:	f7 e9 20 0c 	eor	r12,r11,r9
8000eda8:	e0 86 00 ca 	brmi	8000ef3c <__avr32_f64_add_from_sub>
8000edac:	eb cd 40 e0 	pushm	r5-r7,lr
8000edb0:	16 9c       	mov	r12,r11
8000edb2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000edb6:	bf db       	cbr	r11,0x1f
8000edb8:	bf d9       	cbr	r9,0x1f
8000edba:	10 3a       	cp.w	r10,r8
8000edbc:	f2 0b 13 00 	cpc	r11,r9
8000edc0:	c0 92       	brcc	8000edd2 <__avr32_f64_sub+0x2e>
8000edc2:	16 97       	mov	r7,r11
8000edc4:	12 9b       	mov	r11,r9
8000edc6:	0e 99       	mov	r9,r7
8000edc8:	14 97       	mov	r7,r10
8000edca:	10 9a       	mov	r10,r8
8000edcc:	0e 98       	mov	r8,r7
8000edce:	ee 1c 80 00 	eorh	r12,0x8000
8000edd2:	f6 07 16 14 	lsr	r7,r11,0x14
8000edd6:	ab 7b       	lsl	r11,0xb
8000edd8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000eddc:	ab 7a       	lsl	r10,0xb
8000edde:	bf bb       	sbr	r11,0x1f
8000ede0:	f2 06 16 14 	lsr	r6,r9,0x14
8000ede4:	c4 40       	breq	8000ee6c <__avr32_f64_sub_opL_subnormal>
8000ede6:	ab 79       	lsl	r9,0xb
8000ede8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000edec:	ab 78       	lsl	r8,0xb
8000edee:	bf b9       	sbr	r9,0x1f

8000edf0 <__avr32_f64_sub_opL_subnormal_done>:
8000edf0:	e0 47 07 ff 	cp.w	r7,2047
8000edf4:	c4 f0       	breq	8000ee92 <__avr32_f64_sub_opH_nan_or_inf>
8000edf6:	0e 26       	rsub	r6,r7
8000edf8:	c1 20       	breq	8000ee1c <__avr32_f64_sub_shift_done>
8000edfa:	ec 05 11 20 	rsub	r5,r6,32
8000edfe:	e0 46 00 20 	cp.w	r6,32
8000ee02:	c7 c2       	brcc	8000eefa <__avr32_f64_sub_longshift>
8000ee04:	f0 05 09 4e 	lsl	lr,r8,r5
8000ee08:	f2 05 09 45 	lsl	r5,r9,r5
8000ee0c:	f0 06 0a 48 	lsr	r8,r8,r6
8000ee10:	f2 06 0a 49 	lsr	r9,r9,r6
8000ee14:	0a 48       	or	r8,r5
8000ee16:	58 0e       	cp.w	lr,0
8000ee18:	5f 1e       	srne	lr
8000ee1a:	1c 48       	or	r8,lr

8000ee1c <__avr32_f64_sub_shift_done>:
8000ee1c:	10 1a       	sub	r10,r8
8000ee1e:	f6 09 01 4b 	sbc	r11,r11,r9
8000ee22:	f6 06 12 00 	clz	r6,r11
8000ee26:	c0 e0       	breq	8000ee42 <__avr32_f64_sub_longnormalize_done>
8000ee28:	c7 83       	brcs	8000ef18 <__avr32_f64_sub_longnormalize>
8000ee2a:	ec 0e 11 20 	rsub	lr,r6,32
8000ee2e:	f6 06 09 4b 	lsl	r11,r11,r6
8000ee32:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ee36:	1c 4b       	or	r11,lr
8000ee38:	f4 06 09 4a 	lsl	r10,r10,r6
8000ee3c:	0c 17       	sub	r7,r6
8000ee3e:	e0 8a 00 39 	brle	8000eeb0 <__avr32_f64_sub_subnormal_result>

8000ee42 <__avr32_f64_sub_longnormalize_done>:
8000ee42:	f4 09 15 15 	lsl	r9,r10,0x15
8000ee46:	ab 9a       	lsr	r10,0xb
8000ee48:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ee4c:	ab 9b       	lsr	r11,0xb
8000ee4e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ee52:	18 4b       	or	r11,r12

8000ee54 <__avr32_f64_sub_round>:
8000ee54:	fc 17 80 00 	movh	r7,0x8000
8000ee58:	ed ba 00 00 	bld	r10,0x0
8000ee5c:	f7 b7 01 ff 	subne	r7,-1
8000ee60:	0e 39       	cp.w	r9,r7
8000ee62:	5f 29       	srhs	r9
8000ee64:	12 0a       	add	r10,r9
8000ee66:	5c 0b       	acr	r11
8000ee68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ee6c <__avr32_f64_sub_opL_subnormal>:
8000ee6c:	ab 79       	lsl	r9,0xb
8000ee6e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ee72:	ab 78       	lsl	r8,0xb
8000ee74:	f3 e8 10 0e 	or	lr,r9,r8
8000ee78:	f9 b6 01 01 	movne	r6,1
8000ee7c:	ee 0e 11 00 	rsub	lr,r7,0
8000ee80:	f9 b7 00 01 	moveq	r7,1
8000ee84:	ef bb 00 1f 	bst	r11,0x1f
8000ee88:	f7 ea 10 0e 	or	lr,r11,r10
8000ee8c:	f9 b7 00 00 	moveq	r7,0
8000ee90:	cb 0b       	rjmp	8000edf0 <__avr32_f64_sub_opL_subnormal_done>

8000ee92 <__avr32_f64_sub_opH_nan_or_inf>:
8000ee92:	bf db       	cbr	r11,0x1f
8000ee94:	f7 ea 10 0e 	or	lr,r11,r10
8000ee98:	c0 81       	brne	8000eea8 <__avr32_f64_sub_return_nan>
8000ee9a:	e0 46 07 ff 	cp.w	r6,2047
8000ee9e:	c0 50       	breq	8000eea8 <__avr32_f64_sub_return_nan>
8000eea0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000eea4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eea8 <__avr32_f64_sub_return_nan>:
8000eea8:	3f fa       	mov	r10,-1
8000eeaa:	3f fb       	mov	r11,-1
8000eeac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eeb0 <__avr32_f64_sub_subnormal_result>:
8000eeb0:	5c 37       	neg	r7
8000eeb2:	2f f7       	sub	r7,-1
8000eeb4:	f1 b7 04 c0 	satu	r7,0x6
8000eeb8:	e0 47 00 20 	cp.w	r7,32
8000eebc:	c1 14       	brge	8000eede <__avr32_f64_sub_subnormal_result+0x2e>
8000eebe:	ee 08 11 20 	rsub	r8,r7,32
8000eec2:	f4 08 09 49 	lsl	r9,r10,r8
8000eec6:	5f 16       	srne	r6
8000eec8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000eecc:	0c 4a       	or	r10,r6
8000eece:	f6 08 09 49 	lsl	r9,r11,r8
8000eed2:	f5 e9 10 0a 	or	r10,r10,r9
8000eed6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000eeda:	30 07       	mov	r7,0
8000eedc:	cb 3b       	rjmp	8000ee42 <__avr32_f64_sub_longnormalize_done>
8000eede:	ee 08 11 40 	rsub	r8,r7,64
8000eee2:	f6 08 09 49 	lsl	r9,r11,r8
8000eee6:	14 49       	or	r9,r10
8000eee8:	5f 16       	srne	r6
8000eeea:	f6 07 0a 4a 	lsr	r10,r11,r7
8000eeee:	0c 4a       	or	r10,r6
8000eef0:	30 0b       	mov	r11,0
8000eef2:	30 07       	mov	r7,0
8000eef4:	ca 7b       	rjmp	8000ee42 <__avr32_f64_sub_longnormalize_done>
8000eef6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eefa <__avr32_f64_sub_longshift>:
8000eefa:	f1 b6 04 c0 	satu	r6,0x6
8000eefe:	f0 0e 17 00 	moveq	lr,r8
8000ef02:	c0 40       	breq	8000ef0a <__avr32_f64_sub_longshift+0x10>
8000ef04:	f2 05 09 4e 	lsl	lr,r9,r5
8000ef08:	10 4e       	or	lr,r8
8000ef0a:	f2 06 0a 48 	lsr	r8,r9,r6
8000ef0e:	30 09       	mov	r9,0
8000ef10:	58 0e       	cp.w	lr,0
8000ef12:	5f 1e       	srne	lr
8000ef14:	1c 48       	or	r8,lr
8000ef16:	c8 3b       	rjmp	8000ee1c <__avr32_f64_sub_shift_done>

8000ef18 <__avr32_f64_sub_longnormalize>:
8000ef18:	f4 06 12 00 	clz	r6,r10
8000ef1c:	f9 b7 03 00 	movlo	r7,0
8000ef20:	f9 b6 03 00 	movlo	r6,0
8000ef24:	f9 bc 03 00 	movlo	r12,0
8000ef28:	f7 b6 02 e0 	subhs	r6,-32
8000ef2c:	f4 06 09 4b 	lsl	r11,r10,r6
8000ef30:	30 0a       	mov	r10,0
8000ef32:	0c 17       	sub	r7,r6
8000ef34:	fe 9a ff be 	brle	8000eeb0 <__avr32_f64_sub_subnormal_result>
8000ef38:	c8 5b       	rjmp	8000ee42 <__avr32_f64_sub_longnormalize_done>
8000ef3a:	d7 03       	nop

8000ef3c <__avr32_f64_add_from_sub>:
8000ef3c:	ee 19 80 00 	eorh	r9,0x8000

8000ef40 <__avr32_f64_add>:
8000ef40:	f7 e9 20 0c 	eor	r12,r11,r9
8000ef44:	fe 96 ff 2e 	brmi	8000eda0 <__avr32_f64_sub_from_add>
8000ef48:	eb cd 40 e0 	pushm	r5-r7,lr
8000ef4c:	16 9c       	mov	r12,r11
8000ef4e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ef52:	bf db       	cbr	r11,0x1f
8000ef54:	bf d9       	cbr	r9,0x1f
8000ef56:	12 3b       	cp.w	r11,r9
8000ef58:	c0 72       	brcc	8000ef66 <__avr32_f64_add+0x26>
8000ef5a:	16 97       	mov	r7,r11
8000ef5c:	12 9b       	mov	r11,r9
8000ef5e:	0e 99       	mov	r9,r7
8000ef60:	14 97       	mov	r7,r10
8000ef62:	10 9a       	mov	r10,r8
8000ef64:	0e 98       	mov	r8,r7
8000ef66:	30 0e       	mov	lr,0
8000ef68:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ef6c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ef70:	b5 ab       	sbr	r11,0x14
8000ef72:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ef76:	c6 20       	breq	8000f03a <__avr32_f64_add_op2_subnormal>
8000ef78:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ef7c:	b5 a9       	sbr	r9,0x14
8000ef7e:	e0 47 07 ff 	cp.w	r7,2047
8000ef82:	c2 80       	breq	8000efd2 <__avr32_f64_add_opH_nan_or_inf>
8000ef84:	0e 26       	rsub	r6,r7
8000ef86:	c1 20       	breq	8000efaa <__avr32_f64_add_shift_done>
8000ef88:	e0 46 00 36 	cp.w	r6,54
8000ef8c:	c1 52       	brcc	8000efb6 <__avr32_f64_add_res_of_done>
8000ef8e:	ec 05 11 20 	rsub	r5,r6,32
8000ef92:	e0 46 00 20 	cp.w	r6,32
8000ef96:	c3 52       	brcc	8000f000 <__avr32_f64_add_longshift>
8000ef98:	f0 05 09 4e 	lsl	lr,r8,r5
8000ef9c:	f2 05 09 45 	lsl	r5,r9,r5
8000efa0:	f0 06 0a 48 	lsr	r8,r8,r6
8000efa4:	f2 06 0a 49 	lsr	r9,r9,r6
8000efa8:	0a 48       	or	r8,r5

8000efaa <__avr32_f64_add_shift_done>:
8000efaa:	10 0a       	add	r10,r8
8000efac:	f6 09 00 4b 	adc	r11,r11,r9
8000efb0:	ed bb 00 15 	bld	r11,0x15
8000efb4:	c3 40       	breq	8000f01c <__avr32_f64_add_res_of>

8000efb6 <__avr32_f64_add_res_of_done>:
8000efb6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000efba:	18 4b       	or	r11,r12

8000efbc <__avr32_f64_add_round>:
8000efbc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000efc0:	18 4e       	or	lr,r12
8000efc2:	ee 1e 80 00 	eorh	lr,0x8000
8000efc6:	f1 be 04 20 	satu	lr,0x1
8000efca:	1c 0a       	add	r10,lr
8000efcc:	5c 0b       	acr	r11
8000efce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000efd2 <__avr32_f64_add_opH_nan_or_inf>:
8000efd2:	b5 cb       	cbr	r11,0x14
8000efd4:	f7 ea 10 0e 	or	lr,r11,r10
8000efd8:	c1 01       	brne	8000eff8 <__avr32_f64_add_return_nan>
8000efda:	e0 46 07 ff 	cp.w	r6,2047
8000efde:	c0 30       	breq	8000efe4 <__avr32_f64_add_opL_nan_or_inf>
8000efe0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000efe4 <__avr32_f64_add_opL_nan_or_inf>:
8000efe4:	b5 c9       	cbr	r9,0x14
8000efe6:	f3 e8 10 0e 	or	lr,r9,r8
8000efea:	c0 71       	brne	8000eff8 <__avr32_f64_add_return_nan>
8000efec:	30 0a       	mov	r10,0
8000efee:	fc 1b 7f f0 	movh	r11,0x7ff0
8000eff2:	18 4b       	or	r11,r12
8000eff4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eff8 <__avr32_f64_add_return_nan>:
8000eff8:	3f fa       	mov	r10,-1
8000effa:	3f fb       	mov	r11,-1
8000effc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f000 <__avr32_f64_add_longshift>:
8000f000:	f1 b6 04 c0 	satu	r6,0x6
8000f004:	f0 0e 17 00 	moveq	lr,r8
8000f008:	c0 60       	breq	8000f014 <__avr32_f64_add_longshift+0x14>
8000f00a:	f2 05 09 4e 	lsl	lr,r9,r5
8000f00e:	58 08       	cp.w	r8,0
8000f010:	5f 18       	srne	r8
8000f012:	10 4e       	or	lr,r8
8000f014:	f2 06 0a 48 	lsr	r8,r9,r6
8000f018:	30 09       	mov	r9,0
8000f01a:	cc 8b       	rjmp	8000efaa <__avr32_f64_add_shift_done>

8000f01c <__avr32_f64_add_res_of>:
8000f01c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f020:	a1 9b       	lsr	r11,0x1
8000f022:	5d 0a       	ror	r10
8000f024:	5d 0e       	ror	lr
8000f026:	2f f7       	sub	r7,-1
8000f028:	e0 47 07 ff 	cp.w	r7,2047
8000f02c:	f9 ba 00 00 	moveq	r10,0
8000f030:	f9 bb 00 00 	moveq	r11,0
8000f034:	f9 be 00 00 	moveq	lr,0
8000f038:	cb fb       	rjmp	8000efb6 <__avr32_f64_add_res_of_done>

8000f03a <__avr32_f64_add_op2_subnormal>:
8000f03a:	30 16       	mov	r6,1
8000f03c:	58 07       	cp.w	r7,0
8000f03e:	ca 01       	brne	8000ef7e <__avr32_f64_add+0x3e>
8000f040:	b5 cb       	cbr	r11,0x14
8000f042:	10 0a       	add	r10,r8
8000f044:	f6 09 00 4b 	adc	r11,r11,r9
8000f048:	18 4b       	or	r11,r12
8000f04a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f04e:	d7 03       	nop

8000f050 <__avr32_f64_to_u32>:
8000f050:	58 0b       	cp.w	r11,0
8000f052:	5e 6d       	retmi	0

8000f054 <__avr32_f64_to_s32>:
8000f054:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f058:	b5 9c       	lsr	r12,0x15
8000f05a:	e0 2c 03 ff 	sub	r12,1023
8000f05e:	5e 3d       	retlo	0
8000f060:	f8 0c 11 1f 	rsub	r12,r12,31
8000f064:	16 99       	mov	r9,r11
8000f066:	ab 7b       	lsl	r11,0xb
8000f068:	bf bb       	sbr	r11,0x1f
8000f06a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f06e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f072:	a1 79       	lsl	r9,0x1
8000f074:	5e 2b       	reths	r11
8000f076:	5c 3b       	neg	r11
8000f078:	5e fb       	retal	r11

8000f07a <__avr32_u32_to_f64>:
8000f07a:	f8 cb 00 00 	sub	r11,r12,0
8000f07e:	30 0c       	mov	r12,0
8000f080:	c0 38       	rjmp	8000f086 <__avr32_s32_to_f64+0x4>

8000f082 <__avr32_s32_to_f64>:
8000f082:	18 9b       	mov	r11,r12
8000f084:	5c 4b       	abs	r11
8000f086:	30 0a       	mov	r10,0
8000f088:	5e 0b       	reteq	r11
8000f08a:	d4 01       	pushm	lr
8000f08c:	e0 69 04 1e 	mov	r9,1054
8000f090:	f6 08 12 00 	clz	r8,r11
8000f094:	c1 70       	breq	8000f0c2 <__avr32_s32_to_f64+0x40>
8000f096:	c0 c3       	brcs	8000f0ae <__avr32_s32_to_f64+0x2c>
8000f098:	f0 0e 11 20 	rsub	lr,r8,32
8000f09c:	f6 08 09 4b 	lsl	r11,r11,r8
8000f0a0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f0a4:	1c 4b       	or	r11,lr
8000f0a6:	f4 08 09 4a 	lsl	r10,r10,r8
8000f0aa:	10 19       	sub	r9,r8
8000f0ac:	c0 b8       	rjmp	8000f0c2 <__avr32_s32_to_f64+0x40>
8000f0ae:	f4 08 12 00 	clz	r8,r10
8000f0b2:	f9 b8 03 00 	movlo	r8,0
8000f0b6:	f7 b8 02 e0 	subhs	r8,-32
8000f0ba:	f4 08 09 4b 	lsl	r11,r10,r8
8000f0be:	30 0a       	mov	r10,0
8000f0c0:	10 19       	sub	r9,r8
8000f0c2:	58 09       	cp.w	r9,0
8000f0c4:	e0 89 00 30 	brgt	8000f124 <__avr32_s32_to_f64+0xa2>
8000f0c8:	5c 39       	neg	r9
8000f0ca:	2f f9       	sub	r9,-1
8000f0cc:	e0 49 00 36 	cp.w	r9,54
8000f0d0:	c0 43       	brcs	8000f0d8 <__avr32_s32_to_f64+0x56>
8000f0d2:	30 0b       	mov	r11,0
8000f0d4:	30 0a       	mov	r10,0
8000f0d6:	c2 68       	rjmp	8000f122 <__avr32_s32_to_f64+0xa0>
8000f0d8:	2f 69       	sub	r9,-10
8000f0da:	f2 08 11 20 	rsub	r8,r9,32
8000f0de:	e0 49 00 20 	cp.w	r9,32
8000f0e2:	c0 b2       	brcc	8000f0f8 <__avr32_s32_to_f64+0x76>
8000f0e4:	f4 08 09 4e 	lsl	lr,r10,r8
8000f0e8:	f6 08 09 48 	lsl	r8,r11,r8
8000f0ec:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f0f0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f0f4:	10 4b       	or	r11,r8
8000f0f6:	c0 88       	rjmp	8000f106 <__avr32_s32_to_f64+0x84>
8000f0f8:	f6 08 09 4e 	lsl	lr,r11,r8
8000f0fc:	14 4e       	or	lr,r10
8000f0fe:	16 9a       	mov	r10,r11
8000f100:	30 0b       	mov	r11,0
8000f102:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f106:	ed ba 00 00 	bld	r10,0x0
8000f10a:	c0 92       	brcc	8000f11c <__avr32_s32_to_f64+0x9a>
8000f10c:	1c 7e       	tst	lr,lr
8000f10e:	c0 41       	brne	8000f116 <__avr32_s32_to_f64+0x94>
8000f110:	ed ba 00 01 	bld	r10,0x1
8000f114:	c0 42       	brcc	8000f11c <__avr32_s32_to_f64+0x9a>
8000f116:	2f fa       	sub	r10,-1
8000f118:	f7 bb 02 ff 	subhs	r11,-1
8000f11c:	5c fc       	rol	r12
8000f11e:	5d 0b       	ror	r11
8000f120:	5d 0a       	ror	r10
8000f122:	d8 02       	popm	pc
8000f124:	e0 68 03 ff 	mov	r8,1023
8000f128:	ed ba 00 0b 	bld	r10,0xb
8000f12c:	f7 b8 00 ff 	subeq	r8,-1
8000f130:	10 0a       	add	r10,r8
8000f132:	5c 0b       	acr	r11
8000f134:	f7 b9 03 fe 	sublo	r9,-2
8000f138:	e0 49 07 ff 	cp.w	r9,2047
8000f13c:	c0 55       	brlt	8000f146 <__avr32_s32_to_f64+0xc4>
8000f13e:	30 0a       	mov	r10,0
8000f140:	fc 1b ff e0 	movh	r11,0xffe0
8000f144:	c0 c8       	rjmp	8000f15c <__floatsidf_return_op1>
8000f146:	ed bb 00 1f 	bld	r11,0x1f
8000f14a:	f7 b9 01 01 	subne	r9,1
8000f14e:	ab 9a       	lsr	r10,0xb
8000f150:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f154:	a1 7b       	lsl	r11,0x1
8000f156:	ab 9b       	lsr	r11,0xb
8000f158:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f15c <__floatsidf_return_op1>:
8000f15c:	a1 7c       	lsl	r12,0x1
8000f15e:	5d 0b       	ror	r11
8000f160:	d8 02       	popm	pc

8000f162 <__avr32_f64_cmp_eq>:
8000f162:	10 3a       	cp.w	r10,r8
8000f164:	f2 0b 13 00 	cpc	r11,r9
8000f168:	c0 80       	breq	8000f178 <__avr32_f64_cmp_eq+0x16>
8000f16a:	a1 7b       	lsl	r11,0x1
8000f16c:	a1 79       	lsl	r9,0x1
8000f16e:	14 4b       	or	r11,r10
8000f170:	12 4b       	or	r11,r9
8000f172:	10 4b       	or	r11,r8
8000f174:	5e 0f       	reteq	1
8000f176:	5e fd       	retal	0
8000f178:	a1 7b       	lsl	r11,0x1
8000f17a:	fc 1c ff e0 	movh	r12,0xffe0
8000f17e:	58 0a       	cp.w	r10,0
8000f180:	f8 0b 13 00 	cpc	r11,r12
8000f184:	5e 8f       	retls	1
8000f186:	5e fd       	retal	0

8000f188 <__avr32_f64_cmp_ge>:
8000f188:	1a de       	st.w	--sp,lr
8000f18a:	1a d7       	st.w	--sp,r7
8000f18c:	a1 7b       	lsl	r11,0x1
8000f18e:	5f 3c       	srlo	r12
8000f190:	a1 79       	lsl	r9,0x1
8000f192:	5f 37       	srlo	r7
8000f194:	5c fc       	rol	r12
8000f196:	fc 1e ff e0 	movh	lr,0xffe0
8000f19a:	58 0a       	cp.w	r10,0
8000f19c:	fc 0b 13 00 	cpc	r11,lr
8000f1a0:	e0 8b 00 1d 	brhi	8000f1da <__avr32_f64_cmp_ge+0x52>
8000f1a4:	58 08       	cp.w	r8,0
8000f1a6:	fc 09 13 00 	cpc	r9,lr
8000f1aa:	e0 8b 00 18 	brhi	8000f1da <__avr32_f64_cmp_ge+0x52>
8000f1ae:	58 0b       	cp.w	r11,0
8000f1b0:	f5 ba 00 00 	subfeq	r10,0
8000f1b4:	c1 50       	breq	8000f1de <__avr32_f64_cmp_ge+0x56>
8000f1b6:	1b 07       	ld.w	r7,sp++
8000f1b8:	1b 0e       	ld.w	lr,sp++
8000f1ba:	58 3c       	cp.w	r12,3
8000f1bc:	c0 a0       	breq	8000f1d0 <__avr32_f64_cmp_ge+0x48>
8000f1be:	58 1c       	cp.w	r12,1
8000f1c0:	c0 33       	brcs	8000f1c6 <__avr32_f64_cmp_ge+0x3e>
8000f1c2:	5e 0f       	reteq	1
8000f1c4:	5e 1d       	retne	0
8000f1c6:	10 3a       	cp.w	r10,r8
8000f1c8:	f2 0b 13 00 	cpc	r11,r9
8000f1cc:	5e 2f       	reths	1
8000f1ce:	5e 3d       	retlo	0
8000f1d0:	14 38       	cp.w	r8,r10
8000f1d2:	f6 09 13 00 	cpc	r9,r11
8000f1d6:	5e 2f       	reths	1
8000f1d8:	5e 3d       	retlo	0
8000f1da:	1b 07       	ld.w	r7,sp++
8000f1dc:	d8 0a       	popm	pc,r12=0
8000f1de:	58 17       	cp.w	r7,1
8000f1e0:	5f 0c       	sreq	r12
8000f1e2:	58 09       	cp.w	r9,0
8000f1e4:	f5 b8 00 00 	subfeq	r8,0
8000f1e8:	1b 07       	ld.w	r7,sp++
8000f1ea:	1b 0e       	ld.w	lr,sp++
8000f1ec:	5e 0f       	reteq	1
8000f1ee:	5e fc       	retal	r12

8000f1f0 <__avr32_f64_cmp_lt>:
8000f1f0:	1a de       	st.w	--sp,lr
8000f1f2:	1a d7       	st.w	--sp,r7
8000f1f4:	a1 7b       	lsl	r11,0x1
8000f1f6:	5f 3c       	srlo	r12
8000f1f8:	a1 79       	lsl	r9,0x1
8000f1fa:	5f 37       	srlo	r7
8000f1fc:	5c fc       	rol	r12
8000f1fe:	fc 1e ff e0 	movh	lr,0xffe0
8000f202:	58 0a       	cp.w	r10,0
8000f204:	fc 0b 13 00 	cpc	r11,lr
8000f208:	e0 8b 00 1d 	brhi	8000f242 <__avr32_f64_cmp_lt+0x52>
8000f20c:	58 08       	cp.w	r8,0
8000f20e:	fc 09 13 00 	cpc	r9,lr
8000f212:	e0 8b 00 18 	brhi	8000f242 <__avr32_f64_cmp_lt+0x52>
8000f216:	58 0b       	cp.w	r11,0
8000f218:	f5 ba 00 00 	subfeq	r10,0
8000f21c:	c1 50       	breq	8000f246 <__avr32_f64_cmp_lt+0x56>
8000f21e:	1b 07       	ld.w	r7,sp++
8000f220:	1b 0e       	ld.w	lr,sp++
8000f222:	58 3c       	cp.w	r12,3
8000f224:	c0 a0       	breq	8000f238 <__avr32_f64_cmp_lt+0x48>
8000f226:	58 1c       	cp.w	r12,1
8000f228:	c0 33       	brcs	8000f22e <__avr32_f64_cmp_lt+0x3e>
8000f22a:	5e 0d       	reteq	0
8000f22c:	5e 1f       	retne	1
8000f22e:	10 3a       	cp.w	r10,r8
8000f230:	f2 0b 13 00 	cpc	r11,r9
8000f234:	5e 2d       	reths	0
8000f236:	5e 3f       	retlo	1
8000f238:	14 38       	cp.w	r8,r10
8000f23a:	f6 09 13 00 	cpc	r9,r11
8000f23e:	5e 2d       	reths	0
8000f240:	5e 3f       	retlo	1
8000f242:	1b 07       	ld.w	r7,sp++
8000f244:	d8 0a       	popm	pc,r12=0
8000f246:	58 17       	cp.w	r7,1
8000f248:	5f 1c       	srne	r12
8000f24a:	58 09       	cp.w	r9,0
8000f24c:	f5 b8 00 00 	subfeq	r8,0
8000f250:	1b 07       	ld.w	r7,sp++
8000f252:	1b 0e       	ld.w	lr,sp++
8000f254:	5e 0d       	reteq	0
8000f256:	5e fc       	retal	r12

8000f258 <__avr32_f64_div>:
8000f258:	eb cd 40 ff 	pushm	r0-r7,lr
8000f25c:	f7 e9 20 0e 	eor	lr,r11,r9
8000f260:	f6 07 16 14 	lsr	r7,r11,0x14
8000f264:	a9 7b       	lsl	r11,0x9
8000f266:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f26a:	a9 7a       	lsl	r10,0x9
8000f26c:	bd bb       	sbr	r11,0x1d
8000f26e:	e4 1b 3f ff 	andh	r11,0x3fff
8000f272:	ab d7       	cbr	r7,0xb
8000f274:	e0 80 00 cc 	breq	8000f40c <__avr32_f64_div_round_subnormal+0x54>
8000f278:	e0 47 07 ff 	cp.w	r7,2047
8000f27c:	e0 84 00 b5 	brge	8000f3e6 <__avr32_f64_div_round_subnormal+0x2e>
8000f280:	f2 06 16 14 	lsr	r6,r9,0x14
8000f284:	a9 79       	lsl	r9,0x9
8000f286:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f28a:	a9 78       	lsl	r8,0x9
8000f28c:	bd b9       	sbr	r9,0x1d
8000f28e:	e4 19 3f ff 	andh	r9,0x3fff
8000f292:	ab d6       	cbr	r6,0xb
8000f294:	e0 80 00 e2 	breq	8000f458 <__avr32_f64_div_round_subnormal+0xa0>
8000f298:	e0 46 07 ff 	cp.w	r6,2047
8000f29c:	e0 84 00 b2 	brge	8000f400 <__avr32_f64_div_round_subnormal+0x48>
8000f2a0:	0c 17       	sub	r7,r6
8000f2a2:	fe 37 fc 01 	sub	r7,-1023
8000f2a6:	fc 1c 80 00 	movh	r12,0x8000
8000f2aa:	f8 03 16 01 	lsr	r3,r12,0x1
8000f2ae:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f2b2:	5c d4       	com	r4
8000f2b4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f2b8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f2bc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f2c0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f2c4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f2c8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f2cc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f2d0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f2d4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f2d8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f2dc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f2e0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f2e4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f2e8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f2ec:	e4 09 07 40 	macu.d	r0,r2,r9
8000f2f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f2f4:	02 04       	add	r4,r1
8000f2f6:	5c 05       	acr	r5
8000f2f8:	a3 65       	lsl	r5,0x2
8000f2fa:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f2fe:	a3 64       	lsl	r4,0x2
8000f300:	5c 34       	neg	r4
8000f302:	f8 05 01 45 	sbc	r5,r12,r5
8000f306:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f30a:	e4 05 07 40 	macu.d	r0,r2,r5
8000f30e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f312:	02 04       	add	r4,r1
8000f314:	5c 05       	acr	r5
8000f316:	ea 03 15 02 	lsl	r3,r5,0x2
8000f31a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f31e:	e8 02 15 02 	lsl	r2,r4,0x2
8000f322:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f326:	e4 09 07 40 	macu.d	r0,r2,r9
8000f32a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f32e:	02 04       	add	r4,r1
8000f330:	5c 05       	acr	r5
8000f332:	a3 65       	lsl	r5,0x2
8000f334:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f338:	a3 64       	lsl	r4,0x2
8000f33a:	5c 34       	neg	r4
8000f33c:	f8 05 01 45 	sbc	r5,r12,r5
8000f340:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f344:	e4 05 07 40 	macu.d	r0,r2,r5
8000f348:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f34c:	02 04       	add	r4,r1
8000f34e:	5c 05       	acr	r5
8000f350:	ea 03 15 02 	lsl	r3,r5,0x2
8000f354:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f358:	e8 02 15 02 	lsl	r2,r4,0x2
8000f35c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f360:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f364:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f368:	02 02       	add	r2,r1
8000f36a:	5c 03       	acr	r3
8000f36c:	ed b3 00 1c 	bld	r3,0x1c
8000f370:	c0 90       	breq	8000f382 <__avr32_f64_div+0x12a>
8000f372:	a1 72       	lsl	r2,0x1
8000f374:	5c f3       	rol	r3
8000f376:	20 17       	sub	r7,1
8000f378:	a3 9a       	lsr	r10,0x3
8000f37a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f37e:	a3 9b       	lsr	r11,0x3
8000f380:	c0 58       	rjmp	8000f38a <__avr32_f64_div+0x132>
8000f382:	a5 8a       	lsr	r10,0x4
8000f384:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f388:	a5 8b       	lsr	r11,0x4
8000f38a:	58 07       	cp.w	r7,0
8000f38c:	e0 8a 00 8b 	brle	8000f4a2 <__avr32_f64_div_res_subnormal>
8000f390:	e0 12 ff 00 	andl	r2,0xff00
8000f394:	e8 12 00 80 	orl	r2,0x80
8000f398:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f39c:	e4 09 07 40 	macu.d	r0,r2,r9
8000f3a0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f3a4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f3a8:	00 05       	add	r5,r0
8000f3aa:	f0 01 00 48 	adc	r8,r8,r1
8000f3ae:	5c 09       	acr	r9
8000f3b0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f3b4:	58 04       	cp.w	r4,0
8000f3b6:	5c 25       	cpc	r5

8000f3b8 <__avr32_f64_div_round_subnormal>:
8000f3b8:	f4 08 13 00 	cpc	r8,r10
8000f3bc:	f6 09 13 00 	cpc	r9,r11
8000f3c0:	5f 36       	srlo	r6
8000f3c2:	f8 06 17 00 	moveq	r6,r12
8000f3c6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f3ca:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f3ce:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f3d2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f3d6:	ed be 00 1f 	bld	lr,0x1f
8000f3da:	ef bb 00 1f 	bst	r11,0x1f
8000f3de:	0c 0a       	add	r10,r6
8000f3e0:	5c 0b       	acr	r11
8000f3e2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f3e6:	e4 1b 00 0f 	andh	r11,0xf
8000f3ea:	14 4b       	or	r11,r10
8000f3ec:	e0 81 00 a7 	brne	8000f53a <__avr32_f64_div_res_subnormal+0x98>
8000f3f0:	f2 06 16 14 	lsr	r6,r9,0x14
8000f3f4:	ab d6       	cbr	r6,0xb
8000f3f6:	e0 46 07 ff 	cp.w	r6,2047
8000f3fa:	e0 81 00 a4 	brne	8000f542 <__avr32_f64_div_res_subnormal+0xa0>
8000f3fe:	c9 e8       	rjmp	8000f53a <__avr32_f64_div_res_subnormal+0x98>
8000f400:	e4 19 00 0f 	andh	r9,0xf
8000f404:	10 49       	or	r9,r8
8000f406:	e0 81 00 9a 	brne	8000f53a <__avr32_f64_div_res_subnormal+0x98>
8000f40a:	c9 28       	rjmp	8000f52e <__avr32_f64_div_res_subnormal+0x8c>
8000f40c:	a3 7b       	lsl	r11,0x3
8000f40e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f412:	a3 7a       	lsl	r10,0x3
8000f414:	f5 eb 10 04 	or	r4,r10,r11
8000f418:	e0 80 00 a0 	breq	8000f558 <__avr32_f64_div_op1_zero>
8000f41c:	f6 04 12 00 	clz	r4,r11
8000f420:	c1 70       	breq	8000f44e <__avr32_f64_div_round_subnormal+0x96>
8000f422:	c0 c3       	brcs	8000f43a <__avr32_f64_div_round_subnormal+0x82>
8000f424:	e8 05 11 20 	rsub	r5,r4,32
8000f428:	f6 04 09 4b 	lsl	r11,r11,r4
8000f42c:	f4 05 0a 45 	lsr	r5,r10,r5
8000f430:	0a 4b       	or	r11,r5
8000f432:	f4 04 09 4a 	lsl	r10,r10,r4
8000f436:	08 17       	sub	r7,r4
8000f438:	c0 b8       	rjmp	8000f44e <__avr32_f64_div_round_subnormal+0x96>
8000f43a:	f4 04 12 00 	clz	r4,r10
8000f43e:	f9 b4 03 00 	movlo	r4,0
8000f442:	f7 b4 02 e0 	subhs	r4,-32
8000f446:	f4 04 09 4b 	lsl	r11,r10,r4
8000f44a:	30 0a       	mov	r10,0
8000f44c:	08 17       	sub	r7,r4
8000f44e:	a3 8a       	lsr	r10,0x2
8000f450:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f454:	a3 8b       	lsr	r11,0x2
8000f456:	c1 1b       	rjmp	8000f278 <__avr32_f64_div+0x20>
8000f458:	a3 79       	lsl	r9,0x3
8000f45a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f45e:	a3 78       	lsl	r8,0x3
8000f460:	f3 e8 10 04 	or	r4,r9,r8
8000f464:	c6 f0       	breq	8000f542 <__avr32_f64_div_res_subnormal+0xa0>
8000f466:	f2 04 12 00 	clz	r4,r9
8000f46a:	c1 70       	breq	8000f498 <__avr32_f64_div_round_subnormal+0xe0>
8000f46c:	c0 c3       	brcs	8000f484 <__avr32_f64_div_round_subnormal+0xcc>
8000f46e:	e8 05 11 20 	rsub	r5,r4,32
8000f472:	f2 04 09 49 	lsl	r9,r9,r4
8000f476:	f0 05 0a 45 	lsr	r5,r8,r5
8000f47a:	0a 49       	or	r9,r5
8000f47c:	f0 04 09 48 	lsl	r8,r8,r4
8000f480:	08 16       	sub	r6,r4
8000f482:	c0 b8       	rjmp	8000f498 <__avr32_f64_div_round_subnormal+0xe0>
8000f484:	f0 04 12 00 	clz	r4,r8
8000f488:	f9 b4 03 00 	movlo	r4,0
8000f48c:	f7 b4 02 e0 	subhs	r4,-32
8000f490:	f0 04 09 49 	lsl	r9,r8,r4
8000f494:	30 08       	mov	r8,0
8000f496:	08 16       	sub	r6,r4
8000f498:	a3 88       	lsr	r8,0x2
8000f49a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f49e:	a3 89       	lsr	r9,0x2
8000f4a0:	cf ca       	rjmp	8000f298 <__avr32_f64_div+0x40>

8000f4a2 <__avr32_f64_div_res_subnormal>:
8000f4a2:	5c 37       	neg	r7
8000f4a4:	2f f7       	sub	r7,-1
8000f4a6:	f1 b7 04 c0 	satu	r7,0x6
8000f4aa:	e0 47 00 20 	cp.w	r7,32
8000f4ae:	c1 54       	brge	8000f4d8 <__avr32_f64_div_res_subnormal+0x36>
8000f4b0:	ee 06 11 20 	rsub	r6,r7,32
8000f4b4:	e4 07 0a 42 	lsr	r2,r2,r7
8000f4b8:	e6 06 09 4c 	lsl	r12,r3,r6
8000f4bc:	18 42       	or	r2,r12
8000f4be:	e6 07 0a 43 	lsr	r3,r3,r7
8000f4c2:	f4 06 09 41 	lsl	r1,r10,r6
8000f4c6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f4ca:	f6 06 09 4c 	lsl	r12,r11,r6
8000f4ce:	18 4a       	or	r10,r12
8000f4d0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000f4d4:	30 00       	mov	r0,0
8000f4d6:	c1 58       	rjmp	8000f500 <__avr32_f64_div_res_subnormal+0x5e>
8000f4d8:	ee 06 11 20 	rsub	r6,r7,32
8000f4dc:	f9 b0 00 00 	moveq	r0,0
8000f4e0:	f9 bc 00 00 	moveq	r12,0
8000f4e4:	c0 50       	breq	8000f4ee <__avr32_f64_div_res_subnormal+0x4c>
8000f4e6:	f4 06 09 40 	lsl	r0,r10,r6
8000f4ea:	f6 06 09 4c 	lsl	r12,r11,r6
8000f4ee:	e6 07 0a 42 	lsr	r2,r3,r7
8000f4f2:	30 03       	mov	r3,0
8000f4f4:	f4 07 0a 41 	lsr	r1,r10,r7
8000f4f8:	18 41       	or	r1,r12
8000f4fa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f4fe:	30 0b       	mov	r11,0
8000f500:	e0 12 ff 00 	andl	r2,0xff00
8000f504:	e8 12 00 80 	orl	r2,0x80
8000f508:	e6 08 06 46 	mulu.d	r6,r3,r8
8000f50c:	e4 09 07 46 	macu.d	r6,r2,r9
8000f510:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f514:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f518:	0c 05       	add	r5,r6
8000f51a:	f0 07 00 48 	adc	r8,r8,r7
8000f51e:	5c 09       	acr	r9
8000f520:	30 07       	mov	r7,0
8000f522:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f526:	00 34       	cp.w	r4,r0
8000f528:	e2 05 13 00 	cpc	r5,r1
8000f52c:	c4 6b       	rjmp	8000f3b8 <__avr32_f64_div_round_subnormal>
8000f52e:	1c 9b       	mov	r11,lr
8000f530:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f534:	30 0a       	mov	r10,0
8000f536:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f53a:	3f fb       	mov	r11,-1
8000f53c:	30 0a       	mov	r10,0
8000f53e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f542:	f5 eb 10 04 	or	r4,r10,r11
8000f546:	c0 90       	breq	8000f558 <__avr32_f64_div_op1_zero>
8000f548:	1c 9b       	mov	r11,lr
8000f54a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f54e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000f552:	30 0a       	mov	r10,0
8000f554:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000f558 <__avr32_f64_div_op1_zero>:
8000f558:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000f55c:	ce f0       	breq	8000f53a <__avr32_f64_div_res_subnormal+0x98>
8000f55e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000f562:	e0 44 07 ff 	cp.w	r4,2047
8000f566:	ce 41       	brne	8000f52e <__avr32_f64_div_res_subnormal+0x8c>
8000f568:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000f56c:	ce 10       	breq	8000f52e <__avr32_f64_div_res_subnormal+0x8c>
8000f56e:	ce 6b       	rjmp	8000f53a <__avr32_f64_div_res_subnormal+0x98>

8000f570 <__avr32_udiv64>:
8000f570:	d4 31       	pushm	r0-r7,lr
8000f572:	1a 97       	mov	r7,sp
8000f574:	20 3d       	sub	sp,12
8000f576:	10 9c       	mov	r12,r8
8000f578:	12 9e       	mov	lr,r9
8000f57a:	14 93       	mov	r3,r10
8000f57c:	58 09       	cp.w	r9,0
8000f57e:	e0 81 00 bd 	brne	8000f6f8 <__avr32_udiv64+0x188>
8000f582:	16 38       	cp.w	r8,r11
8000f584:	e0 88 00 40 	brls	8000f604 <__avr32_udiv64+0x94>
8000f588:	f0 08 12 00 	clz	r8,r8
8000f58c:	c0 d0       	breq	8000f5a6 <__avr32_udiv64+0x36>
8000f58e:	f6 08 09 4b 	lsl	r11,r11,r8
8000f592:	f0 09 11 20 	rsub	r9,r8,32
8000f596:	f8 08 09 4c 	lsl	r12,r12,r8
8000f59a:	f4 09 0a 49 	lsr	r9,r10,r9
8000f59e:	f4 08 09 43 	lsl	r3,r10,r8
8000f5a2:	f3 eb 10 0b 	or	r11,r9,r11
8000f5a6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000f5aa:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000f5ae:	f6 0e 0d 00 	divu	r0,r11,lr
8000f5b2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f5b6:	00 99       	mov	r9,r0
8000f5b8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f5bc:	e0 0a 02 48 	mul	r8,r0,r10
8000f5c0:	10 3b       	cp.w	r11,r8
8000f5c2:	c0 a2       	brcc	8000f5d6 <__avr32_udiv64+0x66>
8000f5c4:	20 19       	sub	r9,1
8000f5c6:	18 0b       	add	r11,r12
8000f5c8:	18 3b       	cp.w	r11,r12
8000f5ca:	c0 63       	brcs	8000f5d6 <__avr32_udiv64+0x66>
8000f5cc:	10 3b       	cp.w	r11,r8
8000f5ce:	f7 b9 03 01 	sublo	r9,1
8000f5d2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f5d6:	f6 08 01 01 	sub	r1,r11,r8
8000f5da:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f5de:	e2 0e 0d 00 	divu	r0,r1,lr
8000f5e2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f5e6:	00 98       	mov	r8,r0
8000f5e8:	e0 0a 02 4a 	mul	r10,r0,r10
8000f5ec:	14 33       	cp.w	r3,r10
8000f5ee:	c0 82       	brcc	8000f5fe <__avr32_udiv64+0x8e>
8000f5f0:	20 18       	sub	r8,1
8000f5f2:	18 03       	add	r3,r12
8000f5f4:	18 33       	cp.w	r3,r12
8000f5f6:	c0 43       	brcs	8000f5fe <__avr32_udiv64+0x8e>
8000f5f8:	14 33       	cp.w	r3,r10
8000f5fa:	f7 b8 03 01 	sublo	r8,1
8000f5fe:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000f602:	cd f8       	rjmp	8000f7c0 <__avr32_udiv64+0x250>
8000f604:	58 08       	cp.w	r8,0
8000f606:	c0 51       	brne	8000f610 <__avr32_udiv64+0xa0>
8000f608:	30 19       	mov	r9,1
8000f60a:	f2 08 0d 08 	divu	r8,r9,r8
8000f60e:	10 9c       	mov	r12,r8
8000f610:	f8 06 12 00 	clz	r6,r12
8000f614:	c0 41       	brne	8000f61c <__avr32_udiv64+0xac>
8000f616:	18 1b       	sub	r11,r12
8000f618:	30 19       	mov	r9,1
8000f61a:	c4 08       	rjmp	8000f69a <__avr32_udiv64+0x12a>
8000f61c:	ec 01 11 20 	rsub	r1,r6,32
8000f620:	f4 01 0a 49 	lsr	r9,r10,r1
8000f624:	f8 06 09 4c 	lsl	r12,r12,r6
8000f628:	f6 06 09 48 	lsl	r8,r11,r6
8000f62c:	f6 01 0a 41 	lsr	r1,r11,r1
8000f630:	f3 e8 10 08 	or	r8,r9,r8
8000f634:	f8 03 16 10 	lsr	r3,r12,0x10
8000f638:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f63c:	e2 03 0d 00 	divu	r0,r1,r3
8000f640:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f644:	00 9e       	mov	lr,r0
8000f646:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f64a:	e0 05 02 49 	mul	r9,r0,r5
8000f64e:	12 3b       	cp.w	r11,r9
8000f650:	c0 a2       	brcc	8000f664 <__avr32_udiv64+0xf4>
8000f652:	20 1e       	sub	lr,1
8000f654:	18 0b       	add	r11,r12
8000f656:	18 3b       	cp.w	r11,r12
8000f658:	c0 63       	brcs	8000f664 <__avr32_udiv64+0xf4>
8000f65a:	12 3b       	cp.w	r11,r9
8000f65c:	f7 be 03 01 	sublo	lr,1
8000f660:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f664:	12 1b       	sub	r11,r9
8000f666:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000f66a:	f6 03 0d 02 	divu	r2,r11,r3
8000f66e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000f672:	04 99       	mov	r9,r2
8000f674:	e4 05 02 4b 	mul	r11,r2,r5
8000f678:	16 38       	cp.w	r8,r11
8000f67a:	c0 a2       	brcc	8000f68e <__avr32_udiv64+0x11e>
8000f67c:	20 19       	sub	r9,1
8000f67e:	18 08       	add	r8,r12
8000f680:	18 38       	cp.w	r8,r12
8000f682:	c0 63       	brcs	8000f68e <__avr32_udiv64+0x11e>
8000f684:	16 38       	cp.w	r8,r11
8000f686:	f7 b9 03 01 	sublo	r9,1
8000f68a:	f1 dc e3 08 	addcs	r8,r8,r12
8000f68e:	f4 06 09 43 	lsl	r3,r10,r6
8000f692:	f0 0b 01 0b 	sub	r11,r8,r11
8000f696:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000f69a:	f8 06 16 10 	lsr	r6,r12,0x10
8000f69e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000f6a2:	f6 06 0d 00 	divu	r0,r11,r6
8000f6a6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f6aa:	00 9a       	mov	r10,r0
8000f6ac:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f6b0:	e0 0e 02 48 	mul	r8,r0,lr
8000f6b4:	10 3b       	cp.w	r11,r8
8000f6b6:	c0 a2       	brcc	8000f6ca <__avr32_udiv64+0x15a>
8000f6b8:	20 1a       	sub	r10,1
8000f6ba:	18 0b       	add	r11,r12
8000f6bc:	18 3b       	cp.w	r11,r12
8000f6be:	c0 63       	brcs	8000f6ca <__avr32_udiv64+0x15a>
8000f6c0:	10 3b       	cp.w	r11,r8
8000f6c2:	f7 ba 03 01 	sublo	r10,1
8000f6c6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f6ca:	f6 08 01 01 	sub	r1,r11,r8
8000f6ce:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f6d2:	e2 06 0d 00 	divu	r0,r1,r6
8000f6d6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f6da:	00 98       	mov	r8,r0
8000f6dc:	e0 0e 02 4b 	mul	r11,r0,lr
8000f6e0:	16 33       	cp.w	r3,r11
8000f6e2:	c0 82       	brcc	8000f6f2 <__avr32_udiv64+0x182>
8000f6e4:	20 18       	sub	r8,1
8000f6e6:	18 03       	add	r3,r12
8000f6e8:	18 33       	cp.w	r3,r12
8000f6ea:	c0 43       	brcs	8000f6f2 <__avr32_udiv64+0x182>
8000f6ec:	16 33       	cp.w	r3,r11
8000f6ee:	f7 b8 03 01 	sublo	r8,1
8000f6f2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000f6f6:	c6 98       	rjmp	8000f7c8 <__avr32_udiv64+0x258>
8000f6f8:	16 39       	cp.w	r9,r11
8000f6fa:	e0 8b 00 65 	brhi	8000f7c4 <__avr32_udiv64+0x254>
8000f6fe:	f2 09 12 00 	clz	r9,r9
8000f702:	c0 b1       	brne	8000f718 <__avr32_udiv64+0x1a8>
8000f704:	10 3a       	cp.w	r10,r8
8000f706:	5f 2a       	srhs	r10
8000f708:	1c 3b       	cp.w	r11,lr
8000f70a:	5f b8       	srhi	r8
8000f70c:	10 4a       	or	r10,r8
8000f70e:	f2 0a 18 00 	cp.b	r10,r9
8000f712:	c5 90       	breq	8000f7c4 <__avr32_udiv64+0x254>
8000f714:	30 18       	mov	r8,1
8000f716:	c5 98       	rjmp	8000f7c8 <__avr32_udiv64+0x258>
8000f718:	f0 09 09 46 	lsl	r6,r8,r9
8000f71c:	f2 03 11 20 	rsub	r3,r9,32
8000f720:	fc 09 09 4e 	lsl	lr,lr,r9
8000f724:	f0 03 0a 48 	lsr	r8,r8,r3
8000f728:	f6 09 09 4c 	lsl	r12,r11,r9
8000f72c:	f4 03 0a 42 	lsr	r2,r10,r3
8000f730:	ef 46 ff f4 	st.w	r7[-12],r6
8000f734:	f6 03 0a 43 	lsr	r3,r11,r3
8000f738:	18 42       	or	r2,r12
8000f73a:	f1 ee 10 0c 	or	r12,r8,lr
8000f73e:	f8 01 16 10 	lsr	r1,r12,0x10
8000f742:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f746:	e6 01 0d 04 	divu	r4,r3,r1
8000f74a:	e4 03 16 10 	lsr	r3,r2,0x10
8000f74e:	08 9e       	mov	lr,r4
8000f750:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000f754:	e8 06 02 48 	mul	r8,r4,r6
8000f758:	10 33       	cp.w	r3,r8
8000f75a:	c0 a2       	brcc	8000f76e <__avr32_udiv64+0x1fe>
8000f75c:	20 1e       	sub	lr,1
8000f75e:	18 03       	add	r3,r12
8000f760:	18 33       	cp.w	r3,r12
8000f762:	c0 63       	brcs	8000f76e <__avr32_udiv64+0x1fe>
8000f764:	10 33       	cp.w	r3,r8
8000f766:	f7 be 03 01 	sublo	lr,1
8000f76a:	e7 dc e3 03 	addcs	r3,r3,r12
8000f76e:	10 13       	sub	r3,r8
8000f770:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000f774:	e6 01 0d 00 	divu	r0,r3,r1
8000f778:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f77c:	00 98       	mov	r8,r0
8000f77e:	e0 06 02 46 	mul	r6,r0,r6
8000f782:	0c 3b       	cp.w	r11,r6
8000f784:	c0 a2       	brcc	8000f798 <__avr32_udiv64+0x228>
8000f786:	20 18       	sub	r8,1
8000f788:	18 0b       	add	r11,r12
8000f78a:	18 3b       	cp.w	r11,r12
8000f78c:	c0 63       	brcs	8000f798 <__avr32_udiv64+0x228>
8000f78e:	0c 3b       	cp.w	r11,r6
8000f790:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f794:	f7 b8 03 01 	sublo	r8,1
8000f798:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000f79c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000f7a0:	0c 1b       	sub	r11,r6
8000f7a2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000f7a6:	06 95       	mov	r5,r3
8000f7a8:	16 35       	cp.w	r5,r11
8000f7aa:	e0 8b 00 0a 	brhi	8000f7be <__avr32_udiv64+0x24e>
8000f7ae:	5f 0b       	sreq	r11
8000f7b0:	f4 09 09 49 	lsl	r9,r10,r9
8000f7b4:	12 32       	cp.w	r2,r9
8000f7b6:	5f b9       	srhi	r9
8000f7b8:	f7 e9 00 09 	and	r9,r11,r9
8000f7bc:	c0 60       	breq	8000f7c8 <__avr32_udiv64+0x258>
8000f7be:	20 18       	sub	r8,1
8000f7c0:	30 09       	mov	r9,0
8000f7c2:	c0 38       	rjmp	8000f7c8 <__avr32_udiv64+0x258>
8000f7c4:	30 09       	mov	r9,0
8000f7c6:	12 98       	mov	r8,r9
8000f7c8:	10 9a       	mov	r10,r8
8000f7ca:	12 93       	mov	r3,r9
8000f7cc:	10 92       	mov	r2,r8
8000f7ce:	12 9b       	mov	r11,r9
8000f7d0:	2f dd       	sub	sp,-12
8000f7d2:	d8 32       	popm	r0-r7,pc

8000f7d4 <__avr32_umod64>:
8000f7d4:	d4 31       	pushm	r0-r7,lr
8000f7d6:	1a 97       	mov	r7,sp
8000f7d8:	20 3d       	sub	sp,12
8000f7da:	10 9c       	mov	r12,r8
8000f7dc:	12 95       	mov	r5,r9
8000f7de:	14 9e       	mov	lr,r10
8000f7e0:	16 91       	mov	r1,r11
8000f7e2:	16 96       	mov	r6,r11
8000f7e4:	58 09       	cp.w	r9,0
8000f7e6:	e0 81 00 81 	brne	8000f8e8 <__avr32_umod64+0x114>
8000f7ea:	16 38       	cp.w	r8,r11
8000f7ec:	e0 88 00 12 	brls	8000f810 <__avr32_umod64+0x3c>
8000f7f0:	f0 08 12 00 	clz	r8,r8
8000f7f4:	c4 e0       	breq	8000f890 <__avr32_umod64+0xbc>
8000f7f6:	f6 08 09 46 	lsl	r6,r11,r8
8000f7fa:	f8 08 09 4c 	lsl	r12,r12,r8
8000f7fe:	f0 0b 11 20 	rsub	r11,r8,32
8000f802:	f4 08 09 4e 	lsl	lr,r10,r8
8000f806:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000f80a:	f7 e6 10 06 	or	r6,r11,r6
8000f80e:	c4 18       	rjmp	8000f890 <__avr32_umod64+0xbc>
8000f810:	58 08       	cp.w	r8,0
8000f812:	c0 51       	brne	8000f81c <__avr32_umod64+0x48>
8000f814:	30 19       	mov	r9,1
8000f816:	f2 08 0d 08 	divu	r8,r9,r8
8000f81a:	10 9c       	mov	r12,r8
8000f81c:	f8 08 12 00 	clz	r8,r12
8000f820:	c0 31       	brne	8000f826 <__avr32_umod64+0x52>
8000f822:	18 16       	sub	r6,r12
8000f824:	c3 68       	rjmp	8000f890 <__avr32_umod64+0xbc>
8000f826:	f0 03 11 20 	rsub	r3,r8,32
8000f82a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000f82e:	f8 08 09 4c 	lsl	r12,r12,r8
8000f832:	ec 08 09 49 	lsl	r9,r6,r8
8000f836:	ec 03 0a 43 	lsr	r3,r6,r3
8000f83a:	f7 e9 10 09 	or	r9,r11,r9
8000f83e:	f8 05 16 10 	lsr	r5,r12,0x10
8000f842:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f846:	e6 05 0d 02 	divu	r2,r3,r5
8000f84a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000f84e:	ec 02 02 4b 	mul	r11,r6,r2
8000f852:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000f856:	16 3e       	cp.w	lr,r11
8000f858:	c0 72       	brcc	8000f866 <__avr32_umod64+0x92>
8000f85a:	18 0e       	add	lr,r12
8000f85c:	18 3e       	cp.w	lr,r12
8000f85e:	c0 43       	brcs	8000f866 <__avr32_umod64+0x92>
8000f860:	16 3e       	cp.w	lr,r11
8000f862:	fd dc e3 0e 	addcs	lr,lr,r12
8000f866:	fc 0b 01 03 	sub	r3,lr,r11
8000f86a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000f86e:	e6 05 0d 02 	divu	r2,r3,r5
8000f872:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f876:	a5 36       	mul	r6,r2
8000f878:	0c 39       	cp.w	r9,r6
8000f87a:	c0 72       	brcc	8000f888 <__avr32_umod64+0xb4>
8000f87c:	18 09       	add	r9,r12
8000f87e:	18 39       	cp.w	r9,r12
8000f880:	c0 43       	brcs	8000f888 <__avr32_umod64+0xb4>
8000f882:	0c 39       	cp.w	r9,r6
8000f884:	f3 dc e3 09 	addcs	r9,r9,r12
8000f888:	f2 06 01 06 	sub	r6,r9,r6
8000f88c:	f4 08 09 4e 	lsl	lr,r10,r8
8000f890:	f8 0a 16 10 	lsr	r10,r12,0x10
8000f894:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f898:	ec 0a 0d 02 	divu	r2,r6,r10
8000f89c:	fc 09 16 10 	lsr	r9,lr,0x10
8000f8a0:	ea 02 02 4b 	mul	r11,r5,r2
8000f8a4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f8a8:	16 39       	cp.w	r9,r11
8000f8aa:	c0 72       	brcc	8000f8b8 <__avr32_umod64+0xe4>
8000f8ac:	18 09       	add	r9,r12
8000f8ae:	18 39       	cp.w	r9,r12
8000f8b0:	c0 43       	brcs	8000f8b8 <__avr32_umod64+0xe4>
8000f8b2:	16 39       	cp.w	r9,r11
8000f8b4:	f3 dc e3 09 	addcs	r9,r9,r12
8000f8b8:	f2 0b 01 0b 	sub	r11,r9,r11
8000f8bc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f8c0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000f8c4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000f8c8:	ea 0a 02 4a 	mul	r10,r5,r10
8000f8cc:	14 3e       	cp.w	lr,r10
8000f8ce:	c0 72       	brcc	8000f8dc <__avr32_umod64+0x108>
8000f8d0:	18 0e       	add	lr,r12
8000f8d2:	18 3e       	cp.w	lr,r12
8000f8d4:	c0 43       	brcs	8000f8dc <__avr32_umod64+0x108>
8000f8d6:	14 3e       	cp.w	lr,r10
8000f8d8:	fd dc e3 0e 	addcs	lr,lr,r12
8000f8dc:	fc 0a 01 0a 	sub	r10,lr,r10
8000f8e0:	30 0b       	mov	r11,0
8000f8e2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000f8e6:	c7 b8       	rjmp	8000f9dc <__avr32_umod64+0x208>
8000f8e8:	16 39       	cp.w	r9,r11
8000f8ea:	e0 8b 00 79 	brhi	8000f9dc <__avr32_umod64+0x208>
8000f8ee:	f2 09 12 00 	clz	r9,r9
8000f8f2:	c1 21       	brne	8000f916 <__avr32_umod64+0x142>
8000f8f4:	10 3a       	cp.w	r10,r8
8000f8f6:	5f 2b       	srhs	r11
8000f8f8:	0a 31       	cp.w	r1,r5
8000f8fa:	5f ba       	srhi	r10
8000f8fc:	f7 ea 10 0a 	or	r10,r11,r10
8000f900:	f2 0a 18 00 	cp.b	r10,r9
8000f904:	c0 60       	breq	8000f910 <__avr32_umod64+0x13c>
8000f906:	fc 08 01 0c 	sub	r12,lr,r8
8000f90a:	e2 05 01 46 	sbc	r6,r1,r5
8000f90e:	18 9e       	mov	lr,r12
8000f910:	0c 9b       	mov	r11,r6
8000f912:	1c 9a       	mov	r10,lr
8000f914:	c6 48       	rjmp	8000f9dc <__avr32_umod64+0x208>
8000f916:	ea 09 09 4c 	lsl	r12,r5,r9
8000f91a:	f2 06 11 20 	rsub	r6,r9,32
8000f91e:	f6 09 09 4b 	lsl	r11,r11,r9
8000f922:	f0 09 09 42 	lsl	r2,r8,r9
8000f926:	ef 46 ff f4 	st.w	r7[-12],r6
8000f92a:	f0 06 0a 48 	lsr	r8,r8,r6
8000f92e:	18 48       	or	r8,r12
8000f930:	e2 06 0a 4c 	lsr	r12,r1,r6
8000f934:	f4 09 09 43 	lsl	r3,r10,r9
8000f938:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000f93c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000f940:	16 4a       	or	r10,r11
8000f942:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f946:	f8 0b 0d 04 	divu	r4,r12,r11
8000f94a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000f94e:	08 91       	mov	r1,r4
8000f950:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000f954:	e8 0e 02 46 	mul	r6,r4,lr
8000f958:	0c 3c       	cp.w	r12,r6
8000f95a:	c0 a2       	brcc	8000f96e <__avr32_umod64+0x19a>
8000f95c:	20 11       	sub	r1,1
8000f95e:	10 0c       	add	r12,r8
8000f960:	10 3c       	cp.w	r12,r8
8000f962:	c0 63       	brcs	8000f96e <__avr32_umod64+0x19a>
8000f964:	0c 3c       	cp.w	r12,r6
8000f966:	f7 b1 03 01 	sublo	r1,1
8000f96a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000f96e:	0c 1c       	sub	r12,r6
8000f970:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000f974:	f8 0b 0d 04 	divu	r4,r12,r11
8000f978:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000f97c:	08 96       	mov	r6,r4
8000f97e:	e8 0e 02 4e 	mul	lr,r4,lr
8000f982:	1c 3b       	cp.w	r11,lr
8000f984:	c0 a2       	brcc	8000f998 <__avr32_umod64+0x1c4>
8000f986:	20 16       	sub	r6,1
8000f988:	10 0b       	add	r11,r8
8000f98a:	10 3b       	cp.w	r11,r8
8000f98c:	c0 63       	brcs	8000f998 <__avr32_umod64+0x1c4>
8000f98e:	1c 3b       	cp.w	r11,lr
8000f990:	f7 b6 03 01 	sublo	r6,1
8000f994:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000f998:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000f99c:	1c 1b       	sub	r11,lr
8000f99e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000f9a2:	00 9e       	mov	lr,r0
8000f9a4:	02 9c       	mov	r12,r1
8000f9a6:	16 3c       	cp.w	r12,r11
8000f9a8:	e0 8b 00 08 	brhi	8000f9b8 <__avr32_umod64+0x1e4>
8000f9ac:	5f 06       	sreq	r6
8000f9ae:	06 30       	cp.w	r0,r3
8000f9b0:	5f ba       	srhi	r10
8000f9b2:	ed ea 00 0a 	and	r10,r6,r10
8000f9b6:	c0 60       	breq	8000f9c2 <__avr32_umod64+0x1ee>
8000f9b8:	fc 02 01 04 	sub	r4,lr,r2
8000f9bc:	f8 08 01 4c 	sbc	r12,r12,r8
8000f9c0:	08 9e       	mov	lr,r4
8000f9c2:	e6 0e 01 0a 	sub	r10,r3,lr
8000f9c6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000f9ca:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000f9ce:	f8 09 0a 4b 	lsr	r11,r12,r9
8000f9d2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f9d6:	f8 01 09 4c 	lsl	r12,r12,r1
8000f9da:	18 4a       	or	r10,r12
8000f9dc:	2f dd       	sub	sp,-12
8000f9de:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000fa00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000fa00:	c0 08       	rjmp	8000fa00 <_evba>
	...

8000fa04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000fa04:	c0 08       	rjmp	8000fa04 <_handle_TLB_Multiple_Hit>
	...

8000fa08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000fa08:	c0 08       	rjmp	8000fa08 <_handle_Bus_Error_Data_Fetch>
	...

8000fa0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000fa0c:	c0 08       	rjmp	8000fa0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000fa10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000fa10:	c0 08       	rjmp	8000fa10 <_handle_NMI>
	...

8000fa14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000fa14:	c0 08       	rjmp	8000fa14 <_handle_Instruction_Address>
	...

8000fa18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000fa18:	c0 08       	rjmp	8000fa18 <_handle_ITLB_Protection>
	...

8000fa1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000fa1c:	c0 08       	rjmp	8000fa1c <_handle_Breakpoint>
	...

8000fa20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000fa20:	c0 08       	rjmp	8000fa20 <_handle_Illegal_Opcode>
	...

8000fa24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000fa24:	c0 08       	rjmp	8000fa24 <_handle_Unimplemented_Instruction>
	...

8000fa28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000fa28:	c0 08       	rjmp	8000fa28 <_handle_Privilege_Violation>
	...

8000fa2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000fa2c:	c0 08       	rjmp	8000fa2c <_handle_Floating_Point>
	...

8000fa30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000fa30:	c0 08       	rjmp	8000fa30 <_handle_Coprocessor_Absent>
	...

8000fa34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000fa34:	c0 08       	rjmp	8000fa34 <_handle_Data_Address_Read>
	...

8000fa38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000fa38:	c0 08       	rjmp	8000fa38 <_handle_Data_Address_Write>
	...

8000fa3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000fa3c:	c0 08       	rjmp	8000fa3c <_handle_DTLB_Protection_Read>
	...

8000fa40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000fa40:	c0 08       	rjmp	8000fa40 <_handle_DTLB_Protection_Write>
	...

8000fa44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000fa44:	c0 08       	rjmp	8000fa44 <_handle_DTLB_Modified>
	...

8000fa50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000fa50:	c0 08       	rjmp	8000fa50 <_handle_ITLB_Miss>
	...

8000fa60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000fa60:	c0 08       	rjmp	8000fa60 <_handle_DTLB_Miss_Read>
	...

8000fa70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000fa70:	c0 08       	rjmp	8000fa70 <_handle_DTLB_Miss_Write>
	...

8000fb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000fb00:	fe cf 71 f4 	sub	pc,pc,29172

8000fb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000fb04:	30 0c       	mov	r12,0
8000fb06:	fe b0 af a1 	rcall	80005a48 <_get_interrupt_handler>
8000fb0a:	58 0c       	cp.w	r12,0
8000fb0c:	f8 0f 17 10 	movne	pc,r12
8000fb10:	d6 03       	rete

8000fb12 <_int1>:
8000fb12:	30 1c       	mov	r12,1
8000fb14:	fe b0 af 9a 	rcall	80005a48 <_get_interrupt_handler>
8000fb18:	58 0c       	cp.w	r12,0
8000fb1a:	f8 0f 17 10 	movne	pc,r12
8000fb1e:	d6 03       	rete

8000fb20 <_int2>:
8000fb20:	30 2c       	mov	r12,2
8000fb22:	fe b0 af 93 	rcall	80005a48 <_get_interrupt_handler>
8000fb26:	58 0c       	cp.w	r12,0
8000fb28:	f8 0f 17 10 	movne	pc,r12
8000fb2c:	d6 03       	rete

8000fb2e <_int3>:
8000fb2e:	30 3c       	mov	r12,3
8000fb30:	fe b0 af 8c 	rcall	80005a48 <_get_interrupt_handler>
8000fb34:	58 0c       	cp.w	r12,0
8000fb36:	f8 0f 17 10 	movne	pc,r12
8000fb3a:	d6 03       	rete

8000fb3c <ipr_val>:
8000fb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000fb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fbfc:	d7 03 d7 03                                         ....
