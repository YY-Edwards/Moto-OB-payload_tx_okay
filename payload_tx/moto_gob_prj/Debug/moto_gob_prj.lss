
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a7f0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000011e4  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000dbe4  8000dbe4  0000dfe4  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a38  00000008  8000dbe8  0000e008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          000046c8  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00011ef8  00005108  00005108  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000ea40  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001268  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000027b0  00000000  00000000  0000fcd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002a0a9  00000000  00000000  00012488  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006da2  00000000  00000000  0003c531  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c87d  00000000  00000000  000432d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003004  00000000  00000000  0004fb50  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007542  00000000  00000000  00052b54  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000d428  00000000  00000000  0005a096  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001338  00000000  00000000  000674c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 91 50 	sub	pc,pc,-28336

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b1 54 	sub	pc,pc,-20140

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 7c       	ld.ub	r12,--r6

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 58       	eor	r8,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 20       	sub	r0,18
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 48       	sub	r8,-124
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	2f 0c       	sub	r12,-16
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	44 8c       	lddsp	r12,sp[0x120]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ca 00       	breq	80001fc6 <_trampoline+0x1fc2>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	65 f0       	ld.w	r0,r2[0x7c]
80002090:	00 00       	add	r0,r0
80002092:	0a 50       	eor	r0,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 1a 	mcall	800020fc <app_cfg+0x68>
8000209a:	49 a8       	lddpc	r8,80002100 <app_cfg+0x6c>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 a6       	lddpc	r6,80002104 <app_cfg+0x70>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 a4       	lddpc	r4,80002108 <app_cfg+0x74>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 32       	mov	r2,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 20       	mov	r0,2
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 d1       	brne	800020f2 <app_cfg+0x5e>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020ba:	f0 1f 00 15 	mcall	8000210c <app_cfg+0x78>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020be:	68 08       	ld.w	r8,r4[0x0]
800020c0:	58 08       	cp.w	r8,0
800020c2:	c0 71       	brne	800020d0 <app_cfg+0x3c>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800020c4:	f0 1f 00 13 	mcall	80002110 <app_cfg+0x7c>
					xcmp_enter_enhanced_OB_mode();
800020c8:	f0 1f 00 13 	mcall	80002114 <app_cfg+0x80>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020cc:	89 03       	st.w	r4[0x0],r3
800020ce:	c1 28       	rjmp	800020f2 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800020d0:	58 18       	cp.w	r8,1
800020d2:	c0 51       	brne	800020dc <app_cfg+0x48>
				{
					//xcmp_exit_device_control_mode();
					xcmp_audio_route_AMBE();
800020d4:	f0 1f 00 11 	mcall	80002118 <app_cfg+0x84>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d8:	89 00       	st.w	r4[0x0],r0
800020da:	c0 c8       	rjmp	800020f2 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020dc:	58 28       	cp.w	r8,2
800020de:	c0 31       	brne	800020e4 <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020e0:	89 02       	st.w	r4[0x0],r2
800020e2:	c0 88       	rjmp	800020f2 <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e4:	58 38       	cp.w	r8,3
800020e6:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020ea:	f7 b8 01 ff 	subne	r8,-1
800020ee:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f2:	0a 9b       	mov	r11,r5
800020f4:	0e 9c       	mov	r12,r7
800020f6:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x88>
	}
800020fa:	cd bb       	rjmp	800020b0 <app_cfg+0x1c>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	63 28       	ld.w	r8,r1[0x48]
80002100:	00 00       	add	r0,r0
80002102:	0a 48       	or	r8,r5
80002104:	00 00       	add	r0,r0
80002106:	0d 7c       	ld.ub	r12,--r6
80002108:	00 00       	add	r0,r0
8000210a:	0a 44       	or	r4,r5
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	46 3c       	lddsp	r12,sp[0x18c]
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	44 e0       	lddsp	r0,sp[0x138]
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	45 6c       	lddsp	r12,sp[0x158]
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	45 0c       	lddsp	r12,sp[0x140]
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	64 90       	ld.w	r0,r2[0x24]

80002120 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002120:	d4 01       	pushm	lr
  log("R");
80002122:	48 3c       	lddpc	r12,8000212c <app_payload_tx_proc+0xc>
80002124:	f0 1f 00 03 	mcall	80002130 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002128:	d8 02       	popm	pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	ca 08       	rjmp	8000226e <ButtonConfig_brdcst_func+0x5e>
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	69 b4       	ld.w	r4,r4[0x6c]

80002134 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002134:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002136:	48 3c       	lddpc	r12,80002140 <FD_brdcst_func+0xc>
80002138:	f0 1f 00 03 	mcall	80002144 <FD_brdcst_func+0x10>
	
}
8000213c:	d8 02       	popm	pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	ca 0c       	rcall	80002282 <ButtonConfig_brdcst_func+0x72>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	69 b4       	ld.w	r4,r4[0x6c]

80002148 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002148:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214a:	48 3c       	lddpc	r12,80002154 <FD_reply_func+0xc>
8000214c:	f0 1f 00 03 	mcall	80002158 <FD_reply_func+0x10>
	
	
}
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	ca 2c       	rcall	8000229a <ButtonConfig_brdcst_func+0x8a>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	69 b4       	ld.w	r4,r4[0x6c]

8000215c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000215c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000215e:	48 3c       	lddpc	r12,80002168 <FD_request_func+0xc>
80002160:	f0 1f 00 03 	mcall	8000216c <FD_request_func+0x10>
	
	
}
80002164:	d8 02       	popm	pc
80002166:	00 00       	add	r0,r0
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	ca 48       	rjmp	800022b2 <ButtonConfig_brdcst_func+0xa2>
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	69 b4       	ld.w	r4,r4[0x6c]

80002170 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002170:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002172:	48 3c       	lddpc	r12,8000217c <EnOB_brdcst_func+0xc>
80002174:	f0 1f 00 03 	mcall	80002180 <EnOB_brdcst_func+0x10>
}
80002178:	d8 02       	popm	pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	ca 64       	brge	800020ca <app_cfg+0x36>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	69 b4       	ld.w	r4,r4[0x6c]

80002184 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002184:	eb cd 40 80 	pushm	r7,lr
80002188:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218a:	19 a9       	ld.ub	r9,r12[0x2]
8000218c:	30 08       	mov	r8,0
8000218e:	f0 09 18 00 	cp.b	r9,r8
80002192:	c1 91       	brne	800021c4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002194:	19 b8       	ld.ub	r8,r12[0x3]
80002196:	30 19       	mov	r9,1
80002198:	f2 08 18 00 	cp.b	r8,r9
8000219c:	c0 61       	brne	800021a8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000219e:	49 0c       	lddpc	r12,800021dc <EnOB_reply_func+0x58>
800021a0:	f0 1f 00 10 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021a8:	58 08       	cp.w	r8,0
800021aa:	c0 61       	brne	800021b6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021ac:	48 ec       	lddpc	r12,800021e4 <EnOB_reply_func+0x60>
800021ae:	f0 1f 00 0d 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021b6:	1a d8       	st.w	--sp,r8
800021b8:	48 cc       	lddpc	r12,800021e8 <EnOB_reply_func+0x64>
800021ba:	f0 1f 00 0a 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021be:	2f fd       	sub	sp,-4
800021c0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c4:	48 ac       	lddpc	r12,800021ec <EnOB_reply_func+0x68>
800021c6:	f0 1f 00 07 	mcall	800021e0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ca:	0f a8       	ld.ub	r8,r7[0x2]
800021cc:	1a d8       	st.w	--sp,r8
800021ce:	48 9c       	lddpc	r12,800021f0 <EnOB_reply_func+0x6c>
800021d0:	f0 1f 00 04 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021d4:	2f fd       	sub	sp,-4
800021d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021da:	00 00       	add	r0,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	ca 7c       	rcall	8000232c <Phyuserinput_brdcst_func+0x40>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	69 b4       	ld.w	r4,r4[0x6c]
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	ca 94       	brge	80002138 <FD_brdcst_func+0x4>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	ca a8       	rjmp	8000233e <Phyuserinput_brdcst_func+0x52>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	ca c0       	breq	80002146 <FD_brdcst_func+0x12>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	ca dc       	rcall	8000234c <Phyuserinput_brdcst_func+0x60>

800021f4 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021f6:	19 a9       	ld.ub	r9,r12[0x2]
800021f8:	31 18       	mov	r8,17
800021fa:	f0 09 18 00 	cp.b	r9,r8
800021fe:	c0 41       	brne	80002206 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002200:	48 2c       	lddpc	r12,80002208 <SingleDetection_brdcst_func+0x14>
80002202:	f0 1f 00 03 	mcall	8000220c <SingleDetection_brdcst_func+0x18>
80002206:	d8 02       	popm	pc
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	ca f4       	brge	80002168 <FD_request_func+0xc>
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	69 b4       	ld.w	r4,r4[0x6c]

80002210 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002210:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002212:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002216:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002218:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xb4>
8000221a:	f0 1f 00 2c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000221e:	0f 88       	ld.ub	r8,r7[0x0]
80002220:	1a d8       	st.w	--sp,r8
80002222:	4a bc       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xbc>
80002224:	f0 1f 00 29 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002228:	1a d5       	st.w	--sp,r5
8000222a:	4a ac       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xc0>
8000222c:	f0 1f 00 27 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002230:	0f a8       	ld.ub	r8,r7[0x2]
80002232:	1a d8       	st.w	--sp,r8
80002234:	4a 8c       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc4>
80002236:	f0 1f 00 25 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223a:	2f dd       	sub	sp,-12
8000223c:	58 05       	cp.w	r5,0
8000223e:	c4 10       	breq	800022c0 <ButtonConfig_brdcst_func+0xb0>
80002240:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002242:	4a 64       	lddpc	r4,800022d8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002244:	4a 63       	lddpc	r3,800022dc <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002246:	4a 72       	lddpc	r2,800022e0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002248:	4a 71       	lddpc	r1,800022e4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224a:	4a 80       	lddpc	r0,800022e8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224c:	0f b9       	ld.ub	r9,r7[0x3]
8000224e:	0f c8       	ld.ub	r8,r7[0x4]
80002250:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002254:	1a d8       	st.w	--sp,r8
80002256:	1a d6       	st.w	--sp,r6
80002258:	08 9c       	mov	r12,r4
8000225a:	f0 1f 00 1c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225e:	0f d9       	ld.ub	r9,r7[0x5]
80002260:	0f e8       	ld.ub	r8,r7[0x6]
80002262:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002266:	1a d8       	st.w	--sp,r8
80002268:	1a d6       	st.w	--sp,r6
8000226a:	06 9c       	mov	r12,r3
8000226c:	f0 1f 00 17 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002270:	0f f9       	ld.ub	r9,r7[0x7]
80002272:	ef 38 00 08 	ld.ub	r8,r7[8]
80002276:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227a:	1a d8       	st.w	--sp,r8
8000227c:	1a d6       	st.w	--sp,r6
8000227e:	04 9c       	mov	r12,r2
80002280:	f0 1f 00 12 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002284:	ef 39 00 09 	ld.ub	r9,r7[9]
80002288:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000228c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002290:	1a d8       	st.w	--sp,r8
80002292:	1a d6       	st.w	--sp,r6
80002294:	02 9c       	mov	r12,r1
80002296:	f0 1f 00 0d 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229a:	2f 8d       	sub	sp,-32
8000229c:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	00 9c       	mov	r12,r0
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
800022b2:	2f f6       	sub	r6,-1
800022b4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022b6:	2f ed       	sub	sp,-8
800022b8:	ec 05 18 00 	cp.b	r5,r6
800022bc:	fe 9b ff c8 	brhi	8000224c <ButtonConfig_brdcst_func+0x3c>
800022c0:	d8 32       	popm	r0-r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	cb 08       	rjmp	80002426 <DataSession_brdcst_func+0x7e>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	69 b4       	ld.w	r4,r4[0x6c]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	cb 28       	rjmp	80002432 <DataSession_reply_func+0x6>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	cb 3c       	rcall	80002438 <DataSession_reply_func+0xc>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	cb 54       	brge	80002240 <ButtonConfig_brdcst_func+0x30>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	cb 74       	brge	80002248 <ButtonConfig_brdcst_func+0x38>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cb 9c       	rcall	80002450 <DataSession_reply_func+0x24>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	cb c4       	brge	8000225a <ButtonConfig_brdcst_func+0x4a>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	cb e8       	rjmp	80002462 <DataSession_reply_func+0x36>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	cc 10       	breq	8000226c <ButtonConfig_brdcst_func+0x5c>

800022ec <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f0:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f2:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f4:	19 c7       	ld.ub	r7,r12[0x4]
800022f6:	19 d8       	ld.ub	r8,r12[0x5]
800022f8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022fc:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022fe:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002300:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x58>
80002306:	f0 1f 00 11 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230a:	1a d6       	st.w	--sp,r6
8000230c:	49 0c       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x60>
8000230e:	f0 1f 00 0f 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002312:	1a d5       	st.w	--sp,r5
80002314:	48 fc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x64>
80002316:	f0 1f 00 0d 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231a:	5c 77       	castu.h	r7
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	48 ec       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x68>
80002320:	f0 1f 00 0a 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002324:	1a d4       	st.w	--sp,r4
80002326:	48 dc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x6c>
80002328:	f0 1f 00 08 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
8000232c:	1a d3       	st.w	--sp,r3
8000232e:	48 cc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x70>
80002330:	f0 1f 00 06 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002334:	1a d2       	st.w	--sp,r2
80002336:	48 bc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x74>
80002338:	f0 1f 00 04 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
8000233c:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000233e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002342:	00 00       	add	r0,r0
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	cc 34       	brge	800022cc <ButtonConfig_brdcst_func+0xbc>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	69 b4       	ld.w	r4,r4[0x6c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	cc 58       	rjmp	800024d8 <TransmitControl_brdcst_func+0x10>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	cc 70       	breq	800022e0 <ButtonConfig_brdcst_func+0xd0>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	cc 84       	brge	800022e6 <ButtonConfig_brdcst_func+0xd6>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	cc 98       	rjmp	800024ec <TransmitControl_brdcst_func+0x24>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	cc ac       	rcall	800024f2 <TransmitControl_brdcst_func+0x2a>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	cc cc       	rcall	800024fa <TransmitControl_brdcst_func+0x32>

80002364 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002364:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002368:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000236c:	0f 89       	ld.ub	r9,r7[0x0]
8000236e:	30 08       	mov	r8,0
80002370:	f0 09 18 00 	cp.b	r9,r8
80002374:	c0 c1       	brne	8000238c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002376:	48 9c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x34>
80002378:	f0 1f 00 09 	mcall	8000239c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000237c:	0f 98       	ld.ub	r8,r7[0x1]
8000237e:	1a d8       	st.w	--sp,r8
80002380:	48 8c       	lddpc	r12,800023a0 <ButtonConfig_reply_func+0x3c>
80002382:	f0 1f 00 07 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002386:	2f fd       	sub	sp,-4
80002388:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000238c:	48 6c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x40>
8000238e:	f0 1f 00 04 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002392:	e3 cd 80 80 	ldm	sp++,r7,pc
80002396:	00 00       	add	r0,r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	cc ec       	rcall	80002536 <TransmitControl_reply_func+0x26>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	69 b4       	ld.w	r4,r4[0x6c]
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	cb 28       	rjmp	80002506 <TransmitControl_brdcst_func+0x3e>
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	cd 04       	brge	80002346 <Phyuserinput_brdcst_func+0x5a>

800023a8 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a8:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023aa:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ae:	0d 88       	ld.ub	r8,r6[0x0]
800023b0:	32 49       	mov	r9,36
800023b2:	f2 08 18 00 	cp.b	r8,r9
800023b6:	c2 91       	brne	80002408 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b8:	49 7c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x6c>
800023ba:	f0 1f 00 18 	mcall	80002418 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023be:	0d a5       	ld.ub	r5,r6[0x2]
800023c0:	0d b8       	ld.ub	r8,r6[0x3]
800023c2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023c6:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c8:	0d 98       	ld.ub	r8,r6[0x1]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 4c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x74>
800023ce:	f0 1f 00 13 	mcall	80002418 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 2c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x78>
800023da:	f0 1f 00 10 	mcall	80002418 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023de:	2f ed       	sub	sp,-8
800023e0:	58 05       	cp.w	r5,0
800023e2:	c1 80       	breq	80002412 <DataSession_brdcst_func+0x6a>
800023e4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023e6:	49 04       	lddpc	r4,80002424 <DataSession_brdcst_func+0x7c>
800023e8:	ec 07 00 08 	add	r8,r6,r7
800023ec:	11 c8       	ld.ub	r8,r8[0x4]
800023ee:	1a d8       	st.w	--sp,r8
800023f0:	1a d7       	st.w	--sp,r7
800023f2:	08 9c       	mov	r12,r4
800023f4:	f0 1f 00 09 	mcall	80002418 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f8:	2f f7       	sub	r7,-1
800023fa:	5c 57       	castu.b	r7
800023fc:	2f ed       	sub	sp,-8
800023fe:	ee 05 19 00 	cp.h	r5,r7
80002402:	fe 9b ff f3 	brhi	800023e8 <DataSession_brdcst_func+0x40>
80002406:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002408:	1a d8       	st.w	--sp,r8
8000240a:	48 8c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x80>
8000240c:	f0 1f 00 03 	mcall	80002418 <DataSession_brdcst_func+0x70>
80002410:	2f fd       	sub	sp,-4
80002412:	d8 22       	popm	r4-r7,pc
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	cd 20       	breq	800023ba <DataSession_brdcst_func+0x12>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	69 b4       	ld.w	r4,r4[0x6c]
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	cd 34       	brge	800023c4 <DataSession_brdcst_func+0x1c>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	cd 4c       	rcall	800025ca <Volume_reply_func+0x2a>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	cd 68       	rjmp	800025d2 <Volume_reply_func+0x32>
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	cd 80       	breq	800023da <DataSession_brdcst_func+0x32>

8000242c <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000242c:	eb cd 40 80 	pushm	r7,lr
80002430:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002432:	19 a8       	ld.ub	r8,r12[0x2]
80002434:	58 08       	cp.w	r8,0
80002436:	c0 61       	brne	80002442 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002438:	48 dc       	lddpc	r12,8000246c <DataSession_reply_func+0x40>
8000243a:	f0 1f 00 0e 	mcall	80002470 <DataSession_reply_func+0x44>
8000243e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 cc       	lddpc	r12,80002474 <DataSession_reply_func+0x48>
80002446:	f0 1f 00 0b 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000244a:	48 cc       	lddpc	r12,80002478 <DataSession_reply_func+0x4c>
8000244c:	f0 1f 00 09 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002450:	0f b8       	ld.ub	r8,r7[0x3]
80002452:	1a d8       	st.w	--sp,r8
80002454:	48 ac       	lddpc	r12,8000247c <DataSession_reply_func+0x50>
80002456:	f0 1f 00 07 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000245a:	0f c8       	ld.ub	r8,r7[0x4]
8000245c:	1a d8       	st.w	--sp,r8
8000245e:	48 9c       	lddpc	r12,80002480 <DataSession_reply_func+0x54>
80002460:	f0 1f 00 04 	mcall	80002470 <DataSession_reply_func+0x44>
80002464:	2f dd       	sub	sp,-12
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	cd 94       	brge	80002420 <DataSession_brdcst_func+0x78>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	69 b4       	ld.w	r4,r4[0x6c]
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	cd a8       	rjmp	8000262a <spk_brdcst_func+0x26>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	cd bc       	rcall	80002630 <spk_brdcst_func+0x2c>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	cd d0       	breq	80002438 <DataSession_reply_func+0xc>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	cd e0       	breq	8000243e <DataSession_reply_func+0x12>

80002484 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
8000248c:	0f 98       	ld.ub	r8,r7[0x1]
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <CallControl_brdcst_func+0x38>
80002492:	f0 1f 00 0c 	mcall	800024c0 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002496:	2f fd       	sub	sp,-4
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 38       	mov	r8,3
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 41       	brne	800024a8 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024a2:	30 09       	mov	r9,0
800024a4:	48 88       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024a6:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024a8:	0f 99       	ld.ub	r9,r7[0x1]
800024aa:	30 48       	mov	r8,4
800024ac:	f0 09 18 00 	cp.b	r9,r8
800024b0:	c0 41       	brne	800024b8 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	cd f0       	breq	8000247c <DataSession_reply_func+0x50>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	69 b4       	ld.w	r4,r4[0x6c]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 4c       	or	r12,r5

800024c8 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024cc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024d0:	0f 99       	ld.ub	r9,r7[0x1]
800024d2:	30 08       	mov	r8,0
800024d4:	f0 09 18 00 	cp.b	r9,r8
800024d8:	c0 71       	brne	800024e6 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024da:	48 ac       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x38>
800024dc:	f0 1f 00 0a 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024e0:	30 09       	mov	r9,0
800024e2:	48 a8       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024e4:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024e6:	0f 99       	ld.ub	r9,r7[0x1]
800024e8:	30 18       	mov	r8,1
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024f0:	48 7c       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x44>
800024f2:	f0 1f 00 05 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024f6:	30 19       	mov	r9,1
800024f8:	48 48       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024fa:	b0 89       	st.b	r8[0x0],r9
800024fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	ce 08       	rjmp	800026c2 <mic_brdcst_func+0x3e>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	69 b4       	ld.w	r4,r4[0x6c]
80002508:	00 00       	add	r0,r0
8000250a:	0a 42       	or	r2,r5
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	ce 20       	breq	800024d2 <TransmitControl_brdcst_func+0xa>

80002510 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002510:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002514:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002518:	0f 89       	ld.ub	r9,r7[0x0]
8000251a:	30 08       	mov	r8,0
8000251c:	f0 09 18 00 	cp.b	r9,r8
80002520:	c1 61       	brne	8000254c <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002522:	48 ec       	lddpc	r12,80002558 <TransmitControl_reply_func+0x48>
80002524:	f0 1f 00 0e 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002528:	0f 98       	ld.ub	r8,r7[0x1]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 dc       	lddpc	r12,80002560 <TransmitControl_reply_func+0x50>
8000252e:	f0 1f 00 0c 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002532:	0f a8       	ld.ub	r8,r7[0x2]
80002534:	1a d8       	st.w	--sp,r8
80002536:	48 cc       	lddpc	r12,80002564 <TransmitControl_reply_func+0x54>
80002538:	f0 1f 00 09 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
8000253c:	0f b8       	ld.ub	r8,r7[0x3]
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 ac       	lddpc	r12,80002568 <TransmitControl_reply_func+0x58>
80002542:	f0 1f 00 07 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002546:	2f dd       	sub	sp,-12
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000254c:	48 8c       	lddpc	r12,8000256c <TransmitControl_reply_func+0x5c>
8000254e:	f0 1f 00 04 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002552:	e3 cd 80 80 	ldm	sp++,r7,pc
80002556:	00 00       	add	r0,r0
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	ce 34       	brge	80002520 <TransmitControl_reply_func+0x10>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	69 b4       	ld.w	r4,r4[0x6c]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	ce 50       	breq	8000252c <TransmitControl_reply_func+0x1c>
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	ce 64       	brge	80002532 <TransmitControl_reply_func+0x22>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	ce 80       	breq	8000253a <TransmitControl_reply_func+0x2a>
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	ce 90       	breq	80002540 <TransmitControl_reply_func+0x30>

80002570 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002570:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002572:	19 a9       	ld.ub	r9,r12[0x2]
80002574:	30 08       	mov	r8,0
80002576:	f0 09 18 00 	cp.b	r9,r8
8000257a:	c0 71       	brne	80002588 <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
8000257c:	48 5c       	lddpc	r12,80002590 <AudioRoutingControl_reply_func+0x20>
8000257e:	f0 1f 00 06 	mcall	80002594 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002582:	f0 1f 00 06 	mcall	80002598 <AudioRoutingControl_reply_func+0x28>
80002586:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002588:	48 5c       	lddpc	r12,8000259c <AudioRoutingControl_reply_func+0x2c>
8000258a:	f0 1f 00 03 	mcall	80002594 <AudioRoutingControl_reply_func+0x24>
8000258e:	d8 02       	popm	pc
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	ce a8       	rjmp	80002766 <mic_reply_func+0x8a>
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	69 b4       	ld.w	r4,r4[0x6c]
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	46 3c       	lddsp	r12,sp[0x18c]
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	ce b8       	rjmp	80002774 <dcm_brdcst_func+0x4>

800025a0 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025a0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025a4:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025a8:	0f 89       	ld.ub	r9,r7[0x0]
800025aa:	30 08       	mov	r8,0
800025ac:	f0 09 18 00 	cp.b	r9,r8
800025b0:	c1 b1       	brne	800025e6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025b2:	0f b8       	ld.ub	r8,r7[0x3]
800025b4:	31 09       	mov	r9,16
800025b6:	f2 08 18 00 	cp.b	r8,r9
800025ba:	c0 f1       	brne	800025d8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025bc:	48 dc       	lddpc	r12,800025f0 <Volume_reply_func+0x50>
800025be:	f0 1f 00 0e 	mcall	800025f4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c2:	0f 99       	ld.ub	r9,r7[0x1]
800025c4:	0f a8       	ld.ub	r8,r7[0x2]
800025c6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ca:	1a d8       	st.w	--sp,r8
800025cc:	48 bc       	lddpc	r12,800025f8 <Volume_reply_func+0x58>
800025ce:	f0 1f 00 0a 	mcall	800025f4 <Volume_reply_func+0x54>
800025d2:	2f fd       	sub	sp,-4
800025d4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025d8:	1a d8       	st.w	--sp,r8
800025da:	48 9c       	lddpc	r12,800025fc <Volume_reply_func+0x5c>
800025dc:	f0 1f 00 06 	mcall	800025f4 <Volume_reply_func+0x54>
800025e0:	2f fd       	sub	sp,-4
800025e2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025e6:	48 7c       	lddpc	r12,80002600 <Volume_reply_func+0x60>
800025e8:	f0 1f 00 03 	mcall	800025f4 <Volume_reply_func+0x54>
800025ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	ce cc       	rcall	800027ca <dcm_reply_func+0x12>
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	69 b4       	ld.w	r4,r4[0x6c]
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	ce e0       	breq	800025d6 <Volume_reply_func+0x36>
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	ce fc       	rcall	800027dc <dcm_reply_func+0x24>
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	cf 14       	brge	800025e4 <Volume_reply_func+0x44>

80002604 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002604:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002606:	19 d9       	ld.ub	r9,r12[0x5]
80002608:	30 08       	mov	r8,0
8000260a:	f0 09 18 00 	cp.b	r9,r8
8000260e:	c0 81       	brne	8000261e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002610:	10 99       	mov	r9,r8
80002612:	48 78       	lddpc	r8,8000262c <spk_brdcst_func+0x28>
80002614:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002616:	48 7c       	lddpc	r12,80002630 <spk_brdcst_func+0x2c>
80002618:	f0 1f 00 07 	mcall	80002634 <spk_brdcst_func+0x30>
8000261c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000261e:	30 19       	mov	r9,1
80002620:	48 38       	lddpc	r8,8000262c <spk_brdcst_func+0x28>
80002622:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002624:	48 5c       	lddpc	r12,80002638 <spk_brdcst_func+0x34>
80002626:	f0 1f 00 04 	mcall	80002634 <spk_brdcst_func+0x30>
8000262a:	d8 02       	popm	pc
8000262c:	00 00       	add	r0,r0
8000262e:	0a 40       	or	r0,r5
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	cf 2c       	rcall	80002816 <dcm_reply_func+0x5e>
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	69 b4       	ld.w	r4,r4[0x6c]
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	cf 3c       	rcall	80002820 <ToneControl_reply_func>

8000263c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000263c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000263e:	19 a9       	ld.ub	r9,r12[0x2]
80002640:	30 08       	mov	r8,0
80002642:	f0 09 18 00 	cp.b	r9,r8
80002646:	c0 f1       	brne	80002664 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002648:	19 e9       	ld.ub	r9,r12[0x6]
8000264a:	f0 09 18 00 	cp.b	r9,r8
8000264e:	c0 40       	breq	80002656 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002650:	30 19       	mov	r9,1
80002652:	48 98       	lddpc	r8,80002674 <spk_reply_func+0x38>
80002654:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002656:	19 e8       	ld.ub	r8,r12[0x6]
80002658:	1a d8       	st.w	--sp,r8
8000265a:	48 8c       	lddpc	r12,80002678 <spk_reply_func+0x3c>
8000265c:	f0 1f 00 08 	mcall	8000267c <spk_reply_func+0x40>
80002660:	2f fd       	sub	sp,-4
80002662:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002664:	30 09       	mov	r9,0
80002666:	48 48       	lddpc	r8,80002674 <spk_reply_func+0x38>
80002668:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000266a:	48 6c       	lddpc	r12,80002680 <spk_reply_func+0x44>
8000266c:	f0 1f 00 04 	mcall	8000267c <spk_reply_func+0x40>
80002670:	d8 02       	popm	pc
80002672:	00 00       	add	r0,r0
80002674:	00 00       	add	r0,r0
80002676:	0a 40       	or	r0,r5
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	cf 48       	rjmp	80002862 <app_payload_rx_proc+0x1a>
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	69 b4       	ld.w	r4,r4[0x6c]
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	cf 58       	rjmp	8000286c <app_payload_rx_proc+0x24>

80002684 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002684:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002688:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000268c:	0f a9       	ld.ub	r9,r7[0x2]
8000268e:	30 08       	mov	r8,0
80002690:	f0 09 18 00 	cp.b	r9,r8
80002694:	c0 71       	brne	800026a2 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002696:	48 dc       	lddpc	r12,800026c8 <mic_brdcst_func+0x44>
80002698:	f0 1f 00 0d 	mcall	800026cc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000269c:	30 09       	mov	r9,0
8000269e:	48 d8       	lddpc	r8,800026d0 <mic_brdcst_func+0x4c>
800026a0:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026a2:	0f a9       	ld.ub	r9,r7[0x2]
800026a4:	31 18       	mov	r8,17
800026a6:	f0 09 18 00 	cp.b	r9,r8
800026aa:	c0 d1       	brne	800026c4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026ac:	48 ac       	lddpc	r12,800026d4 <mic_brdcst_func+0x50>
800026ae:	f0 1f 00 08 	mcall	800026cc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026b2:	48 89       	lddpc	r9,800026d0 <mic_brdcst_func+0x4c>
800026b4:	30 18       	mov	r8,1
800026b6:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026b8:	13 89       	ld.ub	r9,r9[0x0]
800026ba:	f0 09 18 00 	cp.b	r9,r8
800026be:	c0 31       	brne	800026c4 <mic_brdcst_func+0x40>
800026c0:	48 68       	lddpc	r8,800026d8 <mic_brdcst_func+0x54>
800026c2:	11 88       	ld.ub	r8,r8[0x0]
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	cf 64       	brge	800026b6 <mic_brdcst_func+0x32>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	69 b4       	ld.w	r4,r4[0x6c]
800026d0:	00 00       	add	r0,r0
800026d2:	0a 54       	eor	r4,r5
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	cf 78       	rjmp	800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800026d8:	00 00       	add	r0,r0
800026da:	0a 4c       	or	r12,r5

800026dc <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026dc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026e0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e4:	49 ac       	lddpc	r12,8000274c <mic_reply_func+0x70>
800026e6:	f0 1f 00 1b 	mcall	80002750 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ea:	0f 89       	ld.ub	r9,r7[0x0]
800026ec:	30 08       	mov	r8,0
800026ee:	f0 09 18 00 	cp.b	r9,r8
800026f2:	c2 71       	brne	80002740 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f4:	0f 98       	ld.ub	r8,r7[0x1]
800026f6:	30 29       	mov	r9,2
800026f8:	f2 08 18 00 	cp.b	r8,r9
800026fc:	c1 b1       	brne	80002732 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026fe:	49 6c       	lddpc	r12,80002754 <mic_reply_func+0x78>
80002700:	f0 1f 00 14 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002704:	0f a8       	ld.ub	r8,r7[0x2]
80002706:	1a d8       	st.w	--sp,r8
80002708:	49 4c       	lddpc	r12,80002758 <mic_reply_func+0x7c>
8000270a:	f0 1f 00 12 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000270e:	0f b8       	ld.ub	r8,r7[0x3]
80002710:	1a d8       	st.w	--sp,r8
80002712:	49 3c       	lddpc	r12,8000275c <mic_reply_func+0x80>
80002714:	f0 1f 00 0f 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002718:	0f c8       	ld.ub	r8,r7[0x4]
8000271a:	1a d8       	st.w	--sp,r8
8000271c:	49 1c       	lddpc	r12,80002760 <mic_reply_func+0x84>
8000271e:	f0 1f 00 0d 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002722:	0f d8       	ld.ub	r8,r7[0x5]
80002724:	1a d8       	st.w	--sp,r8
80002726:	49 0c       	lddpc	r12,80002764 <mic_reply_func+0x88>
80002728:	f0 1f 00 0a 	mcall	80002750 <mic_reply_func+0x74>
8000272c:	2f cd       	sub	sp,-16
8000272e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002732:	1a d8       	st.w	--sp,r8
80002734:	48 dc       	lddpc	r12,80002768 <mic_reply_func+0x8c>
80002736:	f0 1f 00 07 	mcall	80002750 <mic_reply_func+0x74>
8000273a:	2f fd       	sub	sp,-4
8000273c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002740:	48 bc       	lddpc	r12,8000276c <mic_reply_func+0x90>
80002742:	f0 1f 00 04 	mcall	80002750 <mic_reply_func+0x74>
80002746:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274a:	00 00       	add	r0,r0
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	cf 8c       	rcall	8000293e <send_flash_command+0x72>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	69 b4       	ld.w	r4,r4[0x6c]
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	cf 9c       	rcall	80002948 <send_flash_command+0x7c>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	cf b0       	breq	80002750 <mic_reply_func+0x74>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	cf c4       	brge	80002756 <mic_reply_func+0x7a>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	cf e0       	breq	8000275e <mic_reply_func+0x82>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	cf f8       	rjmp	80002964 <send_flash_command+0x98>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d0 10       	acall	0x1
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	d0 28       	*unknown*

80002770 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002770:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002774:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002778:	48 bc       	lddpc	r12,800027a4 <dcm_brdcst_func+0x34>
8000277a:	f0 1f 00 0c 	mcall	800027a8 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000277e:	0f 88       	ld.ub	r8,r7[0x0]
80002780:	1a d8       	st.w	--sp,r8
80002782:	48 bc       	lddpc	r12,800027ac <dcm_brdcst_func+0x3c>
80002784:	f0 1f 00 09 	mcall	800027a8 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002788:	0f a8       	ld.ub	r8,r7[0x2]
8000278a:	1a d8       	st.w	--sp,r8
8000278c:	48 9c       	lddpc	r12,800027b0 <dcm_brdcst_func+0x40>
8000278e:	f0 1f 00 07 	mcall	800027a8 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002792:	0f 98       	ld.ub	r8,r7[0x1]
80002794:	1a d8       	st.w	--sp,r8
80002796:	48 8c       	lddpc	r12,800027b4 <dcm_brdcst_func+0x44>
80002798:	f0 1f 00 04 	mcall	800027a8 <dcm_brdcst_func+0x38>
8000279c:	2f dd       	sub	sp,-12
	
	
}
8000279e:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a2:	00 00       	add	r0,r0
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d0 38       	*unknown*
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	69 b4       	ld.w	r4,r4[0x6c]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d0 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	d0 60       	acall	0x6
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	d0 78       	*unknown*

800027b8 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027b8:	eb cd 40 80 	pushm	r7,lr
800027bc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027be:	19 a9       	ld.ub	r9,r12[0x2]
800027c0:	30 08       	mov	r8,0
800027c2:	f0 09 18 00 	cp.b	r9,r8
800027c6:	c1 b1       	brne	800027fc <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027c8:	19 b8       	ld.ub	r8,r12[0x3]
800027ca:	30 19       	mov	r9,1
800027cc:	f2 08 18 00 	cp.b	r8,r9
800027d0:	c0 51       	brne	800027da <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027d2:	48 ec       	lddpc	r12,80002808 <dcm_reply_func+0x50>
800027d4:	f0 1f 00 0e 	mcall	8000280c <dcm_reply_func+0x54>
800027d8:	c0 a8       	rjmp	800027ec <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027da:	58 08       	cp.w	r8,0
800027dc:	c0 51       	brne	800027e6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027de:	48 dc       	lddpc	r12,80002810 <dcm_reply_func+0x58>
800027e0:	f0 1f 00 0b 	mcall	8000280c <dcm_reply_func+0x54>
800027e4:	c0 48       	rjmp	800027ec <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027e6:	48 cc       	lddpc	r12,80002814 <dcm_reply_func+0x5c>
800027e8:	f0 1f 00 09 	mcall	8000280c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027ec:	0f d8       	ld.ub	r8,r7[0x5]
800027ee:	1a d8       	st.w	--sp,r8
800027f0:	48 ac       	lddpc	r12,80002818 <dcm_reply_func+0x60>
800027f2:	f0 1f 00 07 	mcall	8000280c <dcm_reply_func+0x54>
800027f6:	2f fd       	sub	sp,-4
800027f8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027fc:	48 8c       	lddpc	r12,8000281c <dcm_reply_func+0x64>
800027fe:	f0 1f 00 04 	mcall	8000280c <dcm_reply_func+0x54>
80002802:	e3 cd 80 80 	ldm	sp++,r7,pc
80002806:	00 00       	add	r0,r0
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	d0 94       	*unknown*
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	69 b4       	ld.w	r4,r4[0x6c]
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	d0 a8       	*unknown*
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	d0 bc       	*unknown*
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d0 d0       	acall	0xd
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	d0 dc       	*unknown*

80002820 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002820:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002822:	19 a9       	ld.ub	r9,r12[0x2]
80002824:	30 08       	mov	r8,0
80002826:	f0 09 18 00 	cp.b	r9,r8
8000282a:	c0 51       	brne	80002834 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
8000282c:	48 4c       	lddpc	r12,8000283c <ToneControl_reply_func+0x1c>
8000282e:	f0 1f 00 05 	mcall	80002840 <ToneControl_reply_func+0x20>
80002832:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002834:	48 4c       	lddpc	r12,80002844 <ToneControl_reply_func+0x24>
80002836:	f0 1f 00 03 	mcall	80002840 <ToneControl_reply_func+0x20>
8000283a:	d8 02       	popm	pc
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	d0 e8       	*unknown*
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	69 b4       	ld.w	r4,r4[0x6c]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d0 f0       	acall	0xf

80002848 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002848:	eb cd 40 80 	pushm	r7,lr
8000284c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000284e:	48 c9       	lddpc	r9,8000287c <app_payload_rx_proc+0x34>
80002850:	13 88       	ld.ub	r8,r9[0x0]
80002852:	2f f8       	sub	r8,-1
80002854:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002856:	30 39       	mov	r9,3
80002858:	f2 08 18 00 	cp.b	r8,r9
8000285c:	c0 71       	brne	8000286a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000285e:	30 09       	mov	r9,0
80002860:	48 78       	lddpc	r8,8000287c <app_payload_rx_proc+0x34>
80002862:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002864:	48 7c       	lddpc	r12,80002880 <app_payload_rx_proc+0x38>
80002866:	f0 1f 00 08 	mcall	80002884 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000286a:	48 88       	lddpc	r8,80002888 <app_payload_rx_proc+0x40>
8000286c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000286e:	48 88       	lddpc	r8,8000288c <app_payload_rx_proc+0x44>
80002870:	70 0c       	ld.w	r12,r8[0x0]
80002872:	0e 9b       	mov	r11,r7
80002874:	f0 1f 00 07 	mcall	80002890 <app_payload_rx_proc+0x48>

}
80002878:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287c:	00 00       	add	r0,r0
8000287e:	0a 56       	eor	r6,r5
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	d0 fc       	*unknown*
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	69 b4       	ld.w	r4,r4[0x6c]
80002888:	00 00       	add	r0,r0
8000288a:	0a 55       	eor	r5,r5
8000288c:	00 00       	add	r0,r0
8000288e:	0a 74       	tst	r4,r5
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	2f e4       	sub	r4,-2

80002894 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002894:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002896:	19 e8       	ld.ub	r8,r12[0x6]
80002898:	30 19       	mov	r9,1
8000289a:	f2 08 18 00 	cp.b	r8,r9
8000289e:	c0 61       	brne	800028aa <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a0:	48 98       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028a2:	70 09       	ld.w	r9,r8[0x0]
800028a4:	a1 a9       	sbr	r9,0x0
800028a6:	91 09       	st.w	r8[0x0],r9
800028a8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028aa:	30 29       	mov	r9,2
800028ac:	f2 08 18 00 	cp.b	r8,r9
800028b0:	c0 80       	breq	800028c0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028b2:	48 58       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b4:	70 09       	ld.w	r9,r8[0x0]
800028b6:	e0 19 ff fc 	andl	r9,0xfffc
800028ba:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028bc:	f0 1f 00 03 	mcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
800028c0:	d8 02       	popm	pc
800028c2:	00 00       	add	r0,r0
800028c4:	00 00       	add	r0,r0
800028c6:	0d 7c       	ld.ub	r12,--r6
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	45 90       	lddsp	r0,sp[0x164]

800028cc <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028cc:	eb cd 40 fc 	pushm	r2-r7,lr
800028d0:	20 1d       	sub	sp,4
800028d2:	18 97       	mov	r7,r12
800028d4:	14 95       	mov	r5,r10
800028d6:	12 96       	mov	r6,r9
	U16 status = 1;
800028d8:	30 18       	mov	r8,1
800028da:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028dc:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028e0:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
800028e4:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
800028e8:	30 0b       	mov	r11,0
800028ea:	4e 38       	lddpc	r8,80002a74 <send_flash_command+0x1a8>
800028ec:	70 0c       	ld.w	r12,r8[0x0]
800028ee:	f0 1f 00 63 	mcall	80002a78 <send_flash_command+0x1ac>

    switch (command)
800028f2:	30 58       	mov	r8,5
800028f4:	f0 07 19 00 	cp.h	r7,r8
800028f8:	c3 40       	breq	80002960 <send_flash_command+0x94>
800028fa:	e0 8b 00 18 	brhi	8000292a <send_flash_command+0x5e>
800028fe:	30 28       	mov	r8,2
80002900:	f0 07 19 00 	cp.h	r7,r8
80002904:	c5 e0       	breq	800029c0 <send_flash_command+0xf4>
80002906:	e0 8b 00 08 	brhi	80002916 <send_flash_command+0x4a>
8000290a:	30 18       	mov	r8,1
8000290c:	f0 07 19 00 	cp.h	r7,r8
80002910:	e0 81 00 a9 	brne	80002a62 <send_flash_command+0x196>
80002914:	c9 e8       	rjmp	80002a50 <send_flash_command+0x184>
80002916:	30 38       	mov	r8,3
80002918:	f0 07 19 00 	cp.h	r7,r8
8000291c:	c7 20       	breq	80002a00 <send_flash_command+0x134>
8000291e:	30 48       	mov	r8,4
80002920:	f0 07 19 00 	cp.h	r7,r8
80002924:	e0 81 00 9f 	brne	80002a62 <send_flash_command+0x196>
80002928:	c2 c8       	rjmp	80002980 <send_flash_command+0xb4>
8000292a:	35 28       	mov	r8,82
8000292c:	f0 07 19 00 	cp.h	r7,r8
80002930:	c2 f0       	breq	8000298e <send_flash_command+0xc2>
80002932:	e0 8b 00 0c 	brhi	8000294a <send_flash_command+0x7e>
80002936:	30 68       	mov	r8,6
80002938:	f0 07 19 00 	cp.h	r7,r8
8000293c:	c2 20       	breq	80002980 <send_flash_command+0xb4>
8000293e:	32 08       	mov	r8,32
80002940:	f0 07 19 00 	cp.h	r7,r8
80002944:	e0 81 00 8f 	brne	80002a62 <send_flash_command+0x196>
80002948:	c2 38       	rjmp	8000298e <send_flash_command+0xc2>
8000294a:	36 08       	mov	r8,96
8000294c:	f0 07 19 00 	cp.h	r7,r8
80002950:	c3 20       	breq	800029b4 <send_flash_command+0xe8>
80002952:	e0 68 00 d8 	mov	r8,216
80002956:	f0 07 19 00 	cp.h	r7,r8
8000295a:	e0 81 00 84 	brne	80002a62 <send_flash_command+0x196>
8000295e:	c1 88       	rjmp	8000298e <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002960:	4c 57       	lddpc	r7,80002a74 <send_flash_command+0x1a8>
80002962:	30 5b       	mov	r11,5
80002964:	6e 0c       	ld.w	r12,r7[0x0]
80002966:	f0 1f 00 46 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_dummy();
8000296a:	e0 6b 00 ff 	mov	r11,255
8000296e:	6e 0c       	ld.w	r12,r7[0x0]
80002970:	f0 1f 00 43 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_read_byte(&status);
80002974:	fa cb ff fe 	sub	r11,sp,-2
80002978:	6e 0c       	ld.w	r12,r7[0x0]
8000297a:	f0 1f 00 42 	mcall	80002a80 <send_flash_command+0x1b4>
			break;
8000297e:	c7 28       	rjmp	80002a62 <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002980:	0e 9b       	mov	r11,r7
80002982:	5c 7b       	castu.h	r11
80002984:	4b c8       	lddpc	r8,80002a74 <send_flash_command+0x1a8>
80002986:	70 0c       	ld.w	r12,r8[0x0]
80002988:	f0 1f 00 3d 	mcall	80002a7c <send_flash_command+0x1b0>
			break;
8000298c:	c6 b8       	rjmp	80002a62 <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
8000298e:	4b a6       	lddpc	r6,80002a74 <send_flash_command+0x1a8>
80002990:	0e 9b       	mov	r11,r7
80002992:	5c 7b       	castu.h	r11
80002994:	6c 0c       	ld.w	r12,r6[0x0]
80002996:	f0 1f 00 3a 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
8000299a:	08 9b       	mov	r11,r4
8000299c:	6c 0c       	ld.w	r12,r6[0x0]
8000299e:	f0 1f 00 38 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029a2:	06 9b       	mov	r11,r3
800029a4:	6c 0c       	ld.w	r12,r6[0x0]
800029a6:	f0 1f 00 36 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029aa:	04 9b       	mov	r11,r2
800029ac:	6c 0c       	ld.w	r12,r6[0x0]
800029ae:	f0 1f 00 34 	mcall	80002a7c <send_flash_command+0x1b0>
			break;
800029b2:	c5 88       	rjmp	80002a62 <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029b4:	36 0b       	mov	r11,96
800029b6:	4b 08       	lddpc	r8,80002a74 <send_flash_command+0x1a8>
800029b8:	70 0c       	ld.w	r12,r8[0x0]
800029ba:	f0 1f 00 31 	mcall	80002a7c <send_flash_command+0x1b0>
			break;
800029be:	c5 28       	rjmp	80002a62 <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029c0:	4a d7       	lddpc	r7,80002a74 <send_flash_command+0x1a8>
800029c2:	30 2b       	mov	r11,2
800029c4:	6e 0c       	ld.w	r12,r7[0x0]
800029c6:	f0 1f 00 2e 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029ca:	08 9b       	mov	r11,r4
800029cc:	6e 0c       	ld.w	r12,r7[0x0]
800029ce:	f0 1f 00 2c 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029d2:	06 9b       	mov	r11,r3
800029d4:	6e 0c       	ld.w	r12,r7[0x0]
800029d6:	f0 1f 00 2a 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029da:	04 9b       	mov	r11,r2
800029dc:	6e 0c       	ld.w	r12,r7[0x0]
800029de:	f0 1f 00 28 	mcall	80002a7c <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029e2:	58 06       	cp.w	r6,0
800029e4:	c3 f0       	breq	80002a62 <send_flash_command+0x196>
800029e6:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
800029e8:	4a 34       	lddpc	r4,80002a74 <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
800029ea:	0f 3b       	ld.ub	r11,r7++
800029ec:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
800029ee:	68 0c       	ld.w	r12,r4[0x0]
800029f0:	f0 1f 00 23 	mcall	80002a7c <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
800029f4:	0e 98       	mov	r8,r7
800029f6:	0a 18       	sub	r8,r5
800029f8:	ec 08 19 00 	cp.h	r8,r6
800029fc:	cf 73       	brcs	800029ea <send_flash_command+0x11e>
800029fe:	c3 28       	rjmp	80002a62 <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a00:	49 d7       	lddpc	r7,80002a74 <send_flash_command+0x1a8>
80002a02:	30 3b       	mov	r11,3
80002a04:	6e 0c       	ld.w	r12,r7[0x0]
80002a06:	f0 1f 00 1e 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a0a:	08 9b       	mov	r11,r4
80002a0c:	6e 0c       	ld.w	r12,r7[0x0]
80002a0e:	f0 1f 00 1c 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a12:	06 9b       	mov	r11,r3
80002a14:	6e 0c       	ld.w	r12,r7[0x0]
80002a16:	f0 1f 00 1a 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a1a:	04 9b       	mov	r11,r2
80002a1c:	6e 0c       	ld.w	r12,r7[0x0]
80002a1e:	f0 1f 00 18 	mcall	80002a7c <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a22:	58 06       	cp.w	r6,0
80002a24:	c1 f0       	breq	80002a62 <send_flash_command+0x196>
80002a26:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a28:	49 34       	lddpc	r4,80002a74 <send_flash_command+0x1a8>
80002a2a:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a2e:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a30:	06 9b       	mov	r11,r3
80002a32:	68 0c       	ld.w	r12,r4[0x0]
80002a34:	f0 1f 00 12 	mcall	80002a7c <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a38:	1a 9b       	mov	r11,sp
80002a3a:	68 0c       	ld.w	r12,r4[0x0]
80002a3c:	f0 1f 00 11 	mcall	80002a80 <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a40:	9a 08       	ld.sh	r8,sp[0x0]
80002a42:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a44:	0e 98       	mov	r8,r7
80002a46:	0a 18       	sub	r8,r5
80002a48:	ec 08 19 00 	cp.h	r8,r6
80002a4c:	cf 23       	brcs	80002a30 <send_flash_command+0x164>
80002a4e:	c0 a8       	rjmp	80002a62 <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a50:	48 97       	lddpc	r7,80002a74 <send_flash_command+0x1a8>
80002a52:	30 1b       	mov	r11,1
80002a54:	6e 0c       	ld.w	r12,r7[0x0]
80002a56:	f0 1f 00 0a 	mcall	80002a7c <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a5a:	30 0b       	mov	r11,0
80002a5c:	6e 0c       	ld.w	r12,r7[0x0]
80002a5e:	f0 1f 00 08 	mcall	80002a7c <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a62:	30 0b       	mov	r11,0
80002a64:	48 48       	lddpc	r8,80002a74 <send_flash_command+0x1a8>
80002a66:	70 0c       	ld.w	r12,r8[0x0]
80002a68:	f0 1f 00 07 	mcall	80002a84 <send_flash_command+0x1b8>

	return status;
}
80002a6c:	9a 1c       	ld.sh	r12,sp[0x2]
80002a6e:	2f fd       	sub	sp,-4
80002a70:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a74:	00 00       	add	r0,r0
80002a76:	1d 80       	ld.ub	r0,lr[0x0]
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	51 c0       	stdsp	sp[0x70],r0
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	52 fa       	stdsp	sp[0xbc],r10
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	53 16       	stdsp	sp[0xc4],r6
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	52 0c       	stdsp	sp[0x80],r12

80002a88 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002a88:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002a8a:	58 0a       	cp.w	r10,0
80002a8c:	5f 09       	sreq	r9
80002a8e:	e0 68 ff fe 	mov	r8,65534
80002a92:	ea 18 00 7f 	orh	r8,0x7f
80002a96:	10 3c       	cp.w	r12,r8
80002a98:	5f b8       	srhi	r8
80002a9a:	f3 e8 10 08 	or	r8,r9,r8
80002a9e:	c0 e1       	brne	80002aba <data_flash_read_block+0x32>
80002aa0:	e0 68 10 00 	mov	r8,4096
80002aa4:	f0 0b 19 00 	cp.h	r11,r8
80002aa8:	e0 8b 00 09 	brhi	80002aba <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002aac:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ab0:	18 9b       	mov	r11,r12
80002ab2:	30 3c       	mov	r12,3
80002ab4:	f0 1f 00 02 	mcall	80002abc <data_flash_read_block+0x34>
80002ab8:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002aba:	da 0a       	popm	pc,r12=1
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	28 cc       	sub	r12,-116

80002ac0 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ac0:	eb cd 40 e0 	pushm	r5-r7,lr
80002ac4:	18 96       	mov	r6,r12
80002ac6:	16 97       	mov	r7,r11
80002ac8:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002aca:	58 0c       	cp.w	r12,0
80002acc:	5f 09       	sreq	r9
80002ace:	e0 68 ff fe 	mov	r8,65534
80002ad2:	ea 18 00 7f 	orh	r8,0x7f
80002ad6:	10 3b       	cp.w	r11,r8
80002ad8:	5f b8       	srhi	r8
80002ada:	f3 e8 10 08 	or	r8,r9,r8
80002ade:	c3 91       	brne	80002b50 <data_flash_write_page+0x90>
80002ae0:	e0 68 01 00 	mov	r8,256
80002ae4:	f0 0a 19 00 	cp.h	r10,r8
80002ae8:	e0 8b 00 34 	brhi	80002b50 <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002aec:	30 09       	mov	r9,0
80002aee:	12 9a       	mov	r10,r9
80002af0:	12 9b       	mov	r11,r9
80002af2:	30 5c       	mov	r12,5
80002af4:	f0 1f 00 19 	mcall	80002b58 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002af8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002afc:	c0 30       	breq	80002b02 <data_flash_write_page+0x42>
80002afe:	30 27       	mov	r7,2
80002b00:	c2 98       	rjmp	80002b52 <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b02:	30 09       	mov	r9,0
80002b04:	12 9a       	mov	r10,r9
80002b06:	12 9b       	mov	r11,r9
80002b08:	30 6c       	mov	r12,6
80002b0a:	f0 1f 00 14 	mcall	80002b58 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002b0e:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002b12:	0c 9a       	mov	r10,r6
80002b14:	0e 9b       	mov	r11,r7
80002b16:	30 2c       	mov	r12,2
80002b18:	f0 1f 00 10 	mcall	80002b58 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b1c:	30 05       	mov	r5,0
80002b1e:	30 56       	mov	r6,5
80002b20:	0a 99       	mov	r9,r5
80002b22:	0a 9a       	mov	r10,r5
80002b24:	0a 9b       	mov	r11,r5
80002b26:	0c 9c       	mov	r12,r6
80002b28:	f0 1f 00 0c 	mcall	80002b58 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b2c:	5c 7c       	castu.h	r12
80002b2e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b32:	cf 71       	brne	80002b20 <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b34:	18 97       	mov	r7,r12
80002b36:	e2 17 00 20 	andl	r7,0x20,COH
80002b3a:	f9 b7 01 06 	movne	r7,6
80002b3e:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b42:	30 09       	mov	r9,0
80002b44:	12 9a       	mov	r10,r9
80002b46:	12 9b       	mov	r11,r9
80002b48:	30 4c       	mov	r12,4
80002b4a:	f0 1f 00 04 	mcall	80002b58 <data_flash_write_page+0x98>

	return return_code;
80002b4e:	c0 28       	rjmp	80002b52 <data_flash_write_page+0x92>
80002b50:	30 17       	mov	r7,1
}
80002b52:	0e 9c       	mov	r12,r7
80002b54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	28 cc       	sub	r12,-116

80002b5c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b5c:	d4 31       	pushm	r0-r7,lr
80002b5e:	18 94       	mov	r4,r12
80002b60:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b64:	16 97       	mov	r7,r11
80002b66:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b68:	30 03       	mov	r3,0
80002b6a:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b6c:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b70:	c4 98       	rjmp	80002c02 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b72:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b76:	c1 b1       	brne	80002bac <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b78:	e0 06 19 00 	cp.h	r6,r0
80002b7c:	e0 8b 00 0a 	brhi	80002b90 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b80:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002b84:	0e 9b       	mov	r11,r7
80002b86:	08 9c       	mov	r12,r4
80002b88:	f0 1f 00 24 	mcall	80002c18 <data_flash_write_block+0xbc>
80002b8c:	30 06       	mov	r6,0
80002b8e:	c3 a8       	rjmp	80002c02 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002b90:	e0 6a 01 00 	mov	r10,256
80002b94:	0e 9b       	mov	r11,r7
80002b96:	08 9c       	mov	r12,r4
80002b98:	f0 1f 00 20 	mcall	80002c18 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002b9c:	ec c6 01 00 	sub	r6,r6,256
80002ba0:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002ba2:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002ba6:	ee c7 ff 00 	sub	r7,r7,-256
80002baa:	c2 c8       	rjmp	80002c02 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002bac:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002bb0:	0e 09       	add	r9,r7
80002bb2:	0e 98       	mov	r8,r7
80002bb4:	e4 18 00 7f 	andh	r8,0x7f
80002bb8:	e0 18 ff 00 	andl	r8,0xff00
80002bbc:	f0 c8 ff 00 	sub	r8,r8,-256
80002bc0:	10 39       	cp.w	r9,r8
80002bc2:	e0 88 00 19 	brls	80002bf4 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002bc6:	0e 91       	mov	r1,r7
80002bc8:	5c 51       	castu.b	r1
80002bca:	e0 6a 01 00 	mov	r10,256
80002bce:	02 1a       	sub	r10,r1
80002bd0:	5c 7a       	castu.h	r10
80002bd2:	0e 9b       	mov	r11,r7
80002bd4:	08 9c       	mov	r12,r4
80002bd6:	f0 1f 00 11 	mcall	80002c18 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bda:	ec c6 01 00 	sub	r6,r6,256
80002bde:	02 06       	add	r6,r1
80002be0:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002be2:	e0 68 01 00 	mov	r8,256
80002be6:	f0 05 01 05 	sub	r5,r8,r5
80002bea:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002bec:	e0 17 ff 00 	andl	r7,0xff00
80002bf0:	10 07       	add	r7,r8
80002bf2:	c0 88       	rjmp	80002c02 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002bf4:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002bf8:	0e 9b       	mov	r11,r7
80002bfa:	08 9c       	mov	r12,r4
80002bfc:	f0 1f 00 07 	mcall	80002c18 <data_flash_write_block+0xbc>
80002c00:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002c02:	e6 06 19 00 	cp.h	r6,r3
80002c06:	5f 19       	srne	r9
80002c08:	58 7c       	cp.w	r12,7
80002c0a:	5f 08       	sreq	r8
80002c0c:	f3 e8 00 08 	and	r8,r9,r8
80002c10:	e4 08 18 00 	cp.b	r8,r2
80002c14:	ca f1       	brne	80002b72 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c16:	d8 32       	popm	r0-r7,pc
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	2a c0       	sub	r0,-84

80002c1c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c1c:	eb cd 40 c0 	pushm	r6-r7,lr
80002c20:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c22:	e0 68 ff fe 	mov	r8,65534
80002c26:	ea 18 00 7f 	orh	r8,0x7f
80002c2a:	10 3c       	cp.w	r12,r8
80002c2c:	e0 88 00 04 	brls	80002c34 <data_flash_erase_block+0x18>
80002c30:	30 17       	mov	r7,1
80002c32:	c3 e8       	rjmp	80002cae <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c34:	58 1b       	cp.w	r11,1
80002c36:	c0 31       	brne	80002c3c <data_flash_erase_block+0x20>
80002c38:	32 06       	mov	r6,32
80002c3a:	c0 a8       	rjmp	80002c4e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c3c:	58 2b       	cp.w	r11,2
80002c3e:	c0 31       	brne	80002c44 <data_flash_erase_block+0x28>
80002c40:	35 26       	mov	r6,82
80002c42:	c0 68       	rjmp	80002c4e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c44:	e0 66 00 d8 	mov	r6,216
80002c48:	58 3b       	cp.w	r11,3
80002c4a:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c4e:	30 09       	mov	r9,0
80002c50:	12 9a       	mov	r10,r9
80002c52:	12 9b       	mov	r11,r9
80002c54:	30 5c       	mov	r12,5
80002c56:	f0 1f 00 18 	mcall	80002cb4 <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c5a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c5e:	c0 30       	breq	80002c64 <data_flash_erase_block+0x48>
80002c60:	30 27       	mov	r7,2
80002c62:	c2 68       	rjmp	80002cae <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c64:	30 09       	mov	r9,0
80002c66:	12 9a       	mov	r10,r9
80002c68:	12 9b       	mov	r11,r9
80002c6a:	30 6c       	mov	r12,6
80002c6c:	f0 1f 00 12 	mcall	80002cb4 <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c70:	30 09       	mov	r9,0
80002c72:	12 9a       	mov	r10,r9
80002c74:	0e 9b       	mov	r11,r7
80002c76:	0c 9c       	mov	r12,r6
80002c78:	f0 1f 00 0f 	mcall	80002cb4 <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c7c:	30 06       	mov	r6,0
80002c7e:	30 57       	mov	r7,5
80002c80:	0c 99       	mov	r9,r6
80002c82:	0c 9a       	mov	r10,r6
80002c84:	0c 9b       	mov	r11,r6
80002c86:	0e 9c       	mov	r12,r7
80002c88:	f0 1f 00 0b 	mcall	80002cb4 <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c8c:	5c 7c       	castu.h	r12
80002c8e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c92:	cf 71       	brne	80002c80 <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c94:	18 97       	mov	r7,r12
80002c96:	e2 17 00 20 	andl	r7,0x20,COH
80002c9a:	f9 b7 01 04 	movne	r7,4
80002c9e:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002ca2:	30 09       	mov	r9,0
80002ca4:	12 9a       	mov	r10,r9
80002ca6:	12 9b       	mov	r11,r9
80002ca8:	30 4c       	mov	r12,4
80002caa:	f0 1f 00 03 	mcall	80002cb4 <data_flash_erase_block+0x98>

	return return_code;
}
80002cae:	0e 9c       	mov	r12,r7
80002cb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cb4:	80 00       	ld.sh	r0,r0[0x0]
80002cb6:	28 cc       	sub	r12,-116

80002cb8 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002cb8:	d4 31       	pushm	r0-r7,lr
80002cba:	20 3d       	sub	sp,12
80002cbc:	50 0c       	stdsp	sp[0x0],r12
80002cbe:	16 91       	mov	r1,r11
80002cc0:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cc2:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002cc6:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002cc8:	e0 69 10 00 	mov	r9,4096
80002ccc:	f2 0a 01 07 	sub	r7,r9,r10
80002cd0:	ea 07 19 00 	cp.h	r7,r5
80002cd4:	ea 07 17 b0 	movhi	r7,r5
80002cd8:	5c 87       	casts.h	r7
80002cda:	16 92       	mov	r2,r11
80002cdc:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002ce0:	4a e4       	lddpc	r4,80002d98 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002ce2:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002ce4:	e8 c8 ff ff 	sub	r8,r4,-1
80002ce8:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002cea:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cec:	08 9a       	mov	r10,r4
80002cee:	e0 6b 10 00 	mov	r11,4096
80002cf2:	04 9c       	mov	r12,r2
80002cf4:	f0 1f 00 2a 	mcall	80002d9c <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002cf8:	58 07       	cp.w	r7,0
80002cfa:	c3 00       	breq	80002d5a <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cfc:	40 13       	lddsp	r3,sp[0x4]
80002cfe:	5c 73       	castu.h	r3
80002d00:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002d04:	ec 08 18 00 	cp.b	r8,r6
80002d08:	c1 11       	brne	80002d2a <data_flash_write+0x72>
80002d0a:	e6 c9 ff ff 	sub	r9,r3,-1
80002d0e:	08 09       	add	r9,r4
80002d10:	30 08       	mov	r8,0
80002d12:	c0 58       	rjmp	80002d1c <data_flash_write+0x64>
80002d14:	13 3a       	ld.ub	r10,r9++
80002d16:	ec 0a 18 00 	cp.b	r10,r6
80002d1a:	c0 81       	brne	80002d2a <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d1c:	2f f8       	sub	r8,-1
80002d1e:	5c 88       	casts.h	r8
80002d20:	f0 07 19 00 	cp.h	r7,r8
80002d24:	fe 9b ff f8 	brhi	80002d14 <data_flash_write+0x5c>
80002d28:	c1 98       	rjmp	80002d5a <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d2a:	30 1b       	mov	r11,1
80002d2c:	04 9c       	mov	r12,r2
80002d2e:	f0 1f 00 1d 	mcall	80002da0 <data_flash_write+0xe8>
80002d32:	40 08       	lddsp	r8,sp[0x0]
80002d34:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d36:	40 2a       	lddsp	r10,sp[0x8]
80002d38:	40 19       	lddsp	r9,sp[0x4]
80002d3a:	12 0a       	add	r10,r9
80002d3c:	0e 99       	mov	r9,r7
80002d3e:	20 19       	sub	r9,1
80002d40:	5c 79       	castu.h	r9
80002d42:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d44:	11 39       	ld.ub	r9,r8++
80002d46:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d48:	14 33       	cp.w	r3,r10
80002d4a:	cf d1       	brne	80002d44 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d4c:	e0 6a 10 00 	mov	r10,4096
80002d50:	04 9b       	mov	r11,r2
80002d52:	08 9c       	mov	r12,r4
80002d54:	f0 1f 00 14 	mcall	80002da4 <data_flash_write+0xec>
80002d58:	c0 78       	rjmp	80002d66 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d5a:	0e 9a       	mov	r10,r7
80002d5c:	5c 7a       	castu.h	r10
80002d5e:	02 9b       	mov	r11,r1
80002d60:	40 0c       	lddsp	r12,sp[0x0]
80002d62:	f0 1f 00 11 	mcall	80002da4 <data_flash_write+0xec>
80002d66:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d6a:	0e 98       	mov	r8,r7
80002d6c:	ee 05 19 00 	cp.h	r5,r7
80002d70:	c1 20       	breq	80002d94 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d72:	5c 78       	castu.h	r8
80002d74:	40 0a       	lddsp	r10,sp[0x0]
80002d76:	10 0a       	add	r10,r8
80002d78:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d7a:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d7c:	0e 15       	sub	r5,r7
80002d7e:	5c 85       	casts.h	r5
80002d80:	e0 05 19 00 	cp.h	r5,r0
80002d84:	ea 07 17 80 	movls	r7,r5
80002d88:	e0 07 17 b0 	movhi	r7,r0
80002d8c:	5c 87       	casts.h	r7
80002d8e:	30 09       	mov	r9,0
80002d90:	50 19       	stdsp	sp[0x4],r9
80002d92:	ca db       	rjmp	80002cec <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002d94:	2f dd       	sub	sp,-12
80002d96:	d8 32       	popm	r0-r7,pc
80002d98:	00 00       	add	r0,r0
80002d9a:	0d 80       	ld.ub	r0,r6[0x0]
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	2a 88       	sub	r8,-88
80002da0:	80 00       	ld.sh	r0,r0[0x0]
80002da2:	2c 1c       	sub	r12,-63
80002da4:	80 00       	ld.sh	r0,r0[0x0]
80002da6:	2b 5c       	sub	r12,-75

80002da8 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002da8:	eb cd 40 c0 	pushm	r6-r7,lr
80002dac:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002dae:	4b f8       	lddpc	r8,80002ea8 <data_flash_init+0x100>
80002db0:	fa c6 ff fc 	sub	r6,sp,-4
80002db4:	f0 ea 00 00 	ld.d	r10,r8[0]
80002db8:	ec eb 00 00 	st.d	r6[0],r10
80002dbc:	f0 e8 00 08 	ld.d	r8,r8[8]
80002dc0:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002dc4:	30 4b       	mov	r11,4
80002dc6:	4b ac       	lddpc	r12,80002eac <data_flash_init+0x104>
80002dc8:	f0 1f 00 3a 	mcall	80002eb0 <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002dcc:	31 9c       	mov	r12,25
80002dce:	f0 1f 00 3a 	mcall	80002eb4 <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dd2:	31 9c       	mov	r12,25
80002dd4:	f0 1f 00 39 	mcall	80002eb8 <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002dd8:	4b 97       	lddpc	r7,80002ebc <data_flash_init+0x114>
80002dda:	fe 7c 24 00 	mov	r12,-56320
80002dde:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002de0:	0c 9b       	mov	r11,r6
80002de2:	f0 1f 00 38 	mcall	80002ec0 <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002de6:	30 09       	mov	r9,0
80002de8:	12 9a       	mov	r10,r9
80002dea:	12 9b       	mov	r11,r9
80002dec:	6e 0c       	ld.w	r12,r7[0x0]
80002dee:	f0 1f 00 36 	mcall	80002ec4 <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002df2:	6e 0c       	ld.w	r12,r7[0x0]
80002df4:	f0 1f 00 35 	mcall	80002ec8 <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
80002df8:	e0 6a 36 00 	mov	r10,13824
80002dfc:	ea 1a 01 6e 	orh	r10,0x16e
80002e00:	0c 9b       	mov	r11,r6
80002e02:	6e 0c       	ld.w	r12,r7[0x0]
80002e04:	f0 1f 00 32 	mcall	80002ecc <data_flash_init+0x124>
80002e08:	c0 50       	breq	80002e12 <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002e0a:	30 29       	mov	r9,2
80002e0c:	4b 18       	lddpc	r8,80002ed0 <data_flash_init+0x128>
80002e0e:	b0 89       	st.b	r8[0x0],r9
		return;
80002e10:	c4 88       	rjmp	80002ea0 <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002e12:	1a 96       	mov	r6,sp
80002e14:	30 4a       	mov	r10,4
80002e16:	4b 0b       	lddpc	r11,80002ed4 <data_flash_init+0x12c>
80002e18:	1a 9c       	mov	r12,sp
80002e1a:	f0 1f 00 30 	mcall	80002ed8 <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e1e:	4a 87       	lddpc	r7,80002ebc <data_flash_init+0x114>
80002e20:	30 0b       	mov	r11,0
80002e22:	6e 0c       	ld.w	r12,r7[0x0]
80002e24:	f0 1f 00 2e 	mcall	80002edc <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e28:	e0 6b 00 9f 	mov	r11,159
80002e2c:	6e 0c       	ld.w	r12,r7[0x0]
80002e2e:	f0 1f 00 2d 	mcall	80002ee0 <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e32:	e0 6b 00 ff 	mov	r11,255
80002e36:	6e 0c       	ld.w	r12,r7[0x0]
80002e38:	f0 1f 00 2a 	mcall	80002ee0 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e3c:	1a 9b       	mov	r11,sp
80002e3e:	6e 0c       	ld.w	r12,r7[0x0]
80002e40:	f0 1f 00 29 	mcall	80002ee4 <data_flash_init+0x13c>
	spi_write_dummy();
80002e44:	e0 6b 00 ff 	mov	r11,255
80002e48:	6e 0c       	ld.w	r12,r7[0x0]
80002e4a:	f0 1f 00 26 	mcall	80002ee0 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e4e:	fa cb ff fe 	sub	r11,sp,-2
80002e52:	6e 0c       	ld.w	r12,r7[0x0]
80002e54:	f0 1f 00 24 	mcall	80002ee4 <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e58:	30 0b       	mov	r11,0
80002e5a:	6e 0c       	ld.w	r12,r7[0x0]
80002e5c:	f0 1f 00 23 	mcall	80002ee8 <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e60:	31 f8       	mov	r8,31
80002e62:	9a 09       	ld.sh	r9,sp[0x0]
80002e64:	f0 09 19 00 	cp.h	r9,r8
80002e68:	c0 61       	brne	80002e74 <data_flash_init+0xcc>
80002e6a:	34 88       	mov	r8,72
80002e6c:	9a 19       	ld.sh	r9,sp[0x2]
80002e6e:	f0 09 19 00 	cp.h	r9,r8
80002e72:	c0 50       	breq	80002e7c <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e74:	30 39       	mov	r9,3
80002e76:	49 78       	lddpc	r8,80002ed0 <data_flash_init+0x128>
80002e78:	b0 89       	st.b	r8[0x0],r9
		return;
80002e7a:	c1 38       	rjmp	80002ea0 <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e7c:	30 09       	mov	r9,0
80002e7e:	12 9a       	mov	r10,r9
80002e80:	12 9b       	mov	r11,r9
80002e82:	30 6c       	mov	r12,6
80002e84:	f0 1f 00 1a 	mcall	80002eec <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002e88:	30 09       	mov	r9,0
80002e8a:	12 9a       	mov	r10,r9
80002e8c:	12 9b       	mov	r11,r9
80002e8e:	30 1c       	mov	r12,1
80002e90:	f0 1f 00 17 	mcall	80002eec <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002e94:	30 09       	mov	r9,0
80002e96:	12 9a       	mov	r10,r9
80002e98:	12 9b       	mov	r11,r9
80002e9a:	30 5c       	mov	r12,5
80002e9c:	f0 1f 00 14 	mcall	80002eec <data_flash_init+0x144>
	
	return;
}
80002ea0:	2f bd       	sub	sp,-20
80002ea2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ea6:	00 00       	add	r0,r0
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	d1 08       	*unknown*
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	d1 1c       	*unknown*
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	6e 4c       	ld.w	r12,r7[0x10]
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	6e 7c       	ld.w	r12,r7[0x1c]
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	6e 94       	ld.w	r4,r7[0x24]
80002ebc:	00 00       	add	r0,r0
80002ebe:	1d 80       	ld.ub	r0,lr[0x0]
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	51 5c       	stdsp	sp[0x54],r12
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	51 94       	stdsp	sp[0x64],r4
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	52 f4       	stdsp	sp[0xbc],r4
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	52 32       	stdsp	sp[0x8c],r2
80002ed0:	00 00       	add	r0,r0
80002ed2:	0a 5c       	eor	r12,r5
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	d1 18       	*unknown*
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	73 6e       	ld.w	lr,r9[0x58]
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	51 c0       	stdsp	sp[0x70],r0
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	52 fa       	stdsp	sp[0xbc],r10
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	53 16       	stdsp	sp[0xc4],r6
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	52 0c       	stdsp	sp[0x80],r12
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	28 cc       	sub	r12,-116

80002ef0 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002ef0:	20 1c       	sub	r12,1
80002ef2:	5c 5c       	castu.b	r12
80002ef4:	31 18       	mov	r8,17
80002ef6:	f0 0c 18 00 	cp.b	r12,r8
80002efa:	e0 88 00 03 	brls	80002f00 <CalculateBurst+0x10>
80002efe:	5e fd       	retal	0
80002f00:	48 28       	lddpc	r8,80002f08 <CalculateBurst+0x18>
80002f02:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002f06:	5e fc       	retal	r12
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	d1 44       	*unknown*

80002f0c <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002f0c:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002f0e:	48 98       	lddpc	r8,80002f30 <payload_init+0x24>
80002f10:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002f12:	48 98       	lddpc	r8,80002f34 <payload_init+0x28>
80002f14:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002f16:	30 09       	mov	r9,0
80002f18:	1a d9       	st.w	--sp,r9
80002f1a:	1a d9       	st.w	--sp,r9
80002f1c:	1a d9       	st.w	--sp,r9
80002f1e:	30 28       	mov	r8,2
80002f20:	e0 6a 04 00 	mov	r10,1024
80002f24:	48 5b       	lddpc	r11,80002f38 <payload_init+0x2c>
80002f26:	48 6c       	lddpc	r12,80002f3c <payload_init+0x30>
80002f28:	f0 1f 00 06 	mcall	80002f40 <payload_init+0x34>
80002f2c:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f2e:	d8 02       	popm	pc
80002f30:	00 00       	add	r0,r0
80002f32:	0a 60       	and	r0,r5
80002f34:	00 00       	add	r0,r0
80002f36:	0a 64       	and	r4,r5
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	d1 8c       	*unknown*
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	2f 44       	sub	r4,-12
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	65 f0       	ld.w	r0,r2[0x7c]

80002f44 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f44:	eb cd 40 f8 	pushm	r3-r7,lr
80002f48:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f4a:	48 e8       	lddpc	r8,80002f80 <payload_rx_process+0x3c>
80002f4c:	70 08       	ld.w	r8,r8[0x0]
80002f4e:	58 08       	cp.w	r8,0
80002f50:	c0 71       	brne	80002f5e <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f52:	30 4b       	mov	r11,4
80002f54:	30 5c       	mov	r12,5
80002f56:	f0 1f 00 0c 	mcall	80002f84 <payload_rx_process+0x40>
80002f5a:	48 a8       	lddpc	r8,80002f80 <payload_rx_process+0x3c>
80002f5c:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f5e:	48 96       	lddpc	r6,80002f80 <payload_rx_process+0x3c>
80002f60:	30 05       	mov	r5,0
80002f62:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f64:	48 93       	lddpc	r3,80002f88 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f66:	6c 0c       	ld.w	r12,r6[0x0]
80002f68:	0a 99       	mov	r9,r5
80002f6a:	08 9a       	mov	r10,r4
80002f6c:	1a 9b       	mov	r11,sp
80002f6e:	f0 1f 00 08 	mcall	80002f8c <payload_rx_process+0x48>
80002f72:	58 1c       	cp.w	r12,1
80002f74:	cf 91       	brne	80002f66 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f76:	66 08       	ld.w	r8,r3[0x0]
80002f78:	40 0c       	lddsp	r12,sp[0x0]
80002f7a:	5d 18       	icall	r8
80002f7c:	cf 5b       	rjmp	80002f66 <payload_rx_process+0x22>
80002f7e:	00 00       	add	r0,r0
80002f80:	00 00       	add	r0,r0
80002f82:	0a 90       	mov	r0,r5
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	5f 1c       	srne	r12
80002f88:	00 00       	add	r0,r0
80002f8a:	0a 60       	and	r0,r5
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	5c 10       	scr	r0

80002f90 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002f90:	d4 01       	pushm	lr
80002f92:	20 2d       	sub	sp,8
80002f94:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f96:	30 09       	mov	r9,0
80002f98:	fa ca ff f8 	sub	r10,sp,-8
80002f9c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002f9e:	1a 9b       	mov	r11,sp
80002fa0:	f0 1f 00 02 	mcall	80002fa8 <set_idle_store_isr+0x18>
}
80002fa4:	2f ed       	sub	sp,-8
80002fa6:	d8 02       	popm	pc
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	5d cc       	*unknown*

80002fac <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002fac:	d4 01       	pushm	lr
80002fae:	20 2d       	sub	sp,8
80002fb0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002fb2:	58 0c       	cp.w	r12,0
80002fb4:	c1 10       	breq	80002fd6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fb6:	30 08       	mov	r8,0
80002fb8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002fba:	98 88       	ld.uh	r8,r12[0x0]
80002fbc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fc0:	e0 48 40 00 	cp.w	r8,16384
80002fc4:	c0 91       	brne	80002fd6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002fc6:	48 68       	lddpc	r8,80002fdc <phy_rx+0x30>
80002fc8:	70 0c       	ld.w	r12,r8[0x0]
80002fca:	30 09       	mov	r9,0
80002fcc:	fa ca ff fc 	sub	r10,sp,-4
80002fd0:	1a 9b       	mov	r11,sp
80002fd2:	f0 1f 00 04 	mcall	80002fe0 <phy_rx+0x34>
		}	

    }
		
 
}
80002fd6:	2f ed       	sub	sp,-8
80002fd8:	d8 02       	popm	pc
80002fda:	00 00       	add	r0,r0
80002fdc:	00 00       	add	r0,r0
80002fde:	0a c0       	st.b	r5++,r0
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	5d cc       	*unknown*

80002fe4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002fe4:	eb cd 40 80 	pushm	r7,lr
80002fe8:	20 1d       	sub	sp,4
80002fea:	fa c7 ff fc 	sub	r7,sp,-4
80002fee:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002ff0:	30 09       	mov	r9,0
80002ff2:	12 9a       	mov	r10,r9
80002ff4:	1a 9b       	mov	r11,sp
80002ff6:	f0 1f 00 03 	mcall	80003000 <set_idle_store+0x1c>
}
80002ffa:	2f fd       	sub	sp,-4
80002ffc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	5e 1c       	retne	r12

80003004 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003004:	d4 01       	pushm	lr
80003006:	20 1d       	sub	sp,4
80003008:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
8000300a:	98 88       	ld.uh	r8,r12[0x0]
8000300c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003010:	e0 48 40 00 	cp.w	r8,16384
80003014:	c0 d1       	brne	8000302e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003016:	49 08       	lddpc	r8,80003054 <phy_tx+0x50>
80003018:	70 08       	ld.w	r8,r8[0x0]
8000301a:	58 08       	cp.w	r8,0
8000301c:	c1 a0       	breq	80003050 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000301e:	48 e8       	lddpc	r8,80003054 <phy_tx+0x50>
80003020:	70 0c       	ld.w	r12,r8[0x0]
80003022:	30 09       	mov	r9,0
80003024:	12 9a       	mov	r10,r9
80003026:	1a 9b       	mov	r11,sp
80003028:	f0 1f 00 0c 	mcall	80003058 <phy_tx+0x54>
8000302c:	c1 28       	rjmp	80003050 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000302e:	e0 48 10 00 	cp.w	r8,4096
80003032:	5f 0a       	sreq	r10
80003034:	e0 48 20 00 	cp.w	r8,8192
80003038:	5f 09       	sreq	r9
8000303a:	f5 e9 10 09 	or	r9,r10,r9
8000303e:	c0 71       	brne	8000304c <phy_tx+0x48>
80003040:	e0 48 50 00 	cp.w	r8,20480
80003044:	c0 40       	breq	8000304c <phy_tx+0x48>
80003046:	e0 48 60 00 	cp.w	r8,24576
8000304a:	c0 31       	brne	80003050 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
8000304c:	48 48       	lddpc	r8,8000305c <phy_tx+0x58>
8000304e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003050:	2f fd       	sub	sp,-4
80003052:	d8 02       	popm	pc
80003054:	00 00       	add	r0,r0
80003056:	0a cc       	st.b	r5++,r12
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	5e 1c       	retne	r12
8000305c:	00 00       	add	r0,r0
8000305e:	0a bc       	st.h	r5++,r12

80003060 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003060:	d4 01       	pushm	lr
80003062:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003064:	30 08       	mov	r8,0
80003066:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003068:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
8000306a:	1a 9a       	mov	r10,sp
8000306c:	fa cb ff fc 	sub	r11,sp,-4
80003070:	f0 1f 00 05 	mcall	80003084 <get_idle_store_isr+0x24>
80003074:	58 1c       	cp.w	r12,1
80003076:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000307a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
8000307e:	2f ed       	sub	sp,-8
80003080:	d8 02       	popm	pc
80003082:	00 00       	add	r0,r0
80003084:	80 00       	ld.sh	r0,r0[0x0]
80003086:	5b 20       	cp.w	r0,-14

80003088 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003088:	eb cd 40 c0 	pushm	r6-r7,lr
8000308c:	20 1d       	sub	sp,4
8000308e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003090:	fe f8 04 70 	ld.w	r8,pc[1136]
80003094:	70 08       	ld.w	r8,r8[0x0]
80003096:	58 08       	cp.w	r8,0
80003098:	c7 40       	breq	80003180 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
8000309a:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000309c:	30 08       	mov	r8,0
8000309e:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800030a0:	fe f8 04 64 	ld.w	r8,pc[1124]
800030a4:	70 08       	ld.w	r8,r8[0x0]
800030a6:	58 18       	cp.w	r8,1
800030a8:	c2 90       	breq	800030fa <phy_tx_func+0x72>
800030aa:	c0 43       	brcs	800030b2 <phy_tx_func+0x2a>
800030ac:	58 28       	cp.w	r8,2
800030ae:	c6 91       	brne	80003180 <phy_tx_func+0xf8>
800030b0:	c6 18       	rjmp	80003172 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800030b2:	fe f8 04 4e 	ld.w	r8,pc[1102]
800030b6:	70 0c       	ld.w	r12,r8[0x0]
800030b8:	1a 9a       	mov	r10,sp
800030ba:	fe fb 04 4e 	ld.w	r11,pc[1102]
800030be:	f0 1f 01 14 	mcall	8000350c <phy_tx_func+0x484>
800030c2:	58 1c       	cp.w	r12,1
800030c4:	c1 51       	brne	800030ee <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030c6:	fe f8 04 42 	ld.w	r8,pc[1090]
800030ca:	70 08       	ld.w	r8,r8[0x0]
800030cc:	11 9a       	ld.ub	r10,r8[0x1]
800030ce:	fe f9 04 42 	ld.w	r9,pc[1090]
800030d2:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030d4:	90 88       	ld.uh	r8,r8[0x0]
800030d6:	ea 18 ab cd 	orh	r8,0xabcd
800030da:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030dc:	30 19       	mov	r9,1
800030de:	fe f8 04 36 	ld.w	r8,pc[1078]
800030e2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800030e4:	30 19       	mov	r9,1
800030e6:	fe f8 04 1e 	ld.w	r8,pc[1054]
800030ea:	91 09       	st.w	r8[0x0],r9
800030ec:	c4 a8       	rjmp	80003180 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800030ee:	e0 68 5a 5a 	mov	r8,23130
800030f2:	ea 18 ab cd 	orh	r8,0xabcd
800030f6:	8f 18       	st.w	r7[0x4],r8
800030f8:	c4 48       	rjmp	80003180 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800030fa:	fe f9 04 1a 	ld.w	r9,pc[1050]
800030fe:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003100:	fe fa 04 08 	ld.w	r10,pc[1032]
80003104:	74 0a       	ld.w	r10,r10[0x0]
80003106:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
8000310a:	b1 6a       	lsl	r10,0x10
8000310c:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000310e:	2f f8       	sub	r8,-1
80003110:	5c 58       	castu.b	r8
80003112:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003114:	fe fa 03 fc 	ld.w	r10,pc[1020]
80003118:	94 09       	ld.sh	r9,r10[0x0]
8000311a:	20 29       	sub	r9,2
8000311c:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000311e:	30 0a       	mov	r10,0
80003120:	f4 09 19 00 	cp.h	r9,r10
80003124:	e0 89 00 0b 	brgt	8000313a <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003128:	78 18       	ld.w	r8,r12[0x4]
8000312a:	e8 18 00 ba 	orl	r8,0xba
8000312e:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003130:	30 09       	mov	r9,0
80003132:	fe f8 03 d2 	ld.w	r8,pc[978]
80003136:	91 09       	st.w	r8[0x0],r9
80003138:	c2 48       	rjmp	80003180 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
8000313a:	fe f9 03 ce 	ld.w	r9,pc[974]
8000313e:	72 09       	ld.w	r9,r9[0x0]
80003140:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003144:	78 1a       	ld.w	r10,r12[0x4]
80003146:	f5 e9 10 09 	or	r9,r10,r9
8000314a:	99 19       	st.w	r12[0x4],r9
8000314c:	2f f8       	sub	r8,-1
8000314e:	fe f9 03 c6 	ld.w	r9,pc[966]
80003152:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003154:	fe f9 03 bc 	ld.w	r9,pc[956]
80003158:	92 08       	ld.sh	r8,r9[0x0]
8000315a:	20 28       	sub	r8,2
8000315c:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000315e:	30 09       	mov	r9,0
80003160:	f2 08 19 00 	cp.h	r8,r9
80003164:	e0 89 00 0e 	brgt	80003180 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003168:	30 29       	mov	r9,2
8000316a:	fe f8 03 9a 	ld.w	r8,pc[922]
8000316e:	91 09       	st.w	r8[0x0],r9
80003170:	c0 88       	rjmp	80003180 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003172:	fc 18 00 ba 	movh	r8,0xba
80003176:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003178:	30 09       	mov	r9,0
8000317a:	fe f8 03 8a 	ld.w	r8,pc[906]
8000317e:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80003180:	fe f8 03 98 	ld.w	r8,pc[920]
80003184:	11 89       	ld.ub	r9,r8[0x0]
80003186:	30 18       	mov	r8,1
80003188:	f0 09 18 00 	cp.b	r9,r8
8000318c:	e0 81 01 af 	brne	800034ea <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003190:	fe f8 03 8c 	ld.w	r8,pc[908]
80003194:	70 08       	ld.w	r8,r8[0x0]
80003196:	e0 48 05 b0 	cp.w	r8,1456
8000319a:	f9 b8 02 00 	movhs	r8,0
8000319e:	fe f9 03 7e 	ld.w	r9,pc[894]
800031a2:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
800031a4:	fe f8 03 7c 	ld.w	r8,pc[892]
800031a8:	70 08       	ld.w	r8,r8[0x0]
800031aa:	58 68       	cp.w	r8,6
800031ac:	e0 8b 01 95 	brhi	800034d6 <phy_tx_func+0x44e>
800031b0:	fe f9 03 74 	ld.w	r9,pc[884]
800031b4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
800031b8:	fe f8 03 70 	ld.w	r8,pc[880]
800031bc:	70 08       	ld.w	r8,r8[0x0]
800031be:	58 08       	cp.w	r8,0
800031c0:	c0 b0       	breq	800031d6 <phy_tx_func+0x14e>
800031c2:	fe f8 03 66 	ld.w	r8,pc[870]
800031c6:	70 08       	ld.w	r8,r8[0x0]
800031c8:	58 a8       	cp.w	r8,10
800031ca:	c0 60       	breq	800031d6 <phy_tx_func+0x14e>
800031cc:	fe f8 03 5c 	ld.w	r8,pc[860]
800031d0:	70 08       	ld.w	r8,r8[0x0]
800031d2:	58 18       	cp.w	r8,1
800031d4:	c0 a1       	brne	800031e8 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800031d6:	e0 68 5a 5a 	mov	r8,23130
800031da:	ea 18 ab cd 	orh	r8,0xabcd
800031de:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800031e0:	30 08       	mov	r8,0
800031e2:	8f 38       	st.w	r7[0xc],r8
800031e4:	e0 8f 01 8a 	bral	800034f8 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
800031e8:	fe f8 03 40 	ld.w	r8,pc[832]
800031ec:	70 08       	ld.w	r8,r8[0x0]
800031ee:	58 38       	cp.w	r8,3
800031f0:	c0 91       	brne	80003202 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
800031f2:	fe f8 03 3a 	ld.w	r8,pc[826]
800031f6:	70 09       	ld.w	r9,r8[0x0]
800031f8:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
800031fa:	70 18       	ld.w	r8,r8[0x4]
800031fc:	8f 38       	st.w	r7[0xc],r8
800031fe:	e0 8f 01 7d 	bral	800034f8 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80003202:	fe f8 03 26 	ld.w	r8,pc[806]
80003206:	70 08       	ld.w	r8,r8[0x0]
80003208:	58 28       	cp.w	r8,2
8000320a:	c1 31       	brne	80003230 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
8000320c:	e0 68 c0 32 	mov	r8,49202
80003210:	ea 18 ab cd 	orh	r8,0xabcd
80003214:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80003216:	fe 78 84 7f 	mov	r8,-31617
8000321a:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
8000321c:	fe f8 03 14 	ld.w	r8,pc[788]
80003220:	90 08       	ld.sh	r8,r8[0x0]
80003222:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80003224:	30 39       	mov	r9,3
80003226:	fe f8 02 fa 	ld.w	r8,pc[762]
8000322a:	91 09       	st.w	r8[0x0],r9
8000322c:	e0 8f 01 66 	bral	800034f8 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003230:	e0 68 c0 0e 	mov	r8,49166
80003234:	ea 18 ab cd 	orh	r8,0xabcd
80003238:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
8000323a:	fe f8 02 fa 	ld.w	r8,pc[762]
8000323e:	90 09       	ld.sh	r9,r8[0x0]
80003240:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80003242:	90 18       	ld.sh	r8,r8[0x2]
80003244:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80003246:	30 19       	mov	r9,1
80003248:	fe f8 02 d8 	ld.w	r8,pc[728]
8000324c:	91 09       	st.w	r8[0x0],r9
8000324e:	e0 8f 01 55 	bral	800034f8 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003252:	fe 78 88 f2 	mov	r8,-30478
80003256:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80003258:	fe f8 02 d0 	ld.w	r8,pc[720]
8000325c:	70 08       	ld.w	r8,r8[0x0]
8000325e:	58 48       	cp.w	r8,4
80003260:	c0 60       	breq	8000326c <phy_tx_func+0x1e4>
80003262:	c4 53       	brcs	800032ec <phy_tx_func+0x264>
80003264:	58 98       	cp.w	r8,9
80003266:	e0 8b 00 43 	brhi	800032ec <phy_tx_func+0x264>
8000326a:	c2 98       	rjmp	800032bc <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
8000326c:	fe f8 02 cc 	ld.w	r8,pc[716]
80003270:	11 89       	ld.ub	r9,r8[0x0]
80003272:	30 18       	mov	r8,1
80003274:	f0 09 18 00 	cp.b	r9,r8
80003278:	c0 a1       	brne	8000328c <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
8000327a:	fe f8 02 c2 	ld.w	r8,pc[706]
8000327e:	90 09       	ld.sh	r9,r8[0x0]
80003280:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003282:	90 19       	ld.sh	r9,r8[0x2]
80003284:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003286:	90 28       	ld.sh	r8,r8[0x4]
80003288:	ae 78       	st.h	r7[0xe],r8
8000328a:	c1 48       	rjmp	800032b2 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000328c:	fe f9 02 b4 	ld.w	r9,pc[692]
80003290:	92 0b       	ld.sh	r11,r9[0x0]
80003292:	fe f8 02 aa 	ld.w	r8,pc[682]
80003296:	90 0a       	ld.sh	r10,r8[0x0]
80003298:	f7 ea 20 0a 	eor	r10,r11,r10
8000329c:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
8000329e:	92 1b       	ld.sh	r11,r9[0x2]
800032a0:	90 1a       	ld.sh	r10,r8[0x2]
800032a2:	f7 ea 20 0a 	eor	r10,r11,r10
800032a6:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032a8:	92 29       	ld.sh	r9,r9[0x4]
800032aa:	90 28       	ld.sh	r8,r8[0x4]
800032ac:	f3 e8 20 08 	eor	r8,r9,r8
800032b0:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032b2:	30 29       	mov	r9,2
800032b4:	fe f8 02 6c 	ld.w	r8,pc[620]
800032b8:	91 09       	st.w	r8[0x0],r9
800032ba:	c1 f9       	rjmp	800034f8 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032bc:	fe f9 02 84 	ld.w	r9,pc[644]
800032c0:	92 0b       	ld.sh	r11,r9[0x0]
800032c2:	fe f8 02 7a 	ld.w	r8,pc[634]
800032c6:	90 0a       	ld.sh	r10,r8[0x0]
800032c8:	f7 ea 20 0a 	eor	r10,r11,r10
800032cc:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032ce:	92 1b       	ld.sh	r11,r9[0x2]
800032d0:	90 1a       	ld.sh	r10,r8[0x2]
800032d2:	f7 ea 20 0a 	eor	r10,r11,r10
800032d6:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032d8:	92 29       	ld.sh	r9,r9[0x4]
800032da:	90 28       	ld.sh	r8,r8[0x4]
800032dc:	f3 e8 20 08 	eor	r8,r9,r8
800032e0:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032e2:	30 29       	mov	r9,2
800032e4:	fe f8 02 3c 	ld.w	r8,pc[572]
800032e8:	91 09       	st.w	r8[0x0],r9
800032ea:	c0 79       	rjmp	800034f8 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800032ec:	e0 68 5a 5a 	mov	r8,23130
800032f0:	ea 18 ab cd 	orh	r8,0xabcd
800032f4:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800032f6:	30 08       	mov	r8,0
800032f8:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
800032fa:	fe f9 02 26 	ld.w	r9,pc[550]
800032fe:	93 08       	st.w	r9[0x0],r8
80003300:	cf c8       	rjmp	800034f8 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80003302:	fe f8 02 3e 	ld.w	r8,pc[574]
80003306:	90 38       	ld.sh	r8,r8[0x6]
80003308:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
8000330a:	e0 68 00 ba 	mov	r8,186
8000330e:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003310:	30 08       	mov	r8,0
80003312:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003314:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80003316:	30 09       	mov	r9,0
80003318:	fe f8 02 08 	ld.w	r8,pc[520]
8000331c:	91 09       	st.w	r8[0x0],r9
8000331e:	ce d8       	rjmp	800034f8 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80003320:	fe f8 02 10 	ld.w	r8,pc[528]
80003324:	90 18       	ld.sh	r8,r8[0x2]
80003326:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80003328:	fe f8 02 0c 	ld.w	r8,pc[524]
8000332c:	90 08       	ld.sh	r8,r8[0x0]
8000332e:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80003330:	4f e8       	lddpc	r8,80003528 <phy_tx_func+0x4a0>
80003332:	70 08       	ld.w	r8,r8[0x0]
80003334:	58 48       	cp.w	r8,4
80003336:	c0 d1       	brne	80003350 <phy_tx_func+0x2c8>
80003338:	fe f8 02 00 	ld.w	r8,pc[512]
8000333c:	11 89       	ld.ub	r9,r8[0x0]
8000333e:	30 18       	mov	r8,1
80003340:	f0 09 18 00 	cp.b	r9,r8
80003344:	c0 61       	brne	80003350 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80003346:	4f c8       	lddpc	r8,80003534 <phy_tx_func+0x4ac>
80003348:	90 18       	ld.sh	r8,r8[0x2]
8000334a:	a9 a8       	sbr	r8,0x8
8000334c:	ae 68       	st.h	r7[0xc],r8
8000334e:	c0 48       	rjmp	80003356 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80003350:	4f 98       	lddpc	r8,80003534 <phy_tx_func+0x4ac>
80003352:	90 18       	ld.sh	r8,r8[0x2]
80003354:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80003356:	fe 78 9a 13 	mov	r8,-26093
8000335a:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
8000335c:	30 49       	mov	r9,4
8000335e:	4f 18       	lddpc	r8,80003520 <phy_tx_func+0x498>
80003360:	91 09       	st.w	r8[0x0],r9
80003362:	cc b8       	rjmp	800034f8 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80003364:	4f 88       	lddpc	r8,80003544 <phy_tx_func+0x4bc>
80003366:	70 0a       	ld.w	r10,r8[0x0]
80003368:	4f 89       	lddpc	r9,80003548 <phy_tx_func+0x4c0>
8000336a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000336e:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80003370:	70 0a       	ld.w	r10,r8[0x0]
80003372:	2f fa       	sub	r10,-1
80003374:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003378:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
8000337a:	70 0a       	ld.w	r10,r8[0x0]
8000337c:	2f ea       	sub	r10,-2
8000337e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003382:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80003384:	70 0a       	ld.w	r10,r8[0x0]
80003386:	2f da       	sub	r10,-3
80003388:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
8000338c:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
8000338e:	70 09       	ld.w	r9,r8[0x0]
80003390:	2f c9       	sub	r9,-4
80003392:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80003394:	58 c9       	cp.w	r9,12
80003396:	c0 51       	brne	800033a0 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80003398:	30 59       	mov	r9,5
8000339a:	4e 28       	lddpc	r8,80003520 <phy_tx_func+0x498>
8000339c:	91 09       	st.w	r8[0x0],r9
8000339e:	ca d8       	rjmp	800034f8 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
800033a0:	30 49       	mov	r9,4
800033a2:	4e 08       	lddpc	r8,80003520 <phy_tx_func+0x498>
800033a4:	91 09       	st.w	r8[0x0],r9
800033a6:	ca 98       	rjmp	800034f8 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800033a8:	4e 78       	lddpc	r8,80003544 <phy_tx_func+0x4bc>
800033aa:	70 0a       	ld.w	r10,r8[0x0]
800033ac:	4e 79       	lddpc	r9,80003548 <phy_tx_func+0x4c0>
800033ae:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033b2:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
800033b4:	30 09       	mov	r9,0
800033b6:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
800033b8:	fe 78 80 03 	mov	r8,-32765
800033bc:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800033be:	fe 78 88 f3 	mov	r8,-30477
800033c2:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
800033c4:	4d 98       	lddpc	r8,80003528 <phy_tx_func+0x4a0>
800033c6:	70 08       	ld.w	r8,r8[0x0]
800033c8:	58 48       	cp.w	r8,4
800033ca:	c0 60       	breq	800033d6 <phy_tx_func+0x34e>
800033cc:	c2 83       	brcs	8000341c <phy_tx_func+0x394>
800033ce:	58 98       	cp.w	r8,9
800033d0:	e0 8b 00 26 	brhi	8000341c <phy_tx_func+0x394>
800033d4:	c1 98       	rjmp	80003406 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800033d6:	4d 98       	lddpc	r8,80003538 <phy_tx_func+0x4b0>
800033d8:	11 89       	ld.ub	r9,r8[0x0]
800033da:	30 18       	mov	r8,1
800033dc:	f0 09 18 00 	cp.b	r9,r8
800033e0:	c0 81       	brne	800033f0 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800033e2:	4d 88       	lddpc	r8,80003540 <phy_tx_func+0x4b8>
800033e4:	90 0a       	ld.sh	r10,r8[0x0]
800033e6:	4d a9       	lddpc	r9,8000354c <phy_tx_func+0x4c4>
800033e8:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
800033ea:	90 08       	ld.sh	r8,r8[0x0]
800033ec:	ae 78       	st.h	r7[0xe],r8
800033ee:	c0 88       	rjmp	800033fe <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800033f0:	4d 78       	lddpc	r8,8000354c <phy_tx_func+0x4c4>
800033f2:	90 08       	ld.sh	r8,r8[0x0]
800033f4:	4d 39       	lddpc	r9,80003540 <phy_tx_func+0x4b8>
800033f6:	92 09       	ld.sh	r9,r9[0x0]
800033f8:	f3 e8 20 08 	eor	r8,r9,r8
800033fc:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
800033fe:	30 69       	mov	r9,6
80003400:	4c 88       	lddpc	r8,80003520 <phy_tx_func+0x498>
80003402:	91 09       	st.w	r8[0x0],r9
80003404:	c7 a8       	rjmp	800034f8 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003406:	4d 28       	lddpc	r8,8000354c <phy_tx_func+0x4c4>
80003408:	90 08       	ld.sh	r8,r8[0x0]
8000340a:	4c e9       	lddpc	r9,80003540 <phy_tx_func+0x4b8>
8000340c:	92 09       	ld.sh	r9,r9[0x0]
8000340e:	f3 e8 20 08 	eor	r8,r9,r8
80003412:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80003414:	30 69       	mov	r9,6
80003416:	4c 38       	lddpc	r8,80003520 <phy_tx_func+0x498>
80003418:	91 09       	st.w	r8[0x0],r9
8000341a:	c6 f8       	rjmp	800034f8 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000341c:	e0 68 5a 5a 	mov	r8,23130
80003420:	ea 18 ab cd 	orh	r8,0xabcd
80003424:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003426:	30 08       	mov	r8,0
80003428:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
8000342a:	4b e9       	lddpc	r9,80003520 <phy_tx_func+0x498>
8000342c:	93 08       	st.w	r9[0x0],r8
8000342e:	c6 58       	rjmp	800034f8 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80003430:	4b e8       	lddpc	r8,80003528 <phy_tx_func+0x4a0>
80003432:	70 08       	ld.w	r8,r8[0x0]
80003434:	58 48       	cp.w	r8,4
80003436:	c0 60       	breq	80003442 <phy_tx_func+0x3ba>
80003438:	c4 53       	brcs	800034c2 <phy_tx_func+0x43a>
8000343a:	58 98       	cp.w	r8,9
8000343c:	e0 8b 00 43 	brhi	800034c2 <phy_tx_func+0x43a>
80003440:	c2 d8       	rjmp	8000349a <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80003442:	4b e8       	lddpc	r8,80003538 <phy_tx_func+0x4b0>
80003444:	11 89       	ld.ub	r9,r8[0x0]
80003446:	30 18       	mov	r8,1
80003448:	f0 09 18 00 	cp.b	r9,r8
8000344c:	c1 31       	brne	80003472 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
8000344e:	4b d8       	lddpc	r8,80003540 <phy_tx_func+0x4b8>
80003450:	90 1a       	ld.sh	r10,r8[0x2]
80003452:	4b f9       	lddpc	r9,8000354c <phy_tx_func+0x4c4>
80003454:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80003456:	90 2a       	ld.sh	r10,r8[0x4]
80003458:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
8000345a:	90 3a       	ld.sh	r10,r8[0x6]
8000345c:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
8000345e:	90 19       	ld.sh	r9,r8[0x2]
80003460:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80003462:	90 29       	ld.sh	r9,r8[0x4]
80003464:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80003466:	90 38       	ld.sh	r8,r8[0x6]
80003468:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
8000346a:	e0 68 00 ba 	mov	r8,186
8000346e:	ae 78       	st.h	r7[0xe],r8
80003470:	c1 18       	rjmp	80003492 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80003472:	4b 48       	lddpc	r8,80003540 <phy_tx_func+0x4b8>
80003474:	90 1a       	ld.sh	r10,r8[0x2]
80003476:	4b 69       	lddpc	r9,8000354c <phy_tx_func+0x4c4>
80003478:	92 1b       	ld.sh	r11,r9[0x2]
8000347a:	f7 ea 20 0a 	eor	r10,r11,r10
8000347e:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80003480:	90 2a       	ld.sh	r10,r8[0x4]
80003482:	92 29       	ld.sh	r9,r9[0x4]
80003484:	14 59       	eor	r9,r10
80003486:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80003488:	90 38       	ld.sh	r8,r8[0x6]
8000348a:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
8000348c:	e0 68 00 ba 	mov	r8,186
80003490:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80003492:	30 09       	mov	r9,0
80003494:	4a 38       	lddpc	r8,80003520 <phy_tx_func+0x498>
80003496:	91 09       	st.w	r8[0x0],r9
80003498:	c3 08       	rjmp	800034f8 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000349a:	4a a8       	lddpc	r8,80003540 <phy_tx_func+0x4b8>
8000349c:	90 1a       	ld.sh	r10,r8[0x2]
8000349e:	4a c9       	lddpc	r9,8000354c <phy_tx_func+0x4c4>
800034a0:	92 1b       	ld.sh	r11,r9[0x2]
800034a2:	f7 ea 20 0a 	eor	r10,r11,r10
800034a6:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
800034a8:	90 2a       	ld.sh	r10,r8[0x4]
800034aa:	92 29       	ld.sh	r9,r9[0x4]
800034ac:	14 59       	eor	r9,r10
800034ae:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034b0:	90 38       	ld.sh	r8,r8[0x6]
800034b2:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
800034b4:	e0 68 00 ba 	mov	r8,186
800034b8:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034ba:	30 09       	mov	r9,0
800034bc:	49 98       	lddpc	r8,80003520 <phy_tx_func+0x498>
800034be:	91 09       	st.w	r8[0x0],r9
800034c0:	c1 c8       	rjmp	800034f8 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034c2:	e0 68 5a 5a 	mov	r8,23130
800034c6:	ea 18 ab cd 	orh	r8,0xabcd
800034ca:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034cc:	30 08       	mov	r8,0
800034ce:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
800034d0:	49 49       	lddpc	r9,80003520 <phy_tx_func+0x498>
800034d2:	93 08       	st.w	r9[0x0],r8
800034d4:	c1 28       	rjmp	800034f8 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034d6:	e0 68 5a 5a 	mov	r8,23130
800034da:	ea 18 ab cd 	orh	r8,0xabcd
800034de:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034e0:	30 08       	mov	r8,0
800034e2:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
800034e4:	48 f9       	lddpc	r9,80003520 <phy_tx_func+0x498>
800034e6:	93 08       	st.w	r9[0x0],r8
800034e8:	c0 88       	rjmp	800034f8 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034ea:	e0 68 5a 5a 	mov	r8,23130
800034ee:	ea 18 ab cd 	orh	r8,0xabcd
800034f2:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034f4:	30 08       	mov	r8,0
800034f6:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
800034f8:	2f fd       	sub	sp,-4
800034fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800034fe:	00 00       	add	r0,r0
80003500:	00 00       	add	r0,r0
80003502:	0a cc       	st.b	r5++,r12
80003504:	00 00       	add	r0,r0
80003506:	0a a4       	st.w	r5++,r4
80003508:	00 00       	add	r0,r0
8000350a:	0a 80       	andn	r0,r5
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	5b 20       	cp.w	r0,-14
80003510:	00 00       	add	r0,r0
80003512:	0a c4       	st.b	r5++,r4
80003514:	00 00       	add	r0,r0
80003516:	0a 89       	andn	r9,r5
80003518:	00 00       	add	r0,r0
8000351a:	0a 4d       	or	sp,r5
8000351c:	00 00       	add	r0,r0
8000351e:	0a 7c       	tst	r12,r5
80003520:	00 00       	add	r0,r0
80003522:	0a b4       	st.h	r5++,r4
80003524:	80 00       	ld.sh	r0,r0[0x0]
80003526:	d1 98       	*unknown*
80003528:	00 00       	add	r0,r0
8000352a:	0a 70       	tst	r0,r5
8000352c:	00 00       	add	r0,r0
8000352e:	0a d4       	st.w	--r5,r4
80003530:	00 00       	add	r0,r0
80003532:	1d 8c       	ld.ub	r12,lr[0x0]
80003534:	00 00       	add	r0,r0
80003536:	1e 88       	andn	r8,pc
80003538:	00 00       	add	r0,r0
8000353a:	0a 4e       	or	lr,r5
8000353c:	80 00       	ld.sh	r0,r0[0x0]
8000353e:	d1 3c       	*unknown*
80003540:	00 00       	add	r0,r0
80003542:	1d 84       	ld.ub	r4,lr[0x0]
80003544:	00 00       	add	r0,r0
80003546:	0a a0       	st.w	r5++,r0
80003548:	00 00       	add	r0,r0
8000354a:	1e 8c       	andn	r12,pc
8000354c:	00 00       	add	r0,r0
8000354e:	1d 90       	ld.ub	r0,lr[0x1]

80003550 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003550:	d4 01       	pushm	lr
80003552:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003554:	30 0a       	mov	r10,0
80003556:	fa cb ff fc 	sub	r11,sp,-4
8000355a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
8000355c:	14 99       	mov	r9,r10
8000355e:	1a 9b       	mov	r11,sp
80003560:	f0 1f 00 05 	mcall	80003574 <get_idle_store+0x24>
80003564:	58 1c       	cp.w	r12,1
80003566:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000356a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000356e:	2f fd       	sub	sp,-4
80003570:	d8 02       	popm	pc
80003572:	00 00       	add	r0,r0
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	5c 10       	scr	r0

80003578 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003578:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
8000357c:	f0 1f 00 21 	mcall	80003600 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003580:	4a 1b       	lddpc	r11,80003604 <phy_init+0x8c>
80003582:	4a 2c       	lddpc	r12,80003608 <phy_init+0x90>
80003584:	f0 1f 00 22 	mcall	8000360c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003588:	30 4b       	mov	r11,4
8000358a:	31 ec       	mov	r12,30
8000358c:	f0 1f 00 21 	mcall	80003610 <phy_init+0x98>
80003590:	4a 18       	lddpc	r8,80003614 <phy_init+0x9c>
80003592:	91 0c       	st.w	r8[0x0],r12
80003594:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80003596:	10 96       	mov	r6,r8
80003598:	4a 05       	lddpc	r5,80003618 <phy_init+0xa0>
8000359a:	6c 0c       	ld.w	r12,r6[0x0]
8000359c:	ea 07 00 0b 	add	r11,r5,r7
800035a0:	f0 1f 00 1f 	mcall	8000361c <phy_init+0xa4>
800035a4:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800035a8:	e0 47 1e 00 	cp.w	r7,7680
800035ac:	cf 71       	brne	8000359a <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035ae:	30 4b       	mov	r11,4
800035b0:	31 4c       	mov	r12,20
800035b2:	f0 1f 00 18 	mcall	80003610 <phy_init+0x98>
800035b6:	49 b8       	lddpc	r8,80003620 <phy_init+0xa8>
800035b8:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035ba:	30 4b       	mov	r11,4
800035bc:	30 ac       	mov	r12,10
800035be:	f0 1f 00 15 	mcall	80003610 <phy_init+0x98>
800035c2:	49 98       	lddpc	r8,80003624 <phy_init+0xac>
800035c4:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800035c6:	30 4b       	mov	r11,4
800035c8:	30 ac       	mov	r12,10
800035ca:	f0 1f 00 12 	mcall	80003610 <phy_init+0x98>
800035ce:	49 78       	lddpc	r8,80003628 <phy_init+0xb0>
800035d0:	91 0c       	st.w	r8[0x0],r12
800035d2:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800035d4:	10 96       	mov	r6,r8
800035d6:	49 65       	lddpc	r5,8000362c <phy_init+0xb4>
800035d8:	6c 0c       	ld.w	r12,r6[0x0]
800035da:	ea 07 00 0b 	add	r11,r5,r7
800035de:	f0 1f 00 10 	mcall	8000361c <phy_init+0xa4>
800035e2:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800035e6:	e0 47 14 00 	cp.w	r7,5120
800035ea:	cf 71       	brne	800035d8 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800035ec:	e0 6b 01 00 	mov	r11,256
800035f0:	30 5c       	mov	r12,5
800035f2:	f0 1f 00 08 	mcall	80003610 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800035f6:	48 f8       	lddpc	r8,80003630 <phy_init+0xb8>
800035f8:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800035fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800035fe:	00 00       	add	r0,r0
80003600:	80 00       	ld.sh	r0,r0[0x0]
80003602:	44 24       	lddsp	r4,sp[0x108]
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	30 88       	mov	r8,8
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	36 94       	mov	r4,105
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	44 10       	lddsp	r0,sp[0x104]
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	5f 1c       	srne	r12
80003614:	00 00       	add	r0,r0
80003616:	0a 98       	mov	r8,r5
80003618:	00 00       	add	r0,r0
8000361a:	32 a6       	mov	r6,42
8000361c:	80 00       	ld.sh	r0,r0[0x0]
8000361e:	2f e4       	sub	r4,-2
80003620:	00 00       	add	r0,r0
80003622:	0a cc       	st.b	r5++,r12
80003624:	00 00       	add	r0,r0
80003626:	0a c0       	st.b	r5++,r0
80003628:	00 00       	add	r0,r0
8000362a:	0a 74       	tst	r4,r5
8000362c:	00 00       	add	r0,r0
8000362e:	1e a6       	st.w	pc++,r6
80003630:	00 00       	add	r0,r0
80003632:	0a bc       	st.h	r5++,r12

80003634 <payload_rx>:




static void payload_rx(void * payload)
{
80003634:	d4 01       	pushm	lr
80003636:	20 2d       	sub	sp,8
80003638:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000363a:	30 08       	mov	r8,0
8000363c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000363e:	48 f8       	lddpc	r8,80003678 <payload_rx+0x44>
80003640:	70 08       	ld.w	r8,r8[0x0]
80003642:	58 08       	cp.w	r8,0
80003644:	c0 71       	brne	80003652 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003646:	30 4b       	mov	r11,4
80003648:	30 5c       	mov	r12,5
8000364a:	f0 1f 00 0d 	mcall	8000367c <payload_rx+0x48>
8000364e:	48 b8       	lddpc	r8,80003678 <payload_rx+0x44>
80003650:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80003652:	48 a8       	lddpc	r8,80003678 <payload_rx+0x44>
80003654:	70 0c       	ld.w	r12,r8[0x0]
80003656:	30 09       	mov	r9,0
80003658:	fa ca ff fc 	sub	r10,sp,-4
8000365c:	1a 9b       	mov	r11,sp
8000365e:	f0 1f 00 09 	mcall	80003680 <payload_rx+0x4c>
80003662:	c0 91       	brne	80003674 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003664:	48 88       	lddpc	r8,80003684 <payload_rx+0x50>
80003666:	70 0c       	ld.w	r12,r8[0x0]
80003668:	40 0b       	lddsp	r11,sp[0x0]
8000366a:	f0 1f 00 08 	mcall	80003688 <payload_rx+0x54>
		logFromISR("mm");
8000366e:	48 8c       	lddpc	r12,8000368c <payload_rx+0x58>
80003670:	f0 1f 00 08 	mcall	80003690 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003674:	2f ed       	sub	sp,-8
80003676:	d8 02       	popm	pc
80003678:	00 00       	add	r0,r0
8000367a:	0a 90       	mov	r0,r5
8000367c:	80 00       	ld.sh	r0,r0[0x0]
8000367e:	5f 1c       	srne	r12
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	5d cc       	*unknown*
80003684:	00 00       	add	r0,r0
80003686:	0a 74       	tst	r4,r5
80003688:	80 00       	ld.sh	r0,r0[0x0]
8000368a:	2f 90       	sub	r0,-7
8000368c:	80 00       	ld.sh	r0,r0[0x0]
8000368e:	d1 b4       	*unknown*
80003690:	80 00       	ld.sh	r0,r0[0x0]
80003692:	6b 40       	ld.w	r0,r5[0x50]

80003694 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003694:	eb cd 40 e0 	pushm	r5-r7,lr
80003698:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000369a:	fe f8 0b be 	ld.w	r8,pc[3006]
8000369e:	70 08       	ld.w	r8,r8[0x0]
800036a0:	58 08       	cp.w	r8,0
800036a2:	e0 80 01 05 	breq	800038ac <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800036a6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800036a8:	fe f8 0b b4 	ld.w	r8,pc[2996]
800036ac:	70 09       	ld.w	r9,r8[0x0]
800036ae:	2f f9       	sub	r9,-1
800036b0:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800036b2:	fe f8 0b ae 	ld.w	r8,pc[2990]
800036b6:	70 08       	ld.w	r8,r8[0x0]
800036b8:	58 18       	cp.w	r8,1
800036ba:	e0 80 00 84 	breq	800037c2 <phy_rx_func+0x12e>
800036be:	c0 73       	brcs	800036cc <phy_rx_func+0x38>
800036c0:	58 28       	cp.w	r8,2
800036c2:	c5 b0       	breq	80003778 <phy_rx_func+0xe4>
800036c4:	58 38       	cp.w	r8,3
800036c6:	e0 81 00 f3 	brne	800038ac <phy_rx_func+0x218>
800036ca:	cd 38       	rjmp	80003870 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800036cc:	e0 6a 5a 5a 	mov	r10,23130
800036d0:	ea 1a ab cd 	orh	r10,0xabcd
800036d4:	14 36       	cp.w	r6,r10
800036d6:	e0 80 00 eb 	breq	800038ac <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800036da:	ec 08 16 10 	lsr	r8,r6,0x10
800036de:	e0 48 ab cd 	cp.w	r8,43981
800036e2:	e0 81 00 e5 	brne	800038ac <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800036e6:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800036ea:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800036ee:	20 28       	sub	r8,2
800036f0:	fe f9 0b 74 	ld.w	r9,pc[2932]
800036f4:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800036f6:	30 09       	mov	r9,0
800036f8:	f2 08 19 00 	cp.h	r8,r9
800036fc:	e0 8a 00 d8 	brle	800038ac <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003700:	fe f8 0b 68 	ld.w	r8,pc[2920]
80003704:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003706:	fe f8 0b 66 	ld.w	r8,pc[2918]
8000370a:	70 0c       	ld.w	r12,r8[0x0]
8000370c:	f0 1f 02 d9 	mcall	80004270 <phy_rx_func+0xbdc>
80003710:	fe f8 0b 64 	ld.w	r8,pc[2916]
80003714:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003716:	58 0c       	cp.w	r12,0
80003718:	e0 80 00 ca 	breq	800038ac <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000371c:	fe f8 0b 4c 	ld.w	r8,pc[2892]
80003720:	90 09       	ld.sh	r9,r8[0x0]
80003722:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003726:	2f f9       	sub	r9,-1
80003728:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000372a:	fe fa 0b 4a 	ld.w	r10,pc[2890]
8000372e:	74 0a       	ld.w	r10,r10[0x0]
80003730:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003734:	76 0b       	ld.w	r11,r11[0x0]
80003736:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000373a:	2f f9       	sub	r9,-1
8000373c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000373e:	e2 16 0f 00 	andl	r6,0xf00,COH
80003742:	e0 46 01 00 	cp.w	r6,256
80003746:	c0 c0       	breq	8000375e <phy_rx_func+0xca>
80003748:	e0 8b 00 05 	brhi	80003752 <phy_rx_func+0xbe>
8000374c:	58 06       	cp.w	r6,0
8000374e:	c0 80       	breq	8000375e <phy_rx_func+0xca>
80003750:	c0 c8       	rjmp	80003768 <phy_rx_func+0xd4>
80003752:	e0 46 02 00 	cp.w	r6,512
80003756:	c0 40       	breq	8000375e <phy_rx_func+0xca>
80003758:	e0 46 03 00 	cp.w	r6,768
8000375c:	c0 61       	brne	80003768 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000375e:	30 29       	mov	r9,2
80003760:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	ca 38       	rjmp	800038ac <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003768:	fe f6 0b 0c 	ld.w	r6,pc[2828]
8000376c:	6c 0c       	ld.w	r12,r6[0x0]
8000376e:	f0 1f 02 c3 	mcall	80004278 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
80003772:	30 08       	mov	r8,0
80003774:	8d 08       	st.w	r6[0x0],r8
80003776:	c9 b8       	rjmp	800038ac <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003778:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000377c:	b1 86       	lsr	r6,0x10
8000377e:	14 06       	add	r6,r10
80003780:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003784:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003786:	fe f8 0a e2 	ld.w	r8,pc[2786]
8000378a:	90 09       	ld.sh	r9,r8[0x0]
8000378c:	fe fb 0a e8 	ld.w	r11,pc[2792]
80003790:	76 0b       	ld.w	r11,r11[0x0]
80003792:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003796:	2f f9       	sub	r9,-1
80003798:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000379a:	fe f9 0a ca 	ld.w	r9,pc[2762]
8000379e:	92 08       	ld.sh	r8,r9[0x0]
800037a0:	20 28       	sub	r8,2
800037a2:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800037a4:	30 09       	mov	r9,0
800037a6:	f2 08 19 00 	cp.h	r8,r9
800037aa:	e0 8a 00 07 	brle	800037b8 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800037ae:	30 19       	mov	r9,1
800037b0:	fe f8 0a b0 	ld.w	r8,pc[2736]
800037b4:	91 09       	st.w	r8[0x0],r9
800037b6:	c7 b8       	rjmp	800038ac <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800037b8:	30 39       	mov	r9,3
800037ba:	fe f8 0a a6 	ld.w	r8,pc[2726]
800037be:	91 09       	st.w	r8[0x0],r9
800037c0:	c7 68       	rjmp	800038ac <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800037c2:	ec 0a 14 10 	asr	r10,r6,0x10
800037c6:	fe f8 0a b6 	ld.w	r8,pc[2742]
800037ca:	90 09       	ld.sh	r9,r8[0x0]
800037cc:	14 09       	add	r9,r10
800037ce:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037d0:	fe f9 0a 98 	ld.w	r9,pc[2712]
800037d4:	92 08       	ld.sh	r8,r9[0x0]
800037d6:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800037da:	76 0b       	ld.w	r11,r11[0x0]
800037dc:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800037e0:	2f f8       	sub	r8,-1
800037e2:	5c 88       	casts.h	r8
800037e4:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800037e6:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800037ea:	94 09       	ld.sh	r9,r10[0x0]
800037ec:	20 29       	sub	r9,2
800037ee:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800037f0:	30 0a       	mov	r10,0
800037f2:	f4 09 19 00 	cp.h	r9,r10
800037f6:	e0 89 00 1f 	brgt	80003834 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800037fa:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800037fe:	e0 46 00 ba 	cp.w	r6,186
80003802:	c0 d1       	brne	8000381c <phy_rx_func+0x188>
80003804:	fe f8 0a 78 	ld.w	r8,pc[2680]
80003808:	90 09       	ld.sh	r9,r8[0x0]
8000380a:	f4 09 19 00 	cp.h	r9,r10
8000380e:	c0 71       	brne	8000381c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003810:	fe f8 0a 64 	ld.w	r8,pc[2660]
80003814:	70 0c       	ld.w	r12,r8[0x0]
80003816:	f0 1f 02 9b 	mcall	80004280 <phy_rx_func+0xbec>
8000381a:	c0 88       	rjmp	8000382a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000381c:	fe f6 0a 58 	ld.w	r6,pc[2648]
80003820:	6c 0c       	ld.w	r12,r6[0x0]
80003822:	f0 1f 02 96 	mcall	80004278 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
80003826:	30 08       	mov	r8,0
80003828:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000382a:	30 09       	mov	r9,0
8000382c:	fe f8 0a 34 	ld.w	r8,pc[2612]
80003830:	91 09       	st.w	r8[0x0],r9
80003832:	c3 d8       	rjmp	800038ac <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003834:	5c 86       	casts.h	r6
80003836:	fe f9 0a 46 	ld.w	r9,pc[2630]
8000383a:	92 0a       	ld.sh	r10,r9[0x0]
8000383c:	0c 0a       	add	r10,r6
8000383e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003840:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003844:	72 09       	ld.w	r9,r9[0x0]
80003846:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000384a:	2f f8       	sub	r8,-1
8000384c:	fe f9 0a 1c 	ld.w	r9,pc[2588]
80003850:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003852:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003856:	92 08       	ld.sh	r8,r9[0x0]
80003858:	20 28       	sub	r8,2
8000385a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000385c:	30 09       	mov	r9,0
8000385e:	f2 08 19 00 	cp.h	r8,r9
80003862:	e0 89 00 25 	brgt	800038ac <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003866:	30 39       	mov	r9,3
80003868:	fe f8 09 f8 	ld.w	r8,pc[2552]
8000386c:	91 09       	st.w	r8[0x0],r9
8000386e:	c1 f8       	rjmp	800038ac <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003870:	e6 16 00 ff 	andh	r6,0xff,COH
80003874:	fc 19 00 ba 	movh	r9,0xba
80003878:	12 36       	cp.w	r6,r9
8000387a:	c0 e1       	brne	80003896 <phy_rx_func+0x202>
8000387c:	fe f8 0a 00 	ld.w	r8,pc[2560]
80003880:	90 09       	ld.sh	r9,r8[0x0]
80003882:	30 08       	mov	r8,0
80003884:	f0 09 19 00 	cp.h	r9,r8
80003888:	c0 71       	brne	80003896 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000388a:	fe f8 09 ea 	ld.w	r8,pc[2538]
8000388e:	70 0c       	ld.w	r12,r8[0x0]
80003890:	f0 1f 02 7c 	mcall	80004280 <phy_rx_func+0xbec>
80003894:	c0 88       	rjmp	800038a4 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003896:	fe f6 09 de 	ld.w	r6,pc[2526]
8000389a:	6c 0c       	ld.w	r12,r6[0x0]
8000389c:	f0 1f 02 77 	mcall	80004278 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
800038a0:	30 08       	mov	r8,0
800038a2:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800038a4:	30 09       	mov	r9,0
800038a6:	fe f8 09 ba 	ld.w	r8,pc[2490]
800038aa:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800038ac:	fe f8 09 d8 	ld.w	r8,pc[2520]
800038b0:	11 89       	ld.ub	r9,r8[0x0]
800038b2:	30 08       	mov	r8,0
800038b4:	f0 09 18 00 	cp.b	r9,r8
800038b8:	c0 d1       	brne	800038d2 <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800038ba:	fe f8 09 ce 	ld.w	r8,pc[2510]
800038be:	70 0c       	ld.w	r12,r8[0x0]
800038c0:	f0 1f 02 6c 	mcall	80004270 <phy_rx_func+0xbdc>
800038c4:	fe f8 09 c8 	ld.w	r8,pc[2504]
800038c8:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800038ca:	30 19       	mov	r9,1
800038cc:	fe f8 09 b8 	ld.w	r8,pc[2488]
800038d0:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800038d2:	fe f8 09 be 	ld.w	r8,pc[2494]
800038d6:	70 08       	ld.w	r8,r8[0x0]
800038d8:	58 38       	cp.w	r8,3
800038da:	e0 80 04 7a 	breq	800041ce <phy_rx_func+0xb3a>
800038de:	58 48       	cp.w	r8,4
800038e0:	e0 80 01 02 	breq	80003ae4 <phy_rx_func+0x450>
800038e4:	58 08       	cp.w	r8,0
800038e6:	e0 81 04 b7 	brne	80004254 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800038ea:	6e 28       	ld.w	r8,r7[0x8]
800038ec:	e0 6a 5a 5a 	mov	r10,23130
800038f0:	ea 1a ab cd 	orh	r10,0xabcd
800038f4:	14 38       	cp.w	r8,r10
800038f6:	c0 71       	brne	80003904 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800038f8:	30 09       	mov	r9,0
800038fa:	fe f8 09 9a 	ld.w	r8,pc[2458]
800038fe:	91 09       	st.w	r8[0x0],r9
80003900:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003904:	10 99       	mov	r9,r8
80003906:	e0 19 00 00 	andl	r9,0x0
8000390a:	fc 1a ab cd 	movh	r10,0xabcd
8000390e:	14 39       	cp.w	r9,r10
80003910:	e0 81 04 a2 	brne	80004254 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003914:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003918:	fe f9 09 80 	ld.w	r9,pc[2432]
8000391c:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
8000391e:	fe f8 09 6e 	ld.w	r8,pc[2414]
80003922:	70 08       	ld.w	r8,r8[0x0]
80003924:	58 08       	cp.w	r8,0
80003926:	c1 11       	brne	80003948 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003928:	fe f8 09 60 	ld.w	r8,pc[2400]
8000392c:	70 0c       	ld.w	r12,r8[0x0]
8000392e:	f0 1f 02 51 	mcall	80004270 <phy_rx_func+0xbdc>
80003932:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003936:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003938:	58 0c       	cp.w	r12,0
8000393a:	c0 71       	brne	80003948 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000393c:	fe fc 09 60 	ld.w	r12,pc[2400]
80003940:	f0 1f 02 58 	mcall	800042a0 <phy_rx_func+0xc0c>
80003944:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003948:	6e 28       	ld.w	r8,r7[0x8]
8000394a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000394e:	e0 48 c0 00 	cp.w	r8,49152
80003952:	e0 81 00 c3 	brne	80003ad8 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003956:	30 19       	mov	r9,1
80003958:	fe f8 09 4c 	ld.w	r8,pc[2380]
8000395c:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000395e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003962:	fe f8 09 46 	ld.w	r8,pc[2374]
80003966:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003968:	ef 3a 00 0c 	ld.ub	r10,r7[12]
8000396c:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003970:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003974:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003976:	11 88       	ld.ub	r8,r8[0x0]
80003978:	37 f9       	mov	r9,127
8000397a:	f2 08 18 00 	cp.b	r8,r9
8000397e:	c6 d0       	breq	80003a58 <phy_rx_func+0x3c4>
80003980:	e0 8b 00 0c 	brhi	80003998 <phy_rx_func+0x304>
80003984:	31 29       	mov	r9,18
80003986:	f2 08 18 00 	cp.b	r8,r9
8000398a:	c4 20       	breq	80003a0e <phy_rx_func+0x37a>
8000398c:	31 39       	mov	r9,19
8000398e:	f2 08 18 00 	cp.b	r8,r9
80003992:	e0 81 00 83 	brne	80003a98 <phy_rx_func+0x404>
80003996:	c5 b8       	rjmp	80003a4c <phy_rx_func+0x3b8>
80003998:	2f 08       	sub	r8,-16
8000399a:	30 19       	mov	r9,1
8000399c:	f2 08 18 00 	cp.b	r8,r9
800039a0:	e0 8b 00 7c 	brhi	80003a98 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800039a4:	ef 38 00 0e 	ld.ub	r8,r7[14]
800039a8:	e2 18 00 f0 	andl	r8,0xf0,COH
800039ac:	59 08       	cp.w	r8,16
800039ae:	c0 71       	brne	800039bc <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
800039b0:	30 19       	mov	r9,1
800039b2:	fe f8 08 e2 	ld.w	r8,pc[2274]
800039b6:	91 09       	st.w	r8[0x0],r9
800039b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800039bc:	e0 48 00 20 	cp.w	r8,32
800039c0:	c2 11       	brne	80003a02 <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800039c2:	30 a9       	mov	r9,10
800039c4:	fe f8 08 d0 	ld.w	r8,pc[2256]
800039c8:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800039ca:	fe f6 08 e6 	ld.w	r6,pc[2278]
800039ce:	6c 08       	ld.w	r8,r6[0x0]
800039d0:	f0 0a 11 ff 	rsub	r10,r8,-1
800039d4:	fe f7 08 b8 	ld.w	r7,pc[2232]
800039d8:	2f f8       	sub	r8,-1
800039da:	6e 0c       	ld.w	r12,r7[0x0]
800039dc:	f4 ca fe 00 	sub	r10,r10,-512
800039e0:	30 0b       	mov	r11,0
800039e2:	10 0c       	add	r12,r8
800039e4:	f0 1f 02 34 	mcall	800042b4 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800039e8:	30 08       	mov	r8,0
800039ea:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800039ec:	6e 0c       	ld.w	r12,r7[0x0]
800039ee:	f0 1f 02 33 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800039f2:	fe f8 08 96 	ld.w	r8,pc[2198]
800039f6:	70 0c       	ld.w	r12,r8[0x0]
800039f8:	f0 1f 02 1e 	mcall	80004270 <phy_rx_func+0xbdc>
800039fc:	8f 0c       	st.w	r7[0x0],r12
800039fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003a02:	30 09       	mov	r9,0
80003a04:	fe f8 08 90 	ld.w	r8,pc[2192]
80003a08:	91 09       	st.w	r8[0x0],r9
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a0e:	fe f9 08 8a 	ld.w	r9,pc[2186]
80003a12:	72 08       	ld.w	r8,r9[0x0]
80003a14:	20 48       	sub	r8,4
80003a16:	93 08       	st.w	r9[0x0],r8
80003a18:	e0 80 04 1e 	breq	80004254 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a1c:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003a20:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a24:	fe f8 08 98 	ld.w	r8,pc[2200]
80003a28:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003a2a:	8e 69       	ld.sh	r9,r7[0xc]
80003a2c:	fe f8 08 94 	ld.w	r8,pc[2196]
80003a30:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003a32:	8e 79       	ld.sh	r9,r7[0xe]
80003a34:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003a36:	f0 1f 02 24 	mcall	800042c4 <phy_rx_func+0xc30>
80003a3a:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003a3e:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a40:	30 49       	mov	r9,4
80003a42:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003a46:	91 09       	st.w	r8[0x0],r9
80003a48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003a4c:	30 09       	mov	r9,0
80003a4e:	fe f8 08 46 	ld.w	r8,pc[2118]
80003a52:	91 09       	st.w	r8[0x0],r9
80003a54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a58:	fe f9 08 40 	ld.w	r9,pc[2112]
80003a5c:	72 08       	ld.w	r8,r9[0x0]
80003a5e:	20 48       	sub	r8,4
80003a60:	93 08       	st.w	r9[0x0],r8
80003a62:	e0 80 03 f9 	breq	80004254 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003a66:	fe f8 08 62 	ld.w	r8,pc[2146]
80003a6a:	70 09       	ld.w	r9,r8[0x0]
80003a6c:	8e 7b       	ld.sh	r11,r7[0xe]
80003a6e:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003a72:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003a76:	2f f9       	sub	r9,-1
80003a78:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003a7a:	fe f8 08 32 	ld.w	r8,pc[2098]
80003a7e:	70 09       	ld.w	r9,r8[0x0]
80003a80:	20 29       	sub	r9,2
80003a82:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003a84:	30 29       	mov	r9,2
80003a86:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003a8a:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003a8c:	30 39       	mov	r9,3
80003a8e:	fe f8 08 02 	ld.w	r8,pc[2050]
80003a92:	91 09       	st.w	r8[0x0],r9
80003a94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003a98:	30 39       	mov	r9,3
80003a9a:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003a9e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003aa0:	6e 29       	ld.w	r9,r7[0x8]
80003aa2:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003aa6:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003aa8:	6e 39       	ld.w	r9,r7[0xc]
80003aaa:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003aac:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003ab0:	70 08       	ld.w	r8,r8[0x0]
80003ab2:	59 48       	cp.w	r8,20
80003ab4:	c0 61       	brne	80003ac0 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003ab6:	31 89       	mov	r9,24
80003ab8:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003abc:	91 09       	st.w	r8[0x0],r9
80003abe:	c0 78       	rjmp	80003acc <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003ac0:	59 08       	cp.w	r8,16
80003ac2:	c0 51       	brne	80003acc <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003ac4:	31 09       	mov	r9,16
80003ac6:	fe f8 07 d2 	ld.w	r8,pc[2002]
80003aca:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003acc:	30 49       	mov	r9,4
80003ace:	fe f8 07 c2 	ld.w	r8,pc[1986]
80003ad2:	91 09       	st.w	r8[0x0],r9
80003ad4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
80003ad8:	30 09       	mov	r9,0
80003ada:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003ade:	b0 89       	st.b	r8[0x0],r9
80003ae0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003ae4:	fe f8 07 c4 	ld.w	r8,pc[1988]
80003ae8:	11 89       	ld.ub	r9,r8[0x0]
80003aea:	31 28       	mov	r8,18
80003aec:	f0 09 18 00 	cp.b	r9,r8
80003af0:	e0 81 01 4c 	brne	80003d88 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
80003af4:	ef 39 00 09 	ld.ub	r9,r7[9]
80003af8:	fe f8 07 b0 	ld.w	r8,pc[1968]
80003afc:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003afe:	11 89       	ld.ub	r9,r8[0x0]
80003b00:	3f 28       	mov	r8,-14
80003b02:	f0 09 18 00 	cp.b	r9,r8
80003b06:	e0 81 01 3b 	brne	80003d7c <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
80003b0a:	30 19       	mov	r9,1
80003b0c:	fe f8 07 c8 	ld.w	r8,pc[1992]
80003b10:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003b12:	6e 29       	ld.w	r9,r7[0x8]
80003b14:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003b18:	fe f8 07 80 	ld.w	r8,pc[1920]
80003b1c:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003b1e:	8e 59       	ld.sh	r9,r7[0xa]
80003b20:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003b24:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003b26:	8e 69       	ld.sh	r9,r7[0xc]
80003b28:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003b2a:	8e 79       	ld.sh	r9,r7[0xe]
80003b2c:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003b2e:	fe f8 07 82 	ld.w	r8,pc[1922]
80003b32:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003b36:	72 0a       	ld.w	r10,r9[0x0]
80003b38:	70 09       	ld.w	r9,r8[0x0]
80003b3a:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b3e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b42:	70 09       	ld.w	r9,r8[0x0]
80003b44:	2f f9       	sub	r9,-1
80003b46:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b48:	e0 49 01 ff 	cp.w	r9,511
80003b4c:	e0 88 00 16 	brls	80003b78 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b50:	30 09       	mov	r9,0
80003b52:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b54:	fe f6 07 38 	ld.w	r6,pc[1848]
80003b58:	6c 0c       	ld.w	r12,r6[0x0]
80003b5a:	f0 1f 01 d8 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b5e:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003b62:	70 0c       	ld.w	r12,r8[0x0]
80003b64:	f0 1f 01 c3 	mcall	80004270 <phy_rx_func+0xbdc>
80003b68:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b6a:	c0 71       	brne	80003b78 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003b6c:	30 09       	mov	r9,0
80003b6e:	fe f8 07 22 	ld.w	r8,pc[1826]
80003b72:	91 09       	st.w	r8[0x0],r9
80003b74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b78:	fe f9 07 20 	ld.w	r9,pc[1824]
80003b7c:	72 08       	ld.w	r8,r9[0x0]
80003b7e:	20 18       	sub	r8,1
80003b80:	93 08       	st.w	r9[0x0],r8
80003b82:	c0 71       	brne	80003b90 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003b84:	30 09       	mov	r9,0
80003b86:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003b8a:	91 09       	st.w	r8[0x0],r9
80003b8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003b90:	fe f8 07 20 	ld.w	r8,pc[1824]
80003b94:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003b98:	72 0a       	ld.w	r10,r9[0x0]
80003b9a:	70 09       	ld.w	r9,r8[0x0]
80003b9c:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003ba0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ba4:	70 09       	ld.w	r9,r8[0x0]
80003ba6:	2f f9       	sub	r9,-1
80003ba8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003baa:	e0 49 01 ff 	cp.w	r9,511
80003bae:	e0 88 00 16 	brls	80003bda <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bb2:	30 09       	mov	r9,0
80003bb4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bb6:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003bba:	6c 0c       	ld.w	r12,r6[0x0]
80003bbc:	f0 1f 01 bf 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bc0:	fe f8 06 c8 	ld.w	r8,pc[1736]
80003bc4:	70 0c       	ld.w	r12,r8[0x0]
80003bc6:	f0 1f 01 ab 	mcall	80004270 <phy_rx_func+0xbdc>
80003bca:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003bcc:	c0 71       	brne	80003bda <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
80003bce:	30 09       	mov	r9,0
80003bd0:	fe f8 06 c0 	ld.w	r8,pc[1728]
80003bd4:	91 09       	st.w	r8[0x0],r9
80003bd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bda:	fe f9 06 be 	ld.w	r9,pc[1726]
80003bde:	72 08       	ld.w	r8,r9[0x0]
80003be0:	20 18       	sub	r8,1
80003be2:	93 08       	st.w	r9[0x0],r8
80003be4:	c0 71       	brne	80003bf2 <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
80003be6:	30 09       	mov	r9,0
80003be8:	fe f8 06 a8 	ld.w	r8,pc[1704]
80003bec:	91 09       	st.w	r8[0x0],r9
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003bf2:	fe f8 06 be 	ld.w	r8,pc[1726]
80003bf6:	fe f9 06 96 	ld.w	r9,pc[1686]
80003bfa:	72 0a       	ld.w	r10,r9[0x0]
80003bfc:	70 09       	ld.w	r9,r8[0x0]
80003bfe:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c02:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c06:	70 09       	ld.w	r9,r8[0x0]
80003c08:	2f f9       	sub	r9,-1
80003c0a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c0c:	e0 49 01 ff 	cp.w	r9,511
80003c10:	e0 88 00 16 	brls	80003c3c <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c14:	30 09       	mov	r9,0
80003c16:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c18:	fe f6 06 74 	ld.w	r6,pc[1652]
80003c1c:	6c 0c       	ld.w	r12,r6[0x0]
80003c1e:	f0 1f 01 a7 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c22:	fe f8 06 66 	ld.w	r8,pc[1638]
80003c26:	70 0c       	ld.w	r12,r8[0x0]
80003c28:	f0 1f 01 92 	mcall	80004270 <phy_rx_func+0xbdc>
80003c2c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c2e:	c0 71       	brne	80003c3c <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003c30:	30 09       	mov	r9,0
80003c32:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003c36:	91 09       	st.w	r8[0x0],r9
80003c38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c3c:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003c40:	72 08       	ld.w	r8,r9[0x0]
80003c42:	20 18       	sub	r8,1
80003c44:	93 08       	st.w	r9[0x0],r8
80003c46:	c0 71       	brne	80003c54 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003c48:	30 09       	mov	r9,0
80003c4a:	fe f8 06 46 	ld.w	r8,pc[1606]
80003c4e:	91 09       	st.w	r8[0x0],r9
80003c50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003c54:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003c58:	fe f9 06 34 	ld.w	r9,pc[1588]
80003c5c:	72 0a       	ld.w	r10,r9[0x0]
80003c5e:	70 09       	ld.w	r9,r8[0x0]
80003c60:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003c64:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c68:	70 09       	ld.w	r9,r8[0x0]
80003c6a:	2f f9       	sub	r9,-1
80003c6c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c6e:	e0 49 01 ff 	cp.w	r9,511
80003c72:	e0 88 00 16 	brls	80003c9e <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c76:	30 09       	mov	r9,0
80003c78:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c7a:	fe f6 06 12 	ld.w	r6,pc[1554]
80003c7e:	6c 0c       	ld.w	r12,r6[0x0]
80003c80:	f0 1f 01 8e 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c84:	fe f8 06 04 	ld.w	r8,pc[1540]
80003c88:	70 0c       	ld.w	r12,r8[0x0]
80003c8a:	f0 1f 01 7a 	mcall	80004270 <phy_rx_func+0xbdc>
80003c8e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c90:	c0 71       	brne	80003c9e <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
80003c92:	30 09       	mov	r9,0
80003c94:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003c98:	91 09       	st.w	r8[0x0],r9
80003c9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c9e:	fe f9 05 fa 	ld.w	r9,pc[1530]
80003ca2:	72 08       	ld.w	r8,r9[0x0]
80003ca4:	20 18       	sub	r8,1
80003ca6:	93 08       	st.w	r9[0x0],r8
80003ca8:	c0 71       	brne	80003cb6 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003caa:	30 09       	mov	r9,0
80003cac:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003cb0:	91 09       	st.w	r8[0x0],r9
80003cb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003cb6:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003cba:	fe f9 05 d2 	ld.w	r9,pc[1490]
80003cbe:	72 0a       	ld.w	r10,r9[0x0]
80003cc0:	70 09       	ld.w	r9,r8[0x0]
80003cc2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003cc6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003cca:	70 09       	ld.w	r9,r8[0x0]
80003ccc:	2f f9       	sub	r9,-1
80003cce:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cd0:	e0 49 01 ff 	cp.w	r9,511
80003cd4:	e0 88 00 16 	brls	80003d00 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003cd8:	30 09       	mov	r9,0
80003cda:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003cdc:	fe f6 05 b0 	ld.w	r6,pc[1456]
80003ce0:	6c 0c       	ld.w	r12,r6[0x0]
80003ce2:	f0 1f 01 76 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ce6:	fe f8 05 a2 	ld.w	r8,pc[1442]
80003cea:	70 0c       	ld.w	r12,r8[0x0]
80003cec:	f0 1f 01 61 	mcall	80004270 <phy_rx_func+0xbdc>
80003cf0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cf2:	c0 71       	brne	80003d00 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
80003cf4:	30 09       	mov	r9,0
80003cf6:	fe f8 05 9a 	ld.w	r8,pc[1434]
80003cfa:	91 09       	st.w	r8[0x0],r9
80003cfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d00:	fe f9 05 98 	ld.w	r9,pc[1432]
80003d04:	72 08       	ld.w	r8,r9[0x0]
80003d06:	20 18       	sub	r8,1
80003d08:	93 08       	st.w	r9[0x0],r8
80003d0a:	c0 71       	brne	80003d18 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003d0c:	30 09       	mov	r9,0
80003d0e:	fe f8 05 82 	ld.w	r8,pc[1410]
80003d12:	91 09       	st.w	r8[0x0],r9
80003d14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003d18:	fe f8 05 98 	ld.w	r8,pc[1432]
80003d1c:	fe f9 05 70 	ld.w	r9,pc[1392]
80003d20:	72 0a       	ld.w	r10,r9[0x0]
80003d22:	70 09       	ld.w	r9,r8[0x0]
80003d24:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d28:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d2c:	70 09       	ld.w	r9,r8[0x0]
80003d2e:	2f f9       	sub	r9,-1
80003d30:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d32:	e0 49 01 ff 	cp.w	r9,511
80003d36:	e0 88 00 16 	brls	80003d62 <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d3a:	30 09       	mov	r9,0
80003d3c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d3e:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003d42:	6e 0c       	ld.w	r12,r7[0x0]
80003d44:	f0 1f 01 5d 	mcall	800042b8 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d48:	fe f8 05 40 	ld.w	r8,pc[1344]
80003d4c:	70 0c       	ld.w	r12,r8[0x0]
80003d4e:	f0 1f 01 49 	mcall	80004270 <phy_rx_func+0xbdc>
80003d52:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d54:	c0 71       	brne	80003d62 <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003d56:	30 09       	mov	r9,0
80003d58:	fe f8 05 38 	ld.w	r8,pc[1336]
80003d5c:	91 09       	st.w	r8[0x0],r9
80003d5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d62:	fe f9 05 36 	ld.w	r9,pc[1334]
80003d66:	72 08       	ld.w	r8,r9[0x0]
80003d68:	20 18       	sub	r8,1
80003d6a:	93 08       	st.w	r9[0x0],r8
80003d6c:	e0 81 02 74 	brne	80004254 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003d70:	30 09       	mov	r9,0
80003d72:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003d76:	91 09       	st.w	r8[0x0],r9
80003d78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003d7c:	30 09       	mov	r9,0
80003d7e:	fe f8 05 12 	ld.w	r8,pc[1298]
80003d82:	91 09       	st.w	r8[0x0],r9
80003d84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003d88:	fe f8 05 20 	ld.w	r8,pc[1312]
80003d8c:	11 89       	ld.ub	r9,r8[0x0]
80003d8e:	3f 28       	mov	r8,-14
80003d90:	f0 09 18 00 	cp.b	r9,r8
80003d94:	c4 31       	brne	80003e1a <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003d96:	8e 49       	ld.sh	r9,r7[0x8]
80003d98:	fe f8 05 40 	ld.w	r8,pc[1344]
80003d9c:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003d9e:	fe f8 05 12 	ld.w	r8,pc[1298]
80003da2:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003da6:	72 0a       	ld.w	r10,r9[0x0]
80003da8:	70 09       	ld.w	r9,r8[0x0]
80003daa:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003dae:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003db2:	70 09       	ld.w	r9,r8[0x0]
80003db4:	2f f9       	sub	r9,-1
80003db6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003db8:	e0 49 01 ff 	cp.w	r9,511
80003dbc:	e0 88 00 16 	brls	80003de8 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dc0:	30 09       	mov	r9,0
80003dc2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003dc4:	fe f7 04 c8 	ld.w	r7,pc[1224]
80003dc8:	6e 0c       	ld.w	r12,r7[0x0]
80003dca:	f0 1f 01 3c 	mcall	800042b8 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dce:	fe f8 04 ba 	ld.w	r8,pc[1210]
80003dd2:	70 0c       	ld.w	r12,r8[0x0]
80003dd4:	f0 1f 01 27 	mcall	80004270 <phy_rx_func+0xbdc>
80003dd8:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003dda:	c0 71       	brne	80003de8 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
80003ddc:	30 09       	mov	r9,0
80003dde:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003de2:	91 09       	st.w	r8[0x0],r9
80003de4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003de8:	fe f9 04 b0 	ld.w	r9,pc[1200]
80003dec:	72 08       	ld.w	r8,r9[0x0]
80003dee:	20 18       	sub	r8,1
80003df0:	93 08       	st.w	r9[0x0],r8
80003df2:	c0 71       	brne	80003e00 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
80003df4:	30 09       	mov	r9,0
80003df6:	fe f8 04 9a 	ld.w	r8,pc[1178]
80003dfa:	91 09       	st.w	r8[0x0],r9
80003dfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003e00:	20 18       	sub	r8,1
80003e02:	fe f9 04 96 	ld.w	r9,pc[1174]
80003e06:	93 08       	st.w	r9[0x0],r8
80003e08:	58 08       	cp.w	r8,0
80003e0a:	e0 81 02 25 	brne	80004254 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003e0e:	30 09       	mov	r9,0
80003e10:	fe f8 04 80 	ld.w	r8,pc[1152]
80003e14:	91 09       	st.w	r8[0x0],r9
80003e16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003e1a:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003e1e:	11 89       	ld.ub	r9,r8[0x0]
80003e20:	3f 38       	mov	r8,-13
80003e22:	f0 09 18 00 	cp.b	r9,r8
80003e26:	e0 81 01 0c 	brne	8000403e <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003e2a:	8e 49       	ld.sh	r9,r7[0x8]
80003e2c:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003e30:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003e32:	8e 59       	ld.sh	r9,r7[0xa]
80003e34:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003e36:	8e 69       	ld.sh	r9,r7[0xc]
80003e38:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003e3a:	fe f8 04 76 	ld.w	r8,pc[1142]
80003e3e:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003e42:	72 0a       	ld.w	r10,r9[0x0]
80003e44:	70 09       	ld.w	r9,r8[0x0]
80003e46:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003e4a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e4e:	70 09       	ld.w	r9,r8[0x0]
80003e50:	2f f9       	sub	r9,-1
80003e52:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e54:	e0 49 01 ff 	cp.w	r9,511
80003e58:	e0 88 00 16 	brls	80003e84 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e5c:	30 09       	mov	r9,0
80003e5e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e60:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003e64:	6c 0c       	ld.w	r12,r6[0x0]
80003e66:	f0 1f 01 15 	mcall	800042b8 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e6a:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003e6e:	70 0c       	ld.w	r12,r8[0x0]
80003e70:	f0 1f 01 00 	mcall	80004270 <phy_rx_func+0xbdc>
80003e74:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e76:	c0 71       	brne	80003e84 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003e78:	30 09       	mov	r9,0
80003e7a:	fe f8 04 16 	ld.w	r8,pc[1046]
80003e7e:	91 09       	st.w	r8[0x0],r9
80003e80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e84:	fe f9 04 14 	ld.w	r9,pc[1044]
80003e88:	72 08       	ld.w	r8,r9[0x0]
80003e8a:	20 18       	sub	r8,1
80003e8c:	93 08       	st.w	r9[0x0],r8
80003e8e:	c0 71       	brne	80003e9c <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003e90:	30 09       	mov	r9,0
80003e92:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003e96:	91 09       	st.w	r8[0x0],r9
80003e98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003e9c:	fe f8 04 14 	ld.w	r8,pc[1044]
80003ea0:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003ea4:	72 0a       	ld.w	r10,r9[0x0]
80003ea6:	70 09       	ld.w	r9,r8[0x0]
80003ea8:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003eac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003eb0:	70 09       	ld.w	r9,r8[0x0]
80003eb2:	2f f9       	sub	r9,-1
80003eb4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003eb6:	e0 49 01 ff 	cp.w	r9,511
80003eba:	e0 88 00 16 	brls	80003ee6 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ebe:	30 09       	mov	r9,0
80003ec0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ec2:	fe f6 03 ca 	ld.w	r6,pc[970]
80003ec6:	6c 0c       	ld.w	r12,r6[0x0]
80003ec8:	f0 1f 00 fc 	mcall	800042b8 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ecc:	fe f8 03 bc 	ld.w	r8,pc[956]
80003ed0:	70 0c       	ld.w	r12,r8[0x0]
80003ed2:	f0 1f 00 e8 	mcall	80004270 <phy_rx_func+0xbdc>
80003ed6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ed8:	c0 71       	brne	80003ee6 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
80003eda:	30 09       	mov	r9,0
80003edc:	fe f8 03 b4 	ld.w	r8,pc[948]
80003ee0:	91 09       	st.w	r8[0x0],r9
80003ee2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ee6:	fe f9 03 b2 	ld.w	r9,pc[946]
80003eea:	72 08       	ld.w	r8,r9[0x0]
80003eec:	20 18       	sub	r8,1
80003eee:	93 08       	st.w	r9[0x0],r8
80003ef0:	c0 71       	brne	80003efe <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
80003ef2:	30 09       	mov	r9,0
80003ef4:	fe f8 03 9c 	ld.w	r8,pc[924]
80003ef8:	91 09       	st.w	r8[0x0],r9
80003efa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003efe:	fe f8 03 b2 	ld.w	r8,pc[946]
80003f02:	fe f9 03 8a 	ld.w	r9,pc[906]
80003f06:	72 0a       	ld.w	r10,r9[0x0]
80003f08:	70 09       	ld.w	r9,r8[0x0]
80003f0a:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003f0e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f12:	70 09       	ld.w	r9,r8[0x0]
80003f14:	2f f9       	sub	r9,-1
80003f16:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f18:	e0 49 01 ff 	cp.w	r9,511
80003f1c:	e0 88 00 16 	brls	80003f48 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f20:	30 09       	mov	r9,0
80003f22:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f24:	fe f6 03 68 	ld.w	r6,pc[872]
80003f28:	6c 0c       	ld.w	r12,r6[0x0]
80003f2a:	f0 1f 00 e4 	mcall	800042b8 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f2e:	fe f8 03 5a 	ld.w	r8,pc[858]
80003f32:	70 0c       	ld.w	r12,r8[0x0]
80003f34:	f0 1f 00 cf 	mcall	80004270 <phy_rx_func+0xbdc>
80003f38:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f3a:	c0 71       	brne	80003f48 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003f3c:	30 09       	mov	r9,0
80003f3e:	fe f8 03 52 	ld.w	r8,pc[850]
80003f42:	91 09       	st.w	r8[0x0],r9
80003f44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f48:	fe f9 03 50 	ld.w	r9,pc[848]
80003f4c:	72 08       	ld.w	r8,r9[0x0]
80003f4e:	20 18       	sub	r8,1
80003f50:	93 08       	st.w	r9[0x0],r8
80003f52:	c0 71       	brne	80003f60 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003f54:	30 09       	mov	r9,0
80003f56:	fe f8 03 3a 	ld.w	r8,pc[826]
80003f5a:	91 09       	st.w	r8[0x0],r9
80003f5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003f60:	fe f8 03 50 	ld.w	r8,pc[848]
80003f64:	fe f9 03 28 	ld.w	r9,pc[808]
80003f68:	72 0a       	ld.w	r10,r9[0x0]
80003f6a:	70 09       	ld.w	r9,r8[0x0]
80003f6c:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f70:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f74:	70 09       	ld.w	r9,r8[0x0]
80003f76:	2f f9       	sub	r9,-1
80003f78:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f7a:	e0 49 01 ff 	cp.w	r9,511
80003f7e:	e0 88 00 16 	brls	80003faa <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f82:	30 09       	mov	r9,0
80003f84:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f86:	fe f6 03 06 	ld.w	r6,pc[774]
80003f8a:	6c 0c       	ld.w	r12,r6[0x0]
80003f8c:	f0 1f 00 cb 	mcall	800042b8 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f90:	fe f8 02 f8 	ld.w	r8,pc[760]
80003f94:	70 0c       	ld.w	r12,r8[0x0]
80003f96:	f0 1f 00 b7 	mcall	80004270 <phy_rx_func+0xbdc>
80003f9a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f9c:	c0 71       	brne	80003faa <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003f9e:	30 09       	mov	r9,0
80003fa0:	fe f8 02 f0 	ld.w	r8,pc[752]
80003fa4:	91 09       	st.w	r8[0x0],r9
80003fa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003faa:	fe f9 02 ee 	ld.w	r9,pc[750]
80003fae:	72 08       	ld.w	r8,r9[0x0]
80003fb0:	20 18       	sub	r8,1
80003fb2:	93 08       	st.w	r9[0x0],r8
80003fb4:	c0 71       	brne	80003fc2 <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003fb6:	30 09       	mov	r9,0
80003fb8:	fe f8 02 d8 	ld.w	r8,pc[728]
80003fbc:	91 09       	st.w	r8[0x0],r9
80003fbe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003fc2:	fe f8 02 ee 	ld.w	r8,pc[750]
80003fc6:	fe f9 02 c6 	ld.w	r9,pc[710]
80003fca:	72 0a       	ld.w	r10,r9[0x0]
80003fcc:	70 09       	ld.w	r9,r8[0x0]
80003fce:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003fd2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fd6:	70 09       	ld.w	r9,r8[0x0]
80003fd8:	2f f9       	sub	r9,-1
80003fda:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fdc:	e0 49 01 ff 	cp.w	r9,511
80003fe0:	e0 88 00 16 	brls	8000400c <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
80003fe4:	30 09       	mov	r9,0
80003fe6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fe8:	fe f7 02 a4 	ld.w	r7,pc[676]
80003fec:	6e 0c       	ld.w	r12,r7[0x0]
80003fee:	f0 1f 00 b3 	mcall	800042b8 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ff2:	fe f8 02 96 	ld.w	r8,pc[662]
80003ff6:	70 0c       	ld.w	r12,r8[0x0]
80003ff8:	f0 1f 00 9e 	mcall	80004270 <phy_rx_func+0xbdc>
80003ffc:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ffe:	c0 71       	brne	8000400c <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
80004000:	30 09       	mov	r9,0
80004002:	fe f8 02 8e 	ld.w	r8,pc[654]
80004006:	91 09       	st.w	r8[0x0],r9
80004008:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000400c:	fe f9 02 8c 	ld.w	r9,pc[652]
80004010:	72 08       	ld.w	r8,r9[0x0]
80004012:	20 18       	sub	r8,1
80004014:	93 08       	st.w	r9[0x0],r8
80004016:	c0 71       	brne	80004024 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80004018:	30 09       	mov	r9,0
8000401a:	fe f8 02 76 	ld.w	r8,pc[630]
8000401e:	91 09       	st.w	r8[0x0],r9
80004020:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004024:	20 18       	sub	r8,1
80004026:	fe f9 02 72 	ld.w	r9,pc[626]
8000402a:	93 08       	st.w	r9[0x0],r8
8000402c:	58 08       	cp.w	r8,0
8000402e:	e0 81 01 13 	brne	80004254 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004032:	30 09       	mov	r9,0
80004034:	fe f8 02 5c 	ld.w	r8,pc[604]
80004038:	91 09       	st.w	r8[0x0],r9
8000403a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000403e:	fe f8 02 6a 	ld.w	r8,pc[618]
80004042:	11 89       	ld.ub	r9,r8[0x0]
80004044:	30 48       	mov	r8,4
80004046:	f0 09 18 00 	cp.b	r9,r8
8000404a:	c0 80       	breq	8000405a <phy_rx_func+0x9c6>
8000404c:	fe f8 02 5c 	ld.w	r8,pc[604]
80004050:	11 89       	ld.ub	r9,r8[0x0]
80004052:	30 38       	mov	r8,3
80004054:	f0 09 18 00 	cp.b	r9,r8
80004058:	c1 41       	brne	80004080 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000405a:	6e 29       	ld.w	r9,r7[0x8]
8000405c:	fe f8 02 74 	ld.w	r8,pc[628]
80004060:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004062:	6e 39       	ld.w	r9,r7[0xc]
80004064:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004066:	fe f9 02 32 	ld.w	r9,pc[562]
8000406a:	72 08       	ld.w	r8,r9[0x0]
8000406c:	20 88       	sub	r8,8
8000406e:	93 08       	st.w	r9[0x0],r8
80004070:	e0 81 00 f2 	brne	80004254 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80004074:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004076:	fe f9 02 1a 	ld.w	r9,pc[538]
8000407a:	93 08       	st.w	r9[0x0],r8
8000407c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80004080:	fe f8 02 28 	ld.w	r8,pc[552]
80004084:	11 89       	ld.ub	r9,r8[0x0]
80004086:	31 38       	mov	r8,19
80004088:	f0 09 18 00 	cp.b	r9,r8
8000408c:	e0 81 00 9c 	brne	800041c4 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80004090:	fe f8 02 4c 	ld.w	r8,pc[588]
80004094:	11 88       	ld.ub	r8,r8[0x0]
80004096:	30 c9       	mov	r9,12
80004098:	f2 08 18 00 	cp.b	r8,r9
8000409c:	e0 81 00 7b 	brne	80004192 <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800040a0:	8e 49       	ld.sh	r9,r7[0x8]
800040a2:	fe f8 02 3e 	ld.w	r8,pc[574]
800040a6:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800040aa:	30 09       	mov	r9,0
800040ac:	fe f8 02 30 	ld.w	r8,pc[560]
800040b0:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040b2:	ef 39 00 0d 	ld.ub	r9,r7[13]
800040b6:	3f 38       	mov	r8,-13
800040b8:	f0 09 18 00 	cp.b	r9,r8
800040bc:	c6 61       	brne	80004188 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800040be:	10 99       	mov	r9,r8
800040c0:	4f a8       	lddpc	r8,800042a8 <phy_rx_func+0xc14>
800040c2:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800040c4:	ef 39 00 0c 	ld.ub	r9,r7[12]
800040c8:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800040cc:	4f 38       	lddpc	r8,80004298 <phy_rx_func+0xc04>
800040ce:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800040d0:	30 19       	mov	r9,1
800040d2:	fe f8 02 12 	ld.w	r8,pc[530]
800040d6:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800040d8:	8e 79       	ld.sh	r9,r7[0xe]
800040da:	fe f8 01 fe 	ld.w	r8,pc[510]
800040de:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800040e0:	4f 48       	lddpc	r8,800042b0 <phy_rx_func+0xc1c>
800040e2:	4e b9       	lddpc	r9,8000428c <phy_rx_func+0xbf8>
800040e4:	72 0a       	ld.w	r10,r9[0x0]
800040e6:	70 09       	ld.w	r9,r8[0x0]
800040e8:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800040ec:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800040f0:	70 09       	ld.w	r9,r8[0x0]
800040f2:	2f f9       	sub	r9,-1
800040f4:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040f6:	e0 49 01 ff 	cp.w	r9,511
800040fa:	e0 88 00 13 	brls	80004120 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
800040fe:	30 09       	mov	r9,0
80004100:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004102:	4e 36       	lddpc	r6,8000428c <phy_rx_func+0xbf8>
80004104:	6c 0c       	ld.w	r12,r6[0x0]
80004106:	f0 1f 00 6d 	mcall	800042b8 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
8000410a:	4e 08       	lddpc	r8,80004288 <phy_rx_func+0xbf4>
8000410c:	70 0c       	ld.w	r12,r8[0x0]
8000410e:	f0 1f 00 59 	mcall	80004270 <phy_rx_func+0xbdc>
80004112:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004114:	c0 61       	brne	80004120 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80004116:	30 09       	mov	r9,0
80004118:	4d e8       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
8000411a:	91 09       	st.w	r8[0x0],r9
8000411c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004120:	4d e9       	lddpc	r9,80004298 <phy_rx_func+0xc04>
80004122:	72 08       	ld.w	r8,r9[0x0]
80004124:	20 18       	sub	r8,1
80004126:	93 08       	st.w	r9[0x0],r8
80004128:	c0 61       	brne	80004134 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
8000412a:	30 09       	mov	r9,0
8000412c:	4d 98       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
8000412e:	91 09       	st.w	r8[0x0],r9
80004130:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80004134:	4d f8       	lddpc	r8,800042b0 <phy_rx_func+0xc1c>
80004136:	4d 69       	lddpc	r9,8000428c <phy_rx_func+0xbf8>
80004138:	72 0a       	ld.w	r10,r9[0x0]
8000413a:	70 09       	ld.w	r9,r8[0x0]
8000413c:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004140:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004144:	70 09       	ld.w	r9,r8[0x0]
80004146:	2f f9       	sub	r9,-1
80004148:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000414a:	e0 49 01 ff 	cp.w	r9,511
8000414e:	e0 88 00 13 	brls	80004174 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80004152:	30 09       	mov	r9,0
80004154:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004156:	4c e7       	lddpc	r7,8000428c <phy_rx_func+0xbf8>
80004158:	6e 0c       	ld.w	r12,r7[0x0]
8000415a:	f0 1f 00 58 	mcall	800042b8 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
8000415e:	4c b8       	lddpc	r8,80004288 <phy_rx_func+0xbf4>
80004160:	70 0c       	ld.w	r12,r8[0x0]
80004162:	f0 1f 00 44 	mcall	80004270 <phy_rx_func+0xbdc>
80004166:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004168:	c0 61       	brne	80004174 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
8000416a:	30 09       	mov	r9,0
8000416c:	4c 98       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
8000416e:	91 09       	st.w	r8[0x0],r9
80004170:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004174:	4c 99       	lddpc	r9,80004298 <phy_rx_func+0xc04>
80004176:	72 08       	ld.w	r8,r9[0x0]
80004178:	20 18       	sub	r8,1
8000417a:	93 08       	st.w	r9[0x0],r8
8000417c:	c6 c1       	brne	80004254 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
8000417e:	30 09       	mov	r9,0
80004180:	4c 48       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
80004182:	91 09       	st.w	r8[0x0],r9
80004184:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80004188:	30 09       	mov	r9,0
8000418a:	4c 28       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
8000418c:	91 09       	st.w	r8[0x0],r9
8000418e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004192:	8e 4a       	ld.sh	r10,r7[0x8]
80004194:	4d 39       	lddpc	r9,800042e0 <phy_rx_func+0xc4c>
80004196:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
8000419a:	4d 1a       	lddpc	r10,800042dc <phy_rx_func+0xc48>
8000419c:	15 88       	ld.ub	r8,r10[0x0]
8000419e:	f0 cb ff ff 	sub	r11,r8,-1
800041a2:	8e 5c       	ld.sh	r12,r7[0xa]
800041a4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800041a8:	f0 cb ff fe 	sub	r11,r8,-2
800041ac:	8e 6c       	ld.sh	r12,r7[0xc]
800041ae:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800041b2:	f0 cb ff fd 	sub	r11,r8,-3
800041b6:	8e 7c       	ld.sh	r12,r7[0xe]
800041b8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800041bc:	2f c8       	sub	r8,-4
800041be:	b4 88       	st.b	r10[0x0],r8
800041c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800041c4:	30 09       	mov	r9,0
800041c6:	4b 38       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
800041c8:	91 09       	st.w	r8[0x0],r9
800041ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800041ce:	4b f8       	lddpc	r8,800042c8 <phy_rx_func+0xc34>
800041d0:	70 09       	ld.w	r9,r8[0x0]
800041d2:	8e 4b       	ld.sh	r11,r7[0x8]
800041d4:	4b ea       	lddpc	r10,800042cc <phy_rx_func+0xc38>
800041d6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800041da:	2f f9       	sub	r9,-1
800041dc:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800041de:	4b 48       	lddpc	r8,800042ac <phy_rx_func+0xc18>
800041e0:	70 09       	ld.w	r9,r8[0x0]
800041e2:	20 29       	sub	r9,2
800041e4:	91 09       	st.w	r8[0x0],r9
800041e6:	70 08       	ld.w	r8,r8[0x0]
800041e8:	58 08       	cp.w	r8,0
800041ea:	c2 f1       	brne	80004248 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
800041ec:	30 09       	mov	r9,0
800041ee:	4b 78       	lddpc	r8,800042c8 <phy_rx_func+0xc34>
800041f0:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800041f2:	8e 59       	ld.sh	r9,r7[0xa]
800041f4:	fe 78 82 12 	mov	r8,-32238
800041f8:	f0 09 19 00 	cp.h	r9,r8
800041fc:	c2 11       	brne	8000423e <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800041fe:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004202:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004206:	4a e8       	lddpc	r8,800042bc <phy_rx_func+0xc28>
80004208:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
8000420a:	8e 59       	ld.sh	r9,r7[0xa]
8000420c:	4a d8       	lddpc	r8,800042c0 <phy_rx_func+0xc2c>
8000420e:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80004210:	8e 69       	ld.sh	r9,r7[0xc]
80004212:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004214:	f0 1f 00 2c 	mcall	800042c4 <phy_rx_func+0xc30>
80004218:	49 f8       	lddpc	r8,80004294 <phy_rx_func+0xc00>
8000421a:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000421c:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004220:	31 38       	mov	r8,19
80004222:	f0 09 18 00 	cp.b	r9,r8
80004226:	c0 71       	brne	80004234 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004228:	10 99       	mov	r9,r8
8000422a:	4a 08       	lddpc	r8,800042a8 <phy_rx_func+0xc14>
8000422c:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
8000422e:	30 09       	mov	r9,0
80004230:	49 a8       	lddpc	r8,80004298 <phy_rx_func+0xc04>
80004232:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004234:	30 49       	mov	r9,4
80004236:	49 78       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
80004238:	91 09       	st.w	r8[0x0],r9
8000423a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000423e:	30 09       	mov	r9,0
80004240:	49 48       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
80004242:	91 09       	st.w	r8[0x0],r9
80004244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004248:	4a 8c       	lddpc	r12,800042e8 <phy_rx_func+0xc54>
8000424a:	f0 1f 00 16 	mcall	800042a0 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
8000424e:	30 09       	mov	r9,0
80004250:	49 08       	lddpc	r8,80004290 <phy_rx_func+0xbfc>
80004252:	91 09       	st.w	r8[0x0],r9
80004254:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004258:	00 00       	add	r0,r0
8000425a:	0a c0       	st.b	r5++,r0
8000425c:	00 00       	add	r0,r0
8000425e:	0a b8       	st.h	r5++,r8
80004260:	00 00       	add	r0,r0
80004262:	0a 8c       	andn	r12,r5
80004264:	00 00       	add	r0,r0
80004266:	0a 68       	and	r8,r5
80004268:	00 00       	add	r0,r0
8000426a:	0a d2       	st.w	--r5,r2
8000426c:	00 00       	add	r0,r0
8000426e:	0a 98       	mov	r8,r5
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	30 60       	mov	r0,6
80004274:	00 00       	add	r0,r0
80004276:	0a 78       	tst	r8,r5
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	5a a0       	cp.w	r0,-22
8000427c:	00 00       	add	r0,r0
8000427e:	0a 94       	mov	r4,r5
80004280:	80 00       	ld.sh	r0,r0[0x0]
80004282:	2f ac       	sub	r12,-6
80004284:	00 00       	add	r0,r0
80004286:	0a a8       	st.w	r5++,r8
80004288:	00 00       	add	r0,r0
8000428a:	0a 74       	tst	r4,r5
8000428c:	00 00       	add	r0,r0
8000428e:	0a b0       	st.h	r5++,r0
80004290:	00 00       	add	r0,r0
80004292:	0a 84       	andn	r4,r5
80004294:	00 00       	add	r0,r0
80004296:	0a 70       	tst	r0,r5
80004298:	00 00       	add	r0,r0
8000429a:	0a 9c       	mov	r12,r5
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	d1 b8       	*unknown*
800042a0:	80 00       	ld.sh	r0,r0[0x0]
800042a2:	6b 40       	ld.w	r0,r5[0x50]
800042a4:	00 00       	add	r0,r0
800042a6:	0a 4d       	or	sp,r5
800042a8:	00 00       	add	r0,r0
800042aa:	0a d0       	st.w	--r5,r0
800042ac:	00 00       	add	r0,r0
800042ae:	0a 6c       	and	r12,r5
800042b0:	00 00       	add	r0,r0
800042b2:	0a ac       	st.w	r5++,r12
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	74 b6       	ld.w	r6,r10[0x2c]
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	36 34       	mov	r4,99
800042bc:	00 00       	add	r0,r0
800042be:	0a 4e       	or	lr,r5
800042c0:	00 00       	add	r0,r0
800042c2:	1e 88       	andn	r8,pc
800042c4:	80 00       	ld.sh	r0,r0[0x0]
800042c6:	2e f0       	sub	r0,-17
800042c8:	00 00       	add	r0,r0
800042ca:	0a c8       	st.b	r5++,r8
800042cc:	00 00       	add	r0,r0
800042ce:	1d 8c       	ld.ub	r12,lr[0x0]
800042d0:	00 00       	add	r0,r0
800042d2:	0a d4       	st.w	--r5,r4
800042d4:	00 00       	add	r0,r0
800042d6:	0a 55       	eor	r5,r5
800042d8:	00 00       	add	r0,r0
800042da:	1d 84       	ld.ub	r4,lr[0x0]
800042dc:	00 00       	add	r0,r0
800042de:	0a 88       	andn	r8,r5
800042e0:	00 00       	add	r0,r0
800042e2:	1e 8c       	andn	r12,pc
800042e4:	00 00       	add	r0,r0
800042e6:	0a 41       	or	r1,r5
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	d1 d0       	acall	0x1d

800042ec <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800042ec:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800042ee:	49 88       	lddpc	r8,8000434c <pdca_int_handler+0x60>
800042f0:	11 89       	ld.ub	r9,r8[0x0]
800042f2:	ec 19 00 01 	eorl	r9,0x1
800042f6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800042f8:	11 89       	ld.ub	r9,r8[0x0]
800042fa:	a5 69       	lsl	r9,0x4
800042fc:	2f c9       	sub	r9,-4
800042fe:	49 5a       	lddpc	r10,80004350 <pdca_int_handler+0x64>
80004300:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004302:	fe 7a 00 40 	mov	r10,-65472
80004306:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004308:	30 39       	mov	r9,3
8000430a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
8000430c:	11 8a       	ld.ub	r10,r8[0x0]
8000430e:	a5 6a       	lsl	r10,0x4
80004310:	2f ca       	sub	r10,-4
80004312:	49 18       	lddpc	r8,80004354 <pdca_int_handler+0x68>
80004314:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004316:	fe 78 00 00 	mov	r8,-65536
8000431a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000431c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000431e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004320:	48 e8       	lddpc	r8,80004358 <pdca_int_handler+0x6c>
80004322:	70 08       	ld.w	r8,r8[0x0]
80004324:	58 08       	cp.w	r8,0
80004326:	c0 70       	breq	80004334 <pdca_int_handler+0x48>
80004328:	48 99       	lddpc	r9,8000434c <pdca_int_handler+0x60>
8000432a:	13 89       	ld.ub	r9,r9[0x0]
8000432c:	a5 69       	lsl	r9,0x4
8000432e:	48 ac       	lddpc	r12,80004354 <pdca_int_handler+0x68>
80004330:	12 0c       	add	r12,r9
80004332:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004334:	48 a8       	lddpc	r8,8000435c <pdca_int_handler+0x70>
80004336:	70 08       	ld.w	r8,r8[0x0]
80004338:	58 08       	cp.w	r8,0
8000433a:	c0 70       	breq	80004348 <pdca_int_handler+0x5c>
8000433c:	48 49       	lddpc	r9,8000434c <pdca_int_handler+0x60>
8000433e:	13 89       	ld.ub	r9,r9[0x0]
80004340:	a5 69       	lsl	r9,0x4
80004342:	48 4c       	lddpc	r12,80004350 <pdca_int_handler+0x64>
80004344:	12 0c       	add	r12,r9
80004346:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004348:	d4 02       	popm	lr
8000434a:	d6 03       	rete
8000434c:	00 00       	add	r0,r0
8000434e:	50 ac       	stdsp	sp[0x28],r12
80004350:	00 00       	add	r0,r0
80004352:	50 d4       	stdsp	sp[0x34],r4
80004354:	00 00       	add	r0,r0
80004356:	50 b4       	stdsp	sp[0x2c],r4
80004358:	00 00       	add	r0,r0
8000435a:	0a dc       	st.w	--r5,r12
8000435c:	00 00       	add	r0,r0
8000435e:	0a e0       	st.h	--r5,r0

80004360 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004360:	fe 78 10 00 	mov	r8,-61440
80004364:	e0 69 0d c0 	mov	r9,3520
80004368:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
8000436c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004370:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004374:	fe 78 34 00 	mov	r8,-52224
80004378:	e0 69 80 00 	mov	r9,32768
8000437c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000437e:	30 09       	mov	r9,0
80004380:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004382:	e0 69 04 21 	mov	r9,1057
80004386:	ea 19 3f 20 	orh	r9,0x3f20
8000438a:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
8000438c:	e0 69 02 9f 	mov	r9,671
80004390:	ea 19 01 00 	orh	r9,0x100
80004394:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004396:	e0 6a 04 02 	mov	r10,1026
8000439a:	ea 1a 3f 20 	orh	r10,0x3f20
8000439e:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800043a0:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800043a2:	5e fc       	retal	r12

800043a4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800043a4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800043a6:	30 19       	mov	r9,1
800043a8:	49 78       	lddpc	r8,80004404 <local_start_PDC+0x60>
800043aa:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800043ac:	fe 78 00 00 	mov	r8,-65536
800043b0:	30 7b       	mov	r11,7
800043b2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800043b4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800043b6:	49 59       	lddpc	r9,80004408 <local_start_PDC+0x64>
800043b8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800043bc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800043be:	30 3a       	mov	r10,3
800043c0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800043c2:	30 1c       	mov	r12,1
800043c4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800043c6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800043c8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800043ca:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800043cc:	30 2c       	mov	r12,2
800043ce:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800043d0:	48 f9       	lddpc	r9,8000440c <local_start_PDC+0x68>
800043d2:	e0 68 5a 5a 	mov	r8,23130
800043d6:	ea 18 ab cd 	orh	r8,0xabcd
800043da:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800043dc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800043de:	30 0e       	mov	lr,0
800043e0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800043e2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800043e4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800043e6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800043e8:	fe 78 00 40 	mov	r8,-65472
800043ec:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800043ee:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800043f0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800043f4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800043f6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800043f8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800043fa:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800043fc:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800043fe:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004400:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004402:	d8 02       	popm	pc
80004404:	00 00       	add	r0,r0
80004406:	50 ac       	stdsp	sp[0x28],r12
80004408:	00 00       	add	r0,r0
8000440a:	50 b4       	stdsp	sp[0x2c],r4
8000440c:	00 00       	add	r0,r0
8000440e:	50 d4       	stdsp	sp[0x34],r4

80004410 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004410:	48 38       	lddpc	r8,8000441c <register_rx_tx_func+0xc>
80004412:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004414:	48 38       	lddpc	r8,80004420 <register_rx_tx_func+0x10>
80004416:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004418:	5e fc       	retal	r12
8000441a:	00 00       	add	r0,r0
8000441c:	00 00       	add	r0,r0
8000441e:	0a dc       	st.w	--r5,r12
80004420:	00 00       	add	r0,r0
80004422:	0a e0       	st.h	--r5,r0

80004424 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004424:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004426:	fe 78 10 00 	mov	r8,-61440
8000442a:	30 29       	mov	r9,2
8000442c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004430:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004434:	10 99       	mov	r9,r8
80004436:	f2 f8 01 60 	ld.w	r8,r9[352]
8000443a:	e2 18 00 02 	andl	r8,0x2,COH
8000443e:	cf c0       	breq	80004436 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004440:	fe 79 10 00 	mov	r9,-61440
80004444:	f2 f8 01 60 	ld.w	r8,r9[352]
80004448:	e2 18 00 02 	andl	r8,0x2,COH
8000444c:	cf c1       	brne	80004444 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000444e:	30 3a       	mov	r10,3
80004450:	36 0b       	mov	r11,96
80004452:	48 bc       	lddpc	r12,8000447c <ssc_init+0x58>
80004454:	f0 1f 00 0b 	mcall	80004480 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004458:	f0 1f 00 0b 	mcall	80004484 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
8000445c:	f0 1f 00 0b 	mcall	80004488 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004460:	fe 79 00 00 	mov	r9,-65536
80004464:	30 18       	mov	r8,1
80004466:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004468:	fe 7a 00 40 	mov	r10,-65472
8000446c:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000446e:	e0 6b 01 01 	mov	r11,257
80004472:	fe 7a 34 00 	mov	r10,-52224
80004476:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004478:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
8000447a:	d8 02       	popm	pc
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	42 ec       	lddsp	r12,sp[0xb8]
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	50 50       	stdsp	sp[0x14],r0
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	43 60       	lddsp	r0,sp[0xd8]
80004488:	80 00       	ld.sh	r0,r0[0x0]
8000448a:	43 a4       	lddsp	r4,sp[0xe8]

8000448c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
8000448c:	48 28       	lddpc	r8,80004494 <xcmp_register_app_list+0x8>
8000448e:	91 0c       	st.w	r8[0x0],r12
}
80004490:	5e fc       	retal	r12
80004492:	00 00       	add	r0,r0
80004494:	00 00       	add	r0,r0
80004496:	50 f4       	stdsp	sp[0x3c],r4

80004498 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004498:	eb cd 40 80 	pushm	r7,lr
8000449c:	fa cd 01 00 	sub	sp,sp,256
800044a0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800044a2:	16 98       	mov	r8,r11
800044a4:	2f 08       	sub	r8,-16
800044a6:	af a8       	sbr	r8,0xe
800044a8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800044aa:	3f f8       	mov	r8,-1
800044ac:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800044ae:	30 b9       	mov	r9,11
800044b0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800044b2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800044b4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800044b6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800044b8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800044ba:	f6 ca ff fe 	sub	r10,r11,-2
800044be:	18 9b       	mov	r11,r12
800044c0:	fa cc ff f0 	sub	r12,sp,-16
800044c4:	f0 1f 00 05 	mcall	800044d8 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800044c8:	2f e7       	sub	r7,-2
800044ca:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800044cc:	1a 9c       	mov	r12,sp
800044ce:	f0 1f 00 04 	mcall	800044dc <xcmp_tx+0x44>
}
800044d2:	2c 0d       	sub	sp,-256
800044d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	73 6e       	ld.w	lr,r9[0x58]
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	49 98       	lddpc	r8,80004540 <xcmp_audio_route_AMBE+0x34>

800044e0 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
800044e0:	d4 01       	pushm	lr
800044e2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800044e6:	e0 68 04 21 	mov	r8,1057
800044ea:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
800044ec:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
800044f0:	30 19       	mov	r9,1
800044f2:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
800044f4:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
800044f6:	30 39       	mov	r9,3
800044f8:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
800044fa:	30 3b       	mov	r11,3
800044fc:	fa cc ff fe 	sub	r12,sp,-2
80004500:	f0 1f 00 02 	mcall	80004508 <xcmp_enter_device_control_mode+0x28>
}
80004504:	2c dd       	sub	sp,-204
80004506:	d8 02       	popm	pc
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	44 98       	lddsp	r8,sp[0x124]

8000450c <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
8000450c:	d4 01       	pushm	lr
8000450e:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004512:	e0 68 04 14 	mov	r8,1044
80004516:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004518:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
8000451c:	30 19       	mov	r9,1
8000451e:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004520:	30 09       	mov	r9,0
80004522:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004524:	30 69       	mov	r9,6
80004526:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004528:	30 fa       	mov	r10,15
8000452a:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000452c:	30 c9       	mov	r9,12
8000452e:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004530:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80004532:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80004534:	31 0a       	mov	r10,16
80004536:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004538:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
8000453c:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80004540:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80004544:	31 1a       	mov	r10,17
80004546:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000454a:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
8000454e:	31 3a       	mov	r10,19
80004550:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004554:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004558:	30 fb       	mov	r11,15
8000455a:	fa cc ff fe 	sub	r12,sp,-2
8000455e:	f0 1f 00 03 	mcall	80004568 <xcmp_audio_route_AMBE+0x5c>

	
}
80004562:	2c dd       	sub	sp,-204
80004564:	d8 02       	popm	pc
80004566:	00 00       	add	r0,r0
80004568:	80 00       	ld.sh	r0,r0[0x0]
8000456a:	44 98       	lddsp	r8,sp[0x124]

8000456c <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
8000456c:	d4 01       	pushm	lr
8000456e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80004572:	e0 68 04 65 	mov	r8,1125
80004576:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004578:	fa cc ff fe 	sub	r12,sp,-2
8000457c:	30 18       	mov	r8,1
8000457e:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80004580:	30 1b       	mov	r11,1
80004582:	f0 1f 00 03 	mcall	8000458c <xcmp_enter_enhanced_OB_mode+0x20>
}
80004586:	2c dd       	sub	sp,-204
80004588:	d8 02       	popm	pc
8000458a:	00 00       	add	r0,r0
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	44 98       	lddsp	r8,sp[0x124]

80004590 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004590:	d4 01       	pushm	lr
80004592:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004596:	fe 78 b4 00 	mov	r8,-19456
8000459a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000459c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800045a0:	30 89       	mov	r9,8
800045a2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800045a4:	30 19       	mov	r9,1
800045a6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800045a8:	30 09       	mov	r9,0
800045aa:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800045ac:	30 5a       	mov	r10,5
800045ae:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800045b0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800045b2:	30 7a       	mov	r10,7
800045b4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800045b6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800045b8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800045ba:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800045be:	30 9b       	mov	r11,9
800045c0:	fa cc ff fe 	sub	r12,sp,-2
800045c4:	f0 1f 00 02 	mcall	800045cc <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800045c8:	2c dd       	sub	sp,-204
800045ca:	d8 02       	popm	pc
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	44 98       	lddsp	r8,sp[0x124]

800045d0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800045d0:	d4 01       	pushm	lr
800045d2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800045d6:	fe 78 80 00 	mov	r8,-32768
800045da:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800045dc:	30 38       	mov	r8,3
800045de:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800045e0:	30 1b       	mov	r11,1
800045e2:	fa cc ff fe 	sub	r12,sp,-2
800045e6:	f0 1f 00 03 	mcall	800045f0 <xcmp_opcode_not_supported+0x20>
}
800045ea:	2c dd       	sub	sp,-204
800045ec:	d8 02       	popm	pc
800045ee:	00 00       	add	r0,r0
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	44 98       	lddsp	r8,sp[0x124]

800045f4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800045f4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800045f6:	96 88       	ld.uh	r8,r11[0x0]
800045f8:	e2 18 f0 00 	andl	r8,0xf000,COH
800045fc:	e0 48 80 00 	cp.w	r8,32768
80004600:	c0 f0       	breq	8000461e <xcmp_exec_func+0x2a>
80004602:	e0 48 b0 00 	cp.w	r8,45056
80004606:	c1 20       	breq	8000462a <xcmp_exec_func+0x36>
80004608:	58 08       	cp.w	r8,0
8000460a:	c1 51       	brne	80004634 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000460c:	78 08       	ld.w	r8,r12[0x0]
8000460e:	58 08       	cp.w	r8,0
80004610:	c0 40       	breq	80004618 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004612:	16 9c       	mov	r12,r11
80004614:	5d 18       	icall	r8
80004616:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004618:	f0 1f 00 08 	mcall	80004638 <xcmp_exec_func+0x44>
8000461c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000461e:	78 18       	ld.w	r8,r12[0x4]
80004620:	58 08       	cp.w	r8,0
80004622:	c0 90       	breq	80004634 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004624:	16 9c       	mov	r12,r11
80004626:	5d 18       	icall	r8
80004628:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000462a:	78 28       	ld.w	r8,r12[0x8]
8000462c:	58 08       	cp.w	r8,0
8000462e:	c0 30       	breq	80004634 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004630:	16 9c       	mov	r12,r11
80004632:	5d 18       	icall	r8
80004634:	d8 02       	popm	pc
80004636:	00 00       	add	r0,r0
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	45 d0       	lddsp	r0,sp[0x174]

8000463c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
8000463c:	d4 01       	pushm	lr
8000463e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004642:	e0 68 04 09 	mov	r8,1033
80004646:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004648:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
8000464c:	30 19       	mov	r9,1
8000464e:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004650:	30 09       	mov	r9,0
80004652:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004654:	30 ca       	mov	r10,12
80004656:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004658:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000465a:	fb 69 00 08 	st.b	sp[8],r9
8000465e:	fa c8 ff f7 	sub	r8,sp,-9
80004662:	b0 89       	st.b	r8[0x0],r9
80004664:	fa c8 ff f6 	sub	r8,sp,-10
80004668:	b0 89       	st.b	r8[0x0],r9
8000466a:	fa c8 ff f5 	sub	r8,sp,-11
8000466e:	b0 89       	st.b	r8[0x0],r9
80004670:	fa c8 ff f4 	sub	r8,sp,-12
80004674:	b0 89       	st.b	r8[0x0],r9
80004676:	fa c8 ff f3 	sub	r8,sp,-13
8000467a:	b0 89       	st.b	r8[0x0],r9
8000467c:	fa c8 ff f2 	sub	r8,sp,-14
80004680:	b0 89       	st.b	r8[0x0],r9
80004682:	fa c8 ff f1 	sub	r8,sp,-15
80004686:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004688:	30 cb       	mov	r11,12
8000468a:	fa cc ff fe 	sub	r12,sp,-2
8000468e:	f0 1f 00 03 	mcall	80004698 <xcmp_IdleTestTone+0x5c>
}
80004692:	2c dd       	sub	sp,-204
80004694:	d8 02       	popm	pc
80004696:	00 00       	add	r0,r0
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	44 98       	lddsp	r8,sp[0x124]

8000469c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000469c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000469e:	48 dc       	lddpc	r12,800046d0 <xcmp_init+0x34>
800046a0:	f0 1f 00 0d 	mcall	800046d4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800046a4:	30 4b       	mov	r11,4
800046a6:	31 4c       	mov	r12,20
800046a8:	f0 1f 00 0c 	mcall	800046d8 <xcmp_init+0x3c>
800046ac:	48 c8       	lddpc	r8,800046dc <xcmp_init+0x40>
800046ae:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800046b0:	30 09       	mov	r9,0
800046b2:	1a d9       	st.w	--sp,r9
800046b4:	1a d9       	st.w	--sp,r9
800046b6:	1a d9       	st.w	--sp,r9
800046b8:	30 38       	mov	r8,3
800046ba:	e0 6a 01 80 	mov	r10,384
800046be:	48 9b       	lddpc	r11,800046e0 <xcmp_init+0x44>
800046c0:	48 9c       	lddpc	r12,800046e4 <xcmp_init+0x48>
800046c2:	f0 1f 00 0a 	mcall	800046e8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800046c6:	f0 1f 00 0a 	mcall	800046ec <xcmp_init+0x50>
800046ca:	2f dd       	sub	sp,-12
	
}
800046cc:	d8 02       	popm	pc
800046ce:	00 00       	add	r0,r0
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	47 ec       	lddsp	r12,sp[0x1f8]
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	48 38       	lddpc	r8,800046e0 <xcmp_init+0x44>
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	5f 1c       	srne	r12
800046dc:	00 00       	add	r0,r0
800046de:	0a f0       	st.b	--r5,r0
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	d1 fc       	*unknown*
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	46 f0       	lddsp	r0,sp[0x1bc]
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	65 f0       	ld.w	r0,r2[0x7c]
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	4a 7c       	lddpc	r12,80004788 <xcmp_rx_process+0x98>

800046f0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800046f0:	d4 31       	pushm	r0-r7,lr
800046f2:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800046f4:	4b 16       	lddpc	r6,800047b8 <xcmp_rx_process+0xc8>
800046f6:	30 05       	mov	r5,0
800046f8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800046fa:	4b 13       	lddpc	r3,800047bc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800046fc:	4b 12       	lddpc	r2,800047c0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800046fe:	4b 21       	lddpc	r1,800047c4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004700:	4b 20       	lddpc	r0,800047c8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004702:	6c 0c       	ld.w	r12,r6[0x0]
80004704:	0a 99       	mov	r9,r5
80004706:	08 9a       	mov	r10,r4
80004708:	1a 9b       	mov	r11,sp
8000470a:	f0 1f 00 31 	mcall	800047cc <xcmp_rx_process+0xdc>
8000470e:	58 1c       	cp.w	r12,1
80004710:	cf 91       	brne	80004702 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004712:	40 0b       	lddsp	r11,sp[0x0]
80004714:	58 0b       	cp.w	r11,0
80004716:	cf 60       	breq	80004702 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004718:	96 0a       	ld.sh	r10,r11[0x0]
8000471a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000471e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004722:	59 c8       	cp.w	r8,28
80004724:	c1 e0       	breq	80004760 <xcmp_rx_process+0x70>
80004726:	e0 89 00 07 	brgt	80004734 <xcmp_rx_process+0x44>
8000472a:	58 e8       	cp.w	r8,14
8000472c:	c0 e0       	breq	80004748 <xcmp_rx_process+0x58>
8000472e:	58 f8       	cp.w	r8,15
80004730:	c2 41       	brne	80004778 <xcmp_rx_process+0x88>
80004732:	c0 f8       	rjmp	80004750 <xcmp_rx_process+0x60>
80004734:	e0 48 01 09 	cp.w	r8,265
80004738:	c1 80       	breq	80004768 <xcmp_rx_process+0x78>
8000473a:	e0 48 01 0a 	cp.w	r8,266
8000473e:	c1 90       	breq	80004770 <xcmp_rx_process+0x80>
80004740:	e0 48 00 2c 	cp.w	r8,44
80004744:	c1 a1       	brne	80004778 <xcmp_rx_process+0x88>
80004746:	c0 98       	rjmp	80004758 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004748:	4a 2c       	lddpc	r12,800047d0 <xcmp_rx_process+0xe0>
8000474a:	f0 1f 00 23 	mcall	800047d4 <xcmp_rx_process+0xe4>
					break;
8000474e:	c2 f8       	rjmp	800047ac <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004750:	4a 2c       	lddpc	r12,800047d8 <xcmp_rx_process+0xe8>
80004752:	f0 1f 00 21 	mcall	800047d4 <xcmp_rx_process+0xe4>
					break;
80004756:	c2 b8       	rjmp	800047ac <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004758:	4a 1c       	lddpc	r12,800047dc <xcmp_rx_process+0xec>
8000475a:	f0 1f 00 1f 	mcall	800047d4 <xcmp_rx_process+0xe4>
					break;
8000475e:	c2 78       	rjmp	800047ac <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004760:	04 9c       	mov	r12,r2
80004762:	f0 1f 00 1d 	mcall	800047d4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004766:	c2 38       	rjmp	800047ac <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004768:	02 9c       	mov	r12,r1
8000476a:	f0 1f 00 1b 	mcall	800047d4 <xcmp_rx_process+0xe4>
					break;
8000476e:	c1 f8       	rjmp	800047ac <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004770:	00 9c       	mov	r12,r0
80004772:	f0 1f 00 19 	mcall	800047d4 <xcmp_rx_process+0xe4>
					break;
80004776:	c1 b8       	rjmp	800047ac <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004778:	12 98       	mov	r8,r9
8000477a:	e2 18 04 00 	andl	r8,0x400,COH
8000477e:	c0 70       	breq	8000478c <xcmp_rx_process+0x9c>
80004780:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004784:	e0 48 00 68 	cp.w	r8,104
80004788:	e0 8a 00 08 	brle	80004798 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000478c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004790:	c0 e1       	brne	800047ac <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004792:	f0 1f 00 14 	mcall	800047e0 <xcmp_rx_process+0xf0>
80004796:	c0 b8       	rjmp	800047ac <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004798:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000479c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800047a0:	49 19       	lddpc	r9,800047e4 <xcmp_rx_process+0xf4>
800047a2:	72 08       	ld.w	r8,r9[0x0]
800047a4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800047a8:	f0 1f 00 0b 	mcall	800047d4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800047ac:	66 0c       	ld.w	r12,r3[0x0]
800047ae:	40 0b       	lddsp	r11,sp[0x0]
800047b0:	f0 1f 00 0e 	mcall	800047e8 <xcmp_rx_process+0xf8>
800047b4:	ca 7b       	rjmp	80004702 <xcmp_rx_process+0x12>
800047b6:	00 00       	add	r0,r0
800047b8:	00 00       	add	r0,r0
800047ba:	0a f0       	st.b	--r5,r0
800047bc:	00 00       	add	r0,r0
800047be:	0a 98       	mov	r8,r5
800047c0:	00 00       	add	r0,r0
800047c2:	0b 00       	ld.w	r0,r5++
800047c4:	00 00       	add	r0,r0
800047c6:	0a f4       	st.b	--r5,r4
800047c8:	00 00       	add	r0,r0
800047ca:	0b 0c       	ld.w	r12,r5++
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	5c 10       	scr	r0
800047d0:	00 00       	add	r0,r0
800047d2:	0b 24       	ld.uh	r4,r5++
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	45 f4       	lddsp	r4,sp[0x17c]
800047d8:	00 00       	add	r0,r0
800047da:	0a e4       	st.h	--r5,r4
800047dc:	00 00       	add	r0,r0
800047de:	0b 18       	ld.sh	r8,r5++
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	45 d0       	lddsp	r0,sp[0x174]
800047e4:	00 00       	add	r0,r0
800047e6:	50 f4       	stdsp	sp[0x3c],r4
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	2f e4       	sub	r4,-2

800047ec <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800047ec:	eb cd 40 90 	pushm	r4,r7,lr
800047f0:	20 1d       	sub	sp,4
800047f2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800047f6:	48 c8       	lddpc	r8,80004824 <xcmp_rx+0x38>
800047f8:	70 0c       	ld.w	r12,r8[0x0]
800047fa:	f0 1f 00 0c 	mcall	80004828 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800047fe:	c1 00       	breq	8000481e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004800:	fa c7 ff fc 	sub	r7,sp,-4
80004804:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004806:	e0 6a 00 ca 	mov	r10,202
8000480a:	08 9b       	mov	r11,r4
8000480c:	f0 1f 00 08 	mcall	8000482c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004810:	48 88       	lddpc	r8,80004830 <xcmp_rx+0x44>
80004812:	70 0c       	ld.w	r12,r8[0x0]
80004814:	30 09       	mov	r9,0
80004816:	12 9a       	mov	r10,r9
80004818:	1a 9b       	mov	r11,sp
8000481a:	f0 1f 00 07 	mcall	80004834 <xcmp_rx+0x48>
	}	
}
8000481e:	2f fd       	sub	sp,-4
80004820:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004824:	00 00       	add	r0,r0
80004826:	0a 98       	mov	r8,r5
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	35 50       	mov	r0,85
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	73 6e       	ld.w	lr,r9[0x58]
80004830:	00 00       	add	r0,r0
80004832:	0a f0       	st.b	--r5,r0
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	5e 1c       	retne	r12

80004838 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004838:	48 28       	lddpc	r8,80004840 <xnl_register_xcmp_func+0x8>
8000483a:	91 0c       	st.w	r8[0x0],r12
}
8000483c:	5e fc       	retal	r12
8000483e:	00 00       	add	r0,r0
80004840:	00 00       	add	r0,r0
80004842:	0b 50       	ld.sh	r0,--r5

80004844 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004844:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004846:	48 88       	lddpc	r8,80004864 <xnl_get_msg_ack_func+0x20>
80004848:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000484a:	98 49       	ld.sh	r9,r12[0x8]
8000484c:	f0 09 19 00 	cp.h	r9,r8
80004850:	c0 81       	brne	80004860 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004852:	48 68       	lddpc	r8,80004868 <xnl_get_msg_ack_func+0x24>
80004854:	70 0c       	ld.w	r12,r8[0x0]
80004856:	30 09       	mov	r9,0
80004858:	12 9a       	mov	r10,r9
8000485a:	12 9b       	mov	r11,r9
8000485c:	f0 1f 00 04 	mcall	8000486c <xnl_get_msg_ack_func+0x28>
80004860:	d8 02       	popm	pc
80004862:	00 00       	add	r0,r0
80004864:	00 00       	add	r0,r0
80004866:	0b 36       	ld.ub	r6,r5++
80004868:	00 00       	add	r0,r0
8000486a:	0b 30       	ld.ub	r0,r5++
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	5e 1c       	retne	r12

80004870 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004870:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004872:	4a 86       	lddpc	r6,80004910 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004874:	4a 82       	lddpc	r2,80004914 <xnl_tx_process+0xa4>
80004876:	4a 94       	lddpc	r4,80004918 <xnl_tx_process+0xa8>
80004878:	30 07       	mov	r7,0
8000487a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000487c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000487e:	4a 85       	lddpc	r5,8000491c <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004880:	4a 83       	lddpc	r3,80004920 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004882:	6c 08       	ld.w	r8,r6[0x0]
80004884:	58 08       	cp.w	r8,0
80004886:	c0 40       	breq	8000488e <xnl_tx_process+0x1e>
80004888:	58 18       	cp.w	r8,1
8000488a:	cf d1       	brne	80004884 <xnl_tx_process+0x14>
8000488c:	c2 08       	rjmp	800048cc <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000488e:	64 0c       	ld.w	r12,r2[0x0]
80004890:	0e 99       	mov	r9,r7
80004892:	02 9a       	mov	r10,r1
80004894:	08 9b       	mov	r11,r4
80004896:	f0 1f 00 24 	mcall	80004924 <xnl_tx_process+0xb4>
8000489a:	58 1c       	cp.w	r12,1
8000489c:	cf 31       	brne	80004882 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000489e:	68 0c       	ld.w	r12,r4[0x0]
800048a0:	58 0c       	cp.w	r12,0
800048a2:	cf 00       	breq	80004882 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800048a4:	98 28       	ld.sh	r8,r12[0x4]
800048a6:	e0 08 19 00 	cp.h	r8,r0
800048aa:	c0 41       	brne	800048b2 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800048ac:	f0 1f 00 1f 	mcall	80004928 <xnl_tx_process+0xb8>
						break;
800048b0:	ce 9b       	rjmp	80004882 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800048b2:	f0 1f 00 1f 	mcall	8000492c <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800048b6:	30 18       	mov	r8,1
800048b8:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800048ba:	66 0c       	ld.w	r12,r3[0x0]
800048bc:	0e 99       	mov	r9,r7
800048be:	0e 9a       	mov	r10,r7
800048c0:	0e 9b       	mov	r11,r7
800048c2:	f0 1f 00 19 	mcall	80004924 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800048c6:	30 18       	mov	r8,1
800048c8:	8d 08       	st.w	r6[0x0],r8
800048ca:	cd cb       	rjmp	80004882 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800048cc:	66 0c       	ld.w	r12,r3[0x0]
800048ce:	0e 99       	mov	r9,r7
800048d0:	36 4a       	mov	r10,100
800048d2:	0e 9b       	mov	r11,r7
800048d4:	f0 1f 00 14 	mcall	80004924 <xnl_tx_process+0xb4>
800048d8:	58 1c       	cp.w	r12,1
800048da:	c0 81       	brne	800048ea <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800048dc:	49 58       	lddpc	r8,80004930 <xnl_tx_process+0xc0>
800048de:	70 0c       	ld.w	r12,r8[0x0]
800048e0:	68 0b       	ld.w	r11,r4[0x0]
800048e2:	f0 1f 00 15 	mcall	80004934 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800048e6:	8d 07       	st.w	r6[0x0],r7
800048e8:	cc db       	rjmp	80004882 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800048ea:	6a 08       	ld.w	r8,r5[0x0]
800048ec:	58 38       	cp.w	r8,3
800048ee:	e0 89 00 09 	brgt	80004900 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800048f2:	68 0c       	ld.w	r12,r4[0x0]
800048f4:	f0 1f 00 0e 	mcall	8000492c <xnl_tx_process+0xbc>
						xnl_send_times++;
800048f8:	6a 08       	ld.w	r8,r5[0x0]
800048fa:	2f f8       	sub	r8,-1
800048fc:	8b 08       	st.w	r5[0x0],r8
800048fe:	cc 2b       	rjmp	80004882 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004900:	48 c8       	lddpc	r8,80004930 <xnl_tx_process+0xc0>
80004902:	70 0c       	ld.w	r12,r8[0x0]
80004904:	68 0b       	ld.w	r11,r4[0x0]
80004906:	f0 1f 00 0c 	mcall	80004934 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000490a:	8d 07       	st.w	r6[0x0],r7
8000490c:	cb bb       	rjmp	80004882 <xnl_tx_process+0x12>
8000490e:	00 00       	add	r0,r0
80004910:	00 00       	add	r0,r0
80004912:	0b 4c       	ld.w	r12,--r5
80004914:	00 00       	add	r0,r0
80004916:	0b 40       	ld.w	r0,--r5
80004918:	00 00       	add	r0,r0
8000491a:	0b 44       	ld.w	r4,--r5
8000491c:	00 00       	add	r0,r0
8000491e:	0b 48       	ld.w	r8,--r5
80004920:	00 00       	add	r0,r0
80004922:	0b 30       	ld.ub	r0,r5++
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	5c 10       	scr	r0
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	5a a0       	cp.w	r0,-22
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	30 04       	mov	r4,0
80004930:	00 00       	add	r0,r0
80004932:	0a 98       	mov	r8,r5
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	2f e4       	sub	r4,-2

80004938 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004938:	eb cd 40 fe 	pushm	r1-r7,lr
8000493c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000493e:	49 26       	lddpc	r6,80004984 <xnl_rx_process+0x4c>
80004940:	30 05       	mov	r5,0
80004942:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004944:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004946:	49 11       	lddpc	r1,80004988 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004948:	49 12       	lddpc	r2,8000498c <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000494a:	6c 0c       	ld.w	r12,r6[0x0]
8000494c:	0a 99       	mov	r9,r5
8000494e:	08 9a       	mov	r10,r4
80004950:	1a 9b       	mov	r11,sp
80004952:	f0 1f 00 10 	mcall	80004990 <xnl_rx_process+0x58>
80004956:	58 1c       	cp.w	r12,1
80004958:	cf 91       	brne	8000494a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000495a:	40 0c       	lddsp	r12,sp[0x0]
8000495c:	58 0c       	cp.w	r12,0
8000495e:	cf 60       	breq	8000494a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004960:	98 28       	ld.sh	r8,r12[0x4]
80004962:	e6 08 19 00 	cp.h	r8,r3
80004966:	e0 8b 00 0a 	brhi	8000497a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000496a:	5c 78       	castu.h	r8
8000496c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004970:	58 09       	cp.w	r9,0
80004972:	c0 40       	breq	8000497a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004974:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004978:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000497a:	62 0c       	ld.w	r12,r1[0x0]
8000497c:	40 0b       	lddsp	r11,sp[0x0]
8000497e:	f0 1f 00 06 	mcall	80004994 <xnl_rx_process+0x5c>
80004982:	ce 4b       	rjmp	8000494a <xnl_rx_process+0x12>
80004984:	00 00       	add	r0,r0
80004986:	0a c0       	st.b	r5++,r0
80004988:	00 00       	add	r0,r0
8000498a:	0a 98       	mov	r8,r5
8000498c:	00 00       	add	r0,r0
8000498e:	04 f4       	st.b	--r2,r4
80004990:	80 00       	ld.sh	r0,r0[0x0]
80004992:	5c 10       	scr	r0
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	2f e4       	sub	r4,-2

80004998 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004998:	eb cd 40 c0 	pushm	r6-r7,lr
8000499c:	20 1d       	sub	sp,4
8000499e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800049a0:	98 39       	ld.sh	r9,r12[0x6]
800049a2:	3f f8       	mov	r8,-1
800049a4:	f0 09 19 00 	cp.h	r9,r8
800049a8:	c0 a1       	brne	800049bc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800049aa:	4a e9       	lddpc	r9,80004a60 <xnl_tx+0xc8>
800049ac:	13 88       	ld.ub	r8,r9[0x0]
800049ae:	2f f8       	sub	r8,-1
800049b0:	5c 58       	castu.b	r8
800049b2:	b2 88       	st.b	r9[0x0],r8
800049b4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800049b8:	a9 a8       	sbr	r8,0x8
800049ba:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800049bc:	8c 49       	ld.sh	r9,r6[0x8]
800049be:	3f f8       	mov	r8,-1
800049c0:	f0 09 19 00 	cp.h	r9,r8
800049c4:	c0 41       	brne	800049cc <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800049c6:	4a 88       	lddpc	r8,80004a64 <xnl_tx+0xcc>
800049c8:	90 18       	ld.sh	r8,r8[0x2]
800049ca:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800049cc:	8c 59       	ld.sh	r9,r6[0xa]
800049ce:	3f f8       	mov	r8,-1
800049d0:	f0 09 19 00 	cp.h	r9,r8
800049d4:	c0 41       	brne	800049dc <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800049d6:	4a 48       	lddpc	r8,80004a64 <xnl_tx+0xcc>
800049d8:	90 28       	ld.sh	r8,r8[0x4]
800049da:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800049dc:	8c 69       	ld.sh	r9,r6[0xc]
800049de:	3f f8       	mov	r8,-1
800049e0:	f0 09 19 00 	cp.h	r9,r8
800049e4:	c0 e1       	brne	80004a00 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800049e6:	4a 08       	lddpc	r8,80004a64 <xnl_tx+0xcc>
800049e8:	90 49       	ld.sh	r9,r8[0x8]
800049ea:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800049ec:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800049ee:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800049f0:	90 49       	ld.sh	r9,r8[0x8]
800049f2:	e0 19 ff 00 	andl	r9,0xff00
800049f6:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800049fa:	f3 e8 10 08 	or	r8,r9,r8
800049fe:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004a00:	0d 98       	ld.ub	r8,r6[0x1]
80004a02:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004a04:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004a08:	10 0c       	add	r12,r8
80004a0a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a0c:	58 0c       	cp.w	r12,0
80004a0e:	e0 89 00 04 	brgt	80004a16 <xnl_tx+0x7e>
80004a12:	30 09       	mov	r9,0
80004a14:	c0 d8       	rjmp	80004a2e <xnl_tx+0x96>
80004a16:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004a1a:	2f ec       	sub	r12,-2
80004a1c:	30 09       	mov	r9,0
80004a1e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004a20:	15 1b       	ld.sh	r11,r10++
80004a22:	f6 09 00 09 	add	r9,r11,r9
80004a26:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004a28:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a2a:	18 38       	cp.w	r8,r12
80004a2c:	cf a1       	brne	80004a20 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004a2e:	5c 39       	neg	r9
80004a30:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a32:	48 e8       	lddpc	r8,80004a68 <xnl_tx+0xd0>
80004a34:	70 0c       	ld.w	r12,r8[0x0]
80004a36:	f0 1f 00 0e 	mcall	80004a6c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004a3a:	c1 00       	breq	80004a5a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a3c:	fa c7 ff fc 	sub	r7,sp,-4
80004a40:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004a42:	e0 6a 01 00 	mov	r10,256
80004a46:	0c 9b       	mov	r11,r6
80004a48:	f0 1f 00 0a 	mcall	80004a70 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004a4c:	48 a8       	lddpc	r8,80004a74 <xnl_tx+0xdc>
80004a4e:	70 0c       	ld.w	r12,r8[0x0]
80004a50:	30 09       	mov	r9,0
80004a52:	12 9a       	mov	r10,r9
80004a54:	1a 9b       	mov	r11,sp
80004a56:	f0 1f 00 09 	mcall	80004a78 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004a5a:	2f fd       	sub	sp,-4
80004a5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a60:	00 00       	add	r0,r0
80004a62:	0b 34       	ld.ub	r4,r5++
80004a64:	00 00       	add	r0,r0
80004a66:	0b 36       	ld.ub	r6,r5++
80004a68:	00 00       	add	r0,r0
80004a6a:	0a 98       	mov	r8,r5
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	35 50       	mov	r0,85
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	73 6e       	ld.w	lr,r9[0x58]
80004a74:	00 00       	add	r0,r0
80004a76:	0b 40       	ld.w	r0,--r5
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	5e 1c       	retne	r12

80004a7c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004a7c:	eb cd 40 80 	pushm	r7,lr
80004a80:	fa cd 01 00 	sub	sp,sp,256
	
	xnl_information.is_connected = FALSE;
80004a84:	30 09       	mov	r9,0
80004a86:	4a 78       	lddpc	r8,80004b20 <xnl_init+0xa4>
80004a88:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004a8a:	30 0b       	mov	r11,0
80004a8c:	30 1c       	mov	r12,1
80004a8e:	f0 1f 00 26 	mcall	80004b24 <xnl_init+0xa8>
80004a92:	4a 68       	lddpc	r8,80004b28 <xnl_init+0xac>
80004a94:	91 0c       	st.w	r8[0x0],r12
80004a96:	70 08       	ld.w	r8,r8[0x0]
80004a98:	58 08       	cp.w	r8,0
80004a9a:	c0 80       	breq	80004aaa <xnl_init+0x2e>
80004a9c:	4a 38       	lddpc	r8,80004b28 <xnl_init+0xac>
80004a9e:	70 0c       	ld.w	r12,r8[0x0]
80004aa0:	30 09       	mov	r9,0
80004aa2:	12 9a       	mov	r10,r9
80004aa4:	12 9b       	mov	r11,r9
80004aa6:	f0 1f 00 22 	mcall	80004b2c <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004aaa:	30 4b       	mov	r11,4
80004aac:	31 4c       	mov	r12,20
80004aae:	f0 1f 00 1e 	mcall	80004b24 <xnl_init+0xa8>
80004ab2:	4a 08       	lddpc	r8,80004b30 <xnl_init+0xb4>
80004ab4:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004ab6:	30 07       	mov	r7,0
80004ab8:	1a d7       	st.w	--sp,r7
80004aba:	1a d7       	st.w	--sp,r7
80004abc:	1a d7       	st.w	--sp,r7
80004abe:	30 38       	mov	r8,3
80004ac0:	0e 99       	mov	r9,r7
80004ac2:	e0 6a 02 00 	mov	r10,512
80004ac6:	49 cb       	lddpc	r11,80004b34 <xnl_init+0xb8>
80004ac8:	49 cc       	lddpc	r12,80004b38 <xnl_init+0xbc>
80004aca:	f0 1f 00 1d 	mcall	80004b3c <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004ace:	1a d7       	st.w	--sp,r7
80004ad0:	1a d7       	st.w	--sp,r7
80004ad2:	1a d7       	st.w	--sp,r7
80004ad4:	30 38       	mov	r8,3
80004ad6:	0e 99       	mov	r9,r7
80004ad8:	e0 6a 03 20 	mov	r10,800
80004adc:	49 9b       	lddpc	r11,80004b40 <xnl_init+0xc4>
80004ade:	49 ac       	lddpc	r12,80004b44 <xnl_init+0xc8>
80004ae0:	f0 1f 00 17 	mcall	80004b3c <xnl_init+0xc0>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004ae4:	e0 68 40 0e 	mov	r8,16398
80004ae8:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004aec:	3f f8       	mov	r8,-1
80004aee:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004af2:	30 38       	mov	r8,3
80004af4:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004af8:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004afc:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004b00:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004b04:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004b08:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b0c:	fa cc ff e8 	sub	r12,sp,-24
80004b10:	f0 1f 00 0e 	mcall	80004b48 <xnl_init+0xcc>
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
	
	/*initialize the physical layer*/
	phy_init();
80004b14:	f0 1f 00 0e 	mcall	80004b4c <xnl_init+0xd0>
80004b18:	2f ad       	sub	sp,-24
}
80004b1a:	2c 0d       	sub	sp,-256
80004b1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b20:	00 00       	add	r0,r0
80004b22:	0b 36       	ld.ub	r6,r5++
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	5f 1c       	srne	r12
80004b28:	00 00       	add	r0,r0
80004b2a:	0b 30       	ld.ub	r0,r5++
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	5e 1c       	retne	r12
80004b30:	00 00       	add	r0,r0
80004b32:	0b 40       	ld.w	r0,--r5
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	d2 04       	*unknown*
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	49 38       	lddpc	r8,80004b84 <xnl_data_msg_func+0x34>
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	65 f0       	ld.w	r0,r2[0x7c]
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	ca 00       	breq	80004a82 <xnl_init+0x6>
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	48 70       	lddpc	r0,80004b60 <xnl_data_msg_func+0x10>
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	49 98       	lddpc	r8,80004bac <xnl_data_msg_func+0x5c>
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	35 78       	mov	r8,87

80004b50 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004b50:	eb cd 40 80 	pushm	r7,lr
80004b54:	fa cd 01 00 	sub	sp,sp,256
80004b58:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b5a:	e0 68 40 0e 	mov	r8,16398
80004b5e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b60:	3f f8       	mov	r8,-1
80004b62:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004b64:	30 c8       	mov	r8,12
80004b66:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004b68:	98 38       	ld.sh	r8,r12[0x6]
80004b6a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004b6c:	98 58       	ld.sh	r8,r12[0xa]
80004b6e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004b70:	98 48       	ld.sh	r8,r12[0x8]
80004b72:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004b74:	98 68       	ld.sh	r8,r12[0xc]
80004b76:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004b78:	30 08       	mov	r8,0
80004b7a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b7c:	1a 9c       	mov	r12,sp
80004b7e:	f0 1f 00 0a 	mcall	80004ba4 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004b82:	fa cd 00 cc 	sub	sp,sp,204
80004b86:	e0 6a 00 ca 	mov	r10,202
80004b8a:	ee cb ff f0 	sub	r11,r7,-16
80004b8e:	1a 9c       	mov	r12,sp
80004b90:	f0 1f 00 06 	mcall	80004ba8 <xnl_data_msg_func+0x58>
80004b94:	48 68       	lddpc	r8,80004bac <xnl_data_msg_func+0x5c>
80004b96:	70 08       	ld.w	r8,r8[0x0]
80004b98:	5d 18       	icall	r8
80004b9a:	fa cd ff 34 	sub	sp,sp,-204
}
80004b9e:	2c 0d       	sub	sp,-256
80004ba0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	49 98       	lddpc	r8,80004c08 <xnl_device_auth_reply_func+0x58>
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	73 6e       	ld.w	lr,r9[0x58]
80004bac:	00 00       	add	r0,r0
80004bae:	0b 50       	ld.sh	r0,--r5

80004bb0 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004bb0:	d4 21       	pushm	r4-r7,lr
80004bb2:	fa cd 01 00 	sub	sp,sp,256
80004bb6:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004bb8:	4c 28       	lddpc	r8,80004cc0 <xnl_device_auth_reply_func+0x110>
80004bba:	11 88       	ld.ub	r8,r8[0x0]
80004bbc:	58 08       	cp.w	r8,0
80004bbe:	e0 81 00 7f 	brne	80004cbc <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004bc2:	4c 18       	lddpc	r8,80004cc4 <xnl_device_auth_reply_func+0x114>
80004bc4:	70 0c       	ld.w	r12,r8[0x0]
80004bc6:	30 09       	mov	r9,0
80004bc8:	12 9a       	mov	r10,r9
80004bca:	12 9b       	mov	r11,r9
80004bcc:	f0 1f 00 3f 	mcall	80004cc8 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004bd0:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004bd4:	4b b8       	lddpc	r8,80004cc0 <xnl_device_auth_reply_func+0x110>
80004bd6:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004bd8:	ef 39 00 12 	ld.ub	r9,r7[18]
80004bdc:	ef 38 00 13 	ld.ub	r8,r7[19]
80004be0:	b1 68       	lsl	r8,0x10
80004be2:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004be6:	ef 38 00 15 	ld.ub	r8,r7[21]
80004bea:	f3 e8 10 08 	or	r8,r9,r8
80004bee:	ef 39 00 14 	ld.ub	r9,r7[20]
80004bf2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004bf6:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004bfa:	ef 38 00 17 	ld.ub	r8,r7[23]
80004bfe:	b1 68       	lsl	r8,0x10
80004c00:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004c04:	ef 38 00 19 	ld.ub	r8,r7[25]
80004c08:	f5 e8 10 08 	or	r8,r10,r8
80004c0c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004c10:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004c14:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c16:	e0 64 79 b9 	mov	r4,31161
80004c1a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c1e:	e0 65 45 07 	mov	r5,17671
80004c22:	ea 15 8a bd 	orh	r5,0x8abd
80004c26:	e0 66 f9 3d 	mov	r6,63805
80004c2a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c2e:	e0 6e b8 cf 	mov	lr,47311
80004c32:	ea 1e 36 83 	orh	lr,0x3683
80004c36:	e0 67 aa 1c 	mov	r7,43548
80004c3a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c3e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c40:	f4 08 00 0c 	add	r12,r10,r8
80004c44:	f0 0b 15 04 	lsl	r11,r8,0x4
80004c48:	0a 0b       	add	r11,r5
80004c4a:	f9 eb 20 0b 	eor	r11,r12,r11
80004c4e:	f0 0c 16 05 	lsr	r12,r8,0x5
80004c52:	0c 0c       	add	r12,r6
80004c54:	18 5b       	eor	r11,r12
80004c56:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c58:	f2 0c 15 04 	lsl	r12,r9,0x4
80004c5c:	1c 0c       	add	r12,lr
80004c5e:	f2 0b 16 05 	lsr	r11,r9,0x5
80004c62:	0e 0b       	add	r11,r7
80004c64:	f9 eb 20 0b 	eor	r11,r12,r11
80004c68:	f2 0a 00 0c 	add	r12,r9,r10
80004c6c:	18 5b       	eor	r11,r12
80004c6e:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004c70:	e0 6b 37 20 	mov	r11,14112
80004c74:	ea 1b c6 ef 	orh	r11,0xc6ef
80004c78:	16 3a       	cp.w	r10,r11
80004c7a:	ce 21       	brne	80004c3e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004c7c:	e0 6a 40 1a 	mov	r10,16410
80004c80:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004c82:	3f fa       	mov	r10,-1
80004c84:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004c86:	30 6b       	mov	r11,6
80004c88:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004c8a:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004c8c:	48 db       	lddpc	r11,80004cc0 <xnl_device_auth_reply_func+0x110>
80004c8e:	96 1c       	ld.sh	r12,r11[0x2]
80004c90:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004c92:	96 2b       	ld.sh	r11,r11[0x4]
80004c94:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004c96:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004c98:	30 ca       	mov	r10,12
80004c9a:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004c9c:	30 0a       	mov	r10,0
80004c9e:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004ca2:	30 7a       	mov	r10,7
80004ca4:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004ca8:	30 2a       	mov	r10,2
80004caa:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cae:	fa ca ff ec 	sub	r10,sp,-20
80004cb2:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cb4:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004cb6:	1a 9c       	mov	r12,sp
80004cb8:	f0 1f 00 05 	mcall	80004ccc <xnl_device_auth_reply_func+0x11c>
}
80004cbc:	2c 0d       	sub	sp,-256
80004cbe:	d8 22       	popm	r4-r7,pc
80004cc0:	00 00       	add	r0,r0
80004cc2:	0b 36       	ld.ub	r6,r5++
80004cc4:	00 00       	add	r0,r0
80004cc6:	0b 30       	ld.ub	r0,r5++
80004cc8:	80 00       	ld.sh	r0,r0[0x0]
80004cca:	5e 1c       	retne	r12
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	49 98       	lddpc	r8,80004d30 <xnl_device_conn_reply_func>

80004cd0 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004cd0:	eb cd 40 80 	pushm	r7,lr
80004cd4:	fa cd 01 00 	sub	sp,sp,256
80004cd8:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004cda:	49 28       	lddpc	r8,80004d20 <xnl_master_status_brdcst_func+0x50>
80004cdc:	11 88       	ld.ub	r8,r8[0x0]
80004cde:	58 08       	cp.w	r8,0
80004ce0:	c1 c1       	brne	80004d18 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004ce2:	49 18       	lddpc	r8,80004d24 <xnl_master_status_brdcst_func+0x54>
80004ce4:	70 0c       	ld.w	r12,r8[0x0]
80004ce6:	30 09       	mov	r9,0
80004ce8:	12 9a       	mov	r10,r9
80004cea:	12 9b       	mov	r11,r9
80004cec:	f0 1f 00 0f 	mcall	80004d28 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004cf0:	8e 58       	ld.sh	r8,r7[0xa]
80004cf2:	48 c9       	lddpc	r9,80004d20 <xnl_master_status_brdcst_func+0x50>
80004cf4:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004cf6:	e0 68 40 0e 	mov	r8,16398
80004cfa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004cfc:	3f f8       	mov	r8,-1
80004cfe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004d00:	30 4a       	mov	r10,4
80004d02:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004d04:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004d06:	92 19       	ld.sh	r9,r9[0x2]
80004d08:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004d0a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d0c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004d0e:	30 08       	mov	r8,0
80004d10:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004d12:	1a 9c       	mov	r12,sp
80004d14:	f0 1f 00 06 	mcall	80004d2c <xnl_master_status_brdcst_func+0x5c>
}
80004d18:	2c 0d       	sub	sp,-256
80004d1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d1e:	00 00       	add	r0,r0
80004d20:	00 00       	add	r0,r0
80004d22:	0b 36       	ld.ub	r6,r5++
80004d24:	00 00       	add	r0,r0
80004d26:	0b 30       	ld.ub	r0,r5++
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	5e 1c       	retne	r12
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	49 98       	lddpc	r8,80004d90 <local_start_pll0+0x4>

80004d30 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004d30:	eb cd 40 80 	pushm	r7,lr
80004d34:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004d36:	49 28       	lddpc	r8,80004d7c <xnl_device_conn_reply_func+0x4c>
80004d38:	70 0c       	ld.w	r12,r8[0x0]
80004d3a:	30 09       	mov	r9,0
80004d3c:	12 9a       	mov	r10,r9
80004d3e:	12 9b       	mov	r11,r9
80004d40:	f0 1f 00 10 	mcall	80004d80 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004d44:	ef 18 00 10 	ld.uh	r8,r7[16]
80004d48:	10 99       	mov	r9,r8
80004d4a:	e2 19 ff 00 	andl	r9,0xff00,COH
80004d4e:	e0 49 01 00 	cp.w	r9,256
80004d52:	c0 60       	breq	80004d5e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004d54:	0e 9c       	mov	r12,r7
80004d56:	f0 1f 00 0c 	mcall	80004d84 <xnl_device_conn_reply_func+0x54>
80004d5a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004d5e:	a9 68       	lsl	r8,0x8
80004d60:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d64:	48 98       	lddpc	r8,80004d88 <xnl_device_conn_reply_func+0x58>
80004d66:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004d68:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004d6c:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004d6e:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004d72:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004d74:	30 19       	mov	r9,1
80004d76:	b0 89       	st.b	r8[0x0],r9
80004d78:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d7c:	00 00       	add	r0,r0
80004d7e:	0b 30       	ld.ub	r0,r5++
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	5e 1c       	retne	r12
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4c d0       	lddpc	r0,80004eb8 <voc_init+0x20>
80004d88:	00 00       	add	r0,r0
80004d8a:	0b 36       	ld.ub	r6,r5++

80004d8c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004d8c:	fe 78 0c 00 	mov	r8,-62464
80004d90:	e0 69 03 07 	mov	r9,775
80004d94:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004d96:	30 49       	mov	r9,4
80004d98:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004d9a:	71 59       	ld.w	r9,r8[0x54]
80004d9c:	e2 19 00 80 	andl	r9,0x80,COH
80004da0:	cf d0       	breq	80004d9a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004da2:	fe 78 0c 00 	mov	r8,-62464
80004da6:	30 59       	mov	r9,5
80004da8:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004daa:	e0 69 01 0d 	mov	r9,269
80004dae:	ea 19 10 07 	orh	r9,0x1007
80004db2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004db4:	71 59       	ld.w	r9,r8[0x54]
80004db6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004dba:	cf d0       	breq	80004db4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004dbc:	fe 78 0c 00 	mov	r8,-62464
80004dc0:	fc 19 00 80 	movh	r9,0x80
80004dc4:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004dc6:	34 0a       	mov	r10,64
80004dc8:	fe 69 14 00 	mov	r9,-125952
80004dcc:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004dce:	30 69       	mov	r9,6
80004dd0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004dd2:	30 19       	mov	r9,1
80004dd4:	fe 68 10 00 	mov	r8,-126976
80004dd8:	91 19       	st.w	r8[0x4],r9
}
80004dda:	5e fc       	retal	r12

80004ddc <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004ddc:	fe 78 10 00 	mov	r8,-61440
80004de0:	fc 19 00 10 	movh	r9,0x10
80004de4:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004de6:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004de8:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004dea:	30 39       	mov	r9,3
80004dec:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004df0:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004df4:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004df8:	fe 78 38 00 	mov	r8,-51200
80004dfc:	30 49       	mov	r9,4
80004dfe:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004e02:	e0 69 91 0d 	mov	r9,37133
80004e06:	ea 19 00 52 	orh	r9,0x52
80004e0a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004e0c:	32 09       	mov	r9,32
80004e0e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004e10:	30 59       	mov	r9,5
80004e12:	91 09       	st.w	r8[0x0],r9
}
80004e14:	5e fc       	retal	r12
80004e16:	d7 03       	nop

80004e18 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004e18:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004e1a:	30 2a       	mov	r10,2
80004e1c:	e0 6b 01 c1 	mov	r11,449
80004e20:	48 ec       	lddpc	r12,80004e58 <tc_init+0x40>
80004e22:	f0 1f 00 0f 	mcall	80004e5c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004e26:	48 fb       	lddpc	r11,80004e60 <tc_init+0x48>
80004e28:	fe 7c 38 00 	mov	r12,-51200
80004e2c:	f0 1f 00 0e 	mcall	80004e64 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004e30:	e0 6a 75 30 	mov	r10,30000
80004e34:	30 1b       	mov	r11,1
80004e36:	fe 7c 38 00 	mov	r12,-51200
80004e3a:	f0 1f 00 0c 	mcall	80004e68 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004e3e:	48 ca       	lddpc	r10,80004e6c <tc_init+0x54>
80004e40:	30 1b       	mov	r11,1
80004e42:	fe 7c 38 00 	mov	r12,-51200
80004e46:	f0 1f 00 0b 	mcall	80004e70 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004e4a:	30 1b       	mov	r11,1
80004e4c:	fe 7c 38 00 	mov	r12,-51200
80004e50:	f0 1f 00 09 	mcall	80004e74 <tc_init+0x5c>
80004e54:	d8 02       	popm	pc
80004e56:	00 00       	add	r0,r0
80004e58:	80 00       	ld.sh	r0,r0[0x0]
80004e5a:	4e 78       	lddpc	r8,80004ff4 <voc_init+0x15c>
80004e5c:	80 00       	ld.sh	r0,r0[0x0]
80004e5e:	50 50       	stdsp	sp[0x14],r0
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	d2 10       	acall	0x21
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	53 36       	stdsp	sp[0xcc],r6
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	53 f6       	stdsp	sp[0xfc],r6
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	d2 0c       	*unknown*
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	54 2a       	stdsp	sp[0x108],r10
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	53 d2       	stdsp	sp[0xf4],r2

80004e78 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004e78:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004e7a:	48 68       	lddpc	r8,80004e90 <_tc_interrupt+0x18>
80004e7c:	70 09       	ld.w	r9,r8[0x0]
80004e7e:	2f f9       	sub	r9,-1
80004e80:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004e82:	30 1b       	mov	r11,1
80004e84:	fe 7c 38 00 	mov	r12,-51200
80004e88:	f0 1f 00 03 	mcall	80004e94 <_tc_interrupt+0x1c>
	
}
80004e8c:	d4 02       	popm	lr
80004e8e:	d6 03       	rete
80004e90:	00 00       	add	r0,r0
80004e92:	0b 54       	ld.sh	r4,--r5
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	53 e4       	stdsp	sp[0xf8],r4

80004e98 <voc_init>:
}



void voc_init(void)
{
80004e98:	d4 31       	pushm	r0-r7,lr
80004e9a:	21 4d       	sub	sp,80
	data_flash_init();
80004e9c:	f0 1f 00 5e 	mcall	80005014 <voc_init+0x17c>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
80004ea0:	30 08       	mov	r8,0
80004ea2:	30 09       	mov	r9,0
80004ea4:	fa e9 00 00 	st.d	sp[0],r8
80004ea8:	fa e9 00 08 	st.d	sp[8],r8
80004eac:	fa e9 00 10 	st.d	sp[16],r8
80004eb0:	fa e9 00 18 	st.d	sp[24],r8
80004eb4:	fa e9 00 20 	st.d	sp[32],r8
80004eb8:	fa e9 00 28 	st.d	sp[40],r8
80004ebc:	fa e9 00 30 	st.d	sp[48],r8
80004ec0:	fa e9 00 38 	st.d	sp[56],r8
80004ec4:	fa e9 00 40 	st.d	sp[64],r8
80004ec8:	fa e9 00 48 	st.d	sp[72],r8
80004ecc:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004ece:	1a 97       	mov	r7,sp
80004ed0:	30 74       	mov	r4,7
80004ed2:	0a 93       	mov	r3,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80004ed4:	4d 12       	lddpc	r2,80005018 <voc_init+0x180>
			log("\r\n----create voice info锛 okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80004ed6:	4d 26       	lddpc	r6,8000501c <voc_init+0x184>
80004ed8:	30 21       	mov	r1,2
80004eda:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004edc:	1a 9a       	mov	r10,sp
80004ede:	08 9b       	mov	r11,r4
80004ee0:	06 9c       	mov	r12,r3
80004ee2:	f0 1f 00 50 	mcall	80005020 <voc_init+0x188>
	if(return_code == DF_OK)
80004ee6:	e0 81 00 95 	brne	80005010 <voc_init+0x178>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80004eea:	08 9a       	mov	r10,r4
80004eec:	1a 9b       	mov	r11,sp
80004eee:	04 9c       	mov	r12,r2
80004ef0:	f0 1f 00 4d 	mcall	80005024 <voc_init+0x18c>
80004ef4:	c3 60       	breq	80004f60 <voc_init+0xc8>
80004ef6:	c8 18       	rjmp	80004ff8 <voc_init+0x160>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
80004ef8:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80004efc:	0e 9b       	mov	r11,r7
80004efe:	0a 9c       	mov	r12,r5
80004f00:	f0 1f 00 4a 	mcall	80005028 <voc_init+0x190>
				if(return_code != DF_ERASE_COMPLETED)
80004f04:	58 5c       	cp.w	r12,5
80004f06:	e0 81 00 85 	brne	80005010 <voc_init+0x178>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80004f0a:	0c 35       	cp.w	r5,r6
80004f0c:	cf 61       	brne	80004ef8 <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80004f0e:	30 7a       	mov	r10,7
80004f10:	30 0b       	mov	r11,0
80004f12:	4c 2c       	lddpc	r12,80005018 <voc_init+0x180>
80004f14:	f0 1f 00 46 	mcall	8000502c <voc_init+0x194>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80004f18:	1a 9c       	mov	r12,sp
80004f1a:	30 08       	mov	r8,0
80004f1c:	30 09       	mov	r9,0
80004f1e:	fa e9 00 00 	st.d	sp[0],r8
80004f22:	fa e9 00 08 	st.d	sp[8],r8
80004f26:	fa e9 00 10 	st.d	sp[16],r8
80004f2a:	fa e9 00 18 	st.d	sp[24],r8
80004f2e:	fa e9 00 20 	st.d	sp[32],r8
80004f32:	fa e9 00 28 	st.d	sp[40],r8
80004f36:	fa e9 00 30 	st.d	sp[48],r8
80004f3a:	fa e9 00 38 	st.d	sp[56],r8
80004f3e:	fa e9 00 40 	st.d	sp[64],r8
80004f42:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80004f46:	30 2a       	mov	r10,2
80004f48:	30 ab       	mov	r11,10
80004f4a:	f0 1f 00 39 	mcall	8000502c <voc_init+0x194>
			if(return_code != DF_WRITE_COMPLETED)
80004f4e:	58 7c       	cp.w	r12,7
80004f50:	c6 01       	brne	80005010 <voc_init+0x178>
			{
				return FALSE;
			}
			current_voice_index = 0;
80004f52:	30 09       	mov	r9,0
80004f54:	4b 28       	lddpc	r8,8000501c <voc_init+0x184>
80004f56:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info锛 okay!----\r\n");
80004f58:	4b 6c       	lddpc	r12,80005030 <voc_init+0x198>
80004f5a:	f0 1f 00 37 	mcall	80005034 <voc_init+0x19c>
80004f5e:	c5 68       	rjmp	8000500a <voc_init+0x172>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80004f60:	0c 9a       	mov	r10,r6
80004f62:	02 9b       	mov	r11,r1
80004f64:	00 9c       	mov	r12,r0
80004f66:	f0 1f 00 2f 	mcall	80005020 <voc_init+0x188>
			if(return_code == DF_OK)
80004f6a:	c5 31       	brne	80005010 <voc_init+0x178>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80004f6c:	8c 08       	ld.sh	r8,r6[0x0]
80004f6e:	58 08       	cp.w	r8,0
80004f70:	c4 a0       	breq	80005004 <voc_init+0x16c>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80004f72:	5c 78       	castu.h	r8
80004f74:	20 18       	sub	r8,1
80004f76:	f0 08 00 38 	add	r8,r8,r8<<0x3
80004f7a:	f0 05 15 03 	lsl	r5,r8,0x3
80004f7e:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80004f80:	1a 9a       	mov	r10,sp
80004f82:	34 8b       	mov	r11,72
80004f84:	0a 9c       	mov	r12,r5
80004f86:	f0 1f 00 27 	mcall	80005020 <voc_init+0x188>
					//return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)FLASH_BUF);
					if(return_code == DF_OK)
80004f8a:	c3 d1       	brne	80005004 <voc_init+0x16c>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80004f8c:	0f 89       	ld.ub	r9,r7[0x0]
80004f8e:	0f 98       	ld.ub	r8,r7[0x1]
80004f90:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004f94:	8c 09       	ld.sh	r9,r6[0x0]
80004f96:	f0 09 19 00 	cp.h	r9,r8
80004f9a:	c2 c1       	brne	80004ff2 <voc_init+0x15a>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80004f9c:	ef 39 00 46 	ld.ub	r9,r7[70]
80004fa0:	ef 38 00 47 	ld.ub	r8,r7[71]
80004fa4:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80004fa8:	ef 3a 00 42 	ld.ub	r10,r7[66]
80004fac:	ef 38 00 43 	ld.ub	r8,r7[67]
80004fb0:	b1 68       	lsl	r8,0x10
80004fb2:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80004fb6:	ef 3a 00 44 	ld.ub	r10,r7[68]
80004fba:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004fbe:	ef 3a 00 45 	ld.ub	r10,r7[69]
80004fc2:	f5 e8 10 08 	or	r8,r10,r8
80004fc6:	f2 08 00 08 	add	r8,r9,r8
80004fca:	49 c9       	lddpc	r9,80005038 <voc_init+0x1a0>
80004fcc:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80004fce:	e0 69 c0 00 	mov	r9,49152
80004fd2:	ea 19 00 7b 	orh	r9,0x7b
80004fd6:	12 38       	cp.w	r8,r9
80004fd8:	e0 88 00 16 	brls	80005004 <voc_init+0x16c>
								
								log("\r\n----voice storage is full!!!----\r\n");
80004fdc:	49 8c       	lddpc	r12,8000503c <voc_init+0x1a4>
80004fde:	f0 1f 00 16 	mcall	80005034 <voc_init+0x19c>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80004fe2:	30 4b       	mov	r11,4
80004fe4:	06 9c       	mov	r12,r3
80004fe6:	f0 1f 00 11 	mcall	80005028 <voc_init+0x190>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80004fea:	58 5c       	cp.w	r12,5
80004fec:	fe 90 ff 78 	breq	80004edc <voc_init+0x44>
80004ff0:	c1 08       	rjmp	80005010 <voc_init+0x178>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80004ff2:	49 4c       	lddpc	r12,80005040 <voc_init+0x1a8>
80004ff4:	f0 1f 00 10 	mcall	80005034 <voc_init+0x19c>

}



void voc_init(void)
80004ff8:	e6 78 00 00 	mov	r8,458752
80004ffc:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005000:	30 37       	mov	r7,3
80005002:	c7 db       	rjmp	80004efc <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info锛 okay!----\r\n");
80005004:	49 0c       	lddpc	r12,80005044 <voc_init+0x1ac>
80005006:	f0 1f 00 0c 	mcall	80005034 <voc_init+0x19c>
			}
			else
			return FALSE;
		}
		
		list_init_success_flag = 1;
8000500a:	30 19       	mov	r9,1
8000500c:	48 f8       	lddpc	r8,80005048 <voc_init+0x1b0>
8000500e:	b0 89       	st.b	r8[0x0],r9
	
	//playback_voice_data(5);
	//playback_voice_data(4);
	

80005010:	2e cd       	sub	sp,-80
80005012:	d8 32       	popm	r0-r7,pc
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	2d a8       	sub	r8,-38
80005018:	00 00       	add	r0,r0
8000501a:	05 28       	ld.uh	r8,r2++
8000501c:	00 00       	add	r0,r0
8000501e:	0b 58       	ld.sh	r8,--r5
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	2a 88       	sub	r8,-88
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	73 48       	ld.w	r8,r9[0x50]
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	2c 1c       	sub	r12,-63
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	2c b8       	sub	r8,-53
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	d2 18       	*unknown*
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	69 b4       	ld.w	r4,r4[0x6c]
80005038:	00 00       	add	r0,r0
8000503a:	05 30       	ld.ub	r0,r2++
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	d2 40       	acall	0x24
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	d2 68       	*unknown*
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	d2 8c       	*unknown*
80005048:	00 00       	add	r0,r0
8000504a:	0b 5a       	ld.sh	r10,--r5

8000504c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000504c:	c0 08       	rjmp	8000504c <_unhandled_interrupt>
8000504e:	d7 03       	nop

80005050 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005050:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005054:	49 99       	lddpc	r9,800050b8 <INTC_register_interrupt+0x68>
80005056:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000505a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000505e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005060:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005064:	58 0a       	cp.w	r10,0
80005066:	c0 91       	brne	80005078 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005068:	49 59       	lddpc	r9,800050bc <INTC_register_interrupt+0x6c>
8000506a:	49 6a       	lddpc	r10,800050c0 <INTC_register_interrupt+0x70>
8000506c:	12 1a       	sub	r10,r9
8000506e:	fe 79 08 00 	mov	r9,-63488
80005072:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005076:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005078:	58 1a       	cp.w	r10,1
8000507a:	c0 a1       	brne	8000508e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000507c:	49 09       	lddpc	r9,800050bc <INTC_register_interrupt+0x6c>
8000507e:	49 2a       	lddpc	r10,800050c4 <INTC_register_interrupt+0x74>
80005080:	12 1a       	sub	r10,r9
80005082:	bf aa       	sbr	r10,0x1e
80005084:	fe 79 08 00 	mov	r9,-63488
80005088:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000508c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000508e:	58 2a       	cp.w	r10,2
80005090:	c0 a1       	brne	800050a4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005092:	48 b9       	lddpc	r9,800050bc <INTC_register_interrupt+0x6c>
80005094:	48 da       	lddpc	r10,800050c8 <INTC_register_interrupt+0x78>
80005096:	12 1a       	sub	r10,r9
80005098:	bf ba       	sbr	r10,0x1f
8000509a:	fe 79 08 00 	mov	r9,-63488
8000509e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800050a2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800050a4:	48 69       	lddpc	r9,800050bc <INTC_register_interrupt+0x6c>
800050a6:	48 aa       	lddpc	r10,800050cc <INTC_register_interrupt+0x7c>
800050a8:	12 1a       	sub	r10,r9
800050aa:	ea 1a c0 00 	orh	r10,0xc000
800050ae:	fe 79 08 00 	mov	r9,-63488
800050b2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800050b6:	5e fc       	retal	r12
800050b8:	80 00       	ld.sh	r0,r0[0x0]
800050ba:	d2 b4       	*unknown*
800050bc:	80 00       	ld.sh	r0,r0[0x0]
800050be:	c8 00       	breq	80004fbe <voc_init+0x126>
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	c9 04       	brge	80004fe2 <voc_init+0x14a>
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	c9 12       	brcc	80004fe8 <voc_init+0x150>
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	c9 20       	breq	80004fee <voc_init+0x156>
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	c9 2e       	rcall	80004df2 <local_start_timer+0x16>

800050d0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800050d0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800050d2:	49 18       	lddpc	r8,80005114 <INTC_init_interrupts+0x44>
800050d4:	e3 b8 00 01 	mtsr	0x4,r8
800050d8:	49 0e       	lddpc	lr,80005118 <INTC_init_interrupts+0x48>
800050da:	30 07       	mov	r7,0
800050dc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800050de:	49 0c       	lddpc	r12,8000511c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800050e0:	49 05       	lddpc	r5,80005120 <INTC_init_interrupts+0x50>
800050e2:	10 15       	sub	r5,r8
800050e4:	fe 76 08 00 	mov	r6,-63488
800050e8:	c1 08       	rjmp	80005108 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800050ea:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800050ec:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800050ee:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800050f0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800050f4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800050f6:	10 3a       	cp.w	r10,r8
800050f8:	fe 9b ff fc 	brhi	800050f0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800050fc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005100:	2f f7       	sub	r7,-1
80005102:	2f 8e       	sub	lr,-8
80005104:	59 37       	cp.w	r7,19
80005106:	c0 50       	breq	80005110 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005108:	7c 08       	ld.w	r8,lr[0x0]
8000510a:	58 08       	cp.w	r8,0
8000510c:	ce f1       	brne	800050ea <INTC_init_interrupts+0x1a>
8000510e:	cf 7b       	rjmp	800050fc <INTC_init_interrupts+0x2c>
80005110:	d8 22       	popm	r4-r7,pc
80005112:	00 00       	add	r0,r0
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	c8 00       	breq	80005016 <voc_init+0x17e>
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	d2 b4       	*unknown*
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	50 4c       	stdsp	sp[0x10],r12
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	c9 04       	brge	80005042 <voc_init+0x1aa>

80005124 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005124:	fe 78 08 00 	mov	r8,-63488
80005128:	e0 69 00 83 	mov	r9,131
8000512c:	f2 0c 01 0c 	sub	r12,r9,r12
80005130:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005134:	f2 ca ff c0 	sub	r10,r9,-64
80005138:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000513c:	58 08       	cp.w	r8,0
8000513e:	c0 21       	brne	80005142 <_get_interrupt_handler+0x1e>
80005140:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005142:	f0 08 12 00 	clz	r8,r8
80005146:	48 5a       	lddpc	r10,80005158 <_get_interrupt_handler+0x34>
80005148:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000514c:	f0 08 11 1f 	rsub	r8,r8,31
80005150:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005152:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005156:	5e fc       	retal	r12
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	d2 b4       	*unknown*

8000515c <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
8000515c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005160:	30 18       	mov	r8,1
80005162:	f0 09 18 00 	cp.b	r9,r8
80005166:	e0 88 00 04 	brls	8000516e <spi_initMaster+0x12>
8000516a:	30 2c       	mov	r12,2
8000516c:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000516e:	e0 68 00 80 	mov	r8,128
80005172:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005174:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005176:	30 19       	mov	r9,1
80005178:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000517c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005180:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005184:	30 09       	mov	r9,0
80005186:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000518a:	30 fa       	mov	r10,15
8000518c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005190:	99 18       	st.w	r12[0x4],r8
80005192:	5e f9       	retal	r9

80005194 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005194:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005196:	30 18       	mov	r8,1
80005198:	f0 0b 18 00 	cp.b	r11,r8
8000519c:	5f be       	srhi	lr
8000519e:	f0 0a 18 00 	cp.b	r10,r8
800051a2:	5f b8       	srhi	r8
800051a4:	fd e8 10 08 	or	r8,lr,r8
800051a8:	c0 30       	breq	800051ae <spi_selectionMode+0x1a>
800051aa:	30 2c       	mov	r12,2
800051ac:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
800051ae:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
800051b0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800051b4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
800051b8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
800051bc:	99 18       	st.w	r12[0x4],r8
800051be:	d8 0a       	popm	pc,r12=0

800051c0 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
800051c0:	78 18       	ld.w	r8,r12[0x4]
800051c2:	ea 18 00 0f 	orh	r8,0xf
800051c6:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800051c8:	78 18       	ld.w	r8,r12[0x4]
800051ca:	e2 18 00 04 	andl	r8,0x4,COH
800051ce:	c0 f0       	breq	800051ec <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
800051d0:	30 e8       	mov	r8,14
800051d2:	f0 0b 18 00 	cp.b	r11,r8
800051d6:	e0 8b 00 19 	brhi	80005208 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
800051da:	78 18       	ld.w	r8,r12[0x4]
800051dc:	b1 6b       	lsl	r11,0x10
800051de:	ea 1b ff f0 	orh	r11,0xfff0
800051e2:	e8 1b ff ff 	orl	r11,0xffff
800051e6:	10 6b       	and	r11,r8
800051e8:	99 1b       	st.w	r12[0x4],r11
800051ea:	5e fd       	retal	0
  } else {
    if (chip > 3) {
800051ec:	30 38       	mov	r8,3
800051ee:	f0 0b 18 00 	cp.b	r11,r8
800051f2:	e0 8b 00 0b 	brhi	80005208 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800051f6:	78 18       	ld.w	r8,r12[0x4]
800051f8:	2f 0b       	sub	r11,-16
800051fa:	30 19       	mov	r9,1
800051fc:	f2 0b 09 4b 	lsl	r11,r9,r11
80005200:	5c db       	com	r11
80005202:	10 6b       	and	r11,r8
80005204:	99 1b       	st.w	r12[0x4],r11
80005206:	5e fd       	retal	0
80005208:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
8000520a:	5e fc       	retal	r12

8000520c <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
8000520c:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005210:	c0 58       	rjmp	8000521a <spi_unselectChip+0xe>
    if (!timeout--) {
80005212:	58 08       	cp.w	r8,0
80005214:	c0 21       	brne	80005218 <spi_unselectChip+0xc>
80005216:	5e ff       	retal	1
80005218:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000521a:	78 49       	ld.w	r9,r12[0x10]
8000521c:	e2 19 02 00 	andl	r9,0x200,COH
80005220:	cf 90       	breq	80005212 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005222:	78 18       	ld.w	r8,r12[0x4]
80005224:	ea 18 00 0f 	orh	r8,0xf
80005228:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000522a:	fc 18 01 00 	movh	r8,0x100
8000522e:	99 08       	st.w	r12[0x0],r8
80005230:	5e fd       	retal	0

80005232 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005232:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005236:	f7 38 00 0c 	ld.ub	r8,r11[12]
8000523a:	30 39       	mov	r9,3
8000523c:	f2 08 18 00 	cp.b	r8,r9
80005240:	e0 8b 00 57 	brhi	800052ee <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005244:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005248:	30 1e       	mov	lr,1
8000524a:	fc 09 18 00 	cp.b	r9,lr
8000524e:	e0 8b 00 50 	brhi	800052ee <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005252:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005256:	30 77       	mov	r7,7
80005258:	ee 0e 18 00 	cp.b	lr,r7
8000525c:	e0 88 00 49 	brls	800052ee <spi_setupChipReg+0xbc>
80005260:	31 07       	mov	r7,16
80005262:	ee 0e 18 00 	cp.b	lr,r7
80005266:	e0 8b 00 44 	brhi	800052ee <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
8000526a:	76 17       	ld.w	r7,r11[0x4]
8000526c:	ee 06 16 01 	lsr	r6,r7,0x1
80005270:	0c 0a       	add	r10,r6
80005272:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005276:	ec c7 00 01 	sub	r7,r6,1
8000527a:	e0 47 00 fe 	cp.w	r7,254
8000527e:	e0 8b 00 38 	brhi	800052ee <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005282:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005284:	58 06       	cp.w	r6,0
80005286:	c3 45       	brlt	800052ee <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005288:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
8000528a:	f0 06 16 01 	lsr	r6,r8,0x1
8000528e:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005292:	ec 18 00 01 	eorl	r8,0x1
80005296:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
8000529a:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
8000529e:	20 8e       	sub	lr,8
800052a0:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
800052a4:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
800052a8:	f7 38 00 09 	ld.ub	r8,r11[9]
800052ac:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800052b0:	f7 38 00 0a 	ld.ub	r8,r11[10]
800052b4:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
800052b8:	17 88       	ld.ub	r8,r11[0x0]
800052ba:	30 19       	mov	r9,1
800052bc:	f2 08 18 00 	cp.b	r8,r9
800052c0:	c0 e0       	breq	800052dc <spi_setupChipReg+0xaa>
800052c2:	c0 a3       	brcs	800052d6 <spi_setupChipReg+0xa4>
800052c4:	30 29       	mov	r9,2
800052c6:	f2 08 18 00 	cp.b	r8,r9
800052ca:	c0 c0       	breq	800052e2 <spi_setupChipReg+0xb0>
800052cc:	30 39       	mov	r9,3
800052ce:	f2 08 18 00 	cp.b	r8,r9
800052d2:	c0 e1       	brne	800052ee <spi_setupChipReg+0xbc>
800052d4:	c0 a8       	rjmp	800052e8 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
800052d6:	99 ca       	st.w	r12[0x30],r10
800052d8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
800052dc:	99 da       	st.w	r12[0x34],r10
800052de:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
800052e2:	99 ea       	st.w	r12[0x38],r10
800052e4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
800052e8:	99 fa       	st.w	r12[0x3c],r10
800052ea:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
800052ee:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
800052f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800052f4 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800052f4:	30 18       	mov	r8,1
800052f6:	99 08       	st.w	r12[0x0],r8
}
800052f8:	5e fc       	retal	r12

800052fa <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
800052fa:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800052fe:	c0 58       	rjmp	80005308 <spi_write+0xe>
    if (!timeout--) {
80005300:	58 08       	cp.w	r8,0
80005302:	c0 21       	brne	80005306 <spi_write+0xc>
80005304:	5e ff       	retal	1
80005306:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005308:	78 49       	ld.w	r9,r12[0x10]
8000530a:	e2 19 00 02 	andl	r9,0x2,COH
8000530e:	cf 90       	breq	80005300 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005310:	5c 7b       	castu.h	r11
80005312:	99 3b       	st.w	r12[0xc],r11
80005314:	5e fd       	retal	0

80005316 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005316:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
8000531a:	c0 58       	rjmp	80005324 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
8000531c:	58 08       	cp.w	r8,0
8000531e:	c0 21       	brne	80005322 <spi_read+0xc>
80005320:	5e ff       	retal	1
80005322:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005324:	78 49       	ld.w	r9,r12[0x10]
80005326:	e2 19 02 01 	andl	r9,0x201,COH
8000532a:	e0 49 02 01 	cp.w	r9,513
8000532e:	cf 71       	brne	8000531c <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005330:	78 28       	ld.w	r8,r12[0x8]
80005332:	b6 08       	st.h	r11[0x0],r8
80005334:	5e fd       	retal	0

80005336 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005336:	76 09       	ld.w	r9,r11[0x0]
80005338:	58 29       	cp.w	r9,2
8000533a:	e0 88 00 03 	brls	80005340 <tc_init_waveform+0xa>
8000533e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005340:	76 18       	ld.w	r8,r11[0x4]
80005342:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005346:	af ba       	sbr	r10,0xf
80005348:	10 9b       	mov	r11,r8
8000534a:	e6 1b c0 00 	andh	r11,0xc000,COH
8000534e:	16 4a       	or	r10,r11
80005350:	10 9b       	mov	r11,r8
80005352:	e6 1b 30 00 	andh	r11,0x3000,COH
80005356:	16 4a       	or	r10,r11
80005358:	10 9b       	mov	r11,r8
8000535a:	e6 1b 0c 00 	andh	r11,0xc00,COH
8000535e:	16 4a       	or	r10,r11
80005360:	10 9b       	mov	r11,r8
80005362:	e6 1b 03 00 	andh	r11,0x300,COH
80005366:	16 4a       	or	r10,r11
80005368:	10 9b       	mov	r11,r8
8000536a:	e6 1b 00 c0 	andh	r11,0xc0,COH
8000536e:	16 4a       	or	r10,r11
80005370:	10 9b       	mov	r11,r8
80005372:	e6 1b 00 30 	andh	r11,0x30,COH
80005376:	16 4a       	or	r10,r11
80005378:	10 9b       	mov	r11,r8
8000537a:	e6 1b 00 0c 	andh	r11,0xc,COH
8000537e:	16 4a       	or	r10,r11
80005380:	10 9b       	mov	r11,r8
80005382:	e6 1b 00 03 	andh	r11,0x3,COH
80005386:	16 4a       	or	r10,r11
80005388:	10 9b       	mov	r11,r8
8000538a:	e2 1b 60 00 	andl	r11,0x6000,COH
8000538e:	16 4a       	or	r10,r11
80005390:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005394:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005398:	10 9b       	mov	r11,r8
8000539a:	e2 1b 0c 00 	andl	r11,0xc00,COH
8000539e:	16 4a       	or	r10,r11
800053a0:	10 9b       	mov	r11,r8
800053a2:	e2 1b 03 00 	andl	r11,0x300,COH
800053a6:	16 4a       	or	r10,r11
800053a8:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800053ac:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800053b0:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800053b4:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800053b8:	10 9b       	mov	r11,r8
800053ba:	e2 1b 00 30 	andl	r11,0x30,COH
800053be:	16 4a       	or	r10,r11
800053c0:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800053c4:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800053c8:	a5 69       	lsl	r9,0x4
800053ca:	2f f9       	sub	r9,-1
800053cc:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800053d0:	5e fd       	retal	0

800053d2 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800053d2:	58 2b       	cp.w	r11,2
800053d4:	e0 88 00 03 	brls	800053da <tc_start+0x8>
800053d8:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800053da:	a7 6b       	lsl	r11,0x6
800053dc:	16 0c       	add	r12,r11
800053de:	30 58       	mov	r8,5
800053e0:	99 08       	st.w	r12[0x0],r8
800053e2:	5e fd       	retal	0

800053e4 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800053e4:	58 2b       	cp.w	r11,2
800053e6:	e0 88 00 03 	brls	800053ec <tc_read_sr+0x8>
800053ea:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800053ec:	a7 6b       	lsl	r11,0x6
800053ee:	2e 0b       	sub	r11,-32
800053f0:	16 0c       	add	r12,r11
800053f2:	78 0c       	ld.w	r12,r12[0x0]
}
800053f4:	5e fc       	retal	r12

800053f6 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800053f6:	58 2b       	cp.w	r11,2
800053f8:	e0 88 00 03 	brls	800053fe <tc_write_rc+0x8>
800053fc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800053fe:	f6 08 15 04 	lsl	r8,r11,0x4
80005402:	2f f8       	sub	r8,-1
80005404:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005408:	e2 18 80 00 	andl	r8,0x8000,COH
8000540c:	c0 c0       	breq	80005424 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
8000540e:	a7 6b       	lsl	r11,0x6
80005410:	16 0c       	add	r12,r11
80005412:	2e 4c       	sub	r12,-28
80005414:	78 08       	ld.w	r8,r12[0x0]
80005416:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000541a:	e0 18 00 00 	andl	r8,0x0
8000541e:	f3 e8 10 08 	or	r8,r9,r8
80005422:	99 08       	st.w	r12[0x0],r8

  return value;
80005424:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005428:	5e fc       	retal	r12

8000542a <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
8000542a:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000542e:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005432:	58 2b       	cp.w	r11,2
80005434:	e0 88 00 04 	brls	8000543c <tc_configure_interrupts+0x12>
80005438:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
8000543c:	ee 19 00 01 	eorh	r9,0x1
80005440:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005444:	74 08       	ld.w	r8,r10[0x0]
80005446:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
8000544a:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
8000544e:	a7 6e       	lsl	lr,0x6
80005450:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005454:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005458:	0e 4e       	or	lr,r7
8000545a:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
8000545e:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005462:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005466:	fd e7 10 4e 	or	lr,lr,r7<<0x4
8000546a:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
8000546e:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005472:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005476:	fd e7 10 2e 	or	lr,lr,r7<<0x2
8000547a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000547e:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005482:	f6 0e 15 06 	lsl	lr,r11,0x6
80005486:	f8 0e 00 0e 	add	lr,r12,lr
8000548a:	2d ce       	sub	lr,-36
8000548c:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000548e:	58 09       	cp.w	r9,0
80005490:	c0 20       	breq	80005494 <tc_configure_interrupts+0x6a>
80005492:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005494:	74 08       	ld.w	r8,r10[0x0]
80005496:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
8000549a:	e0 65 00 80 	mov	r5,128
8000549e:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
800054a2:	74 08       	ld.w	r8,r10[0x0]
800054a4:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800054a8:	f9 b4 00 40 	moveq	r4,64
800054ac:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
800054b0:	74 08       	ld.w	r8,r10[0x0]
800054b2:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800054b6:	f9 b3 00 20 	moveq	r3,32
800054ba:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800054be:	74 08       	ld.w	r8,r10[0x0]
800054c0:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800054c4:	f9 b2 00 10 	moveq	r2,16
800054c8:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800054cc:	74 08       	ld.w	r8,r10[0x0]
800054ce:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800054d2:	f9 b6 00 08 	moveq	r6,8
800054d6:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800054da:	74 08       	ld.w	r8,r10[0x0]
800054dc:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800054e0:	f9 b7 00 04 	moveq	r7,4
800054e4:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800054e8:	74 08       	ld.w	r8,r10[0x0]
800054ea:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800054ee:	f9 be 00 02 	moveq	lr,2
800054f2:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800054f6:	74 08       	ld.w	r8,r10[0x0]
800054f8:	ec 18 00 01 	eorl	r8,0x1
800054fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005500:	eb e8 10 08 	or	r8,r5,r8
80005504:	08 48       	or	r8,r4
80005506:	06 48       	or	r8,r3
80005508:	04 48       	or	r8,r2
8000550a:	0c 48       	or	r8,r6
8000550c:	0e 48       	or	r8,r7
8000550e:	1c 48       	or	r8,lr
80005510:	f6 0a 15 06 	lsl	r10,r11,0x6
80005514:	f8 0a 00 0a 	add	r10,r12,r10
80005518:	2d 8a       	sub	r10,-40
8000551a:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
8000551c:	a7 6b       	lsl	r11,0x6
8000551e:	2e 0b       	sub	r11,-32
80005520:	16 0c       	add	r12,r11
80005522:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005524:	58 09       	cp.w	r9,0
80005526:	c0 31       	brne	8000552c <tc_configure_interrupts+0x102>
80005528:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000552c:	d5 03       	csrf	0x10
8000552e:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80005532 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005532:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005534:	f6 08 15 04 	lsl	r8,r11,0x4
80005538:	14 38       	cp.w	r8,r10
8000553a:	f9 b8 08 10 	movls	r8,16
8000553e:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005542:	f0 0b 02 4b 	mul	r11,r8,r11
80005546:	f6 09 16 01 	lsr	r9,r11,0x1
8000554a:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000554e:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005552:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005556:	f2 cb 00 01 	sub	r11,r9,1
8000555a:	e0 4b ff fe 	cp.w	r11,65534
8000555e:	e0 88 00 03 	brls	80005564 <usart_set_async_baudrate+0x32>
80005562:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005564:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005566:	e8 6e 00 00 	mov	lr,524288
8000556a:	59 08       	cp.w	r8,16
8000556c:	fc 08 17 10 	movne	r8,lr
80005570:	f9 b8 00 00 	moveq	r8,0
80005574:	e4 1b ff f7 	andh	r11,0xfff7
80005578:	e0 1b fe cf 	andl	r11,0xfecf
8000557c:	16 48       	or	r8,r11
8000557e:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005580:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005584:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005588:	99 89       	st.w	r12[0x20],r9
8000558a:	d8 0a       	popm	pc,r12=0

8000558c <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000558c:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000558e:	e2 18 00 02 	andl	r8,0x2,COH
80005592:	c0 31       	brne	80005598 <usart_write_char+0xc>
80005594:	30 2c       	mov	r12,2
80005596:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005598:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000559c:	99 7b       	st.w	r12[0x1c],r11
8000559e:	5e fd       	retal	0

800055a0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800055a0:	eb cd 40 e0 	pushm	r5-r7,lr
800055a4:	18 96       	mov	r6,r12
800055a6:	16 95       	mov	r5,r11
800055a8:	e0 67 27 0f 	mov	r7,9999
800055ac:	c0 68       	rjmp	800055b8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800055ae:	58 07       	cp.w	r7,0
800055b0:	c0 31       	brne	800055b6 <usart_putchar+0x16>
800055b2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800055b6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800055b8:	0a 9b       	mov	r11,r5
800055ba:	0c 9c       	mov	r12,r6
800055bc:	f0 1f 00 03 	mcall	800055c8 <usart_putchar+0x28>
800055c0:	cf 71       	brne	800055ae <usart_putchar+0xe>

  return USART_SUCCESS;
}
800055c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800055c6:	00 00       	add	r0,r0
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	55 8c       	stdsp	sp[0x160],r12

800055cc <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800055cc:	78 58       	ld.w	r8,r12[0x14]
800055ce:	e2 18 00 e0 	andl	r8,0xe0,COH
800055d2:	c0 30       	breq	800055d8 <usart_read_char+0xc>
800055d4:	30 4c       	mov	r12,4
800055d6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800055d8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800055da:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800055de:	c0 31       	brne	800055e4 <usart_read_char+0x18>
800055e0:	30 3c       	mov	r12,3
800055e2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800055e4:	78 68       	ld.w	r8,r12[0x18]
800055e6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800055ea:	97 08       	st.w	r11[0x0],r8
800055ec:	5e fd       	retal	0
800055ee:	d7 03       	nop

800055f0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800055f0:	eb cd 40 c0 	pushm	r6-r7,lr
800055f4:	20 1d       	sub	sp,4
800055f6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800055f8:	1a 97       	mov	r7,sp
800055fa:	1a 9b       	mov	r11,sp
800055fc:	0c 9c       	mov	r12,r6
800055fe:	f0 1f 00 07 	mcall	80005618 <usart_getchar+0x28>
80005602:	58 3c       	cp.w	r12,3
80005604:	cf b0       	breq	800055fa <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005606:	58 4c       	cp.w	r12,4
80005608:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000560c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005610:	2f fd       	sub	sp,-4
80005612:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005616:	00 00       	add	r0,r0
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	55 cc       	stdsp	sp[0x170],r12

8000561c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000561c:	eb cd 40 c0 	pushm	r6-r7,lr
80005620:	18 96       	mov	r6,r12
80005622:	16 97       	mov	r7,r11
  while (*string != '\0')
80005624:	17 8b       	ld.ub	r11,r11[0x0]
80005626:	58 0b       	cp.w	r11,0
80005628:	c0 80       	breq	80005638 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000562a:	2f f7       	sub	r7,-1
8000562c:	0c 9c       	mov	r12,r6
8000562e:	f0 1f 00 04 	mcall	8000563c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005632:	0f 8b       	ld.ub	r11,r7[0x0]
80005634:	58 0b       	cp.w	r11,0
80005636:	cf a1       	brne	8000562a <usart_write_line+0xe>
80005638:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	55 a0       	stdsp	sp[0x168],r0

80005640 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005640:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005644:	e6 18 00 01 	andh	r8,0x1,COH
80005648:	c0 71       	brne	80005656 <usart_reset+0x16>
8000564a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000564c:	3f f8       	mov	r8,-1
8000564e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005650:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005652:	d5 03       	csrf	0x10
80005654:	c0 48       	rjmp	8000565c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005656:	3f f8       	mov	r8,-1
80005658:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000565a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000565c:	30 08       	mov	r8,0
8000565e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005660:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005662:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005664:	ea 68 61 0c 	mov	r8,680204
80005668:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000566a:	5e fc       	retal	r12

8000566c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000566c:	eb cd 40 e0 	pushm	r5-r7,lr
80005670:	18 96       	mov	r6,r12
80005672:	16 97       	mov	r7,r11
80005674:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005676:	f0 1f 00 2f 	mcall	80005730 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000567a:	58 07       	cp.w	r7,0
8000567c:	c5 80       	breq	8000572c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000567e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005680:	30 49       	mov	r9,4
80005682:	f2 08 18 00 	cp.b	r8,r9
80005686:	e0 88 00 53 	brls	8000572c <usart_init_rs232+0xc0>
8000568a:	30 99       	mov	r9,9
8000568c:	f2 08 18 00 	cp.b	r8,r9
80005690:	e0 8b 00 4e 	brhi	8000572c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005694:	0f d9       	ld.ub	r9,r7[0x5]
80005696:	30 78       	mov	r8,7
80005698:	f0 09 18 00 	cp.b	r9,r8
8000569c:	e0 8b 00 48 	brhi	8000572c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800056a0:	8e 39       	ld.sh	r9,r7[0x6]
800056a2:	e0 68 01 01 	mov	r8,257
800056a6:	f0 09 19 00 	cp.h	r9,r8
800056aa:	e0 8b 00 41 	brhi	8000572c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800056ae:	ef 39 00 08 	ld.ub	r9,r7[8]
800056b2:	30 38       	mov	r8,3
800056b4:	f0 09 18 00 	cp.b	r9,r8
800056b8:	e0 8b 00 3a 	brhi	8000572c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800056bc:	0a 9a       	mov	r10,r5
800056be:	6e 0b       	ld.w	r11,r7[0x0]
800056c0:	0c 9c       	mov	r12,r6
800056c2:	f0 1f 00 1d 	mcall	80005734 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800056c6:	58 1c       	cp.w	r12,1
800056c8:	c3 20       	breq	8000572c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800056ca:	0f c8       	ld.ub	r8,r7[0x4]
800056cc:	30 99       	mov	r9,9
800056ce:	f2 08 18 00 	cp.b	r8,r9
800056d2:	c0 51       	brne	800056dc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800056d4:	6c 18       	ld.w	r8,r6[0x4]
800056d6:	b1 b8       	sbr	r8,0x11
800056d8:	8d 18       	st.w	r6[0x4],r8
800056da:	c0 68       	rjmp	800056e6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800056dc:	6c 19       	ld.w	r9,r6[0x4]
800056de:	20 58       	sub	r8,5
800056e0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800056e4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800056e6:	6c 19       	ld.w	r9,r6[0x4]
800056e8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800056ec:	0f d8       	ld.ub	r8,r7[0x5]
800056ee:	a9 78       	lsl	r8,0x9
800056f0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800056f4:	12 48       	or	r8,r9
800056f6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800056f8:	8e 38       	ld.sh	r8,r7[0x6]
800056fa:	30 29       	mov	r9,2
800056fc:	f2 08 19 00 	cp.h	r8,r9
80005700:	e0 88 00 09 	brls	80005712 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005704:	6c 18       	ld.w	r8,r6[0x4]
80005706:	ad b8       	sbr	r8,0xd
80005708:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000570a:	8e b8       	ld.uh	r8,r7[0x6]
8000570c:	20 28       	sub	r8,2
8000570e:	8d a8       	st.w	r6[0x28],r8
80005710:	c0 68       	rjmp	8000571c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005712:	6c 19       	ld.w	r9,r6[0x4]
80005714:	5c 78       	castu.h	r8
80005716:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000571a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000571c:	6c 18       	ld.w	r8,r6[0x4]
8000571e:	e0 18 ff f0 	andl	r8,0xfff0
80005722:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005724:	35 08       	mov	r8,80
80005726:	8d 08       	st.w	r6[0x0],r8
80005728:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000572c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005730:	80 00       	ld.sh	r0,r0[0x0]
80005732:	56 40       	stdsp	sp[0x190],r0
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	55 32       	stdsp	sp[0x14c],r2

80005738 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005738:	f8 c8 ff f8 	sub	r8,r12,-8
8000573c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000573e:	3f f9       	mov	r9,-1
80005740:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005742:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005744:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005746:	30 08       	mov	r8,0
80005748:	99 08       	st.w	r12[0x0],r8
}
8000574a:	5e fc       	retal	r12

8000574c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000574c:	30 08       	mov	r8,0
8000574e:	99 48       	st.w	r12[0x10],r8
}
80005750:	5e fc       	retal	r12

80005752 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005752:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005754:	70 19       	ld.w	r9,r8[0x4]
80005756:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005758:	78 19       	ld.w	r9,r12[0x4]
8000575a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000575c:	70 19       	ld.w	r9,r8[0x4]
8000575e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005760:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005762:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005764:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005766:	78 08       	ld.w	r8,r12[0x0]
80005768:	2f f8       	sub	r8,-1
8000576a:	99 08       	st.w	r12[0x0],r8
}
8000576c:	5e fc       	retal	r12

8000576e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000576e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005770:	5b fa       	cp.w	r10,-1
80005772:	c0 31       	brne	80005778 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005774:	78 48       	ld.w	r8,r12[0x10]
80005776:	c0 c8       	rjmp	8000578e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005778:	f8 c8 ff f8 	sub	r8,r12,-8
8000577c:	70 19       	ld.w	r9,r8[0x4]
8000577e:	72 09       	ld.w	r9,r9[0x0]
80005780:	12 3a       	cp.w	r10,r9
80005782:	c0 63       	brcs	8000578e <vListInsert+0x20>
80005784:	70 18       	ld.w	r8,r8[0x4]
80005786:	70 19       	ld.w	r9,r8[0x4]
80005788:	72 09       	ld.w	r9,r9[0x0]
8000578a:	12 3a       	cp.w	r10,r9
8000578c:	cf c2       	brcc	80005784 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000578e:	70 19       	ld.w	r9,r8[0x4]
80005790:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005792:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005794:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005796:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005798:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000579a:	78 08       	ld.w	r8,r12[0x0]
8000579c:	2f f8       	sub	r8,-1
8000579e:	99 08       	st.w	r12[0x0],r8
}
800057a0:	5e fc       	retal	r12

800057a2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800057a2:	78 18       	ld.w	r8,r12[0x4]
800057a4:	78 29       	ld.w	r9,r12[0x8]
800057a6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800057a8:	78 28       	ld.w	r8,r12[0x8]
800057aa:	78 19       	ld.w	r9,r12[0x4]
800057ac:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800057ae:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800057b0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800057b2:	18 39       	cp.w	r9,r12
800057b4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800057b8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057bc:	30 09       	mov	r9,0
800057be:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057c0:	70 09       	ld.w	r9,r8[0x0]
800057c2:	20 19       	sub	r9,1
800057c4:	91 09       	st.w	r8[0x0],r9
}
800057c6:	5e fc       	retal	r12

800057c8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057c8:	e0 68 08 08 	mov	r8,2056
800057cc:	ea 18 08 08 	orh	r8,0x808
800057d0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057d2:	e0 68 09 09 	mov	r8,2313
800057d6:	ea 18 09 09 	orh	r8,0x909
800057da:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800057dc:	e0 68 0a 0a 	mov	r8,2570
800057e0:	ea 18 0a 0a 	orh	r8,0xa0a
800057e4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800057e6:	e0 68 0b 0b 	mov	r8,2827
800057ea:	ea 18 0b 0b 	orh	r8,0xb0b
800057ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800057f0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800057f2:	e0 68 be ef 	mov	r8,48879
800057f6:	ea 18 de ad 	orh	r8,0xdead
800057fa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800057fc:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800057fe:	fc 18 00 40 	movh	r8,0x40
80005802:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005804:	e0 68 00 ff 	mov	r8,255
80005808:	ea 18 ff 00 	orh	r8,0xff00
8000580c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000580e:	e0 68 01 01 	mov	r8,257
80005812:	ea 18 01 01 	orh	r8,0x101
80005816:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005818:	e0 68 02 02 	mov	r8,514
8000581c:	ea 18 02 02 	orh	r8,0x202
80005820:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005822:	e0 68 03 03 	mov	r8,771
80005826:	ea 18 03 03 	orh	r8,0x303
8000582a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000582c:	e0 68 04 04 	mov	r8,1028
80005830:	ea 18 04 04 	orh	r8,0x404
80005834:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005836:	e0 68 05 05 	mov	r8,1285
8000583a:	ea 18 05 05 	orh	r8,0x505
8000583e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005840:	e0 68 06 06 	mov	r8,1542
80005844:	ea 18 06 06 	orh	r8,0x606
80005848:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000584a:	e0 68 07 07 	mov	r8,1799
8000584e:	ea 18 07 07 	orh	r8,0x707
80005852:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005854:	30 08       	mov	r8,0
80005856:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005858:	5e fc       	retal	r12
8000585a:	d7 03       	nop

8000585c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000585c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000585e:	48 38       	lddpc	r8,80005868 <vPortEnterCritical+0xc>
80005860:	70 09       	ld.w	r9,r8[0x0]
80005862:	2f f9       	sub	r9,-1
80005864:	91 09       	st.w	r8[0x0],r9
}
80005866:	5e fc       	retal	r12
80005868:	00 00       	add	r0,r0
8000586a:	05 34       	ld.ub	r4,r2++

8000586c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000586c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000586e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005870:	30 0a       	mov	r10,0
80005872:	14 9b       	mov	r11,r10
80005874:	49 2c       	lddpc	r12,800058bc <xPortStartScheduler+0x50>
80005876:	f0 1f 00 13 	mcall	800058c0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000587a:	e0 68 5d c0 	mov	r8,24000
8000587e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005882:	30 08       	mov	r8,0
80005884:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005888:	e0 68 0c d4 	mov	r8,3284
8000588c:	ea 18 00 00 	orh	r8,0x0
80005890:	70 00       	ld.w	r0,r8[0x0]
80005892:	60 0d       	ld.w	sp,r0[0x0]
80005894:	1b 00       	ld.w	r0,sp++
80005896:	e0 68 05 34 	mov	r8,1332
8000589a:	ea 18 00 00 	orh	r8,0x0
8000589e:	91 00       	st.w	r8[0x0],r0
800058a0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800058a4:	2f ed       	sub	sp,-8
800058a6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800058aa:	fa f0 ff e0 	ld.w	r0,sp[-32]
800058ae:	e3 b0 00 00 	mtsr	0x0,r0
800058b2:	fa f0 ff dc 	ld.w	r0,sp[-36]
800058b6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800058ba:	d8 0a       	popm	pc,r12=0
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	59 88       	cp.w	r8,24
800058c0:	80 00       	ld.sh	r0,r0[0x0]
800058c2:	50 50       	stdsp	sp[0x14],r0

800058c4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058c4:	20 6d       	sub	sp,24
800058c6:	eb cd 00 ff 	pushm	r0-r7
800058ca:	fa c7 ff c0 	sub	r7,sp,-64
800058ce:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058d2:	ef 40 ff e0 	st.w	r7[-32],r0
800058d6:	ee f0 ff fc 	ld.w	r0,r7[-4]
800058da:	ef 40 ff e4 	st.w	r7[-28],r0
800058de:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800058e2:	e0 68 05 34 	mov	r8,1332
800058e6:	ea 18 00 00 	orh	r8,0x0
800058ea:	70 00       	ld.w	r0,r8[0x0]
800058ec:	1a d0       	st.w	--sp,r0
800058ee:	f0 1f 00 1a 	mcall	80005954 <LABEL_RET_SCALL_263+0x14>
800058f2:	e0 68 0c d4 	mov	r8,3284
800058f6:	ea 18 00 00 	orh	r8,0x0
800058fa:	70 00       	ld.w	r0,r8[0x0]
800058fc:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800058fe:	f0 1f 00 17 	mcall	80005958 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005902:	e0 68 0c d4 	mov	r8,3284
80005906:	ea 18 00 00 	orh	r8,0x0
8000590a:	70 00       	ld.w	r0,r8[0x0]
8000590c:	60 0d       	ld.w	sp,r0[0x0]
8000590e:	1b 00       	ld.w	r0,sp++
80005910:	e0 68 05 34 	mov	r8,1332
80005914:	ea 18 00 00 	orh	r8,0x0
80005918:	91 00       	st.w	r8[0x0],r0
8000591a:	fa c7 ff d8 	sub	r7,sp,-40
8000591e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005922:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005926:	e0 61 05 34 	mov	r1,1332
8000592a:	ea 11 00 00 	orh	r1,0x0
8000592e:	62 02       	ld.w	r2,r1[0x0]
80005930:	58 02       	cp.w	r2,0
80005932:	c0 70       	breq	80005940 <LABEL_RET_SCALL_263>
80005934:	e4 c2 00 01 	sub	r2,r2,1
80005938:	83 02       	st.w	r1[0x0],r2
8000593a:	58 02       	cp.w	r2,0
8000593c:	c0 21       	brne	80005940 <LABEL_RET_SCALL_263>
8000593e:	b1 c0       	cbr	r0,0x10

80005940 <LABEL_RET_SCALL_263>:
80005940:	ef 40 ff f8 	st.w	r7[-8],r0
80005944:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005948:	ef 40 ff fc 	st.w	r7[-4],r0
8000594c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005950:	2f ad       	sub	sp,-24
80005952:	d6 13       	rets
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	58 5c       	cp.w	r12,5
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	5f a0       	srle	r0

8000595c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000595c:	e1 b8 00 43 	mfsr	r8,0x10c
80005960:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005964:	5e fc       	retal	r12
80005966:	d7 03       	nop

80005968 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005968:	48 78       	lddpc	r8,80005984 <vPortExitCritical+0x1c>
8000596a:	70 08       	ld.w	r8,r8[0x0]
8000596c:	58 08       	cp.w	r8,0
8000596e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005970:	48 58       	lddpc	r8,80005984 <vPortExitCritical+0x1c>
80005972:	70 09       	ld.w	r9,r8[0x0]
80005974:	20 19       	sub	r9,1
80005976:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005978:	70 08       	ld.w	r8,r8[0x0]
8000597a:	58 08       	cp.w	r8,0
8000597c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000597e:	d5 03       	csrf	0x10
80005980:	5e fc       	retal	r12
80005982:	00 00       	add	r0,r0
80005984:	00 00       	add	r0,r0
80005986:	05 34       	ld.ub	r4,r2++

80005988 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005988:	eb cd 00 ff 	pushm	r0-r7
8000598c:	e0 68 05 34 	mov	r8,1332
80005990:	ea 18 00 00 	orh	r8,0x0
80005994:	70 00       	ld.w	r0,r8[0x0]
80005996:	1a d0       	st.w	--sp,r0
80005998:	7a 90       	ld.w	r0,sp[0x24]
8000599a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000599e:	58 10       	cp.w	r0,1
800059a0:	e0 8b 00 08 	brhi	800059b0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800059a4:	e0 68 0c d4 	mov	r8,3284
800059a8:	ea 18 00 00 	orh	r8,0x0
800059ac:	70 00       	ld.w	r0,r8[0x0]
800059ae:	81 0d       	st.w	r0[0x0],sp

800059b0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800059b0:	f0 1f 00 12 	mcall	800059f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800059b4:	f0 1f 00 12 	mcall	800059fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800059b8:	f0 1f 00 12 	mcall	80005a00 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800059bc:	f0 1f 00 12 	mcall	80005a04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059c0:	7a 90       	ld.w	r0,sp[0x24]
800059c2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059c6:	58 10       	cp.w	r0,1
800059c8:	e0 8b 00 0e 	brhi	800059e4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800059cc:	f0 1f 00 0c 	mcall	800059fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800059d0:	f0 1f 00 0e 	mcall	80005a08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800059d4:	f0 1f 00 0c 	mcall	80005a04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800059d8:	e0 68 0c d4 	mov	r8,3284
800059dc:	ea 18 00 00 	orh	r8,0x0
800059e0:	70 00       	ld.w	r0,r8[0x0]
800059e2:	60 0d       	ld.w	sp,r0[0x0]

800059e4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800059e4:	1b 00       	ld.w	r0,sp++
800059e6:	e0 68 05 34 	mov	r8,1332
800059ea:	ea 18 00 00 	orh	r8,0x0
800059ee:	91 00       	st.w	r8[0x0],r0
800059f0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800059f4:	d6 03       	rete
800059f6:	00 00       	add	r0,r0
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	59 5c       	cp.w	r12,21
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	58 5c       	cp.w	r12,5
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	61 a4       	ld.w	r4,r0[0x68]
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	59 68       	cp.w	r8,22
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	5f a0       	srle	r0

80005a0c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005a0c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005a0e:	f0 1f 00 02 	mcall	80005a14 <__malloc_lock+0x8>
}
80005a12:	d8 02       	popm	pc
80005a14:	80 00       	ld.sh	r0,r0[0x0]
80005a16:	5f 90       	srgt	r0

80005a18 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005a18:	d4 01       	pushm	lr
	xTaskResumeAll();
80005a1a:	f0 1f 00 02 	mcall	80005a20 <__malloc_unlock+0x8>
}
80005a1e:	d8 02       	popm	pc
80005a20:	80 00       	ld.sh	r0,r0[0x0]
80005a22:	63 4c       	ld.w	r12,r1[0x50]

80005a24 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005a24:	d4 21       	pushm	r4-r7,lr
80005a26:	16 95       	mov	r5,r11
80005a28:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005a2a:	58 0c       	cp.w	r12,0
80005a2c:	c0 30       	breq	80005a32 <_read+0xe>
80005a2e:	3f f7       	mov	r7,-1
80005a30:	c1 48       	rjmp	80005a58 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005a32:	58 0a       	cp.w	r10,0
80005a34:	e0 89 00 04 	brgt	80005a3c <_read+0x18>
80005a38:	30 07       	mov	r7,0
80005a3a:	c0 f8       	rjmp	80005a58 <_read+0x34>
80005a3c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005a3e:	48 84       	lddpc	r4,80005a5c <_read+0x38>
80005a40:	68 0c       	ld.w	r12,r4[0x0]
80005a42:	f0 1f 00 08 	mcall	80005a60 <_read+0x3c>
    if (c < 0)
80005a46:	c0 95       	brlt	80005a58 <_read+0x34>
      break;

    *ptr++ = c;
80005a48:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005a4c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005a4e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005a52:	58 08       	cp.w	r8,0
80005a54:	fe 99 ff f6 	brgt	80005a40 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005a58:	0e 9c       	mov	r12,r7
80005a5a:	d8 22       	popm	r4-r7,pc
80005a5c:	00 00       	add	r0,r0
80005a5e:	50 f8       	stdsp	sp[0x3c],r8
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	55 f0       	stdsp	sp[0x17c],r0

80005a64 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005a64:	d4 21       	pushm	r4-r7,lr
80005a66:	16 95       	mov	r5,r11
80005a68:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005a6a:	20 1c       	sub	r12,1
80005a6c:	58 2c       	cp.w	r12,2
80005a6e:	e0 8b 00 12 	brhi	80005a92 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a72:	58 0a       	cp.w	r10,0
80005a74:	c0 31       	brne	80005a7a <_write+0x16>
80005a76:	30 07       	mov	r7,0
80005a78:	c0 e8       	rjmp	80005a94 <_write+0x30>
80005a7a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005a7c:	48 74       	lddpc	r4,80005a98 <_write+0x34>
80005a7e:	68 0c       	ld.w	r12,r4[0x0]
80005a80:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005a84:	f0 1f 00 06 	mcall	80005a9c <_write+0x38>
80005a88:	c0 55       	brlt	80005a92 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005a8a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a8c:	0e 36       	cp.w	r6,r7
80005a8e:	cf 81       	brne	80005a7e <_write+0x1a>
80005a90:	c0 28       	rjmp	80005a94 <_write+0x30>
80005a92:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005a94:	0e 9c       	mov	r12,r7
80005a96:	d8 22       	popm	r4-r7,pc
80005a98:	00 00       	add	r0,r0
80005a9a:	50 f8       	stdsp	sp[0x3c],r8
80005a9c:	80 00       	ld.sh	r0,r0[0x0]
80005a9e:	55 a0       	stdsp	sp[0x168],r0

80005aa0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005aa0:	eb cd 40 80 	pushm	r7,lr
80005aa4:	18 97       	mov	r7,r12
	if( pv )
80005aa6:	58 0c       	cp.w	r12,0
80005aa8:	c0 80       	breq	80005ab8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005aaa:	f0 1f 00 05 	mcall	80005abc <vPortFree+0x1c>
		{
			free( pv );
80005aae:	0e 9c       	mov	r12,r7
80005ab0:	f0 1f 00 04 	mcall	80005ac0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005ab4:	f0 1f 00 04 	mcall	80005ac4 <vPortFree+0x24>
80005ab8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	5f 90       	srgt	r0
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	6e f0       	ld.w	r0,r7[0x3c]
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	63 4c       	ld.w	r12,r1[0x50]

80005ac8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005ac8:	eb cd 40 80 	pushm	r7,lr
80005acc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005ace:	f0 1f 00 06 	mcall	80005ae4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005ad2:	0e 9c       	mov	r12,r7
80005ad4:	f0 1f 00 05 	mcall	80005ae8 <pvPortMalloc+0x20>
80005ad8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005ada:	f0 1f 00 05 	mcall	80005aec <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005ade:	0e 9c       	mov	r12,r7
80005ae0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ae4:	80 00       	ld.sh	r0,r0[0x0]
80005ae6:	5f 90       	srgt	r0
80005ae8:	80 00       	ld.sh	r0,r0[0x0]
80005aea:	6f 00       	ld.w	r0,r7[0x40]
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	63 4c       	ld.w	r12,r1[0x50]

80005af0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005af0:	d4 01       	pushm	lr
80005af2:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005af4:	78 09       	ld.w	r9,r12[0x0]
80005af6:	58 09       	cp.w	r9,0
80005af8:	c1 10       	breq	80005b1a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005afa:	78 3a       	ld.w	r10,r12[0xc]
80005afc:	79 09       	ld.w	r9,r12[0x40]
80005afe:	f4 09 00 09 	add	r9,r10,r9
80005b02:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005b04:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005b06:	14 39       	cp.w	r9,r10
80005b08:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005b0c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005b10:	79 0a       	ld.w	r10,r12[0x40]
80005b12:	78 3b       	ld.w	r11,r12[0xc]
80005b14:	10 9c       	mov	r12,r8
80005b16:	f0 1f 00 02 	mcall	80005b1c <prvCopyDataFromQueue+0x2c>
80005b1a:	d8 02       	popm	pc
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	73 6e       	ld.w	lr,r9[0x58]

80005b20 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005b20:	eb cd 40 c0 	pushm	r6-r7,lr
80005b24:	18 97       	mov	r7,r12
80005b26:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005b28:	78 e8       	ld.w	r8,r12[0x38]
80005b2a:	58 08       	cp.w	r8,0
80005b2c:	c0 31       	brne	80005b32 <xQueueReceiveFromISR+0x12>
80005b2e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005b32:	f0 1f 00 0e 	mcall	80005b68 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005b36:	6e e8       	ld.w	r8,r7[0x38]
80005b38:	20 18       	sub	r8,1
80005b3a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005b3c:	6f 18       	ld.w	r8,r7[0x44]
80005b3e:	5b f8       	cp.w	r8,-1
80005b40:	c0 d1       	brne	80005b5a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005b42:	6e 48       	ld.w	r8,r7[0x10]
80005b44:	58 08       	cp.w	r8,0
80005b46:	c0 f0       	breq	80005b64 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005b48:	ee cc ff f0 	sub	r12,r7,-16
80005b4c:	f0 1f 00 08 	mcall	80005b6c <xQueueReceiveFromISR+0x4c>
80005b50:	c0 a0       	breq	80005b64 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005b52:	30 1c       	mov	r12,1
80005b54:	8d 0c       	st.w	r6[0x0],r12
80005b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005b5a:	2f f8       	sub	r8,-1
80005b5c:	ef 48 00 44 	st.w	r7[68],r8
80005b60:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b64:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	5a f0       	cp.w	r0,-17
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	61 28       	ld.w	r8,r0[0x48]

80005b70 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005b70:	eb cd 40 c0 	pushm	r6-r7,lr
80005b74:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005b76:	f0 1f 00 23 	mcall	80005c00 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b7a:	6f 28       	ld.w	r8,r7[0x48]
80005b7c:	58 08       	cp.w	r8,0
80005b7e:	e0 8a 00 18 	brle	80005bae <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b82:	6e 98       	ld.w	r8,r7[0x24]
80005b84:	58 08       	cp.w	r8,0
80005b86:	c1 40       	breq	80005bae <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b88:	ee c6 ff dc 	sub	r6,r7,-36
80005b8c:	c0 48       	rjmp	80005b94 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b8e:	6e 98       	ld.w	r8,r7[0x24]
80005b90:	58 08       	cp.w	r8,0
80005b92:	c0 e0       	breq	80005bae <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b94:	0c 9c       	mov	r12,r6
80005b96:	f0 1f 00 1c 	mcall	80005c04 <prvUnlockQueue+0x94>
80005b9a:	c0 30       	breq	80005ba0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005b9c:	f0 1f 00 1b 	mcall	80005c08 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005ba0:	6f 28       	ld.w	r8,r7[0x48]
80005ba2:	20 18       	sub	r8,1
80005ba4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005ba8:	58 08       	cp.w	r8,0
80005baa:	fe 99 ff f2 	brgt	80005b8e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005bae:	3f f8       	mov	r8,-1
80005bb0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005bb4:	f0 1f 00 16 	mcall	80005c0c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005bb8:	f0 1f 00 12 	mcall	80005c00 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005bbc:	6f 18       	ld.w	r8,r7[0x44]
80005bbe:	58 08       	cp.w	r8,0
80005bc0:	e0 8a 00 18 	brle	80005bf0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bc4:	6e 48       	ld.w	r8,r7[0x10]
80005bc6:	58 08       	cp.w	r8,0
80005bc8:	c1 40       	breq	80005bf0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bca:	ee c6 ff f0 	sub	r6,r7,-16
80005bce:	c0 48       	rjmp	80005bd6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bd0:	6e 48       	ld.w	r8,r7[0x10]
80005bd2:	58 08       	cp.w	r8,0
80005bd4:	c0 e0       	breq	80005bf0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bd6:	0c 9c       	mov	r12,r6
80005bd8:	f0 1f 00 0b 	mcall	80005c04 <prvUnlockQueue+0x94>
80005bdc:	c0 30       	breq	80005be2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005bde:	f0 1f 00 0b 	mcall	80005c08 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005be2:	6f 18       	ld.w	r8,r7[0x44]
80005be4:	20 18       	sub	r8,1
80005be6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005bea:	58 08       	cp.w	r8,0
80005bec:	fe 99 ff f2 	brgt	80005bd0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005bf0:	3f f8       	mov	r8,-1
80005bf2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005bf6:	f0 1f 00 06 	mcall	80005c0c <prvUnlockQueue+0x9c>
}
80005bfa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bfe:	00 00       	add	r0,r0
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	58 5c       	cp.w	r12,5
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	61 28       	ld.w	r8,r0[0x48]
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	60 34       	ld.w	r4,r0[0xc]
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	59 68       	cp.w	r8,22

80005c10 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005c10:	d4 31       	pushm	r0-r7,lr
80005c12:	20 5d       	sub	sp,20
80005c14:	18 97       	mov	r7,r12
80005c16:	50 0b       	stdsp	sp[0x0],r11
80005c18:	50 2a       	stdsp	sp[0x8],r10
80005c1a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005c1c:	f8 c2 ff dc 	sub	r2,r12,-36
80005c20:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c22:	fa c4 ff f4 	sub	r4,sp,-12
80005c26:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c28:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c2a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005c2e:	f0 1f 00 3e 	mcall	80005d24 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005c32:	6e e8       	ld.w	r8,r7[0x38]
80005c34:	58 08       	cp.w	r8,0
80005c36:	c2 a0       	breq	80005c8a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005c38:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005c3a:	40 0b       	lddsp	r11,sp[0x0]
80005c3c:	0e 9c       	mov	r12,r7
80005c3e:	f0 1f 00 3b 	mcall	80005d28 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005c42:	40 18       	lddsp	r8,sp[0x4]
80005c44:	58 08       	cp.w	r8,0
80005c46:	c1 51       	brne	80005c70 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005c48:	6e e8       	ld.w	r8,r7[0x38]
80005c4a:	20 18       	sub	r8,1
80005c4c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005c4e:	6e 08       	ld.w	r8,r7[0x0]
80005c50:	58 08       	cp.w	r8,0
80005c52:	c0 41       	brne	80005c5a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005c54:	f0 1f 00 36 	mcall	80005d2c <xQueueGenericReceive+0x11c>
80005c58:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c5a:	6e 48       	ld.w	r8,r7[0x10]
80005c5c:	58 08       	cp.w	r8,0
80005c5e:	c1 20       	breq	80005c82 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005c60:	ee cc ff f0 	sub	r12,r7,-16
80005c64:	f0 1f 00 33 	mcall	80005d30 <xQueueGenericReceive+0x120>
80005c68:	58 1c       	cp.w	r12,1
80005c6a:	c0 c1       	brne	80005c82 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005c6c:	d7 33       	scall
80005c6e:	c0 a8       	rjmp	80005c82 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005c70:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c72:	6e 98       	ld.w	r8,r7[0x24]
80005c74:	58 08       	cp.w	r8,0
80005c76:	c0 60       	breq	80005c82 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c78:	04 9c       	mov	r12,r2
80005c7a:	f0 1f 00 2e 	mcall	80005d30 <xQueueGenericReceive+0x120>
80005c7e:	c0 20       	breq	80005c82 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005c80:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005c82:	f0 1f 00 2d 	mcall	80005d34 <xQueueGenericReceive+0x124>
80005c86:	30 1c       	mov	r12,1
				return pdPASS;
80005c88:	c4 c8       	rjmp	80005d20 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005c8a:	40 28       	lddsp	r8,sp[0x8]
80005c8c:	58 08       	cp.w	r8,0
80005c8e:	c0 51       	brne	80005c98 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005c90:	f0 1f 00 29 	mcall	80005d34 <xQueueGenericReceive+0x124>
80005c94:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005c96:	c4 58       	rjmp	80005d20 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005c98:	58 05       	cp.w	r5,0
80005c9a:	c0 51       	brne	80005ca4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c9c:	08 9c       	mov	r12,r4
80005c9e:	f0 1f 00 27 	mcall	80005d38 <xQueueGenericReceive+0x128>
80005ca2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005ca4:	f0 1f 00 24 	mcall	80005d34 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005ca8:	f0 1f 00 25 	mcall	80005d3c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005cac:	f0 1f 00 1e 	mcall	80005d24 <xQueueGenericReceive+0x114>
80005cb0:	6f 18       	ld.w	r8,r7[0x44]
80005cb2:	5b f8       	cp.w	r8,-1
80005cb4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005cb8:	6f 28       	ld.w	r8,r7[0x48]
80005cba:	5b f8       	cp.w	r8,-1
80005cbc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005cc0:	f0 1f 00 1d 	mcall	80005d34 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005cc4:	06 9b       	mov	r11,r3
80005cc6:	08 9c       	mov	r12,r4
80005cc8:	f0 1f 00 1e 	mcall	80005d40 <xQueueGenericReceive+0x130>
80005ccc:	c2 41       	brne	80005d14 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005cce:	f0 1f 00 16 	mcall	80005d24 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cd2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005cd4:	f0 1f 00 18 	mcall	80005d34 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005cd8:	58 06       	cp.w	r6,0
80005cda:	c1 71       	brne	80005d08 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005cdc:	6e 08       	ld.w	r8,r7[0x0]
80005cde:	58 08       	cp.w	r8,0
80005ce0:	c0 81       	brne	80005cf0 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005ce2:	f0 1f 00 11 	mcall	80005d24 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005ce6:	6e 1c       	ld.w	r12,r7[0x4]
80005ce8:	f0 1f 00 17 	mcall	80005d44 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005cec:	f0 1f 00 12 	mcall	80005d34 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005cf0:	40 2b       	lddsp	r11,sp[0x8]
80005cf2:	04 9c       	mov	r12,r2
80005cf4:	f0 1f 00 15 	mcall	80005d48 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005cf8:	0e 9c       	mov	r12,r7
80005cfa:	f0 1f 00 15 	mcall	80005d4c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005cfe:	f0 1f 00 15 	mcall	80005d50 <xQueueGenericReceive+0x140>
80005d02:	c9 61       	brne	80005c2e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005d04:	d7 33       	scall
80005d06:	c9 4b       	rjmp	80005c2e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005d08:	0e 9c       	mov	r12,r7
80005d0a:	f0 1f 00 11 	mcall	80005d4c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005d0e:	f0 1f 00 11 	mcall	80005d50 <xQueueGenericReceive+0x140>
80005d12:	c8 eb       	rjmp	80005c2e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005d14:	0e 9c       	mov	r12,r7
80005d16:	f0 1f 00 0e 	mcall	80005d4c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005d1a:	f0 1f 00 0e 	mcall	80005d50 <xQueueGenericReceive+0x140>
80005d1e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005d20:	2f bd       	sub	sp,-20
80005d22:	d8 32       	popm	r0-r7,pc
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	58 5c       	cp.w	r12,5
80005d28:	80 00       	ld.sh	r0,r0[0x0]
80005d2a:	5a f0       	cp.w	r0,-17
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	60 40       	ld.w	r0,r0[0x10]
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	61 28       	ld.w	r8,r0[0x48]
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	59 68       	cp.w	r8,22
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	60 1c       	ld.w	r12,r0[0x4]
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	5f 90       	srgt	r0
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	62 b8       	ld.w	r8,r1[0x2c]
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	60 a4       	ld.w	r4,r0[0x28]
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	65 10       	ld.w	r0,r2[0x44]
80005d4c:	80 00       	ld.sh	r0,r0[0x0]
80005d4e:	5b 70       	cp.w	r0,-9
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	63 4c       	ld.w	r12,r1[0x50]

80005d54 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005d54:	eb cd 40 80 	pushm	r7,lr
80005d58:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005d5a:	79 08       	ld.w	r8,r12[0x40]
80005d5c:	58 08       	cp.w	r8,0
80005d5e:	c0 a1       	brne	80005d72 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d60:	78 08       	ld.w	r8,r12[0x0]
80005d62:	58 08       	cp.w	r8,0
80005d64:	c2 b1       	brne	80005dba <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005d66:	78 1c       	ld.w	r12,r12[0x4]
80005d68:	f0 1f 00 17 	mcall	80005dc4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005d6c:	30 08       	mov	r8,0
80005d6e:	8f 18       	st.w	r7[0x4],r8
80005d70:	c2 58       	rjmp	80005dba <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005d72:	58 0a       	cp.w	r10,0
80005d74:	c1 01       	brne	80005d94 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d76:	10 9a       	mov	r10,r8
80005d78:	78 2c       	ld.w	r12,r12[0x8]
80005d7a:	f0 1f 00 14 	mcall	80005dc8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005d7e:	6e 29       	ld.w	r9,r7[0x8]
80005d80:	6f 08       	ld.w	r8,r7[0x40]
80005d82:	f2 08 00 08 	add	r8,r9,r8
80005d86:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005d88:	6e 19       	ld.w	r9,r7[0x4]
80005d8a:	12 38       	cp.w	r8,r9
80005d8c:	c1 73       	brcs	80005dba <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005d8e:	6e 08       	ld.w	r8,r7[0x0]
80005d90:	8f 28       	st.w	r7[0x8],r8
80005d92:	c1 48       	rjmp	80005dba <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d94:	10 9a       	mov	r10,r8
80005d96:	78 3c       	ld.w	r12,r12[0xc]
80005d98:	f0 1f 00 0c 	mcall	80005dc8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005d9c:	6f 08       	ld.w	r8,r7[0x40]
80005d9e:	6e 39       	ld.w	r9,r7[0xc]
80005da0:	f2 08 01 08 	sub	r8,r9,r8
80005da4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005da6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005da8:	12 38       	cp.w	r8,r9
80005daa:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005dae:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005db2:	f3 d8 e3 19 	subcs	r9,r9,r8
80005db6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005dba:	6e e8       	ld.w	r8,r7[0x38]
80005dbc:	2f f8       	sub	r8,-1
80005dbe:	8f e8       	st.w	r7[0x38],r8
}
80005dc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	60 4c       	ld.w	r12,r0[0x10]
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	73 6e       	ld.w	lr,r9[0x58]

80005dcc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005dcc:	eb cd 40 c0 	pushm	r6-r7,lr
80005dd0:	18 97       	mov	r7,r12
80005dd2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005dd4:	78 ec       	ld.w	r12,r12[0x38]
80005dd6:	6e f8       	ld.w	r8,r7[0x3c]
80005dd8:	10 3c       	cp.w	r12,r8
80005dda:	c0 33       	brcs	80005de0 <xQueueGenericSendFromISR+0x14>
80005ddc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005de0:	12 9a       	mov	r10,r9
80005de2:	0e 9c       	mov	r12,r7
80005de4:	f0 1f 00 0c 	mcall	80005e14 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005de8:	6f 28       	ld.w	r8,r7[0x48]
80005dea:	5b f8       	cp.w	r8,-1
80005dec:	c0 d1       	brne	80005e06 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005dee:	6e 98       	ld.w	r8,r7[0x24]
80005df0:	58 08       	cp.w	r8,0
80005df2:	c0 f0       	breq	80005e10 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005df4:	ee cc ff dc 	sub	r12,r7,-36
80005df8:	f0 1f 00 08 	mcall	80005e18 <xQueueGenericSendFromISR+0x4c>
80005dfc:	c0 a0       	breq	80005e10 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005dfe:	30 1c       	mov	r12,1
80005e00:	8d 0c       	st.w	r6[0x0],r12
80005e02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005e06:	2f f8       	sub	r8,-1
80005e08:	ef 48 00 48 	st.w	r7[72],r8
80005e0c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e10:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	5d 54       	*unknown*
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	61 28       	ld.w	r8,r0[0x48]

80005e1c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005e1c:	d4 31       	pushm	r0-r7,lr
80005e1e:	20 5d       	sub	sp,20
80005e20:	18 97       	mov	r7,r12
80005e22:	50 0b       	stdsp	sp[0x0],r11
80005e24:	50 2a       	stdsp	sp[0x8],r10
80005e26:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005e28:	f8 c0 ff f0 	sub	r0,r12,-16
80005e2c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e2e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e32:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e34:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005e38:	f0 1f 00 2f 	mcall	80005ef4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e3c:	6e e9       	ld.w	r9,r7[0x38]
80005e3e:	6e f8       	ld.w	r8,r7[0x3c]
80005e40:	10 39       	cp.w	r9,r8
80005e42:	c1 42       	brcc	80005e6a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e44:	40 1a       	lddsp	r10,sp[0x4]
80005e46:	40 0b       	lddsp	r11,sp[0x0]
80005e48:	0e 9c       	mov	r12,r7
80005e4a:	f0 1f 00 2c 	mcall	80005ef8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e4e:	6e 98       	ld.w	r8,r7[0x24]
80005e50:	58 08       	cp.w	r8,0
80005e52:	c0 80       	breq	80005e62 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005e54:	ee cc ff dc 	sub	r12,r7,-36
80005e58:	f0 1f 00 29 	mcall	80005efc <xQueueGenericSend+0xe0>
80005e5c:	58 1c       	cp.w	r12,1
80005e5e:	c0 21       	brne	80005e62 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005e60:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005e62:	f0 1f 00 28 	mcall	80005f00 <xQueueGenericSend+0xe4>
80005e66:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005e68:	c4 38       	rjmp	80005eee <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e6a:	40 28       	lddsp	r8,sp[0x8]
80005e6c:	58 08       	cp.w	r8,0
80005e6e:	c0 51       	brne	80005e78 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005e70:	f0 1f 00 24 	mcall	80005f00 <xQueueGenericSend+0xe4>
80005e74:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005e76:	c3 c8       	rjmp	80005eee <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005e78:	58 04       	cp.w	r4,0
80005e7a:	c0 51       	brne	80005e84 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e7c:	06 9c       	mov	r12,r3
80005e7e:	f0 1f 00 22 	mcall	80005f04 <xQueueGenericSend+0xe8>
80005e82:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005e84:	f0 1f 00 1f 	mcall	80005f00 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005e88:	f0 1f 00 20 	mcall	80005f08 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005e8c:	f0 1f 00 1a 	mcall	80005ef4 <xQueueGenericSend+0xd8>
80005e90:	6f 18       	ld.w	r8,r7[0x44]
80005e92:	5b f8       	cp.w	r8,-1
80005e94:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005e98:	6f 28       	ld.w	r8,r7[0x48]
80005e9a:	5b f8       	cp.w	r8,-1
80005e9c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ea0:	f0 1f 00 18 	mcall	80005f00 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ea4:	04 9b       	mov	r11,r2
80005ea6:	06 9c       	mov	r12,r3
80005ea8:	f0 1f 00 19 	mcall	80005f0c <xQueueGenericSend+0xf0>
80005eac:	c1 b1       	brne	80005ee2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005eae:	f0 1f 00 12 	mcall	80005ef4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005eb2:	6e e5       	ld.w	r5,r7[0x38]
80005eb4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005eb6:	f0 1f 00 13 	mcall	80005f00 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005eba:	0c 35       	cp.w	r5,r6
80005ebc:	c0 d1       	brne	80005ed6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ebe:	40 2b       	lddsp	r11,sp[0x8]
80005ec0:	00 9c       	mov	r12,r0
80005ec2:	f0 1f 00 14 	mcall	80005f10 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005ec6:	0e 9c       	mov	r12,r7
80005ec8:	f0 1f 00 13 	mcall	80005f14 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005ecc:	f0 1f 00 13 	mcall	80005f18 <xQueueGenericSend+0xfc>
80005ed0:	cb 41       	brne	80005e38 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005ed2:	d7 33       	scall
80005ed4:	cb 2b       	rjmp	80005e38 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005ed6:	0e 9c       	mov	r12,r7
80005ed8:	f0 1f 00 0f 	mcall	80005f14 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005edc:	f0 1f 00 0f 	mcall	80005f18 <xQueueGenericSend+0xfc>
80005ee0:	ca cb       	rjmp	80005e38 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005ee2:	0e 9c       	mov	r12,r7
80005ee4:	f0 1f 00 0c 	mcall	80005f14 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005ee8:	f0 1f 00 0c 	mcall	80005f18 <xQueueGenericSend+0xfc>
80005eec:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005eee:	2f bd       	sub	sp,-20
80005ef0:	d8 32       	popm	r0-r7,pc
80005ef2:	00 00       	add	r0,r0
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	58 5c       	cp.w	r12,5
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	5d 54       	*unknown*
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	61 28       	ld.w	r8,r0[0x48]
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	59 68       	cp.w	r8,22
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	60 1c       	ld.w	r12,r0[0x4]
80005f08:	80 00       	ld.sh	r0,r0[0x0]
80005f0a:	5f 90       	srgt	r0
80005f0c:	80 00       	ld.sh	r0,r0[0x0]
80005f0e:	62 b8       	ld.w	r8,r1[0x2c]
80005f10:	80 00       	ld.sh	r0,r0[0x0]
80005f12:	65 10       	ld.w	r0,r2[0x44]
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	5b 70       	cp.w	r0,-9
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	63 4c       	ld.w	r12,r1[0x50]

80005f1c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005f1c:	d4 21       	pushm	r4-r7,lr
80005f1e:	18 97       	mov	r7,r12
80005f20:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005f22:	58 0c       	cp.w	r12,0
80005f24:	c2 f0       	breq	80005f82 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f26:	34 cc       	mov	r12,76
80005f28:	f0 1f 00 17 	mcall	80005f84 <xQueueCreate+0x68>
80005f2c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005f2e:	c2 a0       	breq	80005f82 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005f30:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005f34:	e8 cc ff ff 	sub	r12,r4,-1
80005f38:	f0 1f 00 13 	mcall	80005f84 <xQueueCreate+0x68>
80005f3c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005f3e:	c1 e0       	breq	80005f7a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005f40:	f8 04 00 04 	add	r4,r12,r4
80005f44:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f46:	30 08       	mov	r8,0
80005f48:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005f4a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005f4c:	ee c8 00 01 	sub	r8,r7,1
80005f50:	ad 38       	mul	r8,r6
80005f52:	10 0c       	add	r12,r8
80005f54:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005f56:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005f58:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005f5c:	3f f8       	mov	r8,-1
80005f5e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005f62:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005f66:	ea cc ff f0 	sub	r12,r5,-16
80005f6a:	f0 1f 00 08 	mcall	80005f88 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005f6e:	ea cc ff dc 	sub	r12,r5,-36
80005f72:	f0 1f 00 06 	mcall	80005f88 <xQueueCreate+0x6c>
80005f76:	0a 9c       	mov	r12,r5
80005f78:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005f7a:	0a 9c       	mov	r12,r5
80005f7c:	f0 1f 00 04 	mcall	80005f8c <xQueueCreate+0x70>
80005f80:	d8 2a       	popm	r4-r7,pc,r12=0
80005f82:	d8 2a       	popm	r4-r7,pc,r12=0
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	5a c8       	cp.w	r8,-20
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	57 38       	stdsp	sp[0x1cc],r8
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	5a a0       	cp.w	r0,-22

80005f90 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005f90:	48 38       	lddpc	r8,80005f9c <vTaskSuspendAll+0xc>
80005f92:	70 09       	ld.w	r9,r8[0x0]
80005f94:	2f f9       	sub	r9,-1
80005f96:	91 09       	st.w	r8[0x0],r9
}
80005f98:	5e fc       	retal	r12
80005f9a:	00 00       	add	r0,r0
80005f9c:	00 00       	add	r0,r0
80005f9e:	0d 04       	ld.w	r4,r6++

80005fa0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005fa0:	49 a8       	lddpc	r8,80006008 <vTaskSwitchContext+0x68>
80005fa2:	70 08       	ld.w	r8,r8[0x0]
80005fa4:	58 08       	cp.w	r8,0
80005fa6:	c0 b1       	brne	80005fbc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fa8:	49 98       	lddpc	r8,8000600c <vTaskSwitchContext+0x6c>
80005faa:	70 08       	ld.w	r8,r8[0x0]
80005fac:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fb0:	49 89       	lddpc	r9,80006010 <vTaskSwitchContext+0x70>
80005fb2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005fb6:	58 08       	cp.w	r8,0
80005fb8:	c0 60       	breq	80005fc4 <vTaskSwitchContext+0x24>
80005fba:	c1 18       	rjmp	80005fdc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005fbc:	30 19       	mov	r9,1
80005fbe:	49 68       	lddpc	r8,80006014 <vTaskSwitchContext+0x74>
80005fc0:	91 09       	st.w	r8[0x0],r9
80005fc2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fc4:	49 28       	lddpc	r8,8000600c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fc6:	49 3a       	lddpc	r10,80006010 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fc8:	70 09       	ld.w	r9,r8[0x0]
80005fca:	20 19       	sub	r9,1
80005fcc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fce:	70 09       	ld.w	r9,r8[0x0]
80005fd0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005fd4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005fd8:	58 09       	cp.w	r9,0
80005fda:	cf 70       	breq	80005fc8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005fdc:	48 c8       	lddpc	r8,8000600c <vTaskSwitchContext+0x6c>
80005fde:	70 08       	ld.w	r8,r8[0x0]
80005fe0:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fe4:	48 b9       	lddpc	r9,80006010 <vTaskSwitchContext+0x70>
80005fe6:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005fea:	70 19       	ld.w	r9,r8[0x4]
80005fec:	72 19       	ld.w	r9,r9[0x4]
80005fee:	91 19       	st.w	r8[0x4],r9
80005ff0:	f0 ca ff f8 	sub	r10,r8,-8
80005ff4:	14 39       	cp.w	r9,r10
80005ff6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005ffa:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005ffe:	70 18       	ld.w	r8,r8[0x4]
80006000:	70 39       	ld.w	r9,r8[0xc]
80006002:	48 68       	lddpc	r8,80006018 <vTaskSwitchContext+0x78>
80006004:	91 09       	st.w	r8[0x0],r9
80006006:	5e fc       	retal	r12
80006008:	00 00       	add	r0,r0
8000600a:	0d 04       	ld.w	r4,r6++
8000600c:	00 00       	add	r0,r0
8000600e:	0d 3c       	ld.ub	r12,r6++
80006010:	00 00       	add	r0,r0
80006012:	0c 20       	rsub	r0,r6
80006014:	00 00       	add	r0,r0
80006016:	0d 24       	ld.uh	r4,r6++
80006018:	00 00       	add	r0,r0
8000601a:	0c d4       	st.w	--r6,r4

8000601c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000601c:	48 48       	lddpc	r8,8000602c <vTaskSetTimeOutState+0x10>
8000601e:	70 08       	ld.w	r8,r8[0x0]
80006020:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006022:	48 48       	lddpc	r8,80006030 <vTaskSetTimeOutState+0x14>
80006024:	70 08       	ld.w	r8,r8[0x0]
80006026:	99 18       	st.w	r12[0x4],r8
}
80006028:	5e fc       	retal	r12
8000602a:	00 00       	add	r0,r0
8000602c:	00 00       	add	r0,r0
8000602e:	0c 18       	sub	r8,r6
80006030:	00 00       	add	r0,r0
80006032:	0d 00       	ld.w	r0,r6++

80006034 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006034:	30 19       	mov	r9,1
80006036:	48 28       	lddpc	r8,8000603c <vTaskMissedYield+0x8>
80006038:	91 09       	st.w	r8[0x0],r9
}
8000603a:	5e fc       	retal	r12
8000603c:	00 00       	add	r0,r0
8000603e:	0d 24       	ld.uh	r4,r6++

80006040 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006040:	48 28       	lddpc	r8,80006048 <xTaskGetCurrentTaskHandle+0x8>
80006042:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006044:	5e fc       	retal	r12
80006046:	00 00       	add	r0,r0
80006048:	00 00       	add	r0,r0
8000604a:	0c d4       	st.w	--r6,r4

8000604c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000604c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006050:	58 0c       	cp.w	r12,0
80006052:	c1 f0       	breq	80006090 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006054:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006056:	78 b9       	ld.w	r9,r12[0x2c]
80006058:	79 18       	ld.w	r8,r12[0x44]
8000605a:	10 39       	cp.w	r9,r8
8000605c:	c1 a0       	breq	80006090 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000605e:	f8 c6 ff fc 	sub	r6,r12,-4
80006062:	0c 9c       	mov	r12,r6
80006064:	f0 1f 00 0c 	mcall	80006094 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006068:	6f 1c       	ld.w	r12,r7[0x44]
8000606a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000606c:	f8 08 11 08 	rsub	r8,r12,8
80006070:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006072:	48 a8       	lddpc	r8,80006098 <vTaskPriorityDisinherit+0x4c>
80006074:	70 08       	ld.w	r8,r8[0x0]
80006076:	10 3c       	cp.w	r12,r8
80006078:	e0 88 00 04 	brls	80006080 <vTaskPriorityDisinherit+0x34>
8000607c:	48 78       	lddpc	r8,80006098 <vTaskPriorityDisinherit+0x4c>
8000607e:	91 0c       	st.w	r8[0x0],r12
80006080:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006084:	0c 9b       	mov	r11,r6
80006086:	48 68       	lddpc	r8,8000609c <vTaskPriorityDisinherit+0x50>
80006088:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000608c:	f0 1f 00 05 	mcall	800060a0 <vTaskPriorityDisinherit+0x54>
80006090:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	57 a2       	stdsp	sp[0x1e8],r2
80006098:	00 00       	add	r0,r0
8000609a:	0d 3c       	ld.ub	r12,r6++
8000609c:	00 00       	add	r0,r0
8000609e:	0c 20       	rsub	r0,r6
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	57 52       	stdsp	sp[0x1d4],r2

800060a4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800060a4:	eb cd 40 c0 	pushm	r6-r7,lr
800060a8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800060aa:	49 b8       	lddpc	r8,80006114 <vTaskPriorityInherit+0x70>
800060ac:	70 08       	ld.w	r8,r8[0x0]
800060ae:	78 b9       	ld.w	r9,r12[0x2c]
800060b0:	70 b8       	ld.w	r8,r8[0x2c]
800060b2:	10 39       	cp.w	r9,r8
800060b4:	c2 d2       	brcc	8000610e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800060b6:	49 88       	lddpc	r8,80006114 <vTaskPriorityInherit+0x70>
800060b8:	70 08       	ld.w	r8,r8[0x0]
800060ba:	70 b8       	ld.w	r8,r8[0x2c]
800060bc:	f0 08 11 08 	rsub	r8,r8,8
800060c0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800060c2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800060c6:	49 59       	lddpc	r9,80006118 <vTaskPriorityInherit+0x74>
800060c8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800060cc:	78 59       	ld.w	r9,r12[0x14]
800060ce:	10 39       	cp.w	r9,r8
800060d0:	c1 b1       	brne	80006106 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800060d2:	f8 c6 ff fc 	sub	r6,r12,-4
800060d6:	0c 9c       	mov	r12,r6
800060d8:	f0 1f 00 11 	mcall	8000611c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800060dc:	48 e8       	lddpc	r8,80006114 <vTaskPriorityInherit+0x70>
800060de:	70 08       	ld.w	r8,r8[0x0]
800060e0:	70 bc       	ld.w	r12,r8[0x2c]
800060e2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800060e4:	48 f8       	lddpc	r8,80006120 <vTaskPriorityInherit+0x7c>
800060e6:	70 08       	ld.w	r8,r8[0x0]
800060e8:	10 3c       	cp.w	r12,r8
800060ea:	e0 88 00 04 	brls	800060f2 <vTaskPriorityInherit+0x4e>
800060ee:	48 d8       	lddpc	r8,80006120 <vTaskPriorityInherit+0x7c>
800060f0:	91 0c       	st.w	r8[0x0],r12
800060f2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060f6:	0c 9b       	mov	r11,r6
800060f8:	48 88       	lddpc	r8,80006118 <vTaskPriorityInherit+0x74>
800060fa:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060fe:	f0 1f 00 0a 	mcall	80006124 <vTaskPriorityInherit+0x80>
80006102:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006106:	48 48       	lddpc	r8,80006114 <vTaskPriorityInherit+0x70>
80006108:	70 08       	ld.w	r8,r8[0x0]
8000610a:	70 b8       	ld.w	r8,r8[0x2c]
8000610c:	99 b8       	st.w	r12[0x2c],r8
8000610e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006112:	00 00       	add	r0,r0
80006114:	00 00       	add	r0,r0
80006116:	0c d4       	st.w	--r6,r4
80006118:	00 00       	add	r0,r0
8000611a:	0c 20       	rsub	r0,r6
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	57 a2       	stdsp	sp[0x1e8],r2
80006120:	00 00       	add	r0,r0
80006122:	0d 3c       	ld.ub	r12,r6++
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	57 52       	stdsp	sp[0x1d4],r2

80006128 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006128:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000612c:	78 38       	ld.w	r8,r12[0xc]
8000612e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006130:	ee c6 ff e8 	sub	r6,r7,-24
80006134:	0c 9c       	mov	r12,r6
80006136:	f0 1f 00 15 	mcall	80006188 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000613a:	49 58       	lddpc	r8,8000618c <xTaskRemoveFromEventList+0x64>
8000613c:	70 08       	ld.w	r8,r8[0x0]
8000613e:	58 08       	cp.w	r8,0
80006140:	c1 71       	brne	8000616e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006142:	ee c6 ff fc 	sub	r6,r7,-4
80006146:	0c 9c       	mov	r12,r6
80006148:	f0 1f 00 10 	mcall	80006188 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000614c:	6e bc       	ld.w	r12,r7[0x2c]
8000614e:	49 18       	lddpc	r8,80006190 <xTaskRemoveFromEventList+0x68>
80006150:	70 08       	ld.w	r8,r8[0x0]
80006152:	10 3c       	cp.w	r12,r8
80006154:	e0 88 00 04 	brls	8000615c <xTaskRemoveFromEventList+0x34>
80006158:	48 e8       	lddpc	r8,80006190 <xTaskRemoveFromEventList+0x68>
8000615a:	91 0c       	st.w	r8[0x0],r12
8000615c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006160:	0c 9b       	mov	r11,r6
80006162:	48 d8       	lddpc	r8,80006194 <xTaskRemoveFromEventList+0x6c>
80006164:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006168:	f0 1f 00 0c 	mcall	80006198 <xTaskRemoveFromEventList+0x70>
8000616c:	c0 58       	rjmp	80006176 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000616e:	0c 9b       	mov	r11,r6
80006170:	48 bc       	lddpc	r12,8000619c <xTaskRemoveFromEventList+0x74>
80006172:	f0 1f 00 0a 	mcall	80006198 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006176:	48 b8       	lddpc	r8,800061a0 <xTaskRemoveFromEventList+0x78>
80006178:	70 08       	ld.w	r8,r8[0x0]
8000617a:	6e b9       	ld.w	r9,r7[0x2c]
8000617c:	70 b8       	ld.w	r8,r8[0x2c]
8000617e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006180:	5f 2c       	srhs	r12
80006182:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006186:	00 00       	add	r0,r0
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	57 a2       	stdsp	sp[0x1e8],r2
8000618c:	00 00       	add	r0,r0
8000618e:	0d 04       	ld.w	r4,r6++
80006190:	00 00       	add	r0,r0
80006192:	0d 3c       	ld.ub	r12,r6++
80006194:	00 00       	add	r0,r0
80006196:	0c 20       	rsub	r0,r6
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	57 52       	stdsp	sp[0x1d4],r2
8000619c:	00 00       	add	r0,r0
8000619e:	0c d8       	st.w	--r6,r8
800061a0:	00 00       	add	r0,r0
800061a2:	0c d4       	st.w	--r6,r4

800061a4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800061a4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061a8:	4b 98       	lddpc	r8,8000628c <vTaskIncrementTick+0xe8>
800061aa:	70 08       	ld.w	r8,r8[0x0]
800061ac:	58 08       	cp.w	r8,0
800061ae:	c6 91       	brne	80006280 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800061b0:	4b 88       	lddpc	r8,80006290 <vTaskIncrementTick+0xec>
800061b2:	70 09       	ld.w	r9,r8[0x0]
800061b4:	2f f9       	sub	r9,-1
800061b6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800061b8:	70 08       	ld.w	r8,r8[0x0]
800061ba:	58 08       	cp.w	r8,0
800061bc:	c1 a1       	brne	800061f0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800061be:	4b 68       	lddpc	r8,80006294 <vTaskIncrementTick+0xf0>
800061c0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800061c2:	4b 69       	lddpc	r9,80006298 <vTaskIncrementTick+0xf4>
800061c4:	72 0b       	ld.w	r11,r9[0x0]
800061c6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800061c8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800061ca:	4b 59       	lddpc	r9,8000629c <vTaskIncrementTick+0xf8>
800061cc:	72 0a       	ld.w	r10,r9[0x0]
800061ce:	2f fa       	sub	r10,-1
800061d0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800061d2:	70 08       	ld.w	r8,r8[0x0]
800061d4:	70 08       	ld.w	r8,r8[0x0]
800061d6:	58 08       	cp.w	r8,0
800061d8:	c0 51       	brne	800061e2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800061da:	3f f9       	mov	r9,-1
800061dc:	4b 18       	lddpc	r8,800062a0 <vTaskIncrementTick+0xfc>
800061de:	91 09       	st.w	r8[0x0],r9
800061e0:	c0 88       	rjmp	800061f0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800061e2:	4a d8       	lddpc	r8,80006294 <vTaskIncrementTick+0xf0>
800061e4:	70 08       	ld.w	r8,r8[0x0]
800061e6:	70 38       	ld.w	r8,r8[0xc]
800061e8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800061ea:	70 19       	ld.w	r9,r8[0x4]
800061ec:	4a d8       	lddpc	r8,800062a0 <vTaskIncrementTick+0xfc>
800061ee:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800061f0:	4a 88       	lddpc	r8,80006290 <vTaskIncrementTick+0xec>
800061f2:	70 09       	ld.w	r9,r8[0x0]
800061f4:	4a b8       	lddpc	r8,800062a0 <vTaskIncrementTick+0xfc>
800061f6:	70 08       	ld.w	r8,r8[0x0]
800061f8:	10 39       	cp.w	r9,r8
800061fa:	c4 73       	brcs	80006288 <vTaskIncrementTick+0xe4>
800061fc:	4a 68       	lddpc	r8,80006294 <vTaskIncrementTick+0xf0>
800061fe:	70 08       	ld.w	r8,r8[0x0]
80006200:	70 08       	ld.w	r8,r8[0x0]
80006202:	58 08       	cp.w	r8,0
80006204:	c0 c0       	breq	8000621c <vTaskIncrementTick+0x78>
80006206:	4a 48       	lddpc	r8,80006294 <vTaskIncrementTick+0xf0>
80006208:	70 08       	ld.w	r8,r8[0x0]
8000620a:	70 38       	ld.w	r8,r8[0xc]
8000620c:	70 37       	ld.w	r7,r8[0xc]
8000620e:	6e 18       	ld.w	r8,r7[0x4]
80006210:	4a 09       	lddpc	r9,80006290 <vTaskIncrementTick+0xec>
80006212:	72 09       	ld.w	r9,r9[0x0]
80006214:	12 38       	cp.w	r8,r9
80006216:	e0 88 00 14 	brls	8000623e <vTaskIncrementTick+0x9a>
8000621a:	c0 e8       	rjmp	80006236 <vTaskIncrementTick+0x92>
8000621c:	3f f9       	mov	r9,-1
8000621e:	4a 18       	lddpc	r8,800062a0 <vTaskIncrementTick+0xfc>
80006220:	91 09       	st.w	r8[0x0],r9
80006222:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006226:	6a 08       	ld.w	r8,r5[0x0]
80006228:	70 38       	ld.w	r8,r8[0xc]
8000622a:	70 37       	ld.w	r7,r8[0xc]
8000622c:	6e 18       	ld.w	r8,r7[0x4]
8000622e:	64 09       	ld.w	r9,r2[0x0]
80006230:	12 38       	cp.w	r8,r9
80006232:	e0 88 00 0a 	brls	80006246 <vTaskIncrementTick+0xa2>
80006236:	49 b9       	lddpc	r9,800062a0 <vTaskIncrementTick+0xfc>
80006238:	93 08       	st.w	r9[0x0],r8
8000623a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000623e:	49 a4       	lddpc	r4,800062a4 <vTaskIncrementTick+0x100>
80006240:	49 a3       	lddpc	r3,800062a8 <vTaskIncrementTick+0x104>
80006242:	49 55       	lddpc	r5,80006294 <vTaskIncrementTick+0xf0>
80006244:	49 32       	lddpc	r2,80006290 <vTaskIncrementTick+0xec>
80006246:	ee c6 ff fc 	sub	r6,r7,-4
8000624a:	0c 9c       	mov	r12,r6
8000624c:	f0 1f 00 18 	mcall	800062ac <vTaskIncrementTick+0x108>
80006250:	6e a8       	ld.w	r8,r7[0x28]
80006252:	58 08       	cp.w	r8,0
80006254:	c0 50       	breq	8000625e <vTaskIncrementTick+0xba>
80006256:	ee cc ff e8 	sub	r12,r7,-24
8000625a:	f0 1f 00 15 	mcall	800062ac <vTaskIncrementTick+0x108>
8000625e:	6e bc       	ld.w	r12,r7[0x2c]
80006260:	68 08       	ld.w	r8,r4[0x0]
80006262:	10 3c       	cp.w	r12,r8
80006264:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006268:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000626c:	0c 9b       	mov	r11,r6
8000626e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006272:	f0 1f 00 10 	mcall	800062b0 <vTaskIncrementTick+0x10c>
80006276:	6a 08       	ld.w	r8,r5[0x0]
80006278:	70 08       	ld.w	r8,r8[0x0]
8000627a:	58 08       	cp.w	r8,0
8000627c:	cd 51       	brne	80006226 <vTaskIncrementTick+0x82>
8000627e:	cc fb       	rjmp	8000621c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006280:	48 d8       	lddpc	r8,800062b4 <vTaskIncrementTick+0x110>
80006282:	70 09       	ld.w	r9,r8[0x0]
80006284:	2f f9       	sub	r9,-1
80006286:	91 09       	st.w	r8[0x0],r9
80006288:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000628c:	00 00       	add	r0,r0
8000628e:	0d 04       	ld.w	r4,r6++
80006290:	00 00       	add	r0,r0
80006292:	0d 00       	ld.w	r0,r6++
80006294:	00 00       	add	r0,r0
80006296:	0c 0c       	add	r12,r6
80006298:	00 00       	add	r0,r0
8000629a:	0c 1c       	sub	r12,r6
8000629c:	00 00       	add	r0,r0
8000629e:	0c 18       	sub	r8,r6
800062a0:	00 00       	add	r0,r0
800062a2:	05 38       	ld.ub	r8,r2++
800062a4:	00 00       	add	r0,r0
800062a6:	0d 3c       	ld.ub	r12,r6++
800062a8:	00 00       	add	r0,r0
800062aa:	0c 20       	rsub	r0,r6
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	57 a2       	stdsp	sp[0x1e8],r2
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	57 52       	stdsp	sp[0x1d4],r2
800062b4:	00 00       	add	r0,r0
800062b6:	0c 04       	add	r4,r6

800062b8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800062b8:	eb cd 40 c0 	pushm	r6-r7,lr
800062bc:	18 97       	mov	r7,r12
800062be:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062c0:	f0 1f 00 15 	mcall	80006314 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800062c4:	6c 08       	ld.w	r8,r6[0x0]
800062c6:	5b f8       	cp.w	r8,-1
800062c8:	c0 31       	brne	800062ce <xTaskCheckForTimeOut+0x16>
800062ca:	30 07       	mov	r7,0
800062cc:	c1 f8       	rjmp	8000630a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062ce:	49 39       	lddpc	r9,80006318 <xTaskCheckForTimeOut+0x60>
800062d0:	72 09       	ld.w	r9,r9[0x0]
800062d2:	6e 0a       	ld.w	r10,r7[0x0]
800062d4:	12 3a       	cp.w	r10,r9
800062d6:	c0 70       	breq	800062e4 <xTaskCheckForTimeOut+0x2c>
800062d8:	49 19       	lddpc	r9,8000631c <xTaskCheckForTimeOut+0x64>
800062da:	72 09       	ld.w	r9,r9[0x0]
800062dc:	6e 1a       	ld.w	r10,r7[0x4]
800062de:	12 3a       	cp.w	r10,r9
800062e0:	e0 88 00 14 	brls	80006308 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800062e4:	48 e9       	lddpc	r9,8000631c <xTaskCheckForTimeOut+0x64>
800062e6:	72 0a       	ld.w	r10,r9[0x0]
800062e8:	6e 19       	ld.w	r9,r7[0x4]
800062ea:	12 1a       	sub	r10,r9
800062ec:	14 38       	cp.w	r8,r10
800062ee:	e0 88 00 0d 	brls	80006308 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800062f2:	48 ba       	lddpc	r10,8000631c <xTaskCheckForTimeOut+0x64>
800062f4:	74 0a       	ld.w	r10,r10[0x0]
800062f6:	14 19       	sub	r9,r10
800062f8:	f2 08 00 08 	add	r8,r9,r8
800062fc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800062fe:	0e 9c       	mov	r12,r7
80006300:	f0 1f 00 08 	mcall	80006320 <xTaskCheckForTimeOut+0x68>
80006304:	30 07       	mov	r7,0
80006306:	c0 28       	rjmp	8000630a <xTaskCheckForTimeOut+0x52>
80006308:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000630a:	f0 1f 00 07 	mcall	80006324 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000630e:	0e 9c       	mov	r12,r7
80006310:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	58 5c       	cp.w	r12,5
80006318:	00 00       	add	r0,r0
8000631a:	0c 18       	sub	r8,r6
8000631c:	00 00       	add	r0,r0
8000631e:	0d 00       	ld.w	r0,r6++
80006320:	80 00       	ld.sh	r0,r0[0x0]
80006322:	60 1c       	ld.w	r12,r0[0x4]
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	59 68       	cp.w	r8,22

80006328 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006328:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000632c:	f0 1f 00 05 	mcall	80006340 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006330:	48 58       	lddpc	r8,80006344 <xTaskGetTickCount+0x1c>
80006332:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006334:	f0 1f 00 05 	mcall	80006348 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006338:	0e 9c       	mov	r12,r7
8000633a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000633e:	00 00       	add	r0,r0
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	58 5c       	cp.w	r12,5
80006344:	00 00       	add	r0,r0
80006346:	0d 00       	ld.w	r0,r6++
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	59 68       	cp.w	r8,22

8000634c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000634c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006350:	f0 1f 00 2c 	mcall	80006400 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006354:	4a c8       	lddpc	r8,80006404 <xTaskResumeAll+0xb8>
80006356:	70 09       	ld.w	r9,r8[0x0]
80006358:	20 19       	sub	r9,1
8000635a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000635c:	70 08       	ld.w	r8,r8[0x0]
8000635e:	58 08       	cp.w	r8,0
80006360:	c4 91       	brne	800063f2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006362:	4a a8       	lddpc	r8,80006408 <xTaskResumeAll+0xbc>
80006364:	70 08       	ld.w	r8,r8[0x0]
80006366:	58 08       	cp.w	r8,0
80006368:	c4 50       	breq	800063f2 <xTaskResumeAll+0xa6>
8000636a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000636c:	4a 85       	lddpc	r5,8000640c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000636e:	4a 93       	lddpc	r3,80006410 <xTaskResumeAll+0xc4>
80006370:	4a 92       	lddpc	r2,80006414 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006372:	4a a1       	lddpc	r1,80006418 <xTaskResumeAll+0xcc>
80006374:	c1 e8       	rjmp	800063b0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006376:	6a 38       	ld.w	r8,r5[0xc]
80006378:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000637a:	ee cc ff e8 	sub	r12,r7,-24
8000637e:	f0 1f 00 28 	mcall	8000641c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006382:	ee c6 ff fc 	sub	r6,r7,-4
80006386:	0c 9c       	mov	r12,r6
80006388:	f0 1f 00 25 	mcall	8000641c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000638c:	6e bc       	ld.w	r12,r7[0x2c]
8000638e:	66 08       	ld.w	r8,r3[0x0]
80006390:	10 3c       	cp.w	r12,r8
80006392:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006396:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000639a:	0c 9b       	mov	r11,r6
8000639c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800063a0:	f0 1f 00 20 	mcall	80006420 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063a4:	62 08       	ld.w	r8,r1[0x0]
800063a6:	6e b9       	ld.w	r9,r7[0x2c]
800063a8:	70 b8       	ld.w	r8,r8[0x2c]
800063aa:	10 39       	cp.w	r9,r8
800063ac:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800063b0:	6a 08       	ld.w	r8,r5[0x0]
800063b2:	58 08       	cp.w	r8,0
800063b4:	ce 11       	brne	80006376 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063b6:	49 c8       	lddpc	r8,80006424 <xTaskResumeAll+0xd8>
800063b8:	70 08       	ld.w	r8,r8[0x0]
800063ba:	58 08       	cp.w	r8,0
800063bc:	c0 f0       	breq	800063da <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063be:	49 a8       	lddpc	r8,80006424 <xTaskResumeAll+0xd8>
800063c0:	70 08       	ld.w	r8,r8[0x0]
800063c2:	58 08       	cp.w	r8,0
800063c4:	c1 10       	breq	800063e6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800063c6:	49 87       	lddpc	r7,80006424 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800063c8:	f0 1f 00 18 	mcall	80006428 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800063cc:	6e 08       	ld.w	r8,r7[0x0]
800063ce:	20 18       	sub	r8,1
800063d0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063d2:	6e 08       	ld.w	r8,r7[0x0]
800063d4:	58 08       	cp.w	r8,0
800063d6:	cf 91       	brne	800063c8 <xTaskResumeAll+0x7c>
800063d8:	c0 78       	rjmp	800063e6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800063da:	58 14       	cp.w	r4,1
800063dc:	c0 50       	breq	800063e6 <xTaskResumeAll+0x9a>
800063de:	49 48       	lddpc	r8,8000642c <xTaskResumeAll+0xe0>
800063e0:	70 08       	ld.w	r8,r8[0x0]
800063e2:	58 18       	cp.w	r8,1
800063e4:	c0 71       	brne	800063f2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800063e6:	30 09       	mov	r9,0
800063e8:	49 18       	lddpc	r8,8000642c <xTaskResumeAll+0xe0>
800063ea:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800063ec:	d7 33       	scall
800063ee:	30 17       	mov	r7,1
800063f0:	c0 28       	rjmp	800063f4 <xTaskResumeAll+0xa8>
800063f2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800063f4:	f0 1f 00 0f 	mcall	80006430 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800063f8:	0e 9c       	mov	r12,r7
800063fa:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800063fe:	00 00       	add	r0,r0
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	58 5c       	cp.w	r12,5
80006404:	00 00       	add	r0,r0
80006406:	0d 04       	ld.w	r4,r6++
80006408:	00 00       	add	r0,r0
8000640a:	0d 20       	ld.uh	r0,r6++
8000640c:	00 00       	add	r0,r0
8000640e:	0c d8       	st.w	--r6,r8
80006410:	00 00       	add	r0,r0
80006412:	0d 3c       	ld.ub	r12,r6++
80006414:	00 00       	add	r0,r0
80006416:	0c 20       	rsub	r0,r6
80006418:	00 00       	add	r0,r0
8000641a:	0c d4       	st.w	--r6,r4
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	57 a2       	stdsp	sp[0x1e8],r2
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	57 52       	stdsp	sp[0x1d4],r2
80006424:	00 00       	add	r0,r0
80006426:	0c 04       	add	r4,r6
80006428:	80 00       	ld.sh	r0,r0[0x0]
8000642a:	61 a4       	ld.w	r4,r0[0x68]
8000642c:	00 00       	add	r0,r0
8000642e:	0d 24       	ld.uh	r4,r6++
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	59 68       	cp.w	r8,22

80006434 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006434:	eb cd 40 80 	pushm	r7,lr
80006438:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000643a:	49 08       	lddpc	r8,80006478 <prvAddCurrentTaskToDelayedList+0x44>
8000643c:	70 08       	ld.w	r8,r8[0x0]
8000643e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006440:	48 f8       	lddpc	r8,8000647c <prvAddCurrentTaskToDelayedList+0x48>
80006442:	70 08       	ld.w	r8,r8[0x0]
80006444:	10 3c       	cp.w	r12,r8
80006446:	c0 a2       	brcc	8000645a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006448:	48 c8       	lddpc	r8,80006478 <prvAddCurrentTaskToDelayedList+0x44>
8000644a:	70 0b       	ld.w	r11,r8[0x0]
8000644c:	48 d8       	lddpc	r8,80006480 <prvAddCurrentTaskToDelayedList+0x4c>
8000644e:	70 0c       	ld.w	r12,r8[0x0]
80006450:	2f cb       	sub	r11,-4
80006452:	f0 1f 00 0d 	mcall	80006484 <prvAddCurrentTaskToDelayedList+0x50>
80006456:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000645a:	48 88       	lddpc	r8,80006478 <prvAddCurrentTaskToDelayedList+0x44>
8000645c:	70 0b       	ld.w	r11,r8[0x0]
8000645e:	48 b8       	lddpc	r8,80006488 <prvAddCurrentTaskToDelayedList+0x54>
80006460:	70 0c       	ld.w	r12,r8[0x0]
80006462:	2f cb       	sub	r11,-4
80006464:	f0 1f 00 08 	mcall	80006484 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006468:	48 98       	lddpc	r8,8000648c <prvAddCurrentTaskToDelayedList+0x58>
8000646a:	70 08       	ld.w	r8,r8[0x0]
8000646c:	10 37       	cp.w	r7,r8
8000646e:	c0 32       	brcc	80006474 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006470:	48 78       	lddpc	r8,8000648c <prvAddCurrentTaskToDelayedList+0x58>
80006472:	91 07       	st.w	r8[0x0],r7
80006474:	e3 cd 80 80 	ldm	sp++,r7,pc
80006478:	00 00       	add	r0,r0
8000647a:	0c d4       	st.w	--r6,r4
8000647c:	00 00       	add	r0,r0
8000647e:	0d 00       	ld.w	r0,r6++
80006480:	00 00       	add	r0,r0
80006482:	0c 1c       	sub	r12,r6
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	57 6e       	stdsp	sp[0x1d8],lr
80006488:	00 00       	add	r0,r0
8000648a:	0c 0c       	add	r12,r6
8000648c:	00 00       	add	r0,r0
8000648e:	05 38       	ld.ub	r8,r2++

80006490 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006490:	eb cd 40 c0 	pushm	r6-r7,lr
80006494:	18 96       	mov	r6,r12
80006496:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006498:	f0 1f 00 18 	mcall	800064f8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000649c:	6c 08       	ld.w	r8,r6[0x0]
8000649e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800064a0:	49 79       	lddpc	r9,800064fc <vTaskDelayUntil+0x6c>
800064a2:	72 09       	ld.w	r9,r9[0x0]
800064a4:	12 38       	cp.w	r8,r9
800064a6:	e0 88 00 0c 	brls	800064be <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800064aa:	0e 38       	cp.w	r8,r7
800064ac:	e0 88 00 22 	brls	800064f0 <vTaskDelayUntil+0x60>
800064b0:	49 38       	lddpc	r8,800064fc <vTaskDelayUntil+0x6c>
800064b2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800064b4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800064b6:	10 37       	cp.w	r7,r8
800064b8:	e0 88 00 14 	brls	800064e0 <vTaskDelayUntil+0x50>
800064bc:	c0 a8       	rjmp	800064d0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800064be:	0e 38       	cp.w	r8,r7
800064c0:	e0 8b 00 16 	brhi	800064ec <vTaskDelayUntil+0x5c>
800064c4:	48 e8       	lddpc	r8,800064fc <vTaskDelayUntil+0x6c>
800064c6:	70 08       	ld.w	r8,r8[0x0]
800064c8:	10 37       	cp.w	r7,r8
800064ca:	e0 8b 00 11 	brhi	800064ec <vTaskDelayUntil+0x5c>
800064ce:	c1 18       	rjmp	800064f0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064d0:	48 c8       	lddpc	r8,80006500 <vTaskDelayUntil+0x70>
800064d2:	70 0c       	ld.w	r12,r8[0x0]
800064d4:	2f cc       	sub	r12,-4
800064d6:	f0 1f 00 0c 	mcall	80006504 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800064da:	0e 9c       	mov	r12,r7
800064dc:	f0 1f 00 0b 	mcall	80006508 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800064e0:	f0 1f 00 0b 	mcall	8000650c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800064e4:	c0 81       	brne	800064f4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800064e6:	d7 33       	scall
800064e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800064ec:	8d 07       	st.w	r6[0x0],r7
800064ee:	cf 1b       	rjmp	800064d0 <vTaskDelayUntil+0x40>
800064f0:	8d 07       	st.w	r6[0x0],r7
800064f2:	cf 7b       	rjmp	800064e0 <vTaskDelayUntil+0x50>
800064f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	5f 90       	srgt	r0
800064fc:	00 00       	add	r0,r0
800064fe:	0d 00       	ld.w	r0,r6++
80006500:	00 00       	add	r0,r0
80006502:	0c d4       	st.w	--r6,r4
80006504:	80 00       	ld.sh	r0,r0[0x0]
80006506:	57 a2       	stdsp	sp[0x1e8],r2
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	64 34       	ld.w	r4,r2[0xc]
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	63 4c       	ld.w	r12,r1[0x50]

80006510 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006510:	eb cd 40 c0 	pushm	r6-r7,lr
80006514:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006516:	48 e7       	lddpc	r7,8000654c <vTaskPlaceOnEventList+0x3c>
80006518:	6e 0b       	ld.w	r11,r7[0x0]
8000651a:	2e 8b       	sub	r11,-24
8000651c:	f0 1f 00 0d 	mcall	80006550 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006520:	6e 0c       	ld.w	r12,r7[0x0]
80006522:	2f cc       	sub	r12,-4
80006524:	f0 1f 00 0c 	mcall	80006554 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006528:	5b f6       	cp.w	r6,-1
8000652a:	c0 81       	brne	8000653a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000652c:	6e 0b       	ld.w	r11,r7[0x0]
8000652e:	2f cb       	sub	r11,-4
80006530:	48 ac       	lddpc	r12,80006558 <vTaskPlaceOnEventList+0x48>
80006532:	f0 1f 00 0b 	mcall	8000655c <vTaskPlaceOnEventList+0x4c>
80006536:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000653a:	48 a8       	lddpc	r8,80006560 <vTaskPlaceOnEventList+0x50>
8000653c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000653e:	ec 0c 00 0c 	add	r12,r6,r12
80006542:	f0 1f 00 09 	mcall	80006564 <vTaskPlaceOnEventList+0x54>
80006546:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000654a:	00 00       	add	r0,r0
8000654c:	00 00       	add	r0,r0
8000654e:	0c d4       	st.w	--r6,r4
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	57 6e       	stdsp	sp[0x1d8],lr
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	57 a2       	stdsp	sp[0x1e8],r2
80006558:	00 00       	add	r0,r0
8000655a:	0d 28       	ld.uh	r8,r6++
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	57 52       	stdsp	sp[0x1d4],r2
80006560:	00 00       	add	r0,r0
80006562:	0d 00       	ld.w	r0,r6++
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	64 34       	ld.w	r4,r2[0xc]

80006568 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006568:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000656c:	49 67       	lddpc	r7,800065c4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000656e:	49 74       	lddpc	r4,800065c8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006570:	49 73       	lddpc	r3,800065cc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006572:	49 85       	lddpc	r5,800065d0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006574:	6e 08       	ld.w	r8,r7[0x0]
80006576:	58 08       	cp.w	r8,0
80006578:	c1 e0       	breq	800065b4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000657a:	f0 1f 00 17 	mcall	800065d4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000657e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006580:	f0 1f 00 16 	mcall	800065d8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006584:	58 06       	cp.w	r6,0
80006586:	c1 70       	breq	800065b4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006588:	f0 1f 00 15 	mcall	800065dc <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000658c:	68 38       	ld.w	r8,r4[0xc]
8000658e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006590:	ec cc ff fc 	sub	r12,r6,-4
80006594:	f0 1f 00 13 	mcall	800065e0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006598:	66 08       	ld.w	r8,r3[0x0]
8000659a:	20 18       	sub	r8,1
8000659c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000659e:	6e 08       	ld.w	r8,r7[0x0]
800065a0:	20 18       	sub	r8,1
800065a2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800065a4:	f0 1f 00 10 	mcall	800065e4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800065a8:	6c cc       	ld.w	r12,r6[0x30]
800065aa:	f0 1f 00 10 	mcall	800065e8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800065ae:	0c 9c       	mov	r12,r6
800065b0:	f0 1f 00 0e 	mcall	800065e8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065b4:	6a 08       	ld.w	r8,r5[0x0]
800065b6:	58 18       	cp.w	r8,1
800065b8:	e0 88 00 03 	brls	800065be <prvIdleTask+0x56>
			{
				taskYIELD();
800065bc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800065be:	f0 1f 00 0c 	mcall	800065ec <prvIdleTask+0x84>
		}
		#endif
	}
800065c2:	cd 9b       	rjmp	80006574 <prvIdleTask+0xc>
800065c4:	00 00       	add	r0,r0
800065c6:	0c 14       	sub	r4,r6
800065c8:	00 00       	add	r0,r0
800065ca:	0c c0       	st.b	r6++,r0
800065cc:	00 00       	add	r0,r0
800065ce:	0d 20       	ld.uh	r0,r6++
800065d0:	00 00       	add	r0,r0
800065d2:	0c 20       	rsub	r0,r6
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	5f 90       	srgt	r0
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	63 4c       	ld.w	r12,r1[0x50]
800065dc:	80 00       	ld.sh	r0,r0[0x0]
800065de:	58 5c       	cp.w	r12,5
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	57 a2       	stdsp	sp[0x1e8],r2
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	59 68       	cp.w	r8,22
800065e8:	80 00       	ld.sh	r0,r0[0x0]
800065ea:	5a a0       	cp.w	r0,-22
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	20 30       	sub	r0,3

800065f0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800065f0:	d4 31       	pushm	r0-r7,lr
800065f2:	20 1d       	sub	sp,4
800065f4:	fa c4 ff d8 	sub	r4,sp,-40
800065f8:	50 0c       	stdsp	sp[0x0],r12
800065fa:	16 91       	mov	r1,r11
800065fc:	14 97       	mov	r7,r10
800065fe:	12 90       	mov	r0,r9
80006600:	10 93       	mov	r3,r8
80006602:	68 02       	ld.w	r2,r4[0x0]
80006604:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006606:	34 8c       	mov	r12,72
80006608:	f0 1f 00 5c 	mcall	80006778 <xTaskGenericCreate+0x188>
8000660c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000660e:	c0 31       	brne	80006614 <xTaskGenericCreate+0x24>
80006610:	3f fc       	mov	r12,-1
80006612:	ca f8       	rjmp	80006770 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006614:	58 06       	cp.w	r6,0
80006616:	e0 81 00 af 	brne	80006774 <xTaskGenericCreate+0x184>
8000661a:	0e 9c       	mov	r12,r7
8000661c:	5c 7c       	castu.h	r12
8000661e:	a3 6c       	lsl	r12,0x2
80006620:	f0 1f 00 56 	mcall	80006778 <xTaskGenericCreate+0x188>
80006624:	18 96       	mov	r6,r12
80006626:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006628:	c0 61       	brne	80006634 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000662a:	0a 9c       	mov	r12,r5
8000662c:	f0 1f 00 54 	mcall	8000677c <xTaskGenericCreate+0x18c>
80006630:	3f fc       	mov	r12,-1
80006632:	c9 f8       	rjmp	80006770 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006634:	5c 77       	castu.h	r7
80006636:	ee 0a 15 02 	lsl	r10,r7,0x2
8000663a:	e0 6b 00 a5 	mov	r11,165
8000663e:	0c 9c       	mov	r12,r6
80006640:	f0 1f 00 50 	mcall	80006780 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006644:	ee c6 00 01 	sub	r6,r7,1
80006648:	6a c8       	ld.w	r8,r5[0x30]
8000664a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000664e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006652:	31 0a       	mov	r10,16
80006654:	02 9b       	mov	r11,r1
80006656:	ea cc ff cc 	sub	r12,r5,-52
8000665a:	f0 1f 00 4b 	mcall	80006784 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000665e:	30 08       	mov	r8,0
80006660:	eb 68 00 43 	st.b	r5[67],r8
80006664:	58 73       	cp.w	r3,7
80006666:	e6 07 17 80 	movls	r7,r3
8000666a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000666e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006670:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006674:	ea c4 ff fc 	sub	r4,r5,-4
80006678:	08 9c       	mov	r12,r4
8000667a:	f0 1f 00 44 	mcall	80006788 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000667e:	ea cc ff e8 	sub	r12,r5,-24
80006682:	f0 1f 00 42 	mcall	80006788 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006686:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006688:	ee 07 11 08 	rsub	r7,r7,8
8000668c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000668e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006690:	00 9a       	mov	r10,r0
80006692:	40 0b       	lddsp	r11,sp[0x0]
80006694:	0c 9c       	mov	r12,r6
80006696:	f0 1f 00 3e 	mcall	8000678c <xTaskGenericCreate+0x19c>
8000669a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000669c:	58 02       	cp.w	r2,0
8000669e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800066a2:	f0 1f 00 3c 	mcall	80006790 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800066a6:	4b c8       	lddpc	r8,80006794 <xTaskGenericCreate+0x1a4>
800066a8:	70 09       	ld.w	r9,r8[0x0]
800066aa:	2f f9       	sub	r9,-1
800066ac:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800066ae:	4b b8       	lddpc	r8,80006798 <xTaskGenericCreate+0x1a8>
800066b0:	70 08       	ld.w	r8,r8[0x0]
800066b2:	58 08       	cp.w	r8,0
800066b4:	c2 61       	brne	80006700 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800066b6:	4b 98       	lddpc	r8,80006798 <xTaskGenericCreate+0x1a8>
800066b8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800066ba:	4b 78       	lddpc	r8,80006794 <xTaskGenericCreate+0x1a4>
800066bc:	70 08       	ld.w	r8,r8[0x0]
800066be:	58 18       	cp.w	r8,1
800066c0:	c2 b1       	brne	80006716 <xTaskGenericCreate+0x126>
800066c2:	4b 77       	lddpc	r7,8000679c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800066c4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800066c8:	0e 9c       	mov	r12,r7
800066ca:	f0 1f 00 36 	mcall	800067a0 <xTaskGenericCreate+0x1b0>
800066ce:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800066d0:	0c 37       	cp.w	r7,r6
800066d2:	cf b1       	brne	800066c8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800066d4:	4b 47       	lddpc	r7,800067a4 <xTaskGenericCreate+0x1b4>
800066d6:	0e 9c       	mov	r12,r7
800066d8:	f0 1f 00 32 	mcall	800067a0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800066dc:	4b 36       	lddpc	r6,800067a8 <xTaskGenericCreate+0x1b8>
800066de:	0c 9c       	mov	r12,r6
800066e0:	f0 1f 00 30 	mcall	800067a0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800066e4:	4b 2c       	lddpc	r12,800067ac <xTaskGenericCreate+0x1bc>
800066e6:	f0 1f 00 2f 	mcall	800067a0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800066ea:	4b 2c       	lddpc	r12,800067b0 <xTaskGenericCreate+0x1c0>
800066ec:	f0 1f 00 2d 	mcall	800067a0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800066f0:	4b 1c       	lddpc	r12,800067b4 <xTaskGenericCreate+0x1c4>
800066f2:	f0 1f 00 2c 	mcall	800067a0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800066f6:	4b 18       	lddpc	r8,800067b8 <xTaskGenericCreate+0x1c8>
800066f8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800066fa:	4b 18       	lddpc	r8,800067bc <xTaskGenericCreate+0x1cc>
800066fc:	91 06       	st.w	r8[0x0],r6
800066fe:	c0 c8       	rjmp	80006716 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006700:	4b 08       	lddpc	r8,800067c0 <xTaskGenericCreate+0x1d0>
80006702:	70 08       	ld.w	r8,r8[0x0]
80006704:	58 08       	cp.w	r8,0
80006706:	c0 81       	brne	80006716 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006708:	4a 48       	lddpc	r8,80006798 <xTaskGenericCreate+0x1a8>
8000670a:	70 08       	ld.w	r8,r8[0x0]
8000670c:	70 b8       	ld.w	r8,r8[0x2c]
8000670e:	10 33       	cp.w	r3,r8
80006710:	c0 33       	brcs	80006716 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006712:	4a 28       	lddpc	r8,80006798 <xTaskGenericCreate+0x1a8>
80006714:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006716:	6a b8       	ld.w	r8,r5[0x2c]
80006718:	4a b9       	lddpc	r9,800067c4 <xTaskGenericCreate+0x1d4>
8000671a:	72 09       	ld.w	r9,r9[0x0]
8000671c:	12 38       	cp.w	r8,r9
8000671e:	e0 88 00 04 	brls	80006726 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006722:	4a 99       	lddpc	r9,800067c4 <xTaskGenericCreate+0x1d4>
80006724:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006726:	4a 98       	lddpc	r8,800067c8 <xTaskGenericCreate+0x1d8>
80006728:	70 09       	ld.w	r9,r8[0x0]
8000672a:	2f f9       	sub	r9,-1
8000672c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000672e:	6a b8       	ld.w	r8,r5[0x2c]
80006730:	4a 79       	lddpc	r9,800067cc <xTaskGenericCreate+0x1dc>
80006732:	72 09       	ld.w	r9,r9[0x0]
80006734:	12 38       	cp.w	r8,r9
80006736:	e0 88 00 04 	brls	8000673e <xTaskGenericCreate+0x14e>
8000673a:	4a 59       	lddpc	r9,800067cc <xTaskGenericCreate+0x1dc>
8000673c:	93 08       	st.w	r9[0x0],r8
8000673e:	6a bc       	ld.w	r12,r5[0x2c]
80006740:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006744:	08 9b       	mov	r11,r4
80006746:	49 68       	lddpc	r8,8000679c <xTaskGenericCreate+0x1ac>
80006748:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000674c:	f0 1f 00 21 	mcall	800067d0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006750:	f0 1f 00 21 	mcall	800067d4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006754:	49 b8       	lddpc	r8,800067c0 <xTaskGenericCreate+0x1d0>
80006756:	70 08       	ld.w	r8,r8[0x0]
80006758:	58 08       	cp.w	r8,0
8000675a:	c0 a0       	breq	8000676e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000675c:	48 f8       	lddpc	r8,80006798 <xTaskGenericCreate+0x1a8>
8000675e:	70 08       	ld.w	r8,r8[0x0]
80006760:	70 b8       	ld.w	r8,r8[0x2c]
80006762:	10 33       	cp.w	r3,r8
80006764:	e0 88 00 05 	brls	8000676e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006768:	d7 33       	scall
8000676a:	30 1c       	mov	r12,1
8000676c:	c0 28       	rjmp	80006770 <xTaskGenericCreate+0x180>
8000676e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006770:	2f fd       	sub	sp,-4
80006772:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006774:	99 c6       	st.w	r12[0x30],r6
80006776:	c5 fb       	rjmp	80006634 <xTaskGenericCreate+0x44>
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	5a c8       	cp.w	r8,-20
8000677c:	80 00       	ld.sh	r0,r0[0x0]
8000677e:	5a a0       	cp.w	r0,-22
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	74 b6       	ld.w	r6,r10[0x2c]
80006784:	80 00       	ld.sh	r0,r0[0x0]
80006786:	77 f8       	ld.w	r8,r11[0x7c]
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	57 4c       	stdsp	sp[0x1d0],r12
8000678c:	80 00       	ld.sh	r0,r0[0x0]
8000678e:	57 c8       	stdsp	sp[0x1f0],r8
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	58 5c       	cp.w	r12,5
80006794:	00 00       	add	r0,r0
80006796:	0d 20       	ld.uh	r0,r6++
80006798:	00 00       	add	r0,r0
8000679a:	0c d4       	st.w	--r6,r4
8000679c:	00 00       	add	r0,r0
8000679e:	0c 20       	rsub	r0,r6
800067a0:	80 00       	ld.sh	r0,r0[0x0]
800067a2:	57 38       	stdsp	sp[0x1cc],r8
800067a4:	00 00       	add	r0,r0
800067a6:	0c ec       	st.h	--r6,r12
800067a8:	00 00       	add	r0,r0
800067aa:	0d 08       	ld.w	r8,r6++
800067ac:	00 00       	add	r0,r0
800067ae:	0c d8       	st.w	--r6,r8
800067b0:	00 00       	add	r0,r0
800067b2:	0c c0       	st.b	r6++,r0
800067b4:	00 00       	add	r0,r0
800067b6:	0d 28       	ld.uh	r8,r6++
800067b8:	00 00       	add	r0,r0
800067ba:	0c 0c       	add	r12,r6
800067bc:	00 00       	add	r0,r0
800067be:	0c 1c       	sub	r12,r6
800067c0:	00 00       	add	r0,r0
800067c2:	0c 10       	sub	r0,r6
800067c4:	00 00       	add	r0,r0
800067c6:	0c 08       	add	r8,r6
800067c8:	00 00       	add	r0,r0
800067ca:	0d 1c       	ld.sh	r12,r6++
800067cc:	00 00       	add	r0,r0
800067ce:	0d 3c       	ld.ub	r12,r6++
800067d0:	80 00       	ld.sh	r0,r0[0x0]
800067d2:	57 52       	stdsp	sp[0x1d4],r2
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	59 68       	cp.w	r8,22

800067d8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800067d8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800067da:	30 09       	mov	r9,0
800067dc:	1a d9       	st.w	--sp,r9
800067de:	1a d9       	st.w	--sp,r9
800067e0:	1a d9       	st.w	--sp,r9
800067e2:	12 98       	mov	r8,r9
800067e4:	e0 6a 01 00 	mov	r10,256
800067e8:	48 9b       	lddpc	r11,8000680c <vTaskStartScheduler+0x34>
800067ea:	48 ac       	lddpc	r12,80006810 <vTaskStartScheduler+0x38>
800067ec:	f0 1f 00 0a 	mcall	80006814 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800067f0:	2f dd       	sub	sp,-12
800067f2:	58 1c       	cp.w	r12,1
800067f4:	c0 a1       	brne	80006808 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800067f6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800067f8:	30 19       	mov	r9,1
800067fa:	48 88       	lddpc	r8,80006818 <vTaskStartScheduler+0x40>
800067fc:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800067fe:	30 09       	mov	r9,0
80006800:	48 78       	lddpc	r8,8000681c <vTaskStartScheduler+0x44>
80006802:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006804:	f0 1f 00 07 	mcall	80006820 <vTaskStartScheduler+0x48>
80006808:	d8 02       	popm	pc
8000680a:	00 00       	add	r0,r0
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	d3 4c       	*unknown*
80006810:	80 00       	ld.sh	r0,r0[0x0]
80006812:	65 68       	ld.w	r8,r2[0x58]
80006814:	80 00       	ld.sh	r0,r0[0x0]
80006816:	65 f0       	ld.w	r0,r2[0x7c]
80006818:	00 00       	add	r0,r0
8000681a:	0c 10       	sub	r0,r6
8000681c:	00 00       	add	r0,r0
8000681e:	0d 00       	ld.w	r0,r6++
80006820:	80 00       	ld.sh	r0,r0[0x0]
80006822:	58 6c       	cp.w	r12,6

80006824 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006824:	16 cc       	st.b	r11++,r12
	return str;
}
80006826:	5e fb       	retal	r11

80006828 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006828:	eb cd 40 c0 	pushm	r6-r7,lr
8000682c:	20 3d       	sub	sp,12
8000682e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006830:	30 06       	mov	r6,0
80006832:	30 07       	mov	r7,0
80006834:	fa e7 00 00 	st.d	sp[0],r6
80006838:	30 0c       	mov	r12,0
8000683a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000683c:	58 08       	cp.w	r8,0
8000683e:	c1 30       	breq	80006864 <PrintHex+0x3c>
80006840:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006842:	1a 9c       	mov	r12,sp
80006844:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006848:	58 9e       	cp.w	lr,9
8000684a:	e0 8a 00 04 	brle	80006852 <PrintHex+0x2a>
8000684e:	2c 9e       	sub	lr,-55
80006850:	c0 48       	rjmp	80006858 <PrintHex+0x30>
80006852:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006856:	2d 0e       	sub	lr,-48
80006858:	f8 09 0b 0e 	st.b	r12[r9],lr
8000685c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000685e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006860:	cf 21       	brne	80006844 <PrintHex+0x1c>
80006862:	c0 48       	rjmp	8000686a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006864:	33 08       	mov	r8,48
80006866:	ba 88       	st.b	sp[0x0],r8
80006868:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000686a:	f6 09 01 08 	sub	r8,r11,r9
8000686e:	58 08       	cp.w	r8,0
80006870:	e0 8a 00 13 	brle	80006896 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006874:	12 1b       	sub	r11,r9
80006876:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000687a:	18 9e       	mov	lr,r12
8000687c:	58 0c       	cp.w	r12,0
8000687e:	e0 8a 00 0c 	brle	80006896 <PrintHex+0x6e>
80006882:	1a 9b       	mov	r11,sp
80006884:	12 0b       	add	r11,r9
80006886:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006888:	33 07       	mov	r7,48
8000688a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000688c:	2f f8       	sub	r8,-1
8000688e:	1c 38       	cp.w	r8,lr
80006890:	cf d5       	brlt	8000688a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006892:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006896:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000689a:	f0 cb ff ff 	sub	r11,r8,-1
8000689e:	58 0b       	cp.w	r11,0
800068a0:	e0 8a 00 19 	brle	800068d2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800068a4:	fa cb ff f4 	sub	r11,sp,-12
800068a8:	f6 09 00 09 	add	r9,r11,r9
800068ac:	37 8b       	mov	r11,120
800068ae:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800068b2:	fa c9 ff f4 	sub	r9,sp,-12
800068b6:	10 09       	add	r9,r8
800068b8:	33 0b       	mov	r11,48
800068ba:	f3 6b ff f4 	st.b	r9[-12],r11
800068be:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068c2:	fa ce 00 01 	sub	lr,sp,1
800068c6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800068c8:	11 8b       	ld.ub	r11,r8[0x0]
800068ca:	12 cb       	st.b	r9++,r11
800068cc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800068ce:	1c 38       	cp.w	r8,lr
800068d0:	cf c1       	brne	800068c8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800068d2:	14 9c       	mov	r12,r10
800068d4:	2f dd       	sub	sp,-12
800068d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800068da <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800068da:	d4 21       	pushm	r4-r7,lr
800068dc:	20 3d       	sub	sp,12
800068de:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800068e0:	30 06       	mov	r6,0
800068e2:	30 07       	mov	r7,0
800068e4:	fa e7 00 00 	st.d	sp[0],r6
800068e8:	30 0c       	mov	r12,0
800068ea:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800068ec:	58 08       	cp.w	r8,0
800068ee:	c0 35       	brlt	800068f4 <PrintDec+0x1a>
800068f0:	14 97       	mov	r7,r10
800068f2:	c0 58       	rjmp	800068fc <PrintDec+0x22>
	{
		*p++ = '-';
800068f4:	14 97       	mov	r7,r10
800068f6:	32 d9       	mov	r9,45
800068f8:	0e c9       	st.b	r7++,r9
		i = -i;
800068fa:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800068fc:	58 08       	cp.w	r8,0
800068fe:	c0 51       	brne	80006908 <PrintDec+0x2e>
80006900:	33 08       	mov	r8,48
80006902:	ba 88       	st.b	sp[0x0],r8
80006904:	30 1e       	mov	lr,1
80006906:	c2 f8       	rjmp	80006964 <PrintDec+0x8a>
	
	int ten = i%10;
80006908:	e0 65 66 67 	mov	r5,26215
8000690c:	ea 15 66 66 	orh	r5,0x6666
80006910:	f0 05 04 44 	muls.d	r4,r8,r5
80006914:	ea 0c 14 02 	asr	r12,r5,0x2
80006918:	f0 09 14 1f 	asr	r9,r8,0x1f
8000691c:	f8 09 01 09 	sub	r9,r12,r9
80006920:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006924:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006928:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000692a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000692c:	e0 66 66 67 	mov	r6,26215
80006930:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006934:	2d 09       	sub	r9,-48
80006936:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000693a:	2f fe       	sub	lr,-1
		i /= 10;
8000693c:	f0 06 04 44 	muls.d	r4,r8,r6
80006940:	ea 09 14 02 	asr	r9,r5,0x2
80006944:	bf 58       	asr	r8,0x1f
80006946:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000694a:	f0 06 04 44 	muls.d	r4,r8,r6
8000694e:	ea 09 14 02 	asr	r9,r5,0x2
80006952:	f0 05 14 1f 	asr	r5,r8,0x1f
80006956:	0a 19       	sub	r9,r5
80006958:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000695c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006960:	58 08       	cp.w	r8,0
80006962:	ce 91       	brne	80006934 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006964:	f6 0e 01 08 	sub	r8,r11,lr
80006968:	58 08       	cp.w	r8,0
8000696a:	e0 89 00 06 	brgt	80006976 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000696e:	58 0e       	cp.w	lr,0
80006970:	e0 89 00 14 	brgt	80006998 <PrintDec+0xbe>
80006974:	c1 d8       	rjmp	800069ae <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006976:	1c 1b       	sub	r11,lr
80006978:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000697a:	16 9c       	mov	r12,r11
8000697c:	58 0b       	cp.w	r11,0
8000697e:	fe 9a ff f8 	brle	8000696e <PrintDec+0x94>
80006982:	1a 99       	mov	r9,sp
80006984:	1c 09       	add	r9,lr
80006986:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006988:	33 06       	mov	r6,48
8000698a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000698c:	2f f8       	sub	r8,-1
8000698e:	18 38       	cp.w	r8,r12
80006990:	cf d5       	brlt	8000698a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006992:	f6 0e 00 0e 	add	lr,r11,lr
80006996:	ce cb       	rjmp	8000696e <PrintDec+0x94>
80006998:	fa c8 ff f4 	sub	r8,sp,-12
8000699c:	1c 08       	add	r8,lr
8000699e:	20 d8       	sub	r8,13
800069a0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800069a4:	11 89       	ld.ub	r9,r8[0x0]
800069a6:	0e c9       	st.b	r7++,r9
800069a8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800069aa:	16 38       	cp.w	r8,r11
800069ac:	cf c1       	brne	800069a4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800069ae:	14 9c       	mov	r12,r10
800069b0:	2f dd       	sub	sp,-12
800069b2:	d8 22       	popm	r4-r7,pc

800069b4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800069b4:	d4 31       	pushm	r0-r7,lr
800069b6:	fa cd 02 08 	sub	sp,sp,520
800069ba:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800069bc:	e0 6a 01 00 	mov	r10,256
800069c0:	30 0b       	mov	r11,0
800069c2:	fa cc fe f8 	sub	r12,sp,-264
800069c6:	f0 1f 00 4e 	mcall	80006afc <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800069ca:	fa c4 fd d4 	sub	r4,sp,-556
800069ce:	30 0a       	mov	r10,0
800069d0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800069d2:	fa c3 ff fc 	sub	r3,sp,-4
800069d6:	e0 61 01 00 	mov	r1,256
800069da:	14 90       	mov	r0,r10
			
					if(*str == '%')
800069dc:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800069de:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800069e2:	02 9a       	mov	r10,r1
800069e4:	00 9b       	mov	r11,r0
800069e6:	06 9c       	mov	r12,r3
800069e8:	f0 1f 00 45 	mcall	80006afc <log+0x148>
			
					if(*str == '%')
800069ec:	0f 88       	ld.ub	r8,r7[0x0]
800069ee:	e4 08 18 00 	cp.b	r8,r2
800069f2:	c5 71       	brne	80006aa0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800069f4:	ee c8 ff ff 	sub	r8,r7,-1
800069f8:	11 89       	ld.ub	r9,r8[0x0]
800069fa:	4c 2a       	lddpc	r10,80006b00 <log+0x14c>
800069fc:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800069fe:	23 09       	sub	r9,48
80006a00:	30 9a       	mov	r10,9
80006a02:	f4 09 18 00 	cp.b	r9,r10
80006a06:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006a0a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006a0e:	f7 b9 08 30 	subls	r9,48
80006a12:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006a16:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006a1a:	0f 88       	ld.ub	r8,r7[0x0]
80006a1c:	22 58       	sub	r8,37
80006a1e:	e0 48 00 53 	cp.w	r8,83
80006a22:	e0 8b 00 31 	brhi	80006a84 <log+0xd0>
80006a26:	4b 89       	lddpc	r9,80006b04 <log+0x150>
80006a28:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006a2c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006a30:	06 9a       	mov	r10,r3
80006a32:	40 0b       	lddsp	r11,sp[0x0]
80006a34:	5c 5b       	castu.b	r11
80006a36:	68 0c       	ld.w	r12,r4[0x0]
80006a38:	f0 1f 00 34 	mcall	80006b08 <log+0x154>
							break;
80006a3c:	c2 98       	rjmp	80006a8e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006a3e:	4b 4c       	lddpc	r12,80006b0c <log+0x158>
80006a40:	f0 1f 00 34 	mcall	80006b10 <log+0x15c>
80006a44:	08 95       	mov	r5,r4
80006a46:	06 9c       	mov	r12,r3
							break;
80006a48:	c2 38       	rjmp	80006a8e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006a4a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006a4e:	06 9a       	mov	r10,r3
80006a50:	40 0b       	lddsp	r11,sp[0x0]
80006a52:	5c 5b       	castu.b	r11
80006a54:	68 0c       	ld.w	r12,r4[0x0]
80006a56:	f0 1f 00 30 	mcall	80006b14 <log+0x160>
80006a5a:	06 9c       	mov	r12,r3
							break;
80006a5c:	c1 98       	rjmp	80006a8e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006a5e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006a62:	06 9b       	mov	r11,r3
80006a64:	09 bc       	ld.ub	r12,r4[0x3]
80006a66:	f0 1f 00 2d 	mcall	80006b18 <log+0x164>
80006a6a:	06 9c       	mov	r12,r3
							break;
80006a6c:	c1 18       	rjmp	80006a8e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006a6e:	e8 c5 ff fc 	sub	r5,r4,-4
80006a72:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006a74:	c0 d8       	rjmp	80006a8e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006a76:	06 9b       	mov	r11,r3
80006a78:	32 5c       	mov	r12,37
80006a7a:	f0 1f 00 28 	mcall	80006b18 <log+0x164>
80006a7e:	08 95       	mov	r5,r4
80006a80:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006a82:	c0 68       	rjmp	80006a8e <log+0xda>
							
							default:
							log("I need relax.");
80006a84:	4a 6c       	lddpc	r12,80006b1c <log+0x168>
80006a86:	f0 1f 00 23 	mcall	80006b10 <log+0x15c>
80006a8a:	08 95       	mov	r5,r4
80006a8c:	06 9c       	mov	r12,r3
						}
						str++;
80006a8e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006a90:	1a dc       	st.w	--sp,r12
80006a92:	1a d6       	st.w	--sp,r6
80006a94:	4a 3b       	lddpc	r11,80006b20 <log+0x16c>
80006a96:	0c 9c       	mov	r12,r6
80006a98:	f0 1f 00 23 	mcall	80006b24 <log+0x170>
80006a9c:	2f ed       	sub	sp,-8
80006a9e:	c0 a8       	rjmp	80006ab2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006aa0:	2f f7       	sub	r7,-1
80006aa2:	1a d8       	st.w	--sp,r8
80006aa4:	1a d6       	st.w	--sp,r6
80006aa6:	4a 1b       	lddpc	r11,80006b28 <log+0x174>
80006aa8:	0c 9c       	mov	r12,r6
80006aaa:	f0 1f 00 1f 	mcall	80006b24 <log+0x170>
80006aae:	08 95       	mov	r5,r4
80006ab0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006ab2:	0f 89       	ld.ub	r9,r7[0x0]
80006ab4:	30 08       	mov	r8,0
80006ab6:	f0 09 18 00 	cp.b	r9,r8
80006aba:	c0 30       	breq	80006ac0 <log+0x10c>
80006abc:	0a 94       	mov	r4,r5
80006abe:	c9 2b       	rjmp	800069e2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006ac0:	fa c7 fe f8 	sub	r7,sp,-264
80006ac4:	1a d7       	st.w	--sp,r7
80006ac6:	49 ab       	lddpc	r11,80006b2c <log+0x178>
80006ac8:	0e 9c       	mov	r12,r7
80006aca:	f0 1f 00 17 	mcall	80006b24 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006ace:	5c 5c       	castu.b	r12
80006ad0:	f8 c6 ff ff 	sub	r6,r12,-1
80006ad4:	0c 9c       	mov	r12,r6
80006ad6:	f0 1f 00 17 	mcall	80006b30 <log+0x17c>
80006ada:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006adc:	0c 9a       	mov	r10,r6
80006ade:	0e 9b       	mov	r11,r7
80006ae0:	f0 1f 00 15 	mcall	80006b34 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006ae4:	30 09       	mov	r9,0
80006ae6:	30 5a       	mov	r10,5
80006ae8:	fa cb fe f8 	sub	r11,sp,-264
80006aec:	49 38       	lddpc	r8,80006b38 <log+0x184>
80006aee:	70 0c       	ld.w	r12,r8[0x0]
80006af0:	f0 1f 00 13 	mcall	80006b3c <log+0x188>
80006af4:	2f fd       	sub	sp,-4
	
	
}
80006af6:	fe 3d fd f8 	sub	sp,-520
80006afa:	d8 32       	popm	r0-r7,pc
80006afc:	80 00       	ld.sh	r0,r0[0x0]
80006afe:	74 b6       	ld.w	r6,r10[0x2c]
80006b00:	00 00       	add	r0,r0
80006b02:	0d 40       	ld.w	r0,--r6
80006b04:	80 00       	ld.sh	r0,r0[0x0]
80006b06:	d3 54       	*unknown*
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	68 da       	ld.w	r10,r4[0x34]
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	d6 00       	acall	0x60
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	69 b4       	ld.w	r4,r4[0x6c]
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	68 28       	ld.w	r8,r4[0x8]
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	68 24       	ld.w	r4,r4[0x8]
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	d6 10       	acall	0x61
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	d6 20       	acall	0x62
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	77 a4       	ld.w	r4,r11[0x68]
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	d6 28       	*unknown*
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	d6 30       	acall	0x63
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	5a c8       	cp.w	r8,-20
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	73 6e       	ld.w	lr,r9[0x58]
80006b38:	00 00       	add	r0,r0
80006b3a:	50 fc       	stdsp	sp[0x3c],r12
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	5e 1c       	retne	r12

80006b40 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006b40:	d4 31       	pushm	r0-r7,lr
80006b42:	fa cd 02 0c 	sub	sp,sp,524
80006b46:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006b48:	e0 6a 01 00 	mov	r10,256
80006b4c:	30 0b       	mov	r11,0
80006b4e:	fa cc fe f4 	sub	r12,sp,-268
80006b52:	f0 1f 00 4c 	mcall	80006c80 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006b56:	fa c4 fd d0 	sub	r4,sp,-560
80006b5a:	30 0a       	mov	r10,0
80006b5c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b5e:	fa c3 ff fc 	sub	r3,sp,-4
80006b62:	e0 61 01 00 	mov	r1,256
80006b66:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006b68:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b6a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b6e:	02 9a       	mov	r10,r1
80006b70:	00 9b       	mov	r11,r0
80006b72:	06 9c       	mov	r12,r3
80006b74:	f0 1f 00 43 	mcall	80006c80 <logFromISR+0x140>
			
			if(*str == '%')
80006b78:	0f 88       	ld.ub	r8,r7[0x0]
80006b7a:	e4 08 18 00 	cp.b	r8,r2
80006b7e:	c5 11       	brne	80006c20 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006b80:	ee c8 ff ff 	sub	r8,r7,-1
80006b84:	11 89       	ld.ub	r9,r8[0x0]
80006b86:	4c 0a       	lddpc	r10,80006c84 <logFromISR+0x144>
80006b88:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006b8a:	23 09       	sub	r9,48
80006b8c:	30 9a       	mov	r10,9
80006b8e:	f4 09 18 00 	cp.b	r9,r10
80006b92:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006b96:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006b9a:	f7 b9 08 30 	subls	r9,48
80006b9e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006ba2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006ba6:	0f 88       	ld.ub	r8,r7[0x0]
80006ba8:	22 58       	sub	r8,37
80006baa:	e0 48 00 53 	cp.w	r8,83
80006bae:	e0 8b 00 2b 	brhi	80006c04 <logFromISR+0xc4>
80006bb2:	4b 69       	lddpc	r9,80006c88 <logFromISR+0x148>
80006bb4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006bb8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006bbc:	06 9a       	mov	r10,r3
80006bbe:	40 0b       	lddsp	r11,sp[0x0]
80006bc0:	5c 5b       	castu.b	r11
80006bc2:	68 0c       	ld.w	r12,r4[0x0]
80006bc4:	f0 1f 00 32 	mcall	80006c8c <logFromISR+0x14c>
					break;
80006bc8:	c2 38       	rjmp	80006c0e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006bca:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006bce:	06 9a       	mov	r10,r3
80006bd0:	40 0b       	lddsp	r11,sp[0x0]
80006bd2:	5c 5b       	castu.b	r11
80006bd4:	68 0c       	ld.w	r12,r4[0x0]
80006bd6:	f0 1f 00 2f 	mcall	80006c90 <logFromISR+0x150>
80006bda:	06 9c       	mov	r12,r3
					break;
80006bdc:	c1 98       	rjmp	80006c0e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006bde:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006be2:	06 9b       	mov	r11,r3
80006be4:	09 bc       	ld.ub	r12,r4[0x3]
80006be6:	f0 1f 00 2c 	mcall	80006c94 <logFromISR+0x154>
80006bea:	06 9c       	mov	r12,r3
					break;
80006bec:	c1 18       	rjmp	80006c0e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006bee:	e8 c5 ff fc 	sub	r5,r4,-4
80006bf2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006bf4:	c0 d8       	rjmp	80006c0e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006bf6:	06 9b       	mov	r11,r3
80006bf8:	32 5c       	mov	r12,37
80006bfa:	f0 1f 00 27 	mcall	80006c94 <logFromISR+0x154>
80006bfe:	08 95       	mov	r5,r4
80006c00:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006c02:	c0 68       	rjmp	80006c0e <logFromISR+0xce>
					default:
					log("I need relax.");
80006c04:	4a 5c       	lddpc	r12,80006c98 <logFromISR+0x158>
80006c06:	f0 1f 00 26 	mcall	80006c9c <logFromISR+0x15c>
80006c0a:	08 95       	mov	r5,r4
80006c0c:	06 9c       	mov	r12,r3
				}
				str++;
80006c0e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006c10:	1a dc       	st.w	--sp,r12
80006c12:	1a d6       	st.w	--sp,r6
80006c14:	4a 3b       	lddpc	r11,80006ca0 <logFromISR+0x160>
80006c16:	0c 9c       	mov	r12,r6
80006c18:	f0 1f 00 23 	mcall	80006ca4 <logFromISR+0x164>
80006c1c:	2f ed       	sub	sp,-8
80006c1e:	c0 a8       	rjmp	80006c32 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c20:	2f f7       	sub	r7,-1
80006c22:	1a d8       	st.w	--sp,r8
80006c24:	1a d6       	st.w	--sp,r6
80006c26:	4a 1b       	lddpc	r11,80006ca8 <logFromISR+0x168>
80006c28:	0c 9c       	mov	r12,r6
80006c2a:	f0 1f 00 1f 	mcall	80006ca4 <logFromISR+0x164>
80006c2e:	08 95       	mov	r5,r4
80006c30:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006c32:	0f 89       	ld.ub	r9,r7[0x0]
80006c34:	30 08       	mov	r8,0
80006c36:	f0 09 18 00 	cp.b	r9,r8
80006c3a:	c0 30       	breq	80006c40 <logFromISR+0x100>
80006c3c:	0a 94       	mov	r4,r5
80006c3e:	c9 8b       	rjmp	80006b6e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006c40:	fa c7 fe f4 	sub	r7,sp,-268
80006c44:	1a d7       	st.w	--sp,r7
80006c46:	49 ab       	lddpc	r11,80006cac <logFromISR+0x16c>
80006c48:	0e 9c       	mov	r12,r7
80006c4a:	f0 1f 00 17 	mcall	80006ca4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006c4e:	5c 5c       	castu.b	r12
80006c50:	f8 c6 ff ff 	sub	r6,r12,-1
80006c54:	0c 9c       	mov	r12,r6
80006c56:	f0 1f 00 17 	mcall	80006cb0 <logFromISR+0x170>
80006c5a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006c5c:	0c 9a       	mov	r10,r6
80006c5e:	0e 9b       	mov	r11,r7
80006c60:	f0 1f 00 15 	mcall	80006cb4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006c64:	30 09       	mov	r9,0
80006c66:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006c68:	fa ca fe f8 	sub	r10,sp,-264
80006c6c:	fa cb fe f4 	sub	r11,sp,-268
80006c70:	49 28       	lddpc	r8,80006cb8 <logFromISR+0x178>
80006c72:	70 0c       	ld.w	r12,r8[0x0]
80006c74:	f0 1f 00 12 	mcall	80006cbc <logFromISR+0x17c>
80006c78:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006c7a:	fe 3d fd f4 	sub	sp,-524
80006c7e:	d8 32       	popm	r0-r7,pc
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	74 b6       	ld.w	r6,r10[0x2c]
80006c84:	00 00       	add	r0,r0
80006c86:	0d 41       	ld.w	r1,--r6
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	d4 a4       	*unknown*
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	68 da       	ld.w	r10,r4[0x34]
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	68 28       	ld.w	r8,r4[0x8]
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	68 24       	ld.w	r4,r4[0x8]
80006c98:	80 00       	ld.sh	r0,r0[0x0]
80006c9a:	d6 10       	acall	0x61
80006c9c:	80 00       	ld.sh	r0,r0[0x0]
80006c9e:	69 b4       	ld.w	r4,r4[0x6c]
80006ca0:	80 00       	ld.sh	r0,r0[0x0]
80006ca2:	d6 20       	acall	0x62
80006ca4:	80 00       	ld.sh	r0,r0[0x0]
80006ca6:	77 a4       	ld.w	r4,r11[0x68]
80006ca8:	80 00       	ld.sh	r0,r0[0x0]
80006caa:	d6 28       	*unknown*
80006cac:	80 00       	ld.sh	r0,r0[0x0]
80006cae:	d6 30       	acall	0x63
80006cb0:	80 00       	ld.sh	r0,r0[0x0]
80006cb2:	5a c8       	cp.w	r8,-20
80006cb4:	80 00       	ld.sh	r0,r0[0x0]
80006cb6:	73 6e       	ld.w	lr,r9[0x58]
80006cb8:	00 00       	add	r0,r0
80006cba:	50 fc       	stdsp	sp[0x3c],r12
80006cbc:	80 00       	ld.sh	r0,r0[0x0]
80006cbe:	5d cc       	*unknown*

80006cc0 <log_init>:
		
	return str;
}

void log_init(void)
{
80006cc0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006cc2:	30 2b       	mov	r11,2
80006cc4:	49 0c       	lddpc	r12,80006d04 <log_init+0x44>
80006cc6:	f0 1f 00 11 	mcall	80006d08 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006cca:	e0 6a 36 00 	mov	r10,13824
80006cce:	ea 1a 01 6e 	orh	r10,0x16e
80006cd2:	48 fb       	lddpc	r11,80006d0c <log_init+0x4c>
80006cd4:	fe 7c 18 00 	mov	r12,-59392
80006cd8:	f0 1f 00 0e 	mcall	80006d10 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006cdc:	30 4b       	mov	r11,4
80006cde:	33 2c       	mov	r12,50
80006ce0:	f0 1f 00 0d 	mcall	80006d14 <log_init+0x54>
80006ce4:	48 d8       	lddpc	r8,80006d18 <log_init+0x58>
80006ce6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006ce8:	30 09       	mov	r9,0
80006cea:	1a d9       	st.w	--sp,r9
80006cec:	1a d9       	st.w	--sp,r9
80006cee:	1a d9       	st.w	--sp,r9
80006cf0:	30 28       	mov	r8,2
80006cf2:	e0 6a 01 80 	mov	r10,384
80006cf6:	48 ab       	lddpc	r11,80006d1c <log_init+0x5c>
80006cf8:	48 ac       	lddpc	r12,80006d20 <log_init+0x60>
80006cfa:	f0 1f 00 0b 	mcall	80006d24 <log_init+0x64>
80006cfe:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006d00:	d8 02       	popm	pc
80006d02:	00 00       	add	r0,r0
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	d6 3c       	*unknown*
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	6e 4c       	ld.w	r12,r7[0x10]
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	d5 f4       	*unknown*
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	56 6c       	stdsp	sp[0x198],r12
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	5f 1c       	srne	r12
80006d18:	00 00       	add	r0,r0
80006d1a:	50 fc       	stdsp	sp[0x3c],r12
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	d6 38       	*unknown*
80006d20:	80 00       	ld.sh	r0,r0[0x0]
80006d22:	6d 28       	ld.w	r8,r6[0x48]
80006d24:	80 00       	ld.sh	r0,r0[0x0]
80006d26:	65 f0       	ld.w	r0,r2[0x7c]

80006d28 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006d28:	eb cd 40 f8 	pushm	r3-r7,lr
80006d2c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d2e:	48 c7       	lddpc	r7,80006d5c <task_log+0x34>
80006d30:	30 05       	mov	r5,0
80006d32:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006d34:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d38:	0a 99       	mov	r9,r5
80006d3a:	08 9a       	mov	r10,r4
80006d3c:	1a 9b       	mov	r11,sp
80006d3e:	6e 0c       	ld.w	r12,r7[0x0]
80006d40:	f0 1f 00 08 	mcall	80006d60 <task_log+0x38>
80006d44:	58 1c       	cp.w	r12,1
80006d46:	cf 91       	brne	80006d38 <task_log+0x10>
		{
			if( NULL != str)
80006d48:	40 0b       	lddsp	r11,sp[0x0]
80006d4a:	58 0b       	cp.w	r11,0
80006d4c:	cf 60       	breq	80006d38 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006d4e:	06 9c       	mov	r12,r3
80006d50:	f0 1f 00 05 	mcall	80006d64 <task_log+0x3c>
				vPortFree(str);
80006d54:	40 0c       	lddsp	r12,sp[0x0]
80006d56:	f0 1f 00 05 	mcall	80006d68 <task_log+0x40>
80006d5a:	ce fb       	rjmp	80006d38 <task_log+0x10>
80006d5c:	00 00       	add	r0,r0
80006d5e:	50 fc       	stdsp	sp[0x3c],r12
80006d60:	80 00       	ld.sh	r0,r0[0x0]
80006d62:	5c 10       	scr	r0
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	56 1c       	stdsp	sp[0x184],r12
80006d68:	80 00       	ld.sh	r0,r0[0x0]
80006d6a:	5a a0       	cp.w	r0,-22

80006d6c <main>:
#include "fs/fs.h"
#include "rtc/rtc.h"
#include "voice/voice.h"

int main(void)
{
80006d6c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006d6e:	fe 78 10 00 	mov	r8,-61440
80006d72:	30 19       	mov	r9,1
80006d74:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006d78:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006d7c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006d80:	d3 03       	ssrf	0x10
	local_start_pll0();
80006d82:	f0 1f 00 13 	mcall	80006dcc <main+0x60>
		
	INTC_init_interrupts();
80006d86:	f0 1f 00 13 	mcall	80006dd0 <main+0x64>
	
	log_init();		
80006d8a:	f0 1f 00 13 	mcall	80006dd4 <main+0x68>
	log("----start debug----");	
80006d8e:	49 3c       	lddpc	r12,80006dd8 <main+0x6c>
80006d90:	f0 1f 00 13 	mcall	80006ddc <main+0x70>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。
	
	voc_init();
80006d94:	f0 1f 00 13 	mcall	80006de0 <main+0x74>

	tc_init();	
80006d98:	f0 1f 00 13 	mcall	80006de4 <main+0x78>
	
	app_init();
80006d9c:	f0 1f 00 13 	mcall	80006de8 <main+0x7c>
	
	xcmp_init();
80006da0:	f0 1f 00 13 	mcall	80006dec <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006da4:	fe 79 10 00 	mov	r9,-61440
80006da8:	f2 f8 01 60 	ld.w	r8,r9[352]
80006dac:	e2 18 00 02 	andl	r8,0x2,COH
80006db0:	cf c0       	breq	80006da8 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006db2:	fe 79 10 00 	mov	r9,-61440
80006db6:	f2 f8 01 60 	ld.w	r8,r9[352]
80006dba:	e2 18 00 02 	andl	r8,0x2,COH
80006dbe:	cf c1       	brne	80006db6 <main+0x4a>
	local_start_timer();
80006dc0:	f0 1f 00 0c 	mcall	80006df0 <main+0x84>
	
	Enable_global_interrupt();
80006dc4:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006dc6:	f0 1f 00 0c 	mcall	80006df4 <main+0x88>
	return 0;
}
80006dca:	d8 0a       	popm	pc,r12=0
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	4d 8c       	lddpc	r12,80006f2c <_malloc_r+0x1c>
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	50 d0       	stdsp	sp[0x34],r0
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	6c c0       	ld.w	r0,r6[0x30]
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	d6 4c       	*unknown*
80006ddc:	80 00       	ld.sh	r0,r0[0x0]
80006dde:	69 b4       	ld.w	r4,r4[0x6c]
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	4e 98       	lddpc	r8,80006f84 <_malloc_r+0x74>
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	4e 18       	lddpc	r8,80006f68 <_malloc_r+0x58>
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	20 40       	sub	r0,4
80006dec:	80 00       	ld.sh	r0,r0[0x0]
80006dee:	46 9c       	lddsp	r12,sp[0x1a4]
80006df0:	80 00       	ld.sh	r0,r0[0x0]
80006df2:	4d dc       	lddpc	r12,80006f64 <_malloc_r+0x54>
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	67 d8       	ld.w	r8,r3[0x74]

80006df8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006df8:	f8 08 16 05 	lsr	r8,r12,0x5
80006dfc:	a9 68       	lsl	r8,0x8
80006dfe:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006e02:	58 1b       	cp.w	r11,1
80006e04:	c0 d0       	breq	80006e1e <gpio_enable_module_pin+0x26>
80006e06:	c0 63       	brcs	80006e12 <gpio_enable_module_pin+0x1a>
80006e08:	58 2b       	cp.w	r11,2
80006e0a:	c1 00       	breq	80006e2a <gpio_enable_module_pin+0x32>
80006e0c:	58 3b       	cp.w	r11,3
80006e0e:	c1 40       	breq	80006e36 <gpio_enable_module_pin+0x3e>
80006e10:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006e12:	30 19       	mov	r9,1
80006e14:	f2 0c 09 49 	lsl	r9,r9,r12
80006e18:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006e1a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006e1c:	c1 28       	rjmp	80006e40 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006e1e:	30 19       	mov	r9,1
80006e20:	f2 0c 09 49 	lsl	r9,r9,r12
80006e24:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006e26:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006e28:	c0 c8       	rjmp	80006e40 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006e2a:	30 19       	mov	r9,1
80006e2c:	f2 0c 09 49 	lsl	r9,r9,r12
80006e30:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006e32:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006e34:	c0 68       	rjmp	80006e40 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006e36:	30 19       	mov	r9,1
80006e38:	f2 0c 09 49 	lsl	r9,r9,r12
80006e3c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006e3e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006e40:	30 19       	mov	r9,1
80006e42:	f2 0c 09 4c 	lsl	r12,r9,r12
80006e46:	91 2c       	st.w	r8[0x8],r12
80006e48:	5e fd       	retal	0
80006e4a:	d7 03       	nop

80006e4c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006e4c:	d4 21       	pushm	r4-r7,lr
80006e4e:	18 97       	mov	r7,r12
80006e50:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006e52:	58 0b       	cp.w	r11,0
80006e54:	c0 31       	brne	80006e5a <gpio_enable_module+0xe>
80006e56:	30 05       	mov	r5,0
80006e58:	c0 d8       	rjmp	80006e72 <gpio_enable_module+0x26>
80006e5a:	30 06       	mov	r6,0
80006e5c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006e5e:	6e 1b       	ld.w	r11,r7[0x4]
80006e60:	6e 0c       	ld.w	r12,r7[0x0]
80006e62:	f0 1f 00 06 	mcall	80006e78 <gpio_enable_module+0x2c>
80006e66:	18 45       	or	r5,r12
		gpiomap++;
80006e68:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006e6a:	2f f6       	sub	r6,-1
80006e6c:	0c 34       	cp.w	r4,r6
80006e6e:	fe 9b ff f8 	brhi	80006e5e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006e72:	0a 9c       	mov	r12,r5
80006e74:	d8 22       	popm	r4-r7,pc
80006e76:	00 00       	add	r0,r0
80006e78:	80 00       	ld.sh	r0,r0[0x0]
80006e7a:	6d f8       	ld.w	r8,r6[0x7c]

80006e7c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006e7c:	f8 08 16 05 	lsr	r8,r12,0x5
80006e80:	a9 68       	lsl	r8,0x8
80006e82:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006e86:	30 19       	mov	r9,1
80006e88:	f2 0c 09 4c 	lsl	r12,r9,r12
80006e8c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80006e90:	91 1c       	st.w	r8[0x4],r12
}
80006e92:	5e fc       	retal	r12

80006e94 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006e94:	f8 08 16 05 	lsr	r8,r12,0x5
80006e98:	a9 68       	lsl	r8,0x8
80006e9a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80006e9e:	30 19       	mov	r9,1
80006ea0:	f2 0c 09 4c 	lsl	r12,r9,r12
80006ea4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006ea8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006eac:	91 1c       	st.w	r8[0x4],r12
}
80006eae:	5e fc       	retal	r12

80006eb0 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006eb0:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006eb4:	fe c0 a6 b4 	sub	r0,pc,-22860

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006eb8:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006ebc:	d5 53       	csrf	0x15
  cp      r0, r1
80006ebe:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006ec0:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006ec4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006ec6:	c0 72       	brcc	80006ed4 <idata_load_loop_end>
  cp      r0, r1
80006ec8:	fe c2 92 e0 	sub	r2,pc,-27936

80006ecc <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006ecc:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006ece:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006ed0:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80006ed2:	cf d3       	brcs	80006ecc <idata_load_loop>

80006ed4 <idata_load_loop_end>:
  mov     r2, 0
80006ed4:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006ed8:	e0 61 51 08 	mov	r1,20744
  cp      r0, r1
  brlo    udata_clear_loop
80006edc:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006ede:	c0 62       	brcc	80006eea <udata_clear_loop_end>
80006ee0:	30 02       	mov	r2,0
80006ee2:	30 03       	mov	r3,0

80006ee4 <udata_clear_loop>:
80006ee4:	a1 22       	st.d	r0++,r2
80006ee6:	02 30       	cp.w	r0,r1
80006ee8:	cf e3       	brcs	80006ee4 <udata_clear_loop>

80006eea <udata_clear_loop_end>:
80006eea:	fe cf 01 7e 	sub	pc,pc,382
80006eee:	d7 03       	nop

80006ef0 <free>:
80006ef0:	d4 01       	pushm	lr
80006ef2:	e0 68 0a 3c 	mov	r8,2620
80006ef6:	18 9b       	mov	r11,r12
80006ef8:	70 0c       	ld.w	r12,r8[0x0]
80006efa:	e0 a0 1e 7f 	rcall	8000abf8 <_free_r>
80006efe:	d8 02       	popm	pc

80006f00 <malloc>:
80006f00:	d4 01       	pushm	lr
80006f02:	e0 68 0a 3c 	mov	r8,2620
80006f06:	18 9b       	mov	r11,r12
80006f08:	70 0c       	ld.w	r12,r8[0x0]
80006f0a:	c0 3c       	rcall	80006f10 <_malloc_r>
80006f0c:	d8 02       	popm	pc
80006f0e:	d7 03       	nop

80006f10 <_malloc_r>:
80006f10:	d4 31       	pushm	r0-r7,lr
80006f12:	f6 c8 ff f5 	sub	r8,r11,-11
80006f16:	18 95       	mov	r5,r12
80006f18:	10 97       	mov	r7,r8
80006f1a:	e0 17 ff f8 	andl	r7,0xfff8
80006f1e:	59 68       	cp.w	r8,22
80006f20:	f9 b7 08 10 	movls	r7,16
80006f24:	16 37       	cp.w	r7,r11
80006f26:	5f 38       	srlo	r8
80006f28:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006f2c:	c0 50       	breq	80006f36 <_malloc_r+0x26>
80006f2e:	30 c8       	mov	r8,12
80006f30:	99 38       	st.w	r12[0xc],r8
80006f32:	e0 8f 01 fa 	bral	80007326 <_malloc_r+0x416>
80006f36:	fe b0 f5 6b 	rcall	80005a0c <__malloc_lock>
80006f3a:	e0 47 01 f7 	cp.w	r7,503
80006f3e:	e0 8b 00 1d 	brhi	80006f78 <_malloc_r+0x68>
80006f42:	ee 03 16 03 	lsr	r3,r7,0x3
80006f46:	e0 68 05 3c 	mov	r8,1340
80006f4a:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006f4e:	70 36       	ld.w	r6,r8[0xc]
80006f50:	10 36       	cp.w	r6,r8
80006f52:	c0 61       	brne	80006f5e <_malloc_r+0x4e>
80006f54:	ec c8 ff f8 	sub	r8,r6,-8
80006f58:	70 36       	ld.w	r6,r8[0xc]
80006f5a:	10 36       	cp.w	r6,r8
80006f5c:	c0 c0       	breq	80006f74 <_malloc_r+0x64>
80006f5e:	6c 18       	ld.w	r8,r6[0x4]
80006f60:	e0 18 ff fc 	andl	r8,0xfffc
80006f64:	6c 3a       	ld.w	r10,r6[0xc]
80006f66:	ec 08 00 09 	add	r9,r6,r8
80006f6a:	0a 9c       	mov	r12,r5
80006f6c:	6c 28       	ld.w	r8,r6[0x8]
80006f6e:	95 28       	st.w	r10[0x8],r8
80006f70:	91 3a       	st.w	r8[0xc],r10
80006f72:	c4 78       	rjmp	80007000 <_malloc_r+0xf0>
80006f74:	2f e3       	sub	r3,-2
80006f76:	c4 d8       	rjmp	80007010 <_malloc_r+0x100>
80006f78:	ee 03 16 09 	lsr	r3,r7,0x9
80006f7c:	c0 41       	brne	80006f84 <_malloc_r+0x74>
80006f7e:	ee 03 16 03 	lsr	r3,r7,0x3
80006f82:	c2 68       	rjmp	80006fce <_malloc_r+0xbe>
80006f84:	58 43       	cp.w	r3,4
80006f86:	e0 8b 00 06 	brhi	80006f92 <_malloc_r+0x82>
80006f8a:	ee 03 16 06 	lsr	r3,r7,0x6
80006f8e:	2c 83       	sub	r3,-56
80006f90:	c1 f8       	rjmp	80006fce <_malloc_r+0xbe>
80006f92:	59 43       	cp.w	r3,20
80006f94:	e0 8b 00 04 	brhi	80006f9c <_malloc_r+0x8c>
80006f98:	2a 53       	sub	r3,-91
80006f9a:	c1 a8       	rjmp	80006fce <_malloc_r+0xbe>
80006f9c:	e0 43 00 54 	cp.w	r3,84
80006fa0:	e0 8b 00 06 	brhi	80006fac <_malloc_r+0x9c>
80006fa4:	ee 03 16 0c 	lsr	r3,r7,0xc
80006fa8:	29 23       	sub	r3,-110
80006faa:	c1 28       	rjmp	80006fce <_malloc_r+0xbe>
80006fac:	e0 43 01 54 	cp.w	r3,340
80006fb0:	e0 8b 00 06 	brhi	80006fbc <_malloc_r+0xac>
80006fb4:	ee 03 16 0f 	lsr	r3,r7,0xf
80006fb8:	28 93       	sub	r3,-119
80006fba:	c0 a8       	rjmp	80006fce <_malloc_r+0xbe>
80006fbc:	e0 43 05 54 	cp.w	r3,1364
80006fc0:	e0 88 00 04 	brls	80006fc8 <_malloc_r+0xb8>
80006fc4:	37 e3       	mov	r3,126
80006fc6:	c0 48       	rjmp	80006fce <_malloc_r+0xbe>
80006fc8:	ee 03 16 12 	lsr	r3,r7,0x12
80006fcc:	28 43       	sub	r3,-124
80006fce:	e0 6a 05 3c 	mov	r10,1340
80006fd2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006fd6:	74 36       	ld.w	r6,r10[0xc]
80006fd8:	c1 98       	rjmp	8000700a <_malloc_r+0xfa>
80006fda:	6c 19       	ld.w	r9,r6[0x4]
80006fdc:	e0 19 ff fc 	andl	r9,0xfffc
80006fe0:	f2 07 01 0b 	sub	r11,r9,r7
80006fe4:	58 fb       	cp.w	r11,15
80006fe6:	e0 8a 00 04 	brle	80006fee <_malloc_r+0xde>
80006fea:	20 13       	sub	r3,1
80006fec:	c1 18       	rjmp	8000700e <_malloc_r+0xfe>
80006fee:	6c 38       	ld.w	r8,r6[0xc]
80006ff0:	58 0b       	cp.w	r11,0
80006ff2:	c0 b5       	brlt	80007008 <_malloc_r+0xf8>
80006ff4:	6c 2a       	ld.w	r10,r6[0x8]
80006ff6:	ec 09 00 09 	add	r9,r6,r9
80006ffa:	0a 9c       	mov	r12,r5
80006ffc:	91 2a       	st.w	r8[0x8],r10
80006ffe:	95 38       	st.w	r10[0xc],r8
80007000:	72 18       	ld.w	r8,r9[0x4]
80007002:	a1 a8       	sbr	r8,0x0
80007004:	93 18       	st.w	r9[0x4],r8
80007006:	cb c8       	rjmp	8000717e <_malloc_r+0x26e>
80007008:	10 96       	mov	r6,r8
8000700a:	14 36       	cp.w	r6,r10
8000700c:	ce 71       	brne	80006fda <_malloc_r+0xca>
8000700e:	2f f3       	sub	r3,-1
80007010:	e0 6a 05 3c 	mov	r10,1340
80007014:	f4 cc ff f8 	sub	r12,r10,-8
80007018:	78 26       	ld.w	r6,r12[0x8]
8000701a:	18 36       	cp.w	r6,r12
8000701c:	c6 c0       	breq	800070f4 <_malloc_r+0x1e4>
8000701e:	6c 19       	ld.w	r9,r6[0x4]
80007020:	e0 19 ff fc 	andl	r9,0xfffc
80007024:	f2 07 01 08 	sub	r8,r9,r7
80007028:	58 f8       	cp.w	r8,15
8000702a:	e0 89 00 8f 	brgt	80007148 <_malloc_r+0x238>
8000702e:	99 3c       	st.w	r12[0xc],r12
80007030:	99 2c       	st.w	r12[0x8],r12
80007032:	58 08       	cp.w	r8,0
80007034:	c0 55       	brlt	8000703e <_malloc_r+0x12e>
80007036:	ec 09 00 09 	add	r9,r6,r9
8000703a:	0a 9c       	mov	r12,r5
8000703c:	ce 2b       	rjmp	80007000 <_malloc_r+0xf0>
8000703e:	e0 49 01 ff 	cp.w	r9,511
80007042:	e0 8b 00 13 	brhi	80007068 <_malloc_r+0x158>
80007046:	a3 99       	lsr	r9,0x3
80007048:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000704c:	70 2b       	ld.w	r11,r8[0x8]
8000704e:	8d 38       	st.w	r6[0xc],r8
80007050:	8d 2b       	st.w	r6[0x8],r11
80007052:	97 36       	st.w	r11[0xc],r6
80007054:	91 26       	st.w	r8[0x8],r6
80007056:	a3 49       	asr	r9,0x2
80007058:	74 18       	ld.w	r8,r10[0x4]
8000705a:	30 1b       	mov	r11,1
8000705c:	f6 09 09 49 	lsl	r9,r11,r9
80007060:	f1 e9 10 09 	or	r9,r8,r9
80007064:	95 19       	st.w	r10[0x4],r9
80007066:	c4 78       	rjmp	800070f4 <_malloc_r+0x1e4>
80007068:	f2 0a 16 09 	lsr	r10,r9,0x9
8000706c:	58 4a       	cp.w	r10,4
8000706e:	e0 8b 00 07 	brhi	8000707c <_malloc_r+0x16c>
80007072:	f2 0a 16 06 	lsr	r10,r9,0x6
80007076:	2c 8a       	sub	r10,-56
80007078:	c2 08       	rjmp	800070b8 <_malloc_r+0x1a8>
8000707a:	d7 03       	nop
8000707c:	59 4a       	cp.w	r10,20
8000707e:	e0 8b 00 04 	brhi	80007086 <_malloc_r+0x176>
80007082:	2a 5a       	sub	r10,-91
80007084:	c1 a8       	rjmp	800070b8 <_malloc_r+0x1a8>
80007086:	e0 4a 00 54 	cp.w	r10,84
8000708a:	e0 8b 00 06 	brhi	80007096 <_malloc_r+0x186>
8000708e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007092:	29 2a       	sub	r10,-110
80007094:	c1 28       	rjmp	800070b8 <_malloc_r+0x1a8>
80007096:	e0 4a 01 54 	cp.w	r10,340
8000709a:	e0 8b 00 06 	brhi	800070a6 <_malloc_r+0x196>
8000709e:	f2 0a 16 0f 	lsr	r10,r9,0xf
800070a2:	28 9a       	sub	r10,-119
800070a4:	c0 a8       	rjmp	800070b8 <_malloc_r+0x1a8>
800070a6:	e0 4a 05 54 	cp.w	r10,1364
800070aa:	e0 88 00 04 	brls	800070b2 <_malloc_r+0x1a2>
800070ae:	37 ea       	mov	r10,126
800070b0:	c0 48       	rjmp	800070b8 <_malloc_r+0x1a8>
800070b2:	f2 0a 16 12 	lsr	r10,r9,0x12
800070b6:	28 4a       	sub	r10,-124
800070b8:	e0 6b 05 3c 	mov	r11,1340
800070bc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800070c0:	68 28       	ld.w	r8,r4[0x8]
800070c2:	08 38       	cp.w	r8,r4
800070c4:	c0 e1       	brne	800070e0 <_malloc_r+0x1d0>
800070c6:	76 19       	ld.w	r9,r11[0x4]
800070c8:	a3 4a       	asr	r10,0x2
800070ca:	30 1e       	mov	lr,1
800070cc:	fc 0a 09 4a 	lsl	r10,lr,r10
800070d0:	f3 ea 10 0a 	or	r10,r9,r10
800070d4:	10 99       	mov	r9,r8
800070d6:	97 1a       	st.w	r11[0x4],r10
800070d8:	c0 a8       	rjmp	800070ec <_malloc_r+0x1dc>
800070da:	70 28       	ld.w	r8,r8[0x8]
800070dc:	08 38       	cp.w	r8,r4
800070de:	c0 60       	breq	800070ea <_malloc_r+0x1da>
800070e0:	70 1a       	ld.w	r10,r8[0x4]
800070e2:	e0 1a ff fc 	andl	r10,0xfffc
800070e6:	14 39       	cp.w	r9,r10
800070e8:	cf 93       	brcs	800070da <_malloc_r+0x1ca>
800070ea:	70 39       	ld.w	r9,r8[0xc]
800070ec:	8d 39       	st.w	r6[0xc],r9
800070ee:	8d 28       	st.w	r6[0x8],r8
800070f0:	91 36       	st.w	r8[0xc],r6
800070f2:	93 26       	st.w	r9[0x8],r6
800070f4:	e6 08 14 02 	asr	r8,r3,0x2
800070f8:	30 1b       	mov	r11,1
800070fa:	e0 64 05 3c 	mov	r4,1340
800070fe:	f6 08 09 4b 	lsl	r11,r11,r8
80007102:	68 18       	ld.w	r8,r4[0x4]
80007104:	10 3b       	cp.w	r11,r8
80007106:	e0 8b 00 6b 	brhi	800071dc <_malloc_r+0x2cc>
8000710a:	f7 e8 00 09 	and	r9,r11,r8
8000710e:	c0 b1       	brne	80007124 <_malloc_r+0x214>
80007110:	e0 13 ff fc 	andl	r3,0xfffc
80007114:	a1 7b       	lsl	r11,0x1
80007116:	2f c3       	sub	r3,-4
80007118:	c0 38       	rjmp	8000711e <_malloc_r+0x20e>
8000711a:	2f c3       	sub	r3,-4
8000711c:	a1 7b       	lsl	r11,0x1
8000711e:	f7 e8 00 09 	and	r9,r11,r8
80007122:	cf c0       	breq	8000711a <_malloc_r+0x20a>
80007124:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007128:	06 92       	mov	r2,r3
8000712a:	1c 91       	mov	r1,lr
8000712c:	62 36       	ld.w	r6,r1[0xc]
8000712e:	c2 e8       	rjmp	8000718a <_malloc_r+0x27a>
80007130:	6c 1a       	ld.w	r10,r6[0x4]
80007132:	e0 1a ff fc 	andl	r10,0xfffc
80007136:	f4 07 01 08 	sub	r8,r10,r7
8000713a:	58 f8       	cp.w	r8,15
8000713c:	e0 8a 00 15 	brle	80007166 <_malloc_r+0x256>
80007140:	6c 3a       	ld.w	r10,r6[0xc]
80007142:	6c 29       	ld.w	r9,r6[0x8]
80007144:	95 29       	st.w	r10[0x8],r9
80007146:	93 3a       	st.w	r9[0xc],r10
80007148:	0e 99       	mov	r9,r7
8000714a:	ec 07 00 07 	add	r7,r6,r7
8000714e:	a1 a9       	sbr	r9,0x0
80007150:	99 37       	st.w	r12[0xc],r7
80007152:	99 27       	st.w	r12[0x8],r7
80007154:	8d 19       	st.w	r6[0x4],r9
80007156:	ee 08 09 08 	st.w	r7[r8],r8
8000715a:	8f 2c       	st.w	r7[0x8],r12
8000715c:	8f 3c       	st.w	r7[0xc],r12
8000715e:	a1 a8       	sbr	r8,0x0
80007160:	0a 9c       	mov	r12,r5
80007162:	8f 18       	st.w	r7[0x4],r8
80007164:	c0 d8       	rjmp	8000717e <_malloc_r+0x26e>
80007166:	6c 39       	ld.w	r9,r6[0xc]
80007168:	58 08       	cp.w	r8,0
8000716a:	c0 f5       	brlt	80007188 <_malloc_r+0x278>
8000716c:	ec 0a 00 0a 	add	r10,r6,r10
80007170:	74 18       	ld.w	r8,r10[0x4]
80007172:	a1 a8       	sbr	r8,0x0
80007174:	0a 9c       	mov	r12,r5
80007176:	95 18       	st.w	r10[0x4],r8
80007178:	6c 28       	ld.w	r8,r6[0x8]
8000717a:	93 28       	st.w	r9[0x8],r8
8000717c:	91 39       	st.w	r8[0xc],r9
8000717e:	fe b0 f4 4d 	rcall	80005a18 <__malloc_unlock>
80007182:	ec cc ff f8 	sub	r12,r6,-8
80007186:	d8 32       	popm	r0-r7,pc
80007188:	12 96       	mov	r6,r9
8000718a:	02 36       	cp.w	r6,r1
8000718c:	cd 21       	brne	80007130 <_malloc_r+0x220>
8000718e:	2f f2       	sub	r2,-1
80007190:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007194:	c0 30       	breq	8000719a <_malloc_r+0x28a>
80007196:	2f 81       	sub	r1,-8
80007198:	cc ab       	rjmp	8000712c <_malloc_r+0x21c>
8000719a:	1c 98       	mov	r8,lr
8000719c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800071a0:	c0 81       	brne	800071b0 <_malloc_r+0x2a0>
800071a2:	68 19       	ld.w	r9,r4[0x4]
800071a4:	f6 08 11 ff 	rsub	r8,r11,-1
800071a8:	f3 e8 00 08 	and	r8,r9,r8
800071ac:	89 18       	st.w	r4[0x4],r8
800071ae:	c0 78       	rjmp	800071bc <_malloc_r+0x2ac>
800071b0:	f0 c9 00 08 	sub	r9,r8,8
800071b4:	20 13       	sub	r3,1
800071b6:	70 08       	ld.w	r8,r8[0x0]
800071b8:	12 38       	cp.w	r8,r9
800071ba:	cf 10       	breq	8000719c <_malloc_r+0x28c>
800071bc:	a1 7b       	lsl	r11,0x1
800071be:	68 18       	ld.w	r8,r4[0x4]
800071c0:	10 3b       	cp.w	r11,r8
800071c2:	e0 8b 00 0d 	brhi	800071dc <_malloc_r+0x2cc>
800071c6:	58 0b       	cp.w	r11,0
800071c8:	c0 a0       	breq	800071dc <_malloc_r+0x2cc>
800071ca:	04 93       	mov	r3,r2
800071cc:	c0 38       	rjmp	800071d2 <_malloc_r+0x2c2>
800071ce:	2f c3       	sub	r3,-4
800071d0:	a1 7b       	lsl	r11,0x1
800071d2:	f7 e8 00 09 	and	r9,r11,r8
800071d6:	ca 71       	brne	80007124 <_malloc_r+0x214>
800071d8:	cf bb       	rjmp	800071ce <_malloc_r+0x2be>
800071da:	d7 03       	nop
800071dc:	68 23       	ld.w	r3,r4[0x8]
800071de:	66 12       	ld.w	r2,r3[0x4]
800071e0:	e0 12 ff fc 	andl	r2,0xfffc
800071e4:	0e 32       	cp.w	r2,r7
800071e6:	5f 39       	srlo	r9
800071e8:	e4 07 01 08 	sub	r8,r2,r7
800071ec:	58 f8       	cp.w	r8,15
800071ee:	5f aa       	srle	r10
800071f0:	f5 e9 10 09 	or	r9,r10,r9
800071f4:	e0 80 00 9a 	breq	80007328 <_malloc_r+0x418>
800071f8:	e0 68 0d 4c 	mov	r8,3404
800071fc:	70 01       	ld.w	r1,r8[0x0]
800071fe:	e0 68 09 48 	mov	r8,2376
80007202:	2f 01       	sub	r1,-16
80007204:	70 08       	ld.w	r8,r8[0x0]
80007206:	0e 01       	add	r1,r7
80007208:	5b f8       	cp.w	r8,-1
8000720a:	c0 40       	breq	80007212 <_malloc_r+0x302>
8000720c:	28 11       	sub	r1,-127
8000720e:	e0 11 ff 80 	andl	r1,0xff80
80007212:	02 9b       	mov	r11,r1
80007214:	0a 9c       	mov	r12,r5
80007216:	e0 a0 02 b7 	rcall	80007784 <_sbrk_r>
8000721a:	18 96       	mov	r6,r12
8000721c:	5b fc       	cp.w	r12,-1
8000721e:	c7 50       	breq	80007308 <_malloc_r+0x3f8>
80007220:	e6 02 00 08 	add	r8,r3,r2
80007224:	10 3c       	cp.w	r12,r8
80007226:	c0 32       	brcc	8000722c <_malloc_r+0x31c>
80007228:	08 33       	cp.w	r3,r4
8000722a:	c6 f1       	brne	80007308 <_malloc_r+0x3f8>
8000722c:	e0 6a 0d 50 	mov	r10,3408
80007230:	74 09       	ld.w	r9,r10[0x0]
80007232:	e2 09 00 09 	add	r9,r1,r9
80007236:	95 09       	st.w	r10[0x0],r9
80007238:	10 36       	cp.w	r6,r8
8000723a:	c0 a1       	brne	8000724e <_malloc_r+0x33e>
8000723c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007240:	c0 71       	brne	8000724e <_malloc_r+0x33e>
80007242:	e2 02 00 02 	add	r2,r1,r2
80007246:	68 28       	ld.w	r8,r4[0x8]
80007248:	a1 a2       	sbr	r2,0x0
8000724a:	91 12       	st.w	r8[0x4],r2
8000724c:	c4 f8       	rjmp	800072ea <_malloc_r+0x3da>
8000724e:	e0 6a 09 48 	mov	r10,2376
80007252:	74 0b       	ld.w	r11,r10[0x0]
80007254:	5b fb       	cp.w	r11,-1
80007256:	c0 31       	brne	8000725c <_malloc_r+0x34c>
80007258:	95 06       	st.w	r10[0x0],r6
8000725a:	c0 78       	rjmp	80007268 <_malloc_r+0x358>
8000725c:	ec 09 00 09 	add	r9,r6,r9
80007260:	e0 6a 0d 50 	mov	r10,3408
80007264:	10 19       	sub	r9,r8
80007266:	95 09       	st.w	r10[0x0],r9
80007268:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000726c:	f0 09 11 08 	rsub	r9,r8,8
80007270:	58 08       	cp.w	r8,0
80007272:	f2 08 17 10 	movne	r8,r9
80007276:	ed d8 e1 06 	addne	r6,r6,r8
8000727a:	28 08       	sub	r8,-128
8000727c:	ec 01 00 01 	add	r1,r6,r1
80007280:	0a 9c       	mov	r12,r5
80007282:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007286:	f0 01 01 01 	sub	r1,r8,r1
8000728a:	02 9b       	mov	r11,r1
8000728c:	e0 a0 02 7c 	rcall	80007784 <_sbrk_r>
80007290:	e0 68 0d 50 	mov	r8,3408
80007294:	5b fc       	cp.w	r12,-1
80007296:	ec 0c 17 00 	moveq	r12,r6
8000729a:	f9 b1 00 00 	moveq	r1,0
8000729e:	70 09       	ld.w	r9,r8[0x0]
800072a0:	0c 1c       	sub	r12,r6
800072a2:	89 26       	st.w	r4[0x8],r6
800072a4:	02 0c       	add	r12,r1
800072a6:	12 01       	add	r1,r9
800072a8:	a1 ac       	sbr	r12,0x0
800072aa:	91 01       	st.w	r8[0x0],r1
800072ac:	8d 1c       	st.w	r6[0x4],r12
800072ae:	08 33       	cp.w	r3,r4
800072b0:	c1 d0       	breq	800072ea <_malloc_r+0x3da>
800072b2:	58 f2       	cp.w	r2,15
800072b4:	e0 8b 00 05 	brhi	800072be <_malloc_r+0x3ae>
800072b8:	30 18       	mov	r8,1
800072ba:	8d 18       	st.w	r6[0x4],r8
800072bc:	c2 68       	rjmp	80007308 <_malloc_r+0x3f8>
800072be:	30 59       	mov	r9,5
800072c0:	20 c2       	sub	r2,12
800072c2:	e0 12 ff f8 	andl	r2,0xfff8
800072c6:	e6 02 00 08 	add	r8,r3,r2
800072ca:	91 29       	st.w	r8[0x8],r9
800072cc:	91 19       	st.w	r8[0x4],r9
800072ce:	66 18       	ld.w	r8,r3[0x4]
800072d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800072d4:	e5 e8 10 08 	or	r8,r2,r8
800072d8:	87 18       	st.w	r3[0x4],r8
800072da:	58 f2       	cp.w	r2,15
800072dc:	e0 88 00 07 	brls	800072ea <_malloc_r+0x3da>
800072e0:	e6 cb ff f8 	sub	r11,r3,-8
800072e4:	0a 9c       	mov	r12,r5
800072e6:	e0 a0 1c 89 	rcall	8000abf8 <_free_r>
800072ea:	e0 69 0d 48 	mov	r9,3400
800072ee:	72 0a       	ld.w	r10,r9[0x0]
800072f0:	e0 68 0d 50 	mov	r8,3408
800072f4:	70 08       	ld.w	r8,r8[0x0]
800072f6:	14 38       	cp.w	r8,r10
800072f8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800072fc:	e0 69 0d 44 	mov	r9,3396
80007300:	72 0a       	ld.w	r10,r9[0x0]
80007302:	14 38       	cp.w	r8,r10
80007304:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007308:	68 28       	ld.w	r8,r4[0x8]
8000730a:	70 18       	ld.w	r8,r8[0x4]
8000730c:	e0 18 ff fc 	andl	r8,0xfffc
80007310:	0e 38       	cp.w	r8,r7
80007312:	5f 39       	srlo	r9
80007314:	0e 18       	sub	r8,r7
80007316:	58 f8       	cp.w	r8,15
80007318:	5f aa       	srle	r10
8000731a:	f5 e9 10 09 	or	r9,r10,r9
8000731e:	c0 50       	breq	80007328 <_malloc_r+0x418>
80007320:	0a 9c       	mov	r12,r5
80007322:	fe b0 f3 7b 	rcall	80005a18 <__malloc_unlock>
80007326:	d8 3a       	popm	r0-r7,pc,r12=0
80007328:	68 26       	ld.w	r6,r4[0x8]
8000732a:	a1 a8       	sbr	r8,0x0
8000732c:	0e 99       	mov	r9,r7
8000732e:	a1 a9       	sbr	r9,0x0
80007330:	8d 19       	st.w	r6[0x4],r9
80007332:	ec 07 00 07 	add	r7,r6,r7
80007336:	0a 9c       	mov	r12,r5
80007338:	89 27       	st.w	r4[0x8],r7
8000733a:	8f 18       	st.w	r7[0x4],r8
8000733c:	fe b0 f3 6e 	rcall	80005a18 <__malloc_unlock>
80007340:	ec cc ff f8 	sub	r12,r6,-8
80007344:	d8 32       	popm	r0-r7,pc
80007346:	d7 03       	nop

80007348 <memcmp>:
80007348:	d4 01       	pushm	lr
8000734a:	30 08       	mov	r8,0
8000734c:	c0 d8       	rjmp	80007366 <memcmp+0x1e>
8000734e:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80007352:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007356:	20 1a       	sub	r10,1
80007358:	2f f8       	sub	r8,-1
8000735a:	f2 0e 18 00 	cp.b	lr,r9
8000735e:	c0 40       	breq	80007366 <memcmp+0x1e>
80007360:	fc 09 01 0c 	sub	r12,lr,r9
80007364:	d8 02       	popm	pc
80007366:	58 0a       	cp.w	r10,0
80007368:	cf 31       	brne	8000734e <memcmp+0x6>
8000736a:	14 9c       	mov	r12,r10
8000736c:	d8 02       	popm	pc

8000736e <memcpy>:
8000736e:	58 8a       	cp.w	r10,8
80007370:	c2 f5       	brlt	800073ce <memcpy+0x60>
80007372:	f9 eb 10 09 	or	r9,r12,r11
80007376:	e2 19 00 03 	andl	r9,0x3,COH
8000737a:	e0 81 00 97 	brne	800074a8 <memcpy+0x13a>
8000737e:	e0 4a 00 20 	cp.w	r10,32
80007382:	c3 b4       	brge	800073f8 <memcpy+0x8a>
80007384:	f4 08 14 02 	asr	r8,r10,0x2
80007388:	f0 09 11 08 	rsub	r9,r8,8
8000738c:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007390:	76 69       	ld.w	r9,r11[0x18]
80007392:	99 69       	st.w	r12[0x18],r9
80007394:	76 59       	ld.w	r9,r11[0x14]
80007396:	99 59       	st.w	r12[0x14],r9
80007398:	76 49       	ld.w	r9,r11[0x10]
8000739a:	99 49       	st.w	r12[0x10],r9
8000739c:	76 39       	ld.w	r9,r11[0xc]
8000739e:	99 39       	st.w	r12[0xc],r9
800073a0:	76 29       	ld.w	r9,r11[0x8]
800073a2:	99 29       	st.w	r12[0x8],r9
800073a4:	76 19       	ld.w	r9,r11[0x4]
800073a6:	99 19       	st.w	r12[0x4],r9
800073a8:	76 09       	ld.w	r9,r11[0x0]
800073aa:	99 09       	st.w	r12[0x0],r9
800073ac:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800073b0:	f8 08 00 28 	add	r8,r12,r8<<0x2
800073b4:	e0 1a 00 03 	andl	r10,0x3
800073b8:	f4 0a 11 04 	rsub	r10,r10,4
800073bc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800073c0:	17 a9       	ld.ub	r9,r11[0x2]
800073c2:	b0 a9       	st.b	r8[0x2],r9
800073c4:	17 99       	ld.ub	r9,r11[0x1]
800073c6:	b0 99       	st.b	r8[0x1],r9
800073c8:	17 89       	ld.ub	r9,r11[0x0]
800073ca:	b0 89       	st.b	r8[0x0],r9
800073cc:	5e fc       	retal	r12
800073ce:	f4 0a 11 09 	rsub	r10,r10,9
800073d2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800073d6:	17 f9       	ld.ub	r9,r11[0x7]
800073d8:	b8 f9       	st.b	r12[0x7],r9
800073da:	17 e9       	ld.ub	r9,r11[0x6]
800073dc:	b8 e9       	st.b	r12[0x6],r9
800073de:	17 d9       	ld.ub	r9,r11[0x5]
800073e0:	b8 d9       	st.b	r12[0x5],r9
800073e2:	17 c9       	ld.ub	r9,r11[0x4]
800073e4:	b8 c9       	st.b	r12[0x4],r9
800073e6:	17 b9       	ld.ub	r9,r11[0x3]
800073e8:	b8 b9       	st.b	r12[0x3],r9
800073ea:	17 a9       	ld.ub	r9,r11[0x2]
800073ec:	b8 a9       	st.b	r12[0x2],r9
800073ee:	17 99       	ld.ub	r9,r11[0x1]
800073f0:	b8 99       	st.b	r12[0x1],r9
800073f2:	17 89       	ld.ub	r9,r11[0x0]
800073f4:	b8 89       	st.b	r12[0x0],r9
800073f6:	5e fc       	retal	r12
800073f8:	eb cd 40 c0 	pushm	r6-r7,lr
800073fc:	18 99       	mov	r9,r12
800073fe:	22 0a       	sub	r10,32
80007400:	b7 07       	ld.d	r6,r11++
80007402:	b3 26       	st.d	r9++,r6
80007404:	b7 07       	ld.d	r6,r11++
80007406:	b3 26       	st.d	r9++,r6
80007408:	b7 07       	ld.d	r6,r11++
8000740a:	b3 26       	st.d	r9++,r6
8000740c:	b7 07       	ld.d	r6,r11++
8000740e:	b3 26       	st.d	r9++,r6
80007410:	22 0a       	sub	r10,32
80007412:	cf 74       	brge	80007400 <memcpy+0x92>
80007414:	2f 0a       	sub	r10,-16
80007416:	c0 65       	brlt	80007422 <memcpy+0xb4>
80007418:	b7 07       	ld.d	r6,r11++
8000741a:	b3 26       	st.d	r9++,r6
8000741c:	b7 07       	ld.d	r6,r11++
8000741e:	b3 26       	st.d	r9++,r6
80007420:	21 0a       	sub	r10,16
80007422:	5c 3a       	neg	r10
80007424:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007428:	d7 03       	nop
8000742a:	d7 03       	nop
8000742c:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007430:	f3 66 00 0e 	st.b	r9[14],r6
80007434:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007438:	f3 66 00 0d 	st.b	r9[13],r6
8000743c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007440:	f3 66 00 0c 	st.b	r9[12],r6
80007444:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007448:	f3 66 00 0b 	st.b	r9[11],r6
8000744c:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007450:	f3 66 00 0a 	st.b	r9[10],r6
80007454:	f7 36 00 09 	ld.ub	r6,r11[9]
80007458:	f3 66 00 09 	st.b	r9[9],r6
8000745c:	f7 36 00 08 	ld.ub	r6,r11[8]
80007460:	f3 66 00 08 	st.b	r9[8],r6
80007464:	f7 36 00 07 	ld.ub	r6,r11[7]
80007468:	f3 66 00 07 	st.b	r9[7],r6
8000746c:	f7 36 00 06 	ld.ub	r6,r11[6]
80007470:	f3 66 00 06 	st.b	r9[6],r6
80007474:	f7 36 00 05 	ld.ub	r6,r11[5]
80007478:	f3 66 00 05 	st.b	r9[5],r6
8000747c:	f7 36 00 04 	ld.ub	r6,r11[4]
80007480:	f3 66 00 04 	st.b	r9[4],r6
80007484:	f7 36 00 03 	ld.ub	r6,r11[3]
80007488:	f3 66 00 03 	st.b	r9[3],r6
8000748c:	f7 36 00 02 	ld.ub	r6,r11[2]
80007490:	f3 66 00 02 	st.b	r9[2],r6
80007494:	f7 36 00 01 	ld.ub	r6,r11[1]
80007498:	f3 66 00 01 	st.b	r9[1],r6
8000749c:	f7 36 00 00 	ld.ub	r6,r11[0]
800074a0:	f3 66 00 00 	st.b	r9[0],r6
800074a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800074a8:	20 1a       	sub	r10,1
800074aa:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800074ae:	f8 0a 0b 09 	st.b	r12[r10],r9
800074b2:	cf b1       	brne	800074a8 <memcpy+0x13a>
800074b4:	5e fc       	retal	r12

800074b6 <memset>:
800074b6:	18 98       	mov	r8,r12
800074b8:	c0 38       	rjmp	800074be <memset+0x8>
800074ba:	10 cb       	st.b	r8++,r11
800074bc:	20 1a       	sub	r10,1
800074be:	58 0a       	cp.w	r10,0
800074c0:	cf d1       	brne	800074ba <memset+0x4>
800074c2:	5e fc       	retal	r12

800074c4 <_realloc_r>:
800074c4:	d4 31       	pushm	r0-r7,lr
800074c6:	20 1d       	sub	sp,4
800074c8:	16 94       	mov	r4,r11
800074ca:	18 92       	mov	r2,r12
800074cc:	14 9b       	mov	r11,r10
800074ce:	58 04       	cp.w	r4,0
800074d0:	c0 51       	brne	800074da <_realloc_r+0x16>
800074d2:	fe b0 fd 1f 	rcall	80006f10 <_malloc_r>
800074d6:	18 95       	mov	r5,r12
800074d8:	c5 39       	rjmp	8000777e <_realloc_r+0x2ba>
800074da:	50 0a       	stdsp	sp[0x0],r10
800074dc:	fe b0 f2 98 	rcall	80005a0c <__malloc_lock>
800074e0:	40 0b       	lddsp	r11,sp[0x0]
800074e2:	f6 c8 ff f5 	sub	r8,r11,-11
800074e6:	e8 c1 00 08 	sub	r1,r4,8
800074ea:	10 96       	mov	r6,r8
800074ec:	62 1c       	ld.w	r12,r1[0x4]
800074ee:	e0 16 ff f8 	andl	r6,0xfff8
800074f2:	59 68       	cp.w	r8,22
800074f4:	f9 b6 08 10 	movls	r6,16
800074f8:	16 36       	cp.w	r6,r11
800074fa:	5f 38       	srlo	r8
800074fc:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007500:	c0 50       	breq	8000750a <_realloc_r+0x46>
80007502:	30 c8       	mov	r8,12
80007504:	30 05       	mov	r5,0
80007506:	85 38       	st.w	r2[0xc],r8
80007508:	c3 b9       	rjmp	8000777e <_realloc_r+0x2ba>
8000750a:	18 90       	mov	r0,r12
8000750c:	e0 10 ff fc 	andl	r0,0xfffc
80007510:	0c 30       	cp.w	r0,r6
80007512:	e0 84 01 0b 	brge	80007728 <_realloc_r+0x264>
80007516:	e0 68 05 3c 	mov	r8,1340
8000751a:	e2 00 00 09 	add	r9,r1,r0
8000751e:	70 25       	ld.w	r5,r8[0x8]
80007520:	0a 39       	cp.w	r9,r5
80007522:	c0 90       	breq	80007534 <_realloc_r+0x70>
80007524:	72 1a       	ld.w	r10,r9[0x4]
80007526:	a1 ca       	cbr	r10,0x0
80007528:	f2 0a 00 0a 	add	r10,r9,r10
8000752c:	74 1a       	ld.w	r10,r10[0x4]
8000752e:	ed ba 00 00 	bld	r10,0x0
80007532:	c2 20       	breq	80007576 <_realloc_r+0xb2>
80007534:	72 1a       	ld.w	r10,r9[0x4]
80007536:	e0 1a ff fc 	andl	r10,0xfffc
8000753a:	f4 00 00 03 	add	r3,r10,r0
8000753e:	0a 39       	cp.w	r9,r5
80007540:	c1 31       	brne	80007566 <_realloc_r+0xa2>
80007542:	ec c7 ff f0 	sub	r7,r6,-16
80007546:	0e 33       	cp.w	r3,r7
80007548:	c1 95       	brlt	8000757a <_realloc_r+0xb6>
8000754a:	e2 06 00 09 	add	r9,r1,r6
8000754e:	0c 13       	sub	r3,r6
80007550:	a1 a3       	sbr	r3,0x0
80007552:	93 13       	st.w	r9[0x4],r3
80007554:	91 29       	st.w	r8[0x8],r9
80007556:	04 9c       	mov	r12,r2
80007558:	62 18       	ld.w	r8,r1[0x4]
8000755a:	08 95       	mov	r5,r4
8000755c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007560:	10 46       	or	r6,r8
80007562:	83 16       	st.w	r1[0x4],r6
80007564:	c0 b9       	rjmp	8000777a <_realloc_r+0x2b6>
80007566:	0c 33       	cp.w	r3,r6
80007568:	c0 95       	brlt	8000757a <_realloc_r+0xb6>
8000756a:	72 28       	ld.w	r8,r9[0x8]
8000756c:	02 97       	mov	r7,r1
8000756e:	72 39       	ld.w	r9,r9[0xc]
80007570:	93 28       	st.w	r9[0x8],r8
80007572:	91 39       	st.w	r8[0xc],r9
80007574:	cd c8       	rjmp	8000772c <_realloc_r+0x268>
80007576:	30 0a       	mov	r10,0
80007578:	14 99       	mov	r9,r10
8000757a:	ed bc 00 00 	bld	r12,0x0
8000757e:	e0 80 00 95 	breq	800076a8 <_realloc_r+0x1e4>
80007582:	62 07       	ld.w	r7,r1[0x0]
80007584:	e2 07 01 07 	sub	r7,r1,r7
80007588:	6e 1c       	ld.w	r12,r7[0x4]
8000758a:	e0 1c ff fc 	andl	r12,0xfffc
8000758e:	58 09       	cp.w	r9,0
80007590:	c5 60       	breq	8000763c <_realloc_r+0x178>
80007592:	f8 00 00 03 	add	r3,r12,r0
80007596:	0a 39       	cp.w	r9,r5
80007598:	c4 81       	brne	80007628 <_realloc_r+0x164>
8000759a:	14 03       	add	r3,r10
8000759c:	ec c9 ff f0 	sub	r9,r6,-16
800075a0:	12 33       	cp.w	r3,r9
800075a2:	c4 d5       	brlt	8000763c <_realloc_r+0x178>
800075a4:	6e 3a       	ld.w	r10,r7[0xc]
800075a6:	6e 29       	ld.w	r9,r7[0x8]
800075a8:	95 29       	st.w	r10[0x8],r9
800075aa:	93 3a       	st.w	r9[0xc],r10
800075ac:	ee c5 ff f8 	sub	r5,r7,-8
800075b0:	e0 ca 00 04 	sub	r10,r0,4
800075b4:	e0 4a 00 24 	cp.w	r10,36
800075b8:	e0 8b 00 25 	brhi	80007602 <_realloc_r+0x13e>
800075bc:	0a 99       	mov	r9,r5
800075be:	59 3a       	cp.w	r10,19
800075c0:	e0 88 00 1a 	brls	800075f4 <_realloc_r+0x130>
800075c4:	09 09       	ld.w	r9,r4++
800075c6:	8b 09       	st.w	r5[0x0],r9
800075c8:	09 09       	ld.w	r9,r4++
800075ca:	8f 39       	st.w	r7[0xc],r9
800075cc:	ee c9 ff f0 	sub	r9,r7,-16
800075d0:	59 ba       	cp.w	r10,27
800075d2:	e0 88 00 11 	brls	800075f4 <_realloc_r+0x130>
800075d6:	09 0b       	ld.w	r11,r4++
800075d8:	93 0b       	st.w	r9[0x0],r11
800075da:	09 09       	ld.w	r9,r4++
800075dc:	8f 59       	st.w	r7[0x14],r9
800075de:	ee c9 ff e8 	sub	r9,r7,-24
800075e2:	e0 4a 00 24 	cp.w	r10,36
800075e6:	c0 71       	brne	800075f4 <_realloc_r+0x130>
800075e8:	09 0a       	ld.w	r10,r4++
800075ea:	93 0a       	st.w	r9[0x0],r10
800075ec:	ee c9 ff e0 	sub	r9,r7,-32
800075f0:	09 0a       	ld.w	r10,r4++
800075f2:	8f 7a       	st.w	r7[0x1c],r10
800075f4:	09 0a       	ld.w	r10,r4++
800075f6:	12 aa       	st.w	r9++,r10
800075f8:	68 0a       	ld.w	r10,r4[0x0]
800075fa:	93 0a       	st.w	r9[0x0],r10
800075fc:	68 1a       	ld.w	r10,r4[0x4]
800075fe:	93 1a       	st.w	r9[0x4],r10
80007600:	c0 78       	rjmp	8000760e <_realloc_r+0x14a>
80007602:	50 08       	stdsp	sp[0x0],r8
80007604:	08 9b       	mov	r11,r4
80007606:	0a 9c       	mov	r12,r5
80007608:	e0 a0 1d 9b 	rcall	8000b13e <memmove>
8000760c:	40 08       	lddsp	r8,sp[0x0]
8000760e:	ee 06 00 09 	add	r9,r7,r6
80007612:	0c 13       	sub	r3,r6
80007614:	a1 a3       	sbr	r3,0x0
80007616:	93 13       	st.w	r9[0x4],r3
80007618:	91 29       	st.w	r8[0x8],r9
8000761a:	04 9c       	mov	r12,r2
8000761c:	6e 18       	ld.w	r8,r7[0x4]
8000761e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007622:	10 46       	or	r6,r8
80007624:	8f 16       	st.w	r7[0x4],r6
80007626:	ca a8       	rjmp	8000777a <_realloc_r+0x2b6>
80007628:	14 03       	add	r3,r10
8000762a:	0c 33       	cp.w	r3,r6
8000762c:	c0 85       	brlt	8000763c <_realloc_r+0x178>
8000762e:	72 28       	ld.w	r8,r9[0x8]
80007630:	72 39       	ld.w	r9,r9[0xc]
80007632:	93 28       	st.w	r9[0x8],r8
80007634:	91 39       	st.w	r8[0xc],r9
80007636:	6e 28       	ld.w	r8,r7[0x8]
80007638:	6e 39       	ld.w	r9,r7[0xc]
8000763a:	c0 78       	rjmp	80007648 <_realloc_r+0x184>
8000763c:	f8 00 00 03 	add	r3,r12,r0
80007640:	0c 33       	cp.w	r3,r6
80007642:	c3 35       	brlt	800076a8 <_realloc_r+0x1e4>
80007644:	6e 39       	ld.w	r9,r7[0xc]
80007646:	6e 28       	ld.w	r8,r7[0x8]
80007648:	93 28       	st.w	r9[0x8],r8
8000764a:	91 39       	st.w	r8[0xc],r9
8000764c:	e0 ca 00 04 	sub	r10,r0,4
80007650:	ee cc ff f8 	sub	r12,r7,-8
80007654:	e0 4a 00 24 	cp.w	r10,36
80007658:	e0 8b 00 24 	brhi	800076a0 <_realloc_r+0x1dc>
8000765c:	59 3a       	cp.w	r10,19
8000765e:	e0 88 00 1a 	brls	80007692 <_realloc_r+0x1ce>
80007662:	09 08       	ld.w	r8,r4++
80007664:	99 08       	st.w	r12[0x0],r8
80007666:	09 08       	ld.w	r8,r4++
80007668:	8f 38       	st.w	r7[0xc],r8
8000766a:	ee cc ff f0 	sub	r12,r7,-16
8000766e:	59 ba       	cp.w	r10,27
80007670:	e0 88 00 11 	brls	80007692 <_realloc_r+0x1ce>
80007674:	09 08       	ld.w	r8,r4++
80007676:	99 08       	st.w	r12[0x0],r8
80007678:	09 08       	ld.w	r8,r4++
8000767a:	8f 58       	st.w	r7[0x14],r8
8000767c:	ee cc ff e8 	sub	r12,r7,-24
80007680:	e0 4a 00 24 	cp.w	r10,36
80007684:	c0 71       	brne	80007692 <_realloc_r+0x1ce>
80007686:	09 08       	ld.w	r8,r4++
80007688:	99 08       	st.w	r12[0x0],r8
8000768a:	ee cc ff e0 	sub	r12,r7,-32
8000768e:	09 08       	ld.w	r8,r4++
80007690:	8f 78       	st.w	r7[0x1c],r8
80007692:	09 08       	ld.w	r8,r4++
80007694:	18 a8       	st.w	r12++,r8
80007696:	68 08       	ld.w	r8,r4[0x0]
80007698:	99 08       	st.w	r12[0x0],r8
8000769a:	68 18       	ld.w	r8,r4[0x4]
8000769c:	99 18       	st.w	r12[0x4],r8
8000769e:	c4 78       	rjmp	8000772c <_realloc_r+0x268>
800076a0:	08 9b       	mov	r11,r4
800076a2:	e0 a0 1d 4e 	rcall	8000b13e <memmove>
800076a6:	c4 38       	rjmp	8000772c <_realloc_r+0x268>
800076a8:	04 9c       	mov	r12,r2
800076aa:	fe b0 fc 33 	rcall	80006f10 <_malloc_r>
800076ae:	18 95       	mov	r5,r12
800076b0:	c3 a0       	breq	80007724 <_realloc_r+0x260>
800076b2:	62 18       	ld.w	r8,r1[0x4]
800076b4:	f8 c9 00 08 	sub	r9,r12,8
800076b8:	a1 c8       	cbr	r8,0x0
800076ba:	e2 08 00 08 	add	r8,r1,r8
800076be:	10 39       	cp.w	r9,r8
800076c0:	c0 71       	brne	800076ce <_realloc_r+0x20a>
800076c2:	72 13       	ld.w	r3,r9[0x4]
800076c4:	02 97       	mov	r7,r1
800076c6:	e0 13 ff fc 	andl	r3,0xfffc
800076ca:	00 03       	add	r3,r0
800076cc:	c3 08       	rjmp	8000772c <_realloc_r+0x268>
800076ce:	e0 ca 00 04 	sub	r10,r0,4
800076d2:	e0 4a 00 24 	cp.w	r10,36
800076d6:	e0 8b 00 20 	brhi	80007716 <_realloc_r+0x252>
800076da:	08 99       	mov	r9,r4
800076dc:	18 98       	mov	r8,r12
800076de:	59 3a       	cp.w	r10,19
800076e0:	e0 88 00 14 	brls	80007708 <_realloc_r+0x244>
800076e4:	13 0b       	ld.w	r11,r9++
800076e6:	10 ab       	st.w	r8++,r11
800076e8:	13 0b       	ld.w	r11,r9++
800076ea:	10 ab       	st.w	r8++,r11
800076ec:	59 ba       	cp.w	r10,27
800076ee:	e0 88 00 0d 	brls	80007708 <_realloc_r+0x244>
800076f2:	13 0b       	ld.w	r11,r9++
800076f4:	10 ab       	st.w	r8++,r11
800076f6:	13 0b       	ld.w	r11,r9++
800076f8:	10 ab       	st.w	r8++,r11
800076fa:	e0 4a 00 24 	cp.w	r10,36
800076fe:	c0 51       	brne	80007708 <_realloc_r+0x244>
80007700:	13 0a       	ld.w	r10,r9++
80007702:	10 aa       	st.w	r8++,r10
80007704:	13 0a       	ld.w	r10,r9++
80007706:	10 aa       	st.w	r8++,r10
80007708:	13 0a       	ld.w	r10,r9++
8000770a:	10 aa       	st.w	r8++,r10
8000770c:	72 0a       	ld.w	r10,r9[0x0]
8000770e:	91 0a       	st.w	r8[0x0],r10
80007710:	72 19       	ld.w	r9,r9[0x4]
80007712:	91 19       	st.w	r8[0x4],r9
80007714:	c0 48       	rjmp	8000771c <_realloc_r+0x258>
80007716:	08 9b       	mov	r11,r4
80007718:	e0 a0 1d 13 	rcall	8000b13e <memmove>
8000771c:	08 9b       	mov	r11,r4
8000771e:	04 9c       	mov	r12,r2
80007720:	e0 a0 1a 6c 	rcall	8000abf8 <_free_r>
80007724:	04 9c       	mov	r12,r2
80007726:	c2 a8       	rjmp	8000777a <_realloc_r+0x2b6>
80007728:	00 93       	mov	r3,r0
8000772a:	02 97       	mov	r7,r1
8000772c:	e6 06 01 09 	sub	r9,r3,r6
80007730:	6e 18       	ld.w	r8,r7[0x4]
80007732:	58 f9       	cp.w	r9,15
80007734:	e0 88 00 16 	brls	80007760 <_realloc_r+0x29c>
80007738:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000773c:	ed e8 10 08 	or	r8,r6,r8
80007740:	8f 18       	st.w	r7[0x4],r8
80007742:	12 98       	mov	r8,r9
80007744:	a1 a8       	sbr	r8,0x0
80007746:	ee 06 00 0b 	add	r11,r7,r6
8000774a:	f6 09 00 09 	add	r9,r11,r9
8000774e:	97 18       	st.w	r11[0x4],r8
80007750:	72 18       	ld.w	r8,r9[0x4]
80007752:	a1 a8       	sbr	r8,0x0
80007754:	2f 8b       	sub	r11,-8
80007756:	93 18       	st.w	r9[0x4],r8
80007758:	04 9c       	mov	r12,r2
8000775a:	e0 a0 1a 4f 	rcall	8000abf8 <_free_r>
8000775e:	c0 b8       	rjmp	80007774 <_realloc_r+0x2b0>
80007760:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007764:	e7 e8 10 08 	or	r8,r3,r8
80007768:	8f 18       	st.w	r7[0x4],r8
8000776a:	ee 03 00 03 	add	r3,r7,r3
8000776e:	66 18       	ld.w	r8,r3[0x4]
80007770:	a1 a8       	sbr	r8,0x0
80007772:	87 18       	st.w	r3[0x4],r8
80007774:	04 9c       	mov	r12,r2
80007776:	ee c5 ff f8 	sub	r5,r7,-8
8000777a:	fe b0 f1 4f 	rcall	80005a18 <__malloc_unlock>
8000777e:	0a 9c       	mov	r12,r5
80007780:	2f fd       	sub	sp,-4
80007782:	d8 32       	popm	r0-r7,pc

80007784 <_sbrk_r>:
80007784:	d4 21       	pushm	r4-r7,lr
80007786:	30 08       	mov	r8,0
80007788:	18 97       	mov	r7,r12
8000778a:	e0 66 51 00 	mov	r6,20736
8000778e:	16 9c       	mov	r12,r11
80007790:	8d 08       	st.w	r6[0x0],r8
80007792:	c9 1c       	rcall	800078b4 <_sbrk>
80007794:	5b fc       	cp.w	r12,-1
80007796:	c0 51       	brne	800077a0 <_sbrk_r+0x1c>
80007798:	6c 08       	ld.w	r8,r6[0x0]
8000779a:	58 08       	cp.w	r8,0
8000779c:	ef f8 1a 03 	st.wne	r7[0xc],r8
800077a0:	d8 22       	popm	r4-r7,pc
800077a2:	d7 03       	nop

800077a4 <sprintf>:
800077a4:	d4 01       	pushm	lr
800077a6:	21 7d       	sub	sp,92
800077a8:	e0 68 ff ff 	mov	r8,65535
800077ac:	ea 18 7f ff 	orh	r8,0x7fff
800077b0:	50 58       	stdsp	sp[0x14],r8
800077b2:	50 28       	stdsp	sp[0x8],r8
800077b4:	e0 68 02 08 	mov	r8,520
800077b8:	ba 68       	st.h	sp[0xc],r8
800077ba:	3f f8       	mov	r8,-1
800077bc:	ba 78       	st.h	sp[0xe],r8
800077be:	e0 68 0a 3c 	mov	r8,2620
800077c2:	50 4c       	stdsp	sp[0x10],r12
800077c4:	16 9a       	mov	r10,r11
800077c6:	50 0c       	stdsp	sp[0x0],r12
800077c8:	fa c9 ff a0 	sub	r9,sp,-96
800077cc:	70 0c       	ld.w	r12,r8[0x0]
800077ce:	1a 9b       	mov	r11,sp
800077d0:	e0 a0 02 26 	rcall	80007c1c <_vfprintf_r>
800077d4:	30 09       	mov	r9,0
800077d6:	40 08       	lddsp	r8,sp[0x0]
800077d8:	b0 89       	st.b	r8[0x0],r9
800077da:	2e 9d       	sub	sp,-92
800077dc:	d8 02       	popm	pc
800077de:	d7 03       	nop

800077e0 <strlen>:
800077e0:	30 09       	mov	r9,0
800077e2:	18 98       	mov	r8,r12
800077e4:	c0 28       	rjmp	800077e8 <strlen+0x8>
800077e6:	2f f8       	sub	r8,-1
800077e8:	11 8a       	ld.ub	r10,r8[0x0]
800077ea:	f2 0a 18 00 	cp.b	r10,r9
800077ee:	cf c1       	brne	800077e6 <strlen+0x6>
800077f0:	f0 0c 01 0c 	sub	r12,r8,r12
800077f4:	5e fc       	retal	r12
800077f6:	d7 03       	nop

800077f8 <strncpy>:
800077f8:	30 08       	mov	r8,0
800077fa:	10 3a       	cp.w	r10,r8
800077fc:	5e 0c       	reteq	r12
800077fe:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007802:	f8 08 0b 09 	st.b	r12[r8],r9
80007806:	2f f8       	sub	r8,-1
80007808:	58 09       	cp.w	r9,0
8000780a:	cf 81       	brne	800077fa <strncpy+0x2>
8000780c:	10 3a       	cp.w	r10,r8
8000780e:	5e 0c       	reteq	r12
80007810:	f8 08 0b 09 	st.b	r12[r8],r9
80007814:	2f f8       	sub	r8,-1
80007816:	cf bb       	rjmp	8000780c <strncpy+0x14>

80007818 <_close>:
80007818:	30 28       	mov	r8,2
8000781a:	d6 73       	breakpoint
8000781c:	3f fc       	mov	r12,-1
8000781e:	35 8b       	mov	r11,88
80007820:	58 0c       	cp.w	r12,0
80007822:	5e 4c       	retge	r12
80007824:	e0 6a 51 00 	mov	r10,20736
80007828:	95 0b       	st.w	r10[0x0],r11
8000782a:	5e fc       	retal	r12

8000782c <_lseek>:
8000782c:	30 58       	mov	r8,5
8000782e:	d6 73       	breakpoint
80007830:	3f fc       	mov	r12,-1
80007832:	35 8b       	mov	r11,88
80007834:	58 0c       	cp.w	r12,0
80007836:	5e 4c       	retge	r12
80007838:	e0 6a 51 00 	mov	r10,20736
8000783c:	95 0b       	st.w	r10[0x0],r11
8000783e:	5e fc       	retal	r12

80007840 <isatty>:
80007840:	30 b8       	mov	r8,11
80007842:	d6 73       	breakpoint
80007844:	3f fc       	mov	r12,-1
80007846:	35 8b       	mov	r11,88
80007848:	58 0c       	cp.w	r12,0
8000784a:	5e 4c       	retge	r12
8000784c:	e0 6a 51 00 	mov	r10,20736
80007850:	95 0b       	st.w	r10[0x0],r11
80007852:	5e fc       	retal	r12

80007854 <_fstat_host>:
80007854:	30 98       	mov	r8,9
80007856:	d6 73       	breakpoint
80007858:	3f fc       	mov	r12,-1
8000785a:	35 8b       	mov	r11,88
8000785c:	58 0c       	cp.w	r12,0
8000785e:	5e 4c       	retge	r12
80007860:	e0 6a 51 00 	mov	r10,20736
80007864:	95 0b       	st.w	r10[0x0],r11
80007866:	5e fc       	retal	r12

80007868 <_fstat>:
80007868:	d4 21       	pushm	r4-r7,lr
8000786a:	21 0d       	sub	sp,64
8000786c:	16 97       	mov	r7,r11
8000786e:	1a 9b       	mov	r11,sp
80007870:	cf 2f       	rcall	80007854 <_fstat_host>
80007872:	c0 34       	brge	80007878 <_fstat+0x10>
80007874:	3f fc       	mov	r12,-1
80007876:	c1 c8       	rjmp	800078ae <_fstat+0x46>
80007878:	40 08       	lddsp	r8,sp[0x0]
8000787a:	ae 08       	st.h	r7[0x0],r8
8000787c:	40 18       	lddsp	r8,sp[0x4]
8000787e:	ae 18       	st.h	r7[0x2],r8
80007880:	40 28       	lddsp	r8,sp[0x8]
80007882:	8f 18       	st.w	r7[0x4],r8
80007884:	40 38       	lddsp	r8,sp[0xc]
80007886:	ae 48       	st.h	r7[0x8],r8
80007888:	40 48       	lddsp	r8,sp[0x10]
8000788a:	ae 58       	st.h	r7[0xa],r8
8000788c:	40 58       	lddsp	r8,sp[0x14]
8000788e:	ae 68       	st.h	r7[0xc],r8
80007890:	40 68       	lddsp	r8,sp[0x18]
80007892:	ae 78       	st.h	r7[0xe],r8
80007894:	40 88       	lddsp	r8,sp[0x20]
80007896:	8f 48       	st.w	r7[0x10],r8
80007898:	40 a8       	lddsp	r8,sp[0x28]
8000789a:	8f b8       	st.w	r7[0x2c],r8
8000789c:	40 c8       	lddsp	r8,sp[0x30]
8000789e:	8f c8       	st.w	r7[0x30],r8
800078a0:	40 d8       	lddsp	r8,sp[0x34]
800078a2:	8f 58       	st.w	r7[0x14],r8
800078a4:	40 e8       	lddsp	r8,sp[0x38]
800078a6:	30 0c       	mov	r12,0
800078a8:	8f 78       	st.w	r7[0x1c],r8
800078aa:	40 f8       	lddsp	r8,sp[0x3c]
800078ac:	8f 98       	st.w	r7[0x24],r8
800078ae:	2f 0d       	sub	sp,-64
800078b0:	d8 22       	popm	r4-r7,pc
800078b2:	d7 03       	nop

800078b4 <_sbrk>:
800078b4:	d4 01       	pushm	lr
800078b6:	e0 68 0d 78 	mov	r8,3448
800078ba:	70 09       	ld.w	r9,r8[0x0]
800078bc:	58 09       	cp.w	r9,0
800078be:	c0 41       	brne	800078c6 <_sbrk+0x12>
800078c0:	e0 69 51 08 	mov	r9,20744
800078c4:	91 09       	st.w	r8[0x0],r9
800078c6:	e0 69 0d 78 	mov	r9,3448
800078ca:	e0 7a 70 00 	mov	r10,94208
800078ce:	72 08       	ld.w	r8,r9[0x0]
800078d0:	f0 0c 00 0c 	add	r12,r8,r12
800078d4:	14 3c       	cp.w	r12,r10
800078d6:	e0 8b 00 04 	brhi	800078de <_sbrk+0x2a>
800078da:	93 0c       	st.w	r9[0x0],r12
800078dc:	c0 68       	rjmp	800078e8 <_sbrk+0x34>
800078de:	e0 a0 18 15 	rcall	8000a908 <__errno>
800078e2:	30 c8       	mov	r8,12
800078e4:	99 08       	st.w	r12[0x0],r8
800078e6:	3f f8       	mov	r8,-1
800078e8:	10 9c       	mov	r12,r8
800078ea:	d8 02       	popm	pc

800078ec <get_arg>:
800078ec:	d4 31       	pushm	r0-r7,lr
800078ee:	20 8d       	sub	sp,32
800078f0:	fa c4 ff bc 	sub	r4,sp,-68
800078f4:	50 4b       	stdsp	sp[0x10],r11
800078f6:	68 2e       	ld.w	lr,r4[0x8]
800078f8:	50 58       	stdsp	sp[0x14],r8
800078fa:	12 96       	mov	r6,r9
800078fc:	7c 0b       	ld.w	r11,lr[0x0]
800078fe:	70 05       	ld.w	r5,r8[0x0]
80007900:	50 6e       	stdsp	sp[0x18],lr
80007902:	58 0b       	cp.w	r11,0
80007904:	f4 0b 17 00 	moveq	r11,r10
80007908:	68 03       	ld.w	r3,r4[0x0]
8000790a:	68 11       	ld.w	r1,r4[0x4]
8000790c:	40 49       	lddsp	r9,sp[0x10]
8000790e:	30 08       	mov	r8,0
80007910:	c2 89       	rjmp	80007b60 <get_arg+0x274>
80007912:	2f fb       	sub	r11,-1
80007914:	32 5c       	mov	r12,37
80007916:	17 8a       	ld.ub	r10,r11[0x0]
80007918:	f8 0a 18 00 	cp.b	r10,r12
8000791c:	5f 1e       	srne	lr
8000791e:	f0 0a 18 00 	cp.b	r10,r8
80007922:	5f 1c       	srne	r12
80007924:	fd ec 00 0c 	and	r12,lr,r12
80007928:	f0 0c 18 00 	cp.b	r12,r8
8000792c:	cf 31       	brne	80007912 <get_arg+0x26>
8000792e:	58 0a       	cp.w	r10,0
80007930:	e0 80 01 25 	breq	80007b7a <get_arg+0x28e>
80007934:	30 0c       	mov	r12,0
80007936:	3f fa       	mov	r10,-1
80007938:	18 90       	mov	r0,r12
8000793a:	50 3a       	stdsp	sp[0xc],r10
8000793c:	18 94       	mov	r4,r12
8000793e:	18 92       	mov	r2,r12
80007940:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007944:	16 97       	mov	r7,r11
80007946:	50 7c       	stdsp	sp[0x1c],r12
80007948:	fe cc a0 14 	sub	r12,pc,-24556
8000794c:	0f 3a       	ld.ub	r10,r7++
8000794e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007952:	40 7c       	lddsp	r12,sp[0x1c]
80007954:	1c 0c       	add	r12,lr
80007956:	fe ce a0 ea 	sub	lr,pc,-24342
8000795a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000795e:	20 1e       	sub	lr,1
80007960:	50 0e       	stdsp	sp[0x0],lr
80007962:	fe ce a1 62 	sub	lr,pc,-24222
80007966:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000796a:	50 7c       	stdsp	sp[0x1c],r12
8000796c:	40 0c       	lddsp	r12,sp[0x0]
8000796e:	58 7c       	cp.w	r12,7
80007970:	e0 8b 00 f1 	brhi	80007b52 <get_arg+0x266>
80007974:	fe ce a3 14 	sub	lr,pc,-23788
80007978:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000797c:	36 8b       	mov	r11,104
8000797e:	f6 0a 18 00 	cp.b	r10,r11
80007982:	e0 80 00 e8 	breq	80007b52 <get_arg+0x266>
80007986:	37 1b       	mov	r11,113
80007988:	f6 0a 18 00 	cp.b	r10,r11
8000798c:	c0 70       	breq	8000799a <get_arg+0xae>
8000798e:	34 cb       	mov	r11,76
80007990:	f6 0a 18 00 	cp.b	r10,r11
80007994:	c0 51       	brne	8000799e <get_arg+0xb2>
80007996:	a3 b4       	sbr	r4,0x3
80007998:	cd d8       	rjmp	80007b52 <get_arg+0x266>
8000799a:	a5 b4       	sbr	r4,0x5
8000799c:	cd b8       	rjmp	80007b52 <get_arg+0x266>
8000799e:	08 9a       	mov	r10,r4
800079a0:	0e 9b       	mov	r11,r7
800079a2:	a5 aa       	sbr	r10,0x4
800079a4:	17 3c       	ld.ub	r12,r11++
800079a6:	a5 b4       	sbr	r4,0x5
800079a8:	36 ce       	mov	lr,108
800079aa:	fc 0c 18 00 	cp.b	r12,lr
800079ae:	e0 80 00 d3 	breq	80007b54 <get_arg+0x268>
800079b2:	14 94       	mov	r4,r10
800079b4:	cc f8       	rjmp	80007b52 <get_arg+0x266>
800079b6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800079ba:	36 7c       	mov	r12,103
800079bc:	f8 0a 18 00 	cp.b	r10,r12
800079c0:	e0 8b 00 27 	brhi	80007a0e <get_arg+0x122>
800079c4:	36 5b       	mov	r11,101
800079c6:	f6 0a 18 00 	cp.b	r10,r11
800079ca:	c4 82       	brcc	80007a5a <get_arg+0x16e>
800079cc:	34 fb       	mov	r11,79
800079ce:	f6 0a 18 00 	cp.b	r10,r11
800079d2:	c4 80       	breq	80007a62 <get_arg+0x176>
800079d4:	e0 8b 00 0c 	brhi	800079ec <get_arg+0x100>
800079d8:	34 5b       	mov	r11,69
800079da:	f6 0a 18 00 	cp.b	r10,r11
800079de:	c3 e0       	breq	80007a5a <get_arg+0x16e>
800079e0:	34 7b       	mov	r11,71
800079e2:	f6 0a 18 00 	cp.b	r10,r11
800079e6:	c3 a0       	breq	80007a5a <get_arg+0x16e>
800079e8:	34 4b       	mov	r11,68
800079ea:	c0 88       	rjmp	800079fa <get_arg+0x10e>
800079ec:	35 8b       	mov	r11,88
800079ee:	f6 0a 18 00 	cp.b	r10,r11
800079f2:	c2 c0       	breq	80007a4a <get_arg+0x15e>
800079f4:	e0 8b 00 07 	brhi	80007a02 <get_arg+0x116>
800079f8:	35 5b       	mov	r11,85
800079fa:	f6 0a 18 00 	cp.b	r10,r11
800079fe:	c3 51       	brne	80007a68 <get_arg+0x17c>
80007a00:	c3 18       	rjmp	80007a62 <get_arg+0x176>
80007a02:	36 3b       	mov	r11,99
80007a04:	f6 0a 18 00 	cp.b	r10,r11
80007a08:	c2 f0       	breq	80007a66 <get_arg+0x17a>
80007a0a:	36 4b       	mov	r11,100
80007a0c:	c0 e8       	rjmp	80007a28 <get_arg+0x13c>
80007a0e:	37 0b       	mov	r11,112
80007a10:	f6 0a 18 00 	cp.b	r10,r11
80007a14:	c2 50       	breq	80007a5e <get_arg+0x172>
80007a16:	e0 8b 00 0d 	brhi	80007a30 <get_arg+0x144>
80007a1a:	36 eb       	mov	r11,110
80007a1c:	f6 0a 18 00 	cp.b	r10,r11
80007a20:	c1 f0       	breq	80007a5e <get_arg+0x172>
80007a22:	e0 8b 00 14 	brhi	80007a4a <get_arg+0x15e>
80007a26:	36 9b       	mov	r11,105
80007a28:	f6 0a 18 00 	cp.b	r10,r11
80007a2c:	c1 e1       	brne	80007a68 <get_arg+0x17c>
80007a2e:	c0 e8       	rjmp	80007a4a <get_arg+0x15e>
80007a30:	37 5b       	mov	r11,117
80007a32:	f6 0a 18 00 	cp.b	r10,r11
80007a36:	c0 a0       	breq	80007a4a <get_arg+0x15e>
80007a38:	37 8b       	mov	r11,120
80007a3a:	f6 0a 18 00 	cp.b	r10,r11
80007a3e:	c0 60       	breq	80007a4a <get_arg+0x15e>
80007a40:	37 3b       	mov	r11,115
80007a42:	f6 0a 18 00 	cp.b	r10,r11
80007a46:	c1 11       	brne	80007a68 <get_arg+0x17c>
80007a48:	c0 b8       	rjmp	80007a5e <get_arg+0x172>
80007a4a:	ed b4 00 04 	bld	r4,0x4
80007a4e:	c0 a0       	breq	80007a62 <get_arg+0x176>
80007a50:	ed b4 00 05 	bld	r4,0x5
80007a54:	c0 91       	brne	80007a66 <get_arg+0x17a>
80007a56:	30 20       	mov	r0,2
80007a58:	c0 88       	rjmp	80007a68 <get_arg+0x17c>
80007a5a:	30 40       	mov	r0,4
80007a5c:	c0 68       	rjmp	80007a68 <get_arg+0x17c>
80007a5e:	30 30       	mov	r0,3
80007a60:	c0 48       	rjmp	80007a68 <get_arg+0x17c>
80007a62:	30 10       	mov	r0,1
80007a64:	c0 28       	rjmp	80007a68 <get_arg+0x17c>
80007a66:	30 00       	mov	r0,0
80007a68:	40 3b       	lddsp	r11,sp[0xc]
80007a6a:	5b fb       	cp.w	r11,-1
80007a6c:	c0 40       	breq	80007a74 <get_arg+0x188>
80007a6e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007a72:	c7 08       	rjmp	80007b52 <get_arg+0x266>
80007a74:	58 60       	cp.w	r0,6
80007a76:	e0 8b 00 6e 	brhi	80007b52 <get_arg+0x266>
80007a7a:	6c 0a       	ld.w	r10,r6[0x0]
80007a7c:	ea cc ff ff 	sub	r12,r5,-1
80007a80:	fe ce a4 00 	sub	lr,pc,-23552
80007a84:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007a88:	f4 cb ff f8 	sub	r11,r10,-8
80007a8c:	8d 0b       	st.w	r6[0x0],r11
80007a8e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007a92:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007a96:	c0 f8       	rjmp	80007ab4 <get_arg+0x1c8>
80007a98:	f4 cb ff fc 	sub	r11,r10,-4
80007a9c:	8d 0b       	st.w	r6[0x0],r11
80007a9e:	74 0a       	ld.w	r10,r10[0x0]
80007aa0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007aa4:	c0 88       	rjmp	80007ab4 <get_arg+0x1c8>
80007aa6:	f4 cb ff f8 	sub	r11,r10,-8
80007aaa:	8d 0b       	st.w	r6[0x0],r11
80007aac:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ab0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007ab4:	0e 9b       	mov	r11,r7
80007ab6:	18 95       	mov	r5,r12
80007ab8:	c4 e8       	rjmp	80007b54 <get_arg+0x268>
80007aba:	62 0a       	ld.w	r10,r1[0x0]
80007abc:	5b fa       	cp.w	r10,-1
80007abe:	c0 b1       	brne	80007ad4 <get_arg+0x1e8>
80007ac0:	50 19       	stdsp	sp[0x4],r9
80007ac2:	50 28       	stdsp	sp[0x8],r8
80007ac4:	e0 6a 00 80 	mov	r10,128
80007ac8:	30 0b       	mov	r11,0
80007aca:	02 9c       	mov	r12,r1
80007acc:	fe b0 fc f5 	rcall	800074b6 <memset>
80007ad0:	40 28       	lddsp	r8,sp[0x8]
80007ad2:	40 19       	lddsp	r9,sp[0x4]
80007ad4:	e4 cc 00 01 	sub	r12,r2,1
80007ad8:	0e 9b       	mov	r11,r7
80007ada:	50 3c       	stdsp	sp[0xc],r12
80007adc:	f2 0c 0c 49 	max	r9,r9,r12
80007ae0:	c3 a8       	rjmp	80007b54 <get_arg+0x268>
80007ae2:	62 0a       	ld.w	r10,r1[0x0]
80007ae4:	5b fa       	cp.w	r10,-1
80007ae6:	c0 b1       	brne	80007afc <get_arg+0x210>
80007ae8:	50 19       	stdsp	sp[0x4],r9
80007aea:	50 28       	stdsp	sp[0x8],r8
80007aec:	e0 6a 00 80 	mov	r10,128
80007af0:	30 0b       	mov	r11,0
80007af2:	02 9c       	mov	r12,r1
80007af4:	fe b0 fc e1 	rcall	800074b6 <memset>
80007af8:	40 28       	lddsp	r8,sp[0x8]
80007afa:	40 19       	lddsp	r9,sp[0x4]
80007afc:	20 12       	sub	r2,1
80007afe:	30 0a       	mov	r10,0
80007b00:	0e 9b       	mov	r11,r7
80007b02:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007b06:	f2 02 0c 49 	max	r9,r9,r2
80007b0a:	c2 58       	rjmp	80007b54 <get_arg+0x268>
80007b0c:	16 97       	mov	r7,r11
80007b0e:	6c 0a       	ld.w	r10,r6[0x0]
80007b10:	f4 cb ff fc 	sub	r11,r10,-4
80007b14:	8d 0b       	st.w	r6[0x0],r11
80007b16:	74 0a       	ld.w	r10,r10[0x0]
80007b18:	0e 9b       	mov	r11,r7
80007b1a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007b1e:	2f f5       	sub	r5,-1
80007b20:	c1 a8       	rjmp	80007b54 <get_arg+0x268>
80007b22:	f4 c2 00 30 	sub	r2,r10,48
80007b26:	c0 68       	rjmp	80007b32 <get_arg+0x246>
80007b28:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007b2c:	2f f7       	sub	r7,-1
80007b2e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007b32:	0f 8a       	ld.ub	r10,r7[0x0]
80007b34:	58 0a       	cp.w	r10,0
80007b36:	c0 e0       	breq	80007b52 <get_arg+0x266>
80007b38:	23 0a       	sub	r10,48
80007b3a:	58 9a       	cp.w	r10,9
80007b3c:	fe 98 ff f6 	brls	80007b28 <get_arg+0x23c>
80007b40:	c0 98       	rjmp	80007b52 <get_arg+0x266>
80007b42:	2f f7       	sub	r7,-1
80007b44:	0f 8a       	ld.ub	r10,r7[0x0]
80007b46:	58 0a       	cp.w	r10,0
80007b48:	c0 50       	breq	80007b52 <get_arg+0x266>
80007b4a:	23 0a       	sub	r10,48
80007b4c:	58 9a       	cp.w	r10,9
80007b4e:	fe 98 ff fa 	brls	80007b42 <get_arg+0x256>
80007b52:	0e 9b       	mov	r11,r7
80007b54:	40 7c       	lddsp	r12,sp[0x1c]
80007b56:	30 ba       	mov	r10,11
80007b58:	f4 0c 18 00 	cp.b	r12,r10
80007b5c:	fe 91 fe f2 	brne	80007940 <get_arg+0x54>
80007b60:	40 42       	lddsp	r2,sp[0x10]
80007b62:	17 8c       	ld.ub	r12,r11[0x0]
80007b64:	0a 32       	cp.w	r2,r5
80007b66:	5f 4a       	srge	r10
80007b68:	f0 0c 18 00 	cp.b	r12,r8
80007b6c:	5f 1c       	srne	r12
80007b6e:	f9 ea 00 0a 	and	r10,r12,r10
80007b72:	f0 0a 18 00 	cp.b	r10,r8
80007b76:	fe 91 fe cf 	brne	80007914 <get_arg+0x28>
80007b7a:	30 08       	mov	r8,0
80007b7c:	40 4e       	lddsp	lr,sp[0x10]
80007b7e:	17 8a       	ld.ub	r10,r11[0x0]
80007b80:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007b84:	f0 0a 18 00 	cp.b	r10,r8
80007b88:	fc 09 17 10 	movne	r9,lr
80007b8c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007b90:	06 9e       	mov	lr,r3
80007b92:	c2 a8       	rjmp	80007be6 <get_arg+0x2fa>
80007b94:	62 0a       	ld.w	r10,r1[0x0]
80007b96:	58 3a       	cp.w	r10,3
80007b98:	c1 e0       	breq	80007bd4 <get_arg+0x2e8>
80007b9a:	e0 89 00 07 	brgt	80007ba8 <get_arg+0x2bc>
80007b9e:	58 1a       	cp.w	r10,1
80007ba0:	c1 a0       	breq	80007bd4 <get_arg+0x2e8>
80007ba2:	58 2a       	cp.w	r10,2
80007ba4:	c1 81       	brne	80007bd4 <get_arg+0x2e8>
80007ba6:	c0 58       	rjmp	80007bb0 <get_arg+0x2c4>
80007ba8:	58 5a       	cp.w	r10,5
80007baa:	c0 c0       	breq	80007bc2 <get_arg+0x2d6>
80007bac:	c0 b5       	brlt	80007bc2 <get_arg+0x2d6>
80007bae:	c1 38       	rjmp	80007bd4 <get_arg+0x2e8>
80007bb0:	6c 0a       	ld.w	r10,r6[0x0]
80007bb2:	f4 cc ff f8 	sub	r12,r10,-8
80007bb6:	8d 0c       	st.w	r6[0x0],r12
80007bb8:	f4 e2 00 00 	ld.d	r2,r10[0]
80007bbc:	f0 e3 00 00 	st.d	r8[0],r2
80007bc0:	c1 08       	rjmp	80007be0 <get_arg+0x2f4>
80007bc2:	6c 0a       	ld.w	r10,r6[0x0]
80007bc4:	f4 cc ff f8 	sub	r12,r10,-8
80007bc8:	8d 0c       	st.w	r6[0x0],r12
80007bca:	f4 e2 00 00 	ld.d	r2,r10[0]
80007bce:	f0 e3 00 00 	st.d	r8[0],r2
80007bd2:	c0 78       	rjmp	80007be0 <get_arg+0x2f4>
80007bd4:	6c 0a       	ld.w	r10,r6[0x0]
80007bd6:	f4 cc ff fc 	sub	r12,r10,-4
80007bda:	8d 0c       	st.w	r6[0x0],r12
80007bdc:	74 0a       	ld.w	r10,r10[0x0]
80007bde:	91 0a       	st.w	r8[0x0],r10
80007be0:	2f f5       	sub	r5,-1
80007be2:	2f 88       	sub	r8,-8
80007be4:	2f c1       	sub	r1,-4
80007be6:	12 35       	cp.w	r5,r9
80007be8:	fe 9a ff d6 	brle	80007b94 <get_arg+0x2a8>
80007bec:	1c 93       	mov	r3,lr
80007bee:	40 52       	lddsp	r2,sp[0x14]
80007bf0:	40 6e       	lddsp	lr,sp[0x18]
80007bf2:	85 05       	st.w	r2[0x0],r5
80007bf4:	9d 0b       	st.w	lr[0x0],r11
80007bf6:	40 4b       	lddsp	r11,sp[0x10]
80007bf8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007bfc:	2f 8d       	sub	sp,-32
80007bfe:	d8 32       	popm	r0-r7,pc

80007c00 <__sprint_r>:
80007c00:	d4 21       	pushm	r4-r7,lr
80007c02:	14 97       	mov	r7,r10
80007c04:	74 28       	ld.w	r8,r10[0x8]
80007c06:	58 08       	cp.w	r8,0
80007c08:	c0 41       	brne	80007c10 <__sprint_r+0x10>
80007c0a:	95 18       	st.w	r10[0x4],r8
80007c0c:	10 9c       	mov	r12,r8
80007c0e:	d8 22       	popm	r4-r7,pc
80007c10:	e0 a0 18 ba 	rcall	8000ad84 <__sfvwrite_r>
80007c14:	30 08       	mov	r8,0
80007c16:	8f 18       	st.w	r7[0x4],r8
80007c18:	8f 28       	st.w	r7[0x8],r8
80007c1a:	d8 22       	popm	r4-r7,pc

80007c1c <_vfprintf_r>:
80007c1c:	d4 31       	pushm	r0-r7,lr
80007c1e:	fa cd 06 bc 	sub	sp,sp,1724
80007c22:	51 09       	stdsp	sp[0x40],r9
80007c24:	16 91       	mov	r1,r11
80007c26:	14 97       	mov	r7,r10
80007c28:	18 95       	mov	r5,r12
80007c2a:	e0 a0 1a 1d 	rcall	8000b064 <_localeconv_r>
80007c2e:	78 0c       	ld.w	r12,r12[0x0]
80007c30:	50 cc       	stdsp	sp[0x30],r12
80007c32:	58 05       	cp.w	r5,0
80007c34:	c0 70       	breq	80007c42 <_vfprintf_r+0x26>
80007c36:	6a 68       	ld.w	r8,r5[0x18]
80007c38:	58 08       	cp.w	r8,0
80007c3a:	c0 41       	brne	80007c42 <_vfprintf_r+0x26>
80007c3c:	0a 9c       	mov	r12,r5
80007c3e:	e0 a0 17 43 	rcall	8000aac4 <__sinit>
80007c42:	fe c8 a1 fe 	sub	r8,pc,-24066
80007c46:	10 31       	cp.w	r1,r8
80007c48:	c0 31       	brne	80007c4e <_vfprintf_r+0x32>
80007c4a:	6a 01       	ld.w	r1,r5[0x0]
80007c4c:	c0 c8       	rjmp	80007c64 <_vfprintf_r+0x48>
80007c4e:	fe c8 a1 ea 	sub	r8,pc,-24086
80007c52:	10 31       	cp.w	r1,r8
80007c54:	c0 31       	brne	80007c5a <_vfprintf_r+0x3e>
80007c56:	6a 11       	ld.w	r1,r5[0x4]
80007c58:	c0 68       	rjmp	80007c64 <_vfprintf_r+0x48>
80007c5a:	fe c8 a1 d6 	sub	r8,pc,-24106
80007c5e:	10 31       	cp.w	r1,r8
80007c60:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007c64:	82 68       	ld.sh	r8,r1[0xc]
80007c66:	ed b8 00 03 	bld	r8,0x3
80007c6a:	c0 41       	brne	80007c72 <_vfprintf_r+0x56>
80007c6c:	62 48       	ld.w	r8,r1[0x10]
80007c6e:	58 08       	cp.w	r8,0
80007c70:	c0 71       	brne	80007c7e <_vfprintf_r+0x62>
80007c72:	02 9b       	mov	r11,r1
80007c74:	0a 9c       	mov	r12,r5
80007c76:	e0 a0 0f 5d 	rcall	80009b30 <__swsetup_r>
80007c7a:	e0 81 0f 54 	brne	80009b22 <_vfprintf_r+0x1f06>
80007c7e:	82 68       	ld.sh	r8,r1[0xc]
80007c80:	10 99       	mov	r9,r8
80007c82:	e2 19 00 1a 	andl	r9,0x1a,COH
80007c86:	58 a9       	cp.w	r9,10
80007c88:	c3 c1       	brne	80007d00 <_vfprintf_r+0xe4>
80007c8a:	82 79       	ld.sh	r9,r1[0xe]
80007c8c:	30 0a       	mov	r10,0
80007c8e:	f4 09 19 00 	cp.h	r9,r10
80007c92:	c3 75       	brlt	80007d00 <_vfprintf_r+0xe4>
80007c94:	a1 d8       	cbr	r8,0x1
80007c96:	fb 58 05 d0 	st.h	sp[1488],r8
80007c9a:	62 88       	ld.w	r8,r1[0x20]
80007c9c:	fb 48 05 e4 	st.w	sp[1508],r8
80007ca0:	62 a8       	ld.w	r8,r1[0x28]
80007ca2:	fb 48 05 ec 	st.w	sp[1516],r8
80007ca6:	fa c8 ff bc 	sub	r8,sp,-68
80007caa:	fb 48 05 d4 	st.w	sp[1492],r8
80007cae:	fb 48 05 c4 	st.w	sp[1476],r8
80007cb2:	e0 68 04 00 	mov	r8,1024
80007cb6:	fb 48 05 d8 	st.w	sp[1496],r8
80007cba:	fb 48 05 cc 	st.w	sp[1484],r8
80007cbe:	30 08       	mov	r8,0
80007cc0:	fb 59 05 d2 	st.h	sp[1490],r9
80007cc4:	0e 9a       	mov	r10,r7
80007cc6:	41 09       	lddsp	r9,sp[0x40]
80007cc8:	fa c7 fa 3c 	sub	r7,sp,-1476
80007ccc:	fb 48 05 dc 	st.w	sp[1500],r8
80007cd0:	0a 9c       	mov	r12,r5
80007cd2:	0e 9b       	mov	r11,r7
80007cd4:	ca 4f       	rcall	80007c1c <_vfprintf_r>
80007cd6:	50 bc       	stdsp	sp[0x2c],r12
80007cd8:	c0 95       	brlt	80007cea <_vfprintf_r+0xce>
80007cda:	0e 9b       	mov	r11,r7
80007cdc:	0a 9c       	mov	r12,r5
80007cde:	e0 a0 16 1b 	rcall	8000a914 <_fflush_r>
80007ce2:	40 be       	lddsp	lr,sp[0x2c]
80007ce4:	f9 be 01 ff 	movne	lr,-1
80007ce8:	50 be       	stdsp	sp[0x2c],lr
80007cea:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007cee:	ed b8 00 06 	bld	r8,0x6
80007cf2:	e0 81 0f 1a 	brne	80009b26 <_vfprintf_r+0x1f0a>
80007cf6:	82 68       	ld.sh	r8,r1[0xc]
80007cf8:	a7 a8       	sbr	r8,0x6
80007cfa:	a2 68       	st.h	r1[0xc],r8
80007cfc:	e0 8f 0f 15 	bral	80009b26 <_vfprintf_r+0x1f0a>
80007d00:	30 08       	mov	r8,0
80007d02:	fb 48 06 b4 	st.w	sp[1716],r8
80007d06:	fb 48 06 90 	st.w	sp[1680],r8
80007d0a:	fb 48 06 8c 	st.w	sp[1676],r8
80007d0e:	fb 48 06 b0 	st.w	sp[1712],r8
80007d12:	30 08       	mov	r8,0
80007d14:	30 09       	mov	r9,0
80007d16:	50 a7       	stdsp	sp[0x28],r7
80007d18:	50 78       	stdsp	sp[0x1c],r8
80007d1a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007d1e:	3f f8       	mov	r8,-1
80007d20:	50 59       	stdsp	sp[0x14],r9
80007d22:	fb 43 06 88 	st.w	sp[1672],r3
80007d26:	fb 48 05 44 	st.w	sp[1348],r8
80007d2a:	12 9c       	mov	r12,r9
80007d2c:	50 69       	stdsp	sp[0x18],r9
80007d2e:	50 d9       	stdsp	sp[0x34],r9
80007d30:	50 e9       	stdsp	sp[0x38],r9
80007d32:	50 b9       	stdsp	sp[0x2c],r9
80007d34:	12 97       	mov	r7,r9
80007d36:	0a 94       	mov	r4,r5
80007d38:	40 a2       	lddsp	r2,sp[0x28]
80007d3a:	32 5a       	mov	r10,37
80007d3c:	30 08       	mov	r8,0
80007d3e:	c0 28       	rjmp	80007d42 <_vfprintf_r+0x126>
80007d40:	2f f2       	sub	r2,-1
80007d42:	05 89       	ld.ub	r9,r2[0x0]
80007d44:	f0 09 18 00 	cp.b	r9,r8
80007d48:	5f 1b       	srne	r11
80007d4a:	f4 09 18 00 	cp.b	r9,r10
80007d4e:	5f 19       	srne	r9
80007d50:	f3 eb 00 0b 	and	r11,r9,r11
80007d54:	f0 0b 18 00 	cp.b	r11,r8
80007d58:	cf 41       	brne	80007d40 <_vfprintf_r+0x124>
80007d5a:	40 ab       	lddsp	r11,sp[0x28]
80007d5c:	e4 0b 01 06 	sub	r6,r2,r11
80007d60:	c1 e0       	breq	80007d9c <_vfprintf_r+0x180>
80007d62:	fa f8 06 90 	ld.w	r8,sp[1680]
80007d66:	0c 08       	add	r8,r6
80007d68:	87 0b       	st.w	r3[0x0],r11
80007d6a:	fb 48 06 90 	st.w	sp[1680],r8
80007d6e:	87 16       	st.w	r3[0x4],r6
80007d70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007d74:	2f f8       	sub	r8,-1
80007d76:	fb 48 06 8c 	st.w	sp[1676],r8
80007d7a:	58 78       	cp.w	r8,7
80007d7c:	e0 89 00 04 	brgt	80007d84 <_vfprintf_r+0x168>
80007d80:	2f 83       	sub	r3,-8
80007d82:	c0 a8       	rjmp	80007d96 <_vfprintf_r+0x17a>
80007d84:	fa ca f9 78 	sub	r10,sp,-1672
80007d88:	02 9b       	mov	r11,r1
80007d8a:	08 9c       	mov	r12,r4
80007d8c:	c3 af       	rcall	80007c00 <__sprint_r>
80007d8e:	e0 81 0e c6 	brne	80009b1a <_vfprintf_r+0x1efe>
80007d92:	fa c3 f9 e0 	sub	r3,sp,-1568
80007d96:	40 ba       	lddsp	r10,sp[0x2c]
80007d98:	0c 0a       	add	r10,r6
80007d9a:	50 ba       	stdsp	sp[0x2c],r10
80007d9c:	05 89       	ld.ub	r9,r2[0x0]
80007d9e:	30 08       	mov	r8,0
80007da0:	f0 09 18 00 	cp.b	r9,r8
80007da4:	e0 80 0e aa 	breq	80009af8 <_vfprintf_r+0x1edc>
80007da8:	30 09       	mov	r9,0
80007daa:	fb 68 06 bb 	st.b	sp[1723],r8
80007dae:	0e 96       	mov	r6,r7
80007db0:	e4 c8 ff ff 	sub	r8,r2,-1
80007db4:	3f fe       	mov	lr,-1
80007db6:	50 93       	stdsp	sp[0x24],r3
80007db8:	50 41       	stdsp	sp[0x10],r1
80007dba:	0e 93       	mov	r3,r7
80007dbc:	04 91       	mov	r1,r2
80007dbe:	50 89       	stdsp	sp[0x20],r9
80007dc0:	50 a8       	stdsp	sp[0x28],r8
80007dc2:	50 2e       	stdsp	sp[0x8],lr
80007dc4:	50 39       	stdsp	sp[0xc],r9
80007dc6:	12 95       	mov	r5,r9
80007dc8:	12 90       	mov	r0,r9
80007dca:	10 97       	mov	r7,r8
80007dcc:	08 92       	mov	r2,r4
80007dce:	c0 78       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80007dd0:	3f fc       	mov	r12,-1
80007dd2:	08 97       	mov	r7,r4
80007dd4:	50 2c       	stdsp	sp[0x8],r12
80007dd6:	c0 38       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80007dd8:	30 0b       	mov	r11,0
80007dda:	50 3b       	stdsp	sp[0xc],r11
80007ddc:	0f 38       	ld.ub	r8,r7++
80007dde:	c0 28       	rjmp	80007de2 <_vfprintf_r+0x1c6>
80007de0:	12 90       	mov	r0,r9
80007de2:	f0 c9 00 20 	sub	r9,r8,32
80007de6:	e0 49 00 58 	cp.w	r9,88
80007dea:	e0 8b 0a 30 	brhi	8000924a <_vfprintf_r+0x162e>
80007dee:	fe ca a7 52 	sub	r10,pc,-22702
80007df2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007df6:	50 a7       	stdsp	sp[0x28],r7
80007df8:	50 80       	stdsp	sp[0x20],r0
80007dfa:	0c 97       	mov	r7,r6
80007dfc:	04 94       	mov	r4,r2
80007dfe:	06 96       	mov	r6,r3
80007e00:	02 92       	mov	r2,r1
80007e02:	fe c9 a5 2a 	sub	r9,pc,-23254
80007e06:	40 93       	lddsp	r3,sp[0x24]
80007e08:	10 90       	mov	r0,r8
80007e0a:	40 41       	lddsp	r1,sp[0x10]
80007e0c:	50 d9       	stdsp	sp[0x34],r9
80007e0e:	e0 8f 08 8e 	bral	80008f2a <_vfprintf_r+0x130e>
80007e12:	30 08       	mov	r8,0
80007e14:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007e18:	f0 09 18 00 	cp.b	r9,r8
80007e1c:	ce 01       	brne	80007ddc <_vfprintf_r+0x1c0>
80007e1e:	32 08       	mov	r8,32
80007e20:	c6 e8       	rjmp	80007efc <_vfprintf_r+0x2e0>
80007e22:	a1 a5       	sbr	r5,0x0
80007e24:	cd cb       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80007e26:	0f 89       	ld.ub	r9,r7[0x0]
80007e28:	f2 c8 00 30 	sub	r8,r9,48
80007e2c:	58 98       	cp.w	r8,9
80007e2e:	e0 8b 00 1d 	brhi	80007e68 <_vfprintf_r+0x24c>
80007e32:	ee c8 ff ff 	sub	r8,r7,-1
80007e36:	30 0b       	mov	r11,0
80007e38:	23 09       	sub	r9,48
80007e3a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007e3e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007e42:	11 39       	ld.ub	r9,r8++
80007e44:	f2 ca 00 30 	sub	r10,r9,48
80007e48:	58 9a       	cp.w	r10,9
80007e4a:	fe 98 ff f7 	brls	80007e38 <_vfprintf_r+0x21c>
80007e4e:	e0 49 00 24 	cp.w	r9,36
80007e52:	cc 31       	brne	80007dd8 <_vfprintf_r+0x1bc>
80007e54:	e0 4b 00 20 	cp.w	r11,32
80007e58:	e0 89 0e 60 	brgt	80009b18 <_vfprintf_r+0x1efc>
80007e5c:	20 1b       	sub	r11,1
80007e5e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007e62:	12 3b       	cp.w	r11,r9
80007e64:	c0 95       	brlt	80007e76 <_vfprintf_r+0x25a>
80007e66:	c1 08       	rjmp	80007e86 <_vfprintf_r+0x26a>
80007e68:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007e6c:	ec ca ff ff 	sub	r10,r6,-1
80007e70:	12 36       	cp.w	r6,r9
80007e72:	c1 f5       	brlt	80007eb0 <_vfprintf_r+0x294>
80007e74:	c2 68       	rjmp	80007ec0 <_vfprintf_r+0x2a4>
80007e76:	fa ce f9 44 	sub	lr,sp,-1724
80007e7a:	10 97       	mov	r7,r8
80007e7c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007e80:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007e84:	c3 58       	rjmp	80007eee <_vfprintf_r+0x2d2>
80007e86:	10 97       	mov	r7,r8
80007e88:	fa c8 f9 50 	sub	r8,sp,-1712
80007e8c:	1a d8       	st.w	--sp,r8
80007e8e:	fa c8 fa b8 	sub	r8,sp,-1352
80007e92:	1a d8       	st.w	--sp,r8
80007e94:	fa c8 fb b4 	sub	r8,sp,-1100
80007e98:	02 9a       	mov	r10,r1
80007e9a:	1a d8       	st.w	--sp,r8
80007e9c:	04 9c       	mov	r12,r2
80007e9e:	fa c8 f9 40 	sub	r8,sp,-1728
80007ea2:	fa c9 ff b4 	sub	r9,sp,-76
80007ea6:	fe b0 fd 23 	rcall	800078ec <get_arg>
80007eaa:	2f dd       	sub	sp,-12
80007eac:	78 00       	ld.w	r0,r12[0x0]
80007eae:	c2 08       	rjmp	80007eee <_vfprintf_r+0x2d2>
80007eb0:	fa cc f9 44 	sub	r12,sp,-1724
80007eb4:	14 96       	mov	r6,r10
80007eb6:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007eba:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007ebe:	c1 88       	rjmp	80007eee <_vfprintf_r+0x2d2>
80007ec0:	41 08       	lddsp	r8,sp[0x40]
80007ec2:	59 f9       	cp.w	r9,31
80007ec4:	e0 89 00 11 	brgt	80007ee6 <_vfprintf_r+0x2ca>
80007ec8:	f0 cb ff fc 	sub	r11,r8,-4
80007ecc:	51 0b       	stdsp	sp[0x40],r11
80007ece:	70 00       	ld.w	r0,r8[0x0]
80007ed0:	fa cb f9 44 	sub	r11,sp,-1724
80007ed4:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007ed8:	f1 40 fd 88 	st.w	r8[-632],r0
80007edc:	2f f9       	sub	r9,-1
80007ede:	14 96       	mov	r6,r10
80007ee0:	fb 49 06 b4 	st.w	sp[1716],r9
80007ee4:	c0 58       	rjmp	80007eee <_vfprintf_r+0x2d2>
80007ee6:	70 00       	ld.w	r0,r8[0x0]
80007ee8:	14 96       	mov	r6,r10
80007eea:	2f c8       	sub	r8,-4
80007eec:	51 08       	stdsp	sp[0x40],r8
80007eee:	58 00       	cp.w	r0,0
80007ef0:	fe 94 ff 76 	brge	80007ddc <_vfprintf_r+0x1c0>
80007ef4:	5c 30       	neg	r0
80007ef6:	a3 a5       	sbr	r5,0x2
80007ef8:	c7 2b       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80007efa:	32 b8       	mov	r8,43
80007efc:	fb 68 06 bb 	st.b	sp[1723],r8
80007f00:	c6 eb       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80007f02:	0f 38       	ld.ub	r8,r7++
80007f04:	e0 48 00 2a 	cp.w	r8,42
80007f08:	c0 30       	breq	80007f0e <_vfprintf_r+0x2f2>
80007f0a:	30 09       	mov	r9,0
80007f0c:	c7 98       	rjmp	80007ffe <_vfprintf_r+0x3e2>
80007f0e:	0f 88       	ld.ub	r8,r7[0x0]
80007f10:	f0 c9 00 30 	sub	r9,r8,48
80007f14:	58 99       	cp.w	r9,9
80007f16:	e0 8b 00 1f 	brhi	80007f54 <_vfprintf_r+0x338>
80007f1a:	ee c4 ff ff 	sub	r4,r7,-1
80007f1e:	30 0b       	mov	r11,0
80007f20:	23 08       	sub	r8,48
80007f22:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007f26:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007f2a:	09 38       	ld.ub	r8,r4++
80007f2c:	f0 c9 00 30 	sub	r9,r8,48
80007f30:	58 99       	cp.w	r9,9
80007f32:	fe 98 ff f7 	brls	80007f20 <_vfprintf_r+0x304>
80007f36:	e0 48 00 24 	cp.w	r8,36
80007f3a:	fe 91 ff 4f 	brne	80007dd8 <_vfprintf_r+0x1bc>
80007f3e:	e0 4b 00 20 	cp.w	r11,32
80007f42:	e0 89 0d eb 	brgt	80009b18 <_vfprintf_r+0x1efc>
80007f46:	20 1b       	sub	r11,1
80007f48:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f4c:	10 3b       	cp.w	r11,r8
80007f4e:	c0 a5       	brlt	80007f62 <_vfprintf_r+0x346>
80007f50:	c1 18       	rjmp	80007f72 <_vfprintf_r+0x356>
80007f52:	d7 03       	nop
80007f54:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007f58:	ec c9 ff ff 	sub	r9,r6,-1
80007f5c:	14 36       	cp.w	r6,r10
80007f5e:	c1 f5       	brlt	80007f9c <_vfprintf_r+0x380>
80007f60:	c2 88       	rjmp	80007fb0 <_vfprintf_r+0x394>
80007f62:	fa ca f9 44 	sub	r10,sp,-1724
80007f66:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007f6a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007f6e:	50 2b       	stdsp	sp[0x8],r11
80007f70:	c3 c8       	rjmp	80007fe8 <_vfprintf_r+0x3cc>
80007f72:	fa c8 f9 50 	sub	r8,sp,-1712
80007f76:	1a d8       	st.w	--sp,r8
80007f78:	fa c8 fa b8 	sub	r8,sp,-1352
80007f7c:	1a d8       	st.w	--sp,r8
80007f7e:	fa c8 fb b4 	sub	r8,sp,-1100
80007f82:	02 9a       	mov	r10,r1
80007f84:	1a d8       	st.w	--sp,r8
80007f86:	04 9c       	mov	r12,r2
80007f88:	fa c8 f9 40 	sub	r8,sp,-1728
80007f8c:	fa c9 ff b4 	sub	r9,sp,-76
80007f90:	fe b0 fc ae 	rcall	800078ec <get_arg>
80007f94:	2f dd       	sub	sp,-12
80007f96:	78 0c       	ld.w	r12,r12[0x0]
80007f98:	50 2c       	stdsp	sp[0x8],r12
80007f9a:	c2 78       	rjmp	80007fe8 <_vfprintf_r+0x3cc>
80007f9c:	12 96       	mov	r6,r9
80007f9e:	0e 94       	mov	r4,r7
80007fa0:	fa c9 f9 44 	sub	r9,sp,-1724
80007fa4:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007fa8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007fac:	50 28       	stdsp	sp[0x8],r8
80007fae:	c1 d8       	rjmp	80007fe8 <_vfprintf_r+0x3cc>
80007fb0:	41 08       	lddsp	r8,sp[0x40]
80007fb2:	59 fa       	cp.w	r10,31
80007fb4:	e0 89 00 14 	brgt	80007fdc <_vfprintf_r+0x3c0>
80007fb8:	f0 cb ff fc 	sub	r11,r8,-4
80007fbc:	70 08       	ld.w	r8,r8[0x0]
80007fbe:	51 0b       	stdsp	sp[0x40],r11
80007fc0:	50 28       	stdsp	sp[0x8],r8
80007fc2:	fa c6 f9 44 	sub	r6,sp,-1724
80007fc6:	40 2e       	lddsp	lr,sp[0x8]
80007fc8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007fcc:	f1 4e fd 88 	st.w	r8[-632],lr
80007fd0:	2f fa       	sub	r10,-1
80007fd2:	0e 94       	mov	r4,r7
80007fd4:	fb 4a 06 b4 	st.w	sp[1716],r10
80007fd8:	12 96       	mov	r6,r9
80007fda:	c0 78       	rjmp	80007fe8 <_vfprintf_r+0x3cc>
80007fdc:	70 0c       	ld.w	r12,r8[0x0]
80007fde:	0e 94       	mov	r4,r7
80007fe0:	2f c8       	sub	r8,-4
80007fe2:	50 2c       	stdsp	sp[0x8],r12
80007fe4:	12 96       	mov	r6,r9
80007fe6:	51 08       	stdsp	sp[0x40],r8
80007fe8:	40 2b       	lddsp	r11,sp[0x8]
80007fea:	58 0b       	cp.w	r11,0
80007fec:	fe 95 fe f2 	brlt	80007dd0 <_vfprintf_r+0x1b4>
80007ff0:	08 97       	mov	r7,r4
80007ff2:	cf 5a       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80007ff4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ff8:	0f 38       	ld.ub	r8,r7++
80007ffa:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007ffe:	f0 ca 00 30 	sub	r10,r8,48
80008002:	58 9a       	cp.w	r10,9
80008004:	fe 98 ff f8 	brls	80007ff4 <_vfprintf_r+0x3d8>
80008008:	3f fa       	mov	r10,-1
8000800a:	f2 0a 0c 49 	max	r9,r9,r10
8000800e:	50 29       	stdsp	sp[0x8],r9
80008010:	ce 9a       	rjmp	80007de2 <_vfprintf_r+0x1c6>
80008012:	a7 b5       	sbr	r5,0x7
80008014:	ce 4a       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80008016:	30 09       	mov	r9,0
80008018:	23 08       	sub	r8,48
8000801a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000801e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008022:	0f 38       	ld.ub	r8,r7++
80008024:	f0 ca 00 30 	sub	r10,r8,48
80008028:	58 9a       	cp.w	r10,9
8000802a:	fe 98 ff f7 	brls	80008018 <_vfprintf_r+0x3fc>
8000802e:	e0 48 00 24 	cp.w	r8,36
80008032:	fe 91 fe d7 	brne	80007de0 <_vfprintf_r+0x1c4>
80008036:	e0 49 00 20 	cp.w	r9,32
8000803a:	e0 89 0d 6f 	brgt	80009b18 <_vfprintf_r+0x1efc>
8000803e:	f2 c3 00 01 	sub	r3,r9,1
80008042:	30 19       	mov	r9,1
80008044:	50 39       	stdsp	sp[0xc],r9
80008046:	cc ba       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80008048:	a3 b5       	sbr	r5,0x3
8000804a:	cc 9a       	rjmp	80007ddc <_vfprintf_r+0x1c0>
8000804c:	a7 a5       	sbr	r5,0x6
8000804e:	cc 7a       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80008050:	0a 98       	mov	r8,r5
80008052:	a5 b5       	sbr	r5,0x5
80008054:	a5 a8       	sbr	r8,0x4
80008056:	0f 89       	ld.ub	r9,r7[0x0]
80008058:	36 ce       	mov	lr,108
8000805a:	fc 09 18 00 	cp.b	r9,lr
8000805e:	f7 b7 00 ff 	subeq	r7,-1
80008062:	f0 05 17 10 	movne	r5,r8
80008066:	cb ba       	rjmp	80007ddc <_vfprintf_r+0x1c0>
80008068:	a5 b5       	sbr	r5,0x5
8000806a:	cb 9a       	rjmp	80007ddc <_vfprintf_r+0x1c0>
8000806c:	50 a7       	stdsp	sp[0x28],r7
8000806e:	50 80       	stdsp	sp[0x20],r0
80008070:	0c 97       	mov	r7,r6
80008072:	10 90       	mov	r0,r8
80008074:	06 96       	mov	r6,r3
80008076:	04 94       	mov	r4,r2
80008078:	40 93       	lddsp	r3,sp[0x24]
8000807a:	02 92       	mov	r2,r1
8000807c:	0e 99       	mov	r9,r7
8000807e:	40 41       	lddsp	r1,sp[0x10]
80008080:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008084:	40 3c       	lddsp	r12,sp[0xc]
80008086:	58 0c       	cp.w	r12,0
80008088:	c1 d0       	breq	800080c2 <_vfprintf_r+0x4a6>
8000808a:	10 36       	cp.w	r6,r8
8000808c:	c0 64       	brge	80008098 <_vfprintf_r+0x47c>
8000808e:	fa cb f9 44 	sub	r11,sp,-1724
80008092:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008096:	c1 d8       	rjmp	800080d0 <_vfprintf_r+0x4b4>
80008098:	fa c8 f9 50 	sub	r8,sp,-1712
8000809c:	1a d8       	st.w	--sp,r8
8000809e:	fa c8 fa b8 	sub	r8,sp,-1352
800080a2:	1a d8       	st.w	--sp,r8
800080a4:	fa c8 fb b4 	sub	r8,sp,-1100
800080a8:	1a d8       	st.w	--sp,r8
800080aa:	fa c8 f9 40 	sub	r8,sp,-1728
800080ae:	fa c9 ff b4 	sub	r9,sp,-76
800080b2:	04 9a       	mov	r10,r2
800080b4:	0c 9b       	mov	r11,r6
800080b6:	08 9c       	mov	r12,r4
800080b8:	fe b0 fc 1a 	rcall	800078ec <get_arg>
800080bc:	2f dd       	sub	sp,-12
800080be:	19 b8       	ld.ub	r8,r12[0x3]
800080c0:	c2 28       	rjmp	80008104 <_vfprintf_r+0x4e8>
800080c2:	2f f7       	sub	r7,-1
800080c4:	10 39       	cp.w	r9,r8
800080c6:	c0 84       	brge	800080d6 <_vfprintf_r+0x4ba>
800080c8:	fa ca f9 44 	sub	r10,sp,-1724
800080cc:	f4 06 00 36 	add	r6,r10,r6<<0x3
800080d0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800080d4:	c1 88       	rjmp	80008104 <_vfprintf_r+0x4e8>
800080d6:	41 09       	lddsp	r9,sp[0x40]
800080d8:	59 f8       	cp.w	r8,31
800080da:	e0 89 00 12 	brgt	800080fe <_vfprintf_r+0x4e2>
800080de:	f2 ca ff fc 	sub	r10,r9,-4
800080e2:	51 0a       	stdsp	sp[0x40],r10
800080e4:	72 09       	ld.w	r9,r9[0x0]
800080e6:	fa c6 f9 44 	sub	r6,sp,-1724
800080ea:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800080ee:	2f f8       	sub	r8,-1
800080f0:	f5 49 fd 88 	st.w	r10[-632],r9
800080f4:	fb 48 06 b4 	st.w	sp[1716],r8
800080f8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800080fc:	c0 48       	rjmp	80008104 <_vfprintf_r+0x4e8>
800080fe:	13 b8       	ld.ub	r8,r9[0x3]
80008100:	2f c9       	sub	r9,-4
80008102:	51 09       	stdsp	sp[0x40],r9
80008104:	fb 68 06 60 	st.b	sp[1632],r8
80008108:	30 0e       	mov	lr,0
8000810a:	30 08       	mov	r8,0
8000810c:	30 12       	mov	r2,1
8000810e:	fb 68 06 bb 	st.b	sp[1723],r8
80008112:	50 2e       	stdsp	sp[0x8],lr
80008114:	e0 8f 08 ad 	bral	8000926e <_vfprintf_r+0x1652>
80008118:	50 a7       	stdsp	sp[0x28],r7
8000811a:	50 80       	stdsp	sp[0x20],r0
8000811c:	0c 97       	mov	r7,r6
8000811e:	04 94       	mov	r4,r2
80008120:	06 96       	mov	r6,r3
80008122:	02 92       	mov	r2,r1
80008124:	40 93       	lddsp	r3,sp[0x24]
80008126:	10 90       	mov	r0,r8
80008128:	40 41       	lddsp	r1,sp[0x10]
8000812a:	a5 a5       	sbr	r5,0x4
8000812c:	c0 a8       	rjmp	80008140 <_vfprintf_r+0x524>
8000812e:	50 a7       	stdsp	sp[0x28],r7
80008130:	50 80       	stdsp	sp[0x20],r0
80008132:	0c 97       	mov	r7,r6
80008134:	04 94       	mov	r4,r2
80008136:	06 96       	mov	r6,r3
80008138:	02 92       	mov	r2,r1
8000813a:	40 93       	lddsp	r3,sp[0x24]
8000813c:	10 90       	mov	r0,r8
8000813e:	40 41       	lddsp	r1,sp[0x10]
80008140:	ed b5 00 05 	bld	r5,0x5
80008144:	c5 11       	brne	800081e6 <_vfprintf_r+0x5ca>
80008146:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000814a:	40 3c       	lddsp	r12,sp[0xc]
8000814c:	58 0c       	cp.w	r12,0
8000814e:	c1 e0       	breq	8000818a <_vfprintf_r+0x56e>
80008150:	10 36       	cp.w	r6,r8
80008152:	c0 64       	brge	8000815e <_vfprintf_r+0x542>
80008154:	fa cb f9 44 	sub	r11,sp,-1724
80008158:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000815c:	c2 08       	rjmp	8000819c <_vfprintf_r+0x580>
8000815e:	fa c8 f9 50 	sub	r8,sp,-1712
80008162:	1a d8       	st.w	--sp,r8
80008164:	fa c8 fa b8 	sub	r8,sp,-1352
80008168:	0c 9b       	mov	r11,r6
8000816a:	1a d8       	st.w	--sp,r8
8000816c:	fa c8 fb b4 	sub	r8,sp,-1100
80008170:	1a d8       	st.w	--sp,r8
80008172:	fa c9 ff b4 	sub	r9,sp,-76
80008176:	fa c8 f9 40 	sub	r8,sp,-1728
8000817a:	04 9a       	mov	r10,r2
8000817c:	08 9c       	mov	r12,r4
8000817e:	fe b0 fb b7 	rcall	800078ec <get_arg>
80008182:	2f dd       	sub	sp,-12
80008184:	78 1b       	ld.w	r11,r12[0x4]
80008186:	78 09       	ld.w	r9,r12[0x0]
80008188:	c2 b8       	rjmp	800081de <_vfprintf_r+0x5c2>
8000818a:	ee ca ff ff 	sub	r10,r7,-1
8000818e:	10 37       	cp.w	r7,r8
80008190:	c0 b4       	brge	800081a6 <_vfprintf_r+0x58a>
80008192:	fa c9 f9 44 	sub	r9,sp,-1724
80008196:	14 97       	mov	r7,r10
80008198:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000819c:	ec fb fd 8c 	ld.w	r11,r6[-628]
800081a0:	ec f9 fd 88 	ld.w	r9,r6[-632]
800081a4:	c1 d8       	rjmp	800081de <_vfprintf_r+0x5c2>
800081a6:	41 09       	lddsp	r9,sp[0x40]
800081a8:	59 f8       	cp.w	r8,31
800081aa:	e0 89 00 14 	brgt	800081d2 <_vfprintf_r+0x5b6>
800081ae:	f2 cb ff f8 	sub	r11,r9,-8
800081b2:	51 0b       	stdsp	sp[0x40],r11
800081b4:	fa c6 f9 44 	sub	r6,sp,-1724
800081b8:	72 1b       	ld.w	r11,r9[0x4]
800081ba:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800081be:	72 09       	ld.w	r9,r9[0x0]
800081c0:	f9 4b fd 8c 	st.w	r12[-628],r11
800081c4:	f9 49 fd 88 	st.w	r12[-632],r9
800081c8:	2f f8       	sub	r8,-1
800081ca:	14 97       	mov	r7,r10
800081cc:	fb 48 06 b4 	st.w	sp[1716],r8
800081d0:	c0 78       	rjmp	800081de <_vfprintf_r+0x5c2>
800081d2:	f2 c8 ff f8 	sub	r8,r9,-8
800081d6:	72 1b       	ld.w	r11,r9[0x4]
800081d8:	14 97       	mov	r7,r10
800081da:	51 08       	stdsp	sp[0x40],r8
800081dc:	72 09       	ld.w	r9,r9[0x0]
800081de:	16 98       	mov	r8,r11
800081e0:	fa e9 00 00 	st.d	sp[0],r8
800081e4:	ca e8       	rjmp	80008340 <_vfprintf_r+0x724>
800081e6:	ed b5 00 04 	bld	r5,0x4
800081ea:	c1 71       	brne	80008218 <_vfprintf_r+0x5fc>
800081ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081f0:	40 3e       	lddsp	lr,sp[0xc]
800081f2:	58 0e       	cp.w	lr,0
800081f4:	c0 80       	breq	80008204 <_vfprintf_r+0x5e8>
800081f6:	10 36       	cp.w	r6,r8
800081f8:	c6 94       	brge	800082ca <_vfprintf_r+0x6ae>
800081fa:	fa cc f9 44 	sub	r12,sp,-1724
800081fe:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008202:	c8 28       	rjmp	80008306 <_vfprintf_r+0x6ea>
80008204:	ee ca ff ff 	sub	r10,r7,-1
80008208:	10 37       	cp.w	r7,r8
8000820a:	e0 84 00 81 	brge	8000830c <_vfprintf_r+0x6f0>
8000820e:	fa cb f9 44 	sub	r11,sp,-1724
80008212:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008216:	c7 78       	rjmp	80008304 <_vfprintf_r+0x6e8>
80008218:	ed b5 00 06 	bld	r5,0x6
8000821c:	c4 b1       	brne	800082b2 <_vfprintf_r+0x696>
8000821e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008222:	40 3c       	lddsp	r12,sp[0xc]
80008224:	58 0c       	cp.w	r12,0
80008226:	c1 d0       	breq	80008260 <_vfprintf_r+0x644>
80008228:	10 36       	cp.w	r6,r8
8000822a:	c0 64       	brge	80008236 <_vfprintf_r+0x61a>
8000822c:	fa cb f9 44 	sub	r11,sp,-1724
80008230:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008234:	c1 f8       	rjmp	80008272 <_vfprintf_r+0x656>
80008236:	fa c8 f9 50 	sub	r8,sp,-1712
8000823a:	1a d8       	st.w	--sp,r8
8000823c:	fa c8 fa b8 	sub	r8,sp,-1352
80008240:	1a d8       	st.w	--sp,r8
80008242:	fa c8 fb b4 	sub	r8,sp,-1100
80008246:	1a d8       	st.w	--sp,r8
80008248:	fa c8 f9 40 	sub	r8,sp,-1728
8000824c:	fa c9 ff b4 	sub	r9,sp,-76
80008250:	04 9a       	mov	r10,r2
80008252:	0c 9b       	mov	r11,r6
80008254:	08 9c       	mov	r12,r4
80008256:	fe b0 fb 4b 	rcall	800078ec <get_arg>
8000825a:	2f dd       	sub	sp,-12
8000825c:	98 18       	ld.sh	r8,r12[0x2]
8000825e:	c2 68       	rjmp	800082aa <_vfprintf_r+0x68e>
80008260:	ee ca ff ff 	sub	r10,r7,-1
80008264:	10 37       	cp.w	r7,r8
80008266:	c0 94       	brge	80008278 <_vfprintf_r+0x65c>
80008268:	fa c9 f9 44 	sub	r9,sp,-1724
8000826c:	14 97       	mov	r7,r10
8000826e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008272:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008276:	c1 a8       	rjmp	800082aa <_vfprintf_r+0x68e>
80008278:	41 09       	lddsp	r9,sp[0x40]
8000827a:	59 f8       	cp.w	r8,31
8000827c:	e0 89 00 13 	brgt	800082a2 <_vfprintf_r+0x686>
80008280:	f2 cb ff fc 	sub	r11,r9,-4
80008284:	51 0b       	stdsp	sp[0x40],r11
80008286:	72 09       	ld.w	r9,r9[0x0]
80008288:	fa c6 f9 44 	sub	r6,sp,-1724
8000828c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008290:	2f f8       	sub	r8,-1
80008292:	f7 49 fd 88 	st.w	r11[-632],r9
80008296:	fb 48 06 b4 	st.w	sp[1716],r8
8000829a:	14 97       	mov	r7,r10
8000829c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800082a0:	c0 58       	rjmp	800082aa <_vfprintf_r+0x68e>
800082a2:	92 18       	ld.sh	r8,r9[0x2]
800082a4:	14 97       	mov	r7,r10
800082a6:	2f c9       	sub	r9,-4
800082a8:	51 09       	stdsp	sp[0x40],r9
800082aa:	50 18       	stdsp	sp[0x4],r8
800082ac:	bf 58       	asr	r8,0x1f
800082ae:	50 08       	stdsp	sp[0x0],r8
800082b0:	c4 88       	rjmp	80008340 <_vfprintf_r+0x724>
800082b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082b6:	40 3c       	lddsp	r12,sp[0xc]
800082b8:	58 0c       	cp.w	r12,0
800082ba:	c1 d0       	breq	800082f4 <_vfprintf_r+0x6d8>
800082bc:	10 36       	cp.w	r6,r8
800082be:	c0 64       	brge	800082ca <_vfprintf_r+0x6ae>
800082c0:	fa cb f9 44 	sub	r11,sp,-1724
800082c4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082c8:	c1 f8       	rjmp	80008306 <_vfprintf_r+0x6ea>
800082ca:	fa c8 f9 50 	sub	r8,sp,-1712
800082ce:	1a d8       	st.w	--sp,r8
800082d0:	fa c8 fa b8 	sub	r8,sp,-1352
800082d4:	0c 9b       	mov	r11,r6
800082d6:	1a d8       	st.w	--sp,r8
800082d8:	fa c8 fb b4 	sub	r8,sp,-1100
800082dc:	04 9a       	mov	r10,r2
800082de:	1a d8       	st.w	--sp,r8
800082e0:	08 9c       	mov	r12,r4
800082e2:	fa c8 f9 40 	sub	r8,sp,-1728
800082e6:	fa c9 ff b4 	sub	r9,sp,-76
800082ea:	fe b0 fb 01 	rcall	800078ec <get_arg>
800082ee:	2f dd       	sub	sp,-12
800082f0:	78 0b       	ld.w	r11,r12[0x0]
800082f2:	c2 48       	rjmp	8000833a <_vfprintf_r+0x71e>
800082f4:	ee ca ff ff 	sub	r10,r7,-1
800082f8:	10 37       	cp.w	r7,r8
800082fa:	c0 94       	brge	8000830c <_vfprintf_r+0x6f0>
800082fc:	fa c9 f9 44 	sub	r9,sp,-1724
80008300:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008304:	14 97       	mov	r7,r10
80008306:	ec fb fd 88 	ld.w	r11,r6[-632]
8000830a:	c1 88       	rjmp	8000833a <_vfprintf_r+0x71e>
8000830c:	41 09       	lddsp	r9,sp[0x40]
8000830e:	59 f8       	cp.w	r8,31
80008310:	e0 89 00 11 	brgt	80008332 <_vfprintf_r+0x716>
80008314:	f2 cb ff fc 	sub	r11,r9,-4
80008318:	51 0b       	stdsp	sp[0x40],r11
8000831a:	fa c6 f9 44 	sub	r6,sp,-1724
8000831e:	72 0b       	ld.w	r11,r9[0x0]
80008320:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008324:	f3 4b fd 88 	st.w	r9[-632],r11
80008328:	2f f8       	sub	r8,-1
8000832a:	14 97       	mov	r7,r10
8000832c:	fb 48 06 b4 	st.w	sp[1716],r8
80008330:	c0 58       	rjmp	8000833a <_vfprintf_r+0x71e>
80008332:	72 0b       	ld.w	r11,r9[0x0]
80008334:	14 97       	mov	r7,r10
80008336:	2f c9       	sub	r9,-4
80008338:	51 09       	stdsp	sp[0x40],r9
8000833a:	50 1b       	stdsp	sp[0x4],r11
8000833c:	bf 5b       	asr	r11,0x1f
8000833e:	50 0b       	stdsp	sp[0x0],r11
80008340:	fa ea 00 00 	ld.d	r10,sp[0]
80008344:	58 0a       	cp.w	r10,0
80008346:	5c 2b       	cpc	r11
80008348:	c0 e4       	brge	80008364 <_vfprintf_r+0x748>
8000834a:	30 08       	mov	r8,0
8000834c:	fa ea 00 00 	ld.d	r10,sp[0]
80008350:	30 09       	mov	r9,0
80008352:	f0 0a 01 0a 	sub	r10,r8,r10
80008356:	f2 0b 01 4b 	sbc	r11,r9,r11
8000835a:	32 d8       	mov	r8,45
8000835c:	fa eb 00 00 	st.d	sp[0],r10
80008360:	fb 68 06 bb 	st.b	sp[1723],r8
80008364:	30 18       	mov	r8,1
80008366:	e0 8f 06 fa 	bral	8000915a <_vfprintf_r+0x153e>
8000836a:	50 a7       	stdsp	sp[0x28],r7
8000836c:	50 80       	stdsp	sp[0x20],r0
8000836e:	0c 97       	mov	r7,r6
80008370:	04 94       	mov	r4,r2
80008372:	06 96       	mov	r6,r3
80008374:	02 92       	mov	r2,r1
80008376:	40 93       	lddsp	r3,sp[0x24]
80008378:	10 90       	mov	r0,r8
8000837a:	40 41       	lddsp	r1,sp[0x10]
8000837c:	0e 99       	mov	r9,r7
8000837e:	ed b5 00 03 	bld	r5,0x3
80008382:	c4 11       	brne	80008404 <_vfprintf_r+0x7e8>
80008384:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008388:	40 3a       	lddsp	r10,sp[0xc]
8000838a:	58 0a       	cp.w	r10,0
8000838c:	c1 90       	breq	800083be <_vfprintf_r+0x7a2>
8000838e:	10 36       	cp.w	r6,r8
80008390:	c6 45       	brlt	80008458 <_vfprintf_r+0x83c>
80008392:	fa c8 f9 50 	sub	r8,sp,-1712
80008396:	1a d8       	st.w	--sp,r8
80008398:	fa c8 fa b8 	sub	r8,sp,-1352
8000839c:	1a d8       	st.w	--sp,r8
8000839e:	fa c8 fb b4 	sub	r8,sp,-1100
800083a2:	0c 9b       	mov	r11,r6
800083a4:	1a d8       	st.w	--sp,r8
800083a6:	04 9a       	mov	r10,r2
800083a8:	fa c8 f9 40 	sub	r8,sp,-1728
800083ac:	fa c9 ff b4 	sub	r9,sp,-76
800083b0:	08 9c       	mov	r12,r4
800083b2:	fe b0 fa 9d 	rcall	800078ec <get_arg>
800083b6:	2f dd       	sub	sp,-12
800083b8:	78 16       	ld.w	r6,r12[0x4]
800083ba:	50 76       	stdsp	sp[0x1c],r6
800083bc:	c4 88       	rjmp	8000844c <_vfprintf_r+0x830>
800083be:	2f f7       	sub	r7,-1
800083c0:	10 39       	cp.w	r9,r8
800083c2:	c0 c4       	brge	800083da <_vfprintf_r+0x7be>
800083c4:	fa ce f9 44 	sub	lr,sp,-1724
800083c8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800083cc:	ec fc fd 8c 	ld.w	r12,r6[-628]
800083d0:	50 7c       	stdsp	sp[0x1c],r12
800083d2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800083d6:	50 56       	stdsp	sp[0x14],r6
800083d8:	c6 68       	rjmp	800084a4 <_vfprintf_r+0x888>
800083da:	41 09       	lddsp	r9,sp[0x40]
800083dc:	59 f8       	cp.w	r8,31
800083de:	e0 89 00 10 	brgt	800083fe <_vfprintf_r+0x7e2>
800083e2:	f2 ca ff f8 	sub	r10,r9,-8
800083e6:	72 1b       	ld.w	r11,r9[0x4]
800083e8:	51 0a       	stdsp	sp[0x40],r10
800083ea:	72 09       	ld.w	r9,r9[0x0]
800083ec:	fa ca f9 44 	sub	r10,sp,-1724
800083f0:	50 7b       	stdsp	sp[0x1c],r11
800083f2:	50 59       	stdsp	sp[0x14],r9
800083f4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800083f8:	40 5b       	lddsp	r11,sp[0x14]
800083fa:	40 7a       	lddsp	r10,sp[0x1c]
800083fc:	c4 78       	rjmp	8000848a <_vfprintf_r+0x86e>
800083fe:	72 18       	ld.w	r8,r9[0x4]
80008400:	50 78       	stdsp	sp[0x1c],r8
80008402:	c4 c8       	rjmp	8000849a <_vfprintf_r+0x87e>
80008404:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008408:	40 3e       	lddsp	lr,sp[0xc]
8000840a:	58 0e       	cp.w	lr,0
8000840c:	c2 30       	breq	80008452 <_vfprintf_r+0x836>
8000840e:	10 36       	cp.w	r6,r8
80008410:	c0 94       	brge	80008422 <_vfprintf_r+0x806>
80008412:	fa cc f9 44 	sub	r12,sp,-1724
80008416:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000841a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000841e:	50 7b       	stdsp	sp[0x1c],r11
80008420:	cd 9b       	rjmp	800083d2 <_vfprintf_r+0x7b6>
80008422:	fa c8 f9 50 	sub	r8,sp,-1712
80008426:	1a d8       	st.w	--sp,r8
80008428:	fa c8 fa b8 	sub	r8,sp,-1352
8000842c:	04 9a       	mov	r10,r2
8000842e:	1a d8       	st.w	--sp,r8
80008430:	fa c8 fb b4 	sub	r8,sp,-1100
80008434:	0c 9b       	mov	r11,r6
80008436:	1a d8       	st.w	--sp,r8
80008438:	08 9c       	mov	r12,r4
8000843a:	fa c8 f9 40 	sub	r8,sp,-1728
8000843e:	fa c9 ff b4 	sub	r9,sp,-76
80008442:	fe b0 fa 55 	rcall	800078ec <get_arg>
80008446:	2f dd       	sub	sp,-12
80008448:	78 1a       	ld.w	r10,r12[0x4]
8000844a:	50 7a       	stdsp	sp[0x1c],r10
8000844c:	78 0c       	ld.w	r12,r12[0x0]
8000844e:	50 5c       	stdsp	sp[0x14],r12
80008450:	c2 a8       	rjmp	800084a4 <_vfprintf_r+0x888>
80008452:	2f f7       	sub	r7,-1
80008454:	10 39       	cp.w	r9,r8
80008456:	c0 94       	brge	80008468 <_vfprintf_r+0x84c>
80008458:	fa c9 f9 44 	sub	r9,sp,-1724
8000845c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008460:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008464:	50 78       	stdsp	sp[0x1c],r8
80008466:	cb 6b       	rjmp	800083d2 <_vfprintf_r+0x7b6>
80008468:	41 09       	lddsp	r9,sp[0x40]
8000846a:	59 f8       	cp.w	r8,31
8000846c:	e0 89 00 15 	brgt	80008496 <_vfprintf_r+0x87a>
80008470:	f2 ca ff f8 	sub	r10,r9,-8
80008474:	72 16       	ld.w	r6,r9[0x4]
80008476:	72 09       	ld.w	r9,r9[0x0]
80008478:	51 0a       	stdsp	sp[0x40],r10
8000847a:	50 59       	stdsp	sp[0x14],r9
8000847c:	fa ce f9 44 	sub	lr,sp,-1724
80008480:	50 76       	stdsp	sp[0x1c],r6
80008482:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008486:	40 5b       	lddsp	r11,sp[0x14]
80008488:	0c 9a       	mov	r10,r6
8000848a:	f2 eb fd 88 	st.d	r9[-632],r10
8000848e:	2f f8       	sub	r8,-1
80008490:	fb 48 06 b4 	st.w	sp[1716],r8
80008494:	c0 88       	rjmp	800084a4 <_vfprintf_r+0x888>
80008496:	72 1c       	ld.w	r12,r9[0x4]
80008498:	50 7c       	stdsp	sp[0x1c],r12
8000849a:	f2 c8 ff f8 	sub	r8,r9,-8
8000849e:	51 08       	stdsp	sp[0x40],r8
800084a0:	72 09       	ld.w	r9,r9[0x0]
800084a2:	50 59       	stdsp	sp[0x14],r9
800084a4:	40 5b       	lddsp	r11,sp[0x14]
800084a6:	40 7a       	lddsp	r10,sp[0x1c]
800084a8:	e0 a0 19 54 	rcall	8000b750 <__isinfd>
800084ac:	18 96       	mov	r6,r12
800084ae:	c1 70       	breq	800084dc <_vfprintf_r+0x8c0>
800084b0:	30 08       	mov	r8,0
800084b2:	30 09       	mov	r9,0
800084b4:	40 5b       	lddsp	r11,sp[0x14]
800084b6:	40 7a       	lddsp	r10,sp[0x1c]
800084b8:	e0 a0 1d a8 	rcall	8000c008 <__avr32_f64_cmp_lt>
800084bc:	c0 40       	breq	800084c4 <_vfprintf_r+0x8a8>
800084be:	32 d8       	mov	r8,45
800084c0:	fb 68 06 bb 	st.b	sp[1723],r8
800084c4:	fe c8 ab d8 	sub	r8,pc,-21544
800084c8:	fe c6 ab d8 	sub	r6,pc,-21544
800084cc:	a7 d5       	cbr	r5,0x7
800084ce:	e0 40 00 47 	cp.w	r0,71
800084d2:	f0 06 17 a0 	movle	r6,r8
800084d6:	30 32       	mov	r2,3
800084d8:	e0 8f 06 ce 	bral	80009274 <_vfprintf_r+0x1658>
800084dc:	40 5b       	lddsp	r11,sp[0x14]
800084de:	40 7a       	lddsp	r10,sp[0x1c]
800084e0:	e0 a0 19 4d 	rcall	8000b77a <__isnand>
800084e4:	c0 e0       	breq	80008500 <_vfprintf_r+0x8e4>
800084e6:	50 26       	stdsp	sp[0x8],r6
800084e8:	fe c8 ab f4 	sub	r8,pc,-21516
800084ec:	fe c6 ab f4 	sub	r6,pc,-21516
800084f0:	a7 d5       	cbr	r5,0x7
800084f2:	e0 40 00 47 	cp.w	r0,71
800084f6:	f0 06 17 a0 	movle	r6,r8
800084fa:	30 32       	mov	r2,3
800084fc:	e0 8f 06 c2 	bral	80009280 <_vfprintf_r+0x1664>
80008500:	40 2a       	lddsp	r10,sp[0x8]
80008502:	5b fa       	cp.w	r10,-1
80008504:	c0 41       	brne	8000850c <_vfprintf_r+0x8f0>
80008506:	30 69       	mov	r9,6
80008508:	50 29       	stdsp	sp[0x8],r9
8000850a:	c1 18       	rjmp	8000852c <_vfprintf_r+0x910>
8000850c:	e0 40 00 47 	cp.w	r0,71
80008510:	5f 09       	sreq	r9
80008512:	e0 40 00 67 	cp.w	r0,103
80008516:	5f 08       	sreq	r8
80008518:	f3 e8 10 08 	or	r8,r9,r8
8000851c:	f8 08 18 00 	cp.b	r8,r12
80008520:	c0 60       	breq	8000852c <_vfprintf_r+0x910>
80008522:	40 28       	lddsp	r8,sp[0x8]
80008524:	58 08       	cp.w	r8,0
80008526:	f9 b8 00 01 	moveq	r8,1
8000852a:	50 28       	stdsp	sp[0x8],r8
8000852c:	40 78       	lddsp	r8,sp[0x1c]
8000852e:	40 59       	lddsp	r9,sp[0x14]
80008530:	fa e9 06 94 	st.d	sp[1684],r8
80008534:	a9 a5       	sbr	r5,0x8
80008536:	fa f8 06 94 	ld.w	r8,sp[1684]
8000853a:	58 08       	cp.w	r8,0
8000853c:	c0 65       	brlt	80008548 <_vfprintf_r+0x92c>
8000853e:	40 5e       	lddsp	lr,sp[0x14]
80008540:	30 0c       	mov	r12,0
80008542:	50 6e       	stdsp	sp[0x18],lr
80008544:	50 9c       	stdsp	sp[0x24],r12
80008546:	c0 78       	rjmp	80008554 <_vfprintf_r+0x938>
80008548:	40 5b       	lddsp	r11,sp[0x14]
8000854a:	32 da       	mov	r10,45
8000854c:	ee 1b 80 00 	eorh	r11,0x8000
80008550:	50 9a       	stdsp	sp[0x24],r10
80008552:	50 6b       	stdsp	sp[0x18],r11
80008554:	e0 40 00 46 	cp.w	r0,70
80008558:	5f 09       	sreq	r9
8000855a:	e0 40 00 66 	cp.w	r0,102
8000855e:	5f 08       	sreq	r8
80008560:	f3 e8 10 08 	or	r8,r9,r8
80008564:	50 48       	stdsp	sp[0x10],r8
80008566:	c0 40       	breq	8000856e <_vfprintf_r+0x952>
80008568:	40 22       	lddsp	r2,sp[0x8]
8000856a:	30 39       	mov	r9,3
8000856c:	c1 08       	rjmp	8000858c <_vfprintf_r+0x970>
8000856e:	e0 40 00 45 	cp.w	r0,69
80008572:	5f 09       	sreq	r9
80008574:	e0 40 00 65 	cp.w	r0,101
80008578:	5f 08       	sreq	r8
8000857a:	40 22       	lddsp	r2,sp[0x8]
8000857c:	10 49       	or	r9,r8
8000857e:	2f f2       	sub	r2,-1
80008580:	40 46       	lddsp	r6,sp[0x10]
80008582:	ec 09 18 00 	cp.b	r9,r6
80008586:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000858a:	30 29       	mov	r9,2
8000858c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008590:	1a d8       	st.w	--sp,r8
80008592:	fa c8 f9 54 	sub	r8,sp,-1708
80008596:	1a d8       	st.w	--sp,r8
80008598:	fa c8 f9 4c 	sub	r8,sp,-1716
8000859c:	08 9c       	mov	r12,r4
8000859e:	1a d8       	st.w	--sp,r8
800085a0:	04 98       	mov	r8,r2
800085a2:	40 9b       	lddsp	r11,sp[0x24]
800085a4:	40 aa       	lddsp	r10,sp[0x28]
800085a6:	e0 a0 0b c3 	rcall	80009d2c <_dtoa_r>
800085aa:	e0 40 00 47 	cp.w	r0,71
800085ae:	5f 19       	srne	r9
800085b0:	e0 40 00 67 	cp.w	r0,103
800085b4:	5f 18       	srne	r8
800085b6:	18 96       	mov	r6,r12
800085b8:	2f dd       	sub	sp,-12
800085ba:	f3 e8 00 08 	and	r8,r9,r8
800085be:	c0 41       	brne	800085c6 <_vfprintf_r+0x9aa>
800085c0:	ed b5 00 00 	bld	r5,0x0
800085c4:	c3 01       	brne	80008624 <_vfprintf_r+0xa08>
800085c6:	ec 02 00 0e 	add	lr,r6,r2
800085ca:	50 3e       	stdsp	sp[0xc],lr
800085cc:	40 4c       	lddsp	r12,sp[0x10]
800085ce:	58 0c       	cp.w	r12,0
800085d0:	c1 50       	breq	800085fa <_vfprintf_r+0x9de>
800085d2:	0d 89       	ld.ub	r9,r6[0x0]
800085d4:	33 08       	mov	r8,48
800085d6:	f0 09 18 00 	cp.b	r9,r8
800085da:	c0 b1       	brne	800085f0 <_vfprintf_r+0x9d4>
800085dc:	30 08       	mov	r8,0
800085de:	30 09       	mov	r9,0
800085e0:	40 6b       	lddsp	r11,sp[0x18]
800085e2:	40 7a       	lddsp	r10,sp[0x1c]
800085e4:	e0 a0 1c cb 	rcall	8000bf7a <__avr32_f64_cmp_eq>
800085e8:	fb b2 00 01 	rsubeq	r2,1
800085ec:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800085f0:	40 3b       	lddsp	r11,sp[0xc]
800085f2:	fa f8 06 ac 	ld.w	r8,sp[1708]
800085f6:	10 0b       	add	r11,r8
800085f8:	50 3b       	stdsp	sp[0xc],r11
800085fa:	40 6b       	lddsp	r11,sp[0x18]
800085fc:	30 08       	mov	r8,0
800085fe:	30 09       	mov	r9,0
80008600:	40 7a       	lddsp	r10,sp[0x1c]
80008602:	e0 a0 1c bc 	rcall	8000bf7a <__avr32_f64_cmp_eq>
80008606:	c0 90       	breq	80008618 <_vfprintf_r+0x9fc>
80008608:	40 3a       	lddsp	r10,sp[0xc]
8000860a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000860e:	c0 58       	rjmp	80008618 <_vfprintf_r+0x9fc>
80008610:	10 c9       	st.b	r8++,r9
80008612:	fb 48 06 a4 	st.w	sp[1700],r8
80008616:	c0 28       	rjmp	8000861a <_vfprintf_r+0x9fe>
80008618:	33 09       	mov	r9,48
8000861a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000861e:	40 3e       	lddsp	lr,sp[0xc]
80008620:	1c 38       	cp.w	r8,lr
80008622:	cf 73       	brcs	80008610 <_vfprintf_r+0x9f4>
80008624:	e0 40 00 47 	cp.w	r0,71
80008628:	5f 09       	sreq	r9
8000862a:	e0 40 00 67 	cp.w	r0,103
8000862e:	5f 08       	sreq	r8
80008630:	f3 e8 10 08 	or	r8,r9,r8
80008634:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008638:	0c 19       	sub	r9,r6
8000863a:	50 69       	stdsp	sp[0x18],r9
8000863c:	58 08       	cp.w	r8,0
8000863e:	c0 b0       	breq	80008654 <_vfprintf_r+0xa38>
80008640:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008644:	5b d8       	cp.w	r8,-3
80008646:	c0 55       	brlt	80008650 <_vfprintf_r+0xa34>
80008648:	40 2c       	lddsp	r12,sp[0x8]
8000864a:	18 38       	cp.w	r8,r12
8000864c:	e0 8a 00 6a 	brle	80008720 <_vfprintf_r+0xb04>
80008650:	20 20       	sub	r0,2
80008652:	c0 58       	rjmp	8000865c <_vfprintf_r+0xa40>
80008654:	e0 40 00 65 	cp.w	r0,101
80008658:	e0 89 00 46 	brgt	800086e4 <_vfprintf_r+0xac8>
8000865c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008660:	fb 60 06 9c 	st.b	sp[1692],r0
80008664:	20 1b       	sub	r11,1
80008666:	fb 4b 06 ac 	st.w	sp[1708],r11
8000866a:	c0 47       	brpl	80008672 <_vfprintf_r+0xa56>
8000866c:	5c 3b       	neg	r11
8000866e:	32 d8       	mov	r8,45
80008670:	c0 28       	rjmp	80008674 <_vfprintf_r+0xa58>
80008672:	32 b8       	mov	r8,43
80008674:	fb 68 06 9d 	st.b	sp[1693],r8
80008678:	58 9b       	cp.w	r11,9
8000867a:	e0 8a 00 1d 	brle	800086b4 <_vfprintf_r+0xa98>
8000867e:	fa c9 fa 35 	sub	r9,sp,-1483
80008682:	30 aa       	mov	r10,10
80008684:	12 98       	mov	r8,r9
80008686:	0e 9c       	mov	r12,r7
80008688:	0c 92       	mov	r2,r6
8000868a:	f6 0a 0c 06 	divs	r6,r11,r10
8000868e:	0e 9b       	mov	r11,r7
80008690:	2d 0b       	sub	r11,-48
80008692:	10 fb       	st.b	--r8,r11
80008694:	0c 9b       	mov	r11,r6
80008696:	58 96       	cp.w	r6,9
80008698:	fe 99 ff f9 	brgt	8000868a <_vfprintf_r+0xa6e>
8000869c:	2d 0b       	sub	r11,-48
8000869e:	18 97       	mov	r7,r12
800086a0:	04 96       	mov	r6,r2
800086a2:	10 fb       	st.b	--r8,r11
800086a4:	fa ca f9 62 	sub	r10,sp,-1694
800086a8:	c0 38       	rjmp	800086ae <_vfprintf_r+0xa92>
800086aa:	11 3b       	ld.ub	r11,r8++
800086ac:	14 cb       	st.b	r10++,r11
800086ae:	12 38       	cp.w	r8,r9
800086b0:	cf d3       	brcs	800086aa <_vfprintf_r+0xa8e>
800086b2:	c0 98       	rjmp	800086c4 <_vfprintf_r+0xaa8>
800086b4:	2d 0b       	sub	r11,-48
800086b6:	33 08       	mov	r8,48
800086b8:	fb 6b 06 9f 	st.b	sp[1695],r11
800086bc:	fb 68 06 9e 	st.b	sp[1694],r8
800086c0:	fa ca f9 60 	sub	r10,sp,-1696
800086c4:	fa c8 f9 64 	sub	r8,sp,-1692
800086c8:	f4 08 01 08 	sub	r8,r10,r8
800086cc:	50 e8       	stdsp	sp[0x38],r8
800086ce:	10 92       	mov	r2,r8
800086d0:	40 6b       	lddsp	r11,sp[0x18]
800086d2:	16 02       	add	r2,r11
800086d4:	58 1b       	cp.w	r11,1
800086d6:	e0 89 00 05 	brgt	800086e0 <_vfprintf_r+0xac4>
800086da:	ed b5 00 00 	bld	r5,0x0
800086de:	c3 51       	brne	80008748 <_vfprintf_r+0xb2c>
800086e0:	2f f2       	sub	r2,-1
800086e2:	c3 38       	rjmp	80008748 <_vfprintf_r+0xb2c>
800086e4:	e0 40 00 66 	cp.w	r0,102
800086e8:	c1 c1       	brne	80008720 <_vfprintf_r+0xb04>
800086ea:	fa f2 06 ac 	ld.w	r2,sp[1708]
800086ee:	58 02       	cp.w	r2,0
800086f0:	e0 8a 00 0c 	brle	80008708 <_vfprintf_r+0xaec>
800086f4:	40 2a       	lddsp	r10,sp[0x8]
800086f6:	58 0a       	cp.w	r10,0
800086f8:	c0 41       	brne	80008700 <_vfprintf_r+0xae4>
800086fa:	ed b5 00 00 	bld	r5,0x0
800086fe:	c2 51       	brne	80008748 <_vfprintf_r+0xb2c>
80008700:	2f f2       	sub	r2,-1
80008702:	40 29       	lddsp	r9,sp[0x8]
80008704:	12 02       	add	r2,r9
80008706:	c0 b8       	rjmp	8000871c <_vfprintf_r+0xb00>
80008708:	40 28       	lddsp	r8,sp[0x8]
8000870a:	58 08       	cp.w	r8,0
8000870c:	c0 61       	brne	80008718 <_vfprintf_r+0xafc>
8000870e:	ed b5 00 00 	bld	r5,0x0
80008712:	c0 30       	breq	80008718 <_vfprintf_r+0xafc>
80008714:	30 12       	mov	r2,1
80008716:	c1 98       	rjmp	80008748 <_vfprintf_r+0xb2c>
80008718:	40 22       	lddsp	r2,sp[0x8]
8000871a:	2f e2       	sub	r2,-2
8000871c:	36 60       	mov	r0,102
8000871e:	c1 58       	rjmp	80008748 <_vfprintf_r+0xb2c>
80008720:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008724:	40 6e       	lddsp	lr,sp[0x18]
80008726:	1c 32       	cp.w	r2,lr
80008728:	c0 65       	brlt	80008734 <_vfprintf_r+0xb18>
8000872a:	ed b5 00 00 	bld	r5,0x0
8000872e:	f7 b2 00 ff 	subeq	r2,-1
80008732:	c0 a8       	rjmp	80008746 <_vfprintf_r+0xb2a>
80008734:	e4 08 11 02 	rsub	r8,r2,2
80008738:	40 6c       	lddsp	r12,sp[0x18]
8000873a:	58 02       	cp.w	r2,0
8000873c:	f0 02 17 a0 	movle	r2,r8
80008740:	f9 b2 09 01 	movgt	r2,1
80008744:	18 02       	add	r2,r12
80008746:	36 70       	mov	r0,103
80008748:	40 9b       	lddsp	r11,sp[0x24]
8000874a:	58 0b       	cp.w	r11,0
8000874c:	e0 80 05 94 	breq	80009274 <_vfprintf_r+0x1658>
80008750:	32 d8       	mov	r8,45
80008752:	fb 68 06 bb 	st.b	sp[1723],r8
80008756:	e0 8f 05 93 	bral	8000927c <_vfprintf_r+0x1660>
8000875a:	50 a7       	stdsp	sp[0x28],r7
8000875c:	04 94       	mov	r4,r2
8000875e:	0c 97       	mov	r7,r6
80008760:	02 92       	mov	r2,r1
80008762:	06 96       	mov	r6,r3
80008764:	40 41       	lddsp	r1,sp[0x10]
80008766:	40 93       	lddsp	r3,sp[0x24]
80008768:	0e 99       	mov	r9,r7
8000876a:	ed b5 00 05 	bld	r5,0x5
8000876e:	c4 81       	brne	800087fe <_vfprintf_r+0xbe2>
80008770:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008774:	40 3e       	lddsp	lr,sp[0xc]
80008776:	58 0e       	cp.w	lr,0
80008778:	c1 d0       	breq	800087b2 <_vfprintf_r+0xb96>
8000877a:	10 36       	cp.w	r6,r8
8000877c:	c0 64       	brge	80008788 <_vfprintf_r+0xb6c>
8000877e:	fa cc f9 44 	sub	r12,sp,-1724
80008782:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008786:	c1 d8       	rjmp	800087c0 <_vfprintf_r+0xba4>
80008788:	fa c8 f9 50 	sub	r8,sp,-1712
8000878c:	1a d8       	st.w	--sp,r8
8000878e:	fa c8 fa b8 	sub	r8,sp,-1352
80008792:	04 9a       	mov	r10,r2
80008794:	1a d8       	st.w	--sp,r8
80008796:	fa c8 fb b4 	sub	r8,sp,-1100
8000879a:	0c 9b       	mov	r11,r6
8000879c:	1a d8       	st.w	--sp,r8
8000879e:	08 9c       	mov	r12,r4
800087a0:	fa c8 f9 40 	sub	r8,sp,-1728
800087a4:	fa c9 ff b4 	sub	r9,sp,-76
800087a8:	fe b0 f8 a2 	rcall	800078ec <get_arg>
800087ac:	2f dd       	sub	sp,-12
800087ae:	78 0a       	ld.w	r10,r12[0x0]
800087b0:	c2 08       	rjmp	800087f0 <_vfprintf_r+0xbd4>
800087b2:	2f f7       	sub	r7,-1
800087b4:	10 39       	cp.w	r9,r8
800087b6:	c0 84       	brge	800087c6 <_vfprintf_r+0xbaa>
800087b8:	fa cb f9 44 	sub	r11,sp,-1724
800087bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087c0:	ec fa fd 88 	ld.w	r10,r6[-632]
800087c4:	c1 68       	rjmp	800087f0 <_vfprintf_r+0xbd4>
800087c6:	41 09       	lddsp	r9,sp[0x40]
800087c8:	59 f8       	cp.w	r8,31
800087ca:	e0 89 00 10 	brgt	800087ea <_vfprintf_r+0xbce>
800087ce:	f2 ca ff fc 	sub	r10,r9,-4
800087d2:	51 0a       	stdsp	sp[0x40],r10
800087d4:	fa c6 f9 44 	sub	r6,sp,-1724
800087d8:	72 0a       	ld.w	r10,r9[0x0]
800087da:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087de:	f3 4a fd 88 	st.w	r9[-632],r10
800087e2:	2f f8       	sub	r8,-1
800087e4:	fb 48 06 b4 	st.w	sp[1716],r8
800087e8:	c0 48       	rjmp	800087f0 <_vfprintf_r+0xbd4>
800087ea:	72 0a       	ld.w	r10,r9[0x0]
800087ec:	2f c9       	sub	r9,-4
800087ee:	51 09       	stdsp	sp[0x40],r9
800087f0:	40 be       	lddsp	lr,sp[0x2c]
800087f2:	1c 98       	mov	r8,lr
800087f4:	95 1e       	st.w	r10[0x4],lr
800087f6:	bf 58       	asr	r8,0x1f
800087f8:	95 08       	st.w	r10[0x0],r8
800087fa:	fe 9f fa 9f 	bral	80007d38 <_vfprintf_r+0x11c>
800087fe:	ed b5 00 04 	bld	r5,0x4
80008802:	c4 80       	breq	80008892 <_vfprintf_r+0xc76>
80008804:	e2 15 00 40 	andl	r5,0x40,COH
80008808:	c4 50       	breq	80008892 <_vfprintf_r+0xc76>
8000880a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000880e:	40 3c       	lddsp	r12,sp[0xc]
80008810:	58 0c       	cp.w	r12,0
80008812:	c1 d0       	breq	8000884c <_vfprintf_r+0xc30>
80008814:	10 36       	cp.w	r6,r8
80008816:	c0 64       	brge	80008822 <_vfprintf_r+0xc06>
80008818:	fa cb f9 44 	sub	r11,sp,-1724
8000881c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008820:	c1 d8       	rjmp	8000885a <_vfprintf_r+0xc3e>
80008822:	fa c8 f9 50 	sub	r8,sp,-1712
80008826:	1a d8       	st.w	--sp,r8
80008828:	fa c8 fa b8 	sub	r8,sp,-1352
8000882c:	04 9a       	mov	r10,r2
8000882e:	1a d8       	st.w	--sp,r8
80008830:	fa c8 fb b4 	sub	r8,sp,-1100
80008834:	0c 9b       	mov	r11,r6
80008836:	1a d8       	st.w	--sp,r8
80008838:	08 9c       	mov	r12,r4
8000883a:	fa c8 f9 40 	sub	r8,sp,-1728
8000883e:	fa c9 ff b4 	sub	r9,sp,-76
80008842:	fe b0 f8 55 	rcall	800078ec <get_arg>
80008846:	2f dd       	sub	sp,-12
80008848:	78 0a       	ld.w	r10,r12[0x0]
8000884a:	c2 08       	rjmp	8000888a <_vfprintf_r+0xc6e>
8000884c:	2f f7       	sub	r7,-1
8000884e:	10 39       	cp.w	r9,r8
80008850:	c0 84       	brge	80008860 <_vfprintf_r+0xc44>
80008852:	fa ca f9 44 	sub	r10,sp,-1724
80008856:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000885a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000885e:	c1 68       	rjmp	8000888a <_vfprintf_r+0xc6e>
80008860:	41 09       	lddsp	r9,sp[0x40]
80008862:	59 f8       	cp.w	r8,31
80008864:	e0 89 00 10 	brgt	80008884 <_vfprintf_r+0xc68>
80008868:	f2 ca ff fc 	sub	r10,r9,-4
8000886c:	51 0a       	stdsp	sp[0x40],r10
8000886e:	fa c6 f9 44 	sub	r6,sp,-1724
80008872:	72 0a       	ld.w	r10,r9[0x0]
80008874:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008878:	f3 4a fd 88 	st.w	r9[-632],r10
8000887c:	2f f8       	sub	r8,-1
8000887e:	fb 48 06 b4 	st.w	sp[1716],r8
80008882:	c0 48       	rjmp	8000888a <_vfprintf_r+0xc6e>
80008884:	72 0a       	ld.w	r10,r9[0x0]
80008886:	2f c9       	sub	r9,-4
80008888:	51 09       	stdsp	sp[0x40],r9
8000888a:	40 be       	lddsp	lr,sp[0x2c]
8000888c:	b4 0e       	st.h	r10[0x0],lr
8000888e:	fe 9f fa 55 	bral	80007d38 <_vfprintf_r+0x11c>
80008892:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008896:	40 3c       	lddsp	r12,sp[0xc]
80008898:	58 0c       	cp.w	r12,0
8000889a:	c1 d0       	breq	800088d4 <_vfprintf_r+0xcb8>
8000889c:	10 36       	cp.w	r6,r8
8000889e:	c0 64       	brge	800088aa <_vfprintf_r+0xc8e>
800088a0:	fa cb f9 44 	sub	r11,sp,-1724
800088a4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088a8:	c1 d8       	rjmp	800088e2 <_vfprintf_r+0xcc6>
800088aa:	fa c8 f9 50 	sub	r8,sp,-1712
800088ae:	1a d8       	st.w	--sp,r8
800088b0:	fa c8 fa b8 	sub	r8,sp,-1352
800088b4:	04 9a       	mov	r10,r2
800088b6:	1a d8       	st.w	--sp,r8
800088b8:	fa c8 fb b4 	sub	r8,sp,-1100
800088bc:	0c 9b       	mov	r11,r6
800088be:	1a d8       	st.w	--sp,r8
800088c0:	08 9c       	mov	r12,r4
800088c2:	fa c8 f9 40 	sub	r8,sp,-1728
800088c6:	fa c9 ff b4 	sub	r9,sp,-76
800088ca:	fe b0 f8 11 	rcall	800078ec <get_arg>
800088ce:	2f dd       	sub	sp,-12
800088d0:	78 0a       	ld.w	r10,r12[0x0]
800088d2:	c2 08       	rjmp	80008912 <_vfprintf_r+0xcf6>
800088d4:	2f f7       	sub	r7,-1
800088d6:	10 39       	cp.w	r9,r8
800088d8:	c0 84       	brge	800088e8 <_vfprintf_r+0xccc>
800088da:	fa ca f9 44 	sub	r10,sp,-1724
800088de:	f4 06 00 36 	add	r6,r10,r6<<0x3
800088e2:	ec fa fd 88 	ld.w	r10,r6[-632]
800088e6:	c1 68       	rjmp	80008912 <_vfprintf_r+0xcf6>
800088e8:	41 09       	lddsp	r9,sp[0x40]
800088ea:	59 f8       	cp.w	r8,31
800088ec:	e0 89 00 10 	brgt	8000890c <_vfprintf_r+0xcf0>
800088f0:	f2 ca ff fc 	sub	r10,r9,-4
800088f4:	51 0a       	stdsp	sp[0x40],r10
800088f6:	fa c6 f9 44 	sub	r6,sp,-1724
800088fa:	72 0a       	ld.w	r10,r9[0x0]
800088fc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008900:	f3 4a fd 88 	st.w	r9[-632],r10
80008904:	2f f8       	sub	r8,-1
80008906:	fb 48 06 b4 	st.w	sp[1716],r8
8000890a:	c0 48       	rjmp	80008912 <_vfprintf_r+0xcf6>
8000890c:	72 0a       	ld.w	r10,r9[0x0]
8000890e:	2f c9       	sub	r9,-4
80008910:	51 09       	stdsp	sp[0x40],r9
80008912:	40 be       	lddsp	lr,sp[0x2c]
80008914:	95 0e       	st.w	r10[0x0],lr
80008916:	fe 9f fa 11 	bral	80007d38 <_vfprintf_r+0x11c>
8000891a:	50 a7       	stdsp	sp[0x28],r7
8000891c:	50 80       	stdsp	sp[0x20],r0
8000891e:	0c 97       	mov	r7,r6
80008920:	04 94       	mov	r4,r2
80008922:	06 96       	mov	r6,r3
80008924:	02 92       	mov	r2,r1
80008926:	40 93       	lddsp	r3,sp[0x24]
80008928:	10 90       	mov	r0,r8
8000892a:	40 41       	lddsp	r1,sp[0x10]
8000892c:	a5 a5       	sbr	r5,0x4
8000892e:	c0 a8       	rjmp	80008942 <_vfprintf_r+0xd26>
80008930:	50 a7       	stdsp	sp[0x28],r7
80008932:	50 80       	stdsp	sp[0x20],r0
80008934:	0c 97       	mov	r7,r6
80008936:	04 94       	mov	r4,r2
80008938:	06 96       	mov	r6,r3
8000893a:	02 92       	mov	r2,r1
8000893c:	40 93       	lddsp	r3,sp[0x24]
8000893e:	10 90       	mov	r0,r8
80008940:	40 41       	lddsp	r1,sp[0x10]
80008942:	ed b5 00 05 	bld	r5,0x5
80008946:	c5 d1       	brne	80008a00 <_vfprintf_r+0xde4>
80008948:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000894c:	40 3c       	lddsp	r12,sp[0xc]
8000894e:	58 0c       	cp.w	r12,0
80008950:	c2 60       	breq	8000899c <_vfprintf_r+0xd80>
80008952:	10 36       	cp.w	r6,r8
80008954:	c0 a4       	brge	80008968 <_vfprintf_r+0xd4c>
80008956:	fa cb f9 44 	sub	r11,sp,-1724
8000895a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000895e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008962:	fa e9 00 00 	st.d	sp[0],r8
80008966:	c1 88       	rjmp	80008996 <_vfprintf_r+0xd7a>
80008968:	fa c8 f9 50 	sub	r8,sp,-1712
8000896c:	1a d8       	st.w	--sp,r8
8000896e:	fa c8 fa b8 	sub	r8,sp,-1352
80008972:	04 9a       	mov	r10,r2
80008974:	1a d8       	st.w	--sp,r8
80008976:	0c 9b       	mov	r11,r6
80008978:	fa c8 fb b4 	sub	r8,sp,-1100
8000897c:	08 9c       	mov	r12,r4
8000897e:	1a d8       	st.w	--sp,r8
80008980:	fa c8 f9 40 	sub	r8,sp,-1728
80008984:	fa c9 ff b4 	sub	r9,sp,-76
80008988:	fe b0 f7 b2 	rcall	800078ec <get_arg>
8000898c:	2f dd       	sub	sp,-12
8000898e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008992:	fa eb 00 00 	st.d	sp[0],r10
80008996:	30 08       	mov	r8,0
80008998:	e0 8f 03 de 	bral	80009154 <_vfprintf_r+0x1538>
8000899c:	ee ca ff ff 	sub	r10,r7,-1
800089a0:	10 37       	cp.w	r7,r8
800089a2:	c0 b4       	brge	800089b8 <_vfprintf_r+0xd9c>
800089a4:	fa c9 f9 44 	sub	r9,sp,-1724
800089a8:	14 97       	mov	r7,r10
800089aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089ae:	ec ea fd 88 	ld.d	r10,r6[-632]
800089b2:	fa eb 00 00 	st.d	sp[0],r10
800089b6:	c1 88       	rjmp	800089e6 <_vfprintf_r+0xdca>
800089b8:	41 09       	lddsp	r9,sp[0x40]
800089ba:	59 f8       	cp.w	r8,31
800089bc:	e0 89 00 18 	brgt	800089ec <_vfprintf_r+0xdd0>
800089c0:	f2 e6 00 00 	ld.d	r6,r9[0]
800089c4:	f2 cb ff f8 	sub	r11,r9,-8
800089c8:	fa e7 00 00 	st.d	sp[0],r6
800089cc:	51 0b       	stdsp	sp[0x40],r11
800089ce:	fa c6 f9 44 	sub	r6,sp,-1724
800089d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089d6:	fa e6 00 00 	ld.d	r6,sp[0]
800089da:	f2 e7 fd 88 	st.d	r9[-632],r6
800089de:	2f f8       	sub	r8,-1
800089e0:	14 97       	mov	r7,r10
800089e2:	fb 48 06 b4 	st.w	sp[1716],r8
800089e6:	40 38       	lddsp	r8,sp[0xc]
800089e8:	e0 8f 03 b6 	bral	80009154 <_vfprintf_r+0x1538>
800089ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800089f0:	40 38       	lddsp	r8,sp[0xc]
800089f2:	fa e7 00 00 	st.d	sp[0],r6
800089f6:	2f 89       	sub	r9,-8
800089f8:	14 97       	mov	r7,r10
800089fa:	51 09       	stdsp	sp[0x40],r9
800089fc:	e0 8f 03 ac 	bral	80009154 <_vfprintf_r+0x1538>
80008a00:	ed b5 00 04 	bld	r5,0x4
80008a04:	c1 61       	brne	80008a30 <_vfprintf_r+0xe14>
80008a06:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a0a:	40 3e       	lddsp	lr,sp[0xc]
80008a0c:	58 0e       	cp.w	lr,0
80008a0e:	c0 80       	breq	80008a1e <_vfprintf_r+0xe02>
80008a10:	10 36       	cp.w	r6,r8
80008a12:	c6 74       	brge	80008ae0 <_vfprintf_r+0xec4>
80008a14:	fa cc f9 44 	sub	r12,sp,-1724
80008a18:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a1c:	c8 08       	rjmp	80008b1c <_vfprintf_r+0xf00>
80008a1e:	ee ca ff ff 	sub	r10,r7,-1
80008a22:	10 37       	cp.w	r7,r8
80008a24:	c7 f4       	brge	80008b22 <_vfprintf_r+0xf06>
80008a26:	fa cb f9 44 	sub	r11,sp,-1724
80008a2a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a2e:	c7 68       	rjmp	80008b1a <_vfprintf_r+0xefe>
80008a30:	ed b5 00 06 	bld	r5,0x6
80008a34:	c4 a1       	brne	80008ac8 <_vfprintf_r+0xeac>
80008a36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a3a:	40 3c       	lddsp	r12,sp[0xc]
80008a3c:	58 0c       	cp.w	r12,0
80008a3e:	c1 d0       	breq	80008a78 <_vfprintf_r+0xe5c>
80008a40:	10 36       	cp.w	r6,r8
80008a42:	c0 64       	brge	80008a4e <_vfprintf_r+0xe32>
80008a44:	fa cb f9 44 	sub	r11,sp,-1724
80008a48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a4c:	c1 f8       	rjmp	80008a8a <_vfprintf_r+0xe6e>
80008a4e:	fa c8 f9 50 	sub	r8,sp,-1712
80008a52:	1a d8       	st.w	--sp,r8
80008a54:	fa c8 fa b8 	sub	r8,sp,-1352
80008a58:	1a d8       	st.w	--sp,r8
80008a5a:	fa c8 fb b4 	sub	r8,sp,-1100
80008a5e:	1a d8       	st.w	--sp,r8
80008a60:	fa c8 f9 40 	sub	r8,sp,-1728
80008a64:	fa c9 ff b4 	sub	r9,sp,-76
80008a68:	04 9a       	mov	r10,r2
80008a6a:	0c 9b       	mov	r11,r6
80008a6c:	08 9c       	mov	r12,r4
80008a6e:	fe b0 f7 3f 	rcall	800078ec <get_arg>
80008a72:	2f dd       	sub	sp,-12
80008a74:	98 18       	ld.sh	r8,r12[0x2]
80008a76:	c2 68       	rjmp	80008ac2 <_vfprintf_r+0xea6>
80008a78:	ee ca ff ff 	sub	r10,r7,-1
80008a7c:	10 37       	cp.w	r7,r8
80008a7e:	c0 94       	brge	80008a90 <_vfprintf_r+0xe74>
80008a80:	fa c9 f9 44 	sub	r9,sp,-1724
80008a84:	14 97       	mov	r7,r10
80008a86:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a8a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a8e:	c1 a8       	rjmp	80008ac2 <_vfprintf_r+0xea6>
80008a90:	41 09       	lddsp	r9,sp[0x40]
80008a92:	59 f8       	cp.w	r8,31
80008a94:	e0 89 00 13 	brgt	80008aba <_vfprintf_r+0xe9e>
80008a98:	f2 cb ff fc 	sub	r11,r9,-4
80008a9c:	51 0b       	stdsp	sp[0x40],r11
80008a9e:	72 09       	ld.w	r9,r9[0x0]
80008aa0:	fa c6 f9 44 	sub	r6,sp,-1724
80008aa4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008aa8:	2f f8       	sub	r8,-1
80008aaa:	f7 49 fd 88 	st.w	r11[-632],r9
80008aae:	fb 48 06 b4 	st.w	sp[1716],r8
80008ab2:	14 97       	mov	r7,r10
80008ab4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008ab8:	c0 58       	rjmp	80008ac2 <_vfprintf_r+0xea6>
80008aba:	92 18       	ld.sh	r8,r9[0x2]
80008abc:	14 97       	mov	r7,r10
80008abe:	2f c9       	sub	r9,-4
80008ac0:	51 09       	stdsp	sp[0x40],r9
80008ac2:	5c 78       	castu.h	r8
80008ac4:	50 18       	stdsp	sp[0x4],r8
80008ac6:	c4 68       	rjmp	80008b52 <_vfprintf_r+0xf36>
80008ac8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008acc:	40 3c       	lddsp	r12,sp[0xc]
80008ace:	58 0c       	cp.w	r12,0
80008ad0:	c1 d0       	breq	80008b0a <_vfprintf_r+0xeee>
80008ad2:	10 36       	cp.w	r6,r8
80008ad4:	c0 64       	brge	80008ae0 <_vfprintf_r+0xec4>
80008ad6:	fa cb f9 44 	sub	r11,sp,-1724
80008ada:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ade:	c1 f8       	rjmp	80008b1c <_vfprintf_r+0xf00>
80008ae0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ae4:	1a d8       	st.w	--sp,r8
80008ae6:	fa c8 fa b8 	sub	r8,sp,-1352
80008aea:	0c 9b       	mov	r11,r6
80008aec:	1a d8       	st.w	--sp,r8
80008aee:	fa c8 fb b4 	sub	r8,sp,-1100
80008af2:	04 9a       	mov	r10,r2
80008af4:	1a d8       	st.w	--sp,r8
80008af6:	08 9c       	mov	r12,r4
80008af8:	fa c8 f9 40 	sub	r8,sp,-1728
80008afc:	fa c9 ff b4 	sub	r9,sp,-76
80008b00:	fe b0 f6 f6 	rcall	800078ec <get_arg>
80008b04:	2f dd       	sub	sp,-12
80008b06:	78 0b       	ld.w	r11,r12[0x0]
80008b08:	c2 48       	rjmp	80008b50 <_vfprintf_r+0xf34>
80008b0a:	ee ca ff ff 	sub	r10,r7,-1
80008b0e:	10 37       	cp.w	r7,r8
80008b10:	c0 94       	brge	80008b22 <_vfprintf_r+0xf06>
80008b12:	fa c9 f9 44 	sub	r9,sp,-1724
80008b16:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b1a:	14 97       	mov	r7,r10
80008b1c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b20:	c1 88       	rjmp	80008b50 <_vfprintf_r+0xf34>
80008b22:	41 09       	lddsp	r9,sp[0x40]
80008b24:	59 f8       	cp.w	r8,31
80008b26:	e0 89 00 11 	brgt	80008b48 <_vfprintf_r+0xf2c>
80008b2a:	f2 cb ff fc 	sub	r11,r9,-4
80008b2e:	51 0b       	stdsp	sp[0x40],r11
80008b30:	fa c6 f9 44 	sub	r6,sp,-1724
80008b34:	72 0b       	ld.w	r11,r9[0x0]
80008b36:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b3a:	f3 4b fd 88 	st.w	r9[-632],r11
80008b3e:	2f f8       	sub	r8,-1
80008b40:	14 97       	mov	r7,r10
80008b42:	fb 48 06 b4 	st.w	sp[1716],r8
80008b46:	c0 58       	rjmp	80008b50 <_vfprintf_r+0xf34>
80008b48:	72 0b       	ld.w	r11,r9[0x0]
80008b4a:	14 97       	mov	r7,r10
80008b4c:	2f c9       	sub	r9,-4
80008b4e:	51 09       	stdsp	sp[0x40],r9
80008b50:	50 1b       	stdsp	sp[0x4],r11
80008b52:	30 0e       	mov	lr,0
80008b54:	50 0e       	stdsp	sp[0x0],lr
80008b56:	1c 98       	mov	r8,lr
80008b58:	e0 8f 02 fe 	bral	80009154 <_vfprintf_r+0x1538>
80008b5c:	50 a7       	stdsp	sp[0x28],r7
80008b5e:	50 80       	stdsp	sp[0x20],r0
80008b60:	0c 97       	mov	r7,r6
80008b62:	04 94       	mov	r4,r2
80008b64:	06 96       	mov	r6,r3
80008b66:	02 92       	mov	r2,r1
80008b68:	40 93       	lddsp	r3,sp[0x24]
80008b6a:	40 41       	lddsp	r1,sp[0x10]
80008b6c:	0e 99       	mov	r9,r7
80008b6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b72:	40 3c       	lddsp	r12,sp[0xc]
80008b74:	58 0c       	cp.w	r12,0
80008b76:	c1 d0       	breq	80008bb0 <_vfprintf_r+0xf94>
80008b78:	10 36       	cp.w	r6,r8
80008b7a:	c0 64       	brge	80008b86 <_vfprintf_r+0xf6a>
80008b7c:	fa cb f9 44 	sub	r11,sp,-1724
80008b80:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b84:	c1 d8       	rjmp	80008bbe <_vfprintf_r+0xfa2>
80008b86:	fa c8 f9 50 	sub	r8,sp,-1712
80008b8a:	1a d8       	st.w	--sp,r8
80008b8c:	fa c8 fa b8 	sub	r8,sp,-1352
80008b90:	1a d8       	st.w	--sp,r8
80008b92:	fa c8 fb b4 	sub	r8,sp,-1100
80008b96:	1a d8       	st.w	--sp,r8
80008b98:	fa c9 ff b4 	sub	r9,sp,-76
80008b9c:	fa c8 f9 40 	sub	r8,sp,-1728
80008ba0:	04 9a       	mov	r10,r2
80008ba2:	0c 9b       	mov	r11,r6
80008ba4:	08 9c       	mov	r12,r4
80008ba6:	fe b0 f6 a3 	rcall	800078ec <get_arg>
80008baa:	2f dd       	sub	sp,-12
80008bac:	78 09       	ld.w	r9,r12[0x0]
80008bae:	c2 18       	rjmp	80008bf0 <_vfprintf_r+0xfd4>
80008bb0:	2f f7       	sub	r7,-1
80008bb2:	10 39       	cp.w	r9,r8
80008bb4:	c0 84       	brge	80008bc4 <_vfprintf_r+0xfa8>
80008bb6:	fa ca f9 44 	sub	r10,sp,-1724
80008bba:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bbe:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008bc2:	c1 78       	rjmp	80008bf0 <_vfprintf_r+0xfd4>
80008bc4:	41 09       	lddsp	r9,sp[0x40]
80008bc6:	59 f8       	cp.w	r8,31
80008bc8:	e0 89 00 10 	brgt	80008be8 <_vfprintf_r+0xfcc>
80008bcc:	f2 ca ff fc 	sub	r10,r9,-4
80008bd0:	51 0a       	stdsp	sp[0x40],r10
80008bd2:	fa c6 f9 44 	sub	r6,sp,-1724
80008bd6:	72 09       	ld.w	r9,r9[0x0]
80008bd8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008bdc:	f5 49 fd 88 	st.w	r10[-632],r9
80008be0:	2f f8       	sub	r8,-1
80008be2:	fb 48 06 b4 	st.w	sp[1716],r8
80008be6:	c0 58       	rjmp	80008bf0 <_vfprintf_r+0xfd4>
80008be8:	f2 c8 ff fc 	sub	r8,r9,-4
80008bec:	51 08       	stdsp	sp[0x40],r8
80008bee:	72 09       	ld.w	r9,r9[0x0]
80008bf0:	33 08       	mov	r8,48
80008bf2:	fb 68 06 b8 	st.b	sp[1720],r8
80008bf6:	37 88       	mov	r8,120
80008bf8:	30 0e       	mov	lr,0
80008bfa:	fb 68 06 b9 	st.b	sp[1721],r8
80008bfe:	fe cc b3 02 	sub	r12,pc,-19710
80008c02:	50 19       	stdsp	sp[0x4],r9
80008c04:	a1 b5       	sbr	r5,0x1
80008c06:	50 0e       	stdsp	sp[0x0],lr
80008c08:	50 dc       	stdsp	sp[0x34],r12
80008c0a:	30 28       	mov	r8,2
80008c0c:	37 80       	mov	r0,120
80008c0e:	e0 8f 02 a3 	bral	80009154 <_vfprintf_r+0x1538>
80008c12:	50 a7       	stdsp	sp[0x28],r7
80008c14:	50 80       	stdsp	sp[0x20],r0
80008c16:	10 90       	mov	r0,r8
80008c18:	30 08       	mov	r8,0
80008c1a:	fb 68 06 bb 	st.b	sp[1723],r8
80008c1e:	0c 97       	mov	r7,r6
80008c20:	04 94       	mov	r4,r2
80008c22:	06 96       	mov	r6,r3
80008c24:	02 92       	mov	r2,r1
80008c26:	40 93       	lddsp	r3,sp[0x24]
80008c28:	40 41       	lddsp	r1,sp[0x10]
80008c2a:	0e 99       	mov	r9,r7
80008c2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c30:	40 3b       	lddsp	r11,sp[0xc]
80008c32:	58 0b       	cp.w	r11,0
80008c34:	c1 d0       	breq	80008c6e <_vfprintf_r+0x1052>
80008c36:	10 36       	cp.w	r6,r8
80008c38:	c0 64       	brge	80008c44 <_vfprintf_r+0x1028>
80008c3a:	fa ca f9 44 	sub	r10,sp,-1724
80008c3e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c42:	c1 d8       	rjmp	80008c7c <_vfprintf_r+0x1060>
80008c44:	fa c8 f9 50 	sub	r8,sp,-1712
80008c48:	1a d8       	st.w	--sp,r8
80008c4a:	fa c8 fa b8 	sub	r8,sp,-1352
80008c4e:	1a d8       	st.w	--sp,r8
80008c50:	fa c8 fb b4 	sub	r8,sp,-1100
80008c54:	0c 9b       	mov	r11,r6
80008c56:	1a d8       	st.w	--sp,r8
80008c58:	04 9a       	mov	r10,r2
80008c5a:	fa c8 f9 40 	sub	r8,sp,-1728
80008c5e:	fa c9 ff b4 	sub	r9,sp,-76
80008c62:	08 9c       	mov	r12,r4
80008c64:	fe b0 f6 44 	rcall	800078ec <get_arg>
80008c68:	2f dd       	sub	sp,-12
80008c6a:	78 06       	ld.w	r6,r12[0x0]
80008c6c:	c2 08       	rjmp	80008cac <_vfprintf_r+0x1090>
80008c6e:	2f f7       	sub	r7,-1
80008c70:	10 39       	cp.w	r9,r8
80008c72:	c0 84       	brge	80008c82 <_vfprintf_r+0x1066>
80008c74:	fa c9 f9 44 	sub	r9,sp,-1724
80008c78:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c7c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008c80:	c1 68       	rjmp	80008cac <_vfprintf_r+0x1090>
80008c82:	41 09       	lddsp	r9,sp[0x40]
80008c84:	59 f8       	cp.w	r8,31
80008c86:	e0 89 00 10 	brgt	80008ca6 <_vfprintf_r+0x108a>
80008c8a:	f2 ca ff fc 	sub	r10,r9,-4
80008c8e:	51 0a       	stdsp	sp[0x40],r10
80008c90:	72 06       	ld.w	r6,r9[0x0]
80008c92:	fa ce f9 44 	sub	lr,sp,-1724
80008c96:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008c9a:	f3 46 fd 88 	st.w	r9[-632],r6
80008c9e:	2f f8       	sub	r8,-1
80008ca0:	fb 48 06 b4 	st.w	sp[1716],r8
80008ca4:	c0 48       	rjmp	80008cac <_vfprintf_r+0x1090>
80008ca6:	72 06       	ld.w	r6,r9[0x0]
80008ca8:	2f c9       	sub	r9,-4
80008caa:	51 09       	stdsp	sp[0x40],r9
80008cac:	40 2c       	lddsp	r12,sp[0x8]
80008cae:	58 0c       	cp.w	r12,0
80008cb0:	c1 05       	brlt	80008cd0 <_vfprintf_r+0x10b4>
80008cb2:	18 9a       	mov	r10,r12
80008cb4:	30 0b       	mov	r11,0
80008cb6:	0c 9c       	mov	r12,r6
80008cb8:	e0 a0 12 38 	rcall	8000b128 <memchr>
80008cbc:	e0 80 02 df 	breq	8000927a <_vfprintf_r+0x165e>
80008cc0:	f8 06 01 02 	sub	r2,r12,r6
80008cc4:	40 2b       	lddsp	r11,sp[0x8]
80008cc6:	16 32       	cp.w	r2,r11
80008cc8:	e0 89 02 d9 	brgt	8000927a <_vfprintf_r+0x165e>
80008ccc:	e0 8f 02 d4 	bral	80009274 <_vfprintf_r+0x1658>
80008cd0:	30 0a       	mov	r10,0
80008cd2:	0c 9c       	mov	r12,r6
80008cd4:	50 2a       	stdsp	sp[0x8],r10
80008cd6:	fe b0 f5 85 	rcall	800077e0 <strlen>
80008cda:	18 92       	mov	r2,r12
80008cdc:	e0 8f 02 d2 	bral	80009280 <_vfprintf_r+0x1664>
80008ce0:	50 a7       	stdsp	sp[0x28],r7
80008ce2:	50 80       	stdsp	sp[0x20],r0
80008ce4:	0c 97       	mov	r7,r6
80008ce6:	04 94       	mov	r4,r2
80008ce8:	06 96       	mov	r6,r3
80008cea:	02 92       	mov	r2,r1
80008cec:	40 93       	lddsp	r3,sp[0x24]
80008cee:	10 90       	mov	r0,r8
80008cf0:	40 41       	lddsp	r1,sp[0x10]
80008cf2:	a5 a5       	sbr	r5,0x4
80008cf4:	c0 a8       	rjmp	80008d08 <_vfprintf_r+0x10ec>
80008cf6:	50 a7       	stdsp	sp[0x28],r7
80008cf8:	50 80       	stdsp	sp[0x20],r0
80008cfa:	0c 97       	mov	r7,r6
80008cfc:	04 94       	mov	r4,r2
80008cfe:	06 96       	mov	r6,r3
80008d00:	02 92       	mov	r2,r1
80008d02:	40 93       	lddsp	r3,sp[0x24]
80008d04:	10 90       	mov	r0,r8
80008d06:	40 41       	lddsp	r1,sp[0x10]
80008d08:	ed b5 00 05 	bld	r5,0x5
80008d0c:	c5 61       	brne	80008db8 <_vfprintf_r+0x119c>
80008d0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d12:	40 39       	lddsp	r9,sp[0xc]
80008d14:	58 09       	cp.w	r9,0
80008d16:	c2 10       	breq	80008d58 <_vfprintf_r+0x113c>
80008d18:	10 36       	cp.w	r6,r8
80008d1a:	c0 74       	brge	80008d28 <_vfprintf_r+0x110c>
80008d1c:	fa c8 f9 44 	sub	r8,sp,-1724
80008d20:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008d24:	c2 38       	rjmp	80008d6a <_vfprintf_r+0x114e>
80008d26:	d7 03       	nop
80008d28:	fa c8 f9 50 	sub	r8,sp,-1712
80008d2c:	1a d8       	st.w	--sp,r8
80008d2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d32:	1a d8       	st.w	--sp,r8
80008d34:	fa c8 fb b4 	sub	r8,sp,-1100
80008d38:	1a d8       	st.w	--sp,r8
80008d3a:	fa c8 f9 40 	sub	r8,sp,-1728
80008d3e:	fa c9 ff b4 	sub	r9,sp,-76
80008d42:	04 9a       	mov	r10,r2
80008d44:	0c 9b       	mov	r11,r6
80008d46:	08 9c       	mov	r12,r4
80008d48:	fe b0 f5 d2 	rcall	800078ec <get_arg>
80008d4c:	2f dd       	sub	sp,-12
80008d4e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008d52:	fa e9 00 00 	st.d	sp[0],r8
80008d56:	c2 e8       	rjmp	80008db2 <_vfprintf_r+0x1196>
80008d58:	ee ca ff ff 	sub	r10,r7,-1
80008d5c:	10 37       	cp.w	r7,r8
80008d5e:	c0 b4       	brge	80008d74 <_vfprintf_r+0x1158>
80008d60:	fa c8 f9 44 	sub	r8,sp,-1724
80008d64:	14 97       	mov	r7,r10
80008d66:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008d6a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008d6e:	fa eb 00 00 	st.d	sp[0],r10
80008d72:	c2 08       	rjmp	80008db2 <_vfprintf_r+0x1196>
80008d74:	41 09       	lddsp	r9,sp[0x40]
80008d76:	59 f8       	cp.w	r8,31
80008d78:	e0 89 00 16 	brgt	80008da4 <_vfprintf_r+0x1188>
80008d7c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d80:	f2 cb ff f8 	sub	r11,r9,-8
80008d84:	fa e7 00 00 	st.d	sp[0],r6
80008d88:	51 0b       	stdsp	sp[0x40],r11
80008d8a:	fa c6 f9 44 	sub	r6,sp,-1724
80008d8e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d92:	fa e6 00 00 	ld.d	r6,sp[0]
80008d96:	f2 e7 fd 88 	st.d	r9[-632],r6
80008d9a:	2f f8       	sub	r8,-1
80008d9c:	14 97       	mov	r7,r10
80008d9e:	fb 48 06 b4 	st.w	sp[1716],r8
80008da2:	c0 88       	rjmp	80008db2 <_vfprintf_r+0x1196>
80008da4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008da8:	2f 89       	sub	r9,-8
80008daa:	fa e7 00 00 	st.d	sp[0],r6
80008dae:	51 09       	stdsp	sp[0x40],r9
80008db0:	14 97       	mov	r7,r10
80008db2:	30 18       	mov	r8,1
80008db4:	e0 8f 01 d0 	bral	80009154 <_vfprintf_r+0x1538>
80008db8:	ed b5 00 04 	bld	r5,0x4
80008dbc:	c1 61       	brne	80008de8 <_vfprintf_r+0x11cc>
80008dbe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dc2:	40 3e       	lddsp	lr,sp[0xc]
80008dc4:	58 0e       	cp.w	lr,0
80008dc6:	c0 80       	breq	80008dd6 <_vfprintf_r+0x11ba>
80008dc8:	10 36       	cp.w	r6,r8
80008dca:	c6 74       	brge	80008e98 <_vfprintf_r+0x127c>
80008dcc:	fa cc f9 44 	sub	r12,sp,-1724
80008dd0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008dd4:	c8 08       	rjmp	80008ed4 <_vfprintf_r+0x12b8>
80008dd6:	ee ca ff ff 	sub	r10,r7,-1
80008dda:	10 37       	cp.w	r7,r8
80008ddc:	c7 f4       	brge	80008eda <_vfprintf_r+0x12be>
80008dde:	fa cb f9 44 	sub	r11,sp,-1724
80008de2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008de6:	c7 68       	rjmp	80008ed2 <_vfprintf_r+0x12b6>
80008de8:	ed b5 00 06 	bld	r5,0x6
80008dec:	c4 a1       	brne	80008e80 <_vfprintf_r+0x1264>
80008dee:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008df2:	40 3c       	lddsp	r12,sp[0xc]
80008df4:	58 0c       	cp.w	r12,0
80008df6:	c1 d0       	breq	80008e30 <_vfprintf_r+0x1214>
80008df8:	10 36       	cp.w	r6,r8
80008dfa:	c0 64       	brge	80008e06 <_vfprintf_r+0x11ea>
80008dfc:	fa cb f9 44 	sub	r11,sp,-1724
80008e00:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e04:	c1 f8       	rjmp	80008e42 <_vfprintf_r+0x1226>
80008e06:	fa c8 f9 50 	sub	r8,sp,-1712
80008e0a:	1a d8       	st.w	--sp,r8
80008e0c:	fa c8 fa b8 	sub	r8,sp,-1352
80008e10:	1a d8       	st.w	--sp,r8
80008e12:	fa c8 fb b4 	sub	r8,sp,-1100
80008e16:	1a d8       	st.w	--sp,r8
80008e18:	fa c8 f9 40 	sub	r8,sp,-1728
80008e1c:	fa c9 ff b4 	sub	r9,sp,-76
80008e20:	04 9a       	mov	r10,r2
80008e22:	0c 9b       	mov	r11,r6
80008e24:	08 9c       	mov	r12,r4
80008e26:	fe b0 f5 63 	rcall	800078ec <get_arg>
80008e2a:	2f dd       	sub	sp,-12
80008e2c:	98 18       	ld.sh	r8,r12[0x2]
80008e2e:	c2 68       	rjmp	80008e7a <_vfprintf_r+0x125e>
80008e30:	ee ca ff ff 	sub	r10,r7,-1
80008e34:	10 37       	cp.w	r7,r8
80008e36:	c0 94       	brge	80008e48 <_vfprintf_r+0x122c>
80008e38:	fa c9 f9 44 	sub	r9,sp,-1724
80008e3c:	14 97       	mov	r7,r10
80008e3e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e42:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008e46:	c1 a8       	rjmp	80008e7a <_vfprintf_r+0x125e>
80008e48:	41 09       	lddsp	r9,sp[0x40]
80008e4a:	59 f8       	cp.w	r8,31
80008e4c:	e0 89 00 13 	brgt	80008e72 <_vfprintf_r+0x1256>
80008e50:	f2 cb ff fc 	sub	r11,r9,-4
80008e54:	51 0b       	stdsp	sp[0x40],r11
80008e56:	72 09       	ld.w	r9,r9[0x0]
80008e58:	fa c6 f9 44 	sub	r6,sp,-1724
80008e5c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008e60:	2f f8       	sub	r8,-1
80008e62:	f7 49 fd 88 	st.w	r11[-632],r9
80008e66:	fb 48 06 b4 	st.w	sp[1716],r8
80008e6a:	14 97       	mov	r7,r10
80008e6c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e70:	c0 58       	rjmp	80008e7a <_vfprintf_r+0x125e>
80008e72:	92 18       	ld.sh	r8,r9[0x2]
80008e74:	14 97       	mov	r7,r10
80008e76:	2f c9       	sub	r9,-4
80008e78:	51 09       	stdsp	sp[0x40],r9
80008e7a:	5c 78       	castu.h	r8
80008e7c:	50 18       	stdsp	sp[0x4],r8
80008e7e:	c4 68       	rjmp	80008f0a <_vfprintf_r+0x12ee>
80008e80:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e84:	40 3c       	lddsp	r12,sp[0xc]
80008e86:	58 0c       	cp.w	r12,0
80008e88:	c1 d0       	breq	80008ec2 <_vfprintf_r+0x12a6>
80008e8a:	10 36       	cp.w	r6,r8
80008e8c:	c0 64       	brge	80008e98 <_vfprintf_r+0x127c>
80008e8e:	fa cb f9 44 	sub	r11,sp,-1724
80008e92:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e96:	c1 f8       	rjmp	80008ed4 <_vfprintf_r+0x12b8>
80008e98:	fa c8 f9 50 	sub	r8,sp,-1712
80008e9c:	1a d8       	st.w	--sp,r8
80008e9e:	fa c8 fa b8 	sub	r8,sp,-1352
80008ea2:	0c 9b       	mov	r11,r6
80008ea4:	1a d8       	st.w	--sp,r8
80008ea6:	fa c8 fb b4 	sub	r8,sp,-1100
80008eaa:	04 9a       	mov	r10,r2
80008eac:	1a d8       	st.w	--sp,r8
80008eae:	08 9c       	mov	r12,r4
80008eb0:	fa c8 f9 40 	sub	r8,sp,-1728
80008eb4:	fa c9 ff b4 	sub	r9,sp,-76
80008eb8:	fe b0 f5 1a 	rcall	800078ec <get_arg>
80008ebc:	2f dd       	sub	sp,-12
80008ebe:	78 0b       	ld.w	r11,r12[0x0]
80008ec0:	c2 48       	rjmp	80008f08 <_vfprintf_r+0x12ec>
80008ec2:	ee ca ff ff 	sub	r10,r7,-1
80008ec6:	10 37       	cp.w	r7,r8
80008ec8:	c0 94       	brge	80008eda <_vfprintf_r+0x12be>
80008eca:	fa c9 f9 44 	sub	r9,sp,-1724
80008ece:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ed2:	14 97       	mov	r7,r10
80008ed4:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ed8:	c1 88       	rjmp	80008f08 <_vfprintf_r+0x12ec>
80008eda:	41 09       	lddsp	r9,sp[0x40]
80008edc:	59 f8       	cp.w	r8,31
80008ede:	e0 89 00 11 	brgt	80008f00 <_vfprintf_r+0x12e4>
80008ee2:	f2 cb ff fc 	sub	r11,r9,-4
80008ee6:	51 0b       	stdsp	sp[0x40],r11
80008ee8:	fa c6 f9 44 	sub	r6,sp,-1724
80008eec:	72 0b       	ld.w	r11,r9[0x0]
80008eee:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ef2:	f3 4b fd 88 	st.w	r9[-632],r11
80008ef6:	2f f8       	sub	r8,-1
80008ef8:	14 97       	mov	r7,r10
80008efa:	fb 48 06 b4 	st.w	sp[1716],r8
80008efe:	c0 58       	rjmp	80008f08 <_vfprintf_r+0x12ec>
80008f00:	72 0b       	ld.w	r11,r9[0x0]
80008f02:	14 97       	mov	r7,r10
80008f04:	2f c9       	sub	r9,-4
80008f06:	51 09       	stdsp	sp[0x40],r9
80008f08:	50 1b       	stdsp	sp[0x4],r11
80008f0a:	30 0e       	mov	lr,0
80008f0c:	30 18       	mov	r8,1
80008f0e:	50 0e       	stdsp	sp[0x0],lr
80008f10:	c2 29       	rjmp	80009154 <_vfprintf_r+0x1538>
80008f12:	50 a7       	stdsp	sp[0x28],r7
80008f14:	50 80       	stdsp	sp[0x20],r0
80008f16:	0c 97       	mov	r7,r6
80008f18:	04 94       	mov	r4,r2
80008f1a:	06 96       	mov	r6,r3
80008f1c:	02 92       	mov	r2,r1
80008f1e:	fe cc b6 22 	sub	r12,pc,-18910
80008f22:	40 93       	lddsp	r3,sp[0x24]
80008f24:	10 90       	mov	r0,r8
80008f26:	40 41       	lddsp	r1,sp[0x10]
80008f28:	50 dc       	stdsp	sp[0x34],r12
80008f2a:	ed b5 00 05 	bld	r5,0x5
80008f2e:	c5 51       	brne	80008fd8 <_vfprintf_r+0x13bc>
80008f30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f34:	40 3b       	lddsp	r11,sp[0xc]
80008f36:	58 0b       	cp.w	r11,0
80008f38:	c2 20       	breq	80008f7c <_vfprintf_r+0x1360>
80008f3a:	10 36       	cp.w	r6,r8
80008f3c:	c0 a4       	brge	80008f50 <_vfprintf_r+0x1334>
80008f3e:	fa ca f9 44 	sub	r10,sp,-1724
80008f42:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f46:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008f4a:	fa e9 00 00 	st.d	sp[0],r8
80008f4e:	cf 28       	rjmp	80009132 <_vfprintf_r+0x1516>
80008f50:	fa c8 f9 50 	sub	r8,sp,-1712
80008f54:	1a d8       	st.w	--sp,r8
80008f56:	fa c8 fa b8 	sub	r8,sp,-1352
80008f5a:	04 9a       	mov	r10,r2
80008f5c:	1a d8       	st.w	--sp,r8
80008f5e:	0c 9b       	mov	r11,r6
80008f60:	fa c8 fb b4 	sub	r8,sp,-1100
80008f64:	08 9c       	mov	r12,r4
80008f66:	1a d8       	st.w	--sp,r8
80008f68:	fa c8 f9 40 	sub	r8,sp,-1728
80008f6c:	fa c9 ff b4 	sub	r9,sp,-76
80008f70:	fe b0 f4 be 	rcall	800078ec <get_arg>
80008f74:	2f dd       	sub	sp,-12
80008f76:	f8 ea 00 00 	ld.d	r10,r12[0]
80008f7a:	c0 c8       	rjmp	80008f92 <_vfprintf_r+0x1376>
80008f7c:	ee ca ff ff 	sub	r10,r7,-1
80008f80:	10 37       	cp.w	r7,r8
80008f82:	c0 b4       	brge	80008f98 <_vfprintf_r+0x137c>
80008f84:	fa c9 f9 44 	sub	r9,sp,-1724
80008f88:	14 97       	mov	r7,r10
80008f8a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f8e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f92:	fa eb 00 00 	st.d	sp[0],r10
80008f96:	cc e8       	rjmp	80009132 <_vfprintf_r+0x1516>
80008f98:	41 09       	lddsp	r9,sp[0x40]
80008f9a:	59 f8       	cp.w	r8,31
80008f9c:	e0 89 00 16 	brgt	80008fc8 <_vfprintf_r+0x13ac>
80008fa0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fa4:	f2 cb ff f8 	sub	r11,r9,-8
80008fa8:	fa e7 00 00 	st.d	sp[0],r6
80008fac:	51 0b       	stdsp	sp[0x40],r11
80008fae:	fa c6 f9 44 	sub	r6,sp,-1724
80008fb2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fb6:	fa e6 00 00 	ld.d	r6,sp[0]
80008fba:	f2 e7 fd 88 	st.d	r9[-632],r6
80008fbe:	2f f8       	sub	r8,-1
80008fc0:	14 97       	mov	r7,r10
80008fc2:	fb 48 06 b4 	st.w	sp[1716],r8
80008fc6:	cb 68       	rjmp	80009132 <_vfprintf_r+0x1516>
80008fc8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fcc:	2f 89       	sub	r9,-8
80008fce:	fa e7 00 00 	st.d	sp[0],r6
80008fd2:	51 09       	stdsp	sp[0x40],r9
80008fd4:	14 97       	mov	r7,r10
80008fd6:	ca e8       	rjmp	80009132 <_vfprintf_r+0x1516>
80008fd8:	ed b5 00 04 	bld	r5,0x4
80008fdc:	c1 71       	brne	8000900a <_vfprintf_r+0x13ee>
80008fde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fe2:	40 3e       	lddsp	lr,sp[0xc]
80008fe4:	58 0e       	cp.w	lr,0
80008fe6:	c0 80       	breq	80008ff6 <_vfprintf_r+0x13da>
80008fe8:	10 36       	cp.w	r6,r8
80008fea:	c6 94       	brge	800090bc <_vfprintf_r+0x14a0>
80008fec:	fa cc f9 44 	sub	r12,sp,-1724
80008ff0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ff4:	c8 28       	rjmp	800090f8 <_vfprintf_r+0x14dc>
80008ff6:	ee ca ff ff 	sub	r10,r7,-1
80008ffa:	10 37       	cp.w	r7,r8
80008ffc:	e0 84 00 81 	brge	800090fe <_vfprintf_r+0x14e2>
80009000:	fa cb f9 44 	sub	r11,sp,-1724
80009004:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009008:	c7 78       	rjmp	800090f6 <_vfprintf_r+0x14da>
8000900a:	ed b5 00 06 	bld	r5,0x6
8000900e:	c4 b1       	brne	800090a4 <_vfprintf_r+0x1488>
80009010:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009014:	40 3c       	lddsp	r12,sp[0xc]
80009016:	58 0c       	cp.w	r12,0
80009018:	c1 d0       	breq	80009052 <_vfprintf_r+0x1436>
8000901a:	10 36       	cp.w	r6,r8
8000901c:	c0 64       	brge	80009028 <_vfprintf_r+0x140c>
8000901e:	fa cb f9 44 	sub	r11,sp,-1724
80009022:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009026:	c1 f8       	rjmp	80009064 <_vfprintf_r+0x1448>
80009028:	fa c8 f9 50 	sub	r8,sp,-1712
8000902c:	1a d8       	st.w	--sp,r8
8000902e:	fa c8 fa b8 	sub	r8,sp,-1352
80009032:	1a d8       	st.w	--sp,r8
80009034:	fa c8 fb b4 	sub	r8,sp,-1100
80009038:	1a d8       	st.w	--sp,r8
8000903a:	fa c8 f9 40 	sub	r8,sp,-1728
8000903e:	fa c9 ff b4 	sub	r9,sp,-76
80009042:	04 9a       	mov	r10,r2
80009044:	0c 9b       	mov	r11,r6
80009046:	08 9c       	mov	r12,r4
80009048:	fe b0 f4 52 	rcall	800078ec <get_arg>
8000904c:	2f dd       	sub	sp,-12
8000904e:	98 18       	ld.sh	r8,r12[0x2]
80009050:	c2 78       	rjmp	8000909e <_vfprintf_r+0x1482>
80009052:	ee ca ff ff 	sub	r10,r7,-1
80009056:	10 37       	cp.w	r7,r8
80009058:	c0 a4       	brge	8000906c <_vfprintf_r+0x1450>
8000905a:	fa c9 f9 44 	sub	r9,sp,-1724
8000905e:	14 97       	mov	r7,r10
80009060:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009064:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009068:	c1 b8       	rjmp	8000909e <_vfprintf_r+0x1482>
8000906a:	d7 03       	nop
8000906c:	41 09       	lddsp	r9,sp[0x40]
8000906e:	59 f8       	cp.w	r8,31
80009070:	e0 89 00 13 	brgt	80009096 <_vfprintf_r+0x147a>
80009074:	f2 cb ff fc 	sub	r11,r9,-4
80009078:	51 0b       	stdsp	sp[0x40],r11
8000907a:	72 09       	ld.w	r9,r9[0x0]
8000907c:	fa c6 f9 44 	sub	r6,sp,-1724
80009080:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009084:	2f f8       	sub	r8,-1
80009086:	f7 49 fd 88 	st.w	r11[-632],r9
8000908a:	fb 48 06 b4 	st.w	sp[1716],r8
8000908e:	14 97       	mov	r7,r10
80009090:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009094:	c0 58       	rjmp	8000909e <_vfprintf_r+0x1482>
80009096:	92 18       	ld.sh	r8,r9[0x2]
80009098:	14 97       	mov	r7,r10
8000909a:	2f c9       	sub	r9,-4
8000909c:	51 09       	stdsp	sp[0x40],r9
8000909e:	5c 78       	castu.h	r8
800090a0:	50 18       	stdsp	sp[0x4],r8
800090a2:	c4 68       	rjmp	8000912e <_vfprintf_r+0x1512>
800090a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090a8:	40 3c       	lddsp	r12,sp[0xc]
800090aa:	58 0c       	cp.w	r12,0
800090ac:	c1 d0       	breq	800090e6 <_vfprintf_r+0x14ca>
800090ae:	10 36       	cp.w	r6,r8
800090b0:	c0 64       	brge	800090bc <_vfprintf_r+0x14a0>
800090b2:	fa cb f9 44 	sub	r11,sp,-1724
800090b6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090ba:	c1 f8       	rjmp	800090f8 <_vfprintf_r+0x14dc>
800090bc:	fa c8 f9 50 	sub	r8,sp,-1712
800090c0:	1a d8       	st.w	--sp,r8
800090c2:	fa c8 fa b8 	sub	r8,sp,-1352
800090c6:	0c 9b       	mov	r11,r6
800090c8:	1a d8       	st.w	--sp,r8
800090ca:	fa c8 fb b4 	sub	r8,sp,-1100
800090ce:	04 9a       	mov	r10,r2
800090d0:	1a d8       	st.w	--sp,r8
800090d2:	08 9c       	mov	r12,r4
800090d4:	fa c8 f9 40 	sub	r8,sp,-1728
800090d8:	fa c9 ff b4 	sub	r9,sp,-76
800090dc:	fe b0 f4 08 	rcall	800078ec <get_arg>
800090e0:	2f dd       	sub	sp,-12
800090e2:	78 0b       	ld.w	r11,r12[0x0]
800090e4:	c2 48       	rjmp	8000912c <_vfprintf_r+0x1510>
800090e6:	ee ca ff ff 	sub	r10,r7,-1
800090ea:	10 37       	cp.w	r7,r8
800090ec:	c0 94       	brge	800090fe <_vfprintf_r+0x14e2>
800090ee:	fa c9 f9 44 	sub	r9,sp,-1724
800090f2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090f6:	14 97       	mov	r7,r10
800090f8:	ec fb fd 88 	ld.w	r11,r6[-632]
800090fc:	c1 88       	rjmp	8000912c <_vfprintf_r+0x1510>
800090fe:	41 09       	lddsp	r9,sp[0x40]
80009100:	59 f8       	cp.w	r8,31
80009102:	e0 89 00 11 	brgt	80009124 <_vfprintf_r+0x1508>
80009106:	f2 cb ff fc 	sub	r11,r9,-4
8000910a:	51 0b       	stdsp	sp[0x40],r11
8000910c:	fa c6 f9 44 	sub	r6,sp,-1724
80009110:	72 0b       	ld.w	r11,r9[0x0]
80009112:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009116:	f3 4b fd 88 	st.w	r9[-632],r11
8000911a:	2f f8       	sub	r8,-1
8000911c:	14 97       	mov	r7,r10
8000911e:	fb 48 06 b4 	st.w	sp[1716],r8
80009122:	c0 58       	rjmp	8000912c <_vfprintf_r+0x1510>
80009124:	72 0b       	ld.w	r11,r9[0x0]
80009126:	14 97       	mov	r7,r10
80009128:	2f c9       	sub	r9,-4
8000912a:	51 09       	stdsp	sp[0x40],r9
8000912c:	50 1b       	stdsp	sp[0x4],r11
8000912e:	30 0e       	mov	lr,0
80009130:	50 0e       	stdsp	sp[0x0],lr
80009132:	40 08       	lddsp	r8,sp[0x0]
80009134:	40 1c       	lddsp	r12,sp[0x4]
80009136:	18 48       	or	r8,r12
80009138:	5f 19       	srne	r9
8000913a:	0a 98       	mov	r8,r5
8000913c:	eb e9 00 09 	and	r9,r5,r9
80009140:	a1 b8       	sbr	r8,0x1
80009142:	58 09       	cp.w	r9,0
80009144:	c0 70       	breq	80009152 <_vfprintf_r+0x1536>
80009146:	10 95       	mov	r5,r8
80009148:	fb 60 06 b9 	st.b	sp[1721],r0
8000914c:	33 08       	mov	r8,48
8000914e:	fb 68 06 b8 	st.b	sp[1720],r8
80009152:	30 28       	mov	r8,2
80009154:	30 09       	mov	r9,0
80009156:	fb 69 06 bb 	st.b	sp[1723],r9
8000915a:	0a 99       	mov	r9,r5
8000915c:	a7 d9       	cbr	r9,0x7
8000915e:	40 2b       	lddsp	r11,sp[0x8]
80009160:	40 16       	lddsp	r6,sp[0x4]
80009162:	58 0b       	cp.w	r11,0
80009164:	5f 1a       	srne	r10
80009166:	f2 05 17 40 	movge	r5,r9
8000916a:	fa c2 f9 78 	sub	r2,sp,-1672
8000916e:	40 09       	lddsp	r9,sp[0x0]
80009170:	0c 49       	or	r9,r6
80009172:	5f 19       	srne	r9
80009174:	f5 e9 10 09 	or	r9,r10,r9
80009178:	c5 c0       	breq	80009230 <_vfprintf_r+0x1614>
8000917a:	30 19       	mov	r9,1
8000917c:	f2 08 18 00 	cp.b	r8,r9
80009180:	c0 60       	breq	8000918c <_vfprintf_r+0x1570>
80009182:	30 29       	mov	r9,2
80009184:	f2 08 18 00 	cp.b	r8,r9
80009188:	c0 41       	brne	80009190 <_vfprintf_r+0x1574>
8000918a:	c3 c8       	rjmp	80009202 <_vfprintf_r+0x15e6>
8000918c:	04 96       	mov	r6,r2
8000918e:	c3 08       	rjmp	800091ee <_vfprintf_r+0x15d2>
80009190:	04 96       	mov	r6,r2
80009192:	fa e8 00 00 	ld.d	r8,sp[0]
80009196:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000919a:	2d 0a       	sub	r10,-48
8000919c:	0c fa       	st.b	--r6,r10
8000919e:	f0 0b 16 03 	lsr	r11,r8,0x3
800091a2:	f2 0c 16 03 	lsr	r12,r9,0x3
800091a6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800091aa:	18 99       	mov	r9,r12
800091ac:	16 98       	mov	r8,r11
800091ae:	58 08       	cp.w	r8,0
800091b0:	5c 29       	cpc	r9
800091b2:	cf 21       	brne	80009196 <_vfprintf_r+0x157a>
800091b4:	fa e9 00 00 	st.d	sp[0],r8
800091b8:	ed b5 00 00 	bld	r5,0x0
800091bc:	c4 51       	brne	80009246 <_vfprintf_r+0x162a>
800091be:	33 09       	mov	r9,48
800091c0:	f2 0a 18 00 	cp.b	r10,r9
800091c4:	c4 10       	breq	80009246 <_vfprintf_r+0x162a>
800091c6:	0c f9       	st.b	--r6,r9
800091c8:	c3 f8       	rjmp	80009246 <_vfprintf_r+0x162a>
800091ca:	fa ea 00 00 	ld.d	r10,sp[0]
800091ce:	30 a8       	mov	r8,10
800091d0:	30 09       	mov	r9,0
800091d2:	e0 a0 1a 0d 	rcall	8000c5ec <__avr32_umod64>
800091d6:	30 a8       	mov	r8,10
800091d8:	2d 0a       	sub	r10,-48
800091da:	30 09       	mov	r9,0
800091dc:	ac 8a       	st.b	r6[0x0],r10
800091de:	fa ea 00 00 	ld.d	r10,sp[0]
800091e2:	e0 a0 18 d3 	rcall	8000c388 <__avr32_udiv64>
800091e6:	16 99       	mov	r9,r11
800091e8:	14 98       	mov	r8,r10
800091ea:	fa e9 00 00 	st.d	sp[0],r8
800091ee:	20 16       	sub	r6,1
800091f0:	fa ea 00 00 	ld.d	r10,sp[0]
800091f4:	58 9a       	cp.w	r10,9
800091f6:	5c 2b       	cpc	r11
800091f8:	fe 9b ff e9 	brhi	800091ca <_vfprintf_r+0x15ae>
800091fc:	1b f8       	ld.ub	r8,sp[0x7]
800091fe:	2d 08       	sub	r8,-48
80009200:	c2 08       	rjmp	80009240 <_vfprintf_r+0x1624>
80009202:	04 96       	mov	r6,r2
80009204:	fa e8 00 00 	ld.d	r8,sp[0]
80009208:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000920c:	40 de       	lddsp	lr,sp[0x34]
8000920e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009212:	0c fa       	st.b	--r6,r10
80009214:	f2 0b 16 04 	lsr	r11,r9,0x4
80009218:	f0 0a 16 04 	lsr	r10,r8,0x4
8000921c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009220:	16 99       	mov	r9,r11
80009222:	14 98       	mov	r8,r10
80009224:	58 08       	cp.w	r8,0
80009226:	5c 29       	cpc	r9
80009228:	cf 01       	brne	80009208 <_vfprintf_r+0x15ec>
8000922a:	fa e9 00 00 	st.d	sp[0],r8
8000922e:	c0 c8       	rjmp	80009246 <_vfprintf_r+0x162a>
80009230:	58 08       	cp.w	r8,0
80009232:	c0 91       	brne	80009244 <_vfprintf_r+0x1628>
80009234:	ed b5 00 00 	bld	r5,0x0
80009238:	c0 61       	brne	80009244 <_vfprintf_r+0x1628>
8000923a:	fa c6 f9 79 	sub	r6,sp,-1671
8000923e:	33 08       	mov	r8,48
80009240:	ac 88       	st.b	r6[0x0],r8
80009242:	c0 28       	rjmp	80009246 <_vfprintf_r+0x162a>
80009244:	04 96       	mov	r6,r2
80009246:	0c 12       	sub	r2,r6
80009248:	c1 c8       	rjmp	80009280 <_vfprintf_r+0x1664>
8000924a:	50 a7       	stdsp	sp[0x28],r7
8000924c:	50 80       	stdsp	sp[0x20],r0
8000924e:	40 93       	lddsp	r3,sp[0x24]
80009250:	0c 97       	mov	r7,r6
80009252:	10 90       	mov	r0,r8
80009254:	04 94       	mov	r4,r2
80009256:	40 41       	lddsp	r1,sp[0x10]
80009258:	58 08       	cp.w	r8,0
8000925a:	e0 80 04 4f 	breq	80009af8 <_vfprintf_r+0x1edc>
8000925e:	fb 68 06 60 	st.b	sp[1632],r8
80009262:	30 0c       	mov	r12,0
80009264:	30 08       	mov	r8,0
80009266:	30 12       	mov	r2,1
80009268:	fb 68 06 bb 	st.b	sp[1723],r8
8000926c:	50 2c       	stdsp	sp[0x8],r12
8000926e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009272:	c0 78       	rjmp	80009280 <_vfprintf_r+0x1664>
80009274:	30 0b       	mov	r11,0
80009276:	50 2b       	stdsp	sp[0x8],r11
80009278:	c0 48       	rjmp	80009280 <_vfprintf_r+0x1664>
8000927a:	40 22       	lddsp	r2,sp[0x8]
8000927c:	30 0a       	mov	r10,0
8000927e:	50 2a       	stdsp	sp[0x8],r10
80009280:	40 29       	lddsp	r9,sp[0x8]
80009282:	e4 09 0c 49 	max	r9,r2,r9
80009286:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000928a:	50 39       	stdsp	sp[0xc],r9
8000928c:	0a 9e       	mov	lr,r5
8000928e:	30 09       	mov	r9,0
80009290:	e2 1e 00 02 	andl	lr,0x2,COH
80009294:	f2 08 18 00 	cp.b	r8,r9
80009298:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000929c:	f7 b8 01 ff 	subne	r8,-1
800092a0:	fb f8 1a 03 	st.wne	sp[0xc],r8
800092a4:	0a 9b       	mov	r11,r5
800092a6:	58 0e       	cp.w	lr,0
800092a8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800092ac:	f7 bc 01 fe 	subne	r12,-2
800092b0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800092b4:	e2 1b 00 84 	andl	r11,0x84,COH
800092b8:	50 fe       	stdsp	sp[0x3c],lr
800092ba:	50 9b       	stdsp	sp[0x24],r11
800092bc:	c4 71       	brne	8000934a <_vfprintf_r+0x172e>
800092be:	40 8a       	lddsp	r10,sp[0x20]
800092c0:	40 39       	lddsp	r9,sp[0xc]
800092c2:	12 1a       	sub	r10,r9
800092c4:	50 4a       	stdsp	sp[0x10],r10
800092c6:	58 0a       	cp.w	r10,0
800092c8:	e0 89 00 20 	brgt	80009308 <_vfprintf_r+0x16ec>
800092cc:	c3 f8       	rjmp	8000934a <_vfprintf_r+0x172e>
800092ce:	2f 09       	sub	r9,-16
800092d0:	2f f8       	sub	r8,-1
800092d2:	fe ce b9 be 	sub	lr,pc,-17986
800092d6:	31 0c       	mov	r12,16
800092d8:	fb 49 06 90 	st.w	sp[1680],r9
800092dc:	87 0e       	st.w	r3[0x0],lr
800092de:	87 1c       	st.w	r3[0x4],r12
800092e0:	fb 48 06 8c 	st.w	sp[1676],r8
800092e4:	58 78       	cp.w	r8,7
800092e6:	e0 89 00 04 	brgt	800092ee <_vfprintf_r+0x16d2>
800092ea:	2f 83       	sub	r3,-8
800092ec:	c0 b8       	rjmp	80009302 <_vfprintf_r+0x16e6>
800092ee:	fa ca f9 78 	sub	r10,sp,-1672
800092f2:	02 9b       	mov	r11,r1
800092f4:	08 9c       	mov	r12,r4
800092f6:	fe b0 f4 85 	rcall	80007c00 <__sprint_r>
800092fa:	e0 81 04 10 	brne	80009b1a <_vfprintf_r+0x1efe>
800092fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009302:	40 4b       	lddsp	r11,sp[0x10]
80009304:	21 0b       	sub	r11,16
80009306:	50 4b       	stdsp	sp[0x10],r11
80009308:	fa f9 06 90 	ld.w	r9,sp[1680]
8000930c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009310:	fe ca b9 fc 	sub	r10,pc,-17924
80009314:	40 4e       	lddsp	lr,sp[0x10]
80009316:	59 0e       	cp.w	lr,16
80009318:	fe 99 ff db 	brgt	800092ce <_vfprintf_r+0x16b2>
8000931c:	1c 09       	add	r9,lr
8000931e:	2f f8       	sub	r8,-1
80009320:	87 0a       	st.w	r3[0x0],r10
80009322:	fb 49 06 90 	st.w	sp[1680],r9
80009326:	87 1e       	st.w	r3[0x4],lr
80009328:	fb 48 06 8c 	st.w	sp[1676],r8
8000932c:	58 78       	cp.w	r8,7
8000932e:	e0 89 00 04 	brgt	80009336 <_vfprintf_r+0x171a>
80009332:	2f 83       	sub	r3,-8
80009334:	c0 b8       	rjmp	8000934a <_vfprintf_r+0x172e>
80009336:	fa ca f9 78 	sub	r10,sp,-1672
8000933a:	02 9b       	mov	r11,r1
8000933c:	08 9c       	mov	r12,r4
8000933e:	fe b0 f4 61 	rcall	80007c00 <__sprint_r>
80009342:	e0 81 03 ec 	brne	80009b1a <_vfprintf_r+0x1efe>
80009346:	fa c3 f9 e0 	sub	r3,sp,-1568
8000934a:	30 09       	mov	r9,0
8000934c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009350:	f2 08 18 00 	cp.b	r8,r9
80009354:	c1 f0       	breq	80009392 <_vfprintf_r+0x1776>
80009356:	fa f8 06 90 	ld.w	r8,sp[1680]
8000935a:	fa c9 f9 45 	sub	r9,sp,-1723
8000935e:	2f f8       	sub	r8,-1
80009360:	87 09       	st.w	r3[0x0],r9
80009362:	fb 48 06 90 	st.w	sp[1680],r8
80009366:	30 19       	mov	r9,1
80009368:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000936c:	87 19       	st.w	r3[0x4],r9
8000936e:	2f f8       	sub	r8,-1
80009370:	fb 48 06 8c 	st.w	sp[1676],r8
80009374:	58 78       	cp.w	r8,7
80009376:	e0 89 00 04 	brgt	8000937e <_vfprintf_r+0x1762>
8000937a:	2f 83       	sub	r3,-8
8000937c:	c0 b8       	rjmp	80009392 <_vfprintf_r+0x1776>
8000937e:	fa ca f9 78 	sub	r10,sp,-1672
80009382:	02 9b       	mov	r11,r1
80009384:	08 9c       	mov	r12,r4
80009386:	fe b0 f4 3d 	rcall	80007c00 <__sprint_r>
8000938a:	e0 81 03 c8 	brne	80009b1a <_vfprintf_r+0x1efe>
8000938e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009392:	40 fc       	lddsp	r12,sp[0x3c]
80009394:	58 0c       	cp.w	r12,0
80009396:	c1 f0       	breq	800093d4 <_vfprintf_r+0x17b8>
80009398:	fa f8 06 90 	ld.w	r8,sp[1680]
8000939c:	fa c9 f9 48 	sub	r9,sp,-1720
800093a0:	2f e8       	sub	r8,-2
800093a2:	87 09       	st.w	r3[0x0],r9
800093a4:	fb 48 06 90 	st.w	sp[1680],r8
800093a8:	30 29       	mov	r9,2
800093aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093ae:	87 19       	st.w	r3[0x4],r9
800093b0:	2f f8       	sub	r8,-1
800093b2:	fb 48 06 8c 	st.w	sp[1676],r8
800093b6:	58 78       	cp.w	r8,7
800093b8:	e0 89 00 04 	brgt	800093c0 <_vfprintf_r+0x17a4>
800093bc:	2f 83       	sub	r3,-8
800093be:	c0 b8       	rjmp	800093d4 <_vfprintf_r+0x17b8>
800093c0:	fa ca f9 78 	sub	r10,sp,-1672
800093c4:	02 9b       	mov	r11,r1
800093c6:	08 9c       	mov	r12,r4
800093c8:	fe b0 f4 1c 	rcall	80007c00 <__sprint_r>
800093cc:	e0 81 03 a7 	brne	80009b1a <_vfprintf_r+0x1efe>
800093d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800093d4:	40 9b       	lddsp	r11,sp[0x24]
800093d6:	e0 4b 00 80 	cp.w	r11,128
800093da:	c4 71       	brne	80009468 <_vfprintf_r+0x184c>
800093dc:	40 8a       	lddsp	r10,sp[0x20]
800093de:	40 39       	lddsp	r9,sp[0xc]
800093e0:	12 1a       	sub	r10,r9
800093e2:	50 4a       	stdsp	sp[0x10],r10
800093e4:	58 0a       	cp.w	r10,0
800093e6:	e0 89 00 20 	brgt	80009426 <_vfprintf_r+0x180a>
800093ea:	c3 f8       	rjmp	80009468 <_vfprintf_r+0x184c>
800093ec:	2f 09       	sub	r9,-16
800093ee:	2f f8       	sub	r8,-1
800093f0:	fe ce ba cc 	sub	lr,pc,-17716
800093f4:	31 0c       	mov	r12,16
800093f6:	fb 49 06 90 	st.w	sp[1680],r9
800093fa:	87 0e       	st.w	r3[0x0],lr
800093fc:	87 1c       	st.w	r3[0x4],r12
800093fe:	fb 48 06 8c 	st.w	sp[1676],r8
80009402:	58 78       	cp.w	r8,7
80009404:	e0 89 00 04 	brgt	8000940c <_vfprintf_r+0x17f0>
80009408:	2f 83       	sub	r3,-8
8000940a:	c0 b8       	rjmp	80009420 <_vfprintf_r+0x1804>
8000940c:	fa ca f9 78 	sub	r10,sp,-1672
80009410:	02 9b       	mov	r11,r1
80009412:	08 9c       	mov	r12,r4
80009414:	fe b0 f3 f6 	rcall	80007c00 <__sprint_r>
80009418:	e0 81 03 81 	brne	80009b1a <_vfprintf_r+0x1efe>
8000941c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009420:	40 4b       	lddsp	r11,sp[0x10]
80009422:	21 0b       	sub	r11,16
80009424:	50 4b       	stdsp	sp[0x10],r11
80009426:	fa f9 06 90 	ld.w	r9,sp[1680]
8000942a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000942e:	fe ca bb 0a 	sub	r10,pc,-17654
80009432:	40 4e       	lddsp	lr,sp[0x10]
80009434:	59 0e       	cp.w	lr,16
80009436:	fe 99 ff db 	brgt	800093ec <_vfprintf_r+0x17d0>
8000943a:	1c 09       	add	r9,lr
8000943c:	2f f8       	sub	r8,-1
8000943e:	87 0a       	st.w	r3[0x0],r10
80009440:	fb 49 06 90 	st.w	sp[1680],r9
80009444:	87 1e       	st.w	r3[0x4],lr
80009446:	fb 48 06 8c 	st.w	sp[1676],r8
8000944a:	58 78       	cp.w	r8,7
8000944c:	e0 89 00 04 	brgt	80009454 <_vfprintf_r+0x1838>
80009450:	2f 83       	sub	r3,-8
80009452:	c0 b8       	rjmp	80009468 <_vfprintf_r+0x184c>
80009454:	fa ca f9 78 	sub	r10,sp,-1672
80009458:	02 9b       	mov	r11,r1
8000945a:	08 9c       	mov	r12,r4
8000945c:	fe b0 f3 d2 	rcall	80007c00 <__sprint_r>
80009460:	e0 81 03 5d 	brne	80009b1a <_vfprintf_r+0x1efe>
80009464:	fa c3 f9 e0 	sub	r3,sp,-1568
80009468:	40 2c       	lddsp	r12,sp[0x8]
8000946a:	04 1c       	sub	r12,r2
8000946c:	50 2c       	stdsp	sp[0x8],r12
8000946e:	58 0c       	cp.w	r12,0
80009470:	e0 89 00 20 	brgt	800094b0 <_vfprintf_r+0x1894>
80009474:	c3 f8       	rjmp	800094f2 <_vfprintf_r+0x18d6>
80009476:	2f 09       	sub	r9,-16
80009478:	2f f8       	sub	r8,-1
8000947a:	fe cb bb 56 	sub	r11,pc,-17578
8000947e:	31 0a       	mov	r10,16
80009480:	fb 49 06 90 	st.w	sp[1680],r9
80009484:	87 0b       	st.w	r3[0x0],r11
80009486:	87 1a       	st.w	r3[0x4],r10
80009488:	fb 48 06 8c 	st.w	sp[1676],r8
8000948c:	58 78       	cp.w	r8,7
8000948e:	e0 89 00 04 	brgt	80009496 <_vfprintf_r+0x187a>
80009492:	2f 83       	sub	r3,-8
80009494:	c0 b8       	rjmp	800094aa <_vfprintf_r+0x188e>
80009496:	fa ca f9 78 	sub	r10,sp,-1672
8000949a:	02 9b       	mov	r11,r1
8000949c:	08 9c       	mov	r12,r4
8000949e:	fe b0 f3 b1 	rcall	80007c00 <__sprint_r>
800094a2:	e0 81 03 3c 	brne	80009b1a <_vfprintf_r+0x1efe>
800094a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800094aa:	40 29       	lddsp	r9,sp[0x8]
800094ac:	21 09       	sub	r9,16
800094ae:	50 29       	stdsp	sp[0x8],r9
800094b0:	fa f9 06 90 	ld.w	r9,sp[1680]
800094b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094b8:	fe ca bb 94 	sub	r10,pc,-17516
800094bc:	40 2e       	lddsp	lr,sp[0x8]
800094be:	59 0e       	cp.w	lr,16
800094c0:	fe 99 ff db 	brgt	80009476 <_vfprintf_r+0x185a>
800094c4:	1c 09       	add	r9,lr
800094c6:	2f f8       	sub	r8,-1
800094c8:	87 0a       	st.w	r3[0x0],r10
800094ca:	fb 49 06 90 	st.w	sp[1680],r9
800094ce:	87 1e       	st.w	r3[0x4],lr
800094d0:	fb 48 06 8c 	st.w	sp[1676],r8
800094d4:	58 78       	cp.w	r8,7
800094d6:	e0 89 00 04 	brgt	800094de <_vfprintf_r+0x18c2>
800094da:	2f 83       	sub	r3,-8
800094dc:	c0 b8       	rjmp	800094f2 <_vfprintf_r+0x18d6>
800094de:	fa ca f9 78 	sub	r10,sp,-1672
800094e2:	02 9b       	mov	r11,r1
800094e4:	08 9c       	mov	r12,r4
800094e6:	fe b0 f3 8d 	rcall	80007c00 <__sprint_r>
800094ea:	e0 81 03 18 	brne	80009b1a <_vfprintf_r+0x1efe>
800094ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f2:	ed b5 00 08 	bld	r5,0x8
800094f6:	c0 b0       	breq	8000950c <_vfprintf_r+0x18f0>
800094f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800094fc:	87 12       	st.w	r3[0x4],r2
800094fe:	87 06       	st.w	r3[0x0],r6
80009500:	f0 02 00 02 	add	r2,r8,r2
80009504:	fb 42 06 90 	st.w	sp[1680],r2
80009508:	e0 8f 01 d4 	bral	800098b0 <_vfprintf_r+0x1c94>
8000950c:	e0 40 00 65 	cp.w	r0,101
80009510:	e0 8a 01 d6 	brle	800098bc <_vfprintf_r+0x1ca0>
80009514:	30 08       	mov	r8,0
80009516:	30 09       	mov	r9,0
80009518:	40 5b       	lddsp	r11,sp[0x14]
8000951a:	40 7a       	lddsp	r10,sp[0x1c]
8000951c:	e0 a0 15 2f 	rcall	8000bf7a <__avr32_f64_cmp_eq>
80009520:	c7 90       	breq	80009612 <_vfprintf_r+0x19f6>
80009522:	fa f8 06 90 	ld.w	r8,sp[1680]
80009526:	fe c9 bc 16 	sub	r9,pc,-17386
8000952a:	2f f8       	sub	r8,-1
8000952c:	87 09       	st.w	r3[0x0],r9
8000952e:	fb 48 06 90 	st.w	sp[1680],r8
80009532:	30 19       	mov	r9,1
80009534:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009538:	87 19       	st.w	r3[0x4],r9
8000953a:	2f f8       	sub	r8,-1
8000953c:	fb 48 06 8c 	st.w	sp[1676],r8
80009540:	58 78       	cp.w	r8,7
80009542:	e0 89 00 05 	brgt	8000954c <_vfprintf_r+0x1930>
80009546:	2f 83       	sub	r3,-8
80009548:	c0 c8       	rjmp	80009560 <_vfprintf_r+0x1944>
8000954a:	d7 03       	nop
8000954c:	fa ca f9 78 	sub	r10,sp,-1672
80009550:	02 9b       	mov	r11,r1
80009552:	08 9c       	mov	r12,r4
80009554:	fe b0 f3 56 	rcall	80007c00 <__sprint_r>
80009558:	e0 81 02 e1 	brne	80009b1a <_vfprintf_r+0x1efe>
8000955c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009560:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009564:	40 6c       	lddsp	r12,sp[0x18]
80009566:	18 38       	cp.w	r8,r12
80009568:	c0 55       	brlt	80009572 <_vfprintf_r+0x1956>
8000956a:	ed b5 00 00 	bld	r5,0x0
8000956e:	e0 81 02 6b 	brne	80009a44 <_vfprintf_r+0x1e28>
80009572:	fa f8 06 90 	ld.w	r8,sp[1680]
80009576:	2f f8       	sub	r8,-1
80009578:	40 cb       	lddsp	r11,sp[0x30]
8000957a:	fb 48 06 90 	st.w	sp[1680],r8
8000957e:	30 19       	mov	r9,1
80009580:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009584:	87 0b       	st.w	r3[0x0],r11
80009586:	2f f8       	sub	r8,-1
80009588:	87 19       	st.w	r3[0x4],r9
8000958a:	fb 48 06 8c 	st.w	sp[1676],r8
8000958e:	58 78       	cp.w	r8,7
80009590:	e0 89 00 04 	brgt	80009598 <_vfprintf_r+0x197c>
80009594:	2f 83       	sub	r3,-8
80009596:	c0 b8       	rjmp	800095ac <_vfprintf_r+0x1990>
80009598:	fa ca f9 78 	sub	r10,sp,-1672
8000959c:	02 9b       	mov	r11,r1
8000959e:	08 9c       	mov	r12,r4
800095a0:	fe b0 f3 30 	rcall	80007c00 <__sprint_r>
800095a4:	e0 81 02 bb 	brne	80009b1a <_vfprintf_r+0x1efe>
800095a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ac:	40 66       	lddsp	r6,sp[0x18]
800095ae:	20 16       	sub	r6,1
800095b0:	58 06       	cp.w	r6,0
800095b2:	e0 89 00 1d 	brgt	800095ec <_vfprintf_r+0x19d0>
800095b6:	e0 8f 02 47 	bral	80009a44 <_vfprintf_r+0x1e28>
800095ba:	2f 09       	sub	r9,-16
800095bc:	2f f8       	sub	r8,-1
800095be:	fb 49 06 90 	st.w	sp[1680],r9
800095c2:	87 02       	st.w	r3[0x0],r2
800095c4:	87 10       	st.w	r3[0x4],r0
800095c6:	fb 48 06 8c 	st.w	sp[1676],r8
800095ca:	58 78       	cp.w	r8,7
800095cc:	e0 89 00 04 	brgt	800095d4 <_vfprintf_r+0x19b8>
800095d0:	2f 83       	sub	r3,-8
800095d2:	c0 b8       	rjmp	800095e8 <_vfprintf_r+0x19cc>
800095d4:	fa ca f9 78 	sub	r10,sp,-1672
800095d8:	02 9b       	mov	r11,r1
800095da:	08 9c       	mov	r12,r4
800095dc:	fe b0 f3 12 	rcall	80007c00 <__sprint_r>
800095e0:	e0 81 02 9d 	brne	80009b1a <_vfprintf_r+0x1efe>
800095e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800095e8:	21 06       	sub	r6,16
800095ea:	c0 48       	rjmp	800095f2 <_vfprintf_r+0x19d6>
800095ec:	fe c2 bc c8 	sub	r2,pc,-17208
800095f0:	31 00       	mov	r0,16
800095f2:	fa f9 06 90 	ld.w	r9,sp[1680]
800095f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095fa:	fe ca bc d6 	sub	r10,pc,-17194
800095fe:	59 06       	cp.w	r6,16
80009600:	fe 99 ff dd 	brgt	800095ba <_vfprintf_r+0x199e>
80009604:	0c 09       	add	r9,r6
80009606:	87 0a       	st.w	r3[0x0],r10
80009608:	fb 49 06 90 	st.w	sp[1680],r9
8000960c:	2f f8       	sub	r8,-1
8000960e:	87 16       	st.w	r3[0x4],r6
80009610:	c5 39       	rjmp	800098b6 <_vfprintf_r+0x1c9a>
80009612:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009616:	58 0a       	cp.w	r10,0
80009618:	e0 89 00 92 	brgt	8000973c <_vfprintf_r+0x1b20>
8000961c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009620:	fe c9 bd 10 	sub	r9,pc,-17136
80009624:	2f f8       	sub	r8,-1
80009626:	87 09       	st.w	r3[0x0],r9
80009628:	fb 48 06 90 	st.w	sp[1680],r8
8000962c:	30 19       	mov	r9,1
8000962e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009632:	87 19       	st.w	r3[0x4],r9
80009634:	2f f8       	sub	r8,-1
80009636:	fb 48 06 8c 	st.w	sp[1676],r8
8000963a:	58 78       	cp.w	r8,7
8000963c:	e0 89 00 04 	brgt	80009644 <_vfprintf_r+0x1a28>
80009640:	2f 83       	sub	r3,-8
80009642:	c0 b8       	rjmp	80009658 <_vfprintf_r+0x1a3c>
80009644:	fa ca f9 78 	sub	r10,sp,-1672
80009648:	02 9b       	mov	r11,r1
8000964a:	08 9c       	mov	r12,r4
8000964c:	fe b0 f2 da 	rcall	80007c00 <__sprint_r>
80009650:	e0 81 02 65 	brne	80009b1a <_vfprintf_r+0x1efe>
80009654:	fa c3 f9 e0 	sub	r3,sp,-1568
80009658:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000965c:	58 08       	cp.w	r8,0
8000965e:	c0 81       	brne	8000966e <_vfprintf_r+0x1a52>
80009660:	40 6a       	lddsp	r10,sp[0x18]
80009662:	58 0a       	cp.w	r10,0
80009664:	c0 51       	brne	8000966e <_vfprintf_r+0x1a52>
80009666:	ed b5 00 00 	bld	r5,0x0
8000966a:	e0 81 01 ed 	brne	80009a44 <_vfprintf_r+0x1e28>
8000966e:	40 c9       	lddsp	r9,sp[0x30]
80009670:	fa f8 06 90 	ld.w	r8,sp[1680]
80009674:	2f f8       	sub	r8,-1
80009676:	87 09       	st.w	r3[0x0],r9
80009678:	fb 48 06 90 	st.w	sp[1680],r8
8000967c:	30 19       	mov	r9,1
8000967e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009682:	87 19       	st.w	r3[0x4],r9
80009684:	2f f8       	sub	r8,-1
80009686:	fb 48 06 8c 	st.w	sp[1676],r8
8000968a:	58 78       	cp.w	r8,7
8000968c:	e0 89 00 04 	brgt	80009694 <_vfprintf_r+0x1a78>
80009690:	2f 83       	sub	r3,-8
80009692:	c0 b8       	rjmp	800096a8 <_vfprintf_r+0x1a8c>
80009694:	fa ca f9 78 	sub	r10,sp,-1672
80009698:	02 9b       	mov	r11,r1
8000969a:	08 9c       	mov	r12,r4
8000969c:	fe b0 f2 b2 	rcall	80007c00 <__sprint_r>
800096a0:	e0 81 02 3d 	brne	80009b1a <_vfprintf_r+0x1efe>
800096a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800096a8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800096ac:	5c 32       	neg	r2
800096ae:	58 02       	cp.w	r2,0
800096b0:	e0 89 00 1d 	brgt	800096ea <_vfprintf_r+0x1ace>
800096b4:	c3 d8       	rjmp	8000972e <_vfprintf_r+0x1b12>
800096b6:	2f 09       	sub	r9,-16
800096b8:	2f f8       	sub	r8,-1
800096ba:	31 0e       	mov	lr,16
800096bc:	fb 49 06 90 	st.w	sp[1680],r9
800096c0:	87 00       	st.w	r3[0x0],r0
800096c2:	87 1e       	st.w	r3[0x4],lr
800096c4:	fb 48 06 8c 	st.w	sp[1676],r8
800096c8:	58 78       	cp.w	r8,7
800096ca:	e0 89 00 04 	brgt	800096d2 <_vfprintf_r+0x1ab6>
800096ce:	2f 83       	sub	r3,-8
800096d0:	c0 b8       	rjmp	800096e6 <_vfprintf_r+0x1aca>
800096d2:	fa ca f9 78 	sub	r10,sp,-1672
800096d6:	02 9b       	mov	r11,r1
800096d8:	08 9c       	mov	r12,r4
800096da:	fe b0 f2 93 	rcall	80007c00 <__sprint_r>
800096de:	e0 81 02 1e 	brne	80009b1a <_vfprintf_r+0x1efe>
800096e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800096e6:	21 02       	sub	r2,16
800096e8:	c0 38       	rjmp	800096ee <_vfprintf_r+0x1ad2>
800096ea:	fe c0 bd c6 	sub	r0,pc,-16954
800096ee:	fa f9 06 90 	ld.w	r9,sp[1680]
800096f2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096f6:	fe ca bd d2 	sub	r10,pc,-16942
800096fa:	59 02       	cp.w	r2,16
800096fc:	fe 99 ff dd 	brgt	800096b6 <_vfprintf_r+0x1a9a>
80009700:	04 09       	add	r9,r2
80009702:	2f f8       	sub	r8,-1
80009704:	87 0a       	st.w	r3[0x0],r10
80009706:	fb 49 06 90 	st.w	sp[1680],r9
8000970a:	87 12       	st.w	r3[0x4],r2
8000970c:	fb 48 06 8c 	st.w	sp[1676],r8
80009710:	58 78       	cp.w	r8,7
80009712:	e0 89 00 04 	brgt	8000971a <_vfprintf_r+0x1afe>
80009716:	2f 83       	sub	r3,-8
80009718:	c0 b8       	rjmp	8000972e <_vfprintf_r+0x1b12>
8000971a:	fa ca f9 78 	sub	r10,sp,-1672
8000971e:	02 9b       	mov	r11,r1
80009720:	08 9c       	mov	r12,r4
80009722:	fe b0 f2 6f 	rcall	80007c00 <__sprint_r>
80009726:	e0 81 01 fa 	brne	80009b1a <_vfprintf_r+0x1efe>
8000972a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000972e:	40 6c       	lddsp	r12,sp[0x18]
80009730:	fa f8 06 90 	ld.w	r8,sp[1680]
80009734:	87 06       	st.w	r3[0x0],r6
80009736:	87 1c       	st.w	r3[0x4],r12
80009738:	18 08       	add	r8,r12
8000973a:	cb 98       	rjmp	800098ac <_vfprintf_r+0x1c90>
8000973c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009740:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009744:	40 6b       	lddsp	r11,sp[0x18]
80009746:	16 3a       	cp.w	r10,r11
80009748:	c6 f5       	brlt	80009826 <_vfprintf_r+0x1c0a>
8000974a:	16 09       	add	r9,r11
8000974c:	2f f8       	sub	r8,-1
8000974e:	87 06       	st.w	r3[0x0],r6
80009750:	fb 49 06 90 	st.w	sp[1680],r9
80009754:	87 1b       	st.w	r3[0x4],r11
80009756:	fb 48 06 8c 	st.w	sp[1676],r8
8000975a:	58 78       	cp.w	r8,7
8000975c:	e0 89 00 04 	brgt	80009764 <_vfprintf_r+0x1b48>
80009760:	2f 83       	sub	r3,-8
80009762:	c0 b8       	rjmp	80009778 <_vfprintf_r+0x1b5c>
80009764:	fa ca f9 78 	sub	r10,sp,-1672
80009768:	02 9b       	mov	r11,r1
8000976a:	08 9c       	mov	r12,r4
8000976c:	fe b0 f2 4a 	rcall	80007c00 <__sprint_r>
80009770:	e0 81 01 d5 	brne	80009b1a <_vfprintf_r+0x1efe>
80009774:	fa c3 f9 e0 	sub	r3,sp,-1568
80009778:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000977c:	40 6a       	lddsp	r10,sp[0x18]
8000977e:	14 16       	sub	r6,r10
80009780:	58 06       	cp.w	r6,0
80009782:	e0 89 00 1c 	brgt	800097ba <_vfprintf_r+0x1b9e>
80009786:	c3 d8       	rjmp	80009800 <_vfprintf_r+0x1be4>
80009788:	2f 09       	sub	r9,-16
8000978a:	2f f8       	sub	r8,-1
8000978c:	fb 49 06 90 	st.w	sp[1680],r9
80009790:	87 02       	st.w	r3[0x0],r2
80009792:	87 10       	st.w	r3[0x4],r0
80009794:	fb 48 06 8c 	st.w	sp[1676],r8
80009798:	58 78       	cp.w	r8,7
8000979a:	e0 89 00 04 	brgt	800097a2 <_vfprintf_r+0x1b86>
8000979e:	2f 83       	sub	r3,-8
800097a0:	c0 b8       	rjmp	800097b6 <_vfprintf_r+0x1b9a>
800097a2:	fa ca f9 78 	sub	r10,sp,-1672
800097a6:	02 9b       	mov	r11,r1
800097a8:	08 9c       	mov	r12,r4
800097aa:	fe b0 f2 2b 	rcall	80007c00 <__sprint_r>
800097ae:	e0 81 01 b6 	brne	80009b1a <_vfprintf_r+0x1efe>
800097b2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097b6:	21 06       	sub	r6,16
800097b8:	c0 48       	rjmp	800097c0 <_vfprintf_r+0x1ba4>
800097ba:	fe c2 be 96 	sub	r2,pc,-16746
800097be:	31 00       	mov	r0,16
800097c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800097c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097c8:	fe ca be a4 	sub	r10,pc,-16732
800097cc:	59 06       	cp.w	r6,16
800097ce:	fe 99 ff dd 	brgt	80009788 <_vfprintf_r+0x1b6c>
800097d2:	0c 09       	add	r9,r6
800097d4:	2f f8       	sub	r8,-1
800097d6:	87 0a       	st.w	r3[0x0],r10
800097d8:	fb 49 06 90 	st.w	sp[1680],r9
800097dc:	87 16       	st.w	r3[0x4],r6
800097de:	fb 48 06 8c 	st.w	sp[1676],r8
800097e2:	58 78       	cp.w	r8,7
800097e4:	e0 89 00 04 	brgt	800097ec <_vfprintf_r+0x1bd0>
800097e8:	2f 83       	sub	r3,-8
800097ea:	c0 b8       	rjmp	80009800 <_vfprintf_r+0x1be4>
800097ec:	fa ca f9 78 	sub	r10,sp,-1672
800097f0:	02 9b       	mov	r11,r1
800097f2:	08 9c       	mov	r12,r4
800097f4:	fe b0 f2 06 	rcall	80007c00 <__sprint_r>
800097f8:	e0 81 01 91 	brne	80009b1a <_vfprintf_r+0x1efe>
800097fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009800:	ed b5 00 00 	bld	r5,0x0
80009804:	e0 81 01 20 	brne	80009a44 <_vfprintf_r+0x1e28>
80009808:	40 c9       	lddsp	r9,sp[0x30]
8000980a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000980e:	2f f8       	sub	r8,-1
80009810:	87 09       	st.w	r3[0x0],r9
80009812:	fb 48 06 90 	st.w	sp[1680],r8
80009816:	30 19       	mov	r9,1
80009818:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000981c:	87 19       	st.w	r3[0x4],r9
8000981e:	2f f8       	sub	r8,-1
80009820:	fb 48 06 8c 	st.w	sp[1676],r8
80009824:	c0 29       	rjmp	80009a28 <_vfprintf_r+0x1e0c>
80009826:	14 09       	add	r9,r10
80009828:	2f f8       	sub	r8,-1
8000982a:	fb 49 06 90 	st.w	sp[1680],r9
8000982e:	87 06       	st.w	r3[0x0],r6
80009830:	87 1a       	st.w	r3[0x4],r10
80009832:	fb 48 06 8c 	st.w	sp[1676],r8
80009836:	58 78       	cp.w	r8,7
80009838:	e0 89 00 04 	brgt	80009840 <_vfprintf_r+0x1c24>
8000983c:	2f 83       	sub	r3,-8
8000983e:	c0 b8       	rjmp	80009854 <_vfprintf_r+0x1c38>
80009840:	fa ca f9 78 	sub	r10,sp,-1672
80009844:	02 9b       	mov	r11,r1
80009846:	08 9c       	mov	r12,r4
80009848:	fe b0 f1 dc 	rcall	80007c00 <__sprint_r>
8000984c:	e0 81 01 67 	brne	80009b1a <_vfprintf_r+0x1efe>
80009850:	fa c3 f9 e0 	sub	r3,sp,-1568
80009854:	40 c8       	lddsp	r8,sp[0x30]
80009856:	87 08       	st.w	r3[0x0],r8
80009858:	fa f8 06 90 	ld.w	r8,sp[1680]
8000985c:	2f f8       	sub	r8,-1
8000985e:	30 19       	mov	r9,1
80009860:	fb 48 06 90 	st.w	sp[1680],r8
80009864:	87 19       	st.w	r3[0x4],r9
80009866:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000986a:	2f f8       	sub	r8,-1
8000986c:	fb 48 06 8c 	st.w	sp[1676],r8
80009870:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009874:	58 78       	cp.w	r8,7
80009876:	e0 89 00 04 	brgt	8000987e <_vfprintf_r+0x1c62>
8000987a:	2f 83       	sub	r3,-8
8000987c:	c0 b8       	rjmp	80009892 <_vfprintf_r+0x1c76>
8000987e:	fa ca f9 78 	sub	r10,sp,-1672
80009882:	02 9b       	mov	r11,r1
80009884:	08 9c       	mov	r12,r4
80009886:	fe b0 f1 bd 	rcall	80007c00 <__sprint_r>
8000988a:	e0 81 01 48 	brne	80009b1a <_vfprintf_r+0x1efe>
8000988e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009892:	04 06       	add	r6,r2
80009894:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009898:	87 06       	st.w	r3[0x0],r6
8000989a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000989e:	40 66       	lddsp	r6,sp[0x18]
800098a0:	40 6e       	lddsp	lr,sp[0x18]
800098a2:	10 16       	sub	r6,r8
800098a4:	f2 08 01 08 	sub	r8,r9,r8
800098a8:	87 16       	st.w	r3[0x4],r6
800098aa:	1c 08       	add	r8,lr
800098ac:	fb 48 06 90 	st.w	sp[1680],r8
800098b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098b4:	2f f8       	sub	r8,-1
800098b6:	fb 48 06 8c 	st.w	sp[1676],r8
800098ba:	cb 78       	rjmp	80009a28 <_vfprintf_r+0x1e0c>
800098bc:	40 6c       	lddsp	r12,sp[0x18]
800098be:	58 1c       	cp.w	r12,1
800098c0:	e0 89 00 06 	brgt	800098cc <_vfprintf_r+0x1cb0>
800098c4:	ed b5 00 00 	bld	r5,0x0
800098c8:	e0 81 00 85 	brne	800099d2 <_vfprintf_r+0x1db6>
800098cc:	fa f8 06 90 	ld.w	r8,sp[1680]
800098d0:	2f f8       	sub	r8,-1
800098d2:	30 19       	mov	r9,1
800098d4:	fb 48 06 90 	st.w	sp[1680],r8
800098d8:	87 06       	st.w	r3[0x0],r6
800098da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098de:	87 19       	st.w	r3[0x4],r9
800098e0:	2f f8       	sub	r8,-1
800098e2:	fb 48 06 8c 	st.w	sp[1676],r8
800098e6:	58 78       	cp.w	r8,7
800098e8:	e0 89 00 04 	brgt	800098f0 <_vfprintf_r+0x1cd4>
800098ec:	2f 83       	sub	r3,-8
800098ee:	c0 b8       	rjmp	80009904 <_vfprintf_r+0x1ce8>
800098f0:	fa ca f9 78 	sub	r10,sp,-1672
800098f4:	02 9b       	mov	r11,r1
800098f6:	08 9c       	mov	r12,r4
800098f8:	fe b0 f1 84 	rcall	80007c00 <__sprint_r>
800098fc:	e0 81 01 0f 	brne	80009b1a <_vfprintf_r+0x1efe>
80009900:	fa c3 f9 e0 	sub	r3,sp,-1568
80009904:	fa f8 06 90 	ld.w	r8,sp[1680]
80009908:	2f f8       	sub	r8,-1
8000990a:	40 cb       	lddsp	r11,sp[0x30]
8000990c:	fb 48 06 90 	st.w	sp[1680],r8
80009910:	30 19       	mov	r9,1
80009912:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009916:	87 0b       	st.w	r3[0x0],r11
80009918:	2f f8       	sub	r8,-1
8000991a:	87 19       	st.w	r3[0x4],r9
8000991c:	fb 48 06 8c 	st.w	sp[1676],r8
80009920:	58 78       	cp.w	r8,7
80009922:	e0 89 00 05 	brgt	8000992c <_vfprintf_r+0x1d10>
80009926:	2f 83       	sub	r3,-8
80009928:	c0 c8       	rjmp	80009940 <_vfprintf_r+0x1d24>
8000992a:	d7 03       	nop
8000992c:	fa ca f9 78 	sub	r10,sp,-1672
80009930:	02 9b       	mov	r11,r1
80009932:	08 9c       	mov	r12,r4
80009934:	fe b0 f1 66 	rcall	80007c00 <__sprint_r>
80009938:	e0 81 00 f1 	brne	80009b1a <_vfprintf_r+0x1efe>
8000993c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009940:	30 08       	mov	r8,0
80009942:	30 09       	mov	r9,0
80009944:	40 5b       	lddsp	r11,sp[0x14]
80009946:	40 7a       	lddsp	r10,sp[0x1c]
80009948:	e0 a0 13 19 	rcall	8000bf7a <__avr32_f64_cmp_eq>
8000994c:	40 68       	lddsp	r8,sp[0x18]
8000994e:	20 18       	sub	r8,1
80009950:	58 0c       	cp.w	r12,0
80009952:	c0 d1       	brne	8000996c <_vfprintf_r+0x1d50>
80009954:	2f f6       	sub	r6,-1
80009956:	87 18       	st.w	r3[0x4],r8
80009958:	87 06       	st.w	r3[0x0],r6
8000995a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000995e:	10 06       	add	r6,r8
80009960:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009964:	fb 46 06 90 	st.w	sp[1680],r6
80009968:	2f f8       	sub	r8,-1
8000996a:	c3 18       	rjmp	800099cc <_vfprintf_r+0x1db0>
8000996c:	10 96       	mov	r6,r8
8000996e:	58 08       	cp.w	r8,0
80009970:	e0 89 00 1c 	brgt	800099a8 <_vfprintf_r+0x1d8c>
80009974:	c4 b8       	rjmp	80009a0a <_vfprintf_r+0x1dee>
80009976:	2f 09       	sub	r9,-16
80009978:	2f f8       	sub	r8,-1
8000997a:	fb 49 06 90 	st.w	sp[1680],r9
8000997e:	87 02       	st.w	r3[0x0],r2
80009980:	87 10       	st.w	r3[0x4],r0
80009982:	fb 48 06 8c 	st.w	sp[1676],r8
80009986:	58 78       	cp.w	r8,7
80009988:	e0 89 00 04 	brgt	80009990 <_vfprintf_r+0x1d74>
8000998c:	2f 83       	sub	r3,-8
8000998e:	c0 b8       	rjmp	800099a4 <_vfprintf_r+0x1d88>
80009990:	fa ca f9 78 	sub	r10,sp,-1672
80009994:	02 9b       	mov	r11,r1
80009996:	08 9c       	mov	r12,r4
80009998:	fe b0 f1 34 	rcall	80007c00 <__sprint_r>
8000999c:	e0 81 00 bf 	brne	80009b1a <_vfprintf_r+0x1efe>
800099a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099a4:	21 06       	sub	r6,16
800099a6:	c0 48       	rjmp	800099ae <_vfprintf_r+0x1d92>
800099a8:	fe c2 c0 84 	sub	r2,pc,-16252
800099ac:	31 00       	mov	r0,16
800099ae:	fa f9 06 90 	ld.w	r9,sp[1680]
800099b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099b6:	fe ca c0 92 	sub	r10,pc,-16238
800099ba:	59 06       	cp.w	r6,16
800099bc:	fe 99 ff dd 	brgt	80009976 <_vfprintf_r+0x1d5a>
800099c0:	0c 09       	add	r9,r6
800099c2:	87 0a       	st.w	r3[0x0],r10
800099c4:	fb 49 06 90 	st.w	sp[1680],r9
800099c8:	2f f8       	sub	r8,-1
800099ca:	87 16       	st.w	r3[0x4],r6
800099cc:	fb 48 06 8c 	st.w	sp[1676],r8
800099d0:	c0 e8       	rjmp	800099ec <_vfprintf_r+0x1dd0>
800099d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800099d6:	2f f8       	sub	r8,-1
800099d8:	30 19       	mov	r9,1
800099da:	fb 48 06 90 	st.w	sp[1680],r8
800099de:	87 06       	st.w	r3[0x0],r6
800099e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099e4:	87 19       	st.w	r3[0x4],r9
800099e6:	2f f8       	sub	r8,-1
800099e8:	fb 48 06 8c 	st.w	sp[1676],r8
800099ec:	58 78       	cp.w	r8,7
800099ee:	e0 89 00 04 	brgt	800099f6 <_vfprintf_r+0x1dda>
800099f2:	2f 83       	sub	r3,-8
800099f4:	c0 b8       	rjmp	80009a0a <_vfprintf_r+0x1dee>
800099f6:	fa ca f9 78 	sub	r10,sp,-1672
800099fa:	02 9b       	mov	r11,r1
800099fc:	08 9c       	mov	r12,r4
800099fe:	fe b0 f1 01 	rcall	80007c00 <__sprint_r>
80009a02:	e0 81 00 8c 	brne	80009b1a <_vfprintf_r+0x1efe>
80009a06:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a0a:	40 ea       	lddsp	r10,sp[0x38]
80009a0c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a10:	14 08       	add	r8,r10
80009a12:	fa c9 f9 64 	sub	r9,sp,-1692
80009a16:	fb 48 06 90 	st.w	sp[1680],r8
80009a1a:	87 1a       	st.w	r3[0x4],r10
80009a1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a20:	87 09       	st.w	r3[0x0],r9
80009a22:	2f f8       	sub	r8,-1
80009a24:	fb 48 06 8c 	st.w	sp[1676],r8
80009a28:	58 78       	cp.w	r8,7
80009a2a:	e0 89 00 04 	brgt	80009a32 <_vfprintf_r+0x1e16>
80009a2e:	2f 83       	sub	r3,-8
80009a30:	c0 a8       	rjmp	80009a44 <_vfprintf_r+0x1e28>
80009a32:	fa ca f9 78 	sub	r10,sp,-1672
80009a36:	02 9b       	mov	r11,r1
80009a38:	08 9c       	mov	r12,r4
80009a3a:	fe b0 f0 e3 	rcall	80007c00 <__sprint_r>
80009a3e:	c6 e1       	brne	80009b1a <_vfprintf_r+0x1efe>
80009a40:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a44:	e2 15 00 04 	andl	r5,0x4,COH
80009a48:	c3 f0       	breq	80009ac6 <_vfprintf_r+0x1eaa>
80009a4a:	40 86       	lddsp	r6,sp[0x20]
80009a4c:	40 39       	lddsp	r9,sp[0xc]
80009a4e:	12 16       	sub	r6,r9
80009a50:	58 06       	cp.w	r6,0
80009a52:	e0 89 00 1a 	brgt	80009a86 <_vfprintf_r+0x1e6a>
80009a56:	c3 88       	rjmp	80009ac6 <_vfprintf_r+0x1eaa>
80009a58:	2f 09       	sub	r9,-16
80009a5a:	2f f8       	sub	r8,-1
80009a5c:	fb 49 06 90 	st.w	sp[1680],r9
80009a60:	87 05       	st.w	r3[0x0],r5
80009a62:	87 12       	st.w	r3[0x4],r2
80009a64:	fb 48 06 8c 	st.w	sp[1676],r8
80009a68:	58 78       	cp.w	r8,7
80009a6a:	e0 89 00 04 	brgt	80009a72 <_vfprintf_r+0x1e56>
80009a6e:	2f 83       	sub	r3,-8
80009a70:	c0 98       	rjmp	80009a82 <_vfprintf_r+0x1e66>
80009a72:	00 9a       	mov	r10,r0
80009a74:	02 9b       	mov	r11,r1
80009a76:	08 9c       	mov	r12,r4
80009a78:	fe b0 f0 c4 	rcall	80007c00 <__sprint_r>
80009a7c:	c4 f1       	brne	80009b1a <_vfprintf_r+0x1efe>
80009a7e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a82:	21 06       	sub	r6,16
80009a84:	c0 68       	rjmp	80009a90 <_vfprintf_r+0x1e74>
80009a86:	fe c5 c1 72 	sub	r5,pc,-16014
80009a8a:	31 02       	mov	r2,16
80009a8c:	fa c0 f9 78 	sub	r0,sp,-1672
80009a90:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a98:	fe ca c1 84 	sub	r10,pc,-15996
80009a9c:	59 06       	cp.w	r6,16
80009a9e:	fe 99 ff dd 	brgt	80009a58 <_vfprintf_r+0x1e3c>
80009aa2:	0c 09       	add	r9,r6
80009aa4:	2f f8       	sub	r8,-1
80009aa6:	87 0a       	st.w	r3[0x0],r10
80009aa8:	87 16       	st.w	r3[0x4],r6
80009aaa:	fb 49 06 90 	st.w	sp[1680],r9
80009aae:	fb 48 06 8c 	st.w	sp[1676],r8
80009ab2:	58 78       	cp.w	r8,7
80009ab4:	e0 8a 00 09 	brle	80009ac6 <_vfprintf_r+0x1eaa>
80009ab8:	fa ca f9 78 	sub	r10,sp,-1672
80009abc:	02 9b       	mov	r11,r1
80009abe:	08 9c       	mov	r12,r4
80009ac0:	fe b0 f0 a0 	rcall	80007c00 <__sprint_r>
80009ac4:	c2 b1       	brne	80009b1a <_vfprintf_r+0x1efe>
80009ac6:	40 bc       	lddsp	r12,sp[0x2c]
80009ac8:	40 36       	lddsp	r6,sp[0xc]
80009aca:	40 8e       	lddsp	lr,sp[0x20]
80009acc:	ec 0e 0c 48 	max	r8,r6,lr
80009ad0:	10 0c       	add	r12,r8
80009ad2:	50 bc       	stdsp	sp[0x2c],r12
80009ad4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ad8:	58 08       	cp.w	r8,0
80009ada:	c0 80       	breq	80009aea <_vfprintf_r+0x1ece>
80009adc:	fa ca f9 78 	sub	r10,sp,-1672
80009ae0:	02 9b       	mov	r11,r1
80009ae2:	08 9c       	mov	r12,r4
80009ae4:	fe b0 f0 8e 	rcall	80007c00 <__sprint_r>
80009ae8:	c1 91       	brne	80009b1a <_vfprintf_r+0x1efe>
80009aea:	30 0b       	mov	r11,0
80009aec:	fa c3 f9 e0 	sub	r3,sp,-1568
80009af0:	fb 4b 06 8c 	st.w	sp[1676],r11
80009af4:	fe 9f f1 22 	bral	80007d38 <_vfprintf_r+0x11c>
80009af8:	08 95       	mov	r5,r4
80009afa:	fa f8 06 90 	ld.w	r8,sp[1680]
80009afe:	58 08       	cp.w	r8,0
80009b00:	c0 80       	breq	80009b10 <_vfprintf_r+0x1ef4>
80009b02:	08 9c       	mov	r12,r4
80009b04:	fa ca f9 78 	sub	r10,sp,-1672
80009b08:	02 9b       	mov	r11,r1
80009b0a:	fe b0 f0 7b 	rcall	80007c00 <__sprint_r>
80009b0e:	c0 61       	brne	80009b1a <_vfprintf_r+0x1efe>
80009b10:	30 08       	mov	r8,0
80009b12:	fb 48 06 8c 	st.w	sp[1676],r8
80009b16:	c0 28       	rjmp	80009b1a <_vfprintf_r+0x1efe>
80009b18:	40 41       	lddsp	r1,sp[0x10]
80009b1a:	82 68       	ld.sh	r8,r1[0xc]
80009b1c:	ed b8 00 06 	bld	r8,0x6
80009b20:	c0 31       	brne	80009b26 <_vfprintf_r+0x1f0a>
80009b22:	3f fa       	mov	r10,-1
80009b24:	50 ba       	stdsp	sp[0x2c],r10
80009b26:	40 bc       	lddsp	r12,sp[0x2c]
80009b28:	fe 3d f9 44 	sub	sp,-1724
80009b2c:	d8 32       	popm	r0-r7,pc
80009b2e:	d7 03       	nop

80009b30 <__swsetup_r>:
80009b30:	d4 21       	pushm	r4-r7,lr
80009b32:	e0 68 0a 3c 	mov	r8,2620
80009b36:	18 96       	mov	r6,r12
80009b38:	16 97       	mov	r7,r11
80009b3a:	70 0c       	ld.w	r12,r8[0x0]
80009b3c:	58 0c       	cp.w	r12,0
80009b3e:	c0 60       	breq	80009b4a <__swsetup_r+0x1a>
80009b40:	78 68       	ld.w	r8,r12[0x18]
80009b42:	58 08       	cp.w	r8,0
80009b44:	c0 31       	brne	80009b4a <__swsetup_r+0x1a>
80009b46:	e0 a0 07 bf 	rcall	8000aac4 <__sinit>
80009b4a:	fe c8 c1 06 	sub	r8,pc,-16122
80009b4e:	10 37       	cp.w	r7,r8
80009b50:	c0 61       	brne	80009b5c <__swsetup_r+0x2c>
80009b52:	e0 68 0a 3c 	mov	r8,2620
80009b56:	70 08       	ld.w	r8,r8[0x0]
80009b58:	70 07       	ld.w	r7,r8[0x0]
80009b5a:	c1 28       	rjmp	80009b7e <__swsetup_r+0x4e>
80009b5c:	fe c8 c0 f8 	sub	r8,pc,-16136
80009b60:	10 37       	cp.w	r7,r8
80009b62:	c0 61       	brne	80009b6e <__swsetup_r+0x3e>
80009b64:	e0 68 0a 3c 	mov	r8,2620
80009b68:	70 08       	ld.w	r8,r8[0x0]
80009b6a:	70 17       	ld.w	r7,r8[0x4]
80009b6c:	c0 98       	rjmp	80009b7e <__swsetup_r+0x4e>
80009b6e:	fe c8 c0 ea 	sub	r8,pc,-16150
80009b72:	10 37       	cp.w	r7,r8
80009b74:	c0 51       	brne	80009b7e <__swsetup_r+0x4e>
80009b76:	e0 68 0a 3c 	mov	r8,2620
80009b7a:	70 08       	ld.w	r8,r8[0x0]
80009b7c:	70 27       	ld.w	r7,r8[0x8]
80009b7e:	8e 68       	ld.sh	r8,r7[0xc]
80009b80:	ed b8 00 03 	bld	r8,0x3
80009b84:	c1 e0       	breq	80009bc0 <__swsetup_r+0x90>
80009b86:	ed b8 00 04 	bld	r8,0x4
80009b8a:	c3 e1       	brne	80009c06 <__swsetup_r+0xd6>
80009b8c:	ed b8 00 02 	bld	r8,0x2
80009b90:	c1 51       	brne	80009bba <__swsetup_r+0x8a>
80009b92:	6e db       	ld.w	r11,r7[0x34]
80009b94:	58 0b       	cp.w	r11,0
80009b96:	c0 a0       	breq	80009baa <__swsetup_r+0x7a>
80009b98:	ee c8 ff bc 	sub	r8,r7,-68
80009b9c:	10 3b       	cp.w	r11,r8
80009b9e:	c0 40       	breq	80009ba6 <__swsetup_r+0x76>
80009ba0:	0c 9c       	mov	r12,r6
80009ba2:	e0 a0 08 2b 	rcall	8000abf8 <_free_r>
80009ba6:	30 08       	mov	r8,0
80009ba8:	8f d8       	st.w	r7[0x34],r8
80009baa:	8e 68       	ld.sh	r8,r7[0xc]
80009bac:	e0 18 ff db 	andl	r8,0xffdb
80009bb0:	ae 68       	st.h	r7[0xc],r8
80009bb2:	30 08       	mov	r8,0
80009bb4:	8f 18       	st.w	r7[0x4],r8
80009bb6:	6e 48       	ld.w	r8,r7[0x10]
80009bb8:	8f 08       	st.w	r7[0x0],r8
80009bba:	8e 68       	ld.sh	r8,r7[0xc]
80009bbc:	a3 b8       	sbr	r8,0x3
80009bbe:	ae 68       	st.h	r7[0xc],r8
80009bc0:	6e 48       	ld.w	r8,r7[0x10]
80009bc2:	58 08       	cp.w	r8,0
80009bc4:	c0 b1       	brne	80009bda <__swsetup_r+0xaa>
80009bc6:	8e 68       	ld.sh	r8,r7[0xc]
80009bc8:	e2 18 02 80 	andl	r8,0x280,COH
80009bcc:	e0 48 02 00 	cp.w	r8,512
80009bd0:	c0 50       	breq	80009bda <__swsetup_r+0xaa>
80009bd2:	0c 9c       	mov	r12,r6
80009bd4:	0e 9b       	mov	r11,r7
80009bd6:	e0 a0 0a 4b 	rcall	8000b06c <__smakebuf_r>
80009bda:	8e 69       	ld.sh	r9,r7[0xc]
80009bdc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009be0:	c0 70       	breq	80009bee <__swsetup_r+0xbe>
80009be2:	30 08       	mov	r8,0
80009be4:	8f 28       	st.w	r7[0x8],r8
80009be6:	6e 58       	ld.w	r8,r7[0x14]
80009be8:	5c 38       	neg	r8
80009bea:	8f 68       	st.w	r7[0x18],r8
80009bec:	c0 68       	rjmp	80009bf8 <__swsetup_r+0xc8>
80009bee:	ed b9 00 01 	bld	r9,0x1
80009bf2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009bf6:	8f 28       	st.w	r7[0x8],r8
80009bf8:	6e 48       	ld.w	r8,r7[0x10]
80009bfa:	58 08       	cp.w	r8,0
80009bfc:	c0 61       	brne	80009c08 <__swsetup_r+0xd8>
80009bfe:	8e 68       	ld.sh	r8,r7[0xc]
80009c00:	ed b8 00 07 	bld	r8,0x7
80009c04:	c0 21       	brne	80009c08 <__swsetup_r+0xd8>
80009c06:	dc 2a       	popm	r4-r7,pc,r12=-1
80009c08:	d8 2a       	popm	r4-r7,pc,r12=0
80009c0a:	d7 03       	nop

80009c0c <quorem>:
80009c0c:	d4 31       	pushm	r0-r7,lr
80009c0e:	20 2d       	sub	sp,8
80009c10:	18 97       	mov	r7,r12
80009c12:	78 48       	ld.w	r8,r12[0x10]
80009c14:	76 46       	ld.w	r6,r11[0x10]
80009c16:	0c 38       	cp.w	r8,r6
80009c18:	c0 34       	brge	80009c1e <quorem+0x12>
80009c1a:	30 0c       	mov	r12,0
80009c1c:	c8 58       	rjmp	80009d26 <quorem+0x11a>
80009c1e:	ec c2 ff fc 	sub	r2,r6,-4
80009c22:	f6 c3 ff ec 	sub	r3,r11,-20
80009c26:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009c2a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009c2e:	2f f9       	sub	r9,-1
80009c30:	20 16       	sub	r6,1
80009c32:	f8 09 0d 08 	divu	r8,r12,r9
80009c36:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009c3a:	ee c4 ff ec 	sub	r4,r7,-20
80009c3e:	10 95       	mov	r5,r8
80009c40:	58 08       	cp.w	r8,0
80009c42:	c4 10       	breq	80009cc4 <quorem+0xb8>
80009c44:	30 09       	mov	r9,0
80009c46:	06 9a       	mov	r10,r3
80009c48:	08 98       	mov	r8,r4
80009c4a:	12 91       	mov	r1,r9
80009c4c:	50 0b       	stdsp	sp[0x0],r11
80009c4e:	70 0e       	ld.w	lr,r8[0x0]
80009c50:	b1 8e       	lsr	lr,0x10
80009c52:	50 1e       	stdsp	sp[0x4],lr
80009c54:	15 0e       	ld.w	lr,r10++
80009c56:	fc 00 16 10 	lsr	r0,lr,0x10
80009c5a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009c5e:	ea 0e 03 41 	mac	r1,r5,lr
80009c62:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009c66:	b1 81       	lsr	r1,0x10
80009c68:	40 1b       	lddsp	r11,sp[0x4]
80009c6a:	ea 00 02 40 	mul	r0,r5,r0
80009c6e:	e2 00 00 00 	add	r0,r1,r0
80009c72:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009c76:	02 1b       	sub	r11,r1
80009c78:	50 1b       	stdsp	sp[0x4],r11
80009c7a:	70 0b       	ld.w	r11,r8[0x0]
80009c7c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009c80:	02 09       	add	r9,r1
80009c82:	f2 0e 01 0e 	sub	lr,r9,lr
80009c86:	b0 1e       	st.h	r8[0x2],lr
80009c88:	fc 09 14 10 	asr	r9,lr,0x10
80009c8c:	40 1e       	lddsp	lr,sp[0x4]
80009c8e:	fc 09 00 09 	add	r9,lr,r9
80009c92:	b0 09       	st.h	r8[0x0],r9
80009c94:	e0 01 16 10 	lsr	r1,r0,0x10
80009c98:	2f c8       	sub	r8,-4
80009c9a:	b1 49       	asr	r9,0x10
80009c9c:	04 3a       	cp.w	r10,r2
80009c9e:	fe 98 ff d8 	brls	80009c4e <quorem+0x42>
80009ca2:	40 0b       	lddsp	r11,sp[0x0]
80009ca4:	58 0c       	cp.w	r12,0
80009ca6:	c0 f1       	brne	80009cc4 <quorem+0xb8>
80009ca8:	ec c8 ff fb 	sub	r8,r6,-5
80009cac:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009cb0:	c0 28       	rjmp	80009cb4 <quorem+0xa8>
80009cb2:	20 16       	sub	r6,1
80009cb4:	20 48       	sub	r8,4
80009cb6:	08 38       	cp.w	r8,r4
80009cb8:	e0 88 00 05 	brls	80009cc2 <quorem+0xb6>
80009cbc:	70 09       	ld.w	r9,r8[0x0]
80009cbe:	58 09       	cp.w	r9,0
80009cc0:	cf 90       	breq	80009cb2 <quorem+0xa6>
80009cc2:	8f 46       	st.w	r7[0x10],r6
80009cc4:	0e 9c       	mov	r12,r7
80009cc6:	e0 a0 0a d2 	rcall	8000b26a <__mcmp>
80009cca:	c2 d5       	brlt	80009d24 <quorem+0x118>
80009ccc:	2f f5       	sub	r5,-1
80009cce:	08 98       	mov	r8,r4
80009cd0:	30 09       	mov	r9,0
80009cd2:	07 0b       	ld.w	r11,r3++
80009cd4:	f6 0a 16 10 	lsr	r10,r11,0x10
80009cd8:	70 0c       	ld.w	r12,r8[0x0]
80009cda:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009cde:	f8 0e 16 10 	lsr	lr,r12,0x10
80009ce2:	14 1e       	sub	lr,r10
80009ce4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009ce8:	16 1a       	sub	r10,r11
80009cea:	12 0a       	add	r10,r9
80009cec:	b0 1a       	st.h	r8[0x2],r10
80009cee:	b1 4a       	asr	r10,0x10
80009cf0:	fc 0a 00 09 	add	r9,lr,r10
80009cf4:	b0 09       	st.h	r8[0x0],r9
80009cf6:	2f c8       	sub	r8,-4
80009cf8:	b1 49       	asr	r9,0x10
80009cfa:	04 33       	cp.w	r3,r2
80009cfc:	fe 98 ff eb 	brls	80009cd2 <quorem+0xc6>
80009d00:	ec c8 ff fb 	sub	r8,r6,-5
80009d04:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009d08:	58 09       	cp.w	r9,0
80009d0a:	c0 d1       	brne	80009d24 <quorem+0x118>
80009d0c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009d10:	c0 28       	rjmp	80009d14 <quorem+0x108>
80009d12:	20 16       	sub	r6,1
80009d14:	20 48       	sub	r8,4
80009d16:	08 38       	cp.w	r8,r4
80009d18:	e0 88 00 05 	brls	80009d22 <quorem+0x116>
80009d1c:	70 09       	ld.w	r9,r8[0x0]
80009d1e:	58 09       	cp.w	r9,0
80009d20:	cf 90       	breq	80009d12 <quorem+0x106>
80009d22:	8f 46       	st.w	r7[0x10],r6
80009d24:	0a 9c       	mov	r12,r5
80009d26:	2f ed       	sub	sp,-8
80009d28:	d8 32       	popm	r0-r7,pc
80009d2a:	d7 03       	nop

80009d2c <_dtoa_r>:
80009d2c:	d4 31       	pushm	r0-r7,lr
80009d2e:	21 ad       	sub	sp,104
80009d30:	fa c4 ff 74 	sub	r4,sp,-140
80009d34:	18 97       	mov	r7,r12
80009d36:	16 95       	mov	r5,r11
80009d38:	68 2c       	ld.w	r12,r4[0x8]
80009d3a:	50 c9       	stdsp	sp[0x30],r9
80009d3c:	68 16       	ld.w	r6,r4[0x4]
80009d3e:	68 09       	ld.w	r9,r4[0x0]
80009d40:	50 e8       	stdsp	sp[0x38],r8
80009d42:	14 94       	mov	r4,r10
80009d44:	51 2c       	stdsp	sp[0x48],r12
80009d46:	fa e5 00 08 	st.d	sp[8],r4
80009d4a:	51 59       	stdsp	sp[0x54],r9
80009d4c:	6e 95       	ld.w	r5,r7[0x24]
80009d4e:	58 05       	cp.w	r5,0
80009d50:	c0 91       	brne	80009d62 <_dtoa_r+0x36>
80009d52:	31 0c       	mov	r12,16
80009d54:	fe b0 e8 d6 	rcall	80006f00 <malloc>
80009d58:	99 35       	st.w	r12[0xc],r5
80009d5a:	8f 9c       	st.w	r7[0x24],r12
80009d5c:	99 15       	st.w	r12[0x4],r5
80009d5e:	99 25       	st.w	r12[0x8],r5
80009d60:	99 05       	st.w	r12[0x0],r5
80009d62:	6e 99       	ld.w	r9,r7[0x24]
80009d64:	72 08       	ld.w	r8,r9[0x0]
80009d66:	58 08       	cp.w	r8,0
80009d68:	c0 f0       	breq	80009d86 <_dtoa_r+0x5a>
80009d6a:	72 1a       	ld.w	r10,r9[0x4]
80009d6c:	91 1a       	st.w	r8[0x4],r10
80009d6e:	30 1a       	mov	r10,1
80009d70:	72 19       	ld.w	r9,r9[0x4]
80009d72:	f4 09 09 49 	lsl	r9,r10,r9
80009d76:	10 9b       	mov	r11,r8
80009d78:	91 29       	st.w	r8[0x8],r9
80009d7a:	0e 9c       	mov	r12,r7
80009d7c:	e0 a0 0a 90 	rcall	8000b29c <_Bfree>
80009d80:	6e 98       	ld.w	r8,r7[0x24]
80009d82:	30 09       	mov	r9,0
80009d84:	91 09       	st.w	r8[0x0],r9
80009d86:	40 28       	lddsp	r8,sp[0x8]
80009d88:	10 94       	mov	r4,r8
80009d8a:	58 08       	cp.w	r8,0
80009d8c:	c0 64       	brge	80009d98 <_dtoa_r+0x6c>
80009d8e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009d92:	50 28       	stdsp	sp[0x8],r8
80009d94:	30 18       	mov	r8,1
80009d96:	c0 28       	rjmp	80009d9a <_dtoa_r+0x6e>
80009d98:	30 08       	mov	r8,0
80009d9a:	8d 08       	st.w	r6[0x0],r8
80009d9c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009da0:	40 26       	lddsp	r6,sp[0x8]
80009da2:	0c 98       	mov	r8,r6
80009da4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009da8:	18 38       	cp.w	r8,r12
80009daa:	c2 01       	brne	80009dea <_dtoa_r+0xbe>
80009dac:	e0 68 27 0f 	mov	r8,9999
80009db0:	41 5b       	lddsp	r11,sp[0x54]
80009db2:	97 08       	st.w	r11[0x0],r8
80009db4:	40 3a       	lddsp	r10,sp[0xc]
80009db6:	58 0a       	cp.w	r10,0
80009db8:	c0 71       	brne	80009dc6 <_dtoa_r+0x9a>
80009dba:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009dbe:	c0 41       	brne	80009dc6 <_dtoa_r+0x9a>
80009dc0:	fe cc c3 8c 	sub	r12,pc,-15476
80009dc4:	c0 38       	rjmp	80009dca <_dtoa_r+0x9e>
80009dc6:	fe cc c3 86 	sub	r12,pc,-15482
80009dca:	41 29       	lddsp	r9,sp[0x48]
80009dcc:	58 09       	cp.w	r9,0
80009dce:	e0 80 05 9a 	breq	8000a902 <_dtoa_r+0xbd6>
80009dd2:	f8 c8 ff fd 	sub	r8,r12,-3
80009dd6:	f8 c9 ff f8 	sub	r9,r12,-8
80009dda:	11 8b       	ld.ub	r11,r8[0x0]
80009ddc:	30 0a       	mov	r10,0
80009dde:	41 25       	lddsp	r5,sp[0x48]
80009de0:	f4 0b 18 00 	cp.b	r11,r10
80009de4:	f2 08 17 10 	movne	r8,r9
80009de8:	c1 68       	rjmp	80009e14 <_dtoa_r+0xe8>
80009dea:	fa ea 00 08 	ld.d	r10,sp[8]
80009dee:	30 08       	mov	r8,0
80009df0:	fa eb 00 3c 	st.d	sp[60],r10
80009df4:	30 09       	mov	r9,0
80009df6:	e0 a0 10 c2 	rcall	8000bf7a <__avr32_f64_cmp_eq>
80009dfa:	c1 00       	breq	80009e1a <_dtoa_r+0xee>
80009dfc:	30 18       	mov	r8,1
80009dfe:	41 5a       	lddsp	r10,sp[0x54]
80009e00:	95 08       	st.w	r10[0x0],r8
80009e02:	fe cc c4 f2 	sub	r12,pc,-15118
80009e06:	41 29       	lddsp	r9,sp[0x48]
80009e08:	f8 08 00 08 	add	r8,r12,r8
80009e0c:	58 09       	cp.w	r9,0
80009e0e:	e0 80 05 7a 	breq	8000a902 <_dtoa_r+0xbd6>
80009e12:	12 95       	mov	r5,r9
80009e14:	8b 08       	st.w	r5[0x0],r8
80009e16:	e0 8f 05 76 	bral	8000a902 <_dtoa_r+0xbd6>
80009e1a:	fa c8 ff 9c 	sub	r8,sp,-100
80009e1e:	fa c9 ff a0 	sub	r9,sp,-96
80009e22:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e26:	0e 9c       	mov	r12,r7
80009e28:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009e2c:	e0 a0 0a 8a 	rcall	8000b340 <__d2b>
80009e30:	18 93       	mov	r3,r12
80009e32:	58 05       	cp.w	r5,0
80009e34:	c0 d0       	breq	80009e4e <_dtoa_r+0x122>
80009e36:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e3a:	30 04       	mov	r4,0
80009e3c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009e40:	ea c5 03 ff 	sub	r5,r5,1023
80009e44:	10 9b       	mov	r11,r8
80009e46:	51 74       	stdsp	sp[0x5c],r4
80009e48:	ea 1b 3f f0 	orh	r11,0x3ff0
80009e4c:	c2 58       	rjmp	80009e96 <_dtoa_r+0x16a>
80009e4e:	41 88       	lddsp	r8,sp[0x60]
80009e50:	41 9c       	lddsp	r12,sp[0x64]
80009e52:	10 0c       	add	r12,r8
80009e54:	f8 c5 fb ce 	sub	r5,r12,-1074
80009e58:	e0 45 00 20 	cp.w	r5,32
80009e5c:	e0 8a 00 0e 	brle	80009e78 <_dtoa_r+0x14c>
80009e60:	f8 cc fb ee 	sub	r12,r12,-1042
80009e64:	40 3b       	lddsp	r11,sp[0xc]
80009e66:	ea 08 11 40 	rsub	r8,r5,64
80009e6a:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009e6e:	ec 08 09 46 	lsl	r6,r6,r8
80009e72:	0c 4c       	or	r12,r6
80009e74:	c0 78       	rjmp	80009e82 <_dtoa_r+0x156>
80009e76:	d7 03       	nop
80009e78:	ea 0c 11 20 	rsub	r12,r5,32
80009e7c:	40 3a       	lddsp	r10,sp[0xc]
80009e7e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009e82:	e0 a0 10 08 	rcall	8000be92 <__avr32_u32_to_f64>
80009e86:	fc 18 fe 10 	movh	r8,0xfe10
80009e8a:	30 19       	mov	r9,1
80009e8c:	ea c5 04 33 	sub	r5,r5,1075
80009e90:	f0 0b 00 0b 	add	r11,r8,r11
80009e94:	51 79       	stdsp	sp[0x5c],r9
80009e96:	30 08       	mov	r8,0
80009e98:	fc 19 3f f8 	movh	r9,0x3ff8
80009e9c:	e0 a0 0e 90 	rcall	8000bbbc <__avr32_f64_sub>
80009ea0:	e0 68 43 61 	mov	r8,17249
80009ea4:	ea 18 63 6f 	orh	r8,0x636f
80009ea8:	e0 69 87 a7 	mov	r9,34727
80009eac:	ea 19 3f d2 	orh	r9,0x3fd2
80009eb0:	e0 a0 0d 9a 	rcall	8000b9e4 <__avr32_f64_mul>
80009eb4:	e0 68 c8 b3 	mov	r8,51379
80009eb8:	ea 18 8b 60 	orh	r8,0x8b60
80009ebc:	e0 69 8a 28 	mov	r9,35368
80009ec0:	ea 19 3f c6 	orh	r9,0x3fc6
80009ec4:	e0 a0 0f 4a 	rcall	8000bd58 <__avr32_f64_add>
80009ec8:	0a 9c       	mov	r12,r5
80009eca:	14 90       	mov	r0,r10
80009ecc:	16 91       	mov	r1,r11
80009ece:	e0 a0 0f e6 	rcall	8000be9a <__avr32_s32_to_f64>
80009ed2:	e0 68 79 fb 	mov	r8,31227
80009ed6:	ea 18 50 9f 	orh	r8,0x509f
80009eda:	e0 69 44 13 	mov	r9,17427
80009ede:	ea 19 3f d3 	orh	r9,0x3fd3
80009ee2:	e0 a0 0d 81 	rcall	8000b9e4 <__avr32_f64_mul>
80009ee6:	14 98       	mov	r8,r10
80009ee8:	16 99       	mov	r9,r11
80009eea:	00 9a       	mov	r10,r0
80009eec:	02 9b       	mov	r11,r1
80009eee:	e0 a0 0f 35 	rcall	8000bd58 <__avr32_f64_add>
80009ef2:	14 90       	mov	r0,r10
80009ef4:	16 91       	mov	r1,r11
80009ef6:	e0 a0 0f bb 	rcall	8000be6c <__avr32_f64_to_s32>
80009efa:	30 08       	mov	r8,0
80009efc:	18 96       	mov	r6,r12
80009efe:	30 09       	mov	r9,0
80009f00:	00 9a       	mov	r10,r0
80009f02:	02 9b       	mov	r11,r1
80009f04:	e0 a0 10 82 	rcall	8000c008 <__avr32_f64_cmp_lt>
80009f08:	c0 c0       	breq	80009f20 <_dtoa_r+0x1f4>
80009f0a:	0c 9c       	mov	r12,r6
80009f0c:	e0 a0 0f c7 	rcall	8000be9a <__avr32_s32_to_f64>
80009f10:	14 98       	mov	r8,r10
80009f12:	16 99       	mov	r9,r11
80009f14:	00 9a       	mov	r10,r0
80009f16:	02 9b       	mov	r11,r1
80009f18:	e0 a0 10 31 	rcall	8000bf7a <__avr32_f64_cmp_eq>
80009f1c:	f7 b6 00 01 	subeq	r6,1
80009f20:	59 66       	cp.w	r6,22
80009f22:	e0 88 00 05 	brls	80009f2c <_dtoa_r+0x200>
80009f26:	30 18       	mov	r8,1
80009f28:	51 48       	stdsp	sp[0x50],r8
80009f2a:	c1 38       	rjmp	80009f50 <_dtoa_r+0x224>
80009f2c:	fe c8 c4 38 	sub	r8,pc,-15304
80009f30:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f34:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009f38:	e0 a0 10 68 	rcall	8000c008 <__avr32_f64_cmp_lt>
80009f3c:	f9 b4 00 00 	moveq	r4,0
80009f40:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009f44:	f7 b6 01 01 	subne	r6,1
80009f48:	f9 bc 01 00 	movne	r12,0
80009f4c:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009f50:	41 90       	lddsp	r0,sp[0x64]
80009f52:	20 10       	sub	r0,1
80009f54:	0a 10       	sub	r0,r5
80009f56:	c0 46       	brmi	80009f5e <_dtoa_r+0x232>
80009f58:	50 40       	stdsp	sp[0x10],r0
80009f5a:	30 00       	mov	r0,0
80009f5c:	c0 48       	rjmp	80009f64 <_dtoa_r+0x238>
80009f5e:	30 0b       	mov	r11,0
80009f60:	5c 30       	neg	r0
80009f62:	50 4b       	stdsp	sp[0x10],r11
80009f64:	ec 02 11 00 	rsub	r2,r6,0
80009f68:	58 06       	cp.w	r6,0
80009f6a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009f6e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009f72:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009f76:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009f7a:	f9 b2 04 00 	movge	r2,0
80009f7e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009f82:	f9 b9 05 00 	movlt	r9,0
80009f86:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009f8a:	40 c8       	lddsp	r8,sp[0x30]
80009f8c:	58 98       	cp.w	r8,9
80009f8e:	e0 8b 00 20 	brhi	80009fce <_dtoa_r+0x2a2>
80009f92:	58 58       	cp.w	r8,5
80009f94:	f9 b4 0a 01 	movle	r4,1
80009f98:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009f9c:	f7 b5 09 04 	subgt	r5,4
80009fa0:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009fa4:	f9 b4 09 00 	movgt	r4,0
80009fa8:	40 cc       	lddsp	r12,sp[0x30]
80009faa:	58 3c       	cp.w	r12,3
80009fac:	c2 d0       	breq	8000a006 <_dtoa_r+0x2da>
80009fae:	e0 89 00 05 	brgt	80009fb8 <_dtoa_r+0x28c>
80009fb2:	58 2c       	cp.w	r12,2
80009fb4:	c1 01       	brne	80009fd4 <_dtoa_r+0x2a8>
80009fb6:	c1 88       	rjmp	80009fe6 <_dtoa_r+0x2ba>
80009fb8:	40 cb       	lddsp	r11,sp[0x30]
80009fba:	58 4b       	cp.w	r11,4
80009fbc:	c0 60       	breq	80009fc8 <_dtoa_r+0x29c>
80009fbe:	58 5b       	cp.w	r11,5
80009fc0:	c0 a1       	brne	80009fd4 <_dtoa_r+0x2a8>
80009fc2:	30 1a       	mov	r10,1
80009fc4:	50 da       	stdsp	sp[0x34],r10
80009fc6:	c2 28       	rjmp	8000a00a <_dtoa_r+0x2de>
80009fc8:	30 19       	mov	r9,1
80009fca:	50 d9       	stdsp	sp[0x34],r9
80009fcc:	c0 f8       	rjmp	80009fea <_dtoa_r+0x2be>
80009fce:	30 08       	mov	r8,0
80009fd0:	30 14       	mov	r4,1
80009fd2:	50 c8       	stdsp	sp[0x30],r8
80009fd4:	3f f5       	mov	r5,-1
80009fd6:	30 1c       	mov	r12,1
80009fd8:	30 0b       	mov	r11,0
80009fda:	50 95       	stdsp	sp[0x24],r5
80009fdc:	50 dc       	stdsp	sp[0x34],r12
80009fde:	0a 91       	mov	r1,r5
80009fe0:	31 28       	mov	r8,18
80009fe2:	50 eb       	stdsp	sp[0x38],r11
80009fe4:	c2 08       	rjmp	8000a024 <_dtoa_r+0x2f8>
80009fe6:	30 0a       	mov	r10,0
80009fe8:	50 da       	stdsp	sp[0x34],r10
80009fea:	40 e9       	lddsp	r9,sp[0x38]
80009fec:	58 09       	cp.w	r9,0
80009fee:	e0 89 00 07 	brgt	80009ffc <_dtoa_r+0x2d0>
80009ff2:	30 18       	mov	r8,1
80009ff4:	50 98       	stdsp	sp[0x24],r8
80009ff6:	10 91       	mov	r1,r8
80009ff8:	50 e8       	stdsp	sp[0x38],r8
80009ffa:	c1 58       	rjmp	8000a024 <_dtoa_r+0x2f8>
80009ffc:	40 e5       	lddsp	r5,sp[0x38]
80009ffe:	50 95       	stdsp	sp[0x24],r5
8000a000:	0a 91       	mov	r1,r5
8000a002:	0a 98       	mov	r8,r5
8000a004:	c1 08       	rjmp	8000a024 <_dtoa_r+0x2f8>
8000a006:	30 0c       	mov	r12,0
8000a008:	50 dc       	stdsp	sp[0x34],r12
8000a00a:	40 eb       	lddsp	r11,sp[0x38]
8000a00c:	ec 0b 00 0b 	add	r11,r6,r11
8000a010:	50 9b       	stdsp	sp[0x24],r11
8000a012:	16 98       	mov	r8,r11
8000a014:	2f f8       	sub	r8,-1
8000a016:	58 08       	cp.w	r8,0
8000a018:	e0 89 00 05 	brgt	8000a022 <_dtoa_r+0x2f6>
8000a01c:	10 91       	mov	r1,r8
8000a01e:	30 18       	mov	r8,1
8000a020:	c0 28       	rjmp	8000a024 <_dtoa_r+0x2f8>
8000a022:	10 91       	mov	r1,r8
8000a024:	30 09       	mov	r9,0
8000a026:	6e 9a       	ld.w	r10,r7[0x24]
8000a028:	95 19       	st.w	r10[0x4],r9
8000a02a:	30 49       	mov	r9,4
8000a02c:	c0 68       	rjmp	8000a038 <_dtoa_r+0x30c>
8000a02e:	d7 03       	nop
8000a030:	6a 1a       	ld.w	r10,r5[0x4]
8000a032:	a1 79       	lsl	r9,0x1
8000a034:	2f fa       	sub	r10,-1
8000a036:	8b 1a       	st.w	r5[0x4],r10
8000a038:	6e 95       	ld.w	r5,r7[0x24]
8000a03a:	f2 ca ff ec 	sub	r10,r9,-20
8000a03e:	10 3a       	cp.w	r10,r8
8000a040:	fe 98 ff f8 	brls	8000a030 <_dtoa_r+0x304>
8000a044:	6a 1b       	ld.w	r11,r5[0x4]
8000a046:	0e 9c       	mov	r12,r7
8000a048:	e0 a0 09 44 	rcall	8000b2d0 <_Balloc>
8000a04c:	58 e1       	cp.w	r1,14
8000a04e:	5f 88       	srls	r8
8000a050:	8b 0c       	st.w	r5[0x0],r12
8000a052:	f1 e4 00 04 	and	r4,r8,r4
8000a056:	6e 98       	ld.w	r8,r7[0x24]
8000a058:	70 08       	ld.w	r8,r8[0x0]
8000a05a:	50 88       	stdsp	sp[0x20],r8
8000a05c:	e0 80 01 82 	breq	8000a360 <_dtoa_r+0x634>
8000a060:	58 06       	cp.w	r6,0
8000a062:	e0 8a 00 43 	brle	8000a0e8 <_dtoa_r+0x3bc>
8000a066:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a06a:	fe c8 c5 76 	sub	r8,pc,-14986
8000a06e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a072:	fa e5 00 18 	st.d	sp[24],r4
8000a076:	ec 04 14 04 	asr	r4,r6,0x4
8000a07a:	ed b4 00 04 	bld	r4,0x4
8000a07e:	c0 30       	breq	8000a084 <_dtoa_r+0x358>
8000a080:	30 25       	mov	r5,2
8000a082:	c1 08       	rjmp	8000a0a2 <_dtoa_r+0x376>
8000a084:	fe c8 c4 c8 	sub	r8,pc,-15160
8000a088:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a08c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a090:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a094:	e0 a0 0f ee 	rcall	8000c070 <__avr32_f64_div>
8000a098:	30 35       	mov	r5,3
8000a09a:	14 98       	mov	r8,r10
8000a09c:	16 99       	mov	r9,r11
8000a09e:	fa e9 00 08 	st.d	sp[8],r8
8000a0a2:	fe cc c4 e6 	sub	r12,pc,-15130
8000a0a6:	50 a3       	stdsp	sp[0x28],r3
8000a0a8:	0c 93       	mov	r3,r6
8000a0aa:	18 96       	mov	r6,r12
8000a0ac:	c0 f8       	rjmp	8000a0ca <_dtoa_r+0x39e>
8000a0ae:	fa ea 00 18 	ld.d	r10,sp[24]
8000a0b2:	ed b4 00 00 	bld	r4,0x0
8000a0b6:	c0 81       	brne	8000a0c6 <_dtoa_r+0x39a>
8000a0b8:	ec e8 00 00 	ld.d	r8,r6[0]
8000a0bc:	2f f5       	sub	r5,-1
8000a0be:	e0 a0 0c 93 	rcall	8000b9e4 <__avr32_f64_mul>
8000a0c2:	fa eb 00 18 	st.d	sp[24],r10
8000a0c6:	a1 54       	asr	r4,0x1
8000a0c8:	2f 86       	sub	r6,-8
8000a0ca:	58 04       	cp.w	r4,0
8000a0cc:	cf 11       	brne	8000a0ae <_dtoa_r+0x382>
8000a0ce:	fa e8 00 18 	ld.d	r8,sp[24]
8000a0d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0d6:	06 96       	mov	r6,r3
8000a0d8:	e0 a0 0f cc 	rcall	8000c070 <__avr32_f64_div>
8000a0dc:	40 a3       	lddsp	r3,sp[0x28]
8000a0de:	14 98       	mov	r8,r10
8000a0e0:	16 99       	mov	r9,r11
8000a0e2:	fa e9 00 08 	st.d	sp[8],r8
8000a0e6:	c2 f8       	rjmp	8000a144 <_dtoa_r+0x418>
8000a0e8:	ec 08 11 00 	rsub	r8,r6,0
8000a0ec:	c0 31       	brne	8000a0f2 <_dtoa_r+0x3c6>
8000a0ee:	30 25       	mov	r5,2
8000a0f0:	c2 a8       	rjmp	8000a144 <_dtoa_r+0x418>
8000a0f2:	fe cc c5 36 	sub	r12,pc,-15050
8000a0f6:	f0 04 14 04 	asr	r4,r8,0x4
8000a0fa:	50 1c       	stdsp	sp[0x4],r12
8000a0fc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a100:	fe c9 c6 0c 	sub	r9,pc,-14836
8000a104:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a108:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a10c:	e0 a0 0c 6c 	rcall	8000b9e4 <__avr32_f64_mul>
8000a110:	40 1c       	lddsp	r12,sp[0x4]
8000a112:	50 63       	stdsp	sp[0x18],r3
8000a114:	30 25       	mov	r5,2
8000a116:	0c 93       	mov	r3,r6
8000a118:	fa eb 00 08 	st.d	sp[8],r10
8000a11c:	18 96       	mov	r6,r12
8000a11e:	c0 f8       	rjmp	8000a13c <_dtoa_r+0x410>
8000a120:	fa ea 00 08 	ld.d	r10,sp[8]
8000a124:	ed b4 00 00 	bld	r4,0x0
8000a128:	c0 81       	brne	8000a138 <_dtoa_r+0x40c>
8000a12a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a12e:	2f f5       	sub	r5,-1
8000a130:	e0 a0 0c 5a 	rcall	8000b9e4 <__avr32_f64_mul>
8000a134:	fa eb 00 08 	st.d	sp[8],r10
8000a138:	a1 54       	asr	r4,0x1
8000a13a:	2f 86       	sub	r6,-8
8000a13c:	58 04       	cp.w	r4,0
8000a13e:	cf 11       	brne	8000a120 <_dtoa_r+0x3f4>
8000a140:	06 96       	mov	r6,r3
8000a142:	40 63       	lddsp	r3,sp[0x18]
8000a144:	41 4a       	lddsp	r10,sp[0x50]
8000a146:	58 0a       	cp.w	r10,0
8000a148:	c2 a0       	breq	8000a19c <_dtoa_r+0x470>
8000a14a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a14e:	58 01       	cp.w	r1,0
8000a150:	5f 94       	srgt	r4
8000a152:	fa e9 00 18 	st.d	sp[24],r8
8000a156:	30 08       	mov	r8,0
8000a158:	fc 19 3f f0 	movh	r9,0x3ff0
8000a15c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a160:	e0 a0 0f 54 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a164:	f9 bc 00 00 	moveq	r12,0
8000a168:	f9 bc 01 01 	movne	r12,1
8000a16c:	e9 ec 00 0c 	and	r12,r4,r12
8000a170:	c1 60       	breq	8000a19c <_dtoa_r+0x470>
8000a172:	40 98       	lddsp	r8,sp[0x24]
8000a174:	58 08       	cp.w	r8,0
8000a176:	e0 8a 00 f1 	brle	8000a358 <_dtoa_r+0x62c>
8000a17a:	30 08       	mov	r8,0
8000a17c:	fc 19 40 24 	movh	r9,0x4024
8000a180:	ec c4 00 01 	sub	r4,r6,1
8000a184:	fa ea 00 18 	ld.d	r10,sp[24]
8000a188:	2f f5       	sub	r5,-1
8000a18a:	50 64       	stdsp	sp[0x18],r4
8000a18c:	e0 a0 0c 2c 	rcall	8000b9e4 <__avr32_f64_mul>
8000a190:	40 94       	lddsp	r4,sp[0x24]
8000a192:	14 98       	mov	r8,r10
8000a194:	16 99       	mov	r9,r11
8000a196:	fa e9 00 08 	st.d	sp[8],r8
8000a19a:	c0 38       	rjmp	8000a1a0 <_dtoa_r+0x474>
8000a19c:	50 66       	stdsp	sp[0x18],r6
8000a19e:	02 94       	mov	r4,r1
8000a1a0:	0a 9c       	mov	r12,r5
8000a1a2:	e0 a0 0e 7c 	rcall	8000be9a <__avr32_s32_to_f64>
8000a1a6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a1aa:	e0 a0 0c 1d 	rcall	8000b9e4 <__avr32_f64_mul>
8000a1ae:	30 08       	mov	r8,0
8000a1b0:	fc 19 40 1c 	movh	r9,0x401c
8000a1b4:	e0 a0 0d d2 	rcall	8000bd58 <__avr32_f64_add>
8000a1b8:	14 98       	mov	r8,r10
8000a1ba:	16 99       	mov	r9,r11
8000a1bc:	fa e9 00 28 	st.d	sp[40],r8
8000a1c0:	fc 18 fc c0 	movh	r8,0xfcc0
8000a1c4:	40 a5       	lddsp	r5,sp[0x28]
8000a1c6:	10 05       	add	r5,r8
8000a1c8:	50 a5       	stdsp	sp[0x28],r5
8000a1ca:	58 04       	cp.w	r4,0
8000a1cc:	c2 11       	brne	8000a20e <_dtoa_r+0x4e2>
8000a1ce:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1d2:	30 08       	mov	r8,0
8000a1d4:	fc 19 40 14 	movh	r9,0x4014
8000a1d8:	e0 a0 0c f2 	rcall	8000bbbc <__avr32_f64_sub>
8000a1dc:	40 bc       	lddsp	r12,sp[0x2c]
8000a1de:	fa eb 00 08 	st.d	sp[8],r10
8000a1e2:	14 98       	mov	r8,r10
8000a1e4:	16 99       	mov	r9,r11
8000a1e6:	18 9a       	mov	r10,r12
8000a1e8:	0a 9b       	mov	r11,r5
8000a1ea:	e0 a0 0f 0f 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a1ee:	e0 81 02 54 	brne	8000a696 <_dtoa_r+0x96a>
8000a1f2:	0a 98       	mov	r8,r5
8000a1f4:	40 b9       	lddsp	r9,sp[0x2c]
8000a1f6:	ee 18 80 00 	eorh	r8,0x8000
8000a1fa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1fe:	10 95       	mov	r5,r8
8000a200:	12 98       	mov	r8,r9
8000a202:	0a 99       	mov	r9,r5
8000a204:	e0 a0 0f 02 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a208:	e0 81 02 3e 	brne	8000a684 <_dtoa_r+0x958>
8000a20c:	ca 68       	rjmp	8000a358 <_dtoa_r+0x62c>
8000a20e:	fe c9 c7 1a 	sub	r9,pc,-14566
8000a212:	e8 c8 00 01 	sub	r8,r4,1
8000a216:	40 d5       	lddsp	r5,sp[0x34]
8000a218:	58 05       	cp.w	r5,0
8000a21a:	c4 f0       	breq	8000a2b8 <_dtoa_r+0x58c>
8000a21c:	30 0c       	mov	r12,0
8000a21e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a222:	51 3c       	stdsp	sp[0x4c],r12
8000a224:	30 0a       	mov	r10,0
8000a226:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a22a:	e0 a0 0f 23 	rcall	8000c070 <__avr32_f64_div>
8000a22e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a232:	40 85       	lddsp	r5,sp[0x20]
8000a234:	e0 a0 0c c4 	rcall	8000bbbc <__avr32_f64_sub>
8000a238:	fa eb 00 28 	st.d	sp[40],r10
8000a23c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a240:	e0 a0 0e 16 	rcall	8000be6c <__avr32_f64_to_s32>
8000a244:	51 6c       	stdsp	sp[0x58],r12
8000a246:	e0 a0 0e 2a 	rcall	8000be9a <__avr32_s32_to_f64>
8000a24a:	14 98       	mov	r8,r10
8000a24c:	16 99       	mov	r9,r11
8000a24e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a252:	e0 a0 0c b5 	rcall	8000bbbc <__avr32_f64_sub>
8000a256:	fa eb 00 08 	st.d	sp[8],r10
8000a25a:	41 68       	lddsp	r8,sp[0x58]
8000a25c:	2d 08       	sub	r8,-48
8000a25e:	0a c8       	st.b	r5++,r8
8000a260:	41 39       	lddsp	r9,sp[0x4c]
8000a262:	2f f9       	sub	r9,-1
8000a264:	51 39       	stdsp	sp[0x4c],r9
8000a266:	fa e8 00 28 	ld.d	r8,sp[40]
8000a26a:	e0 a0 0e cf 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a26e:	e0 81 03 39 	brne	8000a8e0 <_dtoa_r+0xbb4>
8000a272:	fa e8 00 08 	ld.d	r8,sp[8]
8000a276:	30 0a       	mov	r10,0
8000a278:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a27c:	e0 a0 0c a0 	rcall	8000bbbc <__avr32_f64_sub>
8000a280:	fa e8 00 28 	ld.d	r8,sp[40]
8000a284:	e0 a0 0e c2 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a288:	fa ea 00 28 	ld.d	r10,sp[40]
8000a28c:	30 08       	mov	r8,0
8000a28e:	fc 19 40 24 	movh	r9,0x4024
8000a292:	e0 81 00 da 	brne	8000a446 <_dtoa_r+0x71a>
8000a296:	41 3c       	lddsp	r12,sp[0x4c]
8000a298:	08 3c       	cp.w	r12,r4
8000a29a:	c5 f4       	brge	8000a358 <_dtoa_r+0x62c>
8000a29c:	e0 a0 0b a4 	rcall	8000b9e4 <__avr32_f64_mul>
8000a2a0:	30 08       	mov	r8,0
8000a2a2:	fa eb 00 28 	st.d	sp[40],r10
8000a2a6:	fc 19 40 24 	movh	r9,0x4024
8000a2aa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2ae:	e0 a0 0b 9b 	rcall	8000b9e4 <__avr32_f64_mul>
8000a2b2:	fa eb 00 08 	st.d	sp[8],r10
8000a2b6:	cc 3b       	rjmp	8000a23c <_dtoa_r+0x510>
8000a2b8:	40 85       	lddsp	r5,sp[0x20]
8000a2ba:	08 05       	add	r5,r4
8000a2bc:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a2c0:	51 35       	stdsp	sp[0x4c],r5
8000a2c2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a2c6:	40 85       	lddsp	r5,sp[0x20]
8000a2c8:	e0 a0 0b 8e 	rcall	8000b9e4 <__avr32_f64_mul>
8000a2cc:	fa eb 00 28 	st.d	sp[40],r10
8000a2d0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2d4:	e0 a0 0d cc 	rcall	8000be6c <__avr32_f64_to_s32>
8000a2d8:	51 6c       	stdsp	sp[0x58],r12
8000a2da:	e0 a0 0d e0 	rcall	8000be9a <__avr32_s32_to_f64>
8000a2de:	14 98       	mov	r8,r10
8000a2e0:	16 99       	mov	r9,r11
8000a2e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2e6:	e0 a0 0c 6b 	rcall	8000bbbc <__avr32_f64_sub>
8000a2ea:	fa eb 00 08 	st.d	sp[8],r10
8000a2ee:	41 68       	lddsp	r8,sp[0x58]
8000a2f0:	2d 08       	sub	r8,-48
8000a2f2:	0a c8       	st.b	r5++,r8
8000a2f4:	41 3c       	lddsp	r12,sp[0x4c]
8000a2f6:	18 35       	cp.w	r5,r12
8000a2f8:	c2 81       	brne	8000a348 <_dtoa_r+0x61c>
8000a2fa:	30 08       	mov	r8,0
8000a2fc:	fc 19 3f e0 	movh	r9,0x3fe0
8000a300:	fa ea 00 28 	ld.d	r10,sp[40]
8000a304:	e0 a0 0d 2a 	rcall	8000bd58 <__avr32_f64_add>
8000a308:	40 85       	lddsp	r5,sp[0x20]
8000a30a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a30e:	08 05       	add	r5,r4
8000a310:	e0 a0 0e 7c 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a314:	e0 81 00 99 	brne	8000a446 <_dtoa_r+0x71a>
8000a318:	fa e8 00 28 	ld.d	r8,sp[40]
8000a31c:	30 0a       	mov	r10,0
8000a31e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a322:	e0 a0 0c 4d 	rcall	8000bbbc <__avr32_f64_sub>
8000a326:	14 98       	mov	r8,r10
8000a328:	16 99       	mov	r9,r11
8000a32a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a32e:	e0 a0 0e 6d 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a332:	c1 30       	breq	8000a358 <_dtoa_r+0x62c>
8000a334:	33 09       	mov	r9,48
8000a336:	0a 98       	mov	r8,r5
8000a338:	11 7a       	ld.ub	r10,--r8
8000a33a:	f2 0a 18 00 	cp.b	r10,r9
8000a33e:	e0 81 02 d1 	brne	8000a8e0 <_dtoa_r+0xbb4>
8000a342:	10 95       	mov	r5,r8
8000a344:	cf 9b       	rjmp	8000a336 <_dtoa_r+0x60a>
8000a346:	d7 03       	nop
8000a348:	30 08       	mov	r8,0
8000a34a:	fc 19 40 24 	movh	r9,0x4024
8000a34e:	e0 a0 0b 4b 	rcall	8000b9e4 <__avr32_f64_mul>
8000a352:	fa eb 00 08 	st.d	sp[8],r10
8000a356:	cb db       	rjmp	8000a2d0 <_dtoa_r+0x5a4>
8000a358:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a35c:	fa eb 00 08 	st.d	sp[8],r10
8000a360:	58 e6       	cp.w	r6,14
8000a362:	5f ab       	srle	r11
8000a364:	41 8a       	lddsp	r10,sp[0x60]
8000a366:	30 08       	mov	r8,0
8000a368:	f4 09 11 ff 	rsub	r9,r10,-1
8000a36c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a370:	f0 09 18 00 	cp.b	r9,r8
8000a374:	e0 80 00 82 	breq	8000a478 <_dtoa_r+0x74c>
8000a378:	40 ea       	lddsp	r10,sp[0x38]
8000a37a:	58 01       	cp.w	r1,0
8000a37c:	5f a9       	srle	r9
8000a37e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a382:	fe ca c8 8e 	sub	r10,pc,-14194
8000a386:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a38a:	fa e5 00 10 	st.d	sp[16],r4
8000a38e:	f0 09 18 00 	cp.b	r9,r8
8000a392:	c1 40       	breq	8000a3ba <_dtoa_r+0x68e>
8000a394:	58 01       	cp.w	r1,0
8000a396:	e0 81 01 77 	brne	8000a684 <_dtoa_r+0x958>
8000a39a:	30 08       	mov	r8,0
8000a39c:	fc 19 40 14 	movh	r9,0x4014
8000a3a0:	08 9a       	mov	r10,r4
8000a3a2:	0a 9b       	mov	r11,r5
8000a3a4:	e0 a0 0b 20 	rcall	8000b9e4 <__avr32_f64_mul>
8000a3a8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3ac:	e0 a0 0d fa 	rcall	8000bfa0 <__avr32_f64_cmp_ge>
8000a3b0:	e0 81 01 6a 	brne	8000a684 <_dtoa_r+0x958>
8000a3b4:	02 92       	mov	r2,r1
8000a3b6:	e0 8f 01 72 	bral	8000a69a <_dtoa_r+0x96e>
8000a3ba:	40 85       	lddsp	r5,sp[0x20]
8000a3bc:	30 14       	mov	r4,1
8000a3be:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3c2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3c6:	e0 a0 0e 55 	rcall	8000c070 <__avr32_f64_div>
8000a3ca:	e0 a0 0d 51 	rcall	8000be6c <__avr32_f64_to_s32>
8000a3ce:	18 92       	mov	r2,r12
8000a3d0:	e0 a0 0d 65 	rcall	8000be9a <__avr32_s32_to_f64>
8000a3d4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a3d8:	e0 a0 0b 06 	rcall	8000b9e4 <__avr32_f64_mul>
8000a3dc:	14 98       	mov	r8,r10
8000a3de:	16 99       	mov	r9,r11
8000a3e0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3e4:	e0 a0 0b ec 	rcall	8000bbbc <__avr32_f64_sub>
8000a3e8:	fa eb 00 08 	st.d	sp[8],r10
8000a3ec:	e4 c8 ff d0 	sub	r8,r2,-48
8000a3f0:	0a c8       	st.b	r5++,r8
8000a3f2:	fc 19 40 24 	movh	r9,0x4024
8000a3f6:	30 08       	mov	r8,0
8000a3f8:	02 34       	cp.w	r4,r1
8000a3fa:	c3 31       	brne	8000a460 <_dtoa_r+0x734>
8000a3fc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a400:	e0 a0 0c ac 	rcall	8000bd58 <__avr32_f64_add>
8000a404:	16 91       	mov	r1,r11
8000a406:	14 90       	mov	r0,r10
8000a408:	14 98       	mov	r8,r10
8000a40a:	02 99       	mov	r9,r1
8000a40c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a410:	e0 a0 0d fc 	rcall	8000c008 <__avr32_f64_cmp_lt>
8000a414:	c1 a1       	brne	8000a448 <_dtoa_r+0x71c>
8000a416:	fa e8 00 10 	ld.d	r8,sp[16]
8000a41a:	00 9a       	mov	r10,r0
8000a41c:	02 9b       	mov	r11,r1
8000a41e:	e0 a0 0d ae 	rcall	8000bf7a <__avr32_f64_cmp_eq>
8000a422:	e0 80 02 5e 	breq	8000a8de <_dtoa_r+0xbb2>
8000a426:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a42a:	c0 f1       	brne	8000a448 <_dtoa_r+0x71c>
8000a42c:	e0 8f 02 59 	bral	8000a8de <_dtoa_r+0xbb2>
8000a430:	40 8a       	lddsp	r10,sp[0x20]
8000a432:	14 38       	cp.w	r8,r10
8000a434:	c0 30       	breq	8000a43a <_dtoa_r+0x70e>
8000a436:	10 95       	mov	r5,r8
8000a438:	c0 98       	rjmp	8000a44a <_dtoa_r+0x71e>
8000a43a:	33 08       	mov	r8,48
8000a43c:	40 89       	lddsp	r9,sp[0x20]
8000a43e:	2f f6       	sub	r6,-1
8000a440:	b2 88       	st.b	r9[0x0],r8
8000a442:	40 88       	lddsp	r8,sp[0x20]
8000a444:	c0 88       	rjmp	8000a454 <_dtoa_r+0x728>
8000a446:	40 66       	lddsp	r6,sp[0x18]
8000a448:	33 99       	mov	r9,57
8000a44a:	0a 98       	mov	r8,r5
8000a44c:	11 7a       	ld.ub	r10,--r8
8000a44e:	f2 0a 18 00 	cp.b	r10,r9
8000a452:	ce f0       	breq	8000a430 <_dtoa_r+0x704>
8000a454:	50 66       	stdsp	sp[0x18],r6
8000a456:	11 89       	ld.ub	r9,r8[0x0]
8000a458:	2f f9       	sub	r9,-1
8000a45a:	b0 89       	st.b	r8[0x0],r9
8000a45c:	e0 8f 02 42 	bral	8000a8e0 <_dtoa_r+0xbb4>
8000a460:	e0 a0 0a c2 	rcall	8000b9e4 <__avr32_f64_mul>
8000a464:	2f f4       	sub	r4,-1
8000a466:	fa eb 00 08 	st.d	sp[8],r10
8000a46a:	30 08       	mov	r8,0
8000a46c:	30 09       	mov	r9,0
8000a46e:	e0 a0 0d 86 	rcall	8000bf7a <__avr32_f64_cmp_eq>
8000a472:	ca 60       	breq	8000a3be <_dtoa_r+0x692>
8000a474:	e0 8f 02 35 	bral	8000a8de <_dtoa_r+0xbb2>
8000a478:	40 d8       	lddsp	r8,sp[0x34]
8000a47a:	58 08       	cp.w	r8,0
8000a47c:	c0 51       	brne	8000a486 <_dtoa_r+0x75a>
8000a47e:	04 98       	mov	r8,r2
8000a480:	00 95       	mov	r5,r0
8000a482:	40 d4       	lddsp	r4,sp[0x34]
8000a484:	c3 78       	rjmp	8000a4f2 <_dtoa_r+0x7c6>
8000a486:	40 c5       	lddsp	r5,sp[0x30]
8000a488:	58 15       	cp.w	r5,1
8000a48a:	e0 89 00 0f 	brgt	8000a4a8 <_dtoa_r+0x77c>
8000a48e:	41 74       	lddsp	r4,sp[0x5c]
8000a490:	58 04       	cp.w	r4,0
8000a492:	c0 40       	breq	8000a49a <_dtoa_r+0x76e>
8000a494:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a498:	c0 48       	rjmp	8000a4a0 <_dtoa_r+0x774>
8000a49a:	41 99       	lddsp	r9,sp[0x64]
8000a49c:	f2 09 11 36 	rsub	r9,r9,54
8000a4a0:	04 98       	mov	r8,r2
8000a4a2:	00 95       	mov	r5,r0
8000a4a4:	c1 c8       	rjmp	8000a4dc <_dtoa_r+0x7b0>
8000a4a6:	d7 03       	nop
8000a4a8:	e2 c8 00 01 	sub	r8,r1,1
8000a4ac:	58 01       	cp.w	r1,0
8000a4ae:	e0 05 17 40 	movge	r5,r0
8000a4b2:	e2 09 17 40 	movge	r9,r1
8000a4b6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a4ba:	f9 b9 05 00 	movlt	r9,0
8000a4be:	10 32       	cp.w	r2,r8
8000a4c0:	e5 d8 e4 18 	subge	r8,r2,r8
8000a4c4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a4c8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a4cc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a4d0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a4d4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a4d8:	f9 b8 05 00 	movlt	r8,0
8000a4dc:	40 4b       	lddsp	r11,sp[0x10]
8000a4de:	12 0b       	add	r11,r9
8000a4e0:	50 08       	stdsp	sp[0x0],r8
8000a4e2:	50 4b       	stdsp	sp[0x10],r11
8000a4e4:	12 00       	add	r0,r9
8000a4e6:	30 1b       	mov	r11,1
8000a4e8:	0e 9c       	mov	r12,r7
8000a4ea:	e0 a0 08 a7 	rcall	8000b638 <__i2b>
8000a4ee:	40 08       	lddsp	r8,sp[0x0]
8000a4f0:	18 94       	mov	r4,r12
8000a4f2:	40 4a       	lddsp	r10,sp[0x10]
8000a4f4:	58 05       	cp.w	r5,0
8000a4f6:	5f 99       	srgt	r9
8000a4f8:	58 0a       	cp.w	r10,0
8000a4fa:	5f 9a       	srgt	r10
8000a4fc:	f5 e9 00 09 	and	r9,r10,r9
8000a500:	c0 80       	breq	8000a510 <_dtoa_r+0x7e4>
8000a502:	40 4c       	lddsp	r12,sp[0x10]
8000a504:	f8 05 0d 49 	min	r9,r12,r5
8000a508:	12 1c       	sub	r12,r9
8000a50a:	12 10       	sub	r0,r9
8000a50c:	50 4c       	stdsp	sp[0x10],r12
8000a50e:	12 15       	sub	r5,r9
8000a510:	58 02       	cp.w	r2,0
8000a512:	e0 8a 00 27 	brle	8000a560 <_dtoa_r+0x834>
8000a516:	40 db       	lddsp	r11,sp[0x34]
8000a518:	58 0b       	cp.w	r11,0
8000a51a:	c1 d0       	breq	8000a554 <_dtoa_r+0x828>
8000a51c:	58 08       	cp.w	r8,0
8000a51e:	e0 8a 00 17 	brle	8000a54c <_dtoa_r+0x820>
8000a522:	10 9a       	mov	r10,r8
8000a524:	50 08       	stdsp	sp[0x0],r8
8000a526:	08 9b       	mov	r11,r4
8000a528:	0e 9c       	mov	r12,r7
8000a52a:	e0 a0 08 cd 	rcall	8000b6c4 <__pow5mult>
8000a52e:	06 9a       	mov	r10,r3
8000a530:	18 9b       	mov	r11,r12
8000a532:	18 94       	mov	r4,r12
8000a534:	0e 9c       	mov	r12,r7
8000a536:	e0 a0 08 01 	rcall	8000b538 <__multiply>
8000a53a:	18 99       	mov	r9,r12
8000a53c:	06 9b       	mov	r11,r3
8000a53e:	50 19       	stdsp	sp[0x4],r9
8000a540:	0e 9c       	mov	r12,r7
8000a542:	e0 a0 06 ad 	rcall	8000b29c <_Bfree>
8000a546:	40 19       	lddsp	r9,sp[0x4]
8000a548:	40 08       	lddsp	r8,sp[0x0]
8000a54a:	12 93       	mov	r3,r9
8000a54c:	e4 08 01 0a 	sub	r10,r2,r8
8000a550:	c0 80       	breq	8000a560 <_dtoa_r+0x834>
8000a552:	c0 28       	rjmp	8000a556 <_dtoa_r+0x82a>
8000a554:	04 9a       	mov	r10,r2
8000a556:	06 9b       	mov	r11,r3
8000a558:	0e 9c       	mov	r12,r7
8000a55a:	e0 a0 08 b5 	rcall	8000b6c4 <__pow5mult>
8000a55e:	18 93       	mov	r3,r12
8000a560:	30 1b       	mov	r11,1
8000a562:	0e 9c       	mov	r12,r7
8000a564:	e0 a0 08 6a 	rcall	8000b638 <__i2b>
8000a568:	41 1a       	lddsp	r10,sp[0x44]
8000a56a:	18 92       	mov	r2,r12
8000a56c:	58 0a       	cp.w	r10,0
8000a56e:	e0 8a 00 07 	brle	8000a57c <_dtoa_r+0x850>
8000a572:	18 9b       	mov	r11,r12
8000a574:	0e 9c       	mov	r12,r7
8000a576:	e0 a0 08 a7 	rcall	8000b6c4 <__pow5mult>
8000a57a:	18 92       	mov	r2,r12
8000a57c:	40 c9       	lddsp	r9,sp[0x30]
8000a57e:	58 19       	cp.w	r9,1
8000a580:	e0 89 00 14 	brgt	8000a5a8 <_dtoa_r+0x87c>
8000a584:	40 38       	lddsp	r8,sp[0xc]
8000a586:	58 08       	cp.w	r8,0
8000a588:	c1 01       	brne	8000a5a8 <_dtoa_r+0x87c>
8000a58a:	40 29       	lddsp	r9,sp[0x8]
8000a58c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a590:	c0 c1       	brne	8000a5a8 <_dtoa_r+0x87c>
8000a592:	12 98       	mov	r8,r9
8000a594:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a598:	c0 80       	breq	8000a5a8 <_dtoa_r+0x87c>
8000a59a:	40 4c       	lddsp	r12,sp[0x10]
8000a59c:	30 1b       	mov	r11,1
8000a59e:	2f fc       	sub	r12,-1
8000a5a0:	2f f0       	sub	r0,-1
8000a5a2:	50 4c       	stdsp	sp[0x10],r12
8000a5a4:	50 6b       	stdsp	sp[0x18],r11
8000a5a6:	c0 38       	rjmp	8000a5ac <_dtoa_r+0x880>
8000a5a8:	30 0a       	mov	r10,0
8000a5aa:	50 6a       	stdsp	sp[0x18],r10
8000a5ac:	41 19       	lddsp	r9,sp[0x44]
8000a5ae:	58 09       	cp.w	r9,0
8000a5b0:	c0 31       	brne	8000a5b6 <_dtoa_r+0x88a>
8000a5b2:	30 1c       	mov	r12,1
8000a5b4:	c0 98       	rjmp	8000a5c6 <_dtoa_r+0x89a>
8000a5b6:	64 48       	ld.w	r8,r2[0x10]
8000a5b8:	2f c8       	sub	r8,-4
8000a5ba:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a5be:	e0 a0 05 df 	rcall	8000b17c <__hi0bits>
8000a5c2:	f8 0c 11 20 	rsub	r12,r12,32
8000a5c6:	40 4b       	lddsp	r11,sp[0x10]
8000a5c8:	f8 0b 00 08 	add	r8,r12,r11
8000a5cc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a5d0:	c0 c0       	breq	8000a5e8 <_dtoa_r+0x8bc>
8000a5d2:	f0 08 11 20 	rsub	r8,r8,32
8000a5d6:	58 48       	cp.w	r8,4
8000a5d8:	e0 8a 00 06 	brle	8000a5e4 <_dtoa_r+0x8b8>
8000a5dc:	20 48       	sub	r8,4
8000a5de:	10 0b       	add	r11,r8
8000a5e0:	50 4b       	stdsp	sp[0x10],r11
8000a5e2:	c0 78       	rjmp	8000a5f0 <_dtoa_r+0x8c4>
8000a5e4:	58 48       	cp.w	r8,4
8000a5e6:	c0 70       	breq	8000a5f4 <_dtoa_r+0x8c8>
8000a5e8:	40 4a       	lddsp	r10,sp[0x10]
8000a5ea:	2e 48       	sub	r8,-28
8000a5ec:	10 0a       	add	r10,r8
8000a5ee:	50 4a       	stdsp	sp[0x10],r10
8000a5f0:	10 00       	add	r0,r8
8000a5f2:	10 05       	add	r5,r8
8000a5f4:	58 00       	cp.w	r0,0
8000a5f6:	e0 8a 00 08 	brle	8000a606 <_dtoa_r+0x8da>
8000a5fa:	06 9b       	mov	r11,r3
8000a5fc:	00 9a       	mov	r10,r0
8000a5fe:	0e 9c       	mov	r12,r7
8000a600:	e0 a0 07 58 	rcall	8000b4b0 <__lshift>
8000a604:	18 93       	mov	r3,r12
8000a606:	40 49       	lddsp	r9,sp[0x10]
8000a608:	58 09       	cp.w	r9,0
8000a60a:	e0 8a 00 08 	brle	8000a61a <_dtoa_r+0x8ee>
8000a60e:	04 9b       	mov	r11,r2
8000a610:	12 9a       	mov	r10,r9
8000a612:	0e 9c       	mov	r12,r7
8000a614:	e0 a0 07 4e 	rcall	8000b4b0 <__lshift>
8000a618:	18 92       	mov	r2,r12
8000a61a:	41 48       	lddsp	r8,sp[0x50]
8000a61c:	58 08       	cp.w	r8,0
8000a61e:	c1 b0       	breq	8000a654 <_dtoa_r+0x928>
8000a620:	04 9b       	mov	r11,r2
8000a622:	06 9c       	mov	r12,r3
8000a624:	e0 a0 06 23 	rcall	8000b26a <__mcmp>
8000a628:	c1 64       	brge	8000a654 <_dtoa_r+0x928>
8000a62a:	06 9b       	mov	r11,r3
8000a62c:	30 09       	mov	r9,0
8000a62e:	30 aa       	mov	r10,10
8000a630:	0e 9c       	mov	r12,r7
8000a632:	e0 a0 08 0b 	rcall	8000b648 <__multadd>
8000a636:	20 16       	sub	r6,1
8000a638:	18 93       	mov	r3,r12
8000a63a:	40 dc       	lddsp	r12,sp[0x34]
8000a63c:	58 0c       	cp.w	r12,0
8000a63e:	c0 31       	brne	8000a644 <_dtoa_r+0x918>
8000a640:	40 91       	lddsp	r1,sp[0x24]
8000a642:	c0 98       	rjmp	8000a654 <_dtoa_r+0x928>
8000a644:	08 9b       	mov	r11,r4
8000a646:	40 91       	lddsp	r1,sp[0x24]
8000a648:	30 09       	mov	r9,0
8000a64a:	30 aa       	mov	r10,10
8000a64c:	0e 9c       	mov	r12,r7
8000a64e:	e0 a0 07 fd 	rcall	8000b648 <__multadd>
8000a652:	18 94       	mov	r4,r12
8000a654:	58 01       	cp.w	r1,0
8000a656:	5f a9       	srle	r9
8000a658:	40 cb       	lddsp	r11,sp[0x30]
8000a65a:	58 2b       	cp.w	r11,2
8000a65c:	5f 98       	srgt	r8
8000a65e:	f3 e8 00 08 	and	r8,r9,r8
8000a662:	c2 50       	breq	8000a6ac <_dtoa_r+0x980>
8000a664:	58 01       	cp.w	r1,0
8000a666:	c1 11       	brne	8000a688 <_dtoa_r+0x95c>
8000a668:	04 9b       	mov	r11,r2
8000a66a:	02 99       	mov	r9,r1
8000a66c:	30 5a       	mov	r10,5
8000a66e:	0e 9c       	mov	r12,r7
8000a670:	e0 a0 07 ec 	rcall	8000b648 <__multadd>
8000a674:	18 92       	mov	r2,r12
8000a676:	18 9b       	mov	r11,r12
8000a678:	06 9c       	mov	r12,r3
8000a67a:	e0 a0 05 f8 	rcall	8000b26a <__mcmp>
8000a67e:	e0 89 00 0f 	brgt	8000a69c <_dtoa_r+0x970>
8000a682:	c0 38       	rjmp	8000a688 <_dtoa_r+0x95c>
8000a684:	30 02       	mov	r2,0
8000a686:	04 94       	mov	r4,r2
8000a688:	40 ea       	lddsp	r10,sp[0x38]
8000a68a:	30 09       	mov	r9,0
8000a68c:	5c da       	com	r10
8000a68e:	40 85       	lddsp	r5,sp[0x20]
8000a690:	50 6a       	stdsp	sp[0x18],r10
8000a692:	50 49       	stdsp	sp[0x10],r9
8000a694:	c0 f9       	rjmp	8000a8b2 <_dtoa_r+0xb86>
8000a696:	08 92       	mov	r2,r4
8000a698:	40 66       	lddsp	r6,sp[0x18]
8000a69a:	04 94       	mov	r4,r2
8000a69c:	2f f6       	sub	r6,-1
8000a69e:	50 66       	stdsp	sp[0x18],r6
8000a6a0:	33 18       	mov	r8,49
8000a6a2:	40 85       	lddsp	r5,sp[0x20]
8000a6a4:	0a c8       	st.b	r5++,r8
8000a6a6:	30 08       	mov	r8,0
8000a6a8:	50 48       	stdsp	sp[0x10],r8
8000a6aa:	c0 49       	rjmp	8000a8b2 <_dtoa_r+0xb86>
8000a6ac:	40 dc       	lddsp	r12,sp[0x34]
8000a6ae:	58 0c       	cp.w	r12,0
8000a6b0:	e0 80 00 b5 	breq	8000a81a <_dtoa_r+0xaee>
8000a6b4:	58 05       	cp.w	r5,0
8000a6b6:	e0 8a 00 08 	brle	8000a6c6 <_dtoa_r+0x99a>
8000a6ba:	08 9b       	mov	r11,r4
8000a6bc:	0a 9a       	mov	r10,r5
8000a6be:	0e 9c       	mov	r12,r7
8000a6c0:	e0 a0 06 f8 	rcall	8000b4b0 <__lshift>
8000a6c4:	18 94       	mov	r4,r12
8000a6c6:	40 6b       	lddsp	r11,sp[0x18]
8000a6c8:	58 0b       	cp.w	r11,0
8000a6ca:	c0 31       	brne	8000a6d0 <_dtoa_r+0x9a4>
8000a6cc:	08 9c       	mov	r12,r4
8000a6ce:	c1 38       	rjmp	8000a6f4 <_dtoa_r+0x9c8>
8000a6d0:	68 1b       	ld.w	r11,r4[0x4]
8000a6d2:	0e 9c       	mov	r12,r7
8000a6d4:	e0 a0 05 fe 	rcall	8000b2d0 <_Balloc>
8000a6d8:	68 4a       	ld.w	r10,r4[0x10]
8000a6da:	18 95       	mov	r5,r12
8000a6dc:	e8 cb ff f4 	sub	r11,r4,-12
8000a6e0:	2f ea       	sub	r10,-2
8000a6e2:	2f 4c       	sub	r12,-12
8000a6e4:	a3 6a       	lsl	r10,0x2
8000a6e6:	fe b0 e6 44 	rcall	8000736e <memcpy>
8000a6ea:	0a 9b       	mov	r11,r5
8000a6ec:	30 1a       	mov	r10,1
8000a6ee:	0e 9c       	mov	r12,r7
8000a6f0:	e0 a0 06 e0 	rcall	8000b4b0 <__lshift>
8000a6f4:	50 44       	stdsp	sp[0x10],r4
8000a6f6:	40 3a       	lddsp	r10,sp[0xc]
8000a6f8:	30 19       	mov	r9,1
8000a6fa:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a6fe:	18 94       	mov	r4,r12
8000a700:	50 da       	stdsp	sp[0x34],r10
8000a702:	40 85       	lddsp	r5,sp[0x20]
8000a704:	50 99       	stdsp	sp[0x24],r9
8000a706:	50 26       	stdsp	sp[0x8],r6
8000a708:	50 e1       	stdsp	sp[0x38],r1
8000a70a:	04 9b       	mov	r11,r2
8000a70c:	06 9c       	mov	r12,r3
8000a70e:	fe b0 fa 7f 	rcall	80009c0c <quorem>
8000a712:	40 4b       	lddsp	r11,sp[0x10]
8000a714:	f8 c0 ff d0 	sub	r0,r12,-48
8000a718:	06 9c       	mov	r12,r3
8000a71a:	e0 a0 05 a8 	rcall	8000b26a <__mcmp>
8000a71e:	08 9a       	mov	r10,r4
8000a720:	50 6c       	stdsp	sp[0x18],r12
8000a722:	04 9b       	mov	r11,r2
8000a724:	0e 9c       	mov	r12,r7
8000a726:	e0 a0 06 5d 	rcall	8000b3e0 <__mdiff>
8000a72a:	18 91       	mov	r1,r12
8000a72c:	78 38       	ld.w	r8,r12[0xc]
8000a72e:	58 08       	cp.w	r8,0
8000a730:	c0 30       	breq	8000a736 <_dtoa_r+0xa0a>
8000a732:	30 16       	mov	r6,1
8000a734:	c0 68       	rjmp	8000a740 <_dtoa_r+0xa14>
8000a736:	18 9b       	mov	r11,r12
8000a738:	06 9c       	mov	r12,r3
8000a73a:	e0 a0 05 98 	rcall	8000b26a <__mcmp>
8000a73e:	18 96       	mov	r6,r12
8000a740:	0e 9c       	mov	r12,r7
8000a742:	02 9b       	mov	r11,r1
8000a744:	e0 a0 05 ac 	rcall	8000b29c <_Bfree>
8000a748:	40 cc       	lddsp	r12,sp[0x30]
8000a74a:	ed ec 10 08 	or	r8,r6,r12
8000a74e:	c0 d1       	brne	8000a768 <_dtoa_r+0xa3c>
8000a750:	40 db       	lddsp	r11,sp[0x34]
8000a752:	58 0b       	cp.w	r11,0
8000a754:	c0 a1       	brne	8000a768 <_dtoa_r+0xa3c>
8000a756:	40 26       	lddsp	r6,sp[0x8]
8000a758:	e0 40 00 39 	cp.w	r0,57
8000a75c:	c3 00       	breq	8000a7bc <_dtoa_r+0xa90>
8000a75e:	40 6a       	lddsp	r10,sp[0x18]
8000a760:	58 0a       	cp.w	r10,0
8000a762:	e0 89 00 24 	brgt	8000a7aa <_dtoa_r+0xa7e>
8000a766:	c2 f8       	rjmp	8000a7c4 <_dtoa_r+0xa98>
8000a768:	40 69       	lddsp	r9,sp[0x18]
8000a76a:	58 09       	cp.w	r9,0
8000a76c:	c0 85       	brlt	8000a77c <_dtoa_r+0xa50>
8000a76e:	12 98       	mov	r8,r9
8000a770:	40 cc       	lddsp	r12,sp[0x30]
8000a772:	18 48       	or	r8,r12
8000a774:	c1 d1       	brne	8000a7ae <_dtoa_r+0xa82>
8000a776:	40 db       	lddsp	r11,sp[0x34]
8000a778:	58 0b       	cp.w	r11,0
8000a77a:	c1 a1       	brne	8000a7ae <_dtoa_r+0xa82>
8000a77c:	0c 99       	mov	r9,r6
8000a77e:	40 26       	lddsp	r6,sp[0x8]
8000a780:	58 09       	cp.w	r9,0
8000a782:	e0 8a 00 21 	brle	8000a7c4 <_dtoa_r+0xa98>
8000a786:	06 9b       	mov	r11,r3
8000a788:	30 1a       	mov	r10,1
8000a78a:	0e 9c       	mov	r12,r7
8000a78c:	e0 a0 06 92 	rcall	8000b4b0 <__lshift>
8000a790:	04 9b       	mov	r11,r2
8000a792:	18 93       	mov	r3,r12
8000a794:	e0 a0 05 6b 	rcall	8000b26a <__mcmp>
8000a798:	e0 89 00 06 	brgt	8000a7a4 <_dtoa_r+0xa78>
8000a79c:	c1 41       	brne	8000a7c4 <_dtoa_r+0xa98>
8000a79e:	ed b0 00 00 	bld	r0,0x0
8000a7a2:	c1 11       	brne	8000a7c4 <_dtoa_r+0xa98>
8000a7a4:	e0 40 00 39 	cp.w	r0,57
8000a7a8:	c0 a0       	breq	8000a7bc <_dtoa_r+0xa90>
8000a7aa:	2f f0       	sub	r0,-1
8000a7ac:	c0 c8       	rjmp	8000a7c4 <_dtoa_r+0xa98>
8000a7ae:	58 06       	cp.w	r6,0
8000a7b0:	e0 8a 00 0c 	brle	8000a7c8 <_dtoa_r+0xa9c>
8000a7b4:	40 26       	lddsp	r6,sp[0x8]
8000a7b6:	e0 40 00 39 	cp.w	r0,57
8000a7ba:	c0 41       	brne	8000a7c2 <_dtoa_r+0xa96>
8000a7bc:	33 98       	mov	r8,57
8000a7be:	0a c8       	st.b	r5++,r8
8000a7c0:	c6 78       	rjmp	8000a88e <_dtoa_r+0xb62>
8000a7c2:	2f f0       	sub	r0,-1
8000a7c4:	0a c0       	st.b	r5++,r0
8000a7c6:	c7 58       	rjmp	8000a8b0 <_dtoa_r+0xb84>
8000a7c8:	0a c0       	st.b	r5++,r0
8000a7ca:	40 9a       	lddsp	r10,sp[0x24]
8000a7cc:	40 e9       	lddsp	r9,sp[0x38]
8000a7ce:	12 3a       	cp.w	r10,r9
8000a7d0:	c4 30       	breq	8000a856 <_dtoa_r+0xb2a>
8000a7d2:	06 9b       	mov	r11,r3
8000a7d4:	30 09       	mov	r9,0
8000a7d6:	30 aa       	mov	r10,10
8000a7d8:	0e 9c       	mov	r12,r7
8000a7da:	e0 a0 07 37 	rcall	8000b648 <__multadd>
8000a7de:	40 48       	lddsp	r8,sp[0x10]
8000a7e0:	18 93       	mov	r3,r12
8000a7e2:	08 38       	cp.w	r8,r4
8000a7e4:	c0 91       	brne	8000a7f6 <_dtoa_r+0xaca>
8000a7e6:	10 9b       	mov	r11,r8
8000a7e8:	30 09       	mov	r9,0
8000a7ea:	30 aa       	mov	r10,10
8000a7ec:	0e 9c       	mov	r12,r7
8000a7ee:	e0 a0 07 2d 	rcall	8000b648 <__multadd>
8000a7f2:	50 4c       	stdsp	sp[0x10],r12
8000a7f4:	c0 e8       	rjmp	8000a810 <_dtoa_r+0xae4>
8000a7f6:	40 4b       	lddsp	r11,sp[0x10]
8000a7f8:	30 09       	mov	r9,0
8000a7fa:	30 aa       	mov	r10,10
8000a7fc:	0e 9c       	mov	r12,r7
8000a7fe:	e0 a0 07 25 	rcall	8000b648 <__multadd>
8000a802:	08 9b       	mov	r11,r4
8000a804:	50 4c       	stdsp	sp[0x10],r12
8000a806:	30 09       	mov	r9,0
8000a808:	30 aa       	mov	r10,10
8000a80a:	0e 9c       	mov	r12,r7
8000a80c:	e0 a0 07 1e 	rcall	8000b648 <__multadd>
8000a810:	18 94       	mov	r4,r12
8000a812:	40 9c       	lddsp	r12,sp[0x24]
8000a814:	2f fc       	sub	r12,-1
8000a816:	50 9c       	stdsp	sp[0x24],r12
8000a818:	c7 9b       	rjmp	8000a70a <_dtoa_r+0x9de>
8000a81a:	30 18       	mov	r8,1
8000a81c:	06 90       	mov	r0,r3
8000a81e:	40 85       	lddsp	r5,sp[0x20]
8000a820:	08 93       	mov	r3,r4
8000a822:	0c 94       	mov	r4,r6
8000a824:	10 96       	mov	r6,r8
8000a826:	04 9b       	mov	r11,r2
8000a828:	00 9c       	mov	r12,r0
8000a82a:	fe b0 f9 f1 	rcall	80009c0c <quorem>
8000a82e:	2d 0c       	sub	r12,-48
8000a830:	0a cc       	st.b	r5++,r12
8000a832:	02 36       	cp.w	r6,r1
8000a834:	c0 a4       	brge	8000a848 <_dtoa_r+0xb1c>
8000a836:	00 9b       	mov	r11,r0
8000a838:	30 09       	mov	r9,0
8000a83a:	30 aa       	mov	r10,10
8000a83c:	0e 9c       	mov	r12,r7
8000a83e:	2f f6       	sub	r6,-1
8000a840:	e0 a0 07 04 	rcall	8000b648 <__multadd>
8000a844:	18 90       	mov	r0,r12
8000a846:	cf 0b       	rjmp	8000a826 <_dtoa_r+0xafa>
8000a848:	08 96       	mov	r6,r4
8000a84a:	30 0b       	mov	r11,0
8000a84c:	06 94       	mov	r4,r3
8000a84e:	50 4b       	stdsp	sp[0x10],r11
8000a850:	00 93       	mov	r3,r0
8000a852:	18 90       	mov	r0,r12
8000a854:	c0 28       	rjmp	8000a858 <_dtoa_r+0xb2c>
8000a856:	40 26       	lddsp	r6,sp[0x8]
8000a858:	06 9b       	mov	r11,r3
8000a85a:	30 1a       	mov	r10,1
8000a85c:	0e 9c       	mov	r12,r7
8000a85e:	e0 a0 06 29 	rcall	8000b4b0 <__lshift>
8000a862:	04 9b       	mov	r11,r2
8000a864:	18 93       	mov	r3,r12
8000a866:	e0 a0 05 02 	rcall	8000b26a <__mcmp>
8000a86a:	e0 89 00 12 	brgt	8000a88e <_dtoa_r+0xb62>
8000a86e:	c1 b1       	brne	8000a8a4 <_dtoa_r+0xb78>
8000a870:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a874:	c0 d1       	brne	8000a88e <_dtoa_r+0xb62>
8000a876:	c1 78       	rjmp	8000a8a4 <_dtoa_r+0xb78>
8000a878:	40 89       	lddsp	r9,sp[0x20]
8000a87a:	12 38       	cp.w	r8,r9
8000a87c:	c0 30       	breq	8000a882 <_dtoa_r+0xb56>
8000a87e:	10 95       	mov	r5,r8
8000a880:	c0 88       	rjmp	8000a890 <_dtoa_r+0xb64>
8000a882:	2f f6       	sub	r6,-1
8000a884:	50 66       	stdsp	sp[0x18],r6
8000a886:	33 18       	mov	r8,49
8000a888:	40 8c       	lddsp	r12,sp[0x20]
8000a88a:	b8 88       	st.b	r12[0x0],r8
8000a88c:	c1 38       	rjmp	8000a8b2 <_dtoa_r+0xb86>
8000a88e:	33 9a       	mov	r10,57
8000a890:	0a 98       	mov	r8,r5
8000a892:	11 79       	ld.ub	r9,--r8
8000a894:	f4 09 18 00 	cp.b	r9,r10
8000a898:	cf 00       	breq	8000a878 <_dtoa_r+0xb4c>
8000a89a:	2f f9       	sub	r9,-1
8000a89c:	b0 89       	st.b	r8[0x0],r9
8000a89e:	c0 98       	rjmp	8000a8b0 <_dtoa_r+0xb84>
8000a8a0:	10 95       	mov	r5,r8
8000a8a2:	c0 28       	rjmp	8000a8a6 <_dtoa_r+0xb7a>
8000a8a4:	33 09       	mov	r9,48
8000a8a6:	0a 98       	mov	r8,r5
8000a8a8:	11 7a       	ld.ub	r10,--r8
8000a8aa:	f2 0a 18 00 	cp.b	r10,r9
8000a8ae:	cf 90       	breq	8000a8a0 <_dtoa_r+0xb74>
8000a8b0:	50 66       	stdsp	sp[0x18],r6
8000a8b2:	04 9b       	mov	r11,r2
8000a8b4:	0e 9c       	mov	r12,r7
8000a8b6:	e0 a0 04 f3 	rcall	8000b29c <_Bfree>
8000a8ba:	58 04       	cp.w	r4,0
8000a8bc:	c1 20       	breq	8000a8e0 <_dtoa_r+0xbb4>
8000a8be:	40 4b       	lddsp	r11,sp[0x10]
8000a8c0:	08 3b       	cp.w	r11,r4
8000a8c2:	5f 19       	srne	r9
8000a8c4:	58 0b       	cp.w	r11,0
8000a8c6:	5f 18       	srne	r8
8000a8c8:	f3 e8 00 08 	and	r8,r9,r8
8000a8cc:	c0 40       	breq	8000a8d4 <_dtoa_r+0xba8>
8000a8ce:	0e 9c       	mov	r12,r7
8000a8d0:	e0 a0 04 e6 	rcall	8000b29c <_Bfree>
8000a8d4:	08 9b       	mov	r11,r4
8000a8d6:	0e 9c       	mov	r12,r7
8000a8d8:	e0 a0 04 e2 	rcall	8000b29c <_Bfree>
8000a8dc:	c0 28       	rjmp	8000a8e0 <_dtoa_r+0xbb4>
8000a8de:	50 66       	stdsp	sp[0x18],r6
8000a8e0:	0e 9c       	mov	r12,r7
8000a8e2:	06 9b       	mov	r11,r3
8000a8e4:	e0 a0 04 dc 	rcall	8000b29c <_Bfree>
8000a8e8:	30 08       	mov	r8,0
8000a8ea:	aa 88       	st.b	r5[0x0],r8
8000a8ec:	40 68       	lddsp	r8,sp[0x18]
8000a8ee:	41 5a       	lddsp	r10,sp[0x54]
8000a8f0:	2f f8       	sub	r8,-1
8000a8f2:	41 29       	lddsp	r9,sp[0x48]
8000a8f4:	95 08       	st.w	r10[0x0],r8
8000a8f6:	40 8c       	lddsp	r12,sp[0x20]
8000a8f8:	58 09       	cp.w	r9,0
8000a8fa:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a8fe:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a902:	2e 6d       	sub	sp,-104
8000a904:	d8 32       	popm	r0-r7,pc
8000a906:	d7 03       	nop

8000a908 <__errno>:
8000a908:	e0 68 0a 3c 	mov	r8,2620
8000a90c:	70 0c       	ld.w	r12,r8[0x0]
8000a90e:	2f 4c       	sub	r12,-12
8000a910:	5e fc       	retal	r12
8000a912:	d7 03       	nop

8000a914 <_fflush_r>:
8000a914:	d4 21       	pushm	r4-r7,lr
8000a916:	16 97       	mov	r7,r11
8000a918:	18 96       	mov	r6,r12
8000a91a:	76 48       	ld.w	r8,r11[0x10]
8000a91c:	58 08       	cp.w	r8,0
8000a91e:	c7 f0       	breq	8000aa1c <_fflush_r+0x108>
8000a920:	58 0c       	cp.w	r12,0
8000a922:	c0 50       	breq	8000a92c <_fflush_r+0x18>
8000a924:	78 68       	ld.w	r8,r12[0x18]
8000a926:	58 08       	cp.w	r8,0
8000a928:	c0 21       	brne	8000a92c <_fflush_r+0x18>
8000a92a:	cc dc       	rcall	8000aac4 <__sinit>
8000a92c:	fe c8 ce e8 	sub	r8,pc,-12568
8000a930:	10 37       	cp.w	r7,r8
8000a932:	c0 31       	brne	8000a938 <_fflush_r+0x24>
8000a934:	6c 07       	ld.w	r7,r6[0x0]
8000a936:	c0 c8       	rjmp	8000a94e <_fflush_r+0x3a>
8000a938:	fe c8 ce d4 	sub	r8,pc,-12588
8000a93c:	10 37       	cp.w	r7,r8
8000a93e:	c0 31       	brne	8000a944 <_fflush_r+0x30>
8000a940:	6c 17       	ld.w	r7,r6[0x4]
8000a942:	c0 68       	rjmp	8000a94e <_fflush_r+0x3a>
8000a944:	fe c8 ce c0 	sub	r8,pc,-12608
8000a948:	10 37       	cp.w	r7,r8
8000a94a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a94e:	8e 6a       	ld.sh	r10,r7[0xc]
8000a950:	14 98       	mov	r8,r10
8000a952:	ed ba 00 03 	bld	r10,0x3
8000a956:	c4 20       	breq	8000a9da <_fflush_r+0xc6>
8000a958:	ab ba       	sbr	r10,0xb
8000a95a:	ae 6a       	st.h	r7[0xc],r10
8000a95c:	6e 18       	ld.w	r8,r7[0x4]
8000a95e:	58 08       	cp.w	r8,0
8000a960:	e0 89 00 06 	brgt	8000a96c <_fflush_r+0x58>
8000a964:	6f 08       	ld.w	r8,r7[0x40]
8000a966:	58 08       	cp.w	r8,0
8000a968:	e0 8a 00 5a 	brle	8000aa1c <_fflush_r+0x108>
8000a96c:	6e b8       	ld.w	r8,r7[0x2c]
8000a96e:	58 08       	cp.w	r8,0
8000a970:	c5 60       	breq	8000aa1c <_fflush_r+0x108>
8000a972:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a976:	c0 30       	breq	8000a97c <_fflush_r+0x68>
8000a978:	6f 55       	ld.w	r5,r7[0x54]
8000a97a:	c0 f8       	rjmp	8000a998 <_fflush_r+0x84>
8000a97c:	30 19       	mov	r9,1
8000a97e:	6e 8b       	ld.w	r11,r7[0x20]
8000a980:	0c 9c       	mov	r12,r6
8000a982:	5d 18       	icall	r8
8000a984:	18 95       	mov	r5,r12
8000a986:	5b fc       	cp.w	r12,-1
8000a988:	c0 81       	brne	8000a998 <_fflush_r+0x84>
8000a98a:	6c 38       	ld.w	r8,r6[0xc]
8000a98c:	59 d8       	cp.w	r8,29
8000a98e:	c4 70       	breq	8000aa1c <_fflush_r+0x108>
8000a990:	8e 68       	ld.sh	r8,r7[0xc]
8000a992:	a7 a8       	sbr	r8,0x6
8000a994:	ae 68       	st.h	r7[0xc],r8
8000a996:	d8 22       	popm	r4-r7,pc
8000a998:	8e 68       	ld.sh	r8,r7[0xc]
8000a99a:	ed b8 00 02 	bld	r8,0x2
8000a99e:	c0 91       	brne	8000a9b0 <_fflush_r+0x9c>
8000a9a0:	6e 18       	ld.w	r8,r7[0x4]
8000a9a2:	10 15       	sub	r5,r8
8000a9a4:	6e d8       	ld.w	r8,r7[0x34]
8000a9a6:	58 08       	cp.w	r8,0
8000a9a8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a9ac:	eb d8 e1 15 	subne	r5,r5,r8
8000a9b0:	6e b8       	ld.w	r8,r7[0x2c]
8000a9b2:	0c 9c       	mov	r12,r6
8000a9b4:	30 09       	mov	r9,0
8000a9b6:	0a 9a       	mov	r10,r5
8000a9b8:	6e 8b       	ld.w	r11,r7[0x20]
8000a9ba:	5d 18       	icall	r8
8000a9bc:	8e 68       	ld.sh	r8,r7[0xc]
8000a9be:	0a 3c       	cp.w	r12,r5
8000a9c0:	c2 61       	brne	8000aa0c <_fflush_r+0xf8>
8000a9c2:	ab d8       	cbr	r8,0xb
8000a9c4:	30 0c       	mov	r12,0
8000a9c6:	6e 49       	ld.w	r9,r7[0x10]
8000a9c8:	ae 68       	st.h	r7[0xc],r8
8000a9ca:	8f 1c       	st.w	r7[0x4],r12
8000a9cc:	8f 09       	st.w	r7[0x0],r9
8000a9ce:	ed b8 00 0c 	bld	r8,0xc
8000a9d2:	c2 51       	brne	8000aa1c <_fflush_r+0x108>
8000a9d4:	ef 45 00 54 	st.w	r7[84],r5
8000a9d8:	d8 22       	popm	r4-r7,pc
8000a9da:	6e 45       	ld.w	r5,r7[0x10]
8000a9dc:	58 05       	cp.w	r5,0
8000a9de:	c1 f0       	breq	8000aa1c <_fflush_r+0x108>
8000a9e0:	6e 04       	ld.w	r4,r7[0x0]
8000a9e2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a9e6:	8f 05       	st.w	r7[0x0],r5
8000a9e8:	f9 b8 01 00 	movne	r8,0
8000a9ec:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a9f0:	0a 14       	sub	r4,r5
8000a9f2:	8f 28       	st.w	r7[0x8],r8
8000a9f4:	c1 18       	rjmp	8000aa16 <_fflush_r+0x102>
8000a9f6:	08 99       	mov	r9,r4
8000a9f8:	0a 9a       	mov	r10,r5
8000a9fa:	6e a8       	ld.w	r8,r7[0x28]
8000a9fc:	6e 8b       	ld.w	r11,r7[0x20]
8000a9fe:	0c 9c       	mov	r12,r6
8000aa00:	5d 18       	icall	r8
8000aa02:	18 14       	sub	r4,r12
8000aa04:	58 0c       	cp.w	r12,0
8000aa06:	e0 89 00 07 	brgt	8000aa14 <_fflush_r+0x100>
8000aa0a:	8e 68       	ld.sh	r8,r7[0xc]
8000aa0c:	a7 a8       	sbr	r8,0x6
8000aa0e:	3f fc       	mov	r12,-1
8000aa10:	ae 68       	st.h	r7[0xc],r8
8000aa12:	d8 22       	popm	r4-r7,pc
8000aa14:	18 05       	add	r5,r12
8000aa16:	58 04       	cp.w	r4,0
8000aa18:	fe 99 ff ef 	brgt	8000a9f6 <_fflush_r+0xe2>
8000aa1c:	d8 2a       	popm	r4-r7,pc,r12=0
8000aa1e:	d7 03       	nop

8000aa20 <__sfp_lock_acquire>:
8000aa20:	5e fc       	retal	r12

8000aa22 <__sfp_lock_release>:
8000aa22:	5e fc       	retal	r12

8000aa24 <_cleanup_r>:
8000aa24:	d4 01       	pushm	lr
8000aa26:	fe cb f0 c6 	sub	r11,pc,-3898
8000aa2a:	e0 a0 02 f7 	rcall	8000b018 <_fwalk>
8000aa2e:	d8 02       	popm	pc

8000aa30 <__sfmoreglue>:
8000aa30:	d4 21       	pushm	r4-r7,lr
8000aa32:	16 95       	mov	r5,r11
8000aa34:	f6 06 10 5c 	mul	r6,r11,92
8000aa38:	ec cb ff f4 	sub	r11,r6,-12
8000aa3c:	fe b0 e2 6a 	rcall	80006f10 <_malloc_r>
8000aa40:	18 97       	mov	r7,r12
8000aa42:	c0 90       	breq	8000aa54 <__sfmoreglue+0x24>
8000aa44:	99 15       	st.w	r12[0x4],r5
8000aa46:	30 0b       	mov	r11,0
8000aa48:	2f 4c       	sub	r12,-12
8000aa4a:	0c 9a       	mov	r10,r6
8000aa4c:	8f 2c       	st.w	r7[0x8],r12
8000aa4e:	8f 0b       	st.w	r7[0x0],r11
8000aa50:	fe b0 e5 33 	rcall	800074b6 <memset>
8000aa54:	0e 9c       	mov	r12,r7
8000aa56:	d8 22       	popm	r4-r7,pc

8000aa58 <__sfp>:
8000aa58:	d4 21       	pushm	r4-r7,lr
8000aa5a:	fe c8 cf b2 	sub	r8,pc,-12366
8000aa5e:	18 96       	mov	r6,r12
8000aa60:	70 07       	ld.w	r7,r8[0x0]
8000aa62:	6e 68       	ld.w	r8,r7[0x18]
8000aa64:	58 08       	cp.w	r8,0
8000aa66:	c0 31       	brne	8000aa6c <__sfp+0x14>
8000aa68:	0e 9c       	mov	r12,r7
8000aa6a:	c2 dc       	rcall	8000aac4 <__sinit>
8000aa6c:	ee c7 ff 28 	sub	r7,r7,-216
8000aa70:	30 05       	mov	r5,0
8000aa72:	6e 2c       	ld.w	r12,r7[0x8]
8000aa74:	6e 18       	ld.w	r8,r7[0x4]
8000aa76:	c0 68       	rjmp	8000aa82 <__sfp+0x2a>
8000aa78:	98 69       	ld.sh	r9,r12[0xc]
8000aa7a:	ea 09 19 00 	cp.h	r9,r5
8000aa7e:	c1 10       	breq	8000aaa0 <__sfp+0x48>
8000aa80:	2a 4c       	sub	r12,-92
8000aa82:	20 18       	sub	r8,1
8000aa84:	cf a7       	brpl	8000aa78 <__sfp+0x20>
8000aa86:	6e 08       	ld.w	r8,r7[0x0]
8000aa88:	58 08       	cp.w	r8,0
8000aa8a:	c0 61       	brne	8000aa96 <__sfp+0x3e>
8000aa8c:	30 4b       	mov	r11,4
8000aa8e:	0c 9c       	mov	r12,r6
8000aa90:	cd 0f       	rcall	8000aa30 <__sfmoreglue>
8000aa92:	8f 0c       	st.w	r7[0x0],r12
8000aa94:	c0 30       	breq	8000aa9a <__sfp+0x42>
8000aa96:	6e 07       	ld.w	r7,r7[0x0]
8000aa98:	ce db       	rjmp	8000aa72 <__sfp+0x1a>
8000aa9a:	30 c8       	mov	r8,12
8000aa9c:	8d 38       	st.w	r6[0xc],r8
8000aa9e:	d8 22       	popm	r4-r7,pc
8000aaa0:	30 08       	mov	r8,0
8000aaa2:	f9 48 00 4c 	st.w	r12[76],r8
8000aaa6:	99 08       	st.w	r12[0x0],r8
8000aaa8:	99 28       	st.w	r12[0x8],r8
8000aaaa:	99 18       	st.w	r12[0x4],r8
8000aaac:	99 48       	st.w	r12[0x10],r8
8000aaae:	99 58       	st.w	r12[0x14],r8
8000aab0:	99 68       	st.w	r12[0x18],r8
8000aab2:	99 d8       	st.w	r12[0x34],r8
8000aab4:	99 e8       	st.w	r12[0x38],r8
8000aab6:	f9 48 00 48 	st.w	r12[72],r8
8000aaba:	3f f8       	mov	r8,-1
8000aabc:	b8 78       	st.h	r12[0xe],r8
8000aabe:	30 18       	mov	r8,1
8000aac0:	b8 68       	st.h	r12[0xc],r8
8000aac2:	d8 22       	popm	r4-r7,pc

8000aac4 <__sinit>:
8000aac4:	d4 21       	pushm	r4-r7,lr
8000aac6:	18 96       	mov	r6,r12
8000aac8:	78 67       	ld.w	r7,r12[0x18]
8000aaca:	58 07       	cp.w	r7,0
8000aacc:	c4 91       	brne	8000ab5e <__sinit+0x9a>
8000aace:	fe c8 00 aa 	sub	r8,pc,170
8000aad2:	30 15       	mov	r5,1
8000aad4:	99 a8       	st.w	r12[0x28],r8
8000aad6:	f9 47 00 d8 	st.w	r12[216],r7
8000aada:	f9 47 00 dc 	st.w	r12[220],r7
8000aade:	f9 47 00 e0 	st.w	r12[224],r7
8000aae2:	99 65       	st.w	r12[0x18],r5
8000aae4:	cb af       	rcall	8000aa58 <__sfp>
8000aae6:	8d 0c       	st.w	r6[0x0],r12
8000aae8:	0c 9c       	mov	r12,r6
8000aaea:	cb 7f       	rcall	8000aa58 <__sfp>
8000aaec:	8d 1c       	st.w	r6[0x4],r12
8000aaee:	0c 9c       	mov	r12,r6
8000aaf0:	cb 4f       	rcall	8000aa58 <__sfp>
8000aaf2:	6c 09       	ld.w	r9,r6[0x0]
8000aaf4:	30 48       	mov	r8,4
8000aaf6:	93 07       	st.w	r9[0x0],r7
8000aaf8:	b2 68       	st.h	r9[0xc],r8
8000aafa:	93 17       	st.w	r9[0x4],r7
8000aafc:	93 27       	st.w	r9[0x8],r7
8000aafe:	6c 18       	ld.w	r8,r6[0x4]
8000ab00:	b2 77       	st.h	r9[0xe],r7
8000ab02:	93 47       	st.w	r9[0x10],r7
8000ab04:	93 57       	st.w	r9[0x14],r7
8000ab06:	93 67       	st.w	r9[0x18],r7
8000ab08:	93 89       	st.w	r9[0x20],r9
8000ab0a:	91 07       	st.w	r8[0x0],r7
8000ab0c:	91 17       	st.w	r8[0x4],r7
8000ab0e:	91 27       	st.w	r8[0x8],r7
8000ab10:	fe ce f3 24 	sub	lr,pc,-3292
8000ab14:	fe cb f3 54 	sub	r11,pc,-3244
8000ab18:	93 9e       	st.w	r9[0x24],lr
8000ab1a:	93 ab       	st.w	r9[0x28],r11
8000ab1c:	fe ca f3 7c 	sub	r10,pc,-3204
8000ab20:	fe c4 f3 88 	sub	r4,pc,-3192
8000ab24:	93 ba       	st.w	r9[0x2c],r10
8000ab26:	93 c4       	st.w	r9[0x30],r4
8000ab28:	30 99       	mov	r9,9
8000ab2a:	b0 69       	st.h	r8[0xc],r9
8000ab2c:	b0 75       	st.h	r8[0xe],r5
8000ab2e:	91 c4       	st.w	r8[0x30],r4
8000ab30:	91 47       	st.w	r8[0x10],r7
8000ab32:	91 57       	st.w	r8[0x14],r7
8000ab34:	91 67       	st.w	r8[0x18],r7
8000ab36:	91 88       	st.w	r8[0x20],r8
8000ab38:	91 9e       	st.w	r8[0x24],lr
8000ab3a:	91 ab       	st.w	r8[0x28],r11
8000ab3c:	91 ba       	st.w	r8[0x2c],r10
8000ab3e:	8d 2c       	st.w	r6[0x8],r12
8000ab40:	31 28       	mov	r8,18
8000ab42:	99 07       	st.w	r12[0x0],r7
8000ab44:	b8 68       	st.h	r12[0xc],r8
8000ab46:	99 17       	st.w	r12[0x4],r7
8000ab48:	99 27       	st.w	r12[0x8],r7
8000ab4a:	30 28       	mov	r8,2
8000ab4c:	b8 78       	st.h	r12[0xe],r8
8000ab4e:	99 c4       	st.w	r12[0x30],r4
8000ab50:	99 67       	st.w	r12[0x18],r7
8000ab52:	99 9e       	st.w	r12[0x24],lr
8000ab54:	99 ab       	st.w	r12[0x28],r11
8000ab56:	99 ba       	st.w	r12[0x2c],r10
8000ab58:	99 47       	st.w	r12[0x10],r7
8000ab5a:	99 57       	st.w	r12[0x14],r7
8000ab5c:	99 8c       	st.w	r12[0x20],r12
8000ab5e:	d8 22       	popm	r4-r7,pc

8000ab60 <_malloc_trim_r>:
8000ab60:	d4 21       	pushm	r4-r7,lr
8000ab62:	16 95       	mov	r5,r11
8000ab64:	18 97       	mov	r7,r12
8000ab66:	fe b0 d7 53 	rcall	80005a0c <__malloc_lock>
8000ab6a:	e0 64 05 3c 	mov	r4,1340
8000ab6e:	68 28       	ld.w	r8,r4[0x8]
8000ab70:	70 16       	ld.w	r6,r8[0x4]
8000ab72:	e0 16 ff fc 	andl	r6,0xfffc
8000ab76:	ec c8 ff 91 	sub	r8,r6,-111
8000ab7a:	f0 05 01 05 	sub	r5,r8,r5
8000ab7e:	e0 15 ff 80 	andl	r5,0xff80
8000ab82:	ea c5 00 80 	sub	r5,r5,128
8000ab86:	e0 45 00 7f 	cp.w	r5,127
8000ab8a:	e0 8a 00 25 	brle	8000abd4 <_malloc_trim_r+0x74>
8000ab8e:	30 0b       	mov	r11,0
8000ab90:	0e 9c       	mov	r12,r7
8000ab92:	fe b0 e5 f9 	rcall	80007784 <_sbrk_r>
8000ab96:	68 28       	ld.w	r8,r4[0x8]
8000ab98:	0c 08       	add	r8,r6
8000ab9a:	10 3c       	cp.w	r12,r8
8000ab9c:	c1 c1       	brne	8000abd4 <_malloc_trim_r+0x74>
8000ab9e:	ea 0b 11 00 	rsub	r11,r5,0
8000aba2:	0e 9c       	mov	r12,r7
8000aba4:	fe b0 e5 f0 	rcall	80007784 <_sbrk_r>
8000aba8:	5b fc       	cp.w	r12,-1
8000abaa:	c1 91       	brne	8000abdc <_malloc_trim_r+0x7c>
8000abac:	30 0b       	mov	r11,0
8000abae:	0e 9c       	mov	r12,r7
8000abb0:	fe b0 e5 ea 	rcall	80007784 <_sbrk_r>
8000abb4:	68 28       	ld.w	r8,r4[0x8]
8000abb6:	f8 08 01 09 	sub	r9,r12,r8
8000abba:	58 f9       	cp.w	r9,15
8000abbc:	e0 8a 00 0c 	brle	8000abd4 <_malloc_trim_r+0x74>
8000abc0:	a1 a9       	sbr	r9,0x0
8000abc2:	91 19       	st.w	r8[0x4],r9
8000abc4:	e0 68 09 48 	mov	r8,2376
8000abc8:	70 09       	ld.w	r9,r8[0x0]
8000abca:	e0 68 0d 50 	mov	r8,3408
8000abce:	f8 09 01 09 	sub	r9,r12,r9
8000abd2:	91 09       	st.w	r8[0x0],r9
8000abd4:	0e 9c       	mov	r12,r7
8000abd6:	fe b0 d7 21 	rcall	80005a18 <__malloc_unlock>
8000abda:	d8 2a       	popm	r4-r7,pc,r12=0
8000abdc:	68 28       	ld.w	r8,r4[0x8]
8000abde:	0a 16       	sub	r6,r5
8000abe0:	a1 a6       	sbr	r6,0x0
8000abe2:	91 16       	st.w	r8[0x4],r6
8000abe4:	e0 68 0d 50 	mov	r8,3408
8000abe8:	70 09       	ld.w	r9,r8[0x0]
8000abea:	0a 19       	sub	r9,r5
8000abec:	0e 9c       	mov	r12,r7
8000abee:	91 09       	st.w	r8[0x0],r9
8000abf0:	fe b0 d7 14 	rcall	80005a18 <__malloc_unlock>
8000abf4:	da 2a       	popm	r4-r7,pc,r12=1
8000abf6:	d7 03       	nop

8000abf8 <_free_r>:
8000abf8:	d4 21       	pushm	r4-r7,lr
8000abfa:	16 96       	mov	r6,r11
8000abfc:	18 97       	mov	r7,r12
8000abfe:	58 0b       	cp.w	r11,0
8000ac00:	e0 80 00 c0 	breq	8000ad80 <_free_r+0x188>
8000ac04:	fe b0 d7 04 	rcall	80005a0c <__malloc_lock>
8000ac08:	20 86       	sub	r6,8
8000ac0a:	e0 6a 05 3c 	mov	r10,1340
8000ac0e:	6c 18       	ld.w	r8,r6[0x4]
8000ac10:	74 2e       	ld.w	lr,r10[0x8]
8000ac12:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ac16:	a1 c8       	cbr	r8,0x0
8000ac18:	ec 08 00 09 	add	r9,r6,r8
8000ac1c:	72 1b       	ld.w	r11,r9[0x4]
8000ac1e:	e0 1b ff fc 	andl	r11,0xfffc
8000ac22:	1c 39       	cp.w	r9,lr
8000ac24:	c1 e1       	brne	8000ac60 <_free_r+0x68>
8000ac26:	f6 08 00 08 	add	r8,r11,r8
8000ac2a:	58 0c       	cp.w	r12,0
8000ac2c:	c0 81       	brne	8000ac3c <_free_r+0x44>
8000ac2e:	6c 09       	ld.w	r9,r6[0x0]
8000ac30:	12 16       	sub	r6,r9
8000ac32:	12 08       	add	r8,r9
8000ac34:	6c 3b       	ld.w	r11,r6[0xc]
8000ac36:	6c 29       	ld.w	r9,r6[0x8]
8000ac38:	97 29       	st.w	r11[0x8],r9
8000ac3a:	93 3b       	st.w	r9[0xc],r11
8000ac3c:	10 99       	mov	r9,r8
8000ac3e:	95 26       	st.w	r10[0x8],r6
8000ac40:	a1 a9       	sbr	r9,0x0
8000ac42:	8d 19       	st.w	r6[0x4],r9
8000ac44:	e0 69 09 44 	mov	r9,2372
8000ac48:	72 09       	ld.w	r9,r9[0x0]
8000ac4a:	12 38       	cp.w	r8,r9
8000ac4c:	c0 63       	brcs	8000ac58 <_free_r+0x60>
8000ac4e:	e0 68 0d 4c 	mov	r8,3404
8000ac52:	0e 9c       	mov	r12,r7
8000ac54:	70 0b       	ld.w	r11,r8[0x0]
8000ac56:	c8 5f       	rcall	8000ab60 <_malloc_trim_r>
8000ac58:	0e 9c       	mov	r12,r7
8000ac5a:	fe b0 d6 df 	rcall	80005a18 <__malloc_unlock>
8000ac5e:	d8 22       	popm	r4-r7,pc
8000ac60:	93 1b       	st.w	r9[0x4],r11
8000ac62:	58 0c       	cp.w	r12,0
8000ac64:	c0 30       	breq	8000ac6a <_free_r+0x72>
8000ac66:	30 0c       	mov	r12,0
8000ac68:	c1 08       	rjmp	8000ac88 <_free_r+0x90>
8000ac6a:	6c 0e       	ld.w	lr,r6[0x0]
8000ac6c:	f4 c5 ff f8 	sub	r5,r10,-8
8000ac70:	1c 16       	sub	r6,lr
8000ac72:	1c 08       	add	r8,lr
8000ac74:	6c 2e       	ld.w	lr,r6[0x8]
8000ac76:	0a 3e       	cp.w	lr,r5
8000ac78:	f9 bc 00 01 	moveq	r12,1
8000ac7c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ac80:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ac84:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ac88:	f2 0b 00 0e 	add	lr,r9,r11
8000ac8c:	7c 1e       	ld.w	lr,lr[0x4]
8000ac8e:	ed be 00 00 	bld	lr,0x0
8000ac92:	c1 40       	breq	8000acba <_free_r+0xc2>
8000ac94:	16 08       	add	r8,r11
8000ac96:	58 0c       	cp.w	r12,0
8000ac98:	c0 d1       	brne	8000acb2 <_free_r+0xba>
8000ac9a:	e0 6e 05 3c 	mov	lr,1340
8000ac9e:	72 2b       	ld.w	r11,r9[0x8]
8000aca0:	2f 8e       	sub	lr,-8
8000aca2:	1c 3b       	cp.w	r11,lr
8000aca4:	c0 71       	brne	8000acb2 <_free_r+0xba>
8000aca6:	97 36       	st.w	r11[0xc],r6
8000aca8:	97 26       	st.w	r11[0x8],r6
8000acaa:	8d 2b       	st.w	r6[0x8],r11
8000acac:	8d 3b       	st.w	r6[0xc],r11
8000acae:	30 1c       	mov	r12,1
8000acb0:	c0 58       	rjmp	8000acba <_free_r+0xc2>
8000acb2:	72 2b       	ld.w	r11,r9[0x8]
8000acb4:	72 39       	ld.w	r9,r9[0xc]
8000acb6:	93 2b       	st.w	r9[0x8],r11
8000acb8:	97 39       	st.w	r11[0xc],r9
8000acba:	10 99       	mov	r9,r8
8000acbc:	ec 08 09 08 	st.w	r6[r8],r8
8000acc0:	a1 a9       	sbr	r9,0x0
8000acc2:	8d 19       	st.w	r6[0x4],r9
8000acc4:	58 0c       	cp.w	r12,0
8000acc6:	c5 a1       	brne	8000ad7a <_free_r+0x182>
8000acc8:	e0 48 01 ff 	cp.w	r8,511
8000accc:	e0 8b 00 13 	brhi	8000acf2 <_free_r+0xfa>
8000acd0:	a3 98       	lsr	r8,0x3
8000acd2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000acd6:	72 2b       	ld.w	r11,r9[0x8]
8000acd8:	8d 39       	st.w	r6[0xc],r9
8000acda:	8d 2b       	st.w	r6[0x8],r11
8000acdc:	97 36       	st.w	r11[0xc],r6
8000acde:	93 26       	st.w	r9[0x8],r6
8000ace0:	a3 48       	asr	r8,0x2
8000ace2:	74 19       	ld.w	r9,r10[0x4]
8000ace4:	30 1b       	mov	r11,1
8000ace6:	f6 08 09 48 	lsl	r8,r11,r8
8000acea:	f3 e8 10 08 	or	r8,r9,r8
8000acee:	95 18       	st.w	r10[0x4],r8
8000acf0:	c4 58       	rjmp	8000ad7a <_free_r+0x182>
8000acf2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000acf6:	58 4b       	cp.w	r11,4
8000acf8:	e0 8b 00 06 	brhi	8000ad04 <_free_r+0x10c>
8000acfc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ad00:	2c 8b       	sub	r11,-56
8000ad02:	c2 08       	rjmp	8000ad42 <_free_r+0x14a>
8000ad04:	59 4b       	cp.w	r11,20
8000ad06:	e0 8b 00 04 	brhi	8000ad0e <_free_r+0x116>
8000ad0a:	2a 5b       	sub	r11,-91
8000ad0c:	c1 b8       	rjmp	8000ad42 <_free_r+0x14a>
8000ad0e:	e0 4b 00 54 	cp.w	r11,84
8000ad12:	e0 8b 00 06 	brhi	8000ad1e <_free_r+0x126>
8000ad16:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ad1a:	29 2b       	sub	r11,-110
8000ad1c:	c1 38       	rjmp	8000ad42 <_free_r+0x14a>
8000ad1e:	e0 4b 01 54 	cp.w	r11,340
8000ad22:	e0 8b 00 06 	brhi	8000ad2e <_free_r+0x136>
8000ad26:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ad2a:	28 9b       	sub	r11,-119
8000ad2c:	c0 b8       	rjmp	8000ad42 <_free_r+0x14a>
8000ad2e:	e0 4b 05 54 	cp.w	r11,1364
8000ad32:	e0 88 00 05 	brls	8000ad3c <_free_r+0x144>
8000ad36:	37 eb       	mov	r11,126
8000ad38:	c0 58       	rjmp	8000ad42 <_free_r+0x14a>
8000ad3a:	d7 03       	nop
8000ad3c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ad40:	28 4b       	sub	r11,-124
8000ad42:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ad46:	78 29       	ld.w	r9,r12[0x8]
8000ad48:	18 39       	cp.w	r9,r12
8000ad4a:	c0 e1       	brne	8000ad66 <_free_r+0x16e>
8000ad4c:	74 18       	ld.w	r8,r10[0x4]
8000ad4e:	a3 4b       	asr	r11,0x2
8000ad50:	30 1c       	mov	r12,1
8000ad52:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ad56:	f1 eb 10 0b 	or	r11,r8,r11
8000ad5a:	12 98       	mov	r8,r9
8000ad5c:	95 1b       	st.w	r10[0x4],r11
8000ad5e:	c0 a8       	rjmp	8000ad72 <_free_r+0x17a>
8000ad60:	72 29       	ld.w	r9,r9[0x8]
8000ad62:	18 39       	cp.w	r9,r12
8000ad64:	c0 60       	breq	8000ad70 <_free_r+0x178>
8000ad66:	72 1a       	ld.w	r10,r9[0x4]
8000ad68:	e0 1a ff fc 	andl	r10,0xfffc
8000ad6c:	14 38       	cp.w	r8,r10
8000ad6e:	cf 93       	brcs	8000ad60 <_free_r+0x168>
8000ad70:	72 38       	ld.w	r8,r9[0xc]
8000ad72:	8d 38       	st.w	r6[0xc],r8
8000ad74:	8d 29       	st.w	r6[0x8],r9
8000ad76:	93 36       	st.w	r9[0xc],r6
8000ad78:	91 26       	st.w	r8[0x8],r6
8000ad7a:	0e 9c       	mov	r12,r7
8000ad7c:	fe b0 d6 4e 	rcall	80005a18 <__malloc_unlock>
8000ad80:	d8 22       	popm	r4-r7,pc
8000ad82:	d7 03       	nop

8000ad84 <__sfvwrite_r>:
8000ad84:	d4 31       	pushm	r0-r7,lr
8000ad86:	20 3d       	sub	sp,12
8000ad88:	14 94       	mov	r4,r10
8000ad8a:	18 95       	mov	r5,r12
8000ad8c:	16 97       	mov	r7,r11
8000ad8e:	74 28       	ld.w	r8,r10[0x8]
8000ad90:	58 08       	cp.w	r8,0
8000ad92:	e0 80 01 40 	breq	8000b012 <__sfvwrite_r+0x28e>
8000ad96:	96 68       	ld.sh	r8,r11[0xc]
8000ad98:	ed b8 00 03 	bld	r8,0x3
8000ad9c:	c0 41       	brne	8000ada4 <__sfvwrite_r+0x20>
8000ad9e:	76 48       	ld.w	r8,r11[0x10]
8000ada0:	58 08       	cp.w	r8,0
8000ada2:	c0 c1       	brne	8000adba <__sfvwrite_r+0x36>
8000ada4:	0e 9b       	mov	r11,r7
8000ada6:	0a 9c       	mov	r12,r5
8000ada8:	fe b0 f6 c4 	rcall	80009b30 <__swsetup_r>
8000adac:	c0 70       	breq	8000adba <__sfvwrite_r+0x36>
8000adae:	8e 68       	ld.sh	r8,r7[0xc]
8000adb0:	a7 a8       	sbr	r8,0x6
8000adb2:	ae 68       	st.h	r7[0xc],r8
8000adb4:	30 98       	mov	r8,9
8000adb6:	8b 38       	st.w	r5[0xc],r8
8000adb8:	c2 b9       	rjmp	8000b00e <__sfvwrite_r+0x28a>
8000adba:	8e 63       	ld.sh	r3,r7[0xc]
8000adbc:	68 00       	ld.w	r0,r4[0x0]
8000adbe:	06 96       	mov	r6,r3
8000adc0:	e2 16 00 02 	andl	r6,0x2,COH
8000adc4:	c2 10       	breq	8000ae06 <__sfvwrite_r+0x82>
8000adc6:	30 03       	mov	r3,0
8000adc8:	e0 62 04 00 	mov	r2,1024
8000adcc:	06 96       	mov	r6,r3
8000adce:	c0 48       	rjmp	8000add6 <__sfvwrite_r+0x52>
8000add0:	60 03       	ld.w	r3,r0[0x0]
8000add2:	60 16       	ld.w	r6,r0[0x4]
8000add4:	2f 80       	sub	r0,-8
8000add6:	58 06       	cp.w	r6,0
8000add8:	cf c0       	breq	8000add0 <__sfvwrite_r+0x4c>
8000adda:	e0 46 04 00 	cp.w	r6,1024
8000adde:	ec 09 17 80 	movls	r9,r6
8000ade2:	e4 09 17 b0 	movhi	r9,r2
8000ade6:	06 9a       	mov	r10,r3
8000ade8:	6e a8       	ld.w	r8,r7[0x28]
8000adea:	6e 8b       	ld.w	r11,r7[0x20]
8000adec:	0a 9c       	mov	r12,r5
8000adee:	5d 18       	icall	r8
8000adf0:	18 16       	sub	r6,r12
8000adf2:	58 0c       	cp.w	r12,0
8000adf4:	e0 8a 01 0a 	brle	8000b008 <__sfvwrite_r+0x284>
8000adf8:	68 28       	ld.w	r8,r4[0x8]
8000adfa:	18 18       	sub	r8,r12
8000adfc:	89 28       	st.w	r4[0x8],r8
8000adfe:	e0 80 01 0a 	breq	8000b012 <__sfvwrite_r+0x28e>
8000ae02:	18 03       	add	r3,r12
8000ae04:	ce 9b       	rjmp	8000add6 <__sfvwrite_r+0x52>
8000ae06:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ae0a:	c0 70       	breq	8000ae18 <__sfvwrite_r+0x94>
8000ae0c:	50 06       	stdsp	sp[0x0],r6
8000ae0e:	0c 93       	mov	r3,r6
8000ae10:	0c 91       	mov	r1,r6
8000ae12:	50 15       	stdsp	sp[0x4],r5
8000ae14:	08 92       	mov	r2,r4
8000ae16:	c9 c8       	rjmp	8000af4e <__sfvwrite_r+0x1ca>
8000ae18:	06 96       	mov	r6,r3
8000ae1a:	08 91       	mov	r1,r4
8000ae1c:	c0 48       	rjmp	8000ae24 <__sfvwrite_r+0xa0>
8000ae1e:	60 03       	ld.w	r3,r0[0x0]
8000ae20:	60 16       	ld.w	r6,r0[0x4]
8000ae22:	2f 80       	sub	r0,-8
8000ae24:	58 06       	cp.w	r6,0
8000ae26:	cf c0       	breq	8000ae1e <__sfvwrite_r+0x9a>
8000ae28:	8e 68       	ld.sh	r8,r7[0xc]
8000ae2a:	6e 24       	ld.w	r4,r7[0x8]
8000ae2c:	10 99       	mov	r9,r8
8000ae2e:	e2 19 02 00 	andl	r9,0x200,COH
8000ae32:	c5 50       	breq	8000aedc <__sfvwrite_r+0x158>
8000ae34:	08 36       	cp.w	r6,r4
8000ae36:	c4 43       	brcs	8000aebe <__sfvwrite_r+0x13a>
8000ae38:	10 99       	mov	r9,r8
8000ae3a:	e2 19 04 80 	andl	r9,0x480,COH
8000ae3e:	c4 00       	breq	8000aebe <__sfvwrite_r+0x13a>
8000ae40:	6e 4b       	ld.w	r11,r7[0x10]
8000ae42:	6e 09       	ld.w	r9,r7[0x0]
8000ae44:	16 19       	sub	r9,r11
8000ae46:	50 09       	stdsp	sp[0x0],r9
8000ae48:	6e 59       	ld.w	r9,r7[0x14]
8000ae4a:	10 9c       	mov	r12,r8
8000ae4c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ae50:	30 28       	mov	r8,2
8000ae52:	f4 08 0c 08 	divs	r8,r10,r8
8000ae56:	fa e9 00 04 	st.d	sp[4],r8
8000ae5a:	10 94       	mov	r4,r8
8000ae5c:	40 09       	lddsp	r9,sp[0x0]
8000ae5e:	e2 1c 04 00 	andl	r12,0x400,COH
8000ae62:	2f f9       	sub	r9,-1
8000ae64:	0c 09       	add	r9,r6
8000ae66:	12 38       	cp.w	r8,r9
8000ae68:	f2 04 17 30 	movlo	r4,r9
8000ae6c:	58 0c       	cp.w	r12,0
8000ae6e:	c1 10       	breq	8000ae90 <__sfvwrite_r+0x10c>
8000ae70:	08 9b       	mov	r11,r4
8000ae72:	0a 9c       	mov	r12,r5
8000ae74:	fe b0 e0 4e 	rcall	80006f10 <_malloc_r>
8000ae78:	18 92       	mov	r2,r12
8000ae7a:	c1 40       	breq	8000aea2 <__sfvwrite_r+0x11e>
8000ae7c:	40 0a       	lddsp	r10,sp[0x0]
8000ae7e:	6e 4b       	ld.w	r11,r7[0x10]
8000ae80:	fe b0 e2 77 	rcall	8000736e <memcpy>
8000ae84:	8e 68       	ld.sh	r8,r7[0xc]
8000ae86:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ae8a:	a7 b8       	sbr	r8,0x7
8000ae8c:	ae 68       	st.h	r7[0xc],r8
8000ae8e:	c0 d8       	rjmp	8000aea8 <__sfvwrite_r+0x124>
8000ae90:	08 9a       	mov	r10,r4
8000ae92:	0a 9c       	mov	r12,r5
8000ae94:	fe b0 e3 18 	rcall	800074c4 <_realloc_r>
8000ae98:	18 92       	mov	r2,r12
8000ae9a:	c0 71       	brne	8000aea8 <__sfvwrite_r+0x124>
8000ae9c:	6e 4b       	ld.w	r11,r7[0x10]
8000ae9e:	0a 9c       	mov	r12,r5
8000aea0:	ca ce       	rcall	8000abf8 <_free_r>
8000aea2:	30 c8       	mov	r8,12
8000aea4:	8b 38       	st.w	r5[0xc],r8
8000aea6:	cb 18       	rjmp	8000b008 <__sfvwrite_r+0x284>
8000aea8:	40 0a       	lddsp	r10,sp[0x0]
8000aeaa:	40 09       	lddsp	r9,sp[0x0]
8000aeac:	e8 0a 01 0a 	sub	r10,r4,r10
8000aeb0:	e4 09 00 08 	add	r8,r2,r9
8000aeb4:	8f 54       	st.w	r7[0x14],r4
8000aeb6:	8f 2a       	st.w	r7[0x8],r10
8000aeb8:	8f 08       	st.w	r7[0x0],r8
8000aeba:	8f 42       	st.w	r7[0x10],r2
8000aebc:	0c 94       	mov	r4,r6
8000aebe:	08 36       	cp.w	r6,r4
8000aec0:	ec 04 17 30 	movlo	r4,r6
8000aec4:	06 9b       	mov	r11,r3
8000aec6:	08 9a       	mov	r10,r4
8000aec8:	6e 0c       	ld.w	r12,r7[0x0]
8000aeca:	c3 ad       	rcall	8000b13e <memmove>
8000aecc:	6e 08       	ld.w	r8,r7[0x0]
8000aece:	08 08       	add	r8,r4
8000aed0:	8f 08       	st.w	r7[0x0],r8
8000aed2:	6e 28       	ld.w	r8,r7[0x8]
8000aed4:	08 18       	sub	r8,r4
8000aed6:	0c 94       	mov	r4,r6
8000aed8:	8f 28       	st.w	r7[0x8],r8
8000aeda:	c2 e8       	rjmp	8000af36 <__sfvwrite_r+0x1b2>
8000aedc:	08 36       	cp.w	r6,r4
8000aede:	5f ba       	srhi	r10
8000aee0:	6e 0c       	ld.w	r12,r7[0x0]
8000aee2:	6e 48       	ld.w	r8,r7[0x10]
8000aee4:	10 3c       	cp.w	r12,r8
8000aee6:	5f b8       	srhi	r8
8000aee8:	f5 e8 00 08 	and	r8,r10,r8
8000aeec:	f2 08 18 00 	cp.b	r8,r9
8000aef0:	c0 d0       	breq	8000af0a <__sfvwrite_r+0x186>
8000aef2:	06 9b       	mov	r11,r3
8000aef4:	08 9a       	mov	r10,r4
8000aef6:	c2 4d       	rcall	8000b13e <memmove>
8000aef8:	6e 08       	ld.w	r8,r7[0x0]
8000aefa:	08 08       	add	r8,r4
8000aefc:	0e 9b       	mov	r11,r7
8000aefe:	8f 08       	st.w	r7[0x0],r8
8000af00:	0a 9c       	mov	r12,r5
8000af02:	fe b0 fd 09 	rcall	8000a914 <_fflush_r>
8000af06:	c1 80       	breq	8000af36 <__sfvwrite_r+0x1b2>
8000af08:	c8 08       	rjmp	8000b008 <__sfvwrite_r+0x284>
8000af0a:	6e 59       	ld.w	r9,r7[0x14]
8000af0c:	12 36       	cp.w	r6,r9
8000af0e:	c0 a3       	brcs	8000af22 <__sfvwrite_r+0x19e>
8000af10:	6e a8       	ld.w	r8,r7[0x28]
8000af12:	06 9a       	mov	r10,r3
8000af14:	6e 8b       	ld.w	r11,r7[0x20]
8000af16:	0a 9c       	mov	r12,r5
8000af18:	5d 18       	icall	r8
8000af1a:	18 94       	mov	r4,r12
8000af1c:	e0 89 00 0d 	brgt	8000af36 <__sfvwrite_r+0x1b2>
8000af20:	c7 48       	rjmp	8000b008 <__sfvwrite_r+0x284>
8000af22:	0c 9a       	mov	r10,r6
8000af24:	06 9b       	mov	r11,r3
8000af26:	c0 cd       	rcall	8000b13e <memmove>
8000af28:	6e 08       	ld.w	r8,r7[0x0]
8000af2a:	0c 08       	add	r8,r6
8000af2c:	0c 94       	mov	r4,r6
8000af2e:	8f 08       	st.w	r7[0x0],r8
8000af30:	6e 28       	ld.w	r8,r7[0x8]
8000af32:	0c 18       	sub	r8,r6
8000af34:	8f 28       	st.w	r7[0x8],r8
8000af36:	62 28       	ld.w	r8,r1[0x8]
8000af38:	08 18       	sub	r8,r4
8000af3a:	83 28       	st.w	r1[0x8],r8
8000af3c:	c6 b0       	breq	8000b012 <__sfvwrite_r+0x28e>
8000af3e:	08 16       	sub	r6,r4
8000af40:	08 03       	add	r3,r4
8000af42:	c7 1b       	rjmp	8000ae24 <__sfvwrite_r+0xa0>
8000af44:	60 03       	ld.w	r3,r0[0x0]
8000af46:	60 11       	ld.w	r1,r0[0x4]
8000af48:	30 08       	mov	r8,0
8000af4a:	2f 80       	sub	r0,-8
8000af4c:	50 08       	stdsp	sp[0x0],r8
8000af4e:	58 01       	cp.w	r1,0
8000af50:	cf a0       	breq	8000af44 <__sfvwrite_r+0x1c0>
8000af52:	40 0a       	lddsp	r10,sp[0x0]
8000af54:	58 0a       	cp.w	r10,0
8000af56:	c1 41       	brne	8000af7e <__sfvwrite_r+0x1fa>
8000af58:	e2 c6 ff ff 	sub	r6,r1,-1
8000af5c:	02 9a       	mov	r10,r1
8000af5e:	30 ab       	mov	r11,10
8000af60:	06 9c       	mov	r12,r3
8000af62:	ce 3c       	rcall	8000b128 <memchr>
8000af64:	f8 c8 ff ff 	sub	r8,r12,-1
8000af68:	58 0c       	cp.w	r12,0
8000af6a:	f1 d3 e1 16 	subne	r6,r8,r3
8000af6e:	f9 b9 01 01 	movne	r9,1
8000af72:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000af76:	f9 b8 00 01 	moveq	r8,1
8000af7a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000af7e:	02 36       	cp.w	r6,r1
8000af80:	ec 04 17 80 	movls	r4,r6
8000af84:	e2 04 17 b0 	movhi	r4,r1
8000af88:	6e 59       	ld.w	r9,r7[0x14]
8000af8a:	6e 25       	ld.w	r5,r7[0x8]
8000af8c:	f2 05 00 05 	add	r5,r9,r5
8000af90:	0a 34       	cp.w	r4,r5
8000af92:	5f 9a       	srgt	r10
8000af94:	6e 0c       	ld.w	r12,r7[0x0]
8000af96:	6e 48       	ld.w	r8,r7[0x10]
8000af98:	10 3c       	cp.w	r12,r8
8000af9a:	5f b8       	srhi	r8
8000af9c:	f5 e8 00 08 	and	r8,r10,r8
8000afa0:	30 0a       	mov	r10,0
8000afa2:	f4 08 18 00 	cp.b	r8,r10
8000afa6:	c0 d0       	breq	8000afc0 <__sfvwrite_r+0x23c>
8000afa8:	06 9b       	mov	r11,r3
8000afaa:	0a 9a       	mov	r10,r5
8000afac:	cc 9c       	rcall	8000b13e <memmove>
8000afae:	6e 08       	ld.w	r8,r7[0x0]
8000afb0:	0a 08       	add	r8,r5
8000afb2:	0e 9b       	mov	r11,r7
8000afb4:	8f 08       	st.w	r7[0x0],r8
8000afb6:	40 1c       	lddsp	r12,sp[0x4]
8000afb8:	fe b0 fc ae 	rcall	8000a914 <_fflush_r>
8000afbc:	c1 70       	breq	8000afea <__sfvwrite_r+0x266>
8000afbe:	c2 58       	rjmp	8000b008 <__sfvwrite_r+0x284>
8000afc0:	12 34       	cp.w	r4,r9
8000afc2:	c0 a5       	brlt	8000afd6 <__sfvwrite_r+0x252>
8000afc4:	6e a8       	ld.w	r8,r7[0x28]
8000afc6:	06 9a       	mov	r10,r3
8000afc8:	6e 8b       	ld.w	r11,r7[0x20]
8000afca:	40 1c       	lddsp	r12,sp[0x4]
8000afcc:	5d 18       	icall	r8
8000afce:	18 95       	mov	r5,r12
8000afd0:	e0 89 00 0d 	brgt	8000afea <__sfvwrite_r+0x266>
8000afd4:	c1 a8       	rjmp	8000b008 <__sfvwrite_r+0x284>
8000afd6:	08 9a       	mov	r10,r4
8000afd8:	06 9b       	mov	r11,r3
8000afda:	cb 2c       	rcall	8000b13e <memmove>
8000afdc:	6e 08       	ld.w	r8,r7[0x0]
8000afde:	08 08       	add	r8,r4
8000afe0:	08 95       	mov	r5,r4
8000afe2:	8f 08       	st.w	r7[0x0],r8
8000afe4:	6e 28       	ld.w	r8,r7[0x8]
8000afe6:	08 18       	sub	r8,r4
8000afe8:	8f 28       	st.w	r7[0x8],r8
8000afea:	0a 16       	sub	r6,r5
8000afec:	c0 71       	brne	8000affa <__sfvwrite_r+0x276>
8000afee:	0e 9b       	mov	r11,r7
8000aff0:	40 1c       	lddsp	r12,sp[0x4]
8000aff2:	fe b0 fc 91 	rcall	8000a914 <_fflush_r>
8000aff6:	c0 91       	brne	8000b008 <__sfvwrite_r+0x284>
8000aff8:	50 06       	stdsp	sp[0x0],r6
8000affa:	64 28       	ld.w	r8,r2[0x8]
8000affc:	0a 18       	sub	r8,r5
8000affe:	85 28       	st.w	r2[0x8],r8
8000b000:	c0 90       	breq	8000b012 <__sfvwrite_r+0x28e>
8000b002:	0a 11       	sub	r1,r5
8000b004:	0a 03       	add	r3,r5
8000b006:	ca 4b       	rjmp	8000af4e <__sfvwrite_r+0x1ca>
8000b008:	8e 68       	ld.sh	r8,r7[0xc]
8000b00a:	a7 a8       	sbr	r8,0x6
8000b00c:	ae 68       	st.h	r7[0xc],r8
8000b00e:	3f fc       	mov	r12,-1
8000b010:	c0 28       	rjmp	8000b014 <__sfvwrite_r+0x290>
8000b012:	30 0c       	mov	r12,0
8000b014:	2f dd       	sub	sp,-12
8000b016:	d8 32       	popm	r0-r7,pc

8000b018 <_fwalk>:
8000b018:	d4 31       	pushm	r0-r7,lr
8000b01a:	30 05       	mov	r5,0
8000b01c:	16 91       	mov	r1,r11
8000b01e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b022:	0a 92       	mov	r2,r5
8000b024:	fe b0 fc fe 	rcall	8000aa20 <__sfp_lock_acquire>
8000b028:	3f f3       	mov	r3,-1
8000b02a:	c1 68       	rjmp	8000b056 <_fwalk+0x3e>
8000b02c:	6e 26       	ld.w	r6,r7[0x8]
8000b02e:	6e 14       	ld.w	r4,r7[0x4]
8000b030:	2f 46       	sub	r6,-12
8000b032:	c0 c8       	rjmp	8000b04a <_fwalk+0x32>
8000b034:	8c 08       	ld.sh	r8,r6[0x0]
8000b036:	e4 08 19 00 	cp.h	r8,r2
8000b03a:	c0 70       	breq	8000b048 <_fwalk+0x30>
8000b03c:	8c 18       	ld.sh	r8,r6[0x2]
8000b03e:	e6 08 19 00 	cp.h	r8,r3
8000b042:	c0 30       	breq	8000b048 <_fwalk+0x30>
8000b044:	5d 11       	icall	r1
8000b046:	18 45       	or	r5,r12
8000b048:	2a 46       	sub	r6,-92
8000b04a:	20 14       	sub	r4,1
8000b04c:	ec cc 00 0c 	sub	r12,r6,12
8000b050:	58 04       	cp.w	r4,0
8000b052:	cf 14       	brge	8000b034 <_fwalk+0x1c>
8000b054:	6e 07       	ld.w	r7,r7[0x0]
8000b056:	58 07       	cp.w	r7,0
8000b058:	ce a1       	brne	8000b02c <_fwalk+0x14>
8000b05a:	fe b0 fc e4 	rcall	8000aa22 <__sfp_lock_release>
8000b05e:	0a 9c       	mov	r12,r5
8000b060:	d8 32       	popm	r0-r7,pc
8000b062:	d7 03       	nop

8000b064 <_localeconv_r>:
8000b064:	fe cc d5 b8 	sub	r12,pc,-10824
8000b068:	5e fc       	retal	r12
8000b06a:	d7 03       	nop

8000b06c <__smakebuf_r>:
8000b06c:	d4 21       	pushm	r4-r7,lr
8000b06e:	20 fd       	sub	sp,60
8000b070:	96 68       	ld.sh	r8,r11[0xc]
8000b072:	16 97       	mov	r7,r11
8000b074:	18 96       	mov	r6,r12
8000b076:	e2 18 00 02 	andl	r8,0x2,COH
8000b07a:	c3 d1       	brne	8000b0f4 <__smakebuf_r+0x88>
8000b07c:	96 7b       	ld.sh	r11,r11[0xe]
8000b07e:	f0 0b 19 00 	cp.h	r11,r8
8000b082:	c0 55       	brlt	8000b08c <__smakebuf_r+0x20>
8000b084:	1a 9a       	mov	r10,sp
8000b086:	e0 a0 04 75 	rcall	8000b970 <_fstat_r>
8000b08a:	c0 f4       	brge	8000b0a8 <__smakebuf_r+0x3c>
8000b08c:	8e 65       	ld.sh	r5,r7[0xc]
8000b08e:	0a 98       	mov	r8,r5
8000b090:	ab b8       	sbr	r8,0xb
8000b092:	e2 15 00 80 	andl	r5,0x80,COH
8000b096:	ae 68       	st.h	r7[0xc],r8
8000b098:	30 04       	mov	r4,0
8000b09a:	e0 68 04 00 	mov	r8,1024
8000b09e:	f9 b5 01 40 	movne	r5,64
8000b0a2:	f0 05 17 00 	moveq	r5,r8
8000b0a6:	c1 c8       	rjmp	8000b0de <__smakebuf_r+0x72>
8000b0a8:	40 18       	lddsp	r8,sp[0x4]
8000b0aa:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b0ae:	e0 48 20 00 	cp.w	r8,8192
8000b0b2:	5f 04       	sreq	r4
8000b0b4:	e0 48 80 00 	cp.w	r8,32768
8000b0b8:	c0 e1       	brne	8000b0d4 <__smakebuf_r+0x68>
8000b0ba:	6e b9       	ld.w	r9,r7[0x2c]
8000b0bc:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b0c0:	10 39       	cp.w	r9,r8
8000b0c2:	c0 91       	brne	8000b0d4 <__smakebuf_r+0x68>
8000b0c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b0c6:	e0 65 04 00 	mov	r5,1024
8000b0ca:	ab a8       	sbr	r8,0xa
8000b0cc:	ef 45 00 50 	st.w	r7[80],r5
8000b0d0:	ae 68       	st.h	r7[0xc],r8
8000b0d2:	c0 68       	rjmp	8000b0de <__smakebuf_r+0x72>
8000b0d4:	8e 68       	ld.sh	r8,r7[0xc]
8000b0d6:	e0 65 04 00 	mov	r5,1024
8000b0da:	ab b8       	sbr	r8,0xb
8000b0dc:	ae 68       	st.h	r7[0xc],r8
8000b0de:	0a 9b       	mov	r11,r5
8000b0e0:	0c 9c       	mov	r12,r6
8000b0e2:	fe b0 df 17 	rcall	80006f10 <_malloc_r>
8000b0e6:	8e 68       	ld.sh	r8,r7[0xc]
8000b0e8:	c0 d1       	brne	8000b102 <__smakebuf_r+0x96>
8000b0ea:	ed b8 00 09 	bld	r8,0x9
8000b0ee:	c1 b0       	breq	8000b124 <__smakebuf_r+0xb8>
8000b0f0:	a1 b8       	sbr	r8,0x1
8000b0f2:	ae 68       	st.h	r7[0xc],r8
8000b0f4:	ee c8 ff b9 	sub	r8,r7,-71
8000b0f8:	8f 48       	st.w	r7[0x10],r8
8000b0fa:	8f 08       	st.w	r7[0x0],r8
8000b0fc:	30 18       	mov	r8,1
8000b0fe:	8f 58       	st.w	r7[0x14],r8
8000b100:	c1 28       	rjmp	8000b124 <__smakebuf_r+0xb8>
8000b102:	a7 b8       	sbr	r8,0x7
8000b104:	8f 4c       	st.w	r7[0x10],r12
8000b106:	ae 68       	st.h	r7[0xc],r8
8000b108:	8f 55       	st.w	r7[0x14],r5
8000b10a:	fe c8 06 e6 	sub	r8,pc,1766
8000b10e:	8f 0c       	st.w	r7[0x0],r12
8000b110:	8d a8       	st.w	r6[0x28],r8
8000b112:	58 04       	cp.w	r4,0
8000b114:	c0 80       	breq	8000b124 <__smakebuf_r+0xb8>
8000b116:	8e 7c       	ld.sh	r12,r7[0xe]
8000b118:	fe b0 e3 94 	rcall	80007840 <isatty>
8000b11c:	c0 40       	breq	8000b124 <__smakebuf_r+0xb8>
8000b11e:	8e 68       	ld.sh	r8,r7[0xc]
8000b120:	a1 a8       	sbr	r8,0x0
8000b122:	ae 68       	st.h	r7[0xc],r8
8000b124:	2f 1d       	sub	sp,-60
8000b126:	d8 22       	popm	r4-r7,pc

8000b128 <memchr>:
8000b128:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b12c:	c0 68       	rjmp	8000b138 <memchr+0x10>
8000b12e:	20 1a       	sub	r10,1
8000b130:	19 88       	ld.ub	r8,r12[0x0]
8000b132:	16 38       	cp.w	r8,r11
8000b134:	5e 0c       	reteq	r12
8000b136:	2f fc       	sub	r12,-1
8000b138:	58 0a       	cp.w	r10,0
8000b13a:	cf a1       	brne	8000b12e <memchr+0x6>
8000b13c:	5e fa       	retal	r10

8000b13e <memmove>:
8000b13e:	d4 01       	pushm	lr
8000b140:	18 3b       	cp.w	r11,r12
8000b142:	c1 92       	brcc	8000b174 <memmove+0x36>
8000b144:	f6 0a 00 09 	add	r9,r11,r10
8000b148:	12 3c       	cp.w	r12,r9
8000b14a:	c1 52       	brcc	8000b174 <memmove+0x36>
8000b14c:	f8 0a 00 0b 	add	r11,r12,r10
8000b150:	30 08       	mov	r8,0
8000b152:	c0 68       	rjmp	8000b15e <memmove+0x20>
8000b154:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b158:	20 1a       	sub	r10,1
8000b15a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b15e:	20 18       	sub	r8,1
8000b160:	58 0a       	cp.w	r10,0
8000b162:	cf 91       	brne	8000b154 <memmove+0x16>
8000b164:	d8 02       	popm	pc
8000b166:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b16a:	20 1a       	sub	r10,1
8000b16c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b170:	2f f8       	sub	r8,-1
8000b172:	c0 28       	rjmp	8000b176 <memmove+0x38>
8000b174:	30 08       	mov	r8,0
8000b176:	58 0a       	cp.w	r10,0
8000b178:	cf 71       	brne	8000b166 <memmove+0x28>
8000b17a:	d8 02       	popm	pc

8000b17c <__hi0bits>:
8000b17c:	18 98       	mov	r8,r12
8000b17e:	e0 1c 00 00 	andl	r12,0x0
8000b182:	f0 09 15 10 	lsl	r9,r8,0x10
8000b186:	58 0c       	cp.w	r12,0
8000b188:	f2 08 17 00 	moveq	r8,r9
8000b18c:	f9 bc 00 10 	moveq	r12,16
8000b190:	f9 bc 01 00 	movne	r12,0
8000b194:	10 9a       	mov	r10,r8
8000b196:	f0 09 15 08 	lsl	r9,r8,0x8
8000b19a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b19e:	f7 bc 00 f8 	subeq	r12,-8
8000b1a2:	f2 08 17 00 	moveq	r8,r9
8000b1a6:	10 9a       	mov	r10,r8
8000b1a8:	f0 09 15 04 	lsl	r9,r8,0x4
8000b1ac:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b1b0:	f7 bc 00 fc 	subeq	r12,-4
8000b1b4:	f2 08 17 00 	moveq	r8,r9
8000b1b8:	10 9a       	mov	r10,r8
8000b1ba:	f0 09 15 02 	lsl	r9,r8,0x2
8000b1be:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b1c2:	f7 bc 00 fe 	subeq	r12,-2
8000b1c6:	f2 08 17 00 	moveq	r8,r9
8000b1ca:	58 08       	cp.w	r8,0
8000b1cc:	5e 5c       	retlt	r12
8000b1ce:	ed b8 00 1e 	bld	r8,0x1e
8000b1d2:	f9 bc 01 20 	movne	r12,32
8000b1d6:	f7 bc 00 ff 	subeq	r12,-1
8000b1da:	5e fc       	retal	r12

8000b1dc <__lo0bits>:
8000b1dc:	18 99       	mov	r9,r12
8000b1de:	78 08       	ld.w	r8,r12[0x0]
8000b1e0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b1e4:	c1 50       	breq	8000b20e <__lo0bits+0x32>
8000b1e6:	ed b8 00 00 	bld	r8,0x0
8000b1ea:	c0 21       	brne	8000b1ee <__lo0bits+0x12>
8000b1ec:	5e fd       	retal	0
8000b1ee:	10 9b       	mov	r11,r8
8000b1f0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b1f4:	e2 1b 00 02 	andl	r11,0x2,COH
8000b1f8:	a3 88       	lsr	r8,0x2
8000b1fa:	58 0b       	cp.w	r11,0
8000b1fc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b200:	f9 bc 01 01 	movne	r12,1
8000b204:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b208:	f9 bc 00 02 	moveq	r12,2
8000b20c:	5e fc       	retal	r12
8000b20e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b212:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b216:	58 0a       	cp.w	r10,0
8000b218:	f6 08 17 00 	moveq	r8,r11
8000b21c:	f9 bc 00 10 	moveq	r12,16
8000b220:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b224:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b228:	58 0b       	cp.w	r11,0
8000b22a:	f7 bc 00 f8 	subeq	r12,-8
8000b22e:	f4 08 17 00 	moveq	r8,r10
8000b232:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b236:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b23a:	58 0b       	cp.w	r11,0
8000b23c:	f7 bc 00 fc 	subeq	r12,-4
8000b240:	f4 08 17 00 	moveq	r8,r10
8000b244:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b248:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b24c:	58 0b       	cp.w	r11,0
8000b24e:	f7 bc 00 fe 	subeq	r12,-2
8000b252:	f4 08 17 00 	moveq	r8,r10
8000b256:	ed b8 00 00 	bld	r8,0x0
8000b25a:	c0 60       	breq	8000b266 <__lo0bits+0x8a>
8000b25c:	a1 98       	lsr	r8,0x1
8000b25e:	c0 31       	brne	8000b264 <__lo0bits+0x88>
8000b260:	32 0c       	mov	r12,32
8000b262:	5e fc       	retal	r12
8000b264:	2f fc       	sub	r12,-1
8000b266:	93 08       	st.w	r9[0x0],r8
8000b268:	5e fc       	retal	r12

8000b26a <__mcmp>:
8000b26a:	d4 01       	pushm	lr
8000b26c:	18 98       	mov	r8,r12
8000b26e:	76 49       	ld.w	r9,r11[0x10]
8000b270:	78 4c       	ld.w	r12,r12[0x10]
8000b272:	12 1c       	sub	r12,r9
8000b274:	c1 31       	brne	8000b29a <__mcmp+0x30>
8000b276:	2f b9       	sub	r9,-5
8000b278:	a3 69       	lsl	r9,0x2
8000b27a:	12 0b       	add	r11,r9
8000b27c:	f0 09 00 09 	add	r9,r8,r9
8000b280:	2e c8       	sub	r8,-20
8000b282:	13 4e       	ld.w	lr,--r9
8000b284:	17 4a       	ld.w	r10,--r11
8000b286:	14 3e       	cp.w	lr,r10
8000b288:	c0 60       	breq	8000b294 <__mcmp+0x2a>
8000b28a:	f9 bc 03 ff 	movlo	r12,-1
8000b28e:	f9 bc 02 01 	movhs	r12,1
8000b292:	d8 02       	popm	pc
8000b294:	10 39       	cp.w	r9,r8
8000b296:	fe 9b ff f6 	brhi	8000b282 <__mcmp+0x18>
8000b29a:	d8 02       	popm	pc

8000b29c <_Bfree>:
8000b29c:	d4 21       	pushm	r4-r7,lr
8000b29e:	18 97       	mov	r7,r12
8000b2a0:	16 95       	mov	r5,r11
8000b2a2:	78 96       	ld.w	r6,r12[0x24]
8000b2a4:	58 06       	cp.w	r6,0
8000b2a6:	c0 91       	brne	8000b2b8 <_Bfree+0x1c>
8000b2a8:	31 0c       	mov	r12,16
8000b2aa:	fe b0 de 2b 	rcall	80006f00 <malloc>
8000b2ae:	99 36       	st.w	r12[0xc],r6
8000b2b0:	8f 9c       	st.w	r7[0x24],r12
8000b2b2:	99 16       	st.w	r12[0x4],r6
8000b2b4:	99 26       	st.w	r12[0x8],r6
8000b2b6:	99 06       	st.w	r12[0x0],r6
8000b2b8:	58 05       	cp.w	r5,0
8000b2ba:	c0 90       	breq	8000b2cc <_Bfree+0x30>
8000b2bc:	6a 19       	ld.w	r9,r5[0x4]
8000b2be:	6e 98       	ld.w	r8,r7[0x24]
8000b2c0:	70 38       	ld.w	r8,r8[0xc]
8000b2c2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b2c6:	8b 0a       	st.w	r5[0x0],r10
8000b2c8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b2cc:	d8 22       	popm	r4-r7,pc
8000b2ce:	d7 03       	nop

8000b2d0 <_Balloc>:
8000b2d0:	d4 21       	pushm	r4-r7,lr
8000b2d2:	18 97       	mov	r7,r12
8000b2d4:	16 96       	mov	r6,r11
8000b2d6:	78 95       	ld.w	r5,r12[0x24]
8000b2d8:	58 05       	cp.w	r5,0
8000b2da:	c0 91       	brne	8000b2ec <_Balloc+0x1c>
8000b2dc:	31 0c       	mov	r12,16
8000b2de:	fe b0 de 11 	rcall	80006f00 <malloc>
8000b2e2:	99 35       	st.w	r12[0xc],r5
8000b2e4:	8f 9c       	st.w	r7[0x24],r12
8000b2e6:	99 15       	st.w	r12[0x4],r5
8000b2e8:	99 25       	st.w	r12[0x8],r5
8000b2ea:	99 05       	st.w	r12[0x0],r5
8000b2ec:	6e 95       	ld.w	r5,r7[0x24]
8000b2ee:	6a 38       	ld.w	r8,r5[0xc]
8000b2f0:	58 08       	cp.w	r8,0
8000b2f2:	c0 b1       	brne	8000b308 <_Balloc+0x38>
8000b2f4:	31 0a       	mov	r10,16
8000b2f6:	30 4b       	mov	r11,4
8000b2f8:	0e 9c       	mov	r12,r7
8000b2fa:	e0 a0 02 9b 	rcall	8000b830 <_calloc_r>
8000b2fe:	8b 3c       	st.w	r5[0xc],r12
8000b300:	6e 98       	ld.w	r8,r7[0x24]
8000b302:	70 3c       	ld.w	r12,r8[0xc]
8000b304:	58 0c       	cp.w	r12,0
8000b306:	c1 b0       	breq	8000b33c <_Balloc+0x6c>
8000b308:	6e 98       	ld.w	r8,r7[0x24]
8000b30a:	70 38       	ld.w	r8,r8[0xc]
8000b30c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b310:	70 0c       	ld.w	r12,r8[0x0]
8000b312:	58 0c       	cp.w	r12,0
8000b314:	c0 40       	breq	8000b31c <_Balloc+0x4c>
8000b316:	78 09       	ld.w	r9,r12[0x0]
8000b318:	91 09       	st.w	r8[0x0],r9
8000b31a:	c0 e8       	rjmp	8000b336 <_Balloc+0x66>
8000b31c:	0e 9c       	mov	r12,r7
8000b31e:	30 17       	mov	r7,1
8000b320:	0e 9b       	mov	r11,r7
8000b322:	ee 06 09 47 	lsl	r7,r7,r6
8000b326:	ee ca ff fb 	sub	r10,r7,-5
8000b32a:	a3 6a       	lsl	r10,0x2
8000b32c:	e0 a0 02 82 	rcall	8000b830 <_calloc_r>
8000b330:	c0 60       	breq	8000b33c <_Balloc+0x6c>
8000b332:	99 16       	st.w	r12[0x4],r6
8000b334:	99 27       	st.w	r12[0x8],r7
8000b336:	30 08       	mov	r8,0
8000b338:	99 38       	st.w	r12[0xc],r8
8000b33a:	99 48       	st.w	r12[0x10],r8
8000b33c:	d8 22       	popm	r4-r7,pc
8000b33e:	d7 03       	nop

8000b340 <__d2b>:
8000b340:	d4 31       	pushm	r0-r7,lr
8000b342:	20 2d       	sub	sp,8
8000b344:	16 93       	mov	r3,r11
8000b346:	12 96       	mov	r6,r9
8000b348:	10 95       	mov	r5,r8
8000b34a:	14 92       	mov	r2,r10
8000b34c:	30 1b       	mov	r11,1
8000b34e:	cc 1f       	rcall	8000b2d0 <_Balloc>
8000b350:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b354:	50 09       	stdsp	sp[0x0],r9
8000b356:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b35a:	b5 a9       	sbr	r9,0x14
8000b35c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b360:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b364:	18 94       	mov	r4,r12
8000b366:	58 02       	cp.w	r2,0
8000b368:	c1 d0       	breq	8000b3a2 <__d2b+0x62>
8000b36a:	fa cc ff f8 	sub	r12,sp,-8
8000b36e:	18 d2       	st.w	--r12,r2
8000b370:	c3 6f       	rcall	8000b1dc <__lo0bits>
8000b372:	40 18       	lddsp	r8,sp[0x4]
8000b374:	c0 d0       	breq	8000b38e <__d2b+0x4e>
8000b376:	40 09       	lddsp	r9,sp[0x0]
8000b378:	f8 0a 11 20 	rsub	r10,r12,32
8000b37c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b380:	f5 e8 10 08 	or	r8,r10,r8
8000b384:	89 58       	st.w	r4[0x14],r8
8000b386:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b38a:	50 09       	stdsp	sp[0x0],r9
8000b38c:	c0 28       	rjmp	8000b390 <__d2b+0x50>
8000b38e:	89 58       	st.w	r4[0x14],r8
8000b390:	40 08       	lddsp	r8,sp[0x0]
8000b392:	58 08       	cp.w	r8,0
8000b394:	f9 b3 01 02 	movne	r3,2
8000b398:	f9 b3 00 01 	moveq	r3,1
8000b39c:	89 68       	st.w	r4[0x18],r8
8000b39e:	89 43       	st.w	r4[0x10],r3
8000b3a0:	c0 88       	rjmp	8000b3b0 <__d2b+0x70>
8000b3a2:	1a 9c       	mov	r12,sp
8000b3a4:	c1 cf       	rcall	8000b1dc <__lo0bits>
8000b3a6:	30 13       	mov	r3,1
8000b3a8:	40 08       	lddsp	r8,sp[0x0]
8000b3aa:	2e 0c       	sub	r12,-32
8000b3ac:	89 43       	st.w	r4[0x10],r3
8000b3ae:	89 58       	st.w	r4[0x14],r8
8000b3b0:	58 01       	cp.w	r1,0
8000b3b2:	c0 90       	breq	8000b3c4 <__d2b+0x84>
8000b3b4:	e2 c1 04 33 	sub	r1,r1,1075
8000b3b8:	18 01       	add	r1,r12
8000b3ba:	8d 01       	st.w	r6[0x0],r1
8000b3bc:	f8 0c 11 35 	rsub	r12,r12,53
8000b3c0:	8b 0c       	st.w	r5[0x0],r12
8000b3c2:	c0 c8       	rjmp	8000b3da <__d2b+0x9a>
8000b3c4:	e6 c8 ff fc 	sub	r8,r3,-4
8000b3c8:	f8 cc 04 32 	sub	r12,r12,1074
8000b3cc:	a5 73       	lsl	r3,0x5
8000b3ce:	8d 0c       	st.w	r6[0x0],r12
8000b3d0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b3d4:	cd 4e       	rcall	8000b17c <__hi0bits>
8000b3d6:	18 13       	sub	r3,r12
8000b3d8:	8b 03       	st.w	r5[0x0],r3
8000b3da:	08 9c       	mov	r12,r4
8000b3dc:	2f ed       	sub	sp,-8
8000b3de:	d8 32       	popm	r0-r7,pc

8000b3e0 <__mdiff>:
8000b3e0:	d4 31       	pushm	r0-r7,lr
8000b3e2:	74 48       	ld.w	r8,r10[0x10]
8000b3e4:	76 45       	ld.w	r5,r11[0x10]
8000b3e6:	16 97       	mov	r7,r11
8000b3e8:	14 96       	mov	r6,r10
8000b3ea:	10 15       	sub	r5,r8
8000b3ec:	c1 31       	brne	8000b412 <__mdiff+0x32>
8000b3ee:	2f b8       	sub	r8,-5
8000b3f0:	ee ce ff ec 	sub	lr,r7,-20
8000b3f4:	a3 68       	lsl	r8,0x2
8000b3f6:	f4 08 00 0b 	add	r11,r10,r8
8000b3fa:	ee 08 00 08 	add	r8,r7,r8
8000b3fe:	11 4a       	ld.w	r10,--r8
8000b400:	17 49       	ld.w	r9,--r11
8000b402:	12 3a       	cp.w	r10,r9
8000b404:	c0 30       	breq	8000b40a <__mdiff+0x2a>
8000b406:	c0 e2       	brcc	8000b422 <__mdiff+0x42>
8000b408:	c0 78       	rjmp	8000b416 <__mdiff+0x36>
8000b40a:	1c 38       	cp.w	r8,lr
8000b40c:	fe 9b ff f9 	brhi	8000b3fe <__mdiff+0x1e>
8000b410:	c4 98       	rjmp	8000b4a2 <__mdiff+0xc2>
8000b412:	58 05       	cp.w	r5,0
8000b414:	c0 64       	brge	8000b420 <__mdiff+0x40>
8000b416:	0e 98       	mov	r8,r7
8000b418:	30 15       	mov	r5,1
8000b41a:	0c 97       	mov	r7,r6
8000b41c:	10 96       	mov	r6,r8
8000b41e:	c0 28       	rjmp	8000b422 <__mdiff+0x42>
8000b420:	30 05       	mov	r5,0
8000b422:	6e 1b       	ld.w	r11,r7[0x4]
8000b424:	c5 6f       	rcall	8000b2d0 <_Balloc>
8000b426:	6e 49       	ld.w	r9,r7[0x10]
8000b428:	6c 44       	ld.w	r4,r6[0x10]
8000b42a:	99 35       	st.w	r12[0xc],r5
8000b42c:	2f b4       	sub	r4,-5
8000b42e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b432:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b436:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b43a:	2e c6       	sub	r6,-20
8000b43c:	2e c7       	sub	r7,-20
8000b43e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b442:	30 0a       	mov	r10,0
8000b444:	0f 0e       	ld.w	lr,r7++
8000b446:	0d 0b       	ld.w	r11,r6++
8000b448:	fc 02 16 10 	lsr	r2,lr,0x10
8000b44c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b450:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b454:	e4 03 01 03 	sub	r3,r2,r3
8000b458:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b45c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b460:	f6 0a 00 0a 	add	r10,r11,r10
8000b464:	b0 1a       	st.h	r8[0x2],r10
8000b466:	b1 4a       	asr	r10,0x10
8000b468:	e6 0a 00 0a 	add	r10,r3,r10
8000b46c:	b0 0a       	st.h	r8[0x0],r10
8000b46e:	2f c8       	sub	r8,-4
8000b470:	b1 4a       	asr	r10,0x10
8000b472:	08 36       	cp.w	r6,r4
8000b474:	ce 83       	brcs	8000b444 <__mdiff+0x64>
8000b476:	c0 d8       	rjmp	8000b490 <__mdiff+0xb0>
8000b478:	0f 0b       	ld.w	r11,r7++
8000b47a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b47e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b482:	16 0a       	add	r10,r11
8000b484:	b0 1a       	st.h	r8[0x2],r10
8000b486:	b1 4a       	asr	r10,0x10
8000b488:	1c 0a       	add	r10,lr
8000b48a:	b0 0a       	st.h	r8[0x0],r10
8000b48c:	2f c8       	sub	r8,-4
8000b48e:	b1 4a       	asr	r10,0x10
8000b490:	0a 37       	cp.w	r7,r5
8000b492:	cf 33       	brcs	8000b478 <__mdiff+0x98>
8000b494:	c0 28       	rjmp	8000b498 <__mdiff+0xb8>
8000b496:	20 19       	sub	r9,1
8000b498:	11 4a       	ld.w	r10,--r8
8000b49a:	58 0a       	cp.w	r10,0
8000b49c:	cf d0       	breq	8000b496 <__mdiff+0xb6>
8000b49e:	99 49       	st.w	r12[0x10],r9
8000b4a0:	d8 32       	popm	r0-r7,pc
8000b4a2:	30 0b       	mov	r11,0
8000b4a4:	c1 6f       	rcall	8000b2d0 <_Balloc>
8000b4a6:	30 18       	mov	r8,1
8000b4a8:	99 48       	st.w	r12[0x10],r8
8000b4aa:	30 08       	mov	r8,0
8000b4ac:	99 58       	st.w	r12[0x14],r8
8000b4ae:	d8 32       	popm	r0-r7,pc

8000b4b0 <__lshift>:
8000b4b0:	d4 31       	pushm	r0-r7,lr
8000b4b2:	16 97       	mov	r7,r11
8000b4b4:	76 46       	ld.w	r6,r11[0x10]
8000b4b6:	f4 02 14 05 	asr	r2,r10,0x5
8000b4ba:	2f f6       	sub	r6,-1
8000b4bc:	14 93       	mov	r3,r10
8000b4be:	18 94       	mov	r4,r12
8000b4c0:	04 06       	add	r6,r2
8000b4c2:	76 1b       	ld.w	r11,r11[0x4]
8000b4c4:	6e 28       	ld.w	r8,r7[0x8]
8000b4c6:	c0 38       	rjmp	8000b4cc <__lshift+0x1c>
8000b4c8:	2f fb       	sub	r11,-1
8000b4ca:	a1 78       	lsl	r8,0x1
8000b4cc:	10 36       	cp.w	r6,r8
8000b4ce:	fe 99 ff fd 	brgt	8000b4c8 <__lshift+0x18>
8000b4d2:	08 9c       	mov	r12,r4
8000b4d4:	cf ee       	rcall	8000b2d0 <_Balloc>
8000b4d6:	30 09       	mov	r9,0
8000b4d8:	18 95       	mov	r5,r12
8000b4da:	f8 c8 ff ec 	sub	r8,r12,-20
8000b4de:	12 9a       	mov	r10,r9
8000b4e0:	c0 38       	rjmp	8000b4e6 <__lshift+0x36>
8000b4e2:	10 aa       	st.w	r8++,r10
8000b4e4:	2f f9       	sub	r9,-1
8000b4e6:	04 39       	cp.w	r9,r2
8000b4e8:	cf d5       	brlt	8000b4e2 <__lshift+0x32>
8000b4ea:	6e 4b       	ld.w	r11,r7[0x10]
8000b4ec:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b4f0:	2f bb       	sub	r11,-5
8000b4f2:	ee c9 ff ec 	sub	r9,r7,-20
8000b4f6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b4fa:	58 03       	cp.w	r3,0
8000b4fc:	c1 30       	breq	8000b522 <__lshift+0x72>
8000b4fe:	e6 0c 11 20 	rsub	r12,r3,32
8000b502:	30 0a       	mov	r10,0
8000b504:	72 02       	ld.w	r2,r9[0x0]
8000b506:	e4 03 09 42 	lsl	r2,r2,r3
8000b50a:	04 4a       	or	r10,r2
8000b50c:	10 aa       	st.w	r8++,r10
8000b50e:	13 0a       	ld.w	r10,r9++
8000b510:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b514:	16 39       	cp.w	r9,r11
8000b516:	cf 73       	brcs	8000b504 <__lshift+0x54>
8000b518:	91 0a       	st.w	r8[0x0],r10
8000b51a:	58 0a       	cp.w	r10,0
8000b51c:	c0 70       	breq	8000b52a <__lshift+0x7a>
8000b51e:	2f f6       	sub	r6,-1
8000b520:	c0 58       	rjmp	8000b52a <__lshift+0x7a>
8000b522:	13 0a       	ld.w	r10,r9++
8000b524:	10 aa       	st.w	r8++,r10
8000b526:	16 39       	cp.w	r9,r11
8000b528:	cf d3       	brcs	8000b522 <__lshift+0x72>
8000b52a:	08 9c       	mov	r12,r4
8000b52c:	20 16       	sub	r6,1
8000b52e:	0e 9b       	mov	r11,r7
8000b530:	8b 46       	st.w	r5[0x10],r6
8000b532:	cb 5e       	rcall	8000b29c <_Bfree>
8000b534:	0a 9c       	mov	r12,r5
8000b536:	d8 32       	popm	r0-r7,pc

8000b538 <__multiply>:
8000b538:	d4 31       	pushm	r0-r7,lr
8000b53a:	20 2d       	sub	sp,8
8000b53c:	76 49       	ld.w	r9,r11[0x10]
8000b53e:	74 48       	ld.w	r8,r10[0x10]
8000b540:	16 96       	mov	r6,r11
8000b542:	14 95       	mov	r5,r10
8000b544:	10 39       	cp.w	r9,r8
8000b546:	ec 08 17 50 	movlt	r8,r6
8000b54a:	ea 06 17 50 	movlt	r6,r5
8000b54e:	f0 05 17 50 	movlt	r5,r8
8000b552:	6c 28       	ld.w	r8,r6[0x8]
8000b554:	76 43       	ld.w	r3,r11[0x10]
8000b556:	74 42       	ld.w	r2,r10[0x10]
8000b558:	76 1b       	ld.w	r11,r11[0x4]
8000b55a:	e4 03 00 07 	add	r7,r2,r3
8000b55e:	10 37       	cp.w	r7,r8
8000b560:	f7 bb 09 ff 	subgt	r11,-1
8000b564:	cb 6e       	rcall	8000b2d0 <_Balloc>
8000b566:	ee c4 ff fb 	sub	r4,r7,-5
8000b56a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b56e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b572:	30 0a       	mov	r10,0
8000b574:	12 98       	mov	r8,r9
8000b576:	c0 28       	rjmp	8000b57a <__multiply+0x42>
8000b578:	10 aa       	st.w	r8++,r10
8000b57a:	08 38       	cp.w	r8,r4
8000b57c:	cf e3       	brcs	8000b578 <__multiply+0x40>
8000b57e:	2f b3       	sub	r3,-5
8000b580:	2f b2       	sub	r2,-5
8000b582:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b586:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b58a:	ec cb ff ec 	sub	r11,r6,-20
8000b58e:	50 12       	stdsp	sp[0x4],r2
8000b590:	ea ca ff ec 	sub	r10,r5,-20
8000b594:	c4 48       	rjmp	8000b61c <__multiply+0xe4>
8000b596:	94 95       	ld.uh	r5,r10[0x2]
8000b598:	58 05       	cp.w	r5,0
8000b59a:	c2 00       	breq	8000b5da <__multiply+0xa2>
8000b59c:	12 98       	mov	r8,r9
8000b59e:	16 96       	mov	r6,r11
8000b5a0:	30 0e       	mov	lr,0
8000b5a2:	50 09       	stdsp	sp[0x0],r9
8000b5a4:	0d 02       	ld.w	r2,r6++
8000b5a6:	e4 00 16 10 	lsr	r0,r2,0x10
8000b5aa:	70 01       	ld.w	r1,r8[0x0]
8000b5ac:	70 09       	ld.w	r9,r8[0x0]
8000b5ae:	b1 81       	lsr	r1,0x10
8000b5b0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b5b4:	e0 05 03 41 	mac	r1,r0,r5
8000b5b8:	ab 32       	mul	r2,r5
8000b5ba:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b5be:	00 02       	add	r2,r0
8000b5c0:	e4 0e 00 0e 	add	lr,r2,lr
8000b5c4:	b0 1e       	st.h	r8[0x2],lr
8000b5c6:	b1 8e       	lsr	lr,0x10
8000b5c8:	1c 01       	add	r1,lr
8000b5ca:	b0 01       	st.h	r8[0x0],r1
8000b5cc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b5d0:	2f c8       	sub	r8,-4
8000b5d2:	06 36       	cp.w	r6,r3
8000b5d4:	ce 83       	brcs	8000b5a4 <__multiply+0x6c>
8000b5d6:	40 09       	lddsp	r9,sp[0x0]
8000b5d8:	91 0e       	st.w	r8[0x0],lr
8000b5da:	94 86       	ld.uh	r6,r10[0x0]
8000b5dc:	58 06       	cp.w	r6,0
8000b5de:	c1 d0       	breq	8000b618 <__multiply+0xe0>
8000b5e0:	72 02       	ld.w	r2,r9[0x0]
8000b5e2:	12 98       	mov	r8,r9
8000b5e4:	16 9e       	mov	lr,r11
8000b5e6:	30 05       	mov	r5,0
8000b5e8:	b0 12       	st.h	r8[0x2],r2
8000b5ea:	1d 01       	ld.w	r1,lr++
8000b5ec:	90 82       	ld.uh	r2,r8[0x0]
8000b5ee:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b5f2:	ad 30       	mul	r0,r6
8000b5f4:	e0 02 00 02 	add	r2,r0,r2
8000b5f8:	e4 05 00 05 	add	r5,r2,r5
8000b5fc:	b0 05       	st.h	r8[0x0],r5
8000b5fe:	b1 85       	lsr	r5,0x10
8000b600:	b1 81       	lsr	r1,0x10
8000b602:	2f c8       	sub	r8,-4
8000b604:	ad 31       	mul	r1,r6
8000b606:	90 92       	ld.uh	r2,r8[0x2]
8000b608:	e2 02 00 02 	add	r2,r1,r2
8000b60c:	0a 02       	add	r2,r5
8000b60e:	e4 05 16 10 	lsr	r5,r2,0x10
8000b612:	06 3e       	cp.w	lr,r3
8000b614:	ce a3       	brcs	8000b5e8 <__multiply+0xb0>
8000b616:	91 02       	st.w	r8[0x0],r2
8000b618:	2f ca       	sub	r10,-4
8000b61a:	2f c9       	sub	r9,-4
8000b61c:	40 18       	lddsp	r8,sp[0x4]
8000b61e:	10 3a       	cp.w	r10,r8
8000b620:	cb b3       	brcs	8000b596 <__multiply+0x5e>
8000b622:	c0 28       	rjmp	8000b626 <__multiply+0xee>
8000b624:	20 17       	sub	r7,1
8000b626:	58 07       	cp.w	r7,0
8000b628:	e0 8a 00 05 	brle	8000b632 <__multiply+0xfa>
8000b62c:	09 48       	ld.w	r8,--r4
8000b62e:	58 08       	cp.w	r8,0
8000b630:	cf a0       	breq	8000b624 <__multiply+0xec>
8000b632:	99 47       	st.w	r12[0x10],r7
8000b634:	2f ed       	sub	sp,-8
8000b636:	d8 32       	popm	r0-r7,pc

8000b638 <__i2b>:
8000b638:	d4 21       	pushm	r4-r7,lr
8000b63a:	16 97       	mov	r7,r11
8000b63c:	30 1b       	mov	r11,1
8000b63e:	c4 9e       	rcall	8000b2d0 <_Balloc>
8000b640:	30 19       	mov	r9,1
8000b642:	99 57       	st.w	r12[0x14],r7
8000b644:	99 49       	st.w	r12[0x10],r9
8000b646:	d8 22       	popm	r4-r7,pc

8000b648 <__multadd>:
8000b648:	d4 31       	pushm	r0-r7,lr
8000b64a:	30 08       	mov	r8,0
8000b64c:	12 95       	mov	r5,r9
8000b64e:	16 97       	mov	r7,r11
8000b650:	18 96       	mov	r6,r12
8000b652:	76 44       	ld.w	r4,r11[0x10]
8000b654:	f6 c9 ff ec 	sub	r9,r11,-20
8000b658:	72 0b       	ld.w	r11,r9[0x0]
8000b65a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b65e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b662:	f4 0c 02 4c 	mul	r12,r10,r12
8000b666:	f4 0b 03 45 	mac	r5,r10,r11
8000b66a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b66e:	b1 85       	lsr	r5,0x10
8000b670:	18 05       	add	r5,r12
8000b672:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b676:	f8 0b 00 0b 	add	r11,r12,r11
8000b67a:	12 ab       	st.w	r9++,r11
8000b67c:	2f f8       	sub	r8,-1
8000b67e:	b1 85       	lsr	r5,0x10
8000b680:	08 38       	cp.w	r8,r4
8000b682:	ce b5       	brlt	8000b658 <__multadd+0x10>
8000b684:	58 05       	cp.w	r5,0
8000b686:	c1 c0       	breq	8000b6be <__multadd+0x76>
8000b688:	6e 28       	ld.w	r8,r7[0x8]
8000b68a:	10 34       	cp.w	r4,r8
8000b68c:	c1 35       	brlt	8000b6b2 <__multadd+0x6a>
8000b68e:	6e 1b       	ld.w	r11,r7[0x4]
8000b690:	0c 9c       	mov	r12,r6
8000b692:	2f fb       	sub	r11,-1
8000b694:	c1 ee       	rcall	8000b2d0 <_Balloc>
8000b696:	6e 4a       	ld.w	r10,r7[0x10]
8000b698:	ee cb ff f4 	sub	r11,r7,-12
8000b69c:	18 93       	mov	r3,r12
8000b69e:	2f ea       	sub	r10,-2
8000b6a0:	2f 4c       	sub	r12,-12
8000b6a2:	a3 6a       	lsl	r10,0x2
8000b6a4:	fe b0 de 65 	rcall	8000736e <memcpy>
8000b6a8:	0e 9b       	mov	r11,r7
8000b6aa:	0c 9c       	mov	r12,r6
8000b6ac:	fe b0 fd f8 	rcall	8000b29c <_Bfree>
8000b6b0:	06 97       	mov	r7,r3
8000b6b2:	e8 c8 ff ff 	sub	r8,r4,-1
8000b6b6:	2f b4       	sub	r4,-5
8000b6b8:	8f 48       	st.w	r7[0x10],r8
8000b6ba:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b6be:	0e 9c       	mov	r12,r7
8000b6c0:	d8 32       	popm	r0-r7,pc
8000b6c2:	d7 03       	nop

8000b6c4 <__pow5mult>:
8000b6c4:	d4 31       	pushm	r0-r7,lr
8000b6c6:	14 96       	mov	r6,r10
8000b6c8:	18 97       	mov	r7,r12
8000b6ca:	16 94       	mov	r4,r11
8000b6cc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b6d0:	c0 90       	breq	8000b6e2 <__pow5mult+0x1e>
8000b6d2:	20 18       	sub	r8,1
8000b6d4:	fe c9 db ec 	sub	r9,pc,-9236
8000b6d8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b6dc:	30 09       	mov	r9,0
8000b6de:	cb 5f       	rcall	8000b648 <__multadd>
8000b6e0:	18 94       	mov	r4,r12
8000b6e2:	a3 46       	asr	r6,0x2
8000b6e4:	c3 40       	breq	8000b74c <__pow5mult+0x88>
8000b6e6:	6e 95       	ld.w	r5,r7[0x24]
8000b6e8:	58 05       	cp.w	r5,0
8000b6ea:	c0 91       	brne	8000b6fc <__pow5mult+0x38>
8000b6ec:	31 0c       	mov	r12,16
8000b6ee:	fe b0 dc 09 	rcall	80006f00 <malloc>
8000b6f2:	99 35       	st.w	r12[0xc],r5
8000b6f4:	8f 9c       	st.w	r7[0x24],r12
8000b6f6:	99 15       	st.w	r12[0x4],r5
8000b6f8:	99 25       	st.w	r12[0x8],r5
8000b6fa:	99 05       	st.w	r12[0x0],r5
8000b6fc:	6e 93       	ld.w	r3,r7[0x24]
8000b6fe:	66 25       	ld.w	r5,r3[0x8]
8000b700:	58 05       	cp.w	r5,0
8000b702:	c0 c1       	brne	8000b71a <__pow5mult+0x56>
8000b704:	e0 6b 02 71 	mov	r11,625
8000b708:	0e 9c       	mov	r12,r7
8000b70a:	c9 7f       	rcall	8000b638 <__i2b>
8000b70c:	87 2c       	st.w	r3[0x8],r12
8000b70e:	30 08       	mov	r8,0
8000b710:	18 95       	mov	r5,r12
8000b712:	99 08       	st.w	r12[0x0],r8
8000b714:	c0 38       	rjmp	8000b71a <__pow5mult+0x56>
8000b716:	06 9c       	mov	r12,r3
8000b718:	18 95       	mov	r5,r12
8000b71a:	ed b6 00 00 	bld	r6,0x0
8000b71e:	c0 b1       	brne	8000b734 <__pow5mult+0x70>
8000b720:	08 9b       	mov	r11,r4
8000b722:	0a 9a       	mov	r10,r5
8000b724:	0e 9c       	mov	r12,r7
8000b726:	c0 9f       	rcall	8000b538 <__multiply>
8000b728:	08 9b       	mov	r11,r4
8000b72a:	18 93       	mov	r3,r12
8000b72c:	0e 9c       	mov	r12,r7
8000b72e:	06 94       	mov	r4,r3
8000b730:	fe b0 fd b6 	rcall	8000b29c <_Bfree>
8000b734:	a1 56       	asr	r6,0x1
8000b736:	c0 b0       	breq	8000b74c <__pow5mult+0x88>
8000b738:	6a 03       	ld.w	r3,r5[0x0]
8000b73a:	58 03       	cp.w	r3,0
8000b73c:	ce d1       	brne	8000b716 <__pow5mult+0x52>
8000b73e:	0a 9a       	mov	r10,r5
8000b740:	0a 9b       	mov	r11,r5
8000b742:	0e 9c       	mov	r12,r7
8000b744:	cf ae       	rcall	8000b538 <__multiply>
8000b746:	8b 0c       	st.w	r5[0x0],r12
8000b748:	99 03       	st.w	r12[0x0],r3
8000b74a:	ce 7b       	rjmp	8000b718 <__pow5mult+0x54>
8000b74c:	08 9c       	mov	r12,r4
8000b74e:	d8 32       	popm	r0-r7,pc

8000b750 <__isinfd>:
8000b750:	14 98       	mov	r8,r10
8000b752:	fc 19 7f f0 	movh	r9,0x7ff0
8000b756:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b75a:	f0 0b 11 00 	rsub	r11,r8,0
8000b75e:	f7 e8 10 08 	or	r8,r11,r8
8000b762:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b766:	f2 08 01 08 	sub	r8,r9,r8
8000b76a:	f0 0c 11 00 	rsub	r12,r8,0
8000b76e:	f9 e8 10 08 	or	r8,r12,r8
8000b772:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b776:	2f fc       	sub	r12,-1
8000b778:	5e fc       	retal	r12

8000b77a <__isnand>:
8000b77a:	14 98       	mov	r8,r10
8000b77c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b780:	f0 0c 11 00 	rsub	r12,r8,0
8000b784:	10 4c       	or	r12,r8
8000b786:	fc 18 7f f0 	movh	r8,0x7ff0
8000b78a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b78e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b792:	bf 9c       	lsr	r12,0x1f
8000b794:	5e fc       	retal	r12
8000b796:	d7 03       	nop

8000b798 <__sclose>:
8000b798:	d4 01       	pushm	lr
8000b79a:	96 7b       	ld.sh	r11,r11[0xe]
8000b79c:	c7 6c       	rcall	8000b888 <_close_r>
8000b79e:	d8 02       	popm	pc

8000b7a0 <__sseek>:
8000b7a0:	d4 21       	pushm	r4-r7,lr
8000b7a2:	16 97       	mov	r7,r11
8000b7a4:	96 7b       	ld.sh	r11,r11[0xe]
8000b7a6:	cf 7c       	rcall	8000b994 <_lseek_r>
8000b7a8:	8e 68       	ld.sh	r8,r7[0xc]
8000b7aa:	10 99       	mov	r9,r8
8000b7ac:	ad c8       	cbr	r8,0xc
8000b7ae:	ad a9       	sbr	r9,0xc
8000b7b0:	5b fc       	cp.w	r12,-1
8000b7b2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b7b6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b7ba:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b7be:	d8 22       	popm	r4-r7,pc

8000b7c0 <__swrite>:
8000b7c0:	d4 21       	pushm	r4-r7,lr
8000b7c2:	96 68       	ld.sh	r8,r11[0xc]
8000b7c4:	16 97       	mov	r7,r11
8000b7c6:	14 95       	mov	r5,r10
8000b7c8:	12 94       	mov	r4,r9
8000b7ca:	e2 18 01 00 	andl	r8,0x100,COH
8000b7ce:	18 96       	mov	r6,r12
8000b7d0:	c0 50       	breq	8000b7da <__swrite+0x1a>
8000b7d2:	30 29       	mov	r9,2
8000b7d4:	30 0a       	mov	r10,0
8000b7d6:	96 7b       	ld.sh	r11,r11[0xe]
8000b7d8:	cd ec       	rcall	8000b994 <_lseek_r>
8000b7da:	8e 68       	ld.sh	r8,r7[0xc]
8000b7dc:	ad c8       	cbr	r8,0xc
8000b7de:	08 99       	mov	r9,r4
8000b7e0:	0a 9a       	mov	r10,r5
8000b7e2:	8e 7b       	ld.sh	r11,r7[0xe]
8000b7e4:	0c 9c       	mov	r12,r6
8000b7e6:	ae 68       	st.h	r7[0xc],r8
8000b7e8:	c1 0c       	rcall	8000b808 <_write_r>
8000b7ea:	d8 22       	popm	r4-r7,pc

8000b7ec <__sread>:
8000b7ec:	d4 21       	pushm	r4-r7,lr
8000b7ee:	16 97       	mov	r7,r11
8000b7f0:	96 7b       	ld.sh	r11,r11[0xe]
8000b7f2:	ce 5c       	rcall	8000b9bc <_read_r>
8000b7f4:	c0 65       	brlt	8000b800 <__sread+0x14>
8000b7f6:	6f 58       	ld.w	r8,r7[0x54]
8000b7f8:	18 08       	add	r8,r12
8000b7fa:	ef 48 00 54 	st.w	r7[84],r8
8000b7fe:	d8 22       	popm	r4-r7,pc
8000b800:	8e 68       	ld.sh	r8,r7[0xc]
8000b802:	ad c8       	cbr	r8,0xc
8000b804:	ae 68       	st.h	r7[0xc],r8
8000b806:	d8 22       	popm	r4-r7,pc

8000b808 <_write_r>:
8000b808:	d4 21       	pushm	r4-r7,lr
8000b80a:	16 98       	mov	r8,r11
8000b80c:	18 97       	mov	r7,r12
8000b80e:	10 9c       	mov	r12,r8
8000b810:	30 08       	mov	r8,0
8000b812:	14 9b       	mov	r11,r10
8000b814:	e0 66 51 00 	mov	r6,20736
8000b818:	12 9a       	mov	r10,r9
8000b81a:	8d 08       	st.w	r6[0x0],r8
8000b81c:	fe b0 d1 24 	rcall	80005a64 <_write>
8000b820:	5b fc       	cp.w	r12,-1
8000b822:	c0 51       	brne	8000b82c <_write_r+0x24>
8000b824:	6c 08       	ld.w	r8,r6[0x0]
8000b826:	58 08       	cp.w	r8,0
8000b828:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b82c:	d8 22       	popm	r4-r7,pc
8000b82e:	d7 03       	nop

8000b830 <_calloc_r>:
8000b830:	d4 21       	pushm	r4-r7,lr
8000b832:	f4 0b 02 4b 	mul	r11,r10,r11
8000b836:	fe b0 db 6d 	rcall	80006f10 <_malloc_r>
8000b83a:	18 97       	mov	r7,r12
8000b83c:	c2 30       	breq	8000b882 <_calloc_r+0x52>
8000b83e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b842:	e0 1a ff fc 	andl	r10,0xfffc
8000b846:	20 4a       	sub	r10,4
8000b848:	e0 4a 00 24 	cp.w	r10,36
8000b84c:	e0 8b 00 18 	brhi	8000b87c <_calloc_r+0x4c>
8000b850:	18 98       	mov	r8,r12
8000b852:	59 3a       	cp.w	r10,19
8000b854:	e0 88 00 0f 	brls	8000b872 <_calloc_r+0x42>
8000b858:	30 09       	mov	r9,0
8000b85a:	10 a9       	st.w	r8++,r9
8000b85c:	10 a9       	st.w	r8++,r9
8000b85e:	59 ba       	cp.w	r10,27
8000b860:	e0 88 00 09 	brls	8000b872 <_calloc_r+0x42>
8000b864:	10 a9       	st.w	r8++,r9
8000b866:	10 a9       	st.w	r8++,r9
8000b868:	e0 4a 00 24 	cp.w	r10,36
8000b86c:	c0 31       	brne	8000b872 <_calloc_r+0x42>
8000b86e:	10 a9       	st.w	r8++,r9
8000b870:	10 a9       	st.w	r8++,r9
8000b872:	30 09       	mov	r9,0
8000b874:	10 a9       	st.w	r8++,r9
8000b876:	91 19       	st.w	r8[0x4],r9
8000b878:	91 09       	st.w	r8[0x0],r9
8000b87a:	c0 48       	rjmp	8000b882 <_calloc_r+0x52>
8000b87c:	30 0b       	mov	r11,0
8000b87e:	fe b0 de 1c 	rcall	800074b6 <memset>
8000b882:	0e 9c       	mov	r12,r7
8000b884:	d8 22       	popm	r4-r7,pc
8000b886:	d7 03       	nop

8000b888 <_close_r>:
8000b888:	d4 21       	pushm	r4-r7,lr
8000b88a:	30 08       	mov	r8,0
8000b88c:	18 97       	mov	r7,r12
8000b88e:	e0 66 51 00 	mov	r6,20736
8000b892:	16 9c       	mov	r12,r11
8000b894:	8d 08       	st.w	r6[0x0],r8
8000b896:	fe b0 df c1 	rcall	80007818 <_close>
8000b89a:	5b fc       	cp.w	r12,-1
8000b89c:	c0 51       	brne	8000b8a6 <_close_r+0x1e>
8000b89e:	6c 08       	ld.w	r8,r6[0x0]
8000b8a0:	58 08       	cp.w	r8,0
8000b8a2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8a6:	d8 22       	popm	r4-r7,pc

8000b8a8 <_fclose_r>:
8000b8a8:	d4 21       	pushm	r4-r7,lr
8000b8aa:	18 96       	mov	r6,r12
8000b8ac:	16 97       	mov	r7,r11
8000b8ae:	58 0b       	cp.w	r11,0
8000b8b0:	c0 31       	brne	8000b8b6 <_fclose_r+0xe>
8000b8b2:	16 95       	mov	r5,r11
8000b8b4:	c5 38       	rjmp	8000b95a <_fclose_r+0xb2>
8000b8b6:	fe b0 f8 b5 	rcall	8000aa20 <__sfp_lock_acquire>
8000b8ba:	58 06       	cp.w	r6,0
8000b8bc:	c0 70       	breq	8000b8ca <_fclose_r+0x22>
8000b8be:	6c 68       	ld.w	r8,r6[0x18]
8000b8c0:	58 08       	cp.w	r8,0
8000b8c2:	c0 41       	brne	8000b8ca <_fclose_r+0x22>
8000b8c4:	0c 9c       	mov	r12,r6
8000b8c6:	fe b0 f8 ff 	rcall	8000aac4 <__sinit>
8000b8ca:	fe c8 de 86 	sub	r8,pc,-8570
8000b8ce:	10 37       	cp.w	r7,r8
8000b8d0:	c0 31       	brne	8000b8d6 <_fclose_r+0x2e>
8000b8d2:	6c 07       	ld.w	r7,r6[0x0]
8000b8d4:	c0 c8       	rjmp	8000b8ec <_fclose_r+0x44>
8000b8d6:	fe c8 de 72 	sub	r8,pc,-8590
8000b8da:	10 37       	cp.w	r7,r8
8000b8dc:	c0 31       	brne	8000b8e2 <_fclose_r+0x3a>
8000b8de:	6c 17       	ld.w	r7,r6[0x4]
8000b8e0:	c0 68       	rjmp	8000b8ec <_fclose_r+0x44>
8000b8e2:	fe c8 de 5e 	sub	r8,pc,-8610
8000b8e6:	10 37       	cp.w	r7,r8
8000b8e8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b8ec:	8e 69       	ld.sh	r9,r7[0xc]
8000b8ee:	30 08       	mov	r8,0
8000b8f0:	f0 09 19 00 	cp.h	r9,r8
8000b8f4:	c0 51       	brne	8000b8fe <_fclose_r+0x56>
8000b8f6:	fe b0 f8 96 	rcall	8000aa22 <__sfp_lock_release>
8000b8fa:	30 05       	mov	r5,0
8000b8fc:	c2 f8       	rjmp	8000b95a <_fclose_r+0xb2>
8000b8fe:	0e 9b       	mov	r11,r7
8000b900:	0c 9c       	mov	r12,r6
8000b902:	fe b0 f8 09 	rcall	8000a914 <_fflush_r>
8000b906:	6e c8       	ld.w	r8,r7[0x30]
8000b908:	18 95       	mov	r5,r12
8000b90a:	58 08       	cp.w	r8,0
8000b90c:	c0 60       	breq	8000b918 <_fclose_r+0x70>
8000b90e:	6e 8b       	ld.w	r11,r7[0x20]
8000b910:	0c 9c       	mov	r12,r6
8000b912:	5d 18       	icall	r8
8000b914:	f9 b5 05 ff 	movlt	r5,-1
8000b918:	8e 68       	ld.sh	r8,r7[0xc]
8000b91a:	ed b8 00 07 	bld	r8,0x7
8000b91e:	c0 51       	brne	8000b928 <_fclose_r+0x80>
8000b920:	6e 4b       	ld.w	r11,r7[0x10]
8000b922:	0c 9c       	mov	r12,r6
8000b924:	fe b0 f9 6a 	rcall	8000abf8 <_free_r>
8000b928:	6e db       	ld.w	r11,r7[0x34]
8000b92a:	58 0b       	cp.w	r11,0
8000b92c:	c0 a0       	breq	8000b940 <_fclose_r+0x98>
8000b92e:	ee c8 ff bc 	sub	r8,r7,-68
8000b932:	10 3b       	cp.w	r11,r8
8000b934:	c0 40       	breq	8000b93c <_fclose_r+0x94>
8000b936:	0c 9c       	mov	r12,r6
8000b938:	fe b0 f9 60 	rcall	8000abf8 <_free_r>
8000b93c:	30 08       	mov	r8,0
8000b93e:	8f d8       	st.w	r7[0x34],r8
8000b940:	6f 2b       	ld.w	r11,r7[0x48]
8000b942:	58 0b       	cp.w	r11,0
8000b944:	c0 70       	breq	8000b952 <_fclose_r+0xaa>
8000b946:	0c 9c       	mov	r12,r6
8000b948:	fe b0 f9 58 	rcall	8000abf8 <_free_r>
8000b94c:	30 08       	mov	r8,0
8000b94e:	ef 48 00 48 	st.w	r7[72],r8
8000b952:	30 08       	mov	r8,0
8000b954:	ae 68       	st.h	r7[0xc],r8
8000b956:	fe b0 f8 66 	rcall	8000aa22 <__sfp_lock_release>
8000b95a:	0a 9c       	mov	r12,r5
8000b95c:	d8 22       	popm	r4-r7,pc
8000b95e:	d7 03       	nop

8000b960 <fclose>:
8000b960:	d4 01       	pushm	lr
8000b962:	e0 68 0a 3c 	mov	r8,2620
8000b966:	18 9b       	mov	r11,r12
8000b968:	70 0c       	ld.w	r12,r8[0x0]
8000b96a:	c9 ff       	rcall	8000b8a8 <_fclose_r>
8000b96c:	d8 02       	popm	pc
8000b96e:	d7 03       	nop

8000b970 <_fstat_r>:
8000b970:	d4 21       	pushm	r4-r7,lr
8000b972:	16 98       	mov	r8,r11
8000b974:	18 97       	mov	r7,r12
8000b976:	10 9c       	mov	r12,r8
8000b978:	30 08       	mov	r8,0
8000b97a:	e0 66 51 00 	mov	r6,20736
8000b97e:	14 9b       	mov	r11,r10
8000b980:	8d 08       	st.w	r6[0x0],r8
8000b982:	fe b0 df 73 	rcall	80007868 <_fstat>
8000b986:	5b fc       	cp.w	r12,-1
8000b988:	c0 51       	brne	8000b992 <_fstat_r+0x22>
8000b98a:	6c 08       	ld.w	r8,r6[0x0]
8000b98c:	58 08       	cp.w	r8,0
8000b98e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b992:	d8 22       	popm	r4-r7,pc

8000b994 <_lseek_r>:
8000b994:	d4 21       	pushm	r4-r7,lr
8000b996:	16 98       	mov	r8,r11
8000b998:	18 97       	mov	r7,r12
8000b99a:	10 9c       	mov	r12,r8
8000b99c:	30 08       	mov	r8,0
8000b99e:	14 9b       	mov	r11,r10
8000b9a0:	e0 66 51 00 	mov	r6,20736
8000b9a4:	12 9a       	mov	r10,r9
8000b9a6:	8d 08       	st.w	r6[0x0],r8
8000b9a8:	fe b0 df 42 	rcall	8000782c <_lseek>
8000b9ac:	5b fc       	cp.w	r12,-1
8000b9ae:	c0 51       	brne	8000b9b8 <_lseek_r+0x24>
8000b9b0:	6c 08       	ld.w	r8,r6[0x0]
8000b9b2:	58 08       	cp.w	r8,0
8000b9b4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b9b8:	d8 22       	popm	r4-r7,pc
8000b9ba:	d7 03       	nop

8000b9bc <_read_r>:
8000b9bc:	d4 21       	pushm	r4-r7,lr
8000b9be:	16 98       	mov	r8,r11
8000b9c0:	18 97       	mov	r7,r12
8000b9c2:	10 9c       	mov	r12,r8
8000b9c4:	30 08       	mov	r8,0
8000b9c6:	14 9b       	mov	r11,r10
8000b9c8:	e0 66 51 00 	mov	r6,20736
8000b9cc:	12 9a       	mov	r10,r9
8000b9ce:	8d 08       	st.w	r6[0x0],r8
8000b9d0:	fe b0 d0 2a 	rcall	80005a24 <_read>
8000b9d4:	5b fc       	cp.w	r12,-1
8000b9d6:	c0 51       	brne	8000b9e0 <_read_r+0x24>
8000b9d8:	6c 08       	ld.w	r8,r6[0x0]
8000b9da:	58 08       	cp.w	r8,0
8000b9dc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b9e0:	d8 22       	popm	r4-r7,pc
8000b9e2:	d7 03       	nop

8000b9e4 <__avr32_f64_mul>:
8000b9e4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b9e8:	e0 80 00 dc 	breq	8000bba0 <__avr32_f64_mul_op1_zero>
8000b9ec:	d4 21       	pushm	r4-r7,lr
8000b9ee:	f7 e9 20 0e 	eor	lr,r11,r9
8000b9f2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b9f6:	30 15       	mov	r5,1
8000b9f8:	c4 30       	breq	8000ba7e <__avr32_f64_mul_op1_subnormal>
8000b9fa:	ab 6b       	lsl	r11,0xa
8000b9fc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ba00:	ab 6a       	lsl	r10,0xa
8000ba02:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ba06:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ba0a:	c5 c0       	breq	8000bac2 <__avr32_f64_mul_op2_subnormal>
8000ba0c:	a1 78       	lsl	r8,0x1
8000ba0e:	5c f9       	rol	r9
8000ba10:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ba14:	e0 47 07 ff 	cp.w	r7,2047
8000ba18:	c7 70       	breq	8000bb06 <__avr32_f64_mul_op_nan_or_inf>
8000ba1a:	e0 46 07 ff 	cp.w	r6,2047
8000ba1e:	c7 40       	breq	8000bb06 <__avr32_f64_mul_op_nan_or_inf>
8000ba20:	ee 06 00 0c 	add	r12,r7,r6
8000ba24:	e0 2c 03 fe 	sub	r12,1022
8000ba28:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ba2c:	f4 09 07 44 	macu.d	r4,r10,r9
8000ba30:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ba34:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ba38:	08 07       	add	r7,r4
8000ba3a:	f4 05 00 4a 	adc	r10,r10,r5
8000ba3e:	5c 0b       	acr	r11
8000ba40:	ed bb 00 14 	bld	r11,0x14
8000ba44:	c0 50       	breq	8000ba4e <__avr32_f64_mul+0x6a>
8000ba46:	a1 77       	lsl	r7,0x1
8000ba48:	5c fa       	rol	r10
8000ba4a:	5c fb       	rol	r11
8000ba4c:	20 1c       	sub	r12,1
8000ba4e:	58 0c       	cp.w	r12,0
8000ba50:	e0 8a 00 6f 	brle	8000bb2e <__avr32_f64_mul_res_subnormal>
8000ba54:	e0 4c 07 ff 	cp.w	r12,2047
8000ba58:	e0 84 00 9c 	brge	8000bb90 <__avr32_f64_mul_res_inf>
8000ba5c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ba60:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ba64:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ba68:	ee 17 80 00 	eorh	r7,0x8000
8000ba6c:	f1 b7 04 20 	satu	r7,0x1
8000ba70:	0e 0a       	add	r10,r7
8000ba72:	5c 0b       	acr	r11
8000ba74:	ed be 00 1f 	bld	lr,0x1f
8000ba78:	ef bb 00 1f 	bst	r11,0x1f
8000ba7c:	d8 22       	popm	r4-r7,pc

8000ba7e <__avr32_f64_mul_op1_subnormal>:
8000ba7e:	e4 1b 00 0f 	andh	r11,0xf
8000ba82:	f4 0c 12 00 	clz	r12,r10
8000ba86:	f6 06 12 00 	clz	r6,r11
8000ba8a:	f7 bc 03 e1 	sublo	r12,-31
8000ba8e:	f8 06 17 30 	movlo	r6,r12
8000ba92:	f7 b6 02 01 	subhs	r6,1
8000ba96:	e0 46 00 20 	cp.w	r6,32
8000ba9a:	c0 d4       	brge	8000bab4 <__avr32_f64_mul_op1_subnormal+0x36>
8000ba9c:	ec 0c 11 20 	rsub	r12,r6,32
8000baa0:	f6 06 09 4b 	lsl	r11,r11,r6
8000baa4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000baa8:	18 4b       	or	r11,r12
8000baaa:	f4 06 09 4a 	lsl	r10,r10,r6
8000baae:	20 b6       	sub	r6,11
8000bab0:	0c 17       	sub	r7,r6
8000bab2:	ca ab       	rjmp	8000ba06 <__avr32_f64_mul+0x22>
8000bab4:	f4 06 09 4b 	lsl	r11,r10,r6
8000bab8:	c6 40       	breq	8000bb80 <__avr32_f64_mul_res_zero>
8000baba:	30 0a       	mov	r10,0
8000babc:	20 b6       	sub	r6,11
8000babe:	0c 17       	sub	r7,r6
8000bac0:	ca 3b       	rjmp	8000ba06 <__avr32_f64_mul+0x22>

8000bac2 <__avr32_f64_mul_op2_subnormal>:
8000bac2:	e4 19 00 0f 	andh	r9,0xf
8000bac6:	f0 0c 12 00 	clz	r12,r8
8000baca:	f2 05 12 00 	clz	r5,r9
8000bace:	f7 bc 03 ea 	sublo	r12,-22
8000bad2:	f8 05 17 30 	movlo	r5,r12
8000bad6:	f7 b5 02 0a 	subhs	r5,10
8000bada:	e0 45 00 20 	cp.w	r5,32
8000bade:	c0 d4       	brge	8000baf8 <__avr32_f64_mul_op2_subnormal+0x36>
8000bae0:	ea 0c 11 20 	rsub	r12,r5,32
8000bae4:	f2 05 09 49 	lsl	r9,r9,r5
8000bae8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000baec:	18 49       	or	r9,r12
8000baee:	f0 05 09 48 	lsl	r8,r8,r5
8000baf2:	20 25       	sub	r5,2
8000baf4:	0a 16       	sub	r6,r5
8000baf6:	c8 fb       	rjmp	8000ba14 <__avr32_f64_mul+0x30>
8000baf8:	f0 05 09 49 	lsl	r9,r8,r5
8000bafc:	c4 20       	breq	8000bb80 <__avr32_f64_mul_res_zero>
8000bafe:	30 08       	mov	r8,0
8000bb00:	20 25       	sub	r5,2
8000bb02:	0a 16       	sub	r6,r5
8000bb04:	c8 8b       	rjmp	8000ba14 <__avr32_f64_mul+0x30>

8000bb06 <__avr32_f64_mul_op_nan_or_inf>:
8000bb06:	e4 19 00 0f 	andh	r9,0xf
8000bb0a:	e4 1b 00 0f 	andh	r11,0xf
8000bb0e:	14 4b       	or	r11,r10
8000bb10:	10 49       	or	r9,r8
8000bb12:	e0 47 07 ff 	cp.w	r7,2047
8000bb16:	c0 91       	brne	8000bb28 <__avr32_f64_mul_op1_not_naninf>
8000bb18:	58 0b       	cp.w	r11,0
8000bb1a:	c3 81       	brne	8000bb8a <__avr32_f64_mul_res_nan>
8000bb1c:	e0 46 07 ff 	cp.w	r6,2047
8000bb20:	c3 81       	brne	8000bb90 <__avr32_f64_mul_res_inf>
8000bb22:	58 09       	cp.w	r9,0
8000bb24:	c3 60       	breq	8000bb90 <__avr32_f64_mul_res_inf>
8000bb26:	c3 28       	rjmp	8000bb8a <__avr32_f64_mul_res_nan>

8000bb28 <__avr32_f64_mul_op1_not_naninf>:
8000bb28:	58 09       	cp.w	r9,0
8000bb2a:	c3 30       	breq	8000bb90 <__avr32_f64_mul_res_inf>
8000bb2c:	c2 f8       	rjmp	8000bb8a <__avr32_f64_mul_res_nan>

8000bb2e <__avr32_f64_mul_res_subnormal>:
8000bb2e:	5c 3c       	neg	r12
8000bb30:	2f fc       	sub	r12,-1
8000bb32:	f1 bc 04 c0 	satu	r12,0x6
8000bb36:	e0 4c 00 20 	cp.w	r12,32
8000bb3a:	c1 14       	brge	8000bb5c <__avr32_f64_mul_res_subnormal+0x2e>
8000bb3c:	f8 08 11 20 	rsub	r8,r12,32
8000bb40:	0e 46       	or	r6,r7
8000bb42:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bb46:	f4 08 09 49 	lsl	r9,r10,r8
8000bb4a:	12 47       	or	r7,r9
8000bb4c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb50:	f6 08 09 49 	lsl	r9,r11,r8
8000bb54:	12 4a       	or	r10,r9
8000bb56:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb5a:	c8 3b       	rjmp	8000ba60 <__avr32_f64_mul+0x7c>
8000bb5c:	f8 08 11 20 	rsub	r8,r12,32
8000bb60:	f9 b9 00 00 	moveq	r9,0
8000bb64:	c0 30       	breq	8000bb6a <__avr32_f64_mul_res_subnormal+0x3c>
8000bb66:	f6 08 09 49 	lsl	r9,r11,r8
8000bb6a:	0e 46       	or	r6,r7
8000bb6c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bb70:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb74:	f3 ea 10 07 	or	r7,r9,r10
8000bb78:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bb7c:	30 0b       	mov	r11,0
8000bb7e:	c7 1b       	rjmp	8000ba60 <__avr32_f64_mul+0x7c>

8000bb80 <__avr32_f64_mul_res_zero>:
8000bb80:	1c 9b       	mov	r11,lr
8000bb82:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bb86:	30 0a       	mov	r10,0
8000bb88:	d8 22       	popm	r4-r7,pc

8000bb8a <__avr32_f64_mul_res_nan>:
8000bb8a:	3f fb       	mov	r11,-1
8000bb8c:	3f fa       	mov	r10,-1
8000bb8e:	d8 22       	popm	r4-r7,pc

8000bb90 <__avr32_f64_mul_res_inf>:
8000bb90:	f0 6b 00 00 	mov	r11,-1048576
8000bb94:	ed be 00 1f 	bld	lr,0x1f
8000bb98:	ef bb 00 1f 	bst	r11,0x1f
8000bb9c:	30 0a       	mov	r10,0
8000bb9e:	d8 22       	popm	r4-r7,pc

8000bba0 <__avr32_f64_mul_op1_zero>:
8000bba0:	f7 e9 20 0b 	eor	r11,r11,r9
8000bba4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bba8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bbac:	e0 4c 07 ff 	cp.w	r12,2047
8000bbb0:	5e 1c       	retne	r12
8000bbb2:	3f fa       	mov	r10,-1
8000bbb4:	3f fb       	mov	r11,-1
8000bbb6:	5e fc       	retal	r12

8000bbb8 <__avr32_f64_sub_from_add>:
8000bbb8:	ee 19 80 00 	eorh	r9,0x8000

8000bbbc <__avr32_f64_sub>:
8000bbbc:	f7 e9 20 0c 	eor	r12,r11,r9
8000bbc0:	e0 86 00 ca 	brmi	8000bd54 <__avr32_f64_add_from_sub>
8000bbc4:	eb cd 40 e0 	pushm	r5-r7,lr
8000bbc8:	16 9c       	mov	r12,r11
8000bbca:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bbce:	bf db       	cbr	r11,0x1f
8000bbd0:	bf d9       	cbr	r9,0x1f
8000bbd2:	10 3a       	cp.w	r10,r8
8000bbd4:	f2 0b 13 00 	cpc	r11,r9
8000bbd8:	c0 92       	brcc	8000bbea <__avr32_f64_sub+0x2e>
8000bbda:	16 97       	mov	r7,r11
8000bbdc:	12 9b       	mov	r11,r9
8000bbde:	0e 99       	mov	r9,r7
8000bbe0:	14 97       	mov	r7,r10
8000bbe2:	10 9a       	mov	r10,r8
8000bbe4:	0e 98       	mov	r8,r7
8000bbe6:	ee 1c 80 00 	eorh	r12,0x8000
8000bbea:	f6 07 16 14 	lsr	r7,r11,0x14
8000bbee:	ab 7b       	lsl	r11,0xb
8000bbf0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bbf4:	ab 7a       	lsl	r10,0xb
8000bbf6:	bf bb       	sbr	r11,0x1f
8000bbf8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bbfc:	c4 40       	breq	8000bc84 <__avr32_f64_sub_opL_subnormal>
8000bbfe:	ab 79       	lsl	r9,0xb
8000bc00:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bc04:	ab 78       	lsl	r8,0xb
8000bc06:	bf b9       	sbr	r9,0x1f

8000bc08 <__avr32_f64_sub_opL_subnormal_done>:
8000bc08:	e0 47 07 ff 	cp.w	r7,2047
8000bc0c:	c4 f0       	breq	8000bcaa <__avr32_f64_sub_opH_nan_or_inf>
8000bc0e:	0e 26       	rsub	r6,r7
8000bc10:	c1 20       	breq	8000bc34 <__avr32_f64_sub_shift_done>
8000bc12:	ec 05 11 20 	rsub	r5,r6,32
8000bc16:	e0 46 00 20 	cp.w	r6,32
8000bc1a:	c7 c2       	brcc	8000bd12 <__avr32_f64_sub_longshift>
8000bc1c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bc20:	f2 05 09 45 	lsl	r5,r9,r5
8000bc24:	f0 06 0a 48 	lsr	r8,r8,r6
8000bc28:	f2 06 0a 49 	lsr	r9,r9,r6
8000bc2c:	0a 48       	or	r8,r5
8000bc2e:	58 0e       	cp.w	lr,0
8000bc30:	5f 1e       	srne	lr
8000bc32:	1c 48       	or	r8,lr

8000bc34 <__avr32_f64_sub_shift_done>:
8000bc34:	10 1a       	sub	r10,r8
8000bc36:	f6 09 01 4b 	sbc	r11,r11,r9
8000bc3a:	f6 06 12 00 	clz	r6,r11
8000bc3e:	c0 e0       	breq	8000bc5a <__avr32_f64_sub_longnormalize_done>
8000bc40:	c7 83       	brcs	8000bd30 <__avr32_f64_sub_longnormalize>
8000bc42:	ec 0e 11 20 	rsub	lr,r6,32
8000bc46:	f6 06 09 4b 	lsl	r11,r11,r6
8000bc4a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bc4e:	1c 4b       	or	r11,lr
8000bc50:	f4 06 09 4a 	lsl	r10,r10,r6
8000bc54:	0c 17       	sub	r7,r6
8000bc56:	e0 8a 00 39 	brle	8000bcc8 <__avr32_f64_sub_subnormal_result>

8000bc5a <__avr32_f64_sub_longnormalize_done>:
8000bc5a:	f4 09 15 15 	lsl	r9,r10,0x15
8000bc5e:	ab 9a       	lsr	r10,0xb
8000bc60:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc64:	ab 9b       	lsr	r11,0xb
8000bc66:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc6a:	18 4b       	or	r11,r12

8000bc6c <__avr32_f64_sub_round>:
8000bc6c:	fc 17 80 00 	movh	r7,0x8000
8000bc70:	ed ba 00 00 	bld	r10,0x0
8000bc74:	f7 b7 01 ff 	subne	r7,-1
8000bc78:	0e 39       	cp.w	r9,r7
8000bc7a:	5f 29       	srhs	r9
8000bc7c:	12 0a       	add	r10,r9
8000bc7e:	5c 0b       	acr	r11
8000bc80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc84 <__avr32_f64_sub_opL_subnormal>:
8000bc84:	ab 79       	lsl	r9,0xb
8000bc86:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bc8a:	ab 78       	lsl	r8,0xb
8000bc8c:	f3 e8 10 0e 	or	lr,r9,r8
8000bc90:	f9 b6 01 01 	movne	r6,1
8000bc94:	ee 0e 11 00 	rsub	lr,r7,0
8000bc98:	f9 b7 00 01 	moveq	r7,1
8000bc9c:	ef bb 00 1f 	bst	r11,0x1f
8000bca0:	f7 ea 10 0e 	or	lr,r11,r10
8000bca4:	f9 b7 00 00 	moveq	r7,0
8000bca8:	cb 0b       	rjmp	8000bc08 <__avr32_f64_sub_opL_subnormal_done>

8000bcaa <__avr32_f64_sub_opH_nan_or_inf>:
8000bcaa:	bf db       	cbr	r11,0x1f
8000bcac:	f7 ea 10 0e 	or	lr,r11,r10
8000bcb0:	c0 81       	brne	8000bcc0 <__avr32_f64_sub_return_nan>
8000bcb2:	e0 46 07 ff 	cp.w	r6,2047
8000bcb6:	c0 50       	breq	8000bcc0 <__avr32_f64_sub_return_nan>
8000bcb8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bcbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcc0 <__avr32_f64_sub_return_nan>:
8000bcc0:	3f fa       	mov	r10,-1
8000bcc2:	3f fb       	mov	r11,-1
8000bcc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcc8 <__avr32_f64_sub_subnormal_result>:
8000bcc8:	5c 37       	neg	r7
8000bcca:	2f f7       	sub	r7,-1
8000bccc:	f1 b7 04 c0 	satu	r7,0x6
8000bcd0:	e0 47 00 20 	cp.w	r7,32
8000bcd4:	c1 14       	brge	8000bcf6 <__avr32_f64_sub_subnormal_result+0x2e>
8000bcd6:	ee 08 11 20 	rsub	r8,r7,32
8000bcda:	f4 08 09 49 	lsl	r9,r10,r8
8000bcde:	5f 16       	srne	r6
8000bce0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bce4:	0c 4a       	or	r10,r6
8000bce6:	f6 08 09 49 	lsl	r9,r11,r8
8000bcea:	f5 e9 10 0a 	or	r10,r10,r9
8000bcee:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bcf2:	30 07       	mov	r7,0
8000bcf4:	cb 3b       	rjmp	8000bc5a <__avr32_f64_sub_longnormalize_done>
8000bcf6:	ee 08 11 40 	rsub	r8,r7,64
8000bcfa:	f6 08 09 49 	lsl	r9,r11,r8
8000bcfe:	14 49       	or	r9,r10
8000bd00:	5f 16       	srne	r6
8000bd02:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bd06:	0c 4a       	or	r10,r6
8000bd08:	30 0b       	mov	r11,0
8000bd0a:	30 07       	mov	r7,0
8000bd0c:	ca 7b       	rjmp	8000bc5a <__avr32_f64_sub_longnormalize_done>
8000bd0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd12 <__avr32_f64_sub_longshift>:
8000bd12:	f1 b6 04 c0 	satu	r6,0x6
8000bd16:	f0 0e 17 00 	moveq	lr,r8
8000bd1a:	c0 40       	breq	8000bd22 <__avr32_f64_sub_longshift+0x10>
8000bd1c:	f2 05 09 4e 	lsl	lr,r9,r5
8000bd20:	10 4e       	or	lr,r8
8000bd22:	f2 06 0a 48 	lsr	r8,r9,r6
8000bd26:	30 09       	mov	r9,0
8000bd28:	58 0e       	cp.w	lr,0
8000bd2a:	5f 1e       	srne	lr
8000bd2c:	1c 48       	or	r8,lr
8000bd2e:	c8 3b       	rjmp	8000bc34 <__avr32_f64_sub_shift_done>

8000bd30 <__avr32_f64_sub_longnormalize>:
8000bd30:	f4 06 12 00 	clz	r6,r10
8000bd34:	f9 b7 03 00 	movlo	r7,0
8000bd38:	f9 b6 03 00 	movlo	r6,0
8000bd3c:	f9 bc 03 00 	movlo	r12,0
8000bd40:	f7 b6 02 e0 	subhs	r6,-32
8000bd44:	f4 06 09 4b 	lsl	r11,r10,r6
8000bd48:	30 0a       	mov	r10,0
8000bd4a:	0c 17       	sub	r7,r6
8000bd4c:	fe 9a ff be 	brle	8000bcc8 <__avr32_f64_sub_subnormal_result>
8000bd50:	c8 5b       	rjmp	8000bc5a <__avr32_f64_sub_longnormalize_done>
8000bd52:	d7 03       	nop

8000bd54 <__avr32_f64_add_from_sub>:
8000bd54:	ee 19 80 00 	eorh	r9,0x8000

8000bd58 <__avr32_f64_add>:
8000bd58:	f7 e9 20 0c 	eor	r12,r11,r9
8000bd5c:	fe 96 ff 2e 	brmi	8000bbb8 <__avr32_f64_sub_from_add>
8000bd60:	eb cd 40 e0 	pushm	r5-r7,lr
8000bd64:	16 9c       	mov	r12,r11
8000bd66:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bd6a:	bf db       	cbr	r11,0x1f
8000bd6c:	bf d9       	cbr	r9,0x1f
8000bd6e:	12 3b       	cp.w	r11,r9
8000bd70:	c0 72       	brcc	8000bd7e <__avr32_f64_add+0x26>
8000bd72:	16 97       	mov	r7,r11
8000bd74:	12 9b       	mov	r11,r9
8000bd76:	0e 99       	mov	r9,r7
8000bd78:	14 97       	mov	r7,r10
8000bd7a:	10 9a       	mov	r10,r8
8000bd7c:	0e 98       	mov	r8,r7
8000bd7e:	30 0e       	mov	lr,0
8000bd80:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd84:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bd88:	b5 ab       	sbr	r11,0x14
8000bd8a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd8e:	c6 20       	breq	8000be52 <__avr32_f64_add_op2_subnormal>
8000bd90:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bd94:	b5 a9       	sbr	r9,0x14
8000bd96:	e0 47 07 ff 	cp.w	r7,2047
8000bd9a:	c2 80       	breq	8000bdea <__avr32_f64_add_opH_nan_or_inf>
8000bd9c:	0e 26       	rsub	r6,r7
8000bd9e:	c1 20       	breq	8000bdc2 <__avr32_f64_add_shift_done>
8000bda0:	e0 46 00 36 	cp.w	r6,54
8000bda4:	c1 52       	brcc	8000bdce <__avr32_f64_add_res_of_done>
8000bda6:	ec 05 11 20 	rsub	r5,r6,32
8000bdaa:	e0 46 00 20 	cp.w	r6,32
8000bdae:	c3 52       	brcc	8000be18 <__avr32_f64_add_longshift>
8000bdb0:	f0 05 09 4e 	lsl	lr,r8,r5
8000bdb4:	f2 05 09 45 	lsl	r5,r9,r5
8000bdb8:	f0 06 0a 48 	lsr	r8,r8,r6
8000bdbc:	f2 06 0a 49 	lsr	r9,r9,r6
8000bdc0:	0a 48       	or	r8,r5

8000bdc2 <__avr32_f64_add_shift_done>:
8000bdc2:	10 0a       	add	r10,r8
8000bdc4:	f6 09 00 4b 	adc	r11,r11,r9
8000bdc8:	ed bb 00 15 	bld	r11,0x15
8000bdcc:	c3 40       	breq	8000be34 <__avr32_f64_add_res_of>

8000bdce <__avr32_f64_add_res_of_done>:
8000bdce:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bdd2:	18 4b       	or	r11,r12

8000bdd4 <__avr32_f64_add_round>:
8000bdd4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bdd8:	18 4e       	or	lr,r12
8000bdda:	ee 1e 80 00 	eorh	lr,0x8000
8000bdde:	f1 be 04 20 	satu	lr,0x1
8000bde2:	1c 0a       	add	r10,lr
8000bde4:	5c 0b       	acr	r11
8000bde6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdea <__avr32_f64_add_opH_nan_or_inf>:
8000bdea:	b5 cb       	cbr	r11,0x14
8000bdec:	f7 ea 10 0e 	or	lr,r11,r10
8000bdf0:	c1 01       	brne	8000be10 <__avr32_f64_add_return_nan>
8000bdf2:	e0 46 07 ff 	cp.w	r6,2047
8000bdf6:	c0 30       	breq	8000bdfc <__avr32_f64_add_opL_nan_or_inf>
8000bdf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bdfc <__avr32_f64_add_opL_nan_or_inf>:
8000bdfc:	b5 c9       	cbr	r9,0x14
8000bdfe:	f3 e8 10 0e 	or	lr,r9,r8
8000be02:	c0 71       	brne	8000be10 <__avr32_f64_add_return_nan>
8000be04:	30 0a       	mov	r10,0
8000be06:	fc 1b 7f f0 	movh	r11,0x7ff0
8000be0a:	18 4b       	or	r11,r12
8000be0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000be10 <__avr32_f64_add_return_nan>:
8000be10:	3f fa       	mov	r10,-1
8000be12:	3f fb       	mov	r11,-1
8000be14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000be18 <__avr32_f64_add_longshift>:
8000be18:	f1 b6 04 c0 	satu	r6,0x6
8000be1c:	f0 0e 17 00 	moveq	lr,r8
8000be20:	c0 60       	breq	8000be2c <__avr32_f64_add_longshift+0x14>
8000be22:	f2 05 09 4e 	lsl	lr,r9,r5
8000be26:	58 08       	cp.w	r8,0
8000be28:	5f 18       	srne	r8
8000be2a:	10 4e       	or	lr,r8
8000be2c:	f2 06 0a 48 	lsr	r8,r9,r6
8000be30:	30 09       	mov	r9,0
8000be32:	cc 8b       	rjmp	8000bdc2 <__avr32_f64_add_shift_done>

8000be34 <__avr32_f64_add_res_of>:
8000be34:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000be38:	a1 9b       	lsr	r11,0x1
8000be3a:	5d 0a       	ror	r10
8000be3c:	5d 0e       	ror	lr
8000be3e:	2f f7       	sub	r7,-1
8000be40:	e0 47 07 ff 	cp.w	r7,2047
8000be44:	f9 ba 00 00 	moveq	r10,0
8000be48:	f9 bb 00 00 	moveq	r11,0
8000be4c:	f9 be 00 00 	moveq	lr,0
8000be50:	cb fb       	rjmp	8000bdce <__avr32_f64_add_res_of_done>

8000be52 <__avr32_f64_add_op2_subnormal>:
8000be52:	30 16       	mov	r6,1
8000be54:	58 07       	cp.w	r7,0
8000be56:	ca 01       	brne	8000bd96 <__avr32_f64_add+0x3e>
8000be58:	b5 cb       	cbr	r11,0x14
8000be5a:	10 0a       	add	r10,r8
8000be5c:	f6 09 00 4b 	adc	r11,r11,r9
8000be60:	18 4b       	or	r11,r12
8000be62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000be66:	d7 03       	nop

8000be68 <__avr32_f64_to_u32>:
8000be68:	58 0b       	cp.w	r11,0
8000be6a:	5e 6d       	retmi	0

8000be6c <__avr32_f64_to_s32>:
8000be6c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000be70:	b5 9c       	lsr	r12,0x15
8000be72:	e0 2c 03 ff 	sub	r12,1023
8000be76:	5e 3d       	retlo	0
8000be78:	f8 0c 11 1f 	rsub	r12,r12,31
8000be7c:	16 99       	mov	r9,r11
8000be7e:	ab 7b       	lsl	r11,0xb
8000be80:	bf bb       	sbr	r11,0x1f
8000be82:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be86:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be8a:	a1 79       	lsl	r9,0x1
8000be8c:	5e 2b       	reths	r11
8000be8e:	5c 3b       	neg	r11
8000be90:	5e fb       	retal	r11

8000be92 <__avr32_u32_to_f64>:
8000be92:	f8 cb 00 00 	sub	r11,r12,0
8000be96:	30 0c       	mov	r12,0
8000be98:	c0 38       	rjmp	8000be9e <__avr32_s32_to_f64+0x4>

8000be9a <__avr32_s32_to_f64>:
8000be9a:	18 9b       	mov	r11,r12
8000be9c:	5c 4b       	abs	r11
8000be9e:	30 0a       	mov	r10,0
8000bea0:	5e 0b       	reteq	r11
8000bea2:	d4 01       	pushm	lr
8000bea4:	e0 69 04 1e 	mov	r9,1054
8000bea8:	f6 08 12 00 	clz	r8,r11
8000beac:	c1 70       	breq	8000beda <__avr32_s32_to_f64+0x40>
8000beae:	c0 c3       	brcs	8000bec6 <__avr32_s32_to_f64+0x2c>
8000beb0:	f0 0e 11 20 	rsub	lr,r8,32
8000beb4:	f6 08 09 4b 	lsl	r11,r11,r8
8000beb8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bebc:	1c 4b       	or	r11,lr
8000bebe:	f4 08 09 4a 	lsl	r10,r10,r8
8000bec2:	10 19       	sub	r9,r8
8000bec4:	c0 b8       	rjmp	8000beda <__avr32_s32_to_f64+0x40>
8000bec6:	f4 08 12 00 	clz	r8,r10
8000beca:	f9 b8 03 00 	movlo	r8,0
8000bece:	f7 b8 02 e0 	subhs	r8,-32
8000bed2:	f4 08 09 4b 	lsl	r11,r10,r8
8000bed6:	30 0a       	mov	r10,0
8000bed8:	10 19       	sub	r9,r8
8000beda:	58 09       	cp.w	r9,0
8000bedc:	e0 89 00 30 	brgt	8000bf3c <__avr32_s32_to_f64+0xa2>
8000bee0:	5c 39       	neg	r9
8000bee2:	2f f9       	sub	r9,-1
8000bee4:	e0 49 00 36 	cp.w	r9,54
8000bee8:	c0 43       	brcs	8000bef0 <__avr32_s32_to_f64+0x56>
8000beea:	30 0b       	mov	r11,0
8000beec:	30 0a       	mov	r10,0
8000beee:	c2 68       	rjmp	8000bf3a <__avr32_s32_to_f64+0xa0>
8000bef0:	2f 69       	sub	r9,-10
8000bef2:	f2 08 11 20 	rsub	r8,r9,32
8000bef6:	e0 49 00 20 	cp.w	r9,32
8000befa:	c0 b2       	brcc	8000bf10 <__avr32_s32_to_f64+0x76>
8000befc:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf00:	f6 08 09 48 	lsl	r8,r11,r8
8000bf04:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bf08:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bf0c:	10 4b       	or	r11,r8
8000bf0e:	c0 88       	rjmp	8000bf1e <__avr32_s32_to_f64+0x84>
8000bf10:	f6 08 09 4e 	lsl	lr,r11,r8
8000bf14:	14 4e       	or	lr,r10
8000bf16:	16 9a       	mov	r10,r11
8000bf18:	30 0b       	mov	r11,0
8000bf1a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bf1e:	ed ba 00 00 	bld	r10,0x0
8000bf22:	c0 92       	brcc	8000bf34 <__avr32_s32_to_f64+0x9a>
8000bf24:	1c 7e       	tst	lr,lr
8000bf26:	c0 41       	brne	8000bf2e <__avr32_s32_to_f64+0x94>
8000bf28:	ed ba 00 01 	bld	r10,0x1
8000bf2c:	c0 42       	brcc	8000bf34 <__avr32_s32_to_f64+0x9a>
8000bf2e:	2f fa       	sub	r10,-1
8000bf30:	f7 bb 02 ff 	subhs	r11,-1
8000bf34:	5c fc       	rol	r12
8000bf36:	5d 0b       	ror	r11
8000bf38:	5d 0a       	ror	r10
8000bf3a:	d8 02       	popm	pc
8000bf3c:	e0 68 03 ff 	mov	r8,1023
8000bf40:	ed ba 00 0b 	bld	r10,0xb
8000bf44:	f7 b8 00 ff 	subeq	r8,-1
8000bf48:	10 0a       	add	r10,r8
8000bf4a:	5c 0b       	acr	r11
8000bf4c:	f7 b9 03 fe 	sublo	r9,-2
8000bf50:	e0 49 07 ff 	cp.w	r9,2047
8000bf54:	c0 55       	brlt	8000bf5e <__avr32_s32_to_f64+0xc4>
8000bf56:	30 0a       	mov	r10,0
8000bf58:	fc 1b ff e0 	movh	r11,0xffe0
8000bf5c:	c0 c8       	rjmp	8000bf74 <__floatsidf_return_op1>
8000bf5e:	ed bb 00 1f 	bld	r11,0x1f
8000bf62:	f7 b9 01 01 	subne	r9,1
8000bf66:	ab 9a       	lsr	r10,0xb
8000bf68:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf6c:	a1 7b       	lsl	r11,0x1
8000bf6e:	ab 9b       	lsr	r11,0xb
8000bf70:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bf74 <__floatsidf_return_op1>:
8000bf74:	a1 7c       	lsl	r12,0x1
8000bf76:	5d 0b       	ror	r11
8000bf78:	d8 02       	popm	pc

8000bf7a <__avr32_f64_cmp_eq>:
8000bf7a:	10 3a       	cp.w	r10,r8
8000bf7c:	f2 0b 13 00 	cpc	r11,r9
8000bf80:	c0 80       	breq	8000bf90 <__avr32_f64_cmp_eq+0x16>
8000bf82:	a1 7b       	lsl	r11,0x1
8000bf84:	a1 79       	lsl	r9,0x1
8000bf86:	14 4b       	or	r11,r10
8000bf88:	12 4b       	or	r11,r9
8000bf8a:	10 4b       	or	r11,r8
8000bf8c:	5e 0f       	reteq	1
8000bf8e:	5e fd       	retal	0
8000bf90:	a1 7b       	lsl	r11,0x1
8000bf92:	fc 1c ff e0 	movh	r12,0xffe0
8000bf96:	58 0a       	cp.w	r10,0
8000bf98:	f8 0b 13 00 	cpc	r11,r12
8000bf9c:	5e 8f       	retls	1
8000bf9e:	5e fd       	retal	0

8000bfa0 <__avr32_f64_cmp_ge>:
8000bfa0:	1a de       	st.w	--sp,lr
8000bfa2:	1a d7       	st.w	--sp,r7
8000bfa4:	a1 7b       	lsl	r11,0x1
8000bfa6:	5f 3c       	srlo	r12
8000bfa8:	a1 79       	lsl	r9,0x1
8000bfaa:	5f 37       	srlo	r7
8000bfac:	5c fc       	rol	r12
8000bfae:	fc 1e ff e0 	movh	lr,0xffe0
8000bfb2:	58 0a       	cp.w	r10,0
8000bfb4:	fc 0b 13 00 	cpc	r11,lr
8000bfb8:	e0 8b 00 1d 	brhi	8000bff2 <__avr32_f64_cmp_ge+0x52>
8000bfbc:	58 08       	cp.w	r8,0
8000bfbe:	fc 09 13 00 	cpc	r9,lr
8000bfc2:	e0 8b 00 18 	brhi	8000bff2 <__avr32_f64_cmp_ge+0x52>
8000bfc6:	58 0b       	cp.w	r11,0
8000bfc8:	f5 ba 00 00 	subfeq	r10,0
8000bfcc:	c1 50       	breq	8000bff6 <__avr32_f64_cmp_ge+0x56>
8000bfce:	1b 07       	ld.w	r7,sp++
8000bfd0:	1b 0e       	ld.w	lr,sp++
8000bfd2:	58 3c       	cp.w	r12,3
8000bfd4:	c0 a0       	breq	8000bfe8 <__avr32_f64_cmp_ge+0x48>
8000bfd6:	58 1c       	cp.w	r12,1
8000bfd8:	c0 33       	brcs	8000bfde <__avr32_f64_cmp_ge+0x3e>
8000bfda:	5e 0f       	reteq	1
8000bfdc:	5e 1d       	retne	0
8000bfde:	10 3a       	cp.w	r10,r8
8000bfe0:	f2 0b 13 00 	cpc	r11,r9
8000bfe4:	5e 2f       	reths	1
8000bfe6:	5e 3d       	retlo	0
8000bfe8:	14 38       	cp.w	r8,r10
8000bfea:	f6 09 13 00 	cpc	r9,r11
8000bfee:	5e 2f       	reths	1
8000bff0:	5e 3d       	retlo	0
8000bff2:	1b 07       	ld.w	r7,sp++
8000bff4:	d8 0a       	popm	pc,r12=0
8000bff6:	58 17       	cp.w	r7,1
8000bff8:	5f 0c       	sreq	r12
8000bffa:	58 09       	cp.w	r9,0
8000bffc:	f5 b8 00 00 	subfeq	r8,0
8000c000:	1b 07       	ld.w	r7,sp++
8000c002:	1b 0e       	ld.w	lr,sp++
8000c004:	5e 0f       	reteq	1
8000c006:	5e fc       	retal	r12

8000c008 <__avr32_f64_cmp_lt>:
8000c008:	1a de       	st.w	--sp,lr
8000c00a:	1a d7       	st.w	--sp,r7
8000c00c:	a1 7b       	lsl	r11,0x1
8000c00e:	5f 3c       	srlo	r12
8000c010:	a1 79       	lsl	r9,0x1
8000c012:	5f 37       	srlo	r7
8000c014:	5c fc       	rol	r12
8000c016:	fc 1e ff e0 	movh	lr,0xffe0
8000c01a:	58 0a       	cp.w	r10,0
8000c01c:	fc 0b 13 00 	cpc	r11,lr
8000c020:	e0 8b 00 1d 	brhi	8000c05a <__avr32_f64_cmp_lt+0x52>
8000c024:	58 08       	cp.w	r8,0
8000c026:	fc 09 13 00 	cpc	r9,lr
8000c02a:	e0 8b 00 18 	brhi	8000c05a <__avr32_f64_cmp_lt+0x52>
8000c02e:	58 0b       	cp.w	r11,0
8000c030:	f5 ba 00 00 	subfeq	r10,0
8000c034:	c1 50       	breq	8000c05e <__avr32_f64_cmp_lt+0x56>
8000c036:	1b 07       	ld.w	r7,sp++
8000c038:	1b 0e       	ld.w	lr,sp++
8000c03a:	58 3c       	cp.w	r12,3
8000c03c:	c0 a0       	breq	8000c050 <__avr32_f64_cmp_lt+0x48>
8000c03e:	58 1c       	cp.w	r12,1
8000c040:	c0 33       	brcs	8000c046 <__avr32_f64_cmp_lt+0x3e>
8000c042:	5e 0d       	reteq	0
8000c044:	5e 1f       	retne	1
8000c046:	10 3a       	cp.w	r10,r8
8000c048:	f2 0b 13 00 	cpc	r11,r9
8000c04c:	5e 2d       	reths	0
8000c04e:	5e 3f       	retlo	1
8000c050:	14 38       	cp.w	r8,r10
8000c052:	f6 09 13 00 	cpc	r9,r11
8000c056:	5e 2d       	reths	0
8000c058:	5e 3f       	retlo	1
8000c05a:	1b 07       	ld.w	r7,sp++
8000c05c:	d8 0a       	popm	pc,r12=0
8000c05e:	58 17       	cp.w	r7,1
8000c060:	5f 1c       	srne	r12
8000c062:	58 09       	cp.w	r9,0
8000c064:	f5 b8 00 00 	subfeq	r8,0
8000c068:	1b 07       	ld.w	r7,sp++
8000c06a:	1b 0e       	ld.w	lr,sp++
8000c06c:	5e 0d       	reteq	0
8000c06e:	5e fc       	retal	r12

8000c070 <__avr32_f64_div>:
8000c070:	eb cd 40 ff 	pushm	r0-r7,lr
8000c074:	f7 e9 20 0e 	eor	lr,r11,r9
8000c078:	f6 07 16 14 	lsr	r7,r11,0x14
8000c07c:	a9 7b       	lsl	r11,0x9
8000c07e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c082:	a9 7a       	lsl	r10,0x9
8000c084:	bd bb       	sbr	r11,0x1d
8000c086:	e4 1b 3f ff 	andh	r11,0x3fff
8000c08a:	ab d7       	cbr	r7,0xb
8000c08c:	e0 80 00 cc 	breq	8000c224 <__avr32_f64_div_round_subnormal+0x54>
8000c090:	e0 47 07 ff 	cp.w	r7,2047
8000c094:	e0 84 00 b5 	brge	8000c1fe <__avr32_f64_div_round_subnormal+0x2e>
8000c098:	f2 06 16 14 	lsr	r6,r9,0x14
8000c09c:	a9 79       	lsl	r9,0x9
8000c09e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c0a2:	a9 78       	lsl	r8,0x9
8000c0a4:	bd b9       	sbr	r9,0x1d
8000c0a6:	e4 19 3f ff 	andh	r9,0x3fff
8000c0aa:	ab d6       	cbr	r6,0xb
8000c0ac:	e0 80 00 e2 	breq	8000c270 <__avr32_f64_div_round_subnormal+0xa0>
8000c0b0:	e0 46 07 ff 	cp.w	r6,2047
8000c0b4:	e0 84 00 b2 	brge	8000c218 <__avr32_f64_div_round_subnormal+0x48>
8000c0b8:	0c 17       	sub	r7,r6
8000c0ba:	fe 37 fc 01 	sub	r7,-1023
8000c0be:	fc 1c 80 00 	movh	r12,0x8000
8000c0c2:	f8 03 16 01 	lsr	r3,r12,0x1
8000c0c6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c0ca:	5c d4       	com	r4
8000c0cc:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c0d0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0d4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c0d8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0dc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0e0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0e4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c0e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0ec:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c0f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c0f8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0fc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c100:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c104:	e4 09 07 40 	macu.d	r0,r2,r9
8000c108:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c10c:	02 04       	add	r4,r1
8000c10e:	5c 05       	acr	r5
8000c110:	a3 65       	lsl	r5,0x2
8000c112:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c116:	a3 64       	lsl	r4,0x2
8000c118:	5c 34       	neg	r4
8000c11a:	f8 05 01 45 	sbc	r5,r12,r5
8000c11e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c122:	e4 05 07 40 	macu.d	r0,r2,r5
8000c126:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c12a:	02 04       	add	r4,r1
8000c12c:	5c 05       	acr	r5
8000c12e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c132:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c136:	e8 02 15 02 	lsl	r2,r4,0x2
8000c13a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c13e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c142:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c146:	02 04       	add	r4,r1
8000c148:	5c 05       	acr	r5
8000c14a:	a3 65       	lsl	r5,0x2
8000c14c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c150:	a3 64       	lsl	r4,0x2
8000c152:	5c 34       	neg	r4
8000c154:	f8 05 01 45 	sbc	r5,r12,r5
8000c158:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c15c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c160:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c164:	02 04       	add	r4,r1
8000c166:	5c 05       	acr	r5
8000c168:	ea 03 15 02 	lsl	r3,r5,0x2
8000c16c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c170:	e8 02 15 02 	lsl	r2,r4,0x2
8000c174:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c178:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c17c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c180:	02 02       	add	r2,r1
8000c182:	5c 03       	acr	r3
8000c184:	ed b3 00 1c 	bld	r3,0x1c
8000c188:	c0 90       	breq	8000c19a <__avr32_f64_div+0x12a>
8000c18a:	a1 72       	lsl	r2,0x1
8000c18c:	5c f3       	rol	r3
8000c18e:	20 17       	sub	r7,1
8000c190:	a3 9a       	lsr	r10,0x3
8000c192:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c196:	a3 9b       	lsr	r11,0x3
8000c198:	c0 58       	rjmp	8000c1a2 <__avr32_f64_div+0x132>
8000c19a:	a5 8a       	lsr	r10,0x4
8000c19c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c1a0:	a5 8b       	lsr	r11,0x4
8000c1a2:	58 07       	cp.w	r7,0
8000c1a4:	e0 8a 00 8b 	brle	8000c2ba <__avr32_f64_div_res_subnormal>
8000c1a8:	e0 12 ff 00 	andl	r2,0xff00
8000c1ac:	e8 12 00 80 	orl	r2,0x80
8000c1b0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c1b4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c1b8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c1bc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c1c0:	00 05       	add	r5,r0
8000c1c2:	f0 01 00 48 	adc	r8,r8,r1
8000c1c6:	5c 09       	acr	r9
8000c1c8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c1cc:	58 04       	cp.w	r4,0
8000c1ce:	5c 25       	cpc	r5

8000c1d0 <__avr32_f64_div_round_subnormal>:
8000c1d0:	f4 08 13 00 	cpc	r8,r10
8000c1d4:	f6 09 13 00 	cpc	r9,r11
8000c1d8:	5f 36       	srlo	r6
8000c1da:	f8 06 17 00 	moveq	r6,r12
8000c1de:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c1e2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c1e6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c1ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c1ee:	ed be 00 1f 	bld	lr,0x1f
8000c1f2:	ef bb 00 1f 	bst	r11,0x1f
8000c1f6:	0c 0a       	add	r10,r6
8000c1f8:	5c 0b       	acr	r11
8000c1fa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c1fe:	e4 1b 00 0f 	andh	r11,0xf
8000c202:	14 4b       	or	r11,r10
8000c204:	e0 81 00 a7 	brne	8000c352 <__avr32_f64_div_res_subnormal+0x98>
8000c208:	f2 06 16 14 	lsr	r6,r9,0x14
8000c20c:	ab d6       	cbr	r6,0xb
8000c20e:	e0 46 07 ff 	cp.w	r6,2047
8000c212:	e0 81 00 a4 	brne	8000c35a <__avr32_f64_div_res_subnormal+0xa0>
8000c216:	c9 e8       	rjmp	8000c352 <__avr32_f64_div_res_subnormal+0x98>
8000c218:	e4 19 00 0f 	andh	r9,0xf
8000c21c:	10 49       	or	r9,r8
8000c21e:	e0 81 00 9a 	brne	8000c352 <__avr32_f64_div_res_subnormal+0x98>
8000c222:	c9 28       	rjmp	8000c346 <__avr32_f64_div_res_subnormal+0x8c>
8000c224:	a3 7b       	lsl	r11,0x3
8000c226:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c22a:	a3 7a       	lsl	r10,0x3
8000c22c:	f5 eb 10 04 	or	r4,r10,r11
8000c230:	e0 80 00 a0 	breq	8000c370 <__avr32_f64_div_op1_zero>
8000c234:	f6 04 12 00 	clz	r4,r11
8000c238:	c1 70       	breq	8000c266 <__avr32_f64_div_round_subnormal+0x96>
8000c23a:	c0 c3       	brcs	8000c252 <__avr32_f64_div_round_subnormal+0x82>
8000c23c:	e8 05 11 20 	rsub	r5,r4,32
8000c240:	f6 04 09 4b 	lsl	r11,r11,r4
8000c244:	f4 05 0a 45 	lsr	r5,r10,r5
8000c248:	0a 4b       	or	r11,r5
8000c24a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c24e:	08 17       	sub	r7,r4
8000c250:	c0 b8       	rjmp	8000c266 <__avr32_f64_div_round_subnormal+0x96>
8000c252:	f4 04 12 00 	clz	r4,r10
8000c256:	f9 b4 03 00 	movlo	r4,0
8000c25a:	f7 b4 02 e0 	subhs	r4,-32
8000c25e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c262:	30 0a       	mov	r10,0
8000c264:	08 17       	sub	r7,r4
8000c266:	a3 8a       	lsr	r10,0x2
8000c268:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c26c:	a3 8b       	lsr	r11,0x2
8000c26e:	c1 1b       	rjmp	8000c090 <__avr32_f64_div+0x20>
8000c270:	a3 79       	lsl	r9,0x3
8000c272:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c276:	a3 78       	lsl	r8,0x3
8000c278:	f3 e8 10 04 	or	r4,r9,r8
8000c27c:	c6 f0       	breq	8000c35a <__avr32_f64_div_res_subnormal+0xa0>
8000c27e:	f2 04 12 00 	clz	r4,r9
8000c282:	c1 70       	breq	8000c2b0 <__avr32_f64_div_round_subnormal+0xe0>
8000c284:	c0 c3       	brcs	8000c29c <__avr32_f64_div_round_subnormal+0xcc>
8000c286:	e8 05 11 20 	rsub	r5,r4,32
8000c28a:	f2 04 09 49 	lsl	r9,r9,r4
8000c28e:	f0 05 0a 45 	lsr	r5,r8,r5
8000c292:	0a 49       	or	r9,r5
8000c294:	f0 04 09 48 	lsl	r8,r8,r4
8000c298:	08 16       	sub	r6,r4
8000c29a:	c0 b8       	rjmp	8000c2b0 <__avr32_f64_div_round_subnormal+0xe0>
8000c29c:	f0 04 12 00 	clz	r4,r8
8000c2a0:	f9 b4 03 00 	movlo	r4,0
8000c2a4:	f7 b4 02 e0 	subhs	r4,-32
8000c2a8:	f0 04 09 49 	lsl	r9,r8,r4
8000c2ac:	30 08       	mov	r8,0
8000c2ae:	08 16       	sub	r6,r4
8000c2b0:	a3 88       	lsr	r8,0x2
8000c2b2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c2b6:	a3 89       	lsr	r9,0x2
8000c2b8:	cf ca       	rjmp	8000c0b0 <__avr32_f64_div+0x40>

8000c2ba <__avr32_f64_div_res_subnormal>:
8000c2ba:	5c 37       	neg	r7
8000c2bc:	2f f7       	sub	r7,-1
8000c2be:	f1 b7 04 c0 	satu	r7,0x6
8000c2c2:	e0 47 00 20 	cp.w	r7,32
8000c2c6:	c1 54       	brge	8000c2f0 <__avr32_f64_div_res_subnormal+0x36>
8000c2c8:	ee 06 11 20 	rsub	r6,r7,32
8000c2cc:	e4 07 0a 42 	lsr	r2,r2,r7
8000c2d0:	e6 06 09 4c 	lsl	r12,r3,r6
8000c2d4:	18 42       	or	r2,r12
8000c2d6:	e6 07 0a 43 	lsr	r3,r3,r7
8000c2da:	f4 06 09 41 	lsl	r1,r10,r6
8000c2de:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c2e2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c2e6:	18 4a       	or	r10,r12
8000c2e8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c2ec:	30 00       	mov	r0,0
8000c2ee:	c1 58       	rjmp	8000c318 <__avr32_f64_div_res_subnormal+0x5e>
8000c2f0:	ee 06 11 20 	rsub	r6,r7,32
8000c2f4:	f9 b0 00 00 	moveq	r0,0
8000c2f8:	f9 bc 00 00 	moveq	r12,0
8000c2fc:	c0 50       	breq	8000c306 <__avr32_f64_div_res_subnormal+0x4c>
8000c2fe:	f4 06 09 40 	lsl	r0,r10,r6
8000c302:	f6 06 09 4c 	lsl	r12,r11,r6
8000c306:	e6 07 0a 42 	lsr	r2,r3,r7
8000c30a:	30 03       	mov	r3,0
8000c30c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c310:	18 41       	or	r1,r12
8000c312:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c316:	30 0b       	mov	r11,0
8000c318:	e0 12 ff 00 	andl	r2,0xff00
8000c31c:	e8 12 00 80 	orl	r2,0x80
8000c320:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c324:	e4 09 07 46 	macu.d	r6,r2,r9
8000c328:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c32c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c330:	0c 05       	add	r5,r6
8000c332:	f0 07 00 48 	adc	r8,r8,r7
8000c336:	5c 09       	acr	r9
8000c338:	30 07       	mov	r7,0
8000c33a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c33e:	00 34       	cp.w	r4,r0
8000c340:	e2 05 13 00 	cpc	r5,r1
8000c344:	c4 6b       	rjmp	8000c1d0 <__avr32_f64_div_round_subnormal>
8000c346:	1c 9b       	mov	r11,lr
8000c348:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c34c:	30 0a       	mov	r10,0
8000c34e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c352:	3f fb       	mov	r11,-1
8000c354:	30 0a       	mov	r10,0
8000c356:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c35a:	f5 eb 10 04 	or	r4,r10,r11
8000c35e:	c0 90       	breq	8000c370 <__avr32_f64_div_op1_zero>
8000c360:	1c 9b       	mov	r11,lr
8000c362:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c366:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c36a:	30 0a       	mov	r10,0
8000c36c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c370 <__avr32_f64_div_op1_zero>:
8000c370:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c374:	ce f0       	breq	8000c352 <__avr32_f64_div_res_subnormal+0x98>
8000c376:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c37a:	e0 44 07 ff 	cp.w	r4,2047
8000c37e:	ce 41       	brne	8000c346 <__avr32_f64_div_res_subnormal+0x8c>
8000c380:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c384:	ce 10       	breq	8000c346 <__avr32_f64_div_res_subnormal+0x8c>
8000c386:	ce 6b       	rjmp	8000c352 <__avr32_f64_div_res_subnormal+0x98>

8000c388 <__avr32_udiv64>:
8000c388:	d4 31       	pushm	r0-r7,lr
8000c38a:	1a 97       	mov	r7,sp
8000c38c:	20 3d       	sub	sp,12
8000c38e:	10 9c       	mov	r12,r8
8000c390:	12 9e       	mov	lr,r9
8000c392:	14 93       	mov	r3,r10
8000c394:	58 09       	cp.w	r9,0
8000c396:	e0 81 00 bd 	brne	8000c510 <__avr32_udiv64+0x188>
8000c39a:	16 38       	cp.w	r8,r11
8000c39c:	e0 88 00 40 	brls	8000c41c <__avr32_udiv64+0x94>
8000c3a0:	f0 08 12 00 	clz	r8,r8
8000c3a4:	c0 d0       	breq	8000c3be <__avr32_udiv64+0x36>
8000c3a6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3aa:	f0 09 11 20 	rsub	r9,r8,32
8000c3ae:	f8 08 09 4c 	lsl	r12,r12,r8
8000c3b2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c3b6:	f4 08 09 43 	lsl	r3,r10,r8
8000c3ba:	f3 eb 10 0b 	or	r11,r9,r11
8000c3be:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c3c2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c3c6:	f6 0e 0d 00 	divu	r0,r11,lr
8000c3ca:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c3ce:	00 99       	mov	r9,r0
8000c3d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c3d4:	e0 0a 02 48 	mul	r8,r0,r10
8000c3d8:	10 3b       	cp.w	r11,r8
8000c3da:	c0 a2       	brcc	8000c3ee <__avr32_udiv64+0x66>
8000c3dc:	20 19       	sub	r9,1
8000c3de:	18 0b       	add	r11,r12
8000c3e0:	18 3b       	cp.w	r11,r12
8000c3e2:	c0 63       	brcs	8000c3ee <__avr32_udiv64+0x66>
8000c3e4:	10 3b       	cp.w	r11,r8
8000c3e6:	f7 b9 03 01 	sublo	r9,1
8000c3ea:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c3ee:	f6 08 01 01 	sub	r1,r11,r8
8000c3f2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c3f6:	e2 0e 0d 00 	divu	r0,r1,lr
8000c3fa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c3fe:	00 98       	mov	r8,r0
8000c400:	e0 0a 02 4a 	mul	r10,r0,r10
8000c404:	14 33       	cp.w	r3,r10
8000c406:	c0 82       	brcc	8000c416 <__avr32_udiv64+0x8e>
8000c408:	20 18       	sub	r8,1
8000c40a:	18 03       	add	r3,r12
8000c40c:	18 33       	cp.w	r3,r12
8000c40e:	c0 43       	brcs	8000c416 <__avr32_udiv64+0x8e>
8000c410:	14 33       	cp.w	r3,r10
8000c412:	f7 b8 03 01 	sublo	r8,1
8000c416:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c41a:	cd f8       	rjmp	8000c5d8 <__avr32_udiv64+0x250>
8000c41c:	58 08       	cp.w	r8,0
8000c41e:	c0 51       	brne	8000c428 <__avr32_udiv64+0xa0>
8000c420:	30 19       	mov	r9,1
8000c422:	f2 08 0d 08 	divu	r8,r9,r8
8000c426:	10 9c       	mov	r12,r8
8000c428:	f8 06 12 00 	clz	r6,r12
8000c42c:	c0 41       	brne	8000c434 <__avr32_udiv64+0xac>
8000c42e:	18 1b       	sub	r11,r12
8000c430:	30 19       	mov	r9,1
8000c432:	c4 08       	rjmp	8000c4b2 <__avr32_udiv64+0x12a>
8000c434:	ec 01 11 20 	rsub	r1,r6,32
8000c438:	f4 01 0a 49 	lsr	r9,r10,r1
8000c43c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c440:	f6 06 09 48 	lsl	r8,r11,r6
8000c444:	f6 01 0a 41 	lsr	r1,r11,r1
8000c448:	f3 e8 10 08 	or	r8,r9,r8
8000c44c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c450:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c454:	e2 03 0d 00 	divu	r0,r1,r3
8000c458:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c45c:	00 9e       	mov	lr,r0
8000c45e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c462:	e0 05 02 49 	mul	r9,r0,r5
8000c466:	12 3b       	cp.w	r11,r9
8000c468:	c0 a2       	brcc	8000c47c <__avr32_udiv64+0xf4>
8000c46a:	20 1e       	sub	lr,1
8000c46c:	18 0b       	add	r11,r12
8000c46e:	18 3b       	cp.w	r11,r12
8000c470:	c0 63       	brcs	8000c47c <__avr32_udiv64+0xf4>
8000c472:	12 3b       	cp.w	r11,r9
8000c474:	f7 be 03 01 	sublo	lr,1
8000c478:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c47c:	12 1b       	sub	r11,r9
8000c47e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c482:	f6 03 0d 02 	divu	r2,r11,r3
8000c486:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c48a:	04 99       	mov	r9,r2
8000c48c:	e4 05 02 4b 	mul	r11,r2,r5
8000c490:	16 38       	cp.w	r8,r11
8000c492:	c0 a2       	brcc	8000c4a6 <__avr32_udiv64+0x11e>
8000c494:	20 19       	sub	r9,1
8000c496:	18 08       	add	r8,r12
8000c498:	18 38       	cp.w	r8,r12
8000c49a:	c0 63       	brcs	8000c4a6 <__avr32_udiv64+0x11e>
8000c49c:	16 38       	cp.w	r8,r11
8000c49e:	f7 b9 03 01 	sublo	r9,1
8000c4a2:	f1 dc e3 08 	addcs	r8,r8,r12
8000c4a6:	f4 06 09 43 	lsl	r3,r10,r6
8000c4aa:	f0 0b 01 0b 	sub	r11,r8,r11
8000c4ae:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c4b2:	f8 06 16 10 	lsr	r6,r12,0x10
8000c4b6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c4ba:	f6 06 0d 00 	divu	r0,r11,r6
8000c4be:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c4c2:	00 9a       	mov	r10,r0
8000c4c4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c4c8:	e0 0e 02 48 	mul	r8,r0,lr
8000c4cc:	10 3b       	cp.w	r11,r8
8000c4ce:	c0 a2       	brcc	8000c4e2 <__avr32_udiv64+0x15a>
8000c4d0:	20 1a       	sub	r10,1
8000c4d2:	18 0b       	add	r11,r12
8000c4d4:	18 3b       	cp.w	r11,r12
8000c4d6:	c0 63       	brcs	8000c4e2 <__avr32_udiv64+0x15a>
8000c4d8:	10 3b       	cp.w	r11,r8
8000c4da:	f7 ba 03 01 	sublo	r10,1
8000c4de:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c4e2:	f6 08 01 01 	sub	r1,r11,r8
8000c4e6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c4ea:	e2 06 0d 00 	divu	r0,r1,r6
8000c4ee:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c4f2:	00 98       	mov	r8,r0
8000c4f4:	e0 0e 02 4b 	mul	r11,r0,lr
8000c4f8:	16 33       	cp.w	r3,r11
8000c4fa:	c0 82       	brcc	8000c50a <__avr32_udiv64+0x182>
8000c4fc:	20 18       	sub	r8,1
8000c4fe:	18 03       	add	r3,r12
8000c500:	18 33       	cp.w	r3,r12
8000c502:	c0 43       	brcs	8000c50a <__avr32_udiv64+0x182>
8000c504:	16 33       	cp.w	r3,r11
8000c506:	f7 b8 03 01 	sublo	r8,1
8000c50a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c50e:	c6 98       	rjmp	8000c5e0 <__avr32_udiv64+0x258>
8000c510:	16 39       	cp.w	r9,r11
8000c512:	e0 8b 00 65 	brhi	8000c5dc <__avr32_udiv64+0x254>
8000c516:	f2 09 12 00 	clz	r9,r9
8000c51a:	c0 b1       	brne	8000c530 <__avr32_udiv64+0x1a8>
8000c51c:	10 3a       	cp.w	r10,r8
8000c51e:	5f 2a       	srhs	r10
8000c520:	1c 3b       	cp.w	r11,lr
8000c522:	5f b8       	srhi	r8
8000c524:	10 4a       	or	r10,r8
8000c526:	f2 0a 18 00 	cp.b	r10,r9
8000c52a:	c5 90       	breq	8000c5dc <__avr32_udiv64+0x254>
8000c52c:	30 18       	mov	r8,1
8000c52e:	c5 98       	rjmp	8000c5e0 <__avr32_udiv64+0x258>
8000c530:	f0 09 09 46 	lsl	r6,r8,r9
8000c534:	f2 03 11 20 	rsub	r3,r9,32
8000c538:	fc 09 09 4e 	lsl	lr,lr,r9
8000c53c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c540:	f6 09 09 4c 	lsl	r12,r11,r9
8000c544:	f4 03 0a 42 	lsr	r2,r10,r3
8000c548:	ef 46 ff f4 	st.w	r7[-12],r6
8000c54c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c550:	18 42       	or	r2,r12
8000c552:	f1 ee 10 0c 	or	r12,r8,lr
8000c556:	f8 01 16 10 	lsr	r1,r12,0x10
8000c55a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c55e:	e6 01 0d 04 	divu	r4,r3,r1
8000c562:	e4 03 16 10 	lsr	r3,r2,0x10
8000c566:	08 9e       	mov	lr,r4
8000c568:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c56c:	e8 06 02 48 	mul	r8,r4,r6
8000c570:	10 33       	cp.w	r3,r8
8000c572:	c0 a2       	brcc	8000c586 <__avr32_udiv64+0x1fe>
8000c574:	20 1e       	sub	lr,1
8000c576:	18 03       	add	r3,r12
8000c578:	18 33       	cp.w	r3,r12
8000c57a:	c0 63       	brcs	8000c586 <__avr32_udiv64+0x1fe>
8000c57c:	10 33       	cp.w	r3,r8
8000c57e:	f7 be 03 01 	sublo	lr,1
8000c582:	e7 dc e3 03 	addcs	r3,r3,r12
8000c586:	10 13       	sub	r3,r8
8000c588:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c58c:	e6 01 0d 00 	divu	r0,r3,r1
8000c590:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c594:	00 98       	mov	r8,r0
8000c596:	e0 06 02 46 	mul	r6,r0,r6
8000c59a:	0c 3b       	cp.w	r11,r6
8000c59c:	c0 a2       	brcc	8000c5b0 <__avr32_udiv64+0x228>
8000c59e:	20 18       	sub	r8,1
8000c5a0:	18 0b       	add	r11,r12
8000c5a2:	18 3b       	cp.w	r11,r12
8000c5a4:	c0 63       	brcs	8000c5b0 <__avr32_udiv64+0x228>
8000c5a6:	0c 3b       	cp.w	r11,r6
8000c5a8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c5ac:	f7 b8 03 01 	sublo	r8,1
8000c5b0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c5b4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c5b8:	0c 1b       	sub	r11,r6
8000c5ba:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c5be:	06 95       	mov	r5,r3
8000c5c0:	16 35       	cp.w	r5,r11
8000c5c2:	e0 8b 00 0a 	brhi	8000c5d6 <__avr32_udiv64+0x24e>
8000c5c6:	5f 0b       	sreq	r11
8000c5c8:	f4 09 09 49 	lsl	r9,r10,r9
8000c5cc:	12 32       	cp.w	r2,r9
8000c5ce:	5f b9       	srhi	r9
8000c5d0:	f7 e9 00 09 	and	r9,r11,r9
8000c5d4:	c0 60       	breq	8000c5e0 <__avr32_udiv64+0x258>
8000c5d6:	20 18       	sub	r8,1
8000c5d8:	30 09       	mov	r9,0
8000c5da:	c0 38       	rjmp	8000c5e0 <__avr32_udiv64+0x258>
8000c5dc:	30 09       	mov	r9,0
8000c5de:	12 98       	mov	r8,r9
8000c5e0:	10 9a       	mov	r10,r8
8000c5e2:	12 93       	mov	r3,r9
8000c5e4:	10 92       	mov	r2,r8
8000c5e6:	12 9b       	mov	r11,r9
8000c5e8:	2f dd       	sub	sp,-12
8000c5ea:	d8 32       	popm	r0-r7,pc

8000c5ec <__avr32_umod64>:
8000c5ec:	d4 31       	pushm	r0-r7,lr
8000c5ee:	1a 97       	mov	r7,sp
8000c5f0:	20 3d       	sub	sp,12
8000c5f2:	10 9c       	mov	r12,r8
8000c5f4:	12 95       	mov	r5,r9
8000c5f6:	14 9e       	mov	lr,r10
8000c5f8:	16 91       	mov	r1,r11
8000c5fa:	16 96       	mov	r6,r11
8000c5fc:	58 09       	cp.w	r9,0
8000c5fe:	e0 81 00 81 	brne	8000c700 <__avr32_umod64+0x114>
8000c602:	16 38       	cp.w	r8,r11
8000c604:	e0 88 00 12 	brls	8000c628 <__avr32_umod64+0x3c>
8000c608:	f0 08 12 00 	clz	r8,r8
8000c60c:	c4 e0       	breq	8000c6a8 <__avr32_umod64+0xbc>
8000c60e:	f6 08 09 46 	lsl	r6,r11,r8
8000c612:	f8 08 09 4c 	lsl	r12,r12,r8
8000c616:	f0 0b 11 20 	rsub	r11,r8,32
8000c61a:	f4 08 09 4e 	lsl	lr,r10,r8
8000c61e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c622:	f7 e6 10 06 	or	r6,r11,r6
8000c626:	c4 18       	rjmp	8000c6a8 <__avr32_umod64+0xbc>
8000c628:	58 08       	cp.w	r8,0
8000c62a:	c0 51       	brne	8000c634 <__avr32_umod64+0x48>
8000c62c:	30 19       	mov	r9,1
8000c62e:	f2 08 0d 08 	divu	r8,r9,r8
8000c632:	10 9c       	mov	r12,r8
8000c634:	f8 08 12 00 	clz	r8,r12
8000c638:	c0 31       	brne	8000c63e <__avr32_umod64+0x52>
8000c63a:	18 16       	sub	r6,r12
8000c63c:	c3 68       	rjmp	8000c6a8 <__avr32_umod64+0xbc>
8000c63e:	f0 03 11 20 	rsub	r3,r8,32
8000c642:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c646:	f8 08 09 4c 	lsl	r12,r12,r8
8000c64a:	ec 08 09 49 	lsl	r9,r6,r8
8000c64e:	ec 03 0a 43 	lsr	r3,r6,r3
8000c652:	f7 e9 10 09 	or	r9,r11,r9
8000c656:	f8 05 16 10 	lsr	r5,r12,0x10
8000c65a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c65e:	e6 05 0d 02 	divu	r2,r3,r5
8000c662:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c666:	ec 02 02 4b 	mul	r11,r6,r2
8000c66a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c66e:	16 3e       	cp.w	lr,r11
8000c670:	c0 72       	brcc	8000c67e <__avr32_umod64+0x92>
8000c672:	18 0e       	add	lr,r12
8000c674:	18 3e       	cp.w	lr,r12
8000c676:	c0 43       	brcs	8000c67e <__avr32_umod64+0x92>
8000c678:	16 3e       	cp.w	lr,r11
8000c67a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c67e:	fc 0b 01 03 	sub	r3,lr,r11
8000c682:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c686:	e6 05 0d 02 	divu	r2,r3,r5
8000c68a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c68e:	a5 36       	mul	r6,r2
8000c690:	0c 39       	cp.w	r9,r6
8000c692:	c0 72       	brcc	8000c6a0 <__avr32_umod64+0xb4>
8000c694:	18 09       	add	r9,r12
8000c696:	18 39       	cp.w	r9,r12
8000c698:	c0 43       	brcs	8000c6a0 <__avr32_umod64+0xb4>
8000c69a:	0c 39       	cp.w	r9,r6
8000c69c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c6a0:	f2 06 01 06 	sub	r6,r9,r6
8000c6a4:	f4 08 09 4e 	lsl	lr,r10,r8
8000c6a8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c6ac:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c6b0:	ec 0a 0d 02 	divu	r2,r6,r10
8000c6b4:	fc 09 16 10 	lsr	r9,lr,0x10
8000c6b8:	ea 02 02 4b 	mul	r11,r5,r2
8000c6bc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c6c0:	16 39       	cp.w	r9,r11
8000c6c2:	c0 72       	brcc	8000c6d0 <__avr32_umod64+0xe4>
8000c6c4:	18 09       	add	r9,r12
8000c6c6:	18 39       	cp.w	r9,r12
8000c6c8:	c0 43       	brcs	8000c6d0 <__avr32_umod64+0xe4>
8000c6ca:	16 39       	cp.w	r9,r11
8000c6cc:	f3 dc e3 09 	addcs	r9,r9,r12
8000c6d0:	f2 0b 01 0b 	sub	r11,r9,r11
8000c6d4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c6d8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c6dc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c6e0:	ea 0a 02 4a 	mul	r10,r5,r10
8000c6e4:	14 3e       	cp.w	lr,r10
8000c6e6:	c0 72       	brcc	8000c6f4 <__avr32_umod64+0x108>
8000c6e8:	18 0e       	add	lr,r12
8000c6ea:	18 3e       	cp.w	lr,r12
8000c6ec:	c0 43       	brcs	8000c6f4 <__avr32_umod64+0x108>
8000c6ee:	14 3e       	cp.w	lr,r10
8000c6f0:	fd dc e3 0e 	addcs	lr,lr,r12
8000c6f4:	fc 0a 01 0a 	sub	r10,lr,r10
8000c6f8:	30 0b       	mov	r11,0
8000c6fa:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c6fe:	c7 b8       	rjmp	8000c7f4 <__avr32_umod64+0x208>
8000c700:	16 39       	cp.w	r9,r11
8000c702:	e0 8b 00 79 	brhi	8000c7f4 <__avr32_umod64+0x208>
8000c706:	f2 09 12 00 	clz	r9,r9
8000c70a:	c1 21       	brne	8000c72e <__avr32_umod64+0x142>
8000c70c:	10 3a       	cp.w	r10,r8
8000c70e:	5f 2b       	srhs	r11
8000c710:	0a 31       	cp.w	r1,r5
8000c712:	5f ba       	srhi	r10
8000c714:	f7 ea 10 0a 	or	r10,r11,r10
8000c718:	f2 0a 18 00 	cp.b	r10,r9
8000c71c:	c0 60       	breq	8000c728 <__avr32_umod64+0x13c>
8000c71e:	fc 08 01 0c 	sub	r12,lr,r8
8000c722:	e2 05 01 46 	sbc	r6,r1,r5
8000c726:	18 9e       	mov	lr,r12
8000c728:	0c 9b       	mov	r11,r6
8000c72a:	1c 9a       	mov	r10,lr
8000c72c:	c6 48       	rjmp	8000c7f4 <__avr32_umod64+0x208>
8000c72e:	ea 09 09 4c 	lsl	r12,r5,r9
8000c732:	f2 06 11 20 	rsub	r6,r9,32
8000c736:	f6 09 09 4b 	lsl	r11,r11,r9
8000c73a:	f0 09 09 42 	lsl	r2,r8,r9
8000c73e:	ef 46 ff f4 	st.w	r7[-12],r6
8000c742:	f0 06 0a 48 	lsr	r8,r8,r6
8000c746:	18 48       	or	r8,r12
8000c748:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c74c:	f4 09 09 43 	lsl	r3,r10,r9
8000c750:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c754:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c758:	16 4a       	or	r10,r11
8000c75a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c75e:	f8 0b 0d 04 	divu	r4,r12,r11
8000c762:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c766:	08 91       	mov	r1,r4
8000c768:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c76c:	e8 0e 02 46 	mul	r6,r4,lr
8000c770:	0c 3c       	cp.w	r12,r6
8000c772:	c0 a2       	brcc	8000c786 <__avr32_umod64+0x19a>
8000c774:	20 11       	sub	r1,1
8000c776:	10 0c       	add	r12,r8
8000c778:	10 3c       	cp.w	r12,r8
8000c77a:	c0 63       	brcs	8000c786 <__avr32_umod64+0x19a>
8000c77c:	0c 3c       	cp.w	r12,r6
8000c77e:	f7 b1 03 01 	sublo	r1,1
8000c782:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c786:	0c 1c       	sub	r12,r6
8000c788:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c78c:	f8 0b 0d 04 	divu	r4,r12,r11
8000c790:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c794:	08 96       	mov	r6,r4
8000c796:	e8 0e 02 4e 	mul	lr,r4,lr
8000c79a:	1c 3b       	cp.w	r11,lr
8000c79c:	c0 a2       	brcc	8000c7b0 <__avr32_umod64+0x1c4>
8000c79e:	20 16       	sub	r6,1
8000c7a0:	10 0b       	add	r11,r8
8000c7a2:	10 3b       	cp.w	r11,r8
8000c7a4:	c0 63       	brcs	8000c7b0 <__avr32_umod64+0x1c4>
8000c7a6:	1c 3b       	cp.w	r11,lr
8000c7a8:	f7 b6 03 01 	sublo	r6,1
8000c7ac:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c7b0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c7b4:	1c 1b       	sub	r11,lr
8000c7b6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c7ba:	00 9e       	mov	lr,r0
8000c7bc:	02 9c       	mov	r12,r1
8000c7be:	16 3c       	cp.w	r12,r11
8000c7c0:	e0 8b 00 08 	brhi	8000c7d0 <__avr32_umod64+0x1e4>
8000c7c4:	5f 06       	sreq	r6
8000c7c6:	06 30       	cp.w	r0,r3
8000c7c8:	5f ba       	srhi	r10
8000c7ca:	ed ea 00 0a 	and	r10,r6,r10
8000c7ce:	c0 60       	breq	8000c7da <__avr32_umod64+0x1ee>
8000c7d0:	fc 02 01 04 	sub	r4,lr,r2
8000c7d4:	f8 08 01 4c 	sbc	r12,r12,r8
8000c7d8:	08 9e       	mov	lr,r4
8000c7da:	e6 0e 01 0a 	sub	r10,r3,lr
8000c7de:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c7e2:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c7e6:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c7ea:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c7ee:	f8 01 09 4c 	lsl	r12,r12,r1
8000c7f2:	18 4a       	or	r10,r12
8000c7f4:	2f dd       	sub	sp,-12
8000c7f6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 70 3c 	sub	pc,pc,28732

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c4 0f 	rcall	80005124 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c4 08 	rcall	80005124 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c4 01 	rcall	80005124 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c3 fa 	rcall	80005124 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
