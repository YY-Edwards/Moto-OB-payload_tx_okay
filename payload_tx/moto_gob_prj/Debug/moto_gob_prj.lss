
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a490  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c600  8000c600  0000ca00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001208  8000c800  8000c800  0000cc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a40  00000008  8000da08  0000e008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000036c8  00000a48  00000a48  00000000  2**2
                  ALLOC
  8 .heap         00012ef0  00004110  00004110  00000000  2**0
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ea48  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001200  00000000  00000000  0000ea78  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000026e3  00000000  00000000  0000fc78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000294e6  00000000  00000000  0001235b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006a74  00000000  00000000  0003b841  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c449  00000000  00000000  000422b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002ed8  00000000  00000000  0004e700  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007195  00000000  00000000  000515d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d01f  00000000  00000000  0005876d  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 19 .debug_ranges 000012e0  00000000  00000000  00065790  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 94 8c 	sub	pc,pc,-27508

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b4 90 	sub	pc,pc,-19312

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 88       	ld.ub	r8,r6[0x0]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 64       	and	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 14       	sub	r4,17
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 3c       	sub	r12,-125
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	2d c0       	sub	r0,-36
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	43 40       	lddsp	r0,sp[0xd0]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c8 00       	breq	80001f86 <_trampoline+0x1f82>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	62 b4       	ld.w	r4,r1[0x2c]
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 19 	mcall	800020f8 <app_cfg+0x64>
8000209a:	49 98       	lddpc	r8,800020fc <app_cfg+0x68>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 96       	lddpc	r6,80002100 <app_cfg+0x6c>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 94       	lddpc	r4,80002104 <app_cfg+0x70>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 07 d0 	mov	r5,2000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 b1       	brne	800020ee <app_cfg+0x5a>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020ba:	f0 1f 00 14 	mcall	80002108 <app_cfg+0x74>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020be:	68 08       	ld.w	r8,r4[0x0]
800020c0:	58 08       	cp.w	r8,0
800020c2:	c0 51       	brne	800020cc <app_cfg+0x38>
				{
					xcmp_data_session();
800020c4:	f0 1f 00 12 	mcall	8000210c <app_cfg+0x78>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c8:	89 03       	st.w	r4[0x0],r3
800020ca:	c1 28       	rjmp	800020ee <app_cfg+0x5a>
				}
				else if(isAudioRouting == 1)
800020cc:	58 18       	cp.w	r8,1
800020ce:	c0 31       	brne	800020d4 <app_cfg+0x40>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d0:	89 02       	st.w	r4[0x0],r2
800020d2:	c0 e8       	rjmp	800020ee <app_cfg+0x5a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d4:	58 28       	cp.w	r8,2
800020d6:	c0 51       	brne	800020e0 <app_cfg+0x4c>
				{
					xcmp_data_session();
800020d8:	f0 1f 00 0d 	mcall	8000210c <app_cfg+0x78>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020dc:	89 00       	st.w	r4[0x0],r0
800020de:	c0 88       	rjmp	800020ee <app_cfg+0x5a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e0:	58 38       	cp.w	r8,3
800020e2:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020e6:	f7 b8 01 ff 	subne	r8,-1
800020ea:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020ee:	0a 9b       	mov	r11,r5
800020f0:	0e 9c       	mov	r12,r7
800020f2:	f0 1f 00 08 	mcall	80002110 <app_cfg+0x7c>
	}
800020f6:	cd db       	rjmp	800020b0 <app_cfg+0x1c>
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	5f ec       	srqs	r12
800020fc:	00 00       	add	r0,r0
800020fe:	0a 58       	eor	r8,r5
80002100:	00 00       	add	r0,r0
80002102:	0d 88       	ld.ub	r8,r6[0x0]
80002104:	00 00       	add	r0,r0
80002106:	0a 54       	eor	r4,r5
80002108:	80 00       	ld.sh	r0,r0[0x0]
8000210a:	44 a8       	lddsp	r8,sp[0x128]
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	43 94       	lddsp	r4,sp[0xe4]
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	61 54       	ld.w	r4,r0[0x54]

80002114 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002114:	d4 01       	pushm	lr
  log("R");
80002116:	48 3c       	lddpc	r12,80002120 <app_payload_tx_proc+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	c8 08       	rjmp	80002222 <ButtonConfig_brdcst_func+0x1e>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	66 78       	ld.w	r8,r3[0x1c]

80002128 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002128:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000212a:	48 3c       	lddpc	r12,80002134 <FD_brdcst_func+0xc>
8000212c:	f0 1f 00 03 	mcall	80002138 <FD_brdcst_func+0x10>
	
}
80002130:	d8 02       	popm	pc
80002132:	00 00       	add	r0,r0
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	c8 0c       	rcall	80002236 <ButtonConfig_brdcst_func+0x32>
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	66 78       	ld.w	r8,r3[0x1c]

8000213c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000213c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000213e:	48 3c       	lddpc	r12,80002148 <FD_reply_func+0xc>
80002140:	f0 1f 00 03 	mcall	8000214c <FD_reply_func+0x10>
	
	
}
80002144:	d8 02       	popm	pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	c8 2c       	rcall	8000224e <ButtonConfig_brdcst_func+0x4a>
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	66 78       	ld.w	r8,r3[0x1c]

80002150 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002150:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002152:	48 3c       	lddpc	r12,8000215c <FD_request_func+0xc>
80002154:	f0 1f 00 03 	mcall	80002160 <FD_request_func+0x10>
	
	
}
80002158:	d8 02       	popm	pc
8000215a:	00 00       	add	r0,r0
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	c8 48       	rjmp	80002266 <ButtonConfig_brdcst_func+0x62>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	66 78       	ld.w	r8,r3[0x1c]

80002164 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002164:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002166:	48 3c       	lddpc	r12,80002170 <EnOB_brdcst_func+0xc>
80002168:	f0 1f 00 03 	mcall	80002174 <EnOB_brdcst_func+0x10>
}
8000216c:	d8 02       	popm	pc
8000216e:	00 00       	add	r0,r0
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	c8 64       	brge	8000207e <app_init+0x3e>
80002174:	80 00       	ld.sh	r0,r0[0x0]
80002176:	66 78       	ld.w	r8,r3[0x1c]

80002178 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002178:	eb cd 40 80 	pushm	r7,lr
8000217c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000217e:	19 a9       	ld.ub	r9,r12[0x2]
80002180:	30 08       	mov	r8,0
80002182:	f0 09 18 00 	cp.b	r9,r8
80002186:	c1 91       	brne	800021b8 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002188:	19 b8       	ld.ub	r8,r12[0x3]
8000218a:	30 19       	mov	r9,1
8000218c:	f2 08 18 00 	cp.b	r8,r9
80002190:	c0 61       	brne	8000219c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002192:	49 0c       	lddpc	r12,800021d0 <EnOB_reply_func+0x58>
80002194:	f0 1f 00 10 	mcall	800021d4 <EnOB_reply_func+0x5c>
80002198:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000219c:	58 08       	cp.w	r8,0
8000219e:	c0 61       	brne	800021aa <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021a0:	48 ec       	lddpc	r12,800021d8 <EnOB_reply_func+0x60>
800021a2:	f0 1f 00 0d 	mcall	800021d4 <EnOB_reply_func+0x5c>
800021a6:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021aa:	1a d8       	st.w	--sp,r8
800021ac:	48 cc       	lddpc	r12,800021dc <EnOB_reply_func+0x64>
800021ae:	f0 1f 00 0a 	mcall	800021d4 <EnOB_reply_func+0x5c>
800021b2:	2f fd       	sub	sp,-4
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021b8:	48 ac       	lddpc	r12,800021e0 <EnOB_reply_func+0x68>
800021ba:	f0 1f 00 07 	mcall	800021d4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 9c       	lddpc	r12,800021e4 <EnOB_reply_func+0x6c>
800021c4:	f0 1f 00 04 	mcall	800021d4 <EnOB_reply_func+0x5c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c8 7c       	rcall	800022e0 <Phyuserinput_brdcst_func>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	66 78       	ld.w	r8,r3[0x1c]
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c8 94       	brge	800020ec <app_cfg+0x58>
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c8 a8       	rjmp	800022f2 <Phyuserinput_brdcst_func+0x12>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	c8 c0       	breq	800020fa <app_cfg+0x66>
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c8 dc       	rcall	80002300 <Phyuserinput_brdcst_func+0x20>

800021e8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021ea:	19 a9       	ld.ub	r9,r12[0x2]
800021ec:	31 18       	mov	r8,17
800021ee:	f0 09 18 00 	cp.b	r9,r8
800021f2:	c0 41       	brne	800021fa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021f4:	48 2c       	lddpc	r12,800021fc <SingleDetection_brdcst_func+0x14>
800021f6:	f0 1f 00 03 	mcall	80002200 <SingleDetection_brdcst_func+0x18>
800021fa:	d8 02       	popm	pc
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	c8 f4       	brge	8000211c <app_payload_tx_proc+0x8>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	66 78       	ld.w	r8,r3[0x1c]

80002204 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002204:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002206:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000220a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000220c:	4a bc       	lddpc	r12,800022b8 <ButtonConfig_brdcst_func+0xb4>
8000220e:	f0 1f 00 2c 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002212:	0f 88       	ld.ub	r8,r7[0x0]
80002214:	1a d8       	st.w	--sp,r8
80002216:	4a bc       	lddpc	r12,800022c0 <ButtonConfig_brdcst_func+0xbc>
80002218:	f0 1f 00 29 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000221c:	1a d5       	st.w	--sp,r5
8000221e:	4a ac       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xc0>
80002220:	f0 1f 00 27 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002224:	0f a8       	ld.ub	r8,r7[0x2]
80002226:	1a d8       	st.w	--sp,r8
80002228:	4a 8c       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xc4>
8000222a:	f0 1f 00 25 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000222e:	2f dd       	sub	sp,-12
80002230:	58 05       	cp.w	r5,0
80002232:	c4 10       	breq	800022b4 <ButtonConfig_brdcst_func+0xb0>
80002234:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002236:	4a 64       	lddpc	r4,800022cc <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002238:	4a 63       	lddpc	r3,800022d0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000223a:	4a 72       	lddpc	r2,800022d4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000223c:	4a 71       	lddpc	r1,800022d8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	4a 80       	lddpc	r0,800022dc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002240:	0f b9       	ld.ub	r9,r7[0x3]
80002242:	0f c8       	ld.ub	r8,r7[0x4]
80002244:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002248:	1a d8       	st.w	--sp,r8
8000224a:	1a d6       	st.w	--sp,r6
8000224c:	08 9c       	mov	r12,r4
8000224e:	f0 1f 00 1c 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002252:	0f d9       	ld.ub	r9,r7[0x5]
80002254:	0f e8       	ld.ub	r8,r7[0x6]
80002256:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225a:	1a d8       	st.w	--sp,r8
8000225c:	1a d6       	st.w	--sp,r6
8000225e:	06 9c       	mov	r12,r3
80002260:	f0 1f 00 17 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002264:	0f f9       	ld.ub	r9,r7[0x7]
80002266:	ef 38 00 08 	ld.ub	r8,r7[8]
8000226a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226e:	1a d8       	st.w	--sp,r8
80002270:	1a d6       	st.w	--sp,r6
80002272:	04 9c       	mov	r12,r2
80002274:	f0 1f 00 12 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002278:	ef 39 00 09 	ld.ub	r9,r7[9]
8000227c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002280:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002284:	1a d8       	st.w	--sp,r8
80002286:	1a d6       	st.w	--sp,r6
80002288:	02 9c       	mov	r12,r1
8000228a:	f0 1f 00 0d 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000228e:	2f 8d       	sub	sp,-32
80002290:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002294:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002298:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000229c:	1a d8       	st.w	--sp,r8
8000229e:	1a d6       	st.w	--sp,r6
800022a0:	00 9c       	mov	r12,r0
800022a2:	f0 1f 00 07 	mcall	800022bc <ButtonConfig_brdcst_func+0xb8>
800022a6:	2f f6       	sub	r6,-1
800022a8:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022aa:	2f ed       	sub	sp,-8
800022ac:	ec 05 18 00 	cp.b	r5,r6
800022b0:	fe 9b ff c8 	brhi	80002240 <ButtonConfig_brdcst_func+0x3c>
800022b4:	d8 32       	popm	r0-r7,pc
800022b6:	00 00       	add	r0,r0
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c9 08       	rjmp	800023da <DataSession_brdcst_func+0x3e>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	66 78       	ld.w	r8,r3[0x1c]
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	c9 28       	rjmp	800023e6 <DataSession_brdcst_func+0x4a>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c9 3c       	rcall	800023ec <DataSession_brdcst_func+0x50>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c9 54       	brge	800021f4 <SingleDetection_brdcst_func+0xc>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c9 74       	brge	800021fc <SingleDetection_brdcst_func+0x14>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c9 9c       	rcall	80002404 <DataSession_brdcst_func+0x68>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c9 c4       	brge	8000220e <ButtonConfig_brdcst_func+0xa>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c9 e8       	rjmp	80002416 <DataSession_brdcst_func+0x7a>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	ca 10       	breq	80002220 <ButtonConfig_brdcst_func+0x1c>

800022e0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e0:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022e4:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022e6:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022e8:	19 c7       	ld.ub	r7,r12[0x4]
800022ea:	19 d8       	ld.ub	r8,r12[0x5]
800022ec:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022f0:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022f2:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022f4:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022f8:	49 0c       	lddpc	r12,80002338 <Phyuserinput_brdcst_func+0x58>
800022fa:	f0 1f 00 11 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022fe:	1a d6       	st.w	--sp,r6
80002300:	49 0c       	lddpc	r12,80002340 <Phyuserinput_brdcst_func+0x60>
80002302:	f0 1f 00 0f 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002306:	1a d5       	st.w	--sp,r5
80002308:	48 fc       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x64>
8000230a:	f0 1f 00 0d 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000230e:	5c 77       	castu.h	r7
80002310:	1a d7       	st.w	--sp,r7
80002312:	48 ec       	lddpc	r12,80002348 <Phyuserinput_brdcst_func+0x68>
80002314:	f0 1f 00 0a 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002318:	1a d4       	st.w	--sp,r4
8000231a:	48 dc       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x6c>
8000231c:	f0 1f 00 08 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002320:	1a d3       	st.w	--sp,r3
80002322:	48 cc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x70>
80002324:	f0 1f 00 06 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002328:	1a d2       	st.w	--sp,r2
8000232a:	48 bc       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x74>
8000232c:	f0 1f 00 04 	mcall	8000233c <Phyuserinput_brdcst_func+0x5c>
80002330:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002332:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	ca 34       	brge	80002280 <ButtonConfig_brdcst_func+0x7c>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	66 78       	ld.w	r8,r3[0x1c]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	ca 58       	rjmp	8000248c <CallControl_brdcst_func+0x14>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	ca 70       	breq	80002294 <ButtonConfig_brdcst_func+0x90>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	ca 84       	brge	8000229a <ButtonConfig_brdcst_func+0x96>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	ca 98       	rjmp	800024a0 <CallControl_brdcst_func+0x28>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	ca ac       	rcall	800024a6 <CallControl_brdcst_func+0x2e>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	ca cc       	rcall	800024ae <CallControl_brdcst_func+0x36>

80002358 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002358:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000235c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002360:	0f 89       	ld.ub	r9,r7[0x0]
80002362:	30 08       	mov	r8,0
80002364:	f0 09 18 00 	cp.b	r9,r8
80002368:	c0 c1       	brne	80002380 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000236a:	48 9c       	lddpc	r12,8000238c <ButtonConfig_reply_func+0x34>
8000236c:	f0 1f 00 09 	mcall	80002390 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002370:	0f 98       	ld.ub	r8,r7[0x1]
80002372:	1a d8       	st.w	--sp,r8
80002374:	48 8c       	lddpc	r12,80002394 <ButtonConfig_reply_func+0x3c>
80002376:	f0 1f 00 07 	mcall	80002390 <ButtonConfig_reply_func+0x38>
8000237a:	2f fd       	sub	sp,-4
8000237c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002380:	48 6c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x40>
80002382:	f0 1f 00 04 	mcall	80002390 <ButtonConfig_reply_func+0x38>
80002386:	e3 cd 80 80 	ldm	sp++,r7,pc
8000238a:	00 00       	add	r0,r0
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	ca ec       	rcall	800024ea <TransmitControl_brdcst_func+0x2e>
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	66 78       	ld.w	r8,r3[0x1c]
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	c9 28       	rjmp	800024ba <CallControl_brdcst_func+0x42>
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	cb 04       	brge	800022fa <Phyuserinput_brdcst_func+0x1a>

8000239c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000239c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000239e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023a2:	0d 88       	ld.ub	r8,r6[0x0]
800023a4:	32 49       	mov	r9,36
800023a6:	f2 08 18 00 	cp.b	r8,r9
800023aa:	c2 91       	brne	800023fc <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023ac:	49 7c       	lddpc	r12,80002408 <DataSession_brdcst_func+0x6c>
800023ae:	f0 1f 00 18 	mcall	8000240c <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023b2:	0d a5       	ld.ub	r5,r6[0x2]
800023b4:	0d b8       	ld.ub	r8,r6[0x3]
800023b6:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023ba:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023bc:	0d 98       	ld.ub	r8,r6[0x1]
800023be:	1a d8       	st.w	--sp,r8
800023c0:	49 4c       	lddpc	r12,80002410 <DataSession_brdcst_func+0x74>
800023c2:	f0 1f 00 13 	mcall	8000240c <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023c6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 2c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x78>
800023ce:	f0 1f 00 10 	mcall	8000240c <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023d2:	2f ed       	sub	sp,-8
800023d4:	58 05       	cp.w	r5,0
800023d6:	c1 80       	breq	80002406 <DataSession_brdcst_func+0x6a>
800023d8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023da:	49 04       	lddpc	r4,80002418 <DataSession_brdcst_func+0x7c>
800023dc:	ec 07 00 08 	add	r8,r6,r7
800023e0:	11 c8       	ld.ub	r8,r8[0x4]
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	1a d7       	st.w	--sp,r7
800023e6:	08 9c       	mov	r12,r4
800023e8:	f0 1f 00 09 	mcall	8000240c <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023ec:	2f f7       	sub	r7,-1
800023ee:	5c 57       	castu.b	r7
800023f0:	2f ed       	sub	sp,-8
800023f2:	ee 05 19 00 	cp.h	r5,r7
800023f6:	fe 9b ff f3 	brhi	800023dc <DataSession_brdcst_func+0x40>
800023fa:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023fc:	1a d8       	st.w	--sp,r8
800023fe:	48 8c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x80>
80002400:	f0 1f 00 03 	mcall	8000240c <DataSession_brdcst_func+0x70>
80002404:	2f fd       	sub	sp,-4
80002406:	d8 22       	popm	r4-r7,pc
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	cb 20       	breq	8000236e <ButtonConfig_reply_func+0x16>
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	66 78       	ld.w	r8,r3[0x1c]
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	cb 34       	brge	80002378 <ButtonConfig_reply_func+0x20>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	cb 4c       	rcall	8000257e <AudioRoutingControl_reply_func+0x1a>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	cb 68       	rjmp	80002586 <AudioRoutingControl_reply_func+0x22>
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	cb 80       	breq	8000238e <ButtonConfig_reply_func+0x36>

80002420 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002420:	eb cd 40 80 	pushm	r7,lr
80002424:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002426:	19 a8       	ld.ub	r8,r12[0x2]
80002428:	58 08       	cp.w	r8,0
8000242a:	c0 61       	brne	80002436 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
8000242c:	48 dc       	lddpc	r12,80002460 <DataSession_reply_func+0x40>
8000242e:	f0 1f 00 0e 	mcall	80002464 <DataSession_reply_func+0x44>
80002432:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002436:	1a d8       	st.w	--sp,r8
80002438:	48 cc       	lddpc	r12,80002468 <DataSession_reply_func+0x48>
8000243a:	f0 1f 00 0b 	mcall	80002464 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000243e:	48 cc       	lddpc	r12,8000246c <DataSession_reply_func+0x4c>
80002440:	f0 1f 00 09 	mcall	80002464 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002444:	0f b8       	ld.ub	r8,r7[0x3]
80002446:	1a d8       	st.w	--sp,r8
80002448:	48 ac       	lddpc	r12,80002470 <DataSession_reply_func+0x50>
8000244a:	f0 1f 00 07 	mcall	80002464 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000244e:	0f c8       	ld.ub	r8,r7[0x4]
80002450:	1a d8       	st.w	--sp,r8
80002452:	48 9c       	lddpc	r12,80002474 <DataSession_reply_func+0x54>
80002454:	f0 1f 00 04 	mcall	80002464 <DataSession_reply_func+0x44>
80002458:	2f dd       	sub	sp,-12
8000245a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245e:	00 00       	add	r0,r0
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	cb 94       	brge	800023d4 <DataSession_brdcst_func+0x38>
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	66 78       	ld.w	r8,r3[0x1c]
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	cb a8       	rjmp	800025de <Volume_reply_func+0x4a>
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	cb bc       	rcall	800025e4 <Volume_reply_func+0x50>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	cb d0       	breq	800023ec <DataSession_brdcst_func+0x50>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	cb e0       	breq	800023f2 <DataSession_brdcst_func+0x56>

80002478 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002478:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000247c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002480:	0f 98       	ld.ub	r8,r7[0x1]
80002482:	1a d8       	st.w	--sp,r8
80002484:	48 bc       	lddpc	r12,800024b0 <CallControl_brdcst_func+0x38>
80002486:	f0 1f 00 0c 	mcall	800024b4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000248a:	2f fd       	sub	sp,-4
8000248c:	0f 99       	ld.ub	r9,r7[0x1]
8000248e:	30 38       	mov	r8,3
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c0 41       	brne	8000249c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002496:	30 09       	mov	r9,0
80002498:	48 88       	lddpc	r8,800024b8 <CallControl_brdcst_func+0x40>
8000249a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000249c:	0f 99       	ld.ub	r9,r7[0x1]
8000249e:	30 48       	mov	r8,4
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c0 41       	brne	800024ac <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024a6:	30 19       	mov	r9,1
800024a8:	48 48       	lddpc	r8,800024b8 <CallControl_brdcst_func+0x40>
800024aa:	b0 89       	st.b	r8[0x0],r9
800024ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	cb f0       	breq	80002430 <DataSession_reply_func+0x10>
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	66 78       	ld.w	r8,r3[0x1c]
800024b8:	00 00       	add	r0,r0
800024ba:	0a 5d       	eor	sp,r5

800024bc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024c0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024c4:	0f 99       	ld.ub	r9,r7[0x1]
800024c6:	30 08       	mov	r8,0
800024c8:	f0 09 18 00 	cp.b	r9,r8
800024cc:	c0 71       	brne	800024da <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024ce:	48 ac       	lddpc	r12,800024f4 <TransmitControl_brdcst_func+0x38>
800024d0:	f0 1f 00 0a 	mcall	800024f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024d4:	30 09       	mov	r9,0
800024d6:	48 a8       	lddpc	r8,800024fc <TransmitControl_brdcst_func+0x40>
800024d8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024da:	0f 99       	ld.ub	r9,r7[0x1]
800024dc:	30 18       	mov	r8,1
800024de:	f0 09 18 00 	cp.b	r9,r8
800024e2:	c0 71       	brne	800024f0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024e4:	48 7c       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x44>
800024e6:	f0 1f 00 05 	mcall	800024f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024ea:	30 19       	mov	r9,1
800024ec:	48 48       	lddpc	r8,800024fc <TransmitControl_brdcst_func+0x40>
800024ee:	b0 89       	st.b	r8[0x0],r9
800024f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	cc 08       	rjmp	80002676 <spk_reply_func+0x46>
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	66 78       	ld.w	r8,r3[0x1c]
800024fc:	00 00       	add	r0,r0
800024fe:	0a 5c       	eor	r12,r5
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	cc 20       	breq	80002486 <CallControl_brdcst_func+0xe>

80002504 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002504:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002508:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000250c:	0f 89       	ld.ub	r9,r7[0x0]
8000250e:	30 08       	mov	r8,0
80002510:	f0 09 18 00 	cp.b	r9,r8
80002514:	c1 61       	brne	80002540 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002516:	48 ec       	lddpc	r12,8000254c <TransmitControl_reply_func+0x48>
80002518:	f0 1f 00 0e 	mcall	80002550 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000251c:	0f 98       	ld.ub	r8,r7[0x1]
8000251e:	1a d8       	st.w	--sp,r8
80002520:	48 dc       	lddpc	r12,80002554 <TransmitControl_reply_func+0x50>
80002522:	f0 1f 00 0c 	mcall	80002550 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002526:	0f a8       	ld.ub	r8,r7[0x2]
80002528:	1a d8       	st.w	--sp,r8
8000252a:	48 cc       	lddpc	r12,80002558 <TransmitControl_reply_func+0x54>
8000252c:	f0 1f 00 09 	mcall	80002550 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002530:	0f b8       	ld.ub	r8,r7[0x3]
80002532:	1a d8       	st.w	--sp,r8
80002534:	48 ac       	lddpc	r12,8000255c <TransmitControl_reply_func+0x58>
80002536:	f0 1f 00 07 	mcall	80002550 <TransmitControl_reply_func+0x4c>
8000253a:	2f dd       	sub	sp,-12
8000253c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002540:	48 8c       	lddpc	r12,80002560 <TransmitControl_reply_func+0x5c>
80002542:	f0 1f 00 04 	mcall	80002550 <TransmitControl_reply_func+0x4c>
80002546:	e3 cd 80 80 	ldm	sp++,r7,pc
8000254a:	00 00       	add	r0,r0
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	cc 34       	brge	800024d4 <TransmitControl_brdcst_func+0x18>
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	66 78       	ld.w	r8,r3[0x1c]
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	cc 50       	breq	800024e0 <TransmitControl_brdcst_func+0x24>
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	cc 64       	brge	800024e6 <TransmitControl_brdcst_func+0x2a>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	cc 80       	breq	800024ee <TransmitControl_brdcst_func+0x32>
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	cc 90       	breq	800024f4 <TransmitControl_brdcst_func+0x38>

80002564 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002564:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002566:	19 a9       	ld.ub	r9,r12[0x2]
80002568:	30 08       	mov	r8,0
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 71       	brne	8000257c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002570:	48 5c       	lddpc	r12,80002584 <AudioRoutingControl_reply_func+0x20>
80002572:	f0 1f 00 06 	mcall	80002588 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002576:	f0 1f 00 06 	mcall	8000258c <AudioRoutingControl_reply_func+0x28>
8000257a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000257c:	48 5c       	lddpc	r12,80002590 <AudioRoutingControl_reply_func+0x2c>
8000257e:	f0 1f 00 03 	mcall	80002588 <AudioRoutingControl_reply_func+0x24>
80002582:	d8 02       	popm	pc
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	cc a8       	rjmp	8000271a <mic_reply_func+0x4a>
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	66 78       	ld.w	r8,r3[0x1c]
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	44 a8       	lddsp	r8,sp[0x128]
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	cc b8       	rjmp	80002728 <mic_reply_func+0x58>

80002594 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002594:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002598:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000259c:	0f 89       	ld.ub	r9,r7[0x0]
8000259e:	30 08       	mov	r8,0
800025a0:	f0 09 18 00 	cp.b	r9,r8
800025a4:	c1 b1       	brne	800025da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025a6:	0f b8       	ld.ub	r8,r7[0x3]
800025a8:	31 09       	mov	r9,16
800025aa:	f2 08 18 00 	cp.b	r8,r9
800025ae:	c0 f1       	brne	800025cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025b0:	48 dc       	lddpc	r12,800025e4 <Volume_reply_func+0x50>
800025b2:	f0 1f 00 0e 	mcall	800025e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025b6:	0f 99       	ld.ub	r9,r7[0x1]
800025b8:	0f a8       	ld.ub	r8,r7[0x2]
800025ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025be:	1a d8       	st.w	--sp,r8
800025c0:	48 bc       	lddpc	r12,800025ec <Volume_reply_func+0x58>
800025c2:	f0 1f 00 0a 	mcall	800025e8 <Volume_reply_func+0x54>
800025c6:	2f fd       	sub	sp,-4
800025c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025cc:	1a d8       	st.w	--sp,r8
800025ce:	48 9c       	lddpc	r12,800025f0 <Volume_reply_func+0x5c>
800025d0:	f0 1f 00 06 	mcall	800025e8 <Volume_reply_func+0x54>
800025d4:	2f fd       	sub	sp,-4
800025d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025da:	48 7c       	lddpc	r12,800025f4 <Volume_reply_func+0x60>
800025dc:	f0 1f 00 03 	mcall	800025e8 <Volume_reply_func+0x54>
800025e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	cc cc       	rcall	8000277e <dcm_brdcst_func+0x1a>
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	66 78       	ld.w	r8,r3[0x1c]
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	cc e0       	breq	8000258a <AudioRoutingControl_reply_func+0x26>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	cc fc       	rcall	80002790 <dcm_brdcst_func+0x2c>
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	cd 14       	brge	80002598 <Volume_reply_func+0x4>

800025f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025fa:	19 d9       	ld.ub	r9,r12[0x5]
800025fc:	30 08       	mov	r8,0
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 81       	brne	80002612 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002604:	10 99       	mov	r9,r8
80002606:	48 78       	lddpc	r8,80002620 <spk_brdcst_func+0x28>
80002608:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000260a:	48 7c       	lddpc	r12,80002624 <spk_brdcst_func+0x2c>
8000260c:	f0 1f 00 07 	mcall	80002628 <spk_brdcst_func+0x30>
80002610:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002612:	30 19       	mov	r9,1
80002614:	48 38       	lddpc	r8,80002620 <spk_brdcst_func+0x28>
80002616:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002618:	48 5c       	lddpc	r12,8000262c <spk_brdcst_func+0x34>
8000261a:	f0 1f 00 04 	mcall	80002628 <spk_brdcst_func+0x30>
8000261e:	d8 02       	popm	pc
80002620:	00 00       	add	r0,r0
80002622:	0a 48       	or	r8,r5
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	cd 2c       	rcall	800027ca <dcm_reply_func+0x1e>
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	66 78       	ld.w	r8,r3[0x1c]
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	cd 3c       	rcall	800027d4 <dcm_reply_func+0x28>

80002630 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002630:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002632:	19 a9       	ld.ub	r9,r12[0x2]
80002634:	30 08       	mov	r8,0
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 f1       	brne	80002658 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000263c:	19 e9       	ld.ub	r9,r12[0x6]
8000263e:	f0 09 18 00 	cp.b	r9,r8
80002642:	c0 40       	breq	8000264a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002644:	30 19       	mov	r9,1
80002646:	48 98       	lddpc	r8,80002668 <spk_reply_func+0x38>
80002648:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000264a:	19 e8       	ld.ub	r8,r12[0x6]
8000264c:	1a d8       	st.w	--sp,r8
8000264e:	48 8c       	lddpc	r12,8000266c <spk_reply_func+0x3c>
80002650:	f0 1f 00 08 	mcall	80002670 <spk_reply_func+0x40>
80002654:	2f fd       	sub	sp,-4
80002656:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002658:	30 09       	mov	r9,0
8000265a:	48 48       	lddpc	r8,80002668 <spk_reply_func+0x38>
8000265c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000265e:	48 6c       	lddpc	r12,80002674 <spk_reply_func+0x44>
80002660:	f0 1f 00 04 	mcall	80002670 <spk_reply_func+0x40>
80002664:	d8 02       	popm	pc
80002666:	00 00       	add	r0,r0
80002668:	00 00       	add	r0,r0
8000266a:	0a 48       	or	r8,r5
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	cd 48       	rjmp	80002816 <ToneControl_reply_func+0x2>
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	66 78       	ld.w	r8,r3[0x1c]
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	cd 58       	rjmp	80002820 <ToneControl_reply_func+0xc>

80002678 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002678:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000267c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002680:	0f a9       	ld.ub	r9,r7[0x2]
80002682:	30 08       	mov	r8,0
80002684:	f0 09 18 00 	cp.b	r9,r8
80002688:	c0 71       	brne	80002696 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000268a:	48 dc       	lddpc	r12,800026bc <mic_brdcst_func+0x44>
8000268c:	f0 1f 00 0d 	mcall	800026c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002690:	30 09       	mov	r9,0
80002692:	48 d8       	lddpc	r8,800026c4 <mic_brdcst_func+0x4c>
80002694:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002696:	0f a9       	ld.ub	r9,r7[0x2]
80002698:	31 18       	mov	r8,17
8000269a:	f0 09 18 00 	cp.b	r9,r8
8000269e:	c0 d1       	brne	800026b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026a0:	48 ac       	lddpc	r12,800026c8 <mic_brdcst_func+0x50>
800026a2:	f0 1f 00 08 	mcall	800026c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026a6:	48 89       	lddpc	r9,800026c4 <mic_brdcst_func+0x4c>
800026a8:	30 18       	mov	r8,1
800026aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026ac:	13 89       	ld.ub	r9,r9[0x0]
800026ae:	f0 09 18 00 	cp.b	r9,r8
800026b2:	c0 31       	brne	800026b8 <mic_brdcst_func+0x40>
800026b4:	48 68       	lddpc	r8,800026cc <mic_brdcst_func+0x54>
800026b6:	11 88       	ld.ub	r8,r8[0x0]
800026b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	cd 64       	brge	8000266a <spk_reply_func+0x3a>
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	66 78       	ld.w	r8,r3[0x1c]
800026c4:	00 00       	add	r0,r0
800026c6:	0a 61       	and	r1,r5
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	cd 78       	rjmp	80002878 <app_payload_rx_proc+0x3c>
800026cc:	00 00       	add	r0,r0
800026ce:	0a 5d       	eor	sp,r5

800026d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026d8:	49 ac       	lddpc	r12,80002740 <mic_reply_func+0x70>
800026da:	f0 1f 00 1b 	mcall	80002744 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026de:	0f 89       	ld.ub	r9,r7[0x0]
800026e0:	30 08       	mov	r8,0
800026e2:	f0 09 18 00 	cp.b	r9,r8
800026e6:	c2 71       	brne	80002734 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026e8:	0f 98       	ld.ub	r8,r7[0x1]
800026ea:	30 29       	mov	r9,2
800026ec:	f2 08 18 00 	cp.b	r8,r9
800026f0:	c1 b1       	brne	80002726 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026f2:	49 6c       	lddpc	r12,80002748 <mic_reply_func+0x78>
800026f4:	f0 1f 00 14 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026f8:	0f a8       	ld.ub	r8,r7[0x2]
800026fa:	1a d8       	st.w	--sp,r8
800026fc:	49 4c       	lddpc	r12,8000274c <mic_reply_func+0x7c>
800026fe:	f0 1f 00 12 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002702:	0f b8       	ld.ub	r8,r7[0x3]
80002704:	1a d8       	st.w	--sp,r8
80002706:	49 3c       	lddpc	r12,80002750 <mic_reply_func+0x80>
80002708:	f0 1f 00 0f 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000270c:	0f c8       	ld.ub	r8,r7[0x4]
8000270e:	1a d8       	st.w	--sp,r8
80002710:	49 1c       	lddpc	r12,80002754 <mic_reply_func+0x84>
80002712:	f0 1f 00 0d 	mcall	80002744 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002716:	0f d8       	ld.ub	r8,r7[0x5]
80002718:	1a d8       	st.w	--sp,r8
8000271a:	49 0c       	lddpc	r12,80002758 <mic_reply_func+0x88>
8000271c:	f0 1f 00 0a 	mcall	80002744 <mic_reply_func+0x74>
80002720:	2f cd       	sub	sp,-16
80002722:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002726:	1a d8       	st.w	--sp,r8
80002728:	48 dc       	lddpc	r12,8000275c <mic_reply_func+0x8c>
8000272a:	f0 1f 00 07 	mcall	80002744 <mic_reply_func+0x74>
8000272e:	2f fd       	sub	sp,-4
80002730:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002734:	48 bc       	lddpc	r12,80002760 <mic_reply_func+0x90>
80002736:	f0 1f 00 04 	mcall	80002744 <mic_reply_func+0x74>
8000273a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000273e:	00 00       	add	r0,r0
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	cd 8c       	rcall	800028f2 <send_flash_command+0xa>
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	66 78       	ld.w	r8,r3[0x1c]
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	cd 9c       	rcall	800028fc <send_flash_command+0x14>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	cd b0       	breq	80002704 <mic_reply_func+0x34>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	cd c4       	brge	8000270a <mic_reply_func+0x3a>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	cd e0       	breq	80002712 <mic_reply_func+0x42>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	cd f8       	rjmp	80002918 <send_flash_command+0x30>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	ce 10       	breq	80002720 <mic_reply_func+0x50>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	ce 28       	rjmp	80002926 <send_flash_command+0x3e>

80002764 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002764:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002768:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000276c:	48 bc       	lddpc	r12,80002798 <dcm_brdcst_func+0x34>
8000276e:	f0 1f 00 0c 	mcall	8000279c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002772:	0f 88       	ld.ub	r8,r7[0x0]
80002774:	1a d8       	st.w	--sp,r8
80002776:	48 bc       	lddpc	r12,800027a0 <dcm_brdcst_func+0x3c>
80002778:	f0 1f 00 09 	mcall	8000279c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000277c:	0f a8       	ld.ub	r8,r7[0x2]
8000277e:	1a d8       	st.w	--sp,r8
80002780:	48 9c       	lddpc	r12,800027a4 <dcm_brdcst_func+0x40>
80002782:	f0 1f 00 07 	mcall	8000279c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002786:	0f 98       	ld.ub	r8,r7[0x1]
80002788:	1a d8       	st.w	--sp,r8
8000278a:	48 8c       	lddpc	r12,800027a8 <dcm_brdcst_func+0x44>
8000278c:	f0 1f 00 04 	mcall	8000279c <dcm_brdcst_func+0x38>
80002790:	2f dd       	sub	sp,-12
	
	
}
80002792:	e3 cd 80 80 	ldm	sp++,r7,pc
80002796:	00 00       	add	r0,r0
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	ce 38       	rjmp	80002960 <send_flash_command+0x78>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	66 78       	ld.w	r8,r3[0x1c]
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	ce 4c       	rcall	8000296a <send_flash_command+0x82>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	ce 60       	breq	80002772 <dcm_brdcst_func+0xe>
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	ce 78       	rjmp	80002978 <send_flash_command+0x90>

800027ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027ac:	eb cd 40 80 	pushm	r7,lr
800027b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027b2:	19 a9       	ld.ub	r9,r12[0x2]
800027b4:	30 08       	mov	r8,0
800027b6:	f0 09 18 00 	cp.b	r9,r8
800027ba:	c1 b1       	brne	800027f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027bc:	19 b8       	ld.ub	r8,r12[0x3]
800027be:	30 19       	mov	r9,1
800027c0:	f2 08 18 00 	cp.b	r8,r9
800027c4:	c0 51       	brne	800027ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027c6:	48 ec       	lddpc	r12,800027fc <dcm_reply_func+0x50>
800027c8:	f0 1f 00 0e 	mcall	80002800 <dcm_reply_func+0x54>
800027cc:	c0 a8       	rjmp	800027e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027ce:	58 08       	cp.w	r8,0
800027d0:	c0 51       	brne	800027da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027d2:	48 dc       	lddpc	r12,80002804 <dcm_reply_func+0x58>
800027d4:	f0 1f 00 0b 	mcall	80002800 <dcm_reply_func+0x54>
800027d8:	c0 48       	rjmp	800027e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027da:	48 cc       	lddpc	r12,80002808 <dcm_reply_func+0x5c>
800027dc:	f0 1f 00 09 	mcall	80002800 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027e0:	0f d8       	ld.ub	r8,r7[0x5]
800027e2:	1a d8       	st.w	--sp,r8
800027e4:	48 ac       	lddpc	r12,8000280c <dcm_reply_func+0x60>
800027e6:	f0 1f 00 07 	mcall	80002800 <dcm_reply_func+0x54>
800027ea:	2f fd       	sub	sp,-4
800027ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027f0:	48 8c       	lddpc	r12,80002810 <dcm_reply_func+0x64>
800027f2:	f0 1f 00 04 	mcall	80002800 <dcm_reply_func+0x54>
800027f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027fa:	00 00       	add	r0,r0
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	ce 94       	brge	800027d0 <dcm_reply_func+0x24>
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	66 78       	ld.w	r8,r3[0x1c]
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	ce a8       	rjmp	800029da <send_flash_command+0xf2>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	ce bc       	rcall	800029e0 <send_flash_command+0xf8>
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	ce d0       	breq	800027e8 <dcm_reply_func+0x3c>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	ce dc       	rcall	800029ec <send_flash_command+0x104>

80002814 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002814:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002816:	19 a9       	ld.ub	r9,r12[0x2]
80002818:	30 08       	mov	r8,0
8000281a:	f0 09 18 00 	cp.b	r9,r8
8000281e:	c0 51       	brne	80002828 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002820:	48 4c       	lddpc	r12,80002830 <ToneControl_reply_func+0x1c>
80002822:	f0 1f 00 05 	mcall	80002834 <ToneControl_reply_func+0x20>
80002826:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002828:	48 4c       	lddpc	r12,80002838 <ToneControl_reply_func+0x24>
8000282a:	f0 1f 00 03 	mcall	80002834 <ToneControl_reply_func+0x20>
8000282e:	d8 02       	popm	pc
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	ce e8       	rjmp	80002a0e <send_flash_command+0x126>
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	66 78       	ld.w	r8,r3[0x1c]
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	ce f0       	breq	80002818 <ToneControl_reply_func+0x4>

8000283c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000283c:	eb cd 40 80 	pushm	r7,lr
80002840:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002842:	48 c9       	lddpc	r9,80002870 <app_payload_rx_proc+0x34>
80002844:	13 88       	ld.ub	r8,r9[0x0]
80002846:	2f f8       	sub	r8,-1
80002848:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000284a:	30 39       	mov	r9,3
8000284c:	f2 08 18 00 	cp.b	r8,r9
80002850:	c0 71       	brne	8000285e <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002852:	30 09       	mov	r9,0
80002854:	48 78       	lddpc	r8,80002870 <app_payload_rx_proc+0x34>
80002856:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002858:	48 7c       	lddpc	r12,80002874 <app_payload_rx_proc+0x38>
8000285a:	f0 1f 00 08 	mcall	80002878 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000285e:	48 88       	lddpc	r8,8000287c <app_payload_rx_proc+0x40>
80002860:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002862:	48 88       	lddpc	r8,80002880 <app_payload_rx_proc+0x44>
80002864:	70 0c       	ld.w	r12,r8[0x0]
80002866:	0e 9b       	mov	r11,r7
80002868:	f0 1f 00 07 	mcall	80002884 <app_payload_rx_proc+0x48>

}
8000286c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002870:	00 00       	add	r0,r0
80002872:	0a 60       	and	r0,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	ce fc       	rcall	80002a54 <send_flash_command+0x16c>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	66 78       	ld.w	r8,r3[0x1c]
8000287c:	00 00       	add	r0,r0
8000287e:	0a 62       	and	r2,r5
80002880:	00 00       	add	r0,r0
80002882:	0a 84       	andn	r4,r5
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	2e 98       	sub	r8,-23

80002888 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002888:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000288a:	19 e8       	ld.ub	r8,r12[0x6]
8000288c:	30 19       	mov	r9,1
8000288e:	f2 08 18 00 	cp.b	r8,r9
80002892:	c0 61       	brne	8000289e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002894:	48 98       	lddpc	r8,800028b8 <DeviceInitializationStatus_brdcst_func+0x30>
80002896:	70 09       	ld.w	r9,r8[0x0]
80002898:	a1 a9       	sbr	r9,0x0
8000289a:	91 09       	st.w	r8[0x0],r9
8000289c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000289e:	30 29       	mov	r9,2
800028a0:	f2 08 18 00 	cp.b	r8,r9
800028a4:	c0 80       	breq	800028b4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028a6:	48 58       	lddpc	r8,800028b8 <DeviceInitializationStatus_brdcst_func+0x30>
800028a8:	70 09       	ld.w	r9,r8[0x0]
800028aa:	e0 19 ff fc 	andl	r9,0xfffc
800028ae:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028b0:	f0 1f 00 03 	mcall	800028bc <DeviceInitializationStatus_brdcst_func+0x34>
800028b4:	d8 02       	popm	pc
800028b6:	00 00       	add	r0,r0
800028b8:	00 00       	add	r0,r0
800028ba:	0d 88       	ld.ub	r8,r6[0x0]
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	43 fc       	lddsp	r12,sp[0xfc]

800028c0 <create_data_flash_test_task>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void create_data_flash_test_task()
{
800028c0:	d4 01       	pushm	lr
	xTaskCreate(
800028c2:	30 09       	mov	r9,0
800028c4:	1a d9       	st.w	--sp,r9
800028c6:	1a d9       	st.w	--sp,r9
800028c8:	1a d9       	st.w	--sp,r9
800028ca:	30 28       	mov	r8,2
800028cc:	e0 6a 01 00 	mov	r10,256
800028d0:	48 3b       	lddpc	r11,800028dc <create_data_flash_test_task+0x1c>
800028d2:	48 4c       	lddpc	r12,800028e0 <create_data_flash_test_task+0x20>
800028d4:	f0 1f 00 04 	mcall	800028e4 <create_data_flash_test_task+0x24>
800028d8:	2f dd       	sub	sp,-12
			,  (const signed portCHAR *)"DFT"
			,  configMINIMAL_STACK_SIZE
			,  NULL
			,  tskFLASH_PRIORITY
			,  NULL );
}
800028da:	d8 02       	popm	pc
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	cf 1c       	rcall	80002ac0 <test_data_flash+0x1c>
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	2c 0c       	sub	r12,-64
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	62 b4       	ld.w	r4,r1[0x2c]

800028e8 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028e8:	eb cd 40 fc 	pushm	r2-r7,lr
800028ec:	20 1d       	sub	sp,4
800028ee:	18 97       	mov	r7,r12
800028f0:	14 95       	mov	r5,r10
800028f2:	12 96       	mov	r6,r9
	U16 status = 1;
800028f4:	30 18       	mov	r8,1
800028f6:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028f8:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028fc:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002900:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80002904:	30 0b       	mov	r11,0
80002906:	4e 38       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
80002908:	70 0c       	ld.w	r12,r8[0x0]
8000290a:	f0 1f 00 63 	mcall	80002a94 <send_flash_command+0x1ac>

    switch (command)
8000290e:	30 58       	mov	r8,5
80002910:	f0 07 19 00 	cp.h	r7,r8
80002914:	c3 40       	breq	8000297c <send_flash_command+0x94>
80002916:	e0 8b 00 18 	brhi	80002946 <send_flash_command+0x5e>
8000291a:	30 28       	mov	r8,2
8000291c:	f0 07 19 00 	cp.h	r7,r8
80002920:	c5 e0       	breq	800029dc <send_flash_command+0xf4>
80002922:	e0 8b 00 08 	brhi	80002932 <send_flash_command+0x4a>
80002926:	30 18       	mov	r8,1
80002928:	f0 07 19 00 	cp.h	r7,r8
8000292c:	e0 81 00 a9 	brne	80002a7e <send_flash_command+0x196>
80002930:	c9 e8       	rjmp	80002a6c <send_flash_command+0x184>
80002932:	30 38       	mov	r8,3
80002934:	f0 07 19 00 	cp.h	r7,r8
80002938:	c7 20       	breq	80002a1c <send_flash_command+0x134>
8000293a:	30 48       	mov	r8,4
8000293c:	f0 07 19 00 	cp.h	r7,r8
80002940:	e0 81 00 9f 	brne	80002a7e <send_flash_command+0x196>
80002944:	c2 c8       	rjmp	8000299c <send_flash_command+0xb4>
80002946:	35 28       	mov	r8,82
80002948:	f0 07 19 00 	cp.h	r7,r8
8000294c:	c2 f0       	breq	800029aa <send_flash_command+0xc2>
8000294e:	e0 8b 00 0c 	brhi	80002966 <send_flash_command+0x7e>
80002952:	30 68       	mov	r8,6
80002954:	f0 07 19 00 	cp.h	r7,r8
80002958:	c2 20       	breq	8000299c <send_flash_command+0xb4>
8000295a:	32 08       	mov	r8,32
8000295c:	f0 07 19 00 	cp.h	r7,r8
80002960:	e0 81 00 8f 	brne	80002a7e <send_flash_command+0x196>
80002964:	c2 38       	rjmp	800029aa <send_flash_command+0xc2>
80002966:	36 08       	mov	r8,96
80002968:	f0 07 19 00 	cp.h	r7,r8
8000296c:	c3 20       	breq	800029d0 <send_flash_command+0xe8>
8000296e:	e0 68 00 d8 	mov	r8,216
80002972:	f0 07 19 00 	cp.h	r7,r8
80002976:	e0 81 00 84 	brne	80002a7e <send_flash_command+0x196>
8000297a:	c1 88       	rjmp	800029aa <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
8000297c:	4c 57       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
8000297e:	30 5b       	mov	r11,5
80002980:	6e 0c       	ld.w	r12,r7[0x0]
80002982:	f0 1f 00 46 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_dummy();
80002986:	e0 6b 00 ff 	mov	r11,255
8000298a:	6e 0c       	ld.w	r12,r7[0x0]
8000298c:	f0 1f 00 43 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_read_byte(&status);
80002990:	fa cb ff fe 	sub	r11,sp,-2
80002994:	6e 0c       	ld.w	r12,r7[0x0]
80002996:	f0 1f 00 42 	mcall	80002a9c <send_flash_command+0x1b4>
			break;
8000299a:	c7 28       	rjmp	80002a7e <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
8000299c:	0e 9b       	mov	r11,r7
8000299e:	5c 7b       	castu.h	r11
800029a0:	4b c8       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
800029a2:	70 0c       	ld.w	r12,r8[0x0]
800029a4:	f0 1f 00 3d 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029a8:	c6 b8       	rjmp	80002a7e <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800029aa:	4b a6       	lddpc	r6,80002a90 <send_flash_command+0x1a8>
800029ac:	0e 9b       	mov	r11,r7
800029ae:	5c 7b       	castu.h	r11
800029b0:	6c 0c       	ld.w	r12,r6[0x0]
800029b2:	f0 1f 00 3a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029b6:	08 9b       	mov	r11,r4
800029b8:	6c 0c       	ld.w	r12,r6[0x0]
800029ba:	f0 1f 00 38 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029be:	06 9b       	mov	r11,r3
800029c0:	6c 0c       	ld.w	r12,r6[0x0]
800029c2:	f0 1f 00 36 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029c6:	04 9b       	mov	r11,r2
800029c8:	6c 0c       	ld.w	r12,r6[0x0]
800029ca:	f0 1f 00 34 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029ce:	c5 88       	rjmp	80002a7e <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029d0:	36 0b       	mov	r11,96
800029d2:	4b 08       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
800029d4:	70 0c       	ld.w	r12,r8[0x0]
800029d6:	f0 1f 00 31 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029da:	c5 28       	rjmp	80002a7e <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029dc:	4a d7       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
800029de:	30 2b       	mov	r11,2
800029e0:	6e 0c       	ld.w	r12,r7[0x0]
800029e2:	f0 1f 00 2e 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029e6:	08 9b       	mov	r11,r4
800029e8:	6e 0c       	ld.w	r12,r7[0x0]
800029ea:	f0 1f 00 2c 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ee:	06 9b       	mov	r11,r3
800029f0:	6e 0c       	ld.w	r12,r7[0x0]
800029f2:	f0 1f 00 2a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029f6:	04 9b       	mov	r11,r2
800029f8:	6e 0c       	ld.w	r12,r7[0x0]
800029fa:	f0 1f 00 28 	mcall	80002a98 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029fe:	58 06       	cp.w	r6,0
80002a00:	c3 f0       	breq	80002a7e <send_flash_command+0x196>
80002a02:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002a04:	4a 34       	lddpc	r4,80002a90 <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002a06:	0f 3b       	ld.ub	r11,r7++
80002a08:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002a0a:	68 0c       	ld.w	r12,r4[0x0]
80002a0c:	f0 1f 00 23 	mcall	80002a98 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a10:	0e 98       	mov	r8,r7
80002a12:	0a 18       	sub	r8,r5
80002a14:	ec 08 19 00 	cp.h	r8,r6
80002a18:	cf 73       	brcs	80002a06 <send_flash_command+0x11e>
80002a1a:	c3 28       	rjmp	80002a7e <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a1c:	49 d7       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
80002a1e:	30 3b       	mov	r11,3
80002a20:	6e 0c       	ld.w	r12,r7[0x0]
80002a22:	f0 1f 00 1e 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a26:	08 9b       	mov	r11,r4
80002a28:	6e 0c       	ld.w	r12,r7[0x0]
80002a2a:	f0 1f 00 1c 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a2e:	06 9b       	mov	r11,r3
80002a30:	6e 0c       	ld.w	r12,r7[0x0]
80002a32:	f0 1f 00 1a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a36:	04 9b       	mov	r11,r2
80002a38:	6e 0c       	ld.w	r12,r7[0x0]
80002a3a:	f0 1f 00 18 	mcall	80002a98 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a3e:	58 06       	cp.w	r6,0
80002a40:	c1 f0       	breq	80002a7e <send_flash_command+0x196>
80002a42:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a44:	49 34       	lddpc	r4,80002a90 <send_flash_command+0x1a8>
80002a46:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a4a:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a4c:	06 9b       	mov	r11,r3
80002a4e:	68 0c       	ld.w	r12,r4[0x0]
80002a50:	f0 1f 00 12 	mcall	80002a98 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a54:	1a 9b       	mov	r11,sp
80002a56:	68 0c       	ld.w	r12,r4[0x0]
80002a58:	f0 1f 00 11 	mcall	80002a9c <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a5c:	9a 08       	ld.sh	r8,sp[0x0]
80002a5e:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a60:	0e 98       	mov	r8,r7
80002a62:	0a 18       	sub	r8,r5
80002a64:	ec 08 19 00 	cp.h	r8,r6
80002a68:	cf 23       	brcs	80002a4c <send_flash_command+0x164>
80002a6a:	c0 a8       	rjmp	80002a7e <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a6c:	48 97       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
80002a6e:	30 1b       	mov	r11,1
80002a70:	6e 0c       	ld.w	r12,r7[0x0]
80002a72:	f0 1f 00 0a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a76:	30 0b       	mov	r11,0
80002a78:	6e 0c       	ld.w	r12,r7[0x0]
80002a7a:	f0 1f 00 08 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a7e:	30 0b       	mov	r11,0
80002a80:	48 48       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
80002a82:	70 0c       	ld.w	r12,r8[0x0]
80002a84:	f0 1f 00 07 	mcall	80002aa0 <send_flash_command+0x1b8>

	return status;
}
80002a88:	9a 1c       	ld.sh	r12,sp[0x2]
80002a8a:	2f fd       	sub	sp,-4
80002a8c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a90:	00 00       	add	r0,r0
80002a92:	0d 8c       	ld.ub	r12,r6[0x0]
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	4e 84       	lddpc	r4,80002c34 <runDataFlashTest+0x28>
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	4f be       	lddpc	lr,80002c84 <data_flash_init+0x30>
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	4f da       	lddpc	r10,80002c90 <data_flash_init+0x3c>
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	4e d0       	lddpc	r0,80002c54 <data_flash_init>

80002aa4 <test_data_flash>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void test_data_flash(Bool bReadOnlyTest)
{
80002aa4:	eb cd 40 c0 	pushm	r6-r7,lr
80002aa8:	20 2d       	sub	sp,8
	/* write 0x5A5A to address 0x00000000 then read it back */
	U8 data_write_in[2] = {0x5A, 0x5A};
80002aaa:	4d 18       	lddpc	r8,80002bec <test_data_flash+0x148>
80002aac:	90 08       	ld.sh	r8,r8[0x0]
80002aae:	ba 28       	st.h	sp[0x4],r8
	U8 data_read_out[2] = {0, 0};
80002ab0:	30 08       	mov	r8,0
80002ab2:	ba 88       	st.b	sp[0x0],r8
80002ab4:	ba 98       	st.b	sp[0x1],r8
	U32 test_address = 0x00001002;
	U16 status = 1;
	U16 count = 0;

	if (bReadOnlyTest == FALSE)
80002ab6:	58 0c       	cp.w	r12,0
80002ab8:	c7 c1       	brne	80002bb0 <test_data_flash+0x10c>
	{
		/* test both write and read */
		send_flash_command(READ_ARRAY, test_address, data_read_out, 2);
80002aba:	30 29       	mov	r9,2
80002abc:	1a 9a       	mov	r10,sp
80002abe:	e0 6b 10 02 	mov	r11,4098
80002ac2:	30 3c       	mov	r12,3
80002ac4:	f0 1f 00 4b 	mcall	80002bf0 <test_data_flash+0x14c>
		data_read_out[0] = 0;
80002ac8:	30 08       	mov	r8,0
80002aca:	ba 88       	st.b	sp[0x0],r8
		data_read_out[1] = 0;
80002acc:	ba 98       	st.b	sp[0x1],r8

		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002ace:	30 09       	mov	r9,0
80002ad0:	12 9a       	mov	r10,r9
80002ad2:	12 9b       	mov	r11,r9
80002ad4:	30 5c       	mov	r12,5
80002ad6:	f0 1f 00 47 	mcall	80002bf0 <test_data_flash+0x14c>
		status = 0;

		send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002ada:	30 09       	mov	r9,0
80002adc:	12 9a       	mov	r10,r9
80002ade:	12 9b       	mov	r11,r9
80002ae0:	30 6c       	mov	r12,6
80002ae2:	f0 1f 00 44 	mcall	80002bf0 <test_data_flash+0x14c>

		send_flash_command(BLOCK_ERASE_4KB, test_address, NULL, 0);
80002ae6:	30 09       	mov	r9,0
80002ae8:	12 9a       	mov	r10,r9
80002aea:	e0 6b 10 02 	mov	r11,4098
80002aee:	32 0c       	mov	r12,32
80002af0:	f0 1f 00 40 	mcall	80002bf0 <test_data_flash+0x14c>

		do {
			status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002af4:	30 06       	mov	r6,0
80002af6:	30 57       	mov	r7,5
80002af8:	0c 99       	mov	r9,r6
80002afa:	0c 9a       	mov	r10,r6
80002afc:	0c 9b       	mov	r11,r6
80002afe:	0e 9c       	mov	r12,r7
80002b00:	f0 1f 00 3c 	mcall	80002bf0 <test_data_flash+0x14c>
			count++;
		} while((status & STATUS_BUSY) != 0);
80002b04:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b08:	cf 81       	brne	80002af8 <test_data_flash+0x54>
		
		//send_flash_command(WRITE_DISABLE, 0, NULL, 0);
		//read again
		send_flash_command(READ_ARRAY, test_address, data_read_out, 2);
80002b0a:	30 29       	mov	r9,2
80002b0c:	1a 9a       	mov	r10,sp
80002b0e:	e0 6b 10 02 	mov	r11,4098
80002b12:	30 3c       	mov	r12,3
80002b14:	f0 1f 00 37 	mcall	80002bf0 <test_data_flash+0x14c>
		if((data_read_out[0] !=0xFF) | ((data_read_out[1] !=0xFF)) )
80002b18:	3f f8       	mov	r8,-1
80002b1a:	1b 89       	ld.ub	r9,sp[0x0]
80002b1c:	f0 09 18 00 	cp.b	r9,r8
80002b20:	5f 19       	srne	r9
80002b22:	1b 9a       	ld.ub	r10,sp[0x1]
80002b24:	f0 0a 18 00 	cp.b	r10,r8
80002b28:	5f 18       	srne	r8
80002b2a:	f3 e8 10 08 	or	r8,r9,r8
80002b2e:	c0 40       	breq	80002b36 <test_data_flash+0x92>
		{
			log("\n----flash erase fail----\n");			
80002b30:	4b 1c       	lddpc	r12,80002bf4 <test_data_flash+0x150>
80002b32:	f0 1f 00 32 	mcall	80002bf8 <test_data_flash+0x154>
		}
		
		send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b36:	30 09       	mov	r9,0
80002b38:	12 9a       	mov	r10,r9
80002b3a:	12 9b       	mov	r11,r9
80002b3c:	30 6c       	mov	r12,6
80002b3e:	f0 1f 00 2d 	mcall	80002bf0 <test_data_flash+0x14c>

		send_flash_command(BYTE_PROGRAM, test_address, data_write_in, 2);
80002b42:	30 29       	mov	r9,2
80002b44:	fa ca ff fc 	sub	r10,sp,-4
80002b48:	e0 6b 10 02 	mov	r11,4098
80002b4c:	12 9c       	mov	r12,r9
80002b4e:	f0 1f 00 29 	mcall	80002bf0 <test_data_flash+0x14c>

		count = 0;
		do {
			status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b52:	30 06       	mov	r6,0
80002b54:	30 57       	mov	r7,5
80002b56:	0c 99       	mov	r9,r6
80002b58:	0c 9a       	mov	r10,r6
80002b5a:	0c 9b       	mov	r11,r6
80002b5c:	0e 9c       	mov	r12,r7
80002b5e:	f0 1f 00 25 	mcall	80002bf0 <test_data_flash+0x14c>
			count++;
		} while((status & STATUS_BUSY) != 0);
80002b62:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b66:	cf 81       	brne	80002b56 <test_data_flash+0xb2>

		send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b68:	30 09       	mov	r9,0
80002b6a:	12 9a       	mov	r10,r9
80002b6c:	12 9b       	mov	r11,r9
80002b6e:	30 4c       	mov	r12,4
80002b70:	f0 1f 00 20 	mcall	80002bf0 <test_data_flash+0x14c>

		send_flash_command(READ_ARRAY, test_address, data_read_out, 2);
80002b74:	30 29       	mov	r9,2
80002b76:	1a 9a       	mov	r10,sp
80002b78:	e0 6b 10 02 	mov	r11,4098
80002b7c:	30 3c       	mov	r12,3
80002b7e:	f0 1f 00 1d 	mcall	80002bf0 <test_data_flash+0x14c>

		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b82:	30 09       	mov	r9,0
80002b84:	12 9a       	mov	r10,r9
80002b86:	12 9b       	mov	r11,r9
80002b88:	30 5c       	mov	r12,5
80002b8a:	f0 1f 00 1a 	mcall	80002bf0 <test_data_flash+0x14c>


	    if ((data_read_out[0] == 0x5A) || (data_read_out[1] == 0x5A))
80002b8e:	35 a8       	mov	r8,90
80002b90:	1b 89       	ld.ub	r9,sp[0x0]
80002b92:	f0 09 18 00 	cp.b	r9,r8
80002b96:	c0 50       	breq	80002ba0 <test_data_flash+0xfc>
80002b98:	1b 99       	ld.ub	r9,sp[0x1]
80002b9a:	f0 09 18 00 	cp.b	r9,r8
80002b9e:	c0 51       	brne	80002ba8 <test_data_flash+0x104>
	    {
	    	log("\n----Flash r/w test pass----\n");
80002ba0:	49 7c       	lddpc	r12,80002bfc <test_data_flash+0x158>
80002ba2:	f0 1f 00 16 	mcall	80002bf8 <test_data_flash+0x154>
		send_flash_command(READ_ARRAY, test_address, data_read_out, 2);

		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);


	    if ((data_read_out[0] == 0x5A) || (data_read_out[1] == 0x5A))
80002ba6:	c1 f8       	rjmp	80002be4 <test_data_flash+0x140>
	    	log("\n----Flash r/w test pass----\n");
			//print_text_time("Flash r/w test pass", 4);
	    }
	    else
	    {
			log("\n----Flash r/w test fail----\n");
80002ba8:	49 6c       	lddpc	r12,80002c00 <test_data_flash+0x15c>
80002baa:	f0 1f 00 14 	mcall	80002bf8 <test_data_flash+0x154>
80002bae:	c1 b8       	rjmp	80002be4 <test_data_flash+0x140>

	}
	else
	{
        /* read only test */
		data_read_out[0] = 0x0;
80002bb0:	30 08       	mov	r8,0
80002bb2:	ba 88       	st.b	sp[0x0],r8
		data_read_out[1] = 0x0;
80002bb4:	ba 98       	st.b	sp[0x1],r8
		send_flash_command(READ_ARRAY, test_address, data_read_out, 2);
80002bb6:	30 29       	mov	r9,2
80002bb8:	1a 9a       	mov	r10,sp
80002bba:	e0 6b 10 02 	mov	r11,4098
80002bbe:	30 3c       	mov	r12,3
80002bc0:	f0 1f 00 0c 	mcall	80002bf0 <test_data_flash+0x14c>

	    if ((data_read_out[0] != 0x5A) || (data_read_out[1] != 0x5A))
80002bc4:	35 a8       	mov	r8,90
80002bc6:	1b 89       	ld.ub	r9,sp[0x0]
80002bc8:	f0 09 18 00 	cp.b	r9,r8
80002bcc:	c0 51       	brne	80002bd6 <test_data_flash+0x132>
80002bce:	1b 99       	ld.ub	r9,sp[0x1]
80002bd0:	f0 09 18 00 	cp.b	r9,r8
80002bd4:	c0 50       	breq	80002bde <test_data_flash+0x13a>
	    {
	    	//print_text_time("Flash test fail", 4);
			log("\n----Flash read test fail----\n");
80002bd6:	48 cc       	lddpc	r12,80002c04 <test_data_flash+0x160>
80002bd8:	f0 1f 00 08 	mcall	80002bf8 <test_data_flash+0x154>
        /* read only test */
		data_read_out[0] = 0x0;
		data_read_out[1] = 0x0;
		send_flash_command(READ_ARRAY, test_address, data_read_out, 2);

	    if ((data_read_out[0] != 0x5A) || (data_read_out[1] != 0x5A))
80002bdc:	c0 48       	rjmp	80002be4 <test_data_flash+0x140>
	    	//print_text_time("Flash test fail", 4);
			log("\n----Flash read test fail----\n");
		}
	    else
	    {
	    	log("\n----Flash read test pass----\n");
80002bde:	48 bc       	lddpc	r12,80002c08 <test_data_flash+0x164>
80002be0:	f0 1f 00 06 	mcall	80002bf8 <test_data_flash+0x154>
			//print_text_time("Flash test pass", 4);
	    }
	}

	return;
}
80002be4:	2f ed       	sub	sp,-8
80002be6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bea:	00 00       	add	r0,r0
80002bec:	80 00       	ld.sh	r0,r0[0x0]
80002bee:	cf 08       	rjmp	80002dce <payload_init+0xe>
80002bf0:	80 00       	ld.sh	r0,r0[0x0]
80002bf2:	28 e8       	sub	r8,-114
80002bf4:	80 00       	ld.sh	r0,r0[0x0]
80002bf6:	cf 20       	breq	80002bda <test_data_flash+0x136>
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	66 78       	ld.w	r8,r3[0x1c]
80002bfc:	80 00       	ld.sh	r0,r0[0x0]
80002bfe:	cf 3c       	rcall	80002de4 <payload_init+0x24>
80002c00:	80 00       	ld.sh	r0,r0[0x0]
80002c02:	cf 5c       	rcall	80002dec <payload_init+0x2c>
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	cf 7c       	rcall	80002df4 <payload_init+0x34>
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	cf 9c       	rcall	80002dfc <payload_rx_process+0x4>

80002c0c <runDataFlashTest>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void runDataFlashTest( void *pvParameters )
{
80002c0c:	eb cd 40 f8 	pushm	r3-r7,lr
	Bool firstTest = TRUE;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	
	 xLastWakeTime = xTaskGetTickCount();
80002c10:	f0 1f 00 0d 	mcall	80002c44 <runDataFlashTest+0x38>
80002c14:	48 d8       	lddpc	r8,80002c48 <runDataFlashTest+0x3c>
80002c16:	91 0c       	st.w	r8[0x0],r12
80002c18:	30 17       	mov	r7,1
	 
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002c1a:	10 95       	mov	r5,r8
80002c1c:	e0 64 0f a0 	mov	r4,4000
				test_data_flash(FALSE);
				firstTest = FALSE;
			}
			else
			{
				test_data_flash(TRUE);
80002c20:	0e 93       	mov	r3,r7
		if(1)
		{
			if (firstTest)
			{
				// write test for the first time
				test_data_flash(FALSE);
80002c22:	30 06       	mov	r6,0
80002c24:	c0 28       	rjmp	80002c28 <runDataFlashTest+0x1c>
{
	Bool firstTest = TRUE;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	
	 xLastWakeTime = xTaskGetTickCount();
80002c26:	0c 97       	mov	r7,r6
	 
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002c28:	08 9b       	mov	r11,r4
80002c2a:	0a 9c       	mov	r12,r5
80002c2c:	f0 1f 00 08 	mcall	80002c4c <runDataFlashTest+0x40>

		if(1)
		{
			if (firstTest)
80002c30:	58 07       	cp.w	r7,0
80002c32:	c0 50       	breq	80002c3c <runDataFlashTest+0x30>
			{
				// write test for the first time
				test_data_flash(FALSE);
80002c34:	0c 9c       	mov	r12,r6
80002c36:	f0 1f 00 07 	mcall	80002c50 <runDataFlashTest+0x44>
80002c3a:	cf 6b       	rjmp	80002c26 <runDataFlashTest+0x1a>
				firstTest = FALSE;
			}
			else
			{
				test_data_flash(TRUE);
80002c3c:	06 9c       	mov	r12,r3
80002c3e:	f0 1f 00 05 	mcall	80002c50 <runDataFlashTest+0x44>
80002c42:	cf 2b       	rjmp	80002c26 <runDataFlashTest+0x1a>
80002c44:	80 00       	ld.sh	r0,r0[0x0]
80002c46:	5f ec       	srqs	r12
80002c48:	00 00       	add	r0,r0
80002c4a:	0a 68       	and	r8,r5
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	61 54       	ld.w	r4,r0[0x54]
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	2a a4       	sub	r4,-86

80002c54 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002c54:	eb cd 40 c0 	pushm	r6-r7,lr
80002c58:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002c5a:	4c 08       	lddpc	r8,80002d58 <data_flash_init+0x104>
80002c5c:	fa c6 ff fc 	sub	r6,sp,-4
80002c60:	f0 ea 00 00 	ld.d	r10,r8[0]
80002c64:	ec eb 00 00 	st.d	r6[0],r10
80002c68:	f0 e8 00 08 	ld.d	r8,r8[8]
80002c6c:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002c70:	30 4b       	mov	r11,4
80002c72:	4b bc       	lddpc	r12,80002d5c <data_flash_init+0x108>
80002c74:	f0 1f 00 3b 	mcall	80002d60 <data_flash_init+0x10c>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002c78:	31 9c       	mov	r12,25
80002c7a:	f0 1f 00 3b 	mcall	80002d64 <data_flash_init+0x110>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002c7e:	31 9c       	mov	r12,25
80002c80:	f0 1f 00 3a 	mcall	80002d68 <data_flash_init+0x114>

	spi = &AVR32_SPI;
80002c84:	4b a7       	lddpc	r7,80002d6c <data_flash_init+0x118>
80002c86:	fe 7c 24 00 	mov	r12,-56320
80002c8a:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002c8c:	0c 9b       	mov	r11,r6
80002c8e:	f0 1f 00 39 	mcall	80002d70 <data_flash_init+0x11c>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002c92:	30 09       	mov	r9,0
80002c94:	12 9a       	mov	r10,r9
80002c96:	12 9b       	mov	r11,r9
80002c98:	6e 0c       	ld.w	r12,r7[0x0]
80002c9a:	f0 1f 00 37 	mcall	80002d74 <data_flash_init+0x120>

	// Enable SPI.
	spi_enable(spi);
80002c9e:	6e 0c       	ld.w	r12,r7[0x0]
80002ca0:	f0 1f 00 36 	mcall	80002d78 <data_flash_init+0x124>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, FOSC0) != SPI_OK)
80002ca4:	e0 6a 1b 00 	mov	r10,6912
80002ca8:	ea 1a 00 b7 	orh	r10,0xb7
80002cac:	0c 9b       	mov	r11,r6
80002cae:	6e 0c       	ld.w	r12,r7[0x0]
80002cb0:	f0 1f 00 33 	mcall	80002d7c <data_flash_init+0x128>
80002cb4:	c0 50       	breq	80002cbe <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002cb6:	30 29       	mov	r9,2
80002cb8:	4b 28       	lddpc	r8,80002d80 <data_flash_init+0x12c>
80002cba:	b0 89       	st.b	r8[0x0],r9
		return;
80002cbc:	c4 a8       	rjmp	80002d50 <data_flash_init+0xfc>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002cbe:	1a 96       	mov	r6,sp
80002cc0:	30 4a       	mov	r10,4
80002cc2:	4b 1b       	lddpc	r11,80002d84 <data_flash_init+0x130>
80002cc4:	1a 9c       	mov	r12,sp
80002cc6:	f0 1f 00 31 	mcall	80002d88 <data_flash_init+0x134>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002cca:	4a 97       	lddpc	r7,80002d6c <data_flash_init+0x118>
80002ccc:	30 0b       	mov	r11,0
80002cce:	6e 0c       	ld.w	r12,r7[0x0]
80002cd0:	f0 1f 00 2f 	mcall	80002d8c <data_flash_init+0x138>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002cd4:	e0 6b 00 9f 	mov	r11,159
80002cd8:	6e 0c       	ld.w	r12,r7[0x0]
80002cda:	f0 1f 00 2e 	mcall	80002d90 <data_flash_init+0x13c>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002cde:	e0 6b 00 ff 	mov	r11,255
80002ce2:	6e 0c       	ld.w	r12,r7[0x0]
80002ce4:	f0 1f 00 2b 	mcall	80002d90 <data_flash_init+0x13c>
	spi_read(spi, &manufacturer_device_id[0]);
80002ce8:	1a 9b       	mov	r11,sp
80002cea:	6e 0c       	ld.w	r12,r7[0x0]
80002cec:	f0 1f 00 2a 	mcall	80002d94 <data_flash_init+0x140>
	spi_write_dummy();
80002cf0:	e0 6b 00 ff 	mov	r11,255
80002cf4:	6e 0c       	ld.w	r12,r7[0x0]
80002cf6:	f0 1f 00 27 	mcall	80002d90 <data_flash_init+0x13c>
	spi_read(spi, &manufacturer_device_id[1]);
80002cfa:	fa cb ff fe 	sub	r11,sp,-2
80002cfe:	6e 0c       	ld.w	r12,r7[0x0]
80002d00:	f0 1f 00 25 	mcall	80002d94 <data_flash_init+0x140>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002d04:	30 0b       	mov	r11,0
80002d06:	6e 0c       	ld.w	r12,r7[0x0]
80002d08:	f0 1f 00 24 	mcall	80002d98 <data_flash_init+0x144>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002d0c:	31 f8       	mov	r8,31
80002d0e:	9a 09       	ld.sh	r9,sp[0x0]
80002d10:	f0 09 19 00 	cp.h	r9,r8
80002d14:	c0 61       	brne	80002d20 <data_flash_init+0xcc>
80002d16:	34 88       	mov	r8,72
80002d18:	9a 19       	ld.sh	r9,sp[0x2]
80002d1a:	f0 09 19 00 	cp.h	r9,r8
80002d1e:	c0 50       	breq	80002d28 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002d20:	30 39       	mov	r9,3
80002d22:	49 88       	lddpc	r8,80002d80 <data_flash_init+0x12c>
80002d24:	b0 89       	st.b	r8[0x0],r9
		return;
80002d26:	c1 58       	rjmp	80002d50 <data_flash_init+0xfc>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002d28:	30 09       	mov	r9,0
80002d2a:	12 9a       	mov	r10,r9
80002d2c:	12 9b       	mov	r11,r9
80002d2e:	30 6c       	mov	r12,6
80002d30:	f0 1f 00 1b 	mcall	80002d9c <data_flash_init+0x148>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002d34:	30 09       	mov	r9,0
80002d36:	12 9a       	mov	r10,r9
80002d38:	12 9b       	mov	r11,r9
80002d3a:	30 1c       	mov	r12,1
80002d3c:	f0 1f 00 18 	mcall	80002d9c <data_flash_init+0x148>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002d40:	30 09       	mov	r9,0
80002d42:	12 9a       	mov	r10,r9
80002d44:	12 9b       	mov	r11,r9
80002d46:	30 5c       	mov	r12,5
80002d48:	f0 1f 00 15 	mcall	80002d9c <data_flash_init+0x148>

	// after 5 seconds, perform a test on write and read back 0x5A5A to address 0x00001002
	// then read address 0x00001002 every 5s and report to radio with failure


	create_data_flash_test_task();
80002d4c:	f0 1f 00 15 	mcall	80002da0 <data_flash_init+0x14c>

	return;
}
80002d50:	2f bd       	sub	sp,-20
80002d52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d56:	00 00       	add	r0,r0
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	cf 0c       	rcall	80002f3a <get_idle_store_isr+0x26>
80002d5c:	80 00       	ld.sh	r0,r0[0x0]
80002d5e:	cf c0       	breq	80002d56 <data_flash_init+0x102>
80002d60:	80 00       	ld.sh	r0,r0[0x0]
80002d62:	6b 10       	ld.w	r0,r5[0x44]
80002d64:	80 00       	ld.sh	r0,r0[0x0]
80002d66:	6b 40       	ld.w	r0,r5[0x50]
80002d68:	80 00       	ld.sh	r0,r0[0x0]
80002d6a:	6b 58       	ld.w	r8,r5[0x54]
80002d6c:	00 00       	add	r0,r0
80002d6e:	0d 8c       	ld.ub	r12,r6[0x0]
80002d70:	80 00       	ld.sh	r0,r0[0x0]
80002d72:	4e 20       	lddpc	r0,80002ef8 <phy_tx+0x40>
80002d74:	80 00       	ld.sh	r0,r0[0x0]
80002d76:	4e 58       	lddpc	r8,80002f08 <phy_tx+0x50>
80002d78:	80 00       	ld.sh	r0,r0[0x0]
80002d7a:	4f b8       	lddpc	r8,80002f64 <phy_tx_func+0x28>
80002d7c:	80 00       	ld.sh	r0,r0[0x0]
80002d7e:	4e f6       	lddpc	r6,80002f38 <get_idle_store_isr+0x24>
80002d80:	00 00       	add	r0,r0
80002d82:	0a 6c       	and	r12,r5
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	cf bc       	rcall	80002f7c <phy_tx_func+0x40>
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	70 0c       	ld.w	r12,r8[0x0]
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	4e 84       	lddpc	r4,80002f2c <get_idle_store_isr+0x18>
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	4f be       	lddpc	lr,80002f7c <phy_tx_func+0x40>
80002d94:	80 00       	ld.sh	r0,r0[0x0]
80002d96:	4f da       	lddpc	r10,80002f88 <phy_tx_func+0x4c>
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	4e d0       	lddpc	r0,80002f4c <phy_tx_func+0x10>
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	28 e8       	sub	r8,-114
80002da0:	80 00       	ld.sh	r0,r0[0x0]
80002da2:	28 c0       	sub	r0,-116

80002da4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002da4:	20 1c       	sub	r12,1
80002da6:	5c 5c       	castu.b	r12
80002da8:	31 18       	mov	r8,17
80002daa:	f0 0c 18 00 	cp.b	r12,r8
80002dae:	e0 88 00 03 	brls	80002db4 <CalculateBurst+0x10>
80002db2:	5e fd       	retal	0
80002db4:	48 28       	lddpc	r8,80002dbc <CalculateBurst+0x18>
80002db6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002dba:	5e fc       	retal	r12
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	cf e8       	rjmp	80002fba <phy_tx_func+0x7e>

80002dc0 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002dc0:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002dc2:	48 98       	lddpc	r8,80002de4 <payload_init+0x24>
80002dc4:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002dc6:	48 98       	lddpc	r8,80002de8 <payload_init+0x28>
80002dc8:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002dca:	30 09       	mov	r9,0
80002dcc:	1a d9       	st.w	--sp,r9
80002dce:	1a d9       	st.w	--sp,r9
80002dd0:	1a d9       	st.w	--sp,r9
80002dd2:	30 28       	mov	r8,2
80002dd4:	e0 6a 04 00 	mov	r10,1024
80002dd8:	48 5b       	lddpc	r11,80002dec <payload_init+0x2c>
80002dda:	48 6c       	lddpc	r12,80002df0 <payload_init+0x30>
80002ddc:	f0 1f 00 06 	mcall	80002df4 <payload_init+0x34>
80002de0:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002de2:	d8 02       	popm	pc
80002de4:	00 00       	add	r0,r0
80002de6:	0a 70       	tst	r0,r5
80002de8:	00 00       	add	r0,r0
80002dea:	0a 74       	tst	r4,r5
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	d0 30       	acall	0x3
80002df0:	80 00       	ld.sh	r0,r0[0x0]
80002df2:	2d f8       	sub	r8,-33
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	62 b4       	ld.w	r4,r1[0x2c]

80002df8 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002df8:	eb cd 40 f8 	pushm	r3-r7,lr
80002dfc:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002dfe:	48 e8       	lddpc	r8,80002e34 <payload_rx_process+0x3c>
80002e00:	70 08       	ld.w	r8,r8[0x0]
80002e02:	58 08       	cp.w	r8,0
80002e04:	c0 71       	brne	80002e12 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002e06:	30 4b       	mov	r11,4
80002e08:	30 5c       	mov	r12,5
80002e0a:	f0 1f 00 0c 	mcall	80002e38 <payload_rx_process+0x40>
80002e0e:	48 a8       	lddpc	r8,80002e34 <payload_rx_process+0x3c>
80002e10:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002e12:	48 96       	lddpc	r6,80002e34 <payload_rx_process+0x3c>
80002e14:	30 05       	mov	r5,0
80002e16:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002e18:	48 93       	lddpc	r3,80002e3c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002e1a:	6c 0c       	ld.w	r12,r6[0x0]
80002e1c:	0a 99       	mov	r9,r5
80002e1e:	08 9a       	mov	r10,r4
80002e20:	1a 9b       	mov	r11,sp
80002e22:	f0 1f 00 08 	mcall	80002e40 <payload_rx_process+0x48>
80002e26:	58 1c       	cp.w	r12,1
80002e28:	cf 91       	brne	80002e1a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002e2a:	66 08       	ld.w	r8,r3[0x0]
80002e2c:	40 0c       	lddsp	r12,sp[0x0]
80002e2e:	5d 18       	icall	r8
80002e30:	cf 5b       	rjmp	80002e1a <payload_rx_process+0x22>
80002e32:	00 00       	add	r0,r0
80002e34:	00 00       	add	r0,r0
80002e36:	0a a0       	st.w	r5++,r0
80002e38:	80 00       	ld.sh	r0,r0[0x0]
80002e3a:	5b e0       	cp.w	r0,-2
80002e3c:	00 00       	add	r0,r0
80002e3e:	0a 70       	tst	r0,r5
80002e40:	80 00       	ld.sh	r0,r0[0x0]
80002e42:	58 d4       	cp.w	r4,13

80002e44 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002e44:	d4 01       	pushm	lr
80002e46:	20 2d       	sub	sp,8
80002e48:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002e4a:	30 09       	mov	r9,0
80002e4c:	fa ca ff f8 	sub	r10,sp,-8
80002e50:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002e52:	1a 9b       	mov	r11,sp
80002e54:	f0 1f 00 02 	mcall	80002e5c <set_idle_store_isr+0x18>
}
80002e58:	2f ed       	sub	sp,-8
80002e5a:	d8 02       	popm	pc
80002e5c:	80 00       	ld.sh	r0,r0[0x0]
80002e5e:	5a 90       	cp.w	r0,-23

80002e60 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002e60:	d4 01       	pushm	lr
80002e62:	20 2d       	sub	sp,8
80002e64:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002e66:	58 0c       	cp.w	r12,0
80002e68:	c1 10       	breq	80002e8a <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002e6a:	30 08       	mov	r8,0
80002e6c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002e6e:	98 88       	ld.uh	r8,r12[0x0]
80002e70:	e2 18 f0 00 	andl	r8,0xf000,COH
80002e74:	e0 48 40 00 	cp.w	r8,16384
80002e78:	c0 91       	brne	80002e8a <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002e7a:	48 68       	lddpc	r8,80002e90 <phy_rx+0x30>
80002e7c:	70 0c       	ld.w	r12,r8[0x0]
80002e7e:	30 09       	mov	r9,0
80002e80:	fa ca ff fc 	sub	r10,sp,-4
80002e84:	1a 9b       	mov	r11,sp
80002e86:	f0 1f 00 04 	mcall	80002e94 <phy_rx+0x34>
		}	

    }
		
 
}
80002e8a:	2f ed       	sub	sp,-8
80002e8c:	d8 02       	popm	pc
80002e8e:	00 00       	add	r0,r0
80002e90:	00 00       	add	r0,r0
80002e92:	0a d0       	st.w	--r5,r0
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	5a 90       	cp.w	r0,-23

80002e98 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002e98:	eb cd 40 80 	pushm	r7,lr
80002e9c:	20 1d       	sub	sp,4
80002e9e:	fa c7 ff fc 	sub	r7,sp,-4
80002ea2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002ea4:	30 09       	mov	r9,0
80002ea6:	12 9a       	mov	r10,r9
80002ea8:	1a 9b       	mov	r11,sp
80002eaa:	f0 1f 00 03 	mcall	80002eb4 <set_idle_store+0x1c>
}
80002eae:	2f fd       	sub	sp,-4
80002eb0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	5a e0       	cp.w	r0,-18

80002eb8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002eb8:	d4 01       	pushm	lr
80002eba:	20 1d       	sub	sp,4
80002ebc:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002ebe:	98 88       	ld.uh	r8,r12[0x0]
80002ec0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ec4:	e0 48 40 00 	cp.w	r8,16384
80002ec8:	c0 d1       	brne	80002ee2 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002eca:	49 08       	lddpc	r8,80002f08 <phy_tx+0x50>
80002ecc:	70 08       	ld.w	r8,r8[0x0]
80002ece:	58 08       	cp.w	r8,0
80002ed0:	c1 a0       	breq	80002f04 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002ed2:	48 e8       	lddpc	r8,80002f08 <phy_tx+0x50>
80002ed4:	70 0c       	ld.w	r12,r8[0x0]
80002ed6:	30 09       	mov	r9,0
80002ed8:	12 9a       	mov	r10,r9
80002eda:	1a 9b       	mov	r11,sp
80002edc:	f0 1f 00 0c 	mcall	80002f0c <phy_tx+0x54>
80002ee0:	c1 28       	rjmp	80002f04 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002ee2:	e0 48 10 00 	cp.w	r8,4096
80002ee6:	5f 0a       	sreq	r10
80002ee8:	e0 48 20 00 	cp.w	r8,8192
80002eec:	5f 09       	sreq	r9
80002eee:	f5 e9 10 09 	or	r9,r10,r9
80002ef2:	c0 71       	brne	80002f00 <phy_tx+0x48>
80002ef4:	e0 48 50 00 	cp.w	r8,20480
80002ef8:	c0 40       	breq	80002f00 <phy_tx+0x48>
80002efa:	e0 48 60 00 	cp.w	r8,24576
80002efe:	c0 31       	brne	80002f04 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002f00:	48 48       	lddpc	r8,80002f10 <phy_tx+0x58>
80002f02:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002f04:	2f fd       	sub	sp,-4
80002f06:	d8 02       	popm	pc
80002f08:	00 00       	add	r0,r0
80002f0a:	0a dc       	st.w	--r5,r12
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	5a e0       	cp.w	r0,-18
80002f10:	00 00       	add	r0,r0
80002f12:	0a cc       	st.b	r5++,r12

80002f14 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002f14:	d4 01       	pushm	lr
80002f16:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002f18:	30 08       	mov	r8,0
80002f1a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f1c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002f1e:	1a 9a       	mov	r10,sp
80002f20:	fa cb ff fc 	sub	r11,sp,-4
80002f24:	f0 1f 00 05 	mcall	80002f38 <get_idle_store_isr+0x24>
80002f28:	58 1c       	cp.w	r12,1
80002f2a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f2e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002f32:	2f ed       	sub	sp,-8
80002f34:	d8 02       	popm	pc
80002f36:	00 00       	add	r0,r0
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	57 e4       	stdsp	sp[0x1f8],r4

80002f3c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002f3c:	eb cd 40 c0 	pushm	r6-r7,lr
80002f40:	20 1d       	sub	sp,4
80002f42:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002f44:	fe f8 04 70 	ld.w	r8,pc[1136]
80002f48:	70 08       	ld.w	r8,r8[0x0]
80002f4a:	58 08       	cp.w	r8,0
80002f4c:	c7 40       	breq	80003034 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002f4e:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f50:	30 08       	mov	r8,0
80002f52:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002f54:	fe f8 04 64 	ld.w	r8,pc[1124]
80002f58:	70 08       	ld.w	r8,r8[0x0]
80002f5a:	58 18       	cp.w	r8,1
80002f5c:	c2 90       	breq	80002fae <phy_tx_func+0x72>
80002f5e:	c0 43       	brcs	80002f66 <phy_tx_func+0x2a>
80002f60:	58 28       	cp.w	r8,2
80002f62:	c6 91       	brne	80003034 <phy_tx_func+0xf8>
80002f64:	c6 18       	rjmp	80003026 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002f66:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002f6a:	70 0c       	ld.w	r12,r8[0x0]
80002f6c:	1a 9a       	mov	r10,sp
80002f6e:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002f72:	f0 1f 01 14 	mcall	800033c0 <phy_tx_func+0x484>
80002f76:	58 1c       	cp.w	r12,1
80002f78:	c1 51       	brne	80002fa2 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002f7a:	fe f8 04 42 	ld.w	r8,pc[1090]
80002f7e:	70 08       	ld.w	r8,r8[0x0]
80002f80:	11 9a       	ld.ub	r10,r8[0x1]
80002f82:	fe f9 04 42 	ld.w	r9,pc[1090]
80002f86:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002f88:	90 88       	ld.uh	r8,r8[0x0]
80002f8a:	ea 18 ab cd 	orh	r8,0xabcd
80002f8e:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002f90:	30 19       	mov	r9,1
80002f92:	fe f8 04 36 	ld.w	r8,pc[1078]
80002f96:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002f98:	30 19       	mov	r9,1
80002f9a:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002f9e:	91 09       	st.w	r8[0x0],r9
80002fa0:	c4 a8       	rjmp	80003034 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002fa2:	e0 68 5a 5a 	mov	r8,23130
80002fa6:	ea 18 ab cd 	orh	r8,0xabcd
80002faa:	8f 18       	st.w	r7[0x4],r8
80002fac:	c4 48       	rjmp	80003034 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002fae:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002fb2:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002fb4:	fe fa 04 08 	ld.w	r10,pc[1032]
80002fb8:	74 0a       	ld.w	r10,r10[0x0]
80002fba:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002fbe:	b1 6a       	lsl	r10,0x10
80002fc0:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002fc2:	2f f8       	sub	r8,-1
80002fc4:	5c 58       	castu.b	r8
80002fc6:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002fc8:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002fcc:	94 09       	ld.sh	r9,r10[0x0]
80002fce:	20 29       	sub	r9,2
80002fd0:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002fd2:	30 0a       	mov	r10,0
80002fd4:	f4 09 19 00 	cp.h	r9,r10
80002fd8:	e0 89 00 0b 	brgt	80002fee <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002fdc:	78 18       	ld.w	r8,r12[0x4]
80002fde:	e8 18 00 ba 	orl	r8,0xba
80002fe2:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002fe4:	30 09       	mov	r9,0
80002fe6:	fe f8 03 d2 	ld.w	r8,pc[978]
80002fea:	91 09       	st.w	r8[0x0],r9
80002fec:	c2 48       	rjmp	80003034 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002fee:	fe f9 03 ce 	ld.w	r9,pc[974]
80002ff2:	72 09       	ld.w	r9,r9[0x0]
80002ff4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ff8:	78 1a       	ld.w	r10,r12[0x4]
80002ffa:	f5 e9 10 09 	or	r9,r10,r9
80002ffe:	99 19       	st.w	r12[0x4],r9
80003000:	2f f8       	sub	r8,-1
80003002:	fe f9 03 c6 	ld.w	r9,pc[966]
80003006:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003008:	fe f9 03 bc 	ld.w	r9,pc[956]
8000300c:	92 08       	ld.sh	r8,r9[0x0]
8000300e:	20 28       	sub	r8,2
80003010:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003012:	30 09       	mov	r9,0
80003014:	f2 08 19 00 	cp.h	r8,r9
80003018:	e0 89 00 0e 	brgt	80003034 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
8000301c:	30 29       	mov	r9,2
8000301e:	fe f8 03 9a 	ld.w	r8,pc[922]
80003022:	91 09       	st.w	r8[0x0],r9
80003024:	c0 88       	rjmp	80003034 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003026:	fc 18 00 ba 	movh	r8,0xba
8000302a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
8000302c:	30 09       	mov	r9,0
8000302e:	fe f8 03 8a 	ld.w	r8,pc[906]
80003032:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80003034:	fe f8 03 98 	ld.w	r8,pc[920]
80003038:	11 89       	ld.ub	r9,r8[0x0]
8000303a:	30 18       	mov	r8,1
8000303c:	f0 09 18 00 	cp.b	r9,r8
80003040:	e0 81 01 af 	brne	8000339e <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003044:	fe f8 03 8c 	ld.w	r8,pc[908]
80003048:	70 08       	ld.w	r8,r8[0x0]
8000304a:	e0 48 05 b0 	cp.w	r8,1456
8000304e:	f9 b8 02 00 	movhs	r8,0
80003052:	fe f9 03 7e 	ld.w	r9,pc[894]
80003056:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80003058:	fe f8 03 7c 	ld.w	r8,pc[892]
8000305c:	70 08       	ld.w	r8,r8[0x0]
8000305e:	58 68       	cp.w	r8,6
80003060:	e0 8b 01 95 	brhi	8000338a <phy_tx_func+0x44e>
80003064:	fe f9 03 74 	ld.w	r9,pc[884]
80003068:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
8000306c:	fe f8 03 70 	ld.w	r8,pc[880]
80003070:	70 08       	ld.w	r8,r8[0x0]
80003072:	58 08       	cp.w	r8,0
80003074:	c0 b0       	breq	8000308a <phy_tx_func+0x14e>
80003076:	fe f8 03 66 	ld.w	r8,pc[870]
8000307a:	70 08       	ld.w	r8,r8[0x0]
8000307c:	58 a8       	cp.w	r8,10
8000307e:	c0 60       	breq	8000308a <phy_tx_func+0x14e>
80003080:	fe f8 03 5c 	ld.w	r8,pc[860]
80003084:	70 08       	ld.w	r8,r8[0x0]
80003086:	58 18       	cp.w	r8,1
80003088:	c0 a1       	brne	8000309c <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000308a:	e0 68 5a 5a 	mov	r8,23130
8000308e:	ea 18 ab cd 	orh	r8,0xabcd
80003092:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003094:	30 08       	mov	r8,0
80003096:	8f 38       	st.w	r7[0xc],r8
80003098:	e0 8f 01 8a 	bral	800033ac <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
8000309c:	fe f8 03 40 	ld.w	r8,pc[832]
800030a0:	70 08       	ld.w	r8,r8[0x0]
800030a2:	58 38       	cp.w	r8,3
800030a4:	c0 91       	brne	800030b6 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
800030a6:	fe f8 03 3a 	ld.w	r8,pc[826]
800030aa:	70 09       	ld.w	r9,r8[0x0]
800030ac:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
800030ae:	70 18       	ld.w	r8,r8[0x4]
800030b0:	8f 38       	st.w	r7[0xc],r8
800030b2:	e0 8f 01 7d 	bral	800033ac <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
800030b6:	fe f8 03 26 	ld.w	r8,pc[806]
800030ba:	70 08       	ld.w	r8,r8[0x0]
800030bc:	58 28       	cp.w	r8,2
800030be:	c1 31       	brne	800030e4 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
800030c0:	e0 68 c0 32 	mov	r8,49202
800030c4:	ea 18 ab cd 	orh	r8,0xabcd
800030c8:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
800030ca:	fe 78 84 7f 	mov	r8,-31617
800030ce:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
800030d0:	fe f8 03 14 	ld.w	r8,pc[788]
800030d4:	90 08       	ld.sh	r8,r8[0x0]
800030d6:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
800030d8:	30 39       	mov	r9,3
800030da:	fe f8 02 fa 	ld.w	r8,pc[762]
800030de:	91 09       	st.w	r8[0x0],r9
800030e0:	e0 8f 01 66 	bral	800033ac <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
800030e4:	e0 68 c0 0e 	mov	r8,49166
800030e8:	ea 18 ab cd 	orh	r8,0xabcd
800030ec:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
800030ee:	fe f8 02 fa 	ld.w	r8,pc[762]
800030f2:	90 09       	ld.sh	r9,r8[0x0]
800030f4:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
800030f6:	90 18       	ld.sh	r8,r8[0x2]
800030f8:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
800030fa:	30 19       	mov	r9,1
800030fc:	fe f8 02 d8 	ld.w	r8,pc[728]
80003100:	91 09       	st.w	r8[0x0],r9
80003102:	e0 8f 01 55 	bral	800033ac <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003106:	fe 78 88 f2 	mov	r8,-30478
8000310a:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
8000310c:	fe f8 02 d0 	ld.w	r8,pc[720]
80003110:	70 08       	ld.w	r8,r8[0x0]
80003112:	58 48       	cp.w	r8,4
80003114:	c0 60       	breq	80003120 <phy_tx_func+0x1e4>
80003116:	c4 53       	brcs	800031a0 <phy_tx_func+0x264>
80003118:	58 98       	cp.w	r8,9
8000311a:	e0 8b 00 43 	brhi	800031a0 <phy_tx_func+0x264>
8000311e:	c2 98       	rjmp	80003170 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003120:	fe f8 02 cc 	ld.w	r8,pc[716]
80003124:	11 89       	ld.ub	r9,r8[0x0]
80003126:	30 18       	mov	r8,1
80003128:	f0 09 18 00 	cp.b	r9,r8
8000312c:	c0 a1       	brne	80003140 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
8000312e:	fe f8 02 c2 	ld.w	r8,pc[706]
80003132:	90 09       	ld.sh	r9,r8[0x0]
80003134:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003136:	90 19       	ld.sh	r9,r8[0x2]
80003138:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
8000313a:	90 28       	ld.sh	r8,r8[0x4]
8000313c:	ae 78       	st.h	r7[0xe],r8
8000313e:	c1 48       	rjmp	80003166 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003140:	fe f9 02 b4 	ld.w	r9,pc[692]
80003144:	92 0b       	ld.sh	r11,r9[0x0]
80003146:	fe f8 02 aa 	ld.w	r8,pc[682]
8000314a:	90 0a       	ld.sh	r10,r8[0x0]
8000314c:	f7 ea 20 0a 	eor	r10,r11,r10
80003150:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003152:	92 1b       	ld.sh	r11,r9[0x2]
80003154:	90 1a       	ld.sh	r10,r8[0x2]
80003156:	f7 ea 20 0a 	eor	r10,r11,r10
8000315a:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
8000315c:	92 29       	ld.sh	r9,r9[0x4]
8000315e:	90 28       	ld.sh	r8,r8[0x4]
80003160:	f3 e8 20 08 	eor	r8,r9,r8
80003164:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80003166:	30 29       	mov	r9,2
80003168:	fe f8 02 6c 	ld.w	r8,pc[620]
8000316c:	91 09       	st.w	r8[0x0],r9
8000316e:	c1 f9       	rjmp	800033ac <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003170:	fe f9 02 84 	ld.w	r9,pc[644]
80003174:	92 0b       	ld.sh	r11,r9[0x0]
80003176:	fe f8 02 7a 	ld.w	r8,pc[634]
8000317a:	90 0a       	ld.sh	r10,r8[0x0]
8000317c:	f7 ea 20 0a 	eor	r10,r11,r10
80003180:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003182:	92 1b       	ld.sh	r11,r9[0x2]
80003184:	90 1a       	ld.sh	r10,r8[0x2]
80003186:	f7 ea 20 0a 	eor	r10,r11,r10
8000318a:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
8000318c:	92 29       	ld.sh	r9,r9[0x4]
8000318e:	90 28       	ld.sh	r8,r8[0x4]
80003190:	f3 e8 20 08 	eor	r8,r9,r8
80003194:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80003196:	30 29       	mov	r9,2
80003198:	fe f8 02 3c 	ld.w	r8,pc[572]
8000319c:	91 09       	st.w	r8[0x0],r9
8000319e:	c0 79       	rjmp	800033ac <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800031a0:	e0 68 5a 5a 	mov	r8,23130
800031a4:	ea 18 ab cd 	orh	r8,0xabcd
800031a8:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800031aa:	30 08       	mov	r8,0
800031ac:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
800031ae:	fe f9 02 26 	ld.w	r9,pc[550]
800031b2:	93 08       	st.w	r9[0x0],r8
800031b4:	cf c8       	rjmp	800033ac <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
800031b6:	fe f8 02 3e 	ld.w	r8,pc[574]
800031ba:	90 38       	ld.sh	r8,r8[0x6]
800031bc:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
800031be:	e0 68 00 ba 	mov	r8,186
800031c2:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
800031c4:	30 08       	mov	r8,0
800031c6:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
800031c8:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
800031ca:	30 09       	mov	r9,0
800031cc:	fe f8 02 08 	ld.w	r8,pc[520]
800031d0:	91 09       	st.w	r8[0x0],r9
800031d2:	ce d8       	rjmp	800033ac <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
800031d4:	fe f8 02 10 	ld.w	r8,pc[528]
800031d8:	90 18       	ld.sh	r8,r8[0x2]
800031da:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
800031dc:	fe f8 02 0c 	ld.w	r8,pc[524]
800031e0:	90 08       	ld.sh	r8,r8[0x0]
800031e2:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
800031e4:	4f e8       	lddpc	r8,800033dc <phy_tx_func+0x4a0>
800031e6:	70 08       	ld.w	r8,r8[0x0]
800031e8:	58 48       	cp.w	r8,4
800031ea:	c0 d1       	brne	80003204 <phy_tx_func+0x2c8>
800031ec:	fe f8 02 00 	ld.w	r8,pc[512]
800031f0:	11 89       	ld.ub	r9,r8[0x0]
800031f2:	30 18       	mov	r8,1
800031f4:	f0 09 18 00 	cp.b	r9,r8
800031f8:	c0 61       	brne	80003204 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
800031fa:	4f c8       	lddpc	r8,800033e8 <phy_tx_func+0x4ac>
800031fc:	90 18       	ld.sh	r8,r8[0x2]
800031fe:	a9 a8       	sbr	r8,0x8
80003200:	ae 68       	st.h	r7[0xc],r8
80003202:	c0 48       	rjmp	8000320a <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80003204:	4f 98       	lddpc	r8,800033e8 <phy_tx_func+0x4ac>
80003206:	90 18       	ld.sh	r8,r8[0x2]
80003208:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
8000320a:	fe 78 9a 13 	mov	r8,-26093
8000320e:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80003210:	30 49       	mov	r9,4
80003212:	4f 18       	lddpc	r8,800033d4 <phy_tx_func+0x498>
80003214:	91 09       	st.w	r8[0x0],r9
80003216:	cc b8       	rjmp	800033ac <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80003218:	4f 88       	lddpc	r8,800033f8 <phy_tx_func+0x4bc>
8000321a:	70 0a       	ld.w	r10,r8[0x0]
8000321c:	4f 89       	lddpc	r9,800033fc <phy_tx_func+0x4c0>
8000321e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003222:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80003224:	70 0a       	ld.w	r10,r8[0x0]
80003226:	2f fa       	sub	r10,-1
80003228:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000322c:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
8000322e:	70 0a       	ld.w	r10,r8[0x0]
80003230:	2f ea       	sub	r10,-2
80003232:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003236:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80003238:	70 0a       	ld.w	r10,r8[0x0]
8000323a:	2f da       	sub	r10,-3
8000323c:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80003240:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80003242:	70 09       	ld.w	r9,r8[0x0]
80003244:	2f c9       	sub	r9,-4
80003246:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80003248:	58 c9       	cp.w	r9,12
8000324a:	c0 51       	brne	80003254 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
8000324c:	30 59       	mov	r9,5
8000324e:	4e 28       	lddpc	r8,800033d4 <phy_tx_func+0x498>
80003250:	91 09       	st.w	r8[0x0],r9
80003252:	ca d8       	rjmp	800033ac <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80003254:	30 49       	mov	r9,4
80003256:	4e 08       	lddpc	r8,800033d4 <phy_tx_func+0x498>
80003258:	91 09       	st.w	r8[0x0],r9
8000325a:	ca 98       	rjmp	800033ac <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
8000325c:	4e 78       	lddpc	r8,800033f8 <phy_tx_func+0x4bc>
8000325e:	70 0a       	ld.w	r10,r8[0x0]
80003260:	4e 79       	lddpc	r9,800033fc <phy_tx_func+0x4c0>
80003262:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80003266:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80003268:	30 09       	mov	r9,0
8000326a:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
8000326c:	fe 78 80 03 	mov	r8,-32765
80003270:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80003272:	fe 78 88 f3 	mov	r8,-30477
80003276:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80003278:	4d 98       	lddpc	r8,800033dc <phy_tx_func+0x4a0>
8000327a:	70 08       	ld.w	r8,r8[0x0]
8000327c:	58 48       	cp.w	r8,4
8000327e:	c0 60       	breq	8000328a <phy_tx_func+0x34e>
80003280:	c2 83       	brcs	800032d0 <phy_tx_func+0x394>
80003282:	58 98       	cp.w	r8,9
80003284:	e0 8b 00 26 	brhi	800032d0 <phy_tx_func+0x394>
80003288:	c1 98       	rjmp	800032ba <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
8000328a:	4d 98       	lddpc	r8,800033ec <phy_tx_func+0x4b0>
8000328c:	11 89       	ld.ub	r9,r8[0x0]
8000328e:	30 18       	mov	r8,1
80003290:	f0 09 18 00 	cp.b	r9,r8
80003294:	c0 81       	brne	800032a4 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80003296:	4d 88       	lddpc	r8,800033f4 <phy_tx_func+0x4b8>
80003298:	90 0a       	ld.sh	r10,r8[0x0]
8000329a:	4d a9       	lddpc	r9,80003400 <phy_tx_func+0x4c4>
8000329c:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
8000329e:	90 08       	ld.sh	r8,r8[0x0]
800032a0:	ae 78       	st.h	r7[0xe],r8
800032a2:	c0 88       	rjmp	800032b2 <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032a4:	4d 78       	lddpc	r8,80003400 <phy_tx_func+0x4c4>
800032a6:	90 08       	ld.sh	r8,r8[0x0]
800032a8:	4d 39       	lddpc	r9,800033f4 <phy_tx_func+0x4b8>
800032aa:	92 09       	ld.sh	r9,r9[0x0]
800032ac:	f3 e8 20 08 	eor	r8,r9,r8
800032b0:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
800032b2:	30 69       	mov	r9,6
800032b4:	4c 88       	lddpc	r8,800033d4 <phy_tx_func+0x498>
800032b6:	91 09       	st.w	r8[0x0],r9
800032b8:	c7 a8       	rjmp	800033ac <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032ba:	4d 28       	lddpc	r8,80003400 <phy_tx_func+0x4c4>
800032bc:	90 08       	ld.sh	r8,r8[0x0]
800032be:	4c e9       	lddpc	r9,800033f4 <phy_tx_func+0x4b8>
800032c0:	92 09       	ld.sh	r9,r9[0x0]
800032c2:	f3 e8 20 08 	eor	r8,r9,r8
800032c6:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
800032c8:	30 69       	mov	r9,6
800032ca:	4c 38       	lddpc	r8,800033d4 <phy_tx_func+0x498>
800032cc:	91 09       	st.w	r8[0x0],r9
800032ce:	c6 f8       	rjmp	800033ac <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
800032d0:	e0 68 5a 5a 	mov	r8,23130
800032d4:	ea 18 ab cd 	orh	r8,0xabcd
800032d8:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
800032da:	30 08       	mov	r8,0
800032dc:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
800032de:	4b e9       	lddpc	r9,800033d4 <phy_tx_func+0x498>
800032e0:	93 08       	st.w	r9[0x0],r8
800032e2:	c6 58       	rjmp	800033ac <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
800032e4:	4b e8       	lddpc	r8,800033dc <phy_tx_func+0x4a0>
800032e6:	70 08       	ld.w	r8,r8[0x0]
800032e8:	58 48       	cp.w	r8,4
800032ea:	c0 60       	breq	800032f6 <phy_tx_func+0x3ba>
800032ec:	c4 53       	brcs	80003376 <phy_tx_func+0x43a>
800032ee:	58 98       	cp.w	r8,9
800032f0:	e0 8b 00 43 	brhi	80003376 <phy_tx_func+0x43a>
800032f4:	c2 d8       	rjmp	8000334e <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
800032f6:	4b e8       	lddpc	r8,800033ec <phy_tx_func+0x4b0>
800032f8:	11 89       	ld.ub	r9,r8[0x0]
800032fa:	30 18       	mov	r8,1
800032fc:	f0 09 18 00 	cp.b	r9,r8
80003300:	c1 31       	brne	80003326 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80003302:	4b d8       	lddpc	r8,800033f4 <phy_tx_func+0x4b8>
80003304:	90 1a       	ld.sh	r10,r8[0x2]
80003306:	4b f9       	lddpc	r9,80003400 <phy_tx_func+0x4c4>
80003308:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
8000330a:	90 2a       	ld.sh	r10,r8[0x4]
8000330c:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
8000330e:	90 3a       	ld.sh	r10,r8[0x6]
80003310:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80003312:	90 19       	ld.sh	r9,r8[0x2]
80003314:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80003316:	90 29       	ld.sh	r9,r8[0x4]
80003318:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
8000331a:	90 38       	ld.sh	r8,r8[0x6]
8000331c:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
8000331e:	e0 68 00 ba 	mov	r8,186
80003322:	ae 78       	st.h	r7[0xe],r8
80003324:	c1 18       	rjmp	80003346 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80003326:	4b 48       	lddpc	r8,800033f4 <phy_tx_func+0x4b8>
80003328:	90 1a       	ld.sh	r10,r8[0x2]
8000332a:	4b 69       	lddpc	r9,80003400 <phy_tx_func+0x4c4>
8000332c:	92 1b       	ld.sh	r11,r9[0x2]
8000332e:	f7 ea 20 0a 	eor	r10,r11,r10
80003332:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80003334:	90 2a       	ld.sh	r10,r8[0x4]
80003336:	92 29       	ld.sh	r9,r9[0x4]
80003338:	14 59       	eor	r9,r10
8000333a:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
8000333c:	90 38       	ld.sh	r8,r8[0x6]
8000333e:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80003340:	e0 68 00 ba 	mov	r8,186
80003344:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80003346:	30 09       	mov	r9,0
80003348:	4a 38       	lddpc	r8,800033d4 <phy_tx_func+0x498>
8000334a:	91 09       	st.w	r8[0x0],r9
8000334c:	c3 08       	rjmp	800033ac <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000334e:	4a a8       	lddpc	r8,800033f4 <phy_tx_func+0x4b8>
80003350:	90 1a       	ld.sh	r10,r8[0x2]
80003352:	4a c9       	lddpc	r9,80003400 <phy_tx_func+0x4c4>
80003354:	92 1b       	ld.sh	r11,r9[0x2]
80003356:	f7 ea 20 0a 	eor	r10,r11,r10
8000335a:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
8000335c:	90 2a       	ld.sh	r10,r8[0x4]
8000335e:	92 29       	ld.sh	r9,r9[0x4]
80003360:	14 59       	eor	r9,r10
80003362:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80003364:	90 38       	ld.sh	r8,r8[0x6]
80003366:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80003368:	e0 68 00 ba 	mov	r8,186
8000336c:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
8000336e:	30 09       	mov	r9,0
80003370:	49 98       	lddpc	r8,800033d4 <phy_tx_func+0x498>
80003372:	91 09       	st.w	r8[0x0],r9
80003374:	c1 c8       	rjmp	800033ac <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003376:	e0 68 5a 5a 	mov	r8,23130
8000337a:	ea 18 ab cd 	orh	r8,0xabcd
8000337e:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003380:	30 08       	mov	r8,0
80003382:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80003384:	49 49       	lddpc	r9,800033d4 <phy_tx_func+0x498>
80003386:	93 08       	st.w	r9[0x0],r8
80003388:	c1 28       	rjmp	800033ac <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000338a:	e0 68 5a 5a 	mov	r8,23130
8000338e:	ea 18 ab cd 	orh	r8,0xabcd
80003392:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003394:	30 08       	mov	r8,0
80003396:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80003398:	48 f9       	lddpc	r9,800033d4 <phy_tx_func+0x498>
8000339a:	93 08       	st.w	r9[0x0],r8
8000339c:	c0 88       	rjmp	800033ac <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000339e:	e0 68 5a 5a 	mov	r8,23130
800033a2:	ea 18 ab cd 	orh	r8,0xabcd
800033a6:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
800033a8:	30 08       	mov	r8,0
800033aa:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
800033ac:	2f fd       	sub	sp,-4
800033ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800033b2:	00 00       	add	r0,r0
800033b4:	00 00       	add	r0,r0
800033b6:	0a dc       	st.w	--r5,r12
800033b8:	00 00       	add	r0,r0
800033ba:	0a b4       	st.h	r5++,r4
800033bc:	00 00       	add	r0,r0
800033be:	0a 90       	mov	r0,r5
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	57 e4       	stdsp	sp[0x1f8],r4
800033c4:	00 00       	add	r0,r0
800033c6:	0a d4       	st.w	--r5,r4
800033c8:	00 00       	add	r0,r0
800033ca:	0a 99       	mov	r9,r5
800033cc:	00 00       	add	r0,r0
800033ce:	0a 5f       	eor	pc,r5
800033d0:	00 00       	add	r0,r0
800033d2:	0a 8c       	andn	r12,r5
800033d4:	00 00       	add	r0,r0
800033d6:	0a c4       	st.b	r5++,r4
800033d8:	80 00       	ld.sh	r0,r0[0x0]
800033da:	d0 3c       	*unknown*
800033dc:	00 00       	add	r0,r0
800033de:	0a 80       	andn	r0,r5
800033e0:	00 00       	add	r0,r0
800033e2:	0a e4       	st.h	--r5,r4
800033e4:	00 00       	add	r0,r0
800033e6:	0d 98       	ld.ub	r8,r6[0x1]
800033e8:	00 00       	add	r0,r0
800033ea:	0e 94       	mov	r4,r7
800033ec:	00 00       	add	r0,r0
800033ee:	0a 50       	eor	r0,r5
800033f0:	80 00       	ld.sh	r0,r0[0x0]
800033f2:	cf e0       	breq	800033ee <phy_tx_func+0x4b2>
800033f4:	00 00       	add	r0,r0
800033f6:	0d 90       	ld.ub	r0,r6[0x1]
800033f8:	00 00       	add	r0,r0
800033fa:	0a b0       	st.h	r5++,r0
800033fc:	00 00       	add	r0,r0
800033fe:	0e 98       	mov	r8,r7
80003400:	00 00       	add	r0,r0
80003402:	0d 9c       	ld.ub	r12,r6[0x1]

80003404 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003404:	d4 01       	pushm	lr
80003406:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003408:	30 0a       	mov	r10,0
8000340a:	fa cb ff fc 	sub	r11,sp,-4
8000340e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003410:	14 99       	mov	r9,r10
80003412:	1a 9b       	mov	r11,sp
80003414:	f0 1f 00 05 	mcall	80003428 <get_idle_store+0x24>
80003418:	58 1c       	cp.w	r12,1
8000341a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000341e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003422:	2f fd       	sub	sp,-4
80003424:	d8 02       	popm	pc
80003426:	00 00       	add	r0,r0
80003428:	80 00       	ld.sh	r0,r0[0x0]
8000342a:	58 d4       	cp.w	r4,13

8000342c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
8000342c:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80003430:	f0 1f 00 21 	mcall	800034b4 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003434:	4a 1b       	lddpc	r11,800034b8 <phy_init+0x8c>
80003436:	4a 2c       	lddpc	r12,800034bc <phy_init+0x90>
80003438:	f0 1f 00 22 	mcall	800034c0 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000343c:	30 4b       	mov	r11,4
8000343e:	31 ec       	mov	r12,30
80003440:	f0 1f 00 21 	mcall	800034c4 <phy_init+0x98>
80003444:	4a 18       	lddpc	r8,800034c8 <phy_init+0x9c>
80003446:	91 0c       	st.w	r8[0x0],r12
80003448:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
8000344a:	10 96       	mov	r6,r8
8000344c:	4a 05       	lddpc	r5,800034cc <phy_init+0xa0>
8000344e:	6c 0c       	ld.w	r12,r6[0x0]
80003450:	ea 07 00 0b 	add	r11,r5,r7
80003454:	f0 1f 00 1f 	mcall	800034d0 <phy_init+0xa4>
80003458:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000345c:	e0 47 1e 00 	cp.w	r7,7680
80003460:	cf 71       	brne	8000344e <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003462:	30 4b       	mov	r11,4
80003464:	31 4c       	mov	r12,20
80003466:	f0 1f 00 18 	mcall	800034c4 <phy_init+0x98>
8000346a:	49 b8       	lddpc	r8,800034d4 <phy_init+0xa8>
8000346c:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000346e:	30 4b       	mov	r11,4
80003470:	30 ac       	mov	r12,10
80003472:	f0 1f 00 15 	mcall	800034c4 <phy_init+0x98>
80003476:	49 98       	lddpc	r8,800034d8 <phy_init+0xac>
80003478:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000347a:	30 4b       	mov	r11,4
8000347c:	30 ac       	mov	r12,10
8000347e:	f0 1f 00 12 	mcall	800034c4 <phy_init+0x98>
80003482:	49 78       	lddpc	r8,800034dc <phy_init+0xb0>
80003484:	91 0c       	st.w	r8[0x0],r12
80003486:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80003488:	10 96       	mov	r6,r8
8000348a:	49 65       	lddpc	r5,800034e0 <phy_init+0xb4>
8000348c:	6c 0c       	ld.w	r12,r6[0x0]
8000348e:	ea 07 00 0b 	add	r11,r5,r7
80003492:	f0 1f 00 10 	mcall	800034d0 <phy_init+0xa4>
80003496:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000349a:	e0 47 14 00 	cp.w	r7,5120
8000349e:	cf 71       	brne	8000348c <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800034a0:	e0 6b 01 00 	mov	r11,256
800034a4:	30 5c       	mov	r12,5
800034a6:	f0 1f 00 08 	mcall	800034c4 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800034aa:	48 f8       	lddpc	r8,800034e4 <phy_init+0xb8>
800034ac:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800034ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800034b2:	00 00       	add	r0,r0
800034b4:	80 00       	ld.sh	r0,r0[0x0]
800034b6:	42 d8       	lddsp	r8,sp[0xb4]
800034b8:	80 00       	ld.sh	r0,r0[0x0]
800034ba:	2f 3c       	sub	r12,-13
800034bc:	80 00       	ld.sh	r0,r0[0x0]
800034be:	35 48       	mov	r8,84
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	42 c4       	lddsp	r4,sp[0xb0]
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	5b e0       	cp.w	r0,-2
800034c8:	00 00       	add	r0,r0
800034ca:	0a a8       	st.w	r5++,r8
800034cc:	00 00       	add	r0,r0
800034ce:	22 b2       	sub	r2,43
800034d0:	80 00       	ld.sh	r0,r0[0x0]
800034d2:	2e 98       	sub	r8,-23
800034d4:	00 00       	add	r0,r0
800034d6:	0a dc       	st.w	--r5,r12
800034d8:	00 00       	add	r0,r0
800034da:	0a d0       	st.w	--r5,r0
800034dc:	00 00       	add	r0,r0
800034de:	0a 84       	andn	r4,r5
800034e0:	00 00       	add	r0,r0
800034e2:	0e b2       	st.h	r7++,r2
800034e4:	00 00       	add	r0,r0
800034e6:	0a cc       	st.b	r5++,r12

800034e8 <payload_rx>:




static void payload_rx(void * payload)
{
800034e8:	d4 01       	pushm	lr
800034ea:	20 2d       	sub	sp,8
800034ec:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800034ee:	30 08       	mov	r8,0
800034f0:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800034f2:	48 f8       	lddpc	r8,8000352c <payload_rx+0x44>
800034f4:	70 08       	ld.w	r8,r8[0x0]
800034f6:	58 08       	cp.w	r8,0
800034f8:	c0 71       	brne	80003506 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800034fa:	30 4b       	mov	r11,4
800034fc:	30 5c       	mov	r12,5
800034fe:	f0 1f 00 0d 	mcall	80003530 <payload_rx+0x48>
80003502:	48 b8       	lddpc	r8,8000352c <payload_rx+0x44>
80003504:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80003506:	48 a8       	lddpc	r8,8000352c <payload_rx+0x44>
80003508:	70 0c       	ld.w	r12,r8[0x0]
8000350a:	30 09       	mov	r9,0
8000350c:	fa ca ff fc 	sub	r10,sp,-4
80003510:	1a 9b       	mov	r11,sp
80003512:	f0 1f 00 09 	mcall	80003534 <payload_rx+0x4c>
80003516:	c0 91       	brne	80003528 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003518:	48 88       	lddpc	r8,80003538 <payload_rx+0x50>
8000351a:	70 0c       	ld.w	r12,r8[0x0]
8000351c:	40 0b       	lddsp	r11,sp[0x0]
8000351e:	f0 1f 00 08 	mcall	8000353c <payload_rx+0x54>
		logFromISR("mm");
80003522:	48 8c       	lddpc	r12,80003540 <payload_rx+0x58>
80003524:	f0 1f 00 08 	mcall	80003544 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003528:	2f ed       	sub	sp,-8
8000352a:	d8 02       	popm	pc
8000352c:	00 00       	add	r0,r0
8000352e:	0a a0       	st.w	r5++,r0
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	5b e0       	cp.w	r0,-2
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	5a 90       	cp.w	r0,-23
80003538:	00 00       	add	r0,r0
8000353a:	0a 84       	andn	r4,r5
8000353c:	80 00       	ld.sh	r0,r0[0x0]
8000353e:	2e 44       	sub	r4,-28
80003540:	80 00       	ld.sh	r0,r0[0x0]
80003542:	d0 58       	*unknown*
80003544:	80 00       	ld.sh	r0,r0[0x0]
80003546:	68 04       	ld.w	r4,r4[0x0]

80003548 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003548:	eb cd 40 e0 	pushm	r5-r7,lr
8000354c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000354e:	fe f8 0b be 	ld.w	r8,pc[3006]
80003552:	70 08       	ld.w	r8,r8[0x0]
80003554:	58 08       	cp.w	r8,0
80003556:	e0 80 01 05 	breq	80003760 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000355a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
8000355c:	fe f8 0b b4 	ld.w	r8,pc[2996]
80003560:	70 09       	ld.w	r9,r8[0x0]
80003562:	2f f9       	sub	r9,-1
80003564:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003566:	fe f8 0b ae 	ld.w	r8,pc[2990]
8000356a:	70 08       	ld.w	r8,r8[0x0]
8000356c:	58 18       	cp.w	r8,1
8000356e:	e0 80 00 84 	breq	80003676 <phy_rx_func+0x12e>
80003572:	c0 73       	brcs	80003580 <phy_rx_func+0x38>
80003574:	58 28       	cp.w	r8,2
80003576:	c5 b0       	breq	8000362c <phy_rx_func+0xe4>
80003578:	58 38       	cp.w	r8,3
8000357a:	e0 81 00 f3 	brne	80003760 <phy_rx_func+0x218>
8000357e:	cd 38       	rjmp	80003724 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003580:	e0 6a 5a 5a 	mov	r10,23130
80003584:	ea 1a ab cd 	orh	r10,0xabcd
80003588:	14 36       	cp.w	r6,r10
8000358a:	e0 80 00 eb 	breq	80003760 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000358e:	ec 08 16 10 	lsr	r8,r6,0x10
80003592:	e0 48 ab cd 	cp.w	r8,43981
80003596:	e0 81 00 e5 	brne	80003760 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000359a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000359e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800035a2:	20 28       	sub	r8,2
800035a4:	fe f9 0b 74 	ld.w	r9,pc[2932]
800035a8:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800035aa:	30 09       	mov	r9,0
800035ac:	f2 08 19 00 	cp.h	r8,r9
800035b0:	e0 8a 00 d8 	brle	80003760 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800035b4:	fe f8 0b 68 	ld.w	r8,pc[2920]
800035b8:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800035ba:	fe f8 0b 66 	ld.w	r8,pc[2918]
800035be:	70 0c       	ld.w	r12,r8[0x0]
800035c0:	f0 1f 02 d9 	mcall	80004124 <phy_rx_func+0xbdc>
800035c4:	fe f8 0b 64 	ld.w	r8,pc[2916]
800035c8:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800035ca:	58 0c       	cp.w	r12,0
800035cc:	e0 80 00 ca 	breq	80003760 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800035d0:	fe f8 0b 4c 	ld.w	r8,pc[2892]
800035d4:	90 09       	ld.sh	r9,r8[0x0]
800035d6:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800035da:	2f f9       	sub	r9,-1
800035dc:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800035de:	fe fa 0b 4a 	ld.w	r10,pc[2890]
800035e2:	74 0a       	ld.w	r10,r10[0x0]
800035e4:	fe fb 0b 2c 	ld.w	r11,pc[2860]
800035e8:	76 0b       	ld.w	r11,r11[0x0]
800035ea:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800035ee:	2f f9       	sub	r9,-1
800035f0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800035f2:	e2 16 0f 00 	andl	r6,0xf00,COH
800035f6:	e0 46 01 00 	cp.w	r6,256
800035fa:	c0 c0       	breq	80003612 <phy_rx_func+0xca>
800035fc:	e0 8b 00 05 	brhi	80003606 <phy_rx_func+0xbe>
80003600:	58 06       	cp.w	r6,0
80003602:	c0 80       	breq	80003612 <phy_rx_func+0xca>
80003604:	c0 c8       	rjmp	8000361c <phy_rx_func+0xd4>
80003606:	e0 46 02 00 	cp.w	r6,512
8000360a:	c0 40       	breq	80003612 <phy_rx_func+0xca>
8000360c:	e0 46 03 00 	cp.w	r6,768
80003610:	c0 61       	brne	8000361c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003612:	30 29       	mov	r9,2
80003614:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003618:	91 09       	st.w	r8[0x0],r9
8000361a:	ca 38       	rjmp	80003760 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
8000361c:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003620:	6c 0c       	ld.w	r12,r6[0x0]
80003622:	f0 1f 02 c3 	mcall	8000412c <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
80003626:	30 08       	mov	r8,0
80003628:	8d 08       	st.w	r6[0x0],r8
8000362a:	c9 b8       	rjmp	80003760 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000362c:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003630:	b1 86       	lsr	r6,0x10
80003632:	14 06       	add	r6,r10
80003634:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003638:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000363a:	fe f8 0a e2 	ld.w	r8,pc[2786]
8000363e:	90 09       	ld.sh	r9,r8[0x0]
80003640:	fe fb 0a e8 	ld.w	r11,pc[2792]
80003644:	76 0b       	ld.w	r11,r11[0x0]
80003646:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000364a:	2f f9       	sub	r9,-1
8000364c:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000364e:	fe f9 0a ca 	ld.w	r9,pc[2762]
80003652:	92 08       	ld.sh	r8,r9[0x0]
80003654:	20 28       	sub	r8,2
80003656:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003658:	30 09       	mov	r9,0
8000365a:	f2 08 19 00 	cp.h	r8,r9
8000365e:	e0 8a 00 07 	brle	8000366c <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003662:	30 19       	mov	r9,1
80003664:	fe f8 0a b0 	ld.w	r8,pc[2736]
80003668:	91 09       	st.w	r8[0x0],r9
8000366a:	c7 b8       	rjmp	80003760 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000366c:	30 39       	mov	r9,3
8000366e:	fe f8 0a a6 	ld.w	r8,pc[2726]
80003672:	91 09       	st.w	r8[0x0],r9
80003674:	c7 68       	rjmp	80003760 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003676:	ec 0a 14 10 	asr	r10,r6,0x10
8000367a:	fe f8 0a b6 	ld.w	r8,pc[2742]
8000367e:	90 09       	ld.sh	r9,r8[0x0]
80003680:	14 09       	add	r9,r10
80003682:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003684:	fe f9 0a 98 	ld.w	r9,pc[2712]
80003688:	92 08       	ld.sh	r8,r9[0x0]
8000368a:	fe fb 0a 9e 	ld.w	r11,pc[2718]
8000368e:	76 0b       	ld.w	r11,r11[0x0]
80003690:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003694:	2f f8       	sub	r8,-1
80003696:	5c 88       	casts.h	r8
80003698:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000369a:	fe fa 0a 7e 	ld.w	r10,pc[2686]
8000369e:	94 09       	ld.sh	r9,r10[0x0]
800036a0:	20 29       	sub	r9,2
800036a2:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800036a4:	30 0a       	mov	r10,0
800036a6:	f4 09 19 00 	cp.h	r9,r10
800036aa:	e0 89 00 1f 	brgt	800036e8 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800036ae:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800036b2:	e0 46 00 ba 	cp.w	r6,186
800036b6:	c0 d1       	brne	800036d0 <phy_rx_func+0x188>
800036b8:	fe f8 0a 78 	ld.w	r8,pc[2680]
800036bc:	90 09       	ld.sh	r9,r8[0x0]
800036be:	f4 09 19 00 	cp.h	r9,r10
800036c2:	c0 71       	brne	800036d0 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800036c4:	fe f8 0a 64 	ld.w	r8,pc[2660]
800036c8:	70 0c       	ld.w	r12,r8[0x0]
800036ca:	f0 1f 02 9b 	mcall	80004134 <phy_rx_func+0xbec>
800036ce:	c0 88       	rjmp	800036de <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800036d0:	fe f6 0a 58 	ld.w	r6,pc[2648]
800036d4:	6c 0c       	ld.w	r12,r6[0x0]
800036d6:	f0 1f 02 96 	mcall	8000412c <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
800036da:	30 08       	mov	r8,0
800036dc:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800036de:	30 09       	mov	r9,0
800036e0:	fe f8 0a 34 	ld.w	r8,pc[2612]
800036e4:	91 09       	st.w	r8[0x0],r9
800036e6:	c3 d8       	rjmp	80003760 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800036e8:	5c 86       	casts.h	r6
800036ea:	fe f9 0a 46 	ld.w	r9,pc[2630]
800036ee:	92 0a       	ld.sh	r10,r9[0x0]
800036f0:	0c 0a       	add	r10,r6
800036f2:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800036f4:	fe f9 0a 34 	ld.w	r9,pc[2612]
800036f8:	72 09       	ld.w	r9,r9[0x0]
800036fa:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800036fe:	2f f8       	sub	r8,-1
80003700:	fe f9 0a 1c 	ld.w	r9,pc[2588]
80003704:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003706:	fe f9 0a 12 	ld.w	r9,pc[2578]
8000370a:	92 08       	ld.sh	r8,r9[0x0]
8000370c:	20 28       	sub	r8,2
8000370e:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003710:	30 09       	mov	r9,0
80003712:	f2 08 19 00 	cp.h	r8,r9
80003716:	e0 89 00 25 	brgt	80003760 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000371a:	30 39       	mov	r9,3
8000371c:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003720:	91 09       	st.w	r8[0x0],r9
80003722:	c1 f8       	rjmp	80003760 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003724:	e6 16 00 ff 	andh	r6,0xff,COH
80003728:	fc 19 00 ba 	movh	r9,0xba
8000372c:	12 36       	cp.w	r6,r9
8000372e:	c0 e1       	brne	8000374a <phy_rx_func+0x202>
80003730:	fe f8 0a 00 	ld.w	r8,pc[2560]
80003734:	90 09       	ld.sh	r9,r8[0x0]
80003736:	30 08       	mov	r8,0
80003738:	f0 09 19 00 	cp.h	r9,r8
8000373c:	c0 71       	brne	8000374a <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000373e:	fe f8 09 ea 	ld.w	r8,pc[2538]
80003742:	70 0c       	ld.w	r12,r8[0x0]
80003744:	f0 1f 02 7c 	mcall	80004134 <phy_rx_func+0xbec>
80003748:	c0 88       	rjmp	80003758 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000374a:	fe f6 09 de 	ld.w	r6,pc[2526]
8000374e:	6c 0c       	ld.w	r12,r6[0x0]
80003750:	f0 1f 02 77 	mcall	8000412c <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
80003754:	30 08       	mov	r8,0
80003756:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003758:	30 09       	mov	r9,0
8000375a:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000375e:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003760:	fe f8 09 d8 	ld.w	r8,pc[2520]
80003764:	11 89       	ld.ub	r9,r8[0x0]
80003766:	30 08       	mov	r8,0
80003768:	f0 09 18 00 	cp.b	r9,r8
8000376c:	c0 d1       	brne	80003786 <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
8000376e:	fe f8 09 ce 	ld.w	r8,pc[2510]
80003772:	70 0c       	ld.w	r12,r8[0x0]
80003774:	f0 1f 02 6c 	mcall	80004124 <phy_rx_func+0xbdc>
80003778:	fe f8 09 c8 	ld.w	r8,pc[2504]
8000377c:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000377e:	30 19       	mov	r9,1
80003780:	fe f8 09 b8 	ld.w	r8,pc[2488]
80003784:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003786:	fe f8 09 be 	ld.w	r8,pc[2494]
8000378a:	70 08       	ld.w	r8,r8[0x0]
8000378c:	58 38       	cp.w	r8,3
8000378e:	e0 80 04 7a 	breq	80004082 <phy_rx_func+0xb3a>
80003792:	58 48       	cp.w	r8,4
80003794:	e0 80 01 02 	breq	80003998 <phy_rx_func+0x450>
80003798:	58 08       	cp.w	r8,0
8000379a:	e0 81 04 b7 	brne	80004108 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000379e:	6e 28       	ld.w	r8,r7[0x8]
800037a0:	e0 6a 5a 5a 	mov	r10,23130
800037a4:	ea 1a ab cd 	orh	r10,0xabcd
800037a8:	14 38       	cp.w	r8,r10
800037aa:	c0 71       	brne	800037b8 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800037ac:	30 09       	mov	r9,0
800037ae:	fe f8 09 9a 	ld.w	r8,pc[2458]
800037b2:	91 09       	st.w	r8[0x0],r9
800037b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800037b8:	10 99       	mov	r9,r8
800037ba:	e0 19 00 00 	andl	r9,0x0
800037be:	fc 1a ab cd 	movh	r10,0xabcd
800037c2:	14 39       	cp.w	r9,r10
800037c4:	e0 81 04 a2 	brne	80004108 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800037c8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800037cc:	fe f9 09 80 	ld.w	r9,pc[2432]
800037d0:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
800037d2:	fe f8 09 6e 	ld.w	r8,pc[2414]
800037d6:	70 08       	ld.w	r8,r8[0x0]
800037d8:	58 08       	cp.w	r8,0
800037da:	c1 11       	brne	800037fc <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
800037dc:	fe f8 09 60 	ld.w	r8,pc[2400]
800037e0:	70 0c       	ld.w	r12,r8[0x0]
800037e2:	f0 1f 02 51 	mcall	80004124 <phy_rx_func+0xbdc>
800037e6:	fe f8 09 5a 	ld.w	r8,pc[2394]
800037ea:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
800037ec:	58 0c       	cp.w	r12,0
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800037f0:	fe fc 09 60 	ld.w	r12,pc[2400]
800037f4:	f0 1f 02 58 	mcall	80004154 <phy_rx_func+0xc0c>
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800037fc:	6e 28       	ld.w	r8,r7[0x8]
800037fe:	e2 18 f0 00 	andl	r8,0xf000,COH
80003802:	e0 48 c0 00 	cp.w	r8,49152
80003806:	e0 81 00 c3 	brne	8000398c <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
8000380a:	30 19       	mov	r9,1
8000380c:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003810:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
80003812:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003816:	fe f8 09 46 	ld.w	r8,pc[2374]
8000381a:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000381c:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003820:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003824:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003828:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000382a:	11 88       	ld.ub	r8,r8[0x0]
8000382c:	37 f9       	mov	r9,127
8000382e:	f2 08 18 00 	cp.b	r8,r9
80003832:	c6 d0       	breq	8000390c <phy_rx_func+0x3c4>
80003834:	e0 8b 00 0c 	brhi	8000384c <phy_rx_func+0x304>
80003838:	31 29       	mov	r9,18
8000383a:	f2 08 18 00 	cp.b	r8,r9
8000383e:	c4 20       	breq	800038c2 <phy_rx_func+0x37a>
80003840:	31 39       	mov	r9,19
80003842:	f2 08 18 00 	cp.b	r8,r9
80003846:	e0 81 00 83 	brne	8000394c <phy_rx_func+0x404>
8000384a:	c5 b8       	rjmp	80003900 <phy_rx_func+0x3b8>
8000384c:	2f 08       	sub	r8,-16
8000384e:	30 19       	mov	r9,1
80003850:	f2 08 18 00 	cp.b	r8,r9
80003854:	e0 8b 00 7c 	brhi	8000394c <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003858:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000385c:	e2 18 00 f0 	andl	r8,0xf0,COH
80003860:	59 08       	cp.w	r8,16
80003862:	c0 71       	brne	80003870 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
80003864:	30 19       	mov	r9,1
80003866:	fe f8 08 e2 	ld.w	r8,pc[2274]
8000386a:	91 09       	st.w	r8[0x0],r9
8000386c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003870:	e0 48 00 20 	cp.w	r8,32
80003874:	c2 11       	brne	800038b6 <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
80003876:	30 a9       	mov	r9,10
80003878:	fe f8 08 d0 	ld.w	r8,pc[2256]
8000387c:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000387e:	fe f6 08 e6 	ld.w	r6,pc[2278]
80003882:	6c 08       	ld.w	r8,r6[0x0]
80003884:	f0 0a 11 ff 	rsub	r10,r8,-1
80003888:	fe f7 08 b8 	ld.w	r7,pc[2232]
8000388c:	2f f8       	sub	r8,-1
8000388e:	6e 0c       	ld.w	r12,r7[0x0]
80003890:	f4 ca fe 00 	sub	r10,r10,-512
80003894:	30 0b       	mov	r11,0
80003896:	10 0c       	add	r12,r8
80003898:	f0 1f 02 34 	mcall	80004168 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
8000389c:	30 08       	mov	r8,0
8000389e:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800038a0:	6e 0c       	ld.w	r12,r7[0x0]
800038a2:	f0 1f 02 33 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800038a6:	fe f8 08 96 	ld.w	r8,pc[2198]
800038aa:	70 0c       	ld.w	r12,r8[0x0]
800038ac:	f0 1f 02 1e 	mcall	80004124 <phy_rx_func+0xbdc>
800038b0:	8f 0c       	st.w	r7[0x0],r12
800038b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800038b6:	30 09       	mov	r9,0
800038b8:	fe f8 08 90 	ld.w	r8,pc[2192]
800038bc:	91 09       	st.w	r8[0x0],r9
800038be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800038c2:	fe f9 08 8a 	ld.w	r9,pc[2186]
800038c6:	72 08       	ld.w	r8,r9[0x0]
800038c8:	20 48       	sub	r8,4
800038ca:	93 08       	st.w	r9[0x0],r8
800038cc:	e0 80 04 1e 	breq	80004108 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800038d0:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800038d4:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800038d8:	fe f8 08 98 	ld.w	r8,pc[2200]
800038dc:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800038de:	8e 69       	ld.sh	r9,r7[0xc]
800038e0:	fe f8 08 94 	ld.w	r8,pc[2196]
800038e4:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800038e6:	8e 79       	ld.sh	r9,r7[0xe]
800038e8:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800038ea:	f0 1f 02 24 	mcall	80004178 <phy_rx_func+0xc30>
800038ee:	fe f8 08 5a 	ld.w	r8,pc[2138]
800038f2:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800038f4:	30 49       	mov	r9,4
800038f6:	fe f8 08 4e 	ld.w	r8,pc[2126]
800038fa:	91 09       	st.w	r8[0x0],r9
800038fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003900:	30 09       	mov	r9,0
80003902:	fe f8 08 46 	ld.w	r8,pc[2118]
80003906:	91 09       	st.w	r8[0x0],r9
80003908:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000390c:	fe f9 08 40 	ld.w	r9,pc[2112]
80003910:	72 08       	ld.w	r8,r9[0x0]
80003912:	20 48       	sub	r8,4
80003914:	93 08       	st.w	r9[0x0],r8
80003916:	e0 80 03 f9 	breq	80004108 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000391a:	fe f8 08 62 	ld.w	r8,pc[2146]
8000391e:	70 09       	ld.w	r9,r8[0x0]
80003920:	8e 7b       	ld.sh	r11,r7[0xe]
80003922:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003926:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000392a:	2f f9       	sub	r9,-1
8000392c:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000392e:	fe f8 08 32 	ld.w	r8,pc[2098]
80003932:	70 09       	ld.w	r9,r8[0x0]
80003934:	20 29       	sub	r9,2
80003936:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003938:	30 29       	mov	r9,2
8000393a:	fe f8 08 0e 	ld.w	r8,pc[2062]
8000393e:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003940:	30 39       	mov	r9,3
80003942:	fe f8 08 02 	ld.w	r8,pc[2050]
80003946:	91 09       	st.w	r8[0x0],r9
80003948:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000394c:	30 39       	mov	r9,3
8000394e:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003952:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003954:	6e 29       	ld.w	r9,r7[0x8]
80003956:	fe f8 08 2e 	ld.w	r8,pc[2094]
8000395a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000395c:	6e 39       	ld.w	r9,r7[0xc]
8000395e:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003960:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003964:	70 08       	ld.w	r8,r8[0x0]
80003966:	59 48       	cp.w	r8,20
80003968:	c0 61       	brne	80003974 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000396a:	31 89       	mov	r9,24
8000396c:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003970:	91 09       	st.w	r8[0x0],r9
80003972:	c0 78       	rjmp	80003980 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003974:	59 08       	cp.w	r8,16
80003976:	c0 51       	brne	80003980 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003978:	31 09       	mov	r9,16
8000397a:	fe f8 07 d2 	ld.w	r8,pc[2002]
8000397e:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003980:	30 49       	mov	r9,4
80003982:	fe f8 07 c2 	ld.w	r8,pc[1986]
80003986:	91 09       	st.w	r8[0x0],r9
80003988:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
8000398c:	30 09       	mov	r9,0
8000398e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003992:	b0 89       	st.b	r8[0x0],r9
80003994:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003998:	fe f8 07 c4 	ld.w	r8,pc[1988]
8000399c:	11 89       	ld.ub	r9,r8[0x0]
8000399e:	31 28       	mov	r8,18
800039a0:	f0 09 18 00 	cp.b	r9,r8
800039a4:	e0 81 01 4c 	brne	80003c3c <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800039a8:	ef 39 00 09 	ld.ub	r9,r7[9]
800039ac:	fe f8 07 b0 	ld.w	r8,pc[1968]
800039b0:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800039b2:	11 89       	ld.ub	r9,r8[0x0]
800039b4:	3f 28       	mov	r8,-14
800039b6:	f0 09 18 00 	cp.b	r9,r8
800039ba:	e0 81 01 3b 	brne	80003c30 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
800039be:	30 19       	mov	r9,1
800039c0:	fe f8 07 c8 	ld.w	r8,pc[1992]
800039c4:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800039c6:	6e 29       	ld.w	r9,r7[0x8]
800039c8:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800039cc:	fe f8 07 80 	ld.w	r8,pc[1920]
800039d0:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800039d2:	8e 59       	ld.sh	r9,r7[0xa]
800039d4:	fe f8 07 b8 	ld.w	r8,pc[1976]
800039d8:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800039da:	8e 69       	ld.sh	r9,r7[0xc]
800039dc:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800039de:	8e 79       	ld.sh	r9,r7[0xe]
800039e0:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800039e2:	fe f8 07 82 	ld.w	r8,pc[1922]
800039e6:	fe f9 07 5a 	ld.w	r9,pc[1882]
800039ea:	72 0a       	ld.w	r10,r9[0x0]
800039ec:	70 09       	ld.w	r9,r8[0x0]
800039ee:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800039f2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039f6:	70 09       	ld.w	r9,r8[0x0]
800039f8:	2f f9       	sub	r9,-1
800039fa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039fc:	e0 49 01 ff 	cp.w	r9,511
80003a00:	e0 88 00 16 	brls	80003a2c <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a04:	30 09       	mov	r9,0
80003a06:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a08:	fe f6 07 38 	ld.w	r6,pc[1848]
80003a0c:	6c 0c       	ld.w	r12,r6[0x0]
80003a0e:	f0 1f 01 d8 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a12:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003a16:	70 0c       	ld.w	r12,r8[0x0]
80003a18:	f0 1f 01 c3 	mcall	80004124 <phy_rx_func+0xbdc>
80003a1c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a1e:	c0 71       	brne	80003a2c <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003a20:	30 09       	mov	r9,0
80003a22:	fe f8 07 22 	ld.w	r8,pc[1826]
80003a26:	91 09       	st.w	r8[0x0],r9
80003a28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a2c:	fe f9 07 20 	ld.w	r9,pc[1824]
80003a30:	72 08       	ld.w	r8,r9[0x0]
80003a32:	20 18       	sub	r8,1
80003a34:	93 08       	st.w	r9[0x0],r8
80003a36:	c0 71       	brne	80003a44 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003a38:	30 09       	mov	r9,0
80003a3a:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003a3e:	91 09       	st.w	r8[0x0],r9
80003a40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003a44:	fe f8 07 20 	ld.w	r8,pc[1824]
80003a48:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003a4c:	72 0a       	ld.w	r10,r9[0x0]
80003a4e:	70 09       	ld.w	r9,r8[0x0]
80003a50:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a54:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a58:	70 09       	ld.w	r9,r8[0x0]
80003a5a:	2f f9       	sub	r9,-1
80003a5c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a5e:	e0 49 01 ff 	cp.w	r9,511
80003a62:	e0 88 00 16 	brls	80003a8e <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a66:	30 09       	mov	r9,0
80003a68:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a6a:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003a6e:	6c 0c       	ld.w	r12,r6[0x0]
80003a70:	f0 1f 01 bf 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a74:	fe f8 06 c8 	ld.w	r8,pc[1736]
80003a78:	70 0c       	ld.w	r12,r8[0x0]
80003a7a:	f0 1f 01 ab 	mcall	80004124 <phy_rx_func+0xbdc>
80003a7e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a80:	c0 71       	brne	80003a8e <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
80003a82:	30 09       	mov	r9,0
80003a84:	fe f8 06 c0 	ld.w	r8,pc[1728]
80003a88:	91 09       	st.w	r8[0x0],r9
80003a8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a8e:	fe f9 06 be 	ld.w	r9,pc[1726]
80003a92:	72 08       	ld.w	r8,r9[0x0]
80003a94:	20 18       	sub	r8,1
80003a96:	93 08       	st.w	r9[0x0],r8
80003a98:	c0 71       	brne	80003aa6 <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
80003a9a:	30 09       	mov	r9,0
80003a9c:	fe f8 06 a8 	ld.w	r8,pc[1704]
80003aa0:	91 09       	st.w	r8[0x0],r9
80003aa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003aa6:	fe f8 06 be 	ld.w	r8,pc[1726]
80003aaa:	fe f9 06 96 	ld.w	r9,pc[1686]
80003aae:	72 0a       	ld.w	r10,r9[0x0]
80003ab0:	70 09       	ld.w	r9,r8[0x0]
80003ab2:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003ab6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003aba:	70 09       	ld.w	r9,r8[0x0]
80003abc:	2f f9       	sub	r9,-1
80003abe:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ac0:	e0 49 01 ff 	cp.w	r9,511
80003ac4:	e0 88 00 16 	brls	80003af0 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ac8:	30 09       	mov	r9,0
80003aca:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003acc:	fe f6 06 74 	ld.w	r6,pc[1652]
80003ad0:	6c 0c       	ld.w	r12,r6[0x0]
80003ad2:	f0 1f 01 a7 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ad6:	fe f8 06 66 	ld.w	r8,pc[1638]
80003ada:	70 0c       	ld.w	r12,r8[0x0]
80003adc:	f0 1f 01 92 	mcall	80004124 <phy_rx_func+0xbdc>
80003ae0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ae2:	c0 71       	brne	80003af0 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003ae4:	30 09       	mov	r9,0
80003ae6:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003aea:	91 09       	st.w	r8[0x0],r9
80003aec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003af0:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003af4:	72 08       	ld.w	r8,r9[0x0]
80003af6:	20 18       	sub	r8,1
80003af8:	93 08       	st.w	r9[0x0],r8
80003afa:	c0 71       	brne	80003b08 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003afc:	30 09       	mov	r9,0
80003afe:	fe f8 06 46 	ld.w	r8,pc[1606]
80003b02:	91 09       	st.w	r8[0x0],r9
80003b04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003b08:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003b0c:	fe f9 06 34 	ld.w	r9,pc[1588]
80003b10:	72 0a       	ld.w	r10,r9[0x0]
80003b12:	70 09       	ld.w	r9,r8[0x0]
80003b14:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003b18:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b1c:	70 09       	ld.w	r9,r8[0x0]
80003b1e:	2f f9       	sub	r9,-1
80003b20:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b22:	e0 49 01 ff 	cp.w	r9,511
80003b26:	e0 88 00 16 	brls	80003b52 <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b2a:	30 09       	mov	r9,0
80003b2c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b2e:	fe f6 06 12 	ld.w	r6,pc[1554]
80003b32:	6c 0c       	ld.w	r12,r6[0x0]
80003b34:	f0 1f 01 8e 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b38:	fe f8 06 04 	ld.w	r8,pc[1540]
80003b3c:	70 0c       	ld.w	r12,r8[0x0]
80003b3e:	f0 1f 01 7a 	mcall	80004124 <phy_rx_func+0xbdc>
80003b42:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b44:	c0 71       	brne	80003b52 <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
80003b46:	30 09       	mov	r9,0
80003b48:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003b4c:	91 09       	st.w	r8[0x0],r9
80003b4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b52:	fe f9 05 fa 	ld.w	r9,pc[1530]
80003b56:	72 08       	ld.w	r8,r9[0x0]
80003b58:	20 18       	sub	r8,1
80003b5a:	93 08       	st.w	r9[0x0],r8
80003b5c:	c0 71       	brne	80003b6a <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003b5e:	30 09       	mov	r9,0
80003b60:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003b64:	91 09       	st.w	r8[0x0],r9
80003b66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003b6a:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003b6e:	fe f9 05 d2 	ld.w	r9,pc[1490]
80003b72:	72 0a       	ld.w	r10,r9[0x0]
80003b74:	70 09       	ld.w	r9,r8[0x0]
80003b76:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b7a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b7e:	70 09       	ld.w	r9,r8[0x0]
80003b80:	2f f9       	sub	r9,-1
80003b82:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b84:	e0 49 01 ff 	cp.w	r9,511
80003b88:	e0 88 00 16 	brls	80003bb4 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b8c:	30 09       	mov	r9,0
80003b8e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b90:	fe f6 05 b0 	ld.w	r6,pc[1456]
80003b94:	6c 0c       	ld.w	r12,r6[0x0]
80003b96:	f0 1f 01 76 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b9a:	fe f8 05 a2 	ld.w	r8,pc[1442]
80003b9e:	70 0c       	ld.w	r12,r8[0x0]
80003ba0:	f0 1f 01 61 	mcall	80004124 <phy_rx_func+0xbdc>
80003ba4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ba6:	c0 71       	brne	80003bb4 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
80003ba8:	30 09       	mov	r9,0
80003baa:	fe f8 05 9a 	ld.w	r8,pc[1434]
80003bae:	91 09       	st.w	r8[0x0],r9
80003bb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bb4:	fe f9 05 98 	ld.w	r9,pc[1432]
80003bb8:	72 08       	ld.w	r8,r9[0x0]
80003bba:	20 18       	sub	r8,1
80003bbc:	93 08       	st.w	r9[0x0],r8
80003bbe:	c0 71       	brne	80003bcc <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003bc0:	30 09       	mov	r9,0
80003bc2:	fe f8 05 82 	ld.w	r8,pc[1410]
80003bc6:	91 09       	st.w	r8[0x0],r9
80003bc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003bcc:	fe f8 05 98 	ld.w	r8,pc[1432]
80003bd0:	fe f9 05 70 	ld.w	r9,pc[1392]
80003bd4:	72 0a       	ld.w	r10,r9[0x0]
80003bd6:	70 09       	ld.w	r9,r8[0x0]
80003bd8:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003bdc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003be0:	70 09       	ld.w	r9,r8[0x0]
80003be2:	2f f9       	sub	r9,-1
80003be4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003be6:	e0 49 01 ff 	cp.w	r9,511
80003bea:	e0 88 00 16 	brls	80003c16 <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bee:	30 09       	mov	r9,0
80003bf0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bf2:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003bf6:	6e 0c       	ld.w	r12,r7[0x0]
80003bf8:	f0 1f 01 5d 	mcall	8000416c <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bfc:	fe f8 05 40 	ld.w	r8,pc[1344]
80003c00:	70 0c       	ld.w	r12,r8[0x0]
80003c02:	f0 1f 01 49 	mcall	80004124 <phy_rx_func+0xbdc>
80003c06:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c08:	c0 71       	brne	80003c16 <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003c0a:	30 09       	mov	r9,0
80003c0c:	fe f8 05 38 	ld.w	r8,pc[1336]
80003c10:	91 09       	st.w	r8[0x0],r9
80003c12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c16:	fe f9 05 36 	ld.w	r9,pc[1334]
80003c1a:	72 08       	ld.w	r8,r9[0x0]
80003c1c:	20 18       	sub	r8,1
80003c1e:	93 08       	st.w	r9[0x0],r8
80003c20:	e0 81 02 74 	brne	80004108 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003c24:	30 09       	mov	r9,0
80003c26:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003c30:	30 09       	mov	r9,0
80003c32:	fe f8 05 12 	ld.w	r8,pc[1298]
80003c36:	91 09       	st.w	r8[0x0],r9
80003c38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003c3c:	fe f8 05 20 	ld.w	r8,pc[1312]
80003c40:	11 89       	ld.ub	r9,r8[0x0]
80003c42:	3f 28       	mov	r8,-14
80003c44:	f0 09 18 00 	cp.b	r9,r8
80003c48:	c4 31       	brne	80003cce <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003c4a:	8e 49       	ld.sh	r9,r7[0x8]
80003c4c:	fe f8 05 40 	ld.w	r8,pc[1344]
80003c50:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003c52:	fe f8 05 12 	ld.w	r8,pc[1298]
80003c56:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003c5a:	72 0a       	ld.w	r10,r9[0x0]
80003c5c:	70 09       	ld.w	r9,r8[0x0]
80003c5e:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003c62:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c66:	70 09       	ld.w	r9,r8[0x0]
80003c68:	2f f9       	sub	r9,-1
80003c6a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c6c:	e0 49 01 ff 	cp.w	r9,511
80003c70:	e0 88 00 16 	brls	80003c9c <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c74:	30 09       	mov	r9,0
80003c76:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c78:	fe f7 04 c8 	ld.w	r7,pc[1224]
80003c7c:	6e 0c       	ld.w	r12,r7[0x0]
80003c7e:	f0 1f 01 3c 	mcall	8000416c <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c82:	fe f8 04 ba 	ld.w	r8,pc[1210]
80003c86:	70 0c       	ld.w	r12,r8[0x0]
80003c88:	f0 1f 01 27 	mcall	80004124 <phy_rx_func+0xbdc>
80003c8c:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c8e:	c0 71       	brne	80003c9c <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
80003c90:	30 09       	mov	r9,0
80003c92:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003c96:	91 09       	st.w	r8[0x0],r9
80003c98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c9c:	fe f9 04 b0 	ld.w	r9,pc[1200]
80003ca0:	72 08       	ld.w	r8,r9[0x0]
80003ca2:	20 18       	sub	r8,1
80003ca4:	93 08       	st.w	r9[0x0],r8
80003ca6:	c0 71       	brne	80003cb4 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
80003ca8:	30 09       	mov	r9,0
80003caa:	fe f8 04 9a 	ld.w	r8,pc[1178]
80003cae:	91 09       	st.w	r8[0x0],r9
80003cb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003cb4:	20 18       	sub	r8,1
80003cb6:	fe f9 04 96 	ld.w	r9,pc[1174]
80003cba:	93 08       	st.w	r9[0x0],r8
80003cbc:	58 08       	cp.w	r8,0
80003cbe:	e0 81 02 25 	brne	80004108 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003cc2:	30 09       	mov	r9,0
80003cc4:	fe f8 04 80 	ld.w	r8,pc[1152]
80003cc8:	91 09       	st.w	r8[0x0],r9
80003cca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003cce:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003cd2:	11 89       	ld.ub	r9,r8[0x0]
80003cd4:	3f 38       	mov	r8,-13
80003cd6:	f0 09 18 00 	cp.b	r9,r8
80003cda:	e0 81 01 0c 	brne	80003ef2 <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003cde:	8e 49       	ld.sh	r9,r7[0x8]
80003ce0:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003ce4:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003ce6:	8e 59       	ld.sh	r9,r7[0xa]
80003ce8:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003cea:	8e 69       	ld.sh	r9,r7[0xc]
80003cec:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003cee:	fe f8 04 76 	ld.w	r8,pc[1142]
80003cf2:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003cf6:	72 0a       	ld.w	r10,r9[0x0]
80003cf8:	70 09       	ld.w	r9,r8[0x0]
80003cfa:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003cfe:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d02:	70 09       	ld.w	r9,r8[0x0]
80003d04:	2f f9       	sub	r9,-1
80003d06:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d08:	e0 49 01 ff 	cp.w	r9,511
80003d0c:	e0 88 00 16 	brls	80003d38 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d10:	30 09       	mov	r9,0
80003d12:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d14:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003d18:	6c 0c       	ld.w	r12,r6[0x0]
80003d1a:	f0 1f 01 15 	mcall	8000416c <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d1e:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003d22:	70 0c       	ld.w	r12,r8[0x0]
80003d24:	f0 1f 01 00 	mcall	80004124 <phy_rx_func+0xbdc>
80003d28:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d2a:	c0 71       	brne	80003d38 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003d2c:	30 09       	mov	r9,0
80003d2e:	fe f8 04 16 	ld.w	r8,pc[1046]
80003d32:	91 09       	st.w	r8[0x0],r9
80003d34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d38:	fe f9 04 14 	ld.w	r9,pc[1044]
80003d3c:	72 08       	ld.w	r8,r9[0x0]
80003d3e:	20 18       	sub	r8,1
80003d40:	93 08       	st.w	r9[0x0],r8
80003d42:	c0 71       	brne	80003d50 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003d44:	30 09       	mov	r9,0
80003d46:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003d4a:	91 09       	st.w	r8[0x0],r9
80003d4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003d50:	fe f8 04 14 	ld.w	r8,pc[1044]
80003d54:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003d58:	72 0a       	ld.w	r10,r9[0x0]
80003d5a:	70 09       	ld.w	r9,r8[0x0]
80003d5c:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003d60:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d64:	70 09       	ld.w	r9,r8[0x0]
80003d66:	2f f9       	sub	r9,-1
80003d68:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d6a:	e0 49 01 ff 	cp.w	r9,511
80003d6e:	e0 88 00 16 	brls	80003d9a <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d72:	30 09       	mov	r9,0
80003d74:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d76:	fe f6 03 ca 	ld.w	r6,pc[970]
80003d7a:	6c 0c       	ld.w	r12,r6[0x0]
80003d7c:	f0 1f 00 fc 	mcall	8000416c <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d80:	fe f8 03 bc 	ld.w	r8,pc[956]
80003d84:	70 0c       	ld.w	r12,r8[0x0]
80003d86:	f0 1f 00 e8 	mcall	80004124 <phy_rx_func+0xbdc>
80003d8a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d8c:	c0 71       	brne	80003d9a <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
80003d8e:	30 09       	mov	r9,0
80003d90:	fe f8 03 b4 	ld.w	r8,pc[948]
80003d94:	91 09       	st.w	r8[0x0],r9
80003d96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d9a:	fe f9 03 b2 	ld.w	r9,pc[946]
80003d9e:	72 08       	ld.w	r8,r9[0x0]
80003da0:	20 18       	sub	r8,1
80003da2:	93 08       	st.w	r9[0x0],r8
80003da4:	c0 71       	brne	80003db2 <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
80003da6:	30 09       	mov	r9,0
80003da8:	fe f8 03 9c 	ld.w	r8,pc[924]
80003dac:	91 09       	st.w	r8[0x0],r9
80003dae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003db2:	fe f8 03 b2 	ld.w	r8,pc[946]
80003db6:	fe f9 03 8a 	ld.w	r9,pc[906]
80003dba:	72 0a       	ld.w	r10,r9[0x0]
80003dbc:	70 09       	ld.w	r9,r8[0x0]
80003dbe:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003dc2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dc6:	70 09       	ld.w	r9,r8[0x0]
80003dc8:	2f f9       	sub	r9,-1
80003dca:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dcc:	e0 49 01 ff 	cp.w	r9,511
80003dd0:	e0 88 00 16 	brls	80003dfc <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dd4:	30 09       	mov	r9,0
80003dd6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003dd8:	fe f6 03 68 	ld.w	r6,pc[872]
80003ddc:	6c 0c       	ld.w	r12,r6[0x0]
80003dde:	f0 1f 00 e4 	mcall	8000416c <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003de2:	fe f8 03 5a 	ld.w	r8,pc[858]
80003de6:	70 0c       	ld.w	r12,r8[0x0]
80003de8:	f0 1f 00 cf 	mcall	80004124 <phy_rx_func+0xbdc>
80003dec:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003dee:	c0 71       	brne	80003dfc <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003df0:	30 09       	mov	r9,0
80003df2:	fe f8 03 52 	ld.w	r8,pc[850]
80003df6:	91 09       	st.w	r8[0x0],r9
80003df8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003dfc:	fe f9 03 50 	ld.w	r9,pc[848]
80003e00:	72 08       	ld.w	r8,r9[0x0]
80003e02:	20 18       	sub	r8,1
80003e04:	93 08       	st.w	r9[0x0],r8
80003e06:	c0 71       	brne	80003e14 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003e08:	30 09       	mov	r9,0
80003e0a:	fe f8 03 3a 	ld.w	r8,pc[826]
80003e0e:	91 09       	st.w	r8[0x0],r9
80003e10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003e14:	fe f8 03 50 	ld.w	r8,pc[848]
80003e18:	fe f9 03 28 	ld.w	r9,pc[808]
80003e1c:	72 0a       	ld.w	r10,r9[0x0]
80003e1e:	70 09       	ld.w	r9,r8[0x0]
80003e20:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003e24:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e28:	70 09       	ld.w	r9,r8[0x0]
80003e2a:	2f f9       	sub	r9,-1
80003e2c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e2e:	e0 49 01 ff 	cp.w	r9,511
80003e32:	e0 88 00 16 	brls	80003e5e <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e36:	30 09       	mov	r9,0
80003e38:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e3a:	fe f6 03 06 	ld.w	r6,pc[774]
80003e3e:	6c 0c       	ld.w	r12,r6[0x0]
80003e40:	f0 1f 00 cb 	mcall	8000416c <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e44:	fe f8 02 f8 	ld.w	r8,pc[760]
80003e48:	70 0c       	ld.w	r12,r8[0x0]
80003e4a:	f0 1f 00 b7 	mcall	80004124 <phy_rx_func+0xbdc>
80003e4e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e50:	c0 71       	brne	80003e5e <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003e52:	30 09       	mov	r9,0
80003e54:	fe f8 02 f0 	ld.w	r8,pc[752]
80003e58:	91 09       	st.w	r8[0x0],r9
80003e5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e5e:	fe f9 02 ee 	ld.w	r9,pc[750]
80003e62:	72 08       	ld.w	r8,r9[0x0]
80003e64:	20 18       	sub	r8,1
80003e66:	93 08       	st.w	r9[0x0],r8
80003e68:	c0 71       	brne	80003e76 <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003e6a:	30 09       	mov	r9,0
80003e6c:	fe f8 02 d8 	ld.w	r8,pc[728]
80003e70:	91 09       	st.w	r8[0x0],r9
80003e72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003e76:	fe f8 02 ee 	ld.w	r8,pc[750]
80003e7a:	fe f9 02 c6 	ld.w	r9,pc[710]
80003e7e:	72 0a       	ld.w	r10,r9[0x0]
80003e80:	70 09       	ld.w	r9,r8[0x0]
80003e82:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003e86:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e8a:	70 09       	ld.w	r9,r8[0x0]
80003e8c:	2f f9       	sub	r9,-1
80003e8e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e90:	e0 49 01 ff 	cp.w	r9,511
80003e94:	e0 88 00 16 	brls	80003ec0 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e98:	30 09       	mov	r9,0
80003e9a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e9c:	fe f7 02 a4 	ld.w	r7,pc[676]
80003ea0:	6e 0c       	ld.w	r12,r7[0x0]
80003ea2:	f0 1f 00 b3 	mcall	8000416c <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ea6:	fe f8 02 96 	ld.w	r8,pc[662]
80003eaa:	70 0c       	ld.w	r12,r8[0x0]
80003eac:	f0 1f 00 9e 	mcall	80004124 <phy_rx_func+0xbdc>
80003eb0:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003eb2:	c0 71       	brne	80003ec0 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
80003eb4:	30 09       	mov	r9,0
80003eb6:	fe f8 02 8e 	ld.w	r8,pc[654]
80003eba:	91 09       	st.w	r8[0x0],r9
80003ebc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ec0:	fe f9 02 8c 	ld.w	r9,pc[652]
80003ec4:	72 08       	ld.w	r8,r9[0x0]
80003ec6:	20 18       	sub	r8,1
80003ec8:	93 08       	st.w	r9[0x0],r8
80003eca:	c0 71       	brne	80003ed8 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80003ecc:	30 09       	mov	r9,0
80003ece:	fe f8 02 76 	ld.w	r8,pc[630]
80003ed2:	91 09       	st.w	r8[0x0],r9
80003ed4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003ed8:	20 18       	sub	r8,1
80003eda:	fe f9 02 72 	ld.w	r9,pc[626]
80003ede:	93 08       	st.w	r9[0x0],r8
80003ee0:	58 08       	cp.w	r8,0
80003ee2:	e0 81 01 13 	brne	80004108 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003ee6:	30 09       	mov	r9,0
80003ee8:	fe f8 02 5c 	ld.w	r8,pc[604]
80003eec:	91 09       	st.w	r8[0x0],r9
80003eee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003ef2:	fe f8 02 6a 	ld.w	r8,pc[618]
80003ef6:	11 89       	ld.ub	r9,r8[0x0]
80003ef8:	30 48       	mov	r8,4
80003efa:	f0 09 18 00 	cp.b	r9,r8
80003efe:	c0 80       	breq	80003f0e <phy_rx_func+0x9c6>
80003f00:	fe f8 02 5c 	ld.w	r8,pc[604]
80003f04:	11 89       	ld.ub	r9,r8[0x0]
80003f06:	30 38       	mov	r8,3
80003f08:	f0 09 18 00 	cp.b	r9,r8
80003f0c:	c1 41       	brne	80003f34 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003f0e:	6e 29       	ld.w	r9,r7[0x8]
80003f10:	fe f8 02 74 	ld.w	r8,pc[628]
80003f14:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003f16:	6e 39       	ld.w	r9,r7[0xc]
80003f18:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003f1a:	fe f9 02 32 	ld.w	r9,pc[562]
80003f1e:	72 08       	ld.w	r8,r9[0x0]
80003f20:	20 88       	sub	r8,8
80003f22:	93 08       	st.w	r9[0x0],r8
80003f24:	e0 81 00 f2 	brne	80004108 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003f28:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003f2a:	fe f9 02 1a 	ld.w	r9,pc[538]
80003f2e:	93 08       	st.w	r9[0x0],r8
80003f30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003f34:	fe f8 02 28 	ld.w	r8,pc[552]
80003f38:	11 89       	ld.ub	r9,r8[0x0]
80003f3a:	31 38       	mov	r8,19
80003f3c:	f0 09 18 00 	cp.b	r9,r8
80003f40:	e0 81 00 9c 	brne	80004078 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003f44:	fe f8 02 4c 	ld.w	r8,pc[588]
80003f48:	11 88       	ld.ub	r8,r8[0x0]
80003f4a:	30 c9       	mov	r9,12
80003f4c:	f2 08 18 00 	cp.b	r8,r9
80003f50:	e0 81 00 7b 	brne	80004046 <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003f54:	8e 49       	ld.sh	r9,r7[0x8]
80003f56:	fe f8 02 3e 	ld.w	r8,pc[574]
80003f5a:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003f5e:	30 09       	mov	r9,0
80003f60:	fe f8 02 30 	ld.w	r8,pc[560]
80003f64:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003f66:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003f6a:	3f 38       	mov	r8,-13
80003f6c:	f0 09 18 00 	cp.b	r9,r8
80003f70:	c6 61       	brne	8000403c <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003f72:	10 99       	mov	r9,r8
80003f74:	4f a8       	lddpc	r8,8000415c <phy_rx_func+0xc14>
80003f76:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003f78:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003f7c:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003f80:	4f 38       	lddpc	r8,8000414c <phy_rx_func+0xc04>
80003f82:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003f84:	30 19       	mov	r9,1
80003f86:	fe f8 02 12 	ld.w	r8,pc[530]
80003f8a:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003f8c:	8e 79       	ld.sh	r9,r7[0xe]
80003f8e:	fe f8 01 fe 	ld.w	r8,pc[510]
80003f92:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003f94:	4f 48       	lddpc	r8,80004164 <phy_rx_func+0xc1c>
80003f96:	4e b9       	lddpc	r9,80004140 <phy_rx_func+0xbf8>
80003f98:	72 0a       	ld.w	r10,r9[0x0]
80003f9a:	70 09       	ld.w	r9,r8[0x0]
80003f9c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003fa0:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003fa4:	70 09       	ld.w	r9,r8[0x0]
80003fa6:	2f f9       	sub	r9,-1
80003fa8:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003faa:	e0 49 01 ff 	cp.w	r9,511
80003fae:	e0 88 00 13 	brls	80003fd4 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003fb2:	30 09       	mov	r9,0
80003fb4:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003fb6:	4e 36       	lddpc	r6,80004140 <phy_rx_func+0xbf8>
80003fb8:	6c 0c       	ld.w	r12,r6[0x0]
80003fba:	f0 1f 00 6d 	mcall	8000416c <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003fbe:	4e 08       	lddpc	r8,8000413c <phy_rx_func+0xbf4>
80003fc0:	70 0c       	ld.w	r12,r8[0x0]
80003fc2:	f0 1f 00 59 	mcall	80004124 <phy_rx_func+0xbdc>
80003fc6:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003fc8:	c0 61       	brne	80003fd4 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003fca:	30 09       	mov	r9,0
80003fcc:	4d e8       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
80003fce:	91 09       	st.w	r8[0x0],r9
80003fd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003fd4:	4d e9       	lddpc	r9,8000414c <phy_rx_func+0xc04>
80003fd6:	72 08       	ld.w	r8,r9[0x0]
80003fd8:	20 18       	sub	r8,1
80003fda:	93 08       	st.w	r9[0x0],r8
80003fdc:	c0 61       	brne	80003fe8 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003fde:	30 09       	mov	r9,0
80003fe0:	4d 98       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
80003fe2:	91 09       	st.w	r8[0x0],r9
80003fe4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003fe8:	4d f8       	lddpc	r8,80004164 <phy_rx_func+0xc1c>
80003fea:	4d 69       	lddpc	r9,80004140 <phy_rx_func+0xbf8>
80003fec:	72 0a       	ld.w	r10,r9[0x0]
80003fee:	70 09       	ld.w	r9,r8[0x0]
80003ff0:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003ff4:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ff8:	70 09       	ld.w	r9,r8[0x0]
80003ffa:	2f f9       	sub	r9,-1
80003ffc:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ffe:	e0 49 01 ff 	cp.w	r9,511
80004002:	e0 88 00 13 	brls	80004028 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80004006:	30 09       	mov	r9,0
80004008:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000400a:	4c e7       	lddpc	r7,80004140 <phy_rx_func+0xbf8>
8000400c:	6e 0c       	ld.w	r12,r7[0x0]
8000400e:	f0 1f 00 58 	mcall	8000416c <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80004012:	4c b8       	lddpc	r8,8000413c <phy_rx_func+0xbf4>
80004014:	70 0c       	ld.w	r12,r8[0x0]
80004016:	f0 1f 00 44 	mcall	80004124 <phy_rx_func+0xbdc>
8000401a:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000401c:	c0 61       	brne	80004028 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
8000401e:	30 09       	mov	r9,0
80004020:	4c 98       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
80004022:	91 09       	st.w	r8[0x0],r9
80004024:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004028:	4c 99       	lddpc	r9,8000414c <phy_rx_func+0xc04>
8000402a:	72 08       	ld.w	r8,r9[0x0]
8000402c:	20 18       	sub	r8,1
8000402e:	93 08       	st.w	r9[0x0],r8
80004030:	c6 c1       	brne	80004108 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80004032:	30 09       	mov	r9,0
80004034:	4c 48       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
80004036:	91 09       	st.w	r8[0x0],r9
80004038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
8000403c:	30 09       	mov	r9,0
8000403e:	4c 28       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
80004040:	91 09       	st.w	r8[0x0],r9
80004042:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004046:	8e 4a       	ld.sh	r10,r7[0x8]
80004048:	4d 39       	lddpc	r9,80004194 <phy_rx_func+0xc4c>
8000404a:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
8000404e:	4d 1a       	lddpc	r10,80004190 <phy_rx_func+0xc48>
80004050:	15 88       	ld.ub	r8,r10[0x0]
80004052:	f0 cb ff ff 	sub	r11,r8,-1
80004056:	8e 5c       	ld.sh	r12,r7[0xa]
80004058:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
8000405c:	f0 cb ff fe 	sub	r11,r8,-2
80004060:	8e 6c       	ld.sh	r12,r7[0xc]
80004062:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004066:	f0 cb ff fd 	sub	r11,r8,-3
8000406a:	8e 7c       	ld.sh	r12,r7[0xe]
8000406c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80004070:	2f c8       	sub	r8,-4
80004072:	b4 88       	st.b	r10[0x0],r8
80004074:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004078:	30 09       	mov	r9,0
8000407a:	4b 38       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
8000407c:	91 09       	st.w	r8[0x0],r9
8000407e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004082:	4b f8       	lddpc	r8,8000417c <phy_rx_func+0xc34>
80004084:	70 09       	ld.w	r9,r8[0x0]
80004086:	8e 4b       	ld.sh	r11,r7[0x8]
80004088:	4b ea       	lddpc	r10,80004180 <phy_rx_func+0xc38>
8000408a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
8000408e:	2f f9       	sub	r9,-1
80004090:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80004092:	4b 48       	lddpc	r8,80004160 <phy_rx_func+0xc18>
80004094:	70 09       	ld.w	r9,r8[0x0]
80004096:	20 29       	sub	r9,2
80004098:	91 09       	st.w	r8[0x0],r9
8000409a:	70 08       	ld.w	r8,r8[0x0]
8000409c:	58 08       	cp.w	r8,0
8000409e:	c2 f1       	brne	800040fc <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
800040a0:	30 09       	mov	r9,0
800040a2:	4b 78       	lddpc	r8,8000417c <phy_rx_func+0xc34>
800040a4:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040a6:	8e 59       	ld.sh	r9,r7[0xa]
800040a8:	fe 78 82 12 	mov	r8,-32238
800040ac:	f0 09 19 00 	cp.h	r9,r8
800040b0:	c2 11       	brne	800040f2 <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800040b2:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800040b6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800040ba:	4a e8       	lddpc	r8,80004170 <phy_rx_func+0xc28>
800040bc:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800040be:	8e 59       	ld.sh	r9,r7[0xa]
800040c0:	4a d8       	lddpc	r8,80004174 <phy_rx_func+0xc2c>
800040c2:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800040c4:	8e 69       	ld.sh	r9,r7[0xc]
800040c6:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800040c8:	f0 1f 00 2c 	mcall	80004178 <phy_rx_func+0xc30>
800040cc:	49 f8       	lddpc	r8,80004148 <phy_rx_func+0xc00>
800040ce:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040d0:	ef 39 00 0f 	ld.ub	r9,r7[15]
800040d4:	31 38       	mov	r8,19
800040d6:	f0 09 18 00 	cp.b	r9,r8
800040da:	c0 71       	brne	800040e8 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
800040dc:	10 99       	mov	r9,r8
800040de:	4a 08       	lddpc	r8,8000415c <phy_rx_func+0xc14>
800040e0:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
800040e2:	30 09       	mov	r9,0
800040e4:	49 a8       	lddpc	r8,8000414c <phy_rx_func+0xc04>
800040e6:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800040e8:	30 49       	mov	r9,4
800040ea:	49 78       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
800040ec:	91 09       	st.w	r8[0x0],r9
800040ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800040f2:	30 09       	mov	r9,0
800040f4:	49 48       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
800040f6:	91 09       	st.w	r8[0x0],r9
800040f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
800040fc:	4a 8c       	lddpc	r12,8000419c <phy_rx_func+0xc54>
800040fe:	f0 1f 00 16 	mcall	80004154 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80004102:	30 09       	mov	r9,0
80004104:	49 08       	lddpc	r8,80004144 <phy_rx_func+0xbfc>
80004106:	91 09       	st.w	r8[0x0],r9
80004108:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000410c:	00 00       	add	r0,r0
8000410e:	0a d0       	st.w	--r5,r0
80004110:	00 00       	add	r0,r0
80004112:	0a c8       	st.b	r5++,r8
80004114:	00 00       	add	r0,r0
80004116:	0a 9c       	mov	r12,r5
80004118:	00 00       	add	r0,r0
8000411a:	0a 78       	tst	r8,r5
8000411c:	00 00       	add	r0,r0
8000411e:	0a e2       	st.h	--r5,r2
80004120:	00 00       	add	r0,r0
80004122:	0a a8       	st.w	r5++,r8
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	2f 14       	sub	r4,-15
80004128:	00 00       	add	r0,r0
8000412a:	0a 88       	andn	r8,r5
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	57 64       	stdsp	sp[0x1d8],r4
80004130:	00 00       	add	r0,r0
80004132:	0a a4       	st.w	r5++,r4
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	2e 60       	sub	r0,-26
80004138:	00 00       	add	r0,r0
8000413a:	0a b8       	st.h	r5++,r8
8000413c:	00 00       	add	r0,r0
8000413e:	0a 84       	andn	r4,r5
80004140:	00 00       	add	r0,r0
80004142:	0a c0       	st.b	r5++,r0
80004144:	00 00       	add	r0,r0
80004146:	0a 94       	mov	r4,r5
80004148:	00 00       	add	r0,r0
8000414a:	0a 80       	andn	r0,r5
8000414c:	00 00       	add	r0,r0
8000414e:	0a ac       	st.w	r5++,r12
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	d0 5c       	*unknown*
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	68 04       	ld.w	r4,r4[0x0]
80004158:	00 00       	add	r0,r0
8000415a:	0a 5f       	eor	pc,r5
8000415c:	00 00       	add	r0,r0
8000415e:	0a e0       	st.h	--r5,r0
80004160:	00 00       	add	r0,r0
80004162:	0a 7c       	tst	r12,r5
80004164:	00 00       	add	r0,r0
80004166:	0a bc       	st.h	r5++,r12
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	71 54       	ld.w	r4,r8[0x54]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	34 e8       	mov	r8,78
80004170:	00 00       	add	r0,r0
80004172:	0a 50       	eor	r0,r5
80004174:	00 00       	add	r0,r0
80004176:	0e 94       	mov	r4,r7
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	2d a4       	sub	r4,-38
8000417c:	00 00       	add	r0,r0
8000417e:	0a d8       	st.w	--r5,r8
80004180:	00 00       	add	r0,r0
80004182:	0d 98       	ld.ub	r8,r6[0x1]
80004184:	00 00       	add	r0,r0
80004186:	0a e4       	st.h	--r5,r4
80004188:	00 00       	add	r0,r0
8000418a:	0a 62       	and	r2,r5
8000418c:	00 00       	add	r0,r0
8000418e:	0d 90       	ld.ub	r0,r6[0x1]
80004190:	00 00       	add	r0,r0
80004192:	0a 98       	mov	r8,r5
80004194:	00 00       	add	r0,r0
80004196:	0e 98       	mov	r8,r7
80004198:	00 00       	add	r0,r0
8000419a:	0a 5e       	eor	lr,r5
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	d0 74       	*unknown*

800041a0 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800041a0:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800041a2:	49 88       	lddpc	r8,80004200 <pdca_int_handler+0x60>
800041a4:	11 89       	ld.ub	r9,r8[0x0]
800041a6:	ec 19 00 01 	eorl	r9,0x1
800041aa:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800041ac:	11 89       	ld.ub	r9,r8[0x0]
800041ae:	a5 69       	lsl	r9,0x4
800041b0:	2f c9       	sub	r9,-4
800041b2:	49 5a       	lddpc	r10,80004204 <pdca_int_handler+0x64>
800041b4:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800041b6:	fe 7a 00 40 	mov	r10,-65472
800041ba:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800041bc:	30 39       	mov	r9,3
800041be:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800041c0:	11 8a       	ld.ub	r10,r8[0x0]
800041c2:	a5 6a       	lsl	r10,0x4
800041c4:	2f ca       	sub	r10,-4
800041c6:	49 18       	lddpc	r8,80004208 <pdca_int_handler+0x68>
800041c8:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800041ca:	fe 78 00 00 	mov	r8,-65536
800041ce:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800041d0:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800041d2:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800041d4:	48 e8       	lddpc	r8,8000420c <pdca_int_handler+0x6c>
800041d6:	70 08       	ld.w	r8,r8[0x0]
800041d8:	58 08       	cp.w	r8,0
800041da:	c0 70       	breq	800041e8 <pdca_int_handler+0x48>
800041dc:	48 99       	lddpc	r9,80004200 <pdca_int_handler+0x60>
800041de:	13 89       	ld.ub	r9,r9[0x0]
800041e0:	a5 69       	lsl	r9,0x4
800041e2:	48 ac       	lddpc	r12,80004208 <pdca_int_handler+0x68>
800041e4:	12 0c       	add	r12,r9
800041e6:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800041e8:	48 a8       	lddpc	r8,80004210 <pdca_int_handler+0x70>
800041ea:	70 08       	ld.w	r8,r8[0x0]
800041ec:	58 08       	cp.w	r8,0
800041ee:	c0 70       	breq	800041fc <pdca_int_handler+0x5c>
800041f0:	48 49       	lddpc	r9,80004200 <pdca_int_handler+0x60>
800041f2:	13 89       	ld.ub	r9,r9[0x0]
800041f4:	a5 69       	lsl	r9,0x4
800041f6:	48 4c       	lddpc	r12,80004204 <pdca_int_handler+0x64>
800041f8:	12 0c       	add	r12,r9
800041fa:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800041fc:	d4 02       	popm	lr
800041fe:	d6 03       	rete
80004200:	00 00       	add	r0,r0
80004202:	40 b8       	lddsp	r8,sp[0x2c]
80004204:	00 00       	add	r0,r0
80004206:	40 e0       	lddsp	r0,sp[0x38]
80004208:	00 00       	add	r0,r0
8000420a:	40 c0       	lddsp	r0,sp[0x30]
8000420c:	00 00       	add	r0,r0
8000420e:	0a ec       	st.h	--r5,r12
80004210:	00 00       	add	r0,r0
80004212:	0a f0       	st.b	--r5,r0

80004214 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004214:	fe 78 10 00 	mov	r8,-61440
80004218:	e0 69 0d c0 	mov	r9,3520
8000421c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004220:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004224:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004228:	fe 78 34 00 	mov	r8,-52224
8000422c:	e0 69 80 00 	mov	r9,32768
80004230:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004232:	30 09       	mov	r9,0
80004234:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004236:	e0 69 04 21 	mov	r9,1057
8000423a:	ea 19 3f 20 	orh	r9,0x3f20
8000423e:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004240:	e0 69 02 9f 	mov	r9,671
80004244:	ea 19 01 00 	orh	r9,0x100
80004248:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000424a:	e0 6a 04 02 	mov	r10,1026
8000424e:	ea 1a 3f 20 	orh	r10,0x3f20
80004252:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004254:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004256:	5e fc       	retal	r12

80004258 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004258:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000425a:	30 19       	mov	r9,1
8000425c:	49 78       	lddpc	r8,800042b8 <local_start_PDC+0x60>
8000425e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004260:	fe 78 00 00 	mov	r8,-65536
80004264:	30 7b       	mov	r11,7
80004266:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004268:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000426a:	49 59       	lddpc	r9,800042bc <local_start_PDC+0x64>
8000426c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004270:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004272:	30 3a       	mov	r10,3
80004274:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004276:	30 1c       	mov	r12,1
80004278:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000427a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000427c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000427e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004280:	30 2c       	mov	r12,2
80004282:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004284:	48 f9       	lddpc	r9,800042c0 <local_start_PDC+0x68>
80004286:	e0 68 5a 5a 	mov	r8,23130
8000428a:	ea 18 ab cd 	orh	r8,0xabcd
8000428e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004290:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004292:	30 0e       	mov	lr,0
80004294:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004296:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004298:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000429a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000429c:	fe 78 00 40 	mov	r8,-65472
800042a0:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800042a2:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800042a4:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800042a8:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800042aa:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800042ac:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800042ae:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800042b0:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800042b2:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800042b4:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800042b6:	d8 02       	popm	pc
800042b8:	00 00       	add	r0,r0
800042ba:	40 b8       	lddsp	r8,sp[0x2c]
800042bc:	00 00       	add	r0,r0
800042be:	40 c0       	lddsp	r0,sp[0x30]
800042c0:	00 00       	add	r0,r0
800042c2:	40 e0       	lddsp	r0,sp[0x38]

800042c4 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800042c4:	48 38       	lddpc	r8,800042d0 <register_rx_tx_func+0xc>
800042c6:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800042c8:	48 38       	lddpc	r8,800042d4 <register_rx_tx_func+0x10>
800042ca:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800042cc:	5e fc       	retal	r12
800042ce:	00 00       	add	r0,r0
800042d0:	00 00       	add	r0,r0
800042d2:	0a ec       	st.h	--r5,r12
800042d4:	00 00       	add	r0,r0
800042d6:	0a f0       	st.b	--r5,r0

800042d8 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800042d8:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800042da:	fe 78 10 00 	mov	r8,-61440
800042de:	30 29       	mov	r9,2
800042e0:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800042e4:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800042e8:	10 99       	mov	r9,r8
800042ea:	f2 f8 01 60 	ld.w	r8,r9[352]
800042ee:	e2 18 00 02 	andl	r8,0x2,COH
800042f2:	cf c0       	breq	800042ea <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800042f4:	fe 79 10 00 	mov	r9,-61440
800042f8:	f2 f8 01 60 	ld.w	r8,r9[352]
800042fc:	e2 18 00 02 	andl	r8,0x2,COH
80004300:	cf c1       	brne	800042f8 <ssc_init+0x20>
				
    INTC_register_interrupt (
80004302:	30 3a       	mov	r10,3
80004304:	36 0b       	mov	r11,96
80004306:	48 bc       	lddpc	r12,80004330 <ssc_init+0x58>
80004308:	f0 1f 00 0b 	mcall	80004334 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
8000430c:	f0 1f 00 0b 	mcall	80004338 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004310:	f0 1f 00 0b 	mcall	8000433c <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004314:	fe 79 00 00 	mov	r9,-65536
80004318:	30 18       	mov	r8,1
8000431a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000431c:	fe 7a 00 40 	mov	r10,-65472
80004320:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004322:	e0 6b 01 01 	mov	r11,257
80004326:	fe 7a 34 00 	mov	r10,-52224
8000432a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
8000432c:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
8000432e:	d8 02       	popm	pc
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	41 a0       	lddsp	r0,sp[0x68]
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	4d 14       	lddpc	r4,80004478 <xcmp_exec_func+0x18>
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	42 14       	lddsp	r4,sp[0x84]
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	42 58       	lddsp	r8,sp[0x94]

80004340 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004340:	48 28       	lddpc	r8,80004348 <xcmp_register_app_list+0x8>
80004342:	91 0c       	st.w	r8[0x0],r12
}
80004344:	5e fc       	retal	r12
80004346:	00 00       	add	r0,r0
80004348:	00 00       	add	r0,r0
8000434a:	41 00       	lddsp	r0,sp[0x40]

8000434c <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
8000434c:	eb cd 40 80 	pushm	r7,lr
80004350:	fa cd 01 00 	sub	sp,sp,256
80004354:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004356:	16 98       	mov	r8,r11
80004358:	2f 08       	sub	r8,-16
8000435a:	af a8       	sbr	r8,0xe
8000435c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000435e:	3f f8       	mov	r8,-1
80004360:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004362:	30 b9       	mov	r9,11
80004364:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004366:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004368:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000436a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000436c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000436e:	f6 ca ff fe 	sub	r10,r11,-2
80004372:	18 9b       	mov	r11,r12
80004374:	fa cc ff f0 	sub	r12,sp,-16
80004378:	f0 1f 00 05 	mcall	8000438c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
8000437c:	2f e7       	sub	r7,-2
8000437e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004380:	1a 9c       	mov	r12,sp
80004382:	f0 1f 00 04 	mcall	80004390 <xcmp_tx+0x44>
}
80004386:	2c 0d       	sub	sp,-256
80004388:	e3 cd 80 80 	ldm	sp++,r7,pc
8000438c:	80 00       	ld.sh	r0,r0[0x0]
8000438e:	70 0c       	ld.w	r12,r8[0x0]
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	48 04       	lddpc	r4,80004390 <xcmp_tx+0x44>

80004394 <xcmp_data_session>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
{
80004394:	d4 01       	pushm	lr
80004396:	fa cd 00 cc 	sub	sp,sp,204
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_DATA_REQUEST;
8000439a:	e0 68 04 1d 	mov	r8,1053
8000439e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
800043a0:	fa c8 ff fc 	sub	r8,sp,-4
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//ID:2
	//
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
	
	ptr->Function = Single_Data_Uint;//0x01
800043a4:	30 19       	mov	r9,1
800043a6:	b0 89       	st.b	r8[0x0],r9
	
	ptr->DataDefinition.Data_Protocol_Version = DMR_CSBK_Data;//0x70
800043a8:	37 0a       	mov	r10,112
800043aa:	b0 9a       	st.b	r8[0x1],r10
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_Mototrbo_Address;//0x01
800043ac:	b0 a9       	st.b	r8[0x2],r9
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_Mototrbo_Address_Size;//0x03
800043ae:	30 39       	mov	r9,3
800043b0:	b0 b9       	st.b	r8[0x3],r9
	
	ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x00;
800043b2:	30 09       	mov	r9,0
800043b4:	b0 c9       	st.b	r8[0x4],r9
	ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;
800043b6:	b0 d9       	st.b	r8[0x5],r9
	ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x02;//ID:2
800043b8:	30 2a       	mov	r10,2
800043ba:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
800043bc:	34 0a       	mov	r10,64
800043be:	b0 fa       	st.b	r8[0x7],r10
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
800043c0:	36 1a       	mov	r10,97
800043c2:	f1 6a 00 08 	st.b	r8[8],r10
	    ////
    ////}
	//
	
	//
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800043c6:	f1 69 00 09 	st.b	r8[9],r9
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//可能会变化
800043ca:	f1 69 00 0a 	st.b	r8[10],r9
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
800043ce:	31 49       	mov	r9,20
800043d0:	f1 69 00 0b 	st.b	r8[11],r9
800043d4:	48 88       	lddpc	r8,800043f4 <xcmp_data_session+0x60>
800043d6:	fa c9 ff f0 	sub	r9,sp,-16
Parameters:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
800043da:	f0 cb ff ec 	sub	r11,r8,-20
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
	
	for (i=0; i< sizeof(DataPayload) ; i++)
	{
	
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//长度计算了吗？
800043de:	11 3a       	ld.ub	r10,r8++
800043e0:	12 ca       	st.b	r9++,r10
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//可能会变化
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
	
	for (i=0; i< sizeof(DataPayload) ; i++)
800043e2:	16 38       	cp.w	r8,r11
800043e4:	cf d1       	brne	800043de <xcmp_data_session+0x4a>
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//长度计算了吗？
		
	}
	
	/*send xcmp frame*///注意！！！！！！！！！！
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t));
800043e6:	32 0b       	mov	r11,32
800043e8:	fa cc ff fe 	sub	r12,sp,-2
800043ec:	f0 1f 00 03 	mcall	800043f8 <xcmp_data_session+0x64>
}
800043f0:	2c dd       	sub	sp,-204
800043f2:	d8 02       	popm	pc
800043f4:	00 00       	add	r0,r0
800043f6:	04 f4       	st.b	--r2,r4
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	43 4c       	lddsp	r12,sp[0xd0]

800043fc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800043fc:	d4 01       	pushm	lr
800043fe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004402:	fe 78 b4 00 	mov	r8,-19456
80004406:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004408:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000440c:	30 89       	mov	r9,8
8000440e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004410:	30 19       	mov	r9,1
80004412:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004414:	30 09       	mov	r9,0
80004416:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004418:	30 5a       	mov	r10,5
8000441a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000441c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000441e:	30 7a       	mov	r10,7
80004420:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004422:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004424:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004426:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000442a:	30 9b       	mov	r11,9
8000442c:	fa cc ff fe 	sub	r12,sp,-2
80004430:	f0 1f 00 02 	mcall	80004438 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004434:	2c dd       	sub	sp,-204
80004436:	d8 02       	popm	pc
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	43 4c       	lddsp	r12,sp[0xd0]

8000443c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000443c:	d4 01       	pushm	lr
8000443e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004442:	fe 78 80 00 	mov	r8,-32768
80004446:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004448:	30 38       	mov	r8,3
8000444a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000444c:	30 1b       	mov	r11,1
8000444e:	fa cc ff fe 	sub	r12,sp,-2
80004452:	f0 1f 00 03 	mcall	8000445c <xcmp_opcode_not_supported+0x20>
}
80004456:	2c dd       	sub	sp,-204
80004458:	d8 02       	popm	pc
8000445a:	00 00       	add	r0,r0
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	43 4c       	lddsp	r12,sp[0xd0]

80004460 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004460:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004462:	96 88       	ld.uh	r8,r11[0x0]
80004464:	e2 18 f0 00 	andl	r8,0xf000,COH
80004468:	e0 48 80 00 	cp.w	r8,32768
8000446c:	c0 f0       	breq	8000448a <xcmp_exec_func+0x2a>
8000446e:	e0 48 b0 00 	cp.w	r8,45056
80004472:	c1 20       	breq	80004496 <xcmp_exec_func+0x36>
80004474:	58 08       	cp.w	r8,0
80004476:	c1 51       	brne	800044a0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004478:	78 08       	ld.w	r8,r12[0x0]
8000447a:	58 08       	cp.w	r8,0
8000447c:	c0 40       	breq	80004484 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000447e:	16 9c       	mov	r12,r11
80004480:	5d 18       	icall	r8
80004482:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
80004484:	f0 1f 00 08 	mcall	800044a4 <xcmp_exec_func+0x44>
80004488:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000448a:	78 18       	ld.w	r8,r12[0x4]
8000448c:	58 08       	cp.w	r8,0
8000448e:	c0 90       	breq	800044a0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004490:	16 9c       	mov	r12,r11
80004492:	5d 18       	icall	r8
80004494:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004496:	78 28       	ld.w	r8,r12[0x8]
80004498:	58 08       	cp.w	r8,0
8000449a:	c0 30       	breq	800044a0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000449c:	16 9c       	mov	r12,r11
8000449e:	5d 18       	icall	r8
800044a0:	d8 02       	popm	pc
800044a2:	00 00       	add	r0,r0
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	44 3c       	lddsp	r12,sp[0x10c]

800044a8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
800044a8:	d4 01       	pushm	lr
800044aa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800044ae:	e0 68 04 09 	mov	r8,1033
800044b2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800044b4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800044b8:	30 19       	mov	r9,1
800044ba:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800044bc:	30 09       	mov	r9,0
800044be:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800044c0:	30 ca       	mov	r10,12
800044c2:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800044c4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800044c6:	fb 69 00 08 	st.b	sp[8],r9
800044ca:	fa c8 ff f7 	sub	r8,sp,-9
800044ce:	b0 89       	st.b	r8[0x0],r9
800044d0:	fa c8 ff f6 	sub	r8,sp,-10
800044d4:	b0 89       	st.b	r8[0x0],r9
800044d6:	fa c8 ff f5 	sub	r8,sp,-11
800044da:	b0 89       	st.b	r8[0x0],r9
800044dc:	fa c8 ff f4 	sub	r8,sp,-12
800044e0:	b0 89       	st.b	r8[0x0],r9
800044e2:	fa c8 ff f3 	sub	r8,sp,-13
800044e6:	b0 89       	st.b	r8[0x0],r9
800044e8:	fa c8 ff f2 	sub	r8,sp,-14
800044ec:	b0 89       	st.b	r8[0x0],r9
800044ee:	fa c8 ff f1 	sub	r8,sp,-15
800044f2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800044f4:	30 cb       	mov	r11,12
800044f6:	fa cc ff fe 	sub	r12,sp,-2
800044fa:	f0 1f 00 03 	mcall	80004504 <xcmp_IdleTestTone+0x5c>
}
800044fe:	2c dd       	sub	sp,-204
80004500:	d8 02       	popm	pc
80004502:	00 00       	add	r0,r0
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	43 4c       	lddsp	r12,sp[0xd0]

80004508 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004508:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
8000450a:	f0 1f 00 0d 	mcall	8000453c <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000450e:	48 dc       	lddpc	r12,80004540 <xcmp_init+0x38>
80004510:	f0 1f 00 0d 	mcall	80004544 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004514:	30 4b       	mov	r11,4
80004516:	31 4c       	mov	r12,20
80004518:	f0 1f 00 0c 	mcall	80004548 <xcmp_init+0x40>
8000451c:	48 c8       	lddpc	r8,8000454c <xcmp_init+0x44>
8000451e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004520:	30 09       	mov	r9,0
80004522:	1a d9       	st.w	--sp,r9
80004524:	1a d9       	st.w	--sp,r9
80004526:	1a d9       	st.w	--sp,r9
80004528:	30 38       	mov	r8,3
8000452a:	e0 6a 01 80 	mov	r10,384
8000452e:	48 9b       	lddpc	r11,80004550 <xcmp_init+0x48>
80004530:	48 9c       	lddpc	r12,80004554 <xcmp_init+0x4c>
80004532:	f0 1f 00 0a 	mcall	80004558 <xcmp_init+0x50>
80004536:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004538:	d8 02       	popm	pc
8000453a:	00 00       	add	r0,r0
8000453c:	80 00       	ld.sh	r0,r0[0x0]
8000453e:	48 e8       	lddpc	r8,80004574 <xcmp_rx_process+0x18>
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	46 58       	lddsp	r8,sp[0x194]
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	46 a4       	lddsp	r4,sp[0x1a8]
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	5b e0       	cp.w	r0,-2
8000454c:	00 00       	add	r0,r0
8000454e:	0b 00       	ld.w	r0,r5++
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	d0 a0       	acall	0xa
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	45 5c       	lddsp	r12,sp[0x154]
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	62 b4       	ld.w	r4,r1[0x2c]

8000455c <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000455c:	d4 31       	pushm	r0-r7,lr
8000455e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004560:	4b 16       	lddpc	r6,80004624 <xcmp_rx_process+0xc8>
80004562:	30 05       	mov	r5,0
80004564:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004566:	4b 13       	lddpc	r3,80004628 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004568:	4b 12       	lddpc	r2,8000462c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000456a:	4b 21       	lddpc	r1,80004630 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000456c:	4b 20       	lddpc	r0,80004634 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000456e:	6c 0c       	ld.w	r12,r6[0x0]
80004570:	0a 99       	mov	r9,r5
80004572:	08 9a       	mov	r10,r4
80004574:	1a 9b       	mov	r11,sp
80004576:	f0 1f 00 31 	mcall	80004638 <xcmp_rx_process+0xdc>
8000457a:	58 1c       	cp.w	r12,1
8000457c:	cf 91       	brne	8000456e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000457e:	40 0b       	lddsp	r11,sp[0x0]
80004580:	58 0b       	cp.w	r11,0
80004582:	cf 60       	breq	8000456e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004584:	96 0a       	ld.sh	r10,r11[0x0]
80004586:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000458a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000458e:	59 c8       	cp.w	r8,28
80004590:	c1 e0       	breq	800045cc <xcmp_rx_process+0x70>
80004592:	e0 89 00 07 	brgt	800045a0 <xcmp_rx_process+0x44>
80004596:	58 e8       	cp.w	r8,14
80004598:	c0 e0       	breq	800045b4 <xcmp_rx_process+0x58>
8000459a:	58 f8       	cp.w	r8,15
8000459c:	c2 41       	brne	800045e4 <xcmp_rx_process+0x88>
8000459e:	c0 f8       	rjmp	800045bc <xcmp_rx_process+0x60>
800045a0:	e0 48 01 09 	cp.w	r8,265
800045a4:	c1 80       	breq	800045d4 <xcmp_rx_process+0x78>
800045a6:	e0 48 01 0a 	cp.w	r8,266
800045aa:	c1 90       	breq	800045dc <xcmp_rx_process+0x80>
800045ac:	e0 48 00 2c 	cp.w	r8,44
800045b0:	c1 a1       	brne	800045e4 <xcmp_rx_process+0x88>
800045b2:	c0 98       	rjmp	800045c4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800045b4:	4a 2c       	lddpc	r12,8000463c <xcmp_rx_process+0xe0>
800045b6:	f0 1f 00 23 	mcall	80004640 <xcmp_rx_process+0xe4>
					break;
800045ba:	c2 f8       	rjmp	80004618 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800045bc:	4a 2c       	lddpc	r12,80004644 <xcmp_rx_process+0xe8>
800045be:	f0 1f 00 21 	mcall	80004640 <xcmp_rx_process+0xe4>
					break;
800045c2:	c2 b8       	rjmp	80004618 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800045c4:	4a 1c       	lddpc	r12,80004648 <xcmp_rx_process+0xec>
800045c6:	f0 1f 00 1f 	mcall	80004640 <xcmp_rx_process+0xe4>
					break;
800045ca:	c2 78       	rjmp	80004618 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800045cc:	04 9c       	mov	r12,r2
800045ce:	f0 1f 00 1d 	mcall	80004640 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800045d2:	c2 38       	rjmp	80004618 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800045d4:	02 9c       	mov	r12,r1
800045d6:	f0 1f 00 1b 	mcall	80004640 <xcmp_rx_process+0xe4>
					break;
800045da:	c1 f8       	rjmp	80004618 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800045dc:	00 9c       	mov	r12,r0
800045de:	f0 1f 00 19 	mcall	80004640 <xcmp_rx_process+0xe4>
					break;
800045e2:	c1 b8       	rjmp	80004618 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800045e4:	12 98       	mov	r8,r9
800045e6:	e2 18 04 00 	andl	r8,0x400,COH
800045ea:	c0 70       	breq	800045f8 <xcmp_rx_process+0x9c>
800045ec:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800045f0:	e0 48 00 68 	cp.w	r8,104
800045f4:	e0 8a 00 08 	brle	80004604 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800045f8:	e2 19 f0 00 	andl	r9,0xf000,COH
800045fc:	c0 e1       	brne	80004618 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800045fe:	f0 1f 00 14 	mcall	8000464c <xcmp_rx_process+0xf0>
80004602:	c0 b8       	rjmp	80004618 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004604:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004608:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000460c:	49 19       	lddpc	r9,80004650 <xcmp_rx_process+0xf4>
8000460e:	72 08       	ld.w	r8,r9[0x0]
80004610:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004614:	f0 1f 00 0b 	mcall	80004640 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004618:	66 0c       	ld.w	r12,r3[0x0]
8000461a:	40 0b       	lddsp	r11,sp[0x0]
8000461c:	f0 1f 00 0e 	mcall	80004654 <xcmp_rx_process+0xf8>
80004620:	ca 7b       	rjmp	8000456e <xcmp_rx_process+0x12>
80004622:	00 00       	add	r0,r0
80004624:	00 00       	add	r0,r0
80004626:	0b 00       	ld.w	r0,r5++
80004628:	00 00       	add	r0,r0
8000462a:	0a a8       	st.w	r5++,r8
8000462c:	00 00       	add	r0,r0
8000462e:	0b 10       	ld.sh	r0,r5++
80004630:	00 00       	add	r0,r0
80004632:	0b 04       	ld.w	r4,r5++
80004634:	00 00       	add	r0,r0
80004636:	0b 1c       	ld.sh	r12,r5++
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	58 d4       	cp.w	r4,13
8000463c:	00 00       	add	r0,r0
8000463e:	0b 34       	ld.ub	r4,r5++
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	44 60       	lddsp	r0,sp[0x118]
80004644:	00 00       	add	r0,r0
80004646:	0a f4       	st.b	--r5,r4
80004648:	00 00       	add	r0,r0
8000464a:	0b 28       	ld.uh	r8,r5++
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	44 3c       	lddsp	r12,sp[0x10c]
80004650:	00 00       	add	r0,r0
80004652:	41 00       	lddsp	r0,sp[0x40]
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	2e 98       	sub	r8,-23

80004658 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004658:	eb cd 40 90 	pushm	r4,r7,lr
8000465c:	20 1d       	sub	sp,4
8000465e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004662:	48 c8       	lddpc	r8,80004690 <xcmp_rx+0x38>
80004664:	70 0c       	ld.w	r12,r8[0x0]
80004666:	f0 1f 00 0c 	mcall	80004694 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000466a:	c1 00       	breq	8000468a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000466c:	fa c7 ff fc 	sub	r7,sp,-4
80004670:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004672:	e0 6a 00 ca 	mov	r10,202
80004676:	08 9b       	mov	r11,r4
80004678:	f0 1f 00 08 	mcall	80004698 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000467c:	48 88       	lddpc	r8,8000469c <xcmp_rx+0x44>
8000467e:	70 0c       	ld.w	r12,r8[0x0]
80004680:	30 09       	mov	r9,0
80004682:	12 9a       	mov	r10,r9
80004684:	1a 9b       	mov	r11,sp
80004686:	f0 1f 00 07 	mcall	800046a0 <xcmp_rx+0x48>
	}	
}
8000468a:	2f fd       	sub	sp,-4
8000468c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004690:	00 00       	add	r0,r0
80004692:	0a a8       	st.w	r5++,r8
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	34 04       	mov	r4,64
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	70 0c       	ld.w	r12,r8[0x0]
8000469c:	00 00       	add	r0,r0
8000469e:	0b 00       	ld.w	r0,r5++
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	5a e0       	cp.w	r0,-18

800046a4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800046a4:	48 28       	lddpc	r8,800046ac <xnl_register_xcmp_func+0x8>
800046a6:	91 0c       	st.w	r8[0x0],r12
}
800046a8:	5e fc       	retal	r12
800046aa:	00 00       	add	r0,r0
800046ac:	00 00       	add	r0,r0
800046ae:	0b 60       	ld.uh	r0,--r5

800046b0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800046b0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800046b2:	48 88       	lddpc	r8,800046d0 <xnl_get_msg_ack_func+0x20>
800046b4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800046b6:	98 49       	ld.sh	r9,r12[0x8]
800046b8:	f0 09 19 00 	cp.h	r9,r8
800046bc:	c0 81       	brne	800046cc <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800046be:	48 68       	lddpc	r8,800046d4 <xnl_get_msg_ack_func+0x24>
800046c0:	70 0c       	ld.w	r12,r8[0x0]
800046c2:	30 09       	mov	r9,0
800046c4:	12 9a       	mov	r10,r9
800046c6:	12 9b       	mov	r11,r9
800046c8:	f0 1f 00 04 	mcall	800046d8 <xnl_get_msg_ack_func+0x28>
800046cc:	d8 02       	popm	pc
800046ce:	00 00       	add	r0,r0
800046d0:	00 00       	add	r0,r0
800046d2:	0b 46       	ld.w	r6,--r5
800046d4:	00 00       	add	r0,r0
800046d6:	0b 40       	ld.w	r0,--r5
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	5a e0       	cp.w	r0,-18

800046dc <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800046dc:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800046de:	4a 86       	lddpc	r6,8000477c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800046e0:	4a 82       	lddpc	r2,80004780 <xnl_tx_process+0xa4>
800046e2:	4a 94       	lddpc	r4,80004784 <xnl_tx_process+0xa8>
800046e4:	30 07       	mov	r7,0
800046e6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800046e8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800046ea:	4a 85       	lddpc	r5,80004788 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800046ec:	4a 83       	lddpc	r3,8000478c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800046ee:	6c 08       	ld.w	r8,r6[0x0]
800046f0:	58 08       	cp.w	r8,0
800046f2:	c0 40       	breq	800046fa <xnl_tx_process+0x1e>
800046f4:	58 18       	cp.w	r8,1
800046f6:	cf d1       	brne	800046f0 <xnl_tx_process+0x14>
800046f8:	c2 08       	rjmp	80004738 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800046fa:	64 0c       	ld.w	r12,r2[0x0]
800046fc:	0e 99       	mov	r9,r7
800046fe:	02 9a       	mov	r10,r1
80004700:	08 9b       	mov	r11,r4
80004702:	f0 1f 00 24 	mcall	80004790 <xnl_tx_process+0xb4>
80004706:	58 1c       	cp.w	r12,1
80004708:	cf 31       	brne	800046ee <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000470a:	68 0c       	ld.w	r12,r4[0x0]
8000470c:	58 0c       	cp.w	r12,0
8000470e:	cf 00       	breq	800046ee <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004710:	98 28       	ld.sh	r8,r12[0x4]
80004712:	e0 08 19 00 	cp.h	r8,r0
80004716:	c0 41       	brne	8000471e <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004718:	f0 1f 00 1f 	mcall	80004794 <xnl_tx_process+0xb8>
						break;
8000471c:	ce 9b       	rjmp	800046ee <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000471e:	f0 1f 00 1f 	mcall	80004798 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004722:	30 18       	mov	r8,1
80004724:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004726:	66 0c       	ld.w	r12,r3[0x0]
80004728:	0e 99       	mov	r9,r7
8000472a:	0e 9a       	mov	r10,r7
8000472c:	0e 9b       	mov	r11,r7
8000472e:	f0 1f 00 19 	mcall	80004790 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
80004732:	30 18       	mov	r8,1
80004734:	8d 08       	st.w	r6[0x0],r8
80004736:	cd cb       	rjmp	800046ee <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004738:	66 0c       	ld.w	r12,r3[0x0]
8000473a:	0e 99       	mov	r9,r7
8000473c:	36 4a       	mov	r10,100
8000473e:	0e 9b       	mov	r11,r7
80004740:	f0 1f 00 14 	mcall	80004790 <xnl_tx_process+0xb4>
80004744:	58 1c       	cp.w	r12,1
80004746:	c0 81       	brne	80004756 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004748:	49 58       	lddpc	r8,8000479c <xnl_tx_process+0xc0>
8000474a:	70 0c       	ld.w	r12,r8[0x0]
8000474c:	68 0b       	ld.w	r11,r4[0x0]
8000474e:	f0 1f 00 15 	mcall	800047a0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004752:	8d 07       	st.w	r6[0x0],r7
80004754:	cc db       	rjmp	800046ee <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004756:	6a 08       	ld.w	r8,r5[0x0]
80004758:	58 38       	cp.w	r8,3
8000475a:	e0 89 00 09 	brgt	8000476c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000475e:	68 0c       	ld.w	r12,r4[0x0]
80004760:	f0 1f 00 0e 	mcall	80004798 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004764:	6a 08       	ld.w	r8,r5[0x0]
80004766:	2f f8       	sub	r8,-1
80004768:	8b 08       	st.w	r5[0x0],r8
8000476a:	cc 2b       	rjmp	800046ee <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000476c:	48 c8       	lddpc	r8,8000479c <xnl_tx_process+0xc0>
8000476e:	70 0c       	ld.w	r12,r8[0x0]
80004770:	68 0b       	ld.w	r11,r4[0x0]
80004772:	f0 1f 00 0c 	mcall	800047a0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004776:	8d 07       	st.w	r6[0x0],r7
80004778:	cb bb       	rjmp	800046ee <xnl_tx_process+0x12>
8000477a:	00 00       	add	r0,r0
8000477c:	00 00       	add	r0,r0
8000477e:	0b 5c       	ld.sh	r12,--r5
80004780:	00 00       	add	r0,r0
80004782:	0b 50       	ld.sh	r0,--r5
80004784:	00 00       	add	r0,r0
80004786:	0b 54       	ld.sh	r4,--r5
80004788:	00 00       	add	r0,r0
8000478a:	0b 58       	ld.sh	r8,--r5
8000478c:	00 00       	add	r0,r0
8000478e:	0b 40       	ld.w	r0,--r5
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	58 d4       	cp.w	r4,13
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	57 64       	stdsp	sp[0x1d8],r4
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	2e b8       	sub	r8,-21
8000479c:	00 00       	add	r0,r0
8000479e:	0a a8       	st.w	r5++,r8
800047a0:	80 00       	ld.sh	r0,r0[0x0]
800047a2:	2e 98       	sub	r8,-23

800047a4 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800047a4:	eb cd 40 fe 	pushm	r1-r7,lr
800047a8:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800047aa:	49 26       	lddpc	r6,800047f0 <xnl_rx_process+0x4c>
800047ac:	30 05       	mov	r5,0
800047ae:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800047b0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800047b2:	49 11       	lddpc	r1,800047f4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800047b4:	49 12       	lddpc	r2,800047f8 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800047b6:	6c 0c       	ld.w	r12,r6[0x0]
800047b8:	0a 99       	mov	r9,r5
800047ba:	08 9a       	mov	r10,r4
800047bc:	1a 9b       	mov	r11,sp
800047be:	f0 1f 00 10 	mcall	800047fc <xnl_rx_process+0x58>
800047c2:	58 1c       	cp.w	r12,1
800047c4:	cf 91       	brne	800047b6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800047c6:	40 0c       	lddsp	r12,sp[0x0]
800047c8:	58 0c       	cp.w	r12,0
800047ca:	cf 60       	breq	800047b6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800047cc:	98 28       	ld.sh	r8,r12[0x4]
800047ce:	e6 08 19 00 	cp.h	r8,r3
800047d2:	e0 8b 00 0a 	brhi	800047e6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800047d6:	5c 78       	castu.h	r8
800047d8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800047dc:	58 09       	cp.w	r9,0
800047de:	c0 40       	breq	800047e6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800047e0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800047e4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800047e6:	62 0c       	ld.w	r12,r1[0x0]
800047e8:	40 0b       	lddsp	r11,sp[0x0]
800047ea:	f0 1f 00 06 	mcall	80004800 <xnl_rx_process+0x5c>
800047ee:	ce 4b       	rjmp	800047b6 <xnl_rx_process+0x12>
800047f0:	00 00       	add	r0,r0
800047f2:	0a d0       	st.w	--r5,r0
800047f4:	00 00       	add	r0,r0
800047f6:	0a a8       	st.w	r5++,r8
800047f8:	00 00       	add	r0,r0
800047fa:	05 08       	ld.w	r8,r2++
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	58 d4       	cp.w	r4,13
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	2e 98       	sub	r8,-23

80004804 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004804:	eb cd 40 c0 	pushm	r6-r7,lr
80004808:	20 1d       	sub	sp,4
8000480a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000480c:	98 39       	ld.sh	r9,r12[0x6]
8000480e:	3f f8       	mov	r8,-1
80004810:	f0 09 19 00 	cp.h	r9,r8
80004814:	c0 a1       	brne	80004828 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004816:	4a e9       	lddpc	r9,800048cc <xnl_tx+0xc8>
80004818:	13 88       	ld.ub	r8,r9[0x0]
8000481a:	2f f8       	sub	r8,-1
8000481c:	5c 58       	castu.b	r8
8000481e:	b2 88       	st.b	r9[0x0],r8
80004820:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004824:	a9 a8       	sbr	r8,0x8
80004826:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004828:	8c 49       	ld.sh	r9,r6[0x8]
8000482a:	3f f8       	mov	r8,-1
8000482c:	f0 09 19 00 	cp.h	r9,r8
80004830:	c0 41       	brne	80004838 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004832:	4a 88       	lddpc	r8,800048d0 <xnl_tx+0xcc>
80004834:	90 18       	ld.sh	r8,r8[0x2]
80004836:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004838:	8c 59       	ld.sh	r9,r6[0xa]
8000483a:	3f f8       	mov	r8,-1
8000483c:	f0 09 19 00 	cp.h	r9,r8
80004840:	c0 41       	brne	80004848 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004842:	4a 48       	lddpc	r8,800048d0 <xnl_tx+0xcc>
80004844:	90 28       	ld.sh	r8,r8[0x4]
80004846:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004848:	8c 69       	ld.sh	r9,r6[0xc]
8000484a:	3f f8       	mov	r8,-1
8000484c:	f0 09 19 00 	cp.h	r9,r8
80004850:	c0 e1       	brne	8000486c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004852:	4a 08       	lddpc	r8,800048d0 <xnl_tx+0xcc>
80004854:	90 49       	ld.sh	r9,r8[0x8]
80004856:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004858:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000485a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000485c:	90 49       	ld.sh	r9,r8[0x8]
8000485e:	e0 19 ff 00 	andl	r9,0xff00
80004862:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004866:	f3 e8 10 08 	or	r8,r9,r8
8000486a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000486c:	0d 98       	ld.ub	r8,r6[0x1]
8000486e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004870:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004874:	10 0c       	add	r12,r8
80004876:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004878:	58 0c       	cp.w	r12,0
8000487a:	e0 89 00 04 	brgt	80004882 <xnl_tx+0x7e>
8000487e:	30 09       	mov	r9,0
80004880:	c0 d8       	rjmp	8000489a <xnl_tx+0x96>
80004882:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004886:	2f ec       	sub	r12,-2
80004888:	30 09       	mov	r9,0
8000488a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000488c:	15 1b       	ld.sh	r11,r10++
8000488e:	f6 09 00 09 	add	r9,r11,r9
80004892:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004894:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004896:	18 38       	cp.w	r8,r12
80004898:	cf a1       	brne	8000488c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000489a:	5c 39       	neg	r9
8000489c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000489e:	48 e8       	lddpc	r8,800048d4 <xnl_tx+0xd0>
800048a0:	70 0c       	ld.w	r12,r8[0x0]
800048a2:	f0 1f 00 0e 	mcall	800048d8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800048a6:	c1 00       	breq	800048c6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800048a8:	fa c7 ff fc 	sub	r7,sp,-4
800048ac:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800048ae:	e0 6a 01 00 	mov	r10,256
800048b2:	0c 9b       	mov	r11,r6
800048b4:	f0 1f 00 0a 	mcall	800048dc <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800048b8:	48 a8       	lddpc	r8,800048e0 <xnl_tx+0xdc>
800048ba:	70 0c       	ld.w	r12,r8[0x0]
800048bc:	30 09       	mov	r9,0
800048be:	12 9a       	mov	r10,r9
800048c0:	1a 9b       	mov	r11,sp
800048c2:	f0 1f 00 09 	mcall	800048e4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800048c6:	2f fd       	sub	sp,-4
800048c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048cc:	00 00       	add	r0,r0
800048ce:	0b 44       	ld.w	r4,--r5
800048d0:	00 00       	add	r0,r0
800048d2:	0b 46       	ld.w	r6,--r5
800048d4:	00 00       	add	r0,r0
800048d6:	0a a8       	st.w	r5++,r8
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	34 04       	mov	r4,64
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	70 0c       	ld.w	r12,r8[0x0]
800048e0:	00 00       	add	r0,r0
800048e2:	0b 50       	ld.sh	r0,--r5
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	5a e0       	cp.w	r0,-18

800048e8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800048e8:	eb cd 40 80 	pushm	r7,lr
800048ec:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800048f0:	f0 1f 00 27 	mcall	8000498c <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800048f4:	30 09       	mov	r9,0
800048f6:	4a 78       	lddpc	r8,80004990 <xnl_init+0xa8>
800048f8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800048fa:	30 0b       	mov	r11,0
800048fc:	30 1c       	mov	r12,1
800048fe:	f0 1f 00 26 	mcall	80004994 <xnl_init+0xac>
80004902:	4a 68       	lddpc	r8,80004998 <xnl_init+0xb0>
80004904:	91 0c       	st.w	r8[0x0],r12
80004906:	70 08       	ld.w	r8,r8[0x0]
80004908:	58 08       	cp.w	r8,0
8000490a:	c0 80       	breq	8000491a <xnl_init+0x32>
8000490c:	4a 38       	lddpc	r8,80004998 <xnl_init+0xb0>
8000490e:	70 0c       	ld.w	r12,r8[0x0]
80004910:	30 09       	mov	r9,0
80004912:	12 9a       	mov	r10,r9
80004914:	12 9b       	mov	r11,r9
80004916:	f0 1f 00 22 	mcall	8000499c <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000491a:	30 4b       	mov	r11,4
8000491c:	31 4c       	mov	r12,20
8000491e:	f0 1f 00 1e 	mcall	80004994 <xnl_init+0xac>
80004922:	4a 08       	lddpc	r8,800049a0 <xnl_init+0xb8>
80004924:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004926:	30 07       	mov	r7,0
80004928:	1a d7       	st.w	--sp,r7
8000492a:	1a d7       	st.w	--sp,r7
8000492c:	1a d7       	st.w	--sp,r7
8000492e:	30 38       	mov	r8,3
80004930:	0e 99       	mov	r9,r7
80004932:	e0 6a 02 00 	mov	r10,512
80004936:	49 cb       	lddpc	r11,800049a4 <xnl_init+0xbc>
80004938:	49 cc       	lddpc	r12,800049a8 <xnl_init+0xc0>
8000493a:	f0 1f 00 1d 	mcall	800049ac <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000493e:	1a d7       	st.w	--sp,r7
80004940:	1a d7       	st.w	--sp,r7
80004942:	1a d7       	st.w	--sp,r7
80004944:	30 38       	mov	r8,3
80004946:	0e 99       	mov	r9,r7
80004948:	e0 6a 03 20 	mov	r10,800
8000494c:	49 9b       	lddpc	r11,800049b0 <xnl_init+0xc8>
8000494e:	49 ac       	lddpc	r12,800049b4 <xnl_init+0xcc>
80004950:	f0 1f 00 17 	mcall	800049ac <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004954:	e0 68 40 0e 	mov	r8,16398
80004958:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000495c:	3f f8       	mov	r8,-1
8000495e:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004962:	30 38       	mov	r8,3
80004964:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004968:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000496c:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004970:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004974:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004978:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000497c:	fa cc ff e8 	sub	r12,sp,-24
80004980:	f0 1f 00 0e 	mcall	800049b8 <xnl_init+0xd0>
80004984:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004986:	2c 0d       	sub	sp,-256
80004988:	e3 cd 80 80 	ldm	sp++,r7,pc
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	34 2c       	mov	r12,66
80004990:	00 00       	add	r0,r0
80004992:	0b 46       	ld.w	r6,--r5
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	5b e0       	cp.w	r0,-2
80004998:	00 00       	add	r0,r0
8000499a:	0b 40       	ld.w	r0,--r5
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	5a e0       	cp.w	r0,-18
800049a0:	00 00       	add	r0,r0
800049a2:	0b 50       	ld.sh	r0,--r5
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	d0 a8       	*unknown*
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	47 a4       	lddsp	r4,sp[0x1e8]
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	62 b4       	ld.w	r4,r1[0x2c]
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	c8 00       	breq	800048b2 <xnl_tx+0xae>
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	46 dc       	lddsp	r12,sp[0x1b4]
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	48 04       	lddpc	r4,800049b8 <xnl_init+0xd0>

800049bc <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800049bc:	eb cd 40 80 	pushm	r7,lr
800049c0:	fa cd 01 00 	sub	sp,sp,256
800049c4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800049c6:	e0 68 40 0e 	mov	r8,16398
800049ca:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800049cc:	3f f8       	mov	r8,-1
800049ce:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800049d0:	30 c8       	mov	r8,12
800049d2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800049d4:	98 38       	ld.sh	r8,r12[0x6]
800049d6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800049d8:	98 58       	ld.sh	r8,r12[0xa]
800049da:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800049dc:	98 48       	ld.sh	r8,r12[0x8]
800049de:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800049e0:	98 68       	ld.sh	r8,r12[0xc]
800049e2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800049e4:	30 08       	mov	r8,0
800049e6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800049e8:	1a 9c       	mov	r12,sp
800049ea:	f0 1f 00 0a 	mcall	80004a10 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800049ee:	fa cd 00 cc 	sub	sp,sp,204
800049f2:	e0 6a 00 ca 	mov	r10,202
800049f6:	ee cb ff f0 	sub	r11,r7,-16
800049fa:	1a 9c       	mov	r12,sp
800049fc:	f0 1f 00 06 	mcall	80004a14 <xnl_data_msg_func+0x58>
80004a00:	48 68       	lddpc	r8,80004a18 <xnl_data_msg_func+0x5c>
80004a02:	70 08       	ld.w	r8,r8[0x0]
80004a04:	5d 18       	icall	r8
80004a06:	fa cd ff 34 	sub	sp,sp,-204
}
80004a0a:	2c 0d       	sub	sp,-256
80004a0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	48 04       	lddpc	r4,80004a10 <xnl_data_msg_func+0x54>
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	70 0c       	ld.w	r12,r8[0x0]
80004a18:	00 00       	add	r0,r0
80004a1a:	0b 60       	ld.uh	r0,--r5

80004a1c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004a1c:	d4 21       	pushm	r4-r7,lr
80004a1e:	fa cd 01 00 	sub	sp,sp,256
80004a22:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004a24:	4c 28       	lddpc	r8,80004b2c <xnl_device_auth_reply_func+0x110>
80004a26:	11 88       	ld.ub	r8,r8[0x0]
80004a28:	58 08       	cp.w	r8,0
80004a2a:	c7 e1       	brne	80004b26 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004a2c:	4c 18       	lddpc	r8,80004b30 <xnl_device_auth_reply_func+0x114>
80004a2e:	70 0c       	ld.w	r12,r8[0x0]
80004a30:	30 09       	mov	r9,0
80004a32:	12 9a       	mov	r10,r9
80004a34:	12 9b       	mov	r11,r9
80004a36:	f0 1f 00 40 	mcall	80004b34 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004a3a:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004a3e:	4b c8       	lddpc	r8,80004b2c <xnl_device_auth_reply_func+0x110>
80004a40:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004a42:	ef 39 00 12 	ld.ub	r9,r7[18]
80004a46:	ef 38 00 13 	ld.ub	r8,r7[19]
80004a4a:	b1 68       	lsl	r8,0x10
80004a4c:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004a50:	ef 38 00 15 	ld.ub	r8,r7[21]
80004a54:	f3 e8 10 08 	or	r8,r9,r8
80004a58:	ef 39 00 14 	ld.ub	r9,r7[20]
80004a5c:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004a60:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004a64:	ef 38 00 17 	ld.ub	r8,r7[23]
80004a68:	b1 68       	lsl	r8,0x10
80004a6a:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004a6e:	ef 38 00 19 	ld.ub	r8,r7[25]
80004a72:	f5 e8 10 08 	or	r8,r10,r8
80004a76:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004a7a:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004a7e:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a80:	e0 64 79 b9 	mov	r4,31161
80004a84:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a88:	e0 65 45 07 	mov	r5,17671
80004a8c:	ea 15 8a bd 	orh	r5,0x8abd
80004a90:	e0 66 f9 3d 	mov	r6,63805
80004a94:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a98:	e0 6e b8 cf 	mov	lr,47311
80004a9c:	ea 1e 36 83 	orh	lr,0x3683
80004aa0:	e0 67 aa 1c 	mov	r7,43548
80004aa4:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004aa8:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004aaa:	f4 08 00 0c 	add	r12,r10,r8
80004aae:	f0 0b 15 04 	lsl	r11,r8,0x4
80004ab2:	0a 0b       	add	r11,r5
80004ab4:	f9 eb 20 0b 	eor	r11,r12,r11
80004ab8:	f0 0c 16 05 	lsr	r12,r8,0x5
80004abc:	0c 0c       	add	r12,r6
80004abe:	18 5b       	eor	r11,r12
80004ac0:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004ac2:	f2 0c 15 04 	lsl	r12,r9,0x4
80004ac6:	1c 0c       	add	r12,lr
80004ac8:	f2 0b 16 05 	lsr	r11,r9,0x5
80004acc:	0e 0b       	add	r11,r7
80004ace:	f9 eb 20 0b 	eor	r11,r12,r11
80004ad2:	f2 0a 00 0c 	add	r12,r9,r10
80004ad6:	18 5b       	eor	r11,r12
80004ad8:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004ada:	e0 6b 37 20 	mov	r11,14112
80004ade:	ea 1b c6 ef 	orh	r11,0xc6ef
80004ae2:	16 3a       	cp.w	r10,r11
80004ae4:	ce 21       	brne	80004aa8 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004ae6:	e0 6a 40 1a 	mov	r10,16410
80004aea:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004aec:	3f fa       	mov	r10,-1
80004aee:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004af0:	30 6b       	mov	r11,6
80004af2:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004af4:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004af6:	48 eb       	lddpc	r11,80004b2c <xnl_device_auth_reply_func+0x110>
80004af8:	96 1c       	ld.sh	r12,r11[0x2]
80004afa:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004afc:	96 2b       	ld.sh	r11,r11[0x4]
80004afe:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004b00:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004b02:	30 ca       	mov	r10,12
80004b04:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004b06:	30 0a       	mov	r10,0
80004b08:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004b0c:	30 7a       	mov	r10,7
80004b0e:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004b12:	30 2a       	mov	r10,2
80004b14:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004b18:	fa ca ff ec 	sub	r10,sp,-20
80004b1c:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004b1e:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b20:	1a 9c       	mov	r12,sp
80004b22:	f0 1f 00 06 	mcall	80004b38 <xnl_device_auth_reply_func+0x11c>
}
80004b26:	2c 0d       	sub	sp,-256
80004b28:	d8 22       	popm	r4-r7,pc
80004b2a:	00 00       	add	r0,r0
80004b2c:	00 00       	add	r0,r0
80004b2e:	0b 46       	ld.w	r6,--r5
80004b30:	00 00       	add	r0,r0
80004b32:	0b 40       	ld.w	r0,--r5
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	5a e0       	cp.w	r0,-18
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	48 04       	lddpc	r4,80004b38 <xnl_device_auth_reply_func+0x11c>

80004b3c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004b3c:	eb cd 40 80 	pushm	r7,lr
80004b40:	fa cd 01 00 	sub	sp,sp,256
80004b44:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004b46:	49 28       	lddpc	r8,80004b8c <xnl_master_status_brdcst_func+0x50>
80004b48:	11 88       	ld.ub	r8,r8[0x0]
80004b4a:	58 08       	cp.w	r8,0
80004b4c:	c1 c1       	brne	80004b84 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004b4e:	49 18       	lddpc	r8,80004b90 <xnl_master_status_brdcst_func+0x54>
80004b50:	70 0c       	ld.w	r12,r8[0x0]
80004b52:	30 09       	mov	r9,0
80004b54:	12 9a       	mov	r10,r9
80004b56:	12 9b       	mov	r11,r9
80004b58:	f0 1f 00 0f 	mcall	80004b94 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004b5c:	8e 58       	ld.sh	r8,r7[0xa]
80004b5e:	48 c9       	lddpc	r9,80004b8c <xnl_master_status_brdcst_func+0x50>
80004b60:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b62:	e0 68 40 0e 	mov	r8,16398
80004b66:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b68:	3f f8       	mov	r8,-1
80004b6a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004b6c:	30 4a       	mov	r10,4
80004b6e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004b70:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004b72:	92 19       	ld.sh	r9,r9[0x2]
80004b74:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004b76:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004b78:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004b7a:	30 08       	mov	r8,0
80004b7c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004b7e:	1a 9c       	mov	r12,sp
80004b80:	f0 1f 00 06 	mcall	80004b98 <xnl_master_status_brdcst_func+0x5c>
}
80004b84:	2c 0d       	sub	sp,-256
80004b86:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b8a:	00 00       	add	r0,r0
80004b8c:	00 00       	add	r0,r0
80004b8e:	0b 46       	ld.w	r6,--r5
80004b90:	00 00       	add	r0,r0
80004b92:	0b 40       	ld.w	r0,--r5
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	5a e0       	cp.w	r0,-18
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	48 04       	lddpc	r4,80004b98 <xnl_master_status_brdcst_func+0x5c>

80004b9c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004b9c:	eb cd 40 80 	pushm	r7,lr
80004ba0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004ba2:	49 38       	lddpc	r8,80004bec <xnl_device_conn_reply_func+0x50>
80004ba4:	70 0c       	ld.w	r12,r8[0x0]
80004ba6:	30 09       	mov	r9,0
80004ba8:	12 9a       	mov	r10,r9
80004baa:	12 9b       	mov	r11,r9
80004bac:	f0 1f 00 11 	mcall	80004bf0 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004bb0:	ef 18 00 10 	ld.uh	r8,r7[16]
80004bb4:	10 99       	mov	r9,r8
80004bb6:	e2 19 ff 00 	andl	r9,0xff00,COH
80004bba:	e0 49 01 00 	cp.w	r9,256
80004bbe:	c0 60       	breq	80004bca <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004bc0:	0e 9c       	mov	r12,r7
80004bc2:	f0 1f 00 0d 	mcall	80004bf4 <xnl_device_conn_reply_func+0x58>
80004bc6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004bca:	a9 68       	lsl	r8,0x8
80004bcc:	48 b9       	lddpc	r9,80004bf8 <xnl_device_conn_reply_func+0x5c>
80004bce:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004bd0:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004bd4:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004bd6:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004bda:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004bdc:	30 18       	mov	r8,1
80004bde:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004be0:	48 7c       	lddpc	r12,80004bfc <xnl_device_conn_reply_func+0x60>
80004be2:	f0 1f 00 08 	mcall	80004c00 <xnl_device_conn_reply_func+0x64>
80004be6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bea:	00 00       	add	r0,r0
80004bec:	00 00       	add	r0,r0
80004bee:	0b 40       	ld.w	r0,--r5
80004bf0:	80 00       	ld.sh	r0,r0[0x0]
80004bf2:	5a e0       	cp.w	r0,-18
80004bf4:	80 00       	ld.sh	r0,r0[0x0]
80004bf6:	4b 3c       	lddpc	r12,80004cc0 <tc_init+0x30>
80004bf8:	00 00       	add	r0,r0
80004bfa:	0b 46       	ld.w	r6,--r5
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	d0 b0       	acall	0xb
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	66 78       	ld.w	r8,r3[0x1c]

80004c04 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004c04:	fe 78 0c 00 	mov	r8,-62464
80004c08:	e0 69 03 07 	mov	r9,775
80004c0c:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004c0e:	30 49       	mov	r9,4
80004c10:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004c12:	71 59       	ld.w	r9,r8[0x54]
80004c14:	e2 19 00 80 	andl	r9,0x80,COH
80004c18:	cf d0       	breq	80004c12 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004c1a:	fe 78 0c 00 	mov	r8,-62464
80004c1e:	30 59       	mov	r9,5
80004c20:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004c22:	e0 69 01 0d 	mov	r9,269
80004c26:	ea 19 10 07 	orh	r9,0x1007
80004c2a:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004c2c:	71 59       	ld.w	r9,r8[0x54]
80004c2e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004c32:	cf d0       	breq	80004c2c <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004c34:	fe 78 0c 00 	mov	r8,-62464
80004c38:	fc 19 00 80 	movh	r9,0x80
80004c3c:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004c3e:	34 0a       	mov	r10,64
80004c40:	fe 69 14 00 	mov	r9,-125952
80004c44:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004c46:	30 69       	mov	r9,6
80004c48:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004c4a:	30 19       	mov	r9,1
80004c4c:	fe 68 10 00 	mov	r8,-126976
80004c50:	91 19       	st.w	r8[0x4],r9
}
80004c52:	5e fc       	retal	r12

80004c54 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004c54:	fe 78 10 00 	mov	r8,-61440
80004c58:	fc 19 00 10 	movh	r9,0x10
80004c5c:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004c5e:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004c60:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004c62:	30 39       	mov	r9,3
80004c64:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004c68:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004c6c:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004c70:	fe 78 38 00 	mov	r8,-51200
80004c74:	30 49       	mov	r9,4
80004c76:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004c7a:	e0 69 91 0d 	mov	r9,37133
80004c7e:	ea 19 00 52 	orh	r9,0x52
80004c82:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004c84:	32 09       	mov	r9,32
80004c86:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004c88:	30 59       	mov	r9,5
80004c8a:	91 09       	st.w	r8[0x0],r9
}
80004c8c:	5e fc       	retal	r12
80004c8e:	d7 03       	nop

80004c90 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004c90:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004c92:	30 2a       	mov	r10,2
80004c94:	e0 6b 01 c1 	mov	r11,449
80004c98:	48 ec       	lddpc	r12,80004cd0 <tc_init+0x40>
80004c9a:	f0 1f 00 0f 	mcall	80004cd4 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004c9e:	48 fb       	lddpc	r11,80004cd8 <tc_init+0x48>
80004ca0:	fe 7c 38 00 	mov	r12,-51200
80004ca4:	f0 1f 00 0e 	mcall	80004cdc <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004ca8:	e0 6a 75 30 	mov	r10,30000
80004cac:	30 1b       	mov	r11,1
80004cae:	fe 7c 38 00 	mov	r12,-51200
80004cb2:	f0 1f 00 0c 	mcall	80004ce0 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004cb6:	48 ca       	lddpc	r10,80004ce4 <tc_init+0x54>
80004cb8:	30 1b       	mov	r11,1
80004cba:	fe 7c 38 00 	mov	r12,-51200
80004cbe:	f0 1f 00 0b 	mcall	80004ce8 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004cc2:	30 1b       	mov	r11,1
80004cc4:	fe 7c 38 00 	mov	r12,-51200
80004cc8:	f0 1f 00 09 	mcall	80004cec <tc_init+0x5c>
80004ccc:	d8 02       	popm	pc
80004cce:	00 00       	add	r0,r0
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	4c f0       	lddpc	r0,80004e0c <_get_interrupt_handler+0x24>
80004cd4:	80 00       	ld.sh	r0,r0[0x0]
80004cd6:	4d 14       	lddpc	r4,80004e18 <_get_interrupt_handler+0x30>
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	d0 c8       	*unknown*
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	4f fa       	lddpc	r10,80004ed8 <spi_unselectChip+0x8>
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	50 ba       	stdsp	sp[0x2c],r10
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	d0 c4       	*unknown*
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	50 ee       	stdsp	sp[0x38],lr
80004cec:	80 00       	ld.sh	r0,r0[0x0]
80004cee:	50 96       	stdsp	sp[0x24],r6

80004cf0 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004cf0:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004cf2:	48 68       	lddpc	r8,80004d08 <_tc_interrupt+0x18>
80004cf4:	70 09       	ld.w	r9,r8[0x0]
80004cf6:	2f f9       	sub	r9,-1
80004cf8:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004cfa:	30 1b       	mov	r11,1
80004cfc:	fe 7c 38 00 	mov	r12,-51200
80004d00:	f0 1f 00 03 	mcall	80004d0c <_tc_interrupt+0x1c>
	
}
80004d04:	d4 02       	popm	lr
80004d06:	d6 03       	rete
80004d08:	00 00       	add	r0,r0
80004d0a:	0b 64       	ld.uh	r4,--r5
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	50 a8       	stdsp	sp[0x28],r8

80004d10 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004d10:	c0 08       	rjmp	80004d10 <_unhandled_interrupt>
80004d12:	d7 03       	nop

80004d14 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004d14:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004d18:	49 99       	lddpc	r9,80004d7c <INTC_register_interrupt+0x68>
80004d1a:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004d1e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004d22:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004d24:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004d28:	58 0a       	cp.w	r10,0
80004d2a:	c0 91       	brne	80004d3c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004d2c:	49 59       	lddpc	r9,80004d80 <INTC_register_interrupt+0x6c>
80004d2e:	49 6a       	lddpc	r10,80004d84 <INTC_register_interrupt+0x70>
80004d30:	12 1a       	sub	r10,r9
80004d32:	fe 79 08 00 	mov	r9,-63488
80004d36:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004d3a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004d3c:	58 1a       	cp.w	r10,1
80004d3e:	c0 a1       	brne	80004d52 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004d40:	49 09       	lddpc	r9,80004d80 <INTC_register_interrupt+0x6c>
80004d42:	49 2a       	lddpc	r10,80004d88 <INTC_register_interrupt+0x74>
80004d44:	12 1a       	sub	r10,r9
80004d46:	bf aa       	sbr	r10,0x1e
80004d48:	fe 79 08 00 	mov	r9,-63488
80004d4c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004d50:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004d52:	58 2a       	cp.w	r10,2
80004d54:	c0 a1       	brne	80004d68 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004d56:	48 b9       	lddpc	r9,80004d80 <INTC_register_interrupt+0x6c>
80004d58:	48 da       	lddpc	r10,80004d8c <INTC_register_interrupt+0x78>
80004d5a:	12 1a       	sub	r10,r9
80004d5c:	bf ba       	sbr	r10,0x1f
80004d5e:	fe 79 08 00 	mov	r9,-63488
80004d62:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004d66:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004d68:	48 69       	lddpc	r9,80004d80 <INTC_register_interrupt+0x6c>
80004d6a:	48 aa       	lddpc	r10,80004d90 <INTC_register_interrupt+0x7c>
80004d6c:	12 1a       	sub	r10,r9
80004d6e:	ea 1a c0 00 	orh	r10,0xc000
80004d72:	fe 79 08 00 	mov	r9,-63488
80004d76:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004d7a:	5e fc       	retal	r12
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	d0 d0       	acall	0xd
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	c6 00       	breq	80004e42 <spi_initMaster+0x22>
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	c7 04       	brge	80004e66 <spi_selectionMode+0xe>
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	c7 12       	brcc	80004e6c <spi_selectionMode+0x14>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	c7 20       	breq	80004e72 <spi_selectionMode+0x1a>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	c7 2e       	rcall	80004a76 <xnl_device_auth_reply_func+0x5a>

80004d94 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004d94:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004d96:	49 18       	lddpc	r8,80004dd8 <INTC_init_interrupts+0x44>
80004d98:	e3 b8 00 01 	mtsr	0x4,r8
80004d9c:	49 0e       	lddpc	lr,80004ddc <INTC_init_interrupts+0x48>
80004d9e:	30 07       	mov	r7,0
80004da0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004da2:	49 0c       	lddpc	r12,80004de0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004da4:	49 05       	lddpc	r5,80004de4 <INTC_init_interrupts+0x50>
80004da6:	10 15       	sub	r5,r8
80004da8:	fe 76 08 00 	mov	r6,-63488
80004dac:	c1 08       	rjmp	80004dcc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004dae:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004db0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004db2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004db4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004db8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004dba:	10 3a       	cp.w	r10,r8
80004dbc:	fe 9b ff fc 	brhi	80004db4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004dc0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004dc4:	2f f7       	sub	r7,-1
80004dc6:	2f 8e       	sub	lr,-8
80004dc8:	59 37       	cp.w	r7,19
80004dca:	c0 50       	breq	80004dd4 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004dcc:	7c 08       	ld.w	r8,lr[0x0]
80004dce:	58 08       	cp.w	r8,0
80004dd0:	ce f1       	brne	80004dae <INTC_init_interrupts+0x1a>
80004dd2:	cf 7b       	rjmp	80004dc0 <INTC_init_interrupts+0x2c>
80004dd4:	d8 22       	popm	r4-r7,pc
80004dd6:	00 00       	add	r0,r0
80004dd8:	80 00       	ld.sh	r0,r0[0x0]
80004dda:	c6 00       	breq	80004e9a <spi_selectChip+0x16>
80004ddc:	80 00       	ld.sh	r0,r0[0x0]
80004dde:	d0 d0       	acall	0xd
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	4d 10       	lddpc	r0,80004f24 <spi_setupChipReg+0x2e>
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	c7 04       	brge	80004ec6 <spi_selectChip+0x42>

80004de8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004de8:	fe 78 08 00 	mov	r8,-63488
80004dec:	e0 69 00 83 	mov	r9,131
80004df0:	f2 0c 01 0c 	sub	r12,r9,r12
80004df4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004df8:	f2 ca ff c0 	sub	r10,r9,-64
80004dfc:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004e00:	58 08       	cp.w	r8,0
80004e02:	c0 21       	brne	80004e06 <_get_interrupt_handler+0x1e>
80004e04:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004e06:	f0 08 12 00 	clz	r8,r8
80004e0a:	48 5a       	lddpc	r10,80004e1c <_get_interrupt_handler+0x34>
80004e0c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004e10:	f0 08 11 1f 	rsub	r8,r8,31
80004e14:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004e16:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004e1a:	5e fc       	retal	r12
80004e1c:	80 00       	ld.sh	r0,r0[0x0]
80004e1e:	d0 d0       	acall	0xd

80004e20 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80004e20:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004e24:	30 18       	mov	r8,1
80004e26:	f0 09 18 00 	cp.b	r9,r8
80004e2a:	e0 88 00 04 	brls	80004e32 <spi_initMaster+0x12>
80004e2e:	30 2c       	mov	r12,2
80004e30:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80004e32:	e0 68 00 80 	mov	r8,128
80004e36:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80004e38:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80004e3a:	30 19       	mov	r9,1
80004e3c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80004e40:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004e44:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80004e48:	30 09       	mov	r9,0
80004e4a:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80004e4e:	30 fa       	mov	r10,15
80004e50:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80004e54:	99 18       	st.w	r12[0x4],r8
80004e56:	5e f9       	retal	r9

80004e58 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80004e58:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80004e5a:	30 18       	mov	r8,1
80004e5c:	f0 0b 18 00 	cp.b	r11,r8
80004e60:	5f be       	srhi	lr
80004e62:	f0 0a 18 00 	cp.b	r10,r8
80004e66:	5f b8       	srhi	r8
80004e68:	fd e8 10 08 	or	r8,lr,r8
80004e6c:	c0 30       	breq	80004e72 <spi_selectionMode+0x1a>
80004e6e:	30 2c       	mov	r12,2
80004e70:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80004e72:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80004e74:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80004e78:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80004e7c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80004e80:	99 18       	st.w	r12[0x4],r8
80004e82:	d8 0a       	popm	pc,r12=0

80004e84 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004e84:	78 18       	ld.w	r8,r12[0x4]
80004e86:	ea 18 00 0f 	orh	r8,0xf
80004e8a:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004e8c:	78 18       	ld.w	r8,r12[0x4]
80004e8e:	e2 18 00 04 	andl	r8,0x4,COH
80004e92:	c0 f0       	breq	80004eb0 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80004e94:	30 e8       	mov	r8,14
80004e96:	f0 0b 18 00 	cp.b	r11,r8
80004e9a:	e0 8b 00 19 	brhi	80004ecc <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80004e9e:	78 18       	ld.w	r8,r12[0x4]
80004ea0:	b1 6b       	lsl	r11,0x10
80004ea2:	ea 1b ff f0 	orh	r11,0xfff0
80004ea6:	e8 1b ff ff 	orl	r11,0xffff
80004eaa:	10 6b       	and	r11,r8
80004eac:	99 1b       	st.w	r12[0x4],r11
80004eae:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80004eb0:	30 38       	mov	r8,3
80004eb2:	f0 0b 18 00 	cp.b	r11,r8
80004eb6:	e0 8b 00 0b 	brhi	80004ecc <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80004eba:	78 18       	ld.w	r8,r12[0x4]
80004ebc:	2f 0b       	sub	r11,-16
80004ebe:	30 19       	mov	r9,1
80004ec0:	f2 0b 09 4b 	lsl	r11,r9,r11
80004ec4:	5c db       	com	r11
80004ec6:	10 6b       	and	r11,r8
80004ec8:	99 1b       	st.w	r12[0x4],r11
80004eca:	5e fd       	retal	0
80004ecc:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80004ece:	5e fc       	retal	r12

80004ed0 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80004ed0:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004ed4:	c0 58       	rjmp	80004ede <spi_unselectChip+0xe>
    if (!timeout--) {
80004ed6:	58 08       	cp.w	r8,0
80004ed8:	c0 21       	brne	80004edc <spi_unselectChip+0xc>
80004eda:	5e ff       	retal	1
80004edc:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004ede:	78 49       	ld.w	r9,r12[0x10]
80004ee0:	e2 19 02 00 	andl	r9,0x200,COH
80004ee4:	cf 90       	breq	80004ed6 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004ee6:	78 18       	ld.w	r8,r12[0x4]
80004ee8:	ea 18 00 0f 	orh	r8,0xf
80004eec:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80004eee:	fc 18 01 00 	movh	r8,0x100
80004ef2:	99 08       	st.w	r12[0x0],r8
80004ef4:	5e fd       	retal	0

80004ef6 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80004ef6:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80004efa:	f7 38 00 0c 	ld.ub	r8,r11[12]
80004efe:	30 39       	mov	r9,3
80004f00:	f2 08 18 00 	cp.b	r8,r9
80004f04:	e0 8b 00 57 	brhi	80004fb2 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80004f08:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80004f0c:	30 1e       	mov	lr,1
80004f0e:	fc 09 18 00 	cp.b	r9,lr
80004f12:	e0 8b 00 50 	brhi	80004fb2 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80004f16:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80004f1a:	30 77       	mov	r7,7
80004f1c:	ee 0e 18 00 	cp.b	lr,r7
80004f20:	e0 88 00 49 	brls	80004fb2 <spi_setupChipReg+0xbc>
80004f24:	31 07       	mov	r7,16
80004f26:	ee 0e 18 00 	cp.b	lr,r7
80004f2a:	e0 8b 00 44 	brhi	80004fb2 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80004f2e:	76 17       	ld.w	r7,r11[0x4]
80004f30:	ee 06 16 01 	lsr	r6,r7,0x1
80004f34:	0c 0a       	add	r10,r6
80004f36:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80004f3a:	ec c7 00 01 	sub	r7,r6,1
80004f3e:	e0 47 00 fe 	cp.w	r7,254
80004f42:	e0 8b 00 38 	brhi	80004fb2 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80004f46:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80004f48:	58 06       	cp.w	r6,0
80004f4a:	c3 45       	brlt	80004fb2 <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80004f4c:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80004f4e:	f0 06 16 01 	lsr	r6,r8,0x1
80004f52:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80004f56:	ec 18 00 01 	eorl	r8,0x1
80004f5a:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80004f5e:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80004f62:	20 8e       	sub	lr,8
80004f64:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80004f68:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80004f6c:	f7 38 00 09 	ld.ub	r8,r11[9]
80004f70:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80004f74:	f7 38 00 0a 	ld.ub	r8,r11[10]
80004f78:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80004f7c:	17 88       	ld.ub	r8,r11[0x0]
80004f7e:	30 19       	mov	r9,1
80004f80:	f2 08 18 00 	cp.b	r8,r9
80004f84:	c0 e0       	breq	80004fa0 <spi_setupChipReg+0xaa>
80004f86:	c0 a3       	brcs	80004f9a <spi_setupChipReg+0xa4>
80004f88:	30 29       	mov	r9,2
80004f8a:	f2 08 18 00 	cp.b	r8,r9
80004f8e:	c0 c0       	breq	80004fa6 <spi_setupChipReg+0xb0>
80004f90:	30 39       	mov	r9,3
80004f92:	f2 08 18 00 	cp.b	r8,r9
80004f96:	c0 e1       	brne	80004fb2 <spi_setupChipReg+0xbc>
80004f98:	c0 a8       	rjmp	80004fac <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80004f9a:	99 ca       	st.w	r12[0x30],r10
80004f9c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80004fa0:	99 da       	st.w	r12[0x34],r10
80004fa2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80004fa6:	99 ea       	st.w	r12[0x38],r10
80004fa8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80004fac:	99 fa       	st.w	r12[0x3c],r10
80004fae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80004fb2:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80004fb4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80004fb8 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80004fb8:	30 18       	mov	r8,1
80004fba:	99 08       	st.w	r12[0x0],r8
}
80004fbc:	5e fc       	retal	r12

80004fbe <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80004fbe:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004fc2:	c0 58       	rjmp	80004fcc <spi_write+0xe>
    if (!timeout--) {
80004fc4:	58 08       	cp.w	r8,0
80004fc6:	c0 21       	brne	80004fca <spi_write+0xc>
80004fc8:	5e ff       	retal	1
80004fca:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004fcc:	78 49       	ld.w	r9,r12[0x10]
80004fce:	e2 19 00 02 	andl	r9,0x2,COH
80004fd2:	cf 90       	breq	80004fc4 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80004fd4:	5c 7b       	castu.h	r11
80004fd6:	99 3b       	st.w	r12[0xc],r11
80004fd8:	5e fd       	retal	0

80004fda <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80004fda:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80004fde:	c0 58       	rjmp	80004fe8 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80004fe0:	58 08       	cp.w	r8,0
80004fe2:	c0 21       	brne	80004fe6 <spi_read+0xc>
80004fe4:	5e ff       	retal	1
80004fe6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80004fe8:	78 49       	ld.w	r9,r12[0x10]
80004fea:	e2 19 02 01 	andl	r9,0x201,COH
80004fee:	e0 49 02 01 	cp.w	r9,513
80004ff2:	cf 71       	brne	80004fe0 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80004ff4:	78 28       	ld.w	r8,r12[0x8]
80004ff6:	b6 08       	st.h	r11[0x0],r8
80004ff8:	5e fd       	retal	0

80004ffa <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004ffa:	76 09       	ld.w	r9,r11[0x0]
80004ffc:	58 29       	cp.w	r9,2
80004ffe:	e0 88 00 03 	brls	80005004 <tc_init_waveform+0xa>
80005002:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005004:	76 18       	ld.w	r8,r11[0x4]
80005006:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000500a:	af ba       	sbr	r10,0xf
8000500c:	10 9b       	mov	r11,r8
8000500e:	e6 1b c0 00 	andh	r11,0xc000,COH
80005012:	16 4a       	or	r10,r11
80005014:	10 9b       	mov	r11,r8
80005016:	e6 1b 30 00 	andh	r11,0x3000,COH
8000501a:	16 4a       	or	r10,r11
8000501c:	10 9b       	mov	r11,r8
8000501e:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005022:	16 4a       	or	r10,r11
80005024:	10 9b       	mov	r11,r8
80005026:	e6 1b 03 00 	andh	r11,0x300,COH
8000502a:	16 4a       	or	r10,r11
8000502c:	10 9b       	mov	r11,r8
8000502e:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005032:	16 4a       	or	r10,r11
80005034:	10 9b       	mov	r11,r8
80005036:	e6 1b 00 30 	andh	r11,0x30,COH
8000503a:	16 4a       	or	r10,r11
8000503c:	10 9b       	mov	r11,r8
8000503e:	e6 1b 00 0c 	andh	r11,0xc,COH
80005042:	16 4a       	or	r10,r11
80005044:	10 9b       	mov	r11,r8
80005046:	e6 1b 00 03 	andh	r11,0x3,COH
8000504a:	16 4a       	or	r10,r11
8000504c:	10 9b       	mov	r11,r8
8000504e:	e2 1b 60 00 	andl	r11,0x6000,COH
80005052:	16 4a       	or	r10,r11
80005054:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005058:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
8000505c:	10 9b       	mov	r11,r8
8000505e:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005062:	16 4a       	or	r10,r11
80005064:	10 9b       	mov	r11,r8
80005066:	e2 1b 03 00 	andl	r11,0x300,COH
8000506a:	16 4a       	or	r10,r11
8000506c:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005070:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005074:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005078:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
8000507c:	10 9b       	mov	r11,r8
8000507e:	e2 1b 00 30 	andl	r11,0x30,COH
80005082:	16 4a       	or	r10,r11
80005084:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005088:	f5 e8 10 38 	or	r8,r10,r8<<0x3
8000508c:	a5 69       	lsl	r9,0x4
8000508e:	2f f9       	sub	r9,-1
80005090:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005094:	5e fd       	retal	0

80005096 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005096:	58 2b       	cp.w	r11,2
80005098:	e0 88 00 03 	brls	8000509e <tc_start+0x8>
8000509c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000509e:	a7 6b       	lsl	r11,0x6
800050a0:	16 0c       	add	r12,r11
800050a2:	30 58       	mov	r8,5
800050a4:	99 08       	st.w	r12[0x0],r8
800050a6:	5e fd       	retal	0

800050a8 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800050a8:	58 2b       	cp.w	r11,2
800050aa:	e0 88 00 03 	brls	800050b0 <tc_read_sr+0x8>
800050ae:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800050b0:	a7 6b       	lsl	r11,0x6
800050b2:	2e 0b       	sub	r11,-32
800050b4:	16 0c       	add	r12,r11
800050b6:	78 0c       	ld.w	r12,r12[0x0]
}
800050b8:	5e fc       	retal	r12

800050ba <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800050ba:	58 2b       	cp.w	r11,2
800050bc:	e0 88 00 03 	brls	800050c2 <tc_write_rc+0x8>
800050c0:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800050c2:	f6 08 15 04 	lsl	r8,r11,0x4
800050c6:	2f f8       	sub	r8,-1
800050c8:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800050cc:	e2 18 80 00 	andl	r8,0x8000,COH
800050d0:	c0 c0       	breq	800050e8 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800050d2:	a7 6b       	lsl	r11,0x6
800050d4:	16 0c       	add	r12,r11
800050d6:	2e 4c       	sub	r12,-28
800050d8:	78 08       	ld.w	r8,r12[0x0]
800050da:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800050de:	e0 18 00 00 	andl	r8,0x0
800050e2:	f3 e8 10 08 	or	r8,r9,r8
800050e6:	99 08       	st.w	r12[0x0],r8

  return value;
800050e8:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
800050ec:	5e fc       	retal	r12

800050ee <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
800050ee:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800050f2:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800050f6:	58 2b       	cp.w	r11,2
800050f8:	e0 88 00 04 	brls	80005100 <tc_configure_interrupts+0x12>
800050fc:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005100:	ee 19 00 01 	eorh	r9,0x1
80005104:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005108:	74 08       	ld.w	r8,r10[0x0]
8000510a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
8000510e:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80005112:	a7 6e       	lsl	lr,0x6
80005114:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005118:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
8000511c:	0e 4e       	or	lr,r7
8000511e:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80005122:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005126:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
8000512a:	fd e7 10 4e 	or	lr,lr,r7<<0x4
8000512e:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80005132:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005136:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
8000513a:	fd e7 10 2e 	or	lr,lr,r7<<0x2
8000513e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005142:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005146:	f6 0e 15 06 	lsl	lr,r11,0x6
8000514a:	f8 0e 00 0e 	add	lr,r12,lr
8000514e:	2d ce       	sub	lr,-36
80005150:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80005152:	58 09       	cp.w	r9,0
80005154:	c0 20       	breq	80005158 <tc_configure_interrupts+0x6a>
80005156:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005158:	74 08       	ld.w	r8,r10[0x0]
8000515a:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
8000515e:	e0 65 00 80 	mov	r5,128
80005162:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80005166:	74 08       	ld.w	r8,r10[0x0]
80005168:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
8000516c:	f9 b4 00 40 	moveq	r4,64
80005170:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80005174:	74 08       	ld.w	r8,r10[0x0]
80005176:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
8000517a:	f9 b3 00 20 	moveq	r3,32
8000517e:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80005182:	74 08       	ld.w	r8,r10[0x0]
80005184:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005188:	f9 b2 00 10 	moveq	r2,16
8000518c:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005190:	74 08       	ld.w	r8,r10[0x0]
80005192:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005196:	f9 b6 00 08 	moveq	r6,8
8000519a:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
8000519e:	74 08       	ld.w	r8,r10[0x0]
800051a0:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800051a4:	f9 b7 00 04 	moveq	r7,4
800051a8:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800051ac:	74 08       	ld.w	r8,r10[0x0]
800051ae:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800051b2:	f9 be 00 02 	moveq	lr,2
800051b6:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800051ba:	74 08       	ld.w	r8,r10[0x0]
800051bc:	ec 18 00 01 	eorl	r8,0x1
800051c0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800051c4:	eb e8 10 08 	or	r8,r5,r8
800051c8:	08 48       	or	r8,r4
800051ca:	06 48       	or	r8,r3
800051cc:	04 48       	or	r8,r2
800051ce:	0c 48       	or	r8,r6
800051d0:	0e 48       	or	r8,r7
800051d2:	1c 48       	or	r8,lr
800051d4:	f6 0a 15 06 	lsl	r10,r11,0x6
800051d8:	f8 0a 00 0a 	add	r10,r12,r10
800051dc:	2d 8a       	sub	r10,-40
800051de:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800051e0:	a7 6b       	lsl	r11,0x6
800051e2:	2e 0b       	sub	r11,-32
800051e4:	16 0c       	add	r12,r11
800051e6:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
800051e8:	58 09       	cp.w	r9,0
800051ea:	c0 31       	brne	800051f0 <tc_configure_interrupts+0x102>
800051ec:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800051f0:	d5 03       	csrf	0x10
800051f2:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

800051f6 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800051f6:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800051f8:	f6 08 15 04 	lsl	r8,r11,0x4
800051fc:	14 38       	cp.w	r8,r10
800051fe:	f9 b8 08 10 	movls	r8,16
80005202:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005206:	f0 0b 02 4b 	mul	r11,r8,r11
8000520a:	f6 09 16 01 	lsr	r9,r11,0x1
8000520e:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005212:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005216:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000521a:	f2 cb 00 01 	sub	r11,r9,1
8000521e:	e0 4b ff fe 	cp.w	r11,65534
80005222:	e0 88 00 03 	brls	80005228 <usart_set_async_baudrate+0x32>
80005226:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005228:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000522a:	e8 6e 00 00 	mov	lr,524288
8000522e:	59 08       	cp.w	r8,16
80005230:	fc 08 17 10 	movne	r8,lr
80005234:	f9 b8 00 00 	moveq	r8,0
80005238:	e4 1b ff f7 	andh	r11,0xfff7
8000523c:	e0 1b fe cf 	andl	r11,0xfecf
80005240:	16 48       	or	r8,r11
80005242:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005244:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005248:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000524c:	99 89       	st.w	r12[0x20],r9
8000524e:	d8 0a       	popm	pc,r12=0

80005250 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005250:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005252:	e2 18 00 02 	andl	r8,0x2,COH
80005256:	c0 31       	brne	8000525c <usart_write_char+0xc>
80005258:	30 2c       	mov	r12,2
8000525a:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000525c:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005260:	99 7b       	st.w	r12[0x1c],r11
80005262:	5e fd       	retal	0

80005264 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005264:	eb cd 40 e0 	pushm	r5-r7,lr
80005268:	18 96       	mov	r6,r12
8000526a:	16 95       	mov	r5,r11
8000526c:	e0 67 27 0f 	mov	r7,9999
80005270:	c0 68       	rjmp	8000527c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005272:	58 07       	cp.w	r7,0
80005274:	c0 31       	brne	8000527a <usart_putchar+0x16>
80005276:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000527a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000527c:	0a 9b       	mov	r11,r5
8000527e:	0c 9c       	mov	r12,r6
80005280:	f0 1f 00 03 	mcall	8000528c <usart_putchar+0x28>
80005284:	cf 71       	brne	80005272 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005286:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000528a:	00 00       	add	r0,r0
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	52 50       	stdsp	sp[0x94],r0

80005290 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005290:	78 58       	ld.w	r8,r12[0x14]
80005292:	e2 18 00 e0 	andl	r8,0xe0,COH
80005296:	c0 30       	breq	8000529c <usart_read_char+0xc>
80005298:	30 4c       	mov	r12,4
8000529a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
8000529c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000529e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800052a2:	c0 31       	brne	800052a8 <usart_read_char+0x18>
800052a4:	30 3c       	mov	r12,3
800052a6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800052a8:	78 68       	ld.w	r8,r12[0x18]
800052aa:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800052ae:	97 08       	st.w	r11[0x0],r8
800052b0:	5e fd       	retal	0
800052b2:	d7 03       	nop

800052b4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800052b4:	eb cd 40 c0 	pushm	r6-r7,lr
800052b8:	20 1d       	sub	sp,4
800052ba:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800052bc:	1a 97       	mov	r7,sp
800052be:	1a 9b       	mov	r11,sp
800052c0:	0c 9c       	mov	r12,r6
800052c2:	f0 1f 00 07 	mcall	800052dc <usart_getchar+0x28>
800052c6:	58 3c       	cp.w	r12,3
800052c8:	cf b0       	breq	800052be <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800052ca:	58 4c       	cp.w	r12,4
800052cc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800052d0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800052d4:	2f fd       	sub	sp,-4
800052d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800052da:	00 00       	add	r0,r0
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	52 90       	stdsp	sp[0xa4],r0

800052e0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800052e0:	eb cd 40 c0 	pushm	r6-r7,lr
800052e4:	18 96       	mov	r6,r12
800052e6:	16 97       	mov	r7,r11
  while (*string != '\0')
800052e8:	17 8b       	ld.ub	r11,r11[0x0]
800052ea:	58 0b       	cp.w	r11,0
800052ec:	c0 80       	breq	800052fc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800052ee:	2f f7       	sub	r7,-1
800052f0:	0c 9c       	mov	r12,r6
800052f2:	f0 1f 00 04 	mcall	80005300 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800052f6:	0f 8b       	ld.ub	r11,r7[0x0]
800052f8:	58 0b       	cp.w	r11,0
800052fa:	cf a1       	brne	800052ee <usart_write_line+0xe>
800052fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	52 64       	stdsp	sp[0x98],r4

80005304 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005304:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005308:	e6 18 00 01 	andh	r8,0x1,COH
8000530c:	c0 71       	brne	8000531a <usart_reset+0x16>
8000530e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005310:	3f f8       	mov	r8,-1
80005312:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005314:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005316:	d5 03       	csrf	0x10
80005318:	c0 48       	rjmp	80005320 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000531a:	3f f8       	mov	r8,-1
8000531c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000531e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005320:	30 08       	mov	r8,0
80005322:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005324:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005326:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005328:	ea 68 61 0c 	mov	r8,680204
8000532c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000532e:	5e fc       	retal	r12

80005330 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005330:	eb cd 40 e0 	pushm	r5-r7,lr
80005334:	18 96       	mov	r6,r12
80005336:	16 97       	mov	r7,r11
80005338:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000533a:	f0 1f 00 2f 	mcall	800053f4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000533e:	58 07       	cp.w	r7,0
80005340:	c5 80       	breq	800053f0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005342:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005344:	30 49       	mov	r9,4
80005346:	f2 08 18 00 	cp.b	r8,r9
8000534a:	e0 88 00 53 	brls	800053f0 <usart_init_rs232+0xc0>
8000534e:	30 99       	mov	r9,9
80005350:	f2 08 18 00 	cp.b	r8,r9
80005354:	e0 8b 00 4e 	brhi	800053f0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005358:	0f d9       	ld.ub	r9,r7[0x5]
8000535a:	30 78       	mov	r8,7
8000535c:	f0 09 18 00 	cp.b	r9,r8
80005360:	e0 8b 00 48 	brhi	800053f0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005364:	8e 39       	ld.sh	r9,r7[0x6]
80005366:	e0 68 01 01 	mov	r8,257
8000536a:	f0 09 19 00 	cp.h	r9,r8
8000536e:	e0 8b 00 41 	brhi	800053f0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005372:	ef 39 00 08 	ld.ub	r9,r7[8]
80005376:	30 38       	mov	r8,3
80005378:	f0 09 18 00 	cp.b	r9,r8
8000537c:	e0 8b 00 3a 	brhi	800053f0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005380:	0a 9a       	mov	r10,r5
80005382:	6e 0b       	ld.w	r11,r7[0x0]
80005384:	0c 9c       	mov	r12,r6
80005386:	f0 1f 00 1d 	mcall	800053f8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000538a:	58 1c       	cp.w	r12,1
8000538c:	c3 20       	breq	800053f0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000538e:	0f c8       	ld.ub	r8,r7[0x4]
80005390:	30 99       	mov	r9,9
80005392:	f2 08 18 00 	cp.b	r8,r9
80005396:	c0 51       	brne	800053a0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005398:	6c 18       	ld.w	r8,r6[0x4]
8000539a:	b1 b8       	sbr	r8,0x11
8000539c:	8d 18       	st.w	r6[0x4],r8
8000539e:	c0 68       	rjmp	800053aa <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800053a0:	6c 19       	ld.w	r9,r6[0x4]
800053a2:	20 58       	sub	r8,5
800053a4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800053a8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800053aa:	6c 19       	ld.w	r9,r6[0x4]
800053ac:	ef 3a 00 08 	ld.ub	r10,r7[8]
800053b0:	0f d8       	ld.ub	r8,r7[0x5]
800053b2:	a9 78       	lsl	r8,0x9
800053b4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800053b8:	12 48       	or	r8,r9
800053ba:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800053bc:	8e 38       	ld.sh	r8,r7[0x6]
800053be:	30 29       	mov	r9,2
800053c0:	f2 08 19 00 	cp.h	r8,r9
800053c4:	e0 88 00 09 	brls	800053d6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800053c8:	6c 18       	ld.w	r8,r6[0x4]
800053ca:	ad b8       	sbr	r8,0xd
800053cc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800053ce:	8e b8       	ld.uh	r8,r7[0x6]
800053d0:	20 28       	sub	r8,2
800053d2:	8d a8       	st.w	r6[0x28],r8
800053d4:	c0 68       	rjmp	800053e0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800053d6:	6c 19       	ld.w	r9,r6[0x4]
800053d8:	5c 78       	castu.h	r8
800053da:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800053de:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800053e0:	6c 18       	ld.w	r8,r6[0x4]
800053e2:	e0 18 ff f0 	andl	r8,0xfff0
800053e6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800053e8:	35 08       	mov	r8,80
800053ea:	8d 08       	st.w	r6[0x0],r8
800053ec:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800053f0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	53 04       	stdsp	sp[0xc0],r4
800053f8:	80 00       	ld.sh	r0,r0[0x0]
800053fa:	51 f6       	stdsp	sp[0x7c],r6

800053fc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800053fc:	f8 c8 ff f8 	sub	r8,r12,-8
80005400:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005402:	3f f9       	mov	r9,-1
80005404:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005406:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005408:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000540a:	30 08       	mov	r8,0
8000540c:	99 08       	st.w	r12[0x0],r8
}
8000540e:	5e fc       	retal	r12

80005410 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005410:	30 08       	mov	r8,0
80005412:	99 48       	st.w	r12[0x10],r8
}
80005414:	5e fc       	retal	r12

80005416 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005416:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005418:	70 19       	ld.w	r9,r8[0x4]
8000541a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000541c:	78 19       	ld.w	r9,r12[0x4]
8000541e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005420:	70 19       	ld.w	r9,r8[0x4]
80005422:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005424:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005426:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005428:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000542a:	78 08       	ld.w	r8,r12[0x0]
8000542c:	2f f8       	sub	r8,-1
8000542e:	99 08       	st.w	r12[0x0],r8
}
80005430:	5e fc       	retal	r12

80005432 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005432:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005434:	5b fa       	cp.w	r10,-1
80005436:	c0 31       	brne	8000543c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005438:	78 48       	ld.w	r8,r12[0x10]
8000543a:	c0 c8       	rjmp	80005452 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000543c:	f8 c8 ff f8 	sub	r8,r12,-8
80005440:	70 19       	ld.w	r9,r8[0x4]
80005442:	72 09       	ld.w	r9,r9[0x0]
80005444:	12 3a       	cp.w	r10,r9
80005446:	c0 63       	brcs	80005452 <vListInsert+0x20>
80005448:	70 18       	ld.w	r8,r8[0x4]
8000544a:	70 19       	ld.w	r9,r8[0x4]
8000544c:	72 09       	ld.w	r9,r9[0x0]
8000544e:	12 3a       	cp.w	r10,r9
80005450:	cf c2       	brcc	80005448 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005452:	70 19       	ld.w	r9,r8[0x4]
80005454:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005456:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005458:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000545a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000545c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000545e:	78 08       	ld.w	r8,r12[0x0]
80005460:	2f f8       	sub	r8,-1
80005462:	99 08       	st.w	r12[0x0],r8
}
80005464:	5e fc       	retal	r12

80005466 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005466:	78 18       	ld.w	r8,r12[0x4]
80005468:	78 29       	ld.w	r9,r12[0x8]
8000546a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000546c:	78 28       	ld.w	r8,r12[0x8]
8000546e:	78 19       	ld.w	r9,r12[0x4]
80005470:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005472:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005474:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005476:	18 39       	cp.w	r9,r12
80005478:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000547c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005480:	30 09       	mov	r9,0
80005482:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005484:	70 09       	ld.w	r9,r8[0x0]
80005486:	20 19       	sub	r9,1
80005488:	91 09       	st.w	r8[0x0],r9
}
8000548a:	5e fc       	retal	r12

8000548c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000548c:	e0 68 08 08 	mov	r8,2056
80005490:	ea 18 08 08 	orh	r8,0x808
80005494:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005496:	e0 68 09 09 	mov	r8,2313
8000549a:	ea 18 09 09 	orh	r8,0x909
8000549e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800054a0:	e0 68 0a 0a 	mov	r8,2570
800054a4:	ea 18 0a 0a 	orh	r8,0xa0a
800054a8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800054aa:	e0 68 0b 0b 	mov	r8,2827
800054ae:	ea 18 0b 0b 	orh	r8,0xb0b
800054b2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800054b4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800054b6:	e0 68 be ef 	mov	r8,48879
800054ba:	ea 18 de ad 	orh	r8,0xdead
800054be:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800054c0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800054c2:	fc 18 00 40 	movh	r8,0x40
800054c6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800054c8:	e0 68 00 ff 	mov	r8,255
800054cc:	ea 18 ff 00 	orh	r8,0xff00
800054d0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800054d2:	e0 68 01 01 	mov	r8,257
800054d6:	ea 18 01 01 	orh	r8,0x101
800054da:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800054dc:	e0 68 02 02 	mov	r8,514
800054e0:	ea 18 02 02 	orh	r8,0x202
800054e4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800054e6:	e0 68 03 03 	mov	r8,771
800054ea:	ea 18 03 03 	orh	r8,0x303
800054ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800054f0:	e0 68 04 04 	mov	r8,1028
800054f4:	ea 18 04 04 	orh	r8,0x404
800054f8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800054fa:	e0 68 05 05 	mov	r8,1285
800054fe:	ea 18 05 05 	orh	r8,0x505
80005502:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005504:	e0 68 06 06 	mov	r8,1542
80005508:	ea 18 06 06 	orh	r8,0x606
8000550c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000550e:	e0 68 07 07 	mov	r8,1799
80005512:	ea 18 07 07 	orh	r8,0x707
80005516:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005518:	30 08       	mov	r8,0
8000551a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000551c:	5e fc       	retal	r12
8000551e:	d7 03       	nop

80005520 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005520:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005522:	48 38       	lddpc	r8,8000552c <vPortEnterCritical+0xc>
80005524:	70 09       	ld.w	r9,r8[0x0]
80005526:	2f f9       	sub	r9,-1
80005528:	91 09       	st.w	r8[0x0],r9
}
8000552a:	5e fc       	retal	r12
8000552c:	00 00       	add	r0,r0
8000552e:	05 3c       	ld.ub	r12,r2++

80005530 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005530:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005532:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005534:	30 0a       	mov	r10,0
80005536:	14 9b       	mov	r11,r10
80005538:	49 2c       	lddpc	r12,80005580 <xPortStartScheduler+0x50>
8000553a:	f0 1f 00 13 	mcall	80005584 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000553e:	e0 68 5d c0 	mov	r8,24000
80005542:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005546:	30 08       	mov	r8,0
80005548:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000554c:	e0 68 0c e0 	mov	r8,3296
80005550:	ea 18 00 00 	orh	r8,0x0
80005554:	70 00       	ld.w	r0,r8[0x0]
80005556:	60 0d       	ld.w	sp,r0[0x0]
80005558:	1b 00       	ld.w	r0,sp++
8000555a:	e0 68 05 3c 	mov	r8,1340
8000555e:	ea 18 00 00 	orh	r8,0x0
80005562:	91 00       	st.w	r8[0x0],r0
80005564:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005568:	2f ed       	sub	sp,-8
8000556a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000556e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005572:	e3 b0 00 00 	mtsr	0x0,r0
80005576:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000557a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000557e:	d8 0a       	popm	pc,r12=0
80005580:	80 00       	ld.sh	r0,r0[0x0]
80005582:	56 4c       	stdsp	sp[0x190],r12
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	4d 14       	lddpc	r4,800056c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

80005588 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005588:	20 6d       	sub	sp,24
8000558a:	eb cd 00 ff 	pushm	r0-r7
8000558e:	fa c7 ff c0 	sub	r7,sp,-64
80005592:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005596:	ef 40 ff e0 	st.w	r7[-32],r0
8000559a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000559e:	ef 40 ff e4 	st.w	r7[-28],r0
800055a2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800055a6:	e0 68 05 3c 	mov	r8,1340
800055aa:	ea 18 00 00 	orh	r8,0x0
800055ae:	70 00       	ld.w	r0,r8[0x0]
800055b0:	1a d0       	st.w	--sp,r0
800055b2:	f0 1f 00 1a 	mcall	80005618 <LABEL_RET_SCALL_263+0x14>
800055b6:	e0 68 0c e0 	mov	r8,3296
800055ba:	ea 18 00 00 	orh	r8,0x0
800055be:	70 00       	ld.w	r0,r8[0x0]
800055c0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800055c2:	f0 1f 00 17 	mcall	8000561c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800055c6:	e0 68 0c e0 	mov	r8,3296
800055ca:	ea 18 00 00 	orh	r8,0x0
800055ce:	70 00       	ld.w	r0,r8[0x0]
800055d0:	60 0d       	ld.w	sp,r0[0x0]
800055d2:	1b 00       	ld.w	r0,sp++
800055d4:	e0 68 05 3c 	mov	r8,1340
800055d8:	ea 18 00 00 	orh	r8,0x0
800055dc:	91 00       	st.w	r8[0x0],r0
800055de:	fa c7 ff d8 	sub	r7,sp,-40
800055e2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800055e6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800055ea:	e0 61 05 3c 	mov	r1,1340
800055ee:	ea 11 00 00 	orh	r1,0x0
800055f2:	62 02       	ld.w	r2,r1[0x0]
800055f4:	58 02       	cp.w	r2,0
800055f6:	c0 70       	breq	80005604 <LABEL_RET_SCALL_263>
800055f8:	e4 c2 00 01 	sub	r2,r2,1
800055fc:	83 02       	st.w	r1[0x0],r2
800055fe:	58 02       	cp.w	r2,0
80005600:	c0 21       	brne	80005604 <LABEL_RET_SCALL_263>
80005602:	b1 c0       	cbr	r0,0x10

80005604 <LABEL_RET_SCALL_263>:
80005604:	ef 40 ff f8 	st.w	r7[-8],r0
80005608:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000560c:	ef 40 ff fc 	st.w	r7[-4],r0
80005610:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005614:	2f ad       	sub	sp,-24
80005616:	d6 13       	rets
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	55 20       	stdsp	sp[0x148],r0
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	5c 64       	casts.b	r4

80005620 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005620:	e1 b8 00 43 	mfsr	r8,0x10c
80005624:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005628:	5e fc       	retal	r12
8000562a:	d7 03       	nop

8000562c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000562c:	48 78       	lddpc	r8,80005648 <vPortExitCritical+0x1c>
8000562e:	70 08       	ld.w	r8,r8[0x0]
80005630:	58 08       	cp.w	r8,0
80005632:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005634:	48 58       	lddpc	r8,80005648 <vPortExitCritical+0x1c>
80005636:	70 09       	ld.w	r9,r8[0x0]
80005638:	20 19       	sub	r9,1
8000563a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000563c:	70 08       	ld.w	r8,r8[0x0]
8000563e:	58 08       	cp.w	r8,0
80005640:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005642:	d5 03       	csrf	0x10
80005644:	5e fc       	retal	r12
80005646:	00 00       	add	r0,r0
80005648:	00 00       	add	r0,r0
8000564a:	05 3c       	ld.ub	r12,r2++

8000564c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000564c:	eb cd 00 ff 	pushm	r0-r7
80005650:	e0 68 05 3c 	mov	r8,1340
80005654:	ea 18 00 00 	orh	r8,0x0
80005658:	70 00       	ld.w	r0,r8[0x0]
8000565a:	1a d0       	st.w	--sp,r0
8000565c:	7a 90       	ld.w	r0,sp[0x24]
8000565e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005662:	58 10       	cp.w	r0,1
80005664:	e0 8b 00 08 	brhi	80005674 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005668:	e0 68 0c e0 	mov	r8,3296
8000566c:	ea 18 00 00 	orh	r8,0x0
80005670:	70 00       	ld.w	r0,r8[0x0]
80005672:	81 0d       	st.w	r0[0x0],sp

80005674 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005674:	f0 1f 00 12 	mcall	800056bc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005678:	f0 1f 00 12 	mcall	800056c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000567c:	f0 1f 00 12 	mcall	800056c4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005680:	f0 1f 00 12 	mcall	800056c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005684:	7a 90       	ld.w	r0,sp[0x24]
80005686:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000568a:	58 10       	cp.w	r0,1
8000568c:	e0 8b 00 0e 	brhi	800056a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005690:	f0 1f 00 0c 	mcall	800056c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005694:	f0 1f 00 0e 	mcall	800056cc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005698:	f0 1f 00 0c 	mcall	800056c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000569c:	e0 68 0c e0 	mov	r8,3296
800056a0:	ea 18 00 00 	orh	r8,0x0
800056a4:	70 00       	ld.w	r0,r8[0x0]
800056a6:	60 0d       	ld.w	sp,r0[0x0]

800056a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800056a8:	1b 00       	ld.w	r0,sp++
800056aa:	e0 68 05 3c 	mov	r8,1340
800056ae:	ea 18 00 00 	orh	r8,0x0
800056b2:	91 00       	st.w	r8[0x0],r0
800056b4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800056b8:	d6 03       	rete
800056ba:	00 00       	add	r0,r0
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	56 20       	stdsp	sp[0x188],r0
800056c0:	80 00       	ld.sh	r0,r0[0x0]
800056c2:	55 20       	stdsp	sp[0x148],r0
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	5e 68       	retmi	r8
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	56 2c       	stdsp	sp[0x188],r12
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	5c 64       	casts.b	r4

800056d0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800056d0:	d4 01       	pushm	lr
	vTaskSuspendAll();
800056d2:	f0 1f 00 02 	mcall	800056d8 <__malloc_lock+0x8>
}
800056d6:	d8 02       	popm	pc
800056d8:	80 00       	ld.sh	r0,r0[0x0]
800056da:	5c 54       	castu.b	r4

800056dc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800056dc:	d4 01       	pushm	lr
	xTaskResumeAll();
800056de:	f0 1f 00 02 	mcall	800056e4 <__malloc_unlock+0x8>
}
800056e2:	d8 02       	popm	pc
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	60 10       	ld.w	r0,r0[0x4]

800056e8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800056e8:	d4 21       	pushm	r4-r7,lr
800056ea:	16 95       	mov	r5,r11
800056ec:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800056ee:	58 0c       	cp.w	r12,0
800056f0:	c0 30       	breq	800056f6 <_read+0xe>
800056f2:	3f f7       	mov	r7,-1
800056f4:	c1 48       	rjmp	8000571c <_read+0x34>
    return -1;

  for (; len > 0; --len)
800056f6:	58 0a       	cp.w	r10,0
800056f8:	e0 89 00 04 	brgt	80005700 <_read+0x18>
800056fc:	30 07       	mov	r7,0
800056fe:	c0 f8       	rjmp	8000571c <_read+0x34>
80005700:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005702:	48 84       	lddpc	r4,80005720 <_read+0x38>
80005704:	68 0c       	ld.w	r12,r4[0x0]
80005706:	f0 1f 00 08 	mcall	80005724 <_read+0x3c>
    if (c < 0)
8000570a:	c0 95       	brlt	8000571c <_read+0x34>
      break;

    *ptr++ = c;
8000570c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005710:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005712:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005716:	58 08       	cp.w	r8,0
80005718:	fe 99 ff f6 	brgt	80005704 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000571c:	0e 9c       	mov	r12,r7
8000571e:	d8 22       	popm	r4-r7,pc
80005720:	00 00       	add	r0,r0
80005722:	41 04       	lddsp	r4,sp[0x40]
80005724:	80 00       	ld.sh	r0,r0[0x0]
80005726:	52 b4       	stdsp	sp[0xac],r4

80005728 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005728:	d4 21       	pushm	r4-r7,lr
8000572a:	16 95       	mov	r5,r11
8000572c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000572e:	20 1c       	sub	r12,1
80005730:	58 2c       	cp.w	r12,2
80005732:	e0 8b 00 12 	brhi	80005756 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005736:	58 0a       	cp.w	r10,0
80005738:	c0 31       	brne	8000573e <_write+0x16>
8000573a:	30 07       	mov	r7,0
8000573c:	c0 e8       	rjmp	80005758 <_write+0x30>
8000573e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005740:	48 74       	lddpc	r4,8000575c <_write+0x34>
80005742:	68 0c       	ld.w	r12,r4[0x0]
80005744:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005748:	f0 1f 00 06 	mcall	80005760 <_write+0x38>
8000574c:	c0 55       	brlt	80005756 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000574e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005750:	0e 36       	cp.w	r6,r7
80005752:	cf 81       	brne	80005742 <_write+0x1a>
80005754:	c0 28       	rjmp	80005758 <_write+0x30>
80005756:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005758:	0e 9c       	mov	r12,r7
8000575a:	d8 22       	popm	r4-r7,pc
8000575c:	00 00       	add	r0,r0
8000575e:	41 04       	lddsp	r4,sp[0x40]
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	52 64       	stdsp	sp[0x98],r4

80005764 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005764:	eb cd 40 80 	pushm	r7,lr
80005768:	18 97       	mov	r7,r12
	if( pv )
8000576a:	58 0c       	cp.w	r12,0
8000576c:	c0 80       	breq	8000577c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000576e:	f0 1f 00 05 	mcall	80005780 <vPortFree+0x1c>
		{
			free( pv );
80005772:	0e 9c       	mov	r12,r7
80005774:	f0 1f 00 04 	mcall	80005784 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005778:	f0 1f 00 04 	mcall	80005788 <vPortFree+0x24>
8000577c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	5c 54       	castu.b	r4
80005784:	80 00       	ld.sh	r0,r0[0x0]
80005786:	6b b4       	ld.w	r4,r5[0x6c]
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	60 10       	ld.w	r0,r0[0x4]

8000578c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000578c:	eb cd 40 80 	pushm	r7,lr
80005790:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005792:	f0 1f 00 06 	mcall	800057a8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005796:	0e 9c       	mov	r12,r7
80005798:	f0 1f 00 05 	mcall	800057ac <pvPortMalloc+0x20>
8000579c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000579e:	f0 1f 00 05 	mcall	800057b0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800057a2:	0e 9c       	mov	r12,r7
800057a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	5c 54       	castu.b	r4
800057ac:	80 00       	ld.sh	r0,r0[0x0]
800057ae:	6b c4       	ld.w	r4,r5[0x70]
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	60 10       	ld.w	r0,r0[0x4]

800057b4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800057b4:	d4 01       	pushm	lr
800057b6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800057b8:	78 09       	ld.w	r9,r12[0x0]
800057ba:	58 09       	cp.w	r9,0
800057bc:	c1 10       	breq	800057de <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800057be:	78 3a       	ld.w	r10,r12[0xc]
800057c0:	79 09       	ld.w	r9,r12[0x40]
800057c2:	f4 09 00 09 	add	r9,r10,r9
800057c6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800057c8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800057ca:	14 39       	cp.w	r9,r10
800057cc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800057d0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800057d4:	79 0a       	ld.w	r10,r12[0x40]
800057d6:	78 3b       	ld.w	r11,r12[0xc]
800057d8:	10 9c       	mov	r12,r8
800057da:	f0 1f 00 02 	mcall	800057e0 <prvCopyDataFromQueue+0x2c>
800057de:	d8 02       	popm	pc
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	70 0c       	ld.w	r12,r8[0x0]

800057e4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800057e4:	eb cd 40 c0 	pushm	r6-r7,lr
800057e8:	18 97       	mov	r7,r12
800057ea:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800057ec:	78 e8       	ld.w	r8,r12[0x38]
800057ee:	58 08       	cp.w	r8,0
800057f0:	c0 31       	brne	800057f6 <xQueueReceiveFromISR+0x12>
800057f2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800057f6:	f0 1f 00 0e 	mcall	8000582c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800057fa:	6e e8       	ld.w	r8,r7[0x38]
800057fc:	20 18       	sub	r8,1
800057fe:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005800:	6f 18       	ld.w	r8,r7[0x44]
80005802:	5b f8       	cp.w	r8,-1
80005804:	c0 d1       	brne	8000581e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005806:	6e 48       	ld.w	r8,r7[0x10]
80005808:	58 08       	cp.w	r8,0
8000580a:	c0 f0       	breq	80005828 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000580c:	ee cc ff f0 	sub	r12,r7,-16
80005810:	f0 1f 00 08 	mcall	80005830 <xQueueReceiveFromISR+0x4c>
80005814:	c0 a0       	breq	80005828 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005816:	30 1c       	mov	r12,1
80005818:	8d 0c       	st.w	r6[0x0],r12
8000581a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000581e:	2f f8       	sub	r8,-1
80005820:	ef 48 00 44 	st.w	r7[68],r8
80005824:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005828:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	57 b4       	stdsp	sp[0x1ec],r4
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	5d ec       	*unknown*

80005834 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005834:	eb cd 40 c0 	pushm	r6-r7,lr
80005838:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000583a:	f0 1f 00 23 	mcall	800058c4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000583e:	6f 28       	ld.w	r8,r7[0x48]
80005840:	58 08       	cp.w	r8,0
80005842:	e0 8a 00 18 	brle	80005872 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005846:	6e 98       	ld.w	r8,r7[0x24]
80005848:	58 08       	cp.w	r8,0
8000584a:	c1 40       	breq	80005872 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000584c:	ee c6 ff dc 	sub	r6,r7,-36
80005850:	c0 48       	rjmp	80005858 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005852:	6e 98       	ld.w	r8,r7[0x24]
80005854:	58 08       	cp.w	r8,0
80005856:	c0 e0       	breq	80005872 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005858:	0c 9c       	mov	r12,r6
8000585a:	f0 1f 00 1c 	mcall	800058c8 <prvUnlockQueue+0x94>
8000585e:	c0 30       	breq	80005864 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005860:	f0 1f 00 1b 	mcall	800058cc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005864:	6f 28       	ld.w	r8,r7[0x48]
80005866:	20 18       	sub	r8,1
80005868:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000586c:	58 08       	cp.w	r8,0
8000586e:	fe 99 ff f2 	brgt	80005852 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005872:	3f f8       	mov	r8,-1
80005874:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005878:	f0 1f 00 16 	mcall	800058d0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000587c:	f0 1f 00 12 	mcall	800058c4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005880:	6f 18       	ld.w	r8,r7[0x44]
80005882:	58 08       	cp.w	r8,0
80005884:	e0 8a 00 18 	brle	800058b4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005888:	6e 48       	ld.w	r8,r7[0x10]
8000588a:	58 08       	cp.w	r8,0
8000588c:	c1 40       	breq	800058b4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000588e:	ee c6 ff f0 	sub	r6,r7,-16
80005892:	c0 48       	rjmp	8000589a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005894:	6e 48       	ld.w	r8,r7[0x10]
80005896:	58 08       	cp.w	r8,0
80005898:	c0 e0       	breq	800058b4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000589a:	0c 9c       	mov	r12,r6
8000589c:	f0 1f 00 0b 	mcall	800058c8 <prvUnlockQueue+0x94>
800058a0:	c0 30       	breq	800058a6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800058a2:	f0 1f 00 0b 	mcall	800058cc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800058a6:	6f 18       	ld.w	r8,r7[0x44]
800058a8:	20 18       	sub	r8,1
800058aa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800058ae:	58 08       	cp.w	r8,0
800058b0:	fe 99 ff f2 	brgt	80005894 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800058b4:	3f f8       	mov	r8,-1
800058b6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800058ba:	f0 1f 00 06 	mcall	800058d0 <prvUnlockQueue+0x9c>
}
800058be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058c2:	00 00       	add	r0,r0
800058c4:	80 00       	ld.sh	r0,r0[0x0]
800058c6:	55 20       	stdsp	sp[0x148],r0
800058c8:	80 00       	ld.sh	r0,r0[0x0]
800058ca:	5d ec       	*unknown*
800058cc:	80 00       	ld.sh	r0,r0[0x0]
800058ce:	5c f8       	rol	r8
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	56 2c       	stdsp	sp[0x188],r12

800058d4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800058d4:	d4 31       	pushm	r0-r7,lr
800058d6:	20 5d       	sub	sp,20
800058d8:	18 97       	mov	r7,r12
800058da:	50 0b       	stdsp	sp[0x0],r11
800058dc:	50 2a       	stdsp	sp[0x8],r10
800058de:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800058e0:	f8 c2 ff dc 	sub	r2,r12,-36
800058e4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800058e6:	fa c4 ff f4 	sub	r4,sp,-12
800058ea:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800058ec:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800058ee:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800058f2:	f0 1f 00 3e 	mcall	800059e8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800058f6:	6e e8       	ld.w	r8,r7[0x38]
800058f8:	58 08       	cp.w	r8,0
800058fa:	c2 a0       	breq	8000594e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800058fc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800058fe:	40 0b       	lddsp	r11,sp[0x0]
80005900:	0e 9c       	mov	r12,r7
80005902:	f0 1f 00 3b 	mcall	800059ec <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005906:	40 18       	lddsp	r8,sp[0x4]
80005908:	58 08       	cp.w	r8,0
8000590a:	c1 51       	brne	80005934 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000590c:	6e e8       	ld.w	r8,r7[0x38]
8000590e:	20 18       	sub	r8,1
80005910:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005912:	6e 08       	ld.w	r8,r7[0x0]
80005914:	58 08       	cp.w	r8,0
80005916:	c0 41       	brne	8000591e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005918:	f0 1f 00 36 	mcall	800059f0 <xQueueGenericReceive+0x11c>
8000591c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000591e:	6e 48       	ld.w	r8,r7[0x10]
80005920:	58 08       	cp.w	r8,0
80005922:	c1 20       	breq	80005946 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005924:	ee cc ff f0 	sub	r12,r7,-16
80005928:	f0 1f 00 33 	mcall	800059f4 <xQueueGenericReceive+0x120>
8000592c:	58 1c       	cp.w	r12,1
8000592e:	c0 c1       	brne	80005946 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005930:	d7 33       	scall
80005932:	c0 a8       	rjmp	80005946 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005934:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005936:	6e 98       	ld.w	r8,r7[0x24]
80005938:	58 08       	cp.w	r8,0
8000593a:	c0 60       	breq	80005946 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000593c:	04 9c       	mov	r12,r2
8000593e:	f0 1f 00 2e 	mcall	800059f4 <xQueueGenericReceive+0x120>
80005942:	c0 20       	breq	80005946 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005944:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005946:	f0 1f 00 2d 	mcall	800059f8 <xQueueGenericReceive+0x124>
8000594a:	30 1c       	mov	r12,1
				return pdPASS;
8000594c:	c4 c8       	rjmp	800059e4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000594e:	40 28       	lddsp	r8,sp[0x8]
80005950:	58 08       	cp.w	r8,0
80005952:	c0 51       	brne	8000595c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005954:	f0 1f 00 29 	mcall	800059f8 <xQueueGenericReceive+0x124>
80005958:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000595a:	c4 58       	rjmp	800059e4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000595c:	58 05       	cp.w	r5,0
8000595e:	c0 51       	brne	80005968 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005960:	08 9c       	mov	r12,r4
80005962:	f0 1f 00 27 	mcall	800059fc <xQueueGenericReceive+0x128>
80005966:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005968:	f0 1f 00 24 	mcall	800059f8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000596c:	f0 1f 00 25 	mcall	80005a00 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005970:	f0 1f 00 1e 	mcall	800059e8 <xQueueGenericReceive+0x114>
80005974:	6f 18       	ld.w	r8,r7[0x44]
80005976:	5b f8       	cp.w	r8,-1
80005978:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000597c:	6f 28       	ld.w	r8,r7[0x48]
8000597e:	5b f8       	cp.w	r8,-1
80005980:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005984:	f0 1f 00 1d 	mcall	800059f8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005988:	06 9b       	mov	r11,r3
8000598a:	08 9c       	mov	r12,r4
8000598c:	f0 1f 00 1e 	mcall	80005a04 <xQueueGenericReceive+0x130>
80005990:	c2 41       	brne	800059d8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005992:	f0 1f 00 16 	mcall	800059e8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005996:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005998:	f0 1f 00 18 	mcall	800059f8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000599c:	58 06       	cp.w	r6,0
8000599e:	c1 71       	brne	800059cc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800059a0:	6e 08       	ld.w	r8,r7[0x0]
800059a2:	58 08       	cp.w	r8,0
800059a4:	c0 81       	brne	800059b4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800059a6:	f0 1f 00 11 	mcall	800059e8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800059aa:	6e 1c       	ld.w	r12,r7[0x4]
800059ac:	f0 1f 00 17 	mcall	80005a08 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800059b0:	f0 1f 00 12 	mcall	800059f8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800059b4:	40 2b       	lddsp	r11,sp[0x8]
800059b6:	04 9c       	mov	r12,r2
800059b8:	f0 1f 00 15 	mcall	80005a0c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800059bc:	0e 9c       	mov	r12,r7
800059be:	f0 1f 00 15 	mcall	80005a10 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800059c2:	f0 1f 00 15 	mcall	80005a14 <xQueueGenericReceive+0x140>
800059c6:	c9 61       	brne	800058f2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800059c8:	d7 33       	scall
800059ca:	c9 4b       	rjmp	800058f2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800059cc:	0e 9c       	mov	r12,r7
800059ce:	f0 1f 00 11 	mcall	80005a10 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800059d2:	f0 1f 00 11 	mcall	80005a14 <xQueueGenericReceive+0x140>
800059d6:	c8 eb       	rjmp	800058f2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800059d8:	0e 9c       	mov	r12,r7
800059da:	f0 1f 00 0e 	mcall	80005a10 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800059de:	f0 1f 00 0e 	mcall	80005a14 <xQueueGenericReceive+0x140>
800059e2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800059e4:	2f bd       	sub	sp,-20
800059e6:	d8 32       	popm	r0-r7,pc
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	55 20       	stdsp	sp[0x148],r0
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	57 b4       	stdsp	sp[0x1ec],r4
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	5d 04       	ror	r4
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	5d ec       	*unknown*
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	56 2c       	stdsp	sp[0x188],r12
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	5c e0       	tnbz	r0
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	5c 54       	castu.b	r4
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	5f 7c       	srpl	r12
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	5d 68       	*unknown*
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	61 d4       	ld.w	r4,r0[0x74]
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	58 34       	cp.w	r4,3
80005a14:	80 00       	ld.sh	r0,r0[0x0]
80005a16:	60 10       	ld.w	r0,r0[0x4]

80005a18 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005a18:	eb cd 40 80 	pushm	r7,lr
80005a1c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005a1e:	79 08       	ld.w	r8,r12[0x40]
80005a20:	58 08       	cp.w	r8,0
80005a22:	c0 a1       	brne	80005a36 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005a24:	78 08       	ld.w	r8,r12[0x0]
80005a26:	58 08       	cp.w	r8,0
80005a28:	c2 b1       	brne	80005a7e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005a2a:	78 1c       	ld.w	r12,r12[0x4]
80005a2c:	f0 1f 00 17 	mcall	80005a88 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005a30:	30 08       	mov	r8,0
80005a32:	8f 18       	st.w	r7[0x4],r8
80005a34:	c2 58       	rjmp	80005a7e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005a36:	58 0a       	cp.w	r10,0
80005a38:	c1 01       	brne	80005a58 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005a3a:	10 9a       	mov	r10,r8
80005a3c:	78 2c       	ld.w	r12,r12[0x8]
80005a3e:	f0 1f 00 14 	mcall	80005a8c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005a42:	6e 29       	ld.w	r9,r7[0x8]
80005a44:	6f 08       	ld.w	r8,r7[0x40]
80005a46:	f2 08 00 08 	add	r8,r9,r8
80005a4a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005a4c:	6e 19       	ld.w	r9,r7[0x4]
80005a4e:	12 38       	cp.w	r8,r9
80005a50:	c1 73       	brcs	80005a7e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005a52:	6e 08       	ld.w	r8,r7[0x0]
80005a54:	8f 28       	st.w	r7[0x8],r8
80005a56:	c1 48       	rjmp	80005a7e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005a58:	10 9a       	mov	r10,r8
80005a5a:	78 3c       	ld.w	r12,r12[0xc]
80005a5c:	f0 1f 00 0c 	mcall	80005a8c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005a60:	6f 08       	ld.w	r8,r7[0x40]
80005a62:	6e 39       	ld.w	r9,r7[0xc]
80005a64:	f2 08 01 08 	sub	r8,r9,r8
80005a68:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005a6a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005a6c:	12 38       	cp.w	r8,r9
80005a6e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005a72:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005a76:	f3 d8 e3 19 	subcs	r9,r9,r8
80005a7a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005a7e:	6e e8       	ld.w	r8,r7[0x38]
80005a80:	2f f8       	sub	r8,-1
80005a82:	8f e8       	st.w	r7[0x38],r8
}
80005a84:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	5d 10       	icall	r0
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	70 0c       	ld.w	r12,r8[0x0]

80005a90 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005a90:	eb cd 40 c0 	pushm	r6-r7,lr
80005a94:	18 97       	mov	r7,r12
80005a96:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005a98:	78 ec       	ld.w	r12,r12[0x38]
80005a9a:	6e f8       	ld.w	r8,r7[0x3c]
80005a9c:	10 3c       	cp.w	r12,r8
80005a9e:	c0 33       	brcs	80005aa4 <xQueueGenericSendFromISR+0x14>
80005aa0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005aa4:	12 9a       	mov	r10,r9
80005aa6:	0e 9c       	mov	r12,r7
80005aa8:	f0 1f 00 0c 	mcall	80005ad8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005aac:	6f 28       	ld.w	r8,r7[0x48]
80005aae:	5b f8       	cp.w	r8,-1
80005ab0:	c0 d1       	brne	80005aca <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ab2:	6e 98       	ld.w	r8,r7[0x24]
80005ab4:	58 08       	cp.w	r8,0
80005ab6:	c0 f0       	breq	80005ad4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ab8:	ee cc ff dc 	sub	r12,r7,-36
80005abc:	f0 1f 00 08 	mcall	80005adc <xQueueGenericSendFromISR+0x4c>
80005ac0:	c0 a0       	breq	80005ad4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005ac2:	30 1c       	mov	r12,1
80005ac4:	8d 0c       	st.w	r6[0x0],r12
80005ac6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005aca:	2f f8       	sub	r8,-1
80005acc:	ef 48 00 48 	st.w	r7[72],r8
80005ad0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ad4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ad8:	80 00       	ld.sh	r0,r0[0x0]
80005ada:	5a 18       	cp.w	r8,-31
80005adc:	80 00       	ld.sh	r0,r0[0x0]
80005ade:	5d ec       	*unknown*

80005ae0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005ae0:	d4 31       	pushm	r0-r7,lr
80005ae2:	20 5d       	sub	sp,20
80005ae4:	18 97       	mov	r7,r12
80005ae6:	50 0b       	stdsp	sp[0x0],r11
80005ae8:	50 2a       	stdsp	sp[0x8],r10
80005aea:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005aec:	f8 c0 ff f0 	sub	r0,r12,-16
80005af0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005af2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005af6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005af8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005afc:	f0 1f 00 2f 	mcall	80005bb8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005b00:	6e e9       	ld.w	r9,r7[0x38]
80005b02:	6e f8       	ld.w	r8,r7[0x3c]
80005b04:	10 39       	cp.w	r9,r8
80005b06:	c1 42       	brcc	80005b2e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005b08:	40 1a       	lddsp	r10,sp[0x4]
80005b0a:	40 0b       	lddsp	r11,sp[0x0]
80005b0c:	0e 9c       	mov	r12,r7
80005b0e:	f0 1f 00 2c 	mcall	80005bbc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b12:	6e 98       	ld.w	r8,r7[0x24]
80005b14:	58 08       	cp.w	r8,0
80005b16:	c0 80       	breq	80005b26 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005b18:	ee cc ff dc 	sub	r12,r7,-36
80005b1c:	f0 1f 00 29 	mcall	80005bc0 <xQueueGenericSend+0xe0>
80005b20:	58 1c       	cp.w	r12,1
80005b22:	c0 21       	brne	80005b26 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005b24:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005b26:	f0 1f 00 28 	mcall	80005bc4 <xQueueGenericSend+0xe4>
80005b2a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005b2c:	c4 38       	rjmp	80005bb2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005b2e:	40 28       	lddsp	r8,sp[0x8]
80005b30:	58 08       	cp.w	r8,0
80005b32:	c0 51       	brne	80005b3c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005b34:	f0 1f 00 24 	mcall	80005bc4 <xQueueGenericSend+0xe4>
80005b38:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005b3a:	c3 c8       	rjmp	80005bb2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005b3c:	58 04       	cp.w	r4,0
80005b3e:	c0 51       	brne	80005b48 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005b40:	06 9c       	mov	r12,r3
80005b42:	f0 1f 00 22 	mcall	80005bc8 <xQueueGenericSend+0xe8>
80005b46:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005b48:	f0 1f 00 1f 	mcall	80005bc4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005b4c:	f0 1f 00 20 	mcall	80005bcc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005b50:	f0 1f 00 1a 	mcall	80005bb8 <xQueueGenericSend+0xd8>
80005b54:	6f 18       	ld.w	r8,r7[0x44]
80005b56:	5b f8       	cp.w	r8,-1
80005b58:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005b5c:	6f 28       	ld.w	r8,r7[0x48]
80005b5e:	5b f8       	cp.w	r8,-1
80005b60:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005b64:	f0 1f 00 18 	mcall	80005bc4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005b68:	04 9b       	mov	r11,r2
80005b6a:	06 9c       	mov	r12,r3
80005b6c:	f0 1f 00 19 	mcall	80005bd0 <xQueueGenericSend+0xf0>
80005b70:	c1 b1       	brne	80005ba6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005b72:	f0 1f 00 12 	mcall	80005bb8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005b76:	6e e5       	ld.w	r5,r7[0x38]
80005b78:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005b7a:	f0 1f 00 13 	mcall	80005bc4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005b7e:	0c 35       	cp.w	r5,r6
80005b80:	c0 d1       	brne	80005b9a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005b82:	40 2b       	lddsp	r11,sp[0x8]
80005b84:	00 9c       	mov	r12,r0
80005b86:	f0 1f 00 14 	mcall	80005bd4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005b8a:	0e 9c       	mov	r12,r7
80005b8c:	f0 1f 00 13 	mcall	80005bd8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005b90:	f0 1f 00 13 	mcall	80005bdc <xQueueGenericSend+0xfc>
80005b94:	cb 41       	brne	80005afc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005b96:	d7 33       	scall
80005b98:	cb 2b       	rjmp	80005afc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005b9a:	0e 9c       	mov	r12,r7
80005b9c:	f0 1f 00 0f 	mcall	80005bd8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005ba0:	f0 1f 00 0f 	mcall	80005bdc <xQueueGenericSend+0xfc>
80005ba4:	ca cb       	rjmp	80005afc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005ba6:	0e 9c       	mov	r12,r7
80005ba8:	f0 1f 00 0c 	mcall	80005bd8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005bac:	f0 1f 00 0c 	mcall	80005bdc <xQueueGenericSend+0xfc>
80005bb0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005bb2:	2f bd       	sub	sp,-20
80005bb4:	d8 32       	popm	r0-r7,pc
80005bb6:	00 00       	add	r0,r0
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	55 20       	stdsp	sp[0x148],r0
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	5a 18       	cp.w	r8,-31
80005bc0:	80 00       	ld.sh	r0,r0[0x0]
80005bc2:	5d ec       	*unknown*
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	56 2c       	stdsp	sp[0x188],r12
80005bc8:	80 00       	ld.sh	r0,r0[0x0]
80005bca:	5c e0       	tnbz	r0
80005bcc:	80 00       	ld.sh	r0,r0[0x0]
80005bce:	5c 54       	castu.b	r4
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	5f 7c       	srpl	r12
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	61 d4       	ld.w	r4,r0[0x74]
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	58 34       	cp.w	r4,3
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	60 10       	ld.w	r0,r0[0x4]

80005be0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005be0:	d4 21       	pushm	r4-r7,lr
80005be2:	18 97       	mov	r7,r12
80005be4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005be6:	58 0c       	cp.w	r12,0
80005be8:	c2 f0       	breq	80005c46 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005bea:	34 cc       	mov	r12,76
80005bec:	f0 1f 00 17 	mcall	80005c48 <xQueueCreate+0x68>
80005bf0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005bf2:	c2 a0       	breq	80005c46 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005bf4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005bf8:	e8 cc ff ff 	sub	r12,r4,-1
80005bfc:	f0 1f 00 13 	mcall	80005c48 <xQueueCreate+0x68>
80005c00:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005c02:	c1 e0       	breq	80005c3e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005c04:	f8 04 00 04 	add	r4,r12,r4
80005c08:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005c0a:	30 08       	mov	r8,0
80005c0c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005c0e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005c10:	ee c8 00 01 	sub	r8,r7,1
80005c14:	ad 38       	mul	r8,r6
80005c16:	10 0c       	add	r12,r8
80005c18:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005c1a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005c1c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005c20:	3f f8       	mov	r8,-1
80005c22:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005c26:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005c2a:	ea cc ff f0 	sub	r12,r5,-16
80005c2e:	f0 1f 00 08 	mcall	80005c4c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005c32:	ea cc ff dc 	sub	r12,r5,-36
80005c36:	f0 1f 00 06 	mcall	80005c4c <xQueueCreate+0x6c>
80005c3a:	0a 9c       	mov	r12,r5
80005c3c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005c3e:	0a 9c       	mov	r12,r5
80005c40:	f0 1f 00 04 	mcall	80005c50 <xQueueCreate+0x70>
80005c44:	d8 2a       	popm	r4-r7,pc,r12=0
80005c46:	d8 2a       	popm	r4-r7,pc,r12=0
80005c48:	80 00       	ld.sh	r0,r0[0x0]
80005c4a:	57 8c       	stdsp	sp[0x1e0],r12
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	53 fc       	stdsp	sp[0xfc],r12
80005c50:	80 00       	ld.sh	r0,r0[0x0]
80005c52:	57 64       	stdsp	sp[0x1d8],r4

80005c54 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005c54:	48 38       	lddpc	r8,80005c60 <vTaskSuspendAll+0xc>
80005c56:	70 09       	ld.w	r9,r8[0x0]
80005c58:	2f f9       	sub	r9,-1
80005c5a:	91 09       	st.w	r8[0x0],r9
}
80005c5c:	5e fc       	retal	r12
80005c5e:	00 00       	add	r0,r0
80005c60:	00 00       	add	r0,r0
80005c62:	0d 10       	ld.sh	r0,r6++

80005c64 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005c64:	49 a8       	lddpc	r8,80005ccc <vTaskSwitchContext+0x68>
80005c66:	70 08       	ld.w	r8,r8[0x0]
80005c68:	58 08       	cp.w	r8,0
80005c6a:	c0 b1       	brne	80005c80 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005c6c:	49 98       	lddpc	r8,80005cd0 <vTaskSwitchContext+0x6c>
80005c6e:	70 08       	ld.w	r8,r8[0x0]
80005c70:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005c74:	49 89       	lddpc	r9,80005cd4 <vTaskSwitchContext+0x70>
80005c76:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005c7a:	58 08       	cp.w	r8,0
80005c7c:	c0 60       	breq	80005c88 <vTaskSwitchContext+0x24>
80005c7e:	c1 18       	rjmp	80005ca0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005c80:	30 19       	mov	r9,1
80005c82:	49 68       	lddpc	r8,80005cd8 <vTaskSwitchContext+0x74>
80005c84:	91 09       	st.w	r8[0x0],r9
80005c86:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005c88:	49 28       	lddpc	r8,80005cd0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005c8a:	49 3a       	lddpc	r10,80005cd4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005c8c:	70 09       	ld.w	r9,r8[0x0]
80005c8e:	20 19       	sub	r9,1
80005c90:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005c92:	70 09       	ld.w	r9,r8[0x0]
80005c94:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005c98:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005c9c:	58 09       	cp.w	r9,0
80005c9e:	cf 70       	breq	80005c8c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005ca0:	48 c8       	lddpc	r8,80005cd0 <vTaskSwitchContext+0x6c>
80005ca2:	70 08       	ld.w	r8,r8[0x0]
80005ca4:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005ca8:	48 b9       	lddpc	r9,80005cd4 <vTaskSwitchContext+0x70>
80005caa:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005cae:	70 19       	ld.w	r9,r8[0x4]
80005cb0:	72 19       	ld.w	r9,r9[0x4]
80005cb2:	91 19       	st.w	r8[0x4],r9
80005cb4:	f0 ca ff f8 	sub	r10,r8,-8
80005cb8:	14 39       	cp.w	r9,r10
80005cba:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005cbe:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005cc2:	70 18       	ld.w	r8,r8[0x4]
80005cc4:	70 39       	ld.w	r9,r8[0xc]
80005cc6:	48 68       	lddpc	r8,80005cdc <vTaskSwitchContext+0x78>
80005cc8:	91 09       	st.w	r8[0x0],r9
80005cca:	5e fc       	retal	r12
80005ccc:	00 00       	add	r0,r0
80005cce:	0d 10       	ld.sh	r0,r6++
80005cd0:	00 00       	add	r0,r0
80005cd2:	0d 48       	ld.w	r8,--r6
80005cd4:	00 00       	add	r0,r0
80005cd6:	0c 2c       	rsub	r12,r6
80005cd8:	00 00       	add	r0,r0
80005cda:	0d 30       	ld.ub	r0,r6++
80005cdc:	00 00       	add	r0,r0
80005cde:	0c e0       	st.h	--r6,r0

80005ce0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005ce0:	48 48       	lddpc	r8,80005cf0 <vTaskSetTimeOutState+0x10>
80005ce2:	70 08       	ld.w	r8,r8[0x0]
80005ce4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005ce6:	48 48       	lddpc	r8,80005cf4 <vTaskSetTimeOutState+0x14>
80005ce8:	70 08       	ld.w	r8,r8[0x0]
80005cea:	99 18       	st.w	r12[0x4],r8
}
80005cec:	5e fc       	retal	r12
80005cee:	00 00       	add	r0,r0
80005cf0:	00 00       	add	r0,r0
80005cf2:	0c 24       	rsub	r4,r6
80005cf4:	00 00       	add	r0,r0
80005cf6:	0d 0c       	ld.w	r12,r6++

80005cf8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005cf8:	30 19       	mov	r9,1
80005cfa:	48 28       	lddpc	r8,80005d00 <vTaskMissedYield+0x8>
80005cfc:	91 09       	st.w	r8[0x0],r9
}
80005cfe:	5e fc       	retal	r12
80005d00:	00 00       	add	r0,r0
80005d02:	0d 30       	ld.ub	r0,r6++

80005d04 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005d04:	48 28       	lddpc	r8,80005d0c <xTaskGetCurrentTaskHandle+0x8>
80005d06:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005d08:	5e fc       	retal	r12
80005d0a:	00 00       	add	r0,r0
80005d0c:	00 00       	add	r0,r0
80005d0e:	0c e0       	st.h	--r6,r0

80005d10 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005d10:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005d14:	58 0c       	cp.w	r12,0
80005d16:	c1 f0       	breq	80005d54 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005d18:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005d1a:	78 b9       	ld.w	r9,r12[0x2c]
80005d1c:	79 18       	ld.w	r8,r12[0x44]
80005d1e:	10 39       	cp.w	r9,r8
80005d20:	c1 a0       	breq	80005d54 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005d22:	f8 c6 ff fc 	sub	r6,r12,-4
80005d26:	0c 9c       	mov	r12,r6
80005d28:	f0 1f 00 0c 	mcall	80005d58 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005d2c:	6f 1c       	ld.w	r12,r7[0x44]
80005d2e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005d30:	f8 08 11 08 	rsub	r8,r12,8
80005d34:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005d36:	48 a8       	lddpc	r8,80005d5c <vTaskPriorityDisinherit+0x4c>
80005d38:	70 08       	ld.w	r8,r8[0x0]
80005d3a:	10 3c       	cp.w	r12,r8
80005d3c:	e0 88 00 04 	brls	80005d44 <vTaskPriorityDisinherit+0x34>
80005d40:	48 78       	lddpc	r8,80005d5c <vTaskPriorityDisinherit+0x4c>
80005d42:	91 0c       	st.w	r8[0x0],r12
80005d44:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d48:	0c 9b       	mov	r11,r6
80005d4a:	48 68       	lddpc	r8,80005d60 <vTaskPriorityDisinherit+0x50>
80005d4c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005d50:	f0 1f 00 05 	mcall	80005d64 <vTaskPriorityDisinherit+0x54>
80005d54:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	54 66       	stdsp	sp[0x118],r6
80005d5c:	00 00       	add	r0,r0
80005d5e:	0d 48       	ld.w	r8,--r6
80005d60:	00 00       	add	r0,r0
80005d62:	0c 2c       	rsub	r12,r6
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	54 16       	stdsp	sp[0x104],r6

80005d68 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005d68:	eb cd 40 c0 	pushm	r6-r7,lr
80005d6c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005d6e:	49 b8       	lddpc	r8,80005dd8 <vTaskPriorityInherit+0x70>
80005d70:	70 08       	ld.w	r8,r8[0x0]
80005d72:	78 b9       	ld.w	r9,r12[0x2c]
80005d74:	70 b8       	ld.w	r8,r8[0x2c]
80005d76:	10 39       	cp.w	r9,r8
80005d78:	c2 d2       	brcc	80005dd2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005d7a:	49 88       	lddpc	r8,80005dd8 <vTaskPriorityInherit+0x70>
80005d7c:	70 08       	ld.w	r8,r8[0x0]
80005d7e:	70 b8       	ld.w	r8,r8[0x2c]
80005d80:	f0 08 11 08 	rsub	r8,r8,8
80005d84:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005d86:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005d8a:	49 59       	lddpc	r9,80005ddc <vTaskPriorityInherit+0x74>
80005d8c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005d90:	78 59       	ld.w	r9,r12[0x14]
80005d92:	10 39       	cp.w	r9,r8
80005d94:	c1 b1       	brne	80005dca <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005d96:	f8 c6 ff fc 	sub	r6,r12,-4
80005d9a:	0c 9c       	mov	r12,r6
80005d9c:	f0 1f 00 11 	mcall	80005de0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005da0:	48 e8       	lddpc	r8,80005dd8 <vTaskPriorityInherit+0x70>
80005da2:	70 08       	ld.w	r8,r8[0x0]
80005da4:	70 bc       	ld.w	r12,r8[0x2c]
80005da6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005da8:	48 f8       	lddpc	r8,80005de4 <vTaskPriorityInherit+0x7c>
80005daa:	70 08       	ld.w	r8,r8[0x0]
80005dac:	10 3c       	cp.w	r12,r8
80005dae:	e0 88 00 04 	brls	80005db6 <vTaskPriorityInherit+0x4e>
80005db2:	48 d8       	lddpc	r8,80005de4 <vTaskPriorityInherit+0x7c>
80005db4:	91 0c       	st.w	r8[0x0],r12
80005db6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005dba:	0c 9b       	mov	r11,r6
80005dbc:	48 88       	lddpc	r8,80005ddc <vTaskPriorityInherit+0x74>
80005dbe:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005dc2:	f0 1f 00 0a 	mcall	80005de8 <vTaskPriorityInherit+0x80>
80005dc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005dca:	48 48       	lddpc	r8,80005dd8 <vTaskPriorityInherit+0x70>
80005dcc:	70 08       	ld.w	r8,r8[0x0]
80005dce:	70 b8       	ld.w	r8,r8[0x2c]
80005dd0:	99 b8       	st.w	r12[0x2c],r8
80005dd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005dd6:	00 00       	add	r0,r0
80005dd8:	00 00       	add	r0,r0
80005dda:	0c e0       	st.h	--r6,r0
80005ddc:	00 00       	add	r0,r0
80005dde:	0c 2c       	rsub	r12,r6
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	54 66       	stdsp	sp[0x118],r6
80005de4:	00 00       	add	r0,r0
80005de6:	0d 48       	ld.w	r8,--r6
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	54 16       	stdsp	sp[0x104],r6

80005dec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005dec:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005df0:	78 38       	ld.w	r8,r12[0xc]
80005df2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005df4:	ee c6 ff e8 	sub	r6,r7,-24
80005df8:	0c 9c       	mov	r12,r6
80005dfa:	f0 1f 00 15 	mcall	80005e4c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005dfe:	49 58       	lddpc	r8,80005e50 <xTaskRemoveFromEventList+0x64>
80005e00:	70 08       	ld.w	r8,r8[0x0]
80005e02:	58 08       	cp.w	r8,0
80005e04:	c1 71       	brne	80005e32 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005e06:	ee c6 ff fc 	sub	r6,r7,-4
80005e0a:	0c 9c       	mov	r12,r6
80005e0c:	f0 1f 00 10 	mcall	80005e4c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005e10:	6e bc       	ld.w	r12,r7[0x2c]
80005e12:	49 18       	lddpc	r8,80005e54 <xTaskRemoveFromEventList+0x68>
80005e14:	70 08       	ld.w	r8,r8[0x0]
80005e16:	10 3c       	cp.w	r12,r8
80005e18:	e0 88 00 04 	brls	80005e20 <xTaskRemoveFromEventList+0x34>
80005e1c:	48 e8       	lddpc	r8,80005e54 <xTaskRemoveFromEventList+0x68>
80005e1e:	91 0c       	st.w	r8[0x0],r12
80005e20:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e24:	0c 9b       	mov	r11,r6
80005e26:	48 d8       	lddpc	r8,80005e58 <xTaskRemoveFromEventList+0x6c>
80005e28:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e2c:	f0 1f 00 0c 	mcall	80005e5c <xTaskRemoveFromEventList+0x70>
80005e30:	c0 58       	rjmp	80005e3a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005e32:	0c 9b       	mov	r11,r6
80005e34:	48 bc       	lddpc	r12,80005e60 <xTaskRemoveFromEventList+0x74>
80005e36:	f0 1f 00 0a 	mcall	80005e5c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e3a:	48 b8       	lddpc	r8,80005e64 <xTaskRemoveFromEventList+0x78>
80005e3c:	70 08       	ld.w	r8,r8[0x0]
80005e3e:	6e b9       	ld.w	r9,r7[0x2c]
80005e40:	70 b8       	ld.w	r8,r8[0x2c]
80005e42:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005e44:	5f 2c       	srhs	r12
80005e46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e4a:	00 00       	add	r0,r0
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	54 66       	stdsp	sp[0x118],r6
80005e50:	00 00       	add	r0,r0
80005e52:	0d 10       	ld.sh	r0,r6++
80005e54:	00 00       	add	r0,r0
80005e56:	0d 48       	ld.w	r8,--r6
80005e58:	00 00       	add	r0,r0
80005e5a:	0c 2c       	rsub	r12,r6
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	54 16       	stdsp	sp[0x104],r6
80005e60:	00 00       	add	r0,r0
80005e62:	0c e4       	st.h	--r6,r4
80005e64:	00 00       	add	r0,r0
80005e66:	0c e0       	st.h	--r6,r0

80005e68 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005e68:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005e6c:	4b 98       	lddpc	r8,80005f50 <vTaskIncrementTick+0xe8>
80005e6e:	70 08       	ld.w	r8,r8[0x0]
80005e70:	58 08       	cp.w	r8,0
80005e72:	c6 91       	brne	80005f44 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005e74:	4b 88       	lddpc	r8,80005f54 <vTaskIncrementTick+0xec>
80005e76:	70 09       	ld.w	r9,r8[0x0]
80005e78:	2f f9       	sub	r9,-1
80005e7a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005e7c:	70 08       	ld.w	r8,r8[0x0]
80005e7e:	58 08       	cp.w	r8,0
80005e80:	c1 a1       	brne	80005eb4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005e82:	4b 68       	lddpc	r8,80005f58 <vTaskIncrementTick+0xf0>
80005e84:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005e86:	4b 69       	lddpc	r9,80005f5c <vTaskIncrementTick+0xf4>
80005e88:	72 0b       	ld.w	r11,r9[0x0]
80005e8a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005e8c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005e8e:	4b 59       	lddpc	r9,80005f60 <vTaskIncrementTick+0xf8>
80005e90:	72 0a       	ld.w	r10,r9[0x0]
80005e92:	2f fa       	sub	r10,-1
80005e94:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005e96:	70 08       	ld.w	r8,r8[0x0]
80005e98:	70 08       	ld.w	r8,r8[0x0]
80005e9a:	58 08       	cp.w	r8,0
80005e9c:	c0 51       	brne	80005ea6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005e9e:	3f f9       	mov	r9,-1
80005ea0:	4b 18       	lddpc	r8,80005f64 <vTaskIncrementTick+0xfc>
80005ea2:	91 09       	st.w	r8[0x0],r9
80005ea4:	c0 88       	rjmp	80005eb4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005ea6:	4a d8       	lddpc	r8,80005f58 <vTaskIncrementTick+0xf0>
80005ea8:	70 08       	ld.w	r8,r8[0x0]
80005eaa:	70 38       	ld.w	r8,r8[0xc]
80005eac:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005eae:	70 19       	ld.w	r9,r8[0x4]
80005eb0:	4a d8       	lddpc	r8,80005f64 <vTaskIncrementTick+0xfc>
80005eb2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005eb4:	4a 88       	lddpc	r8,80005f54 <vTaskIncrementTick+0xec>
80005eb6:	70 09       	ld.w	r9,r8[0x0]
80005eb8:	4a b8       	lddpc	r8,80005f64 <vTaskIncrementTick+0xfc>
80005eba:	70 08       	ld.w	r8,r8[0x0]
80005ebc:	10 39       	cp.w	r9,r8
80005ebe:	c4 73       	brcs	80005f4c <vTaskIncrementTick+0xe4>
80005ec0:	4a 68       	lddpc	r8,80005f58 <vTaskIncrementTick+0xf0>
80005ec2:	70 08       	ld.w	r8,r8[0x0]
80005ec4:	70 08       	ld.w	r8,r8[0x0]
80005ec6:	58 08       	cp.w	r8,0
80005ec8:	c0 c0       	breq	80005ee0 <vTaskIncrementTick+0x78>
80005eca:	4a 48       	lddpc	r8,80005f58 <vTaskIncrementTick+0xf0>
80005ecc:	70 08       	ld.w	r8,r8[0x0]
80005ece:	70 38       	ld.w	r8,r8[0xc]
80005ed0:	70 37       	ld.w	r7,r8[0xc]
80005ed2:	6e 18       	ld.w	r8,r7[0x4]
80005ed4:	4a 09       	lddpc	r9,80005f54 <vTaskIncrementTick+0xec>
80005ed6:	72 09       	ld.w	r9,r9[0x0]
80005ed8:	12 38       	cp.w	r8,r9
80005eda:	e0 88 00 14 	brls	80005f02 <vTaskIncrementTick+0x9a>
80005ede:	c0 e8       	rjmp	80005efa <vTaskIncrementTick+0x92>
80005ee0:	3f f9       	mov	r9,-1
80005ee2:	4a 18       	lddpc	r8,80005f64 <vTaskIncrementTick+0xfc>
80005ee4:	91 09       	st.w	r8[0x0],r9
80005ee6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005eea:	6a 08       	ld.w	r8,r5[0x0]
80005eec:	70 38       	ld.w	r8,r8[0xc]
80005eee:	70 37       	ld.w	r7,r8[0xc]
80005ef0:	6e 18       	ld.w	r8,r7[0x4]
80005ef2:	64 09       	ld.w	r9,r2[0x0]
80005ef4:	12 38       	cp.w	r8,r9
80005ef6:	e0 88 00 0a 	brls	80005f0a <vTaskIncrementTick+0xa2>
80005efa:	49 b9       	lddpc	r9,80005f64 <vTaskIncrementTick+0xfc>
80005efc:	93 08       	st.w	r9[0x0],r8
80005efe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f02:	49 a4       	lddpc	r4,80005f68 <vTaskIncrementTick+0x100>
80005f04:	49 a3       	lddpc	r3,80005f6c <vTaskIncrementTick+0x104>
80005f06:	49 55       	lddpc	r5,80005f58 <vTaskIncrementTick+0xf0>
80005f08:	49 32       	lddpc	r2,80005f54 <vTaskIncrementTick+0xec>
80005f0a:	ee c6 ff fc 	sub	r6,r7,-4
80005f0e:	0c 9c       	mov	r12,r6
80005f10:	f0 1f 00 18 	mcall	80005f70 <vTaskIncrementTick+0x108>
80005f14:	6e a8       	ld.w	r8,r7[0x28]
80005f16:	58 08       	cp.w	r8,0
80005f18:	c0 50       	breq	80005f22 <vTaskIncrementTick+0xba>
80005f1a:	ee cc ff e8 	sub	r12,r7,-24
80005f1e:	f0 1f 00 15 	mcall	80005f70 <vTaskIncrementTick+0x108>
80005f22:	6e bc       	ld.w	r12,r7[0x2c]
80005f24:	68 08       	ld.w	r8,r4[0x0]
80005f26:	10 3c       	cp.w	r12,r8
80005f28:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005f2c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f30:	0c 9b       	mov	r11,r6
80005f32:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005f36:	f0 1f 00 10 	mcall	80005f74 <vTaskIncrementTick+0x10c>
80005f3a:	6a 08       	ld.w	r8,r5[0x0]
80005f3c:	70 08       	ld.w	r8,r8[0x0]
80005f3e:	58 08       	cp.w	r8,0
80005f40:	cd 51       	brne	80005eea <vTaskIncrementTick+0x82>
80005f42:	cc fb       	rjmp	80005ee0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005f44:	48 d8       	lddpc	r8,80005f78 <vTaskIncrementTick+0x110>
80005f46:	70 09       	ld.w	r9,r8[0x0]
80005f48:	2f f9       	sub	r9,-1
80005f4a:	91 09       	st.w	r8[0x0],r9
80005f4c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f50:	00 00       	add	r0,r0
80005f52:	0d 10       	ld.sh	r0,r6++
80005f54:	00 00       	add	r0,r0
80005f56:	0d 0c       	ld.w	r12,r6++
80005f58:	00 00       	add	r0,r0
80005f5a:	0c 18       	sub	r8,r6
80005f5c:	00 00       	add	r0,r0
80005f5e:	0c 28       	rsub	r8,r6
80005f60:	00 00       	add	r0,r0
80005f62:	0c 24       	rsub	r4,r6
80005f64:	00 00       	add	r0,r0
80005f66:	05 40       	ld.w	r0,--r2
80005f68:	00 00       	add	r0,r0
80005f6a:	0d 48       	ld.w	r8,--r6
80005f6c:	00 00       	add	r0,r0
80005f6e:	0c 2c       	rsub	r12,r6
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	54 66       	stdsp	sp[0x118],r6
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	54 16       	stdsp	sp[0x104],r6
80005f78:	00 00       	add	r0,r0
80005f7a:	0c 10       	sub	r0,r6

80005f7c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005f7c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f80:	18 97       	mov	r7,r12
80005f82:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005f84:	f0 1f 00 15 	mcall	80005fd8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005f88:	6c 08       	ld.w	r8,r6[0x0]
80005f8a:	5b f8       	cp.w	r8,-1
80005f8c:	c0 31       	brne	80005f92 <xTaskCheckForTimeOut+0x16>
80005f8e:	30 07       	mov	r7,0
80005f90:	c1 f8       	rjmp	80005fce <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005f92:	49 39       	lddpc	r9,80005fdc <xTaskCheckForTimeOut+0x60>
80005f94:	72 09       	ld.w	r9,r9[0x0]
80005f96:	6e 0a       	ld.w	r10,r7[0x0]
80005f98:	12 3a       	cp.w	r10,r9
80005f9a:	c0 70       	breq	80005fa8 <xTaskCheckForTimeOut+0x2c>
80005f9c:	49 19       	lddpc	r9,80005fe0 <xTaskCheckForTimeOut+0x64>
80005f9e:	72 09       	ld.w	r9,r9[0x0]
80005fa0:	6e 1a       	ld.w	r10,r7[0x4]
80005fa2:	12 3a       	cp.w	r10,r9
80005fa4:	e0 88 00 14 	brls	80005fcc <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005fa8:	48 e9       	lddpc	r9,80005fe0 <xTaskCheckForTimeOut+0x64>
80005faa:	72 0a       	ld.w	r10,r9[0x0]
80005fac:	6e 19       	ld.w	r9,r7[0x4]
80005fae:	12 1a       	sub	r10,r9
80005fb0:	14 38       	cp.w	r8,r10
80005fb2:	e0 88 00 0d 	brls	80005fcc <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005fb6:	48 ba       	lddpc	r10,80005fe0 <xTaskCheckForTimeOut+0x64>
80005fb8:	74 0a       	ld.w	r10,r10[0x0]
80005fba:	14 19       	sub	r9,r10
80005fbc:	f2 08 00 08 	add	r8,r9,r8
80005fc0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005fc2:	0e 9c       	mov	r12,r7
80005fc4:	f0 1f 00 08 	mcall	80005fe4 <xTaskCheckForTimeOut+0x68>
80005fc8:	30 07       	mov	r7,0
80005fca:	c0 28       	rjmp	80005fce <xTaskCheckForTimeOut+0x52>
80005fcc:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005fce:	f0 1f 00 07 	mcall	80005fe8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005fd2:	0e 9c       	mov	r12,r7
80005fd4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	55 20       	stdsp	sp[0x148],r0
80005fdc:	00 00       	add	r0,r0
80005fde:	0c 24       	rsub	r4,r6
80005fe0:	00 00       	add	r0,r0
80005fe2:	0d 0c       	ld.w	r12,r6++
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	5c e0       	tnbz	r0
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	56 2c       	stdsp	sp[0x188],r12

80005fec <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005fec:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005ff0:	f0 1f 00 05 	mcall	80006004 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005ff4:	48 58       	lddpc	r8,80006008 <xTaskGetTickCount+0x1c>
80005ff6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005ff8:	f0 1f 00 05 	mcall	8000600c <xTaskGetTickCount+0x20>

	return xTicks;
}
80005ffc:	0e 9c       	mov	r12,r7
80005ffe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006002:	00 00       	add	r0,r0
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	55 20       	stdsp	sp[0x148],r0
80006008:	00 00       	add	r0,r0
8000600a:	0d 0c       	ld.w	r12,r6++
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	56 2c       	stdsp	sp[0x188],r12

80006010 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006010:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006014:	f0 1f 00 2c 	mcall	800060c4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006018:	4a c8       	lddpc	r8,800060c8 <xTaskResumeAll+0xb8>
8000601a:	70 09       	ld.w	r9,r8[0x0]
8000601c:	20 19       	sub	r9,1
8000601e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006020:	70 08       	ld.w	r8,r8[0x0]
80006022:	58 08       	cp.w	r8,0
80006024:	c4 91       	brne	800060b6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006026:	4a a8       	lddpc	r8,800060cc <xTaskResumeAll+0xbc>
80006028:	70 08       	ld.w	r8,r8[0x0]
8000602a:	58 08       	cp.w	r8,0
8000602c:	c4 50       	breq	800060b6 <xTaskResumeAll+0xa6>
8000602e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006030:	4a 85       	lddpc	r5,800060d0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006032:	4a 93       	lddpc	r3,800060d4 <xTaskResumeAll+0xc4>
80006034:	4a 92       	lddpc	r2,800060d8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006036:	4a a1       	lddpc	r1,800060dc <xTaskResumeAll+0xcc>
80006038:	c1 e8       	rjmp	80006074 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000603a:	6a 38       	ld.w	r8,r5[0xc]
8000603c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000603e:	ee cc ff e8 	sub	r12,r7,-24
80006042:	f0 1f 00 28 	mcall	800060e0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006046:	ee c6 ff fc 	sub	r6,r7,-4
8000604a:	0c 9c       	mov	r12,r6
8000604c:	f0 1f 00 25 	mcall	800060e0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006050:	6e bc       	ld.w	r12,r7[0x2c]
80006052:	66 08       	ld.w	r8,r3[0x0]
80006054:	10 3c       	cp.w	r12,r8
80006056:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000605a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000605e:	0c 9b       	mov	r11,r6
80006060:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006064:	f0 1f 00 20 	mcall	800060e4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006068:	62 08       	ld.w	r8,r1[0x0]
8000606a:	6e b9       	ld.w	r9,r7[0x2c]
8000606c:	70 b8       	ld.w	r8,r8[0x2c]
8000606e:	10 39       	cp.w	r9,r8
80006070:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006074:	6a 08       	ld.w	r8,r5[0x0]
80006076:	58 08       	cp.w	r8,0
80006078:	ce 11       	brne	8000603a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000607a:	49 c8       	lddpc	r8,800060e8 <xTaskResumeAll+0xd8>
8000607c:	70 08       	ld.w	r8,r8[0x0]
8000607e:	58 08       	cp.w	r8,0
80006080:	c0 f0       	breq	8000609e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006082:	49 a8       	lddpc	r8,800060e8 <xTaskResumeAll+0xd8>
80006084:	70 08       	ld.w	r8,r8[0x0]
80006086:	58 08       	cp.w	r8,0
80006088:	c1 10       	breq	800060aa <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000608a:	49 87       	lddpc	r7,800060e8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000608c:	f0 1f 00 18 	mcall	800060ec <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006090:	6e 08       	ld.w	r8,r7[0x0]
80006092:	20 18       	sub	r8,1
80006094:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006096:	6e 08       	ld.w	r8,r7[0x0]
80006098:	58 08       	cp.w	r8,0
8000609a:	cf 91       	brne	8000608c <xTaskResumeAll+0x7c>
8000609c:	c0 78       	rjmp	800060aa <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000609e:	58 14       	cp.w	r4,1
800060a0:	c0 50       	breq	800060aa <xTaskResumeAll+0x9a>
800060a2:	49 48       	lddpc	r8,800060f0 <xTaskResumeAll+0xe0>
800060a4:	70 08       	ld.w	r8,r8[0x0]
800060a6:	58 18       	cp.w	r8,1
800060a8:	c0 71       	brne	800060b6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800060aa:	30 09       	mov	r9,0
800060ac:	49 18       	lddpc	r8,800060f0 <xTaskResumeAll+0xe0>
800060ae:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800060b0:	d7 33       	scall
800060b2:	30 17       	mov	r7,1
800060b4:	c0 28       	rjmp	800060b8 <xTaskResumeAll+0xa8>
800060b6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800060b8:	f0 1f 00 0f 	mcall	800060f4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800060bc:	0e 9c       	mov	r12,r7
800060be:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800060c2:	00 00       	add	r0,r0
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	55 20       	stdsp	sp[0x148],r0
800060c8:	00 00       	add	r0,r0
800060ca:	0d 10       	ld.sh	r0,r6++
800060cc:	00 00       	add	r0,r0
800060ce:	0d 2c       	ld.uh	r12,r6++
800060d0:	00 00       	add	r0,r0
800060d2:	0c e4       	st.h	--r6,r4
800060d4:	00 00       	add	r0,r0
800060d6:	0d 48       	ld.w	r8,--r6
800060d8:	00 00       	add	r0,r0
800060da:	0c 2c       	rsub	r12,r6
800060dc:	00 00       	add	r0,r0
800060de:	0c e0       	st.h	--r6,r0
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	54 66       	stdsp	sp[0x118],r6
800060e4:	80 00       	ld.sh	r0,r0[0x0]
800060e6:	54 16       	stdsp	sp[0x104],r6
800060e8:	00 00       	add	r0,r0
800060ea:	0c 10       	sub	r0,r6
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	5e 68       	retmi	r8
800060f0:	00 00       	add	r0,r0
800060f2:	0d 30       	ld.ub	r0,r6++
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	56 2c       	stdsp	sp[0x188],r12

800060f8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800060f8:	eb cd 40 80 	pushm	r7,lr
800060fc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800060fe:	49 08       	lddpc	r8,8000613c <prvAddCurrentTaskToDelayedList+0x44>
80006100:	70 08       	ld.w	r8,r8[0x0]
80006102:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006104:	48 f8       	lddpc	r8,80006140 <prvAddCurrentTaskToDelayedList+0x48>
80006106:	70 08       	ld.w	r8,r8[0x0]
80006108:	10 3c       	cp.w	r12,r8
8000610a:	c0 a2       	brcc	8000611e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000610c:	48 c8       	lddpc	r8,8000613c <prvAddCurrentTaskToDelayedList+0x44>
8000610e:	70 0b       	ld.w	r11,r8[0x0]
80006110:	48 d8       	lddpc	r8,80006144 <prvAddCurrentTaskToDelayedList+0x4c>
80006112:	70 0c       	ld.w	r12,r8[0x0]
80006114:	2f cb       	sub	r11,-4
80006116:	f0 1f 00 0d 	mcall	80006148 <prvAddCurrentTaskToDelayedList+0x50>
8000611a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000611e:	48 88       	lddpc	r8,8000613c <prvAddCurrentTaskToDelayedList+0x44>
80006120:	70 0b       	ld.w	r11,r8[0x0]
80006122:	48 b8       	lddpc	r8,8000614c <prvAddCurrentTaskToDelayedList+0x54>
80006124:	70 0c       	ld.w	r12,r8[0x0]
80006126:	2f cb       	sub	r11,-4
80006128:	f0 1f 00 08 	mcall	80006148 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000612c:	48 98       	lddpc	r8,80006150 <prvAddCurrentTaskToDelayedList+0x58>
8000612e:	70 08       	ld.w	r8,r8[0x0]
80006130:	10 37       	cp.w	r7,r8
80006132:	c0 32       	brcc	80006138 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006134:	48 78       	lddpc	r8,80006150 <prvAddCurrentTaskToDelayedList+0x58>
80006136:	91 07       	st.w	r8[0x0],r7
80006138:	e3 cd 80 80 	ldm	sp++,r7,pc
8000613c:	00 00       	add	r0,r0
8000613e:	0c e0       	st.h	--r6,r0
80006140:	00 00       	add	r0,r0
80006142:	0d 0c       	ld.w	r12,r6++
80006144:	00 00       	add	r0,r0
80006146:	0c 28       	rsub	r8,r6
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	54 32       	stdsp	sp[0x10c],r2
8000614c:	00 00       	add	r0,r0
8000614e:	0c 18       	sub	r8,r6
80006150:	00 00       	add	r0,r0
80006152:	05 40       	ld.w	r0,--r2

80006154 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006154:	eb cd 40 c0 	pushm	r6-r7,lr
80006158:	18 96       	mov	r6,r12
8000615a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000615c:	f0 1f 00 18 	mcall	800061bc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006160:	6c 08       	ld.w	r8,r6[0x0]
80006162:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006164:	49 79       	lddpc	r9,800061c0 <vTaskDelayUntil+0x6c>
80006166:	72 09       	ld.w	r9,r9[0x0]
80006168:	12 38       	cp.w	r8,r9
8000616a:	e0 88 00 0c 	brls	80006182 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000616e:	0e 38       	cp.w	r8,r7
80006170:	e0 88 00 22 	brls	800061b4 <vTaskDelayUntil+0x60>
80006174:	49 38       	lddpc	r8,800061c0 <vTaskDelayUntil+0x6c>
80006176:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006178:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000617a:	10 37       	cp.w	r7,r8
8000617c:	e0 88 00 14 	brls	800061a4 <vTaskDelayUntil+0x50>
80006180:	c0 a8       	rjmp	80006194 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006182:	0e 38       	cp.w	r8,r7
80006184:	e0 8b 00 16 	brhi	800061b0 <vTaskDelayUntil+0x5c>
80006188:	48 e8       	lddpc	r8,800061c0 <vTaskDelayUntil+0x6c>
8000618a:	70 08       	ld.w	r8,r8[0x0]
8000618c:	10 37       	cp.w	r7,r8
8000618e:	e0 8b 00 11 	brhi	800061b0 <vTaskDelayUntil+0x5c>
80006192:	c1 18       	rjmp	800061b4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006194:	48 c8       	lddpc	r8,800061c4 <vTaskDelayUntil+0x70>
80006196:	70 0c       	ld.w	r12,r8[0x0]
80006198:	2f cc       	sub	r12,-4
8000619a:	f0 1f 00 0c 	mcall	800061c8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000619e:	0e 9c       	mov	r12,r7
800061a0:	f0 1f 00 0b 	mcall	800061cc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800061a4:	f0 1f 00 0b 	mcall	800061d0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800061a8:	c0 81       	brne	800061b8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800061aa:	d7 33       	scall
800061ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800061b0:	8d 07       	st.w	r6[0x0],r7
800061b2:	cf 1b       	rjmp	80006194 <vTaskDelayUntil+0x40>
800061b4:	8d 07       	st.w	r6[0x0],r7
800061b6:	cf 7b       	rjmp	800061a4 <vTaskDelayUntil+0x50>
800061b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061bc:	80 00       	ld.sh	r0,r0[0x0]
800061be:	5c 54       	castu.b	r4
800061c0:	00 00       	add	r0,r0
800061c2:	0d 0c       	ld.w	r12,r6++
800061c4:	00 00       	add	r0,r0
800061c6:	0c e0       	st.h	--r6,r0
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	54 66       	stdsp	sp[0x118],r6
800061cc:	80 00       	ld.sh	r0,r0[0x0]
800061ce:	60 f8       	ld.w	r8,r0[0x3c]
800061d0:	80 00       	ld.sh	r0,r0[0x0]
800061d2:	60 10       	ld.w	r0,r0[0x4]

800061d4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800061d4:	eb cd 40 c0 	pushm	r6-r7,lr
800061d8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800061da:	48 e7       	lddpc	r7,80006210 <vTaskPlaceOnEventList+0x3c>
800061dc:	6e 0b       	ld.w	r11,r7[0x0]
800061de:	2e 8b       	sub	r11,-24
800061e0:	f0 1f 00 0d 	mcall	80006214 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061e4:	6e 0c       	ld.w	r12,r7[0x0]
800061e6:	2f cc       	sub	r12,-4
800061e8:	f0 1f 00 0c 	mcall	80006218 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800061ec:	5b f6       	cp.w	r6,-1
800061ee:	c0 81       	brne	800061fe <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061f0:	6e 0b       	ld.w	r11,r7[0x0]
800061f2:	2f cb       	sub	r11,-4
800061f4:	48 ac       	lddpc	r12,8000621c <vTaskPlaceOnEventList+0x48>
800061f6:	f0 1f 00 0b 	mcall	80006220 <vTaskPlaceOnEventList+0x4c>
800061fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800061fe:	48 a8       	lddpc	r8,80006224 <vTaskPlaceOnEventList+0x50>
80006200:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006202:	ec 0c 00 0c 	add	r12,r6,r12
80006206:	f0 1f 00 09 	mcall	80006228 <vTaskPlaceOnEventList+0x54>
8000620a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000620e:	00 00       	add	r0,r0
80006210:	00 00       	add	r0,r0
80006212:	0c e0       	st.h	--r6,r0
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	54 32       	stdsp	sp[0x10c],r2
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	54 66       	stdsp	sp[0x118],r6
8000621c:	00 00       	add	r0,r0
8000621e:	0d 34       	ld.ub	r4,r6++
80006220:	80 00       	ld.sh	r0,r0[0x0]
80006222:	54 16       	stdsp	sp[0x104],r6
80006224:	00 00       	add	r0,r0
80006226:	0d 0c       	ld.w	r12,r6++
80006228:	80 00       	ld.sh	r0,r0[0x0]
8000622a:	60 f8       	ld.w	r8,r0[0x3c]

8000622c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000622c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006230:	49 67       	lddpc	r7,80006288 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006232:	49 74       	lddpc	r4,8000628c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006234:	49 73       	lddpc	r3,80006290 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006236:	49 85       	lddpc	r5,80006294 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006238:	6e 08       	ld.w	r8,r7[0x0]
8000623a:	58 08       	cp.w	r8,0
8000623c:	c1 e0       	breq	80006278 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000623e:	f0 1f 00 17 	mcall	80006298 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006242:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006244:	f0 1f 00 16 	mcall	8000629c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006248:	58 06       	cp.w	r6,0
8000624a:	c1 70       	breq	80006278 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000624c:	f0 1f 00 15 	mcall	800062a0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006250:	68 38       	ld.w	r8,r4[0xc]
80006252:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006254:	ec cc ff fc 	sub	r12,r6,-4
80006258:	f0 1f 00 13 	mcall	800062a4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000625c:	66 08       	ld.w	r8,r3[0x0]
8000625e:	20 18       	sub	r8,1
80006260:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006262:	6e 08       	ld.w	r8,r7[0x0]
80006264:	20 18       	sub	r8,1
80006266:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006268:	f0 1f 00 10 	mcall	800062a8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000626c:	6c cc       	ld.w	r12,r6[0x30]
8000626e:	f0 1f 00 10 	mcall	800062ac <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006272:	0c 9c       	mov	r12,r6
80006274:	f0 1f 00 0e 	mcall	800062ac <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006278:	6a 08       	ld.w	r8,r5[0x0]
8000627a:	58 18       	cp.w	r8,1
8000627c:	e0 88 00 03 	brls	80006282 <prvIdleTask+0x56>
			{
				taskYIELD();
80006280:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006282:	f0 1f 00 0c 	mcall	800062b0 <prvIdleTask+0x84>
		}
		#endif
	}
80006286:	cd 9b       	rjmp	80006238 <prvIdleTask+0xc>
80006288:	00 00       	add	r0,r0
8000628a:	0c 20       	rsub	r0,r6
8000628c:	00 00       	add	r0,r0
8000628e:	0c cc       	st.b	r6++,r12
80006290:	00 00       	add	r0,r0
80006292:	0d 2c       	ld.uh	r12,r6++
80006294:	00 00       	add	r0,r0
80006296:	0c 2c       	rsub	r12,r6
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	5c 54       	castu.b	r4
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	60 10       	ld.w	r0,r0[0x4]
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	55 20       	stdsp	sp[0x148],r0
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	54 66       	stdsp	sp[0x118],r6
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	56 2c       	stdsp	sp[0x188],r12
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	57 64       	stdsp	sp[0x1d8],r4
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	20 30       	sub	r0,3

800062b4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800062b4:	d4 31       	pushm	r0-r7,lr
800062b6:	20 1d       	sub	sp,4
800062b8:	fa c4 ff d8 	sub	r4,sp,-40
800062bc:	50 0c       	stdsp	sp[0x0],r12
800062be:	16 91       	mov	r1,r11
800062c0:	14 97       	mov	r7,r10
800062c2:	12 90       	mov	r0,r9
800062c4:	10 93       	mov	r3,r8
800062c6:	68 02       	ld.w	r2,r4[0x0]
800062c8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800062ca:	34 8c       	mov	r12,72
800062cc:	f0 1f 00 5c 	mcall	8000643c <xTaskGenericCreate+0x188>
800062d0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800062d2:	c0 31       	brne	800062d8 <xTaskGenericCreate+0x24>
800062d4:	3f fc       	mov	r12,-1
800062d6:	ca f8       	rjmp	80006434 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800062d8:	58 06       	cp.w	r6,0
800062da:	e0 81 00 af 	brne	80006438 <xTaskGenericCreate+0x184>
800062de:	0e 9c       	mov	r12,r7
800062e0:	5c 7c       	castu.h	r12
800062e2:	a3 6c       	lsl	r12,0x2
800062e4:	f0 1f 00 56 	mcall	8000643c <xTaskGenericCreate+0x188>
800062e8:	18 96       	mov	r6,r12
800062ea:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800062ec:	c0 61       	brne	800062f8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800062ee:	0a 9c       	mov	r12,r5
800062f0:	f0 1f 00 54 	mcall	80006440 <xTaskGenericCreate+0x18c>
800062f4:	3f fc       	mov	r12,-1
800062f6:	c9 f8       	rjmp	80006434 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800062f8:	5c 77       	castu.h	r7
800062fa:	ee 0a 15 02 	lsl	r10,r7,0x2
800062fe:	e0 6b 00 a5 	mov	r11,165
80006302:	0c 9c       	mov	r12,r6
80006304:	f0 1f 00 50 	mcall	80006444 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006308:	ee c6 00 01 	sub	r6,r7,1
8000630c:	6a c8       	ld.w	r8,r5[0x30]
8000630e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006312:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006316:	31 0a       	mov	r10,16
80006318:	02 9b       	mov	r11,r1
8000631a:	ea cc ff cc 	sub	r12,r5,-52
8000631e:	f0 1f 00 4b 	mcall	80006448 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006322:	30 08       	mov	r8,0
80006324:	eb 68 00 43 	st.b	r5[67],r8
80006328:	58 73       	cp.w	r3,7
8000632a:	e6 07 17 80 	movls	r7,r3
8000632e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006332:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006334:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006338:	ea c4 ff fc 	sub	r4,r5,-4
8000633c:	08 9c       	mov	r12,r4
8000633e:	f0 1f 00 44 	mcall	8000644c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006342:	ea cc ff e8 	sub	r12,r5,-24
80006346:	f0 1f 00 42 	mcall	8000644c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000634a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000634c:	ee 07 11 08 	rsub	r7,r7,8
80006350:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006352:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006354:	00 9a       	mov	r10,r0
80006356:	40 0b       	lddsp	r11,sp[0x0]
80006358:	0c 9c       	mov	r12,r6
8000635a:	f0 1f 00 3e 	mcall	80006450 <xTaskGenericCreate+0x19c>
8000635e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006360:	58 02       	cp.w	r2,0
80006362:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006366:	f0 1f 00 3c 	mcall	80006454 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000636a:	4b c8       	lddpc	r8,80006458 <xTaskGenericCreate+0x1a4>
8000636c:	70 09       	ld.w	r9,r8[0x0]
8000636e:	2f f9       	sub	r9,-1
80006370:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006372:	4b b8       	lddpc	r8,8000645c <xTaskGenericCreate+0x1a8>
80006374:	70 08       	ld.w	r8,r8[0x0]
80006376:	58 08       	cp.w	r8,0
80006378:	c2 61       	brne	800063c4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000637a:	4b 98       	lddpc	r8,8000645c <xTaskGenericCreate+0x1a8>
8000637c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000637e:	4b 78       	lddpc	r8,80006458 <xTaskGenericCreate+0x1a4>
80006380:	70 08       	ld.w	r8,r8[0x0]
80006382:	58 18       	cp.w	r8,1
80006384:	c2 b1       	brne	800063da <xTaskGenericCreate+0x126>
80006386:	4b 77       	lddpc	r7,80006460 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006388:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000638c:	0e 9c       	mov	r12,r7
8000638e:	f0 1f 00 36 	mcall	80006464 <xTaskGenericCreate+0x1b0>
80006392:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006394:	0c 37       	cp.w	r7,r6
80006396:	cf b1       	brne	8000638c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006398:	4b 47       	lddpc	r7,80006468 <xTaskGenericCreate+0x1b4>
8000639a:	0e 9c       	mov	r12,r7
8000639c:	f0 1f 00 32 	mcall	80006464 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800063a0:	4b 36       	lddpc	r6,8000646c <xTaskGenericCreate+0x1b8>
800063a2:	0c 9c       	mov	r12,r6
800063a4:	f0 1f 00 30 	mcall	80006464 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800063a8:	4b 2c       	lddpc	r12,80006470 <xTaskGenericCreate+0x1bc>
800063aa:	f0 1f 00 2f 	mcall	80006464 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800063ae:	4b 2c       	lddpc	r12,80006474 <xTaskGenericCreate+0x1c0>
800063b0:	f0 1f 00 2d 	mcall	80006464 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800063b4:	4b 1c       	lddpc	r12,80006478 <xTaskGenericCreate+0x1c4>
800063b6:	f0 1f 00 2c 	mcall	80006464 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800063ba:	4b 18       	lddpc	r8,8000647c <xTaskGenericCreate+0x1c8>
800063bc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800063be:	4b 18       	lddpc	r8,80006480 <xTaskGenericCreate+0x1cc>
800063c0:	91 06       	st.w	r8[0x0],r6
800063c2:	c0 c8       	rjmp	800063da <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800063c4:	4b 08       	lddpc	r8,80006484 <xTaskGenericCreate+0x1d0>
800063c6:	70 08       	ld.w	r8,r8[0x0]
800063c8:	58 08       	cp.w	r8,0
800063ca:	c0 81       	brne	800063da <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800063cc:	4a 48       	lddpc	r8,8000645c <xTaskGenericCreate+0x1a8>
800063ce:	70 08       	ld.w	r8,r8[0x0]
800063d0:	70 b8       	ld.w	r8,r8[0x2c]
800063d2:	10 33       	cp.w	r3,r8
800063d4:	c0 33       	brcs	800063da <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800063d6:	4a 28       	lddpc	r8,8000645c <xTaskGenericCreate+0x1a8>
800063d8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800063da:	6a b8       	ld.w	r8,r5[0x2c]
800063dc:	4a b9       	lddpc	r9,80006488 <xTaskGenericCreate+0x1d4>
800063de:	72 09       	ld.w	r9,r9[0x0]
800063e0:	12 38       	cp.w	r8,r9
800063e2:	e0 88 00 04 	brls	800063ea <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800063e6:	4a 99       	lddpc	r9,80006488 <xTaskGenericCreate+0x1d4>
800063e8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800063ea:	4a 98       	lddpc	r8,8000648c <xTaskGenericCreate+0x1d8>
800063ec:	70 09       	ld.w	r9,r8[0x0]
800063ee:	2f f9       	sub	r9,-1
800063f0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800063f2:	6a b8       	ld.w	r8,r5[0x2c]
800063f4:	4a 79       	lddpc	r9,80006490 <xTaskGenericCreate+0x1dc>
800063f6:	72 09       	ld.w	r9,r9[0x0]
800063f8:	12 38       	cp.w	r8,r9
800063fa:	e0 88 00 04 	brls	80006402 <xTaskGenericCreate+0x14e>
800063fe:	4a 59       	lddpc	r9,80006490 <xTaskGenericCreate+0x1dc>
80006400:	93 08       	st.w	r9[0x0],r8
80006402:	6a bc       	ld.w	r12,r5[0x2c]
80006404:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006408:	08 9b       	mov	r11,r4
8000640a:	49 68       	lddpc	r8,80006460 <xTaskGenericCreate+0x1ac>
8000640c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006410:	f0 1f 00 21 	mcall	80006494 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006414:	f0 1f 00 21 	mcall	80006498 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006418:	49 b8       	lddpc	r8,80006484 <xTaskGenericCreate+0x1d0>
8000641a:	70 08       	ld.w	r8,r8[0x0]
8000641c:	58 08       	cp.w	r8,0
8000641e:	c0 a0       	breq	80006432 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006420:	48 f8       	lddpc	r8,8000645c <xTaskGenericCreate+0x1a8>
80006422:	70 08       	ld.w	r8,r8[0x0]
80006424:	70 b8       	ld.w	r8,r8[0x2c]
80006426:	10 33       	cp.w	r3,r8
80006428:	e0 88 00 05 	brls	80006432 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
8000642c:	d7 33       	scall
8000642e:	30 1c       	mov	r12,1
80006430:	c0 28       	rjmp	80006434 <xTaskGenericCreate+0x180>
80006432:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006434:	2f fd       	sub	sp,-4
80006436:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006438:	99 c6       	st.w	r12[0x30],r6
8000643a:	c5 fb       	rjmp	800062f8 <xTaskGenericCreate+0x44>
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	57 8c       	stdsp	sp[0x1e0],r12
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	57 64       	stdsp	sp[0x1d8],r4
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	71 54       	ld.w	r4,r8[0x54]
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	74 98       	ld.w	r8,r10[0x24]
8000644c:	80 00       	ld.sh	r0,r0[0x0]
8000644e:	54 10       	stdsp	sp[0x104],r0
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	54 8c       	stdsp	sp[0x120],r12
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	55 20       	stdsp	sp[0x148],r0
80006458:	00 00       	add	r0,r0
8000645a:	0d 2c       	ld.uh	r12,r6++
8000645c:	00 00       	add	r0,r0
8000645e:	0c e0       	st.h	--r6,r0
80006460:	00 00       	add	r0,r0
80006462:	0c 2c       	rsub	r12,r6
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	53 fc       	stdsp	sp[0xfc],r12
80006468:	00 00       	add	r0,r0
8000646a:	0c f8       	st.b	--r6,r8
8000646c:	00 00       	add	r0,r0
8000646e:	0d 14       	ld.sh	r4,r6++
80006470:	00 00       	add	r0,r0
80006472:	0c e4       	st.h	--r6,r4
80006474:	00 00       	add	r0,r0
80006476:	0c cc       	st.b	r6++,r12
80006478:	00 00       	add	r0,r0
8000647a:	0d 34       	ld.ub	r4,r6++
8000647c:	00 00       	add	r0,r0
8000647e:	0c 18       	sub	r8,r6
80006480:	00 00       	add	r0,r0
80006482:	0c 28       	rsub	r8,r6
80006484:	00 00       	add	r0,r0
80006486:	0c 1c       	sub	r12,r6
80006488:	00 00       	add	r0,r0
8000648a:	0c 14       	sub	r4,r6
8000648c:	00 00       	add	r0,r0
8000648e:	0d 28       	ld.uh	r8,r6++
80006490:	00 00       	add	r0,r0
80006492:	0d 48       	ld.w	r8,--r6
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	54 16       	stdsp	sp[0x104],r6
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	56 2c       	stdsp	sp[0x188],r12

8000649c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000649c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000649e:	30 09       	mov	r9,0
800064a0:	1a d9       	st.w	--sp,r9
800064a2:	1a d9       	st.w	--sp,r9
800064a4:	1a d9       	st.w	--sp,r9
800064a6:	12 98       	mov	r8,r9
800064a8:	e0 6a 01 00 	mov	r10,256
800064ac:	48 9b       	lddpc	r11,800064d0 <vTaskStartScheduler+0x34>
800064ae:	48 ac       	lddpc	r12,800064d4 <vTaskStartScheduler+0x38>
800064b0:	f0 1f 00 0a 	mcall	800064d8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800064b4:	2f dd       	sub	sp,-12
800064b6:	58 1c       	cp.w	r12,1
800064b8:	c0 a1       	brne	800064cc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800064ba:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800064bc:	30 19       	mov	r9,1
800064be:	48 88       	lddpc	r8,800064dc <vTaskStartScheduler+0x40>
800064c0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800064c2:	30 09       	mov	r9,0
800064c4:	48 78       	lddpc	r8,800064e0 <vTaskStartScheduler+0x44>
800064c6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800064c8:	f0 1f 00 07 	mcall	800064e4 <vTaskStartScheduler+0x48>
800064cc:	d8 02       	popm	pc
800064ce:	00 00       	add	r0,r0
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	d1 68       	*unknown*
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	62 2c       	ld.w	r12,r1[0x8]
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	62 b4       	ld.w	r4,r1[0x2c]
800064dc:	00 00       	add	r0,r0
800064de:	0c 1c       	sub	r12,r6
800064e0:	00 00       	add	r0,r0
800064e2:	0d 0c       	ld.w	r12,r6++
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	55 30       	stdsp	sp[0x14c],r0

800064e8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800064e8:	16 cc       	st.b	r11++,r12
	return str;
}
800064ea:	5e fb       	retal	r11

800064ec <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800064ec:	eb cd 40 c0 	pushm	r6-r7,lr
800064f0:	20 3d       	sub	sp,12
800064f2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800064f4:	30 06       	mov	r6,0
800064f6:	30 07       	mov	r7,0
800064f8:	fa e7 00 00 	st.d	sp[0],r6
800064fc:	30 0c       	mov	r12,0
800064fe:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006500:	58 08       	cp.w	r8,0
80006502:	c1 30       	breq	80006528 <PrintHex+0x3c>
80006504:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006506:	1a 9c       	mov	r12,sp
80006508:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000650c:	58 9e       	cp.w	lr,9
8000650e:	e0 8a 00 04 	brle	80006516 <PrintHex+0x2a>
80006512:	2c 9e       	sub	lr,-55
80006514:	c0 48       	rjmp	8000651c <PrintHex+0x30>
80006516:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000651a:	2d 0e       	sub	lr,-48
8000651c:	f8 09 0b 0e 	st.b	r12[r9],lr
80006520:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006522:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006524:	cf 21       	brne	80006508 <PrintHex+0x1c>
80006526:	c0 48       	rjmp	8000652e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006528:	33 08       	mov	r8,48
8000652a:	ba 88       	st.b	sp[0x0],r8
8000652c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000652e:	f6 09 01 08 	sub	r8,r11,r9
80006532:	58 08       	cp.w	r8,0
80006534:	e0 8a 00 13 	brle	8000655a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006538:	12 1b       	sub	r11,r9
8000653a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000653e:	18 9e       	mov	lr,r12
80006540:	58 0c       	cp.w	r12,0
80006542:	e0 8a 00 0c 	brle	8000655a <PrintHex+0x6e>
80006546:	1a 9b       	mov	r11,sp
80006548:	12 0b       	add	r11,r9
8000654a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000654c:	33 07       	mov	r7,48
8000654e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006550:	2f f8       	sub	r8,-1
80006552:	1c 38       	cp.w	r8,lr
80006554:	cf d5       	brlt	8000654e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006556:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000655a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000655e:	f0 cb ff ff 	sub	r11,r8,-1
80006562:	58 0b       	cp.w	r11,0
80006564:	e0 8a 00 19 	brle	80006596 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006568:	fa cb ff f4 	sub	r11,sp,-12
8000656c:	f6 09 00 09 	add	r9,r11,r9
80006570:	37 8b       	mov	r11,120
80006572:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006576:	fa c9 ff f4 	sub	r9,sp,-12
8000657a:	10 09       	add	r9,r8
8000657c:	33 0b       	mov	r11,48
8000657e:	f3 6b ff f4 	st.b	r9[-12],r11
80006582:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006586:	fa ce 00 01 	sub	lr,sp,1
8000658a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000658c:	11 8b       	ld.ub	r11,r8[0x0]
8000658e:	12 cb       	st.b	r9++,r11
80006590:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006592:	1c 38       	cp.w	r8,lr
80006594:	cf c1       	brne	8000658c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006596:	14 9c       	mov	r12,r10
80006598:	2f dd       	sub	sp,-12
8000659a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000659e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000659e:	d4 21       	pushm	r4-r7,lr
800065a0:	20 3d       	sub	sp,12
800065a2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800065a4:	30 06       	mov	r6,0
800065a6:	30 07       	mov	r7,0
800065a8:	fa e7 00 00 	st.d	sp[0],r6
800065ac:	30 0c       	mov	r12,0
800065ae:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800065b0:	58 08       	cp.w	r8,0
800065b2:	c0 35       	brlt	800065b8 <PrintDec+0x1a>
800065b4:	14 97       	mov	r7,r10
800065b6:	c0 58       	rjmp	800065c0 <PrintDec+0x22>
	{
		*p++ = '-';
800065b8:	14 97       	mov	r7,r10
800065ba:	32 d9       	mov	r9,45
800065bc:	0e c9       	st.b	r7++,r9
		i = -i;
800065be:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800065c0:	58 08       	cp.w	r8,0
800065c2:	c0 51       	brne	800065cc <PrintDec+0x2e>
800065c4:	33 08       	mov	r8,48
800065c6:	ba 88       	st.b	sp[0x0],r8
800065c8:	30 1e       	mov	lr,1
800065ca:	c2 f8       	rjmp	80006628 <PrintDec+0x8a>
	
	int ten = i%10;
800065cc:	e0 65 66 67 	mov	r5,26215
800065d0:	ea 15 66 66 	orh	r5,0x6666
800065d4:	f0 05 04 44 	muls.d	r4,r8,r5
800065d8:	ea 0c 14 02 	asr	r12,r5,0x2
800065dc:	f0 09 14 1f 	asr	r9,r8,0x1f
800065e0:	f8 09 01 09 	sub	r9,r12,r9
800065e4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800065e8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800065ec:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800065ee:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800065f0:	e0 66 66 67 	mov	r6,26215
800065f4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800065f8:	2d 09       	sub	r9,-48
800065fa:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800065fe:	2f fe       	sub	lr,-1
		i /= 10;
80006600:	f0 06 04 44 	muls.d	r4,r8,r6
80006604:	ea 09 14 02 	asr	r9,r5,0x2
80006608:	bf 58       	asr	r8,0x1f
8000660a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000660e:	f0 06 04 44 	muls.d	r4,r8,r6
80006612:	ea 09 14 02 	asr	r9,r5,0x2
80006616:	f0 05 14 1f 	asr	r5,r8,0x1f
8000661a:	0a 19       	sub	r9,r5
8000661c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006620:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006624:	58 08       	cp.w	r8,0
80006626:	ce 91       	brne	800065f8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006628:	f6 0e 01 08 	sub	r8,r11,lr
8000662c:	58 08       	cp.w	r8,0
8000662e:	e0 89 00 06 	brgt	8000663a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006632:	58 0e       	cp.w	lr,0
80006634:	e0 89 00 14 	brgt	8000665c <PrintDec+0xbe>
80006638:	c1 d8       	rjmp	80006672 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000663a:	1c 1b       	sub	r11,lr
8000663c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000663e:	16 9c       	mov	r12,r11
80006640:	58 0b       	cp.w	r11,0
80006642:	fe 9a ff f8 	brle	80006632 <PrintDec+0x94>
80006646:	1a 99       	mov	r9,sp
80006648:	1c 09       	add	r9,lr
8000664a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000664c:	33 06       	mov	r6,48
8000664e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006650:	2f f8       	sub	r8,-1
80006652:	18 38       	cp.w	r8,r12
80006654:	cf d5       	brlt	8000664e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006656:	f6 0e 00 0e 	add	lr,r11,lr
8000665a:	ce cb       	rjmp	80006632 <PrintDec+0x94>
8000665c:	fa c8 ff f4 	sub	r8,sp,-12
80006660:	1c 08       	add	r8,lr
80006662:	20 d8       	sub	r8,13
80006664:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006668:	11 89       	ld.ub	r9,r8[0x0]
8000666a:	0e c9       	st.b	r7++,r9
8000666c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000666e:	16 38       	cp.w	r8,r11
80006670:	cf c1       	brne	80006668 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006672:	14 9c       	mov	r12,r10
80006674:	2f dd       	sub	sp,-12
80006676:	d8 22       	popm	r4-r7,pc

80006678 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006678:	d4 31       	pushm	r0-r7,lr
8000667a:	fa cd 02 08 	sub	sp,sp,520
8000667e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006680:	e0 6a 01 00 	mov	r10,256
80006684:	30 0b       	mov	r11,0
80006686:	fa cc fe f8 	sub	r12,sp,-264
8000668a:	f0 1f 00 4e 	mcall	800067c0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000668e:	fa c4 fd d4 	sub	r4,sp,-556
80006692:	30 0a       	mov	r10,0
80006694:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006696:	fa c3 ff fc 	sub	r3,sp,-4
8000669a:	e0 61 01 00 	mov	r1,256
8000669e:	14 90       	mov	r0,r10
			
					if(*str == '%')
800066a0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800066a2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800066a6:	02 9a       	mov	r10,r1
800066a8:	00 9b       	mov	r11,r0
800066aa:	06 9c       	mov	r12,r3
800066ac:	f0 1f 00 45 	mcall	800067c0 <log+0x148>
			
					if(*str == '%')
800066b0:	0f 88       	ld.ub	r8,r7[0x0]
800066b2:	e4 08 18 00 	cp.b	r8,r2
800066b6:	c5 71       	brne	80006764 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800066b8:	ee c8 ff ff 	sub	r8,r7,-1
800066bc:	11 89       	ld.ub	r9,r8[0x0]
800066be:	4c 2a       	lddpc	r10,800067c4 <log+0x14c>
800066c0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800066c2:	23 09       	sub	r9,48
800066c4:	30 9a       	mov	r10,9
800066c6:	f4 09 18 00 	cp.b	r9,r10
800066ca:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800066ce:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800066d2:	f7 b9 08 30 	subls	r9,48
800066d6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800066da:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800066de:	0f 88       	ld.ub	r8,r7[0x0]
800066e0:	22 58       	sub	r8,37
800066e2:	e0 48 00 53 	cp.w	r8,83
800066e6:	e0 8b 00 31 	brhi	80006748 <log+0xd0>
800066ea:	4b 89       	lddpc	r9,800067c8 <log+0x150>
800066ec:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800066f0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800066f4:	06 9a       	mov	r10,r3
800066f6:	40 0b       	lddsp	r11,sp[0x0]
800066f8:	5c 5b       	castu.b	r11
800066fa:	68 0c       	ld.w	r12,r4[0x0]
800066fc:	f0 1f 00 34 	mcall	800067cc <log+0x154>
							break;
80006700:	c2 98       	rjmp	80006752 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006702:	4b 4c       	lddpc	r12,800067d0 <log+0x158>
80006704:	f0 1f 00 34 	mcall	800067d4 <log+0x15c>
80006708:	08 95       	mov	r5,r4
8000670a:	06 9c       	mov	r12,r3
							break;
8000670c:	c2 38       	rjmp	80006752 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000670e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006712:	06 9a       	mov	r10,r3
80006714:	40 0b       	lddsp	r11,sp[0x0]
80006716:	5c 5b       	castu.b	r11
80006718:	68 0c       	ld.w	r12,r4[0x0]
8000671a:	f0 1f 00 30 	mcall	800067d8 <log+0x160>
8000671e:	06 9c       	mov	r12,r3
							break;
80006720:	c1 98       	rjmp	80006752 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006722:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006726:	06 9b       	mov	r11,r3
80006728:	09 bc       	ld.ub	r12,r4[0x3]
8000672a:	f0 1f 00 2d 	mcall	800067dc <log+0x164>
8000672e:	06 9c       	mov	r12,r3
							break;
80006730:	c1 18       	rjmp	80006752 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006732:	e8 c5 ff fc 	sub	r5,r4,-4
80006736:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006738:	c0 d8       	rjmp	80006752 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000673a:	06 9b       	mov	r11,r3
8000673c:	32 5c       	mov	r12,37
8000673e:	f0 1f 00 28 	mcall	800067dc <log+0x164>
80006742:	08 95       	mov	r5,r4
80006744:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006746:	c0 68       	rjmp	80006752 <log+0xda>
							
							default:
							log("I need relax.");
80006748:	4a 6c       	lddpc	r12,800067e0 <log+0x168>
8000674a:	f0 1f 00 23 	mcall	800067d4 <log+0x15c>
8000674e:	08 95       	mov	r5,r4
80006750:	06 9c       	mov	r12,r3
						}
						str++;
80006752:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006754:	1a dc       	st.w	--sp,r12
80006756:	1a d6       	st.w	--sp,r6
80006758:	4a 3b       	lddpc	r11,800067e4 <log+0x16c>
8000675a:	0c 9c       	mov	r12,r6
8000675c:	f0 1f 00 23 	mcall	800067e8 <log+0x170>
80006760:	2f ed       	sub	sp,-8
80006762:	c0 a8       	rjmp	80006776 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006764:	2f f7       	sub	r7,-1
80006766:	1a d8       	st.w	--sp,r8
80006768:	1a d6       	st.w	--sp,r6
8000676a:	4a 1b       	lddpc	r11,800067ec <log+0x174>
8000676c:	0c 9c       	mov	r12,r6
8000676e:	f0 1f 00 1f 	mcall	800067e8 <log+0x170>
80006772:	08 95       	mov	r5,r4
80006774:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006776:	0f 89       	ld.ub	r9,r7[0x0]
80006778:	30 08       	mov	r8,0
8000677a:	f0 09 18 00 	cp.b	r9,r8
8000677e:	c0 30       	breq	80006784 <log+0x10c>
80006780:	0a 94       	mov	r4,r5
80006782:	c9 2b       	rjmp	800066a6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006784:	fa c7 fe f8 	sub	r7,sp,-264
80006788:	1a d7       	st.w	--sp,r7
8000678a:	49 ab       	lddpc	r11,800067f0 <log+0x178>
8000678c:	0e 9c       	mov	r12,r7
8000678e:	f0 1f 00 17 	mcall	800067e8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006792:	5c 5c       	castu.b	r12
80006794:	f8 c6 ff ff 	sub	r6,r12,-1
80006798:	0c 9c       	mov	r12,r6
8000679a:	f0 1f 00 17 	mcall	800067f4 <log+0x17c>
8000679e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800067a0:	0c 9a       	mov	r10,r6
800067a2:	0e 9b       	mov	r11,r7
800067a4:	f0 1f 00 15 	mcall	800067f8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800067a8:	30 09       	mov	r9,0
800067aa:	30 5a       	mov	r10,5
800067ac:	fa cb fe f8 	sub	r11,sp,-264
800067b0:	49 38       	lddpc	r8,800067fc <log+0x184>
800067b2:	70 0c       	ld.w	r12,r8[0x0]
800067b4:	f0 1f 00 13 	mcall	80006800 <log+0x188>
800067b8:	2f fd       	sub	sp,-4
	
	
}
800067ba:	fe 3d fd f8 	sub	sp,-520
800067be:	d8 32       	popm	r0-r7,pc
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	71 54       	ld.w	r4,r8[0x54]
800067c4:	00 00       	add	r0,r0
800067c6:	0d 4c       	ld.w	r12,--r6
800067c8:	80 00       	ld.sh	r0,r0[0x0]
800067ca:	d1 70       	acall	0x17
800067cc:	80 00       	ld.sh	r0,r0[0x0]
800067ce:	65 9e       	ld.w	lr,r2[0x64]
800067d0:	80 00       	ld.sh	r0,r0[0x0]
800067d2:	d4 1c       	*unknown*
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	66 78       	ld.w	r8,r3[0x1c]
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	64 ec       	ld.w	r12,r2[0x38]
800067dc:	80 00       	ld.sh	r0,r0[0x0]
800067de:	64 e8       	ld.w	r8,r2[0x38]
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	d4 2c       	*unknown*
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	d4 3c       	*unknown*
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	74 44       	ld.w	r4,r10[0x10]
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	d4 44       	*unknown*
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	d4 4c       	*unknown*
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	57 8c       	stdsp	sp[0x1e0],r12
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	70 0c       	ld.w	r12,r8[0x0]
800067fc:	00 00       	add	r0,r0
800067fe:	41 08       	lddsp	r8,sp[0x40]
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	5a e0       	cp.w	r0,-18

80006804 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006804:	d4 31       	pushm	r0-r7,lr
80006806:	fa cd 02 0c 	sub	sp,sp,524
8000680a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000680c:	e0 6a 01 00 	mov	r10,256
80006810:	30 0b       	mov	r11,0
80006812:	fa cc fe f4 	sub	r12,sp,-268
80006816:	f0 1f 00 4c 	mcall	80006944 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000681a:	fa c4 fd d0 	sub	r4,sp,-560
8000681e:	30 0a       	mov	r10,0
80006820:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006822:	fa c3 ff fc 	sub	r3,sp,-4
80006826:	e0 61 01 00 	mov	r1,256
8000682a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000682c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000682e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006832:	02 9a       	mov	r10,r1
80006834:	00 9b       	mov	r11,r0
80006836:	06 9c       	mov	r12,r3
80006838:	f0 1f 00 43 	mcall	80006944 <logFromISR+0x140>
			
			if(*str == '%')
8000683c:	0f 88       	ld.ub	r8,r7[0x0]
8000683e:	e4 08 18 00 	cp.b	r8,r2
80006842:	c5 11       	brne	800068e4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006844:	ee c8 ff ff 	sub	r8,r7,-1
80006848:	11 89       	ld.ub	r9,r8[0x0]
8000684a:	4c 0a       	lddpc	r10,80006948 <logFromISR+0x144>
8000684c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000684e:	23 09       	sub	r9,48
80006850:	30 9a       	mov	r10,9
80006852:	f4 09 18 00 	cp.b	r9,r10
80006856:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000685a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000685e:	f7 b9 08 30 	subls	r9,48
80006862:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006866:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000686a:	0f 88       	ld.ub	r8,r7[0x0]
8000686c:	22 58       	sub	r8,37
8000686e:	e0 48 00 53 	cp.w	r8,83
80006872:	e0 8b 00 2b 	brhi	800068c8 <logFromISR+0xc4>
80006876:	4b 69       	lddpc	r9,8000694c <logFromISR+0x148>
80006878:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000687c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006880:	06 9a       	mov	r10,r3
80006882:	40 0b       	lddsp	r11,sp[0x0]
80006884:	5c 5b       	castu.b	r11
80006886:	68 0c       	ld.w	r12,r4[0x0]
80006888:	f0 1f 00 32 	mcall	80006950 <logFromISR+0x14c>
					break;
8000688c:	c2 38       	rjmp	800068d2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000688e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006892:	06 9a       	mov	r10,r3
80006894:	40 0b       	lddsp	r11,sp[0x0]
80006896:	5c 5b       	castu.b	r11
80006898:	68 0c       	ld.w	r12,r4[0x0]
8000689a:	f0 1f 00 2f 	mcall	80006954 <logFromISR+0x150>
8000689e:	06 9c       	mov	r12,r3
					break;
800068a0:	c1 98       	rjmp	800068d2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800068a2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800068a6:	06 9b       	mov	r11,r3
800068a8:	09 bc       	ld.ub	r12,r4[0x3]
800068aa:	f0 1f 00 2c 	mcall	80006958 <logFromISR+0x154>
800068ae:	06 9c       	mov	r12,r3
					break;
800068b0:	c1 18       	rjmp	800068d2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800068b2:	e8 c5 ff fc 	sub	r5,r4,-4
800068b6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800068b8:	c0 d8       	rjmp	800068d2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800068ba:	06 9b       	mov	r11,r3
800068bc:	32 5c       	mov	r12,37
800068be:	f0 1f 00 27 	mcall	80006958 <logFromISR+0x154>
800068c2:	08 95       	mov	r5,r4
800068c4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800068c6:	c0 68       	rjmp	800068d2 <logFromISR+0xce>
					default:
					log("I need relax.");
800068c8:	4a 5c       	lddpc	r12,8000695c <logFromISR+0x158>
800068ca:	f0 1f 00 26 	mcall	80006960 <logFromISR+0x15c>
800068ce:	08 95       	mov	r5,r4
800068d0:	06 9c       	mov	r12,r3
				}
				str++;
800068d2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800068d4:	1a dc       	st.w	--sp,r12
800068d6:	1a d6       	st.w	--sp,r6
800068d8:	4a 3b       	lddpc	r11,80006964 <logFromISR+0x160>
800068da:	0c 9c       	mov	r12,r6
800068dc:	f0 1f 00 23 	mcall	80006968 <logFromISR+0x164>
800068e0:	2f ed       	sub	sp,-8
800068e2:	c0 a8       	rjmp	800068f6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800068e4:	2f f7       	sub	r7,-1
800068e6:	1a d8       	st.w	--sp,r8
800068e8:	1a d6       	st.w	--sp,r6
800068ea:	4a 1b       	lddpc	r11,8000696c <logFromISR+0x168>
800068ec:	0c 9c       	mov	r12,r6
800068ee:	f0 1f 00 1f 	mcall	80006968 <logFromISR+0x164>
800068f2:	08 95       	mov	r5,r4
800068f4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800068f6:	0f 89       	ld.ub	r9,r7[0x0]
800068f8:	30 08       	mov	r8,0
800068fa:	f0 09 18 00 	cp.b	r9,r8
800068fe:	c0 30       	breq	80006904 <logFromISR+0x100>
80006900:	0a 94       	mov	r4,r5
80006902:	c9 8b       	rjmp	80006832 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006904:	fa c7 fe f4 	sub	r7,sp,-268
80006908:	1a d7       	st.w	--sp,r7
8000690a:	49 ab       	lddpc	r11,80006970 <logFromISR+0x16c>
8000690c:	0e 9c       	mov	r12,r7
8000690e:	f0 1f 00 17 	mcall	80006968 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006912:	5c 5c       	castu.b	r12
80006914:	f8 c6 ff ff 	sub	r6,r12,-1
80006918:	0c 9c       	mov	r12,r6
8000691a:	f0 1f 00 17 	mcall	80006974 <logFromISR+0x170>
8000691e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006920:	0c 9a       	mov	r10,r6
80006922:	0e 9b       	mov	r11,r7
80006924:	f0 1f 00 15 	mcall	80006978 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006928:	30 09       	mov	r9,0
8000692a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000692c:	fa ca fe f8 	sub	r10,sp,-264
80006930:	fa cb fe f4 	sub	r11,sp,-268
80006934:	49 28       	lddpc	r8,8000697c <logFromISR+0x178>
80006936:	70 0c       	ld.w	r12,r8[0x0]
80006938:	f0 1f 00 12 	mcall	80006980 <logFromISR+0x17c>
8000693c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000693e:	fe 3d fd f4 	sub	sp,-524
80006942:	d8 32       	popm	r0-r7,pc
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	71 54       	ld.w	r4,r8[0x54]
80006948:	00 00       	add	r0,r0
8000694a:	0d 4d       	ld.w	sp,--r6
8000694c:	80 00       	ld.sh	r0,r0[0x0]
8000694e:	d2 c0       	acall	0x2c
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	65 9e       	ld.w	lr,r2[0x64]
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	64 ec       	ld.w	r12,r2[0x38]
80006958:	80 00       	ld.sh	r0,r0[0x0]
8000695a:	64 e8       	ld.w	r8,r2[0x38]
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	d4 2c       	*unknown*
80006960:	80 00       	ld.sh	r0,r0[0x0]
80006962:	66 78       	ld.w	r8,r3[0x1c]
80006964:	80 00       	ld.sh	r0,r0[0x0]
80006966:	d4 3c       	*unknown*
80006968:	80 00       	ld.sh	r0,r0[0x0]
8000696a:	74 44       	ld.w	r4,r10[0x10]
8000696c:	80 00       	ld.sh	r0,r0[0x0]
8000696e:	d4 44       	*unknown*
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	d4 4c       	*unknown*
80006974:	80 00       	ld.sh	r0,r0[0x0]
80006976:	57 8c       	stdsp	sp[0x1e0],r12
80006978:	80 00       	ld.sh	r0,r0[0x0]
8000697a:	70 0c       	ld.w	r12,r8[0x0]
8000697c:	00 00       	add	r0,r0
8000697e:	41 08       	lddsp	r8,sp[0x40]
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	5a 90       	cp.w	r0,-23

80006984 <log_init>:
		
	return str;
}

void log_init(void)
{
80006984:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006986:	30 2b       	mov	r11,2
80006988:	49 0c       	lddpc	r12,800069c8 <log_init+0x44>
8000698a:	f0 1f 00 11 	mcall	800069cc <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);		
8000698e:	e0 6a 36 00 	mov	r10,13824
80006992:	ea 1a 01 6e 	orh	r10,0x16e
80006996:	48 fb       	lddpc	r11,800069d0 <log_init+0x4c>
80006998:	fe 7c 18 00 	mov	r12,-59392
8000699c:	f0 1f 00 0e 	mcall	800069d4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800069a0:	30 4b       	mov	r11,4
800069a2:	33 2c       	mov	r12,50
800069a4:	f0 1f 00 0d 	mcall	800069d8 <log_init+0x54>
800069a8:	48 d8       	lddpc	r8,800069dc <log_init+0x58>
800069aa:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800069ac:	30 09       	mov	r9,0
800069ae:	1a d9       	st.w	--sp,r9
800069b0:	1a d9       	st.w	--sp,r9
800069b2:	1a d9       	st.w	--sp,r9
800069b4:	30 28       	mov	r8,2
800069b6:	e0 6a 01 80 	mov	r10,384
800069ba:	48 ab       	lddpc	r11,800069e0 <log_init+0x5c>
800069bc:	48 ac       	lddpc	r12,800069e4 <log_init+0x60>
800069be:	f0 1f 00 0b 	mcall	800069e8 <log_init+0x64>
800069c2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800069c4:	d8 02       	popm	pc
800069c6:	00 00       	add	r0,r0
800069c8:	80 00       	ld.sh	r0,r0[0x0]
800069ca:	d4 58       	*unknown*
800069cc:	80 00       	ld.sh	r0,r0[0x0]
800069ce:	6b 10       	ld.w	r0,r5[0x44]
800069d0:	80 00       	ld.sh	r0,r0[0x0]
800069d2:	d4 10       	acall	0x41
800069d4:	80 00       	ld.sh	r0,r0[0x0]
800069d6:	53 30       	stdsp	sp[0xcc],r0
800069d8:	80 00       	ld.sh	r0,r0[0x0]
800069da:	5b e0       	cp.w	r0,-2
800069dc:	00 00       	add	r0,r0
800069de:	41 08       	lddsp	r8,sp[0x40]
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	d4 54       	*unknown*
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	69 ec       	ld.w	r12,r4[0x78]
800069e8:	80 00       	ld.sh	r0,r0[0x0]
800069ea:	62 b4       	ld.w	r4,r1[0x2c]

800069ec <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800069ec:	eb cd 40 f8 	pushm	r3-r7,lr
800069f0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800069f2:	48 c7       	lddpc	r7,80006a20 <task_log+0x34>
800069f4:	30 05       	mov	r5,0
800069f6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800069f8:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800069fc:	0a 99       	mov	r9,r5
800069fe:	08 9a       	mov	r10,r4
80006a00:	1a 9b       	mov	r11,sp
80006a02:	6e 0c       	ld.w	r12,r7[0x0]
80006a04:	f0 1f 00 08 	mcall	80006a24 <task_log+0x38>
80006a08:	58 1c       	cp.w	r12,1
80006a0a:	cf 91       	brne	800069fc <task_log+0x10>
		{
			if( NULL != str)
80006a0c:	40 0b       	lddsp	r11,sp[0x0]
80006a0e:	58 0b       	cp.w	r11,0
80006a10:	cf 60       	breq	800069fc <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006a12:	06 9c       	mov	r12,r3
80006a14:	f0 1f 00 05 	mcall	80006a28 <task_log+0x3c>
				vPortFree(str);
80006a18:	40 0c       	lddsp	r12,sp[0x0]
80006a1a:	f0 1f 00 05 	mcall	80006a2c <task_log+0x40>
80006a1e:	ce fb       	rjmp	800069fc <task_log+0x10>
80006a20:	00 00       	add	r0,r0
80006a22:	41 08       	lddsp	r8,sp[0x40]
80006a24:	80 00       	ld.sh	r0,r0[0x0]
80006a26:	58 d4       	cp.w	r4,13
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	52 e0       	stdsp	sp[0xb8],r0
80006a2c:	80 00       	ld.sh	r0,r0[0x0]
80006a2e:	57 64       	stdsp	sp[0x1d8],r4

80006a30 <main>:
//#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
80006a30:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006a32:	fe 78 10 00 	mov	r8,-61440
80006a36:	30 19       	mov	r9,1
80006a38:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006a3c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006a40:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006a44:	d3 03       	ssrf	0x10
	local_start_pll0();
80006a46:	f0 1f 00 13 	mcall	80006a90 <main+0x60>
		
	INTC_init_interrupts();
80006a4a:	f0 1f 00 13 	mcall	80006a94 <main+0x64>
	
	log_init();		
80006a4e:	f0 1f 00 13 	mcall	80006a98 <main+0x68>
	log("----start debug， yoyo----");	
80006a52:	49 3c       	lddpc	r12,80006a9c <main+0x6c>
80006a54:	f0 1f 00 13 	mcall	80006aa0 <main+0x70>
	
	data_flash_init();
80006a58:	f0 1f 00 13 	mcall	80006aa4 <main+0x74>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。

	tc_init();	
80006a5c:	f0 1f 00 13 	mcall	80006aa8 <main+0x78>
			
	xcmp_init();
80006a60:	f0 1f 00 13 	mcall	80006aac <main+0x7c>
	
	app_init();
80006a64:	f0 1f 00 13 	mcall	80006ab0 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006a68:	fe 79 10 00 	mov	r9,-61440
80006a6c:	f2 f8 01 60 	ld.w	r8,r9[352]
80006a70:	e2 18 00 02 	andl	r8,0x2,COH
80006a74:	cf c0       	breq	80006a6c <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006a76:	fe 79 10 00 	mov	r9,-61440
80006a7a:	f2 f8 01 60 	ld.w	r8,r9[352]
80006a7e:	e2 18 00 02 	andl	r8,0x2,COH
80006a82:	cf c1       	brne	80006a7a <main+0x4a>
	local_start_timer();
80006a84:	f0 1f 00 0c 	mcall	80006ab4 <main+0x84>
	
	Enable_global_interrupt();
80006a88:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006a8a:	f0 1f 00 0c 	mcall	80006ab8 <main+0x88>
	return 0;
}
80006a8e:	d8 0a       	popm	pc,r12=0
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	4c 04       	lddpc	r4,80006b90 <idata_load_loop>
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	4d 94       	lddpc	r4,80006bf8 <_malloc_r+0x24>
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	69 84       	ld.w	r4,r4[0x60]
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	d4 68       	*unknown*
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	66 78       	ld.w	r8,r3[0x1c]
80006aa4:	80 00       	ld.sh	r0,r0[0x0]
80006aa6:	2c 54       	sub	r4,-59
80006aa8:	80 00       	ld.sh	r0,r0[0x0]
80006aaa:	4c 90       	lddpc	r0,80006bcc <malloc+0x8>
80006aac:	80 00       	ld.sh	r0,r0[0x0]
80006aae:	45 08       	lddsp	r8,sp[0x140]
80006ab0:	80 00       	ld.sh	r0,r0[0x0]
80006ab2:	20 40       	sub	r0,4
80006ab4:	80 00       	ld.sh	r0,r0[0x0]
80006ab6:	4c 54       	lddpc	r4,80006bc8 <malloc+0x4>
80006ab8:	80 00       	ld.sh	r0,r0[0x0]
80006aba:	64 9c       	ld.w	r12,r2[0x24]

80006abc <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006abc:	f8 08 16 05 	lsr	r8,r12,0x5
80006ac0:	a9 68       	lsl	r8,0x8
80006ac2:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006ac6:	58 1b       	cp.w	r11,1
80006ac8:	c0 d0       	breq	80006ae2 <gpio_enable_module_pin+0x26>
80006aca:	c0 63       	brcs	80006ad6 <gpio_enable_module_pin+0x1a>
80006acc:	58 2b       	cp.w	r11,2
80006ace:	c1 00       	breq	80006aee <gpio_enable_module_pin+0x32>
80006ad0:	58 3b       	cp.w	r11,3
80006ad2:	c1 40       	breq	80006afa <gpio_enable_module_pin+0x3e>
80006ad4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006ad6:	30 19       	mov	r9,1
80006ad8:	f2 0c 09 49 	lsl	r9,r9,r12
80006adc:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006ade:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006ae0:	c1 28       	rjmp	80006b04 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006ae2:	30 19       	mov	r9,1
80006ae4:	f2 0c 09 49 	lsl	r9,r9,r12
80006ae8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006aea:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006aec:	c0 c8       	rjmp	80006b04 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006aee:	30 19       	mov	r9,1
80006af0:	f2 0c 09 49 	lsl	r9,r9,r12
80006af4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006af6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006af8:	c0 68       	rjmp	80006b04 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006afa:	30 19       	mov	r9,1
80006afc:	f2 0c 09 49 	lsl	r9,r9,r12
80006b00:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006b02:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006b04:	30 19       	mov	r9,1
80006b06:	f2 0c 09 4c 	lsl	r12,r9,r12
80006b0a:	91 2c       	st.w	r8[0x8],r12
80006b0c:	5e fd       	retal	0
80006b0e:	d7 03       	nop

80006b10 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006b10:	d4 21       	pushm	r4-r7,lr
80006b12:	18 97       	mov	r7,r12
80006b14:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006b16:	58 0b       	cp.w	r11,0
80006b18:	c0 31       	brne	80006b1e <gpio_enable_module+0xe>
80006b1a:	30 05       	mov	r5,0
80006b1c:	c0 d8       	rjmp	80006b36 <gpio_enable_module+0x26>
80006b1e:	30 06       	mov	r6,0
80006b20:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006b22:	6e 1b       	ld.w	r11,r7[0x4]
80006b24:	6e 0c       	ld.w	r12,r7[0x0]
80006b26:	f0 1f 00 06 	mcall	80006b3c <gpio_enable_module+0x2c>
80006b2a:	18 45       	or	r5,r12
		gpiomap++;
80006b2c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006b2e:	2f f6       	sub	r6,-1
80006b30:	0c 34       	cp.w	r4,r6
80006b32:	fe 9b ff f8 	brhi	80006b22 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006b36:	0a 9c       	mov	r12,r5
80006b38:	d8 22       	popm	r4-r7,pc
80006b3a:	00 00       	add	r0,r0
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	6a bc       	ld.w	r12,r5[0x2c]

80006b40 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006b40:	f8 08 16 05 	lsr	r8,r12,0x5
80006b44:	a9 68       	lsl	r8,0x8
80006b46:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006b4a:	30 19       	mov	r9,1
80006b4c:	f2 0c 09 4c 	lsl	r12,r9,r12
80006b50:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80006b54:	91 1c       	st.w	r8[0x4],r12
}
80006b56:	5e fc       	retal	r12

80006b58 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006b58:	f8 08 16 05 	lsr	r8,r12,0x5
80006b5c:	a9 68       	lsl	r8,0x8
80006b5e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80006b62:	30 19       	mov	r9,1
80006b64:	f2 0c 09 4c 	lsl	r12,r9,r12
80006b68:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006b6c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006b70:	91 1c       	st.w	r8[0x4],r12
}
80006b72:	5e fc       	retal	r12

80006b74 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006b74:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006b78:	fe c0 a5 78 	sub	r0,pc,-23176

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006b7c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006b80:	d5 53       	csrf	0x15
  cp      r0, r1
80006b82:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006b84:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006b88:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006b8a:	c0 72       	brcc	80006b98 <idata_load_loop_end>
  cp      r0, r1
80006b8c:	fe c2 91 84 	sub	r2,pc,-28284

80006b90 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006b90:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006b92:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006b94:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80006b96:	cf d3       	brcs	80006b90 <idata_load_loop>

80006b98 <idata_load_loop_end>:
  mov     r2, 0
80006b98:	e0 60 0a 48 	mov	r0,2632
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006b9c:	e0 61 41 10 	mov	r1,16656
  cp      r0, r1
  brlo    udata_clear_loop
80006ba0:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006ba2:	c0 62       	brcc	80006bae <udata_clear_loop_end>
80006ba4:	30 02       	mov	r2,0
80006ba6:	30 03       	mov	r3,0

80006ba8 <udata_clear_loop>:
80006ba8:	a1 22       	st.d	r0++,r2
80006baa:	02 30       	cp.w	r0,r1
80006bac:	cf e3       	brcs	80006ba8 <udata_clear_loop>

80006bae <udata_clear_loop_end>:
80006bae:	fe cf 01 7e 	sub	pc,pc,382
80006bb2:	d7 03       	nop

80006bb4 <free>:
80006bb4:	d4 01       	pushm	lr
80006bb6:	e0 68 0a 44 	mov	r8,2628
80006bba:	18 9b       	mov	r11,r12
80006bbc:	70 0c       	ld.w	r12,r8[0x0]
80006bbe:	e0 a0 1e 6d 	rcall	8000a898 <_free_r>
80006bc2:	d8 02       	popm	pc

80006bc4 <malloc>:
80006bc4:	d4 01       	pushm	lr
80006bc6:	e0 68 0a 44 	mov	r8,2628
80006bca:	18 9b       	mov	r11,r12
80006bcc:	70 0c       	ld.w	r12,r8[0x0]
80006bce:	c0 3c       	rcall	80006bd4 <_malloc_r>
80006bd0:	d8 02       	popm	pc
80006bd2:	d7 03       	nop

80006bd4 <_malloc_r>:
80006bd4:	d4 31       	pushm	r0-r7,lr
80006bd6:	f6 c8 ff f5 	sub	r8,r11,-11
80006bda:	18 95       	mov	r5,r12
80006bdc:	10 97       	mov	r7,r8
80006bde:	e0 17 ff f8 	andl	r7,0xfff8
80006be2:	59 68       	cp.w	r8,22
80006be4:	f9 b7 08 10 	movls	r7,16
80006be8:	16 37       	cp.w	r7,r11
80006bea:	5f 38       	srlo	r8
80006bec:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006bf0:	c0 50       	breq	80006bfa <_malloc_r+0x26>
80006bf2:	30 c8       	mov	r8,12
80006bf4:	99 38       	st.w	r12[0xc],r8
80006bf6:	e0 8f 01 fa 	bral	80006fea <_malloc_r+0x416>
80006bfa:	fe b0 f5 6b 	rcall	800056d0 <__malloc_lock>
80006bfe:	e0 47 01 f7 	cp.w	r7,503
80006c02:	e0 8b 00 1d 	brhi	80006c3c <_malloc_r+0x68>
80006c06:	ee 03 16 03 	lsr	r3,r7,0x3
80006c0a:	e0 68 05 44 	mov	r8,1348
80006c0e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006c12:	70 36       	ld.w	r6,r8[0xc]
80006c14:	10 36       	cp.w	r6,r8
80006c16:	c0 61       	brne	80006c22 <_malloc_r+0x4e>
80006c18:	ec c8 ff f8 	sub	r8,r6,-8
80006c1c:	70 36       	ld.w	r6,r8[0xc]
80006c1e:	10 36       	cp.w	r6,r8
80006c20:	c0 c0       	breq	80006c38 <_malloc_r+0x64>
80006c22:	6c 18       	ld.w	r8,r6[0x4]
80006c24:	e0 18 ff fc 	andl	r8,0xfffc
80006c28:	6c 3a       	ld.w	r10,r6[0xc]
80006c2a:	ec 08 00 09 	add	r9,r6,r8
80006c2e:	0a 9c       	mov	r12,r5
80006c30:	6c 28       	ld.w	r8,r6[0x8]
80006c32:	95 28       	st.w	r10[0x8],r8
80006c34:	91 3a       	st.w	r8[0xc],r10
80006c36:	c4 78       	rjmp	80006cc4 <_malloc_r+0xf0>
80006c38:	2f e3       	sub	r3,-2
80006c3a:	c4 d8       	rjmp	80006cd4 <_malloc_r+0x100>
80006c3c:	ee 03 16 09 	lsr	r3,r7,0x9
80006c40:	c0 41       	brne	80006c48 <_malloc_r+0x74>
80006c42:	ee 03 16 03 	lsr	r3,r7,0x3
80006c46:	c2 68       	rjmp	80006c92 <_malloc_r+0xbe>
80006c48:	58 43       	cp.w	r3,4
80006c4a:	e0 8b 00 06 	brhi	80006c56 <_malloc_r+0x82>
80006c4e:	ee 03 16 06 	lsr	r3,r7,0x6
80006c52:	2c 83       	sub	r3,-56
80006c54:	c1 f8       	rjmp	80006c92 <_malloc_r+0xbe>
80006c56:	59 43       	cp.w	r3,20
80006c58:	e0 8b 00 04 	brhi	80006c60 <_malloc_r+0x8c>
80006c5c:	2a 53       	sub	r3,-91
80006c5e:	c1 a8       	rjmp	80006c92 <_malloc_r+0xbe>
80006c60:	e0 43 00 54 	cp.w	r3,84
80006c64:	e0 8b 00 06 	brhi	80006c70 <_malloc_r+0x9c>
80006c68:	ee 03 16 0c 	lsr	r3,r7,0xc
80006c6c:	29 23       	sub	r3,-110
80006c6e:	c1 28       	rjmp	80006c92 <_malloc_r+0xbe>
80006c70:	e0 43 01 54 	cp.w	r3,340
80006c74:	e0 8b 00 06 	brhi	80006c80 <_malloc_r+0xac>
80006c78:	ee 03 16 0f 	lsr	r3,r7,0xf
80006c7c:	28 93       	sub	r3,-119
80006c7e:	c0 a8       	rjmp	80006c92 <_malloc_r+0xbe>
80006c80:	e0 43 05 54 	cp.w	r3,1364
80006c84:	e0 88 00 04 	brls	80006c8c <_malloc_r+0xb8>
80006c88:	37 e3       	mov	r3,126
80006c8a:	c0 48       	rjmp	80006c92 <_malloc_r+0xbe>
80006c8c:	ee 03 16 12 	lsr	r3,r7,0x12
80006c90:	28 43       	sub	r3,-124
80006c92:	e0 6a 05 44 	mov	r10,1348
80006c96:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006c9a:	74 36       	ld.w	r6,r10[0xc]
80006c9c:	c1 98       	rjmp	80006cce <_malloc_r+0xfa>
80006c9e:	6c 19       	ld.w	r9,r6[0x4]
80006ca0:	e0 19 ff fc 	andl	r9,0xfffc
80006ca4:	f2 07 01 0b 	sub	r11,r9,r7
80006ca8:	58 fb       	cp.w	r11,15
80006caa:	e0 8a 00 04 	brle	80006cb2 <_malloc_r+0xde>
80006cae:	20 13       	sub	r3,1
80006cb0:	c1 18       	rjmp	80006cd2 <_malloc_r+0xfe>
80006cb2:	6c 38       	ld.w	r8,r6[0xc]
80006cb4:	58 0b       	cp.w	r11,0
80006cb6:	c0 b5       	brlt	80006ccc <_malloc_r+0xf8>
80006cb8:	6c 2a       	ld.w	r10,r6[0x8]
80006cba:	ec 09 00 09 	add	r9,r6,r9
80006cbe:	0a 9c       	mov	r12,r5
80006cc0:	91 2a       	st.w	r8[0x8],r10
80006cc2:	95 38       	st.w	r10[0xc],r8
80006cc4:	72 18       	ld.w	r8,r9[0x4]
80006cc6:	a1 a8       	sbr	r8,0x0
80006cc8:	93 18       	st.w	r9[0x4],r8
80006cca:	cb c8       	rjmp	80006e42 <_malloc_r+0x26e>
80006ccc:	10 96       	mov	r6,r8
80006cce:	14 36       	cp.w	r6,r10
80006cd0:	ce 71       	brne	80006c9e <_malloc_r+0xca>
80006cd2:	2f f3       	sub	r3,-1
80006cd4:	e0 6a 05 44 	mov	r10,1348
80006cd8:	f4 cc ff f8 	sub	r12,r10,-8
80006cdc:	78 26       	ld.w	r6,r12[0x8]
80006cde:	18 36       	cp.w	r6,r12
80006ce0:	c6 c0       	breq	80006db8 <_malloc_r+0x1e4>
80006ce2:	6c 19       	ld.w	r9,r6[0x4]
80006ce4:	e0 19 ff fc 	andl	r9,0xfffc
80006ce8:	f2 07 01 08 	sub	r8,r9,r7
80006cec:	58 f8       	cp.w	r8,15
80006cee:	e0 89 00 8f 	brgt	80006e0c <_malloc_r+0x238>
80006cf2:	99 3c       	st.w	r12[0xc],r12
80006cf4:	99 2c       	st.w	r12[0x8],r12
80006cf6:	58 08       	cp.w	r8,0
80006cf8:	c0 55       	brlt	80006d02 <_malloc_r+0x12e>
80006cfa:	ec 09 00 09 	add	r9,r6,r9
80006cfe:	0a 9c       	mov	r12,r5
80006d00:	ce 2b       	rjmp	80006cc4 <_malloc_r+0xf0>
80006d02:	e0 49 01 ff 	cp.w	r9,511
80006d06:	e0 8b 00 13 	brhi	80006d2c <_malloc_r+0x158>
80006d0a:	a3 99       	lsr	r9,0x3
80006d0c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006d10:	70 2b       	ld.w	r11,r8[0x8]
80006d12:	8d 38       	st.w	r6[0xc],r8
80006d14:	8d 2b       	st.w	r6[0x8],r11
80006d16:	97 36       	st.w	r11[0xc],r6
80006d18:	91 26       	st.w	r8[0x8],r6
80006d1a:	a3 49       	asr	r9,0x2
80006d1c:	74 18       	ld.w	r8,r10[0x4]
80006d1e:	30 1b       	mov	r11,1
80006d20:	f6 09 09 49 	lsl	r9,r11,r9
80006d24:	f1 e9 10 09 	or	r9,r8,r9
80006d28:	95 19       	st.w	r10[0x4],r9
80006d2a:	c4 78       	rjmp	80006db8 <_malloc_r+0x1e4>
80006d2c:	f2 0a 16 09 	lsr	r10,r9,0x9
80006d30:	58 4a       	cp.w	r10,4
80006d32:	e0 8b 00 07 	brhi	80006d40 <_malloc_r+0x16c>
80006d36:	f2 0a 16 06 	lsr	r10,r9,0x6
80006d3a:	2c 8a       	sub	r10,-56
80006d3c:	c2 08       	rjmp	80006d7c <_malloc_r+0x1a8>
80006d3e:	d7 03       	nop
80006d40:	59 4a       	cp.w	r10,20
80006d42:	e0 8b 00 04 	brhi	80006d4a <_malloc_r+0x176>
80006d46:	2a 5a       	sub	r10,-91
80006d48:	c1 a8       	rjmp	80006d7c <_malloc_r+0x1a8>
80006d4a:	e0 4a 00 54 	cp.w	r10,84
80006d4e:	e0 8b 00 06 	brhi	80006d5a <_malloc_r+0x186>
80006d52:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006d56:	29 2a       	sub	r10,-110
80006d58:	c1 28       	rjmp	80006d7c <_malloc_r+0x1a8>
80006d5a:	e0 4a 01 54 	cp.w	r10,340
80006d5e:	e0 8b 00 06 	brhi	80006d6a <_malloc_r+0x196>
80006d62:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006d66:	28 9a       	sub	r10,-119
80006d68:	c0 a8       	rjmp	80006d7c <_malloc_r+0x1a8>
80006d6a:	e0 4a 05 54 	cp.w	r10,1364
80006d6e:	e0 88 00 04 	brls	80006d76 <_malloc_r+0x1a2>
80006d72:	37 ea       	mov	r10,126
80006d74:	c0 48       	rjmp	80006d7c <_malloc_r+0x1a8>
80006d76:	f2 0a 16 12 	lsr	r10,r9,0x12
80006d7a:	28 4a       	sub	r10,-124
80006d7c:	e0 6b 05 44 	mov	r11,1348
80006d80:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006d84:	68 28       	ld.w	r8,r4[0x8]
80006d86:	08 38       	cp.w	r8,r4
80006d88:	c0 e1       	brne	80006da4 <_malloc_r+0x1d0>
80006d8a:	76 19       	ld.w	r9,r11[0x4]
80006d8c:	a3 4a       	asr	r10,0x2
80006d8e:	30 1e       	mov	lr,1
80006d90:	fc 0a 09 4a 	lsl	r10,lr,r10
80006d94:	f3 ea 10 0a 	or	r10,r9,r10
80006d98:	10 99       	mov	r9,r8
80006d9a:	97 1a       	st.w	r11[0x4],r10
80006d9c:	c0 a8       	rjmp	80006db0 <_malloc_r+0x1dc>
80006d9e:	70 28       	ld.w	r8,r8[0x8]
80006da0:	08 38       	cp.w	r8,r4
80006da2:	c0 60       	breq	80006dae <_malloc_r+0x1da>
80006da4:	70 1a       	ld.w	r10,r8[0x4]
80006da6:	e0 1a ff fc 	andl	r10,0xfffc
80006daa:	14 39       	cp.w	r9,r10
80006dac:	cf 93       	brcs	80006d9e <_malloc_r+0x1ca>
80006dae:	70 39       	ld.w	r9,r8[0xc]
80006db0:	8d 39       	st.w	r6[0xc],r9
80006db2:	8d 28       	st.w	r6[0x8],r8
80006db4:	91 36       	st.w	r8[0xc],r6
80006db6:	93 26       	st.w	r9[0x8],r6
80006db8:	e6 08 14 02 	asr	r8,r3,0x2
80006dbc:	30 1b       	mov	r11,1
80006dbe:	e0 64 05 44 	mov	r4,1348
80006dc2:	f6 08 09 4b 	lsl	r11,r11,r8
80006dc6:	68 18       	ld.w	r8,r4[0x4]
80006dc8:	10 3b       	cp.w	r11,r8
80006dca:	e0 8b 00 6b 	brhi	80006ea0 <_malloc_r+0x2cc>
80006dce:	f7 e8 00 09 	and	r9,r11,r8
80006dd2:	c0 b1       	brne	80006de8 <_malloc_r+0x214>
80006dd4:	e0 13 ff fc 	andl	r3,0xfffc
80006dd8:	a1 7b       	lsl	r11,0x1
80006dda:	2f c3       	sub	r3,-4
80006ddc:	c0 38       	rjmp	80006de2 <_malloc_r+0x20e>
80006dde:	2f c3       	sub	r3,-4
80006de0:	a1 7b       	lsl	r11,0x1
80006de2:	f7 e8 00 09 	and	r9,r11,r8
80006de6:	cf c0       	breq	80006dde <_malloc_r+0x20a>
80006de8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006dec:	06 92       	mov	r2,r3
80006dee:	1c 91       	mov	r1,lr
80006df0:	62 36       	ld.w	r6,r1[0xc]
80006df2:	c2 e8       	rjmp	80006e4e <_malloc_r+0x27a>
80006df4:	6c 1a       	ld.w	r10,r6[0x4]
80006df6:	e0 1a ff fc 	andl	r10,0xfffc
80006dfa:	f4 07 01 08 	sub	r8,r10,r7
80006dfe:	58 f8       	cp.w	r8,15
80006e00:	e0 8a 00 15 	brle	80006e2a <_malloc_r+0x256>
80006e04:	6c 3a       	ld.w	r10,r6[0xc]
80006e06:	6c 29       	ld.w	r9,r6[0x8]
80006e08:	95 29       	st.w	r10[0x8],r9
80006e0a:	93 3a       	st.w	r9[0xc],r10
80006e0c:	0e 99       	mov	r9,r7
80006e0e:	ec 07 00 07 	add	r7,r6,r7
80006e12:	a1 a9       	sbr	r9,0x0
80006e14:	99 37       	st.w	r12[0xc],r7
80006e16:	99 27       	st.w	r12[0x8],r7
80006e18:	8d 19       	st.w	r6[0x4],r9
80006e1a:	ee 08 09 08 	st.w	r7[r8],r8
80006e1e:	8f 2c       	st.w	r7[0x8],r12
80006e20:	8f 3c       	st.w	r7[0xc],r12
80006e22:	a1 a8       	sbr	r8,0x0
80006e24:	0a 9c       	mov	r12,r5
80006e26:	8f 18       	st.w	r7[0x4],r8
80006e28:	c0 d8       	rjmp	80006e42 <_malloc_r+0x26e>
80006e2a:	6c 39       	ld.w	r9,r6[0xc]
80006e2c:	58 08       	cp.w	r8,0
80006e2e:	c0 f5       	brlt	80006e4c <_malloc_r+0x278>
80006e30:	ec 0a 00 0a 	add	r10,r6,r10
80006e34:	74 18       	ld.w	r8,r10[0x4]
80006e36:	a1 a8       	sbr	r8,0x0
80006e38:	0a 9c       	mov	r12,r5
80006e3a:	95 18       	st.w	r10[0x4],r8
80006e3c:	6c 28       	ld.w	r8,r6[0x8]
80006e3e:	93 28       	st.w	r9[0x8],r8
80006e40:	91 39       	st.w	r8[0xc],r9
80006e42:	fe b0 f4 4d 	rcall	800056dc <__malloc_unlock>
80006e46:	ec cc ff f8 	sub	r12,r6,-8
80006e4a:	d8 32       	popm	r0-r7,pc
80006e4c:	12 96       	mov	r6,r9
80006e4e:	02 36       	cp.w	r6,r1
80006e50:	cd 21       	brne	80006df4 <_malloc_r+0x220>
80006e52:	2f f2       	sub	r2,-1
80006e54:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006e58:	c0 30       	breq	80006e5e <_malloc_r+0x28a>
80006e5a:	2f 81       	sub	r1,-8
80006e5c:	cc ab       	rjmp	80006df0 <_malloc_r+0x21c>
80006e5e:	1c 98       	mov	r8,lr
80006e60:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006e64:	c0 81       	brne	80006e74 <_malloc_r+0x2a0>
80006e66:	68 19       	ld.w	r9,r4[0x4]
80006e68:	f6 08 11 ff 	rsub	r8,r11,-1
80006e6c:	f3 e8 00 08 	and	r8,r9,r8
80006e70:	89 18       	st.w	r4[0x4],r8
80006e72:	c0 78       	rjmp	80006e80 <_malloc_r+0x2ac>
80006e74:	f0 c9 00 08 	sub	r9,r8,8
80006e78:	20 13       	sub	r3,1
80006e7a:	70 08       	ld.w	r8,r8[0x0]
80006e7c:	12 38       	cp.w	r8,r9
80006e7e:	cf 10       	breq	80006e60 <_malloc_r+0x28c>
80006e80:	a1 7b       	lsl	r11,0x1
80006e82:	68 18       	ld.w	r8,r4[0x4]
80006e84:	10 3b       	cp.w	r11,r8
80006e86:	e0 8b 00 0d 	brhi	80006ea0 <_malloc_r+0x2cc>
80006e8a:	58 0b       	cp.w	r11,0
80006e8c:	c0 a0       	breq	80006ea0 <_malloc_r+0x2cc>
80006e8e:	04 93       	mov	r3,r2
80006e90:	c0 38       	rjmp	80006e96 <_malloc_r+0x2c2>
80006e92:	2f c3       	sub	r3,-4
80006e94:	a1 7b       	lsl	r11,0x1
80006e96:	f7 e8 00 09 	and	r9,r11,r8
80006e9a:	ca 71       	brne	80006de8 <_malloc_r+0x214>
80006e9c:	cf bb       	rjmp	80006e92 <_malloc_r+0x2be>
80006e9e:	d7 03       	nop
80006ea0:	68 23       	ld.w	r3,r4[0x8]
80006ea2:	66 12       	ld.w	r2,r3[0x4]
80006ea4:	e0 12 ff fc 	andl	r2,0xfffc
80006ea8:	0e 32       	cp.w	r2,r7
80006eaa:	5f 39       	srlo	r9
80006eac:	e4 07 01 08 	sub	r8,r2,r7
80006eb0:	58 f8       	cp.w	r8,15
80006eb2:	5f aa       	srle	r10
80006eb4:	f5 e9 10 09 	or	r9,r10,r9
80006eb8:	e0 80 00 9a 	breq	80006fec <_malloc_r+0x418>
80006ebc:	e0 68 0d 58 	mov	r8,3416
80006ec0:	70 01       	ld.w	r1,r8[0x0]
80006ec2:	e0 68 09 50 	mov	r8,2384
80006ec6:	2f 01       	sub	r1,-16
80006ec8:	70 08       	ld.w	r8,r8[0x0]
80006eca:	0e 01       	add	r1,r7
80006ecc:	5b f8       	cp.w	r8,-1
80006ece:	c0 40       	breq	80006ed6 <_malloc_r+0x302>
80006ed0:	28 11       	sub	r1,-127
80006ed2:	e0 11 ff 80 	andl	r1,0xff80
80006ed6:	02 9b       	mov	r11,r1
80006ed8:	0a 9c       	mov	r12,r5
80006eda:	e0 a0 02 a5 	rcall	80007424 <_sbrk_r>
80006ede:	18 96       	mov	r6,r12
80006ee0:	5b fc       	cp.w	r12,-1
80006ee2:	c7 50       	breq	80006fcc <_malloc_r+0x3f8>
80006ee4:	e6 02 00 08 	add	r8,r3,r2
80006ee8:	10 3c       	cp.w	r12,r8
80006eea:	c0 32       	brcc	80006ef0 <_malloc_r+0x31c>
80006eec:	08 33       	cp.w	r3,r4
80006eee:	c6 f1       	brne	80006fcc <_malloc_r+0x3f8>
80006ef0:	e0 6a 0d 5c 	mov	r10,3420
80006ef4:	74 09       	ld.w	r9,r10[0x0]
80006ef6:	e2 09 00 09 	add	r9,r1,r9
80006efa:	95 09       	st.w	r10[0x0],r9
80006efc:	10 36       	cp.w	r6,r8
80006efe:	c0 a1       	brne	80006f12 <_malloc_r+0x33e>
80006f00:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006f04:	c0 71       	brne	80006f12 <_malloc_r+0x33e>
80006f06:	e2 02 00 02 	add	r2,r1,r2
80006f0a:	68 28       	ld.w	r8,r4[0x8]
80006f0c:	a1 a2       	sbr	r2,0x0
80006f0e:	91 12       	st.w	r8[0x4],r2
80006f10:	c4 f8       	rjmp	80006fae <_malloc_r+0x3da>
80006f12:	e0 6a 09 50 	mov	r10,2384
80006f16:	74 0b       	ld.w	r11,r10[0x0]
80006f18:	5b fb       	cp.w	r11,-1
80006f1a:	c0 31       	brne	80006f20 <_malloc_r+0x34c>
80006f1c:	95 06       	st.w	r10[0x0],r6
80006f1e:	c0 78       	rjmp	80006f2c <_malloc_r+0x358>
80006f20:	ec 09 00 09 	add	r9,r6,r9
80006f24:	e0 6a 0d 5c 	mov	r10,3420
80006f28:	10 19       	sub	r9,r8
80006f2a:	95 09       	st.w	r10[0x0],r9
80006f2c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006f30:	f0 09 11 08 	rsub	r9,r8,8
80006f34:	58 08       	cp.w	r8,0
80006f36:	f2 08 17 10 	movne	r8,r9
80006f3a:	ed d8 e1 06 	addne	r6,r6,r8
80006f3e:	28 08       	sub	r8,-128
80006f40:	ec 01 00 01 	add	r1,r6,r1
80006f44:	0a 9c       	mov	r12,r5
80006f46:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006f4a:	f0 01 01 01 	sub	r1,r8,r1
80006f4e:	02 9b       	mov	r11,r1
80006f50:	e0 a0 02 6a 	rcall	80007424 <_sbrk_r>
80006f54:	e0 68 0d 5c 	mov	r8,3420
80006f58:	5b fc       	cp.w	r12,-1
80006f5a:	ec 0c 17 00 	moveq	r12,r6
80006f5e:	f9 b1 00 00 	moveq	r1,0
80006f62:	70 09       	ld.w	r9,r8[0x0]
80006f64:	0c 1c       	sub	r12,r6
80006f66:	89 26       	st.w	r4[0x8],r6
80006f68:	02 0c       	add	r12,r1
80006f6a:	12 01       	add	r1,r9
80006f6c:	a1 ac       	sbr	r12,0x0
80006f6e:	91 01       	st.w	r8[0x0],r1
80006f70:	8d 1c       	st.w	r6[0x4],r12
80006f72:	08 33       	cp.w	r3,r4
80006f74:	c1 d0       	breq	80006fae <_malloc_r+0x3da>
80006f76:	58 f2       	cp.w	r2,15
80006f78:	e0 8b 00 05 	brhi	80006f82 <_malloc_r+0x3ae>
80006f7c:	30 18       	mov	r8,1
80006f7e:	8d 18       	st.w	r6[0x4],r8
80006f80:	c2 68       	rjmp	80006fcc <_malloc_r+0x3f8>
80006f82:	30 59       	mov	r9,5
80006f84:	20 c2       	sub	r2,12
80006f86:	e0 12 ff f8 	andl	r2,0xfff8
80006f8a:	e6 02 00 08 	add	r8,r3,r2
80006f8e:	91 29       	st.w	r8[0x8],r9
80006f90:	91 19       	st.w	r8[0x4],r9
80006f92:	66 18       	ld.w	r8,r3[0x4]
80006f94:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f98:	e5 e8 10 08 	or	r8,r2,r8
80006f9c:	87 18       	st.w	r3[0x4],r8
80006f9e:	58 f2       	cp.w	r2,15
80006fa0:	e0 88 00 07 	brls	80006fae <_malloc_r+0x3da>
80006fa4:	e6 cb ff f8 	sub	r11,r3,-8
80006fa8:	0a 9c       	mov	r12,r5
80006faa:	e0 a0 1c 77 	rcall	8000a898 <_free_r>
80006fae:	e0 69 0d 54 	mov	r9,3412
80006fb2:	72 0a       	ld.w	r10,r9[0x0]
80006fb4:	e0 68 0d 5c 	mov	r8,3420
80006fb8:	70 08       	ld.w	r8,r8[0x0]
80006fba:	14 38       	cp.w	r8,r10
80006fbc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006fc0:	e0 69 0d 50 	mov	r9,3408
80006fc4:	72 0a       	ld.w	r10,r9[0x0]
80006fc6:	14 38       	cp.w	r8,r10
80006fc8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006fcc:	68 28       	ld.w	r8,r4[0x8]
80006fce:	70 18       	ld.w	r8,r8[0x4]
80006fd0:	e0 18 ff fc 	andl	r8,0xfffc
80006fd4:	0e 38       	cp.w	r8,r7
80006fd6:	5f 39       	srlo	r9
80006fd8:	0e 18       	sub	r8,r7
80006fda:	58 f8       	cp.w	r8,15
80006fdc:	5f aa       	srle	r10
80006fde:	f5 e9 10 09 	or	r9,r10,r9
80006fe2:	c0 50       	breq	80006fec <_malloc_r+0x418>
80006fe4:	0a 9c       	mov	r12,r5
80006fe6:	fe b0 f3 7b 	rcall	800056dc <__malloc_unlock>
80006fea:	d8 3a       	popm	r0-r7,pc,r12=0
80006fec:	68 26       	ld.w	r6,r4[0x8]
80006fee:	a1 a8       	sbr	r8,0x0
80006ff0:	0e 99       	mov	r9,r7
80006ff2:	a1 a9       	sbr	r9,0x0
80006ff4:	8d 19       	st.w	r6[0x4],r9
80006ff6:	ec 07 00 07 	add	r7,r6,r7
80006ffa:	0a 9c       	mov	r12,r5
80006ffc:	89 27       	st.w	r4[0x8],r7
80006ffe:	8f 18       	st.w	r7[0x4],r8
80007000:	fe b0 f3 6e 	rcall	800056dc <__malloc_unlock>
80007004:	ec cc ff f8 	sub	r12,r6,-8
80007008:	d8 32       	popm	r0-r7,pc
8000700a:	d7 03       	nop

8000700c <memcpy>:
8000700c:	58 8a       	cp.w	r10,8
8000700e:	c2 f5       	brlt	8000706c <memcpy+0x60>
80007010:	f9 eb 10 09 	or	r9,r12,r11
80007014:	e2 19 00 03 	andl	r9,0x3,COH
80007018:	e0 81 00 97 	brne	80007146 <memcpy+0x13a>
8000701c:	e0 4a 00 20 	cp.w	r10,32
80007020:	c3 b4       	brge	80007096 <memcpy+0x8a>
80007022:	f4 08 14 02 	asr	r8,r10,0x2
80007026:	f0 09 11 08 	rsub	r9,r8,8
8000702a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000702e:	76 69       	ld.w	r9,r11[0x18]
80007030:	99 69       	st.w	r12[0x18],r9
80007032:	76 59       	ld.w	r9,r11[0x14]
80007034:	99 59       	st.w	r12[0x14],r9
80007036:	76 49       	ld.w	r9,r11[0x10]
80007038:	99 49       	st.w	r12[0x10],r9
8000703a:	76 39       	ld.w	r9,r11[0xc]
8000703c:	99 39       	st.w	r12[0xc],r9
8000703e:	76 29       	ld.w	r9,r11[0x8]
80007040:	99 29       	st.w	r12[0x8],r9
80007042:	76 19       	ld.w	r9,r11[0x4]
80007044:	99 19       	st.w	r12[0x4],r9
80007046:	76 09       	ld.w	r9,r11[0x0]
80007048:	99 09       	st.w	r12[0x0],r9
8000704a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000704e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007052:	e0 1a 00 03 	andl	r10,0x3
80007056:	f4 0a 11 04 	rsub	r10,r10,4
8000705a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000705e:	17 a9       	ld.ub	r9,r11[0x2]
80007060:	b0 a9       	st.b	r8[0x2],r9
80007062:	17 99       	ld.ub	r9,r11[0x1]
80007064:	b0 99       	st.b	r8[0x1],r9
80007066:	17 89       	ld.ub	r9,r11[0x0]
80007068:	b0 89       	st.b	r8[0x0],r9
8000706a:	5e fc       	retal	r12
8000706c:	f4 0a 11 09 	rsub	r10,r10,9
80007070:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007074:	17 f9       	ld.ub	r9,r11[0x7]
80007076:	b8 f9       	st.b	r12[0x7],r9
80007078:	17 e9       	ld.ub	r9,r11[0x6]
8000707a:	b8 e9       	st.b	r12[0x6],r9
8000707c:	17 d9       	ld.ub	r9,r11[0x5]
8000707e:	b8 d9       	st.b	r12[0x5],r9
80007080:	17 c9       	ld.ub	r9,r11[0x4]
80007082:	b8 c9       	st.b	r12[0x4],r9
80007084:	17 b9       	ld.ub	r9,r11[0x3]
80007086:	b8 b9       	st.b	r12[0x3],r9
80007088:	17 a9       	ld.ub	r9,r11[0x2]
8000708a:	b8 a9       	st.b	r12[0x2],r9
8000708c:	17 99       	ld.ub	r9,r11[0x1]
8000708e:	b8 99       	st.b	r12[0x1],r9
80007090:	17 89       	ld.ub	r9,r11[0x0]
80007092:	b8 89       	st.b	r12[0x0],r9
80007094:	5e fc       	retal	r12
80007096:	eb cd 40 c0 	pushm	r6-r7,lr
8000709a:	18 99       	mov	r9,r12
8000709c:	22 0a       	sub	r10,32
8000709e:	b7 07       	ld.d	r6,r11++
800070a0:	b3 26       	st.d	r9++,r6
800070a2:	b7 07       	ld.d	r6,r11++
800070a4:	b3 26       	st.d	r9++,r6
800070a6:	b7 07       	ld.d	r6,r11++
800070a8:	b3 26       	st.d	r9++,r6
800070aa:	b7 07       	ld.d	r6,r11++
800070ac:	b3 26       	st.d	r9++,r6
800070ae:	22 0a       	sub	r10,32
800070b0:	cf 74       	brge	8000709e <memcpy+0x92>
800070b2:	2f 0a       	sub	r10,-16
800070b4:	c0 65       	brlt	800070c0 <memcpy+0xb4>
800070b6:	b7 07       	ld.d	r6,r11++
800070b8:	b3 26       	st.d	r9++,r6
800070ba:	b7 07       	ld.d	r6,r11++
800070bc:	b3 26       	st.d	r9++,r6
800070be:	21 0a       	sub	r10,16
800070c0:	5c 3a       	neg	r10
800070c2:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800070c6:	d7 03       	nop
800070c8:	d7 03       	nop
800070ca:	f7 36 00 0e 	ld.ub	r6,r11[14]
800070ce:	f3 66 00 0e 	st.b	r9[14],r6
800070d2:	f7 36 00 0d 	ld.ub	r6,r11[13]
800070d6:	f3 66 00 0d 	st.b	r9[13],r6
800070da:	f7 36 00 0c 	ld.ub	r6,r11[12]
800070de:	f3 66 00 0c 	st.b	r9[12],r6
800070e2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800070e6:	f3 66 00 0b 	st.b	r9[11],r6
800070ea:	f7 36 00 0a 	ld.ub	r6,r11[10]
800070ee:	f3 66 00 0a 	st.b	r9[10],r6
800070f2:	f7 36 00 09 	ld.ub	r6,r11[9]
800070f6:	f3 66 00 09 	st.b	r9[9],r6
800070fa:	f7 36 00 08 	ld.ub	r6,r11[8]
800070fe:	f3 66 00 08 	st.b	r9[8],r6
80007102:	f7 36 00 07 	ld.ub	r6,r11[7]
80007106:	f3 66 00 07 	st.b	r9[7],r6
8000710a:	f7 36 00 06 	ld.ub	r6,r11[6]
8000710e:	f3 66 00 06 	st.b	r9[6],r6
80007112:	f7 36 00 05 	ld.ub	r6,r11[5]
80007116:	f3 66 00 05 	st.b	r9[5],r6
8000711a:	f7 36 00 04 	ld.ub	r6,r11[4]
8000711e:	f3 66 00 04 	st.b	r9[4],r6
80007122:	f7 36 00 03 	ld.ub	r6,r11[3]
80007126:	f3 66 00 03 	st.b	r9[3],r6
8000712a:	f7 36 00 02 	ld.ub	r6,r11[2]
8000712e:	f3 66 00 02 	st.b	r9[2],r6
80007132:	f7 36 00 01 	ld.ub	r6,r11[1]
80007136:	f3 66 00 01 	st.b	r9[1],r6
8000713a:	f7 36 00 00 	ld.ub	r6,r11[0]
8000713e:	f3 66 00 00 	st.b	r9[0],r6
80007142:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007146:	20 1a       	sub	r10,1
80007148:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000714c:	f8 0a 0b 09 	st.b	r12[r10],r9
80007150:	cf b1       	brne	80007146 <memcpy+0x13a>
80007152:	5e fc       	retal	r12

80007154 <memset>:
80007154:	18 98       	mov	r8,r12
80007156:	c0 38       	rjmp	8000715c <memset+0x8>
80007158:	10 cb       	st.b	r8++,r11
8000715a:	20 1a       	sub	r10,1
8000715c:	58 0a       	cp.w	r10,0
8000715e:	cf d1       	brne	80007158 <memset+0x4>
80007160:	5e fc       	retal	r12
80007162:	d7 03       	nop

80007164 <_realloc_r>:
80007164:	d4 31       	pushm	r0-r7,lr
80007166:	20 1d       	sub	sp,4
80007168:	16 94       	mov	r4,r11
8000716a:	18 92       	mov	r2,r12
8000716c:	14 9b       	mov	r11,r10
8000716e:	58 04       	cp.w	r4,0
80007170:	c0 51       	brne	8000717a <_realloc_r+0x16>
80007172:	fe b0 fd 31 	rcall	80006bd4 <_malloc_r>
80007176:	18 95       	mov	r5,r12
80007178:	c5 39       	rjmp	8000741e <_realloc_r+0x2ba>
8000717a:	50 0a       	stdsp	sp[0x0],r10
8000717c:	fe b0 f2 aa 	rcall	800056d0 <__malloc_lock>
80007180:	40 0b       	lddsp	r11,sp[0x0]
80007182:	f6 c8 ff f5 	sub	r8,r11,-11
80007186:	e8 c1 00 08 	sub	r1,r4,8
8000718a:	10 96       	mov	r6,r8
8000718c:	62 1c       	ld.w	r12,r1[0x4]
8000718e:	e0 16 ff f8 	andl	r6,0xfff8
80007192:	59 68       	cp.w	r8,22
80007194:	f9 b6 08 10 	movls	r6,16
80007198:	16 36       	cp.w	r6,r11
8000719a:	5f 38       	srlo	r8
8000719c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800071a0:	c0 50       	breq	800071aa <_realloc_r+0x46>
800071a2:	30 c8       	mov	r8,12
800071a4:	30 05       	mov	r5,0
800071a6:	85 38       	st.w	r2[0xc],r8
800071a8:	c3 b9       	rjmp	8000741e <_realloc_r+0x2ba>
800071aa:	18 90       	mov	r0,r12
800071ac:	e0 10 ff fc 	andl	r0,0xfffc
800071b0:	0c 30       	cp.w	r0,r6
800071b2:	e0 84 01 0b 	brge	800073c8 <_realloc_r+0x264>
800071b6:	e0 68 05 44 	mov	r8,1348
800071ba:	e2 00 00 09 	add	r9,r1,r0
800071be:	70 25       	ld.w	r5,r8[0x8]
800071c0:	0a 39       	cp.w	r9,r5
800071c2:	c0 90       	breq	800071d4 <_realloc_r+0x70>
800071c4:	72 1a       	ld.w	r10,r9[0x4]
800071c6:	a1 ca       	cbr	r10,0x0
800071c8:	f2 0a 00 0a 	add	r10,r9,r10
800071cc:	74 1a       	ld.w	r10,r10[0x4]
800071ce:	ed ba 00 00 	bld	r10,0x0
800071d2:	c2 20       	breq	80007216 <_realloc_r+0xb2>
800071d4:	72 1a       	ld.w	r10,r9[0x4]
800071d6:	e0 1a ff fc 	andl	r10,0xfffc
800071da:	f4 00 00 03 	add	r3,r10,r0
800071de:	0a 39       	cp.w	r9,r5
800071e0:	c1 31       	brne	80007206 <_realloc_r+0xa2>
800071e2:	ec c7 ff f0 	sub	r7,r6,-16
800071e6:	0e 33       	cp.w	r3,r7
800071e8:	c1 95       	brlt	8000721a <_realloc_r+0xb6>
800071ea:	e2 06 00 09 	add	r9,r1,r6
800071ee:	0c 13       	sub	r3,r6
800071f0:	a1 a3       	sbr	r3,0x0
800071f2:	93 13       	st.w	r9[0x4],r3
800071f4:	91 29       	st.w	r8[0x8],r9
800071f6:	04 9c       	mov	r12,r2
800071f8:	62 18       	ld.w	r8,r1[0x4]
800071fa:	08 95       	mov	r5,r4
800071fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007200:	10 46       	or	r6,r8
80007202:	83 16       	st.w	r1[0x4],r6
80007204:	c0 b9       	rjmp	8000741a <_realloc_r+0x2b6>
80007206:	0c 33       	cp.w	r3,r6
80007208:	c0 95       	brlt	8000721a <_realloc_r+0xb6>
8000720a:	72 28       	ld.w	r8,r9[0x8]
8000720c:	02 97       	mov	r7,r1
8000720e:	72 39       	ld.w	r9,r9[0xc]
80007210:	93 28       	st.w	r9[0x8],r8
80007212:	91 39       	st.w	r8[0xc],r9
80007214:	cd c8       	rjmp	800073cc <_realloc_r+0x268>
80007216:	30 0a       	mov	r10,0
80007218:	14 99       	mov	r9,r10
8000721a:	ed bc 00 00 	bld	r12,0x0
8000721e:	e0 80 00 95 	breq	80007348 <_realloc_r+0x1e4>
80007222:	62 07       	ld.w	r7,r1[0x0]
80007224:	e2 07 01 07 	sub	r7,r1,r7
80007228:	6e 1c       	ld.w	r12,r7[0x4]
8000722a:	e0 1c ff fc 	andl	r12,0xfffc
8000722e:	58 09       	cp.w	r9,0
80007230:	c5 60       	breq	800072dc <_realloc_r+0x178>
80007232:	f8 00 00 03 	add	r3,r12,r0
80007236:	0a 39       	cp.w	r9,r5
80007238:	c4 81       	brne	800072c8 <_realloc_r+0x164>
8000723a:	14 03       	add	r3,r10
8000723c:	ec c9 ff f0 	sub	r9,r6,-16
80007240:	12 33       	cp.w	r3,r9
80007242:	c4 d5       	brlt	800072dc <_realloc_r+0x178>
80007244:	6e 3a       	ld.w	r10,r7[0xc]
80007246:	6e 29       	ld.w	r9,r7[0x8]
80007248:	95 29       	st.w	r10[0x8],r9
8000724a:	93 3a       	st.w	r9[0xc],r10
8000724c:	ee c5 ff f8 	sub	r5,r7,-8
80007250:	e0 ca 00 04 	sub	r10,r0,4
80007254:	e0 4a 00 24 	cp.w	r10,36
80007258:	e0 8b 00 25 	brhi	800072a2 <_realloc_r+0x13e>
8000725c:	0a 99       	mov	r9,r5
8000725e:	59 3a       	cp.w	r10,19
80007260:	e0 88 00 1a 	brls	80007294 <_realloc_r+0x130>
80007264:	09 09       	ld.w	r9,r4++
80007266:	8b 09       	st.w	r5[0x0],r9
80007268:	09 09       	ld.w	r9,r4++
8000726a:	8f 39       	st.w	r7[0xc],r9
8000726c:	ee c9 ff f0 	sub	r9,r7,-16
80007270:	59 ba       	cp.w	r10,27
80007272:	e0 88 00 11 	brls	80007294 <_realloc_r+0x130>
80007276:	09 0b       	ld.w	r11,r4++
80007278:	93 0b       	st.w	r9[0x0],r11
8000727a:	09 09       	ld.w	r9,r4++
8000727c:	8f 59       	st.w	r7[0x14],r9
8000727e:	ee c9 ff e8 	sub	r9,r7,-24
80007282:	e0 4a 00 24 	cp.w	r10,36
80007286:	c0 71       	brne	80007294 <_realloc_r+0x130>
80007288:	09 0a       	ld.w	r10,r4++
8000728a:	93 0a       	st.w	r9[0x0],r10
8000728c:	ee c9 ff e0 	sub	r9,r7,-32
80007290:	09 0a       	ld.w	r10,r4++
80007292:	8f 7a       	st.w	r7[0x1c],r10
80007294:	09 0a       	ld.w	r10,r4++
80007296:	12 aa       	st.w	r9++,r10
80007298:	68 0a       	ld.w	r10,r4[0x0]
8000729a:	93 0a       	st.w	r9[0x0],r10
8000729c:	68 1a       	ld.w	r10,r4[0x4]
8000729e:	93 1a       	st.w	r9[0x4],r10
800072a0:	c0 78       	rjmp	800072ae <_realloc_r+0x14a>
800072a2:	50 08       	stdsp	sp[0x0],r8
800072a4:	08 9b       	mov	r11,r4
800072a6:	0a 9c       	mov	r12,r5
800072a8:	e0 a0 1d 9b 	rcall	8000adde <memmove>
800072ac:	40 08       	lddsp	r8,sp[0x0]
800072ae:	ee 06 00 09 	add	r9,r7,r6
800072b2:	0c 13       	sub	r3,r6
800072b4:	a1 a3       	sbr	r3,0x0
800072b6:	93 13       	st.w	r9[0x4],r3
800072b8:	91 29       	st.w	r8[0x8],r9
800072ba:	04 9c       	mov	r12,r2
800072bc:	6e 18       	ld.w	r8,r7[0x4]
800072be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800072c2:	10 46       	or	r6,r8
800072c4:	8f 16       	st.w	r7[0x4],r6
800072c6:	ca a8       	rjmp	8000741a <_realloc_r+0x2b6>
800072c8:	14 03       	add	r3,r10
800072ca:	0c 33       	cp.w	r3,r6
800072cc:	c0 85       	brlt	800072dc <_realloc_r+0x178>
800072ce:	72 28       	ld.w	r8,r9[0x8]
800072d0:	72 39       	ld.w	r9,r9[0xc]
800072d2:	93 28       	st.w	r9[0x8],r8
800072d4:	91 39       	st.w	r8[0xc],r9
800072d6:	6e 28       	ld.w	r8,r7[0x8]
800072d8:	6e 39       	ld.w	r9,r7[0xc]
800072da:	c0 78       	rjmp	800072e8 <_realloc_r+0x184>
800072dc:	f8 00 00 03 	add	r3,r12,r0
800072e0:	0c 33       	cp.w	r3,r6
800072e2:	c3 35       	brlt	80007348 <_realloc_r+0x1e4>
800072e4:	6e 39       	ld.w	r9,r7[0xc]
800072e6:	6e 28       	ld.w	r8,r7[0x8]
800072e8:	93 28       	st.w	r9[0x8],r8
800072ea:	91 39       	st.w	r8[0xc],r9
800072ec:	e0 ca 00 04 	sub	r10,r0,4
800072f0:	ee cc ff f8 	sub	r12,r7,-8
800072f4:	e0 4a 00 24 	cp.w	r10,36
800072f8:	e0 8b 00 24 	brhi	80007340 <_realloc_r+0x1dc>
800072fc:	59 3a       	cp.w	r10,19
800072fe:	e0 88 00 1a 	brls	80007332 <_realloc_r+0x1ce>
80007302:	09 08       	ld.w	r8,r4++
80007304:	99 08       	st.w	r12[0x0],r8
80007306:	09 08       	ld.w	r8,r4++
80007308:	8f 38       	st.w	r7[0xc],r8
8000730a:	ee cc ff f0 	sub	r12,r7,-16
8000730e:	59 ba       	cp.w	r10,27
80007310:	e0 88 00 11 	brls	80007332 <_realloc_r+0x1ce>
80007314:	09 08       	ld.w	r8,r4++
80007316:	99 08       	st.w	r12[0x0],r8
80007318:	09 08       	ld.w	r8,r4++
8000731a:	8f 58       	st.w	r7[0x14],r8
8000731c:	ee cc ff e8 	sub	r12,r7,-24
80007320:	e0 4a 00 24 	cp.w	r10,36
80007324:	c0 71       	brne	80007332 <_realloc_r+0x1ce>
80007326:	09 08       	ld.w	r8,r4++
80007328:	99 08       	st.w	r12[0x0],r8
8000732a:	ee cc ff e0 	sub	r12,r7,-32
8000732e:	09 08       	ld.w	r8,r4++
80007330:	8f 78       	st.w	r7[0x1c],r8
80007332:	09 08       	ld.w	r8,r4++
80007334:	18 a8       	st.w	r12++,r8
80007336:	68 08       	ld.w	r8,r4[0x0]
80007338:	99 08       	st.w	r12[0x0],r8
8000733a:	68 18       	ld.w	r8,r4[0x4]
8000733c:	99 18       	st.w	r12[0x4],r8
8000733e:	c4 78       	rjmp	800073cc <_realloc_r+0x268>
80007340:	08 9b       	mov	r11,r4
80007342:	e0 a0 1d 4e 	rcall	8000adde <memmove>
80007346:	c4 38       	rjmp	800073cc <_realloc_r+0x268>
80007348:	04 9c       	mov	r12,r2
8000734a:	fe b0 fc 45 	rcall	80006bd4 <_malloc_r>
8000734e:	18 95       	mov	r5,r12
80007350:	c3 a0       	breq	800073c4 <_realloc_r+0x260>
80007352:	62 18       	ld.w	r8,r1[0x4]
80007354:	f8 c9 00 08 	sub	r9,r12,8
80007358:	a1 c8       	cbr	r8,0x0
8000735a:	e2 08 00 08 	add	r8,r1,r8
8000735e:	10 39       	cp.w	r9,r8
80007360:	c0 71       	brne	8000736e <_realloc_r+0x20a>
80007362:	72 13       	ld.w	r3,r9[0x4]
80007364:	02 97       	mov	r7,r1
80007366:	e0 13 ff fc 	andl	r3,0xfffc
8000736a:	00 03       	add	r3,r0
8000736c:	c3 08       	rjmp	800073cc <_realloc_r+0x268>
8000736e:	e0 ca 00 04 	sub	r10,r0,4
80007372:	e0 4a 00 24 	cp.w	r10,36
80007376:	e0 8b 00 20 	brhi	800073b6 <_realloc_r+0x252>
8000737a:	08 99       	mov	r9,r4
8000737c:	18 98       	mov	r8,r12
8000737e:	59 3a       	cp.w	r10,19
80007380:	e0 88 00 14 	brls	800073a8 <_realloc_r+0x244>
80007384:	13 0b       	ld.w	r11,r9++
80007386:	10 ab       	st.w	r8++,r11
80007388:	13 0b       	ld.w	r11,r9++
8000738a:	10 ab       	st.w	r8++,r11
8000738c:	59 ba       	cp.w	r10,27
8000738e:	e0 88 00 0d 	brls	800073a8 <_realloc_r+0x244>
80007392:	13 0b       	ld.w	r11,r9++
80007394:	10 ab       	st.w	r8++,r11
80007396:	13 0b       	ld.w	r11,r9++
80007398:	10 ab       	st.w	r8++,r11
8000739a:	e0 4a 00 24 	cp.w	r10,36
8000739e:	c0 51       	brne	800073a8 <_realloc_r+0x244>
800073a0:	13 0a       	ld.w	r10,r9++
800073a2:	10 aa       	st.w	r8++,r10
800073a4:	13 0a       	ld.w	r10,r9++
800073a6:	10 aa       	st.w	r8++,r10
800073a8:	13 0a       	ld.w	r10,r9++
800073aa:	10 aa       	st.w	r8++,r10
800073ac:	72 0a       	ld.w	r10,r9[0x0]
800073ae:	91 0a       	st.w	r8[0x0],r10
800073b0:	72 19       	ld.w	r9,r9[0x4]
800073b2:	91 19       	st.w	r8[0x4],r9
800073b4:	c0 48       	rjmp	800073bc <_realloc_r+0x258>
800073b6:	08 9b       	mov	r11,r4
800073b8:	e0 a0 1d 13 	rcall	8000adde <memmove>
800073bc:	08 9b       	mov	r11,r4
800073be:	04 9c       	mov	r12,r2
800073c0:	e0 a0 1a 6c 	rcall	8000a898 <_free_r>
800073c4:	04 9c       	mov	r12,r2
800073c6:	c2 a8       	rjmp	8000741a <_realloc_r+0x2b6>
800073c8:	00 93       	mov	r3,r0
800073ca:	02 97       	mov	r7,r1
800073cc:	e6 06 01 09 	sub	r9,r3,r6
800073d0:	6e 18       	ld.w	r8,r7[0x4]
800073d2:	58 f9       	cp.w	r9,15
800073d4:	e0 88 00 16 	brls	80007400 <_realloc_r+0x29c>
800073d8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073dc:	ed e8 10 08 	or	r8,r6,r8
800073e0:	8f 18       	st.w	r7[0x4],r8
800073e2:	12 98       	mov	r8,r9
800073e4:	a1 a8       	sbr	r8,0x0
800073e6:	ee 06 00 0b 	add	r11,r7,r6
800073ea:	f6 09 00 09 	add	r9,r11,r9
800073ee:	97 18       	st.w	r11[0x4],r8
800073f0:	72 18       	ld.w	r8,r9[0x4]
800073f2:	a1 a8       	sbr	r8,0x0
800073f4:	2f 8b       	sub	r11,-8
800073f6:	93 18       	st.w	r9[0x4],r8
800073f8:	04 9c       	mov	r12,r2
800073fa:	e0 a0 1a 4f 	rcall	8000a898 <_free_r>
800073fe:	c0 b8       	rjmp	80007414 <_realloc_r+0x2b0>
80007400:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007404:	e7 e8 10 08 	or	r8,r3,r8
80007408:	8f 18       	st.w	r7[0x4],r8
8000740a:	ee 03 00 03 	add	r3,r7,r3
8000740e:	66 18       	ld.w	r8,r3[0x4]
80007410:	a1 a8       	sbr	r8,0x0
80007412:	87 18       	st.w	r3[0x4],r8
80007414:	04 9c       	mov	r12,r2
80007416:	ee c5 ff f8 	sub	r5,r7,-8
8000741a:	fe b0 f1 61 	rcall	800056dc <__malloc_unlock>
8000741e:	0a 9c       	mov	r12,r5
80007420:	2f fd       	sub	sp,-4
80007422:	d8 32       	popm	r0-r7,pc

80007424 <_sbrk_r>:
80007424:	d4 21       	pushm	r4-r7,lr
80007426:	30 08       	mov	r8,0
80007428:	18 97       	mov	r7,r12
8000742a:	e0 66 41 0c 	mov	r6,16652
8000742e:	16 9c       	mov	r12,r11
80007430:	8d 08       	st.w	r6[0x0],r8
80007432:	c9 1c       	rcall	80007554 <_sbrk>
80007434:	5b fc       	cp.w	r12,-1
80007436:	c0 51       	brne	80007440 <_sbrk_r+0x1c>
80007438:	6c 08       	ld.w	r8,r6[0x0]
8000743a:	58 08       	cp.w	r8,0
8000743c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007440:	d8 22       	popm	r4-r7,pc
80007442:	d7 03       	nop

80007444 <sprintf>:
80007444:	d4 01       	pushm	lr
80007446:	21 7d       	sub	sp,92
80007448:	e0 68 ff ff 	mov	r8,65535
8000744c:	ea 18 7f ff 	orh	r8,0x7fff
80007450:	50 58       	stdsp	sp[0x14],r8
80007452:	50 28       	stdsp	sp[0x8],r8
80007454:	e0 68 02 08 	mov	r8,520
80007458:	ba 68       	st.h	sp[0xc],r8
8000745a:	3f f8       	mov	r8,-1
8000745c:	ba 78       	st.h	sp[0xe],r8
8000745e:	e0 68 0a 44 	mov	r8,2628
80007462:	50 4c       	stdsp	sp[0x10],r12
80007464:	16 9a       	mov	r10,r11
80007466:	50 0c       	stdsp	sp[0x0],r12
80007468:	fa c9 ff a0 	sub	r9,sp,-96
8000746c:	70 0c       	ld.w	r12,r8[0x0]
8000746e:	1a 9b       	mov	r11,sp
80007470:	e0 a0 02 26 	rcall	800078bc <_vfprintf_r>
80007474:	30 09       	mov	r9,0
80007476:	40 08       	lddsp	r8,sp[0x0]
80007478:	b0 89       	st.b	r8[0x0],r9
8000747a:	2e 9d       	sub	sp,-92
8000747c:	d8 02       	popm	pc
8000747e:	d7 03       	nop

80007480 <strlen>:
80007480:	30 09       	mov	r9,0
80007482:	18 98       	mov	r8,r12
80007484:	c0 28       	rjmp	80007488 <strlen+0x8>
80007486:	2f f8       	sub	r8,-1
80007488:	11 8a       	ld.ub	r10,r8[0x0]
8000748a:	f2 0a 18 00 	cp.b	r10,r9
8000748e:	cf c1       	brne	80007486 <strlen+0x6>
80007490:	f0 0c 01 0c 	sub	r12,r8,r12
80007494:	5e fc       	retal	r12
80007496:	d7 03       	nop

80007498 <strncpy>:
80007498:	30 08       	mov	r8,0
8000749a:	10 3a       	cp.w	r10,r8
8000749c:	5e 0c       	reteq	r12
8000749e:	f6 08 07 09 	ld.ub	r9,r11[r8]
800074a2:	f8 08 0b 09 	st.b	r12[r8],r9
800074a6:	2f f8       	sub	r8,-1
800074a8:	58 09       	cp.w	r9,0
800074aa:	cf 81       	brne	8000749a <strncpy+0x2>
800074ac:	10 3a       	cp.w	r10,r8
800074ae:	5e 0c       	reteq	r12
800074b0:	f8 08 0b 09 	st.b	r12[r8],r9
800074b4:	2f f8       	sub	r8,-1
800074b6:	cf bb       	rjmp	800074ac <strncpy+0x14>

800074b8 <_close>:
800074b8:	30 28       	mov	r8,2
800074ba:	d6 73       	breakpoint
800074bc:	3f fc       	mov	r12,-1
800074be:	35 8b       	mov	r11,88
800074c0:	58 0c       	cp.w	r12,0
800074c2:	5e 4c       	retge	r12
800074c4:	e0 6a 41 0c 	mov	r10,16652
800074c8:	95 0b       	st.w	r10[0x0],r11
800074ca:	5e fc       	retal	r12

800074cc <_lseek>:
800074cc:	30 58       	mov	r8,5
800074ce:	d6 73       	breakpoint
800074d0:	3f fc       	mov	r12,-1
800074d2:	35 8b       	mov	r11,88
800074d4:	58 0c       	cp.w	r12,0
800074d6:	5e 4c       	retge	r12
800074d8:	e0 6a 41 0c 	mov	r10,16652
800074dc:	95 0b       	st.w	r10[0x0],r11
800074de:	5e fc       	retal	r12

800074e0 <isatty>:
800074e0:	30 b8       	mov	r8,11
800074e2:	d6 73       	breakpoint
800074e4:	3f fc       	mov	r12,-1
800074e6:	35 8b       	mov	r11,88
800074e8:	58 0c       	cp.w	r12,0
800074ea:	5e 4c       	retge	r12
800074ec:	e0 6a 41 0c 	mov	r10,16652
800074f0:	95 0b       	st.w	r10[0x0],r11
800074f2:	5e fc       	retal	r12

800074f4 <_fstat_host>:
800074f4:	30 98       	mov	r8,9
800074f6:	d6 73       	breakpoint
800074f8:	3f fc       	mov	r12,-1
800074fa:	35 8b       	mov	r11,88
800074fc:	58 0c       	cp.w	r12,0
800074fe:	5e 4c       	retge	r12
80007500:	e0 6a 41 0c 	mov	r10,16652
80007504:	95 0b       	st.w	r10[0x0],r11
80007506:	5e fc       	retal	r12

80007508 <_fstat>:
80007508:	d4 21       	pushm	r4-r7,lr
8000750a:	21 0d       	sub	sp,64
8000750c:	16 97       	mov	r7,r11
8000750e:	1a 9b       	mov	r11,sp
80007510:	cf 2f       	rcall	800074f4 <_fstat_host>
80007512:	c0 34       	brge	80007518 <_fstat+0x10>
80007514:	3f fc       	mov	r12,-1
80007516:	c1 c8       	rjmp	8000754e <_fstat+0x46>
80007518:	40 08       	lddsp	r8,sp[0x0]
8000751a:	ae 08       	st.h	r7[0x0],r8
8000751c:	40 18       	lddsp	r8,sp[0x4]
8000751e:	ae 18       	st.h	r7[0x2],r8
80007520:	40 28       	lddsp	r8,sp[0x8]
80007522:	8f 18       	st.w	r7[0x4],r8
80007524:	40 38       	lddsp	r8,sp[0xc]
80007526:	ae 48       	st.h	r7[0x8],r8
80007528:	40 48       	lddsp	r8,sp[0x10]
8000752a:	ae 58       	st.h	r7[0xa],r8
8000752c:	40 58       	lddsp	r8,sp[0x14]
8000752e:	ae 68       	st.h	r7[0xc],r8
80007530:	40 68       	lddsp	r8,sp[0x18]
80007532:	ae 78       	st.h	r7[0xe],r8
80007534:	40 88       	lddsp	r8,sp[0x20]
80007536:	8f 48       	st.w	r7[0x10],r8
80007538:	40 a8       	lddsp	r8,sp[0x28]
8000753a:	8f b8       	st.w	r7[0x2c],r8
8000753c:	40 c8       	lddsp	r8,sp[0x30]
8000753e:	8f c8       	st.w	r7[0x30],r8
80007540:	40 d8       	lddsp	r8,sp[0x34]
80007542:	8f 58       	st.w	r7[0x14],r8
80007544:	40 e8       	lddsp	r8,sp[0x38]
80007546:	30 0c       	mov	r12,0
80007548:	8f 78       	st.w	r7[0x1c],r8
8000754a:	40 f8       	lddsp	r8,sp[0x3c]
8000754c:	8f 98       	st.w	r7[0x24],r8
8000754e:	2f 0d       	sub	sp,-64
80007550:	d8 22       	popm	r4-r7,pc
80007552:	d7 03       	nop

80007554 <_sbrk>:
80007554:	d4 01       	pushm	lr
80007556:	e0 68 0d 84 	mov	r8,3460
8000755a:	70 09       	ld.w	r9,r8[0x0]
8000755c:	58 09       	cp.w	r9,0
8000755e:	c0 41       	brne	80007566 <_sbrk+0x12>
80007560:	e0 69 41 10 	mov	r9,16656
80007564:	91 09       	st.w	r8[0x0],r9
80007566:	e0 69 0d 84 	mov	r9,3460
8000756a:	e0 7a 70 00 	mov	r10,94208
8000756e:	72 08       	ld.w	r8,r9[0x0]
80007570:	f0 0c 00 0c 	add	r12,r8,r12
80007574:	14 3c       	cp.w	r12,r10
80007576:	e0 8b 00 04 	brhi	8000757e <_sbrk+0x2a>
8000757a:	93 0c       	st.w	r9[0x0],r12
8000757c:	c0 68       	rjmp	80007588 <_sbrk+0x34>
8000757e:	e0 a0 18 15 	rcall	8000a5a8 <__errno>
80007582:	30 c8       	mov	r8,12
80007584:	99 08       	st.w	r12[0x0],r8
80007586:	3f f8       	mov	r8,-1
80007588:	10 9c       	mov	r12,r8
8000758a:	d8 02       	popm	pc

8000758c <get_arg>:
8000758c:	d4 31       	pushm	r0-r7,lr
8000758e:	20 8d       	sub	sp,32
80007590:	fa c4 ff bc 	sub	r4,sp,-68
80007594:	50 4b       	stdsp	sp[0x10],r11
80007596:	68 2e       	ld.w	lr,r4[0x8]
80007598:	50 58       	stdsp	sp[0x14],r8
8000759a:	12 96       	mov	r6,r9
8000759c:	7c 0b       	ld.w	r11,lr[0x0]
8000759e:	70 05       	ld.w	r5,r8[0x0]
800075a0:	50 6e       	stdsp	sp[0x18],lr
800075a2:	58 0b       	cp.w	r11,0
800075a4:	f4 0b 17 00 	moveq	r11,r10
800075a8:	68 03       	ld.w	r3,r4[0x0]
800075aa:	68 11       	ld.w	r1,r4[0x4]
800075ac:	40 49       	lddsp	r9,sp[0x10]
800075ae:	30 08       	mov	r8,0
800075b0:	c2 89       	rjmp	80007800 <get_arg+0x274>
800075b2:	2f fb       	sub	r11,-1
800075b4:	32 5c       	mov	r12,37
800075b6:	17 8a       	ld.ub	r10,r11[0x0]
800075b8:	f8 0a 18 00 	cp.b	r10,r12
800075bc:	5f 1e       	srne	lr
800075be:	f0 0a 18 00 	cp.b	r10,r8
800075c2:	5f 1c       	srne	r12
800075c4:	fd ec 00 0c 	and	r12,lr,r12
800075c8:	f0 0c 18 00 	cp.b	r12,r8
800075cc:	cf 31       	brne	800075b2 <get_arg+0x26>
800075ce:	58 0a       	cp.w	r10,0
800075d0:	e0 80 01 25 	breq	8000781a <get_arg+0x28e>
800075d4:	30 0c       	mov	r12,0
800075d6:	3f fa       	mov	r10,-1
800075d8:	18 90       	mov	r0,r12
800075da:	50 3a       	stdsp	sp[0xc],r10
800075dc:	18 94       	mov	r4,r12
800075de:	18 92       	mov	r2,r12
800075e0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800075e4:	16 97       	mov	r7,r11
800075e6:	50 7c       	stdsp	sp[0x1c],r12
800075e8:	fe cc 9e 90 	sub	r12,pc,-24944
800075ec:	0f 3a       	ld.ub	r10,r7++
800075ee:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800075f2:	40 7c       	lddsp	r12,sp[0x1c]
800075f4:	1c 0c       	add	r12,lr
800075f6:	fe ce 9f 66 	sub	lr,pc,-24730
800075fa:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800075fe:	20 1e       	sub	lr,1
80007600:	50 0e       	stdsp	sp[0x0],lr
80007602:	fe ce 9f de 	sub	lr,pc,-24610
80007606:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000760a:	50 7c       	stdsp	sp[0x1c],r12
8000760c:	40 0c       	lddsp	r12,sp[0x0]
8000760e:	58 7c       	cp.w	r12,7
80007610:	e0 8b 00 f1 	brhi	800077f2 <get_arg+0x266>
80007614:	fe ce a1 90 	sub	lr,pc,-24176
80007618:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000761c:	36 8b       	mov	r11,104
8000761e:	f6 0a 18 00 	cp.b	r10,r11
80007622:	e0 80 00 e8 	breq	800077f2 <get_arg+0x266>
80007626:	37 1b       	mov	r11,113
80007628:	f6 0a 18 00 	cp.b	r10,r11
8000762c:	c0 70       	breq	8000763a <get_arg+0xae>
8000762e:	34 cb       	mov	r11,76
80007630:	f6 0a 18 00 	cp.b	r10,r11
80007634:	c0 51       	brne	8000763e <get_arg+0xb2>
80007636:	a3 b4       	sbr	r4,0x3
80007638:	cd d8       	rjmp	800077f2 <get_arg+0x266>
8000763a:	a5 b4       	sbr	r4,0x5
8000763c:	cd b8       	rjmp	800077f2 <get_arg+0x266>
8000763e:	08 9a       	mov	r10,r4
80007640:	0e 9b       	mov	r11,r7
80007642:	a5 aa       	sbr	r10,0x4
80007644:	17 3c       	ld.ub	r12,r11++
80007646:	a5 b4       	sbr	r4,0x5
80007648:	36 ce       	mov	lr,108
8000764a:	fc 0c 18 00 	cp.b	r12,lr
8000764e:	e0 80 00 d3 	breq	800077f4 <get_arg+0x268>
80007652:	14 94       	mov	r4,r10
80007654:	cc f8       	rjmp	800077f2 <get_arg+0x266>
80007656:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000765a:	36 7c       	mov	r12,103
8000765c:	f8 0a 18 00 	cp.b	r10,r12
80007660:	e0 8b 00 27 	brhi	800076ae <get_arg+0x122>
80007664:	36 5b       	mov	r11,101
80007666:	f6 0a 18 00 	cp.b	r10,r11
8000766a:	c4 82       	brcc	800076fa <get_arg+0x16e>
8000766c:	34 fb       	mov	r11,79
8000766e:	f6 0a 18 00 	cp.b	r10,r11
80007672:	c4 80       	breq	80007702 <get_arg+0x176>
80007674:	e0 8b 00 0c 	brhi	8000768c <get_arg+0x100>
80007678:	34 5b       	mov	r11,69
8000767a:	f6 0a 18 00 	cp.b	r10,r11
8000767e:	c3 e0       	breq	800076fa <get_arg+0x16e>
80007680:	34 7b       	mov	r11,71
80007682:	f6 0a 18 00 	cp.b	r10,r11
80007686:	c3 a0       	breq	800076fa <get_arg+0x16e>
80007688:	34 4b       	mov	r11,68
8000768a:	c0 88       	rjmp	8000769a <get_arg+0x10e>
8000768c:	35 8b       	mov	r11,88
8000768e:	f6 0a 18 00 	cp.b	r10,r11
80007692:	c2 c0       	breq	800076ea <get_arg+0x15e>
80007694:	e0 8b 00 07 	brhi	800076a2 <get_arg+0x116>
80007698:	35 5b       	mov	r11,85
8000769a:	f6 0a 18 00 	cp.b	r10,r11
8000769e:	c3 51       	brne	80007708 <get_arg+0x17c>
800076a0:	c3 18       	rjmp	80007702 <get_arg+0x176>
800076a2:	36 3b       	mov	r11,99
800076a4:	f6 0a 18 00 	cp.b	r10,r11
800076a8:	c2 f0       	breq	80007706 <get_arg+0x17a>
800076aa:	36 4b       	mov	r11,100
800076ac:	c0 e8       	rjmp	800076c8 <get_arg+0x13c>
800076ae:	37 0b       	mov	r11,112
800076b0:	f6 0a 18 00 	cp.b	r10,r11
800076b4:	c2 50       	breq	800076fe <get_arg+0x172>
800076b6:	e0 8b 00 0d 	brhi	800076d0 <get_arg+0x144>
800076ba:	36 eb       	mov	r11,110
800076bc:	f6 0a 18 00 	cp.b	r10,r11
800076c0:	c1 f0       	breq	800076fe <get_arg+0x172>
800076c2:	e0 8b 00 14 	brhi	800076ea <get_arg+0x15e>
800076c6:	36 9b       	mov	r11,105
800076c8:	f6 0a 18 00 	cp.b	r10,r11
800076cc:	c1 e1       	brne	80007708 <get_arg+0x17c>
800076ce:	c0 e8       	rjmp	800076ea <get_arg+0x15e>
800076d0:	37 5b       	mov	r11,117
800076d2:	f6 0a 18 00 	cp.b	r10,r11
800076d6:	c0 a0       	breq	800076ea <get_arg+0x15e>
800076d8:	37 8b       	mov	r11,120
800076da:	f6 0a 18 00 	cp.b	r10,r11
800076de:	c0 60       	breq	800076ea <get_arg+0x15e>
800076e0:	37 3b       	mov	r11,115
800076e2:	f6 0a 18 00 	cp.b	r10,r11
800076e6:	c1 11       	brne	80007708 <get_arg+0x17c>
800076e8:	c0 b8       	rjmp	800076fe <get_arg+0x172>
800076ea:	ed b4 00 04 	bld	r4,0x4
800076ee:	c0 a0       	breq	80007702 <get_arg+0x176>
800076f0:	ed b4 00 05 	bld	r4,0x5
800076f4:	c0 91       	brne	80007706 <get_arg+0x17a>
800076f6:	30 20       	mov	r0,2
800076f8:	c0 88       	rjmp	80007708 <get_arg+0x17c>
800076fa:	30 40       	mov	r0,4
800076fc:	c0 68       	rjmp	80007708 <get_arg+0x17c>
800076fe:	30 30       	mov	r0,3
80007700:	c0 48       	rjmp	80007708 <get_arg+0x17c>
80007702:	30 10       	mov	r0,1
80007704:	c0 28       	rjmp	80007708 <get_arg+0x17c>
80007706:	30 00       	mov	r0,0
80007708:	40 3b       	lddsp	r11,sp[0xc]
8000770a:	5b fb       	cp.w	r11,-1
8000770c:	c0 40       	breq	80007714 <get_arg+0x188>
8000770e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007712:	c7 08       	rjmp	800077f2 <get_arg+0x266>
80007714:	58 60       	cp.w	r0,6
80007716:	e0 8b 00 6e 	brhi	800077f2 <get_arg+0x266>
8000771a:	6c 0a       	ld.w	r10,r6[0x0]
8000771c:	ea cc ff ff 	sub	r12,r5,-1
80007720:	fe ce a2 7c 	sub	lr,pc,-23940
80007724:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007728:	f4 cb ff f8 	sub	r11,r10,-8
8000772c:	8d 0b       	st.w	r6[0x0],r11
8000772e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007732:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007736:	c0 f8       	rjmp	80007754 <get_arg+0x1c8>
80007738:	f4 cb ff fc 	sub	r11,r10,-4
8000773c:	8d 0b       	st.w	r6[0x0],r11
8000773e:	74 0a       	ld.w	r10,r10[0x0]
80007740:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007744:	c0 88       	rjmp	80007754 <get_arg+0x1c8>
80007746:	f4 cb ff f8 	sub	r11,r10,-8
8000774a:	8d 0b       	st.w	r6[0x0],r11
8000774c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007750:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007754:	0e 9b       	mov	r11,r7
80007756:	18 95       	mov	r5,r12
80007758:	c4 e8       	rjmp	800077f4 <get_arg+0x268>
8000775a:	62 0a       	ld.w	r10,r1[0x0]
8000775c:	5b fa       	cp.w	r10,-1
8000775e:	c0 b1       	brne	80007774 <get_arg+0x1e8>
80007760:	50 19       	stdsp	sp[0x4],r9
80007762:	50 28       	stdsp	sp[0x8],r8
80007764:	e0 6a 00 80 	mov	r10,128
80007768:	30 0b       	mov	r11,0
8000776a:	02 9c       	mov	r12,r1
8000776c:	fe b0 fc f4 	rcall	80007154 <memset>
80007770:	40 28       	lddsp	r8,sp[0x8]
80007772:	40 19       	lddsp	r9,sp[0x4]
80007774:	e4 cc 00 01 	sub	r12,r2,1
80007778:	0e 9b       	mov	r11,r7
8000777a:	50 3c       	stdsp	sp[0xc],r12
8000777c:	f2 0c 0c 49 	max	r9,r9,r12
80007780:	c3 a8       	rjmp	800077f4 <get_arg+0x268>
80007782:	62 0a       	ld.w	r10,r1[0x0]
80007784:	5b fa       	cp.w	r10,-1
80007786:	c0 b1       	brne	8000779c <get_arg+0x210>
80007788:	50 19       	stdsp	sp[0x4],r9
8000778a:	50 28       	stdsp	sp[0x8],r8
8000778c:	e0 6a 00 80 	mov	r10,128
80007790:	30 0b       	mov	r11,0
80007792:	02 9c       	mov	r12,r1
80007794:	fe b0 fc e0 	rcall	80007154 <memset>
80007798:	40 28       	lddsp	r8,sp[0x8]
8000779a:	40 19       	lddsp	r9,sp[0x4]
8000779c:	20 12       	sub	r2,1
8000779e:	30 0a       	mov	r10,0
800077a0:	0e 9b       	mov	r11,r7
800077a2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800077a6:	f2 02 0c 49 	max	r9,r9,r2
800077aa:	c2 58       	rjmp	800077f4 <get_arg+0x268>
800077ac:	16 97       	mov	r7,r11
800077ae:	6c 0a       	ld.w	r10,r6[0x0]
800077b0:	f4 cb ff fc 	sub	r11,r10,-4
800077b4:	8d 0b       	st.w	r6[0x0],r11
800077b6:	74 0a       	ld.w	r10,r10[0x0]
800077b8:	0e 9b       	mov	r11,r7
800077ba:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800077be:	2f f5       	sub	r5,-1
800077c0:	c1 a8       	rjmp	800077f4 <get_arg+0x268>
800077c2:	f4 c2 00 30 	sub	r2,r10,48
800077c6:	c0 68       	rjmp	800077d2 <get_arg+0x246>
800077c8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800077cc:	2f f7       	sub	r7,-1
800077ce:	f4 02 00 12 	add	r2,r10,r2<<0x1
800077d2:	0f 8a       	ld.ub	r10,r7[0x0]
800077d4:	58 0a       	cp.w	r10,0
800077d6:	c0 e0       	breq	800077f2 <get_arg+0x266>
800077d8:	23 0a       	sub	r10,48
800077da:	58 9a       	cp.w	r10,9
800077dc:	fe 98 ff f6 	brls	800077c8 <get_arg+0x23c>
800077e0:	c0 98       	rjmp	800077f2 <get_arg+0x266>
800077e2:	2f f7       	sub	r7,-1
800077e4:	0f 8a       	ld.ub	r10,r7[0x0]
800077e6:	58 0a       	cp.w	r10,0
800077e8:	c0 50       	breq	800077f2 <get_arg+0x266>
800077ea:	23 0a       	sub	r10,48
800077ec:	58 9a       	cp.w	r10,9
800077ee:	fe 98 ff fa 	brls	800077e2 <get_arg+0x256>
800077f2:	0e 9b       	mov	r11,r7
800077f4:	40 7c       	lddsp	r12,sp[0x1c]
800077f6:	30 ba       	mov	r10,11
800077f8:	f4 0c 18 00 	cp.b	r12,r10
800077fc:	fe 91 fe f2 	brne	800075e0 <get_arg+0x54>
80007800:	40 42       	lddsp	r2,sp[0x10]
80007802:	17 8c       	ld.ub	r12,r11[0x0]
80007804:	0a 32       	cp.w	r2,r5
80007806:	5f 4a       	srge	r10
80007808:	f0 0c 18 00 	cp.b	r12,r8
8000780c:	5f 1c       	srne	r12
8000780e:	f9 ea 00 0a 	and	r10,r12,r10
80007812:	f0 0a 18 00 	cp.b	r10,r8
80007816:	fe 91 fe cf 	brne	800075b4 <get_arg+0x28>
8000781a:	30 08       	mov	r8,0
8000781c:	40 4e       	lddsp	lr,sp[0x10]
8000781e:	17 8a       	ld.ub	r10,r11[0x0]
80007820:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007824:	f0 0a 18 00 	cp.b	r10,r8
80007828:	fc 09 17 10 	movne	r9,lr
8000782c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007830:	06 9e       	mov	lr,r3
80007832:	c2 a8       	rjmp	80007886 <get_arg+0x2fa>
80007834:	62 0a       	ld.w	r10,r1[0x0]
80007836:	58 3a       	cp.w	r10,3
80007838:	c1 e0       	breq	80007874 <get_arg+0x2e8>
8000783a:	e0 89 00 07 	brgt	80007848 <get_arg+0x2bc>
8000783e:	58 1a       	cp.w	r10,1
80007840:	c1 a0       	breq	80007874 <get_arg+0x2e8>
80007842:	58 2a       	cp.w	r10,2
80007844:	c1 81       	brne	80007874 <get_arg+0x2e8>
80007846:	c0 58       	rjmp	80007850 <get_arg+0x2c4>
80007848:	58 5a       	cp.w	r10,5
8000784a:	c0 c0       	breq	80007862 <get_arg+0x2d6>
8000784c:	c0 b5       	brlt	80007862 <get_arg+0x2d6>
8000784e:	c1 38       	rjmp	80007874 <get_arg+0x2e8>
80007850:	6c 0a       	ld.w	r10,r6[0x0]
80007852:	f4 cc ff f8 	sub	r12,r10,-8
80007856:	8d 0c       	st.w	r6[0x0],r12
80007858:	f4 e2 00 00 	ld.d	r2,r10[0]
8000785c:	f0 e3 00 00 	st.d	r8[0],r2
80007860:	c1 08       	rjmp	80007880 <get_arg+0x2f4>
80007862:	6c 0a       	ld.w	r10,r6[0x0]
80007864:	f4 cc ff f8 	sub	r12,r10,-8
80007868:	8d 0c       	st.w	r6[0x0],r12
8000786a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000786e:	f0 e3 00 00 	st.d	r8[0],r2
80007872:	c0 78       	rjmp	80007880 <get_arg+0x2f4>
80007874:	6c 0a       	ld.w	r10,r6[0x0]
80007876:	f4 cc ff fc 	sub	r12,r10,-4
8000787a:	8d 0c       	st.w	r6[0x0],r12
8000787c:	74 0a       	ld.w	r10,r10[0x0]
8000787e:	91 0a       	st.w	r8[0x0],r10
80007880:	2f f5       	sub	r5,-1
80007882:	2f 88       	sub	r8,-8
80007884:	2f c1       	sub	r1,-4
80007886:	12 35       	cp.w	r5,r9
80007888:	fe 9a ff d6 	brle	80007834 <get_arg+0x2a8>
8000788c:	1c 93       	mov	r3,lr
8000788e:	40 52       	lddsp	r2,sp[0x14]
80007890:	40 6e       	lddsp	lr,sp[0x18]
80007892:	85 05       	st.w	r2[0x0],r5
80007894:	9d 0b       	st.w	lr[0x0],r11
80007896:	40 4b       	lddsp	r11,sp[0x10]
80007898:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000789c:	2f 8d       	sub	sp,-32
8000789e:	d8 32       	popm	r0-r7,pc

800078a0 <__sprint_r>:
800078a0:	d4 21       	pushm	r4-r7,lr
800078a2:	14 97       	mov	r7,r10
800078a4:	74 28       	ld.w	r8,r10[0x8]
800078a6:	58 08       	cp.w	r8,0
800078a8:	c0 41       	brne	800078b0 <__sprint_r+0x10>
800078aa:	95 18       	st.w	r10[0x4],r8
800078ac:	10 9c       	mov	r12,r8
800078ae:	d8 22       	popm	r4-r7,pc
800078b0:	e0 a0 18 ba 	rcall	8000aa24 <__sfvwrite_r>
800078b4:	30 08       	mov	r8,0
800078b6:	8f 18       	st.w	r7[0x4],r8
800078b8:	8f 28       	st.w	r7[0x8],r8
800078ba:	d8 22       	popm	r4-r7,pc

800078bc <_vfprintf_r>:
800078bc:	d4 31       	pushm	r0-r7,lr
800078be:	fa cd 06 bc 	sub	sp,sp,1724
800078c2:	51 09       	stdsp	sp[0x40],r9
800078c4:	16 91       	mov	r1,r11
800078c6:	14 97       	mov	r7,r10
800078c8:	18 95       	mov	r5,r12
800078ca:	e0 a0 1a 1d 	rcall	8000ad04 <_localeconv_r>
800078ce:	78 0c       	ld.w	r12,r12[0x0]
800078d0:	50 cc       	stdsp	sp[0x30],r12
800078d2:	58 05       	cp.w	r5,0
800078d4:	c0 70       	breq	800078e2 <_vfprintf_r+0x26>
800078d6:	6a 68       	ld.w	r8,r5[0x18]
800078d8:	58 08       	cp.w	r8,0
800078da:	c0 41       	brne	800078e2 <_vfprintf_r+0x26>
800078dc:	0a 9c       	mov	r12,r5
800078de:	e0 a0 17 43 	rcall	8000a764 <__sinit>
800078e2:	fe c8 a0 7a 	sub	r8,pc,-24454
800078e6:	10 31       	cp.w	r1,r8
800078e8:	c0 31       	brne	800078ee <_vfprintf_r+0x32>
800078ea:	6a 01       	ld.w	r1,r5[0x0]
800078ec:	c0 c8       	rjmp	80007904 <_vfprintf_r+0x48>
800078ee:	fe c8 a0 66 	sub	r8,pc,-24474
800078f2:	10 31       	cp.w	r1,r8
800078f4:	c0 31       	brne	800078fa <_vfprintf_r+0x3e>
800078f6:	6a 11       	ld.w	r1,r5[0x4]
800078f8:	c0 68       	rjmp	80007904 <_vfprintf_r+0x48>
800078fa:	fe c8 a0 52 	sub	r8,pc,-24494
800078fe:	10 31       	cp.w	r1,r8
80007900:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007904:	82 68       	ld.sh	r8,r1[0xc]
80007906:	ed b8 00 03 	bld	r8,0x3
8000790a:	c0 41       	brne	80007912 <_vfprintf_r+0x56>
8000790c:	62 48       	ld.w	r8,r1[0x10]
8000790e:	58 08       	cp.w	r8,0
80007910:	c0 71       	brne	8000791e <_vfprintf_r+0x62>
80007912:	02 9b       	mov	r11,r1
80007914:	0a 9c       	mov	r12,r5
80007916:	e0 a0 0f 5d 	rcall	800097d0 <__swsetup_r>
8000791a:	e0 81 0f 54 	brne	800097c2 <_vfprintf_r+0x1f06>
8000791e:	82 68       	ld.sh	r8,r1[0xc]
80007920:	10 99       	mov	r9,r8
80007922:	e2 19 00 1a 	andl	r9,0x1a,COH
80007926:	58 a9       	cp.w	r9,10
80007928:	c3 c1       	brne	800079a0 <_vfprintf_r+0xe4>
8000792a:	82 79       	ld.sh	r9,r1[0xe]
8000792c:	30 0a       	mov	r10,0
8000792e:	f4 09 19 00 	cp.h	r9,r10
80007932:	c3 75       	brlt	800079a0 <_vfprintf_r+0xe4>
80007934:	a1 d8       	cbr	r8,0x1
80007936:	fb 58 05 d0 	st.h	sp[1488],r8
8000793a:	62 88       	ld.w	r8,r1[0x20]
8000793c:	fb 48 05 e4 	st.w	sp[1508],r8
80007940:	62 a8       	ld.w	r8,r1[0x28]
80007942:	fb 48 05 ec 	st.w	sp[1516],r8
80007946:	fa c8 ff bc 	sub	r8,sp,-68
8000794a:	fb 48 05 d4 	st.w	sp[1492],r8
8000794e:	fb 48 05 c4 	st.w	sp[1476],r8
80007952:	e0 68 04 00 	mov	r8,1024
80007956:	fb 48 05 d8 	st.w	sp[1496],r8
8000795a:	fb 48 05 cc 	st.w	sp[1484],r8
8000795e:	30 08       	mov	r8,0
80007960:	fb 59 05 d2 	st.h	sp[1490],r9
80007964:	0e 9a       	mov	r10,r7
80007966:	41 09       	lddsp	r9,sp[0x40]
80007968:	fa c7 fa 3c 	sub	r7,sp,-1476
8000796c:	fb 48 05 dc 	st.w	sp[1500],r8
80007970:	0a 9c       	mov	r12,r5
80007972:	0e 9b       	mov	r11,r7
80007974:	ca 4f       	rcall	800078bc <_vfprintf_r>
80007976:	50 bc       	stdsp	sp[0x2c],r12
80007978:	c0 95       	brlt	8000798a <_vfprintf_r+0xce>
8000797a:	0e 9b       	mov	r11,r7
8000797c:	0a 9c       	mov	r12,r5
8000797e:	e0 a0 16 1b 	rcall	8000a5b4 <_fflush_r>
80007982:	40 be       	lddsp	lr,sp[0x2c]
80007984:	f9 be 01 ff 	movne	lr,-1
80007988:	50 be       	stdsp	sp[0x2c],lr
8000798a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000798e:	ed b8 00 06 	bld	r8,0x6
80007992:	e0 81 0f 1a 	brne	800097c6 <_vfprintf_r+0x1f0a>
80007996:	82 68       	ld.sh	r8,r1[0xc]
80007998:	a7 a8       	sbr	r8,0x6
8000799a:	a2 68       	st.h	r1[0xc],r8
8000799c:	e0 8f 0f 15 	bral	800097c6 <_vfprintf_r+0x1f0a>
800079a0:	30 08       	mov	r8,0
800079a2:	fb 48 06 b4 	st.w	sp[1716],r8
800079a6:	fb 48 06 90 	st.w	sp[1680],r8
800079aa:	fb 48 06 8c 	st.w	sp[1676],r8
800079ae:	fb 48 06 b0 	st.w	sp[1712],r8
800079b2:	30 08       	mov	r8,0
800079b4:	30 09       	mov	r9,0
800079b6:	50 a7       	stdsp	sp[0x28],r7
800079b8:	50 78       	stdsp	sp[0x1c],r8
800079ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800079be:	3f f8       	mov	r8,-1
800079c0:	50 59       	stdsp	sp[0x14],r9
800079c2:	fb 43 06 88 	st.w	sp[1672],r3
800079c6:	fb 48 05 44 	st.w	sp[1348],r8
800079ca:	12 9c       	mov	r12,r9
800079cc:	50 69       	stdsp	sp[0x18],r9
800079ce:	50 d9       	stdsp	sp[0x34],r9
800079d0:	50 e9       	stdsp	sp[0x38],r9
800079d2:	50 b9       	stdsp	sp[0x2c],r9
800079d4:	12 97       	mov	r7,r9
800079d6:	0a 94       	mov	r4,r5
800079d8:	40 a2       	lddsp	r2,sp[0x28]
800079da:	32 5a       	mov	r10,37
800079dc:	30 08       	mov	r8,0
800079de:	c0 28       	rjmp	800079e2 <_vfprintf_r+0x126>
800079e0:	2f f2       	sub	r2,-1
800079e2:	05 89       	ld.ub	r9,r2[0x0]
800079e4:	f0 09 18 00 	cp.b	r9,r8
800079e8:	5f 1b       	srne	r11
800079ea:	f4 09 18 00 	cp.b	r9,r10
800079ee:	5f 19       	srne	r9
800079f0:	f3 eb 00 0b 	and	r11,r9,r11
800079f4:	f0 0b 18 00 	cp.b	r11,r8
800079f8:	cf 41       	brne	800079e0 <_vfprintf_r+0x124>
800079fa:	40 ab       	lddsp	r11,sp[0x28]
800079fc:	e4 0b 01 06 	sub	r6,r2,r11
80007a00:	c1 e0       	breq	80007a3c <_vfprintf_r+0x180>
80007a02:	fa f8 06 90 	ld.w	r8,sp[1680]
80007a06:	0c 08       	add	r8,r6
80007a08:	87 0b       	st.w	r3[0x0],r11
80007a0a:	fb 48 06 90 	st.w	sp[1680],r8
80007a0e:	87 16       	st.w	r3[0x4],r6
80007a10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007a14:	2f f8       	sub	r8,-1
80007a16:	fb 48 06 8c 	st.w	sp[1676],r8
80007a1a:	58 78       	cp.w	r8,7
80007a1c:	e0 89 00 04 	brgt	80007a24 <_vfprintf_r+0x168>
80007a20:	2f 83       	sub	r3,-8
80007a22:	c0 a8       	rjmp	80007a36 <_vfprintf_r+0x17a>
80007a24:	fa ca f9 78 	sub	r10,sp,-1672
80007a28:	02 9b       	mov	r11,r1
80007a2a:	08 9c       	mov	r12,r4
80007a2c:	c3 af       	rcall	800078a0 <__sprint_r>
80007a2e:	e0 81 0e c6 	brne	800097ba <_vfprintf_r+0x1efe>
80007a32:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a36:	40 ba       	lddsp	r10,sp[0x2c]
80007a38:	0c 0a       	add	r10,r6
80007a3a:	50 ba       	stdsp	sp[0x2c],r10
80007a3c:	05 89       	ld.ub	r9,r2[0x0]
80007a3e:	30 08       	mov	r8,0
80007a40:	f0 09 18 00 	cp.b	r9,r8
80007a44:	e0 80 0e aa 	breq	80009798 <_vfprintf_r+0x1edc>
80007a48:	30 09       	mov	r9,0
80007a4a:	fb 68 06 bb 	st.b	sp[1723],r8
80007a4e:	0e 96       	mov	r6,r7
80007a50:	e4 c8 ff ff 	sub	r8,r2,-1
80007a54:	3f fe       	mov	lr,-1
80007a56:	50 93       	stdsp	sp[0x24],r3
80007a58:	50 41       	stdsp	sp[0x10],r1
80007a5a:	0e 93       	mov	r3,r7
80007a5c:	04 91       	mov	r1,r2
80007a5e:	50 89       	stdsp	sp[0x20],r9
80007a60:	50 a8       	stdsp	sp[0x28],r8
80007a62:	50 2e       	stdsp	sp[0x8],lr
80007a64:	50 39       	stdsp	sp[0xc],r9
80007a66:	12 95       	mov	r5,r9
80007a68:	12 90       	mov	r0,r9
80007a6a:	10 97       	mov	r7,r8
80007a6c:	08 92       	mov	r2,r4
80007a6e:	c0 78       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007a70:	3f fc       	mov	r12,-1
80007a72:	08 97       	mov	r7,r4
80007a74:	50 2c       	stdsp	sp[0x8],r12
80007a76:	c0 38       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007a78:	30 0b       	mov	r11,0
80007a7a:	50 3b       	stdsp	sp[0xc],r11
80007a7c:	0f 38       	ld.ub	r8,r7++
80007a7e:	c0 28       	rjmp	80007a82 <_vfprintf_r+0x1c6>
80007a80:	12 90       	mov	r0,r9
80007a82:	f0 c9 00 20 	sub	r9,r8,32
80007a86:	e0 49 00 58 	cp.w	r9,88
80007a8a:	e0 8b 0a 30 	brhi	80008eea <_vfprintf_r+0x162e>
80007a8e:	fe ca a5 ce 	sub	r10,pc,-23090
80007a92:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007a96:	50 a7       	stdsp	sp[0x28],r7
80007a98:	50 80       	stdsp	sp[0x20],r0
80007a9a:	0c 97       	mov	r7,r6
80007a9c:	04 94       	mov	r4,r2
80007a9e:	06 96       	mov	r6,r3
80007aa0:	02 92       	mov	r2,r1
80007aa2:	fe c9 a3 a6 	sub	r9,pc,-23642
80007aa6:	40 93       	lddsp	r3,sp[0x24]
80007aa8:	10 90       	mov	r0,r8
80007aaa:	40 41       	lddsp	r1,sp[0x10]
80007aac:	50 d9       	stdsp	sp[0x34],r9
80007aae:	e0 8f 08 8e 	bral	80008bca <_vfprintf_r+0x130e>
80007ab2:	30 08       	mov	r8,0
80007ab4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007ab8:	f0 09 18 00 	cp.b	r9,r8
80007abc:	ce 01       	brne	80007a7c <_vfprintf_r+0x1c0>
80007abe:	32 08       	mov	r8,32
80007ac0:	c6 e8       	rjmp	80007b9c <_vfprintf_r+0x2e0>
80007ac2:	a1 a5       	sbr	r5,0x0
80007ac4:	cd cb       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007ac6:	0f 89       	ld.ub	r9,r7[0x0]
80007ac8:	f2 c8 00 30 	sub	r8,r9,48
80007acc:	58 98       	cp.w	r8,9
80007ace:	e0 8b 00 1d 	brhi	80007b08 <_vfprintf_r+0x24c>
80007ad2:	ee c8 ff ff 	sub	r8,r7,-1
80007ad6:	30 0b       	mov	r11,0
80007ad8:	23 09       	sub	r9,48
80007ada:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007ade:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007ae2:	11 39       	ld.ub	r9,r8++
80007ae4:	f2 ca 00 30 	sub	r10,r9,48
80007ae8:	58 9a       	cp.w	r10,9
80007aea:	fe 98 ff f7 	brls	80007ad8 <_vfprintf_r+0x21c>
80007aee:	e0 49 00 24 	cp.w	r9,36
80007af2:	cc 31       	brne	80007a78 <_vfprintf_r+0x1bc>
80007af4:	e0 4b 00 20 	cp.w	r11,32
80007af8:	e0 89 0e 60 	brgt	800097b8 <_vfprintf_r+0x1efc>
80007afc:	20 1b       	sub	r11,1
80007afe:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007b02:	12 3b       	cp.w	r11,r9
80007b04:	c0 95       	brlt	80007b16 <_vfprintf_r+0x25a>
80007b06:	c1 08       	rjmp	80007b26 <_vfprintf_r+0x26a>
80007b08:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007b0c:	ec ca ff ff 	sub	r10,r6,-1
80007b10:	12 36       	cp.w	r6,r9
80007b12:	c1 f5       	brlt	80007b50 <_vfprintf_r+0x294>
80007b14:	c2 68       	rjmp	80007b60 <_vfprintf_r+0x2a4>
80007b16:	fa ce f9 44 	sub	lr,sp,-1724
80007b1a:	10 97       	mov	r7,r8
80007b1c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007b20:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007b24:	c3 58       	rjmp	80007b8e <_vfprintf_r+0x2d2>
80007b26:	10 97       	mov	r7,r8
80007b28:	fa c8 f9 50 	sub	r8,sp,-1712
80007b2c:	1a d8       	st.w	--sp,r8
80007b2e:	fa c8 fa b8 	sub	r8,sp,-1352
80007b32:	1a d8       	st.w	--sp,r8
80007b34:	fa c8 fb b4 	sub	r8,sp,-1100
80007b38:	02 9a       	mov	r10,r1
80007b3a:	1a d8       	st.w	--sp,r8
80007b3c:	04 9c       	mov	r12,r2
80007b3e:	fa c8 f9 40 	sub	r8,sp,-1728
80007b42:	fa c9 ff b4 	sub	r9,sp,-76
80007b46:	fe b0 fd 23 	rcall	8000758c <get_arg>
80007b4a:	2f dd       	sub	sp,-12
80007b4c:	78 00       	ld.w	r0,r12[0x0]
80007b4e:	c2 08       	rjmp	80007b8e <_vfprintf_r+0x2d2>
80007b50:	fa cc f9 44 	sub	r12,sp,-1724
80007b54:	14 96       	mov	r6,r10
80007b56:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007b5a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007b5e:	c1 88       	rjmp	80007b8e <_vfprintf_r+0x2d2>
80007b60:	41 08       	lddsp	r8,sp[0x40]
80007b62:	59 f9       	cp.w	r9,31
80007b64:	e0 89 00 11 	brgt	80007b86 <_vfprintf_r+0x2ca>
80007b68:	f0 cb ff fc 	sub	r11,r8,-4
80007b6c:	51 0b       	stdsp	sp[0x40],r11
80007b6e:	70 00       	ld.w	r0,r8[0x0]
80007b70:	fa cb f9 44 	sub	r11,sp,-1724
80007b74:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007b78:	f1 40 fd 88 	st.w	r8[-632],r0
80007b7c:	2f f9       	sub	r9,-1
80007b7e:	14 96       	mov	r6,r10
80007b80:	fb 49 06 b4 	st.w	sp[1716],r9
80007b84:	c0 58       	rjmp	80007b8e <_vfprintf_r+0x2d2>
80007b86:	70 00       	ld.w	r0,r8[0x0]
80007b88:	14 96       	mov	r6,r10
80007b8a:	2f c8       	sub	r8,-4
80007b8c:	51 08       	stdsp	sp[0x40],r8
80007b8e:	58 00       	cp.w	r0,0
80007b90:	fe 94 ff 76 	brge	80007a7c <_vfprintf_r+0x1c0>
80007b94:	5c 30       	neg	r0
80007b96:	a3 a5       	sbr	r5,0x2
80007b98:	c7 2b       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007b9a:	32 b8       	mov	r8,43
80007b9c:	fb 68 06 bb 	st.b	sp[1723],r8
80007ba0:	c6 eb       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007ba2:	0f 38       	ld.ub	r8,r7++
80007ba4:	e0 48 00 2a 	cp.w	r8,42
80007ba8:	c0 30       	breq	80007bae <_vfprintf_r+0x2f2>
80007baa:	30 09       	mov	r9,0
80007bac:	c7 98       	rjmp	80007c9e <_vfprintf_r+0x3e2>
80007bae:	0f 88       	ld.ub	r8,r7[0x0]
80007bb0:	f0 c9 00 30 	sub	r9,r8,48
80007bb4:	58 99       	cp.w	r9,9
80007bb6:	e0 8b 00 1f 	brhi	80007bf4 <_vfprintf_r+0x338>
80007bba:	ee c4 ff ff 	sub	r4,r7,-1
80007bbe:	30 0b       	mov	r11,0
80007bc0:	23 08       	sub	r8,48
80007bc2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007bc6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007bca:	09 38       	ld.ub	r8,r4++
80007bcc:	f0 c9 00 30 	sub	r9,r8,48
80007bd0:	58 99       	cp.w	r9,9
80007bd2:	fe 98 ff f7 	brls	80007bc0 <_vfprintf_r+0x304>
80007bd6:	e0 48 00 24 	cp.w	r8,36
80007bda:	fe 91 ff 4f 	brne	80007a78 <_vfprintf_r+0x1bc>
80007bde:	e0 4b 00 20 	cp.w	r11,32
80007be2:	e0 89 0d eb 	brgt	800097b8 <_vfprintf_r+0x1efc>
80007be6:	20 1b       	sub	r11,1
80007be8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bec:	10 3b       	cp.w	r11,r8
80007bee:	c0 a5       	brlt	80007c02 <_vfprintf_r+0x346>
80007bf0:	c1 18       	rjmp	80007c12 <_vfprintf_r+0x356>
80007bf2:	d7 03       	nop
80007bf4:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007bf8:	ec c9 ff ff 	sub	r9,r6,-1
80007bfc:	14 36       	cp.w	r6,r10
80007bfe:	c1 f5       	brlt	80007c3c <_vfprintf_r+0x380>
80007c00:	c2 88       	rjmp	80007c50 <_vfprintf_r+0x394>
80007c02:	fa ca f9 44 	sub	r10,sp,-1724
80007c06:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007c0a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007c0e:	50 2b       	stdsp	sp[0x8],r11
80007c10:	c3 c8       	rjmp	80007c88 <_vfprintf_r+0x3cc>
80007c12:	fa c8 f9 50 	sub	r8,sp,-1712
80007c16:	1a d8       	st.w	--sp,r8
80007c18:	fa c8 fa b8 	sub	r8,sp,-1352
80007c1c:	1a d8       	st.w	--sp,r8
80007c1e:	fa c8 fb b4 	sub	r8,sp,-1100
80007c22:	02 9a       	mov	r10,r1
80007c24:	1a d8       	st.w	--sp,r8
80007c26:	04 9c       	mov	r12,r2
80007c28:	fa c8 f9 40 	sub	r8,sp,-1728
80007c2c:	fa c9 ff b4 	sub	r9,sp,-76
80007c30:	fe b0 fc ae 	rcall	8000758c <get_arg>
80007c34:	2f dd       	sub	sp,-12
80007c36:	78 0c       	ld.w	r12,r12[0x0]
80007c38:	50 2c       	stdsp	sp[0x8],r12
80007c3a:	c2 78       	rjmp	80007c88 <_vfprintf_r+0x3cc>
80007c3c:	12 96       	mov	r6,r9
80007c3e:	0e 94       	mov	r4,r7
80007c40:	fa c9 f9 44 	sub	r9,sp,-1724
80007c44:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007c48:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007c4c:	50 28       	stdsp	sp[0x8],r8
80007c4e:	c1 d8       	rjmp	80007c88 <_vfprintf_r+0x3cc>
80007c50:	41 08       	lddsp	r8,sp[0x40]
80007c52:	59 fa       	cp.w	r10,31
80007c54:	e0 89 00 14 	brgt	80007c7c <_vfprintf_r+0x3c0>
80007c58:	f0 cb ff fc 	sub	r11,r8,-4
80007c5c:	70 08       	ld.w	r8,r8[0x0]
80007c5e:	51 0b       	stdsp	sp[0x40],r11
80007c60:	50 28       	stdsp	sp[0x8],r8
80007c62:	fa c6 f9 44 	sub	r6,sp,-1724
80007c66:	40 2e       	lddsp	lr,sp[0x8]
80007c68:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007c6c:	f1 4e fd 88 	st.w	r8[-632],lr
80007c70:	2f fa       	sub	r10,-1
80007c72:	0e 94       	mov	r4,r7
80007c74:	fb 4a 06 b4 	st.w	sp[1716],r10
80007c78:	12 96       	mov	r6,r9
80007c7a:	c0 78       	rjmp	80007c88 <_vfprintf_r+0x3cc>
80007c7c:	70 0c       	ld.w	r12,r8[0x0]
80007c7e:	0e 94       	mov	r4,r7
80007c80:	2f c8       	sub	r8,-4
80007c82:	50 2c       	stdsp	sp[0x8],r12
80007c84:	12 96       	mov	r6,r9
80007c86:	51 08       	stdsp	sp[0x40],r8
80007c88:	40 2b       	lddsp	r11,sp[0x8]
80007c8a:	58 0b       	cp.w	r11,0
80007c8c:	fe 95 fe f2 	brlt	80007a70 <_vfprintf_r+0x1b4>
80007c90:	08 97       	mov	r7,r4
80007c92:	cf 5a       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007c94:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007c98:	0f 38       	ld.ub	r8,r7++
80007c9a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007c9e:	f0 ca 00 30 	sub	r10,r8,48
80007ca2:	58 9a       	cp.w	r10,9
80007ca4:	fe 98 ff f8 	brls	80007c94 <_vfprintf_r+0x3d8>
80007ca8:	3f fa       	mov	r10,-1
80007caa:	f2 0a 0c 49 	max	r9,r9,r10
80007cae:	50 29       	stdsp	sp[0x8],r9
80007cb0:	ce 9a       	rjmp	80007a82 <_vfprintf_r+0x1c6>
80007cb2:	a7 b5       	sbr	r5,0x7
80007cb4:	ce 4a       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007cb6:	30 09       	mov	r9,0
80007cb8:	23 08       	sub	r8,48
80007cba:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007cbe:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007cc2:	0f 38       	ld.ub	r8,r7++
80007cc4:	f0 ca 00 30 	sub	r10,r8,48
80007cc8:	58 9a       	cp.w	r10,9
80007cca:	fe 98 ff f7 	brls	80007cb8 <_vfprintf_r+0x3fc>
80007cce:	e0 48 00 24 	cp.w	r8,36
80007cd2:	fe 91 fe d7 	brne	80007a80 <_vfprintf_r+0x1c4>
80007cd6:	e0 49 00 20 	cp.w	r9,32
80007cda:	e0 89 0d 6f 	brgt	800097b8 <_vfprintf_r+0x1efc>
80007cde:	f2 c3 00 01 	sub	r3,r9,1
80007ce2:	30 19       	mov	r9,1
80007ce4:	50 39       	stdsp	sp[0xc],r9
80007ce6:	cc ba       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007ce8:	a3 b5       	sbr	r5,0x3
80007cea:	cc 9a       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007cec:	a7 a5       	sbr	r5,0x6
80007cee:	cc 7a       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007cf0:	0a 98       	mov	r8,r5
80007cf2:	a5 b5       	sbr	r5,0x5
80007cf4:	a5 a8       	sbr	r8,0x4
80007cf6:	0f 89       	ld.ub	r9,r7[0x0]
80007cf8:	36 ce       	mov	lr,108
80007cfa:	fc 09 18 00 	cp.b	r9,lr
80007cfe:	f7 b7 00 ff 	subeq	r7,-1
80007d02:	f0 05 17 10 	movne	r5,r8
80007d06:	cb ba       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007d08:	a5 b5       	sbr	r5,0x5
80007d0a:	cb 9a       	rjmp	80007a7c <_vfprintf_r+0x1c0>
80007d0c:	50 a7       	stdsp	sp[0x28],r7
80007d0e:	50 80       	stdsp	sp[0x20],r0
80007d10:	0c 97       	mov	r7,r6
80007d12:	10 90       	mov	r0,r8
80007d14:	06 96       	mov	r6,r3
80007d16:	04 94       	mov	r4,r2
80007d18:	40 93       	lddsp	r3,sp[0x24]
80007d1a:	02 92       	mov	r2,r1
80007d1c:	0e 99       	mov	r9,r7
80007d1e:	40 41       	lddsp	r1,sp[0x10]
80007d20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d24:	40 3c       	lddsp	r12,sp[0xc]
80007d26:	58 0c       	cp.w	r12,0
80007d28:	c1 d0       	breq	80007d62 <_vfprintf_r+0x4a6>
80007d2a:	10 36       	cp.w	r6,r8
80007d2c:	c0 64       	brge	80007d38 <_vfprintf_r+0x47c>
80007d2e:	fa cb f9 44 	sub	r11,sp,-1724
80007d32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d36:	c1 d8       	rjmp	80007d70 <_vfprintf_r+0x4b4>
80007d38:	fa c8 f9 50 	sub	r8,sp,-1712
80007d3c:	1a d8       	st.w	--sp,r8
80007d3e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d42:	1a d8       	st.w	--sp,r8
80007d44:	fa c8 fb b4 	sub	r8,sp,-1100
80007d48:	1a d8       	st.w	--sp,r8
80007d4a:	fa c8 f9 40 	sub	r8,sp,-1728
80007d4e:	fa c9 ff b4 	sub	r9,sp,-76
80007d52:	04 9a       	mov	r10,r2
80007d54:	0c 9b       	mov	r11,r6
80007d56:	08 9c       	mov	r12,r4
80007d58:	fe b0 fc 1a 	rcall	8000758c <get_arg>
80007d5c:	2f dd       	sub	sp,-12
80007d5e:	19 b8       	ld.ub	r8,r12[0x3]
80007d60:	c2 28       	rjmp	80007da4 <_vfprintf_r+0x4e8>
80007d62:	2f f7       	sub	r7,-1
80007d64:	10 39       	cp.w	r9,r8
80007d66:	c0 84       	brge	80007d76 <_vfprintf_r+0x4ba>
80007d68:	fa ca f9 44 	sub	r10,sp,-1724
80007d6c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d70:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007d74:	c1 88       	rjmp	80007da4 <_vfprintf_r+0x4e8>
80007d76:	41 09       	lddsp	r9,sp[0x40]
80007d78:	59 f8       	cp.w	r8,31
80007d7a:	e0 89 00 12 	brgt	80007d9e <_vfprintf_r+0x4e2>
80007d7e:	f2 ca ff fc 	sub	r10,r9,-4
80007d82:	51 0a       	stdsp	sp[0x40],r10
80007d84:	72 09       	ld.w	r9,r9[0x0]
80007d86:	fa c6 f9 44 	sub	r6,sp,-1724
80007d8a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007d8e:	2f f8       	sub	r8,-1
80007d90:	f5 49 fd 88 	st.w	r10[-632],r9
80007d94:	fb 48 06 b4 	st.w	sp[1716],r8
80007d98:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007d9c:	c0 48       	rjmp	80007da4 <_vfprintf_r+0x4e8>
80007d9e:	13 b8       	ld.ub	r8,r9[0x3]
80007da0:	2f c9       	sub	r9,-4
80007da2:	51 09       	stdsp	sp[0x40],r9
80007da4:	fb 68 06 60 	st.b	sp[1632],r8
80007da8:	30 0e       	mov	lr,0
80007daa:	30 08       	mov	r8,0
80007dac:	30 12       	mov	r2,1
80007dae:	fb 68 06 bb 	st.b	sp[1723],r8
80007db2:	50 2e       	stdsp	sp[0x8],lr
80007db4:	e0 8f 08 ad 	bral	80008f0e <_vfprintf_r+0x1652>
80007db8:	50 a7       	stdsp	sp[0x28],r7
80007dba:	50 80       	stdsp	sp[0x20],r0
80007dbc:	0c 97       	mov	r7,r6
80007dbe:	04 94       	mov	r4,r2
80007dc0:	06 96       	mov	r6,r3
80007dc2:	02 92       	mov	r2,r1
80007dc4:	40 93       	lddsp	r3,sp[0x24]
80007dc6:	10 90       	mov	r0,r8
80007dc8:	40 41       	lddsp	r1,sp[0x10]
80007dca:	a5 a5       	sbr	r5,0x4
80007dcc:	c0 a8       	rjmp	80007de0 <_vfprintf_r+0x524>
80007dce:	50 a7       	stdsp	sp[0x28],r7
80007dd0:	50 80       	stdsp	sp[0x20],r0
80007dd2:	0c 97       	mov	r7,r6
80007dd4:	04 94       	mov	r4,r2
80007dd6:	06 96       	mov	r6,r3
80007dd8:	02 92       	mov	r2,r1
80007dda:	40 93       	lddsp	r3,sp[0x24]
80007ddc:	10 90       	mov	r0,r8
80007dde:	40 41       	lddsp	r1,sp[0x10]
80007de0:	ed b5 00 05 	bld	r5,0x5
80007de4:	c5 11       	brne	80007e86 <_vfprintf_r+0x5ca>
80007de6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dea:	40 3c       	lddsp	r12,sp[0xc]
80007dec:	58 0c       	cp.w	r12,0
80007dee:	c1 e0       	breq	80007e2a <_vfprintf_r+0x56e>
80007df0:	10 36       	cp.w	r6,r8
80007df2:	c0 64       	brge	80007dfe <_vfprintf_r+0x542>
80007df4:	fa cb f9 44 	sub	r11,sp,-1724
80007df8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007dfc:	c2 08       	rjmp	80007e3c <_vfprintf_r+0x580>
80007dfe:	fa c8 f9 50 	sub	r8,sp,-1712
80007e02:	1a d8       	st.w	--sp,r8
80007e04:	fa c8 fa b8 	sub	r8,sp,-1352
80007e08:	0c 9b       	mov	r11,r6
80007e0a:	1a d8       	st.w	--sp,r8
80007e0c:	fa c8 fb b4 	sub	r8,sp,-1100
80007e10:	1a d8       	st.w	--sp,r8
80007e12:	fa c9 ff b4 	sub	r9,sp,-76
80007e16:	fa c8 f9 40 	sub	r8,sp,-1728
80007e1a:	04 9a       	mov	r10,r2
80007e1c:	08 9c       	mov	r12,r4
80007e1e:	fe b0 fb b7 	rcall	8000758c <get_arg>
80007e22:	2f dd       	sub	sp,-12
80007e24:	78 1b       	ld.w	r11,r12[0x4]
80007e26:	78 09       	ld.w	r9,r12[0x0]
80007e28:	c2 b8       	rjmp	80007e7e <_vfprintf_r+0x5c2>
80007e2a:	ee ca ff ff 	sub	r10,r7,-1
80007e2e:	10 37       	cp.w	r7,r8
80007e30:	c0 b4       	brge	80007e46 <_vfprintf_r+0x58a>
80007e32:	fa c9 f9 44 	sub	r9,sp,-1724
80007e36:	14 97       	mov	r7,r10
80007e38:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e3c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007e40:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007e44:	c1 d8       	rjmp	80007e7e <_vfprintf_r+0x5c2>
80007e46:	41 09       	lddsp	r9,sp[0x40]
80007e48:	59 f8       	cp.w	r8,31
80007e4a:	e0 89 00 14 	brgt	80007e72 <_vfprintf_r+0x5b6>
80007e4e:	f2 cb ff f8 	sub	r11,r9,-8
80007e52:	51 0b       	stdsp	sp[0x40],r11
80007e54:	fa c6 f9 44 	sub	r6,sp,-1724
80007e58:	72 1b       	ld.w	r11,r9[0x4]
80007e5a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007e5e:	72 09       	ld.w	r9,r9[0x0]
80007e60:	f9 4b fd 8c 	st.w	r12[-628],r11
80007e64:	f9 49 fd 88 	st.w	r12[-632],r9
80007e68:	2f f8       	sub	r8,-1
80007e6a:	14 97       	mov	r7,r10
80007e6c:	fb 48 06 b4 	st.w	sp[1716],r8
80007e70:	c0 78       	rjmp	80007e7e <_vfprintf_r+0x5c2>
80007e72:	f2 c8 ff f8 	sub	r8,r9,-8
80007e76:	72 1b       	ld.w	r11,r9[0x4]
80007e78:	14 97       	mov	r7,r10
80007e7a:	51 08       	stdsp	sp[0x40],r8
80007e7c:	72 09       	ld.w	r9,r9[0x0]
80007e7e:	16 98       	mov	r8,r11
80007e80:	fa e9 00 00 	st.d	sp[0],r8
80007e84:	ca e8       	rjmp	80007fe0 <_vfprintf_r+0x724>
80007e86:	ed b5 00 04 	bld	r5,0x4
80007e8a:	c1 71       	brne	80007eb8 <_vfprintf_r+0x5fc>
80007e8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e90:	40 3e       	lddsp	lr,sp[0xc]
80007e92:	58 0e       	cp.w	lr,0
80007e94:	c0 80       	breq	80007ea4 <_vfprintf_r+0x5e8>
80007e96:	10 36       	cp.w	r6,r8
80007e98:	c6 94       	brge	80007f6a <_vfprintf_r+0x6ae>
80007e9a:	fa cc f9 44 	sub	r12,sp,-1724
80007e9e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007ea2:	c8 28       	rjmp	80007fa6 <_vfprintf_r+0x6ea>
80007ea4:	ee ca ff ff 	sub	r10,r7,-1
80007ea8:	10 37       	cp.w	r7,r8
80007eaa:	e0 84 00 81 	brge	80007fac <_vfprintf_r+0x6f0>
80007eae:	fa cb f9 44 	sub	r11,sp,-1724
80007eb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007eb6:	c7 78       	rjmp	80007fa4 <_vfprintf_r+0x6e8>
80007eb8:	ed b5 00 06 	bld	r5,0x6
80007ebc:	c4 b1       	brne	80007f52 <_vfprintf_r+0x696>
80007ebe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ec2:	40 3c       	lddsp	r12,sp[0xc]
80007ec4:	58 0c       	cp.w	r12,0
80007ec6:	c1 d0       	breq	80007f00 <_vfprintf_r+0x644>
80007ec8:	10 36       	cp.w	r6,r8
80007eca:	c0 64       	brge	80007ed6 <_vfprintf_r+0x61a>
80007ecc:	fa cb f9 44 	sub	r11,sp,-1724
80007ed0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ed4:	c1 f8       	rjmp	80007f12 <_vfprintf_r+0x656>
80007ed6:	fa c8 f9 50 	sub	r8,sp,-1712
80007eda:	1a d8       	st.w	--sp,r8
80007edc:	fa c8 fa b8 	sub	r8,sp,-1352
80007ee0:	1a d8       	st.w	--sp,r8
80007ee2:	fa c8 fb b4 	sub	r8,sp,-1100
80007ee6:	1a d8       	st.w	--sp,r8
80007ee8:	fa c8 f9 40 	sub	r8,sp,-1728
80007eec:	fa c9 ff b4 	sub	r9,sp,-76
80007ef0:	04 9a       	mov	r10,r2
80007ef2:	0c 9b       	mov	r11,r6
80007ef4:	08 9c       	mov	r12,r4
80007ef6:	fe b0 fb 4b 	rcall	8000758c <get_arg>
80007efa:	2f dd       	sub	sp,-12
80007efc:	98 18       	ld.sh	r8,r12[0x2]
80007efe:	c2 68       	rjmp	80007f4a <_vfprintf_r+0x68e>
80007f00:	ee ca ff ff 	sub	r10,r7,-1
80007f04:	10 37       	cp.w	r7,r8
80007f06:	c0 94       	brge	80007f18 <_vfprintf_r+0x65c>
80007f08:	fa c9 f9 44 	sub	r9,sp,-1724
80007f0c:	14 97       	mov	r7,r10
80007f0e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f12:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f16:	c1 a8       	rjmp	80007f4a <_vfprintf_r+0x68e>
80007f18:	41 09       	lddsp	r9,sp[0x40]
80007f1a:	59 f8       	cp.w	r8,31
80007f1c:	e0 89 00 13 	brgt	80007f42 <_vfprintf_r+0x686>
80007f20:	f2 cb ff fc 	sub	r11,r9,-4
80007f24:	51 0b       	stdsp	sp[0x40],r11
80007f26:	72 09       	ld.w	r9,r9[0x0]
80007f28:	fa c6 f9 44 	sub	r6,sp,-1724
80007f2c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f30:	2f f8       	sub	r8,-1
80007f32:	f7 49 fd 88 	st.w	r11[-632],r9
80007f36:	fb 48 06 b4 	st.w	sp[1716],r8
80007f3a:	14 97       	mov	r7,r10
80007f3c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007f40:	c0 58       	rjmp	80007f4a <_vfprintf_r+0x68e>
80007f42:	92 18       	ld.sh	r8,r9[0x2]
80007f44:	14 97       	mov	r7,r10
80007f46:	2f c9       	sub	r9,-4
80007f48:	51 09       	stdsp	sp[0x40],r9
80007f4a:	50 18       	stdsp	sp[0x4],r8
80007f4c:	bf 58       	asr	r8,0x1f
80007f4e:	50 08       	stdsp	sp[0x0],r8
80007f50:	c4 88       	rjmp	80007fe0 <_vfprintf_r+0x724>
80007f52:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f56:	40 3c       	lddsp	r12,sp[0xc]
80007f58:	58 0c       	cp.w	r12,0
80007f5a:	c1 d0       	breq	80007f94 <_vfprintf_r+0x6d8>
80007f5c:	10 36       	cp.w	r6,r8
80007f5e:	c0 64       	brge	80007f6a <_vfprintf_r+0x6ae>
80007f60:	fa cb f9 44 	sub	r11,sp,-1724
80007f64:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f68:	c1 f8       	rjmp	80007fa6 <_vfprintf_r+0x6ea>
80007f6a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f6e:	1a d8       	st.w	--sp,r8
80007f70:	fa c8 fa b8 	sub	r8,sp,-1352
80007f74:	0c 9b       	mov	r11,r6
80007f76:	1a d8       	st.w	--sp,r8
80007f78:	fa c8 fb b4 	sub	r8,sp,-1100
80007f7c:	04 9a       	mov	r10,r2
80007f7e:	1a d8       	st.w	--sp,r8
80007f80:	08 9c       	mov	r12,r4
80007f82:	fa c8 f9 40 	sub	r8,sp,-1728
80007f86:	fa c9 ff b4 	sub	r9,sp,-76
80007f8a:	fe b0 fb 01 	rcall	8000758c <get_arg>
80007f8e:	2f dd       	sub	sp,-12
80007f90:	78 0b       	ld.w	r11,r12[0x0]
80007f92:	c2 48       	rjmp	80007fda <_vfprintf_r+0x71e>
80007f94:	ee ca ff ff 	sub	r10,r7,-1
80007f98:	10 37       	cp.w	r7,r8
80007f9a:	c0 94       	brge	80007fac <_vfprintf_r+0x6f0>
80007f9c:	fa c9 f9 44 	sub	r9,sp,-1724
80007fa0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fa4:	14 97       	mov	r7,r10
80007fa6:	ec fb fd 88 	ld.w	r11,r6[-632]
80007faa:	c1 88       	rjmp	80007fda <_vfprintf_r+0x71e>
80007fac:	41 09       	lddsp	r9,sp[0x40]
80007fae:	59 f8       	cp.w	r8,31
80007fb0:	e0 89 00 11 	brgt	80007fd2 <_vfprintf_r+0x716>
80007fb4:	f2 cb ff fc 	sub	r11,r9,-4
80007fb8:	51 0b       	stdsp	sp[0x40],r11
80007fba:	fa c6 f9 44 	sub	r6,sp,-1724
80007fbe:	72 0b       	ld.w	r11,r9[0x0]
80007fc0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fc4:	f3 4b fd 88 	st.w	r9[-632],r11
80007fc8:	2f f8       	sub	r8,-1
80007fca:	14 97       	mov	r7,r10
80007fcc:	fb 48 06 b4 	st.w	sp[1716],r8
80007fd0:	c0 58       	rjmp	80007fda <_vfprintf_r+0x71e>
80007fd2:	72 0b       	ld.w	r11,r9[0x0]
80007fd4:	14 97       	mov	r7,r10
80007fd6:	2f c9       	sub	r9,-4
80007fd8:	51 09       	stdsp	sp[0x40],r9
80007fda:	50 1b       	stdsp	sp[0x4],r11
80007fdc:	bf 5b       	asr	r11,0x1f
80007fde:	50 0b       	stdsp	sp[0x0],r11
80007fe0:	fa ea 00 00 	ld.d	r10,sp[0]
80007fe4:	58 0a       	cp.w	r10,0
80007fe6:	5c 2b       	cpc	r11
80007fe8:	c0 e4       	brge	80008004 <_vfprintf_r+0x748>
80007fea:	30 08       	mov	r8,0
80007fec:	fa ea 00 00 	ld.d	r10,sp[0]
80007ff0:	30 09       	mov	r9,0
80007ff2:	f0 0a 01 0a 	sub	r10,r8,r10
80007ff6:	f2 0b 01 4b 	sbc	r11,r9,r11
80007ffa:	32 d8       	mov	r8,45
80007ffc:	fa eb 00 00 	st.d	sp[0],r10
80008000:	fb 68 06 bb 	st.b	sp[1723],r8
80008004:	30 18       	mov	r8,1
80008006:	e0 8f 06 fa 	bral	80008dfa <_vfprintf_r+0x153e>
8000800a:	50 a7       	stdsp	sp[0x28],r7
8000800c:	50 80       	stdsp	sp[0x20],r0
8000800e:	0c 97       	mov	r7,r6
80008010:	04 94       	mov	r4,r2
80008012:	06 96       	mov	r6,r3
80008014:	02 92       	mov	r2,r1
80008016:	40 93       	lddsp	r3,sp[0x24]
80008018:	10 90       	mov	r0,r8
8000801a:	40 41       	lddsp	r1,sp[0x10]
8000801c:	0e 99       	mov	r9,r7
8000801e:	ed b5 00 03 	bld	r5,0x3
80008022:	c4 11       	brne	800080a4 <_vfprintf_r+0x7e8>
80008024:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008028:	40 3a       	lddsp	r10,sp[0xc]
8000802a:	58 0a       	cp.w	r10,0
8000802c:	c1 90       	breq	8000805e <_vfprintf_r+0x7a2>
8000802e:	10 36       	cp.w	r6,r8
80008030:	c6 45       	brlt	800080f8 <_vfprintf_r+0x83c>
80008032:	fa c8 f9 50 	sub	r8,sp,-1712
80008036:	1a d8       	st.w	--sp,r8
80008038:	fa c8 fa b8 	sub	r8,sp,-1352
8000803c:	1a d8       	st.w	--sp,r8
8000803e:	fa c8 fb b4 	sub	r8,sp,-1100
80008042:	0c 9b       	mov	r11,r6
80008044:	1a d8       	st.w	--sp,r8
80008046:	04 9a       	mov	r10,r2
80008048:	fa c8 f9 40 	sub	r8,sp,-1728
8000804c:	fa c9 ff b4 	sub	r9,sp,-76
80008050:	08 9c       	mov	r12,r4
80008052:	fe b0 fa 9d 	rcall	8000758c <get_arg>
80008056:	2f dd       	sub	sp,-12
80008058:	78 16       	ld.w	r6,r12[0x4]
8000805a:	50 76       	stdsp	sp[0x1c],r6
8000805c:	c4 88       	rjmp	800080ec <_vfprintf_r+0x830>
8000805e:	2f f7       	sub	r7,-1
80008060:	10 39       	cp.w	r9,r8
80008062:	c0 c4       	brge	8000807a <_vfprintf_r+0x7be>
80008064:	fa ce f9 44 	sub	lr,sp,-1724
80008068:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000806c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008070:	50 7c       	stdsp	sp[0x1c],r12
80008072:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008076:	50 56       	stdsp	sp[0x14],r6
80008078:	c6 68       	rjmp	80008144 <_vfprintf_r+0x888>
8000807a:	41 09       	lddsp	r9,sp[0x40]
8000807c:	59 f8       	cp.w	r8,31
8000807e:	e0 89 00 10 	brgt	8000809e <_vfprintf_r+0x7e2>
80008082:	f2 ca ff f8 	sub	r10,r9,-8
80008086:	72 1b       	ld.w	r11,r9[0x4]
80008088:	51 0a       	stdsp	sp[0x40],r10
8000808a:	72 09       	ld.w	r9,r9[0x0]
8000808c:	fa ca f9 44 	sub	r10,sp,-1724
80008090:	50 7b       	stdsp	sp[0x1c],r11
80008092:	50 59       	stdsp	sp[0x14],r9
80008094:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008098:	40 5b       	lddsp	r11,sp[0x14]
8000809a:	40 7a       	lddsp	r10,sp[0x1c]
8000809c:	c4 78       	rjmp	8000812a <_vfprintf_r+0x86e>
8000809e:	72 18       	ld.w	r8,r9[0x4]
800080a0:	50 78       	stdsp	sp[0x1c],r8
800080a2:	c4 c8       	rjmp	8000813a <_vfprintf_r+0x87e>
800080a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080a8:	40 3e       	lddsp	lr,sp[0xc]
800080aa:	58 0e       	cp.w	lr,0
800080ac:	c2 30       	breq	800080f2 <_vfprintf_r+0x836>
800080ae:	10 36       	cp.w	r6,r8
800080b0:	c0 94       	brge	800080c2 <_vfprintf_r+0x806>
800080b2:	fa cc f9 44 	sub	r12,sp,-1724
800080b6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080ba:	ec fb fd 8c 	ld.w	r11,r6[-628]
800080be:	50 7b       	stdsp	sp[0x1c],r11
800080c0:	cd 9b       	rjmp	80008072 <_vfprintf_r+0x7b6>
800080c2:	fa c8 f9 50 	sub	r8,sp,-1712
800080c6:	1a d8       	st.w	--sp,r8
800080c8:	fa c8 fa b8 	sub	r8,sp,-1352
800080cc:	04 9a       	mov	r10,r2
800080ce:	1a d8       	st.w	--sp,r8
800080d0:	fa c8 fb b4 	sub	r8,sp,-1100
800080d4:	0c 9b       	mov	r11,r6
800080d6:	1a d8       	st.w	--sp,r8
800080d8:	08 9c       	mov	r12,r4
800080da:	fa c8 f9 40 	sub	r8,sp,-1728
800080de:	fa c9 ff b4 	sub	r9,sp,-76
800080e2:	fe b0 fa 55 	rcall	8000758c <get_arg>
800080e6:	2f dd       	sub	sp,-12
800080e8:	78 1a       	ld.w	r10,r12[0x4]
800080ea:	50 7a       	stdsp	sp[0x1c],r10
800080ec:	78 0c       	ld.w	r12,r12[0x0]
800080ee:	50 5c       	stdsp	sp[0x14],r12
800080f0:	c2 a8       	rjmp	80008144 <_vfprintf_r+0x888>
800080f2:	2f f7       	sub	r7,-1
800080f4:	10 39       	cp.w	r9,r8
800080f6:	c0 94       	brge	80008108 <_vfprintf_r+0x84c>
800080f8:	fa c9 f9 44 	sub	r9,sp,-1724
800080fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008100:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008104:	50 78       	stdsp	sp[0x1c],r8
80008106:	cb 6b       	rjmp	80008072 <_vfprintf_r+0x7b6>
80008108:	41 09       	lddsp	r9,sp[0x40]
8000810a:	59 f8       	cp.w	r8,31
8000810c:	e0 89 00 15 	brgt	80008136 <_vfprintf_r+0x87a>
80008110:	f2 ca ff f8 	sub	r10,r9,-8
80008114:	72 16       	ld.w	r6,r9[0x4]
80008116:	72 09       	ld.w	r9,r9[0x0]
80008118:	51 0a       	stdsp	sp[0x40],r10
8000811a:	50 59       	stdsp	sp[0x14],r9
8000811c:	fa ce f9 44 	sub	lr,sp,-1724
80008120:	50 76       	stdsp	sp[0x1c],r6
80008122:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008126:	40 5b       	lddsp	r11,sp[0x14]
80008128:	0c 9a       	mov	r10,r6
8000812a:	f2 eb fd 88 	st.d	r9[-632],r10
8000812e:	2f f8       	sub	r8,-1
80008130:	fb 48 06 b4 	st.w	sp[1716],r8
80008134:	c0 88       	rjmp	80008144 <_vfprintf_r+0x888>
80008136:	72 1c       	ld.w	r12,r9[0x4]
80008138:	50 7c       	stdsp	sp[0x1c],r12
8000813a:	f2 c8 ff f8 	sub	r8,r9,-8
8000813e:	51 08       	stdsp	sp[0x40],r8
80008140:	72 09       	ld.w	r9,r9[0x0]
80008142:	50 59       	stdsp	sp[0x14],r9
80008144:	40 5b       	lddsp	r11,sp[0x14]
80008146:	40 7a       	lddsp	r10,sp[0x1c]
80008148:	e0 a0 19 54 	rcall	8000b3f0 <__isinfd>
8000814c:	18 96       	mov	r6,r12
8000814e:	c1 70       	breq	8000817c <_vfprintf_r+0x8c0>
80008150:	30 08       	mov	r8,0
80008152:	30 09       	mov	r9,0
80008154:	40 5b       	lddsp	r11,sp[0x14]
80008156:	40 7a       	lddsp	r10,sp[0x1c]
80008158:	e0 a0 1d a8 	rcall	8000bca8 <__avr32_f64_cmp_lt>
8000815c:	c0 40       	breq	80008164 <_vfprintf_r+0x8a8>
8000815e:	32 d8       	mov	r8,45
80008160:	fb 68 06 bb 	st.b	sp[1723],r8
80008164:	fe c8 aa 54 	sub	r8,pc,-21932
80008168:	fe c6 aa 54 	sub	r6,pc,-21932
8000816c:	a7 d5       	cbr	r5,0x7
8000816e:	e0 40 00 47 	cp.w	r0,71
80008172:	f0 06 17 a0 	movle	r6,r8
80008176:	30 32       	mov	r2,3
80008178:	e0 8f 06 ce 	bral	80008f14 <_vfprintf_r+0x1658>
8000817c:	40 5b       	lddsp	r11,sp[0x14]
8000817e:	40 7a       	lddsp	r10,sp[0x1c]
80008180:	e0 a0 19 4d 	rcall	8000b41a <__isnand>
80008184:	c0 e0       	breq	800081a0 <_vfprintf_r+0x8e4>
80008186:	50 26       	stdsp	sp[0x8],r6
80008188:	fe c8 aa 70 	sub	r8,pc,-21904
8000818c:	fe c6 aa 70 	sub	r6,pc,-21904
80008190:	a7 d5       	cbr	r5,0x7
80008192:	e0 40 00 47 	cp.w	r0,71
80008196:	f0 06 17 a0 	movle	r6,r8
8000819a:	30 32       	mov	r2,3
8000819c:	e0 8f 06 c2 	bral	80008f20 <_vfprintf_r+0x1664>
800081a0:	40 2a       	lddsp	r10,sp[0x8]
800081a2:	5b fa       	cp.w	r10,-1
800081a4:	c0 41       	brne	800081ac <_vfprintf_r+0x8f0>
800081a6:	30 69       	mov	r9,6
800081a8:	50 29       	stdsp	sp[0x8],r9
800081aa:	c1 18       	rjmp	800081cc <_vfprintf_r+0x910>
800081ac:	e0 40 00 47 	cp.w	r0,71
800081b0:	5f 09       	sreq	r9
800081b2:	e0 40 00 67 	cp.w	r0,103
800081b6:	5f 08       	sreq	r8
800081b8:	f3 e8 10 08 	or	r8,r9,r8
800081bc:	f8 08 18 00 	cp.b	r8,r12
800081c0:	c0 60       	breq	800081cc <_vfprintf_r+0x910>
800081c2:	40 28       	lddsp	r8,sp[0x8]
800081c4:	58 08       	cp.w	r8,0
800081c6:	f9 b8 00 01 	moveq	r8,1
800081ca:	50 28       	stdsp	sp[0x8],r8
800081cc:	40 78       	lddsp	r8,sp[0x1c]
800081ce:	40 59       	lddsp	r9,sp[0x14]
800081d0:	fa e9 06 94 	st.d	sp[1684],r8
800081d4:	a9 a5       	sbr	r5,0x8
800081d6:	fa f8 06 94 	ld.w	r8,sp[1684]
800081da:	58 08       	cp.w	r8,0
800081dc:	c0 65       	brlt	800081e8 <_vfprintf_r+0x92c>
800081de:	40 5e       	lddsp	lr,sp[0x14]
800081e0:	30 0c       	mov	r12,0
800081e2:	50 6e       	stdsp	sp[0x18],lr
800081e4:	50 9c       	stdsp	sp[0x24],r12
800081e6:	c0 78       	rjmp	800081f4 <_vfprintf_r+0x938>
800081e8:	40 5b       	lddsp	r11,sp[0x14]
800081ea:	32 da       	mov	r10,45
800081ec:	ee 1b 80 00 	eorh	r11,0x8000
800081f0:	50 9a       	stdsp	sp[0x24],r10
800081f2:	50 6b       	stdsp	sp[0x18],r11
800081f4:	e0 40 00 46 	cp.w	r0,70
800081f8:	5f 09       	sreq	r9
800081fa:	e0 40 00 66 	cp.w	r0,102
800081fe:	5f 08       	sreq	r8
80008200:	f3 e8 10 08 	or	r8,r9,r8
80008204:	50 48       	stdsp	sp[0x10],r8
80008206:	c0 40       	breq	8000820e <_vfprintf_r+0x952>
80008208:	40 22       	lddsp	r2,sp[0x8]
8000820a:	30 39       	mov	r9,3
8000820c:	c1 08       	rjmp	8000822c <_vfprintf_r+0x970>
8000820e:	e0 40 00 45 	cp.w	r0,69
80008212:	5f 09       	sreq	r9
80008214:	e0 40 00 65 	cp.w	r0,101
80008218:	5f 08       	sreq	r8
8000821a:	40 22       	lddsp	r2,sp[0x8]
8000821c:	10 49       	or	r9,r8
8000821e:	2f f2       	sub	r2,-1
80008220:	40 46       	lddsp	r6,sp[0x10]
80008222:	ec 09 18 00 	cp.b	r9,r6
80008226:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000822a:	30 29       	mov	r9,2
8000822c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008230:	1a d8       	st.w	--sp,r8
80008232:	fa c8 f9 54 	sub	r8,sp,-1708
80008236:	1a d8       	st.w	--sp,r8
80008238:	fa c8 f9 4c 	sub	r8,sp,-1716
8000823c:	08 9c       	mov	r12,r4
8000823e:	1a d8       	st.w	--sp,r8
80008240:	04 98       	mov	r8,r2
80008242:	40 9b       	lddsp	r11,sp[0x24]
80008244:	40 aa       	lddsp	r10,sp[0x28]
80008246:	e0 a0 0b c3 	rcall	800099cc <_dtoa_r>
8000824a:	e0 40 00 47 	cp.w	r0,71
8000824e:	5f 19       	srne	r9
80008250:	e0 40 00 67 	cp.w	r0,103
80008254:	5f 18       	srne	r8
80008256:	18 96       	mov	r6,r12
80008258:	2f dd       	sub	sp,-12
8000825a:	f3 e8 00 08 	and	r8,r9,r8
8000825e:	c0 41       	brne	80008266 <_vfprintf_r+0x9aa>
80008260:	ed b5 00 00 	bld	r5,0x0
80008264:	c3 01       	brne	800082c4 <_vfprintf_r+0xa08>
80008266:	ec 02 00 0e 	add	lr,r6,r2
8000826a:	50 3e       	stdsp	sp[0xc],lr
8000826c:	40 4c       	lddsp	r12,sp[0x10]
8000826e:	58 0c       	cp.w	r12,0
80008270:	c1 50       	breq	8000829a <_vfprintf_r+0x9de>
80008272:	0d 89       	ld.ub	r9,r6[0x0]
80008274:	33 08       	mov	r8,48
80008276:	f0 09 18 00 	cp.b	r9,r8
8000827a:	c0 b1       	brne	80008290 <_vfprintf_r+0x9d4>
8000827c:	30 08       	mov	r8,0
8000827e:	30 09       	mov	r9,0
80008280:	40 6b       	lddsp	r11,sp[0x18]
80008282:	40 7a       	lddsp	r10,sp[0x1c]
80008284:	e0 a0 1c cb 	rcall	8000bc1a <__avr32_f64_cmp_eq>
80008288:	fb b2 00 01 	rsubeq	r2,1
8000828c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008290:	40 3b       	lddsp	r11,sp[0xc]
80008292:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008296:	10 0b       	add	r11,r8
80008298:	50 3b       	stdsp	sp[0xc],r11
8000829a:	40 6b       	lddsp	r11,sp[0x18]
8000829c:	30 08       	mov	r8,0
8000829e:	30 09       	mov	r9,0
800082a0:	40 7a       	lddsp	r10,sp[0x1c]
800082a2:	e0 a0 1c bc 	rcall	8000bc1a <__avr32_f64_cmp_eq>
800082a6:	c0 90       	breq	800082b8 <_vfprintf_r+0x9fc>
800082a8:	40 3a       	lddsp	r10,sp[0xc]
800082aa:	fb 4a 06 a4 	st.w	sp[1700],r10
800082ae:	c0 58       	rjmp	800082b8 <_vfprintf_r+0x9fc>
800082b0:	10 c9       	st.b	r8++,r9
800082b2:	fb 48 06 a4 	st.w	sp[1700],r8
800082b6:	c0 28       	rjmp	800082ba <_vfprintf_r+0x9fe>
800082b8:	33 09       	mov	r9,48
800082ba:	fa f8 06 a4 	ld.w	r8,sp[1700]
800082be:	40 3e       	lddsp	lr,sp[0xc]
800082c0:	1c 38       	cp.w	r8,lr
800082c2:	cf 73       	brcs	800082b0 <_vfprintf_r+0x9f4>
800082c4:	e0 40 00 47 	cp.w	r0,71
800082c8:	5f 09       	sreq	r9
800082ca:	e0 40 00 67 	cp.w	r0,103
800082ce:	5f 08       	sreq	r8
800082d0:	f3 e8 10 08 	or	r8,r9,r8
800082d4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800082d8:	0c 19       	sub	r9,r6
800082da:	50 69       	stdsp	sp[0x18],r9
800082dc:	58 08       	cp.w	r8,0
800082de:	c0 b0       	breq	800082f4 <_vfprintf_r+0xa38>
800082e0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800082e4:	5b d8       	cp.w	r8,-3
800082e6:	c0 55       	brlt	800082f0 <_vfprintf_r+0xa34>
800082e8:	40 2c       	lddsp	r12,sp[0x8]
800082ea:	18 38       	cp.w	r8,r12
800082ec:	e0 8a 00 6a 	brle	800083c0 <_vfprintf_r+0xb04>
800082f0:	20 20       	sub	r0,2
800082f2:	c0 58       	rjmp	800082fc <_vfprintf_r+0xa40>
800082f4:	e0 40 00 65 	cp.w	r0,101
800082f8:	e0 89 00 46 	brgt	80008384 <_vfprintf_r+0xac8>
800082fc:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008300:	fb 60 06 9c 	st.b	sp[1692],r0
80008304:	20 1b       	sub	r11,1
80008306:	fb 4b 06 ac 	st.w	sp[1708],r11
8000830a:	c0 47       	brpl	80008312 <_vfprintf_r+0xa56>
8000830c:	5c 3b       	neg	r11
8000830e:	32 d8       	mov	r8,45
80008310:	c0 28       	rjmp	80008314 <_vfprintf_r+0xa58>
80008312:	32 b8       	mov	r8,43
80008314:	fb 68 06 9d 	st.b	sp[1693],r8
80008318:	58 9b       	cp.w	r11,9
8000831a:	e0 8a 00 1d 	brle	80008354 <_vfprintf_r+0xa98>
8000831e:	fa c9 fa 35 	sub	r9,sp,-1483
80008322:	30 aa       	mov	r10,10
80008324:	12 98       	mov	r8,r9
80008326:	0e 9c       	mov	r12,r7
80008328:	0c 92       	mov	r2,r6
8000832a:	f6 0a 0c 06 	divs	r6,r11,r10
8000832e:	0e 9b       	mov	r11,r7
80008330:	2d 0b       	sub	r11,-48
80008332:	10 fb       	st.b	--r8,r11
80008334:	0c 9b       	mov	r11,r6
80008336:	58 96       	cp.w	r6,9
80008338:	fe 99 ff f9 	brgt	8000832a <_vfprintf_r+0xa6e>
8000833c:	2d 0b       	sub	r11,-48
8000833e:	18 97       	mov	r7,r12
80008340:	04 96       	mov	r6,r2
80008342:	10 fb       	st.b	--r8,r11
80008344:	fa ca f9 62 	sub	r10,sp,-1694
80008348:	c0 38       	rjmp	8000834e <_vfprintf_r+0xa92>
8000834a:	11 3b       	ld.ub	r11,r8++
8000834c:	14 cb       	st.b	r10++,r11
8000834e:	12 38       	cp.w	r8,r9
80008350:	cf d3       	brcs	8000834a <_vfprintf_r+0xa8e>
80008352:	c0 98       	rjmp	80008364 <_vfprintf_r+0xaa8>
80008354:	2d 0b       	sub	r11,-48
80008356:	33 08       	mov	r8,48
80008358:	fb 6b 06 9f 	st.b	sp[1695],r11
8000835c:	fb 68 06 9e 	st.b	sp[1694],r8
80008360:	fa ca f9 60 	sub	r10,sp,-1696
80008364:	fa c8 f9 64 	sub	r8,sp,-1692
80008368:	f4 08 01 08 	sub	r8,r10,r8
8000836c:	50 e8       	stdsp	sp[0x38],r8
8000836e:	10 92       	mov	r2,r8
80008370:	40 6b       	lddsp	r11,sp[0x18]
80008372:	16 02       	add	r2,r11
80008374:	58 1b       	cp.w	r11,1
80008376:	e0 89 00 05 	brgt	80008380 <_vfprintf_r+0xac4>
8000837a:	ed b5 00 00 	bld	r5,0x0
8000837e:	c3 51       	brne	800083e8 <_vfprintf_r+0xb2c>
80008380:	2f f2       	sub	r2,-1
80008382:	c3 38       	rjmp	800083e8 <_vfprintf_r+0xb2c>
80008384:	e0 40 00 66 	cp.w	r0,102
80008388:	c1 c1       	brne	800083c0 <_vfprintf_r+0xb04>
8000838a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000838e:	58 02       	cp.w	r2,0
80008390:	e0 8a 00 0c 	brle	800083a8 <_vfprintf_r+0xaec>
80008394:	40 2a       	lddsp	r10,sp[0x8]
80008396:	58 0a       	cp.w	r10,0
80008398:	c0 41       	brne	800083a0 <_vfprintf_r+0xae4>
8000839a:	ed b5 00 00 	bld	r5,0x0
8000839e:	c2 51       	brne	800083e8 <_vfprintf_r+0xb2c>
800083a0:	2f f2       	sub	r2,-1
800083a2:	40 29       	lddsp	r9,sp[0x8]
800083a4:	12 02       	add	r2,r9
800083a6:	c0 b8       	rjmp	800083bc <_vfprintf_r+0xb00>
800083a8:	40 28       	lddsp	r8,sp[0x8]
800083aa:	58 08       	cp.w	r8,0
800083ac:	c0 61       	brne	800083b8 <_vfprintf_r+0xafc>
800083ae:	ed b5 00 00 	bld	r5,0x0
800083b2:	c0 30       	breq	800083b8 <_vfprintf_r+0xafc>
800083b4:	30 12       	mov	r2,1
800083b6:	c1 98       	rjmp	800083e8 <_vfprintf_r+0xb2c>
800083b8:	40 22       	lddsp	r2,sp[0x8]
800083ba:	2f e2       	sub	r2,-2
800083bc:	36 60       	mov	r0,102
800083be:	c1 58       	rjmp	800083e8 <_vfprintf_r+0xb2c>
800083c0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800083c4:	40 6e       	lddsp	lr,sp[0x18]
800083c6:	1c 32       	cp.w	r2,lr
800083c8:	c0 65       	brlt	800083d4 <_vfprintf_r+0xb18>
800083ca:	ed b5 00 00 	bld	r5,0x0
800083ce:	f7 b2 00 ff 	subeq	r2,-1
800083d2:	c0 a8       	rjmp	800083e6 <_vfprintf_r+0xb2a>
800083d4:	e4 08 11 02 	rsub	r8,r2,2
800083d8:	40 6c       	lddsp	r12,sp[0x18]
800083da:	58 02       	cp.w	r2,0
800083dc:	f0 02 17 a0 	movle	r2,r8
800083e0:	f9 b2 09 01 	movgt	r2,1
800083e4:	18 02       	add	r2,r12
800083e6:	36 70       	mov	r0,103
800083e8:	40 9b       	lddsp	r11,sp[0x24]
800083ea:	58 0b       	cp.w	r11,0
800083ec:	e0 80 05 94 	breq	80008f14 <_vfprintf_r+0x1658>
800083f0:	32 d8       	mov	r8,45
800083f2:	fb 68 06 bb 	st.b	sp[1723],r8
800083f6:	e0 8f 05 93 	bral	80008f1c <_vfprintf_r+0x1660>
800083fa:	50 a7       	stdsp	sp[0x28],r7
800083fc:	04 94       	mov	r4,r2
800083fe:	0c 97       	mov	r7,r6
80008400:	02 92       	mov	r2,r1
80008402:	06 96       	mov	r6,r3
80008404:	40 41       	lddsp	r1,sp[0x10]
80008406:	40 93       	lddsp	r3,sp[0x24]
80008408:	0e 99       	mov	r9,r7
8000840a:	ed b5 00 05 	bld	r5,0x5
8000840e:	c4 81       	brne	8000849e <_vfprintf_r+0xbe2>
80008410:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008414:	40 3e       	lddsp	lr,sp[0xc]
80008416:	58 0e       	cp.w	lr,0
80008418:	c1 d0       	breq	80008452 <_vfprintf_r+0xb96>
8000841a:	10 36       	cp.w	r6,r8
8000841c:	c0 64       	brge	80008428 <_vfprintf_r+0xb6c>
8000841e:	fa cc f9 44 	sub	r12,sp,-1724
80008422:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008426:	c1 d8       	rjmp	80008460 <_vfprintf_r+0xba4>
80008428:	fa c8 f9 50 	sub	r8,sp,-1712
8000842c:	1a d8       	st.w	--sp,r8
8000842e:	fa c8 fa b8 	sub	r8,sp,-1352
80008432:	04 9a       	mov	r10,r2
80008434:	1a d8       	st.w	--sp,r8
80008436:	fa c8 fb b4 	sub	r8,sp,-1100
8000843a:	0c 9b       	mov	r11,r6
8000843c:	1a d8       	st.w	--sp,r8
8000843e:	08 9c       	mov	r12,r4
80008440:	fa c8 f9 40 	sub	r8,sp,-1728
80008444:	fa c9 ff b4 	sub	r9,sp,-76
80008448:	fe b0 f8 a2 	rcall	8000758c <get_arg>
8000844c:	2f dd       	sub	sp,-12
8000844e:	78 0a       	ld.w	r10,r12[0x0]
80008450:	c2 08       	rjmp	80008490 <_vfprintf_r+0xbd4>
80008452:	2f f7       	sub	r7,-1
80008454:	10 39       	cp.w	r9,r8
80008456:	c0 84       	brge	80008466 <_vfprintf_r+0xbaa>
80008458:	fa cb f9 44 	sub	r11,sp,-1724
8000845c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008460:	ec fa fd 88 	ld.w	r10,r6[-632]
80008464:	c1 68       	rjmp	80008490 <_vfprintf_r+0xbd4>
80008466:	41 09       	lddsp	r9,sp[0x40]
80008468:	59 f8       	cp.w	r8,31
8000846a:	e0 89 00 10 	brgt	8000848a <_vfprintf_r+0xbce>
8000846e:	f2 ca ff fc 	sub	r10,r9,-4
80008472:	51 0a       	stdsp	sp[0x40],r10
80008474:	fa c6 f9 44 	sub	r6,sp,-1724
80008478:	72 0a       	ld.w	r10,r9[0x0]
8000847a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000847e:	f3 4a fd 88 	st.w	r9[-632],r10
80008482:	2f f8       	sub	r8,-1
80008484:	fb 48 06 b4 	st.w	sp[1716],r8
80008488:	c0 48       	rjmp	80008490 <_vfprintf_r+0xbd4>
8000848a:	72 0a       	ld.w	r10,r9[0x0]
8000848c:	2f c9       	sub	r9,-4
8000848e:	51 09       	stdsp	sp[0x40],r9
80008490:	40 be       	lddsp	lr,sp[0x2c]
80008492:	1c 98       	mov	r8,lr
80008494:	95 1e       	st.w	r10[0x4],lr
80008496:	bf 58       	asr	r8,0x1f
80008498:	95 08       	st.w	r10[0x0],r8
8000849a:	fe 9f fa 9f 	bral	800079d8 <_vfprintf_r+0x11c>
8000849e:	ed b5 00 04 	bld	r5,0x4
800084a2:	c4 80       	breq	80008532 <_vfprintf_r+0xc76>
800084a4:	e2 15 00 40 	andl	r5,0x40,COH
800084a8:	c4 50       	breq	80008532 <_vfprintf_r+0xc76>
800084aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084ae:	40 3c       	lddsp	r12,sp[0xc]
800084b0:	58 0c       	cp.w	r12,0
800084b2:	c1 d0       	breq	800084ec <_vfprintf_r+0xc30>
800084b4:	10 36       	cp.w	r6,r8
800084b6:	c0 64       	brge	800084c2 <_vfprintf_r+0xc06>
800084b8:	fa cb f9 44 	sub	r11,sp,-1724
800084bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084c0:	c1 d8       	rjmp	800084fa <_vfprintf_r+0xc3e>
800084c2:	fa c8 f9 50 	sub	r8,sp,-1712
800084c6:	1a d8       	st.w	--sp,r8
800084c8:	fa c8 fa b8 	sub	r8,sp,-1352
800084cc:	04 9a       	mov	r10,r2
800084ce:	1a d8       	st.w	--sp,r8
800084d0:	fa c8 fb b4 	sub	r8,sp,-1100
800084d4:	0c 9b       	mov	r11,r6
800084d6:	1a d8       	st.w	--sp,r8
800084d8:	08 9c       	mov	r12,r4
800084da:	fa c8 f9 40 	sub	r8,sp,-1728
800084de:	fa c9 ff b4 	sub	r9,sp,-76
800084e2:	fe b0 f8 55 	rcall	8000758c <get_arg>
800084e6:	2f dd       	sub	sp,-12
800084e8:	78 0a       	ld.w	r10,r12[0x0]
800084ea:	c2 08       	rjmp	8000852a <_vfprintf_r+0xc6e>
800084ec:	2f f7       	sub	r7,-1
800084ee:	10 39       	cp.w	r9,r8
800084f0:	c0 84       	brge	80008500 <_vfprintf_r+0xc44>
800084f2:	fa ca f9 44 	sub	r10,sp,-1724
800084f6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084fa:	ec fa fd 88 	ld.w	r10,r6[-632]
800084fe:	c1 68       	rjmp	8000852a <_vfprintf_r+0xc6e>
80008500:	41 09       	lddsp	r9,sp[0x40]
80008502:	59 f8       	cp.w	r8,31
80008504:	e0 89 00 10 	brgt	80008524 <_vfprintf_r+0xc68>
80008508:	f2 ca ff fc 	sub	r10,r9,-4
8000850c:	51 0a       	stdsp	sp[0x40],r10
8000850e:	fa c6 f9 44 	sub	r6,sp,-1724
80008512:	72 0a       	ld.w	r10,r9[0x0]
80008514:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008518:	f3 4a fd 88 	st.w	r9[-632],r10
8000851c:	2f f8       	sub	r8,-1
8000851e:	fb 48 06 b4 	st.w	sp[1716],r8
80008522:	c0 48       	rjmp	8000852a <_vfprintf_r+0xc6e>
80008524:	72 0a       	ld.w	r10,r9[0x0]
80008526:	2f c9       	sub	r9,-4
80008528:	51 09       	stdsp	sp[0x40],r9
8000852a:	40 be       	lddsp	lr,sp[0x2c]
8000852c:	b4 0e       	st.h	r10[0x0],lr
8000852e:	fe 9f fa 55 	bral	800079d8 <_vfprintf_r+0x11c>
80008532:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008536:	40 3c       	lddsp	r12,sp[0xc]
80008538:	58 0c       	cp.w	r12,0
8000853a:	c1 d0       	breq	80008574 <_vfprintf_r+0xcb8>
8000853c:	10 36       	cp.w	r6,r8
8000853e:	c0 64       	brge	8000854a <_vfprintf_r+0xc8e>
80008540:	fa cb f9 44 	sub	r11,sp,-1724
80008544:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008548:	c1 d8       	rjmp	80008582 <_vfprintf_r+0xcc6>
8000854a:	fa c8 f9 50 	sub	r8,sp,-1712
8000854e:	1a d8       	st.w	--sp,r8
80008550:	fa c8 fa b8 	sub	r8,sp,-1352
80008554:	04 9a       	mov	r10,r2
80008556:	1a d8       	st.w	--sp,r8
80008558:	fa c8 fb b4 	sub	r8,sp,-1100
8000855c:	0c 9b       	mov	r11,r6
8000855e:	1a d8       	st.w	--sp,r8
80008560:	08 9c       	mov	r12,r4
80008562:	fa c8 f9 40 	sub	r8,sp,-1728
80008566:	fa c9 ff b4 	sub	r9,sp,-76
8000856a:	fe b0 f8 11 	rcall	8000758c <get_arg>
8000856e:	2f dd       	sub	sp,-12
80008570:	78 0a       	ld.w	r10,r12[0x0]
80008572:	c2 08       	rjmp	800085b2 <_vfprintf_r+0xcf6>
80008574:	2f f7       	sub	r7,-1
80008576:	10 39       	cp.w	r9,r8
80008578:	c0 84       	brge	80008588 <_vfprintf_r+0xccc>
8000857a:	fa ca f9 44 	sub	r10,sp,-1724
8000857e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008582:	ec fa fd 88 	ld.w	r10,r6[-632]
80008586:	c1 68       	rjmp	800085b2 <_vfprintf_r+0xcf6>
80008588:	41 09       	lddsp	r9,sp[0x40]
8000858a:	59 f8       	cp.w	r8,31
8000858c:	e0 89 00 10 	brgt	800085ac <_vfprintf_r+0xcf0>
80008590:	f2 ca ff fc 	sub	r10,r9,-4
80008594:	51 0a       	stdsp	sp[0x40],r10
80008596:	fa c6 f9 44 	sub	r6,sp,-1724
8000859a:	72 0a       	ld.w	r10,r9[0x0]
8000859c:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085a0:	f3 4a fd 88 	st.w	r9[-632],r10
800085a4:	2f f8       	sub	r8,-1
800085a6:	fb 48 06 b4 	st.w	sp[1716],r8
800085aa:	c0 48       	rjmp	800085b2 <_vfprintf_r+0xcf6>
800085ac:	72 0a       	ld.w	r10,r9[0x0]
800085ae:	2f c9       	sub	r9,-4
800085b0:	51 09       	stdsp	sp[0x40],r9
800085b2:	40 be       	lddsp	lr,sp[0x2c]
800085b4:	95 0e       	st.w	r10[0x0],lr
800085b6:	fe 9f fa 11 	bral	800079d8 <_vfprintf_r+0x11c>
800085ba:	50 a7       	stdsp	sp[0x28],r7
800085bc:	50 80       	stdsp	sp[0x20],r0
800085be:	0c 97       	mov	r7,r6
800085c0:	04 94       	mov	r4,r2
800085c2:	06 96       	mov	r6,r3
800085c4:	02 92       	mov	r2,r1
800085c6:	40 93       	lddsp	r3,sp[0x24]
800085c8:	10 90       	mov	r0,r8
800085ca:	40 41       	lddsp	r1,sp[0x10]
800085cc:	a5 a5       	sbr	r5,0x4
800085ce:	c0 a8       	rjmp	800085e2 <_vfprintf_r+0xd26>
800085d0:	50 a7       	stdsp	sp[0x28],r7
800085d2:	50 80       	stdsp	sp[0x20],r0
800085d4:	0c 97       	mov	r7,r6
800085d6:	04 94       	mov	r4,r2
800085d8:	06 96       	mov	r6,r3
800085da:	02 92       	mov	r2,r1
800085dc:	40 93       	lddsp	r3,sp[0x24]
800085de:	10 90       	mov	r0,r8
800085e0:	40 41       	lddsp	r1,sp[0x10]
800085e2:	ed b5 00 05 	bld	r5,0x5
800085e6:	c5 d1       	brne	800086a0 <_vfprintf_r+0xde4>
800085e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085ec:	40 3c       	lddsp	r12,sp[0xc]
800085ee:	58 0c       	cp.w	r12,0
800085f0:	c2 60       	breq	8000863c <_vfprintf_r+0xd80>
800085f2:	10 36       	cp.w	r6,r8
800085f4:	c0 a4       	brge	80008608 <_vfprintf_r+0xd4c>
800085f6:	fa cb f9 44 	sub	r11,sp,-1724
800085fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085fe:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008602:	fa e9 00 00 	st.d	sp[0],r8
80008606:	c1 88       	rjmp	80008636 <_vfprintf_r+0xd7a>
80008608:	fa c8 f9 50 	sub	r8,sp,-1712
8000860c:	1a d8       	st.w	--sp,r8
8000860e:	fa c8 fa b8 	sub	r8,sp,-1352
80008612:	04 9a       	mov	r10,r2
80008614:	1a d8       	st.w	--sp,r8
80008616:	0c 9b       	mov	r11,r6
80008618:	fa c8 fb b4 	sub	r8,sp,-1100
8000861c:	08 9c       	mov	r12,r4
8000861e:	1a d8       	st.w	--sp,r8
80008620:	fa c8 f9 40 	sub	r8,sp,-1728
80008624:	fa c9 ff b4 	sub	r9,sp,-76
80008628:	fe b0 f7 b2 	rcall	8000758c <get_arg>
8000862c:	2f dd       	sub	sp,-12
8000862e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008632:	fa eb 00 00 	st.d	sp[0],r10
80008636:	30 08       	mov	r8,0
80008638:	e0 8f 03 de 	bral	80008df4 <_vfprintf_r+0x1538>
8000863c:	ee ca ff ff 	sub	r10,r7,-1
80008640:	10 37       	cp.w	r7,r8
80008642:	c0 b4       	brge	80008658 <_vfprintf_r+0xd9c>
80008644:	fa c9 f9 44 	sub	r9,sp,-1724
80008648:	14 97       	mov	r7,r10
8000864a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000864e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008652:	fa eb 00 00 	st.d	sp[0],r10
80008656:	c1 88       	rjmp	80008686 <_vfprintf_r+0xdca>
80008658:	41 09       	lddsp	r9,sp[0x40]
8000865a:	59 f8       	cp.w	r8,31
8000865c:	e0 89 00 18 	brgt	8000868c <_vfprintf_r+0xdd0>
80008660:	f2 e6 00 00 	ld.d	r6,r9[0]
80008664:	f2 cb ff f8 	sub	r11,r9,-8
80008668:	fa e7 00 00 	st.d	sp[0],r6
8000866c:	51 0b       	stdsp	sp[0x40],r11
8000866e:	fa c6 f9 44 	sub	r6,sp,-1724
80008672:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008676:	fa e6 00 00 	ld.d	r6,sp[0]
8000867a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000867e:	2f f8       	sub	r8,-1
80008680:	14 97       	mov	r7,r10
80008682:	fb 48 06 b4 	st.w	sp[1716],r8
80008686:	40 38       	lddsp	r8,sp[0xc]
80008688:	e0 8f 03 b6 	bral	80008df4 <_vfprintf_r+0x1538>
8000868c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008690:	40 38       	lddsp	r8,sp[0xc]
80008692:	fa e7 00 00 	st.d	sp[0],r6
80008696:	2f 89       	sub	r9,-8
80008698:	14 97       	mov	r7,r10
8000869a:	51 09       	stdsp	sp[0x40],r9
8000869c:	e0 8f 03 ac 	bral	80008df4 <_vfprintf_r+0x1538>
800086a0:	ed b5 00 04 	bld	r5,0x4
800086a4:	c1 61       	brne	800086d0 <_vfprintf_r+0xe14>
800086a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086aa:	40 3e       	lddsp	lr,sp[0xc]
800086ac:	58 0e       	cp.w	lr,0
800086ae:	c0 80       	breq	800086be <_vfprintf_r+0xe02>
800086b0:	10 36       	cp.w	r6,r8
800086b2:	c6 74       	brge	80008780 <_vfprintf_r+0xec4>
800086b4:	fa cc f9 44 	sub	r12,sp,-1724
800086b8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086bc:	c8 08       	rjmp	800087bc <_vfprintf_r+0xf00>
800086be:	ee ca ff ff 	sub	r10,r7,-1
800086c2:	10 37       	cp.w	r7,r8
800086c4:	c7 f4       	brge	800087c2 <_vfprintf_r+0xf06>
800086c6:	fa cb f9 44 	sub	r11,sp,-1724
800086ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086ce:	c7 68       	rjmp	800087ba <_vfprintf_r+0xefe>
800086d0:	ed b5 00 06 	bld	r5,0x6
800086d4:	c4 a1       	brne	80008768 <_vfprintf_r+0xeac>
800086d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086da:	40 3c       	lddsp	r12,sp[0xc]
800086dc:	58 0c       	cp.w	r12,0
800086de:	c1 d0       	breq	80008718 <_vfprintf_r+0xe5c>
800086e0:	10 36       	cp.w	r6,r8
800086e2:	c0 64       	brge	800086ee <_vfprintf_r+0xe32>
800086e4:	fa cb f9 44 	sub	r11,sp,-1724
800086e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086ec:	c1 f8       	rjmp	8000872a <_vfprintf_r+0xe6e>
800086ee:	fa c8 f9 50 	sub	r8,sp,-1712
800086f2:	1a d8       	st.w	--sp,r8
800086f4:	fa c8 fa b8 	sub	r8,sp,-1352
800086f8:	1a d8       	st.w	--sp,r8
800086fa:	fa c8 fb b4 	sub	r8,sp,-1100
800086fe:	1a d8       	st.w	--sp,r8
80008700:	fa c8 f9 40 	sub	r8,sp,-1728
80008704:	fa c9 ff b4 	sub	r9,sp,-76
80008708:	04 9a       	mov	r10,r2
8000870a:	0c 9b       	mov	r11,r6
8000870c:	08 9c       	mov	r12,r4
8000870e:	fe b0 f7 3f 	rcall	8000758c <get_arg>
80008712:	2f dd       	sub	sp,-12
80008714:	98 18       	ld.sh	r8,r12[0x2]
80008716:	c2 68       	rjmp	80008762 <_vfprintf_r+0xea6>
80008718:	ee ca ff ff 	sub	r10,r7,-1
8000871c:	10 37       	cp.w	r7,r8
8000871e:	c0 94       	brge	80008730 <_vfprintf_r+0xe74>
80008720:	fa c9 f9 44 	sub	r9,sp,-1724
80008724:	14 97       	mov	r7,r10
80008726:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000872a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000872e:	c1 a8       	rjmp	80008762 <_vfprintf_r+0xea6>
80008730:	41 09       	lddsp	r9,sp[0x40]
80008732:	59 f8       	cp.w	r8,31
80008734:	e0 89 00 13 	brgt	8000875a <_vfprintf_r+0xe9e>
80008738:	f2 cb ff fc 	sub	r11,r9,-4
8000873c:	51 0b       	stdsp	sp[0x40],r11
8000873e:	72 09       	ld.w	r9,r9[0x0]
80008740:	fa c6 f9 44 	sub	r6,sp,-1724
80008744:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008748:	2f f8       	sub	r8,-1
8000874a:	f7 49 fd 88 	st.w	r11[-632],r9
8000874e:	fb 48 06 b4 	st.w	sp[1716],r8
80008752:	14 97       	mov	r7,r10
80008754:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008758:	c0 58       	rjmp	80008762 <_vfprintf_r+0xea6>
8000875a:	92 18       	ld.sh	r8,r9[0x2]
8000875c:	14 97       	mov	r7,r10
8000875e:	2f c9       	sub	r9,-4
80008760:	51 09       	stdsp	sp[0x40],r9
80008762:	5c 78       	castu.h	r8
80008764:	50 18       	stdsp	sp[0x4],r8
80008766:	c4 68       	rjmp	800087f2 <_vfprintf_r+0xf36>
80008768:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000876c:	40 3c       	lddsp	r12,sp[0xc]
8000876e:	58 0c       	cp.w	r12,0
80008770:	c1 d0       	breq	800087aa <_vfprintf_r+0xeee>
80008772:	10 36       	cp.w	r6,r8
80008774:	c0 64       	brge	80008780 <_vfprintf_r+0xec4>
80008776:	fa cb f9 44 	sub	r11,sp,-1724
8000877a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000877e:	c1 f8       	rjmp	800087bc <_vfprintf_r+0xf00>
80008780:	fa c8 f9 50 	sub	r8,sp,-1712
80008784:	1a d8       	st.w	--sp,r8
80008786:	fa c8 fa b8 	sub	r8,sp,-1352
8000878a:	0c 9b       	mov	r11,r6
8000878c:	1a d8       	st.w	--sp,r8
8000878e:	fa c8 fb b4 	sub	r8,sp,-1100
80008792:	04 9a       	mov	r10,r2
80008794:	1a d8       	st.w	--sp,r8
80008796:	08 9c       	mov	r12,r4
80008798:	fa c8 f9 40 	sub	r8,sp,-1728
8000879c:	fa c9 ff b4 	sub	r9,sp,-76
800087a0:	fe b0 f6 f6 	rcall	8000758c <get_arg>
800087a4:	2f dd       	sub	sp,-12
800087a6:	78 0b       	ld.w	r11,r12[0x0]
800087a8:	c2 48       	rjmp	800087f0 <_vfprintf_r+0xf34>
800087aa:	ee ca ff ff 	sub	r10,r7,-1
800087ae:	10 37       	cp.w	r7,r8
800087b0:	c0 94       	brge	800087c2 <_vfprintf_r+0xf06>
800087b2:	fa c9 f9 44 	sub	r9,sp,-1724
800087b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087ba:	14 97       	mov	r7,r10
800087bc:	ec fb fd 88 	ld.w	r11,r6[-632]
800087c0:	c1 88       	rjmp	800087f0 <_vfprintf_r+0xf34>
800087c2:	41 09       	lddsp	r9,sp[0x40]
800087c4:	59 f8       	cp.w	r8,31
800087c6:	e0 89 00 11 	brgt	800087e8 <_vfprintf_r+0xf2c>
800087ca:	f2 cb ff fc 	sub	r11,r9,-4
800087ce:	51 0b       	stdsp	sp[0x40],r11
800087d0:	fa c6 f9 44 	sub	r6,sp,-1724
800087d4:	72 0b       	ld.w	r11,r9[0x0]
800087d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087da:	f3 4b fd 88 	st.w	r9[-632],r11
800087de:	2f f8       	sub	r8,-1
800087e0:	14 97       	mov	r7,r10
800087e2:	fb 48 06 b4 	st.w	sp[1716],r8
800087e6:	c0 58       	rjmp	800087f0 <_vfprintf_r+0xf34>
800087e8:	72 0b       	ld.w	r11,r9[0x0]
800087ea:	14 97       	mov	r7,r10
800087ec:	2f c9       	sub	r9,-4
800087ee:	51 09       	stdsp	sp[0x40],r9
800087f0:	50 1b       	stdsp	sp[0x4],r11
800087f2:	30 0e       	mov	lr,0
800087f4:	50 0e       	stdsp	sp[0x0],lr
800087f6:	1c 98       	mov	r8,lr
800087f8:	e0 8f 02 fe 	bral	80008df4 <_vfprintf_r+0x1538>
800087fc:	50 a7       	stdsp	sp[0x28],r7
800087fe:	50 80       	stdsp	sp[0x20],r0
80008800:	0c 97       	mov	r7,r6
80008802:	04 94       	mov	r4,r2
80008804:	06 96       	mov	r6,r3
80008806:	02 92       	mov	r2,r1
80008808:	40 93       	lddsp	r3,sp[0x24]
8000880a:	40 41       	lddsp	r1,sp[0x10]
8000880c:	0e 99       	mov	r9,r7
8000880e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008812:	40 3c       	lddsp	r12,sp[0xc]
80008814:	58 0c       	cp.w	r12,0
80008816:	c1 d0       	breq	80008850 <_vfprintf_r+0xf94>
80008818:	10 36       	cp.w	r6,r8
8000881a:	c0 64       	brge	80008826 <_vfprintf_r+0xf6a>
8000881c:	fa cb f9 44 	sub	r11,sp,-1724
80008820:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008824:	c1 d8       	rjmp	8000885e <_vfprintf_r+0xfa2>
80008826:	fa c8 f9 50 	sub	r8,sp,-1712
8000882a:	1a d8       	st.w	--sp,r8
8000882c:	fa c8 fa b8 	sub	r8,sp,-1352
80008830:	1a d8       	st.w	--sp,r8
80008832:	fa c8 fb b4 	sub	r8,sp,-1100
80008836:	1a d8       	st.w	--sp,r8
80008838:	fa c9 ff b4 	sub	r9,sp,-76
8000883c:	fa c8 f9 40 	sub	r8,sp,-1728
80008840:	04 9a       	mov	r10,r2
80008842:	0c 9b       	mov	r11,r6
80008844:	08 9c       	mov	r12,r4
80008846:	fe b0 f6 a3 	rcall	8000758c <get_arg>
8000884a:	2f dd       	sub	sp,-12
8000884c:	78 09       	ld.w	r9,r12[0x0]
8000884e:	c2 18       	rjmp	80008890 <_vfprintf_r+0xfd4>
80008850:	2f f7       	sub	r7,-1
80008852:	10 39       	cp.w	r9,r8
80008854:	c0 84       	brge	80008864 <_vfprintf_r+0xfa8>
80008856:	fa ca f9 44 	sub	r10,sp,-1724
8000885a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000885e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008862:	c1 78       	rjmp	80008890 <_vfprintf_r+0xfd4>
80008864:	41 09       	lddsp	r9,sp[0x40]
80008866:	59 f8       	cp.w	r8,31
80008868:	e0 89 00 10 	brgt	80008888 <_vfprintf_r+0xfcc>
8000886c:	f2 ca ff fc 	sub	r10,r9,-4
80008870:	51 0a       	stdsp	sp[0x40],r10
80008872:	fa c6 f9 44 	sub	r6,sp,-1724
80008876:	72 09       	ld.w	r9,r9[0x0]
80008878:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000887c:	f5 49 fd 88 	st.w	r10[-632],r9
80008880:	2f f8       	sub	r8,-1
80008882:	fb 48 06 b4 	st.w	sp[1716],r8
80008886:	c0 58       	rjmp	80008890 <_vfprintf_r+0xfd4>
80008888:	f2 c8 ff fc 	sub	r8,r9,-4
8000888c:	51 08       	stdsp	sp[0x40],r8
8000888e:	72 09       	ld.w	r9,r9[0x0]
80008890:	33 08       	mov	r8,48
80008892:	fb 68 06 b8 	st.b	sp[1720],r8
80008896:	37 88       	mov	r8,120
80008898:	30 0e       	mov	lr,0
8000889a:	fb 68 06 b9 	st.b	sp[1721],r8
8000889e:	fe cc b1 7e 	sub	r12,pc,-20098
800088a2:	50 19       	stdsp	sp[0x4],r9
800088a4:	a1 b5       	sbr	r5,0x1
800088a6:	50 0e       	stdsp	sp[0x0],lr
800088a8:	50 dc       	stdsp	sp[0x34],r12
800088aa:	30 28       	mov	r8,2
800088ac:	37 80       	mov	r0,120
800088ae:	e0 8f 02 a3 	bral	80008df4 <_vfprintf_r+0x1538>
800088b2:	50 a7       	stdsp	sp[0x28],r7
800088b4:	50 80       	stdsp	sp[0x20],r0
800088b6:	10 90       	mov	r0,r8
800088b8:	30 08       	mov	r8,0
800088ba:	fb 68 06 bb 	st.b	sp[1723],r8
800088be:	0c 97       	mov	r7,r6
800088c0:	04 94       	mov	r4,r2
800088c2:	06 96       	mov	r6,r3
800088c4:	02 92       	mov	r2,r1
800088c6:	40 93       	lddsp	r3,sp[0x24]
800088c8:	40 41       	lddsp	r1,sp[0x10]
800088ca:	0e 99       	mov	r9,r7
800088cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088d0:	40 3b       	lddsp	r11,sp[0xc]
800088d2:	58 0b       	cp.w	r11,0
800088d4:	c1 d0       	breq	8000890e <_vfprintf_r+0x1052>
800088d6:	10 36       	cp.w	r6,r8
800088d8:	c0 64       	brge	800088e4 <_vfprintf_r+0x1028>
800088da:	fa ca f9 44 	sub	r10,sp,-1724
800088de:	f4 06 00 36 	add	r6,r10,r6<<0x3
800088e2:	c1 d8       	rjmp	8000891c <_vfprintf_r+0x1060>
800088e4:	fa c8 f9 50 	sub	r8,sp,-1712
800088e8:	1a d8       	st.w	--sp,r8
800088ea:	fa c8 fa b8 	sub	r8,sp,-1352
800088ee:	1a d8       	st.w	--sp,r8
800088f0:	fa c8 fb b4 	sub	r8,sp,-1100
800088f4:	0c 9b       	mov	r11,r6
800088f6:	1a d8       	st.w	--sp,r8
800088f8:	04 9a       	mov	r10,r2
800088fa:	fa c8 f9 40 	sub	r8,sp,-1728
800088fe:	fa c9 ff b4 	sub	r9,sp,-76
80008902:	08 9c       	mov	r12,r4
80008904:	fe b0 f6 44 	rcall	8000758c <get_arg>
80008908:	2f dd       	sub	sp,-12
8000890a:	78 06       	ld.w	r6,r12[0x0]
8000890c:	c2 08       	rjmp	8000894c <_vfprintf_r+0x1090>
8000890e:	2f f7       	sub	r7,-1
80008910:	10 39       	cp.w	r9,r8
80008912:	c0 84       	brge	80008922 <_vfprintf_r+0x1066>
80008914:	fa c9 f9 44 	sub	r9,sp,-1724
80008918:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000891c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008920:	c1 68       	rjmp	8000894c <_vfprintf_r+0x1090>
80008922:	41 09       	lddsp	r9,sp[0x40]
80008924:	59 f8       	cp.w	r8,31
80008926:	e0 89 00 10 	brgt	80008946 <_vfprintf_r+0x108a>
8000892a:	f2 ca ff fc 	sub	r10,r9,-4
8000892e:	51 0a       	stdsp	sp[0x40],r10
80008930:	72 06       	ld.w	r6,r9[0x0]
80008932:	fa ce f9 44 	sub	lr,sp,-1724
80008936:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000893a:	f3 46 fd 88 	st.w	r9[-632],r6
8000893e:	2f f8       	sub	r8,-1
80008940:	fb 48 06 b4 	st.w	sp[1716],r8
80008944:	c0 48       	rjmp	8000894c <_vfprintf_r+0x1090>
80008946:	72 06       	ld.w	r6,r9[0x0]
80008948:	2f c9       	sub	r9,-4
8000894a:	51 09       	stdsp	sp[0x40],r9
8000894c:	40 2c       	lddsp	r12,sp[0x8]
8000894e:	58 0c       	cp.w	r12,0
80008950:	c1 05       	brlt	80008970 <_vfprintf_r+0x10b4>
80008952:	18 9a       	mov	r10,r12
80008954:	30 0b       	mov	r11,0
80008956:	0c 9c       	mov	r12,r6
80008958:	e0 a0 12 38 	rcall	8000adc8 <memchr>
8000895c:	e0 80 02 df 	breq	80008f1a <_vfprintf_r+0x165e>
80008960:	f8 06 01 02 	sub	r2,r12,r6
80008964:	40 2b       	lddsp	r11,sp[0x8]
80008966:	16 32       	cp.w	r2,r11
80008968:	e0 89 02 d9 	brgt	80008f1a <_vfprintf_r+0x165e>
8000896c:	e0 8f 02 d4 	bral	80008f14 <_vfprintf_r+0x1658>
80008970:	30 0a       	mov	r10,0
80008972:	0c 9c       	mov	r12,r6
80008974:	50 2a       	stdsp	sp[0x8],r10
80008976:	fe b0 f5 85 	rcall	80007480 <strlen>
8000897a:	18 92       	mov	r2,r12
8000897c:	e0 8f 02 d2 	bral	80008f20 <_vfprintf_r+0x1664>
80008980:	50 a7       	stdsp	sp[0x28],r7
80008982:	50 80       	stdsp	sp[0x20],r0
80008984:	0c 97       	mov	r7,r6
80008986:	04 94       	mov	r4,r2
80008988:	06 96       	mov	r6,r3
8000898a:	02 92       	mov	r2,r1
8000898c:	40 93       	lddsp	r3,sp[0x24]
8000898e:	10 90       	mov	r0,r8
80008990:	40 41       	lddsp	r1,sp[0x10]
80008992:	a5 a5       	sbr	r5,0x4
80008994:	c0 a8       	rjmp	800089a8 <_vfprintf_r+0x10ec>
80008996:	50 a7       	stdsp	sp[0x28],r7
80008998:	50 80       	stdsp	sp[0x20],r0
8000899a:	0c 97       	mov	r7,r6
8000899c:	04 94       	mov	r4,r2
8000899e:	06 96       	mov	r6,r3
800089a0:	02 92       	mov	r2,r1
800089a2:	40 93       	lddsp	r3,sp[0x24]
800089a4:	10 90       	mov	r0,r8
800089a6:	40 41       	lddsp	r1,sp[0x10]
800089a8:	ed b5 00 05 	bld	r5,0x5
800089ac:	c5 61       	brne	80008a58 <_vfprintf_r+0x119c>
800089ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089b2:	40 39       	lddsp	r9,sp[0xc]
800089b4:	58 09       	cp.w	r9,0
800089b6:	c2 10       	breq	800089f8 <_vfprintf_r+0x113c>
800089b8:	10 36       	cp.w	r6,r8
800089ba:	c0 74       	brge	800089c8 <_vfprintf_r+0x110c>
800089bc:	fa c8 f9 44 	sub	r8,sp,-1724
800089c0:	f0 06 00 36 	add	r6,r8,r6<<0x3
800089c4:	c2 38       	rjmp	80008a0a <_vfprintf_r+0x114e>
800089c6:	d7 03       	nop
800089c8:	fa c8 f9 50 	sub	r8,sp,-1712
800089cc:	1a d8       	st.w	--sp,r8
800089ce:	fa c8 fa b8 	sub	r8,sp,-1352
800089d2:	1a d8       	st.w	--sp,r8
800089d4:	fa c8 fb b4 	sub	r8,sp,-1100
800089d8:	1a d8       	st.w	--sp,r8
800089da:	fa c8 f9 40 	sub	r8,sp,-1728
800089de:	fa c9 ff b4 	sub	r9,sp,-76
800089e2:	04 9a       	mov	r10,r2
800089e4:	0c 9b       	mov	r11,r6
800089e6:	08 9c       	mov	r12,r4
800089e8:	fe b0 f5 d2 	rcall	8000758c <get_arg>
800089ec:	2f dd       	sub	sp,-12
800089ee:	f8 e8 00 00 	ld.d	r8,r12[0]
800089f2:	fa e9 00 00 	st.d	sp[0],r8
800089f6:	c2 e8       	rjmp	80008a52 <_vfprintf_r+0x1196>
800089f8:	ee ca ff ff 	sub	r10,r7,-1
800089fc:	10 37       	cp.w	r7,r8
800089fe:	c0 b4       	brge	80008a14 <_vfprintf_r+0x1158>
80008a00:	fa c8 f9 44 	sub	r8,sp,-1724
80008a04:	14 97       	mov	r7,r10
80008a06:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008a0a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008a0e:	fa eb 00 00 	st.d	sp[0],r10
80008a12:	c2 08       	rjmp	80008a52 <_vfprintf_r+0x1196>
80008a14:	41 09       	lddsp	r9,sp[0x40]
80008a16:	59 f8       	cp.w	r8,31
80008a18:	e0 89 00 16 	brgt	80008a44 <_vfprintf_r+0x1188>
80008a1c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a20:	f2 cb ff f8 	sub	r11,r9,-8
80008a24:	fa e7 00 00 	st.d	sp[0],r6
80008a28:	51 0b       	stdsp	sp[0x40],r11
80008a2a:	fa c6 f9 44 	sub	r6,sp,-1724
80008a2e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a32:	fa e6 00 00 	ld.d	r6,sp[0]
80008a36:	f2 e7 fd 88 	st.d	r9[-632],r6
80008a3a:	2f f8       	sub	r8,-1
80008a3c:	14 97       	mov	r7,r10
80008a3e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a42:	c0 88       	rjmp	80008a52 <_vfprintf_r+0x1196>
80008a44:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a48:	2f 89       	sub	r9,-8
80008a4a:	fa e7 00 00 	st.d	sp[0],r6
80008a4e:	51 09       	stdsp	sp[0x40],r9
80008a50:	14 97       	mov	r7,r10
80008a52:	30 18       	mov	r8,1
80008a54:	e0 8f 01 d0 	bral	80008df4 <_vfprintf_r+0x1538>
80008a58:	ed b5 00 04 	bld	r5,0x4
80008a5c:	c1 61       	brne	80008a88 <_vfprintf_r+0x11cc>
80008a5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a62:	40 3e       	lddsp	lr,sp[0xc]
80008a64:	58 0e       	cp.w	lr,0
80008a66:	c0 80       	breq	80008a76 <_vfprintf_r+0x11ba>
80008a68:	10 36       	cp.w	r6,r8
80008a6a:	c6 74       	brge	80008b38 <_vfprintf_r+0x127c>
80008a6c:	fa cc f9 44 	sub	r12,sp,-1724
80008a70:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a74:	c8 08       	rjmp	80008b74 <_vfprintf_r+0x12b8>
80008a76:	ee ca ff ff 	sub	r10,r7,-1
80008a7a:	10 37       	cp.w	r7,r8
80008a7c:	c7 f4       	brge	80008b7a <_vfprintf_r+0x12be>
80008a7e:	fa cb f9 44 	sub	r11,sp,-1724
80008a82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a86:	c7 68       	rjmp	80008b72 <_vfprintf_r+0x12b6>
80008a88:	ed b5 00 06 	bld	r5,0x6
80008a8c:	c4 a1       	brne	80008b20 <_vfprintf_r+0x1264>
80008a8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a92:	40 3c       	lddsp	r12,sp[0xc]
80008a94:	58 0c       	cp.w	r12,0
80008a96:	c1 d0       	breq	80008ad0 <_vfprintf_r+0x1214>
80008a98:	10 36       	cp.w	r6,r8
80008a9a:	c0 64       	brge	80008aa6 <_vfprintf_r+0x11ea>
80008a9c:	fa cb f9 44 	sub	r11,sp,-1724
80008aa0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aa4:	c1 f8       	rjmp	80008ae2 <_vfprintf_r+0x1226>
80008aa6:	fa c8 f9 50 	sub	r8,sp,-1712
80008aaa:	1a d8       	st.w	--sp,r8
80008aac:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab0:	1a d8       	st.w	--sp,r8
80008ab2:	fa c8 fb b4 	sub	r8,sp,-1100
80008ab6:	1a d8       	st.w	--sp,r8
80008ab8:	fa c8 f9 40 	sub	r8,sp,-1728
80008abc:	fa c9 ff b4 	sub	r9,sp,-76
80008ac0:	04 9a       	mov	r10,r2
80008ac2:	0c 9b       	mov	r11,r6
80008ac4:	08 9c       	mov	r12,r4
80008ac6:	fe b0 f5 63 	rcall	8000758c <get_arg>
80008aca:	2f dd       	sub	sp,-12
80008acc:	98 18       	ld.sh	r8,r12[0x2]
80008ace:	c2 68       	rjmp	80008b1a <_vfprintf_r+0x125e>
80008ad0:	ee ca ff ff 	sub	r10,r7,-1
80008ad4:	10 37       	cp.w	r7,r8
80008ad6:	c0 94       	brge	80008ae8 <_vfprintf_r+0x122c>
80008ad8:	fa c9 f9 44 	sub	r9,sp,-1724
80008adc:	14 97       	mov	r7,r10
80008ade:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ae2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008ae6:	c1 a8       	rjmp	80008b1a <_vfprintf_r+0x125e>
80008ae8:	41 09       	lddsp	r9,sp[0x40]
80008aea:	59 f8       	cp.w	r8,31
80008aec:	e0 89 00 13 	brgt	80008b12 <_vfprintf_r+0x1256>
80008af0:	f2 cb ff fc 	sub	r11,r9,-4
80008af4:	51 0b       	stdsp	sp[0x40],r11
80008af6:	72 09       	ld.w	r9,r9[0x0]
80008af8:	fa c6 f9 44 	sub	r6,sp,-1724
80008afc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008b00:	2f f8       	sub	r8,-1
80008b02:	f7 49 fd 88 	st.w	r11[-632],r9
80008b06:	fb 48 06 b4 	st.w	sp[1716],r8
80008b0a:	14 97       	mov	r7,r10
80008b0c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b10:	c0 58       	rjmp	80008b1a <_vfprintf_r+0x125e>
80008b12:	92 18       	ld.sh	r8,r9[0x2]
80008b14:	14 97       	mov	r7,r10
80008b16:	2f c9       	sub	r9,-4
80008b18:	51 09       	stdsp	sp[0x40],r9
80008b1a:	5c 78       	castu.h	r8
80008b1c:	50 18       	stdsp	sp[0x4],r8
80008b1e:	c4 68       	rjmp	80008baa <_vfprintf_r+0x12ee>
80008b20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b24:	40 3c       	lddsp	r12,sp[0xc]
80008b26:	58 0c       	cp.w	r12,0
80008b28:	c1 d0       	breq	80008b62 <_vfprintf_r+0x12a6>
80008b2a:	10 36       	cp.w	r6,r8
80008b2c:	c0 64       	brge	80008b38 <_vfprintf_r+0x127c>
80008b2e:	fa cb f9 44 	sub	r11,sp,-1724
80008b32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b36:	c1 f8       	rjmp	80008b74 <_vfprintf_r+0x12b8>
80008b38:	fa c8 f9 50 	sub	r8,sp,-1712
80008b3c:	1a d8       	st.w	--sp,r8
80008b3e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b42:	0c 9b       	mov	r11,r6
80008b44:	1a d8       	st.w	--sp,r8
80008b46:	fa c8 fb b4 	sub	r8,sp,-1100
80008b4a:	04 9a       	mov	r10,r2
80008b4c:	1a d8       	st.w	--sp,r8
80008b4e:	08 9c       	mov	r12,r4
80008b50:	fa c8 f9 40 	sub	r8,sp,-1728
80008b54:	fa c9 ff b4 	sub	r9,sp,-76
80008b58:	fe b0 f5 1a 	rcall	8000758c <get_arg>
80008b5c:	2f dd       	sub	sp,-12
80008b5e:	78 0b       	ld.w	r11,r12[0x0]
80008b60:	c2 48       	rjmp	80008ba8 <_vfprintf_r+0x12ec>
80008b62:	ee ca ff ff 	sub	r10,r7,-1
80008b66:	10 37       	cp.w	r7,r8
80008b68:	c0 94       	brge	80008b7a <_vfprintf_r+0x12be>
80008b6a:	fa c9 f9 44 	sub	r9,sp,-1724
80008b6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b72:	14 97       	mov	r7,r10
80008b74:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b78:	c1 88       	rjmp	80008ba8 <_vfprintf_r+0x12ec>
80008b7a:	41 09       	lddsp	r9,sp[0x40]
80008b7c:	59 f8       	cp.w	r8,31
80008b7e:	e0 89 00 11 	brgt	80008ba0 <_vfprintf_r+0x12e4>
80008b82:	f2 cb ff fc 	sub	r11,r9,-4
80008b86:	51 0b       	stdsp	sp[0x40],r11
80008b88:	fa c6 f9 44 	sub	r6,sp,-1724
80008b8c:	72 0b       	ld.w	r11,r9[0x0]
80008b8e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b92:	f3 4b fd 88 	st.w	r9[-632],r11
80008b96:	2f f8       	sub	r8,-1
80008b98:	14 97       	mov	r7,r10
80008b9a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b9e:	c0 58       	rjmp	80008ba8 <_vfprintf_r+0x12ec>
80008ba0:	72 0b       	ld.w	r11,r9[0x0]
80008ba2:	14 97       	mov	r7,r10
80008ba4:	2f c9       	sub	r9,-4
80008ba6:	51 09       	stdsp	sp[0x40],r9
80008ba8:	50 1b       	stdsp	sp[0x4],r11
80008baa:	30 0e       	mov	lr,0
80008bac:	30 18       	mov	r8,1
80008bae:	50 0e       	stdsp	sp[0x0],lr
80008bb0:	c2 29       	rjmp	80008df4 <_vfprintf_r+0x1538>
80008bb2:	50 a7       	stdsp	sp[0x28],r7
80008bb4:	50 80       	stdsp	sp[0x20],r0
80008bb6:	0c 97       	mov	r7,r6
80008bb8:	04 94       	mov	r4,r2
80008bba:	06 96       	mov	r6,r3
80008bbc:	02 92       	mov	r2,r1
80008bbe:	fe cc b4 9e 	sub	r12,pc,-19298
80008bc2:	40 93       	lddsp	r3,sp[0x24]
80008bc4:	10 90       	mov	r0,r8
80008bc6:	40 41       	lddsp	r1,sp[0x10]
80008bc8:	50 dc       	stdsp	sp[0x34],r12
80008bca:	ed b5 00 05 	bld	r5,0x5
80008bce:	c5 51       	brne	80008c78 <_vfprintf_r+0x13bc>
80008bd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bd4:	40 3b       	lddsp	r11,sp[0xc]
80008bd6:	58 0b       	cp.w	r11,0
80008bd8:	c2 20       	breq	80008c1c <_vfprintf_r+0x1360>
80008bda:	10 36       	cp.w	r6,r8
80008bdc:	c0 a4       	brge	80008bf0 <_vfprintf_r+0x1334>
80008bde:	fa ca f9 44 	sub	r10,sp,-1724
80008be2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008be6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008bea:	fa e9 00 00 	st.d	sp[0],r8
80008bee:	cf 28       	rjmp	80008dd2 <_vfprintf_r+0x1516>
80008bf0:	fa c8 f9 50 	sub	r8,sp,-1712
80008bf4:	1a d8       	st.w	--sp,r8
80008bf6:	fa c8 fa b8 	sub	r8,sp,-1352
80008bfa:	04 9a       	mov	r10,r2
80008bfc:	1a d8       	st.w	--sp,r8
80008bfe:	0c 9b       	mov	r11,r6
80008c00:	fa c8 fb b4 	sub	r8,sp,-1100
80008c04:	08 9c       	mov	r12,r4
80008c06:	1a d8       	st.w	--sp,r8
80008c08:	fa c8 f9 40 	sub	r8,sp,-1728
80008c0c:	fa c9 ff b4 	sub	r9,sp,-76
80008c10:	fe b0 f4 be 	rcall	8000758c <get_arg>
80008c14:	2f dd       	sub	sp,-12
80008c16:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c1a:	c0 c8       	rjmp	80008c32 <_vfprintf_r+0x1376>
80008c1c:	ee ca ff ff 	sub	r10,r7,-1
80008c20:	10 37       	cp.w	r7,r8
80008c22:	c0 b4       	brge	80008c38 <_vfprintf_r+0x137c>
80008c24:	fa c9 f9 44 	sub	r9,sp,-1724
80008c28:	14 97       	mov	r7,r10
80008c2a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c2e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c32:	fa eb 00 00 	st.d	sp[0],r10
80008c36:	cc e8       	rjmp	80008dd2 <_vfprintf_r+0x1516>
80008c38:	41 09       	lddsp	r9,sp[0x40]
80008c3a:	59 f8       	cp.w	r8,31
80008c3c:	e0 89 00 16 	brgt	80008c68 <_vfprintf_r+0x13ac>
80008c40:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c44:	f2 cb ff f8 	sub	r11,r9,-8
80008c48:	fa e7 00 00 	st.d	sp[0],r6
80008c4c:	51 0b       	stdsp	sp[0x40],r11
80008c4e:	fa c6 f9 44 	sub	r6,sp,-1724
80008c52:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c56:	fa e6 00 00 	ld.d	r6,sp[0]
80008c5a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c5e:	2f f8       	sub	r8,-1
80008c60:	14 97       	mov	r7,r10
80008c62:	fb 48 06 b4 	st.w	sp[1716],r8
80008c66:	cb 68       	rjmp	80008dd2 <_vfprintf_r+0x1516>
80008c68:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c6c:	2f 89       	sub	r9,-8
80008c6e:	fa e7 00 00 	st.d	sp[0],r6
80008c72:	51 09       	stdsp	sp[0x40],r9
80008c74:	14 97       	mov	r7,r10
80008c76:	ca e8       	rjmp	80008dd2 <_vfprintf_r+0x1516>
80008c78:	ed b5 00 04 	bld	r5,0x4
80008c7c:	c1 71       	brne	80008caa <_vfprintf_r+0x13ee>
80008c7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c82:	40 3e       	lddsp	lr,sp[0xc]
80008c84:	58 0e       	cp.w	lr,0
80008c86:	c0 80       	breq	80008c96 <_vfprintf_r+0x13da>
80008c88:	10 36       	cp.w	r6,r8
80008c8a:	c6 94       	brge	80008d5c <_vfprintf_r+0x14a0>
80008c8c:	fa cc f9 44 	sub	r12,sp,-1724
80008c90:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c94:	c8 28       	rjmp	80008d98 <_vfprintf_r+0x14dc>
80008c96:	ee ca ff ff 	sub	r10,r7,-1
80008c9a:	10 37       	cp.w	r7,r8
80008c9c:	e0 84 00 81 	brge	80008d9e <_vfprintf_r+0x14e2>
80008ca0:	fa cb f9 44 	sub	r11,sp,-1724
80008ca4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ca8:	c7 78       	rjmp	80008d96 <_vfprintf_r+0x14da>
80008caa:	ed b5 00 06 	bld	r5,0x6
80008cae:	c4 b1       	brne	80008d44 <_vfprintf_r+0x1488>
80008cb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cb4:	40 3c       	lddsp	r12,sp[0xc]
80008cb6:	58 0c       	cp.w	r12,0
80008cb8:	c1 d0       	breq	80008cf2 <_vfprintf_r+0x1436>
80008cba:	10 36       	cp.w	r6,r8
80008cbc:	c0 64       	brge	80008cc8 <_vfprintf_r+0x140c>
80008cbe:	fa cb f9 44 	sub	r11,sp,-1724
80008cc2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cc6:	c1 f8       	rjmp	80008d04 <_vfprintf_r+0x1448>
80008cc8:	fa c8 f9 50 	sub	r8,sp,-1712
80008ccc:	1a d8       	st.w	--sp,r8
80008cce:	fa c8 fa b8 	sub	r8,sp,-1352
80008cd2:	1a d8       	st.w	--sp,r8
80008cd4:	fa c8 fb b4 	sub	r8,sp,-1100
80008cd8:	1a d8       	st.w	--sp,r8
80008cda:	fa c8 f9 40 	sub	r8,sp,-1728
80008cde:	fa c9 ff b4 	sub	r9,sp,-76
80008ce2:	04 9a       	mov	r10,r2
80008ce4:	0c 9b       	mov	r11,r6
80008ce6:	08 9c       	mov	r12,r4
80008ce8:	fe b0 f4 52 	rcall	8000758c <get_arg>
80008cec:	2f dd       	sub	sp,-12
80008cee:	98 18       	ld.sh	r8,r12[0x2]
80008cf0:	c2 78       	rjmp	80008d3e <_vfprintf_r+0x1482>
80008cf2:	ee ca ff ff 	sub	r10,r7,-1
80008cf6:	10 37       	cp.w	r7,r8
80008cf8:	c0 a4       	brge	80008d0c <_vfprintf_r+0x1450>
80008cfa:	fa c9 f9 44 	sub	r9,sp,-1724
80008cfe:	14 97       	mov	r7,r10
80008d00:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d04:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d08:	c1 b8       	rjmp	80008d3e <_vfprintf_r+0x1482>
80008d0a:	d7 03       	nop
80008d0c:	41 09       	lddsp	r9,sp[0x40]
80008d0e:	59 f8       	cp.w	r8,31
80008d10:	e0 89 00 13 	brgt	80008d36 <_vfprintf_r+0x147a>
80008d14:	f2 cb ff fc 	sub	r11,r9,-4
80008d18:	51 0b       	stdsp	sp[0x40],r11
80008d1a:	72 09       	ld.w	r9,r9[0x0]
80008d1c:	fa c6 f9 44 	sub	r6,sp,-1724
80008d20:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d24:	2f f8       	sub	r8,-1
80008d26:	f7 49 fd 88 	st.w	r11[-632],r9
80008d2a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d2e:	14 97       	mov	r7,r10
80008d30:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d34:	c0 58       	rjmp	80008d3e <_vfprintf_r+0x1482>
80008d36:	92 18       	ld.sh	r8,r9[0x2]
80008d38:	14 97       	mov	r7,r10
80008d3a:	2f c9       	sub	r9,-4
80008d3c:	51 09       	stdsp	sp[0x40],r9
80008d3e:	5c 78       	castu.h	r8
80008d40:	50 18       	stdsp	sp[0x4],r8
80008d42:	c4 68       	rjmp	80008dce <_vfprintf_r+0x1512>
80008d44:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d48:	40 3c       	lddsp	r12,sp[0xc]
80008d4a:	58 0c       	cp.w	r12,0
80008d4c:	c1 d0       	breq	80008d86 <_vfprintf_r+0x14ca>
80008d4e:	10 36       	cp.w	r6,r8
80008d50:	c0 64       	brge	80008d5c <_vfprintf_r+0x14a0>
80008d52:	fa cb f9 44 	sub	r11,sp,-1724
80008d56:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d5a:	c1 f8       	rjmp	80008d98 <_vfprintf_r+0x14dc>
80008d5c:	fa c8 f9 50 	sub	r8,sp,-1712
80008d60:	1a d8       	st.w	--sp,r8
80008d62:	fa c8 fa b8 	sub	r8,sp,-1352
80008d66:	0c 9b       	mov	r11,r6
80008d68:	1a d8       	st.w	--sp,r8
80008d6a:	fa c8 fb b4 	sub	r8,sp,-1100
80008d6e:	04 9a       	mov	r10,r2
80008d70:	1a d8       	st.w	--sp,r8
80008d72:	08 9c       	mov	r12,r4
80008d74:	fa c8 f9 40 	sub	r8,sp,-1728
80008d78:	fa c9 ff b4 	sub	r9,sp,-76
80008d7c:	fe b0 f4 08 	rcall	8000758c <get_arg>
80008d80:	2f dd       	sub	sp,-12
80008d82:	78 0b       	ld.w	r11,r12[0x0]
80008d84:	c2 48       	rjmp	80008dcc <_vfprintf_r+0x1510>
80008d86:	ee ca ff ff 	sub	r10,r7,-1
80008d8a:	10 37       	cp.w	r7,r8
80008d8c:	c0 94       	brge	80008d9e <_vfprintf_r+0x14e2>
80008d8e:	fa c9 f9 44 	sub	r9,sp,-1724
80008d92:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d96:	14 97       	mov	r7,r10
80008d98:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d9c:	c1 88       	rjmp	80008dcc <_vfprintf_r+0x1510>
80008d9e:	41 09       	lddsp	r9,sp[0x40]
80008da0:	59 f8       	cp.w	r8,31
80008da2:	e0 89 00 11 	brgt	80008dc4 <_vfprintf_r+0x1508>
80008da6:	f2 cb ff fc 	sub	r11,r9,-4
80008daa:	51 0b       	stdsp	sp[0x40],r11
80008dac:	fa c6 f9 44 	sub	r6,sp,-1724
80008db0:	72 0b       	ld.w	r11,r9[0x0]
80008db2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008db6:	f3 4b fd 88 	st.w	r9[-632],r11
80008dba:	2f f8       	sub	r8,-1
80008dbc:	14 97       	mov	r7,r10
80008dbe:	fb 48 06 b4 	st.w	sp[1716],r8
80008dc2:	c0 58       	rjmp	80008dcc <_vfprintf_r+0x1510>
80008dc4:	72 0b       	ld.w	r11,r9[0x0]
80008dc6:	14 97       	mov	r7,r10
80008dc8:	2f c9       	sub	r9,-4
80008dca:	51 09       	stdsp	sp[0x40],r9
80008dcc:	50 1b       	stdsp	sp[0x4],r11
80008dce:	30 0e       	mov	lr,0
80008dd0:	50 0e       	stdsp	sp[0x0],lr
80008dd2:	40 08       	lddsp	r8,sp[0x0]
80008dd4:	40 1c       	lddsp	r12,sp[0x4]
80008dd6:	18 48       	or	r8,r12
80008dd8:	5f 19       	srne	r9
80008dda:	0a 98       	mov	r8,r5
80008ddc:	eb e9 00 09 	and	r9,r5,r9
80008de0:	a1 b8       	sbr	r8,0x1
80008de2:	58 09       	cp.w	r9,0
80008de4:	c0 70       	breq	80008df2 <_vfprintf_r+0x1536>
80008de6:	10 95       	mov	r5,r8
80008de8:	fb 60 06 b9 	st.b	sp[1721],r0
80008dec:	33 08       	mov	r8,48
80008dee:	fb 68 06 b8 	st.b	sp[1720],r8
80008df2:	30 28       	mov	r8,2
80008df4:	30 09       	mov	r9,0
80008df6:	fb 69 06 bb 	st.b	sp[1723],r9
80008dfa:	0a 99       	mov	r9,r5
80008dfc:	a7 d9       	cbr	r9,0x7
80008dfe:	40 2b       	lddsp	r11,sp[0x8]
80008e00:	40 16       	lddsp	r6,sp[0x4]
80008e02:	58 0b       	cp.w	r11,0
80008e04:	5f 1a       	srne	r10
80008e06:	f2 05 17 40 	movge	r5,r9
80008e0a:	fa c2 f9 78 	sub	r2,sp,-1672
80008e0e:	40 09       	lddsp	r9,sp[0x0]
80008e10:	0c 49       	or	r9,r6
80008e12:	5f 19       	srne	r9
80008e14:	f5 e9 10 09 	or	r9,r10,r9
80008e18:	c5 c0       	breq	80008ed0 <_vfprintf_r+0x1614>
80008e1a:	30 19       	mov	r9,1
80008e1c:	f2 08 18 00 	cp.b	r8,r9
80008e20:	c0 60       	breq	80008e2c <_vfprintf_r+0x1570>
80008e22:	30 29       	mov	r9,2
80008e24:	f2 08 18 00 	cp.b	r8,r9
80008e28:	c0 41       	brne	80008e30 <_vfprintf_r+0x1574>
80008e2a:	c3 c8       	rjmp	80008ea2 <_vfprintf_r+0x15e6>
80008e2c:	04 96       	mov	r6,r2
80008e2e:	c3 08       	rjmp	80008e8e <_vfprintf_r+0x15d2>
80008e30:	04 96       	mov	r6,r2
80008e32:	fa e8 00 00 	ld.d	r8,sp[0]
80008e36:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008e3a:	2d 0a       	sub	r10,-48
80008e3c:	0c fa       	st.b	--r6,r10
80008e3e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008e42:	f2 0c 16 03 	lsr	r12,r9,0x3
80008e46:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008e4a:	18 99       	mov	r9,r12
80008e4c:	16 98       	mov	r8,r11
80008e4e:	58 08       	cp.w	r8,0
80008e50:	5c 29       	cpc	r9
80008e52:	cf 21       	brne	80008e36 <_vfprintf_r+0x157a>
80008e54:	fa e9 00 00 	st.d	sp[0],r8
80008e58:	ed b5 00 00 	bld	r5,0x0
80008e5c:	c4 51       	brne	80008ee6 <_vfprintf_r+0x162a>
80008e5e:	33 09       	mov	r9,48
80008e60:	f2 0a 18 00 	cp.b	r10,r9
80008e64:	c4 10       	breq	80008ee6 <_vfprintf_r+0x162a>
80008e66:	0c f9       	st.b	--r6,r9
80008e68:	c3 f8       	rjmp	80008ee6 <_vfprintf_r+0x162a>
80008e6a:	fa ea 00 00 	ld.d	r10,sp[0]
80008e6e:	30 a8       	mov	r8,10
80008e70:	30 09       	mov	r9,0
80008e72:	e0 a0 1a 0d 	rcall	8000c28c <__avr32_umod64>
80008e76:	30 a8       	mov	r8,10
80008e78:	2d 0a       	sub	r10,-48
80008e7a:	30 09       	mov	r9,0
80008e7c:	ac 8a       	st.b	r6[0x0],r10
80008e7e:	fa ea 00 00 	ld.d	r10,sp[0]
80008e82:	e0 a0 18 d3 	rcall	8000c028 <__avr32_udiv64>
80008e86:	16 99       	mov	r9,r11
80008e88:	14 98       	mov	r8,r10
80008e8a:	fa e9 00 00 	st.d	sp[0],r8
80008e8e:	20 16       	sub	r6,1
80008e90:	fa ea 00 00 	ld.d	r10,sp[0]
80008e94:	58 9a       	cp.w	r10,9
80008e96:	5c 2b       	cpc	r11
80008e98:	fe 9b ff e9 	brhi	80008e6a <_vfprintf_r+0x15ae>
80008e9c:	1b f8       	ld.ub	r8,sp[0x7]
80008e9e:	2d 08       	sub	r8,-48
80008ea0:	c2 08       	rjmp	80008ee0 <_vfprintf_r+0x1624>
80008ea2:	04 96       	mov	r6,r2
80008ea4:	fa e8 00 00 	ld.d	r8,sp[0]
80008ea8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008eac:	40 de       	lddsp	lr,sp[0x34]
80008eae:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008eb2:	0c fa       	st.b	--r6,r10
80008eb4:	f2 0b 16 04 	lsr	r11,r9,0x4
80008eb8:	f0 0a 16 04 	lsr	r10,r8,0x4
80008ebc:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008ec0:	16 99       	mov	r9,r11
80008ec2:	14 98       	mov	r8,r10
80008ec4:	58 08       	cp.w	r8,0
80008ec6:	5c 29       	cpc	r9
80008ec8:	cf 01       	brne	80008ea8 <_vfprintf_r+0x15ec>
80008eca:	fa e9 00 00 	st.d	sp[0],r8
80008ece:	c0 c8       	rjmp	80008ee6 <_vfprintf_r+0x162a>
80008ed0:	58 08       	cp.w	r8,0
80008ed2:	c0 91       	brne	80008ee4 <_vfprintf_r+0x1628>
80008ed4:	ed b5 00 00 	bld	r5,0x0
80008ed8:	c0 61       	brne	80008ee4 <_vfprintf_r+0x1628>
80008eda:	fa c6 f9 79 	sub	r6,sp,-1671
80008ede:	33 08       	mov	r8,48
80008ee0:	ac 88       	st.b	r6[0x0],r8
80008ee2:	c0 28       	rjmp	80008ee6 <_vfprintf_r+0x162a>
80008ee4:	04 96       	mov	r6,r2
80008ee6:	0c 12       	sub	r2,r6
80008ee8:	c1 c8       	rjmp	80008f20 <_vfprintf_r+0x1664>
80008eea:	50 a7       	stdsp	sp[0x28],r7
80008eec:	50 80       	stdsp	sp[0x20],r0
80008eee:	40 93       	lddsp	r3,sp[0x24]
80008ef0:	0c 97       	mov	r7,r6
80008ef2:	10 90       	mov	r0,r8
80008ef4:	04 94       	mov	r4,r2
80008ef6:	40 41       	lddsp	r1,sp[0x10]
80008ef8:	58 08       	cp.w	r8,0
80008efa:	e0 80 04 4f 	breq	80009798 <_vfprintf_r+0x1edc>
80008efe:	fb 68 06 60 	st.b	sp[1632],r8
80008f02:	30 0c       	mov	r12,0
80008f04:	30 08       	mov	r8,0
80008f06:	30 12       	mov	r2,1
80008f08:	fb 68 06 bb 	st.b	sp[1723],r8
80008f0c:	50 2c       	stdsp	sp[0x8],r12
80008f0e:	fa c6 f9 a0 	sub	r6,sp,-1632
80008f12:	c0 78       	rjmp	80008f20 <_vfprintf_r+0x1664>
80008f14:	30 0b       	mov	r11,0
80008f16:	50 2b       	stdsp	sp[0x8],r11
80008f18:	c0 48       	rjmp	80008f20 <_vfprintf_r+0x1664>
80008f1a:	40 22       	lddsp	r2,sp[0x8]
80008f1c:	30 0a       	mov	r10,0
80008f1e:	50 2a       	stdsp	sp[0x8],r10
80008f20:	40 29       	lddsp	r9,sp[0x8]
80008f22:	e4 09 0c 49 	max	r9,r2,r9
80008f26:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008f2a:	50 39       	stdsp	sp[0xc],r9
80008f2c:	0a 9e       	mov	lr,r5
80008f2e:	30 09       	mov	r9,0
80008f30:	e2 1e 00 02 	andl	lr,0x2,COH
80008f34:	f2 08 18 00 	cp.b	r8,r9
80008f38:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008f3c:	f7 b8 01 ff 	subne	r8,-1
80008f40:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008f44:	0a 9b       	mov	r11,r5
80008f46:	58 0e       	cp.w	lr,0
80008f48:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008f4c:	f7 bc 01 fe 	subne	r12,-2
80008f50:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008f54:	e2 1b 00 84 	andl	r11,0x84,COH
80008f58:	50 fe       	stdsp	sp[0x3c],lr
80008f5a:	50 9b       	stdsp	sp[0x24],r11
80008f5c:	c4 71       	brne	80008fea <_vfprintf_r+0x172e>
80008f5e:	40 8a       	lddsp	r10,sp[0x20]
80008f60:	40 39       	lddsp	r9,sp[0xc]
80008f62:	12 1a       	sub	r10,r9
80008f64:	50 4a       	stdsp	sp[0x10],r10
80008f66:	58 0a       	cp.w	r10,0
80008f68:	e0 89 00 20 	brgt	80008fa8 <_vfprintf_r+0x16ec>
80008f6c:	c3 f8       	rjmp	80008fea <_vfprintf_r+0x172e>
80008f6e:	2f 09       	sub	r9,-16
80008f70:	2f f8       	sub	r8,-1
80008f72:	fe ce b8 3a 	sub	lr,pc,-18374
80008f76:	31 0c       	mov	r12,16
80008f78:	fb 49 06 90 	st.w	sp[1680],r9
80008f7c:	87 0e       	st.w	r3[0x0],lr
80008f7e:	87 1c       	st.w	r3[0x4],r12
80008f80:	fb 48 06 8c 	st.w	sp[1676],r8
80008f84:	58 78       	cp.w	r8,7
80008f86:	e0 89 00 04 	brgt	80008f8e <_vfprintf_r+0x16d2>
80008f8a:	2f 83       	sub	r3,-8
80008f8c:	c0 b8       	rjmp	80008fa2 <_vfprintf_r+0x16e6>
80008f8e:	fa ca f9 78 	sub	r10,sp,-1672
80008f92:	02 9b       	mov	r11,r1
80008f94:	08 9c       	mov	r12,r4
80008f96:	fe b0 f4 85 	rcall	800078a0 <__sprint_r>
80008f9a:	e0 81 04 10 	brne	800097ba <_vfprintf_r+0x1efe>
80008f9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fa2:	40 4b       	lddsp	r11,sp[0x10]
80008fa4:	21 0b       	sub	r11,16
80008fa6:	50 4b       	stdsp	sp[0x10],r11
80008fa8:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fac:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fb0:	fe ca b8 78 	sub	r10,pc,-18312
80008fb4:	40 4e       	lddsp	lr,sp[0x10]
80008fb6:	59 0e       	cp.w	lr,16
80008fb8:	fe 99 ff db 	brgt	80008f6e <_vfprintf_r+0x16b2>
80008fbc:	1c 09       	add	r9,lr
80008fbe:	2f f8       	sub	r8,-1
80008fc0:	87 0a       	st.w	r3[0x0],r10
80008fc2:	fb 49 06 90 	st.w	sp[1680],r9
80008fc6:	87 1e       	st.w	r3[0x4],lr
80008fc8:	fb 48 06 8c 	st.w	sp[1676],r8
80008fcc:	58 78       	cp.w	r8,7
80008fce:	e0 89 00 04 	brgt	80008fd6 <_vfprintf_r+0x171a>
80008fd2:	2f 83       	sub	r3,-8
80008fd4:	c0 b8       	rjmp	80008fea <_vfprintf_r+0x172e>
80008fd6:	fa ca f9 78 	sub	r10,sp,-1672
80008fda:	02 9b       	mov	r11,r1
80008fdc:	08 9c       	mov	r12,r4
80008fde:	fe b0 f4 61 	rcall	800078a0 <__sprint_r>
80008fe2:	e0 81 03 ec 	brne	800097ba <_vfprintf_r+0x1efe>
80008fe6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fea:	30 09       	mov	r9,0
80008fec:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008ff0:	f2 08 18 00 	cp.b	r8,r9
80008ff4:	c1 f0       	breq	80009032 <_vfprintf_r+0x1776>
80008ff6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ffa:	fa c9 f9 45 	sub	r9,sp,-1723
80008ffe:	2f f8       	sub	r8,-1
80009000:	87 09       	st.w	r3[0x0],r9
80009002:	fb 48 06 90 	st.w	sp[1680],r8
80009006:	30 19       	mov	r9,1
80009008:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000900c:	87 19       	st.w	r3[0x4],r9
8000900e:	2f f8       	sub	r8,-1
80009010:	fb 48 06 8c 	st.w	sp[1676],r8
80009014:	58 78       	cp.w	r8,7
80009016:	e0 89 00 04 	brgt	8000901e <_vfprintf_r+0x1762>
8000901a:	2f 83       	sub	r3,-8
8000901c:	c0 b8       	rjmp	80009032 <_vfprintf_r+0x1776>
8000901e:	fa ca f9 78 	sub	r10,sp,-1672
80009022:	02 9b       	mov	r11,r1
80009024:	08 9c       	mov	r12,r4
80009026:	fe b0 f4 3d 	rcall	800078a0 <__sprint_r>
8000902a:	e0 81 03 c8 	brne	800097ba <_vfprintf_r+0x1efe>
8000902e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009032:	40 fc       	lddsp	r12,sp[0x3c]
80009034:	58 0c       	cp.w	r12,0
80009036:	c1 f0       	breq	80009074 <_vfprintf_r+0x17b8>
80009038:	fa f8 06 90 	ld.w	r8,sp[1680]
8000903c:	fa c9 f9 48 	sub	r9,sp,-1720
80009040:	2f e8       	sub	r8,-2
80009042:	87 09       	st.w	r3[0x0],r9
80009044:	fb 48 06 90 	st.w	sp[1680],r8
80009048:	30 29       	mov	r9,2
8000904a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000904e:	87 19       	st.w	r3[0x4],r9
80009050:	2f f8       	sub	r8,-1
80009052:	fb 48 06 8c 	st.w	sp[1676],r8
80009056:	58 78       	cp.w	r8,7
80009058:	e0 89 00 04 	brgt	80009060 <_vfprintf_r+0x17a4>
8000905c:	2f 83       	sub	r3,-8
8000905e:	c0 b8       	rjmp	80009074 <_vfprintf_r+0x17b8>
80009060:	fa ca f9 78 	sub	r10,sp,-1672
80009064:	02 9b       	mov	r11,r1
80009066:	08 9c       	mov	r12,r4
80009068:	fe b0 f4 1c 	rcall	800078a0 <__sprint_r>
8000906c:	e0 81 03 a7 	brne	800097ba <_vfprintf_r+0x1efe>
80009070:	fa c3 f9 e0 	sub	r3,sp,-1568
80009074:	40 9b       	lddsp	r11,sp[0x24]
80009076:	e0 4b 00 80 	cp.w	r11,128
8000907a:	c4 71       	brne	80009108 <_vfprintf_r+0x184c>
8000907c:	40 8a       	lddsp	r10,sp[0x20]
8000907e:	40 39       	lddsp	r9,sp[0xc]
80009080:	12 1a       	sub	r10,r9
80009082:	50 4a       	stdsp	sp[0x10],r10
80009084:	58 0a       	cp.w	r10,0
80009086:	e0 89 00 20 	brgt	800090c6 <_vfprintf_r+0x180a>
8000908a:	c3 f8       	rjmp	80009108 <_vfprintf_r+0x184c>
8000908c:	2f 09       	sub	r9,-16
8000908e:	2f f8       	sub	r8,-1
80009090:	fe ce b9 48 	sub	lr,pc,-18104
80009094:	31 0c       	mov	r12,16
80009096:	fb 49 06 90 	st.w	sp[1680],r9
8000909a:	87 0e       	st.w	r3[0x0],lr
8000909c:	87 1c       	st.w	r3[0x4],r12
8000909e:	fb 48 06 8c 	st.w	sp[1676],r8
800090a2:	58 78       	cp.w	r8,7
800090a4:	e0 89 00 04 	brgt	800090ac <_vfprintf_r+0x17f0>
800090a8:	2f 83       	sub	r3,-8
800090aa:	c0 b8       	rjmp	800090c0 <_vfprintf_r+0x1804>
800090ac:	fa ca f9 78 	sub	r10,sp,-1672
800090b0:	02 9b       	mov	r11,r1
800090b2:	08 9c       	mov	r12,r4
800090b4:	fe b0 f3 f6 	rcall	800078a0 <__sprint_r>
800090b8:	e0 81 03 81 	brne	800097ba <_vfprintf_r+0x1efe>
800090bc:	fa c3 f9 e0 	sub	r3,sp,-1568
800090c0:	40 4b       	lddsp	r11,sp[0x10]
800090c2:	21 0b       	sub	r11,16
800090c4:	50 4b       	stdsp	sp[0x10],r11
800090c6:	fa f9 06 90 	ld.w	r9,sp[1680]
800090ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090ce:	fe ca b9 86 	sub	r10,pc,-18042
800090d2:	40 4e       	lddsp	lr,sp[0x10]
800090d4:	59 0e       	cp.w	lr,16
800090d6:	fe 99 ff db 	brgt	8000908c <_vfprintf_r+0x17d0>
800090da:	1c 09       	add	r9,lr
800090dc:	2f f8       	sub	r8,-1
800090de:	87 0a       	st.w	r3[0x0],r10
800090e0:	fb 49 06 90 	st.w	sp[1680],r9
800090e4:	87 1e       	st.w	r3[0x4],lr
800090e6:	fb 48 06 8c 	st.w	sp[1676],r8
800090ea:	58 78       	cp.w	r8,7
800090ec:	e0 89 00 04 	brgt	800090f4 <_vfprintf_r+0x1838>
800090f0:	2f 83       	sub	r3,-8
800090f2:	c0 b8       	rjmp	80009108 <_vfprintf_r+0x184c>
800090f4:	fa ca f9 78 	sub	r10,sp,-1672
800090f8:	02 9b       	mov	r11,r1
800090fa:	08 9c       	mov	r12,r4
800090fc:	fe b0 f3 d2 	rcall	800078a0 <__sprint_r>
80009100:	e0 81 03 5d 	brne	800097ba <_vfprintf_r+0x1efe>
80009104:	fa c3 f9 e0 	sub	r3,sp,-1568
80009108:	40 2c       	lddsp	r12,sp[0x8]
8000910a:	04 1c       	sub	r12,r2
8000910c:	50 2c       	stdsp	sp[0x8],r12
8000910e:	58 0c       	cp.w	r12,0
80009110:	e0 89 00 20 	brgt	80009150 <_vfprintf_r+0x1894>
80009114:	c3 f8       	rjmp	80009192 <_vfprintf_r+0x18d6>
80009116:	2f 09       	sub	r9,-16
80009118:	2f f8       	sub	r8,-1
8000911a:	fe cb b9 d2 	sub	r11,pc,-17966
8000911e:	31 0a       	mov	r10,16
80009120:	fb 49 06 90 	st.w	sp[1680],r9
80009124:	87 0b       	st.w	r3[0x0],r11
80009126:	87 1a       	st.w	r3[0x4],r10
80009128:	fb 48 06 8c 	st.w	sp[1676],r8
8000912c:	58 78       	cp.w	r8,7
8000912e:	e0 89 00 04 	brgt	80009136 <_vfprintf_r+0x187a>
80009132:	2f 83       	sub	r3,-8
80009134:	c0 b8       	rjmp	8000914a <_vfprintf_r+0x188e>
80009136:	fa ca f9 78 	sub	r10,sp,-1672
8000913a:	02 9b       	mov	r11,r1
8000913c:	08 9c       	mov	r12,r4
8000913e:	fe b0 f3 b1 	rcall	800078a0 <__sprint_r>
80009142:	e0 81 03 3c 	brne	800097ba <_vfprintf_r+0x1efe>
80009146:	fa c3 f9 e0 	sub	r3,sp,-1568
8000914a:	40 29       	lddsp	r9,sp[0x8]
8000914c:	21 09       	sub	r9,16
8000914e:	50 29       	stdsp	sp[0x8],r9
80009150:	fa f9 06 90 	ld.w	r9,sp[1680]
80009154:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009158:	fe ca ba 10 	sub	r10,pc,-17904
8000915c:	40 2e       	lddsp	lr,sp[0x8]
8000915e:	59 0e       	cp.w	lr,16
80009160:	fe 99 ff db 	brgt	80009116 <_vfprintf_r+0x185a>
80009164:	1c 09       	add	r9,lr
80009166:	2f f8       	sub	r8,-1
80009168:	87 0a       	st.w	r3[0x0],r10
8000916a:	fb 49 06 90 	st.w	sp[1680],r9
8000916e:	87 1e       	st.w	r3[0x4],lr
80009170:	fb 48 06 8c 	st.w	sp[1676],r8
80009174:	58 78       	cp.w	r8,7
80009176:	e0 89 00 04 	brgt	8000917e <_vfprintf_r+0x18c2>
8000917a:	2f 83       	sub	r3,-8
8000917c:	c0 b8       	rjmp	80009192 <_vfprintf_r+0x18d6>
8000917e:	fa ca f9 78 	sub	r10,sp,-1672
80009182:	02 9b       	mov	r11,r1
80009184:	08 9c       	mov	r12,r4
80009186:	fe b0 f3 8d 	rcall	800078a0 <__sprint_r>
8000918a:	e0 81 03 18 	brne	800097ba <_vfprintf_r+0x1efe>
8000918e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009192:	ed b5 00 08 	bld	r5,0x8
80009196:	c0 b0       	breq	800091ac <_vfprintf_r+0x18f0>
80009198:	fa f8 06 90 	ld.w	r8,sp[1680]
8000919c:	87 12       	st.w	r3[0x4],r2
8000919e:	87 06       	st.w	r3[0x0],r6
800091a0:	f0 02 00 02 	add	r2,r8,r2
800091a4:	fb 42 06 90 	st.w	sp[1680],r2
800091a8:	e0 8f 01 d4 	bral	80009550 <_vfprintf_r+0x1c94>
800091ac:	e0 40 00 65 	cp.w	r0,101
800091b0:	e0 8a 01 d6 	brle	8000955c <_vfprintf_r+0x1ca0>
800091b4:	30 08       	mov	r8,0
800091b6:	30 09       	mov	r9,0
800091b8:	40 5b       	lddsp	r11,sp[0x14]
800091ba:	40 7a       	lddsp	r10,sp[0x1c]
800091bc:	e0 a0 15 2f 	rcall	8000bc1a <__avr32_f64_cmp_eq>
800091c0:	c7 90       	breq	800092b2 <_vfprintf_r+0x19f6>
800091c2:	fa f8 06 90 	ld.w	r8,sp[1680]
800091c6:	fe c9 ba 92 	sub	r9,pc,-17774
800091ca:	2f f8       	sub	r8,-1
800091cc:	87 09       	st.w	r3[0x0],r9
800091ce:	fb 48 06 90 	st.w	sp[1680],r8
800091d2:	30 19       	mov	r9,1
800091d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091d8:	87 19       	st.w	r3[0x4],r9
800091da:	2f f8       	sub	r8,-1
800091dc:	fb 48 06 8c 	st.w	sp[1676],r8
800091e0:	58 78       	cp.w	r8,7
800091e2:	e0 89 00 05 	brgt	800091ec <_vfprintf_r+0x1930>
800091e6:	2f 83       	sub	r3,-8
800091e8:	c0 c8       	rjmp	80009200 <_vfprintf_r+0x1944>
800091ea:	d7 03       	nop
800091ec:	fa ca f9 78 	sub	r10,sp,-1672
800091f0:	02 9b       	mov	r11,r1
800091f2:	08 9c       	mov	r12,r4
800091f4:	fe b0 f3 56 	rcall	800078a0 <__sprint_r>
800091f8:	e0 81 02 e1 	brne	800097ba <_vfprintf_r+0x1efe>
800091fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009200:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009204:	40 6c       	lddsp	r12,sp[0x18]
80009206:	18 38       	cp.w	r8,r12
80009208:	c0 55       	brlt	80009212 <_vfprintf_r+0x1956>
8000920a:	ed b5 00 00 	bld	r5,0x0
8000920e:	e0 81 02 6b 	brne	800096e4 <_vfprintf_r+0x1e28>
80009212:	fa f8 06 90 	ld.w	r8,sp[1680]
80009216:	2f f8       	sub	r8,-1
80009218:	40 cb       	lddsp	r11,sp[0x30]
8000921a:	fb 48 06 90 	st.w	sp[1680],r8
8000921e:	30 19       	mov	r9,1
80009220:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009224:	87 0b       	st.w	r3[0x0],r11
80009226:	2f f8       	sub	r8,-1
80009228:	87 19       	st.w	r3[0x4],r9
8000922a:	fb 48 06 8c 	st.w	sp[1676],r8
8000922e:	58 78       	cp.w	r8,7
80009230:	e0 89 00 04 	brgt	80009238 <_vfprintf_r+0x197c>
80009234:	2f 83       	sub	r3,-8
80009236:	c0 b8       	rjmp	8000924c <_vfprintf_r+0x1990>
80009238:	fa ca f9 78 	sub	r10,sp,-1672
8000923c:	02 9b       	mov	r11,r1
8000923e:	08 9c       	mov	r12,r4
80009240:	fe b0 f3 30 	rcall	800078a0 <__sprint_r>
80009244:	e0 81 02 bb 	brne	800097ba <_vfprintf_r+0x1efe>
80009248:	fa c3 f9 e0 	sub	r3,sp,-1568
8000924c:	40 66       	lddsp	r6,sp[0x18]
8000924e:	20 16       	sub	r6,1
80009250:	58 06       	cp.w	r6,0
80009252:	e0 89 00 1d 	brgt	8000928c <_vfprintf_r+0x19d0>
80009256:	e0 8f 02 47 	bral	800096e4 <_vfprintf_r+0x1e28>
8000925a:	2f 09       	sub	r9,-16
8000925c:	2f f8       	sub	r8,-1
8000925e:	fb 49 06 90 	st.w	sp[1680],r9
80009262:	87 02       	st.w	r3[0x0],r2
80009264:	87 10       	st.w	r3[0x4],r0
80009266:	fb 48 06 8c 	st.w	sp[1676],r8
8000926a:	58 78       	cp.w	r8,7
8000926c:	e0 89 00 04 	brgt	80009274 <_vfprintf_r+0x19b8>
80009270:	2f 83       	sub	r3,-8
80009272:	c0 b8       	rjmp	80009288 <_vfprintf_r+0x19cc>
80009274:	fa ca f9 78 	sub	r10,sp,-1672
80009278:	02 9b       	mov	r11,r1
8000927a:	08 9c       	mov	r12,r4
8000927c:	fe b0 f3 12 	rcall	800078a0 <__sprint_r>
80009280:	e0 81 02 9d 	brne	800097ba <_vfprintf_r+0x1efe>
80009284:	fa c3 f9 e0 	sub	r3,sp,-1568
80009288:	21 06       	sub	r6,16
8000928a:	c0 48       	rjmp	80009292 <_vfprintf_r+0x19d6>
8000928c:	fe c2 bb 44 	sub	r2,pc,-17596
80009290:	31 00       	mov	r0,16
80009292:	fa f9 06 90 	ld.w	r9,sp[1680]
80009296:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000929a:	fe ca bb 52 	sub	r10,pc,-17582
8000929e:	59 06       	cp.w	r6,16
800092a0:	fe 99 ff dd 	brgt	8000925a <_vfprintf_r+0x199e>
800092a4:	0c 09       	add	r9,r6
800092a6:	87 0a       	st.w	r3[0x0],r10
800092a8:	fb 49 06 90 	st.w	sp[1680],r9
800092ac:	2f f8       	sub	r8,-1
800092ae:	87 16       	st.w	r3[0x4],r6
800092b0:	c5 39       	rjmp	80009556 <_vfprintf_r+0x1c9a>
800092b2:	fa fa 06 ac 	ld.w	r10,sp[1708]
800092b6:	58 0a       	cp.w	r10,0
800092b8:	e0 89 00 92 	brgt	800093dc <_vfprintf_r+0x1b20>
800092bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800092c0:	fe c9 bb 8c 	sub	r9,pc,-17524
800092c4:	2f f8       	sub	r8,-1
800092c6:	87 09       	st.w	r3[0x0],r9
800092c8:	fb 48 06 90 	st.w	sp[1680],r8
800092cc:	30 19       	mov	r9,1
800092ce:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092d2:	87 19       	st.w	r3[0x4],r9
800092d4:	2f f8       	sub	r8,-1
800092d6:	fb 48 06 8c 	st.w	sp[1676],r8
800092da:	58 78       	cp.w	r8,7
800092dc:	e0 89 00 04 	brgt	800092e4 <_vfprintf_r+0x1a28>
800092e0:	2f 83       	sub	r3,-8
800092e2:	c0 b8       	rjmp	800092f8 <_vfprintf_r+0x1a3c>
800092e4:	fa ca f9 78 	sub	r10,sp,-1672
800092e8:	02 9b       	mov	r11,r1
800092ea:	08 9c       	mov	r12,r4
800092ec:	fe b0 f2 da 	rcall	800078a0 <__sprint_r>
800092f0:	e0 81 02 65 	brne	800097ba <_vfprintf_r+0x1efe>
800092f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092fc:	58 08       	cp.w	r8,0
800092fe:	c0 81       	brne	8000930e <_vfprintf_r+0x1a52>
80009300:	40 6a       	lddsp	r10,sp[0x18]
80009302:	58 0a       	cp.w	r10,0
80009304:	c0 51       	brne	8000930e <_vfprintf_r+0x1a52>
80009306:	ed b5 00 00 	bld	r5,0x0
8000930a:	e0 81 01 ed 	brne	800096e4 <_vfprintf_r+0x1e28>
8000930e:	40 c9       	lddsp	r9,sp[0x30]
80009310:	fa f8 06 90 	ld.w	r8,sp[1680]
80009314:	2f f8       	sub	r8,-1
80009316:	87 09       	st.w	r3[0x0],r9
80009318:	fb 48 06 90 	st.w	sp[1680],r8
8000931c:	30 19       	mov	r9,1
8000931e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009322:	87 19       	st.w	r3[0x4],r9
80009324:	2f f8       	sub	r8,-1
80009326:	fb 48 06 8c 	st.w	sp[1676],r8
8000932a:	58 78       	cp.w	r8,7
8000932c:	e0 89 00 04 	brgt	80009334 <_vfprintf_r+0x1a78>
80009330:	2f 83       	sub	r3,-8
80009332:	c0 b8       	rjmp	80009348 <_vfprintf_r+0x1a8c>
80009334:	fa ca f9 78 	sub	r10,sp,-1672
80009338:	02 9b       	mov	r11,r1
8000933a:	08 9c       	mov	r12,r4
8000933c:	fe b0 f2 b2 	rcall	800078a0 <__sprint_r>
80009340:	e0 81 02 3d 	brne	800097ba <_vfprintf_r+0x1efe>
80009344:	fa c3 f9 e0 	sub	r3,sp,-1568
80009348:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000934c:	5c 32       	neg	r2
8000934e:	58 02       	cp.w	r2,0
80009350:	e0 89 00 1d 	brgt	8000938a <_vfprintf_r+0x1ace>
80009354:	c3 d8       	rjmp	800093ce <_vfprintf_r+0x1b12>
80009356:	2f 09       	sub	r9,-16
80009358:	2f f8       	sub	r8,-1
8000935a:	31 0e       	mov	lr,16
8000935c:	fb 49 06 90 	st.w	sp[1680],r9
80009360:	87 00       	st.w	r3[0x0],r0
80009362:	87 1e       	st.w	r3[0x4],lr
80009364:	fb 48 06 8c 	st.w	sp[1676],r8
80009368:	58 78       	cp.w	r8,7
8000936a:	e0 89 00 04 	brgt	80009372 <_vfprintf_r+0x1ab6>
8000936e:	2f 83       	sub	r3,-8
80009370:	c0 b8       	rjmp	80009386 <_vfprintf_r+0x1aca>
80009372:	fa ca f9 78 	sub	r10,sp,-1672
80009376:	02 9b       	mov	r11,r1
80009378:	08 9c       	mov	r12,r4
8000937a:	fe b0 f2 93 	rcall	800078a0 <__sprint_r>
8000937e:	e0 81 02 1e 	brne	800097ba <_vfprintf_r+0x1efe>
80009382:	fa c3 f9 e0 	sub	r3,sp,-1568
80009386:	21 02       	sub	r2,16
80009388:	c0 38       	rjmp	8000938e <_vfprintf_r+0x1ad2>
8000938a:	fe c0 bc 42 	sub	r0,pc,-17342
8000938e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009392:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009396:	fe ca bc 4e 	sub	r10,pc,-17330
8000939a:	59 02       	cp.w	r2,16
8000939c:	fe 99 ff dd 	brgt	80009356 <_vfprintf_r+0x1a9a>
800093a0:	04 09       	add	r9,r2
800093a2:	2f f8       	sub	r8,-1
800093a4:	87 0a       	st.w	r3[0x0],r10
800093a6:	fb 49 06 90 	st.w	sp[1680],r9
800093aa:	87 12       	st.w	r3[0x4],r2
800093ac:	fb 48 06 8c 	st.w	sp[1676],r8
800093b0:	58 78       	cp.w	r8,7
800093b2:	e0 89 00 04 	brgt	800093ba <_vfprintf_r+0x1afe>
800093b6:	2f 83       	sub	r3,-8
800093b8:	c0 b8       	rjmp	800093ce <_vfprintf_r+0x1b12>
800093ba:	fa ca f9 78 	sub	r10,sp,-1672
800093be:	02 9b       	mov	r11,r1
800093c0:	08 9c       	mov	r12,r4
800093c2:	fe b0 f2 6f 	rcall	800078a0 <__sprint_r>
800093c6:	e0 81 01 fa 	brne	800097ba <_vfprintf_r+0x1efe>
800093ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800093ce:	40 6c       	lddsp	r12,sp[0x18]
800093d0:	fa f8 06 90 	ld.w	r8,sp[1680]
800093d4:	87 06       	st.w	r3[0x0],r6
800093d6:	87 1c       	st.w	r3[0x4],r12
800093d8:	18 08       	add	r8,r12
800093da:	cb 98       	rjmp	8000954c <_vfprintf_r+0x1c90>
800093dc:	fa f9 06 90 	ld.w	r9,sp[1680]
800093e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093e4:	40 6b       	lddsp	r11,sp[0x18]
800093e6:	16 3a       	cp.w	r10,r11
800093e8:	c6 f5       	brlt	800094c6 <_vfprintf_r+0x1c0a>
800093ea:	16 09       	add	r9,r11
800093ec:	2f f8       	sub	r8,-1
800093ee:	87 06       	st.w	r3[0x0],r6
800093f0:	fb 49 06 90 	st.w	sp[1680],r9
800093f4:	87 1b       	st.w	r3[0x4],r11
800093f6:	fb 48 06 8c 	st.w	sp[1676],r8
800093fa:	58 78       	cp.w	r8,7
800093fc:	e0 89 00 04 	brgt	80009404 <_vfprintf_r+0x1b48>
80009400:	2f 83       	sub	r3,-8
80009402:	c0 b8       	rjmp	80009418 <_vfprintf_r+0x1b5c>
80009404:	fa ca f9 78 	sub	r10,sp,-1672
80009408:	02 9b       	mov	r11,r1
8000940a:	08 9c       	mov	r12,r4
8000940c:	fe b0 f2 4a 	rcall	800078a0 <__sprint_r>
80009410:	e0 81 01 d5 	brne	800097ba <_vfprintf_r+0x1efe>
80009414:	fa c3 f9 e0 	sub	r3,sp,-1568
80009418:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000941c:	40 6a       	lddsp	r10,sp[0x18]
8000941e:	14 16       	sub	r6,r10
80009420:	58 06       	cp.w	r6,0
80009422:	e0 89 00 1c 	brgt	8000945a <_vfprintf_r+0x1b9e>
80009426:	c3 d8       	rjmp	800094a0 <_vfprintf_r+0x1be4>
80009428:	2f 09       	sub	r9,-16
8000942a:	2f f8       	sub	r8,-1
8000942c:	fb 49 06 90 	st.w	sp[1680],r9
80009430:	87 02       	st.w	r3[0x0],r2
80009432:	87 10       	st.w	r3[0x4],r0
80009434:	fb 48 06 8c 	st.w	sp[1676],r8
80009438:	58 78       	cp.w	r8,7
8000943a:	e0 89 00 04 	brgt	80009442 <_vfprintf_r+0x1b86>
8000943e:	2f 83       	sub	r3,-8
80009440:	c0 b8       	rjmp	80009456 <_vfprintf_r+0x1b9a>
80009442:	fa ca f9 78 	sub	r10,sp,-1672
80009446:	02 9b       	mov	r11,r1
80009448:	08 9c       	mov	r12,r4
8000944a:	fe b0 f2 2b 	rcall	800078a0 <__sprint_r>
8000944e:	e0 81 01 b6 	brne	800097ba <_vfprintf_r+0x1efe>
80009452:	fa c3 f9 e0 	sub	r3,sp,-1568
80009456:	21 06       	sub	r6,16
80009458:	c0 48       	rjmp	80009460 <_vfprintf_r+0x1ba4>
8000945a:	fe c2 bd 12 	sub	r2,pc,-17134
8000945e:	31 00       	mov	r0,16
80009460:	fa f9 06 90 	ld.w	r9,sp[1680]
80009464:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009468:	fe ca bd 20 	sub	r10,pc,-17120
8000946c:	59 06       	cp.w	r6,16
8000946e:	fe 99 ff dd 	brgt	80009428 <_vfprintf_r+0x1b6c>
80009472:	0c 09       	add	r9,r6
80009474:	2f f8       	sub	r8,-1
80009476:	87 0a       	st.w	r3[0x0],r10
80009478:	fb 49 06 90 	st.w	sp[1680],r9
8000947c:	87 16       	st.w	r3[0x4],r6
8000947e:	fb 48 06 8c 	st.w	sp[1676],r8
80009482:	58 78       	cp.w	r8,7
80009484:	e0 89 00 04 	brgt	8000948c <_vfprintf_r+0x1bd0>
80009488:	2f 83       	sub	r3,-8
8000948a:	c0 b8       	rjmp	800094a0 <_vfprintf_r+0x1be4>
8000948c:	fa ca f9 78 	sub	r10,sp,-1672
80009490:	02 9b       	mov	r11,r1
80009492:	08 9c       	mov	r12,r4
80009494:	fe b0 f2 06 	rcall	800078a0 <__sprint_r>
80009498:	e0 81 01 91 	brne	800097ba <_vfprintf_r+0x1efe>
8000949c:	fa c3 f9 e0 	sub	r3,sp,-1568
800094a0:	ed b5 00 00 	bld	r5,0x0
800094a4:	e0 81 01 20 	brne	800096e4 <_vfprintf_r+0x1e28>
800094a8:	40 c9       	lddsp	r9,sp[0x30]
800094aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800094ae:	2f f8       	sub	r8,-1
800094b0:	87 09       	st.w	r3[0x0],r9
800094b2:	fb 48 06 90 	st.w	sp[1680],r8
800094b6:	30 19       	mov	r9,1
800094b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094bc:	87 19       	st.w	r3[0x4],r9
800094be:	2f f8       	sub	r8,-1
800094c0:	fb 48 06 8c 	st.w	sp[1676],r8
800094c4:	c0 29       	rjmp	800096c8 <_vfprintf_r+0x1e0c>
800094c6:	14 09       	add	r9,r10
800094c8:	2f f8       	sub	r8,-1
800094ca:	fb 49 06 90 	st.w	sp[1680],r9
800094ce:	87 06       	st.w	r3[0x0],r6
800094d0:	87 1a       	st.w	r3[0x4],r10
800094d2:	fb 48 06 8c 	st.w	sp[1676],r8
800094d6:	58 78       	cp.w	r8,7
800094d8:	e0 89 00 04 	brgt	800094e0 <_vfprintf_r+0x1c24>
800094dc:	2f 83       	sub	r3,-8
800094de:	c0 b8       	rjmp	800094f4 <_vfprintf_r+0x1c38>
800094e0:	fa ca f9 78 	sub	r10,sp,-1672
800094e4:	02 9b       	mov	r11,r1
800094e6:	08 9c       	mov	r12,r4
800094e8:	fe b0 f1 dc 	rcall	800078a0 <__sprint_r>
800094ec:	e0 81 01 67 	brne	800097ba <_vfprintf_r+0x1efe>
800094f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f4:	40 c8       	lddsp	r8,sp[0x30]
800094f6:	87 08       	st.w	r3[0x0],r8
800094f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800094fc:	2f f8       	sub	r8,-1
800094fe:	30 19       	mov	r9,1
80009500:	fb 48 06 90 	st.w	sp[1680],r8
80009504:	87 19       	st.w	r3[0x4],r9
80009506:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000950a:	2f f8       	sub	r8,-1
8000950c:	fb 48 06 8c 	st.w	sp[1676],r8
80009510:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009514:	58 78       	cp.w	r8,7
80009516:	e0 89 00 04 	brgt	8000951e <_vfprintf_r+0x1c62>
8000951a:	2f 83       	sub	r3,-8
8000951c:	c0 b8       	rjmp	80009532 <_vfprintf_r+0x1c76>
8000951e:	fa ca f9 78 	sub	r10,sp,-1672
80009522:	02 9b       	mov	r11,r1
80009524:	08 9c       	mov	r12,r4
80009526:	fe b0 f1 bd 	rcall	800078a0 <__sprint_r>
8000952a:	e0 81 01 48 	brne	800097ba <_vfprintf_r+0x1efe>
8000952e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009532:	04 06       	add	r6,r2
80009534:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009538:	87 06       	st.w	r3[0x0],r6
8000953a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000953e:	40 66       	lddsp	r6,sp[0x18]
80009540:	40 6e       	lddsp	lr,sp[0x18]
80009542:	10 16       	sub	r6,r8
80009544:	f2 08 01 08 	sub	r8,r9,r8
80009548:	87 16       	st.w	r3[0x4],r6
8000954a:	1c 08       	add	r8,lr
8000954c:	fb 48 06 90 	st.w	sp[1680],r8
80009550:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009554:	2f f8       	sub	r8,-1
80009556:	fb 48 06 8c 	st.w	sp[1676],r8
8000955a:	cb 78       	rjmp	800096c8 <_vfprintf_r+0x1e0c>
8000955c:	40 6c       	lddsp	r12,sp[0x18]
8000955e:	58 1c       	cp.w	r12,1
80009560:	e0 89 00 06 	brgt	8000956c <_vfprintf_r+0x1cb0>
80009564:	ed b5 00 00 	bld	r5,0x0
80009568:	e0 81 00 85 	brne	80009672 <_vfprintf_r+0x1db6>
8000956c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009570:	2f f8       	sub	r8,-1
80009572:	30 19       	mov	r9,1
80009574:	fb 48 06 90 	st.w	sp[1680],r8
80009578:	87 06       	st.w	r3[0x0],r6
8000957a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000957e:	87 19       	st.w	r3[0x4],r9
80009580:	2f f8       	sub	r8,-1
80009582:	fb 48 06 8c 	st.w	sp[1676],r8
80009586:	58 78       	cp.w	r8,7
80009588:	e0 89 00 04 	brgt	80009590 <_vfprintf_r+0x1cd4>
8000958c:	2f 83       	sub	r3,-8
8000958e:	c0 b8       	rjmp	800095a4 <_vfprintf_r+0x1ce8>
80009590:	fa ca f9 78 	sub	r10,sp,-1672
80009594:	02 9b       	mov	r11,r1
80009596:	08 9c       	mov	r12,r4
80009598:	fe b0 f1 84 	rcall	800078a0 <__sprint_r>
8000959c:	e0 81 01 0f 	brne	800097ba <_vfprintf_r+0x1efe>
800095a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800095a4:	fa f8 06 90 	ld.w	r8,sp[1680]
800095a8:	2f f8       	sub	r8,-1
800095aa:	40 cb       	lddsp	r11,sp[0x30]
800095ac:	fb 48 06 90 	st.w	sp[1680],r8
800095b0:	30 19       	mov	r9,1
800095b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095b6:	87 0b       	st.w	r3[0x0],r11
800095b8:	2f f8       	sub	r8,-1
800095ba:	87 19       	st.w	r3[0x4],r9
800095bc:	fb 48 06 8c 	st.w	sp[1676],r8
800095c0:	58 78       	cp.w	r8,7
800095c2:	e0 89 00 05 	brgt	800095cc <_vfprintf_r+0x1d10>
800095c6:	2f 83       	sub	r3,-8
800095c8:	c0 c8       	rjmp	800095e0 <_vfprintf_r+0x1d24>
800095ca:	d7 03       	nop
800095cc:	fa ca f9 78 	sub	r10,sp,-1672
800095d0:	02 9b       	mov	r11,r1
800095d2:	08 9c       	mov	r12,r4
800095d4:	fe b0 f1 66 	rcall	800078a0 <__sprint_r>
800095d8:	e0 81 00 f1 	brne	800097ba <_vfprintf_r+0x1efe>
800095dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800095e0:	30 08       	mov	r8,0
800095e2:	30 09       	mov	r9,0
800095e4:	40 5b       	lddsp	r11,sp[0x14]
800095e6:	40 7a       	lddsp	r10,sp[0x1c]
800095e8:	e0 a0 13 19 	rcall	8000bc1a <__avr32_f64_cmp_eq>
800095ec:	40 68       	lddsp	r8,sp[0x18]
800095ee:	20 18       	sub	r8,1
800095f0:	58 0c       	cp.w	r12,0
800095f2:	c0 d1       	brne	8000960c <_vfprintf_r+0x1d50>
800095f4:	2f f6       	sub	r6,-1
800095f6:	87 18       	st.w	r3[0x4],r8
800095f8:	87 06       	st.w	r3[0x0],r6
800095fa:	fa f6 06 90 	ld.w	r6,sp[1680]
800095fe:	10 06       	add	r6,r8
80009600:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009604:	fb 46 06 90 	st.w	sp[1680],r6
80009608:	2f f8       	sub	r8,-1
8000960a:	c3 18       	rjmp	8000966c <_vfprintf_r+0x1db0>
8000960c:	10 96       	mov	r6,r8
8000960e:	58 08       	cp.w	r8,0
80009610:	e0 89 00 1c 	brgt	80009648 <_vfprintf_r+0x1d8c>
80009614:	c4 b8       	rjmp	800096aa <_vfprintf_r+0x1dee>
80009616:	2f 09       	sub	r9,-16
80009618:	2f f8       	sub	r8,-1
8000961a:	fb 49 06 90 	st.w	sp[1680],r9
8000961e:	87 02       	st.w	r3[0x0],r2
80009620:	87 10       	st.w	r3[0x4],r0
80009622:	fb 48 06 8c 	st.w	sp[1676],r8
80009626:	58 78       	cp.w	r8,7
80009628:	e0 89 00 04 	brgt	80009630 <_vfprintf_r+0x1d74>
8000962c:	2f 83       	sub	r3,-8
8000962e:	c0 b8       	rjmp	80009644 <_vfprintf_r+0x1d88>
80009630:	fa ca f9 78 	sub	r10,sp,-1672
80009634:	02 9b       	mov	r11,r1
80009636:	08 9c       	mov	r12,r4
80009638:	fe b0 f1 34 	rcall	800078a0 <__sprint_r>
8000963c:	e0 81 00 bf 	brne	800097ba <_vfprintf_r+0x1efe>
80009640:	fa c3 f9 e0 	sub	r3,sp,-1568
80009644:	21 06       	sub	r6,16
80009646:	c0 48       	rjmp	8000964e <_vfprintf_r+0x1d92>
80009648:	fe c2 bf 00 	sub	r2,pc,-16640
8000964c:	31 00       	mov	r0,16
8000964e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009652:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009656:	fe ca bf 0e 	sub	r10,pc,-16626
8000965a:	59 06       	cp.w	r6,16
8000965c:	fe 99 ff dd 	brgt	80009616 <_vfprintf_r+0x1d5a>
80009660:	0c 09       	add	r9,r6
80009662:	87 0a       	st.w	r3[0x0],r10
80009664:	fb 49 06 90 	st.w	sp[1680],r9
80009668:	2f f8       	sub	r8,-1
8000966a:	87 16       	st.w	r3[0x4],r6
8000966c:	fb 48 06 8c 	st.w	sp[1676],r8
80009670:	c0 e8       	rjmp	8000968c <_vfprintf_r+0x1dd0>
80009672:	fa f8 06 90 	ld.w	r8,sp[1680]
80009676:	2f f8       	sub	r8,-1
80009678:	30 19       	mov	r9,1
8000967a:	fb 48 06 90 	st.w	sp[1680],r8
8000967e:	87 06       	st.w	r3[0x0],r6
80009680:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009684:	87 19       	st.w	r3[0x4],r9
80009686:	2f f8       	sub	r8,-1
80009688:	fb 48 06 8c 	st.w	sp[1676],r8
8000968c:	58 78       	cp.w	r8,7
8000968e:	e0 89 00 04 	brgt	80009696 <_vfprintf_r+0x1dda>
80009692:	2f 83       	sub	r3,-8
80009694:	c0 b8       	rjmp	800096aa <_vfprintf_r+0x1dee>
80009696:	fa ca f9 78 	sub	r10,sp,-1672
8000969a:	02 9b       	mov	r11,r1
8000969c:	08 9c       	mov	r12,r4
8000969e:	fe b0 f1 01 	rcall	800078a0 <__sprint_r>
800096a2:	e0 81 00 8c 	brne	800097ba <_vfprintf_r+0x1efe>
800096a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800096aa:	40 ea       	lddsp	r10,sp[0x38]
800096ac:	fa f8 06 90 	ld.w	r8,sp[1680]
800096b0:	14 08       	add	r8,r10
800096b2:	fa c9 f9 64 	sub	r9,sp,-1692
800096b6:	fb 48 06 90 	st.w	sp[1680],r8
800096ba:	87 1a       	st.w	r3[0x4],r10
800096bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096c0:	87 09       	st.w	r3[0x0],r9
800096c2:	2f f8       	sub	r8,-1
800096c4:	fb 48 06 8c 	st.w	sp[1676],r8
800096c8:	58 78       	cp.w	r8,7
800096ca:	e0 89 00 04 	brgt	800096d2 <_vfprintf_r+0x1e16>
800096ce:	2f 83       	sub	r3,-8
800096d0:	c0 a8       	rjmp	800096e4 <_vfprintf_r+0x1e28>
800096d2:	fa ca f9 78 	sub	r10,sp,-1672
800096d6:	02 9b       	mov	r11,r1
800096d8:	08 9c       	mov	r12,r4
800096da:	fe b0 f0 e3 	rcall	800078a0 <__sprint_r>
800096de:	c6 e1       	brne	800097ba <_vfprintf_r+0x1efe>
800096e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096e4:	e2 15 00 04 	andl	r5,0x4,COH
800096e8:	c3 f0       	breq	80009766 <_vfprintf_r+0x1eaa>
800096ea:	40 86       	lddsp	r6,sp[0x20]
800096ec:	40 39       	lddsp	r9,sp[0xc]
800096ee:	12 16       	sub	r6,r9
800096f0:	58 06       	cp.w	r6,0
800096f2:	e0 89 00 1a 	brgt	80009726 <_vfprintf_r+0x1e6a>
800096f6:	c3 88       	rjmp	80009766 <_vfprintf_r+0x1eaa>
800096f8:	2f 09       	sub	r9,-16
800096fa:	2f f8       	sub	r8,-1
800096fc:	fb 49 06 90 	st.w	sp[1680],r9
80009700:	87 05       	st.w	r3[0x0],r5
80009702:	87 12       	st.w	r3[0x4],r2
80009704:	fb 48 06 8c 	st.w	sp[1676],r8
80009708:	58 78       	cp.w	r8,7
8000970a:	e0 89 00 04 	brgt	80009712 <_vfprintf_r+0x1e56>
8000970e:	2f 83       	sub	r3,-8
80009710:	c0 98       	rjmp	80009722 <_vfprintf_r+0x1e66>
80009712:	00 9a       	mov	r10,r0
80009714:	02 9b       	mov	r11,r1
80009716:	08 9c       	mov	r12,r4
80009718:	fe b0 f0 c4 	rcall	800078a0 <__sprint_r>
8000971c:	c4 f1       	brne	800097ba <_vfprintf_r+0x1efe>
8000971e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009722:	21 06       	sub	r6,16
80009724:	c0 68       	rjmp	80009730 <_vfprintf_r+0x1e74>
80009726:	fe c5 bf ee 	sub	r5,pc,-16402
8000972a:	31 02       	mov	r2,16
8000972c:	fa c0 f9 78 	sub	r0,sp,-1672
80009730:	fa f9 06 90 	ld.w	r9,sp[1680]
80009734:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009738:	fe ca c0 00 	sub	r10,pc,-16384
8000973c:	59 06       	cp.w	r6,16
8000973e:	fe 99 ff dd 	brgt	800096f8 <_vfprintf_r+0x1e3c>
80009742:	0c 09       	add	r9,r6
80009744:	2f f8       	sub	r8,-1
80009746:	87 0a       	st.w	r3[0x0],r10
80009748:	87 16       	st.w	r3[0x4],r6
8000974a:	fb 49 06 90 	st.w	sp[1680],r9
8000974e:	fb 48 06 8c 	st.w	sp[1676],r8
80009752:	58 78       	cp.w	r8,7
80009754:	e0 8a 00 09 	brle	80009766 <_vfprintf_r+0x1eaa>
80009758:	fa ca f9 78 	sub	r10,sp,-1672
8000975c:	02 9b       	mov	r11,r1
8000975e:	08 9c       	mov	r12,r4
80009760:	fe b0 f0 a0 	rcall	800078a0 <__sprint_r>
80009764:	c2 b1       	brne	800097ba <_vfprintf_r+0x1efe>
80009766:	40 bc       	lddsp	r12,sp[0x2c]
80009768:	40 36       	lddsp	r6,sp[0xc]
8000976a:	40 8e       	lddsp	lr,sp[0x20]
8000976c:	ec 0e 0c 48 	max	r8,r6,lr
80009770:	10 0c       	add	r12,r8
80009772:	50 bc       	stdsp	sp[0x2c],r12
80009774:	fa f8 06 90 	ld.w	r8,sp[1680]
80009778:	58 08       	cp.w	r8,0
8000977a:	c0 80       	breq	8000978a <_vfprintf_r+0x1ece>
8000977c:	fa ca f9 78 	sub	r10,sp,-1672
80009780:	02 9b       	mov	r11,r1
80009782:	08 9c       	mov	r12,r4
80009784:	fe b0 f0 8e 	rcall	800078a0 <__sprint_r>
80009788:	c1 91       	brne	800097ba <_vfprintf_r+0x1efe>
8000978a:	30 0b       	mov	r11,0
8000978c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009790:	fb 4b 06 8c 	st.w	sp[1676],r11
80009794:	fe 9f f1 22 	bral	800079d8 <_vfprintf_r+0x11c>
80009798:	08 95       	mov	r5,r4
8000979a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000979e:	58 08       	cp.w	r8,0
800097a0:	c0 80       	breq	800097b0 <_vfprintf_r+0x1ef4>
800097a2:	08 9c       	mov	r12,r4
800097a4:	fa ca f9 78 	sub	r10,sp,-1672
800097a8:	02 9b       	mov	r11,r1
800097aa:	fe b0 f0 7b 	rcall	800078a0 <__sprint_r>
800097ae:	c0 61       	brne	800097ba <_vfprintf_r+0x1efe>
800097b0:	30 08       	mov	r8,0
800097b2:	fb 48 06 8c 	st.w	sp[1676],r8
800097b6:	c0 28       	rjmp	800097ba <_vfprintf_r+0x1efe>
800097b8:	40 41       	lddsp	r1,sp[0x10]
800097ba:	82 68       	ld.sh	r8,r1[0xc]
800097bc:	ed b8 00 06 	bld	r8,0x6
800097c0:	c0 31       	brne	800097c6 <_vfprintf_r+0x1f0a>
800097c2:	3f fa       	mov	r10,-1
800097c4:	50 ba       	stdsp	sp[0x2c],r10
800097c6:	40 bc       	lddsp	r12,sp[0x2c]
800097c8:	fe 3d f9 44 	sub	sp,-1724
800097cc:	d8 32       	popm	r0-r7,pc
800097ce:	d7 03       	nop

800097d0 <__swsetup_r>:
800097d0:	d4 21       	pushm	r4-r7,lr
800097d2:	e0 68 0a 44 	mov	r8,2628
800097d6:	18 96       	mov	r6,r12
800097d8:	16 97       	mov	r7,r11
800097da:	70 0c       	ld.w	r12,r8[0x0]
800097dc:	58 0c       	cp.w	r12,0
800097de:	c0 60       	breq	800097ea <__swsetup_r+0x1a>
800097e0:	78 68       	ld.w	r8,r12[0x18]
800097e2:	58 08       	cp.w	r8,0
800097e4:	c0 31       	brne	800097ea <__swsetup_r+0x1a>
800097e6:	e0 a0 07 bf 	rcall	8000a764 <__sinit>
800097ea:	fe c8 bf 82 	sub	r8,pc,-16510
800097ee:	10 37       	cp.w	r7,r8
800097f0:	c0 61       	brne	800097fc <__swsetup_r+0x2c>
800097f2:	e0 68 0a 44 	mov	r8,2628
800097f6:	70 08       	ld.w	r8,r8[0x0]
800097f8:	70 07       	ld.w	r7,r8[0x0]
800097fa:	c1 28       	rjmp	8000981e <__swsetup_r+0x4e>
800097fc:	fe c8 bf 74 	sub	r8,pc,-16524
80009800:	10 37       	cp.w	r7,r8
80009802:	c0 61       	brne	8000980e <__swsetup_r+0x3e>
80009804:	e0 68 0a 44 	mov	r8,2628
80009808:	70 08       	ld.w	r8,r8[0x0]
8000980a:	70 17       	ld.w	r7,r8[0x4]
8000980c:	c0 98       	rjmp	8000981e <__swsetup_r+0x4e>
8000980e:	fe c8 bf 66 	sub	r8,pc,-16538
80009812:	10 37       	cp.w	r7,r8
80009814:	c0 51       	brne	8000981e <__swsetup_r+0x4e>
80009816:	e0 68 0a 44 	mov	r8,2628
8000981a:	70 08       	ld.w	r8,r8[0x0]
8000981c:	70 27       	ld.w	r7,r8[0x8]
8000981e:	8e 68       	ld.sh	r8,r7[0xc]
80009820:	ed b8 00 03 	bld	r8,0x3
80009824:	c1 e0       	breq	80009860 <__swsetup_r+0x90>
80009826:	ed b8 00 04 	bld	r8,0x4
8000982a:	c3 e1       	brne	800098a6 <__swsetup_r+0xd6>
8000982c:	ed b8 00 02 	bld	r8,0x2
80009830:	c1 51       	brne	8000985a <__swsetup_r+0x8a>
80009832:	6e db       	ld.w	r11,r7[0x34]
80009834:	58 0b       	cp.w	r11,0
80009836:	c0 a0       	breq	8000984a <__swsetup_r+0x7a>
80009838:	ee c8 ff bc 	sub	r8,r7,-68
8000983c:	10 3b       	cp.w	r11,r8
8000983e:	c0 40       	breq	80009846 <__swsetup_r+0x76>
80009840:	0c 9c       	mov	r12,r6
80009842:	e0 a0 08 2b 	rcall	8000a898 <_free_r>
80009846:	30 08       	mov	r8,0
80009848:	8f d8       	st.w	r7[0x34],r8
8000984a:	8e 68       	ld.sh	r8,r7[0xc]
8000984c:	e0 18 ff db 	andl	r8,0xffdb
80009850:	ae 68       	st.h	r7[0xc],r8
80009852:	30 08       	mov	r8,0
80009854:	8f 18       	st.w	r7[0x4],r8
80009856:	6e 48       	ld.w	r8,r7[0x10]
80009858:	8f 08       	st.w	r7[0x0],r8
8000985a:	8e 68       	ld.sh	r8,r7[0xc]
8000985c:	a3 b8       	sbr	r8,0x3
8000985e:	ae 68       	st.h	r7[0xc],r8
80009860:	6e 48       	ld.w	r8,r7[0x10]
80009862:	58 08       	cp.w	r8,0
80009864:	c0 b1       	brne	8000987a <__swsetup_r+0xaa>
80009866:	8e 68       	ld.sh	r8,r7[0xc]
80009868:	e2 18 02 80 	andl	r8,0x280,COH
8000986c:	e0 48 02 00 	cp.w	r8,512
80009870:	c0 50       	breq	8000987a <__swsetup_r+0xaa>
80009872:	0c 9c       	mov	r12,r6
80009874:	0e 9b       	mov	r11,r7
80009876:	e0 a0 0a 4b 	rcall	8000ad0c <__smakebuf_r>
8000987a:	8e 69       	ld.sh	r9,r7[0xc]
8000987c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009880:	c0 70       	breq	8000988e <__swsetup_r+0xbe>
80009882:	30 08       	mov	r8,0
80009884:	8f 28       	st.w	r7[0x8],r8
80009886:	6e 58       	ld.w	r8,r7[0x14]
80009888:	5c 38       	neg	r8
8000988a:	8f 68       	st.w	r7[0x18],r8
8000988c:	c0 68       	rjmp	80009898 <__swsetup_r+0xc8>
8000988e:	ed b9 00 01 	bld	r9,0x1
80009892:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009896:	8f 28       	st.w	r7[0x8],r8
80009898:	6e 48       	ld.w	r8,r7[0x10]
8000989a:	58 08       	cp.w	r8,0
8000989c:	c0 61       	brne	800098a8 <__swsetup_r+0xd8>
8000989e:	8e 68       	ld.sh	r8,r7[0xc]
800098a0:	ed b8 00 07 	bld	r8,0x7
800098a4:	c0 21       	brne	800098a8 <__swsetup_r+0xd8>
800098a6:	dc 2a       	popm	r4-r7,pc,r12=-1
800098a8:	d8 2a       	popm	r4-r7,pc,r12=0
800098aa:	d7 03       	nop

800098ac <quorem>:
800098ac:	d4 31       	pushm	r0-r7,lr
800098ae:	20 2d       	sub	sp,8
800098b0:	18 97       	mov	r7,r12
800098b2:	78 48       	ld.w	r8,r12[0x10]
800098b4:	76 46       	ld.w	r6,r11[0x10]
800098b6:	0c 38       	cp.w	r8,r6
800098b8:	c0 34       	brge	800098be <quorem+0x12>
800098ba:	30 0c       	mov	r12,0
800098bc:	c8 58       	rjmp	800099c6 <quorem+0x11a>
800098be:	ec c2 ff fc 	sub	r2,r6,-4
800098c2:	f6 c3 ff ec 	sub	r3,r11,-20
800098c6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800098ca:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800098ce:	2f f9       	sub	r9,-1
800098d0:	20 16       	sub	r6,1
800098d2:	f8 09 0d 08 	divu	r8,r12,r9
800098d6:	f6 02 00 22 	add	r2,r11,r2<<0x2
800098da:	ee c4 ff ec 	sub	r4,r7,-20
800098de:	10 95       	mov	r5,r8
800098e0:	58 08       	cp.w	r8,0
800098e2:	c4 10       	breq	80009964 <quorem+0xb8>
800098e4:	30 09       	mov	r9,0
800098e6:	06 9a       	mov	r10,r3
800098e8:	08 98       	mov	r8,r4
800098ea:	12 91       	mov	r1,r9
800098ec:	50 0b       	stdsp	sp[0x0],r11
800098ee:	70 0e       	ld.w	lr,r8[0x0]
800098f0:	b1 8e       	lsr	lr,0x10
800098f2:	50 1e       	stdsp	sp[0x4],lr
800098f4:	15 0e       	ld.w	lr,r10++
800098f6:	fc 00 16 10 	lsr	r0,lr,0x10
800098fa:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800098fe:	ea 0e 03 41 	mac	r1,r5,lr
80009902:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009906:	b1 81       	lsr	r1,0x10
80009908:	40 1b       	lddsp	r11,sp[0x4]
8000990a:	ea 00 02 40 	mul	r0,r5,r0
8000990e:	e2 00 00 00 	add	r0,r1,r0
80009912:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009916:	02 1b       	sub	r11,r1
80009918:	50 1b       	stdsp	sp[0x4],r11
8000991a:	70 0b       	ld.w	r11,r8[0x0]
8000991c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009920:	02 09       	add	r9,r1
80009922:	f2 0e 01 0e 	sub	lr,r9,lr
80009926:	b0 1e       	st.h	r8[0x2],lr
80009928:	fc 09 14 10 	asr	r9,lr,0x10
8000992c:	40 1e       	lddsp	lr,sp[0x4]
8000992e:	fc 09 00 09 	add	r9,lr,r9
80009932:	b0 09       	st.h	r8[0x0],r9
80009934:	e0 01 16 10 	lsr	r1,r0,0x10
80009938:	2f c8       	sub	r8,-4
8000993a:	b1 49       	asr	r9,0x10
8000993c:	04 3a       	cp.w	r10,r2
8000993e:	fe 98 ff d8 	brls	800098ee <quorem+0x42>
80009942:	40 0b       	lddsp	r11,sp[0x0]
80009944:	58 0c       	cp.w	r12,0
80009946:	c0 f1       	brne	80009964 <quorem+0xb8>
80009948:	ec c8 ff fb 	sub	r8,r6,-5
8000994c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009950:	c0 28       	rjmp	80009954 <quorem+0xa8>
80009952:	20 16       	sub	r6,1
80009954:	20 48       	sub	r8,4
80009956:	08 38       	cp.w	r8,r4
80009958:	e0 88 00 05 	brls	80009962 <quorem+0xb6>
8000995c:	70 09       	ld.w	r9,r8[0x0]
8000995e:	58 09       	cp.w	r9,0
80009960:	cf 90       	breq	80009952 <quorem+0xa6>
80009962:	8f 46       	st.w	r7[0x10],r6
80009964:	0e 9c       	mov	r12,r7
80009966:	e0 a0 0a d2 	rcall	8000af0a <__mcmp>
8000996a:	c2 d5       	brlt	800099c4 <quorem+0x118>
8000996c:	2f f5       	sub	r5,-1
8000996e:	08 98       	mov	r8,r4
80009970:	30 09       	mov	r9,0
80009972:	07 0b       	ld.w	r11,r3++
80009974:	f6 0a 16 10 	lsr	r10,r11,0x10
80009978:	70 0c       	ld.w	r12,r8[0x0]
8000997a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000997e:	f8 0e 16 10 	lsr	lr,r12,0x10
80009982:	14 1e       	sub	lr,r10
80009984:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009988:	16 1a       	sub	r10,r11
8000998a:	12 0a       	add	r10,r9
8000998c:	b0 1a       	st.h	r8[0x2],r10
8000998e:	b1 4a       	asr	r10,0x10
80009990:	fc 0a 00 09 	add	r9,lr,r10
80009994:	b0 09       	st.h	r8[0x0],r9
80009996:	2f c8       	sub	r8,-4
80009998:	b1 49       	asr	r9,0x10
8000999a:	04 33       	cp.w	r3,r2
8000999c:	fe 98 ff eb 	brls	80009972 <quorem+0xc6>
800099a0:	ec c8 ff fb 	sub	r8,r6,-5
800099a4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800099a8:	58 09       	cp.w	r9,0
800099aa:	c0 d1       	brne	800099c4 <quorem+0x118>
800099ac:	ee 08 00 28 	add	r8,r7,r8<<0x2
800099b0:	c0 28       	rjmp	800099b4 <quorem+0x108>
800099b2:	20 16       	sub	r6,1
800099b4:	20 48       	sub	r8,4
800099b6:	08 38       	cp.w	r8,r4
800099b8:	e0 88 00 05 	brls	800099c2 <quorem+0x116>
800099bc:	70 09       	ld.w	r9,r8[0x0]
800099be:	58 09       	cp.w	r9,0
800099c0:	cf 90       	breq	800099b2 <quorem+0x106>
800099c2:	8f 46       	st.w	r7[0x10],r6
800099c4:	0a 9c       	mov	r12,r5
800099c6:	2f ed       	sub	sp,-8
800099c8:	d8 32       	popm	r0-r7,pc
800099ca:	d7 03       	nop

800099cc <_dtoa_r>:
800099cc:	d4 31       	pushm	r0-r7,lr
800099ce:	21 ad       	sub	sp,104
800099d0:	fa c4 ff 74 	sub	r4,sp,-140
800099d4:	18 97       	mov	r7,r12
800099d6:	16 95       	mov	r5,r11
800099d8:	68 2c       	ld.w	r12,r4[0x8]
800099da:	50 c9       	stdsp	sp[0x30],r9
800099dc:	68 16       	ld.w	r6,r4[0x4]
800099de:	68 09       	ld.w	r9,r4[0x0]
800099e0:	50 e8       	stdsp	sp[0x38],r8
800099e2:	14 94       	mov	r4,r10
800099e4:	51 2c       	stdsp	sp[0x48],r12
800099e6:	fa e5 00 08 	st.d	sp[8],r4
800099ea:	51 59       	stdsp	sp[0x54],r9
800099ec:	6e 95       	ld.w	r5,r7[0x24]
800099ee:	58 05       	cp.w	r5,0
800099f0:	c0 91       	brne	80009a02 <_dtoa_r+0x36>
800099f2:	31 0c       	mov	r12,16
800099f4:	fe b0 e8 e8 	rcall	80006bc4 <malloc>
800099f8:	99 35       	st.w	r12[0xc],r5
800099fa:	8f 9c       	st.w	r7[0x24],r12
800099fc:	99 15       	st.w	r12[0x4],r5
800099fe:	99 25       	st.w	r12[0x8],r5
80009a00:	99 05       	st.w	r12[0x0],r5
80009a02:	6e 99       	ld.w	r9,r7[0x24]
80009a04:	72 08       	ld.w	r8,r9[0x0]
80009a06:	58 08       	cp.w	r8,0
80009a08:	c0 f0       	breq	80009a26 <_dtoa_r+0x5a>
80009a0a:	72 1a       	ld.w	r10,r9[0x4]
80009a0c:	91 1a       	st.w	r8[0x4],r10
80009a0e:	30 1a       	mov	r10,1
80009a10:	72 19       	ld.w	r9,r9[0x4]
80009a12:	f4 09 09 49 	lsl	r9,r10,r9
80009a16:	10 9b       	mov	r11,r8
80009a18:	91 29       	st.w	r8[0x8],r9
80009a1a:	0e 9c       	mov	r12,r7
80009a1c:	e0 a0 0a 90 	rcall	8000af3c <_Bfree>
80009a20:	6e 98       	ld.w	r8,r7[0x24]
80009a22:	30 09       	mov	r9,0
80009a24:	91 09       	st.w	r8[0x0],r9
80009a26:	40 28       	lddsp	r8,sp[0x8]
80009a28:	10 94       	mov	r4,r8
80009a2a:	58 08       	cp.w	r8,0
80009a2c:	c0 64       	brge	80009a38 <_dtoa_r+0x6c>
80009a2e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009a32:	50 28       	stdsp	sp[0x8],r8
80009a34:	30 18       	mov	r8,1
80009a36:	c0 28       	rjmp	80009a3a <_dtoa_r+0x6e>
80009a38:	30 08       	mov	r8,0
80009a3a:	8d 08       	st.w	r6[0x0],r8
80009a3c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009a40:	40 26       	lddsp	r6,sp[0x8]
80009a42:	0c 98       	mov	r8,r6
80009a44:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009a48:	18 38       	cp.w	r8,r12
80009a4a:	c2 01       	brne	80009a8a <_dtoa_r+0xbe>
80009a4c:	e0 68 27 0f 	mov	r8,9999
80009a50:	41 5b       	lddsp	r11,sp[0x54]
80009a52:	97 08       	st.w	r11[0x0],r8
80009a54:	40 3a       	lddsp	r10,sp[0xc]
80009a56:	58 0a       	cp.w	r10,0
80009a58:	c0 71       	brne	80009a66 <_dtoa_r+0x9a>
80009a5a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009a5e:	c0 41       	brne	80009a66 <_dtoa_r+0x9a>
80009a60:	fe cc c2 08 	sub	r12,pc,-15864
80009a64:	c0 38       	rjmp	80009a6a <_dtoa_r+0x9e>
80009a66:	fe cc c2 02 	sub	r12,pc,-15870
80009a6a:	41 29       	lddsp	r9,sp[0x48]
80009a6c:	58 09       	cp.w	r9,0
80009a6e:	e0 80 05 9a 	breq	8000a5a2 <_dtoa_r+0xbd6>
80009a72:	f8 c8 ff fd 	sub	r8,r12,-3
80009a76:	f8 c9 ff f8 	sub	r9,r12,-8
80009a7a:	11 8b       	ld.ub	r11,r8[0x0]
80009a7c:	30 0a       	mov	r10,0
80009a7e:	41 25       	lddsp	r5,sp[0x48]
80009a80:	f4 0b 18 00 	cp.b	r11,r10
80009a84:	f2 08 17 10 	movne	r8,r9
80009a88:	c1 68       	rjmp	80009ab4 <_dtoa_r+0xe8>
80009a8a:	fa ea 00 08 	ld.d	r10,sp[8]
80009a8e:	30 08       	mov	r8,0
80009a90:	fa eb 00 3c 	st.d	sp[60],r10
80009a94:	30 09       	mov	r9,0
80009a96:	e0 a0 10 c2 	rcall	8000bc1a <__avr32_f64_cmp_eq>
80009a9a:	c1 00       	breq	80009aba <_dtoa_r+0xee>
80009a9c:	30 18       	mov	r8,1
80009a9e:	41 5a       	lddsp	r10,sp[0x54]
80009aa0:	95 08       	st.w	r10[0x0],r8
80009aa2:	fe cc c3 6e 	sub	r12,pc,-15506
80009aa6:	41 29       	lddsp	r9,sp[0x48]
80009aa8:	f8 08 00 08 	add	r8,r12,r8
80009aac:	58 09       	cp.w	r9,0
80009aae:	e0 80 05 7a 	breq	8000a5a2 <_dtoa_r+0xbd6>
80009ab2:	12 95       	mov	r5,r9
80009ab4:	8b 08       	st.w	r5[0x0],r8
80009ab6:	e0 8f 05 76 	bral	8000a5a2 <_dtoa_r+0xbd6>
80009aba:	fa c8 ff 9c 	sub	r8,sp,-100
80009abe:	fa c9 ff a0 	sub	r9,sp,-96
80009ac2:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ac6:	0e 9c       	mov	r12,r7
80009ac8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009acc:	e0 a0 0a 8a 	rcall	8000afe0 <__d2b>
80009ad0:	18 93       	mov	r3,r12
80009ad2:	58 05       	cp.w	r5,0
80009ad4:	c0 d0       	breq	80009aee <_dtoa_r+0x122>
80009ad6:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ada:	30 04       	mov	r4,0
80009adc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009ae0:	ea c5 03 ff 	sub	r5,r5,1023
80009ae4:	10 9b       	mov	r11,r8
80009ae6:	51 74       	stdsp	sp[0x5c],r4
80009ae8:	ea 1b 3f f0 	orh	r11,0x3ff0
80009aec:	c2 58       	rjmp	80009b36 <_dtoa_r+0x16a>
80009aee:	41 88       	lddsp	r8,sp[0x60]
80009af0:	41 9c       	lddsp	r12,sp[0x64]
80009af2:	10 0c       	add	r12,r8
80009af4:	f8 c5 fb ce 	sub	r5,r12,-1074
80009af8:	e0 45 00 20 	cp.w	r5,32
80009afc:	e0 8a 00 0e 	brle	80009b18 <_dtoa_r+0x14c>
80009b00:	f8 cc fb ee 	sub	r12,r12,-1042
80009b04:	40 3b       	lddsp	r11,sp[0xc]
80009b06:	ea 08 11 40 	rsub	r8,r5,64
80009b0a:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009b0e:	ec 08 09 46 	lsl	r6,r6,r8
80009b12:	0c 4c       	or	r12,r6
80009b14:	c0 78       	rjmp	80009b22 <_dtoa_r+0x156>
80009b16:	d7 03       	nop
80009b18:	ea 0c 11 20 	rsub	r12,r5,32
80009b1c:	40 3a       	lddsp	r10,sp[0xc]
80009b1e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009b22:	e0 a0 10 08 	rcall	8000bb32 <__avr32_u32_to_f64>
80009b26:	fc 18 fe 10 	movh	r8,0xfe10
80009b2a:	30 19       	mov	r9,1
80009b2c:	ea c5 04 33 	sub	r5,r5,1075
80009b30:	f0 0b 00 0b 	add	r11,r8,r11
80009b34:	51 79       	stdsp	sp[0x5c],r9
80009b36:	30 08       	mov	r8,0
80009b38:	fc 19 3f f8 	movh	r9,0x3ff8
80009b3c:	e0 a0 0e 90 	rcall	8000b85c <__avr32_f64_sub>
80009b40:	e0 68 43 61 	mov	r8,17249
80009b44:	ea 18 63 6f 	orh	r8,0x636f
80009b48:	e0 69 87 a7 	mov	r9,34727
80009b4c:	ea 19 3f d2 	orh	r9,0x3fd2
80009b50:	e0 a0 0d 9a 	rcall	8000b684 <__avr32_f64_mul>
80009b54:	e0 68 c8 b3 	mov	r8,51379
80009b58:	ea 18 8b 60 	orh	r8,0x8b60
80009b5c:	e0 69 8a 28 	mov	r9,35368
80009b60:	ea 19 3f c6 	orh	r9,0x3fc6
80009b64:	e0 a0 0f 4a 	rcall	8000b9f8 <__avr32_f64_add>
80009b68:	0a 9c       	mov	r12,r5
80009b6a:	14 90       	mov	r0,r10
80009b6c:	16 91       	mov	r1,r11
80009b6e:	e0 a0 0f e6 	rcall	8000bb3a <__avr32_s32_to_f64>
80009b72:	e0 68 79 fb 	mov	r8,31227
80009b76:	ea 18 50 9f 	orh	r8,0x509f
80009b7a:	e0 69 44 13 	mov	r9,17427
80009b7e:	ea 19 3f d3 	orh	r9,0x3fd3
80009b82:	e0 a0 0d 81 	rcall	8000b684 <__avr32_f64_mul>
80009b86:	14 98       	mov	r8,r10
80009b88:	16 99       	mov	r9,r11
80009b8a:	00 9a       	mov	r10,r0
80009b8c:	02 9b       	mov	r11,r1
80009b8e:	e0 a0 0f 35 	rcall	8000b9f8 <__avr32_f64_add>
80009b92:	14 90       	mov	r0,r10
80009b94:	16 91       	mov	r1,r11
80009b96:	e0 a0 0f bb 	rcall	8000bb0c <__avr32_f64_to_s32>
80009b9a:	30 08       	mov	r8,0
80009b9c:	18 96       	mov	r6,r12
80009b9e:	30 09       	mov	r9,0
80009ba0:	00 9a       	mov	r10,r0
80009ba2:	02 9b       	mov	r11,r1
80009ba4:	e0 a0 10 82 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009ba8:	c0 c0       	breq	80009bc0 <_dtoa_r+0x1f4>
80009baa:	0c 9c       	mov	r12,r6
80009bac:	e0 a0 0f c7 	rcall	8000bb3a <__avr32_s32_to_f64>
80009bb0:	14 98       	mov	r8,r10
80009bb2:	16 99       	mov	r9,r11
80009bb4:	00 9a       	mov	r10,r0
80009bb6:	02 9b       	mov	r11,r1
80009bb8:	e0 a0 10 31 	rcall	8000bc1a <__avr32_f64_cmp_eq>
80009bbc:	f7 b6 00 01 	subeq	r6,1
80009bc0:	59 66       	cp.w	r6,22
80009bc2:	e0 88 00 05 	brls	80009bcc <_dtoa_r+0x200>
80009bc6:	30 18       	mov	r8,1
80009bc8:	51 48       	stdsp	sp[0x50],r8
80009bca:	c1 38       	rjmp	80009bf0 <_dtoa_r+0x224>
80009bcc:	fe c8 c2 b4 	sub	r8,pc,-15692
80009bd0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bd4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009bd8:	e0 a0 10 68 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009bdc:	f9 b4 00 00 	moveq	r4,0
80009be0:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009be4:	f7 b6 01 01 	subne	r6,1
80009be8:	f9 bc 01 00 	movne	r12,0
80009bec:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009bf0:	41 90       	lddsp	r0,sp[0x64]
80009bf2:	20 10       	sub	r0,1
80009bf4:	0a 10       	sub	r0,r5
80009bf6:	c0 46       	brmi	80009bfe <_dtoa_r+0x232>
80009bf8:	50 40       	stdsp	sp[0x10],r0
80009bfa:	30 00       	mov	r0,0
80009bfc:	c0 48       	rjmp	80009c04 <_dtoa_r+0x238>
80009bfe:	30 0b       	mov	r11,0
80009c00:	5c 30       	neg	r0
80009c02:	50 4b       	stdsp	sp[0x10],r11
80009c04:	ec 02 11 00 	rsub	r2,r6,0
80009c08:	58 06       	cp.w	r6,0
80009c0a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009c0e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009c12:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009c16:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009c1a:	f9 b2 04 00 	movge	r2,0
80009c1e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009c22:	f9 b9 05 00 	movlt	r9,0
80009c26:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009c2a:	40 c8       	lddsp	r8,sp[0x30]
80009c2c:	58 98       	cp.w	r8,9
80009c2e:	e0 8b 00 20 	brhi	80009c6e <_dtoa_r+0x2a2>
80009c32:	58 58       	cp.w	r8,5
80009c34:	f9 b4 0a 01 	movle	r4,1
80009c38:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009c3c:	f7 b5 09 04 	subgt	r5,4
80009c40:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009c44:	f9 b4 09 00 	movgt	r4,0
80009c48:	40 cc       	lddsp	r12,sp[0x30]
80009c4a:	58 3c       	cp.w	r12,3
80009c4c:	c2 d0       	breq	80009ca6 <_dtoa_r+0x2da>
80009c4e:	e0 89 00 05 	brgt	80009c58 <_dtoa_r+0x28c>
80009c52:	58 2c       	cp.w	r12,2
80009c54:	c1 01       	brne	80009c74 <_dtoa_r+0x2a8>
80009c56:	c1 88       	rjmp	80009c86 <_dtoa_r+0x2ba>
80009c58:	40 cb       	lddsp	r11,sp[0x30]
80009c5a:	58 4b       	cp.w	r11,4
80009c5c:	c0 60       	breq	80009c68 <_dtoa_r+0x29c>
80009c5e:	58 5b       	cp.w	r11,5
80009c60:	c0 a1       	brne	80009c74 <_dtoa_r+0x2a8>
80009c62:	30 1a       	mov	r10,1
80009c64:	50 da       	stdsp	sp[0x34],r10
80009c66:	c2 28       	rjmp	80009caa <_dtoa_r+0x2de>
80009c68:	30 19       	mov	r9,1
80009c6a:	50 d9       	stdsp	sp[0x34],r9
80009c6c:	c0 f8       	rjmp	80009c8a <_dtoa_r+0x2be>
80009c6e:	30 08       	mov	r8,0
80009c70:	30 14       	mov	r4,1
80009c72:	50 c8       	stdsp	sp[0x30],r8
80009c74:	3f f5       	mov	r5,-1
80009c76:	30 1c       	mov	r12,1
80009c78:	30 0b       	mov	r11,0
80009c7a:	50 95       	stdsp	sp[0x24],r5
80009c7c:	50 dc       	stdsp	sp[0x34],r12
80009c7e:	0a 91       	mov	r1,r5
80009c80:	31 28       	mov	r8,18
80009c82:	50 eb       	stdsp	sp[0x38],r11
80009c84:	c2 08       	rjmp	80009cc4 <_dtoa_r+0x2f8>
80009c86:	30 0a       	mov	r10,0
80009c88:	50 da       	stdsp	sp[0x34],r10
80009c8a:	40 e9       	lddsp	r9,sp[0x38]
80009c8c:	58 09       	cp.w	r9,0
80009c8e:	e0 89 00 07 	brgt	80009c9c <_dtoa_r+0x2d0>
80009c92:	30 18       	mov	r8,1
80009c94:	50 98       	stdsp	sp[0x24],r8
80009c96:	10 91       	mov	r1,r8
80009c98:	50 e8       	stdsp	sp[0x38],r8
80009c9a:	c1 58       	rjmp	80009cc4 <_dtoa_r+0x2f8>
80009c9c:	40 e5       	lddsp	r5,sp[0x38]
80009c9e:	50 95       	stdsp	sp[0x24],r5
80009ca0:	0a 91       	mov	r1,r5
80009ca2:	0a 98       	mov	r8,r5
80009ca4:	c1 08       	rjmp	80009cc4 <_dtoa_r+0x2f8>
80009ca6:	30 0c       	mov	r12,0
80009ca8:	50 dc       	stdsp	sp[0x34],r12
80009caa:	40 eb       	lddsp	r11,sp[0x38]
80009cac:	ec 0b 00 0b 	add	r11,r6,r11
80009cb0:	50 9b       	stdsp	sp[0x24],r11
80009cb2:	16 98       	mov	r8,r11
80009cb4:	2f f8       	sub	r8,-1
80009cb6:	58 08       	cp.w	r8,0
80009cb8:	e0 89 00 05 	brgt	80009cc2 <_dtoa_r+0x2f6>
80009cbc:	10 91       	mov	r1,r8
80009cbe:	30 18       	mov	r8,1
80009cc0:	c0 28       	rjmp	80009cc4 <_dtoa_r+0x2f8>
80009cc2:	10 91       	mov	r1,r8
80009cc4:	30 09       	mov	r9,0
80009cc6:	6e 9a       	ld.w	r10,r7[0x24]
80009cc8:	95 19       	st.w	r10[0x4],r9
80009cca:	30 49       	mov	r9,4
80009ccc:	c0 68       	rjmp	80009cd8 <_dtoa_r+0x30c>
80009cce:	d7 03       	nop
80009cd0:	6a 1a       	ld.w	r10,r5[0x4]
80009cd2:	a1 79       	lsl	r9,0x1
80009cd4:	2f fa       	sub	r10,-1
80009cd6:	8b 1a       	st.w	r5[0x4],r10
80009cd8:	6e 95       	ld.w	r5,r7[0x24]
80009cda:	f2 ca ff ec 	sub	r10,r9,-20
80009cde:	10 3a       	cp.w	r10,r8
80009ce0:	fe 98 ff f8 	brls	80009cd0 <_dtoa_r+0x304>
80009ce4:	6a 1b       	ld.w	r11,r5[0x4]
80009ce6:	0e 9c       	mov	r12,r7
80009ce8:	e0 a0 09 44 	rcall	8000af70 <_Balloc>
80009cec:	58 e1       	cp.w	r1,14
80009cee:	5f 88       	srls	r8
80009cf0:	8b 0c       	st.w	r5[0x0],r12
80009cf2:	f1 e4 00 04 	and	r4,r8,r4
80009cf6:	6e 98       	ld.w	r8,r7[0x24]
80009cf8:	70 08       	ld.w	r8,r8[0x0]
80009cfa:	50 88       	stdsp	sp[0x20],r8
80009cfc:	e0 80 01 82 	breq	8000a000 <_dtoa_r+0x634>
80009d00:	58 06       	cp.w	r6,0
80009d02:	e0 8a 00 43 	brle	80009d88 <_dtoa_r+0x3bc>
80009d06:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009d0a:	fe c8 c3 f2 	sub	r8,pc,-15374
80009d0e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009d12:	fa e5 00 18 	st.d	sp[24],r4
80009d16:	ec 04 14 04 	asr	r4,r6,0x4
80009d1a:	ed b4 00 04 	bld	r4,0x4
80009d1e:	c0 30       	breq	80009d24 <_dtoa_r+0x358>
80009d20:	30 25       	mov	r5,2
80009d22:	c1 08       	rjmp	80009d42 <_dtoa_r+0x376>
80009d24:	fe c8 c3 44 	sub	r8,pc,-15548
80009d28:	f0 e8 00 20 	ld.d	r8,r8[32]
80009d2c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d30:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009d34:	e0 a0 0f ee 	rcall	8000bd10 <__avr32_f64_div>
80009d38:	30 35       	mov	r5,3
80009d3a:	14 98       	mov	r8,r10
80009d3c:	16 99       	mov	r9,r11
80009d3e:	fa e9 00 08 	st.d	sp[8],r8
80009d42:	fe cc c3 62 	sub	r12,pc,-15518
80009d46:	50 a3       	stdsp	sp[0x28],r3
80009d48:	0c 93       	mov	r3,r6
80009d4a:	18 96       	mov	r6,r12
80009d4c:	c0 f8       	rjmp	80009d6a <_dtoa_r+0x39e>
80009d4e:	fa ea 00 18 	ld.d	r10,sp[24]
80009d52:	ed b4 00 00 	bld	r4,0x0
80009d56:	c0 81       	brne	80009d66 <_dtoa_r+0x39a>
80009d58:	ec e8 00 00 	ld.d	r8,r6[0]
80009d5c:	2f f5       	sub	r5,-1
80009d5e:	e0 a0 0c 93 	rcall	8000b684 <__avr32_f64_mul>
80009d62:	fa eb 00 18 	st.d	sp[24],r10
80009d66:	a1 54       	asr	r4,0x1
80009d68:	2f 86       	sub	r6,-8
80009d6a:	58 04       	cp.w	r4,0
80009d6c:	cf 11       	brne	80009d4e <_dtoa_r+0x382>
80009d6e:	fa e8 00 18 	ld.d	r8,sp[24]
80009d72:	fa ea 00 08 	ld.d	r10,sp[8]
80009d76:	06 96       	mov	r6,r3
80009d78:	e0 a0 0f cc 	rcall	8000bd10 <__avr32_f64_div>
80009d7c:	40 a3       	lddsp	r3,sp[0x28]
80009d7e:	14 98       	mov	r8,r10
80009d80:	16 99       	mov	r9,r11
80009d82:	fa e9 00 08 	st.d	sp[8],r8
80009d86:	c2 f8       	rjmp	80009de4 <_dtoa_r+0x418>
80009d88:	ec 08 11 00 	rsub	r8,r6,0
80009d8c:	c0 31       	brne	80009d92 <_dtoa_r+0x3c6>
80009d8e:	30 25       	mov	r5,2
80009d90:	c2 a8       	rjmp	80009de4 <_dtoa_r+0x418>
80009d92:	fe cc c3 b2 	sub	r12,pc,-15438
80009d96:	f0 04 14 04 	asr	r4,r8,0x4
80009d9a:	50 1c       	stdsp	sp[0x4],r12
80009d9c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009da0:	fe c9 c4 88 	sub	r9,pc,-15224
80009da4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009da8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009dac:	e0 a0 0c 6c 	rcall	8000b684 <__avr32_f64_mul>
80009db0:	40 1c       	lddsp	r12,sp[0x4]
80009db2:	50 63       	stdsp	sp[0x18],r3
80009db4:	30 25       	mov	r5,2
80009db6:	0c 93       	mov	r3,r6
80009db8:	fa eb 00 08 	st.d	sp[8],r10
80009dbc:	18 96       	mov	r6,r12
80009dbe:	c0 f8       	rjmp	80009ddc <_dtoa_r+0x410>
80009dc0:	fa ea 00 08 	ld.d	r10,sp[8]
80009dc4:	ed b4 00 00 	bld	r4,0x0
80009dc8:	c0 81       	brne	80009dd8 <_dtoa_r+0x40c>
80009dca:	ec e8 00 00 	ld.d	r8,r6[0]
80009dce:	2f f5       	sub	r5,-1
80009dd0:	e0 a0 0c 5a 	rcall	8000b684 <__avr32_f64_mul>
80009dd4:	fa eb 00 08 	st.d	sp[8],r10
80009dd8:	a1 54       	asr	r4,0x1
80009dda:	2f 86       	sub	r6,-8
80009ddc:	58 04       	cp.w	r4,0
80009dde:	cf 11       	brne	80009dc0 <_dtoa_r+0x3f4>
80009de0:	06 96       	mov	r6,r3
80009de2:	40 63       	lddsp	r3,sp[0x18]
80009de4:	41 4a       	lddsp	r10,sp[0x50]
80009de6:	58 0a       	cp.w	r10,0
80009de8:	c2 a0       	breq	80009e3c <_dtoa_r+0x470>
80009dea:	fa e8 00 08 	ld.d	r8,sp[8]
80009dee:	58 01       	cp.w	r1,0
80009df0:	5f 94       	srgt	r4
80009df2:	fa e9 00 18 	st.d	sp[24],r8
80009df6:	30 08       	mov	r8,0
80009df8:	fc 19 3f f0 	movh	r9,0x3ff0
80009dfc:	fa ea 00 18 	ld.d	r10,sp[24]
80009e00:	e0 a0 0f 54 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009e04:	f9 bc 00 00 	moveq	r12,0
80009e08:	f9 bc 01 01 	movne	r12,1
80009e0c:	e9 ec 00 0c 	and	r12,r4,r12
80009e10:	c1 60       	breq	80009e3c <_dtoa_r+0x470>
80009e12:	40 98       	lddsp	r8,sp[0x24]
80009e14:	58 08       	cp.w	r8,0
80009e16:	e0 8a 00 f1 	brle	80009ff8 <_dtoa_r+0x62c>
80009e1a:	30 08       	mov	r8,0
80009e1c:	fc 19 40 24 	movh	r9,0x4024
80009e20:	ec c4 00 01 	sub	r4,r6,1
80009e24:	fa ea 00 18 	ld.d	r10,sp[24]
80009e28:	2f f5       	sub	r5,-1
80009e2a:	50 64       	stdsp	sp[0x18],r4
80009e2c:	e0 a0 0c 2c 	rcall	8000b684 <__avr32_f64_mul>
80009e30:	40 94       	lddsp	r4,sp[0x24]
80009e32:	14 98       	mov	r8,r10
80009e34:	16 99       	mov	r9,r11
80009e36:	fa e9 00 08 	st.d	sp[8],r8
80009e3a:	c0 38       	rjmp	80009e40 <_dtoa_r+0x474>
80009e3c:	50 66       	stdsp	sp[0x18],r6
80009e3e:	02 94       	mov	r4,r1
80009e40:	0a 9c       	mov	r12,r5
80009e42:	e0 a0 0e 7c 	rcall	8000bb3a <__avr32_s32_to_f64>
80009e46:	fa e8 00 08 	ld.d	r8,sp[8]
80009e4a:	e0 a0 0c 1d 	rcall	8000b684 <__avr32_f64_mul>
80009e4e:	30 08       	mov	r8,0
80009e50:	fc 19 40 1c 	movh	r9,0x401c
80009e54:	e0 a0 0d d2 	rcall	8000b9f8 <__avr32_f64_add>
80009e58:	14 98       	mov	r8,r10
80009e5a:	16 99       	mov	r9,r11
80009e5c:	fa e9 00 28 	st.d	sp[40],r8
80009e60:	fc 18 fc c0 	movh	r8,0xfcc0
80009e64:	40 a5       	lddsp	r5,sp[0x28]
80009e66:	10 05       	add	r5,r8
80009e68:	50 a5       	stdsp	sp[0x28],r5
80009e6a:	58 04       	cp.w	r4,0
80009e6c:	c2 11       	brne	80009eae <_dtoa_r+0x4e2>
80009e6e:	fa ea 00 08 	ld.d	r10,sp[8]
80009e72:	30 08       	mov	r8,0
80009e74:	fc 19 40 14 	movh	r9,0x4014
80009e78:	e0 a0 0c f2 	rcall	8000b85c <__avr32_f64_sub>
80009e7c:	40 bc       	lddsp	r12,sp[0x2c]
80009e7e:	fa eb 00 08 	st.d	sp[8],r10
80009e82:	14 98       	mov	r8,r10
80009e84:	16 99       	mov	r9,r11
80009e86:	18 9a       	mov	r10,r12
80009e88:	0a 9b       	mov	r11,r5
80009e8a:	e0 a0 0f 0f 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009e8e:	e0 81 02 54 	brne	8000a336 <_dtoa_r+0x96a>
80009e92:	0a 98       	mov	r8,r5
80009e94:	40 b9       	lddsp	r9,sp[0x2c]
80009e96:	ee 18 80 00 	eorh	r8,0x8000
80009e9a:	fa ea 00 08 	ld.d	r10,sp[8]
80009e9e:	10 95       	mov	r5,r8
80009ea0:	12 98       	mov	r8,r9
80009ea2:	0a 99       	mov	r9,r5
80009ea4:	e0 a0 0f 02 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009ea8:	e0 81 02 3e 	brne	8000a324 <_dtoa_r+0x958>
80009eac:	ca 68       	rjmp	80009ff8 <_dtoa_r+0x62c>
80009eae:	fe c9 c5 96 	sub	r9,pc,-14954
80009eb2:	e8 c8 00 01 	sub	r8,r4,1
80009eb6:	40 d5       	lddsp	r5,sp[0x34]
80009eb8:	58 05       	cp.w	r5,0
80009eba:	c4 f0       	breq	80009f58 <_dtoa_r+0x58c>
80009ebc:	30 0c       	mov	r12,0
80009ebe:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009ec2:	51 3c       	stdsp	sp[0x4c],r12
80009ec4:	30 0a       	mov	r10,0
80009ec6:	fc 1b 3f e0 	movh	r11,0x3fe0
80009eca:	e0 a0 0f 23 	rcall	8000bd10 <__avr32_f64_div>
80009ece:	fa e8 00 28 	ld.d	r8,sp[40]
80009ed2:	40 85       	lddsp	r5,sp[0x20]
80009ed4:	e0 a0 0c c4 	rcall	8000b85c <__avr32_f64_sub>
80009ed8:	fa eb 00 28 	st.d	sp[40],r10
80009edc:	fa ea 00 08 	ld.d	r10,sp[8]
80009ee0:	e0 a0 0e 16 	rcall	8000bb0c <__avr32_f64_to_s32>
80009ee4:	51 6c       	stdsp	sp[0x58],r12
80009ee6:	e0 a0 0e 2a 	rcall	8000bb3a <__avr32_s32_to_f64>
80009eea:	14 98       	mov	r8,r10
80009eec:	16 99       	mov	r9,r11
80009eee:	fa ea 00 08 	ld.d	r10,sp[8]
80009ef2:	e0 a0 0c b5 	rcall	8000b85c <__avr32_f64_sub>
80009ef6:	fa eb 00 08 	st.d	sp[8],r10
80009efa:	41 68       	lddsp	r8,sp[0x58]
80009efc:	2d 08       	sub	r8,-48
80009efe:	0a c8       	st.b	r5++,r8
80009f00:	41 39       	lddsp	r9,sp[0x4c]
80009f02:	2f f9       	sub	r9,-1
80009f04:	51 39       	stdsp	sp[0x4c],r9
80009f06:	fa e8 00 28 	ld.d	r8,sp[40]
80009f0a:	e0 a0 0e cf 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009f0e:	e0 81 03 39 	brne	8000a580 <_dtoa_r+0xbb4>
80009f12:	fa e8 00 08 	ld.d	r8,sp[8]
80009f16:	30 0a       	mov	r10,0
80009f18:	fc 1b 3f f0 	movh	r11,0x3ff0
80009f1c:	e0 a0 0c a0 	rcall	8000b85c <__avr32_f64_sub>
80009f20:	fa e8 00 28 	ld.d	r8,sp[40]
80009f24:	e0 a0 0e c2 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009f28:	fa ea 00 28 	ld.d	r10,sp[40]
80009f2c:	30 08       	mov	r8,0
80009f2e:	fc 19 40 24 	movh	r9,0x4024
80009f32:	e0 81 00 da 	brne	8000a0e6 <_dtoa_r+0x71a>
80009f36:	41 3c       	lddsp	r12,sp[0x4c]
80009f38:	08 3c       	cp.w	r12,r4
80009f3a:	c5 f4       	brge	80009ff8 <_dtoa_r+0x62c>
80009f3c:	e0 a0 0b a4 	rcall	8000b684 <__avr32_f64_mul>
80009f40:	30 08       	mov	r8,0
80009f42:	fa eb 00 28 	st.d	sp[40],r10
80009f46:	fc 19 40 24 	movh	r9,0x4024
80009f4a:	fa ea 00 08 	ld.d	r10,sp[8]
80009f4e:	e0 a0 0b 9b 	rcall	8000b684 <__avr32_f64_mul>
80009f52:	fa eb 00 08 	st.d	sp[8],r10
80009f56:	cc 3b       	rjmp	80009edc <_dtoa_r+0x510>
80009f58:	40 85       	lddsp	r5,sp[0x20]
80009f5a:	08 05       	add	r5,r4
80009f5c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009f60:	51 35       	stdsp	sp[0x4c],r5
80009f62:	fa e8 00 28 	ld.d	r8,sp[40]
80009f66:	40 85       	lddsp	r5,sp[0x20]
80009f68:	e0 a0 0b 8e 	rcall	8000b684 <__avr32_f64_mul>
80009f6c:	fa eb 00 28 	st.d	sp[40],r10
80009f70:	fa ea 00 08 	ld.d	r10,sp[8]
80009f74:	e0 a0 0d cc 	rcall	8000bb0c <__avr32_f64_to_s32>
80009f78:	51 6c       	stdsp	sp[0x58],r12
80009f7a:	e0 a0 0d e0 	rcall	8000bb3a <__avr32_s32_to_f64>
80009f7e:	14 98       	mov	r8,r10
80009f80:	16 99       	mov	r9,r11
80009f82:	fa ea 00 08 	ld.d	r10,sp[8]
80009f86:	e0 a0 0c 6b 	rcall	8000b85c <__avr32_f64_sub>
80009f8a:	fa eb 00 08 	st.d	sp[8],r10
80009f8e:	41 68       	lddsp	r8,sp[0x58]
80009f90:	2d 08       	sub	r8,-48
80009f92:	0a c8       	st.b	r5++,r8
80009f94:	41 3c       	lddsp	r12,sp[0x4c]
80009f96:	18 35       	cp.w	r5,r12
80009f98:	c2 81       	brne	80009fe8 <_dtoa_r+0x61c>
80009f9a:	30 08       	mov	r8,0
80009f9c:	fc 19 3f e0 	movh	r9,0x3fe0
80009fa0:	fa ea 00 28 	ld.d	r10,sp[40]
80009fa4:	e0 a0 0d 2a 	rcall	8000b9f8 <__avr32_f64_add>
80009fa8:	40 85       	lddsp	r5,sp[0x20]
80009faa:	fa e8 00 08 	ld.d	r8,sp[8]
80009fae:	08 05       	add	r5,r4
80009fb0:	e0 a0 0e 7c 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009fb4:	e0 81 00 99 	brne	8000a0e6 <_dtoa_r+0x71a>
80009fb8:	fa e8 00 28 	ld.d	r8,sp[40]
80009fbc:	30 0a       	mov	r10,0
80009fbe:	fc 1b 3f e0 	movh	r11,0x3fe0
80009fc2:	e0 a0 0c 4d 	rcall	8000b85c <__avr32_f64_sub>
80009fc6:	14 98       	mov	r8,r10
80009fc8:	16 99       	mov	r9,r11
80009fca:	fa ea 00 08 	ld.d	r10,sp[8]
80009fce:	e0 a0 0e 6d 	rcall	8000bca8 <__avr32_f64_cmp_lt>
80009fd2:	c1 30       	breq	80009ff8 <_dtoa_r+0x62c>
80009fd4:	33 09       	mov	r9,48
80009fd6:	0a 98       	mov	r8,r5
80009fd8:	11 7a       	ld.ub	r10,--r8
80009fda:	f2 0a 18 00 	cp.b	r10,r9
80009fde:	e0 81 02 d1 	brne	8000a580 <_dtoa_r+0xbb4>
80009fe2:	10 95       	mov	r5,r8
80009fe4:	cf 9b       	rjmp	80009fd6 <_dtoa_r+0x60a>
80009fe6:	d7 03       	nop
80009fe8:	30 08       	mov	r8,0
80009fea:	fc 19 40 24 	movh	r9,0x4024
80009fee:	e0 a0 0b 4b 	rcall	8000b684 <__avr32_f64_mul>
80009ff2:	fa eb 00 08 	st.d	sp[8],r10
80009ff6:	cb db       	rjmp	80009f70 <_dtoa_r+0x5a4>
80009ff8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ffc:	fa eb 00 08 	st.d	sp[8],r10
8000a000:	58 e6       	cp.w	r6,14
8000a002:	5f ab       	srle	r11
8000a004:	41 8a       	lddsp	r10,sp[0x60]
8000a006:	30 08       	mov	r8,0
8000a008:	f4 09 11 ff 	rsub	r9,r10,-1
8000a00c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a010:	f0 09 18 00 	cp.b	r9,r8
8000a014:	e0 80 00 82 	breq	8000a118 <_dtoa_r+0x74c>
8000a018:	40 ea       	lddsp	r10,sp[0x38]
8000a01a:	58 01       	cp.w	r1,0
8000a01c:	5f a9       	srle	r9
8000a01e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a022:	fe ca c7 0a 	sub	r10,pc,-14582
8000a026:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a02a:	fa e5 00 10 	st.d	sp[16],r4
8000a02e:	f0 09 18 00 	cp.b	r9,r8
8000a032:	c1 40       	breq	8000a05a <_dtoa_r+0x68e>
8000a034:	58 01       	cp.w	r1,0
8000a036:	e0 81 01 77 	brne	8000a324 <_dtoa_r+0x958>
8000a03a:	30 08       	mov	r8,0
8000a03c:	fc 19 40 14 	movh	r9,0x4014
8000a040:	08 9a       	mov	r10,r4
8000a042:	0a 9b       	mov	r11,r5
8000a044:	e0 a0 0b 20 	rcall	8000b684 <__avr32_f64_mul>
8000a048:	fa e8 00 08 	ld.d	r8,sp[8]
8000a04c:	e0 a0 0d fa 	rcall	8000bc40 <__avr32_f64_cmp_ge>
8000a050:	e0 81 01 6a 	brne	8000a324 <_dtoa_r+0x958>
8000a054:	02 92       	mov	r2,r1
8000a056:	e0 8f 01 72 	bral	8000a33a <_dtoa_r+0x96e>
8000a05a:	40 85       	lddsp	r5,sp[0x20]
8000a05c:	30 14       	mov	r4,1
8000a05e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a062:	fa ea 00 08 	ld.d	r10,sp[8]
8000a066:	e0 a0 0e 55 	rcall	8000bd10 <__avr32_f64_div>
8000a06a:	e0 a0 0d 51 	rcall	8000bb0c <__avr32_f64_to_s32>
8000a06e:	18 92       	mov	r2,r12
8000a070:	e0 a0 0d 65 	rcall	8000bb3a <__avr32_s32_to_f64>
8000a074:	fa e8 00 10 	ld.d	r8,sp[16]
8000a078:	e0 a0 0b 06 	rcall	8000b684 <__avr32_f64_mul>
8000a07c:	14 98       	mov	r8,r10
8000a07e:	16 99       	mov	r9,r11
8000a080:	fa ea 00 08 	ld.d	r10,sp[8]
8000a084:	e0 a0 0b ec 	rcall	8000b85c <__avr32_f64_sub>
8000a088:	fa eb 00 08 	st.d	sp[8],r10
8000a08c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a090:	0a c8       	st.b	r5++,r8
8000a092:	fc 19 40 24 	movh	r9,0x4024
8000a096:	30 08       	mov	r8,0
8000a098:	02 34       	cp.w	r4,r1
8000a09a:	c3 31       	brne	8000a100 <_dtoa_r+0x734>
8000a09c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0a0:	e0 a0 0c ac 	rcall	8000b9f8 <__avr32_f64_add>
8000a0a4:	16 91       	mov	r1,r11
8000a0a6:	14 90       	mov	r0,r10
8000a0a8:	14 98       	mov	r8,r10
8000a0aa:	02 99       	mov	r9,r1
8000a0ac:	fa ea 00 10 	ld.d	r10,sp[16]
8000a0b0:	e0 a0 0d fc 	rcall	8000bca8 <__avr32_f64_cmp_lt>
8000a0b4:	c1 a1       	brne	8000a0e8 <_dtoa_r+0x71c>
8000a0b6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a0ba:	00 9a       	mov	r10,r0
8000a0bc:	02 9b       	mov	r11,r1
8000a0be:	e0 a0 0d ae 	rcall	8000bc1a <__avr32_f64_cmp_eq>
8000a0c2:	e0 80 02 5e 	breq	8000a57e <_dtoa_r+0xbb2>
8000a0c6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a0ca:	c0 f1       	brne	8000a0e8 <_dtoa_r+0x71c>
8000a0cc:	e0 8f 02 59 	bral	8000a57e <_dtoa_r+0xbb2>
8000a0d0:	40 8a       	lddsp	r10,sp[0x20]
8000a0d2:	14 38       	cp.w	r8,r10
8000a0d4:	c0 30       	breq	8000a0da <_dtoa_r+0x70e>
8000a0d6:	10 95       	mov	r5,r8
8000a0d8:	c0 98       	rjmp	8000a0ea <_dtoa_r+0x71e>
8000a0da:	33 08       	mov	r8,48
8000a0dc:	40 89       	lddsp	r9,sp[0x20]
8000a0de:	2f f6       	sub	r6,-1
8000a0e0:	b2 88       	st.b	r9[0x0],r8
8000a0e2:	40 88       	lddsp	r8,sp[0x20]
8000a0e4:	c0 88       	rjmp	8000a0f4 <_dtoa_r+0x728>
8000a0e6:	40 66       	lddsp	r6,sp[0x18]
8000a0e8:	33 99       	mov	r9,57
8000a0ea:	0a 98       	mov	r8,r5
8000a0ec:	11 7a       	ld.ub	r10,--r8
8000a0ee:	f2 0a 18 00 	cp.b	r10,r9
8000a0f2:	ce f0       	breq	8000a0d0 <_dtoa_r+0x704>
8000a0f4:	50 66       	stdsp	sp[0x18],r6
8000a0f6:	11 89       	ld.ub	r9,r8[0x0]
8000a0f8:	2f f9       	sub	r9,-1
8000a0fa:	b0 89       	st.b	r8[0x0],r9
8000a0fc:	e0 8f 02 42 	bral	8000a580 <_dtoa_r+0xbb4>
8000a100:	e0 a0 0a c2 	rcall	8000b684 <__avr32_f64_mul>
8000a104:	2f f4       	sub	r4,-1
8000a106:	fa eb 00 08 	st.d	sp[8],r10
8000a10a:	30 08       	mov	r8,0
8000a10c:	30 09       	mov	r9,0
8000a10e:	e0 a0 0d 86 	rcall	8000bc1a <__avr32_f64_cmp_eq>
8000a112:	ca 60       	breq	8000a05e <_dtoa_r+0x692>
8000a114:	e0 8f 02 35 	bral	8000a57e <_dtoa_r+0xbb2>
8000a118:	40 d8       	lddsp	r8,sp[0x34]
8000a11a:	58 08       	cp.w	r8,0
8000a11c:	c0 51       	brne	8000a126 <_dtoa_r+0x75a>
8000a11e:	04 98       	mov	r8,r2
8000a120:	00 95       	mov	r5,r0
8000a122:	40 d4       	lddsp	r4,sp[0x34]
8000a124:	c3 78       	rjmp	8000a192 <_dtoa_r+0x7c6>
8000a126:	40 c5       	lddsp	r5,sp[0x30]
8000a128:	58 15       	cp.w	r5,1
8000a12a:	e0 89 00 0f 	brgt	8000a148 <_dtoa_r+0x77c>
8000a12e:	41 74       	lddsp	r4,sp[0x5c]
8000a130:	58 04       	cp.w	r4,0
8000a132:	c0 40       	breq	8000a13a <_dtoa_r+0x76e>
8000a134:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a138:	c0 48       	rjmp	8000a140 <_dtoa_r+0x774>
8000a13a:	41 99       	lddsp	r9,sp[0x64]
8000a13c:	f2 09 11 36 	rsub	r9,r9,54
8000a140:	04 98       	mov	r8,r2
8000a142:	00 95       	mov	r5,r0
8000a144:	c1 c8       	rjmp	8000a17c <_dtoa_r+0x7b0>
8000a146:	d7 03       	nop
8000a148:	e2 c8 00 01 	sub	r8,r1,1
8000a14c:	58 01       	cp.w	r1,0
8000a14e:	e0 05 17 40 	movge	r5,r0
8000a152:	e2 09 17 40 	movge	r9,r1
8000a156:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a15a:	f9 b9 05 00 	movlt	r9,0
8000a15e:	10 32       	cp.w	r2,r8
8000a160:	e5 d8 e4 18 	subge	r8,r2,r8
8000a164:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a168:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a16c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a170:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a174:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a178:	f9 b8 05 00 	movlt	r8,0
8000a17c:	40 4b       	lddsp	r11,sp[0x10]
8000a17e:	12 0b       	add	r11,r9
8000a180:	50 08       	stdsp	sp[0x0],r8
8000a182:	50 4b       	stdsp	sp[0x10],r11
8000a184:	12 00       	add	r0,r9
8000a186:	30 1b       	mov	r11,1
8000a188:	0e 9c       	mov	r12,r7
8000a18a:	e0 a0 08 a7 	rcall	8000b2d8 <__i2b>
8000a18e:	40 08       	lddsp	r8,sp[0x0]
8000a190:	18 94       	mov	r4,r12
8000a192:	40 4a       	lddsp	r10,sp[0x10]
8000a194:	58 05       	cp.w	r5,0
8000a196:	5f 99       	srgt	r9
8000a198:	58 0a       	cp.w	r10,0
8000a19a:	5f 9a       	srgt	r10
8000a19c:	f5 e9 00 09 	and	r9,r10,r9
8000a1a0:	c0 80       	breq	8000a1b0 <_dtoa_r+0x7e4>
8000a1a2:	40 4c       	lddsp	r12,sp[0x10]
8000a1a4:	f8 05 0d 49 	min	r9,r12,r5
8000a1a8:	12 1c       	sub	r12,r9
8000a1aa:	12 10       	sub	r0,r9
8000a1ac:	50 4c       	stdsp	sp[0x10],r12
8000a1ae:	12 15       	sub	r5,r9
8000a1b0:	58 02       	cp.w	r2,0
8000a1b2:	e0 8a 00 27 	brle	8000a200 <_dtoa_r+0x834>
8000a1b6:	40 db       	lddsp	r11,sp[0x34]
8000a1b8:	58 0b       	cp.w	r11,0
8000a1ba:	c1 d0       	breq	8000a1f4 <_dtoa_r+0x828>
8000a1bc:	58 08       	cp.w	r8,0
8000a1be:	e0 8a 00 17 	brle	8000a1ec <_dtoa_r+0x820>
8000a1c2:	10 9a       	mov	r10,r8
8000a1c4:	50 08       	stdsp	sp[0x0],r8
8000a1c6:	08 9b       	mov	r11,r4
8000a1c8:	0e 9c       	mov	r12,r7
8000a1ca:	e0 a0 08 cd 	rcall	8000b364 <__pow5mult>
8000a1ce:	06 9a       	mov	r10,r3
8000a1d0:	18 9b       	mov	r11,r12
8000a1d2:	18 94       	mov	r4,r12
8000a1d4:	0e 9c       	mov	r12,r7
8000a1d6:	e0 a0 08 01 	rcall	8000b1d8 <__multiply>
8000a1da:	18 99       	mov	r9,r12
8000a1dc:	06 9b       	mov	r11,r3
8000a1de:	50 19       	stdsp	sp[0x4],r9
8000a1e0:	0e 9c       	mov	r12,r7
8000a1e2:	e0 a0 06 ad 	rcall	8000af3c <_Bfree>
8000a1e6:	40 19       	lddsp	r9,sp[0x4]
8000a1e8:	40 08       	lddsp	r8,sp[0x0]
8000a1ea:	12 93       	mov	r3,r9
8000a1ec:	e4 08 01 0a 	sub	r10,r2,r8
8000a1f0:	c0 80       	breq	8000a200 <_dtoa_r+0x834>
8000a1f2:	c0 28       	rjmp	8000a1f6 <_dtoa_r+0x82a>
8000a1f4:	04 9a       	mov	r10,r2
8000a1f6:	06 9b       	mov	r11,r3
8000a1f8:	0e 9c       	mov	r12,r7
8000a1fa:	e0 a0 08 b5 	rcall	8000b364 <__pow5mult>
8000a1fe:	18 93       	mov	r3,r12
8000a200:	30 1b       	mov	r11,1
8000a202:	0e 9c       	mov	r12,r7
8000a204:	e0 a0 08 6a 	rcall	8000b2d8 <__i2b>
8000a208:	41 1a       	lddsp	r10,sp[0x44]
8000a20a:	18 92       	mov	r2,r12
8000a20c:	58 0a       	cp.w	r10,0
8000a20e:	e0 8a 00 07 	brle	8000a21c <_dtoa_r+0x850>
8000a212:	18 9b       	mov	r11,r12
8000a214:	0e 9c       	mov	r12,r7
8000a216:	e0 a0 08 a7 	rcall	8000b364 <__pow5mult>
8000a21a:	18 92       	mov	r2,r12
8000a21c:	40 c9       	lddsp	r9,sp[0x30]
8000a21e:	58 19       	cp.w	r9,1
8000a220:	e0 89 00 14 	brgt	8000a248 <_dtoa_r+0x87c>
8000a224:	40 38       	lddsp	r8,sp[0xc]
8000a226:	58 08       	cp.w	r8,0
8000a228:	c1 01       	brne	8000a248 <_dtoa_r+0x87c>
8000a22a:	40 29       	lddsp	r9,sp[0x8]
8000a22c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a230:	c0 c1       	brne	8000a248 <_dtoa_r+0x87c>
8000a232:	12 98       	mov	r8,r9
8000a234:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a238:	c0 80       	breq	8000a248 <_dtoa_r+0x87c>
8000a23a:	40 4c       	lddsp	r12,sp[0x10]
8000a23c:	30 1b       	mov	r11,1
8000a23e:	2f fc       	sub	r12,-1
8000a240:	2f f0       	sub	r0,-1
8000a242:	50 4c       	stdsp	sp[0x10],r12
8000a244:	50 6b       	stdsp	sp[0x18],r11
8000a246:	c0 38       	rjmp	8000a24c <_dtoa_r+0x880>
8000a248:	30 0a       	mov	r10,0
8000a24a:	50 6a       	stdsp	sp[0x18],r10
8000a24c:	41 19       	lddsp	r9,sp[0x44]
8000a24e:	58 09       	cp.w	r9,0
8000a250:	c0 31       	brne	8000a256 <_dtoa_r+0x88a>
8000a252:	30 1c       	mov	r12,1
8000a254:	c0 98       	rjmp	8000a266 <_dtoa_r+0x89a>
8000a256:	64 48       	ld.w	r8,r2[0x10]
8000a258:	2f c8       	sub	r8,-4
8000a25a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a25e:	e0 a0 05 df 	rcall	8000ae1c <__hi0bits>
8000a262:	f8 0c 11 20 	rsub	r12,r12,32
8000a266:	40 4b       	lddsp	r11,sp[0x10]
8000a268:	f8 0b 00 08 	add	r8,r12,r11
8000a26c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a270:	c0 c0       	breq	8000a288 <_dtoa_r+0x8bc>
8000a272:	f0 08 11 20 	rsub	r8,r8,32
8000a276:	58 48       	cp.w	r8,4
8000a278:	e0 8a 00 06 	brle	8000a284 <_dtoa_r+0x8b8>
8000a27c:	20 48       	sub	r8,4
8000a27e:	10 0b       	add	r11,r8
8000a280:	50 4b       	stdsp	sp[0x10],r11
8000a282:	c0 78       	rjmp	8000a290 <_dtoa_r+0x8c4>
8000a284:	58 48       	cp.w	r8,4
8000a286:	c0 70       	breq	8000a294 <_dtoa_r+0x8c8>
8000a288:	40 4a       	lddsp	r10,sp[0x10]
8000a28a:	2e 48       	sub	r8,-28
8000a28c:	10 0a       	add	r10,r8
8000a28e:	50 4a       	stdsp	sp[0x10],r10
8000a290:	10 00       	add	r0,r8
8000a292:	10 05       	add	r5,r8
8000a294:	58 00       	cp.w	r0,0
8000a296:	e0 8a 00 08 	brle	8000a2a6 <_dtoa_r+0x8da>
8000a29a:	06 9b       	mov	r11,r3
8000a29c:	00 9a       	mov	r10,r0
8000a29e:	0e 9c       	mov	r12,r7
8000a2a0:	e0 a0 07 58 	rcall	8000b150 <__lshift>
8000a2a4:	18 93       	mov	r3,r12
8000a2a6:	40 49       	lddsp	r9,sp[0x10]
8000a2a8:	58 09       	cp.w	r9,0
8000a2aa:	e0 8a 00 08 	brle	8000a2ba <_dtoa_r+0x8ee>
8000a2ae:	04 9b       	mov	r11,r2
8000a2b0:	12 9a       	mov	r10,r9
8000a2b2:	0e 9c       	mov	r12,r7
8000a2b4:	e0 a0 07 4e 	rcall	8000b150 <__lshift>
8000a2b8:	18 92       	mov	r2,r12
8000a2ba:	41 48       	lddsp	r8,sp[0x50]
8000a2bc:	58 08       	cp.w	r8,0
8000a2be:	c1 b0       	breq	8000a2f4 <_dtoa_r+0x928>
8000a2c0:	04 9b       	mov	r11,r2
8000a2c2:	06 9c       	mov	r12,r3
8000a2c4:	e0 a0 06 23 	rcall	8000af0a <__mcmp>
8000a2c8:	c1 64       	brge	8000a2f4 <_dtoa_r+0x928>
8000a2ca:	06 9b       	mov	r11,r3
8000a2cc:	30 09       	mov	r9,0
8000a2ce:	30 aa       	mov	r10,10
8000a2d0:	0e 9c       	mov	r12,r7
8000a2d2:	e0 a0 08 0b 	rcall	8000b2e8 <__multadd>
8000a2d6:	20 16       	sub	r6,1
8000a2d8:	18 93       	mov	r3,r12
8000a2da:	40 dc       	lddsp	r12,sp[0x34]
8000a2dc:	58 0c       	cp.w	r12,0
8000a2de:	c0 31       	brne	8000a2e4 <_dtoa_r+0x918>
8000a2e0:	40 91       	lddsp	r1,sp[0x24]
8000a2e2:	c0 98       	rjmp	8000a2f4 <_dtoa_r+0x928>
8000a2e4:	08 9b       	mov	r11,r4
8000a2e6:	40 91       	lddsp	r1,sp[0x24]
8000a2e8:	30 09       	mov	r9,0
8000a2ea:	30 aa       	mov	r10,10
8000a2ec:	0e 9c       	mov	r12,r7
8000a2ee:	e0 a0 07 fd 	rcall	8000b2e8 <__multadd>
8000a2f2:	18 94       	mov	r4,r12
8000a2f4:	58 01       	cp.w	r1,0
8000a2f6:	5f a9       	srle	r9
8000a2f8:	40 cb       	lddsp	r11,sp[0x30]
8000a2fa:	58 2b       	cp.w	r11,2
8000a2fc:	5f 98       	srgt	r8
8000a2fe:	f3 e8 00 08 	and	r8,r9,r8
8000a302:	c2 50       	breq	8000a34c <_dtoa_r+0x980>
8000a304:	58 01       	cp.w	r1,0
8000a306:	c1 11       	brne	8000a328 <_dtoa_r+0x95c>
8000a308:	04 9b       	mov	r11,r2
8000a30a:	02 99       	mov	r9,r1
8000a30c:	30 5a       	mov	r10,5
8000a30e:	0e 9c       	mov	r12,r7
8000a310:	e0 a0 07 ec 	rcall	8000b2e8 <__multadd>
8000a314:	18 92       	mov	r2,r12
8000a316:	18 9b       	mov	r11,r12
8000a318:	06 9c       	mov	r12,r3
8000a31a:	e0 a0 05 f8 	rcall	8000af0a <__mcmp>
8000a31e:	e0 89 00 0f 	brgt	8000a33c <_dtoa_r+0x970>
8000a322:	c0 38       	rjmp	8000a328 <_dtoa_r+0x95c>
8000a324:	30 02       	mov	r2,0
8000a326:	04 94       	mov	r4,r2
8000a328:	40 ea       	lddsp	r10,sp[0x38]
8000a32a:	30 09       	mov	r9,0
8000a32c:	5c da       	com	r10
8000a32e:	40 85       	lddsp	r5,sp[0x20]
8000a330:	50 6a       	stdsp	sp[0x18],r10
8000a332:	50 49       	stdsp	sp[0x10],r9
8000a334:	c0 f9       	rjmp	8000a552 <_dtoa_r+0xb86>
8000a336:	08 92       	mov	r2,r4
8000a338:	40 66       	lddsp	r6,sp[0x18]
8000a33a:	04 94       	mov	r4,r2
8000a33c:	2f f6       	sub	r6,-1
8000a33e:	50 66       	stdsp	sp[0x18],r6
8000a340:	33 18       	mov	r8,49
8000a342:	40 85       	lddsp	r5,sp[0x20]
8000a344:	0a c8       	st.b	r5++,r8
8000a346:	30 08       	mov	r8,0
8000a348:	50 48       	stdsp	sp[0x10],r8
8000a34a:	c0 49       	rjmp	8000a552 <_dtoa_r+0xb86>
8000a34c:	40 dc       	lddsp	r12,sp[0x34]
8000a34e:	58 0c       	cp.w	r12,0
8000a350:	e0 80 00 b5 	breq	8000a4ba <_dtoa_r+0xaee>
8000a354:	58 05       	cp.w	r5,0
8000a356:	e0 8a 00 08 	brle	8000a366 <_dtoa_r+0x99a>
8000a35a:	08 9b       	mov	r11,r4
8000a35c:	0a 9a       	mov	r10,r5
8000a35e:	0e 9c       	mov	r12,r7
8000a360:	e0 a0 06 f8 	rcall	8000b150 <__lshift>
8000a364:	18 94       	mov	r4,r12
8000a366:	40 6b       	lddsp	r11,sp[0x18]
8000a368:	58 0b       	cp.w	r11,0
8000a36a:	c0 31       	brne	8000a370 <_dtoa_r+0x9a4>
8000a36c:	08 9c       	mov	r12,r4
8000a36e:	c1 38       	rjmp	8000a394 <_dtoa_r+0x9c8>
8000a370:	68 1b       	ld.w	r11,r4[0x4]
8000a372:	0e 9c       	mov	r12,r7
8000a374:	e0 a0 05 fe 	rcall	8000af70 <_Balloc>
8000a378:	68 4a       	ld.w	r10,r4[0x10]
8000a37a:	18 95       	mov	r5,r12
8000a37c:	e8 cb ff f4 	sub	r11,r4,-12
8000a380:	2f ea       	sub	r10,-2
8000a382:	2f 4c       	sub	r12,-12
8000a384:	a3 6a       	lsl	r10,0x2
8000a386:	fe b0 e6 43 	rcall	8000700c <memcpy>
8000a38a:	0a 9b       	mov	r11,r5
8000a38c:	30 1a       	mov	r10,1
8000a38e:	0e 9c       	mov	r12,r7
8000a390:	e0 a0 06 e0 	rcall	8000b150 <__lshift>
8000a394:	50 44       	stdsp	sp[0x10],r4
8000a396:	40 3a       	lddsp	r10,sp[0xc]
8000a398:	30 19       	mov	r9,1
8000a39a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a39e:	18 94       	mov	r4,r12
8000a3a0:	50 da       	stdsp	sp[0x34],r10
8000a3a2:	40 85       	lddsp	r5,sp[0x20]
8000a3a4:	50 99       	stdsp	sp[0x24],r9
8000a3a6:	50 26       	stdsp	sp[0x8],r6
8000a3a8:	50 e1       	stdsp	sp[0x38],r1
8000a3aa:	04 9b       	mov	r11,r2
8000a3ac:	06 9c       	mov	r12,r3
8000a3ae:	fe b0 fa 7f 	rcall	800098ac <quorem>
8000a3b2:	40 4b       	lddsp	r11,sp[0x10]
8000a3b4:	f8 c0 ff d0 	sub	r0,r12,-48
8000a3b8:	06 9c       	mov	r12,r3
8000a3ba:	e0 a0 05 a8 	rcall	8000af0a <__mcmp>
8000a3be:	08 9a       	mov	r10,r4
8000a3c0:	50 6c       	stdsp	sp[0x18],r12
8000a3c2:	04 9b       	mov	r11,r2
8000a3c4:	0e 9c       	mov	r12,r7
8000a3c6:	e0 a0 06 5d 	rcall	8000b080 <__mdiff>
8000a3ca:	18 91       	mov	r1,r12
8000a3cc:	78 38       	ld.w	r8,r12[0xc]
8000a3ce:	58 08       	cp.w	r8,0
8000a3d0:	c0 30       	breq	8000a3d6 <_dtoa_r+0xa0a>
8000a3d2:	30 16       	mov	r6,1
8000a3d4:	c0 68       	rjmp	8000a3e0 <_dtoa_r+0xa14>
8000a3d6:	18 9b       	mov	r11,r12
8000a3d8:	06 9c       	mov	r12,r3
8000a3da:	e0 a0 05 98 	rcall	8000af0a <__mcmp>
8000a3de:	18 96       	mov	r6,r12
8000a3e0:	0e 9c       	mov	r12,r7
8000a3e2:	02 9b       	mov	r11,r1
8000a3e4:	e0 a0 05 ac 	rcall	8000af3c <_Bfree>
8000a3e8:	40 cc       	lddsp	r12,sp[0x30]
8000a3ea:	ed ec 10 08 	or	r8,r6,r12
8000a3ee:	c0 d1       	brne	8000a408 <_dtoa_r+0xa3c>
8000a3f0:	40 db       	lddsp	r11,sp[0x34]
8000a3f2:	58 0b       	cp.w	r11,0
8000a3f4:	c0 a1       	brne	8000a408 <_dtoa_r+0xa3c>
8000a3f6:	40 26       	lddsp	r6,sp[0x8]
8000a3f8:	e0 40 00 39 	cp.w	r0,57
8000a3fc:	c3 00       	breq	8000a45c <_dtoa_r+0xa90>
8000a3fe:	40 6a       	lddsp	r10,sp[0x18]
8000a400:	58 0a       	cp.w	r10,0
8000a402:	e0 89 00 24 	brgt	8000a44a <_dtoa_r+0xa7e>
8000a406:	c2 f8       	rjmp	8000a464 <_dtoa_r+0xa98>
8000a408:	40 69       	lddsp	r9,sp[0x18]
8000a40a:	58 09       	cp.w	r9,0
8000a40c:	c0 85       	brlt	8000a41c <_dtoa_r+0xa50>
8000a40e:	12 98       	mov	r8,r9
8000a410:	40 cc       	lddsp	r12,sp[0x30]
8000a412:	18 48       	or	r8,r12
8000a414:	c1 d1       	brne	8000a44e <_dtoa_r+0xa82>
8000a416:	40 db       	lddsp	r11,sp[0x34]
8000a418:	58 0b       	cp.w	r11,0
8000a41a:	c1 a1       	brne	8000a44e <_dtoa_r+0xa82>
8000a41c:	0c 99       	mov	r9,r6
8000a41e:	40 26       	lddsp	r6,sp[0x8]
8000a420:	58 09       	cp.w	r9,0
8000a422:	e0 8a 00 21 	brle	8000a464 <_dtoa_r+0xa98>
8000a426:	06 9b       	mov	r11,r3
8000a428:	30 1a       	mov	r10,1
8000a42a:	0e 9c       	mov	r12,r7
8000a42c:	e0 a0 06 92 	rcall	8000b150 <__lshift>
8000a430:	04 9b       	mov	r11,r2
8000a432:	18 93       	mov	r3,r12
8000a434:	e0 a0 05 6b 	rcall	8000af0a <__mcmp>
8000a438:	e0 89 00 06 	brgt	8000a444 <_dtoa_r+0xa78>
8000a43c:	c1 41       	brne	8000a464 <_dtoa_r+0xa98>
8000a43e:	ed b0 00 00 	bld	r0,0x0
8000a442:	c1 11       	brne	8000a464 <_dtoa_r+0xa98>
8000a444:	e0 40 00 39 	cp.w	r0,57
8000a448:	c0 a0       	breq	8000a45c <_dtoa_r+0xa90>
8000a44a:	2f f0       	sub	r0,-1
8000a44c:	c0 c8       	rjmp	8000a464 <_dtoa_r+0xa98>
8000a44e:	58 06       	cp.w	r6,0
8000a450:	e0 8a 00 0c 	brle	8000a468 <_dtoa_r+0xa9c>
8000a454:	40 26       	lddsp	r6,sp[0x8]
8000a456:	e0 40 00 39 	cp.w	r0,57
8000a45a:	c0 41       	brne	8000a462 <_dtoa_r+0xa96>
8000a45c:	33 98       	mov	r8,57
8000a45e:	0a c8       	st.b	r5++,r8
8000a460:	c6 78       	rjmp	8000a52e <_dtoa_r+0xb62>
8000a462:	2f f0       	sub	r0,-1
8000a464:	0a c0       	st.b	r5++,r0
8000a466:	c7 58       	rjmp	8000a550 <_dtoa_r+0xb84>
8000a468:	0a c0       	st.b	r5++,r0
8000a46a:	40 9a       	lddsp	r10,sp[0x24]
8000a46c:	40 e9       	lddsp	r9,sp[0x38]
8000a46e:	12 3a       	cp.w	r10,r9
8000a470:	c4 30       	breq	8000a4f6 <_dtoa_r+0xb2a>
8000a472:	06 9b       	mov	r11,r3
8000a474:	30 09       	mov	r9,0
8000a476:	30 aa       	mov	r10,10
8000a478:	0e 9c       	mov	r12,r7
8000a47a:	e0 a0 07 37 	rcall	8000b2e8 <__multadd>
8000a47e:	40 48       	lddsp	r8,sp[0x10]
8000a480:	18 93       	mov	r3,r12
8000a482:	08 38       	cp.w	r8,r4
8000a484:	c0 91       	brne	8000a496 <_dtoa_r+0xaca>
8000a486:	10 9b       	mov	r11,r8
8000a488:	30 09       	mov	r9,0
8000a48a:	30 aa       	mov	r10,10
8000a48c:	0e 9c       	mov	r12,r7
8000a48e:	e0 a0 07 2d 	rcall	8000b2e8 <__multadd>
8000a492:	50 4c       	stdsp	sp[0x10],r12
8000a494:	c0 e8       	rjmp	8000a4b0 <_dtoa_r+0xae4>
8000a496:	40 4b       	lddsp	r11,sp[0x10]
8000a498:	30 09       	mov	r9,0
8000a49a:	30 aa       	mov	r10,10
8000a49c:	0e 9c       	mov	r12,r7
8000a49e:	e0 a0 07 25 	rcall	8000b2e8 <__multadd>
8000a4a2:	08 9b       	mov	r11,r4
8000a4a4:	50 4c       	stdsp	sp[0x10],r12
8000a4a6:	30 09       	mov	r9,0
8000a4a8:	30 aa       	mov	r10,10
8000a4aa:	0e 9c       	mov	r12,r7
8000a4ac:	e0 a0 07 1e 	rcall	8000b2e8 <__multadd>
8000a4b0:	18 94       	mov	r4,r12
8000a4b2:	40 9c       	lddsp	r12,sp[0x24]
8000a4b4:	2f fc       	sub	r12,-1
8000a4b6:	50 9c       	stdsp	sp[0x24],r12
8000a4b8:	c7 9b       	rjmp	8000a3aa <_dtoa_r+0x9de>
8000a4ba:	30 18       	mov	r8,1
8000a4bc:	06 90       	mov	r0,r3
8000a4be:	40 85       	lddsp	r5,sp[0x20]
8000a4c0:	08 93       	mov	r3,r4
8000a4c2:	0c 94       	mov	r4,r6
8000a4c4:	10 96       	mov	r6,r8
8000a4c6:	04 9b       	mov	r11,r2
8000a4c8:	00 9c       	mov	r12,r0
8000a4ca:	fe b0 f9 f1 	rcall	800098ac <quorem>
8000a4ce:	2d 0c       	sub	r12,-48
8000a4d0:	0a cc       	st.b	r5++,r12
8000a4d2:	02 36       	cp.w	r6,r1
8000a4d4:	c0 a4       	brge	8000a4e8 <_dtoa_r+0xb1c>
8000a4d6:	00 9b       	mov	r11,r0
8000a4d8:	30 09       	mov	r9,0
8000a4da:	30 aa       	mov	r10,10
8000a4dc:	0e 9c       	mov	r12,r7
8000a4de:	2f f6       	sub	r6,-1
8000a4e0:	e0 a0 07 04 	rcall	8000b2e8 <__multadd>
8000a4e4:	18 90       	mov	r0,r12
8000a4e6:	cf 0b       	rjmp	8000a4c6 <_dtoa_r+0xafa>
8000a4e8:	08 96       	mov	r6,r4
8000a4ea:	30 0b       	mov	r11,0
8000a4ec:	06 94       	mov	r4,r3
8000a4ee:	50 4b       	stdsp	sp[0x10],r11
8000a4f0:	00 93       	mov	r3,r0
8000a4f2:	18 90       	mov	r0,r12
8000a4f4:	c0 28       	rjmp	8000a4f8 <_dtoa_r+0xb2c>
8000a4f6:	40 26       	lddsp	r6,sp[0x8]
8000a4f8:	06 9b       	mov	r11,r3
8000a4fa:	30 1a       	mov	r10,1
8000a4fc:	0e 9c       	mov	r12,r7
8000a4fe:	e0 a0 06 29 	rcall	8000b150 <__lshift>
8000a502:	04 9b       	mov	r11,r2
8000a504:	18 93       	mov	r3,r12
8000a506:	e0 a0 05 02 	rcall	8000af0a <__mcmp>
8000a50a:	e0 89 00 12 	brgt	8000a52e <_dtoa_r+0xb62>
8000a50e:	c1 b1       	brne	8000a544 <_dtoa_r+0xb78>
8000a510:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a514:	c0 d1       	brne	8000a52e <_dtoa_r+0xb62>
8000a516:	c1 78       	rjmp	8000a544 <_dtoa_r+0xb78>
8000a518:	40 89       	lddsp	r9,sp[0x20]
8000a51a:	12 38       	cp.w	r8,r9
8000a51c:	c0 30       	breq	8000a522 <_dtoa_r+0xb56>
8000a51e:	10 95       	mov	r5,r8
8000a520:	c0 88       	rjmp	8000a530 <_dtoa_r+0xb64>
8000a522:	2f f6       	sub	r6,-1
8000a524:	50 66       	stdsp	sp[0x18],r6
8000a526:	33 18       	mov	r8,49
8000a528:	40 8c       	lddsp	r12,sp[0x20]
8000a52a:	b8 88       	st.b	r12[0x0],r8
8000a52c:	c1 38       	rjmp	8000a552 <_dtoa_r+0xb86>
8000a52e:	33 9a       	mov	r10,57
8000a530:	0a 98       	mov	r8,r5
8000a532:	11 79       	ld.ub	r9,--r8
8000a534:	f4 09 18 00 	cp.b	r9,r10
8000a538:	cf 00       	breq	8000a518 <_dtoa_r+0xb4c>
8000a53a:	2f f9       	sub	r9,-1
8000a53c:	b0 89       	st.b	r8[0x0],r9
8000a53e:	c0 98       	rjmp	8000a550 <_dtoa_r+0xb84>
8000a540:	10 95       	mov	r5,r8
8000a542:	c0 28       	rjmp	8000a546 <_dtoa_r+0xb7a>
8000a544:	33 09       	mov	r9,48
8000a546:	0a 98       	mov	r8,r5
8000a548:	11 7a       	ld.ub	r10,--r8
8000a54a:	f2 0a 18 00 	cp.b	r10,r9
8000a54e:	cf 90       	breq	8000a540 <_dtoa_r+0xb74>
8000a550:	50 66       	stdsp	sp[0x18],r6
8000a552:	04 9b       	mov	r11,r2
8000a554:	0e 9c       	mov	r12,r7
8000a556:	e0 a0 04 f3 	rcall	8000af3c <_Bfree>
8000a55a:	58 04       	cp.w	r4,0
8000a55c:	c1 20       	breq	8000a580 <_dtoa_r+0xbb4>
8000a55e:	40 4b       	lddsp	r11,sp[0x10]
8000a560:	08 3b       	cp.w	r11,r4
8000a562:	5f 19       	srne	r9
8000a564:	58 0b       	cp.w	r11,0
8000a566:	5f 18       	srne	r8
8000a568:	f3 e8 00 08 	and	r8,r9,r8
8000a56c:	c0 40       	breq	8000a574 <_dtoa_r+0xba8>
8000a56e:	0e 9c       	mov	r12,r7
8000a570:	e0 a0 04 e6 	rcall	8000af3c <_Bfree>
8000a574:	08 9b       	mov	r11,r4
8000a576:	0e 9c       	mov	r12,r7
8000a578:	e0 a0 04 e2 	rcall	8000af3c <_Bfree>
8000a57c:	c0 28       	rjmp	8000a580 <_dtoa_r+0xbb4>
8000a57e:	50 66       	stdsp	sp[0x18],r6
8000a580:	0e 9c       	mov	r12,r7
8000a582:	06 9b       	mov	r11,r3
8000a584:	e0 a0 04 dc 	rcall	8000af3c <_Bfree>
8000a588:	30 08       	mov	r8,0
8000a58a:	aa 88       	st.b	r5[0x0],r8
8000a58c:	40 68       	lddsp	r8,sp[0x18]
8000a58e:	41 5a       	lddsp	r10,sp[0x54]
8000a590:	2f f8       	sub	r8,-1
8000a592:	41 29       	lddsp	r9,sp[0x48]
8000a594:	95 08       	st.w	r10[0x0],r8
8000a596:	40 8c       	lddsp	r12,sp[0x20]
8000a598:	58 09       	cp.w	r9,0
8000a59a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a59e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a5a2:	2e 6d       	sub	sp,-104
8000a5a4:	d8 32       	popm	r0-r7,pc
8000a5a6:	d7 03       	nop

8000a5a8 <__errno>:
8000a5a8:	e0 68 0a 44 	mov	r8,2628
8000a5ac:	70 0c       	ld.w	r12,r8[0x0]
8000a5ae:	2f 4c       	sub	r12,-12
8000a5b0:	5e fc       	retal	r12
8000a5b2:	d7 03       	nop

8000a5b4 <_fflush_r>:
8000a5b4:	d4 21       	pushm	r4-r7,lr
8000a5b6:	16 97       	mov	r7,r11
8000a5b8:	18 96       	mov	r6,r12
8000a5ba:	76 48       	ld.w	r8,r11[0x10]
8000a5bc:	58 08       	cp.w	r8,0
8000a5be:	c7 f0       	breq	8000a6bc <_fflush_r+0x108>
8000a5c0:	58 0c       	cp.w	r12,0
8000a5c2:	c0 50       	breq	8000a5cc <_fflush_r+0x18>
8000a5c4:	78 68       	ld.w	r8,r12[0x18]
8000a5c6:	58 08       	cp.w	r8,0
8000a5c8:	c0 21       	brne	8000a5cc <_fflush_r+0x18>
8000a5ca:	cc dc       	rcall	8000a764 <__sinit>
8000a5cc:	fe c8 cd 64 	sub	r8,pc,-12956
8000a5d0:	10 37       	cp.w	r7,r8
8000a5d2:	c0 31       	brne	8000a5d8 <_fflush_r+0x24>
8000a5d4:	6c 07       	ld.w	r7,r6[0x0]
8000a5d6:	c0 c8       	rjmp	8000a5ee <_fflush_r+0x3a>
8000a5d8:	fe c8 cd 50 	sub	r8,pc,-12976
8000a5dc:	10 37       	cp.w	r7,r8
8000a5de:	c0 31       	brne	8000a5e4 <_fflush_r+0x30>
8000a5e0:	6c 17       	ld.w	r7,r6[0x4]
8000a5e2:	c0 68       	rjmp	8000a5ee <_fflush_r+0x3a>
8000a5e4:	fe c8 cd 3c 	sub	r8,pc,-12996
8000a5e8:	10 37       	cp.w	r7,r8
8000a5ea:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a5ee:	8e 6a       	ld.sh	r10,r7[0xc]
8000a5f0:	14 98       	mov	r8,r10
8000a5f2:	ed ba 00 03 	bld	r10,0x3
8000a5f6:	c4 20       	breq	8000a67a <_fflush_r+0xc6>
8000a5f8:	ab ba       	sbr	r10,0xb
8000a5fa:	ae 6a       	st.h	r7[0xc],r10
8000a5fc:	6e 18       	ld.w	r8,r7[0x4]
8000a5fe:	58 08       	cp.w	r8,0
8000a600:	e0 89 00 06 	brgt	8000a60c <_fflush_r+0x58>
8000a604:	6f 08       	ld.w	r8,r7[0x40]
8000a606:	58 08       	cp.w	r8,0
8000a608:	e0 8a 00 5a 	brle	8000a6bc <_fflush_r+0x108>
8000a60c:	6e b8       	ld.w	r8,r7[0x2c]
8000a60e:	58 08       	cp.w	r8,0
8000a610:	c5 60       	breq	8000a6bc <_fflush_r+0x108>
8000a612:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a616:	c0 30       	breq	8000a61c <_fflush_r+0x68>
8000a618:	6f 55       	ld.w	r5,r7[0x54]
8000a61a:	c0 f8       	rjmp	8000a638 <_fflush_r+0x84>
8000a61c:	30 19       	mov	r9,1
8000a61e:	6e 8b       	ld.w	r11,r7[0x20]
8000a620:	0c 9c       	mov	r12,r6
8000a622:	5d 18       	icall	r8
8000a624:	18 95       	mov	r5,r12
8000a626:	5b fc       	cp.w	r12,-1
8000a628:	c0 81       	brne	8000a638 <_fflush_r+0x84>
8000a62a:	6c 38       	ld.w	r8,r6[0xc]
8000a62c:	59 d8       	cp.w	r8,29
8000a62e:	c4 70       	breq	8000a6bc <_fflush_r+0x108>
8000a630:	8e 68       	ld.sh	r8,r7[0xc]
8000a632:	a7 a8       	sbr	r8,0x6
8000a634:	ae 68       	st.h	r7[0xc],r8
8000a636:	d8 22       	popm	r4-r7,pc
8000a638:	8e 68       	ld.sh	r8,r7[0xc]
8000a63a:	ed b8 00 02 	bld	r8,0x2
8000a63e:	c0 91       	brne	8000a650 <_fflush_r+0x9c>
8000a640:	6e 18       	ld.w	r8,r7[0x4]
8000a642:	10 15       	sub	r5,r8
8000a644:	6e d8       	ld.w	r8,r7[0x34]
8000a646:	58 08       	cp.w	r8,0
8000a648:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a64c:	eb d8 e1 15 	subne	r5,r5,r8
8000a650:	6e b8       	ld.w	r8,r7[0x2c]
8000a652:	0c 9c       	mov	r12,r6
8000a654:	30 09       	mov	r9,0
8000a656:	0a 9a       	mov	r10,r5
8000a658:	6e 8b       	ld.w	r11,r7[0x20]
8000a65a:	5d 18       	icall	r8
8000a65c:	8e 68       	ld.sh	r8,r7[0xc]
8000a65e:	0a 3c       	cp.w	r12,r5
8000a660:	c2 61       	brne	8000a6ac <_fflush_r+0xf8>
8000a662:	ab d8       	cbr	r8,0xb
8000a664:	30 0c       	mov	r12,0
8000a666:	6e 49       	ld.w	r9,r7[0x10]
8000a668:	ae 68       	st.h	r7[0xc],r8
8000a66a:	8f 1c       	st.w	r7[0x4],r12
8000a66c:	8f 09       	st.w	r7[0x0],r9
8000a66e:	ed b8 00 0c 	bld	r8,0xc
8000a672:	c2 51       	brne	8000a6bc <_fflush_r+0x108>
8000a674:	ef 45 00 54 	st.w	r7[84],r5
8000a678:	d8 22       	popm	r4-r7,pc
8000a67a:	6e 45       	ld.w	r5,r7[0x10]
8000a67c:	58 05       	cp.w	r5,0
8000a67e:	c1 f0       	breq	8000a6bc <_fflush_r+0x108>
8000a680:	6e 04       	ld.w	r4,r7[0x0]
8000a682:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a686:	8f 05       	st.w	r7[0x0],r5
8000a688:	f9 b8 01 00 	movne	r8,0
8000a68c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a690:	0a 14       	sub	r4,r5
8000a692:	8f 28       	st.w	r7[0x8],r8
8000a694:	c1 18       	rjmp	8000a6b6 <_fflush_r+0x102>
8000a696:	08 99       	mov	r9,r4
8000a698:	0a 9a       	mov	r10,r5
8000a69a:	6e a8       	ld.w	r8,r7[0x28]
8000a69c:	6e 8b       	ld.w	r11,r7[0x20]
8000a69e:	0c 9c       	mov	r12,r6
8000a6a0:	5d 18       	icall	r8
8000a6a2:	18 14       	sub	r4,r12
8000a6a4:	58 0c       	cp.w	r12,0
8000a6a6:	e0 89 00 07 	brgt	8000a6b4 <_fflush_r+0x100>
8000a6aa:	8e 68       	ld.sh	r8,r7[0xc]
8000a6ac:	a7 a8       	sbr	r8,0x6
8000a6ae:	3f fc       	mov	r12,-1
8000a6b0:	ae 68       	st.h	r7[0xc],r8
8000a6b2:	d8 22       	popm	r4-r7,pc
8000a6b4:	18 05       	add	r5,r12
8000a6b6:	58 04       	cp.w	r4,0
8000a6b8:	fe 99 ff ef 	brgt	8000a696 <_fflush_r+0xe2>
8000a6bc:	d8 2a       	popm	r4-r7,pc,r12=0
8000a6be:	d7 03       	nop

8000a6c0 <__sfp_lock_acquire>:
8000a6c0:	5e fc       	retal	r12

8000a6c2 <__sfp_lock_release>:
8000a6c2:	5e fc       	retal	r12

8000a6c4 <_cleanup_r>:
8000a6c4:	d4 01       	pushm	lr
8000a6c6:	fe cb f0 c6 	sub	r11,pc,-3898
8000a6ca:	e0 a0 02 f7 	rcall	8000acb8 <_fwalk>
8000a6ce:	d8 02       	popm	pc

8000a6d0 <__sfmoreglue>:
8000a6d0:	d4 21       	pushm	r4-r7,lr
8000a6d2:	16 95       	mov	r5,r11
8000a6d4:	f6 06 10 5c 	mul	r6,r11,92
8000a6d8:	ec cb ff f4 	sub	r11,r6,-12
8000a6dc:	fe b0 e2 7c 	rcall	80006bd4 <_malloc_r>
8000a6e0:	18 97       	mov	r7,r12
8000a6e2:	c0 90       	breq	8000a6f4 <__sfmoreglue+0x24>
8000a6e4:	99 15       	st.w	r12[0x4],r5
8000a6e6:	30 0b       	mov	r11,0
8000a6e8:	2f 4c       	sub	r12,-12
8000a6ea:	0c 9a       	mov	r10,r6
8000a6ec:	8f 2c       	st.w	r7[0x8],r12
8000a6ee:	8f 0b       	st.w	r7[0x0],r11
8000a6f0:	fe b0 e5 32 	rcall	80007154 <memset>
8000a6f4:	0e 9c       	mov	r12,r7
8000a6f6:	d8 22       	popm	r4-r7,pc

8000a6f8 <__sfp>:
8000a6f8:	d4 21       	pushm	r4-r7,lr
8000a6fa:	fe c8 ce 2e 	sub	r8,pc,-12754
8000a6fe:	18 96       	mov	r6,r12
8000a700:	70 07       	ld.w	r7,r8[0x0]
8000a702:	6e 68       	ld.w	r8,r7[0x18]
8000a704:	58 08       	cp.w	r8,0
8000a706:	c0 31       	brne	8000a70c <__sfp+0x14>
8000a708:	0e 9c       	mov	r12,r7
8000a70a:	c2 dc       	rcall	8000a764 <__sinit>
8000a70c:	ee c7 ff 28 	sub	r7,r7,-216
8000a710:	30 05       	mov	r5,0
8000a712:	6e 2c       	ld.w	r12,r7[0x8]
8000a714:	6e 18       	ld.w	r8,r7[0x4]
8000a716:	c0 68       	rjmp	8000a722 <__sfp+0x2a>
8000a718:	98 69       	ld.sh	r9,r12[0xc]
8000a71a:	ea 09 19 00 	cp.h	r9,r5
8000a71e:	c1 10       	breq	8000a740 <__sfp+0x48>
8000a720:	2a 4c       	sub	r12,-92
8000a722:	20 18       	sub	r8,1
8000a724:	cf a7       	brpl	8000a718 <__sfp+0x20>
8000a726:	6e 08       	ld.w	r8,r7[0x0]
8000a728:	58 08       	cp.w	r8,0
8000a72a:	c0 61       	brne	8000a736 <__sfp+0x3e>
8000a72c:	30 4b       	mov	r11,4
8000a72e:	0c 9c       	mov	r12,r6
8000a730:	cd 0f       	rcall	8000a6d0 <__sfmoreglue>
8000a732:	8f 0c       	st.w	r7[0x0],r12
8000a734:	c0 30       	breq	8000a73a <__sfp+0x42>
8000a736:	6e 07       	ld.w	r7,r7[0x0]
8000a738:	ce db       	rjmp	8000a712 <__sfp+0x1a>
8000a73a:	30 c8       	mov	r8,12
8000a73c:	8d 38       	st.w	r6[0xc],r8
8000a73e:	d8 22       	popm	r4-r7,pc
8000a740:	30 08       	mov	r8,0
8000a742:	f9 48 00 4c 	st.w	r12[76],r8
8000a746:	99 08       	st.w	r12[0x0],r8
8000a748:	99 28       	st.w	r12[0x8],r8
8000a74a:	99 18       	st.w	r12[0x4],r8
8000a74c:	99 48       	st.w	r12[0x10],r8
8000a74e:	99 58       	st.w	r12[0x14],r8
8000a750:	99 68       	st.w	r12[0x18],r8
8000a752:	99 d8       	st.w	r12[0x34],r8
8000a754:	99 e8       	st.w	r12[0x38],r8
8000a756:	f9 48 00 48 	st.w	r12[72],r8
8000a75a:	3f f8       	mov	r8,-1
8000a75c:	b8 78       	st.h	r12[0xe],r8
8000a75e:	30 18       	mov	r8,1
8000a760:	b8 68       	st.h	r12[0xc],r8
8000a762:	d8 22       	popm	r4-r7,pc

8000a764 <__sinit>:
8000a764:	d4 21       	pushm	r4-r7,lr
8000a766:	18 96       	mov	r6,r12
8000a768:	78 67       	ld.w	r7,r12[0x18]
8000a76a:	58 07       	cp.w	r7,0
8000a76c:	c4 91       	brne	8000a7fe <__sinit+0x9a>
8000a76e:	fe c8 00 aa 	sub	r8,pc,170
8000a772:	30 15       	mov	r5,1
8000a774:	99 a8       	st.w	r12[0x28],r8
8000a776:	f9 47 00 d8 	st.w	r12[216],r7
8000a77a:	f9 47 00 dc 	st.w	r12[220],r7
8000a77e:	f9 47 00 e0 	st.w	r12[224],r7
8000a782:	99 65       	st.w	r12[0x18],r5
8000a784:	cb af       	rcall	8000a6f8 <__sfp>
8000a786:	8d 0c       	st.w	r6[0x0],r12
8000a788:	0c 9c       	mov	r12,r6
8000a78a:	cb 7f       	rcall	8000a6f8 <__sfp>
8000a78c:	8d 1c       	st.w	r6[0x4],r12
8000a78e:	0c 9c       	mov	r12,r6
8000a790:	cb 4f       	rcall	8000a6f8 <__sfp>
8000a792:	6c 09       	ld.w	r9,r6[0x0]
8000a794:	30 48       	mov	r8,4
8000a796:	93 07       	st.w	r9[0x0],r7
8000a798:	b2 68       	st.h	r9[0xc],r8
8000a79a:	93 17       	st.w	r9[0x4],r7
8000a79c:	93 27       	st.w	r9[0x8],r7
8000a79e:	6c 18       	ld.w	r8,r6[0x4]
8000a7a0:	b2 77       	st.h	r9[0xe],r7
8000a7a2:	93 47       	st.w	r9[0x10],r7
8000a7a4:	93 57       	st.w	r9[0x14],r7
8000a7a6:	93 67       	st.w	r9[0x18],r7
8000a7a8:	93 89       	st.w	r9[0x20],r9
8000a7aa:	91 07       	st.w	r8[0x0],r7
8000a7ac:	91 17       	st.w	r8[0x4],r7
8000a7ae:	91 27       	st.w	r8[0x8],r7
8000a7b0:	fe ce f3 24 	sub	lr,pc,-3292
8000a7b4:	fe cb f3 54 	sub	r11,pc,-3244
8000a7b8:	93 9e       	st.w	r9[0x24],lr
8000a7ba:	93 ab       	st.w	r9[0x28],r11
8000a7bc:	fe ca f3 7c 	sub	r10,pc,-3204
8000a7c0:	fe c4 f3 88 	sub	r4,pc,-3192
8000a7c4:	93 ba       	st.w	r9[0x2c],r10
8000a7c6:	93 c4       	st.w	r9[0x30],r4
8000a7c8:	30 99       	mov	r9,9
8000a7ca:	b0 69       	st.h	r8[0xc],r9
8000a7cc:	b0 75       	st.h	r8[0xe],r5
8000a7ce:	91 c4       	st.w	r8[0x30],r4
8000a7d0:	91 47       	st.w	r8[0x10],r7
8000a7d2:	91 57       	st.w	r8[0x14],r7
8000a7d4:	91 67       	st.w	r8[0x18],r7
8000a7d6:	91 88       	st.w	r8[0x20],r8
8000a7d8:	91 9e       	st.w	r8[0x24],lr
8000a7da:	91 ab       	st.w	r8[0x28],r11
8000a7dc:	91 ba       	st.w	r8[0x2c],r10
8000a7de:	8d 2c       	st.w	r6[0x8],r12
8000a7e0:	31 28       	mov	r8,18
8000a7e2:	99 07       	st.w	r12[0x0],r7
8000a7e4:	b8 68       	st.h	r12[0xc],r8
8000a7e6:	99 17       	st.w	r12[0x4],r7
8000a7e8:	99 27       	st.w	r12[0x8],r7
8000a7ea:	30 28       	mov	r8,2
8000a7ec:	b8 78       	st.h	r12[0xe],r8
8000a7ee:	99 c4       	st.w	r12[0x30],r4
8000a7f0:	99 67       	st.w	r12[0x18],r7
8000a7f2:	99 9e       	st.w	r12[0x24],lr
8000a7f4:	99 ab       	st.w	r12[0x28],r11
8000a7f6:	99 ba       	st.w	r12[0x2c],r10
8000a7f8:	99 47       	st.w	r12[0x10],r7
8000a7fa:	99 57       	st.w	r12[0x14],r7
8000a7fc:	99 8c       	st.w	r12[0x20],r12
8000a7fe:	d8 22       	popm	r4-r7,pc

8000a800 <_malloc_trim_r>:
8000a800:	d4 21       	pushm	r4-r7,lr
8000a802:	16 95       	mov	r5,r11
8000a804:	18 97       	mov	r7,r12
8000a806:	fe b0 d7 65 	rcall	800056d0 <__malloc_lock>
8000a80a:	e0 64 05 44 	mov	r4,1348
8000a80e:	68 28       	ld.w	r8,r4[0x8]
8000a810:	70 16       	ld.w	r6,r8[0x4]
8000a812:	e0 16 ff fc 	andl	r6,0xfffc
8000a816:	ec c8 ff 91 	sub	r8,r6,-111
8000a81a:	f0 05 01 05 	sub	r5,r8,r5
8000a81e:	e0 15 ff 80 	andl	r5,0xff80
8000a822:	ea c5 00 80 	sub	r5,r5,128
8000a826:	e0 45 00 7f 	cp.w	r5,127
8000a82a:	e0 8a 00 25 	brle	8000a874 <_malloc_trim_r+0x74>
8000a82e:	30 0b       	mov	r11,0
8000a830:	0e 9c       	mov	r12,r7
8000a832:	fe b0 e5 f9 	rcall	80007424 <_sbrk_r>
8000a836:	68 28       	ld.w	r8,r4[0x8]
8000a838:	0c 08       	add	r8,r6
8000a83a:	10 3c       	cp.w	r12,r8
8000a83c:	c1 c1       	brne	8000a874 <_malloc_trim_r+0x74>
8000a83e:	ea 0b 11 00 	rsub	r11,r5,0
8000a842:	0e 9c       	mov	r12,r7
8000a844:	fe b0 e5 f0 	rcall	80007424 <_sbrk_r>
8000a848:	5b fc       	cp.w	r12,-1
8000a84a:	c1 91       	brne	8000a87c <_malloc_trim_r+0x7c>
8000a84c:	30 0b       	mov	r11,0
8000a84e:	0e 9c       	mov	r12,r7
8000a850:	fe b0 e5 ea 	rcall	80007424 <_sbrk_r>
8000a854:	68 28       	ld.w	r8,r4[0x8]
8000a856:	f8 08 01 09 	sub	r9,r12,r8
8000a85a:	58 f9       	cp.w	r9,15
8000a85c:	e0 8a 00 0c 	brle	8000a874 <_malloc_trim_r+0x74>
8000a860:	a1 a9       	sbr	r9,0x0
8000a862:	91 19       	st.w	r8[0x4],r9
8000a864:	e0 68 09 50 	mov	r8,2384
8000a868:	70 09       	ld.w	r9,r8[0x0]
8000a86a:	e0 68 0d 5c 	mov	r8,3420
8000a86e:	f8 09 01 09 	sub	r9,r12,r9
8000a872:	91 09       	st.w	r8[0x0],r9
8000a874:	0e 9c       	mov	r12,r7
8000a876:	fe b0 d7 33 	rcall	800056dc <__malloc_unlock>
8000a87a:	d8 2a       	popm	r4-r7,pc,r12=0
8000a87c:	68 28       	ld.w	r8,r4[0x8]
8000a87e:	0a 16       	sub	r6,r5
8000a880:	a1 a6       	sbr	r6,0x0
8000a882:	91 16       	st.w	r8[0x4],r6
8000a884:	e0 68 0d 5c 	mov	r8,3420
8000a888:	70 09       	ld.w	r9,r8[0x0]
8000a88a:	0a 19       	sub	r9,r5
8000a88c:	0e 9c       	mov	r12,r7
8000a88e:	91 09       	st.w	r8[0x0],r9
8000a890:	fe b0 d7 26 	rcall	800056dc <__malloc_unlock>
8000a894:	da 2a       	popm	r4-r7,pc,r12=1
8000a896:	d7 03       	nop

8000a898 <_free_r>:
8000a898:	d4 21       	pushm	r4-r7,lr
8000a89a:	16 96       	mov	r6,r11
8000a89c:	18 97       	mov	r7,r12
8000a89e:	58 0b       	cp.w	r11,0
8000a8a0:	e0 80 00 c0 	breq	8000aa20 <_free_r+0x188>
8000a8a4:	fe b0 d7 16 	rcall	800056d0 <__malloc_lock>
8000a8a8:	20 86       	sub	r6,8
8000a8aa:	e0 6a 05 44 	mov	r10,1348
8000a8ae:	6c 18       	ld.w	r8,r6[0x4]
8000a8b0:	74 2e       	ld.w	lr,r10[0x8]
8000a8b2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a8b6:	a1 c8       	cbr	r8,0x0
8000a8b8:	ec 08 00 09 	add	r9,r6,r8
8000a8bc:	72 1b       	ld.w	r11,r9[0x4]
8000a8be:	e0 1b ff fc 	andl	r11,0xfffc
8000a8c2:	1c 39       	cp.w	r9,lr
8000a8c4:	c1 e1       	brne	8000a900 <_free_r+0x68>
8000a8c6:	f6 08 00 08 	add	r8,r11,r8
8000a8ca:	58 0c       	cp.w	r12,0
8000a8cc:	c0 81       	brne	8000a8dc <_free_r+0x44>
8000a8ce:	6c 09       	ld.w	r9,r6[0x0]
8000a8d0:	12 16       	sub	r6,r9
8000a8d2:	12 08       	add	r8,r9
8000a8d4:	6c 3b       	ld.w	r11,r6[0xc]
8000a8d6:	6c 29       	ld.w	r9,r6[0x8]
8000a8d8:	97 29       	st.w	r11[0x8],r9
8000a8da:	93 3b       	st.w	r9[0xc],r11
8000a8dc:	10 99       	mov	r9,r8
8000a8de:	95 26       	st.w	r10[0x8],r6
8000a8e0:	a1 a9       	sbr	r9,0x0
8000a8e2:	8d 19       	st.w	r6[0x4],r9
8000a8e4:	e0 69 09 4c 	mov	r9,2380
8000a8e8:	72 09       	ld.w	r9,r9[0x0]
8000a8ea:	12 38       	cp.w	r8,r9
8000a8ec:	c0 63       	brcs	8000a8f8 <_free_r+0x60>
8000a8ee:	e0 68 0d 58 	mov	r8,3416
8000a8f2:	0e 9c       	mov	r12,r7
8000a8f4:	70 0b       	ld.w	r11,r8[0x0]
8000a8f6:	c8 5f       	rcall	8000a800 <_malloc_trim_r>
8000a8f8:	0e 9c       	mov	r12,r7
8000a8fa:	fe b0 d6 f1 	rcall	800056dc <__malloc_unlock>
8000a8fe:	d8 22       	popm	r4-r7,pc
8000a900:	93 1b       	st.w	r9[0x4],r11
8000a902:	58 0c       	cp.w	r12,0
8000a904:	c0 30       	breq	8000a90a <_free_r+0x72>
8000a906:	30 0c       	mov	r12,0
8000a908:	c1 08       	rjmp	8000a928 <_free_r+0x90>
8000a90a:	6c 0e       	ld.w	lr,r6[0x0]
8000a90c:	f4 c5 ff f8 	sub	r5,r10,-8
8000a910:	1c 16       	sub	r6,lr
8000a912:	1c 08       	add	r8,lr
8000a914:	6c 2e       	ld.w	lr,r6[0x8]
8000a916:	0a 3e       	cp.w	lr,r5
8000a918:	f9 bc 00 01 	moveq	r12,1
8000a91c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a920:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a924:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a928:	f2 0b 00 0e 	add	lr,r9,r11
8000a92c:	7c 1e       	ld.w	lr,lr[0x4]
8000a92e:	ed be 00 00 	bld	lr,0x0
8000a932:	c1 40       	breq	8000a95a <_free_r+0xc2>
8000a934:	16 08       	add	r8,r11
8000a936:	58 0c       	cp.w	r12,0
8000a938:	c0 d1       	brne	8000a952 <_free_r+0xba>
8000a93a:	e0 6e 05 44 	mov	lr,1348
8000a93e:	72 2b       	ld.w	r11,r9[0x8]
8000a940:	2f 8e       	sub	lr,-8
8000a942:	1c 3b       	cp.w	r11,lr
8000a944:	c0 71       	brne	8000a952 <_free_r+0xba>
8000a946:	97 36       	st.w	r11[0xc],r6
8000a948:	97 26       	st.w	r11[0x8],r6
8000a94a:	8d 2b       	st.w	r6[0x8],r11
8000a94c:	8d 3b       	st.w	r6[0xc],r11
8000a94e:	30 1c       	mov	r12,1
8000a950:	c0 58       	rjmp	8000a95a <_free_r+0xc2>
8000a952:	72 2b       	ld.w	r11,r9[0x8]
8000a954:	72 39       	ld.w	r9,r9[0xc]
8000a956:	93 2b       	st.w	r9[0x8],r11
8000a958:	97 39       	st.w	r11[0xc],r9
8000a95a:	10 99       	mov	r9,r8
8000a95c:	ec 08 09 08 	st.w	r6[r8],r8
8000a960:	a1 a9       	sbr	r9,0x0
8000a962:	8d 19       	st.w	r6[0x4],r9
8000a964:	58 0c       	cp.w	r12,0
8000a966:	c5 a1       	brne	8000aa1a <_free_r+0x182>
8000a968:	e0 48 01 ff 	cp.w	r8,511
8000a96c:	e0 8b 00 13 	brhi	8000a992 <_free_r+0xfa>
8000a970:	a3 98       	lsr	r8,0x3
8000a972:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a976:	72 2b       	ld.w	r11,r9[0x8]
8000a978:	8d 39       	st.w	r6[0xc],r9
8000a97a:	8d 2b       	st.w	r6[0x8],r11
8000a97c:	97 36       	st.w	r11[0xc],r6
8000a97e:	93 26       	st.w	r9[0x8],r6
8000a980:	a3 48       	asr	r8,0x2
8000a982:	74 19       	ld.w	r9,r10[0x4]
8000a984:	30 1b       	mov	r11,1
8000a986:	f6 08 09 48 	lsl	r8,r11,r8
8000a98a:	f3 e8 10 08 	or	r8,r9,r8
8000a98e:	95 18       	st.w	r10[0x4],r8
8000a990:	c4 58       	rjmp	8000aa1a <_free_r+0x182>
8000a992:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a996:	58 4b       	cp.w	r11,4
8000a998:	e0 8b 00 06 	brhi	8000a9a4 <_free_r+0x10c>
8000a99c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a9a0:	2c 8b       	sub	r11,-56
8000a9a2:	c2 08       	rjmp	8000a9e2 <_free_r+0x14a>
8000a9a4:	59 4b       	cp.w	r11,20
8000a9a6:	e0 8b 00 04 	brhi	8000a9ae <_free_r+0x116>
8000a9aa:	2a 5b       	sub	r11,-91
8000a9ac:	c1 b8       	rjmp	8000a9e2 <_free_r+0x14a>
8000a9ae:	e0 4b 00 54 	cp.w	r11,84
8000a9b2:	e0 8b 00 06 	brhi	8000a9be <_free_r+0x126>
8000a9b6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a9ba:	29 2b       	sub	r11,-110
8000a9bc:	c1 38       	rjmp	8000a9e2 <_free_r+0x14a>
8000a9be:	e0 4b 01 54 	cp.w	r11,340
8000a9c2:	e0 8b 00 06 	brhi	8000a9ce <_free_r+0x136>
8000a9c6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a9ca:	28 9b       	sub	r11,-119
8000a9cc:	c0 b8       	rjmp	8000a9e2 <_free_r+0x14a>
8000a9ce:	e0 4b 05 54 	cp.w	r11,1364
8000a9d2:	e0 88 00 05 	brls	8000a9dc <_free_r+0x144>
8000a9d6:	37 eb       	mov	r11,126
8000a9d8:	c0 58       	rjmp	8000a9e2 <_free_r+0x14a>
8000a9da:	d7 03       	nop
8000a9dc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a9e0:	28 4b       	sub	r11,-124
8000a9e2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a9e6:	78 29       	ld.w	r9,r12[0x8]
8000a9e8:	18 39       	cp.w	r9,r12
8000a9ea:	c0 e1       	brne	8000aa06 <_free_r+0x16e>
8000a9ec:	74 18       	ld.w	r8,r10[0x4]
8000a9ee:	a3 4b       	asr	r11,0x2
8000a9f0:	30 1c       	mov	r12,1
8000a9f2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a9f6:	f1 eb 10 0b 	or	r11,r8,r11
8000a9fa:	12 98       	mov	r8,r9
8000a9fc:	95 1b       	st.w	r10[0x4],r11
8000a9fe:	c0 a8       	rjmp	8000aa12 <_free_r+0x17a>
8000aa00:	72 29       	ld.w	r9,r9[0x8]
8000aa02:	18 39       	cp.w	r9,r12
8000aa04:	c0 60       	breq	8000aa10 <_free_r+0x178>
8000aa06:	72 1a       	ld.w	r10,r9[0x4]
8000aa08:	e0 1a ff fc 	andl	r10,0xfffc
8000aa0c:	14 38       	cp.w	r8,r10
8000aa0e:	cf 93       	brcs	8000aa00 <_free_r+0x168>
8000aa10:	72 38       	ld.w	r8,r9[0xc]
8000aa12:	8d 38       	st.w	r6[0xc],r8
8000aa14:	8d 29       	st.w	r6[0x8],r9
8000aa16:	93 36       	st.w	r9[0xc],r6
8000aa18:	91 26       	st.w	r8[0x8],r6
8000aa1a:	0e 9c       	mov	r12,r7
8000aa1c:	fe b0 d6 60 	rcall	800056dc <__malloc_unlock>
8000aa20:	d8 22       	popm	r4-r7,pc
8000aa22:	d7 03       	nop

8000aa24 <__sfvwrite_r>:
8000aa24:	d4 31       	pushm	r0-r7,lr
8000aa26:	20 3d       	sub	sp,12
8000aa28:	14 94       	mov	r4,r10
8000aa2a:	18 95       	mov	r5,r12
8000aa2c:	16 97       	mov	r7,r11
8000aa2e:	74 28       	ld.w	r8,r10[0x8]
8000aa30:	58 08       	cp.w	r8,0
8000aa32:	e0 80 01 40 	breq	8000acb2 <__sfvwrite_r+0x28e>
8000aa36:	96 68       	ld.sh	r8,r11[0xc]
8000aa38:	ed b8 00 03 	bld	r8,0x3
8000aa3c:	c0 41       	brne	8000aa44 <__sfvwrite_r+0x20>
8000aa3e:	76 48       	ld.w	r8,r11[0x10]
8000aa40:	58 08       	cp.w	r8,0
8000aa42:	c0 c1       	brne	8000aa5a <__sfvwrite_r+0x36>
8000aa44:	0e 9b       	mov	r11,r7
8000aa46:	0a 9c       	mov	r12,r5
8000aa48:	fe b0 f6 c4 	rcall	800097d0 <__swsetup_r>
8000aa4c:	c0 70       	breq	8000aa5a <__sfvwrite_r+0x36>
8000aa4e:	8e 68       	ld.sh	r8,r7[0xc]
8000aa50:	a7 a8       	sbr	r8,0x6
8000aa52:	ae 68       	st.h	r7[0xc],r8
8000aa54:	30 98       	mov	r8,9
8000aa56:	8b 38       	st.w	r5[0xc],r8
8000aa58:	c2 b9       	rjmp	8000acae <__sfvwrite_r+0x28a>
8000aa5a:	8e 63       	ld.sh	r3,r7[0xc]
8000aa5c:	68 00       	ld.w	r0,r4[0x0]
8000aa5e:	06 96       	mov	r6,r3
8000aa60:	e2 16 00 02 	andl	r6,0x2,COH
8000aa64:	c2 10       	breq	8000aaa6 <__sfvwrite_r+0x82>
8000aa66:	30 03       	mov	r3,0
8000aa68:	e0 62 04 00 	mov	r2,1024
8000aa6c:	06 96       	mov	r6,r3
8000aa6e:	c0 48       	rjmp	8000aa76 <__sfvwrite_r+0x52>
8000aa70:	60 03       	ld.w	r3,r0[0x0]
8000aa72:	60 16       	ld.w	r6,r0[0x4]
8000aa74:	2f 80       	sub	r0,-8
8000aa76:	58 06       	cp.w	r6,0
8000aa78:	cf c0       	breq	8000aa70 <__sfvwrite_r+0x4c>
8000aa7a:	e0 46 04 00 	cp.w	r6,1024
8000aa7e:	ec 09 17 80 	movls	r9,r6
8000aa82:	e4 09 17 b0 	movhi	r9,r2
8000aa86:	06 9a       	mov	r10,r3
8000aa88:	6e a8       	ld.w	r8,r7[0x28]
8000aa8a:	6e 8b       	ld.w	r11,r7[0x20]
8000aa8c:	0a 9c       	mov	r12,r5
8000aa8e:	5d 18       	icall	r8
8000aa90:	18 16       	sub	r6,r12
8000aa92:	58 0c       	cp.w	r12,0
8000aa94:	e0 8a 01 0a 	brle	8000aca8 <__sfvwrite_r+0x284>
8000aa98:	68 28       	ld.w	r8,r4[0x8]
8000aa9a:	18 18       	sub	r8,r12
8000aa9c:	89 28       	st.w	r4[0x8],r8
8000aa9e:	e0 80 01 0a 	breq	8000acb2 <__sfvwrite_r+0x28e>
8000aaa2:	18 03       	add	r3,r12
8000aaa4:	ce 9b       	rjmp	8000aa76 <__sfvwrite_r+0x52>
8000aaa6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000aaaa:	c0 70       	breq	8000aab8 <__sfvwrite_r+0x94>
8000aaac:	50 06       	stdsp	sp[0x0],r6
8000aaae:	0c 93       	mov	r3,r6
8000aab0:	0c 91       	mov	r1,r6
8000aab2:	50 15       	stdsp	sp[0x4],r5
8000aab4:	08 92       	mov	r2,r4
8000aab6:	c9 c8       	rjmp	8000abee <__sfvwrite_r+0x1ca>
8000aab8:	06 96       	mov	r6,r3
8000aaba:	08 91       	mov	r1,r4
8000aabc:	c0 48       	rjmp	8000aac4 <__sfvwrite_r+0xa0>
8000aabe:	60 03       	ld.w	r3,r0[0x0]
8000aac0:	60 16       	ld.w	r6,r0[0x4]
8000aac2:	2f 80       	sub	r0,-8
8000aac4:	58 06       	cp.w	r6,0
8000aac6:	cf c0       	breq	8000aabe <__sfvwrite_r+0x9a>
8000aac8:	8e 68       	ld.sh	r8,r7[0xc]
8000aaca:	6e 24       	ld.w	r4,r7[0x8]
8000aacc:	10 99       	mov	r9,r8
8000aace:	e2 19 02 00 	andl	r9,0x200,COH
8000aad2:	c5 50       	breq	8000ab7c <__sfvwrite_r+0x158>
8000aad4:	08 36       	cp.w	r6,r4
8000aad6:	c4 43       	brcs	8000ab5e <__sfvwrite_r+0x13a>
8000aad8:	10 99       	mov	r9,r8
8000aada:	e2 19 04 80 	andl	r9,0x480,COH
8000aade:	c4 00       	breq	8000ab5e <__sfvwrite_r+0x13a>
8000aae0:	6e 4b       	ld.w	r11,r7[0x10]
8000aae2:	6e 09       	ld.w	r9,r7[0x0]
8000aae4:	16 19       	sub	r9,r11
8000aae6:	50 09       	stdsp	sp[0x0],r9
8000aae8:	6e 59       	ld.w	r9,r7[0x14]
8000aaea:	10 9c       	mov	r12,r8
8000aaec:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000aaf0:	30 28       	mov	r8,2
8000aaf2:	f4 08 0c 08 	divs	r8,r10,r8
8000aaf6:	fa e9 00 04 	st.d	sp[4],r8
8000aafa:	10 94       	mov	r4,r8
8000aafc:	40 09       	lddsp	r9,sp[0x0]
8000aafe:	e2 1c 04 00 	andl	r12,0x400,COH
8000ab02:	2f f9       	sub	r9,-1
8000ab04:	0c 09       	add	r9,r6
8000ab06:	12 38       	cp.w	r8,r9
8000ab08:	f2 04 17 30 	movlo	r4,r9
8000ab0c:	58 0c       	cp.w	r12,0
8000ab0e:	c1 10       	breq	8000ab30 <__sfvwrite_r+0x10c>
8000ab10:	08 9b       	mov	r11,r4
8000ab12:	0a 9c       	mov	r12,r5
8000ab14:	fe b0 e0 60 	rcall	80006bd4 <_malloc_r>
8000ab18:	18 92       	mov	r2,r12
8000ab1a:	c1 40       	breq	8000ab42 <__sfvwrite_r+0x11e>
8000ab1c:	40 0a       	lddsp	r10,sp[0x0]
8000ab1e:	6e 4b       	ld.w	r11,r7[0x10]
8000ab20:	fe b0 e2 76 	rcall	8000700c <memcpy>
8000ab24:	8e 68       	ld.sh	r8,r7[0xc]
8000ab26:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ab2a:	a7 b8       	sbr	r8,0x7
8000ab2c:	ae 68       	st.h	r7[0xc],r8
8000ab2e:	c0 d8       	rjmp	8000ab48 <__sfvwrite_r+0x124>
8000ab30:	08 9a       	mov	r10,r4
8000ab32:	0a 9c       	mov	r12,r5
8000ab34:	fe b0 e3 18 	rcall	80007164 <_realloc_r>
8000ab38:	18 92       	mov	r2,r12
8000ab3a:	c0 71       	brne	8000ab48 <__sfvwrite_r+0x124>
8000ab3c:	6e 4b       	ld.w	r11,r7[0x10]
8000ab3e:	0a 9c       	mov	r12,r5
8000ab40:	ca ce       	rcall	8000a898 <_free_r>
8000ab42:	30 c8       	mov	r8,12
8000ab44:	8b 38       	st.w	r5[0xc],r8
8000ab46:	cb 18       	rjmp	8000aca8 <__sfvwrite_r+0x284>
8000ab48:	40 0a       	lddsp	r10,sp[0x0]
8000ab4a:	40 09       	lddsp	r9,sp[0x0]
8000ab4c:	e8 0a 01 0a 	sub	r10,r4,r10
8000ab50:	e4 09 00 08 	add	r8,r2,r9
8000ab54:	8f 54       	st.w	r7[0x14],r4
8000ab56:	8f 2a       	st.w	r7[0x8],r10
8000ab58:	8f 08       	st.w	r7[0x0],r8
8000ab5a:	8f 42       	st.w	r7[0x10],r2
8000ab5c:	0c 94       	mov	r4,r6
8000ab5e:	08 36       	cp.w	r6,r4
8000ab60:	ec 04 17 30 	movlo	r4,r6
8000ab64:	06 9b       	mov	r11,r3
8000ab66:	08 9a       	mov	r10,r4
8000ab68:	6e 0c       	ld.w	r12,r7[0x0]
8000ab6a:	c3 ad       	rcall	8000adde <memmove>
8000ab6c:	6e 08       	ld.w	r8,r7[0x0]
8000ab6e:	08 08       	add	r8,r4
8000ab70:	8f 08       	st.w	r7[0x0],r8
8000ab72:	6e 28       	ld.w	r8,r7[0x8]
8000ab74:	08 18       	sub	r8,r4
8000ab76:	0c 94       	mov	r4,r6
8000ab78:	8f 28       	st.w	r7[0x8],r8
8000ab7a:	c2 e8       	rjmp	8000abd6 <__sfvwrite_r+0x1b2>
8000ab7c:	08 36       	cp.w	r6,r4
8000ab7e:	5f ba       	srhi	r10
8000ab80:	6e 0c       	ld.w	r12,r7[0x0]
8000ab82:	6e 48       	ld.w	r8,r7[0x10]
8000ab84:	10 3c       	cp.w	r12,r8
8000ab86:	5f b8       	srhi	r8
8000ab88:	f5 e8 00 08 	and	r8,r10,r8
8000ab8c:	f2 08 18 00 	cp.b	r8,r9
8000ab90:	c0 d0       	breq	8000abaa <__sfvwrite_r+0x186>
8000ab92:	06 9b       	mov	r11,r3
8000ab94:	08 9a       	mov	r10,r4
8000ab96:	c2 4d       	rcall	8000adde <memmove>
8000ab98:	6e 08       	ld.w	r8,r7[0x0]
8000ab9a:	08 08       	add	r8,r4
8000ab9c:	0e 9b       	mov	r11,r7
8000ab9e:	8f 08       	st.w	r7[0x0],r8
8000aba0:	0a 9c       	mov	r12,r5
8000aba2:	fe b0 fd 09 	rcall	8000a5b4 <_fflush_r>
8000aba6:	c1 80       	breq	8000abd6 <__sfvwrite_r+0x1b2>
8000aba8:	c8 08       	rjmp	8000aca8 <__sfvwrite_r+0x284>
8000abaa:	6e 59       	ld.w	r9,r7[0x14]
8000abac:	12 36       	cp.w	r6,r9
8000abae:	c0 a3       	brcs	8000abc2 <__sfvwrite_r+0x19e>
8000abb0:	6e a8       	ld.w	r8,r7[0x28]
8000abb2:	06 9a       	mov	r10,r3
8000abb4:	6e 8b       	ld.w	r11,r7[0x20]
8000abb6:	0a 9c       	mov	r12,r5
8000abb8:	5d 18       	icall	r8
8000abba:	18 94       	mov	r4,r12
8000abbc:	e0 89 00 0d 	brgt	8000abd6 <__sfvwrite_r+0x1b2>
8000abc0:	c7 48       	rjmp	8000aca8 <__sfvwrite_r+0x284>
8000abc2:	0c 9a       	mov	r10,r6
8000abc4:	06 9b       	mov	r11,r3
8000abc6:	c0 cd       	rcall	8000adde <memmove>
8000abc8:	6e 08       	ld.w	r8,r7[0x0]
8000abca:	0c 08       	add	r8,r6
8000abcc:	0c 94       	mov	r4,r6
8000abce:	8f 08       	st.w	r7[0x0],r8
8000abd0:	6e 28       	ld.w	r8,r7[0x8]
8000abd2:	0c 18       	sub	r8,r6
8000abd4:	8f 28       	st.w	r7[0x8],r8
8000abd6:	62 28       	ld.w	r8,r1[0x8]
8000abd8:	08 18       	sub	r8,r4
8000abda:	83 28       	st.w	r1[0x8],r8
8000abdc:	c6 b0       	breq	8000acb2 <__sfvwrite_r+0x28e>
8000abde:	08 16       	sub	r6,r4
8000abe0:	08 03       	add	r3,r4
8000abe2:	c7 1b       	rjmp	8000aac4 <__sfvwrite_r+0xa0>
8000abe4:	60 03       	ld.w	r3,r0[0x0]
8000abe6:	60 11       	ld.w	r1,r0[0x4]
8000abe8:	30 08       	mov	r8,0
8000abea:	2f 80       	sub	r0,-8
8000abec:	50 08       	stdsp	sp[0x0],r8
8000abee:	58 01       	cp.w	r1,0
8000abf0:	cf a0       	breq	8000abe4 <__sfvwrite_r+0x1c0>
8000abf2:	40 0a       	lddsp	r10,sp[0x0]
8000abf4:	58 0a       	cp.w	r10,0
8000abf6:	c1 41       	brne	8000ac1e <__sfvwrite_r+0x1fa>
8000abf8:	e2 c6 ff ff 	sub	r6,r1,-1
8000abfc:	02 9a       	mov	r10,r1
8000abfe:	30 ab       	mov	r11,10
8000ac00:	06 9c       	mov	r12,r3
8000ac02:	ce 3c       	rcall	8000adc8 <memchr>
8000ac04:	f8 c8 ff ff 	sub	r8,r12,-1
8000ac08:	58 0c       	cp.w	r12,0
8000ac0a:	f1 d3 e1 16 	subne	r6,r8,r3
8000ac0e:	f9 b9 01 01 	movne	r9,1
8000ac12:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ac16:	f9 b8 00 01 	moveq	r8,1
8000ac1a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ac1e:	02 36       	cp.w	r6,r1
8000ac20:	ec 04 17 80 	movls	r4,r6
8000ac24:	e2 04 17 b0 	movhi	r4,r1
8000ac28:	6e 59       	ld.w	r9,r7[0x14]
8000ac2a:	6e 25       	ld.w	r5,r7[0x8]
8000ac2c:	f2 05 00 05 	add	r5,r9,r5
8000ac30:	0a 34       	cp.w	r4,r5
8000ac32:	5f 9a       	srgt	r10
8000ac34:	6e 0c       	ld.w	r12,r7[0x0]
8000ac36:	6e 48       	ld.w	r8,r7[0x10]
8000ac38:	10 3c       	cp.w	r12,r8
8000ac3a:	5f b8       	srhi	r8
8000ac3c:	f5 e8 00 08 	and	r8,r10,r8
8000ac40:	30 0a       	mov	r10,0
8000ac42:	f4 08 18 00 	cp.b	r8,r10
8000ac46:	c0 d0       	breq	8000ac60 <__sfvwrite_r+0x23c>
8000ac48:	06 9b       	mov	r11,r3
8000ac4a:	0a 9a       	mov	r10,r5
8000ac4c:	cc 9c       	rcall	8000adde <memmove>
8000ac4e:	6e 08       	ld.w	r8,r7[0x0]
8000ac50:	0a 08       	add	r8,r5
8000ac52:	0e 9b       	mov	r11,r7
8000ac54:	8f 08       	st.w	r7[0x0],r8
8000ac56:	40 1c       	lddsp	r12,sp[0x4]
8000ac58:	fe b0 fc ae 	rcall	8000a5b4 <_fflush_r>
8000ac5c:	c1 70       	breq	8000ac8a <__sfvwrite_r+0x266>
8000ac5e:	c2 58       	rjmp	8000aca8 <__sfvwrite_r+0x284>
8000ac60:	12 34       	cp.w	r4,r9
8000ac62:	c0 a5       	brlt	8000ac76 <__sfvwrite_r+0x252>
8000ac64:	6e a8       	ld.w	r8,r7[0x28]
8000ac66:	06 9a       	mov	r10,r3
8000ac68:	6e 8b       	ld.w	r11,r7[0x20]
8000ac6a:	40 1c       	lddsp	r12,sp[0x4]
8000ac6c:	5d 18       	icall	r8
8000ac6e:	18 95       	mov	r5,r12
8000ac70:	e0 89 00 0d 	brgt	8000ac8a <__sfvwrite_r+0x266>
8000ac74:	c1 a8       	rjmp	8000aca8 <__sfvwrite_r+0x284>
8000ac76:	08 9a       	mov	r10,r4
8000ac78:	06 9b       	mov	r11,r3
8000ac7a:	cb 2c       	rcall	8000adde <memmove>
8000ac7c:	6e 08       	ld.w	r8,r7[0x0]
8000ac7e:	08 08       	add	r8,r4
8000ac80:	08 95       	mov	r5,r4
8000ac82:	8f 08       	st.w	r7[0x0],r8
8000ac84:	6e 28       	ld.w	r8,r7[0x8]
8000ac86:	08 18       	sub	r8,r4
8000ac88:	8f 28       	st.w	r7[0x8],r8
8000ac8a:	0a 16       	sub	r6,r5
8000ac8c:	c0 71       	brne	8000ac9a <__sfvwrite_r+0x276>
8000ac8e:	0e 9b       	mov	r11,r7
8000ac90:	40 1c       	lddsp	r12,sp[0x4]
8000ac92:	fe b0 fc 91 	rcall	8000a5b4 <_fflush_r>
8000ac96:	c0 91       	brne	8000aca8 <__sfvwrite_r+0x284>
8000ac98:	50 06       	stdsp	sp[0x0],r6
8000ac9a:	64 28       	ld.w	r8,r2[0x8]
8000ac9c:	0a 18       	sub	r8,r5
8000ac9e:	85 28       	st.w	r2[0x8],r8
8000aca0:	c0 90       	breq	8000acb2 <__sfvwrite_r+0x28e>
8000aca2:	0a 11       	sub	r1,r5
8000aca4:	0a 03       	add	r3,r5
8000aca6:	ca 4b       	rjmp	8000abee <__sfvwrite_r+0x1ca>
8000aca8:	8e 68       	ld.sh	r8,r7[0xc]
8000acaa:	a7 a8       	sbr	r8,0x6
8000acac:	ae 68       	st.h	r7[0xc],r8
8000acae:	3f fc       	mov	r12,-1
8000acb0:	c0 28       	rjmp	8000acb4 <__sfvwrite_r+0x290>
8000acb2:	30 0c       	mov	r12,0
8000acb4:	2f dd       	sub	sp,-12
8000acb6:	d8 32       	popm	r0-r7,pc

8000acb8 <_fwalk>:
8000acb8:	d4 31       	pushm	r0-r7,lr
8000acba:	30 05       	mov	r5,0
8000acbc:	16 91       	mov	r1,r11
8000acbe:	f8 c7 ff 28 	sub	r7,r12,-216
8000acc2:	0a 92       	mov	r2,r5
8000acc4:	fe b0 fc fe 	rcall	8000a6c0 <__sfp_lock_acquire>
8000acc8:	3f f3       	mov	r3,-1
8000acca:	c1 68       	rjmp	8000acf6 <_fwalk+0x3e>
8000accc:	6e 26       	ld.w	r6,r7[0x8]
8000acce:	6e 14       	ld.w	r4,r7[0x4]
8000acd0:	2f 46       	sub	r6,-12
8000acd2:	c0 c8       	rjmp	8000acea <_fwalk+0x32>
8000acd4:	8c 08       	ld.sh	r8,r6[0x0]
8000acd6:	e4 08 19 00 	cp.h	r8,r2
8000acda:	c0 70       	breq	8000ace8 <_fwalk+0x30>
8000acdc:	8c 18       	ld.sh	r8,r6[0x2]
8000acde:	e6 08 19 00 	cp.h	r8,r3
8000ace2:	c0 30       	breq	8000ace8 <_fwalk+0x30>
8000ace4:	5d 11       	icall	r1
8000ace6:	18 45       	or	r5,r12
8000ace8:	2a 46       	sub	r6,-92
8000acea:	20 14       	sub	r4,1
8000acec:	ec cc 00 0c 	sub	r12,r6,12
8000acf0:	58 04       	cp.w	r4,0
8000acf2:	cf 14       	brge	8000acd4 <_fwalk+0x1c>
8000acf4:	6e 07       	ld.w	r7,r7[0x0]
8000acf6:	58 07       	cp.w	r7,0
8000acf8:	ce a1       	brne	8000accc <_fwalk+0x14>
8000acfa:	fe b0 fc e4 	rcall	8000a6c2 <__sfp_lock_release>
8000acfe:	0a 9c       	mov	r12,r5
8000ad00:	d8 32       	popm	r0-r7,pc
8000ad02:	d7 03       	nop

8000ad04 <_localeconv_r>:
8000ad04:	fe cc d4 34 	sub	r12,pc,-11212
8000ad08:	5e fc       	retal	r12
8000ad0a:	d7 03       	nop

8000ad0c <__smakebuf_r>:
8000ad0c:	d4 21       	pushm	r4-r7,lr
8000ad0e:	20 fd       	sub	sp,60
8000ad10:	96 68       	ld.sh	r8,r11[0xc]
8000ad12:	16 97       	mov	r7,r11
8000ad14:	18 96       	mov	r6,r12
8000ad16:	e2 18 00 02 	andl	r8,0x2,COH
8000ad1a:	c3 d1       	brne	8000ad94 <__smakebuf_r+0x88>
8000ad1c:	96 7b       	ld.sh	r11,r11[0xe]
8000ad1e:	f0 0b 19 00 	cp.h	r11,r8
8000ad22:	c0 55       	brlt	8000ad2c <__smakebuf_r+0x20>
8000ad24:	1a 9a       	mov	r10,sp
8000ad26:	e0 a0 04 75 	rcall	8000b610 <_fstat_r>
8000ad2a:	c0 f4       	brge	8000ad48 <__smakebuf_r+0x3c>
8000ad2c:	8e 65       	ld.sh	r5,r7[0xc]
8000ad2e:	0a 98       	mov	r8,r5
8000ad30:	ab b8       	sbr	r8,0xb
8000ad32:	e2 15 00 80 	andl	r5,0x80,COH
8000ad36:	ae 68       	st.h	r7[0xc],r8
8000ad38:	30 04       	mov	r4,0
8000ad3a:	e0 68 04 00 	mov	r8,1024
8000ad3e:	f9 b5 01 40 	movne	r5,64
8000ad42:	f0 05 17 00 	moveq	r5,r8
8000ad46:	c1 c8       	rjmp	8000ad7e <__smakebuf_r+0x72>
8000ad48:	40 18       	lddsp	r8,sp[0x4]
8000ad4a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ad4e:	e0 48 20 00 	cp.w	r8,8192
8000ad52:	5f 04       	sreq	r4
8000ad54:	e0 48 80 00 	cp.w	r8,32768
8000ad58:	c0 e1       	brne	8000ad74 <__smakebuf_r+0x68>
8000ad5a:	6e b9       	ld.w	r9,r7[0x2c]
8000ad5c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000ad60:	10 39       	cp.w	r9,r8
8000ad62:	c0 91       	brne	8000ad74 <__smakebuf_r+0x68>
8000ad64:	8e 68       	ld.sh	r8,r7[0xc]
8000ad66:	e0 65 04 00 	mov	r5,1024
8000ad6a:	ab a8       	sbr	r8,0xa
8000ad6c:	ef 45 00 50 	st.w	r7[80],r5
8000ad70:	ae 68       	st.h	r7[0xc],r8
8000ad72:	c0 68       	rjmp	8000ad7e <__smakebuf_r+0x72>
8000ad74:	8e 68       	ld.sh	r8,r7[0xc]
8000ad76:	e0 65 04 00 	mov	r5,1024
8000ad7a:	ab b8       	sbr	r8,0xb
8000ad7c:	ae 68       	st.h	r7[0xc],r8
8000ad7e:	0a 9b       	mov	r11,r5
8000ad80:	0c 9c       	mov	r12,r6
8000ad82:	fe b0 df 29 	rcall	80006bd4 <_malloc_r>
8000ad86:	8e 68       	ld.sh	r8,r7[0xc]
8000ad88:	c0 d1       	brne	8000ada2 <__smakebuf_r+0x96>
8000ad8a:	ed b8 00 09 	bld	r8,0x9
8000ad8e:	c1 b0       	breq	8000adc4 <__smakebuf_r+0xb8>
8000ad90:	a1 b8       	sbr	r8,0x1
8000ad92:	ae 68       	st.h	r7[0xc],r8
8000ad94:	ee c8 ff b9 	sub	r8,r7,-71
8000ad98:	8f 48       	st.w	r7[0x10],r8
8000ad9a:	8f 08       	st.w	r7[0x0],r8
8000ad9c:	30 18       	mov	r8,1
8000ad9e:	8f 58       	st.w	r7[0x14],r8
8000ada0:	c1 28       	rjmp	8000adc4 <__smakebuf_r+0xb8>
8000ada2:	a7 b8       	sbr	r8,0x7
8000ada4:	8f 4c       	st.w	r7[0x10],r12
8000ada6:	ae 68       	st.h	r7[0xc],r8
8000ada8:	8f 55       	st.w	r7[0x14],r5
8000adaa:	fe c8 06 e6 	sub	r8,pc,1766
8000adae:	8f 0c       	st.w	r7[0x0],r12
8000adb0:	8d a8       	st.w	r6[0x28],r8
8000adb2:	58 04       	cp.w	r4,0
8000adb4:	c0 80       	breq	8000adc4 <__smakebuf_r+0xb8>
8000adb6:	8e 7c       	ld.sh	r12,r7[0xe]
8000adb8:	fe b0 e3 94 	rcall	800074e0 <isatty>
8000adbc:	c0 40       	breq	8000adc4 <__smakebuf_r+0xb8>
8000adbe:	8e 68       	ld.sh	r8,r7[0xc]
8000adc0:	a1 a8       	sbr	r8,0x0
8000adc2:	ae 68       	st.h	r7[0xc],r8
8000adc4:	2f 1d       	sub	sp,-60
8000adc6:	d8 22       	popm	r4-r7,pc

8000adc8 <memchr>:
8000adc8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000adcc:	c0 68       	rjmp	8000add8 <memchr+0x10>
8000adce:	20 1a       	sub	r10,1
8000add0:	19 88       	ld.ub	r8,r12[0x0]
8000add2:	16 38       	cp.w	r8,r11
8000add4:	5e 0c       	reteq	r12
8000add6:	2f fc       	sub	r12,-1
8000add8:	58 0a       	cp.w	r10,0
8000adda:	cf a1       	brne	8000adce <memchr+0x6>
8000addc:	5e fa       	retal	r10

8000adde <memmove>:
8000adde:	d4 01       	pushm	lr
8000ade0:	18 3b       	cp.w	r11,r12
8000ade2:	c1 92       	brcc	8000ae14 <memmove+0x36>
8000ade4:	f6 0a 00 09 	add	r9,r11,r10
8000ade8:	12 3c       	cp.w	r12,r9
8000adea:	c1 52       	brcc	8000ae14 <memmove+0x36>
8000adec:	f8 0a 00 0b 	add	r11,r12,r10
8000adf0:	30 08       	mov	r8,0
8000adf2:	c0 68       	rjmp	8000adfe <memmove+0x20>
8000adf4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000adf8:	20 1a       	sub	r10,1
8000adfa:	f6 08 0b 0e 	st.b	r11[r8],lr
8000adfe:	20 18       	sub	r8,1
8000ae00:	58 0a       	cp.w	r10,0
8000ae02:	cf 91       	brne	8000adf4 <memmove+0x16>
8000ae04:	d8 02       	popm	pc
8000ae06:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ae0a:	20 1a       	sub	r10,1
8000ae0c:	f8 08 0b 09 	st.b	r12[r8],r9
8000ae10:	2f f8       	sub	r8,-1
8000ae12:	c0 28       	rjmp	8000ae16 <memmove+0x38>
8000ae14:	30 08       	mov	r8,0
8000ae16:	58 0a       	cp.w	r10,0
8000ae18:	cf 71       	brne	8000ae06 <memmove+0x28>
8000ae1a:	d8 02       	popm	pc

8000ae1c <__hi0bits>:
8000ae1c:	18 98       	mov	r8,r12
8000ae1e:	e0 1c 00 00 	andl	r12,0x0
8000ae22:	f0 09 15 10 	lsl	r9,r8,0x10
8000ae26:	58 0c       	cp.w	r12,0
8000ae28:	f2 08 17 00 	moveq	r8,r9
8000ae2c:	f9 bc 00 10 	moveq	r12,16
8000ae30:	f9 bc 01 00 	movne	r12,0
8000ae34:	10 9a       	mov	r10,r8
8000ae36:	f0 09 15 08 	lsl	r9,r8,0x8
8000ae3a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ae3e:	f7 bc 00 f8 	subeq	r12,-8
8000ae42:	f2 08 17 00 	moveq	r8,r9
8000ae46:	10 9a       	mov	r10,r8
8000ae48:	f0 09 15 04 	lsl	r9,r8,0x4
8000ae4c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ae50:	f7 bc 00 fc 	subeq	r12,-4
8000ae54:	f2 08 17 00 	moveq	r8,r9
8000ae58:	10 9a       	mov	r10,r8
8000ae5a:	f0 09 15 02 	lsl	r9,r8,0x2
8000ae5e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ae62:	f7 bc 00 fe 	subeq	r12,-2
8000ae66:	f2 08 17 00 	moveq	r8,r9
8000ae6a:	58 08       	cp.w	r8,0
8000ae6c:	5e 5c       	retlt	r12
8000ae6e:	ed b8 00 1e 	bld	r8,0x1e
8000ae72:	f9 bc 01 20 	movne	r12,32
8000ae76:	f7 bc 00 ff 	subeq	r12,-1
8000ae7a:	5e fc       	retal	r12

8000ae7c <__lo0bits>:
8000ae7c:	18 99       	mov	r9,r12
8000ae7e:	78 08       	ld.w	r8,r12[0x0]
8000ae80:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ae84:	c1 50       	breq	8000aeae <__lo0bits+0x32>
8000ae86:	ed b8 00 00 	bld	r8,0x0
8000ae8a:	c0 21       	brne	8000ae8e <__lo0bits+0x12>
8000ae8c:	5e fd       	retal	0
8000ae8e:	10 9b       	mov	r11,r8
8000ae90:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ae94:	e2 1b 00 02 	andl	r11,0x2,COH
8000ae98:	a3 88       	lsr	r8,0x2
8000ae9a:	58 0b       	cp.w	r11,0
8000ae9c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000aea0:	f9 bc 01 01 	movne	r12,1
8000aea4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000aea8:	f9 bc 00 02 	moveq	r12,2
8000aeac:	5e fc       	retal	r12
8000aeae:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aeb2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aeb6:	58 0a       	cp.w	r10,0
8000aeb8:	f6 08 17 00 	moveq	r8,r11
8000aebc:	f9 bc 00 10 	moveq	r12,16
8000aec0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aec4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000aec8:	58 0b       	cp.w	r11,0
8000aeca:	f7 bc 00 f8 	subeq	r12,-8
8000aece:	f4 08 17 00 	moveq	r8,r10
8000aed2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000aed6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000aeda:	58 0b       	cp.w	r11,0
8000aedc:	f7 bc 00 fc 	subeq	r12,-4
8000aee0:	f4 08 17 00 	moveq	r8,r10
8000aee4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000aee8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000aeec:	58 0b       	cp.w	r11,0
8000aeee:	f7 bc 00 fe 	subeq	r12,-2
8000aef2:	f4 08 17 00 	moveq	r8,r10
8000aef6:	ed b8 00 00 	bld	r8,0x0
8000aefa:	c0 60       	breq	8000af06 <__lo0bits+0x8a>
8000aefc:	a1 98       	lsr	r8,0x1
8000aefe:	c0 31       	brne	8000af04 <__lo0bits+0x88>
8000af00:	32 0c       	mov	r12,32
8000af02:	5e fc       	retal	r12
8000af04:	2f fc       	sub	r12,-1
8000af06:	93 08       	st.w	r9[0x0],r8
8000af08:	5e fc       	retal	r12

8000af0a <__mcmp>:
8000af0a:	d4 01       	pushm	lr
8000af0c:	18 98       	mov	r8,r12
8000af0e:	76 49       	ld.w	r9,r11[0x10]
8000af10:	78 4c       	ld.w	r12,r12[0x10]
8000af12:	12 1c       	sub	r12,r9
8000af14:	c1 31       	brne	8000af3a <__mcmp+0x30>
8000af16:	2f b9       	sub	r9,-5
8000af18:	a3 69       	lsl	r9,0x2
8000af1a:	12 0b       	add	r11,r9
8000af1c:	f0 09 00 09 	add	r9,r8,r9
8000af20:	2e c8       	sub	r8,-20
8000af22:	13 4e       	ld.w	lr,--r9
8000af24:	17 4a       	ld.w	r10,--r11
8000af26:	14 3e       	cp.w	lr,r10
8000af28:	c0 60       	breq	8000af34 <__mcmp+0x2a>
8000af2a:	f9 bc 03 ff 	movlo	r12,-1
8000af2e:	f9 bc 02 01 	movhs	r12,1
8000af32:	d8 02       	popm	pc
8000af34:	10 39       	cp.w	r9,r8
8000af36:	fe 9b ff f6 	brhi	8000af22 <__mcmp+0x18>
8000af3a:	d8 02       	popm	pc

8000af3c <_Bfree>:
8000af3c:	d4 21       	pushm	r4-r7,lr
8000af3e:	18 97       	mov	r7,r12
8000af40:	16 95       	mov	r5,r11
8000af42:	78 96       	ld.w	r6,r12[0x24]
8000af44:	58 06       	cp.w	r6,0
8000af46:	c0 91       	brne	8000af58 <_Bfree+0x1c>
8000af48:	31 0c       	mov	r12,16
8000af4a:	fe b0 de 3d 	rcall	80006bc4 <malloc>
8000af4e:	99 36       	st.w	r12[0xc],r6
8000af50:	8f 9c       	st.w	r7[0x24],r12
8000af52:	99 16       	st.w	r12[0x4],r6
8000af54:	99 26       	st.w	r12[0x8],r6
8000af56:	99 06       	st.w	r12[0x0],r6
8000af58:	58 05       	cp.w	r5,0
8000af5a:	c0 90       	breq	8000af6c <_Bfree+0x30>
8000af5c:	6a 19       	ld.w	r9,r5[0x4]
8000af5e:	6e 98       	ld.w	r8,r7[0x24]
8000af60:	70 38       	ld.w	r8,r8[0xc]
8000af62:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000af66:	8b 0a       	st.w	r5[0x0],r10
8000af68:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000af6c:	d8 22       	popm	r4-r7,pc
8000af6e:	d7 03       	nop

8000af70 <_Balloc>:
8000af70:	d4 21       	pushm	r4-r7,lr
8000af72:	18 97       	mov	r7,r12
8000af74:	16 96       	mov	r6,r11
8000af76:	78 95       	ld.w	r5,r12[0x24]
8000af78:	58 05       	cp.w	r5,0
8000af7a:	c0 91       	brne	8000af8c <_Balloc+0x1c>
8000af7c:	31 0c       	mov	r12,16
8000af7e:	fe b0 de 23 	rcall	80006bc4 <malloc>
8000af82:	99 35       	st.w	r12[0xc],r5
8000af84:	8f 9c       	st.w	r7[0x24],r12
8000af86:	99 15       	st.w	r12[0x4],r5
8000af88:	99 25       	st.w	r12[0x8],r5
8000af8a:	99 05       	st.w	r12[0x0],r5
8000af8c:	6e 95       	ld.w	r5,r7[0x24]
8000af8e:	6a 38       	ld.w	r8,r5[0xc]
8000af90:	58 08       	cp.w	r8,0
8000af92:	c0 b1       	brne	8000afa8 <_Balloc+0x38>
8000af94:	31 0a       	mov	r10,16
8000af96:	30 4b       	mov	r11,4
8000af98:	0e 9c       	mov	r12,r7
8000af9a:	e0 a0 02 9b 	rcall	8000b4d0 <_calloc_r>
8000af9e:	8b 3c       	st.w	r5[0xc],r12
8000afa0:	6e 98       	ld.w	r8,r7[0x24]
8000afa2:	70 3c       	ld.w	r12,r8[0xc]
8000afa4:	58 0c       	cp.w	r12,0
8000afa6:	c1 b0       	breq	8000afdc <_Balloc+0x6c>
8000afa8:	6e 98       	ld.w	r8,r7[0x24]
8000afaa:	70 38       	ld.w	r8,r8[0xc]
8000afac:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000afb0:	70 0c       	ld.w	r12,r8[0x0]
8000afb2:	58 0c       	cp.w	r12,0
8000afb4:	c0 40       	breq	8000afbc <_Balloc+0x4c>
8000afb6:	78 09       	ld.w	r9,r12[0x0]
8000afb8:	91 09       	st.w	r8[0x0],r9
8000afba:	c0 e8       	rjmp	8000afd6 <_Balloc+0x66>
8000afbc:	0e 9c       	mov	r12,r7
8000afbe:	30 17       	mov	r7,1
8000afc0:	0e 9b       	mov	r11,r7
8000afc2:	ee 06 09 47 	lsl	r7,r7,r6
8000afc6:	ee ca ff fb 	sub	r10,r7,-5
8000afca:	a3 6a       	lsl	r10,0x2
8000afcc:	e0 a0 02 82 	rcall	8000b4d0 <_calloc_r>
8000afd0:	c0 60       	breq	8000afdc <_Balloc+0x6c>
8000afd2:	99 16       	st.w	r12[0x4],r6
8000afd4:	99 27       	st.w	r12[0x8],r7
8000afd6:	30 08       	mov	r8,0
8000afd8:	99 38       	st.w	r12[0xc],r8
8000afda:	99 48       	st.w	r12[0x10],r8
8000afdc:	d8 22       	popm	r4-r7,pc
8000afde:	d7 03       	nop

8000afe0 <__d2b>:
8000afe0:	d4 31       	pushm	r0-r7,lr
8000afe2:	20 2d       	sub	sp,8
8000afe4:	16 93       	mov	r3,r11
8000afe6:	12 96       	mov	r6,r9
8000afe8:	10 95       	mov	r5,r8
8000afea:	14 92       	mov	r2,r10
8000afec:	30 1b       	mov	r11,1
8000afee:	cc 1f       	rcall	8000af70 <_Balloc>
8000aff0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000aff4:	50 09       	stdsp	sp[0x0],r9
8000aff6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000affa:	b5 a9       	sbr	r9,0x14
8000affc:	f0 01 16 14 	lsr	r1,r8,0x14
8000b000:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b004:	18 94       	mov	r4,r12
8000b006:	58 02       	cp.w	r2,0
8000b008:	c1 d0       	breq	8000b042 <__d2b+0x62>
8000b00a:	fa cc ff f8 	sub	r12,sp,-8
8000b00e:	18 d2       	st.w	--r12,r2
8000b010:	c3 6f       	rcall	8000ae7c <__lo0bits>
8000b012:	40 18       	lddsp	r8,sp[0x4]
8000b014:	c0 d0       	breq	8000b02e <__d2b+0x4e>
8000b016:	40 09       	lddsp	r9,sp[0x0]
8000b018:	f8 0a 11 20 	rsub	r10,r12,32
8000b01c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b020:	f5 e8 10 08 	or	r8,r10,r8
8000b024:	89 58       	st.w	r4[0x14],r8
8000b026:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b02a:	50 09       	stdsp	sp[0x0],r9
8000b02c:	c0 28       	rjmp	8000b030 <__d2b+0x50>
8000b02e:	89 58       	st.w	r4[0x14],r8
8000b030:	40 08       	lddsp	r8,sp[0x0]
8000b032:	58 08       	cp.w	r8,0
8000b034:	f9 b3 01 02 	movne	r3,2
8000b038:	f9 b3 00 01 	moveq	r3,1
8000b03c:	89 68       	st.w	r4[0x18],r8
8000b03e:	89 43       	st.w	r4[0x10],r3
8000b040:	c0 88       	rjmp	8000b050 <__d2b+0x70>
8000b042:	1a 9c       	mov	r12,sp
8000b044:	c1 cf       	rcall	8000ae7c <__lo0bits>
8000b046:	30 13       	mov	r3,1
8000b048:	40 08       	lddsp	r8,sp[0x0]
8000b04a:	2e 0c       	sub	r12,-32
8000b04c:	89 43       	st.w	r4[0x10],r3
8000b04e:	89 58       	st.w	r4[0x14],r8
8000b050:	58 01       	cp.w	r1,0
8000b052:	c0 90       	breq	8000b064 <__d2b+0x84>
8000b054:	e2 c1 04 33 	sub	r1,r1,1075
8000b058:	18 01       	add	r1,r12
8000b05a:	8d 01       	st.w	r6[0x0],r1
8000b05c:	f8 0c 11 35 	rsub	r12,r12,53
8000b060:	8b 0c       	st.w	r5[0x0],r12
8000b062:	c0 c8       	rjmp	8000b07a <__d2b+0x9a>
8000b064:	e6 c8 ff fc 	sub	r8,r3,-4
8000b068:	f8 cc 04 32 	sub	r12,r12,1074
8000b06c:	a5 73       	lsl	r3,0x5
8000b06e:	8d 0c       	st.w	r6[0x0],r12
8000b070:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b074:	cd 4e       	rcall	8000ae1c <__hi0bits>
8000b076:	18 13       	sub	r3,r12
8000b078:	8b 03       	st.w	r5[0x0],r3
8000b07a:	08 9c       	mov	r12,r4
8000b07c:	2f ed       	sub	sp,-8
8000b07e:	d8 32       	popm	r0-r7,pc

8000b080 <__mdiff>:
8000b080:	d4 31       	pushm	r0-r7,lr
8000b082:	74 48       	ld.w	r8,r10[0x10]
8000b084:	76 45       	ld.w	r5,r11[0x10]
8000b086:	16 97       	mov	r7,r11
8000b088:	14 96       	mov	r6,r10
8000b08a:	10 15       	sub	r5,r8
8000b08c:	c1 31       	brne	8000b0b2 <__mdiff+0x32>
8000b08e:	2f b8       	sub	r8,-5
8000b090:	ee ce ff ec 	sub	lr,r7,-20
8000b094:	a3 68       	lsl	r8,0x2
8000b096:	f4 08 00 0b 	add	r11,r10,r8
8000b09a:	ee 08 00 08 	add	r8,r7,r8
8000b09e:	11 4a       	ld.w	r10,--r8
8000b0a0:	17 49       	ld.w	r9,--r11
8000b0a2:	12 3a       	cp.w	r10,r9
8000b0a4:	c0 30       	breq	8000b0aa <__mdiff+0x2a>
8000b0a6:	c0 e2       	brcc	8000b0c2 <__mdiff+0x42>
8000b0a8:	c0 78       	rjmp	8000b0b6 <__mdiff+0x36>
8000b0aa:	1c 38       	cp.w	r8,lr
8000b0ac:	fe 9b ff f9 	brhi	8000b09e <__mdiff+0x1e>
8000b0b0:	c4 98       	rjmp	8000b142 <__mdiff+0xc2>
8000b0b2:	58 05       	cp.w	r5,0
8000b0b4:	c0 64       	brge	8000b0c0 <__mdiff+0x40>
8000b0b6:	0e 98       	mov	r8,r7
8000b0b8:	30 15       	mov	r5,1
8000b0ba:	0c 97       	mov	r7,r6
8000b0bc:	10 96       	mov	r6,r8
8000b0be:	c0 28       	rjmp	8000b0c2 <__mdiff+0x42>
8000b0c0:	30 05       	mov	r5,0
8000b0c2:	6e 1b       	ld.w	r11,r7[0x4]
8000b0c4:	c5 6f       	rcall	8000af70 <_Balloc>
8000b0c6:	6e 49       	ld.w	r9,r7[0x10]
8000b0c8:	6c 44       	ld.w	r4,r6[0x10]
8000b0ca:	99 35       	st.w	r12[0xc],r5
8000b0cc:	2f b4       	sub	r4,-5
8000b0ce:	f2 c5 ff fb 	sub	r5,r9,-5
8000b0d2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b0d6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b0da:	2e c6       	sub	r6,-20
8000b0dc:	2e c7       	sub	r7,-20
8000b0de:	f8 c8 ff ec 	sub	r8,r12,-20
8000b0e2:	30 0a       	mov	r10,0
8000b0e4:	0f 0e       	ld.w	lr,r7++
8000b0e6:	0d 0b       	ld.w	r11,r6++
8000b0e8:	fc 02 16 10 	lsr	r2,lr,0x10
8000b0ec:	f6 03 16 10 	lsr	r3,r11,0x10
8000b0f0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b0f4:	e4 03 01 03 	sub	r3,r2,r3
8000b0f8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b0fc:	fc 0b 01 0b 	sub	r11,lr,r11
8000b100:	f6 0a 00 0a 	add	r10,r11,r10
8000b104:	b0 1a       	st.h	r8[0x2],r10
8000b106:	b1 4a       	asr	r10,0x10
8000b108:	e6 0a 00 0a 	add	r10,r3,r10
8000b10c:	b0 0a       	st.h	r8[0x0],r10
8000b10e:	2f c8       	sub	r8,-4
8000b110:	b1 4a       	asr	r10,0x10
8000b112:	08 36       	cp.w	r6,r4
8000b114:	ce 83       	brcs	8000b0e4 <__mdiff+0x64>
8000b116:	c0 d8       	rjmp	8000b130 <__mdiff+0xb0>
8000b118:	0f 0b       	ld.w	r11,r7++
8000b11a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b11e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b122:	16 0a       	add	r10,r11
8000b124:	b0 1a       	st.h	r8[0x2],r10
8000b126:	b1 4a       	asr	r10,0x10
8000b128:	1c 0a       	add	r10,lr
8000b12a:	b0 0a       	st.h	r8[0x0],r10
8000b12c:	2f c8       	sub	r8,-4
8000b12e:	b1 4a       	asr	r10,0x10
8000b130:	0a 37       	cp.w	r7,r5
8000b132:	cf 33       	brcs	8000b118 <__mdiff+0x98>
8000b134:	c0 28       	rjmp	8000b138 <__mdiff+0xb8>
8000b136:	20 19       	sub	r9,1
8000b138:	11 4a       	ld.w	r10,--r8
8000b13a:	58 0a       	cp.w	r10,0
8000b13c:	cf d0       	breq	8000b136 <__mdiff+0xb6>
8000b13e:	99 49       	st.w	r12[0x10],r9
8000b140:	d8 32       	popm	r0-r7,pc
8000b142:	30 0b       	mov	r11,0
8000b144:	c1 6f       	rcall	8000af70 <_Balloc>
8000b146:	30 18       	mov	r8,1
8000b148:	99 48       	st.w	r12[0x10],r8
8000b14a:	30 08       	mov	r8,0
8000b14c:	99 58       	st.w	r12[0x14],r8
8000b14e:	d8 32       	popm	r0-r7,pc

8000b150 <__lshift>:
8000b150:	d4 31       	pushm	r0-r7,lr
8000b152:	16 97       	mov	r7,r11
8000b154:	76 46       	ld.w	r6,r11[0x10]
8000b156:	f4 02 14 05 	asr	r2,r10,0x5
8000b15a:	2f f6       	sub	r6,-1
8000b15c:	14 93       	mov	r3,r10
8000b15e:	18 94       	mov	r4,r12
8000b160:	04 06       	add	r6,r2
8000b162:	76 1b       	ld.w	r11,r11[0x4]
8000b164:	6e 28       	ld.w	r8,r7[0x8]
8000b166:	c0 38       	rjmp	8000b16c <__lshift+0x1c>
8000b168:	2f fb       	sub	r11,-1
8000b16a:	a1 78       	lsl	r8,0x1
8000b16c:	10 36       	cp.w	r6,r8
8000b16e:	fe 99 ff fd 	brgt	8000b168 <__lshift+0x18>
8000b172:	08 9c       	mov	r12,r4
8000b174:	cf ee       	rcall	8000af70 <_Balloc>
8000b176:	30 09       	mov	r9,0
8000b178:	18 95       	mov	r5,r12
8000b17a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b17e:	12 9a       	mov	r10,r9
8000b180:	c0 38       	rjmp	8000b186 <__lshift+0x36>
8000b182:	10 aa       	st.w	r8++,r10
8000b184:	2f f9       	sub	r9,-1
8000b186:	04 39       	cp.w	r9,r2
8000b188:	cf d5       	brlt	8000b182 <__lshift+0x32>
8000b18a:	6e 4b       	ld.w	r11,r7[0x10]
8000b18c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b190:	2f bb       	sub	r11,-5
8000b192:	ee c9 ff ec 	sub	r9,r7,-20
8000b196:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b19a:	58 03       	cp.w	r3,0
8000b19c:	c1 30       	breq	8000b1c2 <__lshift+0x72>
8000b19e:	e6 0c 11 20 	rsub	r12,r3,32
8000b1a2:	30 0a       	mov	r10,0
8000b1a4:	72 02       	ld.w	r2,r9[0x0]
8000b1a6:	e4 03 09 42 	lsl	r2,r2,r3
8000b1aa:	04 4a       	or	r10,r2
8000b1ac:	10 aa       	st.w	r8++,r10
8000b1ae:	13 0a       	ld.w	r10,r9++
8000b1b0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1b4:	16 39       	cp.w	r9,r11
8000b1b6:	cf 73       	brcs	8000b1a4 <__lshift+0x54>
8000b1b8:	91 0a       	st.w	r8[0x0],r10
8000b1ba:	58 0a       	cp.w	r10,0
8000b1bc:	c0 70       	breq	8000b1ca <__lshift+0x7a>
8000b1be:	2f f6       	sub	r6,-1
8000b1c0:	c0 58       	rjmp	8000b1ca <__lshift+0x7a>
8000b1c2:	13 0a       	ld.w	r10,r9++
8000b1c4:	10 aa       	st.w	r8++,r10
8000b1c6:	16 39       	cp.w	r9,r11
8000b1c8:	cf d3       	brcs	8000b1c2 <__lshift+0x72>
8000b1ca:	08 9c       	mov	r12,r4
8000b1cc:	20 16       	sub	r6,1
8000b1ce:	0e 9b       	mov	r11,r7
8000b1d0:	8b 46       	st.w	r5[0x10],r6
8000b1d2:	cb 5e       	rcall	8000af3c <_Bfree>
8000b1d4:	0a 9c       	mov	r12,r5
8000b1d6:	d8 32       	popm	r0-r7,pc

8000b1d8 <__multiply>:
8000b1d8:	d4 31       	pushm	r0-r7,lr
8000b1da:	20 2d       	sub	sp,8
8000b1dc:	76 49       	ld.w	r9,r11[0x10]
8000b1de:	74 48       	ld.w	r8,r10[0x10]
8000b1e0:	16 96       	mov	r6,r11
8000b1e2:	14 95       	mov	r5,r10
8000b1e4:	10 39       	cp.w	r9,r8
8000b1e6:	ec 08 17 50 	movlt	r8,r6
8000b1ea:	ea 06 17 50 	movlt	r6,r5
8000b1ee:	f0 05 17 50 	movlt	r5,r8
8000b1f2:	6c 28       	ld.w	r8,r6[0x8]
8000b1f4:	76 43       	ld.w	r3,r11[0x10]
8000b1f6:	74 42       	ld.w	r2,r10[0x10]
8000b1f8:	76 1b       	ld.w	r11,r11[0x4]
8000b1fa:	e4 03 00 07 	add	r7,r2,r3
8000b1fe:	10 37       	cp.w	r7,r8
8000b200:	f7 bb 09 ff 	subgt	r11,-1
8000b204:	cb 6e       	rcall	8000af70 <_Balloc>
8000b206:	ee c4 ff fb 	sub	r4,r7,-5
8000b20a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b20e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b212:	30 0a       	mov	r10,0
8000b214:	12 98       	mov	r8,r9
8000b216:	c0 28       	rjmp	8000b21a <__multiply+0x42>
8000b218:	10 aa       	st.w	r8++,r10
8000b21a:	08 38       	cp.w	r8,r4
8000b21c:	cf e3       	brcs	8000b218 <__multiply+0x40>
8000b21e:	2f b3       	sub	r3,-5
8000b220:	2f b2       	sub	r2,-5
8000b222:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b226:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b22a:	ec cb ff ec 	sub	r11,r6,-20
8000b22e:	50 12       	stdsp	sp[0x4],r2
8000b230:	ea ca ff ec 	sub	r10,r5,-20
8000b234:	c4 48       	rjmp	8000b2bc <__multiply+0xe4>
8000b236:	94 95       	ld.uh	r5,r10[0x2]
8000b238:	58 05       	cp.w	r5,0
8000b23a:	c2 00       	breq	8000b27a <__multiply+0xa2>
8000b23c:	12 98       	mov	r8,r9
8000b23e:	16 96       	mov	r6,r11
8000b240:	30 0e       	mov	lr,0
8000b242:	50 09       	stdsp	sp[0x0],r9
8000b244:	0d 02       	ld.w	r2,r6++
8000b246:	e4 00 16 10 	lsr	r0,r2,0x10
8000b24a:	70 01       	ld.w	r1,r8[0x0]
8000b24c:	70 09       	ld.w	r9,r8[0x0]
8000b24e:	b1 81       	lsr	r1,0x10
8000b250:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b254:	e0 05 03 41 	mac	r1,r0,r5
8000b258:	ab 32       	mul	r2,r5
8000b25a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b25e:	00 02       	add	r2,r0
8000b260:	e4 0e 00 0e 	add	lr,r2,lr
8000b264:	b0 1e       	st.h	r8[0x2],lr
8000b266:	b1 8e       	lsr	lr,0x10
8000b268:	1c 01       	add	r1,lr
8000b26a:	b0 01       	st.h	r8[0x0],r1
8000b26c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b270:	2f c8       	sub	r8,-4
8000b272:	06 36       	cp.w	r6,r3
8000b274:	ce 83       	brcs	8000b244 <__multiply+0x6c>
8000b276:	40 09       	lddsp	r9,sp[0x0]
8000b278:	91 0e       	st.w	r8[0x0],lr
8000b27a:	94 86       	ld.uh	r6,r10[0x0]
8000b27c:	58 06       	cp.w	r6,0
8000b27e:	c1 d0       	breq	8000b2b8 <__multiply+0xe0>
8000b280:	72 02       	ld.w	r2,r9[0x0]
8000b282:	12 98       	mov	r8,r9
8000b284:	16 9e       	mov	lr,r11
8000b286:	30 05       	mov	r5,0
8000b288:	b0 12       	st.h	r8[0x2],r2
8000b28a:	1d 01       	ld.w	r1,lr++
8000b28c:	90 82       	ld.uh	r2,r8[0x0]
8000b28e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b292:	ad 30       	mul	r0,r6
8000b294:	e0 02 00 02 	add	r2,r0,r2
8000b298:	e4 05 00 05 	add	r5,r2,r5
8000b29c:	b0 05       	st.h	r8[0x0],r5
8000b29e:	b1 85       	lsr	r5,0x10
8000b2a0:	b1 81       	lsr	r1,0x10
8000b2a2:	2f c8       	sub	r8,-4
8000b2a4:	ad 31       	mul	r1,r6
8000b2a6:	90 92       	ld.uh	r2,r8[0x2]
8000b2a8:	e2 02 00 02 	add	r2,r1,r2
8000b2ac:	0a 02       	add	r2,r5
8000b2ae:	e4 05 16 10 	lsr	r5,r2,0x10
8000b2b2:	06 3e       	cp.w	lr,r3
8000b2b4:	ce a3       	brcs	8000b288 <__multiply+0xb0>
8000b2b6:	91 02       	st.w	r8[0x0],r2
8000b2b8:	2f ca       	sub	r10,-4
8000b2ba:	2f c9       	sub	r9,-4
8000b2bc:	40 18       	lddsp	r8,sp[0x4]
8000b2be:	10 3a       	cp.w	r10,r8
8000b2c0:	cb b3       	brcs	8000b236 <__multiply+0x5e>
8000b2c2:	c0 28       	rjmp	8000b2c6 <__multiply+0xee>
8000b2c4:	20 17       	sub	r7,1
8000b2c6:	58 07       	cp.w	r7,0
8000b2c8:	e0 8a 00 05 	brle	8000b2d2 <__multiply+0xfa>
8000b2cc:	09 48       	ld.w	r8,--r4
8000b2ce:	58 08       	cp.w	r8,0
8000b2d0:	cf a0       	breq	8000b2c4 <__multiply+0xec>
8000b2d2:	99 47       	st.w	r12[0x10],r7
8000b2d4:	2f ed       	sub	sp,-8
8000b2d6:	d8 32       	popm	r0-r7,pc

8000b2d8 <__i2b>:
8000b2d8:	d4 21       	pushm	r4-r7,lr
8000b2da:	16 97       	mov	r7,r11
8000b2dc:	30 1b       	mov	r11,1
8000b2de:	c4 9e       	rcall	8000af70 <_Balloc>
8000b2e0:	30 19       	mov	r9,1
8000b2e2:	99 57       	st.w	r12[0x14],r7
8000b2e4:	99 49       	st.w	r12[0x10],r9
8000b2e6:	d8 22       	popm	r4-r7,pc

8000b2e8 <__multadd>:
8000b2e8:	d4 31       	pushm	r0-r7,lr
8000b2ea:	30 08       	mov	r8,0
8000b2ec:	12 95       	mov	r5,r9
8000b2ee:	16 97       	mov	r7,r11
8000b2f0:	18 96       	mov	r6,r12
8000b2f2:	76 44       	ld.w	r4,r11[0x10]
8000b2f4:	f6 c9 ff ec 	sub	r9,r11,-20
8000b2f8:	72 0b       	ld.w	r11,r9[0x0]
8000b2fa:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b2fe:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b302:	f4 0c 02 4c 	mul	r12,r10,r12
8000b306:	f4 0b 03 45 	mac	r5,r10,r11
8000b30a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b30e:	b1 85       	lsr	r5,0x10
8000b310:	18 05       	add	r5,r12
8000b312:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b316:	f8 0b 00 0b 	add	r11,r12,r11
8000b31a:	12 ab       	st.w	r9++,r11
8000b31c:	2f f8       	sub	r8,-1
8000b31e:	b1 85       	lsr	r5,0x10
8000b320:	08 38       	cp.w	r8,r4
8000b322:	ce b5       	brlt	8000b2f8 <__multadd+0x10>
8000b324:	58 05       	cp.w	r5,0
8000b326:	c1 c0       	breq	8000b35e <__multadd+0x76>
8000b328:	6e 28       	ld.w	r8,r7[0x8]
8000b32a:	10 34       	cp.w	r4,r8
8000b32c:	c1 35       	brlt	8000b352 <__multadd+0x6a>
8000b32e:	6e 1b       	ld.w	r11,r7[0x4]
8000b330:	0c 9c       	mov	r12,r6
8000b332:	2f fb       	sub	r11,-1
8000b334:	c1 ee       	rcall	8000af70 <_Balloc>
8000b336:	6e 4a       	ld.w	r10,r7[0x10]
8000b338:	ee cb ff f4 	sub	r11,r7,-12
8000b33c:	18 93       	mov	r3,r12
8000b33e:	2f ea       	sub	r10,-2
8000b340:	2f 4c       	sub	r12,-12
8000b342:	a3 6a       	lsl	r10,0x2
8000b344:	fe b0 de 64 	rcall	8000700c <memcpy>
8000b348:	0e 9b       	mov	r11,r7
8000b34a:	0c 9c       	mov	r12,r6
8000b34c:	fe b0 fd f8 	rcall	8000af3c <_Bfree>
8000b350:	06 97       	mov	r7,r3
8000b352:	e8 c8 ff ff 	sub	r8,r4,-1
8000b356:	2f b4       	sub	r4,-5
8000b358:	8f 48       	st.w	r7[0x10],r8
8000b35a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b35e:	0e 9c       	mov	r12,r7
8000b360:	d8 32       	popm	r0-r7,pc
8000b362:	d7 03       	nop

8000b364 <__pow5mult>:
8000b364:	d4 31       	pushm	r0-r7,lr
8000b366:	14 96       	mov	r6,r10
8000b368:	18 97       	mov	r7,r12
8000b36a:	16 94       	mov	r4,r11
8000b36c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b370:	c0 90       	breq	8000b382 <__pow5mult+0x1e>
8000b372:	20 18       	sub	r8,1
8000b374:	fe c9 da 68 	sub	r9,pc,-9624
8000b378:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b37c:	30 09       	mov	r9,0
8000b37e:	cb 5f       	rcall	8000b2e8 <__multadd>
8000b380:	18 94       	mov	r4,r12
8000b382:	a3 46       	asr	r6,0x2
8000b384:	c3 40       	breq	8000b3ec <__pow5mult+0x88>
8000b386:	6e 95       	ld.w	r5,r7[0x24]
8000b388:	58 05       	cp.w	r5,0
8000b38a:	c0 91       	brne	8000b39c <__pow5mult+0x38>
8000b38c:	31 0c       	mov	r12,16
8000b38e:	fe b0 dc 1b 	rcall	80006bc4 <malloc>
8000b392:	99 35       	st.w	r12[0xc],r5
8000b394:	8f 9c       	st.w	r7[0x24],r12
8000b396:	99 15       	st.w	r12[0x4],r5
8000b398:	99 25       	st.w	r12[0x8],r5
8000b39a:	99 05       	st.w	r12[0x0],r5
8000b39c:	6e 93       	ld.w	r3,r7[0x24]
8000b39e:	66 25       	ld.w	r5,r3[0x8]
8000b3a0:	58 05       	cp.w	r5,0
8000b3a2:	c0 c1       	brne	8000b3ba <__pow5mult+0x56>
8000b3a4:	e0 6b 02 71 	mov	r11,625
8000b3a8:	0e 9c       	mov	r12,r7
8000b3aa:	c9 7f       	rcall	8000b2d8 <__i2b>
8000b3ac:	87 2c       	st.w	r3[0x8],r12
8000b3ae:	30 08       	mov	r8,0
8000b3b0:	18 95       	mov	r5,r12
8000b3b2:	99 08       	st.w	r12[0x0],r8
8000b3b4:	c0 38       	rjmp	8000b3ba <__pow5mult+0x56>
8000b3b6:	06 9c       	mov	r12,r3
8000b3b8:	18 95       	mov	r5,r12
8000b3ba:	ed b6 00 00 	bld	r6,0x0
8000b3be:	c0 b1       	brne	8000b3d4 <__pow5mult+0x70>
8000b3c0:	08 9b       	mov	r11,r4
8000b3c2:	0a 9a       	mov	r10,r5
8000b3c4:	0e 9c       	mov	r12,r7
8000b3c6:	c0 9f       	rcall	8000b1d8 <__multiply>
8000b3c8:	08 9b       	mov	r11,r4
8000b3ca:	18 93       	mov	r3,r12
8000b3cc:	0e 9c       	mov	r12,r7
8000b3ce:	06 94       	mov	r4,r3
8000b3d0:	fe b0 fd b6 	rcall	8000af3c <_Bfree>
8000b3d4:	a1 56       	asr	r6,0x1
8000b3d6:	c0 b0       	breq	8000b3ec <__pow5mult+0x88>
8000b3d8:	6a 03       	ld.w	r3,r5[0x0]
8000b3da:	58 03       	cp.w	r3,0
8000b3dc:	ce d1       	brne	8000b3b6 <__pow5mult+0x52>
8000b3de:	0a 9a       	mov	r10,r5
8000b3e0:	0a 9b       	mov	r11,r5
8000b3e2:	0e 9c       	mov	r12,r7
8000b3e4:	cf ae       	rcall	8000b1d8 <__multiply>
8000b3e6:	8b 0c       	st.w	r5[0x0],r12
8000b3e8:	99 03       	st.w	r12[0x0],r3
8000b3ea:	ce 7b       	rjmp	8000b3b8 <__pow5mult+0x54>
8000b3ec:	08 9c       	mov	r12,r4
8000b3ee:	d8 32       	popm	r0-r7,pc

8000b3f0 <__isinfd>:
8000b3f0:	14 98       	mov	r8,r10
8000b3f2:	fc 19 7f f0 	movh	r9,0x7ff0
8000b3f6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b3fa:	f0 0b 11 00 	rsub	r11,r8,0
8000b3fe:	f7 e8 10 08 	or	r8,r11,r8
8000b402:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b406:	f2 08 01 08 	sub	r8,r9,r8
8000b40a:	f0 0c 11 00 	rsub	r12,r8,0
8000b40e:	f9 e8 10 08 	or	r8,r12,r8
8000b412:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b416:	2f fc       	sub	r12,-1
8000b418:	5e fc       	retal	r12

8000b41a <__isnand>:
8000b41a:	14 98       	mov	r8,r10
8000b41c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b420:	f0 0c 11 00 	rsub	r12,r8,0
8000b424:	10 4c       	or	r12,r8
8000b426:	fc 18 7f f0 	movh	r8,0x7ff0
8000b42a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b42e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b432:	bf 9c       	lsr	r12,0x1f
8000b434:	5e fc       	retal	r12
8000b436:	d7 03       	nop

8000b438 <__sclose>:
8000b438:	d4 01       	pushm	lr
8000b43a:	96 7b       	ld.sh	r11,r11[0xe]
8000b43c:	c7 6c       	rcall	8000b528 <_close_r>
8000b43e:	d8 02       	popm	pc

8000b440 <__sseek>:
8000b440:	d4 21       	pushm	r4-r7,lr
8000b442:	16 97       	mov	r7,r11
8000b444:	96 7b       	ld.sh	r11,r11[0xe]
8000b446:	cf 7c       	rcall	8000b634 <_lseek_r>
8000b448:	8e 68       	ld.sh	r8,r7[0xc]
8000b44a:	10 99       	mov	r9,r8
8000b44c:	ad c8       	cbr	r8,0xc
8000b44e:	ad a9       	sbr	r9,0xc
8000b450:	5b fc       	cp.w	r12,-1
8000b452:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b456:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b45a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b45e:	d8 22       	popm	r4-r7,pc

8000b460 <__swrite>:
8000b460:	d4 21       	pushm	r4-r7,lr
8000b462:	96 68       	ld.sh	r8,r11[0xc]
8000b464:	16 97       	mov	r7,r11
8000b466:	14 95       	mov	r5,r10
8000b468:	12 94       	mov	r4,r9
8000b46a:	e2 18 01 00 	andl	r8,0x100,COH
8000b46e:	18 96       	mov	r6,r12
8000b470:	c0 50       	breq	8000b47a <__swrite+0x1a>
8000b472:	30 29       	mov	r9,2
8000b474:	30 0a       	mov	r10,0
8000b476:	96 7b       	ld.sh	r11,r11[0xe]
8000b478:	cd ec       	rcall	8000b634 <_lseek_r>
8000b47a:	8e 68       	ld.sh	r8,r7[0xc]
8000b47c:	ad c8       	cbr	r8,0xc
8000b47e:	08 99       	mov	r9,r4
8000b480:	0a 9a       	mov	r10,r5
8000b482:	8e 7b       	ld.sh	r11,r7[0xe]
8000b484:	0c 9c       	mov	r12,r6
8000b486:	ae 68       	st.h	r7[0xc],r8
8000b488:	c1 0c       	rcall	8000b4a8 <_write_r>
8000b48a:	d8 22       	popm	r4-r7,pc

8000b48c <__sread>:
8000b48c:	d4 21       	pushm	r4-r7,lr
8000b48e:	16 97       	mov	r7,r11
8000b490:	96 7b       	ld.sh	r11,r11[0xe]
8000b492:	ce 5c       	rcall	8000b65c <_read_r>
8000b494:	c0 65       	brlt	8000b4a0 <__sread+0x14>
8000b496:	6f 58       	ld.w	r8,r7[0x54]
8000b498:	18 08       	add	r8,r12
8000b49a:	ef 48 00 54 	st.w	r7[84],r8
8000b49e:	d8 22       	popm	r4-r7,pc
8000b4a0:	8e 68       	ld.sh	r8,r7[0xc]
8000b4a2:	ad c8       	cbr	r8,0xc
8000b4a4:	ae 68       	st.h	r7[0xc],r8
8000b4a6:	d8 22       	popm	r4-r7,pc

8000b4a8 <_write_r>:
8000b4a8:	d4 21       	pushm	r4-r7,lr
8000b4aa:	16 98       	mov	r8,r11
8000b4ac:	18 97       	mov	r7,r12
8000b4ae:	10 9c       	mov	r12,r8
8000b4b0:	30 08       	mov	r8,0
8000b4b2:	14 9b       	mov	r11,r10
8000b4b4:	e0 66 41 0c 	mov	r6,16652
8000b4b8:	12 9a       	mov	r10,r9
8000b4ba:	8d 08       	st.w	r6[0x0],r8
8000b4bc:	fe b0 d1 36 	rcall	80005728 <_write>
8000b4c0:	5b fc       	cp.w	r12,-1
8000b4c2:	c0 51       	brne	8000b4cc <_write_r+0x24>
8000b4c4:	6c 08       	ld.w	r8,r6[0x0]
8000b4c6:	58 08       	cp.w	r8,0
8000b4c8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4cc:	d8 22       	popm	r4-r7,pc
8000b4ce:	d7 03       	nop

8000b4d0 <_calloc_r>:
8000b4d0:	d4 21       	pushm	r4-r7,lr
8000b4d2:	f4 0b 02 4b 	mul	r11,r10,r11
8000b4d6:	fe b0 db 7f 	rcall	80006bd4 <_malloc_r>
8000b4da:	18 97       	mov	r7,r12
8000b4dc:	c2 30       	breq	8000b522 <_calloc_r+0x52>
8000b4de:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b4e2:	e0 1a ff fc 	andl	r10,0xfffc
8000b4e6:	20 4a       	sub	r10,4
8000b4e8:	e0 4a 00 24 	cp.w	r10,36
8000b4ec:	e0 8b 00 18 	brhi	8000b51c <_calloc_r+0x4c>
8000b4f0:	18 98       	mov	r8,r12
8000b4f2:	59 3a       	cp.w	r10,19
8000b4f4:	e0 88 00 0f 	brls	8000b512 <_calloc_r+0x42>
8000b4f8:	30 09       	mov	r9,0
8000b4fa:	10 a9       	st.w	r8++,r9
8000b4fc:	10 a9       	st.w	r8++,r9
8000b4fe:	59 ba       	cp.w	r10,27
8000b500:	e0 88 00 09 	brls	8000b512 <_calloc_r+0x42>
8000b504:	10 a9       	st.w	r8++,r9
8000b506:	10 a9       	st.w	r8++,r9
8000b508:	e0 4a 00 24 	cp.w	r10,36
8000b50c:	c0 31       	brne	8000b512 <_calloc_r+0x42>
8000b50e:	10 a9       	st.w	r8++,r9
8000b510:	10 a9       	st.w	r8++,r9
8000b512:	30 09       	mov	r9,0
8000b514:	10 a9       	st.w	r8++,r9
8000b516:	91 19       	st.w	r8[0x4],r9
8000b518:	91 09       	st.w	r8[0x0],r9
8000b51a:	c0 48       	rjmp	8000b522 <_calloc_r+0x52>
8000b51c:	30 0b       	mov	r11,0
8000b51e:	fe b0 de 1b 	rcall	80007154 <memset>
8000b522:	0e 9c       	mov	r12,r7
8000b524:	d8 22       	popm	r4-r7,pc
8000b526:	d7 03       	nop

8000b528 <_close_r>:
8000b528:	d4 21       	pushm	r4-r7,lr
8000b52a:	30 08       	mov	r8,0
8000b52c:	18 97       	mov	r7,r12
8000b52e:	e0 66 41 0c 	mov	r6,16652
8000b532:	16 9c       	mov	r12,r11
8000b534:	8d 08       	st.w	r6[0x0],r8
8000b536:	fe b0 df c1 	rcall	800074b8 <_close>
8000b53a:	5b fc       	cp.w	r12,-1
8000b53c:	c0 51       	brne	8000b546 <_close_r+0x1e>
8000b53e:	6c 08       	ld.w	r8,r6[0x0]
8000b540:	58 08       	cp.w	r8,0
8000b542:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b546:	d8 22       	popm	r4-r7,pc

8000b548 <_fclose_r>:
8000b548:	d4 21       	pushm	r4-r7,lr
8000b54a:	18 96       	mov	r6,r12
8000b54c:	16 97       	mov	r7,r11
8000b54e:	58 0b       	cp.w	r11,0
8000b550:	c0 31       	brne	8000b556 <_fclose_r+0xe>
8000b552:	16 95       	mov	r5,r11
8000b554:	c5 38       	rjmp	8000b5fa <_fclose_r+0xb2>
8000b556:	fe b0 f8 b5 	rcall	8000a6c0 <__sfp_lock_acquire>
8000b55a:	58 06       	cp.w	r6,0
8000b55c:	c0 70       	breq	8000b56a <_fclose_r+0x22>
8000b55e:	6c 68       	ld.w	r8,r6[0x18]
8000b560:	58 08       	cp.w	r8,0
8000b562:	c0 41       	brne	8000b56a <_fclose_r+0x22>
8000b564:	0c 9c       	mov	r12,r6
8000b566:	fe b0 f8 ff 	rcall	8000a764 <__sinit>
8000b56a:	fe c8 dd 02 	sub	r8,pc,-8958
8000b56e:	10 37       	cp.w	r7,r8
8000b570:	c0 31       	brne	8000b576 <_fclose_r+0x2e>
8000b572:	6c 07       	ld.w	r7,r6[0x0]
8000b574:	c0 c8       	rjmp	8000b58c <_fclose_r+0x44>
8000b576:	fe c8 dc ee 	sub	r8,pc,-8978
8000b57a:	10 37       	cp.w	r7,r8
8000b57c:	c0 31       	brne	8000b582 <_fclose_r+0x3a>
8000b57e:	6c 17       	ld.w	r7,r6[0x4]
8000b580:	c0 68       	rjmp	8000b58c <_fclose_r+0x44>
8000b582:	fe c8 dc da 	sub	r8,pc,-8998
8000b586:	10 37       	cp.w	r7,r8
8000b588:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b58c:	8e 69       	ld.sh	r9,r7[0xc]
8000b58e:	30 08       	mov	r8,0
8000b590:	f0 09 19 00 	cp.h	r9,r8
8000b594:	c0 51       	brne	8000b59e <_fclose_r+0x56>
8000b596:	fe b0 f8 96 	rcall	8000a6c2 <__sfp_lock_release>
8000b59a:	30 05       	mov	r5,0
8000b59c:	c2 f8       	rjmp	8000b5fa <_fclose_r+0xb2>
8000b59e:	0e 9b       	mov	r11,r7
8000b5a0:	0c 9c       	mov	r12,r6
8000b5a2:	fe b0 f8 09 	rcall	8000a5b4 <_fflush_r>
8000b5a6:	6e c8       	ld.w	r8,r7[0x30]
8000b5a8:	18 95       	mov	r5,r12
8000b5aa:	58 08       	cp.w	r8,0
8000b5ac:	c0 60       	breq	8000b5b8 <_fclose_r+0x70>
8000b5ae:	6e 8b       	ld.w	r11,r7[0x20]
8000b5b0:	0c 9c       	mov	r12,r6
8000b5b2:	5d 18       	icall	r8
8000b5b4:	f9 b5 05 ff 	movlt	r5,-1
8000b5b8:	8e 68       	ld.sh	r8,r7[0xc]
8000b5ba:	ed b8 00 07 	bld	r8,0x7
8000b5be:	c0 51       	brne	8000b5c8 <_fclose_r+0x80>
8000b5c0:	6e 4b       	ld.w	r11,r7[0x10]
8000b5c2:	0c 9c       	mov	r12,r6
8000b5c4:	fe b0 f9 6a 	rcall	8000a898 <_free_r>
8000b5c8:	6e db       	ld.w	r11,r7[0x34]
8000b5ca:	58 0b       	cp.w	r11,0
8000b5cc:	c0 a0       	breq	8000b5e0 <_fclose_r+0x98>
8000b5ce:	ee c8 ff bc 	sub	r8,r7,-68
8000b5d2:	10 3b       	cp.w	r11,r8
8000b5d4:	c0 40       	breq	8000b5dc <_fclose_r+0x94>
8000b5d6:	0c 9c       	mov	r12,r6
8000b5d8:	fe b0 f9 60 	rcall	8000a898 <_free_r>
8000b5dc:	30 08       	mov	r8,0
8000b5de:	8f d8       	st.w	r7[0x34],r8
8000b5e0:	6f 2b       	ld.w	r11,r7[0x48]
8000b5e2:	58 0b       	cp.w	r11,0
8000b5e4:	c0 70       	breq	8000b5f2 <_fclose_r+0xaa>
8000b5e6:	0c 9c       	mov	r12,r6
8000b5e8:	fe b0 f9 58 	rcall	8000a898 <_free_r>
8000b5ec:	30 08       	mov	r8,0
8000b5ee:	ef 48 00 48 	st.w	r7[72],r8
8000b5f2:	30 08       	mov	r8,0
8000b5f4:	ae 68       	st.h	r7[0xc],r8
8000b5f6:	fe b0 f8 66 	rcall	8000a6c2 <__sfp_lock_release>
8000b5fa:	0a 9c       	mov	r12,r5
8000b5fc:	d8 22       	popm	r4-r7,pc
8000b5fe:	d7 03       	nop

8000b600 <fclose>:
8000b600:	d4 01       	pushm	lr
8000b602:	e0 68 0a 44 	mov	r8,2628
8000b606:	18 9b       	mov	r11,r12
8000b608:	70 0c       	ld.w	r12,r8[0x0]
8000b60a:	c9 ff       	rcall	8000b548 <_fclose_r>
8000b60c:	d8 02       	popm	pc
8000b60e:	d7 03       	nop

8000b610 <_fstat_r>:
8000b610:	d4 21       	pushm	r4-r7,lr
8000b612:	16 98       	mov	r8,r11
8000b614:	18 97       	mov	r7,r12
8000b616:	10 9c       	mov	r12,r8
8000b618:	30 08       	mov	r8,0
8000b61a:	e0 66 41 0c 	mov	r6,16652
8000b61e:	14 9b       	mov	r11,r10
8000b620:	8d 08       	st.w	r6[0x0],r8
8000b622:	fe b0 df 73 	rcall	80007508 <_fstat>
8000b626:	5b fc       	cp.w	r12,-1
8000b628:	c0 51       	brne	8000b632 <_fstat_r+0x22>
8000b62a:	6c 08       	ld.w	r8,r6[0x0]
8000b62c:	58 08       	cp.w	r8,0
8000b62e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b632:	d8 22       	popm	r4-r7,pc

8000b634 <_lseek_r>:
8000b634:	d4 21       	pushm	r4-r7,lr
8000b636:	16 98       	mov	r8,r11
8000b638:	18 97       	mov	r7,r12
8000b63a:	10 9c       	mov	r12,r8
8000b63c:	30 08       	mov	r8,0
8000b63e:	14 9b       	mov	r11,r10
8000b640:	e0 66 41 0c 	mov	r6,16652
8000b644:	12 9a       	mov	r10,r9
8000b646:	8d 08       	st.w	r6[0x0],r8
8000b648:	fe b0 df 42 	rcall	800074cc <_lseek>
8000b64c:	5b fc       	cp.w	r12,-1
8000b64e:	c0 51       	brne	8000b658 <_lseek_r+0x24>
8000b650:	6c 08       	ld.w	r8,r6[0x0]
8000b652:	58 08       	cp.w	r8,0
8000b654:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b658:	d8 22       	popm	r4-r7,pc
8000b65a:	d7 03       	nop

8000b65c <_read_r>:
8000b65c:	d4 21       	pushm	r4-r7,lr
8000b65e:	16 98       	mov	r8,r11
8000b660:	18 97       	mov	r7,r12
8000b662:	10 9c       	mov	r12,r8
8000b664:	30 08       	mov	r8,0
8000b666:	14 9b       	mov	r11,r10
8000b668:	e0 66 41 0c 	mov	r6,16652
8000b66c:	12 9a       	mov	r10,r9
8000b66e:	8d 08       	st.w	r6[0x0],r8
8000b670:	fe b0 d0 3c 	rcall	800056e8 <_read>
8000b674:	5b fc       	cp.w	r12,-1
8000b676:	c0 51       	brne	8000b680 <_read_r+0x24>
8000b678:	6c 08       	ld.w	r8,r6[0x0]
8000b67a:	58 08       	cp.w	r8,0
8000b67c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b680:	d8 22       	popm	r4-r7,pc
8000b682:	d7 03       	nop

8000b684 <__avr32_f64_mul>:
8000b684:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b688:	e0 80 00 dc 	breq	8000b840 <__avr32_f64_mul_op1_zero>
8000b68c:	d4 21       	pushm	r4-r7,lr
8000b68e:	f7 e9 20 0e 	eor	lr,r11,r9
8000b692:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b696:	30 15       	mov	r5,1
8000b698:	c4 30       	breq	8000b71e <__avr32_f64_mul_op1_subnormal>
8000b69a:	ab 6b       	lsl	r11,0xa
8000b69c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b6a0:	ab 6a       	lsl	r10,0xa
8000b6a2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b6a6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b6aa:	c5 c0       	breq	8000b762 <__avr32_f64_mul_op2_subnormal>
8000b6ac:	a1 78       	lsl	r8,0x1
8000b6ae:	5c f9       	rol	r9
8000b6b0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b6b4:	e0 47 07 ff 	cp.w	r7,2047
8000b6b8:	c7 70       	breq	8000b7a6 <__avr32_f64_mul_op_nan_or_inf>
8000b6ba:	e0 46 07 ff 	cp.w	r6,2047
8000b6be:	c7 40       	breq	8000b7a6 <__avr32_f64_mul_op_nan_or_inf>
8000b6c0:	ee 06 00 0c 	add	r12,r7,r6
8000b6c4:	e0 2c 03 fe 	sub	r12,1022
8000b6c8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b6cc:	f4 09 07 44 	macu.d	r4,r10,r9
8000b6d0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b6d4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b6d8:	08 07       	add	r7,r4
8000b6da:	f4 05 00 4a 	adc	r10,r10,r5
8000b6de:	5c 0b       	acr	r11
8000b6e0:	ed bb 00 14 	bld	r11,0x14
8000b6e4:	c0 50       	breq	8000b6ee <__avr32_f64_mul+0x6a>
8000b6e6:	a1 77       	lsl	r7,0x1
8000b6e8:	5c fa       	rol	r10
8000b6ea:	5c fb       	rol	r11
8000b6ec:	20 1c       	sub	r12,1
8000b6ee:	58 0c       	cp.w	r12,0
8000b6f0:	e0 8a 00 6f 	brle	8000b7ce <__avr32_f64_mul_res_subnormal>
8000b6f4:	e0 4c 07 ff 	cp.w	r12,2047
8000b6f8:	e0 84 00 9c 	brge	8000b830 <__avr32_f64_mul_res_inf>
8000b6fc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b700:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b704:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b708:	ee 17 80 00 	eorh	r7,0x8000
8000b70c:	f1 b7 04 20 	satu	r7,0x1
8000b710:	0e 0a       	add	r10,r7
8000b712:	5c 0b       	acr	r11
8000b714:	ed be 00 1f 	bld	lr,0x1f
8000b718:	ef bb 00 1f 	bst	r11,0x1f
8000b71c:	d8 22       	popm	r4-r7,pc

8000b71e <__avr32_f64_mul_op1_subnormal>:
8000b71e:	e4 1b 00 0f 	andh	r11,0xf
8000b722:	f4 0c 12 00 	clz	r12,r10
8000b726:	f6 06 12 00 	clz	r6,r11
8000b72a:	f7 bc 03 e1 	sublo	r12,-31
8000b72e:	f8 06 17 30 	movlo	r6,r12
8000b732:	f7 b6 02 01 	subhs	r6,1
8000b736:	e0 46 00 20 	cp.w	r6,32
8000b73a:	c0 d4       	brge	8000b754 <__avr32_f64_mul_op1_subnormal+0x36>
8000b73c:	ec 0c 11 20 	rsub	r12,r6,32
8000b740:	f6 06 09 4b 	lsl	r11,r11,r6
8000b744:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b748:	18 4b       	or	r11,r12
8000b74a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b74e:	20 b6       	sub	r6,11
8000b750:	0c 17       	sub	r7,r6
8000b752:	ca ab       	rjmp	8000b6a6 <__avr32_f64_mul+0x22>
8000b754:	f4 06 09 4b 	lsl	r11,r10,r6
8000b758:	c6 40       	breq	8000b820 <__avr32_f64_mul_res_zero>
8000b75a:	30 0a       	mov	r10,0
8000b75c:	20 b6       	sub	r6,11
8000b75e:	0c 17       	sub	r7,r6
8000b760:	ca 3b       	rjmp	8000b6a6 <__avr32_f64_mul+0x22>

8000b762 <__avr32_f64_mul_op2_subnormal>:
8000b762:	e4 19 00 0f 	andh	r9,0xf
8000b766:	f0 0c 12 00 	clz	r12,r8
8000b76a:	f2 05 12 00 	clz	r5,r9
8000b76e:	f7 bc 03 ea 	sublo	r12,-22
8000b772:	f8 05 17 30 	movlo	r5,r12
8000b776:	f7 b5 02 0a 	subhs	r5,10
8000b77a:	e0 45 00 20 	cp.w	r5,32
8000b77e:	c0 d4       	brge	8000b798 <__avr32_f64_mul_op2_subnormal+0x36>
8000b780:	ea 0c 11 20 	rsub	r12,r5,32
8000b784:	f2 05 09 49 	lsl	r9,r9,r5
8000b788:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b78c:	18 49       	or	r9,r12
8000b78e:	f0 05 09 48 	lsl	r8,r8,r5
8000b792:	20 25       	sub	r5,2
8000b794:	0a 16       	sub	r6,r5
8000b796:	c8 fb       	rjmp	8000b6b4 <__avr32_f64_mul+0x30>
8000b798:	f0 05 09 49 	lsl	r9,r8,r5
8000b79c:	c4 20       	breq	8000b820 <__avr32_f64_mul_res_zero>
8000b79e:	30 08       	mov	r8,0
8000b7a0:	20 25       	sub	r5,2
8000b7a2:	0a 16       	sub	r6,r5
8000b7a4:	c8 8b       	rjmp	8000b6b4 <__avr32_f64_mul+0x30>

8000b7a6 <__avr32_f64_mul_op_nan_or_inf>:
8000b7a6:	e4 19 00 0f 	andh	r9,0xf
8000b7aa:	e4 1b 00 0f 	andh	r11,0xf
8000b7ae:	14 4b       	or	r11,r10
8000b7b0:	10 49       	or	r9,r8
8000b7b2:	e0 47 07 ff 	cp.w	r7,2047
8000b7b6:	c0 91       	brne	8000b7c8 <__avr32_f64_mul_op1_not_naninf>
8000b7b8:	58 0b       	cp.w	r11,0
8000b7ba:	c3 81       	brne	8000b82a <__avr32_f64_mul_res_nan>
8000b7bc:	e0 46 07 ff 	cp.w	r6,2047
8000b7c0:	c3 81       	brne	8000b830 <__avr32_f64_mul_res_inf>
8000b7c2:	58 09       	cp.w	r9,0
8000b7c4:	c3 60       	breq	8000b830 <__avr32_f64_mul_res_inf>
8000b7c6:	c3 28       	rjmp	8000b82a <__avr32_f64_mul_res_nan>

8000b7c8 <__avr32_f64_mul_op1_not_naninf>:
8000b7c8:	58 09       	cp.w	r9,0
8000b7ca:	c3 30       	breq	8000b830 <__avr32_f64_mul_res_inf>
8000b7cc:	c2 f8       	rjmp	8000b82a <__avr32_f64_mul_res_nan>

8000b7ce <__avr32_f64_mul_res_subnormal>:
8000b7ce:	5c 3c       	neg	r12
8000b7d0:	2f fc       	sub	r12,-1
8000b7d2:	f1 bc 04 c0 	satu	r12,0x6
8000b7d6:	e0 4c 00 20 	cp.w	r12,32
8000b7da:	c1 14       	brge	8000b7fc <__avr32_f64_mul_res_subnormal+0x2e>
8000b7dc:	f8 08 11 20 	rsub	r8,r12,32
8000b7e0:	0e 46       	or	r6,r7
8000b7e2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b7e6:	f4 08 09 49 	lsl	r9,r10,r8
8000b7ea:	12 47       	or	r7,r9
8000b7ec:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7f0:	f6 08 09 49 	lsl	r9,r11,r8
8000b7f4:	12 4a       	or	r10,r9
8000b7f6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b7fa:	c8 3b       	rjmp	8000b700 <__avr32_f64_mul+0x7c>
8000b7fc:	f8 08 11 20 	rsub	r8,r12,32
8000b800:	f9 b9 00 00 	moveq	r9,0
8000b804:	c0 30       	breq	8000b80a <__avr32_f64_mul_res_subnormal+0x3c>
8000b806:	f6 08 09 49 	lsl	r9,r11,r8
8000b80a:	0e 46       	or	r6,r7
8000b80c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b810:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b814:	f3 ea 10 07 	or	r7,r9,r10
8000b818:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b81c:	30 0b       	mov	r11,0
8000b81e:	c7 1b       	rjmp	8000b700 <__avr32_f64_mul+0x7c>

8000b820 <__avr32_f64_mul_res_zero>:
8000b820:	1c 9b       	mov	r11,lr
8000b822:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b826:	30 0a       	mov	r10,0
8000b828:	d8 22       	popm	r4-r7,pc

8000b82a <__avr32_f64_mul_res_nan>:
8000b82a:	3f fb       	mov	r11,-1
8000b82c:	3f fa       	mov	r10,-1
8000b82e:	d8 22       	popm	r4-r7,pc

8000b830 <__avr32_f64_mul_res_inf>:
8000b830:	f0 6b 00 00 	mov	r11,-1048576
8000b834:	ed be 00 1f 	bld	lr,0x1f
8000b838:	ef bb 00 1f 	bst	r11,0x1f
8000b83c:	30 0a       	mov	r10,0
8000b83e:	d8 22       	popm	r4-r7,pc

8000b840 <__avr32_f64_mul_op1_zero>:
8000b840:	f7 e9 20 0b 	eor	r11,r11,r9
8000b844:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b848:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b84c:	e0 4c 07 ff 	cp.w	r12,2047
8000b850:	5e 1c       	retne	r12
8000b852:	3f fa       	mov	r10,-1
8000b854:	3f fb       	mov	r11,-1
8000b856:	5e fc       	retal	r12

8000b858 <__avr32_f64_sub_from_add>:
8000b858:	ee 19 80 00 	eorh	r9,0x8000

8000b85c <__avr32_f64_sub>:
8000b85c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b860:	e0 86 00 ca 	brmi	8000b9f4 <__avr32_f64_add_from_sub>
8000b864:	eb cd 40 e0 	pushm	r5-r7,lr
8000b868:	16 9c       	mov	r12,r11
8000b86a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b86e:	bf db       	cbr	r11,0x1f
8000b870:	bf d9       	cbr	r9,0x1f
8000b872:	10 3a       	cp.w	r10,r8
8000b874:	f2 0b 13 00 	cpc	r11,r9
8000b878:	c0 92       	brcc	8000b88a <__avr32_f64_sub+0x2e>
8000b87a:	16 97       	mov	r7,r11
8000b87c:	12 9b       	mov	r11,r9
8000b87e:	0e 99       	mov	r9,r7
8000b880:	14 97       	mov	r7,r10
8000b882:	10 9a       	mov	r10,r8
8000b884:	0e 98       	mov	r8,r7
8000b886:	ee 1c 80 00 	eorh	r12,0x8000
8000b88a:	f6 07 16 14 	lsr	r7,r11,0x14
8000b88e:	ab 7b       	lsl	r11,0xb
8000b890:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b894:	ab 7a       	lsl	r10,0xb
8000b896:	bf bb       	sbr	r11,0x1f
8000b898:	f2 06 16 14 	lsr	r6,r9,0x14
8000b89c:	c4 40       	breq	8000b924 <__avr32_f64_sub_opL_subnormal>
8000b89e:	ab 79       	lsl	r9,0xb
8000b8a0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b8a4:	ab 78       	lsl	r8,0xb
8000b8a6:	bf b9       	sbr	r9,0x1f

8000b8a8 <__avr32_f64_sub_opL_subnormal_done>:
8000b8a8:	e0 47 07 ff 	cp.w	r7,2047
8000b8ac:	c4 f0       	breq	8000b94a <__avr32_f64_sub_opH_nan_or_inf>
8000b8ae:	0e 26       	rsub	r6,r7
8000b8b0:	c1 20       	breq	8000b8d4 <__avr32_f64_sub_shift_done>
8000b8b2:	ec 05 11 20 	rsub	r5,r6,32
8000b8b6:	e0 46 00 20 	cp.w	r6,32
8000b8ba:	c7 c2       	brcc	8000b9b2 <__avr32_f64_sub_longshift>
8000b8bc:	f0 05 09 4e 	lsl	lr,r8,r5
8000b8c0:	f2 05 09 45 	lsl	r5,r9,r5
8000b8c4:	f0 06 0a 48 	lsr	r8,r8,r6
8000b8c8:	f2 06 0a 49 	lsr	r9,r9,r6
8000b8cc:	0a 48       	or	r8,r5
8000b8ce:	58 0e       	cp.w	lr,0
8000b8d0:	5f 1e       	srne	lr
8000b8d2:	1c 48       	or	r8,lr

8000b8d4 <__avr32_f64_sub_shift_done>:
8000b8d4:	10 1a       	sub	r10,r8
8000b8d6:	f6 09 01 4b 	sbc	r11,r11,r9
8000b8da:	f6 06 12 00 	clz	r6,r11
8000b8de:	c0 e0       	breq	8000b8fa <__avr32_f64_sub_longnormalize_done>
8000b8e0:	c7 83       	brcs	8000b9d0 <__avr32_f64_sub_longnormalize>
8000b8e2:	ec 0e 11 20 	rsub	lr,r6,32
8000b8e6:	f6 06 09 4b 	lsl	r11,r11,r6
8000b8ea:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b8ee:	1c 4b       	or	r11,lr
8000b8f0:	f4 06 09 4a 	lsl	r10,r10,r6
8000b8f4:	0c 17       	sub	r7,r6
8000b8f6:	e0 8a 00 39 	brle	8000b968 <__avr32_f64_sub_subnormal_result>

8000b8fa <__avr32_f64_sub_longnormalize_done>:
8000b8fa:	f4 09 15 15 	lsl	r9,r10,0x15
8000b8fe:	ab 9a       	lsr	r10,0xb
8000b900:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b904:	ab 9b       	lsr	r11,0xb
8000b906:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b90a:	18 4b       	or	r11,r12

8000b90c <__avr32_f64_sub_round>:
8000b90c:	fc 17 80 00 	movh	r7,0x8000
8000b910:	ed ba 00 00 	bld	r10,0x0
8000b914:	f7 b7 01 ff 	subne	r7,-1
8000b918:	0e 39       	cp.w	r9,r7
8000b91a:	5f 29       	srhs	r9
8000b91c:	12 0a       	add	r10,r9
8000b91e:	5c 0b       	acr	r11
8000b920:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b924 <__avr32_f64_sub_opL_subnormal>:
8000b924:	ab 79       	lsl	r9,0xb
8000b926:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b92a:	ab 78       	lsl	r8,0xb
8000b92c:	f3 e8 10 0e 	or	lr,r9,r8
8000b930:	f9 b6 01 01 	movne	r6,1
8000b934:	ee 0e 11 00 	rsub	lr,r7,0
8000b938:	f9 b7 00 01 	moveq	r7,1
8000b93c:	ef bb 00 1f 	bst	r11,0x1f
8000b940:	f7 ea 10 0e 	or	lr,r11,r10
8000b944:	f9 b7 00 00 	moveq	r7,0
8000b948:	cb 0b       	rjmp	8000b8a8 <__avr32_f64_sub_opL_subnormal_done>

8000b94a <__avr32_f64_sub_opH_nan_or_inf>:
8000b94a:	bf db       	cbr	r11,0x1f
8000b94c:	f7 ea 10 0e 	or	lr,r11,r10
8000b950:	c0 81       	brne	8000b960 <__avr32_f64_sub_return_nan>
8000b952:	e0 46 07 ff 	cp.w	r6,2047
8000b956:	c0 50       	breq	8000b960 <__avr32_f64_sub_return_nan>
8000b958:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b95c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b960 <__avr32_f64_sub_return_nan>:
8000b960:	3f fa       	mov	r10,-1
8000b962:	3f fb       	mov	r11,-1
8000b964:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b968 <__avr32_f64_sub_subnormal_result>:
8000b968:	5c 37       	neg	r7
8000b96a:	2f f7       	sub	r7,-1
8000b96c:	f1 b7 04 c0 	satu	r7,0x6
8000b970:	e0 47 00 20 	cp.w	r7,32
8000b974:	c1 14       	brge	8000b996 <__avr32_f64_sub_subnormal_result+0x2e>
8000b976:	ee 08 11 20 	rsub	r8,r7,32
8000b97a:	f4 08 09 49 	lsl	r9,r10,r8
8000b97e:	5f 16       	srne	r6
8000b980:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b984:	0c 4a       	or	r10,r6
8000b986:	f6 08 09 49 	lsl	r9,r11,r8
8000b98a:	f5 e9 10 0a 	or	r10,r10,r9
8000b98e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b992:	30 07       	mov	r7,0
8000b994:	cb 3b       	rjmp	8000b8fa <__avr32_f64_sub_longnormalize_done>
8000b996:	ee 08 11 40 	rsub	r8,r7,64
8000b99a:	f6 08 09 49 	lsl	r9,r11,r8
8000b99e:	14 49       	or	r9,r10
8000b9a0:	5f 16       	srne	r6
8000b9a2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b9a6:	0c 4a       	or	r10,r6
8000b9a8:	30 0b       	mov	r11,0
8000b9aa:	30 07       	mov	r7,0
8000b9ac:	ca 7b       	rjmp	8000b8fa <__avr32_f64_sub_longnormalize_done>
8000b9ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9b2 <__avr32_f64_sub_longshift>:
8000b9b2:	f1 b6 04 c0 	satu	r6,0x6
8000b9b6:	f0 0e 17 00 	moveq	lr,r8
8000b9ba:	c0 40       	breq	8000b9c2 <__avr32_f64_sub_longshift+0x10>
8000b9bc:	f2 05 09 4e 	lsl	lr,r9,r5
8000b9c0:	10 4e       	or	lr,r8
8000b9c2:	f2 06 0a 48 	lsr	r8,r9,r6
8000b9c6:	30 09       	mov	r9,0
8000b9c8:	58 0e       	cp.w	lr,0
8000b9ca:	5f 1e       	srne	lr
8000b9cc:	1c 48       	or	r8,lr
8000b9ce:	c8 3b       	rjmp	8000b8d4 <__avr32_f64_sub_shift_done>

8000b9d0 <__avr32_f64_sub_longnormalize>:
8000b9d0:	f4 06 12 00 	clz	r6,r10
8000b9d4:	f9 b7 03 00 	movlo	r7,0
8000b9d8:	f9 b6 03 00 	movlo	r6,0
8000b9dc:	f9 bc 03 00 	movlo	r12,0
8000b9e0:	f7 b6 02 e0 	subhs	r6,-32
8000b9e4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9e8:	30 0a       	mov	r10,0
8000b9ea:	0c 17       	sub	r7,r6
8000b9ec:	fe 9a ff be 	brle	8000b968 <__avr32_f64_sub_subnormal_result>
8000b9f0:	c8 5b       	rjmp	8000b8fa <__avr32_f64_sub_longnormalize_done>
8000b9f2:	d7 03       	nop

8000b9f4 <__avr32_f64_add_from_sub>:
8000b9f4:	ee 19 80 00 	eorh	r9,0x8000

8000b9f8 <__avr32_f64_add>:
8000b9f8:	f7 e9 20 0c 	eor	r12,r11,r9
8000b9fc:	fe 96 ff 2e 	brmi	8000b858 <__avr32_f64_sub_from_add>
8000ba00:	eb cd 40 e0 	pushm	r5-r7,lr
8000ba04:	16 9c       	mov	r12,r11
8000ba06:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ba0a:	bf db       	cbr	r11,0x1f
8000ba0c:	bf d9       	cbr	r9,0x1f
8000ba0e:	12 3b       	cp.w	r11,r9
8000ba10:	c0 72       	brcc	8000ba1e <__avr32_f64_add+0x26>
8000ba12:	16 97       	mov	r7,r11
8000ba14:	12 9b       	mov	r11,r9
8000ba16:	0e 99       	mov	r9,r7
8000ba18:	14 97       	mov	r7,r10
8000ba1a:	10 9a       	mov	r10,r8
8000ba1c:	0e 98       	mov	r8,r7
8000ba1e:	30 0e       	mov	lr,0
8000ba20:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ba24:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ba28:	b5 ab       	sbr	r11,0x14
8000ba2a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ba2e:	c6 20       	breq	8000baf2 <__avr32_f64_add_op2_subnormal>
8000ba30:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ba34:	b5 a9       	sbr	r9,0x14
8000ba36:	e0 47 07 ff 	cp.w	r7,2047
8000ba3a:	c2 80       	breq	8000ba8a <__avr32_f64_add_opH_nan_or_inf>
8000ba3c:	0e 26       	rsub	r6,r7
8000ba3e:	c1 20       	breq	8000ba62 <__avr32_f64_add_shift_done>
8000ba40:	e0 46 00 36 	cp.w	r6,54
8000ba44:	c1 52       	brcc	8000ba6e <__avr32_f64_add_res_of_done>
8000ba46:	ec 05 11 20 	rsub	r5,r6,32
8000ba4a:	e0 46 00 20 	cp.w	r6,32
8000ba4e:	c3 52       	brcc	8000bab8 <__avr32_f64_add_longshift>
8000ba50:	f0 05 09 4e 	lsl	lr,r8,r5
8000ba54:	f2 05 09 45 	lsl	r5,r9,r5
8000ba58:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba5c:	f2 06 0a 49 	lsr	r9,r9,r6
8000ba60:	0a 48       	or	r8,r5

8000ba62 <__avr32_f64_add_shift_done>:
8000ba62:	10 0a       	add	r10,r8
8000ba64:	f6 09 00 4b 	adc	r11,r11,r9
8000ba68:	ed bb 00 15 	bld	r11,0x15
8000ba6c:	c3 40       	breq	8000bad4 <__avr32_f64_add_res_of>

8000ba6e <__avr32_f64_add_res_of_done>:
8000ba6e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba72:	18 4b       	or	r11,r12

8000ba74 <__avr32_f64_add_round>:
8000ba74:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ba78:	18 4e       	or	lr,r12
8000ba7a:	ee 1e 80 00 	eorh	lr,0x8000
8000ba7e:	f1 be 04 20 	satu	lr,0x1
8000ba82:	1c 0a       	add	r10,lr
8000ba84:	5c 0b       	acr	r11
8000ba86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba8a <__avr32_f64_add_opH_nan_or_inf>:
8000ba8a:	b5 cb       	cbr	r11,0x14
8000ba8c:	f7 ea 10 0e 	or	lr,r11,r10
8000ba90:	c1 01       	brne	8000bab0 <__avr32_f64_add_return_nan>
8000ba92:	e0 46 07 ff 	cp.w	r6,2047
8000ba96:	c0 30       	breq	8000ba9c <__avr32_f64_add_opL_nan_or_inf>
8000ba98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba9c <__avr32_f64_add_opL_nan_or_inf>:
8000ba9c:	b5 c9       	cbr	r9,0x14
8000ba9e:	f3 e8 10 0e 	or	lr,r9,r8
8000baa2:	c0 71       	brne	8000bab0 <__avr32_f64_add_return_nan>
8000baa4:	30 0a       	mov	r10,0
8000baa6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000baaa:	18 4b       	or	r11,r12
8000baac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bab0 <__avr32_f64_add_return_nan>:
8000bab0:	3f fa       	mov	r10,-1
8000bab2:	3f fb       	mov	r11,-1
8000bab4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bab8 <__avr32_f64_add_longshift>:
8000bab8:	f1 b6 04 c0 	satu	r6,0x6
8000babc:	f0 0e 17 00 	moveq	lr,r8
8000bac0:	c0 60       	breq	8000bacc <__avr32_f64_add_longshift+0x14>
8000bac2:	f2 05 09 4e 	lsl	lr,r9,r5
8000bac6:	58 08       	cp.w	r8,0
8000bac8:	5f 18       	srne	r8
8000baca:	10 4e       	or	lr,r8
8000bacc:	f2 06 0a 48 	lsr	r8,r9,r6
8000bad0:	30 09       	mov	r9,0
8000bad2:	cc 8b       	rjmp	8000ba62 <__avr32_f64_add_shift_done>

8000bad4 <__avr32_f64_add_res_of>:
8000bad4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bad8:	a1 9b       	lsr	r11,0x1
8000bada:	5d 0a       	ror	r10
8000badc:	5d 0e       	ror	lr
8000bade:	2f f7       	sub	r7,-1
8000bae0:	e0 47 07 ff 	cp.w	r7,2047
8000bae4:	f9 ba 00 00 	moveq	r10,0
8000bae8:	f9 bb 00 00 	moveq	r11,0
8000baec:	f9 be 00 00 	moveq	lr,0
8000baf0:	cb fb       	rjmp	8000ba6e <__avr32_f64_add_res_of_done>

8000baf2 <__avr32_f64_add_op2_subnormal>:
8000baf2:	30 16       	mov	r6,1
8000baf4:	58 07       	cp.w	r7,0
8000baf6:	ca 01       	brne	8000ba36 <__avr32_f64_add+0x3e>
8000baf8:	b5 cb       	cbr	r11,0x14
8000bafa:	10 0a       	add	r10,r8
8000bafc:	f6 09 00 4b 	adc	r11,r11,r9
8000bb00:	18 4b       	or	r11,r12
8000bb02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bb06:	d7 03       	nop

8000bb08 <__avr32_f64_to_u32>:
8000bb08:	58 0b       	cp.w	r11,0
8000bb0a:	5e 6d       	retmi	0

8000bb0c <__avr32_f64_to_s32>:
8000bb0c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bb10:	b5 9c       	lsr	r12,0x15
8000bb12:	e0 2c 03 ff 	sub	r12,1023
8000bb16:	5e 3d       	retlo	0
8000bb18:	f8 0c 11 1f 	rsub	r12,r12,31
8000bb1c:	16 99       	mov	r9,r11
8000bb1e:	ab 7b       	lsl	r11,0xb
8000bb20:	bf bb       	sbr	r11,0x1f
8000bb22:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb26:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb2a:	a1 79       	lsl	r9,0x1
8000bb2c:	5e 2b       	reths	r11
8000bb2e:	5c 3b       	neg	r11
8000bb30:	5e fb       	retal	r11

8000bb32 <__avr32_u32_to_f64>:
8000bb32:	f8 cb 00 00 	sub	r11,r12,0
8000bb36:	30 0c       	mov	r12,0
8000bb38:	c0 38       	rjmp	8000bb3e <__avr32_s32_to_f64+0x4>

8000bb3a <__avr32_s32_to_f64>:
8000bb3a:	18 9b       	mov	r11,r12
8000bb3c:	5c 4b       	abs	r11
8000bb3e:	30 0a       	mov	r10,0
8000bb40:	5e 0b       	reteq	r11
8000bb42:	d4 01       	pushm	lr
8000bb44:	e0 69 04 1e 	mov	r9,1054
8000bb48:	f6 08 12 00 	clz	r8,r11
8000bb4c:	c1 70       	breq	8000bb7a <__avr32_s32_to_f64+0x40>
8000bb4e:	c0 c3       	brcs	8000bb66 <__avr32_s32_to_f64+0x2c>
8000bb50:	f0 0e 11 20 	rsub	lr,r8,32
8000bb54:	f6 08 09 4b 	lsl	r11,r11,r8
8000bb58:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb5c:	1c 4b       	or	r11,lr
8000bb5e:	f4 08 09 4a 	lsl	r10,r10,r8
8000bb62:	10 19       	sub	r9,r8
8000bb64:	c0 b8       	rjmp	8000bb7a <__avr32_s32_to_f64+0x40>
8000bb66:	f4 08 12 00 	clz	r8,r10
8000bb6a:	f9 b8 03 00 	movlo	r8,0
8000bb6e:	f7 b8 02 e0 	subhs	r8,-32
8000bb72:	f4 08 09 4b 	lsl	r11,r10,r8
8000bb76:	30 0a       	mov	r10,0
8000bb78:	10 19       	sub	r9,r8
8000bb7a:	58 09       	cp.w	r9,0
8000bb7c:	e0 89 00 30 	brgt	8000bbdc <__avr32_s32_to_f64+0xa2>
8000bb80:	5c 39       	neg	r9
8000bb82:	2f f9       	sub	r9,-1
8000bb84:	e0 49 00 36 	cp.w	r9,54
8000bb88:	c0 43       	brcs	8000bb90 <__avr32_s32_to_f64+0x56>
8000bb8a:	30 0b       	mov	r11,0
8000bb8c:	30 0a       	mov	r10,0
8000bb8e:	c2 68       	rjmp	8000bbda <__avr32_s32_to_f64+0xa0>
8000bb90:	2f 69       	sub	r9,-10
8000bb92:	f2 08 11 20 	rsub	r8,r9,32
8000bb96:	e0 49 00 20 	cp.w	r9,32
8000bb9a:	c0 b2       	brcc	8000bbb0 <__avr32_s32_to_f64+0x76>
8000bb9c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bba0:	f6 08 09 48 	lsl	r8,r11,r8
8000bba4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bba8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bbac:	10 4b       	or	r11,r8
8000bbae:	c0 88       	rjmp	8000bbbe <__avr32_s32_to_f64+0x84>
8000bbb0:	f6 08 09 4e 	lsl	lr,r11,r8
8000bbb4:	14 4e       	or	lr,r10
8000bbb6:	16 9a       	mov	r10,r11
8000bbb8:	30 0b       	mov	r11,0
8000bbba:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bbbe:	ed ba 00 00 	bld	r10,0x0
8000bbc2:	c0 92       	brcc	8000bbd4 <__avr32_s32_to_f64+0x9a>
8000bbc4:	1c 7e       	tst	lr,lr
8000bbc6:	c0 41       	brne	8000bbce <__avr32_s32_to_f64+0x94>
8000bbc8:	ed ba 00 01 	bld	r10,0x1
8000bbcc:	c0 42       	brcc	8000bbd4 <__avr32_s32_to_f64+0x9a>
8000bbce:	2f fa       	sub	r10,-1
8000bbd0:	f7 bb 02 ff 	subhs	r11,-1
8000bbd4:	5c fc       	rol	r12
8000bbd6:	5d 0b       	ror	r11
8000bbd8:	5d 0a       	ror	r10
8000bbda:	d8 02       	popm	pc
8000bbdc:	e0 68 03 ff 	mov	r8,1023
8000bbe0:	ed ba 00 0b 	bld	r10,0xb
8000bbe4:	f7 b8 00 ff 	subeq	r8,-1
8000bbe8:	10 0a       	add	r10,r8
8000bbea:	5c 0b       	acr	r11
8000bbec:	f7 b9 03 fe 	sublo	r9,-2
8000bbf0:	e0 49 07 ff 	cp.w	r9,2047
8000bbf4:	c0 55       	brlt	8000bbfe <__avr32_s32_to_f64+0xc4>
8000bbf6:	30 0a       	mov	r10,0
8000bbf8:	fc 1b ff e0 	movh	r11,0xffe0
8000bbfc:	c0 c8       	rjmp	8000bc14 <__floatsidf_return_op1>
8000bbfe:	ed bb 00 1f 	bld	r11,0x1f
8000bc02:	f7 b9 01 01 	subne	r9,1
8000bc06:	ab 9a       	lsr	r10,0xb
8000bc08:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc0c:	a1 7b       	lsl	r11,0x1
8000bc0e:	ab 9b       	lsr	r11,0xb
8000bc10:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bc14 <__floatsidf_return_op1>:
8000bc14:	a1 7c       	lsl	r12,0x1
8000bc16:	5d 0b       	ror	r11
8000bc18:	d8 02       	popm	pc

8000bc1a <__avr32_f64_cmp_eq>:
8000bc1a:	10 3a       	cp.w	r10,r8
8000bc1c:	f2 0b 13 00 	cpc	r11,r9
8000bc20:	c0 80       	breq	8000bc30 <__avr32_f64_cmp_eq+0x16>
8000bc22:	a1 7b       	lsl	r11,0x1
8000bc24:	a1 79       	lsl	r9,0x1
8000bc26:	14 4b       	or	r11,r10
8000bc28:	12 4b       	or	r11,r9
8000bc2a:	10 4b       	or	r11,r8
8000bc2c:	5e 0f       	reteq	1
8000bc2e:	5e fd       	retal	0
8000bc30:	a1 7b       	lsl	r11,0x1
8000bc32:	fc 1c ff e0 	movh	r12,0xffe0
8000bc36:	58 0a       	cp.w	r10,0
8000bc38:	f8 0b 13 00 	cpc	r11,r12
8000bc3c:	5e 8f       	retls	1
8000bc3e:	5e fd       	retal	0

8000bc40 <__avr32_f64_cmp_ge>:
8000bc40:	1a de       	st.w	--sp,lr
8000bc42:	1a d7       	st.w	--sp,r7
8000bc44:	a1 7b       	lsl	r11,0x1
8000bc46:	5f 3c       	srlo	r12
8000bc48:	a1 79       	lsl	r9,0x1
8000bc4a:	5f 37       	srlo	r7
8000bc4c:	5c fc       	rol	r12
8000bc4e:	fc 1e ff e0 	movh	lr,0xffe0
8000bc52:	58 0a       	cp.w	r10,0
8000bc54:	fc 0b 13 00 	cpc	r11,lr
8000bc58:	e0 8b 00 1d 	brhi	8000bc92 <__avr32_f64_cmp_ge+0x52>
8000bc5c:	58 08       	cp.w	r8,0
8000bc5e:	fc 09 13 00 	cpc	r9,lr
8000bc62:	e0 8b 00 18 	brhi	8000bc92 <__avr32_f64_cmp_ge+0x52>
8000bc66:	58 0b       	cp.w	r11,0
8000bc68:	f5 ba 00 00 	subfeq	r10,0
8000bc6c:	c1 50       	breq	8000bc96 <__avr32_f64_cmp_ge+0x56>
8000bc6e:	1b 07       	ld.w	r7,sp++
8000bc70:	1b 0e       	ld.w	lr,sp++
8000bc72:	58 3c       	cp.w	r12,3
8000bc74:	c0 a0       	breq	8000bc88 <__avr32_f64_cmp_ge+0x48>
8000bc76:	58 1c       	cp.w	r12,1
8000bc78:	c0 33       	brcs	8000bc7e <__avr32_f64_cmp_ge+0x3e>
8000bc7a:	5e 0f       	reteq	1
8000bc7c:	5e 1d       	retne	0
8000bc7e:	10 3a       	cp.w	r10,r8
8000bc80:	f2 0b 13 00 	cpc	r11,r9
8000bc84:	5e 2f       	reths	1
8000bc86:	5e 3d       	retlo	0
8000bc88:	14 38       	cp.w	r8,r10
8000bc8a:	f6 09 13 00 	cpc	r9,r11
8000bc8e:	5e 2f       	reths	1
8000bc90:	5e 3d       	retlo	0
8000bc92:	1b 07       	ld.w	r7,sp++
8000bc94:	d8 0a       	popm	pc,r12=0
8000bc96:	58 17       	cp.w	r7,1
8000bc98:	5f 0c       	sreq	r12
8000bc9a:	58 09       	cp.w	r9,0
8000bc9c:	f5 b8 00 00 	subfeq	r8,0
8000bca0:	1b 07       	ld.w	r7,sp++
8000bca2:	1b 0e       	ld.w	lr,sp++
8000bca4:	5e 0f       	reteq	1
8000bca6:	5e fc       	retal	r12

8000bca8 <__avr32_f64_cmp_lt>:
8000bca8:	1a de       	st.w	--sp,lr
8000bcaa:	1a d7       	st.w	--sp,r7
8000bcac:	a1 7b       	lsl	r11,0x1
8000bcae:	5f 3c       	srlo	r12
8000bcb0:	a1 79       	lsl	r9,0x1
8000bcb2:	5f 37       	srlo	r7
8000bcb4:	5c fc       	rol	r12
8000bcb6:	fc 1e ff e0 	movh	lr,0xffe0
8000bcba:	58 0a       	cp.w	r10,0
8000bcbc:	fc 0b 13 00 	cpc	r11,lr
8000bcc0:	e0 8b 00 1d 	brhi	8000bcfa <__avr32_f64_cmp_lt+0x52>
8000bcc4:	58 08       	cp.w	r8,0
8000bcc6:	fc 09 13 00 	cpc	r9,lr
8000bcca:	e0 8b 00 18 	brhi	8000bcfa <__avr32_f64_cmp_lt+0x52>
8000bcce:	58 0b       	cp.w	r11,0
8000bcd0:	f5 ba 00 00 	subfeq	r10,0
8000bcd4:	c1 50       	breq	8000bcfe <__avr32_f64_cmp_lt+0x56>
8000bcd6:	1b 07       	ld.w	r7,sp++
8000bcd8:	1b 0e       	ld.w	lr,sp++
8000bcda:	58 3c       	cp.w	r12,3
8000bcdc:	c0 a0       	breq	8000bcf0 <__avr32_f64_cmp_lt+0x48>
8000bcde:	58 1c       	cp.w	r12,1
8000bce0:	c0 33       	brcs	8000bce6 <__avr32_f64_cmp_lt+0x3e>
8000bce2:	5e 0d       	reteq	0
8000bce4:	5e 1f       	retne	1
8000bce6:	10 3a       	cp.w	r10,r8
8000bce8:	f2 0b 13 00 	cpc	r11,r9
8000bcec:	5e 2d       	reths	0
8000bcee:	5e 3f       	retlo	1
8000bcf0:	14 38       	cp.w	r8,r10
8000bcf2:	f6 09 13 00 	cpc	r9,r11
8000bcf6:	5e 2d       	reths	0
8000bcf8:	5e 3f       	retlo	1
8000bcfa:	1b 07       	ld.w	r7,sp++
8000bcfc:	d8 0a       	popm	pc,r12=0
8000bcfe:	58 17       	cp.w	r7,1
8000bd00:	5f 1c       	srne	r12
8000bd02:	58 09       	cp.w	r9,0
8000bd04:	f5 b8 00 00 	subfeq	r8,0
8000bd08:	1b 07       	ld.w	r7,sp++
8000bd0a:	1b 0e       	ld.w	lr,sp++
8000bd0c:	5e 0d       	reteq	0
8000bd0e:	5e fc       	retal	r12

8000bd10 <__avr32_f64_div>:
8000bd10:	eb cd 40 ff 	pushm	r0-r7,lr
8000bd14:	f7 e9 20 0e 	eor	lr,r11,r9
8000bd18:	f6 07 16 14 	lsr	r7,r11,0x14
8000bd1c:	a9 7b       	lsl	r11,0x9
8000bd1e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bd22:	a9 7a       	lsl	r10,0x9
8000bd24:	bd bb       	sbr	r11,0x1d
8000bd26:	e4 1b 3f ff 	andh	r11,0x3fff
8000bd2a:	ab d7       	cbr	r7,0xb
8000bd2c:	e0 80 00 cc 	breq	8000bec4 <__avr32_f64_div_round_subnormal+0x54>
8000bd30:	e0 47 07 ff 	cp.w	r7,2047
8000bd34:	e0 84 00 b5 	brge	8000be9e <__avr32_f64_div_round_subnormal+0x2e>
8000bd38:	f2 06 16 14 	lsr	r6,r9,0x14
8000bd3c:	a9 79       	lsl	r9,0x9
8000bd3e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bd42:	a9 78       	lsl	r8,0x9
8000bd44:	bd b9       	sbr	r9,0x1d
8000bd46:	e4 19 3f ff 	andh	r9,0x3fff
8000bd4a:	ab d6       	cbr	r6,0xb
8000bd4c:	e0 80 00 e2 	breq	8000bf10 <__avr32_f64_div_round_subnormal+0xa0>
8000bd50:	e0 46 07 ff 	cp.w	r6,2047
8000bd54:	e0 84 00 b2 	brge	8000beb8 <__avr32_f64_div_round_subnormal+0x48>
8000bd58:	0c 17       	sub	r7,r6
8000bd5a:	fe 37 fc 01 	sub	r7,-1023
8000bd5e:	fc 1c 80 00 	movh	r12,0x8000
8000bd62:	f8 03 16 01 	lsr	r3,r12,0x1
8000bd66:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bd6a:	5c d4       	com	r4
8000bd6c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bd70:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd74:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd78:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd7c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd80:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd84:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd88:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd8c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd90:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd94:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd98:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd9c:	ea 03 15 02 	lsl	r3,r5,0x2
8000bda0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bda4:	e4 09 07 40 	macu.d	r0,r2,r9
8000bda8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bdac:	02 04       	add	r4,r1
8000bdae:	5c 05       	acr	r5
8000bdb0:	a3 65       	lsl	r5,0x2
8000bdb2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bdb6:	a3 64       	lsl	r4,0x2
8000bdb8:	5c 34       	neg	r4
8000bdba:	f8 05 01 45 	sbc	r5,r12,r5
8000bdbe:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bdc2:	e4 05 07 40 	macu.d	r0,r2,r5
8000bdc6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdca:	02 04       	add	r4,r1
8000bdcc:	5c 05       	acr	r5
8000bdce:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdd2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bdd6:	e8 02 15 02 	lsl	r2,r4,0x2
8000bdda:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bdde:	e4 09 07 40 	macu.d	r0,r2,r9
8000bde2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bde6:	02 04       	add	r4,r1
8000bde8:	5c 05       	acr	r5
8000bdea:	a3 65       	lsl	r5,0x2
8000bdec:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bdf0:	a3 64       	lsl	r4,0x2
8000bdf2:	5c 34       	neg	r4
8000bdf4:	f8 05 01 45 	sbc	r5,r12,r5
8000bdf8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bdfc:	e4 05 07 40 	macu.d	r0,r2,r5
8000be00:	e6 05 06 44 	mulu.d	r4,r3,r5
8000be04:	02 04       	add	r4,r1
8000be06:	5c 05       	acr	r5
8000be08:	ea 03 15 02 	lsl	r3,r5,0x2
8000be0c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000be10:	e8 02 15 02 	lsl	r2,r4,0x2
8000be14:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000be18:	e4 0b 07 40 	macu.d	r0,r2,r11
8000be1c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000be20:	02 02       	add	r2,r1
8000be22:	5c 03       	acr	r3
8000be24:	ed b3 00 1c 	bld	r3,0x1c
8000be28:	c0 90       	breq	8000be3a <__avr32_f64_div+0x12a>
8000be2a:	a1 72       	lsl	r2,0x1
8000be2c:	5c f3       	rol	r3
8000be2e:	20 17       	sub	r7,1
8000be30:	a3 9a       	lsr	r10,0x3
8000be32:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000be36:	a3 9b       	lsr	r11,0x3
8000be38:	c0 58       	rjmp	8000be42 <__avr32_f64_div+0x132>
8000be3a:	a5 8a       	lsr	r10,0x4
8000be3c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000be40:	a5 8b       	lsr	r11,0x4
8000be42:	58 07       	cp.w	r7,0
8000be44:	e0 8a 00 8b 	brle	8000bf5a <__avr32_f64_div_res_subnormal>
8000be48:	e0 12 ff 00 	andl	r2,0xff00
8000be4c:	e8 12 00 80 	orl	r2,0x80
8000be50:	e6 08 06 40 	mulu.d	r0,r3,r8
8000be54:	e4 09 07 40 	macu.d	r0,r2,r9
8000be58:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be5c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be60:	00 05       	add	r5,r0
8000be62:	f0 01 00 48 	adc	r8,r8,r1
8000be66:	5c 09       	acr	r9
8000be68:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000be6c:	58 04       	cp.w	r4,0
8000be6e:	5c 25       	cpc	r5

8000be70 <__avr32_f64_div_round_subnormal>:
8000be70:	f4 08 13 00 	cpc	r8,r10
8000be74:	f6 09 13 00 	cpc	r9,r11
8000be78:	5f 36       	srlo	r6
8000be7a:	f8 06 17 00 	moveq	r6,r12
8000be7e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000be82:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000be86:	e6 0b 16 08 	lsr	r11,r3,0x8
8000be8a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000be8e:	ed be 00 1f 	bld	lr,0x1f
8000be92:	ef bb 00 1f 	bst	r11,0x1f
8000be96:	0c 0a       	add	r10,r6
8000be98:	5c 0b       	acr	r11
8000be9a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000be9e:	e4 1b 00 0f 	andh	r11,0xf
8000bea2:	14 4b       	or	r11,r10
8000bea4:	e0 81 00 a7 	brne	8000bff2 <__avr32_f64_div_res_subnormal+0x98>
8000bea8:	f2 06 16 14 	lsr	r6,r9,0x14
8000beac:	ab d6       	cbr	r6,0xb
8000beae:	e0 46 07 ff 	cp.w	r6,2047
8000beb2:	e0 81 00 a4 	brne	8000bffa <__avr32_f64_div_res_subnormal+0xa0>
8000beb6:	c9 e8       	rjmp	8000bff2 <__avr32_f64_div_res_subnormal+0x98>
8000beb8:	e4 19 00 0f 	andh	r9,0xf
8000bebc:	10 49       	or	r9,r8
8000bebe:	e0 81 00 9a 	brne	8000bff2 <__avr32_f64_div_res_subnormal+0x98>
8000bec2:	c9 28       	rjmp	8000bfe6 <__avr32_f64_div_res_subnormal+0x8c>
8000bec4:	a3 7b       	lsl	r11,0x3
8000bec6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000beca:	a3 7a       	lsl	r10,0x3
8000becc:	f5 eb 10 04 	or	r4,r10,r11
8000bed0:	e0 80 00 a0 	breq	8000c010 <__avr32_f64_div_op1_zero>
8000bed4:	f6 04 12 00 	clz	r4,r11
8000bed8:	c1 70       	breq	8000bf06 <__avr32_f64_div_round_subnormal+0x96>
8000beda:	c0 c3       	brcs	8000bef2 <__avr32_f64_div_round_subnormal+0x82>
8000bedc:	e8 05 11 20 	rsub	r5,r4,32
8000bee0:	f6 04 09 4b 	lsl	r11,r11,r4
8000bee4:	f4 05 0a 45 	lsr	r5,r10,r5
8000bee8:	0a 4b       	or	r11,r5
8000beea:	f4 04 09 4a 	lsl	r10,r10,r4
8000beee:	08 17       	sub	r7,r4
8000bef0:	c0 b8       	rjmp	8000bf06 <__avr32_f64_div_round_subnormal+0x96>
8000bef2:	f4 04 12 00 	clz	r4,r10
8000bef6:	f9 b4 03 00 	movlo	r4,0
8000befa:	f7 b4 02 e0 	subhs	r4,-32
8000befe:	f4 04 09 4b 	lsl	r11,r10,r4
8000bf02:	30 0a       	mov	r10,0
8000bf04:	08 17       	sub	r7,r4
8000bf06:	a3 8a       	lsr	r10,0x2
8000bf08:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bf0c:	a3 8b       	lsr	r11,0x2
8000bf0e:	c1 1b       	rjmp	8000bd30 <__avr32_f64_div+0x20>
8000bf10:	a3 79       	lsl	r9,0x3
8000bf12:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bf16:	a3 78       	lsl	r8,0x3
8000bf18:	f3 e8 10 04 	or	r4,r9,r8
8000bf1c:	c6 f0       	breq	8000bffa <__avr32_f64_div_res_subnormal+0xa0>
8000bf1e:	f2 04 12 00 	clz	r4,r9
8000bf22:	c1 70       	breq	8000bf50 <__avr32_f64_div_round_subnormal+0xe0>
8000bf24:	c0 c3       	brcs	8000bf3c <__avr32_f64_div_round_subnormal+0xcc>
8000bf26:	e8 05 11 20 	rsub	r5,r4,32
8000bf2a:	f2 04 09 49 	lsl	r9,r9,r4
8000bf2e:	f0 05 0a 45 	lsr	r5,r8,r5
8000bf32:	0a 49       	or	r9,r5
8000bf34:	f0 04 09 48 	lsl	r8,r8,r4
8000bf38:	08 16       	sub	r6,r4
8000bf3a:	c0 b8       	rjmp	8000bf50 <__avr32_f64_div_round_subnormal+0xe0>
8000bf3c:	f0 04 12 00 	clz	r4,r8
8000bf40:	f9 b4 03 00 	movlo	r4,0
8000bf44:	f7 b4 02 e0 	subhs	r4,-32
8000bf48:	f0 04 09 49 	lsl	r9,r8,r4
8000bf4c:	30 08       	mov	r8,0
8000bf4e:	08 16       	sub	r6,r4
8000bf50:	a3 88       	lsr	r8,0x2
8000bf52:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bf56:	a3 89       	lsr	r9,0x2
8000bf58:	cf ca       	rjmp	8000bd50 <__avr32_f64_div+0x40>

8000bf5a <__avr32_f64_div_res_subnormal>:
8000bf5a:	5c 37       	neg	r7
8000bf5c:	2f f7       	sub	r7,-1
8000bf5e:	f1 b7 04 c0 	satu	r7,0x6
8000bf62:	e0 47 00 20 	cp.w	r7,32
8000bf66:	c1 54       	brge	8000bf90 <__avr32_f64_div_res_subnormal+0x36>
8000bf68:	ee 06 11 20 	rsub	r6,r7,32
8000bf6c:	e4 07 0a 42 	lsr	r2,r2,r7
8000bf70:	e6 06 09 4c 	lsl	r12,r3,r6
8000bf74:	18 42       	or	r2,r12
8000bf76:	e6 07 0a 43 	lsr	r3,r3,r7
8000bf7a:	f4 06 09 41 	lsl	r1,r10,r6
8000bf7e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf82:	f6 06 09 4c 	lsl	r12,r11,r6
8000bf86:	18 4a       	or	r10,r12
8000bf88:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bf8c:	30 00       	mov	r0,0
8000bf8e:	c1 58       	rjmp	8000bfb8 <__avr32_f64_div_res_subnormal+0x5e>
8000bf90:	ee 06 11 20 	rsub	r6,r7,32
8000bf94:	f9 b0 00 00 	moveq	r0,0
8000bf98:	f9 bc 00 00 	moveq	r12,0
8000bf9c:	c0 50       	breq	8000bfa6 <__avr32_f64_div_res_subnormal+0x4c>
8000bf9e:	f4 06 09 40 	lsl	r0,r10,r6
8000bfa2:	f6 06 09 4c 	lsl	r12,r11,r6
8000bfa6:	e6 07 0a 42 	lsr	r2,r3,r7
8000bfaa:	30 03       	mov	r3,0
8000bfac:	f4 07 0a 41 	lsr	r1,r10,r7
8000bfb0:	18 41       	or	r1,r12
8000bfb2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bfb6:	30 0b       	mov	r11,0
8000bfb8:	e0 12 ff 00 	andl	r2,0xff00
8000bfbc:	e8 12 00 80 	orl	r2,0x80
8000bfc0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bfc4:	e4 09 07 46 	macu.d	r6,r2,r9
8000bfc8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bfcc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bfd0:	0c 05       	add	r5,r6
8000bfd2:	f0 07 00 48 	adc	r8,r8,r7
8000bfd6:	5c 09       	acr	r9
8000bfd8:	30 07       	mov	r7,0
8000bfda:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bfde:	00 34       	cp.w	r4,r0
8000bfe0:	e2 05 13 00 	cpc	r5,r1
8000bfe4:	c4 6b       	rjmp	8000be70 <__avr32_f64_div_round_subnormal>
8000bfe6:	1c 9b       	mov	r11,lr
8000bfe8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bfec:	30 0a       	mov	r10,0
8000bfee:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bff2:	3f fb       	mov	r11,-1
8000bff4:	30 0a       	mov	r10,0
8000bff6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bffa:	f5 eb 10 04 	or	r4,r10,r11
8000bffe:	c0 90       	breq	8000c010 <__avr32_f64_div_op1_zero>
8000c000:	1c 9b       	mov	r11,lr
8000c002:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c006:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c00a:	30 0a       	mov	r10,0
8000c00c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c010 <__avr32_f64_div_op1_zero>:
8000c010:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c014:	ce f0       	breq	8000bff2 <__avr32_f64_div_res_subnormal+0x98>
8000c016:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c01a:	e0 44 07 ff 	cp.w	r4,2047
8000c01e:	ce 41       	brne	8000bfe6 <__avr32_f64_div_res_subnormal+0x8c>
8000c020:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c024:	ce 10       	breq	8000bfe6 <__avr32_f64_div_res_subnormal+0x8c>
8000c026:	ce 6b       	rjmp	8000bff2 <__avr32_f64_div_res_subnormal+0x98>

8000c028 <__avr32_udiv64>:
8000c028:	d4 31       	pushm	r0-r7,lr
8000c02a:	1a 97       	mov	r7,sp
8000c02c:	20 3d       	sub	sp,12
8000c02e:	10 9c       	mov	r12,r8
8000c030:	12 9e       	mov	lr,r9
8000c032:	14 93       	mov	r3,r10
8000c034:	58 09       	cp.w	r9,0
8000c036:	e0 81 00 bd 	brne	8000c1b0 <__avr32_udiv64+0x188>
8000c03a:	16 38       	cp.w	r8,r11
8000c03c:	e0 88 00 40 	brls	8000c0bc <__avr32_udiv64+0x94>
8000c040:	f0 08 12 00 	clz	r8,r8
8000c044:	c0 d0       	breq	8000c05e <__avr32_udiv64+0x36>
8000c046:	f6 08 09 4b 	lsl	r11,r11,r8
8000c04a:	f0 09 11 20 	rsub	r9,r8,32
8000c04e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c052:	f4 09 0a 49 	lsr	r9,r10,r9
8000c056:	f4 08 09 43 	lsl	r3,r10,r8
8000c05a:	f3 eb 10 0b 	or	r11,r9,r11
8000c05e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c062:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c066:	f6 0e 0d 00 	divu	r0,r11,lr
8000c06a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c06e:	00 99       	mov	r9,r0
8000c070:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c074:	e0 0a 02 48 	mul	r8,r0,r10
8000c078:	10 3b       	cp.w	r11,r8
8000c07a:	c0 a2       	brcc	8000c08e <__avr32_udiv64+0x66>
8000c07c:	20 19       	sub	r9,1
8000c07e:	18 0b       	add	r11,r12
8000c080:	18 3b       	cp.w	r11,r12
8000c082:	c0 63       	brcs	8000c08e <__avr32_udiv64+0x66>
8000c084:	10 3b       	cp.w	r11,r8
8000c086:	f7 b9 03 01 	sublo	r9,1
8000c08a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c08e:	f6 08 01 01 	sub	r1,r11,r8
8000c092:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c096:	e2 0e 0d 00 	divu	r0,r1,lr
8000c09a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c09e:	00 98       	mov	r8,r0
8000c0a0:	e0 0a 02 4a 	mul	r10,r0,r10
8000c0a4:	14 33       	cp.w	r3,r10
8000c0a6:	c0 82       	brcc	8000c0b6 <__avr32_udiv64+0x8e>
8000c0a8:	20 18       	sub	r8,1
8000c0aa:	18 03       	add	r3,r12
8000c0ac:	18 33       	cp.w	r3,r12
8000c0ae:	c0 43       	brcs	8000c0b6 <__avr32_udiv64+0x8e>
8000c0b0:	14 33       	cp.w	r3,r10
8000c0b2:	f7 b8 03 01 	sublo	r8,1
8000c0b6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c0ba:	cd f8       	rjmp	8000c278 <__avr32_udiv64+0x250>
8000c0bc:	58 08       	cp.w	r8,0
8000c0be:	c0 51       	brne	8000c0c8 <__avr32_udiv64+0xa0>
8000c0c0:	30 19       	mov	r9,1
8000c0c2:	f2 08 0d 08 	divu	r8,r9,r8
8000c0c6:	10 9c       	mov	r12,r8
8000c0c8:	f8 06 12 00 	clz	r6,r12
8000c0cc:	c0 41       	brne	8000c0d4 <__avr32_udiv64+0xac>
8000c0ce:	18 1b       	sub	r11,r12
8000c0d0:	30 19       	mov	r9,1
8000c0d2:	c4 08       	rjmp	8000c152 <__avr32_udiv64+0x12a>
8000c0d4:	ec 01 11 20 	rsub	r1,r6,32
8000c0d8:	f4 01 0a 49 	lsr	r9,r10,r1
8000c0dc:	f8 06 09 4c 	lsl	r12,r12,r6
8000c0e0:	f6 06 09 48 	lsl	r8,r11,r6
8000c0e4:	f6 01 0a 41 	lsr	r1,r11,r1
8000c0e8:	f3 e8 10 08 	or	r8,r9,r8
8000c0ec:	f8 03 16 10 	lsr	r3,r12,0x10
8000c0f0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c0f4:	e2 03 0d 00 	divu	r0,r1,r3
8000c0f8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c0fc:	00 9e       	mov	lr,r0
8000c0fe:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c102:	e0 05 02 49 	mul	r9,r0,r5
8000c106:	12 3b       	cp.w	r11,r9
8000c108:	c0 a2       	brcc	8000c11c <__avr32_udiv64+0xf4>
8000c10a:	20 1e       	sub	lr,1
8000c10c:	18 0b       	add	r11,r12
8000c10e:	18 3b       	cp.w	r11,r12
8000c110:	c0 63       	brcs	8000c11c <__avr32_udiv64+0xf4>
8000c112:	12 3b       	cp.w	r11,r9
8000c114:	f7 be 03 01 	sublo	lr,1
8000c118:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c11c:	12 1b       	sub	r11,r9
8000c11e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c122:	f6 03 0d 02 	divu	r2,r11,r3
8000c126:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c12a:	04 99       	mov	r9,r2
8000c12c:	e4 05 02 4b 	mul	r11,r2,r5
8000c130:	16 38       	cp.w	r8,r11
8000c132:	c0 a2       	brcc	8000c146 <__avr32_udiv64+0x11e>
8000c134:	20 19       	sub	r9,1
8000c136:	18 08       	add	r8,r12
8000c138:	18 38       	cp.w	r8,r12
8000c13a:	c0 63       	brcs	8000c146 <__avr32_udiv64+0x11e>
8000c13c:	16 38       	cp.w	r8,r11
8000c13e:	f7 b9 03 01 	sublo	r9,1
8000c142:	f1 dc e3 08 	addcs	r8,r8,r12
8000c146:	f4 06 09 43 	lsl	r3,r10,r6
8000c14a:	f0 0b 01 0b 	sub	r11,r8,r11
8000c14e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c152:	f8 06 16 10 	lsr	r6,r12,0x10
8000c156:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c15a:	f6 06 0d 00 	divu	r0,r11,r6
8000c15e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c162:	00 9a       	mov	r10,r0
8000c164:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c168:	e0 0e 02 48 	mul	r8,r0,lr
8000c16c:	10 3b       	cp.w	r11,r8
8000c16e:	c0 a2       	brcc	8000c182 <__avr32_udiv64+0x15a>
8000c170:	20 1a       	sub	r10,1
8000c172:	18 0b       	add	r11,r12
8000c174:	18 3b       	cp.w	r11,r12
8000c176:	c0 63       	brcs	8000c182 <__avr32_udiv64+0x15a>
8000c178:	10 3b       	cp.w	r11,r8
8000c17a:	f7 ba 03 01 	sublo	r10,1
8000c17e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c182:	f6 08 01 01 	sub	r1,r11,r8
8000c186:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c18a:	e2 06 0d 00 	divu	r0,r1,r6
8000c18e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c192:	00 98       	mov	r8,r0
8000c194:	e0 0e 02 4b 	mul	r11,r0,lr
8000c198:	16 33       	cp.w	r3,r11
8000c19a:	c0 82       	brcc	8000c1aa <__avr32_udiv64+0x182>
8000c19c:	20 18       	sub	r8,1
8000c19e:	18 03       	add	r3,r12
8000c1a0:	18 33       	cp.w	r3,r12
8000c1a2:	c0 43       	brcs	8000c1aa <__avr32_udiv64+0x182>
8000c1a4:	16 33       	cp.w	r3,r11
8000c1a6:	f7 b8 03 01 	sublo	r8,1
8000c1aa:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c1ae:	c6 98       	rjmp	8000c280 <__avr32_udiv64+0x258>
8000c1b0:	16 39       	cp.w	r9,r11
8000c1b2:	e0 8b 00 65 	brhi	8000c27c <__avr32_udiv64+0x254>
8000c1b6:	f2 09 12 00 	clz	r9,r9
8000c1ba:	c0 b1       	brne	8000c1d0 <__avr32_udiv64+0x1a8>
8000c1bc:	10 3a       	cp.w	r10,r8
8000c1be:	5f 2a       	srhs	r10
8000c1c0:	1c 3b       	cp.w	r11,lr
8000c1c2:	5f b8       	srhi	r8
8000c1c4:	10 4a       	or	r10,r8
8000c1c6:	f2 0a 18 00 	cp.b	r10,r9
8000c1ca:	c5 90       	breq	8000c27c <__avr32_udiv64+0x254>
8000c1cc:	30 18       	mov	r8,1
8000c1ce:	c5 98       	rjmp	8000c280 <__avr32_udiv64+0x258>
8000c1d0:	f0 09 09 46 	lsl	r6,r8,r9
8000c1d4:	f2 03 11 20 	rsub	r3,r9,32
8000c1d8:	fc 09 09 4e 	lsl	lr,lr,r9
8000c1dc:	f0 03 0a 48 	lsr	r8,r8,r3
8000c1e0:	f6 09 09 4c 	lsl	r12,r11,r9
8000c1e4:	f4 03 0a 42 	lsr	r2,r10,r3
8000c1e8:	ef 46 ff f4 	st.w	r7[-12],r6
8000c1ec:	f6 03 0a 43 	lsr	r3,r11,r3
8000c1f0:	18 42       	or	r2,r12
8000c1f2:	f1 ee 10 0c 	or	r12,r8,lr
8000c1f6:	f8 01 16 10 	lsr	r1,r12,0x10
8000c1fa:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c1fe:	e6 01 0d 04 	divu	r4,r3,r1
8000c202:	e4 03 16 10 	lsr	r3,r2,0x10
8000c206:	08 9e       	mov	lr,r4
8000c208:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c20c:	e8 06 02 48 	mul	r8,r4,r6
8000c210:	10 33       	cp.w	r3,r8
8000c212:	c0 a2       	brcc	8000c226 <__avr32_udiv64+0x1fe>
8000c214:	20 1e       	sub	lr,1
8000c216:	18 03       	add	r3,r12
8000c218:	18 33       	cp.w	r3,r12
8000c21a:	c0 63       	brcs	8000c226 <__avr32_udiv64+0x1fe>
8000c21c:	10 33       	cp.w	r3,r8
8000c21e:	f7 be 03 01 	sublo	lr,1
8000c222:	e7 dc e3 03 	addcs	r3,r3,r12
8000c226:	10 13       	sub	r3,r8
8000c228:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c22c:	e6 01 0d 00 	divu	r0,r3,r1
8000c230:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c234:	00 98       	mov	r8,r0
8000c236:	e0 06 02 46 	mul	r6,r0,r6
8000c23a:	0c 3b       	cp.w	r11,r6
8000c23c:	c0 a2       	brcc	8000c250 <__avr32_udiv64+0x228>
8000c23e:	20 18       	sub	r8,1
8000c240:	18 0b       	add	r11,r12
8000c242:	18 3b       	cp.w	r11,r12
8000c244:	c0 63       	brcs	8000c250 <__avr32_udiv64+0x228>
8000c246:	0c 3b       	cp.w	r11,r6
8000c248:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c24c:	f7 b8 03 01 	sublo	r8,1
8000c250:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c254:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c258:	0c 1b       	sub	r11,r6
8000c25a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c25e:	06 95       	mov	r5,r3
8000c260:	16 35       	cp.w	r5,r11
8000c262:	e0 8b 00 0a 	brhi	8000c276 <__avr32_udiv64+0x24e>
8000c266:	5f 0b       	sreq	r11
8000c268:	f4 09 09 49 	lsl	r9,r10,r9
8000c26c:	12 32       	cp.w	r2,r9
8000c26e:	5f b9       	srhi	r9
8000c270:	f7 e9 00 09 	and	r9,r11,r9
8000c274:	c0 60       	breq	8000c280 <__avr32_udiv64+0x258>
8000c276:	20 18       	sub	r8,1
8000c278:	30 09       	mov	r9,0
8000c27a:	c0 38       	rjmp	8000c280 <__avr32_udiv64+0x258>
8000c27c:	30 09       	mov	r9,0
8000c27e:	12 98       	mov	r8,r9
8000c280:	10 9a       	mov	r10,r8
8000c282:	12 93       	mov	r3,r9
8000c284:	10 92       	mov	r2,r8
8000c286:	12 9b       	mov	r11,r9
8000c288:	2f dd       	sub	sp,-12
8000c28a:	d8 32       	popm	r0-r7,pc

8000c28c <__avr32_umod64>:
8000c28c:	d4 31       	pushm	r0-r7,lr
8000c28e:	1a 97       	mov	r7,sp
8000c290:	20 3d       	sub	sp,12
8000c292:	10 9c       	mov	r12,r8
8000c294:	12 95       	mov	r5,r9
8000c296:	14 9e       	mov	lr,r10
8000c298:	16 91       	mov	r1,r11
8000c29a:	16 96       	mov	r6,r11
8000c29c:	58 09       	cp.w	r9,0
8000c29e:	e0 81 00 81 	brne	8000c3a0 <__avr32_umod64+0x114>
8000c2a2:	16 38       	cp.w	r8,r11
8000c2a4:	e0 88 00 12 	brls	8000c2c8 <__avr32_umod64+0x3c>
8000c2a8:	f0 08 12 00 	clz	r8,r8
8000c2ac:	c4 e0       	breq	8000c348 <__avr32_umod64+0xbc>
8000c2ae:	f6 08 09 46 	lsl	r6,r11,r8
8000c2b2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2b6:	f0 0b 11 20 	rsub	r11,r8,32
8000c2ba:	f4 08 09 4e 	lsl	lr,r10,r8
8000c2be:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c2c2:	f7 e6 10 06 	or	r6,r11,r6
8000c2c6:	c4 18       	rjmp	8000c348 <__avr32_umod64+0xbc>
8000c2c8:	58 08       	cp.w	r8,0
8000c2ca:	c0 51       	brne	8000c2d4 <__avr32_umod64+0x48>
8000c2cc:	30 19       	mov	r9,1
8000c2ce:	f2 08 0d 08 	divu	r8,r9,r8
8000c2d2:	10 9c       	mov	r12,r8
8000c2d4:	f8 08 12 00 	clz	r8,r12
8000c2d8:	c0 31       	brne	8000c2de <__avr32_umod64+0x52>
8000c2da:	18 16       	sub	r6,r12
8000c2dc:	c3 68       	rjmp	8000c348 <__avr32_umod64+0xbc>
8000c2de:	f0 03 11 20 	rsub	r3,r8,32
8000c2e2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c2e6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2ea:	ec 08 09 49 	lsl	r9,r6,r8
8000c2ee:	ec 03 0a 43 	lsr	r3,r6,r3
8000c2f2:	f7 e9 10 09 	or	r9,r11,r9
8000c2f6:	f8 05 16 10 	lsr	r5,r12,0x10
8000c2fa:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c2fe:	e6 05 0d 02 	divu	r2,r3,r5
8000c302:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c306:	ec 02 02 4b 	mul	r11,r6,r2
8000c30a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c30e:	16 3e       	cp.w	lr,r11
8000c310:	c0 72       	brcc	8000c31e <__avr32_umod64+0x92>
8000c312:	18 0e       	add	lr,r12
8000c314:	18 3e       	cp.w	lr,r12
8000c316:	c0 43       	brcs	8000c31e <__avr32_umod64+0x92>
8000c318:	16 3e       	cp.w	lr,r11
8000c31a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c31e:	fc 0b 01 03 	sub	r3,lr,r11
8000c322:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c326:	e6 05 0d 02 	divu	r2,r3,r5
8000c32a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c32e:	a5 36       	mul	r6,r2
8000c330:	0c 39       	cp.w	r9,r6
8000c332:	c0 72       	brcc	8000c340 <__avr32_umod64+0xb4>
8000c334:	18 09       	add	r9,r12
8000c336:	18 39       	cp.w	r9,r12
8000c338:	c0 43       	brcs	8000c340 <__avr32_umod64+0xb4>
8000c33a:	0c 39       	cp.w	r9,r6
8000c33c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c340:	f2 06 01 06 	sub	r6,r9,r6
8000c344:	f4 08 09 4e 	lsl	lr,r10,r8
8000c348:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c34c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c350:	ec 0a 0d 02 	divu	r2,r6,r10
8000c354:	fc 09 16 10 	lsr	r9,lr,0x10
8000c358:	ea 02 02 4b 	mul	r11,r5,r2
8000c35c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c360:	16 39       	cp.w	r9,r11
8000c362:	c0 72       	brcc	8000c370 <__avr32_umod64+0xe4>
8000c364:	18 09       	add	r9,r12
8000c366:	18 39       	cp.w	r9,r12
8000c368:	c0 43       	brcs	8000c370 <__avr32_umod64+0xe4>
8000c36a:	16 39       	cp.w	r9,r11
8000c36c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c370:	f2 0b 01 0b 	sub	r11,r9,r11
8000c374:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c378:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c37c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c380:	ea 0a 02 4a 	mul	r10,r5,r10
8000c384:	14 3e       	cp.w	lr,r10
8000c386:	c0 72       	brcc	8000c394 <__avr32_umod64+0x108>
8000c388:	18 0e       	add	lr,r12
8000c38a:	18 3e       	cp.w	lr,r12
8000c38c:	c0 43       	brcs	8000c394 <__avr32_umod64+0x108>
8000c38e:	14 3e       	cp.w	lr,r10
8000c390:	fd dc e3 0e 	addcs	lr,lr,r12
8000c394:	fc 0a 01 0a 	sub	r10,lr,r10
8000c398:	30 0b       	mov	r11,0
8000c39a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c39e:	c7 b8       	rjmp	8000c494 <__avr32_umod64+0x208>
8000c3a0:	16 39       	cp.w	r9,r11
8000c3a2:	e0 8b 00 79 	brhi	8000c494 <__avr32_umod64+0x208>
8000c3a6:	f2 09 12 00 	clz	r9,r9
8000c3aa:	c1 21       	brne	8000c3ce <__avr32_umod64+0x142>
8000c3ac:	10 3a       	cp.w	r10,r8
8000c3ae:	5f 2b       	srhs	r11
8000c3b0:	0a 31       	cp.w	r1,r5
8000c3b2:	5f ba       	srhi	r10
8000c3b4:	f7 ea 10 0a 	or	r10,r11,r10
8000c3b8:	f2 0a 18 00 	cp.b	r10,r9
8000c3bc:	c0 60       	breq	8000c3c8 <__avr32_umod64+0x13c>
8000c3be:	fc 08 01 0c 	sub	r12,lr,r8
8000c3c2:	e2 05 01 46 	sbc	r6,r1,r5
8000c3c6:	18 9e       	mov	lr,r12
8000c3c8:	0c 9b       	mov	r11,r6
8000c3ca:	1c 9a       	mov	r10,lr
8000c3cc:	c6 48       	rjmp	8000c494 <__avr32_umod64+0x208>
8000c3ce:	ea 09 09 4c 	lsl	r12,r5,r9
8000c3d2:	f2 06 11 20 	rsub	r6,r9,32
8000c3d6:	f6 09 09 4b 	lsl	r11,r11,r9
8000c3da:	f0 09 09 42 	lsl	r2,r8,r9
8000c3de:	ef 46 ff f4 	st.w	r7[-12],r6
8000c3e2:	f0 06 0a 48 	lsr	r8,r8,r6
8000c3e6:	18 48       	or	r8,r12
8000c3e8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c3ec:	f4 09 09 43 	lsl	r3,r10,r9
8000c3f0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c3f4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c3f8:	16 4a       	or	r10,r11
8000c3fa:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c3fe:	f8 0b 0d 04 	divu	r4,r12,r11
8000c402:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c406:	08 91       	mov	r1,r4
8000c408:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c40c:	e8 0e 02 46 	mul	r6,r4,lr
8000c410:	0c 3c       	cp.w	r12,r6
8000c412:	c0 a2       	brcc	8000c426 <__avr32_umod64+0x19a>
8000c414:	20 11       	sub	r1,1
8000c416:	10 0c       	add	r12,r8
8000c418:	10 3c       	cp.w	r12,r8
8000c41a:	c0 63       	brcs	8000c426 <__avr32_umod64+0x19a>
8000c41c:	0c 3c       	cp.w	r12,r6
8000c41e:	f7 b1 03 01 	sublo	r1,1
8000c422:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c426:	0c 1c       	sub	r12,r6
8000c428:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c42c:	f8 0b 0d 04 	divu	r4,r12,r11
8000c430:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c434:	08 96       	mov	r6,r4
8000c436:	e8 0e 02 4e 	mul	lr,r4,lr
8000c43a:	1c 3b       	cp.w	r11,lr
8000c43c:	c0 a2       	brcc	8000c450 <__avr32_umod64+0x1c4>
8000c43e:	20 16       	sub	r6,1
8000c440:	10 0b       	add	r11,r8
8000c442:	10 3b       	cp.w	r11,r8
8000c444:	c0 63       	brcs	8000c450 <__avr32_umod64+0x1c4>
8000c446:	1c 3b       	cp.w	r11,lr
8000c448:	f7 b6 03 01 	sublo	r6,1
8000c44c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c450:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c454:	1c 1b       	sub	r11,lr
8000c456:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c45a:	00 9e       	mov	lr,r0
8000c45c:	02 9c       	mov	r12,r1
8000c45e:	16 3c       	cp.w	r12,r11
8000c460:	e0 8b 00 08 	brhi	8000c470 <__avr32_umod64+0x1e4>
8000c464:	5f 06       	sreq	r6
8000c466:	06 30       	cp.w	r0,r3
8000c468:	5f ba       	srhi	r10
8000c46a:	ed ea 00 0a 	and	r10,r6,r10
8000c46e:	c0 60       	breq	8000c47a <__avr32_umod64+0x1ee>
8000c470:	fc 02 01 04 	sub	r4,lr,r2
8000c474:	f8 08 01 4c 	sbc	r12,r12,r8
8000c478:	08 9e       	mov	lr,r4
8000c47a:	e6 0e 01 0a 	sub	r10,r3,lr
8000c47e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c482:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c486:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c48a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c48e:	f8 01 09 4c 	lsl	r12,r12,r1
8000c492:	18 4a       	or	r10,r12
8000c494:	2f dd       	sub	sp,-12
8000c496:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c600:	c0 08       	rjmp	8000c600 <_evba>
	...

8000c604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c604:	c0 08       	rjmp	8000c604 <_handle_TLB_Multiple_Hit>
	...

8000c608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c608:	c0 08       	rjmp	8000c608 <_handle_Bus_Error_Data_Fetch>
	...

8000c60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c60c:	c0 08       	rjmp	8000c60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c610:	c0 08       	rjmp	8000c610 <_handle_NMI>
	...

8000c614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c614:	c0 08       	rjmp	8000c614 <_handle_Instruction_Address>
	...

8000c618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c618:	c0 08       	rjmp	8000c618 <_handle_ITLB_Protection>
	...

8000c61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c61c:	c0 08       	rjmp	8000c61c <_handle_Breakpoint>
	...

8000c620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c620:	c0 08       	rjmp	8000c620 <_handle_Illegal_Opcode>
	...

8000c624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c624:	c0 08       	rjmp	8000c624 <_handle_Unimplemented_Instruction>
	...

8000c628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c628:	c0 08       	rjmp	8000c628 <_handle_Privilege_Violation>
	...

8000c62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c62c:	c0 08       	rjmp	8000c62c <_handle_Floating_Point>
	...

8000c630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c630:	c0 08       	rjmp	8000c630 <_handle_Coprocessor_Absent>
	...

8000c634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c634:	c0 08       	rjmp	8000c634 <_handle_Data_Address_Read>
	...

8000c638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c638:	c0 08       	rjmp	8000c638 <_handle_Data_Address_Write>
	...

8000c63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c63c:	c0 08       	rjmp	8000c63c <_handle_DTLB_Protection_Read>
	...

8000c640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c640:	c0 08       	rjmp	8000c640 <_handle_DTLB_Protection_Write>
	...

8000c644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c644:	c0 08       	rjmp	8000c644 <_handle_DTLB_Modified>
	...

8000c650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c650:	c0 08       	rjmp	8000c650 <_handle_ITLB_Miss>
	...

8000c660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c660:	c0 08       	rjmp	8000c660 <_handle_DTLB_Miss_Read>
	...

8000c670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c670:	c0 08       	rjmp	8000c670 <_handle_DTLB_Miss_Write>
	...

8000c700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c700:	fe cf 71 78 	sub	pc,pc,29048

8000c704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c704:	30 0c       	mov	r12,0
8000c706:	fe b0 c3 71 	rcall	80004de8 <_get_interrupt_handler>
8000c70a:	58 0c       	cp.w	r12,0
8000c70c:	f8 0f 17 10 	movne	pc,r12
8000c710:	d6 03       	rete

8000c712 <_int1>:
8000c712:	30 1c       	mov	r12,1
8000c714:	fe b0 c3 6a 	rcall	80004de8 <_get_interrupt_handler>
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	f8 0f 17 10 	movne	pc,r12
8000c71e:	d6 03       	rete

8000c720 <_int2>:
8000c720:	30 2c       	mov	r12,2
8000c722:	fe b0 c3 63 	rcall	80004de8 <_get_interrupt_handler>
8000c726:	58 0c       	cp.w	r12,0
8000c728:	f8 0f 17 10 	movne	pc,r12
8000c72c:	d6 03       	rete

8000c72e <_int3>:
8000c72e:	30 3c       	mov	r12,3
8000c730:	fe b0 c3 5c 	rcall	80004de8 <_get_interrupt_handler>
8000c734:	58 0c       	cp.w	r12,0
8000c736:	f8 0f 17 10 	movne	pc,r12
8000c73a:	d6 03       	rete

8000c73c <ipr_val>:
8000c73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7fc:	d7 03 d7 03                                         ....
