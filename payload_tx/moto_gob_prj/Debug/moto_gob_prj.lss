
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000e0f0  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010200  80010200  00010600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000099c  80010400  80010400  00010800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  80010d9c  80010d9c  0001119c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a48  00000008  80010da0  00011408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          000036c8  00000a50  00000a50  00000000  2**2
                  ALLOC
  9 .heap         00012ee8  00004118  00004118  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00011e50  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001318  00000000  00000000  00011e80  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000270f  00000000  00000000  00013198  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00029579  00000000  00000000  000158a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000063a1  00000000  00000000  0003ee20  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00015c2b  00000000  00000000  000451c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000344c  00000000  00000000  0005adec  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007242  00000000  00000000  0005e238  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000afcf  00000000  00000000  0006547a  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 0150c54f  00000000  00000000  00070449  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001358  00000000  00000000  0157c998  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	a7 b8       	sbr	r8,0x7

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	a7 b8       	sbr	r8,0x7

Disassembly of section .text:

80002010 <DeviceInitializationStatus_brdcst_func-0x71c>:
80002010:	54 6f       	stdsp	sp[0x118],pc
80002012:	6e 65       	ld.w	r5,r7[0x18]
80002014:	20 4f       	sub	pc,4
80002016:	4b 00       	lddpc	r0,800020d4 <program_start+0xcc>
80002018:	54 6f       	stdsp	sp[0x118],pc
8000201a:	6e 65       	ld.w	r5,r7[0x18]
8000201c:	20 65       	sub	r5,6
8000201e:	72 72       	ld.w	r2,r9[0x1c]
80002020:	6f 72       	ld.w	r2,r7[0x5c]
80002022:	00 00       	add	r0,r0
80002024:	0a 0d       	add	sp,r5
80002026:	20 44       	sub	r4,4
80002028:	63 6d       	ld.w	sp,r1[0x58]
8000202a:	2d 45       	sub	r5,-44
8000202c:	6e 74       	ld.w	r4,r7[0x1c]
8000202e:	65 72       	ld.w	r2,r2[0x5c]
80002030:	20 4f       	sub	pc,4
80002032:	4b 20       	lddpc	r0,800020f8 <program_start+0xf0>
80002034:	0a 0d       	add	sp,r5
80002036:	00 00       	add	r0,r0
80002038:	0a 0d       	add	sp,r5
8000203a:	20 44       	sub	r4,4
8000203c:	63 6d       	ld.w	sp,r1[0x58]
8000203e:	2d 45       	sub	r5,-44
80002040:	78 69       	ld.w	r9,r12[0x18]
80002042:	74 20       	ld.w	r0,r10[0x8]
80002044:	4f 4b       	lddpc	r11,80002214 <program_start+0x20c>
80002046:	20 0a       	sub	r10,0
80002048:	0d 00       	ld.w	r0,r6++
8000204a:	00 00       	add	r0,r0
8000204c:	0a 0d       	add	sp,r5
8000204e:	20 44       	sub	r4,4
80002050:	63 6d       	ld.w	sp,r1[0x58]
80002052:	2d 52       	sub	r2,-43
80002054:	65 76       	ld.w	r6,r2[0x5c]
80002056:	6f 6b       	ld.w	r11,r7[0x58]
80002058:	65 20       	ld.w	r0,r2[0x48]
8000205a:	0a 0d       	add	sp,r5
8000205c:	00 00       	add	r0,r0
8000205e:	00 00       	add	r0,r0
80002060:	64 63       	ld.w	r3,r2[0x18]
80002062:	6d 20       	ld.w	r0,r6[0x48]
80002064:	4f 4b       	lddpc	r11,80002234 <program_start+0x22c>
80002066:	2d 6d       	sub	sp,-168
80002068:	6f 25       	ld.w	r5,r7[0x48]
8000206a:	58 00       	cp.w	r0,0
8000206c:	64 63       	ld.w	r3,r2[0x18]
8000206e:	6d 20       	ld.w	r0,r6[0x48]
80002070:	65 72       	ld.w	r2,r2[0x5c]
80002072:	72 6f       	ld.w	pc,r9[0x18]
80002074:	72 00       	ld.w	r0,r9[0x0]
80002076:	00 00       	add	r0,r0
80002078:	0a 0d       	add	sp,r5
8000207a:	20 44       	sub	r4,4
8000207c:	63 6d       	ld.w	sp,r1[0x58]
8000207e:	5f 62       	srmi	r2
80002080:	72 64       	ld.w	r4,r9[0x18]
80002082:	63 73       	ld.w	r3,r1[0x5c]
80002084:	74 20       	ld.w	r0,r10[0x8]
80002086:	0a 0d       	add	sp,r5
80002088:	00 00       	add	r0,r0
8000208a:	00 00       	add	r0,r0
8000208c:	0a 0d       	add	sp,r5
8000208e:	20 46       	sub	r6,4
80002090:	75 6e       	ld.w	lr,r10[0x58]
80002092:	63 74       	ld.w	r4,r1[0x5c]
80002094:	69 6f       	ld.w	pc,r4[0x58]
80002096:	6e 3a       	ld.w	r10,r7[0xc]
80002098:	20 25       	sub	r5,2
8000209a:	78 20       	ld.w	r0,r12[0x8]
8000209c:	0a 0d       	add	sp,r5
8000209e:	20 00       	sub	r0,0
800020a0:	0a 0d       	add	sp,r5
800020a2:	20 43       	sub	r3,4
800020a4:	6f 6e       	ld.w	lr,r7[0x58]
800020a6:	74 72       	ld.w	r2,r10[0x1c]
800020a8:	6f 6c       	ld.w	r12,r7[0x58]
800020aa:	54 79       	stdsp	sp[0x11c],r9
800020ac:	70 65       	ld.w	r5,r8[0x18]
800020ae:	3a 20       	mov	r0,-94
800020b0:	25 78       	sub	r8,87
800020b2:	20 0a       	sub	r10,0
800020b4:	0d 20       	ld.uh	r0,r6++
800020b6:	00 00       	add	r0,r0
800020b8:	0a 0d       	add	sp,r5
800020ba:	20 43       	sub	r3,4
800020bc:	6f 6e       	ld.w	lr,r7[0x58]
800020be:	74 72       	ld.w	r2,r10[0x1c]
800020c0:	6f 6c       	ld.w	r12,r7[0x58]
800020c2:	54 79       	stdsp	sp[0x11c],r9
800020c4:	70 65       	ld.w	r5,r8[0x18]
800020c6:	53 69       	stdsp	sp[0xd8],r9
800020c8:	7a 65       	ld.w	r5,sp[0x18]
800020ca:	3a 20       	mov	r0,-94
800020cc:	25 78       	sub	r8,87
800020ce:	20 0a       	sub	r10,0
800020d0:	0d 20       	ld.uh	r0,r6++
800020d2:	00 00       	add	r0,r0
800020d4:	0a 0d       	add	sp,r5
800020d6:	20 4d       	sub	sp,16
800020d8:	69 63       	ld.w	r3,r4[0x58]
800020da:	5f 72       	srpl	r2
800020dc:	65 70       	ld.w	r0,r2[0x5c]
800020de:	6c 79       	ld.w	r9,r6[0x1c]
800020e0:	20 0a       	sub	r10,0
800020e2:	0d 00       	ld.w	r0,r6++
800020e4:	0a 0d       	add	sp,r5
800020e6:	20 4d       	sub	sp,16
800020e8:	69 63       	ld.w	r3,r4[0x58]
800020ea:	5f 63       	srmi	r3
800020ec:	6c 6f       	ld.w	pc,r6[0x18]
800020ee:	73 65       	ld.w	r5,r9[0x58]
800020f0:	5f 6f       	srmi	pc
800020f2:	6b 20       	ld.w	r0,r5[0x48]
800020f4:	0a 0d       	add	sp,r5
800020f6:	20 00       	sub	r0,0
800020f8:	0a 0d       	add	sp,r5
800020fa:	20 4d       	sub	sp,16
800020fc:	69 63       	ld.w	r3,r4[0x58]
800020fe:	5f 74       	srpl	r4
80002100:	79 70       	ld.w	r0,r12[0x5c]
80002102:	65 3a       	ld.w	r10,r2[0x4c]
80002104:	20 25       	sub	r5,2
80002106:	78 20       	ld.w	r0,r12[0x8]
80002108:	0a 0d       	add	sp,r5
8000210a:	20 00       	sub	r0,0
8000210c:	0a 0d       	add	sp,r5
8000210e:	20 53       	sub	r3,5
80002110:	69 67       	ld.w	r7,r4[0x58]
80002112:	6e 61       	ld.w	r1,r7[0x18]
80002114:	6c 69       	ld.w	r9,r6[0x18]
80002116:	6e 67       	ld.w	r7,r7[0x18]
80002118:	5f 74       	srpl	r4
8000211a:	79 70       	ld.w	r0,r12[0x5c]
8000211c:	65 3a       	ld.w	r10,r2[0x4c]
8000211e:	20 25       	sub	r5,2
80002120:	78 20       	ld.w	r0,r12[0x8]
80002122:	0a 0d       	add	sp,r5
80002124:	20 00       	sub	r0,0
80002126:	00 00       	add	r0,r0
80002128:	0a 0d       	add	sp,r5
8000212a:	20 4d       	sub	sp,16
8000212c:	69 63       	ld.w	r3,r4[0x58]
8000212e:	5f 73       	srpl	r3
80002130:	74 61       	ld.w	r1,r10[0x18]
80002132:	74 65       	ld.w	r5,r10[0x18]
80002134:	3a 20       	mov	r0,-94
80002136:	25 78       	sub	r8,87
80002138:	20 0a       	sub	r10,0
8000213a:	0d 20       	ld.uh	r0,r6++
8000213c:	00 00       	add	r0,r0
8000213e:	00 00       	add	r0,r0
80002140:	0a 0d       	add	sp,r5
80002142:	20 47       	sub	r7,4
80002144:	61 69       	ld.w	r9,r0[0x58]
80002146:	6e 5f       	ld.w	pc,r7[0x14]
80002148:	6f 66       	ld.w	r6,r7[0x58]
8000214a:	66 73       	ld.w	r3,r3[0x1c]
8000214c:	65 74       	ld.w	r4,r2[0x5c]
8000214e:	3a 20       	mov	r0,-94
80002150:	25 78       	sub	r8,87
80002152:	20 0a       	sub	r10,0
80002154:	0d 20       	ld.uh	r0,r6++
80002156:	00 00       	add	r0,r0
80002158:	0a 0d       	add	sp,r5
8000215a:	20 4d       	sub	sp,16
8000215c:	69 63       	ld.w	r3,r4[0x58]
8000215e:	5f 66       	srmi	r6
80002160:	75 6e       	ld.w	lr,r10[0x58]
80002162:	63 74       	ld.w	r4,r1[0x5c]
80002164:	69 6f       	ld.w	pc,r4[0x58]
80002166:	6e 3a       	ld.w	r10,r7[0xc]
80002168:	20 25       	sub	r5,2
8000216a:	78 20       	ld.w	r0,r12[0x8]
8000216c:	0a 0d       	add	sp,r5
8000216e:	20 00       	sub	r0,0
80002170:	0a 0d       	add	sp,r5
80002172:	20 4d       	sub	sp,16
80002174:	69 63       	ld.w	r3,r4[0x58]
80002176:	20 65       	sub	r5,6
80002178:	72 72       	ld.w	r2,r9[0x1c]
8000217a:	6f 72       	ld.w	r2,r7[0x5c]
8000217c:	20 0a       	sub	r10,0
8000217e:	0d 00       	ld.w	r0,r6++
80002180:	0a 0d       	add	sp,r5
80002182:	20 4d       	sub	sp,16
80002184:	69 63       	ld.w	r3,r4[0x58]
80002186:	5f 44       	srge	r4
80002188:	69 73       	ld.w	r3,r4[0x5c]
8000218a:	61 62       	ld.w	r2,r0[0x58]
8000218c:	6c 65       	ld.w	r5,r6[0x18]
8000218e:	64 20       	ld.w	r0,r2[0x8]
80002190:	0a 0d       	add	sp,r5
80002192:	00 00       	add	r0,r0
80002194:	0a 0d       	add	sp,r5
80002196:	20 4d       	sub	sp,16
80002198:	69 63       	ld.w	r3,r4[0x58]
8000219a:	5f 45       	srge	r5
8000219c:	6e 61       	ld.w	r1,r7[0x18]
8000219e:	62 6c       	ld.w	r12,r1[0x18]
800021a0:	65 64       	ld.w	r4,r2[0x58]
800021a2:	20 0a       	sub	r10,0
800021a4:	0d 00       	ld.w	r0,r6++
800021a6:	00 00       	add	r0,r0
800021a8:	73 70       	ld.w	r0,r9[0x5c]
800021aa:	6b 20       	ld.w	r0,r5[0x48]
800021ac:	4f 4b       	lddpc	r11,8000237c <program_start+0x374>
800021ae:	20 2d       	sub	sp,8
800021b0:	73 74       	ld.w	r4,r9[0x5c]
800021b2:	25 32       	sub	r2,83
800021b4:	78 00       	ld.w	r0,r12[0x0]
800021b6:	00 00       	add	r0,r0
800021b8:	73 70       	ld.w	r0,r9[0x5c]
800021ba:	6b 20       	ld.w	r0,r5[0x48]
800021bc:	65 72       	ld.w	r2,r2[0x5c]
800021be:	72 6f       	ld.w	pc,r9[0x18]
800021c0:	72 00       	ld.w	r0,r9[0x0]
800021c2:	00 00       	add	r0,r0
800021c4:	73 70       	ld.w	r0,r9[0x5c]
800021c6:	6b 5f       	ld.w	pc,r5[0x54]
800021c8:	73 5f       	ld.w	pc,r9[0x54]
800021ca:	63 6c       	ld.w	r12,r1[0x58]
800021cc:	6f 73       	ld.w	r3,r7[0x5c]
800021ce:	65 20       	ld.w	r0,r2[0x48]
800021d0:	00 00       	add	r0,r0
800021d2:	00 00       	add	r0,r0
800021d4:	73 70       	ld.w	r0,r9[0x5c]
800021d6:	6b 5f       	ld.w	pc,r5[0x54]
800021d8:	73 5f       	ld.w	pc,r9[0x54]
800021da:	6f 70       	ld.w	r0,r7[0x5c]
800021dc:	65 6e       	ld.w	lr,r2[0x58]
800021de:	20 00       	sub	r0,0
800021e0:	0a 0d       	add	sp,r5
800021e2:	20 45       	sub	r5,4
800021e4:	6e 61       	ld.w	r1,r7[0x18]
800021e6:	62 6c       	ld.w	r12,r1[0x18]
800021e8:	65 5f       	ld.w	pc,r2[0x54]
800021ea:	49 41       	lddpc	r1,80002238 <program_start+0x230>
800021ec:	20 4f       	sub	pc,4
800021ee:	4b 20       	lddpc	r0,800022b4 <program_start+0x2ac>
800021f0:	0a 0d       	add	sp,r5
800021f2:	00 00       	add	r0,r0
800021f4:	0a 0d       	add	sp,r5
800021f6:	20 41       	sub	r1,4
800021f8:	74 74       	ld.w	r4,r10[0x1c]
800021fa:	65 6e       	ld.w	lr,r2[0x58]
800021fc:	75 61       	ld.w	r1,r10[0x58]
800021fe:	74 6f       	ld.w	pc,r10[0x18]
80002200:	72 5f       	ld.w	pc,r9[0x14]
80002202:	4e 75       	lddpc	r5,8000239c <program_start+0x394>
80002204:	6d 62       	ld.w	r2,r6[0x58]
80002206:	65 72       	ld.w	r2,r2[0x5c]
80002208:	3a 20       	mov	r0,-94
8000220a:	25 78       	sub	r8,87
8000220c:	20 0a       	sub	r10,0
8000220e:	0d 00       	ld.w	r0,r6++
80002210:	0a 0d       	add	sp,r5
80002212:	20 56       	sub	r6,5
80002214:	6f 6c       	ld.w	r12,r7[0x58]
80002216:	75 6d       	ld.w	sp,r10[0x58]
80002218:	65 43       	ld.w	r3,r2[0x50]
8000221a:	6f 6e       	ld.w	lr,r7[0x58]
8000221c:	74 72       	ld.w	r2,r10[0x1c]
8000221e:	6f 6c       	ld.w	r12,r7[0x58]
80002220:	3a 20       	mov	r0,-94
80002222:	25 78       	sub	r8,87
80002224:	20 0a       	sub	r10,0
80002226:	0d 00       	ld.w	r0,r6++
80002228:	0a 0d       	add	sp,r5
8000222a:	20 45       	sub	r5,4
8000222c:	6e 61       	ld.w	r1,r7[0x18]
8000222e:	62 6c       	ld.w	r12,r1[0x18]
80002230:	65 5f       	ld.w	pc,r2[0x54]
80002232:	49 41       	lddpc	r1,80002280 <program_start+0x278>
80002234:	20 65       	sub	r5,6
80002236:	72 72       	ld.w	r2,r9[0x1c]
80002238:	6f 72       	ld.w	r2,r7[0x5c]
8000223a:	20 0a       	sub	r10,0
8000223c:	0d 00       	ld.w	r0,r6++
8000223e:	00 00       	add	r0,r0
80002240:	41 75       	lddsp	r5,sp[0x5c]
80002242:	64 69       	ld.w	r9,r2[0x18]
80002244:	6f 52       	ld.w	r2,r7[0x54]
80002246:	6f 75       	ld.w	r5,r7[0x5c]
80002248:	74 69       	ld.w	r9,r10[0x18]
8000224a:	6e 67       	ld.w	r7,r7[0x18]
8000224c:	20 4f       	sub	pc,4
8000224e:	4b 00       	lddpc	r0,8000230c <program_start+0x304>
80002250:	41 75       	lddsp	r5,sp[0x5c]
80002252:	64 69       	ld.w	r9,r2[0x18]
80002254:	6f 52       	ld.w	r2,r7[0x54]
80002256:	6f 75       	ld.w	r5,r7[0x5c]
80002258:	74 69       	ld.w	r9,r10[0x18]
8000225a:	6e 67       	ld.w	r7,r7[0x18]
8000225c:	20 65       	sub	r5,6
8000225e:	72 72       	ld.w	r2,r9[0x1c]
80002260:	6f 72       	ld.w	r2,r7[0x5c]
80002262:	00 00       	add	r0,r0
80002264:	0a 0d       	add	sp,r5
80002266:	20 20       	sub	r0,2
80002268:	54 72       	stdsp	sp[0x11c],r2
8000226a:	61 6e       	ld.w	lr,r0[0x58]
8000226c:	73 6d       	ld.w	sp,r9[0x58]
8000226e:	69 74       	ld.w	r4,r4[0x5c]
80002270:	43 6f       	lddsp	pc,sp[0xd8]
80002272:	6e 74       	ld.w	r4,r7[0x1c]
80002274:	72 6f       	ld.w	pc,r9[0x18]
80002276:	6c 20       	ld.w	r0,r6[0x8]
80002278:	4f 4b       	lddpc	r11,80002448 <program_start+0x440>
8000227a:	20 0a       	sub	r10,0
8000227c:	0d 20       	ld.uh	r0,r6++
8000227e:	00 00       	add	r0,r0
80002280:	0a 0d       	add	sp,r5
80002282:	20 46       	sub	r6,4
80002284:	75 6e       	ld.w	lr,r10[0x58]
80002286:	63 74       	ld.w	r4,r1[0x5c]
80002288:	69 6f       	ld.w	pc,r4[0x58]
8000228a:	6e 3a       	ld.w	r10,r7[0xc]
8000228c:	20 25       	sub	r5,2
8000228e:	78 20       	ld.w	r0,r12[0x8]
80002290:	0a 0d       	add	sp,r5
80002292:	00 00       	add	r0,r0
80002294:	0a 0d       	add	sp,r5
80002296:	20 4d       	sub	sp,16
80002298:	6f 64       	ld.w	r4,r7[0x58]
8000229a:	65 20       	ld.w	r0,r2[0x48]
8000229c:	6f 66       	ld.w	r6,r7[0x58]
8000229e:	20 4f       	sub	pc,4
800022a0:	70 65       	ld.w	r5,r8[0x18]
800022a2:	72 61       	ld.w	r1,r9[0x18]
800022a4:	74 69       	ld.w	r9,r10[0x18]
800022a6:	6f 6e       	ld.w	lr,r7[0x58]
800022a8:	3a 20       	mov	r0,-94
800022aa:	25 78       	sub	r8,87
800022ac:	20 0a       	sub	r10,0
800022ae:	0d 00       	ld.w	r0,r6++
800022b0:	0a 0d       	add	sp,r5
800022b2:	20 53       	sub	r3,5
800022b4:	74 61       	ld.w	r1,r10[0x18]
800022b6:	74 65       	ld.w	r5,r10[0x18]
800022b8:	3a 20       	mov	r0,-94
800022ba:	25 78       	sub	r8,87
800022bc:	20 0a       	sub	r10,0
800022be:	0d 00       	ld.w	r0,r6++
800022c0:	54 72       	stdsp	sp[0x11c],r2
800022c2:	61 6e       	ld.w	lr,r0[0x58]
800022c4:	73 6d       	ld.w	sp,r9[0x58]
800022c6:	69 74       	ld.w	r4,r4[0x5c]
800022c8:	43 6f       	lddsp	pc,sp[0xd8]
800022ca:	6e 74       	ld.w	r4,r7[0x1c]
800022cc:	72 6f       	ld.w	pc,r9[0x18]
800022ce:	6c 20       	ld.w	r0,r6[0x8]
800022d0:	65 72       	ld.w	r2,r2[0x5c]
800022d2:	72 6f       	ld.w	pc,r9[0x18]
800022d4:	72 00       	ld.w	r0,r9[0x0]
800022d6:	00 00       	add	r0,r0
800022d8:	0a 0d       	add	sp,r5
800022da:	20 20       	sub	r0,2
800022dc:	53 74       	stdsp	sp[0xdc],r4
800022de:	61 6e       	ld.w	lr,r0[0x58]
800022e0:	64 62       	ld.w	r2,r2[0x18]
800022e2:	79 2d       	ld.w	sp,r12[0x48]
800022e4:	52 65       	stdsp	sp[0x98],r5
800022e6:	63 65       	ld.w	r5,r1[0x58]
800022e8:	69 76       	ld.w	r6,r4[0x5c]
800022ea:	65 20       	ld.w	r0,r2[0x48]
800022ec:	0a 0d       	add	sp,r5
800022ee:	20 00       	sub	r0,0
800022f0:	0a 0d       	add	sp,r5
800022f2:	20 20       	sub	r0,2
800022f4:	54 72       	stdsp	sp[0x11c],r2
800022f6:	61 6e       	ld.w	lr,r0[0x58]
800022f8:	73 6d       	ld.w	sp,r9[0x58]
800022fa:	69 74       	ld.w	r4,r4[0x5c]
800022fc:	20 0a       	sub	r10,0
800022fe:	0d 20       	ld.uh	r0,r6++
80002300:	00 00       	add	r0,r0
80002302:	00 00       	add	r0,r0
80002304:	0a 0d       	add	sp,r5
80002306:	20 20       	sub	r0,2
80002308:	43 61       	lddsp	r1,sp[0xd8]
8000230a:	6c 6c       	ld.w	r12,r6[0x18]
8000230c:	5f 73       	srpl	r3
8000230e:	74 61       	ld.w	r1,r10[0x18]
80002310:	74 65       	ld.w	r5,r10[0x18]
80002312:	3a 20       	mov	r0,-94
80002314:	25 78       	sub	r8,87
80002316:	20 0a       	sub	r10,0
80002318:	0d 20       	ld.uh	r0,r6++
8000231a:	00 00       	add	r0,r0
8000231c:	0a 0d       	add	sp,r5
8000231e:	20 44       	sub	r4,4
80002320:	41 54       	lddsp	r4,sp[0x54]
80002322:	41 72       	lddsp	r2,sp[0x5c]
80002324:	65 70       	ld.w	r0,r2[0x5c]
80002326:	20 4f       	sub	pc,4
80002328:	4b 20       	lddpc	r0,800023f0 <program_start+0x3e8>
8000232a:	0a 0d       	add	sp,r5
8000232c:	00 00       	add	r0,r0
8000232e:	00 00       	add	r0,r0
80002330:	0a 0d       	add	sp,r5
80002332:	20 52       	sub	r2,5
80002334:	65 73       	ld.w	r3,r2[0x5c]
80002336:	75 6c       	ld.w	r12,r10[0x58]
80002338:	74 3a       	ld.w	r10,r10[0xc]
8000233a:	20 20       	sub	r0,2
8000233c:	25 58       	sub	r8,85
8000233e:	20 0a       	sub	r10,0
80002340:	0d 00       	ld.w	r0,r6++
80002342:	00 00       	add	r0,r0
80002344:	0a 0d       	add	sp,r5
80002346:	20 44       	sub	r4,4
80002348:	41 54       	lddsp	r4,sp[0x54]
8000234a:	41 72       	lddsp	r2,sp[0x5c]
8000234c:	65 70       	ld.w	r0,r2[0x5c]
8000234e:	20 65       	sub	r5,6
80002350:	72 72       	ld.w	r2,r9[0x1c]
80002352:	6f 72       	ld.w	r2,r7[0x5c]
80002354:	20 0a       	sub	r10,0
80002356:	0d 00       	ld.w	r0,r6++
80002358:	0a 0d       	add	sp,r5
8000235a:	20 46       	sub	r6,4
8000235c:	75 6e       	ld.w	lr,r10[0x58]
8000235e:	63 3a       	ld.w	r10,r1[0x4c]
80002360:	20 20       	sub	r0,2
80002362:	25 58       	sub	r8,85
80002364:	20 0a       	sub	r10,0
80002366:	0d 00       	ld.w	r0,r6++
80002368:	0a 0d       	add	sp,r5
8000236a:	20 49       	sub	r9,4
8000236c:	44 3a       	lddsp	r10,sp[0x10c]
8000236e:	20 20       	sub	r0,2
80002370:	25 58       	sub	r8,85
80002372:	20 0a       	sub	r10,0
80002374:	0d 00       	ld.w	r0,r6++
80002376:	00 00       	add	r0,r0
80002378:	0a 0d       	add	sp,r5
8000237a:	20 43       	sub	r3,4
8000237c:	53 42       	stdsp	sp[0xd0],r2
8000237e:	4b 5f       	lddpc	pc,80002450 <program_start+0x448>
80002380:	52 58       	stdsp	sp[0x94],r8
80002382:	20 4f       	sub	pc,4
80002384:	4b 20       	lddpc	r0,8000244c <program_start+0x444>
80002386:	0a 0d       	add	sp,r5
80002388:	00 00       	add	r0,r0
8000238a:	00 00       	add	r0,r0
8000238c:	0a 0d       	add	sp,r5
8000238e:	20 53       	sub	r3,5
80002390:	65 73       	ld.w	r3,r2[0x5c]
80002392:	73 69       	ld.w	r9,r9[0x58]
80002394:	6f 6e       	ld.w	lr,r7[0x58]
80002396:	5f 49       	srge	r9
80002398:	44 3a       	lddsp	r10,sp[0x10c]
8000239a:	20 25       	sub	r5,2
8000239c:	78 20       	ld.w	r0,r12[0x8]
8000239e:	0a 0d       	add	sp,r5
800023a0:	00 00       	add	r0,r0
800023a2:	00 00       	add	r0,r0
800023a4:	0a 0d       	add	sp,r5
800023a6:	20 70       	sub	r0,7
800023a8:	61 79       	ld.w	r9,r0[0x5c]
800023aa:	6c 61       	ld.w	r1,r6[0x18]
800023ac:	6f 64       	ld.w	r4,r7[0x58]
800023ae:	5f 6c       	srmi	r12
800023b0:	65 6e       	ld.w	lr,r2[0x58]
800023b2:	67 74       	ld.w	r4,r3[0x5c]
800023b4:	68 3a       	ld.w	r10,r4[0xc]
800023b6:	20 25       	sub	r5,2
800023b8:	64 20       	ld.w	r0,r2[0x8]
800023ba:	0a 0d       	add	sp,r5
800023bc:	00 00       	add	r0,r0
800023be:	00 00       	add	r0,r0
800023c0:	0a 0d       	add	sp,r5
800023c2:	20 70       	sub	r0,7
800023c4:	61 79       	ld.w	r9,r0[0x5c]
800023c6:	6c 6f       	ld.w	pc,r6[0x18]
800023c8:	61 64       	ld.w	r4,r0[0x58]
800023ca:	5b 25       	cp.w	r5,-14
800023cc:	64 5d       	ld.w	sp,r2[0x14]
800023ce:	3a 20       	mov	r0,-94
800023d0:	25 58       	sub	r8,85
800023d2:	20 0a       	sub	r10,0
800023d4:	0d 00       	ld.w	r0,r6++
800023d6:	00 00       	add	r0,r0
800023d8:	0a 0d       	add	sp,r5
800023da:	20 53       	sub	r3,5
800023dc:	74 61       	ld.w	r1,r10[0x18]
800023de:	74 65       	ld.w	r5,r10[0x18]
800023e0:	3a 20       	mov	r0,-94
800023e2:	30 78       	mov	r8,7
800023e4:	20 25       	sub	r5,2
800023e6:	58 20       	cp.w	r0,2
800023e8:	0a 0d       	add	sp,r5
800023ea:	00 00       	add	r0,r0
800023ec:	0a 0d       	add	sp,r5
800023ee:	20 42       	sub	r2,4
800023f0:	75 74       	ld.w	r4,r10[0x5c]
800023f2:	74 6f       	ld.w	pc,r10[0x18]
800023f4:	6e 5f       	ld.w	pc,r7[0x14]
800023f6:	43 6f       	lddsp	pc,sp[0xd8]
800023f8:	6e 66       	ld.w	r6,r7[0x18]
800023fa:	69 67       	ld.w	r7,r4[0x58]
800023fc:	20 4f       	sub	pc,4
800023fe:	4b 20       	lddpc	r0,800024c4 <program_start+0x4bc>
80002400:	0a 0d       	add	sp,r5
80002402:	00 00       	add	r0,r0
80002404:	0a 0d       	add	sp,r5
80002406:	20 46       	sub	r6,4
80002408:	75 6e       	ld.w	lr,r10[0x58]
8000240a:	63 74       	ld.w	r4,r1[0x5c]
8000240c:	69 6f       	ld.w	pc,r4[0x58]
8000240e:	6e 3a       	ld.w	r10,r7[0xc]
80002410:	20 25       	sub	r5,2
80002412:	58 20       	cp.w	r0,2
80002414:	0a 0d       	add	sp,r5
80002416:	00 00       	add	r0,r0
80002418:	0a 0d       	add	sp,r5
8000241a:	20 42       	sub	r2,4
8000241c:	75 74       	ld.w	r4,r10[0x5c]
8000241e:	74 6f       	ld.w	pc,r10[0x18]
80002420:	6e 5f       	ld.w	pc,r7[0x14]
80002422:	52 65       	stdsp	sp[0x98],r5
80002424:	71 75       	ld.w	r5,r8[0x5c]
80002426:	65 73       	ld.w	r3,r2[0x5c]
80002428:	74 20       	ld.w	r0,r10[0x8]
8000242a:	65 72       	ld.w	r2,r2[0x5c]
8000242c:	72 6f       	ld.w	pc,r9[0x18]
8000242e:	72 20       	ld.w	r0,r9[0x8]
80002430:	0a 0d       	add	sp,r5
80002432:	00 00       	add	r0,r0
80002434:	0a 0d       	add	sp,r5
80002436:	20 50       	sub	r0,5
80002438:	68 79       	ld.w	r9,r4[0x1c]
8000243a:	73 69       	ld.w	r9,r9[0x58]
8000243c:	63 61       	ld.w	r1,r1[0x58]
8000243e:	6c 55       	ld.w	r5,r6[0x14]
80002440:	73 65       	ld.w	r5,r9[0x58]
80002442:	72 49       	ld.w	r9,r9[0x10]
80002444:	6e 70       	ld.w	r0,r7[0x1c]
80002446:	75 74       	ld.w	r4,r10[0x5c]
80002448:	5f 62       	srmi	r2
8000244a:	72 6f       	ld.w	pc,r9[0x18]
8000244c:	61 64       	ld.w	r4,r0[0x58]
8000244e:	63 61       	ld.w	r1,r1[0x58]
80002450:	73 74       	ld.w	r4,r9[0x5c]
80002452:	20 20       	sub	r0,2
80002454:	0a 0d       	add	sp,r5
80002456:	00 00       	add	r0,r0
80002458:	0a 0d       	add	sp,r5
8000245a:	20 50       	sub	r0,5
8000245c:	55 49       	stdsp	sp[0x150],r9
8000245e:	5f 53       	srlt	r3
80002460:	6f 75       	ld.w	r5,r7[0x5c]
80002462:	72 63       	ld.w	r3,r9[0x18]
80002464:	65 3a       	ld.w	r10,r2[0x4c]
80002466:	20 25       	sub	r5,2
80002468:	58 20       	cp.w	r0,2
8000246a:	0a 0d       	add	sp,r5
8000246c:	00 00       	add	r0,r0
8000246e:	00 00       	add	r0,r0
80002470:	0a 0d       	add	sp,r5
80002472:	20 50       	sub	r0,5
80002474:	55 49       	stdsp	sp[0x150],r9
80002476:	5f 54       	srlt	r4
80002478:	79 70       	ld.w	r0,r12[0x5c]
8000247a:	65 3a       	ld.w	r10,r2[0x4c]
8000247c:	20 25       	sub	r5,2
8000247e:	58 20       	cp.w	r0,2
80002480:	0a 0d       	add	sp,r5
80002482:	00 00       	add	r0,r0
80002484:	0a 0d       	add	sp,r5
80002486:	20 50       	sub	r0,5
80002488:	55 49       	stdsp	sp[0x150],r9
8000248a:	5f 49       	srge	r9
8000248c:	44 3a       	lddsp	r10,sp[0x10c]
8000248e:	20 25       	sub	r5,2
80002490:	58 20       	cp.w	r0,2
80002492:	0a 0d       	add	sp,r5
80002494:	00 00       	add	r0,r0
80002496:	00 00       	add	r0,r0
80002498:	0a 0d       	add	sp,r5
8000249a:	20 50       	sub	r0,5
8000249c:	55 49       	stdsp	sp[0x150],r9
8000249e:	5f 53       	srlt	r3
800024a0:	74 61       	ld.w	r1,r10[0x18]
800024a2:	74 65       	ld.w	r5,r10[0x18]
800024a4:	3a 20       	mov	r0,-94
800024a6:	25 58       	sub	r8,85
800024a8:	20 0a       	sub	r10,0
800024aa:	0d 00       	ld.w	r0,r6++
800024ac:	0a 0d       	add	sp,r5
800024ae:	20 50       	sub	r0,5
800024b0:	55 49       	stdsp	sp[0x150],r9
800024b2:	5f 53       	srlt	r3
800024b4:	74 61       	ld.w	r1,r10[0x18]
800024b6:	74 65       	ld.w	r5,r10[0x18]
800024b8:	5f 4d       	srge	sp
800024ba:	69 6e       	ld.w	lr,r4[0x58]
800024bc:	5f 56       	srlt	r6
800024be:	61 6c       	ld.w	r12,r0[0x58]
800024c0:	75 65       	ld.w	r5,r10[0x58]
800024c2:	3a 20       	mov	r0,-94
800024c4:	25 58       	sub	r8,85
800024c6:	20 0a       	sub	r10,0
800024c8:	0d 00       	ld.w	r0,r6++
800024ca:	00 00       	add	r0,r0
800024cc:	0a 0d       	add	sp,r5
800024ce:	20 50       	sub	r0,5
800024d0:	55 49       	stdsp	sp[0x150],r9
800024d2:	5f 53       	srlt	r3
800024d4:	74 61       	ld.w	r1,r10[0x18]
800024d6:	74 65       	ld.w	r5,r10[0x18]
800024d8:	5f 4d       	srge	sp
800024da:	61 78       	ld.w	r8,r0[0x5c]
800024dc:	5f 56       	srlt	r6
800024de:	61 6c       	ld.w	r12,r0[0x58]
800024e0:	75 65       	ld.w	r5,r10[0x58]
800024e2:	3a 20       	mov	r0,-94
800024e4:	25 58       	sub	r8,85
800024e6:	20 0a       	sub	r10,0
800024e8:	0d 00       	ld.w	r0,r6++
800024ea:	00 00       	add	r0,r0
800024ec:	0a 0d       	add	sp,r5
800024ee:	20 42       	sub	r2,4
800024f0:	75 74       	ld.w	r4,r10[0x5c]
800024f2:	74 6f       	ld.w	pc,r10[0x18]
800024f4:	6e 43       	ld.w	r3,r7[0x10]
800024f6:	6f 6e       	ld.w	lr,r7[0x58]
800024f8:	66 69       	ld.w	r9,r3[0x18]
800024fa:	67 5f       	ld.w	pc,r3[0x54]
800024fc:	62 72       	ld.w	r2,r1[0x1c]
800024fe:	6f 61       	ld.w	r1,r7[0x58]
80002500:	64 63       	ld.w	r3,r2[0x18]
80002502:	61 73       	ld.w	r3,r0[0x5c]
80002504:	74 20       	ld.w	r0,r10[0x8]
80002506:	20 0a       	sub	r10,0
80002508:	0d 00       	ld.w	r0,r6++
8000250a:	00 00       	add	r0,r0
8000250c:	0a 0d       	add	sp,r5
8000250e:	20 4e       	sub	lr,4
80002510:	75 6d       	ld.w	sp,r10[0x58]
80002512:	4f 66       	lddpc	r6,800026e8 <program_start+0x6e0>
80002514:	42 75       	lddsp	r5,sp[0x9c]
80002516:	74 74       	ld.w	r4,r10[0x1c]
80002518:	6f 6e       	ld.w	lr,r7[0x58]
8000251a:	73 3a       	ld.w	r10,r9[0x4c]
8000251c:	20 25       	sub	r5,2
8000251e:	64 20       	ld.w	r0,r2[0x8]
80002520:	0a 0d       	add	sp,r5
80002522:	00 00       	add	r0,r0
80002524:	0a 0d       	add	sp,r5
80002526:	20 42       	sub	r2,4
80002528:	75 74       	ld.w	r4,r10[0x5c]
8000252a:	74 6f       	ld.w	pc,r10[0x18]
8000252c:	6e 49       	ld.w	r9,r7[0x10]
8000252e:	6e 66       	ld.w	r6,r7[0x18]
80002530:	6f 53       	ld.w	r3,r7[0x54]
80002532:	74 72       	ld.w	r2,r10[0x1c]
80002534:	75 63       	ld.w	r3,r10[0x58]
80002536:	74 53       	ld.w	r3,r10[0x14]
80002538:	69 7a       	ld.w	r10,r4[0x5c]
8000253a:	65 3a       	ld.w	r10,r2[0x4c]
8000253c:	20 25       	sub	r5,2
8000253e:	78 20       	ld.w	r0,r12[0x8]
80002540:	0a 0d       	add	sp,r5
80002542:	00 00       	add	r0,r0
80002544:	0a 0d       	add	sp,r5
80002546:	20 42       	sub	r2,4
80002548:	75 74       	ld.w	r4,r10[0x5c]
8000254a:	74 6f       	ld.w	pc,r10[0x18]
8000254c:	6e 49       	ld.w	r9,r7[0x10]
8000254e:	6e 66       	ld.w	r6,r7[0x18]
80002550:	6f 5b       	ld.w	r11,r7[0x54]
80002552:	25 64       	sub	r4,86
80002554:	5d 2e       	mustr	lr
80002556:	42 74       	lddsp	r4,sp[0x9c]
80002558:	5f 49       	srge	r9
8000255a:	64 65       	ld.w	r5,r2[0x18]
8000255c:	6e 74       	ld.w	r4,r7[0x1c]
8000255e:	69 66       	ld.w	r6,r4[0x58]
80002560:	69 65       	ld.w	r5,r4[0x58]
80002562:	72 3a       	ld.w	r10,r9[0xc]
80002564:	20 25       	sub	r5,2
80002566:	78 20       	ld.w	r0,r12[0x8]
80002568:	0a 0d       	add	sp,r5
8000256a:	00 00       	add	r0,r0
8000256c:	0a 0d       	add	sp,r5
8000256e:	20 42       	sub	r2,4
80002570:	75 74       	ld.w	r4,r10[0x5c]
80002572:	74 6f       	ld.w	pc,r10[0x18]
80002574:	6e 49       	ld.w	r9,r7[0x10]
80002576:	6e 66       	ld.w	r6,r7[0x18]
80002578:	6f 5b       	ld.w	r11,r7[0x54]
8000257a:	25 64       	sub	r4,86
8000257c:	5d 2e       	mustr	lr
8000257e:	53 5f       	stdsp	sp[0xd4],pc
80002580:	50 72       	stdsp	sp[0x1c],r2
80002582:	65 73       	ld.w	r3,r2[0x5c]
80002584:	73 46       	ld.w	r6,r9[0x50]
80002586:	65 61       	ld.w	r1,r2[0x58]
80002588:	74 75       	ld.w	r5,r10[0x1c]
8000258a:	72 65       	ld.w	r5,r9[0x18]
8000258c:	3a 20       	mov	r0,-94
8000258e:	25 78       	sub	r8,87
80002590:	20 0a       	sub	r10,0
80002592:	0d 00       	ld.w	r0,r6++
80002594:	0a 0d       	add	sp,r5
80002596:	20 42       	sub	r2,4
80002598:	75 74       	ld.w	r4,r10[0x5c]
8000259a:	74 6f       	ld.w	pc,r10[0x18]
8000259c:	6e 49       	ld.w	r9,r7[0x10]
8000259e:	6e 66       	ld.w	r6,r7[0x18]
800025a0:	6f 5b       	ld.w	r11,r7[0x54]
800025a2:	25 64       	sub	r4,86
800025a4:	5d 2e       	mustr	lr
800025a6:	52 65       	stdsp	sp[0x98],r5
800025a8:	73 65       	ld.w	r5,r9[0x58]
800025aa:	72 76       	ld.w	r6,r9[0x1c]
800025ac:	65 64       	ld.w	r4,r2[0x58]
800025ae:	31 3a       	mov	r10,19
800025b0:	20 25       	sub	r5,2
800025b2:	78 20       	ld.w	r0,r12[0x8]
800025b4:	0a 0d       	add	sp,r5
800025b6:	00 00       	add	r0,r0
800025b8:	0a 0d       	add	sp,r5
800025ba:	20 42       	sub	r2,4
800025bc:	75 74       	ld.w	r4,r10[0x5c]
800025be:	74 6f       	ld.w	pc,r10[0x18]
800025c0:	6e 49       	ld.w	r9,r7[0x10]
800025c2:	6e 66       	ld.w	r6,r7[0x18]
800025c4:	6f 5b       	ld.w	r11,r7[0x54]
800025c6:	25 64       	sub	r4,86
800025c8:	5d 2e       	mustr	lr
800025ca:	4c 5f       	lddpc	pc,800026dc <program_start+0x6d4>
800025cc:	50 72       	stdsp	sp[0x1c],r2
800025ce:	65 73       	ld.w	r3,r2[0x5c]
800025d0:	73 46       	ld.w	r6,r9[0x50]
800025d2:	65 61       	ld.w	r1,r2[0x58]
800025d4:	74 75       	ld.w	r5,r10[0x1c]
800025d6:	72 65       	ld.w	r5,r9[0x18]
800025d8:	3a 20       	mov	r0,-94
800025da:	25 78       	sub	r8,87
800025dc:	20 0a       	sub	r10,0
800025de:	0d 00       	ld.w	r0,r6++
800025e0:	0a 0d       	add	sp,r5
800025e2:	20 42       	sub	r2,4
800025e4:	75 74       	ld.w	r4,r10[0x5c]
800025e6:	74 6f       	ld.w	pc,r10[0x18]
800025e8:	6e 49       	ld.w	r9,r7[0x10]
800025ea:	6e 66       	ld.w	r6,r7[0x18]
800025ec:	6f 5b       	ld.w	r11,r7[0x54]
800025ee:	25 64       	sub	r4,86
800025f0:	5d 2e       	mustr	lr
800025f2:	52 65       	stdsp	sp[0x98],r5
800025f4:	73 65       	ld.w	r5,r9[0x58]
800025f6:	72 76       	ld.w	r6,r9[0x1c]
800025f8:	65 64       	ld.w	r4,r2[0x58]
800025fa:	32 3a       	mov	r10,35
800025fc:	20 25       	sub	r5,2
800025fe:	78 20       	ld.w	r0,r12[0x8]
80002600:	0a 0d       	add	sp,r5
80002602:	00 00       	add	r0,r0
80002604:	0a 0d       	add	sp,r5
80002606:	20 44       	sub	r4,4
80002608:	4d 52       	lddpc	r2,8000275c <DeviceInitializationStatus_brdcst_func+0x30>
8000260a:	5f 43       	srge	r3
8000260c:	53 42       	stdsp	sp[0xd0],r2
8000260e:	4b 20       	lddpc	r0,800026d4 <program_start+0x6cc>
80002610:	4f 4b       	lddpc	r11,800027e0 <ToneControl_reply_func>
80002612:	20 0a       	sub	r10,0
80002614:	0d 00       	ld.w	r0,r6++
80002616:	00 00       	add	r0,r0
80002618:	0a 0d       	add	sp,r5
8000261a:	20 45       	sub	r5,4
8000261c:	6e 5f       	ld.w	pc,r7[0x14]
8000261e:	4f 42       	lddpc	r2,800027ec <ToneControl_reply_func+0xc>
80002620:	5f 45       	srge	r5
80002622:	6e 74       	ld.w	r4,r7[0x1c]
80002624:	65 72       	ld.w	r2,r2[0x5c]
80002626:	20 4f       	sub	pc,4
80002628:	4b 20       	lddpc	r0,800026f0 <program_start+0x6e8>
8000262a:	0a 0d       	add	sp,r5
8000262c:	00 00       	add	r0,r0
8000262e:	00 00       	add	r0,r0
80002630:	0a 0d       	add	sp,r5
80002632:	20 45       	sub	r5,4
80002634:	6e 5f       	ld.w	pc,r7[0x14]
80002636:	4f 42       	lddpc	r2,80002804 <ToneControl_reply_func+0x24>
80002638:	5f 45       	srge	r5
8000263a:	78 69       	ld.w	r9,r12[0x18]
8000263c:	74 20       	ld.w	r0,r10[0x8]
8000263e:	4f 4b       	lddpc	r11,8000280c <ToneControl_reply_func+0x2c>
80002640:	20 0a       	sub	r10,0
80002642:	0d 00       	ld.w	r0,r6++
80002644:	0a 0d       	add	sp,r5
80002646:	20 45       	sub	r5,4
80002648:	6e 5f       	ld.w	pc,r7[0x14]
8000264a:	4f 42       	lddpc	r2,80002818 <dcm_reply_func>
8000264c:	5f 43       	srge	r3
8000264e:	6f 6e       	ld.w	lr,r7[0x58]
80002650:	74 72       	ld.w	r2,r10[0x1c]
80002652:	6f 6c       	ld.w	r12,r7[0x58]
80002654:	3a 20       	mov	r0,-94
80002656:	25 78       	sub	r8,87
80002658:	20 0a       	sub	r10,0
8000265a:	0d 00       	ld.w	r0,r6++
8000265c:	0a 0d       	add	sp,r5
8000265e:	20 45       	sub	r5,4
80002660:	6e 5f       	ld.w	pc,r7[0x14]
80002662:	4f 42       	lddpc	r2,80002830 <dcm_reply_func+0x18>
80002664:	5f 43       	srge	r3
80002666:	6f 6e       	ld.w	lr,r7[0x58]
80002668:	74 72       	ld.w	r2,r10[0x1c]
8000266a:	6f 6c       	ld.w	r12,r7[0x58]
8000266c:	20 65       	sub	r5,6
8000266e:	72 72       	ld.w	r2,r9[0x1c]
80002670:	6f 72       	ld.w	r2,r7[0x5c]
80002672:	20 0a       	sub	r10,0
80002674:	0d 00       	ld.w	r0,r6++
80002676:	00 00       	add	r0,r0
80002678:	0a 0d       	add	sp,r5
8000267a:	20 45       	sub	r5,4
8000267c:	6e 5f       	ld.w	pc,r7[0x14]
8000267e:	4f 42       	lddpc	r2,8000284c <dcm_reply_func+0x34>
80002680:	5f 72       	srpl	r2
80002682:	65 73       	ld.w	r3,r2[0x5c]
80002684:	75 6c       	ld.w	r12,r10[0x58]
80002686:	74 3a       	ld.w	r10,r10[0xc]
80002688:	20 25       	sub	r5,2
8000268a:	78 20       	ld.w	r0,r12[0x8]
8000268c:	0a 0d       	add	sp,r5
8000268e:	00 00       	add	r0,r0
80002690:	0a 0d       	add	sp,r5
80002692:	20 45       	sub	r5,4
80002694:	6e 5f       	ld.w	pc,r7[0x14]
80002696:	4f 42       	lddpc	r2,80002864 <dcm_reply_func+0x4c>
80002698:	20 42       	sub	r2,4
8000269a:	72 6f       	ld.w	pc,r9[0x18]
8000269c:	61 64       	ld.w	r4,r0[0x58]
8000269e:	63 61       	ld.w	r1,r1[0x58]
800026a0:	73 74       	ld.w	r4,r9[0x5c]
800026a2:	20 0a       	sub	r10,0
800026a4:	0d 00       	ld.w	r0,r6++
800026a6:	00 00       	add	r0,r0
800026a8:	0a 0d       	add	sp,r5
800026aa:	20 46       	sub	r6,4
800026ac:	6f 72       	ld.w	r2,r7[0x5c]
800026ae:	77 61       	ld.w	r1,r11[0x58]
800026b0:	72 64       	ld.w	r4,r9[0x18]
800026b2:	20 44       	sub	r4,4
800026b4:	61 74       	ld.w	r4,r0[0x5c]
800026b6:	61 20       	ld.w	r0,r0[0x48]
800026b8:	52 65       	stdsp	sp[0x98],r5
800026ba:	71 75       	ld.w	r5,r8[0x5c]
800026bc:	65 73       	ld.w	r3,r2[0x5c]
800026be:	74 20       	ld.w	r0,r10[0x8]
800026c0:	0a 0d       	add	sp,r5
800026c2:	00 00       	add	r0,r0
800026c4:	0a 0d       	add	sp,r5
800026c6:	20 46       	sub	r6,4
800026c8:	6f 72       	ld.w	r2,r7[0x5c]
800026ca:	77 61       	ld.w	r1,r11[0x58]
800026cc:	72 64       	ld.w	r4,r9[0x18]
800026ce:	20 44       	sub	r4,4
800026d0:	61 74       	ld.w	r4,r0[0x5c]
800026d2:	61 20       	ld.w	r0,r0[0x48]
800026d4:	52 65       	stdsp	sp[0x98],r5
800026d6:	70 6c       	ld.w	r12,r8[0x18]
800026d8:	79 20       	ld.w	r0,r12[0x48]
800026da:	0a 0d       	add	sp,r5
800026dc:	00 00       	add	r0,r0
800026de:	00 00       	add	r0,r0
800026e0:	0a 0d       	add	sp,r5
800026e2:	20 46       	sub	r6,4
800026e4:	6f 72       	ld.w	r2,r7[0x5c]
800026e6:	77 61       	ld.w	r1,r11[0x58]
800026e8:	72 64       	ld.w	r4,r9[0x18]
800026ea:	20 44       	sub	r4,4
800026ec:	61 74       	ld.w	r4,r0[0x5c]
800026ee:	61 20       	ld.w	r0,r0[0x48]
800026f0:	42 72       	lddsp	r2,sp[0x9c]
800026f2:	6f 61       	ld.w	r1,r7[0x58]
800026f4:	64 63       	ld.w	r3,r2[0x18]
800026f6:	61 73       	ld.w	r3,r0[0x5c]
800026f8:	74 20       	ld.w	r0,r10[0x8]
800026fa:	0a 0d       	add	sp,r5
800026fc:	00 00       	add	r0,r0
800026fe:	00 00       	add	r0,r0
80002700:	58 4e       	cp.w	lr,4
80002702:	4c 5f       	lddpc	pc,80002814 <ToneControl_reply_func+0x34>
80002704:	54 58       	stdsp	sp[0x114],r8
80002706:	00 00       	add	r0,r0
80002708:	0a 0d       	add	sp,r5
8000270a:	20 63       	sub	r3,6
8000270c:	6f 75       	ld.w	r5,r7[0x5c]
8000270e:	6e 74       	ld.w	r4,r7[0x1c]
80002710:	65 72       	ld.w	r2,r2[0x5c]
80002712:	3a 20       	mov	r0,-94
80002714:	25 64       	sub	r4,86
80002716:	20 0a       	sub	r10,0
80002718:	0d 00       	ld.w	r0,r6++
8000271a:	00 00       	add	r0,r0
8000271c:	0a 0d       	add	sp,r5
8000271e:	20 77       	sub	r7,7
80002720:	3a 20       	mov	r0,-94
80002722:	0a 0d       	add	sp,r5
80002724:	00 00       	add	r0,r0
80002726:	00 00       	add	r0,r0
80002728:	52 00       	stdsp	sp[0x80],r0
	...

8000272c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	1a 97       	mov	r7,sp
80002732:	20 1d       	sub	sp,4
80002734:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[4] == 0x01)
80002738:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000273c:	11 e9       	ld.ub	r9,r8[0x6]
8000273e:	30 18       	mov	r8,1
80002740:	f0 09 18 00 	cp.b	r9,r8
80002744:	c0 81       	brne	80002754 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002746:	48 e8       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002748:	70 08       	ld.w	r8,r8[0x0]
8000274a:	10 99       	mov	r9,r8
8000274c:	a1 a9       	sbr	r9,0x0
8000274e:	48 c8       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002750:	91 09       	st.w	r8[0x0],r9
80002752:	c1 18       	rjmp	80002774 <DeviceInitializationStatus_brdcst_func+0x48>
	}
	else if(xcmp->u8[4] != 0x02)
80002754:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002758:	11 e9       	ld.ub	r9,r8[0x6]
8000275a:	30 28       	mov	r8,2
8000275c:	f0 09 18 00 	cp.b	r9,r8
80002760:	c0 a0       	breq	80002774 <DeviceInitializationStatus_brdcst_func+0x48>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002762:	48 78       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002764:	70 08       	ld.w	r8,r8[0x0]
80002766:	10 99       	mov	r9,r8
80002768:	e0 19 ff fc 	andl	r9,0xfffc
8000276c:	48 48       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
8000276e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002770:	f0 1f 00 04 	mcall	80002780 <DeviceInitializationStatus_brdcst_func+0x54>
	}
}
80002774:	2f fd       	sub	sp,-4
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	00 00       	add	r0,r0
8000277e:	0d 90       	ld.ub	r0,r6[0x1]
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	62 88       	ld.w	r8,r1[0x20]

80002784 <DeviceManagement_brdcst_func>:

void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
80002784:	eb cd 40 80 	pushm	r7,lr
80002788:	1a 97       	mov	r7,sp
8000278a:	20 2d       	sub	sp,8
8000278c:	ef 4c ff f8 	st.w	r7[-8],r12
		U8 temp = 0;
80002790:	30 08       	mov	r8,0
80002792:	ef 68 ff ff 	st.b	r7[-1],r8
		temp  = xcmp->u8[1] << 8;
80002796:	30 08       	mov	r8,0
80002798:	ef 68 ff ff 	st.b	r7[-1],r8
		temp |= xcmp->u8[2];
8000279c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027a0:	11 c9       	ld.ub	r9,r8[0x4]
800027a2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800027a6:	f3 e8 10 08 	or	r8,r9,r8
800027aa:	ef 68 ff ff 	st.b	r7[-1],r8
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
800027ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027b2:	11 a9       	ld.ub	r9,r8[0x2]
800027b4:	30 18       	mov	r8,1
800027b6:	f0 09 18 00 	cp.b	r9,r8
800027ba:	c0 81       	brne	800027ca <DeviceManagement_brdcst_func+0x46>
			{
				bunchofrandomstatusflags |= 0x00000002;
800027bc:	48 88       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027be:	70 08       	ld.w	r8,r8[0x0]
800027c0:	10 99       	mov	r9,r8
800027c2:	a1 b9       	sbr	r9,0x1
800027c4:	48 68       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027c6:	91 09       	st.w	r8[0x0],r9
800027c8:	c0 78       	rjmp	800027d6 <DeviceManagement_brdcst_func+0x52>
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
800027ca:	48 58       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027cc:	70 08       	ld.w	r8,r8[0x0]
800027ce:	10 99       	mov	r9,r8
800027d0:	a1 d9       	cbr	r9,0x1
800027d2:	48 38       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027d4:	91 09       	st.w	r8[0x0],r9
			}
		}
}
800027d6:	2f ed       	sub	sp,-8
800027d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800027dc:	00 00       	add	r0,r0
800027de:	0d 90       	ld.ub	r0,r6[0x1]

800027e0 <ToneControl_reply_func>:

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027e0:	eb cd 40 80 	pushm	r7,lr
800027e4:	1a 97       	mov	r7,sp
800027e6:	20 1d       	sub	sp,4
800027e8:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027f0:	11 a8       	ld.ub	r8,r8[0x2]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c0 51       	brne	800027fe <ToneControl_reply_func+0x1e>
	{		
		log("Tone OK");
800027f6:	48 6c       	lddpc	r12,8000280c <ToneControl_reply_func+0x2c>
800027f8:	f0 1f 00 06 	mcall	80002810 <ToneControl_reply_func+0x30>
800027fc:	c0 48       	rjmp	80002804 <ToneControl_reply_func+0x24>
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027fe:	48 6c       	lddpc	r12,80002814 <ToneControl_reply_func+0x34>
80002800:	f0 1f 00 04 	mcall	80002810 <ToneControl_reply_func+0x30>
	}
}
80002804:	2f fd       	sub	sp,-4
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	20 10       	sub	r0,1
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	9f 84       	st.w	pc[0x20],r4
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	20 18       	sub	r8,1

80002818 <dcm_reply_func>:

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002818:	eb cd 40 80 	pushm	r7,lr
8000281c:	1a 97       	mov	r7,sp
8000281e:	20 1d       	sub	sp,4
80002820:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002824:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002828:	11 a8       	ld.ub	r8,r8[0x2]
8000282a:	58 08       	cp.w	r8,0
8000282c:	c2 11       	brne	8000286e <dcm_reply_func+0x56>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000282e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002832:	11 b9       	ld.ub	r9,r8[0x3]
80002834:	30 18       	mov	r8,1
80002836:	f0 09 18 00 	cp.b	r9,r8
8000283a:	c0 51       	brne	80002844 <dcm_reply_func+0x2c>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000283c:	49 0c       	lddpc	r12,8000287c <dcm_reply_func+0x64>
8000283e:	f0 1f 00 11 	mcall	80002880 <dcm_reply_func+0x68>
80002842:	c0 d8       	rjmp	8000285c <dcm_reply_func+0x44>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002844:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002848:	11 b8       	ld.ub	r8,r8[0x3]
8000284a:	58 08       	cp.w	r8,0
8000284c:	c0 51       	brne	80002856 <dcm_reply_func+0x3e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000284e:	48 ec       	lddpc	r12,80002884 <dcm_reply_func+0x6c>
80002850:	f0 1f 00 0c 	mcall	80002880 <dcm_reply_func+0x68>
80002854:	c0 48       	rjmp	8000285c <dcm_reply_func+0x44>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002856:	48 dc       	lddpc	r12,80002888 <dcm_reply_func+0x70>
80002858:	f0 1f 00 0a 	mcall	80002880 <dcm_reply_func+0x68>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000285c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002860:	11 d8       	ld.ub	r8,r8[0x5]
80002862:	1a d8       	st.w	--sp,r8
80002864:	48 ac       	lddpc	r12,8000288c <dcm_reply_func+0x74>
80002866:	f0 1f 00 07 	mcall	80002880 <dcm_reply_func+0x68>
8000286a:	2f fd       	sub	sp,-4
8000286c:	c0 48       	rjmp	80002874 <dcm_reply_func+0x5c>
	}
	else
	{
		log("dcm error");
8000286e:	48 9c       	lddpc	r12,80002890 <dcm_reply_func+0x78>
80002870:	f0 1f 00 04 	mcall	80002880 <dcm_reply_func+0x68>
	}
}
80002874:	2f fd       	sub	sp,-4
80002876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287a:	00 00       	add	r0,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	20 24       	sub	r4,2
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	9f 84       	st.w	pc[0x20],r4
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	20 38       	sub	r8,3
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	20 4c       	sub	r12,4
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	20 60       	sub	r0,6
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	20 6c       	sub	r12,6

80002894 <dcm_brdcst_func>:


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002894:	eb cd 40 80 	pushm	r7,lr
80002898:	1a 97       	mov	r7,sp
8000289a:	20 2d       	sub	sp,8
8000289c:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800028a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028a4:	2f e8       	sub	r8,-2
800028a6:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Dcm_brdcst \n\r");		
800028aa:	49 0c       	lddpc	r12,800028e8 <dcm_brdcst_func+0x54>
800028ac:	f0 1f 00 10 	mcall	800028ec <dcm_brdcst_func+0x58>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800028b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028b4:	11 88       	ld.ub	r8,r8[0x0]
800028b6:	1a d8       	st.w	--sp,r8
800028b8:	48 ec       	lddpc	r12,800028f0 <dcm_brdcst_func+0x5c>
800028ba:	f0 1f 00 0d 	mcall	800028ec <dcm_brdcst_func+0x58>
800028be:	2f fd       	sub	sp,-4
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800028c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028c4:	11 a8       	ld.ub	r8,r8[0x2]
800028c6:	1a d8       	st.w	--sp,r8
800028c8:	48 bc       	lddpc	r12,800028f4 <dcm_brdcst_func+0x60>
800028ca:	f0 1f 00 09 	mcall	800028ec <dcm_brdcst_func+0x58>
800028ce:	2f fd       	sub	sp,-4
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800028d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028d4:	11 98       	ld.ub	r8,r8[0x1]
800028d6:	1a d8       	st.w	--sp,r8
800028d8:	48 8c       	lddpc	r12,800028f8 <dcm_brdcst_func+0x64>
800028da:	f0 1f 00 05 	mcall	800028ec <dcm_brdcst_func+0x58>
800028de:	2f fd       	sub	sp,-4
	
	
}
800028e0:	2f ed       	sub	sp,-8
800028e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028e6:	00 00       	add	r0,r0
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	20 78       	sub	r8,7
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	9f 84       	st.w	pc[0x20],r4
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	20 8c       	sub	r12,8
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	20 a0       	sub	r0,10
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	20 b8       	sub	r8,11

800028fc <mic_reply_func>:

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800028fc:	eb cd 40 80 	pushm	r7,lr
80002900:	1a 97       	mov	r7,sp
80002902:	20 2d       	sub	sp,8
80002904:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002908:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000290c:	2f e8       	sub	r8,-2
8000290e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Mic_reply \n\r");
80002912:	4a 2c       	lddpc	r12,80002998 <mic_reply_func+0x9c>
80002914:	f0 1f 00 22 	mcall	8000299c <mic_reply_func+0xa0>
	if (ptr->Result == 0x00)
80002918:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000291c:	11 88       	ld.ub	r8,r8[0x0]
8000291e:	58 08       	cp.w	r8,0
80002920:	c3 51       	brne	8000298a <mic_reply_func+0x8e>
	{
		
		if (ptr->Function == Mic_Disable)
80002922:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002926:	11 99       	ld.ub	r9,r8[0x1]
80002928:	30 28       	mov	r8,2
8000292a:	f0 09 18 00 	cp.b	r9,r8
8000292e:	c2 51       	brne	80002978 <mic_reply_func+0x7c>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002930:	49 cc       	lddpc	r12,800029a0 <mic_reply_func+0xa4>
80002932:	f0 1f 00 1b 	mcall	8000299c <mic_reply_func+0xa0>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002936:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000293a:	11 a8       	ld.ub	r8,r8[0x2]
8000293c:	1a d8       	st.w	--sp,r8
8000293e:	49 ac       	lddpc	r12,800029a4 <mic_reply_func+0xa8>
80002940:	f0 1f 00 17 	mcall	8000299c <mic_reply_func+0xa0>
80002944:	2f fd       	sub	sp,-4
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002946:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000294a:	11 b8       	ld.ub	r8,r8[0x3]
8000294c:	1a d8       	st.w	--sp,r8
8000294e:	49 7c       	lddpc	r12,800029a8 <mic_reply_func+0xac>
80002950:	f0 1f 00 13 	mcall	8000299c <mic_reply_func+0xa0>
80002954:	2f fd       	sub	sp,-4
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002956:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000295a:	11 c8       	ld.ub	r8,r8[0x4]
8000295c:	1a d8       	st.w	--sp,r8
8000295e:	49 4c       	lddpc	r12,800029ac <mic_reply_func+0xb0>
80002960:	f0 1f 00 0f 	mcall	8000299c <mic_reply_func+0xa0>
80002964:	2f fd       	sub	sp,-4
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002966:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000296a:	11 d8       	ld.ub	r8,r8[0x5]
8000296c:	1a d8       	st.w	--sp,r8
8000296e:	49 1c       	lddpc	r12,800029b0 <mic_reply_func+0xb4>
80002970:	f0 1f 00 0b 	mcall	8000299c <mic_reply_func+0xa0>
80002974:	2f fd       	sub	sp,-4
80002976:	c0 d8       	rjmp	80002990 <mic_reply_func+0x94>
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002978:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000297c:	11 98       	ld.ub	r8,r8[0x1]
8000297e:	1a d8       	st.w	--sp,r8
80002980:	48 dc       	lddpc	r12,800029b4 <mic_reply_func+0xb8>
80002982:	f0 1f 00 07 	mcall	8000299c <mic_reply_func+0xa0>
80002986:	2f fd       	sub	sp,-4
80002988:	c0 48       	rjmp	80002990 <mic_reply_func+0x94>
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000298a:	48 cc       	lddpc	r12,800029b8 <mic_reply_func+0xbc>
8000298c:	f0 1f 00 04 	mcall	8000299c <mic_reply_func+0xa0>
		
	}
	
	
	
}
80002990:	2f ed       	sub	sp,-8
80002992:	e3 cd 80 80 	ldm	sp++,r7,pc
80002996:	00 00       	add	r0,r0
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	20 d4       	sub	r4,13
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	9f 84       	st.w	pc[0x20],r4
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	20 e4       	sub	r4,14
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	20 f8       	sub	r8,15
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	21 0c       	sub	r12,16
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	21 28       	sub	r8,18
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	21 40       	sub	r0,20
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	21 58       	sub	r8,21
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	21 70       	sub	r0,23

800029bc <mic_brdcst_func>:

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800029bc:	eb cd 40 80 	pushm	r7,lr
800029c0:	1a 97       	mov	r7,sp
800029c2:	20 2d       	sub	sp,8
800029c4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800029c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029cc:	2f e8       	sub	r8,-2
800029ce:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800029d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029d6:	11 a8       	ld.ub	r8,r8[0x2]
800029d8:	58 08       	cp.w	r8,0
800029da:	c0 71       	brne	800029e8 <mic_brdcst_func+0x2c>
	{
		log("\n\r Mic_Disabled \n\r");	
800029dc:	49 0c       	lddpc	r12,80002a1c <mic_brdcst_func+0x60>
800029de:	f0 1f 00 11 	mcall	80002a20 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 0;
800029e2:	49 19       	lddpc	r9,80002a24 <mic_brdcst_func+0x68>
800029e4:	30 08       	mov	r8,0
800029e6:	b2 88       	st.b	r9[0x0],r8
	} 
	if(ptr->Mic_State == 0x11)
800029e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029ec:	11 a9       	ld.ub	r9,r8[0x2]
800029ee:	31 18       	mov	r8,17
800029f0:	f0 09 18 00 	cp.b	r9,r8
800029f4:	c1 11       	brne	80002a16 <mic_brdcst_func+0x5a>
	{
		log("\n\r Mic_Enabled \n\r");
800029f6:	48 dc       	lddpc	r12,80002a28 <mic_brdcst_func+0x6c>
800029f8:	f0 1f 00 0a 	mcall	80002a20 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 1;
800029fc:	48 a9       	lddpc	r9,80002a24 <mic_brdcst_func+0x68>
800029fe:	30 18       	mov	r8,1
80002a00:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002a02:	48 98       	lddpc	r8,80002a24 <mic_brdcst_func+0x68>
80002a04:	11 88       	ld.ub	r8,r8[0x0]
80002a06:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002a0a:	30 18       	mov	r8,1
80002a0c:	f0 09 18 00 	cp.b	r9,r8
80002a10:	c0 31       	brne	80002a16 <mic_brdcst_func+0x5a>
80002a12:	48 78       	lddpc	r8,80002a2c <mic_brdcst_func+0x70>
80002a14:	11 88       	ld.ub	r8,r8[0x0]
	}
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002a16:	2f ed       	sub	sp,-8
80002a18:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	21 80       	sub	r0,24
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	9f 84       	st.w	pc[0x20],r4
80002a24:	00 00       	add	r0,r0
80002a26:	0a 55       	eor	r5,r5
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	21 94       	sub	r4,25
80002a2c:	00 00       	add	r0,r0
80002a2e:	0a 56       	eor	r6,r5

80002a30 <spk_reply_func>:

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002a30:	eb cd 40 80 	pushm	r7,lr
80002a34:	1a 97       	mov	r7,sp
80002a36:	20 1d       	sub	sp,4
80002a38:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002a3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a40:	11 a8       	ld.ub	r8,r8[0x2]
80002a42:	58 08       	cp.w	r8,0
80002a44:	c1 21       	brne	80002a68 <spk_reply_func+0x38>
	{
		
		if(xcmp->u8[4])
80002a46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a4a:	11 e8       	ld.ub	r8,r8[0x6]
80002a4c:	58 08       	cp.w	r8,0
80002a4e:	c0 40       	breq	80002a56 <spk_reply_func+0x26>
		{
			Speaker_is_unmute = 1;
80002a50:	48 b9       	lddpc	r9,80002a7c <spk_reply_func+0x4c>
80002a52:	30 18       	mov	r8,1
80002a54:	b2 88       	st.b	r9[0x0],r8
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002a56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a5a:	11 e8       	ld.ub	r8,r8[0x6]
80002a5c:	1a d8       	st.w	--sp,r8
80002a5e:	48 9c       	lddpc	r12,80002a80 <spk_reply_func+0x50>
80002a60:	f0 1f 00 09 	mcall	80002a84 <spk_reply_func+0x54>
80002a64:	2f fd       	sub	sp,-4
80002a66:	c0 78       	rjmp	80002a74 <spk_reply_func+0x44>
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002a68:	48 59       	lddpc	r9,80002a7c <spk_reply_func+0x4c>
80002a6a:	30 08       	mov	r8,0
80002a6c:	b2 88       	st.b	r9[0x0],r8
		log("spk error");
80002a6e:	48 7c       	lddpc	r12,80002a88 <spk_reply_func+0x58>
80002a70:	f0 1f 00 05 	mcall	80002a84 <spk_reply_func+0x54>
	}
}
80002a74:	2f fd       	sub	sp,-4
80002a76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a7a:	00 00       	add	r0,r0
80002a7c:	00 00       	add	r0,r0
80002a7e:	0a 50       	eor	r0,r5
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	21 a8       	sub	r8,26
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	9f 84       	st.w	pc[0x20],r4
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	21 b8       	sub	r8,27

80002a8c <spk_brdcst_func>:

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a8c:	eb cd 40 80 	pushm	r7,lr
80002a90:	1a 97       	mov	r7,sp
80002a92:	20 1d       	sub	sp,4
80002a94:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a9c:	11 d8       	ld.ub	r8,r8[0x5]
80002a9e:	58 08       	cp.w	r8,0
80002aa0:	c0 81       	brne	80002ab0 <spk_brdcst_func+0x24>
	{
		Speaker_is_unmute =0;
80002aa2:	48 99       	lddpc	r9,80002ac4 <spk_brdcst_func+0x38>
80002aa4:	30 08       	mov	r8,0
80002aa6:	b2 88       	st.b	r9[0x0],r8
		//Silent_flag = 0;
		log("spk_s_close ");
80002aa8:	48 8c       	lddpc	r12,80002ac8 <spk_brdcst_func+0x3c>
80002aaa:	f0 1f 00 09 	mcall	80002acc <spk_brdcst_func+0x40>
80002aae:	c0 78       	rjmp	80002abc <spk_brdcst_func+0x30>
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002ab0:	48 59       	lddpc	r9,80002ac4 <spk_brdcst_func+0x38>
80002ab2:	30 18       	mov	r8,1
80002ab4:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");	
80002ab6:	48 7c       	lddpc	r12,80002ad0 <spk_brdcst_func+0x44>
80002ab8:	f0 1f 00 05 	mcall	80002acc <spk_brdcst_func+0x40>
	}
	
	
	
	
}
80002abc:	2f fd       	sub	sp,-4
80002abe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	00 00       	add	r0,r0
80002ac6:	0a 50       	eor	r0,r5
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	21 c4       	sub	r4,28
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	9f 84       	st.w	pc[0x20],r4
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	21 d4       	sub	r4,29

80002ad4 <Volume_reply_func>:


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002ad4:	eb cd 40 80 	pushm	r7,lr
80002ad8:	1a 97       	mov	r7,sp
80002ada:	20 2d       	sub	sp,8
80002adc:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002ae0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ae4:	2f e8       	sub	r8,-2
80002ae6:	ef 48 ff fc 	st.w	r7[-4],r8
	
		if (ptr->Result == xcmp_Res_Success)
80002aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002aee:	11 88       	ld.ub	r8,r8[0x0]
80002af0:	58 08       	cp.w	r8,0
80002af2:	c2 41       	brne	80002b3a <Volume_reply_func+0x66>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002af4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002af8:	11 b9       	ld.ub	r9,r8[0x3]
80002afa:	31 08       	mov	r8,16
80002afc:	f0 09 18 00 	cp.b	r9,r8
80002b00:	c1 41       	brne	80002b28 <Volume_reply_func+0x54>
			{
				log("\n\r Enable_IA OK \n\r");
80002b02:	49 2c       	lddpc	r12,80002b48 <Volume_reply_func+0x74>
80002b04:	f0 1f 00 12 	mcall	80002b4c <Volume_reply_func+0x78>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b0c:	11 98       	ld.ub	r8,r8[0x1]
80002b0e:	f0 09 15 08 	lsl	r9,r8,0x8
80002b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b16:	11 a8       	ld.ub	r8,r8[0x2]
80002b18:	f3 e8 10 08 	or	r8,r9,r8
80002b1c:	1a d8       	st.w	--sp,r8
80002b1e:	48 dc       	lddpc	r12,80002b50 <Volume_reply_func+0x7c>
80002b20:	f0 1f 00 0b 	mcall	80002b4c <Volume_reply_func+0x78>
80002b24:	2f fd       	sub	sp,-4
80002b26:	c0 d8       	rjmp	80002b40 <Volume_reply_func+0x6c>
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002b28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2c:	11 b8       	ld.ub	r8,r8[0x3]
80002b2e:	1a d8       	st.w	--sp,r8
80002b30:	48 9c       	lddpc	r12,80002b54 <Volume_reply_func+0x80>
80002b32:	f0 1f 00 07 	mcall	80002b4c <Volume_reply_func+0x78>
80002b36:	2f fd       	sub	sp,-4
80002b38:	c0 48       	rjmp	80002b40 <Volume_reply_func+0x6c>
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002b3a:	48 8c       	lddpc	r12,80002b58 <Volume_reply_func+0x84>
80002b3c:	f0 1f 00 04 	mcall	80002b4c <Volume_reply_func+0x78>
		}
	
	
	
}
80002b40:	2f ed       	sub	sp,-8
80002b42:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b46:	00 00       	add	r0,r0
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	21 e0       	sub	r0,30
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	9f 84       	st.w	pc[0x20],r4
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	21 f4       	sub	r4,31
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	22 10       	sub	r0,33
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	22 28       	sub	r8,34

80002b5c <Volume_brdcst_func>:

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b5c:	eb cd 40 80 	pushm	r7,lr
80002b60:	1a 97       	mov	r7,sp
80002b62:	20 2d       	sub	sp,8
80002b64:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	2f e8       	sub	r8,-2
80002b6e:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002b72:	2f ed       	sub	sp,-8
80002b74:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b78 <AudioRoutingControl_reply_func>:


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002b78:	eb cd 40 80 	pushm	r7,lr
80002b7c:	1a 97       	mov	r7,sp
80002b7e:	20 1d       	sub	sp,4
80002b80:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002b84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b88:	11 a8       	ld.ub	r8,r8[0x2]
80002b8a:	58 08       	cp.w	r8,0
80002b8c:	c0 71       	brne	80002b9a <AudioRoutingControl_reply_func+0x22>
	{
		log("AudioRouting OK");
80002b8e:	48 7c       	lddpc	r12,80002ba8 <AudioRoutingControl_reply_func+0x30>
80002b90:	f0 1f 00 07 	mcall	80002bac <AudioRoutingControl_reply_func+0x34>
		xcmp_IdleTestTone();//
80002b94:	f0 1f 00 07 	mcall	80002bb0 <AudioRoutingControl_reply_func+0x38>
80002b98:	c0 48       	rjmp	80002ba0 <AudioRoutingControl_reply_func+0x28>
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002b9a:	48 7c       	lddpc	r12,80002bb4 <AudioRoutingControl_reply_func+0x3c>
80002b9c:	f0 1f 00 04 	mcall	80002bac <AudioRoutingControl_reply_func+0x34>
		//log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
		
	}
}
80002ba0:	2f fd       	sub	sp,-4
80002ba2:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ba6:	00 00       	add	r0,r0
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	22 40       	sub	r0,36
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	9f 84       	st.w	pc[0x20],r4
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	63 04       	ld.w	r4,r1[0x40]
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	22 50       	sub	r0,37

80002bb8 <AudioRoutingControl_brdcst_func>:


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002bb8:	eb cd 40 80 	pushm	r7,lr
80002bbc:	1a 97       	mov	r7,sp
80002bbe:	20 2d       	sub	sp,8
80002bc0:	ef 4c ff f8 	st.w	r7[-8],r12
	
	U16 num_routings = 0;
80002bc4:	30 08       	mov	r8,0
80002bc6:	ef 58 ff fc 	st.h	r7[-4],r8
	U8 j = 0 ;
80002bca:	30 08       	mov	r8,0
80002bcc:	ef 68 ff ff 	st.b	r7[-1],r8
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002bd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bd4:	11 a8       	ld.ub	r8,r8[0x2]
80002bd6:	a9 68       	lsl	r8,0x8
80002bd8:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002bdc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002be0:	11 b8       	ld.ub	r8,r8[0x3]
80002be2:	f3 e8 10 08 	or	r8,r9,r8
80002be6:	5c 88       	casts.h	r8
80002be8:	ef 58 ff fc 	st.h	r7[-4],r8
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002bec:	2f ed       	sub	sp,-8
80002bee:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bf2:	d7 03       	nop

80002bf4 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002bf4:	eb cd 40 80 	pushm	r7,lr
80002bf8:	1a 97       	mov	r7,sp
80002bfa:	20 2d       	sub	sp,8
80002bfc:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002c00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c04:	2f e8       	sub	r8,-2
80002c06:	ef 48 ff fc 	st.w	r7[-4],r8
	
	if (ptr->Result == xcmp_Res_Success)
80002c0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c0e:	11 88       	ld.ub	r8,r8[0x0]
80002c10:	58 08       	cp.w	r8,0
80002c12:	c1 d1       	brne	80002c4c <TransmitControl_reply_func+0x58>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002c14:	49 1c       	lddpc	r12,80002c58 <TransmitControl_reply_func+0x64>
80002c16:	f0 1f 00 12 	mcall	80002c5c <TransmitControl_reply_func+0x68>
		log("\n\r Function: %x \n\r", ptr->Function);
80002c1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c1e:	11 98       	ld.ub	r8,r8[0x1]
80002c20:	1a d8       	st.w	--sp,r8
80002c22:	49 0c       	lddpc	r12,80002c60 <TransmitControl_reply_func+0x6c>
80002c24:	f0 1f 00 0e 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c28:	2f fd       	sub	sp,-4
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002c2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c2e:	11 a8       	ld.ub	r8,r8[0x2]
80002c30:	1a d8       	st.w	--sp,r8
80002c32:	48 dc       	lddpc	r12,80002c64 <TransmitControl_reply_func+0x70>
80002c34:	f0 1f 00 0a 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c38:	2f fd       	sub	sp,-4
		log("\n\r State: %x \n\r", ptr->State);
80002c3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c3e:	11 b8       	ld.ub	r8,r8[0x3]
80002c40:	1a d8       	st.w	--sp,r8
80002c42:	48 ac       	lddpc	r12,80002c68 <TransmitControl_reply_func+0x74>
80002c44:	f0 1f 00 06 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c48:	2f fd       	sub	sp,-4
80002c4a:	c0 48       	rjmp	80002c52 <TransmitControl_reply_func+0x5e>
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002c4c:	48 8c       	lddpc	r12,80002c6c <TransmitControl_reply_func+0x78>
80002c4e:	f0 1f 00 04 	mcall	80002c5c <TransmitControl_reply_func+0x68>
	}
	

}
80002c52:	2f ed       	sub	sp,-8
80002c54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	22 64       	sub	r4,38
80002c5c:	80 00       	ld.sh	r0,r0[0x0]
80002c5e:	9f 84       	st.w	pc[0x20],r4
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	22 80       	sub	r0,40
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	22 94       	sub	r4,41
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	22 b0       	sub	r0,43
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	22 c0       	sub	r0,44

80002c70 <TransmitControl_brdcst_func>:


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002c70:	eb cd 40 80 	pushm	r7,lr
80002c74:	1a 97       	mov	r7,sp
80002c76:	20 2d       	sub	sp,8
80002c78:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002c7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c80:	2f e8       	sub	r8,-2
80002c82:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002c86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c8a:	11 98       	ld.ub	r8,r8[0x1]
80002c8c:	58 08       	cp.w	r8,0
80002c8e:	c0 71       	brne	80002c9c <TransmitControl_brdcst_func+0x2c>
	{
		log("\n\r  Standby-Receive \n\r ");
80002c90:	48 bc       	lddpc	r12,80002cbc <TransmitControl_brdcst_func+0x4c>
80002c92:	f0 1f 00 0c 	mcall	80002cc0 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 0;
80002c96:	48 c9       	lddpc	r9,80002cc4 <TransmitControl_brdcst_func+0x54>
80002c98:	30 08       	mov	r8,0
80002c9a:	b2 88       	st.b	r9[0x0],r8
	}
	if (ptr->State == 0x01)
80002c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca0:	11 99       	ld.ub	r9,r8[0x1]
80002ca2:	30 18       	mov	r8,1
80002ca4:	f0 09 18 00 	cp.b	r9,r8
80002ca8:	c0 71       	brne	80002cb6 <TransmitControl_brdcst_func+0x46>
	{
		log("\n\r  Transmit \n\r ");
80002caa:	48 8c       	lddpc	r12,80002cc8 <TransmitControl_brdcst_func+0x58>
80002cac:	f0 1f 00 05 	mcall	80002cc0 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 1;
80002cb0:	48 59       	lddpc	r9,80002cc4 <TransmitControl_brdcst_func+0x54>
80002cb2:	30 18       	mov	r8,1
80002cb4:	b2 88       	st.b	r9[0x0],r8
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002cb6:	2f ed       	sub	sp,-8
80002cb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	22 d8       	sub	r8,45
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	9f 84       	st.w	pc[0x20],r4
80002cc4:	00 00       	add	r0,r0
80002cc6:	0a 54       	eor	r4,r5
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	22 f0       	sub	r0,47

80002ccc <CallControl_brdcst_func>:


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ccc:	eb cd 40 80 	pushm	r7,lr
80002cd0:	1a 97       	mov	r7,sp
80002cd2:	20 2d       	sub	sp,8
80002cd4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002cd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cdc:	2f e8       	sub	r8,-2
80002cde:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002ce2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ce6:	11 98       	ld.ub	r8,r8[0x1]
80002ce8:	1a d8       	st.w	--sp,r8
80002cea:	48 ec       	lddpc	r12,80002d20 <CallControl_brdcst_func+0x54>
80002cec:	f0 1f 00 0e 	mcall	80002d24 <CallControl_brdcst_func+0x58>
80002cf0:	2f fd       	sub	sp,-4
	if (ptr->Callstate == Call_Ended)//0x03
80002cf2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cf6:	11 99       	ld.ub	r9,r8[0x1]
80002cf8:	30 38       	mov	r8,3
80002cfa:	f0 09 18 00 	cp.b	r9,r8
80002cfe:	c0 41       	brne	80002d06 <CallControl_brdcst_func+0x3a>
	{
		//
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002d00:	48 a9       	lddpc	r9,80002d28 <CallControl_brdcst_func+0x5c>
80002d02:	30 08       	mov	r8,0
80002d04:	b2 88       	st.b	r9[0x0],r8
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002d06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d0a:	11 99       	ld.ub	r9,r8[0x1]
80002d0c:	30 48       	mov	r8,4
80002d0e:	f0 09 18 00 	cp.b	r9,r8
80002d12:	c0 41       	brne	80002d1a <CallControl_brdcst_func+0x4e>
	{
		Call_Begin = 1;
80002d14:	48 59       	lddpc	r9,80002d28 <CallControl_brdcst_func+0x5c>
80002d16:	30 18       	mov	r8,1
80002d18:	b2 88       	st.b	r9[0x0],r8
		//xcmp_audio_route_decoder_AMBE();

	}
	
	
}
80002d1a:	2f ed       	sub	sp,-8
80002d1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	23 04       	sub	r4,48
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	9f 84       	st.w	pc[0x20],r4
80002d28:	00 00       	add	r0,r0
80002d2a:	0a 56       	eor	r6,r5

80002d2c <DataSession_reply_func>:



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002d2c:	eb cd 40 80 	pushm	r7,lr
80002d30:	1a 97       	mov	r7,sp
80002d32:	20 1d       	sub	sp,4
80002d34:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002d38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d3c:	11 a8       	ld.ub	r8,r8[0x2]
80002d3e:	58 08       	cp.w	r8,0
80002d40:	c0 51       	brne	80002d4a <DataSession_reply_func+0x1e>
	{
		log("\n\r DATArep OK \n\r");
80002d42:	49 2c       	lddpc	r12,80002d88 <DataSession_reply_func+0x5c>
80002d44:	f0 1f 00 12 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d48:	c1 c8       	rjmp	80002d80 <DataSession_reply_func+0x54>
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002d4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d4e:	11 a8       	ld.ub	r8,r8[0x2]
80002d50:	1a d8       	st.w	--sp,r8
80002d52:	49 0c       	lddpc	r12,80002d90 <DataSession_reply_func+0x64>
80002d54:	f0 1f 00 0e 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d58:	2f fd       	sub	sp,-4
		log("\n\r DATArep error \n\r");
80002d5a:	48 fc       	lddpc	r12,80002d94 <DataSession_reply_func+0x68>
80002d5c:	f0 1f 00 0c 	mcall	80002d8c <DataSession_reply_func+0x60>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002d60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d64:	11 b8       	ld.ub	r8,r8[0x3]
80002d66:	1a d8       	st.w	--sp,r8
80002d68:	48 cc       	lddpc	r12,80002d98 <DataSession_reply_func+0x6c>
80002d6a:	f0 1f 00 09 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d6e:	2f fd       	sub	sp,-4
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002d70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d74:	11 c8       	ld.ub	r8,r8[0x4]
80002d76:	1a d8       	st.w	--sp,r8
80002d78:	48 9c       	lddpc	r12,80002d9c <DataSession_reply_func+0x70>
80002d7a:	f0 1f 00 05 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d7e:	2f fd       	sub	sp,-4
	}
	
}
80002d80:	2f fd       	sub	sp,-4
80002d82:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d86:	00 00       	add	r0,r0
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	23 1c       	sub	r12,49
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	9f 84       	st.w	pc[0x20],r4
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	23 30       	sub	r0,51
80002d94:	80 00       	ld.sh	r0,r0[0x0]
80002d96:	23 44       	sub	r4,52
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	23 58       	sub	r8,53
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	23 68       	sub	r8,54

80002da0 <DataSession_brdcst_func>:

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002da0:	eb cd 40 80 	pushm	r7,lr
80002da4:	1a 97       	mov	r7,sp
80002da6:	20 4d       	sub	sp,16
80002da8:	ef 4c ff f0 	st.w	r7[-16],r12
	U8 Session_number = 0;
80002dac:	30 08       	mov	r8,0
80002dae:	ef 68 ff f7 	st.b	r7[-9],r8
	U16 data_length = 0;
80002db2:	30 08       	mov	r8,0
80002db4:	ef 58 ff f8 	st.h	r7[-8],r8
	U8 i = 0;
80002db8:	30 08       	mov	r8,0
80002dba:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002dbe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002dc2:	2f e8       	sub	r8,-2
80002dc4:	ef 48 ff fc 	st.w	r7[-4],r8

	if (ptr->State == CSBK_DATA_RX_Suc)
80002dc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dcc:	11 89       	ld.ub	r9,r8[0x0]
80002dce:	32 48       	mov	r8,36
80002dd0:	f0 09 18 00 	cp.b	r9,r8
80002dd4:	c4 71       	brne	80002e62 <DataSession_brdcst_func+0xc2>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002dd6:	4a 9c       	lddpc	r12,80002e78 <DataSession_brdcst_func+0xd8>
80002dd8:	f0 1f 00 29 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
80002ddc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002de0:	11 98       	ld.ub	r8,r8[0x1]
80002de2:	ef 68 ff f7 	st.b	r7[-9],r8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002de6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dea:	11 a8       	ld.ub	r8,r8[0x2]
80002dec:	a9 68       	lsl	r8,0x8
80002dee:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002df2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002df6:	11 b8       	ld.ub	r8,r8[0x3]
80002df8:	f3 e8 10 08 	or	r8,r9,r8
80002dfc:	5c 88       	casts.h	r8
80002dfe:	ef 58 ff f8 	st.h	r7[-8],r8

		log("\n\r Session_ID: %x \n\r",Session_number );
80002e02:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80002e06:	1a d8       	st.w	--sp,r8
80002e08:	49 ec       	lddpc	r12,80002e80 <DataSession_brdcst_func+0xe0>
80002e0a:	f0 1f 00 1d 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e0e:	2f fd       	sub	sp,-4
		log("\n\r paylaod_length: %d \n\r",data_length );
80002e10:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80002e14:	1a d8       	st.w	--sp,r8
80002e16:	49 cc       	lddpc	r12,80002e84 <DataSession_brdcst_func+0xe4>
80002e18:	f0 1f 00 19 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e1c:	2f fd       	sub	sp,-4
		for(i=0; i<data_length; i++)
80002e1e:	30 08       	mov	r8,0
80002e20:	ef 68 ff fb 	st.b	r7[-5],r8
80002e24:	c1 68       	rjmp	80002e50 <DataSession_brdcst_func+0xb0>
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002e26:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e2a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002e2e:	f2 08 00 08 	add	r8,r9,r8
80002e32:	11 c8       	ld.ub	r8,r8[0x4]
80002e34:	10 99       	mov	r9,r8
80002e36:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e3a:	1a d9       	st.w	--sp,r9
80002e3c:	1a d8       	st.w	--sp,r8
80002e3e:	49 3c       	lddpc	r12,80002e88 <DataSession_brdcst_func+0xe8>
80002e40:	f0 1f 00 0f 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e44:	2f ed       	sub	sp,-8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002e46:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e4a:	2f f8       	sub	r8,-1
80002e4c:	ef 68 ff fb 	st.b	r7[-5],r8
80002e50:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e54:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80002e58:	f0 09 19 00 	cp.h	r9,r8
80002e5c:	fe 9b ff e5 	brhi	80002e26 <DataSession_brdcst_func+0x86>
80002e60:	c0 98       	rjmp	80002e72 <DataSession_brdcst_func+0xd2>
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002e62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e66:	11 88       	ld.ub	r8,r8[0x0]
80002e68:	1a d8       	st.w	--sp,r8
80002e6a:	48 9c       	lddpc	r12,80002e8c <DataSession_brdcst_func+0xec>
80002e6c:	f0 1f 00 04 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e70:	2f fd       	sub	sp,-4
		
	}
	
}
80002e72:	2f cd       	sub	sp,-16
80002e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	23 78       	sub	r8,55
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	9f 84       	st.w	pc[0x20],r4
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	23 8c       	sub	r12,56
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	23 a4       	sub	r4,58
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	23 c0       	sub	r0,60
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	23 d8       	sub	r8,61

80002e90 <ButtonConfig_reply_func>:

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002e90:	eb cd 40 80 	pushm	r7,lr
80002e94:	1a 97       	mov	r7,sp
80002e96:	20 2d       	sub	sp,8
80002e98:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002e9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ea0:	2f e8       	sub	r8,-2
80002ea2:	ef 48 ff fc 	st.w	r7[-4],r8
	if (ptr->Result == xcmp_Res_Success)
80002ea6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eaa:	11 88       	ld.ub	r8,r8[0x0]
80002eac:	58 08       	cp.w	r8,0
80002eae:	c0 d1       	brne	80002ec8 <ButtonConfig_reply_func+0x38>
	{
		log("\n\r Button_Config OK \n\r");
80002eb0:	48 9c       	lddpc	r12,80002ed4 <ButtonConfig_reply_func+0x44>
80002eb2:	f0 1f 00 0a 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002eb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eba:	11 98       	ld.ub	r8,r8[0x1]
80002ebc:	1a d8       	st.w	--sp,r8
80002ebe:	48 8c       	lddpc	r12,80002edc <ButtonConfig_reply_func+0x4c>
80002ec0:	f0 1f 00 06 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
80002ec4:	2f fd       	sub	sp,-4
80002ec6:	c0 48       	rjmp	80002ece <ButtonConfig_reply_func+0x3e>
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002ec8:	48 6c       	lddpc	r12,80002ee0 <ButtonConfig_reply_func+0x50>
80002eca:	f0 1f 00 04 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
	}
	
}
80002ece:	2f ed       	sub	sp,-8
80002ed0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	23 ec       	sub	r12,62
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	9f 84       	st.w	pc[0x20],r4
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	24 04       	sub	r4,64
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	24 18       	sub	r8,65

80002ee4 <Phyuserinput_brdcst_func>:


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ee4:	eb cd 40 80 	pushm	r7,lr
80002ee8:	1a 97       	mov	r7,sp
80002eea:	20 3d       	sub	sp,12
80002eec:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 PUI_Source =0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 PUI_Type =0;
80002ef6:	30 08       	mov	r8,0
80002ef8:	ef 68 ff f9 	st.b	r7[-7],r8
	U16 PUI_ID =0;
80002efc:	30 08       	mov	r8,0
80002efe:	ef 58 ff fa 	st.h	r7[-6],r8
	U8 PUI_State =0;
80002f02:	30 08       	mov	r8,0
80002f04:	ef 68 ff fd 	st.b	r7[-3],r8
	U8 PUI_State_Min_Value =0;
80002f08:	30 08       	mov	r8,0
80002f0a:	ef 68 ff fe 	st.b	r7[-2],r8
	U8 PUI_State_Max_Value =0;
80002f0e:	30 08       	mov	r8,0
80002f10:	ef 68 ff ff 	st.b	r7[-1],r8
	
	PUI_Source = xcmp->u8[0];
80002f14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f18:	11 a8       	ld.ub	r8,r8[0x2]
80002f1a:	ef 68 ff f8 	st.b	r7[-8],r8
	PUI_Type = xcmp ->u8[1];
80002f1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f22:	11 b8       	ld.ub	r8,r8[0x3]
80002f24:	ef 68 ff f9 	st.b	r7[-7],r8
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002f28:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f2c:	11 c8       	ld.ub	r8,r8[0x4]
80002f2e:	a9 68       	lsl	r8,0x8
80002f30:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002f34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f38:	11 d8       	ld.ub	r8,r8[0x5]
80002f3a:	f3 e8 10 08 	or	r8,r9,r8
80002f3e:	5c 88       	casts.h	r8
80002f40:	ef 58 ff fa 	st.h	r7[-6],r8
	PUI_State = xcmp->u8[4];
80002f44:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f48:	11 e8       	ld.ub	r8,r8[0x6]
80002f4a:	ef 68 ff fd 	st.b	r7[-3],r8
	PUI_State_Min_Value = xcmp->u8[5];
80002f4e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f52:	11 f8       	ld.ub	r8,r8[0x7]
80002f54:	ef 68 ff fe 	st.b	r7[-2],r8
	PUI_State_Max_Value = xcmp->u8[6];
80002f58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f5c:	f1 38 00 08 	ld.ub	r8,r8[8]
80002f60:	ef 68 ff ff 	st.b	r7[-1],r8
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002f64:	49 8c       	lddpc	r12,80002fc4 <Phyuserinput_brdcst_func+0xe0>
80002f66:	f0 1f 00 19 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002f6a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002f6e:	1a d8       	st.w	--sp,r8
80002f70:	49 7c       	lddpc	r12,80002fcc <Phyuserinput_brdcst_func+0xe8>
80002f72:	f0 1f 00 16 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f76:	2f fd       	sub	sp,-4
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002f78:	ef 38 ff f9 	ld.ub	r8,r7[-7]
80002f7c:	1a d8       	st.w	--sp,r8
80002f7e:	49 5c       	lddpc	r12,80002fd0 <Phyuserinput_brdcst_func+0xec>
80002f80:	f0 1f 00 12 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f84:	2f fd       	sub	sp,-4
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002f86:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80002f8a:	1a d8       	st.w	--sp,r8
80002f8c:	49 2c       	lddpc	r12,80002fd4 <Phyuserinput_brdcst_func+0xf0>
80002f8e:	f0 1f 00 0f 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f92:	2f fd       	sub	sp,-4
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002f94:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80002f98:	1a d8       	st.w	--sp,r8
80002f9a:	49 0c       	lddpc	r12,80002fd8 <Phyuserinput_brdcst_func+0xf4>
80002f9c:	f0 1f 00 0b 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fa0:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002fa2:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80002fa6:	1a d8       	st.w	--sp,r8
80002fa8:	48 dc       	lddpc	r12,80002fdc <Phyuserinput_brdcst_func+0xf8>
80002faa:	f0 1f 00 08 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fae:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002fb0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002fb4:	1a d8       	st.w	--sp,r8
80002fb6:	48 bc       	lddpc	r12,80002fe0 <Phyuserinput_brdcst_func+0xfc>
80002fb8:	f0 1f 00 04 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fbc:	2f fd       	sub	sp,-4
	
	
	
	
	
}
80002fbe:	2f dd       	sub	sp,-12
80002fc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	24 34       	sub	r4,67
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	9f 84       	st.w	pc[0x20],r4
80002fcc:	80 00       	ld.sh	r0,r0[0x0]
80002fce:	24 58       	sub	r8,69
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	24 70       	sub	r0,71
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	24 84       	sub	r4,72
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	24 98       	sub	r8,73
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	24 ac       	sub	r12,74
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	24 cc       	sub	r12,76

80002fe4 <ButtonConfig_brdcst_func>:


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002fe4:	eb cd 40 80 	pushm	r7,lr
80002fe8:	1a 97       	mov	r7,sp
80002fea:	20 3d       	sub	sp,12
80002fec:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 Num_Button =0;
80002ff0:	30 08       	mov	r8,0
80002ff2:	ef 68 ff fa 	st.b	r7[-6],r8
	U8 i = 0 ;
80002ff6:	30 08       	mov	r8,0
80002ff8:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002ffc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003000:	2f e8       	sub	r8,-2
80003002:	ef 48 ff fc 	st.w	r7[-4],r8
	
	Num_Button = ptr->NumOfButtons;
80003006:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000300a:	11 98       	ld.ub	r8,r8[0x1]
8000300c:	ef 68 ff fa 	st.b	r7[-6],r8
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80003010:	4f 0c       	lddpc	r12,800031d0 <ButtonConfig_brdcst_func+0x1ec>
80003012:	f0 1f 00 71 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80003016:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000301a:	11 88       	ld.ub	r8,r8[0x0]
8000301c:	1a d8       	st.w	--sp,r8
8000301e:	4e fc       	lddpc	r12,800031d8 <ButtonConfig_brdcst_func+0x1f4>
80003020:	f0 1f 00 6d 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003024:	2f fd       	sub	sp,-4
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80003026:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000302a:	1a d8       	st.w	--sp,r8
8000302c:	4e cc       	lddpc	r12,800031dc <ButtonConfig_brdcst_func+0x1f8>
8000302e:	f0 1f 00 6a 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003032:	2f fd       	sub	sp,-4
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80003034:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003038:	11 a8       	ld.ub	r8,r8[0x2]
8000303a:	1a d8       	st.w	--sp,r8
8000303c:	4e 9c       	lddpc	r12,800031e0 <ButtonConfig_brdcst_func+0x1fc>
8000303e:	f0 1f 00 66 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003042:	2f fd       	sub	sp,-4
	
	for (i; i<Num_Button; i++)
80003044:	cb a8       	rjmp	800031b8 <ButtonConfig_brdcst_func+0x1d4>
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
80003046:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000304a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000304e:	12 98       	mov	r8,r9
80003050:	a3 68       	lsl	r8,0x2
80003052:	12 08       	add	r8,r9
80003054:	a1 78       	lsl	r8,0x1
80003056:	f4 08 00 08 	add	r8,r10,r8
8000305a:	2f d8       	sub	r8,-3
8000305c:	11 88       	ld.ub	r8,r8[0x0]
8000305e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003062:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003066:	ee fb ff fc 	ld.w	r11,r7[-4]
8000306a:	12 98       	mov	r8,r9
8000306c:	a3 68       	lsl	r8,0x2
8000306e:	12 08       	add	r8,r9
80003070:	a1 78       	lsl	r8,0x1
80003072:	f6 08 00 08 	add	r8,r11,r8
80003076:	2f c8       	sub	r8,-4
80003078:	11 88       	ld.ub	r8,r8[0x0]
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000307a:	f5 e8 10 09 	or	r9,r10,r8
8000307e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003082:	1a d9       	st.w	--sp,r9
80003084:	1a d8       	st.w	--sp,r8
80003086:	4d 8c       	lddpc	r12,800031e4 <ButtonConfig_brdcst_func+0x200>
80003088:	f0 1f 00 53 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
8000308c:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
8000308e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003092:	ee fa ff fc 	ld.w	r10,r7[-4]
80003096:	12 98       	mov	r8,r9
80003098:	a3 68       	lsl	r8,0x2
8000309a:	12 08       	add	r8,r9
8000309c:	a1 78       	lsl	r8,0x1
8000309e:	f4 08 00 08 	add	r8,r10,r8
800030a2:	2f b8       	sub	r8,-5
800030a4:	11 88       	ld.ub	r8,r8[0x0]
800030a6:	f0 0a 15 08 	lsl	r10,r8,0x8
800030aa:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030ae:	ee fb ff fc 	ld.w	r11,r7[-4]
800030b2:	12 98       	mov	r8,r9
800030b4:	a3 68       	lsl	r8,0x2
800030b6:	12 08       	add	r8,r9
800030b8:	a1 78       	lsl	r8,0x1
800030ba:	f6 08 00 08 	add	r8,r11,r8
800030be:	2f a8       	sub	r8,-6
800030c0:	11 88       	ld.ub	r8,r8[0x0]
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800030c2:	f5 e8 10 09 	or	r9,r10,r8
800030c6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800030ca:	1a d9       	st.w	--sp,r9
800030cc:	1a d8       	st.w	--sp,r8
800030ce:	4c 7c       	lddpc	r12,800031e8 <ButtonConfig_brdcst_func+0x204>
800030d0:	f0 1f 00 41 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
800030d4:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
800030d6:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030da:	ee fa ff fc 	ld.w	r10,r7[-4]
800030de:	12 98       	mov	r8,r9
800030e0:	a3 68       	lsl	r8,0x2
800030e2:	12 08       	add	r8,r9
800030e4:	a1 78       	lsl	r8,0x1
800030e6:	f4 08 00 08 	add	r8,r10,r8
800030ea:	2f 98       	sub	r8,-7
800030ec:	11 88       	ld.ub	r8,r8[0x0]
800030ee:	f0 0a 15 08 	lsl	r10,r8,0x8
800030f2:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030f6:	ee fb ff fc 	ld.w	r11,r7[-4]
800030fa:	12 98       	mov	r8,r9
800030fc:	a3 68       	lsl	r8,0x2
800030fe:	12 08       	add	r8,r9
80003100:	a1 78       	lsl	r8,0x1
80003102:	f6 08 00 08 	add	r8,r11,r8
80003106:	2f 88       	sub	r8,-8
80003108:	11 88       	ld.ub	r8,r8[0x0]
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000310a:	f5 e8 10 09 	or	r9,r10,r8
8000310e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003112:	1a d9       	st.w	--sp,r9
80003114:	1a d8       	st.w	--sp,r8
80003116:	4b 6c       	lddpc	r12,800031ec <ButtonConfig_brdcst_func+0x208>
80003118:	f0 1f 00 2f 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
8000311c:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
8000311e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003122:	ee fa ff fc 	ld.w	r10,r7[-4]
80003126:	12 98       	mov	r8,r9
80003128:	a3 68       	lsl	r8,0x2
8000312a:	12 08       	add	r8,r9
8000312c:	a1 78       	lsl	r8,0x1
8000312e:	f4 08 00 08 	add	r8,r10,r8
80003132:	2f 78       	sub	r8,-9
80003134:	11 88       	ld.ub	r8,r8[0x0]
80003136:	f0 0a 15 08 	lsl	r10,r8,0x8
8000313a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000313e:	ee fb ff fc 	ld.w	r11,r7[-4]
80003142:	12 98       	mov	r8,r9
80003144:	a3 68       	lsl	r8,0x2
80003146:	12 08       	add	r8,r9
80003148:	a1 78       	lsl	r8,0x1
8000314a:	f6 08 00 08 	add	r8,r11,r8
8000314e:	2f 68       	sub	r8,-10
80003150:	11 88       	ld.ub	r8,r8[0x0]
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80003152:	f5 e8 10 09 	or	r9,r10,r8
80003156:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000315a:	1a d9       	st.w	--sp,r9
8000315c:	1a d8       	st.w	--sp,r8
8000315e:	4a 5c       	lddpc	r12,800031f0 <ButtonConfig_brdcst_func+0x20c>
80003160:	f0 1f 00 1d 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003164:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved2[0]<<8) | (ptr->ButtonInfo[i].Reserved2[1]));
80003166:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000316a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000316e:	12 98       	mov	r8,r9
80003170:	a3 68       	lsl	r8,0x2
80003172:	12 08       	add	r8,r9
80003174:	a1 78       	lsl	r8,0x1
80003176:	f4 08 00 08 	add	r8,r10,r8
8000317a:	2f 58       	sub	r8,-11
8000317c:	11 88       	ld.ub	r8,r8[0x0]
8000317e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003182:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003186:	ee fb ff fc 	ld.w	r11,r7[-4]
8000318a:	12 98       	mov	r8,r9
8000318c:	a3 68       	lsl	r8,0x2
8000318e:	12 08       	add	r8,r9
80003190:	a1 78       	lsl	r8,0x1
80003192:	f6 08 00 08 	add	r8,r11,r8
80003196:	2f 48       	sub	r8,-12
80003198:	11 88       	ld.ub	r8,r8[0x0]
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000319a:	f5 e8 10 09 	or	r9,r10,r8
8000319e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800031a2:	1a d9       	st.w	--sp,r9
800031a4:	1a d8       	st.w	--sp,r8
800031a6:	49 4c       	lddpc	r12,800031f4 <ButtonConfig_brdcst_func+0x210>
800031a8:	f0 1f 00 0b 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
800031ac:	2f ed       	sub	sp,-8
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800031ae:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800031b2:	2f f8       	sub	r8,-1
800031b4:	ef 68 ff fb 	st.b	r7[-5],r8
800031b8:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800031bc:	ef 38 ff fa 	ld.ub	r8,r7[-6]
800031c0:	f0 09 18 00 	cp.b	r9,r8
800031c4:	fe 93 ff 41 	brlo	80003046 <ButtonConfig_brdcst_func+0x62>
		
	}
	

	
}
800031c8:	2f dd       	sub	sp,-12
800031ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800031ce:	00 00       	add	r0,r0
800031d0:	80 00       	ld.sh	r0,r0[0x0]
800031d2:	24 ec       	sub	r12,78
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	9f 84       	st.w	pc[0x20],r4
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	24 04       	sub	r4,64
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	25 0c       	sub	r12,80
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	25 24       	sub	r4,82
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	25 44       	sub	r4,84
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	25 6c       	sub	r12,86
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	25 94       	sub	r4,89
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	25 b8       	sub	r8,91
800031f4:	80 00       	ld.sh	r0,r0[0x0]
800031f6:	25 e0       	sub	r0,94

800031f8 <SingleDetection_brdcst_func>:


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800031f8:	eb cd 40 80 	pushm	r7,lr
800031fc:	1a 97       	mov	r7,sp
800031fe:	20 1d       	sub	sp,4
80003200:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == 0x11)
80003204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003208:	11 a9       	ld.ub	r9,r8[0x2]
8000320a:	31 18       	mov	r8,17
8000320c:	f0 09 18 00 	cp.b	r9,r8
80003210:	c0 41       	brne	80003218 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80003212:	48 4c       	lddpc	r12,80003220 <SingleDetection_brdcst_func+0x28>
80003214:	f0 1f 00 04 	mcall	80003224 <SingleDetection_brdcst_func+0x2c>
		//log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
	}
	

	//;
}
80003218:	2f fd       	sub	sp,-4
8000321a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000321e:	00 00       	add	r0,r0
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	26 04       	sub	r4,96
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	9f 84       	st.w	pc[0x20],r4

80003228 <EnOB_reply_func>:



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80003228:	eb cd 40 80 	pushm	r7,lr
8000322c:	1a 97       	mov	r7,sp
8000322e:	20 1d       	sub	sp,4
80003230:	ef 4c ff fc 	st.w	r7[-4],r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80003234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003238:	11 a8       	ld.ub	r8,r8[0x2]
8000323a:	58 08       	cp.w	r8,0
8000323c:	c1 e1       	brne	80003278 <EnOB_reply_func+0x50>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000323e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003242:	11 b9       	ld.ub	r9,r8[0x3]
80003244:	30 18       	mov	r8,1
80003246:	f0 09 18 00 	cp.b	r9,r8
8000324a:	c0 51       	brne	80003254 <EnOB_reply_func+0x2c>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000324c:	49 2c       	lddpc	r12,80003294 <EnOB_reply_func+0x6c>
8000324e:	f0 1f 00 13 	mcall	80003298 <EnOB_reply_func+0x70>
80003252:	c1 e8       	rjmp	8000328e <EnOB_reply_func+0x66>
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80003254:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003258:	11 b8       	ld.ub	r8,r8[0x3]
8000325a:	58 08       	cp.w	r8,0
8000325c:	c0 51       	brne	80003266 <EnOB_reply_func+0x3e>
		{
			log("\n\r En_OB_Exit OK \n\r");
8000325e:	49 0c       	lddpc	r12,8000329c <EnOB_reply_func+0x74>
80003260:	f0 1f 00 0e 	mcall	80003298 <EnOB_reply_func+0x70>
80003264:	c1 58       	rjmp	8000328e <EnOB_reply_func+0x66>
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80003266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000326a:	11 b8       	ld.ub	r8,r8[0x3]
8000326c:	1a d8       	st.w	--sp,r8
8000326e:	48 dc       	lddpc	r12,800032a0 <EnOB_reply_func+0x78>
80003270:	f0 1f 00 0a 	mcall	80003298 <EnOB_reply_func+0x70>
80003274:	2f fd       	sub	sp,-4
80003276:	c0 c8       	rjmp	8000328e <EnOB_reply_func+0x66>
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80003278:	48 bc       	lddpc	r12,800032a4 <EnOB_reply_func+0x7c>
8000327a:	f0 1f 00 08 	mcall	80003298 <EnOB_reply_func+0x70>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000327e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003282:	11 a8       	ld.ub	r8,r8[0x2]
80003284:	1a d8       	st.w	--sp,r8
80003286:	48 9c       	lddpc	r12,800032a8 <EnOB_reply_func+0x80>
80003288:	f0 1f 00 04 	mcall	80003298 <EnOB_reply_func+0x70>
8000328c:	2f fd       	sub	sp,-4
		
	}
	
	
}
8000328e:	2f fd       	sub	sp,-4
80003290:	e3 cd 80 80 	ldm	sp++,r7,pc
80003294:	80 00       	ld.sh	r0,r0[0x0]
80003296:	26 18       	sub	r8,97
80003298:	80 00       	ld.sh	r0,r0[0x0]
8000329a:	9f 84       	st.w	pc[0x20],r4
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	26 30       	sub	r0,99
800032a0:	80 00       	ld.sh	r0,r0[0x0]
800032a2:	26 44       	sub	r4,100
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	26 5c       	sub	r12,101
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	26 78       	sub	r8,103

800032ac <EnOB_brdcst_func>:

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800032ac:	eb cd 40 80 	pushm	r7,lr
800032b0:	1a 97       	mov	r7,sp
800032b2:	20 1d       	sub	sp,4
800032b4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r En_OB Broadcast \n\r");
800032b8:	48 3c       	lddpc	r12,800032c4 <EnOB_brdcst_func+0x18>
800032ba:	f0 1f 00 04 	mcall	800032c8 <EnOB_brdcst_func+0x1c>
}
800032be:	2f fd       	sub	sp,-4
800032c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032c4:	80 00       	ld.sh	r0,r0[0x0]
800032c6:	26 90       	sub	r0,105
800032c8:	80 00       	ld.sh	r0,r0[0x0]
800032ca:	9f 84       	st.w	pc[0x20],r4

800032cc <FD_request_func>:



void FD_request_func(xcmp_fragment_t * xcmp)
{
800032cc:	eb cd 40 80 	pushm	r7,lr
800032d0:	1a 97       	mov	r7,sp
800032d2:	20 1d       	sub	sp,4
800032d4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Request \n\r");
800032d8:	48 3c       	lddpc	r12,800032e4 <FD_request_func+0x18>
800032da:	f0 1f 00 04 	mcall	800032e8 <FD_request_func+0x1c>
	
	
}
800032de:	2f fd       	sub	sp,-4
800032e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032e4:	80 00       	ld.sh	r0,r0[0x0]
800032e6:	26 a8       	sub	r8,106
800032e8:	80 00       	ld.sh	r0,r0[0x0]
800032ea:	9f 84       	st.w	pc[0x20],r4

800032ec <FD_reply_func>:

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800032ec:	eb cd 40 80 	pushm	r7,lr
800032f0:	1a 97       	mov	r7,sp
800032f2:	20 1d       	sub	sp,4
800032f4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Reply \n\r");
800032f8:	48 3c       	lddpc	r12,80003304 <FD_reply_func+0x18>
800032fa:	f0 1f 00 04 	mcall	80003308 <FD_reply_func+0x1c>
	
	
}
800032fe:	2f fd       	sub	sp,-4
80003300:	e3 cd 80 80 	ldm	sp++,r7,pc
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	26 c4       	sub	r4,108
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	9f 84       	st.w	pc[0x20],r4

8000330c <FD_brdcst_func>:

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000330c:	eb cd 40 80 	pushm	r7,lr
80003310:	1a 97       	mov	r7,sp
80003312:	20 1d       	sub	sp,4
80003314:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r Forward Data Broadcast \n\r");
80003318:	48 3c       	lddpc	r12,80003324 <FD_brdcst_func+0x18>
8000331a:	f0 1f 00 04 	mcall	80003328 <FD_brdcst_func+0x1c>
	
}
8000331e:	2f fd       	sub	sp,-4
80003320:	e3 cd 80 80 	ldm	sp++,r7,pc
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	26 e0       	sub	r0,110
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	9f 84       	st.w	pc[0x20],r4

8000332c <app_init>:
														
		
};

void app_init(void)
{	
8000332c:	eb cd 40 80 	pushm	r7,lr
80003330:	1a 97       	mov	r7,sp
	//app_payload_rx_procPCM
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80003332:	48 eb       	lddpc	r11,80003368 <app_init+0x3c>
80003334:	48 ec       	lddpc	r12,8000336c <app_init+0x40>
80003336:	f0 1f 00 0f 	mcall	80003370 <app_init+0x44>
	xcmp_register_app_list(the_app_list);
8000333a:	48 fc       	lddpc	r12,80003374 <app_init+0x48>
8000333c:	f0 1f 00 0f 	mcall	80003378 <app_init+0x4c>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80003340:	48 fb       	lddpc	r11,8000337c <app_init+0x50>
80003342:	30 08       	mov	r8,0
80003344:	1a d8       	st.w	--sp,r8
80003346:	30 08       	mov	r8,0
80003348:	1a d8       	st.w	--sp,r8
8000334a:	30 08       	mov	r8,0
8000334c:	1a d8       	st.w	--sp,r8
8000334e:	30 18       	mov	r8,1
80003350:	30 09       	mov	r9,0
80003352:	e0 6a 01 80 	mov	r10,384
80003356:	48 bc       	lddpc	r12,80003380 <app_init+0x54>
80003358:	f0 1f 00 0b 	mcall	80003384 <app_init+0x58>
8000335c:	2f dd       	sub	sp,-12
8000335e:	18 99       	mov	r9,r12
80003360:	48 a8       	lddpc	r8,80003388 <app_init+0x5c>
80003362:	91 09       	st.w	r8[0x0],r9
	,  NULL
	,  1
	,  NULL );
	
	
}
80003364:	e3 cd 80 80 	ldm	sp++,r7,pc
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	34 c4       	mov	r4,76
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	34 64       	mov	r4,70
80003370:	80 00       	ld.sh	r0,r0[0x0]
80003372:	3e 5c       	mov	r12,-27
80003374:	00 00       	add	r0,r0
80003376:	00 08       	add	r8,r0
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	62 38       	ld.w	r8,r1[0xc]
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	27 00       	sub	r0,112
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	33 8c       	mov	r12,56
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	8d b0       	st.w	r6[0x2c],r0
80003388:	00 00       	add	r0,r0
8000338a:	0a 6c       	and	r12,r5

8000338c <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
8000338c:	eb cd 40 80 	pushm	r7,lr
80003390:	1a 97       	mov	r7,sp
80003392:	20 3d       	sub	sp,12
80003394:	ef 4c ff f4 	st.w	r7[-12],r12
	static int counter=0;
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
80003398:	e0 68 0f a0 	mov	r8,4000
8000339c:	ef 48 ff f8 	st.w	r7[-8],r8
	U8 Burst_ID = 0;
800033a0:	30 08       	mov	r8,0
800033a2:	ef 68 ff ff 	st.b	r7[-1],r8
	
	 xLastWakeTime = xTaskGetTickCount();
800033a6:	f0 1f 00 26 	mcall	8000343c <app_cfg+0xb0>
800033aa:	18 99       	mov	r9,r12
800033ac:	4a 58       	lddpc	r8,80003440 <app_cfg+0xb4>
800033ae:	91 09       	st.w	r8[0x0],r9
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800033b0:	4a 58       	lddpc	r8,80003444 <app_cfg+0xb8>
800033b2:	70 08       	ld.w	r8,r8[0x0]
800033b4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033b8:	58 38       	cp.w	r8,3
800033ba:	c2 d1       	brne	80003414 <app_cfg+0x88>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800033bc:	f0 1f 00 23 	mcall	80003448 <app_cfg+0xbc>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800033c0:	4a 38       	lddpc	r8,8000344c <app_cfg+0xc0>
800033c2:	70 08       	ld.w	r8,r8[0x0]
800033c4:	58 08       	cp.w	r8,0
800033c6:	c0 71       	brne	800033d4 <app_cfg+0x48>
				{
					xcmp_data_session();
800033c8:	f0 1f 00 22 	mcall	80003450 <app_cfg+0xc4>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800033cc:	4a 08       	lddpc	r8,8000344c <app_cfg+0xc0>
800033ce:	30 19       	mov	r9,1
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	c2 18       	rjmp	80003414 <app_cfg+0x88>
				}
				else if(isAudioRouting == 1)
800033d4:	49 e8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033d6:	70 08       	ld.w	r8,r8[0x0]
800033d8:	58 18       	cp.w	r8,1
800033da:	c0 51       	brne	800033e4 <app_cfg+0x58>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800033dc:	49 c8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033de:	30 29       	mov	r9,2
800033e0:	91 09       	st.w	r8[0x0],r9
800033e2:	c1 98       	rjmp	80003414 <app_cfg+0x88>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800033e4:	49 a8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033e6:	70 08       	ld.w	r8,r8[0x0]
800033e8:	58 28       	cp.w	r8,2
800033ea:	c0 71       	brne	800033f8 <app_cfg+0x6c>
				{
					xcmp_data_session();
800033ec:	f0 1f 00 19 	mcall	80003450 <app_cfg+0xc4>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800033f0:	49 78       	lddpc	r8,8000344c <app_cfg+0xc0>
800033f2:	30 39       	mov	r9,3
800033f4:	91 09       	st.w	r8[0x0],r9
800033f6:	c0 f8       	rjmp	80003414 <app_cfg+0x88>
					
				}
				else if(isAudioRouting == 3)
800033f8:	49 58       	lddpc	r8,8000344c <app_cfg+0xc0>
800033fa:	70 08       	ld.w	r8,r8[0x0]
800033fc:	58 38       	cp.w	r8,3
800033fe:	c0 51       	brne	80003408 <app_cfg+0x7c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80003400:	49 38       	lddpc	r8,8000344c <app_cfg+0xc0>
80003402:	30 49       	mov	r9,4
80003404:	91 09       	st.w	r8[0x0],r9
80003406:	c0 78       	rjmp	80003414 <app_cfg+0x88>
					
				}
				else
				{
					isAudioRouting++;
80003408:	49 18       	lddpc	r8,8000344c <app_cfg+0xc0>
8000340a:	70 08       	ld.w	r8,r8[0x0]
8000340c:	f0 c9 ff ff 	sub	r9,r8,-1
80003410:	48 f8       	lddpc	r8,8000344c <app_cfg+0xc0>
80003412:	91 09       	st.w	r8[0x0],r9
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		counter++;
80003414:	49 08       	lddpc	r8,80003454 <app_cfg+0xc8>
80003416:	70 08       	ld.w	r8,r8[0x0]
80003418:	f0 c9 ff ff 	sub	r9,r8,-1
8000341c:	48 e8       	lddpc	r8,80003454 <app_cfg+0xc8>
8000341e:	91 09       	st.w	r8[0x0],r9
		log("\n\r counter: %d \n\r", counter);
80003420:	48 d8       	lddpc	r8,80003454 <app_cfg+0xc8>
80003422:	70 08       	ld.w	r8,r8[0x0]
80003424:	1a d8       	st.w	--sp,r8
80003426:	48 dc       	lddpc	r12,80003458 <app_cfg+0xcc>
80003428:	f0 1f 00 0d 	mcall	8000345c <app_cfg+0xd0>
8000342c:	2f fd       	sub	sp,-4
		//log("\n\r xLastWakeTime: %d \n\r", xLastWakeTime);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//1000ms
8000342e:	e0 6b 07 d0 	mov	r11,2000
80003432:	48 4c       	lddpc	r12,80003440 <app_cfg+0xb4>
80003434:	f0 1f 00 0b 	mcall	80003460 <app_cfg+0xd4>
	}
80003438:	cb cb       	rjmp	800033b0 <app_cfg+0x24>
8000343a:	00 00       	add	r0,r0
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	92 00       	ld.sh	r0,r9[0x0]
80003440:	00 00       	add	r0,r0
80003442:	0a 60       	and	r0,r5
80003444:	00 00       	add	r0,r0
80003446:	0d 90       	ld.ub	r0,r6[0x1]
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	63 04       	ld.w	r4,r1[0x40]
8000344c:	00 00       	add	r0,r0
8000344e:	0a 64       	and	r4,r5
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	63 6c       	ld.w	r12,r1[0x58]
80003454:	00 00       	add	r0,r0
80003456:	0a 68       	and	r8,r5
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	27 08       	sub	r8,112
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	9f 84       	st.w	pc[0x20],r4
80003460:	80 00       	ld.sh	r0,r0[0x0]
80003462:	8f 78       	st.w	r7[0x1c],r8

80003464 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80003464:	eb cd 40 80 	pushm	r7,lr
80003468:	1a 97       	mov	r7,sp
8000346a:	20 1d       	sub	sp,4
8000346c:	ef 4c ff fc 	st.w	r7[-4],r12
	static  U8 times_counter = 0;
	
	times_counter++;
80003470:	48 f8       	lddpc	r8,800034ac <app_payload_rx_proc+0x48>
80003472:	11 88       	ld.ub	r8,r8[0x0]
80003474:	2f f8       	sub	r8,-1
80003476:	5c 58       	castu.b	r8
80003478:	48 d9       	lddpc	r9,800034ac <app_payload_rx_proc+0x48>
8000347a:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000347c:	48 c8       	lddpc	r8,800034ac <app_payload_rx_proc+0x48>
8000347e:	11 89       	ld.ub	r9,r8[0x0]
80003480:	30 38       	mov	r8,3
80003482:	f0 09 18 00 	cp.b	r9,r8
80003486:	c0 71       	brne	80003494 <app_payload_rx_proc+0x30>
	{
		times_counter = 0 ;
80003488:	48 99       	lddpc	r9,800034ac <app_payload_rx_proc+0x48>
8000348a:	30 08       	mov	r8,0
8000348c:	b2 88       	st.b	r9[0x0],r8
		log("\n\r w: \n\r");
8000348e:	48 9c       	lddpc	r12,800034b0 <app_payload_rx_proc+0x4c>
80003490:	f0 1f 00 09 	mcall	800034b4 <app_payload_rx_proc+0x50>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//mic
80003494:	48 98       	lddpc	r8,800034b8 <app_payload_rx_proc+0x54>
80003496:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80003498:	48 98       	lddpc	r8,800034bc <app_payload_rx_proc+0x58>
8000349a:	70 08       	ld.w	r8,r8[0x0]
8000349c:	ee fb ff fc 	ld.w	r11,r7[-4]
800034a0:	10 9c       	mov	r12,r8
800034a2:	f0 1f 00 08 	mcall	800034c0 <app_payload_rx_proc+0x5c>

}
800034a6:	2f fd       	sub	sp,-4
800034a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034ac:	00 00       	add	r0,r0
800034ae:	0a 5c       	eor	r12,r5
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	27 1c       	sub	r12,113
800034b4:	80 00       	ld.sh	r0,r0[0x0]
800034b6:	9f 84       	st.w	pc[0x20],r4
800034b8:	00 00       	add	r0,r0
800034ba:	0a 52       	eor	r2,r5
800034bc:	00 00       	add	r0,r0
800034be:	0a 88       	andn	r8,r5
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	5b d8       	cp.w	r8,-3

800034c4 <app_payload_tx_proc>:


static void app_payload_tx_proc(void  * payload)
{
800034c4:	eb cd 40 80 	pushm	r7,lr
800034c8:	1a 97       	mov	r7,sp
800034ca:	20 1d       	sub	sp,4
800034cc:	ef 4c ff fc 	st.w	r7[-4],r12
  log("R");
800034d0:	48 3c       	lddpc	r12,800034dc <app_payload_tx_proc+0x18>
800034d2:	f0 1f 00 04 	mcall	800034e0 <app_payload_tx_proc+0x1c>
  //
  //
  //set_payload_idle(payload);


}
800034d6:	2f fd       	sub	sp,-4
800034d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	27 28       	sub	r8,114
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	9f 84       	st.w	pc[0x20],r4

800034e4 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
800034e4:	eb cd 40 80 	pushm	r7,lr
800034e8:	1a 97       	mov	r7,sp
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
800034ea:	48 58       	lddpc	r8,800034fc <vApplicationIdleHook+0x18>
800034ec:	70 08       	ld.w	r8,r8[0x0]
800034ee:	f0 c9 ff ff 	sub	r9,r8,-1
800034f2:	48 38       	lddpc	r8,800034fc <vApplicationIdleHook+0x18>
800034f4:	91 09       	st.w	r8[0x0],r9
	
}
800034f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800034fa:	00 00       	add	r0,r0
800034fc:	00 00       	add	r0,r0
800034fe:	0a 58       	eor	r8,r5

80003500 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003500:	eb cd 40 80 	pushm	r7,lr
80003504:	1a 97       	mov	r7,sp
80003506:	20 5d       	sub	sp,20
	U16 status = 0xff;
80003508:	e0 68 00 ff 	mov	r8,255
8000350c:	ef 58 ff fe 	st.h	r7[-2],r8
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80003510:	4b 58       	lddpc	r8,800035e4 <data_flash_init+0xe4>
80003512:	ee ca 00 14 	sub	r10,r7,20
80003516:	10 9b       	mov	r11,r8
80003518:	f6 e8 00 00 	ld.d	r8,r11[0]
8000351c:	f4 e9 00 00 	st.d	r10[0],r8
80003520:	f6 e8 00 08 	ld.d	r8,r11[8]
80003524:	f4 e9 00 08 	st.d	r10[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80003528:	30 4b       	mov	r11,4
8000352a:	4b 0c       	lddpc	r12,800035e8 <data_flash_init+0xe8>
8000352c:	f0 1f 00 30 	mcall	800035ec <data_flash_init+0xec>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80003530:	31 9c       	mov	r12,25
80003532:	f0 1f 00 30 	mcall	800035f0 <data_flash_init+0xf0>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80003536:	31 9c       	mov	r12,25
80003538:	f0 1f 00 2f 	mcall	800035f4 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
8000353c:	4a f8       	lddpc	r8,800035f8 <data_flash_init+0xf8>
8000353e:	fe 79 24 00 	mov	r9,-56320
80003542:	91 09       	st.w	r8[0x0],r9

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003544:	4a d8       	lddpc	r8,800035f8 <data_flash_init+0xf8>
80003546:	70 08       	ld.w	r8,r8[0x0]
80003548:	ee c9 00 14 	sub	r9,r7,20
8000354c:	12 9b       	mov	r11,r9
8000354e:	10 9c       	mov	r12,r8
80003550:	f0 1f 00 2b 	mcall	800035fc <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80003554:	4a 98       	lddpc	r8,800035f8 <data_flash_init+0xf8>
80003556:	70 08       	ld.w	r8,r8[0x0]
80003558:	30 09       	mov	r9,0
8000355a:	30 0a       	mov	r10,0
8000355c:	30 0b       	mov	r11,0
8000355e:	10 9c       	mov	r12,r8
80003560:	f0 1f 00 28 	mcall	80003600 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
80003564:	4a 58       	lddpc	r8,800035f8 <data_flash_init+0xf8>
80003566:	70 08       	ld.w	r8,r8[0x0]
80003568:	10 9c       	mov	r12,r8
8000356a:	f0 1f 00 27 	mcall	80003604 <data_flash_init+0x104>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
8000356e:	4a 38       	lddpc	r8,800035f8 <data_flash_init+0xf8>
80003570:	70 08       	ld.w	r8,r8[0x0]
80003572:	ee c9 00 14 	sub	r9,r7,20
80003576:	e0 6a 36 00 	mov	r10,13824
8000357a:	ea 1a 01 6e 	orh	r10,0x16e
8000357e:	12 9b       	mov	r11,r9
80003580:	10 9c       	mov	r12,r8
80003582:	f0 1f 00 22 	mcall	80003608 <data_flash_init+0x108>
80003586:	18 98       	mov	r8,r12
80003588:	58 08       	cp.w	r8,0
8000358a:	c0 50       	breq	80003594 <data_flash_init+0x94>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
8000358c:	4a 09       	lddpc	r9,8000360c <data_flash_init+0x10c>
8000358e:	30 28       	mov	r8,2
80003590:	b2 88       	st.b	r9[0x0],r8
		return;
80003592:	c2 68       	rjmp	800035de <data_flash_init+0xde>
	}

	if (data_flash_check_device_id() != TRUE)
80003594:	f0 1f 00 1f 	mcall	80003610 <data_flash_init+0x110>
80003598:	18 98       	mov	r8,r12
8000359a:	10 99       	mov	r9,r8
8000359c:	30 18       	mov	r8,1
8000359e:	f0 09 18 00 	cp.b	r9,r8
800035a2:	c0 50       	breq	800035ac <data_flash_init+0xac>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
800035a4:	49 a9       	lddpc	r9,8000360c <data_flash_init+0x10c>
800035a6:	30 38       	mov	r8,3
800035a8:	b2 88       	st.b	r9[0x0],r8
		return;
800035aa:	c1 a8       	rjmp	800035de <data_flash_init+0xde>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
800035ac:	30 09       	mov	r9,0
800035ae:	30 0a       	mov	r10,0
800035b0:	30 0b       	mov	r11,0
800035b2:	30 6c       	mov	r12,6
800035b4:	f0 1f 00 18 	mcall	80003614 <data_flash_init+0x114>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
800035b8:	30 09       	mov	r9,0
800035ba:	30 0a       	mov	r10,0
800035bc:	30 0b       	mov	r11,0
800035be:	30 1c       	mov	r12,1
800035c0:	f0 1f 00 15 	mcall	80003614 <data_flash_init+0x114>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
800035c4:	30 09       	mov	r9,0
800035c6:	30 0a       	mov	r10,0
800035c8:	30 0b       	mov	r11,0
800035ca:	30 5c       	mov	r12,5
800035cc:	f0 1f 00 12 	mcall	80003614 <data_flash_init+0x114>
800035d0:	18 98       	mov	r8,r12
800035d2:	5c 88       	casts.h	r8
800035d4:	ef 58 ff fe 	st.h	r7[-2],r8
	// after 5 seconds, perform a test on write and read back 0x5A5A to address 0x00001002
	// then read address 0x00001002 every 5s and report to radio with failure

	//test_data_flash(FALSE);
	//create_data_flash_test_task();
	create_data_list();
800035d8:	f0 1f 00 10 	mcall	80003618 <data_flash_init+0x118>

	return;
800035dc:	d7 03       	nop
}
800035de:	2f bd       	sub	sp,-20
800035e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800035e4:	80 01       	ld.sh	r1,r0[0x0]
800035e6:	04 04       	add	r4,r2
800035e8:	80 01       	ld.sh	r1,r0[0x0]
800035ea:	04 14       	sub	r4,r2
800035ec:	80 00       	ld.sh	r0,r0[0x0]
800035ee:	a5 80       	lsr	r0,0x4
800035f0:	80 00       	ld.sh	r0,r0[0x0]
800035f2:	a7 00       	ld.d	r0,r3
800035f4:	80 00       	ld.sh	r0,r0[0x0]
800035f6:	a7 50       	asr	r0,0x7
800035f8:	00 00       	add	r0,r0
800035fa:	0d 94       	ld.ub	r4,r6[0x1]
800035fc:	80 00       	ld.sh	r0,r0[0x0]
800035fe:	70 e2       	ld.w	r2,r8[0x38]
80003600:	80 00       	ld.sh	r0,r0[0x0]
80003602:	71 76       	ld.w	r6,r8[0x5c]
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	74 8c       	ld.w	r12,r10[0x20]
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	73 0c       	ld.w	r12,r9[0x40]
8000360c:	00 00       	add	r0,r0
8000360e:	0a 70       	tst	r0,r5
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	36 1c       	mov	r12,97
80003614:	80 00       	ld.sh	r0,r0[0x0]
80003616:	36 dc       	mov	r12,109
80003618:	80 00       	ld.sh	r0,r0[0x0]
8000361a:	39 b4       	mov	r4,-101

8000361c <data_flash_check_device_id>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
8000361c:	eb cd 40 80 	pushm	r7,lr
80003620:	1a 97       	mov	r7,sp
80003622:	20 1d       	sub	sp,4
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80003624:	4a 79       	lddpc	r9,800036c0 <data_flash_check_device_id+0xa4>
80003626:	ee c8 00 04 	sub	r8,r7,4
8000362a:	30 4a       	mov	r10,4
8000362c:	12 9b       	mov	r11,r9
8000362e:	10 9c       	mov	r12,r8
80003630:	f0 1f 00 25 	mcall	800036c4 <data_flash_check_device_id+0xa8>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80003634:	4a 58       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
80003636:	70 08       	ld.w	r8,r8[0x0]
80003638:	30 0b       	mov	r11,0
8000363a:	10 9c       	mov	r12,r8
8000363c:	f0 1f 00 24 	mcall	800036cc <data_flash_check_device_id+0xb0>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80003640:	4a 28       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
80003642:	70 08       	ld.w	r8,r8[0x0]
80003644:	e0 6b 00 9f 	mov	r11,159
80003648:	10 9c       	mov	r12,r8
8000364a:	f0 1f 00 22 	mcall	800036d0 <data_flash_check_device_id+0xb4>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
8000364e:	49 f8       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
80003650:	70 08       	ld.w	r8,r8[0x0]
80003652:	e0 6b 00 ff 	mov	r11,255
80003656:	10 9c       	mov	r12,r8
80003658:	f0 1f 00 1e 	mcall	800036d0 <data_flash_check_device_id+0xb4>
	spi_read(spi, &manufacturer_device_id[0]);
8000365c:	49 b8       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
8000365e:	70 08       	ld.w	r8,r8[0x0]
80003660:	ee c9 00 04 	sub	r9,r7,4
80003664:	12 9b       	mov	r11,r9
80003666:	10 9c       	mov	r12,r8
80003668:	f0 1f 00 1b 	mcall	800036d4 <data_flash_check_device_id+0xb8>
	spi_write_dummy();
8000366c:	49 78       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
8000366e:	70 08       	ld.w	r8,r8[0x0]
80003670:	e0 6b 00 ff 	mov	r11,255
80003674:	10 9c       	mov	r12,r8
80003676:	f0 1f 00 17 	mcall	800036d0 <data_flash_check_device_id+0xb4>
	spi_read(spi, &manufacturer_device_id[1]);
8000367a:	49 48       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
8000367c:	70 08       	ld.w	r8,r8[0x0]
8000367e:	ee c9 00 04 	sub	r9,r7,4
80003682:	2f e9       	sub	r9,-2
80003684:	12 9b       	mov	r11,r9
80003686:	10 9c       	mov	r12,r8
80003688:	f0 1f 00 13 	mcall	800036d4 <data_flash_check_device_id+0xb8>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000368c:	48 f8       	lddpc	r8,800036c8 <data_flash_check_device_id+0xac>
8000368e:	70 08       	ld.w	r8,r8[0x0]
80003690:	30 0b       	mov	r11,0
80003692:	10 9c       	mov	r12,r8
80003694:	f0 1f 00 11 	mcall	800036d8 <data_flash_check_device_id+0xbc>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80003698:	ef 09 ff fc 	ld.sh	r9,r7[-4]
8000369c:	31 f8       	mov	r8,31
8000369e:	f0 09 19 00 	cp.h	r9,r8
800036a2:	c0 71       	brne	800036b0 <data_flash_check_device_id+0x94>
800036a4:	ef 09 ff fe 	ld.sh	r9,r7[-2]
800036a8:	34 88       	mov	r8,72
800036aa:	f0 09 19 00 	cp.h	r9,r8
800036ae:	c0 30       	breq	800036b4 <data_flash_check_device_id+0x98>
    {
    	return FALSE;
800036b0:	30 08       	mov	r8,0
800036b2:	c0 28       	rjmp	800036b6 <data_flash_check_device_id+0x9a>
    }

    return TRUE;
800036b4:	30 18       	mov	r8,1
}
800036b6:	10 9c       	mov	r12,r8
800036b8:	2f fd       	sub	sp,-4
800036ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800036be:	00 00       	add	r0,r0
800036c0:	80 01       	ld.sh	r1,r0[0x0]
800036c2:	04 00       	add	r0,r2
800036c4:	80 00       	ld.sh	r0,r0[0x0]
800036c6:	ac 76       	st.h	r6[0xe],r6
800036c8:	00 00       	add	r0,r0
800036ca:	0d 94       	ld.ub	r4,r6[0x1]
800036cc:	80 00       	ld.sh	r0,r0[0x0]
800036ce:	72 0a       	ld.w	r10,r9[0x0]
800036d0:	80 00       	ld.sh	r0,r0[0x0]
800036d2:	74 a6       	ld.w	r6,r10[0x28]
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	74 fe       	ld.w	lr,r10[0x3c]
800036d8:	80 00       	ld.sh	r0,r0[0x0]
800036da:	72 a2       	ld.w	r2,r9[0x28]

800036dc <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800036dc:	eb cd 40 80 	pushm	r7,lr
800036e0:	1a 97       	mov	r7,sp
800036e2:	20 7d       	sub	sp,28
800036e4:	ef 4b ff ec 	st.w	r7[-20],r11
800036e8:	ef 4a ff e8 	st.w	r7[-24],r10
800036ec:	12 98       	mov	r8,r9
800036ee:	18 99       	mov	r9,r12
800036f0:	ef 59 ff f0 	st.h	r7[-16],r9
800036f4:	ef 58 ff e4 	st.h	r7[-28],r8
	U16 status = 1;
800036f8:	30 18       	mov	r8,1
800036fa:	ef 58 ff fc 	st.h	r7[-4],r8
	U16 i = 0;
800036fe:	30 08       	mov	r8,0
80003700:	ef 58 ff fe 	st.h	r7[-2],r8

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80003704:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003708:	e6 18 00 ff 	andh	r8,0xff,COH
8000370c:	b1 88       	lsr	r8,0x10
8000370e:	5c 88       	casts.h	r8
80003710:	ef 58 ff fa 	st.h	r7[-6],r8
	addr[1] = (address & 0x0000ff00) >> 8;
80003714:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003718:	e2 18 ff 00 	andl	r8,0xff00,COH
8000371c:	a9 88       	lsr	r8,0x8
8000371e:	5c 88       	casts.h	r8
80003720:	ef 58 ff f8 	st.h	r7[-8],r8
	addr[0] = (address & 0x000000ff);
80003724:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003728:	5c 88       	casts.h	r8
8000372a:	5c 88       	casts.h	r8
8000372c:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003730:	ef 58 ff f6 	st.h	r7[-10],r8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80003734:	fe f8 02 6c 	ld.w	r8,pc[620]
80003738:	70 08       	ld.w	r8,r8[0x0]
8000373a:	30 0b       	mov	r11,0
8000373c:	10 9c       	mov	r12,r8
8000373e:	f0 1f 00 9a 	mcall	800039a4 <send_flash_command+0x2c8>

    switch (command)
80003742:	ef 18 ff f0 	ld.uh	r8,r7[-16]
80003746:	58 58       	cp.w	r8,5
80003748:	c2 30       	breq	8000378e <send_flash_command+0xb2>
8000374a:	e0 89 00 10 	brgt	8000376a <send_flash_command+0x8e>
8000374e:	58 28       	cp.w	r8,2
80003750:	c7 20       	breq	80003834 <send_flash_command+0x158>
80003752:	e0 89 00 06 	brgt	8000375e <send_flash_command+0x82>
80003756:	58 18       	cp.w	r8,1
80003758:	e0 80 01 0a 	breq	8000396c <send_flash_command+0x290>
8000375c:	c1 69       	rjmp	80003988 <send_flash_command+0x2ac>
8000375e:	58 38       	cp.w	r8,3
80003760:	e0 80 00 b5 	breq	800038ca <send_flash_command+0x1ee>
80003764:	58 48       	cp.w	r8,4
80003766:	c2 e0       	breq	800037c2 <send_flash_command+0xe6>
80003768:	c1 09       	rjmp	80003988 <send_flash_command+0x2ac>
8000376a:	e0 48 00 52 	cp.w	r8,82
8000376e:	c3 30       	breq	800037d4 <send_flash_command+0xf8>
80003770:	e0 89 00 08 	brgt	80003780 <send_flash_command+0xa4>
80003774:	58 68       	cp.w	r8,6
80003776:	c2 60       	breq	800037c2 <send_flash_command+0xe6>
80003778:	e0 48 00 20 	cp.w	r8,32
8000377c:	c2 c0       	breq	800037d4 <send_flash_command+0xf8>
8000377e:	c0 59       	rjmp	80003988 <send_flash_command+0x2ac>
80003780:	e0 48 00 60 	cp.w	r8,96
80003784:	c4 f0       	breq	80003822 <send_flash_command+0x146>
80003786:	e0 48 00 d8 	cp.w	r8,216
8000378a:	c2 50       	breq	800037d4 <send_flash_command+0xf8>
8000378c:	cf e8       	rjmp	80003988 <send_flash_command+0x2ac>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
8000378e:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003792:	fe f8 02 0e 	ld.w	r8,pc[526]
80003796:	70 08       	ld.w	r8,r8[0x0]
80003798:	12 9b       	mov	r11,r9
8000379a:	10 9c       	mov	r12,r8
8000379c:	f0 1f 00 83 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_dummy();
800037a0:	fe f8 02 00 	ld.w	r8,pc[512]
800037a4:	70 08       	ld.w	r8,r8[0x0]
800037a6:	e0 6b 00 ff 	mov	r11,255
800037aa:	10 9c       	mov	r12,r8
800037ac:	f0 1f 00 7f 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_read_byte(&status);
800037b0:	4f c8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800037b2:	70 08       	ld.w	r8,r8[0x0]
800037b4:	ee c9 00 04 	sub	r9,r7,4
800037b8:	12 9b       	mov	r11,r9
800037ba:	10 9c       	mov	r12,r8
800037bc:	f0 1f 00 7c 	mcall	800039ac <send_flash_command+0x2d0>
			break;
800037c0:	ce 48       	rjmp	80003988 <send_flash_command+0x2ac>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
800037c2:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800037c6:	4f 78       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800037c8:	70 08       	ld.w	r8,r8[0x0]
800037ca:	12 9b       	mov	r11,r9
800037cc:	10 9c       	mov	r12,r8
800037ce:	f0 1f 00 77 	mcall	800039a8 <send_flash_command+0x2cc>
			break;
800037d2:	cd b8       	rjmp	80003988 <send_flash_command+0x2ac>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800037d4:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800037d8:	4f 28       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800037da:	70 08       	ld.w	r8,r8[0x0]
800037dc:	12 9b       	mov	r11,r9
800037de:	10 9c       	mov	r12,r8
800037e0:	f0 1f 00 72 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
800037e4:	ef 08 ff fa 	ld.sh	r8,r7[-6]
800037e8:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800037ec:	4e d8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800037ee:	70 08       	ld.w	r8,r8[0x0]
800037f0:	12 9b       	mov	r11,r9
800037f2:	10 9c       	mov	r12,r8
800037f4:	f0 1f 00 6d 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
800037f8:	ef 08 ff f8 	ld.sh	r8,r7[-8]
800037fc:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003800:	4e 88       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003802:	70 08       	ld.w	r8,r8[0x0]
80003804:	12 9b       	mov	r11,r9
80003806:	10 9c       	mov	r12,r8
80003808:	f0 1f 00 68 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
8000380c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003810:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003814:	4e 38       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003816:	70 08       	ld.w	r8,r8[0x0]
80003818:	12 9b       	mov	r11,r9
8000381a:	10 9c       	mov	r12,r8
8000381c:	f0 1f 00 63 	mcall	800039a8 <send_flash_command+0x2cc>
			break;
80003820:	cb 48       	rjmp	80003988 <send_flash_command+0x2ac>
		case CHIP_ERASE:
			spi_write_byte(command);
80003822:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003826:	4d f8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003828:	70 08       	ld.w	r8,r8[0x0]
8000382a:	12 9b       	mov	r11,r9
8000382c:	10 9c       	mov	r12,r8
8000382e:	f0 1f 00 5f 	mcall	800039a8 <send_flash_command+0x2cc>
			break;
80003832:	ca b8       	rjmp	80003988 <send_flash_command+0x2ac>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80003834:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003838:	4d a8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
8000383a:	70 08       	ld.w	r8,r8[0x0]
8000383c:	12 9b       	mov	r11,r9
8000383e:	10 9c       	mov	r12,r8
80003840:	f0 1f 00 5a 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
80003844:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003848:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000384c:	4d 58       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
8000384e:	70 08       	ld.w	r8,r8[0x0]
80003850:	12 9b       	mov	r11,r9
80003852:	10 9c       	mov	r12,r8
80003854:	f0 1f 00 55 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
80003858:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000385c:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003860:	4d 08       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003862:	70 08       	ld.w	r8,r8[0x0]
80003864:	12 9b       	mov	r11,r9
80003866:	10 9c       	mov	r12,r8
80003868:	f0 1f 00 50 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
8000386c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003870:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003874:	4c b8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003876:	70 08       	ld.w	r8,r8[0x0]
80003878:	12 9b       	mov	r11,r9
8000387a:	10 9c       	mov	r12,r8
8000387c:	f0 1f 00 4b 	mcall	800039a8 <send_flash_command+0x2cc>
			for (i = 0; i < length; i++)
80003880:	30 08       	mov	r8,0
80003882:	ef 58 ff fe 	st.h	r7[-2],r8
80003886:	c1 a8       	rjmp	800038ba <send_flash_command+0x1de>
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80003888:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000388c:	11 88       	ld.ub	r8,r8[0x0]
8000388e:	ef 58 ff f4 	st.h	r7[-12],r8
				data_ptr++;
80003892:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003896:	2f f8       	sub	r8,-1
80003898:	ef 48 ff e8 	st.w	r7[-24],r8
				spi_write_byte(data_u16);
8000389c:	ef 08 ff f4 	ld.sh	r8,r7[-12]
800038a0:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038a4:	4b f8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800038a6:	70 08       	ld.w	r8,r8[0x0]
800038a8:	12 9b       	mov	r11,r9
800038aa:	10 9c       	mov	r12,r8
800038ac:	f0 1f 00 3f 	mcall	800039a8 <send_flash_command+0x2cc>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
800038b0:	ef 08 ff fe 	ld.sh	r8,r7[-2]
800038b4:	2f f8       	sub	r8,-1
800038b6:	ef 58 ff fe 	st.h	r7[-2],r8
800038ba:	ef 09 ff fe 	ld.sh	r9,r7[-2]
800038be:	ef 08 ff e4 	ld.sh	r8,r7[-28]
800038c2:	f0 09 19 00 	cp.h	r9,r8
800038c6:	ce 13       	brcs	80003888 <send_flash_command+0x1ac>
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
800038c8:	c6 08       	rjmp	80003988 <send_flash_command+0x2ac>
		case READ_ARRAY:
			spi_write_byte(command);
800038ca:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800038ce:	4b 58       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800038d0:	70 08       	ld.w	r8,r8[0x0]
800038d2:	12 9b       	mov	r11,r9
800038d4:	10 9c       	mov	r12,r8
800038d6:	f0 1f 00 35 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
800038da:	ef 08 ff fa 	ld.sh	r8,r7[-6]
800038de:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038e2:	4b 08       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800038e4:	70 08       	ld.w	r8,r8[0x0]
800038e6:	12 9b       	mov	r11,r9
800038e8:	10 9c       	mov	r12,r8
800038ea:	f0 1f 00 30 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
800038ee:	ef 08 ff f8 	ld.sh	r8,r7[-8]
800038f2:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038f6:	4a b8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
800038f8:	70 08       	ld.w	r8,r8[0x0]
800038fa:	12 9b       	mov	r11,r9
800038fc:	10 9c       	mov	r12,r8
800038fe:	f0 1f 00 2b 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
80003902:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003906:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000390a:	4a 68       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
8000390c:	70 08       	ld.w	r8,r8[0x0]
8000390e:	12 9b       	mov	r11,r9
80003910:	10 9c       	mov	r12,r8
80003912:	f0 1f 00 26 	mcall	800039a8 <send_flash_command+0x2cc>
			for (i = 0; i < length; i++)
80003916:	30 08       	mov	r8,0
80003918:	ef 58 ff fe 	st.h	r7[-2],r8
8000391c:	c2 08       	rjmp	8000395c <send_flash_command+0x280>
			{
				spi_write_dummy();
8000391e:	4a 18       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003920:	70 08       	ld.w	r8,r8[0x0]
80003922:	e0 6b 00 ff 	mov	r11,255
80003926:	10 9c       	mov	r12,r8
80003928:	f0 1f 00 20 	mcall	800039a8 <send_flash_command+0x2cc>
				spi_read_byte(&data_u16);
8000392c:	49 d8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
8000392e:	70 08       	ld.w	r8,r8[0x0]
80003930:	ee c9 00 0c 	sub	r9,r7,12
80003934:	12 9b       	mov	r11,r9
80003936:	10 9c       	mov	r12,r8
80003938:	f0 1f 00 1d 	mcall	800039ac <send_flash_command+0x2d0>
				*data_ptr = (U8)data_u16;
8000393c:	ef 08 ff f4 	ld.sh	r8,r7[-12]
80003940:	5c 58       	castu.b	r8
80003942:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003946:	b2 88       	st.b	r9[0x0],r8
				data_ptr++;
80003948:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000394c:	2f f8       	sub	r8,-1
8000394e:	ef 48 ff e8 	st.w	r7[-24],r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80003952:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003956:	2f f8       	sub	r8,-1
80003958:	ef 58 ff fe 	st.h	r7[-2],r8
8000395c:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003960:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80003964:	f0 09 19 00 	cp.h	r9,r8
80003968:	cd b3       	brcs	8000391e <send_flash_command+0x242>
				spi_write_dummy();
				spi_read_byte(&data_u16);
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
8000396a:	c0 f8       	rjmp	80003988 <send_flash_command+0x2ac>
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
8000396c:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003970:	48 c8       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
80003972:	70 08       	ld.w	r8,r8[0x0]
80003974:	12 9b       	mov	r11,r9
80003976:	10 9c       	mov	r12,r8
80003978:	f0 1f 00 0c 	mcall	800039a8 <send_flash_command+0x2cc>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
8000397c:	48 98       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
8000397e:	70 08       	ld.w	r8,r8[0x0]
80003980:	30 0b       	mov	r11,0
80003982:	10 9c       	mov	r12,r8
80003984:	f0 1f 00 09 	mcall	800039a8 <send_flash_command+0x2cc>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80003988:	48 68       	lddpc	r8,800039a0 <send_flash_command+0x2c4>
8000398a:	70 08       	ld.w	r8,r8[0x0]
8000398c:	30 0b       	mov	r11,0
8000398e:	10 9c       	mov	r12,r8
80003990:	f0 1f 00 08 	mcall	800039b0 <send_flash_command+0x2d4>

	return status;
80003994:	ef 08 ff fc 	ld.sh	r8,r7[-4]
}
80003998:	10 9c       	mov	r12,r8
8000399a:	2f 9d       	sub	sp,-28
8000399c:	e3 cd 80 80 	ldm	sp++,r7,pc
800039a0:	00 00       	add	r0,r0
800039a2:	0d 94       	ld.ub	r4,r6[0x1]
800039a4:	80 00       	ld.sh	r0,r0[0x0]
800039a6:	72 0a       	ld.w	r10,r9[0x0]
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	74 a6       	ld.w	r6,r10[0x28]
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	74 fe       	ld.w	lr,r10[0x3c]
800039b0:	80 00       	ld.sh	r0,r0[0x0]
800039b2:	72 a2       	ld.w	r2,r9[0x28]

800039b4 <create_data_list>:
* ----------  --------  ----------  --------------------------------------------
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
static Bool create_data_list(void)
{
800039b4:	eb cd 40 80 	pushm	r7,lr
800039b8:	1a 97       	mov	r7,sp
800039ba:	20 6d       	sub	sp,24
	df_status_t return_code = DF_OK;
800039bc:	30 08       	mov	r8,0
800039be:	ef 48 ff f4 	st.w	r7[-12],r8
	unsigned int i = 0;
800039c2:	30 08       	mov	r8,0
800039c4:	ef 48 ff f8 	st.w	r7[-8],r8
	unsigned int address =0x00000000;
800039c8:	30 08       	mov	r8,0
800039ca:	ef 48 ff fc 	st.w	r7[-4],r8
	char str[10];
	memset(str, 0x00, sizeof(str));
800039ce:	ee c8 00 18 	sub	r8,r7,24
800039d2:	30 aa       	mov	r10,10
800039d4:	30 0b       	mov	r11,0
800039d6:	10 9c       	mov	r12,r8
800039d8:	f0 1f 00 4a 	mcall	80003b00 <create_data_list+0x14c>
	
	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
800039dc:	ee c8 00 18 	sub	r8,r7,24
800039e0:	10 9a       	mov	r10,r8
800039e2:	30 7b       	mov	r11,7
800039e4:	30 0c       	mov	r12,0
800039e6:	f0 1f 00 48 	mcall	80003b04 <create_data_list+0x150>
800039ea:	18 98       	mov	r8,r12
800039ec:	ef 48 ff f4 	st.w	r7[-12],r8
	if(return_code == DF_OK)
800039f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800039f4:	58 08       	cp.w	r8,0
800039f6:	e0 81 00 7f 	brne	80003af4 <create_data_list+0x140>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)
800039fa:	ee c8 00 18 	sub	r8,r7,24
800039fe:	30 7a       	mov	r10,7
80003a00:	10 9b       	mov	r11,r8
80003a02:	4c 2c       	lddpc	r12,80003b08 <create_data_list+0x154>
80003a04:	f0 1f 00 42 	mcall	80003b0c <create_data_list+0x158>
80003a08:	18 98       	mov	r8,r12
80003a0a:	58 08       	cp.w	r8,0
80003a0c:	c4 40       	breq	80003a94 <create_data_list+0xe0>
		{
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)
80003a0e:	c1 d8       	rjmp	80003a48 <create_data_list+0x94>
			{
				address+=(i*65536);//64k*1024=65536bytes
80003a10:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a14:	b1 68       	lsl	r8,0x10
80003a16:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003a1a:	f2 08 00 08 	add	r8,r9,r8
80003a1e:	ef 48 ff fc 	st.w	r7[-4],r8
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80003a22:	30 3b       	mov	r11,3
80003a24:	ee fc ff fc 	ld.w	r12,r7[-4]
80003a28:	f0 1f 00 3a 	mcall	80003b10 <create_data_list+0x15c>
80003a2c:	18 98       	mov	r8,r12
80003a2e:	ef 48 ff f4 	st.w	r7[-12],r8
				if(return_code != DF_ERASE_COMPLETED)
80003a32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003a36:	58 58       	cp.w	r8,5
80003a38:	c0 30       	breq	80003a3e <create_data_list+0x8a>
				{
					return FALSE;
80003a3a:	30 08       	mov	r8,0
80003a3c:	c5 d8       	rjmp	80003af6 <create_data_list+0x142>
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)
		{
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)
80003a3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a42:	2f f8       	sub	r8,-1
80003a44:	ef 48 ff f8 	st.w	r7[-8],r8
80003a48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a4c:	58 78       	cp.w	r8,7
80003a4e:	fe 98 ff e1 	brls	80003a10 <create_data_list+0x5c>
				{
					return FALSE;
				}
			}
			//set label
			return_code = data_flash_write_page(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80003a52:	30 7a       	mov	r10,7
80003a54:	30 0b       	mov	r11,0
80003a56:	4a dc       	lddpc	r12,80003b08 <create_data_list+0x154>
80003a58:	f0 1f 00 2f 	mcall	80003b14 <create_data_list+0x160>
80003a5c:	18 98       	mov	r8,r12
80003a5e:	ef 48 ff f4 	st.w	r7[-12],r8
			//set voice_numbers
			memset(str, 0x00, sizeof(str));
80003a62:	ee c8 00 18 	sub	r8,r7,24
80003a66:	30 aa       	mov	r10,10
80003a68:	30 0b       	mov	r11,0
80003a6a:	10 9c       	mov	r12,r8
80003a6c:	f0 1f 00 25 	mcall	80003b00 <create_data_list+0x14c>
			return_code = data_flash_write_page(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80003a70:	ee c8 00 18 	sub	r8,r7,24
80003a74:	30 2a       	mov	r10,2
80003a76:	30 ab       	mov	r11,10
80003a78:	10 9c       	mov	r12,r8
80003a7a:	f0 1f 00 27 	mcall	80003b14 <create_data_list+0x160>
80003a7e:	18 98       	mov	r8,r12
80003a80:	ef 48 ff f4 	st.w	r7[-12],r8
			if(return_code != DF_WRITE_COMPLETED)
80003a84:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003a88:	58 78       	cp.w	r8,7
80003a8a:	c0 30       	breq	80003a90 <create_data_list+0xdc>
			{
				return FALSE;
80003a8c:	30 08       	mov	r8,0
80003a8e:	c3 48       	rjmp	80003af6 <create_data_list+0x142>
			}		
			return TRUE;		
80003a90:	30 18       	mov	r8,1
80003a92:	c3 28       	rjmp	80003af6 <create_data_list+0x142>
						
		}
		else//success
		{
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &voice_numbers);
80003a94:	4a 18       	lddpc	r8,80003b18 <create_data_list+0x164>
80003a96:	10 9a       	mov	r10,r8
80003a98:	30 2b       	mov	r11,2
80003a9a:	30 ac       	mov	r12,10
80003a9c:	f0 1f 00 1a 	mcall	80003b04 <create_data_list+0x150>
80003aa0:	18 98       	mov	r8,r12
80003aa2:	ef 48 ff f4 	st.w	r7[-12],r8
			if(return_code == DF_OK) 
80003aa6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003aaa:	58 08       	cp.w	r8,0
80003aac:	c2 21       	brne	80003af0 <create_data_list+0x13c>
			{	
				if(voice_numbers > 9000){//reset list numbers
80003aae:	49 b8       	lddpc	r8,80003b18 <create_data_list+0x164>
80003ab0:	90 09       	ld.sh	r9,r8[0x0]
80003ab2:	e0 68 23 28 	mov	r8,9000
80003ab6:	f0 09 19 00 	cp.h	r9,r8
80003aba:	e0 88 00 19 	brls	80003aec <create_data_list+0x138>
					memset(str, 0x00, sizeof(str));
80003abe:	ee c8 00 18 	sub	r8,r7,24
80003ac2:	30 aa       	mov	r10,10
80003ac4:	30 0b       	mov	r11,0
80003ac6:	10 9c       	mov	r12,r8
80003ac8:	f0 1f 00 0e 	mcall	80003b00 <create_data_list+0x14c>
					return_code = data_flash_write_page(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80003acc:	ee c8 00 18 	sub	r8,r7,24
80003ad0:	30 2a       	mov	r10,2
80003ad2:	30 ab       	mov	r11,10
80003ad4:	10 9c       	mov	r12,r8
80003ad6:	f0 1f 00 10 	mcall	80003b14 <create_data_list+0x160>
80003ada:	18 98       	mov	r8,r12
80003adc:	ef 48 ff f4 	st.w	r7[-12],r8
					if(return_code != DF_WRITE_COMPLETED)
80003ae0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003ae4:	58 78       	cp.w	r8,7
80003ae6:	c0 30       	breq	80003aec <create_data_list+0x138>
					{
						return FALSE;
80003ae8:	30 08       	mov	r8,0
80003aea:	c0 68       	rjmp	80003af6 <create_data_list+0x142>
					}
				}
				
				return TRUE;
80003aec:	30 18       	mov	r8,1
80003aee:	c0 48       	rjmp	80003af6 <create_data_list+0x142>
			}
			else
				return FALSE;
80003af0:	30 08       	mov	r8,0
80003af2:	c0 28       	rjmp	80003af6 <create_data_list+0x142>
		}
	}
	return FALSE;
80003af4:	30 08       	mov	r8,0

}
80003af6:	10 9c       	mov	r12,r8
80003af8:	2f ad       	sub	sp,-24
80003afa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003afe:	00 00       	add	r0,r0
80003b00:	80 00       	ld.sh	r0,r0[0x0]
80003b02:	ad be       	sbr	lr,0xd
80003b04:	80 00       	ld.sh	r0,r0[0x0]
80003b06:	3d 14       	mov	r4,-47
80003b08:	00 00       	add	r0,r0
80003b0a:	04 f4       	st.b	--r2,r4
80003b0c:	80 00       	ld.sh	r0,r0[0x0]
80003b0e:	ac 50       	st.h	r6[0xa],r0
80003b10:	80 00       	ld.sh	r0,r0[0x0]
80003b12:	3b 1c       	mov	r12,-79
80003b14:	80 00       	ld.sh	r0,r0[0x0]
80003b16:	3c 1c       	mov	r12,-63
80003b18:	00 00       	add	r0,r0
80003b1a:	0a 72       	tst	r2,r5

80003b1c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80003b1c:	eb cd 40 80 	pushm	r7,lr
80003b20:	1a 97       	mov	r7,sp
80003b22:	20 5d       	sub	sp,20
80003b24:	ef 4c ff f0 	st.w	r7[-16],r12
80003b28:	ef 4b ff ec 	st.w	r7[-20],r11
	U16 status = 1;
80003b2c:	30 18       	mov	r8,1
80003b2e:	ef 58 ff f4 	st.h	r7[-12],r8
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
80003b32:	30 48       	mov	r8,4
80003b34:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 count = 0; /* to monitor erase time consumption */
80003b38:	30 08       	mov	r8,0
80003b3a:	ef 58 ff fe 	st.h	r7[-2],r8

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80003b3e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b42:	e0 69 ff fe 	mov	r9,65534
80003b46:	ea 19 00 7f 	orh	r9,0x7f
80003b4a:	12 38       	cp.w	r8,r9
80003b4c:	e0 88 00 04 	brls	80003b54 <data_flash_erase_block+0x38>
	{
		return DF_INVALID_PARAM;
80003b50:	30 18       	mov	r8,1
80003b52:	c5 f8       	rjmp	80003c10 <data_flash_erase_block+0xf4>
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80003b54:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003b58:	58 18       	cp.w	r8,1
80003b5a:	c0 51       	brne	80003b64 <data_flash_erase_block+0x48>
		erase_commond = BLOCK_ERASE_4KB;
80003b5c:	32 08       	mov	r8,32
80003b5e:	ef 58 ff f6 	st.h	r7[-10],r8
80003b62:	c0 d8       	rjmp	80003b7c <data_flash_erase_block+0x60>
	else if (block_size == DF_BLOCK_32KB)
80003b64:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003b68:	58 28       	cp.w	r8,2
80003b6a:	c0 51       	brne	80003b74 <data_flash_erase_block+0x58>
		erase_commond = BLOCK_ERASE_32KB;
80003b6c:	35 28       	mov	r8,82
80003b6e:	ef 58 ff f6 	st.h	r7[-10],r8
80003b72:	c0 58       	rjmp	80003b7c <data_flash_erase_block+0x60>
	else /* (block_size == DF_BLOCK_64KB) */
		erase_commond = BLOCK_ERASE_64KB;
80003b74:	e0 68 00 d8 	mov	r8,216
80003b78:	ef 58 ff f6 	st.h	r7[-10],r8

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003b7c:	30 09       	mov	r9,0
80003b7e:	30 0a       	mov	r10,0
80003b80:	30 0b       	mov	r11,0
80003b82:	30 5c       	mov	r12,5
80003b84:	f0 1f 00 25 	mcall	80003c18 <data_flash_erase_block+0xfc>
80003b88:	18 98       	mov	r8,r12
80003b8a:	5c 88       	casts.h	r8
80003b8c:	ef 58 ff f4 	st.h	r7[-12],r8
	if ((status & STATUS_BUSY) != 0)
80003b90:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80003b94:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003b98:	5c 58       	castu.b	r8
80003b9a:	c0 30       	breq	80003ba0 <data_flash_erase_block+0x84>
	{
		return DF_DEVICE_BUSY;
80003b9c:	30 28       	mov	r8,2
80003b9e:	c3 98       	rjmp	80003c10 <data_flash_erase_block+0xf4>
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80003ba0:	30 09       	mov	r9,0
80003ba2:	30 0a       	mov	r10,0
80003ba4:	30 0b       	mov	r11,0
80003ba6:	30 6c       	mov	r12,6
80003ba8:	f0 1f 00 1c 	mcall	80003c18 <data_flash_erase_block+0xfc>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80003bac:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80003bb0:	30 09       	mov	r9,0
80003bb2:	30 0a       	mov	r10,0
80003bb4:	ee fb ff f0 	ld.w	r11,r7[-16]
80003bb8:	10 9c       	mov	r12,r8
80003bba:	f0 1f 00 18 	mcall	80003c18 <data_flash_erase_block+0xfc>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003bbe:	30 09       	mov	r9,0
80003bc0:	30 0a       	mov	r10,0
80003bc2:	30 0b       	mov	r11,0
80003bc4:	30 5c       	mov	r12,5
80003bc6:	f0 1f 00 15 	mcall	80003c18 <data_flash_erase_block+0xfc>
80003bca:	18 98       	mov	r8,r12
80003bcc:	5c 88       	casts.h	r8
80003bce:	ef 58 ff f4 	st.h	r7[-12],r8
		count++;
80003bd2:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003bd6:	2f f8       	sub	r8,-1
80003bd8:	ef 58 ff fe 	st.h	r7[-2],r8
	} while((status & STATUS_BUSY) != 0);
80003bdc:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80003be0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003be4:	5c 58       	castu.b	r8
80003be6:	ce c1       	brne	80003bbe <data_flash_erase_block+0xa2>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80003be8:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80003bec:	e2 18 00 20 	andl	r8,0x20,COH
80003bf0:	c0 50       	breq	80003bfa <data_flash_erase_block+0xde>
	{
		return_code = DF_ERASE_FAIL;
80003bf2:	30 48       	mov	r8,4
80003bf4:	ef 48 ff f8 	st.w	r7[-8],r8
80003bf8:	c0 48       	rjmp	80003c00 <data_flash_erase_block+0xe4>
	}
#endif
	else
	{
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
80003bfa:	30 58       	mov	r8,5
80003bfc:	ef 48 ff f8 	st.w	r7[-8],r8
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80003c00:	30 09       	mov	r9,0
80003c02:	30 0a       	mov	r10,0
80003c04:	30 0b       	mov	r11,0
80003c06:	30 4c       	mov	r12,4
80003c08:	f0 1f 00 04 	mcall	80003c18 <data_flash_erase_block+0xfc>

	return return_code;
80003c0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003c10:	10 9c       	mov	r12,r8
80003c12:	2f bd       	sub	sp,-20
80003c14:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c18:	80 00       	ld.sh	r0,r0[0x0]
80003c1a:	36 dc       	mov	r12,109

80003c1c <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80003c1c:	eb cd 40 80 	pushm	r7,lr
80003c20:	1a 97       	mov	r7,sp
80003c22:	20 6d       	sub	sp,24
80003c24:	ef 4c ff f0 	st.w	r7[-16],r12
80003c28:	ef 4b ff ec 	st.w	r7[-20],r11
80003c2c:	14 98       	mov	r8,r10
80003c2e:	ef 58 ff e8 	st.h	r7[-24],r8
	U16 status = 1;
80003c32:	30 18       	mov	r8,1
80003c34:	ef 58 ff f6 	st.h	r7[-10],r8
	df_status_t return_code = DF_WRITE_FAIL;
80003c38:	30 68       	mov	r8,6
80003c3a:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 count = 0; /* to monitor write time consumption */
80003c3e:	30 08       	mov	r8,0
80003c40:	ef 58 ff fe 	st.h	r7[-2],r8

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80003c44:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c48:	58 08       	cp.w	r8,0
80003c4a:	c1 20       	breq	80003c6e <data_flash_write_page+0x52>
80003c4c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003c50:	e0 69 ff fe 	mov	r9,65534
80003c54:	ea 19 00 7f 	orh	r9,0x7f
80003c58:	12 38       	cp.w	r8,r9
80003c5a:	e0 8b 00 0a 	brhi	80003c6e <data_flash_write_page+0x52>
80003c5e:	ef 09 ff e8 	ld.sh	r9,r7[-24]
80003c62:	e0 68 01 00 	mov	r8,256
80003c66:	f0 09 19 00 	cp.h	r9,r8
80003c6a:	e0 88 00 04 	brls	80003c72 <data_flash_write_page+0x56>
	{
		return DF_INVALID_PARAM;
80003c6e:	30 18       	mov	r8,1
80003c70:	c4 c8       	rjmp	80003d08 <data_flash_write_page+0xec>
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003c72:	30 09       	mov	r9,0
80003c74:	30 0a       	mov	r10,0
80003c76:	30 0b       	mov	r11,0
80003c78:	30 5c       	mov	r12,5
80003c7a:	f0 1f 00 26 	mcall	80003d10 <data_flash_write_page+0xf4>
80003c7e:	18 98       	mov	r8,r12
80003c80:	5c 88       	casts.h	r8
80003c82:	ef 58 ff f6 	st.h	r7[-10],r8
	if ((status & STATUS_BUSY) != 0)
80003c86:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80003c8a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c8e:	5c 58       	castu.b	r8
80003c90:	c0 30       	breq	80003c96 <data_flash_write_page+0x7a>
	{
		return DF_DEVICE_BUSY;
80003c92:	30 28       	mov	r8,2
80003c94:	c3 a8       	rjmp	80003d08 <data_flash_write_page+0xec>
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80003c96:	30 09       	mov	r9,0
80003c98:	30 0a       	mov	r10,0
80003c9a:	30 0b       	mov	r11,0
80003c9c:	30 6c       	mov	r12,6
80003c9e:	f0 1f 00 1d 	mcall	80003d10 <data_flash_write_page+0xf4>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80003ca2:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80003ca6:	10 99       	mov	r9,r8
80003ca8:	ee fa ff f0 	ld.w	r10,r7[-16]
80003cac:	ee fb ff ec 	ld.w	r11,r7[-20]
80003cb0:	30 2c       	mov	r12,2
80003cb2:	f0 1f 00 18 	mcall	80003d10 <data_flash_write_page+0xf4>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003cb6:	30 09       	mov	r9,0
80003cb8:	30 0a       	mov	r10,0
80003cba:	30 0b       	mov	r11,0
80003cbc:	30 5c       	mov	r12,5
80003cbe:	f0 1f 00 15 	mcall	80003d10 <data_flash_write_page+0xf4>
80003cc2:	18 98       	mov	r8,r12
80003cc4:	5c 88       	casts.h	r8
80003cc6:	ef 58 ff f6 	st.h	r7[-10],r8
		count++;
80003cca:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003cce:	2f f8       	sub	r8,-1
80003cd0:	ef 58 ff fe 	st.h	r7[-2],r8
	} while((status & STATUS_BUSY) != 0);
80003cd4:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80003cd8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003cdc:	5c 58       	castu.b	r8
80003cde:	ce c1       	brne	80003cb6 <data_flash_write_page+0x9a>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80003ce0:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80003ce4:	e2 18 00 20 	andl	r8,0x20,COH
80003ce8:	c0 50       	breq	80003cf2 <data_flash_write_page+0xd6>
	{
		return_code = DF_WRITE_FAIL;
80003cea:	30 68       	mov	r8,6
80003cec:	ef 48 ff f8 	st.w	r7[-8],r8
80003cf0:	c0 48       	rjmp	80003cf8 <data_flash_write_page+0xdc>
	}
#endif
	else
	{
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
80003cf2:	30 78       	mov	r8,7
80003cf4:	ef 48 ff f8 	st.w	r7[-8],r8
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80003cf8:	30 09       	mov	r9,0
80003cfa:	30 0a       	mov	r10,0
80003cfc:	30 0b       	mov	r11,0
80003cfe:	30 4c       	mov	r12,4
80003d00:	f0 1f 00 04 	mcall	80003d10 <data_flash_write_page+0xf4>

	return return_code;
80003d04:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003d08:	10 9c       	mov	r12,r8
80003d0a:	2f ad       	sub	sp,-24
80003d0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d10:	80 00       	ld.sh	r0,r0[0x0]
80003d12:	36 dc       	mov	r12,109

80003d14 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80003d14:	eb cd 40 80 	pushm	r7,lr
80003d18:	1a 97       	mov	r7,sp
80003d1a:	20 3d       	sub	sp,12
80003d1c:	ef 4c ff fc 	st.w	r7[-4],r12
80003d20:	16 98       	mov	r8,r11
80003d22:	ef 4a ff f4 	st.w	r7[-12],r10
80003d26:	ef 58 ff f8 	st.h	r7[-8],r8
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80003d2a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003d2e:	58 08       	cp.w	r8,0
80003d30:	c1 20       	breq	80003d54 <data_flash_read_block+0x40>
80003d32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d36:	e0 69 ff fe 	mov	r9,65534
80003d3a:	ea 19 00 7f 	orh	r9,0x7f
80003d3e:	12 38       	cp.w	r8,r9
80003d40:	e0 8b 00 0a 	brhi	80003d54 <data_flash_read_block+0x40>
80003d44:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80003d48:	e0 68 10 00 	mov	r8,4096
80003d4c:	f0 09 19 00 	cp.h	r9,r8
80003d50:	e0 88 00 04 	brls	80003d58 <data_flash_read_block+0x44>
	{
		return DF_INVALID_PARAM;
80003d54:	30 18       	mov	r8,1
80003d56:	c0 c8       	rjmp	80003d6e <data_flash_read_block+0x5a>
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80003d58:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003d5c:	10 99       	mov	r9,r8
80003d5e:	ee fa ff f4 	ld.w	r10,r7[-12]
80003d62:	ee fb ff fc 	ld.w	r11,r7[-4]
80003d66:	30 3c       	mov	r12,3
80003d68:	f0 1f 00 04 	mcall	80003d78 <data_flash_read_block+0x64>

	return DF_OK;
80003d6c:	30 08       	mov	r8,0
}
80003d6e:	10 9c       	mov	r12,r8
80003d70:	2f dd       	sub	sp,-12
80003d72:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d76:	00 00       	add	r0,r0
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	36 dc       	mov	r12,109

80003d7c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003d7c:	eb cd 40 80 	pushm	r7,lr
80003d80:	1a 97       	mov	r7,sp
80003d82:	20 2d       	sub	sp,8
80003d84:	18 98       	mov	r8,r12
80003d86:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 Burst_ID = 0;
80003d8a:	30 08       	mov	r8,0
80003d8c:	ef 68 ff ff 	st.b	r7[-1],r8
	
	switch(vf_sn)
80003d90:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003d94:	20 18       	sub	r8,1
80003d96:	59 18       	cp.w	r8,17
80003d98:	e0 8b 00 23 	brhi	80003dde <CalculateBurst+0x62>
80003d9c:	49 59       	lddpc	r9,80003df0 <CalculateBurst+0x74>
80003d9e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	{
		case 0x01:
		case 0x02:
		case 0x03:
		
			Burst_ID = 0x0A;
80003da2:	30 a8       	mov	r8,10
80003da4:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_A;
80003da8:	30 48       	mov	r8,4
80003daa:	c1 e8       	rjmp	80003de6 <CalculateBurst+0x6a>
		
		case 0x04:
		case 0x05:
		case 0x06:
		
			Burst_ID = 0x0B;
80003dac:	30 b8       	mov	r8,11
80003dae:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_B;
80003db2:	30 58       	mov	r8,5
80003db4:	c1 98       	rjmp	80003de6 <CalculateBurst+0x6a>
		
		case 0x07:
		case 0x08:
		case 0x09:
		
			Burst_ID = 0x0C;
80003db6:	30 c8       	mov	r8,12
80003db8:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_C;
80003dbc:	30 68       	mov	r8,6
80003dbe:	c1 48       	rjmp	80003de6 <CalculateBurst+0x6a>
		
		case 0x0A:
		case 0x0B:
		case 0x0C:
		
			Burst_ID = 0x0D;
80003dc0:	30 d8       	mov	r8,13
80003dc2:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_D;
80003dc6:	30 78       	mov	r8,7
80003dc8:	c0 f8       	rjmp	80003de6 <CalculateBurst+0x6a>
		
		case 0x0D:
		case 0x0E:
		case 0x0F:
		
			Burst_ID = 0x0E;
80003dca:	30 e8       	mov	r8,14
80003dcc:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_E;
80003dd0:	30 88       	mov	r8,8
80003dd2:	c0 a8       	rjmp	80003de6 <CalculateBurst+0x6a>
			
		case 0x10:
		case 0x11:
		case 0x12:
		
				Burst_ID = 0x0F;
80003dd4:	30 f8       	mov	r8,15
80003dd6:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_F;     
80003dda:	30 98       	mov	r8,9
80003ddc:	c0 58       	rjmp	80003de6 <CalculateBurst+0x6a>
		
		default:
		
			Burst_ID = 0x00;
80003dde:	30 08       	mov	r8,0
80003de0:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICE_WATING;
80003de4:	30 08       	mov	r8,0
		
	}
	
}
80003de6:	10 9c       	mov	r12,r8
80003de8:	2f ed       	sub	sp,-8
80003dea:	e3 cd 80 80 	ldm	sp++,r7,pc
80003dee:	00 00       	add	r0,r0
80003df0:	80 01       	ld.sh	r1,r0[0x0]
80003df2:	04 3c       	cp.w	r12,r2
80003df4:	50 41       	stdsp	sp[0x10],r1
80003df6:	59 4c       	cp.w	r12,20
80003df8:	4f 41       	lddpc	r1,80003fc8 <phy_init+0xcc>
80003dfa:	44 5f       	lddsp	pc,sp[0x114]
80003dfc:	52 58       	stdsp	sp[0x94],r8
	...

80003e00 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003e00:	eb cd 40 80 	pushm	r7,lr
80003e04:	1a 97       	mov	r7,sp
80003e06:	20 2d       	sub	sp,8
80003e08:	ef 4c ff f8 	st.w	r7[-8],r12
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003e0c:	49 08       	lddpc	r8,80003e4c <payload_rx_process+0x4c>
80003e0e:	70 08       	ld.w	r8,r8[0x0]
80003e10:	58 08       	cp.w	r8,0
80003e12:	c0 a1       	brne	80003e26 <payload_rx_process+0x26>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003e14:	30 4b       	mov	r11,4
80003e16:	30 5c       	mov	r12,5
80003e18:	f0 1f 00 0e 	mcall	80003e50 <payload_rx_process+0x50>
80003e1c:	18 99       	mov	r9,r12
80003e1e:	48 c8       	lddpc	r8,80003e4c <payload_rx_process+0x4c>
80003e20:	91 09       	st.w	r8[0x0],r9
80003e22:	c0 28       	rjmp	80003e26 <payload_rx_process+0x26>
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
		}
	
	}
80003e24:	d7 03       	nop
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003e26:	48 a8       	lddpc	r8,80003e4c <payload_rx_process+0x4c>
80003e28:	70 08       	ld.w	r8,r8[0x0]
80003e2a:	ee cb 00 04 	sub	r11,r7,4
80003e2e:	30 09       	mov	r9,0
80003e30:	3f fa       	mov	r10,-1
80003e32:	10 9c       	mov	r12,r8
80003e34:	f0 1f 00 08 	mcall	80003e54 <payload_rx_process+0x54>
80003e38:	18 98       	mov	r8,r12
80003e3a:	58 18       	cp.w	r8,1
80003e3c:	cf 41       	brne	80003e24 <payload_rx_process+0x24>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003e3e:	48 78       	lddpc	r8,80003e58 <payload_rx_process+0x58>
80003e40:	70 08       	ld.w	r8,r8[0x0]
80003e42:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e46:	12 9c       	mov	r12,r9
80003e48:	5d 18       	icall	r8
		}
	
	}
80003e4a:	ce eb       	rjmp	80003e26 <payload_rx_process+0x26>
80003e4c:	00 00       	add	r0,r0
80003e4e:	0a 90       	mov	r0,r5
80003e50:	80 00       	ld.sh	r0,r0[0x0]
80003e52:	85 40       	st.w	r2[0x10],r0
80003e54:	80 00       	ld.sh	r0,r0[0x0]
80003e56:	88 64       	ld.sh	r4,r4[0xc]
80003e58:	00 00       	add	r0,r0
80003e5a:	0a 74       	tst	r4,r5

80003e5c <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003e5c:	eb cd 40 80 	pushm	r7,lr
80003e60:	1a 97       	mov	r7,sp
80003e62:	20 2d       	sub	sp,8
80003e64:	ef 4c ff fc 	st.w	r7[-4],r12
80003e68:	ef 4b ff f8 	st.w	r7[-8],r11
	payload_rx_exec = payload_rx_func;
80003e6c:	48 d8       	lddpc	r8,80003ea0 <payload_init+0x44>
80003e6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e72:	91 09       	st.w	r8[0x0],r9
	payload_tx_exec = payload_tx_func;
80003e74:	48 c8       	lddpc	r8,80003ea4 <payload_init+0x48>
80003e76:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003e7a:	91 09       	st.w	r8[0x0],r9
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003e7c:	48 bb       	lddpc	r11,80003ea8 <payload_init+0x4c>
80003e7e:	30 08       	mov	r8,0
80003e80:	1a d8       	st.w	--sp,r8
80003e82:	30 08       	mov	r8,0
80003e84:	1a d8       	st.w	--sp,r8
80003e86:	30 08       	mov	r8,0
80003e88:	1a d8       	st.w	--sp,r8
80003e8a:	30 28       	mov	r8,2
80003e8c:	30 09       	mov	r9,0
80003e8e:	e0 6a 04 00 	mov	r10,1024
80003e92:	48 7c       	lddpc	r12,80003eac <payload_init+0x50>
80003e94:	f0 1f 00 07 	mcall	80003eb0 <payload_init+0x54>
80003e98:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80003e9a:	2f ed       	sub	sp,-8
80003e9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ea0:	00 00       	add	r0,r0
80003ea2:	0a 74       	tst	r4,r5
80003ea4:	00 00       	add	r0,r0
80003ea6:	0a 78       	tst	r8,r5
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	3d f4       	mov	r4,-33
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	3e 00       	mov	r0,-32
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	8d b0       	st.w	r6[0x2c],r0
80003eb4:	6d 6d       	ld.w	sp,r6[0x58]
80003eb6:	00 00       	add	r0,r0
80003eb8:	0a 0d       	add	sp,r5
80003eba:	20 78       	sub	r8,7
80003ebc:	78 78       	ld.w	r8,r12[0x1c]
80003ebe:	78 78       	ld.w	r8,r12[0x1c]
80003ec0:	5f 51       	srlt	r1
80003ec2:	51 5f       	stdsp	sp[0x54],pc
80003ec4:	78 78       	ld.w	r8,r12[0x1c]
80003ec6:	78 78       	ld.w	r8,r12[0x1c]
80003ec8:	78 20       	ld.w	r0,r12[0x8]
80003eca:	0a 0d       	add	sp,r5
80003ecc:	00 00       	add	r0,r0
80003ece:	00 00       	add	r0,r0
80003ed0:	0a 0d       	add	sp,r5
80003ed2:	20 52       	sub	r2,5
80003ed4:	61 64       	ld.w	r4,r0[0x58]
80003ed6:	69 6f       	ld.w	pc,r4[0x58]
80003ed8:	20 49       	sub	r9,4
80003eda:	6e 74       	ld.w	r4,r7[0x1c]
80003edc:	65 72       	ld.w	r2,r2[0x5c]
80003ede:	6e 61       	ld.w	r1,r7[0x18]
80003ee0:	6c 20       	ld.w	r0,r6[0x8]
80003ee2:	70 61       	ld.w	r1,r8[0x18]
80003ee4:	72 61       	ld.w	r1,r9[0x18]
80003ee6:	6d 65       	ld.w	r5,r6[0x58]
80003ee8:	74 65       	ld.w	r5,r10[0x18]
80003eea:	72 20       	ld.w	r0,r9[0x8]
80003eec:	6c 65       	ld.w	r5,r6[0x18]
80003eee:	6e 67       	ld.w	r7,r7[0x18]
80003ef0:	74 68       	ld.w	r8,r10[0x18]
80003ef2:	20 65       	sub	r5,6
80003ef4:	72 72       	ld.w	r2,r9[0x1c]
80003ef6:	6f 72       	ld.w	r2,r7[0x5c]
80003ef8:	20 0a       	sub	r10,0
80003efa:	0d 00       	ld.w	r0,r6++

80003efc <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003efc:	eb cd 40 80 	pushm	r7,lr
80003f00:	1a 97       	mov	r7,sp
80003f02:	20 4d       	sub	sp,16
    /*initialize the SSC*/
    ssc_init();
80003f04:	f0 1f 00 34 	mcall	80003fd4 <phy_init+0xd8>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003f08:	4b 4b       	lddpc	r11,80003fd8 <phy_init+0xdc>
80003f0a:	4b 5c       	lddpc	r12,80003fdc <phy_init+0xe0>
80003f0c:	f0 1f 00 35 	mcall	80003fe0 <phy_init+0xe4>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003f10:	30 4b       	mov	r11,4
80003f12:	31 ec       	mov	r12,30
80003f14:	f0 1f 00 34 	mcall	80003fe4 <phy_init+0xe8>
80003f18:	18 99       	mov	r9,r12
80003f1a:	4b 48       	lddpc	r8,80003fe8 <phy_init+0xec>
80003f1c:	91 09       	st.w	r8[0x0],r9
	phy_fragment_t * xnl_ptr = NULL;
80003f1e:	30 08       	mov	r8,0
80003f20:	ef 48 ff f0 	st.w	r7[-16],r8
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003f24:	30 08       	mov	r8,0
80003f26:	ef 48 ff f8 	st.w	r7[-8],r8
80003f2a:	c1 28       	rjmp	80003f4e <phy_init+0x52>
	{
		set_xnl_idle(&xnl_store[i]);
80003f2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f30:	f0 09 15 08 	lsl	r9,r8,0x8
80003f34:	4a e8       	lddpc	r8,80003fec <phy_init+0xf0>
80003f36:	10 09       	add	r9,r8
80003f38:	4a c8       	lddpc	r8,80003fe8 <phy_init+0xec>
80003f3a:	70 08       	ld.w	r8,r8[0x0]
80003f3c:	12 9b       	mov	r11,r9
80003f3e:	10 9c       	mov	r12,r8
80003f40:	f0 1f 00 2c 	mcall	80003ff0 <phy_init+0xf4>
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003f44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f48:	2f f8       	sub	r8,-1
80003f4a:	ef 48 ff f8 	st.w	r7[-8],r8
80003f4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f52:	59 d8       	cp.w	r8,29
80003f54:	fe 9a ff ec 	brle	80003f2c <phy_init+0x30>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003f58:	30 4b       	mov	r11,4
80003f5a:	31 4c       	mov	r12,20
80003f5c:	f0 1f 00 22 	mcall	80003fe4 <phy_init+0xe8>
80003f60:	18 99       	mov	r9,r12
80003f62:	4a 58       	lddpc	r8,80003ff4 <phy_init+0xf8>
80003f64:	91 09       	st.w	r8[0x0],r9
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003f66:	30 4b       	mov	r11,4
80003f68:	30 ac       	mov	r12,10
80003f6a:	f0 1f 00 1f 	mcall	80003fe4 <phy_init+0xe8>
80003f6e:	18 99       	mov	r9,r12
80003f70:	4a 28       	lddpc	r8,80003ff8 <phy_init+0xfc>
80003f72:	91 09       	st.w	r8[0x0],r9
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80003f74:	30 4b       	mov	r11,4
80003f76:	30 ac       	mov	r12,10
80003f78:	f0 1f 00 1b 	mcall	80003fe4 <phy_init+0xe8>
80003f7c:	18 99       	mov	r9,r12
80003f7e:	4a 08       	lddpc	r8,80003ffc <phy_init+0x100>
80003f80:	91 09       	st.w	r8[0x0],r9
	U8 * payload_ptr = NULL;
80003f82:	30 08       	mov	r8,0
80003f84:	ef 48 ff f4 	st.w	r7[-12],r8
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80003f88:	30 08       	mov	r8,0
80003f8a:	ef 48 ff fc 	st.w	r7[-4],r8
80003f8e:	c1 28       	rjmp	80003fb2 <phy_init+0xb6>
	{
		set_payload_idle(payload_store[i]);
80003f90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f94:	f0 09 15 09 	lsl	r9,r8,0x9
80003f98:	49 a8       	lddpc	r8,80004000 <phy_init+0x104>
80003f9a:	10 09       	add	r9,r8
80003f9c:	49 88       	lddpc	r8,80003ffc <phy_init+0x100>
80003f9e:	70 08       	ld.w	r8,r8[0x0]
80003fa0:	12 9b       	mov	r11,r9
80003fa2:	10 9c       	mov	r12,r8
80003fa4:	f0 1f 00 13 	mcall	80003ff0 <phy_init+0xf4>
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80003fa8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fac:	2f f8       	sub	r8,-1
80003fae:	ef 48 ff fc 	st.w	r7[-4],r8
80003fb2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fb6:	58 98       	cp.w	r8,9
80003fb8:	fe 9a ff ec 	brle	80003f90 <phy_init+0x94>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003fbc:	e0 6b 01 00 	mov	r11,256
80003fc0:	30 5c       	mov	r12,5
80003fc2:	f0 1f 00 09 	mcall	80003fe4 <phy_init+0xe8>
80003fc6:	18 99       	mov	r9,r12
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80003fc8:	48 f8       	lddpc	r8,80004004 <phy_init+0x108>
80003fca:	91 09       	st.w	r8[0x0],r9
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80003fcc:	2f cd       	sub	sp,-16
80003fce:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fd2:	00 00       	add	r0,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	5e 48       	retge	r8
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	41 14       	lddsp	r4,sp[0x44]
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	41 54       	lddsp	r4,sp[0x54]
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	5e c8       	retvs	r8
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	85 40       	st.w	r2[0x10],r0
80003fe8:	00 00       	add	r0,r0
80003fea:	0a 7c       	tst	r12,r5
80003fec:	00 00       	add	r0,r0
80003fee:	22 ba       	sub	r10,43
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	5b d8       	cp.w	r8,-3
80003ff4:	00 00       	add	r0,r0
80003ff6:	0a 80       	andn	r0,r5
80003ff8:	00 00       	add	r0,r0
80003ffa:	0a 84       	andn	r4,r5
80003ffc:	00 00       	add	r0,r0
80003ffe:	0a 88       	andn	r8,r5
80004000:	00 00       	add	r0,r0
80004002:	0e ba       	st.h	r7++,r10
80004004:	00 00       	add	r0,r0
80004006:	0a 8c       	andn	r12,r5

80004008 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80004008:	eb cd 40 80 	pushm	r7,lr
8000400c:	1a 97       	mov	r7,sp
8000400e:	20 2d       	sub	sp,8
80004010:	ef 4c ff f8 	st.w	r7[-8],r12
    Bool res = FALSE;
80004014:	30 08       	mov	r8,0
80004016:	ef 68 ff fd 	st.b	r7[-3],r8
	
	U16 phy_ctrl = phy->xnl_fragment.phy_header.phy_control;
8000401a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000401e:	90 08       	ld.sh	r8,r8[0x0]
80004020:	ef 58 ff fe 	st.h	r7[-2],r8
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80004024:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004028:	e2 18 f0 00 	andl	r8,0xf000,COH
8000402c:	e0 48 40 00 	cp.w	r8,16384
80004030:	c1 51       	brne	8000405a <phy_tx+0x52>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80004032:	49 b8       	lddpc	r8,8000409c <phy_tx+0x94>
80004034:	70 08       	ld.w	r8,r8[0x0]
80004036:	58 08       	cp.w	r8,0
80004038:	c2 f0       	breq	80004096 <phy_tx+0x8e>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000403a:	49 98       	lddpc	r8,8000409c <phy_tx+0x94>
8000403c:	70 08       	ld.w	r8,r8[0x0]
8000403e:	ee cb 00 08 	sub	r11,r7,8
80004042:	30 09       	mov	r9,0
80004044:	30 0a       	mov	r10,0
80004046:	10 9c       	mov	r12,r8
80004048:	f0 1f 00 16 	mcall	800040a0 <phy_tx+0x98>
8000404c:	18 98       	mov	r8,r12
8000404e:	58 18       	cp.w	r8,1
80004050:	c2 31       	brne	80004096 <phy_tx+0x8e>
			{
				res = TRUE;
80004052:	30 18       	mov	r8,1
80004054:	ef 68 ff fd 	st.b	r7[-3],r8
80004058:	c1 f8       	rjmp	80004096 <phy_tx+0x8e>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000405a:	ef 18 ff fe 	ld.uh	r8,r7[-2]
8000405e:	e2 18 f0 00 	andl	r8,0xf000,COH
80004062:	e0 48 10 00 	cp.w	r8,4096
80004066:	c1 60       	breq	80004092 <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
80004068:	ef 18 ff fe 	ld.uh	r8,r7[-2]
8000406c:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80004070:	e0 48 20 00 	cp.w	r8,8192
80004074:	c0 f0       	breq	80004092 <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
80004076:	ef 18 ff fe 	ld.uh	r8,r7[-2]
8000407a:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000407e:	e0 48 50 00 	cp.w	r8,20480
80004082:	c0 80       	breq	80004092 <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
80004084:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004088:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000408c:	e0 48 60 00 	cp.w	r8,24576
80004090:	c0 31       	brne	80004096 <phy_tx+0x8e>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80004092:	48 58       	lddpc	r8,800040a4 <phy_tx+0x9c>
80004094:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80004096:	2f ed       	sub	sp,-8
80004098:	e3 cd 80 80 	ldm	sp++,r7,pc
8000409c:	00 00       	add	r0,r0
8000409e:	0a 80       	andn	r0,r5
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	86 58       	ld.sh	r8,r3[0xa]
800040a4:	00 00       	add	r0,r0
800040a6:	0a 8c       	andn	r12,r5

800040a8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800040a8:	eb cd 40 80 	pushm	r7,lr
800040ac:	1a 97       	mov	r7,sp
800040ae:	20 3d       	sub	sp,12
800040b0:	ef 4c ff f4 	st.w	r7[-12],r12
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800040b4:	30 08       	mov	r8,0
800040b6:	ef 48 ff f8 	st.w	r7[-8],r8
	
	//phy_fragment_t * xx = pvPortMalloc(sizeof(phy_fragment_t));
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
800040ba:	30 08       	mov	r8,0
800040bc:	ef 68 ff fd 	st.b	r7[-3],r8
	
	if(NULL == phy_ptr)
800040c0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040c4:	58 08       	cp.w	r8,0
800040c6:	c1 e0       	breq	80004102 <phy_rx+0x5a>
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800040c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040cc:	90 08       	ld.sh	r8,r8[0x0]
800040ce:	ef 58 ff fe 	st.h	r7[-2],r8

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
800040d2:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800040d6:	e2 18 f0 00 	andl	r8,0xf000,COH
800040da:	e0 48 40 00 	cp.w	r8,16384
800040de:	c1 31       	brne	80004104 <phy_rx+0x5c>
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800040e0:	48 b8       	lddpc	r8,8000410c <phy_rx+0x64>
800040e2:	70 08       	ld.w	r8,r8[0x0]
800040e4:	ee ca 00 08 	sub	r10,r7,8
800040e8:	ee cb 00 0c 	sub	r11,r7,12
800040ec:	30 09       	mov	r9,0
800040ee:	10 9c       	mov	r12,r8
800040f0:	f0 1f 00 08 	mcall	80004110 <phy_rx+0x68>
800040f4:	18 98       	mov	r8,r12
800040f6:	58 18       	cp.w	r8,1
800040f8:	c0 61       	brne	80004104 <phy_rx+0x5c>
			///*  */
			//if (xHigherPriorityTaskWoken == pdTRUE)
			//{
				//taskYIELD();
			//}
			res = TRUE;
800040fa:	30 18       	mov	r8,1
800040fc:	ef 68 ff fd 	st.b	r7[-3],r8
80004100:	c0 28       	rjmp	80004104 <phy_rx+0x5c>
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
	{
		return;
80004102:	d7 03       	nop
		}	

    }
		
 
}
80004104:	2f dd       	sub	sp,-12
80004106:	e3 cd 80 80 	ldm	sp++,r7,pc
8000410a:	00 00       	add	r0,r0
8000410c:	00 00       	add	r0,r0
8000410e:	0a 84       	andn	r4,r5
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	87 c0       	st.w	r3[0x30],r0

80004114 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80004114:	eb cd 40 80 	pushm	r7,lr
80004118:	1a 97       	mov	r7,sp
8000411a:	20 1d       	sub	sp,4
8000411c:	ef 4c ff fc 	st.w	r7[-4],r12
    if(NULL != phy_xnl_frame_tx)
80004120:	48 a8       	lddpc	r8,80004148 <phy_tx_func+0x34>
80004122:	70 08       	ld.w	r8,r8[0x0]
80004124:	58 08       	cp.w	r8,0
80004126:	c0 70       	breq	80004134 <phy_tx_func+0x20>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80004128:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000412c:	2f c8       	sub	r8,-4
8000412e:	10 9c       	mov	r12,r8
80004130:	f0 1f 00 07 	mcall	8000414c <phy_tx_func+0x38>
    {
		//
		//if (ENABLE == PLAYBACK_ENABLE)
		{
			/*send ssc data in payload(media) frame*/
			phy_payload_tx(&(((ssc_fragment_t * )ssc)->payload_channel));	
80004134:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004138:	2f 88       	sub	r8,-8
8000413a:	10 9c       	mov	r12,r8
8000413c:	f0 1f 00 05 	mcall	80004150 <phy_tx_func+0x3c>
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004140:	2f fd       	sub	sp,-4
80004142:	e3 cd 80 80 	ldm	sp++,r7,pc
80004146:	00 00       	add	r0,r0
80004148:	00 00       	add	r0,r0
8000414a:	0a 80       	andn	r0,r5
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	41 94       	lddsp	r4,sp[0x64]
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	45 fc       	lddsp	r12,sp[0x17c]

80004154 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80004154:	eb cd 40 80 	pushm	r7,lr
80004158:	1a 97       	mov	r7,sp
8000415a:	20 1d       	sub	sp,4
8000415c:	ef 4c ff fc 	st.w	r7[-4],r12
		
	if(NULL != phy_xnl_frame_rx)
80004160:	48 a8       	lddpc	r8,80004188 <phy_rx_func+0x34>
80004162:	70 08       	ld.w	r8,r8[0x0]
80004164:	58 08       	cp.w	r8,0
80004166:	c0 70       	breq	80004174 <phy_rx_func+0x20>
	{
		/*receive ssc data in xnl frame*/
		phy_xnl_rx(&(((ssc_fragment_t * )ssc)->xnl_channel));
80004168:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000416c:	2f c8       	sub	r8,-4
8000416e:	10 9c       	mov	r12,r8
80004170:	f0 1f 00 07 	mcall	8000418c <phy_rx_func+0x38>
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004174:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004178:	2f 88       	sub	r8,-8
8000417a:	10 9c       	mov	r12,r8
8000417c:	f0 1f 00 05 	mcall	80004190 <phy_rx_func+0x3c>
	}
	#endif /*end if*/
	
	
}
80004180:	2f fd       	sub	sp,-4
80004182:	e3 cd 80 80 	ldm	sp++,r7,pc
80004186:	00 00       	add	r0,r0
80004188:	00 00       	add	r0,r0
8000418a:	0a 84       	andn	r4,r5
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	42 f4       	lddsp	r4,sp[0xbc]
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	4c 74       	lddpc	r4,800042ac <phy_xnl_tx+0x118>

80004194 <phy_xnl_tx>:
Calls:   
    xQueueReceiveFromISR -- freertos
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
80004194:	eb cd 40 80 	pushm	r7,lr
80004198:	1a 97       	mov	r7,sp
8000419a:	20 2d       	sub	sp,8
8000419c:	ef 4c ff f8 	st.w	r7[-8],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800041a0:	30 08       	mov	r8,0
800041a2:	ef 48 ff fc 	st.w	r7[-4],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800041a6:	4c e8       	lddpc	r8,800042dc <phy_xnl_tx+0x148>
800041a8:	70 08       	ld.w	r8,r8[0x0]
800041aa:	58 18       	cp.w	r8,1
800041ac:	c3 a0       	breq	80004220 <phy_xnl_tx+0x8c>
800041ae:	c0 53       	brcs	800041b8 <phy_xnl_tx+0x24>
800041b0:	58 28       	cp.w	r8,2
800041b2:	e0 80 00 88 	breq	800042c2 <phy_xnl_tx+0x12e>
800041b6:	c9 08       	rjmp	800042d6 <phy_xnl_tx+0x142>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800041b8:	4c a8       	lddpc	r8,800042e0 <phy_xnl_tx+0x14c>
800041ba:	70 08       	ld.w	r8,r8[0x0]
800041bc:	ee c9 00 04 	sub	r9,r7,4
800041c0:	12 9a       	mov	r10,r9
800041c2:	4c 9b       	lddpc	r11,800042e4 <phy_xnl_tx+0x150>
800041c4:	10 9c       	mov	r12,r8
800041c6:	f0 1f 00 49 	mcall	800042e8 <phy_xnl_tx+0x154>
800041ca:	18 98       	mov	r8,r12
800041cc:	58 18       	cp.w	r8,1
800041ce:	c2 11       	brne	80004210 <phy_xnl_tx+0x7c>
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
				     phy_ptr->xnl_fragment.phy_header.phy_control & 0x000000FF;
800041d0:	4c 58       	lddpc	r8,800042e4 <phy_xnl_tx+0x150>
800041d2:	70 08       	ld.w	r8,r8[0x0]
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800041d4:	90 08       	ld.sh	r8,r8[0x0]
800041d6:	5c 88       	casts.h	r8
800041d8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800041dc:	4c 49       	lddpc	r9,800042ec <phy_xnl_tx+0x158>
800041de:	b2 08       	st.h	r9[0x0],r8
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
800041e0:	4c 18       	lddpc	r8,800042e4 <phy_xnl_tx+0x150>
800041e2:	70 08       	ld.w	r8,r8[0x0]
800041e4:	90 08       	ld.sh	r8,r8[0x0]
				
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
800041e6:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800041ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041ee:	91 09       	st.w	r8[0x0],r9
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800041f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041f4:	70 08       	ld.w	r8,r8[0x0]
800041f6:	10 99       	mov	r9,r8
800041f8:	ea 19 ab cd 	orh	r9,0xabcd
800041fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004200:	91 09       	st.w	r8[0x0],r9
				
				phy_tx_index = 1;
80004202:	4b c9       	lddpc	r9,800042f0 <phy_xnl_tx+0x15c>
80004204:	30 18       	mov	r8,1
80004206:	b2 88       	st.b	r9[0x0],r8
				phy_tx_state = WRITE_NEXT_DWORD;	
80004208:	4b 58       	lddpc	r8,800042dc <phy_xnl_tx+0x148>
8000420a:	30 19       	mov	r9,1
8000420c:	91 09       	st.w	r8[0x0],r9
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
8000420e:	c6 48       	rjmp	800042d6 <phy_xnl_tx+0x142>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80004210:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004214:	e0 69 5a 5a 	mov	r9,23130
80004218:	ea 19 ab cd 	orh	r9,0xabcd
8000421c:	91 09       	st.w	r8[0x0],r9
			}			
			break;
8000421e:	c5 c8       	rjmp	800042d6 <phy_xnl_tx+0x142>
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80004220:	4b 18       	lddpc	r8,800042e4 <phy_xnl_tx+0x150>
80004222:	70 09       	ld.w	r9,r8[0x0]
80004224:	4b 38       	lddpc	r8,800042f0 <phy_xnl_tx+0x15c>
80004226:	11 88       	ld.ub	r8,r8[0x0]
80004228:	10 9a       	mov	r10,r8
8000422a:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
8000422e:	5c 79       	castu.h	r9
80004230:	b1 69       	lsl	r9,0x10
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80004232:	12 9a       	mov	r10,r9
80004234:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004238:	93 0a       	st.w	r9[0x0],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000423a:	2f f8       	sub	r8,-1
8000423c:	5c 58       	castu.b	r8
8000423e:	4a d9       	lddpc	r9,800042f0 <phy_xnl_tx+0x15c>
80004240:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80004242:	4a b8       	lddpc	r8,800042ec <phy_xnl_tx+0x158>
80004244:	90 08       	ld.sh	r8,r8[0x0]
80004246:	20 28       	sub	r8,2
80004248:	5c 88       	casts.h	r8
8000424a:	5c 88       	casts.h	r8
8000424c:	4a 89       	lddpc	r9,800042ec <phy_xnl_tx+0x158>
8000424e:	b2 08       	st.h	r9[0x0],r8
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80004250:	4a 78       	lddpc	r8,800042ec <phy_xnl_tx+0x158>
80004252:	90 09       	ld.sh	r9,r8[0x0]
80004254:	30 08       	mov	r8,0
80004256:	f0 09 19 00 	cp.h	r9,r8
8000425a:	e0 89 00 0f 	brgt	80004278 <phy_xnl_tx+0xe4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000425e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004262:	70 08       	ld.w	r8,r8[0x0]
80004264:	10 99       	mov	r9,r8
80004266:	e8 19 00 ba 	orl	r9,0xba
8000426a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000426e:	91 09       	st.w	r8[0x0],r9
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80004270:	49 b8       	lddpc	r8,800042dc <phy_xnl_tx+0x148>
80004272:	30 09       	mov	r9,0
80004274:	91 09       	st.w	r8[0x0],r9
				break;
80004276:	c3 08       	rjmp	800042d6 <phy_xnl_tx+0x142>
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80004278:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000427c:	70 0a       	ld.w	r10,r8[0x0]
8000427e:	49 a8       	lddpc	r8,800042e4 <phy_xnl_tx+0x150>
80004280:	70 09       	ld.w	r9,r8[0x0]
80004282:	49 c8       	lddpc	r8,800042f0 <phy_xnl_tx+0x15c>
80004284:	11 88       	ld.ub	r8,r8[0x0]
80004286:	10 9b       	mov	r11,r8
80004288:	f2 0b 04 19 	ld.sh	r9,r9[r11<<0x1]
8000428c:	5c 79       	castu.h	r9
8000428e:	12 4a       	or	r10,r9
80004290:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004294:	93 0a       	st.w	r9[0x0],r10
80004296:	2f f8       	sub	r8,-1
80004298:	5c 58       	castu.b	r8
8000429a:	49 69       	lddpc	r9,800042f0 <phy_xnl_tx+0x15c>
8000429c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000429e:	49 48       	lddpc	r8,800042ec <phy_xnl_tx+0x158>
800042a0:	90 08       	ld.sh	r8,r8[0x0]
800042a2:	20 28       	sub	r8,2
800042a4:	5c 88       	casts.h	r8
800042a6:	5c 88       	casts.h	r8
800042a8:	49 19       	lddpc	r9,800042ec <phy_xnl_tx+0x158>
800042aa:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800042ac:	49 08       	lddpc	r8,800042ec <phy_xnl_tx+0x158>
800042ae:	90 09       	ld.sh	r9,r8[0x0]
800042b0:	30 08       	mov	r8,0
800042b2:	f0 09 19 00 	cp.h	r9,r8
800042b6:	e0 89 00 0f 	brgt	800042d4 <phy_xnl_tx+0x140>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
800042ba:	48 98       	lddpc	r8,800042dc <phy_xnl_tx+0x148>
800042bc:	30 29       	mov	r9,2
800042be:	91 09       	st.w	r8[0x0],r9
			}
			break;
800042c0:	c0 b8       	rjmp	800042d6 <phy_xnl_tx+0x142>

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
800042c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042c6:	fc 19 00 ba 	movh	r9,0xba
800042ca:	91 09       	st.w	r8[0x0],r9
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
800042cc:	48 48       	lddpc	r8,800042dc <phy_xnl_tx+0x148>
800042ce:	30 09       	mov	r9,0
800042d0:	91 09       	st.w	r8[0x0],r9
800042d2:	c0 28       	rjmp	800042d6 <phy_xnl_tx+0x142>
			if (phy_tx_expexted_length <= 0)
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
			}
			break;
800042d4:	d7 03       	nop
			/*This fragment finished.*/
			
		default:
			break;
	}
}
800042d6:	2f ed       	sub	sp,-8
800042d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800042dc:	00 00       	add	r0,r0
800042de:	0a e4       	st.h	--r5,r4
800042e0:	00 00       	add	r0,r0
800042e2:	0a 80       	andn	r0,r5
800042e4:	00 00       	add	r0,r0
800042e6:	0a e8       	st.h	--r5,r8
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	8a 50       	ld.sh	r0,r5[0xa]
800042ec:	00 00       	add	r0,r0
800042ee:	0a ec       	st.h	--r5,r12
800042f0:	00 00       	add	r0,r0
800042f2:	0a ee       	st.h	--r5,lr

800042f4 <phy_xnl_rx>:
Calls:   
    phy_rx
Called By: phy_rx_func
*/
static void phy_xnl_rx(xnl_channel_t * xnl_rx_channel)
{
800042f4:	eb cd 40 80 	pushm	r7,lr
800042f8:	1a 97       	mov	r7,sp
800042fa:	20 3d       	sub	sp,12
800042fc:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80004300:	30 08       	mov	r8,0
80004302:	ef 48 ff f8 	st.w	r7[-8],r8
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80004306:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000430a:	70 08       	ld.w	r8,r8[0x0]
8000430c:	ef 48 ff fc 	st.w	r7[-4],r8

	phy_rx_count++;
80004310:	fe f8 02 c4 	ld.w	r8,pc[708]
80004314:	70 08       	ld.w	r8,r8[0x0]
80004316:	f0 c9 ff ff 	sub	r9,r8,-1
8000431a:	fe f8 02 ba 	ld.w	r8,pc[698]
8000431e:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80004320:	fe f8 02 b8 	ld.w	r8,pc[696]
80004324:	70 08       	ld.w	r8,r8[0x0]
80004326:	58 18       	cp.w	r8,1
80004328:	e0 80 00 ba 	breq	8000449c <phy_xnl_rx+0x1a8>
8000432c:	c0 93       	brcs	8000433e <phy_xnl_rx+0x4a>
8000432e:	58 28       	cp.w	r8,2
80004330:	e0 80 00 81 	breq	80004432 <phy_xnl_rx+0x13e>
80004334:	58 38       	cp.w	r8,3
80004336:	e0 80 01 24 	breq	8000457e <phy_xnl_rx+0x28a>
8000433a:	e0 8f 01 49 	bral	800045cc <phy_xnl_rx+0x2d8>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000433e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004342:	e0 69 5a 5a 	mov	r9,23130
80004346:	ea 19 ab cd 	orh	r9,0xabcd
8000434a:	12 38       	cp.w	r8,r9
8000434c:	e0 80 01 37 	breq	800045ba <phy_xnl_rx+0x2c6>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80004350:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004354:	b1 88       	lsr	r8,0x10
80004356:	e0 48 ab cd 	cp.w	r8,43981
8000435a:	e0 81 01 32 	brne	800045be <phy_xnl_rx+0x2ca>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000435e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004362:	5c 88       	casts.h	r8
80004364:	5c 88       	casts.h	r8
80004366:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000436a:	20 28       	sub	r8,2
8000436c:	5c 88       	casts.h	r8
8000436e:	5c 88       	casts.h	r8
80004370:	fe f9 02 6c 	ld.w	r9,pc[620]
80004374:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004376:	fe f8 02 66 	ld.w	r8,pc[614]
8000437a:	90 09       	ld.sh	r9,r8[0x0]
8000437c:	30 08       	mov	r8,0
8000437e:	f0 09 19 00 	cp.h	r9,r8
80004382:	e0 8a 01 20 	brle	800045c2 <phy_xnl_rx+0x2ce>
			{
				break;
			}
		
			phy_rx_length = 0;
80004386:	fe f9 02 5a 	ld.w	r9,pc[602]
8000438a:	30 08       	mov	r8,0
8000438c:	b2 08       	st.h	r9[0x0],r8
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000438e:	fe f8 02 56 	ld.w	r8,pc[598]
80004392:	70 08       	ld.w	r8,r8[0x0]
80004394:	10 9c       	mov	r12,r8
80004396:	f0 1f 00 95 	mcall	800045e8 <phy_xnl_rx+0x2f4>
8000439a:	18 98       	mov	r8,r12
8000439c:	10 99       	mov	r9,r8
8000439e:	fe f8 02 4e 	ld.w	r8,pc[590]
800043a2:	91 09       	st.w	r8[0x0],r9
			if(NULL == phy_frame_ptr)
800043a4:	fe f8 02 48 	ld.w	r8,pc[584]
800043a8:	70 08       	ld.w	r8,r8[0x0]
800043aa:	58 08       	cp.w	r8,0
800043ac:	e0 80 01 0d 	breq	800045c6 <phy_xnl_rx+0x2d2>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800043b0:	fe f8 02 3c 	ld.w	r8,pc[572]
800043b4:	70 0a       	ld.w	r10,r8[0x0]
800043b6:	fe f8 02 2a 	ld.w	r8,pc[554]
800043ba:	90 08       	ld.sh	r8,r8[0x0]
800043bc:	10 9b       	mov	r11,r8
800043be:	ee f9 ff fc 	ld.w	r9,r7[-4]
800043c2:	5c 89       	casts.h	r9
800043c4:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800043c8:	2f f8       	sub	r8,-1
800043ca:	5c 88       	casts.h	r8
800043cc:	fe f9 02 14 	ld.w	r9,pc[532]
800043d0:	b2 08       	st.h	r9[0x0],r8
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800043d2:	fe f8 02 1a 	ld.w	r8,pc[538]
800043d6:	70 0a       	ld.w	r10,r8[0x0]
800043d8:	fe f8 02 08 	ld.w	r8,pc[520]
800043dc:	90 08       	ld.sh	r8,r8[0x0]
800043de:	10 9b       	mov	r11,r8
800043e0:	4f d9       	lddpc	r9,800045d4 <phy_xnl_rx+0x2e0>
800043e2:	72 09       	ld.w	r9,r9[0x0]
800043e4:	5c 89       	casts.h	r9
800043e6:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800043ea:	2f f8       	sub	r8,-1
800043ec:	5c 88       	casts.h	r8
800043ee:	4f d9       	lddpc	r9,800045e0 <phy_xnl_rx+0x2ec>
800043f0:	b2 08       	st.h	r9[0x0],r8
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800043f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043f6:	e2 18 0f 00 	andl	r8,0xf00,COH
800043fa:	e0 48 01 00 	cp.w	r8,256
800043fe:	c0 c0       	breq	80004416 <phy_xnl_rx+0x122>
80004400:	e0 8b 00 05 	brhi	8000440a <phy_xnl_rx+0x116>
80004404:	58 08       	cp.w	r8,0
80004406:	c0 80       	breq	80004416 <phy_xnl_rx+0x122>
80004408:	c0 c8       	rjmp	80004420 <phy_xnl_rx+0x12c>
8000440a:	e0 48 02 00 	cp.w	r8,512
8000440e:	c0 40       	breq	80004416 <phy_xnl_rx+0x122>
80004410:	e0 48 03 00 	cp.w	r8,768
80004414:	c0 61       	brne	80004420 <phy_xnl_rx+0x12c>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80004416:	4f 18       	lddpc	r8,800045d8 <phy_xnl_rx+0x2e4>
80004418:	30 29       	mov	r9,2
8000441a:	91 09       	st.w	r8[0x0],r9
				break;
8000441c:	d7 03       	nop
				default:
					vPortFree(phy_frame_ptr);
					phy_frame_ptr = NULL;					
				break;
			}	
			break;
8000441e:	cd 78       	rjmp	800045cc <phy_xnl_rx+0x2d8>
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
				break;
				default:
					vPortFree(phy_frame_ptr);
80004420:	4f 38       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
80004422:	70 08       	ld.w	r8,r8[0x0]
80004424:	10 9c       	mov	r12,r8
80004426:	f0 1f 00 73 	mcall	800045f0 <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;					
8000442a:	4f 18       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
8000442c:	30 09       	mov	r9,0
8000442e:	91 09       	st.w	r8[0x0],r9
				break;
			}	
			break;
80004430:	cc e8       	rjmp	800045cc <phy_xnl_rx+0x2d8>
		Gets here on CSUM. Expect at least one hWord payload. Gets here once 
		on every fragment.*/	
		case WAITING_CHECK_SUM:
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
80004432:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004436:	b1 88       	lsr	r8,0x10
80004438:	5c 88       	casts.h	r8
8000443a:	4e f9       	lddpc	r9,800045f4 <phy_xnl_rx+0x300>
8000443c:	b2 08       	st.h	r9[0x0],r8
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000443e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004442:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004446:	4e c8       	lddpc	r8,800045f4 <phy_xnl_rx+0x300>
80004448:	90 08       	ld.sh	r8,r8[0x0]
8000444a:	f2 08 00 08 	add	r8,r9,r8
8000444e:	5c 88       	casts.h	r8
80004450:	4e 99       	lddpc	r9,800045f4 <phy_xnl_rx+0x300>
80004452:	b2 08       	st.h	r9[0x0],r8
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004454:	4e 68       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
80004456:	70 0a       	ld.w	r10,r8[0x0]
80004458:	4e 28       	lddpc	r8,800045e0 <phy_xnl_rx+0x2ec>
8000445a:	90 08       	ld.sh	r8,r8[0x0]
8000445c:	10 9b       	mov	r11,r8
8000445e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004462:	5c 89       	casts.h	r9
80004464:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004468:	2f f8       	sub	r8,-1
8000446a:	5c 88       	casts.h	r8
8000446c:	4d d9       	lddpc	r9,800045e0 <phy_xnl_rx+0x2ec>
8000446e:	b2 08       	st.h	r9[0x0],r8
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80004470:	4d b8       	lddpc	r8,800045dc <phy_xnl_rx+0x2e8>
80004472:	90 08       	ld.sh	r8,r8[0x0]
80004474:	20 28       	sub	r8,2
80004476:	5c 88       	casts.h	r8
80004478:	5c 88       	casts.h	r8
8000447a:	4d 99       	lddpc	r9,800045dc <phy_xnl_rx+0x2e8>
8000447c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000447e:	4d 88       	lddpc	r8,800045dc <phy_xnl_rx+0x2e8>
80004480:	90 09       	ld.sh	r9,r8[0x0]
80004482:	30 08       	mov	r8,0
80004484:	f0 09 19 00 	cp.h	r9,r8
80004488:	e0 8a 00 06 	brle	80004494 <phy_xnl_rx+0x1a0>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000448c:	4d 38       	lddpc	r8,800045d8 <phy_xnl_rx+0x2e4>
8000448e:	30 19       	mov	r9,1
80004490:	91 09       	st.w	r8[0x0],r9
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
			}			
		
			break;
80004492:	c9 d8       	rjmp	800045cc <phy_xnl_rx+0x2d8>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004494:	4d 18       	lddpc	r8,800045d8 <phy_xnl_rx+0x2e4>
80004496:	30 39       	mov	r9,3
80004498:	91 09       	st.w	r8[0x0],r9
			}			
		
			break;
8000449a:	c9 98       	rjmp	800045cc <phy_xnl_rx+0x2d8>

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000449c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044a0:	b1 88       	lsr	r8,0x10
800044a2:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800044a6:	4d 48       	lddpc	r8,800045f4 <phy_xnl_rx+0x300>
800044a8:	90 08       	ld.sh	r8,r8[0x0]
800044aa:	f2 08 00 08 	add	r8,r9,r8
800044ae:	5c 88       	casts.h	r8
800044b0:	4d 19       	lddpc	r9,800045f4 <phy_xnl_rx+0x300>
800044b2:	b2 08       	st.h	r9[0x0],r8
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800044b4:	4c e8       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
800044b6:	70 0a       	ld.w	r10,r8[0x0]
800044b8:	4c a8       	lddpc	r8,800045e0 <phy_xnl_rx+0x2ec>
800044ba:	90 08       	ld.sh	r8,r8[0x0]
800044bc:	10 9b       	mov	r11,r8
												 (phy_dword & 0xFFFF0000) >> 16;
800044be:	ee f9 ff fc 	ld.w	r9,r7[-4]
800044c2:	b1 89       	lsr	r9,0x10
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800044c4:	5c 89       	casts.h	r9
800044c6:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800044ca:	2f f8       	sub	r8,-1
800044cc:	5c 88       	casts.h	r8
800044ce:	4c 59       	lddpc	r9,800045e0 <phy_xnl_rx+0x2ec>
800044d0:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800044d2:	4c 38       	lddpc	r8,800045dc <phy_xnl_rx+0x2e8>
800044d4:	90 08       	ld.sh	r8,r8[0x0]
800044d6:	20 28       	sub	r8,2
800044d8:	5c 88       	casts.h	r8
800044da:	5c 88       	casts.h	r8
800044dc:	4c 09       	lddpc	r9,800045dc <phy_xnl_rx+0x2e8>
800044de:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800044e0:	4b f8       	lddpc	r8,800045dc <phy_xnl_rx+0x2e8>
800044e2:	90 09       	ld.sh	r9,r8[0x0]
800044e4:	30 08       	mov	r8,0
800044e6:	f0 09 19 00 	cp.h	r9,r8
800044ea:	e0 89 00 1f 	brgt	80004528 <phy_xnl_rx+0x234>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800044ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044f2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
800044f6:	e0 48 00 ba 	cp.w	r8,186
800044fa:	c0 b1       	brne	80004510 <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
800044fc:	4b e8       	lddpc	r8,800045f4 <phy_xnl_rx+0x300>
800044fe:	90 08       	ld.sh	r8,r8[0x0]
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80004500:	58 08       	cp.w	r8,0
80004502:	c0 71       	brne	80004510 <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004504:	4b a8       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
80004506:	70 08       	ld.w	r8,r8[0x0]
80004508:	10 9c       	mov	r12,r8
8000450a:	f0 1f 00 3c 	mcall	800045f8 <phy_xnl_rx+0x304>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000450e:	c0 98       	rjmp	80004520 <phy_xnl_rx+0x22c>
				{
					phy_rx(phy_frame_ptr);
				}
				else
				{
					vPortFree(phy_frame_ptr);
80004510:	4b 78       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
80004512:	70 08       	ld.w	r8,r8[0x0]
80004514:	10 9c       	mov	r12,r8
80004516:	f0 1f 00 37 	mcall	800045f0 <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;
8000451a:	4b 58       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
8000451c:	30 09       	mov	r9,0
8000451e:	91 09       	st.w	r8[0x0],r9
				}

				phy_rx_state = WAITING_FOR_HEADER;
80004520:	4a e8       	lddpc	r8,800045d8 <phy_xnl_rx+0x2e4>
80004522:	30 09       	mov	r9,0
80004524:	91 09       	st.w	r8[0x0],r9
				break;
80004526:	c5 38       	rjmp	800045cc <phy_xnl_rx+0x2d8>
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004528:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000452c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004530:	4b 18       	lddpc	r8,800045f4 <phy_xnl_rx+0x300>
80004532:	90 08       	ld.sh	r8,r8[0x0]
80004534:	f2 08 00 08 	add	r8,r9,r8
80004538:	5c 88       	casts.h	r8
8000453a:	4a f9       	lddpc	r9,800045f4 <phy_xnl_rx+0x300>
8000453c:	b2 08       	st.h	r9[0x0],r8
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000453e:	4a c8       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
80004540:	70 0a       	ld.w	r10,r8[0x0]
80004542:	4a 88       	lddpc	r8,800045e0 <phy_xnl_rx+0x2ec>
80004544:	90 08       	ld.sh	r8,r8[0x0]
80004546:	10 9b       	mov	r11,r8
80004548:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000454c:	5c 89       	casts.h	r9
8000454e:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004552:	2f f8       	sub	r8,-1
80004554:	5c 88       	casts.h	r8
80004556:	4a 39       	lddpc	r9,800045e0 <phy_xnl_rx+0x2ec>
80004558:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000455a:	4a 18       	lddpc	r8,800045dc <phy_xnl_rx+0x2e8>
8000455c:	90 08       	ld.sh	r8,r8[0x0]
8000455e:	20 28       	sub	r8,2
80004560:	5c 88       	casts.h	r8
80004562:	5c 88       	casts.h	r8
80004564:	49 e9       	lddpc	r9,800045dc <phy_xnl_rx+0x2e8>
80004566:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004568:	49 d8       	lddpc	r8,800045dc <phy_xnl_rx+0x2e8>
8000456a:	90 09       	ld.sh	r9,r8[0x0]
8000456c:	30 08       	mov	r8,0
8000456e:	f0 09 19 00 	cp.h	r9,r8
80004572:	e0 89 00 2c 	brgt	800045ca <phy_xnl_rx+0x2d6>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80004576:	49 98       	lddpc	r8,800045d8 <phy_xnl_rx+0x2e4>
80004578:	30 39       	mov	r9,3
8000457a:	91 09       	st.w	r8[0x0],r9
			}/*else, next Word contains more payload.*/
			break;
8000457c:	c2 88       	rjmp	800045cc <phy_xnl_rx+0x2d8>

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000457e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004582:	e6 18 00 ff 	andh	r8,0xff,COH
80004586:	fc 19 00 ba 	movh	r9,0xba
8000458a:	12 38       	cp.w	r8,r9
8000458c:	c0 b1       	brne	800045a2 <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
8000458e:	49 a8       	lddpc	r8,800045f4 <phy_xnl_rx+0x300>
80004590:	90 08       	ld.sh	r8,r8[0x0]
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004592:	58 08       	cp.w	r8,0
80004594:	c0 71       	brne	800045a2 <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80004596:	49 68       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
80004598:	70 08       	ld.w	r8,r8[0x0]
8000459a:	10 9c       	mov	r12,r8
8000459c:	f0 1f 00 17 	mcall	800045f8 <phy_xnl_rx+0x304>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800045a0:	c0 98       	rjmp	800045b2 <phy_xnl_rx+0x2be>
				phy_rx(phy_frame_ptr);

			}
			else
			{
				vPortFree(phy_frame_ptr);
800045a2:	49 38       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
800045a4:	70 08       	ld.w	r8,r8[0x0]
800045a6:	10 9c       	mov	r12,r8
800045a8:	f0 1f 00 12 	mcall	800045f0 <phy_xnl_rx+0x2fc>
				phy_frame_ptr = NULL;
800045ac:	49 08       	lddpc	r8,800045ec <phy_xnl_rx+0x2f8>
800045ae:	30 09       	mov	r9,0
800045b0:	91 09       	st.w	r8[0x0],r9
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800045b2:	48 a8       	lddpc	r8,800045d8 <phy_xnl_rx+0x2e4>
800045b4:	30 09       	mov	r9,0
800045b6:	91 09       	st.w	r8[0x0],r9
800045b8:	c0 a8       	rjmp	800045cc <phy_xnl_rx+0x2d8>
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
			{
				break;
800045ba:	d7 03       	nop
800045bc:	c0 88       	rjmp	800045cc <phy_xnl_rx+0x2d8>
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
			{			
				break;
800045be:	d7 03       	nop
800045c0:	c0 68       	rjmp	800045cc <phy_xnl_rx+0x2d8>
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
			{
				break;
800045c2:	d7 03       	nop
800045c4:	c0 48       	rjmp	800045cc <phy_xnl_rx+0x2d8>
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
			if(NULL == phy_frame_ptr)
			{
				break;
800045c6:	d7 03       	nop
800045c8:	c0 28       	rjmp	800045cc <phy_xnl_rx+0x2d8>
			if (phy_rx_expexted_length <= 0)
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
			}/*else, next Word contains more payload.*/
			break;
800045ca:	d7 03       	nop
			phy_rx_state = WAITING_FOR_HEADER;
			break;
		default:
		break;
	}/*End of phy_rx_state switch.*/
}
800045cc:	2f dd       	sub	sp,-12
800045ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800045d2:	00 00       	add	r0,r0
800045d4:	00 00       	add	r0,r0
800045d6:	0a d0       	st.w	--r5,r0
800045d8:	00 00       	add	r0,r0
800045da:	0a d4       	st.w	--r5,r4
800045dc:	00 00       	add	r0,r0
800045de:	0a d8       	st.w	--r5,r8
800045e0:	00 00       	add	r0,r0
800045e2:	0a da       	st.w	--r5,r10
800045e4:	00 00       	add	r0,r0
800045e6:	0a 7c       	tst	r12,r5
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	5b 90       	cp.w	r0,-7
800045ec:	00 00       	add	r0,r0
800045ee:	0a dc       	st.w	--r5,r12
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	85 08       	st.w	r2[0x0],r8
800045f4:	00 00       	add	r0,r0
800045f6:	0a e0       	st.h	--r5,r0
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	40 a8       	lddsp	r8,sp[0x28]

800045fc <phy_payload_tx>:
Calls: 
Called By:phy_tx_func
*/

static void phy_payload_tx(payload_channel_t * payload_tx_channel)
{
800045fc:	eb cd 40 80 	pushm	r7,lr
80004600:	1a 97       	mov	r7,sp
80004602:	20 1d       	sub	sp,4
80004604:	ef 4c ff fc 	st.w	r7[-4],r12
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80004608:	fe f8 05 b8 	ld.w	r8,pc[1464]
8000460c:	11 89       	ld.ub	r9,r8[0x0]
8000460e:	30 18       	mov	r8,1
80004610:	f0 09 18 00 	cp.b	r9,r8
80004614:	e0 81 02 c8 	brne	80004ba4 <phy_payload_tx+0x5a8>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80004618:	fe f8 05 ac 	ld.w	r8,pc[1452]
8000461c:	70 08       	ld.w	r8,r8[0x0]
8000461e:	e0 48 05 af 	cp.w	r8,1455
80004622:	e0 8b 00 06 	brhi	8000462e <phy_payload_tx+0x32>
80004626:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000462a:	70 08       	ld.w	r8,r8[0x0]
8000462c:	c0 28       	rjmp	80004630 <phy_payload_tx+0x34>
8000462e:	30 08       	mov	r8,0
80004630:	fe f9 05 94 	ld.w	r9,pc[1428]
80004634:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80004636:	fe f8 05 92 	ld.w	r8,pc[1426]
8000463a:	70 08       	ld.w	r8,r8[0x0]
8000463c:	58 68       	cp.w	r8,6
8000463e:	e0 8b 02 a4 	brhi	80004b86 <phy_payload_tx+0x58a>
80004642:	fe f9 05 8a 	ld.w	r9,pc[1418]
80004646:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
8000464a:	fe f8 05 86 	ld.w	r8,pc[1414]
8000464e:	70 08       	ld.w	r8,r8[0x0]
80004650:	58 08       	cp.w	r8,0
80004652:	c0 b0       	breq	80004668 <phy_payload_tx+0x6c>
80004654:	fe f8 05 7c 	ld.w	r8,pc[1404]
80004658:	70 08       	ld.w	r8,r8[0x0]
8000465a:	58 a8       	cp.w	r8,10
8000465c:	c0 60       	breq	80004668 <phy_payload_tx+0x6c>
8000465e:	fe f8 05 72 	ld.w	r8,pc[1394]
80004662:	70 08       	ld.w	r8,r8[0x0]
80004664:	58 18       	cp.w	r8,1
80004666:	c0 f1       	brne	80004684 <phy_payload_tx+0x88>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004668:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000466c:	e0 69 5a 5a 	mov	r9,23130
80004670:	ea 19 ab cd 	orh	r9,0xabcd
80004674:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004676:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000467a:	30 09       	mov	r9,0
8000467c:	91 19       	st.w	r8[0x4],r9
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
8000467e:	d7 03       	nop
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004680:	e0 8f 02 9d 	bral	80004bba <phy_payload_tx+0x5be>
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80004684:	fe f8 05 4c 	ld.w	r8,pc[1356]
80004688:	70 08       	ld.w	r8,r8[0x0]
8000468a:	58 38       	cp.w	r8,3
8000468c:	c0 f1       	brne	800046aa <phy_payload_tx+0xae>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
8000468e:	fe f8 05 46 	ld.w	r8,pc[1350]
80004692:	70 09       	ld.w	r9,r8[0x0]
80004694:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004698:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
8000469a:	fe f8 05 3a 	ld.w	r8,pc[1338]
8000469e:	70 19       	ld.w	r9,r8[0x4]
800046a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046a4:	91 19       	st.w	r8[0x4],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
800046a6:	e0 8f 02 8a 	bral	80004bba <phy_payload_tx+0x5be>
				else//
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//
800046aa:	fe f8 05 26 	ld.w	r8,pc[1318]
800046ae:	70 08       	ld.w	r8,r8[0x0]
800046b0:	58 28       	cp.w	r8,2
800046b2:	c1 a1       	brne	800046e6 <phy_payload_tx+0xea>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
800046b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046b8:	e0 69 c0 32 	mov	r9,49202
800046bc:	ea 19 ab cd 	orh	r9,0xabcd
800046c0:	91 09       	st.w	r8[0x0],r9
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
800046c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046c6:	fe 78 84 7f 	mov	r8,-31617
800046ca:	b2 28       	st.h	r9[0x4],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
800046cc:	fe f8 05 0c 	ld.w	r8,pc[1292]
800046d0:	90 08       	ld.sh	r8,r8[0x0]
800046d2:	5c 88       	casts.h	r8
800046d4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800046d8:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
800046da:	fe f8 04 ee 	ld.w	r8,pc[1262]
800046de:	30 39       	mov	r9,3
800046e0:	91 09       	st.w	r8[0x0],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
800046e2:	e0 8f 02 6c 	bral	80004bba <phy_payload_tx+0x5be>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
800046e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046ea:	e0 69 c0 0e 	mov	r9,49166
800046ee:	ea 19 ab cd 	orh	r9,0xabcd
800046f2:	91 09       	st.w	r8[0x0],r9
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
800046f4:	fe f8 04 e8 	ld.w	r8,pc[1256]
800046f8:	90 08       	ld.sh	r8,r8[0x0]
800046fa:	5c 88       	casts.h	r8
800046fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004700:	b2 28       	st.h	r9[0x4],r8
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80004702:	fe f8 04 da 	ld.w	r8,pc[1242]
80004706:	90 18       	ld.sh	r8,r8[0x2]
80004708:	5c 88       	casts.h	r8
8000470a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000470e:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80004710:	fe f8 04 b8 	ld.w	r8,pc[1208]
80004714:	30 19       	mov	r9,1
80004716:	91 09       	st.w	r8[0x0],r9
					}

				}
				
				break;
80004718:	e0 8f 02 51 	bral	80004bba <phy_payload_tx+0x5be>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
8000471c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004720:	fe 78 88 f2 	mov	r8,-30478
80004724:	b2 08       	st.h	r9[0x0],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//
80004726:	fe f8 04 aa 	ld.w	r8,pc[1194]
8000472a:	70 08       	ld.w	r8,r8[0x0]
8000472c:	58 48       	cp.w	r8,4
8000472e:	c0 60       	breq	8000473a <phy_payload_tx+0x13e>
80004730:	c7 73       	brcs	8000481e <phy_payload_tx+0x222>
80004732:	58 98       	cp.w	r8,9
80004734:	e0 8b 00 75 	brhi	8000481e <phy_payload_tx+0x222>
80004738:	c4 78       	rjmp	800047c6 <phy_payload_tx+0x1ca>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
8000473a:	fe f8 04 a6 	ld.w	r8,pc[1190]
8000473e:	11 89       	ld.ub	r9,r8[0x0]
80004740:	30 18       	mov	r8,1
80004742:	f0 09 18 00 	cp.b	r9,r8
80004746:	c1 41       	brne	8000476e <phy_payload_tx+0x172>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80004748:	fe f8 04 9c 	ld.w	r8,pc[1180]
8000474c:	90 08       	ld.sh	r8,r8[0x0]
8000474e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004752:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80004754:	fe f8 04 90 	ld.w	r8,pc[1168]
80004758:	90 18       	ld.sh	r8,r8[0x2]
8000475a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000475e:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80004760:	fe f8 04 84 	ld.w	r8,pc[1156]
80004764:	90 28       	ld.sh	r8,r8[0x4]
80004766:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000476a:	b2 38       	st.h	r9[0x6],r8
8000476c:	c2 88       	rjmp	800047bc <phy_payload_tx+0x1c0>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000476e:	fe f8 04 76 	ld.w	r8,pc[1142]
80004772:	90 09       	ld.sh	r9,r8[0x0]
80004774:	fe f8 04 74 	ld.w	r8,pc[1140]
80004778:	90 08       	ld.sh	r8,r8[0x0]
8000477a:	5c 88       	casts.h	r8
8000477c:	f3 e8 20 08 	eor	r8,r9,r8
80004780:	5c 88       	casts.h	r8
80004782:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004786:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80004788:	fe f8 04 5c 	ld.w	r8,pc[1116]
8000478c:	90 19       	ld.sh	r9,r8[0x2]
8000478e:	fe f8 04 5a 	ld.w	r8,pc[1114]
80004792:	90 18       	ld.sh	r8,r8[0x2]
80004794:	5c 88       	casts.h	r8
80004796:	f3 e8 20 08 	eor	r8,r9,r8
8000479a:	5c 88       	casts.h	r8
8000479c:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047a0:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800047a2:	fe f8 04 42 	ld.w	r8,pc[1090]
800047a6:	90 29       	ld.sh	r9,r8[0x4]
800047a8:	fe f8 04 40 	ld.w	r8,pc[1088]
800047ac:	90 28       	ld.sh	r8,r8[0x4]
800047ae:	5c 88       	casts.h	r8
800047b0:	f3 e8 20 08 	eor	r8,r9,r8
800047b4:	5c 88       	casts.h	r8
800047b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047ba:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
800047bc:	fe f8 04 0c 	ld.w	r8,pc[1036]
800047c0:	30 29       	mov	r9,2
800047c2:	91 09       	st.w	r8[0x0],r9
					
						break;
800047c4:	c3 e8       	rjmp	80004840 <phy_payload_tx+0x244>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800047c6:	fe f8 04 1e 	ld.w	r8,pc[1054]
800047ca:	90 09       	ld.sh	r9,r8[0x0]
800047cc:	fe f8 04 1c 	ld.w	r8,pc[1052]
800047d0:	90 08       	ld.sh	r8,r8[0x0]
800047d2:	5c 88       	casts.h	r8
800047d4:	f3 e8 20 08 	eor	r8,r9,r8
800047d8:	5c 88       	casts.h	r8
800047da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047de:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800047e0:	fe f8 04 04 	ld.w	r8,pc[1028]
800047e4:	90 19       	ld.sh	r9,r8[0x2]
800047e6:	fe f8 04 02 	ld.w	r8,pc[1026]
800047ea:	90 18       	ld.sh	r8,r8[0x2]
800047ec:	5c 88       	casts.h	r8
800047ee:	f3 e8 20 08 	eor	r8,r9,r8
800047f2:	5c 88       	casts.h	r8
800047f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047f8:	b2 28       	st.h	r9[0x4],r8
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800047fa:	fe f8 03 ea 	ld.w	r8,pc[1002]
800047fe:	90 29       	ld.sh	r9,r8[0x4]
80004800:	fe f8 03 e8 	ld.w	r8,pc[1000]
80004804:	90 28       	ld.sh	r8,r8[0x4]
80004806:	5c 88       	casts.h	r8
80004808:	f3 e8 20 08 	eor	r8,r9,r8
8000480c:	5c 88       	casts.h	r8
8000480e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004812:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80004814:	fe f8 03 b4 	ld.w	r8,pc[948]
80004818:	30 29       	mov	r9,2
8000481a:	91 09       	st.w	r8[0x0],r9
				
						break;
8000481c:	c1 28       	rjmp	80004840 <phy_payload_tx+0x244>
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000481e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004822:	e0 69 5a 5a 	mov	r9,23130
80004826:	ea 19 ab cd 	orh	r9,0xabcd
8000482a:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000482c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004830:	30 09       	mov	r9,0
80004832:	91 19       	st.w	r8[0x4],r9
							
							AMBEpayload_tx_state = AMBE_IDLE;
80004834:	fe f8 03 94 	ld.w	r8,pc[916]
80004838:	30 09       	mov	r9,0
8000483a:	91 09       	st.w	r8[0x0],r9
				}
		
		
		
		
				break;
8000483c:	e0 8f 01 bf 	bral	80004bba <phy_payload_tx+0x5be>
80004840:	e0 8f 01 bd 	bral	80004bba <phy_payload_tx+0x5be>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80004844:	fe f8 03 a4 	ld.w	r8,pc[932]
80004848:	90 38       	ld.sh	r8,r8[0x6]
8000484a:	5c 88       	casts.h	r8
8000484c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004850:	b2 08       	st.h	r9[0x0],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80004852:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004856:	e0 68 00 ba 	mov	r8,186
8000485a:	b2 18       	st.h	r9[0x2],r8
					payload_tx_channel->word[2]	= 0x0000 ;
8000485c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004860:	30 08       	mov	r8,0
80004862:	b2 28       	st.h	r9[0x4],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80004864:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004868:	30 08       	mov	r8,0
8000486a:	b2 38       	st.h	r9[0x6],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
8000486c:	fe f8 03 5c 	ld.w	r8,pc[860]
80004870:	30 09       	mov	r9,0
80004872:	91 09       	st.w	r8[0x0],r9
				
				break;
80004874:	e0 8f 01 a3 	bral	80004bba <phy_payload_tx+0x5be>
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80004878:	fe f8 03 60 	ld.w	r8,pc[864]
8000487c:	90 18       	ld.sh	r8,r8[0x2]
8000487e:	5c 88       	casts.h	r8
80004880:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004884:	b2 08       	st.h	r9[0x0],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80004886:	fe f8 03 56 	ld.w	r8,pc[854]
8000488a:	90 08       	ld.sh	r8,r8[0x0]
8000488c:	5c 88       	casts.h	r8
8000488e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004892:	b2 18       	st.h	r9[0x2],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80004894:	fe f8 03 3c 	ld.w	r8,pc[828]
80004898:	70 08       	ld.w	r8,r8[0x0]
8000489a:	58 48       	cp.w	r8,4
8000489c:	c1 21       	brne	800048c0 <phy_payload_tx+0x2c4>
8000489e:	fe f8 03 42 	ld.w	r8,pc[834]
800048a2:	11 89       	ld.ub	r9,r8[0x0]
800048a4:	30 18       	mov	r8,1
800048a6:	f0 09 18 00 	cp.b	r9,r8
800048aa:	c0 b1       	brne	800048c0 <phy_payload_tx+0x2c4>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
800048ac:	fe f8 03 30 	ld.w	r8,pc[816]
800048b0:	90 18       	ld.sh	r8,r8[0x2]
800048b2:	5c 88       	casts.h	r8
800048b4:	a9 a8       	sbr	r8,0x8
800048b6:	5c 88       	casts.h	r8
800048b8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048bc:	b2 28       	st.h	r9[0x4],r8
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
800048be:	c0 88       	rjmp	800048ce <phy_payload_tx+0x2d2>
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
800048c0:	fe f8 03 1c 	ld.w	r8,pc[796]
800048c4:	90 18       	ld.sh	r8,r8[0x2]
800048c6:	5c 88       	casts.h	r8
800048c8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048cc:	b2 28       	st.h	r9[0x4],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
800048ce:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048d2:	fe 78 9a 13 	mov	r8,-26093
800048d6:	b2 38       	st.h	r9[0x6],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
800048d8:	fe f8 02 f0 	ld.w	r8,pc[752]
800048dc:	30 49       	mov	r9,4
800048de:	91 09       	st.w	r8[0x0],r9
					
				break;
800048e0:	e0 8f 01 6d 	bral	80004bba <phy_payload_tx+0x5be>
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800048e4:	fe f8 03 08 	ld.w	r8,pc[776]
800048e8:	70 09       	ld.w	r9,r8[0x0]
800048ea:	fe f8 03 06 	ld.w	r8,pc[774]
800048ee:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800048f2:	5c 88       	casts.h	r8
800048f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048f8:	b2 08       	st.h	r9[0x0],r8
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
800048fa:	fe f8 02 f2 	ld.w	r8,pc[754]
800048fe:	70 08       	ld.w	r8,r8[0x0]
80004900:	f0 c9 ff ff 	sub	r9,r8,-1
80004904:	fe f8 02 ec 	ld.w	r8,pc[748]
80004908:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000490c:	5c 88       	casts.h	r8
8000490e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004912:	b2 18       	st.h	r9[0x2],r8
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80004914:	fe f8 02 d8 	ld.w	r8,pc[728]
80004918:	70 08       	ld.w	r8,r8[0x0]
8000491a:	f0 c9 ff fe 	sub	r9,r8,-2
8000491e:	fe f8 02 d2 	ld.w	r8,pc[722]
80004922:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004926:	5c 88       	casts.h	r8
80004928:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000492c:	b2 28       	st.h	r9[0x4],r8
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
8000492e:	fe f8 02 be 	ld.w	r8,pc[702]
80004932:	70 08       	ld.w	r8,r8[0x0]
80004934:	f0 c9 ff fd 	sub	r9,r8,-3
80004938:	fe f8 02 b8 	ld.w	r8,pc[696]
8000493c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004940:	5c 88       	casts.h	r8
80004942:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004946:	b2 38       	st.h	r9[0x6],r8
						Soft_index +=4;
80004948:	fe f8 02 a4 	ld.w	r8,pc[676]
8000494c:	70 08       	ld.w	r8,r8[0x0]
8000494e:	f0 c9 ff fc 	sub	r9,r8,-4
80004952:	fe f8 02 9a 	ld.w	r8,pc[666]
80004956:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80004958:	fe f8 02 94 	ld.w	r8,pc[660]
8000495c:	70 08       	ld.w	r8,r8[0x0]
8000495e:	58 c8       	cp.w	r8,12
80004960:	c0 71       	brne	8000496e <phy_payload_tx+0x372>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80004962:	fe f8 02 66 	ld.w	r8,pc[614]
80004966:	30 59       	mov	r9,5
80004968:	91 09       	st.w	r8[0x0],r9
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
			
				break;	
8000496a:	e0 8f 01 28 	bral	80004bba <phy_payload_tx+0x5be>
							AMBEpayload_tx_state = AMBE_DE_THIRD;
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
8000496e:	fe f8 02 5a 	ld.w	r8,pc[602]
80004972:	30 49       	mov	r9,4
80004974:	91 09       	st.w	r8[0x0],r9
			
				break;	
80004976:	e0 8f 01 22 	bral	80004bba <phy_payload_tx+0x5be>
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
8000497a:	fe f8 02 72 	ld.w	r8,pc[626]
8000497e:	70 09       	ld.w	r9,r8[0x0]
80004980:	fe f8 02 70 	ld.w	r8,pc[624]
80004984:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004988:	5c 88       	casts.h	r8
8000498a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000498e:	b2 08       	st.h	r9[0x0],r8
					Soft_index = 0 ;//
80004990:	fe f8 02 5c 	ld.w	r8,pc[604]
80004994:	30 09       	mov	r9,0
80004996:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 
					payload_tx_channel->word[1] = 0x8003;
80004998:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000499c:	fe 78 80 03 	mov	r8,-32765
800049a0:	b2 18       	st.h	r9[0x2],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800049a2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800049a6:	fe 78 88 f3 	mov	r8,-30477
800049aa:	b2 28       	st.h	r9[0x4],r8
				
					switch (m_RxBurstType)//
800049ac:	fe f8 02 24 	ld.w	r8,pc[548]
800049b0:	70 08       	ld.w	r8,r8[0x0]
800049b2:	58 48       	cp.w	r8,4
800049b4:	c0 60       	breq	800049c0 <phy_payload_tx+0x3c4>
800049b6:	c3 e3       	brcs	80004a32 <phy_payload_tx+0x436>
800049b8:	58 98       	cp.w	r8,9
800049ba:	e0 8b 00 3c 	brhi	80004a32 <phy_payload_tx+0x436>
800049be:	c2 98       	rjmp	80004a10 <phy_payload_tx+0x414>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800049c0:	fe f8 02 20 	ld.w	r8,pc[544]
800049c4:	11 89       	ld.ub	r9,r8[0x0]
800049c6:	30 18       	mov	r8,1
800049c8:	f0 09 18 00 	cp.b	r9,r8
800049cc:	c1 01       	brne	800049ec <phy_payload_tx+0x3f0>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800049ce:	fe f8 02 1a 	ld.w	r8,pc[538]
800049d2:	90 08       	ld.sh	r8,r8[0x0]
800049d4:	5c 88       	casts.h	r8
800049d6:	fe f9 02 1e 	ld.w	r9,pc[542]
800049da:	b2 08       	st.h	r9[0x0],r8
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
800049dc:	fe f8 02 0c 	ld.w	r8,pc[524]
800049e0:	90 08       	ld.sh	r8,r8[0x0]
800049e2:	5c 88       	casts.h	r8
800049e4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800049e8:	b2 38       	st.h	r9[0x6],r8
800049ea:	c0 f8       	rjmp	80004a08 <phy_payload_tx+0x40c>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800049ec:	fe f8 02 08 	ld.w	r8,pc[520]
800049f0:	90 08       	ld.sh	r8,r8[0x0]
800049f2:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800049f6:	4f d8       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
800049f8:	90 08       	ld.sh	r8,r8[0x0]
800049fa:	5c 88       	casts.h	r8
800049fc:	f3 e8 20 08 	eor	r8,r9,r8
80004a00:	5c 88       	casts.h	r8
80004a02:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004a06:	b2 38       	st.h	r9[0x6],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80004a08:	4f 08       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004a0a:	30 69       	mov	r9,6
80004a0c:	91 09       	st.w	r8[0x0],r9
					
							break;
80004a0e:	c2 18       	rjmp	80004a50 <phy_payload_tx+0x454>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004a10:	4f 98       	lddpc	r8,80004bf4 <phy_payload_tx+0x5f8>
80004a12:	90 08       	ld.sh	r8,r8[0x0]
80004a14:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004a18:	4f 48       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004a1a:	90 08       	ld.sh	r8,r8[0x0]
80004a1c:	5c 88       	casts.h	r8
80004a1e:	f3 e8 20 08 	eor	r8,r9,r8
80004a22:	5c 88       	casts.h	r8
80004a24:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004a28:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80004a2a:	4e 88       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004a2c:	30 69       	mov	r9,6
80004a2e:	91 09       	st.w	r8[0x0],r9
				
							break;
80004a30:	c1 08       	rjmp	80004a50 <phy_payload_tx+0x454>
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004a32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a36:	e0 69 5a 5a 	mov	r9,23130
80004a3a:	ea 19 ab cd 	orh	r9,0xabcd
80004a3e:	91 09       	st.w	r8[0x0],r9
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004a40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a44:	30 09       	mov	r9,0
80004a46:	91 19       	st.w	r8[0x4],r9
								AMBEpayload_tx_state = AMBE_IDLE;
80004a48:	4e 08       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004a4a:	30 09       	mov	r9,0
80004a4c:	91 09       	st.w	r8[0x0],r9
					
							break;
					}
		
					break;
80004a4e:	cb 68       	rjmp	80004bba <phy_payload_tx+0x5be>
80004a50:	cb 58       	rjmp	80004bba <phy_payload_tx+0x5be>
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//
80004a52:	4e 08       	lddpc	r8,80004bd0 <phy_payload_tx+0x5d4>
80004a54:	70 08       	ld.w	r8,r8[0x0]
80004a56:	58 48       	cp.w	r8,4
80004a58:	c0 70       	breq	80004a66 <phy_payload_tx+0x46a>
80004a5a:	e0 83 00 85 	brlo	80004b64 <phy_payload_tx+0x568>
80004a5e:	58 98       	cp.w	r8,9
80004a60:	e0 8b 00 82 	brhi	80004b64 <phy_payload_tx+0x568>
80004a64:	c5 78       	rjmp	80004b12 <phy_payload_tx+0x516>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80004a66:	4d f8       	lddpc	r8,80004be0 <phy_payload_tx+0x5e4>
80004a68:	11 89       	ld.ub	r9,r8[0x0]
80004a6a:	30 18       	mov	r8,1
80004a6c:	f0 09 18 00 	cp.b	r9,r8
80004a70:	c2 81       	brne	80004ac0 <phy_payload_tx+0x4c4>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80004a72:	4d e8       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004a74:	90 18       	ld.sh	r8,r8[0x2]
80004a76:	5c 88       	casts.h	r8
80004a78:	4d f9       	lddpc	r9,80004bf4 <phy_payload_tx+0x5f8>
80004a7a:	b2 18       	st.h	r9[0x2],r8
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80004a7c:	4d b8       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004a7e:	90 28       	ld.sh	r8,r8[0x4]
80004a80:	5c 88       	casts.h	r8
80004a82:	4d d9       	lddpc	r9,80004bf4 <phy_payload_tx+0x5f8>
80004a84:	b2 28       	st.h	r9[0x4],r8
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80004a86:	4d 98       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004a88:	90 38       	ld.sh	r8,r8[0x6]
80004a8a:	5c 88       	casts.h	r8
80004a8c:	4d a9       	lddpc	r9,80004bf4 <phy_payload_tx+0x5f8>
80004a8e:	b2 38       	st.h	r9[0x6],r8
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80004a90:	4d 68       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004a92:	90 18       	ld.sh	r8,r8[0x2]
80004a94:	5c 88       	casts.h	r8
80004a96:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004a9a:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80004a9c:	4d 38       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004a9e:	90 28       	ld.sh	r8,r8[0x4]
80004aa0:	5c 88       	casts.h	r8
80004aa2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004aa6:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80004aa8:	4d 08       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004aaa:	90 38       	ld.sh	r8,r8[0x6]
80004aac:	5c 88       	casts.h	r8
80004aae:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ab2:	b2 28       	st.h	r9[0x4],r8
									payload_tx_channel->word[3] = 0x00BA ;
80004ab4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ab8:	e0 68 00 ba 	mov	r8,186
80004abc:	b2 38       	st.h	r9[0x6],r8
80004abe:	c2 68       	rjmp	80004b0a <phy_payload_tx+0x50e>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80004ac0:	4c a8       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004ac2:	90 18       	ld.sh	r8,r8[0x2]
80004ac4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004ac8:	4c b8       	lddpc	r8,80004bf4 <phy_payload_tx+0x5f8>
80004aca:	90 18       	ld.sh	r8,r8[0x2]
80004acc:	5c 88       	casts.h	r8
80004ace:	f3 e8 20 08 	eor	r8,r9,r8
80004ad2:	5c 88       	casts.h	r8
80004ad4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ad8:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80004ada:	4c 48       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004adc:	90 28       	ld.sh	r8,r8[0x4]
80004ade:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004ae2:	4c 58       	lddpc	r8,80004bf4 <phy_payload_tx+0x5f8>
80004ae4:	90 28       	ld.sh	r8,r8[0x4]
80004ae6:	5c 88       	casts.h	r8
80004ae8:	f3 e8 20 08 	eor	r8,r9,r8
80004aec:	5c 88       	casts.h	r8
80004aee:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004af2:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80004af4:	4b d8       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004af6:	90 38       	ld.sh	r8,r8[0x6]
80004af8:	5c 88       	casts.h	r8
80004afa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004afe:	b2 28       	st.h	r9[0x4],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80004b00:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b04:	e0 68 00 ba 	mov	r8,186
80004b08:	b2 38       	st.h	r9[0x6],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80004b0a:	4b 08       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004b0c:	30 09       	mov	r9,0
80004b0e:	91 09       	st.w	r8[0x0],r9
						
						break;
80004b10:	c3 98       	rjmp	80004b82 <phy_payload_tx+0x586>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80004b12:	4b 68       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004b14:	90 18       	ld.sh	r8,r8[0x2]
80004b16:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004b1a:	4b 78       	lddpc	r8,80004bf4 <phy_payload_tx+0x5f8>
80004b1c:	90 18       	ld.sh	r8,r8[0x2]
80004b1e:	5c 88       	casts.h	r8
80004b20:	f3 e8 20 08 	eor	r8,r9,r8
80004b24:	5c 88       	casts.h	r8
80004b26:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b2a:	b2 08       	st.h	r9[0x0],r8
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80004b2c:	4a f8       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004b2e:	90 28       	ld.sh	r8,r8[0x4]
80004b30:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004b34:	4b 08       	lddpc	r8,80004bf4 <phy_payload_tx+0x5f8>
80004b36:	90 28       	ld.sh	r8,r8[0x4]
80004b38:	5c 88       	casts.h	r8
80004b3a:	f3 e8 20 08 	eor	r8,r9,r8
80004b3e:	5c 88       	casts.h	r8
80004b40:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b44:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80004b46:	4a 98       	lddpc	r8,80004be8 <phy_payload_tx+0x5ec>
80004b48:	90 38       	ld.sh	r8,r8[0x6]
80004b4a:	5c 88       	casts.h	r8
80004b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b50:	b2 28       	st.h	r9[0x4],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80004b52:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b56:	e0 68 00 ba 	mov	r8,186
80004b5a:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80004b5c:	49 b8       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004b5e:	30 09       	mov	r9,0
80004b60:	91 09       	st.w	r8[0x0],r9
						
							break;
80004b62:	c1 08       	rjmp	80004b82 <phy_payload_tx+0x586>
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004b64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b68:	e0 69 5a 5a 	mov	r9,23130
80004b6c:	ea 19 ab cd 	orh	r9,0xabcd
80004b70:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004b72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b76:	30 09       	mov	r9,0
80004b78:	91 19       	st.w	r8[0x4],r9
							AMBEpayload_tx_state = AMBE_IDLE;
80004b7a:	49 48       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004b7c:	30 09       	mov	r9,0
80004b7e:	91 09       	st.w	r8[0x0],r9
							
							break;
					}

				break;
80004b80:	c1 d8       	rjmp	80004bba <phy_payload_tx+0x5be>
80004b82:	d7 03       	nop
80004b84:	c1 b8       	rjmp	80004bba <phy_payload_tx+0x5be>
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004b86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b8a:	e0 69 5a 5a 	mov	r9,23130
80004b8e:	ea 19 ab cd 	orh	r9,0xabcd
80004b92:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004b94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b98:	30 09       	mov	r9,0
80004b9a:	91 19       	st.w	r8[0x4],r9
					
					AMBEpayload_tx_state = AMBE_IDLE;
80004b9c:	48 b8       	lddpc	r8,80004bc8 <phy_payload_tx+0x5cc>
80004b9e:	30 09       	mov	r9,0
80004ba0:	91 09       	st.w	r8[0x0],r9
80004ba2:	c0 c8       	rjmp	80004bba <phy_payload_tx+0x5be>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004ba4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ba8:	e0 69 5a 5a 	mov	r9,23130
80004bac:	ea 19 ab cd 	orh	r9,0xabcd
80004bb0:	91 09       	st.w	r8[0x0],r9
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004bb2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bb6:	30 09       	mov	r9,0
80004bb8:	91 19       	st.w	r8[0x4],r9

	}//end of Send-PCM-data
	
#endif

}
80004bba:	2f fd       	sub	sp,-4
80004bbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bc0:	00 00       	add	r0,r0
80004bc2:	0a 53       	eor	r3,r5
80004bc4:	00 00       	add	r0,r0
80004bc6:	0a c4       	st.b	r5++,r4
80004bc8:	00 00       	add	r0,r0
80004bca:	0a c8       	st.b	r5++,r8
80004bcc:	80 01       	ld.sh	r1,r0[0x0]
80004bce:	04 84       	andn	r4,r2
80004bd0:	00 00       	add	r0,r0
80004bd2:	0a 94       	mov	r4,r5
80004bd4:	00 00       	add	r0,r0
80004bd6:	0a 98       	mov	r8,r5
80004bd8:	00 00       	add	r0,r0
80004bda:	0d a0       	ld.ub	r0,r6[0x2]
80004bdc:	00 00       	add	r0,r0
80004bde:	0e 9c       	mov	r12,r7
80004be0:	00 00       	add	r0,r0
80004be2:	0a 57       	eor	r7,r5
80004be4:	80 01       	ld.sh	r1,r0[0x0]
80004be6:	04 34       	cp.w	r4,r2
80004be8:	00 00       	add	r0,r0
80004bea:	0d 98       	ld.ub	r8,r6[0x1]
80004bec:	00 00       	add	r0,r0
80004bee:	0a cc       	st.b	r5++,r12
80004bf0:	00 00       	add	r0,r0
80004bf2:	0e a0       	st.w	r7++,r0
80004bf4:	00 00       	add	r0,r0
80004bf6:	0d a4       	ld.ub	r4,r6[0x2]

80004bf8 <payload_rx>:




static void payload_rx(void * payload)
{
80004bf8:	eb cd 40 80 	pushm	r7,lr
80004bfc:	1a 97       	mov	r7,sp
80004bfe:	20 2d       	sub	sp,8
80004c00:	ef 4c ff f8 	st.w	r7[-8],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80004c04:	30 08       	mov	r8,0
80004c06:	ef 48 ff fc 	st.w	r7[-4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80004c0a:	49 48       	lddpc	r8,80004c58 <payload_rx+0x60>
80004c0c:	70 08       	ld.w	r8,r8[0x0]
80004c0e:	58 08       	cp.w	r8,0
80004c10:	c0 81       	brne	80004c20 <payload_rx+0x28>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80004c12:	30 4b       	mov	r11,4
80004c14:	30 5c       	mov	r12,5
80004c16:	f0 1f 00 12 	mcall	80004c5c <payload_rx+0x64>
80004c1a:	18 99       	mov	r9,r12
80004c1c:	48 f8       	lddpc	r8,80004c58 <payload_rx+0x60>
80004c1e:	91 09       	st.w	r8[0x0],r9
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80004c20:	48 e8       	lddpc	r8,80004c58 <payload_rx+0x60>
80004c22:	70 08       	ld.w	r8,r8[0x0]
80004c24:	ee ca 00 04 	sub	r10,r7,4
80004c28:	ee cb 00 08 	sub	r11,r7,8
80004c2c:	30 09       	mov	r9,0
80004c2e:	10 9c       	mov	r12,r8
80004c30:	f0 1f 00 0c 	mcall	80004c60 <payload_rx+0x68>
80004c34:	18 98       	mov	r8,r12
80004c36:	58 08       	cp.w	r8,0
80004c38:	c0 c1       	brne	80004c50 <payload_rx+0x58>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80004c3a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c3e:	48 a8       	lddpc	r8,80004c64 <payload_rx+0x6c>
80004c40:	70 08       	ld.w	r8,r8[0x0]
80004c42:	12 9b       	mov	r11,r9
80004c44:	10 9c       	mov	r12,r8
80004c46:	f0 1f 00 09 	mcall	80004c68 <payload_rx+0x70>
		logFromISR("mm");
80004c4a:	48 9c       	lddpc	r12,80004c6c <payload_rx+0x74>
80004c4c:	f0 1f 00 09 	mcall	80004c70 <payload_rx+0x78>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80004c50:	2f ed       	sub	sp,-8
80004c52:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c56:	00 00       	add	r0,r0
80004c58:	00 00       	add	r0,r0
80004c5a:	0a 90       	mov	r0,r5
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	85 40       	st.w	r2[0x10],r0
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	87 c0       	st.w	r3[0x30],r0
80004c64:	00 00       	add	r0,r0
80004c66:	0a 88       	andn	r8,r5
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	5c 04       	acr	r4
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	3e b4       	mov	r4,-21
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	a1 f4       	*unknown*

80004c74 <phy_payload_rx>:
Description: receive payload(mdia) packet
Calls: 
Called By:phy_rx_func
*/
static void phy_payload_rx(payload_channel_t * payload_rx_channel)
{
80004c74:	eb cd 40 80 	pushm	r7,lr
80004c78:	1a 97       	mov	r7,sp
80004c7a:	20 2d       	sub	sp,8
80004c7c:	ef 4c ff f8 	st.w	r7[-8],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80004c80:	30 08       	mov	r8,0
80004c82:	ef 48 ff fc 	st.w	r7[-4],r8
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80004c86:	fe f8 0e 5e 	ld.w	r8,pc[3678]
80004c8a:	11 88       	ld.ub	r8,r8[0x0]
80004c8c:	58 08       	cp.w	r8,0
80004c8e:	c1 01       	brne	80004cae <phy_payload_rx+0x3a>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
80004c90:	fe f8 0e 58 	ld.w	r8,pc[3672]
80004c94:	70 08       	ld.w	r8,r8[0x0]
80004c96:	10 9c       	mov	r12,r8
80004c98:	f0 1f 03 95 	mcall	80005aec <phy_payload_rx+0xe78>
80004c9c:	18 98       	mov	r8,r12
80004c9e:	10 99       	mov	r9,r8
80004ca0:	fe f8 0e 50 	ld.w	r8,pc[3664]
80004ca4:	91 09       	st.w	r8[0x0],r9
		is_first = TRUE;
80004ca6:	fe f9 0e 3e 	ld.w	r9,pc[3646]
80004caa:	30 18       	mov	r8,1
80004cac:	b2 88       	st.b	r9[0x0],r8
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80004cae:	fe f8 0e 46 	ld.w	r8,pc[3654]
80004cb2:	70 08       	ld.w	r8,r8[0x0]
80004cb4:	58 38       	cp.w	r8,3
80004cb6:	e0 80 06 ad 	breq	80005a10 <phy_payload_rx+0xd9c>
80004cba:	58 48       	cp.w	r8,4
80004cbc:	e0 80 01 4e 	breq	80004f58 <phy_payload_rx+0x2e4>
80004cc0:	58 08       	cp.w	r8,0
80004cc2:	e0 81 07 0e 	brne	80005ade <phy_payload_rx+0xe6a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80004cc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cca:	70 08       	ld.w	r8,r8[0x0]
80004ccc:	e0 69 5a 5a 	mov	r9,23130
80004cd0:	ea 19 ab cd 	orh	r9,0xabcd
80004cd4:	12 38       	cp.w	r8,r9
80004cd6:	c0 71       	brne	80004ce4 <phy_payload_rx+0x70>
			{
				m_RxBurstType = VOICE_WATING;
80004cd8:	fe f8 0e 20 	ld.w	r8,pc[3616]
80004cdc:	30 09       	mov	r9,0
80004cde:	91 09       	st.w	r8[0x0],r9
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
80004ce0:	e0 8f 06 ff 	bral	80005ade <phy_payload_rx+0xe6a>
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004ce4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ce8:	70 08       	ld.w	r8,r8[0x0]
80004cea:	e0 18 00 00 	andl	r8,0x0
80004cee:	fc 19 ab cd 	movh	r9,0xabcd
80004cf2:	12 38       	cp.w	r8,r9
80004cf4:	e0 81 06 ea 	brne	80005ac8 <phy_payload_rx+0xe54>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004cf8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cfc:	70 08       	ld.w	r8,r8[0x0]
80004cfe:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004d02:	fe f8 0d fa 	ld.w	r8,pc[3578]
80004d06:	91 09       	st.w	r8[0x0],r9
		
			if( (NULL== AMBE_payload_ptr))
80004d08:	fe f8 0d e8 	ld.w	r8,pc[3560]
80004d0c:	70 08       	ld.w	r8,r8[0x0]
80004d0e:	58 08       	cp.w	r8,0
80004d10:	c1 71       	brne	80004d3e <phy_payload_rx+0xca>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80004d12:	fe f8 0d d6 	ld.w	r8,pc[3542]
80004d16:	70 08       	ld.w	r8,r8[0x0]
80004d18:	10 9c       	mov	r12,r8
80004d1a:	f0 1f 03 75 	mcall	80005aec <phy_payload_rx+0xe78>
80004d1e:	18 98       	mov	r8,r12
80004d20:	10 99       	mov	r9,r8
80004d22:	fe f8 0d ce 	ld.w	r8,pc[3534]
80004d26:	91 09       	st.w	r8[0x0],r9
				
				if (NULL== AMBE_payload_ptr)
80004d28:	fe f8 0d c8 	ld.w	r8,pc[3528]
80004d2c:	70 08       	ld.w	r8,r8[0x0]
80004d2e:	58 08       	cp.w	r8,0
80004d30:	c0 71       	brne	80004d3e <phy_payload_rx+0xca>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
80004d32:	fe fc 0d ce 	ld.w	r12,pc[3534]
80004d36:	f0 1f 03 74 	mcall	80005b04 <phy_payload_rx+0xe90>
					break;
80004d3a:	e0 8f 06 d2 	bral	80005ade <phy_payload_rx+0xe6a>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80004d3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d42:	70 08       	ld.w	r8,r8[0x0]
80004d44:	e2 18 f0 00 	andl	r8,0xf000,COH
80004d48:	e0 48 c0 00 	cp.w	r8,49152
80004d4c:	e0 81 01 00 	brne	80004f4c <phy_payload_rx+0x2d8>
			{
				AMBE_Media = 1;	
80004d50:	fe f9 0d b8 	ld.w	r9,pc[3512]
80004d54:	30 18       	mov	r8,1
80004d56:	b2 88       	st.b	r9[0x0],r8
											
				Item_ID = payload_rx_channel->byte[5];
80004d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d5c:	11 d8       	ld.ub	r8,r8[0x5]
80004d5e:	fe f9 0d ae 	ld.w	r9,pc[3502]
80004d62:	b2 88       	st.b	r9[0x0],r8
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80004d64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d68:	11 c8       	ld.ub	r8,r8[0x4]
80004d6a:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
80004d6e:	fe f8 0d a2 	ld.w	r8,pc[3490]
80004d72:	91 09       	st.w	r8[0x0],r9
								
				switch(Item_ID)
80004d74:	fe f8 0d 98 	ld.w	r8,pc[3480]
80004d78:	11 88       	ld.ub	r8,r8[0x0]
80004d7a:	5c 58       	castu.b	r8
80004d7c:	e0 48 00 7f 	cp.w	r8,127
80004d80:	e0 80 00 8b 	breq	80004e96 <phy_payload_rx+0x222>
80004d84:	e0 89 00 07 	brgt	80004d92 <phy_payload_rx+0x11e>
80004d88:	59 28       	cp.w	r8,18
80004d8a:	c5 00       	breq	80004e2a <phy_payload_rx+0x1b6>
80004d8c:	59 38       	cp.w	r8,19
80004d8e:	c7 f0       	breq	80004e8c <phy_payload_rx+0x218>
80004d90:	cb 48       	rjmp	80004ef8 <phy_payload_rx+0x284>
80004d92:	f0 c8 00 f0 	sub	r8,r8,240
80004d96:	58 18       	cp.w	r8,1
80004d98:	e0 8b 00 b0 	brhi	80004ef8 <phy_payload_rx+0x284>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80004d9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004da0:	11 e8       	ld.ub	r8,r8[0x6]
80004da2:	e2 18 00 f0 	andl	r8,0xf0,COH
80004da6:	59 08       	cp.w	r8,16
80004da8:	c0 61       	brne	80004db4 <phy_payload_rx+0x140>
							{
								m_RxBurstType = VOICEHEADER;
80004daa:	fe f8 0d 4e 	ld.w	r8,pc[3406]
80004dae:	30 19       	mov	r9,1
80004db0:	91 09       	st.w	r8[0x0],r9
80004db2:	c3 b8       	rjmp	80004e28 <phy_payload_rx+0x1b4>

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80004db4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004db8:	11 e8       	ld.ub	r8,r8[0x6]
80004dba:	e2 18 00 f0 	andl	r8,0xf0,COH
80004dbe:	e0 48 00 20 	cp.w	r8,32
80004dc2:	c2 f1       	brne	80004e20 <phy_payload_rx+0x1ac>
							{
								m_RxBurstType = VOICETERMINATOR;
80004dc4:	fe f8 0d 34 	ld.w	r8,pc[3380]
80004dc8:	30 a9       	mov	r9,10
80004dca:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//0
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80004dcc:	fe f8 0d 48 	ld.w	r8,pc[3400]
80004dd0:	70 08       	ld.w	r8,r8[0x0]
80004dd2:	5c d8       	com	r8
80004dd4:	f0 c9 fe 00 	sub	r9,r8,-512
80004dd8:	fe f8 0d 18 	ld.w	r8,pc[3352]
80004ddc:	70 0a       	ld.w	r10,r8[0x0]
80004dde:	fe f8 0d 36 	ld.w	r8,pc[3382]
80004de2:	70 08       	ld.w	r8,r8[0x0]
80004de4:	2f f8       	sub	r8,-1
80004de6:	f4 08 00 08 	add	r8,r10,r8
80004dea:	12 9a       	mov	r10,r9
80004dec:	30 0b       	mov	r11,0
80004dee:	10 9c       	mov	r12,r8
80004df0:	f0 1f 03 4a 	mcall	80005b18 <phy_payload_rx+0xea4>
								
								RxAMBE_IsFillingNext8 = 0;
80004df4:	fe f8 0d 20 	ld.w	r8,pc[3360]
80004df8:	30 09       	mov	r9,0
80004dfa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004dfc:	fe f8 0c f4 	ld.w	r8,pc[3316]
80004e00:	70 08       	ld.w	r8,r8[0x0]
80004e02:	10 9c       	mov	r12,r8
80004e04:	f0 1f 03 46 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80004e08:	fe f8 0c e0 	ld.w	r8,pc[3296]
80004e0c:	70 08       	ld.w	r8,r8[0x0]
80004e0e:	10 9c       	mov	r12,r8
80004e10:	f0 1f 03 37 	mcall	80005aec <phy_payload_rx+0xe78>
80004e14:	18 98       	mov	r8,r12
80004e16:	10 99       	mov	r9,r8
80004e18:	fe f8 0c d8 	ld.w	r8,pc[3288]
80004e1c:	91 09       	st.w	r8[0x0],r9
80004e1e:	c0 58       	rjmp	80004e28 <phy_payload_rx+0x1b4>
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80004e20:	fe f8 0c d8 	ld.w	r8,pc[3288]
80004e24:	30 09       	mov	r9,0
80004e26:	91 09       	st.w	r8[0x0],r9
							}
							
						break;//WAITINGABAB.
80004e28:	c9 08       	rjmp	80004f48 <phy_payload_rx+0x2d4>
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80004e2a:	fe f8 0c d2 	ld.w	r8,pc[3282]
80004e2e:	70 08       	ld.w	r8,r8[0x0]
80004e30:	f0 c9 00 04 	sub	r9,r8,4
80004e34:	fe f8 0c c8 	ld.w	r8,pc[3272]
80004e38:	91 09       	st.w	r8[0x0],r9
80004e3a:	fe f8 0c c2 	ld.w	r8,pc[3266]
80004e3e:	70 08       	ld.w	r8,r8[0x0]
80004e40:	58 08       	cp.w	r8,0
80004e42:	c0 21       	brne	80004e46 <phy_payload_rx+0x1d2>
80004e44:	c8 28       	rjmp	80004f48 <phy_payload_rx+0x2d4>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004e46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e4a:	11 f8       	ld.ub	r8,r8[0x7]
80004e4c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004e50:	fe f9 0c d0 	ld.w	r9,pc[3280]
80004e54:	b2 88       	st.b	r9[0x0],r8
							
							VBSP_data[0] = payload_rx_channel->word[2];
80004e56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e5a:	90 28       	ld.sh	r8,r8[0x4]
80004e5c:	fe f9 0c c8 	ld.w	r9,pc[3272]
80004e60:	b2 08       	st.h	r9[0x0],r8
							VBSP_data[1] = payload_rx_channel->word[3];
80004e62:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e66:	90 38       	ld.sh	r8,r8[0x6]
80004e68:	fe f9 0c bc 	ld.w	r9,pc[3260]
80004e6c:	b2 18       	st.h	r9[0x2],r8
							
							m_RxBurstType = CalculateBurst(VF_SN);
80004e6e:	fe f8 0c b2 	ld.w	r8,pc[3250]
80004e72:	11 88       	ld.ub	r8,r8[0x0]
80004e74:	10 9c       	mov	r12,r8
80004e76:	f0 1f 03 2d 	mcall	80005b28 <phy_payload_rx+0xeb4>
80004e7a:	18 99       	mov	r9,r12
80004e7c:	fe f8 0c 7c 	ld.w	r8,pc[3196]
80004e80:	91 09       	st.w	r8[0x0],r9
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80004e82:	fe f8 0c 72 	ld.w	r8,pc[3186]
80004e86:	30 49       	mov	r9,4
80004e88:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_MEDIA
80004e8a:	c5 f8       	rjmp	80004f48 <phy_payload_rx+0x2d4>
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80004e8c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80004e90:	30 09       	mov	r9,0
80004e92:	91 09       	st.w	r8[0x0],r9
						
						break;//WAITINGABAB.
80004e94:	c5 a8       	rjmp	80004f48 <phy_payload_rx+0x2d4>
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80004e96:	fe f8 0c 66 	ld.w	r8,pc[3174]
80004e9a:	70 08       	ld.w	r8,r8[0x0]
80004e9c:	f0 c9 00 04 	sub	r9,r8,4
80004ea0:	fe f8 0c 5c 	ld.w	r8,pc[3164]
80004ea4:	91 09       	st.w	r8[0x0],r9
80004ea6:	fe f8 0c 56 	ld.w	r8,pc[3158]
80004eaa:	70 08       	ld.w	r8,r8[0x0]
80004eac:	58 08       	cp.w	r8,0
80004eae:	c0 21       	brne	80004eb2 <phy_payload_rx+0x23e>
80004eb0:	c4 c8       	rjmp	80004f48 <phy_payload_rx+0x2d4>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80004eb2:	fe f8 0c 7a 	ld.w	r8,pc[3194]
80004eb6:	70 0a       	ld.w	r10,r8[0x0]
80004eb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ebc:	90 38       	ld.sh	r8,r8[0x6]
80004ebe:	fe f9 0c 72 	ld.w	r9,pc[3186]
80004ec2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							RxData_IsFillingNext16 += 1; 
80004ec6:	fe f8 0c 66 	ld.w	r8,pc[3174]
80004eca:	70 08       	ld.w	r8,r8[0x0]
80004ecc:	f0 c9 ff ff 	sub	r9,r8,-1
80004ed0:	fe f8 0c 5c 	ld.w	r8,pc[3164]
80004ed4:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80004ed6:	fe f8 0c 3a 	ld.w	r8,pc[3130]
80004eda:	70 08       	ld.w	r8,r8[0x0]
80004edc:	f0 c9 00 02 	sub	r9,r8,2
80004ee0:	fe f8 0c 30 	ld.w	r8,pc[3120]
80004ee4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80004ee6:	fe f8 0c 12 	ld.w	r8,pc[3090]
80004eea:	30 29       	mov	r9,2
80004eec:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80004eee:	fe f8 0c 06 	ld.w	r8,pc[3078]
80004ef2:	30 39       	mov	r9,3
80004ef4:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_AUX
80004ef6:	c2 98       	rjmp	80004f48 <phy_payload_rx+0x2d4>
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80004ef8:	fe f8 0c 00 	ld.w	r8,pc[3072]
80004efc:	30 39       	mov	r9,3
80004efe:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80004f00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f04:	70 09       	ld.w	r9,r8[0x0]
80004f06:	fe f8 0c 2e 	ld.w	r8,pc[3118]
80004f0a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80004f0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f10:	70 19       	ld.w	r9,r8[0x4]
80004f12:	fe f8 0c 22 	ld.w	r8,pc[3106]
80004f16:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80004f18:	fe f8 0b e4 	ld.w	r8,pc[3044]
80004f1c:	70 08       	ld.w	r8,r8[0x0]
80004f1e:	59 48       	cp.w	r8,20
80004f20:	c0 51       	brne	80004f2a <phy_payload_rx+0x2b6>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80004f22:	fe f8 0b da 	ld.w	r8,pc[3034]
80004f26:	31 89       	mov	r9,24
80004f28:	91 09       	st.w	r8[0x0],r9
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80004f2a:	fe f8 0b d2 	ld.w	r8,pc[3026]
80004f2e:	70 08       	ld.w	r8,r8[0x0]
80004f30:	59 08       	cp.w	r8,16
80004f32:	c0 51       	brne	80004f3c <phy_payload_rx+0x2c8>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80004f34:	fe f8 0b c8 	ld.w	r8,pc[3016]
80004f38:	31 09       	mov	r9,16
80004f3a:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80004f3c:	fe f8 0b b8 	ld.w	r8,pc[3000]
80004f40:	30 49       	mov	r9,4
80004f42:	91 09       	st.w	r8[0x0],r9
					
						break;//Jump to READING_AMBE_MEDIA
									
			
				}
				break;
80004f44:	e0 8f 05 cd 	bral	80005ade <phy_payload_rx+0xe6a>
80004f48:	e0 8f 05 cb 	bral	80005ade <phy_payload_rx+0xe6a>
			}
			
			else
			{
				AMBE_Media = 0;	
80004f4c:	fe f9 0b bc 	ld.w	r9,pc[3004]
80004f50:	30 08       	mov	r8,0
80004f52:	b2 88       	st.b	r9[0x0],r8
				break;
80004f54:	e0 8f 05 c5 	bral	80005ade <phy_payload_rx+0xe6a>

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80004f58:	fe f8 0b b4 	ld.w	r8,pc[2996]
80004f5c:	11 88       	ld.ub	r8,r8[0x0]
80004f5e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004f62:	31 28       	mov	r8,18
80004f64:	f0 09 18 00 	cp.b	r9,r8
80004f68:	e0 81 02 07 	brne	80005376 <phy_payload_rx+0x702>
					{
						Item_ID = payload_rx_channel->byte[1];
80004f6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f70:	11 98       	ld.ub	r8,r8[0x1]
80004f72:	fe f9 0b 9a 	ld.w	r9,pc[2970]
80004f76:	b2 88       	st.b	r9[0x0],r8
						if (Item_ID == Post_Voice_Encoder_Data)//
80004f78:	fe f8 0b 94 	ld.w	r8,pc[2964]
80004f7c:	11 88       	ld.ub	r8,r8[0x0]
80004f7e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004f82:	3f 28       	mov	r8,-14
80004f84:	f0 09 18 00 	cp.b	r9,r8
80004f88:	e0 81 01 f1 	brne	8000536a <phy_payload_rx+0x6f6>
						{
							AMBE_tx_flag = 1;
80004f8c:	fe f9 0b ac 	ld.w	r9,pc[2988]
80004f90:	30 18       	mov	r8,1
80004f92:	b2 88       	st.b	r9[0x0],r8
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004f94:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f98:	70 08       	ld.w	r8,r8[0x0]
80004f9a:	e6 18 7f 00 	andh	r8,0x7f00,COH
80004f9e:	f0 09 16 18 	lsr	r9,r8,0x18
80004fa2:	fe f8 0b 5a 	ld.w	r8,pc[2906]
80004fa6:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80004fa8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fac:	90 18       	ld.sh	r8,r8[0x2]
80004fae:	fe f9 0b 8e 	ld.w	r9,pc[2958]
80004fb2:	b2 08       	st.h	r9[0x0],r8
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004fb4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fb8:	90 28       	ld.sh	r8,r8[0x4]
80004fba:	fe f9 0b 82 	ld.w	r9,pc[2946]
80004fbe:	b2 18       	st.h	r9[0x2],r8
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004fc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fc4:	90 38       	ld.sh	r8,r8[0x6]
80004fc6:	fe f9 0b 76 	ld.w	r9,pc[2934]
80004fca:	b2 28       	st.h	r9[0x4],r8
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80004fcc:	fe f8 0b 24 	ld.w	r8,pc[2852]
80004fd0:	70 09       	ld.w	r9,r8[0x0]
80004fd2:	fe f8 0b 42 	ld.w	r8,pc[2882]
80004fd6:	70 08       	ld.w	r8,r8[0x0]
80004fd8:	10 09       	add	r9,r8
80004fda:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fde:	11 a8       	ld.ub	r8,r8[0x2]
80004fe0:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80004fe2:	fe f8 0b 32 	ld.w	r8,pc[2866]
80004fe6:	70 08       	ld.w	r8,r8[0x0]
80004fe8:	f0 c9 ff ff 	sub	r9,r8,-1
80004fec:	fe f8 0b 28 	ld.w	r8,pc[2856]
80004ff0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004ff2:	fe f8 0b 22 	ld.w	r8,pc[2850]
80004ff6:	70 08       	ld.w	r8,r8[0x0]
80004ff8:	e0 48 01 ff 	cp.w	r8,511
80004ffc:	e0 88 00 22 	brls	80005040 <phy_payload_rx+0x3cc>
							{
								RxAMBE_IsFillingNext8 = 0;
80005000:	fe f8 0b 14 	ld.w	r8,pc[2836]
80005004:	30 09       	mov	r9,0
80005006:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005008:	fe f8 0a e8 	ld.w	r8,pc[2792]
8000500c:	70 08       	ld.w	r8,r8[0x0]
8000500e:	10 9c       	mov	r12,r8
80005010:	f0 1f 02 c3 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005014:	fe f8 0a d4 	ld.w	r8,pc[2772]
80005018:	70 08       	ld.w	r8,r8[0x0]
8000501a:	10 9c       	mov	r12,r8
8000501c:	f0 1f 02 b4 	mcall	80005aec <phy_payload_rx+0xe78>
80005020:	18 98       	mov	r8,r12
80005022:	10 99       	mov	r9,r8
80005024:	fe f8 0a cc 	ld.w	r8,pc[2764]
80005028:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
8000502a:	fe f8 0a c6 	ld.w	r8,pc[2758]
8000502e:	70 08       	ld.w	r8,r8[0x0]
80005030:	58 08       	cp.w	r8,0
80005032:	c0 71       	brne	80005040 <phy_payload_rx+0x3cc>
								{
									RxMediaState = WAITINGABAB;
80005034:	fe f8 0a c0 	ld.w	r8,pc[2752]
80005038:	30 09       	mov	r9,0
8000503a:	91 09       	st.w	r8[0x0],r9
									break;
8000503c:	e0 8f 05 51 	bral	80005ade <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005040:	fe f8 0a bc 	ld.w	r8,pc[2748]
80005044:	70 08       	ld.w	r8,r8[0x0]
80005046:	f0 c9 00 01 	sub	r9,r8,1
8000504a:	fe f8 0a b2 	ld.w	r8,pc[2738]
8000504e:	91 09       	st.w	r8[0x0],r9
80005050:	fe f8 0a ac 	ld.w	r8,pc[2732]
80005054:	70 08       	ld.w	r8,r8[0x0]
80005056:	58 08       	cp.w	r8,0
80005058:	c0 71       	brne	80005066 <phy_payload_rx+0x3f2>
								RxMediaState = WAITINGABAB;
8000505a:	fe f8 0a 9a 	ld.w	r8,pc[2714]
8000505e:	30 09       	mov	r9,0
80005060:	91 09       	st.w	r8[0x0],r9
								break;
80005062:	e0 8f 05 3e 	bral	80005ade <phy_payload_rx+0xe6a>
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80005066:	fe f8 0a 8a 	ld.w	r8,pc[2698]
8000506a:	70 09       	ld.w	r9,r8[0x0]
8000506c:	fe f8 0a a8 	ld.w	r8,pc[2728]
80005070:	70 08       	ld.w	r8,r8[0x0]
80005072:	10 09       	add	r9,r8
80005074:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005078:	11 b8       	ld.ub	r8,r8[0x3]
8000507a:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
8000507c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80005080:	70 08       	ld.w	r8,r8[0x0]
80005082:	f0 c9 ff ff 	sub	r9,r8,-1
80005086:	fe f8 0a 8e 	ld.w	r8,pc[2702]
8000508a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000508c:	fe f8 0a 88 	ld.w	r8,pc[2696]
80005090:	70 08       	ld.w	r8,r8[0x0]
80005092:	e0 48 01 ff 	cp.w	r8,511
80005096:	e0 88 00 22 	brls	800050da <phy_payload_rx+0x466>
							{
								RxAMBE_IsFillingNext8 = 0;
8000509a:	fe f8 0a 7a 	ld.w	r8,pc[2682]
8000509e:	30 09       	mov	r9,0
800050a0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800050a2:	fe f8 0a 4e 	ld.w	r8,pc[2638]
800050a6:	70 08       	ld.w	r8,r8[0x0]
800050a8:	10 9c       	mov	r12,r8
800050aa:	f0 1f 02 9d 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800050ae:	fe f8 0a 3a 	ld.w	r8,pc[2618]
800050b2:	70 08       	ld.w	r8,r8[0x0]
800050b4:	10 9c       	mov	r12,r8
800050b6:	f0 1f 02 8e 	mcall	80005aec <phy_payload_rx+0xe78>
800050ba:	18 98       	mov	r8,r12
800050bc:	10 99       	mov	r9,r8
800050be:	fe f8 0a 32 	ld.w	r8,pc[2610]
800050c2:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800050c4:	fe f8 0a 2c 	ld.w	r8,pc[2604]
800050c8:	70 08       	ld.w	r8,r8[0x0]
800050ca:	58 08       	cp.w	r8,0
800050cc:	c0 71       	brne	800050da <phy_payload_rx+0x466>
								{
									RxMediaState = WAITINGABAB;
800050ce:	fe f8 0a 26 	ld.w	r8,pc[2598]
800050d2:	30 09       	mov	r9,0
800050d4:	91 09       	st.w	r8[0x0],r9
									break;
800050d6:	e0 8f 05 04 	bral	80005ade <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800050da:	fe f8 0a 22 	ld.w	r8,pc[2594]
800050de:	70 08       	ld.w	r8,r8[0x0]
800050e0:	f0 c9 00 01 	sub	r9,r8,1
800050e4:	fe f8 0a 18 	ld.w	r8,pc[2584]
800050e8:	91 09       	st.w	r8[0x0],r9
800050ea:	fe f8 0a 12 	ld.w	r8,pc[2578]
800050ee:	70 08       	ld.w	r8,r8[0x0]
800050f0:	58 08       	cp.w	r8,0
800050f2:	c0 71       	brne	80005100 <phy_payload_rx+0x48c>
								RxMediaState = WAITINGABAB;
800050f4:	fe f8 0a 00 	ld.w	r8,pc[2560]
800050f8:	30 09       	mov	r9,0
800050fa:	91 09       	st.w	r8[0x0],r9
								break;
800050fc:	e0 8f 04 f1 	bral	80005ade <phy_payload_rx+0xe6a>
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80005100:	fe f8 09 f0 	ld.w	r8,pc[2544]
80005104:	70 09       	ld.w	r9,r8[0x0]
80005106:	fe f8 0a 0e 	ld.w	r8,pc[2574]
8000510a:	70 08       	ld.w	r8,r8[0x0]
8000510c:	10 09       	add	r9,r8
8000510e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005112:	11 c8       	ld.ub	r8,r8[0x4]
80005114:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005116:	fe f8 09 fe 	ld.w	r8,pc[2558]
8000511a:	70 08       	ld.w	r8,r8[0x0]
8000511c:	f0 c9 ff ff 	sub	r9,r8,-1
80005120:	fe f8 09 f4 	ld.w	r8,pc[2548]
80005124:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005126:	fe f8 09 ee 	ld.w	r8,pc[2542]
8000512a:	70 08       	ld.w	r8,r8[0x0]
8000512c:	e0 48 01 ff 	cp.w	r8,511
80005130:	e0 88 00 22 	brls	80005174 <phy_payload_rx+0x500>
							{
								RxAMBE_IsFillingNext8 = 0;
80005134:	fe f8 09 e0 	ld.w	r8,pc[2528]
80005138:	30 09       	mov	r9,0
8000513a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000513c:	fe f8 09 b4 	ld.w	r8,pc[2484]
80005140:	70 08       	ld.w	r8,r8[0x0]
80005142:	10 9c       	mov	r12,r8
80005144:	f0 1f 02 76 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005148:	fe f8 09 a0 	ld.w	r8,pc[2464]
8000514c:	70 08       	ld.w	r8,r8[0x0]
8000514e:	10 9c       	mov	r12,r8
80005150:	f0 1f 02 67 	mcall	80005aec <phy_payload_rx+0xe78>
80005154:	18 98       	mov	r8,r12
80005156:	10 99       	mov	r9,r8
80005158:	fe f8 09 98 	ld.w	r8,pc[2456]
8000515c:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
8000515e:	fe f8 09 92 	ld.w	r8,pc[2450]
80005162:	70 08       	ld.w	r8,r8[0x0]
80005164:	58 08       	cp.w	r8,0
80005166:	c0 71       	brne	80005174 <phy_payload_rx+0x500>
								{
									RxMediaState = WAITINGABAB;
80005168:	fe f8 09 8c 	ld.w	r8,pc[2444]
8000516c:	30 09       	mov	r9,0
8000516e:	91 09       	st.w	r8[0x0],r9
									break;
80005170:	e0 8f 04 b7 	bral	80005ade <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005174:	fe f8 09 88 	ld.w	r8,pc[2440]
80005178:	70 08       	ld.w	r8,r8[0x0]
8000517a:	f0 c9 00 01 	sub	r9,r8,1
8000517e:	fe f8 09 7e 	ld.w	r8,pc[2430]
80005182:	91 09       	st.w	r8[0x0],r9
80005184:	fe f8 09 78 	ld.w	r8,pc[2424]
80005188:	70 08       	ld.w	r8,r8[0x0]
8000518a:	58 08       	cp.w	r8,0
8000518c:	c0 71       	brne	8000519a <phy_payload_rx+0x526>
								RxMediaState = WAITINGABAB;
8000518e:	fe f8 09 66 	ld.w	r8,pc[2406]
80005192:	30 09       	mov	r9,0
80005194:	91 09       	st.w	r8[0x0],r9
								break;
80005196:	e0 8f 04 a4 	bral	80005ade <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000519a:	fe f8 09 56 	ld.w	r8,pc[2390]
8000519e:	70 09       	ld.w	r9,r8[0x0]
800051a0:	fe f8 09 74 	ld.w	r8,pc[2420]
800051a4:	70 08       	ld.w	r8,r8[0x0]
800051a6:	10 09       	add	r9,r8
800051a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051ac:	11 d8       	ld.ub	r8,r8[0x5]
800051ae:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800051b0:	fe f8 09 64 	ld.w	r8,pc[2404]
800051b4:	70 08       	ld.w	r8,r8[0x0]
800051b6:	f0 c9 ff ff 	sub	r9,r8,-1
800051ba:	fe f8 09 5a 	ld.w	r8,pc[2394]
800051be:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800051c0:	fe f8 09 54 	ld.w	r8,pc[2388]
800051c4:	70 08       	ld.w	r8,r8[0x0]
800051c6:	e0 48 01 ff 	cp.w	r8,511
800051ca:	e0 88 00 22 	brls	8000520e <phy_payload_rx+0x59a>
							{
								RxAMBE_IsFillingNext8 = 0;
800051ce:	fe f8 09 46 	ld.w	r8,pc[2374]
800051d2:	30 09       	mov	r9,0
800051d4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800051d6:	fe f8 09 1a 	ld.w	r8,pc[2330]
800051da:	70 08       	ld.w	r8,r8[0x0]
800051dc:	10 9c       	mov	r12,r8
800051de:	f0 1f 02 50 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800051e2:	fe f8 09 06 	ld.w	r8,pc[2310]
800051e6:	70 08       	ld.w	r8,r8[0x0]
800051e8:	10 9c       	mov	r12,r8
800051ea:	f0 1f 02 41 	mcall	80005aec <phy_payload_rx+0xe78>
800051ee:	18 98       	mov	r8,r12
800051f0:	10 99       	mov	r9,r8
800051f2:	fe f8 08 fe 	ld.w	r8,pc[2302]
800051f6:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800051f8:	fe f8 08 f8 	ld.w	r8,pc[2296]
800051fc:	70 08       	ld.w	r8,r8[0x0]
800051fe:	58 08       	cp.w	r8,0
80005200:	c0 71       	brne	8000520e <phy_payload_rx+0x59a>
								{
									RxMediaState = WAITINGABAB;
80005202:	fe f8 08 f2 	ld.w	r8,pc[2290]
80005206:	30 09       	mov	r9,0
80005208:	91 09       	st.w	r8[0x0],r9
									break;
8000520a:	e0 8f 04 6a 	bral	80005ade <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000520e:	fe f8 08 ee 	ld.w	r8,pc[2286]
80005212:	70 08       	ld.w	r8,r8[0x0]
80005214:	f0 c9 00 01 	sub	r9,r8,1
80005218:	fe f8 08 e4 	ld.w	r8,pc[2276]
8000521c:	91 09       	st.w	r8[0x0],r9
8000521e:	fe f8 08 de 	ld.w	r8,pc[2270]
80005222:	70 08       	ld.w	r8,r8[0x0]
80005224:	58 08       	cp.w	r8,0
80005226:	c0 71       	brne	80005234 <phy_payload_rx+0x5c0>
								RxMediaState = WAITINGABAB;
80005228:	fe f8 08 cc 	ld.w	r8,pc[2252]
8000522c:	30 09       	mov	r9,0
8000522e:	91 09       	st.w	r8[0x0],r9
								break;
80005230:	e0 8f 04 57 	bral	80005ade <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80005234:	fe f8 08 bc 	ld.w	r8,pc[2236]
80005238:	70 09       	ld.w	r9,r8[0x0]
8000523a:	fe f8 08 da 	ld.w	r8,pc[2266]
8000523e:	70 08       	ld.w	r8,r8[0x0]
80005240:	10 09       	add	r9,r8
80005242:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005246:	11 e8       	ld.ub	r8,r8[0x6]
80005248:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
8000524a:	fe f8 08 ca 	ld.w	r8,pc[2250]
8000524e:	70 08       	ld.w	r8,r8[0x0]
80005250:	f0 c9 ff ff 	sub	r9,r8,-1
80005254:	fe f8 08 c0 	ld.w	r8,pc[2240]
80005258:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000525a:	fe f8 08 ba 	ld.w	r8,pc[2234]
8000525e:	70 08       	ld.w	r8,r8[0x0]
80005260:	e0 48 01 ff 	cp.w	r8,511
80005264:	e0 88 00 22 	brls	800052a8 <phy_payload_rx+0x634>
							{
								RxAMBE_IsFillingNext8 = 0;
80005268:	fe f8 08 ac 	ld.w	r8,pc[2220]
8000526c:	30 09       	mov	r9,0
8000526e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005270:	fe f8 08 80 	ld.w	r8,pc[2176]
80005274:	70 08       	ld.w	r8,r8[0x0]
80005276:	10 9c       	mov	r12,r8
80005278:	f0 1f 02 29 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
8000527c:	fe f8 08 6c 	ld.w	r8,pc[2156]
80005280:	70 08       	ld.w	r8,r8[0x0]
80005282:	10 9c       	mov	r12,r8
80005284:	f0 1f 02 1a 	mcall	80005aec <phy_payload_rx+0xe78>
80005288:	18 98       	mov	r8,r12
8000528a:	10 99       	mov	r9,r8
8000528c:	fe f8 08 64 	ld.w	r8,pc[2148]
80005290:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005292:	fe f8 08 5e 	ld.w	r8,pc[2142]
80005296:	70 08       	ld.w	r8,r8[0x0]
80005298:	58 08       	cp.w	r8,0
8000529a:	c0 71       	brne	800052a8 <phy_payload_rx+0x634>
								{
									RxMediaState = WAITINGABAB;
8000529c:	fe f8 08 58 	ld.w	r8,pc[2136]
800052a0:	30 09       	mov	r9,0
800052a2:	91 09       	st.w	r8[0x0],r9
									break;
800052a4:	e0 8f 04 1d 	bral	80005ade <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800052a8:	fe f8 08 54 	ld.w	r8,pc[2132]
800052ac:	70 08       	ld.w	r8,r8[0x0]
800052ae:	f0 c9 00 01 	sub	r9,r8,1
800052b2:	fe f8 08 4a 	ld.w	r8,pc[2122]
800052b6:	91 09       	st.w	r8[0x0],r9
800052b8:	fe f8 08 44 	ld.w	r8,pc[2116]
800052bc:	70 08       	ld.w	r8,r8[0x0]
800052be:	58 08       	cp.w	r8,0
800052c0:	c0 71       	brne	800052ce <phy_payload_rx+0x65a>
								RxMediaState = WAITINGABAB;
800052c2:	fe f8 08 32 	ld.w	r8,pc[2098]
800052c6:	30 09       	mov	r9,0
800052c8:	91 09       	st.w	r8[0x0],r9
								break;
800052ca:	e0 8f 04 0a 	bral	80005ade <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800052ce:	fe f8 08 22 	ld.w	r8,pc[2082]
800052d2:	70 09       	ld.w	r9,r8[0x0]
800052d4:	fe f8 08 40 	ld.w	r8,pc[2112]
800052d8:	70 08       	ld.w	r8,r8[0x0]
800052da:	10 09       	add	r9,r8
800052dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052e0:	11 f8       	ld.ub	r8,r8[0x7]
800052e2:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800052e4:	fe f8 08 30 	ld.w	r8,pc[2096]
800052e8:	70 08       	ld.w	r8,r8[0x0]
800052ea:	f0 c9 ff ff 	sub	r9,r8,-1
800052ee:	fe f8 08 26 	ld.w	r8,pc[2086]
800052f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800052f4:	fe f8 08 20 	ld.w	r8,pc[2080]
800052f8:	70 08       	ld.w	r8,r8[0x0]
800052fa:	e0 48 01 ff 	cp.w	r8,511
800052fe:	e0 88 00 22 	brls	80005342 <phy_payload_rx+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80005302:	fe f8 08 12 	ld.w	r8,pc[2066]
80005306:	30 09       	mov	r9,0
80005308:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000530a:	fe f8 07 e6 	ld.w	r8,pc[2022]
8000530e:	70 08       	ld.w	r8,r8[0x0]
80005310:	10 9c       	mov	r12,r8
80005312:	f0 1f 02 03 	mcall	80005b1c <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005316:	fe f8 07 d2 	ld.w	r8,pc[2002]
8000531a:	70 08       	ld.w	r8,r8[0x0]
8000531c:	10 9c       	mov	r12,r8
8000531e:	f0 1f 01 f4 	mcall	80005aec <phy_payload_rx+0xe78>
80005322:	18 98       	mov	r8,r12
80005324:	10 99       	mov	r9,r8
80005326:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000532a:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
8000532c:	fe f8 07 c4 	ld.w	r8,pc[1988]
80005330:	70 08       	ld.w	r8,r8[0x0]
80005332:	58 08       	cp.w	r8,0
80005334:	c0 71       	brne	80005342 <phy_payload_rx+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80005336:	fe f8 07 be 	ld.w	r8,pc[1982]
8000533a:	30 09       	mov	r9,0
8000533c:	91 09       	st.w	r8[0x0],r9
									break;
8000533e:	e0 8f 03 d0 	bral	80005ade <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005342:	fe f8 07 ba 	ld.w	r8,pc[1978]
80005346:	70 08       	ld.w	r8,r8[0x0]
80005348:	f0 c9 00 01 	sub	r9,r8,1
8000534c:	fe f8 07 b0 	ld.w	r8,pc[1968]
80005350:	91 09       	st.w	r8[0x0],r9
80005352:	fe f8 07 aa 	ld.w	r8,pc[1962]
80005356:	70 08       	ld.w	r8,r8[0x0]
80005358:	58 08       	cp.w	r8,0
8000535a:	e0 81 03 b9 	brne	80005acc <phy_payload_rx+0xe58>
								RxMediaState = WAITINGABAB;
8000535e:	fe f8 07 96 	ld.w	r8,pc[1942]
80005362:	30 09       	mov	r9,0
80005364:	91 09       	st.w	r8[0x0],r9
								break;
80005366:	e0 8f 03 bc 	bral	80005ade <phy_payload_rx+0xe6a>
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000536a:	fe f8 07 8a 	ld.w	r8,pc[1930]
8000536e:	30 09       	mov	r9,0
80005370:	91 09       	st.w	r8[0x0],r9
							break;
80005372:	e0 8f 03 b6 	bral	80005ade <phy_payload_rx+0xe6a>
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80005376:	fe f8 07 96 	ld.w	r8,pc[1942]
8000537a:	11 88       	ld.ub	r8,r8[0x0]
8000537c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005380:	3f 28       	mov	r8,-14
80005382:	f0 09 18 00 	cp.b	r9,r8
80005386:	c6 81       	brne	80005456 <phy_payload_rx+0x7e2>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80005388:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000538c:	90 08       	ld.sh	r8,r8[0x0]
8000538e:	fe f9 07 ae 	ld.w	r9,pc[1966]
80005392:	b2 38       	st.h	r9[0x6],r8
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80005394:	fe f8 07 5c 	ld.w	r8,pc[1884]
80005398:	70 09       	ld.w	r9,r8[0x0]
8000539a:	fe f8 07 7a 	ld.w	r8,pc[1914]
8000539e:	70 08       	ld.w	r8,r8[0x0]
800053a0:	10 09       	add	r9,r8
800053a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053a6:	11 88       	ld.ub	r8,r8[0x0]
800053a8:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
800053aa:	fe f8 07 6a 	ld.w	r8,pc[1898]
800053ae:	70 08       	ld.w	r8,r8[0x0]
800053b0:	f0 c9 ff ff 	sub	r9,r8,-1
800053b4:	fe f8 07 60 	ld.w	r8,pc[1888]
800053b8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800053ba:	fe f8 07 5a 	ld.w	r8,pc[1882]
800053be:	70 08       	ld.w	r8,r8[0x0]
800053c0:	e0 48 01 ff 	cp.w	r8,511
800053c4:	e0 88 00 22 	brls	80005408 <phy_payload_rx+0x794>
						{
							RxAMBE_IsFillingNext8 = 0;
800053c8:	fe f8 07 4c 	ld.w	r8,pc[1868]
800053cc:	30 09       	mov	r9,0
800053ce:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800053d0:	fe f8 07 20 	ld.w	r8,pc[1824]
800053d4:	70 08       	ld.w	r8,r8[0x0]
800053d6:	10 9c       	mov	r12,r8
800053d8:	f0 1f 01 d1 	mcall	80005b1c <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
800053dc:	fe f8 07 0c 	ld.w	r8,pc[1804]
800053e0:	70 08       	ld.w	r8,r8[0x0]
800053e2:	10 9c       	mov	r12,r8
800053e4:	f0 1f 01 c2 	mcall	80005aec <phy_payload_rx+0xe78>
800053e8:	18 98       	mov	r8,r12
800053ea:	10 99       	mov	r9,r8
800053ec:	fe f8 07 04 	ld.w	r8,pc[1796]
800053f0:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
800053f2:	fe f8 06 fe 	ld.w	r8,pc[1790]
800053f6:	70 08       	ld.w	r8,r8[0x0]
800053f8:	58 08       	cp.w	r8,0
800053fa:	c0 71       	brne	80005408 <phy_payload_rx+0x794>
							{
								RxMediaState = WAITINGABAB;
800053fc:	fe f8 06 f8 	ld.w	r8,pc[1784]
80005400:	30 09       	mov	r9,0
80005402:	91 09       	st.w	r8[0x0],r9
								break;
80005404:	e0 8f 03 6d 	bral	80005ade <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005408:	fe f8 06 f4 	ld.w	r8,pc[1780]
8000540c:	70 08       	ld.w	r8,r8[0x0]
8000540e:	f0 c9 00 01 	sub	r9,r8,1
80005412:	fe f8 06 ea 	ld.w	r8,pc[1770]
80005416:	91 09       	st.w	r8[0x0],r9
80005418:	fe f8 06 e4 	ld.w	r8,pc[1764]
8000541c:	70 08       	ld.w	r8,r8[0x0]
8000541e:	58 08       	cp.w	r8,0
80005420:	c0 71       	brne	8000542e <phy_payload_rx+0x7ba>
							RxMediaState = WAITINGABAB;
80005422:	fe f8 06 d2 	ld.w	r8,pc[1746]
80005426:	30 09       	mov	r9,0
80005428:	91 09       	st.w	r8[0x0],r9
							break;
8000542a:	e0 8f 03 5a 	bral	80005ade <phy_payload_rx+0xe6a>
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
8000542e:	fe f8 06 ce 	ld.w	r8,pc[1742]
80005432:	70 08       	ld.w	r8,r8[0x0]
80005434:	f0 c9 00 01 	sub	r9,r8,1
80005438:	fe f8 06 c4 	ld.w	r8,pc[1732]
8000543c:	91 09       	st.w	r8[0x0],r9
8000543e:	fe f8 06 be 	ld.w	r8,pc[1726]
80005442:	70 08       	ld.w	r8,r8[0x0]
80005444:	58 08       	cp.w	r8,0
80005446:	e0 81 03 45 	brne	80005ad0 <phy_payload_rx+0xe5c>
							RxMediaState = WAITINGABAB;
8000544a:	fe f8 06 aa 	ld.w	r8,pc[1706]
8000544e:	30 09       	mov	r9,0
80005450:	91 09       	st.w	r8[0x0],r9
							break;
80005452:	e0 8f 03 46 	bral	80005ade <phy_payload_rx+0xe6a>
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80005456:	fe f8 06 b6 	ld.w	r8,pc[1718]
8000545a:	11 88       	ld.ub	r8,r8[0x0]
8000545c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005460:	3f 38       	mov	r8,-13
80005462:	f0 09 18 00 	cp.b	r9,r8
80005466:	e0 81 01 a9 	brne	800057b8 <phy_payload_rx+0xb44>
					{
						//
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000546a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000546e:	90 08       	ld.sh	r8,r8[0x0]
80005470:	fe f9 06 cc 	ld.w	r9,pc[1740]
80005474:	b2 18       	st.h	r9[0x2],r8
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80005476:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000547a:	90 18       	ld.sh	r8,r8[0x2]
8000547c:	fe f9 06 c0 	ld.w	r9,pc[1728]
80005480:	b2 28       	st.h	r9[0x4],r8
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80005482:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005486:	90 28       	ld.sh	r8,r8[0x4]
80005488:	fe f9 06 b4 	ld.w	r9,pc[1716]
8000548c:	b2 38       	st.h	r9[0x6],r8
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000548e:	fe f8 06 62 	ld.w	r8,pc[1634]
80005492:	70 09       	ld.w	r9,r8[0x0]
80005494:	fe f8 06 80 	ld.w	r8,pc[1664]
80005498:	70 08       	ld.w	r8,r8[0x0]
8000549a:	10 09       	add	r9,r8
8000549c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800054a0:	11 88       	ld.ub	r8,r8[0x0]
800054a2:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
800054a4:	fe f8 06 70 	ld.w	r8,pc[1648]
800054a8:	70 08       	ld.w	r8,r8[0x0]
800054aa:	f0 c9 ff ff 	sub	r9,r8,-1
800054ae:	fe f8 06 66 	ld.w	r8,pc[1638]
800054b2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800054b4:	fe f8 06 60 	ld.w	r8,pc[1632]
800054b8:	70 08       	ld.w	r8,r8[0x0]
800054ba:	e0 48 01 ff 	cp.w	r8,511
800054be:	e0 88 00 22 	brls	80005502 <phy_payload_rx+0x88e>
						{
							RxAMBE_IsFillingNext8 = 0;
800054c2:	fe f8 06 52 	ld.w	r8,pc[1618]
800054c6:	30 09       	mov	r9,0
800054c8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800054ca:	fe f8 06 26 	ld.w	r8,pc[1574]
800054ce:	70 08       	ld.w	r8,r8[0x0]
800054d0:	10 9c       	mov	r12,r8
800054d2:	f0 1f 01 93 	mcall	80005b1c <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
800054d6:	fe f8 06 12 	ld.w	r8,pc[1554]
800054da:	70 08       	ld.w	r8,r8[0x0]
800054dc:	10 9c       	mov	r12,r8
800054de:	f0 1f 01 84 	mcall	80005aec <phy_payload_rx+0xe78>
800054e2:	18 98       	mov	r8,r12
800054e4:	10 99       	mov	r9,r8
800054e6:	fe f8 06 0a 	ld.w	r8,pc[1546]
800054ea:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
800054ec:	fe f8 06 04 	ld.w	r8,pc[1540]
800054f0:	70 08       	ld.w	r8,r8[0x0]
800054f2:	58 08       	cp.w	r8,0
800054f4:	c0 71       	brne	80005502 <phy_payload_rx+0x88e>
							{
								RxMediaState = WAITINGABAB;
800054f6:	fe f8 05 fe 	ld.w	r8,pc[1534]
800054fa:	30 09       	mov	r9,0
800054fc:	91 09       	st.w	r8[0x0],r9
								break;
800054fe:	e0 8f 02 f0 	bral	80005ade <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005502:	fe f8 05 fa 	ld.w	r8,pc[1530]
80005506:	70 08       	ld.w	r8,r8[0x0]
80005508:	f0 c9 00 01 	sub	r9,r8,1
8000550c:	fe f8 05 f0 	ld.w	r8,pc[1520]
80005510:	91 09       	st.w	r8[0x0],r9
80005512:	fe f8 05 ea 	ld.w	r8,pc[1514]
80005516:	70 08       	ld.w	r8,r8[0x0]
80005518:	58 08       	cp.w	r8,0
8000551a:	c0 71       	brne	80005528 <phy_payload_rx+0x8b4>
							RxMediaState = WAITINGABAB;
8000551c:	fe f8 05 d8 	ld.w	r8,pc[1496]
80005520:	30 09       	mov	r9,0
80005522:	91 09       	st.w	r8[0x0],r9
							break;
80005524:	e0 8f 02 dd 	bral	80005ade <phy_payload_rx+0xe6a>
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80005528:	fe f8 05 c8 	ld.w	r8,pc[1480]
8000552c:	70 09       	ld.w	r9,r8[0x0]
8000552e:	fe f8 05 e6 	ld.w	r8,pc[1510]
80005532:	70 08       	ld.w	r8,r8[0x0]
80005534:	10 09       	add	r9,r8
80005536:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000553a:	11 98       	ld.ub	r8,r8[0x1]
8000553c:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
8000553e:	fe f8 05 d6 	ld.w	r8,pc[1494]
80005542:	70 08       	ld.w	r8,r8[0x0]
80005544:	f0 c9 ff ff 	sub	r9,r8,-1
80005548:	fe f8 05 cc 	ld.w	r8,pc[1484]
8000554c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000554e:	fe f8 05 c6 	ld.w	r8,pc[1478]
80005552:	70 08       	ld.w	r8,r8[0x0]
80005554:	e0 48 01 ff 	cp.w	r8,511
80005558:	e0 88 00 22 	brls	8000559c <phy_payload_rx+0x928>
						{
							RxAMBE_IsFillingNext8 = 0;
8000555c:	fe f8 05 b8 	ld.w	r8,pc[1464]
80005560:	30 09       	mov	r9,0
80005562:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005564:	fe f8 05 8c 	ld.w	r8,pc[1420]
80005568:	70 08       	ld.w	r8,r8[0x0]
8000556a:	10 9c       	mov	r12,r8
8000556c:	f0 1f 01 6c 	mcall	80005b1c <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005570:	fe f8 05 78 	ld.w	r8,pc[1400]
80005574:	70 08       	ld.w	r8,r8[0x0]
80005576:	10 9c       	mov	r12,r8
80005578:	f0 1f 01 5d 	mcall	80005aec <phy_payload_rx+0xe78>
8000557c:	18 98       	mov	r8,r12
8000557e:	10 99       	mov	r9,r8
80005580:	fe f8 05 70 	ld.w	r8,pc[1392]
80005584:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005586:	fe f8 05 6a 	ld.w	r8,pc[1386]
8000558a:	70 08       	ld.w	r8,r8[0x0]
8000558c:	58 08       	cp.w	r8,0
8000558e:	c0 71       	brne	8000559c <phy_payload_rx+0x928>
							{
								RxMediaState = WAITINGABAB;
80005590:	fe f8 05 64 	ld.w	r8,pc[1380]
80005594:	30 09       	mov	r9,0
80005596:	91 09       	st.w	r8[0x0],r9
								break;
80005598:	e0 8f 02 a3 	bral	80005ade <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000559c:	fe f8 05 60 	ld.w	r8,pc[1376]
800055a0:	70 08       	ld.w	r8,r8[0x0]
800055a2:	f0 c9 00 01 	sub	r9,r8,1
800055a6:	fe f8 05 56 	ld.w	r8,pc[1366]
800055aa:	91 09       	st.w	r8[0x0],r9
800055ac:	fe f8 05 50 	ld.w	r8,pc[1360]
800055b0:	70 08       	ld.w	r8,r8[0x0]
800055b2:	58 08       	cp.w	r8,0
800055b4:	c0 71       	brne	800055c2 <phy_payload_rx+0x94e>
							RxMediaState = WAITINGABAB;
800055b6:	fe f8 05 3e 	ld.w	r8,pc[1342]
800055ba:	30 09       	mov	r9,0
800055bc:	91 09       	st.w	r8[0x0],r9
							break;
800055be:	e0 8f 02 90 	bral	80005ade <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800055c2:	fe f8 05 2e 	ld.w	r8,pc[1326]
800055c6:	70 09       	ld.w	r9,r8[0x0]
800055c8:	fe f8 05 4c 	ld.w	r8,pc[1356]
800055cc:	70 08       	ld.w	r8,r8[0x0]
800055ce:	10 09       	add	r9,r8
800055d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800055d4:	11 a8       	ld.ub	r8,r8[0x2]
800055d6:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
800055d8:	fe f8 05 3c 	ld.w	r8,pc[1340]
800055dc:	70 08       	ld.w	r8,r8[0x0]
800055de:	f0 c9 ff ff 	sub	r9,r8,-1
800055e2:	fe f8 05 32 	ld.w	r8,pc[1330]
800055e6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800055e8:	fe f8 05 2c 	ld.w	r8,pc[1324]
800055ec:	70 08       	ld.w	r8,r8[0x0]
800055ee:	e0 48 01 ff 	cp.w	r8,511
800055f2:	e0 88 00 22 	brls	80005636 <phy_payload_rx+0x9c2>
						{
							RxAMBE_IsFillingNext8 = 0;
800055f6:	fe f8 05 1e 	ld.w	r8,pc[1310]
800055fa:	30 09       	mov	r9,0
800055fc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800055fe:	fe f8 04 f2 	ld.w	r8,pc[1266]
80005602:	70 08       	ld.w	r8,r8[0x0]
80005604:	10 9c       	mov	r12,r8
80005606:	f0 1f 01 46 	mcall	80005b1c <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
8000560a:	fe f8 04 de 	ld.w	r8,pc[1246]
8000560e:	70 08       	ld.w	r8,r8[0x0]
80005610:	10 9c       	mov	r12,r8
80005612:	f0 1f 01 37 	mcall	80005aec <phy_payload_rx+0xe78>
80005616:	18 98       	mov	r8,r12
80005618:	10 99       	mov	r9,r8
8000561a:	fe f8 04 d6 	ld.w	r8,pc[1238]
8000561e:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005620:	fe f8 04 d0 	ld.w	r8,pc[1232]
80005624:	70 08       	ld.w	r8,r8[0x0]
80005626:	58 08       	cp.w	r8,0
80005628:	c0 71       	brne	80005636 <phy_payload_rx+0x9c2>
							{
								RxMediaState = WAITINGABAB;
8000562a:	fe f8 04 ca 	ld.w	r8,pc[1226]
8000562e:	30 09       	mov	r9,0
80005630:	91 09       	st.w	r8[0x0],r9
								break;
80005632:	e0 8f 02 56 	bral	80005ade <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005636:	fe f8 04 c6 	ld.w	r8,pc[1222]
8000563a:	70 08       	ld.w	r8,r8[0x0]
8000563c:	f0 c9 00 01 	sub	r9,r8,1
80005640:	fe f8 04 bc 	ld.w	r8,pc[1212]
80005644:	91 09       	st.w	r8[0x0],r9
80005646:	fe f8 04 b6 	ld.w	r8,pc[1206]
8000564a:	70 08       	ld.w	r8,r8[0x0]
8000564c:	58 08       	cp.w	r8,0
8000564e:	c0 71       	brne	8000565c <phy_payload_rx+0x9e8>
							RxMediaState = WAITINGABAB;
80005650:	fe f8 04 a4 	ld.w	r8,pc[1188]
80005654:	30 09       	mov	r9,0
80005656:	91 09       	st.w	r8[0x0],r9
							break;
80005658:	e0 8f 02 43 	bral	80005ade <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000565c:	fe f8 04 94 	ld.w	r8,pc[1172]
80005660:	70 09       	ld.w	r9,r8[0x0]
80005662:	fe f8 04 b2 	ld.w	r8,pc[1202]
80005666:	70 08       	ld.w	r8,r8[0x0]
80005668:	10 09       	add	r9,r8
8000566a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000566e:	11 b8       	ld.ub	r8,r8[0x3]
80005670:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005672:	fe f8 04 a2 	ld.w	r8,pc[1186]
80005676:	70 08       	ld.w	r8,r8[0x0]
80005678:	f0 c9 ff ff 	sub	r9,r8,-1
8000567c:	fe f8 04 98 	ld.w	r8,pc[1176]
80005680:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005682:	fe f8 04 92 	ld.w	r8,pc[1170]
80005686:	70 08       	ld.w	r8,r8[0x0]
80005688:	e0 48 01 ff 	cp.w	r8,511
8000568c:	e0 88 00 22 	brls	800056d0 <phy_payload_rx+0xa5c>
						{
							RxAMBE_IsFillingNext8 = 0;
80005690:	fe f8 04 84 	ld.w	r8,pc[1156]
80005694:	30 09       	mov	r9,0
80005696:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005698:	fe f8 04 58 	ld.w	r8,pc[1112]
8000569c:	70 08       	ld.w	r8,r8[0x0]
8000569e:	10 9c       	mov	r12,r8
800056a0:	f0 1f 01 1f 	mcall	80005b1c <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
800056a4:	fe f8 04 44 	ld.w	r8,pc[1092]
800056a8:	70 08       	ld.w	r8,r8[0x0]
800056aa:	10 9c       	mov	r12,r8
800056ac:	f0 1f 01 10 	mcall	80005aec <phy_payload_rx+0xe78>
800056b0:	18 98       	mov	r8,r12
800056b2:	10 99       	mov	r9,r8
800056b4:	fe f8 04 3c 	ld.w	r8,pc[1084]
800056b8:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
800056ba:	fe f8 04 36 	ld.w	r8,pc[1078]
800056be:	70 08       	ld.w	r8,r8[0x0]
800056c0:	58 08       	cp.w	r8,0
800056c2:	c0 71       	brne	800056d0 <phy_payload_rx+0xa5c>
							{
								RxMediaState = WAITINGABAB;
800056c4:	fe f8 04 30 	ld.w	r8,pc[1072]
800056c8:	30 09       	mov	r9,0
800056ca:	91 09       	st.w	r8[0x0],r9
								break;
800056cc:	e0 8f 02 09 	bral	80005ade <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800056d0:	fe f8 04 2c 	ld.w	r8,pc[1068]
800056d4:	70 08       	ld.w	r8,r8[0x0]
800056d6:	f0 c9 00 01 	sub	r9,r8,1
800056da:	fe f8 04 22 	ld.w	r8,pc[1058]
800056de:	91 09       	st.w	r8[0x0],r9
800056e0:	fe f8 04 1c 	ld.w	r8,pc[1052]
800056e4:	70 08       	ld.w	r8,r8[0x0]
800056e6:	58 08       	cp.w	r8,0
800056e8:	c0 71       	brne	800056f6 <phy_payload_rx+0xa82>
							RxMediaState = WAITINGABAB;
800056ea:	fe f8 04 0a 	ld.w	r8,pc[1034]
800056ee:	30 09       	mov	r9,0
800056f0:	91 09       	st.w	r8[0x0],r9
							break;
800056f2:	e0 8f 01 f6 	bral	80005ade <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800056f6:	fe f8 03 fa 	ld.w	r8,pc[1018]
800056fa:	70 09       	ld.w	r9,r8[0x0]
800056fc:	fe f8 04 18 	ld.w	r8,pc[1048]
80005700:	70 08       	ld.w	r8,r8[0x0]
80005702:	10 09       	add	r9,r8
80005704:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005708:	11 c8       	ld.ub	r8,r8[0x4]
8000570a:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
8000570c:	fe f8 04 08 	ld.w	r8,pc[1032]
80005710:	70 08       	ld.w	r8,r8[0x0]
80005712:	f0 c9 ff ff 	sub	r9,r8,-1
80005716:	fe f8 03 fe 	ld.w	r8,pc[1022]
8000571a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000571c:	fe f8 03 f8 	ld.w	r8,pc[1016]
80005720:	70 08       	ld.w	r8,r8[0x0]
80005722:	e0 48 01 ff 	cp.w	r8,511
80005726:	e0 88 00 22 	brls	8000576a <phy_payload_rx+0xaf6>
						{
							RxAMBE_IsFillingNext8 = 0;
8000572a:	fe f8 03 ea 	ld.w	r8,pc[1002]
8000572e:	30 09       	mov	r9,0
80005730:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005732:	fe f8 03 be 	ld.w	r8,pc[958]
80005736:	70 08       	ld.w	r8,r8[0x0]
80005738:	10 9c       	mov	r12,r8
8000573a:	f0 1f 00 f9 	mcall	80005b1c <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
8000573e:	fe f8 03 aa 	ld.w	r8,pc[938]
80005742:	70 08       	ld.w	r8,r8[0x0]
80005744:	10 9c       	mov	r12,r8
80005746:	f0 1f 00 ea 	mcall	80005aec <phy_payload_rx+0xe78>
8000574a:	18 98       	mov	r8,r12
8000574c:	10 99       	mov	r9,r8
8000574e:	fe f8 03 a2 	ld.w	r8,pc[930]
80005752:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005754:	fe f8 03 9c 	ld.w	r8,pc[924]
80005758:	70 08       	ld.w	r8,r8[0x0]
8000575a:	58 08       	cp.w	r8,0
8000575c:	c0 71       	brne	8000576a <phy_payload_rx+0xaf6>
							{
								RxMediaState = WAITINGABAB;
8000575e:	fe f8 03 96 	ld.w	r8,pc[918]
80005762:	30 09       	mov	r9,0
80005764:	91 09       	st.w	r8[0x0],r9
								break;
80005766:	e0 8f 01 bc 	bral	80005ade <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000576a:	fe f8 03 92 	ld.w	r8,pc[914]
8000576e:	70 08       	ld.w	r8,r8[0x0]
80005770:	f0 c9 00 01 	sub	r9,r8,1
80005774:	fe f8 03 88 	ld.w	r8,pc[904]
80005778:	91 09       	st.w	r8[0x0],r9
8000577a:	fe f8 03 82 	ld.w	r8,pc[898]
8000577e:	70 08       	ld.w	r8,r8[0x0]
80005780:	58 08       	cp.w	r8,0
80005782:	c0 71       	brne	80005790 <phy_payload_rx+0xb1c>
							RxMediaState = WAITINGABAB;
80005784:	fe f8 03 70 	ld.w	r8,pc[880]
80005788:	30 09       	mov	r9,0
8000578a:	91 09       	st.w	r8[0x0],r9
							break;
8000578c:	e0 8f 01 a9 	bral	80005ade <phy_payload_rx+0xe6a>
						}
						
						//AMBE Vocoder Bits Stream(bit59~63),
						if ((RxBytesWaiting -= 1) <= 0){
80005790:	fe f8 03 6c 	ld.w	r8,pc[876]
80005794:	70 08       	ld.w	r8,r8[0x0]
80005796:	f0 c9 00 01 	sub	r9,r8,1
8000579a:	fe f8 03 62 	ld.w	r8,pc[866]
8000579e:	91 09       	st.w	r8[0x0],r9
800057a0:	fe f8 03 5c 	ld.w	r8,pc[860]
800057a4:	70 08       	ld.w	r8,r8[0x0]
800057a6:	58 08       	cp.w	r8,0
800057a8:	e0 81 01 96 	brne	80005ad4 <phy_payload_rx+0xe60>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
800057ac:	fe f8 03 48 	ld.w	r8,pc[840]
800057b0:	30 09       	mov	r9,0
800057b2:	91 09       	st.w	r8[0x0],r9
							break;
800057b4:	e0 8f 01 95 	bral	80005ade <phy_payload_rx+0xe6a>
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800057b8:	fe f8 03 54 	ld.w	r8,pc[852]
800057bc:	11 88       	ld.ub	r8,r8[0x0]
800057be:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800057c2:	30 48       	mov	r8,4
800057c4:	f0 09 18 00 	cp.b	r9,r8
800057c8:	c0 a0       	breq	800057dc <phy_payload_rx+0xb68>
800057ca:	fe f8 03 42 	ld.w	r8,pc[834]
800057ce:	11 88       	ld.ub	r8,r8[0x0]
800057d0:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800057d4:	30 38       	mov	r8,3
800057d6:	f0 09 18 00 	cp.b	r9,r8
800057da:	c2 51       	brne	80005824 <phy_payload_rx+0xbb0>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800057dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057e0:	70 09       	ld.w	r9,r8[0x0]
800057e2:	fe f8 03 52 	ld.w	r8,pc[850]
800057e6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800057e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057ec:	70 19       	ld.w	r9,r8[0x4]
800057ee:	fe f8 03 46 	ld.w	r8,pc[838]
800057f2:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800057f4:	fe f8 03 08 	ld.w	r8,pc[776]
800057f8:	70 08       	ld.w	r8,r8[0x0]
800057fa:	f0 c9 00 08 	sub	r9,r8,8
800057fe:	fe f8 02 fe 	ld.w	r8,pc[766]
80005802:	91 09       	st.w	r8[0x0],r9
80005804:	fe f8 02 f8 	ld.w	r8,pc[760]
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	58 08       	cp.w	r8,0
8000580c:	e0 81 01 66 	brne	80005ad8 <phy_payload_rx+0xe64>
						{
					
							RxBytesWaiting = 0;
80005810:	fe f8 02 ec 	ld.w	r8,pc[748]
80005814:	30 09       	mov	r9,0
80005816:	91 09       	st.w	r8[0x0],r9
							RxMediaState = WAITINGABAB;
80005818:	fe f8 02 dc 	ld.w	r8,pc[732]
8000581c:	30 09       	mov	r9,0
8000581e:	91 09       	st.w	r8[0x0],r9
							break;
80005820:	e0 8f 01 5f 	bral	80005ade <phy_payload_rx+0xe6a>
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80005824:	fe f8 02 e8 	ld.w	r8,pc[744]
80005828:	11 88       	ld.ub	r8,r8[0x0]
8000582a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000582e:	31 38       	mov	r8,19
80005830:	f0 09 18 00 	cp.b	r9,r8
80005834:	e0 81 00 ea 	brne	80005a08 <phy_payload_rx+0xd94>
					{							
						if (SDV_Index == 12)
80005838:	fe f8 03 08 	ld.w	r8,pc[776]
8000583c:	11 89       	ld.ub	r9,r8[0x0]
8000583e:	30 c8       	mov	r8,12
80005840:	f0 09 18 00 	cp.b	r9,r8
80005844:	e0 81 00 b4 	brne	800059ac <phy_payload_rx+0xd38>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80005848:	fe f8 02 f8 	ld.w	r8,pc[760]
8000584c:	11 88       	ld.ub	r8,r8[0x0]
8000584e:	10 9a       	mov	r10,r8
80005850:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005854:	90 08       	ld.sh	r8,r8[0x0]
80005856:	fe f9 02 ee 	ld.w	r9,pc[750]
8000585a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							
							SDV_Index = 0;
8000585e:	fe f9 02 e2 	ld.w	r9,pc[738]
80005862:	30 08       	mov	r8,0
80005864:	b2 88       	st.b	r9[0x0],r8
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
80005866:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000586a:	11 d9       	ld.ub	r9,r8[0x5]
8000586c:	3f 38       	mov	r8,-13
8000586e:	f0 09 18 00 	cp.b	r9,r8
80005872:	e0 81 00 99 	brne	800059a4 <phy_payload_rx+0xd30>
							{
									Item_ID = Pre_Voice_Decoder_Data;
80005876:	fe f9 02 96 	ld.w	r9,pc[662]
8000587a:	3f 38       	mov	r8,-13
8000587c:	b2 88       	st.b	r9[0x0],r8
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000587e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005882:	11 c8       	ld.ub	r8,r8[0x4]
80005884:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
80005888:	fe f8 02 74 	ld.w	r8,pc[628]
8000588c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//AMBE
8000588e:	fe f9 02 ba 	ld.w	r9,pc[698]
80005892:	30 18       	mov	r8,1
80005894:	b2 88       	st.b	r9[0x0],r8
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//
80005896:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000589a:	90 38       	ld.sh	r8,r8[0x6]
8000589c:	fe f9 02 a0 	ld.w	r9,pc[672]
800058a0:	b2 08       	st.h	r9[0x0],r8
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800058a2:	fe f8 02 4e 	ld.w	r8,pc[590]
800058a6:	70 09       	ld.w	r9,r8[0x0]
800058a8:	fe f8 02 6c 	ld.w	r8,pc[620]
800058ac:	70 08       	ld.w	r8,r8[0x0]
800058ae:	10 09       	add	r9,r8
800058b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058b4:	11 e8       	ld.ub	r8,r8[0x6]
800058b6:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
800058b8:	fe f8 02 5c 	ld.w	r8,pc[604]
800058bc:	70 08       	ld.w	r8,r8[0x0]
800058be:	f0 c9 ff ff 	sub	r9,r8,-1
800058c2:	fe f8 02 52 	ld.w	r8,pc[594]
800058c6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800058c8:	fe f8 02 4c 	ld.w	r8,pc[588]
800058cc:	70 08       	ld.w	r8,r8[0x0]
800058ce:	e0 48 01 ff 	cp.w	r8,511
800058d2:	e0 88 00 1e 	brls	8000590e <phy_payload_rx+0xc9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800058d6:	fe f8 02 3e 	ld.w	r8,pc[574]
800058da:	30 09       	mov	r9,0
800058dc:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800058de:	fe f8 02 12 	ld.w	r8,pc[530]
800058e2:	70 08       	ld.w	r8,r8[0x0]
800058e4:	10 9c       	mov	r12,r8
800058e6:	f0 1f 00 8e 	mcall	80005b1c <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
800058ea:	fe f8 01 fe 	ld.w	r8,pc[510]
800058ee:	70 08       	ld.w	r8,r8[0x0]
800058f0:	10 9c       	mov	r12,r8
800058f2:	f0 1f 00 7f 	mcall	80005aec <phy_payload_rx+0xe78>
800058f6:	18 98       	mov	r8,r12
800058f8:	10 99       	mov	r9,r8
800058fa:	4f e8       	lddpc	r8,80005af0 <phy_payload_rx+0xe7c>
800058fc:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
800058fe:	4f d8       	lddpc	r8,80005af0 <phy_payload_rx+0xe7c>
80005900:	70 08       	ld.w	r8,r8[0x0]
80005902:	58 08       	cp.w	r8,0
80005904:	c0 51       	brne	8000590e <phy_payload_rx+0xc9a>
										{
											RxMediaState = WAITINGABAB;
80005906:	4f c8       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005908:	30 09       	mov	r9,0
8000590a:	91 09       	st.w	r8[0x0],r9
											break;
8000590c:	ce 98       	rjmp	80005ade <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000590e:	4f c8       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
80005910:	70 08       	ld.w	r8,r8[0x0]
80005912:	f0 c9 00 01 	sub	r9,r8,1
80005916:	4f a8       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
80005918:	91 09       	st.w	r8[0x0],r9
8000591a:	4f 98       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
8000591c:	70 08       	ld.w	r8,r8[0x0]
8000591e:	58 08       	cp.w	r8,0
80005920:	c0 51       	brne	8000592a <phy_payload_rx+0xcb6>
										RxMediaState = WAITINGABAB;
80005922:	4f 58       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005924:	30 09       	mov	r9,0
80005926:	91 09       	st.w	r8[0x0],r9
										break;
80005928:	cd b8       	rjmp	80005ade <phy_payload_rx+0xe6a>
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000592a:	4f 28       	lddpc	r8,80005af0 <phy_payload_rx+0xe7c>
8000592c:	70 09       	ld.w	r9,r8[0x0]
8000592e:	4f a8       	lddpc	r8,80005b14 <phy_payload_rx+0xea0>
80005930:	70 08       	ld.w	r8,r8[0x0]
80005932:	10 09       	add	r9,r8
80005934:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005938:	11 f8       	ld.ub	r8,r8[0x7]
8000593a:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
8000593c:	4f 68       	lddpc	r8,80005b14 <phy_payload_rx+0xea0>
8000593e:	70 08       	ld.w	r8,r8[0x0]
80005940:	f0 c9 ff ff 	sub	r9,r8,-1
80005944:	4f 48       	lddpc	r8,80005b14 <phy_payload_rx+0xea0>
80005946:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005948:	4f 38       	lddpc	r8,80005b14 <phy_payload_rx+0xea0>
8000594a:	70 08       	ld.w	r8,r8[0x0]
8000594c:	e0 48 01 ff 	cp.w	r8,511
80005950:	e0 88 00 1b 	brls	80005986 <phy_payload_rx+0xd12>
									{
										RxAMBE_IsFillingNext8 = 0;
80005954:	4f 08       	lddpc	r8,80005b14 <phy_payload_rx+0xea0>
80005956:	30 09       	mov	r9,0
80005958:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000595a:	4e 68       	lddpc	r8,80005af0 <phy_payload_rx+0xe7c>
8000595c:	70 08       	ld.w	r8,r8[0x0]
8000595e:	10 9c       	mov	r12,r8
80005960:	f0 1f 00 6f 	mcall	80005b1c <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
80005964:	4e 18       	lddpc	r8,80005ae8 <phy_payload_rx+0xe74>
80005966:	70 08       	ld.w	r8,r8[0x0]
80005968:	10 9c       	mov	r12,r8
8000596a:	f0 1f 00 61 	mcall	80005aec <phy_payload_rx+0xe78>
8000596e:	18 98       	mov	r8,r12
80005970:	10 99       	mov	r9,r8
80005972:	4e 08       	lddpc	r8,80005af0 <phy_payload_rx+0xe7c>
80005974:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
80005976:	4d f8       	lddpc	r8,80005af0 <phy_payload_rx+0xe7c>
80005978:	70 08       	ld.w	r8,r8[0x0]
8000597a:	58 08       	cp.w	r8,0
8000597c:	c0 51       	brne	80005986 <phy_payload_rx+0xd12>
										{
											RxMediaState = WAITINGABAB;
8000597e:	4d e8       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005980:	30 09       	mov	r9,0
80005982:	91 09       	st.w	r8[0x0],r9
											break;
80005984:	ca d8       	rjmp	80005ade <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80005986:	4d e8       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
80005988:	70 08       	ld.w	r8,r8[0x0]
8000598a:	f0 c9 00 01 	sub	r9,r8,1
8000598e:	4d c8       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
80005990:	91 09       	st.w	r8[0x0],r9
80005992:	4d b8       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
80005994:	70 08       	ld.w	r8,r8[0x0]
80005996:	58 08       	cp.w	r8,0
80005998:	e0 81 00 a2 	brne	80005adc <phy_payload_rx+0xe68>
										RxMediaState = WAITINGABAB;
8000599c:	4d 68       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
8000599e:	30 09       	mov	r9,0
800059a0:	91 09       	st.w	r8[0x0],r9
										break;
800059a2:	c9 e8       	rjmp	80005ade <phy_payload_rx+0xe6a>
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800059a4:	4d 48       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
800059a6:	30 09       	mov	r9,0
800059a8:	91 09       	st.w	r8[0x0],r9
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
800059aa:	c9 a8       	rjmp	80005ade <phy_payload_rx+0xe6a>
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800059ac:	4e 58       	lddpc	r8,80005b40 <phy_payload_rx+0xecc>
800059ae:	11 88       	ld.ub	r8,r8[0x0]
800059b0:	10 9a       	mov	r10,r8
800059b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059b6:	90 08       	ld.sh	r8,r8[0x0]
800059b8:	4e 39       	lddpc	r9,80005b44 <phy_payload_rx+0xed0>
800059ba:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800059be:	4e 18       	lddpc	r8,80005b40 <phy_payload_rx+0xecc>
800059c0:	11 88       	ld.ub	r8,r8[0x0]
800059c2:	f0 ca ff ff 	sub	r10,r8,-1
800059c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059ca:	90 18       	ld.sh	r8,r8[0x2]
800059cc:	4d e9       	lddpc	r9,80005b44 <phy_payload_rx+0xed0>
800059ce:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800059d2:	4d c8       	lddpc	r8,80005b40 <phy_payload_rx+0xecc>
800059d4:	11 88       	ld.ub	r8,r8[0x0]
800059d6:	f0 ca ff fe 	sub	r10,r8,-2
800059da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059de:	90 28       	ld.sh	r8,r8[0x4]
800059e0:	4d 99       	lddpc	r9,80005b44 <phy_payload_rx+0xed0>
800059e2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800059e6:	4d 78       	lddpc	r8,80005b40 <phy_payload_rx+0xecc>
800059e8:	11 88       	ld.ub	r8,r8[0x0]
800059ea:	f0 ca ff fd 	sub	r10,r8,-3
800059ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059f2:	90 38       	ld.sh	r8,r8[0x6]
800059f4:	4d 49       	lddpc	r9,80005b44 <phy_payload_rx+0xed0>
800059f6:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							SDV_Index +=4;
800059fa:	4d 28       	lddpc	r8,80005b40 <phy_payload_rx+0xecc>
800059fc:	11 88       	ld.ub	r8,r8[0x0]
800059fe:	2f c8       	sub	r8,-4
80005a00:	5c 58       	castu.b	r8
80005a02:	4d 09       	lddpc	r9,80005b40 <phy_payload_rx+0xecc>
80005a04:	b2 88       	st.b	r9[0x0],r8
									
						}
							
							break;
80005a06:	c6 c8       	rjmp	80005ade <phy_payload_rx+0xe6a>
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80005a08:	4b b8       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005a0a:	30 09       	mov	r9,0
80005a0c:	91 09       	st.w	r8[0x0],r9
						break;
80005a0e:	c6 88       	rjmp	80005ade <phy_payload_rx+0xe6a>
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80005a10:	4c 78       	lddpc	r8,80005b2c <phy_payload_rx+0xeb8>
80005a12:	70 0a       	ld.w	r10,r8[0x0]
80005a14:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a18:	90 08       	ld.sh	r8,r8[0x0]
80005a1a:	4c 69       	lddpc	r9,80005b30 <phy_payload_rx+0xebc>
80005a1c:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				RxData_IsFillingNext16 += 1;
80005a20:	4c 38       	lddpc	r8,80005b2c <phy_payload_rx+0xeb8>
80005a22:	70 08       	ld.w	r8,r8[0x0]
80005a24:	f0 c9 ff ff 	sub	r9,r8,-1
80005a28:	4c 18       	lddpc	r8,80005b2c <phy_payload_rx+0xeb8>
80005a2a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80005a2c:	4b 98       	lddpc	r8,80005b10 <phy_payload_rx+0xe9c>
80005a2e:	70 08       	ld.w	r8,r8[0x0]
80005a30:	f0 c9 00 02 	sub	r9,r8,2
80005a34:	4b 78       	lddpc	r8,80005b10 <phy_payload_rx+0xe9c>
80005a36:	91 09       	st.w	r8[0x0],r9
80005a38:	4b 68       	lddpc	r8,80005b10 <phy_payload_rx+0xe9c>
80005a3a:	70 08       	ld.w	r8,r8[0x0]
80005a3c:	58 08       	cp.w	r8,0
80005a3e:	c3 e1       	brne	80005aba <phy_payload_rx+0xe46>
				{
					RxData_IsFillingNext16 = 0;
80005a40:	4b b8       	lddpc	r8,80005b2c <phy_payload_rx+0xeb8>
80005a42:	30 09       	mov	r9,0
80005a44:	91 09       	st.w	r8[0x0],r9
				
					if (payload_rx_channel->word[1] == 0x8212 )
80005a46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a4a:	90 19       	ld.sh	r9,r8[0x2]
80005a4c:	fe 78 82 12 	mov	r8,-32238
80005a50:	f0 09 19 00 	cp.h	r9,r8
80005a54:	c2 f1       	brne	80005ab2 <phy_payload_rx+0xe3e>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80005a56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a5a:	11 d8       	ld.ub	r8,r8[0x5]
80005a5c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80005a60:	4b 09       	lddpc	r9,80005b20 <phy_payload_rx+0xeac>
80005a62:	b2 88       	st.b	r9[0x0],r8
							
						VBSP_data[0] = payload_rx_channel->word[1];
80005a64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a68:	90 18       	ld.sh	r8,r8[0x2]
80005a6a:	4a f9       	lddpc	r9,80005b24 <phy_payload_rx+0xeb0>
80005a6c:	b2 08       	st.h	r9[0x0],r8
						VBSP_data[1] = payload_rx_channel->word[2];
80005a6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a72:	90 28       	ld.sh	r8,r8[0x4]
80005a74:	4a c9       	lddpc	r9,80005b24 <phy_payload_rx+0xeb0>
80005a76:	b2 18       	st.h	r9[0x2],r8
							
						m_RxBurstType = CalculateBurst(VF_SN);
80005a78:	4a a8       	lddpc	r8,80005b20 <phy_payload_rx+0xeac>
80005a7a:	11 88       	ld.ub	r8,r8[0x0]
80005a7c:	10 9c       	mov	r12,r8
80005a7e:	f0 1f 00 2b 	mcall	80005b28 <phy_payload_rx+0xeb4>
80005a82:	18 99       	mov	r9,r12
80005a84:	49 d8       	lddpc	r8,80005af8 <phy_payload_rx+0xe84>
80005a86:	91 09       	st.w	r8[0x0],r9
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
80005a88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a8c:	11 f9       	ld.ub	r9,r8[0x7]
80005a8e:	31 38       	mov	r8,19
80005a90:	f0 09 18 00 	cp.b	r9,r8
80005a94:	c0 81       	brne	80005aa4 <phy_payload_rx+0xe30>
						{
							Item_ID = Soft_Decision_Value;	
80005a96:	49 e9       	lddpc	r9,80005b0c <phy_payload_rx+0xe98>
80005a98:	31 38       	mov	r8,19
80005a9a:	b2 88       	st.b	r9[0x0],r8
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80005a9c:	49 88       	lddpc	r8,80005afc <phy_payload_rx+0xe88>
80005a9e:	30 09       	mov	r9,0
80005aa0:	91 09       	st.w	r8[0x0],r9
80005aa2:	c0 48       	rjmp	80005aaa <phy_payload_rx+0xe36>
						}
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
80005aa4:	49 48       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005aa6:	30 09       	mov	r9,0
80005aa8:	91 09       	st.w	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80005aaa:	49 38       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005aac:	30 49       	mov	r9,4
80005aae:	91 09       	st.w	r8[0x0],r9
80005ab0:	c1 78       	rjmp	80005ade <phy_payload_rx+0xe6a>
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80005ab2:	49 18       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005ab4:	30 09       	mov	r9,0
80005ab6:	91 09       	st.w	r8[0x0],r9
80005ab8:	c1 38       	rjmp	80005ade <phy_payload_rx+0xe6a>
					}

				}
				else
				{//
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80005aba:	4a 5c       	lddpc	r12,80005b4c <phy_payload_rx+0xed8>
80005abc:	f0 1f 00 12 	mcall	80005b04 <phy_payload_rx+0xe90>
					RxMediaState = WAITINGABAB;//Jump
80005ac0:	48 d8       	lddpc	r8,80005af4 <phy_payload_rx+0xe80>
80005ac2:	30 09       	mov	r9,0
80005ac4:	91 09       	st.w	r8[0x0],r9
80005ac6:	c0 c8       	rjmp	80005ade <phy_payload_rx+0xe6a>
				m_RxBurstType = VOICE_WATING;
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80005ac8:	d7 03       	nop
80005aca:	c0 a8       	rjmp	80005ade <phy_payload_rx+0xe6a>
						RxMediaState  = WAITINGABAB;
						break;
					}
			
			
			break;//End of READING_AMBE_MEDIA.
80005acc:	d7 03       	nop
80005ace:	c0 88       	rjmp	80005ade <phy_payload_rx+0xe6a>
80005ad0:	d7 03       	nop
80005ad2:	c0 68       	rjmp	80005ade <phy_payload_rx+0xe6a>
80005ad4:	d7 03       	nop
80005ad6:	c0 48       	rjmp	80005ade <phy_payload_rx+0xe6a>
							RxBytesWaiting = 0;
							RxMediaState = WAITINGABAB;
							break;
			
						}
						break;
80005ad8:	d7 03       	nop
80005ada:	c0 28       	rjmp	80005ade <phy_payload_rx+0xe6a>
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
80005adc:	d7 03       	nop

#endif
		case BGFORCERESET: //Do nothing.
		break;
	}//End of RxMedia Phy Handler.
}
80005ade:	2f ed       	sub	sp,-8
80005ae0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ae4:	00 00       	add	r0,r0
80005ae6:	0a a0       	st.w	r5++,r0
80005ae8:	00 00       	add	r0,r0
80005aea:	0a 88       	andn	r8,r5
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	5b 90       	cp.w	r0,-7
80005af0:	00 00       	add	r0,r0
80005af2:	0a a4       	st.w	r5++,r4
80005af4:	00 00       	add	r0,r0
80005af6:	0a a8       	st.w	r5++,r8
80005af8:	00 00       	add	r0,r0
80005afa:	0a 94       	mov	r4,r5
80005afc:	00 00       	add	r0,r0
80005afe:	0a ac       	st.w	r5++,r12
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	3e b8       	mov	r8,-21
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	a1 f4       	*unknown*
80005b08:	00 00       	add	r0,r0
80005b0a:	0a 53       	eor	r3,r5
80005b0c:	00 00       	add	r0,r0
80005b0e:	0a b0       	st.h	r5++,r0
80005b10:	00 00       	add	r0,r0
80005b12:	0a b4       	st.h	r5++,r4
80005b14:	00 00       	add	r0,r0
80005b16:	0a b8       	st.h	r5++,r8
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	ad be       	sbr	lr,0xd
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	4b f8       	lddpc	r8,80005c18 <set_idle_store_isr+0x14>
80005b20:	00 00       	add	r0,r0
80005b22:	0a 57       	eor	r7,r5
80005b24:	00 00       	add	r0,r0
80005b26:	0e 9c       	mov	r12,r7
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	3d 7c       	mov	r12,-41
80005b2c:	00 00       	add	r0,r0
80005b2e:	0a bc       	st.h	r5++,r12
80005b30:	00 00       	add	r0,r0
80005b32:	0d a0       	ld.ub	r0,r6[0x2]
80005b34:	00 00       	add	r0,r0
80005b36:	0a 98       	mov	r8,r5
80005b38:	00 00       	add	r0,r0
80005b3a:	0a 52       	eor	r2,r5
80005b3c:	00 00       	add	r0,r0
80005b3e:	0d 98       	ld.ub	r8,r6[0x1]
80005b40:	00 00       	add	r0,r0
80005b42:	0a c0       	st.b	r5++,r0
80005b44:	00 00       	add	r0,r0
80005b46:	0e a0       	st.w	r7++,r0
80005b48:	00 00       	add	r0,r0
80005b4a:	0a 51       	eor	r1,r5
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	3e d0       	mov	r0,-19

80005b50 <get_idle_store>:
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80005b50:	eb cd 40 80 	pushm	r7,lr
80005b54:	1a 97       	mov	r7,sp
80005b56:	20 2d       	sub	sp,8
80005b58:	ef 4c ff f8 	st.w	r7[-8],r12
	void * ptr = NULL;
80005b5c:	30 08       	mov	r8,0
80005b5e:	ef 48 ff fc 	st.w	r7[-4],r8

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80005b62:	ee c8 00 04 	sub	r8,r7,4
80005b66:	30 09       	mov	r9,0
80005b68:	30 0a       	mov	r10,0
80005b6a:	10 9b       	mov	r11,r8
80005b6c:	ee fc ff f8 	ld.w	r12,r7[-8]
80005b70:	f0 1f 00 07 	mcall	80005b8c <get_idle_store+0x3c>
80005b74:	18 98       	mov	r8,r12
80005b76:	58 18       	cp.w	r8,1
80005b78:	c0 41       	brne	80005b80 <get_idle_store+0x30>
	{
		return ptr;
80005b7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005b7e:	c0 28       	rjmp	80005b82 <get_idle_store+0x32>
	}
	else
	{
		return NULL;
80005b80:	30 08       	mov	r8,0
	}
}
80005b82:	10 9c       	mov	r12,r8
80005b84:	2f ed       	sub	sp,-8
80005b86:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b8a:	00 00       	add	r0,r0
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	88 64       	ld.sh	r4,r4[0xc]

80005b90 <get_idle_store_isr>:

void * get_idle_store_isr(xQueueHandle store)
{
80005b90:	eb cd 40 80 	pushm	r7,lr
80005b94:	1a 97       	mov	r7,sp
80005b96:	20 3d       	sub	sp,12
80005b98:	ef 4c ff f4 	st.w	r7[-12],r12
	void * ptr = NULL;
80005b9c:	30 08       	mov	r8,0
80005b9e:	ef 48 ff fc 	st.w	r7[-4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005ba2:	30 08       	mov	r8,0
80005ba4:	ef 48 ff f8 	st.w	r7[-8],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80005ba8:	ee c9 00 08 	sub	r9,r7,8
80005bac:	ee c8 00 04 	sub	r8,r7,4
80005bb0:	12 9a       	mov	r10,r9
80005bb2:	10 9b       	mov	r11,r8
80005bb4:	ee fc ff f4 	ld.w	r12,r7[-12]
80005bb8:	f0 1f 00 07 	mcall	80005bd4 <get_idle_store_isr+0x44>
80005bbc:	18 98       	mov	r8,r12
80005bbe:	58 18       	cp.w	r8,1
80005bc0:	c0 41       	brne	80005bc8 <get_idle_store_isr+0x38>
	{
		return ptr;
80005bc2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bc6:	c0 28       	rjmp	80005bca <get_idle_store_isr+0x3a>
	}
	else
	{
		return NULL;
80005bc8:	30 08       	mov	r8,0
	}
}
80005bca:	10 9c       	mov	r12,r8
80005bcc:	2f dd       	sub	sp,-12
80005bce:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bd2:	00 00       	add	r0,r0
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	8a 50       	ld.sh	r0,r5[0xa]

80005bd8 <set_idle_store>:


void set_idle_store(xQueueHandle store, void * ptr)
{
80005bd8:	eb cd 40 80 	pushm	r7,lr
80005bdc:	1a 97       	mov	r7,sp
80005bde:	20 2d       	sub	sp,8
80005be0:	ef 4c ff fc 	st.w	r7[-4],r12
80005be4:	ef 4b ff f8 	st.w	r7[-8],r11
	xQueueSend(store, &ptr, 0);
80005be8:	ee c8 00 08 	sub	r8,r7,8
80005bec:	30 09       	mov	r9,0
80005bee:	30 0a       	mov	r10,0
80005bf0:	10 9b       	mov	r11,r8
80005bf2:	ee fc ff fc 	ld.w	r12,r7[-4]
80005bf6:	f0 1f 00 03 	mcall	80005c00 <set_idle_store+0x28>
}
80005bfa:	2f ed       	sub	sp,-8
80005bfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	86 58       	ld.sh	r8,r3[0xa]

80005c04 <set_idle_store_isr>:

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80005c04:	eb cd 40 80 	pushm	r7,lr
80005c08:	1a 97       	mov	r7,sp
80005c0a:	20 3d       	sub	sp,12
80005c0c:	ef 4c ff f8 	st.w	r7[-8],r12
80005c10:	ef 4b ff f4 	st.w	r7[-12],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005c14:	30 08       	mov	r8,0
80005c16:	ef 48 ff fc 	st.w	r7[-4],r8
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80005c1a:	ee ca 00 04 	sub	r10,r7,4
80005c1e:	ee c8 00 0c 	sub	r8,r7,12
80005c22:	30 09       	mov	r9,0
80005c24:	10 9b       	mov	r11,r8
80005c26:	ee fc ff f8 	ld.w	r12,r7[-8]
80005c2a:	f0 1f 00 03 	mcall	80005c34 <set_idle_store_isr+0x30>
}
80005c2e:	2f dd       	sub	sp,-12
80005c30:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	87 c0       	st.w	r3[0x30],r0

80005c38 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80005c38:	eb cd 40 80 	pushm	r7,lr
80005c3c:	1a 97       	mov	r7,sp
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80005c3e:	4a 98       	lddpc	r8,80005ce0 <pdca_int_handler+0xa8>
80005c40:	11 88       	ld.ub	r8,r8[0x0]
80005c42:	5c 58       	castu.b	r8
80005c44:	ec 18 00 01 	eorl	r8,0x1
80005c48:	5c 58       	castu.b	r8
80005c4a:	4a 69       	lddpc	r9,80005ce0 <pdca_int_handler+0xa8>
80005c4c:	b2 88       	st.b	r9[0x0],r8
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80005c4e:	fe 79 00 40 	mov	r9,-65472
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80005c52:	4a 48       	lddpc	r8,80005ce0 <pdca_int_handler+0xa8>
80005c54:	11 88       	ld.ub	r8,r8[0x0]
80005c56:	5c 58       	castu.b	r8
80005c58:	a3 68       	lsl	r8,0x2
80005c5a:	2f f8       	sub	r8,-1
80005c5c:	f0 0a 15 02 	lsl	r10,r8,0x2
80005c60:	4a 18       	lddpc	r8,80005ce4 <pdca_int_handler+0xac>
80005c62:	f4 08 00 08 	add	r8,r10,r8
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80005c66:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80005c68:	fe 78 00 40 	mov	r8,-65472
80005c6c:	30 39       	mov	r9,3
80005c6e:	91 49       	st.w	r8[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80005c70:	fe 79 00 00 	mov	r9,-65536
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80005c74:	49 b8       	lddpc	r8,80005ce0 <pdca_int_handler+0xa8>
80005c76:	11 88       	ld.ub	r8,r8[0x0]
80005c78:	5c 58       	castu.b	r8
80005c7a:	a3 68       	lsl	r8,0x2
80005c7c:	2f f8       	sub	r8,-1
80005c7e:	f0 0a 15 02 	lsl	r10,r8,0x2
80005c82:	49 a8       	lddpc	r8,80005ce8 <pdca_int_handler+0xb0>
80005c84:	f4 08 00 08 	add	r8,r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80005c88:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80005c8a:	fe 78 00 00 	mov	r8,-65536
80005c8e:	30 39       	mov	r9,3
80005c90:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80005c92:	fe 78 00 00 	mov	r8,-65536
80005c96:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80005c98:	49 58       	lddpc	r8,80005cec <pdca_int_handler+0xb4>
80005c9a:	70 08       	ld.w	r8,r8[0x0]
80005c9c:	58 08       	cp.w	r8,0
80005c9e:	c0 d0       	breq	80005cb8 <pdca_int_handler+0x80>
80005ca0:	49 38       	lddpc	r8,80005cec <pdca_int_handler+0xb4>
80005ca2:	70 09       	ld.w	r9,r8[0x0]
80005ca4:	48 f8       	lddpc	r8,80005ce0 <pdca_int_handler+0xa8>
80005ca6:	11 88       	ld.ub	r8,r8[0x0]
80005ca8:	5c 58       	castu.b	r8
80005caa:	f0 0a 15 04 	lsl	r10,r8,0x4
80005cae:	48 f8       	lddpc	r8,80005ce8 <pdca_int_handler+0xb0>
80005cb0:	f4 08 00 08 	add	r8,r10,r8
80005cb4:	10 9c       	mov	r12,r8
80005cb6:	5d 19       	icall	r9

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80005cb8:	48 e8       	lddpc	r8,80005cf0 <pdca_int_handler+0xb8>
80005cba:	70 08       	ld.w	r8,r8[0x0]
80005cbc:	58 08       	cp.w	r8,0
80005cbe:	c0 d0       	breq	80005cd8 <pdca_int_handler+0xa0>
80005cc0:	48 c8       	lddpc	r8,80005cf0 <pdca_int_handler+0xb8>
80005cc2:	70 09       	ld.w	r9,r8[0x0]
80005cc4:	48 78       	lddpc	r8,80005ce0 <pdca_int_handler+0xa8>
80005cc6:	11 88       	ld.ub	r8,r8[0x0]
80005cc8:	5c 58       	castu.b	r8
80005cca:	f0 0a 15 04 	lsl	r10,r8,0x4
80005cce:	48 68       	lddpc	r8,80005ce4 <pdca_int_handler+0xac>
80005cd0:	f4 08 00 08 	add	r8,r10,r8
80005cd4:	10 9c       	mov	r12,r8
80005cd6:	5d 19       	icall	r9

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80005cd8:	e3 cd 40 80 	ldm	sp++,r7,lr
80005cdc:	d6 03       	rete
80005cde:	00 00       	add	r0,r0
80005ce0:	00 00       	add	r0,r0
80005ce2:	40 c0       	lddsp	r0,sp[0x30]
80005ce4:	00 00       	add	r0,r0
80005ce6:	40 e8       	lddsp	r8,sp[0x38]
80005ce8:	00 00       	add	r0,r0
80005cea:	40 c8       	lddsp	r8,sp[0x30]
80005cec:	00 00       	add	r0,r0
80005cee:	0a f0       	st.b	--r5,r0
80005cf0:	00 00       	add	r0,r0
80005cf2:	0a f4       	st.b	--r5,r4

80005cf4 <local_start_SSC>:
    Before using the SSC transmitter, the PIO controller must be configured to 
    dedicate the SSC,transmitter I/O lines to the SSC peripheral mode. [23.6.1]
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_SSC(void)
{
80005cf4:	eb cd 40 80 	pushm	r7,lr
80005cf8:	1a 97       	mov	r7,sp
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80005cfa:	fe 78 10 00 	mov	r8,-61440
80005cfe:	e0 69 0d c0 	mov	r9,3520
80005d02:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80005d06:	fe 78 10 00 	mov	r8,-61440
80005d0a:	e0 69 0d c0 	mov	r9,3520
80005d0e:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80005d12:	fe 78 10 00 	mov	r8,-61440
80005d16:	e0 69 0d c0 	mov	r9,3520
80005d1a:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80005d1e:	fe 78 34 00 	mov	r8,-52224
80005d22:	e0 69 80 00 	mov	r9,32768
80005d26:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80005d28:	fe 78 34 00 	mov	r8,-52224
80005d2c:	30 09       	mov	r9,0
80005d2e:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80005d30:	fe 78 34 00 	mov	r8,-52224
80005d34:	e0 69 04 21 	mov	r9,1057
80005d38:	ea 19 3f 20 	orh	r9,0x3f20
80005d3c:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80005d3e:	fe 78 34 00 	mov	r8,-52224
80005d42:	e0 69 02 9f 	mov	r9,671
80005d46:	ea 19 01 00 	orh	r9,0x100
80005d4a:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80005d4c:	fe 78 34 00 	mov	r8,-52224
80005d50:	e0 69 04 02 	mov	r9,1026
80005d54:	ea 19 3f 20 	orh	r9,0x3f20
80005d58:	91 49       	st.w	r8[0x10],r9
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80005d5a:	fe 78 34 00 	mov	r8,-52224
80005d5e:	e0 69 02 9f 	mov	r9,671
80005d62:	ea 19 01 00 	orh	r9,0x100
80005d66:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80005d68:	e3 cd 80 80 	ldm	sp++,r7,pc

80005d6c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80005d6c:	eb cd 40 80 	pushm	r7,lr
80005d70:	1a 97       	mov	r7,sp
    /*Toggle Index*/	
    BufferIndex = 1;
80005d72:	4b 39       	lddpc	r9,80005e3c <local_start_PDC+0xd0>
80005d74:	30 18       	mov	r8,1
80005d76:	b2 88       	st.b	r9[0x0],r8
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80005d78:	fe 78 00 00 	mov	r8,-65536
80005d7c:	30 79       	mov	r9,7
80005d7e:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80005d80:	fe 78 00 00 	mov	r8,-65536
80005d84:	70 b8       	ld.w	r8,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80005d86:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80005d8a:	4a e9       	lddpc	r9,80005e40 <local_start_PDC+0xd4>
80005d8c:	2f c9       	sub	r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80005d8e:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80005d90:	fe 78 00 00 	mov	r8,-65536
80005d94:	30 39       	mov	r9,3
80005d96:	91 29       	st.w	r8[0x8],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80005d98:	fe 78 00 00 	mov	r8,-65536
80005d9c:	30 19       	mov	r9,1
80005d9e:	91 19       	st.w	r8[0x4],r9
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80005da0:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80005da4:	4a 79       	lddpc	r9,80005e40 <local_start_PDC+0xd4>
80005da6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80005da8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80005daa:	fe 78 00 00 	mov	r8,-65536
80005dae:	30 39       	mov	r9,3
80005db0:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80005db2:	fe 78 00 00 	mov	r8,-65536
80005db6:	30 29       	mov	r9,2
80005db8:	91 69       	st.w	r8[0x18],r9

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80005dba:	4a 38       	lddpc	r8,80005e44 <local_start_PDC+0xd8>
80005dbc:	e0 69 5a 5a 	mov	r9,23130
80005dc0:	ea 19 ab cd 	orh	r9,0xabcd
80005dc4:	91 19       	st.w	r8[0x4],r9
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80005dc6:	4a 08       	lddpc	r8,80005e44 <local_start_PDC+0xd8>
80005dc8:	e0 69 5a 5a 	mov	r9,23130
80005dcc:	ea 19 ab cd 	orh	r9,0xabcd
80005dd0:	91 29       	st.w	r8[0x8],r9
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80005dd2:	49 d8       	lddpc	r8,80005e44 <local_start_PDC+0xd8>
80005dd4:	30 09       	mov	r9,0
80005dd6:	91 39       	st.w	r8[0xc],r9
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80005dd8:	49 b8       	lddpc	r8,80005e44 <local_start_PDC+0xd8>
80005dda:	e0 69 5a 5a 	mov	r9,23130
80005dde:	ea 19 ab cd 	orh	r9,0xabcd
80005de2:	91 59       	st.w	r8[0x14],r9
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80005de4:	49 88       	lddpc	r8,80005e44 <local_start_PDC+0xd8>
80005de6:	e0 69 5a 5a 	mov	r9,23130
80005dea:	ea 19 ab cd 	orh	r9,0xabcd
80005dee:	91 69       	st.w	r8[0x18],r9
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80005df0:	49 58       	lddpc	r8,80005e44 <local_start_PDC+0xd8>
80005df2:	30 09       	mov	r9,0
80005df4:	91 79       	st.w	r8[0x1c],r9

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80005df6:	fe 78 00 40 	mov	r8,-65472
80005dfa:	30 79       	mov	r9,7
80005dfc:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80005dfe:	fe 78 00 40 	mov	r8,-65472
80005e02:	70 b8       	ld.w	r8,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80005e04:	fe 78 00 40 	mov	r8,-65472
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80005e08:	48 f9       	lddpc	r9,80005e44 <local_start_PDC+0xd8>
80005e0a:	2f c9       	sub	r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80005e0c:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80005e0e:	fe 78 00 40 	mov	r8,-65472
80005e12:	30 39       	mov	r9,3
80005e14:	91 29       	st.w	r8[0x8],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80005e16:	fe 78 00 40 	mov	r8,-65472
80005e1a:	30 79       	mov	r9,7
80005e1c:	91 19       	st.w	r8[0x4],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80005e1e:	fe 78 00 40 	mov	r8,-65472
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80005e22:	48 99       	lddpc	r9,80005e44 <local_start_PDC+0xd8>
80005e24:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80005e26:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80005e28:	fe 78 00 40 	mov	r8,-65472
80005e2c:	30 39       	mov	r9,3
80005e2e:	91 49       	st.w	r8[0x10],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80005e30:	fe 78 00 40 	mov	r8,-65472
80005e34:	30 29       	mov	r9,2
80005e36:	91 69       	st.w	r8[0x18],r9
}/*End of local_start_PDC.*/
80005e38:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e3c:	00 00       	add	r0,r0
80005e3e:	40 c0       	lddsp	r0,sp[0x30]
80005e40:	00 00       	add	r0,r0
80005e42:	40 c8       	lddsp	r8,sp[0x30]
80005e44:	00 00       	add	r0,r0
80005e46:	40 e8       	lddsp	r8,sp[0x38]

80005e48 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80005e48:	eb cd 40 80 	pushm	r7,lr
80005e4c:	1a 97       	mov	r7,sp
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;	
80005e4e:	fe 78 10 00 	mov	r8,-61440
80005e52:	30 29       	mov	r9,2
80005e54:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80005e58:	fe 78 10 00 	mov	r8,-61440
80005e5c:	30 29       	mov	r9,2
80005e5e:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80005e62:	fe 78 10 00 	mov	r8,-61440
80005e66:	f0 f8 01 60 	ld.w	r8,r8[352]
80005e6a:	e2 18 00 02 	andl	r8,0x2,COH
80005e6e:	cf a0       	breq	80005e62 <ssc_init+0x1a>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80005e70:	fe 78 10 00 	mov	r8,-61440
80005e74:	f0 f8 01 60 	ld.w	r8,r8[352]
80005e78:	e2 18 00 02 	andl	r8,0x2,COH
80005e7c:	cf a1       	brne	80005e70 <ssc_init+0x28>
				
    INTC_register_interrupt (
80005e7e:	30 3a       	mov	r10,3
80005e80:	36 0b       	mov	r11,96
80005e82:	48 ec       	lddpc	r12,80005eb8 <ssc_init+0x70>
80005e84:	f0 1f 00 0e 	mcall	80005ebc <ssc_init+0x74>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80005e88:	f0 1f 00 0e 	mcall	80005ec0 <ssc_init+0x78>

    /*config the PDCA*/
    local_start_PDC();
80005e8c:	f0 1f 00 0e 	mcall	80005ec4 <ssc_init+0x7c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005e90:	fe 78 00 00 	mov	r8,-65536
80005e94:	30 19       	mov	r9,1
80005e96:	91 59       	st.w	r8[0x14],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005e98:	fe 78 00 40 	mov	r8,-65472
80005e9c:	30 19       	mov	r9,1
80005e9e:	91 59       	st.w	r8[0x14],r9
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80005ea0:	fe 78 34 00 	mov	r8,-52224
80005ea4:	e0 69 01 01 	mov	r9,257
80005ea8:	91 09       	st.w	r8[0x0],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80005eaa:	fe 78 00 00 	mov	r8,-65536
80005eae:	30 19       	mov	r9,1
80005eb0:	91 89       	st.w	r8[0x20],r9
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80005eb2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005eb6:	00 00       	add	r0,r0
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	5c 38       	neg	r8
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	6f b8       	ld.w	r8,r7[0x6c]
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	5c f4       	rol	r4
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	5d 6c       	*unknown*

80005ec8 <register_rx_tx_func>:
	void ( *tx_exec)(void *) -- send ssc function
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
80005ec8:	eb cd 40 80 	pushm	r7,lr
80005ecc:	1a 97       	mov	r7,sp
80005ece:	20 2d       	sub	sp,8
80005ed0:	ef 4c ff fc 	st.w	r7[-4],r12
80005ed4:	ef 4b ff f8 	st.w	r7[-8],r11
	 phy_rx_exec = rx_exec;
80005ed8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005edc:	48 58       	lddpc	r8,80005ef0 <register_rx_tx_func+0x28>
80005ede:	91 09       	st.w	r8[0x0],r9
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80005ee0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005ee4:	48 48       	lddpc	r8,80005ef4 <register_rx_tx_func+0x2c>
80005ee6:	91 09       	st.w	r8[0x0],r9
	 
}/*End of register_tx_rx_func.*/
80005ee8:	2f ed       	sub	sp,-8
80005eea:	e3 cd 80 80 	ldm	sp++,r7,pc
80005eee:	00 00       	add	r0,r0
80005ef0:	00 00       	add	r0,r0
80005ef2:	0a f0       	st.b	--r5,r0
80005ef4:	00 00       	add	r0,r0
80005ef6:	0a f4       	st.b	--r5,r4
80005ef8:	58 43       	cp.w	r3,4
80005efa:	4d 50       	lddpc	r0,8000604c <xcmp_exec_func+0x60>
80005efc:	5f 52       	srlt	r2
80005efe:	58 00       	cp.w	r0,0

80005f00 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80005f00:	eb cd 40 80 	pushm	r7,lr
80005f04:	1a 97       	mov	r7,sp
80005f06:	fa cd 01 08 	sub	sp,sp,264
80005f0a:	ef 4c fe fc 	st.w	r7[-260],r12
80005f0e:	16 98       	mov	r8,r11
80005f10:	ef 68 fe f8 	st.b	r7[-264],r8
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80005f14:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80005f18:	2f 08       	sub	r8,-16
80005f1a:	5c 88       	casts.h	r8
80005f1c:	5c 88       	casts.h	r8
80005f1e:	af a8       	sbr	r8,0xe
80005f20:	5c 88       	casts.h	r8
80005f22:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80005f26:	3f f8       	mov	r8,-1
80005f28:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80005f2c:	30 b8       	mov	r8,11
80005f2e:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80005f32:	3f f8       	mov	r8,-1
80005f34:	ef 58 ff 06 	st.h	r7[-250],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80005f38:	3f f8       	mov	r8,-1
80005f3a:	ef 58 ff 08 	st.h	r7[-248],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80005f3e:	3f f8       	mov	r8,-1
80005f40:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005f44:	3f f8       	mov	r8,-1
80005f46:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80005f4a:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80005f4e:	2f e8       	sub	r8,-2
80005f50:	10 99       	mov	r9,r8
80005f52:	ee c8 01 00 	sub	r8,r7,256
80005f56:	2f 08       	sub	r8,-16
80005f58:	12 9a       	mov	r10,r9
80005f5a:	ee fb fe fc 	ld.w	r11,r7[-260]
80005f5e:	10 9c       	mov	r12,r8
80005f60:	f0 1f 00 09 	mcall	80005f84 <xcmp_tx+0x84>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80005f64:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80005f68:	2f e8       	sub	r8,-2
80005f6a:	5c 88       	casts.h	r8
80005f6c:	5c 88       	casts.h	r8
80005f6e:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80005f72:	ee c8 01 00 	sub	r8,r7,256
80005f76:	10 9c       	mov	r12,r8
80005f78:	f0 1f 00 04 	mcall	80005f88 <xcmp_tx+0x88>
}
80005f7c:	2b ed       	sub	sp,-264
80005f7e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f82:	00 00       	add	r0,r0
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	ac 76       	st.h	r6[0xe],r6
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	69 78       	ld.w	r8,r4[0x5c]

80005f8c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80005f8c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f90:	1a 97       	mov	r7,sp
80005f92:	20 1d       	sub	sp,4
80005f94:	ee c6 ff f4 	sub	r6,r7,-12
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005f98:	49 08       	lddpc	r8,80005fd8 <xcmp_rx+0x4c>
80005f9a:	70 08       	ld.w	r8,r8[0x0]
80005f9c:	10 9c       	mov	r12,r8
80005f9e:	f0 1f 00 10 	mcall	80005fdc <xcmp_rx+0x50>
80005fa2:	18 98       	mov	r8,r12
80005fa4:	ef 48 ff fc 	st.w	r7[-4],r8
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80005fa8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fac:	58 08       	cp.w	r8,0
80005fae:	c1 20       	breq	80005fd2 <xcmp_rx+0x46>
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80005fb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fb4:	e0 6a 00 ca 	mov	r10,202
80005fb8:	0c 9b       	mov	r11,r6
80005fba:	10 9c       	mov	r12,r8
80005fbc:	f0 1f 00 09 	mcall	80005fe0 <xcmp_rx+0x54>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80005fc0:	48 98       	lddpc	r8,80005fe4 <xcmp_rx+0x58>
80005fc2:	70 08       	ld.w	r8,r8[0x0]
80005fc4:	ee cb 00 04 	sub	r11,r7,4
80005fc8:	30 09       	mov	r9,0
80005fca:	30 0a       	mov	r10,0
80005fcc:	10 9c       	mov	r12,r8
80005fce:	f0 1f 00 07 	mcall	80005fe8 <xcmp_rx+0x5c>
	}	
}
80005fd2:	2f fd       	sub	sp,-4
80005fd4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fd8:	00 00       	add	r0,r0
80005fda:	0a 7c       	tst	r12,r5
80005fdc:	80 00       	ld.sh	r0,r0[0x0]
80005fde:	5b 50       	cp.w	r0,-11
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	ac 76       	st.h	r6[0xe],r6
80005fe4:	00 00       	add	r0,r0
80005fe6:	0a f8       	st.b	--r5,r8
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	86 58       	ld.sh	r8,r3[0xa]

80005fec <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80005fec:	eb cd 40 80 	pushm	r7,lr
80005ff0:	1a 97       	mov	r7,sp
80005ff2:	20 2d       	sub	sp,8
80005ff4:	ef 4c ff fc 	st.w	r7[-4],r12
80005ff8:	ef 4b ff f8 	st.w	r7[-8],r11
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80005ffc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006000:	90 08       	ld.sh	r8,r8[0x0]
80006002:	5c 78       	castu.h	r8
80006004:	e2 18 f0 00 	andl	r8,0xf000,COH
80006008:	e0 48 80 00 	cp.w	r8,32768
8000600c:	c1 50       	breq	80006036 <xcmp_exec_func+0x4a>
8000600e:	e0 48 b0 00 	cp.w	r8,45056
80006012:	c1 e0       	breq	8000604e <xcmp_exec_func+0x62>
80006014:	58 08       	cp.w	r8,0
80006016:	c2 91       	brne	80006068 <xcmp_exec_func+0x7c>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80006018:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000601c:	70 08       	ld.w	r8,r8[0x0]
8000601e:	58 08       	cp.w	r8,0
80006020:	c0 80       	breq	80006030 <xcmp_exec_func+0x44>
			{
				exec->xcmp_rx_req(xcmp);
80006022:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006026:	70 08       	ld.w	r8,r8[0x0]
80006028:	ee fc ff f8 	ld.w	r12,r7[-8]
8000602c:	5d 18       	icall	r8
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
			}
			break;
8000602e:	c1 d8       	rjmp	80006068 <xcmp_exec_func+0x7c>
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
80006030:	f0 1f 00 10 	mcall	80006070 <xcmp_exec_func+0x84>
			}
			break;
80006034:	c1 a8       	rjmp	80006068 <xcmp_exec_func+0x7c>
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80006036:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000603a:	70 18       	ld.w	r8,r8[0x4]
8000603c:	58 08       	cp.w	r8,0
8000603e:	c1 40       	breq	80006066 <xcmp_exec_func+0x7a>
			{
				exec->xcmp_rx_reply(xcmp);
80006040:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006044:	70 18       	ld.w	r8,r8[0x4]
80006046:	ee fc ff f8 	ld.w	r12,r7[-8]
8000604a:	5d 18       	icall	r8
			}
			break;
8000604c:	c0 e8       	rjmp	80006068 <xcmp_exec_func+0x7c>
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000604e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006052:	70 28       	ld.w	r8,r8[0x8]
80006054:	58 08       	cp.w	r8,0
80006056:	c0 90       	breq	80006068 <xcmp_exec_func+0x7c>
			{
				exec->xcmp_rx_brdcst(xcmp);
80006058:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000605c:	70 28       	ld.w	r8,r8[0x8]
8000605e:	ee fc ff f8 	ld.w	r12,r7[-8]
80006062:	5d 18       	icall	r8
80006064:	c0 28       	rjmp	80006068 <xcmp_exec_func+0x7c>
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
			{
				exec->xcmp_rx_reply(xcmp);
			}
			break;
80006066:	d7 03       	nop
			break;
			
		default:
			break;
	}
}
80006068:	2f ed       	sub	sp,-8
8000606a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000606e:	00 00       	add	r0,r0
80006070:	80 00       	ld.sh	r0,r0[0x0]
80006072:	62 58       	ld.w	r8,r1[0x14]

80006074 <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80006074:	eb cd 40 80 	pushm	r7,lr
80006078:	1a 97       	mov	r7,sp
8000607a:	fa cd 00 d4 	sub	sp,sp,212
8000607e:	ef 4c ff 2c 	st.w	r7[-212],r12
80006082:	c0 28       	rjmp	80006086 <xcmp_rx_process+0x12>
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
80006084:	d7 03       	nop
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80006086:	4c 88       	lddpc	r8,800061a4 <xcmp_rx_process+0x130>
80006088:	70 08       	ld.w	r8,r8[0x0]
8000608a:	ee cb 00 d0 	sub	r11,r7,208
8000608e:	30 09       	mov	r9,0
80006090:	31 4a       	mov	r10,20
80006092:	10 9c       	mov	r12,r8
80006094:	f0 1f 00 45 	mcall	800061a8 <xcmp_rx_process+0x134>
80006098:	18 98       	mov	r8,r12
8000609a:	58 18       	cp.w	r8,1
8000609c:	cf 41       	brne	80006084 <xcmp_rx_process+0x10>
		{									
			if(NULL == ptr)
8000609e:	ee f8 ff 30 	ld.w	r8,r7[-208]
800060a2:	58 08       	cp.w	r8,0
800060a4:	c0 31       	brne	800060aa <xcmp_rx_process+0x36>
			{
				continue;
800060a6:	d7 03       	nop
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
800060a8:	ce fb       	rjmp	80006086 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800060aa:	ee f8 ff 30 	ld.w	r8,r7[-208]
800060ae:	90 08       	ld.sh	r8,r8[0x0]
800060b0:	5c 78       	castu.h	r8
800060b2:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800060b6:	59 c8       	cp.w	r8,28
800060b8:	c2 70       	breq	80006106 <xcmp_rx_process+0x92>
800060ba:	e0 89 00 07 	brgt	800060c8 <xcmp_rx_process+0x54>
800060be:	58 e8       	cp.w	r8,14
800060c0:	c0 e0       	breq	800060dc <xcmp_rx_process+0x68>
800060c2:	58 f8       	cp.w	r8,15
800060c4:	c1 30       	breq	800060ea <xcmp_rx_process+0x76>
800060c6:	c3 58       	rjmp	80006130 <xcmp_rx_process+0xbc>
800060c8:	e0 48 01 09 	cp.w	r8,265
800060cc:	c2 40       	breq	80006114 <xcmp_rx_process+0xa0>
800060ce:	e0 48 01 0a 	cp.w	r8,266
800060d2:	c2 80       	breq	80006122 <xcmp_rx_process+0xae>
800060d4:	e0 48 00 2c 	cp.w	r8,44
800060d8:	c1 00       	breq	800060f8 <xcmp_rx_process+0x84>
800060da:	c2 b8       	rjmp	80006130 <xcmp_rx_process+0xbc>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800060dc:	ee f8 ff 30 	ld.w	r8,r7[-208]
800060e0:	10 9b       	mov	r11,r8
800060e2:	4b 3c       	lddpc	r12,800061ac <xcmp_rx_process+0x138>
800060e4:	f0 1f 00 33 	mcall	800061b0 <xcmp_rx_process+0x13c>
					break;
800060e8:	c5 58       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800060ea:	ee f8 ff 30 	ld.w	r8,r7[-208]
800060ee:	10 9b       	mov	r11,r8
800060f0:	4b 1c       	lddpc	r12,800061b4 <xcmp_rx_process+0x140>
800060f2:	f0 1f 00 30 	mcall	800061b0 <xcmp_rx_process+0x13c>
					break;
800060f6:	c4 e8       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800060f8:	ee f8 ff 30 	ld.w	r8,r7[-208]
800060fc:	10 9b       	mov	r11,r8
800060fe:	4a fc       	lddpc	r12,800061b8 <xcmp_rx_process+0x144>
80006100:	f0 1f 00 2c 	mcall	800061b0 <xcmp_rx_process+0x13c>
					break;
80006104:	c4 78       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80006106:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000610a:	10 9b       	mov	r11,r8
8000610c:	4a cc       	lddpc	r12,800061bc <xcmp_rx_process+0x148>
8000610e:	f0 1f 00 29 	mcall	800061b0 <xcmp_rx_process+0x13c>
						, ptr);
					break;
80006112:	c4 08       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80006114:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006118:	10 9b       	mov	r11,r8
8000611a:	4a ac       	lddpc	r12,800061c0 <xcmp_rx_process+0x14c>
8000611c:	f0 1f 00 25 	mcall	800061b0 <xcmp_rx_process+0x13c>
					break;
80006120:	c3 98       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80006122:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006126:	10 9b       	mov	r11,r8
80006128:	4a 7c       	lddpc	r12,800061c4 <xcmp_rx_process+0x150>
8000612a:	f0 1f 00 22 	mcall	800061b0 <xcmp_rx_process+0x13c>
					break;
8000612e:	c3 28       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006130:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006134:	90 08       	ld.sh	r8,r8[0x0]
80006136:	5c 78       	castu.h	r8
80006138:	e2 18 04 00 	andl	r8,0x400,COH
8000613c:	c0 b0       	breq	80006152 <xcmp_rx_process+0xde>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
8000613e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006142:	90 08       	ld.sh	r8,r8[0x0]
80006144:	5c 78       	castu.h	r8
80006146:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000614a:	e0 48 00 68 	cp.w	r8,104
8000614e:	e0 8a 00 0c 	brle	80006166 <xcmp_rx_process+0xf2>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80006152:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006156:	90 08       	ld.sh	r8,r8[0x0]
80006158:	5c 78       	castu.h	r8
8000615a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000615e:	c1 91       	brne	80006190 <xcmp_rx_process+0x11c>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80006160:	f0 1f 00 1a 	mcall	800061c8 <xcmp_rx_process+0x154>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006164:	c1 78       	rjmp	80006192 <xcmp_rx_process+0x11e>
							xcmp_opcode_not_supported();
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80006166:	ee fa ff 30 	ld.w	r10,r7[-208]
8000616a:	49 98       	lddpc	r8,800061cc <xcmp_rx_process+0x158>
8000616c:	70 0b       	ld.w	r11,r8[0x0]
8000616e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006172:	90 08       	ld.sh	r8,r8[0x0]
80006174:	5c 78       	castu.h	r8
80006176:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000617a:	12 98       	mov	r8,r9
8000617c:	a1 78       	lsl	r8,0x1
8000617e:	12 08       	add	r8,r9
80006180:	a3 68       	lsl	r8,0x2
80006182:	f6 08 00 08 	add	r8,r11,r8
80006186:	14 9b       	mov	r11,r10
80006188:	10 9c       	mov	r12,r8
8000618a:	f0 1f 00 0a 	mcall	800061b0 <xcmp_rx_process+0x13c>
8000618e:	c0 28       	rjmp	80006192 <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006190:	d7 03       	nop
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80006192:	ee f9 ff 30 	ld.w	r9,r7[-208]
80006196:	48 f8       	lddpc	r8,800061d0 <xcmp_rx_process+0x15c>
80006198:	70 08       	ld.w	r8,r8[0x0]
8000619a:	12 9b       	mov	r11,r9
8000619c:	10 9c       	mov	r12,r8
8000619e:	f0 1f 00 0e 	mcall	800061d4 <xcmp_rx_process+0x160>
		}

	}
800061a2:	c7 2b       	rjmp	80006086 <xcmp_rx_process+0x12>
800061a4:	00 00       	add	r0,r0
800061a6:	0a f8       	st.b	--r5,r8
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	88 64       	ld.sh	r4,r4[0xc]
800061ac:	00 00       	add	r0,r0
800061ae:	0a fc       	st.b	--r5,r12
800061b0:	80 00       	ld.sh	r0,r0[0x0]
800061b2:	5f ec       	srqs	r12
800061b4:	00 00       	add	r0,r0
800061b6:	0b 08       	ld.w	r8,r5++
800061b8:	00 00       	add	r0,r0
800061ba:	0b 14       	ld.sh	r4,r5++
800061bc:	00 00       	add	r0,r0
800061be:	0b 20       	ld.uh	r0,r5++
800061c0:	00 00       	add	r0,r0
800061c2:	0b 2c       	ld.uh	r12,r5++
800061c4:	00 00       	add	r0,r0
800061c6:	0b 38       	ld.ub	r8,r5++
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	62 58       	ld.w	r8,r1[0x14]
800061cc:	00 00       	add	r0,r0
800061ce:	41 08       	lddsp	r8,sp[0x40]
800061d0:	00 00       	add	r0,r0
800061d2:	0a 7c       	tst	r12,r5
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	5b d8       	cp.w	r8,-3

800061d8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800061d8:	eb cd 40 80 	pushm	r7,lr
800061dc:	1a 97       	mov	r7,sp
	/*initialize the xnl*/
	xnl_init();
800061de:	f0 1f 00 0f 	mcall	80006218 <xcmp_init+0x40>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800061e2:	48 fc       	lddpc	r12,8000621c <xcmp_init+0x44>
800061e4:	f0 1f 00 0f 	mcall	80006220 <xcmp_init+0x48>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800061e8:	30 4b       	mov	r11,4
800061ea:	31 4c       	mov	r12,20
800061ec:	f0 1f 00 0e 	mcall	80006224 <xcmp_init+0x4c>
800061f0:	18 99       	mov	r9,r12
800061f2:	48 e8       	lddpc	r8,80006228 <xcmp_init+0x50>
800061f4:	91 09       	st.w	r8[0x0],r9
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800061f6:	48 eb       	lddpc	r11,8000622c <xcmp_init+0x54>
800061f8:	30 08       	mov	r8,0
800061fa:	1a d8       	st.w	--sp,r8
800061fc:	30 08       	mov	r8,0
800061fe:	1a d8       	st.w	--sp,r8
80006200:	30 08       	mov	r8,0
80006202:	1a d8       	st.w	--sp,r8
80006204:	30 38       	mov	r8,3
80006206:	30 09       	mov	r9,0
80006208:	e0 6a 01 80 	mov	r10,384
8000620c:	48 9c       	lddpc	r12,80006230 <xcmp_init+0x58>
8000620e:	f0 1f 00 0a 	mcall	80006234 <xcmp_init+0x5c>
80006212:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80006214:	e3 cd 80 80 	ldm	sp++,r7,pc
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	6c 64       	ld.w	r4,r6[0x18]
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	5f 8c       	srls	r12
80006220:	80 00       	ld.sh	r0,r0[0x0]
80006222:	69 58       	ld.w	r8,r4[0x54]
80006224:	80 00       	ld.sh	r0,r0[0x0]
80006226:	85 40       	st.w	r2[0x10],r0
80006228:	00 00       	add	r0,r0
8000622a:	0a f8       	st.b	--r5,r8
8000622c:	80 00       	ld.sh	r0,r0[0x0]
8000622e:	5e f8       	retal	r8
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	60 74       	ld.w	r4,r0[0x1c]
80006234:	80 00       	ld.sh	r0,r0[0x0]
80006236:	8d b0       	st.w	r6[0x2c],r0

80006238 <xcmp_register_app_list>:
Description: register the app list
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
80006238:	eb cd 40 80 	pushm	r7,lr
8000623c:	1a 97       	mov	r7,sp
8000623e:	20 1d       	sub	sp,4
80006240:	ef 4c ff fc 	st.w	r7[-4],r12
	app_list = (app_exec_t *)list;
80006244:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006248:	48 38       	lddpc	r8,80006254 <xcmp_register_app_list+0x1c>
8000624a:	91 09       	st.w	r8[0x0],r9
}
8000624c:	2f fd       	sub	sp,-4
8000624e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006252:	00 00       	add	r0,r0
80006254:	00 00       	add	r0,r0
80006256:	41 08       	lddsp	r8,sp[0x40]

80006258 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80006258:	eb cd 40 80 	pushm	r7,lr
8000625c:	1a 97       	mov	r7,sp
8000625e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80006262:	fe 78 80 00 	mov	r8,-32768
80006266:	ef 58 ff 36 	st.h	r7[-202],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000626a:	30 38       	mov	r8,3
8000626c:	ef 68 ff 38 	st.b	r7[-200],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80006270:	ee c8 00 ca 	sub	r8,r7,202
80006274:	30 1b       	mov	r11,1
80006276:	10 9c       	mov	r12,r8
80006278:	f0 1f 00 03 	mcall	80006284 <xcmp_opcode_not_supported+0x2c>
}
8000627c:	2c dd       	sub	sp,-204
8000627e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006282:	00 00       	add	r0,r0
80006284:	80 00       	ld.sh	r0,r0[0x0]
80006286:	5f 00       	sreq	r0

80006288 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80006288:	eb cd 40 80 	pushm	r7,lr
8000628c:	1a 97       	mov	r7,sp
8000628e:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80006292:	fe 78 b4 00 	mov	r8,-19456
80006296:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000629a:	ee c8 00 ce 	sub	r8,r7,206
8000629e:	2f e8       	sub	r8,-2
800062a0:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
800062a4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062a8:	30 88       	mov	r8,8
800062aa:	b2 88       	st.b	r9[0x0],r8
	ptr->XCMPVersion[1] = 0x01;
800062ac:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062b0:	30 18       	mov	r8,1
800062b2:	b2 98       	st.b	r9[0x1],r8
	ptr->XCMPVersion[2] = 0x00;
800062b4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062b8:	30 08       	mov	r8,0
800062ba:	b2 a8       	st.b	r9[0x2],r8
	ptr->XCMPVersion[3] = 0x05;
800062bc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062c0:	30 58       	mov	r8,5
800062c2:	b2 b8       	st.b	r9[0x3],r8
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800062c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062c8:	30 08       	mov	r8,0
800062ca:	b2 c8       	st.b	r9[0x4],r8
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800062cc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062d0:	30 78       	mov	r8,7
800062d2:	b2 d8       	st.b	r9[0x5],r8
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800062d4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062d8:	30 08       	mov	r8,0
800062da:	b2 e8       	st.b	r9[0x6],r8
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800062dc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062e0:	30 08       	mov	r8,0
800062e2:	b2 f8       	st.b	r9[0x7],r8
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800062e4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062e8:	30 08       	mov	r8,0
800062ea:	f3 68 00 08 	st.b	r9[8],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800062ee:	ee c8 00 ce 	sub	r8,r7,206
800062f2:	30 9b       	mov	r11,9
800062f4:	10 9c       	mov	r12,r8
800062f6:	f0 1f 00 03 	mcall	80006300 <xcmp_DeviceInitializationStatus_request+0x78>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800062fa:	2c cd       	sub	sp,-208
800062fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	5f 00       	sreq	r0

80006304 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80006304:	eb cd 40 80 	pushm	r7,lr
80006308:	1a 97       	mov	r7,sp
8000630a:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000630e:	e0 68 04 09 	mov	r8,1033
80006312:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80006316:	ee c8 00 ce 	sub	r8,r7,206
8000631a:	2f e8       	sub	r8,-2
8000631c:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80006320:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006324:	30 18       	mov	r8,1
80006326:	b2 88       	st.b	r9[0x0],r8
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80006328:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000632c:	30 08       	mov	r8,0
8000632e:	b2 98       	st.b	r9[0x1],r8
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80006330:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006334:	30 c8       	mov	r8,12
80006336:	b2 a8       	st.b	r9[0x2],r8
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80006338:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000633c:	30 08       	mov	r8,0
8000633e:	b2 b8       	st.b	r9[0x3],r8
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80006340:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006344:	2f c8       	sub	r8,-4
80006346:	30 8a       	mov	r10,8
80006348:	30 0b       	mov	r11,0
8000634a:	10 9c       	mov	r12,r8
8000634c:	f0 1f 00 06 	mcall	80006364 <xcmp_IdleTestTone+0x60>
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80006350:	ee c8 00 ce 	sub	r8,r7,206
80006354:	30 cb       	mov	r11,12
80006356:	10 9c       	mov	r12,r8
80006358:	f0 1f 00 04 	mcall	80006368 <xcmp_IdleTestTone+0x64>
}
8000635c:	2c cd       	sub	sp,-208
8000635e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006362:	00 00       	add	r0,r0
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	ad be       	sbr	lr,0xd
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	5f 00       	sreq	r0

8000636c <xcmp_data_session>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
{
8000636c:	eb cd 40 80 	pushm	r7,lr
80006370:	1a 97       	mov	r7,sp
80006372:	fa cd 00 d0 	sub	sp,sp,208
	//U8 *DMR_Raw_Data= &DataPayload[0];
	U8 i =0;
80006376:	30 08       	mov	r8,0
80006378:	ef 68 ff fb 	st.b	r7[-5],r8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_DATA_REQUEST;
8000637c:	e0 68 04 1d 	mov	r8,1053
80006380:	ef 58 ff 30 	st.h	r7[-208],r8
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80006384:	ee c8 00 d0 	sub	r8,r7,208
80006388:	2f e8       	sub	r8,-2
8000638a:	ef 48 ff fc 	st.w	r7[-4],r8
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//ID:2
	//
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
	
	ptr->Function = Single_Data_Uint;//0x01
8000638e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006392:	30 18       	mov	r8,1
80006394:	b2 88       	st.b	r9[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = DMR_CSBK_Data;//0x70
80006396:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000639a:	37 08       	mov	r8,112
8000639c:	b2 98       	st.b	r9[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_Mototrbo_Address;//0x01
8000639e:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063a2:	30 18       	mov	r8,1
800063a4:	b2 a8       	st.b	r9[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_Mototrbo_Address_Size;//0x03
800063a6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063aa:	30 38       	mov	r8,3
800063ac:	b2 b8       	st.b	r9[0x3],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x00;
800063ae:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063b2:	30 08       	mov	r8,0
800063b4:	b2 c8       	st.b	r9[0x4],r8
	ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;
800063b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063ba:	30 08       	mov	r8,0
800063bc:	b2 d8       	st.b	r9[0x5],r8
	ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x02;//ID:2
800063be:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063c2:	30 28       	mov	r8,2
800063c4:	b2 e8       	st.b	r9[0x6],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
800063c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063ca:	34 08       	mov	r8,64
800063cc:	b2 f8       	st.b	r9[0x7],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
800063ce:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063d2:	36 18       	mov	r8,97
800063d4:	f3 68 00 08 	st.b	r9[8],r8
	    ////
    ////}
	//
	
	//
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800063d8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063dc:	30 08       	mov	r8,0
800063de:	f3 68 00 09 	st.b	r9[9],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//
800063e2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063e6:	30 08       	mov	r8,0
800063e8:	f3 68 00 0a 	st.b	r9[10],r8
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//
800063ec:	ee f9 ff fc 	ld.w	r9,r7[-4]
800063f0:	31 48       	mov	r8,20
800063f2:	f3 68 00 0b 	st.b	r9[11],r8
	
	for (i=0; i< sizeof(DataPayload) ; i++)
800063f6:	30 08       	mov	r8,0
800063f8:	ef 68 ff fb 	st.b	r7[-5],r8
800063fc:	c1 38       	rjmp	80006422 <xcmp_data_session+0xb6>
	{
	
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//
800063fe:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006402:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006406:	49 0a       	lddpc	r10,80006444 <xcmp_data_session+0xd8>
80006408:	f4 08 07 08 	ld.ub	r8,r10[r8]
8000640c:	ee fa ff fc 	ld.w	r10,r7[-4]
80006410:	f4 09 00 09 	add	r9,r10,r9
80006414:	f3 68 00 0c 	st.b	r9[12],r8
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//
	
	for (i=0; i< sizeof(DataPayload) ; i++)
80006418:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000641c:	2f f8       	sub	r8,-1
8000641e:	ef 68 ff fb 	st.b	r7[-5],r8
80006422:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006426:	31 38       	mov	r8,19
80006428:	f0 09 18 00 	cp.b	r9,r8
8000642c:	fe 98 ff e9 	brls	800063fe <xcmp_data_session+0x92>
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//
		
	}
	
	/*send xcmp frame*///
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t));
80006430:	ee c8 00 d0 	sub	r8,r7,208
80006434:	32 0b       	mov	r11,32
80006436:	10 9c       	mov	r12,r8
80006438:	f0 1f 00 04 	mcall	80006448 <xcmp_data_session+0xdc>
}
8000643c:	2c cd       	sub	sp,-208
8000643e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006442:	00 00       	add	r0,r0
80006444:	00 00       	add	r0,r0
80006446:	04 fc       	st.b	--r2,r12
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	5f 00       	sreq	r0
8000644c:	63 6f       	ld.w	pc,r1[0x58]
8000644e:	6e 6e       	ld.w	lr,r7[0x18]
80006450:	65 63       	ld.w	r3,r2[0x58]
80006452:	74 65       	ld.w	r5,r10[0x18]
80006454:	64 20       	ld.w	r0,r2[0x8]
80006456:	66 69       	ld.w	r9,r3[0x18]
80006458:	6e 69       	ld.w	r9,r7[0x18]
8000645a:	73 68       	ld.w	r8,r9[0x58]
8000645c:	00 00       	add	r0,r0
8000645e:	00 00       	add	r0,r0
80006460:	58 4e       	cp.w	lr,4
80006462:	4c 5f       	lddpc	pc,80006574 <check_sum+0x58>
80006464:	52 58       	stdsp	sp[0x94],r8
80006466:	00 00       	add	r0,r0
80006468:	58 4e       	cp.w	lr,4
8000646a:	4c 5f       	lddpc	pc,8000657c <check_sum+0x60>
8000646c:	54 58       	stdsp	sp[0x114],r8
	...

80006470 <encipher>:
Calls:   
Called By: xnl_device_auth_reply_func
Output: U32 *const w
*/
static void encipher(U32 *const v, U32 *const w, const U32 *const k)
{
80006470:	eb cd 40 ef 	pushm	r0-r3,r5-r7,lr
80006474:	1a 97       	mov	r7,sp
80006476:	20 4d       	sub	sp,16
80006478:	ef 4c ff fc 	st.w	r7[-4],r12
8000647c:	ef 4b ff f8 	st.w	r7[-8],r11
80006480:	ef 4a ff f4 	st.w	r7[-12],r10
	register U32 y=v[0], z=v[1], sum=0;
80006484:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006488:	70 06       	ld.w	r6,r8[0x0]
8000648a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000648e:	2f c8       	sub	r8,-4
80006490:	70 0e       	ld.w	lr,r8[0x0]
80006492:	30 05       	mov	r5,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
80006494:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006498:	70 08       	ld.w	r8,r8[0x0]
8000649a:	ef 48 ff f0 	st.w	r7[-16],r8
8000649e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800064a2:	2f c8       	sub	r8,-4
800064a4:	70 00       	ld.w	r0,r8[0x0]
800064a6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800064aa:	2f 88       	sub	r8,-8
800064ac:	70 01       	ld.w	r1,r8[0x0]
800064ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800064b2:	2f 48       	sub	r8,-12
800064b4:	70 02       	ld.w	r2,r8[0x0]
	register U32 n=32;
800064b6:	32 03       	mov	r3,32

	while(n-->0)
800064b8:	c2 08       	rjmp	800064f8 <encipher+0x88>
	{
		sum += authDelta;		
800064ba:	49 88       	lddpc	r8,80006518 <encipher+0xa8>
800064bc:	70 08       	ld.w	r8,r8[0x0]
800064be:	10 05       	add	r5,r8
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800064c0:	fc 08 15 04 	lsl	r8,lr,0x4
800064c4:	ee fa ff f0 	ld.w	r10,r7[-16]
800064c8:	f0 0a 00 09 	add	r9,r8,r10
800064cc:	fc 05 00 08 	add	r8,lr,r5
800064d0:	10 59       	eor	r9,r8
800064d2:	fc 08 16 05 	lsr	r8,lr,0x5
800064d6:	00 08       	add	r8,r0
800064d8:	f3 e8 20 08 	eor	r8,r9,r8
800064dc:	10 06       	add	r6,r8
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800064de:	ec 08 15 04 	lsl	r8,r6,0x4
800064e2:	f0 01 00 09 	add	r9,r8,r1
800064e6:	ec 05 00 08 	add	r8,r6,r5
800064ea:	10 59       	eor	r9,r8
800064ec:	ec 08 16 05 	lsr	r8,r6,0x5
800064f0:	04 08       	add	r8,r2
800064f2:	f3 e8 20 08 	eor	r8,r9,r8
800064f6:	10 0e       	add	lr,r8
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800064f8:	58 03       	cp.w	r3,0
800064fa:	5f 18       	srne	r8
800064fc:	5c 58       	castu.b	r8
800064fe:	20 13       	sub	r3,1
80006500:	58 08       	cp.w	r8,0
80006502:	cd c1       	brne	800064ba <encipher+0x4a>
		sum += authDelta;		
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
	}

	w[0]=y; w[1]=z;
80006504:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006508:	91 06       	st.w	r8[0x0],r6
8000650a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000650e:	2f c8       	sub	r8,-4
80006510:	91 0e       	st.w	r8[0x0],lr
}
80006512:	2f cd       	sub	sp,-16
80006514:	e3 cd 80 ef 	ldm	sp++,r0-r3,r5-r7,pc
80006518:	80 01       	ld.sh	r1,r0[0x0]
8000651a:	04 b0       	st.h	r2++,r0

8000651c <check_sum>:
Calls:   
Called By: xnl_tx
Return:U16
*/
static U16 check_sum (xnl_fragment_t * xnl)
{
8000651c:	eb cd 40 80 	pushm	r7,lr
80006520:	1a 97       	mov	r7,sp
80006522:	20 4d       	sub	sp,16
80006524:	ef 4c ff f0 	st.w	r7[-16],r12
	*/	
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
80006528:	30 08       	mov	r8,0
8000652a:	ef 58 ff f6 	st.h	r7[-10],r8
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000652e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006532:	90 08       	ld.sh	r8,r8[0x0]
80006534:	5c 78       	castu.h	r8
80006536:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000653a:	20 28       	sub	r8,2
8000653c:	ef 48 ff fc 	st.w	r7[-4],r8
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80006540:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006544:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80006548:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000654c:	f2 08 00 08 	add	r8,r9,r8
80006550:	a1 58       	asr	r8,0x1
80006552:	ef 48 ff fc 	st.w	r7[-4],r8
	indextohWord = 2;
80006556:	30 28       	mov	r8,2
80006558:	ef 48 ff f8 	st.w	r7[-8],r8
	while (hWordswithinFrag > 0)
8000655c:	c1 98       	rjmp	8000658e <check_sum+0x72>
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000655e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80006562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006566:	a1 78       	lsl	r8,0x1
80006568:	f2 08 00 08 	add	r8,r9,r8
8000656c:	90 08       	ld.sh	r8,r8[0x0]
8000656e:	ef 09 ff f6 	ld.sh	r9,r7[-10]
80006572:	f2 08 00 08 	add	r8,r9,r8
80006576:	ef 58 ff f6 	st.h	r7[-10],r8
		indextohWord     += 1;
8000657a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000657e:	2f f8       	sub	r8,-1
80006580:	ef 48 ff f8 	st.w	r7[-8],r8
		hWordswithinFrag -= 1;
80006584:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006588:	20 18       	sub	r8,1
8000658a:	ef 48 ff fc 	st.w	r7[-4],r8
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000658e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006592:	58 08       	cp.w	r8,0
80006594:	fe 99 ff e5 	brgt	8000655e <check_sum+0x42>
		sumScratch += *((U16*)xnl + indextohWord);
		indextohWord     += 1;
		hWordswithinFrag -= 1;
	}
	
	return -sumScratch;
80006598:	ef 08 ff f6 	ld.sh	r8,r7[-10]
8000659c:	5c 38       	neg	r8
8000659e:	5c 88       	casts.h	r8
}
800065a0:	10 9c       	mov	r12,r8
800065a2:	2f cd       	sub	sp,-16
800065a4:	e3 cd 80 80 	ldm	sp++,r7,pc

800065a8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
static void xnl_send_device_master_query(void)
{
800065a8:	eb cd 40 80 	pushm	r7,lr
800065ac:	1a 97       	mov	r7,sp
800065ae:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800065b2:	e0 68 40 0e 	mov	r8,16398
800065b6:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800065ba:	3f f8       	mov	r8,-1
800065bc:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800065c0:	30 38       	mov	r8,3
800065c2:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800065c6:	30 08       	mov	r8,0
800065c8:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800065cc:	30 08       	mov	r8,0
800065ce:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800065d2:	30 08       	mov	r8,0
800065d4:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800065d8:	30 08       	mov	r8,0
800065da:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800065de:	30 08       	mov	r8,0
800065e0:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800065e4:	ee c8 01 00 	sub	r8,r7,256
800065e8:	10 9c       	mov	r12,r8
800065ea:	f0 1f 00 03 	mcall	800065f4 <xnl_send_device_master_query+0x4c>
}
800065ee:	2c 0d       	sub	sp,-256
800065f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	69 78       	ld.w	r8,r4[0x5c]

800065f8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800065f8:	eb cd 40 80 	pushm	r7,lr
800065fc:	1a 97       	mov	r7,sp
800065fe:	fa cd 01 04 	sub	sp,sp,260
80006602:	ef 4c fe fc 	st.w	r7[-260],r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80006606:	49 c8       	lddpc	r8,80006674 <xnl_master_status_brdcst_func+0x7c>
80006608:	11 88       	ld.ub	r8,r8[0x0]
8000660a:	5c 58       	castu.b	r8
8000660c:	c2 f1       	brne	8000666a <xnl_master_status_brdcst_func+0x72>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000660e:	49 b8       	lddpc	r8,80006678 <xnl_master_status_brdcst_func+0x80>
80006610:	70 08       	ld.w	r8,r8[0x0]
80006612:	30 09       	mov	r9,0
80006614:	30 0a       	mov	r10,0
80006616:	30 0b       	mov	r11,0
80006618:	10 9c       	mov	r12,r8
8000661a:	f0 1f 00 19 	mcall	8000667c <xnl_master_status_brdcst_func+0x84>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000661e:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006622:	90 58       	ld.sh	r8,r8[0xa]
80006624:	49 49       	lddpc	r9,80006674 <xnl_master_status_brdcst_func+0x7c>
80006626:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80006628:	e0 68 40 0e 	mov	r8,16398
8000662c:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80006630:	3f f8       	mov	r8,-1
80006632:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80006636:	30 48       	mov	r8,4
80006638:	ef 58 ff 04 	st.h	r7[-252],r8
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000663c:	3f f8       	mov	r8,-1
8000663e:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80006642:	48 d8       	lddpc	r8,80006674 <xnl_master_status_brdcst_func+0x7c>
80006644:	90 18       	ld.sh	r8,r8[0x2]
80006646:	5c 88       	casts.h	r8
80006648:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000664c:	3f f8       	mov	r8,-1
8000664e:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006652:	3f f8       	mov	r8,-1
80006654:	ef 58 ff 0c 	st.h	r7[-244],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80006658:	30 08       	mov	r8,0
8000665a:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000665e:	ee c8 01 00 	sub	r8,r7,256
80006662:	10 9c       	mov	r12,r8
80006664:	f0 1f 00 07 	mcall	80006680 <xnl_master_status_brdcst_func+0x88>
80006668:	c0 28       	rjmp	8000666c <xnl_master_status_brdcst_func+0x74>
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
	{
		return;	
8000666a:	d7 03       	nop
		
	xnl_frame.xnl_header.payload_length = 0;
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
}
8000666c:	2b fd       	sub	sp,-260
8000666e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006672:	00 00       	add	r0,r0
80006674:	00 00       	add	r0,r0
80006676:	0b 44       	ld.w	r4,--r5
80006678:	00 00       	add	r0,r0
8000667a:	0b 58       	ld.sh	r8,--r5
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	86 58       	ld.sh	r8,r3[0xa]
80006680:	80 00       	ld.sh	r0,r0[0x0]
80006682:	69 78       	ld.w	r8,r4[0x5c]

80006684 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80006684:	eb cd 40 80 	pushm	r7,lr
80006688:	1a 97       	mov	r7,sp
8000668a:	fa cd 01 14 	sub	sp,sp,276
8000668e:	ef 4c fe ec 	st.w	r7[-276],r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80006692:	4c 78       	lddpc	r8,800067ac <xnl_device_auth_reply_func+0x128>
80006694:	11 88       	ld.ub	r8,r8[0x0]
80006696:	5c 58       	castu.b	r8
80006698:	e0 81 00 86 	brne	800067a4 <xnl_device_auth_reply_func+0x120>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000669c:	4c 58       	lddpc	r8,800067b0 <xnl_device_auth_reply_func+0x12c>
8000669e:	70 08       	ld.w	r8,r8[0x0]
800066a0:	30 09       	mov	r9,0
800066a2:	30 0a       	mov	r10,0
800066a4:	30 0b       	mov	r11,0
800066a6:	10 9c       	mov	r12,r8
800066a8:	f0 1f 00 43 	mcall	800067b4 <xnl_device_auth_reply_func+0x130>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800066ac:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066b0:	f1 08 00 10 	ld.sh	r8,r8[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800066b4:	4b e9       	lddpc	r9,800067ac <xnl_device_auth_reply_func+0x128>
800066b6:	b2 28       	st.h	r9[0x4],r8
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066b8:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066bc:	f1 38 00 12 	ld.ub	r8,r8[18]
	  .unencrypted_authentication_value[0])<<24	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066c0:	f0 09 15 18 	lsl	r9,r8,0x18
800066c4:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066c8:	f1 38 00 13 	ld.ub	r8,r8[19]
	  .unencrypted_authentication_value[1])<<16	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066cc:	b1 68       	lsl	r8,0x10
800066ce:	10 49       	or	r9,r8
800066d0:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066d4:	f1 38 00 14 	ld.ub	r8,r8[20]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066d8:	a9 68       	lsl	r8,0x8
800066da:	10 49       	or	r9,r8
800066dc:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066e0:	f1 38 00 15 	ld.ub	r8,r8[21]
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066e4:	f3 e8 10 08 	or	r8,r9,r8
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800066e8:	ef 48 ff f8 	st.w	r7[-8],r8
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066ec:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066f0:	f1 38 00 16 	ld.ub	r8,r8[22]
	  .unencrypted_authentication_value[4])<<24
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
800066f4:	f0 09 15 18 	lsl	r9,r8,0x18
800066f8:	ee f8 fe ec 	ld.w	r8,r7[-276]
800066fc:	f1 38 00 17 	ld.ub	r8,r8[23]
	   .unencrypted_authentication_value[5])<<16
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006700:	b1 68       	lsl	r8,0x10
80006702:	10 49       	or	r9,r8
80006704:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006708:	f1 38 00 18 	ld.ub	r8,r8[24]
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
8000670c:	a9 68       	lsl	r8,0x8
8000670e:	10 49       	or	r9,r8
80006710:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006714:	f1 38 00 19 	ld.ub	r8,r8[25]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006718:	f3 e8 10 08 	or	r8,r9,r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000671c:	ef 48 ff fc 	st.w	r7[-4],r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[7]);
	
	encipher(&v_vector[0], &w_vector[0], &authKey[0]);
80006720:	ee c9 00 10 	sub	r9,r7,16
80006724:	ee c8 00 08 	sub	r8,r7,8
80006728:	4a 4a       	lddpc	r10,800067b8 <xnl_device_auth_reply_func+0x134>
8000672a:	12 9b       	mov	r11,r9
8000672c:	10 9c       	mov	r12,r8
8000672e:	f0 1f 00 24 	mcall	800067bc <xnl_device_auth_reply_func+0x138>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80006732:	e0 68 40 1a 	mov	r8,16410
80006736:	ef 58 fe f0 	st.h	r7[-272],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000673a:	3f f8       	mov	r8,-1
8000673c:	ef 58 fe f2 	st.h	r7[-270],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80006740:	30 68       	mov	r8,6
80006742:	ef 58 fe f4 	st.h	r7[-268],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80006746:	3f f8       	mov	r8,-1
80006748:	ef 58 fe f6 	st.h	r7[-266],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000674c:	49 88       	lddpc	r8,800067ac <xnl_device_auth_reply_func+0x128>
8000674e:	90 18       	ld.sh	r8,r8[0x2]
80006750:	5c 88       	casts.h	r8
80006752:	ef 58 fe f8 	st.h	r7[-264],r8
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80006756:	49 68       	lddpc	r8,800067ac <xnl_device_auth_reply_func+0x128>
80006758:	90 28       	ld.sh	r8,r8[0x4]
8000675a:	5c 88       	casts.h	r8
8000675c:	ef 58 fe fa 	st.h	r7[-262],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006760:	3f f8       	mov	r8,-1
80006762:	ef 58 fe fc 	st.h	r7[-260],r8
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80006766:	30 c8       	mov	r8,12
80006768:	ef 58 fe fe 	st.h	r7[-258],r8
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000676c:	30 08       	mov	r8,0
8000676e:	ef 58 ff 00 	st.h	r7[-256],r8
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80006772:	30 78       	mov	r8,7
80006774:	ef 68 ff 02 	st.b	r7[-254],r8
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80006778:	30 28       	mov	r8,2
8000677a:	ef 68 ff 03 	st.b	r7[-253],r8
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000677e:	ee c8 01 10 	sub	r8,r7,272
80006782:	2e c8       	sub	r8,-20
	                         .encrypted_authentication_value[0])) = w_vector[0];
80006784:	ee f9 ff f0 	ld.w	r9,r7[-16]
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80006788:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000678a:	ee c8 01 10 	sub	r8,r7,272
8000678e:	2e c8       	sub	r8,-20
80006790:	2f c8       	sub	r8,-4
	                         .encrypted_authentication_value[4])) = w_vector[1];
80006792:	ee f9 ff f4 	ld.w	r9,r7[-12]
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80006796:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80006798:	ee c8 01 10 	sub	r8,r7,272
8000679c:	10 9c       	mov	r12,r8
8000679e:	f0 1f 00 09 	mcall	800067c0 <xnl_device_auth_reply_func+0x13c>
800067a2:	c0 28       	rjmp	800067a6 <xnl_device_auth_reply_func+0x122>
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
	{
		return;		
800067a4:	d7 03       	nop
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
}
800067a6:	2b bd       	sub	sp,-276
800067a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800067ac:	00 00       	add	r0,r0
800067ae:	0b 44       	ld.w	r4,--r5
800067b0:	00 00       	add	r0,r0
800067b2:	0b 58       	ld.sh	r8,--r5
800067b4:	80 00       	ld.sh	r0,r0[0x0]
800067b6:	86 58       	ld.sh	r8,r3[0xa]
800067b8:	80 01       	ld.sh	r1,r0[0x0]
800067ba:	04 a0       	st.w	r2++,r0
800067bc:	80 00       	ld.sh	r0,r0[0x0]
800067be:	64 70       	ld.w	r0,r2[0x1c]
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	69 78       	ld.w	r8,r4[0x5c]

800067c4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800067c4:	eb cd 40 80 	pushm	r7,lr
800067c8:	1a 97       	mov	r7,sp
800067ca:	20 1d       	sub	sp,4
800067cc:	ef 4c ff fc 	st.w	r7[-4],r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800067d0:	49 b8       	lddpc	r8,8000683c <xnl_device_conn_reply_func+0x78>
800067d2:	70 08       	ld.w	r8,r8[0x0]
800067d4:	30 09       	mov	r9,0
800067d6:	30 0a       	mov	r10,0
800067d8:	30 0b       	mov	r11,0
800067da:	10 9c       	mov	r12,r8
800067dc:	f0 1f 00 19 	mcall	80006840 <xnl_device_conn_reply_func+0x7c>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800067e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800067e4:	f1 08 00 10 	ld.sh	r8,r8[16]
800067e8:	5c 78       	castu.h	r8
800067ea:	e2 18 ff 00 	andl	r8,0xff00,COH
800067ee:	e0 48 01 00 	cp.w	r8,256
800067f2:	c0 60       	breq	800067fe <xnl_device_conn_reply_func+0x3a>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800067f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800067f8:	f0 1f 00 13 	mcall	80006844 <xnl_device_conn_reply_func+0x80>
800067fc:	c1 c8       	rjmp	80006834 <xnl_device_conn_reply_func+0x70>
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800067fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006802:	f1 08 00 10 	ld.sh	r8,r8[16]
80006806:	5c 78       	castu.h	r8
80006808:	a9 68       	lsl	r8,0x8
8000680a:	5c 88       	casts.h	r8
8000680c:	48 f9       	lddpc	r9,80006848 <xnl_device_conn_reply_func+0x84>
8000680e:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80006810:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006814:	f1 08 00 14 	ld.sh	r8,r8[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80006818:	48 c9       	lddpc	r9,80006848 <xnl_device_conn_reply_func+0x84>
8000681a:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000681c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006820:	f1 08 00 12 	ld.sh	r8,r8[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80006824:	48 99       	lddpc	r9,80006848 <xnl_device_conn_reply_func+0x84>
80006826:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80006828:	48 89       	lddpc	r9,80006848 <xnl_device_conn_reply_func+0x84>
8000682a:	30 18       	mov	r8,1
8000682c:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000682e:	48 8c       	lddpc	r12,8000684c <xnl_device_conn_reply_func+0x88>
80006830:	f0 1f 00 08 	mcall	80006850 <xnl_device_conn_reply_func+0x8c>
	}
	
	//xcmp_audio_route_speaker();
	
}
80006834:	2f fd       	sub	sp,-4
80006836:	e3 cd 80 80 	ldm	sp++,r7,pc
8000683a:	00 00       	add	r0,r0
8000683c:	00 00       	add	r0,r0
8000683e:	0b 58       	ld.sh	r8,--r5
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	86 58       	ld.sh	r8,r3[0xa]
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	65 f8       	ld.w	r8,r2[0x7c]
80006848:	00 00       	add	r0,r0
8000684a:	0b 44       	ld.w	r4,--r5
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	64 4c       	ld.w	r12,r2[0x10]
80006850:	80 00       	ld.sh	r0,r0[0x0]
80006852:	9f 84       	st.w	pc[0x20],r4

80006854 <xnl_send_msg_ack>:
Description: send data message ack.
Calls:xnl_tx
Register:xnl_data_msg_func
*/
static void xnl_send_msg_ack(xnl_header_t * hdr)
{	
80006854:	eb cd 40 80 	pushm	r7,lr
80006858:	1a 97       	mov	r7,sp
8000685a:	fa cd 01 04 	sub	sp,sp,260
8000685e:	ef 4c fe fc 	st.w	r7[-260],r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80006862:	e0 68 40 0e 	mov	r8,16398
80006866:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000686a:	3f f8       	mov	r8,-1
8000686c:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80006870:	30 c8       	mov	r8,12
80006872:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80006876:	ee f8 fe fc 	ld.w	r8,r7[-260]
8000687a:	90 18       	ld.sh	r8,r8[0x2]
8000687c:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80006880:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006884:	90 38       	ld.sh	r8,r8[0x6]
80006886:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000688a:	ee f8 fe fc 	ld.w	r8,r7[-260]
8000688e:	90 28       	ld.sh	r8,r8[0x4]
80006890:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80006894:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006898:	90 48       	ld.sh	r8,r8[0x8]
8000689a:	ef 58 ff 0c 	st.h	r7[-244],r8
	xnl_frame.xnl_header.payload_length = 0;
8000689e:	30 08       	mov	r8,0
800068a0:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800068a4:	ee c8 01 00 	sub	r8,r7,256
800068a8:	10 9c       	mov	r12,r8
800068aa:	f0 1f 00 03 	mcall	800068b4 <xnl_send_msg_ack+0x60>
}
800068ae:	2b fd       	sub	sp,-260
800068b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800068b4:	80 00       	ld.sh	r0,r0[0x0]
800068b6:	69 78       	ld.w	r8,r4[0x5c]

800068b8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800068b8:	eb cd 40 c0 	pushm	r6-r7,lr
800068bc:	1a 97       	mov	r7,sp
800068be:	20 1d       	sub	sp,4
800068c0:	ef 4c ff fc 	st.w	r7[-4],r12
	If cannot schedule ACK, just leave without processing message; 
	XNL will retry again, and hopefully our Tx resources will then be free. If 
	ACK has been scheduled. It most likely is already owned by the 
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
800068c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068c8:	2f c8       	sub	r8,-4
800068ca:	10 9c       	mov	r12,r8
800068cc:	f0 1f 00 0b 	mcall	800068f8 <xnl_data_msg_func+0x40>
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800068d0:	48 b8       	lddpc	r8,800068fc <xnl_data_msg_func+0x44>
800068d2:	70 06       	ld.w	r6,r8[0x0]
800068d4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800068d8:	fa cd 00 cc 	sub	sp,sp,204
800068dc:	1a 98       	mov	r8,sp
800068de:	2f 09       	sub	r9,-16
800068e0:	e0 6a 00 ca 	mov	r10,202
800068e4:	12 9b       	mov	r11,r9
800068e6:	10 9c       	mov	r12,r8
800068e8:	f0 1f 00 06 	mcall	80006900 <xnl_data_msg_func+0x48>
800068ec:	5d 16       	icall	r6
800068ee:	fa cd ff 34 	sub	sp,sp,-204
}
800068f2:	2f fd       	sub	sp,-4
800068f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	68 54       	ld.w	r4,r4[0x14]
800068fc:	00 00       	add	r0,r0
800068fe:	0b 50       	ld.sh	r0,--r5
80006900:	80 00       	ld.sh	r0,r0[0x0]
80006902:	ac 76       	st.h	r6[0xe],r6

80006904 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80006904:	eb cd 40 80 	pushm	r7,lr
80006908:	1a 97       	mov	r7,sp
8000690a:	20 2d       	sub	sp,8
8000690c:	ef 4c ff f8 	st.w	r7[-8],r12
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80006910:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006914:	90 48       	ld.sh	r8,r8[0x8]
80006916:	ef 58 ff fc 	st.h	r7[-4],r8
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000691a:	48 d8       	lddpc	r8,8000694c <xnl_get_msg_ack_func+0x48>
8000691c:	90 28       	ld.sh	r8,r8[0x4]
8000691e:	5c 88       	casts.h	r8
80006920:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80006924:	f0 09 19 00 	cp.h	r9,r8
80006928:	c0 e1       	brne	80006944 <xnl_get_msg_ack_func+0x40>
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
8000692a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000692e:	90 68       	ld.sh	r8,r8[0xc]
80006930:	ef 58 ff fe 	st.h	r7[-2],r8
		xSemaphoreGive(xnl_timeout_semphr);	
80006934:	48 78       	lddpc	r8,80006950 <xnl_get_msg_ack_func+0x4c>
80006936:	70 08       	ld.w	r8,r8[0x0]
80006938:	30 09       	mov	r9,0
8000693a:	30 0a       	mov	r10,0
8000693c:	30 0b       	mov	r11,0
8000693e:	10 9c       	mov	r12,r8
80006940:	f0 1f 00 05 	mcall	80006954 <xnl_get_msg_ack_func+0x50>
	}
	
	
	
	//xSemaphoreGive(xnl_timeout_semphr);	
}
80006944:	2f ed       	sub	sp,-8
80006946:	e3 cd 80 80 	ldm	sp++,r7,pc
8000694a:	00 00       	add	r0,r0
8000694c:	00 00       	add	r0,r0
8000694e:	0b 44       	ld.w	r4,--r5
80006950:	00 00       	add	r0,r0
80006952:	0b 58       	ld.sh	r8,--r5
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	86 58       	ld.sh	r8,r3[0xa]

80006958 <xnl_register_xcmp_func>:
/**
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
80006958:	eb cd 40 80 	pushm	r7,lr
8000695c:	1a 97       	mov	r7,sp
8000695e:	20 1d       	sub	sp,4
80006960:	ef 4c ff fc 	st.w	r7[-4],r12
	 xcmp_exec = func;
80006964:	48 48       	lddpc	r8,80006974 <xnl_register_xcmp_func+0x1c>
80006966:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000696a:	91 09       	st.w	r8[0x0],r9
}
8000696c:	2f fd       	sub	sp,-4
8000696e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006972:	00 00       	add	r0,r0
80006974:	00 00       	add	r0,r0
80006976:	0b 50       	ld.sh	r0,--r5

80006978 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80006978:	eb cd 40 80 	pushm	r7,lr
8000697c:	1a 97       	mov	r7,sp
8000697e:	20 3d       	sub	sp,12
80006980:	ef 4c ff f4 	st.w	r7[-12],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006984:	30 08       	mov	r8,0
80006986:	ef 48 ff fc 	st.w	r7[-4],r8
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000698a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000698e:	90 39       	ld.sh	r9,r8[0x6]
80006990:	3f f8       	mov	r8,-1
80006992:	f0 09 19 00 	cp.h	r9,r8
80006996:	c1 01       	brne	800069b6 <xnl_tx+0x3e>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80006998:	4b a8       	lddpc	r8,80006a80 <xnl_tx+0x108>
8000699a:	11 88       	ld.ub	r8,r8[0x0]
8000699c:	2f f8       	sub	r8,-1
8000699e:	5c 58       	castu.b	r8
800069a0:	4b 89       	lddpc	r9,80006a80 <xnl_tx+0x108>
800069a2:	b2 88       	st.b	r9[0x0],r8
800069a4:	4b 78       	lddpc	r8,80006a80 <xnl_tx+0x108>
800069a6:	11 88       	ld.ub	r8,r8[0x0]
800069a8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800069ac:	a9 a8       	sbr	r8,0x8
800069ae:	5c 88       	casts.h	r8
800069b0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800069b4:	b2 38       	st.h	r9[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800069b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800069ba:	90 49       	ld.sh	r9,r8[0x8]
800069bc:	3f f8       	mov	r8,-1
800069be:	f0 09 19 00 	cp.h	r9,r8
800069c2:	c0 71       	brne	800069d0 <xnl_tx+0x58>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800069c4:	4b 08       	lddpc	r8,80006a84 <xnl_tx+0x10c>
800069c6:	90 18       	ld.sh	r8,r8[0x2]
800069c8:	5c 88       	casts.h	r8
800069ca:	ee f9 ff f4 	ld.w	r9,r7[-12]
800069ce:	b2 48       	st.h	r9[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800069d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800069d4:	90 59       	ld.sh	r9,r8[0xa]
800069d6:	3f f8       	mov	r8,-1
800069d8:	f0 09 19 00 	cp.h	r9,r8
800069dc:	c0 71       	brne	800069ea <xnl_tx+0x72>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800069de:	4a a8       	lddpc	r8,80006a84 <xnl_tx+0x10c>
800069e0:	90 28       	ld.sh	r8,r8[0x4]
800069e2:	5c 88       	casts.h	r8
800069e4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800069e8:	b2 58       	st.h	r9[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800069ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800069ee:	90 69       	ld.sh	r9,r8[0xc]
800069f0:	3f f8       	mov	r8,-1
800069f2:	f0 09 19 00 	cp.h	r9,r8
800069f6:	c1 a1       	brne	80006a2a <xnl_tx+0xb2>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800069f8:	4a 38       	lddpc	r8,80006a84 <xnl_tx+0x10c>
800069fa:	90 48       	ld.sh	r8,r8[0x8]
800069fc:	5c 88       	casts.h	r8
800069fe:	2f f8       	sub	r8,-1
80006a00:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80006a02:	4a 19       	lddpc	r9,80006a84 <xnl_tx+0x10c>
80006a04:	b2 48       	st.h	r9[0x8],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
80006a06:	4a 08       	lddpc	r8,80006a84 <xnl_tx+0x10c>
80006a08:	90 48       	ld.sh	r8,r8[0x8]
80006a0a:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80006a0c:	5c 88       	casts.h	r8
80006a0e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80006a12:	49 d9       	lddpc	r9,80006a84 <xnl_tx+0x10c>
80006a14:	92 49       	ld.sh	r9,r9[0x8]
80006a16:	5c 89       	casts.h	r9
80006a18:	5c 89       	casts.h	r9
80006a1a:	e0 19 ff 00 	andl	r9,0xff00
80006a1e:	5c 89       	casts.h	r9
80006a20:	12 48       	or	r8,r9
80006a22:	5c 88       	casts.h	r8
80006a24:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006a28:	b2 68       	st.h	r9[0xc],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80006a2a:	ee fc ff f4 	ld.w	r12,r7[-12]
80006a2e:	f0 1f 00 17 	mcall	80006a88 <xnl_tx+0x110>
80006a32:	18 98       	mov	r8,r12
80006a34:	5c 88       	casts.h	r8
80006a36:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006a3a:	b2 18       	st.h	r9[0x2],r8
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80006a3c:	49 48       	lddpc	r8,80006a8c <xnl_tx+0x114>
80006a3e:	70 08       	ld.w	r8,r8[0x0]
80006a40:	10 9c       	mov	r12,r8
80006a42:	f0 1f 00 14 	mcall	80006a90 <xnl_tx+0x118>
80006a46:	18 98       	mov	r8,r12
80006a48:	ef 48 ff f8 	st.w	r7[-8],r8
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80006a4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a50:	58 08       	cp.w	r8,0
80006a52:	c1 30       	breq	80006a78 <xnl_tx+0x100>
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80006a54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a58:	e0 6a 01 00 	mov	r10,256
80006a5c:	ee fb ff f4 	ld.w	r11,r7[-12]
80006a60:	10 9c       	mov	r12,r8
80006a62:	f0 1f 00 0d 	mcall	80006a94 <xnl_tx+0x11c>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80006a66:	48 d8       	lddpc	r8,80006a98 <xnl_tx+0x120>
80006a68:	70 08       	ld.w	r8,r8[0x0]
80006a6a:	ee cb 00 08 	sub	r11,r7,8
80006a6e:	30 09       	mov	r9,0
80006a70:	30 0a       	mov	r10,0
80006a72:	10 9c       	mov	r12,r8
80006a74:	f0 1f 00 0a 	mcall	80006a9c <xnl_tx+0x124>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80006a78:	2f dd       	sub	sp,-12
80006a7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a7e:	00 00       	add	r0,r0
80006a80:	00 00       	add	r0,r0
80006a82:	0b 68       	ld.uh	r8,--r5
80006a84:	00 00       	add	r0,r0
80006a86:	0b 44       	ld.w	r4,--r5
80006a88:	80 00       	ld.sh	r0,r0[0x0]
80006a8a:	65 1c       	ld.w	r12,r2[0x44]
80006a8c:	00 00       	add	r0,r0
80006a8e:	0a 7c       	tst	r12,r5
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	5b 50       	cp.w	r0,-11
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	ac 76       	st.h	r6[0xe],r6
80006a98:	00 00       	add	r0,r0
80006a9a:	0b 54       	ld.sh	r4,--r5
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	86 58       	ld.sh	r8,r3[0xa]

80006aa0 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80006aa0:	eb cd 40 80 	pushm	r7,lr
80006aa4:	1a 97       	mov	r7,sp
80006aa6:	20 1d       	sub	sp,4
80006aa8:	ef 4c ff fc 	st.w	r7[-4],r12
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80006aac:	4b 68       	lddpc	r8,80006b84 <xnl_tx_process+0xe4>
80006aae:	70 08       	ld.w	r8,r8[0x0]
80006ab0:	58 08       	cp.w	r8,0
80006ab2:	c0 40       	breq	80006aba <xnl_tx_process+0x1a>
80006ab4:	58 18       	cp.w	r8,1
80006ab6:	c3 10       	breq	80006b18 <xnl_tx_process+0x78>
				}
				break;
			default:
				break;
		}
	}
80006ab8:	cf ab       	rjmp	80006aac <xnl_tx_process+0xc>
	for(;;)
	{		
		switch(xnl_tx_state)
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80006aba:	4b 48       	lddpc	r8,80006b88 <xnl_tx_process+0xe8>
80006abc:	70 08       	ld.w	r8,r8[0x0]
80006abe:	30 09       	mov	r9,0
80006ac0:	3f fa       	mov	r10,-1
80006ac2:	4b 3b       	lddpc	r11,80006b8c <xnl_tx_process+0xec>
80006ac4:	10 9c       	mov	r12,r8
80006ac6:	f0 1f 00 33 	mcall	80006b90 <xnl_tx_process+0xf0>
80006aca:	18 98       	mov	r8,r12
80006acc:	58 18       	cp.w	r8,1
80006ace:	c2 41       	brne	80006b16 <xnl_tx_process+0x76>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80006ad0:	4a f8       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006ad2:	70 08       	ld.w	r8,r8[0x0]
80006ad4:	58 08       	cp.w	r8,0
80006ad6:	c0 21       	brne	80006ada <xnl_tx_process+0x3a>
					{
						break;
80006ad8:	c5 48       	rjmp	80006b80 <xnl_tx_process+0xe0>
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80006ada:	4a d8       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006adc:	70 08       	ld.w	r8,r8[0x0]
80006ade:	90 28       	ld.sh	r8,r8[0x4]
80006ae0:	58 08       	cp.w	r8,0
80006ae2:	c0 71       	brne	80006af0 <xnl_tx_process+0x50>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80006ae4:	4a a8       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006ae6:	70 08       	ld.w	r8,r8[0x0]
80006ae8:	10 9c       	mov	r12,r8
80006aea:	f0 1f 00 2b 	mcall	80006b94 <xnl_tx_process+0xf4>
						break;
80006aee:	c4 98       	rjmp	80006b80 <xnl_tx_process+0xe0>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80006af0:	4a 78       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006af2:	70 08       	ld.w	r8,r8[0x0]
80006af4:	10 9c       	mov	r12,r8
80006af6:	f0 1f 00 29 	mcall	80006b98 <xnl_tx_process+0xf8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80006afa:	4a 98       	lddpc	r8,80006b9c <xnl_tx_process+0xfc>
80006afc:	30 19       	mov	r9,1
80006afe:	91 09       	st.w	r8[0x0],r9
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80006b00:	4a 88       	lddpc	r8,80006ba0 <xnl_tx_process+0x100>
80006b02:	70 08       	ld.w	r8,r8[0x0]
80006b04:	30 09       	mov	r9,0
80006b06:	30 0a       	mov	r10,0
80006b08:	30 0b       	mov	r11,0
80006b0a:	10 9c       	mov	r12,r8
80006b0c:	f0 1f 00 21 	mcall	80006b90 <xnl_tx_process+0xf0>
					xnl_tx_state = WAITING_FOR_REPLY;
80006b10:	49 d8       	lddpc	r8,80006b84 <xnl_tx_process+0xe4>
80006b12:	30 19       	mov	r9,1
80006b14:	91 09       	st.w	r8[0x0],r9
				}
				break;
80006b16:	c3 58       	rjmp	80006b80 <xnl_tx_process+0xe0>
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80006b18:	4a 28       	lddpc	r8,80006ba0 <xnl_tx_process+0x100>
80006b1a:	70 08       	ld.w	r8,r8[0x0]
80006b1c:	30 09       	mov	r9,0
80006b1e:	36 4a       	mov	r10,100
80006b20:	30 0b       	mov	r11,0
80006b22:	10 9c       	mov	r12,r8
80006b24:	f0 1f 00 1b 	mcall	80006b90 <xnl_tx_process+0xf0>
80006b28:	18 98       	mov	r8,r12
80006b2a:	58 18       	cp.w	r8,1
80006b2c:	c0 d1       	brne	80006b46 <xnl_tx_process+0xa6>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80006b2e:	49 88       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006b30:	70 09       	ld.w	r9,r8[0x0]
80006b32:	49 d8       	lddpc	r8,80006ba4 <xnl_tx_process+0x104>
80006b34:	70 08       	ld.w	r8,r8[0x0]
80006b36:	12 9b       	mov	r11,r9
80006b38:	10 9c       	mov	r12,r8
80006b3a:	f0 1f 00 1c 	mcall	80006ba8 <xnl_tx_process+0x108>
					xnl_tx_state = WAITING_FOR_TX;
80006b3e:	49 28       	lddpc	r8,80006b84 <xnl_tx_process+0xe4>
80006b40:	30 09       	mov	r9,0
80006b42:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80006b44:	cb 4b       	rjmp	80006aac <xnl_tx_process+0xc>
					xnl_tx_state = WAITING_FOR_TX;
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80006b46:	49 68       	lddpc	r8,80006b9c <xnl_tx_process+0xfc>
80006b48:	70 08       	ld.w	r8,r8[0x0]
80006b4a:	58 38       	cp.w	r8,3
80006b4c:	e0 89 00 0e 	brgt	80006b68 <xnl_tx_process+0xc8>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80006b50:	48 f8       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006b52:	70 08       	ld.w	r8,r8[0x0]
80006b54:	10 9c       	mov	r12,r8
80006b56:	f0 1f 00 11 	mcall	80006b98 <xnl_tx_process+0xf8>
						xnl_send_times++;
80006b5a:	49 18       	lddpc	r8,80006b9c <xnl_tx_process+0xfc>
80006b5c:	70 08       	ld.w	r8,r8[0x0]
80006b5e:	f0 c9 ff ff 	sub	r9,r8,-1
80006b62:	48 f8       	lddpc	r8,80006b9c <xnl_tx_process+0xfc>
80006b64:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80006b66:	ca 3b       	rjmp	80006aac <xnl_tx_process+0xc>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80006b68:	48 98       	lddpc	r8,80006b8c <xnl_tx_process+0xec>
80006b6a:	70 09       	ld.w	r9,r8[0x0]
80006b6c:	48 e8       	lddpc	r8,80006ba4 <xnl_tx_process+0x104>
80006b6e:	70 08       	ld.w	r8,r8[0x0]
80006b70:	12 9b       	mov	r11,r9
80006b72:	10 9c       	mov	r12,r8
80006b74:	f0 1f 00 0d 	mcall	80006ba8 <xnl_tx_process+0x108>
						xnl_tx_state = WAITING_FOR_TX;
80006b78:	48 38       	lddpc	r8,80006b84 <xnl_tx_process+0xe4>
80006b7a:	30 09       	mov	r9,0
80006b7c:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80006b7e:	c9 7b       	rjmp	80006aac <xnl_tx_process+0xc>
80006b80:	c9 6b       	rjmp	80006aac <xnl_tx_process+0xc>
80006b82:	00 00       	add	r0,r0
80006b84:	00 00       	add	r0,r0
80006b86:	0b 5c       	ld.sh	r12,--r5
80006b88:	00 00       	add	r0,r0
80006b8a:	0b 54       	ld.sh	r4,--r5
80006b8c:	00 00       	add	r0,r0
80006b8e:	0b 60       	ld.uh	r0,--r5
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	88 64       	ld.sh	r4,r4[0xc]
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	85 08       	st.w	r2[0x0],r8
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	40 08       	lddsp	r8,sp[0x0]
80006b9c:	00 00       	add	r0,r0
80006b9e:	0b 64       	ld.uh	r4,--r5
80006ba0:	00 00       	add	r0,r0
80006ba2:	0b 58       	ld.sh	r8,--r5
80006ba4:	00 00       	add	r0,r0
80006ba6:	0a 7c       	tst	r12,r5
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	5b d8       	cp.w	r8,-3

80006bac <xnl_rx>:
Description: Receive the XNL and perform the corresponding functions
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
80006bac:	eb cd 40 80 	pushm	r7,lr
80006bb0:	1a 97       	mov	r7,sp
80006bb2:	20 1d       	sub	sp,4
80006bb4:	ef 4c ff fc 	st.w	r7[-4],r12
	if(xnl->xnl_header.opcode > 0x0C)	
80006bb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006bbc:	90 29       	ld.sh	r9,r8[0x4]
80006bbe:	30 c8       	mov	r8,12
80006bc0:	f0 09 19 00 	cp.h	r9,r8
80006bc4:	e0 8b 00 18 	brhi	80006bf4 <xnl_rx+0x48>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80006bc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006bcc:	90 28       	ld.sh	r8,r8[0x4]
80006bce:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006bd2:	48 b8       	lddpc	r8,80006bfc <xnl_rx+0x50>
80006bd4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006bd8:	58 08       	cp.w	r8,0
80006bda:	c0 e0       	breq	80006bf6 <xnl_rx+0x4a>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80006bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006be0:	90 28       	ld.sh	r8,r8[0x4]
80006be2:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006be6:	48 68       	lddpc	r8,80006bfc <xnl_rx+0x50>
80006be8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006bec:	ee fc ff fc 	ld.w	r12,r7[-4]
80006bf0:	5d 18       	icall	r8
80006bf2:	c0 28       	rjmp	80006bf6 <xnl_rx+0x4a>
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
80006bf4:	d7 03       	nop
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
	}
}
80006bf6:	2f fd       	sub	sp,-4
80006bf8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bfc:	00 00       	add	r0,r0
80006bfe:	05 10       	ld.sh	r0,r2++

80006c00 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80006c00:	eb cd 40 80 	pushm	r7,lr
80006c04:	1a 97       	mov	r7,sp
80006c06:	20 2d       	sub	sp,8
80006c08:	ef 4c ff f8 	st.w	r7[-8],r12
80006c0c:	c0 48       	rjmp	80006c14 <xnl_rx_process+0x14>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
80006c0e:	d7 03       	nop
80006c10:	c0 28       	rjmp	80006c14 <xnl_rx_process+0x14>
80006c12:	d7 03       	nop
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80006c14:	48 f8       	lddpc	r8,80006c50 <xnl_rx_process+0x50>
80006c16:	70 08       	ld.w	r8,r8[0x0]
80006c18:	ee cb 00 04 	sub	r11,r7,4
80006c1c:	30 09       	mov	r9,0
80006c1e:	3f fa       	mov	r10,-1
80006c20:	10 9c       	mov	r12,r8
80006c22:	f0 1f 00 0d 	mcall	80006c54 <xnl_rx_process+0x54>
80006c26:	18 98       	mov	r8,r12
80006c28:	58 18       	cp.w	r8,1
80006c2a:	cf 21       	brne	80006c0e <xnl_rx_process+0xe>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80006c2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c30:	58 08       	cp.w	r8,0
80006c32:	cf 00       	breq	80006c12 <xnl_rx_process+0x12>
			{
				xnl_rx(xnl_ptr);
80006c34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c38:	10 9c       	mov	r12,r8
80006c3a:	f0 1f 00 08 	mcall	80006c58 <xnl_rx_process+0x58>
				set_xnl_idle(xnl_ptr);
80006c3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c42:	48 78       	lddpc	r8,80006c5c <xnl_rx_process+0x5c>
80006c44:	70 08       	ld.w	r8,r8[0x0]
80006c46:	12 9b       	mov	r11,r9
80006c48:	10 9c       	mov	r12,r8
80006c4a:	f0 1f 00 06 	mcall	80006c60 <xnl_rx_process+0x60>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
80006c4e:	ce 3b       	rjmp	80006c14 <xnl_rx_process+0x14>
80006c50:	00 00       	add	r0,r0
80006c52:	0a 84       	andn	r4,r5
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	88 64       	ld.sh	r4,r4[0xc]
80006c58:	80 00       	ld.sh	r0,r0[0x0]
80006c5a:	6b ac       	ld.w	r12,r5[0x68]
80006c5c:	00 00       	add	r0,r0
80006c5e:	0a 7c       	tst	r12,r5
80006c60:	80 00       	ld.sh	r0,r0[0x0]
80006c62:	5b d8       	cp.w	r8,-3

80006c64 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80006c64:	eb cd 40 80 	pushm	r7,lr
80006c68:	1a 97       	mov	r7,sp
	/*initialize the physical layer*/
	phy_init();
80006c6a:	f0 1f 00 21 	mcall	80006cec <xnl_init+0x88>
	
	xnl_information.is_connected = FALSE;
80006c6e:	4a 19       	lddpc	r9,80006cf0 <xnl_init+0x8c>
80006c70:	30 08       	mov	r8,0
80006c72:	b2 88       	st.b	r9[0x0],r8

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80006c74:	30 0b       	mov	r11,0
80006c76:	30 1c       	mov	r12,1
80006c78:	f0 1f 00 1f 	mcall	80006cf4 <xnl_init+0x90>
80006c7c:	18 99       	mov	r9,r12
80006c7e:	49 f8       	lddpc	r8,80006cf8 <xnl_init+0x94>
80006c80:	91 09       	st.w	r8[0x0],r9
80006c82:	49 e8       	lddpc	r8,80006cf8 <xnl_init+0x94>
80006c84:	70 08       	ld.w	r8,r8[0x0]
80006c86:	58 08       	cp.w	r8,0
80006c88:	c0 90       	breq	80006c9a <xnl_init+0x36>
80006c8a:	49 c8       	lddpc	r8,80006cf8 <xnl_init+0x94>
80006c8c:	70 08       	ld.w	r8,r8[0x0]
80006c8e:	30 09       	mov	r9,0
80006c90:	30 0a       	mov	r10,0
80006c92:	30 0b       	mov	r11,0
80006c94:	10 9c       	mov	r12,r8
80006c96:	f0 1f 00 1a 	mcall	80006cfc <xnl_init+0x98>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80006c9a:	30 4b       	mov	r11,4
80006c9c:	31 4c       	mov	r12,20
80006c9e:	f0 1f 00 16 	mcall	80006cf4 <xnl_init+0x90>
80006ca2:	18 99       	mov	r9,r12
80006ca4:	49 78       	lddpc	r8,80006d00 <xnl_init+0x9c>
80006ca6:	91 09       	st.w	r8[0x0],r9
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80006ca8:	49 7b       	lddpc	r11,80006d04 <xnl_init+0xa0>
80006caa:	30 08       	mov	r8,0
80006cac:	1a d8       	st.w	--sp,r8
80006cae:	30 08       	mov	r8,0
80006cb0:	1a d8       	st.w	--sp,r8
80006cb2:	30 08       	mov	r8,0
80006cb4:	1a d8       	st.w	--sp,r8
80006cb6:	30 38       	mov	r8,3
80006cb8:	30 09       	mov	r9,0
80006cba:	e0 6a 02 00 	mov	r10,512
80006cbe:	49 3c       	lddpc	r12,80006d08 <xnl_init+0xa4>
80006cc0:	f0 1f 00 13 	mcall	80006d0c <xnl_init+0xa8>
80006cc4:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80006cc6:	49 3b       	lddpc	r11,80006d10 <xnl_init+0xac>
80006cc8:	30 08       	mov	r8,0
80006cca:	1a d8       	st.w	--sp,r8
80006ccc:	30 08       	mov	r8,0
80006cce:	1a d8       	st.w	--sp,r8
80006cd0:	30 08       	mov	r8,0
80006cd2:	1a d8       	st.w	--sp,r8
80006cd4:	30 38       	mov	r8,3
80006cd6:	30 09       	mov	r9,0
80006cd8:	e0 6a 03 20 	mov	r10,800
80006cdc:	48 ec       	lddpc	r12,80006d14 <xnl_init+0xb0>
80006cde:	f0 1f 00 0c 	mcall	80006d0c <xnl_init+0xa8>
80006ce2:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
80006ce4:	f0 1f 00 0d 	mcall	80006d18 <xnl_init+0xb4>
}
80006ce8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006cec:	80 00       	ld.sh	r0,r0[0x0]
80006cee:	3e fc       	mov	r12,-17
80006cf0:	00 00       	add	r0,r0
80006cf2:	0b 44       	ld.w	r4,--r5
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	85 40       	st.w	r2[0x10],r0
80006cf8:	00 00       	add	r0,r0
80006cfa:	0b 58       	ld.sh	r8,--r5
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	86 58       	ld.sh	r8,r3[0xa]
80006d00:	00 00       	add	r0,r0
80006d02:	0b 54       	ld.sh	r4,--r5
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	64 60       	ld.w	r0,r2[0x18]
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	6c 00       	ld.w	r0,r6[0x0]
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	8d b0       	st.w	r6[0x2c],r0
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	64 68       	ld.w	r8,r2[0x18]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	6a a0       	ld.w	r0,r5[0x28]
80006d18:	80 00       	ld.sh	r0,r0[0x0]
80006d1a:	65 a8       	ld.w	r8,r2[0x68]

80006d1c <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80006d1c:	eb cd 40 80 	pushm	r7,lr
80006d20:	1a 97       	mov	r7,sp
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80006d22:	fe 78 0c 00 	mov	r8,-62464
80006d26:	e0 69 03 07 	mov	r9,775
80006d2a:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80006d2c:	fe 78 0c 00 	mov	r8,-62464
80006d30:	30 49       	mov	r9,4
80006d32:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006d34:	fe 78 0c 00 	mov	r8,-62464
80006d38:	71 58       	ld.w	r8,r8[0x54]
80006d3a:	e2 18 00 80 	andl	r8,0x80,COH
80006d3e:	cf b0       	breq	80006d34 <local_start_pll0+0x18>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80006d40:	fe 78 0c 00 	mov	r8,-62464
80006d44:	30 59       	mov	r9,5
80006d46:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80006d48:	fe 78 0c 00 	mov	r8,-62464
80006d4c:	e0 69 01 0d 	mov	r9,269
80006d50:	ea 19 10 07 	orh	r9,0x1007
80006d54:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80006d56:	fe 78 0c 00 	mov	r8,-62464
80006d5a:	71 58       	ld.w	r8,r8[0x54]
80006d5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d60:	cf b0       	breq	80006d56 <local_start_pll0+0x3a>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80006d62:	fe 78 0c 00 	mov	r8,-62464
80006d66:	fc 19 00 80 	movh	r9,0x80
80006d6a:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80006d6c:	fe 68 14 00 	mov	r8,-125952
80006d70:	34 09       	mov	r9,64
80006d72:	91 09       	st.w	r8[0x0],r9

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80006d74:	fe 78 0c 00 	mov	r8,-62464
80006d78:	30 69       	mov	r9,6
80006d7a:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80006d7c:	fe 68 10 00 	mov	r8,-126976
80006d80:	30 19       	mov	r9,1
80006d82:	91 19       	st.w	r8[0x4],r9
}
80006d84:	e3 cd 80 80 	ldm	sp++,r7,pc

80006d88 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80006d88:	eb cd 40 80 	pushm	r7,lr
80006d8c:	1a 97       	mov	r7,sp
	// Increment the 10ms seconds counter
	tc_tick++;
80006d8e:	48 88       	lddpc	r8,80006dac <_tc_interrupt+0x24>
80006d90:	70 08       	ld.w	r8,r8[0x0]
80006d92:	f0 c9 ff ff 	sub	r9,r8,-1
80006d96:	48 68       	lddpc	r8,80006dac <_tc_interrupt+0x24>
80006d98:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80006d9a:	30 1b       	mov	r11,1
80006d9c:	fe 7c 38 00 	mov	r12,-51200
80006da0:	f0 1f 00 04 	mcall	80006db0 <_tc_interrupt+0x28>
	
}
80006da4:	e3 cd 40 80 	ldm	sp++,r7,lr
80006da8:	d6 03       	rete
80006daa:	00 00       	add	r0,r0
80006dac:	00 00       	add	r0,r0
80006dae:	0b 6c       	ld.uh	r12,--r5
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	78 f2       	ld.w	r2,r12[0x3c]

80006db4 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80006db4:	eb cd 40 80 	pushm	r7,lr
80006db8:	1a 97       	mov	r7,sp
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80006dba:	fe 78 10 00 	mov	r8,-61440
80006dbe:	fc 19 00 10 	movh	r9,0x10
80006dc2:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80006dc4:	fe 78 10 00 	mov	r8,-61440
80006dc8:	fc 19 00 10 	movh	r9,0x10
80006dcc:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80006dce:	fe 78 10 00 	mov	r8,-61440
80006dd2:	fc 19 00 10 	movh	r9,0x10
80006dd6:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80006dd8:	fe 78 10 00 	mov	r8,-61440
80006ddc:	30 39       	mov	r9,3
80006dde:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80006de2:	fe 78 10 00 	mov	r8,-61440
80006de6:	30 39       	mov	r9,3
80006de8:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80006dec:	fe 78 10 00 	mov	r8,-61440
80006df0:	30 39       	mov	r9,3
80006df2:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80006df6:	fe 78 38 00 	mov	r8,-51200
80006dfa:	30 49       	mov	r9,4
80006dfc:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80006e00:	fe 78 38 00 	mov	r8,-51200
80006e04:	e0 69 91 0d 	mov	r9,37133
80006e08:	ea 19 00 52 	orh	r9,0x52
80006e0c:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80006e0e:	fe 78 38 00 	mov	r8,-51200
80006e12:	32 09       	mov	r9,32
80006e14:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80006e16:	fe 78 38 00 	mov	r8,-51200
80006e1a:	30 59       	mov	r9,5
80006e1c:	91 09       	st.w	r8[0x0],r9
}
80006e1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e22:	d7 03       	nop

80006e24 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80006e24:	eb cd 40 80 	pushm	r7,lr
80006e28:	1a 97       	mov	r7,sp
80006e2a:	20 1d       	sub	sp,4

	volatile avr32_tc_t * tc = EXAMPLE_TC;
80006e2c:	fe 78 38 00 	mov	r8,-51200
80006e30:	ef 48 ff fc 	st.w	r7[-4],r8
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80006e34:	30 2a       	mov	r10,2
80006e36:	e0 6b 01 c1 	mov	r11,449
80006e3a:	48 fc       	lddpc	r12,80006e74 <tc_init+0x50>
80006e3c:	f0 1f 00 0f 	mcall	80006e78 <tc_init+0x54>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80006e40:	48 fb       	lddpc	r11,80006e7c <tc_init+0x58>
80006e42:	ee fc ff fc 	ld.w	r12,r7[-4]
80006e46:	f0 1f 00 0f 	mcall	80006e80 <tc_init+0x5c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80006e4a:	e0 6a 75 30 	mov	r10,30000
80006e4e:	30 1b       	mov	r11,1
80006e50:	ee fc ff fc 	ld.w	r12,r7[-4]
80006e54:	f0 1f 00 0c 	mcall	80006e84 <tc_init+0x60>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80006e58:	48 ca       	lddpc	r10,80006e88 <tc_init+0x64>
80006e5a:	30 1b       	mov	r11,1
80006e5c:	ee fc ff fc 	ld.w	r12,r7[-4]
80006e60:	f0 1f 00 0b 	mcall	80006e8c <tc_init+0x68>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80006e64:	30 1b       	mov	r11,1
80006e66:	ee fc ff fc 	ld.w	r12,r7[-4]
80006e6a:	f0 1f 00 0a 	mcall	80006e90 <tc_init+0x6c>
80006e6e:	2f fd       	sub	sp,-4
80006e70:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e74:	80 00       	ld.sh	r0,r0[0x0]
80006e76:	6d 88       	ld.w	r8,r6[0x60]
80006e78:	80 00       	ld.sh	r0,r0[0x0]
80006e7a:	6f b8       	ld.w	r8,r7[0x6c]
80006e7c:	80 01       	ld.sh	r1,r0[0x0]
80006e7e:	04 b4       	st.h	r2++,r4
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	77 64       	ld.w	r4,r11[0x58]
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	79 2c       	ld.w	r12,r12[0x48]
80006e88:	80 01       	ld.sh	r1,r0[0x0]
80006e8a:	04 bc       	st.h	r2++,r12
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	75 7c       	ld.w	r12,r10[0x5c]
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	78 b8       	ld.w	r8,r12[0x2c]

80006e94 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80006e94:	eb cd 40 80 	pushm	r7,lr
80006e98:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80006e9a:	c0 08       	rjmp	80006e9a <_unhandled_interrupt+0x6>

80006e9c <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80006e9c:	eb cd 40 80 	pushm	r7,lr
80006ea0:	1a 97       	mov	r7,sp
80006ea2:	20 3d       	sub	sp,12
80006ea4:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006ea8:	fe 78 08 00 	mov	r8,-63488
80006eac:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006eb0:	f2 09 11 03 	rsub	r9,r9,3
80006eb4:	28 09       	sub	r9,-128
80006eb6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006eba:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006ebe:	fe 78 08 00 	mov	r8,-63488
80006ec2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006ec6:	2c 09       	sub	r9,-64
80006ec8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006ecc:	ef 48 ff fc 	st.w	r7[-4],r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80006ed0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006ed4:	58 08       	cp.w	r8,0
80006ed6:	c1 30       	breq	80006efc <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006ed8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006edc:	48 b8       	lddpc	r8,80006f08 <_get_interrupt_handler+0x6c>
80006ede:	a1 79       	lsl	r9,0x1
80006ee0:	2f f9       	sub	r9,-1
80006ee2:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80006ee6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006eea:	f0 08 12 00 	clz	r8,r8
80006eee:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80006ef2:	a3 68       	lsl	r8,0x2
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006ef4:	f2 08 00 08 	add	r8,r9,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80006ef8:	70 08       	ld.w	r8,r8[0x0]
80006efa:	c0 28       	rjmp	80006efe <_get_interrupt_handler+0x62>
80006efc:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006efe:	10 9c       	mov	r12,r8
80006f00:	2f dd       	sub	sp,-12
80006f02:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f06:	00 00       	add	r0,r0
80006f08:	80 01       	ld.sh	r1,r0[0x0]
80006f0a:	04 c0       	st.b	r2++,r0

80006f0c <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80006f0c:	eb cd 40 80 	pushm	r7,lr
80006f10:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006f12:	48 38       	lddpc	r8,80006f1c <INTC_init_evba+0x10>
80006f14:	e3 b8 00 01 	mtsr	0x4,r8
}
80006f18:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f1c:	80 01       	ld.sh	r1,r0[0x0]
80006f1e:	02 00       	add	r0,r1

80006f20 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80006f20:	eb cd 40 80 	pushm	r7,lr
80006f24:	1a 97       	mov	r7,sp
80006f26:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80006f28:	f0 1f 00 1f 	mcall	80006fa4 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006f2c:	30 08       	mov	r8,0
80006f2e:	ef 48 ff f8 	st.w	r7[-8],r8
80006f32:	c3 18       	rjmp	80006f94 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006f34:	30 08       	mov	r8,0
80006f36:	ef 48 ff fc 	st.w	r7[-4],r8
80006f3a:	c1 48       	rjmp	80006f62 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80006f3c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006f40:	49 a8       	lddpc	r8,80006fa8 <INTC_init_interrupts+0x88>
80006f42:	a1 79       	lsl	r9,0x1
80006f44:	2f f9       	sub	r9,-1
80006f46:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80006f4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006f4e:	a3 68       	lsl	r8,0x2
80006f50:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006f54:	49 69       	lddpc	r9,80006fac <INTC_init_interrupts+0x8c>
80006f56:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006f58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006f5c:	2f f8       	sub	r8,-1
80006f5e:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80006f62:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006f66:	49 18       	lddpc	r8,80006fa8 <INTC_init_interrupts+0x88>
80006f68:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006f6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006f70:	10 39       	cp.w	r9,r8
80006f72:	fe 9b ff e5 	brhi	80006f3c <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006f76:	fe 78 08 00 	mov	r8,-63488
80006f7a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006f7e:	48 db       	lddpc	r11,80006fb0 <INTC_init_interrupts+0x90>
80006f80:	48 da       	lddpc	r10,80006fb4 <INTC_init_interrupts+0x94>
80006f82:	f6 0a 01 0a 	sub	r10,r11,r10
80006f86:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006f8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006f8e:	2f f8       	sub	r8,-1
80006f90:	ef 48 ff f8 	st.w	r7[-8],r8
80006f94:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006f98:	59 28       	cp.w	r8,18
80006f9a:	fe 98 ff cd 	brls	80006f34 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80006f9e:	2f ed       	sub	sp,-8
80006fa0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fa4:	80 00       	ld.sh	r0,r0[0x0]
80006fa6:	6f 0c       	ld.w	r12,r7[0x40]
80006fa8:	80 01       	ld.sh	r1,r0[0x0]
80006faa:	04 c0       	st.b	r2++,r0
80006fac:	80 00       	ld.sh	r0,r0[0x0]
80006fae:	6e 94       	ld.w	r4,r7[0x24]
80006fb0:	80 01       	ld.sh	r1,r0[0x0]
80006fb2:	03 04       	ld.w	r4,r1++
80006fb4:	80 01       	ld.sh	r1,r0[0x0]
80006fb6:	02 00       	add	r0,r1

80006fb8 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80006fb8:	eb cd 40 80 	pushm	r7,lr
80006fbc:	1a 97       	mov	r7,sp
80006fbe:	20 4d       	sub	sp,16
80006fc0:	ef 4c ff f8 	st.w	r7[-8],r12
80006fc4:	ef 4b ff f4 	st.w	r7[-12],r11
80006fc8:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80006fcc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006fd0:	a5 98       	lsr	r8,0x5
80006fd2:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80006fd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006fda:	4a 78       	lddpc	r8,80007074 <INTC_register_interrupt+0xbc>
80006fdc:	a1 79       	lsl	r9,0x1
80006fde:	2f f9       	sub	r9,-1
80006fe0:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80006fe4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006fe8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80006fec:	a3 68       	lsl	r8,0x2
80006fee:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80006ff2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006ff6:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006ff8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006ffc:	58 08       	cp.w	r8,0
80006ffe:	c0 c1       	brne	80007016 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80007000:	fe 78 08 00 	mov	r8,-63488
80007004:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007008:	49 cb       	lddpc	r11,80007078 <INTC_register_interrupt+0xc0>
8000700a:	49 da       	lddpc	r10,8000707c <INTC_register_interrupt+0xc4>
8000700c:	f6 0a 01 0a 	sub	r10,r11,r10
80007010:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007014:	c2 d8       	rjmp	8000706e <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80007016:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000701a:	58 18       	cp.w	r8,1
8000701c:	c0 d1       	brne	80007036 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000701e:	fe 78 08 00 	mov	r8,-63488
80007022:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007026:	49 7b       	lddpc	r11,80007080 <INTC_register_interrupt+0xc8>
80007028:	49 5a       	lddpc	r10,8000707c <INTC_register_interrupt+0xc4>
8000702a:	f6 0a 01 0a 	sub	r10,r11,r10
8000702e:	bf aa       	sbr	r10,0x1e
80007030:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007034:	c1 d8       	rjmp	8000706e <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80007036:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000703a:	58 28       	cp.w	r8,2
8000703c:	c0 d1       	brne	80007056 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000703e:	fe 78 08 00 	mov	r8,-63488
80007042:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007046:	49 0b       	lddpc	r11,80007084 <INTC_register_interrupt+0xcc>
80007048:	48 da       	lddpc	r10,8000707c <INTC_register_interrupt+0xc4>
8000704a:	f6 0a 01 0a 	sub	r10,r11,r10
8000704e:	bf ba       	sbr	r10,0x1f
80007050:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007054:	c0 d8       	rjmp	8000706e <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80007056:	fe 78 08 00 	mov	r8,-63488
8000705a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000705e:	48 bb       	lddpc	r11,80007088 <INTC_register_interrupt+0xd0>
80007060:	48 7a       	lddpc	r10,8000707c <INTC_register_interrupt+0xc4>
80007062:	f6 0a 01 0a 	sub	r10,r11,r10
80007066:	ea 1a c0 00 	orh	r10,0xc000
8000706a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
8000706e:	2f cd       	sub	sp,-16
80007070:	e3 cd 80 80 	ldm	sp++,r7,pc
80007074:	80 01       	ld.sh	r1,r0[0x0]
80007076:	04 c0       	st.b	r2++,r0
80007078:	80 01       	ld.sh	r1,r0[0x0]
8000707a:	03 04       	ld.w	r4,r1++
8000707c:	80 01       	ld.sh	r1,r0[0x0]
8000707e:	02 00       	add	r0,r1
80007080:	80 01       	ld.sh	r1,r0[0x0]
80007082:	03 12       	ld.sh	r2,r1++
80007084:	80 01       	ld.sh	r1,r0[0x0]
80007086:	03 20       	ld.uh	r0,r1++
80007088:	80 01       	ld.sh	r1,r0[0x0]
8000708a:	03 2e       	ld.uh	lr,r1++

8000708c <getBaudDiv>:
 * \return Divider or error code.
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
8000708c:	eb cd 40 80 	pushm	r7,lr
80007090:	1a 97       	mov	r7,sp
80007092:	20 3d       	sub	sp,12
80007094:	ef 4c ff f8 	st.w	r7[-8],r12
80007098:	ef 4b ff f4 	st.w	r7[-12],r11
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
8000709c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800070a0:	70 18       	ld.w	r8,r8[0x4]
800070a2:	f0 09 16 01 	lsr	r9,r8,0x1
800070a6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800070aa:	f2 08 00 08 	add	r8,r9,r8
800070ae:	ee f9 ff f8 	ld.w	r9,r7[-8]
800070b2:	72 19       	ld.w	r9,r9[0x4]
800070b4:	f0 09 0d 08 	divu	r8,r8,r9
800070b8:	ef 48 ff fc 	st.w	r7[-4],r8

  if (baudDiv <= 0 || baudDiv > 255) {
800070bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070c0:	58 08       	cp.w	r8,0
800070c2:	e0 8a 00 08 	brle	800070d2 <getBaudDiv+0x46>
800070c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070ca:	e0 48 00 ff 	cp.w	r8,255
800070ce:	e0 8a 00 04 	brle	800070d6 <getBaudDiv+0x4a>
    return -1;
800070d2:	3f f8       	mov	r8,-1
800070d4:	c0 38       	rjmp	800070da <getBaudDiv+0x4e>
  }

  return baudDiv;
800070d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800070da:	10 9c       	mov	r12,r8
800070dc:	2f dd       	sub	sp,-12
800070de:	e3 cd 80 80 	ldm	sp++,r7,pc

800070e2 <spi_initMaster>:
  return SPI_OK;
}


spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
800070e2:	eb cd 40 80 	pushm	r7,lr
800070e6:	1a 97       	mov	r7,sp
800070e8:	20 3d       	sub	sp,12
800070ea:	ef 4c ff f8 	st.w	r7[-8],r12
800070ee:	ef 4b ff f4 	st.w	r7[-12],r11
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
800070f2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800070f6:	f1 39 00 0d 	ld.ub	r9,r8[13]
800070fa:	30 18       	mov	r8,1
800070fc:	f0 09 18 00 	cp.b	r9,r8
80007100:	e0 88 00 04 	brls	80007108 <spi_initMaster+0x26>
    return SPI_ERROR_ARGUMENT;
80007104:	30 28       	mov	r8,2
80007106:	c3 48       	rjmp	8000716e <spi_initMaster+0x8c>
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80007108:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000710c:	e0 69 00 80 	mov	r9,128
80007110:	91 09       	st.w	r8[0x0],r9

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80007112:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007116:	70 18       	ld.w	r8,r8[0x4]
80007118:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.mstr = 1;
8000711c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007120:	30 19       	mov	r9,1
80007122:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80007126:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000712a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000712e:	f1 38 00 0d 	ld.ub	r8,r8[13]
80007132:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007136:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000713a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000713e:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
80007142:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.llb = 0;
80007146:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000714a:	30 09       	mov	r9,0
8000714c:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
80007150:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80007154:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007158:	30 f9       	mov	r9,15
8000715a:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
8000715e:	ef 48 ff fc 	st.w	r7[-4],r8
  spi->mr = u_avr32_spi_mr.mr;
80007162:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007166:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000716a:	91 19       	st.w	r8[0x4],r9

  return SPI_OK;
8000716c:	30 08       	mov	r8,0
}
8000716e:	10 9c       	mov	r12,r8
80007170:	2f dd       	sub	sp,-12
80007172:	e3 cd 80 80 	ldm	sp++,r7,pc

80007176 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80007176:	eb cd 40 80 	pushm	r7,lr
8000717a:	1a 97       	mov	r7,sp
8000717c:	20 5d       	sub	sp,20
8000717e:	ef 4c ff f8 	st.w	r7[-8],r12
80007182:	12 98       	mov	r8,r9
80007184:	16 99       	mov	r9,r11
80007186:	ef 69 ff f4 	st.b	r7[-12],r9
8000718a:	14 99       	mov	r9,r10
8000718c:	ef 69 ff f0 	st.b	r7[-16],r9
80007190:	ef 68 ff ec 	st.b	r7[-20],r8
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80007194:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80007198:	30 18       	mov	r8,1
8000719a:	f0 09 18 00 	cp.b	r9,r8
8000719e:	e0 8b 00 09 	brhi	800071b0 <spi_selectionMode+0x3a>
800071a2:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800071a6:	30 18       	mov	r8,1
800071a8:	f0 09 18 00 	cp.b	r9,r8
800071ac:	e0 88 00 04 	brls	800071b4 <spi_selectionMode+0x3e>
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
800071b0:	30 28       	mov	r8,2
800071b2:	c2 88       	rjmp	80007202 <spi_selectionMode+0x8c>
  }

  u_avr32_spi_mr.mr = spi->mr;
800071b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800071b8:	70 18       	ld.w	r8,r8[0x4]
800071ba:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.ps = variable_ps;
800071be:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800071c2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071c6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800071ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071ce:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800071d2:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800071d6:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800071da:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071de:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800071e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071e6:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
800071ea:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.dlybcs = delay;
800071ee:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800071f2:	ef 68 ff fc 	st.b	r7[-4],r8
  spi->mr = u_avr32_spi_mr.mr;
800071f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800071fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800071fe:	91 19       	st.w	r8[0x4],r9

  return SPI_OK;
80007200:	30 08       	mov	r8,0
}
80007202:	10 9c       	mov	r12,r8
80007204:	2f bd       	sub	sp,-20
80007206:	e3 cd 80 80 	ldm	sp++,r7,pc

8000720a <spi_selectChip>:


spi_status_t spi_selectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
8000720a:	eb cd 40 80 	pushm	r7,lr
8000720e:	1a 97       	mov	r7,sp
80007210:	20 2d       	sub	sp,8
80007212:	ef 4c ff fc 	st.w	r7[-4],r12
80007216:	16 98       	mov	r8,r11
80007218:	ef 68 ff f8 	st.b	r7[-8],r8
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000721c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007220:	70 18       	ld.w	r8,r8[0x4]
80007222:	10 99       	mov	r9,r8
80007224:	ea 19 00 0f 	orh	r9,0xf
80007228:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000722c:	91 19       	st.w	r8[0x4],r9

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000722e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007232:	70 18       	ld.w	r8,r8[0x4]
80007234:	e2 18 00 04 	andl	r8,0x4,COH
80007238:	c1 90       	breq	8000726a <spi_selectChip+0x60>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
8000723a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000723e:	30 e8       	mov	r8,14
80007240:	f0 09 18 00 	cp.b	r9,r8
80007244:	e0 88 00 04 	brls	8000724c <spi_selectChip+0x42>
      return SPI_ERROR_ARGUMENT;
80007248:	30 28       	mov	r8,2
8000724a:	c2 88       	rjmp	8000729a <spi_selectChip+0x90>
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
8000724c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007250:	70 19       	ld.w	r9,r8[0x4]
80007252:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80007256:	b1 68       	lsl	r8,0x10
80007258:	ea 18 ff f0 	orh	r8,0xfff0
8000725c:	e8 18 ff ff 	orl	r8,0xffff
80007260:	10 69       	and	r9,r8
80007262:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007266:	91 19       	st.w	r8[0x4],r9
80007268:	c1 88       	rjmp	80007298 <spi_selectChip+0x8e>
  } else {
    if (chip > 3) {
8000726a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000726e:	30 38       	mov	r8,3
80007270:	f0 09 18 00 	cp.b	r9,r8
80007274:	e0 88 00 04 	brls	8000727c <spi_selectChip+0x72>
      return SPI_ERROR_ARGUMENT;
80007278:	30 28       	mov	r8,2
8000727a:	c1 08       	rjmp	8000729a <spi_selectChip+0x90>
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000727c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007280:	70 19       	ld.w	r9,r8[0x4]
80007282:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80007286:	2f 08       	sub	r8,-16
80007288:	30 1a       	mov	r10,1
8000728a:	f4 08 09 48 	lsl	r8,r10,r8
8000728e:	5c d8       	com	r8
80007290:	10 69       	and	r9,r8
80007292:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007296:	91 19       	st.w	r8[0x4],r9
  }

  return SPI_OK;
80007298:	30 08       	mov	r8,0
}
8000729a:	10 9c       	mov	r12,r8
8000729c:	2f ed       	sub	sp,-8
8000729e:	e3 cd 80 80 	ldm	sp++,r7,pc

800072a2 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
800072a2:	eb cd 40 80 	pushm	r7,lr
800072a6:	1a 97       	mov	r7,sp
800072a8:	20 3d       	sub	sp,12
800072aa:	ef 4c ff f8 	st.w	r7[-8],r12
800072ae:	16 98       	mov	r8,r11
800072b0:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned int timeout = SPI_TIMEOUT;
800072b4:	e0 68 27 10 	mov	r8,10000
800072b8:	ef 48 ff fc 	st.w	r7[-4],r8

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800072bc:	c0 f8       	rjmp	800072da <spi_unselectChip+0x38>
    if (!timeout--) {
800072be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800072c2:	58 08       	cp.w	r8,0
800072c4:	5f 08       	sreq	r8
800072c6:	5c 58       	castu.b	r8
800072c8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800072cc:	20 19       	sub	r9,1
800072ce:	ef 49 ff fc 	st.w	r7[-4],r9
800072d2:	58 08       	cp.w	r8,0
800072d4:	c0 30       	breq	800072da <spi_unselectChip+0x38>
      return SPI_ERROR_TIMEOUT;
800072d6:	30 18       	mov	r8,1
800072d8:	c1 68       	rjmp	80007304 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800072da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072de:	70 48       	ld.w	r8,r8[0x10]
800072e0:	e2 18 02 00 	andl	r8,0x200,COH
800072e4:	ce d0       	breq	800072be <spi_unselectChip+0x1c>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
800072e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072ea:	70 18       	ld.w	r8,r8[0x4]
800072ec:	10 99       	mov	r9,r8
800072ee:	ea 19 00 0f 	orh	r9,0xf
800072f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072f6:	91 19       	st.w	r8[0x4],r9

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800072f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072fc:	fc 19 01 00 	movh	r9,0x100
80007300:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
  xSemaphoreGive(xSPIMutex);
#endif

  return SPI_OK;
80007302:	30 08       	mov	r8,0
}
80007304:	10 9c       	mov	r12,r8
80007306:	2f dd       	sub	sp,-12
80007308:	e3 cd 80 80 	ldm	sp++,r7,pc

8000730c <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
8000730c:	eb cd 40 80 	pushm	r7,lr
80007310:	1a 97       	mov	r7,sp
80007312:	20 5d       	sub	sp,20
80007314:	ef 4c ff f4 	st.w	r7[-12],r12
80007318:	ef 4b ff f0 	st.w	r7[-16],r11
8000731c:	ef 4a ff ec 	st.w	r7[-20],r10
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007320:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007324:	f1 39 00 0c 	ld.ub	r9,r8[12]
80007328:	30 38       	mov	r8,3
8000732a:	f0 09 18 00 	cp.b	r9,r8
8000732e:	e0 8b 00 1d 	brhi	80007368 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
80007332:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007336:	f1 39 00 0b 	ld.ub	r9,r8[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
8000733a:	30 18       	mov	r8,1
8000733c:	f0 09 18 00 	cp.b	r9,r8
80007340:	e0 8b 00 14 	brhi	80007368 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80007344:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007348:	f1 39 00 08 	ld.ub	r9,r8[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
8000734c:	30 78       	mov	r8,7
8000734e:	f0 09 18 00 	cp.b	r9,r8
80007352:	e0 88 00 0b 	brls	80007368 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80007356:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000735a:	f1 39 00 08 	ld.ub	r9,r8[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
8000735e:	31 08       	mov	r8,16
80007360:	f0 09 18 00 	cp.b	r9,r8
80007364:	e0 88 00 04 	brls	8000736c <spi_setupChipReg+0x60>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
    return SPI_ERROR_ARGUMENT;
80007368:	30 28       	mov	r8,2
8000736a:	c8 b8       	rjmp	80007480 <spi_setupChipReg+0x174>
  }

  int baudDiv = getBaudDiv(options, pba_hz);
8000736c:	ee fb ff ec 	ld.w	r11,r7[-20]
80007370:	ee fc ff f0 	ld.w	r12,r7[-16]
80007374:	f0 1f 00 45 	mcall	80007488 <spi_setupChipReg+0x17c>
80007378:	18 98       	mov	r8,r12
8000737a:	ef 48 ff fc 	st.w	r7[-4],r8

  if (baudDiv < 0) {
8000737e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007382:	58 08       	cp.w	r8,0
80007384:	c0 34       	brge	8000738a <spi_setupChipReg+0x7e>
    return SPI_ERROR_ARGUMENT;
80007386:	30 28       	mov	r8,2
80007388:	c7 c8       	rjmp	80007480 <spi_setupChipReg+0x174>
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
8000738a:	30 08       	mov	r8,0
8000738c:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80007390:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007394:	f1 38 00 0c 	ld.ub	r8,r8[12]
80007398:	a1 98       	lsr	r8,0x1
8000739a:	5c 58       	castu.b	r8
8000739c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073a0:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800073a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800073a8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800073ac:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
800073b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073b4:	f1 38 00 0c 	ld.ub	r8,r8[12]
800073b8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073bc:	5f 08       	sreq	r8
800073be:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800073c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800073c6:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800073ca:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
800073ce:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073d2:	f1 38 00 0b 	ld.ub	r8,r8[11]
800073d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073da:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800073de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800073e2:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
800073e6:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
800073ea:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073ee:	f1 38 00 08 	ld.ub	r8,r8[8]
800073f2:	20 88       	sub	r8,8
800073f4:	5c 58       	castu.b	r8
800073f6:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800073fa:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800073fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007402:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
80007406:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.scbr = baudDiv;
8000740a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000740e:	5c 58       	castu.b	r8
80007410:	ef 68 ff fa 	st.b	r7[-6],r8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80007414:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007418:	f1 38 00 09 	ld.ub	r8,r8[9]
8000741c:	ef 68 ff f9 	st.b	r7[-7],r8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80007420:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007424:	f1 38 00 0a 	ld.ub	r8,r8[10]
80007428:	ef 68 ff f8 	st.b	r7[-8],r8

  switch(options->reg) {
8000742c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007430:	11 88       	ld.ub	r8,r8[0x0]
80007432:	58 18       	cp.w	r8,1
80007434:	c1 10       	breq	80007456 <spi_setupChipReg+0x14a>
80007436:	e0 89 00 05 	brgt	80007440 <spi_setupChipReg+0x134>
8000743a:	58 08       	cp.w	r8,0
8000743c:	c0 70       	breq	8000744a <spi_setupChipReg+0x13e>
8000743e:	c1 e8       	rjmp	8000747a <spi_setupChipReg+0x16e>
80007440:	58 28       	cp.w	r8,2
80007442:	c1 00       	breq	80007462 <spi_setupChipReg+0x156>
80007444:	58 38       	cp.w	r8,3
80007446:	c1 40       	breq	8000746e <spi_setupChipReg+0x162>
80007448:	c1 98       	rjmp	8000747a <spi_setupChipReg+0x16e>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
8000744a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000744e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007452:	91 c9       	st.w	r8[0x30],r9
      break;
80007454:	c1 58       	rjmp	8000747e <spi_setupChipReg+0x172>
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80007456:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000745a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000745e:	91 d9       	st.w	r8[0x34],r9
      break;
80007460:	c0 f8       	rjmp	8000747e <spi_setupChipReg+0x172>
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80007462:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007466:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000746a:	91 e9       	st.w	r8[0x38],r9
      break;
8000746c:	c0 98       	rjmp	8000747e <spi_setupChipReg+0x172>
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
8000746e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007472:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007476:	91 f9       	st.w	r8[0x3c],r9
      break;
80007478:	c0 38       	rjmp	8000747e <spi_setupChipReg+0x172>
    default:
      return SPI_ERROR_ARGUMENT;
8000747a:	30 28       	mov	r8,2
8000747c:	c0 28       	rjmp	80007480 <spi_setupChipReg+0x174>
      while(1);
    }
  }
#endif

  return SPI_OK;
8000747e:	30 08       	mov	r8,0
}
80007480:	10 9c       	mov	r12,r8
80007482:	2f bd       	sub	sp,-20
80007484:	e3 cd 80 80 	ldm	sp++,r7,pc
80007488:	80 00       	ld.sh	r0,r0[0x0]
8000748a:	70 8c       	ld.w	r12,r8[0x20]

8000748c <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
8000748c:	eb cd 40 80 	pushm	r7,lr
80007490:	1a 97       	mov	r7,sp
80007492:	20 1d       	sub	sp,4
80007494:	ef 4c ff fc 	st.w	r7[-4],r12
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80007498:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000749c:	30 19       	mov	r9,1
8000749e:	91 09       	st.w	r8[0x0],r9
}
800074a0:	2f fd       	sub	sp,-4
800074a2:	e3 cd 80 80 	ldm	sp++,r7,pc

800074a6 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
800074a6:	eb cd 40 80 	pushm	r7,lr
800074aa:	1a 97       	mov	r7,sp
800074ac:	20 3d       	sub	sp,12
800074ae:	ef 4c ff f8 	st.w	r7[-8],r12
800074b2:	16 98       	mov	r8,r11
800074b4:	ef 58 ff f4 	st.h	r7[-12],r8
  unsigned int timeout = SPI_TIMEOUT;
800074b8:	e0 68 27 10 	mov	r8,10000
800074bc:	ef 48 ff fc 	st.w	r7[-4],r8

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800074c0:	c0 f8       	rjmp	800074de <spi_write+0x38>
    if (!timeout--) {
800074c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074c6:	58 08       	cp.w	r8,0
800074c8:	5f 08       	sreq	r8
800074ca:	5c 58       	castu.b	r8
800074cc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800074d0:	20 19       	sub	r9,1
800074d2:	ef 49 ff fc 	st.w	r7[-4],r9
800074d6:	58 08       	cp.w	r8,0
800074d8:	c0 30       	breq	800074de <spi_write+0x38>
      return SPI_ERROR_TIMEOUT;
800074da:	30 18       	mov	r8,1
800074dc:	c0 d8       	rjmp	800074f6 <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800074de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800074e2:	70 48       	ld.w	r8,r8[0x10]
800074e4:	e2 18 00 02 	andl	r8,0x2,COH
800074e8:	ce d0       	breq	800074c2 <spi_write+0x1c>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800074ea:	ef 19 ff f4 	ld.uh	r9,r7[-12]
800074ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800074f2:	91 39       	st.w	r8[0xc],r9

  return SPI_OK;
800074f4:	30 08       	mov	r8,0
}
800074f6:	10 9c       	mov	r12,r8
800074f8:	2f dd       	sub	sp,-12
800074fa:	e3 cd 80 80 	ldm	sp++,r7,pc

800074fe <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
800074fe:	eb cd 40 80 	pushm	r7,lr
80007502:	1a 97       	mov	r7,sp
80007504:	20 3d       	sub	sp,12
80007506:	ef 4c ff f8 	st.w	r7[-8],r12
8000750a:	ef 4b ff f4 	st.w	r7[-12],r11
  unsigned int timeout = SPI_TIMEOUT;
8000750e:	e0 68 27 10 	mov	r8,10000
80007512:	ef 48 ff fc 	st.w	r7[-4],r8

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80007516:	c0 f8       	rjmp	80007534 <spi_read+0x36>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80007518:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000751c:	58 08       	cp.w	r8,0
8000751e:	5f 08       	sreq	r8
80007520:	5c 58       	castu.b	r8
80007522:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007526:	20 19       	sub	r9,1
80007528:	ef 49 ff fc 	st.w	r7[-4],r9
8000752c:	58 08       	cp.w	r8,0
8000752e:	c0 30       	breq	80007534 <spi_read+0x36>
      return SPI_ERROR_TIMEOUT;
80007530:	30 18       	mov	r8,1
80007532:	c1 18       	rjmp	80007554 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80007534:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007538:	70 48       	ld.w	r8,r8[0x10]
8000753a:	e2 18 02 01 	andl	r8,0x201,COH
8000753e:	e0 48 02 01 	cp.w	r8,513
80007542:	ce b1       	brne	80007518 <spi_read+0x1a>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80007544:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007548:	70 28       	ld.w	r8,r8[0x8]
8000754a:	5c 88       	casts.h	r8
8000754c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007550:	b2 08       	st.h	r9[0x0],r8

  return SPI_OK;
80007552:	30 08       	mov	r8,0
}
80007554:	10 9c       	mov	r12,r8
80007556:	2f dd       	sub	sp,-12
80007558:	e3 cd 80 80 	ldm	sp++,r7,pc

8000755c <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
8000755c:	eb cd 40 80 	pushm	r7,lr
80007560:	1a 97       	mov	r7,sp
80007562:	20 1d       	sub	sp,4
80007564:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80007568:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000756c:	e6 18 00 01 	andh	r8,0x1,COH
80007570:	5f 08       	sreq	r8
80007572:	5c 58       	castu.b	r8
}
80007574:	10 9c       	mov	r12,r8
80007576:	2f fd       	sub	sp,-4
80007578:	e3 cd 80 80 	ldm	sp++,r7,pc

8000757c <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
8000757c:	eb cd 40 80 	pushm	r7,lr
80007580:	1a 97       	mov	r7,sp
80007582:	20 4d       	sub	sp,16
80007584:	ef 4c ff f8 	st.w	r7[-8],r12
80007588:	ef 4b ff f4 	st.w	r7[-12],r11
8000758c:	ef 4a ff f0 	st.w	r7[-16],r10
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80007590:	e1 b8 00 00 	mfsr	r8,0x0
80007594:	10 9c       	mov	r12,r8
80007596:	f0 1f 00 73 	mcall	80007760 <tc_configure_interrupts+0x1e4>
8000759a:	18 98       	mov	r8,r12
8000759c:	ef 68 ff ff 	st.b	r7[-1],r8

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800075a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800075a4:	58 28       	cp.w	r8,2
800075a6:	e0 88 00 04 	brls	800075ae <tc_configure_interrupts+0x32>
    return TC_INVALID_ARGUMENT;
800075aa:	3f f8       	mov	r8,-1
800075ac:	cd 68       	rjmp	80007758 <tc_configure_interrupts+0x1dc>

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800075ae:	ee fb ff f4 	ld.w	r11,r7[-12]
800075b2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800075b6:	70 08       	ld.w	r8,r8[0x0]
800075b8:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800075bc:	5c 58       	castu.b	r8
800075be:	f0 09 15 07 	lsl	r9,r8,0x7
                             bitfield->ldrbs << AVR32_TC_LDRBS_OFFSET |
800075c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800075c6:	70 08       	ld.w	r8,r8[0x0]
800075c8:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800075cc:	5c 58       	castu.b	r8
800075ce:	a7 68       	lsl	r8,0x6
800075d0:	10 49       	or	r9,r8
                             bitfield->ldras << AVR32_TC_LDRAS_OFFSET |
800075d2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800075d6:	70 08       	ld.w	r8,r8[0x0]
800075d8:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800075dc:	5c 58       	castu.b	r8
800075de:	a5 78       	lsl	r8,0x5
800075e0:	10 49       	or	r9,r8
                             bitfield->cpcs << AVR32_TC_CPCS_OFFSET |
800075e2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800075e6:	70 08       	ld.w	r8,r8[0x0]
800075e8:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800075ec:	5c 58       	castu.b	r8
800075ee:	a5 68       	lsl	r8,0x4
800075f0:	10 49       	or	r9,r8
                             bitfield->cpbs << AVR32_TC_CPBS_OFFSET |
800075f2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800075f6:	70 08       	ld.w	r8,r8[0x0]
800075f8:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800075fc:	5c 58       	castu.b	r8
800075fe:	a3 78       	lsl	r8,0x3
80007600:	10 49       	or	r9,r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
80007602:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007606:	70 08       	ld.w	r8,r8[0x0]
80007608:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
8000760c:	5c 58       	castu.b	r8
8000760e:	a3 68       	lsl	r8,0x2
80007610:	10 49       	or	r9,r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
80007612:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007616:	70 08       	ld.w	r8,r8[0x0]
80007618:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000761c:	5c 58       	castu.b	r8
8000761e:	a1 78       	lsl	r8,0x1
80007620:	10 49       	or	r9,r8
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;
80007622:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007626:	70 08       	ld.w	r8,r8[0x0]
80007628:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000762c:	5c 58       	castu.b	r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
8000762e:	f3 e8 10 08 	or	r8,r9,r8
80007632:	10 99       	mov	r9,r8
80007634:	ee fa ff f8 	ld.w	r10,r7[-8]
80007638:	f6 08 15 06 	lsl	r8,r11,0x6
8000763c:	f4 08 00 08 	add	r8,r10,r8
80007640:	2d c8       	sub	r8,-36
80007642:	91 09       	st.w	r8[0x0],r9
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80007644:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007648:	30 08       	mov	r8,0
8000764a:	f0 09 18 00 	cp.b	r9,r8
8000764e:	c0 20       	breq	80007652 <tc_configure_interrupts+0xd6>
80007650:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80007652:	ee fb ff f4 	ld.w	r11,r7[-12]
80007656:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000765a:	70 08       	ld.w	r8,r8[0x0]
8000765c:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80007660:	5c 58       	castu.b	r8
80007662:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007666:	c0 41       	brne	8000766e <tc_configure_interrupts+0xf2>
80007668:	e0 69 00 80 	mov	r9,128
8000766c:	c0 28       	rjmp	80007670 <tc_configure_interrupts+0xf4>
8000766e:	30 09       	mov	r9,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80007670:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007674:	70 08       	ld.w	r8,r8[0x0]
80007676:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
8000767a:	5c 58       	castu.b	r8
8000767c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007680:	c0 31       	brne	80007686 <tc_configure_interrupts+0x10a>
80007682:	34 08       	mov	r8,64
80007684:	c0 28       	rjmp	80007688 <tc_configure_interrupts+0x10c>
80007686:	30 08       	mov	r8,0
80007688:	10 49       	or	r9,r8
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000768a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000768e:	70 08       	ld.w	r8,r8[0x0]
80007690:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80007694:	5c 58       	castu.b	r8
80007696:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000769a:	c0 31       	brne	800076a0 <tc_configure_interrupts+0x124>
8000769c:	32 08       	mov	r8,32
8000769e:	c0 28       	rjmp	800076a2 <tc_configure_interrupts+0x126>
800076a0:	30 08       	mov	r8,0
800076a2:	10 49       	or	r9,r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800076a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800076a8:	70 08       	ld.w	r8,r8[0x0]
800076aa:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800076ae:	5c 58       	castu.b	r8
800076b0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076b4:	c0 31       	brne	800076ba <tc_configure_interrupts+0x13e>
800076b6:	31 08       	mov	r8,16
800076b8:	c0 28       	rjmp	800076bc <tc_configure_interrupts+0x140>
800076ba:	30 08       	mov	r8,0
800076bc:	10 49       	or	r9,r8
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800076be:	ee f8 ff f0 	ld.w	r8,r7[-16]
800076c2:	70 08       	ld.w	r8,r8[0x0]
800076c4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800076c8:	5c 58       	castu.b	r8
800076ca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076ce:	c0 31       	brne	800076d4 <tc_configure_interrupts+0x158>
800076d0:	30 88       	mov	r8,8
800076d2:	c0 28       	rjmp	800076d6 <tc_configure_interrupts+0x15a>
800076d4:	30 08       	mov	r8,0
800076d6:	10 49       	or	r9,r8
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800076d8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800076dc:	70 08       	ld.w	r8,r8[0x0]
800076de:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800076e2:	5c 58       	castu.b	r8
800076e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076e8:	c0 31       	brne	800076ee <tc_configure_interrupts+0x172>
800076ea:	30 48       	mov	r8,4
800076ec:	c0 28       	rjmp	800076f0 <tc_configure_interrupts+0x174>
800076ee:	30 08       	mov	r8,0
800076f0:	10 49       	or	r9,r8
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800076f2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800076f6:	70 08       	ld.w	r8,r8[0x0]
800076f8:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800076fc:	5c 58       	castu.b	r8
800076fe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007702:	c0 31       	brne	80007708 <tc_configure_interrupts+0x18c>
80007704:	30 28       	mov	r8,2
80007706:	c0 28       	rjmp	8000770a <tc_configure_interrupts+0x18e>
80007708:	30 08       	mov	r8,0
8000770a:	10 49       	or	r9,r8
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
8000770c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007710:	70 08       	ld.w	r8,r8[0x0]
80007712:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007716:	5c 58       	castu.b	r8
80007718:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000771c:	5f 08       	sreq	r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000771e:	f3 e8 10 08 	or	r8,r9,r8
80007722:	10 99       	mov	r9,r8
80007724:	ee fa ff f8 	ld.w	r10,r7[-8]
80007728:	f6 08 15 06 	lsl	r8,r11,0x6
8000772c:	f4 08 00 08 	add	r8,r10,r8
80007730:	2d 88       	sub	r8,-40
80007732:	91 09       	st.w	r8[0x0],r9
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80007734:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007738:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000773c:	a1 78       	lsl	r8,0x1
8000773e:	2f f8       	sub	r8,-1
80007740:	a5 78       	lsl	r8,0x5
80007742:	f2 08 00 08 	add	r8,r9,r8
80007746:	70 08       	ld.w	r8,r8[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80007748:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000774c:	30 08       	mov	r8,0
8000774e:	f0 09 18 00 	cp.b	r9,r8
80007752:	c0 20       	breq	80007756 <tc_configure_interrupts+0x1da>
80007754:	d5 03       	csrf	0x10

  return 0;
80007756:	30 08       	mov	r8,0
}
80007758:	10 9c       	mov	r12,r8
8000775a:	2f cd       	sub	sp,-16
8000775c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007760:	80 00       	ld.sh	r0,r0[0x0]
80007762:	75 5c       	ld.w	r12,r10[0x54]

80007764 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
80007764:	eb cd 40 80 	pushm	r7,lr
80007768:	1a 97       	mov	r7,sp
8000776a:	20 2d       	sub	sp,8
8000776c:	ef 4c ff fc 	st.w	r7[-4],r12
80007770:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80007774:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007778:	70 08       	ld.w	r8,r8[0x0]
8000777a:	58 28       	cp.w	r8,2
8000777c:	e0 88 00 04 	brls	80007784 <tc_init_waveform+0x20>
    return TC_INVALID_ARGUMENT;
80007780:	3f f8       	mov	r8,-1
80007782:	c9 78       	rjmp	800078b0 <tc_init_waveform+0x14c>

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80007784:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007788:	70 09       	ld.w	r9,r8[0x0]
8000778a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000778e:	70 18       	ld.w	r8,r8[0x4]
80007790:	f1 d8 c3 c2 	bfextu	r8,r8,0x1e,0x2
80007794:	5c 58       	castu.b	r8
80007796:	f0 0a 15 1e 	lsl	r10,r8,0x1e
                                  opt->beevt << AVR32_TC_BEEVT_OFFSET |
8000779a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000779e:	70 18       	ld.w	r8,r8[0x4]
800077a0:	f1 d8 c3 82 	bfextu	r8,r8,0x1c,0x2
800077a4:	5c 58       	castu.b	r8
800077a6:	bd 68       	lsl	r8,0x1c
800077a8:	10 4a       	or	r10,r8
                                  opt->bcpc << AVR32_TC_BCPC_OFFSET |
800077aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077ae:	70 18       	ld.w	r8,r8[0x4]
800077b0:	f1 d8 c3 42 	bfextu	r8,r8,0x1a,0x2
800077b4:	5c 58       	castu.b	r8
800077b6:	bb 68       	lsl	r8,0x1a
800077b8:	10 4a       	or	r10,r8
                                  opt->bcpb << AVR32_TC_BCPB_OFFSET |
800077ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077be:	70 18       	ld.w	r8,r8[0x4]
800077c0:	f1 d8 c3 02 	bfextu	r8,r8,0x18,0x2
800077c4:	5c 58       	castu.b	r8
800077c6:	b9 68       	lsl	r8,0x18
800077c8:	10 4a       	or	r10,r8
                                  opt->aswtrg << AVR32_TC_ASWTRG_OFFSET |
800077ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077ce:	70 18       	ld.w	r8,r8[0x4]
800077d0:	f1 d8 c2 c2 	bfextu	r8,r8,0x16,0x2
800077d4:	5c 58       	castu.b	r8
800077d6:	b7 68       	lsl	r8,0x16
800077d8:	10 4a       	or	r10,r8
                                  opt->aeevt << AVR32_TC_AEEVT_OFFSET |
800077da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077de:	70 18       	ld.w	r8,r8[0x4]
800077e0:	f1 d8 c2 82 	bfextu	r8,r8,0x14,0x2
800077e4:	5c 58       	castu.b	r8
800077e6:	b5 68       	lsl	r8,0x14
800077e8:	10 4a       	or	r10,r8
                                  opt->acpc << AVR32_TC_ACPC_OFFSET |
800077ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077ee:	70 18       	ld.w	r8,r8[0x4]
800077f0:	f1 d8 c2 42 	bfextu	r8,r8,0x12,0x2
800077f4:	5c 58       	castu.b	r8
800077f6:	b3 68       	lsl	r8,0x12
800077f8:	10 4a       	or	r10,r8
                                  opt->acpa << AVR32_TC_ACPA_OFFSET |
800077fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077fe:	70 18       	ld.w	r8,r8[0x4]
80007800:	f1 d8 c2 02 	bfextu	r8,r8,0x10,0x2
80007804:	5c 58       	castu.b	r8
80007806:	b1 68       	lsl	r8,0x10
80007808:	f5 e8 10 08 	or	r8,r10,r8
                                  1 << AVR32_TC_WAVE_OFFSET |
8000780c:	10 9a       	mov	r10,r8
8000780e:	af ba       	sbr	r10,0xf
                                  opt->wavsel << AVR32_TC_WAVSEL_OFFSET |
80007810:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007814:	70 18       	ld.w	r8,r8[0x4]
80007816:	f1 d8 c1 a2 	bfextu	r8,r8,0xd,0x2
8000781a:	5c 58       	castu.b	r8
8000781c:	ad 78       	lsl	r8,0xd
8000781e:	10 4a       	or	r10,r8
                                  opt->enetrg << AVR32_TC_ENETRG_OFFSET |
80007820:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007824:	70 18       	ld.w	r8,r8[0x4]
80007826:	f1 d8 c1 81 	bfextu	r8,r8,0xc,0x1
8000782a:	5c 58       	castu.b	r8
8000782c:	ad 68       	lsl	r8,0xc
8000782e:	10 4a       	or	r10,r8
                                  opt->eevt << AVR32_TC_EEVT_OFFSET |
80007830:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007834:	70 18       	ld.w	r8,r8[0x4]
80007836:	f1 d8 c1 42 	bfextu	r8,r8,0xa,0x2
8000783a:	5c 58       	castu.b	r8
8000783c:	ab 68       	lsl	r8,0xa
8000783e:	10 4a       	or	r10,r8
                                  opt->eevtedg << AVR32_TC_EEVTEDG_OFFSET |
80007840:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007844:	70 18       	ld.w	r8,r8[0x4]
80007846:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
8000784a:	5c 58       	castu.b	r8
8000784c:	a9 68       	lsl	r8,0x8
8000784e:	10 4a       	or	r10,r8
                                  opt->cpcdis << AVR32_TC_CPCDIS_OFFSET |
80007850:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007854:	70 18       	ld.w	r8,r8[0x4]
80007856:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
8000785a:	5c 58       	castu.b	r8
8000785c:	a7 78       	lsl	r8,0x7
8000785e:	10 4a       	or	r10,r8
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
80007860:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007864:	70 18       	ld.w	r8,r8[0x4]
80007866:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
8000786a:	5c 58       	castu.b	r8
8000786c:	a7 68       	lsl	r8,0x6
8000786e:	10 4a       	or	r10,r8
                                  opt->burst << AVR32_TC_BURST_OFFSET |
80007870:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007874:	70 18       	ld.w	r8,r8[0x4]
80007876:	f1 d8 c0 82 	bfextu	r8,r8,0x4,0x2
8000787a:	5c 58       	castu.b	r8
8000787c:	a5 68       	lsl	r8,0x4
8000787e:	10 4a       	or	r10,r8
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
80007880:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007884:	70 18       	ld.w	r8,r8[0x4]
80007886:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000788a:	5c 58       	castu.b	r8
8000788c:	a3 78       	lsl	r8,0x3
8000788e:	10 4a       	or	r10,r8
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;
80007890:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007894:	70 18       	ld.w	r8,r8[0x4]
80007896:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000789a:	5c 58       	castu.b	r8
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000789c:	f5 e8 10 08 	or	r8,r10,r8
800078a0:	10 9a       	mov	r10,r8
800078a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800078a6:	a5 69       	lsl	r9,0x4
800078a8:	2f f9       	sub	r9,-1
800078aa:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
                                  opt->burst << AVR32_TC_BURST_OFFSET |
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;

  return 0;
800078ae:	30 08       	mov	r8,0
}
800078b0:	10 9c       	mov	r12,r8
800078b2:	2f ed       	sub	sp,-8
800078b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800078b8 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
800078b8:	eb cd 40 80 	pushm	r7,lr
800078bc:	1a 97       	mov	r7,sp
800078be:	20 2d       	sub	sp,8
800078c0:	ef 4c ff fc 	st.w	r7[-4],r12
800078c4:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800078c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800078cc:	58 28       	cp.w	r8,2
800078ce:	e0 88 00 04 	brls	800078d6 <tc_start+0x1e>
    return TC_INVALID_ARGUMENT;
800078d2:	3f f8       	mov	r8,-1
800078d4:	c0 b8       	rjmp	800078ea <tc_start+0x32>

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800078d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800078da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800078de:	a7 68       	lsl	r8,0x6
800078e0:	f2 08 00 08 	add	r8,r9,r8
800078e4:	30 59       	mov	r9,5
800078e6:	91 09       	st.w	r8[0x0],r9

  return 0;
800078e8:	30 08       	mov	r8,0
}
800078ea:	10 9c       	mov	r12,r8
800078ec:	2f ed       	sub	sp,-8
800078ee:	e3 cd 80 80 	ldm	sp++,r7,pc

800078f2 <tc_read_sr>:
  tc->bcr = AVR32_TC_BCR_SYNC_MASK;
}


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
800078f2:	eb cd 40 80 	pushm	r7,lr
800078f6:	1a 97       	mov	r7,sp
800078f8:	20 2d       	sub	sp,8
800078fa:	ef 4c ff fc 	st.w	r7[-4],r12
800078fe:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80007902:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007906:	58 28       	cp.w	r8,2
80007908:	e0 88 00 04 	brls	80007910 <tc_read_sr+0x1e>
    return TC_INVALID_ARGUMENT;
8000790c:	3f f8       	mov	r8,-1
8000790e:	c0 b8       	rjmp	80007924 <tc_read_sr+0x32>

  return tc->channel[channel].sr;
80007910:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007914:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007918:	a1 78       	lsl	r8,0x1
8000791a:	2f f8       	sub	r8,-1
8000791c:	a5 78       	lsl	r8,0x5
8000791e:	f2 08 00 08 	add	r8,r9,r8
80007922:	70 08       	ld.w	r8,r8[0x0]
}
80007924:	10 9c       	mov	r12,r8
80007926:	2f ed       	sub	sp,-8
80007928:	e3 cd 80 80 	ldm	sp++,r7,pc

8000792c <tc_write_rc>:
  return value;
}


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
8000792c:	eb cd 40 80 	pushm	r7,lr
80007930:	1a 97       	mov	r7,sp
80007932:	20 3d       	sub	sp,12
80007934:	ef 4c ff fc 	st.w	r7[-4],r12
80007938:	ef 4b ff f8 	st.w	r7[-8],r11
8000793c:	14 98       	mov	r8,r10
8000793e:	ef 58 ff f4 	st.h	r7[-12],r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80007942:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007946:	58 28       	cp.w	r8,2
80007948:	e0 88 00 04 	brls	80007950 <tc_write_rc+0x24>
    return TC_INVALID_ARGUMENT;
8000794c:	3f f8       	mov	r8,-1
8000794e:	c2 78       	rjmp	8000799c <tc_write_rc+0x70>

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80007950:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007954:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007958:	a5 69       	lsl	r9,0x4
8000795a:	2f f9       	sub	r9,-1
8000795c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007960:	e2 18 80 00 	andl	r8,0x8000,COH
80007964:	c1 a0       	breq	80007998 <tc_write_rc+0x6c>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80007966:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000796a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000796e:	ee fa ff fc 	ld.w	r10,r7[-4]
80007972:	a7 69       	lsl	r9,0x6
80007974:	f4 09 00 09 	add	r9,r10,r9
80007978:	2e 49       	sub	r9,-28
8000797a:	72 09       	ld.w	r9,r9[0x0]
8000797c:	12 9a       	mov	r10,r9
8000797e:	e0 1a 00 00 	andl	r10,0x0
80007982:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80007986:	f5 e9 10 09 	or	r9,r10,r9
8000798a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000798e:	a7 68       	lsl	r8,0x6
80007990:	f4 08 00 08 	add	r8,r10,r8
80007994:	2e 48       	sub	r8,-28
80007996:	91 09       	st.w	r8[0x0],r9

  return value;
80007998:	ef 18 ff f4 	ld.uh	r8,r7[-12]
}
8000799c:	10 9c       	mov	r12,r8
8000799e:	2f dd       	sub	sp,-12
800079a0:	e3 cd 80 80 	ldm	sp++,r7,pc

800079a4 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800079a4:	eb cd 40 80 	pushm	r7,lr
800079a8:	1a 97       	mov	r7,sp
800079aa:	20 1d       	sub	sp,4
800079ac:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800079b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079b4:	e6 18 00 01 	andh	r8,0x1,COH
800079b8:	5f 08       	sreq	r8
800079ba:	5c 58       	castu.b	r8
}
800079bc:	10 9c       	mov	r12,r8
800079be:	2f fd       	sub	sp,-4
800079c0:	e3 cd 80 80 	ldm	sp++,r7,pc

800079c4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800079c4:	eb cd 40 80 	pushm	r7,lr
800079c8:	1a 97       	mov	r7,sp
800079ca:	20 7d       	sub	sp,28
800079cc:	ef 4c ff ec 	st.w	r7[-20],r12
800079d0:	ef 4b ff e8 	st.w	r7[-24],r11
800079d4:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800079d8:	ee f8 ff e8 	ld.w	r8,r7[-24]
800079dc:	f0 09 15 04 	lsl	r9,r8,0x4
800079e0:	ee f8 ff e4 	ld.w	r8,r7[-28]
800079e4:	10 39       	cp.w	r9,r8
800079e6:	e0 8b 00 04 	brhi	800079ee <usart_set_async_baudrate+0x2a>
800079ea:	31 08       	mov	r8,16
800079ec:	c0 28       	rjmp	800079f0 <usart_set_async_baudrate+0x2c>
800079ee:	30 88       	mov	r8,8
800079f0:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800079f4:	ee f8 ff e4 	ld.w	r8,r7[-28]
800079f8:	f0 09 15 03 	lsl	r9,r8,0x3
800079fc:	ee fa ff f0 	ld.w	r10,r7[-16]
80007a00:	ee f8 ff e8 	ld.w	r8,r7[-24]
80007a04:	f4 08 02 48 	mul	r8,r10,r8
80007a08:	a1 98       	lsr	r8,0x1
80007a0a:	f2 08 00 08 	add	r8,r9,r8
80007a0e:	ee fa ff f0 	ld.w	r10,r7[-16]
80007a12:	ee f9 ff e8 	ld.w	r9,r7[-24]
80007a16:	f4 09 02 49 	mul	r9,r10,r9
80007a1a:	f0 09 0d 08 	divu	r8,r8,r9
80007a1e:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80007a22:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007a26:	a3 98       	lsr	r8,0x3
80007a28:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80007a2c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007a30:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80007a34:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80007a38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a3c:	58 08       	cp.w	r8,0
80007a3e:	c0 70       	breq	80007a4c <usart_set_async_baudrate+0x88>
80007a40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a44:	e0 48 ff ff 	cp.w	r8,65535
80007a48:	e0 88 00 04 	brls	80007a50 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80007a4c:	30 18       	mov	r8,1
80007a4e:	c2 08       	rjmp	80007a8e <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80007a50:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007a54:	70 18       	ld.w	r8,r8[0x4]
80007a56:	10 99       	mov	r9,r8
80007a58:	e4 19 ff f7 	andh	r9,0xfff7
80007a5c:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80007a60:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a64:	59 08       	cp.w	r8,16
80007a66:	c0 40       	breq	80007a6e <usart_set_async_baudrate+0xaa>
80007a68:	e8 68 00 00 	mov	r8,524288
80007a6c:	c0 28       	rjmp	80007a70 <usart_set_async_baudrate+0xac>
80007a6e:	30 08       	mov	r8,0
80007a70:	10 49       	or	r9,r8
80007a72:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007a76:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80007a78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a7c:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80007a80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a84:	10 49       	or	r9,r8
80007a86:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007a8a:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80007a8c:	30 08       	mov	r8,0
}
80007a8e:	10 9c       	mov	r12,r8
80007a90:	2f 9d       	sub	sp,-28
80007a92:	e3 cd 80 80 	ldm	sp++,r7,pc
80007a96:	d7 03       	nop

80007a98 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80007a98:	eb cd 40 80 	pushm	r7,lr
80007a9c:	1a 97       	mov	r7,sp
80007a9e:	20 2d       	sub	sp,8
80007aa0:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80007aa4:	e1 b8 00 00 	mfsr	r8,0x0
80007aa8:	10 9c       	mov	r12,r8
80007aaa:	f0 1f 00 18 	mcall	80007b08 <usart_reset+0x70>
80007aae:	18 98       	mov	r8,r12
80007ab0:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80007ab4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007ab8:	30 08       	mov	r8,0
80007aba:	f0 09 18 00 	cp.b	r9,r8
80007abe:	c0 20       	breq	80007ac2 <usart_reset+0x2a>
80007ac0:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80007ac2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ac6:	3f f9       	mov	r9,-1
80007ac8:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80007aca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ace:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80007ad0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007ad4:	30 08       	mov	r8,0
80007ad6:	f0 09 18 00 	cp.b	r9,r8
80007ada:	c0 20       	breq	80007ade <usart_reset+0x46>
80007adc:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80007ade:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ae2:	30 09       	mov	r9,0
80007ae4:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80007ae6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007aea:	30 09       	mov	r9,0
80007aec:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80007aee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007af2:	30 09       	mov	r9,0
80007af4:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80007af6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007afa:	ea 69 61 0c 	mov	r9,680204
80007afe:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80007b00:	2f ed       	sub	sp,-8
80007b02:	e3 cd 80 80 	ldm	sp++,r7,pc
80007b06:	00 00       	add	r0,r0
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	79 a4       	ld.w	r4,r12[0x68]

80007b0c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80007b0c:	eb cd 40 80 	pushm	r7,lr
80007b10:	1a 97       	mov	r7,sp
80007b12:	20 3d       	sub	sp,12
80007b14:	ef 4c ff fc 	st.w	r7[-4],r12
80007b18:	ef 4b ff f8 	st.w	r7[-8],r11
80007b1c:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80007b20:	ee fc ff fc 	ld.w	r12,r7[-4]
80007b24:	f0 1f 00 54 	mcall	80007c74 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80007b28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b2c:	58 08       	cp.w	r8,0
80007b2e:	c3 90       	breq	80007ba0 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80007b30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b34:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007b36:	30 48       	mov	r8,4
80007b38:	f0 09 18 00 	cp.b	r9,r8
80007b3c:	e0 88 00 32 	brls	80007ba0 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80007b40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b44:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007b46:	30 98       	mov	r8,9
80007b48:	f0 09 18 00 	cp.b	r9,r8
80007b4c:	e0 8b 00 2a 	brhi	80007ba0 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80007b50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b54:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007b56:	30 78       	mov	r8,7
80007b58:	f0 09 18 00 	cp.b	r9,r8
80007b5c:	e0 8b 00 22 	brhi	80007ba0 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80007b60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b64:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007b66:	e0 68 01 01 	mov	r8,257
80007b6a:	f0 09 19 00 	cp.h	r9,r8
80007b6e:	e0 8b 00 19 	brhi	80007ba0 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80007b72:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b76:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007b7a:	30 38       	mov	r8,3
80007b7c:	f0 09 18 00 	cp.b	r9,r8
80007b80:	e0 8b 00 10 	brhi	80007ba0 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80007b84:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007b88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b8c:	70 08       	ld.w	r8,r8[0x0]
80007b8e:	12 9a       	mov	r10,r9
80007b90:	10 9b       	mov	r11,r8
80007b92:	ee fc ff fc 	ld.w	r12,r7[-4]
80007b96:	f0 1f 00 39 	mcall	80007c78 <usart_init_rs232+0x16c>
80007b9a:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007b9c:	58 18       	cp.w	r8,1
80007b9e:	c0 31       	brne	80007ba4 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80007ba0:	30 18       	mov	r8,1
80007ba2:	c6 48       	rjmp	80007c6a <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80007ba4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ba8:	11 c9       	ld.ub	r9,r8[0x4]
80007baa:	30 98       	mov	r8,9
80007bac:	f0 09 18 00 	cp.b	r9,r8
80007bb0:	c0 a1       	brne	80007bc4 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80007bb2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007bb6:	70 18       	ld.w	r8,r8[0x4]
80007bb8:	10 99       	mov	r9,r8
80007bba:	b1 b9       	sbr	r9,0x11
80007bbc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007bc0:	91 19       	st.w	r8[0x4],r9
80007bc2:	c0 d8       	rjmp	80007bdc <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80007bc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007bc8:	70 19       	ld.w	r9,r8[0x4]
80007bca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bce:	11 c8       	ld.ub	r8,r8[0x4]
80007bd0:	20 58       	sub	r8,5
80007bd2:	a7 68       	lsl	r8,0x6
80007bd4:	10 49       	or	r9,r8
80007bd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007bda:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80007bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007be0:	70 19       	ld.w	r9,r8[0x4]
80007be2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007be6:	11 d8       	ld.ub	r8,r8[0x5]
80007be8:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80007bec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bf0:	f1 38 00 08 	ld.ub	r8,r8[8]
80007bf4:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80007bf6:	f5 e8 10 08 	or	r8,r10,r8
80007bfa:	10 49       	or	r9,r8
80007bfc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c00:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80007c02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c06:	90 39       	ld.sh	r9,r8[0x6]
80007c08:	30 28       	mov	r8,2
80007c0a:	f0 09 19 00 	cp.h	r9,r8
80007c0e:	e0 88 00 14 	brls	80007c36 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80007c12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c16:	70 18       	ld.w	r8,r8[0x4]
80007c18:	10 99       	mov	r9,r8
80007c1a:	ad b9       	sbr	r9,0xd
80007c1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c20:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80007c22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c26:	90 38       	ld.sh	r8,r8[0x6]
80007c28:	5c 78       	castu.h	r8
80007c2a:	20 28       	sub	r8,2
80007c2c:	10 99       	mov	r9,r8
80007c2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c32:	91 a9       	st.w	r8[0x28],r9
80007c34:	c0 d8       	rjmp	80007c4e <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80007c36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c3a:	70 19       	ld.w	r9,r8[0x4]
80007c3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c40:	90 38       	ld.sh	r8,r8[0x6]
80007c42:	5c 78       	castu.h	r8
80007c44:	ad 68       	lsl	r8,0xc
80007c46:	10 49       	or	r9,r8
80007c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c4c:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80007c4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c52:	70 18       	ld.w	r8,r8[0x4]
80007c54:	10 99       	mov	r9,r8
80007c56:	e0 19 ff f0 	andl	r9,0xfff0
80007c5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c5e:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80007c60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c64:	35 09       	mov	r9,80
80007c66:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80007c68:	30 08       	mov	r8,0
}
80007c6a:	10 9c       	mov	r12,r8
80007c6c:	2f dd       	sub	sp,-12
80007c6e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007c72:	00 00       	add	r0,r0
80007c74:	80 00       	ld.sh	r0,r0[0x0]
80007c76:	7a 98       	ld.w	r8,sp[0x24]
80007c78:	80 00       	ld.sh	r0,r0[0x0]
80007c7a:	79 c4       	ld.w	r4,r12[0x70]

80007c7c <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80007c7c:	eb cd 40 80 	pushm	r7,lr
80007c80:	1a 97       	mov	r7,sp
80007c82:	20 3d       	sub	sp,12
80007c84:	ef 4c ff f8 	st.w	r7[-8],r12
80007c88:	ef 4b ff f4 	st.w	r7[-12],r11
80007c8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c90:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80007c94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c98:	70 58       	ld.w	r8,r8[0x14]
80007c9a:	e2 18 00 02 	andl	r8,0x2,COH
80007c9e:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80007ca0:	58 08       	cp.w	r8,0
80007ca2:	c0 a0       	breq	80007cb6 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80007ca4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007ca8:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80007cac:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cb0:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80007cb2:	30 08       	mov	r8,0
80007cb4:	c0 28       	rjmp	80007cb8 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80007cb6:	30 28       	mov	r8,2
}
80007cb8:	10 9c       	mov	r12,r8
80007cba:	2f dd       	sub	sp,-12
80007cbc:	e3 cd 80 80 	ldm	sp++,r7,pc

80007cc0 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80007cc0:	eb cd 40 80 	pushm	r7,lr
80007cc4:	1a 97       	mov	r7,sp
80007cc6:	20 3d       	sub	sp,12
80007cc8:	ef 4c ff f8 	st.w	r7[-8],r12
80007ccc:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80007cd0:	e0 68 27 10 	mov	r8,10000
80007cd4:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80007cd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007cdc:	58 08       	cp.w	r8,0
80007cde:	5f 08       	sreq	r8
80007ce0:	5c 58       	castu.b	r8
80007ce2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007ce6:	20 19       	sub	r9,1
80007ce8:	ef 49 ff fc 	st.w	r7[-4],r9
80007cec:	58 08       	cp.w	r8,0
80007cee:	c0 30       	breq	80007cf4 <usart_putchar+0x34>
80007cf0:	3f f8       	mov	r8,-1
80007cf2:	c0 b8       	rjmp	80007d08 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80007cf4:	ee fb ff f4 	ld.w	r11,r7[-12]
80007cf8:	ee fc ff f8 	ld.w	r12,r7[-8]
80007cfc:	f0 1f 00 05 	mcall	80007d10 <usart_putchar+0x50>
80007d00:	18 98       	mov	r8,r12
80007d02:	58 08       	cp.w	r8,0
80007d04:	ce a1       	brne	80007cd8 <usart_putchar+0x18>

  return USART_SUCCESS;
80007d06:	30 08       	mov	r8,0
}
80007d08:	10 9c       	mov	r12,r8
80007d0a:	2f dd       	sub	sp,-12
80007d0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d10:	80 00       	ld.sh	r0,r0[0x0]
80007d12:	7c 7c       	ld.w	r12,lr[0x1c]

80007d14 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80007d14:	eb cd 40 80 	pushm	r7,lr
80007d18:	1a 97       	mov	r7,sp
80007d1a:	20 3d       	sub	sp,12
80007d1c:	ef 4c ff f8 	st.w	r7[-8],r12
80007d20:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80007d24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d28:	70 58       	ld.w	r8,r8[0x14]
80007d2a:	e2 18 00 e0 	andl	r8,0xe0,COH
80007d2e:	c0 30       	breq	80007d34 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80007d30:	30 48       	mov	r8,4
80007d32:	c1 68       	rjmp	80007d5e <usart_read_char+0x4a>
80007d34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d38:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80007d3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007d40:	70 58       	ld.w	r8,r8[0x14]
80007d42:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80007d46:	c0 b0       	breq	80007d5c <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80007d48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d4c:	70 68       	ld.w	r8,r8[0x18]
80007d4e:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80007d52:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d56:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80007d58:	30 08       	mov	r8,0
80007d5a:	c0 28       	rjmp	80007d5e <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80007d5c:	30 38       	mov	r8,3
}
80007d5e:	10 9c       	mov	r12,r8
80007d60:	2f dd       	sub	sp,-12
80007d62:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d66:	d7 03       	nop

80007d68 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80007d68:	eb cd 40 80 	pushm	r7,lr
80007d6c:	1a 97       	mov	r7,sp
80007d6e:	20 3d       	sub	sp,12
80007d70:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80007d74:	ee c8 00 08 	sub	r8,r7,8
80007d78:	10 9b       	mov	r11,r8
80007d7a:	ee fc ff f4 	ld.w	r12,r7[-12]
80007d7e:	f0 1f 00 0b 	mcall	80007da8 <usart_getchar+0x40>
80007d82:	18 98       	mov	r8,r12
80007d84:	ef 48 ff fc 	st.w	r7[-4],r8
80007d88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007d8c:	58 38       	cp.w	r8,3
80007d8e:	cf 30       	breq	80007d74 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80007d90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007d94:	58 48       	cp.w	r8,4
80007d96:	c0 31       	brne	80007d9c <usart_getchar+0x34>
    return USART_FAILURE;
80007d98:	3f f8       	mov	r8,-1
80007d9a:	c0 38       	rjmp	80007da0 <usart_getchar+0x38>

  return c;
80007d9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80007da0:	10 9c       	mov	r12,r8
80007da2:	2f dd       	sub	sp,-12
80007da4:	e3 cd 80 80 	ldm	sp++,r7,pc
80007da8:	80 00       	ld.sh	r0,r0[0x0]
80007daa:	7d 14       	ld.w	r4,lr[0x44]

80007dac <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80007dac:	eb cd 40 80 	pushm	r7,lr
80007db0:	1a 97       	mov	r7,sp
80007db2:	20 2d       	sub	sp,8
80007db4:	ef 4c ff fc 	st.w	r7[-4],r12
80007db8:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80007dbc:	c0 e8       	rjmp	80007dd8 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80007dbe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007dc2:	11 88       	ld.ub	r8,r8[0x0]
80007dc4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007dc8:	2f f9       	sub	r9,-1
80007dca:	ef 49 ff f8 	st.w	r7[-8],r9
80007dce:	10 9b       	mov	r11,r8
80007dd0:	ee fc ff fc 	ld.w	r12,r7[-4]
80007dd4:	f0 1f 00 05 	mcall	80007de8 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80007dd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ddc:	11 88       	ld.ub	r8,r8[0x0]
80007dde:	58 08       	cp.w	r8,0
80007de0:	ce f1       	brne	80007dbe <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80007de2:	2f ed       	sub	sp,-8
80007de4:	e3 cd 80 80 	ldm	sp++,r7,pc
80007de8:	80 00       	ld.sh	r0,r0[0x0]
80007dea:	7c c0       	ld.w	r0,lr[0x30]

80007dec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80007dec:	eb cd 40 80 	pushm	r7,lr
80007df0:	1a 97       	mov	r7,sp
80007df2:	20 1d       	sub	sp,4
80007df4:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80007df8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007dfc:	2f 88       	sub	r8,-8
80007dfe:	10 99       	mov	r9,r8
80007e00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e04:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80007e06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e0a:	3f f9       	mov	r9,-1
80007e0c:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80007e0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e12:	2f 88       	sub	r8,-8
80007e14:	10 99       	mov	r9,r8
80007e16:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e1a:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80007e1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e20:	2f 88       	sub	r8,-8
80007e22:	10 99       	mov	r9,r8
80007e24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e28:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80007e2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e2e:	30 09       	mov	r9,0
80007e30:	91 09       	st.w	r8[0x0],r9
}
80007e32:	2f fd       	sub	sp,-4
80007e34:	e3 cd 80 80 	ldm	sp++,r7,pc

80007e38 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80007e38:	eb cd 40 80 	pushm	r7,lr
80007e3c:	1a 97       	mov	r7,sp
80007e3e:	20 1d       	sub	sp,4
80007e40:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80007e44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e48:	30 09       	mov	r9,0
80007e4a:	91 49       	st.w	r8[0x10],r9
}
80007e4c:	2f fd       	sub	sp,-4
80007e4e:	e3 cd 80 80 	ldm	sp++,r7,pc

80007e52 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80007e52:	eb cd 40 80 	pushm	r7,lr
80007e56:	1a 97       	mov	r7,sp
80007e58:	20 3d       	sub	sp,12
80007e5a:	ef 4c ff f8 	st.w	r7[-8],r12
80007e5e:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80007e62:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e66:	70 18       	ld.w	r8,r8[0x4]
80007e68:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80007e6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e70:	70 19       	ld.w	r9,r8[0x4]
80007e72:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e76:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80007e78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e7c:	70 19       	ld.w	r9,r8[0x4]
80007e7e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e82:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80007e84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e88:	70 18       	ld.w	r8,r8[0x4]
80007e8a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e8e:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80007e90:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e98:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80007e9a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e9e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ea2:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80007ea4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007ea8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007eac:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80007eae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007eb2:	70 08       	ld.w	r8,r8[0x0]
80007eb4:	f0 c9 ff ff 	sub	r9,r8,-1
80007eb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ebc:	91 09       	st.w	r8[0x0],r9
}
80007ebe:	2f dd       	sub	sp,-12
80007ec0:	e3 cd 80 80 	ldm	sp++,r7,pc

80007ec4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80007ec4:	eb cd 40 80 	pushm	r7,lr
80007ec8:	1a 97       	mov	r7,sp
80007eca:	20 4d       	sub	sp,16
80007ecc:	ef 4c ff f4 	st.w	r7[-12],r12
80007ed0:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80007ed4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ed8:	70 08       	ld.w	r8,r8[0x0]
80007eda:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80007ede:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ee2:	5b f8       	cp.w	r8,-1
80007ee4:	c0 71       	brne	80007ef2 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80007ee6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007eea:	70 48       	ld.w	r8,r8[0x10]
80007eec:	ef 48 ff f8 	st.w	r7[-8],r8
80007ef0:	c1 58       	rjmp	80007f1a <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80007ef2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007ef6:	2f 88       	sub	r8,-8
80007ef8:	ef 48 ff f8 	st.w	r7[-8],r8
80007efc:	c0 68       	rjmp	80007f08 <vListInsert+0x44>
80007efe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f02:	70 18       	ld.w	r8,r8[0x4]
80007f04:	ef 48 ff f8 	st.w	r7[-8],r8
80007f08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f0c:	70 18       	ld.w	r8,r8[0x4]
80007f0e:	70 09       	ld.w	r9,r8[0x0]
80007f10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007f14:	10 39       	cp.w	r9,r8
80007f16:	fe 98 ff f4 	brls	80007efe <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80007f1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f1e:	70 19       	ld.w	r9,r8[0x4]
80007f20:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f24:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80007f26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f2a:	70 18       	ld.w	r8,r8[0x4]
80007f2c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80007f30:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80007f32:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f36:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007f3a:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80007f3c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80007f40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f44:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80007f46:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f4a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007f4e:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80007f50:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007f54:	70 08       	ld.w	r8,r8[0x0]
80007f56:	f0 c9 ff ff 	sub	r9,r8,-1
80007f5a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007f5e:	91 09       	st.w	r8[0x0],r9
}
80007f60:	2f cd       	sub	sp,-16
80007f62:	e3 cd 80 80 	ldm	sp++,r7,pc

80007f66 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80007f66:	eb cd 40 80 	pushm	r7,lr
80007f6a:	1a 97       	mov	r7,sp
80007f6c:	20 2d       	sub	sp,8
80007f6e:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80007f72:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f76:	70 18       	ld.w	r8,r8[0x4]
80007f78:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007f7c:	72 29       	ld.w	r9,r9[0x8]
80007f7e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80007f80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f84:	70 28       	ld.w	r8,r8[0x8]
80007f86:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007f8a:	72 19       	ld.w	r9,r9[0x4]
80007f8c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80007f8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f92:	70 48       	ld.w	r8,r8[0x10]
80007f94:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80007f98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007f9c:	70 19       	ld.w	r9,r8[0x4]
80007f9e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fa2:	10 39       	cp.w	r9,r8
80007fa4:	c0 71       	brne	80007fb2 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80007fa6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007faa:	70 29       	ld.w	r9,r8[0x8]
80007fac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fb0:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80007fb2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fb6:	30 09       	mov	r9,0
80007fb8:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80007fba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fbe:	70 08       	ld.w	r8,r8[0x0]
80007fc0:	f0 c9 00 01 	sub	r9,r8,1
80007fc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fc8:	91 09       	st.w	r8[0x0],r9
}
80007fca:	2f ed       	sub	sp,-8
80007fcc:	e3 cd 80 80 	ldm	sp++,r7,pc

80007fd0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80007fd0:	eb cd 40 80 	pushm	r7,lr
80007fd4:	1a 97       	mov	r7,sp
80007fd6:	20 1d       	sub	sp,4
80007fd8:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80007fdc:	f0 1f 00 03 	mcall	80007fe8 <__malloc_lock+0x18>
}
80007fe0:	2f fd       	sub	sp,-4
80007fe2:	e3 cd 80 80 	ldm	sp++,r7,pc
80007fe6:	00 00       	add	r0,r0
80007fe8:	80 00       	ld.sh	r0,r0[0x0]
80007fea:	90 bc       	ld.uh	r12,r8[0x6]

80007fec <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80007fec:	eb cd 40 80 	pushm	r7,lr
80007ff0:	1a 97       	mov	r7,sp
80007ff2:	20 1d       	sub	sp,4
80007ff4:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80007ff8:	f0 1f 00 03 	mcall	80008004 <__malloc_unlock+0x18>
}
80007ffc:	2f fd       	sub	sp,-4
80007ffe:	e3 cd 80 80 	ldm	sp++,r7,pc
80008002:	00 00       	add	r0,r0
80008004:	80 00       	ld.sh	r0,r0[0x0]
80008006:	90 d8       	ld.uh	r8,r8[0xa]

80008008 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008008:	eb cd 00 ff 	pushm	r0-r7
8000800c:	e0 68 05 44 	mov	r8,1348
80008010:	ea 18 00 00 	orh	r8,0x0
80008014:	70 00       	ld.w	r0,r8[0x0]
80008016:	1a d0       	st.w	--sp,r0
80008018:	7a 90       	ld.w	r0,sp[0x24]
8000801a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000801e:	58 10       	cp.w	r0,1
80008020:	e0 8b 00 08 	brhi	80008030 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008024:	e0 68 0c 18 	mov	r8,3096
80008028:	ea 18 00 00 	orh	r8,0x0
8000802c:	70 00       	ld.w	r0,r8[0x0]
8000802e:	81 0d       	st.w	r0[0x0],sp

80008030 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008030:	f0 1f 00 12 	mcall	80008078 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008034:	f0 1f 00 12 	mcall	8000807c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008038:	f0 1f 00 12 	mcall	80008080 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
8000803c:	f0 1f 00 12 	mcall	80008084 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008040:	7a 90       	ld.w	r0,sp[0x24]
80008042:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008046:	58 10       	cp.w	r0,1
80008048:	e0 8b 00 0e 	brhi	80008064 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
8000804c:	f0 1f 00 0c 	mcall	8000807c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008050:	f0 1f 00 0e 	mcall	80008088 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008054:	f0 1f 00 0c 	mcall	80008084 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008058:	e0 68 0c 18 	mov	r8,3096
8000805c:	ea 18 00 00 	orh	r8,0x0
80008060:	70 00       	ld.w	r0,r8[0x0]
80008062:	60 0d       	ld.w	sp,r0[0x0]

80008064 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008064:	1b 00       	ld.w	r0,sp++
80008066:	e0 68 05 44 	mov	r8,1348
8000806a:	ea 18 00 00 	orh	r8,0x0
8000806e:	91 00       	st.w	r8[0x0],r0
80008070:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008074:	d6 03       	rete
80008076:	00 00       	add	r0,r0
80008078:	80 00       	ld.sh	r0,r0[0x0]
8000807a:	83 74       	st.w	r1[0x1c],r4
8000807c:	80 00       	ld.sh	r0,r0[0x0]
8000807e:	81 24       	st.w	r0[0x8],r4
80008080:	80 00       	ld.sh	r0,r0[0x0]
80008082:	92 30       	ld.sh	r0,r9[0x6]
80008084:	80 00       	ld.sh	r0,r0[0x0]
80008086:	81 40       	st.w	r0[0x10],r0
80008088:	80 00       	ld.sh	r0,r0[0x0]
8000808a:	93 90       	st.w	r9[0x24],r0

8000808c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000808c:	20 6d       	sub	sp,24
8000808e:	eb cd 00 ff 	pushm	r0-r7
80008092:	fa c7 ff c0 	sub	r7,sp,-64
80008096:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000809a:	ef 40 ff e0 	st.w	r7[-32],r0
8000809e:	ee f0 ff fc 	ld.w	r0,r7[-4]
800080a2:	ef 40 ff e4 	st.w	r7[-28],r0
800080a6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800080aa:	e0 68 05 44 	mov	r8,1348
800080ae:	ea 18 00 00 	orh	r8,0x0
800080b2:	70 00       	ld.w	r0,r8[0x0]
800080b4:	1a d0       	st.w	--sp,r0
800080b6:	f0 1f 00 1a 	mcall	8000811c <LABEL_RET_SCALL_263+0x14>
800080ba:	e0 68 0c 18 	mov	r8,3096
800080be:	ea 18 00 00 	orh	r8,0x0
800080c2:	70 00       	ld.w	r0,r8[0x0]
800080c4:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800080c6:	f0 1f 00 17 	mcall	80008120 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800080ca:	e0 68 0c 18 	mov	r8,3096
800080ce:	ea 18 00 00 	orh	r8,0x0
800080d2:	70 00       	ld.w	r0,r8[0x0]
800080d4:	60 0d       	ld.w	sp,r0[0x0]
800080d6:	1b 00       	ld.w	r0,sp++
800080d8:	e0 68 05 44 	mov	r8,1348
800080dc:	ea 18 00 00 	orh	r8,0x0
800080e0:	91 00       	st.w	r8[0x0],r0
800080e2:	fa c7 ff d8 	sub	r7,sp,-40
800080e6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800080ea:	ee f0 ff e0 	ld.w	r0,r7[-32]
800080ee:	e0 61 05 44 	mov	r1,1348
800080f2:	ea 11 00 00 	orh	r1,0x0
800080f6:	62 02       	ld.w	r2,r1[0x0]
800080f8:	58 02       	cp.w	r2,0
800080fa:	c0 70       	breq	80008108 <LABEL_RET_SCALL_263>
800080fc:	e4 c2 00 01 	sub	r2,r2,1
80008100:	83 02       	st.w	r1[0x0],r2
80008102:	58 02       	cp.w	r2,0
80008104:	c0 21       	brne	80008108 <LABEL_RET_SCALL_263>
80008106:	b1 c0       	cbr	r0,0x10

80008108 <LABEL_RET_SCALL_263>:
80008108:	ef 40 ff f8 	st.w	r7[-8],r0
8000810c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80008110:	ef 40 ff fc 	st.w	r7[-4],r0
80008114:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008118:	2f ad       	sub	sp,-24
8000811a:	d6 13       	rets
8000811c:	80 00       	ld.sh	r0,r0[0x0]
8000811e:	81 24       	st.w	r0[0x8],r4
80008120:	80 00       	ld.sh	r0,r0[0x0]
80008122:	93 90       	st.w	r9[0x24],r0

80008124 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80008124:	eb cd 40 80 	pushm	r7,lr
80008128:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000812a:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000812c:	48 48       	lddpc	r8,8000813c <vPortEnterCritical+0x18>
8000812e:	70 08       	ld.w	r8,r8[0x0]
80008130:	f0 c9 ff ff 	sub	r9,r8,-1
80008134:	48 28       	lddpc	r8,8000813c <vPortEnterCritical+0x18>
80008136:	91 09       	st.w	r8[0x0],r9
}
80008138:	e3 cd 80 80 	ldm	sp++,r7,pc
8000813c:	00 00       	add	r0,r0
8000813e:	05 44       	ld.w	r4,--r2

80008140 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80008140:	eb cd 40 80 	pushm	r7,lr
80008144:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008146:	48 98       	lddpc	r8,80008168 <vPortExitCritical+0x28>
80008148:	70 08       	ld.w	r8,r8[0x0]
8000814a:	58 08       	cp.w	r8,0
8000814c:	c0 c0       	breq	80008164 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
8000814e:	48 78       	lddpc	r8,80008168 <vPortExitCritical+0x28>
80008150:	70 08       	ld.w	r8,r8[0x0]
80008152:	f0 c9 00 01 	sub	r9,r8,1
80008156:	48 58       	lddpc	r8,80008168 <vPortExitCritical+0x28>
80008158:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000815a:	48 48       	lddpc	r8,80008168 <vPortExitCritical+0x28>
8000815c:	70 08       	ld.w	r8,r8[0x0]
8000815e:	58 08       	cp.w	r8,0
80008160:	c0 21       	brne	80008164 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008162:	d5 03       	csrf	0x10
		}
	}
}
80008164:	e3 cd 80 80 	ldm	sp++,r7,pc
80008168:	00 00       	add	r0,r0
8000816a:	05 44       	ld.w	r4,--r2

8000816c <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
8000816c:	eb cd 40 80 	pushm	r7,lr
80008170:	1a 97       	mov	r7,sp
80008172:	20 3d       	sub	sp,12
80008174:	ef 4c ff fc 	st.w	r7[-4],r12
80008178:	ef 4b ff f8 	st.w	r7[-8],r11
8000817c:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80008180:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008184:	20 48       	sub	r8,4
80008186:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000818a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000818e:	e0 69 08 08 	mov	r9,2056
80008192:	ea 19 08 08 	orh	r9,0x808
80008196:	91 09       	st.w	r8[0x0],r9
80008198:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000819c:	20 48       	sub	r8,4
8000819e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800081a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081a6:	e0 69 09 09 	mov	r9,2313
800081aa:	ea 19 09 09 	orh	r9,0x909
800081ae:	91 09       	st.w	r8[0x0],r9
800081b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081b4:	20 48       	sub	r8,4
800081b6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800081ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081be:	e0 69 0a 0a 	mov	r9,2570
800081c2:	ea 19 0a 0a 	orh	r9,0xa0a
800081c6:	91 09       	st.w	r8[0x0],r9
800081c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081cc:	20 48       	sub	r8,4
800081ce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800081d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081d6:	e0 69 0b 0b 	mov	r9,2827
800081da:	ea 19 0b 0b 	orh	r9,0xb0b
800081de:	91 09       	st.w	r8[0x0],r9
800081e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081e4:	20 48       	sub	r8,4
800081e6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800081ea:	ee f9 ff f4 	ld.w	r9,r7[-12]
800081ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081f2:	91 09       	st.w	r8[0x0],r9
800081f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081f8:	20 48       	sub	r8,4
800081fa:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800081fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008202:	e0 69 be ef 	mov	r9,48879
80008206:	ea 19 de ad 	orh	r9,0xdead
8000820a:	91 09       	st.w	r8[0x0],r9
8000820c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008210:	20 48       	sub	r8,4
80008212:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008216:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000821a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000821e:	91 09       	st.w	r8[0x0],r9
80008220:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008224:	20 48       	sub	r8,4
80008226:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000822a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000822e:	fc 19 00 40 	movh	r9,0x40
80008232:	91 09       	st.w	r8[0x0],r9
80008234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008238:	20 48       	sub	r8,4
8000823a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000823e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008242:	e0 69 00 ff 	mov	r9,255
80008246:	ea 19 ff 00 	orh	r9,0xff00
8000824a:	91 09       	st.w	r8[0x0],r9
8000824c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008250:	20 48       	sub	r8,4
80008252:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008256:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000825a:	e0 69 01 01 	mov	r9,257
8000825e:	ea 19 01 01 	orh	r9,0x101
80008262:	91 09       	st.w	r8[0x0],r9
80008264:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008268:	20 48       	sub	r8,4
8000826a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000826e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008272:	e0 69 02 02 	mov	r9,514
80008276:	ea 19 02 02 	orh	r9,0x202
8000827a:	91 09       	st.w	r8[0x0],r9
8000827c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008280:	20 48       	sub	r8,4
80008282:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80008286:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000828a:	e0 69 03 03 	mov	r9,771
8000828e:	ea 19 03 03 	orh	r9,0x303
80008292:	91 09       	st.w	r8[0x0],r9
80008294:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008298:	20 48       	sub	r8,4
8000829a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000829e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082a2:	e0 69 04 04 	mov	r9,1028
800082a6:	ea 19 04 04 	orh	r9,0x404
800082aa:	91 09       	st.w	r8[0x0],r9
800082ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082b0:	20 48       	sub	r8,4
800082b2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800082b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082ba:	e0 69 05 05 	mov	r9,1285
800082be:	ea 19 05 05 	orh	r9,0x505
800082c2:	91 09       	st.w	r8[0x0],r9
800082c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082c8:	20 48       	sub	r8,4
800082ca:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800082ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082d2:	e0 69 06 06 	mov	r9,1542
800082d6:	ea 19 06 06 	orh	r9,0x606
800082da:	91 09       	st.w	r8[0x0],r9
800082dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082e0:	20 48       	sub	r8,4
800082e2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800082e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082ea:	e0 69 07 07 	mov	r9,1799
800082ee:	ea 19 07 07 	orh	r9,0x707
800082f2:	91 09       	st.w	r8[0x0],r9
800082f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082f8:	20 48       	sub	r8,4
800082fa:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800082fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008302:	30 09       	mov	r9,0
80008304:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80008306:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000830a:	10 9c       	mov	r12,r8
8000830c:	2f dd       	sub	sp,-12
8000830e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008312:	d7 03       	nop

80008314 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008314:	eb cd 40 80 	pushm	r7,lr
80008318:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
8000831a:	f0 1f 00 10 	mcall	80008358 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000831e:	e0 68 0c 18 	mov	r8,3096
80008322:	ea 18 00 00 	orh	r8,0x0
80008326:	70 00       	ld.w	r0,r8[0x0]
80008328:	60 0d       	ld.w	sp,r0[0x0]
8000832a:	1b 00       	ld.w	r0,sp++
8000832c:	e0 68 05 44 	mov	r8,1348
80008330:	ea 18 00 00 	orh	r8,0x0
80008334:	91 00       	st.w	r8[0x0],r0
80008336:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000833a:	2f ed       	sub	sp,-8
8000833c:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008340:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008344:	e3 b0 00 00 	mtsr	0x0,r0
80008348:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000834c:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80008350:	30 08       	mov	r8,0
}
80008352:	10 9c       	mov	r12,r8
80008354:	e3 cd 80 80 	ldm	sp++,r7,pc
80008358:	80 00       	ld.sh	r0,r0[0x0]
8000835a:	83 88       	st.w	r1[0x20],r8

8000835c <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
8000835c:	eb cd 40 80 	pushm	r7,lr
80008360:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80008362:	e0 68 5d c0 	mov	r8,24000
80008366:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000836a:	30 08       	mov	r8,0
8000836c:	e3 b8 00 42 	mtsr	0x108,r8
	}
80008370:	e3 cd 80 80 	ldm	sp++,r7,pc

80008374 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80008374:	eb cd 40 80 	pushm	r7,lr
80008378:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000837a:	e1 b8 00 43 	mfsr	r8,0x10c
8000837e:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80008382:	e3 cd 80 80 	ldm	sp++,r7,pc
80008386:	d7 03       	nop

80008388 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80008388:	eb cd 40 80 	pushm	r7,lr
8000838c:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000838e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008390:	30 0a       	mov	r10,0
80008392:	30 0b       	mov	r11,0
80008394:	48 4c       	lddpc	r12,800083a4 <prvSetupTimerInterrupt+0x1c>
80008396:	f0 1f 00 05 	mcall	800083a8 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
8000839a:	f0 1f 00 05 	mcall	800083ac <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
8000839e:	e3 cd 80 80 	ldm	sp++,r7,pc
800083a2:	00 00       	add	r0,r0
800083a4:	80 00       	ld.sh	r0,r0[0x0]
800083a6:	80 08       	ld.sh	r8,r0[0x0]
800083a8:	80 00       	ld.sh	r0,r0[0x0]
800083aa:	6f b8       	ld.w	r8,r7[0x6c]
800083ac:	80 00       	ld.sh	r0,r0[0x0]
800083ae:	83 5c       	st.w	r1[0x14],r12

800083b0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800083b0:	eb cd 40 80 	pushm	r7,lr
800083b4:	1a 97       	mov	r7,sp
800083b6:	20 5d       	sub	sp,20
800083b8:	ef 4c ff f4 	st.w	r7[-12],r12
800083bc:	ef 4b ff f0 	st.w	r7[-16],r11
800083c0:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
800083c4:	30 08       	mov	r8,0
800083c6:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
800083ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800083ce:	58 08       	cp.w	r8,0
800083d0:	c2 40       	breq	80008418 <_read+0x68>
    return -1;
800083d2:	3f f8       	mov	r8,-1
800083d4:	c2 b8       	rjmp	8000842a <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
800083d6:	49 88       	lddpc	r8,80008434 <_read+0x84>
800083d8:	70 08       	ld.w	r8,r8[0x0]
800083da:	10 9c       	mov	r12,r8
800083dc:	f0 1f 00 17 	mcall	80008438 <_read+0x88>
800083e0:	18 98       	mov	r8,r12
800083e2:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
800083e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800083ea:	58 08       	cp.w	r8,0
800083ec:	c1 c5       	brlt	80008424 <_read+0x74>
      break;

    *ptr++ = c;
800083ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800083f2:	5c 58       	castu.b	r8
800083f4:	ee f9 ff f0 	ld.w	r9,r7[-16]
800083f8:	b2 88       	st.b	r9[0x0],r8
800083fa:	ee f8 ff f0 	ld.w	r8,r7[-16]
800083fe:	2f f8       	sub	r8,-1
80008400:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80008404:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008408:	2f f8       	sub	r8,-1
8000840a:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000840e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008412:	20 18       	sub	r8,1
80008414:	ef 48 ff ec 	st.w	r7[-20],r8
80008418:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000841c:	58 08       	cp.w	r8,0
8000841e:	fe 99 ff dc 	brgt	800083d6 <_read+0x26>
80008422:	c0 28       	rjmp	80008426 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
80008424:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
80008426:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000842a:	10 9c       	mov	r12,r8
8000842c:	2f bd       	sub	sp,-20
8000842e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008432:	00 00       	add	r0,r0
80008434:	00 00       	add	r0,r0
80008436:	41 0c       	lddsp	r12,sp[0x40]
80008438:	80 00       	ld.sh	r0,r0[0x0]
8000843a:	7d 68       	ld.w	r8,lr[0x58]

8000843c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
8000843c:	eb cd 40 80 	pushm	r7,lr
80008440:	1a 97       	mov	r7,sp
80008442:	20 4d       	sub	sp,16
80008444:	ef 4c ff f8 	st.w	r7[-8],r12
80008448:	ef 4b ff f4 	st.w	r7[-12],r11
8000844c:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
80008450:	30 08       	mov	r8,0
80008452:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
80008456:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000845a:	58 18       	cp.w	r8,1
8000845c:	c2 90       	breq	800084ae <_write+0x72>
8000845e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008462:	58 28       	cp.w	r8,2
80008464:	c2 50       	breq	800084ae <_write+0x72>
80008466:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000846a:	58 38       	cp.w	r8,3
8000846c:	c2 10       	breq	800084ae <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
8000846e:	3f f8       	mov	r8,-1
80008470:	c2 58       	rjmp	800084ba <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008472:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008476:	11 88       	ld.ub	r8,r8[0x0]
80008478:	10 99       	mov	r9,r8
8000847a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000847e:	2f f8       	sub	r8,-1
80008480:	ef 48 ff f4 	st.w	r7[-12],r8
80008484:	49 08       	lddpc	r8,800084c4 <_write+0x88>
80008486:	70 08       	ld.w	r8,r8[0x0]
80008488:	12 9b       	mov	r11,r9
8000848a:	10 9c       	mov	r12,r8
8000848c:	f0 1f 00 0f 	mcall	800084c8 <_write+0x8c>
80008490:	18 98       	mov	r8,r12
80008492:	58 08       	cp.w	r8,0
80008494:	c0 34       	brge	8000849a <_write+0x5e>
    {
      return -1;
80008496:	3f f8       	mov	r8,-1
80008498:	c1 18       	rjmp	800084ba <_write+0x7e>
    }

    ++nChars;
8000849a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000849e:	2f f8       	sub	r8,-1
800084a0:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800084a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800084a8:	20 18       	sub	r8,1
800084aa:	ef 48 ff f0 	st.w	r7[-16],r8
800084ae:	ee f8 ff f0 	ld.w	r8,r7[-16]
800084b2:	58 08       	cp.w	r8,0
800084b4:	cd f1       	brne	80008472 <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
800084b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800084ba:	10 9c       	mov	r12,r8
800084bc:	2f cd       	sub	sp,-16
800084be:	e3 cd 80 80 	ldm	sp++,r7,pc
800084c2:	00 00       	add	r0,r0
800084c4:	00 00       	add	r0,r0
800084c6:	41 0c       	lddsp	r12,sp[0x40]
800084c8:	80 00       	ld.sh	r0,r0[0x0]
800084ca:	7c c0       	ld.w	r0,lr[0x30]

800084cc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800084cc:	eb cd 40 80 	pushm	r7,lr
800084d0:	1a 97       	mov	r7,sp
800084d2:	20 2d       	sub	sp,8
800084d4:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
800084d8:	f0 1f 00 09 	mcall	800084fc <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
800084dc:	ee fc ff f8 	ld.w	r12,r7[-8]
800084e0:	f0 1f 00 08 	mcall	80008500 <pvPortMalloc+0x34>
800084e4:	18 98       	mov	r8,r12
800084e6:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
800084ea:	f0 1f 00 07 	mcall	80008504 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
800084ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800084f2:	10 9c       	mov	r12,r8
800084f4:	2f ed       	sub	sp,-8
800084f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800084fa:	00 00       	add	r0,r0
800084fc:	80 00       	ld.sh	r0,r0[0x0]
800084fe:	90 bc       	ld.uh	r12,r8[0x6]
80008500:	80 00       	ld.sh	r0,r0[0x0]
80008502:	a8 08       	st.h	r4[0x0],r8
80008504:	80 00       	ld.sh	r0,r0[0x0]
80008506:	90 d8       	ld.uh	r8,r8[0xa]

80008508 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008508:	eb cd 40 80 	pushm	r7,lr
8000850c:	1a 97       	mov	r7,sp
8000850e:	20 1d       	sub	sp,4
80008510:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80008514:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008518:	58 08       	cp.w	r8,0
8000851a:	c0 90       	breq	8000852c <vPortFree+0x24>
	{
		vTaskSuspendAll();
8000851c:	f0 1f 00 06 	mcall	80008534 <vPortFree+0x2c>
		{
			free( pv );
80008520:	ee fc ff fc 	ld.w	r12,r7[-4]
80008524:	f0 1f 00 05 	mcall	80008538 <vPortFree+0x30>
		}
		xTaskResumeAll();
80008528:	f0 1f 00 05 	mcall	8000853c <vPortFree+0x34>
	}
}
8000852c:	2f fd       	sub	sp,-4
8000852e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008532:	00 00       	add	r0,r0
80008534:	80 00       	ld.sh	r0,r0[0x0]
80008536:	90 bc       	ld.uh	r12,r8[0x6]
80008538:	80 00       	ld.sh	r0,r0[0x0]
8000853a:	a7 f8       	*unknown*
8000853c:	80 00       	ld.sh	r0,r0[0x0]
8000853e:	90 d8       	ld.uh	r8,r8[0xa]

80008540 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80008540:	eb cd 40 80 	pushm	r7,lr
80008544:	1a 97       	mov	r7,sp
80008546:	20 5d       	sub	sp,20
80008548:	ef 4c ff f0 	st.w	r7[-16],r12
8000854c:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80008550:	30 08       	mov	r8,0
80008552:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80008556:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000855a:	58 08       	cp.w	r8,0
8000855c:	c7 20       	breq	80008640 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000855e:	34 cc       	mov	r12,76
80008560:	f0 1f 00 3b 	mcall	8000864c <xQueueCreate+0x10c>
80008564:	18 98       	mov	r8,r12
80008566:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
8000856a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000856e:	58 08       	cp.w	r8,0
80008570:	c6 80       	breq	80008640 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80008572:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008576:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000857a:	f2 08 02 48 	mul	r8,r9,r8
8000857e:	2f f8       	sub	r8,-1
80008580:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80008584:	ee fc ff f8 	ld.w	r12,r7[-8]
80008588:	f0 1f 00 31 	mcall	8000864c <xQueueCreate+0x10c>
8000858c:	18 98       	mov	r8,r12
8000858e:	10 99       	mov	r9,r8
80008590:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008594:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80008596:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000859a:	70 08       	ld.w	r8,r8[0x0]
8000859c:	58 08       	cp.w	r8,0
8000859e:	c4 d0       	breq	80008638 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800085a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085a4:	70 09       	ld.w	r9,r8[0x0]
800085a6:	ee fa ff f0 	ld.w	r10,r7[-16]
800085aa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800085ae:	f4 08 02 48 	mul	r8,r10,r8
800085b2:	10 09       	add	r9,r8
800085b4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085b8:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800085ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085be:	30 09       	mov	r9,0
800085c0:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800085c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085c6:	70 09       	ld.w	r9,r8[0x0]
800085c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085cc:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800085ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085d2:	70 09       	ld.w	r9,r8[0x0]
800085d4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800085d8:	f0 ca 00 01 	sub	r10,r8,1
800085dc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800085e0:	f4 08 02 48 	mul	r8,r10,r8
800085e4:	10 09       	add	r9,r8
800085e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085ea:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
800085ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085f0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800085f4:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
800085f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085fa:	ee f9 ff ec 	ld.w	r9,r7[-20]
800085fe:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80008602:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008606:	3f f9       	mov	r9,-1
80008608:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
8000860c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008610:	3f f9       	mov	r9,-1
80008612:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008616:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000861a:	2f 08       	sub	r8,-16
8000861c:	10 9c       	mov	r12,r8
8000861e:	f0 1f 00 0d 	mcall	80008650 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008622:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008626:	2d c8       	sub	r8,-36
80008628:	10 9c       	mov	r12,r8
8000862a:	f0 1f 00 0a 	mcall	80008650 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
8000862e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008632:	ef 48 ff fc 	st.w	r7[-4],r8
80008636:	c0 58       	rjmp	80008640 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80008638:	ee fc ff f4 	ld.w	r12,r7[-12]
8000863c:	f0 1f 00 06 	mcall	80008654 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80008640:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008644:	10 9c       	mov	r12,r8
80008646:	2f bd       	sub	sp,-20
80008648:	e3 cd 80 80 	ldm	sp++,r7,pc
8000864c:	80 00       	ld.sh	r0,r0[0x0]
8000864e:	84 cc       	ld.uh	r12,r2[0x8]
80008650:	80 00       	ld.sh	r0,r0[0x0]
80008652:	7d ec       	ld.w	r12,lr[0x78]
80008654:	80 00       	ld.sh	r0,r0[0x0]
80008656:	85 08       	st.w	r2[0x0],r8

80008658 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008658:	eb cd 40 80 	pushm	r7,lr
8000865c:	1a 97       	mov	r7,sp
8000865e:	20 7d       	sub	sp,28
80008660:	ef 4c ff f0 	st.w	r7[-16],r12
80008664:	ef 4b ff ec 	st.w	r7[-20],r11
80008668:	ef 4a ff e8 	st.w	r7[-24],r10
8000866c:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80008670:	30 08       	mov	r8,0
80008672:	ef 48 ff fc 	st.w	r7[-4],r8
80008676:	c0 28       	rjmp	8000867a <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80008678:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000867a:	f0 1f 00 47 	mcall	80008794 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000867e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008682:	70 e9       	ld.w	r9,r8[0x38]
80008684:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008688:	70 f8       	ld.w	r8,r8[0x3c]
8000868a:	10 39       	cp.w	r9,r8
8000868c:	c1 c2       	brcc	800086c4 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000868e:	ee fa ff e4 	ld.w	r10,r7[-28]
80008692:	ee fb ff ec 	ld.w	r11,r7[-20]
80008696:	ee fc ff f0 	ld.w	r12,r7[-16]
8000869a:	f0 1f 00 40 	mcall	80008798 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000869e:	ee f8 ff f0 	ld.w	r8,r7[-16]
800086a2:	70 98       	ld.w	r8,r8[0x24]
800086a4:	58 08       	cp.w	r8,0
800086a6:	c0 b0       	breq	800086bc <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800086a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800086ac:	2d c8       	sub	r8,-36
800086ae:	10 9c       	mov	r12,r8
800086b0:	f0 1f 00 3b 	mcall	8000879c <xQueueGenericSend+0x144>
800086b4:	18 98       	mov	r8,r12
800086b6:	58 18       	cp.w	r8,1
800086b8:	c0 21       	brne	800086bc <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800086ba:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800086bc:	f0 1f 00 39 	mcall	800087a0 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800086c0:	30 18       	mov	r8,1
800086c2:	c6 58       	rjmp	8000878c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800086c4:	ee f8 ff e8 	ld.w	r8,r7[-24]
800086c8:	58 08       	cp.w	r8,0
800086ca:	c0 51       	brne	800086d4 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800086cc:	f0 1f 00 35 	mcall	800087a0 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800086d0:	30 08       	mov	r8,0
800086d2:	c5 d8       	rjmp	8000878c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
800086d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086d8:	58 08       	cp.w	r8,0
800086da:	c0 91       	brne	800086ec <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800086dc:	ee c8 00 0c 	sub	r8,r7,12
800086e0:	10 9c       	mov	r12,r8
800086e2:	f0 1f 00 31 	mcall	800087a4 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
800086e6:	30 18       	mov	r8,1
800086e8:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800086ec:	f0 1f 00 2d 	mcall	800087a0 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800086f0:	f0 1f 00 2e 	mcall	800087a8 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
800086f4:	f0 1f 00 28 	mcall	80008794 <xQueueGenericSend+0x13c>
800086f8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800086fc:	71 18       	ld.w	r8,r8[0x44]
800086fe:	5b f8       	cp.w	r8,-1
80008700:	c0 61       	brne	8000870c <xQueueGenericSend+0xb4>
80008702:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008706:	30 09       	mov	r9,0
80008708:	f1 49 00 44 	st.w	r8[68],r9
8000870c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008710:	71 28       	ld.w	r8,r8[0x48]
80008712:	5b f8       	cp.w	r8,-1
80008714:	c0 61       	brne	80008720 <xQueueGenericSend+0xc8>
80008716:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000871a:	30 09       	mov	r9,0
8000871c:	f1 49 00 48 	st.w	r8[72],r9
80008720:	f0 1f 00 20 	mcall	800087a0 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008724:	ee c9 00 18 	sub	r9,r7,24
80008728:	ee c8 00 0c 	sub	r8,r7,12
8000872c:	12 9b       	mov	r11,r9
8000872e:	10 9c       	mov	r12,r8
80008730:	f0 1f 00 1f 	mcall	800087ac <xQueueGenericSend+0x154>
80008734:	18 98       	mov	r8,r12
80008736:	58 08       	cp.w	r8,0
80008738:	c2 31       	brne	8000877e <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
8000873a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000873e:	f0 1f 00 1d 	mcall	800087b0 <xQueueGenericSend+0x158>
80008742:	18 98       	mov	r8,r12
80008744:	58 08       	cp.w	r8,0
80008746:	c1 50       	breq	80008770 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008748:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000874c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008750:	2f 08       	sub	r8,-16
80008752:	12 9b       	mov	r11,r9
80008754:	10 9c       	mov	r12,r8
80008756:	f0 1f 00 18 	mcall	800087b4 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000875a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000875e:	f0 1f 00 17 	mcall	800087b8 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80008762:	f0 1f 00 17 	mcall	800087bc <xQueueGenericSend+0x164>
80008766:	18 98       	mov	r8,r12
80008768:	58 08       	cp.w	r8,0
8000876a:	c8 71       	brne	80008678 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
8000876c:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000876e:	c8 6b       	rjmp	8000867a <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008770:	ee fc ff f0 	ld.w	r12,r7[-16]
80008774:	f0 1f 00 11 	mcall	800087b8 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80008778:	f0 1f 00 11 	mcall	800087bc <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000877c:	c7 fb       	rjmp	8000867a <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000877e:	ee fc ff f0 	ld.w	r12,r7[-16]
80008782:	f0 1f 00 0e 	mcall	800087b8 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80008786:	f0 1f 00 0e 	mcall	800087bc <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000878a:	30 08       	mov	r8,0
		}
	}
}
8000878c:	10 9c       	mov	r12,r8
8000878e:	2f 9d       	sub	sp,-28
80008790:	e3 cd 80 80 	ldm	sp++,r7,pc
80008794:	80 00       	ld.sh	r0,r0[0x0]
80008796:	81 24       	st.w	r0[0x8],r4
80008798:	80 00       	ld.sh	r0,r0[0x0]
8000879a:	8a f4       	ld.uh	r4,r5[0xe]
8000879c:	80 00       	ld.sh	r0,r0[0x0]
8000879e:	94 c0       	ld.uh	r0,r10[0x8]
800087a0:	80 00       	ld.sh	r0,r0[0x0]
800087a2:	81 40       	st.w	r0[0x10],r0
800087a4:	80 00       	ld.sh	r0,r0[0x0]
800087a6:	95 90       	st.w	r10[0x24],r0
800087a8:	80 00       	ld.sh	r0,r0[0x0]
800087aa:	90 bc       	ld.uh	r12,r8[0x6]
800087ac:	80 00       	ld.sh	r0,r0[0x0]
800087ae:	95 c0       	st.w	r10[0x30],r0
800087b0:	80 00       	ld.sh	r0,r0[0x0]
800087b2:	8d 6c       	st.w	r6[0x18],r12
800087b4:	80 00       	ld.sh	r0,r0[0x0]
800087b6:	94 40       	ld.sh	r0,r10[0x8]
800087b8:	80 00       	ld.sh	r0,r0[0x0]
800087ba:	8c 64       	ld.sh	r4,r6[0xc]
800087bc:	80 00       	ld.sh	r0,r0[0x0]
800087be:	90 d8       	ld.uh	r8,r8[0xa]

800087c0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800087c0:	eb cd 40 80 	pushm	r7,lr
800087c4:	1a 97       	mov	r7,sp
800087c6:	20 6d       	sub	sp,24
800087c8:	ef 4c ff f4 	st.w	r7[-12],r12
800087cc:	ef 4b ff f0 	st.w	r7[-16],r11
800087d0:	ef 4a ff ec 	st.w	r7[-20],r10
800087d4:	ef 49 ff e8 	st.w	r7[-24],r9
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
800087d8:	30 08       	mov	r8,0
800087da:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800087de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087e2:	70 e9       	ld.w	r9,r8[0x38]
800087e4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087e8:	70 f8       	ld.w	r8,r8[0x3c]
800087ea:	10 39       	cp.w	r9,r8
800087ec:	c2 e2       	brcc	80008848 <xQueueGenericSendFromISR+0x88>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800087ee:	ee fa ff e8 	ld.w	r10,r7[-24]
800087f2:	ee fb ff f0 	ld.w	r11,r7[-16]
800087f6:	ee fc ff f4 	ld.w	r12,r7[-12]
800087fa:	f0 1f 00 19 	mcall	8000885c <xQueueGenericSendFromISR+0x9c>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800087fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008802:	71 28       	ld.w	r8,r8[0x48]
80008804:	5b f8       	cp.w	r8,-1
80008806:	c1 41       	brne	8000882e <xQueueGenericSendFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008808:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000880c:	70 98       	ld.w	r8,r8[0x24]
8000880e:	58 08       	cp.w	r8,0
80008810:	c1 80       	breq	80008840 <xQueueGenericSendFromISR+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008812:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008816:	2d c8       	sub	r8,-36
80008818:	10 9c       	mov	r12,r8
8000881a:	f0 1f 00 12 	mcall	80008860 <xQueueGenericSendFromISR+0xa0>
8000881e:	18 98       	mov	r8,r12
80008820:	58 08       	cp.w	r8,0
80008822:	c0 f0       	breq	80008840 <xQueueGenericSendFromISR+0x80>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80008824:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008828:	30 19       	mov	r9,1
8000882a:	91 09       	st.w	r8[0x0],r9
8000882c:	c0 a8       	rjmp	80008840 <xQueueGenericSendFromISR+0x80>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000882e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008832:	71 28       	ld.w	r8,r8[0x48]
80008834:	f0 c9 ff ff 	sub	r9,r8,-1
80008838:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000883c:	f1 49 00 48 	st.w	r8[72],r9
			}

			xReturn = pdPASS;
80008840:	30 18       	mov	r8,1
80008842:	ef 48 ff f8 	st.w	r7[-8],r8
80008846:	c0 48       	rjmp	8000884e <xQueueGenericSendFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
80008848:	30 08       	mov	r8,0
8000884a:	ef 48 ff f8 	st.w	r7[-8],r8
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
8000884e:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008852:	10 9c       	mov	r12,r8
80008854:	2f ad       	sub	sp,-24
80008856:	e3 cd 80 80 	ldm	sp++,r7,pc
8000885a:	00 00       	add	r0,r0
8000885c:	80 00       	ld.sh	r0,r0[0x0]
8000885e:	8a f4       	ld.uh	r4,r5[0xe]
80008860:	80 00       	ld.sh	r0,r0[0x0]
80008862:	94 c0       	ld.uh	r0,r10[0x8]

80008864 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80008864:	eb cd 40 80 	pushm	r7,lr
80008868:	1a 97       	mov	r7,sp
8000886a:	20 8d       	sub	sp,32
8000886c:	ef 4c ff ec 	st.w	r7[-20],r12
80008870:	ef 4b ff e8 	st.w	r7[-24],r11
80008874:	ef 4a ff e4 	st.w	r7[-28],r10
80008878:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
8000887c:	30 08       	mov	r8,0
8000887e:	ef 48 ff f8 	st.w	r7[-8],r8
80008882:	c0 28       	rjmp	80008886 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80008884:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80008886:	f0 1f 00 66 	mcall	80008a1c <xQueueGenericReceive+0x1b8>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000888a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000888e:	70 e8       	ld.w	r8,r8[0x38]
80008890:	58 08       	cp.w	r8,0
80008892:	c4 c0       	breq	8000892a <xQueueGenericReceive+0xc6>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80008894:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008898:	70 38       	ld.w	r8,r8[0xc]
8000889a:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000889e:	ee fb ff e8 	ld.w	r11,r7[-24]
800088a2:	ee fc ff ec 	ld.w	r12,r7[-20]
800088a6:	f0 1f 00 5f 	mcall	80008a20 <xQueueGenericReceive+0x1bc>

				if( xJustPeeking == pdFALSE )
800088aa:	ee f8 ff e0 	ld.w	r8,r7[-32]
800088ae:	58 08       	cp.w	r8,0
800088b0:	c2 51       	brne	800088fa <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800088b2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088b6:	70 e8       	ld.w	r8,r8[0x38]
800088b8:	f0 c9 00 01 	sub	r9,r8,1
800088bc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088c0:	91 e9       	st.w	r8[0x38],r9

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800088c2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088c6:	70 08       	ld.w	r8,r8[0x0]
800088c8:	58 08       	cp.w	r8,0
800088ca:	c0 81       	brne	800088da <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800088cc:	f0 1f 00 56 	mcall	80008a24 <xQueueGenericReceive+0x1c0>
800088d0:	18 98       	mov	r8,r12
800088d2:	10 99       	mov	r9,r8
800088d4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088d8:	91 19       	st.w	r8[0x4],r9
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800088da:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088de:	70 48       	ld.w	r8,r8[0x10]
800088e0:	58 08       	cp.w	r8,0
800088e2:	c2 00       	breq	80008922 <xQueueGenericReceive+0xbe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800088e4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088e8:	2f 08       	sub	r8,-16
800088ea:	10 9c       	mov	r12,r8
800088ec:	f0 1f 00 4f 	mcall	80008a28 <xQueueGenericReceive+0x1c4>
800088f0:	18 98       	mov	r8,r12
800088f2:	58 18       	cp.w	r8,1
800088f4:	c1 71       	brne	80008922 <xQueueGenericReceive+0xbe>
						{
							portYIELD_WITHIN_API();
800088f6:	d7 33       	scall
800088f8:	c1 58       	rjmp	80008922 <xQueueGenericReceive+0xbe>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800088fa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088fe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008902:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008904:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008908:	70 98       	ld.w	r8,r8[0x24]
8000890a:	58 08       	cp.w	r8,0
8000890c:	c0 b0       	breq	80008922 <xQueueGenericReceive+0xbe>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000890e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008912:	2d c8       	sub	r8,-36
80008914:	10 9c       	mov	r12,r8
80008916:	f0 1f 00 45 	mcall	80008a28 <xQueueGenericReceive+0x1c4>
8000891a:	18 98       	mov	r8,r12
8000891c:	58 08       	cp.w	r8,0
8000891e:	c0 20       	breq	80008922 <xQueueGenericReceive+0xbe>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80008920:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80008922:	f0 1f 00 43 	mcall	80008a2c <xQueueGenericReceive+0x1c8>
				return pdPASS;
80008926:	30 18       	mov	r8,1
80008928:	c7 58       	rjmp	80008a12 <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000892a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000892e:	58 08       	cp.w	r8,0
80008930:	c0 51       	brne	8000893a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008932:	f0 1f 00 3f 	mcall	80008a2c <xQueueGenericReceive+0x1c8>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80008936:	30 08       	mov	r8,0
80008938:	c6 d8       	rjmp	80008a12 <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
8000893a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000893e:	58 08       	cp.w	r8,0
80008940:	c0 91       	brne	80008952 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008942:	ee c8 00 10 	sub	r8,r7,16
80008946:	10 9c       	mov	r12,r8
80008948:	f0 1f 00 3a 	mcall	80008a30 <xQueueGenericReceive+0x1cc>
					xEntryTimeSet = pdTRUE;
8000894c:	30 18       	mov	r8,1
8000894e:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80008952:	f0 1f 00 37 	mcall	80008a2c <xQueueGenericReceive+0x1c8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008956:	f0 1f 00 38 	mcall	80008a34 <xQueueGenericReceive+0x1d0>
		prvLockQueue( pxQueue );
8000895a:	f0 1f 00 31 	mcall	80008a1c <xQueueGenericReceive+0x1b8>
8000895e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008962:	71 18       	ld.w	r8,r8[0x44]
80008964:	5b f8       	cp.w	r8,-1
80008966:	c0 61       	brne	80008972 <xQueueGenericReceive+0x10e>
80008968:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000896c:	30 09       	mov	r9,0
8000896e:	f1 49 00 44 	st.w	r8[68],r9
80008972:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008976:	71 28       	ld.w	r8,r8[0x48]
80008978:	5b f8       	cp.w	r8,-1
8000897a:	c0 61       	brne	80008986 <xQueueGenericReceive+0x122>
8000897c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008980:	30 09       	mov	r9,0
80008982:	f1 49 00 48 	st.w	r8[72],r9
80008986:	f0 1f 00 2a 	mcall	80008a2c <xQueueGenericReceive+0x1c8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000898a:	ee c9 00 1c 	sub	r9,r7,28
8000898e:	ee c8 00 10 	sub	r8,r7,16
80008992:	12 9b       	mov	r11,r9
80008994:	10 9c       	mov	r12,r8
80008996:	f0 1f 00 29 	mcall	80008a38 <xQueueGenericReceive+0x1d4>
8000899a:	18 98       	mov	r8,r12
8000899c:	58 08       	cp.w	r8,0
8000899e:	c3 31       	brne	80008a04 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) )
800089a0:	ee fc ff ec 	ld.w	r12,r7[-20]
800089a4:	f0 1f 00 26 	mcall	80008a3c <xQueueGenericReceive+0x1d8>
800089a8:	18 98       	mov	r8,r12
800089aa:	58 08       	cp.w	r8,0
800089ac:	c2 50       	breq	800089f6 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800089ae:	ee f8 ff ec 	ld.w	r8,r7[-20]
800089b2:	70 08       	ld.w	r8,r8[0x0]
800089b4:	58 08       	cp.w	r8,0
800089b6:	c0 b1       	brne	800089cc <xQueueGenericReceive+0x168>
					{
						portENTER_CRITICAL();
800089b8:	f0 1f 00 19 	mcall	80008a1c <xQueueGenericReceive+0x1b8>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800089bc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800089c0:	70 18       	ld.w	r8,r8[0x4]
800089c2:	10 9c       	mov	r12,r8
800089c4:	f0 1f 00 1f 	mcall	80008a40 <xQueueGenericReceive+0x1dc>
						}
						portEXIT_CRITICAL();
800089c8:	f0 1f 00 19 	mcall	80008a2c <xQueueGenericReceive+0x1c8>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800089cc:	ee f9 ff e4 	ld.w	r9,r7[-28]
800089d0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800089d4:	2d c8       	sub	r8,-36
800089d6:	12 9b       	mov	r11,r9
800089d8:	10 9c       	mov	r12,r8
800089da:	f0 1f 00 1b 	mcall	80008a44 <xQueueGenericReceive+0x1e0>
				prvUnlockQueue( pxQueue );
800089de:	ee fc ff ec 	ld.w	r12,r7[-20]
800089e2:	f0 1f 00 1a 	mcall	80008a48 <xQueueGenericReceive+0x1e4>
				if( !xTaskResumeAll() )
800089e6:	f0 1f 00 1a 	mcall	80008a4c <xQueueGenericReceive+0x1e8>
800089ea:	18 98       	mov	r8,r12
800089ec:	58 08       	cp.w	r8,0
800089ee:	fe 91 ff 4b 	brne	80008884 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800089f2:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800089f4:	c4 9b       	rjmp	80008886 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800089f6:	ee fc ff ec 	ld.w	r12,r7[-20]
800089fa:	f0 1f 00 14 	mcall	80008a48 <xQueueGenericReceive+0x1e4>
				( void ) xTaskResumeAll();
800089fe:	f0 1f 00 14 	mcall	80008a4c <xQueueGenericReceive+0x1e8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80008a02:	c4 2b       	rjmp	80008886 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80008a04:	ee fc ff ec 	ld.w	r12,r7[-20]
80008a08:	f0 1f 00 10 	mcall	80008a48 <xQueueGenericReceive+0x1e4>
			( void ) xTaskResumeAll();
80008a0c:	f0 1f 00 10 	mcall	80008a4c <xQueueGenericReceive+0x1e8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
80008a10:	30 08       	mov	r8,0
		}
	}
}
80008a12:	10 9c       	mov	r12,r8
80008a14:	2f 8d       	sub	sp,-32
80008a16:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a1a:	00 00       	add	r0,r0
80008a1c:	80 00       	ld.sh	r0,r0[0x0]
80008a1e:	81 24       	st.w	r0[0x8],r4
80008a20:	80 00       	ld.sh	r0,r0[0x0]
80008a22:	8b f8       	st.w	r5[0x3c],r8
80008a24:	80 00       	ld.sh	r0,r0[0x0]
80008a26:	99 d0       	st.w	r12[0x34],r0
80008a28:	80 00       	ld.sh	r0,r0[0x0]
80008a2a:	94 c0       	ld.uh	r0,r10[0x8]
80008a2c:	80 00       	ld.sh	r0,r0[0x0]
80008a2e:	81 40       	st.w	r0[0x10],r0
80008a30:	80 00       	ld.sh	r0,r0[0x0]
80008a32:	95 90       	st.w	r10[0x24],r0
80008a34:	80 00       	ld.sh	r0,r0[0x0]
80008a36:	90 bc       	ld.uh	r12,r8[0x6]
80008a38:	80 00       	ld.sh	r0,r0[0x0]
80008a3a:	95 c0       	st.w	r10[0x30],r0
80008a3c:	80 00       	ld.sh	r0,r0[0x0]
80008a3e:	8d 34       	st.w	r6[0xc],r4
80008a40:	80 00       	ld.sh	r0,r0[0x0]
80008a42:	99 f0       	st.w	r12[0x3c],r0
80008a44:	80 00       	ld.sh	r0,r0[0x0]
80008a46:	94 40       	ld.sh	r0,r10[0x8]
80008a48:	80 00       	ld.sh	r0,r0[0x0]
80008a4a:	8c 64       	ld.sh	r4,r6[0xc]
80008a4c:	80 00       	ld.sh	r0,r0[0x0]
80008a4e:	90 d8       	ld.uh	r8,r8[0xa]

80008a50 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80008a50:	eb cd 40 80 	pushm	r7,lr
80008a54:	1a 97       	mov	r7,sp
80008a56:	20 5d       	sub	sp,20
80008a58:	ef 4c ff f4 	st.w	r7[-12],r12
80008a5c:	ef 4b ff f0 	st.w	r7[-16],r11
80008a60:	ef 4a ff ec 	st.w	r7[-20],r10

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80008a64:	30 08       	mov	r8,0
80008a66:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008a6a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a6e:	70 e8       	ld.w	r8,r8[0x38]
80008a70:	58 08       	cp.w	r8,0
80008a72:	c3 40       	breq	80008ada <xQueueReceiveFromISR+0x8a>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80008a74:	ee fb ff f0 	ld.w	r11,r7[-16]
80008a78:	ee fc ff f4 	ld.w	r12,r7[-12]
80008a7c:	f0 1f 00 1c 	mcall	80008aec <xQueueReceiveFromISR+0x9c>
			--( pxQueue->uxMessagesWaiting );
80008a80:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a84:	70 e8       	ld.w	r8,r8[0x38]
80008a86:	f0 c9 00 01 	sub	r9,r8,1
80008a8a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a8e:	91 e9       	st.w	r8[0x38],r9

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80008a90:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a94:	71 18       	ld.w	r8,r8[0x44]
80008a96:	5b f8       	cp.w	r8,-1
80008a98:	c1 41       	brne	80008ac0 <xQueueReceiveFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008a9a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a9e:	70 48       	ld.w	r8,r8[0x10]
80008aa0:	58 08       	cp.w	r8,0
80008aa2:	c1 80       	breq	80008ad2 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008aa4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008aa8:	2f 08       	sub	r8,-16
80008aaa:	10 9c       	mov	r12,r8
80008aac:	f0 1f 00 11 	mcall	80008af0 <xQueueReceiveFromISR+0xa0>
80008ab0:	18 98       	mov	r8,r12
80008ab2:	58 08       	cp.w	r8,0
80008ab4:	c0 f0       	breq	80008ad2 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80008ab6:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008aba:	30 19       	mov	r9,1
80008abc:	91 09       	st.w	r8[0x0],r9
80008abe:	c0 a8       	rjmp	80008ad2 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80008ac0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ac4:	71 18       	ld.w	r8,r8[0x44]
80008ac6:	f0 c9 ff ff 	sub	r9,r8,-1
80008aca:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ace:	f1 49 00 44 	st.w	r8[68],r9
			}

			xReturn = pdPASS;
80008ad2:	30 18       	mov	r8,1
80008ad4:	ef 48 ff f8 	st.w	r7[-8],r8
80008ad8:	c0 48       	rjmp	80008ae0 <xQueueReceiveFromISR+0x90>
		}
		else
		{
			xReturn = pdFAIL;
80008ada:	30 08       	mov	r8,0
80008adc:	ef 48 ff f8 	st.w	r7[-8],r8
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
80008ae0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008ae4:	10 9c       	mov	r12,r8
80008ae6:	2f bd       	sub	sp,-20
80008ae8:	e3 cd 80 80 	ldm	sp++,r7,pc
80008aec:	80 00       	ld.sh	r0,r0[0x0]
80008aee:	8b f8       	st.w	r5[0x3c],r8
80008af0:	80 00       	ld.sh	r0,r0[0x0]
80008af2:	94 c0       	ld.uh	r0,r10[0x8]

80008af4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80008af4:	eb cd 40 80 	pushm	r7,lr
80008af8:	1a 97       	mov	r7,sp
80008afa:	20 3d       	sub	sp,12
80008afc:	ef 4c ff fc 	st.w	r7[-4],r12
80008b00:	ef 4b ff f8 	st.w	r7[-8],r11
80008b04:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80008b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b0c:	71 08       	ld.w	r8,r8[0x40]
80008b0e:	58 08       	cp.w	r8,0
80008b10:	c1 11       	brne	80008b32 <prvCopyDataToQueue+0x3e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b16:	70 08       	ld.w	r8,r8[0x0]
80008b18:	58 08       	cp.w	r8,0
80008b1a:	c5 f1       	brne	80008bd8 <prvCopyDataToQueue+0xe4>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80008b1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b20:	70 18       	ld.w	r8,r8[0x4]
80008b22:	10 9c       	mov	r12,r8
80008b24:	f0 1f 00 33 	mcall	80008bf0 <prvCopyDataToQueue+0xfc>
				pxQueue->pxMutexHolder = NULL;
80008b28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b2c:	30 09       	mov	r9,0
80008b2e:	91 19       	st.w	r8[0x4],r9
80008b30:	c5 48       	rjmp	80008bd8 <prvCopyDataToQueue+0xe4>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80008b32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008b36:	58 08       	cp.w	r8,0
80008b38:	c2 61       	brne	80008b84 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008b3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b3e:	71 09       	ld.w	r9,r8[0x40]
80008b40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b44:	70 28       	ld.w	r8,r8[0x8]
80008b46:	12 9a       	mov	r10,r9
80008b48:	ee fb ff f8 	ld.w	r11,r7[-8]
80008b4c:	10 9c       	mov	r12,r8
80008b4e:	f0 1f 00 2a 	mcall	80008bf4 <prvCopyDataToQueue+0x100>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80008b52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b56:	70 29       	ld.w	r9,r8[0x8]
80008b58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b5c:	71 08       	ld.w	r8,r8[0x40]
80008b5e:	10 09       	add	r9,r8
80008b60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b64:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80008b66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b6a:	70 29       	ld.w	r9,r8[0x8]
80008b6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b70:	70 18       	ld.w	r8,r8[0x4]
80008b72:	10 39       	cp.w	r9,r8
80008b74:	c3 23       	brcs	80008bd8 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80008b76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b7a:	70 09       	ld.w	r9,r8[0x0]
80008b7c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b80:	91 29       	st.w	r8[0x8],r9
80008b82:	c2 b8       	rjmp	80008bd8 <prvCopyDataToQueue+0xe4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008b84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b88:	71 09       	ld.w	r9,r8[0x40]
80008b8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b8e:	70 38       	ld.w	r8,r8[0xc]
80008b90:	12 9a       	mov	r10,r9
80008b92:	ee fb ff f8 	ld.w	r11,r7[-8]
80008b96:	10 9c       	mov	r12,r8
80008b98:	f0 1f 00 17 	mcall	80008bf4 <prvCopyDataToQueue+0x100>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80008b9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ba0:	70 39       	ld.w	r9,r8[0xc]
80008ba2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ba6:	71 08       	ld.w	r8,r8[0x40]
80008ba8:	5c 38       	neg	r8
80008baa:	10 09       	add	r9,r8
80008bac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bb0:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80008bb2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bb6:	70 39       	ld.w	r9,r8[0xc]
80008bb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bbc:	70 08       	ld.w	r8,r8[0x0]
80008bbe:	10 39       	cp.w	r9,r8
80008bc0:	c0 c2       	brcc	80008bd8 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80008bc2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bc6:	70 19       	ld.w	r9,r8[0x4]
80008bc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bcc:	71 08       	ld.w	r8,r8[0x40]
80008bce:	5c 38       	neg	r8
80008bd0:	10 09       	add	r9,r8
80008bd2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bd6:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80008bd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bdc:	70 e8       	ld.w	r8,r8[0x38]
80008bde:	f0 c9 ff ff 	sub	r9,r8,-1
80008be2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008be6:	91 e9       	st.w	r8[0x38],r9
}
80008be8:	2f dd       	sub	sp,-12
80008bea:	e3 cd 80 80 	ldm	sp++,r7,pc
80008bee:	00 00       	add	r0,r0
80008bf0:	80 00       	ld.sh	r0,r0[0x0]
80008bf2:	9a c4       	ld.uh	r4,sp[0x8]
80008bf4:	80 00       	ld.sh	r0,r0[0x0]
80008bf6:	ac 76       	st.h	r6[0xe],r6

80008bf8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008bf8:	eb cd 40 80 	pushm	r7,lr
80008bfc:	1a 97       	mov	r7,sp
80008bfe:	20 2d       	sub	sp,8
80008c00:	ef 4c ff fc 	st.w	r7[-4],r12
80008c04:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80008c08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c0c:	70 08       	ld.w	r8,r8[0x0]
80008c0e:	58 08       	cp.w	r8,0
80008c10:	c2 50       	breq	80008c5a <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80008c12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c16:	70 39       	ld.w	r9,r8[0xc]
80008c18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c1c:	71 08       	ld.w	r8,r8[0x40]
80008c1e:	10 09       	add	r9,r8
80008c20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c24:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80008c26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c2a:	70 39       	ld.w	r9,r8[0xc]
80008c2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c30:	70 18       	ld.w	r8,r8[0x4]
80008c32:	10 39       	cp.w	r9,r8
80008c34:	c0 73       	brcs	80008c42 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80008c36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c3a:	70 09       	ld.w	r9,r8[0x0]
80008c3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c40:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80008c42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c46:	71 09       	ld.w	r9,r8[0x40]
80008c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c4c:	70 38       	ld.w	r8,r8[0xc]
80008c4e:	12 9a       	mov	r10,r9
80008c50:	10 9b       	mov	r11,r8
80008c52:	ee fc ff f8 	ld.w	r12,r7[-8]
80008c56:	f0 1f 00 03 	mcall	80008c60 <prvCopyDataFromQueue+0x68>
	}
}
80008c5a:	2f ed       	sub	sp,-8
80008c5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008c60:	80 00       	ld.sh	r0,r0[0x0]
80008c62:	ac 76       	st.h	r6[0xe],r6

80008c64 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80008c64:	eb cd 40 80 	pushm	r7,lr
80008c68:	1a 97       	mov	r7,sp
80008c6a:	20 1d       	sub	sp,4
80008c6c:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80008c70:	f0 1f 00 2d 	mcall	80008d24 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008c74:	c1 a8       	rjmp	80008ca8 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008c76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c7a:	70 98       	ld.w	r8,r8[0x24]
80008c7c:	58 08       	cp.w	r8,0
80008c7e:	c1 c0       	breq	80008cb6 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008c80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c84:	2d c8       	sub	r8,-36
80008c86:	10 9c       	mov	r12,r8
80008c88:	f0 1f 00 28 	mcall	80008d28 <prvUnlockQueue+0xc4>
80008c8c:	18 98       	mov	r8,r12
80008c8e:	58 08       	cp.w	r8,0
80008c90:	c0 30       	breq	80008c96 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80008c92:	f0 1f 00 27 	mcall	80008d2c <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80008c96:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008c9a:	71 28       	ld.w	r8,r8[0x48]
80008c9c:	f0 c9 00 01 	sub	r9,r8,1
80008ca0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ca4:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008ca8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cac:	71 28       	ld.w	r8,r8[0x48]
80008cae:	58 08       	cp.w	r8,0
80008cb0:	fe 99 ff e3 	brgt	80008c76 <prvUnlockQueue+0x12>
80008cb4:	c0 28       	rjmp	80008cb8 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
80008cb6:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80008cb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cbc:	3f f9       	mov	r9,-1
80008cbe:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
80008cc2:	f0 1f 00 1c 	mcall	80008d30 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80008cc6:	f0 1f 00 18 	mcall	80008d24 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008cca:	c1 a8       	rjmp	80008cfe <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008ccc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cd0:	70 48       	ld.w	r8,r8[0x10]
80008cd2:	58 08       	cp.w	r8,0
80008cd4:	c1 c0       	breq	80008d0c <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008cd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cda:	2f 08       	sub	r8,-16
80008cdc:	10 9c       	mov	r12,r8
80008cde:	f0 1f 00 13 	mcall	80008d28 <prvUnlockQueue+0xc4>
80008ce2:	18 98       	mov	r8,r12
80008ce4:	58 08       	cp.w	r8,0
80008ce6:	c0 30       	breq	80008cec <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
80008ce8:	f0 1f 00 11 	mcall	80008d2c <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
80008cec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cf0:	71 18       	ld.w	r8,r8[0x44]
80008cf2:	f0 c9 00 01 	sub	r9,r8,1
80008cf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cfa:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008cfe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008d02:	71 18       	ld.w	r8,r8[0x44]
80008d04:	58 08       	cp.w	r8,0
80008d06:	fe 99 ff e3 	brgt	80008ccc <prvUnlockQueue+0x68>
80008d0a:	c0 28       	rjmp	80008d0e <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80008d0c:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80008d0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008d12:	3f f9       	mov	r9,-1
80008d14:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80008d18:	f0 1f 00 06 	mcall	80008d30 <prvUnlockQueue+0xcc>
}
80008d1c:	2f fd       	sub	sp,-4
80008d1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008d22:	00 00       	add	r0,r0
80008d24:	80 00       	ld.sh	r0,r0[0x0]
80008d26:	81 24       	st.w	r0[0x8],r4
80008d28:	80 00       	ld.sh	r0,r0[0x0]
80008d2a:	94 c0       	ld.uh	r0,r10[0x8]
80008d2c:	80 00       	ld.sh	r0,r0[0x0]
80008d2e:	96 78       	ld.sh	r8,r11[0xe]
80008d30:	80 00       	ld.sh	r0,r0[0x0]
80008d32:	81 40       	st.w	r0[0x10],r0

80008d34 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80008d34:	eb cd 40 80 	pushm	r7,lr
80008d38:	1a 97       	mov	r7,sp
80008d3a:	20 2d       	sub	sp,8
80008d3c:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008d40:	f0 1f 00 09 	mcall	80008d64 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80008d44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d48:	70 e8       	ld.w	r8,r8[0x38]
80008d4a:	58 08       	cp.w	r8,0
80008d4c:	5f 08       	sreq	r8
80008d4e:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80008d52:	f0 1f 00 06 	mcall	80008d68 <prvIsQueueEmpty+0x34>

	return xReturn;
80008d56:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008d5a:	10 9c       	mov	r12,r8
80008d5c:	2f ed       	sub	sp,-8
80008d5e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008d62:	00 00       	add	r0,r0
80008d64:	80 00       	ld.sh	r0,r0[0x0]
80008d66:	81 24       	st.w	r0[0x8],r4
80008d68:	80 00       	ld.sh	r0,r0[0x0]
80008d6a:	81 40       	st.w	r0[0x10],r0

80008d6c <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80008d6c:	eb cd 40 80 	pushm	r7,lr
80008d70:	1a 97       	mov	r7,sp
80008d72:	20 2d       	sub	sp,8
80008d74:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008d78:	f0 1f 00 0a 	mcall	80008da0 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80008d7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d80:	70 e9       	ld.w	r9,r8[0x38]
80008d82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d86:	70 f8       	ld.w	r8,r8[0x3c]
80008d88:	10 39       	cp.w	r9,r8
80008d8a:	5f 08       	sreq	r8
80008d8c:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80008d90:	f0 1f 00 05 	mcall	80008da4 <prvIsQueueFull+0x38>

	return xReturn;
80008d94:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008d98:	10 9c       	mov	r12,r8
80008d9a:	2f ed       	sub	sp,-8
80008d9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008da0:	80 00       	ld.sh	r0,r0[0x0]
80008da2:	81 24       	st.w	r0[0x8],r4
80008da4:	80 00       	ld.sh	r0,r0[0x0]
80008da6:	81 40       	st.w	r0[0x10],r0
80008da8:	49 44       	lddpc	r4,80008df8 <xTaskGenericCreate+0x48>
80008daa:	4c 45       	lddpc	r5,80008eb8 <xTaskGenericCreate+0x108>
80008dac:	00 00       	add	r0,r0
	...

80008db0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80008db0:	eb cd 40 c0 	pushm	r6-r7,lr
80008db4:	1a 97       	mov	r7,sp
80008db6:	20 8d       	sub	sp,32
80008db8:	ee c6 ff f4 	sub	r6,r7,-12
80008dbc:	ef 4c ff f0 	st.w	r7[-16],r12
80008dc0:	ef 4b ff ec 	st.w	r7[-20],r11
80008dc4:	ef 49 ff e4 	st.w	r7[-28],r9
80008dc8:	ef 48 ff e0 	st.w	r7[-32],r8
80008dcc:	14 98       	mov	r8,r10
80008dce:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80008dd2:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80008dd6:	6c 1b       	ld.w	r11,r6[0x4]
80008dd8:	10 9c       	mov	r12,r8
80008dda:	f0 1f 00 5a 	mcall	80008f40 <xTaskGenericCreate+0x190>
80008dde:	18 98       	mov	r8,r12
80008de0:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80008de4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008de8:	58 08       	cp.w	r8,0
80008dea:	e0 80 00 92 	breq	80008f0e <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80008dee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008df2:	70 c9       	ld.w	r9,r8[0x30]
80008df4:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80008df8:	20 18       	sub	r8,1
80008dfa:	a3 68       	lsl	r8,0x2
80008dfc:	f2 08 00 08 	add	r8,r9,r8
80008e00:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80008e04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008e08:	e0 18 ff fc 	andl	r8,0xfffc
80008e0c:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80008e10:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80008e14:	6c 29       	ld.w	r9,r6[0x8]
80008e16:	ee fa ff e0 	ld.w	r10,r7[-32]
80008e1a:	ee fb ff ec 	ld.w	r11,r7[-20]
80008e1e:	ee fc ff f8 	ld.w	r12,r7[-8]
80008e22:	f0 1f 00 49 	mcall	80008f44 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80008e26:	ee fa ff e4 	ld.w	r10,r7[-28]
80008e2a:	ee fb ff f0 	ld.w	r11,r7[-16]
80008e2e:	ee fc ff fc 	ld.w	r12,r7[-4]
80008e32:	f0 1f 00 46 	mcall	80008f48 <xTaskGenericCreate+0x198>
80008e36:	18 98       	mov	r8,r12
80008e38:	10 99       	mov	r9,r8
80008e3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008e3e:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80008e40:	6c 08       	ld.w	r8,r6[0x0]
80008e42:	58 08       	cp.w	r8,0
80008e44:	c0 50       	breq	80008e4e <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80008e46:	6c 08       	ld.w	r8,r6[0x0]
80008e48:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008e4c:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80008e4e:	f0 1f 00 40 	mcall	80008f4c <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80008e52:	4c 08       	lddpc	r8,80008f50 <xTaskGenericCreate+0x1a0>
80008e54:	70 08       	ld.w	r8,r8[0x0]
80008e56:	f0 c9 ff ff 	sub	r9,r8,-1
80008e5a:	4b e8       	lddpc	r8,80008f50 <xTaskGenericCreate+0x1a0>
80008e5c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80008e5e:	4b e8       	lddpc	r8,80008f54 <xTaskGenericCreate+0x1a4>
80008e60:	70 08       	ld.w	r8,r8[0x0]
80008e62:	58 08       	cp.w	r8,0
80008e64:	c0 c1       	brne	80008e7c <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80008e66:	4b c8       	lddpc	r8,80008f54 <xTaskGenericCreate+0x1a4>
80008e68:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008e6c:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80008e6e:	4b 98       	lddpc	r8,80008f50 <xTaskGenericCreate+0x1a0>
80008e70:	70 08       	ld.w	r8,r8[0x0]
80008e72:	58 18       	cp.w	r8,1
80008e74:	c1 41       	brne	80008e9c <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80008e76:	f0 1f 00 39 	mcall	80008f58 <xTaskGenericCreate+0x1a8>
80008e7a:	c1 18       	rjmp	80008e9c <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80008e7c:	4b 88       	lddpc	r8,80008f5c <xTaskGenericCreate+0x1ac>
80008e7e:	70 08       	ld.w	r8,r8[0x0]
80008e80:	58 08       	cp.w	r8,0
80008e82:	c0 d1       	brne	80008e9c <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80008e84:	4b 48       	lddpc	r8,80008f54 <xTaskGenericCreate+0x1a4>
80008e86:	70 08       	ld.w	r8,r8[0x0]
80008e88:	70 b9       	ld.w	r9,r8[0x2c]
80008e8a:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008e8e:	10 39       	cp.w	r9,r8
80008e90:	e0 8b 00 06 	brhi	80008e9c <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80008e94:	4b 08       	lddpc	r8,80008f54 <xTaskGenericCreate+0x1a4>
80008e96:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008e9a:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80008e9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ea0:	70 b9       	ld.w	r9,r8[0x2c]
80008ea2:	4b 08       	lddpc	r8,80008f60 <xTaskGenericCreate+0x1b0>
80008ea4:	70 08       	ld.w	r8,r8[0x0]
80008ea6:	10 39       	cp.w	r9,r8
80008ea8:	e0 88 00 07 	brls	80008eb6 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80008eac:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008eb0:	70 b9       	ld.w	r9,r8[0x2c]
80008eb2:	4a c8       	lddpc	r8,80008f60 <xTaskGenericCreate+0x1b0>
80008eb4:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80008eb6:	4a c8       	lddpc	r8,80008f64 <xTaskGenericCreate+0x1b4>
80008eb8:	70 08       	ld.w	r8,r8[0x0]
80008eba:	f0 c9 ff ff 	sub	r9,r8,-1
80008ebe:	4a a8       	lddpc	r8,80008f64 <xTaskGenericCreate+0x1b4>
80008ec0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80008ec2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ec6:	70 b9       	ld.w	r9,r8[0x2c]
80008ec8:	4a 88       	lddpc	r8,80008f68 <xTaskGenericCreate+0x1b8>
80008eca:	70 08       	ld.w	r8,r8[0x0]
80008ecc:	10 39       	cp.w	r9,r8
80008ece:	e0 88 00 07 	brls	80008edc <xTaskGenericCreate+0x12c>
80008ed2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ed6:	70 b9       	ld.w	r9,r8[0x2c]
80008ed8:	4a 48       	lddpc	r8,80008f68 <xTaskGenericCreate+0x1b8>
80008eda:	91 09       	st.w	r8[0x0],r9
80008edc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ee0:	f0 ca ff fc 	sub	r10,r8,-4
80008ee4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ee8:	70 b9       	ld.w	r9,r8[0x2c]
80008eea:	12 98       	mov	r8,r9
80008eec:	a3 68       	lsl	r8,0x2
80008eee:	12 08       	add	r8,r9
80008ef0:	a3 68       	lsl	r8,0x2
80008ef2:	10 99       	mov	r9,r8
80008ef4:	49 e8       	lddpc	r8,80008f6c <xTaskGenericCreate+0x1bc>
80008ef6:	f2 08 00 08 	add	r8,r9,r8
80008efa:	14 9b       	mov	r11,r10
80008efc:	10 9c       	mov	r12,r8
80008efe:	f0 1f 00 1d 	mcall	80008f70 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80008f02:	30 18       	mov	r8,1
80008f04:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80008f08:	f0 1f 00 1b 	mcall	80008f74 <xTaskGenericCreate+0x1c4>
80008f0c:	c0 48       	rjmp	80008f14 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80008f0e:	3f f8       	mov	r8,-1
80008f10:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80008f14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008f18:	58 18       	cp.w	r8,1
80008f1a:	c0 d1       	brne	80008f34 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80008f1c:	49 08       	lddpc	r8,80008f5c <xTaskGenericCreate+0x1ac>
80008f1e:	70 08       	ld.w	r8,r8[0x0]
80008f20:	58 08       	cp.w	r8,0
80008f22:	c0 90       	breq	80008f34 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80008f24:	48 c8       	lddpc	r8,80008f54 <xTaskGenericCreate+0x1a4>
80008f26:	70 08       	ld.w	r8,r8[0x0]
80008f28:	70 b9       	ld.w	r9,r8[0x2c]
80008f2a:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008f2e:	10 39       	cp.w	r9,r8
80008f30:	c0 22       	brcc	80008f34 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80008f32:	d7 33       	scall
			}
		}
	}

	return xReturn;
80008f34:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80008f38:	10 9c       	mov	r12,r8
80008f3a:	2f 8d       	sub	sp,-32
80008f3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008f40:	80 00       	ld.sh	r0,r0[0x0]
80008f42:	99 10       	st.w	r12[0x4],r0
80008f44:	80 00       	ld.sh	r0,r0[0x0]
80008f46:	96 bc       	ld.uh	r12,r11[0x6]
80008f48:	80 00       	ld.sh	r0,r0[0x0]
80008f4a:	81 6c       	st.w	r0[0x18],r12
80008f4c:	80 00       	ld.sh	r0,r0[0x0]
80008f4e:	81 24       	st.w	r0[0x8],r4
80008f50:	00 00       	add	r0,r0
80008f52:	0d 2c       	ld.uh	r12,r6++
80008f54:	00 00       	add	r0,r0
80008f56:	0c 18       	sub	r8,r6
80008f58:	80 00       	ld.sh	r0,r0[0x0]
80008f5a:	97 64       	st.w	r11[0x18],r4
80008f5c:	00 00       	add	r0,r0
80008f5e:	0d 3c       	ld.ub	r12,r6++
80008f60:	00 00       	add	r0,r0
80008f62:	0d 34       	ld.ub	r4,r6++
80008f64:	00 00       	add	r0,r0
80008f66:	0d 50       	ld.sh	r0,--r6
80008f68:	00 00       	add	r0,r0
80008f6a:	0d 38       	ld.ub	r8,r6++
80008f6c:	00 00       	add	r0,r0
80008f6e:	0c 1c       	sub	r12,r6
80008f70:	80 00       	ld.sh	r0,r0[0x0]
80008f72:	7e 52       	ld.w	r2,pc[0x14]
80008f74:	80 00       	ld.sh	r0,r0[0x0]
80008f76:	81 40       	st.w	r0[0x10],r0

80008f78 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80008f78:	eb cd 40 80 	pushm	r7,lr
80008f7c:	1a 97       	mov	r7,sp
80008f7e:	20 5d       	sub	sp,20
80008f80:	ef 4c ff f0 	st.w	r7[-16],r12
80008f84:	ef 4b ff ec 	st.w	r7[-20],r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
80008f88:	30 08       	mov	r8,0
80008f8a:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80008f8e:	f0 1f 00 2d 	mcall	80009040 <vTaskDelayUntil+0xc8>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80008f92:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008f96:	70 09       	ld.w	r9,r8[0x0]
80008f98:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008f9c:	f2 08 00 08 	add	r8,r9,r8
80008fa0:	ef 48 ff f4 	st.w	r7[-12],r8

			if( xTickCount < *pxPreviousWakeTime )
80008fa4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008fa8:	70 09       	ld.w	r9,r8[0x0]
80008faa:	4a 78       	lddpc	r8,80009044 <vTaskDelayUntil+0xcc>
80008fac:	70 08       	ld.w	r8,r8[0x0]
80008fae:	10 39       	cp.w	r9,r8
80008fb0:	e0 88 00 15 	brls	80008fda <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80008fb4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008fb8:	70 09       	ld.w	r9,r8[0x0]
80008fba:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008fbe:	10 39       	cp.w	r9,r8
80008fc0:	e0 88 00 1f 	brls	80008ffe <vTaskDelayUntil+0x86>
80008fc4:	4a 08       	lddpc	r8,80009044 <vTaskDelayUntil+0xcc>
80008fc6:	70 08       	ld.w	r8,r8[0x0]
80008fc8:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008fcc:	10 39       	cp.w	r9,r8
80008fce:	e0 88 00 18 	brls	80008ffe <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80008fd2:	30 18       	mov	r8,1
80008fd4:	ef 48 ff fc 	st.w	r7[-4],r8
80008fd8:	c1 38       	rjmp	80008ffe <vTaskDelayUntil+0x86>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80008fda:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008fde:	70 09       	ld.w	r9,r8[0x0]
80008fe0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008fe4:	10 39       	cp.w	r9,r8
80008fe6:	e0 8b 00 09 	brhi	80008ff8 <vTaskDelayUntil+0x80>
80008fea:	49 78       	lddpc	r8,80009044 <vTaskDelayUntil+0xcc>
80008fec:	70 08       	ld.w	r8,r8[0x0]
80008fee:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008ff2:	10 39       	cp.w	r9,r8
80008ff4:	e0 88 00 05 	brls	80008ffe <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80008ff8:	30 18       	mov	r8,1
80008ffa:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80008ffe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009002:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009006:	91 09       	st.w	r8[0x0],r9

			if( xShouldDelay != pdFALSE )
80009008:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000900c:	58 08       	cp.w	r8,0
8000900e:	c0 b0       	breq	80009024 <vTaskDelayUntil+0xac>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009010:	48 e8       	lddpc	r8,80009048 <vTaskDelayUntil+0xd0>
80009012:	70 08       	ld.w	r8,r8[0x0]
80009014:	2f c8       	sub	r8,-4
80009016:	10 9c       	mov	r12,r8
80009018:	f0 1f 00 0d 	mcall	8000904c <vTaskDelayUntil+0xd4>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000901c:	ee fc ff f4 	ld.w	r12,r7[-12]
80009020:	f0 1f 00 0c 	mcall	80009050 <vTaskDelayUntil+0xd8>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009024:	f0 1f 00 0c 	mcall	80009054 <vTaskDelayUntil+0xdc>
80009028:	18 98       	mov	r8,r12
8000902a:	ef 48 ff f8 	st.w	r7[-8],r8

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000902e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009032:	58 08       	cp.w	r8,0
80009034:	c0 21       	brne	80009038 <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
80009036:	d7 33       	scall
		}
	}
80009038:	2f bd       	sub	sp,-20
8000903a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000903e:	00 00       	add	r0,r0
80009040:	80 00       	ld.sh	r0,r0[0x0]
80009042:	90 bc       	ld.uh	r12,r8[0x6]
80009044:	00 00       	add	r0,r0
80009046:	0d 30       	ld.ub	r0,r6++
80009048:	00 00       	add	r0,r0
8000904a:	0c 18       	sub	r8,r6
8000904c:	80 00       	ld.sh	r0,r0[0x0]
8000904e:	7f 66       	ld.w	r6,pc[0x58]
80009050:	80 00       	ld.sh	r0,r0[0x0]
80009052:	98 90       	ld.uh	r0,r12[0x2]
80009054:	80 00       	ld.sh	r0,r0[0x0]
80009056:	90 d8       	ld.uh	r8,r8[0xa]

80009058 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009058:	eb cd 40 80 	pushm	r7,lr
8000905c:	1a 97       	mov	r7,sp
8000905e:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80009060:	49 1b       	lddpc	r11,800090a4 <vTaskStartScheduler+0x4c>
80009062:	30 08       	mov	r8,0
80009064:	1a d8       	st.w	--sp,r8
80009066:	30 08       	mov	r8,0
80009068:	1a d8       	st.w	--sp,r8
8000906a:	30 08       	mov	r8,0
8000906c:	1a d8       	st.w	--sp,r8
8000906e:	30 08       	mov	r8,0
80009070:	30 09       	mov	r9,0
80009072:	e0 6a 01 00 	mov	r10,256
80009076:	48 dc       	lddpc	r12,800090a8 <vTaskStartScheduler+0x50>
80009078:	f0 1f 00 0d 	mcall	800090ac <vTaskStartScheduler+0x54>
8000907c:	2f dd       	sub	sp,-12
8000907e:	18 98       	mov	r8,r12
80009080:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009084:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009088:	58 18       	cp.w	r8,1
8000908a:	c0 a1       	brne	8000909e <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000908c:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000908e:	48 98       	lddpc	r8,800090b0 <vTaskStartScheduler+0x58>
80009090:	30 19       	mov	r9,1
80009092:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80009094:	48 88       	lddpc	r8,800090b4 <vTaskStartScheduler+0x5c>
80009096:	30 09       	mov	r9,0
80009098:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
8000909a:	f0 1f 00 08 	mcall	800090b8 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
8000909e:	2f fd       	sub	sp,-4
800090a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800090a4:	80 00       	ld.sh	r0,r0[0x0]
800090a6:	8d a8       	st.w	r6[0x28],r8
800090a8:	80 00       	ld.sh	r0,r0[0x0]
800090aa:	96 8c       	ld.uh	r12,r11[0x0]
800090ac:	80 00       	ld.sh	r0,r0[0x0]
800090ae:	8d b0       	st.w	r6[0x2c],r0
800090b0:	00 00       	add	r0,r0
800090b2:	0d 3c       	ld.ub	r12,r6++
800090b4:	00 00       	add	r0,r0
800090b6:	0d 30       	ld.ub	r0,r6++
800090b8:	80 00       	ld.sh	r0,r0[0x0]
800090ba:	83 14       	st.w	r1[0x4],r4

800090bc <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
800090bc:	eb cd 40 80 	pushm	r7,lr
800090c0:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800090c2:	48 58       	lddpc	r8,800090d4 <vTaskSuspendAll+0x18>
800090c4:	70 08       	ld.w	r8,r8[0x0]
800090c6:	f0 c9 ff ff 	sub	r9,r8,-1
800090ca:	48 38       	lddpc	r8,800090d4 <vTaskSuspendAll+0x18>
800090cc:	91 09       	st.w	r8[0x0],r9
}
800090ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800090d2:	00 00       	add	r0,r0
800090d4:	00 00       	add	r0,r0
800090d6:	0d 40       	ld.w	r0,--r6

800090d8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800090d8:	eb cd 40 c0 	pushm	r6-r7,lr
800090dc:	1a 97       	mov	r7,sp
800090de:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
800090e0:	30 08       	mov	r8,0
800090e2:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800090e6:	f0 1f 00 3a 	mcall	800091cc <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
800090ea:	4b a8       	lddpc	r8,800091d0 <xTaskResumeAll+0xf8>
800090ec:	70 08       	ld.w	r8,r8[0x0]
800090ee:	f0 c9 00 01 	sub	r9,r8,1
800090f2:	4b 88       	lddpc	r8,800091d0 <xTaskResumeAll+0xf8>
800090f4:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800090f6:	4b 78       	lddpc	r8,800091d0 <xTaskResumeAll+0xf8>
800090f8:	70 08       	ld.w	r8,r8[0x0]
800090fa:	58 08       	cp.w	r8,0
800090fc:	c5 f1       	brne	800091ba <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800090fe:	4b 68       	lddpc	r8,800091d4 <xTaskResumeAll+0xfc>
80009100:	70 08       	ld.w	r8,r8[0x0]
80009102:	58 08       	cp.w	r8,0
80009104:	c5 b0       	breq	800091ba <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80009106:	30 08       	mov	r8,0
80009108:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000910c:	c3 08       	rjmp	8000916c <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000910e:	4b 38       	lddpc	r8,800091d8 <xTaskResumeAll+0x100>
80009110:	70 38       	ld.w	r8,r8[0xc]
80009112:	70 38       	ld.w	r8,r8[0xc]
80009114:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80009116:	ec c8 ff e8 	sub	r8,r6,-24
8000911a:	10 9c       	mov	r12,r8
8000911c:	f0 1f 00 30 	mcall	800091dc <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80009120:	ec c8 ff fc 	sub	r8,r6,-4
80009124:	10 9c       	mov	r12,r8
80009126:	f0 1f 00 2e 	mcall	800091dc <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
8000912a:	6c b9       	ld.w	r9,r6[0x2c]
8000912c:	4a d8       	lddpc	r8,800091e0 <xTaskResumeAll+0x108>
8000912e:	70 08       	ld.w	r8,r8[0x0]
80009130:	10 39       	cp.w	r9,r8
80009132:	e0 88 00 05 	brls	8000913c <xTaskResumeAll+0x64>
80009136:	6c b9       	ld.w	r9,r6[0x2c]
80009138:	4a a8       	lddpc	r8,800091e0 <xTaskResumeAll+0x108>
8000913a:	91 09       	st.w	r8[0x0],r9
8000913c:	ec ca ff fc 	sub	r10,r6,-4
80009140:	6c b9       	ld.w	r9,r6[0x2c]
80009142:	12 98       	mov	r8,r9
80009144:	a3 68       	lsl	r8,0x2
80009146:	12 08       	add	r8,r9
80009148:	a3 68       	lsl	r8,0x2
8000914a:	10 99       	mov	r9,r8
8000914c:	4a 68       	lddpc	r8,800091e4 <xTaskResumeAll+0x10c>
8000914e:	f2 08 00 08 	add	r8,r9,r8
80009152:	14 9b       	mov	r11,r10
80009154:	10 9c       	mov	r12,r8
80009156:	f0 1f 00 25 	mcall	800091e8 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000915a:	6c b9       	ld.w	r9,r6[0x2c]
8000915c:	4a 48       	lddpc	r8,800091ec <xTaskResumeAll+0x114>
8000915e:	70 08       	ld.w	r8,r8[0x0]
80009160:	70 b8       	ld.w	r8,r8[0x2c]
80009162:	10 39       	cp.w	r9,r8
80009164:	c0 43       	brcs	8000916c <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80009166:	30 18       	mov	r8,1
80009168:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000916c:	49 b8       	lddpc	r8,800091d8 <xTaskResumeAll+0x100>
8000916e:	70 08       	ld.w	r8,r8[0x0]
80009170:	58 08       	cp.w	r8,0
80009172:	cc e1       	brne	8000910e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009174:	49 f8       	lddpc	r8,800091f0 <xTaskResumeAll+0x118>
80009176:	70 08       	ld.w	r8,r8[0x0]
80009178:	58 08       	cp.w	r8,0
8000917a:	c1 10       	breq	8000919c <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000917c:	c0 98       	rjmp	8000918e <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
8000917e:	f0 1f 00 1e 	mcall	800091f4 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80009182:	49 c8       	lddpc	r8,800091f0 <xTaskResumeAll+0x118>
80009184:	70 08       	ld.w	r8,r8[0x0]
80009186:	f0 c9 00 01 	sub	r9,r8,1
8000918a:	49 a8       	lddpc	r8,800091f0 <xTaskResumeAll+0x118>
8000918c:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000918e:	49 98       	lddpc	r8,800091f0 <xTaskResumeAll+0x118>
80009190:	70 08       	ld.w	r8,r8[0x0]
80009192:	58 08       	cp.w	r8,0
80009194:	cf 51       	brne	8000917e <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80009196:	30 18       	mov	r8,1
80009198:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000919c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800091a0:	58 18       	cp.w	r8,1
800091a2:	c0 50       	breq	800091ac <xTaskResumeAll+0xd4>
800091a4:	49 58       	lddpc	r8,800091f8 <xTaskResumeAll+0x120>
800091a6:	70 08       	ld.w	r8,r8[0x0]
800091a8:	58 18       	cp.w	r8,1
800091aa:	c0 81       	brne	800091ba <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
800091ac:	30 18       	mov	r8,1
800091ae:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
800091b2:	49 28       	lddpc	r8,800091f8 <xTaskResumeAll+0x120>
800091b4:	30 09       	mov	r9,0
800091b6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800091b8:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800091ba:	f0 1f 00 11 	mcall	800091fc <xTaskResumeAll+0x124>

	return xAlreadyYielded;
800091be:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800091c2:	10 9c       	mov	r12,r8
800091c4:	2f ed       	sub	sp,-8
800091c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800091ca:	00 00       	add	r0,r0
800091cc:	80 00       	ld.sh	r0,r0[0x0]
800091ce:	81 24       	st.w	r0[0x8],r4
800091d0:	00 00       	add	r0,r0
800091d2:	0d 40       	ld.w	r0,--r6
800091d4:	00 00       	add	r0,r0
800091d6:	0d 2c       	ld.uh	r12,r6++
800091d8:	00 00       	add	r0,r0
800091da:	0c ec       	st.h	--r6,r12
800091dc:	80 00       	ld.sh	r0,r0[0x0]
800091de:	7f 66       	ld.w	r6,pc[0x58]
800091e0:	00 00       	add	r0,r0
800091e2:	0d 38       	ld.ub	r8,r6++
800091e4:	00 00       	add	r0,r0
800091e6:	0c 1c       	sub	r12,r6
800091e8:	80 00       	ld.sh	r0,r0[0x0]
800091ea:	7e 52       	ld.w	r2,pc[0x14]
800091ec:	00 00       	add	r0,r0
800091ee:	0c 18       	sub	r8,r6
800091f0:	00 00       	add	r0,r0
800091f2:	0d 44       	ld.w	r4,--r6
800091f4:	80 00       	ld.sh	r0,r0[0x0]
800091f6:	92 30       	ld.sh	r0,r9[0x6]
800091f8:	00 00       	add	r0,r0
800091fa:	0d 48       	ld.w	r8,--r6
800091fc:	80 00       	ld.sh	r0,r0[0x0]
800091fe:	81 40       	st.w	r0[0x10],r0

80009200 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80009200:	eb cd 40 80 	pushm	r7,lr
80009204:	1a 97       	mov	r7,sp
80009206:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009208:	f0 1f 00 07 	mcall	80009224 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
8000920c:	48 78       	lddpc	r8,80009228 <xTaskGetTickCount+0x28>
8000920e:	70 08       	ld.w	r8,r8[0x0]
80009210:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80009214:	f0 1f 00 06 	mcall	8000922c <xTaskGetTickCount+0x2c>

	return xTicks;
80009218:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000921c:	10 9c       	mov	r12,r8
8000921e:	2f fd       	sub	sp,-4
80009220:	e3 cd 80 80 	ldm	sp++,r7,pc
80009224:	80 00       	ld.sh	r0,r0[0x0]
80009226:	81 24       	st.w	r0[0x8],r4
80009228:	00 00       	add	r0,r0
8000922a:	0d 30       	ld.ub	r0,r6++
8000922c:	80 00       	ld.sh	r0,r0[0x0]
8000922e:	81 40       	st.w	r0[0x10],r0

80009230 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009230:	eb cd 40 80 	pushm	r7,lr
80009234:	1a 97       	mov	r7,sp
80009236:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009238:	4c b8       	lddpc	r8,80009364 <vTaskIncrementTick+0x134>
8000923a:	70 08       	ld.w	r8,r8[0x0]
8000923c:	58 08       	cp.w	r8,0
8000923e:	e0 81 00 89 	brne	80009350 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80009242:	4c a8       	lddpc	r8,80009368 <vTaskIncrementTick+0x138>
80009244:	70 08       	ld.w	r8,r8[0x0]
80009246:	f0 c9 ff ff 	sub	r9,r8,-1
8000924a:	4c 88       	lddpc	r8,80009368 <vTaskIncrementTick+0x138>
8000924c:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000924e:	4c 78       	lddpc	r8,80009368 <vTaskIncrementTick+0x138>
80009250:	70 08       	ld.w	r8,r8[0x0]
80009252:	58 08       	cp.w	r8,0
80009254:	c2 71       	brne	800092a2 <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80009256:	4c 68       	lddpc	r8,8000936c <vTaskIncrementTick+0x13c>
80009258:	70 08       	ld.w	r8,r8[0x0]
8000925a:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000925e:	4c 58       	lddpc	r8,80009370 <vTaskIncrementTick+0x140>
80009260:	70 09       	ld.w	r9,r8[0x0]
80009262:	4c 38       	lddpc	r8,8000936c <vTaskIncrementTick+0x13c>
80009264:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80009266:	4c 38       	lddpc	r8,80009370 <vTaskIncrementTick+0x140>
80009268:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000926c:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
8000926e:	4c 28       	lddpc	r8,80009374 <vTaskIncrementTick+0x144>
80009270:	70 08       	ld.w	r8,r8[0x0]
80009272:	f0 c9 ff ff 	sub	r9,r8,-1
80009276:	4c 08       	lddpc	r8,80009374 <vTaskIncrementTick+0x144>
80009278:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000927a:	4b d8       	lddpc	r8,8000936c <vTaskIncrementTick+0x13c>
8000927c:	70 08       	ld.w	r8,r8[0x0]
8000927e:	70 08       	ld.w	r8,r8[0x0]
80009280:	58 08       	cp.w	r8,0
80009282:	c0 51       	brne	8000928c <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80009284:	4b d8       	lddpc	r8,80009378 <vTaskIncrementTick+0x148>
80009286:	3f f9       	mov	r9,-1
80009288:	91 09       	st.w	r8[0x0],r9
8000928a:	c0 c8       	rjmp	800092a2 <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000928c:	4b 88       	lddpc	r8,8000936c <vTaskIncrementTick+0x13c>
8000928e:	70 08       	ld.w	r8,r8[0x0]
80009290:	70 38       	ld.w	r8,r8[0xc]
80009292:	70 38       	ld.w	r8,r8[0xc]
80009294:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80009298:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000929c:	70 19       	ld.w	r9,r8[0x4]
8000929e:	4b 78       	lddpc	r8,80009378 <vTaskIncrementTick+0x148>
800092a0:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800092a2:	4b 28       	lddpc	r8,80009368 <vTaskIncrementTick+0x138>
800092a4:	70 09       	ld.w	r9,r8[0x0]
800092a6:	4b 58       	lddpc	r8,80009378 <vTaskIncrementTick+0x148>
800092a8:	70 08       	ld.w	r8,r8[0x0]
800092aa:	10 39       	cp.w	r9,r8
800092ac:	c5 83       	brcs	8000935c <vTaskIncrementTick+0x12c>
800092ae:	4b 08       	lddpc	r8,8000936c <vTaskIncrementTick+0x13c>
800092b0:	70 08       	ld.w	r8,r8[0x0]
800092b2:	70 08       	ld.w	r8,r8[0x0]
800092b4:	58 08       	cp.w	r8,0
800092b6:	c0 51       	brne	800092c0 <vTaskIncrementTick+0x90>
800092b8:	4b 08       	lddpc	r8,80009378 <vTaskIncrementTick+0x148>
800092ba:	3f f9       	mov	r9,-1
800092bc:	91 09       	st.w	r8[0x0],r9
800092be:	c4 f8       	rjmp	8000935c <vTaskIncrementTick+0x12c>
800092c0:	4a b8       	lddpc	r8,8000936c <vTaskIncrementTick+0x13c>
800092c2:	70 08       	ld.w	r8,r8[0x0]
800092c4:	70 38       	ld.w	r8,r8[0xc]
800092c6:	70 38       	ld.w	r8,r8[0xc]
800092c8:	ef 48 ff f4 	st.w	r7[-12],r8
800092cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800092d0:	70 18       	ld.w	r8,r8[0x4]
800092d2:	ef 48 ff fc 	st.w	r7[-4],r8
800092d6:	4a 58       	lddpc	r8,80009368 <vTaskIncrementTick+0x138>
800092d8:	70 09       	ld.w	r9,r8[0x0]
800092da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800092de:	10 39       	cp.w	r9,r8
800092e0:	c0 62       	brcc	800092ec <vTaskIncrementTick+0xbc>
800092e2:	4a 68       	lddpc	r8,80009378 <vTaskIncrementTick+0x148>
800092e4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800092e8:	91 09       	st.w	r8[0x0],r9
800092ea:	c3 98       	rjmp	8000935c <vTaskIncrementTick+0x12c>
800092ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800092f0:	2f c8       	sub	r8,-4
800092f2:	10 9c       	mov	r12,r8
800092f4:	f0 1f 00 22 	mcall	8000937c <vTaskIncrementTick+0x14c>
800092f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800092fc:	70 a8       	ld.w	r8,r8[0x28]
800092fe:	58 08       	cp.w	r8,0
80009300:	c0 70       	breq	8000930e <vTaskIncrementTick+0xde>
80009302:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009306:	2e 88       	sub	r8,-24
80009308:	10 9c       	mov	r12,r8
8000930a:	f0 1f 00 1d 	mcall	8000937c <vTaskIncrementTick+0x14c>
8000930e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009312:	70 b9       	ld.w	r9,r8[0x2c]
80009314:	49 b8       	lddpc	r8,80009380 <vTaskIncrementTick+0x150>
80009316:	70 08       	ld.w	r8,r8[0x0]
80009318:	10 39       	cp.w	r9,r8
8000931a:	e0 88 00 07 	brls	80009328 <vTaskIncrementTick+0xf8>
8000931e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009322:	70 b9       	ld.w	r9,r8[0x2c]
80009324:	49 78       	lddpc	r8,80009380 <vTaskIncrementTick+0x150>
80009326:	91 09       	st.w	r8[0x0],r9
80009328:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000932c:	f0 ca ff fc 	sub	r10,r8,-4
80009330:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009334:	70 b9       	ld.w	r9,r8[0x2c]
80009336:	12 98       	mov	r8,r9
80009338:	a3 68       	lsl	r8,0x2
8000933a:	12 08       	add	r8,r9
8000933c:	a3 68       	lsl	r8,0x2
8000933e:	10 99       	mov	r9,r8
80009340:	49 18       	lddpc	r8,80009384 <vTaskIncrementTick+0x154>
80009342:	f2 08 00 08 	add	r8,r9,r8
80009346:	14 9b       	mov	r11,r10
80009348:	10 9c       	mov	r12,r8
8000934a:	f0 1f 00 10 	mcall	80009388 <vTaskIncrementTick+0x158>
8000934e:	cb 0b       	rjmp	800092ae <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80009350:	48 f8       	lddpc	r8,8000938c <vTaskIncrementTick+0x15c>
80009352:	70 08       	ld.w	r8,r8[0x0]
80009354:	f0 c9 ff ff 	sub	r9,r8,-1
80009358:	48 d8       	lddpc	r8,8000938c <vTaskIncrementTick+0x15c>
8000935a:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
8000935c:	2f dd       	sub	sp,-12
8000935e:	e3 cd 80 80 	ldm	sp++,r7,pc
80009362:	00 00       	add	r0,r0
80009364:	00 00       	add	r0,r0
80009366:	0d 40       	ld.w	r0,--r6
80009368:	00 00       	add	r0,r0
8000936a:	0d 30       	ld.ub	r0,r6++
8000936c:	00 00       	add	r0,r0
8000936e:	0c e4       	st.h	--r6,r4
80009370:	00 00       	add	r0,r0
80009372:	0c e8       	st.h	--r6,r8
80009374:	00 00       	add	r0,r0
80009376:	0d 4c       	ld.w	r12,--r6
80009378:	00 00       	add	r0,r0
8000937a:	05 48       	ld.w	r8,--r2
8000937c:	80 00       	ld.sh	r0,r0[0x0]
8000937e:	7f 66       	ld.w	r6,pc[0x58]
80009380:	00 00       	add	r0,r0
80009382:	0d 38       	ld.ub	r8,r6++
80009384:	00 00       	add	r0,r0
80009386:	0c 1c       	sub	r12,r6
80009388:	80 00       	ld.sh	r0,r0[0x0]
8000938a:	7e 52       	ld.w	r2,pc[0x14]
8000938c:	00 00       	add	r0,r0
8000938e:	0d 44       	ld.w	r4,--r6

80009390 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80009390:	eb cd 40 80 	pushm	r7,lr
80009394:	1a 97       	mov	r7,sp
80009396:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80009398:	4a 58       	lddpc	r8,8000942c <vTaskSwitchContext+0x9c>
8000939a:	70 08       	ld.w	r8,r8[0x0]
8000939c:	58 08       	cp.w	r8,0
8000939e:	c0 c0       	breq	800093b6 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800093a0:	4a 48       	lddpc	r8,80009430 <vTaskSwitchContext+0xa0>
800093a2:	30 19       	mov	r9,1
800093a4:	91 09       	st.w	r8[0x0],r9
800093a6:	c3 f8       	rjmp	80009424 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800093a8:	4a 38       	lddpc	r8,80009434 <vTaskSwitchContext+0xa4>
800093aa:	70 08       	ld.w	r8,r8[0x0]
800093ac:	f0 c9 00 01 	sub	r9,r8,1
800093b0:	4a 18       	lddpc	r8,80009434 <vTaskSwitchContext+0xa4>
800093b2:	91 09       	st.w	r8[0x0],r9
800093b4:	c0 28       	rjmp	800093b8 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800093b6:	d7 03       	nop
800093b8:	49 f8       	lddpc	r8,80009434 <vTaskSwitchContext+0xa4>
800093ba:	70 09       	ld.w	r9,r8[0x0]
800093bc:	12 98       	mov	r8,r9
800093be:	a3 68       	lsl	r8,0x2
800093c0:	12 08       	add	r8,r9
800093c2:	a3 68       	lsl	r8,0x2
800093c4:	10 99       	mov	r9,r8
800093c6:	49 d8       	lddpc	r8,80009438 <vTaskSwitchContext+0xa8>
800093c8:	f2 08 00 08 	add	r8,r9,r8
800093cc:	70 08       	ld.w	r8,r8[0x0]
800093ce:	58 08       	cp.w	r8,0
800093d0:	ce c0       	breq	800093a8 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800093d2:	49 98       	lddpc	r8,80009434 <vTaskSwitchContext+0xa4>
800093d4:	70 09       	ld.w	r9,r8[0x0]
800093d6:	12 98       	mov	r8,r9
800093d8:	a3 68       	lsl	r8,0x2
800093da:	12 08       	add	r8,r9
800093dc:	a3 68       	lsl	r8,0x2
800093de:	10 99       	mov	r9,r8
800093e0:	49 68       	lddpc	r8,80009438 <vTaskSwitchContext+0xa8>
800093e2:	f2 08 00 08 	add	r8,r9,r8
800093e6:	ef 48 ff fc 	st.w	r7[-4],r8
800093ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800093ee:	70 18       	ld.w	r8,r8[0x4]
800093f0:	70 19       	ld.w	r9,r8[0x4]
800093f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800093f6:	91 19       	st.w	r8[0x4],r9
800093f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800093fc:	70 19       	ld.w	r9,r8[0x4]
800093fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009402:	2f 88       	sub	r8,-8
80009404:	10 39       	cp.w	r9,r8
80009406:	c0 81       	brne	80009416 <vTaskSwitchContext+0x86>
80009408:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000940c:	70 18       	ld.w	r8,r8[0x4]
8000940e:	70 19       	ld.w	r9,r8[0x4]
80009410:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009414:	91 19       	st.w	r8[0x4],r9
80009416:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000941a:	70 18       	ld.w	r8,r8[0x4]
8000941c:	70 38       	ld.w	r8,r8[0xc]
8000941e:	10 99       	mov	r9,r8
80009420:	48 78       	lddpc	r8,8000943c <vTaskSwitchContext+0xac>
80009422:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80009424:	2f fd       	sub	sp,-4
80009426:	e3 cd 80 80 	ldm	sp++,r7,pc
8000942a:	00 00       	add	r0,r0
8000942c:	00 00       	add	r0,r0
8000942e:	0d 40       	ld.w	r0,--r6
80009430:	00 00       	add	r0,r0
80009432:	0d 48       	ld.w	r8,--r6
80009434:	00 00       	add	r0,r0
80009436:	0d 38       	ld.ub	r8,r6++
80009438:	00 00       	add	r0,r0
8000943a:	0c 1c       	sub	r12,r6
8000943c:	00 00       	add	r0,r0
8000943e:	0c 18       	sub	r8,r6

80009440 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009440:	eb cd 40 80 	pushm	r7,lr
80009444:	1a 97       	mov	r7,sp
80009446:	20 3d       	sub	sp,12
80009448:	ef 4c ff f8 	st.w	r7[-8],r12
8000944c:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009450:	49 58       	lddpc	r8,800094a4 <vTaskPlaceOnEventList+0x64>
80009452:	70 08       	ld.w	r8,r8[0x0]
80009454:	2e 88       	sub	r8,-24
80009456:	10 9b       	mov	r11,r8
80009458:	ee fc ff f8 	ld.w	r12,r7[-8]
8000945c:	f0 1f 00 13 	mcall	800094a8 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009460:	49 18       	lddpc	r8,800094a4 <vTaskPlaceOnEventList+0x64>
80009462:	70 08       	ld.w	r8,r8[0x0]
80009464:	2f c8       	sub	r8,-4
80009466:	10 9c       	mov	r12,r8
80009468:	f0 1f 00 11 	mcall	800094ac <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
8000946c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009470:	5b f8       	cp.w	r8,-1
80009472:	c0 91       	brne	80009484 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009474:	48 c8       	lddpc	r8,800094a4 <vTaskPlaceOnEventList+0x64>
80009476:	70 08       	ld.w	r8,r8[0x0]
80009478:	2f c8       	sub	r8,-4
8000947a:	10 9b       	mov	r11,r8
8000947c:	48 dc       	lddpc	r12,800094b0 <vTaskPlaceOnEventList+0x70>
8000947e:	f0 1f 00 0e 	mcall	800094b4 <vTaskPlaceOnEventList+0x74>
80009482:	c0 d8       	rjmp	8000949c <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009484:	48 d8       	lddpc	r8,800094b8 <vTaskPlaceOnEventList+0x78>
80009486:	70 09       	ld.w	r9,r8[0x0]
80009488:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000948c:	f2 08 00 08 	add	r8,r9,r8
80009490:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009494:	ee fc ff fc 	ld.w	r12,r7[-4]
80009498:	f0 1f 00 09 	mcall	800094bc <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
8000949c:	2f dd       	sub	sp,-12
8000949e:	e3 cd 80 80 	ldm	sp++,r7,pc
800094a2:	00 00       	add	r0,r0
800094a4:	00 00       	add	r0,r0
800094a6:	0c 18       	sub	r8,r6
800094a8:	80 00       	ld.sh	r0,r0[0x0]
800094aa:	7e c4       	ld.w	r4,pc[0x30]
800094ac:	80 00       	ld.sh	r0,r0[0x0]
800094ae:	7f 66       	ld.w	r6,pc[0x58]
800094b0:	00 00       	add	r0,r0
800094b2:	0d 18       	ld.sh	r8,r6++
800094b4:	80 00       	ld.sh	r0,r0[0x0]
800094b6:	7e 52       	ld.w	r2,pc[0x14]
800094b8:	00 00       	add	r0,r0
800094ba:	0d 30       	ld.ub	r0,r6++
800094bc:	80 00       	ld.sh	r0,r0[0x0]
800094be:	98 90       	ld.uh	r0,r12[0x2]

800094c0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800094c0:	eb cd 40 80 	pushm	r7,lr
800094c4:	1a 97       	mov	r7,sp
800094c6:	20 3d       	sub	sp,12
800094c8:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800094cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800094d0:	70 38       	ld.w	r8,r8[0xc]
800094d2:	70 38       	ld.w	r8,r8[0xc]
800094d4:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800094d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800094dc:	2e 88       	sub	r8,-24
800094de:	10 9c       	mov	r12,r8
800094e0:	f0 1f 00 25 	mcall	80009574 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800094e4:	4a 58       	lddpc	r8,80009578 <xTaskRemoveFromEventList+0xb8>
800094e6:	70 08       	ld.w	r8,r8[0x0]
800094e8:	58 08       	cp.w	r8,0
800094ea:	c2 81       	brne	8000953a <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800094ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800094f0:	2f c8       	sub	r8,-4
800094f2:	10 9c       	mov	r12,r8
800094f4:	f0 1f 00 20 	mcall	80009574 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800094f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800094fc:	70 b9       	ld.w	r9,r8[0x2c]
800094fe:	4a 08       	lddpc	r8,8000957c <xTaskRemoveFromEventList+0xbc>
80009500:	70 08       	ld.w	r8,r8[0x0]
80009502:	10 39       	cp.w	r9,r8
80009504:	e0 88 00 07 	brls	80009512 <xTaskRemoveFromEventList+0x52>
80009508:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000950c:	70 b9       	ld.w	r9,r8[0x2c]
8000950e:	49 c8       	lddpc	r8,8000957c <xTaskRemoveFromEventList+0xbc>
80009510:	91 09       	st.w	r8[0x0],r9
80009512:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009516:	f0 ca ff fc 	sub	r10,r8,-4
8000951a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000951e:	70 b9       	ld.w	r9,r8[0x2c]
80009520:	12 98       	mov	r8,r9
80009522:	a3 68       	lsl	r8,0x2
80009524:	12 08       	add	r8,r9
80009526:	a3 68       	lsl	r8,0x2
80009528:	10 99       	mov	r9,r8
8000952a:	49 68       	lddpc	r8,80009580 <xTaskRemoveFromEventList+0xc0>
8000952c:	f2 08 00 08 	add	r8,r9,r8
80009530:	14 9b       	mov	r11,r10
80009532:	10 9c       	mov	r12,r8
80009534:	f0 1f 00 14 	mcall	80009584 <xTaskRemoveFromEventList+0xc4>
80009538:	c0 88       	rjmp	80009548 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000953a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000953e:	2e 88       	sub	r8,-24
80009540:	10 9b       	mov	r11,r8
80009542:	49 2c       	lddpc	r12,80009588 <xTaskRemoveFromEventList+0xc8>
80009544:	f0 1f 00 10 	mcall	80009584 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009548:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000954c:	70 b9       	ld.w	r9,r8[0x2c]
8000954e:	49 08       	lddpc	r8,8000958c <xTaskRemoveFromEventList+0xcc>
80009550:	70 08       	ld.w	r8,r8[0x0]
80009552:	70 b8       	ld.w	r8,r8[0x2c]
80009554:	10 39       	cp.w	r9,r8
80009556:	c0 53       	brcs	80009560 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80009558:	30 18       	mov	r8,1
8000955a:	ef 48 ff fc 	st.w	r7[-4],r8
8000955e:	c0 48       	rjmp	80009566 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80009560:	30 08       	mov	r8,0
80009562:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80009566:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000956a:	10 9c       	mov	r12,r8
8000956c:	2f dd       	sub	sp,-12
8000956e:	e3 cd 80 80 	ldm	sp++,r7,pc
80009572:	00 00       	add	r0,r0
80009574:	80 00       	ld.sh	r0,r0[0x0]
80009576:	7f 66       	ld.w	r6,pc[0x58]
80009578:	00 00       	add	r0,r0
8000957a:	0d 40       	ld.w	r0,--r6
8000957c:	00 00       	add	r0,r0
8000957e:	0d 38       	ld.ub	r8,r6++
80009580:	00 00       	add	r0,r0
80009582:	0c 1c       	sub	r12,r6
80009584:	80 00       	ld.sh	r0,r0[0x0]
80009586:	7e 52       	ld.w	r2,pc[0x14]
80009588:	00 00       	add	r0,r0
8000958a:	0c ec       	st.h	--r6,r12
8000958c:	00 00       	add	r0,r0
8000958e:	0c 18       	sub	r8,r6

80009590 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80009590:	eb cd 40 80 	pushm	r7,lr
80009594:	1a 97       	mov	r7,sp
80009596:	20 1d       	sub	sp,4
80009598:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000959c:	48 78       	lddpc	r8,800095b8 <vTaskSetTimeOutState+0x28>
8000959e:	70 09       	ld.w	r9,r8[0x0]
800095a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095a4:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
800095a6:	48 68       	lddpc	r8,800095bc <vTaskSetTimeOutState+0x2c>
800095a8:	70 09       	ld.w	r9,r8[0x0]
800095aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095ae:	91 19       	st.w	r8[0x4],r9
}
800095b0:	2f fd       	sub	sp,-4
800095b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800095b6:	00 00       	add	r0,r0
800095b8:	00 00       	add	r0,r0
800095ba:	0d 4c       	ld.w	r12,--r6
800095bc:	00 00       	add	r0,r0
800095be:	0d 30       	ld.ub	r0,r6++

800095c0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800095c0:	eb cd 40 80 	pushm	r7,lr
800095c4:	1a 97       	mov	r7,sp
800095c6:	20 3d       	sub	sp,12
800095c8:	ef 4c ff f8 	st.w	r7[-8],r12
800095cc:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800095d0:	f0 1f 00 25 	mcall	80009664 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800095d4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800095d8:	70 08       	ld.w	r8,r8[0x0]
800095da:	5b f8       	cp.w	r8,-1
800095dc:	c0 51       	brne	800095e6 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
800095de:	30 08       	mov	r8,0
800095e0:	ef 48 ff fc 	st.w	r7[-4],r8
800095e4:	c3 88       	rjmp	80009654 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800095e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800095ea:	70 09       	ld.w	r9,r8[0x0]
800095ec:	49 f8       	lddpc	r8,80009668 <xTaskCheckForTimeOut+0xa8>
800095ee:	70 08       	ld.w	r8,r8[0x0]
800095f0:	10 39       	cp.w	r9,r8
800095f2:	c0 d0       	breq	8000960c <xTaskCheckForTimeOut+0x4c>
800095f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800095f8:	70 19       	ld.w	r9,r8[0x4]
800095fa:	49 d8       	lddpc	r8,8000966c <xTaskCheckForTimeOut+0xac>
800095fc:	70 08       	ld.w	r8,r8[0x0]
800095fe:	10 39       	cp.w	r9,r8
80009600:	e0 8b 00 06 	brhi	8000960c <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80009604:	30 18       	mov	r8,1
80009606:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000960a:	c2 58       	rjmp	80009654 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000960c:	49 88       	lddpc	r8,8000966c <xTaskCheckForTimeOut+0xac>
8000960e:	70 09       	ld.w	r9,r8[0x0]
80009610:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009614:	70 18       	ld.w	r8,r8[0x4]
80009616:	10 19       	sub	r9,r8
80009618:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000961c:	70 08       	ld.w	r8,r8[0x0]
8000961e:	10 39       	cp.w	r9,r8
80009620:	c1 72       	brcc	8000964e <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80009622:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009626:	70 09       	ld.w	r9,r8[0x0]
80009628:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000962c:	70 1a       	ld.w	r10,r8[0x4]
8000962e:	49 08       	lddpc	r8,8000966c <xTaskCheckForTimeOut+0xac>
80009630:	70 08       	ld.w	r8,r8[0x0]
80009632:	f4 08 01 08 	sub	r8,r10,r8
80009636:	10 09       	add	r9,r8
80009638:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000963c:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
8000963e:	ee fc ff f8 	ld.w	r12,r7[-8]
80009642:	f0 1f 00 0c 	mcall	80009670 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80009646:	30 08       	mov	r8,0
80009648:	ef 48 ff fc 	st.w	r7[-4],r8
8000964c:	c0 48       	rjmp	80009654 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
8000964e:	30 18       	mov	r8,1
80009650:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80009654:	f0 1f 00 08 	mcall	80009674 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80009658:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000965c:	10 9c       	mov	r12,r8
8000965e:	2f dd       	sub	sp,-12
80009660:	e3 cd 80 80 	ldm	sp++,r7,pc
80009664:	80 00       	ld.sh	r0,r0[0x0]
80009666:	81 24       	st.w	r0[0x8],r4
80009668:	00 00       	add	r0,r0
8000966a:	0d 4c       	ld.w	r12,--r6
8000966c:	00 00       	add	r0,r0
8000966e:	0d 30       	ld.ub	r0,r6++
80009670:	80 00       	ld.sh	r0,r0[0x0]
80009672:	95 90       	st.w	r10[0x24],r0
80009674:	80 00       	ld.sh	r0,r0[0x0]
80009676:	81 40       	st.w	r0[0x10],r0

80009678 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80009678:	eb cd 40 80 	pushm	r7,lr
8000967c:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
8000967e:	48 38       	lddpc	r8,80009688 <vTaskMissedYield+0x10>
80009680:	30 19       	mov	r9,1
80009682:	91 09       	st.w	r8[0x0],r9
}
80009684:	e3 cd 80 80 	ldm	sp++,r7,pc
80009688:	00 00       	add	r0,r0
8000968a:	0d 48       	ld.w	r8,--r6

8000968c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000968c:	eb cd 40 80 	pushm	r7,lr
80009690:	1a 97       	mov	r7,sp
80009692:	20 1d       	sub	sp,4
80009694:	ef 4c ff fc 	st.w	r7[-4],r12
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80009698:	f0 1f 00 06 	mcall	800096b0 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000969c:	48 68       	lddpc	r8,800096b4 <prvIdleTask+0x28>
8000969e:	70 08       	ld.w	r8,r8[0x0]
800096a0:	58 18       	cp.w	r8,1
800096a2:	e0 88 00 03 	brls	800096a8 <prvIdleTask+0x1c>
			{
				taskYIELD();
800096a6:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800096a8:	f0 1f 00 04 	mcall	800096b8 <prvIdleTask+0x2c>
		}
		#endif
	}
800096ac:	cf 6b       	rjmp	80009698 <prvIdleTask+0xc>
800096ae:	00 00       	add	r0,r0
800096b0:	80 00       	ld.sh	r0,r0[0x0]
800096b2:	97 f8       	st.w	r11[0x3c],r8
800096b4:	00 00       	add	r0,r0
800096b6:	0c 1c       	sub	r12,r6
800096b8:	80 00       	ld.sh	r0,r0[0x0]
800096ba:	34 e4       	mov	r4,78

800096bc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
800096bc:	eb cd 40 80 	pushm	r7,lr
800096c0:	1a 97       	mov	r7,sp
800096c2:	20 5d       	sub	sp,20
800096c4:	ef 4c ff fc 	st.w	r7[-4],r12
800096c8:	ef 4b ff f8 	st.w	r7[-8],r11
800096cc:	ef 4a ff f4 	st.w	r7[-12],r10
800096d0:	ef 49 ff f0 	st.w	r7[-16],r9
800096d4:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800096d8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800096dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800096e0:	2c c8       	sub	r8,-52
800096e2:	31 0a       	mov	r10,16
800096e4:	12 9b       	mov	r11,r9
800096e6:	10 9c       	mov	r12,r8
800096e8:	f0 1f 00 1d 	mcall	8000975c <prvInitialiseTCBVariables+0xa0>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800096ec:	ee f9 ff fc 	ld.w	r9,r7[-4]
800096f0:	30 08       	mov	r8,0
800096f2:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
800096f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800096fa:	58 78       	cp.w	r8,7
800096fc:	e0 88 00 05 	brls	80009706 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80009700:	30 78       	mov	r8,7
80009702:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
80009706:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000970a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000970e:	91 b9       	st.w	r8[0x2c],r9
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009710:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009714:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009718:	f1 49 00 44 	st.w	r8[68],r9
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000971c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009720:	2f c8       	sub	r8,-4
80009722:	10 9c       	mov	r12,r8
80009724:	f0 1f 00 0f 	mcall	80009760 <prvInitialiseTCBVariables+0xa4>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80009728:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000972c:	2e 88       	sub	r8,-24
8000972e:	10 9c       	mov	r12,r8
80009730:	f0 1f 00 0c 	mcall	80009760 <prvInitialiseTCBVariables+0xa4>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009734:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009738:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000973c:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000973e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009742:	f0 09 11 08 	rsub	r9,r8,8
80009746:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000974a:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000974c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009750:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009754:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
80009756:	2f bd       	sub	sp,-20
80009758:	e3 cd 80 80 	ldm	sp++,r7,pc
8000975c:	80 00       	ld.sh	r0,r0[0x0]
8000975e:	b1 00       	ld.d	r0,r8
80009760:	80 00       	ld.sh	r0,r0[0x0]
80009762:	7e 38       	ld.w	r8,pc[0xc]

80009764 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80009764:	eb cd 40 80 	pushm	r7,lr
80009768:	1a 97       	mov	r7,sp
8000976a:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000976c:	30 08       	mov	r8,0
8000976e:	ef 48 ff fc 	st.w	r7[-4],r8
80009772:	c1 38       	rjmp	80009798 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009774:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009778:	12 98       	mov	r8,r9
8000977a:	a3 68       	lsl	r8,0x2
8000977c:	12 08       	add	r8,r9
8000977e:	a3 68       	lsl	r8,0x2
80009780:	10 99       	mov	r9,r8
80009782:	49 58       	lddpc	r8,800097d4 <prvInitialiseTaskLists+0x70>
80009784:	f2 08 00 08 	add	r8,r9,r8
80009788:	10 9c       	mov	r12,r8
8000978a:	f0 1f 00 14 	mcall	800097d8 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000978e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009792:	2f f8       	sub	r8,-1
80009794:	ef 48 ff fc 	st.w	r7[-4],r8
80009798:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000979c:	58 78       	cp.w	r8,7
8000979e:	fe 98 ff eb 	brls	80009774 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800097a2:	48 fc       	lddpc	r12,800097dc <prvInitialiseTaskLists+0x78>
800097a4:	f0 1f 00 0d 	mcall	800097d8 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800097a8:	48 ec       	lddpc	r12,800097e0 <prvInitialiseTaskLists+0x7c>
800097aa:	f0 1f 00 0c 	mcall	800097d8 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
800097ae:	48 ec       	lddpc	r12,800097e4 <prvInitialiseTaskLists+0x80>
800097b0:	f0 1f 00 0a 	mcall	800097d8 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800097b4:	48 dc       	lddpc	r12,800097e8 <prvInitialiseTaskLists+0x84>
800097b6:	f0 1f 00 09 	mcall	800097d8 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800097ba:	48 dc       	lddpc	r12,800097ec <prvInitialiseTaskLists+0x88>
800097bc:	f0 1f 00 07 	mcall	800097d8 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800097c0:	48 c8       	lddpc	r8,800097f0 <prvInitialiseTaskLists+0x8c>
800097c2:	48 79       	lddpc	r9,800097dc <prvInitialiseTaskLists+0x78>
800097c4:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800097c6:	48 c8       	lddpc	r8,800097f4 <prvInitialiseTaskLists+0x90>
800097c8:	48 69       	lddpc	r9,800097e0 <prvInitialiseTaskLists+0x7c>
800097ca:	91 09       	st.w	r8[0x0],r9
}
800097cc:	2f fd       	sub	sp,-4
800097ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800097d2:	00 00       	add	r0,r0
800097d4:	00 00       	add	r0,r0
800097d6:	0c 1c       	sub	r12,r6
800097d8:	80 00       	ld.sh	r0,r0[0x0]
800097da:	7d ec       	ld.w	r12,lr[0x78]
800097dc:	00 00       	add	r0,r0
800097de:	0c bc       	st.h	r6++,r12
800097e0:	00 00       	add	r0,r0
800097e2:	0c d0       	st.w	--r6,r0
800097e4:	00 00       	add	r0,r0
800097e6:	0c ec       	st.h	--r6,r12
800097e8:	00 00       	add	r0,r0
800097ea:	0d 00       	ld.w	r0,r6++
800097ec:	00 00       	add	r0,r0
800097ee:	0d 18       	ld.sh	r8,r6++
800097f0:	00 00       	add	r0,r0
800097f2:	0c e4       	st.h	--r6,r4
800097f4:	00 00       	add	r0,r0
800097f6:	0c e8       	st.h	--r6,r8

800097f8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
800097f8:	eb cd 40 80 	pushm	r7,lr
800097fc:	1a 97       	mov	r7,sp
800097fe:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009800:	49 b8       	lddpc	r8,8000986c <prvCheckTasksWaitingTermination+0x74>
80009802:	70 08       	ld.w	r8,r8[0x0]
80009804:	58 08       	cp.w	r8,0
80009806:	c2 f0       	breq	80009864 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80009808:	f0 1f 00 1a 	mcall	80009870 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000980c:	49 a8       	lddpc	r8,80009874 <prvCheckTasksWaitingTermination+0x7c>
8000980e:	70 08       	ld.w	r8,r8[0x0]
80009810:	58 08       	cp.w	r8,0
80009812:	5f 08       	sreq	r8
80009814:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80009818:	f0 1f 00 18 	mcall	80009878 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
8000981c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009820:	58 08       	cp.w	r8,0
80009822:	c2 11       	brne	80009864 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009824:	f0 1f 00 16 	mcall	8000987c <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009828:	49 38       	lddpc	r8,80009874 <prvCheckTasksWaitingTermination+0x7c>
8000982a:	2f 88       	sub	r8,-8
8000982c:	70 18       	ld.w	r8,r8[0x4]
8000982e:	70 38       	ld.w	r8,r8[0xc]
80009830:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80009834:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009838:	2f c8       	sub	r8,-4
8000983a:	10 9c       	mov	r12,r8
8000983c:	f0 1f 00 11 	mcall	80009880 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
80009840:	49 18       	lddpc	r8,80009884 <prvCheckTasksWaitingTermination+0x8c>
80009842:	70 08       	ld.w	r8,r8[0x0]
80009844:	f0 c9 00 01 	sub	r9,r8,1
80009848:	48 f8       	lddpc	r8,80009884 <prvCheckTasksWaitingTermination+0x8c>
8000984a:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
8000984c:	48 88       	lddpc	r8,8000986c <prvCheckTasksWaitingTermination+0x74>
8000984e:	70 08       	ld.w	r8,r8[0x0]
80009850:	f0 c9 00 01 	sub	r9,r8,1
80009854:	48 68       	lddpc	r8,8000986c <prvCheckTasksWaitingTermination+0x74>
80009856:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
80009858:	f0 1f 00 0c 	mcall	80009888 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
8000985c:	ee fc ff fc 	ld.w	r12,r7[-4]
80009860:	f0 1f 00 0b 	mcall	8000988c <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80009864:	2f ed       	sub	sp,-8
80009866:	e3 cd 80 80 	ldm	sp++,r7,pc
8000986a:	00 00       	add	r0,r0
8000986c:	00 00       	add	r0,r0
8000986e:	0d 14       	ld.sh	r4,r6++
80009870:	80 00       	ld.sh	r0,r0[0x0]
80009872:	90 bc       	ld.uh	r12,r8[0x6]
80009874:	00 00       	add	r0,r0
80009876:	0d 00       	ld.w	r0,r6++
80009878:	80 00       	ld.sh	r0,r0[0x0]
8000987a:	90 d8       	ld.uh	r8,r8[0xa]
8000987c:	80 00       	ld.sh	r0,r0[0x0]
8000987e:	81 24       	st.w	r0[0x8],r4
80009880:	80 00       	ld.sh	r0,r0[0x0]
80009882:	7f 66       	ld.w	r6,pc[0x58]
80009884:	00 00       	add	r0,r0
80009886:	0d 2c       	ld.uh	r12,r6++
80009888:	80 00       	ld.sh	r0,r0[0x0]
8000988a:	81 40       	st.w	r0[0x10],r0
8000988c:	80 00       	ld.sh	r0,r0[0x0]
8000988e:	99 a4       	st.w	r12[0x28],r4

80009890 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009890:	eb cd 40 80 	pushm	r7,lr
80009894:	1a 97       	mov	r7,sp
80009896:	20 1d       	sub	sp,4
80009898:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000989c:	49 78       	lddpc	r8,800098f8 <prvAddCurrentTaskToDelayedList+0x68>
8000989e:	70 08       	ld.w	r8,r8[0x0]
800098a0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800098a4:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
800098a6:	49 68       	lddpc	r8,800098fc <prvAddCurrentTaskToDelayedList+0x6c>
800098a8:	70 08       	ld.w	r8,r8[0x0]
800098aa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800098ae:	10 39       	cp.w	r9,r8
800098b0:	c0 c2       	brcc	800098c8 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800098b2:	49 28       	lddpc	r8,800098f8 <prvAddCurrentTaskToDelayedList+0x68>
800098b4:	70 08       	ld.w	r8,r8[0x0]
800098b6:	f0 c9 ff fc 	sub	r9,r8,-4
800098ba:	49 28       	lddpc	r8,80009900 <prvAddCurrentTaskToDelayedList+0x70>
800098bc:	70 08       	ld.w	r8,r8[0x0]
800098be:	12 9b       	mov	r11,r9
800098c0:	10 9c       	mov	r12,r8
800098c2:	f0 1f 00 11 	mcall	80009904 <prvAddCurrentTaskToDelayedList+0x74>
800098c6:	c1 58       	rjmp	800098f0 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800098c8:	48 c8       	lddpc	r8,800098f8 <prvAddCurrentTaskToDelayedList+0x68>
800098ca:	70 08       	ld.w	r8,r8[0x0]
800098cc:	f0 c9 ff fc 	sub	r9,r8,-4
800098d0:	48 e8       	lddpc	r8,80009908 <prvAddCurrentTaskToDelayedList+0x78>
800098d2:	70 08       	ld.w	r8,r8[0x0]
800098d4:	12 9b       	mov	r11,r9
800098d6:	10 9c       	mov	r12,r8
800098d8:	f0 1f 00 0b 	mcall	80009904 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800098dc:	48 c8       	lddpc	r8,8000990c <prvAddCurrentTaskToDelayedList+0x7c>
800098de:	70 08       	ld.w	r8,r8[0x0]
800098e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800098e4:	10 39       	cp.w	r9,r8
800098e6:	c0 52       	brcc	800098f0 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
800098e8:	48 98       	lddpc	r8,8000990c <prvAddCurrentTaskToDelayedList+0x7c>
800098ea:	ee f9 ff fc 	ld.w	r9,r7[-4]
800098ee:	91 09       	st.w	r8[0x0],r9
		}
	}
}
800098f0:	2f fd       	sub	sp,-4
800098f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800098f6:	00 00       	add	r0,r0
800098f8:	00 00       	add	r0,r0
800098fa:	0c 18       	sub	r8,r6
800098fc:	00 00       	add	r0,r0
800098fe:	0d 30       	ld.ub	r0,r6++
80009900:	00 00       	add	r0,r0
80009902:	0c e8       	st.h	--r6,r8
80009904:	80 00       	ld.sh	r0,r0[0x0]
80009906:	7e c4       	ld.w	r4,pc[0x30]
80009908:	00 00       	add	r0,r0
8000990a:	0c e4       	st.h	--r6,r4
8000990c:	00 00       	add	r0,r0
8000990e:	05 48       	ld.w	r8,--r2

80009910 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
80009910:	eb cd 40 80 	pushm	r7,lr
80009914:	1a 97       	mov	r7,sp
80009916:	20 3d       	sub	sp,12
80009918:	18 98       	mov	r8,r12
8000991a:	ef 4b ff f4 	st.w	r7[-12],r11
8000991e:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009922:	34 8c       	mov	r12,72
80009924:	f0 1f 00 1d 	mcall	80009998 <prvAllocateTCBAndStack+0x88>
80009928:	18 98       	mov	r8,r12
8000992a:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
8000992e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009932:	58 08       	cp.w	r8,0
80009934:	c2 c0       	breq	8000998c <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009936:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000993a:	58 08       	cp.w	r8,0
8000993c:	c0 91       	brne	8000994e <prvAllocateTCBAndStack+0x3e>
8000993e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80009942:	a3 68       	lsl	r8,0x2
80009944:	10 9c       	mov	r12,r8
80009946:	f0 1f 00 15 	mcall	80009998 <prvAllocateTCBAndStack+0x88>
8000994a:	18 98       	mov	r8,r12
8000994c:	c0 38       	rjmp	80009952 <prvAllocateTCBAndStack+0x42>
8000994e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009952:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009956:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
80009958:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000995c:	70 c8       	ld.w	r8,r8[0x30]
8000995e:	58 08       	cp.w	r8,0
80009960:	c0 91       	brne	80009972 <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009962:	ee fc ff fc 	ld.w	r12,r7[-4]
80009966:	f0 1f 00 0e 	mcall	8000999c <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
8000996a:	30 08       	mov	r8,0
8000996c:	ef 48 ff fc 	st.w	r7[-4],r8
80009970:	c0 e8       	rjmp	8000998c <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009972:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80009976:	f0 09 15 02 	lsl	r9,r8,0x2
8000997a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000997e:	70 c8       	ld.w	r8,r8[0x30]
80009980:	12 9a       	mov	r10,r9
80009982:	e0 6b 00 a5 	mov	r11,165
80009986:	10 9c       	mov	r12,r8
80009988:	f0 1f 00 06 	mcall	800099a0 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
8000998c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009990:	10 9c       	mov	r12,r8
80009992:	2f dd       	sub	sp,-12
80009994:	e3 cd 80 80 	ldm	sp++,r7,pc
80009998:	80 00       	ld.sh	r0,r0[0x0]
8000999a:	84 cc       	ld.uh	r12,r2[0x8]
8000999c:	80 00       	ld.sh	r0,r0[0x0]
8000999e:	85 08       	st.w	r2[0x0],r8
800099a0:	80 00       	ld.sh	r0,r0[0x0]
800099a2:	ad be       	sbr	lr,0xd

800099a4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
800099a4:	eb cd 40 80 	pushm	r7,lr
800099a8:	1a 97       	mov	r7,sp
800099aa:	20 1d       	sub	sp,4
800099ac:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800099b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800099b4:	70 c8       	ld.w	r8,r8[0x30]
800099b6:	10 9c       	mov	r12,r8
800099b8:	f0 1f 00 05 	mcall	800099cc <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
800099bc:	ee fc ff fc 	ld.w	r12,r7[-4]
800099c0:	f0 1f 00 03 	mcall	800099cc <prvDeleteTCB+0x28>
	}
800099c4:	2f fd       	sub	sp,-4
800099c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800099ca:	00 00       	add	r0,r0
800099cc:	80 00       	ld.sh	r0,r0[0x0]
800099ce:	85 08       	st.w	r2[0x0],r8

800099d0 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
800099d0:	eb cd 40 80 	pushm	r7,lr
800099d4:	1a 97       	mov	r7,sp
800099d6:	20 1d       	sub	sp,4
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800099d8:	48 58       	lddpc	r8,800099ec <xTaskGetCurrentTaskHandle+0x1c>
800099da:	70 08       	ld.w	r8,r8[0x0]
800099dc:	ef 48 ff fc 	st.w	r7[-4],r8

		return xReturn;
800099e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
800099e4:	10 9c       	mov	r12,r8
800099e6:	2f fd       	sub	sp,-4
800099e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800099ec:	00 00       	add	r0,r0
800099ee:	0c 18       	sub	r8,r6

800099f0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800099f0:	eb cd 40 80 	pushm	r7,lr
800099f4:	1a 97       	mov	r7,sp
800099f6:	20 2d       	sub	sp,8
800099f8:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800099fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009a00:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80009a04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a08:	70 b9       	ld.w	r9,r8[0x2c]
80009a0a:	4a a8       	lddpc	r8,80009ab0 <vTaskPriorityInherit+0xc0>
80009a0c:	70 08       	ld.w	r8,r8[0x0]
80009a0e:	70 b8       	ld.w	r8,r8[0x2c]
80009a10:	10 39       	cp.w	r9,r8
80009a12:	c4 c2       	brcc	80009aaa <vTaskPriorityInherit+0xba>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80009a14:	4a 78       	lddpc	r8,80009ab0 <vTaskPriorityInherit+0xc0>
80009a16:	70 08       	ld.w	r8,r8[0x0]
80009a18:	70 b8       	ld.w	r8,r8[0x2c]
80009a1a:	f0 09 11 08 	rsub	r9,r8,8
80009a1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a22:	91 69       	st.w	r8[0x18],r9

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80009a24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a28:	70 5a       	ld.w	r10,r8[0x14]
80009a2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a2e:	70 b9       	ld.w	r9,r8[0x2c]
80009a30:	12 98       	mov	r8,r9
80009a32:	a3 68       	lsl	r8,0x2
80009a34:	12 08       	add	r8,r9
80009a36:	a3 68       	lsl	r8,0x2
80009a38:	10 99       	mov	r9,r8
80009a3a:	49 f8       	lddpc	r8,80009ab4 <vTaskPriorityInherit+0xc4>
80009a3c:	f2 08 00 08 	add	r8,r9,r8
80009a40:	10 3a       	cp.w	r10,r8
80009a42:	c2 e1       	brne	80009a9e <vTaskPriorityInherit+0xae>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80009a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a48:	2f c8       	sub	r8,-4
80009a4a:	10 9c       	mov	r12,r8
80009a4c:	f0 1f 00 1b 	mcall	80009ab8 <vTaskPriorityInherit+0xc8>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009a50:	49 88       	lddpc	r8,80009ab0 <vTaskPriorityInherit+0xc0>
80009a52:	70 08       	ld.w	r8,r8[0x0]
80009a54:	70 b9       	ld.w	r9,r8[0x2c]
80009a56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a5a:	91 b9       	st.w	r8[0x2c],r9
				prvAddTaskToReadyQueue( pxTCB );
80009a5c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a60:	70 b9       	ld.w	r9,r8[0x2c]
80009a62:	49 78       	lddpc	r8,80009abc <vTaskPriorityInherit+0xcc>
80009a64:	70 08       	ld.w	r8,r8[0x0]
80009a66:	10 39       	cp.w	r9,r8
80009a68:	e0 88 00 07 	brls	80009a76 <vTaskPriorityInherit+0x86>
80009a6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a70:	70 b9       	ld.w	r9,r8[0x2c]
80009a72:	49 38       	lddpc	r8,80009abc <vTaskPriorityInherit+0xcc>
80009a74:	91 09       	st.w	r8[0x0],r9
80009a76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a7a:	f0 ca ff fc 	sub	r10,r8,-4
80009a7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a82:	70 b9       	ld.w	r9,r8[0x2c]
80009a84:	12 98       	mov	r8,r9
80009a86:	a3 68       	lsl	r8,0x2
80009a88:	12 08       	add	r8,r9
80009a8a:	a3 68       	lsl	r8,0x2
80009a8c:	10 99       	mov	r9,r8
80009a8e:	48 a8       	lddpc	r8,80009ab4 <vTaskPriorityInherit+0xc4>
80009a90:	f2 08 00 08 	add	r8,r9,r8
80009a94:	14 9b       	mov	r11,r10
80009a96:	10 9c       	mov	r12,r8
80009a98:	f0 1f 00 0a 	mcall	80009ac0 <vTaskPriorityInherit+0xd0>
80009a9c:	c0 78       	rjmp	80009aaa <vTaskPriorityInherit+0xba>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009a9e:	48 58       	lddpc	r8,80009ab0 <vTaskPriorityInherit+0xc0>
80009aa0:	70 08       	ld.w	r8,r8[0x0]
80009aa2:	70 b9       	ld.w	r9,r8[0x2c]
80009aa4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009aa8:	91 b9       	st.w	r8[0x2c],r9
			}
		}
	}
80009aaa:	2f ed       	sub	sp,-8
80009aac:	e3 cd 80 80 	ldm	sp++,r7,pc
80009ab0:	00 00       	add	r0,r0
80009ab2:	0c 18       	sub	r8,r6
80009ab4:	00 00       	add	r0,r0
80009ab6:	0c 1c       	sub	r12,r6
80009ab8:	80 00       	ld.sh	r0,r0[0x0]
80009aba:	7f 66       	ld.w	r6,pc[0x58]
80009abc:	00 00       	add	r0,r0
80009abe:	0d 38       	ld.ub	r8,r6++
80009ac0:	80 00       	ld.sh	r0,r0[0x0]
80009ac2:	7e 52       	ld.w	r2,pc[0x14]

80009ac4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80009ac4:	eb cd 40 80 	pushm	r7,lr
80009ac8:	1a 97       	mov	r7,sp
80009aca:	20 2d       	sub	sp,8
80009acc:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009ad0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009ad4:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxMutexHolder != NULL )
80009ad8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009adc:	58 08       	cp.w	r8,0
80009ade:	c3 d0       	breq	80009b58 <vTaskPriorityDisinherit+0x94>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80009ae0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ae4:	70 b9       	ld.w	r9,r8[0x2c]
80009ae6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009aea:	71 18       	ld.w	r8,r8[0x44]
80009aec:	10 39       	cp.w	r9,r8
80009aee:	c3 50       	breq	80009b58 <vTaskPriorityDisinherit+0x94>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80009af0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009af4:	2f c8       	sub	r8,-4
80009af6:	10 9c       	mov	r12,r8
80009af8:	f0 1f 00 1a 	mcall	80009b60 <vTaskPriorityDisinherit+0x9c>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009afc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b00:	71 19       	ld.w	r9,r8[0x44]
80009b02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b06:	91 b9       	st.w	r8[0x2c],r9
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80009b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b0c:	70 b8       	ld.w	r8,r8[0x2c]
80009b0e:	f0 09 11 08 	rsub	r9,r8,8
80009b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b16:	91 69       	st.w	r8[0x18],r9
				prvAddTaskToReadyQueue( pxTCB );
80009b18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b1c:	70 b9       	ld.w	r9,r8[0x2c]
80009b1e:	49 28       	lddpc	r8,80009b64 <vTaskPriorityDisinherit+0xa0>
80009b20:	70 08       	ld.w	r8,r8[0x0]
80009b22:	10 39       	cp.w	r9,r8
80009b24:	e0 88 00 07 	brls	80009b32 <vTaskPriorityDisinherit+0x6e>
80009b28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b2c:	70 b9       	ld.w	r9,r8[0x2c]
80009b2e:	48 e8       	lddpc	r8,80009b64 <vTaskPriorityDisinherit+0xa0>
80009b30:	91 09       	st.w	r8[0x0],r9
80009b32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b36:	f0 ca ff fc 	sub	r10,r8,-4
80009b3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b3e:	70 b9       	ld.w	r9,r8[0x2c]
80009b40:	12 98       	mov	r8,r9
80009b42:	a3 68       	lsl	r8,0x2
80009b44:	12 08       	add	r8,r9
80009b46:	a3 68       	lsl	r8,0x2
80009b48:	10 99       	mov	r9,r8
80009b4a:	48 88       	lddpc	r8,80009b68 <vTaskPriorityDisinherit+0xa4>
80009b4c:	f2 08 00 08 	add	r8,r9,r8
80009b50:	14 9b       	mov	r11,r10
80009b52:	10 9c       	mov	r12,r8
80009b54:	f0 1f 00 06 	mcall	80009b6c <vTaskPriorityDisinherit+0xa8>
			}
		}
	}
80009b58:	2f ed       	sub	sp,-8
80009b5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b5e:	00 00       	add	r0,r0
80009b60:	80 00       	ld.sh	r0,r0[0x0]
80009b62:	7f 66       	ld.w	r6,pc[0x58]
80009b64:	00 00       	add	r0,r0
80009b66:	0d 38       	ld.ub	r8,r6++
80009b68:	00 00       	add	r0,r0
80009b6a:	0c 1c       	sub	r12,r6
80009b6c:	80 00       	ld.sh	r0,r0[0x0]
80009b6e:	7e 52       	ld.w	r2,pc[0x14]
80009b70:	4c 4f       	lddpc	pc,80009c80 <PrintDec+0xa0>
80009b72:	47 00       	lddsp	r0,sp[0x1c0]
80009b74:	49 20       	lddpc	r0,80009bbc <PrintChar+0x10>
80009b76:	6e 65       	ld.w	r5,r7[0x18]
80009b78:	65 64       	ld.w	r4,r2[0x58]
80009b7a:	20 66       	sub	r6,6
80009b7c:	6c 6f       	ld.w	pc,r6[0x18]
80009b7e:	61 74       	ld.w	r4,r0[0x5c]
80009b80:	2e 00       	sub	r0,-32
80009b82:	00 00       	add	r0,r0
80009b84:	49 20       	lddpc	r0,80009bcc <PrintChar+0x20>
80009b86:	6e 65       	ld.w	r5,r7[0x18]
80009b88:	65 64       	ld.w	r4,r2[0x58]
80009b8a:	20 72       	sub	r2,7
80009b8c:	65 6c       	ld.w	r12,r2[0x58]
80009b8e:	61 78       	ld.w	r8,r0[0x5c]
80009b90:	2e 00       	sub	r0,-32
80009b92:	00 00       	add	r0,r0
80009b94:	25 73       	sub	r3,87
80009b96:	25 73       	sub	r3,87
80009b98:	00 00       	add	r0,r0
80009b9a:	00 00       	add	r0,r0
80009b9c:	25 73       	sub	r3,87
80009b9e:	25 63       	sub	r3,86
80009ba0:	00 00       	add	r0,r0
80009ba2:	00 00       	add	r0,r0
80009ba4:	25 73       	sub	r3,87
80009ba6:	0d 0a       	ld.w	r10,r6++
80009ba8:	00 00       	add	r0,r0
	...

80009bac <PrintChar>:

	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
80009bac:	eb cd 40 80 	pushm	r7,lr
80009bb0:	1a 97       	mov	r7,sp
80009bb2:	20 2d       	sub	sp,8
80009bb4:	18 98       	mov	r8,r12
80009bb6:	ef 4b ff f8 	st.w	r7[-8],r11
80009bba:	ef 68 ff fc 	st.b	r7[-4],r8
	*str++ = c;
80009bbe:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009bc2:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80009bc6:	b2 88       	st.b	r9[0x0],r8
80009bc8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009bcc:	2f f8       	sub	r8,-1
80009bce:	ef 48 ff f8 	st.w	r7[-8],r8
	return str;
80009bd2:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80009bd6:	10 9c       	mov	r12,r8
80009bd8:	2f ed       	sub	sp,-8
80009bda:	e3 cd 80 80 	ldm	sp++,r7,pc
80009bde:	d7 03       	nop

80009be0 <PrintDec>:

char * PrintDec(int i, char len, char * str)
{
80009be0:	eb cd 40 80 	pushm	r7,lr
80009be4:	1a 97       	mov	r7,sp
80009be6:	20 cd       	sub	sp,48
80009be8:	ef 4c ff d8 	st.w	r7[-40],r12
80009bec:	16 98       	mov	r8,r11
80009bee:	ef 4a ff d0 	st.w	r7[-48],r10
80009bf2:	ef 68 ff d4 	st.b	r7[-44],r8
	char * p = str;
80009bf6:	ee f8 ff d0 	ld.w	r8,r7[-48]
80009bfa:	ef 48 ff e8 	st.w	r7[-24],r8
	
	int sign = i>=0 ? 0 : 1;
80009bfe:	ee f8 ff d8 	ld.w	r8,r7[-40]
80009c02:	bf 98       	lsr	r8,0x1f
80009c04:	ef 48 ff ec 	st.w	r7[-20],r8
	char s[10];
	memset(s, 0 , 10);
80009c08:	ee c8 00 24 	sub	r8,r7,36
80009c0c:	30 aa       	mov	r10,10
80009c0e:	30 0b       	mov	r11,0
80009c10:	10 9c       	mov	r12,r8
80009c12:	f0 1f 00 61 	mcall	80009d94 <PrintDec+0x1b4>
	int cnt=0;
80009c16:	30 08       	mov	r8,0
80009c18:	ef 48 ff f0 	st.w	r7[-16],r8
	if(sign)
80009c1c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009c20:	58 08       	cp.w	r8,0
80009c22:	c0 f0       	breq	80009c40 <PrintDec+0x60>
	{
		*p++ = '-';
80009c24:	ee f9 ff e8 	ld.w	r9,r7[-24]
80009c28:	32 d8       	mov	r8,45
80009c2a:	b2 88       	st.b	r9[0x0],r8
80009c2c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80009c30:	2f f8       	sub	r8,-1
80009c32:	ef 48 ff e8 	st.w	r7[-24],r8
		i = -i;
80009c36:	ee f8 ff d8 	ld.w	r8,r7[-40]
80009c3a:	5c 38       	neg	r8
80009c3c:	ef 48 ff d8 	st.w	r7[-40],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80009c40:	ee f8 ff d8 	ld.w	r8,r7[-40]
80009c44:	58 08       	cp.w	r8,0
80009c46:	c0 d1       	brne	80009c60 <PrintDec+0x80>
80009c48:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009c4c:	ee 08 00 09 	add	r9,r7,r8
80009c50:	33 08       	mov	r8,48
80009c52:	f3 68 ff dc 	st.b	r9[-36],r8
80009c56:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009c5a:	2f f8       	sub	r8,-1
80009c5c:	ef 48 ff f0 	st.w	r7[-16],r8
	
	int ten = i%10;
80009c60:	ee f9 ff d8 	ld.w	r9,r7[-40]
80009c64:	e0 68 66 67 	mov	r8,26215
80009c68:	ea 18 66 66 	orh	r8,0x6666
80009c6c:	f2 08 04 4a 	muls.d	r10,r9,r8
80009c70:	f6 0a 14 02 	asr	r10,r11,0x2
80009c74:	f2 08 14 1f 	asr	r8,r9,0x1f
80009c78:	10 1a       	sub	r10,r8
80009c7a:	14 98       	mov	r8,r10
80009c7c:	a3 68       	lsl	r8,0x2
80009c7e:	14 08       	add	r8,r10
80009c80:	a1 78       	lsl	r8,0x1
80009c82:	f2 08 01 08 	sub	r8,r9,r8
80009c86:	ef 48 ff f4 	st.w	r7[-12],r8
	while(i)
80009c8a:	c3 58       	rjmp	80009cf4 <PrintDec+0x114>
	{
		s[cnt] = ten+'0';
80009c8c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80009c90:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009c94:	5c 58       	castu.b	r8
80009c96:	2d 08       	sub	r8,-48
80009c98:	5c 58       	castu.b	r8
80009c9a:	ee 09 00 09 	add	r9,r7,r9
80009c9e:	f3 68 ff dc 	st.b	r9[-36],r8
		cnt++;
80009ca2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009ca6:	2f f8       	sub	r8,-1
80009ca8:	ef 48 ff f0 	st.w	r7[-16],r8
		i /= 10;
80009cac:	ee fa ff d8 	ld.w	r10,r7[-40]
80009cb0:	e0 68 66 67 	mov	r8,26215
80009cb4:	ea 18 66 66 	orh	r8,0x6666
80009cb8:	f4 08 04 48 	muls.d	r8,r10,r8
80009cbc:	a3 49       	asr	r9,0x2
80009cbe:	f4 08 14 1f 	asr	r8,r10,0x1f
80009cc2:	f2 08 01 08 	sub	r8,r9,r8
80009cc6:	ef 48 ff d8 	st.w	r7[-40],r8
		ten = i%10;
80009cca:	ee f9 ff d8 	ld.w	r9,r7[-40]
80009cce:	e0 68 66 67 	mov	r8,26215
80009cd2:	ea 18 66 66 	orh	r8,0x6666
80009cd6:	f2 08 04 4a 	muls.d	r10,r9,r8
80009cda:	f6 0a 14 02 	asr	r10,r11,0x2
80009cde:	f2 08 14 1f 	asr	r8,r9,0x1f
80009ce2:	10 1a       	sub	r10,r8
80009ce4:	14 98       	mov	r8,r10
80009ce6:	a3 68       	lsl	r8,0x2
80009ce8:	14 08       	add	r8,r10
80009cea:	a1 78       	lsl	r8,0x1
80009cec:	f2 08 01 08 	sub	r8,r9,r8
80009cf0:	ef 48 ff f4 	st.w	r7[-12],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009cf4:	ee f8 ff d8 	ld.w	r8,r7[-40]
80009cf8:	58 08       	cp.w	r8,0
80009cfa:	cc 91       	brne	80009c8c <PrintDec+0xac>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009cfc:	ef 39 ff d4 	ld.ub	r9,r7[-44]
80009d00:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d04:	f2 08 01 08 	sub	r8,r9,r8
80009d08:	58 08       	cp.w	r8,0
80009d0a:	e0 8a 00 3a 	brle	80009d7e <PrintDec+0x19e>
	{
		char num = len - cnt;
80009d0e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d12:	5c 58       	castu.b	r8
80009d14:	ef 39 ff d4 	ld.ub	r9,r7[-44]
80009d18:	10 19       	sub	r9,r8
80009d1a:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
80009d1e:	30 08       	mov	r8,0
80009d20:	ef 48 ff fc 	st.w	r7[-4],r8
80009d24:	c1 28       	rjmp	80009d48 <PrintDec+0x168>
		{
			s[cnt++] = '0';
80009d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d2a:	ee 08 00 09 	add	r9,r7,r8
80009d2e:	33 08       	mov	r8,48
80009d30:	f3 68 ff dc 	st.b	r9[-36],r8
80009d34:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d38:	2f f8       	sub	r8,-1
80009d3a:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009d3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d42:	2f f8       	sub	r8,-1
80009d44:	ef 48 ff fc 	st.w	r7[-4],r8
80009d48:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80009d4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d50:	10 39       	cp.w	r9,r8
80009d52:	fe 99 ff ea 	brgt	80009d26 <PrintDec+0x146>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009d56:	c1 48       	rjmp	80009d7e <PrintDec+0x19e>
	*p++ = s[--cnt];
80009d58:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d5c:	20 18       	sub	r8,1
80009d5e:	ef 48 ff f0 	st.w	r7[-16],r8
80009d62:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d66:	ee 08 00 08 	add	r8,r7,r8
80009d6a:	f1 38 ff dc 	ld.ub	r8,r8[-36]
80009d6e:	ee f9 ff e8 	ld.w	r9,r7[-24]
80009d72:	b2 88       	st.b	r9[0x0],r8
80009d74:	ee f8 ff e8 	ld.w	r8,r7[-24]
80009d78:	2f f8       	sub	r8,-1
80009d7a:	ef 48 ff e8 	st.w	r7[-24],r8
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009d7e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009d82:	58 08       	cp.w	r8,0
80009d84:	fe 99 ff ea 	brgt	80009d58 <PrintDec+0x178>
	*p++ = s[--cnt];
	
	return str;
80009d88:	ee f8 ff d0 	ld.w	r8,r7[-48]
}
80009d8c:	10 9c       	mov	r12,r8
80009d8e:	2f 4d       	sub	sp,-48
80009d90:	e3 cd 80 80 	ldm	sp++,r7,pc
80009d94:	80 00       	ld.sh	r0,r0[0x0]
80009d96:	ad be       	sbr	lr,0xd

80009d98 <PrintHex>:

char * PrintHex(int i,char len, char * str)
{
80009d98:	eb cd 40 80 	pushm	r7,lr
80009d9c:	1a 97       	mov	r7,sp
80009d9e:	20 ad       	sub	sp,40
80009da0:	ef 4c ff e0 	st.w	r7[-32],r12
80009da4:	16 98       	mov	r8,r11
80009da6:	ef 4a ff d8 	st.w	r7[-40],r10
80009daa:	ef 68 ff dc 	st.b	r7[-36],r8
	char * p = str;
80009dae:	ee f8 ff d8 	ld.w	r8,r7[-40]
80009db2:	ef 48 ff f0 	st.w	r7[-16],r8
	char s[12];
	memset(s, 0 , 12);
80009db6:	ee c8 00 1c 	sub	r8,r7,28
80009dba:	30 ca       	mov	r10,12
80009dbc:	30 0b       	mov	r11,0
80009dbe:	10 9c       	mov	r12,r8
80009dc0:	f0 1f 00 53 	mcall	80009f0c <PrintHex+0x174>
	int cnt=0;
80009dc4:	30 08       	mov	r8,0
80009dc6:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(i)
80009dca:	ee f8 ff e0 	ld.w	r8,r7[-32]
80009dce:	58 08       	cp.w	r8,0
80009dd0:	c2 d0       	breq	80009e2a <PrintHex+0x92>
	while(i)
80009dd2:	c2 78       	rjmp	80009e20 <PrintHex+0x88>
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80009dd4:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009dd8:	ee f8 ff e0 	ld.w	r8,r7[-32]
80009ddc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009de0:	58 98       	cp.w	r8,9
80009de2:	e0 8a 00 0a 	brle	80009df6 <PrintHex+0x5e>
80009de6:	ee f8 ff e0 	ld.w	r8,r7[-32]
80009dea:	5c 58       	castu.b	r8
80009dec:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009df0:	2c 98       	sub	r8,-55
80009df2:	5c 58       	castu.b	r8
80009df4:	c0 88       	rjmp	80009e04 <PrintHex+0x6c>
80009df6:	ee f8 ff e0 	ld.w	r8,r7[-32]
80009dfa:	5c 58       	castu.b	r8
80009dfc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009e00:	2d 08       	sub	r8,-48
80009e02:	5c 58       	castu.b	r8
80009e04:	ee 09 00 09 	add	r9,r7,r9
80009e08:	f3 68 ff e4 	st.b	r9[-28],r8
80009e0c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e10:	2f f8       	sub	r8,-1
80009e12:	ef 48 ff f4 	st.w	r7[-12],r8
		i = (i >> 4 ) & 0x0FFFFFFF;
80009e16:	ee f8 ff e0 	ld.w	r8,r7[-32]
80009e1a:	a5 88       	lsr	r8,0x4
80009e1c:	ef 48 ff e0 	st.w	r7[-32],r8
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009e20:	ee f8 ff e0 	ld.w	r8,r7[-32]
80009e24:	58 08       	cp.w	r8,0
80009e26:	cd 71       	brne	80009dd4 <PrintHex+0x3c>
80009e28:	c0 d8       	rjmp	80009e42 <PrintHex+0xaa>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009e2a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e2e:	ee 08 00 09 	add	r9,r7,r8
80009e32:	33 08       	mov	r8,48
80009e34:	f3 68 ff e4 	st.b	r9[-28],r8
80009e38:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e3c:	2f f8       	sub	r8,-1
80009e3e:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(len - cnt > 0 )
80009e42:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80009e46:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e4a:	f2 08 01 08 	sub	r8,r9,r8
80009e4e:	58 08       	cp.w	r8,0
80009e50:	e0 8a 00 26 	brle	80009e9c <PrintHex+0x104>
	{
		char num = len - cnt;
80009e54:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e58:	5c 58       	castu.b	r8
80009e5a:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80009e5e:	10 19       	sub	r9,r8
80009e60:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
80009e64:	30 08       	mov	r8,0
80009e66:	ef 48 ff fc 	st.w	r7[-4],r8
80009e6a:	c1 28       	rjmp	80009e8e <PrintHex+0xf6>
		{
			s[cnt++] = '0';
80009e6c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e70:	ee 08 00 09 	add	r9,r7,r8
80009e74:	33 08       	mov	r8,48
80009e76:	f3 68 ff e4 	st.b	r9[-28],r8
80009e7a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009e7e:	2f f8       	sub	r8,-1
80009e80:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009e84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e88:	2f f8       	sub	r8,-1
80009e8a:	ef 48 ff fc 	st.w	r7[-4],r8
80009e8e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80009e92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e96:	10 39       	cp.w	r9,r8
80009e98:	fe 99 ff ea 	brgt	80009e6c <PrintHex+0xd4>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009e9c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009ea0:	ee 08 00 09 	add	r9,r7,r8
80009ea4:	37 88       	mov	r8,120
80009ea6:	f3 68 ff e4 	st.b	r9[-28],r8
80009eaa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009eae:	2f f8       	sub	r8,-1
80009eb0:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
80009eb4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009eb8:	ee 08 00 09 	add	r9,r7,r8
80009ebc:	33 08       	mov	r8,48
80009ebe:	f3 68 ff e4 	st.b	r9[-28],r8
80009ec2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009ec6:	2f f8       	sub	r8,-1
80009ec8:	ef 48 ff f4 	st.w	r7[-12],r8
	
	while(cnt>0)
80009ecc:	c1 48       	rjmp	80009ef4 <PrintHex+0x15c>
	*p++ = s[--cnt];
80009ece:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009ed2:	20 18       	sub	r8,1
80009ed4:	ef 48 ff f4 	st.w	r7[-12],r8
80009ed8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009edc:	ee 08 00 08 	add	r8,r7,r8
80009ee0:	f1 38 ff e4 	ld.ub	r8,r8[-28]
80009ee4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80009ee8:	b2 88       	st.b	r9[0x0],r8
80009eea:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009eee:	2f f8       	sub	r8,-1
80009ef0:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80009ef4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009ef8:	58 08       	cp.w	r8,0
80009efa:	fe 99 ff ea 	brgt	80009ece <PrintHex+0x136>
	*p++ = s[--cnt];
		
	return str;
80009efe:	ee f8 ff d8 	ld.w	r8,r7[-40]
}
80009f02:	10 9c       	mov	r12,r8
80009f04:	2f 6d       	sub	sp,-40
80009f06:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f0a:	00 00       	add	r0,r0
80009f0c:	80 00       	ld.sh	r0,r0[0x0]
80009f0e:	ad be       	sbr	lr,0xd

80009f10 <log_init>:

void log_init(void)
{
80009f10:	eb cd 40 80 	pushm	r7,lr
80009f14:	1a 97       	mov	r7,sp
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80009f16:	30 2b       	mov	r11,2
80009f18:	49 2c       	lddpc	r12,80009f60 <log_init+0x50>
80009f1a:	f0 1f 00 13 	mcall	80009f64 <log_init+0x54>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);		
80009f1e:	e0 6a 36 00 	mov	r10,13824
80009f22:	ea 1a 01 6e 	orh	r10,0x16e
80009f26:	49 1b       	lddpc	r11,80009f68 <log_init+0x58>
80009f28:	fe 7c 18 00 	mov	r12,-59392
80009f2c:	f0 1f 00 10 	mcall	80009f6c <log_init+0x5c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80009f30:	30 4b       	mov	r11,4
80009f32:	33 2c       	mov	r12,50
80009f34:	f0 1f 00 0f 	mcall	80009f70 <log_init+0x60>
80009f38:	18 99       	mov	r9,r12
80009f3a:	48 f8       	lddpc	r8,80009f74 <log_init+0x64>
80009f3c:	91 09       	st.w	r8[0x0],r9
	
	xTaskCreate(
80009f3e:	48 fb       	lddpc	r11,80009f78 <log_init+0x68>
80009f40:	30 08       	mov	r8,0
80009f42:	1a d8       	st.w	--sp,r8
80009f44:	30 08       	mov	r8,0
80009f46:	1a d8       	st.w	--sp,r8
80009f48:	30 08       	mov	r8,0
80009f4a:	1a d8       	st.w	--sp,r8
80009f4c:	30 28       	mov	r8,2
80009f4e:	30 09       	mov	r9,0
80009f50:	e0 6a 01 80 	mov	r10,384
80009f54:	48 ac       	lddpc	r12,80009f7c <log_init+0x6c>
80009f56:	f0 1f 00 0b 	mcall	80009f80 <log_init+0x70>
80009f5a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80009f5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f60:	80 01       	ld.sh	r1,r0[0x0]
80009f62:	07 f8       	ld.ub	r8,r3[0x7]
80009f64:	80 00       	ld.sh	r0,r0[0x0]
80009f66:	a5 80       	lsr	r0,0x4
80009f68:	80 01       	ld.sh	r1,r0[0x0]
80009f6a:	08 08       	add	r8,r4
80009f6c:	80 00       	ld.sh	r0,r0[0x0]
80009f6e:	7b 0c       	ld.w	r12,sp[0x40]
80009f70:	80 00       	ld.sh	r0,r0[0x0]
80009f72:	85 40       	st.w	r2[0x10],r0
80009f74:	00 00       	add	r0,r0
80009f76:	41 10       	lddsp	r0,sp[0x44]
80009f78:	80 00       	ld.sh	r0,r0[0x0]
80009f7a:	9b 70       	st.w	sp[0x1c],r0
80009f7c:	80 00       	ld.sh	r0,r0[0x0]
80009f7e:	a4 60       	st.h	r2[0xc],r0
80009f80:	80 00       	ld.sh	r0,r0[0x0]
80009f82:	8d b0       	st.w	r6[0x2c],r0

80009f84 <log>:

int log(char * content, ...)
{
80009f84:	eb cd 40 c0 	pushm	r6-r7,lr
80009f88:	1a 97       	mov	r7,sp
80009f8a:	fa cd 02 28 	sub	sp,sp,552
80009f8e:	ee c6 ff f4 	sub	r6,r7,-12
80009f92:	ef 4c fd d8 	st.w	r7[-552],r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009f96:	ee c8 01 1c 	sub	r8,r7,284
80009f9a:	e0 6a 01 00 	mov	r10,256
80009f9e:	30 0b       	mov	r11,0
80009fa0:	10 9c       	mov	r12,r8
80009fa2:	f0 1f 00 84 	mcall	8000a1b0 <log+0x22c>
	
	int len = 0 ;
80009fa6:	30 08       	mov	r8,0
80009fa8:	ef 48 ff e4 	st.w	r7[-28],r8
	

	va_list arg_ptr;
	char* str = content;
80009fac:	ee f8 fd d8 	ld.w	r8,r7[-552]
80009fb0:	ef 48 ff e8 	st.w	r7[-24],r8
	int x;
	char y;
	float f;
	//char* s;
	char length= 0;
80009fb4:	30 08       	mov	r8,0
80009fb6:	ef 68 ff fb 	st.b	r7[-5],r8
		
	va_start(arg_ptr, content);
80009fba:	ec c8 00 00 	sub	r8,r6,0
80009fbe:	ef 48 fe e0 	st.w	r7[-288],r8
		//str += 4;
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
80009fc2:	ee c8 02 24 	sub	r8,r7,548
80009fc6:	ef 48 ff fc 	st.w	r7[-4],r8
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009fca:	e0 6a 01 00 	mov	r10,256
80009fce:	30 0b       	mov	r11,0
80009fd0:	ee fc ff fc 	ld.w	r12,r7[-4]
80009fd4:	f0 1f 00 77 	mcall	8000a1b0 <log+0x22c>
			
					if(*str == '%')
80009fd8:	ee f8 ff e8 	ld.w	r8,r7[-24]
80009fdc:	11 89       	ld.ub	r9,r8[0x0]
80009fde:	32 58       	mov	r8,37
80009fe0:	f0 09 18 00 	cp.b	r9,r8
80009fe4:	e0 81 00 9a 	brne	8000a118 <log+0x194>
					{
						static char lench = 0;
						lench =*(str + 1);
80009fe8:	ee f8 ff e8 	ld.w	r8,r7[-24]
80009fec:	2f f8       	sub	r8,-1
80009fee:	11 88       	ld.ub	r8,r8[0x0]
80009ff0:	4f 19       	lddpc	r9,8000a1b4 <log+0x230>
80009ff2:	b2 88       	st.b	r9[0x0],r8
						if((lench >= '0') &&  (lench <= '9'))
80009ff4:	4f 08       	lddpc	r8,8000a1b4 <log+0x230>
80009ff6:	11 89       	ld.ub	r9,r8[0x0]
80009ff8:	32 f8       	mov	r8,47
80009ffa:	f0 09 18 00 	cp.b	r9,r8
80009ffe:	e0 88 00 14 	brls	8000a026 <log+0xa2>
8000a002:	4e d8       	lddpc	r8,8000a1b4 <log+0x230>
8000a004:	11 89       	ld.ub	r9,r8[0x0]
8000a006:	33 98       	mov	r8,57
8000a008:	f0 09 18 00 	cp.b	r9,r8
8000a00c:	e0 8b 00 0d 	brhi	8000a026 <log+0xa2>
						{
							len = *(++str) - '0';
8000a010:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a014:	2f f8       	sub	r8,-1
8000a016:	ef 48 ff e8 	st.w	r7[-24],r8
8000a01a:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a01e:	11 88       	ld.ub	r8,r8[0x0]
8000a020:	23 08       	sub	r8,48
8000a022:	ef 48 ff e4 	st.w	r7[-28],r8
						}
						
						str++;
8000a026:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a02a:	2f f8       	sub	r8,-1
8000a02c:	ef 48 ff e8 	st.w	r7[-24],r8
						
						switch(*(str))
8000a030:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a034:	11 88       	ld.ub	r8,r8[0x0]
8000a036:	22 58       	sub	r8,37
8000a038:	e0 48 00 53 	cp.w	r8,83
8000a03c:	e0 8b 00 55 	brhi	8000a0e6 <log+0x162>
8000a040:	4d e9       	lddpc	r9,8000a1b8 <log+0x234>
8000a042:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000a046:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a04a:	f0 c9 ff fc 	sub	r9,r8,-4
8000a04e:	ef 49 fe e0 	st.w	r7[-288],r9
8000a052:	70 08       	ld.w	r8,r8[0x0]
8000a054:	ef 48 ff ec 	st.w	r7[-20],r8
							strTmp = PrintDec(x, len, strTmp);
8000a058:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000a05c:	5c 58       	castu.b	r8
8000a05e:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a062:	10 9b       	mov	r11,r8
8000a064:	ee fc ff ec 	ld.w	r12,r7[-20]
8000a068:	f0 1f 00 55 	mcall	8000a1bc <log+0x238>
8000a06c:	18 98       	mov	r8,r12
8000a06e:	ef 48 ff fc 	st.w	r7[-4],r8
							break;
8000a072:	c3 d8       	rjmp	8000a0ec <log+0x168>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000a074:	4d 3c       	lddpc	r12,8000a1c0 <log+0x23c>
8000a076:	f0 1f 00 54 	mcall	8000a1c4 <log+0x240>
							break;
8000a07a:	c3 98       	rjmp	8000a0ec <log+0x168>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000a07c:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a080:	f0 c9 ff fc 	sub	r9,r8,-4
8000a084:	ef 49 fe e0 	st.w	r7[-288],r9
8000a088:	70 08       	ld.w	r8,r8[0x0]
8000a08a:	ef 48 ff ec 	st.w	r7[-20],r8
							PrintHex(x,len, strTmp);
8000a08e:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000a092:	5c 58       	castu.b	r8
8000a094:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a098:	10 9b       	mov	r11,r8
8000a09a:	ee fc ff ec 	ld.w	r12,r7[-20]
8000a09e:	f0 1f 00 4b 	mcall	8000a1c8 <log+0x244>
							break;
8000a0a2:	c2 58       	rjmp	8000a0ec <log+0x168>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000a0a4:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a0a8:	f0 c9 ff fc 	sub	r9,r8,-4
8000a0ac:	ef 49 fe e0 	st.w	r7[-288],r9
8000a0b0:	70 08       	ld.w	r8,r8[0x0]
8000a0b2:	ef 68 ff f3 	st.b	r7[-13],r8
							PrintChar(y, strTmp);
8000a0b6:	ef 38 ff f3 	ld.ub	r8,r7[-13]
8000a0ba:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a0be:	10 9c       	mov	r12,r8
8000a0c0:	f0 1f 00 43 	mcall	8000a1cc <log+0x248>
							break;
8000a0c4:	c1 48       	rjmp	8000a0ec <log+0x168>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000a0c6:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a0ca:	f0 c9 ff fc 	sub	r9,r8,-4
8000a0ce:	ef 49 fe e0 	st.w	r7[-288],r9
8000a0d2:	70 08       	ld.w	r8,r8[0x0]
8000a0d4:	ef 48 ff fc 	st.w	r7[-4],r8
							//PrintStr(s);
							break;
8000a0d8:	c0 a8       	rjmp	8000a0ec <log+0x168>
							
							case('%'):
							PrintChar('%', strTmp);
8000a0da:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a0de:	32 5c       	mov	r12,37
8000a0e0:	f0 1f 00 3b 	mcall	8000a1cc <log+0x248>
							//PrintChar('%');
							break;
8000a0e4:	c0 48       	rjmp	8000a0ec <log+0x168>
							
							default:
							log("I need relax.");
8000a0e6:	4b bc       	lddpc	r12,8000a1d0 <log+0x24c>
8000a0e8:	f0 1f 00 37 	mcall	8000a1c4 <log+0x240>
						}
						str++;
8000a0ec:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a0f0:	2f f8       	sub	r8,-1
8000a0f2:	ef 48 ff e8 	st.w	r7[-24],r8
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a0f6:	ee c8 01 1c 	sub	r8,r7,284
8000a0fa:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a0fe:	1a d9       	st.w	--sp,r9
8000a100:	ee c9 01 1c 	sub	r9,r7,284
8000a104:	1a d9       	st.w	--sp,r9
8000a106:	4b 4b       	lddpc	r11,8000a1d4 <log+0x250>
8000a108:	10 9c       	mov	r12,r8
8000a10a:	f0 1f 00 34 	mcall	8000a1d8 <log+0x254>
8000a10e:	2f ed       	sub	sp,-8
8000a110:	18 98       	mov	r8,r12
8000a112:	ef 68 ff fb 	st.b	r7[-5],r8
8000a116:	c1 88       	rjmp	8000a146 <log+0x1c2>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a118:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a11c:	11 88       	ld.ub	r8,r8[0x0]
8000a11e:	10 99       	mov	r9,r8
8000a120:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a124:	2f f8       	sub	r8,-1
8000a126:	ef 48 ff e8 	st.w	r7[-24],r8
8000a12a:	ee c8 01 1c 	sub	r8,r7,284
8000a12e:	1a d9       	st.w	--sp,r9
8000a130:	ee c9 01 1c 	sub	r9,r7,284
8000a134:	1a d9       	st.w	--sp,r9
8000a136:	4a ab       	lddpc	r11,8000a1dc <log+0x258>
8000a138:	10 9c       	mov	r12,r8
8000a13a:	f0 1f 00 28 	mcall	8000a1d8 <log+0x254>
8000a13e:	2f ed       	sub	sp,-8
8000a140:	18 98       	mov	r8,r12
8000a142:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
	}while(*str != '\0');
8000a146:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a14a:	11 88       	ld.ub	r8,r8[0x0]
8000a14c:	58 08       	cp.w	r8,0
8000a14e:	fe 91 ff 3a 	brne	80009fc2 <log+0x3e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000a152:	ee c8 01 1c 	sub	r8,r7,284
8000a156:	ee c9 01 1c 	sub	r9,r7,284
8000a15a:	1a d9       	st.w	--sp,r9
8000a15c:	4a 1b       	lddpc	r11,8000a1e0 <log+0x25c>
8000a15e:	10 9c       	mov	r12,r8
8000a160:	f0 1f 00 1e 	mcall	8000a1d8 <log+0x254>
8000a164:	2f fd       	sub	sp,-4
8000a166:	18 98       	mov	r8,r12
8000a168:	ef 68 ff fb 	st.b	r7[-5],r8
	
	char * p = pvPortMalloc(length+1);
8000a16c:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a170:	2f f8       	sub	r8,-1
8000a172:	10 9c       	mov	r12,r8
8000a174:	f0 1f 00 1c 	mcall	8000a1e4 <log+0x260>
8000a178:	18 98       	mov	r8,r12
8000a17a:	ef 48 fe dc 	st.w	r7[-292],r8
	memcpy(p, logTmp, length+1);
8000a17e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a182:	2f f8       	sub	r8,-1
8000a184:	10 9a       	mov	r10,r8
8000a186:	ee f8 fe dc 	ld.w	r8,r7[-292]
8000a18a:	ee c9 01 1c 	sub	r9,r7,284
8000a18e:	12 9b       	mov	r11,r9
8000a190:	10 9c       	mov	r12,r8
8000a192:	f0 1f 00 16 	mcall	8000a1e8 <log+0x264>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000a196:	49 68       	lddpc	r8,8000a1ec <log+0x268>
8000a198:	70 08       	ld.w	r8,r8[0x0]
8000a19a:	ee cb 01 24 	sub	r11,r7,292
8000a19e:	30 09       	mov	r9,0
8000a1a0:	30 5a       	mov	r10,5
8000a1a2:	10 9c       	mov	r12,r8
8000a1a4:	f0 1f 00 13 	mcall	8000a1f0 <log+0x26c>
	
	
}
8000a1a8:	fe 3d fd d8 	sub	sp,-552
8000a1ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a1b0:	80 00       	ld.sh	r0,r0[0x0]
8000a1b2:	ad be       	sbr	lr,0xd
8000a1b4:	00 00       	add	r0,r0
8000a1b6:	0d 55       	ld.sh	r5,--r6
8000a1b8:	80 01       	ld.sh	r1,r0[0x0]
8000a1ba:	05 58       	ld.sh	r8,--r2
8000a1bc:	80 00       	ld.sh	r0,r0[0x0]
8000a1be:	9b e0       	st.w	sp[0x38],r0
8000a1c0:	80 00       	ld.sh	r0,r0[0x0]
8000a1c2:	9b 74       	st.w	sp[0x1c],r4
8000a1c4:	80 00       	ld.sh	r0,r0[0x0]
8000a1c6:	9f 84       	st.w	pc[0x20],r4
8000a1c8:	80 00       	ld.sh	r0,r0[0x0]
8000a1ca:	9d 98       	st.w	lr[0x24],r8
8000a1cc:	80 00       	ld.sh	r0,r0[0x0]
8000a1ce:	9b ac       	st.w	sp[0x28],r12
8000a1d0:	80 00       	ld.sh	r0,r0[0x0]
8000a1d2:	9b 84       	st.w	sp[0x20],r4
8000a1d4:	80 00       	ld.sh	r0,r0[0x0]
8000a1d6:	9b 94       	st.w	sp[0x24],r4
8000a1d8:	80 00       	ld.sh	r0,r0[0x0]
8000a1da:	b0 ac       	st.b	r8[0x2],r12
8000a1dc:	80 00       	ld.sh	r0,r0[0x0]
8000a1de:	9b 9c       	st.w	sp[0x24],r12
8000a1e0:	80 00       	ld.sh	r0,r0[0x0]
8000a1e2:	9b a4       	st.w	sp[0x28],r4
8000a1e4:	80 00       	ld.sh	r0,r0[0x0]
8000a1e6:	84 cc       	ld.uh	r12,r2[0x8]
8000a1e8:	80 00       	ld.sh	r0,r0[0x0]
8000a1ea:	ac 76       	st.h	r6[0xe],r6
8000a1ec:	00 00       	add	r0,r0
8000a1ee:	41 10       	lddsp	r0,sp[0x44]
8000a1f0:	80 00       	ld.sh	r0,r0[0x0]
8000a1f2:	86 58       	ld.sh	r8,r3[0xa]

8000a1f4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000a1f4:	eb cd 40 c0 	pushm	r6-r7,lr
8000a1f8:	1a 97       	mov	r7,sp
8000a1fa:	fa cd 02 24 	sub	sp,sp,548
8000a1fe:	ee c6 ff f4 	sub	r6,r7,-12
8000a202:	ef 4c fd dc 	st.w	r7[-548],r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000a206:	ee c8 01 14 	sub	r8,r7,276
8000a20a:	e0 6a 01 00 	mov	r10,256
8000a20e:	30 0b       	mov	r11,0
8000a210:	10 9c       	mov	r12,r8
8000a212:	f0 1f 00 84 	mcall	8000a420 <logFromISR+0x22c>
		
		int len = 0 ;
8000a216:	30 08       	mov	r8,0
8000a218:	ef 48 ff ec 	st.w	r7[-20],r8
		

		va_list arg_ptr;
		char* str = content;
8000a21c:	ee f8 fd dc 	ld.w	r8,r7[-548]
8000a220:	ef 48 ff f0 	st.w	r7[-16],r8
		int x;
		char y;
		//char* s;
		char length= 0;
8000a224:	30 08       	mov	r8,0
8000a226:	ef 68 ff fb 	st.b	r7[-5],r8
		
		va_start(arg_ptr, content);
8000a22a:	ec c8 00 00 	sub	r8,r6,0
8000a22e:	ef 48 fe e8 	st.w	r7[-280],r8
		//str += 4;
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
8000a232:	ee c8 02 20 	sub	r8,r7,544
8000a236:	ef 48 ff fc 	st.w	r7[-4],r8
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a23a:	e0 6a 01 00 	mov	r10,256
8000a23e:	30 0b       	mov	r11,0
8000a240:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a244:	f0 1f 00 77 	mcall	8000a420 <logFromISR+0x22c>
			
			if(*str == '%')
8000a248:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a24c:	11 89       	ld.ub	r9,r8[0x0]
8000a24e:	32 58       	mov	r8,37
8000a250:	f0 09 18 00 	cp.b	r9,r8
8000a254:	e0 81 00 96 	brne	8000a380 <logFromISR+0x18c>
			{
				static char lench = 0;
				lench =*(str + 1);
8000a258:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a25c:	2f f8       	sub	r8,-1
8000a25e:	11 88       	ld.ub	r8,r8[0x0]
8000a260:	4f 19       	lddpc	r9,8000a424 <logFromISR+0x230>
8000a262:	b2 88       	st.b	r9[0x0],r8
				if((lench >= '0') &&  (lench <= '9'))
8000a264:	4f 08       	lddpc	r8,8000a424 <logFromISR+0x230>
8000a266:	11 89       	ld.ub	r9,r8[0x0]
8000a268:	32 f8       	mov	r8,47
8000a26a:	f0 09 18 00 	cp.b	r9,r8
8000a26e:	e0 88 00 14 	brls	8000a296 <logFromISR+0xa2>
8000a272:	4e d8       	lddpc	r8,8000a424 <logFromISR+0x230>
8000a274:	11 89       	ld.ub	r9,r8[0x0]
8000a276:	33 98       	mov	r8,57
8000a278:	f0 09 18 00 	cp.b	r9,r8
8000a27c:	e0 8b 00 0d 	brhi	8000a296 <logFromISR+0xa2>
				{
					len = *(++str) - '0';
8000a280:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a284:	2f f8       	sub	r8,-1
8000a286:	ef 48 ff f0 	st.w	r7[-16],r8
8000a28a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a28e:	11 88       	ld.ub	r8,r8[0x0]
8000a290:	23 08       	sub	r8,48
8000a292:	ef 48 ff ec 	st.w	r7[-20],r8
				}
				
				str++;
8000a296:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a29a:	2f f8       	sub	r8,-1
8000a29c:	ef 48 ff f0 	st.w	r7[-16],r8
				
				switch(*(str))
8000a2a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a2a4:	11 88       	ld.ub	r8,r8[0x0]
8000a2a6:	22 58       	sub	r8,37
8000a2a8:	e0 48 00 53 	cp.w	r8,83
8000a2ac:	e0 8b 00 51 	brhi	8000a34e <logFromISR+0x15a>
8000a2b0:	4d e9       	lddpc	r9,8000a428 <logFromISR+0x234>
8000a2b2:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000a2b6:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a2ba:	f0 c9 ff fc 	sub	r9,r8,-4
8000a2be:	ef 49 fe e8 	st.w	r7[-280],r9
8000a2c2:	70 08       	ld.w	r8,r8[0x0]
8000a2c4:	ef 48 ff f4 	st.w	r7[-12],r8
					strTmp = PrintDec(x, len, strTmp);
8000a2c8:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a2cc:	5c 58       	castu.b	r8
8000a2ce:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a2d2:	10 9b       	mov	r11,r8
8000a2d4:	ee fc ff f4 	ld.w	r12,r7[-12]
8000a2d8:	f0 1f 00 55 	mcall	8000a42c <logFromISR+0x238>
8000a2dc:	18 98       	mov	r8,r12
8000a2de:	ef 48 ff fc 	st.w	r7[-4],r8
					break;
8000a2e2:	c3 98       	rjmp	8000a354 <logFromISR+0x160>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000a2e4:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a2e8:	f0 c9 ff fc 	sub	r9,r8,-4
8000a2ec:	ef 49 fe e8 	st.w	r7[-280],r9
8000a2f0:	70 08       	ld.w	r8,r8[0x0]
8000a2f2:	ef 48 ff f4 	st.w	r7[-12],r8
					PrintHex(x,len, strTmp);
8000a2f6:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a2fa:	5c 58       	castu.b	r8
8000a2fc:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a300:	10 9b       	mov	r11,r8
8000a302:	ee fc ff f4 	ld.w	r12,r7[-12]
8000a306:	f0 1f 00 4b 	mcall	8000a430 <logFromISR+0x23c>
					break;
8000a30a:	c2 58       	rjmp	8000a354 <logFromISR+0x160>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000a30c:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a310:	f0 c9 ff fc 	sub	r9,r8,-4
8000a314:	ef 49 fe e8 	st.w	r7[-280],r9
8000a318:	70 08       	ld.w	r8,r8[0x0]
8000a31a:	ef 68 ff fa 	st.b	r7[-6],r8
					PrintChar(y, strTmp);
8000a31e:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000a322:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a326:	10 9c       	mov	r12,r8
8000a328:	f0 1f 00 43 	mcall	8000a434 <logFromISR+0x240>
					break;
8000a32c:	c1 48       	rjmp	8000a354 <logFromISR+0x160>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000a32e:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a332:	f0 c9 ff fc 	sub	r9,r8,-4
8000a336:	ef 49 fe e8 	st.w	r7[-280],r9
8000a33a:	70 08       	ld.w	r8,r8[0x0]
8000a33c:	ef 48 ff fc 	st.w	r7[-4],r8
					//PrintStr(s);
					break;
8000a340:	c0 a8       	rjmp	8000a354 <logFromISR+0x160>
					case('%'):
					PrintChar('%', strTmp);
8000a342:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a346:	32 5c       	mov	r12,37
8000a348:	f0 1f 00 3b 	mcall	8000a434 <logFromISR+0x240>
					//PrintChar('%');
					break;
8000a34c:	c0 48       	rjmp	8000a354 <logFromISR+0x160>
					default:
					log("I need relax.");
8000a34e:	4b bc       	lddpc	r12,8000a438 <logFromISR+0x244>
8000a350:	f0 1f 00 3b 	mcall	8000a43c <logFromISR+0x248>
				}
				str++;
8000a354:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a358:	2f f8       	sub	r8,-1
8000a35a:	ef 48 ff f0 	st.w	r7[-16],r8
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a35e:	ee c8 01 14 	sub	r8,r7,276
8000a362:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a366:	1a d9       	st.w	--sp,r9
8000a368:	ee c9 01 14 	sub	r9,r7,276
8000a36c:	1a d9       	st.w	--sp,r9
8000a36e:	4b 5b       	lddpc	r11,8000a440 <logFromISR+0x24c>
8000a370:	10 9c       	mov	r12,r8
8000a372:	f0 1f 00 35 	mcall	8000a444 <logFromISR+0x250>
8000a376:	2f ed       	sub	sp,-8
8000a378:	18 98       	mov	r8,r12
8000a37a:	ef 68 ff fb 	st.b	r7[-5],r8
8000a37e:	c1 88       	rjmp	8000a3ae <logFromISR+0x1ba>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a380:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a384:	11 88       	ld.ub	r8,r8[0x0]
8000a386:	10 99       	mov	r9,r8
8000a388:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a38c:	2f f8       	sub	r8,-1
8000a38e:	ef 48 ff f0 	st.w	r7[-16],r8
8000a392:	ee c8 01 14 	sub	r8,r7,276
8000a396:	1a d9       	st.w	--sp,r9
8000a398:	ee c9 01 14 	sub	r9,r7,276
8000a39c:	1a d9       	st.w	--sp,r9
8000a39e:	4a bb       	lddpc	r11,8000a448 <logFromISR+0x254>
8000a3a0:	10 9c       	mov	r12,r8
8000a3a2:	f0 1f 00 29 	mcall	8000a444 <logFromISR+0x250>
8000a3a6:	2f ed       	sub	sp,-8
8000a3a8:	18 98       	mov	r8,r12
8000a3aa:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
		}while(*str != '\0');
8000a3ae:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a3b2:	11 88       	ld.ub	r8,r8[0x0]
8000a3b4:	58 08       	cp.w	r8,0
8000a3b6:	fe 91 ff 3e 	brne	8000a232 <logFromISR+0x3e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000a3ba:	ee c8 01 14 	sub	r8,r7,276
8000a3be:	ee c9 01 14 	sub	r9,r7,276
8000a3c2:	1a d9       	st.w	--sp,r9
8000a3c4:	4a 2b       	lddpc	r11,8000a44c <logFromISR+0x258>
8000a3c6:	10 9c       	mov	r12,r8
8000a3c8:	f0 1f 00 1f 	mcall	8000a444 <logFromISR+0x250>
8000a3cc:	2f fd       	sub	sp,-4
8000a3ce:	18 98       	mov	r8,r12
8000a3d0:	ef 68 ff fb 	st.b	r7[-5],r8
		
		char * p = pvPortMalloc(length+1);
8000a3d4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a3d8:	2f f8       	sub	r8,-1
8000a3da:	10 9c       	mov	r12,r8
8000a3dc:	f0 1f 00 1d 	mcall	8000a450 <logFromISR+0x25c>
8000a3e0:	18 98       	mov	r8,r12
8000a3e2:	ef 48 fe e4 	st.w	r7[-284],r8
		memcpy(p, logTmp, length+1);
8000a3e6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a3ea:	2f f8       	sub	r8,-1
8000a3ec:	10 9a       	mov	r10,r8
8000a3ee:	ee f8 fe e4 	ld.w	r8,r7[-284]
8000a3f2:	ee c9 01 14 	sub	r9,r7,276
8000a3f6:	12 9b       	mov	r11,r9
8000a3f8:	10 9c       	mov	r12,r8
8000a3fa:	f0 1f 00 17 	mcall	8000a454 <logFromISR+0x260>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000a3fe:	30 08       	mov	r8,0
8000a400:	ef 48 fe e0 	st.w	r7[-288],r8
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000a404:	49 58       	lddpc	r8,8000a458 <logFromISR+0x264>
8000a406:	70 08       	ld.w	r8,r8[0x0]
8000a408:	ee ca 01 20 	sub	r10,r7,288
8000a40c:	ee cb 01 1c 	sub	r11,r7,284
8000a410:	30 09       	mov	r9,0
8000a412:	10 9c       	mov	r12,r8
8000a414:	f0 1f 00 12 	mcall	8000a45c <logFromISR+0x268>
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000a418:	fe 3d fd dc 	sub	sp,-548
8000a41c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a420:	80 00       	ld.sh	r0,r0[0x0]
8000a422:	ad be       	sbr	lr,0xd
8000a424:	00 00       	add	r0,r0
8000a426:	0d 54       	ld.sh	r4,--r6
8000a428:	80 01       	ld.sh	r1,r0[0x0]
8000a42a:	06 a8       	st.w	r3++,r8
8000a42c:	80 00       	ld.sh	r0,r0[0x0]
8000a42e:	9b e0       	st.w	sp[0x38],r0
8000a430:	80 00       	ld.sh	r0,r0[0x0]
8000a432:	9d 98       	st.w	lr[0x24],r8
8000a434:	80 00       	ld.sh	r0,r0[0x0]
8000a436:	9b ac       	st.w	sp[0x28],r12
8000a438:	80 00       	ld.sh	r0,r0[0x0]
8000a43a:	9b 84       	st.w	sp[0x20],r4
8000a43c:	80 00       	ld.sh	r0,r0[0x0]
8000a43e:	9f 84       	st.w	pc[0x20],r4
8000a440:	80 00       	ld.sh	r0,r0[0x0]
8000a442:	9b 94       	st.w	sp[0x24],r4
8000a444:	80 00       	ld.sh	r0,r0[0x0]
8000a446:	b0 ac       	st.b	r8[0x2],r12
8000a448:	80 00       	ld.sh	r0,r0[0x0]
8000a44a:	9b 9c       	st.w	sp[0x24],r12
8000a44c:	80 00       	ld.sh	r0,r0[0x0]
8000a44e:	9b a4       	st.w	sp[0x28],r4
8000a450:	80 00       	ld.sh	r0,r0[0x0]
8000a452:	84 cc       	ld.uh	r12,r2[0x8]
8000a454:	80 00       	ld.sh	r0,r0[0x0]
8000a456:	ac 76       	st.h	r6[0xe],r6
8000a458:	00 00       	add	r0,r0
8000a45a:	41 10       	lddsp	r0,sp[0x44]
8000a45c:	80 00       	ld.sh	r0,r0[0x0]
8000a45e:	87 c0       	st.w	r3[0x30],r0

8000a460 <task_log>:
	
static void task_log(void * pvParameters)
{
8000a460:	eb cd 40 80 	pushm	r7,lr
8000a464:	1a 97       	mov	r7,sp
8000a466:	20 2d       	sub	sp,8
8000a468:	ef 4c ff f8 	st.w	r7[-8],r12
8000a46c:	c0 48       	rjmp	8000a474 <task_log+0x14>
				vPortFree(str);
			}
			
		}

	}
8000a46e:	d7 03       	nop
8000a470:	c0 28       	rjmp	8000a474 <task_log+0x14>
8000a472:	d7 03       	nop
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a474:	48 f8       	lddpc	r8,8000a4b0 <task_log+0x50>
8000a476:	70 08       	ld.w	r8,r8[0x0]
8000a478:	ee cb 00 04 	sub	r11,r7,4
8000a47c:	30 09       	mov	r9,0
8000a47e:	3f fa       	mov	r10,-1
8000a480:	10 9c       	mov	r12,r8
8000a482:	f0 1f 00 0d 	mcall	8000a4b4 <task_log+0x54>
8000a486:	18 98       	mov	r8,r12
8000a488:	58 18       	cp.w	r8,1
8000a48a:	cf 21       	brne	8000a46e <task_log+0xe>
		{
			if( NULL != str)
8000a48c:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a490:	58 08       	cp.w	r8,0
8000a492:	cf 00       	breq	8000a472 <task_log+0x12>
			{
				usart_write_line(EXAMPLE_USART, str);
8000a494:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a498:	10 9b       	mov	r11,r8
8000a49a:	fe 7c 18 00 	mov	r12,-59392
8000a49e:	f0 1f 00 07 	mcall	8000a4b8 <task_log+0x58>
				vPortFree(str);
8000a4a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a4a6:	10 9c       	mov	r12,r8
8000a4a8:	f0 1f 00 05 	mcall	8000a4bc <task_log+0x5c>
			}
			
		}

	}
8000a4ac:	ce 4b       	rjmp	8000a474 <task_log+0x14>
8000a4ae:	00 00       	add	r0,r0
8000a4b0:	00 00       	add	r0,r0
8000a4b2:	41 10       	lddsp	r0,sp[0x44]
8000a4b4:	80 00       	ld.sh	r0,r0[0x0]
8000a4b6:	88 64       	ld.sh	r4,r4[0xc]
8000a4b8:	80 00       	ld.sh	r0,r0[0x0]
8000a4ba:	7d ac       	ld.w	r12,lr[0x68]
8000a4bc:	80 00       	ld.sh	r0,r0[0x0]
8000a4be:	85 08       	st.w	r2[0x0],r8
8000a4c0:	2d 2d       	sub	sp,-184
8000a4c2:	2d 2d       	sub	sp,-184
8000a4c4:	73 74       	ld.w	r4,r9[0x5c]
8000a4c6:	61 72       	ld.w	r2,r0[0x5c]
8000a4c8:	74 20       	ld.w	r0,r10[0x8]
8000a4ca:	64 65       	ld.w	r5,r2[0x18]
8000a4cc:	62 75       	ld.w	r5,r1[0x1c]
8000a4ce:	67 a3       	ld.w	r3,r3[0x68]
8000a4d0:	ac 20       	st.h	r6[0x4],r0
8000a4d2:	79 6f       	ld.w	pc,r12[0x58]
8000a4d4:	79 6f       	ld.w	pc,r12[0x58]
8000a4d6:	2d 2d       	sub	sp,-184
8000a4d8:	2d 2d       	sub	sp,-184
	...

8000a4dc <main>:
//#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
8000a4dc:	eb cd 40 80 	pushm	r7,lr
8000a4e0:	1a 97       	mov	r7,sp
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000a4e2:	fe 78 10 00 	mov	r8,-61440
8000a4e6:	30 19       	mov	r9,1
8000a4e8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000a4ec:	fe 78 10 00 	mov	r8,-61440
8000a4f0:	30 19       	mov	r9,1
8000a4f2:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000a4f6:	fe 78 10 00 	mov	r8,-61440
8000a4fa:	30 19       	mov	r9,1
8000a4fc:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000a500:	d3 03       	ssrf	0x10
	local_start_pll0();
8000a502:	f0 1f 00 15 	mcall	8000a554 <main+0x78>
		
	INTC_init_interrupts();
8000a506:	f0 1f 00 15 	mcall	8000a558 <main+0x7c>
	
	log_init();		
8000a50a:	f0 1f 00 15 	mcall	8000a55c <main+0x80>
	log("----start debug yoyo----");	
8000a50e:	49 5c       	lddpc	r12,8000a560 <main+0x84>
8000a510:	f0 1f 00 15 	mcall	8000a564 <main+0x88>
	
	data_flash_init();
8000a514:	f0 1f 00 15 	mcall	8000a568 <main+0x8c>
		
	//rtc_init();
	
	//fs_init();//65795,RadioOBSD

	tc_init();	
8000a518:	f0 1f 00 15 	mcall	8000a56c <main+0x90>
			
	xcmp_init();
8000a51c:	f0 1f 00 15 	mcall	8000a570 <main+0x94>
	
	app_init();
8000a520:	f0 1f 00 15 	mcall	8000a574 <main+0x98>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000a524:	fe 78 10 00 	mov	r8,-61440
8000a528:	f0 f8 01 60 	ld.w	r8,r8[352]
8000a52c:	e2 18 00 02 	andl	r8,0x2,COH
8000a530:	cf a0       	breq	8000a524 <main+0x48>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000a532:	fe 78 10 00 	mov	r8,-61440
8000a536:	f0 f8 01 60 	ld.w	r8,r8[352]
8000a53a:	e2 18 00 02 	andl	r8,0x2,COH
8000a53e:	cf a1       	brne	8000a532 <main+0x56>
	local_start_timer();
8000a540:	f0 1f 00 0e 	mcall	8000a578 <main+0x9c>
	
	Enable_global_interrupt();
8000a544:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000a546:	f0 1f 00 0e 	mcall	8000a57c <main+0xa0>
	return 0;
8000a54a:	30 08       	mov	r8,0
}
8000a54c:	10 9c       	mov	r12,r8
8000a54e:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a552:	00 00       	add	r0,r0
8000a554:	80 00       	ld.sh	r0,r0[0x0]
8000a556:	6d 1c       	ld.w	r12,r6[0x44]
8000a558:	80 00       	ld.sh	r0,r0[0x0]
8000a55a:	6f 20       	ld.w	r0,r7[0x48]
8000a55c:	80 00       	ld.sh	r0,r0[0x0]
8000a55e:	9f 10       	st.w	pc[0x4],r0
8000a560:	80 00       	ld.sh	r0,r0[0x0]
8000a562:	a4 c0       	st.b	r2[0x4],r0
8000a564:	80 00       	ld.sh	r0,r0[0x0]
8000a566:	9f 84       	st.w	pc[0x20],r4
8000a568:	80 00       	ld.sh	r0,r0[0x0]
8000a56a:	35 00       	mov	r0,80
8000a56c:	80 00       	ld.sh	r0,r0[0x0]
8000a56e:	6e 24       	ld.w	r4,r7[0x8]
8000a570:	80 00       	ld.sh	r0,r0[0x0]
8000a572:	61 d8       	ld.w	r8,r0[0x74]
8000a574:	80 00       	ld.sh	r0,r0[0x0]
8000a576:	33 2c       	mov	r12,50
8000a578:	80 00       	ld.sh	r0,r0[0x0]
8000a57a:	6d b4       	ld.w	r4,r6[0x6c]
8000a57c:	80 00       	ld.sh	r0,r0[0x0]
8000a57e:	90 58       	ld.sh	r8,r8[0xa]

8000a580 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000a580:	eb cd 40 80 	pushm	r7,lr
8000a584:	1a 97       	mov	r7,sp
8000a586:	20 4d       	sub	sp,16
8000a588:	ef 4c ff f4 	st.w	r7[-12],r12
8000a58c:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
8000a590:	30 08       	mov	r8,0
8000a592:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a596:	30 08       	mov	r8,0
8000a598:	ef 48 ff fc 	st.w	r7[-4],r8
8000a59c:	c1 c8       	rjmp	8000a5d4 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000a59e:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a5a2:	70 19       	ld.w	r9,r8[0x4]
8000a5a4:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a5a8:	70 08       	ld.w	r8,r8[0x0]
8000a5aa:	12 9b       	mov	r11,r9
8000a5ac:	10 9c       	mov	r12,r8
8000a5ae:	f0 1f 00 10 	mcall	8000a5ec <gpio_enable_module+0x6c>
8000a5b2:	18 98       	mov	r8,r12
8000a5b4:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000a5b8:	f3 e8 10 08 	or	r8,r9,r8
8000a5bc:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
8000a5c0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a5c4:	2f 88       	sub	r8,-8
8000a5c6:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a5ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a5ce:	2f f8       	sub	r8,-1
8000a5d0:	ef 48 ff fc 	st.w	r7[-4],r8
8000a5d4:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a5d8:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a5dc:	10 39       	cp.w	r9,r8
8000a5de:	ce 03       	brcs	8000a59e <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
8000a5e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000a5e4:	10 9c       	mov	r12,r8
8000a5e6:	2f cd       	sub	sp,-16
8000a5e8:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a5ec:	80 00       	ld.sh	r0,r0[0x0]
8000a5ee:	a5 f0       	*unknown*

8000a5f0 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
8000a5f0:	eb cd 40 80 	pushm	r7,lr
8000a5f4:	1a 97       	mov	r7,sp
8000a5f6:	20 3d       	sub	sp,12
8000a5f8:	ef 4c ff f8 	st.w	r7[-8],r12
8000a5fc:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a600:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a604:	a5 98       	lsr	r8,0x5
8000a606:	a9 68       	lsl	r8,0x8
8000a608:	e0 28 f0 00 	sub	r8,61440
8000a60c:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
8000a610:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a614:	58 18       	cp.w	r8,1
8000a616:	c1 e0       	breq	8000a652 <gpio_enable_module_pin+0x62>
8000a618:	c0 63       	brcs	8000a624 <gpio_enable_module_pin+0x34>
8000a61a:	58 28       	cp.w	r8,2
8000a61c:	c3 20       	breq	8000a680 <gpio_enable_module_pin+0x90>
8000a61e:	58 38       	cp.w	r8,3
8000a620:	c4 70       	breq	8000a6ae <gpio_enable_module_pin+0xbe>
8000a622:	c5 d8       	rjmp	8000a6dc <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a624:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a628:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a62c:	30 19       	mov	r9,1
8000a62e:	f2 08 09 48 	lsl	r8,r9,r8
8000a632:	10 99       	mov	r9,r8
8000a634:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a638:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a63a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a63e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a642:	30 19       	mov	r9,1
8000a644:	f2 08 09 48 	lsl	r8,r9,r8
8000a648:	10 99       	mov	r9,r8
8000a64a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a64e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a650:	c4 88       	rjmp	8000a6e0 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a652:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a656:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a65a:	30 19       	mov	r9,1
8000a65c:	f2 08 09 48 	lsl	r8,r9,r8
8000a660:	10 99       	mov	r9,r8
8000a662:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a666:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a668:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a66c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a670:	30 19       	mov	r9,1
8000a672:	f2 08 09 48 	lsl	r8,r9,r8
8000a676:	10 99       	mov	r9,r8
8000a678:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a67c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a67e:	c3 18       	rjmp	8000a6e0 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a680:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a684:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a688:	30 19       	mov	r9,1
8000a68a:	f2 08 09 48 	lsl	r8,r9,r8
8000a68e:	10 99       	mov	r9,r8
8000a690:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a694:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a696:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a69a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a69e:	30 19       	mov	r9,1
8000a6a0:	f2 08 09 48 	lsl	r8,r9,r8
8000a6a4:	10 99       	mov	r9,r8
8000a6a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a6aa:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a6ac:	c1 a8       	rjmp	8000a6e0 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a6ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a6b2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a6b6:	30 19       	mov	r9,1
8000a6b8:	f2 08 09 48 	lsl	r8,r9,r8
8000a6bc:	10 99       	mov	r9,r8
8000a6be:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a6c2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a6c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a6c8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a6cc:	30 19       	mov	r9,1
8000a6ce:	f2 08 09 48 	lsl	r8,r9,r8
8000a6d2:	10 99       	mov	r9,r8
8000a6d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a6d8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a6da:	c0 38       	rjmp	8000a6e0 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
8000a6dc:	30 18       	mov	r8,1
8000a6de:	c0 d8       	rjmp	8000a6f8 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000a6e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a6e4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a6e8:	30 19       	mov	r9,1
8000a6ea:	f2 08 09 48 	lsl	r8,r9,r8
8000a6ee:	10 99       	mov	r9,r8
8000a6f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a6f4:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
8000a6f6:	30 08       	mov	r8,0
}
8000a6f8:	10 9c       	mov	r12,r8
8000a6fa:	2f dd       	sub	sp,-12
8000a6fc:	e3 cd 80 80 	ldm	sp++,r7,pc

8000a700 <gpio_enable_gpio_pin>:
 *            GPIO mode of PX21, AVR32_PIN_PX21 can be used. Module pins such as
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
8000a700:	eb cd 40 80 	pushm	r7,lr
8000a704:	1a 97       	mov	r7,sp
8000a706:	20 2d       	sub	sp,8
8000a708:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a70c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a710:	a5 98       	lsr	r8,0x5
8000a712:	a9 68       	lsl	r8,0x8
8000a714:	e0 28 f0 00 	sub	r8,61440
8000a718:	ef 48 ff fc 	st.w	r7[-4],r8
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000a71c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a720:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a724:	30 19       	mov	r9,1
8000a726:	f2 08 09 48 	lsl	r8,r9,r8
8000a72a:	10 99       	mov	r9,r8
8000a72c:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a730:	f1 49 00 48 	st.w	r8[72],r9
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a734:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a738:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a73c:	30 19       	mov	r9,1
8000a73e:	f2 08 09 48 	lsl	r8,r9,r8
8000a742:	10 99       	mov	r9,r8
8000a744:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a748:	91 19       	st.w	r8[0x4],r9
}
8000a74a:	2f ed       	sub	sp,-8
8000a74c:	e3 cd 80 80 	ldm	sp++,r7,pc

8000a750 <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
8000a750:	eb cd 40 80 	pushm	r7,lr
8000a754:	1a 97       	mov	r7,sp
8000a756:	20 2d       	sub	sp,8
8000a758:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a75c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a760:	a5 98       	lsr	r8,0x5
8000a762:	a9 68       	lsl	r8,0x8
8000a764:	e0 28 f0 00 	sub	r8,61440
8000a768:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000a76c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a770:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a774:	30 19       	mov	r9,1
8000a776:	f2 08 09 48 	lsl	r8,r9,r8
8000a77a:	10 99       	mov	r9,r8
8000a77c:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a780:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000a784:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a788:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a78c:	30 19       	mov	r9,1
8000a78e:	f2 08 09 48 	lsl	r8,r9,r8
8000a792:	10 99       	mov	r9,r8
8000a794:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a798:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a79c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a7a0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a7a4:	30 19       	mov	r9,1
8000a7a6:	f2 08 09 48 	lsl	r8,r9,r8
8000a7aa:	10 99       	mov	r9,r8
8000a7ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a7b0:	91 19       	st.w	r8[0x4],r9
}
8000a7b2:	2f ed       	sub	sp,-8
8000a7b4:	e3 cd 80 80 	ldm	sp++,r7,pc

8000a7b8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000a7b8:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000a7bc:	fe c0 a5 bc 	sub	r0,pc,-23108

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000a7c0:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000a7c4:	d5 53       	csrf	0x15
  cp      r0, r1
8000a7c6:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000a7c8:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000a7cc:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000a7ce:	c0 72       	brcc	8000a7dc <idata_load_loop_end>
  cp      r0, r1
8000a7d0:	fe c2 9a 30 	sub	r2,pc,-26064

8000a7d4 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000a7d4:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000a7d6:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000a7d8:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000a7da:	cf d3       	brcs	8000a7d4 <idata_load_loop>

8000a7dc <idata_load_loop_end>:
  mov     r2, 0
8000a7dc:	e0 60 0a 50 	mov	r0,2640
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
8000a7e0:	e0 61 41 18 	mov	r1,16664
  cp      r0, r1
  brlo    udata_clear_loop
8000a7e4:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000a7e6:	c0 62       	brcc	8000a7f2 <udata_clear_loop_end>
8000a7e8:	30 02       	mov	r2,0
8000a7ea:	30 03       	mov	r3,0

8000a7ec <udata_clear_loop>:
8000a7ec:	a1 22       	st.d	r0++,r2
8000a7ee:	02 30       	cp.w	r0,r1
8000a7f0:	cf e3       	brcs	8000a7ec <udata_clear_loop>

8000a7f2 <udata_clear_loop_end>:
8000a7f2:	fe cf 03 16 	sub	pc,pc,790
8000a7f6:	d7 03       	nop

8000a7f8 <free>:
8000a7f8:	d4 01       	pushm	lr
8000a7fa:	e0 68 0a 4c 	mov	r8,2636
8000a7fe:	18 9b       	mov	r11,r12
8000a800:	70 0c       	ld.w	r12,r8[0x0]
8000a802:	e0 a0 1e 7f 	rcall	8000e500 <_free_r>
8000a806:	d8 02       	popm	pc

8000a808 <malloc>:
8000a808:	d4 01       	pushm	lr
8000a80a:	e0 68 0a 4c 	mov	r8,2636
8000a80e:	18 9b       	mov	r11,r12
8000a810:	70 0c       	ld.w	r12,r8[0x0]
8000a812:	c0 3c       	rcall	8000a818 <_malloc_r>
8000a814:	d8 02       	popm	pc
8000a816:	d7 03       	nop

8000a818 <_malloc_r>:
8000a818:	d4 31       	pushm	r0-r7,lr
8000a81a:	f6 c8 ff f5 	sub	r8,r11,-11
8000a81e:	18 95       	mov	r5,r12
8000a820:	10 97       	mov	r7,r8
8000a822:	e0 17 ff f8 	andl	r7,0xfff8
8000a826:	59 68       	cp.w	r8,22
8000a828:	f9 b7 08 10 	movls	r7,16
8000a82c:	16 37       	cp.w	r7,r11
8000a82e:	5f 38       	srlo	r8
8000a830:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a834:	c0 50       	breq	8000a83e <_malloc_r+0x26>
8000a836:	30 c8       	mov	r8,12
8000a838:	99 38       	st.w	r12[0xc],r8
8000a83a:	e0 8f 01 fa 	bral	8000ac2e <_malloc_r+0x416>
8000a83e:	fe b0 eb c9 	rcall	80007fd0 <__malloc_lock>
8000a842:	e0 47 01 f7 	cp.w	r7,503
8000a846:	e0 8b 00 1d 	brhi	8000a880 <_malloc_r+0x68>
8000a84a:	ee 03 16 03 	lsr	r3,r7,0x3
8000a84e:	e0 68 05 4c 	mov	r8,1356
8000a852:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a856:	70 36       	ld.w	r6,r8[0xc]
8000a858:	10 36       	cp.w	r6,r8
8000a85a:	c0 61       	brne	8000a866 <_malloc_r+0x4e>
8000a85c:	ec c8 ff f8 	sub	r8,r6,-8
8000a860:	70 36       	ld.w	r6,r8[0xc]
8000a862:	10 36       	cp.w	r6,r8
8000a864:	c0 c0       	breq	8000a87c <_malloc_r+0x64>
8000a866:	6c 18       	ld.w	r8,r6[0x4]
8000a868:	e0 18 ff fc 	andl	r8,0xfffc
8000a86c:	6c 3a       	ld.w	r10,r6[0xc]
8000a86e:	ec 08 00 09 	add	r9,r6,r8
8000a872:	0a 9c       	mov	r12,r5
8000a874:	6c 28       	ld.w	r8,r6[0x8]
8000a876:	95 28       	st.w	r10[0x8],r8
8000a878:	91 3a       	st.w	r8[0xc],r10
8000a87a:	c4 78       	rjmp	8000a908 <_malloc_r+0xf0>
8000a87c:	2f e3       	sub	r3,-2
8000a87e:	c4 d8       	rjmp	8000a918 <_malloc_r+0x100>
8000a880:	ee 03 16 09 	lsr	r3,r7,0x9
8000a884:	c0 41       	brne	8000a88c <_malloc_r+0x74>
8000a886:	ee 03 16 03 	lsr	r3,r7,0x3
8000a88a:	c2 68       	rjmp	8000a8d6 <_malloc_r+0xbe>
8000a88c:	58 43       	cp.w	r3,4
8000a88e:	e0 8b 00 06 	brhi	8000a89a <_malloc_r+0x82>
8000a892:	ee 03 16 06 	lsr	r3,r7,0x6
8000a896:	2c 83       	sub	r3,-56
8000a898:	c1 f8       	rjmp	8000a8d6 <_malloc_r+0xbe>
8000a89a:	59 43       	cp.w	r3,20
8000a89c:	e0 8b 00 04 	brhi	8000a8a4 <_malloc_r+0x8c>
8000a8a0:	2a 53       	sub	r3,-91
8000a8a2:	c1 a8       	rjmp	8000a8d6 <_malloc_r+0xbe>
8000a8a4:	e0 43 00 54 	cp.w	r3,84
8000a8a8:	e0 8b 00 06 	brhi	8000a8b4 <_malloc_r+0x9c>
8000a8ac:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a8b0:	29 23       	sub	r3,-110
8000a8b2:	c1 28       	rjmp	8000a8d6 <_malloc_r+0xbe>
8000a8b4:	e0 43 01 54 	cp.w	r3,340
8000a8b8:	e0 8b 00 06 	brhi	8000a8c4 <_malloc_r+0xac>
8000a8bc:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a8c0:	28 93       	sub	r3,-119
8000a8c2:	c0 a8       	rjmp	8000a8d6 <_malloc_r+0xbe>
8000a8c4:	e0 43 05 54 	cp.w	r3,1364
8000a8c8:	e0 88 00 04 	brls	8000a8d0 <_malloc_r+0xb8>
8000a8cc:	37 e3       	mov	r3,126
8000a8ce:	c0 48       	rjmp	8000a8d6 <_malloc_r+0xbe>
8000a8d0:	ee 03 16 12 	lsr	r3,r7,0x12
8000a8d4:	28 43       	sub	r3,-124
8000a8d6:	e0 6a 05 4c 	mov	r10,1356
8000a8da:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a8de:	74 36       	ld.w	r6,r10[0xc]
8000a8e0:	c1 98       	rjmp	8000a912 <_malloc_r+0xfa>
8000a8e2:	6c 19       	ld.w	r9,r6[0x4]
8000a8e4:	e0 19 ff fc 	andl	r9,0xfffc
8000a8e8:	f2 07 01 0b 	sub	r11,r9,r7
8000a8ec:	58 fb       	cp.w	r11,15
8000a8ee:	e0 8a 00 04 	brle	8000a8f6 <_malloc_r+0xde>
8000a8f2:	20 13       	sub	r3,1
8000a8f4:	c1 18       	rjmp	8000a916 <_malloc_r+0xfe>
8000a8f6:	6c 38       	ld.w	r8,r6[0xc]
8000a8f8:	58 0b       	cp.w	r11,0
8000a8fa:	c0 b5       	brlt	8000a910 <_malloc_r+0xf8>
8000a8fc:	6c 2a       	ld.w	r10,r6[0x8]
8000a8fe:	ec 09 00 09 	add	r9,r6,r9
8000a902:	0a 9c       	mov	r12,r5
8000a904:	91 2a       	st.w	r8[0x8],r10
8000a906:	95 38       	st.w	r10[0xc],r8
8000a908:	72 18       	ld.w	r8,r9[0x4]
8000a90a:	a1 a8       	sbr	r8,0x0
8000a90c:	93 18       	st.w	r9[0x4],r8
8000a90e:	cb c8       	rjmp	8000aa86 <_malloc_r+0x26e>
8000a910:	10 96       	mov	r6,r8
8000a912:	14 36       	cp.w	r6,r10
8000a914:	ce 71       	brne	8000a8e2 <_malloc_r+0xca>
8000a916:	2f f3       	sub	r3,-1
8000a918:	e0 6a 05 4c 	mov	r10,1356
8000a91c:	f4 cc ff f8 	sub	r12,r10,-8
8000a920:	78 26       	ld.w	r6,r12[0x8]
8000a922:	18 36       	cp.w	r6,r12
8000a924:	c6 c0       	breq	8000a9fc <_malloc_r+0x1e4>
8000a926:	6c 19       	ld.w	r9,r6[0x4]
8000a928:	e0 19 ff fc 	andl	r9,0xfffc
8000a92c:	f2 07 01 08 	sub	r8,r9,r7
8000a930:	58 f8       	cp.w	r8,15
8000a932:	e0 89 00 8f 	brgt	8000aa50 <_malloc_r+0x238>
8000a936:	99 3c       	st.w	r12[0xc],r12
8000a938:	99 2c       	st.w	r12[0x8],r12
8000a93a:	58 08       	cp.w	r8,0
8000a93c:	c0 55       	brlt	8000a946 <_malloc_r+0x12e>
8000a93e:	ec 09 00 09 	add	r9,r6,r9
8000a942:	0a 9c       	mov	r12,r5
8000a944:	ce 2b       	rjmp	8000a908 <_malloc_r+0xf0>
8000a946:	e0 49 01 ff 	cp.w	r9,511
8000a94a:	e0 8b 00 13 	brhi	8000a970 <_malloc_r+0x158>
8000a94e:	a3 99       	lsr	r9,0x3
8000a950:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a954:	70 2b       	ld.w	r11,r8[0x8]
8000a956:	8d 38       	st.w	r6[0xc],r8
8000a958:	8d 2b       	st.w	r6[0x8],r11
8000a95a:	97 36       	st.w	r11[0xc],r6
8000a95c:	91 26       	st.w	r8[0x8],r6
8000a95e:	a3 49       	asr	r9,0x2
8000a960:	74 18       	ld.w	r8,r10[0x4]
8000a962:	30 1b       	mov	r11,1
8000a964:	f6 09 09 49 	lsl	r9,r11,r9
8000a968:	f1 e9 10 09 	or	r9,r8,r9
8000a96c:	95 19       	st.w	r10[0x4],r9
8000a96e:	c4 78       	rjmp	8000a9fc <_malloc_r+0x1e4>
8000a970:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a974:	58 4a       	cp.w	r10,4
8000a976:	e0 8b 00 07 	brhi	8000a984 <_malloc_r+0x16c>
8000a97a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a97e:	2c 8a       	sub	r10,-56
8000a980:	c2 08       	rjmp	8000a9c0 <_malloc_r+0x1a8>
8000a982:	d7 03       	nop
8000a984:	59 4a       	cp.w	r10,20
8000a986:	e0 8b 00 04 	brhi	8000a98e <_malloc_r+0x176>
8000a98a:	2a 5a       	sub	r10,-91
8000a98c:	c1 a8       	rjmp	8000a9c0 <_malloc_r+0x1a8>
8000a98e:	e0 4a 00 54 	cp.w	r10,84
8000a992:	e0 8b 00 06 	brhi	8000a99e <_malloc_r+0x186>
8000a996:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a99a:	29 2a       	sub	r10,-110
8000a99c:	c1 28       	rjmp	8000a9c0 <_malloc_r+0x1a8>
8000a99e:	e0 4a 01 54 	cp.w	r10,340
8000a9a2:	e0 8b 00 06 	brhi	8000a9ae <_malloc_r+0x196>
8000a9a6:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a9aa:	28 9a       	sub	r10,-119
8000a9ac:	c0 a8       	rjmp	8000a9c0 <_malloc_r+0x1a8>
8000a9ae:	e0 4a 05 54 	cp.w	r10,1364
8000a9b2:	e0 88 00 04 	brls	8000a9ba <_malloc_r+0x1a2>
8000a9b6:	37 ea       	mov	r10,126
8000a9b8:	c0 48       	rjmp	8000a9c0 <_malloc_r+0x1a8>
8000a9ba:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a9be:	28 4a       	sub	r10,-124
8000a9c0:	e0 6b 05 4c 	mov	r11,1356
8000a9c4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a9c8:	68 28       	ld.w	r8,r4[0x8]
8000a9ca:	08 38       	cp.w	r8,r4
8000a9cc:	c0 e1       	brne	8000a9e8 <_malloc_r+0x1d0>
8000a9ce:	76 19       	ld.w	r9,r11[0x4]
8000a9d0:	a3 4a       	asr	r10,0x2
8000a9d2:	30 1e       	mov	lr,1
8000a9d4:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a9d8:	f3 ea 10 0a 	or	r10,r9,r10
8000a9dc:	10 99       	mov	r9,r8
8000a9de:	97 1a       	st.w	r11[0x4],r10
8000a9e0:	c0 a8       	rjmp	8000a9f4 <_malloc_r+0x1dc>
8000a9e2:	70 28       	ld.w	r8,r8[0x8]
8000a9e4:	08 38       	cp.w	r8,r4
8000a9e6:	c0 60       	breq	8000a9f2 <_malloc_r+0x1da>
8000a9e8:	70 1a       	ld.w	r10,r8[0x4]
8000a9ea:	e0 1a ff fc 	andl	r10,0xfffc
8000a9ee:	14 39       	cp.w	r9,r10
8000a9f0:	cf 93       	brcs	8000a9e2 <_malloc_r+0x1ca>
8000a9f2:	70 39       	ld.w	r9,r8[0xc]
8000a9f4:	8d 39       	st.w	r6[0xc],r9
8000a9f6:	8d 28       	st.w	r6[0x8],r8
8000a9f8:	91 36       	st.w	r8[0xc],r6
8000a9fa:	93 26       	st.w	r9[0x8],r6
8000a9fc:	e6 08 14 02 	asr	r8,r3,0x2
8000aa00:	30 1b       	mov	r11,1
8000aa02:	e0 64 05 4c 	mov	r4,1356
8000aa06:	f6 08 09 4b 	lsl	r11,r11,r8
8000aa0a:	68 18       	ld.w	r8,r4[0x4]
8000aa0c:	10 3b       	cp.w	r11,r8
8000aa0e:	e0 8b 00 6b 	brhi	8000aae4 <_malloc_r+0x2cc>
8000aa12:	f7 e8 00 09 	and	r9,r11,r8
8000aa16:	c0 b1       	brne	8000aa2c <_malloc_r+0x214>
8000aa18:	e0 13 ff fc 	andl	r3,0xfffc
8000aa1c:	a1 7b       	lsl	r11,0x1
8000aa1e:	2f c3       	sub	r3,-4
8000aa20:	c0 38       	rjmp	8000aa26 <_malloc_r+0x20e>
8000aa22:	2f c3       	sub	r3,-4
8000aa24:	a1 7b       	lsl	r11,0x1
8000aa26:	f7 e8 00 09 	and	r9,r11,r8
8000aa2a:	cf c0       	breq	8000aa22 <_malloc_r+0x20a>
8000aa2c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000aa30:	06 92       	mov	r2,r3
8000aa32:	1c 91       	mov	r1,lr
8000aa34:	62 36       	ld.w	r6,r1[0xc]
8000aa36:	c2 e8       	rjmp	8000aa92 <_malloc_r+0x27a>
8000aa38:	6c 1a       	ld.w	r10,r6[0x4]
8000aa3a:	e0 1a ff fc 	andl	r10,0xfffc
8000aa3e:	f4 07 01 08 	sub	r8,r10,r7
8000aa42:	58 f8       	cp.w	r8,15
8000aa44:	e0 8a 00 15 	brle	8000aa6e <_malloc_r+0x256>
8000aa48:	6c 3a       	ld.w	r10,r6[0xc]
8000aa4a:	6c 29       	ld.w	r9,r6[0x8]
8000aa4c:	95 29       	st.w	r10[0x8],r9
8000aa4e:	93 3a       	st.w	r9[0xc],r10
8000aa50:	0e 99       	mov	r9,r7
8000aa52:	ec 07 00 07 	add	r7,r6,r7
8000aa56:	a1 a9       	sbr	r9,0x0
8000aa58:	99 37       	st.w	r12[0xc],r7
8000aa5a:	99 27       	st.w	r12[0x8],r7
8000aa5c:	8d 19       	st.w	r6[0x4],r9
8000aa5e:	ee 08 09 08 	st.w	r7[r8],r8
8000aa62:	8f 2c       	st.w	r7[0x8],r12
8000aa64:	8f 3c       	st.w	r7[0xc],r12
8000aa66:	a1 a8       	sbr	r8,0x0
8000aa68:	0a 9c       	mov	r12,r5
8000aa6a:	8f 18       	st.w	r7[0x4],r8
8000aa6c:	c0 d8       	rjmp	8000aa86 <_malloc_r+0x26e>
8000aa6e:	6c 39       	ld.w	r9,r6[0xc]
8000aa70:	58 08       	cp.w	r8,0
8000aa72:	c0 f5       	brlt	8000aa90 <_malloc_r+0x278>
8000aa74:	ec 0a 00 0a 	add	r10,r6,r10
8000aa78:	74 18       	ld.w	r8,r10[0x4]
8000aa7a:	a1 a8       	sbr	r8,0x0
8000aa7c:	0a 9c       	mov	r12,r5
8000aa7e:	95 18       	st.w	r10[0x4],r8
8000aa80:	6c 28       	ld.w	r8,r6[0x8]
8000aa82:	93 28       	st.w	r9[0x8],r8
8000aa84:	91 39       	st.w	r8[0xc],r9
8000aa86:	fe b0 ea b3 	rcall	80007fec <__malloc_unlock>
8000aa8a:	ec cc ff f8 	sub	r12,r6,-8
8000aa8e:	d8 32       	popm	r0-r7,pc
8000aa90:	12 96       	mov	r6,r9
8000aa92:	02 36       	cp.w	r6,r1
8000aa94:	cd 21       	brne	8000aa38 <_malloc_r+0x220>
8000aa96:	2f f2       	sub	r2,-1
8000aa98:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000aa9c:	c0 30       	breq	8000aaa2 <_malloc_r+0x28a>
8000aa9e:	2f 81       	sub	r1,-8
8000aaa0:	cc ab       	rjmp	8000aa34 <_malloc_r+0x21c>
8000aaa2:	1c 98       	mov	r8,lr
8000aaa4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000aaa8:	c0 81       	brne	8000aab8 <_malloc_r+0x2a0>
8000aaaa:	68 19       	ld.w	r9,r4[0x4]
8000aaac:	f6 08 11 ff 	rsub	r8,r11,-1
8000aab0:	f3 e8 00 08 	and	r8,r9,r8
8000aab4:	89 18       	st.w	r4[0x4],r8
8000aab6:	c0 78       	rjmp	8000aac4 <_malloc_r+0x2ac>
8000aab8:	f0 c9 00 08 	sub	r9,r8,8
8000aabc:	20 13       	sub	r3,1
8000aabe:	70 08       	ld.w	r8,r8[0x0]
8000aac0:	12 38       	cp.w	r8,r9
8000aac2:	cf 10       	breq	8000aaa4 <_malloc_r+0x28c>
8000aac4:	a1 7b       	lsl	r11,0x1
8000aac6:	68 18       	ld.w	r8,r4[0x4]
8000aac8:	10 3b       	cp.w	r11,r8
8000aaca:	e0 8b 00 0d 	brhi	8000aae4 <_malloc_r+0x2cc>
8000aace:	58 0b       	cp.w	r11,0
8000aad0:	c0 a0       	breq	8000aae4 <_malloc_r+0x2cc>
8000aad2:	04 93       	mov	r3,r2
8000aad4:	c0 38       	rjmp	8000aada <_malloc_r+0x2c2>
8000aad6:	2f c3       	sub	r3,-4
8000aad8:	a1 7b       	lsl	r11,0x1
8000aada:	f7 e8 00 09 	and	r9,r11,r8
8000aade:	ca 71       	brne	8000aa2c <_malloc_r+0x214>
8000aae0:	cf bb       	rjmp	8000aad6 <_malloc_r+0x2be>
8000aae2:	d7 03       	nop
8000aae4:	68 23       	ld.w	r3,r4[0x8]
8000aae6:	66 12       	ld.w	r2,r3[0x4]
8000aae8:	e0 12 ff fc 	andl	r2,0xfffc
8000aaec:	0e 32       	cp.w	r2,r7
8000aaee:	5f 39       	srlo	r9
8000aaf0:	e4 07 01 08 	sub	r8,r2,r7
8000aaf4:	58 f8       	cp.w	r8,15
8000aaf6:	5f aa       	srle	r10
8000aaf8:	f5 e9 10 09 	or	r9,r10,r9
8000aafc:	e0 80 00 9a 	breq	8000ac30 <_malloc_r+0x418>
8000ab00:	e0 68 0d 60 	mov	r8,3424
8000ab04:	70 01       	ld.w	r1,r8[0x0]
8000ab06:	e0 68 09 58 	mov	r8,2392
8000ab0a:	2f 01       	sub	r1,-16
8000ab0c:	70 08       	ld.w	r8,r8[0x0]
8000ab0e:	0e 01       	add	r1,r7
8000ab10:	5b f8       	cp.w	r8,-1
8000ab12:	c0 40       	breq	8000ab1a <_malloc_r+0x302>
8000ab14:	28 11       	sub	r1,-127
8000ab16:	e0 11 ff 80 	andl	r1,0xff80
8000ab1a:	02 9b       	mov	r11,r1
8000ab1c:	0a 9c       	mov	r12,r5
8000ab1e:	e0 a0 02 b7 	rcall	8000b08c <_sbrk_r>
8000ab22:	18 96       	mov	r6,r12
8000ab24:	5b fc       	cp.w	r12,-1
8000ab26:	c7 50       	breq	8000ac10 <_malloc_r+0x3f8>
8000ab28:	e6 02 00 08 	add	r8,r3,r2
8000ab2c:	10 3c       	cp.w	r12,r8
8000ab2e:	c0 32       	brcc	8000ab34 <_malloc_r+0x31c>
8000ab30:	08 33       	cp.w	r3,r4
8000ab32:	c6 f1       	brne	8000ac10 <_malloc_r+0x3f8>
8000ab34:	e0 6a 0d 64 	mov	r10,3428
8000ab38:	74 09       	ld.w	r9,r10[0x0]
8000ab3a:	e2 09 00 09 	add	r9,r1,r9
8000ab3e:	95 09       	st.w	r10[0x0],r9
8000ab40:	10 36       	cp.w	r6,r8
8000ab42:	c0 a1       	brne	8000ab56 <_malloc_r+0x33e>
8000ab44:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000ab48:	c0 71       	brne	8000ab56 <_malloc_r+0x33e>
8000ab4a:	e2 02 00 02 	add	r2,r1,r2
8000ab4e:	68 28       	ld.w	r8,r4[0x8]
8000ab50:	a1 a2       	sbr	r2,0x0
8000ab52:	91 12       	st.w	r8[0x4],r2
8000ab54:	c4 f8       	rjmp	8000abf2 <_malloc_r+0x3da>
8000ab56:	e0 6a 09 58 	mov	r10,2392
8000ab5a:	74 0b       	ld.w	r11,r10[0x0]
8000ab5c:	5b fb       	cp.w	r11,-1
8000ab5e:	c0 31       	brne	8000ab64 <_malloc_r+0x34c>
8000ab60:	95 06       	st.w	r10[0x0],r6
8000ab62:	c0 78       	rjmp	8000ab70 <_malloc_r+0x358>
8000ab64:	ec 09 00 09 	add	r9,r6,r9
8000ab68:	e0 6a 0d 64 	mov	r10,3428
8000ab6c:	10 19       	sub	r9,r8
8000ab6e:	95 09       	st.w	r10[0x0],r9
8000ab70:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000ab74:	f0 09 11 08 	rsub	r9,r8,8
8000ab78:	58 08       	cp.w	r8,0
8000ab7a:	f2 08 17 10 	movne	r8,r9
8000ab7e:	ed d8 e1 06 	addne	r6,r6,r8
8000ab82:	28 08       	sub	r8,-128
8000ab84:	ec 01 00 01 	add	r1,r6,r1
8000ab88:	0a 9c       	mov	r12,r5
8000ab8a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000ab8e:	f0 01 01 01 	sub	r1,r8,r1
8000ab92:	02 9b       	mov	r11,r1
8000ab94:	e0 a0 02 7c 	rcall	8000b08c <_sbrk_r>
8000ab98:	e0 68 0d 64 	mov	r8,3428
8000ab9c:	5b fc       	cp.w	r12,-1
8000ab9e:	ec 0c 17 00 	moveq	r12,r6
8000aba2:	f9 b1 00 00 	moveq	r1,0
8000aba6:	70 09       	ld.w	r9,r8[0x0]
8000aba8:	0c 1c       	sub	r12,r6
8000abaa:	89 26       	st.w	r4[0x8],r6
8000abac:	02 0c       	add	r12,r1
8000abae:	12 01       	add	r1,r9
8000abb0:	a1 ac       	sbr	r12,0x0
8000abb2:	91 01       	st.w	r8[0x0],r1
8000abb4:	8d 1c       	st.w	r6[0x4],r12
8000abb6:	08 33       	cp.w	r3,r4
8000abb8:	c1 d0       	breq	8000abf2 <_malloc_r+0x3da>
8000abba:	58 f2       	cp.w	r2,15
8000abbc:	e0 8b 00 05 	brhi	8000abc6 <_malloc_r+0x3ae>
8000abc0:	30 18       	mov	r8,1
8000abc2:	8d 18       	st.w	r6[0x4],r8
8000abc4:	c2 68       	rjmp	8000ac10 <_malloc_r+0x3f8>
8000abc6:	30 59       	mov	r9,5
8000abc8:	20 c2       	sub	r2,12
8000abca:	e0 12 ff f8 	andl	r2,0xfff8
8000abce:	e6 02 00 08 	add	r8,r3,r2
8000abd2:	91 29       	st.w	r8[0x8],r9
8000abd4:	91 19       	st.w	r8[0x4],r9
8000abd6:	66 18       	ld.w	r8,r3[0x4]
8000abd8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000abdc:	e5 e8 10 08 	or	r8,r2,r8
8000abe0:	87 18       	st.w	r3[0x4],r8
8000abe2:	58 f2       	cp.w	r2,15
8000abe4:	e0 88 00 07 	brls	8000abf2 <_malloc_r+0x3da>
8000abe8:	e6 cb ff f8 	sub	r11,r3,-8
8000abec:	0a 9c       	mov	r12,r5
8000abee:	e0 a0 1c 89 	rcall	8000e500 <_free_r>
8000abf2:	e0 69 0d 5c 	mov	r9,3420
8000abf6:	72 0a       	ld.w	r10,r9[0x0]
8000abf8:	e0 68 0d 64 	mov	r8,3428
8000abfc:	70 08       	ld.w	r8,r8[0x0]
8000abfe:	14 38       	cp.w	r8,r10
8000ac00:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000ac04:	e0 69 0d 58 	mov	r9,3416
8000ac08:	72 0a       	ld.w	r10,r9[0x0]
8000ac0a:	14 38       	cp.w	r8,r10
8000ac0c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000ac10:	68 28       	ld.w	r8,r4[0x8]
8000ac12:	70 18       	ld.w	r8,r8[0x4]
8000ac14:	e0 18 ff fc 	andl	r8,0xfffc
8000ac18:	0e 38       	cp.w	r8,r7
8000ac1a:	5f 39       	srlo	r9
8000ac1c:	0e 18       	sub	r8,r7
8000ac1e:	58 f8       	cp.w	r8,15
8000ac20:	5f aa       	srle	r10
8000ac22:	f5 e9 10 09 	or	r9,r10,r9
8000ac26:	c0 50       	breq	8000ac30 <_malloc_r+0x418>
8000ac28:	0a 9c       	mov	r12,r5
8000ac2a:	fe b0 e9 e1 	rcall	80007fec <__malloc_unlock>
8000ac2e:	d8 3a       	popm	r0-r7,pc,r12=0
8000ac30:	68 26       	ld.w	r6,r4[0x8]
8000ac32:	a1 a8       	sbr	r8,0x0
8000ac34:	0e 99       	mov	r9,r7
8000ac36:	a1 a9       	sbr	r9,0x0
8000ac38:	8d 19       	st.w	r6[0x4],r9
8000ac3a:	ec 07 00 07 	add	r7,r6,r7
8000ac3e:	0a 9c       	mov	r12,r5
8000ac40:	89 27       	st.w	r4[0x8],r7
8000ac42:	8f 18       	st.w	r7[0x4],r8
8000ac44:	fe b0 e9 d4 	rcall	80007fec <__malloc_unlock>
8000ac48:	ec cc ff f8 	sub	r12,r6,-8
8000ac4c:	d8 32       	popm	r0-r7,pc
8000ac4e:	d7 03       	nop

8000ac50 <memcmp>:
8000ac50:	d4 01       	pushm	lr
8000ac52:	30 08       	mov	r8,0
8000ac54:	c0 d8       	rjmp	8000ac6e <memcmp+0x1e>
8000ac56:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000ac5a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ac5e:	20 1a       	sub	r10,1
8000ac60:	2f f8       	sub	r8,-1
8000ac62:	f2 0e 18 00 	cp.b	lr,r9
8000ac66:	c0 40       	breq	8000ac6e <memcmp+0x1e>
8000ac68:	fc 09 01 0c 	sub	r12,lr,r9
8000ac6c:	d8 02       	popm	pc
8000ac6e:	58 0a       	cp.w	r10,0
8000ac70:	cf 31       	brne	8000ac56 <memcmp+0x6>
8000ac72:	14 9c       	mov	r12,r10
8000ac74:	d8 02       	popm	pc

8000ac76 <memcpy>:
8000ac76:	58 8a       	cp.w	r10,8
8000ac78:	c2 f5       	brlt	8000acd6 <memcpy+0x60>
8000ac7a:	f9 eb 10 09 	or	r9,r12,r11
8000ac7e:	e2 19 00 03 	andl	r9,0x3,COH
8000ac82:	e0 81 00 97 	brne	8000adb0 <memcpy+0x13a>
8000ac86:	e0 4a 00 20 	cp.w	r10,32
8000ac8a:	c3 b4       	brge	8000ad00 <memcpy+0x8a>
8000ac8c:	f4 08 14 02 	asr	r8,r10,0x2
8000ac90:	f0 09 11 08 	rsub	r9,r8,8
8000ac94:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000ac98:	76 69       	ld.w	r9,r11[0x18]
8000ac9a:	99 69       	st.w	r12[0x18],r9
8000ac9c:	76 59       	ld.w	r9,r11[0x14]
8000ac9e:	99 59       	st.w	r12[0x14],r9
8000aca0:	76 49       	ld.w	r9,r11[0x10]
8000aca2:	99 49       	st.w	r12[0x10],r9
8000aca4:	76 39       	ld.w	r9,r11[0xc]
8000aca6:	99 39       	st.w	r12[0xc],r9
8000aca8:	76 29       	ld.w	r9,r11[0x8]
8000acaa:	99 29       	st.w	r12[0x8],r9
8000acac:	76 19       	ld.w	r9,r11[0x4]
8000acae:	99 19       	st.w	r12[0x4],r9
8000acb0:	76 09       	ld.w	r9,r11[0x0]
8000acb2:	99 09       	st.w	r12[0x0],r9
8000acb4:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000acb8:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000acbc:	e0 1a 00 03 	andl	r10,0x3
8000acc0:	f4 0a 11 04 	rsub	r10,r10,4
8000acc4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000acc8:	17 a9       	ld.ub	r9,r11[0x2]
8000acca:	b0 a9       	st.b	r8[0x2],r9
8000accc:	17 99       	ld.ub	r9,r11[0x1]
8000acce:	b0 99       	st.b	r8[0x1],r9
8000acd0:	17 89       	ld.ub	r9,r11[0x0]
8000acd2:	b0 89       	st.b	r8[0x0],r9
8000acd4:	5e fc       	retal	r12
8000acd6:	f4 0a 11 09 	rsub	r10,r10,9
8000acda:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000acde:	17 f9       	ld.ub	r9,r11[0x7]
8000ace0:	b8 f9       	st.b	r12[0x7],r9
8000ace2:	17 e9       	ld.ub	r9,r11[0x6]
8000ace4:	b8 e9       	st.b	r12[0x6],r9
8000ace6:	17 d9       	ld.ub	r9,r11[0x5]
8000ace8:	b8 d9       	st.b	r12[0x5],r9
8000acea:	17 c9       	ld.ub	r9,r11[0x4]
8000acec:	b8 c9       	st.b	r12[0x4],r9
8000acee:	17 b9       	ld.ub	r9,r11[0x3]
8000acf0:	b8 b9       	st.b	r12[0x3],r9
8000acf2:	17 a9       	ld.ub	r9,r11[0x2]
8000acf4:	b8 a9       	st.b	r12[0x2],r9
8000acf6:	17 99       	ld.ub	r9,r11[0x1]
8000acf8:	b8 99       	st.b	r12[0x1],r9
8000acfa:	17 89       	ld.ub	r9,r11[0x0]
8000acfc:	b8 89       	st.b	r12[0x0],r9
8000acfe:	5e fc       	retal	r12
8000ad00:	eb cd 40 c0 	pushm	r6-r7,lr
8000ad04:	18 99       	mov	r9,r12
8000ad06:	22 0a       	sub	r10,32
8000ad08:	b7 07       	ld.d	r6,r11++
8000ad0a:	b3 26       	st.d	r9++,r6
8000ad0c:	b7 07       	ld.d	r6,r11++
8000ad0e:	b3 26       	st.d	r9++,r6
8000ad10:	b7 07       	ld.d	r6,r11++
8000ad12:	b3 26       	st.d	r9++,r6
8000ad14:	b7 07       	ld.d	r6,r11++
8000ad16:	b3 26       	st.d	r9++,r6
8000ad18:	22 0a       	sub	r10,32
8000ad1a:	cf 74       	brge	8000ad08 <memcpy+0x92>
8000ad1c:	2f 0a       	sub	r10,-16
8000ad1e:	c0 65       	brlt	8000ad2a <memcpy+0xb4>
8000ad20:	b7 07       	ld.d	r6,r11++
8000ad22:	b3 26       	st.d	r9++,r6
8000ad24:	b7 07       	ld.d	r6,r11++
8000ad26:	b3 26       	st.d	r9++,r6
8000ad28:	21 0a       	sub	r10,16
8000ad2a:	5c 3a       	neg	r10
8000ad2c:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000ad30:	d7 03       	nop
8000ad32:	d7 03       	nop
8000ad34:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000ad38:	f3 66 00 0e 	st.b	r9[14],r6
8000ad3c:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000ad40:	f3 66 00 0d 	st.b	r9[13],r6
8000ad44:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000ad48:	f3 66 00 0c 	st.b	r9[12],r6
8000ad4c:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000ad50:	f3 66 00 0b 	st.b	r9[11],r6
8000ad54:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000ad58:	f3 66 00 0a 	st.b	r9[10],r6
8000ad5c:	f7 36 00 09 	ld.ub	r6,r11[9]
8000ad60:	f3 66 00 09 	st.b	r9[9],r6
8000ad64:	f7 36 00 08 	ld.ub	r6,r11[8]
8000ad68:	f3 66 00 08 	st.b	r9[8],r6
8000ad6c:	f7 36 00 07 	ld.ub	r6,r11[7]
8000ad70:	f3 66 00 07 	st.b	r9[7],r6
8000ad74:	f7 36 00 06 	ld.ub	r6,r11[6]
8000ad78:	f3 66 00 06 	st.b	r9[6],r6
8000ad7c:	f7 36 00 05 	ld.ub	r6,r11[5]
8000ad80:	f3 66 00 05 	st.b	r9[5],r6
8000ad84:	f7 36 00 04 	ld.ub	r6,r11[4]
8000ad88:	f3 66 00 04 	st.b	r9[4],r6
8000ad8c:	f7 36 00 03 	ld.ub	r6,r11[3]
8000ad90:	f3 66 00 03 	st.b	r9[3],r6
8000ad94:	f7 36 00 02 	ld.ub	r6,r11[2]
8000ad98:	f3 66 00 02 	st.b	r9[2],r6
8000ad9c:	f7 36 00 01 	ld.ub	r6,r11[1]
8000ada0:	f3 66 00 01 	st.b	r9[1],r6
8000ada4:	f7 36 00 00 	ld.ub	r6,r11[0]
8000ada8:	f3 66 00 00 	st.b	r9[0],r6
8000adac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000adb0:	20 1a       	sub	r10,1
8000adb2:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000adb6:	f8 0a 0b 09 	st.b	r12[r10],r9
8000adba:	cf b1       	brne	8000adb0 <memcpy+0x13a>
8000adbc:	5e fc       	retal	r12

8000adbe <memset>:
8000adbe:	18 98       	mov	r8,r12
8000adc0:	c0 38       	rjmp	8000adc6 <memset+0x8>
8000adc2:	10 cb       	st.b	r8++,r11
8000adc4:	20 1a       	sub	r10,1
8000adc6:	58 0a       	cp.w	r10,0
8000adc8:	cf d1       	brne	8000adc2 <memset+0x4>
8000adca:	5e fc       	retal	r12

8000adcc <_realloc_r>:
8000adcc:	d4 31       	pushm	r0-r7,lr
8000adce:	20 1d       	sub	sp,4
8000add0:	16 94       	mov	r4,r11
8000add2:	18 92       	mov	r2,r12
8000add4:	14 9b       	mov	r11,r10
8000add6:	58 04       	cp.w	r4,0
8000add8:	c0 51       	brne	8000ade2 <_realloc_r+0x16>
8000adda:	fe b0 fd 1f 	rcall	8000a818 <_malloc_r>
8000adde:	18 95       	mov	r5,r12
8000ade0:	c5 39       	rjmp	8000b086 <_realloc_r+0x2ba>
8000ade2:	50 0a       	stdsp	sp[0x0],r10
8000ade4:	fe b0 e8 f6 	rcall	80007fd0 <__malloc_lock>
8000ade8:	40 0b       	lddsp	r11,sp[0x0]
8000adea:	f6 c8 ff f5 	sub	r8,r11,-11
8000adee:	e8 c1 00 08 	sub	r1,r4,8
8000adf2:	10 96       	mov	r6,r8
8000adf4:	62 1c       	ld.w	r12,r1[0x4]
8000adf6:	e0 16 ff f8 	andl	r6,0xfff8
8000adfa:	59 68       	cp.w	r8,22
8000adfc:	f9 b6 08 10 	movls	r6,16
8000ae00:	16 36       	cp.w	r6,r11
8000ae02:	5f 38       	srlo	r8
8000ae04:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000ae08:	c0 50       	breq	8000ae12 <_realloc_r+0x46>
8000ae0a:	30 c8       	mov	r8,12
8000ae0c:	30 05       	mov	r5,0
8000ae0e:	85 38       	st.w	r2[0xc],r8
8000ae10:	c3 b9       	rjmp	8000b086 <_realloc_r+0x2ba>
8000ae12:	18 90       	mov	r0,r12
8000ae14:	e0 10 ff fc 	andl	r0,0xfffc
8000ae18:	0c 30       	cp.w	r0,r6
8000ae1a:	e0 84 01 0b 	brge	8000b030 <_realloc_r+0x264>
8000ae1e:	e0 68 05 4c 	mov	r8,1356
8000ae22:	e2 00 00 09 	add	r9,r1,r0
8000ae26:	70 25       	ld.w	r5,r8[0x8]
8000ae28:	0a 39       	cp.w	r9,r5
8000ae2a:	c0 90       	breq	8000ae3c <_realloc_r+0x70>
8000ae2c:	72 1a       	ld.w	r10,r9[0x4]
8000ae2e:	a1 ca       	cbr	r10,0x0
8000ae30:	f2 0a 00 0a 	add	r10,r9,r10
8000ae34:	74 1a       	ld.w	r10,r10[0x4]
8000ae36:	ed ba 00 00 	bld	r10,0x0
8000ae3a:	c2 20       	breq	8000ae7e <_realloc_r+0xb2>
8000ae3c:	72 1a       	ld.w	r10,r9[0x4]
8000ae3e:	e0 1a ff fc 	andl	r10,0xfffc
8000ae42:	f4 00 00 03 	add	r3,r10,r0
8000ae46:	0a 39       	cp.w	r9,r5
8000ae48:	c1 31       	brne	8000ae6e <_realloc_r+0xa2>
8000ae4a:	ec c7 ff f0 	sub	r7,r6,-16
8000ae4e:	0e 33       	cp.w	r3,r7
8000ae50:	c1 95       	brlt	8000ae82 <_realloc_r+0xb6>
8000ae52:	e2 06 00 09 	add	r9,r1,r6
8000ae56:	0c 13       	sub	r3,r6
8000ae58:	a1 a3       	sbr	r3,0x0
8000ae5a:	93 13       	st.w	r9[0x4],r3
8000ae5c:	91 29       	st.w	r8[0x8],r9
8000ae5e:	04 9c       	mov	r12,r2
8000ae60:	62 18       	ld.w	r8,r1[0x4]
8000ae62:	08 95       	mov	r5,r4
8000ae64:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ae68:	10 46       	or	r6,r8
8000ae6a:	83 16       	st.w	r1[0x4],r6
8000ae6c:	c0 b9       	rjmp	8000b082 <_realloc_r+0x2b6>
8000ae6e:	0c 33       	cp.w	r3,r6
8000ae70:	c0 95       	brlt	8000ae82 <_realloc_r+0xb6>
8000ae72:	72 28       	ld.w	r8,r9[0x8]
8000ae74:	02 97       	mov	r7,r1
8000ae76:	72 39       	ld.w	r9,r9[0xc]
8000ae78:	93 28       	st.w	r9[0x8],r8
8000ae7a:	91 39       	st.w	r8[0xc],r9
8000ae7c:	cd c8       	rjmp	8000b034 <_realloc_r+0x268>
8000ae7e:	30 0a       	mov	r10,0
8000ae80:	14 99       	mov	r9,r10
8000ae82:	ed bc 00 00 	bld	r12,0x0
8000ae86:	e0 80 00 95 	breq	8000afb0 <_realloc_r+0x1e4>
8000ae8a:	62 07       	ld.w	r7,r1[0x0]
8000ae8c:	e2 07 01 07 	sub	r7,r1,r7
8000ae90:	6e 1c       	ld.w	r12,r7[0x4]
8000ae92:	e0 1c ff fc 	andl	r12,0xfffc
8000ae96:	58 09       	cp.w	r9,0
8000ae98:	c5 60       	breq	8000af44 <_realloc_r+0x178>
8000ae9a:	f8 00 00 03 	add	r3,r12,r0
8000ae9e:	0a 39       	cp.w	r9,r5
8000aea0:	c4 81       	brne	8000af30 <_realloc_r+0x164>
8000aea2:	14 03       	add	r3,r10
8000aea4:	ec c9 ff f0 	sub	r9,r6,-16
8000aea8:	12 33       	cp.w	r3,r9
8000aeaa:	c4 d5       	brlt	8000af44 <_realloc_r+0x178>
8000aeac:	6e 3a       	ld.w	r10,r7[0xc]
8000aeae:	6e 29       	ld.w	r9,r7[0x8]
8000aeb0:	95 29       	st.w	r10[0x8],r9
8000aeb2:	93 3a       	st.w	r9[0xc],r10
8000aeb4:	ee c5 ff f8 	sub	r5,r7,-8
8000aeb8:	e0 ca 00 04 	sub	r10,r0,4
8000aebc:	e0 4a 00 24 	cp.w	r10,36
8000aec0:	e0 8b 00 25 	brhi	8000af0a <_realloc_r+0x13e>
8000aec4:	0a 99       	mov	r9,r5
8000aec6:	59 3a       	cp.w	r10,19
8000aec8:	e0 88 00 1a 	brls	8000aefc <_realloc_r+0x130>
8000aecc:	09 09       	ld.w	r9,r4++
8000aece:	8b 09       	st.w	r5[0x0],r9
8000aed0:	09 09       	ld.w	r9,r4++
8000aed2:	8f 39       	st.w	r7[0xc],r9
8000aed4:	ee c9 ff f0 	sub	r9,r7,-16
8000aed8:	59 ba       	cp.w	r10,27
8000aeda:	e0 88 00 11 	brls	8000aefc <_realloc_r+0x130>
8000aede:	09 0b       	ld.w	r11,r4++
8000aee0:	93 0b       	st.w	r9[0x0],r11
8000aee2:	09 09       	ld.w	r9,r4++
8000aee4:	8f 59       	st.w	r7[0x14],r9
8000aee6:	ee c9 ff e8 	sub	r9,r7,-24
8000aeea:	e0 4a 00 24 	cp.w	r10,36
8000aeee:	c0 71       	brne	8000aefc <_realloc_r+0x130>
8000aef0:	09 0a       	ld.w	r10,r4++
8000aef2:	93 0a       	st.w	r9[0x0],r10
8000aef4:	ee c9 ff e0 	sub	r9,r7,-32
8000aef8:	09 0a       	ld.w	r10,r4++
8000aefa:	8f 7a       	st.w	r7[0x1c],r10
8000aefc:	09 0a       	ld.w	r10,r4++
8000aefe:	12 aa       	st.w	r9++,r10
8000af00:	68 0a       	ld.w	r10,r4[0x0]
8000af02:	93 0a       	st.w	r9[0x0],r10
8000af04:	68 1a       	ld.w	r10,r4[0x4]
8000af06:	93 1a       	st.w	r9[0x4],r10
8000af08:	c0 78       	rjmp	8000af16 <_realloc_r+0x14a>
8000af0a:	50 08       	stdsp	sp[0x0],r8
8000af0c:	08 9b       	mov	r11,r4
8000af0e:	0a 9c       	mov	r12,r5
8000af10:	e0 a0 1d 9b 	rcall	8000ea46 <memmove>
8000af14:	40 08       	lddsp	r8,sp[0x0]
8000af16:	ee 06 00 09 	add	r9,r7,r6
8000af1a:	0c 13       	sub	r3,r6
8000af1c:	a1 a3       	sbr	r3,0x0
8000af1e:	93 13       	st.w	r9[0x4],r3
8000af20:	91 29       	st.w	r8[0x8],r9
8000af22:	04 9c       	mov	r12,r2
8000af24:	6e 18       	ld.w	r8,r7[0x4]
8000af26:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000af2a:	10 46       	or	r6,r8
8000af2c:	8f 16       	st.w	r7[0x4],r6
8000af2e:	ca a8       	rjmp	8000b082 <_realloc_r+0x2b6>
8000af30:	14 03       	add	r3,r10
8000af32:	0c 33       	cp.w	r3,r6
8000af34:	c0 85       	brlt	8000af44 <_realloc_r+0x178>
8000af36:	72 28       	ld.w	r8,r9[0x8]
8000af38:	72 39       	ld.w	r9,r9[0xc]
8000af3a:	93 28       	st.w	r9[0x8],r8
8000af3c:	91 39       	st.w	r8[0xc],r9
8000af3e:	6e 28       	ld.w	r8,r7[0x8]
8000af40:	6e 39       	ld.w	r9,r7[0xc]
8000af42:	c0 78       	rjmp	8000af50 <_realloc_r+0x184>
8000af44:	f8 00 00 03 	add	r3,r12,r0
8000af48:	0c 33       	cp.w	r3,r6
8000af4a:	c3 35       	brlt	8000afb0 <_realloc_r+0x1e4>
8000af4c:	6e 39       	ld.w	r9,r7[0xc]
8000af4e:	6e 28       	ld.w	r8,r7[0x8]
8000af50:	93 28       	st.w	r9[0x8],r8
8000af52:	91 39       	st.w	r8[0xc],r9
8000af54:	e0 ca 00 04 	sub	r10,r0,4
8000af58:	ee cc ff f8 	sub	r12,r7,-8
8000af5c:	e0 4a 00 24 	cp.w	r10,36
8000af60:	e0 8b 00 24 	brhi	8000afa8 <_realloc_r+0x1dc>
8000af64:	59 3a       	cp.w	r10,19
8000af66:	e0 88 00 1a 	brls	8000af9a <_realloc_r+0x1ce>
8000af6a:	09 08       	ld.w	r8,r4++
8000af6c:	99 08       	st.w	r12[0x0],r8
8000af6e:	09 08       	ld.w	r8,r4++
8000af70:	8f 38       	st.w	r7[0xc],r8
8000af72:	ee cc ff f0 	sub	r12,r7,-16
8000af76:	59 ba       	cp.w	r10,27
8000af78:	e0 88 00 11 	brls	8000af9a <_realloc_r+0x1ce>
8000af7c:	09 08       	ld.w	r8,r4++
8000af7e:	99 08       	st.w	r12[0x0],r8
8000af80:	09 08       	ld.w	r8,r4++
8000af82:	8f 58       	st.w	r7[0x14],r8
8000af84:	ee cc ff e8 	sub	r12,r7,-24
8000af88:	e0 4a 00 24 	cp.w	r10,36
8000af8c:	c0 71       	brne	8000af9a <_realloc_r+0x1ce>
8000af8e:	09 08       	ld.w	r8,r4++
8000af90:	99 08       	st.w	r12[0x0],r8
8000af92:	ee cc ff e0 	sub	r12,r7,-32
8000af96:	09 08       	ld.w	r8,r4++
8000af98:	8f 78       	st.w	r7[0x1c],r8
8000af9a:	09 08       	ld.w	r8,r4++
8000af9c:	18 a8       	st.w	r12++,r8
8000af9e:	68 08       	ld.w	r8,r4[0x0]
8000afa0:	99 08       	st.w	r12[0x0],r8
8000afa2:	68 18       	ld.w	r8,r4[0x4]
8000afa4:	99 18       	st.w	r12[0x4],r8
8000afa6:	c4 78       	rjmp	8000b034 <_realloc_r+0x268>
8000afa8:	08 9b       	mov	r11,r4
8000afaa:	e0 a0 1d 4e 	rcall	8000ea46 <memmove>
8000afae:	c4 38       	rjmp	8000b034 <_realloc_r+0x268>
8000afb0:	04 9c       	mov	r12,r2
8000afb2:	fe b0 fc 33 	rcall	8000a818 <_malloc_r>
8000afb6:	18 95       	mov	r5,r12
8000afb8:	c3 a0       	breq	8000b02c <_realloc_r+0x260>
8000afba:	62 18       	ld.w	r8,r1[0x4]
8000afbc:	f8 c9 00 08 	sub	r9,r12,8
8000afc0:	a1 c8       	cbr	r8,0x0
8000afc2:	e2 08 00 08 	add	r8,r1,r8
8000afc6:	10 39       	cp.w	r9,r8
8000afc8:	c0 71       	brne	8000afd6 <_realloc_r+0x20a>
8000afca:	72 13       	ld.w	r3,r9[0x4]
8000afcc:	02 97       	mov	r7,r1
8000afce:	e0 13 ff fc 	andl	r3,0xfffc
8000afd2:	00 03       	add	r3,r0
8000afd4:	c3 08       	rjmp	8000b034 <_realloc_r+0x268>
8000afd6:	e0 ca 00 04 	sub	r10,r0,4
8000afda:	e0 4a 00 24 	cp.w	r10,36
8000afde:	e0 8b 00 20 	brhi	8000b01e <_realloc_r+0x252>
8000afe2:	08 99       	mov	r9,r4
8000afe4:	18 98       	mov	r8,r12
8000afe6:	59 3a       	cp.w	r10,19
8000afe8:	e0 88 00 14 	brls	8000b010 <_realloc_r+0x244>
8000afec:	13 0b       	ld.w	r11,r9++
8000afee:	10 ab       	st.w	r8++,r11
8000aff0:	13 0b       	ld.w	r11,r9++
8000aff2:	10 ab       	st.w	r8++,r11
8000aff4:	59 ba       	cp.w	r10,27
8000aff6:	e0 88 00 0d 	brls	8000b010 <_realloc_r+0x244>
8000affa:	13 0b       	ld.w	r11,r9++
8000affc:	10 ab       	st.w	r8++,r11
8000affe:	13 0b       	ld.w	r11,r9++
8000b000:	10 ab       	st.w	r8++,r11
8000b002:	e0 4a 00 24 	cp.w	r10,36
8000b006:	c0 51       	brne	8000b010 <_realloc_r+0x244>
8000b008:	13 0a       	ld.w	r10,r9++
8000b00a:	10 aa       	st.w	r8++,r10
8000b00c:	13 0a       	ld.w	r10,r9++
8000b00e:	10 aa       	st.w	r8++,r10
8000b010:	13 0a       	ld.w	r10,r9++
8000b012:	10 aa       	st.w	r8++,r10
8000b014:	72 0a       	ld.w	r10,r9[0x0]
8000b016:	91 0a       	st.w	r8[0x0],r10
8000b018:	72 19       	ld.w	r9,r9[0x4]
8000b01a:	91 19       	st.w	r8[0x4],r9
8000b01c:	c0 48       	rjmp	8000b024 <_realloc_r+0x258>
8000b01e:	08 9b       	mov	r11,r4
8000b020:	e0 a0 1d 13 	rcall	8000ea46 <memmove>
8000b024:	08 9b       	mov	r11,r4
8000b026:	04 9c       	mov	r12,r2
8000b028:	e0 a0 1a 6c 	rcall	8000e500 <_free_r>
8000b02c:	04 9c       	mov	r12,r2
8000b02e:	c2 a8       	rjmp	8000b082 <_realloc_r+0x2b6>
8000b030:	00 93       	mov	r3,r0
8000b032:	02 97       	mov	r7,r1
8000b034:	e6 06 01 09 	sub	r9,r3,r6
8000b038:	6e 18       	ld.w	r8,r7[0x4]
8000b03a:	58 f9       	cp.w	r9,15
8000b03c:	e0 88 00 16 	brls	8000b068 <_realloc_r+0x29c>
8000b040:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b044:	ed e8 10 08 	or	r8,r6,r8
8000b048:	8f 18       	st.w	r7[0x4],r8
8000b04a:	12 98       	mov	r8,r9
8000b04c:	a1 a8       	sbr	r8,0x0
8000b04e:	ee 06 00 0b 	add	r11,r7,r6
8000b052:	f6 09 00 09 	add	r9,r11,r9
8000b056:	97 18       	st.w	r11[0x4],r8
8000b058:	72 18       	ld.w	r8,r9[0x4]
8000b05a:	a1 a8       	sbr	r8,0x0
8000b05c:	2f 8b       	sub	r11,-8
8000b05e:	93 18       	st.w	r9[0x4],r8
8000b060:	04 9c       	mov	r12,r2
8000b062:	e0 a0 1a 4f 	rcall	8000e500 <_free_r>
8000b066:	c0 b8       	rjmp	8000b07c <_realloc_r+0x2b0>
8000b068:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b06c:	e7 e8 10 08 	or	r8,r3,r8
8000b070:	8f 18       	st.w	r7[0x4],r8
8000b072:	ee 03 00 03 	add	r3,r7,r3
8000b076:	66 18       	ld.w	r8,r3[0x4]
8000b078:	a1 a8       	sbr	r8,0x0
8000b07a:	87 18       	st.w	r3[0x4],r8
8000b07c:	04 9c       	mov	r12,r2
8000b07e:	ee c5 ff f8 	sub	r5,r7,-8
8000b082:	fe b0 e7 b5 	rcall	80007fec <__malloc_unlock>
8000b086:	0a 9c       	mov	r12,r5
8000b088:	2f fd       	sub	sp,-4
8000b08a:	d8 32       	popm	r0-r7,pc

8000b08c <_sbrk_r>:
8000b08c:	d4 21       	pushm	r4-r7,lr
8000b08e:	30 08       	mov	r8,0
8000b090:	18 97       	mov	r7,r12
8000b092:	e0 66 41 14 	mov	r6,16660
8000b096:	16 9c       	mov	r12,r11
8000b098:	8d 08       	st.w	r6[0x0],r8
8000b09a:	c9 1c       	rcall	8000b1bc <_sbrk>
8000b09c:	5b fc       	cp.w	r12,-1
8000b09e:	c0 51       	brne	8000b0a8 <_sbrk_r+0x1c>
8000b0a0:	6c 08       	ld.w	r8,r6[0x0]
8000b0a2:	58 08       	cp.w	r8,0
8000b0a4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b0a8:	d8 22       	popm	r4-r7,pc
8000b0aa:	d7 03       	nop

8000b0ac <sprintf>:
8000b0ac:	d4 01       	pushm	lr
8000b0ae:	21 7d       	sub	sp,92
8000b0b0:	e0 68 ff ff 	mov	r8,65535
8000b0b4:	ea 18 7f ff 	orh	r8,0x7fff
8000b0b8:	50 58       	stdsp	sp[0x14],r8
8000b0ba:	50 28       	stdsp	sp[0x8],r8
8000b0bc:	e0 68 02 08 	mov	r8,520
8000b0c0:	ba 68       	st.h	sp[0xc],r8
8000b0c2:	3f f8       	mov	r8,-1
8000b0c4:	ba 78       	st.h	sp[0xe],r8
8000b0c6:	e0 68 0a 4c 	mov	r8,2636
8000b0ca:	50 4c       	stdsp	sp[0x10],r12
8000b0cc:	16 9a       	mov	r10,r11
8000b0ce:	50 0c       	stdsp	sp[0x0],r12
8000b0d0:	fa c9 ff a0 	sub	r9,sp,-96
8000b0d4:	70 0c       	ld.w	r12,r8[0x0]
8000b0d6:	1a 9b       	mov	r11,sp
8000b0d8:	e0 a0 02 26 	rcall	8000b524 <_vfprintf_r>
8000b0dc:	30 09       	mov	r9,0
8000b0de:	40 08       	lddsp	r8,sp[0x0]
8000b0e0:	b0 89       	st.b	r8[0x0],r9
8000b0e2:	2e 9d       	sub	sp,-92
8000b0e4:	d8 02       	popm	pc
8000b0e6:	d7 03       	nop

8000b0e8 <strlen>:
8000b0e8:	30 09       	mov	r9,0
8000b0ea:	18 98       	mov	r8,r12
8000b0ec:	c0 28       	rjmp	8000b0f0 <strlen+0x8>
8000b0ee:	2f f8       	sub	r8,-1
8000b0f0:	11 8a       	ld.ub	r10,r8[0x0]
8000b0f2:	f2 0a 18 00 	cp.b	r10,r9
8000b0f6:	cf c1       	brne	8000b0ee <strlen+0x6>
8000b0f8:	f0 0c 01 0c 	sub	r12,r8,r12
8000b0fc:	5e fc       	retal	r12
8000b0fe:	d7 03       	nop

8000b100 <strncpy>:
8000b100:	30 08       	mov	r8,0
8000b102:	10 3a       	cp.w	r10,r8
8000b104:	5e 0c       	reteq	r12
8000b106:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b10a:	f8 08 0b 09 	st.b	r12[r8],r9
8000b10e:	2f f8       	sub	r8,-1
8000b110:	58 09       	cp.w	r9,0
8000b112:	cf 81       	brne	8000b102 <strncpy+0x2>
8000b114:	10 3a       	cp.w	r10,r8
8000b116:	5e 0c       	reteq	r12
8000b118:	f8 08 0b 09 	st.b	r12[r8],r9
8000b11c:	2f f8       	sub	r8,-1
8000b11e:	cf bb       	rjmp	8000b114 <strncpy+0x14>

8000b120 <_close>:
8000b120:	30 28       	mov	r8,2
8000b122:	d6 73       	breakpoint
8000b124:	3f fc       	mov	r12,-1
8000b126:	35 8b       	mov	r11,88
8000b128:	58 0c       	cp.w	r12,0
8000b12a:	5e 4c       	retge	r12
8000b12c:	e0 6a 41 14 	mov	r10,16660
8000b130:	95 0b       	st.w	r10[0x0],r11
8000b132:	5e fc       	retal	r12

8000b134 <_lseek>:
8000b134:	30 58       	mov	r8,5
8000b136:	d6 73       	breakpoint
8000b138:	3f fc       	mov	r12,-1
8000b13a:	35 8b       	mov	r11,88
8000b13c:	58 0c       	cp.w	r12,0
8000b13e:	5e 4c       	retge	r12
8000b140:	e0 6a 41 14 	mov	r10,16660
8000b144:	95 0b       	st.w	r10[0x0],r11
8000b146:	5e fc       	retal	r12

8000b148 <isatty>:
8000b148:	30 b8       	mov	r8,11
8000b14a:	d6 73       	breakpoint
8000b14c:	3f fc       	mov	r12,-1
8000b14e:	35 8b       	mov	r11,88
8000b150:	58 0c       	cp.w	r12,0
8000b152:	5e 4c       	retge	r12
8000b154:	e0 6a 41 14 	mov	r10,16660
8000b158:	95 0b       	st.w	r10[0x0],r11
8000b15a:	5e fc       	retal	r12

8000b15c <_fstat_host>:
8000b15c:	30 98       	mov	r8,9
8000b15e:	d6 73       	breakpoint
8000b160:	3f fc       	mov	r12,-1
8000b162:	35 8b       	mov	r11,88
8000b164:	58 0c       	cp.w	r12,0
8000b166:	5e 4c       	retge	r12
8000b168:	e0 6a 41 14 	mov	r10,16660
8000b16c:	95 0b       	st.w	r10[0x0],r11
8000b16e:	5e fc       	retal	r12

8000b170 <_fstat>:
8000b170:	d4 21       	pushm	r4-r7,lr
8000b172:	21 0d       	sub	sp,64
8000b174:	16 97       	mov	r7,r11
8000b176:	1a 9b       	mov	r11,sp
8000b178:	cf 2f       	rcall	8000b15c <_fstat_host>
8000b17a:	c0 34       	brge	8000b180 <_fstat+0x10>
8000b17c:	3f fc       	mov	r12,-1
8000b17e:	c1 c8       	rjmp	8000b1b6 <_fstat+0x46>
8000b180:	40 08       	lddsp	r8,sp[0x0]
8000b182:	ae 08       	st.h	r7[0x0],r8
8000b184:	40 18       	lddsp	r8,sp[0x4]
8000b186:	ae 18       	st.h	r7[0x2],r8
8000b188:	40 28       	lddsp	r8,sp[0x8]
8000b18a:	8f 18       	st.w	r7[0x4],r8
8000b18c:	40 38       	lddsp	r8,sp[0xc]
8000b18e:	ae 48       	st.h	r7[0x8],r8
8000b190:	40 48       	lddsp	r8,sp[0x10]
8000b192:	ae 58       	st.h	r7[0xa],r8
8000b194:	40 58       	lddsp	r8,sp[0x14]
8000b196:	ae 68       	st.h	r7[0xc],r8
8000b198:	40 68       	lddsp	r8,sp[0x18]
8000b19a:	ae 78       	st.h	r7[0xe],r8
8000b19c:	40 88       	lddsp	r8,sp[0x20]
8000b19e:	8f 48       	st.w	r7[0x10],r8
8000b1a0:	40 a8       	lddsp	r8,sp[0x28]
8000b1a2:	8f b8       	st.w	r7[0x2c],r8
8000b1a4:	40 c8       	lddsp	r8,sp[0x30]
8000b1a6:	8f c8       	st.w	r7[0x30],r8
8000b1a8:	40 d8       	lddsp	r8,sp[0x34]
8000b1aa:	8f 58       	st.w	r7[0x14],r8
8000b1ac:	40 e8       	lddsp	r8,sp[0x38]
8000b1ae:	30 0c       	mov	r12,0
8000b1b0:	8f 78       	st.w	r7[0x1c],r8
8000b1b2:	40 f8       	lddsp	r8,sp[0x3c]
8000b1b4:	8f 98       	st.w	r7[0x24],r8
8000b1b6:	2f 0d       	sub	sp,-64
8000b1b8:	d8 22       	popm	r4-r7,pc
8000b1ba:	d7 03       	nop

8000b1bc <_sbrk>:
8000b1bc:	d4 01       	pushm	lr
8000b1be:	e0 68 0d 8c 	mov	r8,3468
8000b1c2:	70 09       	ld.w	r9,r8[0x0]
8000b1c4:	58 09       	cp.w	r9,0
8000b1c6:	c0 41       	brne	8000b1ce <_sbrk+0x12>
8000b1c8:	e0 69 41 18 	mov	r9,16664
8000b1cc:	91 09       	st.w	r8[0x0],r9
8000b1ce:	e0 69 0d 8c 	mov	r9,3468
8000b1d2:	e0 7a 70 00 	mov	r10,94208
8000b1d6:	72 08       	ld.w	r8,r9[0x0]
8000b1d8:	f0 0c 00 0c 	add	r12,r8,r12
8000b1dc:	14 3c       	cp.w	r12,r10
8000b1de:	e0 8b 00 04 	brhi	8000b1e6 <_sbrk+0x2a>
8000b1e2:	93 0c       	st.w	r9[0x0],r12
8000b1e4:	c0 68       	rjmp	8000b1f0 <_sbrk+0x34>
8000b1e6:	e0 a0 18 15 	rcall	8000e210 <__errno>
8000b1ea:	30 c8       	mov	r8,12
8000b1ec:	99 08       	st.w	r12[0x0],r8
8000b1ee:	3f f8       	mov	r8,-1
8000b1f0:	10 9c       	mov	r12,r8
8000b1f2:	d8 02       	popm	pc

8000b1f4 <get_arg>:
8000b1f4:	d4 31       	pushm	r0-r7,lr
8000b1f6:	20 8d       	sub	sp,32
8000b1f8:	fa c4 ff bc 	sub	r4,sp,-68
8000b1fc:	50 4b       	stdsp	sp[0x10],r11
8000b1fe:	68 2e       	ld.w	lr,r4[0x8]
8000b200:	50 58       	stdsp	sp[0x14],r8
8000b202:	12 96       	mov	r6,r9
8000b204:	7c 0b       	ld.w	r11,lr[0x0]
8000b206:	70 05       	ld.w	r5,r8[0x0]
8000b208:	50 6e       	stdsp	sp[0x18],lr
8000b20a:	58 0b       	cp.w	r11,0
8000b20c:	f4 0b 17 00 	moveq	r11,r10
8000b210:	68 03       	ld.w	r3,r4[0x0]
8000b212:	68 11       	ld.w	r1,r4[0x4]
8000b214:	40 49       	lddsp	r9,sp[0x10]
8000b216:	30 08       	mov	r8,0
8000b218:	c2 89       	rjmp	8000b468 <get_arg+0x274>
8000b21a:	2f fb       	sub	r11,-1
8000b21c:	32 5c       	mov	r12,37
8000b21e:	17 8a       	ld.ub	r10,r11[0x0]
8000b220:	f8 0a 18 00 	cp.b	r10,r12
8000b224:	5f 1e       	srne	lr
8000b226:	f0 0a 18 00 	cp.b	r10,r8
8000b22a:	5f 1c       	srne	r12
8000b22c:	fd ec 00 0c 	and	r12,lr,r12
8000b230:	f0 0c 18 00 	cp.b	r12,r8
8000b234:	cf 31       	brne	8000b21a <get_arg+0x26>
8000b236:	58 0a       	cp.w	r10,0
8000b238:	e0 80 01 25 	breq	8000b482 <get_arg+0x28e>
8000b23c:	30 0c       	mov	r12,0
8000b23e:	3f fa       	mov	r10,-1
8000b240:	18 90       	mov	r0,r12
8000b242:	50 3a       	stdsp	sp[0xc],r10
8000b244:	18 94       	mov	r4,r12
8000b246:	18 92       	mov	r2,r12
8000b248:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000b24c:	16 97       	mov	r7,r11
8000b24e:	50 7c       	stdsp	sp[0x1c],r12
8000b250:	fe cc a7 68 	sub	r12,pc,-22680
8000b254:	0f 3a       	ld.ub	r10,r7++
8000b256:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000b25a:	40 7c       	lddsp	r12,sp[0x1c]
8000b25c:	1c 0c       	add	r12,lr
8000b25e:	fe ce a8 3e 	sub	lr,pc,-22466
8000b262:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000b266:	20 1e       	sub	lr,1
8000b268:	50 0e       	stdsp	sp[0x0],lr
8000b26a:	fe ce a8 b6 	sub	lr,pc,-22346
8000b26e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000b272:	50 7c       	stdsp	sp[0x1c],r12
8000b274:	40 0c       	lddsp	r12,sp[0x0]
8000b276:	58 7c       	cp.w	r12,7
8000b278:	e0 8b 00 f1 	brhi	8000b45a <get_arg+0x266>
8000b27c:	fe ce aa 68 	sub	lr,pc,-21912
8000b280:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000b284:	36 8b       	mov	r11,104
8000b286:	f6 0a 18 00 	cp.b	r10,r11
8000b28a:	e0 80 00 e8 	breq	8000b45a <get_arg+0x266>
8000b28e:	37 1b       	mov	r11,113
8000b290:	f6 0a 18 00 	cp.b	r10,r11
8000b294:	c0 70       	breq	8000b2a2 <get_arg+0xae>
8000b296:	34 cb       	mov	r11,76
8000b298:	f6 0a 18 00 	cp.b	r10,r11
8000b29c:	c0 51       	brne	8000b2a6 <get_arg+0xb2>
8000b29e:	a3 b4       	sbr	r4,0x3
8000b2a0:	cd d8       	rjmp	8000b45a <get_arg+0x266>
8000b2a2:	a5 b4       	sbr	r4,0x5
8000b2a4:	cd b8       	rjmp	8000b45a <get_arg+0x266>
8000b2a6:	08 9a       	mov	r10,r4
8000b2a8:	0e 9b       	mov	r11,r7
8000b2aa:	a5 aa       	sbr	r10,0x4
8000b2ac:	17 3c       	ld.ub	r12,r11++
8000b2ae:	a5 b4       	sbr	r4,0x5
8000b2b0:	36 ce       	mov	lr,108
8000b2b2:	fc 0c 18 00 	cp.b	r12,lr
8000b2b6:	e0 80 00 d3 	breq	8000b45c <get_arg+0x268>
8000b2ba:	14 94       	mov	r4,r10
8000b2bc:	cc f8       	rjmp	8000b45a <get_arg+0x266>
8000b2be:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000b2c2:	36 7c       	mov	r12,103
8000b2c4:	f8 0a 18 00 	cp.b	r10,r12
8000b2c8:	e0 8b 00 27 	brhi	8000b316 <get_arg+0x122>
8000b2cc:	36 5b       	mov	r11,101
8000b2ce:	f6 0a 18 00 	cp.b	r10,r11
8000b2d2:	c4 82       	brcc	8000b362 <get_arg+0x16e>
8000b2d4:	34 fb       	mov	r11,79
8000b2d6:	f6 0a 18 00 	cp.b	r10,r11
8000b2da:	c4 80       	breq	8000b36a <get_arg+0x176>
8000b2dc:	e0 8b 00 0c 	brhi	8000b2f4 <get_arg+0x100>
8000b2e0:	34 5b       	mov	r11,69
8000b2e2:	f6 0a 18 00 	cp.b	r10,r11
8000b2e6:	c3 e0       	breq	8000b362 <get_arg+0x16e>
8000b2e8:	34 7b       	mov	r11,71
8000b2ea:	f6 0a 18 00 	cp.b	r10,r11
8000b2ee:	c3 a0       	breq	8000b362 <get_arg+0x16e>
8000b2f0:	34 4b       	mov	r11,68
8000b2f2:	c0 88       	rjmp	8000b302 <get_arg+0x10e>
8000b2f4:	35 8b       	mov	r11,88
8000b2f6:	f6 0a 18 00 	cp.b	r10,r11
8000b2fa:	c2 c0       	breq	8000b352 <get_arg+0x15e>
8000b2fc:	e0 8b 00 07 	brhi	8000b30a <get_arg+0x116>
8000b300:	35 5b       	mov	r11,85
8000b302:	f6 0a 18 00 	cp.b	r10,r11
8000b306:	c3 51       	brne	8000b370 <get_arg+0x17c>
8000b308:	c3 18       	rjmp	8000b36a <get_arg+0x176>
8000b30a:	36 3b       	mov	r11,99
8000b30c:	f6 0a 18 00 	cp.b	r10,r11
8000b310:	c2 f0       	breq	8000b36e <get_arg+0x17a>
8000b312:	36 4b       	mov	r11,100
8000b314:	c0 e8       	rjmp	8000b330 <get_arg+0x13c>
8000b316:	37 0b       	mov	r11,112
8000b318:	f6 0a 18 00 	cp.b	r10,r11
8000b31c:	c2 50       	breq	8000b366 <get_arg+0x172>
8000b31e:	e0 8b 00 0d 	brhi	8000b338 <get_arg+0x144>
8000b322:	36 eb       	mov	r11,110
8000b324:	f6 0a 18 00 	cp.b	r10,r11
8000b328:	c1 f0       	breq	8000b366 <get_arg+0x172>
8000b32a:	e0 8b 00 14 	brhi	8000b352 <get_arg+0x15e>
8000b32e:	36 9b       	mov	r11,105
8000b330:	f6 0a 18 00 	cp.b	r10,r11
8000b334:	c1 e1       	brne	8000b370 <get_arg+0x17c>
8000b336:	c0 e8       	rjmp	8000b352 <get_arg+0x15e>
8000b338:	37 5b       	mov	r11,117
8000b33a:	f6 0a 18 00 	cp.b	r10,r11
8000b33e:	c0 a0       	breq	8000b352 <get_arg+0x15e>
8000b340:	37 8b       	mov	r11,120
8000b342:	f6 0a 18 00 	cp.b	r10,r11
8000b346:	c0 60       	breq	8000b352 <get_arg+0x15e>
8000b348:	37 3b       	mov	r11,115
8000b34a:	f6 0a 18 00 	cp.b	r10,r11
8000b34e:	c1 11       	brne	8000b370 <get_arg+0x17c>
8000b350:	c0 b8       	rjmp	8000b366 <get_arg+0x172>
8000b352:	ed b4 00 04 	bld	r4,0x4
8000b356:	c0 a0       	breq	8000b36a <get_arg+0x176>
8000b358:	ed b4 00 05 	bld	r4,0x5
8000b35c:	c0 91       	brne	8000b36e <get_arg+0x17a>
8000b35e:	30 20       	mov	r0,2
8000b360:	c0 88       	rjmp	8000b370 <get_arg+0x17c>
8000b362:	30 40       	mov	r0,4
8000b364:	c0 68       	rjmp	8000b370 <get_arg+0x17c>
8000b366:	30 30       	mov	r0,3
8000b368:	c0 48       	rjmp	8000b370 <get_arg+0x17c>
8000b36a:	30 10       	mov	r0,1
8000b36c:	c0 28       	rjmp	8000b370 <get_arg+0x17c>
8000b36e:	30 00       	mov	r0,0
8000b370:	40 3b       	lddsp	r11,sp[0xc]
8000b372:	5b fb       	cp.w	r11,-1
8000b374:	c0 40       	breq	8000b37c <get_arg+0x188>
8000b376:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000b37a:	c7 08       	rjmp	8000b45a <get_arg+0x266>
8000b37c:	58 60       	cp.w	r0,6
8000b37e:	e0 8b 00 6e 	brhi	8000b45a <get_arg+0x266>
8000b382:	6c 0a       	ld.w	r10,r6[0x0]
8000b384:	ea cc ff ff 	sub	r12,r5,-1
8000b388:	fe ce ab 54 	sub	lr,pc,-21676
8000b38c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000b390:	f4 cb ff f8 	sub	r11,r10,-8
8000b394:	8d 0b       	st.w	r6[0x0],r11
8000b396:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b39a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b39e:	c0 f8       	rjmp	8000b3bc <get_arg+0x1c8>
8000b3a0:	f4 cb ff fc 	sub	r11,r10,-4
8000b3a4:	8d 0b       	st.w	r6[0x0],r11
8000b3a6:	74 0a       	ld.w	r10,r10[0x0]
8000b3a8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b3ac:	c0 88       	rjmp	8000b3bc <get_arg+0x1c8>
8000b3ae:	f4 cb ff f8 	sub	r11,r10,-8
8000b3b2:	8d 0b       	st.w	r6[0x0],r11
8000b3b4:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b3b8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b3bc:	0e 9b       	mov	r11,r7
8000b3be:	18 95       	mov	r5,r12
8000b3c0:	c4 e8       	rjmp	8000b45c <get_arg+0x268>
8000b3c2:	62 0a       	ld.w	r10,r1[0x0]
8000b3c4:	5b fa       	cp.w	r10,-1
8000b3c6:	c0 b1       	brne	8000b3dc <get_arg+0x1e8>
8000b3c8:	50 19       	stdsp	sp[0x4],r9
8000b3ca:	50 28       	stdsp	sp[0x8],r8
8000b3cc:	e0 6a 00 80 	mov	r10,128
8000b3d0:	30 0b       	mov	r11,0
8000b3d2:	02 9c       	mov	r12,r1
8000b3d4:	fe b0 fc f5 	rcall	8000adbe <memset>
8000b3d8:	40 28       	lddsp	r8,sp[0x8]
8000b3da:	40 19       	lddsp	r9,sp[0x4]
8000b3dc:	e4 cc 00 01 	sub	r12,r2,1
8000b3e0:	0e 9b       	mov	r11,r7
8000b3e2:	50 3c       	stdsp	sp[0xc],r12
8000b3e4:	f2 0c 0c 49 	max	r9,r9,r12
8000b3e8:	c3 a8       	rjmp	8000b45c <get_arg+0x268>
8000b3ea:	62 0a       	ld.w	r10,r1[0x0]
8000b3ec:	5b fa       	cp.w	r10,-1
8000b3ee:	c0 b1       	brne	8000b404 <get_arg+0x210>
8000b3f0:	50 19       	stdsp	sp[0x4],r9
8000b3f2:	50 28       	stdsp	sp[0x8],r8
8000b3f4:	e0 6a 00 80 	mov	r10,128
8000b3f8:	30 0b       	mov	r11,0
8000b3fa:	02 9c       	mov	r12,r1
8000b3fc:	fe b0 fc e1 	rcall	8000adbe <memset>
8000b400:	40 28       	lddsp	r8,sp[0x8]
8000b402:	40 19       	lddsp	r9,sp[0x4]
8000b404:	20 12       	sub	r2,1
8000b406:	30 0a       	mov	r10,0
8000b408:	0e 9b       	mov	r11,r7
8000b40a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000b40e:	f2 02 0c 49 	max	r9,r9,r2
8000b412:	c2 58       	rjmp	8000b45c <get_arg+0x268>
8000b414:	16 97       	mov	r7,r11
8000b416:	6c 0a       	ld.w	r10,r6[0x0]
8000b418:	f4 cb ff fc 	sub	r11,r10,-4
8000b41c:	8d 0b       	st.w	r6[0x0],r11
8000b41e:	74 0a       	ld.w	r10,r10[0x0]
8000b420:	0e 9b       	mov	r11,r7
8000b422:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b426:	2f f5       	sub	r5,-1
8000b428:	c1 a8       	rjmp	8000b45c <get_arg+0x268>
8000b42a:	f4 c2 00 30 	sub	r2,r10,48
8000b42e:	c0 68       	rjmp	8000b43a <get_arg+0x246>
8000b430:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000b434:	2f f7       	sub	r7,-1
8000b436:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000b43a:	0f 8a       	ld.ub	r10,r7[0x0]
8000b43c:	58 0a       	cp.w	r10,0
8000b43e:	c0 e0       	breq	8000b45a <get_arg+0x266>
8000b440:	23 0a       	sub	r10,48
8000b442:	58 9a       	cp.w	r10,9
8000b444:	fe 98 ff f6 	brls	8000b430 <get_arg+0x23c>
8000b448:	c0 98       	rjmp	8000b45a <get_arg+0x266>
8000b44a:	2f f7       	sub	r7,-1
8000b44c:	0f 8a       	ld.ub	r10,r7[0x0]
8000b44e:	58 0a       	cp.w	r10,0
8000b450:	c0 50       	breq	8000b45a <get_arg+0x266>
8000b452:	23 0a       	sub	r10,48
8000b454:	58 9a       	cp.w	r10,9
8000b456:	fe 98 ff fa 	brls	8000b44a <get_arg+0x256>
8000b45a:	0e 9b       	mov	r11,r7
8000b45c:	40 7c       	lddsp	r12,sp[0x1c]
8000b45e:	30 ba       	mov	r10,11
8000b460:	f4 0c 18 00 	cp.b	r12,r10
8000b464:	fe 91 fe f2 	brne	8000b248 <get_arg+0x54>
8000b468:	40 42       	lddsp	r2,sp[0x10]
8000b46a:	17 8c       	ld.ub	r12,r11[0x0]
8000b46c:	0a 32       	cp.w	r2,r5
8000b46e:	5f 4a       	srge	r10
8000b470:	f0 0c 18 00 	cp.b	r12,r8
8000b474:	5f 1c       	srne	r12
8000b476:	f9 ea 00 0a 	and	r10,r12,r10
8000b47a:	f0 0a 18 00 	cp.b	r10,r8
8000b47e:	fe 91 fe cf 	brne	8000b21c <get_arg+0x28>
8000b482:	30 08       	mov	r8,0
8000b484:	40 4e       	lddsp	lr,sp[0x10]
8000b486:	17 8a       	ld.ub	r10,r11[0x0]
8000b488:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000b48c:	f0 0a 18 00 	cp.b	r10,r8
8000b490:	fc 09 17 10 	movne	r9,lr
8000b494:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000b498:	06 9e       	mov	lr,r3
8000b49a:	c2 a8       	rjmp	8000b4ee <get_arg+0x2fa>
8000b49c:	62 0a       	ld.w	r10,r1[0x0]
8000b49e:	58 3a       	cp.w	r10,3
8000b4a0:	c1 e0       	breq	8000b4dc <get_arg+0x2e8>
8000b4a2:	e0 89 00 07 	brgt	8000b4b0 <get_arg+0x2bc>
8000b4a6:	58 1a       	cp.w	r10,1
8000b4a8:	c1 a0       	breq	8000b4dc <get_arg+0x2e8>
8000b4aa:	58 2a       	cp.w	r10,2
8000b4ac:	c1 81       	brne	8000b4dc <get_arg+0x2e8>
8000b4ae:	c0 58       	rjmp	8000b4b8 <get_arg+0x2c4>
8000b4b0:	58 5a       	cp.w	r10,5
8000b4b2:	c0 c0       	breq	8000b4ca <get_arg+0x2d6>
8000b4b4:	c0 b5       	brlt	8000b4ca <get_arg+0x2d6>
8000b4b6:	c1 38       	rjmp	8000b4dc <get_arg+0x2e8>
8000b4b8:	6c 0a       	ld.w	r10,r6[0x0]
8000b4ba:	f4 cc ff f8 	sub	r12,r10,-8
8000b4be:	8d 0c       	st.w	r6[0x0],r12
8000b4c0:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b4c4:	f0 e3 00 00 	st.d	r8[0],r2
8000b4c8:	c1 08       	rjmp	8000b4e8 <get_arg+0x2f4>
8000b4ca:	6c 0a       	ld.w	r10,r6[0x0]
8000b4cc:	f4 cc ff f8 	sub	r12,r10,-8
8000b4d0:	8d 0c       	st.w	r6[0x0],r12
8000b4d2:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b4d6:	f0 e3 00 00 	st.d	r8[0],r2
8000b4da:	c0 78       	rjmp	8000b4e8 <get_arg+0x2f4>
8000b4dc:	6c 0a       	ld.w	r10,r6[0x0]
8000b4de:	f4 cc ff fc 	sub	r12,r10,-4
8000b4e2:	8d 0c       	st.w	r6[0x0],r12
8000b4e4:	74 0a       	ld.w	r10,r10[0x0]
8000b4e6:	91 0a       	st.w	r8[0x0],r10
8000b4e8:	2f f5       	sub	r5,-1
8000b4ea:	2f 88       	sub	r8,-8
8000b4ec:	2f c1       	sub	r1,-4
8000b4ee:	12 35       	cp.w	r5,r9
8000b4f0:	fe 9a ff d6 	brle	8000b49c <get_arg+0x2a8>
8000b4f4:	1c 93       	mov	r3,lr
8000b4f6:	40 52       	lddsp	r2,sp[0x14]
8000b4f8:	40 6e       	lddsp	lr,sp[0x18]
8000b4fa:	85 05       	st.w	r2[0x0],r5
8000b4fc:	9d 0b       	st.w	lr[0x0],r11
8000b4fe:	40 4b       	lddsp	r11,sp[0x10]
8000b500:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000b504:	2f 8d       	sub	sp,-32
8000b506:	d8 32       	popm	r0-r7,pc

8000b508 <__sprint_r>:
8000b508:	d4 21       	pushm	r4-r7,lr
8000b50a:	14 97       	mov	r7,r10
8000b50c:	74 28       	ld.w	r8,r10[0x8]
8000b50e:	58 08       	cp.w	r8,0
8000b510:	c0 41       	brne	8000b518 <__sprint_r+0x10>
8000b512:	95 18       	st.w	r10[0x4],r8
8000b514:	10 9c       	mov	r12,r8
8000b516:	d8 22       	popm	r4-r7,pc
8000b518:	e0 a0 18 ba 	rcall	8000e68c <__sfvwrite_r>
8000b51c:	30 08       	mov	r8,0
8000b51e:	8f 18       	st.w	r7[0x4],r8
8000b520:	8f 28       	st.w	r7[0x8],r8
8000b522:	d8 22       	popm	r4-r7,pc

8000b524 <_vfprintf_r>:
8000b524:	d4 31       	pushm	r0-r7,lr
8000b526:	fa cd 06 bc 	sub	sp,sp,1724
8000b52a:	51 09       	stdsp	sp[0x40],r9
8000b52c:	16 91       	mov	r1,r11
8000b52e:	14 97       	mov	r7,r10
8000b530:	18 95       	mov	r5,r12
8000b532:	e0 a0 1a 1d 	rcall	8000e96c <_localeconv_r>
8000b536:	78 0c       	ld.w	r12,r12[0x0]
8000b538:	50 cc       	stdsp	sp[0x30],r12
8000b53a:	58 05       	cp.w	r5,0
8000b53c:	c0 70       	breq	8000b54a <_vfprintf_r+0x26>
8000b53e:	6a 68       	ld.w	r8,r5[0x18]
8000b540:	58 08       	cp.w	r8,0
8000b542:	c0 41       	brne	8000b54a <_vfprintf_r+0x26>
8000b544:	0a 9c       	mov	r12,r5
8000b546:	e0 a0 17 43 	rcall	8000e3cc <__sinit>
8000b54a:	fe c8 a9 52 	sub	r8,pc,-22190
8000b54e:	10 31       	cp.w	r1,r8
8000b550:	c0 31       	brne	8000b556 <_vfprintf_r+0x32>
8000b552:	6a 01       	ld.w	r1,r5[0x0]
8000b554:	c0 c8       	rjmp	8000b56c <_vfprintf_r+0x48>
8000b556:	fe c8 a9 3e 	sub	r8,pc,-22210
8000b55a:	10 31       	cp.w	r1,r8
8000b55c:	c0 31       	brne	8000b562 <_vfprintf_r+0x3e>
8000b55e:	6a 11       	ld.w	r1,r5[0x4]
8000b560:	c0 68       	rjmp	8000b56c <_vfprintf_r+0x48>
8000b562:	fe c8 a9 2a 	sub	r8,pc,-22230
8000b566:	10 31       	cp.w	r1,r8
8000b568:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000b56c:	82 68       	ld.sh	r8,r1[0xc]
8000b56e:	ed b8 00 03 	bld	r8,0x3
8000b572:	c0 41       	brne	8000b57a <_vfprintf_r+0x56>
8000b574:	62 48       	ld.w	r8,r1[0x10]
8000b576:	58 08       	cp.w	r8,0
8000b578:	c0 71       	brne	8000b586 <_vfprintf_r+0x62>
8000b57a:	02 9b       	mov	r11,r1
8000b57c:	0a 9c       	mov	r12,r5
8000b57e:	e0 a0 0f 5d 	rcall	8000d438 <__swsetup_r>
8000b582:	e0 81 0f 54 	brne	8000d42a <_vfprintf_r+0x1f06>
8000b586:	82 68       	ld.sh	r8,r1[0xc]
8000b588:	10 99       	mov	r9,r8
8000b58a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000b58e:	58 a9       	cp.w	r9,10
8000b590:	c3 c1       	brne	8000b608 <_vfprintf_r+0xe4>
8000b592:	82 79       	ld.sh	r9,r1[0xe]
8000b594:	30 0a       	mov	r10,0
8000b596:	f4 09 19 00 	cp.h	r9,r10
8000b59a:	c3 75       	brlt	8000b608 <_vfprintf_r+0xe4>
8000b59c:	a1 d8       	cbr	r8,0x1
8000b59e:	fb 58 05 d0 	st.h	sp[1488],r8
8000b5a2:	62 88       	ld.w	r8,r1[0x20]
8000b5a4:	fb 48 05 e4 	st.w	sp[1508],r8
8000b5a8:	62 a8       	ld.w	r8,r1[0x28]
8000b5aa:	fb 48 05 ec 	st.w	sp[1516],r8
8000b5ae:	fa c8 ff bc 	sub	r8,sp,-68
8000b5b2:	fb 48 05 d4 	st.w	sp[1492],r8
8000b5b6:	fb 48 05 c4 	st.w	sp[1476],r8
8000b5ba:	e0 68 04 00 	mov	r8,1024
8000b5be:	fb 48 05 d8 	st.w	sp[1496],r8
8000b5c2:	fb 48 05 cc 	st.w	sp[1484],r8
8000b5c6:	30 08       	mov	r8,0
8000b5c8:	fb 59 05 d2 	st.h	sp[1490],r9
8000b5cc:	0e 9a       	mov	r10,r7
8000b5ce:	41 09       	lddsp	r9,sp[0x40]
8000b5d0:	fa c7 fa 3c 	sub	r7,sp,-1476
8000b5d4:	fb 48 05 dc 	st.w	sp[1500],r8
8000b5d8:	0a 9c       	mov	r12,r5
8000b5da:	0e 9b       	mov	r11,r7
8000b5dc:	ca 4f       	rcall	8000b524 <_vfprintf_r>
8000b5de:	50 bc       	stdsp	sp[0x2c],r12
8000b5e0:	c0 95       	brlt	8000b5f2 <_vfprintf_r+0xce>
8000b5e2:	0e 9b       	mov	r11,r7
8000b5e4:	0a 9c       	mov	r12,r5
8000b5e6:	e0 a0 16 1b 	rcall	8000e21c <_fflush_r>
8000b5ea:	40 be       	lddsp	lr,sp[0x2c]
8000b5ec:	f9 be 01 ff 	movne	lr,-1
8000b5f0:	50 be       	stdsp	sp[0x2c],lr
8000b5f2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000b5f6:	ed b8 00 06 	bld	r8,0x6
8000b5fa:	e0 81 0f 1a 	brne	8000d42e <_vfprintf_r+0x1f0a>
8000b5fe:	82 68       	ld.sh	r8,r1[0xc]
8000b600:	a7 a8       	sbr	r8,0x6
8000b602:	a2 68       	st.h	r1[0xc],r8
8000b604:	e0 8f 0f 15 	bral	8000d42e <_vfprintf_r+0x1f0a>
8000b608:	30 08       	mov	r8,0
8000b60a:	fb 48 06 b4 	st.w	sp[1716],r8
8000b60e:	fb 48 06 90 	st.w	sp[1680],r8
8000b612:	fb 48 06 8c 	st.w	sp[1676],r8
8000b616:	fb 48 06 b0 	st.w	sp[1712],r8
8000b61a:	30 08       	mov	r8,0
8000b61c:	30 09       	mov	r9,0
8000b61e:	50 a7       	stdsp	sp[0x28],r7
8000b620:	50 78       	stdsp	sp[0x1c],r8
8000b622:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b626:	3f f8       	mov	r8,-1
8000b628:	50 59       	stdsp	sp[0x14],r9
8000b62a:	fb 43 06 88 	st.w	sp[1672],r3
8000b62e:	fb 48 05 44 	st.w	sp[1348],r8
8000b632:	12 9c       	mov	r12,r9
8000b634:	50 69       	stdsp	sp[0x18],r9
8000b636:	50 d9       	stdsp	sp[0x34],r9
8000b638:	50 e9       	stdsp	sp[0x38],r9
8000b63a:	50 b9       	stdsp	sp[0x2c],r9
8000b63c:	12 97       	mov	r7,r9
8000b63e:	0a 94       	mov	r4,r5
8000b640:	40 a2       	lddsp	r2,sp[0x28]
8000b642:	32 5a       	mov	r10,37
8000b644:	30 08       	mov	r8,0
8000b646:	c0 28       	rjmp	8000b64a <_vfprintf_r+0x126>
8000b648:	2f f2       	sub	r2,-1
8000b64a:	05 89       	ld.ub	r9,r2[0x0]
8000b64c:	f0 09 18 00 	cp.b	r9,r8
8000b650:	5f 1b       	srne	r11
8000b652:	f4 09 18 00 	cp.b	r9,r10
8000b656:	5f 19       	srne	r9
8000b658:	f3 eb 00 0b 	and	r11,r9,r11
8000b65c:	f0 0b 18 00 	cp.b	r11,r8
8000b660:	cf 41       	brne	8000b648 <_vfprintf_r+0x124>
8000b662:	40 ab       	lddsp	r11,sp[0x28]
8000b664:	e4 0b 01 06 	sub	r6,r2,r11
8000b668:	c1 e0       	breq	8000b6a4 <_vfprintf_r+0x180>
8000b66a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b66e:	0c 08       	add	r8,r6
8000b670:	87 0b       	st.w	r3[0x0],r11
8000b672:	fb 48 06 90 	st.w	sp[1680],r8
8000b676:	87 16       	st.w	r3[0x4],r6
8000b678:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b67c:	2f f8       	sub	r8,-1
8000b67e:	fb 48 06 8c 	st.w	sp[1676],r8
8000b682:	58 78       	cp.w	r8,7
8000b684:	e0 89 00 04 	brgt	8000b68c <_vfprintf_r+0x168>
8000b688:	2f 83       	sub	r3,-8
8000b68a:	c0 a8       	rjmp	8000b69e <_vfprintf_r+0x17a>
8000b68c:	fa ca f9 78 	sub	r10,sp,-1672
8000b690:	02 9b       	mov	r11,r1
8000b692:	08 9c       	mov	r12,r4
8000b694:	c3 af       	rcall	8000b508 <__sprint_r>
8000b696:	e0 81 0e c6 	brne	8000d422 <_vfprintf_r+0x1efe>
8000b69a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b69e:	40 ba       	lddsp	r10,sp[0x2c]
8000b6a0:	0c 0a       	add	r10,r6
8000b6a2:	50 ba       	stdsp	sp[0x2c],r10
8000b6a4:	05 89       	ld.ub	r9,r2[0x0]
8000b6a6:	30 08       	mov	r8,0
8000b6a8:	f0 09 18 00 	cp.b	r9,r8
8000b6ac:	e0 80 0e aa 	breq	8000d400 <_vfprintf_r+0x1edc>
8000b6b0:	30 09       	mov	r9,0
8000b6b2:	fb 68 06 bb 	st.b	sp[1723],r8
8000b6b6:	0e 96       	mov	r6,r7
8000b6b8:	e4 c8 ff ff 	sub	r8,r2,-1
8000b6bc:	3f fe       	mov	lr,-1
8000b6be:	50 93       	stdsp	sp[0x24],r3
8000b6c0:	50 41       	stdsp	sp[0x10],r1
8000b6c2:	0e 93       	mov	r3,r7
8000b6c4:	04 91       	mov	r1,r2
8000b6c6:	50 89       	stdsp	sp[0x20],r9
8000b6c8:	50 a8       	stdsp	sp[0x28],r8
8000b6ca:	50 2e       	stdsp	sp[0x8],lr
8000b6cc:	50 39       	stdsp	sp[0xc],r9
8000b6ce:	12 95       	mov	r5,r9
8000b6d0:	12 90       	mov	r0,r9
8000b6d2:	10 97       	mov	r7,r8
8000b6d4:	08 92       	mov	r2,r4
8000b6d6:	c0 78       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b6d8:	3f fc       	mov	r12,-1
8000b6da:	08 97       	mov	r7,r4
8000b6dc:	50 2c       	stdsp	sp[0x8],r12
8000b6de:	c0 38       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b6e0:	30 0b       	mov	r11,0
8000b6e2:	50 3b       	stdsp	sp[0xc],r11
8000b6e4:	0f 38       	ld.ub	r8,r7++
8000b6e6:	c0 28       	rjmp	8000b6ea <_vfprintf_r+0x1c6>
8000b6e8:	12 90       	mov	r0,r9
8000b6ea:	f0 c9 00 20 	sub	r9,r8,32
8000b6ee:	e0 49 00 58 	cp.w	r9,88
8000b6f2:	e0 8b 0a 30 	brhi	8000cb52 <_vfprintf_r+0x162e>
8000b6f6:	fe ca ae a6 	sub	r10,pc,-20826
8000b6fa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b6fe:	50 a7       	stdsp	sp[0x28],r7
8000b700:	50 80       	stdsp	sp[0x20],r0
8000b702:	0c 97       	mov	r7,r6
8000b704:	04 94       	mov	r4,r2
8000b706:	06 96       	mov	r6,r3
8000b708:	02 92       	mov	r2,r1
8000b70a:	fe c9 ac 7e 	sub	r9,pc,-21378
8000b70e:	40 93       	lddsp	r3,sp[0x24]
8000b710:	10 90       	mov	r0,r8
8000b712:	40 41       	lddsp	r1,sp[0x10]
8000b714:	50 d9       	stdsp	sp[0x34],r9
8000b716:	e0 8f 08 8e 	bral	8000c832 <_vfprintf_r+0x130e>
8000b71a:	30 08       	mov	r8,0
8000b71c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b720:	f0 09 18 00 	cp.b	r9,r8
8000b724:	ce 01       	brne	8000b6e4 <_vfprintf_r+0x1c0>
8000b726:	32 08       	mov	r8,32
8000b728:	c6 e8       	rjmp	8000b804 <_vfprintf_r+0x2e0>
8000b72a:	a1 a5       	sbr	r5,0x0
8000b72c:	cd cb       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b72e:	0f 89       	ld.ub	r9,r7[0x0]
8000b730:	f2 c8 00 30 	sub	r8,r9,48
8000b734:	58 98       	cp.w	r8,9
8000b736:	e0 8b 00 1d 	brhi	8000b770 <_vfprintf_r+0x24c>
8000b73a:	ee c8 ff ff 	sub	r8,r7,-1
8000b73e:	30 0b       	mov	r11,0
8000b740:	23 09       	sub	r9,48
8000b742:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b746:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b74a:	11 39       	ld.ub	r9,r8++
8000b74c:	f2 ca 00 30 	sub	r10,r9,48
8000b750:	58 9a       	cp.w	r10,9
8000b752:	fe 98 ff f7 	brls	8000b740 <_vfprintf_r+0x21c>
8000b756:	e0 49 00 24 	cp.w	r9,36
8000b75a:	cc 31       	brne	8000b6e0 <_vfprintf_r+0x1bc>
8000b75c:	e0 4b 00 20 	cp.w	r11,32
8000b760:	e0 89 0e 60 	brgt	8000d420 <_vfprintf_r+0x1efc>
8000b764:	20 1b       	sub	r11,1
8000b766:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b76a:	12 3b       	cp.w	r11,r9
8000b76c:	c0 95       	brlt	8000b77e <_vfprintf_r+0x25a>
8000b76e:	c1 08       	rjmp	8000b78e <_vfprintf_r+0x26a>
8000b770:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b774:	ec ca ff ff 	sub	r10,r6,-1
8000b778:	12 36       	cp.w	r6,r9
8000b77a:	c1 f5       	brlt	8000b7b8 <_vfprintf_r+0x294>
8000b77c:	c2 68       	rjmp	8000b7c8 <_vfprintf_r+0x2a4>
8000b77e:	fa ce f9 44 	sub	lr,sp,-1724
8000b782:	10 97       	mov	r7,r8
8000b784:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b788:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b78c:	c3 58       	rjmp	8000b7f6 <_vfprintf_r+0x2d2>
8000b78e:	10 97       	mov	r7,r8
8000b790:	fa c8 f9 50 	sub	r8,sp,-1712
8000b794:	1a d8       	st.w	--sp,r8
8000b796:	fa c8 fa b8 	sub	r8,sp,-1352
8000b79a:	1a d8       	st.w	--sp,r8
8000b79c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b7a0:	02 9a       	mov	r10,r1
8000b7a2:	1a d8       	st.w	--sp,r8
8000b7a4:	04 9c       	mov	r12,r2
8000b7a6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b7aa:	fa c9 ff b4 	sub	r9,sp,-76
8000b7ae:	fe b0 fd 23 	rcall	8000b1f4 <get_arg>
8000b7b2:	2f dd       	sub	sp,-12
8000b7b4:	78 00       	ld.w	r0,r12[0x0]
8000b7b6:	c2 08       	rjmp	8000b7f6 <_vfprintf_r+0x2d2>
8000b7b8:	fa cc f9 44 	sub	r12,sp,-1724
8000b7bc:	14 96       	mov	r6,r10
8000b7be:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b7c2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b7c6:	c1 88       	rjmp	8000b7f6 <_vfprintf_r+0x2d2>
8000b7c8:	41 08       	lddsp	r8,sp[0x40]
8000b7ca:	59 f9       	cp.w	r9,31
8000b7cc:	e0 89 00 11 	brgt	8000b7ee <_vfprintf_r+0x2ca>
8000b7d0:	f0 cb ff fc 	sub	r11,r8,-4
8000b7d4:	51 0b       	stdsp	sp[0x40],r11
8000b7d6:	70 00       	ld.w	r0,r8[0x0]
8000b7d8:	fa cb f9 44 	sub	r11,sp,-1724
8000b7dc:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b7e0:	f1 40 fd 88 	st.w	r8[-632],r0
8000b7e4:	2f f9       	sub	r9,-1
8000b7e6:	14 96       	mov	r6,r10
8000b7e8:	fb 49 06 b4 	st.w	sp[1716],r9
8000b7ec:	c0 58       	rjmp	8000b7f6 <_vfprintf_r+0x2d2>
8000b7ee:	70 00       	ld.w	r0,r8[0x0]
8000b7f0:	14 96       	mov	r6,r10
8000b7f2:	2f c8       	sub	r8,-4
8000b7f4:	51 08       	stdsp	sp[0x40],r8
8000b7f6:	58 00       	cp.w	r0,0
8000b7f8:	fe 94 ff 76 	brge	8000b6e4 <_vfprintf_r+0x1c0>
8000b7fc:	5c 30       	neg	r0
8000b7fe:	a3 a5       	sbr	r5,0x2
8000b800:	c7 2b       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b802:	32 b8       	mov	r8,43
8000b804:	fb 68 06 bb 	st.b	sp[1723],r8
8000b808:	c6 eb       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b80a:	0f 38       	ld.ub	r8,r7++
8000b80c:	e0 48 00 2a 	cp.w	r8,42
8000b810:	c0 30       	breq	8000b816 <_vfprintf_r+0x2f2>
8000b812:	30 09       	mov	r9,0
8000b814:	c7 98       	rjmp	8000b906 <_vfprintf_r+0x3e2>
8000b816:	0f 88       	ld.ub	r8,r7[0x0]
8000b818:	f0 c9 00 30 	sub	r9,r8,48
8000b81c:	58 99       	cp.w	r9,9
8000b81e:	e0 8b 00 1f 	brhi	8000b85c <_vfprintf_r+0x338>
8000b822:	ee c4 ff ff 	sub	r4,r7,-1
8000b826:	30 0b       	mov	r11,0
8000b828:	23 08       	sub	r8,48
8000b82a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b82e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b832:	09 38       	ld.ub	r8,r4++
8000b834:	f0 c9 00 30 	sub	r9,r8,48
8000b838:	58 99       	cp.w	r9,9
8000b83a:	fe 98 ff f7 	brls	8000b828 <_vfprintf_r+0x304>
8000b83e:	e0 48 00 24 	cp.w	r8,36
8000b842:	fe 91 ff 4f 	brne	8000b6e0 <_vfprintf_r+0x1bc>
8000b846:	e0 4b 00 20 	cp.w	r11,32
8000b84a:	e0 89 0d eb 	brgt	8000d420 <_vfprintf_r+0x1efc>
8000b84e:	20 1b       	sub	r11,1
8000b850:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b854:	10 3b       	cp.w	r11,r8
8000b856:	c0 a5       	brlt	8000b86a <_vfprintf_r+0x346>
8000b858:	c1 18       	rjmp	8000b87a <_vfprintf_r+0x356>
8000b85a:	d7 03       	nop
8000b85c:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b860:	ec c9 ff ff 	sub	r9,r6,-1
8000b864:	14 36       	cp.w	r6,r10
8000b866:	c1 f5       	brlt	8000b8a4 <_vfprintf_r+0x380>
8000b868:	c2 88       	rjmp	8000b8b8 <_vfprintf_r+0x394>
8000b86a:	fa ca f9 44 	sub	r10,sp,-1724
8000b86e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b872:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b876:	50 2b       	stdsp	sp[0x8],r11
8000b878:	c3 c8       	rjmp	8000b8f0 <_vfprintf_r+0x3cc>
8000b87a:	fa c8 f9 50 	sub	r8,sp,-1712
8000b87e:	1a d8       	st.w	--sp,r8
8000b880:	fa c8 fa b8 	sub	r8,sp,-1352
8000b884:	1a d8       	st.w	--sp,r8
8000b886:	fa c8 fb b4 	sub	r8,sp,-1100
8000b88a:	02 9a       	mov	r10,r1
8000b88c:	1a d8       	st.w	--sp,r8
8000b88e:	04 9c       	mov	r12,r2
8000b890:	fa c8 f9 40 	sub	r8,sp,-1728
8000b894:	fa c9 ff b4 	sub	r9,sp,-76
8000b898:	fe b0 fc ae 	rcall	8000b1f4 <get_arg>
8000b89c:	2f dd       	sub	sp,-12
8000b89e:	78 0c       	ld.w	r12,r12[0x0]
8000b8a0:	50 2c       	stdsp	sp[0x8],r12
8000b8a2:	c2 78       	rjmp	8000b8f0 <_vfprintf_r+0x3cc>
8000b8a4:	12 96       	mov	r6,r9
8000b8a6:	0e 94       	mov	r4,r7
8000b8a8:	fa c9 f9 44 	sub	r9,sp,-1724
8000b8ac:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b8b0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b8b4:	50 28       	stdsp	sp[0x8],r8
8000b8b6:	c1 d8       	rjmp	8000b8f0 <_vfprintf_r+0x3cc>
8000b8b8:	41 08       	lddsp	r8,sp[0x40]
8000b8ba:	59 fa       	cp.w	r10,31
8000b8bc:	e0 89 00 14 	brgt	8000b8e4 <_vfprintf_r+0x3c0>
8000b8c0:	f0 cb ff fc 	sub	r11,r8,-4
8000b8c4:	70 08       	ld.w	r8,r8[0x0]
8000b8c6:	51 0b       	stdsp	sp[0x40],r11
8000b8c8:	50 28       	stdsp	sp[0x8],r8
8000b8ca:	fa c6 f9 44 	sub	r6,sp,-1724
8000b8ce:	40 2e       	lddsp	lr,sp[0x8]
8000b8d0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b8d4:	f1 4e fd 88 	st.w	r8[-632],lr
8000b8d8:	2f fa       	sub	r10,-1
8000b8da:	0e 94       	mov	r4,r7
8000b8dc:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b8e0:	12 96       	mov	r6,r9
8000b8e2:	c0 78       	rjmp	8000b8f0 <_vfprintf_r+0x3cc>
8000b8e4:	70 0c       	ld.w	r12,r8[0x0]
8000b8e6:	0e 94       	mov	r4,r7
8000b8e8:	2f c8       	sub	r8,-4
8000b8ea:	50 2c       	stdsp	sp[0x8],r12
8000b8ec:	12 96       	mov	r6,r9
8000b8ee:	51 08       	stdsp	sp[0x40],r8
8000b8f0:	40 2b       	lddsp	r11,sp[0x8]
8000b8f2:	58 0b       	cp.w	r11,0
8000b8f4:	fe 95 fe f2 	brlt	8000b6d8 <_vfprintf_r+0x1b4>
8000b8f8:	08 97       	mov	r7,r4
8000b8fa:	cf 5a       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b8fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b900:	0f 38       	ld.ub	r8,r7++
8000b902:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b906:	f0 ca 00 30 	sub	r10,r8,48
8000b90a:	58 9a       	cp.w	r10,9
8000b90c:	fe 98 ff f8 	brls	8000b8fc <_vfprintf_r+0x3d8>
8000b910:	3f fa       	mov	r10,-1
8000b912:	f2 0a 0c 49 	max	r9,r9,r10
8000b916:	50 29       	stdsp	sp[0x8],r9
8000b918:	ce 9a       	rjmp	8000b6ea <_vfprintf_r+0x1c6>
8000b91a:	a7 b5       	sbr	r5,0x7
8000b91c:	ce 4a       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b91e:	30 09       	mov	r9,0
8000b920:	23 08       	sub	r8,48
8000b922:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b926:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b92a:	0f 38       	ld.ub	r8,r7++
8000b92c:	f0 ca 00 30 	sub	r10,r8,48
8000b930:	58 9a       	cp.w	r10,9
8000b932:	fe 98 ff f7 	brls	8000b920 <_vfprintf_r+0x3fc>
8000b936:	e0 48 00 24 	cp.w	r8,36
8000b93a:	fe 91 fe d7 	brne	8000b6e8 <_vfprintf_r+0x1c4>
8000b93e:	e0 49 00 20 	cp.w	r9,32
8000b942:	e0 89 0d 6f 	brgt	8000d420 <_vfprintf_r+0x1efc>
8000b946:	f2 c3 00 01 	sub	r3,r9,1
8000b94a:	30 19       	mov	r9,1
8000b94c:	50 39       	stdsp	sp[0xc],r9
8000b94e:	cc ba       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b950:	a3 b5       	sbr	r5,0x3
8000b952:	cc 9a       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b954:	a7 a5       	sbr	r5,0x6
8000b956:	cc 7a       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b958:	0a 98       	mov	r8,r5
8000b95a:	a5 b5       	sbr	r5,0x5
8000b95c:	a5 a8       	sbr	r8,0x4
8000b95e:	0f 89       	ld.ub	r9,r7[0x0]
8000b960:	36 ce       	mov	lr,108
8000b962:	fc 09 18 00 	cp.b	r9,lr
8000b966:	f7 b7 00 ff 	subeq	r7,-1
8000b96a:	f0 05 17 10 	movne	r5,r8
8000b96e:	cb ba       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b970:	a5 b5       	sbr	r5,0x5
8000b972:	cb 9a       	rjmp	8000b6e4 <_vfprintf_r+0x1c0>
8000b974:	50 a7       	stdsp	sp[0x28],r7
8000b976:	50 80       	stdsp	sp[0x20],r0
8000b978:	0c 97       	mov	r7,r6
8000b97a:	10 90       	mov	r0,r8
8000b97c:	06 96       	mov	r6,r3
8000b97e:	04 94       	mov	r4,r2
8000b980:	40 93       	lddsp	r3,sp[0x24]
8000b982:	02 92       	mov	r2,r1
8000b984:	0e 99       	mov	r9,r7
8000b986:	40 41       	lddsp	r1,sp[0x10]
8000b988:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b98c:	40 3c       	lddsp	r12,sp[0xc]
8000b98e:	58 0c       	cp.w	r12,0
8000b990:	c1 d0       	breq	8000b9ca <_vfprintf_r+0x4a6>
8000b992:	10 36       	cp.w	r6,r8
8000b994:	c0 64       	brge	8000b9a0 <_vfprintf_r+0x47c>
8000b996:	fa cb f9 44 	sub	r11,sp,-1724
8000b99a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b99e:	c1 d8       	rjmp	8000b9d8 <_vfprintf_r+0x4b4>
8000b9a0:	fa c8 f9 50 	sub	r8,sp,-1712
8000b9a4:	1a d8       	st.w	--sp,r8
8000b9a6:	fa c8 fa b8 	sub	r8,sp,-1352
8000b9aa:	1a d8       	st.w	--sp,r8
8000b9ac:	fa c8 fb b4 	sub	r8,sp,-1100
8000b9b0:	1a d8       	st.w	--sp,r8
8000b9b2:	fa c8 f9 40 	sub	r8,sp,-1728
8000b9b6:	fa c9 ff b4 	sub	r9,sp,-76
8000b9ba:	04 9a       	mov	r10,r2
8000b9bc:	0c 9b       	mov	r11,r6
8000b9be:	08 9c       	mov	r12,r4
8000b9c0:	fe b0 fc 1a 	rcall	8000b1f4 <get_arg>
8000b9c4:	2f dd       	sub	sp,-12
8000b9c6:	19 b8       	ld.ub	r8,r12[0x3]
8000b9c8:	c2 28       	rjmp	8000ba0c <_vfprintf_r+0x4e8>
8000b9ca:	2f f7       	sub	r7,-1
8000b9cc:	10 39       	cp.w	r9,r8
8000b9ce:	c0 84       	brge	8000b9de <_vfprintf_r+0x4ba>
8000b9d0:	fa ca f9 44 	sub	r10,sp,-1724
8000b9d4:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b9d8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b9dc:	c1 88       	rjmp	8000ba0c <_vfprintf_r+0x4e8>
8000b9de:	41 09       	lddsp	r9,sp[0x40]
8000b9e0:	59 f8       	cp.w	r8,31
8000b9e2:	e0 89 00 12 	brgt	8000ba06 <_vfprintf_r+0x4e2>
8000b9e6:	f2 ca ff fc 	sub	r10,r9,-4
8000b9ea:	51 0a       	stdsp	sp[0x40],r10
8000b9ec:	72 09       	ld.w	r9,r9[0x0]
8000b9ee:	fa c6 f9 44 	sub	r6,sp,-1724
8000b9f2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b9f6:	2f f8       	sub	r8,-1
8000b9f8:	f5 49 fd 88 	st.w	r10[-632],r9
8000b9fc:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba00:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000ba04:	c0 48       	rjmp	8000ba0c <_vfprintf_r+0x4e8>
8000ba06:	13 b8       	ld.ub	r8,r9[0x3]
8000ba08:	2f c9       	sub	r9,-4
8000ba0a:	51 09       	stdsp	sp[0x40],r9
8000ba0c:	fb 68 06 60 	st.b	sp[1632],r8
8000ba10:	30 0e       	mov	lr,0
8000ba12:	30 08       	mov	r8,0
8000ba14:	30 12       	mov	r2,1
8000ba16:	fb 68 06 bb 	st.b	sp[1723],r8
8000ba1a:	50 2e       	stdsp	sp[0x8],lr
8000ba1c:	e0 8f 08 ad 	bral	8000cb76 <_vfprintf_r+0x1652>
8000ba20:	50 a7       	stdsp	sp[0x28],r7
8000ba22:	50 80       	stdsp	sp[0x20],r0
8000ba24:	0c 97       	mov	r7,r6
8000ba26:	04 94       	mov	r4,r2
8000ba28:	06 96       	mov	r6,r3
8000ba2a:	02 92       	mov	r2,r1
8000ba2c:	40 93       	lddsp	r3,sp[0x24]
8000ba2e:	10 90       	mov	r0,r8
8000ba30:	40 41       	lddsp	r1,sp[0x10]
8000ba32:	a5 a5       	sbr	r5,0x4
8000ba34:	c0 a8       	rjmp	8000ba48 <_vfprintf_r+0x524>
8000ba36:	50 a7       	stdsp	sp[0x28],r7
8000ba38:	50 80       	stdsp	sp[0x20],r0
8000ba3a:	0c 97       	mov	r7,r6
8000ba3c:	04 94       	mov	r4,r2
8000ba3e:	06 96       	mov	r6,r3
8000ba40:	02 92       	mov	r2,r1
8000ba42:	40 93       	lddsp	r3,sp[0x24]
8000ba44:	10 90       	mov	r0,r8
8000ba46:	40 41       	lddsp	r1,sp[0x10]
8000ba48:	ed b5 00 05 	bld	r5,0x5
8000ba4c:	c5 11       	brne	8000baee <_vfprintf_r+0x5ca>
8000ba4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba52:	40 3c       	lddsp	r12,sp[0xc]
8000ba54:	58 0c       	cp.w	r12,0
8000ba56:	c1 e0       	breq	8000ba92 <_vfprintf_r+0x56e>
8000ba58:	10 36       	cp.w	r6,r8
8000ba5a:	c0 64       	brge	8000ba66 <_vfprintf_r+0x542>
8000ba5c:	fa cb f9 44 	sub	r11,sp,-1724
8000ba60:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ba64:	c2 08       	rjmp	8000baa4 <_vfprintf_r+0x580>
8000ba66:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba6a:	1a d8       	st.w	--sp,r8
8000ba6c:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba70:	0c 9b       	mov	r11,r6
8000ba72:	1a d8       	st.w	--sp,r8
8000ba74:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba78:	1a d8       	st.w	--sp,r8
8000ba7a:	fa c9 ff b4 	sub	r9,sp,-76
8000ba7e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba82:	04 9a       	mov	r10,r2
8000ba84:	08 9c       	mov	r12,r4
8000ba86:	fe b0 fb b7 	rcall	8000b1f4 <get_arg>
8000ba8a:	2f dd       	sub	sp,-12
8000ba8c:	78 1b       	ld.w	r11,r12[0x4]
8000ba8e:	78 09       	ld.w	r9,r12[0x0]
8000ba90:	c2 b8       	rjmp	8000bae6 <_vfprintf_r+0x5c2>
8000ba92:	ee ca ff ff 	sub	r10,r7,-1
8000ba96:	10 37       	cp.w	r7,r8
8000ba98:	c0 b4       	brge	8000baae <_vfprintf_r+0x58a>
8000ba9a:	fa c9 f9 44 	sub	r9,sp,-1724
8000ba9e:	14 97       	mov	r7,r10
8000baa0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000baa4:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000baa8:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000baac:	c1 d8       	rjmp	8000bae6 <_vfprintf_r+0x5c2>
8000baae:	41 09       	lddsp	r9,sp[0x40]
8000bab0:	59 f8       	cp.w	r8,31
8000bab2:	e0 89 00 14 	brgt	8000bada <_vfprintf_r+0x5b6>
8000bab6:	f2 cb ff f8 	sub	r11,r9,-8
8000baba:	51 0b       	stdsp	sp[0x40],r11
8000babc:	fa c6 f9 44 	sub	r6,sp,-1724
8000bac0:	72 1b       	ld.w	r11,r9[0x4]
8000bac2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000bac6:	72 09       	ld.w	r9,r9[0x0]
8000bac8:	f9 4b fd 8c 	st.w	r12[-628],r11
8000bacc:	f9 49 fd 88 	st.w	r12[-632],r9
8000bad0:	2f f8       	sub	r8,-1
8000bad2:	14 97       	mov	r7,r10
8000bad4:	fb 48 06 b4 	st.w	sp[1716],r8
8000bad8:	c0 78       	rjmp	8000bae6 <_vfprintf_r+0x5c2>
8000bada:	f2 c8 ff f8 	sub	r8,r9,-8
8000bade:	72 1b       	ld.w	r11,r9[0x4]
8000bae0:	14 97       	mov	r7,r10
8000bae2:	51 08       	stdsp	sp[0x40],r8
8000bae4:	72 09       	ld.w	r9,r9[0x0]
8000bae6:	16 98       	mov	r8,r11
8000bae8:	fa e9 00 00 	st.d	sp[0],r8
8000baec:	ca e8       	rjmp	8000bc48 <_vfprintf_r+0x724>
8000baee:	ed b5 00 04 	bld	r5,0x4
8000baf2:	c1 71       	brne	8000bb20 <_vfprintf_r+0x5fc>
8000baf4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000baf8:	40 3e       	lddsp	lr,sp[0xc]
8000bafa:	58 0e       	cp.w	lr,0
8000bafc:	c0 80       	breq	8000bb0c <_vfprintf_r+0x5e8>
8000bafe:	10 36       	cp.w	r6,r8
8000bb00:	c6 94       	brge	8000bbd2 <_vfprintf_r+0x6ae>
8000bb02:	fa cc f9 44 	sub	r12,sp,-1724
8000bb06:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bb0a:	c8 28       	rjmp	8000bc0e <_vfprintf_r+0x6ea>
8000bb0c:	ee ca ff ff 	sub	r10,r7,-1
8000bb10:	10 37       	cp.w	r7,r8
8000bb12:	e0 84 00 81 	brge	8000bc14 <_vfprintf_r+0x6f0>
8000bb16:	fa cb f9 44 	sub	r11,sp,-1724
8000bb1a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb1e:	c7 78       	rjmp	8000bc0c <_vfprintf_r+0x6e8>
8000bb20:	ed b5 00 06 	bld	r5,0x6
8000bb24:	c4 b1       	brne	8000bbba <_vfprintf_r+0x696>
8000bb26:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb2a:	40 3c       	lddsp	r12,sp[0xc]
8000bb2c:	58 0c       	cp.w	r12,0
8000bb2e:	c1 d0       	breq	8000bb68 <_vfprintf_r+0x644>
8000bb30:	10 36       	cp.w	r6,r8
8000bb32:	c0 64       	brge	8000bb3e <_vfprintf_r+0x61a>
8000bb34:	fa cb f9 44 	sub	r11,sp,-1724
8000bb38:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb3c:	c1 f8       	rjmp	8000bb7a <_vfprintf_r+0x656>
8000bb3e:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb42:	1a d8       	st.w	--sp,r8
8000bb44:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb48:	1a d8       	st.w	--sp,r8
8000bb4a:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb4e:	1a d8       	st.w	--sp,r8
8000bb50:	fa c8 f9 40 	sub	r8,sp,-1728
8000bb54:	fa c9 ff b4 	sub	r9,sp,-76
8000bb58:	04 9a       	mov	r10,r2
8000bb5a:	0c 9b       	mov	r11,r6
8000bb5c:	08 9c       	mov	r12,r4
8000bb5e:	fe b0 fb 4b 	rcall	8000b1f4 <get_arg>
8000bb62:	2f dd       	sub	sp,-12
8000bb64:	98 18       	ld.sh	r8,r12[0x2]
8000bb66:	c2 68       	rjmp	8000bbb2 <_vfprintf_r+0x68e>
8000bb68:	ee ca ff ff 	sub	r10,r7,-1
8000bb6c:	10 37       	cp.w	r7,r8
8000bb6e:	c0 94       	brge	8000bb80 <_vfprintf_r+0x65c>
8000bb70:	fa c9 f9 44 	sub	r9,sp,-1724
8000bb74:	14 97       	mov	r7,r10
8000bb76:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bb7a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bb7e:	c1 a8       	rjmp	8000bbb2 <_vfprintf_r+0x68e>
8000bb80:	41 09       	lddsp	r9,sp[0x40]
8000bb82:	59 f8       	cp.w	r8,31
8000bb84:	e0 89 00 13 	brgt	8000bbaa <_vfprintf_r+0x686>
8000bb88:	f2 cb ff fc 	sub	r11,r9,-4
8000bb8c:	51 0b       	stdsp	sp[0x40],r11
8000bb8e:	72 09       	ld.w	r9,r9[0x0]
8000bb90:	fa c6 f9 44 	sub	r6,sp,-1724
8000bb94:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bb98:	2f f8       	sub	r8,-1
8000bb9a:	f7 49 fd 88 	st.w	r11[-632],r9
8000bb9e:	fb 48 06 b4 	st.w	sp[1716],r8
8000bba2:	14 97       	mov	r7,r10
8000bba4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bba8:	c0 58       	rjmp	8000bbb2 <_vfprintf_r+0x68e>
8000bbaa:	92 18       	ld.sh	r8,r9[0x2]
8000bbac:	14 97       	mov	r7,r10
8000bbae:	2f c9       	sub	r9,-4
8000bbb0:	51 09       	stdsp	sp[0x40],r9
8000bbb2:	50 18       	stdsp	sp[0x4],r8
8000bbb4:	bf 58       	asr	r8,0x1f
8000bbb6:	50 08       	stdsp	sp[0x0],r8
8000bbb8:	c4 88       	rjmp	8000bc48 <_vfprintf_r+0x724>
8000bbba:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bbbe:	40 3c       	lddsp	r12,sp[0xc]
8000bbc0:	58 0c       	cp.w	r12,0
8000bbc2:	c1 d0       	breq	8000bbfc <_vfprintf_r+0x6d8>
8000bbc4:	10 36       	cp.w	r6,r8
8000bbc6:	c0 64       	brge	8000bbd2 <_vfprintf_r+0x6ae>
8000bbc8:	fa cb f9 44 	sub	r11,sp,-1724
8000bbcc:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bbd0:	c1 f8       	rjmp	8000bc0e <_vfprintf_r+0x6ea>
8000bbd2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bbd6:	1a d8       	st.w	--sp,r8
8000bbd8:	fa c8 fa b8 	sub	r8,sp,-1352
8000bbdc:	0c 9b       	mov	r11,r6
8000bbde:	1a d8       	st.w	--sp,r8
8000bbe0:	fa c8 fb b4 	sub	r8,sp,-1100
8000bbe4:	04 9a       	mov	r10,r2
8000bbe6:	1a d8       	st.w	--sp,r8
8000bbe8:	08 9c       	mov	r12,r4
8000bbea:	fa c8 f9 40 	sub	r8,sp,-1728
8000bbee:	fa c9 ff b4 	sub	r9,sp,-76
8000bbf2:	fe b0 fb 01 	rcall	8000b1f4 <get_arg>
8000bbf6:	2f dd       	sub	sp,-12
8000bbf8:	78 0b       	ld.w	r11,r12[0x0]
8000bbfa:	c2 48       	rjmp	8000bc42 <_vfprintf_r+0x71e>
8000bbfc:	ee ca ff ff 	sub	r10,r7,-1
8000bc00:	10 37       	cp.w	r7,r8
8000bc02:	c0 94       	brge	8000bc14 <_vfprintf_r+0x6f0>
8000bc04:	fa c9 f9 44 	sub	r9,sp,-1724
8000bc08:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bc0c:	14 97       	mov	r7,r10
8000bc0e:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bc12:	c1 88       	rjmp	8000bc42 <_vfprintf_r+0x71e>
8000bc14:	41 09       	lddsp	r9,sp[0x40]
8000bc16:	59 f8       	cp.w	r8,31
8000bc18:	e0 89 00 11 	brgt	8000bc3a <_vfprintf_r+0x716>
8000bc1c:	f2 cb ff fc 	sub	r11,r9,-4
8000bc20:	51 0b       	stdsp	sp[0x40],r11
8000bc22:	fa c6 f9 44 	sub	r6,sp,-1724
8000bc26:	72 0b       	ld.w	r11,r9[0x0]
8000bc28:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bc2c:	f3 4b fd 88 	st.w	r9[-632],r11
8000bc30:	2f f8       	sub	r8,-1
8000bc32:	14 97       	mov	r7,r10
8000bc34:	fb 48 06 b4 	st.w	sp[1716],r8
8000bc38:	c0 58       	rjmp	8000bc42 <_vfprintf_r+0x71e>
8000bc3a:	72 0b       	ld.w	r11,r9[0x0]
8000bc3c:	14 97       	mov	r7,r10
8000bc3e:	2f c9       	sub	r9,-4
8000bc40:	51 09       	stdsp	sp[0x40],r9
8000bc42:	50 1b       	stdsp	sp[0x4],r11
8000bc44:	bf 5b       	asr	r11,0x1f
8000bc46:	50 0b       	stdsp	sp[0x0],r11
8000bc48:	fa ea 00 00 	ld.d	r10,sp[0]
8000bc4c:	58 0a       	cp.w	r10,0
8000bc4e:	5c 2b       	cpc	r11
8000bc50:	c0 e4       	brge	8000bc6c <_vfprintf_r+0x748>
8000bc52:	30 08       	mov	r8,0
8000bc54:	fa ea 00 00 	ld.d	r10,sp[0]
8000bc58:	30 09       	mov	r9,0
8000bc5a:	f0 0a 01 0a 	sub	r10,r8,r10
8000bc5e:	f2 0b 01 4b 	sbc	r11,r9,r11
8000bc62:	32 d8       	mov	r8,45
8000bc64:	fa eb 00 00 	st.d	sp[0],r10
8000bc68:	fb 68 06 bb 	st.b	sp[1723],r8
8000bc6c:	30 18       	mov	r8,1
8000bc6e:	e0 8f 06 fa 	bral	8000ca62 <_vfprintf_r+0x153e>
8000bc72:	50 a7       	stdsp	sp[0x28],r7
8000bc74:	50 80       	stdsp	sp[0x20],r0
8000bc76:	0c 97       	mov	r7,r6
8000bc78:	04 94       	mov	r4,r2
8000bc7a:	06 96       	mov	r6,r3
8000bc7c:	02 92       	mov	r2,r1
8000bc7e:	40 93       	lddsp	r3,sp[0x24]
8000bc80:	10 90       	mov	r0,r8
8000bc82:	40 41       	lddsp	r1,sp[0x10]
8000bc84:	0e 99       	mov	r9,r7
8000bc86:	ed b5 00 03 	bld	r5,0x3
8000bc8a:	c4 11       	brne	8000bd0c <_vfprintf_r+0x7e8>
8000bc8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc90:	40 3a       	lddsp	r10,sp[0xc]
8000bc92:	58 0a       	cp.w	r10,0
8000bc94:	c1 90       	breq	8000bcc6 <_vfprintf_r+0x7a2>
8000bc96:	10 36       	cp.w	r6,r8
8000bc98:	c6 45       	brlt	8000bd60 <_vfprintf_r+0x83c>
8000bc9a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc9e:	1a d8       	st.w	--sp,r8
8000bca0:	fa c8 fa b8 	sub	r8,sp,-1352
8000bca4:	1a d8       	st.w	--sp,r8
8000bca6:	fa c8 fb b4 	sub	r8,sp,-1100
8000bcaa:	0c 9b       	mov	r11,r6
8000bcac:	1a d8       	st.w	--sp,r8
8000bcae:	04 9a       	mov	r10,r2
8000bcb0:	fa c8 f9 40 	sub	r8,sp,-1728
8000bcb4:	fa c9 ff b4 	sub	r9,sp,-76
8000bcb8:	08 9c       	mov	r12,r4
8000bcba:	fe b0 fa 9d 	rcall	8000b1f4 <get_arg>
8000bcbe:	2f dd       	sub	sp,-12
8000bcc0:	78 16       	ld.w	r6,r12[0x4]
8000bcc2:	50 76       	stdsp	sp[0x1c],r6
8000bcc4:	c4 88       	rjmp	8000bd54 <_vfprintf_r+0x830>
8000bcc6:	2f f7       	sub	r7,-1
8000bcc8:	10 39       	cp.w	r9,r8
8000bcca:	c0 c4       	brge	8000bce2 <_vfprintf_r+0x7be>
8000bccc:	fa ce f9 44 	sub	lr,sp,-1724
8000bcd0:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000bcd4:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000bcd8:	50 7c       	stdsp	sp[0x1c],r12
8000bcda:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000bcde:	50 56       	stdsp	sp[0x14],r6
8000bce0:	c6 68       	rjmp	8000bdac <_vfprintf_r+0x888>
8000bce2:	41 09       	lddsp	r9,sp[0x40]
8000bce4:	59 f8       	cp.w	r8,31
8000bce6:	e0 89 00 10 	brgt	8000bd06 <_vfprintf_r+0x7e2>
8000bcea:	f2 ca ff f8 	sub	r10,r9,-8
8000bcee:	72 1b       	ld.w	r11,r9[0x4]
8000bcf0:	51 0a       	stdsp	sp[0x40],r10
8000bcf2:	72 09       	ld.w	r9,r9[0x0]
8000bcf4:	fa ca f9 44 	sub	r10,sp,-1724
8000bcf8:	50 7b       	stdsp	sp[0x1c],r11
8000bcfa:	50 59       	stdsp	sp[0x14],r9
8000bcfc:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000bd00:	40 5b       	lddsp	r11,sp[0x14]
8000bd02:	40 7a       	lddsp	r10,sp[0x1c]
8000bd04:	c4 78       	rjmp	8000bd92 <_vfprintf_r+0x86e>
8000bd06:	72 18       	ld.w	r8,r9[0x4]
8000bd08:	50 78       	stdsp	sp[0x1c],r8
8000bd0a:	c4 c8       	rjmp	8000bda2 <_vfprintf_r+0x87e>
8000bd0c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd10:	40 3e       	lddsp	lr,sp[0xc]
8000bd12:	58 0e       	cp.w	lr,0
8000bd14:	c2 30       	breq	8000bd5a <_vfprintf_r+0x836>
8000bd16:	10 36       	cp.w	r6,r8
8000bd18:	c0 94       	brge	8000bd2a <_vfprintf_r+0x806>
8000bd1a:	fa cc f9 44 	sub	r12,sp,-1724
8000bd1e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bd22:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000bd26:	50 7b       	stdsp	sp[0x1c],r11
8000bd28:	cd 9b       	rjmp	8000bcda <_vfprintf_r+0x7b6>
8000bd2a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bd2e:	1a d8       	st.w	--sp,r8
8000bd30:	fa c8 fa b8 	sub	r8,sp,-1352
8000bd34:	04 9a       	mov	r10,r2
8000bd36:	1a d8       	st.w	--sp,r8
8000bd38:	fa c8 fb b4 	sub	r8,sp,-1100
8000bd3c:	0c 9b       	mov	r11,r6
8000bd3e:	1a d8       	st.w	--sp,r8
8000bd40:	08 9c       	mov	r12,r4
8000bd42:	fa c8 f9 40 	sub	r8,sp,-1728
8000bd46:	fa c9 ff b4 	sub	r9,sp,-76
8000bd4a:	fe b0 fa 55 	rcall	8000b1f4 <get_arg>
8000bd4e:	2f dd       	sub	sp,-12
8000bd50:	78 1a       	ld.w	r10,r12[0x4]
8000bd52:	50 7a       	stdsp	sp[0x1c],r10
8000bd54:	78 0c       	ld.w	r12,r12[0x0]
8000bd56:	50 5c       	stdsp	sp[0x14],r12
8000bd58:	c2 a8       	rjmp	8000bdac <_vfprintf_r+0x888>
8000bd5a:	2f f7       	sub	r7,-1
8000bd5c:	10 39       	cp.w	r9,r8
8000bd5e:	c0 94       	brge	8000bd70 <_vfprintf_r+0x84c>
8000bd60:	fa c9 f9 44 	sub	r9,sp,-1724
8000bd64:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bd68:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000bd6c:	50 78       	stdsp	sp[0x1c],r8
8000bd6e:	cb 6b       	rjmp	8000bcda <_vfprintf_r+0x7b6>
8000bd70:	41 09       	lddsp	r9,sp[0x40]
8000bd72:	59 f8       	cp.w	r8,31
8000bd74:	e0 89 00 15 	brgt	8000bd9e <_vfprintf_r+0x87a>
8000bd78:	f2 ca ff f8 	sub	r10,r9,-8
8000bd7c:	72 16       	ld.w	r6,r9[0x4]
8000bd7e:	72 09       	ld.w	r9,r9[0x0]
8000bd80:	51 0a       	stdsp	sp[0x40],r10
8000bd82:	50 59       	stdsp	sp[0x14],r9
8000bd84:	fa ce f9 44 	sub	lr,sp,-1724
8000bd88:	50 76       	stdsp	sp[0x1c],r6
8000bd8a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000bd8e:	40 5b       	lddsp	r11,sp[0x14]
8000bd90:	0c 9a       	mov	r10,r6
8000bd92:	f2 eb fd 88 	st.d	r9[-632],r10
8000bd96:	2f f8       	sub	r8,-1
8000bd98:	fb 48 06 b4 	st.w	sp[1716],r8
8000bd9c:	c0 88       	rjmp	8000bdac <_vfprintf_r+0x888>
8000bd9e:	72 1c       	ld.w	r12,r9[0x4]
8000bda0:	50 7c       	stdsp	sp[0x1c],r12
8000bda2:	f2 c8 ff f8 	sub	r8,r9,-8
8000bda6:	51 08       	stdsp	sp[0x40],r8
8000bda8:	72 09       	ld.w	r9,r9[0x0]
8000bdaa:	50 59       	stdsp	sp[0x14],r9
8000bdac:	40 5b       	lddsp	r11,sp[0x14]
8000bdae:	40 7a       	lddsp	r10,sp[0x1c]
8000bdb0:	e0 a0 19 54 	rcall	8000f058 <__isinfd>
8000bdb4:	18 96       	mov	r6,r12
8000bdb6:	c1 70       	breq	8000bde4 <_vfprintf_r+0x8c0>
8000bdb8:	30 08       	mov	r8,0
8000bdba:	30 09       	mov	r9,0
8000bdbc:	40 5b       	lddsp	r11,sp[0x14]
8000bdbe:	40 7a       	lddsp	r10,sp[0x1c]
8000bdc0:	e0 a0 1d a8 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000bdc4:	c0 40       	breq	8000bdcc <_vfprintf_r+0x8a8>
8000bdc6:	32 d8       	mov	r8,45
8000bdc8:	fb 68 06 bb 	st.b	sp[1723],r8
8000bdcc:	fe c8 b3 2c 	sub	r8,pc,-19668
8000bdd0:	fe c6 b3 2c 	sub	r6,pc,-19668
8000bdd4:	a7 d5       	cbr	r5,0x7
8000bdd6:	e0 40 00 47 	cp.w	r0,71
8000bdda:	f0 06 17 a0 	movle	r6,r8
8000bdde:	30 32       	mov	r2,3
8000bde0:	e0 8f 06 ce 	bral	8000cb7c <_vfprintf_r+0x1658>
8000bde4:	40 5b       	lddsp	r11,sp[0x14]
8000bde6:	40 7a       	lddsp	r10,sp[0x1c]
8000bde8:	e0 a0 19 4d 	rcall	8000f082 <__isnand>
8000bdec:	c0 e0       	breq	8000be08 <_vfprintf_r+0x8e4>
8000bdee:	50 26       	stdsp	sp[0x8],r6
8000bdf0:	fe c8 b3 48 	sub	r8,pc,-19640
8000bdf4:	fe c6 b3 48 	sub	r6,pc,-19640
8000bdf8:	a7 d5       	cbr	r5,0x7
8000bdfa:	e0 40 00 47 	cp.w	r0,71
8000bdfe:	f0 06 17 a0 	movle	r6,r8
8000be02:	30 32       	mov	r2,3
8000be04:	e0 8f 06 c2 	bral	8000cb88 <_vfprintf_r+0x1664>
8000be08:	40 2a       	lddsp	r10,sp[0x8]
8000be0a:	5b fa       	cp.w	r10,-1
8000be0c:	c0 41       	brne	8000be14 <_vfprintf_r+0x8f0>
8000be0e:	30 69       	mov	r9,6
8000be10:	50 29       	stdsp	sp[0x8],r9
8000be12:	c1 18       	rjmp	8000be34 <_vfprintf_r+0x910>
8000be14:	e0 40 00 47 	cp.w	r0,71
8000be18:	5f 09       	sreq	r9
8000be1a:	e0 40 00 67 	cp.w	r0,103
8000be1e:	5f 08       	sreq	r8
8000be20:	f3 e8 10 08 	or	r8,r9,r8
8000be24:	f8 08 18 00 	cp.b	r8,r12
8000be28:	c0 60       	breq	8000be34 <_vfprintf_r+0x910>
8000be2a:	40 28       	lddsp	r8,sp[0x8]
8000be2c:	58 08       	cp.w	r8,0
8000be2e:	f9 b8 00 01 	moveq	r8,1
8000be32:	50 28       	stdsp	sp[0x8],r8
8000be34:	40 78       	lddsp	r8,sp[0x1c]
8000be36:	40 59       	lddsp	r9,sp[0x14]
8000be38:	fa e9 06 94 	st.d	sp[1684],r8
8000be3c:	a9 a5       	sbr	r5,0x8
8000be3e:	fa f8 06 94 	ld.w	r8,sp[1684]
8000be42:	58 08       	cp.w	r8,0
8000be44:	c0 65       	brlt	8000be50 <_vfprintf_r+0x92c>
8000be46:	40 5e       	lddsp	lr,sp[0x14]
8000be48:	30 0c       	mov	r12,0
8000be4a:	50 6e       	stdsp	sp[0x18],lr
8000be4c:	50 9c       	stdsp	sp[0x24],r12
8000be4e:	c0 78       	rjmp	8000be5c <_vfprintf_r+0x938>
8000be50:	40 5b       	lddsp	r11,sp[0x14]
8000be52:	32 da       	mov	r10,45
8000be54:	ee 1b 80 00 	eorh	r11,0x8000
8000be58:	50 9a       	stdsp	sp[0x24],r10
8000be5a:	50 6b       	stdsp	sp[0x18],r11
8000be5c:	e0 40 00 46 	cp.w	r0,70
8000be60:	5f 09       	sreq	r9
8000be62:	e0 40 00 66 	cp.w	r0,102
8000be66:	5f 08       	sreq	r8
8000be68:	f3 e8 10 08 	or	r8,r9,r8
8000be6c:	50 48       	stdsp	sp[0x10],r8
8000be6e:	c0 40       	breq	8000be76 <_vfprintf_r+0x952>
8000be70:	40 22       	lddsp	r2,sp[0x8]
8000be72:	30 39       	mov	r9,3
8000be74:	c1 08       	rjmp	8000be94 <_vfprintf_r+0x970>
8000be76:	e0 40 00 45 	cp.w	r0,69
8000be7a:	5f 09       	sreq	r9
8000be7c:	e0 40 00 65 	cp.w	r0,101
8000be80:	5f 08       	sreq	r8
8000be82:	40 22       	lddsp	r2,sp[0x8]
8000be84:	10 49       	or	r9,r8
8000be86:	2f f2       	sub	r2,-1
8000be88:	40 46       	lddsp	r6,sp[0x10]
8000be8a:	ec 09 18 00 	cp.b	r9,r6
8000be8e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000be92:	30 29       	mov	r9,2
8000be94:	fa c8 f9 5c 	sub	r8,sp,-1700
8000be98:	1a d8       	st.w	--sp,r8
8000be9a:	fa c8 f9 54 	sub	r8,sp,-1708
8000be9e:	1a d8       	st.w	--sp,r8
8000bea0:	fa c8 f9 4c 	sub	r8,sp,-1716
8000bea4:	08 9c       	mov	r12,r4
8000bea6:	1a d8       	st.w	--sp,r8
8000bea8:	04 98       	mov	r8,r2
8000beaa:	40 9b       	lddsp	r11,sp[0x24]
8000beac:	40 aa       	lddsp	r10,sp[0x28]
8000beae:	e0 a0 0b c3 	rcall	8000d634 <_dtoa_r>
8000beb2:	e0 40 00 47 	cp.w	r0,71
8000beb6:	5f 19       	srne	r9
8000beb8:	e0 40 00 67 	cp.w	r0,103
8000bebc:	5f 18       	srne	r8
8000bebe:	18 96       	mov	r6,r12
8000bec0:	2f dd       	sub	sp,-12
8000bec2:	f3 e8 00 08 	and	r8,r9,r8
8000bec6:	c0 41       	brne	8000bece <_vfprintf_r+0x9aa>
8000bec8:	ed b5 00 00 	bld	r5,0x0
8000becc:	c3 01       	brne	8000bf2c <_vfprintf_r+0xa08>
8000bece:	ec 02 00 0e 	add	lr,r6,r2
8000bed2:	50 3e       	stdsp	sp[0xc],lr
8000bed4:	40 4c       	lddsp	r12,sp[0x10]
8000bed6:	58 0c       	cp.w	r12,0
8000bed8:	c1 50       	breq	8000bf02 <_vfprintf_r+0x9de>
8000beda:	0d 89       	ld.ub	r9,r6[0x0]
8000bedc:	33 08       	mov	r8,48
8000bede:	f0 09 18 00 	cp.b	r9,r8
8000bee2:	c0 b1       	brne	8000bef8 <_vfprintf_r+0x9d4>
8000bee4:	30 08       	mov	r8,0
8000bee6:	30 09       	mov	r9,0
8000bee8:	40 6b       	lddsp	r11,sp[0x18]
8000beea:	40 7a       	lddsp	r10,sp[0x1c]
8000beec:	e0 a0 1c cb 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000bef0:	fb b2 00 01 	rsubeq	r2,1
8000bef4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000bef8:	40 3b       	lddsp	r11,sp[0xc]
8000befa:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000befe:	10 0b       	add	r11,r8
8000bf00:	50 3b       	stdsp	sp[0xc],r11
8000bf02:	40 6b       	lddsp	r11,sp[0x18]
8000bf04:	30 08       	mov	r8,0
8000bf06:	30 09       	mov	r9,0
8000bf08:	40 7a       	lddsp	r10,sp[0x1c]
8000bf0a:	e0 a0 1c bc 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000bf0e:	c0 90       	breq	8000bf20 <_vfprintf_r+0x9fc>
8000bf10:	40 3a       	lddsp	r10,sp[0xc]
8000bf12:	fb 4a 06 a4 	st.w	sp[1700],r10
8000bf16:	c0 58       	rjmp	8000bf20 <_vfprintf_r+0x9fc>
8000bf18:	10 c9       	st.b	r8++,r9
8000bf1a:	fb 48 06 a4 	st.w	sp[1700],r8
8000bf1e:	c0 28       	rjmp	8000bf22 <_vfprintf_r+0x9fe>
8000bf20:	33 09       	mov	r9,48
8000bf22:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000bf26:	40 3e       	lddsp	lr,sp[0xc]
8000bf28:	1c 38       	cp.w	r8,lr
8000bf2a:	cf 73       	brcs	8000bf18 <_vfprintf_r+0x9f4>
8000bf2c:	e0 40 00 47 	cp.w	r0,71
8000bf30:	5f 09       	sreq	r9
8000bf32:	e0 40 00 67 	cp.w	r0,103
8000bf36:	5f 08       	sreq	r8
8000bf38:	f3 e8 10 08 	or	r8,r9,r8
8000bf3c:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000bf40:	0c 19       	sub	r9,r6
8000bf42:	50 69       	stdsp	sp[0x18],r9
8000bf44:	58 08       	cp.w	r8,0
8000bf46:	c0 b0       	breq	8000bf5c <_vfprintf_r+0xa38>
8000bf48:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bf4c:	5b d8       	cp.w	r8,-3
8000bf4e:	c0 55       	brlt	8000bf58 <_vfprintf_r+0xa34>
8000bf50:	40 2c       	lddsp	r12,sp[0x8]
8000bf52:	18 38       	cp.w	r8,r12
8000bf54:	e0 8a 00 6a 	brle	8000c028 <_vfprintf_r+0xb04>
8000bf58:	20 20       	sub	r0,2
8000bf5a:	c0 58       	rjmp	8000bf64 <_vfprintf_r+0xa40>
8000bf5c:	e0 40 00 65 	cp.w	r0,101
8000bf60:	e0 89 00 46 	brgt	8000bfec <_vfprintf_r+0xac8>
8000bf64:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000bf68:	fb 60 06 9c 	st.b	sp[1692],r0
8000bf6c:	20 1b       	sub	r11,1
8000bf6e:	fb 4b 06 ac 	st.w	sp[1708],r11
8000bf72:	c0 47       	brpl	8000bf7a <_vfprintf_r+0xa56>
8000bf74:	5c 3b       	neg	r11
8000bf76:	32 d8       	mov	r8,45
8000bf78:	c0 28       	rjmp	8000bf7c <_vfprintf_r+0xa58>
8000bf7a:	32 b8       	mov	r8,43
8000bf7c:	fb 68 06 9d 	st.b	sp[1693],r8
8000bf80:	58 9b       	cp.w	r11,9
8000bf82:	e0 8a 00 1d 	brle	8000bfbc <_vfprintf_r+0xa98>
8000bf86:	fa c9 fa 35 	sub	r9,sp,-1483
8000bf8a:	30 aa       	mov	r10,10
8000bf8c:	12 98       	mov	r8,r9
8000bf8e:	0e 9c       	mov	r12,r7
8000bf90:	0c 92       	mov	r2,r6
8000bf92:	f6 0a 0c 06 	divs	r6,r11,r10
8000bf96:	0e 9b       	mov	r11,r7
8000bf98:	2d 0b       	sub	r11,-48
8000bf9a:	10 fb       	st.b	--r8,r11
8000bf9c:	0c 9b       	mov	r11,r6
8000bf9e:	58 96       	cp.w	r6,9
8000bfa0:	fe 99 ff f9 	brgt	8000bf92 <_vfprintf_r+0xa6e>
8000bfa4:	2d 0b       	sub	r11,-48
8000bfa6:	18 97       	mov	r7,r12
8000bfa8:	04 96       	mov	r6,r2
8000bfaa:	10 fb       	st.b	--r8,r11
8000bfac:	fa ca f9 62 	sub	r10,sp,-1694
8000bfb0:	c0 38       	rjmp	8000bfb6 <_vfprintf_r+0xa92>
8000bfb2:	11 3b       	ld.ub	r11,r8++
8000bfb4:	14 cb       	st.b	r10++,r11
8000bfb6:	12 38       	cp.w	r8,r9
8000bfb8:	cf d3       	brcs	8000bfb2 <_vfprintf_r+0xa8e>
8000bfba:	c0 98       	rjmp	8000bfcc <_vfprintf_r+0xaa8>
8000bfbc:	2d 0b       	sub	r11,-48
8000bfbe:	33 08       	mov	r8,48
8000bfc0:	fb 6b 06 9f 	st.b	sp[1695],r11
8000bfc4:	fb 68 06 9e 	st.b	sp[1694],r8
8000bfc8:	fa ca f9 60 	sub	r10,sp,-1696
8000bfcc:	fa c8 f9 64 	sub	r8,sp,-1692
8000bfd0:	f4 08 01 08 	sub	r8,r10,r8
8000bfd4:	50 e8       	stdsp	sp[0x38],r8
8000bfd6:	10 92       	mov	r2,r8
8000bfd8:	40 6b       	lddsp	r11,sp[0x18]
8000bfda:	16 02       	add	r2,r11
8000bfdc:	58 1b       	cp.w	r11,1
8000bfde:	e0 89 00 05 	brgt	8000bfe8 <_vfprintf_r+0xac4>
8000bfe2:	ed b5 00 00 	bld	r5,0x0
8000bfe6:	c3 51       	brne	8000c050 <_vfprintf_r+0xb2c>
8000bfe8:	2f f2       	sub	r2,-1
8000bfea:	c3 38       	rjmp	8000c050 <_vfprintf_r+0xb2c>
8000bfec:	e0 40 00 66 	cp.w	r0,102
8000bff0:	c1 c1       	brne	8000c028 <_vfprintf_r+0xb04>
8000bff2:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bff6:	58 02       	cp.w	r2,0
8000bff8:	e0 8a 00 0c 	brle	8000c010 <_vfprintf_r+0xaec>
8000bffc:	40 2a       	lddsp	r10,sp[0x8]
8000bffe:	58 0a       	cp.w	r10,0
8000c000:	c0 41       	brne	8000c008 <_vfprintf_r+0xae4>
8000c002:	ed b5 00 00 	bld	r5,0x0
8000c006:	c2 51       	brne	8000c050 <_vfprintf_r+0xb2c>
8000c008:	2f f2       	sub	r2,-1
8000c00a:	40 29       	lddsp	r9,sp[0x8]
8000c00c:	12 02       	add	r2,r9
8000c00e:	c0 b8       	rjmp	8000c024 <_vfprintf_r+0xb00>
8000c010:	40 28       	lddsp	r8,sp[0x8]
8000c012:	58 08       	cp.w	r8,0
8000c014:	c0 61       	brne	8000c020 <_vfprintf_r+0xafc>
8000c016:	ed b5 00 00 	bld	r5,0x0
8000c01a:	c0 30       	breq	8000c020 <_vfprintf_r+0xafc>
8000c01c:	30 12       	mov	r2,1
8000c01e:	c1 98       	rjmp	8000c050 <_vfprintf_r+0xb2c>
8000c020:	40 22       	lddsp	r2,sp[0x8]
8000c022:	2f e2       	sub	r2,-2
8000c024:	36 60       	mov	r0,102
8000c026:	c1 58       	rjmp	8000c050 <_vfprintf_r+0xb2c>
8000c028:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c02c:	40 6e       	lddsp	lr,sp[0x18]
8000c02e:	1c 32       	cp.w	r2,lr
8000c030:	c0 65       	brlt	8000c03c <_vfprintf_r+0xb18>
8000c032:	ed b5 00 00 	bld	r5,0x0
8000c036:	f7 b2 00 ff 	subeq	r2,-1
8000c03a:	c0 a8       	rjmp	8000c04e <_vfprintf_r+0xb2a>
8000c03c:	e4 08 11 02 	rsub	r8,r2,2
8000c040:	40 6c       	lddsp	r12,sp[0x18]
8000c042:	58 02       	cp.w	r2,0
8000c044:	f0 02 17 a0 	movle	r2,r8
8000c048:	f9 b2 09 01 	movgt	r2,1
8000c04c:	18 02       	add	r2,r12
8000c04e:	36 70       	mov	r0,103
8000c050:	40 9b       	lddsp	r11,sp[0x24]
8000c052:	58 0b       	cp.w	r11,0
8000c054:	e0 80 05 94 	breq	8000cb7c <_vfprintf_r+0x1658>
8000c058:	32 d8       	mov	r8,45
8000c05a:	fb 68 06 bb 	st.b	sp[1723],r8
8000c05e:	e0 8f 05 93 	bral	8000cb84 <_vfprintf_r+0x1660>
8000c062:	50 a7       	stdsp	sp[0x28],r7
8000c064:	04 94       	mov	r4,r2
8000c066:	0c 97       	mov	r7,r6
8000c068:	02 92       	mov	r2,r1
8000c06a:	06 96       	mov	r6,r3
8000c06c:	40 41       	lddsp	r1,sp[0x10]
8000c06e:	40 93       	lddsp	r3,sp[0x24]
8000c070:	0e 99       	mov	r9,r7
8000c072:	ed b5 00 05 	bld	r5,0x5
8000c076:	c4 81       	brne	8000c106 <_vfprintf_r+0xbe2>
8000c078:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c07c:	40 3e       	lddsp	lr,sp[0xc]
8000c07e:	58 0e       	cp.w	lr,0
8000c080:	c1 d0       	breq	8000c0ba <_vfprintf_r+0xb96>
8000c082:	10 36       	cp.w	r6,r8
8000c084:	c0 64       	brge	8000c090 <_vfprintf_r+0xb6c>
8000c086:	fa cc f9 44 	sub	r12,sp,-1724
8000c08a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c08e:	c1 d8       	rjmp	8000c0c8 <_vfprintf_r+0xba4>
8000c090:	fa c8 f9 50 	sub	r8,sp,-1712
8000c094:	1a d8       	st.w	--sp,r8
8000c096:	fa c8 fa b8 	sub	r8,sp,-1352
8000c09a:	04 9a       	mov	r10,r2
8000c09c:	1a d8       	st.w	--sp,r8
8000c09e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c0a2:	0c 9b       	mov	r11,r6
8000c0a4:	1a d8       	st.w	--sp,r8
8000c0a6:	08 9c       	mov	r12,r4
8000c0a8:	fa c8 f9 40 	sub	r8,sp,-1728
8000c0ac:	fa c9 ff b4 	sub	r9,sp,-76
8000c0b0:	fe b0 f8 a2 	rcall	8000b1f4 <get_arg>
8000c0b4:	2f dd       	sub	sp,-12
8000c0b6:	78 0a       	ld.w	r10,r12[0x0]
8000c0b8:	c2 08       	rjmp	8000c0f8 <_vfprintf_r+0xbd4>
8000c0ba:	2f f7       	sub	r7,-1
8000c0bc:	10 39       	cp.w	r9,r8
8000c0be:	c0 84       	brge	8000c0ce <_vfprintf_r+0xbaa>
8000c0c0:	fa cb f9 44 	sub	r11,sp,-1724
8000c0c4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c0c8:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c0cc:	c1 68       	rjmp	8000c0f8 <_vfprintf_r+0xbd4>
8000c0ce:	41 09       	lddsp	r9,sp[0x40]
8000c0d0:	59 f8       	cp.w	r8,31
8000c0d2:	e0 89 00 10 	brgt	8000c0f2 <_vfprintf_r+0xbce>
8000c0d6:	f2 ca ff fc 	sub	r10,r9,-4
8000c0da:	51 0a       	stdsp	sp[0x40],r10
8000c0dc:	fa c6 f9 44 	sub	r6,sp,-1724
8000c0e0:	72 0a       	ld.w	r10,r9[0x0]
8000c0e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c0e6:	f3 4a fd 88 	st.w	r9[-632],r10
8000c0ea:	2f f8       	sub	r8,-1
8000c0ec:	fb 48 06 b4 	st.w	sp[1716],r8
8000c0f0:	c0 48       	rjmp	8000c0f8 <_vfprintf_r+0xbd4>
8000c0f2:	72 0a       	ld.w	r10,r9[0x0]
8000c0f4:	2f c9       	sub	r9,-4
8000c0f6:	51 09       	stdsp	sp[0x40],r9
8000c0f8:	40 be       	lddsp	lr,sp[0x2c]
8000c0fa:	1c 98       	mov	r8,lr
8000c0fc:	95 1e       	st.w	r10[0x4],lr
8000c0fe:	bf 58       	asr	r8,0x1f
8000c100:	95 08       	st.w	r10[0x0],r8
8000c102:	fe 9f fa 9f 	bral	8000b640 <_vfprintf_r+0x11c>
8000c106:	ed b5 00 04 	bld	r5,0x4
8000c10a:	c4 80       	breq	8000c19a <_vfprintf_r+0xc76>
8000c10c:	e2 15 00 40 	andl	r5,0x40,COH
8000c110:	c4 50       	breq	8000c19a <_vfprintf_r+0xc76>
8000c112:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c116:	40 3c       	lddsp	r12,sp[0xc]
8000c118:	58 0c       	cp.w	r12,0
8000c11a:	c1 d0       	breq	8000c154 <_vfprintf_r+0xc30>
8000c11c:	10 36       	cp.w	r6,r8
8000c11e:	c0 64       	brge	8000c12a <_vfprintf_r+0xc06>
8000c120:	fa cb f9 44 	sub	r11,sp,-1724
8000c124:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c128:	c1 d8       	rjmp	8000c162 <_vfprintf_r+0xc3e>
8000c12a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c12e:	1a d8       	st.w	--sp,r8
8000c130:	fa c8 fa b8 	sub	r8,sp,-1352
8000c134:	04 9a       	mov	r10,r2
8000c136:	1a d8       	st.w	--sp,r8
8000c138:	fa c8 fb b4 	sub	r8,sp,-1100
8000c13c:	0c 9b       	mov	r11,r6
8000c13e:	1a d8       	st.w	--sp,r8
8000c140:	08 9c       	mov	r12,r4
8000c142:	fa c8 f9 40 	sub	r8,sp,-1728
8000c146:	fa c9 ff b4 	sub	r9,sp,-76
8000c14a:	fe b0 f8 55 	rcall	8000b1f4 <get_arg>
8000c14e:	2f dd       	sub	sp,-12
8000c150:	78 0a       	ld.w	r10,r12[0x0]
8000c152:	c2 08       	rjmp	8000c192 <_vfprintf_r+0xc6e>
8000c154:	2f f7       	sub	r7,-1
8000c156:	10 39       	cp.w	r9,r8
8000c158:	c0 84       	brge	8000c168 <_vfprintf_r+0xc44>
8000c15a:	fa ca f9 44 	sub	r10,sp,-1724
8000c15e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c162:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c166:	c1 68       	rjmp	8000c192 <_vfprintf_r+0xc6e>
8000c168:	41 09       	lddsp	r9,sp[0x40]
8000c16a:	59 f8       	cp.w	r8,31
8000c16c:	e0 89 00 10 	brgt	8000c18c <_vfprintf_r+0xc68>
8000c170:	f2 ca ff fc 	sub	r10,r9,-4
8000c174:	51 0a       	stdsp	sp[0x40],r10
8000c176:	fa c6 f9 44 	sub	r6,sp,-1724
8000c17a:	72 0a       	ld.w	r10,r9[0x0]
8000c17c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c180:	f3 4a fd 88 	st.w	r9[-632],r10
8000c184:	2f f8       	sub	r8,-1
8000c186:	fb 48 06 b4 	st.w	sp[1716],r8
8000c18a:	c0 48       	rjmp	8000c192 <_vfprintf_r+0xc6e>
8000c18c:	72 0a       	ld.w	r10,r9[0x0]
8000c18e:	2f c9       	sub	r9,-4
8000c190:	51 09       	stdsp	sp[0x40],r9
8000c192:	40 be       	lddsp	lr,sp[0x2c]
8000c194:	b4 0e       	st.h	r10[0x0],lr
8000c196:	fe 9f fa 55 	bral	8000b640 <_vfprintf_r+0x11c>
8000c19a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c19e:	40 3c       	lddsp	r12,sp[0xc]
8000c1a0:	58 0c       	cp.w	r12,0
8000c1a2:	c1 d0       	breq	8000c1dc <_vfprintf_r+0xcb8>
8000c1a4:	10 36       	cp.w	r6,r8
8000c1a6:	c0 64       	brge	8000c1b2 <_vfprintf_r+0xc8e>
8000c1a8:	fa cb f9 44 	sub	r11,sp,-1724
8000c1ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c1b0:	c1 d8       	rjmp	8000c1ea <_vfprintf_r+0xcc6>
8000c1b2:	fa c8 f9 50 	sub	r8,sp,-1712
8000c1b6:	1a d8       	st.w	--sp,r8
8000c1b8:	fa c8 fa b8 	sub	r8,sp,-1352
8000c1bc:	04 9a       	mov	r10,r2
8000c1be:	1a d8       	st.w	--sp,r8
8000c1c0:	fa c8 fb b4 	sub	r8,sp,-1100
8000c1c4:	0c 9b       	mov	r11,r6
8000c1c6:	1a d8       	st.w	--sp,r8
8000c1c8:	08 9c       	mov	r12,r4
8000c1ca:	fa c8 f9 40 	sub	r8,sp,-1728
8000c1ce:	fa c9 ff b4 	sub	r9,sp,-76
8000c1d2:	fe b0 f8 11 	rcall	8000b1f4 <get_arg>
8000c1d6:	2f dd       	sub	sp,-12
8000c1d8:	78 0a       	ld.w	r10,r12[0x0]
8000c1da:	c2 08       	rjmp	8000c21a <_vfprintf_r+0xcf6>
8000c1dc:	2f f7       	sub	r7,-1
8000c1de:	10 39       	cp.w	r9,r8
8000c1e0:	c0 84       	brge	8000c1f0 <_vfprintf_r+0xccc>
8000c1e2:	fa ca f9 44 	sub	r10,sp,-1724
8000c1e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c1ea:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c1ee:	c1 68       	rjmp	8000c21a <_vfprintf_r+0xcf6>
8000c1f0:	41 09       	lddsp	r9,sp[0x40]
8000c1f2:	59 f8       	cp.w	r8,31
8000c1f4:	e0 89 00 10 	brgt	8000c214 <_vfprintf_r+0xcf0>
8000c1f8:	f2 ca ff fc 	sub	r10,r9,-4
8000c1fc:	51 0a       	stdsp	sp[0x40],r10
8000c1fe:	fa c6 f9 44 	sub	r6,sp,-1724
8000c202:	72 0a       	ld.w	r10,r9[0x0]
8000c204:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c208:	f3 4a fd 88 	st.w	r9[-632],r10
8000c20c:	2f f8       	sub	r8,-1
8000c20e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c212:	c0 48       	rjmp	8000c21a <_vfprintf_r+0xcf6>
8000c214:	72 0a       	ld.w	r10,r9[0x0]
8000c216:	2f c9       	sub	r9,-4
8000c218:	51 09       	stdsp	sp[0x40],r9
8000c21a:	40 be       	lddsp	lr,sp[0x2c]
8000c21c:	95 0e       	st.w	r10[0x0],lr
8000c21e:	fe 9f fa 11 	bral	8000b640 <_vfprintf_r+0x11c>
8000c222:	50 a7       	stdsp	sp[0x28],r7
8000c224:	50 80       	stdsp	sp[0x20],r0
8000c226:	0c 97       	mov	r7,r6
8000c228:	04 94       	mov	r4,r2
8000c22a:	06 96       	mov	r6,r3
8000c22c:	02 92       	mov	r2,r1
8000c22e:	40 93       	lddsp	r3,sp[0x24]
8000c230:	10 90       	mov	r0,r8
8000c232:	40 41       	lddsp	r1,sp[0x10]
8000c234:	a5 a5       	sbr	r5,0x4
8000c236:	c0 a8       	rjmp	8000c24a <_vfprintf_r+0xd26>
8000c238:	50 a7       	stdsp	sp[0x28],r7
8000c23a:	50 80       	stdsp	sp[0x20],r0
8000c23c:	0c 97       	mov	r7,r6
8000c23e:	04 94       	mov	r4,r2
8000c240:	06 96       	mov	r6,r3
8000c242:	02 92       	mov	r2,r1
8000c244:	40 93       	lddsp	r3,sp[0x24]
8000c246:	10 90       	mov	r0,r8
8000c248:	40 41       	lddsp	r1,sp[0x10]
8000c24a:	ed b5 00 05 	bld	r5,0x5
8000c24e:	c5 d1       	brne	8000c308 <_vfprintf_r+0xde4>
8000c250:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c254:	40 3c       	lddsp	r12,sp[0xc]
8000c256:	58 0c       	cp.w	r12,0
8000c258:	c2 60       	breq	8000c2a4 <_vfprintf_r+0xd80>
8000c25a:	10 36       	cp.w	r6,r8
8000c25c:	c0 a4       	brge	8000c270 <_vfprintf_r+0xd4c>
8000c25e:	fa cb f9 44 	sub	r11,sp,-1724
8000c262:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c266:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c26a:	fa e9 00 00 	st.d	sp[0],r8
8000c26e:	c1 88       	rjmp	8000c29e <_vfprintf_r+0xd7a>
8000c270:	fa c8 f9 50 	sub	r8,sp,-1712
8000c274:	1a d8       	st.w	--sp,r8
8000c276:	fa c8 fa b8 	sub	r8,sp,-1352
8000c27a:	04 9a       	mov	r10,r2
8000c27c:	1a d8       	st.w	--sp,r8
8000c27e:	0c 9b       	mov	r11,r6
8000c280:	fa c8 fb b4 	sub	r8,sp,-1100
8000c284:	08 9c       	mov	r12,r4
8000c286:	1a d8       	st.w	--sp,r8
8000c288:	fa c8 f9 40 	sub	r8,sp,-1728
8000c28c:	fa c9 ff b4 	sub	r9,sp,-76
8000c290:	fe b0 f7 b2 	rcall	8000b1f4 <get_arg>
8000c294:	2f dd       	sub	sp,-12
8000c296:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c29a:	fa eb 00 00 	st.d	sp[0],r10
8000c29e:	30 08       	mov	r8,0
8000c2a0:	e0 8f 03 de 	bral	8000ca5c <_vfprintf_r+0x1538>
8000c2a4:	ee ca ff ff 	sub	r10,r7,-1
8000c2a8:	10 37       	cp.w	r7,r8
8000c2aa:	c0 b4       	brge	8000c2c0 <_vfprintf_r+0xd9c>
8000c2ac:	fa c9 f9 44 	sub	r9,sp,-1724
8000c2b0:	14 97       	mov	r7,r10
8000c2b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c2b6:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c2ba:	fa eb 00 00 	st.d	sp[0],r10
8000c2be:	c1 88       	rjmp	8000c2ee <_vfprintf_r+0xdca>
8000c2c0:	41 09       	lddsp	r9,sp[0x40]
8000c2c2:	59 f8       	cp.w	r8,31
8000c2c4:	e0 89 00 18 	brgt	8000c2f4 <_vfprintf_r+0xdd0>
8000c2c8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c2cc:	f2 cb ff f8 	sub	r11,r9,-8
8000c2d0:	fa e7 00 00 	st.d	sp[0],r6
8000c2d4:	51 0b       	stdsp	sp[0x40],r11
8000c2d6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c2da:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c2de:	fa e6 00 00 	ld.d	r6,sp[0]
8000c2e2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c2e6:	2f f8       	sub	r8,-1
8000c2e8:	14 97       	mov	r7,r10
8000c2ea:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2ee:	40 38       	lddsp	r8,sp[0xc]
8000c2f0:	e0 8f 03 b6 	bral	8000ca5c <_vfprintf_r+0x1538>
8000c2f4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c2f8:	40 38       	lddsp	r8,sp[0xc]
8000c2fa:	fa e7 00 00 	st.d	sp[0],r6
8000c2fe:	2f 89       	sub	r9,-8
8000c300:	14 97       	mov	r7,r10
8000c302:	51 09       	stdsp	sp[0x40],r9
8000c304:	e0 8f 03 ac 	bral	8000ca5c <_vfprintf_r+0x1538>
8000c308:	ed b5 00 04 	bld	r5,0x4
8000c30c:	c1 61       	brne	8000c338 <_vfprintf_r+0xe14>
8000c30e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c312:	40 3e       	lddsp	lr,sp[0xc]
8000c314:	58 0e       	cp.w	lr,0
8000c316:	c0 80       	breq	8000c326 <_vfprintf_r+0xe02>
8000c318:	10 36       	cp.w	r6,r8
8000c31a:	c6 74       	brge	8000c3e8 <_vfprintf_r+0xec4>
8000c31c:	fa cc f9 44 	sub	r12,sp,-1724
8000c320:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c324:	c8 08       	rjmp	8000c424 <_vfprintf_r+0xf00>
8000c326:	ee ca ff ff 	sub	r10,r7,-1
8000c32a:	10 37       	cp.w	r7,r8
8000c32c:	c7 f4       	brge	8000c42a <_vfprintf_r+0xf06>
8000c32e:	fa cb f9 44 	sub	r11,sp,-1724
8000c332:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c336:	c7 68       	rjmp	8000c422 <_vfprintf_r+0xefe>
8000c338:	ed b5 00 06 	bld	r5,0x6
8000c33c:	c4 a1       	brne	8000c3d0 <_vfprintf_r+0xeac>
8000c33e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c342:	40 3c       	lddsp	r12,sp[0xc]
8000c344:	58 0c       	cp.w	r12,0
8000c346:	c1 d0       	breq	8000c380 <_vfprintf_r+0xe5c>
8000c348:	10 36       	cp.w	r6,r8
8000c34a:	c0 64       	brge	8000c356 <_vfprintf_r+0xe32>
8000c34c:	fa cb f9 44 	sub	r11,sp,-1724
8000c350:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c354:	c1 f8       	rjmp	8000c392 <_vfprintf_r+0xe6e>
8000c356:	fa c8 f9 50 	sub	r8,sp,-1712
8000c35a:	1a d8       	st.w	--sp,r8
8000c35c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c360:	1a d8       	st.w	--sp,r8
8000c362:	fa c8 fb b4 	sub	r8,sp,-1100
8000c366:	1a d8       	st.w	--sp,r8
8000c368:	fa c8 f9 40 	sub	r8,sp,-1728
8000c36c:	fa c9 ff b4 	sub	r9,sp,-76
8000c370:	04 9a       	mov	r10,r2
8000c372:	0c 9b       	mov	r11,r6
8000c374:	08 9c       	mov	r12,r4
8000c376:	fe b0 f7 3f 	rcall	8000b1f4 <get_arg>
8000c37a:	2f dd       	sub	sp,-12
8000c37c:	98 18       	ld.sh	r8,r12[0x2]
8000c37e:	c2 68       	rjmp	8000c3ca <_vfprintf_r+0xea6>
8000c380:	ee ca ff ff 	sub	r10,r7,-1
8000c384:	10 37       	cp.w	r7,r8
8000c386:	c0 94       	brge	8000c398 <_vfprintf_r+0xe74>
8000c388:	fa c9 f9 44 	sub	r9,sp,-1724
8000c38c:	14 97       	mov	r7,r10
8000c38e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c392:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c396:	c1 a8       	rjmp	8000c3ca <_vfprintf_r+0xea6>
8000c398:	41 09       	lddsp	r9,sp[0x40]
8000c39a:	59 f8       	cp.w	r8,31
8000c39c:	e0 89 00 13 	brgt	8000c3c2 <_vfprintf_r+0xe9e>
8000c3a0:	f2 cb ff fc 	sub	r11,r9,-4
8000c3a4:	51 0b       	stdsp	sp[0x40],r11
8000c3a6:	72 09       	ld.w	r9,r9[0x0]
8000c3a8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c3ac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c3b0:	2f f8       	sub	r8,-1
8000c3b2:	f7 49 fd 88 	st.w	r11[-632],r9
8000c3b6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c3ba:	14 97       	mov	r7,r10
8000c3bc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c3c0:	c0 58       	rjmp	8000c3ca <_vfprintf_r+0xea6>
8000c3c2:	92 18       	ld.sh	r8,r9[0x2]
8000c3c4:	14 97       	mov	r7,r10
8000c3c6:	2f c9       	sub	r9,-4
8000c3c8:	51 09       	stdsp	sp[0x40],r9
8000c3ca:	5c 78       	castu.h	r8
8000c3cc:	50 18       	stdsp	sp[0x4],r8
8000c3ce:	c4 68       	rjmp	8000c45a <_vfprintf_r+0xf36>
8000c3d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c3d4:	40 3c       	lddsp	r12,sp[0xc]
8000c3d6:	58 0c       	cp.w	r12,0
8000c3d8:	c1 d0       	breq	8000c412 <_vfprintf_r+0xeee>
8000c3da:	10 36       	cp.w	r6,r8
8000c3dc:	c0 64       	brge	8000c3e8 <_vfprintf_r+0xec4>
8000c3de:	fa cb f9 44 	sub	r11,sp,-1724
8000c3e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c3e6:	c1 f8       	rjmp	8000c424 <_vfprintf_r+0xf00>
8000c3e8:	fa c8 f9 50 	sub	r8,sp,-1712
8000c3ec:	1a d8       	st.w	--sp,r8
8000c3ee:	fa c8 fa b8 	sub	r8,sp,-1352
8000c3f2:	0c 9b       	mov	r11,r6
8000c3f4:	1a d8       	st.w	--sp,r8
8000c3f6:	fa c8 fb b4 	sub	r8,sp,-1100
8000c3fa:	04 9a       	mov	r10,r2
8000c3fc:	1a d8       	st.w	--sp,r8
8000c3fe:	08 9c       	mov	r12,r4
8000c400:	fa c8 f9 40 	sub	r8,sp,-1728
8000c404:	fa c9 ff b4 	sub	r9,sp,-76
8000c408:	fe b0 f6 f6 	rcall	8000b1f4 <get_arg>
8000c40c:	2f dd       	sub	sp,-12
8000c40e:	78 0b       	ld.w	r11,r12[0x0]
8000c410:	c2 48       	rjmp	8000c458 <_vfprintf_r+0xf34>
8000c412:	ee ca ff ff 	sub	r10,r7,-1
8000c416:	10 37       	cp.w	r7,r8
8000c418:	c0 94       	brge	8000c42a <_vfprintf_r+0xf06>
8000c41a:	fa c9 f9 44 	sub	r9,sp,-1724
8000c41e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c422:	14 97       	mov	r7,r10
8000c424:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c428:	c1 88       	rjmp	8000c458 <_vfprintf_r+0xf34>
8000c42a:	41 09       	lddsp	r9,sp[0x40]
8000c42c:	59 f8       	cp.w	r8,31
8000c42e:	e0 89 00 11 	brgt	8000c450 <_vfprintf_r+0xf2c>
8000c432:	f2 cb ff fc 	sub	r11,r9,-4
8000c436:	51 0b       	stdsp	sp[0x40],r11
8000c438:	fa c6 f9 44 	sub	r6,sp,-1724
8000c43c:	72 0b       	ld.w	r11,r9[0x0]
8000c43e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c442:	f3 4b fd 88 	st.w	r9[-632],r11
8000c446:	2f f8       	sub	r8,-1
8000c448:	14 97       	mov	r7,r10
8000c44a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c44e:	c0 58       	rjmp	8000c458 <_vfprintf_r+0xf34>
8000c450:	72 0b       	ld.w	r11,r9[0x0]
8000c452:	14 97       	mov	r7,r10
8000c454:	2f c9       	sub	r9,-4
8000c456:	51 09       	stdsp	sp[0x40],r9
8000c458:	50 1b       	stdsp	sp[0x4],r11
8000c45a:	30 0e       	mov	lr,0
8000c45c:	50 0e       	stdsp	sp[0x0],lr
8000c45e:	1c 98       	mov	r8,lr
8000c460:	e0 8f 02 fe 	bral	8000ca5c <_vfprintf_r+0x1538>
8000c464:	50 a7       	stdsp	sp[0x28],r7
8000c466:	50 80       	stdsp	sp[0x20],r0
8000c468:	0c 97       	mov	r7,r6
8000c46a:	04 94       	mov	r4,r2
8000c46c:	06 96       	mov	r6,r3
8000c46e:	02 92       	mov	r2,r1
8000c470:	40 93       	lddsp	r3,sp[0x24]
8000c472:	40 41       	lddsp	r1,sp[0x10]
8000c474:	0e 99       	mov	r9,r7
8000c476:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c47a:	40 3c       	lddsp	r12,sp[0xc]
8000c47c:	58 0c       	cp.w	r12,0
8000c47e:	c1 d0       	breq	8000c4b8 <_vfprintf_r+0xf94>
8000c480:	10 36       	cp.w	r6,r8
8000c482:	c0 64       	brge	8000c48e <_vfprintf_r+0xf6a>
8000c484:	fa cb f9 44 	sub	r11,sp,-1724
8000c488:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c48c:	c1 d8       	rjmp	8000c4c6 <_vfprintf_r+0xfa2>
8000c48e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c492:	1a d8       	st.w	--sp,r8
8000c494:	fa c8 fa b8 	sub	r8,sp,-1352
8000c498:	1a d8       	st.w	--sp,r8
8000c49a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c49e:	1a d8       	st.w	--sp,r8
8000c4a0:	fa c9 ff b4 	sub	r9,sp,-76
8000c4a4:	fa c8 f9 40 	sub	r8,sp,-1728
8000c4a8:	04 9a       	mov	r10,r2
8000c4aa:	0c 9b       	mov	r11,r6
8000c4ac:	08 9c       	mov	r12,r4
8000c4ae:	fe b0 f6 a3 	rcall	8000b1f4 <get_arg>
8000c4b2:	2f dd       	sub	sp,-12
8000c4b4:	78 09       	ld.w	r9,r12[0x0]
8000c4b6:	c2 18       	rjmp	8000c4f8 <_vfprintf_r+0xfd4>
8000c4b8:	2f f7       	sub	r7,-1
8000c4ba:	10 39       	cp.w	r9,r8
8000c4bc:	c0 84       	brge	8000c4cc <_vfprintf_r+0xfa8>
8000c4be:	fa ca f9 44 	sub	r10,sp,-1724
8000c4c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c4c6:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c4ca:	c1 78       	rjmp	8000c4f8 <_vfprintf_r+0xfd4>
8000c4cc:	41 09       	lddsp	r9,sp[0x40]
8000c4ce:	59 f8       	cp.w	r8,31
8000c4d0:	e0 89 00 10 	brgt	8000c4f0 <_vfprintf_r+0xfcc>
8000c4d4:	f2 ca ff fc 	sub	r10,r9,-4
8000c4d8:	51 0a       	stdsp	sp[0x40],r10
8000c4da:	fa c6 f9 44 	sub	r6,sp,-1724
8000c4de:	72 09       	ld.w	r9,r9[0x0]
8000c4e0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c4e4:	f5 49 fd 88 	st.w	r10[-632],r9
8000c4e8:	2f f8       	sub	r8,-1
8000c4ea:	fb 48 06 b4 	st.w	sp[1716],r8
8000c4ee:	c0 58       	rjmp	8000c4f8 <_vfprintf_r+0xfd4>
8000c4f0:	f2 c8 ff fc 	sub	r8,r9,-4
8000c4f4:	51 08       	stdsp	sp[0x40],r8
8000c4f6:	72 09       	ld.w	r9,r9[0x0]
8000c4f8:	33 08       	mov	r8,48
8000c4fa:	fb 68 06 b8 	st.b	sp[1720],r8
8000c4fe:	37 88       	mov	r8,120
8000c500:	30 0e       	mov	lr,0
8000c502:	fb 68 06 b9 	st.b	sp[1721],r8
8000c506:	fe cc ba 56 	sub	r12,pc,-17834
8000c50a:	50 19       	stdsp	sp[0x4],r9
8000c50c:	a1 b5       	sbr	r5,0x1
8000c50e:	50 0e       	stdsp	sp[0x0],lr
8000c510:	50 dc       	stdsp	sp[0x34],r12
8000c512:	30 28       	mov	r8,2
8000c514:	37 80       	mov	r0,120
8000c516:	e0 8f 02 a3 	bral	8000ca5c <_vfprintf_r+0x1538>
8000c51a:	50 a7       	stdsp	sp[0x28],r7
8000c51c:	50 80       	stdsp	sp[0x20],r0
8000c51e:	10 90       	mov	r0,r8
8000c520:	30 08       	mov	r8,0
8000c522:	fb 68 06 bb 	st.b	sp[1723],r8
8000c526:	0c 97       	mov	r7,r6
8000c528:	04 94       	mov	r4,r2
8000c52a:	06 96       	mov	r6,r3
8000c52c:	02 92       	mov	r2,r1
8000c52e:	40 93       	lddsp	r3,sp[0x24]
8000c530:	40 41       	lddsp	r1,sp[0x10]
8000c532:	0e 99       	mov	r9,r7
8000c534:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c538:	40 3b       	lddsp	r11,sp[0xc]
8000c53a:	58 0b       	cp.w	r11,0
8000c53c:	c1 d0       	breq	8000c576 <_vfprintf_r+0x1052>
8000c53e:	10 36       	cp.w	r6,r8
8000c540:	c0 64       	brge	8000c54c <_vfprintf_r+0x1028>
8000c542:	fa ca f9 44 	sub	r10,sp,-1724
8000c546:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c54a:	c1 d8       	rjmp	8000c584 <_vfprintf_r+0x1060>
8000c54c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c550:	1a d8       	st.w	--sp,r8
8000c552:	fa c8 fa b8 	sub	r8,sp,-1352
8000c556:	1a d8       	st.w	--sp,r8
8000c558:	fa c8 fb b4 	sub	r8,sp,-1100
8000c55c:	0c 9b       	mov	r11,r6
8000c55e:	1a d8       	st.w	--sp,r8
8000c560:	04 9a       	mov	r10,r2
8000c562:	fa c8 f9 40 	sub	r8,sp,-1728
8000c566:	fa c9 ff b4 	sub	r9,sp,-76
8000c56a:	08 9c       	mov	r12,r4
8000c56c:	fe b0 f6 44 	rcall	8000b1f4 <get_arg>
8000c570:	2f dd       	sub	sp,-12
8000c572:	78 06       	ld.w	r6,r12[0x0]
8000c574:	c2 08       	rjmp	8000c5b4 <_vfprintf_r+0x1090>
8000c576:	2f f7       	sub	r7,-1
8000c578:	10 39       	cp.w	r9,r8
8000c57a:	c0 84       	brge	8000c58a <_vfprintf_r+0x1066>
8000c57c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c580:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c584:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c588:	c1 68       	rjmp	8000c5b4 <_vfprintf_r+0x1090>
8000c58a:	41 09       	lddsp	r9,sp[0x40]
8000c58c:	59 f8       	cp.w	r8,31
8000c58e:	e0 89 00 10 	brgt	8000c5ae <_vfprintf_r+0x108a>
8000c592:	f2 ca ff fc 	sub	r10,r9,-4
8000c596:	51 0a       	stdsp	sp[0x40],r10
8000c598:	72 06       	ld.w	r6,r9[0x0]
8000c59a:	fa ce f9 44 	sub	lr,sp,-1724
8000c59e:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c5a2:	f3 46 fd 88 	st.w	r9[-632],r6
8000c5a6:	2f f8       	sub	r8,-1
8000c5a8:	fb 48 06 b4 	st.w	sp[1716],r8
8000c5ac:	c0 48       	rjmp	8000c5b4 <_vfprintf_r+0x1090>
8000c5ae:	72 06       	ld.w	r6,r9[0x0]
8000c5b0:	2f c9       	sub	r9,-4
8000c5b2:	51 09       	stdsp	sp[0x40],r9
8000c5b4:	40 2c       	lddsp	r12,sp[0x8]
8000c5b6:	58 0c       	cp.w	r12,0
8000c5b8:	c1 05       	brlt	8000c5d8 <_vfprintf_r+0x10b4>
8000c5ba:	18 9a       	mov	r10,r12
8000c5bc:	30 0b       	mov	r11,0
8000c5be:	0c 9c       	mov	r12,r6
8000c5c0:	e0 a0 12 38 	rcall	8000ea30 <memchr>
8000c5c4:	e0 80 02 df 	breq	8000cb82 <_vfprintf_r+0x165e>
8000c5c8:	f8 06 01 02 	sub	r2,r12,r6
8000c5cc:	40 2b       	lddsp	r11,sp[0x8]
8000c5ce:	16 32       	cp.w	r2,r11
8000c5d0:	e0 89 02 d9 	brgt	8000cb82 <_vfprintf_r+0x165e>
8000c5d4:	e0 8f 02 d4 	bral	8000cb7c <_vfprintf_r+0x1658>
8000c5d8:	30 0a       	mov	r10,0
8000c5da:	0c 9c       	mov	r12,r6
8000c5dc:	50 2a       	stdsp	sp[0x8],r10
8000c5de:	fe b0 f5 85 	rcall	8000b0e8 <strlen>
8000c5e2:	18 92       	mov	r2,r12
8000c5e4:	e0 8f 02 d2 	bral	8000cb88 <_vfprintf_r+0x1664>
8000c5e8:	50 a7       	stdsp	sp[0x28],r7
8000c5ea:	50 80       	stdsp	sp[0x20],r0
8000c5ec:	0c 97       	mov	r7,r6
8000c5ee:	04 94       	mov	r4,r2
8000c5f0:	06 96       	mov	r6,r3
8000c5f2:	02 92       	mov	r2,r1
8000c5f4:	40 93       	lddsp	r3,sp[0x24]
8000c5f6:	10 90       	mov	r0,r8
8000c5f8:	40 41       	lddsp	r1,sp[0x10]
8000c5fa:	a5 a5       	sbr	r5,0x4
8000c5fc:	c0 a8       	rjmp	8000c610 <_vfprintf_r+0x10ec>
8000c5fe:	50 a7       	stdsp	sp[0x28],r7
8000c600:	50 80       	stdsp	sp[0x20],r0
8000c602:	0c 97       	mov	r7,r6
8000c604:	04 94       	mov	r4,r2
8000c606:	06 96       	mov	r6,r3
8000c608:	02 92       	mov	r2,r1
8000c60a:	40 93       	lddsp	r3,sp[0x24]
8000c60c:	10 90       	mov	r0,r8
8000c60e:	40 41       	lddsp	r1,sp[0x10]
8000c610:	ed b5 00 05 	bld	r5,0x5
8000c614:	c5 61       	brne	8000c6c0 <_vfprintf_r+0x119c>
8000c616:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c61a:	40 39       	lddsp	r9,sp[0xc]
8000c61c:	58 09       	cp.w	r9,0
8000c61e:	c2 10       	breq	8000c660 <_vfprintf_r+0x113c>
8000c620:	10 36       	cp.w	r6,r8
8000c622:	c0 74       	brge	8000c630 <_vfprintf_r+0x110c>
8000c624:	fa c8 f9 44 	sub	r8,sp,-1724
8000c628:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c62c:	c2 38       	rjmp	8000c672 <_vfprintf_r+0x114e>
8000c62e:	d7 03       	nop
8000c630:	fa c8 f9 50 	sub	r8,sp,-1712
8000c634:	1a d8       	st.w	--sp,r8
8000c636:	fa c8 fa b8 	sub	r8,sp,-1352
8000c63a:	1a d8       	st.w	--sp,r8
8000c63c:	fa c8 fb b4 	sub	r8,sp,-1100
8000c640:	1a d8       	st.w	--sp,r8
8000c642:	fa c8 f9 40 	sub	r8,sp,-1728
8000c646:	fa c9 ff b4 	sub	r9,sp,-76
8000c64a:	04 9a       	mov	r10,r2
8000c64c:	0c 9b       	mov	r11,r6
8000c64e:	08 9c       	mov	r12,r4
8000c650:	fe b0 f5 d2 	rcall	8000b1f4 <get_arg>
8000c654:	2f dd       	sub	sp,-12
8000c656:	f8 e8 00 00 	ld.d	r8,r12[0]
8000c65a:	fa e9 00 00 	st.d	sp[0],r8
8000c65e:	c2 e8       	rjmp	8000c6ba <_vfprintf_r+0x1196>
8000c660:	ee ca ff ff 	sub	r10,r7,-1
8000c664:	10 37       	cp.w	r7,r8
8000c666:	c0 b4       	brge	8000c67c <_vfprintf_r+0x1158>
8000c668:	fa c8 f9 44 	sub	r8,sp,-1724
8000c66c:	14 97       	mov	r7,r10
8000c66e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c672:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c676:	fa eb 00 00 	st.d	sp[0],r10
8000c67a:	c2 08       	rjmp	8000c6ba <_vfprintf_r+0x1196>
8000c67c:	41 09       	lddsp	r9,sp[0x40]
8000c67e:	59 f8       	cp.w	r8,31
8000c680:	e0 89 00 16 	brgt	8000c6ac <_vfprintf_r+0x1188>
8000c684:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c688:	f2 cb ff f8 	sub	r11,r9,-8
8000c68c:	fa e7 00 00 	st.d	sp[0],r6
8000c690:	51 0b       	stdsp	sp[0x40],r11
8000c692:	fa c6 f9 44 	sub	r6,sp,-1724
8000c696:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c69a:	fa e6 00 00 	ld.d	r6,sp[0]
8000c69e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c6a2:	2f f8       	sub	r8,-1
8000c6a4:	14 97       	mov	r7,r10
8000c6a6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c6aa:	c0 88       	rjmp	8000c6ba <_vfprintf_r+0x1196>
8000c6ac:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c6b0:	2f 89       	sub	r9,-8
8000c6b2:	fa e7 00 00 	st.d	sp[0],r6
8000c6b6:	51 09       	stdsp	sp[0x40],r9
8000c6b8:	14 97       	mov	r7,r10
8000c6ba:	30 18       	mov	r8,1
8000c6bc:	e0 8f 01 d0 	bral	8000ca5c <_vfprintf_r+0x1538>
8000c6c0:	ed b5 00 04 	bld	r5,0x4
8000c6c4:	c1 61       	brne	8000c6f0 <_vfprintf_r+0x11cc>
8000c6c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c6ca:	40 3e       	lddsp	lr,sp[0xc]
8000c6cc:	58 0e       	cp.w	lr,0
8000c6ce:	c0 80       	breq	8000c6de <_vfprintf_r+0x11ba>
8000c6d0:	10 36       	cp.w	r6,r8
8000c6d2:	c6 74       	brge	8000c7a0 <_vfprintf_r+0x127c>
8000c6d4:	fa cc f9 44 	sub	r12,sp,-1724
8000c6d8:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c6dc:	c8 08       	rjmp	8000c7dc <_vfprintf_r+0x12b8>
8000c6de:	ee ca ff ff 	sub	r10,r7,-1
8000c6e2:	10 37       	cp.w	r7,r8
8000c6e4:	c7 f4       	brge	8000c7e2 <_vfprintf_r+0x12be>
8000c6e6:	fa cb f9 44 	sub	r11,sp,-1724
8000c6ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c6ee:	c7 68       	rjmp	8000c7da <_vfprintf_r+0x12b6>
8000c6f0:	ed b5 00 06 	bld	r5,0x6
8000c6f4:	c4 a1       	brne	8000c788 <_vfprintf_r+0x1264>
8000c6f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c6fa:	40 3c       	lddsp	r12,sp[0xc]
8000c6fc:	58 0c       	cp.w	r12,0
8000c6fe:	c1 d0       	breq	8000c738 <_vfprintf_r+0x1214>
8000c700:	10 36       	cp.w	r6,r8
8000c702:	c0 64       	brge	8000c70e <_vfprintf_r+0x11ea>
8000c704:	fa cb f9 44 	sub	r11,sp,-1724
8000c708:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c70c:	c1 f8       	rjmp	8000c74a <_vfprintf_r+0x1226>
8000c70e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c712:	1a d8       	st.w	--sp,r8
8000c714:	fa c8 fa b8 	sub	r8,sp,-1352
8000c718:	1a d8       	st.w	--sp,r8
8000c71a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c71e:	1a d8       	st.w	--sp,r8
8000c720:	fa c8 f9 40 	sub	r8,sp,-1728
8000c724:	fa c9 ff b4 	sub	r9,sp,-76
8000c728:	04 9a       	mov	r10,r2
8000c72a:	0c 9b       	mov	r11,r6
8000c72c:	08 9c       	mov	r12,r4
8000c72e:	fe b0 f5 63 	rcall	8000b1f4 <get_arg>
8000c732:	2f dd       	sub	sp,-12
8000c734:	98 18       	ld.sh	r8,r12[0x2]
8000c736:	c2 68       	rjmp	8000c782 <_vfprintf_r+0x125e>
8000c738:	ee ca ff ff 	sub	r10,r7,-1
8000c73c:	10 37       	cp.w	r7,r8
8000c73e:	c0 94       	brge	8000c750 <_vfprintf_r+0x122c>
8000c740:	fa c9 f9 44 	sub	r9,sp,-1724
8000c744:	14 97       	mov	r7,r10
8000c746:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c74a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c74e:	c1 a8       	rjmp	8000c782 <_vfprintf_r+0x125e>
8000c750:	41 09       	lddsp	r9,sp[0x40]
8000c752:	59 f8       	cp.w	r8,31
8000c754:	e0 89 00 13 	brgt	8000c77a <_vfprintf_r+0x1256>
8000c758:	f2 cb ff fc 	sub	r11,r9,-4
8000c75c:	51 0b       	stdsp	sp[0x40],r11
8000c75e:	72 09       	ld.w	r9,r9[0x0]
8000c760:	fa c6 f9 44 	sub	r6,sp,-1724
8000c764:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c768:	2f f8       	sub	r8,-1
8000c76a:	f7 49 fd 88 	st.w	r11[-632],r9
8000c76e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c772:	14 97       	mov	r7,r10
8000c774:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c778:	c0 58       	rjmp	8000c782 <_vfprintf_r+0x125e>
8000c77a:	92 18       	ld.sh	r8,r9[0x2]
8000c77c:	14 97       	mov	r7,r10
8000c77e:	2f c9       	sub	r9,-4
8000c780:	51 09       	stdsp	sp[0x40],r9
8000c782:	5c 78       	castu.h	r8
8000c784:	50 18       	stdsp	sp[0x4],r8
8000c786:	c4 68       	rjmp	8000c812 <_vfprintf_r+0x12ee>
8000c788:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c78c:	40 3c       	lddsp	r12,sp[0xc]
8000c78e:	58 0c       	cp.w	r12,0
8000c790:	c1 d0       	breq	8000c7ca <_vfprintf_r+0x12a6>
8000c792:	10 36       	cp.w	r6,r8
8000c794:	c0 64       	brge	8000c7a0 <_vfprintf_r+0x127c>
8000c796:	fa cb f9 44 	sub	r11,sp,-1724
8000c79a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c79e:	c1 f8       	rjmp	8000c7dc <_vfprintf_r+0x12b8>
8000c7a0:	fa c8 f9 50 	sub	r8,sp,-1712
8000c7a4:	1a d8       	st.w	--sp,r8
8000c7a6:	fa c8 fa b8 	sub	r8,sp,-1352
8000c7aa:	0c 9b       	mov	r11,r6
8000c7ac:	1a d8       	st.w	--sp,r8
8000c7ae:	fa c8 fb b4 	sub	r8,sp,-1100
8000c7b2:	04 9a       	mov	r10,r2
8000c7b4:	1a d8       	st.w	--sp,r8
8000c7b6:	08 9c       	mov	r12,r4
8000c7b8:	fa c8 f9 40 	sub	r8,sp,-1728
8000c7bc:	fa c9 ff b4 	sub	r9,sp,-76
8000c7c0:	fe b0 f5 1a 	rcall	8000b1f4 <get_arg>
8000c7c4:	2f dd       	sub	sp,-12
8000c7c6:	78 0b       	ld.w	r11,r12[0x0]
8000c7c8:	c2 48       	rjmp	8000c810 <_vfprintf_r+0x12ec>
8000c7ca:	ee ca ff ff 	sub	r10,r7,-1
8000c7ce:	10 37       	cp.w	r7,r8
8000c7d0:	c0 94       	brge	8000c7e2 <_vfprintf_r+0x12be>
8000c7d2:	fa c9 f9 44 	sub	r9,sp,-1724
8000c7d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c7da:	14 97       	mov	r7,r10
8000c7dc:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c7e0:	c1 88       	rjmp	8000c810 <_vfprintf_r+0x12ec>
8000c7e2:	41 09       	lddsp	r9,sp[0x40]
8000c7e4:	59 f8       	cp.w	r8,31
8000c7e6:	e0 89 00 11 	brgt	8000c808 <_vfprintf_r+0x12e4>
8000c7ea:	f2 cb ff fc 	sub	r11,r9,-4
8000c7ee:	51 0b       	stdsp	sp[0x40],r11
8000c7f0:	fa c6 f9 44 	sub	r6,sp,-1724
8000c7f4:	72 0b       	ld.w	r11,r9[0x0]
8000c7f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c7fa:	f3 4b fd 88 	st.w	r9[-632],r11
8000c7fe:	2f f8       	sub	r8,-1
8000c800:	14 97       	mov	r7,r10
8000c802:	fb 48 06 b4 	st.w	sp[1716],r8
8000c806:	c0 58       	rjmp	8000c810 <_vfprintf_r+0x12ec>
8000c808:	72 0b       	ld.w	r11,r9[0x0]
8000c80a:	14 97       	mov	r7,r10
8000c80c:	2f c9       	sub	r9,-4
8000c80e:	51 09       	stdsp	sp[0x40],r9
8000c810:	50 1b       	stdsp	sp[0x4],r11
8000c812:	30 0e       	mov	lr,0
8000c814:	30 18       	mov	r8,1
8000c816:	50 0e       	stdsp	sp[0x0],lr
8000c818:	c2 29       	rjmp	8000ca5c <_vfprintf_r+0x1538>
8000c81a:	50 a7       	stdsp	sp[0x28],r7
8000c81c:	50 80       	stdsp	sp[0x20],r0
8000c81e:	0c 97       	mov	r7,r6
8000c820:	04 94       	mov	r4,r2
8000c822:	06 96       	mov	r6,r3
8000c824:	02 92       	mov	r2,r1
8000c826:	fe cc bd 76 	sub	r12,pc,-17034
8000c82a:	40 93       	lddsp	r3,sp[0x24]
8000c82c:	10 90       	mov	r0,r8
8000c82e:	40 41       	lddsp	r1,sp[0x10]
8000c830:	50 dc       	stdsp	sp[0x34],r12
8000c832:	ed b5 00 05 	bld	r5,0x5
8000c836:	c5 51       	brne	8000c8e0 <_vfprintf_r+0x13bc>
8000c838:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c83c:	40 3b       	lddsp	r11,sp[0xc]
8000c83e:	58 0b       	cp.w	r11,0
8000c840:	c2 20       	breq	8000c884 <_vfprintf_r+0x1360>
8000c842:	10 36       	cp.w	r6,r8
8000c844:	c0 a4       	brge	8000c858 <_vfprintf_r+0x1334>
8000c846:	fa ca f9 44 	sub	r10,sp,-1724
8000c84a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c84e:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c852:	fa e9 00 00 	st.d	sp[0],r8
8000c856:	cf 28       	rjmp	8000ca3a <_vfprintf_r+0x1516>
8000c858:	fa c8 f9 50 	sub	r8,sp,-1712
8000c85c:	1a d8       	st.w	--sp,r8
8000c85e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c862:	04 9a       	mov	r10,r2
8000c864:	1a d8       	st.w	--sp,r8
8000c866:	0c 9b       	mov	r11,r6
8000c868:	fa c8 fb b4 	sub	r8,sp,-1100
8000c86c:	08 9c       	mov	r12,r4
8000c86e:	1a d8       	st.w	--sp,r8
8000c870:	fa c8 f9 40 	sub	r8,sp,-1728
8000c874:	fa c9 ff b4 	sub	r9,sp,-76
8000c878:	fe b0 f4 be 	rcall	8000b1f4 <get_arg>
8000c87c:	2f dd       	sub	sp,-12
8000c87e:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c882:	c0 c8       	rjmp	8000c89a <_vfprintf_r+0x1376>
8000c884:	ee ca ff ff 	sub	r10,r7,-1
8000c888:	10 37       	cp.w	r7,r8
8000c88a:	c0 b4       	brge	8000c8a0 <_vfprintf_r+0x137c>
8000c88c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c890:	14 97       	mov	r7,r10
8000c892:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c896:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c89a:	fa eb 00 00 	st.d	sp[0],r10
8000c89e:	cc e8       	rjmp	8000ca3a <_vfprintf_r+0x1516>
8000c8a0:	41 09       	lddsp	r9,sp[0x40]
8000c8a2:	59 f8       	cp.w	r8,31
8000c8a4:	e0 89 00 16 	brgt	8000c8d0 <_vfprintf_r+0x13ac>
8000c8a8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c8ac:	f2 cb ff f8 	sub	r11,r9,-8
8000c8b0:	fa e7 00 00 	st.d	sp[0],r6
8000c8b4:	51 0b       	stdsp	sp[0x40],r11
8000c8b6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c8ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c8be:	fa e6 00 00 	ld.d	r6,sp[0]
8000c8c2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c8c6:	2f f8       	sub	r8,-1
8000c8c8:	14 97       	mov	r7,r10
8000c8ca:	fb 48 06 b4 	st.w	sp[1716],r8
8000c8ce:	cb 68       	rjmp	8000ca3a <_vfprintf_r+0x1516>
8000c8d0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c8d4:	2f 89       	sub	r9,-8
8000c8d6:	fa e7 00 00 	st.d	sp[0],r6
8000c8da:	51 09       	stdsp	sp[0x40],r9
8000c8dc:	14 97       	mov	r7,r10
8000c8de:	ca e8       	rjmp	8000ca3a <_vfprintf_r+0x1516>
8000c8e0:	ed b5 00 04 	bld	r5,0x4
8000c8e4:	c1 71       	brne	8000c912 <_vfprintf_r+0x13ee>
8000c8e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c8ea:	40 3e       	lddsp	lr,sp[0xc]
8000c8ec:	58 0e       	cp.w	lr,0
8000c8ee:	c0 80       	breq	8000c8fe <_vfprintf_r+0x13da>
8000c8f0:	10 36       	cp.w	r6,r8
8000c8f2:	c6 94       	brge	8000c9c4 <_vfprintf_r+0x14a0>
8000c8f4:	fa cc f9 44 	sub	r12,sp,-1724
8000c8f8:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c8fc:	c8 28       	rjmp	8000ca00 <_vfprintf_r+0x14dc>
8000c8fe:	ee ca ff ff 	sub	r10,r7,-1
8000c902:	10 37       	cp.w	r7,r8
8000c904:	e0 84 00 81 	brge	8000ca06 <_vfprintf_r+0x14e2>
8000c908:	fa cb f9 44 	sub	r11,sp,-1724
8000c90c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c910:	c7 78       	rjmp	8000c9fe <_vfprintf_r+0x14da>
8000c912:	ed b5 00 06 	bld	r5,0x6
8000c916:	c4 b1       	brne	8000c9ac <_vfprintf_r+0x1488>
8000c918:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c91c:	40 3c       	lddsp	r12,sp[0xc]
8000c91e:	58 0c       	cp.w	r12,0
8000c920:	c1 d0       	breq	8000c95a <_vfprintf_r+0x1436>
8000c922:	10 36       	cp.w	r6,r8
8000c924:	c0 64       	brge	8000c930 <_vfprintf_r+0x140c>
8000c926:	fa cb f9 44 	sub	r11,sp,-1724
8000c92a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c92e:	c1 f8       	rjmp	8000c96c <_vfprintf_r+0x1448>
8000c930:	fa c8 f9 50 	sub	r8,sp,-1712
8000c934:	1a d8       	st.w	--sp,r8
8000c936:	fa c8 fa b8 	sub	r8,sp,-1352
8000c93a:	1a d8       	st.w	--sp,r8
8000c93c:	fa c8 fb b4 	sub	r8,sp,-1100
8000c940:	1a d8       	st.w	--sp,r8
8000c942:	fa c8 f9 40 	sub	r8,sp,-1728
8000c946:	fa c9 ff b4 	sub	r9,sp,-76
8000c94a:	04 9a       	mov	r10,r2
8000c94c:	0c 9b       	mov	r11,r6
8000c94e:	08 9c       	mov	r12,r4
8000c950:	fe b0 f4 52 	rcall	8000b1f4 <get_arg>
8000c954:	2f dd       	sub	sp,-12
8000c956:	98 18       	ld.sh	r8,r12[0x2]
8000c958:	c2 78       	rjmp	8000c9a6 <_vfprintf_r+0x1482>
8000c95a:	ee ca ff ff 	sub	r10,r7,-1
8000c95e:	10 37       	cp.w	r7,r8
8000c960:	c0 a4       	brge	8000c974 <_vfprintf_r+0x1450>
8000c962:	fa c9 f9 44 	sub	r9,sp,-1724
8000c966:	14 97       	mov	r7,r10
8000c968:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c96c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c970:	c1 b8       	rjmp	8000c9a6 <_vfprintf_r+0x1482>
8000c972:	d7 03       	nop
8000c974:	41 09       	lddsp	r9,sp[0x40]
8000c976:	59 f8       	cp.w	r8,31
8000c978:	e0 89 00 13 	brgt	8000c99e <_vfprintf_r+0x147a>
8000c97c:	f2 cb ff fc 	sub	r11,r9,-4
8000c980:	51 0b       	stdsp	sp[0x40],r11
8000c982:	72 09       	ld.w	r9,r9[0x0]
8000c984:	fa c6 f9 44 	sub	r6,sp,-1724
8000c988:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c98c:	2f f8       	sub	r8,-1
8000c98e:	f7 49 fd 88 	st.w	r11[-632],r9
8000c992:	fb 48 06 b4 	st.w	sp[1716],r8
8000c996:	14 97       	mov	r7,r10
8000c998:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c99c:	c0 58       	rjmp	8000c9a6 <_vfprintf_r+0x1482>
8000c99e:	92 18       	ld.sh	r8,r9[0x2]
8000c9a0:	14 97       	mov	r7,r10
8000c9a2:	2f c9       	sub	r9,-4
8000c9a4:	51 09       	stdsp	sp[0x40],r9
8000c9a6:	5c 78       	castu.h	r8
8000c9a8:	50 18       	stdsp	sp[0x4],r8
8000c9aa:	c4 68       	rjmp	8000ca36 <_vfprintf_r+0x1512>
8000c9ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c9b0:	40 3c       	lddsp	r12,sp[0xc]
8000c9b2:	58 0c       	cp.w	r12,0
8000c9b4:	c1 d0       	breq	8000c9ee <_vfprintf_r+0x14ca>
8000c9b6:	10 36       	cp.w	r6,r8
8000c9b8:	c0 64       	brge	8000c9c4 <_vfprintf_r+0x14a0>
8000c9ba:	fa cb f9 44 	sub	r11,sp,-1724
8000c9be:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c9c2:	c1 f8       	rjmp	8000ca00 <_vfprintf_r+0x14dc>
8000c9c4:	fa c8 f9 50 	sub	r8,sp,-1712
8000c9c8:	1a d8       	st.w	--sp,r8
8000c9ca:	fa c8 fa b8 	sub	r8,sp,-1352
8000c9ce:	0c 9b       	mov	r11,r6
8000c9d0:	1a d8       	st.w	--sp,r8
8000c9d2:	fa c8 fb b4 	sub	r8,sp,-1100
8000c9d6:	04 9a       	mov	r10,r2
8000c9d8:	1a d8       	st.w	--sp,r8
8000c9da:	08 9c       	mov	r12,r4
8000c9dc:	fa c8 f9 40 	sub	r8,sp,-1728
8000c9e0:	fa c9 ff b4 	sub	r9,sp,-76
8000c9e4:	fe b0 f4 08 	rcall	8000b1f4 <get_arg>
8000c9e8:	2f dd       	sub	sp,-12
8000c9ea:	78 0b       	ld.w	r11,r12[0x0]
8000c9ec:	c2 48       	rjmp	8000ca34 <_vfprintf_r+0x1510>
8000c9ee:	ee ca ff ff 	sub	r10,r7,-1
8000c9f2:	10 37       	cp.w	r7,r8
8000c9f4:	c0 94       	brge	8000ca06 <_vfprintf_r+0x14e2>
8000c9f6:	fa c9 f9 44 	sub	r9,sp,-1724
8000c9fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c9fe:	14 97       	mov	r7,r10
8000ca00:	ec fb fd 88 	ld.w	r11,r6[-632]
8000ca04:	c1 88       	rjmp	8000ca34 <_vfprintf_r+0x1510>
8000ca06:	41 09       	lddsp	r9,sp[0x40]
8000ca08:	59 f8       	cp.w	r8,31
8000ca0a:	e0 89 00 11 	brgt	8000ca2c <_vfprintf_r+0x1508>
8000ca0e:	f2 cb ff fc 	sub	r11,r9,-4
8000ca12:	51 0b       	stdsp	sp[0x40],r11
8000ca14:	fa c6 f9 44 	sub	r6,sp,-1724
8000ca18:	72 0b       	ld.w	r11,r9[0x0]
8000ca1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ca1e:	f3 4b fd 88 	st.w	r9[-632],r11
8000ca22:	2f f8       	sub	r8,-1
8000ca24:	14 97       	mov	r7,r10
8000ca26:	fb 48 06 b4 	st.w	sp[1716],r8
8000ca2a:	c0 58       	rjmp	8000ca34 <_vfprintf_r+0x1510>
8000ca2c:	72 0b       	ld.w	r11,r9[0x0]
8000ca2e:	14 97       	mov	r7,r10
8000ca30:	2f c9       	sub	r9,-4
8000ca32:	51 09       	stdsp	sp[0x40],r9
8000ca34:	50 1b       	stdsp	sp[0x4],r11
8000ca36:	30 0e       	mov	lr,0
8000ca38:	50 0e       	stdsp	sp[0x0],lr
8000ca3a:	40 08       	lddsp	r8,sp[0x0]
8000ca3c:	40 1c       	lddsp	r12,sp[0x4]
8000ca3e:	18 48       	or	r8,r12
8000ca40:	5f 19       	srne	r9
8000ca42:	0a 98       	mov	r8,r5
8000ca44:	eb e9 00 09 	and	r9,r5,r9
8000ca48:	a1 b8       	sbr	r8,0x1
8000ca4a:	58 09       	cp.w	r9,0
8000ca4c:	c0 70       	breq	8000ca5a <_vfprintf_r+0x1536>
8000ca4e:	10 95       	mov	r5,r8
8000ca50:	fb 60 06 b9 	st.b	sp[1721],r0
8000ca54:	33 08       	mov	r8,48
8000ca56:	fb 68 06 b8 	st.b	sp[1720],r8
8000ca5a:	30 28       	mov	r8,2
8000ca5c:	30 09       	mov	r9,0
8000ca5e:	fb 69 06 bb 	st.b	sp[1723],r9
8000ca62:	0a 99       	mov	r9,r5
8000ca64:	a7 d9       	cbr	r9,0x7
8000ca66:	40 2b       	lddsp	r11,sp[0x8]
8000ca68:	40 16       	lddsp	r6,sp[0x4]
8000ca6a:	58 0b       	cp.w	r11,0
8000ca6c:	5f 1a       	srne	r10
8000ca6e:	f2 05 17 40 	movge	r5,r9
8000ca72:	fa c2 f9 78 	sub	r2,sp,-1672
8000ca76:	40 09       	lddsp	r9,sp[0x0]
8000ca78:	0c 49       	or	r9,r6
8000ca7a:	5f 19       	srne	r9
8000ca7c:	f5 e9 10 09 	or	r9,r10,r9
8000ca80:	c5 c0       	breq	8000cb38 <_vfprintf_r+0x1614>
8000ca82:	30 19       	mov	r9,1
8000ca84:	f2 08 18 00 	cp.b	r8,r9
8000ca88:	c0 60       	breq	8000ca94 <_vfprintf_r+0x1570>
8000ca8a:	30 29       	mov	r9,2
8000ca8c:	f2 08 18 00 	cp.b	r8,r9
8000ca90:	c0 41       	brne	8000ca98 <_vfprintf_r+0x1574>
8000ca92:	c3 c8       	rjmp	8000cb0a <_vfprintf_r+0x15e6>
8000ca94:	04 96       	mov	r6,r2
8000ca96:	c3 08       	rjmp	8000caf6 <_vfprintf_r+0x15d2>
8000ca98:	04 96       	mov	r6,r2
8000ca9a:	fa e8 00 00 	ld.d	r8,sp[0]
8000ca9e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000caa2:	2d 0a       	sub	r10,-48
8000caa4:	0c fa       	st.b	--r6,r10
8000caa6:	f0 0b 16 03 	lsr	r11,r8,0x3
8000caaa:	f2 0c 16 03 	lsr	r12,r9,0x3
8000caae:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000cab2:	18 99       	mov	r9,r12
8000cab4:	16 98       	mov	r8,r11
8000cab6:	58 08       	cp.w	r8,0
8000cab8:	5c 29       	cpc	r9
8000caba:	cf 21       	brne	8000ca9e <_vfprintf_r+0x157a>
8000cabc:	fa e9 00 00 	st.d	sp[0],r8
8000cac0:	ed b5 00 00 	bld	r5,0x0
8000cac4:	c4 51       	brne	8000cb4e <_vfprintf_r+0x162a>
8000cac6:	33 09       	mov	r9,48
8000cac8:	f2 0a 18 00 	cp.b	r10,r9
8000cacc:	c4 10       	breq	8000cb4e <_vfprintf_r+0x162a>
8000cace:	0c f9       	st.b	--r6,r9
8000cad0:	c3 f8       	rjmp	8000cb4e <_vfprintf_r+0x162a>
8000cad2:	fa ea 00 00 	ld.d	r10,sp[0]
8000cad6:	30 a8       	mov	r8,10
8000cad8:	30 09       	mov	r9,0
8000cada:	e0 a0 1a 0d 	rcall	8000fef4 <__avr32_umod64>
8000cade:	30 a8       	mov	r8,10
8000cae0:	2d 0a       	sub	r10,-48
8000cae2:	30 09       	mov	r9,0
8000cae4:	ac 8a       	st.b	r6[0x0],r10
8000cae6:	fa ea 00 00 	ld.d	r10,sp[0]
8000caea:	e0 a0 18 d3 	rcall	8000fc90 <__avr32_udiv64>
8000caee:	16 99       	mov	r9,r11
8000caf0:	14 98       	mov	r8,r10
8000caf2:	fa e9 00 00 	st.d	sp[0],r8
8000caf6:	20 16       	sub	r6,1
8000caf8:	fa ea 00 00 	ld.d	r10,sp[0]
8000cafc:	58 9a       	cp.w	r10,9
8000cafe:	5c 2b       	cpc	r11
8000cb00:	fe 9b ff e9 	brhi	8000cad2 <_vfprintf_r+0x15ae>
8000cb04:	1b f8       	ld.ub	r8,sp[0x7]
8000cb06:	2d 08       	sub	r8,-48
8000cb08:	c2 08       	rjmp	8000cb48 <_vfprintf_r+0x1624>
8000cb0a:	04 96       	mov	r6,r2
8000cb0c:	fa e8 00 00 	ld.d	r8,sp[0]
8000cb10:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000cb14:	40 de       	lddsp	lr,sp[0x34]
8000cb16:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000cb1a:	0c fa       	st.b	--r6,r10
8000cb1c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000cb20:	f0 0a 16 04 	lsr	r10,r8,0x4
8000cb24:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000cb28:	16 99       	mov	r9,r11
8000cb2a:	14 98       	mov	r8,r10
8000cb2c:	58 08       	cp.w	r8,0
8000cb2e:	5c 29       	cpc	r9
8000cb30:	cf 01       	brne	8000cb10 <_vfprintf_r+0x15ec>
8000cb32:	fa e9 00 00 	st.d	sp[0],r8
8000cb36:	c0 c8       	rjmp	8000cb4e <_vfprintf_r+0x162a>
8000cb38:	58 08       	cp.w	r8,0
8000cb3a:	c0 91       	brne	8000cb4c <_vfprintf_r+0x1628>
8000cb3c:	ed b5 00 00 	bld	r5,0x0
8000cb40:	c0 61       	brne	8000cb4c <_vfprintf_r+0x1628>
8000cb42:	fa c6 f9 79 	sub	r6,sp,-1671
8000cb46:	33 08       	mov	r8,48
8000cb48:	ac 88       	st.b	r6[0x0],r8
8000cb4a:	c0 28       	rjmp	8000cb4e <_vfprintf_r+0x162a>
8000cb4c:	04 96       	mov	r6,r2
8000cb4e:	0c 12       	sub	r2,r6
8000cb50:	c1 c8       	rjmp	8000cb88 <_vfprintf_r+0x1664>
8000cb52:	50 a7       	stdsp	sp[0x28],r7
8000cb54:	50 80       	stdsp	sp[0x20],r0
8000cb56:	40 93       	lddsp	r3,sp[0x24]
8000cb58:	0c 97       	mov	r7,r6
8000cb5a:	10 90       	mov	r0,r8
8000cb5c:	04 94       	mov	r4,r2
8000cb5e:	40 41       	lddsp	r1,sp[0x10]
8000cb60:	58 08       	cp.w	r8,0
8000cb62:	e0 80 04 4f 	breq	8000d400 <_vfprintf_r+0x1edc>
8000cb66:	fb 68 06 60 	st.b	sp[1632],r8
8000cb6a:	30 0c       	mov	r12,0
8000cb6c:	30 08       	mov	r8,0
8000cb6e:	30 12       	mov	r2,1
8000cb70:	fb 68 06 bb 	st.b	sp[1723],r8
8000cb74:	50 2c       	stdsp	sp[0x8],r12
8000cb76:	fa c6 f9 a0 	sub	r6,sp,-1632
8000cb7a:	c0 78       	rjmp	8000cb88 <_vfprintf_r+0x1664>
8000cb7c:	30 0b       	mov	r11,0
8000cb7e:	50 2b       	stdsp	sp[0x8],r11
8000cb80:	c0 48       	rjmp	8000cb88 <_vfprintf_r+0x1664>
8000cb82:	40 22       	lddsp	r2,sp[0x8]
8000cb84:	30 0a       	mov	r10,0
8000cb86:	50 2a       	stdsp	sp[0x8],r10
8000cb88:	40 29       	lddsp	r9,sp[0x8]
8000cb8a:	e4 09 0c 49 	max	r9,r2,r9
8000cb8e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000cb92:	50 39       	stdsp	sp[0xc],r9
8000cb94:	0a 9e       	mov	lr,r5
8000cb96:	30 09       	mov	r9,0
8000cb98:	e2 1e 00 02 	andl	lr,0x2,COH
8000cb9c:	f2 08 18 00 	cp.b	r8,r9
8000cba0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000cba4:	f7 b8 01 ff 	subne	r8,-1
8000cba8:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000cbac:	0a 9b       	mov	r11,r5
8000cbae:	58 0e       	cp.w	lr,0
8000cbb0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000cbb4:	f7 bc 01 fe 	subne	r12,-2
8000cbb8:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000cbbc:	e2 1b 00 84 	andl	r11,0x84,COH
8000cbc0:	50 fe       	stdsp	sp[0x3c],lr
8000cbc2:	50 9b       	stdsp	sp[0x24],r11
8000cbc4:	c4 71       	brne	8000cc52 <_vfprintf_r+0x172e>
8000cbc6:	40 8a       	lddsp	r10,sp[0x20]
8000cbc8:	40 39       	lddsp	r9,sp[0xc]
8000cbca:	12 1a       	sub	r10,r9
8000cbcc:	50 4a       	stdsp	sp[0x10],r10
8000cbce:	58 0a       	cp.w	r10,0
8000cbd0:	e0 89 00 20 	brgt	8000cc10 <_vfprintf_r+0x16ec>
8000cbd4:	c3 f8       	rjmp	8000cc52 <_vfprintf_r+0x172e>
8000cbd6:	2f 09       	sub	r9,-16
8000cbd8:	2f f8       	sub	r8,-1
8000cbda:	fe ce c1 12 	sub	lr,pc,-16110
8000cbde:	31 0c       	mov	r12,16
8000cbe0:	fb 49 06 90 	st.w	sp[1680],r9
8000cbe4:	87 0e       	st.w	r3[0x0],lr
8000cbe6:	87 1c       	st.w	r3[0x4],r12
8000cbe8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbec:	58 78       	cp.w	r8,7
8000cbee:	e0 89 00 04 	brgt	8000cbf6 <_vfprintf_r+0x16d2>
8000cbf2:	2f 83       	sub	r3,-8
8000cbf4:	c0 b8       	rjmp	8000cc0a <_vfprintf_r+0x16e6>
8000cbf6:	fa ca f9 78 	sub	r10,sp,-1672
8000cbfa:	02 9b       	mov	r11,r1
8000cbfc:	08 9c       	mov	r12,r4
8000cbfe:	fe b0 f4 85 	rcall	8000b508 <__sprint_r>
8000cc02:	e0 81 04 10 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cc06:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc0a:	40 4b       	lddsp	r11,sp[0x10]
8000cc0c:	21 0b       	sub	r11,16
8000cc0e:	50 4b       	stdsp	sp[0x10],r11
8000cc10:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cc14:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc18:	fe ca c1 50 	sub	r10,pc,-16048
8000cc1c:	40 4e       	lddsp	lr,sp[0x10]
8000cc1e:	59 0e       	cp.w	lr,16
8000cc20:	fe 99 ff db 	brgt	8000cbd6 <_vfprintf_r+0x16b2>
8000cc24:	1c 09       	add	r9,lr
8000cc26:	2f f8       	sub	r8,-1
8000cc28:	87 0a       	st.w	r3[0x0],r10
8000cc2a:	fb 49 06 90 	st.w	sp[1680],r9
8000cc2e:	87 1e       	st.w	r3[0x4],lr
8000cc30:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc34:	58 78       	cp.w	r8,7
8000cc36:	e0 89 00 04 	brgt	8000cc3e <_vfprintf_r+0x171a>
8000cc3a:	2f 83       	sub	r3,-8
8000cc3c:	c0 b8       	rjmp	8000cc52 <_vfprintf_r+0x172e>
8000cc3e:	fa ca f9 78 	sub	r10,sp,-1672
8000cc42:	02 9b       	mov	r11,r1
8000cc44:	08 9c       	mov	r12,r4
8000cc46:	fe b0 f4 61 	rcall	8000b508 <__sprint_r>
8000cc4a:	e0 81 03 ec 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cc4e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc52:	30 09       	mov	r9,0
8000cc54:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000cc58:	f2 08 18 00 	cp.b	r8,r9
8000cc5c:	c1 f0       	breq	8000cc9a <_vfprintf_r+0x1776>
8000cc5e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc62:	fa c9 f9 45 	sub	r9,sp,-1723
8000cc66:	2f f8       	sub	r8,-1
8000cc68:	87 09       	st.w	r3[0x0],r9
8000cc6a:	fb 48 06 90 	st.w	sp[1680],r8
8000cc6e:	30 19       	mov	r9,1
8000cc70:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc74:	87 19       	st.w	r3[0x4],r9
8000cc76:	2f f8       	sub	r8,-1
8000cc78:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc7c:	58 78       	cp.w	r8,7
8000cc7e:	e0 89 00 04 	brgt	8000cc86 <_vfprintf_r+0x1762>
8000cc82:	2f 83       	sub	r3,-8
8000cc84:	c0 b8       	rjmp	8000cc9a <_vfprintf_r+0x1776>
8000cc86:	fa ca f9 78 	sub	r10,sp,-1672
8000cc8a:	02 9b       	mov	r11,r1
8000cc8c:	08 9c       	mov	r12,r4
8000cc8e:	fe b0 f4 3d 	rcall	8000b508 <__sprint_r>
8000cc92:	e0 81 03 c8 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cc96:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc9a:	40 fc       	lddsp	r12,sp[0x3c]
8000cc9c:	58 0c       	cp.w	r12,0
8000cc9e:	c1 f0       	breq	8000ccdc <_vfprintf_r+0x17b8>
8000cca0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cca4:	fa c9 f9 48 	sub	r9,sp,-1720
8000cca8:	2f e8       	sub	r8,-2
8000ccaa:	87 09       	st.w	r3[0x0],r9
8000ccac:	fb 48 06 90 	st.w	sp[1680],r8
8000ccb0:	30 29       	mov	r9,2
8000ccb2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ccb6:	87 19       	st.w	r3[0x4],r9
8000ccb8:	2f f8       	sub	r8,-1
8000ccba:	fb 48 06 8c 	st.w	sp[1676],r8
8000ccbe:	58 78       	cp.w	r8,7
8000ccc0:	e0 89 00 04 	brgt	8000ccc8 <_vfprintf_r+0x17a4>
8000ccc4:	2f 83       	sub	r3,-8
8000ccc6:	c0 b8       	rjmp	8000ccdc <_vfprintf_r+0x17b8>
8000ccc8:	fa ca f9 78 	sub	r10,sp,-1672
8000cccc:	02 9b       	mov	r11,r1
8000ccce:	08 9c       	mov	r12,r4
8000ccd0:	fe b0 f4 1c 	rcall	8000b508 <__sprint_r>
8000ccd4:	e0 81 03 a7 	brne	8000d422 <_vfprintf_r+0x1efe>
8000ccd8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ccdc:	40 9b       	lddsp	r11,sp[0x24]
8000ccde:	e0 4b 00 80 	cp.w	r11,128
8000cce2:	c4 71       	brne	8000cd70 <_vfprintf_r+0x184c>
8000cce4:	40 8a       	lddsp	r10,sp[0x20]
8000cce6:	40 39       	lddsp	r9,sp[0xc]
8000cce8:	12 1a       	sub	r10,r9
8000ccea:	50 4a       	stdsp	sp[0x10],r10
8000ccec:	58 0a       	cp.w	r10,0
8000ccee:	e0 89 00 20 	brgt	8000cd2e <_vfprintf_r+0x180a>
8000ccf2:	c3 f8       	rjmp	8000cd70 <_vfprintf_r+0x184c>
8000ccf4:	2f 09       	sub	r9,-16
8000ccf6:	2f f8       	sub	r8,-1
8000ccf8:	fe ce c2 20 	sub	lr,pc,-15840
8000ccfc:	31 0c       	mov	r12,16
8000ccfe:	fb 49 06 90 	st.w	sp[1680],r9
8000cd02:	87 0e       	st.w	r3[0x0],lr
8000cd04:	87 1c       	st.w	r3[0x4],r12
8000cd06:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd0a:	58 78       	cp.w	r8,7
8000cd0c:	e0 89 00 04 	brgt	8000cd14 <_vfprintf_r+0x17f0>
8000cd10:	2f 83       	sub	r3,-8
8000cd12:	c0 b8       	rjmp	8000cd28 <_vfprintf_r+0x1804>
8000cd14:	fa ca f9 78 	sub	r10,sp,-1672
8000cd18:	02 9b       	mov	r11,r1
8000cd1a:	08 9c       	mov	r12,r4
8000cd1c:	fe b0 f3 f6 	rcall	8000b508 <__sprint_r>
8000cd20:	e0 81 03 81 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cd24:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd28:	40 4b       	lddsp	r11,sp[0x10]
8000cd2a:	21 0b       	sub	r11,16
8000cd2c:	50 4b       	stdsp	sp[0x10],r11
8000cd2e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cd32:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cd36:	fe ca c2 5e 	sub	r10,pc,-15778
8000cd3a:	40 4e       	lddsp	lr,sp[0x10]
8000cd3c:	59 0e       	cp.w	lr,16
8000cd3e:	fe 99 ff db 	brgt	8000ccf4 <_vfprintf_r+0x17d0>
8000cd42:	1c 09       	add	r9,lr
8000cd44:	2f f8       	sub	r8,-1
8000cd46:	87 0a       	st.w	r3[0x0],r10
8000cd48:	fb 49 06 90 	st.w	sp[1680],r9
8000cd4c:	87 1e       	st.w	r3[0x4],lr
8000cd4e:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd52:	58 78       	cp.w	r8,7
8000cd54:	e0 89 00 04 	brgt	8000cd5c <_vfprintf_r+0x1838>
8000cd58:	2f 83       	sub	r3,-8
8000cd5a:	c0 b8       	rjmp	8000cd70 <_vfprintf_r+0x184c>
8000cd5c:	fa ca f9 78 	sub	r10,sp,-1672
8000cd60:	02 9b       	mov	r11,r1
8000cd62:	08 9c       	mov	r12,r4
8000cd64:	fe b0 f3 d2 	rcall	8000b508 <__sprint_r>
8000cd68:	e0 81 03 5d 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cd6c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd70:	40 2c       	lddsp	r12,sp[0x8]
8000cd72:	04 1c       	sub	r12,r2
8000cd74:	50 2c       	stdsp	sp[0x8],r12
8000cd76:	58 0c       	cp.w	r12,0
8000cd78:	e0 89 00 20 	brgt	8000cdb8 <_vfprintf_r+0x1894>
8000cd7c:	c3 f8       	rjmp	8000cdfa <_vfprintf_r+0x18d6>
8000cd7e:	2f 09       	sub	r9,-16
8000cd80:	2f f8       	sub	r8,-1
8000cd82:	fe cb c2 aa 	sub	r11,pc,-15702
8000cd86:	31 0a       	mov	r10,16
8000cd88:	fb 49 06 90 	st.w	sp[1680],r9
8000cd8c:	87 0b       	st.w	r3[0x0],r11
8000cd8e:	87 1a       	st.w	r3[0x4],r10
8000cd90:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd94:	58 78       	cp.w	r8,7
8000cd96:	e0 89 00 04 	brgt	8000cd9e <_vfprintf_r+0x187a>
8000cd9a:	2f 83       	sub	r3,-8
8000cd9c:	c0 b8       	rjmp	8000cdb2 <_vfprintf_r+0x188e>
8000cd9e:	fa ca f9 78 	sub	r10,sp,-1672
8000cda2:	02 9b       	mov	r11,r1
8000cda4:	08 9c       	mov	r12,r4
8000cda6:	fe b0 f3 b1 	rcall	8000b508 <__sprint_r>
8000cdaa:	e0 81 03 3c 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cdae:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cdb2:	40 29       	lddsp	r9,sp[0x8]
8000cdb4:	21 09       	sub	r9,16
8000cdb6:	50 29       	stdsp	sp[0x8],r9
8000cdb8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cdbc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cdc0:	fe ca c2 e8 	sub	r10,pc,-15640
8000cdc4:	40 2e       	lddsp	lr,sp[0x8]
8000cdc6:	59 0e       	cp.w	lr,16
8000cdc8:	fe 99 ff db 	brgt	8000cd7e <_vfprintf_r+0x185a>
8000cdcc:	1c 09       	add	r9,lr
8000cdce:	2f f8       	sub	r8,-1
8000cdd0:	87 0a       	st.w	r3[0x0],r10
8000cdd2:	fb 49 06 90 	st.w	sp[1680],r9
8000cdd6:	87 1e       	st.w	r3[0x4],lr
8000cdd8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cddc:	58 78       	cp.w	r8,7
8000cdde:	e0 89 00 04 	brgt	8000cde6 <_vfprintf_r+0x18c2>
8000cde2:	2f 83       	sub	r3,-8
8000cde4:	c0 b8       	rjmp	8000cdfa <_vfprintf_r+0x18d6>
8000cde6:	fa ca f9 78 	sub	r10,sp,-1672
8000cdea:	02 9b       	mov	r11,r1
8000cdec:	08 9c       	mov	r12,r4
8000cdee:	fe b0 f3 8d 	rcall	8000b508 <__sprint_r>
8000cdf2:	e0 81 03 18 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cdf6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cdfa:	ed b5 00 08 	bld	r5,0x8
8000cdfe:	c0 b0       	breq	8000ce14 <_vfprintf_r+0x18f0>
8000ce00:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce04:	87 12       	st.w	r3[0x4],r2
8000ce06:	87 06       	st.w	r3[0x0],r6
8000ce08:	f0 02 00 02 	add	r2,r8,r2
8000ce0c:	fb 42 06 90 	st.w	sp[1680],r2
8000ce10:	e0 8f 01 d4 	bral	8000d1b8 <_vfprintf_r+0x1c94>
8000ce14:	e0 40 00 65 	cp.w	r0,101
8000ce18:	e0 8a 01 d6 	brle	8000d1c4 <_vfprintf_r+0x1ca0>
8000ce1c:	30 08       	mov	r8,0
8000ce1e:	30 09       	mov	r9,0
8000ce20:	40 5b       	lddsp	r11,sp[0x14]
8000ce22:	40 7a       	lddsp	r10,sp[0x1c]
8000ce24:	e0 a0 15 2f 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000ce28:	c7 90       	breq	8000cf1a <_vfprintf_r+0x19f6>
8000ce2a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce2e:	fe c9 c3 6a 	sub	r9,pc,-15510
8000ce32:	2f f8       	sub	r8,-1
8000ce34:	87 09       	st.w	r3[0x0],r9
8000ce36:	fb 48 06 90 	st.w	sp[1680],r8
8000ce3a:	30 19       	mov	r9,1
8000ce3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce40:	87 19       	st.w	r3[0x4],r9
8000ce42:	2f f8       	sub	r8,-1
8000ce44:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce48:	58 78       	cp.w	r8,7
8000ce4a:	e0 89 00 05 	brgt	8000ce54 <_vfprintf_r+0x1930>
8000ce4e:	2f 83       	sub	r3,-8
8000ce50:	c0 c8       	rjmp	8000ce68 <_vfprintf_r+0x1944>
8000ce52:	d7 03       	nop
8000ce54:	fa ca f9 78 	sub	r10,sp,-1672
8000ce58:	02 9b       	mov	r11,r1
8000ce5a:	08 9c       	mov	r12,r4
8000ce5c:	fe b0 f3 56 	rcall	8000b508 <__sprint_r>
8000ce60:	e0 81 02 e1 	brne	8000d422 <_vfprintf_r+0x1efe>
8000ce64:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce68:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ce6c:	40 6c       	lddsp	r12,sp[0x18]
8000ce6e:	18 38       	cp.w	r8,r12
8000ce70:	c0 55       	brlt	8000ce7a <_vfprintf_r+0x1956>
8000ce72:	ed b5 00 00 	bld	r5,0x0
8000ce76:	e0 81 02 6b 	brne	8000d34c <_vfprintf_r+0x1e28>
8000ce7a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce7e:	2f f8       	sub	r8,-1
8000ce80:	40 cb       	lddsp	r11,sp[0x30]
8000ce82:	fb 48 06 90 	st.w	sp[1680],r8
8000ce86:	30 19       	mov	r9,1
8000ce88:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce8c:	87 0b       	st.w	r3[0x0],r11
8000ce8e:	2f f8       	sub	r8,-1
8000ce90:	87 19       	st.w	r3[0x4],r9
8000ce92:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce96:	58 78       	cp.w	r8,7
8000ce98:	e0 89 00 04 	brgt	8000cea0 <_vfprintf_r+0x197c>
8000ce9c:	2f 83       	sub	r3,-8
8000ce9e:	c0 b8       	rjmp	8000ceb4 <_vfprintf_r+0x1990>
8000cea0:	fa ca f9 78 	sub	r10,sp,-1672
8000cea4:	02 9b       	mov	r11,r1
8000cea6:	08 9c       	mov	r12,r4
8000cea8:	fe b0 f3 30 	rcall	8000b508 <__sprint_r>
8000ceac:	e0 81 02 bb 	brne	8000d422 <_vfprintf_r+0x1efe>
8000ceb0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ceb4:	40 66       	lddsp	r6,sp[0x18]
8000ceb6:	20 16       	sub	r6,1
8000ceb8:	58 06       	cp.w	r6,0
8000ceba:	e0 89 00 1d 	brgt	8000cef4 <_vfprintf_r+0x19d0>
8000cebe:	e0 8f 02 47 	bral	8000d34c <_vfprintf_r+0x1e28>
8000cec2:	2f 09       	sub	r9,-16
8000cec4:	2f f8       	sub	r8,-1
8000cec6:	fb 49 06 90 	st.w	sp[1680],r9
8000ceca:	87 02       	st.w	r3[0x0],r2
8000cecc:	87 10       	st.w	r3[0x4],r0
8000cece:	fb 48 06 8c 	st.w	sp[1676],r8
8000ced2:	58 78       	cp.w	r8,7
8000ced4:	e0 89 00 04 	brgt	8000cedc <_vfprintf_r+0x19b8>
8000ced8:	2f 83       	sub	r3,-8
8000ceda:	c0 b8       	rjmp	8000cef0 <_vfprintf_r+0x19cc>
8000cedc:	fa ca f9 78 	sub	r10,sp,-1672
8000cee0:	02 9b       	mov	r11,r1
8000cee2:	08 9c       	mov	r12,r4
8000cee4:	fe b0 f3 12 	rcall	8000b508 <__sprint_r>
8000cee8:	e0 81 02 9d 	brne	8000d422 <_vfprintf_r+0x1efe>
8000ceec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cef0:	21 06       	sub	r6,16
8000cef2:	c0 48       	rjmp	8000cefa <_vfprintf_r+0x19d6>
8000cef4:	fe c2 c4 1c 	sub	r2,pc,-15332
8000cef8:	31 00       	mov	r0,16
8000cefa:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cefe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf02:	fe ca c4 2a 	sub	r10,pc,-15318
8000cf06:	59 06       	cp.w	r6,16
8000cf08:	fe 99 ff dd 	brgt	8000cec2 <_vfprintf_r+0x199e>
8000cf0c:	0c 09       	add	r9,r6
8000cf0e:	87 0a       	st.w	r3[0x0],r10
8000cf10:	fb 49 06 90 	st.w	sp[1680],r9
8000cf14:	2f f8       	sub	r8,-1
8000cf16:	87 16       	st.w	r3[0x4],r6
8000cf18:	c5 39       	rjmp	8000d1be <_vfprintf_r+0x1c9a>
8000cf1a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000cf1e:	58 0a       	cp.w	r10,0
8000cf20:	e0 89 00 92 	brgt	8000d044 <_vfprintf_r+0x1b20>
8000cf24:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf28:	fe c9 c4 64 	sub	r9,pc,-15260
8000cf2c:	2f f8       	sub	r8,-1
8000cf2e:	87 09       	st.w	r3[0x0],r9
8000cf30:	fb 48 06 90 	st.w	sp[1680],r8
8000cf34:	30 19       	mov	r9,1
8000cf36:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf3a:	87 19       	st.w	r3[0x4],r9
8000cf3c:	2f f8       	sub	r8,-1
8000cf3e:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf42:	58 78       	cp.w	r8,7
8000cf44:	e0 89 00 04 	brgt	8000cf4c <_vfprintf_r+0x1a28>
8000cf48:	2f 83       	sub	r3,-8
8000cf4a:	c0 b8       	rjmp	8000cf60 <_vfprintf_r+0x1a3c>
8000cf4c:	fa ca f9 78 	sub	r10,sp,-1672
8000cf50:	02 9b       	mov	r11,r1
8000cf52:	08 9c       	mov	r12,r4
8000cf54:	fe b0 f2 da 	rcall	8000b508 <__sprint_r>
8000cf58:	e0 81 02 65 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cf5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf60:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cf64:	58 08       	cp.w	r8,0
8000cf66:	c0 81       	brne	8000cf76 <_vfprintf_r+0x1a52>
8000cf68:	40 6a       	lddsp	r10,sp[0x18]
8000cf6a:	58 0a       	cp.w	r10,0
8000cf6c:	c0 51       	brne	8000cf76 <_vfprintf_r+0x1a52>
8000cf6e:	ed b5 00 00 	bld	r5,0x0
8000cf72:	e0 81 01 ed 	brne	8000d34c <_vfprintf_r+0x1e28>
8000cf76:	40 c9       	lddsp	r9,sp[0x30]
8000cf78:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf7c:	2f f8       	sub	r8,-1
8000cf7e:	87 09       	st.w	r3[0x0],r9
8000cf80:	fb 48 06 90 	st.w	sp[1680],r8
8000cf84:	30 19       	mov	r9,1
8000cf86:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf8a:	87 19       	st.w	r3[0x4],r9
8000cf8c:	2f f8       	sub	r8,-1
8000cf8e:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf92:	58 78       	cp.w	r8,7
8000cf94:	e0 89 00 04 	brgt	8000cf9c <_vfprintf_r+0x1a78>
8000cf98:	2f 83       	sub	r3,-8
8000cf9a:	c0 b8       	rjmp	8000cfb0 <_vfprintf_r+0x1a8c>
8000cf9c:	fa ca f9 78 	sub	r10,sp,-1672
8000cfa0:	02 9b       	mov	r11,r1
8000cfa2:	08 9c       	mov	r12,r4
8000cfa4:	fe b0 f2 b2 	rcall	8000b508 <__sprint_r>
8000cfa8:	e0 81 02 3d 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cfac:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cfb0:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cfb4:	5c 32       	neg	r2
8000cfb6:	58 02       	cp.w	r2,0
8000cfb8:	e0 89 00 1d 	brgt	8000cff2 <_vfprintf_r+0x1ace>
8000cfbc:	c3 d8       	rjmp	8000d036 <_vfprintf_r+0x1b12>
8000cfbe:	2f 09       	sub	r9,-16
8000cfc0:	2f f8       	sub	r8,-1
8000cfc2:	31 0e       	mov	lr,16
8000cfc4:	fb 49 06 90 	st.w	sp[1680],r9
8000cfc8:	87 00       	st.w	r3[0x0],r0
8000cfca:	87 1e       	st.w	r3[0x4],lr
8000cfcc:	fb 48 06 8c 	st.w	sp[1676],r8
8000cfd0:	58 78       	cp.w	r8,7
8000cfd2:	e0 89 00 04 	brgt	8000cfda <_vfprintf_r+0x1ab6>
8000cfd6:	2f 83       	sub	r3,-8
8000cfd8:	c0 b8       	rjmp	8000cfee <_vfprintf_r+0x1aca>
8000cfda:	fa ca f9 78 	sub	r10,sp,-1672
8000cfde:	02 9b       	mov	r11,r1
8000cfe0:	08 9c       	mov	r12,r4
8000cfe2:	fe b0 f2 93 	rcall	8000b508 <__sprint_r>
8000cfe6:	e0 81 02 1e 	brne	8000d422 <_vfprintf_r+0x1efe>
8000cfea:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cfee:	21 02       	sub	r2,16
8000cff0:	c0 38       	rjmp	8000cff6 <_vfprintf_r+0x1ad2>
8000cff2:	fe c0 c5 1a 	sub	r0,pc,-15078
8000cff6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cffa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cffe:	fe ca c5 26 	sub	r10,pc,-15066
8000d002:	59 02       	cp.w	r2,16
8000d004:	fe 99 ff dd 	brgt	8000cfbe <_vfprintf_r+0x1a9a>
8000d008:	04 09       	add	r9,r2
8000d00a:	2f f8       	sub	r8,-1
8000d00c:	87 0a       	st.w	r3[0x0],r10
8000d00e:	fb 49 06 90 	st.w	sp[1680],r9
8000d012:	87 12       	st.w	r3[0x4],r2
8000d014:	fb 48 06 8c 	st.w	sp[1676],r8
8000d018:	58 78       	cp.w	r8,7
8000d01a:	e0 89 00 04 	brgt	8000d022 <_vfprintf_r+0x1afe>
8000d01e:	2f 83       	sub	r3,-8
8000d020:	c0 b8       	rjmp	8000d036 <_vfprintf_r+0x1b12>
8000d022:	fa ca f9 78 	sub	r10,sp,-1672
8000d026:	02 9b       	mov	r11,r1
8000d028:	08 9c       	mov	r12,r4
8000d02a:	fe b0 f2 6f 	rcall	8000b508 <__sprint_r>
8000d02e:	e0 81 01 fa 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d032:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d036:	40 6c       	lddsp	r12,sp[0x18]
8000d038:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d03c:	87 06       	st.w	r3[0x0],r6
8000d03e:	87 1c       	st.w	r3[0x4],r12
8000d040:	18 08       	add	r8,r12
8000d042:	cb 98       	rjmp	8000d1b4 <_vfprintf_r+0x1c90>
8000d044:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d048:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d04c:	40 6b       	lddsp	r11,sp[0x18]
8000d04e:	16 3a       	cp.w	r10,r11
8000d050:	c6 f5       	brlt	8000d12e <_vfprintf_r+0x1c0a>
8000d052:	16 09       	add	r9,r11
8000d054:	2f f8       	sub	r8,-1
8000d056:	87 06       	st.w	r3[0x0],r6
8000d058:	fb 49 06 90 	st.w	sp[1680],r9
8000d05c:	87 1b       	st.w	r3[0x4],r11
8000d05e:	fb 48 06 8c 	st.w	sp[1676],r8
8000d062:	58 78       	cp.w	r8,7
8000d064:	e0 89 00 04 	brgt	8000d06c <_vfprintf_r+0x1b48>
8000d068:	2f 83       	sub	r3,-8
8000d06a:	c0 b8       	rjmp	8000d080 <_vfprintf_r+0x1b5c>
8000d06c:	fa ca f9 78 	sub	r10,sp,-1672
8000d070:	02 9b       	mov	r11,r1
8000d072:	08 9c       	mov	r12,r4
8000d074:	fe b0 f2 4a 	rcall	8000b508 <__sprint_r>
8000d078:	e0 81 01 d5 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d07c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d080:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000d084:	40 6a       	lddsp	r10,sp[0x18]
8000d086:	14 16       	sub	r6,r10
8000d088:	58 06       	cp.w	r6,0
8000d08a:	e0 89 00 1c 	brgt	8000d0c2 <_vfprintf_r+0x1b9e>
8000d08e:	c3 d8       	rjmp	8000d108 <_vfprintf_r+0x1be4>
8000d090:	2f 09       	sub	r9,-16
8000d092:	2f f8       	sub	r8,-1
8000d094:	fb 49 06 90 	st.w	sp[1680],r9
8000d098:	87 02       	st.w	r3[0x0],r2
8000d09a:	87 10       	st.w	r3[0x4],r0
8000d09c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0a0:	58 78       	cp.w	r8,7
8000d0a2:	e0 89 00 04 	brgt	8000d0aa <_vfprintf_r+0x1b86>
8000d0a6:	2f 83       	sub	r3,-8
8000d0a8:	c0 b8       	rjmp	8000d0be <_vfprintf_r+0x1b9a>
8000d0aa:	fa ca f9 78 	sub	r10,sp,-1672
8000d0ae:	02 9b       	mov	r11,r1
8000d0b0:	08 9c       	mov	r12,r4
8000d0b2:	fe b0 f2 2b 	rcall	8000b508 <__sprint_r>
8000d0b6:	e0 81 01 b6 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d0ba:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0be:	21 06       	sub	r6,16
8000d0c0:	c0 48       	rjmp	8000d0c8 <_vfprintf_r+0x1ba4>
8000d0c2:	fe c2 c5 ea 	sub	r2,pc,-14870
8000d0c6:	31 00       	mov	r0,16
8000d0c8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d0cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0d0:	fe ca c5 f8 	sub	r10,pc,-14856
8000d0d4:	59 06       	cp.w	r6,16
8000d0d6:	fe 99 ff dd 	brgt	8000d090 <_vfprintf_r+0x1b6c>
8000d0da:	0c 09       	add	r9,r6
8000d0dc:	2f f8       	sub	r8,-1
8000d0de:	87 0a       	st.w	r3[0x0],r10
8000d0e0:	fb 49 06 90 	st.w	sp[1680],r9
8000d0e4:	87 16       	st.w	r3[0x4],r6
8000d0e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0ea:	58 78       	cp.w	r8,7
8000d0ec:	e0 89 00 04 	brgt	8000d0f4 <_vfprintf_r+0x1bd0>
8000d0f0:	2f 83       	sub	r3,-8
8000d0f2:	c0 b8       	rjmp	8000d108 <_vfprintf_r+0x1be4>
8000d0f4:	fa ca f9 78 	sub	r10,sp,-1672
8000d0f8:	02 9b       	mov	r11,r1
8000d0fa:	08 9c       	mov	r12,r4
8000d0fc:	fe b0 f2 06 	rcall	8000b508 <__sprint_r>
8000d100:	e0 81 01 91 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d104:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d108:	ed b5 00 00 	bld	r5,0x0
8000d10c:	e0 81 01 20 	brne	8000d34c <_vfprintf_r+0x1e28>
8000d110:	40 c9       	lddsp	r9,sp[0x30]
8000d112:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d116:	2f f8       	sub	r8,-1
8000d118:	87 09       	st.w	r3[0x0],r9
8000d11a:	fb 48 06 90 	st.w	sp[1680],r8
8000d11e:	30 19       	mov	r9,1
8000d120:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d124:	87 19       	st.w	r3[0x4],r9
8000d126:	2f f8       	sub	r8,-1
8000d128:	fb 48 06 8c 	st.w	sp[1676],r8
8000d12c:	c0 29       	rjmp	8000d330 <_vfprintf_r+0x1e0c>
8000d12e:	14 09       	add	r9,r10
8000d130:	2f f8       	sub	r8,-1
8000d132:	fb 49 06 90 	st.w	sp[1680],r9
8000d136:	87 06       	st.w	r3[0x0],r6
8000d138:	87 1a       	st.w	r3[0x4],r10
8000d13a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d13e:	58 78       	cp.w	r8,7
8000d140:	e0 89 00 04 	brgt	8000d148 <_vfprintf_r+0x1c24>
8000d144:	2f 83       	sub	r3,-8
8000d146:	c0 b8       	rjmp	8000d15c <_vfprintf_r+0x1c38>
8000d148:	fa ca f9 78 	sub	r10,sp,-1672
8000d14c:	02 9b       	mov	r11,r1
8000d14e:	08 9c       	mov	r12,r4
8000d150:	fe b0 f1 dc 	rcall	8000b508 <__sprint_r>
8000d154:	e0 81 01 67 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d158:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d15c:	40 c8       	lddsp	r8,sp[0x30]
8000d15e:	87 08       	st.w	r3[0x0],r8
8000d160:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d164:	2f f8       	sub	r8,-1
8000d166:	30 19       	mov	r9,1
8000d168:	fb 48 06 90 	st.w	sp[1680],r8
8000d16c:	87 19       	st.w	r3[0x4],r9
8000d16e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d172:	2f f8       	sub	r8,-1
8000d174:	fb 48 06 8c 	st.w	sp[1676],r8
8000d178:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000d17c:	58 78       	cp.w	r8,7
8000d17e:	e0 89 00 04 	brgt	8000d186 <_vfprintf_r+0x1c62>
8000d182:	2f 83       	sub	r3,-8
8000d184:	c0 b8       	rjmp	8000d19a <_vfprintf_r+0x1c76>
8000d186:	fa ca f9 78 	sub	r10,sp,-1672
8000d18a:	02 9b       	mov	r11,r1
8000d18c:	08 9c       	mov	r12,r4
8000d18e:	fe b0 f1 bd 	rcall	8000b508 <__sprint_r>
8000d192:	e0 81 01 48 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d196:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d19a:	04 06       	add	r6,r2
8000d19c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d1a0:	87 06       	st.w	r3[0x0],r6
8000d1a2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d1a6:	40 66       	lddsp	r6,sp[0x18]
8000d1a8:	40 6e       	lddsp	lr,sp[0x18]
8000d1aa:	10 16       	sub	r6,r8
8000d1ac:	f2 08 01 08 	sub	r8,r9,r8
8000d1b0:	87 16       	st.w	r3[0x4],r6
8000d1b2:	1c 08       	add	r8,lr
8000d1b4:	fb 48 06 90 	st.w	sp[1680],r8
8000d1b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d1bc:	2f f8       	sub	r8,-1
8000d1be:	fb 48 06 8c 	st.w	sp[1676],r8
8000d1c2:	cb 78       	rjmp	8000d330 <_vfprintf_r+0x1e0c>
8000d1c4:	40 6c       	lddsp	r12,sp[0x18]
8000d1c6:	58 1c       	cp.w	r12,1
8000d1c8:	e0 89 00 06 	brgt	8000d1d4 <_vfprintf_r+0x1cb0>
8000d1cc:	ed b5 00 00 	bld	r5,0x0
8000d1d0:	e0 81 00 85 	brne	8000d2da <_vfprintf_r+0x1db6>
8000d1d4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d1d8:	2f f8       	sub	r8,-1
8000d1da:	30 19       	mov	r9,1
8000d1dc:	fb 48 06 90 	st.w	sp[1680],r8
8000d1e0:	87 06       	st.w	r3[0x0],r6
8000d1e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d1e6:	87 19       	st.w	r3[0x4],r9
8000d1e8:	2f f8       	sub	r8,-1
8000d1ea:	fb 48 06 8c 	st.w	sp[1676],r8
8000d1ee:	58 78       	cp.w	r8,7
8000d1f0:	e0 89 00 04 	brgt	8000d1f8 <_vfprintf_r+0x1cd4>
8000d1f4:	2f 83       	sub	r3,-8
8000d1f6:	c0 b8       	rjmp	8000d20c <_vfprintf_r+0x1ce8>
8000d1f8:	fa ca f9 78 	sub	r10,sp,-1672
8000d1fc:	02 9b       	mov	r11,r1
8000d1fe:	08 9c       	mov	r12,r4
8000d200:	fe b0 f1 84 	rcall	8000b508 <__sprint_r>
8000d204:	e0 81 01 0f 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d208:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d20c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d210:	2f f8       	sub	r8,-1
8000d212:	40 cb       	lddsp	r11,sp[0x30]
8000d214:	fb 48 06 90 	st.w	sp[1680],r8
8000d218:	30 19       	mov	r9,1
8000d21a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d21e:	87 0b       	st.w	r3[0x0],r11
8000d220:	2f f8       	sub	r8,-1
8000d222:	87 19       	st.w	r3[0x4],r9
8000d224:	fb 48 06 8c 	st.w	sp[1676],r8
8000d228:	58 78       	cp.w	r8,7
8000d22a:	e0 89 00 05 	brgt	8000d234 <_vfprintf_r+0x1d10>
8000d22e:	2f 83       	sub	r3,-8
8000d230:	c0 c8       	rjmp	8000d248 <_vfprintf_r+0x1d24>
8000d232:	d7 03       	nop
8000d234:	fa ca f9 78 	sub	r10,sp,-1672
8000d238:	02 9b       	mov	r11,r1
8000d23a:	08 9c       	mov	r12,r4
8000d23c:	fe b0 f1 66 	rcall	8000b508 <__sprint_r>
8000d240:	e0 81 00 f1 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d244:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d248:	30 08       	mov	r8,0
8000d24a:	30 09       	mov	r9,0
8000d24c:	40 5b       	lddsp	r11,sp[0x14]
8000d24e:	40 7a       	lddsp	r10,sp[0x1c]
8000d250:	e0 a0 13 19 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000d254:	40 68       	lddsp	r8,sp[0x18]
8000d256:	20 18       	sub	r8,1
8000d258:	58 0c       	cp.w	r12,0
8000d25a:	c0 d1       	brne	8000d274 <_vfprintf_r+0x1d50>
8000d25c:	2f f6       	sub	r6,-1
8000d25e:	87 18       	st.w	r3[0x4],r8
8000d260:	87 06       	st.w	r3[0x0],r6
8000d262:	fa f6 06 90 	ld.w	r6,sp[1680]
8000d266:	10 06       	add	r6,r8
8000d268:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d26c:	fb 46 06 90 	st.w	sp[1680],r6
8000d270:	2f f8       	sub	r8,-1
8000d272:	c3 18       	rjmp	8000d2d4 <_vfprintf_r+0x1db0>
8000d274:	10 96       	mov	r6,r8
8000d276:	58 08       	cp.w	r8,0
8000d278:	e0 89 00 1c 	brgt	8000d2b0 <_vfprintf_r+0x1d8c>
8000d27c:	c4 b8       	rjmp	8000d312 <_vfprintf_r+0x1dee>
8000d27e:	2f 09       	sub	r9,-16
8000d280:	2f f8       	sub	r8,-1
8000d282:	fb 49 06 90 	st.w	sp[1680],r9
8000d286:	87 02       	st.w	r3[0x0],r2
8000d288:	87 10       	st.w	r3[0x4],r0
8000d28a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d28e:	58 78       	cp.w	r8,7
8000d290:	e0 89 00 04 	brgt	8000d298 <_vfprintf_r+0x1d74>
8000d294:	2f 83       	sub	r3,-8
8000d296:	c0 b8       	rjmp	8000d2ac <_vfprintf_r+0x1d88>
8000d298:	fa ca f9 78 	sub	r10,sp,-1672
8000d29c:	02 9b       	mov	r11,r1
8000d29e:	08 9c       	mov	r12,r4
8000d2a0:	fe b0 f1 34 	rcall	8000b508 <__sprint_r>
8000d2a4:	e0 81 00 bf 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d2a8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d2ac:	21 06       	sub	r6,16
8000d2ae:	c0 48       	rjmp	8000d2b6 <_vfprintf_r+0x1d92>
8000d2b0:	fe c2 c7 d8 	sub	r2,pc,-14376
8000d2b4:	31 00       	mov	r0,16
8000d2b6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d2ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d2be:	fe ca c7 e6 	sub	r10,pc,-14362
8000d2c2:	59 06       	cp.w	r6,16
8000d2c4:	fe 99 ff dd 	brgt	8000d27e <_vfprintf_r+0x1d5a>
8000d2c8:	0c 09       	add	r9,r6
8000d2ca:	87 0a       	st.w	r3[0x0],r10
8000d2cc:	fb 49 06 90 	st.w	sp[1680],r9
8000d2d0:	2f f8       	sub	r8,-1
8000d2d2:	87 16       	st.w	r3[0x4],r6
8000d2d4:	fb 48 06 8c 	st.w	sp[1676],r8
8000d2d8:	c0 e8       	rjmp	8000d2f4 <_vfprintf_r+0x1dd0>
8000d2da:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d2de:	2f f8       	sub	r8,-1
8000d2e0:	30 19       	mov	r9,1
8000d2e2:	fb 48 06 90 	st.w	sp[1680],r8
8000d2e6:	87 06       	st.w	r3[0x0],r6
8000d2e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d2ec:	87 19       	st.w	r3[0x4],r9
8000d2ee:	2f f8       	sub	r8,-1
8000d2f0:	fb 48 06 8c 	st.w	sp[1676],r8
8000d2f4:	58 78       	cp.w	r8,7
8000d2f6:	e0 89 00 04 	brgt	8000d2fe <_vfprintf_r+0x1dda>
8000d2fa:	2f 83       	sub	r3,-8
8000d2fc:	c0 b8       	rjmp	8000d312 <_vfprintf_r+0x1dee>
8000d2fe:	fa ca f9 78 	sub	r10,sp,-1672
8000d302:	02 9b       	mov	r11,r1
8000d304:	08 9c       	mov	r12,r4
8000d306:	fe b0 f1 01 	rcall	8000b508 <__sprint_r>
8000d30a:	e0 81 00 8c 	brne	8000d422 <_vfprintf_r+0x1efe>
8000d30e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d312:	40 ea       	lddsp	r10,sp[0x38]
8000d314:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d318:	14 08       	add	r8,r10
8000d31a:	fa c9 f9 64 	sub	r9,sp,-1692
8000d31e:	fb 48 06 90 	st.w	sp[1680],r8
8000d322:	87 1a       	st.w	r3[0x4],r10
8000d324:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d328:	87 09       	st.w	r3[0x0],r9
8000d32a:	2f f8       	sub	r8,-1
8000d32c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d330:	58 78       	cp.w	r8,7
8000d332:	e0 89 00 04 	brgt	8000d33a <_vfprintf_r+0x1e16>
8000d336:	2f 83       	sub	r3,-8
8000d338:	c0 a8       	rjmp	8000d34c <_vfprintf_r+0x1e28>
8000d33a:	fa ca f9 78 	sub	r10,sp,-1672
8000d33e:	02 9b       	mov	r11,r1
8000d340:	08 9c       	mov	r12,r4
8000d342:	fe b0 f0 e3 	rcall	8000b508 <__sprint_r>
8000d346:	c6 e1       	brne	8000d422 <_vfprintf_r+0x1efe>
8000d348:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d34c:	e2 15 00 04 	andl	r5,0x4,COH
8000d350:	c3 f0       	breq	8000d3ce <_vfprintf_r+0x1eaa>
8000d352:	40 86       	lddsp	r6,sp[0x20]
8000d354:	40 39       	lddsp	r9,sp[0xc]
8000d356:	12 16       	sub	r6,r9
8000d358:	58 06       	cp.w	r6,0
8000d35a:	e0 89 00 1a 	brgt	8000d38e <_vfprintf_r+0x1e6a>
8000d35e:	c3 88       	rjmp	8000d3ce <_vfprintf_r+0x1eaa>
8000d360:	2f 09       	sub	r9,-16
8000d362:	2f f8       	sub	r8,-1
8000d364:	fb 49 06 90 	st.w	sp[1680],r9
8000d368:	87 05       	st.w	r3[0x0],r5
8000d36a:	87 12       	st.w	r3[0x4],r2
8000d36c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d370:	58 78       	cp.w	r8,7
8000d372:	e0 89 00 04 	brgt	8000d37a <_vfprintf_r+0x1e56>
8000d376:	2f 83       	sub	r3,-8
8000d378:	c0 98       	rjmp	8000d38a <_vfprintf_r+0x1e66>
8000d37a:	00 9a       	mov	r10,r0
8000d37c:	02 9b       	mov	r11,r1
8000d37e:	08 9c       	mov	r12,r4
8000d380:	fe b0 f0 c4 	rcall	8000b508 <__sprint_r>
8000d384:	c4 f1       	brne	8000d422 <_vfprintf_r+0x1efe>
8000d386:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d38a:	21 06       	sub	r6,16
8000d38c:	c0 68       	rjmp	8000d398 <_vfprintf_r+0x1e74>
8000d38e:	fe c5 c8 c6 	sub	r5,pc,-14138
8000d392:	31 02       	mov	r2,16
8000d394:	fa c0 f9 78 	sub	r0,sp,-1672
8000d398:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d39c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d3a0:	fe ca c8 d8 	sub	r10,pc,-14120
8000d3a4:	59 06       	cp.w	r6,16
8000d3a6:	fe 99 ff dd 	brgt	8000d360 <_vfprintf_r+0x1e3c>
8000d3aa:	0c 09       	add	r9,r6
8000d3ac:	2f f8       	sub	r8,-1
8000d3ae:	87 0a       	st.w	r3[0x0],r10
8000d3b0:	87 16       	st.w	r3[0x4],r6
8000d3b2:	fb 49 06 90 	st.w	sp[1680],r9
8000d3b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000d3ba:	58 78       	cp.w	r8,7
8000d3bc:	e0 8a 00 09 	brle	8000d3ce <_vfprintf_r+0x1eaa>
8000d3c0:	fa ca f9 78 	sub	r10,sp,-1672
8000d3c4:	02 9b       	mov	r11,r1
8000d3c6:	08 9c       	mov	r12,r4
8000d3c8:	fe b0 f0 a0 	rcall	8000b508 <__sprint_r>
8000d3cc:	c2 b1       	brne	8000d422 <_vfprintf_r+0x1efe>
8000d3ce:	40 bc       	lddsp	r12,sp[0x2c]
8000d3d0:	40 36       	lddsp	r6,sp[0xc]
8000d3d2:	40 8e       	lddsp	lr,sp[0x20]
8000d3d4:	ec 0e 0c 48 	max	r8,r6,lr
8000d3d8:	10 0c       	add	r12,r8
8000d3da:	50 bc       	stdsp	sp[0x2c],r12
8000d3dc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d3e0:	58 08       	cp.w	r8,0
8000d3e2:	c0 80       	breq	8000d3f2 <_vfprintf_r+0x1ece>
8000d3e4:	fa ca f9 78 	sub	r10,sp,-1672
8000d3e8:	02 9b       	mov	r11,r1
8000d3ea:	08 9c       	mov	r12,r4
8000d3ec:	fe b0 f0 8e 	rcall	8000b508 <__sprint_r>
8000d3f0:	c1 91       	brne	8000d422 <_vfprintf_r+0x1efe>
8000d3f2:	30 0b       	mov	r11,0
8000d3f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d3f8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000d3fc:	fe 9f f1 22 	bral	8000b640 <_vfprintf_r+0x11c>
8000d400:	08 95       	mov	r5,r4
8000d402:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d406:	58 08       	cp.w	r8,0
8000d408:	c0 80       	breq	8000d418 <_vfprintf_r+0x1ef4>
8000d40a:	08 9c       	mov	r12,r4
8000d40c:	fa ca f9 78 	sub	r10,sp,-1672
8000d410:	02 9b       	mov	r11,r1
8000d412:	fe b0 f0 7b 	rcall	8000b508 <__sprint_r>
8000d416:	c0 61       	brne	8000d422 <_vfprintf_r+0x1efe>
8000d418:	30 08       	mov	r8,0
8000d41a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d41e:	c0 28       	rjmp	8000d422 <_vfprintf_r+0x1efe>
8000d420:	40 41       	lddsp	r1,sp[0x10]
8000d422:	82 68       	ld.sh	r8,r1[0xc]
8000d424:	ed b8 00 06 	bld	r8,0x6
8000d428:	c0 31       	brne	8000d42e <_vfprintf_r+0x1f0a>
8000d42a:	3f fa       	mov	r10,-1
8000d42c:	50 ba       	stdsp	sp[0x2c],r10
8000d42e:	40 bc       	lddsp	r12,sp[0x2c]
8000d430:	fe 3d f9 44 	sub	sp,-1724
8000d434:	d8 32       	popm	r0-r7,pc
8000d436:	d7 03       	nop

8000d438 <__swsetup_r>:
8000d438:	d4 21       	pushm	r4-r7,lr
8000d43a:	e0 68 0a 4c 	mov	r8,2636
8000d43e:	18 96       	mov	r6,r12
8000d440:	16 97       	mov	r7,r11
8000d442:	70 0c       	ld.w	r12,r8[0x0]
8000d444:	58 0c       	cp.w	r12,0
8000d446:	c0 60       	breq	8000d452 <__swsetup_r+0x1a>
8000d448:	78 68       	ld.w	r8,r12[0x18]
8000d44a:	58 08       	cp.w	r8,0
8000d44c:	c0 31       	brne	8000d452 <__swsetup_r+0x1a>
8000d44e:	e0 a0 07 bf 	rcall	8000e3cc <__sinit>
8000d452:	fe c8 c8 5a 	sub	r8,pc,-14246
8000d456:	10 37       	cp.w	r7,r8
8000d458:	c0 61       	brne	8000d464 <__swsetup_r+0x2c>
8000d45a:	e0 68 0a 4c 	mov	r8,2636
8000d45e:	70 08       	ld.w	r8,r8[0x0]
8000d460:	70 07       	ld.w	r7,r8[0x0]
8000d462:	c1 28       	rjmp	8000d486 <__swsetup_r+0x4e>
8000d464:	fe c8 c8 4c 	sub	r8,pc,-14260
8000d468:	10 37       	cp.w	r7,r8
8000d46a:	c0 61       	brne	8000d476 <__swsetup_r+0x3e>
8000d46c:	e0 68 0a 4c 	mov	r8,2636
8000d470:	70 08       	ld.w	r8,r8[0x0]
8000d472:	70 17       	ld.w	r7,r8[0x4]
8000d474:	c0 98       	rjmp	8000d486 <__swsetup_r+0x4e>
8000d476:	fe c8 c8 3e 	sub	r8,pc,-14274
8000d47a:	10 37       	cp.w	r7,r8
8000d47c:	c0 51       	brne	8000d486 <__swsetup_r+0x4e>
8000d47e:	e0 68 0a 4c 	mov	r8,2636
8000d482:	70 08       	ld.w	r8,r8[0x0]
8000d484:	70 27       	ld.w	r7,r8[0x8]
8000d486:	8e 68       	ld.sh	r8,r7[0xc]
8000d488:	ed b8 00 03 	bld	r8,0x3
8000d48c:	c1 e0       	breq	8000d4c8 <__swsetup_r+0x90>
8000d48e:	ed b8 00 04 	bld	r8,0x4
8000d492:	c3 e1       	brne	8000d50e <__swsetup_r+0xd6>
8000d494:	ed b8 00 02 	bld	r8,0x2
8000d498:	c1 51       	brne	8000d4c2 <__swsetup_r+0x8a>
8000d49a:	6e db       	ld.w	r11,r7[0x34]
8000d49c:	58 0b       	cp.w	r11,0
8000d49e:	c0 a0       	breq	8000d4b2 <__swsetup_r+0x7a>
8000d4a0:	ee c8 ff bc 	sub	r8,r7,-68
8000d4a4:	10 3b       	cp.w	r11,r8
8000d4a6:	c0 40       	breq	8000d4ae <__swsetup_r+0x76>
8000d4a8:	0c 9c       	mov	r12,r6
8000d4aa:	e0 a0 08 2b 	rcall	8000e500 <_free_r>
8000d4ae:	30 08       	mov	r8,0
8000d4b0:	8f d8       	st.w	r7[0x34],r8
8000d4b2:	8e 68       	ld.sh	r8,r7[0xc]
8000d4b4:	e0 18 ff db 	andl	r8,0xffdb
8000d4b8:	ae 68       	st.h	r7[0xc],r8
8000d4ba:	30 08       	mov	r8,0
8000d4bc:	8f 18       	st.w	r7[0x4],r8
8000d4be:	6e 48       	ld.w	r8,r7[0x10]
8000d4c0:	8f 08       	st.w	r7[0x0],r8
8000d4c2:	8e 68       	ld.sh	r8,r7[0xc]
8000d4c4:	a3 b8       	sbr	r8,0x3
8000d4c6:	ae 68       	st.h	r7[0xc],r8
8000d4c8:	6e 48       	ld.w	r8,r7[0x10]
8000d4ca:	58 08       	cp.w	r8,0
8000d4cc:	c0 b1       	brne	8000d4e2 <__swsetup_r+0xaa>
8000d4ce:	8e 68       	ld.sh	r8,r7[0xc]
8000d4d0:	e2 18 02 80 	andl	r8,0x280,COH
8000d4d4:	e0 48 02 00 	cp.w	r8,512
8000d4d8:	c0 50       	breq	8000d4e2 <__swsetup_r+0xaa>
8000d4da:	0c 9c       	mov	r12,r6
8000d4dc:	0e 9b       	mov	r11,r7
8000d4de:	e0 a0 0a 4b 	rcall	8000e974 <__smakebuf_r>
8000d4e2:	8e 69       	ld.sh	r9,r7[0xc]
8000d4e4:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000d4e8:	c0 70       	breq	8000d4f6 <__swsetup_r+0xbe>
8000d4ea:	30 08       	mov	r8,0
8000d4ec:	8f 28       	st.w	r7[0x8],r8
8000d4ee:	6e 58       	ld.w	r8,r7[0x14]
8000d4f0:	5c 38       	neg	r8
8000d4f2:	8f 68       	st.w	r7[0x18],r8
8000d4f4:	c0 68       	rjmp	8000d500 <__swsetup_r+0xc8>
8000d4f6:	ed b9 00 01 	bld	r9,0x1
8000d4fa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000d4fe:	8f 28       	st.w	r7[0x8],r8
8000d500:	6e 48       	ld.w	r8,r7[0x10]
8000d502:	58 08       	cp.w	r8,0
8000d504:	c0 61       	brne	8000d510 <__swsetup_r+0xd8>
8000d506:	8e 68       	ld.sh	r8,r7[0xc]
8000d508:	ed b8 00 07 	bld	r8,0x7
8000d50c:	c0 21       	brne	8000d510 <__swsetup_r+0xd8>
8000d50e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000d510:	d8 2a       	popm	r4-r7,pc,r12=0
8000d512:	d7 03       	nop

8000d514 <quorem>:
8000d514:	d4 31       	pushm	r0-r7,lr
8000d516:	20 2d       	sub	sp,8
8000d518:	18 97       	mov	r7,r12
8000d51a:	78 48       	ld.w	r8,r12[0x10]
8000d51c:	76 46       	ld.w	r6,r11[0x10]
8000d51e:	0c 38       	cp.w	r8,r6
8000d520:	c0 34       	brge	8000d526 <quorem+0x12>
8000d522:	30 0c       	mov	r12,0
8000d524:	c8 58       	rjmp	8000d62e <quorem+0x11a>
8000d526:	ec c2 ff fc 	sub	r2,r6,-4
8000d52a:	f6 c3 ff ec 	sub	r3,r11,-20
8000d52e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000d532:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000d536:	2f f9       	sub	r9,-1
8000d538:	20 16       	sub	r6,1
8000d53a:	f8 09 0d 08 	divu	r8,r12,r9
8000d53e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000d542:	ee c4 ff ec 	sub	r4,r7,-20
8000d546:	10 95       	mov	r5,r8
8000d548:	58 08       	cp.w	r8,0
8000d54a:	c4 10       	breq	8000d5cc <quorem+0xb8>
8000d54c:	30 09       	mov	r9,0
8000d54e:	06 9a       	mov	r10,r3
8000d550:	08 98       	mov	r8,r4
8000d552:	12 91       	mov	r1,r9
8000d554:	50 0b       	stdsp	sp[0x0],r11
8000d556:	70 0e       	ld.w	lr,r8[0x0]
8000d558:	b1 8e       	lsr	lr,0x10
8000d55a:	50 1e       	stdsp	sp[0x4],lr
8000d55c:	15 0e       	ld.w	lr,r10++
8000d55e:	fc 00 16 10 	lsr	r0,lr,0x10
8000d562:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d566:	ea 0e 03 41 	mac	r1,r5,lr
8000d56a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000d56e:	b1 81       	lsr	r1,0x10
8000d570:	40 1b       	lddsp	r11,sp[0x4]
8000d572:	ea 00 02 40 	mul	r0,r5,r0
8000d576:	e2 00 00 00 	add	r0,r1,r0
8000d57a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000d57e:	02 1b       	sub	r11,r1
8000d580:	50 1b       	stdsp	sp[0x4],r11
8000d582:	70 0b       	ld.w	r11,r8[0x0]
8000d584:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000d588:	02 09       	add	r9,r1
8000d58a:	f2 0e 01 0e 	sub	lr,r9,lr
8000d58e:	b0 1e       	st.h	r8[0x2],lr
8000d590:	fc 09 14 10 	asr	r9,lr,0x10
8000d594:	40 1e       	lddsp	lr,sp[0x4]
8000d596:	fc 09 00 09 	add	r9,lr,r9
8000d59a:	b0 09       	st.h	r8[0x0],r9
8000d59c:	e0 01 16 10 	lsr	r1,r0,0x10
8000d5a0:	2f c8       	sub	r8,-4
8000d5a2:	b1 49       	asr	r9,0x10
8000d5a4:	04 3a       	cp.w	r10,r2
8000d5a6:	fe 98 ff d8 	brls	8000d556 <quorem+0x42>
8000d5aa:	40 0b       	lddsp	r11,sp[0x0]
8000d5ac:	58 0c       	cp.w	r12,0
8000d5ae:	c0 f1       	brne	8000d5cc <quorem+0xb8>
8000d5b0:	ec c8 ff fb 	sub	r8,r6,-5
8000d5b4:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d5b8:	c0 28       	rjmp	8000d5bc <quorem+0xa8>
8000d5ba:	20 16       	sub	r6,1
8000d5bc:	20 48       	sub	r8,4
8000d5be:	08 38       	cp.w	r8,r4
8000d5c0:	e0 88 00 05 	brls	8000d5ca <quorem+0xb6>
8000d5c4:	70 09       	ld.w	r9,r8[0x0]
8000d5c6:	58 09       	cp.w	r9,0
8000d5c8:	cf 90       	breq	8000d5ba <quorem+0xa6>
8000d5ca:	8f 46       	st.w	r7[0x10],r6
8000d5cc:	0e 9c       	mov	r12,r7
8000d5ce:	e0 a0 0a d2 	rcall	8000eb72 <__mcmp>
8000d5d2:	c2 d5       	brlt	8000d62c <quorem+0x118>
8000d5d4:	2f f5       	sub	r5,-1
8000d5d6:	08 98       	mov	r8,r4
8000d5d8:	30 09       	mov	r9,0
8000d5da:	07 0b       	ld.w	r11,r3++
8000d5dc:	f6 0a 16 10 	lsr	r10,r11,0x10
8000d5e0:	70 0c       	ld.w	r12,r8[0x0]
8000d5e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d5e6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d5ea:	14 1e       	sub	lr,r10
8000d5ec:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d5f0:	16 1a       	sub	r10,r11
8000d5f2:	12 0a       	add	r10,r9
8000d5f4:	b0 1a       	st.h	r8[0x2],r10
8000d5f6:	b1 4a       	asr	r10,0x10
8000d5f8:	fc 0a 00 09 	add	r9,lr,r10
8000d5fc:	b0 09       	st.h	r8[0x0],r9
8000d5fe:	2f c8       	sub	r8,-4
8000d600:	b1 49       	asr	r9,0x10
8000d602:	04 33       	cp.w	r3,r2
8000d604:	fe 98 ff eb 	brls	8000d5da <quorem+0xc6>
8000d608:	ec c8 ff fb 	sub	r8,r6,-5
8000d60c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000d610:	58 09       	cp.w	r9,0
8000d612:	c0 d1       	brne	8000d62c <quorem+0x118>
8000d614:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d618:	c0 28       	rjmp	8000d61c <quorem+0x108>
8000d61a:	20 16       	sub	r6,1
8000d61c:	20 48       	sub	r8,4
8000d61e:	08 38       	cp.w	r8,r4
8000d620:	e0 88 00 05 	brls	8000d62a <quorem+0x116>
8000d624:	70 09       	ld.w	r9,r8[0x0]
8000d626:	58 09       	cp.w	r9,0
8000d628:	cf 90       	breq	8000d61a <quorem+0x106>
8000d62a:	8f 46       	st.w	r7[0x10],r6
8000d62c:	0a 9c       	mov	r12,r5
8000d62e:	2f ed       	sub	sp,-8
8000d630:	d8 32       	popm	r0-r7,pc
8000d632:	d7 03       	nop

8000d634 <_dtoa_r>:
8000d634:	d4 31       	pushm	r0-r7,lr
8000d636:	21 ad       	sub	sp,104
8000d638:	fa c4 ff 74 	sub	r4,sp,-140
8000d63c:	18 97       	mov	r7,r12
8000d63e:	16 95       	mov	r5,r11
8000d640:	68 2c       	ld.w	r12,r4[0x8]
8000d642:	50 c9       	stdsp	sp[0x30],r9
8000d644:	68 16       	ld.w	r6,r4[0x4]
8000d646:	68 09       	ld.w	r9,r4[0x0]
8000d648:	50 e8       	stdsp	sp[0x38],r8
8000d64a:	14 94       	mov	r4,r10
8000d64c:	51 2c       	stdsp	sp[0x48],r12
8000d64e:	fa e5 00 08 	st.d	sp[8],r4
8000d652:	51 59       	stdsp	sp[0x54],r9
8000d654:	6e 95       	ld.w	r5,r7[0x24]
8000d656:	58 05       	cp.w	r5,0
8000d658:	c0 91       	brne	8000d66a <_dtoa_r+0x36>
8000d65a:	31 0c       	mov	r12,16
8000d65c:	fe b0 e8 d6 	rcall	8000a808 <malloc>
8000d660:	99 35       	st.w	r12[0xc],r5
8000d662:	8f 9c       	st.w	r7[0x24],r12
8000d664:	99 15       	st.w	r12[0x4],r5
8000d666:	99 25       	st.w	r12[0x8],r5
8000d668:	99 05       	st.w	r12[0x0],r5
8000d66a:	6e 99       	ld.w	r9,r7[0x24]
8000d66c:	72 08       	ld.w	r8,r9[0x0]
8000d66e:	58 08       	cp.w	r8,0
8000d670:	c0 f0       	breq	8000d68e <_dtoa_r+0x5a>
8000d672:	72 1a       	ld.w	r10,r9[0x4]
8000d674:	91 1a       	st.w	r8[0x4],r10
8000d676:	30 1a       	mov	r10,1
8000d678:	72 19       	ld.w	r9,r9[0x4]
8000d67a:	f4 09 09 49 	lsl	r9,r10,r9
8000d67e:	10 9b       	mov	r11,r8
8000d680:	91 29       	st.w	r8[0x8],r9
8000d682:	0e 9c       	mov	r12,r7
8000d684:	e0 a0 0a 90 	rcall	8000eba4 <_Bfree>
8000d688:	6e 98       	ld.w	r8,r7[0x24]
8000d68a:	30 09       	mov	r9,0
8000d68c:	91 09       	st.w	r8[0x0],r9
8000d68e:	40 28       	lddsp	r8,sp[0x8]
8000d690:	10 94       	mov	r4,r8
8000d692:	58 08       	cp.w	r8,0
8000d694:	c0 64       	brge	8000d6a0 <_dtoa_r+0x6c>
8000d696:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000d69a:	50 28       	stdsp	sp[0x8],r8
8000d69c:	30 18       	mov	r8,1
8000d69e:	c0 28       	rjmp	8000d6a2 <_dtoa_r+0x6e>
8000d6a0:	30 08       	mov	r8,0
8000d6a2:	8d 08       	st.w	r6[0x0],r8
8000d6a4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000d6a8:	40 26       	lddsp	r6,sp[0x8]
8000d6aa:	0c 98       	mov	r8,r6
8000d6ac:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d6b0:	18 38       	cp.w	r8,r12
8000d6b2:	c2 01       	brne	8000d6f2 <_dtoa_r+0xbe>
8000d6b4:	e0 68 27 0f 	mov	r8,9999
8000d6b8:	41 5b       	lddsp	r11,sp[0x54]
8000d6ba:	97 08       	st.w	r11[0x0],r8
8000d6bc:	40 3a       	lddsp	r10,sp[0xc]
8000d6be:	58 0a       	cp.w	r10,0
8000d6c0:	c0 71       	brne	8000d6ce <_dtoa_r+0x9a>
8000d6c2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000d6c6:	c0 41       	brne	8000d6ce <_dtoa_r+0x9a>
8000d6c8:	fe cc ca e0 	sub	r12,pc,-13600
8000d6cc:	c0 38       	rjmp	8000d6d2 <_dtoa_r+0x9e>
8000d6ce:	fe cc ca da 	sub	r12,pc,-13606
8000d6d2:	41 29       	lddsp	r9,sp[0x48]
8000d6d4:	58 09       	cp.w	r9,0
8000d6d6:	e0 80 05 9a 	breq	8000e20a <_dtoa_r+0xbd6>
8000d6da:	f8 c8 ff fd 	sub	r8,r12,-3
8000d6de:	f8 c9 ff f8 	sub	r9,r12,-8
8000d6e2:	11 8b       	ld.ub	r11,r8[0x0]
8000d6e4:	30 0a       	mov	r10,0
8000d6e6:	41 25       	lddsp	r5,sp[0x48]
8000d6e8:	f4 0b 18 00 	cp.b	r11,r10
8000d6ec:	f2 08 17 10 	movne	r8,r9
8000d6f0:	c1 68       	rjmp	8000d71c <_dtoa_r+0xe8>
8000d6f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000d6f6:	30 08       	mov	r8,0
8000d6f8:	fa eb 00 3c 	st.d	sp[60],r10
8000d6fc:	30 09       	mov	r9,0
8000d6fe:	e0 a0 10 c2 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000d702:	c1 00       	breq	8000d722 <_dtoa_r+0xee>
8000d704:	30 18       	mov	r8,1
8000d706:	41 5a       	lddsp	r10,sp[0x54]
8000d708:	95 08       	st.w	r10[0x0],r8
8000d70a:	fe cc cc 46 	sub	r12,pc,-13242
8000d70e:	41 29       	lddsp	r9,sp[0x48]
8000d710:	f8 08 00 08 	add	r8,r12,r8
8000d714:	58 09       	cp.w	r9,0
8000d716:	e0 80 05 7a 	breq	8000e20a <_dtoa_r+0xbd6>
8000d71a:	12 95       	mov	r5,r9
8000d71c:	8b 08       	st.w	r5[0x0],r8
8000d71e:	e0 8f 05 76 	bral	8000e20a <_dtoa_r+0xbd6>
8000d722:	fa c8 ff 9c 	sub	r8,sp,-100
8000d726:	fa c9 ff a0 	sub	r9,sp,-96
8000d72a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d72e:	0e 9c       	mov	r12,r7
8000d730:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d734:	e0 a0 0a 8a 	rcall	8000ec48 <__d2b>
8000d738:	18 93       	mov	r3,r12
8000d73a:	58 05       	cp.w	r5,0
8000d73c:	c0 d0       	breq	8000d756 <_dtoa_r+0x122>
8000d73e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d742:	30 04       	mov	r4,0
8000d744:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d748:	ea c5 03 ff 	sub	r5,r5,1023
8000d74c:	10 9b       	mov	r11,r8
8000d74e:	51 74       	stdsp	sp[0x5c],r4
8000d750:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d754:	c2 58       	rjmp	8000d79e <_dtoa_r+0x16a>
8000d756:	41 88       	lddsp	r8,sp[0x60]
8000d758:	41 9c       	lddsp	r12,sp[0x64]
8000d75a:	10 0c       	add	r12,r8
8000d75c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d760:	e0 45 00 20 	cp.w	r5,32
8000d764:	e0 8a 00 0e 	brle	8000d780 <_dtoa_r+0x14c>
8000d768:	f8 cc fb ee 	sub	r12,r12,-1042
8000d76c:	40 3b       	lddsp	r11,sp[0xc]
8000d76e:	ea 08 11 40 	rsub	r8,r5,64
8000d772:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d776:	ec 08 09 46 	lsl	r6,r6,r8
8000d77a:	0c 4c       	or	r12,r6
8000d77c:	c0 78       	rjmp	8000d78a <_dtoa_r+0x156>
8000d77e:	d7 03       	nop
8000d780:	ea 0c 11 20 	rsub	r12,r5,32
8000d784:	40 3a       	lddsp	r10,sp[0xc]
8000d786:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d78a:	e0 a0 10 08 	rcall	8000f79a <__avr32_u32_to_f64>
8000d78e:	fc 18 fe 10 	movh	r8,0xfe10
8000d792:	30 19       	mov	r9,1
8000d794:	ea c5 04 33 	sub	r5,r5,1075
8000d798:	f0 0b 00 0b 	add	r11,r8,r11
8000d79c:	51 79       	stdsp	sp[0x5c],r9
8000d79e:	30 08       	mov	r8,0
8000d7a0:	fc 19 3f f8 	movh	r9,0x3ff8
8000d7a4:	e0 a0 0e 90 	rcall	8000f4c4 <__avr32_f64_sub>
8000d7a8:	e0 68 43 61 	mov	r8,17249
8000d7ac:	ea 18 63 6f 	orh	r8,0x636f
8000d7b0:	e0 69 87 a7 	mov	r9,34727
8000d7b4:	ea 19 3f d2 	orh	r9,0x3fd2
8000d7b8:	e0 a0 0d 9a 	rcall	8000f2ec <__avr32_f64_mul>
8000d7bc:	e0 68 c8 b3 	mov	r8,51379
8000d7c0:	ea 18 8b 60 	orh	r8,0x8b60
8000d7c4:	e0 69 8a 28 	mov	r9,35368
8000d7c8:	ea 19 3f c6 	orh	r9,0x3fc6
8000d7cc:	e0 a0 0f 4a 	rcall	8000f660 <__avr32_f64_add>
8000d7d0:	0a 9c       	mov	r12,r5
8000d7d2:	14 90       	mov	r0,r10
8000d7d4:	16 91       	mov	r1,r11
8000d7d6:	e0 a0 0f e6 	rcall	8000f7a2 <__avr32_s32_to_f64>
8000d7da:	e0 68 79 fb 	mov	r8,31227
8000d7de:	ea 18 50 9f 	orh	r8,0x509f
8000d7e2:	e0 69 44 13 	mov	r9,17427
8000d7e6:	ea 19 3f d3 	orh	r9,0x3fd3
8000d7ea:	e0 a0 0d 81 	rcall	8000f2ec <__avr32_f64_mul>
8000d7ee:	14 98       	mov	r8,r10
8000d7f0:	16 99       	mov	r9,r11
8000d7f2:	00 9a       	mov	r10,r0
8000d7f4:	02 9b       	mov	r11,r1
8000d7f6:	e0 a0 0f 35 	rcall	8000f660 <__avr32_f64_add>
8000d7fa:	14 90       	mov	r0,r10
8000d7fc:	16 91       	mov	r1,r11
8000d7fe:	e0 a0 0f bb 	rcall	8000f774 <__avr32_f64_to_s32>
8000d802:	30 08       	mov	r8,0
8000d804:	18 96       	mov	r6,r12
8000d806:	30 09       	mov	r9,0
8000d808:	00 9a       	mov	r10,r0
8000d80a:	02 9b       	mov	r11,r1
8000d80c:	e0 a0 10 82 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000d810:	c0 c0       	breq	8000d828 <_dtoa_r+0x1f4>
8000d812:	0c 9c       	mov	r12,r6
8000d814:	e0 a0 0f c7 	rcall	8000f7a2 <__avr32_s32_to_f64>
8000d818:	14 98       	mov	r8,r10
8000d81a:	16 99       	mov	r9,r11
8000d81c:	00 9a       	mov	r10,r0
8000d81e:	02 9b       	mov	r11,r1
8000d820:	e0 a0 10 31 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000d824:	f7 b6 00 01 	subeq	r6,1
8000d828:	59 66       	cp.w	r6,22
8000d82a:	e0 88 00 05 	brls	8000d834 <_dtoa_r+0x200>
8000d82e:	30 18       	mov	r8,1
8000d830:	51 48       	stdsp	sp[0x50],r8
8000d832:	c1 38       	rjmp	8000d858 <_dtoa_r+0x224>
8000d834:	fe c8 cb 88 	sub	r8,pc,-13432
8000d838:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d83c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d840:	e0 a0 10 68 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000d844:	f9 b4 00 00 	moveq	r4,0
8000d848:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d84c:	f7 b6 01 01 	subne	r6,1
8000d850:	f9 bc 01 00 	movne	r12,0
8000d854:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d858:	41 90       	lddsp	r0,sp[0x64]
8000d85a:	20 10       	sub	r0,1
8000d85c:	0a 10       	sub	r0,r5
8000d85e:	c0 46       	brmi	8000d866 <_dtoa_r+0x232>
8000d860:	50 40       	stdsp	sp[0x10],r0
8000d862:	30 00       	mov	r0,0
8000d864:	c0 48       	rjmp	8000d86c <_dtoa_r+0x238>
8000d866:	30 0b       	mov	r11,0
8000d868:	5c 30       	neg	r0
8000d86a:	50 4b       	stdsp	sp[0x10],r11
8000d86c:	ec 02 11 00 	rsub	r2,r6,0
8000d870:	58 06       	cp.w	r6,0
8000d872:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d876:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d87a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d87e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d882:	f9 b2 04 00 	movge	r2,0
8000d886:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d88a:	f9 b9 05 00 	movlt	r9,0
8000d88e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d892:	40 c8       	lddsp	r8,sp[0x30]
8000d894:	58 98       	cp.w	r8,9
8000d896:	e0 8b 00 20 	brhi	8000d8d6 <_dtoa_r+0x2a2>
8000d89a:	58 58       	cp.w	r8,5
8000d89c:	f9 b4 0a 01 	movle	r4,1
8000d8a0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d8a4:	f7 b5 09 04 	subgt	r5,4
8000d8a8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d8ac:	f9 b4 09 00 	movgt	r4,0
8000d8b0:	40 cc       	lddsp	r12,sp[0x30]
8000d8b2:	58 3c       	cp.w	r12,3
8000d8b4:	c2 d0       	breq	8000d90e <_dtoa_r+0x2da>
8000d8b6:	e0 89 00 05 	brgt	8000d8c0 <_dtoa_r+0x28c>
8000d8ba:	58 2c       	cp.w	r12,2
8000d8bc:	c1 01       	brne	8000d8dc <_dtoa_r+0x2a8>
8000d8be:	c1 88       	rjmp	8000d8ee <_dtoa_r+0x2ba>
8000d8c0:	40 cb       	lddsp	r11,sp[0x30]
8000d8c2:	58 4b       	cp.w	r11,4
8000d8c4:	c0 60       	breq	8000d8d0 <_dtoa_r+0x29c>
8000d8c6:	58 5b       	cp.w	r11,5
8000d8c8:	c0 a1       	brne	8000d8dc <_dtoa_r+0x2a8>
8000d8ca:	30 1a       	mov	r10,1
8000d8cc:	50 da       	stdsp	sp[0x34],r10
8000d8ce:	c2 28       	rjmp	8000d912 <_dtoa_r+0x2de>
8000d8d0:	30 19       	mov	r9,1
8000d8d2:	50 d9       	stdsp	sp[0x34],r9
8000d8d4:	c0 f8       	rjmp	8000d8f2 <_dtoa_r+0x2be>
8000d8d6:	30 08       	mov	r8,0
8000d8d8:	30 14       	mov	r4,1
8000d8da:	50 c8       	stdsp	sp[0x30],r8
8000d8dc:	3f f5       	mov	r5,-1
8000d8de:	30 1c       	mov	r12,1
8000d8e0:	30 0b       	mov	r11,0
8000d8e2:	50 95       	stdsp	sp[0x24],r5
8000d8e4:	50 dc       	stdsp	sp[0x34],r12
8000d8e6:	0a 91       	mov	r1,r5
8000d8e8:	31 28       	mov	r8,18
8000d8ea:	50 eb       	stdsp	sp[0x38],r11
8000d8ec:	c2 08       	rjmp	8000d92c <_dtoa_r+0x2f8>
8000d8ee:	30 0a       	mov	r10,0
8000d8f0:	50 da       	stdsp	sp[0x34],r10
8000d8f2:	40 e9       	lddsp	r9,sp[0x38]
8000d8f4:	58 09       	cp.w	r9,0
8000d8f6:	e0 89 00 07 	brgt	8000d904 <_dtoa_r+0x2d0>
8000d8fa:	30 18       	mov	r8,1
8000d8fc:	50 98       	stdsp	sp[0x24],r8
8000d8fe:	10 91       	mov	r1,r8
8000d900:	50 e8       	stdsp	sp[0x38],r8
8000d902:	c1 58       	rjmp	8000d92c <_dtoa_r+0x2f8>
8000d904:	40 e5       	lddsp	r5,sp[0x38]
8000d906:	50 95       	stdsp	sp[0x24],r5
8000d908:	0a 91       	mov	r1,r5
8000d90a:	0a 98       	mov	r8,r5
8000d90c:	c1 08       	rjmp	8000d92c <_dtoa_r+0x2f8>
8000d90e:	30 0c       	mov	r12,0
8000d910:	50 dc       	stdsp	sp[0x34],r12
8000d912:	40 eb       	lddsp	r11,sp[0x38]
8000d914:	ec 0b 00 0b 	add	r11,r6,r11
8000d918:	50 9b       	stdsp	sp[0x24],r11
8000d91a:	16 98       	mov	r8,r11
8000d91c:	2f f8       	sub	r8,-1
8000d91e:	58 08       	cp.w	r8,0
8000d920:	e0 89 00 05 	brgt	8000d92a <_dtoa_r+0x2f6>
8000d924:	10 91       	mov	r1,r8
8000d926:	30 18       	mov	r8,1
8000d928:	c0 28       	rjmp	8000d92c <_dtoa_r+0x2f8>
8000d92a:	10 91       	mov	r1,r8
8000d92c:	30 09       	mov	r9,0
8000d92e:	6e 9a       	ld.w	r10,r7[0x24]
8000d930:	95 19       	st.w	r10[0x4],r9
8000d932:	30 49       	mov	r9,4
8000d934:	c0 68       	rjmp	8000d940 <_dtoa_r+0x30c>
8000d936:	d7 03       	nop
8000d938:	6a 1a       	ld.w	r10,r5[0x4]
8000d93a:	a1 79       	lsl	r9,0x1
8000d93c:	2f fa       	sub	r10,-1
8000d93e:	8b 1a       	st.w	r5[0x4],r10
8000d940:	6e 95       	ld.w	r5,r7[0x24]
8000d942:	f2 ca ff ec 	sub	r10,r9,-20
8000d946:	10 3a       	cp.w	r10,r8
8000d948:	fe 98 ff f8 	brls	8000d938 <_dtoa_r+0x304>
8000d94c:	6a 1b       	ld.w	r11,r5[0x4]
8000d94e:	0e 9c       	mov	r12,r7
8000d950:	e0 a0 09 44 	rcall	8000ebd8 <_Balloc>
8000d954:	58 e1       	cp.w	r1,14
8000d956:	5f 88       	srls	r8
8000d958:	8b 0c       	st.w	r5[0x0],r12
8000d95a:	f1 e4 00 04 	and	r4,r8,r4
8000d95e:	6e 98       	ld.w	r8,r7[0x24]
8000d960:	70 08       	ld.w	r8,r8[0x0]
8000d962:	50 88       	stdsp	sp[0x20],r8
8000d964:	e0 80 01 82 	breq	8000dc68 <_dtoa_r+0x634>
8000d968:	58 06       	cp.w	r6,0
8000d96a:	e0 8a 00 43 	brle	8000d9f0 <_dtoa_r+0x3bc>
8000d96e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d972:	fe c8 cc c6 	sub	r8,pc,-13114
8000d976:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d97a:	fa e5 00 18 	st.d	sp[24],r4
8000d97e:	ec 04 14 04 	asr	r4,r6,0x4
8000d982:	ed b4 00 04 	bld	r4,0x4
8000d986:	c0 30       	breq	8000d98c <_dtoa_r+0x358>
8000d988:	30 25       	mov	r5,2
8000d98a:	c1 08       	rjmp	8000d9aa <_dtoa_r+0x376>
8000d98c:	fe c8 cc 18 	sub	r8,pc,-13288
8000d990:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d994:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d998:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d99c:	e0 a0 0f ee 	rcall	8000f978 <__avr32_f64_div>
8000d9a0:	30 35       	mov	r5,3
8000d9a2:	14 98       	mov	r8,r10
8000d9a4:	16 99       	mov	r9,r11
8000d9a6:	fa e9 00 08 	st.d	sp[8],r8
8000d9aa:	fe cc cc 36 	sub	r12,pc,-13258
8000d9ae:	50 a3       	stdsp	sp[0x28],r3
8000d9b0:	0c 93       	mov	r3,r6
8000d9b2:	18 96       	mov	r6,r12
8000d9b4:	c0 f8       	rjmp	8000d9d2 <_dtoa_r+0x39e>
8000d9b6:	fa ea 00 18 	ld.d	r10,sp[24]
8000d9ba:	ed b4 00 00 	bld	r4,0x0
8000d9be:	c0 81       	brne	8000d9ce <_dtoa_r+0x39a>
8000d9c0:	ec e8 00 00 	ld.d	r8,r6[0]
8000d9c4:	2f f5       	sub	r5,-1
8000d9c6:	e0 a0 0c 93 	rcall	8000f2ec <__avr32_f64_mul>
8000d9ca:	fa eb 00 18 	st.d	sp[24],r10
8000d9ce:	a1 54       	asr	r4,0x1
8000d9d0:	2f 86       	sub	r6,-8
8000d9d2:	58 04       	cp.w	r4,0
8000d9d4:	cf 11       	brne	8000d9b6 <_dtoa_r+0x382>
8000d9d6:	fa e8 00 18 	ld.d	r8,sp[24]
8000d9da:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9de:	06 96       	mov	r6,r3
8000d9e0:	e0 a0 0f cc 	rcall	8000f978 <__avr32_f64_div>
8000d9e4:	40 a3       	lddsp	r3,sp[0x28]
8000d9e6:	14 98       	mov	r8,r10
8000d9e8:	16 99       	mov	r9,r11
8000d9ea:	fa e9 00 08 	st.d	sp[8],r8
8000d9ee:	c2 f8       	rjmp	8000da4c <_dtoa_r+0x418>
8000d9f0:	ec 08 11 00 	rsub	r8,r6,0
8000d9f4:	c0 31       	brne	8000d9fa <_dtoa_r+0x3c6>
8000d9f6:	30 25       	mov	r5,2
8000d9f8:	c2 a8       	rjmp	8000da4c <_dtoa_r+0x418>
8000d9fa:	fe cc cc 86 	sub	r12,pc,-13178
8000d9fe:	f0 04 14 04 	asr	r4,r8,0x4
8000da02:	50 1c       	stdsp	sp[0x4],r12
8000da04:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000da08:	fe c9 cd 5c 	sub	r9,pc,-12964
8000da0c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000da10:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000da14:	e0 a0 0c 6c 	rcall	8000f2ec <__avr32_f64_mul>
8000da18:	40 1c       	lddsp	r12,sp[0x4]
8000da1a:	50 63       	stdsp	sp[0x18],r3
8000da1c:	30 25       	mov	r5,2
8000da1e:	0c 93       	mov	r3,r6
8000da20:	fa eb 00 08 	st.d	sp[8],r10
8000da24:	18 96       	mov	r6,r12
8000da26:	c0 f8       	rjmp	8000da44 <_dtoa_r+0x410>
8000da28:	fa ea 00 08 	ld.d	r10,sp[8]
8000da2c:	ed b4 00 00 	bld	r4,0x0
8000da30:	c0 81       	brne	8000da40 <_dtoa_r+0x40c>
8000da32:	ec e8 00 00 	ld.d	r8,r6[0]
8000da36:	2f f5       	sub	r5,-1
8000da38:	e0 a0 0c 5a 	rcall	8000f2ec <__avr32_f64_mul>
8000da3c:	fa eb 00 08 	st.d	sp[8],r10
8000da40:	a1 54       	asr	r4,0x1
8000da42:	2f 86       	sub	r6,-8
8000da44:	58 04       	cp.w	r4,0
8000da46:	cf 11       	brne	8000da28 <_dtoa_r+0x3f4>
8000da48:	06 96       	mov	r6,r3
8000da4a:	40 63       	lddsp	r3,sp[0x18]
8000da4c:	41 4a       	lddsp	r10,sp[0x50]
8000da4e:	58 0a       	cp.w	r10,0
8000da50:	c2 a0       	breq	8000daa4 <_dtoa_r+0x470>
8000da52:	fa e8 00 08 	ld.d	r8,sp[8]
8000da56:	58 01       	cp.w	r1,0
8000da58:	5f 94       	srgt	r4
8000da5a:	fa e9 00 18 	st.d	sp[24],r8
8000da5e:	30 08       	mov	r8,0
8000da60:	fc 19 3f f0 	movh	r9,0x3ff0
8000da64:	fa ea 00 18 	ld.d	r10,sp[24]
8000da68:	e0 a0 0f 54 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000da6c:	f9 bc 00 00 	moveq	r12,0
8000da70:	f9 bc 01 01 	movne	r12,1
8000da74:	e9 ec 00 0c 	and	r12,r4,r12
8000da78:	c1 60       	breq	8000daa4 <_dtoa_r+0x470>
8000da7a:	40 98       	lddsp	r8,sp[0x24]
8000da7c:	58 08       	cp.w	r8,0
8000da7e:	e0 8a 00 f1 	brle	8000dc60 <_dtoa_r+0x62c>
8000da82:	30 08       	mov	r8,0
8000da84:	fc 19 40 24 	movh	r9,0x4024
8000da88:	ec c4 00 01 	sub	r4,r6,1
8000da8c:	fa ea 00 18 	ld.d	r10,sp[24]
8000da90:	2f f5       	sub	r5,-1
8000da92:	50 64       	stdsp	sp[0x18],r4
8000da94:	e0 a0 0c 2c 	rcall	8000f2ec <__avr32_f64_mul>
8000da98:	40 94       	lddsp	r4,sp[0x24]
8000da9a:	14 98       	mov	r8,r10
8000da9c:	16 99       	mov	r9,r11
8000da9e:	fa e9 00 08 	st.d	sp[8],r8
8000daa2:	c0 38       	rjmp	8000daa8 <_dtoa_r+0x474>
8000daa4:	50 66       	stdsp	sp[0x18],r6
8000daa6:	02 94       	mov	r4,r1
8000daa8:	0a 9c       	mov	r12,r5
8000daaa:	e0 a0 0e 7c 	rcall	8000f7a2 <__avr32_s32_to_f64>
8000daae:	fa e8 00 08 	ld.d	r8,sp[8]
8000dab2:	e0 a0 0c 1d 	rcall	8000f2ec <__avr32_f64_mul>
8000dab6:	30 08       	mov	r8,0
8000dab8:	fc 19 40 1c 	movh	r9,0x401c
8000dabc:	e0 a0 0d d2 	rcall	8000f660 <__avr32_f64_add>
8000dac0:	14 98       	mov	r8,r10
8000dac2:	16 99       	mov	r9,r11
8000dac4:	fa e9 00 28 	st.d	sp[40],r8
8000dac8:	fc 18 fc c0 	movh	r8,0xfcc0
8000dacc:	40 a5       	lddsp	r5,sp[0x28]
8000dace:	10 05       	add	r5,r8
8000dad0:	50 a5       	stdsp	sp[0x28],r5
8000dad2:	58 04       	cp.w	r4,0
8000dad4:	c2 11       	brne	8000db16 <_dtoa_r+0x4e2>
8000dad6:	fa ea 00 08 	ld.d	r10,sp[8]
8000dada:	30 08       	mov	r8,0
8000dadc:	fc 19 40 14 	movh	r9,0x4014
8000dae0:	e0 a0 0c f2 	rcall	8000f4c4 <__avr32_f64_sub>
8000dae4:	40 bc       	lddsp	r12,sp[0x2c]
8000dae6:	fa eb 00 08 	st.d	sp[8],r10
8000daea:	14 98       	mov	r8,r10
8000daec:	16 99       	mov	r9,r11
8000daee:	18 9a       	mov	r10,r12
8000daf0:	0a 9b       	mov	r11,r5
8000daf2:	e0 a0 0f 0f 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000daf6:	e0 81 02 54 	brne	8000df9e <_dtoa_r+0x96a>
8000dafa:	0a 98       	mov	r8,r5
8000dafc:	40 b9       	lddsp	r9,sp[0x2c]
8000dafe:	ee 18 80 00 	eorh	r8,0x8000
8000db02:	fa ea 00 08 	ld.d	r10,sp[8]
8000db06:	10 95       	mov	r5,r8
8000db08:	12 98       	mov	r8,r9
8000db0a:	0a 99       	mov	r9,r5
8000db0c:	e0 a0 0f 02 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000db10:	e0 81 02 3e 	brne	8000df8c <_dtoa_r+0x958>
8000db14:	ca 68       	rjmp	8000dc60 <_dtoa_r+0x62c>
8000db16:	fe c9 ce 6a 	sub	r9,pc,-12694
8000db1a:	e8 c8 00 01 	sub	r8,r4,1
8000db1e:	40 d5       	lddsp	r5,sp[0x34]
8000db20:	58 05       	cp.w	r5,0
8000db22:	c4 f0       	breq	8000dbc0 <_dtoa_r+0x58c>
8000db24:	30 0c       	mov	r12,0
8000db26:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000db2a:	51 3c       	stdsp	sp[0x4c],r12
8000db2c:	30 0a       	mov	r10,0
8000db2e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000db32:	e0 a0 0f 23 	rcall	8000f978 <__avr32_f64_div>
8000db36:	fa e8 00 28 	ld.d	r8,sp[40]
8000db3a:	40 85       	lddsp	r5,sp[0x20]
8000db3c:	e0 a0 0c c4 	rcall	8000f4c4 <__avr32_f64_sub>
8000db40:	fa eb 00 28 	st.d	sp[40],r10
8000db44:	fa ea 00 08 	ld.d	r10,sp[8]
8000db48:	e0 a0 0e 16 	rcall	8000f774 <__avr32_f64_to_s32>
8000db4c:	51 6c       	stdsp	sp[0x58],r12
8000db4e:	e0 a0 0e 2a 	rcall	8000f7a2 <__avr32_s32_to_f64>
8000db52:	14 98       	mov	r8,r10
8000db54:	16 99       	mov	r9,r11
8000db56:	fa ea 00 08 	ld.d	r10,sp[8]
8000db5a:	e0 a0 0c b5 	rcall	8000f4c4 <__avr32_f64_sub>
8000db5e:	fa eb 00 08 	st.d	sp[8],r10
8000db62:	41 68       	lddsp	r8,sp[0x58]
8000db64:	2d 08       	sub	r8,-48
8000db66:	0a c8       	st.b	r5++,r8
8000db68:	41 39       	lddsp	r9,sp[0x4c]
8000db6a:	2f f9       	sub	r9,-1
8000db6c:	51 39       	stdsp	sp[0x4c],r9
8000db6e:	fa e8 00 28 	ld.d	r8,sp[40]
8000db72:	e0 a0 0e cf 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000db76:	e0 81 03 39 	brne	8000e1e8 <_dtoa_r+0xbb4>
8000db7a:	fa e8 00 08 	ld.d	r8,sp[8]
8000db7e:	30 0a       	mov	r10,0
8000db80:	fc 1b 3f f0 	movh	r11,0x3ff0
8000db84:	e0 a0 0c a0 	rcall	8000f4c4 <__avr32_f64_sub>
8000db88:	fa e8 00 28 	ld.d	r8,sp[40]
8000db8c:	e0 a0 0e c2 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000db90:	fa ea 00 28 	ld.d	r10,sp[40]
8000db94:	30 08       	mov	r8,0
8000db96:	fc 19 40 24 	movh	r9,0x4024
8000db9a:	e0 81 00 da 	brne	8000dd4e <_dtoa_r+0x71a>
8000db9e:	41 3c       	lddsp	r12,sp[0x4c]
8000dba0:	08 3c       	cp.w	r12,r4
8000dba2:	c5 f4       	brge	8000dc60 <_dtoa_r+0x62c>
8000dba4:	e0 a0 0b a4 	rcall	8000f2ec <__avr32_f64_mul>
8000dba8:	30 08       	mov	r8,0
8000dbaa:	fa eb 00 28 	st.d	sp[40],r10
8000dbae:	fc 19 40 24 	movh	r9,0x4024
8000dbb2:	fa ea 00 08 	ld.d	r10,sp[8]
8000dbb6:	e0 a0 0b 9b 	rcall	8000f2ec <__avr32_f64_mul>
8000dbba:	fa eb 00 08 	st.d	sp[8],r10
8000dbbe:	cc 3b       	rjmp	8000db44 <_dtoa_r+0x510>
8000dbc0:	40 85       	lddsp	r5,sp[0x20]
8000dbc2:	08 05       	add	r5,r4
8000dbc4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000dbc8:	51 35       	stdsp	sp[0x4c],r5
8000dbca:	fa e8 00 28 	ld.d	r8,sp[40]
8000dbce:	40 85       	lddsp	r5,sp[0x20]
8000dbd0:	e0 a0 0b 8e 	rcall	8000f2ec <__avr32_f64_mul>
8000dbd4:	fa eb 00 28 	st.d	sp[40],r10
8000dbd8:	fa ea 00 08 	ld.d	r10,sp[8]
8000dbdc:	e0 a0 0d cc 	rcall	8000f774 <__avr32_f64_to_s32>
8000dbe0:	51 6c       	stdsp	sp[0x58],r12
8000dbe2:	e0 a0 0d e0 	rcall	8000f7a2 <__avr32_s32_to_f64>
8000dbe6:	14 98       	mov	r8,r10
8000dbe8:	16 99       	mov	r9,r11
8000dbea:	fa ea 00 08 	ld.d	r10,sp[8]
8000dbee:	e0 a0 0c 6b 	rcall	8000f4c4 <__avr32_f64_sub>
8000dbf2:	fa eb 00 08 	st.d	sp[8],r10
8000dbf6:	41 68       	lddsp	r8,sp[0x58]
8000dbf8:	2d 08       	sub	r8,-48
8000dbfa:	0a c8       	st.b	r5++,r8
8000dbfc:	41 3c       	lddsp	r12,sp[0x4c]
8000dbfe:	18 35       	cp.w	r5,r12
8000dc00:	c2 81       	brne	8000dc50 <_dtoa_r+0x61c>
8000dc02:	30 08       	mov	r8,0
8000dc04:	fc 19 3f e0 	movh	r9,0x3fe0
8000dc08:	fa ea 00 28 	ld.d	r10,sp[40]
8000dc0c:	e0 a0 0d 2a 	rcall	8000f660 <__avr32_f64_add>
8000dc10:	40 85       	lddsp	r5,sp[0x20]
8000dc12:	fa e8 00 08 	ld.d	r8,sp[8]
8000dc16:	08 05       	add	r5,r4
8000dc18:	e0 a0 0e 7c 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000dc1c:	e0 81 00 99 	brne	8000dd4e <_dtoa_r+0x71a>
8000dc20:	fa e8 00 28 	ld.d	r8,sp[40]
8000dc24:	30 0a       	mov	r10,0
8000dc26:	fc 1b 3f e0 	movh	r11,0x3fe0
8000dc2a:	e0 a0 0c 4d 	rcall	8000f4c4 <__avr32_f64_sub>
8000dc2e:	14 98       	mov	r8,r10
8000dc30:	16 99       	mov	r9,r11
8000dc32:	fa ea 00 08 	ld.d	r10,sp[8]
8000dc36:	e0 a0 0e 6d 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000dc3a:	c1 30       	breq	8000dc60 <_dtoa_r+0x62c>
8000dc3c:	33 09       	mov	r9,48
8000dc3e:	0a 98       	mov	r8,r5
8000dc40:	11 7a       	ld.ub	r10,--r8
8000dc42:	f2 0a 18 00 	cp.b	r10,r9
8000dc46:	e0 81 02 d1 	brne	8000e1e8 <_dtoa_r+0xbb4>
8000dc4a:	10 95       	mov	r5,r8
8000dc4c:	cf 9b       	rjmp	8000dc3e <_dtoa_r+0x60a>
8000dc4e:	d7 03       	nop
8000dc50:	30 08       	mov	r8,0
8000dc52:	fc 19 40 24 	movh	r9,0x4024
8000dc56:	e0 a0 0b 4b 	rcall	8000f2ec <__avr32_f64_mul>
8000dc5a:	fa eb 00 08 	st.d	sp[8],r10
8000dc5e:	cb db       	rjmp	8000dbd8 <_dtoa_r+0x5a4>
8000dc60:	fa ea 00 3c 	ld.d	r10,sp[60]
8000dc64:	fa eb 00 08 	st.d	sp[8],r10
8000dc68:	58 e6       	cp.w	r6,14
8000dc6a:	5f ab       	srle	r11
8000dc6c:	41 8a       	lddsp	r10,sp[0x60]
8000dc6e:	30 08       	mov	r8,0
8000dc70:	f4 09 11 ff 	rsub	r9,r10,-1
8000dc74:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000dc78:	f0 09 18 00 	cp.b	r9,r8
8000dc7c:	e0 80 00 82 	breq	8000dd80 <_dtoa_r+0x74c>
8000dc80:	40 ea       	lddsp	r10,sp[0x38]
8000dc82:	58 01       	cp.w	r1,0
8000dc84:	5f a9       	srle	r9
8000dc86:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000dc8a:	fe ca cf de 	sub	r10,pc,-12322
8000dc8e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000dc92:	fa e5 00 10 	st.d	sp[16],r4
8000dc96:	f0 09 18 00 	cp.b	r9,r8
8000dc9a:	c1 40       	breq	8000dcc2 <_dtoa_r+0x68e>
8000dc9c:	58 01       	cp.w	r1,0
8000dc9e:	e0 81 01 77 	brne	8000df8c <_dtoa_r+0x958>
8000dca2:	30 08       	mov	r8,0
8000dca4:	fc 19 40 14 	movh	r9,0x4014
8000dca8:	08 9a       	mov	r10,r4
8000dcaa:	0a 9b       	mov	r11,r5
8000dcac:	e0 a0 0b 20 	rcall	8000f2ec <__avr32_f64_mul>
8000dcb0:	fa e8 00 08 	ld.d	r8,sp[8]
8000dcb4:	e0 a0 0d fa 	rcall	8000f8a8 <__avr32_f64_cmp_ge>
8000dcb8:	e0 81 01 6a 	brne	8000df8c <_dtoa_r+0x958>
8000dcbc:	02 92       	mov	r2,r1
8000dcbe:	e0 8f 01 72 	bral	8000dfa2 <_dtoa_r+0x96e>
8000dcc2:	40 85       	lddsp	r5,sp[0x20]
8000dcc4:	30 14       	mov	r4,1
8000dcc6:	fa e8 00 10 	ld.d	r8,sp[16]
8000dcca:	fa ea 00 08 	ld.d	r10,sp[8]
8000dcce:	e0 a0 0e 55 	rcall	8000f978 <__avr32_f64_div>
8000dcd2:	e0 a0 0d 51 	rcall	8000f774 <__avr32_f64_to_s32>
8000dcd6:	18 92       	mov	r2,r12
8000dcd8:	e0 a0 0d 65 	rcall	8000f7a2 <__avr32_s32_to_f64>
8000dcdc:	fa e8 00 10 	ld.d	r8,sp[16]
8000dce0:	e0 a0 0b 06 	rcall	8000f2ec <__avr32_f64_mul>
8000dce4:	14 98       	mov	r8,r10
8000dce6:	16 99       	mov	r9,r11
8000dce8:	fa ea 00 08 	ld.d	r10,sp[8]
8000dcec:	e0 a0 0b ec 	rcall	8000f4c4 <__avr32_f64_sub>
8000dcf0:	fa eb 00 08 	st.d	sp[8],r10
8000dcf4:	e4 c8 ff d0 	sub	r8,r2,-48
8000dcf8:	0a c8       	st.b	r5++,r8
8000dcfa:	fc 19 40 24 	movh	r9,0x4024
8000dcfe:	30 08       	mov	r8,0
8000dd00:	02 34       	cp.w	r4,r1
8000dd02:	c3 31       	brne	8000dd68 <_dtoa_r+0x734>
8000dd04:	fa e8 00 08 	ld.d	r8,sp[8]
8000dd08:	e0 a0 0c ac 	rcall	8000f660 <__avr32_f64_add>
8000dd0c:	16 91       	mov	r1,r11
8000dd0e:	14 90       	mov	r0,r10
8000dd10:	14 98       	mov	r8,r10
8000dd12:	02 99       	mov	r9,r1
8000dd14:	fa ea 00 10 	ld.d	r10,sp[16]
8000dd18:	e0 a0 0d fc 	rcall	8000f910 <__avr32_f64_cmp_lt>
8000dd1c:	c1 a1       	brne	8000dd50 <_dtoa_r+0x71c>
8000dd1e:	fa e8 00 10 	ld.d	r8,sp[16]
8000dd22:	00 9a       	mov	r10,r0
8000dd24:	02 9b       	mov	r11,r1
8000dd26:	e0 a0 0d ae 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000dd2a:	e0 80 02 5e 	breq	8000e1e6 <_dtoa_r+0xbb2>
8000dd2e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000dd32:	c0 f1       	brne	8000dd50 <_dtoa_r+0x71c>
8000dd34:	e0 8f 02 59 	bral	8000e1e6 <_dtoa_r+0xbb2>
8000dd38:	40 8a       	lddsp	r10,sp[0x20]
8000dd3a:	14 38       	cp.w	r8,r10
8000dd3c:	c0 30       	breq	8000dd42 <_dtoa_r+0x70e>
8000dd3e:	10 95       	mov	r5,r8
8000dd40:	c0 98       	rjmp	8000dd52 <_dtoa_r+0x71e>
8000dd42:	33 08       	mov	r8,48
8000dd44:	40 89       	lddsp	r9,sp[0x20]
8000dd46:	2f f6       	sub	r6,-1
8000dd48:	b2 88       	st.b	r9[0x0],r8
8000dd4a:	40 88       	lddsp	r8,sp[0x20]
8000dd4c:	c0 88       	rjmp	8000dd5c <_dtoa_r+0x728>
8000dd4e:	40 66       	lddsp	r6,sp[0x18]
8000dd50:	33 99       	mov	r9,57
8000dd52:	0a 98       	mov	r8,r5
8000dd54:	11 7a       	ld.ub	r10,--r8
8000dd56:	f2 0a 18 00 	cp.b	r10,r9
8000dd5a:	ce f0       	breq	8000dd38 <_dtoa_r+0x704>
8000dd5c:	50 66       	stdsp	sp[0x18],r6
8000dd5e:	11 89       	ld.ub	r9,r8[0x0]
8000dd60:	2f f9       	sub	r9,-1
8000dd62:	b0 89       	st.b	r8[0x0],r9
8000dd64:	e0 8f 02 42 	bral	8000e1e8 <_dtoa_r+0xbb4>
8000dd68:	e0 a0 0a c2 	rcall	8000f2ec <__avr32_f64_mul>
8000dd6c:	2f f4       	sub	r4,-1
8000dd6e:	fa eb 00 08 	st.d	sp[8],r10
8000dd72:	30 08       	mov	r8,0
8000dd74:	30 09       	mov	r9,0
8000dd76:	e0 a0 0d 86 	rcall	8000f882 <__avr32_f64_cmp_eq>
8000dd7a:	ca 60       	breq	8000dcc6 <_dtoa_r+0x692>
8000dd7c:	e0 8f 02 35 	bral	8000e1e6 <_dtoa_r+0xbb2>
8000dd80:	40 d8       	lddsp	r8,sp[0x34]
8000dd82:	58 08       	cp.w	r8,0
8000dd84:	c0 51       	brne	8000dd8e <_dtoa_r+0x75a>
8000dd86:	04 98       	mov	r8,r2
8000dd88:	00 95       	mov	r5,r0
8000dd8a:	40 d4       	lddsp	r4,sp[0x34]
8000dd8c:	c3 78       	rjmp	8000ddfa <_dtoa_r+0x7c6>
8000dd8e:	40 c5       	lddsp	r5,sp[0x30]
8000dd90:	58 15       	cp.w	r5,1
8000dd92:	e0 89 00 0f 	brgt	8000ddb0 <_dtoa_r+0x77c>
8000dd96:	41 74       	lddsp	r4,sp[0x5c]
8000dd98:	58 04       	cp.w	r4,0
8000dd9a:	c0 40       	breq	8000dda2 <_dtoa_r+0x76e>
8000dd9c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000dda0:	c0 48       	rjmp	8000dda8 <_dtoa_r+0x774>
8000dda2:	41 99       	lddsp	r9,sp[0x64]
8000dda4:	f2 09 11 36 	rsub	r9,r9,54
8000dda8:	04 98       	mov	r8,r2
8000ddaa:	00 95       	mov	r5,r0
8000ddac:	c1 c8       	rjmp	8000dde4 <_dtoa_r+0x7b0>
8000ddae:	d7 03       	nop
8000ddb0:	e2 c8 00 01 	sub	r8,r1,1
8000ddb4:	58 01       	cp.w	r1,0
8000ddb6:	e0 05 17 40 	movge	r5,r0
8000ddba:	e2 09 17 40 	movge	r9,r1
8000ddbe:	e1 d1 e5 15 	sublt	r5,r0,r1
8000ddc2:	f9 b9 05 00 	movlt	r9,0
8000ddc6:	10 32       	cp.w	r2,r8
8000ddc8:	e5 d8 e4 18 	subge	r8,r2,r8
8000ddcc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000ddd0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000ddd4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000ddd8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000dddc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000dde0:	f9 b8 05 00 	movlt	r8,0
8000dde4:	40 4b       	lddsp	r11,sp[0x10]
8000dde6:	12 0b       	add	r11,r9
8000dde8:	50 08       	stdsp	sp[0x0],r8
8000ddea:	50 4b       	stdsp	sp[0x10],r11
8000ddec:	12 00       	add	r0,r9
8000ddee:	30 1b       	mov	r11,1
8000ddf0:	0e 9c       	mov	r12,r7
8000ddf2:	e0 a0 08 a7 	rcall	8000ef40 <__i2b>
8000ddf6:	40 08       	lddsp	r8,sp[0x0]
8000ddf8:	18 94       	mov	r4,r12
8000ddfa:	40 4a       	lddsp	r10,sp[0x10]
8000ddfc:	58 05       	cp.w	r5,0
8000ddfe:	5f 99       	srgt	r9
8000de00:	58 0a       	cp.w	r10,0
8000de02:	5f 9a       	srgt	r10
8000de04:	f5 e9 00 09 	and	r9,r10,r9
8000de08:	c0 80       	breq	8000de18 <_dtoa_r+0x7e4>
8000de0a:	40 4c       	lddsp	r12,sp[0x10]
8000de0c:	f8 05 0d 49 	min	r9,r12,r5
8000de10:	12 1c       	sub	r12,r9
8000de12:	12 10       	sub	r0,r9
8000de14:	50 4c       	stdsp	sp[0x10],r12
8000de16:	12 15       	sub	r5,r9
8000de18:	58 02       	cp.w	r2,0
8000de1a:	e0 8a 00 27 	brle	8000de68 <_dtoa_r+0x834>
8000de1e:	40 db       	lddsp	r11,sp[0x34]
8000de20:	58 0b       	cp.w	r11,0
8000de22:	c1 d0       	breq	8000de5c <_dtoa_r+0x828>
8000de24:	58 08       	cp.w	r8,0
8000de26:	e0 8a 00 17 	brle	8000de54 <_dtoa_r+0x820>
8000de2a:	10 9a       	mov	r10,r8
8000de2c:	50 08       	stdsp	sp[0x0],r8
8000de2e:	08 9b       	mov	r11,r4
8000de30:	0e 9c       	mov	r12,r7
8000de32:	e0 a0 08 cd 	rcall	8000efcc <__pow5mult>
8000de36:	06 9a       	mov	r10,r3
8000de38:	18 9b       	mov	r11,r12
8000de3a:	18 94       	mov	r4,r12
8000de3c:	0e 9c       	mov	r12,r7
8000de3e:	e0 a0 08 01 	rcall	8000ee40 <__multiply>
8000de42:	18 99       	mov	r9,r12
8000de44:	06 9b       	mov	r11,r3
8000de46:	50 19       	stdsp	sp[0x4],r9
8000de48:	0e 9c       	mov	r12,r7
8000de4a:	e0 a0 06 ad 	rcall	8000eba4 <_Bfree>
8000de4e:	40 19       	lddsp	r9,sp[0x4]
8000de50:	40 08       	lddsp	r8,sp[0x0]
8000de52:	12 93       	mov	r3,r9
8000de54:	e4 08 01 0a 	sub	r10,r2,r8
8000de58:	c0 80       	breq	8000de68 <_dtoa_r+0x834>
8000de5a:	c0 28       	rjmp	8000de5e <_dtoa_r+0x82a>
8000de5c:	04 9a       	mov	r10,r2
8000de5e:	06 9b       	mov	r11,r3
8000de60:	0e 9c       	mov	r12,r7
8000de62:	e0 a0 08 b5 	rcall	8000efcc <__pow5mult>
8000de66:	18 93       	mov	r3,r12
8000de68:	30 1b       	mov	r11,1
8000de6a:	0e 9c       	mov	r12,r7
8000de6c:	e0 a0 08 6a 	rcall	8000ef40 <__i2b>
8000de70:	41 1a       	lddsp	r10,sp[0x44]
8000de72:	18 92       	mov	r2,r12
8000de74:	58 0a       	cp.w	r10,0
8000de76:	e0 8a 00 07 	brle	8000de84 <_dtoa_r+0x850>
8000de7a:	18 9b       	mov	r11,r12
8000de7c:	0e 9c       	mov	r12,r7
8000de7e:	e0 a0 08 a7 	rcall	8000efcc <__pow5mult>
8000de82:	18 92       	mov	r2,r12
8000de84:	40 c9       	lddsp	r9,sp[0x30]
8000de86:	58 19       	cp.w	r9,1
8000de88:	e0 89 00 14 	brgt	8000deb0 <_dtoa_r+0x87c>
8000de8c:	40 38       	lddsp	r8,sp[0xc]
8000de8e:	58 08       	cp.w	r8,0
8000de90:	c1 01       	brne	8000deb0 <_dtoa_r+0x87c>
8000de92:	40 29       	lddsp	r9,sp[0x8]
8000de94:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000de98:	c0 c1       	brne	8000deb0 <_dtoa_r+0x87c>
8000de9a:	12 98       	mov	r8,r9
8000de9c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000dea0:	c0 80       	breq	8000deb0 <_dtoa_r+0x87c>
8000dea2:	40 4c       	lddsp	r12,sp[0x10]
8000dea4:	30 1b       	mov	r11,1
8000dea6:	2f fc       	sub	r12,-1
8000dea8:	2f f0       	sub	r0,-1
8000deaa:	50 4c       	stdsp	sp[0x10],r12
8000deac:	50 6b       	stdsp	sp[0x18],r11
8000deae:	c0 38       	rjmp	8000deb4 <_dtoa_r+0x880>
8000deb0:	30 0a       	mov	r10,0
8000deb2:	50 6a       	stdsp	sp[0x18],r10
8000deb4:	41 19       	lddsp	r9,sp[0x44]
8000deb6:	58 09       	cp.w	r9,0
8000deb8:	c0 31       	brne	8000debe <_dtoa_r+0x88a>
8000deba:	30 1c       	mov	r12,1
8000debc:	c0 98       	rjmp	8000dece <_dtoa_r+0x89a>
8000debe:	64 48       	ld.w	r8,r2[0x10]
8000dec0:	2f c8       	sub	r8,-4
8000dec2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000dec6:	e0 a0 05 df 	rcall	8000ea84 <__hi0bits>
8000deca:	f8 0c 11 20 	rsub	r12,r12,32
8000dece:	40 4b       	lddsp	r11,sp[0x10]
8000ded0:	f8 0b 00 08 	add	r8,r12,r11
8000ded4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ded8:	c0 c0       	breq	8000def0 <_dtoa_r+0x8bc>
8000deda:	f0 08 11 20 	rsub	r8,r8,32
8000dede:	58 48       	cp.w	r8,4
8000dee0:	e0 8a 00 06 	brle	8000deec <_dtoa_r+0x8b8>
8000dee4:	20 48       	sub	r8,4
8000dee6:	10 0b       	add	r11,r8
8000dee8:	50 4b       	stdsp	sp[0x10],r11
8000deea:	c0 78       	rjmp	8000def8 <_dtoa_r+0x8c4>
8000deec:	58 48       	cp.w	r8,4
8000deee:	c0 70       	breq	8000defc <_dtoa_r+0x8c8>
8000def0:	40 4a       	lddsp	r10,sp[0x10]
8000def2:	2e 48       	sub	r8,-28
8000def4:	10 0a       	add	r10,r8
8000def6:	50 4a       	stdsp	sp[0x10],r10
8000def8:	10 00       	add	r0,r8
8000defa:	10 05       	add	r5,r8
8000defc:	58 00       	cp.w	r0,0
8000defe:	e0 8a 00 08 	brle	8000df0e <_dtoa_r+0x8da>
8000df02:	06 9b       	mov	r11,r3
8000df04:	00 9a       	mov	r10,r0
8000df06:	0e 9c       	mov	r12,r7
8000df08:	e0 a0 07 58 	rcall	8000edb8 <__lshift>
8000df0c:	18 93       	mov	r3,r12
8000df0e:	40 49       	lddsp	r9,sp[0x10]
8000df10:	58 09       	cp.w	r9,0
8000df12:	e0 8a 00 08 	brle	8000df22 <_dtoa_r+0x8ee>
8000df16:	04 9b       	mov	r11,r2
8000df18:	12 9a       	mov	r10,r9
8000df1a:	0e 9c       	mov	r12,r7
8000df1c:	e0 a0 07 4e 	rcall	8000edb8 <__lshift>
8000df20:	18 92       	mov	r2,r12
8000df22:	41 48       	lddsp	r8,sp[0x50]
8000df24:	58 08       	cp.w	r8,0
8000df26:	c1 b0       	breq	8000df5c <_dtoa_r+0x928>
8000df28:	04 9b       	mov	r11,r2
8000df2a:	06 9c       	mov	r12,r3
8000df2c:	e0 a0 06 23 	rcall	8000eb72 <__mcmp>
8000df30:	c1 64       	brge	8000df5c <_dtoa_r+0x928>
8000df32:	06 9b       	mov	r11,r3
8000df34:	30 09       	mov	r9,0
8000df36:	30 aa       	mov	r10,10
8000df38:	0e 9c       	mov	r12,r7
8000df3a:	e0 a0 08 0b 	rcall	8000ef50 <__multadd>
8000df3e:	20 16       	sub	r6,1
8000df40:	18 93       	mov	r3,r12
8000df42:	40 dc       	lddsp	r12,sp[0x34]
8000df44:	58 0c       	cp.w	r12,0
8000df46:	c0 31       	brne	8000df4c <_dtoa_r+0x918>
8000df48:	40 91       	lddsp	r1,sp[0x24]
8000df4a:	c0 98       	rjmp	8000df5c <_dtoa_r+0x928>
8000df4c:	08 9b       	mov	r11,r4
8000df4e:	40 91       	lddsp	r1,sp[0x24]
8000df50:	30 09       	mov	r9,0
8000df52:	30 aa       	mov	r10,10
8000df54:	0e 9c       	mov	r12,r7
8000df56:	e0 a0 07 fd 	rcall	8000ef50 <__multadd>
8000df5a:	18 94       	mov	r4,r12
8000df5c:	58 01       	cp.w	r1,0
8000df5e:	5f a9       	srle	r9
8000df60:	40 cb       	lddsp	r11,sp[0x30]
8000df62:	58 2b       	cp.w	r11,2
8000df64:	5f 98       	srgt	r8
8000df66:	f3 e8 00 08 	and	r8,r9,r8
8000df6a:	c2 50       	breq	8000dfb4 <_dtoa_r+0x980>
8000df6c:	58 01       	cp.w	r1,0
8000df6e:	c1 11       	brne	8000df90 <_dtoa_r+0x95c>
8000df70:	04 9b       	mov	r11,r2
8000df72:	02 99       	mov	r9,r1
8000df74:	30 5a       	mov	r10,5
8000df76:	0e 9c       	mov	r12,r7
8000df78:	e0 a0 07 ec 	rcall	8000ef50 <__multadd>
8000df7c:	18 92       	mov	r2,r12
8000df7e:	18 9b       	mov	r11,r12
8000df80:	06 9c       	mov	r12,r3
8000df82:	e0 a0 05 f8 	rcall	8000eb72 <__mcmp>
8000df86:	e0 89 00 0f 	brgt	8000dfa4 <_dtoa_r+0x970>
8000df8a:	c0 38       	rjmp	8000df90 <_dtoa_r+0x95c>
8000df8c:	30 02       	mov	r2,0
8000df8e:	04 94       	mov	r4,r2
8000df90:	40 ea       	lddsp	r10,sp[0x38]
8000df92:	30 09       	mov	r9,0
8000df94:	5c da       	com	r10
8000df96:	40 85       	lddsp	r5,sp[0x20]
8000df98:	50 6a       	stdsp	sp[0x18],r10
8000df9a:	50 49       	stdsp	sp[0x10],r9
8000df9c:	c0 f9       	rjmp	8000e1ba <_dtoa_r+0xb86>
8000df9e:	08 92       	mov	r2,r4
8000dfa0:	40 66       	lddsp	r6,sp[0x18]
8000dfa2:	04 94       	mov	r4,r2
8000dfa4:	2f f6       	sub	r6,-1
8000dfa6:	50 66       	stdsp	sp[0x18],r6
8000dfa8:	33 18       	mov	r8,49
8000dfaa:	40 85       	lddsp	r5,sp[0x20]
8000dfac:	0a c8       	st.b	r5++,r8
8000dfae:	30 08       	mov	r8,0
8000dfb0:	50 48       	stdsp	sp[0x10],r8
8000dfb2:	c0 49       	rjmp	8000e1ba <_dtoa_r+0xb86>
8000dfb4:	40 dc       	lddsp	r12,sp[0x34]
8000dfb6:	58 0c       	cp.w	r12,0
8000dfb8:	e0 80 00 b5 	breq	8000e122 <_dtoa_r+0xaee>
8000dfbc:	58 05       	cp.w	r5,0
8000dfbe:	e0 8a 00 08 	brle	8000dfce <_dtoa_r+0x99a>
8000dfc2:	08 9b       	mov	r11,r4
8000dfc4:	0a 9a       	mov	r10,r5
8000dfc6:	0e 9c       	mov	r12,r7
8000dfc8:	e0 a0 06 f8 	rcall	8000edb8 <__lshift>
8000dfcc:	18 94       	mov	r4,r12
8000dfce:	40 6b       	lddsp	r11,sp[0x18]
8000dfd0:	58 0b       	cp.w	r11,0
8000dfd2:	c0 31       	brne	8000dfd8 <_dtoa_r+0x9a4>
8000dfd4:	08 9c       	mov	r12,r4
8000dfd6:	c1 38       	rjmp	8000dffc <_dtoa_r+0x9c8>
8000dfd8:	68 1b       	ld.w	r11,r4[0x4]
8000dfda:	0e 9c       	mov	r12,r7
8000dfdc:	e0 a0 05 fe 	rcall	8000ebd8 <_Balloc>
8000dfe0:	68 4a       	ld.w	r10,r4[0x10]
8000dfe2:	18 95       	mov	r5,r12
8000dfe4:	e8 cb ff f4 	sub	r11,r4,-12
8000dfe8:	2f ea       	sub	r10,-2
8000dfea:	2f 4c       	sub	r12,-12
8000dfec:	a3 6a       	lsl	r10,0x2
8000dfee:	fe b0 e6 44 	rcall	8000ac76 <memcpy>
8000dff2:	0a 9b       	mov	r11,r5
8000dff4:	30 1a       	mov	r10,1
8000dff6:	0e 9c       	mov	r12,r7
8000dff8:	e0 a0 06 e0 	rcall	8000edb8 <__lshift>
8000dffc:	50 44       	stdsp	sp[0x10],r4
8000dffe:	40 3a       	lddsp	r10,sp[0xc]
8000e000:	30 19       	mov	r9,1
8000e002:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000e006:	18 94       	mov	r4,r12
8000e008:	50 da       	stdsp	sp[0x34],r10
8000e00a:	40 85       	lddsp	r5,sp[0x20]
8000e00c:	50 99       	stdsp	sp[0x24],r9
8000e00e:	50 26       	stdsp	sp[0x8],r6
8000e010:	50 e1       	stdsp	sp[0x38],r1
8000e012:	04 9b       	mov	r11,r2
8000e014:	06 9c       	mov	r12,r3
8000e016:	fe b0 fa 7f 	rcall	8000d514 <quorem>
8000e01a:	40 4b       	lddsp	r11,sp[0x10]
8000e01c:	f8 c0 ff d0 	sub	r0,r12,-48
8000e020:	06 9c       	mov	r12,r3
8000e022:	e0 a0 05 a8 	rcall	8000eb72 <__mcmp>
8000e026:	08 9a       	mov	r10,r4
8000e028:	50 6c       	stdsp	sp[0x18],r12
8000e02a:	04 9b       	mov	r11,r2
8000e02c:	0e 9c       	mov	r12,r7
8000e02e:	e0 a0 06 5d 	rcall	8000ece8 <__mdiff>
8000e032:	18 91       	mov	r1,r12
8000e034:	78 38       	ld.w	r8,r12[0xc]
8000e036:	58 08       	cp.w	r8,0
8000e038:	c0 30       	breq	8000e03e <_dtoa_r+0xa0a>
8000e03a:	30 16       	mov	r6,1
8000e03c:	c0 68       	rjmp	8000e048 <_dtoa_r+0xa14>
8000e03e:	18 9b       	mov	r11,r12
8000e040:	06 9c       	mov	r12,r3
8000e042:	e0 a0 05 98 	rcall	8000eb72 <__mcmp>
8000e046:	18 96       	mov	r6,r12
8000e048:	0e 9c       	mov	r12,r7
8000e04a:	02 9b       	mov	r11,r1
8000e04c:	e0 a0 05 ac 	rcall	8000eba4 <_Bfree>
8000e050:	40 cc       	lddsp	r12,sp[0x30]
8000e052:	ed ec 10 08 	or	r8,r6,r12
8000e056:	c0 d1       	brne	8000e070 <_dtoa_r+0xa3c>
8000e058:	40 db       	lddsp	r11,sp[0x34]
8000e05a:	58 0b       	cp.w	r11,0
8000e05c:	c0 a1       	brne	8000e070 <_dtoa_r+0xa3c>
8000e05e:	40 26       	lddsp	r6,sp[0x8]
8000e060:	e0 40 00 39 	cp.w	r0,57
8000e064:	c3 00       	breq	8000e0c4 <_dtoa_r+0xa90>
8000e066:	40 6a       	lddsp	r10,sp[0x18]
8000e068:	58 0a       	cp.w	r10,0
8000e06a:	e0 89 00 24 	brgt	8000e0b2 <_dtoa_r+0xa7e>
8000e06e:	c2 f8       	rjmp	8000e0cc <_dtoa_r+0xa98>
8000e070:	40 69       	lddsp	r9,sp[0x18]
8000e072:	58 09       	cp.w	r9,0
8000e074:	c0 85       	brlt	8000e084 <_dtoa_r+0xa50>
8000e076:	12 98       	mov	r8,r9
8000e078:	40 cc       	lddsp	r12,sp[0x30]
8000e07a:	18 48       	or	r8,r12
8000e07c:	c1 d1       	brne	8000e0b6 <_dtoa_r+0xa82>
8000e07e:	40 db       	lddsp	r11,sp[0x34]
8000e080:	58 0b       	cp.w	r11,0
8000e082:	c1 a1       	brne	8000e0b6 <_dtoa_r+0xa82>
8000e084:	0c 99       	mov	r9,r6
8000e086:	40 26       	lddsp	r6,sp[0x8]
8000e088:	58 09       	cp.w	r9,0
8000e08a:	e0 8a 00 21 	brle	8000e0cc <_dtoa_r+0xa98>
8000e08e:	06 9b       	mov	r11,r3
8000e090:	30 1a       	mov	r10,1
8000e092:	0e 9c       	mov	r12,r7
8000e094:	e0 a0 06 92 	rcall	8000edb8 <__lshift>
8000e098:	04 9b       	mov	r11,r2
8000e09a:	18 93       	mov	r3,r12
8000e09c:	e0 a0 05 6b 	rcall	8000eb72 <__mcmp>
8000e0a0:	e0 89 00 06 	brgt	8000e0ac <_dtoa_r+0xa78>
8000e0a4:	c1 41       	brne	8000e0cc <_dtoa_r+0xa98>
8000e0a6:	ed b0 00 00 	bld	r0,0x0
8000e0aa:	c1 11       	brne	8000e0cc <_dtoa_r+0xa98>
8000e0ac:	e0 40 00 39 	cp.w	r0,57
8000e0b0:	c0 a0       	breq	8000e0c4 <_dtoa_r+0xa90>
8000e0b2:	2f f0       	sub	r0,-1
8000e0b4:	c0 c8       	rjmp	8000e0cc <_dtoa_r+0xa98>
8000e0b6:	58 06       	cp.w	r6,0
8000e0b8:	e0 8a 00 0c 	brle	8000e0d0 <_dtoa_r+0xa9c>
8000e0bc:	40 26       	lddsp	r6,sp[0x8]
8000e0be:	e0 40 00 39 	cp.w	r0,57
8000e0c2:	c0 41       	brne	8000e0ca <_dtoa_r+0xa96>
8000e0c4:	33 98       	mov	r8,57
8000e0c6:	0a c8       	st.b	r5++,r8
8000e0c8:	c6 78       	rjmp	8000e196 <_dtoa_r+0xb62>
8000e0ca:	2f f0       	sub	r0,-1
8000e0cc:	0a c0       	st.b	r5++,r0
8000e0ce:	c7 58       	rjmp	8000e1b8 <_dtoa_r+0xb84>
8000e0d0:	0a c0       	st.b	r5++,r0
8000e0d2:	40 9a       	lddsp	r10,sp[0x24]
8000e0d4:	40 e9       	lddsp	r9,sp[0x38]
8000e0d6:	12 3a       	cp.w	r10,r9
8000e0d8:	c4 30       	breq	8000e15e <_dtoa_r+0xb2a>
8000e0da:	06 9b       	mov	r11,r3
8000e0dc:	30 09       	mov	r9,0
8000e0de:	30 aa       	mov	r10,10
8000e0e0:	0e 9c       	mov	r12,r7
8000e0e2:	e0 a0 07 37 	rcall	8000ef50 <__multadd>
8000e0e6:	40 48       	lddsp	r8,sp[0x10]
8000e0e8:	18 93       	mov	r3,r12
8000e0ea:	08 38       	cp.w	r8,r4
8000e0ec:	c0 91       	brne	8000e0fe <_dtoa_r+0xaca>
8000e0ee:	10 9b       	mov	r11,r8
8000e0f0:	30 09       	mov	r9,0
8000e0f2:	30 aa       	mov	r10,10
8000e0f4:	0e 9c       	mov	r12,r7
8000e0f6:	e0 a0 07 2d 	rcall	8000ef50 <__multadd>
8000e0fa:	50 4c       	stdsp	sp[0x10],r12
8000e0fc:	c0 e8       	rjmp	8000e118 <_dtoa_r+0xae4>
8000e0fe:	40 4b       	lddsp	r11,sp[0x10]
8000e100:	30 09       	mov	r9,0
8000e102:	30 aa       	mov	r10,10
8000e104:	0e 9c       	mov	r12,r7
8000e106:	e0 a0 07 25 	rcall	8000ef50 <__multadd>
8000e10a:	08 9b       	mov	r11,r4
8000e10c:	50 4c       	stdsp	sp[0x10],r12
8000e10e:	30 09       	mov	r9,0
8000e110:	30 aa       	mov	r10,10
8000e112:	0e 9c       	mov	r12,r7
8000e114:	e0 a0 07 1e 	rcall	8000ef50 <__multadd>
8000e118:	18 94       	mov	r4,r12
8000e11a:	40 9c       	lddsp	r12,sp[0x24]
8000e11c:	2f fc       	sub	r12,-1
8000e11e:	50 9c       	stdsp	sp[0x24],r12
8000e120:	c7 9b       	rjmp	8000e012 <_dtoa_r+0x9de>
8000e122:	30 18       	mov	r8,1
8000e124:	06 90       	mov	r0,r3
8000e126:	40 85       	lddsp	r5,sp[0x20]
8000e128:	08 93       	mov	r3,r4
8000e12a:	0c 94       	mov	r4,r6
8000e12c:	10 96       	mov	r6,r8
8000e12e:	04 9b       	mov	r11,r2
8000e130:	00 9c       	mov	r12,r0
8000e132:	fe b0 f9 f1 	rcall	8000d514 <quorem>
8000e136:	2d 0c       	sub	r12,-48
8000e138:	0a cc       	st.b	r5++,r12
8000e13a:	02 36       	cp.w	r6,r1
8000e13c:	c0 a4       	brge	8000e150 <_dtoa_r+0xb1c>
8000e13e:	00 9b       	mov	r11,r0
8000e140:	30 09       	mov	r9,0
8000e142:	30 aa       	mov	r10,10
8000e144:	0e 9c       	mov	r12,r7
8000e146:	2f f6       	sub	r6,-1
8000e148:	e0 a0 07 04 	rcall	8000ef50 <__multadd>
8000e14c:	18 90       	mov	r0,r12
8000e14e:	cf 0b       	rjmp	8000e12e <_dtoa_r+0xafa>
8000e150:	08 96       	mov	r6,r4
8000e152:	30 0b       	mov	r11,0
8000e154:	06 94       	mov	r4,r3
8000e156:	50 4b       	stdsp	sp[0x10],r11
8000e158:	00 93       	mov	r3,r0
8000e15a:	18 90       	mov	r0,r12
8000e15c:	c0 28       	rjmp	8000e160 <_dtoa_r+0xb2c>
8000e15e:	40 26       	lddsp	r6,sp[0x8]
8000e160:	06 9b       	mov	r11,r3
8000e162:	30 1a       	mov	r10,1
8000e164:	0e 9c       	mov	r12,r7
8000e166:	e0 a0 06 29 	rcall	8000edb8 <__lshift>
8000e16a:	04 9b       	mov	r11,r2
8000e16c:	18 93       	mov	r3,r12
8000e16e:	e0 a0 05 02 	rcall	8000eb72 <__mcmp>
8000e172:	e0 89 00 12 	brgt	8000e196 <_dtoa_r+0xb62>
8000e176:	c1 b1       	brne	8000e1ac <_dtoa_r+0xb78>
8000e178:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000e17c:	c0 d1       	brne	8000e196 <_dtoa_r+0xb62>
8000e17e:	c1 78       	rjmp	8000e1ac <_dtoa_r+0xb78>
8000e180:	40 89       	lddsp	r9,sp[0x20]
8000e182:	12 38       	cp.w	r8,r9
8000e184:	c0 30       	breq	8000e18a <_dtoa_r+0xb56>
8000e186:	10 95       	mov	r5,r8
8000e188:	c0 88       	rjmp	8000e198 <_dtoa_r+0xb64>
8000e18a:	2f f6       	sub	r6,-1
8000e18c:	50 66       	stdsp	sp[0x18],r6
8000e18e:	33 18       	mov	r8,49
8000e190:	40 8c       	lddsp	r12,sp[0x20]
8000e192:	b8 88       	st.b	r12[0x0],r8
8000e194:	c1 38       	rjmp	8000e1ba <_dtoa_r+0xb86>
8000e196:	33 9a       	mov	r10,57
8000e198:	0a 98       	mov	r8,r5
8000e19a:	11 79       	ld.ub	r9,--r8
8000e19c:	f4 09 18 00 	cp.b	r9,r10
8000e1a0:	cf 00       	breq	8000e180 <_dtoa_r+0xb4c>
8000e1a2:	2f f9       	sub	r9,-1
8000e1a4:	b0 89       	st.b	r8[0x0],r9
8000e1a6:	c0 98       	rjmp	8000e1b8 <_dtoa_r+0xb84>
8000e1a8:	10 95       	mov	r5,r8
8000e1aa:	c0 28       	rjmp	8000e1ae <_dtoa_r+0xb7a>
8000e1ac:	33 09       	mov	r9,48
8000e1ae:	0a 98       	mov	r8,r5
8000e1b0:	11 7a       	ld.ub	r10,--r8
8000e1b2:	f2 0a 18 00 	cp.b	r10,r9
8000e1b6:	cf 90       	breq	8000e1a8 <_dtoa_r+0xb74>
8000e1b8:	50 66       	stdsp	sp[0x18],r6
8000e1ba:	04 9b       	mov	r11,r2
8000e1bc:	0e 9c       	mov	r12,r7
8000e1be:	e0 a0 04 f3 	rcall	8000eba4 <_Bfree>
8000e1c2:	58 04       	cp.w	r4,0
8000e1c4:	c1 20       	breq	8000e1e8 <_dtoa_r+0xbb4>
8000e1c6:	40 4b       	lddsp	r11,sp[0x10]
8000e1c8:	08 3b       	cp.w	r11,r4
8000e1ca:	5f 19       	srne	r9
8000e1cc:	58 0b       	cp.w	r11,0
8000e1ce:	5f 18       	srne	r8
8000e1d0:	f3 e8 00 08 	and	r8,r9,r8
8000e1d4:	c0 40       	breq	8000e1dc <_dtoa_r+0xba8>
8000e1d6:	0e 9c       	mov	r12,r7
8000e1d8:	e0 a0 04 e6 	rcall	8000eba4 <_Bfree>
8000e1dc:	08 9b       	mov	r11,r4
8000e1de:	0e 9c       	mov	r12,r7
8000e1e0:	e0 a0 04 e2 	rcall	8000eba4 <_Bfree>
8000e1e4:	c0 28       	rjmp	8000e1e8 <_dtoa_r+0xbb4>
8000e1e6:	50 66       	stdsp	sp[0x18],r6
8000e1e8:	0e 9c       	mov	r12,r7
8000e1ea:	06 9b       	mov	r11,r3
8000e1ec:	e0 a0 04 dc 	rcall	8000eba4 <_Bfree>
8000e1f0:	30 08       	mov	r8,0
8000e1f2:	aa 88       	st.b	r5[0x0],r8
8000e1f4:	40 68       	lddsp	r8,sp[0x18]
8000e1f6:	41 5a       	lddsp	r10,sp[0x54]
8000e1f8:	2f f8       	sub	r8,-1
8000e1fa:	41 29       	lddsp	r9,sp[0x48]
8000e1fc:	95 08       	st.w	r10[0x0],r8
8000e1fe:	40 8c       	lddsp	r12,sp[0x20]
8000e200:	58 09       	cp.w	r9,0
8000e202:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000e206:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000e20a:	2e 6d       	sub	sp,-104
8000e20c:	d8 32       	popm	r0-r7,pc
8000e20e:	d7 03       	nop

8000e210 <__errno>:
8000e210:	e0 68 0a 4c 	mov	r8,2636
8000e214:	70 0c       	ld.w	r12,r8[0x0]
8000e216:	2f 4c       	sub	r12,-12
8000e218:	5e fc       	retal	r12
8000e21a:	d7 03       	nop

8000e21c <_fflush_r>:
8000e21c:	d4 21       	pushm	r4-r7,lr
8000e21e:	16 97       	mov	r7,r11
8000e220:	18 96       	mov	r6,r12
8000e222:	76 48       	ld.w	r8,r11[0x10]
8000e224:	58 08       	cp.w	r8,0
8000e226:	c7 f0       	breq	8000e324 <_fflush_r+0x108>
8000e228:	58 0c       	cp.w	r12,0
8000e22a:	c0 50       	breq	8000e234 <_fflush_r+0x18>
8000e22c:	78 68       	ld.w	r8,r12[0x18]
8000e22e:	58 08       	cp.w	r8,0
8000e230:	c0 21       	brne	8000e234 <_fflush_r+0x18>
8000e232:	cc dc       	rcall	8000e3cc <__sinit>
8000e234:	fe c8 d6 3c 	sub	r8,pc,-10692
8000e238:	10 37       	cp.w	r7,r8
8000e23a:	c0 31       	brne	8000e240 <_fflush_r+0x24>
8000e23c:	6c 07       	ld.w	r7,r6[0x0]
8000e23e:	c0 c8       	rjmp	8000e256 <_fflush_r+0x3a>
8000e240:	fe c8 d6 28 	sub	r8,pc,-10712
8000e244:	10 37       	cp.w	r7,r8
8000e246:	c0 31       	brne	8000e24c <_fflush_r+0x30>
8000e248:	6c 17       	ld.w	r7,r6[0x4]
8000e24a:	c0 68       	rjmp	8000e256 <_fflush_r+0x3a>
8000e24c:	fe c8 d6 14 	sub	r8,pc,-10732
8000e250:	10 37       	cp.w	r7,r8
8000e252:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e256:	8e 6a       	ld.sh	r10,r7[0xc]
8000e258:	14 98       	mov	r8,r10
8000e25a:	ed ba 00 03 	bld	r10,0x3
8000e25e:	c4 20       	breq	8000e2e2 <_fflush_r+0xc6>
8000e260:	ab ba       	sbr	r10,0xb
8000e262:	ae 6a       	st.h	r7[0xc],r10
8000e264:	6e 18       	ld.w	r8,r7[0x4]
8000e266:	58 08       	cp.w	r8,0
8000e268:	e0 89 00 06 	brgt	8000e274 <_fflush_r+0x58>
8000e26c:	6f 08       	ld.w	r8,r7[0x40]
8000e26e:	58 08       	cp.w	r8,0
8000e270:	e0 8a 00 5a 	brle	8000e324 <_fflush_r+0x108>
8000e274:	6e b8       	ld.w	r8,r7[0x2c]
8000e276:	58 08       	cp.w	r8,0
8000e278:	c5 60       	breq	8000e324 <_fflush_r+0x108>
8000e27a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000e27e:	c0 30       	breq	8000e284 <_fflush_r+0x68>
8000e280:	6f 55       	ld.w	r5,r7[0x54]
8000e282:	c0 f8       	rjmp	8000e2a0 <_fflush_r+0x84>
8000e284:	30 19       	mov	r9,1
8000e286:	6e 8b       	ld.w	r11,r7[0x20]
8000e288:	0c 9c       	mov	r12,r6
8000e28a:	5d 18       	icall	r8
8000e28c:	18 95       	mov	r5,r12
8000e28e:	5b fc       	cp.w	r12,-1
8000e290:	c0 81       	brne	8000e2a0 <_fflush_r+0x84>
8000e292:	6c 38       	ld.w	r8,r6[0xc]
8000e294:	59 d8       	cp.w	r8,29
8000e296:	c4 70       	breq	8000e324 <_fflush_r+0x108>
8000e298:	8e 68       	ld.sh	r8,r7[0xc]
8000e29a:	a7 a8       	sbr	r8,0x6
8000e29c:	ae 68       	st.h	r7[0xc],r8
8000e29e:	d8 22       	popm	r4-r7,pc
8000e2a0:	8e 68       	ld.sh	r8,r7[0xc]
8000e2a2:	ed b8 00 02 	bld	r8,0x2
8000e2a6:	c0 91       	brne	8000e2b8 <_fflush_r+0x9c>
8000e2a8:	6e 18       	ld.w	r8,r7[0x4]
8000e2aa:	10 15       	sub	r5,r8
8000e2ac:	6e d8       	ld.w	r8,r7[0x34]
8000e2ae:	58 08       	cp.w	r8,0
8000e2b0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e2b4:	eb d8 e1 15 	subne	r5,r5,r8
8000e2b8:	6e b8       	ld.w	r8,r7[0x2c]
8000e2ba:	0c 9c       	mov	r12,r6
8000e2bc:	30 09       	mov	r9,0
8000e2be:	0a 9a       	mov	r10,r5
8000e2c0:	6e 8b       	ld.w	r11,r7[0x20]
8000e2c2:	5d 18       	icall	r8
8000e2c4:	8e 68       	ld.sh	r8,r7[0xc]
8000e2c6:	0a 3c       	cp.w	r12,r5
8000e2c8:	c2 61       	brne	8000e314 <_fflush_r+0xf8>
8000e2ca:	ab d8       	cbr	r8,0xb
8000e2cc:	30 0c       	mov	r12,0
8000e2ce:	6e 49       	ld.w	r9,r7[0x10]
8000e2d0:	ae 68       	st.h	r7[0xc],r8
8000e2d2:	8f 1c       	st.w	r7[0x4],r12
8000e2d4:	8f 09       	st.w	r7[0x0],r9
8000e2d6:	ed b8 00 0c 	bld	r8,0xc
8000e2da:	c2 51       	brne	8000e324 <_fflush_r+0x108>
8000e2dc:	ef 45 00 54 	st.w	r7[84],r5
8000e2e0:	d8 22       	popm	r4-r7,pc
8000e2e2:	6e 45       	ld.w	r5,r7[0x10]
8000e2e4:	58 05       	cp.w	r5,0
8000e2e6:	c1 f0       	breq	8000e324 <_fflush_r+0x108>
8000e2e8:	6e 04       	ld.w	r4,r7[0x0]
8000e2ea:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e2ee:	8f 05       	st.w	r7[0x0],r5
8000e2f0:	f9 b8 01 00 	movne	r8,0
8000e2f4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e2f8:	0a 14       	sub	r4,r5
8000e2fa:	8f 28       	st.w	r7[0x8],r8
8000e2fc:	c1 18       	rjmp	8000e31e <_fflush_r+0x102>
8000e2fe:	08 99       	mov	r9,r4
8000e300:	0a 9a       	mov	r10,r5
8000e302:	6e a8       	ld.w	r8,r7[0x28]
8000e304:	6e 8b       	ld.w	r11,r7[0x20]
8000e306:	0c 9c       	mov	r12,r6
8000e308:	5d 18       	icall	r8
8000e30a:	18 14       	sub	r4,r12
8000e30c:	58 0c       	cp.w	r12,0
8000e30e:	e0 89 00 07 	brgt	8000e31c <_fflush_r+0x100>
8000e312:	8e 68       	ld.sh	r8,r7[0xc]
8000e314:	a7 a8       	sbr	r8,0x6
8000e316:	3f fc       	mov	r12,-1
8000e318:	ae 68       	st.h	r7[0xc],r8
8000e31a:	d8 22       	popm	r4-r7,pc
8000e31c:	18 05       	add	r5,r12
8000e31e:	58 04       	cp.w	r4,0
8000e320:	fe 99 ff ef 	brgt	8000e2fe <_fflush_r+0xe2>
8000e324:	d8 2a       	popm	r4-r7,pc,r12=0
8000e326:	d7 03       	nop

8000e328 <__sfp_lock_acquire>:
8000e328:	5e fc       	retal	r12

8000e32a <__sfp_lock_release>:
8000e32a:	5e fc       	retal	r12

8000e32c <_cleanup_r>:
8000e32c:	d4 01       	pushm	lr
8000e32e:	fe cb f0 c6 	sub	r11,pc,-3898
8000e332:	e0 a0 02 f7 	rcall	8000e920 <_fwalk>
8000e336:	d8 02       	popm	pc

8000e338 <__sfmoreglue>:
8000e338:	d4 21       	pushm	r4-r7,lr
8000e33a:	16 95       	mov	r5,r11
8000e33c:	f6 06 10 5c 	mul	r6,r11,92
8000e340:	ec cb ff f4 	sub	r11,r6,-12
8000e344:	fe b0 e2 6a 	rcall	8000a818 <_malloc_r>
8000e348:	18 97       	mov	r7,r12
8000e34a:	c0 90       	breq	8000e35c <__sfmoreglue+0x24>
8000e34c:	99 15       	st.w	r12[0x4],r5
8000e34e:	30 0b       	mov	r11,0
8000e350:	2f 4c       	sub	r12,-12
8000e352:	0c 9a       	mov	r10,r6
8000e354:	8f 2c       	st.w	r7[0x8],r12
8000e356:	8f 0b       	st.w	r7[0x0],r11
8000e358:	fe b0 e5 33 	rcall	8000adbe <memset>
8000e35c:	0e 9c       	mov	r12,r7
8000e35e:	d8 22       	popm	r4-r7,pc

8000e360 <__sfp>:
8000e360:	d4 21       	pushm	r4-r7,lr
8000e362:	fe c8 d7 06 	sub	r8,pc,-10490
8000e366:	18 96       	mov	r6,r12
8000e368:	70 07       	ld.w	r7,r8[0x0]
8000e36a:	6e 68       	ld.w	r8,r7[0x18]
8000e36c:	58 08       	cp.w	r8,0
8000e36e:	c0 31       	brne	8000e374 <__sfp+0x14>
8000e370:	0e 9c       	mov	r12,r7
8000e372:	c2 dc       	rcall	8000e3cc <__sinit>
8000e374:	ee c7 ff 28 	sub	r7,r7,-216
8000e378:	30 05       	mov	r5,0
8000e37a:	6e 2c       	ld.w	r12,r7[0x8]
8000e37c:	6e 18       	ld.w	r8,r7[0x4]
8000e37e:	c0 68       	rjmp	8000e38a <__sfp+0x2a>
8000e380:	98 69       	ld.sh	r9,r12[0xc]
8000e382:	ea 09 19 00 	cp.h	r9,r5
8000e386:	c1 10       	breq	8000e3a8 <__sfp+0x48>
8000e388:	2a 4c       	sub	r12,-92
8000e38a:	20 18       	sub	r8,1
8000e38c:	cf a7       	brpl	8000e380 <__sfp+0x20>
8000e38e:	6e 08       	ld.w	r8,r7[0x0]
8000e390:	58 08       	cp.w	r8,0
8000e392:	c0 61       	brne	8000e39e <__sfp+0x3e>
8000e394:	30 4b       	mov	r11,4
8000e396:	0c 9c       	mov	r12,r6
8000e398:	cd 0f       	rcall	8000e338 <__sfmoreglue>
8000e39a:	8f 0c       	st.w	r7[0x0],r12
8000e39c:	c0 30       	breq	8000e3a2 <__sfp+0x42>
8000e39e:	6e 07       	ld.w	r7,r7[0x0]
8000e3a0:	ce db       	rjmp	8000e37a <__sfp+0x1a>
8000e3a2:	30 c8       	mov	r8,12
8000e3a4:	8d 38       	st.w	r6[0xc],r8
8000e3a6:	d8 22       	popm	r4-r7,pc
8000e3a8:	30 08       	mov	r8,0
8000e3aa:	f9 48 00 4c 	st.w	r12[76],r8
8000e3ae:	99 08       	st.w	r12[0x0],r8
8000e3b0:	99 28       	st.w	r12[0x8],r8
8000e3b2:	99 18       	st.w	r12[0x4],r8
8000e3b4:	99 48       	st.w	r12[0x10],r8
8000e3b6:	99 58       	st.w	r12[0x14],r8
8000e3b8:	99 68       	st.w	r12[0x18],r8
8000e3ba:	99 d8       	st.w	r12[0x34],r8
8000e3bc:	99 e8       	st.w	r12[0x38],r8
8000e3be:	f9 48 00 48 	st.w	r12[72],r8
8000e3c2:	3f f8       	mov	r8,-1
8000e3c4:	b8 78       	st.h	r12[0xe],r8
8000e3c6:	30 18       	mov	r8,1
8000e3c8:	b8 68       	st.h	r12[0xc],r8
8000e3ca:	d8 22       	popm	r4-r7,pc

8000e3cc <__sinit>:
8000e3cc:	d4 21       	pushm	r4-r7,lr
8000e3ce:	18 96       	mov	r6,r12
8000e3d0:	78 67       	ld.w	r7,r12[0x18]
8000e3d2:	58 07       	cp.w	r7,0
8000e3d4:	c4 91       	brne	8000e466 <__sinit+0x9a>
8000e3d6:	fe c8 00 aa 	sub	r8,pc,170
8000e3da:	30 15       	mov	r5,1
8000e3dc:	99 a8       	st.w	r12[0x28],r8
8000e3de:	f9 47 00 d8 	st.w	r12[216],r7
8000e3e2:	f9 47 00 dc 	st.w	r12[220],r7
8000e3e6:	f9 47 00 e0 	st.w	r12[224],r7
8000e3ea:	99 65       	st.w	r12[0x18],r5
8000e3ec:	cb af       	rcall	8000e360 <__sfp>
8000e3ee:	8d 0c       	st.w	r6[0x0],r12
8000e3f0:	0c 9c       	mov	r12,r6
8000e3f2:	cb 7f       	rcall	8000e360 <__sfp>
8000e3f4:	8d 1c       	st.w	r6[0x4],r12
8000e3f6:	0c 9c       	mov	r12,r6
8000e3f8:	cb 4f       	rcall	8000e360 <__sfp>
8000e3fa:	6c 09       	ld.w	r9,r6[0x0]
8000e3fc:	30 48       	mov	r8,4
8000e3fe:	93 07       	st.w	r9[0x0],r7
8000e400:	b2 68       	st.h	r9[0xc],r8
8000e402:	93 17       	st.w	r9[0x4],r7
8000e404:	93 27       	st.w	r9[0x8],r7
8000e406:	6c 18       	ld.w	r8,r6[0x4]
8000e408:	b2 77       	st.h	r9[0xe],r7
8000e40a:	93 47       	st.w	r9[0x10],r7
8000e40c:	93 57       	st.w	r9[0x14],r7
8000e40e:	93 67       	st.w	r9[0x18],r7
8000e410:	93 89       	st.w	r9[0x20],r9
8000e412:	91 07       	st.w	r8[0x0],r7
8000e414:	91 17       	st.w	r8[0x4],r7
8000e416:	91 27       	st.w	r8[0x8],r7
8000e418:	fe ce f3 24 	sub	lr,pc,-3292
8000e41c:	fe cb f3 54 	sub	r11,pc,-3244
8000e420:	93 9e       	st.w	r9[0x24],lr
8000e422:	93 ab       	st.w	r9[0x28],r11
8000e424:	fe ca f3 7c 	sub	r10,pc,-3204
8000e428:	fe c4 f3 88 	sub	r4,pc,-3192
8000e42c:	93 ba       	st.w	r9[0x2c],r10
8000e42e:	93 c4       	st.w	r9[0x30],r4
8000e430:	30 99       	mov	r9,9
8000e432:	b0 69       	st.h	r8[0xc],r9
8000e434:	b0 75       	st.h	r8[0xe],r5
8000e436:	91 c4       	st.w	r8[0x30],r4
8000e438:	91 47       	st.w	r8[0x10],r7
8000e43a:	91 57       	st.w	r8[0x14],r7
8000e43c:	91 67       	st.w	r8[0x18],r7
8000e43e:	91 88       	st.w	r8[0x20],r8
8000e440:	91 9e       	st.w	r8[0x24],lr
8000e442:	91 ab       	st.w	r8[0x28],r11
8000e444:	91 ba       	st.w	r8[0x2c],r10
8000e446:	8d 2c       	st.w	r6[0x8],r12
8000e448:	31 28       	mov	r8,18
8000e44a:	99 07       	st.w	r12[0x0],r7
8000e44c:	b8 68       	st.h	r12[0xc],r8
8000e44e:	99 17       	st.w	r12[0x4],r7
8000e450:	99 27       	st.w	r12[0x8],r7
8000e452:	30 28       	mov	r8,2
8000e454:	b8 78       	st.h	r12[0xe],r8
8000e456:	99 c4       	st.w	r12[0x30],r4
8000e458:	99 67       	st.w	r12[0x18],r7
8000e45a:	99 9e       	st.w	r12[0x24],lr
8000e45c:	99 ab       	st.w	r12[0x28],r11
8000e45e:	99 ba       	st.w	r12[0x2c],r10
8000e460:	99 47       	st.w	r12[0x10],r7
8000e462:	99 57       	st.w	r12[0x14],r7
8000e464:	99 8c       	st.w	r12[0x20],r12
8000e466:	d8 22       	popm	r4-r7,pc

8000e468 <_malloc_trim_r>:
8000e468:	d4 21       	pushm	r4-r7,lr
8000e46a:	16 95       	mov	r5,r11
8000e46c:	18 97       	mov	r7,r12
8000e46e:	fe b0 cd b1 	rcall	80007fd0 <__malloc_lock>
8000e472:	e0 64 05 4c 	mov	r4,1356
8000e476:	68 28       	ld.w	r8,r4[0x8]
8000e478:	70 16       	ld.w	r6,r8[0x4]
8000e47a:	e0 16 ff fc 	andl	r6,0xfffc
8000e47e:	ec c8 ff 91 	sub	r8,r6,-111
8000e482:	f0 05 01 05 	sub	r5,r8,r5
8000e486:	e0 15 ff 80 	andl	r5,0xff80
8000e48a:	ea c5 00 80 	sub	r5,r5,128
8000e48e:	e0 45 00 7f 	cp.w	r5,127
8000e492:	e0 8a 00 25 	brle	8000e4dc <_malloc_trim_r+0x74>
8000e496:	30 0b       	mov	r11,0
8000e498:	0e 9c       	mov	r12,r7
8000e49a:	fe b0 e5 f9 	rcall	8000b08c <_sbrk_r>
8000e49e:	68 28       	ld.w	r8,r4[0x8]
8000e4a0:	0c 08       	add	r8,r6
8000e4a2:	10 3c       	cp.w	r12,r8
8000e4a4:	c1 c1       	brne	8000e4dc <_malloc_trim_r+0x74>
8000e4a6:	ea 0b 11 00 	rsub	r11,r5,0
8000e4aa:	0e 9c       	mov	r12,r7
8000e4ac:	fe b0 e5 f0 	rcall	8000b08c <_sbrk_r>
8000e4b0:	5b fc       	cp.w	r12,-1
8000e4b2:	c1 91       	brne	8000e4e4 <_malloc_trim_r+0x7c>
8000e4b4:	30 0b       	mov	r11,0
8000e4b6:	0e 9c       	mov	r12,r7
8000e4b8:	fe b0 e5 ea 	rcall	8000b08c <_sbrk_r>
8000e4bc:	68 28       	ld.w	r8,r4[0x8]
8000e4be:	f8 08 01 09 	sub	r9,r12,r8
8000e4c2:	58 f9       	cp.w	r9,15
8000e4c4:	e0 8a 00 0c 	brle	8000e4dc <_malloc_trim_r+0x74>
8000e4c8:	a1 a9       	sbr	r9,0x0
8000e4ca:	91 19       	st.w	r8[0x4],r9
8000e4cc:	e0 68 09 58 	mov	r8,2392
8000e4d0:	70 09       	ld.w	r9,r8[0x0]
8000e4d2:	e0 68 0d 64 	mov	r8,3428
8000e4d6:	f8 09 01 09 	sub	r9,r12,r9
8000e4da:	91 09       	st.w	r8[0x0],r9
8000e4dc:	0e 9c       	mov	r12,r7
8000e4de:	fe b0 cd 87 	rcall	80007fec <__malloc_unlock>
8000e4e2:	d8 2a       	popm	r4-r7,pc,r12=0
8000e4e4:	68 28       	ld.w	r8,r4[0x8]
8000e4e6:	0a 16       	sub	r6,r5
8000e4e8:	a1 a6       	sbr	r6,0x0
8000e4ea:	91 16       	st.w	r8[0x4],r6
8000e4ec:	e0 68 0d 64 	mov	r8,3428
8000e4f0:	70 09       	ld.w	r9,r8[0x0]
8000e4f2:	0a 19       	sub	r9,r5
8000e4f4:	0e 9c       	mov	r12,r7
8000e4f6:	91 09       	st.w	r8[0x0],r9
8000e4f8:	fe b0 cd 7a 	rcall	80007fec <__malloc_unlock>
8000e4fc:	da 2a       	popm	r4-r7,pc,r12=1
8000e4fe:	d7 03       	nop

8000e500 <_free_r>:
8000e500:	d4 21       	pushm	r4-r7,lr
8000e502:	16 96       	mov	r6,r11
8000e504:	18 97       	mov	r7,r12
8000e506:	58 0b       	cp.w	r11,0
8000e508:	e0 80 00 c0 	breq	8000e688 <_free_r+0x188>
8000e50c:	fe b0 cd 62 	rcall	80007fd0 <__malloc_lock>
8000e510:	20 86       	sub	r6,8
8000e512:	e0 6a 05 4c 	mov	r10,1356
8000e516:	6c 18       	ld.w	r8,r6[0x4]
8000e518:	74 2e       	ld.w	lr,r10[0x8]
8000e51a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e51e:	a1 c8       	cbr	r8,0x0
8000e520:	ec 08 00 09 	add	r9,r6,r8
8000e524:	72 1b       	ld.w	r11,r9[0x4]
8000e526:	e0 1b ff fc 	andl	r11,0xfffc
8000e52a:	1c 39       	cp.w	r9,lr
8000e52c:	c1 e1       	brne	8000e568 <_free_r+0x68>
8000e52e:	f6 08 00 08 	add	r8,r11,r8
8000e532:	58 0c       	cp.w	r12,0
8000e534:	c0 81       	brne	8000e544 <_free_r+0x44>
8000e536:	6c 09       	ld.w	r9,r6[0x0]
8000e538:	12 16       	sub	r6,r9
8000e53a:	12 08       	add	r8,r9
8000e53c:	6c 3b       	ld.w	r11,r6[0xc]
8000e53e:	6c 29       	ld.w	r9,r6[0x8]
8000e540:	97 29       	st.w	r11[0x8],r9
8000e542:	93 3b       	st.w	r9[0xc],r11
8000e544:	10 99       	mov	r9,r8
8000e546:	95 26       	st.w	r10[0x8],r6
8000e548:	a1 a9       	sbr	r9,0x0
8000e54a:	8d 19       	st.w	r6[0x4],r9
8000e54c:	e0 69 09 54 	mov	r9,2388
8000e550:	72 09       	ld.w	r9,r9[0x0]
8000e552:	12 38       	cp.w	r8,r9
8000e554:	c0 63       	brcs	8000e560 <_free_r+0x60>
8000e556:	e0 68 0d 60 	mov	r8,3424
8000e55a:	0e 9c       	mov	r12,r7
8000e55c:	70 0b       	ld.w	r11,r8[0x0]
8000e55e:	c8 5f       	rcall	8000e468 <_malloc_trim_r>
8000e560:	0e 9c       	mov	r12,r7
8000e562:	fe b0 cd 45 	rcall	80007fec <__malloc_unlock>
8000e566:	d8 22       	popm	r4-r7,pc
8000e568:	93 1b       	st.w	r9[0x4],r11
8000e56a:	58 0c       	cp.w	r12,0
8000e56c:	c0 30       	breq	8000e572 <_free_r+0x72>
8000e56e:	30 0c       	mov	r12,0
8000e570:	c1 08       	rjmp	8000e590 <_free_r+0x90>
8000e572:	6c 0e       	ld.w	lr,r6[0x0]
8000e574:	f4 c5 ff f8 	sub	r5,r10,-8
8000e578:	1c 16       	sub	r6,lr
8000e57a:	1c 08       	add	r8,lr
8000e57c:	6c 2e       	ld.w	lr,r6[0x8]
8000e57e:	0a 3e       	cp.w	lr,r5
8000e580:	f9 bc 00 01 	moveq	r12,1
8000e584:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e588:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e58c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e590:	f2 0b 00 0e 	add	lr,r9,r11
8000e594:	7c 1e       	ld.w	lr,lr[0x4]
8000e596:	ed be 00 00 	bld	lr,0x0
8000e59a:	c1 40       	breq	8000e5c2 <_free_r+0xc2>
8000e59c:	16 08       	add	r8,r11
8000e59e:	58 0c       	cp.w	r12,0
8000e5a0:	c0 d1       	brne	8000e5ba <_free_r+0xba>
8000e5a2:	e0 6e 05 4c 	mov	lr,1356
8000e5a6:	72 2b       	ld.w	r11,r9[0x8]
8000e5a8:	2f 8e       	sub	lr,-8
8000e5aa:	1c 3b       	cp.w	r11,lr
8000e5ac:	c0 71       	brne	8000e5ba <_free_r+0xba>
8000e5ae:	97 36       	st.w	r11[0xc],r6
8000e5b0:	97 26       	st.w	r11[0x8],r6
8000e5b2:	8d 2b       	st.w	r6[0x8],r11
8000e5b4:	8d 3b       	st.w	r6[0xc],r11
8000e5b6:	30 1c       	mov	r12,1
8000e5b8:	c0 58       	rjmp	8000e5c2 <_free_r+0xc2>
8000e5ba:	72 2b       	ld.w	r11,r9[0x8]
8000e5bc:	72 39       	ld.w	r9,r9[0xc]
8000e5be:	93 2b       	st.w	r9[0x8],r11
8000e5c0:	97 39       	st.w	r11[0xc],r9
8000e5c2:	10 99       	mov	r9,r8
8000e5c4:	ec 08 09 08 	st.w	r6[r8],r8
8000e5c8:	a1 a9       	sbr	r9,0x0
8000e5ca:	8d 19       	st.w	r6[0x4],r9
8000e5cc:	58 0c       	cp.w	r12,0
8000e5ce:	c5 a1       	brne	8000e682 <_free_r+0x182>
8000e5d0:	e0 48 01 ff 	cp.w	r8,511
8000e5d4:	e0 8b 00 13 	brhi	8000e5fa <_free_r+0xfa>
8000e5d8:	a3 98       	lsr	r8,0x3
8000e5da:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e5de:	72 2b       	ld.w	r11,r9[0x8]
8000e5e0:	8d 39       	st.w	r6[0xc],r9
8000e5e2:	8d 2b       	st.w	r6[0x8],r11
8000e5e4:	97 36       	st.w	r11[0xc],r6
8000e5e6:	93 26       	st.w	r9[0x8],r6
8000e5e8:	a3 48       	asr	r8,0x2
8000e5ea:	74 19       	ld.w	r9,r10[0x4]
8000e5ec:	30 1b       	mov	r11,1
8000e5ee:	f6 08 09 48 	lsl	r8,r11,r8
8000e5f2:	f3 e8 10 08 	or	r8,r9,r8
8000e5f6:	95 18       	st.w	r10[0x4],r8
8000e5f8:	c4 58       	rjmp	8000e682 <_free_r+0x182>
8000e5fa:	f0 0b 16 09 	lsr	r11,r8,0x9
8000e5fe:	58 4b       	cp.w	r11,4
8000e600:	e0 8b 00 06 	brhi	8000e60c <_free_r+0x10c>
8000e604:	f0 0b 16 06 	lsr	r11,r8,0x6
8000e608:	2c 8b       	sub	r11,-56
8000e60a:	c2 08       	rjmp	8000e64a <_free_r+0x14a>
8000e60c:	59 4b       	cp.w	r11,20
8000e60e:	e0 8b 00 04 	brhi	8000e616 <_free_r+0x116>
8000e612:	2a 5b       	sub	r11,-91
8000e614:	c1 b8       	rjmp	8000e64a <_free_r+0x14a>
8000e616:	e0 4b 00 54 	cp.w	r11,84
8000e61a:	e0 8b 00 06 	brhi	8000e626 <_free_r+0x126>
8000e61e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000e622:	29 2b       	sub	r11,-110
8000e624:	c1 38       	rjmp	8000e64a <_free_r+0x14a>
8000e626:	e0 4b 01 54 	cp.w	r11,340
8000e62a:	e0 8b 00 06 	brhi	8000e636 <_free_r+0x136>
8000e62e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000e632:	28 9b       	sub	r11,-119
8000e634:	c0 b8       	rjmp	8000e64a <_free_r+0x14a>
8000e636:	e0 4b 05 54 	cp.w	r11,1364
8000e63a:	e0 88 00 05 	brls	8000e644 <_free_r+0x144>
8000e63e:	37 eb       	mov	r11,126
8000e640:	c0 58       	rjmp	8000e64a <_free_r+0x14a>
8000e642:	d7 03       	nop
8000e644:	f0 0b 16 12 	lsr	r11,r8,0x12
8000e648:	28 4b       	sub	r11,-124
8000e64a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000e64e:	78 29       	ld.w	r9,r12[0x8]
8000e650:	18 39       	cp.w	r9,r12
8000e652:	c0 e1       	brne	8000e66e <_free_r+0x16e>
8000e654:	74 18       	ld.w	r8,r10[0x4]
8000e656:	a3 4b       	asr	r11,0x2
8000e658:	30 1c       	mov	r12,1
8000e65a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000e65e:	f1 eb 10 0b 	or	r11,r8,r11
8000e662:	12 98       	mov	r8,r9
8000e664:	95 1b       	st.w	r10[0x4],r11
8000e666:	c0 a8       	rjmp	8000e67a <_free_r+0x17a>
8000e668:	72 29       	ld.w	r9,r9[0x8]
8000e66a:	18 39       	cp.w	r9,r12
8000e66c:	c0 60       	breq	8000e678 <_free_r+0x178>
8000e66e:	72 1a       	ld.w	r10,r9[0x4]
8000e670:	e0 1a ff fc 	andl	r10,0xfffc
8000e674:	14 38       	cp.w	r8,r10
8000e676:	cf 93       	brcs	8000e668 <_free_r+0x168>
8000e678:	72 38       	ld.w	r8,r9[0xc]
8000e67a:	8d 38       	st.w	r6[0xc],r8
8000e67c:	8d 29       	st.w	r6[0x8],r9
8000e67e:	93 36       	st.w	r9[0xc],r6
8000e680:	91 26       	st.w	r8[0x8],r6
8000e682:	0e 9c       	mov	r12,r7
8000e684:	fe b0 cc b4 	rcall	80007fec <__malloc_unlock>
8000e688:	d8 22       	popm	r4-r7,pc
8000e68a:	d7 03       	nop

8000e68c <__sfvwrite_r>:
8000e68c:	d4 31       	pushm	r0-r7,lr
8000e68e:	20 3d       	sub	sp,12
8000e690:	14 94       	mov	r4,r10
8000e692:	18 95       	mov	r5,r12
8000e694:	16 97       	mov	r7,r11
8000e696:	74 28       	ld.w	r8,r10[0x8]
8000e698:	58 08       	cp.w	r8,0
8000e69a:	e0 80 01 40 	breq	8000e91a <__sfvwrite_r+0x28e>
8000e69e:	96 68       	ld.sh	r8,r11[0xc]
8000e6a0:	ed b8 00 03 	bld	r8,0x3
8000e6a4:	c0 41       	brne	8000e6ac <__sfvwrite_r+0x20>
8000e6a6:	76 48       	ld.w	r8,r11[0x10]
8000e6a8:	58 08       	cp.w	r8,0
8000e6aa:	c0 c1       	brne	8000e6c2 <__sfvwrite_r+0x36>
8000e6ac:	0e 9b       	mov	r11,r7
8000e6ae:	0a 9c       	mov	r12,r5
8000e6b0:	fe b0 f6 c4 	rcall	8000d438 <__swsetup_r>
8000e6b4:	c0 70       	breq	8000e6c2 <__sfvwrite_r+0x36>
8000e6b6:	8e 68       	ld.sh	r8,r7[0xc]
8000e6b8:	a7 a8       	sbr	r8,0x6
8000e6ba:	ae 68       	st.h	r7[0xc],r8
8000e6bc:	30 98       	mov	r8,9
8000e6be:	8b 38       	st.w	r5[0xc],r8
8000e6c0:	c2 b9       	rjmp	8000e916 <__sfvwrite_r+0x28a>
8000e6c2:	8e 63       	ld.sh	r3,r7[0xc]
8000e6c4:	68 00       	ld.w	r0,r4[0x0]
8000e6c6:	06 96       	mov	r6,r3
8000e6c8:	e2 16 00 02 	andl	r6,0x2,COH
8000e6cc:	c2 10       	breq	8000e70e <__sfvwrite_r+0x82>
8000e6ce:	30 03       	mov	r3,0
8000e6d0:	e0 62 04 00 	mov	r2,1024
8000e6d4:	06 96       	mov	r6,r3
8000e6d6:	c0 48       	rjmp	8000e6de <__sfvwrite_r+0x52>
8000e6d8:	60 03       	ld.w	r3,r0[0x0]
8000e6da:	60 16       	ld.w	r6,r0[0x4]
8000e6dc:	2f 80       	sub	r0,-8
8000e6de:	58 06       	cp.w	r6,0
8000e6e0:	cf c0       	breq	8000e6d8 <__sfvwrite_r+0x4c>
8000e6e2:	e0 46 04 00 	cp.w	r6,1024
8000e6e6:	ec 09 17 80 	movls	r9,r6
8000e6ea:	e4 09 17 b0 	movhi	r9,r2
8000e6ee:	06 9a       	mov	r10,r3
8000e6f0:	6e a8       	ld.w	r8,r7[0x28]
8000e6f2:	6e 8b       	ld.w	r11,r7[0x20]
8000e6f4:	0a 9c       	mov	r12,r5
8000e6f6:	5d 18       	icall	r8
8000e6f8:	18 16       	sub	r6,r12
8000e6fa:	58 0c       	cp.w	r12,0
8000e6fc:	e0 8a 01 0a 	brle	8000e910 <__sfvwrite_r+0x284>
8000e700:	68 28       	ld.w	r8,r4[0x8]
8000e702:	18 18       	sub	r8,r12
8000e704:	89 28       	st.w	r4[0x8],r8
8000e706:	e0 80 01 0a 	breq	8000e91a <__sfvwrite_r+0x28e>
8000e70a:	18 03       	add	r3,r12
8000e70c:	ce 9b       	rjmp	8000e6de <__sfvwrite_r+0x52>
8000e70e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e712:	c0 70       	breq	8000e720 <__sfvwrite_r+0x94>
8000e714:	50 06       	stdsp	sp[0x0],r6
8000e716:	0c 93       	mov	r3,r6
8000e718:	0c 91       	mov	r1,r6
8000e71a:	50 15       	stdsp	sp[0x4],r5
8000e71c:	08 92       	mov	r2,r4
8000e71e:	c9 c8       	rjmp	8000e856 <__sfvwrite_r+0x1ca>
8000e720:	06 96       	mov	r6,r3
8000e722:	08 91       	mov	r1,r4
8000e724:	c0 48       	rjmp	8000e72c <__sfvwrite_r+0xa0>
8000e726:	60 03       	ld.w	r3,r0[0x0]
8000e728:	60 16       	ld.w	r6,r0[0x4]
8000e72a:	2f 80       	sub	r0,-8
8000e72c:	58 06       	cp.w	r6,0
8000e72e:	cf c0       	breq	8000e726 <__sfvwrite_r+0x9a>
8000e730:	8e 68       	ld.sh	r8,r7[0xc]
8000e732:	6e 24       	ld.w	r4,r7[0x8]
8000e734:	10 99       	mov	r9,r8
8000e736:	e2 19 02 00 	andl	r9,0x200,COH
8000e73a:	c5 50       	breq	8000e7e4 <__sfvwrite_r+0x158>
8000e73c:	08 36       	cp.w	r6,r4
8000e73e:	c4 43       	brcs	8000e7c6 <__sfvwrite_r+0x13a>
8000e740:	10 99       	mov	r9,r8
8000e742:	e2 19 04 80 	andl	r9,0x480,COH
8000e746:	c4 00       	breq	8000e7c6 <__sfvwrite_r+0x13a>
8000e748:	6e 4b       	ld.w	r11,r7[0x10]
8000e74a:	6e 09       	ld.w	r9,r7[0x0]
8000e74c:	16 19       	sub	r9,r11
8000e74e:	50 09       	stdsp	sp[0x0],r9
8000e750:	6e 59       	ld.w	r9,r7[0x14]
8000e752:	10 9c       	mov	r12,r8
8000e754:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e758:	30 28       	mov	r8,2
8000e75a:	f4 08 0c 08 	divs	r8,r10,r8
8000e75e:	fa e9 00 04 	st.d	sp[4],r8
8000e762:	10 94       	mov	r4,r8
8000e764:	40 09       	lddsp	r9,sp[0x0]
8000e766:	e2 1c 04 00 	andl	r12,0x400,COH
8000e76a:	2f f9       	sub	r9,-1
8000e76c:	0c 09       	add	r9,r6
8000e76e:	12 38       	cp.w	r8,r9
8000e770:	f2 04 17 30 	movlo	r4,r9
8000e774:	58 0c       	cp.w	r12,0
8000e776:	c1 10       	breq	8000e798 <__sfvwrite_r+0x10c>
8000e778:	08 9b       	mov	r11,r4
8000e77a:	0a 9c       	mov	r12,r5
8000e77c:	fe b0 e0 4e 	rcall	8000a818 <_malloc_r>
8000e780:	18 92       	mov	r2,r12
8000e782:	c1 40       	breq	8000e7aa <__sfvwrite_r+0x11e>
8000e784:	40 0a       	lddsp	r10,sp[0x0]
8000e786:	6e 4b       	ld.w	r11,r7[0x10]
8000e788:	fe b0 e2 77 	rcall	8000ac76 <memcpy>
8000e78c:	8e 68       	ld.sh	r8,r7[0xc]
8000e78e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e792:	a7 b8       	sbr	r8,0x7
8000e794:	ae 68       	st.h	r7[0xc],r8
8000e796:	c0 d8       	rjmp	8000e7b0 <__sfvwrite_r+0x124>
8000e798:	08 9a       	mov	r10,r4
8000e79a:	0a 9c       	mov	r12,r5
8000e79c:	fe b0 e3 18 	rcall	8000adcc <_realloc_r>
8000e7a0:	18 92       	mov	r2,r12
8000e7a2:	c0 71       	brne	8000e7b0 <__sfvwrite_r+0x124>
8000e7a4:	6e 4b       	ld.w	r11,r7[0x10]
8000e7a6:	0a 9c       	mov	r12,r5
8000e7a8:	ca ce       	rcall	8000e500 <_free_r>
8000e7aa:	30 c8       	mov	r8,12
8000e7ac:	8b 38       	st.w	r5[0xc],r8
8000e7ae:	cb 18       	rjmp	8000e910 <__sfvwrite_r+0x284>
8000e7b0:	40 0a       	lddsp	r10,sp[0x0]
8000e7b2:	40 09       	lddsp	r9,sp[0x0]
8000e7b4:	e8 0a 01 0a 	sub	r10,r4,r10
8000e7b8:	e4 09 00 08 	add	r8,r2,r9
8000e7bc:	8f 54       	st.w	r7[0x14],r4
8000e7be:	8f 2a       	st.w	r7[0x8],r10
8000e7c0:	8f 08       	st.w	r7[0x0],r8
8000e7c2:	8f 42       	st.w	r7[0x10],r2
8000e7c4:	0c 94       	mov	r4,r6
8000e7c6:	08 36       	cp.w	r6,r4
8000e7c8:	ec 04 17 30 	movlo	r4,r6
8000e7cc:	06 9b       	mov	r11,r3
8000e7ce:	08 9a       	mov	r10,r4
8000e7d0:	6e 0c       	ld.w	r12,r7[0x0]
8000e7d2:	c3 ad       	rcall	8000ea46 <memmove>
8000e7d4:	6e 08       	ld.w	r8,r7[0x0]
8000e7d6:	08 08       	add	r8,r4
8000e7d8:	8f 08       	st.w	r7[0x0],r8
8000e7da:	6e 28       	ld.w	r8,r7[0x8]
8000e7dc:	08 18       	sub	r8,r4
8000e7de:	0c 94       	mov	r4,r6
8000e7e0:	8f 28       	st.w	r7[0x8],r8
8000e7e2:	c2 e8       	rjmp	8000e83e <__sfvwrite_r+0x1b2>
8000e7e4:	08 36       	cp.w	r6,r4
8000e7e6:	5f ba       	srhi	r10
8000e7e8:	6e 0c       	ld.w	r12,r7[0x0]
8000e7ea:	6e 48       	ld.w	r8,r7[0x10]
8000e7ec:	10 3c       	cp.w	r12,r8
8000e7ee:	5f b8       	srhi	r8
8000e7f0:	f5 e8 00 08 	and	r8,r10,r8
8000e7f4:	f2 08 18 00 	cp.b	r8,r9
8000e7f8:	c0 d0       	breq	8000e812 <__sfvwrite_r+0x186>
8000e7fa:	06 9b       	mov	r11,r3
8000e7fc:	08 9a       	mov	r10,r4
8000e7fe:	c2 4d       	rcall	8000ea46 <memmove>
8000e800:	6e 08       	ld.w	r8,r7[0x0]
8000e802:	08 08       	add	r8,r4
8000e804:	0e 9b       	mov	r11,r7
8000e806:	8f 08       	st.w	r7[0x0],r8
8000e808:	0a 9c       	mov	r12,r5
8000e80a:	fe b0 fd 09 	rcall	8000e21c <_fflush_r>
8000e80e:	c1 80       	breq	8000e83e <__sfvwrite_r+0x1b2>
8000e810:	c8 08       	rjmp	8000e910 <__sfvwrite_r+0x284>
8000e812:	6e 59       	ld.w	r9,r7[0x14]
8000e814:	12 36       	cp.w	r6,r9
8000e816:	c0 a3       	brcs	8000e82a <__sfvwrite_r+0x19e>
8000e818:	6e a8       	ld.w	r8,r7[0x28]
8000e81a:	06 9a       	mov	r10,r3
8000e81c:	6e 8b       	ld.w	r11,r7[0x20]
8000e81e:	0a 9c       	mov	r12,r5
8000e820:	5d 18       	icall	r8
8000e822:	18 94       	mov	r4,r12
8000e824:	e0 89 00 0d 	brgt	8000e83e <__sfvwrite_r+0x1b2>
8000e828:	c7 48       	rjmp	8000e910 <__sfvwrite_r+0x284>
8000e82a:	0c 9a       	mov	r10,r6
8000e82c:	06 9b       	mov	r11,r3
8000e82e:	c0 cd       	rcall	8000ea46 <memmove>
8000e830:	6e 08       	ld.w	r8,r7[0x0]
8000e832:	0c 08       	add	r8,r6
8000e834:	0c 94       	mov	r4,r6
8000e836:	8f 08       	st.w	r7[0x0],r8
8000e838:	6e 28       	ld.w	r8,r7[0x8]
8000e83a:	0c 18       	sub	r8,r6
8000e83c:	8f 28       	st.w	r7[0x8],r8
8000e83e:	62 28       	ld.w	r8,r1[0x8]
8000e840:	08 18       	sub	r8,r4
8000e842:	83 28       	st.w	r1[0x8],r8
8000e844:	c6 b0       	breq	8000e91a <__sfvwrite_r+0x28e>
8000e846:	08 16       	sub	r6,r4
8000e848:	08 03       	add	r3,r4
8000e84a:	c7 1b       	rjmp	8000e72c <__sfvwrite_r+0xa0>
8000e84c:	60 03       	ld.w	r3,r0[0x0]
8000e84e:	60 11       	ld.w	r1,r0[0x4]
8000e850:	30 08       	mov	r8,0
8000e852:	2f 80       	sub	r0,-8
8000e854:	50 08       	stdsp	sp[0x0],r8
8000e856:	58 01       	cp.w	r1,0
8000e858:	cf a0       	breq	8000e84c <__sfvwrite_r+0x1c0>
8000e85a:	40 0a       	lddsp	r10,sp[0x0]
8000e85c:	58 0a       	cp.w	r10,0
8000e85e:	c1 41       	brne	8000e886 <__sfvwrite_r+0x1fa>
8000e860:	e2 c6 ff ff 	sub	r6,r1,-1
8000e864:	02 9a       	mov	r10,r1
8000e866:	30 ab       	mov	r11,10
8000e868:	06 9c       	mov	r12,r3
8000e86a:	ce 3c       	rcall	8000ea30 <memchr>
8000e86c:	f8 c8 ff ff 	sub	r8,r12,-1
8000e870:	58 0c       	cp.w	r12,0
8000e872:	f1 d3 e1 16 	subne	r6,r8,r3
8000e876:	f9 b9 01 01 	movne	r9,1
8000e87a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e87e:	f9 b8 00 01 	moveq	r8,1
8000e882:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e886:	02 36       	cp.w	r6,r1
8000e888:	ec 04 17 80 	movls	r4,r6
8000e88c:	e2 04 17 b0 	movhi	r4,r1
8000e890:	6e 59       	ld.w	r9,r7[0x14]
8000e892:	6e 25       	ld.w	r5,r7[0x8]
8000e894:	f2 05 00 05 	add	r5,r9,r5
8000e898:	0a 34       	cp.w	r4,r5
8000e89a:	5f 9a       	srgt	r10
8000e89c:	6e 0c       	ld.w	r12,r7[0x0]
8000e89e:	6e 48       	ld.w	r8,r7[0x10]
8000e8a0:	10 3c       	cp.w	r12,r8
8000e8a2:	5f b8       	srhi	r8
8000e8a4:	f5 e8 00 08 	and	r8,r10,r8
8000e8a8:	30 0a       	mov	r10,0
8000e8aa:	f4 08 18 00 	cp.b	r8,r10
8000e8ae:	c0 d0       	breq	8000e8c8 <__sfvwrite_r+0x23c>
8000e8b0:	06 9b       	mov	r11,r3
8000e8b2:	0a 9a       	mov	r10,r5
8000e8b4:	cc 9c       	rcall	8000ea46 <memmove>
8000e8b6:	6e 08       	ld.w	r8,r7[0x0]
8000e8b8:	0a 08       	add	r8,r5
8000e8ba:	0e 9b       	mov	r11,r7
8000e8bc:	8f 08       	st.w	r7[0x0],r8
8000e8be:	40 1c       	lddsp	r12,sp[0x4]
8000e8c0:	fe b0 fc ae 	rcall	8000e21c <_fflush_r>
8000e8c4:	c1 70       	breq	8000e8f2 <__sfvwrite_r+0x266>
8000e8c6:	c2 58       	rjmp	8000e910 <__sfvwrite_r+0x284>
8000e8c8:	12 34       	cp.w	r4,r9
8000e8ca:	c0 a5       	brlt	8000e8de <__sfvwrite_r+0x252>
8000e8cc:	6e a8       	ld.w	r8,r7[0x28]
8000e8ce:	06 9a       	mov	r10,r3
8000e8d0:	6e 8b       	ld.w	r11,r7[0x20]
8000e8d2:	40 1c       	lddsp	r12,sp[0x4]
8000e8d4:	5d 18       	icall	r8
8000e8d6:	18 95       	mov	r5,r12
8000e8d8:	e0 89 00 0d 	brgt	8000e8f2 <__sfvwrite_r+0x266>
8000e8dc:	c1 a8       	rjmp	8000e910 <__sfvwrite_r+0x284>
8000e8de:	08 9a       	mov	r10,r4
8000e8e0:	06 9b       	mov	r11,r3
8000e8e2:	cb 2c       	rcall	8000ea46 <memmove>
8000e8e4:	6e 08       	ld.w	r8,r7[0x0]
8000e8e6:	08 08       	add	r8,r4
8000e8e8:	08 95       	mov	r5,r4
8000e8ea:	8f 08       	st.w	r7[0x0],r8
8000e8ec:	6e 28       	ld.w	r8,r7[0x8]
8000e8ee:	08 18       	sub	r8,r4
8000e8f0:	8f 28       	st.w	r7[0x8],r8
8000e8f2:	0a 16       	sub	r6,r5
8000e8f4:	c0 71       	brne	8000e902 <__sfvwrite_r+0x276>
8000e8f6:	0e 9b       	mov	r11,r7
8000e8f8:	40 1c       	lddsp	r12,sp[0x4]
8000e8fa:	fe b0 fc 91 	rcall	8000e21c <_fflush_r>
8000e8fe:	c0 91       	brne	8000e910 <__sfvwrite_r+0x284>
8000e900:	50 06       	stdsp	sp[0x0],r6
8000e902:	64 28       	ld.w	r8,r2[0x8]
8000e904:	0a 18       	sub	r8,r5
8000e906:	85 28       	st.w	r2[0x8],r8
8000e908:	c0 90       	breq	8000e91a <__sfvwrite_r+0x28e>
8000e90a:	0a 11       	sub	r1,r5
8000e90c:	0a 03       	add	r3,r5
8000e90e:	ca 4b       	rjmp	8000e856 <__sfvwrite_r+0x1ca>
8000e910:	8e 68       	ld.sh	r8,r7[0xc]
8000e912:	a7 a8       	sbr	r8,0x6
8000e914:	ae 68       	st.h	r7[0xc],r8
8000e916:	3f fc       	mov	r12,-1
8000e918:	c0 28       	rjmp	8000e91c <__sfvwrite_r+0x290>
8000e91a:	30 0c       	mov	r12,0
8000e91c:	2f dd       	sub	sp,-12
8000e91e:	d8 32       	popm	r0-r7,pc

8000e920 <_fwalk>:
8000e920:	d4 31       	pushm	r0-r7,lr
8000e922:	30 05       	mov	r5,0
8000e924:	16 91       	mov	r1,r11
8000e926:	f8 c7 ff 28 	sub	r7,r12,-216
8000e92a:	0a 92       	mov	r2,r5
8000e92c:	fe b0 fc fe 	rcall	8000e328 <__sfp_lock_acquire>
8000e930:	3f f3       	mov	r3,-1
8000e932:	c1 68       	rjmp	8000e95e <_fwalk+0x3e>
8000e934:	6e 26       	ld.w	r6,r7[0x8]
8000e936:	6e 14       	ld.w	r4,r7[0x4]
8000e938:	2f 46       	sub	r6,-12
8000e93a:	c0 c8       	rjmp	8000e952 <_fwalk+0x32>
8000e93c:	8c 08       	ld.sh	r8,r6[0x0]
8000e93e:	e4 08 19 00 	cp.h	r8,r2
8000e942:	c0 70       	breq	8000e950 <_fwalk+0x30>
8000e944:	8c 18       	ld.sh	r8,r6[0x2]
8000e946:	e6 08 19 00 	cp.h	r8,r3
8000e94a:	c0 30       	breq	8000e950 <_fwalk+0x30>
8000e94c:	5d 11       	icall	r1
8000e94e:	18 45       	or	r5,r12
8000e950:	2a 46       	sub	r6,-92
8000e952:	20 14       	sub	r4,1
8000e954:	ec cc 00 0c 	sub	r12,r6,12
8000e958:	58 04       	cp.w	r4,0
8000e95a:	cf 14       	brge	8000e93c <_fwalk+0x1c>
8000e95c:	6e 07       	ld.w	r7,r7[0x0]
8000e95e:	58 07       	cp.w	r7,0
8000e960:	ce a1       	brne	8000e934 <_fwalk+0x14>
8000e962:	fe b0 fc e4 	rcall	8000e32a <__sfp_lock_release>
8000e966:	0a 9c       	mov	r12,r5
8000e968:	d8 32       	popm	r0-r7,pc
8000e96a:	d7 03       	nop

8000e96c <_localeconv_r>:
8000e96c:	fe cc dd 0c 	sub	r12,pc,-8948
8000e970:	5e fc       	retal	r12
8000e972:	d7 03       	nop

8000e974 <__smakebuf_r>:
8000e974:	d4 21       	pushm	r4-r7,lr
8000e976:	20 fd       	sub	sp,60
8000e978:	96 68       	ld.sh	r8,r11[0xc]
8000e97a:	16 97       	mov	r7,r11
8000e97c:	18 96       	mov	r6,r12
8000e97e:	e2 18 00 02 	andl	r8,0x2,COH
8000e982:	c3 d1       	brne	8000e9fc <__smakebuf_r+0x88>
8000e984:	96 7b       	ld.sh	r11,r11[0xe]
8000e986:	f0 0b 19 00 	cp.h	r11,r8
8000e98a:	c0 55       	brlt	8000e994 <__smakebuf_r+0x20>
8000e98c:	1a 9a       	mov	r10,sp
8000e98e:	e0 a0 04 75 	rcall	8000f278 <_fstat_r>
8000e992:	c0 f4       	brge	8000e9b0 <__smakebuf_r+0x3c>
8000e994:	8e 65       	ld.sh	r5,r7[0xc]
8000e996:	0a 98       	mov	r8,r5
8000e998:	ab b8       	sbr	r8,0xb
8000e99a:	e2 15 00 80 	andl	r5,0x80,COH
8000e99e:	ae 68       	st.h	r7[0xc],r8
8000e9a0:	30 04       	mov	r4,0
8000e9a2:	e0 68 04 00 	mov	r8,1024
8000e9a6:	f9 b5 01 40 	movne	r5,64
8000e9aa:	f0 05 17 00 	moveq	r5,r8
8000e9ae:	c1 c8       	rjmp	8000e9e6 <__smakebuf_r+0x72>
8000e9b0:	40 18       	lddsp	r8,sp[0x4]
8000e9b2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e9b6:	e0 48 20 00 	cp.w	r8,8192
8000e9ba:	5f 04       	sreq	r4
8000e9bc:	e0 48 80 00 	cp.w	r8,32768
8000e9c0:	c0 e1       	brne	8000e9dc <__smakebuf_r+0x68>
8000e9c2:	6e b9       	ld.w	r9,r7[0x2c]
8000e9c4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000e9c8:	10 39       	cp.w	r9,r8
8000e9ca:	c0 91       	brne	8000e9dc <__smakebuf_r+0x68>
8000e9cc:	8e 68       	ld.sh	r8,r7[0xc]
8000e9ce:	e0 65 04 00 	mov	r5,1024
8000e9d2:	ab a8       	sbr	r8,0xa
8000e9d4:	ef 45 00 50 	st.w	r7[80],r5
8000e9d8:	ae 68       	st.h	r7[0xc],r8
8000e9da:	c0 68       	rjmp	8000e9e6 <__smakebuf_r+0x72>
8000e9dc:	8e 68       	ld.sh	r8,r7[0xc]
8000e9de:	e0 65 04 00 	mov	r5,1024
8000e9e2:	ab b8       	sbr	r8,0xb
8000e9e4:	ae 68       	st.h	r7[0xc],r8
8000e9e6:	0a 9b       	mov	r11,r5
8000e9e8:	0c 9c       	mov	r12,r6
8000e9ea:	fe b0 df 17 	rcall	8000a818 <_malloc_r>
8000e9ee:	8e 68       	ld.sh	r8,r7[0xc]
8000e9f0:	c0 d1       	brne	8000ea0a <__smakebuf_r+0x96>
8000e9f2:	ed b8 00 09 	bld	r8,0x9
8000e9f6:	c1 b0       	breq	8000ea2c <__smakebuf_r+0xb8>
8000e9f8:	a1 b8       	sbr	r8,0x1
8000e9fa:	ae 68       	st.h	r7[0xc],r8
8000e9fc:	ee c8 ff b9 	sub	r8,r7,-71
8000ea00:	8f 48       	st.w	r7[0x10],r8
8000ea02:	8f 08       	st.w	r7[0x0],r8
8000ea04:	30 18       	mov	r8,1
8000ea06:	8f 58       	st.w	r7[0x14],r8
8000ea08:	c1 28       	rjmp	8000ea2c <__smakebuf_r+0xb8>
8000ea0a:	a7 b8       	sbr	r8,0x7
8000ea0c:	8f 4c       	st.w	r7[0x10],r12
8000ea0e:	ae 68       	st.h	r7[0xc],r8
8000ea10:	8f 55       	st.w	r7[0x14],r5
8000ea12:	fe c8 06 e6 	sub	r8,pc,1766
8000ea16:	8f 0c       	st.w	r7[0x0],r12
8000ea18:	8d a8       	st.w	r6[0x28],r8
8000ea1a:	58 04       	cp.w	r4,0
8000ea1c:	c0 80       	breq	8000ea2c <__smakebuf_r+0xb8>
8000ea1e:	8e 7c       	ld.sh	r12,r7[0xe]
8000ea20:	fe b0 e3 94 	rcall	8000b148 <isatty>
8000ea24:	c0 40       	breq	8000ea2c <__smakebuf_r+0xb8>
8000ea26:	8e 68       	ld.sh	r8,r7[0xc]
8000ea28:	a1 a8       	sbr	r8,0x0
8000ea2a:	ae 68       	st.h	r7[0xc],r8
8000ea2c:	2f 1d       	sub	sp,-60
8000ea2e:	d8 22       	popm	r4-r7,pc

8000ea30 <memchr>:
8000ea30:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ea34:	c0 68       	rjmp	8000ea40 <memchr+0x10>
8000ea36:	20 1a       	sub	r10,1
8000ea38:	19 88       	ld.ub	r8,r12[0x0]
8000ea3a:	16 38       	cp.w	r8,r11
8000ea3c:	5e 0c       	reteq	r12
8000ea3e:	2f fc       	sub	r12,-1
8000ea40:	58 0a       	cp.w	r10,0
8000ea42:	cf a1       	brne	8000ea36 <memchr+0x6>
8000ea44:	5e fa       	retal	r10

8000ea46 <memmove>:
8000ea46:	d4 01       	pushm	lr
8000ea48:	18 3b       	cp.w	r11,r12
8000ea4a:	c1 92       	brcc	8000ea7c <memmove+0x36>
8000ea4c:	f6 0a 00 09 	add	r9,r11,r10
8000ea50:	12 3c       	cp.w	r12,r9
8000ea52:	c1 52       	brcc	8000ea7c <memmove+0x36>
8000ea54:	f8 0a 00 0b 	add	r11,r12,r10
8000ea58:	30 08       	mov	r8,0
8000ea5a:	c0 68       	rjmp	8000ea66 <memmove+0x20>
8000ea5c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ea60:	20 1a       	sub	r10,1
8000ea62:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ea66:	20 18       	sub	r8,1
8000ea68:	58 0a       	cp.w	r10,0
8000ea6a:	cf 91       	brne	8000ea5c <memmove+0x16>
8000ea6c:	d8 02       	popm	pc
8000ea6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ea72:	20 1a       	sub	r10,1
8000ea74:	f8 08 0b 09 	st.b	r12[r8],r9
8000ea78:	2f f8       	sub	r8,-1
8000ea7a:	c0 28       	rjmp	8000ea7e <memmove+0x38>
8000ea7c:	30 08       	mov	r8,0
8000ea7e:	58 0a       	cp.w	r10,0
8000ea80:	cf 71       	brne	8000ea6e <memmove+0x28>
8000ea82:	d8 02       	popm	pc

8000ea84 <__hi0bits>:
8000ea84:	18 98       	mov	r8,r12
8000ea86:	e0 1c 00 00 	andl	r12,0x0
8000ea8a:	f0 09 15 10 	lsl	r9,r8,0x10
8000ea8e:	58 0c       	cp.w	r12,0
8000ea90:	f2 08 17 00 	moveq	r8,r9
8000ea94:	f9 bc 00 10 	moveq	r12,16
8000ea98:	f9 bc 01 00 	movne	r12,0
8000ea9c:	10 9a       	mov	r10,r8
8000ea9e:	f0 09 15 08 	lsl	r9,r8,0x8
8000eaa2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000eaa6:	f7 bc 00 f8 	subeq	r12,-8
8000eaaa:	f2 08 17 00 	moveq	r8,r9
8000eaae:	10 9a       	mov	r10,r8
8000eab0:	f0 09 15 04 	lsl	r9,r8,0x4
8000eab4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000eab8:	f7 bc 00 fc 	subeq	r12,-4
8000eabc:	f2 08 17 00 	moveq	r8,r9
8000eac0:	10 9a       	mov	r10,r8
8000eac2:	f0 09 15 02 	lsl	r9,r8,0x2
8000eac6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000eaca:	f7 bc 00 fe 	subeq	r12,-2
8000eace:	f2 08 17 00 	moveq	r8,r9
8000ead2:	58 08       	cp.w	r8,0
8000ead4:	5e 5c       	retlt	r12
8000ead6:	ed b8 00 1e 	bld	r8,0x1e
8000eada:	f9 bc 01 20 	movne	r12,32
8000eade:	f7 bc 00 ff 	subeq	r12,-1
8000eae2:	5e fc       	retal	r12

8000eae4 <__lo0bits>:
8000eae4:	18 99       	mov	r9,r12
8000eae6:	78 08       	ld.w	r8,r12[0x0]
8000eae8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000eaec:	c1 50       	breq	8000eb16 <__lo0bits+0x32>
8000eaee:	ed b8 00 00 	bld	r8,0x0
8000eaf2:	c0 21       	brne	8000eaf6 <__lo0bits+0x12>
8000eaf4:	5e fd       	retal	0
8000eaf6:	10 9b       	mov	r11,r8
8000eaf8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000eafc:	e2 1b 00 02 	andl	r11,0x2,COH
8000eb00:	a3 88       	lsr	r8,0x2
8000eb02:	58 0b       	cp.w	r11,0
8000eb04:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000eb08:	f9 bc 01 01 	movne	r12,1
8000eb0c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000eb10:	f9 bc 00 02 	moveq	r12,2
8000eb14:	5e fc       	retal	r12
8000eb16:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000eb1a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000eb1e:	58 0a       	cp.w	r10,0
8000eb20:	f6 08 17 00 	moveq	r8,r11
8000eb24:	f9 bc 00 10 	moveq	r12,16
8000eb28:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000eb2c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000eb30:	58 0b       	cp.w	r11,0
8000eb32:	f7 bc 00 f8 	subeq	r12,-8
8000eb36:	f4 08 17 00 	moveq	r8,r10
8000eb3a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000eb3e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000eb42:	58 0b       	cp.w	r11,0
8000eb44:	f7 bc 00 fc 	subeq	r12,-4
8000eb48:	f4 08 17 00 	moveq	r8,r10
8000eb4c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000eb50:	f0 0a 16 02 	lsr	r10,r8,0x2
8000eb54:	58 0b       	cp.w	r11,0
8000eb56:	f7 bc 00 fe 	subeq	r12,-2
8000eb5a:	f4 08 17 00 	moveq	r8,r10
8000eb5e:	ed b8 00 00 	bld	r8,0x0
8000eb62:	c0 60       	breq	8000eb6e <__lo0bits+0x8a>
8000eb64:	a1 98       	lsr	r8,0x1
8000eb66:	c0 31       	brne	8000eb6c <__lo0bits+0x88>
8000eb68:	32 0c       	mov	r12,32
8000eb6a:	5e fc       	retal	r12
8000eb6c:	2f fc       	sub	r12,-1
8000eb6e:	93 08       	st.w	r9[0x0],r8
8000eb70:	5e fc       	retal	r12

8000eb72 <__mcmp>:
8000eb72:	d4 01       	pushm	lr
8000eb74:	18 98       	mov	r8,r12
8000eb76:	76 49       	ld.w	r9,r11[0x10]
8000eb78:	78 4c       	ld.w	r12,r12[0x10]
8000eb7a:	12 1c       	sub	r12,r9
8000eb7c:	c1 31       	brne	8000eba2 <__mcmp+0x30>
8000eb7e:	2f b9       	sub	r9,-5
8000eb80:	a3 69       	lsl	r9,0x2
8000eb82:	12 0b       	add	r11,r9
8000eb84:	f0 09 00 09 	add	r9,r8,r9
8000eb88:	2e c8       	sub	r8,-20
8000eb8a:	13 4e       	ld.w	lr,--r9
8000eb8c:	17 4a       	ld.w	r10,--r11
8000eb8e:	14 3e       	cp.w	lr,r10
8000eb90:	c0 60       	breq	8000eb9c <__mcmp+0x2a>
8000eb92:	f9 bc 03 ff 	movlo	r12,-1
8000eb96:	f9 bc 02 01 	movhs	r12,1
8000eb9a:	d8 02       	popm	pc
8000eb9c:	10 39       	cp.w	r9,r8
8000eb9e:	fe 9b ff f6 	brhi	8000eb8a <__mcmp+0x18>
8000eba2:	d8 02       	popm	pc

8000eba4 <_Bfree>:
8000eba4:	d4 21       	pushm	r4-r7,lr
8000eba6:	18 97       	mov	r7,r12
8000eba8:	16 95       	mov	r5,r11
8000ebaa:	78 96       	ld.w	r6,r12[0x24]
8000ebac:	58 06       	cp.w	r6,0
8000ebae:	c0 91       	brne	8000ebc0 <_Bfree+0x1c>
8000ebb0:	31 0c       	mov	r12,16
8000ebb2:	fe b0 de 2b 	rcall	8000a808 <malloc>
8000ebb6:	99 36       	st.w	r12[0xc],r6
8000ebb8:	8f 9c       	st.w	r7[0x24],r12
8000ebba:	99 16       	st.w	r12[0x4],r6
8000ebbc:	99 26       	st.w	r12[0x8],r6
8000ebbe:	99 06       	st.w	r12[0x0],r6
8000ebc0:	58 05       	cp.w	r5,0
8000ebc2:	c0 90       	breq	8000ebd4 <_Bfree+0x30>
8000ebc4:	6a 19       	ld.w	r9,r5[0x4]
8000ebc6:	6e 98       	ld.w	r8,r7[0x24]
8000ebc8:	70 38       	ld.w	r8,r8[0xc]
8000ebca:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ebce:	8b 0a       	st.w	r5[0x0],r10
8000ebd0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ebd4:	d8 22       	popm	r4-r7,pc
8000ebd6:	d7 03       	nop

8000ebd8 <_Balloc>:
8000ebd8:	d4 21       	pushm	r4-r7,lr
8000ebda:	18 97       	mov	r7,r12
8000ebdc:	16 96       	mov	r6,r11
8000ebde:	78 95       	ld.w	r5,r12[0x24]
8000ebe0:	58 05       	cp.w	r5,0
8000ebe2:	c0 91       	brne	8000ebf4 <_Balloc+0x1c>
8000ebe4:	31 0c       	mov	r12,16
8000ebe6:	fe b0 de 11 	rcall	8000a808 <malloc>
8000ebea:	99 35       	st.w	r12[0xc],r5
8000ebec:	8f 9c       	st.w	r7[0x24],r12
8000ebee:	99 15       	st.w	r12[0x4],r5
8000ebf0:	99 25       	st.w	r12[0x8],r5
8000ebf2:	99 05       	st.w	r12[0x0],r5
8000ebf4:	6e 95       	ld.w	r5,r7[0x24]
8000ebf6:	6a 38       	ld.w	r8,r5[0xc]
8000ebf8:	58 08       	cp.w	r8,0
8000ebfa:	c0 b1       	brne	8000ec10 <_Balloc+0x38>
8000ebfc:	31 0a       	mov	r10,16
8000ebfe:	30 4b       	mov	r11,4
8000ec00:	0e 9c       	mov	r12,r7
8000ec02:	e0 a0 02 9b 	rcall	8000f138 <_calloc_r>
8000ec06:	8b 3c       	st.w	r5[0xc],r12
8000ec08:	6e 98       	ld.w	r8,r7[0x24]
8000ec0a:	70 3c       	ld.w	r12,r8[0xc]
8000ec0c:	58 0c       	cp.w	r12,0
8000ec0e:	c1 b0       	breq	8000ec44 <_Balloc+0x6c>
8000ec10:	6e 98       	ld.w	r8,r7[0x24]
8000ec12:	70 38       	ld.w	r8,r8[0xc]
8000ec14:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ec18:	70 0c       	ld.w	r12,r8[0x0]
8000ec1a:	58 0c       	cp.w	r12,0
8000ec1c:	c0 40       	breq	8000ec24 <_Balloc+0x4c>
8000ec1e:	78 09       	ld.w	r9,r12[0x0]
8000ec20:	91 09       	st.w	r8[0x0],r9
8000ec22:	c0 e8       	rjmp	8000ec3e <_Balloc+0x66>
8000ec24:	0e 9c       	mov	r12,r7
8000ec26:	30 17       	mov	r7,1
8000ec28:	0e 9b       	mov	r11,r7
8000ec2a:	ee 06 09 47 	lsl	r7,r7,r6
8000ec2e:	ee ca ff fb 	sub	r10,r7,-5
8000ec32:	a3 6a       	lsl	r10,0x2
8000ec34:	e0 a0 02 82 	rcall	8000f138 <_calloc_r>
8000ec38:	c0 60       	breq	8000ec44 <_Balloc+0x6c>
8000ec3a:	99 16       	st.w	r12[0x4],r6
8000ec3c:	99 27       	st.w	r12[0x8],r7
8000ec3e:	30 08       	mov	r8,0
8000ec40:	99 38       	st.w	r12[0xc],r8
8000ec42:	99 48       	st.w	r12[0x10],r8
8000ec44:	d8 22       	popm	r4-r7,pc
8000ec46:	d7 03       	nop

8000ec48 <__d2b>:
8000ec48:	d4 31       	pushm	r0-r7,lr
8000ec4a:	20 2d       	sub	sp,8
8000ec4c:	16 93       	mov	r3,r11
8000ec4e:	12 96       	mov	r6,r9
8000ec50:	10 95       	mov	r5,r8
8000ec52:	14 92       	mov	r2,r10
8000ec54:	30 1b       	mov	r11,1
8000ec56:	cc 1f       	rcall	8000ebd8 <_Balloc>
8000ec58:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000ec5c:	50 09       	stdsp	sp[0x0],r9
8000ec5e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000ec62:	b5 a9       	sbr	r9,0x14
8000ec64:	f0 01 16 14 	lsr	r1,r8,0x14
8000ec68:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ec6c:	18 94       	mov	r4,r12
8000ec6e:	58 02       	cp.w	r2,0
8000ec70:	c1 d0       	breq	8000ecaa <__d2b+0x62>
8000ec72:	fa cc ff f8 	sub	r12,sp,-8
8000ec76:	18 d2       	st.w	--r12,r2
8000ec78:	c3 6f       	rcall	8000eae4 <__lo0bits>
8000ec7a:	40 18       	lddsp	r8,sp[0x4]
8000ec7c:	c0 d0       	breq	8000ec96 <__d2b+0x4e>
8000ec7e:	40 09       	lddsp	r9,sp[0x0]
8000ec80:	f8 0a 11 20 	rsub	r10,r12,32
8000ec84:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ec88:	f5 e8 10 08 	or	r8,r10,r8
8000ec8c:	89 58       	st.w	r4[0x14],r8
8000ec8e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ec92:	50 09       	stdsp	sp[0x0],r9
8000ec94:	c0 28       	rjmp	8000ec98 <__d2b+0x50>
8000ec96:	89 58       	st.w	r4[0x14],r8
8000ec98:	40 08       	lddsp	r8,sp[0x0]
8000ec9a:	58 08       	cp.w	r8,0
8000ec9c:	f9 b3 01 02 	movne	r3,2
8000eca0:	f9 b3 00 01 	moveq	r3,1
8000eca4:	89 68       	st.w	r4[0x18],r8
8000eca6:	89 43       	st.w	r4[0x10],r3
8000eca8:	c0 88       	rjmp	8000ecb8 <__d2b+0x70>
8000ecaa:	1a 9c       	mov	r12,sp
8000ecac:	c1 cf       	rcall	8000eae4 <__lo0bits>
8000ecae:	30 13       	mov	r3,1
8000ecb0:	40 08       	lddsp	r8,sp[0x0]
8000ecb2:	2e 0c       	sub	r12,-32
8000ecb4:	89 43       	st.w	r4[0x10],r3
8000ecb6:	89 58       	st.w	r4[0x14],r8
8000ecb8:	58 01       	cp.w	r1,0
8000ecba:	c0 90       	breq	8000eccc <__d2b+0x84>
8000ecbc:	e2 c1 04 33 	sub	r1,r1,1075
8000ecc0:	18 01       	add	r1,r12
8000ecc2:	8d 01       	st.w	r6[0x0],r1
8000ecc4:	f8 0c 11 35 	rsub	r12,r12,53
8000ecc8:	8b 0c       	st.w	r5[0x0],r12
8000ecca:	c0 c8       	rjmp	8000ece2 <__d2b+0x9a>
8000eccc:	e6 c8 ff fc 	sub	r8,r3,-4
8000ecd0:	f8 cc 04 32 	sub	r12,r12,1074
8000ecd4:	a5 73       	lsl	r3,0x5
8000ecd6:	8d 0c       	st.w	r6[0x0],r12
8000ecd8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ecdc:	cd 4e       	rcall	8000ea84 <__hi0bits>
8000ecde:	18 13       	sub	r3,r12
8000ece0:	8b 03       	st.w	r5[0x0],r3
8000ece2:	08 9c       	mov	r12,r4
8000ece4:	2f ed       	sub	sp,-8
8000ece6:	d8 32       	popm	r0-r7,pc

8000ece8 <__mdiff>:
8000ece8:	d4 31       	pushm	r0-r7,lr
8000ecea:	74 48       	ld.w	r8,r10[0x10]
8000ecec:	76 45       	ld.w	r5,r11[0x10]
8000ecee:	16 97       	mov	r7,r11
8000ecf0:	14 96       	mov	r6,r10
8000ecf2:	10 15       	sub	r5,r8
8000ecf4:	c1 31       	brne	8000ed1a <__mdiff+0x32>
8000ecf6:	2f b8       	sub	r8,-5
8000ecf8:	ee ce ff ec 	sub	lr,r7,-20
8000ecfc:	a3 68       	lsl	r8,0x2
8000ecfe:	f4 08 00 0b 	add	r11,r10,r8
8000ed02:	ee 08 00 08 	add	r8,r7,r8
8000ed06:	11 4a       	ld.w	r10,--r8
8000ed08:	17 49       	ld.w	r9,--r11
8000ed0a:	12 3a       	cp.w	r10,r9
8000ed0c:	c0 30       	breq	8000ed12 <__mdiff+0x2a>
8000ed0e:	c0 e2       	brcc	8000ed2a <__mdiff+0x42>
8000ed10:	c0 78       	rjmp	8000ed1e <__mdiff+0x36>
8000ed12:	1c 38       	cp.w	r8,lr
8000ed14:	fe 9b ff f9 	brhi	8000ed06 <__mdiff+0x1e>
8000ed18:	c4 98       	rjmp	8000edaa <__mdiff+0xc2>
8000ed1a:	58 05       	cp.w	r5,0
8000ed1c:	c0 64       	brge	8000ed28 <__mdiff+0x40>
8000ed1e:	0e 98       	mov	r8,r7
8000ed20:	30 15       	mov	r5,1
8000ed22:	0c 97       	mov	r7,r6
8000ed24:	10 96       	mov	r6,r8
8000ed26:	c0 28       	rjmp	8000ed2a <__mdiff+0x42>
8000ed28:	30 05       	mov	r5,0
8000ed2a:	6e 1b       	ld.w	r11,r7[0x4]
8000ed2c:	c5 6f       	rcall	8000ebd8 <_Balloc>
8000ed2e:	6e 49       	ld.w	r9,r7[0x10]
8000ed30:	6c 44       	ld.w	r4,r6[0x10]
8000ed32:	99 35       	st.w	r12[0xc],r5
8000ed34:	2f b4       	sub	r4,-5
8000ed36:	f2 c5 ff fb 	sub	r5,r9,-5
8000ed3a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ed3e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000ed42:	2e c6       	sub	r6,-20
8000ed44:	2e c7       	sub	r7,-20
8000ed46:	f8 c8 ff ec 	sub	r8,r12,-20
8000ed4a:	30 0a       	mov	r10,0
8000ed4c:	0f 0e       	ld.w	lr,r7++
8000ed4e:	0d 0b       	ld.w	r11,r6++
8000ed50:	fc 02 16 10 	lsr	r2,lr,0x10
8000ed54:	f6 03 16 10 	lsr	r3,r11,0x10
8000ed58:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ed5c:	e4 03 01 03 	sub	r3,r2,r3
8000ed60:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ed64:	fc 0b 01 0b 	sub	r11,lr,r11
8000ed68:	f6 0a 00 0a 	add	r10,r11,r10
8000ed6c:	b0 1a       	st.h	r8[0x2],r10
8000ed6e:	b1 4a       	asr	r10,0x10
8000ed70:	e6 0a 00 0a 	add	r10,r3,r10
8000ed74:	b0 0a       	st.h	r8[0x0],r10
8000ed76:	2f c8       	sub	r8,-4
8000ed78:	b1 4a       	asr	r10,0x10
8000ed7a:	08 36       	cp.w	r6,r4
8000ed7c:	ce 83       	brcs	8000ed4c <__mdiff+0x64>
8000ed7e:	c0 d8       	rjmp	8000ed98 <__mdiff+0xb0>
8000ed80:	0f 0b       	ld.w	r11,r7++
8000ed82:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ed86:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ed8a:	16 0a       	add	r10,r11
8000ed8c:	b0 1a       	st.h	r8[0x2],r10
8000ed8e:	b1 4a       	asr	r10,0x10
8000ed90:	1c 0a       	add	r10,lr
8000ed92:	b0 0a       	st.h	r8[0x0],r10
8000ed94:	2f c8       	sub	r8,-4
8000ed96:	b1 4a       	asr	r10,0x10
8000ed98:	0a 37       	cp.w	r7,r5
8000ed9a:	cf 33       	brcs	8000ed80 <__mdiff+0x98>
8000ed9c:	c0 28       	rjmp	8000eda0 <__mdiff+0xb8>
8000ed9e:	20 19       	sub	r9,1
8000eda0:	11 4a       	ld.w	r10,--r8
8000eda2:	58 0a       	cp.w	r10,0
8000eda4:	cf d0       	breq	8000ed9e <__mdiff+0xb6>
8000eda6:	99 49       	st.w	r12[0x10],r9
8000eda8:	d8 32       	popm	r0-r7,pc
8000edaa:	30 0b       	mov	r11,0
8000edac:	c1 6f       	rcall	8000ebd8 <_Balloc>
8000edae:	30 18       	mov	r8,1
8000edb0:	99 48       	st.w	r12[0x10],r8
8000edb2:	30 08       	mov	r8,0
8000edb4:	99 58       	st.w	r12[0x14],r8
8000edb6:	d8 32       	popm	r0-r7,pc

8000edb8 <__lshift>:
8000edb8:	d4 31       	pushm	r0-r7,lr
8000edba:	16 97       	mov	r7,r11
8000edbc:	76 46       	ld.w	r6,r11[0x10]
8000edbe:	f4 02 14 05 	asr	r2,r10,0x5
8000edc2:	2f f6       	sub	r6,-1
8000edc4:	14 93       	mov	r3,r10
8000edc6:	18 94       	mov	r4,r12
8000edc8:	04 06       	add	r6,r2
8000edca:	76 1b       	ld.w	r11,r11[0x4]
8000edcc:	6e 28       	ld.w	r8,r7[0x8]
8000edce:	c0 38       	rjmp	8000edd4 <__lshift+0x1c>
8000edd0:	2f fb       	sub	r11,-1
8000edd2:	a1 78       	lsl	r8,0x1
8000edd4:	10 36       	cp.w	r6,r8
8000edd6:	fe 99 ff fd 	brgt	8000edd0 <__lshift+0x18>
8000edda:	08 9c       	mov	r12,r4
8000eddc:	cf ee       	rcall	8000ebd8 <_Balloc>
8000edde:	30 09       	mov	r9,0
8000ede0:	18 95       	mov	r5,r12
8000ede2:	f8 c8 ff ec 	sub	r8,r12,-20
8000ede6:	12 9a       	mov	r10,r9
8000ede8:	c0 38       	rjmp	8000edee <__lshift+0x36>
8000edea:	10 aa       	st.w	r8++,r10
8000edec:	2f f9       	sub	r9,-1
8000edee:	04 39       	cp.w	r9,r2
8000edf0:	cf d5       	brlt	8000edea <__lshift+0x32>
8000edf2:	6e 4b       	ld.w	r11,r7[0x10]
8000edf4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000edf8:	2f bb       	sub	r11,-5
8000edfa:	ee c9 ff ec 	sub	r9,r7,-20
8000edfe:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ee02:	58 03       	cp.w	r3,0
8000ee04:	c1 30       	breq	8000ee2a <__lshift+0x72>
8000ee06:	e6 0c 11 20 	rsub	r12,r3,32
8000ee0a:	30 0a       	mov	r10,0
8000ee0c:	72 02       	ld.w	r2,r9[0x0]
8000ee0e:	e4 03 09 42 	lsl	r2,r2,r3
8000ee12:	04 4a       	or	r10,r2
8000ee14:	10 aa       	st.w	r8++,r10
8000ee16:	13 0a       	ld.w	r10,r9++
8000ee18:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ee1c:	16 39       	cp.w	r9,r11
8000ee1e:	cf 73       	brcs	8000ee0c <__lshift+0x54>
8000ee20:	91 0a       	st.w	r8[0x0],r10
8000ee22:	58 0a       	cp.w	r10,0
8000ee24:	c0 70       	breq	8000ee32 <__lshift+0x7a>
8000ee26:	2f f6       	sub	r6,-1
8000ee28:	c0 58       	rjmp	8000ee32 <__lshift+0x7a>
8000ee2a:	13 0a       	ld.w	r10,r9++
8000ee2c:	10 aa       	st.w	r8++,r10
8000ee2e:	16 39       	cp.w	r9,r11
8000ee30:	cf d3       	brcs	8000ee2a <__lshift+0x72>
8000ee32:	08 9c       	mov	r12,r4
8000ee34:	20 16       	sub	r6,1
8000ee36:	0e 9b       	mov	r11,r7
8000ee38:	8b 46       	st.w	r5[0x10],r6
8000ee3a:	cb 5e       	rcall	8000eba4 <_Bfree>
8000ee3c:	0a 9c       	mov	r12,r5
8000ee3e:	d8 32       	popm	r0-r7,pc

8000ee40 <__multiply>:
8000ee40:	d4 31       	pushm	r0-r7,lr
8000ee42:	20 2d       	sub	sp,8
8000ee44:	76 49       	ld.w	r9,r11[0x10]
8000ee46:	74 48       	ld.w	r8,r10[0x10]
8000ee48:	16 96       	mov	r6,r11
8000ee4a:	14 95       	mov	r5,r10
8000ee4c:	10 39       	cp.w	r9,r8
8000ee4e:	ec 08 17 50 	movlt	r8,r6
8000ee52:	ea 06 17 50 	movlt	r6,r5
8000ee56:	f0 05 17 50 	movlt	r5,r8
8000ee5a:	6c 28       	ld.w	r8,r6[0x8]
8000ee5c:	76 43       	ld.w	r3,r11[0x10]
8000ee5e:	74 42       	ld.w	r2,r10[0x10]
8000ee60:	76 1b       	ld.w	r11,r11[0x4]
8000ee62:	e4 03 00 07 	add	r7,r2,r3
8000ee66:	10 37       	cp.w	r7,r8
8000ee68:	f7 bb 09 ff 	subgt	r11,-1
8000ee6c:	cb 6e       	rcall	8000ebd8 <_Balloc>
8000ee6e:	ee c4 ff fb 	sub	r4,r7,-5
8000ee72:	f8 c9 ff ec 	sub	r9,r12,-20
8000ee76:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ee7a:	30 0a       	mov	r10,0
8000ee7c:	12 98       	mov	r8,r9
8000ee7e:	c0 28       	rjmp	8000ee82 <__multiply+0x42>
8000ee80:	10 aa       	st.w	r8++,r10
8000ee82:	08 38       	cp.w	r8,r4
8000ee84:	cf e3       	brcs	8000ee80 <__multiply+0x40>
8000ee86:	2f b3       	sub	r3,-5
8000ee88:	2f b2       	sub	r2,-5
8000ee8a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ee8e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ee92:	ec cb ff ec 	sub	r11,r6,-20
8000ee96:	50 12       	stdsp	sp[0x4],r2
8000ee98:	ea ca ff ec 	sub	r10,r5,-20
8000ee9c:	c4 48       	rjmp	8000ef24 <__multiply+0xe4>
8000ee9e:	94 95       	ld.uh	r5,r10[0x2]
8000eea0:	58 05       	cp.w	r5,0
8000eea2:	c2 00       	breq	8000eee2 <__multiply+0xa2>
8000eea4:	12 98       	mov	r8,r9
8000eea6:	16 96       	mov	r6,r11
8000eea8:	30 0e       	mov	lr,0
8000eeaa:	50 09       	stdsp	sp[0x0],r9
8000eeac:	0d 02       	ld.w	r2,r6++
8000eeae:	e4 00 16 10 	lsr	r0,r2,0x10
8000eeb2:	70 01       	ld.w	r1,r8[0x0]
8000eeb4:	70 09       	ld.w	r9,r8[0x0]
8000eeb6:	b1 81       	lsr	r1,0x10
8000eeb8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000eebc:	e0 05 03 41 	mac	r1,r0,r5
8000eec0:	ab 32       	mul	r2,r5
8000eec2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000eec6:	00 02       	add	r2,r0
8000eec8:	e4 0e 00 0e 	add	lr,r2,lr
8000eecc:	b0 1e       	st.h	r8[0x2],lr
8000eece:	b1 8e       	lsr	lr,0x10
8000eed0:	1c 01       	add	r1,lr
8000eed2:	b0 01       	st.h	r8[0x0],r1
8000eed4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000eed8:	2f c8       	sub	r8,-4
8000eeda:	06 36       	cp.w	r6,r3
8000eedc:	ce 83       	brcs	8000eeac <__multiply+0x6c>
8000eede:	40 09       	lddsp	r9,sp[0x0]
8000eee0:	91 0e       	st.w	r8[0x0],lr
8000eee2:	94 86       	ld.uh	r6,r10[0x0]
8000eee4:	58 06       	cp.w	r6,0
8000eee6:	c1 d0       	breq	8000ef20 <__multiply+0xe0>
8000eee8:	72 02       	ld.w	r2,r9[0x0]
8000eeea:	12 98       	mov	r8,r9
8000eeec:	16 9e       	mov	lr,r11
8000eeee:	30 05       	mov	r5,0
8000eef0:	b0 12       	st.h	r8[0x2],r2
8000eef2:	1d 01       	ld.w	r1,lr++
8000eef4:	90 82       	ld.uh	r2,r8[0x0]
8000eef6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000eefa:	ad 30       	mul	r0,r6
8000eefc:	e0 02 00 02 	add	r2,r0,r2
8000ef00:	e4 05 00 05 	add	r5,r2,r5
8000ef04:	b0 05       	st.h	r8[0x0],r5
8000ef06:	b1 85       	lsr	r5,0x10
8000ef08:	b1 81       	lsr	r1,0x10
8000ef0a:	2f c8       	sub	r8,-4
8000ef0c:	ad 31       	mul	r1,r6
8000ef0e:	90 92       	ld.uh	r2,r8[0x2]
8000ef10:	e2 02 00 02 	add	r2,r1,r2
8000ef14:	0a 02       	add	r2,r5
8000ef16:	e4 05 16 10 	lsr	r5,r2,0x10
8000ef1a:	06 3e       	cp.w	lr,r3
8000ef1c:	ce a3       	brcs	8000eef0 <__multiply+0xb0>
8000ef1e:	91 02       	st.w	r8[0x0],r2
8000ef20:	2f ca       	sub	r10,-4
8000ef22:	2f c9       	sub	r9,-4
8000ef24:	40 18       	lddsp	r8,sp[0x4]
8000ef26:	10 3a       	cp.w	r10,r8
8000ef28:	cb b3       	brcs	8000ee9e <__multiply+0x5e>
8000ef2a:	c0 28       	rjmp	8000ef2e <__multiply+0xee>
8000ef2c:	20 17       	sub	r7,1
8000ef2e:	58 07       	cp.w	r7,0
8000ef30:	e0 8a 00 05 	brle	8000ef3a <__multiply+0xfa>
8000ef34:	09 48       	ld.w	r8,--r4
8000ef36:	58 08       	cp.w	r8,0
8000ef38:	cf a0       	breq	8000ef2c <__multiply+0xec>
8000ef3a:	99 47       	st.w	r12[0x10],r7
8000ef3c:	2f ed       	sub	sp,-8
8000ef3e:	d8 32       	popm	r0-r7,pc

8000ef40 <__i2b>:
8000ef40:	d4 21       	pushm	r4-r7,lr
8000ef42:	16 97       	mov	r7,r11
8000ef44:	30 1b       	mov	r11,1
8000ef46:	c4 9e       	rcall	8000ebd8 <_Balloc>
8000ef48:	30 19       	mov	r9,1
8000ef4a:	99 57       	st.w	r12[0x14],r7
8000ef4c:	99 49       	st.w	r12[0x10],r9
8000ef4e:	d8 22       	popm	r4-r7,pc

8000ef50 <__multadd>:
8000ef50:	d4 31       	pushm	r0-r7,lr
8000ef52:	30 08       	mov	r8,0
8000ef54:	12 95       	mov	r5,r9
8000ef56:	16 97       	mov	r7,r11
8000ef58:	18 96       	mov	r6,r12
8000ef5a:	76 44       	ld.w	r4,r11[0x10]
8000ef5c:	f6 c9 ff ec 	sub	r9,r11,-20
8000ef60:	72 0b       	ld.w	r11,r9[0x0]
8000ef62:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ef66:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ef6a:	f4 0c 02 4c 	mul	r12,r10,r12
8000ef6e:	f4 0b 03 45 	mac	r5,r10,r11
8000ef72:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ef76:	b1 85       	lsr	r5,0x10
8000ef78:	18 05       	add	r5,r12
8000ef7a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ef7e:	f8 0b 00 0b 	add	r11,r12,r11
8000ef82:	12 ab       	st.w	r9++,r11
8000ef84:	2f f8       	sub	r8,-1
8000ef86:	b1 85       	lsr	r5,0x10
8000ef88:	08 38       	cp.w	r8,r4
8000ef8a:	ce b5       	brlt	8000ef60 <__multadd+0x10>
8000ef8c:	58 05       	cp.w	r5,0
8000ef8e:	c1 c0       	breq	8000efc6 <__multadd+0x76>
8000ef90:	6e 28       	ld.w	r8,r7[0x8]
8000ef92:	10 34       	cp.w	r4,r8
8000ef94:	c1 35       	brlt	8000efba <__multadd+0x6a>
8000ef96:	6e 1b       	ld.w	r11,r7[0x4]
8000ef98:	0c 9c       	mov	r12,r6
8000ef9a:	2f fb       	sub	r11,-1
8000ef9c:	c1 ee       	rcall	8000ebd8 <_Balloc>
8000ef9e:	6e 4a       	ld.w	r10,r7[0x10]
8000efa0:	ee cb ff f4 	sub	r11,r7,-12
8000efa4:	18 93       	mov	r3,r12
8000efa6:	2f ea       	sub	r10,-2
8000efa8:	2f 4c       	sub	r12,-12
8000efaa:	a3 6a       	lsl	r10,0x2
8000efac:	fe b0 de 65 	rcall	8000ac76 <memcpy>
8000efb0:	0e 9b       	mov	r11,r7
8000efb2:	0c 9c       	mov	r12,r6
8000efb4:	fe b0 fd f8 	rcall	8000eba4 <_Bfree>
8000efb8:	06 97       	mov	r7,r3
8000efba:	e8 c8 ff ff 	sub	r8,r4,-1
8000efbe:	2f b4       	sub	r4,-5
8000efc0:	8f 48       	st.w	r7[0x10],r8
8000efc2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000efc6:	0e 9c       	mov	r12,r7
8000efc8:	d8 32       	popm	r0-r7,pc
8000efca:	d7 03       	nop

8000efcc <__pow5mult>:
8000efcc:	d4 31       	pushm	r0-r7,lr
8000efce:	14 96       	mov	r6,r10
8000efd0:	18 97       	mov	r7,r12
8000efd2:	16 94       	mov	r4,r11
8000efd4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000efd8:	c0 90       	breq	8000efea <__pow5mult+0x1e>
8000efda:	20 18       	sub	r8,1
8000efdc:	fe c9 e3 3c 	sub	r9,pc,-7364
8000efe0:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000efe4:	30 09       	mov	r9,0
8000efe6:	cb 5f       	rcall	8000ef50 <__multadd>
8000efe8:	18 94       	mov	r4,r12
8000efea:	a3 46       	asr	r6,0x2
8000efec:	c3 40       	breq	8000f054 <__pow5mult+0x88>
8000efee:	6e 95       	ld.w	r5,r7[0x24]
8000eff0:	58 05       	cp.w	r5,0
8000eff2:	c0 91       	brne	8000f004 <__pow5mult+0x38>
8000eff4:	31 0c       	mov	r12,16
8000eff6:	fe b0 dc 09 	rcall	8000a808 <malloc>
8000effa:	99 35       	st.w	r12[0xc],r5
8000effc:	8f 9c       	st.w	r7[0x24],r12
8000effe:	99 15       	st.w	r12[0x4],r5
8000f000:	99 25       	st.w	r12[0x8],r5
8000f002:	99 05       	st.w	r12[0x0],r5
8000f004:	6e 93       	ld.w	r3,r7[0x24]
8000f006:	66 25       	ld.w	r5,r3[0x8]
8000f008:	58 05       	cp.w	r5,0
8000f00a:	c0 c1       	brne	8000f022 <__pow5mult+0x56>
8000f00c:	e0 6b 02 71 	mov	r11,625
8000f010:	0e 9c       	mov	r12,r7
8000f012:	c9 7f       	rcall	8000ef40 <__i2b>
8000f014:	87 2c       	st.w	r3[0x8],r12
8000f016:	30 08       	mov	r8,0
8000f018:	18 95       	mov	r5,r12
8000f01a:	99 08       	st.w	r12[0x0],r8
8000f01c:	c0 38       	rjmp	8000f022 <__pow5mult+0x56>
8000f01e:	06 9c       	mov	r12,r3
8000f020:	18 95       	mov	r5,r12
8000f022:	ed b6 00 00 	bld	r6,0x0
8000f026:	c0 b1       	brne	8000f03c <__pow5mult+0x70>
8000f028:	08 9b       	mov	r11,r4
8000f02a:	0a 9a       	mov	r10,r5
8000f02c:	0e 9c       	mov	r12,r7
8000f02e:	c0 9f       	rcall	8000ee40 <__multiply>
8000f030:	08 9b       	mov	r11,r4
8000f032:	18 93       	mov	r3,r12
8000f034:	0e 9c       	mov	r12,r7
8000f036:	06 94       	mov	r4,r3
8000f038:	fe b0 fd b6 	rcall	8000eba4 <_Bfree>
8000f03c:	a1 56       	asr	r6,0x1
8000f03e:	c0 b0       	breq	8000f054 <__pow5mult+0x88>
8000f040:	6a 03       	ld.w	r3,r5[0x0]
8000f042:	58 03       	cp.w	r3,0
8000f044:	ce d1       	brne	8000f01e <__pow5mult+0x52>
8000f046:	0a 9a       	mov	r10,r5
8000f048:	0a 9b       	mov	r11,r5
8000f04a:	0e 9c       	mov	r12,r7
8000f04c:	cf ae       	rcall	8000ee40 <__multiply>
8000f04e:	8b 0c       	st.w	r5[0x0],r12
8000f050:	99 03       	st.w	r12[0x0],r3
8000f052:	ce 7b       	rjmp	8000f020 <__pow5mult+0x54>
8000f054:	08 9c       	mov	r12,r4
8000f056:	d8 32       	popm	r0-r7,pc

8000f058 <__isinfd>:
8000f058:	14 98       	mov	r8,r10
8000f05a:	fc 19 7f f0 	movh	r9,0x7ff0
8000f05e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f062:	f0 0b 11 00 	rsub	r11,r8,0
8000f066:	f7 e8 10 08 	or	r8,r11,r8
8000f06a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000f06e:	f2 08 01 08 	sub	r8,r9,r8
8000f072:	f0 0c 11 00 	rsub	r12,r8,0
8000f076:	f9 e8 10 08 	or	r8,r12,r8
8000f07a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000f07e:	2f fc       	sub	r12,-1
8000f080:	5e fc       	retal	r12

8000f082 <__isnand>:
8000f082:	14 98       	mov	r8,r10
8000f084:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f088:	f0 0c 11 00 	rsub	r12,r8,0
8000f08c:	10 4c       	or	r12,r8
8000f08e:	fc 18 7f f0 	movh	r8,0x7ff0
8000f092:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000f096:	f0 0c 01 0c 	sub	r12,r8,r12
8000f09a:	bf 9c       	lsr	r12,0x1f
8000f09c:	5e fc       	retal	r12
8000f09e:	d7 03       	nop

8000f0a0 <__sclose>:
8000f0a0:	d4 01       	pushm	lr
8000f0a2:	96 7b       	ld.sh	r11,r11[0xe]
8000f0a4:	c7 6c       	rcall	8000f190 <_close_r>
8000f0a6:	d8 02       	popm	pc

8000f0a8 <__sseek>:
8000f0a8:	d4 21       	pushm	r4-r7,lr
8000f0aa:	16 97       	mov	r7,r11
8000f0ac:	96 7b       	ld.sh	r11,r11[0xe]
8000f0ae:	cf 7c       	rcall	8000f29c <_lseek_r>
8000f0b0:	8e 68       	ld.sh	r8,r7[0xc]
8000f0b2:	10 99       	mov	r9,r8
8000f0b4:	ad c8       	cbr	r8,0xc
8000f0b6:	ad a9       	sbr	r9,0xc
8000f0b8:	5b fc       	cp.w	r12,-1
8000f0ba:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000f0be:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000f0c2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000f0c6:	d8 22       	popm	r4-r7,pc

8000f0c8 <__swrite>:
8000f0c8:	d4 21       	pushm	r4-r7,lr
8000f0ca:	96 68       	ld.sh	r8,r11[0xc]
8000f0cc:	16 97       	mov	r7,r11
8000f0ce:	14 95       	mov	r5,r10
8000f0d0:	12 94       	mov	r4,r9
8000f0d2:	e2 18 01 00 	andl	r8,0x100,COH
8000f0d6:	18 96       	mov	r6,r12
8000f0d8:	c0 50       	breq	8000f0e2 <__swrite+0x1a>
8000f0da:	30 29       	mov	r9,2
8000f0dc:	30 0a       	mov	r10,0
8000f0de:	96 7b       	ld.sh	r11,r11[0xe]
8000f0e0:	cd ec       	rcall	8000f29c <_lseek_r>
8000f0e2:	8e 68       	ld.sh	r8,r7[0xc]
8000f0e4:	ad c8       	cbr	r8,0xc
8000f0e6:	08 99       	mov	r9,r4
8000f0e8:	0a 9a       	mov	r10,r5
8000f0ea:	8e 7b       	ld.sh	r11,r7[0xe]
8000f0ec:	0c 9c       	mov	r12,r6
8000f0ee:	ae 68       	st.h	r7[0xc],r8
8000f0f0:	c1 0c       	rcall	8000f110 <_write_r>
8000f0f2:	d8 22       	popm	r4-r7,pc

8000f0f4 <__sread>:
8000f0f4:	d4 21       	pushm	r4-r7,lr
8000f0f6:	16 97       	mov	r7,r11
8000f0f8:	96 7b       	ld.sh	r11,r11[0xe]
8000f0fa:	ce 5c       	rcall	8000f2c4 <_read_r>
8000f0fc:	c0 65       	brlt	8000f108 <__sread+0x14>
8000f0fe:	6f 58       	ld.w	r8,r7[0x54]
8000f100:	18 08       	add	r8,r12
8000f102:	ef 48 00 54 	st.w	r7[84],r8
8000f106:	d8 22       	popm	r4-r7,pc
8000f108:	8e 68       	ld.sh	r8,r7[0xc]
8000f10a:	ad c8       	cbr	r8,0xc
8000f10c:	ae 68       	st.h	r7[0xc],r8
8000f10e:	d8 22       	popm	r4-r7,pc

8000f110 <_write_r>:
8000f110:	d4 21       	pushm	r4-r7,lr
8000f112:	16 98       	mov	r8,r11
8000f114:	18 97       	mov	r7,r12
8000f116:	10 9c       	mov	r12,r8
8000f118:	30 08       	mov	r8,0
8000f11a:	14 9b       	mov	r11,r10
8000f11c:	e0 66 41 14 	mov	r6,16660
8000f120:	12 9a       	mov	r10,r9
8000f122:	8d 08       	st.w	r6[0x0],r8
8000f124:	fe b0 c9 8c 	rcall	8000843c <_write>
8000f128:	5b fc       	cp.w	r12,-1
8000f12a:	c0 51       	brne	8000f134 <_write_r+0x24>
8000f12c:	6c 08       	ld.w	r8,r6[0x0]
8000f12e:	58 08       	cp.w	r8,0
8000f130:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f134:	d8 22       	popm	r4-r7,pc
8000f136:	d7 03       	nop

8000f138 <_calloc_r>:
8000f138:	d4 21       	pushm	r4-r7,lr
8000f13a:	f4 0b 02 4b 	mul	r11,r10,r11
8000f13e:	fe b0 db 6d 	rcall	8000a818 <_malloc_r>
8000f142:	18 97       	mov	r7,r12
8000f144:	c2 30       	breq	8000f18a <_calloc_r+0x52>
8000f146:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000f14a:	e0 1a ff fc 	andl	r10,0xfffc
8000f14e:	20 4a       	sub	r10,4
8000f150:	e0 4a 00 24 	cp.w	r10,36
8000f154:	e0 8b 00 18 	brhi	8000f184 <_calloc_r+0x4c>
8000f158:	18 98       	mov	r8,r12
8000f15a:	59 3a       	cp.w	r10,19
8000f15c:	e0 88 00 0f 	brls	8000f17a <_calloc_r+0x42>
8000f160:	30 09       	mov	r9,0
8000f162:	10 a9       	st.w	r8++,r9
8000f164:	10 a9       	st.w	r8++,r9
8000f166:	59 ba       	cp.w	r10,27
8000f168:	e0 88 00 09 	brls	8000f17a <_calloc_r+0x42>
8000f16c:	10 a9       	st.w	r8++,r9
8000f16e:	10 a9       	st.w	r8++,r9
8000f170:	e0 4a 00 24 	cp.w	r10,36
8000f174:	c0 31       	brne	8000f17a <_calloc_r+0x42>
8000f176:	10 a9       	st.w	r8++,r9
8000f178:	10 a9       	st.w	r8++,r9
8000f17a:	30 09       	mov	r9,0
8000f17c:	10 a9       	st.w	r8++,r9
8000f17e:	91 19       	st.w	r8[0x4],r9
8000f180:	91 09       	st.w	r8[0x0],r9
8000f182:	c0 48       	rjmp	8000f18a <_calloc_r+0x52>
8000f184:	30 0b       	mov	r11,0
8000f186:	fe b0 de 1c 	rcall	8000adbe <memset>
8000f18a:	0e 9c       	mov	r12,r7
8000f18c:	d8 22       	popm	r4-r7,pc
8000f18e:	d7 03       	nop

8000f190 <_close_r>:
8000f190:	d4 21       	pushm	r4-r7,lr
8000f192:	30 08       	mov	r8,0
8000f194:	18 97       	mov	r7,r12
8000f196:	e0 66 41 14 	mov	r6,16660
8000f19a:	16 9c       	mov	r12,r11
8000f19c:	8d 08       	st.w	r6[0x0],r8
8000f19e:	fe b0 df c1 	rcall	8000b120 <_close>
8000f1a2:	5b fc       	cp.w	r12,-1
8000f1a4:	c0 51       	brne	8000f1ae <_close_r+0x1e>
8000f1a6:	6c 08       	ld.w	r8,r6[0x0]
8000f1a8:	58 08       	cp.w	r8,0
8000f1aa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f1ae:	d8 22       	popm	r4-r7,pc

8000f1b0 <_fclose_r>:
8000f1b0:	d4 21       	pushm	r4-r7,lr
8000f1b2:	18 96       	mov	r6,r12
8000f1b4:	16 97       	mov	r7,r11
8000f1b6:	58 0b       	cp.w	r11,0
8000f1b8:	c0 31       	brne	8000f1be <_fclose_r+0xe>
8000f1ba:	16 95       	mov	r5,r11
8000f1bc:	c5 38       	rjmp	8000f262 <_fclose_r+0xb2>
8000f1be:	fe b0 f8 b5 	rcall	8000e328 <__sfp_lock_acquire>
8000f1c2:	58 06       	cp.w	r6,0
8000f1c4:	c0 70       	breq	8000f1d2 <_fclose_r+0x22>
8000f1c6:	6c 68       	ld.w	r8,r6[0x18]
8000f1c8:	58 08       	cp.w	r8,0
8000f1ca:	c0 41       	brne	8000f1d2 <_fclose_r+0x22>
8000f1cc:	0c 9c       	mov	r12,r6
8000f1ce:	fe b0 f8 ff 	rcall	8000e3cc <__sinit>
8000f1d2:	fe c8 e5 da 	sub	r8,pc,-6694
8000f1d6:	10 37       	cp.w	r7,r8
8000f1d8:	c0 31       	brne	8000f1de <_fclose_r+0x2e>
8000f1da:	6c 07       	ld.w	r7,r6[0x0]
8000f1dc:	c0 c8       	rjmp	8000f1f4 <_fclose_r+0x44>
8000f1de:	fe c8 e5 c6 	sub	r8,pc,-6714
8000f1e2:	10 37       	cp.w	r7,r8
8000f1e4:	c0 31       	brne	8000f1ea <_fclose_r+0x3a>
8000f1e6:	6c 17       	ld.w	r7,r6[0x4]
8000f1e8:	c0 68       	rjmp	8000f1f4 <_fclose_r+0x44>
8000f1ea:	fe c8 e5 b2 	sub	r8,pc,-6734
8000f1ee:	10 37       	cp.w	r7,r8
8000f1f0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000f1f4:	8e 69       	ld.sh	r9,r7[0xc]
8000f1f6:	30 08       	mov	r8,0
8000f1f8:	f0 09 19 00 	cp.h	r9,r8
8000f1fc:	c0 51       	brne	8000f206 <_fclose_r+0x56>
8000f1fe:	fe b0 f8 96 	rcall	8000e32a <__sfp_lock_release>
8000f202:	30 05       	mov	r5,0
8000f204:	c2 f8       	rjmp	8000f262 <_fclose_r+0xb2>
8000f206:	0e 9b       	mov	r11,r7
8000f208:	0c 9c       	mov	r12,r6
8000f20a:	fe b0 f8 09 	rcall	8000e21c <_fflush_r>
8000f20e:	6e c8       	ld.w	r8,r7[0x30]
8000f210:	18 95       	mov	r5,r12
8000f212:	58 08       	cp.w	r8,0
8000f214:	c0 60       	breq	8000f220 <_fclose_r+0x70>
8000f216:	6e 8b       	ld.w	r11,r7[0x20]
8000f218:	0c 9c       	mov	r12,r6
8000f21a:	5d 18       	icall	r8
8000f21c:	f9 b5 05 ff 	movlt	r5,-1
8000f220:	8e 68       	ld.sh	r8,r7[0xc]
8000f222:	ed b8 00 07 	bld	r8,0x7
8000f226:	c0 51       	brne	8000f230 <_fclose_r+0x80>
8000f228:	6e 4b       	ld.w	r11,r7[0x10]
8000f22a:	0c 9c       	mov	r12,r6
8000f22c:	fe b0 f9 6a 	rcall	8000e500 <_free_r>
8000f230:	6e db       	ld.w	r11,r7[0x34]
8000f232:	58 0b       	cp.w	r11,0
8000f234:	c0 a0       	breq	8000f248 <_fclose_r+0x98>
8000f236:	ee c8 ff bc 	sub	r8,r7,-68
8000f23a:	10 3b       	cp.w	r11,r8
8000f23c:	c0 40       	breq	8000f244 <_fclose_r+0x94>
8000f23e:	0c 9c       	mov	r12,r6
8000f240:	fe b0 f9 60 	rcall	8000e500 <_free_r>
8000f244:	30 08       	mov	r8,0
8000f246:	8f d8       	st.w	r7[0x34],r8
8000f248:	6f 2b       	ld.w	r11,r7[0x48]
8000f24a:	58 0b       	cp.w	r11,0
8000f24c:	c0 70       	breq	8000f25a <_fclose_r+0xaa>
8000f24e:	0c 9c       	mov	r12,r6
8000f250:	fe b0 f9 58 	rcall	8000e500 <_free_r>
8000f254:	30 08       	mov	r8,0
8000f256:	ef 48 00 48 	st.w	r7[72],r8
8000f25a:	30 08       	mov	r8,0
8000f25c:	ae 68       	st.h	r7[0xc],r8
8000f25e:	fe b0 f8 66 	rcall	8000e32a <__sfp_lock_release>
8000f262:	0a 9c       	mov	r12,r5
8000f264:	d8 22       	popm	r4-r7,pc
8000f266:	d7 03       	nop

8000f268 <fclose>:
8000f268:	d4 01       	pushm	lr
8000f26a:	e0 68 0a 4c 	mov	r8,2636
8000f26e:	18 9b       	mov	r11,r12
8000f270:	70 0c       	ld.w	r12,r8[0x0]
8000f272:	c9 ff       	rcall	8000f1b0 <_fclose_r>
8000f274:	d8 02       	popm	pc
8000f276:	d7 03       	nop

8000f278 <_fstat_r>:
8000f278:	d4 21       	pushm	r4-r7,lr
8000f27a:	16 98       	mov	r8,r11
8000f27c:	18 97       	mov	r7,r12
8000f27e:	10 9c       	mov	r12,r8
8000f280:	30 08       	mov	r8,0
8000f282:	e0 66 41 14 	mov	r6,16660
8000f286:	14 9b       	mov	r11,r10
8000f288:	8d 08       	st.w	r6[0x0],r8
8000f28a:	fe b0 df 73 	rcall	8000b170 <_fstat>
8000f28e:	5b fc       	cp.w	r12,-1
8000f290:	c0 51       	brne	8000f29a <_fstat_r+0x22>
8000f292:	6c 08       	ld.w	r8,r6[0x0]
8000f294:	58 08       	cp.w	r8,0
8000f296:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f29a:	d8 22       	popm	r4-r7,pc

8000f29c <_lseek_r>:
8000f29c:	d4 21       	pushm	r4-r7,lr
8000f29e:	16 98       	mov	r8,r11
8000f2a0:	18 97       	mov	r7,r12
8000f2a2:	10 9c       	mov	r12,r8
8000f2a4:	30 08       	mov	r8,0
8000f2a6:	14 9b       	mov	r11,r10
8000f2a8:	e0 66 41 14 	mov	r6,16660
8000f2ac:	12 9a       	mov	r10,r9
8000f2ae:	8d 08       	st.w	r6[0x0],r8
8000f2b0:	fe b0 df 42 	rcall	8000b134 <_lseek>
8000f2b4:	5b fc       	cp.w	r12,-1
8000f2b6:	c0 51       	brne	8000f2c0 <_lseek_r+0x24>
8000f2b8:	6c 08       	ld.w	r8,r6[0x0]
8000f2ba:	58 08       	cp.w	r8,0
8000f2bc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f2c0:	d8 22       	popm	r4-r7,pc
8000f2c2:	d7 03       	nop

8000f2c4 <_read_r>:
8000f2c4:	d4 21       	pushm	r4-r7,lr
8000f2c6:	16 98       	mov	r8,r11
8000f2c8:	18 97       	mov	r7,r12
8000f2ca:	10 9c       	mov	r12,r8
8000f2cc:	30 08       	mov	r8,0
8000f2ce:	14 9b       	mov	r11,r10
8000f2d0:	e0 66 41 14 	mov	r6,16660
8000f2d4:	12 9a       	mov	r10,r9
8000f2d6:	8d 08       	st.w	r6[0x0],r8
8000f2d8:	fe b0 c8 6c 	rcall	800083b0 <_read>
8000f2dc:	5b fc       	cp.w	r12,-1
8000f2de:	c0 51       	brne	8000f2e8 <_read_r+0x24>
8000f2e0:	6c 08       	ld.w	r8,r6[0x0]
8000f2e2:	58 08       	cp.w	r8,0
8000f2e4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f2e8:	d8 22       	popm	r4-r7,pc
8000f2ea:	d7 03       	nop

8000f2ec <__avr32_f64_mul>:
8000f2ec:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f2f0:	e0 80 00 dc 	breq	8000f4a8 <__avr32_f64_mul_op1_zero>
8000f2f4:	d4 21       	pushm	r4-r7,lr
8000f2f6:	f7 e9 20 0e 	eor	lr,r11,r9
8000f2fa:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f2fe:	30 15       	mov	r5,1
8000f300:	c4 30       	breq	8000f386 <__avr32_f64_mul_op1_subnormal>
8000f302:	ab 6b       	lsl	r11,0xa
8000f304:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f308:	ab 6a       	lsl	r10,0xa
8000f30a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f30e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f312:	c5 c0       	breq	8000f3ca <__avr32_f64_mul_op2_subnormal>
8000f314:	a1 78       	lsl	r8,0x1
8000f316:	5c f9       	rol	r9
8000f318:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f31c:	e0 47 07 ff 	cp.w	r7,2047
8000f320:	c7 70       	breq	8000f40e <__avr32_f64_mul_op_nan_or_inf>
8000f322:	e0 46 07 ff 	cp.w	r6,2047
8000f326:	c7 40       	breq	8000f40e <__avr32_f64_mul_op_nan_or_inf>
8000f328:	ee 06 00 0c 	add	r12,r7,r6
8000f32c:	e0 2c 03 fe 	sub	r12,1022
8000f330:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f334:	f4 09 07 44 	macu.d	r4,r10,r9
8000f338:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f33c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f340:	08 07       	add	r7,r4
8000f342:	f4 05 00 4a 	adc	r10,r10,r5
8000f346:	5c 0b       	acr	r11
8000f348:	ed bb 00 14 	bld	r11,0x14
8000f34c:	c0 50       	breq	8000f356 <__avr32_f64_mul+0x6a>
8000f34e:	a1 77       	lsl	r7,0x1
8000f350:	5c fa       	rol	r10
8000f352:	5c fb       	rol	r11
8000f354:	20 1c       	sub	r12,1
8000f356:	58 0c       	cp.w	r12,0
8000f358:	e0 8a 00 6f 	brle	8000f436 <__avr32_f64_mul_res_subnormal>
8000f35c:	e0 4c 07 ff 	cp.w	r12,2047
8000f360:	e0 84 00 9c 	brge	8000f498 <__avr32_f64_mul_res_inf>
8000f364:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f368:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f36c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f370:	ee 17 80 00 	eorh	r7,0x8000
8000f374:	f1 b7 04 20 	satu	r7,0x1
8000f378:	0e 0a       	add	r10,r7
8000f37a:	5c 0b       	acr	r11
8000f37c:	ed be 00 1f 	bld	lr,0x1f
8000f380:	ef bb 00 1f 	bst	r11,0x1f
8000f384:	d8 22       	popm	r4-r7,pc

8000f386 <__avr32_f64_mul_op1_subnormal>:
8000f386:	e4 1b 00 0f 	andh	r11,0xf
8000f38a:	f4 0c 12 00 	clz	r12,r10
8000f38e:	f6 06 12 00 	clz	r6,r11
8000f392:	f7 bc 03 e1 	sublo	r12,-31
8000f396:	f8 06 17 30 	movlo	r6,r12
8000f39a:	f7 b6 02 01 	subhs	r6,1
8000f39e:	e0 46 00 20 	cp.w	r6,32
8000f3a2:	c0 d4       	brge	8000f3bc <__avr32_f64_mul_op1_subnormal+0x36>
8000f3a4:	ec 0c 11 20 	rsub	r12,r6,32
8000f3a8:	f6 06 09 4b 	lsl	r11,r11,r6
8000f3ac:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f3b0:	18 4b       	or	r11,r12
8000f3b2:	f4 06 09 4a 	lsl	r10,r10,r6
8000f3b6:	20 b6       	sub	r6,11
8000f3b8:	0c 17       	sub	r7,r6
8000f3ba:	ca ab       	rjmp	8000f30e <__avr32_f64_mul+0x22>
8000f3bc:	f4 06 09 4b 	lsl	r11,r10,r6
8000f3c0:	c6 40       	breq	8000f488 <__avr32_f64_mul_res_zero>
8000f3c2:	30 0a       	mov	r10,0
8000f3c4:	20 b6       	sub	r6,11
8000f3c6:	0c 17       	sub	r7,r6
8000f3c8:	ca 3b       	rjmp	8000f30e <__avr32_f64_mul+0x22>

8000f3ca <__avr32_f64_mul_op2_subnormal>:
8000f3ca:	e4 19 00 0f 	andh	r9,0xf
8000f3ce:	f0 0c 12 00 	clz	r12,r8
8000f3d2:	f2 05 12 00 	clz	r5,r9
8000f3d6:	f7 bc 03 ea 	sublo	r12,-22
8000f3da:	f8 05 17 30 	movlo	r5,r12
8000f3de:	f7 b5 02 0a 	subhs	r5,10
8000f3e2:	e0 45 00 20 	cp.w	r5,32
8000f3e6:	c0 d4       	brge	8000f400 <__avr32_f64_mul_op2_subnormal+0x36>
8000f3e8:	ea 0c 11 20 	rsub	r12,r5,32
8000f3ec:	f2 05 09 49 	lsl	r9,r9,r5
8000f3f0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f3f4:	18 49       	or	r9,r12
8000f3f6:	f0 05 09 48 	lsl	r8,r8,r5
8000f3fa:	20 25       	sub	r5,2
8000f3fc:	0a 16       	sub	r6,r5
8000f3fe:	c8 fb       	rjmp	8000f31c <__avr32_f64_mul+0x30>
8000f400:	f0 05 09 49 	lsl	r9,r8,r5
8000f404:	c4 20       	breq	8000f488 <__avr32_f64_mul_res_zero>
8000f406:	30 08       	mov	r8,0
8000f408:	20 25       	sub	r5,2
8000f40a:	0a 16       	sub	r6,r5
8000f40c:	c8 8b       	rjmp	8000f31c <__avr32_f64_mul+0x30>

8000f40e <__avr32_f64_mul_op_nan_or_inf>:
8000f40e:	e4 19 00 0f 	andh	r9,0xf
8000f412:	e4 1b 00 0f 	andh	r11,0xf
8000f416:	14 4b       	or	r11,r10
8000f418:	10 49       	or	r9,r8
8000f41a:	e0 47 07 ff 	cp.w	r7,2047
8000f41e:	c0 91       	brne	8000f430 <__avr32_f64_mul_op1_not_naninf>
8000f420:	58 0b       	cp.w	r11,0
8000f422:	c3 81       	brne	8000f492 <__avr32_f64_mul_res_nan>
8000f424:	e0 46 07 ff 	cp.w	r6,2047
8000f428:	c3 81       	brne	8000f498 <__avr32_f64_mul_res_inf>
8000f42a:	58 09       	cp.w	r9,0
8000f42c:	c3 60       	breq	8000f498 <__avr32_f64_mul_res_inf>
8000f42e:	c3 28       	rjmp	8000f492 <__avr32_f64_mul_res_nan>

8000f430 <__avr32_f64_mul_op1_not_naninf>:
8000f430:	58 09       	cp.w	r9,0
8000f432:	c3 30       	breq	8000f498 <__avr32_f64_mul_res_inf>
8000f434:	c2 f8       	rjmp	8000f492 <__avr32_f64_mul_res_nan>

8000f436 <__avr32_f64_mul_res_subnormal>:
8000f436:	5c 3c       	neg	r12
8000f438:	2f fc       	sub	r12,-1
8000f43a:	f1 bc 04 c0 	satu	r12,0x6
8000f43e:	e0 4c 00 20 	cp.w	r12,32
8000f442:	c1 14       	brge	8000f464 <__avr32_f64_mul_res_subnormal+0x2e>
8000f444:	f8 08 11 20 	rsub	r8,r12,32
8000f448:	0e 46       	or	r6,r7
8000f44a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f44e:	f4 08 09 49 	lsl	r9,r10,r8
8000f452:	12 47       	or	r7,r9
8000f454:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f458:	f6 08 09 49 	lsl	r9,r11,r8
8000f45c:	12 4a       	or	r10,r9
8000f45e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f462:	c8 3b       	rjmp	8000f368 <__avr32_f64_mul+0x7c>
8000f464:	f8 08 11 20 	rsub	r8,r12,32
8000f468:	f9 b9 00 00 	moveq	r9,0
8000f46c:	c0 30       	breq	8000f472 <__avr32_f64_mul_res_subnormal+0x3c>
8000f46e:	f6 08 09 49 	lsl	r9,r11,r8
8000f472:	0e 46       	or	r6,r7
8000f474:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f478:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f47c:	f3 ea 10 07 	or	r7,r9,r10
8000f480:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f484:	30 0b       	mov	r11,0
8000f486:	c7 1b       	rjmp	8000f368 <__avr32_f64_mul+0x7c>

8000f488 <__avr32_f64_mul_res_zero>:
8000f488:	1c 9b       	mov	r11,lr
8000f48a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f48e:	30 0a       	mov	r10,0
8000f490:	d8 22       	popm	r4-r7,pc

8000f492 <__avr32_f64_mul_res_nan>:
8000f492:	3f fb       	mov	r11,-1
8000f494:	3f fa       	mov	r10,-1
8000f496:	d8 22       	popm	r4-r7,pc

8000f498 <__avr32_f64_mul_res_inf>:
8000f498:	f0 6b 00 00 	mov	r11,-1048576
8000f49c:	ed be 00 1f 	bld	lr,0x1f
8000f4a0:	ef bb 00 1f 	bst	r11,0x1f
8000f4a4:	30 0a       	mov	r10,0
8000f4a6:	d8 22       	popm	r4-r7,pc

8000f4a8 <__avr32_f64_mul_op1_zero>:
8000f4a8:	f7 e9 20 0b 	eor	r11,r11,r9
8000f4ac:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f4b0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f4b4:	e0 4c 07 ff 	cp.w	r12,2047
8000f4b8:	5e 1c       	retne	r12
8000f4ba:	3f fa       	mov	r10,-1
8000f4bc:	3f fb       	mov	r11,-1
8000f4be:	5e fc       	retal	r12

8000f4c0 <__avr32_f64_sub_from_add>:
8000f4c0:	ee 19 80 00 	eorh	r9,0x8000

8000f4c4 <__avr32_f64_sub>:
8000f4c4:	f7 e9 20 0c 	eor	r12,r11,r9
8000f4c8:	e0 86 00 ca 	brmi	8000f65c <__avr32_f64_add_from_sub>
8000f4cc:	eb cd 40 e0 	pushm	r5-r7,lr
8000f4d0:	16 9c       	mov	r12,r11
8000f4d2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f4d6:	bf db       	cbr	r11,0x1f
8000f4d8:	bf d9       	cbr	r9,0x1f
8000f4da:	10 3a       	cp.w	r10,r8
8000f4dc:	f2 0b 13 00 	cpc	r11,r9
8000f4e0:	c0 92       	brcc	8000f4f2 <__avr32_f64_sub+0x2e>
8000f4e2:	16 97       	mov	r7,r11
8000f4e4:	12 9b       	mov	r11,r9
8000f4e6:	0e 99       	mov	r9,r7
8000f4e8:	14 97       	mov	r7,r10
8000f4ea:	10 9a       	mov	r10,r8
8000f4ec:	0e 98       	mov	r8,r7
8000f4ee:	ee 1c 80 00 	eorh	r12,0x8000
8000f4f2:	f6 07 16 14 	lsr	r7,r11,0x14
8000f4f6:	ab 7b       	lsl	r11,0xb
8000f4f8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f4fc:	ab 7a       	lsl	r10,0xb
8000f4fe:	bf bb       	sbr	r11,0x1f
8000f500:	f2 06 16 14 	lsr	r6,r9,0x14
8000f504:	c4 40       	breq	8000f58c <__avr32_f64_sub_opL_subnormal>
8000f506:	ab 79       	lsl	r9,0xb
8000f508:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f50c:	ab 78       	lsl	r8,0xb
8000f50e:	bf b9       	sbr	r9,0x1f

8000f510 <__avr32_f64_sub_opL_subnormal_done>:
8000f510:	e0 47 07 ff 	cp.w	r7,2047
8000f514:	c4 f0       	breq	8000f5b2 <__avr32_f64_sub_opH_nan_or_inf>
8000f516:	0e 26       	rsub	r6,r7
8000f518:	c1 20       	breq	8000f53c <__avr32_f64_sub_shift_done>
8000f51a:	ec 05 11 20 	rsub	r5,r6,32
8000f51e:	e0 46 00 20 	cp.w	r6,32
8000f522:	c7 c2       	brcc	8000f61a <__avr32_f64_sub_longshift>
8000f524:	f0 05 09 4e 	lsl	lr,r8,r5
8000f528:	f2 05 09 45 	lsl	r5,r9,r5
8000f52c:	f0 06 0a 48 	lsr	r8,r8,r6
8000f530:	f2 06 0a 49 	lsr	r9,r9,r6
8000f534:	0a 48       	or	r8,r5
8000f536:	58 0e       	cp.w	lr,0
8000f538:	5f 1e       	srne	lr
8000f53a:	1c 48       	or	r8,lr

8000f53c <__avr32_f64_sub_shift_done>:
8000f53c:	10 1a       	sub	r10,r8
8000f53e:	f6 09 01 4b 	sbc	r11,r11,r9
8000f542:	f6 06 12 00 	clz	r6,r11
8000f546:	c0 e0       	breq	8000f562 <__avr32_f64_sub_longnormalize_done>
8000f548:	c7 83       	brcs	8000f638 <__avr32_f64_sub_longnormalize>
8000f54a:	ec 0e 11 20 	rsub	lr,r6,32
8000f54e:	f6 06 09 4b 	lsl	r11,r11,r6
8000f552:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f556:	1c 4b       	or	r11,lr
8000f558:	f4 06 09 4a 	lsl	r10,r10,r6
8000f55c:	0c 17       	sub	r7,r6
8000f55e:	e0 8a 00 39 	brle	8000f5d0 <__avr32_f64_sub_subnormal_result>

8000f562 <__avr32_f64_sub_longnormalize_done>:
8000f562:	f4 09 15 15 	lsl	r9,r10,0x15
8000f566:	ab 9a       	lsr	r10,0xb
8000f568:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f56c:	ab 9b       	lsr	r11,0xb
8000f56e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f572:	18 4b       	or	r11,r12

8000f574 <__avr32_f64_sub_round>:
8000f574:	fc 17 80 00 	movh	r7,0x8000
8000f578:	ed ba 00 00 	bld	r10,0x0
8000f57c:	f7 b7 01 ff 	subne	r7,-1
8000f580:	0e 39       	cp.w	r9,r7
8000f582:	5f 29       	srhs	r9
8000f584:	12 0a       	add	r10,r9
8000f586:	5c 0b       	acr	r11
8000f588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f58c <__avr32_f64_sub_opL_subnormal>:
8000f58c:	ab 79       	lsl	r9,0xb
8000f58e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f592:	ab 78       	lsl	r8,0xb
8000f594:	f3 e8 10 0e 	or	lr,r9,r8
8000f598:	f9 b6 01 01 	movne	r6,1
8000f59c:	ee 0e 11 00 	rsub	lr,r7,0
8000f5a0:	f9 b7 00 01 	moveq	r7,1
8000f5a4:	ef bb 00 1f 	bst	r11,0x1f
8000f5a8:	f7 ea 10 0e 	or	lr,r11,r10
8000f5ac:	f9 b7 00 00 	moveq	r7,0
8000f5b0:	cb 0b       	rjmp	8000f510 <__avr32_f64_sub_opL_subnormal_done>

8000f5b2 <__avr32_f64_sub_opH_nan_or_inf>:
8000f5b2:	bf db       	cbr	r11,0x1f
8000f5b4:	f7 ea 10 0e 	or	lr,r11,r10
8000f5b8:	c0 81       	brne	8000f5c8 <__avr32_f64_sub_return_nan>
8000f5ba:	e0 46 07 ff 	cp.w	r6,2047
8000f5be:	c0 50       	breq	8000f5c8 <__avr32_f64_sub_return_nan>
8000f5c0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f5c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f5c8 <__avr32_f64_sub_return_nan>:
8000f5c8:	3f fa       	mov	r10,-1
8000f5ca:	3f fb       	mov	r11,-1
8000f5cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f5d0 <__avr32_f64_sub_subnormal_result>:
8000f5d0:	5c 37       	neg	r7
8000f5d2:	2f f7       	sub	r7,-1
8000f5d4:	f1 b7 04 c0 	satu	r7,0x6
8000f5d8:	e0 47 00 20 	cp.w	r7,32
8000f5dc:	c1 14       	brge	8000f5fe <__avr32_f64_sub_subnormal_result+0x2e>
8000f5de:	ee 08 11 20 	rsub	r8,r7,32
8000f5e2:	f4 08 09 49 	lsl	r9,r10,r8
8000f5e6:	5f 16       	srne	r6
8000f5e8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f5ec:	0c 4a       	or	r10,r6
8000f5ee:	f6 08 09 49 	lsl	r9,r11,r8
8000f5f2:	f5 e9 10 0a 	or	r10,r10,r9
8000f5f6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f5fa:	30 07       	mov	r7,0
8000f5fc:	cb 3b       	rjmp	8000f562 <__avr32_f64_sub_longnormalize_done>
8000f5fe:	ee 08 11 40 	rsub	r8,r7,64
8000f602:	f6 08 09 49 	lsl	r9,r11,r8
8000f606:	14 49       	or	r9,r10
8000f608:	5f 16       	srne	r6
8000f60a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f60e:	0c 4a       	or	r10,r6
8000f610:	30 0b       	mov	r11,0
8000f612:	30 07       	mov	r7,0
8000f614:	ca 7b       	rjmp	8000f562 <__avr32_f64_sub_longnormalize_done>
8000f616:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f61a <__avr32_f64_sub_longshift>:
8000f61a:	f1 b6 04 c0 	satu	r6,0x6
8000f61e:	f0 0e 17 00 	moveq	lr,r8
8000f622:	c0 40       	breq	8000f62a <__avr32_f64_sub_longshift+0x10>
8000f624:	f2 05 09 4e 	lsl	lr,r9,r5
8000f628:	10 4e       	or	lr,r8
8000f62a:	f2 06 0a 48 	lsr	r8,r9,r6
8000f62e:	30 09       	mov	r9,0
8000f630:	58 0e       	cp.w	lr,0
8000f632:	5f 1e       	srne	lr
8000f634:	1c 48       	or	r8,lr
8000f636:	c8 3b       	rjmp	8000f53c <__avr32_f64_sub_shift_done>

8000f638 <__avr32_f64_sub_longnormalize>:
8000f638:	f4 06 12 00 	clz	r6,r10
8000f63c:	f9 b7 03 00 	movlo	r7,0
8000f640:	f9 b6 03 00 	movlo	r6,0
8000f644:	f9 bc 03 00 	movlo	r12,0
8000f648:	f7 b6 02 e0 	subhs	r6,-32
8000f64c:	f4 06 09 4b 	lsl	r11,r10,r6
8000f650:	30 0a       	mov	r10,0
8000f652:	0c 17       	sub	r7,r6
8000f654:	fe 9a ff be 	brle	8000f5d0 <__avr32_f64_sub_subnormal_result>
8000f658:	c8 5b       	rjmp	8000f562 <__avr32_f64_sub_longnormalize_done>
8000f65a:	d7 03       	nop

8000f65c <__avr32_f64_add_from_sub>:
8000f65c:	ee 19 80 00 	eorh	r9,0x8000

8000f660 <__avr32_f64_add>:
8000f660:	f7 e9 20 0c 	eor	r12,r11,r9
8000f664:	fe 96 ff 2e 	brmi	8000f4c0 <__avr32_f64_sub_from_add>
8000f668:	eb cd 40 e0 	pushm	r5-r7,lr
8000f66c:	16 9c       	mov	r12,r11
8000f66e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f672:	bf db       	cbr	r11,0x1f
8000f674:	bf d9       	cbr	r9,0x1f
8000f676:	12 3b       	cp.w	r11,r9
8000f678:	c0 72       	brcc	8000f686 <__avr32_f64_add+0x26>
8000f67a:	16 97       	mov	r7,r11
8000f67c:	12 9b       	mov	r11,r9
8000f67e:	0e 99       	mov	r9,r7
8000f680:	14 97       	mov	r7,r10
8000f682:	10 9a       	mov	r10,r8
8000f684:	0e 98       	mov	r8,r7
8000f686:	30 0e       	mov	lr,0
8000f688:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f68c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000f690:	b5 ab       	sbr	r11,0x14
8000f692:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f696:	c6 20       	breq	8000f75a <__avr32_f64_add_op2_subnormal>
8000f698:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000f69c:	b5 a9       	sbr	r9,0x14
8000f69e:	e0 47 07 ff 	cp.w	r7,2047
8000f6a2:	c2 80       	breq	8000f6f2 <__avr32_f64_add_opH_nan_or_inf>
8000f6a4:	0e 26       	rsub	r6,r7
8000f6a6:	c1 20       	breq	8000f6ca <__avr32_f64_add_shift_done>
8000f6a8:	e0 46 00 36 	cp.w	r6,54
8000f6ac:	c1 52       	brcc	8000f6d6 <__avr32_f64_add_res_of_done>
8000f6ae:	ec 05 11 20 	rsub	r5,r6,32
8000f6b2:	e0 46 00 20 	cp.w	r6,32
8000f6b6:	c3 52       	brcc	8000f720 <__avr32_f64_add_longshift>
8000f6b8:	f0 05 09 4e 	lsl	lr,r8,r5
8000f6bc:	f2 05 09 45 	lsl	r5,r9,r5
8000f6c0:	f0 06 0a 48 	lsr	r8,r8,r6
8000f6c4:	f2 06 0a 49 	lsr	r9,r9,r6
8000f6c8:	0a 48       	or	r8,r5

8000f6ca <__avr32_f64_add_shift_done>:
8000f6ca:	10 0a       	add	r10,r8
8000f6cc:	f6 09 00 4b 	adc	r11,r11,r9
8000f6d0:	ed bb 00 15 	bld	r11,0x15
8000f6d4:	c3 40       	breq	8000f73c <__avr32_f64_add_res_of>

8000f6d6 <__avr32_f64_add_res_of_done>:
8000f6d6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f6da:	18 4b       	or	r11,r12

8000f6dc <__avr32_f64_add_round>:
8000f6dc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f6e0:	18 4e       	or	lr,r12
8000f6e2:	ee 1e 80 00 	eorh	lr,0x8000
8000f6e6:	f1 be 04 20 	satu	lr,0x1
8000f6ea:	1c 0a       	add	r10,lr
8000f6ec:	5c 0b       	acr	r11
8000f6ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f6f2 <__avr32_f64_add_opH_nan_or_inf>:
8000f6f2:	b5 cb       	cbr	r11,0x14
8000f6f4:	f7 ea 10 0e 	or	lr,r11,r10
8000f6f8:	c1 01       	brne	8000f718 <__avr32_f64_add_return_nan>
8000f6fa:	e0 46 07 ff 	cp.w	r6,2047
8000f6fe:	c0 30       	breq	8000f704 <__avr32_f64_add_opL_nan_or_inf>
8000f700:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f704 <__avr32_f64_add_opL_nan_or_inf>:
8000f704:	b5 c9       	cbr	r9,0x14
8000f706:	f3 e8 10 0e 	or	lr,r9,r8
8000f70a:	c0 71       	brne	8000f718 <__avr32_f64_add_return_nan>
8000f70c:	30 0a       	mov	r10,0
8000f70e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f712:	18 4b       	or	r11,r12
8000f714:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f718 <__avr32_f64_add_return_nan>:
8000f718:	3f fa       	mov	r10,-1
8000f71a:	3f fb       	mov	r11,-1
8000f71c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f720 <__avr32_f64_add_longshift>:
8000f720:	f1 b6 04 c0 	satu	r6,0x6
8000f724:	f0 0e 17 00 	moveq	lr,r8
8000f728:	c0 60       	breq	8000f734 <__avr32_f64_add_longshift+0x14>
8000f72a:	f2 05 09 4e 	lsl	lr,r9,r5
8000f72e:	58 08       	cp.w	r8,0
8000f730:	5f 18       	srne	r8
8000f732:	10 4e       	or	lr,r8
8000f734:	f2 06 0a 48 	lsr	r8,r9,r6
8000f738:	30 09       	mov	r9,0
8000f73a:	cc 8b       	rjmp	8000f6ca <__avr32_f64_add_shift_done>

8000f73c <__avr32_f64_add_res_of>:
8000f73c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f740:	a1 9b       	lsr	r11,0x1
8000f742:	5d 0a       	ror	r10
8000f744:	5d 0e       	ror	lr
8000f746:	2f f7       	sub	r7,-1
8000f748:	e0 47 07 ff 	cp.w	r7,2047
8000f74c:	f9 ba 00 00 	moveq	r10,0
8000f750:	f9 bb 00 00 	moveq	r11,0
8000f754:	f9 be 00 00 	moveq	lr,0
8000f758:	cb fb       	rjmp	8000f6d6 <__avr32_f64_add_res_of_done>

8000f75a <__avr32_f64_add_op2_subnormal>:
8000f75a:	30 16       	mov	r6,1
8000f75c:	58 07       	cp.w	r7,0
8000f75e:	ca 01       	brne	8000f69e <__avr32_f64_add+0x3e>
8000f760:	b5 cb       	cbr	r11,0x14
8000f762:	10 0a       	add	r10,r8
8000f764:	f6 09 00 4b 	adc	r11,r11,r9
8000f768:	18 4b       	or	r11,r12
8000f76a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f76e:	d7 03       	nop

8000f770 <__avr32_f64_to_u32>:
8000f770:	58 0b       	cp.w	r11,0
8000f772:	5e 6d       	retmi	0

8000f774 <__avr32_f64_to_s32>:
8000f774:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f778:	b5 9c       	lsr	r12,0x15
8000f77a:	e0 2c 03 ff 	sub	r12,1023
8000f77e:	5e 3d       	retlo	0
8000f780:	f8 0c 11 1f 	rsub	r12,r12,31
8000f784:	16 99       	mov	r9,r11
8000f786:	ab 7b       	lsl	r11,0xb
8000f788:	bf bb       	sbr	r11,0x1f
8000f78a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f78e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f792:	a1 79       	lsl	r9,0x1
8000f794:	5e 2b       	reths	r11
8000f796:	5c 3b       	neg	r11
8000f798:	5e fb       	retal	r11

8000f79a <__avr32_u32_to_f64>:
8000f79a:	f8 cb 00 00 	sub	r11,r12,0
8000f79e:	30 0c       	mov	r12,0
8000f7a0:	c0 38       	rjmp	8000f7a6 <__avr32_s32_to_f64+0x4>

8000f7a2 <__avr32_s32_to_f64>:
8000f7a2:	18 9b       	mov	r11,r12
8000f7a4:	5c 4b       	abs	r11
8000f7a6:	30 0a       	mov	r10,0
8000f7a8:	5e 0b       	reteq	r11
8000f7aa:	d4 01       	pushm	lr
8000f7ac:	e0 69 04 1e 	mov	r9,1054
8000f7b0:	f6 08 12 00 	clz	r8,r11
8000f7b4:	c1 70       	breq	8000f7e2 <__avr32_s32_to_f64+0x40>
8000f7b6:	c0 c3       	brcs	8000f7ce <__avr32_s32_to_f64+0x2c>
8000f7b8:	f0 0e 11 20 	rsub	lr,r8,32
8000f7bc:	f6 08 09 4b 	lsl	r11,r11,r8
8000f7c0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f7c4:	1c 4b       	or	r11,lr
8000f7c6:	f4 08 09 4a 	lsl	r10,r10,r8
8000f7ca:	10 19       	sub	r9,r8
8000f7cc:	c0 b8       	rjmp	8000f7e2 <__avr32_s32_to_f64+0x40>
8000f7ce:	f4 08 12 00 	clz	r8,r10
8000f7d2:	f9 b8 03 00 	movlo	r8,0
8000f7d6:	f7 b8 02 e0 	subhs	r8,-32
8000f7da:	f4 08 09 4b 	lsl	r11,r10,r8
8000f7de:	30 0a       	mov	r10,0
8000f7e0:	10 19       	sub	r9,r8
8000f7e2:	58 09       	cp.w	r9,0
8000f7e4:	e0 89 00 30 	brgt	8000f844 <__avr32_s32_to_f64+0xa2>
8000f7e8:	5c 39       	neg	r9
8000f7ea:	2f f9       	sub	r9,-1
8000f7ec:	e0 49 00 36 	cp.w	r9,54
8000f7f0:	c0 43       	brcs	8000f7f8 <__avr32_s32_to_f64+0x56>
8000f7f2:	30 0b       	mov	r11,0
8000f7f4:	30 0a       	mov	r10,0
8000f7f6:	c2 68       	rjmp	8000f842 <__avr32_s32_to_f64+0xa0>
8000f7f8:	2f 69       	sub	r9,-10
8000f7fa:	f2 08 11 20 	rsub	r8,r9,32
8000f7fe:	e0 49 00 20 	cp.w	r9,32
8000f802:	c0 b2       	brcc	8000f818 <__avr32_s32_to_f64+0x76>
8000f804:	f4 08 09 4e 	lsl	lr,r10,r8
8000f808:	f6 08 09 48 	lsl	r8,r11,r8
8000f80c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f810:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f814:	10 4b       	or	r11,r8
8000f816:	c0 88       	rjmp	8000f826 <__avr32_s32_to_f64+0x84>
8000f818:	f6 08 09 4e 	lsl	lr,r11,r8
8000f81c:	14 4e       	or	lr,r10
8000f81e:	16 9a       	mov	r10,r11
8000f820:	30 0b       	mov	r11,0
8000f822:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f826:	ed ba 00 00 	bld	r10,0x0
8000f82a:	c0 92       	brcc	8000f83c <__avr32_s32_to_f64+0x9a>
8000f82c:	1c 7e       	tst	lr,lr
8000f82e:	c0 41       	brne	8000f836 <__avr32_s32_to_f64+0x94>
8000f830:	ed ba 00 01 	bld	r10,0x1
8000f834:	c0 42       	brcc	8000f83c <__avr32_s32_to_f64+0x9a>
8000f836:	2f fa       	sub	r10,-1
8000f838:	f7 bb 02 ff 	subhs	r11,-1
8000f83c:	5c fc       	rol	r12
8000f83e:	5d 0b       	ror	r11
8000f840:	5d 0a       	ror	r10
8000f842:	d8 02       	popm	pc
8000f844:	e0 68 03 ff 	mov	r8,1023
8000f848:	ed ba 00 0b 	bld	r10,0xb
8000f84c:	f7 b8 00 ff 	subeq	r8,-1
8000f850:	10 0a       	add	r10,r8
8000f852:	5c 0b       	acr	r11
8000f854:	f7 b9 03 fe 	sublo	r9,-2
8000f858:	e0 49 07 ff 	cp.w	r9,2047
8000f85c:	c0 55       	brlt	8000f866 <__avr32_s32_to_f64+0xc4>
8000f85e:	30 0a       	mov	r10,0
8000f860:	fc 1b ff e0 	movh	r11,0xffe0
8000f864:	c0 c8       	rjmp	8000f87c <__floatsidf_return_op1>
8000f866:	ed bb 00 1f 	bld	r11,0x1f
8000f86a:	f7 b9 01 01 	subne	r9,1
8000f86e:	ab 9a       	lsr	r10,0xb
8000f870:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f874:	a1 7b       	lsl	r11,0x1
8000f876:	ab 9b       	lsr	r11,0xb
8000f878:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f87c <__floatsidf_return_op1>:
8000f87c:	a1 7c       	lsl	r12,0x1
8000f87e:	5d 0b       	ror	r11
8000f880:	d8 02       	popm	pc

8000f882 <__avr32_f64_cmp_eq>:
8000f882:	10 3a       	cp.w	r10,r8
8000f884:	f2 0b 13 00 	cpc	r11,r9
8000f888:	c0 80       	breq	8000f898 <__avr32_f64_cmp_eq+0x16>
8000f88a:	a1 7b       	lsl	r11,0x1
8000f88c:	a1 79       	lsl	r9,0x1
8000f88e:	14 4b       	or	r11,r10
8000f890:	12 4b       	or	r11,r9
8000f892:	10 4b       	or	r11,r8
8000f894:	5e 0f       	reteq	1
8000f896:	5e fd       	retal	0
8000f898:	a1 7b       	lsl	r11,0x1
8000f89a:	fc 1c ff e0 	movh	r12,0xffe0
8000f89e:	58 0a       	cp.w	r10,0
8000f8a0:	f8 0b 13 00 	cpc	r11,r12
8000f8a4:	5e 8f       	retls	1
8000f8a6:	5e fd       	retal	0

8000f8a8 <__avr32_f64_cmp_ge>:
8000f8a8:	1a de       	st.w	--sp,lr
8000f8aa:	1a d7       	st.w	--sp,r7
8000f8ac:	a1 7b       	lsl	r11,0x1
8000f8ae:	5f 3c       	srlo	r12
8000f8b0:	a1 79       	lsl	r9,0x1
8000f8b2:	5f 37       	srlo	r7
8000f8b4:	5c fc       	rol	r12
8000f8b6:	fc 1e ff e0 	movh	lr,0xffe0
8000f8ba:	58 0a       	cp.w	r10,0
8000f8bc:	fc 0b 13 00 	cpc	r11,lr
8000f8c0:	e0 8b 00 1d 	brhi	8000f8fa <__avr32_f64_cmp_ge+0x52>
8000f8c4:	58 08       	cp.w	r8,0
8000f8c6:	fc 09 13 00 	cpc	r9,lr
8000f8ca:	e0 8b 00 18 	brhi	8000f8fa <__avr32_f64_cmp_ge+0x52>
8000f8ce:	58 0b       	cp.w	r11,0
8000f8d0:	f5 ba 00 00 	subfeq	r10,0
8000f8d4:	c1 50       	breq	8000f8fe <__avr32_f64_cmp_ge+0x56>
8000f8d6:	1b 07       	ld.w	r7,sp++
8000f8d8:	1b 0e       	ld.w	lr,sp++
8000f8da:	58 3c       	cp.w	r12,3
8000f8dc:	c0 a0       	breq	8000f8f0 <__avr32_f64_cmp_ge+0x48>
8000f8de:	58 1c       	cp.w	r12,1
8000f8e0:	c0 33       	brcs	8000f8e6 <__avr32_f64_cmp_ge+0x3e>
8000f8e2:	5e 0f       	reteq	1
8000f8e4:	5e 1d       	retne	0
8000f8e6:	10 3a       	cp.w	r10,r8
8000f8e8:	f2 0b 13 00 	cpc	r11,r9
8000f8ec:	5e 2f       	reths	1
8000f8ee:	5e 3d       	retlo	0
8000f8f0:	14 38       	cp.w	r8,r10
8000f8f2:	f6 09 13 00 	cpc	r9,r11
8000f8f6:	5e 2f       	reths	1
8000f8f8:	5e 3d       	retlo	0
8000f8fa:	1b 07       	ld.w	r7,sp++
8000f8fc:	d8 0a       	popm	pc,r12=0
8000f8fe:	58 17       	cp.w	r7,1
8000f900:	5f 0c       	sreq	r12
8000f902:	58 09       	cp.w	r9,0
8000f904:	f5 b8 00 00 	subfeq	r8,0
8000f908:	1b 07       	ld.w	r7,sp++
8000f90a:	1b 0e       	ld.w	lr,sp++
8000f90c:	5e 0f       	reteq	1
8000f90e:	5e fc       	retal	r12

8000f910 <__avr32_f64_cmp_lt>:
8000f910:	1a de       	st.w	--sp,lr
8000f912:	1a d7       	st.w	--sp,r7
8000f914:	a1 7b       	lsl	r11,0x1
8000f916:	5f 3c       	srlo	r12
8000f918:	a1 79       	lsl	r9,0x1
8000f91a:	5f 37       	srlo	r7
8000f91c:	5c fc       	rol	r12
8000f91e:	fc 1e ff e0 	movh	lr,0xffe0
8000f922:	58 0a       	cp.w	r10,0
8000f924:	fc 0b 13 00 	cpc	r11,lr
8000f928:	e0 8b 00 1d 	brhi	8000f962 <__avr32_f64_cmp_lt+0x52>
8000f92c:	58 08       	cp.w	r8,0
8000f92e:	fc 09 13 00 	cpc	r9,lr
8000f932:	e0 8b 00 18 	brhi	8000f962 <__avr32_f64_cmp_lt+0x52>
8000f936:	58 0b       	cp.w	r11,0
8000f938:	f5 ba 00 00 	subfeq	r10,0
8000f93c:	c1 50       	breq	8000f966 <__avr32_f64_cmp_lt+0x56>
8000f93e:	1b 07       	ld.w	r7,sp++
8000f940:	1b 0e       	ld.w	lr,sp++
8000f942:	58 3c       	cp.w	r12,3
8000f944:	c0 a0       	breq	8000f958 <__avr32_f64_cmp_lt+0x48>
8000f946:	58 1c       	cp.w	r12,1
8000f948:	c0 33       	brcs	8000f94e <__avr32_f64_cmp_lt+0x3e>
8000f94a:	5e 0d       	reteq	0
8000f94c:	5e 1f       	retne	1
8000f94e:	10 3a       	cp.w	r10,r8
8000f950:	f2 0b 13 00 	cpc	r11,r9
8000f954:	5e 2d       	reths	0
8000f956:	5e 3f       	retlo	1
8000f958:	14 38       	cp.w	r8,r10
8000f95a:	f6 09 13 00 	cpc	r9,r11
8000f95e:	5e 2d       	reths	0
8000f960:	5e 3f       	retlo	1
8000f962:	1b 07       	ld.w	r7,sp++
8000f964:	d8 0a       	popm	pc,r12=0
8000f966:	58 17       	cp.w	r7,1
8000f968:	5f 1c       	srne	r12
8000f96a:	58 09       	cp.w	r9,0
8000f96c:	f5 b8 00 00 	subfeq	r8,0
8000f970:	1b 07       	ld.w	r7,sp++
8000f972:	1b 0e       	ld.w	lr,sp++
8000f974:	5e 0d       	reteq	0
8000f976:	5e fc       	retal	r12

8000f978 <__avr32_f64_div>:
8000f978:	eb cd 40 ff 	pushm	r0-r7,lr
8000f97c:	f7 e9 20 0e 	eor	lr,r11,r9
8000f980:	f6 07 16 14 	lsr	r7,r11,0x14
8000f984:	a9 7b       	lsl	r11,0x9
8000f986:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f98a:	a9 7a       	lsl	r10,0x9
8000f98c:	bd bb       	sbr	r11,0x1d
8000f98e:	e4 1b 3f ff 	andh	r11,0x3fff
8000f992:	ab d7       	cbr	r7,0xb
8000f994:	e0 80 00 cc 	breq	8000fb2c <__avr32_f64_div_round_subnormal+0x54>
8000f998:	e0 47 07 ff 	cp.w	r7,2047
8000f99c:	e0 84 00 b5 	brge	8000fb06 <__avr32_f64_div_round_subnormal+0x2e>
8000f9a0:	f2 06 16 14 	lsr	r6,r9,0x14
8000f9a4:	a9 79       	lsl	r9,0x9
8000f9a6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f9aa:	a9 78       	lsl	r8,0x9
8000f9ac:	bd b9       	sbr	r9,0x1d
8000f9ae:	e4 19 3f ff 	andh	r9,0x3fff
8000f9b2:	ab d6       	cbr	r6,0xb
8000f9b4:	e0 80 00 e2 	breq	8000fb78 <__avr32_f64_div_round_subnormal+0xa0>
8000f9b8:	e0 46 07 ff 	cp.w	r6,2047
8000f9bc:	e0 84 00 b2 	brge	8000fb20 <__avr32_f64_div_round_subnormal+0x48>
8000f9c0:	0c 17       	sub	r7,r6
8000f9c2:	fe 37 fc 01 	sub	r7,-1023
8000f9c6:	fc 1c 80 00 	movh	r12,0x8000
8000f9ca:	f8 03 16 01 	lsr	r3,r12,0x1
8000f9ce:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f9d2:	5c d4       	com	r4
8000f9d4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f9d8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f9dc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f9e0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f9e4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f9e8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f9ec:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f9f0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f9f4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f9f8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f9fc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fa00:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fa04:	ea 03 15 02 	lsl	r3,r5,0x2
8000fa08:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fa0c:	e4 09 07 40 	macu.d	r0,r2,r9
8000fa10:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fa14:	02 04       	add	r4,r1
8000fa16:	5c 05       	acr	r5
8000fa18:	a3 65       	lsl	r5,0x2
8000fa1a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000fa1e:	a3 64       	lsl	r4,0x2
8000fa20:	5c 34       	neg	r4
8000fa22:	f8 05 01 45 	sbc	r5,r12,r5
8000fa26:	e6 04 06 40 	mulu.d	r0,r3,r4
8000fa2a:	e4 05 07 40 	macu.d	r0,r2,r5
8000fa2e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fa32:	02 04       	add	r4,r1
8000fa34:	5c 05       	acr	r5
8000fa36:	ea 03 15 02 	lsl	r3,r5,0x2
8000fa3a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000fa3e:	e8 02 15 02 	lsl	r2,r4,0x2
8000fa42:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fa46:	e4 09 07 40 	macu.d	r0,r2,r9
8000fa4a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fa4e:	02 04       	add	r4,r1
8000fa50:	5c 05       	acr	r5
8000fa52:	a3 65       	lsl	r5,0x2
8000fa54:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000fa58:	a3 64       	lsl	r4,0x2
8000fa5a:	5c 34       	neg	r4
8000fa5c:	f8 05 01 45 	sbc	r5,r12,r5
8000fa60:	e6 04 06 40 	mulu.d	r0,r3,r4
8000fa64:	e4 05 07 40 	macu.d	r0,r2,r5
8000fa68:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fa6c:	02 04       	add	r4,r1
8000fa6e:	5c 05       	acr	r5
8000fa70:	ea 03 15 02 	lsl	r3,r5,0x2
8000fa74:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000fa78:	e8 02 15 02 	lsl	r2,r4,0x2
8000fa7c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000fa80:	e4 0b 07 40 	macu.d	r0,r2,r11
8000fa84:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000fa88:	02 02       	add	r2,r1
8000fa8a:	5c 03       	acr	r3
8000fa8c:	ed b3 00 1c 	bld	r3,0x1c
8000fa90:	c0 90       	breq	8000faa2 <__avr32_f64_div+0x12a>
8000fa92:	a1 72       	lsl	r2,0x1
8000fa94:	5c f3       	rol	r3
8000fa96:	20 17       	sub	r7,1
8000fa98:	a3 9a       	lsr	r10,0x3
8000fa9a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000fa9e:	a3 9b       	lsr	r11,0x3
8000faa0:	c0 58       	rjmp	8000faaa <__avr32_f64_div+0x132>
8000faa2:	a5 8a       	lsr	r10,0x4
8000faa4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000faa8:	a5 8b       	lsr	r11,0x4
8000faaa:	58 07       	cp.w	r7,0
8000faac:	e0 8a 00 8b 	brle	8000fbc2 <__avr32_f64_div_res_subnormal>
8000fab0:	e0 12 ff 00 	andl	r2,0xff00
8000fab4:	e8 12 00 80 	orl	r2,0x80
8000fab8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fabc:	e4 09 07 40 	macu.d	r0,r2,r9
8000fac0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fac4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fac8:	00 05       	add	r5,r0
8000faca:	f0 01 00 48 	adc	r8,r8,r1
8000face:	5c 09       	acr	r9
8000fad0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fad4:	58 04       	cp.w	r4,0
8000fad6:	5c 25       	cpc	r5

8000fad8 <__avr32_f64_div_round_subnormal>:
8000fad8:	f4 08 13 00 	cpc	r8,r10
8000fadc:	f6 09 13 00 	cpc	r9,r11
8000fae0:	5f 36       	srlo	r6
8000fae2:	f8 06 17 00 	moveq	r6,r12
8000fae6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000faea:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000faee:	e6 0b 16 08 	lsr	r11,r3,0x8
8000faf2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000faf6:	ed be 00 1f 	bld	lr,0x1f
8000fafa:	ef bb 00 1f 	bst	r11,0x1f
8000fafe:	0c 0a       	add	r10,r6
8000fb00:	5c 0b       	acr	r11
8000fb02:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fb06:	e4 1b 00 0f 	andh	r11,0xf
8000fb0a:	14 4b       	or	r11,r10
8000fb0c:	e0 81 00 a7 	brne	8000fc5a <__avr32_f64_div_res_subnormal+0x98>
8000fb10:	f2 06 16 14 	lsr	r6,r9,0x14
8000fb14:	ab d6       	cbr	r6,0xb
8000fb16:	e0 46 07 ff 	cp.w	r6,2047
8000fb1a:	e0 81 00 a4 	brne	8000fc62 <__avr32_f64_div_res_subnormal+0xa0>
8000fb1e:	c9 e8       	rjmp	8000fc5a <__avr32_f64_div_res_subnormal+0x98>
8000fb20:	e4 19 00 0f 	andh	r9,0xf
8000fb24:	10 49       	or	r9,r8
8000fb26:	e0 81 00 9a 	brne	8000fc5a <__avr32_f64_div_res_subnormal+0x98>
8000fb2a:	c9 28       	rjmp	8000fc4e <__avr32_f64_div_res_subnormal+0x8c>
8000fb2c:	a3 7b       	lsl	r11,0x3
8000fb2e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000fb32:	a3 7a       	lsl	r10,0x3
8000fb34:	f5 eb 10 04 	or	r4,r10,r11
8000fb38:	e0 80 00 a0 	breq	8000fc78 <__avr32_f64_div_op1_zero>
8000fb3c:	f6 04 12 00 	clz	r4,r11
8000fb40:	c1 70       	breq	8000fb6e <__avr32_f64_div_round_subnormal+0x96>
8000fb42:	c0 c3       	brcs	8000fb5a <__avr32_f64_div_round_subnormal+0x82>
8000fb44:	e8 05 11 20 	rsub	r5,r4,32
8000fb48:	f6 04 09 4b 	lsl	r11,r11,r4
8000fb4c:	f4 05 0a 45 	lsr	r5,r10,r5
8000fb50:	0a 4b       	or	r11,r5
8000fb52:	f4 04 09 4a 	lsl	r10,r10,r4
8000fb56:	08 17       	sub	r7,r4
8000fb58:	c0 b8       	rjmp	8000fb6e <__avr32_f64_div_round_subnormal+0x96>
8000fb5a:	f4 04 12 00 	clz	r4,r10
8000fb5e:	f9 b4 03 00 	movlo	r4,0
8000fb62:	f7 b4 02 e0 	subhs	r4,-32
8000fb66:	f4 04 09 4b 	lsl	r11,r10,r4
8000fb6a:	30 0a       	mov	r10,0
8000fb6c:	08 17       	sub	r7,r4
8000fb6e:	a3 8a       	lsr	r10,0x2
8000fb70:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000fb74:	a3 8b       	lsr	r11,0x2
8000fb76:	c1 1b       	rjmp	8000f998 <__avr32_f64_div+0x20>
8000fb78:	a3 79       	lsl	r9,0x3
8000fb7a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000fb7e:	a3 78       	lsl	r8,0x3
8000fb80:	f3 e8 10 04 	or	r4,r9,r8
8000fb84:	c6 f0       	breq	8000fc62 <__avr32_f64_div_res_subnormal+0xa0>
8000fb86:	f2 04 12 00 	clz	r4,r9
8000fb8a:	c1 70       	breq	8000fbb8 <__avr32_f64_div_round_subnormal+0xe0>
8000fb8c:	c0 c3       	brcs	8000fba4 <__avr32_f64_div_round_subnormal+0xcc>
8000fb8e:	e8 05 11 20 	rsub	r5,r4,32
8000fb92:	f2 04 09 49 	lsl	r9,r9,r4
8000fb96:	f0 05 0a 45 	lsr	r5,r8,r5
8000fb9a:	0a 49       	or	r9,r5
8000fb9c:	f0 04 09 48 	lsl	r8,r8,r4
8000fba0:	08 16       	sub	r6,r4
8000fba2:	c0 b8       	rjmp	8000fbb8 <__avr32_f64_div_round_subnormal+0xe0>
8000fba4:	f0 04 12 00 	clz	r4,r8
8000fba8:	f9 b4 03 00 	movlo	r4,0
8000fbac:	f7 b4 02 e0 	subhs	r4,-32
8000fbb0:	f0 04 09 49 	lsl	r9,r8,r4
8000fbb4:	30 08       	mov	r8,0
8000fbb6:	08 16       	sub	r6,r4
8000fbb8:	a3 88       	lsr	r8,0x2
8000fbba:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000fbbe:	a3 89       	lsr	r9,0x2
8000fbc0:	cf ca       	rjmp	8000f9b8 <__avr32_f64_div+0x40>

8000fbc2 <__avr32_f64_div_res_subnormal>:
8000fbc2:	5c 37       	neg	r7
8000fbc4:	2f f7       	sub	r7,-1
8000fbc6:	f1 b7 04 c0 	satu	r7,0x6
8000fbca:	e0 47 00 20 	cp.w	r7,32
8000fbce:	c1 54       	brge	8000fbf8 <__avr32_f64_div_res_subnormal+0x36>
8000fbd0:	ee 06 11 20 	rsub	r6,r7,32
8000fbd4:	e4 07 0a 42 	lsr	r2,r2,r7
8000fbd8:	e6 06 09 4c 	lsl	r12,r3,r6
8000fbdc:	18 42       	or	r2,r12
8000fbde:	e6 07 0a 43 	lsr	r3,r3,r7
8000fbe2:	f4 06 09 41 	lsl	r1,r10,r6
8000fbe6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000fbea:	f6 06 09 4c 	lsl	r12,r11,r6
8000fbee:	18 4a       	or	r10,r12
8000fbf0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000fbf4:	30 00       	mov	r0,0
8000fbf6:	c1 58       	rjmp	8000fc20 <__avr32_f64_div_res_subnormal+0x5e>
8000fbf8:	ee 06 11 20 	rsub	r6,r7,32
8000fbfc:	f9 b0 00 00 	moveq	r0,0
8000fc00:	f9 bc 00 00 	moveq	r12,0
8000fc04:	c0 50       	breq	8000fc0e <__avr32_f64_div_res_subnormal+0x4c>
8000fc06:	f4 06 09 40 	lsl	r0,r10,r6
8000fc0a:	f6 06 09 4c 	lsl	r12,r11,r6
8000fc0e:	e6 07 0a 42 	lsr	r2,r3,r7
8000fc12:	30 03       	mov	r3,0
8000fc14:	f4 07 0a 41 	lsr	r1,r10,r7
8000fc18:	18 41       	or	r1,r12
8000fc1a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000fc1e:	30 0b       	mov	r11,0
8000fc20:	e0 12 ff 00 	andl	r2,0xff00
8000fc24:	e8 12 00 80 	orl	r2,0x80
8000fc28:	e6 08 06 46 	mulu.d	r6,r3,r8
8000fc2c:	e4 09 07 46 	macu.d	r6,r2,r9
8000fc30:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fc34:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fc38:	0c 05       	add	r5,r6
8000fc3a:	f0 07 00 48 	adc	r8,r8,r7
8000fc3e:	5c 09       	acr	r9
8000fc40:	30 07       	mov	r7,0
8000fc42:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fc46:	00 34       	cp.w	r4,r0
8000fc48:	e2 05 13 00 	cpc	r5,r1
8000fc4c:	c4 6b       	rjmp	8000fad8 <__avr32_f64_div_round_subnormal>
8000fc4e:	1c 9b       	mov	r11,lr
8000fc50:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fc54:	30 0a       	mov	r10,0
8000fc56:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fc5a:	3f fb       	mov	r11,-1
8000fc5c:	30 0a       	mov	r10,0
8000fc5e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fc62:	f5 eb 10 04 	or	r4,r10,r11
8000fc66:	c0 90       	breq	8000fc78 <__avr32_f64_div_op1_zero>
8000fc68:	1c 9b       	mov	r11,lr
8000fc6a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fc6e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000fc72:	30 0a       	mov	r10,0
8000fc74:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000fc78 <__avr32_f64_div_op1_zero>:
8000fc78:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000fc7c:	ce f0       	breq	8000fc5a <__avr32_f64_div_res_subnormal+0x98>
8000fc7e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000fc82:	e0 44 07 ff 	cp.w	r4,2047
8000fc86:	ce 41       	brne	8000fc4e <__avr32_f64_div_res_subnormal+0x8c>
8000fc88:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000fc8c:	ce 10       	breq	8000fc4e <__avr32_f64_div_res_subnormal+0x8c>
8000fc8e:	ce 6b       	rjmp	8000fc5a <__avr32_f64_div_res_subnormal+0x98>

8000fc90 <__avr32_udiv64>:
8000fc90:	d4 31       	pushm	r0-r7,lr
8000fc92:	1a 97       	mov	r7,sp
8000fc94:	20 3d       	sub	sp,12
8000fc96:	10 9c       	mov	r12,r8
8000fc98:	12 9e       	mov	lr,r9
8000fc9a:	14 93       	mov	r3,r10
8000fc9c:	58 09       	cp.w	r9,0
8000fc9e:	e0 81 00 bd 	brne	8000fe18 <__avr32_udiv64+0x188>
8000fca2:	16 38       	cp.w	r8,r11
8000fca4:	e0 88 00 40 	brls	8000fd24 <__avr32_udiv64+0x94>
8000fca8:	f0 08 12 00 	clz	r8,r8
8000fcac:	c0 d0       	breq	8000fcc6 <__avr32_udiv64+0x36>
8000fcae:	f6 08 09 4b 	lsl	r11,r11,r8
8000fcb2:	f0 09 11 20 	rsub	r9,r8,32
8000fcb6:	f8 08 09 4c 	lsl	r12,r12,r8
8000fcba:	f4 09 0a 49 	lsr	r9,r10,r9
8000fcbe:	f4 08 09 43 	lsl	r3,r10,r8
8000fcc2:	f3 eb 10 0b 	or	r11,r9,r11
8000fcc6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fcca:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fcce:	f6 0e 0d 00 	divu	r0,r11,lr
8000fcd2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fcd6:	00 99       	mov	r9,r0
8000fcd8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fcdc:	e0 0a 02 48 	mul	r8,r0,r10
8000fce0:	10 3b       	cp.w	r11,r8
8000fce2:	c0 a2       	brcc	8000fcf6 <__avr32_udiv64+0x66>
8000fce4:	20 19       	sub	r9,1
8000fce6:	18 0b       	add	r11,r12
8000fce8:	18 3b       	cp.w	r11,r12
8000fcea:	c0 63       	brcs	8000fcf6 <__avr32_udiv64+0x66>
8000fcec:	10 3b       	cp.w	r11,r8
8000fcee:	f7 b9 03 01 	sublo	r9,1
8000fcf2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fcf6:	f6 08 01 01 	sub	r1,r11,r8
8000fcfa:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fcfe:	e2 0e 0d 00 	divu	r0,r1,lr
8000fd02:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fd06:	00 98       	mov	r8,r0
8000fd08:	e0 0a 02 4a 	mul	r10,r0,r10
8000fd0c:	14 33       	cp.w	r3,r10
8000fd0e:	c0 82       	brcc	8000fd1e <__avr32_udiv64+0x8e>
8000fd10:	20 18       	sub	r8,1
8000fd12:	18 03       	add	r3,r12
8000fd14:	18 33       	cp.w	r3,r12
8000fd16:	c0 43       	brcs	8000fd1e <__avr32_udiv64+0x8e>
8000fd18:	14 33       	cp.w	r3,r10
8000fd1a:	f7 b8 03 01 	sublo	r8,1
8000fd1e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000fd22:	cd f8       	rjmp	8000fee0 <__avr32_udiv64+0x250>
8000fd24:	58 08       	cp.w	r8,0
8000fd26:	c0 51       	brne	8000fd30 <__avr32_udiv64+0xa0>
8000fd28:	30 19       	mov	r9,1
8000fd2a:	f2 08 0d 08 	divu	r8,r9,r8
8000fd2e:	10 9c       	mov	r12,r8
8000fd30:	f8 06 12 00 	clz	r6,r12
8000fd34:	c0 41       	brne	8000fd3c <__avr32_udiv64+0xac>
8000fd36:	18 1b       	sub	r11,r12
8000fd38:	30 19       	mov	r9,1
8000fd3a:	c4 08       	rjmp	8000fdba <__avr32_udiv64+0x12a>
8000fd3c:	ec 01 11 20 	rsub	r1,r6,32
8000fd40:	f4 01 0a 49 	lsr	r9,r10,r1
8000fd44:	f8 06 09 4c 	lsl	r12,r12,r6
8000fd48:	f6 06 09 48 	lsl	r8,r11,r6
8000fd4c:	f6 01 0a 41 	lsr	r1,r11,r1
8000fd50:	f3 e8 10 08 	or	r8,r9,r8
8000fd54:	f8 03 16 10 	lsr	r3,r12,0x10
8000fd58:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fd5c:	e2 03 0d 00 	divu	r0,r1,r3
8000fd60:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fd64:	00 9e       	mov	lr,r0
8000fd66:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fd6a:	e0 05 02 49 	mul	r9,r0,r5
8000fd6e:	12 3b       	cp.w	r11,r9
8000fd70:	c0 a2       	brcc	8000fd84 <__avr32_udiv64+0xf4>
8000fd72:	20 1e       	sub	lr,1
8000fd74:	18 0b       	add	r11,r12
8000fd76:	18 3b       	cp.w	r11,r12
8000fd78:	c0 63       	brcs	8000fd84 <__avr32_udiv64+0xf4>
8000fd7a:	12 3b       	cp.w	r11,r9
8000fd7c:	f7 be 03 01 	sublo	lr,1
8000fd80:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fd84:	12 1b       	sub	r11,r9
8000fd86:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000fd8a:	f6 03 0d 02 	divu	r2,r11,r3
8000fd8e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000fd92:	04 99       	mov	r9,r2
8000fd94:	e4 05 02 4b 	mul	r11,r2,r5
8000fd98:	16 38       	cp.w	r8,r11
8000fd9a:	c0 a2       	brcc	8000fdae <__avr32_udiv64+0x11e>
8000fd9c:	20 19       	sub	r9,1
8000fd9e:	18 08       	add	r8,r12
8000fda0:	18 38       	cp.w	r8,r12
8000fda2:	c0 63       	brcs	8000fdae <__avr32_udiv64+0x11e>
8000fda4:	16 38       	cp.w	r8,r11
8000fda6:	f7 b9 03 01 	sublo	r9,1
8000fdaa:	f1 dc e3 08 	addcs	r8,r8,r12
8000fdae:	f4 06 09 43 	lsl	r3,r10,r6
8000fdb2:	f0 0b 01 0b 	sub	r11,r8,r11
8000fdb6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000fdba:	f8 06 16 10 	lsr	r6,r12,0x10
8000fdbe:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000fdc2:	f6 06 0d 00 	divu	r0,r11,r6
8000fdc6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fdca:	00 9a       	mov	r10,r0
8000fdcc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fdd0:	e0 0e 02 48 	mul	r8,r0,lr
8000fdd4:	10 3b       	cp.w	r11,r8
8000fdd6:	c0 a2       	brcc	8000fdea <__avr32_udiv64+0x15a>
8000fdd8:	20 1a       	sub	r10,1
8000fdda:	18 0b       	add	r11,r12
8000fddc:	18 3b       	cp.w	r11,r12
8000fdde:	c0 63       	brcs	8000fdea <__avr32_udiv64+0x15a>
8000fde0:	10 3b       	cp.w	r11,r8
8000fde2:	f7 ba 03 01 	sublo	r10,1
8000fde6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fdea:	f6 08 01 01 	sub	r1,r11,r8
8000fdee:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fdf2:	e2 06 0d 00 	divu	r0,r1,r6
8000fdf6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fdfa:	00 98       	mov	r8,r0
8000fdfc:	e0 0e 02 4b 	mul	r11,r0,lr
8000fe00:	16 33       	cp.w	r3,r11
8000fe02:	c0 82       	brcc	8000fe12 <__avr32_udiv64+0x182>
8000fe04:	20 18       	sub	r8,1
8000fe06:	18 03       	add	r3,r12
8000fe08:	18 33       	cp.w	r3,r12
8000fe0a:	c0 43       	brcs	8000fe12 <__avr32_udiv64+0x182>
8000fe0c:	16 33       	cp.w	r3,r11
8000fe0e:	f7 b8 03 01 	sublo	r8,1
8000fe12:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000fe16:	c6 98       	rjmp	8000fee8 <__avr32_udiv64+0x258>
8000fe18:	16 39       	cp.w	r9,r11
8000fe1a:	e0 8b 00 65 	brhi	8000fee4 <__avr32_udiv64+0x254>
8000fe1e:	f2 09 12 00 	clz	r9,r9
8000fe22:	c0 b1       	brne	8000fe38 <__avr32_udiv64+0x1a8>
8000fe24:	10 3a       	cp.w	r10,r8
8000fe26:	5f 2a       	srhs	r10
8000fe28:	1c 3b       	cp.w	r11,lr
8000fe2a:	5f b8       	srhi	r8
8000fe2c:	10 4a       	or	r10,r8
8000fe2e:	f2 0a 18 00 	cp.b	r10,r9
8000fe32:	c5 90       	breq	8000fee4 <__avr32_udiv64+0x254>
8000fe34:	30 18       	mov	r8,1
8000fe36:	c5 98       	rjmp	8000fee8 <__avr32_udiv64+0x258>
8000fe38:	f0 09 09 46 	lsl	r6,r8,r9
8000fe3c:	f2 03 11 20 	rsub	r3,r9,32
8000fe40:	fc 09 09 4e 	lsl	lr,lr,r9
8000fe44:	f0 03 0a 48 	lsr	r8,r8,r3
8000fe48:	f6 09 09 4c 	lsl	r12,r11,r9
8000fe4c:	f4 03 0a 42 	lsr	r2,r10,r3
8000fe50:	ef 46 ff f4 	st.w	r7[-12],r6
8000fe54:	f6 03 0a 43 	lsr	r3,r11,r3
8000fe58:	18 42       	or	r2,r12
8000fe5a:	f1 ee 10 0c 	or	r12,r8,lr
8000fe5e:	f8 01 16 10 	lsr	r1,r12,0x10
8000fe62:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fe66:	e6 01 0d 04 	divu	r4,r3,r1
8000fe6a:	e4 03 16 10 	lsr	r3,r2,0x10
8000fe6e:	08 9e       	mov	lr,r4
8000fe70:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000fe74:	e8 06 02 48 	mul	r8,r4,r6
8000fe78:	10 33       	cp.w	r3,r8
8000fe7a:	c0 a2       	brcc	8000fe8e <__avr32_udiv64+0x1fe>
8000fe7c:	20 1e       	sub	lr,1
8000fe7e:	18 03       	add	r3,r12
8000fe80:	18 33       	cp.w	r3,r12
8000fe82:	c0 63       	brcs	8000fe8e <__avr32_udiv64+0x1fe>
8000fe84:	10 33       	cp.w	r3,r8
8000fe86:	f7 be 03 01 	sublo	lr,1
8000fe8a:	e7 dc e3 03 	addcs	r3,r3,r12
8000fe8e:	10 13       	sub	r3,r8
8000fe90:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000fe94:	e6 01 0d 00 	divu	r0,r3,r1
8000fe98:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fe9c:	00 98       	mov	r8,r0
8000fe9e:	e0 06 02 46 	mul	r6,r0,r6
8000fea2:	0c 3b       	cp.w	r11,r6
8000fea4:	c0 a2       	brcc	8000feb8 <__avr32_udiv64+0x228>
8000fea6:	20 18       	sub	r8,1
8000fea8:	18 0b       	add	r11,r12
8000feaa:	18 3b       	cp.w	r11,r12
8000feac:	c0 63       	brcs	8000feb8 <__avr32_udiv64+0x228>
8000feae:	0c 3b       	cp.w	r11,r6
8000feb0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000feb4:	f7 b8 03 01 	sublo	r8,1
8000feb8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000febc:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000fec0:	0c 1b       	sub	r11,r6
8000fec2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000fec6:	06 95       	mov	r5,r3
8000fec8:	16 35       	cp.w	r5,r11
8000feca:	e0 8b 00 0a 	brhi	8000fede <__avr32_udiv64+0x24e>
8000fece:	5f 0b       	sreq	r11
8000fed0:	f4 09 09 49 	lsl	r9,r10,r9
8000fed4:	12 32       	cp.w	r2,r9
8000fed6:	5f b9       	srhi	r9
8000fed8:	f7 e9 00 09 	and	r9,r11,r9
8000fedc:	c0 60       	breq	8000fee8 <__avr32_udiv64+0x258>
8000fede:	20 18       	sub	r8,1
8000fee0:	30 09       	mov	r9,0
8000fee2:	c0 38       	rjmp	8000fee8 <__avr32_udiv64+0x258>
8000fee4:	30 09       	mov	r9,0
8000fee6:	12 98       	mov	r8,r9
8000fee8:	10 9a       	mov	r10,r8
8000feea:	12 93       	mov	r3,r9
8000feec:	10 92       	mov	r2,r8
8000feee:	12 9b       	mov	r11,r9
8000fef0:	2f dd       	sub	sp,-12
8000fef2:	d8 32       	popm	r0-r7,pc

8000fef4 <__avr32_umod64>:
8000fef4:	d4 31       	pushm	r0-r7,lr
8000fef6:	1a 97       	mov	r7,sp
8000fef8:	20 3d       	sub	sp,12
8000fefa:	10 9c       	mov	r12,r8
8000fefc:	12 95       	mov	r5,r9
8000fefe:	14 9e       	mov	lr,r10
8000ff00:	16 91       	mov	r1,r11
8000ff02:	16 96       	mov	r6,r11
8000ff04:	58 09       	cp.w	r9,0
8000ff06:	e0 81 00 81 	brne	80010008 <__avr32_umod64+0x114>
8000ff0a:	16 38       	cp.w	r8,r11
8000ff0c:	e0 88 00 12 	brls	8000ff30 <__avr32_umod64+0x3c>
8000ff10:	f0 08 12 00 	clz	r8,r8
8000ff14:	c4 e0       	breq	8000ffb0 <__avr32_umod64+0xbc>
8000ff16:	f6 08 09 46 	lsl	r6,r11,r8
8000ff1a:	f8 08 09 4c 	lsl	r12,r12,r8
8000ff1e:	f0 0b 11 20 	rsub	r11,r8,32
8000ff22:	f4 08 09 4e 	lsl	lr,r10,r8
8000ff26:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000ff2a:	f7 e6 10 06 	or	r6,r11,r6
8000ff2e:	c4 18       	rjmp	8000ffb0 <__avr32_umod64+0xbc>
8000ff30:	58 08       	cp.w	r8,0
8000ff32:	c0 51       	brne	8000ff3c <__avr32_umod64+0x48>
8000ff34:	30 19       	mov	r9,1
8000ff36:	f2 08 0d 08 	divu	r8,r9,r8
8000ff3a:	10 9c       	mov	r12,r8
8000ff3c:	f8 08 12 00 	clz	r8,r12
8000ff40:	c0 31       	brne	8000ff46 <__avr32_umod64+0x52>
8000ff42:	18 16       	sub	r6,r12
8000ff44:	c3 68       	rjmp	8000ffb0 <__avr32_umod64+0xbc>
8000ff46:	f0 03 11 20 	rsub	r3,r8,32
8000ff4a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ff4e:	f8 08 09 4c 	lsl	r12,r12,r8
8000ff52:	ec 08 09 49 	lsl	r9,r6,r8
8000ff56:	ec 03 0a 43 	lsr	r3,r6,r3
8000ff5a:	f7 e9 10 09 	or	r9,r11,r9
8000ff5e:	f8 05 16 10 	lsr	r5,r12,0x10
8000ff62:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ff66:	e6 05 0d 02 	divu	r2,r3,r5
8000ff6a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ff6e:	ec 02 02 4b 	mul	r11,r6,r2
8000ff72:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ff76:	16 3e       	cp.w	lr,r11
8000ff78:	c0 72       	brcc	8000ff86 <__avr32_umod64+0x92>
8000ff7a:	18 0e       	add	lr,r12
8000ff7c:	18 3e       	cp.w	lr,r12
8000ff7e:	c0 43       	brcs	8000ff86 <__avr32_umod64+0x92>
8000ff80:	16 3e       	cp.w	lr,r11
8000ff82:	fd dc e3 0e 	addcs	lr,lr,r12
8000ff86:	fc 0b 01 03 	sub	r3,lr,r11
8000ff8a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000ff8e:	e6 05 0d 02 	divu	r2,r3,r5
8000ff92:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ff96:	a5 36       	mul	r6,r2
8000ff98:	0c 39       	cp.w	r9,r6
8000ff9a:	c0 72       	brcc	8000ffa8 <__avr32_umod64+0xb4>
8000ff9c:	18 09       	add	r9,r12
8000ff9e:	18 39       	cp.w	r9,r12
8000ffa0:	c0 43       	brcs	8000ffa8 <__avr32_umod64+0xb4>
8000ffa2:	0c 39       	cp.w	r9,r6
8000ffa4:	f3 dc e3 09 	addcs	r9,r9,r12
8000ffa8:	f2 06 01 06 	sub	r6,r9,r6
8000ffac:	f4 08 09 4e 	lsl	lr,r10,r8
8000ffb0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000ffb4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ffb8:	ec 0a 0d 02 	divu	r2,r6,r10
8000ffbc:	fc 09 16 10 	lsr	r9,lr,0x10
8000ffc0:	ea 02 02 4b 	mul	r11,r5,r2
8000ffc4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ffc8:	16 39       	cp.w	r9,r11
8000ffca:	c0 72       	brcc	8000ffd8 <__avr32_umod64+0xe4>
8000ffcc:	18 09       	add	r9,r12
8000ffce:	18 39       	cp.w	r9,r12
8000ffd0:	c0 43       	brcs	8000ffd8 <__avr32_umod64+0xe4>
8000ffd2:	16 39       	cp.w	r9,r11
8000ffd4:	f3 dc e3 09 	addcs	r9,r9,r12
8000ffd8:	f2 0b 01 0b 	sub	r11,r9,r11
8000ffdc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ffe0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ffe4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000ffe8:	ea 0a 02 4a 	mul	r10,r5,r10
8000ffec:	14 3e       	cp.w	lr,r10
8000ffee:	c0 72       	brcc	8000fffc <__avr32_umod64+0x108>
8000fff0:	18 0e       	add	lr,r12
8000fff2:	18 3e       	cp.w	lr,r12
8000fff4:	c0 43       	brcs	8000fffc <__avr32_umod64+0x108>
8000fff6:	14 3e       	cp.w	lr,r10
8000fff8:	fd dc e3 0e 	addcs	lr,lr,r12
8000fffc:	fc 0a 01 0a 	sub	r10,lr,r10
80010000:	30 0b       	mov	r11,0
80010002:	f4 08 0a 4a 	lsr	r10,r10,r8
80010006:	c7 b8       	rjmp	800100fc <__avr32_umod64+0x208>
80010008:	16 39       	cp.w	r9,r11
8001000a:	e0 8b 00 79 	brhi	800100fc <__avr32_umod64+0x208>
8001000e:	f2 09 12 00 	clz	r9,r9
80010012:	c1 21       	brne	80010036 <__avr32_umod64+0x142>
80010014:	10 3a       	cp.w	r10,r8
80010016:	5f 2b       	srhs	r11
80010018:	0a 31       	cp.w	r1,r5
8001001a:	5f ba       	srhi	r10
8001001c:	f7 ea 10 0a 	or	r10,r11,r10
80010020:	f2 0a 18 00 	cp.b	r10,r9
80010024:	c0 60       	breq	80010030 <__avr32_umod64+0x13c>
80010026:	fc 08 01 0c 	sub	r12,lr,r8
8001002a:	e2 05 01 46 	sbc	r6,r1,r5
8001002e:	18 9e       	mov	lr,r12
80010030:	0c 9b       	mov	r11,r6
80010032:	1c 9a       	mov	r10,lr
80010034:	c6 48       	rjmp	800100fc <__avr32_umod64+0x208>
80010036:	ea 09 09 4c 	lsl	r12,r5,r9
8001003a:	f2 06 11 20 	rsub	r6,r9,32
8001003e:	f6 09 09 4b 	lsl	r11,r11,r9
80010042:	f0 09 09 42 	lsl	r2,r8,r9
80010046:	ef 46 ff f4 	st.w	r7[-12],r6
8001004a:	f0 06 0a 48 	lsr	r8,r8,r6
8001004e:	18 48       	or	r8,r12
80010050:	e2 06 0a 4c 	lsr	r12,r1,r6
80010054:	f4 09 09 43 	lsl	r3,r10,r9
80010058:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8001005c:	f4 06 0a 4a 	lsr	r10,r10,r6
80010060:	16 4a       	or	r10,r11
80010062:	f0 0b 16 10 	lsr	r11,r8,0x10
80010066:	f8 0b 0d 04 	divu	r4,r12,r11
8001006a:	f4 0c 16 10 	lsr	r12,r10,0x10
8001006e:	08 91       	mov	r1,r4
80010070:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
80010074:	e8 0e 02 46 	mul	r6,r4,lr
80010078:	0c 3c       	cp.w	r12,r6
8001007a:	c0 a2       	brcc	8001008e <__avr32_umod64+0x19a>
8001007c:	20 11       	sub	r1,1
8001007e:	10 0c       	add	r12,r8
80010080:	10 3c       	cp.w	r12,r8
80010082:	c0 63       	brcs	8001008e <__avr32_umod64+0x19a>
80010084:	0c 3c       	cp.w	r12,r6
80010086:	f7 b1 03 01 	sublo	r1,1
8001008a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8001008e:	0c 1c       	sub	r12,r6
80010090:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
80010094:	f8 0b 0d 04 	divu	r4,r12,r11
80010098:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8001009c:	08 96       	mov	r6,r4
8001009e:	e8 0e 02 4e 	mul	lr,r4,lr
800100a2:	1c 3b       	cp.w	r11,lr
800100a4:	c0 a2       	brcc	800100b8 <__avr32_umod64+0x1c4>
800100a6:	20 16       	sub	r6,1
800100a8:	10 0b       	add	r11,r8
800100aa:	10 3b       	cp.w	r11,r8
800100ac:	c0 63       	brcs	800100b8 <__avr32_umod64+0x1c4>
800100ae:	1c 3b       	cp.w	r11,lr
800100b0:	f7 b6 03 01 	sublo	r6,1
800100b4:	f7 d8 e3 0b 	addcs	r11,r11,r8
800100b8:	ed e1 11 01 	or	r1,r6,r1<<0x10
800100bc:	1c 1b       	sub	r11,lr
800100be:	e2 02 06 40 	mulu.d	r0,r1,r2
800100c2:	00 9e       	mov	lr,r0
800100c4:	02 9c       	mov	r12,r1
800100c6:	16 3c       	cp.w	r12,r11
800100c8:	e0 8b 00 08 	brhi	800100d8 <__avr32_umod64+0x1e4>
800100cc:	5f 06       	sreq	r6
800100ce:	06 30       	cp.w	r0,r3
800100d0:	5f ba       	srhi	r10
800100d2:	ed ea 00 0a 	and	r10,r6,r10
800100d6:	c0 60       	breq	800100e2 <__avr32_umod64+0x1ee>
800100d8:	fc 02 01 04 	sub	r4,lr,r2
800100dc:	f8 08 01 4c 	sbc	r12,r12,r8
800100e0:	08 9e       	mov	lr,r4
800100e2:	e6 0e 01 0a 	sub	r10,r3,lr
800100e6:	f6 0c 01 4c 	sbc	r12,r11,r12
800100ea:	ee f1 ff f4 	ld.w	r1,r7[-12]
800100ee:	f8 09 0a 4b 	lsr	r11,r12,r9
800100f2:	f4 09 0a 4a 	lsr	r10,r10,r9
800100f6:	f8 01 09 4c 	lsl	r12,r12,r1
800100fa:	18 4a       	or	r10,r12
800100fc:	2f dd       	sub	sp,-12
800100fe:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010200 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010200:	c0 08       	rjmp	80010200 <_evba>
	...

80010204 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010204:	c0 08       	rjmp	80010204 <_handle_TLB_Multiple_Hit>
	...

80010208 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010208:	c0 08       	rjmp	80010208 <_handle_Bus_Error_Data_Fetch>
	...

8001020c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8001020c:	c0 08       	rjmp	8001020c <_handle_Bus_Error_Instruction_Fetch>
	...

80010210 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010210:	c0 08       	rjmp	80010210 <_handle_NMI>
	...

80010214 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010214:	c0 08       	rjmp	80010214 <_handle_Instruction_Address>
	...

80010218 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010218:	c0 08       	rjmp	80010218 <_handle_ITLB_Protection>
	...

8001021c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8001021c:	c0 08       	rjmp	8001021c <_handle_Breakpoint>
	...

80010220 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010220:	c0 08       	rjmp	80010220 <_handle_Illegal_Opcode>
	...

80010224 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010224:	c0 08       	rjmp	80010224 <_handle_Unimplemented_Instruction>
	...

80010228 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010228:	c0 08       	rjmp	80010228 <_handle_Privilege_Violation>
	...

8001022c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8001022c:	c0 08       	rjmp	8001022c <_handle_Floating_Point>
	...

80010230 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010230:	c0 08       	rjmp	80010230 <_handle_Coprocessor_Absent>
	...

80010234 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010234:	c0 08       	rjmp	80010234 <_handle_Data_Address_Read>
	...

80010238 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010238:	c0 08       	rjmp	80010238 <_handle_Data_Address_Write>
	...

8001023c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8001023c:	c0 08       	rjmp	8001023c <_handle_DTLB_Protection_Read>
	...

80010240 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010240:	c0 08       	rjmp	80010240 <_handle_DTLB_Protection_Write>
	...

80010244 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010244:	c0 08       	rjmp	80010244 <_handle_DTLB_Modified>
	...

80010250 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010250:	c0 08       	rjmp	80010250 <_handle_ITLB_Miss>
	...

80010260 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010260:	c0 08       	rjmp	80010260 <_handle_DTLB_Miss_Read>
	...

80010270 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010270:	c0 08       	rjmp	80010270 <_handle_DTLB_Miss_Write>
	...

80010300 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010300:	49 3f       	lddpc	pc,8001034c <ipr_val+0x10>
80010302:	d7 03       	nop

80010304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010304:	30 0c       	mov	r12,0
80010306:	fe b0 b5 cb 	rcall	80006e9c <_get_interrupt_handler>
8001030a:	58 0c       	cp.w	r12,0
8001030c:	f8 0f 17 10 	movne	pc,r12
80010310:	d6 03       	rete

80010312 <_int1>:
80010312:	30 1c       	mov	r12,1
80010314:	fe b0 b5 c4 	rcall	80006e9c <_get_interrupt_handler>
80010318:	58 0c       	cp.w	r12,0
8001031a:	f8 0f 17 10 	movne	pc,r12
8001031e:	d6 03       	rete

80010320 <_int2>:
80010320:	30 2c       	mov	r12,2
80010322:	fe b0 b5 bd 	rcall	80006e9c <_get_interrupt_handler>
80010326:	58 0c       	cp.w	r12,0
80010328:	f8 0f 17 10 	movne	pc,r12
8001032c:	d6 03       	rete

8001032e <_int3>:
8001032e:	30 3c       	mov	r12,3
80010330:	fe b0 b5 b6 	rcall	80006e9c <_get_interrupt_handler>
80010334:	58 0c       	cp.w	r12,0
80010336:	f8 0f 17 10 	movne	pc,r12
8001033a:	d6 03       	rete

8001033c <ipr_val>:
8001033c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8001034c:	80 00 80 8c d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001035c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001036c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001037c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001038c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001039c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800103ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800103bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800103cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800103dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800103ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800103fc:	d7 03 d7 03                                         ....
